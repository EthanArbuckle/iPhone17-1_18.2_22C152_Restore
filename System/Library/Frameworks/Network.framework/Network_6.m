void sub_18344BAB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,void *a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *a47)
{
  void *v47;
  void *v48;
  void *v49;

  _Unwind_Resume(a1);
}

void nw_http_request_access_extended_connect_protocol(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  v5 = v4;
  if (v3)
  {
    if (v4)
    {
LABEL_3:
      _nw_http_request_access_extended_connect_protocol((uint64_t)v3, v5);

      return;
    }
  }
  else
  {
    v6 = __nwlog_obj();
    os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    v7 = (void *)_os_log_send_and_compose_impl();

    if (__nwlog_abort((uint64_t)v7)) {
      goto LABEL_8;
    }
    free(v7);
    if (v5) {
      goto LABEL_3;
    }
  }
  v8 = __nwlog_obj();
  os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
  v9 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v9))
  {
    free(v9);
    goto LABEL_3;
  }
LABEL_8:
  __break(1u);
}

void tcp_connection_write_buffer(void *a1, const void *a2, size_t a3, void *a4)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  v7 = a1;
  id v8 = a4;
  v9 = (void (**)(void, void))v8;
  if (!v7)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v11 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v30 = "tcp_connection_write_buffer";
    v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (!__nwlog_fault(v12, &type, &v27)) {
      goto LABEL_17;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = (id)gLogObj;
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)buf = 136446210;
      v30 = "tcp_connection_write_buffer";
      v15 = "%{public}s called with null connection";
    }
    else
    {
      if (v27)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v13 = (id)gLogObj;
        os_log_type_t v17 = type;
        BOOL v18 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)buf = 136446466;
            v30 = "tcp_connection_write_buffer";
            __int16 v31 = 2082;
            v32 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v13, v17, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
LABEL_17:
          if (!v12) {
            goto LABEL_27;
          }
          goto LABEL_26;
        }
        if (!v18) {
          goto LABEL_25;
        }
        *(_DWORD *)buf = 136446210;
        v30 = "tcp_connection_write_buffer";
        v15 = "%{public}s called with null connection, no backtrace";
        v19 = v13;
        os_log_type_t v20 = v17;
        goto LABEL_24;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = (id)gLogObj;
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)buf = 136446210;
      v30 = "tcp_connection_write_buffer";
      v15 = "%{public}s called with null connection, backtrace limit exceeded";
    }
    v19 = v13;
    os_log_type_t v20 = v14;
LABEL_24:
    _os_log_impl(&dword_1830D4000, v19, v20, v15, buf, 0xCu);
LABEL_25:

    if (!v12) {
      goto LABEL_27;
    }
    goto LABEL_26;
  }
  if (!v7[2])
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = (id)gLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v30 = "tcp_connection_write_buffer";
      _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_ERROR, "%{public}s API Misuse: Function must be called after tcp_connection_start", buf, 0xCu);
    }
    goto LABEL_20;
  }
  if (v8)
  {
    v10 = dispatch_data_create(a2, a3, 0, 0);
    if (v10) {
      tcp_connection_write(v7, v10, v9);
    }
    else {
      v9[2](v9, 12);
    }
LABEL_20:

    goto LABEL_27;
  }
  v21 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v30 = "tcp_connection_write_buffer";
  v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v27 = 0;
  if (!__nwlog_fault(v12, &type, &v27)) {
    goto LABEL_17;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    v22 = __nwlog_obj();
    os_log_type_t v23 = type;
    if (os_log_type_enabled(v22, type))
    {
      *(_DWORD *)buf = 136446210;
      v30 = "tcp_connection_write_buffer";
      v24 = "%{public}s called with null handler";
LABEL_44:
      _os_log_impl(&dword_1830D4000, v22, v23, v24, buf, 0xCu);
      goto LABEL_45;
    }
    goto LABEL_45;
  }
  if (!v27)
  {
    v22 = __nwlog_obj();
    os_log_type_t v23 = type;
    if (os_log_type_enabled(v22, type))
    {
      *(_DWORD *)buf = 136446210;
      v30 = "tcp_connection_write_buffer";
      v24 = "%{public}s called with null handler, backtrace limit exceeded";
      goto LABEL_44;
    }
LABEL_45:

    goto LABEL_17;
  }
  v25 = (char *)__nw_create_backtrace_string();
  v22 = __nwlog_obj();
  os_log_type_t v23 = type;
  BOOL v26 = os_log_type_enabled(v22, type);
  if (!v25)
  {
    if (v26)
    {
      *(_DWORD *)buf = 136446210;
      v30 = "tcp_connection_write_buffer";
      v24 = "%{public}s called with null handler, no backtrace";
      goto LABEL_44;
    }
    goto LABEL_45;
  }
  if (v26)
  {
    *(_DWORD *)buf = 136446466;
    v30 = "tcp_connection_write_buffer";
    __int16 v31 = 2082;
    v32 = v25;
    _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v25);
  if (v12) {
LABEL_26:
  }
    free(v12);
LABEL_27:
}

void nw_protocol_webtransport_session_connected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v118 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_connected";
    v72 = (char *)_os_log_send_and_compose_impl();
    v112[0] = 16;
    LOBYTE(v104[0]) = 0;
    if (!__nwlog_fault(v72, v112, v104)) {
      goto LABEL_153;
    }
    if (v112[0] == 17)
    {
      v73 = __nwlog_obj();
      os_log_type_t v74 = v112[0];
      if (!os_log_type_enabled(v73, (os_log_type_t)v112[0])) {
        goto LABEL_153;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_connected";
      v75 = "%{public}s called with null protocol";
      goto LABEL_152;
    }
    if (!LOBYTE(v104[0]))
    {
      v73 = __nwlog_obj();
      os_log_type_t v74 = v112[0];
      if (!os_log_type_enabled(v73, (os_log_type_t)v112[0])) {
        goto LABEL_153;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_connected";
      v75 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_152;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v73 = __nwlog_obj();
    os_log_type_t v74 = v112[0];
    BOOL v82 = os_log_type_enabled(v73, (os_log_type_t)v112[0]);
    if (!backtrace_string)
    {
      if (!v82) {
        goto LABEL_153;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_connected";
      v75 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_152;
    }
    if (v82)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_connected";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl(&dword_1830D4000, v73, v74, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
    goto LABEL_153;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_connected";
    v72 = (char *)_os_log_send_and_compose_impl();
    v112[0] = 16;
    LOBYTE(v104[0]) = 0;
    if (!__nwlog_fault(v72, v112, v104)) {
      goto LABEL_153;
    }
    if (v112[0] == 17)
    {
      v73 = __nwlog_obj();
      os_log_type_t v74 = v112[0];
      if (!os_log_type_enabled(v73, (os_log_type_t)v112[0])) {
        goto LABEL_153;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_connected";
      v75 = "%{public}s called with null webtransport_session";
      goto LABEL_152;
    }
    if (!LOBYTE(v104[0]))
    {
      v73 = __nwlog_obj();
      os_log_type_t v74 = v112[0];
      if (!os_log_type_enabled(v73, (os_log_type_t)v112[0])) {
        goto LABEL_153;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_connected";
      v75 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
      goto LABEL_152;
    }
    v83 = (char *)__nw_create_backtrace_string();
    v73 = __nwlog_obj();
    os_log_type_t v74 = v112[0];
    BOOL v84 = os_log_type_enabled(v73, (os_log_type_t)v112[0]);
    if (!v83)
    {
      if (!v84) {
        goto LABEL_153;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_connected";
      v75 = "%{public}s called with null webtransport_session, no backtrace";
      goto LABEL_152;
    }
    if (!v84) {
      goto LABEL_142;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_connected";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v83;
    v85 = "%{public}s called with null webtransport_session, dumping backtrace:%{public}s";
    goto LABEL_141;
  }
  if ((handle[548] & 2) == 0)
  {
    if (gLogDatapath)
    {
      v76 = __nwlog_obj();
      if (os_log_type_enabled(v76, OS_LOG_TYPE_DEBUG))
      {
        int v77 = *((_DWORD *)handle + 115);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_connected";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = handle + 464;
        *(_WORD *)&buf[22] = 2080;
        v108 = " ";
        LOWORD(v109) = 1024;
        *(_DWORD *)((char *)&v109 + 2) = v77;
        _os_log_impl(&dword_1830D4000, v76, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> Got a connected event from the lower layer", buf, 0x26u);
      }
    }
  }
  if (a1->output_handler != a2)
  {
    if ((handle[548] & 2) == 0 && gLogDatapath)
    {
      v78 = __nwlog_obj();
      if (os_log_type_enabled(v78, OS_LOG_TYPE_DEBUG))
      {
        int v79 = *((_DWORD *)handle + 115);
        identifier = a2->identifier;
        *(_DWORD *)buf = 136447490;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_connected";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = handle + 464;
        *(_WORD *)&buf[22] = 2080;
        v108 = " ";
        LOWORD(v109) = 1024;
        *(_DWORD *)((char *)&v109 + 2) = v79;
        HIWORD(v109) = 2048;
        v110 = a2;
        LOWORD(v111) = 2080;
        *(void *)((char *)&v111 + 2) = identifier;
        _os_log_impl(&dword_1830D4000, v78, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> connected protocol %p (%s) is not our output_handler, ignoring", buf, 0x3Au);
      }
    }
    return;
  }
  uint64_t v5 = *((void *)handle + 4);
  if (!v5 || *((_DWORD *)handle + 112) != 2) {
    goto LABEL_40;
  }
  v6 = *(void **)(v5 + 16);
  if (nw_protocol_http2_identifier::onceToken[0] != -1) {
    dispatch_once(nw_protocol_http2_identifier::onceToken, &__block_literal_global_85036);
  }
  if (!nw_protocols_are_equal(v6, &nw_protocol_http2_identifier::http2_protocol_identifier))
  {
    v7 = *(void **)(v5 + 16);
    if (nw_protocol_http3_identifier::onceToken[0] != -1) {
      dispatch_once(nw_protocol_http3_identifier::onceToken, &__block_literal_global_13_62491);
    }
    if (!nw_protocols_are_equal(v7, &nw_protocol_http3_identifier::http3_protocol_identifier))
    {
      id v8 = *(void **)(v5 + 16);
      if (nw_protocol_http_messaging_identifier::onceToken[0] != -1) {
        dispatch_once(nw_protocol_http_messaging_identifier::onceToken, &__block_literal_global_77555);
      }
      if (!nw_protocols_are_equal(v8, nw_protocol_http_messaging_identifier::protocol_identifier)) {
        goto LABEL_40;
      }
    }
  }
  v9 = (atomic_uchar *)nw_protocol_copy_info(v5, 255);
  v104[0] = MEMORY[0x1E4F143A8];
  v104[1] = 0x40000000;
  v104[2] = ___ZL33nw_webtransport_session_establishP23nw_webtransport_session_block_invoke;
  v104[3] = &__block_descriptor_tmp_52_34643;
  v104[4] = handle;
  nw_array_apply(v9, (uint64_t)v104);
  v10 = (void *)*((void *)handle + 47);
  if (!v10)
  {
    if (v9) {
      os_release(v9);
    }
    goto LABEL_68;
  }
  int version = nw_http_connection_metadata_get_version(v10);
  int v12 = version;
  if (version == 4)
  {
    int v13 = 0;
LABEL_27:
    *((_DWORD *)handle + 112) = v13;
    goto LABEL_28;
  }
  if (version == 5)
  {
    int v13 = 1;
    goto LABEL_27;
  }
LABEL_28:
  os_log_type_t v14 = *(void **)(v5 + 16);
  if (nw_protocol_http_messaging_identifier::onceToken[0] != -1) {
    dispatch_once(nw_protocol_http_messaging_identifier::onceToken, &__block_literal_global_77555);
  }
  BOOL v15 = nw_protocols_are_equal(v14, nw_protocol_http_messaging_identifier::protocol_identifier);
  char v16 = handle[548];
  if (v15)
  {
    v16 |= 0x40u;
    handle[548] = v16;
  }
  if ((v16 & 2) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v17 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      int v18 = *((_DWORD *)handle + 115);
      if (v12 == 4) {
        int v19 = 2;
      }
      else {
        int v19 = 3;
      }
      *(_DWORD *)buf = 136447234;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_establish";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = handle + 464;
      *(_WORD *)&buf[22] = 2080;
      v108 = " ";
      LOWORD(v109) = 1024;
      *(_DWORD *)((char *)&v109 + 2) = v18;
      HIWORD(v109) = 1024;
      LODWORD(v110) = v19;
      _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Establishing webtransport session for HTTP/%u", buf, 0x2Cu);
    }
  }
  if (v9) {
    os_release(v9);
  }
LABEL_40:
  unsigned int v20 = *((_DWORD *)handle + 112);
  if (v20 <= 1)
  {
    int v21 = *((_DWORD *)handle + 111);
    if ((handle[548] & 1) == 0)
    {
      if (v21) {
        return;
      }
      if ((handle[548] & 2) == 0)
      {
        if (gLogDatapath)
        {
          v86 = __nwlog_obj();
          if (os_log_type_enabled(v86, OS_LOG_TYPE_DEBUG))
          {
            int v87 = *((_DWORD *)handle + 115);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_webtransport_http_send_connect";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = handle + 464;
            *(_WORD *)&buf[22] = 2080;
            v108 = " ";
            LOWORD(v109) = 1024;
            *(_DWORD *)((char *)&v109 + 2) = v87;
            _os_log_impl(&dword_1830D4000, v86, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
          }
        }
      }
      if (handle[548])
      {
LABEL_119:
        *((_DWORD *)handle + 111) = 1;
        return;
      }
      v22 = *((void *)handle + 45);
      v105 = 0;
      hostname = nw_endpoint_get_hostname(v22);
      int port = nw_endpoint_get_port(v22);
      asprintf(&v105, "%s:%u", hostname, port);
      url_path = nw_parameters_copy_url_endpoint(*((void **)handle + 43));
      BOOL v26 = url_path;
      if (url_path) {
        url_path = (void *)nw_endpoint_get_url_path(url_path);
      }
      if (url_path) {
        char v27 = (const char *)url_path;
      }
      else {
        char v27 = "/";
      }
      v28 = (void *)_nw_http_request_create("CONNECT", "https", v105, v27);
      if (v105)
      {
        free(v105);
        v105 = 0;
      }
      nw_http_request_set_extended_connect_protocol(v28, (uint64_t)"webtransport");
      metadata_for_request = nw_http_create_metadata_for_request(v28);
      uint64_t v30 = *((void *)handle + 4);
      if ((handle[548] & 2) == 0)
      {
        if (gLogDatapath)
        {
          v88 = __nwlog_obj();
          if (os_log_type_enabled(v88, OS_LOG_TYPE_DEBUG))
          {
            int v89 = *((_DWORD *)handle + 115);
            *(_DWORD *)v112 = 136446978;
            *(void *)&v112[4] = "nw_webtransport_session_send_metadata";
            *(_WORD *)&v112[12] = 2082;
            *(void *)&v112[14] = handle + 464;
            *(_WORD *)&v112[22] = 2080;
            v113 = " ";
            __int16 v114 = 1024;
            int v115 = v89;
            _os_log_impl(&dword_1830D4000, v88, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", v112, 0x26u);
          }
        }
      }
      v106[0] = 0;
      v106[1] = v106;
      int output_frames = nw_protocol_get_output_frames(v30, (uint64_t)handle, 0, 0, 1, (uint64_t)v106);
      if ((handle[548] & 2) == 0)
      {
        if (gLogDatapath)
        {
          int v90 = output_frames;
          v91 = __nwlog_obj();
          BOOL v92 = os_log_type_enabled(v91, OS_LOG_TYPE_DEBUG);
          int output_frames = v90;
          if (v92)
          {
            int v93 = *((_DWORD *)handle + 115);
            *(_DWORD *)v112 = 136447234;
            *(void *)&v112[4] = "nw_webtransport_session_send_metadata";
            *(_WORD *)&v112[12] = 2082;
            *(void *)&v112[14] = handle + 464;
            *(_WORD *)&v112[22] = 2080;
            v113 = " ";
            __int16 v114 = 1024;
            int v115 = v93;
            __int16 v116 = 1024;
            int v117 = v90;
            _os_log_impl(&dword_1830D4000, v91, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> Got %u output frames", v112, 0x2Cu);
            int output_frames = v90;
          }
        }
      }
      if (output_frames)
      {
        *(void *)v112 = 0;
        *(void *)&v112[8] = v112;
        *(void *)&v112[16] = 0x2000000000;
        LOBYTE(v113) = 0;
        *(void *)buf = MEMORY[0x1E4F143A8];
        *(void *)&buf[8] = 0x40000000;
        *(void *)&buf[16] = ___ZL37nw_webtransport_session_send_metadataP23nw_webtransport_sessionP20nw_protocol_metadataP11nw_protocol_block_invoke;
        v108 = (const char *)&unk_1E5240478;
        v109 = v112;
        v110 = (nw_protocol *)v106;
        *(void *)&long long v111 = handle;
        *((void *)&v111 + 1) = metadata_for_request;
        uint64_t v32 = v106[0];
        do
        {
          if (!v32) {
            break;
          }
          uint64_t v33 = *(void *)(v32 + 32);
          char v34 = (*(uint64_t (**)(unsigned char *))&buf[16])(buf);
          uint64_t v32 = v33;
        }
        while ((v34 & 1) != 0);
        char v35 = nw_protocol_finalize_output_frames(v30, (uint64_t)v106);
        _Block_object_dispose(v112, 8);
        char v36 = handle[548];
        if (v35)
        {
          if ((handle[548] & 2) != 0) {
            goto LABEL_113;
          }
          v37 = __nwlog_obj();
          if (!os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_113;
          }
          int v38 = *((_DWORD *)handle + 115);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_webtransport_http_send_connect";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = handle + 464;
          *(_WORD *)&buf[22] = 2080;
          v108 = " ";
          LOWORD(v109) = 1024;
          *(_DWORD *)((char *)&v109 + 2) = v38;
          v39 = "%{public}s %{public}s%s<i%u> Sent CONNECT request to WebTransport server";
          v40 = v37;
          os_log_type_t v41 = OS_LOG_TYPE_DEBUG;
          goto LABEL_99;
        }
      }
      else
      {
        char v36 = handle[548];
      }
      if (*((_DWORD *)handle + 111) != 5)
      {
        if ((v36 & 2) == 0)
        {
          v62 = __nwlog_obj();
          if (os_log_type_enabled(v62, OS_LOG_TYPE_INFO))
          {
            int v63 = *((_DWORD *)handle + 115);
            *(_DWORD *)buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_webtransport_session_terminate";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = handle + 464;
            *(_WORD *)&buf[22] = 2080;
            v108 = " ";
            LOWORD(v109) = 1024;
            *(_DWORD *)((char *)&v109 + 2) = v63;
            HIWORD(v109) = 1024;
            LODWORD(v110) = 12;
            _os_log_impl(&dword_1830D4000, v62, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Closing webtransport session with error %{darwin.errno}d", buf, 0x2Cu);
          }
        }
        *((_DWORD *)handle + 111) = 5;
        v64 = (char *)*((void *)handle + 23);
        if (v64)
        {
          *(void *)buf = MEMORY[0x1E4F143A8];
          *(void *)&buf[8] = 0x40000000;
          *(void *)&buf[16] = ___ZL33nw_webtransport_session_terminateP23nw_webtransport_sessioni_block_invoke;
          v108 = (const char *)&__block_descriptor_tmp_26_33833;
          LODWORD(v109) = 12;
          nw_hash_table_apply(v64, (uint64_t)buf);
        }
        uint64_t v65 = *((void *)handle + 53);
        if (v65)
        {
          v66 = *(void **)(v65 + 48);
          nw_protocol_error(v66, *((void *)handle + 53));
          nw_protocol_disconnected(v66, v65);
        }
        uint64_t v67 = *((void *)handle + 41);
        if (v67)
        {
          do
          {
            uint64_t v68 = *(void *)(v67 + 112);
            v69 = *(void **)(v67 + 48);
            nw_protocol_error(v69, v67);
            nw_protocol_disconnected(v69, v67);
            uint64_t v67 = v68;
          }
          while (v68);
        }
        uint64_t v70 = *((void *)handle + 52);
        if (v70)
        {
          v71 = *(void **)(v70 + 48);
          nw_protocol_error(v71, *((void *)handle + 52));
          nw_protocol_disconnected(v71, v70);
        }
        if (*((void *)handle + 4))
        {
          nw_protocol_remove_instance((uint64_t)handle);
          nw_protocol_disconnect(*((void **)handle + 4), (uint64_t)handle);
        }
        goto LABEL_113;
      }
      if ((v36 & 2) != 0 || (v60 = __nwlog_obj(), !os_log_type_enabled(v60, OS_LOG_TYPE_INFO)))
      {
LABEL_113:
        if (metadata_for_request) {
          os_release(metadata_for_request);
        }
        if (v28) {
          os_release(v28);
        }
        if (v26) {
          os_release(v26);
        }
        goto LABEL_119;
      }
      int v61 = *((_DWORD *)handle + 115);
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_terminate";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = handle + 464;
      *(_WORD *)&buf[22] = 2080;
      v108 = " ";
      LOWORD(v109) = 1024;
      *(_DWORD *)((char *)&v109 + 2) = v61;
      v39 = "%{public}s %{public}s%s<i%u> Session already terminated, ignoring";
      v40 = v60;
      os_log_type_t v41 = OS_LOG_TYPE_INFO;
LABEL_99:
      _os_log_impl(&dword_1830D4000, v40, v41, v39, buf, 0x26u);
      goto LABEL_113;
    }
    if (v21) {
      return;
    }
    if (v20 == 1)
    {
      uint64_t v56 = *((void *)handle + 6);
      if (v56)
      {
        uint64_t v57 = *(void *)(v56 + 40);
        if (v57)
        {
          nw_protocol_replace_input_handler(*((void *)handle + 4), (uint64_t)handle, *(void *)(v56 + 40));
          *((void *)handle + 52) = v57;
          nw_protocol_set_output_handler((uint64_t)handle, 0);
          nw_protocol_set_input_handler((uint64_t)handle, 0);
LABEL_90:
          *((_DWORD *)handle + 111) = 2;
          return;
        }
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_webtransport_http3_setup_placeholder_stream";
        v94 = (char *)_os_log_send_and_compose_impl();
        v112[0] = 16;
        LOBYTE(v106[0]) = 0;
        if (!__nwlog_fault(v94, v112, v106)) {
          goto LABEL_211;
        }
        if (v112[0] == 17)
        {
          v95 = __nwlog_obj();
          os_log_type_t v96 = v112[0];
          if (!os_log_type_enabled(v95, (os_log_type_t)v112[0])) {
            goto LABEL_211;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_webtransport_http3_setup_placeholder_stream";
          v97 = "%{public}s called with null webtransport_stream";
          goto LABEL_210;
        }
        if (!LOBYTE(v106[0]))
        {
          v95 = __nwlog_obj();
          os_log_type_t v96 = v112[0];
          if (!os_log_type_enabled(v95, (os_log_type_t)v112[0])) {
            goto LABEL_211;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_webtransport_http3_setup_placeholder_stream";
          v97 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
          goto LABEL_210;
        }
        v100 = (char *)__nw_create_backtrace_string();
        v95 = __nwlog_obj();
        os_log_type_t v96 = v112[0];
        BOOL v101 = os_log_type_enabled(v95, (os_log_type_t)v112[0]);
        if (v100)
        {
          if (v101)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_webtransport_http3_setup_placeholder_stream";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v100;
            _os_log_impl(&dword_1830D4000, v95, v96, "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v100);
          if (!v94) {
            goto LABEL_90;
          }
          goto LABEL_212;
        }
        if (v101)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_webtransport_http3_setup_placeholder_stream";
          v97 = "%{public}s called with null webtransport_stream, no backtrace";
LABEL_210:
          _os_log_impl(&dword_1830D4000, v95, v96, v97, buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_webtransport_http3_setup_placeholder_stream";
        v94 = (char *)_os_log_send_and_compose_impl();
        v112[0] = 16;
        LOBYTE(v106[0]) = 0;
        if (!__nwlog_fault(v94, v112, v106)) {
          goto LABEL_211;
        }
        if (v112[0] == 17)
        {
          v95 = __nwlog_obj();
          os_log_type_t v96 = v112[0];
          if (!os_log_type_enabled(v95, (os_log_type_t)v112[0])) {
            goto LABEL_211;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_webtransport_http3_setup_placeholder_stream";
          v97 = "%{public}s called with null input_protocol";
          goto LABEL_210;
        }
        if (!LOBYTE(v106[0]))
        {
          v95 = __nwlog_obj();
          os_log_type_t v96 = v112[0];
          if (!os_log_type_enabled(v95, (os_log_type_t)v112[0])) {
            goto LABEL_211;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_webtransport_http3_setup_placeholder_stream";
          v97 = "%{public}s called with null input_protocol, backtrace limit exceeded";
          goto LABEL_210;
        }
        v98 = (char *)__nw_create_backtrace_string();
        v95 = __nwlog_obj();
        os_log_type_t v96 = v112[0];
        BOOL v99 = os_log_type_enabled(v95, (os_log_type_t)v112[0]);
        if (!v98)
        {
          if (!v99) {
            goto LABEL_211;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_webtransport_http3_setup_placeholder_stream";
          v97 = "%{public}s called with null input_protocol, no backtrace";
          goto LABEL_210;
        }
        if (v99)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_webtransport_http3_setup_placeholder_stream";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v98;
          _os_log_impl(&dword_1830D4000, v95, v96, "%{public}s called with null input_protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v98);
      }
LABEL_211:
      if (!v94) {
        goto LABEL_90;
      }
LABEL_212:
      free(v94);
      goto LABEL_90;
    }
    *((_DWORD *)handle + 111) = 3;
    uint64_t v58 = *((void *)handle + 6);
    if (v58)
    {
      uint64_t v59 = *(void *)(v58 + 40);
      if (v59)
      {
        *((void *)handle + 52) = v59;
        return;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_http2_setup_placeholder_stream";
      v72 = (char *)_os_log_send_and_compose_impl();
      v112[0] = 16;
      LOBYTE(v106[0]) = 0;
      if (!__nwlog_fault(v72, v112, v106)) {
        goto LABEL_153;
      }
      if (v112[0] == 17)
      {
        v73 = __nwlog_obj();
        os_log_type_t v74 = v112[0];
        if (os_log_type_enabled(v73, (os_log_type_t)v112[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_webtransport_http2_setup_placeholder_stream";
          v75 = "%{public}s called with null webtransport_stream";
          goto LABEL_152;
        }
        goto LABEL_153;
      }
      if (!LOBYTE(v106[0]))
      {
        v73 = __nwlog_obj();
        os_log_type_t v74 = v112[0];
        if (os_log_type_enabled(v73, (os_log_type_t)v112[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_webtransport_http2_setup_placeholder_stream";
          v75 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
          goto LABEL_152;
        }
        goto LABEL_153;
      }
      v83 = (char *)__nw_create_backtrace_string();
      v73 = __nwlog_obj();
      os_log_type_t v74 = v112[0];
      BOOL v103 = os_log_type_enabled(v73, (os_log_type_t)v112[0]);
      if (!v83)
      {
        if (v103)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_webtransport_http2_setup_placeholder_stream";
          v75 = "%{public}s called with null webtransport_stream, no backtrace";
          goto LABEL_152;
        }
        goto LABEL_153;
      }
      if (v103)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_webtransport_http2_setup_placeholder_stream";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v83;
        v85 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
        goto LABEL_141;
      }
LABEL_142:
      free(v83);
      if (!v72) {
        return;
      }
LABEL_154:
      free(v72);
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_webtransport_http2_setup_placeholder_stream";
    v72 = (char *)_os_log_send_and_compose_impl();
    v112[0] = 16;
    LOBYTE(v106[0]) = 0;
    if (!__nwlog_fault(v72, v112, v106)) {
      goto LABEL_153;
    }
    if (v112[0] == 17)
    {
      v73 = __nwlog_obj();
      os_log_type_t v74 = v112[0];
      if (os_log_type_enabled(v73, (os_log_type_t)v112[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_webtransport_http2_setup_placeholder_stream";
        v75 = "%{public}s called with null input_protocol";
LABEL_152:
        _os_log_impl(&dword_1830D4000, v73, v74, v75, buf, 0xCu);
      }
LABEL_153:
      if (!v72) {
        return;
      }
      goto LABEL_154;
    }
    if (!LOBYTE(v106[0]))
    {
      v73 = __nwlog_obj();
      os_log_type_t v74 = v112[0];
      if (os_log_type_enabled(v73, (os_log_type_t)v112[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_webtransport_http2_setup_placeholder_stream";
        v75 = "%{public}s called with null input_protocol, backtrace limit exceeded";
        goto LABEL_152;
      }
      goto LABEL_153;
    }
    v83 = (char *)__nw_create_backtrace_string();
    v73 = __nwlog_obj();
    os_log_type_t v74 = v112[0];
    BOOL v102 = os_log_type_enabled(v73, (os_log_type_t)v112[0]);
    if (!v83)
    {
      if (v102)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_webtransport_http2_setup_placeholder_stream";
        v75 = "%{public}s called with null input_protocol, no backtrace";
        goto LABEL_152;
      }
      goto LABEL_153;
    }
    if (!v102) {
      goto LABEL_142;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_webtransport_http2_setup_placeholder_stream";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v83;
    v85 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
LABEL_141:
    _os_log_impl(&dword_1830D4000, v73, v74, v85, buf, 0x16u);
    goto LABEL_142;
  }
  if ((handle[548] & 2) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v42 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      int v43 = *((_DWORD *)handle + 115);
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_establish";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = handle + 464;
      *(_WORD *)&buf[22] = 2080;
      v108 = " ";
      LOWORD(v109) = 1024;
      *(_DWORD *)((char *)&v109 + 2) = v43;
      _os_log_impl(&dword_1830D4000, v42, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> Unknown webtransport session transport mode for establishment, failing", buf, 0x26u);
    }
  }
LABEL_68:
  if (*((_DWORD *)handle + 111) == 5)
  {
    if ((handle[548] & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v44 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        int v45 = *((_DWORD *)handle + 115);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_terminate";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = handle + 464;
        *(_WORD *)&buf[22] = 2080;
        v108 = " ";
        LOWORD(v109) = 1024;
        *(_DWORD *)((char *)&v109 + 2) = v45;
        _os_log_impl(&dword_1830D4000, v44, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Session already terminated, ignoring", buf, 0x26u);
      }
    }
  }
  else
  {
    if ((handle[548] & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v46 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        int v47 = *((_DWORD *)handle + 115);
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_terminate";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = handle + 464;
        *(_WORD *)&buf[22] = 2080;
        v108 = " ";
        LOWORD(v109) = 1024;
        *(_DWORD *)((char *)&v109 + 2) = v47;
        HIWORD(v109) = 1024;
        LODWORD(v110) = 57;
        _os_log_impl(&dword_1830D4000, v46, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Closing webtransport session with error %{darwin.errno}d", buf, 0x2Cu);
      }
    }
    *((_DWORD *)handle + 111) = 5;
    v48 = (char *)*((void *)handle + 23);
    if (v48)
    {
      *(void *)buf = MEMORY[0x1E4F143A8];
      *(void *)&buf[8] = 0x40000000;
      *(void *)&buf[16] = ___ZL33nw_webtransport_session_terminateP23nw_webtransport_sessioni_block_invoke;
      v108 = (const char *)&__block_descriptor_tmp_26_33833;
      LODWORD(v109) = 57;
      nw_hash_table_apply(v48, (uint64_t)buf);
    }
    uint64_t v49 = *((void *)handle + 53);
    if (v49)
    {
      v50 = *(void **)(v49 + 48);
      nw_protocol_error(v50, *((void *)handle + 53));
      nw_protocol_disconnected(v50, v49);
    }
    uint64_t v51 = *((void *)handle + 41);
    if (v51)
    {
      do
      {
        uint64_t v52 = *(void *)(v51 + 112);
        v53 = *(void **)(v51 + 48);
        nw_protocol_error(v53, v51);
        nw_protocol_disconnected(v53, v51);
        uint64_t v51 = v52;
      }
      while (v52);
    }
    uint64_t v54 = *((void *)handle + 52);
    if (v54)
    {
      v55 = *(void **)(v54 + 48);
      nw_protocol_error(v55, *((void *)handle + 52));
      nw_protocol_disconnected(v55, v54);
    }
    if (*((void *)handle + 4))
    {
      nw_protocol_remove_instance((uint64_t)handle);
      nw_protocol_disconnect(*((void **)handle + 4), (uint64_t)handle);
    }
  }
}

nw_endpoint_t nw_endpoint_create_bonjour_service(const char *name, const char *type, const char *domain)
{
  uint64_t v112 = *MEMORY[0x1E4F143B8];
  if (!name)
  {
    int v61 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v107 = "nw_endpoint_create_bonjour_service";
    v9 = (char *)_os_log_send_and_compose_impl();

    typea[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v95.receiver) = 0;
    if (!__nwlog_fault(v9, typea, &v95)) {
      goto LABEL_93;
    }
    if (typea[0] == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      os_log_type_t v62 = typea[0];
      if (os_log_type_enabled(v10, typea[0]))
      {
        *(_DWORD *)buf = 136446210;
        v107 = "nw_endpoint_create_bonjour_service";
        _os_log_impl(&dword_1830D4000, v10, v62, "%{public}s called with null name", buf, 0xCu);
      }
      goto LABEL_92;
    }
    if (!LOBYTE(v95.receiver))
    {
      v10 = __nwlog_obj();
      os_log_type_t v68 = typea[0];
      if (os_log_type_enabled(v10, typea[0]))
      {
        *(_DWORD *)buf = 136446210;
        v107 = "nw_endpoint_create_bonjour_service";
        _os_log_impl(&dword_1830D4000, v10, v68, "%{public}s called with null name, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_92;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v10 = __nwlog_obj();
    os_log_type_t v64 = typea[0];
    BOOL v65 = os_log_type_enabled(v10, typea[0]);
    if (!backtrace_string)
    {
      if (v65)
      {
        *(_DWORD *)buf = 136446210;
        v107 = "nw_endpoint_create_bonjour_service";
        _os_log_impl(&dword_1830D4000, v10, v64, "%{public}s called with null name, no backtrace", buf, 0xCu);
      }
      goto LABEL_92;
    }
    if (v65)
    {
      *(_DWORD *)buf = 136446466;
      v107 = "nw_endpoint_create_bonjour_service";
      __int16 v108 = 2082;
      v109 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v10, v64, "%{public}s called with null name, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_164:

    free(backtrace_string);
    goto LABEL_93;
  }
  size_t v6 = strlen(name);
  if (!v6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v8 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    v107 = "nw_endpoint_create_bonjour_service";
    __int16 v108 = 2082;
    v109 = "name";
    v9 = (char *)_os_log_send_and_compose_impl();

    typea[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v95.receiver) = 0;
    if (!__nwlog_fault(v9, typea, &v95)) {
      goto LABEL_93;
    }
    if (typea[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = (id)gLogObj;
      os_log_type_t v11 = typea[0];
      if (os_log_type_enabled(v10, typea[0]))
      {
        *(_DWORD *)buf = 136446466;
        v107 = "nw_endpoint_create_bonjour_service";
        __int16 v108 = 2082;
        v109 = "name";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s invalid empty string %{public}s", buf, 0x16u);
      }
      goto LABEL_92;
    }
    if (!LOBYTE(v95.receiver))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = (id)gLogObj;
      os_log_type_t v19 = typea[0];
      if (os_log_type_enabled(v10, typea[0]))
      {
        *(_DWORD *)buf = 136446466;
        v107 = "nw_endpoint_create_bonjour_service";
        __int16 v108 = 2082;
        v109 = "name";
        _os_log_impl(&dword_1830D4000, v10, v19, "%{public}s invalid empty string %{public}s, backtrace limit exceeded", buf, 0x16u);
      }
      goto LABEL_92;
    }
    int v13 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = (id)gLogObj;
    os_log_type_t v14 = typea[0];
    BOOL v15 = os_log_type_enabled(v10, typea[0]);
    if (!v13)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        v107 = "nw_endpoint_create_bonjour_service";
        __int16 v108 = 2082;
        v109 = "name";
        _os_log_impl(&dword_1830D4000, v10, v14, "%{public}s invalid empty string %{public}s, no backtrace", buf, 0x16u);
      }
      goto LABEL_92;
    }
    if (v15)
    {
      *(_DWORD *)buf = 136446722;
      v107 = "nw_endpoint_create_bonjour_service";
      __int16 v108 = 2082;
      v109 = "name";
      __int16 v110 = 2082;
      long long v111 = v13;
      _os_log_impl(&dword_1830D4000, v10, v14, "%{public}s invalid empty string %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
    }
    goto LABEL_41;
  }
  if (v6 >= 0x400)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v107 = "nw_endpoint_create_bonjour_service";
      __int16 v108 = 2082;
      v109 = "name";
      __int16 v110 = 1024;
      LODWORD(v111) = 1024;
      _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_ERROR, "%{public}s %{public}s is longer than %d", buf, 0x1Cu);
    }
LABEL_33:

    return 0;
  }
  if (!type)
  {
    v66 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v107 = "nw_endpoint_create_bonjour_service";
    v9 = (char *)_os_log_send_and_compose_impl();

    typea[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v95.receiver) = 0;
    if (!__nwlog_fault(v9, typea, &v95)) {
      goto LABEL_93;
    }
    if (typea[0] == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      os_log_type_t v67 = typea[0];
      if (os_log_type_enabled(v10, typea[0]))
      {
        *(_DWORD *)buf = 136446210;
        v107 = "nw_endpoint_create_bonjour_service";
        _os_log_impl(&dword_1830D4000, v10, v67, "%{public}s called with null type", buf, 0xCu);
      }
      goto LABEL_92;
    }
    if (!LOBYTE(v95.receiver))
    {
      v10 = __nwlog_obj();
      os_log_type_t v73 = typea[0];
      if (os_log_type_enabled(v10, typea[0]))
      {
        *(_DWORD *)buf = 136446210;
        v107 = "nw_endpoint_create_bonjour_service";
        _os_log_impl(&dword_1830D4000, v10, v73, "%{public}s called with null type, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_92;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v10 = __nwlog_obj();
    os_log_type_t v69 = typea[0];
    BOOL v70 = os_log_type_enabled(v10, typea[0]);
    if (!backtrace_string)
    {
      if (v70)
      {
        *(_DWORD *)buf = 136446210;
        v107 = "nw_endpoint_create_bonjour_service";
        _os_log_impl(&dword_1830D4000, v10, v69, "%{public}s called with null type, no backtrace", buf, 0xCu);
      }
      goto LABEL_92;
    }
    if (v70)
    {
      *(_DWORD *)buf = 136446466;
      v107 = "nw_endpoint_create_bonjour_service";
      __int16 v108 = 2082;
      v109 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v10, v69, "%{public}s called with null type, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_164;
  }
  size_t v12 = strlen(type);
  if (!v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v16 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    v107 = "nw_endpoint_create_bonjour_service";
    __int16 v108 = 2082;
    v109 = "type";
    v9 = (char *)_os_log_send_and_compose_impl();

    typea[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v95.receiver) = 0;
    if (!__nwlog_fault(v9, typea, &v95)) {
      goto LABEL_93;
    }
    if (typea[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = (id)gLogObj;
      os_log_type_t v17 = typea[0];
      if (os_log_type_enabled(v10, typea[0]))
      {
        *(_DWORD *)buf = 136446466;
        v107 = "nw_endpoint_create_bonjour_service";
        __int16 v108 = 2082;
        v109 = "type";
        _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s invalid empty string %{public}s", buf, 0x16u);
      }
      goto LABEL_92;
    }
    if (!LOBYTE(v95.receiver))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = (id)gLogObj;
      os_log_type_t v40 = typea[0];
      if (os_log_type_enabled(v10, typea[0]))
      {
        *(_DWORD *)buf = 136446466;
        v107 = "nw_endpoint_create_bonjour_service";
        __int16 v108 = 2082;
        v109 = "type";
        _os_log_impl(&dword_1830D4000, v10, v40, "%{public}s invalid empty string %{public}s, backtrace limit exceeded", buf, 0x16u);
      }
      goto LABEL_92;
    }
    int v13 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = (id)gLogObj;
    os_log_type_t v20 = typea[0];
    BOOL v21 = os_log_type_enabled(v10, typea[0]);
    if (!v13)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446466;
        v107 = "nw_endpoint_create_bonjour_service";
        __int16 v108 = 2082;
        v109 = "type";
        _os_log_impl(&dword_1830D4000, v10, v20, "%{public}s invalid empty string %{public}s, no backtrace", buf, 0x16u);
      }
      goto LABEL_92;
    }
    if (v21)
    {
      *(_DWORD *)buf = 136446722;
      v107 = "nw_endpoint_create_bonjour_service";
      __int16 v108 = 2082;
      v109 = "type";
      __int16 v110 = 2082;
      long long v111 = v13;
      _os_log_impl(&dword_1830D4000, v10, v20, "%{public}s invalid empty string %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
    }
LABEL_41:

    free(v13);
    if (!v9) {
      return 0;
    }
    goto LABEL_94;
  }
  if (v12 >= 0x400)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v107 = "nw_endpoint_create_bonjour_service";
      __int16 v108 = 2082;
      v109 = "type";
      __int16 v110 = 1024;
      LODWORD(v111) = 1024;
      _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_ERROR, "%{public}s %{public}s is longer than %d", buf, 0x1Cu);
    }
    goto LABEL_33;
  }
  if (!domain)
  {
    v71 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v107 = "nw_endpoint_create_bonjour_service";
    v9 = (char *)_os_log_send_and_compose_impl();

    typea[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v95.receiver) = 0;
    if (!__nwlog_fault(v9, typea, &v95)) {
      goto LABEL_93;
    }
    if (typea[0] == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      os_log_type_t v72 = typea[0];
      if (os_log_type_enabled(v10, typea[0]))
      {
        *(_DWORD *)buf = 136446210;
        v107 = "nw_endpoint_create_bonjour_service";
        _os_log_impl(&dword_1830D4000, v10, v72, "%{public}s called with null domain", buf, 0xCu);
      }
      goto LABEL_92;
    }
    if (!LOBYTE(v95.receiver))
    {
      v10 = __nwlog_obj();
      os_log_type_t v86 = typea[0];
      if (os_log_type_enabled(v10, typea[0]))
      {
        *(_DWORD *)buf = 136446210;
        v107 = "nw_endpoint_create_bonjour_service";
        _os_log_impl(&dword_1830D4000, v10, v86, "%{public}s called with null domain, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_92;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v10 = __nwlog_obj();
    os_log_type_t v74 = typea[0];
    BOOL v75 = os_log_type_enabled(v10, typea[0]);
    if (!backtrace_string)
    {
      if (v75)
      {
        *(_DWORD *)buf = 136446210;
        v107 = "nw_endpoint_create_bonjour_service";
        _os_log_impl(&dword_1830D4000, v10, v74, "%{public}s called with null domain, no backtrace", buf, 0xCu);
      }
      goto LABEL_92;
    }
    if (v75)
    {
      *(_DWORD *)buf = 136446466;
      v107 = "nw_endpoint_create_bonjour_service";
      __int16 v108 = 2082;
      v109 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v10, v74, "%{public}s called with null domain, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_164;
  }
  size_t v18 = strlen(domain);
  if (!v18)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v22 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    v107 = "nw_endpoint_create_bonjour_service";
    __int16 v108 = 2082;
    v109 = "domain";
    v9 = (char *)_os_log_send_and_compose_impl();

    typea[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v95.receiver) = 0;
    if (!__nwlog_fault(v9, typea, &v95)) {
      goto LABEL_93;
    }
    if (typea[0] == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      os_log_type_t v23 = typea[0];
      if (os_log_type_enabled(v10, typea[0]))
      {
        *(_DWORD *)buf = 136446466;
        v107 = "nw_endpoint_create_bonjour_service";
        __int16 v108 = 2082;
        v109 = "domain";
        _os_log_impl(&dword_1830D4000, v10, v23, "%{public}s invalid empty string %{public}s", buf, 0x16u);
      }
LABEL_92:

      goto LABEL_93;
    }
    if (!LOBYTE(v95.receiver))
    {
      v10 = __nwlog_obj();
      os_log_type_t v50 = typea[0];
      if (os_log_type_enabled(v10, typea[0]))
      {
        *(_DWORD *)buf = 136446466;
        v107 = "nw_endpoint_create_bonjour_service";
        __int16 v108 = 2082;
        v109 = "domain";
        _os_log_impl(&dword_1830D4000, v10, v50, "%{public}s invalid empty string %{public}s, backtrace limit exceeded", buf, 0x16u);
      }
      goto LABEL_92;
    }
    os_log_type_t v41 = (char *)__nw_create_backtrace_string();
    v10 = __nwlog_obj();
    os_log_type_t v42 = typea[0];
    BOOL v43 = os_log_type_enabled(v10, typea[0]);
    if (!v41)
    {
      if (v43)
      {
        *(_DWORD *)buf = 136446466;
        v107 = "nw_endpoint_create_bonjour_service";
        __int16 v108 = 2082;
        v109 = "domain";
        _os_log_impl(&dword_1830D4000, v10, v42, "%{public}s invalid empty string %{public}s, no backtrace", buf, 0x16u);
      }
      goto LABEL_92;
    }
    if (v43)
    {
      *(_DWORD *)buf = 136446722;
      v107 = "nw_endpoint_create_bonjour_service";
      __int16 v108 = 2082;
      v109 = "domain";
      __int16 v110 = 2082;
      long long v111 = v41;
      _os_log_impl(&dword_1830D4000, v10, v42, "%{public}s invalid empty string %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
    }

    free(v41);
LABEL_93:
    if (!v9) {
      return 0;
    }
LABEL_94:
    free(v9);
    return 0;
  }
  if (v18 >= 0x400)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v107 = "nw_endpoint_create_bonjour_service";
      __int16 v108 = 2082;
      v109 = "domain";
      __int16 v110 = 1024;
      LODWORD(v111) = 1024;
      _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_ERROR, "%{public}s %{public}s is longer than %d", buf, 0x1Cu);
    }
    goto LABEL_33;
  }
  v24 = [NWConcrete_nw_bonjour_service_endpoint alloc];
  if (!v24)
  {
LABEL_106:
    v53 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v107 = "nw_endpoint_create_bonjour_service";
    uint64_t v54 = (char *)_os_log_send_and_compose_impl();

    typea[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v95.receiver) = 0;
    if (__nwlog_fault(v54, typea, &v95))
    {
      if (typea[0] == OS_LOG_TYPE_FAULT)
      {
        v55 = __nwlog_obj();
        os_log_type_t v56 = typea[0];
        if (os_log_type_enabled(v55, typea[0]))
        {
          *(_DWORD *)buf = 136446210;
          v107 = "nw_endpoint_create_bonjour_service";
          _os_log_impl(&dword_1830D4000, v55, v56, "%{public}s NWOSBonjourEndpoint alloc/init failed", buf, 0xCu);
        }
      }
      else if (LOBYTE(v95.receiver))
      {
        uint64_t v57 = (char *)__nw_create_backtrace_string();
        v55 = __nwlog_obj();
        os_log_type_t v58 = typea[0];
        BOOL v59 = os_log_type_enabled(v55, typea[0]);
        if (v57)
        {
          if (v59)
          {
            *(_DWORD *)buf = 136446466;
            v107 = "nw_endpoint_create_bonjour_service";
            __int16 v108 = 2082;
            v109 = v57;
            _os_log_impl(&dword_1830D4000, v55, v58, "%{public}s NWOSBonjourEndpoint alloc/init failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v57);
          goto LABEL_122;
        }
        if (v59)
        {
          *(_DWORD *)buf = 136446210;
          v107 = "nw_endpoint_create_bonjour_service";
          _os_log_impl(&dword_1830D4000, v55, v58, "%{public}s NWOSBonjourEndpoint alloc/init failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        v55 = __nwlog_obj();
        os_log_type_t v60 = typea[0];
        if (os_log_type_enabled(v55, typea[0]))
        {
          *(_DWORD *)buf = 136446210;
          v107 = "nw_endpoint_create_bonjour_service";
          _os_log_impl(&dword_1830D4000, v55, v60, "%{public}s NWOSBonjourEndpoint alloc/init failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_122:
    if (v54) {
      free(v54);
    }
    v46 = 0;
LABEL_125:

    return v46;
  }
  v95.receiver = v24;
  v95.super_class = (Class)NWConcrete_nw_bonjour_service_endpoint;
  id v25 = objc_msgSendSuper2(&v95, sel_init);
  if (!v25)
  {
    v76 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v107 = "-[NWConcrete_nw_bonjour_service_endpoint initWithName:type:domain:]";
    int v77 = (char *)_os_log_send_and_compose_impl();

    typea[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v94 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v77, typea, &v94))
    {
      if (typea[0] == OS_LOG_TYPE_FAULT)
      {
        v78 = __nwlog_obj();
        os_log_type_t v79 = typea[0];
        if (os_log_type_enabled(v78, typea[0]))
        {
          *(_DWORD *)buf = 136446210;
          v107 = "-[NWConcrete_nw_bonjour_service_endpoint initWithName:type:domain:]";
          _os_log_impl(&dword_1830D4000, v78, v79, "%{public}s [super init] failed", buf, 0xCu);
        }
      }
      else if (v94)
      {
        int v87 = (char *)__nw_create_backtrace_string();
        v78 = __nwlog_obj();
        os_log_type_t v88 = typea[0];
        BOOL v89 = os_log_type_enabled(v78, typea[0]);
        if (v87)
        {
          if (v89)
          {
            *(_DWORD *)buf = 136446466;
            v107 = "-[NWConcrete_nw_bonjour_service_endpoint initWithName:type:domain:]";
            __int16 v108 = 2082;
            v109 = v87;
            _os_log_impl(&dword_1830D4000, v78, v88, "%{public}s [super init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v87);
          goto LABEL_198;
        }
        if (v89)
        {
          *(_DWORD *)buf = 136446210;
          v107 = "-[NWConcrete_nw_bonjour_service_endpoint initWithName:type:domain:]";
          _os_log_impl(&dword_1830D4000, v78, v88, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        v78 = __nwlog_obj();
        os_log_type_t v92 = typea[0];
        if (os_log_type_enabled(v78, typea[0]))
        {
          *(_DWORD *)buf = 136446210;
          v107 = "-[NWConcrete_nw_bonjour_service_endpoint initWithName:type:domain:]";
          _os_log_impl(&dword_1830D4000, v78, v92, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_198:
    if (v77) {
      free(v77);
    }
    goto LABEL_106;
  }
  BOOL v26 = strdup(name);
  if (!v26)
  {
    v80 = __nwlog_obj();
    os_log_type_enabled(v80, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v107 = "strict_strdup";
    v81 = (void *)_os_log_send_and_compose_impl();

    nw_endpoint_t result = (nw_endpoint_t)__nwlog_abort((uint64_t)v81);
    if (result) {
      goto LABEL_200;
    }
    free(v81);
  }
  *((void *)v25 + 29) = v26;
  char v27 = strdup(type);
  if (!v27)
  {
    BOOL v82 = __nwlog_obj();
    os_log_type_enabled(v82, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v107 = "strict_strdup";
    v83 = (void *)_os_log_send_and_compose_impl();

    nw_endpoint_t result = (nw_endpoint_t)__nwlog_abort((uint64_t)v83);
    if (result) {
      goto LABEL_200;
    }
    free(v83);
  }
  *((void *)v25 + 30) = v27;
  v28 = strdup(domain);
  if (!v28)
  {
    BOOL v84 = __nwlog_obj();
    os_log_type_enabled(v84, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v107 = "strict_strdup";
    v85 = (void *)_os_log_send_and_compose_impl();

    nw_endpoint_t result = (nw_endpoint_t)__nwlog_abort((uint64_t)v85);
    if (result) {
      goto LABEL_200;
    }
    free(v85);
  }
  *((void *)v25 + 31) = v28;
  size_t v29 = strlen(type);
  if (type[v29 - 1] == 46)
  {
    *(unsigned char *)(*((void *)v25 + 30) + v29 - 1) = 0;
    v28 = (char *)*((void *)v25 + 31);
  }
  DNSServiceErrorType v30 = DNSServiceConstructFullName((char *const)buf, *((const char *const *)v25 + 29), *((const char *const *)v25 + 30), v28);
  if (v30)
  {
    dns_error = nw_error_create_dns_error(v30);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v32 = (id)gLogObj;
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      uint64_t v33 = (_DWORD *)*((void *)v25 + 29);
      char v34 = (char *)*((void *)v25 + 30);
      uint64_t v35 = *((void *)v25 + 31);
      *(_DWORD *)typea = 136447235;
      v97 = "-[NWConcrete_nw_bonjour_service_endpoint initWithName:type:domain:]";
      __int16 v98 = 2085;
      BOOL v99 = v33;
      __int16 v100 = 2082;
      BOOL v101 = v34;
      __int16 v102 = 2085;
      uint64_t v103 = v35;
      __int16 v104 = 2114;
      v105 = dns_error;
      _os_log_impl(&dword_1830D4000, v32, OS_LOG_TYPE_ERROR, "%{public}s DNSServiceConstructFullName(..., %{sensitive}s, %{public}s, %{sensitive}s) failed: %{public}@", (uint8_t *)typea, 0x34u);
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v36 = (id)gLogObj;
    *(_DWORD *)typea = 136446466;
    v97 = "-[NWConcrete_nw_bonjour_service_endpoint initWithName:type:domain:]";
    __int16 v98 = 2114;
    BOOL v99 = dns_error;
    v37 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v94 = OS_LOG_TYPE_ERROR;
    char v93 = 0;
    if (!__nwlog_fault(v37, &v94, &v93)) {
      goto LABEL_103;
    }
    if (v94 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v38 = (id)gLogObj;
      os_log_type_t v39 = v94;
      if (os_log_type_enabled(v38, v94))
      {
        *(_DWORD *)typea = 136446466;
        v97 = "-[NWConcrete_nw_bonjour_service_endpoint initWithName:type:domain:]";
        __int16 v98 = 2114;
        BOOL v99 = dns_error;
        _os_log_impl(&dword_1830D4000, v38, v39, "%{public}s DNSServiceConstructFullName failed: %{public}@ failed", (uint8_t *)typea, 0x16u);
      }
    }
    else if (v93)
    {
      int v47 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v38 = (id)gLogObj;
      os_log_type_t v48 = v94;
      BOOL v49 = os_log_type_enabled(v38, v94);
      if (v47)
      {
        if (v49)
        {
          *(_DWORD *)typea = 136446722;
          v97 = "-[NWConcrete_nw_bonjour_service_endpoint initWithName:type:domain:]";
          __int16 v98 = 2114;
          BOOL v99 = dns_error;
          __int16 v100 = 2082;
          BOOL v101 = v47;
          _os_log_impl(&dword_1830D4000, v38, v48, "%{public}s DNSServiceConstructFullName failed: %{public}@ failed, dumping backtrace:%{public}s", (uint8_t *)typea, 0x20u);
        }

        free(v47);
        goto LABEL_103;
      }
      if (v49)
      {
        *(_DWORD *)typea = 136446466;
        v97 = "-[NWConcrete_nw_bonjour_service_endpoint initWithName:type:domain:]";
        __int16 v98 = 2114;
        BOOL v99 = dns_error;
        _os_log_impl(&dword_1830D4000, v38, v48, "%{public}s DNSServiceConstructFullName failed: %{public}@ failed, no backtrace", (uint8_t *)typea, 0x16u);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v38 = (id)gLogObj;
      os_log_type_t v52 = v94;
      if (os_log_type_enabled(v38, v94))
      {
        *(_DWORD *)typea = 136446466;
        v97 = "-[NWConcrete_nw_bonjour_service_endpoint initWithName:type:domain:]";
        __int16 v98 = 2114;
        BOOL v99 = dns_error;
        _os_log_impl(&dword_1830D4000, v38, v52, "%{public}s DNSServiceConstructFullName failed: %{public}@ failed, backtrace limit exceeded", (uint8_t *)typea, 0x16u);
      }
    }

LABEL_103:
    if (v37) {
      free(v37);
    }

    goto LABEL_106;
  }
  v44 = strdup((const char *)buf);
  if (v44)
  {
LABEL_78:
    *((void *)v25 + 32) = v44;
    if (!strcmp(domain, "local") || strcmp(domain, "local.")) {
      *((unsigned char *)v25 + 231) |= 1u;
    }
    id v45 = v25;

    v46 = v45;
    goto LABEL_125;
  }
  int v90 = __nwlog_obj();
  os_log_type_enabled(v90, OS_LOG_TYPE_ERROR);
  *(_DWORD *)typea = 136446210;
  v97 = "strict_strdup";
  v91 = (void *)_os_log_send_and_compose_impl();

  nw_endpoint_t result = (nw_endpoint_t)__nwlog_abort((uint64_t)v91);
  if (!result)
  {
    free(v91);
    goto LABEL_78;
  }
LABEL_200:
  __break(1u);
  return result;
}

void sub_183451D44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_implementation_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0;
    }
    size_t v6 = p_output_handler;
    v7 = v6;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      uint64_t v8 = *((void *)v6 + 1);
      if (v8)
      {
        if (*(void *)(v8 + 80))
        {
          if ((v6[405] & 0x80000000) == 0 && gLogDatapath)
          {
            id v36 = __nwlog_obj();
            if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v7 + 407;
              *(_WORD *)&buf[22] = 2080;
              v80 = " ";
              _os_log_impl(&dword_1830D4000, v36, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sDisconnected from output handler", buf, 0x20u);
            }
          }
          if (*((void *)v7 + 37))
          {
            *(void *)os_log_type_t type = 0;
            if (nw_protocol_implementation_lookup_path_by_protocol((NWConcrete_nw_protocol_instance *)v7, a2, (unint64_t *)type))
            {
              nw_protocol_instance_tear_down_path(v7, *(uint64_t *)type);
            }
            else if ((v7[405] & 0x80000000) == 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v10 = (id)gLogObj;
              if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v7 + 407;
                *(_WORD *)&buf[22] = 2080;
                v80 = " ";
                __int16 v81 = 2048;
                BOOL v82 = a2;
                _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sReceived a disconnected event from an unknown protocol %p", buf, 0x2Au);
              }
            }
            *(void *)buf = 0;
            *(void *)&buf[8] = buf;
            *(void *)&buf[16] = 0x2020000000;
            LOBYTE(v80) = 0;
            os_log_type_t v11 = (char *)*((void *)v7 + 37);
            v72[0] = MEMORY[0x1E4F143A8];
            v72[1] = 3221225472;
            v72[2] = ___ZL39nw_protocol_implementation_disconnectedP11nw_protocolS0__block_invoke;
            v72[3] = &unk_1E523BE48;
            v72[4] = buf;
            nw_hash_table_apply(v11, (uint64_t)v72);
            int v12 = *(unsigned __int8 *)(*(void *)&buf[8] + 24);
            _Block_object_dispose(buf, 8);
            if (v12) {
              goto LABEL_42;
            }
          }
          else
          {
            v9 = *(void (**)(char *, void, uint64_t, uint64_t))(*(void *)(*((void *)v7 + 1) + 80)
                                                                         + 208);
            if (v9) {
              v9(v7, 0, 2, 1);
            }
          }
          v7[404] |= 4u;
          nw_protocol_remove_instance((uint64_t)a1);
          uint64_t v13 = *((void *)v7 + 3);
          if (v13) {
            (*(void (**)(uint64_t, nw_protocol *, uint64_t))(*(void *)v13 + 8))(v13, a1, 57);
          }
          if (*(_DWORD *)(*((void *)v7 + 1) + 64) == 3)
          {
            os_log_type_t v14 = (char *)*((void *)v7 + 29);
            v71[0] = MEMORY[0x1E4F143A8];
            v71[1] = 3221225472;
            v71[2] = ___ZL39nw_protocol_implementation_disconnectedP11nw_protocolS0__block_invoke_2;
            v71[3] = &__block_descriptor_40_e23_B16__0__nw_hash_node__8l;
            v71[4] = a1;
            nw_hash_table_apply(v14, (uint64_t)v71);
LABEL_42:

            return;
          }
          default_input_handler = a1->default_input_handler;
          if (default_input_handler)
          {
            id v16 = default_input_handler->handle;
            if (v16 == &nw_protocol_ref_counted_handle)
            {
              callbacks = default_input_handler[1].callbacks;
              if (callbacks) {
                default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
              }
              char v17 = -1;
            }
            else
            {
              char v17 = 0;
            }
            *(void *)os_log_type_t type = default_input_handler;
            char v78 = v17;
            os_log_type_t v19 = a1->handle;
            if (v19 == &nw_protocol_ref_counted_handle)
            {
              BOOL v21 = a1[1].callbacks;
              if (v21) {
                a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v21->add_input_handler + 1);
              }
              char v20 = -1;
            }
            else
            {
              char v20 = 0;
            }
            BOOL v75 = a1;
            char v76 = v20;
            id v22 = default_input_handler->callbacks;
            if (v22)
            {
              disconnected = (void (*)(nw_protocol *, nw_protocol *))v22->disconnected;
              if (disconnected)
              {
                disconnected(default_input_handler, a1);
                goto LABEL_37;
              }
            }
            v37 = __nwlog_obj();
            name = default_input_handler->identifier->name;
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "__nw_protocol_disconnected";
            if (!name) {
              name = "invalid";
            }
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = name;
            *(_WORD *)&buf[22] = 2048;
            v80 = (const char *)default_input_handler;
            os_log_type_t v39 = (char *)_os_log_send_and_compose_impl();

            os_log_type_t v74 = OS_LOG_TYPE_ERROR;
            char v73 = 0;
            if (__nwlog_fault(v39, &v74, &v73))
            {
              if (v74 == OS_LOG_TYPE_FAULT)
              {
                os_log_type_t v40 = __nwlog_obj();
                os_log_type_t v41 = v74;
                if (os_log_type_enabled(v40, v74))
                {
                  os_log_type_t v42 = default_input_handler->identifier->name;
                  if (!v42) {
                    os_log_type_t v42 = "invalid";
                  }
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "__nw_protocol_disconnected";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v42;
                  *(_WORD *)&buf[22] = 2048;
                  v80 = (const char *)default_input_handler;
                  _os_log_impl(&dword_1830D4000, v40, v41, "%{public}s protocol %{public}s (%p) has invalid disconnected callback", buf, 0x20u);
                }
              }
              else if (v73)
              {
                backtrace_string = (char *)__nw_create_backtrace_string();
                os_log_type_t v40 = __nwlog_obj();
                os_log_type_t v58 = v74;
                BOOL v59 = os_log_type_enabled(v40, v74);
                if (backtrace_string)
                {
                  if (v59)
                  {
                    os_log_type_t v60 = default_input_handler->identifier->name;
                    if (!v60) {
                      os_log_type_t v60 = "invalid";
                    }
                    *(_DWORD *)buf = 136446978;
                    *(void *)&uint8_t buf[4] = "__nw_protocol_disconnected";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = v60;
                    *(_WORD *)&buf[22] = 2048;
                    v80 = (const char *)default_input_handler;
                    __int16 v81 = 2082;
                    BOOL v82 = (nw_protocol *)backtrace_string;
                    _os_log_impl(&dword_1830D4000, v40, v58, "%{public}s protocol %{public}s (%p) has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x2Au);
                  }

                  free(backtrace_string);
                  goto LABEL_151;
                }
                if (v59)
                {
                  os_log_type_t v69 = default_input_handler->identifier->name;
                  if (!v69) {
                    os_log_type_t v69 = "invalid";
                  }
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "__nw_protocol_disconnected";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v69;
                  *(_WORD *)&buf[22] = 2048;
                  v80 = (const char *)default_input_handler;
                  _os_log_impl(&dword_1830D4000, v40, v58, "%{public}s protocol %{public}s (%p) has invalid disconnected callback, no backtrace", buf, 0x20u);
                }
              }
              else
              {
                os_log_type_t v40 = __nwlog_obj();
                os_log_type_t v67 = v74;
                if (os_log_type_enabled(v40, v74))
                {
                  os_log_type_t v68 = default_input_handler->identifier->name;
                  if (!v68) {
                    os_log_type_t v68 = "invalid";
                  }
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "__nw_protocol_disconnected";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v68;
                  *(_WORD *)&buf[22] = 2048;
                  v80 = (const char *)default_input_handler;
                  _os_log_impl(&dword_1830D4000, v40, v67, "%{public}s protocol %{public}s (%p) has invalid disconnected callback, backtrace limit exceeded", buf, 0x20u);
                }
              }
            }
LABEL_151:
            if (v39) {
              free(v39);
            }
LABEL_37:
            if (v19 == &nw_protocol_ref_counted_handle)
            {
              nw::release_if_needed<nw_protocol *>((uint64_t *)&v75);
              if (v16 != &nw_protocol_ref_counted_handle) {
                goto LABEL_42;
              }
            }
            else if (v16 != &nw_protocol_ref_counted_handle)
            {
              goto LABEL_42;
            }
            nw::release_if_needed<nw_protocol *>((uint64_t *)type);
            goto LABEL_42;
          }
          uint64_t v54 = __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_protocol_disconnected";
          size_t v29 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          LOBYTE(v75) = 0;
          if (!__nwlog_fault(v29, type, &v75)) {
            goto LABEL_159;
          }
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            v55 = __nwlog_obj();
            os_log_type_t v56 = type[0];
            if (os_log_type_enabled(v55, type[0]))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "__nw_protocol_disconnected";
              _os_log_impl(&dword_1830D4000, v55, v56, "%{public}s called with null protocol", buf, 0xCu);
            }
LABEL_158:

            goto LABEL_159;
          }
          if (!(_BYTE)v75)
          {
            v55 = __nwlog_obj();
            os_log_type_t v70 = type[0];
            if (os_log_type_enabled(v55, type[0]))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "__nw_protocol_disconnected";
              _os_log_impl(&dword_1830D4000, v55, v70, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
            }
            goto LABEL_158;
          }
          BOOL v49 = (char *)__nw_create_backtrace_string();
          v55 = __nwlog_obj();
          os_log_type_t v65 = type[0];
          BOOL v66 = os_log_type_enabled(v55, type[0]);
          if (!v49)
          {
            if (v66)
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "__nw_protocol_disconnected";
              _os_log_impl(&dword_1830D4000, v55, v65, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
            }
            goto LABEL_158;
          }
          if (v66)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "__nw_protocol_disconnected";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v49;
            _os_log_impl(&dword_1830D4000, v55, v65, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }

LABEL_125:
          free(v49);
          if (!v29) {
            goto LABEL_42;
          }
          goto LABEL_160;
        }
        char v34 = __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
        size_t v29 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(v75) = 0;
        if (!__nwlog_fault(v29, type, &v75)) {
          goto LABEL_159;
        }
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          DNSServiceErrorType v30 = __nwlog_obj();
          os_log_type_t v35 = type[0];
          if (os_log_type_enabled(v30, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
            _os_log_impl(&dword_1830D4000, v30, v35, "%{public}s called with null instance->parent_definition->extended_state", buf, 0xCu);
          }
          goto LABEL_140;
        }
        if (!(_BYTE)v75)
        {
          DNSServiceErrorType v30 = __nwlog_obj();
          os_log_type_t v64 = type[0];
          if (os_log_type_enabled(v30, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
            _os_log_impl(&dword_1830D4000, v30, v64, "%{public}s called with null instance->parent_definition->extended_state, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_140;
        }
        BOOL v49 = (char *)__nw_create_backtrace_string();
        DNSServiceErrorType v30 = __nwlog_obj();
        os_log_type_t v52 = type[0];
        BOOL v53 = os_log_type_enabled(v30, type[0]);
        if (!v49)
        {
          if (v53)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
            _os_log_impl(&dword_1830D4000, v30, v52, "%{public}s called with null instance->parent_definition->extended_state, no backtrace", buf, 0xCu);
          }
          goto LABEL_140;
        }
        if (v53)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v49;
          _os_log_impl(&dword_1830D4000, v30, v52, "%{public}s called with null instance->parent_definition->extended_state, dumping backtrace:%{public}s", buf, 0x16u);
        }
      }
      else
      {
        uint64_t v32 = __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
        size_t v29 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(v75) = 0;
        if (!__nwlog_fault(v29, type, &v75)) {
          goto LABEL_159;
        }
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          DNSServiceErrorType v30 = __nwlog_obj();
          os_log_type_t v33 = type[0];
          if (os_log_type_enabled(v30, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
            _os_log_impl(&dword_1830D4000, v30, v33, "%{public}s called with null instance->parent_definition", buf, 0xCu);
          }
          goto LABEL_140;
        }
        if (!(_BYTE)v75)
        {
          DNSServiceErrorType v30 = __nwlog_obj();
          os_log_type_t v63 = type[0];
          if (os_log_type_enabled(v30, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
            _os_log_impl(&dword_1830D4000, v30, v63, "%{public}s called with null instance->parent_definition, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_140;
        }
        BOOL v49 = (char *)__nw_create_backtrace_string();
        DNSServiceErrorType v30 = __nwlog_obj();
        os_log_type_t v50 = type[0];
        BOOL v51 = os_log_type_enabled(v30, type[0]);
        if (!v49)
        {
          if (v51)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
            _os_log_impl(&dword_1830D4000, v30, v50, "%{public}s called with null instance->parent_definition, no backtrace", buf, 0xCu);
          }
          goto LABEL_140;
        }
        if (v51)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v49;
          _os_log_impl(&dword_1830D4000, v30, v50, "%{public}s called with null instance->parent_definition, dumping backtrace:%{public}s", buf, 0x16u);
        }
      }

      goto LABEL_125;
    }
    v28 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
    size_t v29 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v75) = 0;
    if (!__nwlog_fault(v29, type, &v75)) {
      goto LABEL_159;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      DNSServiceErrorType v30 = __nwlog_obj();
      os_log_type_t v31 = type[0];
      if (os_log_type_enabled(v30, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
        _os_log_impl(&dword_1830D4000, v30, v31, "%{public}s called with null instance", buf, 0xCu);
      }
    }
    else if ((_BYTE)v75)
    {
      v46 = (char *)__nw_create_backtrace_string();
      DNSServiceErrorType v30 = __nwlog_obj();
      os_log_type_t v47 = type[0];
      BOOL v48 = os_log_type_enabled(v30, type[0]);
      if (v46)
      {
        if (v48)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v46;
          _os_log_impl(&dword_1830D4000, v30, v47, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v46);
LABEL_159:
        if (!v29) {
          goto LABEL_42;
        }
LABEL_160:
        free(v29);
        goto LABEL_42;
      }
      if (v48)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
        _os_log_impl(&dword_1830D4000, v30, v47, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      DNSServiceErrorType v30 = __nwlog_obj();
      os_log_type_t v62 = type[0];
      if (os_log_type_enabled(v30, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
        _os_log_impl(&dword_1830D4000, v30, v62, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_140:

    goto LABEL_159;
  }
  v24 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
  id v25 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v75) = 0;
  if (__nwlog_fault(v25, type, &v75))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      BOOL v26 = __nwlog_obj();
      os_log_type_t v27 = type[0];
      if (os_log_type_enabled(v26, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
        _os_log_impl(&dword_1830D4000, v26, v27, "%{public}s called with null protocol", buf, 0xCu);
      }
    }
    else if ((_BYTE)v75)
    {
      BOOL v43 = (char *)__nw_create_backtrace_string();
      BOOL v26 = __nwlog_obj();
      os_log_type_t v44 = type[0];
      BOOL v45 = os_log_type_enabled(v26, type[0]);
      if (v43)
      {
        if (v45)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v43;
          _os_log_impl(&dword_1830D4000, v26, v44, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v43);
        goto LABEL_130;
      }
      if (v45)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
        _os_log_impl(&dword_1830D4000, v26, v44, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v26 = __nwlog_obj();
      os_log_type_t v61 = type[0];
      if (os_log_type_enabled(v26, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
        _os_log_impl(&dword_1830D4000, v26, v61, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_130:
  if (v25) {
    free(v25);
  }
}

BOOL nw_endpoint_proxy_unsatisfied_handler_should_use_proxy(void *a1)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  v2 = v1;
  if (!v1)
  {
    int v12 = __nwlog_obj();
    *(_DWORD *)os_log_type_t v27 = 136446210;
    *(void *)&v27[4] = "nw_endpoint_proxy_unsatisfied_handler_should_use_proxy";
    uint64_t v13 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    char v22 = 0;
    if (__nwlog_fault(v13, buf, &v22))
    {
      if (buf[0] == 17)
      {
        os_log_type_t v14 = __nwlog_obj();
        os_log_type_t v15 = buf[0];
        if (os_log_type_enabled(v14, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)os_log_type_t v27 = 136446210;
          *(void *)&v27[4] = "nw_endpoint_proxy_unsatisfied_handler_should_use_proxy";
          _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s called with null path", v27, 0xCu);
        }
      }
      else if (v22)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v14 = __nwlog_obj();
        os_log_type_t v17 = buf[0];
        BOOL v18 = os_log_type_enabled(v14, (os_log_type_t)buf[0]);
        if (backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)os_log_type_t v27 = 136446466;
            *(void *)&v27[4] = "nw_endpoint_proxy_unsatisfied_handler_should_use_proxy";
            *(_WORD *)&v27[12] = 2082;
            *(void *)&v27[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null path, dumping backtrace:%{public}s", v27, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_25;
        }
        if (v18)
        {
          *(_DWORD *)os_log_type_t v27 = 136446210;
          *(void *)&v27[4] = "nw_endpoint_proxy_unsatisfied_handler_should_use_proxy";
          _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null path, no backtrace", v27, 0xCu);
        }
      }
      else
      {
        os_log_type_t v14 = __nwlog_obj();
        os_log_type_t v19 = buf[0];
        if (os_log_type_enabled(v14, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)os_log_type_t v27 = 136446210;
          *(void *)&v27[4] = "nw_endpoint_proxy_unsatisfied_handler_should_use_proxy";
          _os_log_impl(&dword_1830D4000, v14, v19, "%{public}s called with null path, backtrace limit exceeded", v27, 0xCu);
        }
      }
    }
LABEL_25:
    if (v13) {
      free(v13);
    }
    goto LABEL_27;
  }
  id v3 = v1;
  int v4 = v3[94];

  if (v4 != 2)
  {
LABEL_27:
    BOOL v7 = 1;
    goto LABEL_28;
  }
  uint64_t v5 = v3;
  int v6 = v5[95];

  BOOL v7 = 1;
  if (v6 == 2)
  {
    *(void *)os_log_type_t v27 = 0;
    *(void *)&v27[8] = v27;
    *(void *)&v27[16] = 0x2020000000;
    char v28 = 1;
    uint64_t v8 = (atomic_uchar *)nw_path_copy_proxy_configs(v5);
    v9 = v8;
    if (v8)
    {
      v21[0] = MEMORY[0x1E4F143A8];
      v21[1] = 3221225472;
      v21[2] = __nw_endpoint_proxy_unsatisfied_handler_should_use_proxy_block_invoke;
      v21[3] = &unk_1E5248058;
      v21[4] = v27;
      nw_array_apply(v8, (uint64_t)v21);
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = (id)gLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      int v11 = *(unsigned __int8 *)(*(void *)&v27[8] + 24);
      *(_DWORD *)buf = 136446466;
      v24 = "nw_endpoint_proxy_unsatisfied_handler_should_use_proxy";
      __int16 v25 = 1024;
      int v26 = v11;
      _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_INFO, "%{public}s unsatisfied path allowed to use proxy: %d", buf, 0x12u);
    }

    BOOL v7 = *(unsigned char *)(*(void *)&v27[8] + 24) != 0;
    _Block_object_dispose(v27, 8);
  }
LABEL_28:

  return v7;
}

void sub_1834532B8(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v2 - 96), 8);

  _Unwind_Resume(a1);
}

void nw_protocol_http1_error(nw_protocol *a1, nw_protocol *a2, int a3)
{
  uint64_t v236 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http1_get_http1_protocol";
    v142 = (char *)_os_log_send_and_compose_impl();
    v235[0] = 16;
    LOBYTE(v229) = 0;
    if (!__nwlog_fault(v142, v235, &v229)) {
      goto LABEL_334;
    }
    if (v235[0] != 17)
    {
      if (!(_BYTE)v229)
      {
        v143 = __nwlog_obj();
        os_log_type_t v144 = v235[0];
        if (!os_log_type_enabled(v143, (os_log_type_t)v235[0])) {
          goto LABEL_334;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http1_get_http1_protocol";
        v145 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_333;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v143 = __nwlog_obj();
      os_log_type_t v144 = v235[0];
      BOOL v151 = os_log_type_enabled(v143, (os_log_type_t)v235[0]);
      if (!backtrace_string)
      {
        if (!v151) {
          goto LABEL_334;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http1_get_http1_protocol";
        v145 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_333;
      }
      if (v151)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http1_get_http1_protocol";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v143, v144, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_334;
    }
    v143 = __nwlog_obj();
    os_log_type_t v144 = v235[0];
    if (!os_log_type_enabled(v143, (os_log_type_t)v235[0])) {
      goto LABEL_334;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http1_get_http1_protocol";
    v145 = "%{public}s called with null protocol";
    goto LABEL_333;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http1_get_http1_protocol";
    v142 = (char *)_os_log_send_and_compose_impl();
    v235[0] = 16;
    LOBYTE(v229) = 0;
    if (!__nwlog_fault(v142, v235, &v229)) {
      goto LABEL_334;
    }
    if (v235[0] != 17)
    {
      if (!(_BYTE)v229)
      {
        v143 = __nwlog_obj();
        os_log_type_t v144 = v235[0];
        if (!os_log_type_enabled(v143, (os_log_type_t)v235[0])) {
          goto LABEL_334;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http1_get_http1_protocol";
        v145 = "%{public}s called with null handle, backtrace limit exceeded";
        goto LABEL_333;
      }
      v152 = (char *)__nw_create_backtrace_string();
      v143 = __nwlog_obj();
      os_log_type_t v144 = v235[0];
      BOOL v153 = os_log_type_enabled(v143, (os_log_type_t)v235[0]);
      if (!v152)
      {
        if (!v153) {
          goto LABEL_334;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http1_get_http1_protocol";
        v145 = "%{public}s called with null handle, no backtrace";
        goto LABEL_333;
      }
      if (!v153) {
        goto LABEL_247;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_http1_get_http1_protocol";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v152;
      v154 = "%{public}s called with null handle, dumping backtrace:%{public}s";
      goto LABEL_246;
    }
    v143 = __nwlog_obj();
    os_log_type_t v144 = v235[0];
    if (!os_log_type_enabled(v143, (os_log_type_t)v235[0])) {
      goto LABEL_334;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http1_get_http1_protocol";
    v145 = "%{public}s called with null handle";
LABEL_333:
    _os_log_impl(&dword_1830D4000, v143, v144, v145, buf, 0xCu);
    goto LABEL_334;
  }
  uint64_t v5 = a2;
  int v6 = *((_DWORD *)handle + 6);
  BOOL v7 = a1->handle;
  if (v6 == 1) {
    goto LABEL_10;
  }
  if (v6 != 2)
  {
    if (v6 != 3) {
      goto LABEL_336;
    }
    uint64_t v8 = *((void *)handle + 2);
    if (v8)
    {
      BOOL v7 = (void *)(v8 + 480);
      goto LABEL_10;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http1_get_http1_protocol";
    v142 = (char *)_os_log_send_and_compose_impl();
    v235[0] = 16;
    LOBYTE(v229) = 0;
    if (__nwlog_fault(v142, v235, &v229))
    {
      if (v235[0] == 17)
      {
        v143 = __nwlog_obj();
        os_log_type_t v144 = v235[0];
        if (!os_log_type_enabled(v143, (os_log_type_t)v235[0])) {
          goto LABEL_334;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http1_get_http1_protocol";
        v145 = "%{public}s called with null handle->http1_connection";
        goto LABEL_333;
      }
      if (!(_BYTE)v229)
      {
        v143 = __nwlog_obj();
        os_log_type_t v144 = v235[0];
        if (!os_log_type_enabled(v143, (os_log_type_t)v235[0])) {
          goto LABEL_334;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http1_get_http1_protocol";
        v145 = "%{public}s called with null handle->http1_connection, backtrace limit exceeded";
        goto LABEL_333;
      }
      v152 = (char *)__nw_create_backtrace_string();
      v143 = __nwlog_obj();
      os_log_type_t v144 = v235[0];
      BOOL v169 = os_log_type_enabled(v143, (os_log_type_t)v235[0]);
      if (!v152)
      {
        if (!v169) {
          goto LABEL_334;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http1_get_http1_protocol";
        v145 = "%{public}s called with null handle->http1_connection, no backtrace";
        goto LABEL_333;
      }
      if (v169)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http1_get_http1_protocol";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v152;
        v154 = "%{public}s called with null handle->http1_connection, dumping backtrace:%{public}s";
        goto LABEL_246;
      }
LABEL_247:
      free(v152);
      if (!v142)
      {
LABEL_336:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http1_error";
        v146 = (char *)_os_log_send_and_compose_impl();
        v235[0] = 16;
        LOBYTE(v229) = 0;
        if (!__nwlog_fault(v146, v235, &v229)) {
          goto LABEL_370;
        }
        if (v235[0] == 17)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v147 = gLogObj;
          os_log_type_t v148 = v235[0];
          if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v235[0])) {
            goto LABEL_370;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_http1_error";
          v149 = "%{public}s called with null http1";
        }
        else
        {
          if ((_BYTE)v229)
          {
            v184 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v185 = gLogObj;
            os_log_type_t v186 = v235[0];
            BOOL v187 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v235[0]);
            if (!v184)
            {
              if (!v187) {
                goto LABEL_370;
              }
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_http1_error";
              v149 = "%{public}s called with null http1, no backtrace";
              goto LABEL_375;
            }
            if (v187)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_protocol_http1_error";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v184;
              _os_log_impl(&dword_1830D4000, v185, v186, "%{public}s called with null http1, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v184);
LABEL_370:
            if (!v146) {
              return;
            }
            goto LABEL_371;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v147 = gLogObj;
          os_log_type_t v148 = v235[0];
          if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v235[0])) {
            goto LABEL_370;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_http1_error";
          v149 = "%{public}s called with null http1, backtrace limit exceeded";
        }
LABEL_368:
        v191 = v147;
        os_log_type_t v192 = v148;
LABEL_369:
        _os_log_impl(&dword_1830D4000, v191, v192, v149, buf, 0xCu);
        goto LABEL_370;
      }
LABEL_335:
      free(v142);
      goto LABEL_336;
    }
LABEL_334:
    if (!v142) {
      goto LABEL_336;
    }
    goto LABEL_335;
  }
  uint64_t v9 = *((void *)handle + 1);
  if (!v9)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http1_get_http1_protocol";
    v142 = (char *)_os_log_send_and_compose_impl();
    v235[0] = 16;
    LOBYTE(v229) = 0;
    if (!__nwlog_fault(v142, v235, &v229)) {
      goto LABEL_334;
    }
    if (v235[0] == 17)
    {
      v143 = __nwlog_obj();
      os_log_type_t v144 = v235[0];
      if (!os_log_type_enabled(v143, (os_log_type_t)v235[0])) {
        goto LABEL_334;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_get_http1_protocol";
      v145 = "%{public}s called with null handle->http1_stream";
      goto LABEL_333;
    }
    if (!(_BYTE)v229)
    {
      v143 = __nwlog_obj();
      os_log_type_t v144 = v235[0];
      if (!os_log_type_enabled(v143, (os_log_type_t)v235[0])) {
        goto LABEL_334;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_get_http1_protocol";
      v145 = "%{public}s called with null handle->http1_stream, backtrace limit exceeded";
      goto LABEL_333;
    }
    v152 = (char *)__nw_create_backtrace_string();
    v143 = __nwlog_obj();
    os_log_type_t v144 = v235[0];
    BOOL v168 = os_log_type_enabled(v143, (os_log_type_t)v235[0]);
    if (!v152)
    {
      if (!v168) {
        goto LABEL_334;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_get_http1_protocol";
      v145 = "%{public}s called with null handle->http1_stream, no backtrace";
      goto LABEL_333;
    }
    if (!v168) {
      goto LABEL_247;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_http1_get_http1_protocol";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v152;
    v154 = "%{public}s called with null handle->http1_stream, dumping backtrace:%{public}s";
LABEL_246:
    _os_log_impl(&dword_1830D4000, v143, v144, v154, buf, 0x16u);
    goto LABEL_247;
  }
  BOOL v7 = (void *)(v9 + 248);
LABEL_10:
  if (!*v7) {
    goto LABEL_336;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http1_error";
    v146 = (char *)_os_log_send_and_compose_impl();
    v235[0] = 16;
    LOBYTE(v229) = 0;
    if (!__nwlog_fault(v146, v235, &v229)) {
      goto LABEL_370;
    }
    if (v235[0] == 17)
    {
      v147 = __nwlog_obj();
      os_log_type_t v148 = v235[0];
      if (!os_log_type_enabled(v147, (os_log_type_t)v235[0])) {
        goto LABEL_370;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http1_error";
      v149 = "%{public}s called with null other_protocol";
    }
    else if ((_BYTE)v229)
    {
      v159 = (char *)__nw_create_backtrace_string();
      v147 = __nwlog_obj();
      os_log_type_t v148 = v235[0];
      BOOL v160 = os_log_type_enabled(v147, (os_log_type_t)v235[0]);
      if (v159)
      {
        if (v160)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_http1_error";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v159;
          _os_log_impl(&dword_1830D4000, v147, v148, "%{public}s called with null other_protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v159);
        if (!v146) {
          return;
        }
LABEL_371:
        free(v146);
        return;
      }
      if (!v160) {
        goto LABEL_370;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http1_error";
      v149 = "%{public}s called with null other_protocol, no backtrace";
    }
    else
    {
      v147 = __nwlog_obj();
      os_log_type_t v148 = v235[0];
      if (!os_log_type_enabled(v147, (os_log_type_t)v235[0])) {
        goto LABEL_370;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http1_error";
      v149 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    }
    goto LABEL_368;
  }
  if (v6 == 2)
  {
    uint64_t v11 = *((void *)handle + 1);
    if (v11)
    {
      v10 = (uint64_t *)(v11 + 256);
      goto LABEL_17;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http1_get_connection_for_protocol";
    v164 = (char *)_os_log_send_and_compose_impl();
    v235[0] = 16;
    LOBYTE(v229) = 0;
    if (__nwlog_fault(v164, v235, &v229))
    {
      if (v235[0] == 17)
      {
        v165 = __nwlog_obj();
        os_log_type_t v166 = v235[0];
        if (!os_log_type_enabled(v165, (os_log_type_t)v235[0])) {
          goto LABEL_354;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http1_get_connection_for_protocol";
        v167 = "%{public}s called with null handle->http1_stream";
        goto LABEL_353;
      }
      if (!(_BYTE)v229)
      {
        v165 = __nwlog_obj();
        os_log_type_t v166 = v235[0];
        if (!os_log_type_enabled(v165, (os_log_type_t)v235[0])) {
          goto LABEL_354;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http1_get_connection_for_protocol";
        v167 = "%{public}s called with null handle->http1_stream, backtrace limit exceeded";
        goto LABEL_353;
      }
      v170 = (char *)__nw_create_backtrace_string();
      v165 = __nwlog_obj();
      os_log_type_t v166 = v235[0];
      BOOL v171 = os_log_type_enabled(v165, (os_log_type_t)v235[0]);
      if (v170)
      {
        if (v171)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http1_get_connection_for_protocol";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v170;
          _os_log_impl(&dword_1830D4000, v165, v166, "%{public}s called with null handle->http1_stream, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v170);
        goto LABEL_354;
      }
      if (v171)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http1_get_connection_for_protocol";
        v167 = "%{public}s called with null handle->http1_stream, no backtrace";
LABEL_353:
        _os_log_impl(&dword_1830D4000, v165, v166, v167, buf, 0xCu);
      }
    }
LABEL_354:
    if (v164) {
      free(v164);
    }
LABEL_356:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http1_error";
    v146 = (char *)_os_log_send_and_compose_impl();
    v235[0] = 16;
    LOBYTE(v229) = 0;
    if (!__nwlog_fault(v146, v235, &v229)) {
      goto LABEL_370;
    }
    if (v235[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v147 = gLogObj;
      os_log_type_t v148 = v235[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v235[0])) {
        goto LABEL_370;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http1_error";
      v149 = "%{public}s called with null http1_connection";
      goto LABEL_368;
    }
    if (!(_BYTE)v229)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v147 = gLogObj;
      os_log_type_t v148 = v235[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v235[0])) {
        goto LABEL_370;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http1_error";
      v149 = "%{public}s called with null http1_connection, backtrace limit exceeded";
      goto LABEL_368;
    }
    v189 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v185 = gLogObj;
    os_log_type_t v186 = v235[0];
    BOOL v190 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v235[0]);
    if (v189)
    {
      if (v190)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http1_error";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v189;
        _os_log_impl(&dword_1830D4000, v185, v186, "%{public}s called with null http1_connection, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v189);
      if (!v146) {
        return;
      }
      goto LABEL_371;
    }
    if (v190)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http1_error";
      v149 = "%{public}s called with null http1_connection, no backtrace";
LABEL_375:
      v191 = v185;
      os_log_type_t v192 = v186;
      goto LABEL_369;
    }
    goto LABEL_370;
  }
  if (v6 != 3) {
    goto LABEL_356;
  }
  v10 = (uint64_t *)(handle + 16);
LABEL_17:
  uint64_t v12 = *v10;
  if (!*v10) {
    goto LABEL_356;
  }
  if ((*(unsigned char *)(v12 + 158) & 1) == 0)
  {
    if (gLogDatapath)
    {
      v155 = __nwlog_obj();
      if (os_log_type_enabled(v155, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v156 = *(void *)(v12 + 488);
        int v157 = *(_DWORD *)(*(void *)(v12 + 480) + 372);
        int v158 = *(_DWORD *)(v12 + 860);
        if (v156) {
          LODWORD(v156) = *(_DWORD *)(v156 + 424);
        }
        *(_DWORD *)buf = 136447746;
        *(void *)&uint8_t buf[4] = "nw_protocol_http1_error";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v12 + 74;
        *(_WORD *)&buf[22] = 2080;
        *(void *)&unsigned char buf[24] = " ";
        *(_WORD *)&buf[32] = 1024;
        *(_DWORD *)&buf[34] = v157;
        *(_WORD *)&buf[38] = 1024;
        *(_DWORD *)&buf[40] = v158;
        *(_WORD *)v234 = 1024;
        *(_DWORD *)&v234[2] = v156;
        *(_WORD *)&v234[6] = 1024;
        *(_DWORD *)&v234[8] = a3;
        _os_log_impl(&dword_1830D4000, v155, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:c%u:s%u> called with error %d", buf, 0x38u);
      }
    }
  }
  if (!a3)
  {
    if (*(unsigned char *)(v12 + 158)) {
      return;
    }
    if (!gLogDatapath) {
      return;
    }
    char v22 = __nwlog_obj();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG)) {
      return;
    }
    uint64_t v23 = *(void *)(v12 + 488);
    int v24 = *(_DWORD *)(*(void *)(v12 + 480) + 372);
    int v25 = *(_DWORD *)(v12 + 860);
    if (v23) {
      LODWORD(v23) = *(_DWORD *)(v23 + 424);
    }
    *(_DWORD *)buf = 136447490;
    *(void *)&uint8_t buf[4] = "nw_protocol_http1_error";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v12 + 74;
    *(_WORD *)&buf[22] = 2080;
    *(void *)&unsigned char buf[24] = " ";
    *(_WORD *)&buf[32] = 1024;
    *(_DWORD *)&buf[34] = v24;
    *(_WORD *)&buf[38] = 1024;
    *(_DWORD *)&buf[40] = v25;
    *(_WORD *)v234 = 1024;
    *(_DWORD *)&v234[2] = v23;
    BOOL v18 = "%{public}s %{public}s%s<i%u:c%u:s%u> suppressing error 0";
LABEL_119:
    os_log_type_t v19 = v22;
    os_log_type_t v20 = OS_LOG_TYPE_DEBUG;
    uint32_t v21 = 50;
LABEL_27:
    _os_log_impl(&dword_1830D4000, v19, v20, v18, buf, v21);
    return;
  }
  if (*(_DWORD *)(v12 + 868))
  {
    if (*(unsigned char *)(v12 + 158)) {
      return;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v13 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
      return;
    }
    uint64_t v14 = *(void *)(v12 + 488);
    int v15 = *(_DWORD *)(*(void *)(v12 + 480) + 372);
    int v16 = *(_DWORD *)(v12 + 860);
    if (v14) {
      LODWORD(v14) = *(_DWORD *)(v14 + 424);
    }
    int v17 = *(_DWORD *)(v12 + 868);
    *(_DWORD *)buf = 136448002;
    *(void *)&uint8_t buf[4] = "nw_protocol_http1_error";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v12 + 74;
    *(_WORD *)&buf[22] = 2080;
    *(void *)&unsigned char buf[24] = " ";
    *(_WORD *)&buf[32] = 1024;
    *(_DWORD *)&buf[34] = v15;
    *(_WORD *)&buf[38] = 1024;
    *(_DWORD *)&buf[40] = v16;
    *(_WORD *)v234 = 1024;
    *(_DWORD *)&v234[2] = v14;
    *(_WORD *)&v234[6] = 1024;
    *(_DWORD *)&v234[8] = a3;
    *(_WORD *)&v234[12] = 1024;
    *(_DWORD *)&v234[14] = v17;
    BOOL v18 = "%{public}s %{public}s%s<i%u:c%u:s%u> suppressing received error: %d, connection error already set to: %d";
    os_log_type_t v19 = v13;
    os_log_type_t v20 = OS_LOG_TYPE_INFO;
    uint32_t v21 = 62;
    goto LABEL_27;
  }
  *(_DWORD *)(v12 + 868) = a3;
  int v26 = (unsigned __int16 *)(v12 + 872);
  int v27 = *(unsigned __int16 *)(v12 + 872);
  int v28 = v27 | (*(unsigned __int8 *)(v12 + 874) << 16);
  if ((v27 & 0x2000) != 0)
  {
    if (*(unsigned char *)(v12 + 158)) {
      goto LABEL_112;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v65 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
      goto LABEL_112;
    }
    uint64_t v66 = *(void *)(v12 + 488);
    int v67 = *(_DWORD *)(*(void *)(v12 + 480) + 372);
    int v68 = *(_DWORD *)(v12 + 860);
    if (v66) {
      LODWORD(v66) = *(_DWORD *)(v66 + 424);
    }
    *(_DWORD *)buf = 136447490;
    *(void *)&uint8_t buf[4] = "nw_http1_connection_finish_input";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v12 + 74;
    *(_WORD *)&buf[22] = 2080;
    *(void *)&unsigned char buf[24] = " ";
    *(_WORD *)&buf[32] = 1024;
    *(_DWORD *)&buf[34] = v67;
    *(_WORD *)&buf[38] = 1024;
    *(_DWORD *)&buf[40] = v68;
    *(_WORD *)v234 = 1024;
    *(_DWORD *)&v234[2] = v66;
    os_log_type_t v69 = "%{public}s %{public}s%s<i%u:c%u:s%u> input already finished, returning";
LABEL_111:
    _os_log_impl(&dword_1830D4000, v65, OS_LOG_TYPE_INFO, v69, buf, 0x32u);
    goto LABEL_112;
  }
  *(unsigned char *)(v12 + 874) = BYTE2(v28);
  *int v26 = v28 | 0x2000;
  if ((v28 & 0x40000) != 0)
  {
    if (*(unsigned char *)(v12 + 158)) {
      goto LABEL_112;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v65 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
      goto LABEL_112;
    }
    uint64_t v70 = *(void *)(v12 + 488);
    int v71 = *(_DWORD *)(*(void *)(v12 + 480) + 372);
    int v72 = *(_DWORD *)(v12 + 860);
    if (v70) {
      LODWORD(v70) = *(_DWORD *)(v70 + 424);
    }
    *(_DWORD *)buf = 136447490;
    *(void *)&uint8_t buf[4] = "nw_http1_connection_finish_input";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v12 + 74;
    *(_WORD *)&buf[22] = 2080;
    *(void *)&unsigned char buf[24] = " ";
    *(_WORD *)&buf[32] = 1024;
    *(_DWORD *)&buf[34] = v71;
    *(_WORD *)&buf[38] = 1024;
    *(_DWORD *)&buf[40] = v72;
    *(_WORD *)v234 = 1024;
    *(_DWORD *)&v234[2] = v70;
    os_log_type_t v69 = "%{public}s %{public}s%s<i%u:c%u:s%u> already getting input frames, returning";
    goto LABEL_111;
  }
  v226 = v5;
  v227 = (_WORD *)(v12 + 872);
  int v228 = a3;
  int v29 = 0;
  v229 = 0;
  v230 = &v229;
  do
  {
    int input_frames = nw_protocol_get_input_frames(*(void *)(v12 + 32), v12, 1, 0xFFFFFFFFLL, 0xFFFFFFFFLL, (uint64_t)&v229);
    os_log_type_t v31 = v229;
    if (!v229) {
      goto LABEL_38;
    }
    if (gLogDatapath)
    {
      os_log_type_t v63 = __nwlog_obj();
      if (os_log_type_enabled(v63, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136447746;
        *(void *)&uint8_t buf[4] = "nw_http1_move_frame_array";
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = v31;
        *(_WORD *)&buf[22] = 2048;
        *(void *)&unsigned char buf[24] = &v229;
        *(_WORD *)&buf[32] = 2048;
        *(void *)&buf[34] = v12 + 616;
        *(_WORD *)&buf[42] = 1024;
        *(_DWORD *)v234 = 1;
        *(_WORD *)&v234[4] = 1024;
        *(_DWORD *)&v234[6] = 1;
        *(_WORD *)&v234[10] = 1024;
        *(_DWORD *)&v234[12] = 1;
        _os_log_impl(&dword_1830D4000, v63, OS_LOG_TYPE_DEBUG, "%{public}s called: initial frame %p, source %p, destination %p, temp %u, forwards %u, append %u", buf, 0x3Cu);
      }
    }
    int v32 = 0;
    *(void *)v235 = 0;
    *(void *)&v235[8] = v235;
    do
    {
      char v34 = (_DWORD *)*((void *)v31 + 4);
      if (!v34 && !*((void *)v31 + 5)) {
        char v34 = 0;
      }
      if (gLogDatapath)
      {
        v37 = __nwlog_obj();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
        {
          int v38 = v31[13];
          if (v38) {
            v38 -= v31[14] + v31[15];
          }
          if (v34)
          {
            int v39 = v34[13];
            if (v39) {
              v39 -= v34[14] + v34[15];
            }
          }
          else
          {
            int v39 = 0;
          }
          *(_DWORD *)buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_http1_move_frame_array";
          *(_WORD *)&buf[12] = 2048;
          *(void *)&buf[14] = v31;
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&unsigned char buf[24] = v38;
          *(_WORD *)&buf[28] = 2048;
          *(void *)&buf[30] = v34;
          *(_WORD *)&buf[38] = 1024;
          *(_DWORD *)&buf[40] = v39;
          _os_log_impl(&dword_1830D4000, v37, OS_LOG_TYPE_DEBUG, "%{public}s current frame: (%p, %u bytes), next frame: (%p, %u bytes)", buf, 0x2Cu);
        }
      }
      uint64_t v35 = *((void *)v31 + 4);
      id v36 = (void *)*((void *)v31 + 5);
      if (v35)
      {
        *(void *)(v35 + 40) = v36;
        id v36 = (void *)*((void *)v31 + 5);
      }
      else
      {
        v230 = (void *)*((void *)v31 + 5);
      }
      *id v36 = v35;
      os_log_type_t v33 = *(void **)&v235[8];
      *((void *)v31 + 4) = 0;
      *((void *)v31 + 5) = v33;
      *os_log_type_t v33 = v31;
      *(void *)&v235[8] = v31 + 8;
      ++v32;
      os_log_type_t v31 = v34;
    }
    while (v34);
    if (v32)
    {
      if (gLogDatapath)
      {
        os_log_type_t v64 = __nwlog_obj();
        if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http1_move_frame_array";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v32;
          _os_log_impl(&dword_1830D4000, v64, OS_LOG_TYPE_DEBUG, "%{public}s moving %u frames from temp array to destination array", buf, 0x12u);
        }
      }
      os_log_type_t v40 = *(_DWORD **)v235;
      int v41 = v32;
      if (!*(void *)v235) {
        goto LABEL_79;
      }
      int v41 = v32;
      do
      {
        os_log_type_t v44 = v40 + 8;
        BOOL v45 = (_DWORD *)*((void *)v40 + 4);
        if (!v45 && !*((void *)v40 + 5)) {
          BOOL v45 = 0;
        }
        if (gLogDatapath)
        {
          os_log_type_t v47 = __nwlog_obj();
          if (os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG))
          {
            int v48 = v40[13];
            if (v48) {
              v48 -= v40[14] + v40[15];
            }
            if (v45)
            {
              int v49 = v45[13];
              if (v49) {
                v49 -= v45[14] + v45[15];
              }
            }
            else
            {
              int v49 = 0;
            }
            *(_DWORD *)buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_http1_move_frame_array";
            *(_WORD *)&buf[12] = 2048;
            *(void *)&buf[14] = v40;
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&unsigned char buf[24] = v48;
            *(_WORD *)&buf[28] = 2048;
            *(void *)&buf[30] = v45;
            *(_WORD *)&buf[38] = 1024;
            *(_DWORD *)&buf[40] = v49;
            _os_log_impl(&dword_1830D4000, v47, OS_LOG_TYPE_DEBUG, "%{public}s current frame: (%p, %u bytes), next frame: (%p, %u bytes)", buf, 0x2Cu);
          }
        }
        uint64_t v46 = *((void *)v40 + 4);
        os_log_type_t v42 = (void *)*((void *)v40 + 5);
        if (v46)
        {
          *(void *)(v46 + 40) = v42;
          os_log_type_t v42 = (void *)*((void *)v40 + 5);
        }
        else
        {
          *(void *)&v235[8] = *((void *)v40 + 5);
        }
        void *v42 = v46;
        void *v44 = 0;
        *((void *)v40 + 5) = 0;
        BOOL v43 = *(void **)(v12 + 624);
        *((void *)v40 + 5) = v43;
        *BOOL v43 = v40;
        *(void *)(v12 + 624) = v44;
        --v41;
        os_log_type_t v40 = v45;
      }
      while (v45);
      if (v41)
      {
LABEL_79:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http1_move_frame_array";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v41;
        os_log_type_t v50 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v231 = 0;
        if (!__nwlog_fault(v50, &type, &v231)) {
          goto LABEL_93;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v51 = gLogObj;
          os_log_type_t v52 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_93;
          }
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http1_move_frame_array";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v41;
          BOOL v53 = v51;
          os_log_type_t v54 = v52;
          v55 = "%{public}s failed to deliver all temp frames, remaining %u frames";
        }
        else if (v231)
        {
          os_log_type_t v56 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v57 = gLogObj;
          os_log_type_t v58 = type;
          BOOL v59 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (v56)
          {
            if (v59)
            {
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_http1_move_frame_array";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v41;
              *(_WORD *)&buf[18] = 2082;
              *(void *)&buf[20] = v56;
              _os_log_impl(&dword_1830D4000, v57, v58, "%{public}s failed to deliver all temp frames, remaining %u frames, dumping backtrace:%{public}s", buf, 0x1Cu);
            }
            free(v56);
            goto LABEL_93;
          }
          if (!v59)
          {
LABEL_93:
            if (v50) {
              free(v50);
            }
            goto LABEL_37;
          }
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http1_move_frame_array";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v41;
          BOOL v53 = v57;
          os_log_type_t v54 = v58;
          v55 = "%{public}s failed to deliver all temp frames, remaining %u frames, no backtrace";
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v60 = gLogObj;
          os_log_type_t v61 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_93;
          }
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http1_move_frame_array";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v41;
          BOOL v53 = v60;
          os_log_type_t v54 = v61;
          v55 = "%{public}s failed to deliver all temp frames, remaining %u frames, backtrace limit exceeded";
        }
        _os_log_impl(&dword_1830D4000, v53, v54, v55, buf, 0x12u);
        goto LABEL_93;
      }
    }
LABEL_37:
    if (gLogDatapath)
    {
      os_log_type_t v62 = __nwlog_obj();
      if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_http1_move_frame_array";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v32;
        *(_WORD *)&buf[18] = 2048;
        *(void *)&buf[20] = &v229;
        *(_WORD *)&buf[28] = 2048;
        *(void *)&buf[30] = v12 + 616;
        _os_log_impl(&dword_1830D4000, v62, OS_LOG_TYPE_DEBUG, "%{public}s moved %u frames from %p to %p", buf, 0x26u);
      }
    }
LABEL_38:
    v29 += input_frames;
  }
  while (input_frames);
  if (gLogDatapath)
  {
    v188 = __nwlog_obj();
    if (os_log_type_enabled(v188, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
      _os_log_impl(&dword_1830D4000, v188, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }
  *(void *)buf = MEMORY[0x1E4F143A8];
  *(void *)&buf[8] = 0x40000000;
  *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_40118;
  *(void *)&unsigned char buf[24] = &__block_descriptor_tmp_58_40119;
  *(void *)&buf[32] = &v229;
  buf[40] = 0;
  __int16 v81 = v229;
  int v26 = (unsigned __int16 *)(v12 + 872);
  do
  {
    if (!v81) {
      break;
    }
    BOOL v82 = (_DWORD *)*((void *)v81 + 4);
    char v83 = (*(uint64_t (**)(unsigned char *))&buf[16])(buf);
    __int16 v81 = v82;
  }
  while ((v83 & 1) != 0);
  int v84 = (unsigned __int16)*v227;
  int v85 = v84 | (*(unsigned __int8 *)(v12 + 874) << 16);
  a3 = v228;
  if ((v84 & 0x6000) == 0x2000 && !*(void *)(v12 + 616))
  {
    *(unsigned char *)(v12 + 874) = BYTE2(v85);
    _WORD *v227 = v85 | 0x4000;
    if (*(void *)(v12 + 488))
    {
      if (*(_DWORD *)(v12 + 868) && llhttp_message_needs_eof(v12 + 200))
      {
        if ((v85 & 4) == 0)
        {
          unsigned int v112 = 5;
          goto LABEL_196;
        }
LABEL_383:
        if ((*(unsigned char *)(v12 + 158) & 1) == 0)
        {
          if (gLogDatapath)
          {
            v194 = __nwlog_obj();
            if (os_log_type_enabled(v194, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v195 = *(void *)(v12 + 488);
              int v196 = *(_DWORD *)(*(void *)(v12 + 480) + 372);
              int v197 = *(_DWORD *)(v12 + 860);
              if (v195) {
                LODWORD(v195) = *(_DWORD *)(v195 + 424);
              }
              *(_DWORD *)buf = 136447490;
              *(void *)&uint8_t buf[4] = "nw_http1_parser_signal_eof_if_needed";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v12 + 74;
              *(_WORD *)&buf[22] = 2080;
              *(void *)&unsigned char buf[24] = " ";
              *(_WORD *)&buf[32] = 1024;
              *(_DWORD *)&buf[34] = v196;
              *(_WORD *)&buf[38] = 1024;
              *(_DWORD *)&buf[40] = v197;
              *(_WORD *)v234 = 1024;
              *(_DWORD *)&v234[2] = v195;
              _os_log_impl(&dword_1830D4000, v194, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:c%u:s%u> signaled eof and terminated message successfully", buf, 0x32u);
              a3 = v228;
              int v26 = (unsigned __int16 *)(v12 + 872);
            }
          }
        }
        *((unsigned char *)v26 + 2) = (*v26 | (*((unsigned __int8 *)v26 + 2) << 16) | 0x10000u) >> 16;
        goto LABEL_131;
      }
      unsigned int v116 = llhttp_finish(v12 + 200);
      if ((*v227 & 4) != 0) {
        goto LABEL_383;
      }
      unsigned int v112 = v116;
      if (!v116) {
        goto LABEL_383;
      }
      if (v116 != 14) {
        goto LABEL_196;
      }
      uint64_t v117 = *(void *)(v12 + 488);
      if (v117)
      {
        unsigned int v112 = 14;
        if ((*v227 & 1) == 0 || (*(_WORD *)(v117 + 428) & 1) != 0 || *(_DWORD *)(v12 + 848) || *(_DWORD *)(v12 + 852))
        {
LABEL_196:
          if ((*(unsigned char *)(v12 + 158) & 1) == 0)
          {
            uint64_t v118 = __nwlog_obj();
            if (os_log_type_enabled(v118, OS_LOG_TYPE_ERROR))
            {
              uint64_t v119 = *(void *)(v12 + 488);
              if (v119) {
                LODWORD(v119) = *(_DWORD *)(v119 + 424);
              }
              if (v112 >= 0x24) {
                abort();
              }
              int v120 = *(_DWORD *)(*(void *)(v12 + 480) + 372);
              int v121 = *(_DWORD *)(v12 + 860);
              v122 = off_1E52441B8[v112];
              *(_DWORD *)buf = 136447746;
              *(void *)&uint8_t buf[4] = "nw_http1_parser_signal_eof_if_needed";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v12 + 74;
              *(_WORD *)&buf[22] = 2080;
              *(void *)&unsigned char buf[24] = " ";
              *(_WORD *)&buf[32] = 1024;
              *(_DWORD *)&buf[34] = v120;
              *(_WORD *)&buf[38] = 1024;
              *(_DWORD *)&buf[40] = v121;
              *(_WORD *)v234 = 1024;
              *(_DWORD *)&v234[2] = v119;
              *(_WORD *)&v234[6] = 2080;
              *(void *)&v234[8] = v122;
              _os_log_impl(&dword_1830D4000, v118, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:c%u:s%u> parser eof did not terminate full message with errno: %s, deferring input error", buf, 0x3Cu);
            }
          }
          goto LABEL_131;
        }
        if (!*(_DWORD *)(v12 + 856))
        {
          if ((*v227 & 2) != 0 && *(void *)(v12 + 800))
          {
            if (!*(void *)(v12 + 808))
            {
              v193 = strdup("");
              if (!v193)
              {
                v224 = __nwlog_obj();
                os_log_type_enabled(v224, OS_LOG_TYPE_ERROR);
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "strict_strdup";
                v225 = (void *)_os_log_send_and_compose_impl();
                if (__nwlog_abort((uint64_t)v225))
                {
                  __break(1u);
                  return;
                }
                free(v225);
              }
              *(void *)(v12 + 808) = v193;
            }
            nw_http1_on_header_value_complete(v12 + 200);
          }
          nw_http1_on_headers_complete(v12 + 200);
          nw_http1_on_message_complete(v12 + 200);
          a3 = v228;
          int v26 = (unsigned __int16 *)(v12 + 872);
          goto LABEL_383;
        }
LABEL_195:
        a3 = v228;
        int v26 = (unsigned __int16 *)(v12 + 872);
        goto LABEL_196;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_recover_incomplete_header";
      v206 = (char *)_os_log_send_and_compose_impl();
      v235[0] = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v206, v235, &type))
      {
        if (v235[0] == 17)
        {
          v207 = __nwlog_obj();
          os_log_type_t v208 = v235[0];
          if (os_log_type_enabled(v207, (os_log_type_t)v235[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_http1_recover_incomplete_header";
            v209 = "%{public}s called with null http1_stream";
LABEL_448:
            _os_log_impl(&dword_1830D4000, v207, v208, v209, buf, 0xCu);
          }
        }
        else if (type)
        {
          v217 = (char *)__nw_create_backtrace_string();
          v207 = __nwlog_obj();
          os_log_type_t v208 = v235[0];
          BOOL v218 = os_log_type_enabled(v207, (os_log_type_t)v235[0]);
          if (v217)
          {
            if (v218)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_http1_recover_incomplete_header";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v217;
              _os_log_impl(&dword_1830D4000, v207, v208, "%{public}s called with null http1_stream, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v217);
            goto LABEL_449;
          }
          if (v218)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_http1_recover_incomplete_header";
            v209 = "%{public}s called with null http1_stream, no backtrace";
            goto LABEL_448;
          }
        }
        else
        {
          v207 = __nwlog_obj();
          os_log_type_t v208 = v235[0];
          if (os_log_type_enabled(v207, (os_log_type_t)v235[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_http1_recover_incomplete_header";
            v209 = "%{public}s called with null http1_stream, backtrace limit exceeded";
            goto LABEL_448;
          }
        }
      }
LABEL_449:
      if (v206) {
        free(v206);
      }
      unsigned int v112 = 14;
      goto LABEL_195;
    }
    if ((v85 & 0x100) != 0)
    {
      if ((*(unsigned char *)(v12 + 158) & 1) == 0)
      {
        if (gLogDatapath)
        {
          v134 = __nwlog_obj();
          if (os_log_type_enabled(v134, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v135 = *(void *)(v12 + 488);
            int v136 = *(_DWORD *)(*(void *)(v12 + 480) + 372);
            int v137 = *(_DWORD *)(v12 + 860);
            if (v135) {
              LODWORD(v135) = *(_DWORD *)(v135 + 424);
            }
            *(_DWORD *)buf = 136447490;
            *(void *)&uint8_t buf[4] = "nw_http1_connection_close";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v12 + 74;
            *(_WORD *)&buf[22] = 2080;
            *(void *)&unsigned char buf[24] = " ";
            *(_WORD *)&buf[32] = 1024;
            *(_DWORD *)&buf[34] = v136;
            *(_WORD *)&buf[38] = 1024;
            *(_DWORD *)&buf[40] = v137;
            *(_WORD *)v234 = 1024;
            *(_DWORD *)&v234[2] = v135;
            _os_log_impl(&dword_1830D4000, v134, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:c%u:s%u> already closed", buf, 0x32u);
            a3 = v228;
            int v26 = (unsigned __int16 *)(v12 + 872);
          }
        }
      }
      goto LABEL_131;
    }
    *(unsigned char *)(v12 + 874) = BYTE2(v85);
    _WORD *v227 = v85 | 0x4100;
    if ((*(unsigned char *)(v12 + 158) & 1) == 0)
    {
      if (gLogDatapath)
      {
        v202 = __nwlog_obj();
        if (os_log_type_enabled(v202, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v203 = *(void *)(v12 + 488);
          int v204 = *(_DWORD *)(*(void *)(v12 + 480) + 372);
          int v205 = *(_DWORD *)(v12 + 860);
          if (v203) {
            LODWORD(v203) = *(_DWORD *)(v203 + 424);
          }
          *(_DWORD *)buf = 136447490;
          *(void *)&uint8_t buf[4] = "nw_http1_connection_close";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v12 + 74;
          *(_WORD *)&buf[22] = 2080;
          *(void *)&unsigned char buf[24] = " ";
          *(_WORD *)&buf[32] = 1024;
          *(_DWORD *)&buf[34] = v204;
          *(_WORD *)&buf[38] = 1024;
          *(_DWORD *)&buf[40] = v205;
          *(_WORD *)v234 = 1024;
          *(_DWORD *)&v234[2] = v203;
          _os_log_impl(&dword_1830D4000, v202, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:c%u:s%u> http connection closed, increasing pool width", buf, 0x32u);
          a3 = v228;
          int v26 = (unsigned __int16 *)(v12 + 872);
        }
      }
    }
    uint64_t v123 = *(void *)(v12 + 480);
    if (!v123)
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
      v198 = (char *)_os_log_send_and_compose_impl();
      v235[0] = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v198, v235, &type)) {
        goto LABEL_458;
      }
      if (v235[0] == 17)
      {
        v199 = __nwlog_obj();
        os_log_type_t v200 = v235[0];
        if (!os_log_type_enabled(v199, (os_log_type_t)v235[0])) {
          goto LABEL_458;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
        v201 = "%{public}s called with null http1";
      }
      else if (type)
      {
        v210 = (char *)__nw_create_backtrace_string();
        v199 = __nwlog_obj();
        os_log_type_t v200 = v235[0];
        BOOL v211 = os_log_type_enabled(v199, (os_log_type_t)v235[0]);
        if (v210)
        {
          if (v211)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v210;
            _os_log_impl(&dword_1830D4000, v199, v200, "%{public}s called with null http1, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v210);
          goto LABEL_458;
        }
        if (!v211) {
          goto LABEL_458;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
        v201 = "%{public}s called with null http1, no backtrace";
      }
      else
      {
        v199 = __nwlog_obj();
        os_log_type_t v200 = v235[0];
        if (!os_log_type_enabled(v199, (os_log_type_t)v235[0])) {
          goto LABEL_458;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
        v201 = "%{public}s called with null http1, backtrace limit exceeded";
      }
      v223 = buf;
LABEL_457:
      _os_log_impl(&dword_1830D4000, v199, v200, v201, v223, 0xCu);
      goto LABEL_458;
    }
    int v124 = *v26;
    int v125 = v124 | (*((unsigned __int8 *)v26 + 2) << 16);
    if ((v124 & 0x800) != 0)
    {
      if ((*(unsigned char *)(v12 + 158) & 1) != 0
        || !gLogDatapath
        || (v138 = __nwlog_obj(), !os_log_type_enabled(v138, OS_LOG_TYPE_DEBUG)))
      {
LABEL_314:
        if (*(void *)(v12 + 488)) {
          goto LABEL_131;
        }
LABEL_315:
        uint64_t v177 = *(void *)(v12 + 784);
        if (v177)
        {
          nw_queue_set_timer_values(v177, 0x8000000000000000, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
        }
        else
        {
          if ((*(unsigned char *)(v12 + 158) & 1) == 0)
          {
            v178 = __nwlog_obj();
            if (os_log_type_enabled(v178, OS_LOG_TYPE_ERROR))
            {
              uint64_t v179 = *(void *)(v12 + 488);
              int v180 = *(_DWORD *)(*(void *)(v12 + 480) + 372);
              int v181 = *(_DWORD *)(v12 + 860);
              if (v179) {
                LODWORD(v179) = *(_DWORD *)(v179 + 424);
              }
              *(_DWORD *)buf = 136447490;
              *(void *)&uint8_t buf[4] = "nw_http1_connection_close";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v12 + 74;
              *(_WORD *)&buf[22] = 2080;
              *(void *)&unsigned char buf[24] = " ";
              *(_WORD *)&buf[32] = 1024;
              *(_DWORD *)&buf[34] = v180;
              *(_WORD *)&buf[38] = 1024;
              *(_DWORD *)&buf[40] = v181;
              *(_WORD *)v234 = 1024;
              *(_DWORD *)&v234[2] = v179;
              _os_log_impl(&dword_1830D4000, v178, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:c%u:s%u> No destroy timer on HTTP/1 connection when closing", buf, 0x32u);
              a3 = v228;
              int v26 = (unsigned __int16 *)(v12 + 872);
            }
          }
          uint64_t v182 = *(void *)(v12 + 608);
          v183 = *(void **)(v12 + 496);
          *(void *)buf = MEMORY[0x1E4F143A8];
          *(void *)&buf[8] = 0x40000000;
          *(void *)&buf[16] = ___ZL25nw_http1_connection_closeP19nw_http1_connection_block_invoke;
          *(void *)&unsigned char buf[24] = &unk_1E52411A0;
          *(void *)&buf[32] = v182;
          nw_queue_context_async(v183, buf);
        }
        goto LABEL_131;
      }
      uint64_t v139 = *(void *)(v12 + 488);
      int v140 = *(_DWORD *)(*(void *)(v12 + 480) + 372);
      int v141 = *(_DWORD *)(v12 + 860);
      if (v139) {
        LODWORD(v139) = *(_DWORD *)(v139 + 424);
      }
      *(_DWORD *)buf = 136447490;
      *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v12 + 74;
      *(_WORD *)&buf[22] = 2080;
      *(void *)&unsigned char buf[24] = " ";
      *(_WORD *)&buf[32] = 1024;
      *(_DWORD *)&buf[34] = v140;
      *(_WORD *)&buf[38] = 1024;
      *(_DWORD *)&buf[40] = v141;
      *(_WORD *)v234 = 1024;
      *(_DWORD *)&v234[2] = v139;
      _os_log_impl(&dword_1830D4000, v138, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:c%u:s%u> Connection already marked as not-reusable, ignoring", buf, 0x32u);
      goto LABEL_460;
    }
    *((unsigned char *)v26 + 2) = BYTE2(v125);
    *int v26 = v125 | 0x800;
    uint64_t v126 = *(unsigned int *)(v123 + 368) + 1;
    uint64_t v127 = v126 << 31 >> 31;
    *(_DWORD *)(v123 + 368) = v126;
    if (v127 == v126 && (v127 & 0x8000000000000000) == 0)
    {
LABEL_309:
      if ((*(unsigned char *)(v12 + 158) & 1) == 0)
      {
        if (gLogDatapath)
        {
          v212 = __nwlog_obj();
          if (os_log_type_enabled(v212, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v213 = *(void *)(v12 + 488);
            int v214 = *(_DWORD *)(*(void *)(v12 + 480) + 372);
            int v215 = *(_DWORD *)(v12 + 860);
            if (v213) {
              LODWORD(v213) = *(_DWORD *)(v213 + 424);
            }
            int v216 = *(_DWORD *)(v123 + 368) + *(_DWORD *)(v123 + 364);
            *(_DWORD *)buf = 136447746;
            *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v12 + 74;
            *(_WORD *)&buf[22] = 2080;
            *(void *)&unsigned char buf[24] = " ";
            *(_WORD *)&buf[32] = 1024;
            *(_DWORD *)&buf[34] = v214;
            *(_WORD *)&buf[38] = 1024;
            *(_DWORD *)&buf[40] = v215;
            *(_WORD *)v234 = 1024;
            *(_DWORD *)&v234[2] = v213;
            *(_WORD *)&v234[6] = 1024;
            *(_DWORD *)&v234[8] = v216;
            _os_log_impl(&dword_1830D4000, v212, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:c%u:s%u> connection marked as not-reusable, increased pool width to %u", buf, 0x38u);
            a3 = v228;
            int v26 = (unsigned __int16 *)(v12 + 872);
          }
        }
      }
      v174 = *(void **)(v12 + 496);
      if (!v174)
      {
        __nwlog_obj();
        *(_DWORD *)v235 = 136446210;
        *(void *)&v235[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
        v198 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v231 = 0;
        if (!__nwlog_fault(v198, &type, &v231)) {
          goto LABEL_458;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          v199 = __nwlog_obj();
          os_log_type_t v200 = type;
          if (!os_log_type_enabled(v199, type)) {
            goto LABEL_458;
          }
          *(_DWORD *)v235 = 136446210;
          *(void *)&v235[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
          v201 = "%{public}s called with null http1_connection->context";
LABEL_456:
          v223 = v235;
          goto LABEL_457;
        }
        if (!v231)
        {
          v199 = __nwlog_obj();
          os_log_type_t v200 = type;
          if (!os_log_type_enabled(v199, type)) {
            goto LABEL_458;
          }
          *(_DWORD *)v235 = 136446210;
          *(void *)&v235[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
          v201 = "%{public}s called with null http1_connection->context, backtrace limit exceeded";
          goto LABEL_456;
        }
        v219 = (char *)__nw_create_backtrace_string();
        v199 = __nwlog_obj();
        os_log_type_t v200 = type;
        BOOL v220 = os_log_type_enabled(v199, type);
        if (!v219)
        {
          if (!v220) {
            goto LABEL_458;
          }
          *(_DWORD *)v235 = 136446210;
          *(void *)&v235[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
          v201 = "%{public}s called with null http1_connection->context, no backtrace";
          goto LABEL_456;
        }
        if (!v220) {
          goto LABEL_433;
        }
        *(_DWORD *)v235 = 136446466;
        *(void *)&v235[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
        *(_WORD *)&v235[12] = 2082;
        *(void *)&v235[14] = v219;
        v221 = "%{public}s called with null http1_connection->context, dumping backtrace:%{public}s";
        goto LABEL_432;
      }
      uint64_t v175 = *(void *)(v12 + 480);
      if (v175)
      {
        uint64_t v176 = *(void *)(v175 + 200);
        *(void *)buf = MEMORY[0x1E4F143A8];
        *(void *)&buf[8] = 0x40000000;
        *(void *)&buf[16] = ___ZL56nw_http1_match_idle_connection_with_pending_stream_asyncP19nw_http1_connection_block_invoke;
        *(void *)&unsigned char buf[24] = &unk_1E52411C8;
        *(void *)&buf[32] = v176;
        nw_queue_context_async(v174, buf);
        goto LABEL_314;
      }
      __nwlog_obj();
      *(_DWORD *)v235 = 136446210;
      *(void *)&v235[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
      v198 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v231 = 0;
      if (__nwlog_fault(v198, &type, &v231))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v199 = __nwlog_obj();
          os_log_type_t v200 = type;
          if (!os_log_type_enabled(v199, type)) {
            goto LABEL_458;
          }
          *(_DWORD *)v235 = 136446210;
          *(void *)&v235[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
          v201 = "%{public}s called with null http1";
          goto LABEL_456;
        }
        if (!v231)
        {
          v199 = __nwlog_obj();
          os_log_type_t v200 = type;
          if (!os_log_type_enabled(v199, type)) {
            goto LABEL_458;
          }
          *(_DWORD *)v235 = 136446210;
          *(void *)&v235[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
          v201 = "%{public}s called with null http1, backtrace limit exceeded";
          goto LABEL_456;
        }
        v219 = (char *)__nw_create_backtrace_string();
        v199 = __nwlog_obj();
        os_log_type_t v200 = type;
        BOOL v222 = os_log_type_enabled(v199, type);
        if (!v219)
        {
          if (!v222) {
            goto LABEL_458;
          }
          *(_DWORD *)v235 = 136446210;
          *(void *)&v235[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
          v201 = "%{public}s called with null http1, no backtrace";
          goto LABEL_456;
        }
        if (!v222) {
          goto LABEL_433;
        }
        *(_DWORD *)v235 = 136446466;
        *(void *)&v235[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
        *(_WORD *)&v235[12] = 2082;
        *(void *)&v235[14] = v219;
        v221 = "%{public}s called with null http1, dumping backtrace:%{public}s";
LABEL_432:
        _os_log_impl(&dword_1830D4000, v199, v200, v221, v235, 0x16u);
LABEL_433:
        free(v219);
        if (v198) {
LABEL_459:
        }
          free(v198);
LABEL_460:
        a3 = v228;
        int v26 = (unsigned __int16 *)(v12 + 872);
        if (*(void *)(v12 + 488)) {
          goto LABEL_131;
        }
        goto LABEL_315;
      }
LABEL_458:
      if (!v198) {
        goto LABEL_460;
      }
      goto LABEL_459;
    }
    __nwlog_obj();
    uint64_t v128 = *(unsigned int *)(v123 + 368);
    *(_DWORD *)buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = "http1->nonresuable_connections";
    *(_WORD *)&buf[22] = 2048;
    *(void *)&unsigned char buf[24] = 1;
    *(_WORD *)&buf[32] = 2048;
    *(void *)&buf[34] = v128;
    v129 = (char *)_os_log_send_and_compose_impl();
    v235[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v129, v235, &type))
    {
      if (v235[0] == 17)
      {
        v130 = __nwlog_obj();
        os_log_type_t v131 = v235[0];
        if (os_log_type_enabled(v130, (os_log_type_t)v235[0]))
        {
          uint64_t v132 = *(unsigned int *)(v123 + 368);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = "http1->nonresuable_connections";
          *(_WORD *)&buf[22] = 2048;
          *(void *)&unsigned char buf[24] = 1;
          *(_WORD *)&buf[32] = 2048;
          *(void *)&buf[34] = v132;
          v133 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_305:
          _os_log_impl(&dword_1830D4000, v130, v131, v133, buf, 0x2Au);
        }
      }
      else if (type)
      {
        v161 = (char *)__nw_create_backtrace_string();
        v130 = __nwlog_obj();
        os_log_type_t v131 = v235[0];
        BOOL v162 = os_log_type_enabled(v130, (os_log_type_t)v235[0]);
        if (v161)
        {
          if (v162)
          {
            uint64_t v163 = *(unsigned int *)(v123 + 368);
            *(_DWORD *)buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = "http1->nonresuable_connections";
            *(_WORD *)&buf[22] = 2048;
            *(void *)&unsigned char buf[24] = 1;
            *(_WORD *)&buf[32] = 2048;
            *(void *)&buf[34] = v163;
            *(_WORD *)&buf[42] = 2082;
            *(void *)v234 = v161;
            _os_log_impl(&dword_1830D4000, v130, v131, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v161);
          goto LABEL_306;
        }
        if (v162)
        {
          uint64_t v173 = *(unsigned int *)(v123 + 368);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = "http1->nonresuable_connections";
          *(_WORD *)&buf[22] = 2048;
          *(void *)&unsigned char buf[24] = 1;
          *(_WORD *)&buf[32] = 2048;
          *(void *)&buf[34] = v173;
          v133 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
          goto LABEL_305;
        }
      }
      else
      {
        v130 = __nwlog_obj();
        os_log_type_t v131 = v235[0];
        if (os_log_type_enabled(v130, (os_log_type_t)v235[0]))
        {
          uint64_t v172 = *(unsigned int *)(v123 + 368);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = "http1->nonresuable_connections";
          *(_WORD *)&buf[22] = 2048;
          *(void *)&unsigned char buf[24] = 1;
          *(_WORD *)&buf[32] = 2048;
          *(void *)&buf[34] = v172;
          v133 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
          goto LABEL_305;
        }
      }
    }
LABEL_306:
    if (v129) {
      free(v129);
    }
    *(_DWORD *)(v123 + 368) = -1;
    a3 = v228;
    int v26 = (unsigned __int16 *)(v12 + 872);
    goto LABEL_309;
  }
LABEL_131:
  uint64_t v86 = *(void *)(v12 + 616);
  uint64_t v87 = *(void *)(v12 + 632);
  int v88 = *v26 & 0x204;
  if ((*v26 & 0x2000) != 0)
  {
    uint64_t v99 = v86 | v87;
    BOOL v100 = (v86 | v87) == 0;
    unsigned int v101 = ((*v26 | (*((unsigned __int8 *)v26 + 2) << 16)) >> 9) & 1;
    if (v88 == 4) {
      unsigned int v101 = 1;
    }
    uint64_t v5 = v226;
    if (v99 || !v101)
    {
      if (v88 == 4) {
        goto LABEL_170;
      }
      if (!v100) {
        goto LABEL_170;
      }
      *(_DWORD *)(v12 + 864) = 5;
      if (*(unsigned char *)(v12 + 158)) {
        goto LABEL_170;
      }
      BOOL v89 = __nwlog_obj();
      if (!os_log_type_enabled(v89, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_170;
      }
      uint64_t v105 = *(void *)(v12 + 488);
      int v106 = *(_DWORD *)(*(void *)(v12 + 480) + 372);
      int v107 = *(_DWORD *)(v12 + 860);
      if (v105) {
        LODWORD(v105) = *(_DWORD *)(v105 + 424);
      }
      *(_DWORD *)buf = 136447490;
      *(void *)&uint8_t buf[4] = "nw_http1_update_connection_input_state";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v12 + 74;
      *(_WORD *)&buf[22] = 2080;
      *(void *)&unsigned char buf[24] = " ";
      *(_WORD *)&buf[32] = 1024;
      *(_DWORD *)&buf[34] = v106;
      *(_WORD *)&buf[38] = 1024;
      *(_DWORD *)&buf[40] = v107;
      *(_WORD *)v234 = 1024;
      *(_DWORD *)&v234[2] = v105;
      char v93 = "%{public}s %{public}s%s<i%u:c%u:s%u> connection input state: connection error";
    }
    else
    {
      *(_DWORD *)(v12 + 864) = 4;
      if (*(unsigned char *)(v12 + 158)) {
        goto LABEL_170;
      }
      BOOL v89 = __nwlog_obj();
      if (!os_log_type_enabled(v89, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_170;
      }
      uint64_t v102 = *(void *)(v12 + 488);
      int v103 = *(_DWORD *)(*(void *)(v12 + 480) + 372);
      int v104 = *(_DWORD *)(v12 + 860);
      if (v102) {
        LODWORD(v102) = *(_DWORD *)(v102 + 424);
      }
      *(_DWORD *)buf = 136447490;
      *(void *)&uint8_t buf[4] = "nw_http1_update_connection_input_state";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v12 + 74;
      *(_WORD *)&buf[22] = 2080;
      *(void *)&unsigned char buf[24] = " ";
      *(_WORD *)&buf[32] = 1024;
      *(_DWORD *)&buf[34] = v103;
      *(_WORD *)&buf[38] = 1024;
      *(_DWORD *)&buf[40] = v104;
      *(_WORD *)v234 = 1024;
      *(_DWORD *)&v234[2] = v102;
      char v93 = "%{public}s %{public}s%s<i%u:c%u:s%u> connection input state: connection complete";
    }
LABEL_169:
    _os_log_impl(&dword_1830D4000, v89, OS_LOG_TYPE_DEBUG, v93, buf, 0x32u);
    goto LABEL_170;
  }
  uint64_t v5 = v226;
  if (v88 != 4)
  {
    if (*(unsigned char *)(v12 + 158)) {
      goto LABEL_170;
    }
    BOOL v89 = __nwlog_obj();
    if (!os_log_type_enabled(v89, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_170;
    }
    uint64_t v108 = *(void *)(v12 + 488);
    int v109 = *(_DWORD *)(*(void *)(v12 + 480) + 372);
    int v110 = *(_DWORD *)(v12 + 860);
    if (v108) {
      LODWORD(v108) = *(_DWORD *)(v108 + 424);
    }
    *(_DWORD *)buf = 136447490;
    *(void *)&uint8_t buf[4] = "nw_http1_update_connection_input_state";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v12 + 74;
    *(_WORD *)&buf[22] = 2080;
    *(void *)&unsigned char buf[24] = " ";
    *(_WORD *)&buf[32] = 1024;
    *(_DWORD *)&buf[34] = v109;
    *(_WORD *)&buf[38] = 1024;
    *(_DWORD *)&buf[40] = v110;
    *(_WORD *)v234 = 1024;
    *(_DWORD *)&v234[2] = v108;
    char v93 = "%{public}s %{public}s%s<i%u:c%u:s%u> no change to http1 connection state";
    goto LABEL_169;
  }
  if (v86 | v87)
  {
    if (!v86) {
      goto LABEL_170;
    }
    if (v87) {
      goto LABEL_170;
    }
    *(_DWORD *)(v12 + 864) = 3;
    if (*(unsigned char *)(v12 + 158)) {
      goto LABEL_170;
    }
    BOOL v89 = __nwlog_obj();
    if (!os_log_type_enabled(v89, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_170;
    }
    uint64_t v113 = *(void *)(v12 + 488);
    int v114 = *(_DWORD *)(*(void *)(v12 + 480) + 372);
    int v115 = *(_DWORD *)(v12 + 860);
    if (v113) {
      LODWORD(v113) = *(_DWORD *)(v113 + 424);
    }
    *(_DWORD *)buf = 136447490;
    *(void *)&uint8_t buf[4] = "nw_http1_update_connection_input_state";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v12 + 74;
    *(_WORD *)&buf[22] = 2080;
    *(void *)&unsigned char buf[24] = " ";
    *(_WORD *)&buf[32] = 1024;
    *(_DWORD *)&buf[34] = v114;
    *(_WORD *)&buf[38] = 1024;
    *(_DWORD *)&buf[40] = v115;
    *(_WORD *)v234 = 1024;
    *(_DWORD *)&v234[2] = v113;
    char v93 = "%{public}s %{public}s%s<i%u:c%u:s%u> connection input state: stream pending";
    goto LABEL_169;
  }
  *(_DWORD *)(v12 + 864) = 2;
  if ((*(unsigned char *)(v12 + 158) & 1) == 0)
  {
    BOOL v89 = __nwlog_obj();
    if (os_log_type_enabled(v89, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v90 = *(void *)(v12 + 488);
      int v91 = *(_DWORD *)(*(void *)(v12 + 480) + 372);
      int v92 = *(_DWORD *)(v12 + 860);
      if (v90) {
        LODWORD(v90) = *(_DWORD *)(v90 + 424);
      }
      *(_DWORD *)buf = 136447490;
      *(void *)&uint8_t buf[4] = "nw_http1_update_connection_input_state";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v12 + 74;
      *(_WORD *)&buf[22] = 2080;
      *(void *)&unsigned char buf[24] = " ";
      *(_WORD *)&buf[32] = 1024;
      *(_DWORD *)&buf[34] = v91;
      *(_WORD *)&buf[38] = 1024;
      *(_DWORD *)&buf[40] = v92;
      *(_WORD *)v234 = 1024;
      *(_DWORD *)&v234[2] = v90;
      char v93 = "%{public}s %{public}s%s<i%u:c%u:s%u> connection input state: stream complete";
      goto LABEL_169;
    }
  }
LABEL_170:
  if (*(_DWORD *)(v12 + 864) == 1)
  {
    if (v29)
    {
      uint64_t v111 = *(void *)(v12 + 488);
      if (v111) {
        nw_protocol_input_available(*(void **)(v111 + 48), v111);
      }
    }
  }
LABEL_112:
  uint64_t v73 = *(void *)(v12 + 488);
  if (!v73)
  {
    if (*(unsigned char *)(v12 + 158)) {
      return;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v77 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG)) {
      return;
    }
    uint64_t v78 = *(void *)(v12 + 488);
    int v79 = *(_DWORD *)(*(void *)(v12 + 480) + 372);
    int v80 = *(_DWORD *)(v12 + 860);
    if (v78) {
      LODWORD(v78) = *(_DWORD *)(v78 + 424);
    }
    *(_DWORD *)buf = 136447746;
    *(void *)&uint8_t buf[4] = "nw_protocol_http1_error";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v12 + 74;
    *(_WORD *)&buf[22] = 2080;
    *(void *)&unsigned char buf[24] = " ";
    *(_WORD *)&buf[32] = 1024;
    *(_DWORD *)&buf[34] = v79;
    *(_WORD *)&buf[38] = 1024;
    *(_DWORD *)&buf[40] = v80;
    *(_WORD *)v234 = 1024;
    *(_DWORD *)&v234[2] = v78;
    *(_WORD *)&v234[6] = 1024;
    *(_DWORD *)&v234[8] = a3;
    BOOL v18 = "%{public}s %{public}s%s<i%u:c%u:s%u> not passing up error %d, no stream";
    os_log_type_t v19 = v77;
    os_log_type_t v20 = OS_LOG_TYPE_DEBUG;
    uint32_t v21 = 56;
    goto LABEL_27;
  }
  if (((*v26 | (*((unsigned __int8 *)v26 + 2) << 16)) & 0x10004) != 0)
  {
    if ((*(unsigned char *)(v12 + 158) & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v22 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v74 = *(void *)(v12 + 488);
        int v75 = *(_DWORD *)(*(void *)(v12 + 480) + 372);
        int v76 = *(_DWORD *)(v12 + 860);
        if (v74) {
          LODWORD(v74) = *(_DWORD *)(v74 + 424);
        }
        *(_DWORD *)buf = 136447490;
        *(void *)&uint8_t buf[4] = "nw_protocol_http1_error";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v12 + 74;
        *(_WORD *)&buf[22] = 2080;
        *(void *)&unsigned char buf[24] = " ";
        *(_WORD *)&buf[32] = 1024;
        *(_DWORD *)&buf[34] = v75;
        *(_WORD *)&buf[38] = 1024;
        *(_DWORD *)&buf[40] = v76;
        *(_WORD *)v234 = 1024;
        *(_DWORD *)&v234[2] = v74;
        BOOL v18 = "%{public}s %{public}s%s<i%u:c%u:s%u> not passing up error because stream finished";
        goto LABEL_119;
      }
    }
  }
  else
  {
    if (*(unsigned char *)(v12 + 158)) {
      goto LABEL_145;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v94 = gLogObj;
    BOOL v95 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG);
    uint64_t v73 = *(void *)(v12 + 488);
    if (v95)
    {
      int v96 = *(_DWORD *)(*(void *)(v12 + 480) + 372);
      int v97 = *(_DWORD *)(v12 + 860);
      if (v73) {
        LODWORD(v73) = *(_DWORD *)(v73 + 424);
      }
      *(_DWORD *)buf = 136447746;
      *(void *)&uint8_t buf[4] = "nw_protocol_http1_error";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v12 + 74;
      *(_WORD *)&buf[22] = 2080;
      *(void *)&unsigned char buf[24] = " ";
      *(_WORD *)&buf[32] = 1024;
      *(_DWORD *)&buf[34] = v96;
      *(_WORD *)&buf[38] = 1024;
      *(_DWORD *)&buf[40] = v97;
      *(_WORD *)v234 = 1024;
      *(_DWORD *)&v234[2] = v73;
      *(_WORD *)&v234[6] = 1024;
      *(_DWORD *)&v234[8] = a3;
      _os_log_impl(&dword_1830D4000, v94, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:c%u:s%u> passing up error: %d", buf, 0x38u);
      uint64_t v73 = *(void *)(v12 + 488);
    }
    if (v73) {
LABEL_145:
    }
      __int16 v98 = *(void **)(v73 + 48);
    else {
      __int16 v98 = 0;
    }
    nw_protocol_error(v98, (uint64_t)v5);
  }
}

uint64_t ___ZL38nw_webtransport_session_http_get_inputP23nw_webtransport_session_block_invoke(uint64_t a1, _DWORD *a2)
{
  uint64_t v552 = *MEMORY[0x1E4F143B8];
  if (nw_frame_unclaimed_length(a2))
  {
    uint64_t v4 = *(void *)(a1 + 40);
    if (!v4 || (*(unsigned char *)(v4 + 548) & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v5 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        uint64_t v6 = *(void *)(a1 + 40);
        BOOL v7 = (const char *)(v6 + 464);
        uint64_t v8 = "";
        int v9 = *(_DWORD *)(v6 + 460);
        BOOL v10 = v6 == 0;
        if (!v6) {
          BOOL v7 = "";
        }
        int v11 = *(_DWORD *)(v6 + 444);
        if (!v10) {
          uint64_t v8 = " ";
        }
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_http_get_input_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v7;
        *(_WORD *)&buf[22] = 2080;
        uint64_t v539 = (uint64_t)v8;
        *(_WORD *)v540 = 1024;
        *(_DWORD *)&v540[2] = v9;
        *(_WORD *)&v540[6] = 1024;
        *(_DWORD *)&v540[8] = v11;
        _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> Unexpected data received in state: %d", buf, 0x2Cu);
      }
    }
  }
  uint64_t v12 = nw_frame_copy_metadata_for_protocol((uint64_t)a2, *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40));
  uint64_t v13 = *(void *)(a1 + 40);
  v526 = v12;
  if (v12)
  {
    int v14 = *(_DWORD *)(v13 + 444);
    if (v14 != 3)
    {
      if (v14 != 1)
      {
LABEL_724:
        nw_frame_finalize((uint64_t)a2);
        os_release(v526);
        return 1;
      }
      if (nw_protocol_metadata_is_http(v12))
      {
        if ((*(unsigned char *)(v13 + 548) & 2) == 0)
        {
          if (gLogDatapath)
          {
            v492 = __nwlog_obj();
            if (os_log_type_enabled(v492, OS_LOG_TYPE_DEBUG))
            {
              int v493 = *(_DWORD *)(v13 + 460);
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_response";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v13 + 464;
              *(_WORD *)&buf[22] = 2080;
              uint64_t v539 = (uint64_t)" ";
              *(_WORD *)v540 = 1024;
              *(_DWORD *)&v540[2] = v493;
              _os_log_impl(&dword_1830D4000, v492, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
            }
          }
        }
        id v15 = nw_http_metadata_copy_response(v526);
        if (v15)
        {
          id v16 = v15;
          int status_code = _nw_http_response_get_status_code();
          id v525 = v16;

          if ((status_code - 200) > 0x63)
          {
            if (*(_DWORD *)(v13 + 444) != 5)
            {
              if ((*(unsigned char *)(v13 + 548) & 2) == 0)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v270 = gLogObj;
                if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
                {
                  int v271 = *(_DWORD *)(v13 + 460);
                  *(_DWORD *)buf = 136447234;
                  *(void *)&uint8_t buf[4] = "nw_webtransport_session_terminate";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v13 + 464;
                  *(_WORD *)&buf[22] = 2080;
                  uint64_t v539 = (uint64_t)" ";
                  *(_WORD *)v540 = 1024;
                  *(_DWORD *)&v540[2] = v271;
                  *(_WORD *)&v540[6] = 1024;
                  *(_DWORD *)&v540[8] = 57;
                  _os_log_impl(&dword_1830D4000, v270, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Closing webtransport session with error %{darwin.errno}d", buf, 0x2Cu);
                }
              }
              *(_DWORD *)(v13 + 444) = 5;
              v272 = *(char **)(v13 + 184);
              if (v272)
              {
                *(void *)buf = MEMORY[0x1E4F143A8];
                *(void *)&buf[8] = 0x40000000;
                *(void *)&buf[16] = ___ZL33nw_webtransport_session_terminateP23nw_webtransport_sessioni_block_invoke;
                uint64_t v539 = (uint64_t)&__block_descriptor_tmp_26_33833;
                *(_DWORD *)v540 = 57;
                nw_hash_table_apply(v272, (uint64_t)buf);
              }
              uint64_t v273 = *(void *)(v13 + 424);
              if (v273)
              {
                v274 = *(void **)(v273 + 48);
                nw_protocol_error(v274, *(void *)(v13 + 424));
                nw_protocol_disconnected(v274, v273);
              }
              uint64_t v275 = *(void *)(v13 + 328);
              if (v275)
              {
                do
                {
                  uint64_t v276 = *(void *)(v275 + 112);
                  v277 = *(void **)(v275 + 48);
                  nw_protocol_error(v277, v275);
                  nw_protocol_disconnected(v277, v275);
                  uint64_t v275 = v276;
                }
                while (v276);
              }
              uint64_t v278 = *(void *)(v13 + 416);
              if (v278)
              {
                v279 = *(void **)(v278 + 48);
                nw_protocol_error(v279, *(void *)(v13 + 416));
                nw_protocol_disconnected(v279, v278);
              }
              if (*(void *)(v13 + 32))
              {
                nw_protocol_remove_instance(v13);
                nw_protocol_disconnect(*(void **)(v13 + 32), v13);
              }
              goto LABEL_723;
            }
            if ((*(unsigned char *)(v13 + 548) & 2) != 0
              || (pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once),
                  networkd_settings_init(),
                  uint64_t v49 = gLogObj,
                  !os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)))
            {
LABEL_723:
              os_release(v525);
              goto LABEL_724;
            }
            int v50 = *(_DWORD *)(v13 + 460);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_webtransport_session_terminate";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v13 + 464;
            *(_WORD *)&buf[22] = 2080;
            uint64_t v539 = (uint64_t)" ";
            *(_WORD *)v540 = 1024;
            *(_DWORD *)&v540[2] = v50;
            uint32_t v21 = "%{public}s %{public}s%s<i%u> Session already terminated, ignoring";
            char v22 = v49;
            os_log_type_t v23 = OS_LOG_TYPE_INFO;
            uint32_t v24 = 38;
LABEL_57:
            _os_log_impl(&dword_1830D4000, v22, v23, v21, buf, v24);
            goto LABEL_723;
          }
          if (*(_DWORD *)(v13 + 444) == 4)
          {
            if ((*(unsigned char *)(v13 + 548) & 2) != 0) {
              goto LABEL_723;
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v18 = gLogObj;
            if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
              goto LABEL_723;
            }
            int v19 = *(_DWORD *)(v13 + 460);
            int v20 = *(_DWORD *)(v13 + 444);
            *(_DWORD *)buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_webtransport_session_streams_ready";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v13 + 464;
            *(_WORD *)&buf[22] = 2080;
            uint64_t v539 = (uint64_t)" ";
            *(_WORD *)v540 = 1024;
            *(_DWORD *)&v540[2] = v19;
            *(_WORD *)&v540[6] = 1024;
            *(_DWORD *)&v540[8] = v20;
            uint32_t v21 = "%{public}s %{public}s%s<i%u> Tried to ready streams with incorrect state: %d, ignoring";
            char v22 = v18;
            os_log_type_t v23 = OS_LOG_TYPE_ERROR;
            uint32_t v24 = 44;
            goto LABEL_57;
          }
          *(_DWORD *)(v13 + 444) = 4;
          if ((*(unsigned char *)(v13 + 548) & 2) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v61 = gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
            {
              int v62 = *(_DWORD *)(v13 + 460);
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_webtransport_session_streams_ready";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v13 + 464;
              *(_WORD *)&buf[22] = 2080;
              uint64_t v539 = (uint64_t)" ";
              *(_WORD *)v540 = 1024;
              *(_DWORD *)&v540[2] = v62;
              _os_log_impl(&dword_1830D4000, v61, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Webtransport session established, reconfiguring streams", buf, 0x26u);
            }
          }
          uint64_t v63 = *(void *)(v13 + 328);
          p_cache = NWConcrete_nw_resolution_report.cache;
          if (!v63) {
            goto LABEL_723;
          }
          if ((*(unsigned char *)(v63 + 276) & 0x10) == 0)
          {
            if (gLogDatapath)
            {
              v511 = __nwlog_obj();
              if (os_log_type_enabled(v511, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v512 = *(void *)(v63 + 88);
                if (v512) {
                  int v513 = *(_DWORD *)(v512 + 460);
                }
                else {
                  int v513 = -1;
                }
                uint64_t v517 = *(void *)(v63 + 64);
                *(_DWORD *)buf = 136447490;
                *(void *)&uint8_t buf[4] = "nw_webtransport_session_get_next_pending_stream";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v63 + 192;
                *(_WORD *)&buf[22] = 2080;
                uint64_t v539 = (uint64_t)" ";
                *(_WORD *)v540 = 1024;
                *(_DWORD *)&v540[2] = v513;
                *(_WORD *)&v540[6] = 2048;
                *(void *)&v540[8] = v517;
                *(_WORD *)&v540[16] = 2048;
                *(void *)&v540[18] = v63;
                _os_log_impl(&dword_1830D4000, v511, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> found stream (%p)", buf, 0x3Au);
              }
            }
          }
          int v65 = *(unsigned char *)(v13 + 548) & 1;
          int v521 = v65;
          while (1)
          {
            if ((*(unsigned char *)(v13 + 548) & 2) == 0)
            {
              if (*((unsigned char *)p_cache + 3665))
              {
                v210 = __nwlog_obj();
                if (os_log_type_enabled(v210, OS_LOG_TYPE_DEBUG))
                {
                  int v211 = *(_DWORD *)(v13 + 460);
                  *(_DWORD *)buf = 136447234;
                  *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v13 + 464;
                  *(_WORD *)&buf[22] = 2080;
                  uint64_t v539 = (uint64_t)" ";
                  *(_WORD *)v540 = 1024;
                  *(_DWORD *)&v540[2] = v211;
                  *(_WORD *)&v540[6] = 2048;
                  *(void *)&v540[8] = v63;
                  _os_log_impl(&dword_1830D4000, v210, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called for stream (%p)", buf, 0x30u);
                }
              }
            }
            if ((*(unsigned char *)(v63 + 276) & 0x20) == 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
              *(_WORD *)&buf[12] = 2048;
              *(void *)&buf[14] = v63;
              uint64_t v66 = (char *)_os_log_send_and_compose_impl();
              iterate_block[0] = 16;
              LOBYTE(v527) = 0;
              if (!__nwlog_fault(v66, iterate_block, &v527)) {
                goto LABEL_108;
              }
              if (iterate_block[0] == 17)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                uint64_t v67 = gLogObj;
                os_log_type_t v68 = iterate_block[0];
                if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0]))
                {
                  *(_DWORD *)buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
                  *(_WORD *)&buf[12] = 2048;
                  *(void *)&buf[14] = v63;
                  os_log_type_t v69 = v67;
                  os_log_type_t v70 = v68;
                  int v71 = "%{public}s stream %p not in pending list, cannot remove";
                  goto LABEL_107;
                }
                goto LABEL_108;
              }
              if ((_BYTE)v527)
              {
                backtrace_string = (char *)__nw_create_backtrace_string();
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                int v75 = gLogObj;
                os_log_type_t v76 = iterate_block[0];
                BOOL v77 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0]);
                if (backtrace_string)
                {
                  if (v77)
                  {
                    *(_DWORD *)buf = 136446722;
                    *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
                    *(_WORD *)&buf[12] = 2048;
                    *(void *)&buf[14] = v63;
                    *(_WORD *)&buf[22] = 2082;
                    uint64_t v539 = (uint64_t)backtrace_string;
                    _os_log_impl(&dword_1830D4000, v75, v76, "%{public}s stream %p not in pending list, cannot remove, dumping backtrace:%{public}s", buf, 0x20u);
                  }
                  free(backtrace_string);
                  goto LABEL_108;
                }
                if (!v77)
                {
LABEL_108:
                  if (v66) {
                    free(v66);
                  }
                  goto LABEL_120;
                }
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
                *(_WORD *)&buf[12] = 2048;
                *(void *)&buf[14] = v63;
                os_log_type_t v69 = v75;
                os_log_type_t v70 = v76;
                int v71 = "%{public}s stream %p not in pending list, cannot remove, no backtrace";
              }
              else
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                uint64_t v87 = gLogObj;
                os_log_type_t v88 = iterate_block[0];
                if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0])) {
                  goto LABEL_108;
                }
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
                *(_WORD *)&buf[12] = 2048;
                *(void *)&buf[14] = v63;
                os_log_type_t v69 = v87;
                os_log_type_t v70 = v88;
                int v71 = "%{public}s stream %p not in pending list, cannot remove, backtrace limit exceeded";
              }
LABEL_107:
              _os_log_impl(&dword_1830D4000, v69, v70, v71, buf, 0x16u);
              goto LABEL_108;
            }
            uint64_t v72 = *(void *)(v63 + 112);
            uint64_t v73 = *(void **)(v63 + 120);
            if (v72)
            {
              *(void *)(v72 + 120) = v73;
              uint64_t v73 = *(void **)(v63 + 120);
            }
            else
            {
              *(void *)(v13 + 336) = v73;
            }
            void *v73 = v72;
            *(void *)(v63 + 112) = 0;
            *(void *)(v63 + 120) = 0;
            int v78 = *(_DWORD *)(v13 + 456);
            *(_DWORD *)(v13 + 456) = v78 - 1;
            if (!v78) {
              break;
            }
LABEL_118:
            char v98 = *(unsigned char *)(v63 + 276);
            *(unsigned char *)(v63 + 276) = v98 & 0xDF;
            if ((v98 & 0x10) == 0)
            {
              if (*((unsigned char *)p_cache + 3665))
              {
                v212 = __nwlog_obj();
                if (os_log_type_enabled(v212, OS_LOG_TYPE_DEBUG))
                {
                  uint64_t v213 = *(void *)(v63 + 88);
                  if (v213) {
                    int v214 = *(_DWORD *)(v213 + 460);
                  }
                  else {
                    int v214 = -1;
                  }
                  uint64_t v229 = *(void *)(v63 + 64);
                  int v230 = *(_DWORD *)(v13 + 456);
                  *(_DWORD *)buf = 136447746;
                  *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v63 + 192;
                  *(_WORD *)&buf[22] = 2080;
                  uint64_t v539 = (uint64_t)" ";
                  *(_WORD *)v540 = 1024;
                  *(_DWORD *)&v540[2] = v214;
                  *(_WORD *)&v540[6] = 2048;
                  *(void *)&v540[8] = v229;
                  *(_WORD *)&v540[16] = 2048;
                  *(void *)&v540[18] = v63;
                  *(_WORD *)&v540[26] = 1024;
                  *(_DWORD *)&v540[28] = v230;
                  _os_log_impl(&dword_1830D4000, v212, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> removed pending stream (%p), now have %u pending streams", buf, 0x40u);
                }
              }
            }
LABEL_120:
            int v99 = *(_DWORD *)(v13 + 448);
            if (v99 != 1)
            {
              if (!v99)
              {
                if ((*(unsigned char *)(v63 + 276) & 0x10) == 0)
                {
                  if (*((unsigned char *)p_cache + 3665))
                  {
                    int v215 = __nwlog_obj();
                    if (os_log_type_enabled(v215, OS_LOG_TYPE_DEBUG))
                    {
                      uint64_t v216 = *(void *)(v63 + 88);
                      if (v216) {
                        int v217 = *(_DWORD *)(v216 + 460);
                      }
                      else {
                        int v217 = -1;
                      }
                      uint64_t v231 = *(void *)(v63 + 64);
                      *(_DWORD *)buf = 136447746;
                      *(void *)&uint8_t buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&buf[14] = v63 + 192;
                      *(_WORD *)&buf[22] = 2080;
                      uint64_t v539 = (uint64_t)" ";
                      *(_WORD *)v540 = 1024;
                      *(_DWORD *)&v540[2] = v217;
                      *(_WORD *)&v540[6] = 2048;
                      *(void *)&v540[8] = v231;
                      *(_WORD *)&v540[16] = 2048;
                      *(void *)&v540[18] = v63;
                      *(_WORD *)&v540[26] = 1024;
                      int v65 = v521;
                      *(_DWORD *)&v540[28] = v521;
                      _os_log_impl(&dword_1830D4000, v215, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Reconfiguring HTTP2 stream with protocol: %p, peer_initiated: %u", buf, 0x40u);
                      p_cache = (void **)(NWConcrete_nw_resolution_report + 16);
                    }
                  }
                }
                uint64_t v100 = *(void *)(v63 + 88);
                if (*(void *)(v100 + 416) == v63)
                {
                  if ((*(unsigned char *)(v63 + 276) & 0x10) == 0)
                  {
                    if (*((unsigned char *)p_cache + 3665))
                    {
                      v219 = __nwlog_obj();
                      if (os_log_type_enabled(v219, OS_LOG_TYPE_DEBUG))
                      {
                        uint64_t v220 = *(void *)(v63 + 88);
                        if (v220) {
                          int v221 = *(_DWORD *)(v220 + 460);
                        }
                        else {
                          int v221 = -1;
                        }
                        uint64_t v256 = *(void *)(v63 + 64);
                        *(_DWORD *)buf = 136447234;
                        *(void *)&uint8_t buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
                        *(_WORD *)&buf[12] = 2082;
                        *(void *)&buf[14] = v63 + 192;
                        *(_WORD *)&buf[22] = 2080;
                        uint64_t v539 = (uint64_t)" ";
                        *(_WORD *)v540 = 1024;
                        *(_DWORD *)&v540[2] = v221;
                        *(_WORD *)&v540[6] = 2048;
                        *(void *)&v540[8] = v256;
                        _os_log_impl(&dword_1830D4000, v219, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Returning without more reconfiguration for placeholder stream", buf, 0x30u);
                        p_cache = (void **)(NWConcrete_nw_resolution_report + 16);
                        int v65 = v521;
                      }
                    }
                  }
                  nw_protocol_connected(*(void **)(v63 + 48), v63);
                }
                else
                {
                  if (nw_protocol_webtransport_http2_stream_callbacks(void)::onceToken != -1) {
                    dispatch_once(&nw_protocol_webtransport_http2_stream_callbacks(void)::onceToken, &__block_literal_global_34);
                  }
                  *(void *)(v63 + 24) = &nw_protocol_webtransport_http2_stream_callbacks(void)::protocol_callbacks;
                  nw_protocol_set_output_handler(v63, v100);
                  unsigned int v101 = nw_parameters_copy_protocol_options_legacy(*(void **)(v63 + 144), (nw_protocol *)v63);
                  if (v101)
                  {
                    uint64_t v102 = v101;
                    if (v65)
                    {
                      if ((*(unsigned char *)(v63 + 276) & 0x10) == 0)
                      {
                        if (*((unsigned char *)p_cache + 3665))
                        {
                          uint64_t v117 = __nwlog_obj();
                          if (os_log_type_enabled(v117, OS_LOG_TYPE_DEBUG))
                          {
                            uint64_t v118 = *(void *)(v63 + 88);
                            if (v118) {
                              int v119 = *(_DWORD *)(v118 + 460);
                            }
                            else {
                              int v119 = -1;
                            }
                            uint64_t v259 = *(void *)(v63 + 64);
                            *(_DWORD *)buf = 136447234;
                            *(void *)&uint8_t buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
                            *(_WORD *)&buf[12] = 2082;
                            *(void *)&buf[14] = v63 + 192;
                            *(_WORD *)&buf[22] = 2080;
                            uint64_t v539 = (uint64_t)" ";
                            *(_WORD *)v540 = 1024;
                            *(_DWORD *)&v540[2] = v119;
                            *(_WORD *)&v540[6] = 2048;
                            *(void *)&v540[8] = v259;
                            _os_log_impl(&dword_1830D4000, v117, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Waiting for connected callback and stream ID assignment to setup metadata", buf, 0x30u);
                            p_cache = (void **)(NWConcrete_nw_resolution_report + 16);
                            int v65 = v521;
                          }
                        }
                      }
                    }
                    else if (nw_protocol_options_is_webtransport(v101))
                    {
                      *(unsigned char *)(v63 + 276) = *(unsigned char *)(v63 + 276) & 0xFC | 1;
                      if (nw_webtransport_options_get_is_datagram(v102)) {
                        char v103 = 8;
                      }
                      else {
                        char v103 = 0;
                      }
                      *(unsigned char *)(v63 + 276) = *(unsigned char *)(v63 + 276) & 0xF7 | v103;
                      BOOL is_unidirectional = nw_webtransport_options_get_is_unidirectional(v102);
                      char v105 = *(unsigned char *)(v63 + 276);
                      if (is_unidirectional) {
                        char v106 = 4;
                      }
                      else {
                        char v106 = 0;
                      }
                      *(unsigned char *)(v63 + 276) = v105 & 0xFB | v106;
                      if ((v105 & 0x10) == 0)
                      {
                        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                        networkd_settings_init();
                        int v107 = gLogObj;
                        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
                        {
                          uint64_t v108 = *(void *)(v63 + 88);
                          if (v108) {
                            int v109 = *(_DWORD *)(v108 + 460);
                          }
                          else {
                            int v109 = -1;
                          }
                          uint64_t v156 = *(void *)(v63 + 64);
                          unsigned int v157 = *(unsigned __int8 *)(v63 + 276);
                          *(_DWORD *)buf = 136448002;
                          *(void *)&uint8_t buf[4] = "nw_webtransport_stream_configure_metadata_with_options";
                          *(_WORD *)&buf[12] = 2082;
                          *(void *)&buf[14] = v63 + 192;
                          *(_WORD *)&buf[22] = 2080;
                          uint64_t v539 = (uint64_t)" ";
                          *(_WORD *)v540 = 1024;
                          *(_DWORD *)&v540[2] = v109;
                          *(_WORD *)&v540[6] = 2048;
                          *(void *)&v540[8] = v156;
                          *(_WORD *)&v540[16] = 1024;
                          *(_DWORD *)&v540[18] = (v157 >> 1) & 1;
                          *(_WORD *)&v540[22] = 1024;
                          *(_DWORD *)&v540[24] = (v157 >> 3) & 1;
                          *(_WORD *)&v540[28] = 1024;
                          *(_DWORD *)&v540[30] = (v157 >> 2) & 1;
                          _os_log_impl(&dword_1830D4000, v107, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> Configuring metadata with flags: peer_initiated: %u, datagram: %u, unidirectional: %u", buf, 0x42u);
                        }
                      }
                      nw_webtransport_metadata_set_is_peer_initiated(*(void **)(v63 + 160), (*(unsigned char *)(v63 + 276) & 2) != 0);
                      nw_webtransport_metadata_set_is_datagram(*(void **)(v63 + 160), (*(unsigned char *)(v63 + 276) & 8) != 0);
                      nw_webtransport_metadata_set_is_unidirectional(*(void **)(v63 + 160), (*(unsigned char *)(v63 + 276) & 4) != 0);
                    }
                    else if ((*(unsigned char *)(v63 + 276) & 0x10) == 0)
                    {
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      uint64_t v139 = gLogObj;
                      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                      {
                        uint64_t v140 = *(void *)(v63 + 88);
                        if (v140) {
                          int v141 = *(_DWORD *)(v140 + 460);
                        }
                        else {
                          int v141 = -1;
                        }
                        uint64_t v163 = *(void *)(v63 + 64);
                        *(_DWORD *)buf = 136447234;
                        *(void *)&uint8_t buf[4] = "nw_webtransport_stream_configure_metadata_with_options";
                        *(_WORD *)&buf[12] = 2082;
                        *(void *)&buf[14] = v63 + 192;
                        *(_WORD *)&buf[22] = 2080;
                        uint64_t v539 = (uint64_t)" ";
                        *(_WORD *)v540 = 1024;
                        *(_DWORD *)&v540[2] = v141;
                        *(_WORD *)&v540[6] = 2048;
                        *(void *)&v540[8] = v163;
                        _os_log_impl(&dword_1830D4000, v139, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> Invalid protocol options for webtransport stream", buf, 0x30u);
                      }
                    }
                    os_release(v102);
                  }
                  else if ((*(unsigned char *)(v63 + 276) & 0x10) == 0)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    int v114 = gLogObj;
                    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                    {
                      uint64_t v115 = *(void *)(v63 + 88);
                      if (v115) {
                        int v116 = *(_DWORD *)(v115 + 460);
                      }
                      else {
                        int v116 = -1;
                      }
                      uint64_t v146 = *(void *)(v63 + 64);
                      *(_DWORD *)buf = 136447234;
                      *(void *)&uint8_t buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&buf[14] = v63 + 192;
                      *(_WORD *)&buf[22] = 2080;
                      uint64_t v539 = (uint64_t)" ";
                      *(_WORD *)v540 = 1024;
                      *(_DWORD *)&v540[2] = v116;
                      *(_WORD *)&v540[6] = 2048;
                      *(void *)&v540[8] = v146;
                      _os_log_impl(&dword_1830D4000, v114, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> Could not find options for stream when reconfiguring", buf, 0x30u);
                    }
                  }
                }
                if (v63 != *(void *)(v13 + 416)) {
                  nw_protocol_connected((void *)v63, v13);
                }
              }
LABEL_236:
              uint64_t v63 = *(void *)(v13 + 328);
              if (!v63) {
                goto LABEL_723;
              }
              goto LABEL_237;
            }
            uint64_t v110 = *(void *)(v63 + 88);
            if ((*(unsigned char *)(v63 + 276) & 0x10) == 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v111 = gLogObj;
              if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
              {
                uint64_t v112 = *(void *)(v63 + 88);
                if (v112) {
                  int v113 = *(_DWORD *)(v112 + 460);
                }
                else {
                  int v113 = -1;
                }
                uint64_t v120 = *(void *)(v63 + 64);
                *(_DWORD *)buf = 136447746;
                *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v63 + 192;
                *(_WORD *)&buf[22] = 2080;
                uint64_t v539 = (uint64_t)" ";
                *(_WORD *)v540 = 1024;
                *(_DWORD *)&v540[2] = v113;
                *(_WORD *)&v540[6] = 2048;
                *(void *)&v540[8] = v120;
                *(_WORD *)&v540[16] = 2048;
                *(void *)&v540[18] = v63;
                *(_WORD *)&v540[26] = 1024;
                *(_DWORD *)&v540[28] = v65;
                _os_log_impl(&dword_1830D4000, v111, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> Reconfiguring HTTP3 stream with protocol: %p, peer_initiated: %u", buf, 0x40u);
              }
            }
            if (*(void *)(v110 + 416) == v63)
            {
              if ((*(unsigned char *)(v63 + 276) & 0x10) == 0)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v130 = gLogObj;
                if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
                {
                  uint64_t v131 = *(void *)(v63 + 88);
                  if (v131) {
                    int v132 = *(_DWORD *)(v131 + 460);
                  }
                  else {
                    int v132 = -1;
                  }
                  uint64_t v145 = *(void *)(v63 + 64);
                  *(_DWORD *)buf = 136447234;
                  *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v63 + 192;
                  *(_WORD *)&buf[22] = 2080;
                  uint64_t v539 = (uint64_t)" ";
                  *(_WORD *)v540 = 1024;
                  *(_DWORD *)&v540[2] = v132;
                  *(_WORD *)&v540[6] = 2048;
                  *(void *)&v540[8] = v145;
                  _os_log_impl(&dword_1830D4000, v130, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Returning connected without more reconfiguration for placeholder stream", buf, 0x30u);
                }
              }
              nw_protocol_connected(*(void **)(v63 + 48), v63);
              uint64_t v63 = *(void *)(v13 + 328);
              if (!v63) {
                goto LABEL_723;
              }
            }
            else
            {
              int v121 = nw_parameters_copy_protocol_options_legacy(*(void **)(v63 + 144), (nw_protocol *)v63);
              if (v121)
              {
                v122 = v121;
                if (nw_protocol_webtransport_http3_stream_callbacks(void)::onceToken != -1) {
                  dispatch_once(&nw_protocol_webtransport_http3_stream_callbacks(void)::onceToken, &__block_literal_global_49);
                }
                *(void *)(v63 + 24) = &nw_protocol_webtransport_http3_stream_callbacks(void)::protocol_callbacks;
                if (!v65)
                {
                  if (nw_protocol_options_is_webtransport(v122))
                  {
                    *(unsigned char *)(v63 + 276) = *(unsigned char *)(v63 + 276) & 0xFC | 1;
                    if (nw_webtransport_options_get_is_datagram(v122)) {
                      char v123 = 8;
                    }
                    else {
                      char v123 = 0;
                    }
                    *(unsigned char *)(v63 + 276) = *(unsigned char *)(v63 + 276) & 0xF7 | v123;
                    BOOL v124 = nw_webtransport_options_get_is_unidirectional(v122);
                    char v125 = *(unsigned char *)(v63 + 276);
                    if (v124) {
                      char v126 = 4;
                    }
                    else {
                      char v126 = 0;
                    }
                    *(unsigned char *)(v63 + 276) = v125 & 0xFB | v126;
                    if ((v125 & 0x10) == 0)
                    {
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      uint64_t v127 = gLogObj;
                      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
                      {
                        uint64_t v128 = *(void *)(v63 + 88);
                        if (v128) {
                          int v129 = *(_DWORD *)(v128 + 460);
                        }
                        else {
                          int v129 = -1;
                        }
                        uint64_t v158 = *(void *)(v63 + 64);
                        unsigned int v159 = *(unsigned __int8 *)(v63 + 276);
                        *(_DWORD *)buf = 136448002;
                        *(void *)&uint8_t buf[4] = "nw_webtransport_stream_configure_metadata_with_options";
                        *(_WORD *)&buf[12] = 2082;
                        *(void *)&buf[14] = v63 + 192;
                        *(_WORD *)&buf[22] = 2080;
                        uint64_t v539 = (uint64_t)" ";
                        *(_WORD *)v540 = 1024;
                        *(_DWORD *)&v540[2] = v129;
                        *(_WORD *)&v540[6] = 2048;
                        *(void *)&v540[8] = v158;
                        *(_WORD *)&v540[16] = 1024;
                        *(_DWORD *)&v540[18] = (v159 >> 1) & 1;
                        *(_WORD *)&v540[22] = 1024;
                        *(_DWORD *)&v540[24] = (v159 >> 3) & 1;
                        *(_WORD *)&v540[28] = 1024;
                        *(_DWORD *)&v540[30] = (v159 >> 2) & 1;
                        _os_log_impl(&dword_1830D4000, v127, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> Configuring metadata with flags: peer_initiated: %u, datagram: %u, unidirectional: %u", buf, 0x42u);
                      }
                    }
                    nw_webtransport_metadata_set_is_peer_initiated(*(void **)(v63 + 160), (*(unsigned char *)(v63 + 276) & 2) != 0);
                    nw_webtransport_metadata_set_is_datagram(*(void **)(v63 + 160), (*(unsigned char *)(v63 + 276) & 8) != 0);
                    nw_webtransport_metadata_set_is_unidirectional(*(void **)(v63 + 160), (*(unsigned char *)(v63 + 276) & 4) != 0);
LABEL_223:
                    if ((*(unsigned char *)(v63 + 276) & 8) == 0) {
                      goto LABEL_224;
                    }
LABEL_244:
                    nw_protocol_connected((void *)v63, v110);
LABEL_270:
                    uint64_t v187 = *(void *)(v110 + 32);
                    if (v187)
                    {
                      if ((*(unsigned char *)(v110 + 548) & 0x40) == 0)
                      {
                        p_cache = (void **)(NWConcrete_nw_resolution_report + 16);
                        if (!nw_protocol_add_input_handler(*(void *)(v110 + 32), v63)) {
                          goto LABEL_371;
                        }
LABEL_300:
                        if (*(void *)(v63 + 32))
                        {
                          uint64_t v207 = *(void *)(v63 + 176);
                          os_log_type_t v208 = *(void **)(v110 + 392);
                          uint64_t v527 = MEMORY[0x1E4F143A8];
                          uint64_t v528 = 0x40000000;
                          v529 = ___ZL50nw_webtransport_http3_stream_reconfigure_and_startP22nw_webtransport_streamb_block_invoke;
                          v530 = &unk_1E52403E8;
                          uint64_t v531 = v207;
                          nw_queue_context_async(v208, &v527);
                          goto LABEL_379;
                        }
LABEL_371:
                        if ((*(unsigned char *)(v63 + 276) & 0x10) == 0)
                        {
                          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                          networkd_settings_init();
                          uint64_t v264 = gLogObj;
                          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                          {
                            uint64_t v265 = *(void *)(v63 + 88);
                            if (v265) {
                              int v266 = *(_DWORD *)(v265 + 460);
                            }
                            else {
                              int v266 = -1;
                            }
                            uint64_t v267 = *(void *)(v63 + 64);
                            *(_DWORD *)buf = 136447234;
                            *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
                            *(_WORD *)&buf[12] = 2082;
                            *(void *)&buf[14] = v63 + 192;
                            *(_WORD *)&buf[22] = 2080;
                            uint64_t v539 = (uint64_t)" ";
                            *(_WORD *)v540 = 1024;
                            *(_DWORD *)&v540[2] = v266;
                            *(_WORD *)&v540[6] = 2048;
                            *(void *)&v540[8] = v267;
                            uint64_t v172 = v264;
                            uint64_t v173 = "%{public}s %{public}s%s<i%u:s%lld> no http3 output handler for webtransport http3 stream";
                            goto LABEL_377;
                          }
                        }
                        goto LABEL_378;
                      }
                      v522 = v122;
                      parameters = (void *)nw_protocol_get_parameters(v63);
                      if (parameters)
                      {
                        v189 = parameters;
                        nw_parameters_log_protocol_instances(parameters);
                        BOOL v190 = v189;
                        v191 = v190[19];

                        *(void *)os_log_type_t type = 0;
                        v535 = type;
                        uint64_t v536 = 0x2000000000;
                        char v537 = 0;
                        *(void *)buf = 0;
                        *(void *)&buf[8] = buf;
                        *(void *)&buf[16] = 0x3802000000;
                        uint64_t v539 = (uint64_t)__Block_byref_object_copy__33867;
                        *(void *)v540 = __Block_byref_object_dispose__33868;
                        *(void *)&v540[8] = 0;
                        v540[16] |= 1u;
                        *(void *)iterate_block = MEMORY[0x1E4F143A8];
                        *(void *)&iterate_block[8] = 0x40000000;
                        *(void *)&iterate_block[16] = ___ZL45nw_webtransport_session_add_to_http_messagingP23nw_webtransport_sessionP11nw_protocolS2__block_invoke;
                        v548 = (const char *)&unk_1E5240430;
                        v549 = type;
                        v550 = buf;
                        uint64_t v551 = v63;
                        nw_protocol_stack_iterate_application_protocols(v191, iterate_block);
                        os_log_type_t v192 = *(void **)(*(void *)&buf[8] + 40);
                        if (v192)
                        {
                          if (nw_protocol_copy_http_messaging_definition_onceToken != -1) {
                            dispatch_once(&nw_protocol_copy_http_messaging_definition_onceToken, &__block_literal_global_81);
                          }
                          id v193 = (id)nw_protocol_copy_http_messaging_definition_definition;
                          v194 = v192;
                          v194[2] = v187;

                          if (v193) {
                            os_release(v193);
                          }
                          uint64_t v195 = (void *)nw_protocol_get_parameters(v187);
                          if (v195)
                          {
                            int v196 = v195;
                            int v197 = v196[19];

                            v198 = v190;
                            v199 = v190[19];

                            os_log_type_t v200 = nw_protocol_stack_copy_transport_protocol(v197);
                            nw_protocol_options_t v201 = nw_protocol_stack_copy_transport_protocol(v199);
                            nw_protocol_options_t v202 = v201;
                            if (v200)
                            {
                              if (v201)
                              {
                                nw_protocol_definition_t v203 = nw_protocol_options_copy_definition(v200);
                                if (nw_protocol_options_matches_definition(v202, v203))
                                {
                                  uint64_t protocol_handle = nw_protocol_options_get_protocol_handle(v200);
                                  nw_parameters_set_protocol_instance(v202, v205, protocol_handle);
                                }
                                os_release(v202);
                              }
                              nw_protocol_options_t v202 = v200;
LABEL_288:
                              os_release(v202);
                            }
                            else if (v201)
                            {
                              goto LABEL_288;
                            }
                            if (v199) {
                              os_release(v199);
                            }
                            if (v197) {
                              os_release(v197);
                            }
                          }
                          nw_protocol_set_output_handler(v63, 0);
                          char v206 = nw_protocol_add_input_handler(v187, v63);
LABEL_294:
                          _Block_object_dispose(buf, 8);
                          p_cache = (void **)(NWConcrete_nw_resolution_report + 16);
                          int v65 = v521;
                          if ((v540[16] & 1) != 0 && *(void *)&v540[8]) {
                            os_release(*(void **)&v540[8]);
                          }
                          _Block_object_dispose(type, 8);
                          if (v191) {
                            os_release(v191);
                          }
                          v122 = v522;
                          if (v206) {
                            goto LABEL_300;
                          }
                          goto LABEL_371;
                        }
                        __nwlog_obj();
                        *(_DWORD *)v543 = 136446210;
                        v544 = "nw_webtransport_session_add_to_http_messaging";
                        v238 = (char *)_os_log_send_and_compose_impl();
                        os_log_type_t v533 = OS_LOG_TYPE_ERROR;
                        char v532 = 0;
                        if (!__nwlog_fault(v238, &v533, &v532)) {
                          goto LABEL_384;
                        }
                        if (v533 == OS_LOG_TYPE_FAULT)
                        {
                          v239 = __nwlog_obj();
                          os_log_type_t v240 = v533;
                          if (os_log_type_enabled(v239, v533))
                          {
                            *(_DWORD *)v543 = 136446210;
                            v544 = "nw_webtransport_session_add_to_http_messaging";
                            v241 = v239;
                            os_log_type_t v242 = v240;
                            v243 = "%{public}s called with null options";
                            goto LABEL_383;
                          }
                          goto LABEL_384;
                        }
                        if (v532)
                        {
                          v252 = (char *)__nw_create_backtrace_string();
                          v253 = __nwlog_obj();
                          os_log_type_t v254 = v533;
                          BOOL v255 = os_log_type_enabled(v253, v533);
                          if (v252)
                          {
                            if (v255)
                            {
                              *(_DWORD *)v543 = 136446466;
                              v544 = "nw_webtransport_session_add_to_http_messaging";
                              __int16 v545 = 2082;
                              v546 = v252;
                              _os_log_impl(&dword_1830D4000, v253, v254, "%{public}s called with null options, dumping backtrace:%{public}s", v543, 0x16u);
                            }
                            free(v252);
                            goto LABEL_384;
                          }
                          if (!v255)
                          {
LABEL_384:
                            if (v238) {
                              free(v238);
                            }
                            char v206 = 0;
                            goto LABEL_294;
                          }
                          *(_DWORD *)v543 = 136446210;
                          v544 = "nw_webtransport_session_add_to_http_messaging";
                          v241 = v253;
                          os_log_type_t v242 = v254;
                          v243 = "%{public}s called with null options, no backtrace";
                        }
                        else
                        {
                          v262 = __nwlog_obj();
                          os_log_type_t v263 = v533;
                          if (!os_log_type_enabled(v262, v533)) {
                            goto LABEL_384;
                          }
                          *(_DWORD *)v543 = 136446210;
                          v544 = "nw_webtransport_session_add_to_http_messaging";
                          v241 = v262;
                          os_log_type_t v242 = v263;
                          v243 = "%{public}s called with null options, backtrace limit exceeded";
                        }
LABEL_383:
                        _os_log_impl(&dword_1830D4000, v241, v242, v243, v543, 0xCu);
                        goto LABEL_384;
                      }
                      __nwlog_obj();
                      *(_DWORD *)buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_http_messaging";
                      v232 = (char *)_os_log_send_and_compose_impl();
                      type[0] = OS_LOG_TYPE_ERROR;
                      v543[0] = 0;
                      if (!__nwlog_fault(v232, type, v543)) {
                        goto LABEL_368;
                      }
                      if (type[0] == OS_LOG_TYPE_FAULT)
                      {
                        v233 = __nwlog_obj();
                        os_log_type_t v234 = type[0];
                        if (os_log_type_enabled(v233, type[0]))
                        {
                          *(_DWORD *)buf = 136446210;
                          *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_http_messaging";
                          v235 = v233;
                          os_log_type_t v236 = v234;
                          v237 = "%{public}s called with null parameters";
                          goto LABEL_367;
                        }
                        goto LABEL_368;
                      }
                      if (v543[0])
                      {
                        v248 = (char *)__nw_create_backtrace_string();
                        v249 = __nwlog_obj();
                        os_log_type_t v250 = type[0];
                        BOOL v251 = os_log_type_enabled(v249, type[0]);
                        if (v248)
                        {
                          if (v251)
                          {
                            *(_DWORD *)buf = 136446466;
                            *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_http_messaging";
                            *(_WORD *)&buf[12] = 2082;
                            *(void *)&buf[14] = v248;
                            _os_log_impl(&dword_1830D4000, v249, v250, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
                          }
                          free(v248);
                          goto LABEL_368;
                        }
                        if (!v251)
                        {
LABEL_368:
                          if (v232) {
                            free(v232);
                          }
                          p_cache = (void **)(NWConcrete_nw_resolution_report + 16);
                          int v65 = v521;
                          v122 = v522;
                          goto LABEL_371;
                        }
                        *(_DWORD *)buf = 136446210;
                        *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_http_messaging";
                        v235 = v249;
                        os_log_type_t v236 = v250;
                        v237 = "%{public}s called with null parameters, no backtrace";
                      }
                      else
                      {
                        v260 = __nwlog_obj();
                        os_log_type_t v261 = type[0];
                        if (!os_log_type_enabled(v260, type[0])) {
                          goto LABEL_368;
                        }
                        *(_DWORD *)buf = 136446210;
                        *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_http_messaging";
                        v235 = v260;
                        os_log_type_t v236 = v261;
                        v237 = "%{public}s called with null parameters, backtrace limit exceeded";
                      }
LABEL_367:
                      _os_log_impl(&dword_1830D4000, v235, v236, v237, buf, 0xCu);
                      goto LABEL_368;
                    }
                    BOOL v222 = v122;
                    __nwlog_obj();
                    *(_DWORD *)buf = 136446210;
                    *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_transport";
                    v223 = (char *)_os_log_send_and_compose_impl();
                    iterate_block[0] = 16;
                    type[0] = OS_LOG_TYPE_DEFAULT;
                    if (!__nwlog_fault(v223, iterate_block, type)) {
                      goto LABEL_356;
                    }
                    if (iterate_block[0] == 17)
                    {
                      v224 = __nwlog_obj();
                      os_log_type_t v225 = iterate_block[0];
                      if (os_log_type_enabled(v224, (os_log_type_t)iterate_block[0]))
                      {
                        *(_DWORD *)buf = 136446210;
                        *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_transport";
                        v226 = v224;
                        os_log_type_t v227 = v225;
                        int v228 = "%{public}s called with null transport_protocol";
                        goto LABEL_355;
                      }
                      goto LABEL_356;
                    }
                    if (type[0])
                    {
                      v244 = (char *)__nw_create_backtrace_string();
                      v245 = __nwlog_obj();
                      os_log_type_t v246 = iterate_block[0];
                      BOOL v247 = os_log_type_enabled(v245, (os_log_type_t)iterate_block[0]);
                      if (v244)
                      {
                        if (v247)
                        {
                          *(_DWORD *)buf = 136446466;
                          *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_transport";
                          *(_WORD *)&buf[12] = 2082;
                          *(void *)&buf[14] = v244;
                          _os_log_impl(&dword_1830D4000, v245, v246, "%{public}s called with null transport_protocol, dumping backtrace:%{public}s", buf, 0x16u);
                        }
                        free(v244);
                        goto LABEL_356;
                      }
                      if (!v247)
                      {
LABEL_356:
                        if (v223) {
                          free(v223);
                        }
                        p_cache = (void **)(NWConcrete_nw_resolution_report + 16);
                        int v65 = v521;
                        v122 = v222;
                        goto LABEL_371;
                      }
                      *(_DWORD *)buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_transport";
                      v226 = v245;
                      os_log_type_t v227 = v246;
                      int v228 = "%{public}s called with null transport_protocol, no backtrace";
                    }
                    else
                    {
                      v257 = __nwlog_obj();
                      os_log_type_t v258 = iterate_block[0];
                      if (!os_log_type_enabled(v257, (os_log_type_t)iterate_block[0])) {
                        goto LABEL_356;
                      }
                      *(_DWORD *)buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_transport";
                      v226 = v257;
                      os_log_type_t v227 = v258;
                      int v228 = "%{public}s called with null transport_protocol, backtrace limit exceeded";
                    }
LABEL_355:
                    _os_log_impl(&dword_1830D4000, v226, v227, v228, buf, 0xCu);
                    goto LABEL_356;
                  }
                  if ((*(unsigned char *)(v63 + 276) & 0x10) != 0) {
                    goto LABEL_223;
                  }
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v142 = gLogObj;
                  if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_223;
                  }
                  uint64_t v143 = *(void *)(v63 + 88);
                  if (v143) {
                    int v144 = *(_DWORD *)(v143 + 460);
                  }
                  else {
                    int v144 = -1;
                  }
                  uint64_t v167 = *(void *)(v63 + 64);
                  *(_DWORD *)buf = 136447234;
                  *(void *)&uint8_t buf[4] = "nw_webtransport_stream_configure_metadata_with_options";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v63 + 192;
                  *(_WORD *)&buf[22] = 2080;
                  uint64_t v539 = (uint64_t)" ";
                  *(_WORD *)v540 = 1024;
                  *(_DWORD *)&v540[2] = v144;
                  *(_WORD *)&v540[6] = 2048;
                  *(void *)&v540[8] = v167;
                  _os_log_impl(&dword_1830D4000, v142, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> Invalid protocol options for webtransport stream", buf, 0x30u);
                  if ((*(unsigned char *)(v63 + 276) & 8) != 0) {
                    goto LABEL_244;
                  }
LABEL_224:
                  nw_protocol_set_output_handler(v63, 0);
                  *(void *)(v63 + 56) = 0;
                  if (!*(void *)(v110 + 376))
                  {
                    if ((*(unsigned char *)(v63 + 276) & 0x10) == 0)
                    {
                      BOOL v160 = __nwlog_obj();
                      if (os_log_type_enabled(v160, OS_LOG_TYPE_ERROR))
                      {
                        uint64_t v161 = *(void *)(v63 + 88);
                        if (v161) {
                          int v162 = *(_DWORD *)(v161 + 460);
                        }
                        else {
                          int v162 = -1;
                        }
                        uint64_t v171 = *(void *)(v63 + 64);
                        *(_DWORD *)buf = 136447234;
                        *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
                        *(_WORD *)&buf[12] = 2082;
                        *(void *)&buf[14] = v63 + 192;
                        *(_WORD *)&buf[22] = 2080;
                        uint64_t v539 = (uint64_t)" ";
                        *(_WORD *)v540 = 1024;
                        *(_DWORD *)&v540[2] = v162;
                        *(_WORD *)&v540[6] = 2048;
                        *(void *)&v540[8] = v171;
                        uint64_t v172 = v160;
                        uint64_t v173 = "%{public}s %{public}s%s<i%u:s%lld> no http connection metadata when attempting to start w"
                               "ebtransport http3 stream";
LABEL_377:
                        _os_log_impl(&dword_1830D4000, v172, OS_LOG_TYPE_ERROR, v173, buf, 0x30u);
                      }
                    }
LABEL_378:
                    v268 = *(void **)(v63 + 48);
                    nw_protocol_error(v268, v63);
                    nw_protocol_disconnected(v268, v63);
LABEL_379:
                    os_release(v122);
                    uint64_t v63 = *(void *)(v13 + 328);
                    if (!v63) {
                      goto LABEL_723;
                    }
                    goto LABEL_237;
                  }
                  if ((*(unsigned char *)(v63 + 276) & 0x40) != 0) {
                    goto LABEL_270;
                  }
LABEL_269:
                  nw_webtransport_http3_stream_fix_http_parameters(v110, v63);
                  goto LABEL_270;
                }
                if ((*(unsigned char *)(v63 + 276) & 0x10) == 0)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  int v136 = gLogObj;
                  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
                  {
                    uint64_t v137 = *(void *)(v63 + 88);
                    if (v137) {
                      int v138 = *(_DWORD *)(v137 + 460);
                    }
                    else {
                      int v138 = -1;
                    }
                    uint64_t v148 = *(void *)(v63 + 64);
                    *(_DWORD *)buf = 136447234;
                    *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = v63 + 192;
                    *(_WORD *)&buf[22] = 2080;
                    uint64_t v539 = (uint64_t)" ";
                    *(_WORD *)v540 = 1024;
                    *(_DWORD *)&v540[2] = v138;
                    *(_WORD *)&v540[6] = 2048;
                    *(void *)&v540[8] = v148;
                    _os_log_impl(&dword_1830D4000, v136, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Preemptively configuring metadata with incoming stream ID", buf, 0x30u);
                  }
                }
                if (*(void *)(v110 + 176) != -1)
                {
                  if (*(void *)(v63 + 64) == -1)
                  {
                    uint64_t v152 = *(void *)(*(void *)(v63 + 88) + 176);
                    if (v152 == -1)
                    {
                      if ((*(unsigned char *)(v63 + 276) & 0x10) == 0)
                      {
                        BOOL v168 = __nwlog_obj();
                        if (os_log_type_enabled(v168, OS_LOG_TYPE_ERROR))
                        {
                          uint64_t v169 = *(void *)(v63 + 88);
                          if (v169) {
                            int v170 = *(_DWORD *)(v169 + 460);
                          }
                          else {
                            int v170 = -1;
                          }
                          uint64_t v175 = *(void *)(v63 + 64);
                          *(_DWORD *)buf = 136447234;
                          *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_assign_stream_id";
                          *(_WORD *)&buf[12] = 2082;
                          *(void *)&buf[14] = v63 + 192;
                          *(_WORD *)&buf[22] = 2080;
                          uint64_t v539 = (uint64_t)" ";
                          *(_WORD *)v540 = 1024;
                          *(_DWORD *)&v540[2] = v170;
                          *(_WORD *)&v540[6] = 2048;
                          *(void *)&v540[8] = v175;
                          _os_log_impl(&dword_1830D4000, v168, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> Failed to get stream ID for HTTP/3 webtransport stream, failing", buf, 0x30u);
                        }
                      }
                      uint64_t v176 = *(void **)(v63 + 48);
                      nw_protocol_error(v176, v63);
                      nw_protocol_disconnected(v176, v63);
                    }
                    else
                    {
                      *(void *)(v63 + 64) = v152;
                      nw_webtransport_metadata_set_stream_id(*(void **)(v63 + 160), v152);
                      if ((*(unsigned char *)(v63 + 276) & 0x10) == 0)
                      {
                        BOOL v153 = __nwlog_obj();
                        if (os_log_type_enabled(v153, OS_LOG_TYPE_INFO))
                        {
                          uint64_t v154 = *(void *)(v63 + 88);
                          if (v154) {
                            int v155 = *(_DWORD *)(v154 + 460);
                          }
                          else {
                            int v155 = -1;
                          }
                          uint64_t v174 = *(void *)(v63 + 64);
                          *(_DWORD *)buf = 136448002;
                          *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_assign_stream_id";
                          *(_WORD *)&buf[12] = 2082;
                          *(void *)&buf[14] = v63 + 192;
                          *(_WORD *)&buf[22] = 2080;
                          uint64_t v539 = (uint64_t)" ";
                          *(_WORD *)v540 = 1024;
                          *(_DWORD *)&v540[2] = v155;
                          *(_WORD *)&v540[6] = 2048;
                          *(void *)&v540[8] = v174;
                          *(_WORD *)&v540[16] = 2048;
                          *(void *)&v540[18] = v174;
                          *(_WORD *)&v540[26] = 2048;
                          *(void *)&v540[28] = v63;
                          __int16 v541 = 1024;
                          int v542 = 1;
                          _os_log_impl(&dword_1830D4000, v153, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> Assigned stream ID: %llu to stream with protocol %p, incoming: %u", buf, 0x4Au);
                        }
                      }
                    }
                  }
                  else if ((*(unsigned char *)(v63 + 276) & 0x10) == 0)
                  {
                    if (*((unsigned char *)p_cache + 3665))
                    {
                      v149 = __nwlog_obj();
                      if (os_log_type_enabled(v149, OS_LOG_TYPE_DEBUG))
                      {
                        uint64_t v150 = *(void *)(v63 + 88);
                        if (v150) {
                          int v151 = *(_DWORD *)(v150 + 460);
                        }
                        else {
                          int v151 = -1;
                        }
                        uint64_t v269 = *(void *)(v63 + 64);
                        *(_DWORD *)buf = 136447490;
                        *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_assign_stream_id";
                        *(_WORD *)&buf[12] = 2082;
                        *(void *)&buf[14] = v63 + 192;
                        *(_WORD *)&buf[22] = 2080;
                        uint64_t v539 = (uint64_t)" ";
                        *(_WORD *)v540 = 1024;
                        *(_DWORD *)&v540[2] = v151;
                        *(_WORD *)&v540[6] = 2048;
                        *(void *)&v540[8] = v269;
                        *(_WORD *)&v540[16] = 2048;
                        *(void *)&v540[18] = v269;
                        _os_log_impl(&dword_1830D4000, v149, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Stream ID %llu already set, skipping", buf, 0x3Au);
                        int v65 = v521;
                      }
                    }
                  }
                  uint64_t v177 = *(void *)(v63 + 64);
                  char v178 = *(unsigned char *)(v63 + 276);
                  if (v177 == -1)
                  {
                    if ((*(unsigned char *)(v63 + 276) & 0x10) == 0)
                    {
                      uint64_t v182 = __nwlog_obj();
                      if (os_log_type_enabled(v182, OS_LOG_TYPE_ERROR))
                      {
                        uint64_t v183 = *(void *)(v63 + 88);
                        if (v183) {
                          int v184 = *(_DWORD *)(v183 + 460);
                        }
                        else {
                          int v184 = -1;
                        }
                        uint64_t v209 = *(void *)(v63 + 64);
                        *(_DWORD *)buf = 136447234;
                        *(void *)&uint8_t buf[4] = "nw_webtransport_stream_configure_metadata_with_stream_id";
                        *(_WORD *)&buf[12] = 2082;
                        *(void *)&buf[14] = v63 + 192;
                        *(_WORD *)&buf[22] = 2080;
                        uint64_t v539 = (uint64_t)" ";
                        *(_WORD *)v540 = 1024;
                        *(_DWORD *)&v540[2] = v184;
                        *(_WORD *)&v540[6] = 2048;
                        *(void *)&v540[8] = v209;
                        _os_log_impl(&dword_1830D4000, v182, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> Not configuring webtransport stream metadata with no stream ID set", buf, 0x30u);
                        if ((*(unsigned char *)(v63 + 276) & 0x40) != 0) {
                          goto LABEL_270;
                        }
                        goto LABEL_269;
                      }
                    }
                  }
                  else
                  {
                    *(unsigned char *)(v63 + 276) = v178 & 0xF0 | (4 * ((v177 & 2) != 0)) | 3;
                    if ((v178 & 0x10) == 0)
                    {
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      uint64_t v179 = gLogObj;
                      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
                      {
                        uint64_t v180 = *(void *)(v63 + 88);
                        if (v180) {
                          int v181 = *(_DWORD *)(v180 + 460);
                        }
                        else {
                          int v181 = -1;
                        }
                        uint64_t v185 = *(void *)(v63 + 64);
                        unsigned int v186 = *(unsigned __int8 *)(v63 + 276);
                        *(_DWORD *)buf = 136448002;
                        *(void *)&uint8_t buf[4] = "nw_webtransport_stream_configure_metadata_with_stream_id";
                        *(_WORD *)&buf[12] = 2082;
                        *(void *)&buf[14] = v63 + 192;
                        *(_WORD *)&buf[22] = 2080;
                        uint64_t v539 = (uint64_t)" ";
                        *(_WORD *)v540 = 1024;
                        *(_DWORD *)&v540[2] = v181;
                        *(_WORD *)&v540[6] = 2048;
                        *(void *)&v540[8] = v185;
                        *(_WORD *)&v540[16] = 1024;
                        *(_DWORD *)&v540[18] = (v186 >> 1) & 1;
                        *(_WORD *)&v540[22] = 1024;
                        *(_DWORD *)&v540[24] = (v186 >> 3) & 1;
                        *(_WORD *)&v540[28] = 1024;
                        *(_DWORD *)&v540[30] = (v186 >> 2) & 1;
                        _os_log_impl(&dword_1830D4000, v179, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> Configuring metadata with flags: peer_initiated: %u, datagram: %u, unidirectional: %u", buf, 0x42u);
                      }
                    }
                    nw_webtransport_metadata_set_is_peer_initiated(*(void **)(v63 + 160), (*(unsigned char *)(v63 + 276) & 2) != 0);
                    nw_webtransport_metadata_set_is_datagram(*(void **)(v63 + 160), (*(unsigned char *)(v63 + 276) & 8) != 0);
                    nw_webtransport_metadata_set_is_unidirectional(*(void **)(v63 + 160), (*(unsigned char *)(v63 + 276) & 4) != 0);
                  }
                }
                if ((*(unsigned char *)(v63 + 276) & 0x40) != 0) {
                  goto LABEL_270;
                }
                goto LABEL_269;
              }
              if ((*(unsigned char *)(v63 + 276) & 0x10) != 0) {
                goto LABEL_236;
              }
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v133 = gLogObj;
              if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
                goto LABEL_236;
              }
              uint64_t v134 = *(void *)(v63 + 88);
              if (v134) {
                int v135 = *(_DWORD *)(v134 + 460);
              }
              else {
                int v135 = -1;
              }
              uint64_t v147 = *(void *)(v63 + 64);
              *(_DWORD *)buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v63 + 192;
              *(_WORD *)&buf[22] = 2080;
              uint64_t v539 = (uint64_t)" ";
              *(_WORD *)v540 = 1024;
              *(_DWORD *)&v540[2] = v135;
              *(_WORD *)&v540[6] = 2048;
              *(void *)&v540[8] = v147;
              _os_log_impl(&dword_1830D4000, v133, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> Could not find options for stream when reconfiguring", buf, 0x30u);
              uint64_t v63 = *(void *)(v13 + 328);
              if (!v63) {
                goto LABEL_723;
              }
            }
LABEL_237:
            if ((*(unsigned char *)(v63 + 276) & 0x10) == 0)
            {
              if (*((unsigned char *)p_cache + 3665))
              {
                v164 = __nwlog_obj();
                if (os_log_type_enabled(v164, OS_LOG_TYPE_DEBUG))
                {
                  uint64_t v165 = *(void *)(v63 + 88);
                  if (v165) {
                    int v166 = *(_DWORD *)(v165 + 460);
                  }
                  else {
                    int v166 = -1;
                  }
                  uint64_t v218 = *(void *)(v63 + 64);
                  *(_DWORD *)buf = 136447490;
                  *(void *)&uint8_t buf[4] = "nw_webtransport_session_get_next_pending_stream";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v63 + 192;
                  *(_WORD *)&buf[22] = 2080;
                  uint64_t v539 = (uint64_t)" ";
                  *(_WORD *)v540 = 1024;
                  *(_DWORD *)&v540[2] = v166;
                  *(_WORD *)&v540[6] = 2048;
                  *(void *)&v540[8] = v218;
                  *(_WORD *)&v540[16] = 2048;
                  *(void *)&v540[18] = v63;
                  _os_log_impl(&dword_1830D4000, v164, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> found stream (%p)", buf, 0x3Au);
                }
              }
            }
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v79 = *(unsigned int *)(v13 + 456);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = "webtransport_session->pending_stream_count";
          *(_WORD *)&buf[22] = 2048;
          uint64_t v539 = 1;
          *(_WORD *)v540 = 2048;
          *(void *)&v540[2] = v79;
          int v80 = (char *)_os_log_send_and_compose_impl();
          iterate_block[0] = 16;
          LOBYTE(v527) = 0;
          if (__nwlog_fault(v80, iterate_block, &v527))
          {
            if (iterate_block[0] == 17)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v81 = gLogObj;
              os_log_type_t v82 = iterate_block[0];
              if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0]))
              {
                uint64_t v83 = *(unsigned int *)(v13 + 456);
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = "webtransport_session->pending_stream_count";
                *(_WORD *)&buf[22] = 2048;
                uint64_t v539 = 1;
                *(_WORD *)v540 = 2048;
                *(void *)&v540[2] = v83;
                int v84 = v81;
                os_log_type_t v85 = v82;
                uint64_t v86 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_114:
                _os_log_impl(&dword_1830D4000, v84, v85, v86, buf, 0x2Au);
              }
            }
            else if ((_BYTE)v527)
            {
              BOOL v89 = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v90 = gLogObj;
              os_log_type_t v91 = iterate_block[0];
              BOOL v92 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0]);
              if (v89)
              {
                if (v92)
                {
                  uint64_t v93 = *(unsigned int *)(v13 + 456);
                  *(_DWORD *)buf = 136447234;
                  *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = "webtransport_session->pending_stream_count";
                  *(_WORD *)&buf[22] = 2048;
                  uint64_t v539 = 1;
                  *(_WORD *)v540 = 2048;
                  *(void *)&v540[2] = v93;
                  *(_WORD *)&v540[10] = 2082;
                  *(void *)&v540[12] = v89;
                  _os_log_impl(&dword_1830D4000, v90, v91, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
                }
                free(v89);
                goto LABEL_115;
              }
              if (v92)
              {
                uint64_t v97 = *(unsigned int *)(v13 + 456);
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = "webtransport_session->pending_stream_count";
                *(_WORD *)&buf[22] = 2048;
                uint64_t v539 = 1;
                *(_WORD *)v540 = 2048;
                *(void *)&v540[2] = v97;
                int v84 = v90;
                os_log_type_t v85 = v91;
                uint64_t v86 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
                goto LABEL_114;
              }
            }
            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v94 = gLogObj;
              os_log_type_t v95 = iterate_block[0];
              if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0]))
              {
                uint64_t v96 = *(unsigned int *)(v13 + 456);
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = "webtransport_session->pending_stream_count";
                *(_WORD *)&buf[22] = 2048;
                uint64_t v539 = 1;
                *(_WORD *)v540 = 2048;
                *(void *)&v540[2] = v96;
                int v84 = v94;
                os_log_type_t v85 = v95;
                uint64_t v86 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
                goto LABEL_114;
              }
            }
          }
LABEL_115:
          if (v80) {
            free(v80);
          }
          *(_DWORD *)(v13 + 456) = 0;
          goto LABEL_118;
        }
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_response";
        v488 = (char *)_os_log_send_and_compose_impl();
        iterate_block[0] = 16;
        LOBYTE(v527) = 0;
        if (!__nwlog_fault(v488, iterate_block, &v527)) {
          goto LABEL_780;
        }
        if (iterate_block[0] == 17)
        {
          v489 = __nwlog_obj();
          os_log_type_t v490 = iterate_block[0];
          if (!os_log_type_enabled(v489, (os_log_type_t)iterate_block[0])) {
            goto LABEL_780;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_response";
          v491 = "%{public}s called with null response";
          goto LABEL_778;
        }
        if (!(_BYTE)v527)
        {
          v489 = __nwlog_obj();
          os_log_type_t v490 = iterate_block[0];
          if (!os_log_type_enabled(v489, (os_log_type_t)iterate_block[0])) {
            goto LABEL_780;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_response";
          v491 = "%{public}s called with null response, backtrace limit exceeded";
          goto LABEL_778;
        }
        v504 = (char *)__nw_create_backtrace_string();
        v501 = __nwlog_obj();
        os_log_type_t v502 = iterate_block[0];
        BOOL v507 = os_log_type_enabled(v501, (os_log_type_t)iterate_block[0]);
        if (v504)
        {
          if (!v507) {
            goto LABEL_768;
          }
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_response";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v504;
          v506 = "%{public}s called with null response, dumping backtrace:%{public}s";
          goto LABEL_767;
        }
        if (v507)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_response";
          v491 = "%{public}s called with null response, no backtrace";
          goto LABEL_793;
        }
LABEL_780:
        if (!v488) {
          goto LABEL_724;
        }
LABEL_781:
        free(v488);
        goto LABEL_724;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_response";
      v488 = (char *)_os_log_send_and_compose_impl();
      iterate_block[0] = 16;
      LOBYTE(v527) = 0;
      if (!__nwlog_fault(v488, iterate_block, &v527)) {
        goto LABEL_780;
      }
      if (iterate_block[0] == 17)
      {
        v489 = __nwlog_obj();
        os_log_type_t v490 = iterate_block[0];
        if (!os_log_type_enabled(v489, (os_log_type_t)iterate_block[0])) {
          goto LABEL_780;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_response";
        v491 = "%{public}s called with null nw_protocol_metadata_is_http(metadata)";
LABEL_778:
        v509 = v489;
        os_log_type_t v510 = v490;
LABEL_779:
        _os_log_impl(&dword_1830D4000, v509, v510, v491, buf, 0xCu);
        goto LABEL_780;
      }
      if (!(_BYTE)v527)
      {
        v489 = __nwlog_obj();
        os_log_type_t v490 = iterate_block[0];
        if (!os_log_type_enabled(v489, (os_log_type_t)iterate_block[0])) {
          goto LABEL_780;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_response";
        v491 = "%{public}s called with null nw_protocol_metadata_is_http(metadata), backtrace limit exceeded";
        goto LABEL_778;
      }
      v500 = (char *)__nw_create_backtrace_string();
      v501 = __nwlog_obj();
      os_log_type_t v502 = iterate_block[0];
      BOOL v503 = os_log_type_enabled(v501, (os_log_type_t)iterate_block[0]);
      if (v500)
      {
        if (v503)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_response";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v500;
          _os_log_impl(&dword_1830D4000, v501, v502, "%{public}s called with null nw_protocol_metadata_is_http(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v500);
        goto LABEL_780;
      }
      if (!v503) {
        goto LABEL_780;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_response";
      v491 = "%{public}s called with null nw_protocol_metadata_is_http(metadata), no backtrace";
LABEL_793:
      v509 = v501;
      os_log_type_t v510 = v502;
      goto LABEL_779;
    }
    if (nw_protocol_metadata_is_http(v12))
    {
      os_log_type_t v31 = NWConcrete_nw_resolution_report.cache;
      if ((*(unsigned char *)(v13 + 548) & 2) == 0)
      {
        if (gLogDatapath)
        {
          v494 = __nwlog_obj();
          if (os_log_type_enabled(v494, OS_LOG_TYPE_DEBUG))
          {
            int v495 = *(_DWORD *)(v13 + 460);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_request";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v13 + 464;
            *(_WORD *)&buf[22] = 2080;
            uint64_t v539 = (uint64_t)" ";
            *(_WORD *)v540 = 1024;
            *(_DWORD *)&v540[2] = v495;
            _os_log_impl(&dword_1830D4000, v494, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
          }
        }
      }
      id v525 = nw_http_metadata_copy_request(v526);
      if (v525)
      {
        well_known = (void *)_nw_http_response_create_well_known(200);
        metadata_for_response = nw_http_create_metadata_for_response(well_known);
        uint64_t v34 = *(void *)(v13 + 32);
        if ((*(unsigned char *)(v13 + 548) & 2) == 0)
        {
          if (gLogDatapath)
          {
            v496 = __nwlog_obj();
            if (os_log_type_enabled(v496, OS_LOG_TYPE_DEBUG))
            {
              int v497 = *(_DWORD *)(v13 + 460);
              *(_DWORD *)iterate_block = 136446978;
              *(void *)&iterate_block[4] = "nw_webtransport_session_send_metadata";
              *(_WORD *)&iterate_block[12] = 2082;
              *(void *)&iterate_block[14] = v13 + 464;
              *(_WORD *)&iterate_block[22] = 2080;
              v548 = " ";
              LOWORD(v549) = 1024;
              *(_DWORD *)((char *)&v549 + 2) = v497;
              _os_log_impl(&dword_1830D4000, v496, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", iterate_block, 0x26u);
            }
          }
        }
        uint64_t v527 = 0;
        uint64_t v528 = (uint64_t)&v527;
        int output_frames = nw_protocol_get_output_frames(v34, v13, 0, 0, 1, (uint64_t)&v527);
        if ((*(unsigned char *)(v13 + 548) & 2) == 0)
        {
          if (gLogDatapath)
          {
            v498 = __nwlog_obj();
            if (os_log_type_enabled(v498, OS_LOG_TYPE_DEBUG))
            {
              int v499 = *(_DWORD *)(v13 + 460);
              *(_DWORD *)iterate_block = 136447234;
              *(void *)&iterate_block[4] = "nw_webtransport_session_send_metadata";
              *(_WORD *)&iterate_block[12] = 2082;
              *(void *)&iterate_block[14] = v13 + 464;
              *(_WORD *)&iterate_block[22] = 2080;
              v548 = " ";
              LOWORD(v549) = 1024;
              *(_DWORD *)((char *)&v549 + 2) = v499;
              HIWORD(v549) = 1024;
              LODWORD(v550) = output_frames;
              _os_log_impl(&dword_1830D4000, v498, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> Got %u output frames", iterate_block, 0x2Cu);
            }
          }
        }
        v524 = metadata_for_response;
        if (!output_frames) {
          goto LABEL_48;
        }
        *(void *)iterate_block = 0;
        *(void *)&iterate_block[8] = iterate_block;
        *(void *)&iterate_block[16] = 0x2000000000;
        LOBYTE(v548) = 0;
        *(void *)buf = MEMORY[0x1E4F143A8];
        *(void *)&buf[8] = 0x40000000;
        *(void *)&buf[16] = ___ZL37nw_webtransport_session_send_metadataP23nw_webtransport_sessionP20nw_protocol_metadataP11nw_protocol_block_invoke;
        uint64_t v539 = (uint64_t)&unk_1E5240478;
        *(void *)v540 = iterate_block;
        *(void *)&v540[8] = &v527;
        *(void *)&v540[16] = v13;
        *(void *)&v540[24] = metadata_for_response;
        uint64_t v36 = v527;
        do
        {
          if (!v36) {
            break;
          }
          uint64_t v37 = *(void *)(v36 + 32);
          char v38 = (*(uint64_t (**)(unsigned char *))&buf[16])(buf);
          uint64_t v36 = v37;
        }
        while ((v38 & 1) != 0);
        char v39 = nw_protocol_finalize_output_frames(v34, (uint64_t)&v527);
        _Block_object_dispose(iterate_block, 8);
        if ((v39 & 1) == 0)
        {
LABEL_48:
          if (*(_DWORD *)(v13 + 444) != 5)
          {
            if ((*(unsigned char *)(v13 + 548) & 2) == 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v51 = gLogObj;
              if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
              {
                int v52 = *(_DWORD *)(v13 + 460);
                *(_DWORD *)buf = 136447234;
                *(void *)&uint8_t buf[4] = "nw_webtransport_session_terminate";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v13 + 464;
                *(_WORD *)&buf[22] = 2080;
                uint64_t v539 = (uint64_t)" ";
                *(_WORD *)v540 = 1024;
                *(_DWORD *)&v540[2] = v52;
                *(_WORD *)&v540[6] = 1024;
                *(_DWORD *)&v540[8] = 57;
                _os_log_impl(&dword_1830D4000, v51, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Closing webtransport session with error %{darwin.errno}d", buf, 0x2Cu);
              }
            }
            *(_DWORD *)(v13 + 444) = 5;
            BOOL v53 = *(char **)(v13 + 184);
            if (v53)
            {
              *(void *)buf = MEMORY[0x1E4F143A8];
              *(void *)&buf[8] = 0x40000000;
              *(void *)&buf[16] = ___ZL33nw_webtransport_session_terminateP23nw_webtransport_sessioni_block_invoke;
              uint64_t v539 = (uint64_t)&__block_descriptor_tmp_26_33833;
              *(_DWORD *)v540 = 57;
              nw_hash_table_apply(v53, (uint64_t)buf);
            }
            uint64_t v54 = *(void *)(v13 + 424);
            if (v54)
            {
              v55 = *(void **)(v54 + 48);
              nw_protocol_error(v55, *(void *)(v13 + 424));
              nw_protocol_disconnected(v55, v54);
            }
            uint64_t v56 = *(void *)(v13 + 328);
            if (v56)
            {
              do
              {
                uint64_t v57 = *(void *)(v56 + 112);
                os_log_type_t v58 = *(void **)(v56 + 48);
                nw_protocol_error(v58, v56);
                nw_protocol_disconnected(v58, v56);
                uint64_t v56 = v57;
              }
              while (v57);
            }
            uint64_t v59 = *(void *)(v13 + 416);
            if (v59)
            {
              uint64_t v60 = *(void **)(v59 + 48);
              nw_protocol_error(v60, *(void *)(v13 + 416));
              nw_protocol_disconnected(v60, v59);
            }
            if (*(void *)(v13 + 32))
            {
              nw_protocol_remove_instance(v13);
              nw_protocol_disconnect(*(void **)(v13 + 32), v13);
            }
            goto LABEL_719;
          }
          if ((*(unsigned char *)(v13 + 548) & 2) != 0
            || (pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once),
                networkd_settings_init(),
                uint64_t v47 = gLogObj,
                !os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)))
          {
LABEL_719:
            if (v524) {
              os_release(v524);
            }
            if (well_known) {
              os_release(well_known);
            }
            goto LABEL_723;
          }
          int v48 = *(_DWORD *)(v13 + 460);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_terminate";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v13 + 464;
          *(_WORD *)&buf[22] = 2080;
          uint64_t v539 = (uint64_t)" ";
          *(_WORD *)v540 = 1024;
          *(_DWORD *)&v540[2] = v48;
          BOOL v43 = "%{public}s %{public}s%s<i%u> Session already terminated, ignoring";
          os_log_type_t v44 = v47;
          os_log_type_t v45 = OS_LOG_TYPE_INFO;
          uint32_t v46 = 38;
LABEL_52:
          _os_log_impl(&dword_1830D4000, v44, v45, v43, buf, v46);
          goto LABEL_719;
        }
        if (*(_DWORD *)(v13 + 444) == 4)
        {
          if ((*(unsigned char *)(v13 + 548) & 2) != 0) {
            goto LABEL_719;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v40 = gLogObj;
          if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
            goto LABEL_719;
          }
          int v41 = *(_DWORD *)(v13 + 460);
          int v42 = *(_DWORD *)(v13 + 444);
          *(_DWORD *)buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_streams_ready";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v13 + 464;
          *(_WORD *)&buf[22] = 2080;
          uint64_t v539 = (uint64_t)" ";
          *(_WORD *)v540 = 1024;
          *(_DWORD *)&v540[2] = v41;
          *(_WORD *)&v540[6] = 1024;
          *(_DWORD *)&v540[8] = v42;
          BOOL v43 = "%{public}s %{public}s%s<i%u> Tried to ready streams with incorrect state: %d, ignoring";
          os_log_type_t v44 = v40;
          os_log_type_t v45 = OS_LOG_TYPE_ERROR;
          uint32_t v46 = 44;
          goto LABEL_52;
        }
        *(_DWORD *)(v13 + 444) = 4;
        if ((*(unsigned char *)(v13 + 548) & 2) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v280 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          {
            int v281 = *(_DWORD *)(v13 + 460);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_webtransport_session_streams_ready";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v13 + 464;
            *(_WORD *)&buf[22] = 2080;
            uint64_t v539 = (uint64_t)" ";
            *(_WORD *)v540 = 1024;
            *(_DWORD *)&v540[2] = v281;
            _os_log_impl(&dword_1830D4000, v280, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Webtransport session established, reconfiguring streams", buf, 0x26u);
          }
        }
        uint64_t v282 = *(void *)(v13 + 328);
        if (!v282) {
          goto LABEL_719;
        }
        v519 = well_known;
        if ((*(unsigned char *)(v282 + 276) & 0x10) == 0)
        {
          if (gLogDatapath)
          {
            v514 = __nwlog_obj();
            if (os_log_type_enabled(v514, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v515 = *(void *)(v282 + 88);
              if (v515) {
                int v516 = *(_DWORD *)(v515 + 460);
              }
              else {
                int v516 = -1;
              }
              uint64_t v518 = *(void *)(v282 + 64);
              *(_DWORD *)buf = 136447490;
              *(void *)&uint8_t buf[4] = "nw_webtransport_session_get_next_pending_stream";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v282 + 192;
              *(_WORD *)&buf[22] = 2080;
              uint64_t v539 = (uint64_t)" ";
              *(_WORD *)v540 = 1024;
              *(_DWORD *)&v540[2] = v516;
              *(_WORD *)&v540[6] = 2048;
              *(void *)&v540[8] = v518;
              *(_WORD *)&v540[16] = 2048;
              *(void *)&v540[18] = v282;
              _os_log_impl(&dword_1830D4000, v514, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> found stream (%p)", buf, 0x3Au);
              os_log_type_t v31 = (void **)(NWConcrete_nw_resolution_report + 16);
            }
          }
        }
        int v523 = *(unsigned char *)(v13 + 548) & 1;
        while (1)
        {
          if ((*(unsigned char *)(v13 + 548) & 2) == 0)
          {
            if (*((unsigned char *)v31 + 3665))
            {
              v427 = __nwlog_obj();
              if (os_log_type_enabled(v427, OS_LOG_TYPE_DEBUG))
              {
                int v428 = *(_DWORD *)(v13 + 460);
                *(_DWORD *)buf = 136447234;
                *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v13 + 464;
                *(_WORD *)&buf[22] = 2080;
                uint64_t v539 = (uint64_t)" ";
                *(_WORD *)v540 = 1024;
                *(_DWORD *)&v540[2] = v428;
                *(_WORD *)&v540[6] = 2048;
                *(void *)&v540[8] = v282;
                _os_log_impl(&dword_1830D4000, v427, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called for stream (%p)", buf, 0x30u);
              }
            }
          }
          if ((*(unsigned char *)(v282 + 276) & 0x20) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
            *(_WORD *)&buf[12] = 2048;
            *(void *)&buf[14] = v282;
            v283 = (char *)_os_log_send_and_compose_impl();
            iterate_block[0] = 16;
            LOBYTE(v527) = 0;
            if (!__nwlog_fault(v283, iterate_block, &v527)) {
              goto LABEL_439;
            }
            if (iterate_block[0] == 17)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v284 = gLogObj;
              os_log_type_t v285 = iterate_block[0];
              if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0]))
              {
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
                *(_WORD *)&buf[12] = 2048;
                *(void *)&buf[14] = v282;
                v286 = v284;
                os_log_type_t v287 = v285;
                v288 = "%{public}s stream %p not in pending list, cannot remove";
                goto LABEL_438;
              }
              goto LABEL_439;
            }
            if ((_BYTE)v527)
            {
              v291 = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v292 = gLogObj;
              os_log_type_t v293 = iterate_block[0];
              BOOL v294 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0]);
              if (v291)
              {
                if (v294)
                {
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
                  *(_WORD *)&buf[12] = 2048;
                  *(void *)&buf[14] = v282;
                  *(_WORD *)&buf[22] = 2082;
                  uint64_t v539 = (uint64_t)v291;
                  _os_log_impl(&dword_1830D4000, v292, v293, "%{public}s stream %p not in pending list, cannot remove, dumping backtrace:%{public}s", buf, 0x20u);
                }
                free(v291);
                goto LABEL_439;
              }
              if (!v294)
              {
LABEL_439:
                if (v283) {
                  free(v283);
                }
                goto LABEL_451;
              }
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
              *(_WORD *)&buf[12] = 2048;
              *(void *)&buf[14] = v282;
              v286 = v292;
              os_log_type_t v287 = v293;
              v288 = "%{public}s stream %p not in pending list, cannot remove, no backtrace";
            }
            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v304 = gLogObj;
              os_log_type_t v305 = iterate_block[0];
              if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0])) {
                goto LABEL_439;
              }
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
              *(_WORD *)&buf[12] = 2048;
              *(void *)&buf[14] = v282;
              v286 = v304;
              os_log_type_t v287 = v305;
              v288 = "%{public}s stream %p not in pending list, cannot remove, backtrace limit exceeded";
            }
LABEL_438:
            _os_log_impl(&dword_1830D4000, v286, v287, v288, buf, 0x16u);
            goto LABEL_439;
          }
          uint64_t v289 = *(void *)(v282 + 112);
          v290 = *(void **)(v282 + 120);
          if (v289)
          {
            *(void *)(v289 + 120) = v290;
            v290 = *(void **)(v282 + 120);
          }
          else
          {
            *(void *)(v13 + 336) = v290;
          }
          void *v290 = v289;
          *(void *)(v282 + 112) = 0;
          *(void *)(v282 + 120) = 0;
          int v295 = *(_DWORD *)(v13 + 456);
          *(_DWORD *)(v13 + 456) = v295 - 1;
          if (!v295) {
            break;
          }
LABEL_449:
          char v315 = *(unsigned char *)(v282 + 276);
          *(unsigned char *)(v282 + 276) = v315 & 0xDF;
          if ((v315 & 0x10) == 0)
          {
            if (*((unsigned char *)v31 + 3665))
            {
              v429 = __nwlog_obj();
              if (os_log_type_enabled(v429, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v430 = *(void *)(v282 + 88);
                if (v430) {
                  int v431 = *(_DWORD *)(v430 + 460);
                }
                else {
                  int v431 = -1;
                }
                uint64_t v446 = *(void *)(v282 + 64);
                int v447 = *(_DWORD *)(v13 + 456);
                *(_DWORD *)buf = 136447746;
                *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v282 + 192;
                *(_WORD *)&buf[22] = 2080;
                uint64_t v539 = (uint64_t)" ";
                *(_WORD *)v540 = 1024;
                *(_DWORD *)&v540[2] = v431;
                *(_WORD *)&v540[6] = 2048;
                *(void *)&v540[8] = v446;
                *(_WORD *)&v540[16] = 2048;
                *(void *)&v540[18] = v282;
                *(_WORD *)&v540[26] = 1024;
                *(_DWORD *)&v540[28] = v447;
                _os_log_impl(&dword_1830D4000, v429, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> removed pending stream (%p), now have %u pending streams", buf, 0x40u);
                well_known = v519;
                os_log_type_t v31 = (void **)(NWConcrete_nw_resolution_report + 16);
              }
            }
          }
LABEL_451:
          int v316 = *(_DWORD *)(v13 + 448);
          if (v316 != 1)
          {
            if (!v316)
            {
              if ((*(unsigned char *)(v282 + 276) & 0x10) == 0)
              {
                if (*((unsigned char *)v31 + 3665))
                {
                  v432 = __nwlog_obj();
                  if (os_log_type_enabled(v432, OS_LOG_TYPE_DEBUG))
                  {
                    uint64_t v433 = *(void *)(v282 + 88);
                    if (v433) {
                      int v434 = *(_DWORD *)(v433 + 460);
                    }
                    else {
                      int v434 = -1;
                    }
                    uint64_t v448 = *(void *)(v282 + 64);
                    *(_DWORD *)buf = 136447746;
                    *(void *)&uint8_t buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = v282 + 192;
                    *(_WORD *)&buf[22] = 2080;
                    uint64_t v539 = (uint64_t)" ";
                    *(_WORD *)v540 = 1024;
                    *(_DWORD *)&v540[2] = v434;
                    *(_WORD *)&v540[6] = 2048;
                    *(void *)&v540[8] = v448;
                    *(_WORD *)&v540[16] = 2048;
                    *(void *)&v540[18] = v282;
                    *(_WORD *)&v540[26] = 1024;
                    *(_DWORD *)&v540[28] = v523;
                    _os_log_impl(&dword_1830D4000, v432, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Reconfiguring HTTP2 stream with protocol: %p, peer_initiated: %u", buf, 0x40u);
                    well_known = v519;
                    os_log_type_t v31 = (void **)(NWConcrete_nw_resolution_report + 16);
                  }
                }
              }
              uint64_t v317 = *(void *)(v282 + 88);
              if (*(void *)(v317 + 416) == v282)
              {
                if ((*(unsigned char *)(v282 + 276) & 0x10) == 0)
                {
                  if (*((unsigned char *)v31 + 3665))
                  {
                    v436 = __nwlog_obj();
                    if (os_log_type_enabled(v436, OS_LOG_TYPE_DEBUG))
                    {
                      uint64_t v437 = *(void *)(v282 + 88);
                      if (v437) {
                        int v438 = *(_DWORD *)(v437 + 460);
                      }
                      else {
                        int v438 = -1;
                      }
                      uint64_t v473 = *(void *)(v282 + 64);
                      *(_DWORD *)buf = 136447234;
                      *(void *)&uint8_t buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&buf[14] = v282 + 192;
                      *(_WORD *)&buf[22] = 2080;
                      uint64_t v539 = (uint64_t)" ";
                      *(_WORD *)v540 = 1024;
                      *(_DWORD *)&v540[2] = v438;
                      *(_WORD *)&v540[6] = 2048;
                      *(void *)&v540[8] = v473;
                      _os_log_impl(&dword_1830D4000, v436, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Returning without more reconfiguration for placeholder stream", buf, 0x30u);
                      well_known = v519;
                      os_log_type_t v31 = (void **)(NWConcrete_nw_resolution_report + 16);
                    }
                  }
                }
                nw_protocol_connected(*(void **)(v282 + 48), v282);
              }
              else
              {
                if (nw_protocol_webtransport_http2_stream_callbacks(void)::onceToken != -1) {
                  dispatch_once(&nw_protocol_webtransport_http2_stream_callbacks(void)::onceToken, &__block_literal_global_34);
                }
                *(void *)(v282 + 24) = &nw_protocol_webtransport_http2_stream_callbacks(void)::protocol_callbacks;
                nw_protocol_set_output_handler(v282, v317);
                v318 = nw_parameters_copy_protocol_options_legacy(*(void **)(v282 + 144), (nw_protocol *)v282);
                if (v318)
                {
                  v319 = v318;
                  if (v523)
                  {
                    if ((*(unsigned char *)(v282 + 276) & 0x10) == 0)
                    {
                      if (*((unsigned char *)v31 + 3665))
                      {
                        v334 = __nwlog_obj();
                        if (os_log_type_enabled(v334, OS_LOG_TYPE_DEBUG))
                        {
                          uint64_t v335 = *(void *)(v282 + 88);
                          if (v335) {
                            int v336 = *(_DWORD *)(v335 + 460);
                          }
                          else {
                            int v336 = -1;
                          }
                          uint64_t v476 = *(void *)(v282 + 64);
                          *(_DWORD *)buf = 136447234;
                          *(void *)&uint8_t buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
                          *(_WORD *)&buf[12] = 2082;
                          *(void *)&buf[14] = v282 + 192;
                          *(_WORD *)&buf[22] = 2080;
                          uint64_t v539 = (uint64_t)" ";
                          *(_WORD *)v540 = 1024;
                          *(_DWORD *)&v540[2] = v336;
                          *(_WORD *)&v540[6] = 2048;
                          *(void *)&v540[8] = v476;
                          _os_log_impl(&dword_1830D4000, v334, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Waiting for connected callback and stream ID assignment to setup metadata", buf, 0x30u);
                          well_known = v519;
                          os_log_type_t v31 = (void **)(NWConcrete_nw_resolution_report + 16);
                        }
                      }
                    }
                  }
                  else if (nw_protocol_options_is_webtransport(v318))
                  {
                    *(unsigned char *)(v282 + 276) = *(unsigned char *)(v282 + 276) & 0xFC | 1;
                    if (nw_webtransport_options_get_is_datagram(v319)) {
                      char v320 = 8;
                    }
                    else {
                      char v320 = 0;
                    }
                    *(unsigned char *)(v282 + 276) = *(unsigned char *)(v282 + 276) & 0xF7 | v320;
                    BOOL v321 = nw_webtransport_options_get_is_unidirectional(v319);
                    char v322 = *(unsigned char *)(v282 + 276);
                    if (v321) {
                      char v323 = 4;
                    }
                    else {
                      char v323 = 0;
                    }
                    *(unsigned char *)(v282 + 276) = v322 & 0xFB | v323;
                    if ((v322 & 0x10) == 0)
                    {
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      v324 = gLogObj;
                      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
                      {
                        uint64_t v325 = *(void *)(v282 + 88);
                        if (v325) {
                          int v326 = *(_DWORD *)(v325 + 460);
                        }
                        else {
                          int v326 = -1;
                        }
                        uint64_t v373 = *(void *)(v282 + 64);
                        unsigned int v374 = *(unsigned __int8 *)(v282 + 276);
                        *(_DWORD *)buf = 136448002;
                        *(void *)&uint8_t buf[4] = "nw_webtransport_stream_configure_metadata_with_options";
                        *(_WORD *)&buf[12] = 2082;
                        *(void *)&buf[14] = v282 + 192;
                        *(_WORD *)&buf[22] = 2080;
                        uint64_t v539 = (uint64_t)" ";
                        *(_WORD *)v540 = 1024;
                        *(_DWORD *)&v540[2] = v326;
                        *(_WORD *)&v540[6] = 2048;
                        *(void *)&v540[8] = v373;
                        *(_WORD *)&v540[16] = 1024;
                        *(_DWORD *)&v540[18] = (v374 >> 1) & 1;
                        *(_WORD *)&v540[22] = 1024;
                        *(_DWORD *)&v540[24] = (v374 >> 3) & 1;
                        *(_WORD *)&v540[28] = 1024;
                        *(_DWORD *)&v540[30] = (v374 >> 2) & 1;
                        _os_log_impl(&dword_1830D4000, v324, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> Configuring metadata with flags: peer_initiated: %u, datagram: %u, unidirectional: %u", buf, 0x42u);
                      }
                    }
                    nw_webtransport_metadata_set_is_peer_initiated(*(void **)(v282 + 160), (*(unsigned char *)(v282 + 276) & 2) != 0);
                    nw_webtransport_metadata_set_is_datagram(*(void **)(v282 + 160), (*(unsigned char *)(v282 + 276) & 8) != 0);
                    nw_webtransport_metadata_set_is_unidirectional(*(void **)(v282 + 160), (*(unsigned char *)(v282 + 276) & 4) != 0);
                  }
                  else if ((*(unsigned char *)(v282 + 276) & 0x10) == 0)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    v356 = gLogObj;
                    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                    {
                      uint64_t v357 = *(void *)(v282 + 88);
                      if (v357) {
                        int v358 = *(_DWORD *)(v357 + 460);
                      }
                      else {
                        int v358 = -1;
                      }
                      uint64_t v380 = *(void *)(v282 + 64);
                      *(_DWORD *)buf = 136447234;
                      *(void *)&uint8_t buf[4] = "nw_webtransport_stream_configure_metadata_with_options";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&buf[14] = v282 + 192;
                      *(_WORD *)&buf[22] = 2080;
                      uint64_t v539 = (uint64_t)" ";
                      *(_WORD *)v540 = 1024;
                      *(_DWORD *)&v540[2] = v358;
                      *(_WORD *)&v540[6] = 2048;
                      *(void *)&v540[8] = v380;
                      _os_log_impl(&dword_1830D4000, v356, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> Invalid protocol options for webtransport stream", buf, 0x30u);
                    }
                  }
                  os_release(v319);
                }
                else if ((*(unsigned char *)(v282 + 276) & 0x10) == 0)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v331 = gLogObj;
                  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                  {
                    uint64_t v332 = *(void *)(v282 + 88);
                    if (v332) {
                      int v333 = *(_DWORD *)(v332 + 460);
                    }
                    else {
                      int v333 = -1;
                    }
                    uint64_t v363 = *(void *)(v282 + 64);
                    *(_DWORD *)buf = 136447234;
                    *(void *)&uint8_t buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = v282 + 192;
                    *(_WORD *)&buf[22] = 2080;
                    uint64_t v539 = (uint64_t)" ";
                    *(_WORD *)v540 = 1024;
                    *(_DWORD *)&v540[2] = v333;
                    *(_WORD *)&v540[6] = 2048;
                    *(void *)&v540[8] = v363;
                    _os_log_impl(&dword_1830D4000, v331, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> Could not find options for stream when reconfiguring", buf, 0x30u);
                  }
                }
              }
              if (v282 != *(void *)(v13 + 416)) {
                nw_protocol_connected((void *)v282, v13);
              }
            }
LABEL_567:
            uint64_t v282 = *(void *)(v13 + 328);
            if (!v282) {
              goto LABEL_719;
            }
            goto LABEL_568;
          }
          uint64_t v327 = *(void *)(v282 + 88);
          if ((*(unsigned char *)(v282 + 276) & 0x10) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v328 = gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
            {
              uint64_t v329 = *(void *)(v282 + 88);
              if (v329) {
                int v330 = *(_DWORD *)(v329 + 460);
              }
              else {
                int v330 = -1;
              }
              uint64_t v337 = *(void *)(v282 + 64);
              *(_DWORD *)buf = 136447746;
              *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v282 + 192;
              *(_WORD *)&buf[22] = 2080;
              uint64_t v539 = (uint64_t)" ";
              *(_WORD *)v540 = 1024;
              *(_DWORD *)&v540[2] = v330;
              *(_WORD *)&v540[6] = 2048;
              *(void *)&v540[8] = v337;
              *(_WORD *)&v540[16] = 2048;
              *(void *)&v540[18] = v282;
              *(_WORD *)&v540[26] = 1024;
              *(_DWORD *)&v540[28] = v523;
              _os_log_impl(&dword_1830D4000, v328, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> Reconfiguring HTTP3 stream with protocol: %p, peer_initiated: %u", buf, 0x40u);
            }
          }
          if (*(void *)(v327 + 416) == v282)
          {
            os_log_type_t v31 = (void **)(NWConcrete_nw_resolution_report + 16);
            if ((*(unsigned char *)(v282 + 276) & 0x10) == 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v347 = gLogObj;
              if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v348 = *(void *)(v282 + 88);
                if (v348) {
                  int v349 = *(_DWORD *)(v348 + 460);
                }
                else {
                  int v349 = -1;
                }
                uint64_t v362 = *(void *)(v282 + 64);
                *(_DWORD *)buf = 136447234;
                *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v282 + 192;
                *(_WORD *)&buf[22] = 2080;
                uint64_t v539 = (uint64_t)" ";
                *(_WORD *)v540 = 1024;
                *(_DWORD *)&v540[2] = v349;
                *(_WORD *)&v540[6] = 2048;
                *(void *)&v540[8] = v362;
                _os_log_impl(&dword_1830D4000, v347, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Returning connected without more reconfiguration for placeholder stream", buf, 0x30u);
              }
            }
            nw_protocol_connected(*(void **)(v282 + 48), v282);
            uint64_t v282 = *(void *)(v13 + 328);
            if (!v282) {
              goto LABEL_719;
            }
          }
          else
          {
            v338 = nw_parameters_copy_protocol_options_legacy(*(void **)(v282 + 144), (nw_protocol *)v282);
            if (v338)
            {
              v339 = v338;
              if (nw_protocol_webtransport_http3_stream_callbacks(void)::onceToken != -1) {
                dispatch_once(&nw_protocol_webtransport_http3_stream_callbacks(void)::onceToken, &__block_literal_global_49);
              }
              *(void *)(v282 + 24) = &nw_protocol_webtransport_http3_stream_callbacks(void)::protocol_callbacks;
              if (v523)
              {
                if ((*(unsigned char *)(v282 + 276) & 0x10) == 0)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v353 = gLogObj;
                  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
                  {
                    uint64_t v354 = *(void *)(v282 + 88);
                    if (v354) {
                      int v355 = *(_DWORD *)(v354 + 460);
                    }
                    else {
                      int v355 = -1;
                    }
                    uint64_t v365 = *(void *)(v282 + 64);
                    *(_DWORD *)buf = 136447234;
                    *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = v282 + 192;
                    *(_WORD *)&buf[22] = 2080;
                    uint64_t v539 = (uint64_t)" ";
                    *(_WORD *)v540 = 1024;
                    *(_DWORD *)&v540[2] = v355;
                    *(_WORD *)&v540[6] = 2048;
                    *(void *)&v540[8] = v365;
                    _os_log_impl(&dword_1830D4000, v353, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Preemptively configuring metadata with incoming stream ID", buf, 0x30u);
                  }
                }
                if (*(void *)(v327 + 176) != -1)
                {
                  if (*(void *)(v282 + 64) == -1)
                  {
                    uint64_t v369 = *(void *)(*(void *)(v282 + 88) + 176);
                    if (v369 == -1)
                    {
                      if ((*(unsigned char *)(v282 + 276) & 0x10) == 0)
                      {
                        v385 = __nwlog_obj();
                        if (os_log_type_enabled(v385, OS_LOG_TYPE_ERROR))
                        {
                          uint64_t v386 = *(void *)(v282 + 88);
                          if (v386) {
                            int v387 = *(_DWORD *)(v386 + 460);
                          }
                          else {
                            int v387 = -1;
                          }
                          uint64_t v392 = *(void *)(v282 + 64);
                          *(_DWORD *)buf = 136447234;
                          *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_assign_stream_id";
                          *(_WORD *)&buf[12] = 2082;
                          *(void *)&buf[14] = v282 + 192;
                          *(_WORD *)&buf[22] = 2080;
                          uint64_t v539 = (uint64_t)" ";
                          *(_WORD *)v540 = 1024;
                          *(_DWORD *)&v540[2] = v387;
                          *(_WORD *)&v540[6] = 2048;
                          *(void *)&v540[8] = v392;
                          _os_log_impl(&dword_1830D4000, v385, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> Failed to get stream ID for HTTP/3 webtransport stream, failing", buf, 0x30u);
                        }
                      }
                      v393 = *(void **)(v282 + 48);
                      nw_protocol_error(v393, v282);
                      nw_protocol_disconnected(v393, v282);
                    }
                    else
                    {
                      *(void *)(v282 + 64) = v369;
                      nw_webtransport_metadata_set_stream_id(*(void **)(v282 + 160), v369);
                      if ((*(unsigned char *)(v282 + 276) & 0x10) == 0)
                      {
                        v370 = __nwlog_obj();
                        if (os_log_type_enabled(v370, OS_LOG_TYPE_INFO))
                        {
                          uint64_t v371 = *(void *)(v282 + 88);
                          if (v371) {
                            int v372 = *(_DWORD *)(v371 + 460);
                          }
                          else {
                            int v372 = -1;
                          }
                          uint64_t v391 = *(void *)(v282 + 64);
                          *(_DWORD *)buf = 136448002;
                          *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_assign_stream_id";
                          *(_WORD *)&buf[12] = 2082;
                          *(void *)&buf[14] = v282 + 192;
                          *(_WORD *)&buf[22] = 2080;
                          uint64_t v539 = (uint64_t)" ";
                          *(_WORD *)v540 = 1024;
                          *(_DWORD *)&v540[2] = v372;
                          *(_WORD *)&v540[6] = 2048;
                          *(void *)&v540[8] = v391;
                          *(_WORD *)&v540[16] = 2048;
                          *(void *)&v540[18] = v391;
                          *(_WORD *)&v540[26] = 2048;
                          *(void *)&v540[28] = v282;
                          __int16 v541 = 1024;
                          int v542 = 1;
                          _os_log_impl(&dword_1830D4000, v370, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> Assigned stream ID: %llu to stream with protocol %p, incoming: %u", buf, 0x4Au);
                        }
                      }
                    }
                  }
                  else if ((*(unsigned char *)(v282 + 276) & 0x10) == 0)
                  {
                    if (gLogDatapath)
                    {
                      v366 = __nwlog_obj();
                      if (os_log_type_enabled(v366, OS_LOG_TYPE_DEBUG))
                      {
                        uint64_t v367 = *(void *)(v282 + 88);
                        if (v367) {
                          int v368 = *(_DWORD *)(v367 + 460);
                        }
                        else {
                          int v368 = -1;
                        }
                        uint64_t v486 = *(void *)(v282 + 64);
                        *(_DWORD *)buf = 136447490;
                        *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_assign_stream_id";
                        *(_WORD *)&buf[12] = 2082;
                        *(void *)&buf[14] = v282 + 192;
                        *(_WORD *)&buf[22] = 2080;
                        uint64_t v539 = (uint64_t)" ";
                        *(_WORD *)v540 = 1024;
                        *(_DWORD *)&v540[2] = v368;
                        *(_WORD *)&v540[6] = 2048;
                        *(void *)&v540[8] = v486;
                        *(_WORD *)&v540[16] = 2048;
                        *(void *)&v540[18] = v486;
                        _os_log_impl(&dword_1830D4000, v366, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Stream ID %llu already set, skipping", buf, 0x3Au);
                        well_known = v519;
                      }
                    }
                  }
                  uint64_t v394 = *(void *)(v282 + 64);
                  char v395 = *(unsigned char *)(v282 + 276);
                  if (v394 == -1)
                  {
                    if ((*(unsigned char *)(v282 + 276) & 0x10) == 0)
                    {
                      v399 = __nwlog_obj();
                      if (os_log_type_enabled(v399, OS_LOG_TYPE_ERROR))
                      {
                        uint64_t v400 = *(void *)(v282 + 88);
                        if (v400) {
                          int v401 = *(_DWORD *)(v400 + 460);
                        }
                        else {
                          int v401 = -1;
                        }
                        uint64_t v404 = *(void *)(v282 + 64);
                        *(_DWORD *)buf = 136447234;
                        *(void *)&uint8_t buf[4] = "nw_webtransport_stream_configure_metadata_with_stream_id";
                        *(_WORD *)&buf[12] = 2082;
                        *(void *)&buf[14] = v282 + 192;
                        *(_WORD *)&buf[22] = 2080;
                        uint64_t v539 = (uint64_t)" ";
                        *(_WORD *)v540 = 1024;
                        *(_DWORD *)&v540[2] = v401;
                        *(_WORD *)&v540[6] = 2048;
                        *(void *)&v540[8] = v404;
                        _os_log_impl(&dword_1830D4000, v399, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> Not configuring webtransport stream metadata with no stream ID set", buf, 0x30u);
                      }
                    }
                  }
                  else
                  {
                    *(unsigned char *)(v282 + 276) = v395 & 0xF0 | (4 * ((v394 & 2) != 0)) | 3;
                    if ((v395 & 0x10) == 0)
                    {
                      v396 = __nwlog_obj();
                      if (os_log_type_enabled(v396, OS_LOG_TYPE_INFO))
                      {
                        uint64_t v397 = *(void *)(v282 + 88);
                        if (v397) {
                          int v398 = *(_DWORD *)(v397 + 460);
                        }
                        else {
                          int v398 = -1;
                        }
                        uint64_t v402 = *(void *)(v282 + 64);
                        unsigned int v403 = *(unsigned __int8 *)(v282 + 276);
                        *(_DWORD *)buf = 136448002;
                        *(void *)&uint8_t buf[4] = "nw_webtransport_stream_configure_metadata_with_stream_id";
                        *(_WORD *)&buf[12] = 2082;
                        *(void *)&buf[14] = v282 + 192;
                        *(_WORD *)&buf[22] = 2080;
                        uint64_t v539 = (uint64_t)" ";
                        *(_WORD *)v540 = 1024;
                        *(_DWORD *)&v540[2] = v398;
                        *(_WORD *)&v540[6] = 2048;
                        *(void *)&v540[8] = v402;
                        *(_WORD *)&v540[16] = 1024;
                        *(_DWORD *)&v540[18] = (v403 >> 1) & 1;
                        *(_WORD *)&v540[22] = 1024;
                        *(_DWORD *)&v540[24] = (v403 >> 3) & 1;
                        *(_WORD *)&v540[28] = 1024;
                        *(_DWORD *)&v540[30] = (v403 >> 2) & 1;
                        _os_log_impl(&dword_1830D4000, v396, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> Configuring metadata with flags: peer_initiated: %u, datagram: %u, unidirectional: %u", buf, 0x42u);
                      }
                    }
                    nw_webtransport_metadata_set_is_peer_initiated(*(void **)(v282 + 160), (*(unsigned char *)(v282 + 276) & 2) != 0);
                    nw_webtransport_metadata_set_is_datagram(*(void **)(v282 + 160), (*(unsigned char *)(v282 + 276) & 8) != 0);
                    nw_webtransport_metadata_set_is_unidirectional(*(void **)(v282 + 160), (*(unsigned char *)(v282 + 276) & 4) != 0);
                  }
                }
                if ((*(unsigned char *)(v282 + 276) & 0x40) != 0) {
                  goto LABEL_603;
                }
              }
              else
              {
                if (nw_protocol_options_is_webtransport(v339))
                {
                  *(unsigned char *)(v282 + 276) = *(unsigned char *)(v282 + 276) & 0xFC | 1;
                  if (nw_webtransport_options_get_is_datagram(v339)) {
                    char v340 = 8;
                  }
                  else {
                    char v340 = 0;
                  }
                  *(unsigned char *)(v282 + 276) = *(unsigned char *)(v282 + 276) & 0xF7 | v340;
                  BOOL v341 = nw_webtransport_options_get_is_unidirectional(v339);
                  char v342 = *(unsigned char *)(v282 + 276);
                  if (v341) {
                    char v343 = 4;
                  }
                  else {
                    char v343 = 0;
                  }
                  *(unsigned char *)(v282 + 276) = v342 & 0xFB | v343;
                  if ((v342 & 0x10) == 0)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    v344 = gLogObj;
                    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
                    {
                      uint64_t v345 = *(void *)(v282 + 88);
                      if (v345) {
                        int v346 = *(_DWORD *)(v345 + 460);
                      }
                      else {
                        int v346 = -1;
                      }
                      uint64_t v375 = *(void *)(v282 + 64);
                      unsigned int v376 = *(unsigned __int8 *)(v282 + 276);
                      *(_DWORD *)buf = 136448002;
                      *(void *)&uint8_t buf[4] = "nw_webtransport_stream_configure_metadata_with_options";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&buf[14] = v282 + 192;
                      *(_WORD *)&buf[22] = 2080;
                      uint64_t v539 = (uint64_t)" ";
                      *(_WORD *)v540 = 1024;
                      *(_DWORD *)&v540[2] = v346;
                      *(_WORD *)&v540[6] = 2048;
                      *(void *)&v540[8] = v375;
                      *(_WORD *)&v540[16] = 1024;
                      *(_DWORD *)&v540[18] = (v376 >> 1) & 1;
                      *(_WORD *)&v540[22] = 1024;
                      *(_DWORD *)&v540[24] = (v376 >> 3) & 1;
                      *(_WORD *)&v540[28] = 1024;
                      *(_DWORD *)&v540[30] = (v376 >> 2) & 1;
                      _os_log_impl(&dword_1830D4000, v344, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> Configuring metadata with flags: peer_initiated: %u, datagram: %u, unidirectional: %u", buf, 0x42u);
                    }
                  }
                  nw_webtransport_metadata_set_is_peer_initiated(*(void **)(v282 + 160), (*(unsigned char *)(v282 + 276) & 2) != 0);
                  nw_webtransport_metadata_set_is_datagram(*(void **)(v282 + 160), (*(unsigned char *)(v282 + 276) & 8) != 0);
                  nw_webtransport_metadata_set_is_unidirectional(*(void **)(v282 + 160), (*(unsigned char *)(v282 + 276) & 4) != 0);
LABEL_554:
                  if ((*(unsigned char *)(v282 + 276) & 8) == 0) {
                    goto LABEL_555;
                  }
LABEL_575:
                  nw_protocol_connected((void *)v282, v327);
LABEL_603:
                  uint64_t v405 = *(void *)(v327 + 32);
                  if (v405)
                  {
                    if ((*(unsigned char *)(v327 + 548) & 0x40) == 0)
                    {
                      if (!nw_protocol_add_input_handler(*(void *)(v327 + 32), v282)) {
                        goto LABEL_701;
                      }
LABEL_633:
                      if (*(void *)(v282 + 32))
                      {
                        uint64_t v425 = *(void *)(v282 + 176);
                        v426 = *(void **)(v327 + 392);
                        uint64_t v527 = MEMORY[0x1E4F143A8];
                        uint64_t v528 = 0x40000000;
                        v529 = ___ZL50nw_webtransport_http3_stream_reconfigure_and_startP22nw_webtransport_streamb_block_invoke;
                        v530 = &unk_1E52403E8;
                        uint64_t v531 = v425;
                        nw_queue_context_async(v426, &v527);
                        os_log_type_t v31 = (void **)(NWConcrete_nw_resolution_report + 16);
                        goto LABEL_709;
                      }
LABEL_701:
                      os_log_type_t v31 = (void **)(NWConcrete_nw_resolution_report + 16);
                      if ((*(unsigned char *)(v282 + 276) & 0x10) == 0)
                      {
                        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                        networkd_settings_init();
                        uint64_t v481 = gLogObj;
                        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                        {
                          uint64_t v482 = *(void *)(v282 + 88);
                          if (v482) {
                            int v483 = *(_DWORD *)(v482 + 460);
                          }
                          else {
                            int v483 = -1;
                          }
                          uint64_t v484 = *(void *)(v282 + 64);
                          *(_DWORD *)buf = 136447234;
                          *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
                          *(_WORD *)&buf[12] = 2082;
                          *(void *)&buf[14] = v282 + 192;
                          *(_WORD *)&buf[22] = 2080;
                          uint64_t v539 = (uint64_t)" ";
                          *(_WORD *)v540 = 1024;
                          *(_DWORD *)&v540[2] = v483;
                          *(_WORD *)&v540[6] = 2048;
                          *(void *)&v540[8] = v484;
                          v389 = v481;
                          v390 = "%{public}s %{public}s%s<i%u:s%lld> no http3 output handler for webtransport http3 stream";
                          goto LABEL_707;
                        }
                      }
                      goto LABEL_708;
                    }
                    v520 = v339;
                    v406 = (void *)nw_protocol_get_parameters(v282);
                    if (v406)
                    {
                      v407 = v406;
                      nw_parameters_log_protocol_instances(v406);
                      v408 = v407;
                      v409 = v408[19];

                      *(void *)os_log_type_t type = 0;
                      v535 = type;
                      uint64_t v536 = 0x2000000000;
                      char v537 = 0;
                      *(void *)buf = 0;
                      *(void *)&buf[8] = buf;
                      *(void *)&buf[16] = 0x3802000000;
                      uint64_t v539 = (uint64_t)__Block_byref_object_copy__33867;
                      *(void *)v540 = __Block_byref_object_dispose__33868;
                      *(void *)&v540[8] = 0;
                      v540[16] |= 1u;
                      *(void *)iterate_block = MEMORY[0x1E4F143A8];
                      *(void *)&iterate_block[8] = 0x40000000;
                      *(void *)&iterate_block[16] = ___ZL45nw_webtransport_session_add_to_http_messagingP23nw_webtransport_sessionP11nw_protocolS2__block_invoke;
                      v548 = (const char *)&unk_1E5240430;
                      v549 = type;
                      v550 = buf;
                      uint64_t v551 = v282;
                      nw_protocol_stack_iterate_application_protocols(v409, iterate_block);
                      v410 = *(void **)(*(void *)&buf[8] + 40);
                      if (v410)
                      {
                        if (nw_protocol_copy_http_messaging_definition_onceToken != -1) {
                          dispatch_once(&nw_protocol_copy_http_messaging_definition_onceToken, &__block_literal_global_81);
                        }
                        id v411 = (id)nw_protocol_copy_http_messaging_definition_definition;
                        v412 = v410;
                        v412[2] = v405;

                        if (v411) {
                          os_release(v411);
                        }
                        v413 = (void *)nw_protocol_get_parameters(v405);
                        if (v413)
                        {
                          v414 = v413;
                          v415 = v414[19];

                          v416 = v408;
                          v417 = v408[19];

                          v418 = nw_protocol_stack_copy_transport_protocol(v415);
                          nw_protocol_options_t v419 = nw_protocol_stack_copy_transport_protocol(v417);
                          nw_protocol_options_t v420 = v419;
                          if (v418)
                          {
                            if (v419)
                            {
                              nw_protocol_definition_t v421 = nw_protocol_options_copy_definition(v418);
                              if (nw_protocol_options_matches_definition(v420, v421))
                              {
                                uint64_t v422 = nw_protocol_options_get_protocol_handle(v418);
                                nw_parameters_set_protocol_instance(v420, v423, v422);
                              }
                              os_release(v420);
                            }
                            nw_protocol_options_t v420 = v418;
LABEL_621:
                            os_release(v420);
                          }
                          else if (v419)
                          {
                            goto LABEL_621;
                          }
                          well_known = v519;
                          if (v417) {
                            os_release(v417);
                          }
                          if (v415) {
                            os_release(v415);
                          }
                        }
                        nw_protocol_set_output_handler(v282, 0);
                        char v424 = nw_protocol_add_input_handler(v405, v282);
LABEL_627:
                        _Block_object_dispose(buf, 8);
                        if ((v540[16] & 1) != 0 && *(void *)&v540[8]) {
                          os_release(*(void **)&v540[8]);
                        }
                        _Block_object_dispose(type, 8);
                        if (v409) {
                          os_release(v409);
                        }
                        v339 = v520;
                        if (v424) {
                          goto LABEL_633;
                        }
                        goto LABEL_701;
                      }
                      __nwlog_obj();
                      *(_DWORD *)v543 = 136446210;
                      v544 = "nw_webtransport_session_add_to_http_messaging";
                      v455 = (char *)_os_log_send_and_compose_impl();
                      os_log_type_t v533 = OS_LOG_TYPE_ERROR;
                      char v532 = 0;
                      if (!__nwlog_fault(v455, &v533, &v532)) {
                        goto LABEL_714;
                      }
                      if (v533 == OS_LOG_TYPE_FAULT)
                      {
                        v456 = __nwlog_obj();
                        os_log_type_t v457 = v533;
                        if (os_log_type_enabled(v456, v533))
                        {
                          *(_DWORD *)v543 = 136446210;
                          v544 = "nw_webtransport_session_add_to_http_messaging";
                          v458 = v456;
                          os_log_type_t v459 = v457;
                          v460 = "%{public}s called with null options";
                          goto LABEL_713;
                        }
                        goto LABEL_714;
                      }
                      if (v532)
                      {
                        v469 = (char *)__nw_create_backtrace_string();
                        v470 = __nwlog_obj();
                        os_log_type_t v471 = v533;
                        BOOL v472 = os_log_type_enabled(v470, v533);
                        if (v469)
                        {
                          if (v472)
                          {
                            *(_DWORD *)v543 = 136446466;
                            v544 = "nw_webtransport_session_add_to_http_messaging";
                            __int16 v545 = 2082;
                            v546 = v469;
                            _os_log_impl(&dword_1830D4000, v470, v471, "%{public}s called with null options, dumping backtrace:%{public}s", v543, 0x16u);
                          }
                          free(v469);
                          goto LABEL_714;
                        }
                        if (!v472)
                        {
LABEL_714:
                          if (v455) {
                            free(v455);
                          }
                          char v424 = 0;
                          well_known = v519;
                          goto LABEL_627;
                        }
                        *(_DWORD *)v543 = 136446210;
                        v544 = "nw_webtransport_session_add_to_http_messaging";
                        v458 = v470;
                        os_log_type_t v459 = v471;
                        v460 = "%{public}s called with null options, no backtrace";
                      }
                      else
                      {
                        v479 = __nwlog_obj();
                        os_log_type_t v480 = v533;
                        if (!os_log_type_enabled(v479, v533)) {
                          goto LABEL_714;
                        }
                        *(_DWORD *)v543 = 136446210;
                        v544 = "nw_webtransport_session_add_to_http_messaging";
                        v458 = v479;
                        os_log_type_t v459 = v480;
                        v460 = "%{public}s called with null options, backtrace limit exceeded";
                      }
LABEL_713:
                      _os_log_impl(&dword_1830D4000, v458, v459, v460, v543, 0xCu);
                      goto LABEL_714;
                    }
                    __nwlog_obj();
                    *(_DWORD *)buf = 136446210;
                    *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_http_messaging";
                    v449 = (char *)_os_log_send_and_compose_impl();
                    type[0] = OS_LOG_TYPE_ERROR;
                    v543[0] = 0;
                    if (!__nwlog_fault(v449, type, v543)) {
                      goto LABEL_698;
                    }
                    if (type[0] == OS_LOG_TYPE_FAULT)
                    {
                      v450 = __nwlog_obj();
                      os_log_type_t v451 = type[0];
                      if (os_log_type_enabled(v450, type[0]))
                      {
                        *(_DWORD *)buf = 136446210;
                        *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_http_messaging";
                        v452 = v450;
                        os_log_type_t v453 = v451;
                        v454 = "%{public}s called with null parameters";
                        goto LABEL_697;
                      }
                      goto LABEL_698;
                    }
                    if (v543[0])
                    {
                      v465 = (char *)__nw_create_backtrace_string();
                      v466 = __nwlog_obj();
                      os_log_type_t v467 = type[0];
                      BOOL v468 = os_log_type_enabled(v466, type[0]);
                      if (v465)
                      {
                        if (v468)
                        {
                          *(_DWORD *)buf = 136446466;
                          *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_http_messaging";
                          *(_WORD *)&buf[12] = 2082;
                          *(void *)&buf[14] = v465;
                          _os_log_impl(&dword_1830D4000, v466, v467, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
                        }
                        free(v465);
                        goto LABEL_698;
                      }
                      if (!v468)
                      {
LABEL_698:
                        if (v449) {
                          free(v449);
                        }
                        well_known = v519;
                        v339 = v520;
                        goto LABEL_701;
                      }
                      *(_DWORD *)buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_http_messaging";
                      v452 = v466;
                      os_log_type_t v453 = v467;
                      v454 = "%{public}s called with null parameters, no backtrace";
                    }
                    else
                    {
                      v477 = __nwlog_obj();
                      os_log_type_t v478 = type[0];
                      if (!os_log_type_enabled(v477, type[0])) {
                        goto LABEL_698;
                      }
                      *(_DWORD *)buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_http_messaging";
                      v452 = v477;
                      os_log_type_t v453 = v478;
                      v454 = "%{public}s called with null parameters, backtrace limit exceeded";
                    }
LABEL_697:
                    _os_log_impl(&dword_1830D4000, v452, v453, v454, buf, 0xCu);
                    goto LABEL_698;
                  }
                  v439 = v339;
                  __nwlog_obj();
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_transport";
                  v440 = (char *)_os_log_send_and_compose_impl();
                  iterate_block[0] = 16;
                  type[0] = OS_LOG_TYPE_DEFAULT;
                  if (!__nwlog_fault(v440, iterate_block, type)) {
                    goto LABEL_686;
                  }
                  if (iterate_block[0] == 17)
                  {
                    v441 = __nwlog_obj();
                    os_log_type_t v442 = iterate_block[0];
                    if (os_log_type_enabled(v441, (os_log_type_t)iterate_block[0]))
                    {
                      *(_DWORD *)buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_transport";
                      v443 = v441;
                      os_log_type_t v444 = v442;
                      v445 = "%{public}s called with null transport_protocol";
                      goto LABEL_685;
                    }
                    goto LABEL_686;
                  }
                  if (type[0])
                  {
                    v461 = (char *)__nw_create_backtrace_string();
                    v462 = __nwlog_obj();
                    os_log_type_t v463 = iterate_block[0];
                    BOOL v464 = os_log_type_enabled(v462, (os_log_type_t)iterate_block[0]);
                    if (v461)
                    {
                      if (v464)
                      {
                        *(_DWORD *)buf = 136446466;
                        *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_transport";
                        *(_WORD *)&buf[12] = 2082;
                        *(void *)&buf[14] = v461;
                        _os_log_impl(&dword_1830D4000, v462, v463, "%{public}s called with null transport_protocol, dumping backtrace:%{public}s", buf, 0x16u);
                      }
                      free(v461);
                      goto LABEL_686;
                    }
                    if (!v464)
                    {
LABEL_686:
                      if (v440) {
                        free(v440);
                      }
                      well_known = v519;
                      v339 = v439;
                      goto LABEL_701;
                    }
                    *(_DWORD *)buf = 136446210;
                    *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_transport";
                    v443 = v462;
                    os_log_type_t v444 = v463;
                    v445 = "%{public}s called with null transport_protocol, no backtrace";
                  }
                  else
                  {
                    v474 = __nwlog_obj();
                    os_log_type_t v475 = iterate_block[0];
                    if (!os_log_type_enabled(v474, (os_log_type_t)iterate_block[0])) {
                      goto LABEL_686;
                    }
                    *(_DWORD *)buf = 136446210;
                    *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_transport";
                    v443 = v474;
                    os_log_type_t v444 = v475;
                    v445 = "%{public}s called with null transport_protocol, backtrace limit exceeded";
                  }
LABEL_685:
                  _os_log_impl(&dword_1830D4000, v443, v444, v445, buf, 0xCu);
                  goto LABEL_686;
                }
                if ((*(unsigned char *)(v282 + 276) & 0x10) != 0) {
                  goto LABEL_554;
                }
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v359 = gLogObj;
                if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_554;
                }
                uint64_t v360 = *(void *)(v282 + 88);
                if (v360) {
                  int v361 = *(_DWORD *)(v360 + 460);
                }
                else {
                  int v361 = -1;
                }
                uint64_t v384 = *(void *)(v282 + 64);
                *(_DWORD *)buf = 136447234;
                *(void *)&uint8_t buf[4] = "nw_webtransport_stream_configure_metadata_with_options";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v282 + 192;
                *(_WORD *)&buf[22] = 2080;
                uint64_t v539 = (uint64_t)" ";
                *(_WORD *)v540 = 1024;
                *(_DWORD *)&v540[2] = v361;
                *(_WORD *)&v540[6] = 2048;
                *(void *)&v540[8] = v384;
                _os_log_impl(&dword_1830D4000, v359, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> Invalid protocol options for webtransport stream", buf, 0x30u);
                if ((*(unsigned char *)(v282 + 276) & 8) != 0) {
                  goto LABEL_575;
                }
LABEL_555:
                nw_protocol_set_output_handler(v282, 0);
                *(void *)(v282 + 56) = 0;
                if (!*(void *)(v327 + 376))
                {
                  os_log_type_t v31 = (void **)(NWConcrete_nw_resolution_report + 16);
                  if ((*(unsigned char *)(v282 + 276) & 0x10) == 0)
                  {
                    v377 = __nwlog_obj();
                    if (os_log_type_enabled(v377, OS_LOG_TYPE_ERROR))
                    {
                      uint64_t v378 = *(void *)(v282 + 88);
                      if (v378) {
                        int v379 = *(_DWORD *)(v378 + 460);
                      }
                      else {
                        int v379 = -1;
                      }
                      uint64_t v388 = *(void *)(v282 + 64);
                      *(_DWORD *)buf = 136447234;
                      *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&buf[14] = v282 + 192;
                      *(_WORD *)&buf[22] = 2080;
                      uint64_t v539 = (uint64_t)" ";
                      *(_WORD *)v540 = 1024;
                      *(_DWORD *)&v540[2] = v379;
                      *(_WORD *)&v540[6] = 2048;
                      *(void *)&v540[8] = v388;
                      v389 = v377;
                      v390 = "%{public}s %{public}s%s<i%u:s%lld> no http connection metadata when attempting to start web"
                             "transport http3 stream";
LABEL_707:
                      _os_log_impl(&dword_1830D4000, v389, OS_LOG_TYPE_ERROR, v390, buf, 0x30u);
                    }
                  }
LABEL_708:
                  v485 = *(void **)(v282 + 48);
                  nw_protocol_error(v485, v282);
                  nw_protocol_disconnected(v485, v282);
LABEL_709:
                  os_release(v339);
                  uint64_t v282 = *(void *)(v13 + 328);
                  if (!v282) {
                    goto LABEL_719;
                  }
                  goto LABEL_568;
                }
                if ((*(unsigned char *)(v282 + 276) & 0x40) != 0) {
                  goto LABEL_603;
                }
              }
              nw_webtransport_http3_stream_fix_http_parameters(v327, v282);
              goto LABEL_603;
            }
            os_log_type_t v31 = (void **)(NWConcrete_nw_resolution_report + 16);
            if ((*(unsigned char *)(v282 + 276) & 0x10) != 0) {
              goto LABEL_567;
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v350 = gLogObj;
            if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
              goto LABEL_567;
            }
            uint64_t v351 = *(void *)(v282 + 88);
            if (v351) {
              int v352 = *(_DWORD *)(v351 + 460);
            }
            else {
              int v352 = -1;
            }
            uint64_t v364 = *(void *)(v282 + 64);
            *(_DWORD *)buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v282 + 192;
            *(_WORD *)&buf[22] = 2080;
            uint64_t v539 = (uint64_t)" ";
            *(_WORD *)v540 = 1024;
            *(_DWORD *)&v540[2] = v352;
            *(_WORD *)&v540[6] = 2048;
            *(void *)&v540[8] = v364;
            _os_log_impl(&dword_1830D4000, v350, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> Could not find options for stream when reconfiguring", buf, 0x30u);
            uint64_t v282 = *(void *)(v13 + 328);
            if (!v282) {
              goto LABEL_719;
            }
          }
LABEL_568:
          if ((*(unsigned char *)(v282 + 276) & 0x10) == 0)
          {
            if (*((unsigned char *)v31 + 3665))
            {
              v381 = __nwlog_obj();
              if (os_log_type_enabled(v381, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v382 = *(void *)(v282 + 88);
                if (v382) {
                  int v383 = *(_DWORD *)(v382 + 460);
                }
                else {
                  int v383 = -1;
                }
                uint64_t v435 = *(void *)(v282 + 64);
                *(_DWORD *)buf = 136447490;
                *(void *)&uint8_t buf[4] = "nw_webtransport_session_get_next_pending_stream";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v282 + 192;
                *(_WORD *)&buf[22] = 2080;
                uint64_t v539 = (uint64_t)" ";
                *(_WORD *)v540 = 1024;
                *(_DWORD *)&v540[2] = v383;
                *(_WORD *)&v540[6] = 2048;
                *(void *)&v540[8] = v435;
                *(_WORD *)&v540[16] = 2048;
                *(void *)&v540[18] = v282;
                _os_log_impl(&dword_1830D4000, v381, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> found stream (%p)", buf, 0x3Au);
              }
            }
          }
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v296 = *(unsigned int *)(v13 + 456);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = "webtransport_session->pending_stream_count";
        *(_WORD *)&buf[22] = 2048;
        uint64_t v539 = 1;
        *(_WORD *)v540 = 2048;
        *(void *)&v540[2] = v296;
        v297 = (char *)_os_log_send_and_compose_impl();
        iterate_block[0] = 16;
        LOBYTE(v527) = 0;
        if (__nwlog_fault(v297, iterate_block, &v527))
        {
          if (iterate_block[0] == 17)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v298 = gLogObj;
            os_log_type_t v299 = iterate_block[0];
            if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0]))
            {
              uint64_t v300 = *(unsigned int *)(v13 + 456);
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = "webtransport_session->pending_stream_count";
              *(_WORD *)&buf[22] = 2048;
              uint64_t v539 = 1;
              *(_WORD *)v540 = 2048;
              *(void *)&v540[2] = v300;
              v301 = v298;
              os_log_type_t v302 = v299;
              v303 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_445:
              _os_log_impl(&dword_1830D4000, v301, v302, v303, buf, 0x2Au);
            }
          }
          else if ((_BYTE)v527)
          {
            v306 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v307 = gLogObj;
            os_log_type_t v308 = iterate_block[0];
            BOOL v309 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0]);
            if (v306)
            {
              if (v309)
              {
                uint64_t v310 = *(unsigned int *)(v13 + 456);
                *(_DWORD *)buf = 136447234;
                *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = "webtransport_session->pending_stream_count";
                *(_WORD *)&buf[22] = 2048;
                uint64_t v539 = 1;
                *(_WORD *)v540 = 2048;
                *(void *)&v540[2] = v310;
                *(_WORD *)&v540[10] = 2082;
                *(void *)&v540[12] = v306;
                _os_log_impl(&dword_1830D4000, v307, v308, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
              }
              free(v306);
              goto LABEL_446;
            }
            if (v309)
            {
              uint64_t v314 = *(unsigned int *)(v13 + 456);
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = "webtransport_session->pending_stream_count";
              *(_WORD *)&buf[22] = 2048;
              uint64_t v539 = 1;
              *(_WORD *)v540 = 2048;
              *(void *)&v540[2] = v314;
              v301 = v307;
              os_log_type_t v302 = v308;
              v303 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
              goto LABEL_445;
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v311 = gLogObj;
            os_log_type_t v312 = iterate_block[0];
            if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0]))
            {
              uint64_t v313 = *(unsigned int *)(v13 + 456);
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = "webtransport_session->pending_stream_count";
              *(_WORD *)&buf[22] = 2048;
              uint64_t v539 = 1;
              *(_WORD *)v540 = 2048;
              *(void *)&v540[2] = v313;
              v301 = v311;
              os_log_type_t v302 = v312;
              v303 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
              goto LABEL_445;
            }
          }
        }
LABEL_446:
        if (v297) {
          free(v297);
        }
        *(_DWORD *)(v13 + 456) = 0;
        goto LABEL_449;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_request";
      v488 = (char *)_os_log_send_and_compose_impl();
      iterate_block[0] = 16;
      LOBYTE(v527) = 0;
      if (!__nwlog_fault(v488, iterate_block, &v527)) {
        goto LABEL_780;
      }
      if (iterate_block[0] == 17)
      {
        v489 = __nwlog_obj();
        os_log_type_t v490 = iterate_block[0];
        if (!os_log_type_enabled(v489, (os_log_type_t)iterate_block[0])) {
          goto LABEL_780;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_request";
        v491 = "%{public}s called with null request";
        goto LABEL_778;
      }
      if (!(_BYTE)v527)
      {
        v489 = __nwlog_obj();
        os_log_type_t v490 = iterate_block[0];
        if (!os_log_type_enabled(v489, (os_log_type_t)iterate_block[0])) {
          goto LABEL_780;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_request";
        v491 = "%{public}s called with null request, backtrace limit exceeded";
        goto LABEL_778;
      }
      v504 = (char *)__nw_create_backtrace_string();
      v501 = __nwlog_obj();
      os_log_type_t v502 = iterate_block[0];
      BOOL v508 = os_log_type_enabled(v501, (os_log_type_t)iterate_block[0]);
      if (!v504)
      {
        if (v508)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_request";
          v491 = "%{public}s called with null request, no backtrace";
          goto LABEL_793;
        }
        goto LABEL_780;
      }
      if (!v508) {
        goto LABEL_768;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_request";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v504;
      v506 = "%{public}s called with null request, dumping backtrace:%{public}s";
    }
    else
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_request";
      v488 = (char *)_os_log_send_and_compose_impl();
      iterate_block[0] = 16;
      LOBYTE(v527) = 0;
      if (!__nwlog_fault(v488, iterate_block, &v527)) {
        goto LABEL_780;
      }
      if (iterate_block[0] == 17)
      {
        v489 = __nwlog_obj();
        os_log_type_t v490 = iterate_block[0];
        if (!os_log_type_enabled(v489, (os_log_type_t)iterate_block[0])) {
          goto LABEL_780;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_request";
        v491 = "%{public}s called with null nw_protocol_metadata_is_http(metadata)";
        goto LABEL_778;
      }
      if (!(_BYTE)v527)
      {
        v489 = __nwlog_obj();
        os_log_type_t v490 = iterate_block[0];
        if (!os_log_type_enabled(v489, (os_log_type_t)iterate_block[0])) {
          goto LABEL_780;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_request";
        v491 = "%{public}s called with null nw_protocol_metadata_is_http(metadata), backtrace limit exceeded";
        goto LABEL_778;
      }
      v504 = (char *)__nw_create_backtrace_string();
      v501 = __nwlog_obj();
      os_log_type_t v502 = iterate_block[0];
      BOOL v505 = os_log_type_enabled(v501, (os_log_type_t)iterate_block[0]);
      if (!v504)
      {
        if (!v505) {
          goto LABEL_780;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_request";
        v491 = "%{public}s called with null nw_protocol_metadata_is_http(metadata), no backtrace";
        goto LABEL_793;
      }
      if (!v505) {
        goto LABEL_768;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_request";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v504;
      v506 = "%{public}s called with null nw_protocol_metadata_is_http(metadata), dumping backtrace:%{public}s";
    }
LABEL_767:
    _os_log_impl(&dword_1830D4000, v501, v502, v506, buf, 0x16u);
LABEL_768:
    free(v504);
    if (!v488) {
      goto LABEL_724;
    }
    goto LABEL_781;
  }
  if (!v13 || (*(unsigned char *)(v13 + 548) & 2) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v25 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      uint64_t v26 = *(void *)(a1 + 40);
      int v27 = (const char *)(v26 + 464);
      int v28 = "";
      BOOL v29 = v26 == 0;
      int v30 = *(_DWORD *)(v26 + 460);
      if (v29) {
        int v27 = "";
      }
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_http_get_input_block_invoke";
      *(_WORD *)&buf[12] = 2082;
      *(_DWORD *)buf = 136446978;
      if (!v29) {
        int v28 = " ";
      }
      *(void *)&buf[14] = v27;
      *(_WORD *)&buf[22] = 2080;
      uint64_t v539 = (uint64_t)v28;
      *(_WORD *)v540 = 1024;
      *(_DWORD *)&v540[2] = v30;
      _os_log_impl(&dword_1830D4000, v25, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> Received unexpected input frame without HTTP metadata", buf, 0x26u);
    }
  }
  nw_frame_finalize((uint64_t)a2);
  return 1;
}

id nw_http_metadata_copy_request(void *a1)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = nw_protocol_metadata_copy_definition(v1);
    if (nw_protocol_copy_http_definition_onceToken != -1) {
      dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_15_74223);
    }
    BOOL is_equal = nw_protocol_definition_is_equal(v3, (nw_protocol_definition_t)nw_protocol_copy_http_definition_http_definition);

    if (is_equal)
    {
      *(void *)buf = 0;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x3032000000;
      uint64_t v26 = __Block_byref_object_copy__5_73857;
      int v27 = __Block_byref_object_dispose__6_73858;
      id v28 = 0;
      v22[0] = MEMORY[0x1E4F143A8];
      v22[1] = 3221225472;
      v22[2] = __nw_http_metadata_copy_request_block_invoke;
      v22[3] = &unk_1E5248E90;
      v22[4] = buf;
      uint64_t isa = (uint64_t)v2[4].isa;
      if (isa)
      {
        __nw_http_metadata_copy_request_block_invoke((uint64_t)v22, isa);
        uint64_t v6 = *(void **)(*(void *)&buf[8] + 40);
      }
      else
      {
        uint64_t v6 = 0;
      }
      id v7 = v6;
      _Block_object_dispose(buf, 8);

      goto LABEL_9;
    }
    uint64_t v13 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_request";
    BOOL v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v10, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v11 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_request";
          _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s metadata must be http", buf, 0xCu);
        }
LABEL_41:

        goto LABEL_42;
      }
      if (!v23)
      {
        int v11 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_request";
          _os_log_impl(&dword_1830D4000, v11, v21, "%{public}s metadata must be http, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_41;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v11 = __nwlog_obj();
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_request";
          _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s metadata must be http, no backtrace", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_request";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s metadata must be http, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_29;
    }
  }
  else
  {
    int v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_request";
    BOOL v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v10, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_request";
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null metadata", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (!v23)
      {
        int v11 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_request";
          _os_log_impl(&dword_1830D4000, v11, v20, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_41;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_request";
          _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_request";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_29:

      free(backtrace_string);
    }
  }
LABEL_42:
  if (v10) {
    free(v10);
  }
  id v7 = 0;
LABEL_9:

  return v7;
}

uint64_t tcp_connection_multipath_get_subflow_count(void *a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v5 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v20 = "tcp_connection_multipath_get_subflow_count";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v6, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v7 = (id)gLogObj;
        os_log_type_t v8 = type;
        if (!os_log_type_enabled(v7, type)) {
          goto LABEL_24;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "tcp_connection_multipath_get_subflow_count";
        int v9 = "%{public}s called with null connection";
LABEL_22:
        id v15 = v7;
        os_log_type_t v16 = v8;
        goto LABEL_23;
      }
      if (!v17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v7 = (id)gLogObj;
        os_log_type_t v8 = type;
        if (!os_log_type_enabled(v7, type)) {
          goto LABEL_24;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "tcp_connection_multipath_get_subflow_count";
        int v9 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_22;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v7 = (id)gLogObj;
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (!v13)
        {
LABEL_24:

          if (!v6) {
            goto LABEL_18;
          }
          goto LABEL_17;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "tcp_connection_multipath_get_subflow_count";
        int v9 = "%{public}s called with null connection, no backtrace";
        id v15 = v7;
        os_log_type_t v16 = v12;
LABEL_23:
        _os_log_impl(&dword_1830D4000, v15, v16, v9, buf, 0xCu);
        goto LABEL_24;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v20 = "tcp_connection_multipath_get_subflow_count";
        __int16 v21 = 2082;
        char v22 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    if (!v6)
    {
LABEL_18:
      uint64_t subflow_count = 0;
      goto LABEL_19;
    }
LABEL_17:
    free(v6);
    goto LABEL_18;
  }
  id v3 = (void *)*((void *)v1 + 2);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v10 = (id)gLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v20 = "tcp_connection_multipath_get_subflow_count";
      _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_ERROR, "%{public}s API Misuse: Function must be called after tcp_connection_start", buf, 0xCu);
    }

    goto LABEL_18;
  }
  uint64_t subflow_count = nw_connection_multipath_get_subflow_count(v3);
LABEL_19:

  return subflow_count;
}

uint64_t tcp_connection_get_remote(void *a1, void *a2)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  uint64_t v4 = v3;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v15 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v34 = "tcp_connection_get_remote";
    os_log_type_t v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (!__nwlog_fault(v16, &type, &v31)) {
      goto LABEL_33;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v17 = (id)gLogObj;
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v34 = "tcp_connection_get_remote";
        _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v31)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v17 = (id)gLogObj;
      os_log_type_t v21 = type;
      BOOL v22 = os_log_type_enabled(v17, type);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v34 = "tcp_connection_get_remote";
          __int16 v35 = 2082;
          uint64_t v36 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v17, v21, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (!v16) {
          goto LABEL_35;
        }
        goto LABEL_34;
      }
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v34 = "tcp_connection_get_remote";
        _os_log_impl(&dword_1830D4000, v17, v21, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v17 = (id)gLogObj;
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v34 = "tcp_connection_get_remote";
        _os_log_impl(&dword_1830D4000, v17, v23, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_32;
  }
  if (!v3[2])
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v19 = (id)gLogObj;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v34 = "tcp_connection_get_remote";
      _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_ERROR, "%{public}s API Misuse: Function must be called after tcp_connection_start", buf, 0xCu);
    }

    goto LABEL_35;
  }
  if (!a2)
  {
    int v25 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v34 = "tcp_connection_get_remote";
    os_log_type_t v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (__nwlog_fault(v16, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v17 = __nwlog_obj();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v34 = "tcp_connection_get_remote";
          _os_log_impl(&dword_1830D4000, v17, v26, "%{public}s called with null outremote", buf, 0xCu);
        }
LABEL_32:

        goto LABEL_33;
      }
      if (!v31)
      {
        char v17 = __nwlog_obj();
        os_log_type_t v30 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v34 = "tcp_connection_get_remote";
          _os_log_impl(&dword_1830D4000, v17, v30, "%{public}s called with null outremote, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_32;
      }
      int v27 = (char *)__nw_create_backtrace_string();
      char v17 = __nwlog_obj();
      os_log_type_t v28 = type;
      BOOL v29 = os_log_type_enabled(v17, type);
      if (!v27)
      {
        if (v29)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v34 = "tcp_connection_get_remote";
          _os_log_impl(&dword_1830D4000, v17, v28, "%{public}s called with null outremote, no backtrace", buf, 0xCu);
        }
        goto LABEL_32;
      }
      if (v29)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v34 = "tcp_connection_get_remote";
        __int16 v35 = 2082;
        uint64_t v36 = v27;
        _os_log_impl(&dword_1830D4000, v17, v28, "%{public}s called with null outremote, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(v27);
    }
LABEL_33:
    if (!v16)
    {
LABEL_35:
      uint64_t v14 = 0;
      goto LABEL_36;
    }
LABEL_34:
    free(v16);
    goto LABEL_35;
  }
  *a2 = 0;
  a2[1] = 0;
  *((_DWORD *)a2 + 6) = 0;
  a2[2] = 0;
  id v5 = nw_connection_copy_connected_remote_endpoint(v3[2]);
  uint64_t v6 = v5;
  if (v5)
  {
    id v7 = v5;
    int v8 = [v7 type];

    if (v8 == 1)
    {
      address = nw_endpoint_get_address(v7);
      if (address)
      {
        BOOL v10 = address;
        size_t sa_len = address->sa_len;
        if (sa_len < 0x1D)
        {
          memcpy(a2, address, sa_len);
          uint64_t v14 = 1;
          goto LABEL_12;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (id)gLogObj;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          int v13 = v10->sa_len;
          *(_DWORD *)buf = 136446466;
          uint64_t v34 = "tcp_connection_get_remote";
          __int16 v35 = 1024;
          LODWORD(v36) = v13;
          _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_ERROR, "%{public}s Remote address length (%u) too long", buf, 0x12u);
        }
      }
    }
  }
  uint64_t v14 = 0;
LABEL_12:

LABEL_36:
  return v14;
}

void sub_18345D840(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void tcp_connection_cancel(void *a1)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v2 = (id)gLogObj;
  id v3 = v2;
  if (!v1)
  {
    *(_DWORD *)buf = 136446210;
    int v32 = "tcp_connection_cancel";
    int v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (__nwlog_fault(v9, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v10 = (id)gLogObj;
        os_log_type_t v11 = type;
        if (!os_log_type_enabled(v10, type)) {
          goto LABEL_37;
        }
        *(_DWORD *)buf = 136446210;
        int v32 = "tcp_connection_cancel";
        os_log_type_t v12 = "%{public}s called with null connection";
LABEL_35:
        int v25 = v10;
        os_log_type_t v26 = v11;
        goto LABEL_36;
      }
      if (!v29)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v10 = (id)gLogObj;
        os_log_type_t v11 = type;
        if (!os_log_type_enabled(v10, type)) {
          goto LABEL_37;
        }
        *(_DWORD *)buf = 136446210;
        int v32 = "tcp_connection_cancel";
        os_log_type_t v12 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_35;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v10 = (id)gLogObj;
      os_log_type_t v23 = type;
      BOOL v24 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (!v24)
        {
LABEL_37:

          if (!v9) {
            goto LABEL_32;
          }
          goto LABEL_31;
        }
        *(_DWORD *)buf = 136446210;
        int v32 = "tcp_connection_cancel";
        os_log_type_t v12 = "%{public}s called with null connection, no backtrace";
        int v25 = v10;
        os_log_type_t v26 = v23;
LABEL_36:
        _os_log_impl(&dword_1830D4000, v25, v26, v12, buf, 0xCu);
        goto LABEL_37;
      }
      if (v24)
      {
        *(_DWORD *)buf = 136446466;
        int v32 = "tcp_connection_cancel";
        __int16 v33 = 2082;
        uint64_t v34 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v10, v23, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    if (!v9) {
      goto LABEL_32;
    }
LABEL_31:
    free(v9);
    goto LABEL_32;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v4 = (char *)*((void *)v1 + 12);
    *(_DWORD *)buf = 136446466;
    int v32 = "tcp_connection_cancel";
    __int16 v33 = 2048;
    uint64_t v34 = v4;
    _os_log_impl(&dword_1830D4000, v3, OS_LOG_TYPE_DEBUG, "%{public}s %llu", buf, 0x16u);
  }

  os_unfair_lock_lock((os_unfair_lock_t)v1 + 30);
  if (v1[156] == 255) {
    goto LABEL_24;
  }
  v1[156] = -1;
  id v5 = (const void *)*((void *)v1 + 9);
  if (v5 && *((void *)v1 + 7))
  {
    uint64_t v6 = _Block_copy(v5);
    id v7 = *((id *)v1 + 7);
    int v8 = *((void *)v1 + 2);
    if (!v8) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  uint64_t v6 = 0;
  id v7 = 0;
  int v8 = *((void *)v1 + 2);
  if (v8) {
LABEL_14:
  }
    nw_connection_cancel(v8);
LABEL_15:
  int v13 = v1;
  v13[158] |= 0x30u;
  uint64_t v14 = *((void *)v13 + 10);
  if (v14)
  {
    dispatch_source_cancel(v14);
    id v15 = (void *)*((void *)v13 + 10);
    *((void *)v13 + 10) = 0;
  }
  os_log_type_t v16 = (void *)*((void *)v13 + 11);
  *((void *)v13 + 11) = 0;

  int v17 = *((_DWORD *)v13 + 29);
  if (v17 != -1)
  {
    unsigned __int8 v18 = v13[159];
    if ((v18 & 8) == 0)
    {
      close(v17);
      unsigned __int8 v18 = v13[159];
    }
    *((_DWORD *)v13 + 29) = -1;
    v13[159] = v18 & 0xF7;
  }
  BOOL v19 = (void *)*((void *)v13 + 7);
  *((void *)v13 + 7) = 0;

  os_log_type_t v20 = (void *)*((void *)v13 + 8);
  *((void *)v13 + 8) = 0;

  os_log_type_t v21 = (void *)*((void *)v1 + 9);
  *((void *)v1 + 9) = 0;

  if (v6)
  {
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __tcp_connection_cancel_block_invoke;
    block[3] = &unk_1E524AFA8;
    id v28 = v6;
    dispatch_async(v7, block);
  }
LABEL_24:
  os_unfair_lock_unlock((os_unfair_lock_t)v1 + 30);
LABEL_32:
}

void nw_service_connector_start_request(void *a1, void *a2, const char *a3, void *a4, void *a5)
{
  v82[3] = *MEMORY[0x1E4F143B8];
  int v9 = a1;
  id v10 = a2;
  id v68 = a4;
  id v11 = a5;
  os_log_type_t v12 = v11;
  if (!v9)
  {
    os_log_type_t v44 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v78 = "nw_service_connector_start_request";
    os_log_type_t v45 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v75 = 0;
    if (!__nwlog_fault(v45, &type, &v75)) {
      goto LABEL_136;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint32_t v46 = __nwlog_obj();
      os_log_type_t v47 = type;
      if (os_log_type_enabled(v46, type))
      {
        *(_DWORD *)buf = 136446210;
        int v78 = "nw_service_connector_start_request";
        _os_log_impl(&dword_1830D4000, v46, v47, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }
    else if (v75)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint32_t v46 = __nwlog_obj();
      os_log_type_t v55 = type;
      BOOL v56 = os_log_type_enabled(v46, type);
      if (backtrace_string)
      {
        if (v56)
        {
          *(_DWORD *)buf = 136446466;
          int v78 = "nw_service_connector_start_request";
          __int16 v79 = 2082;
          size_t v80 = (size_t)backtrace_string;
          _os_log_impl(&dword_1830D4000, v46, v55, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_136:
        if (!v45) {
          goto LABEL_70;
        }
LABEL_137:
        free(v45);
        goto LABEL_70;
      }
      if (v56)
      {
        *(_DWORD *)buf = 136446210;
        int v78 = "nw_service_connector_start_request";
        _os_log_impl(&dword_1830D4000, v46, v55, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint32_t v46 = __nwlog_obj();
      os_log_type_t v64 = type;
      if (os_log_type_enabled(v46, type))
      {
        *(_DWORD *)buf = 136446210;
        int v78 = "nw_service_connector_start_request";
        _os_log_impl(&dword_1830D4000, v46, v64, "%{public}s called with null serviceConnector, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_135:

    goto LABEL_136;
  }
  if (!v10)
  {
    int v48 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v78 = "nw_service_connector_start_request";
    os_log_type_t v45 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v75 = 0;
    if (!__nwlog_fault(v45, &type, &v75)) {
      goto LABEL_136;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint32_t v46 = __nwlog_obj();
      os_log_type_t v49 = type;
      if (os_log_type_enabled(v46, type))
      {
        *(_DWORD *)buf = 136446210;
        int v78 = "nw_service_connector_start_request";
        _os_log_impl(&dword_1830D4000, v46, v49, "%{public}s called with null endpoint", buf, 0xCu);
      }
      goto LABEL_135;
    }
    if (!v75)
    {
      uint32_t v46 = __nwlog_obj();
      os_log_type_t v65 = type;
      if (os_log_type_enabled(v46, type))
      {
        *(_DWORD *)buf = 136446210;
        int v78 = "nw_service_connector_start_request";
        _os_log_impl(&dword_1830D4000, v46, v65, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_135;
    }
    uint64_t v57 = (char *)__nw_create_backtrace_string();
    uint32_t v46 = __nwlog_obj();
    os_log_type_t v58 = type;
    BOOL v59 = os_log_type_enabled(v46, type);
    if (!v57)
    {
      if (v59)
      {
        *(_DWORD *)buf = 136446210;
        int v78 = "nw_service_connector_start_request";
        _os_log_impl(&dword_1830D4000, v46, v58, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
      goto LABEL_135;
    }
    if (v59)
    {
      *(_DWORD *)buf = 136446466;
      int v78 = "nw_service_connector_start_request";
      __int16 v79 = 2082;
      size_t v80 = (size_t)v57;
      _os_log_impl(&dword_1830D4000, v46, v58, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_110;
  }
  if (!a3)
  {
    int v50 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v78 = "nw_service_connector_start_request";
    os_log_type_t v45 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v75 = 0;
    if (!__nwlog_fault(v45, &type, &v75)) {
      goto LABEL_136;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint32_t v46 = __nwlog_obj();
      os_log_type_t v51 = type;
      if (os_log_type_enabled(v46, type))
      {
        *(_DWORD *)buf = 136446210;
        int v78 = "nw_service_connector_start_request";
        _os_log_impl(&dword_1830D4000, v46, v51, "%{public}s called with null userService", buf, 0xCu);
      }
      goto LABEL_135;
    }
    if (!v75)
    {
      uint32_t v46 = __nwlog_obj();
      os_log_type_t v66 = type;
      if (os_log_type_enabled(v46, type))
      {
        *(_DWORD *)buf = 136446210;
        int v78 = "nw_service_connector_start_request";
        _os_log_impl(&dword_1830D4000, v46, v66, "%{public}s called with null userService, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_135;
    }
    uint64_t v57 = (char *)__nw_create_backtrace_string();
    uint32_t v46 = __nwlog_obj();
    os_log_type_t v60 = type;
    BOOL v61 = os_log_type_enabled(v46, type);
    if (!v57)
    {
      if (v61)
      {
        *(_DWORD *)buf = 136446210;
        int v78 = "nw_service_connector_start_request";
        _os_log_impl(&dword_1830D4000, v46, v60, "%{public}s called with null userService, no backtrace", buf, 0xCu);
      }
      goto LABEL_135;
    }
    if (v61)
    {
      *(_DWORD *)buf = 136446466;
      int v78 = "nw_service_connector_start_request";
      __int16 v79 = 2082;
      size_t v80 = (size_t)v57;
      _os_log_impl(&dword_1830D4000, v46, v60, "%{public}s called with null userService, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_110;
  }
  if (!v11)
  {
    int v52 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v78 = "nw_service_connector_start_request";
    os_log_type_t v45 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v75 = 0;
    if (!__nwlog_fault(v45, &type, &v75)) {
      goto LABEL_136;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint32_t v46 = __nwlog_obj();
      os_log_type_t v53 = type;
      if (os_log_type_enabled(v46, type))
      {
        *(_DWORD *)buf = 136446210;
        int v78 = "nw_service_connector_start_request";
        _os_log_impl(&dword_1830D4000, v46, v53, "%{public}s called with null requestBlock", buf, 0xCu);
      }
      goto LABEL_135;
    }
    if (!v75)
    {
      uint32_t v46 = __nwlog_obj();
      os_log_type_t v67 = type;
      if (os_log_type_enabled(v46, type))
      {
        *(_DWORD *)buf = 136446210;
        int v78 = "nw_service_connector_start_request";
        _os_log_impl(&dword_1830D4000, v46, v67, "%{public}s called with null requestBlock, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_135;
    }
    uint64_t v57 = (char *)__nw_create_backtrace_string();
    uint32_t v46 = __nwlog_obj();
    os_log_type_t v62 = type;
    BOOL v63 = os_log_type_enabled(v46, type);
    if (!v57)
    {
      if (v63)
      {
        *(_DWORD *)buf = 136446210;
        int v78 = "nw_service_connector_start_request";
        _os_log_impl(&dword_1830D4000, v46, v62, "%{public}s called with null requestBlock, no backtrace", buf, 0xCu);
      }
      goto LABEL_135;
    }
    if (v63)
    {
      *(_DWORD *)buf = 136446466;
      int v78 = "nw_service_connector_start_request";
      __int16 v79 = 2082;
      size_t v80 = (size_t)v57;
      _os_log_impl(&dword_1830D4000, v46, v62, "%{public}s called with null requestBlock, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_110:

    free(v57);
    if (!v45) {
      goto LABEL_70;
    }
    goto LABEL_137;
  }
  id v13 = v10;
  int v14 = [v13 type];

  if (v14 != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v20 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    int v78 = "nw_service_connector_start_request";
    __int16 v79 = 2114;
    size_t v80 = (size_t)v13;
    os_log_type_t v21 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v75 = 0;
    if (__nwlog_fault(v21, &type, &v75))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v22 = (id)gLogObj;
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446466;
          int v78 = "nw_service_connector_start_request";
          __int16 v79 = 2114;
          size_t v80 = (size_t)v13;
          _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s Specified endpoint %{public}@ is not an address endpoint", buf, 0x16u);
        }
      }
      else if (v75)
      {
        id v28 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v22 = (id)gLogObj;
        os_log_type_t v29 = type;
        BOOL v30 = os_log_type_enabled(v22, type);
        if (v28)
        {
          if (v30)
          {
            *(_DWORD *)buf = 136446722;
            int v78 = "nw_service_connector_start_request";
            __int16 v79 = 2114;
            size_t v80 = (size_t)v13;
            __int16 v81 = 2082;
            v82[0] = v28;
            _os_log_impl(&dword_1830D4000, v22, v29, "%{public}s Specified endpoint %{public}@ is not an address endpoint, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(v28);
          if (!v21) {
            goto LABEL_44;
          }
          goto LABEL_43;
        }
        if (v30)
        {
          *(_DWORD *)buf = 136446466;
          int v78 = "nw_service_connector_start_request";
          __int16 v79 = 2114;
          size_t v80 = (size_t)v13;
          _os_log_impl(&dword_1830D4000, v22, v29, "%{public}s Specified endpoint %{public}@ is not an address endpoint, no backtrace", buf, 0x16u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v22 = (id)gLogObj;
        os_log_type_t v38 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446466;
          int v78 = "nw_service_connector_start_request";
          __int16 v79 = 2114;
          size_t v80 = (size_t)v13;
          _os_log_impl(&dword_1830D4000, v22, v38, "%{public}s Specified endpoint %{public}@ is not an address endpoint, backtrace limit exceeded", buf, 0x16u);
        }
      }
    }
    if (!v21) {
      goto LABEL_44;
    }
LABEL_43:
    free(v21);
    goto LABEL_44;
  }
  size_t v15 = strlen(a3);
  if (v15 <= 0x100)
  {
    size_t v24 = v15;
    xpc_object_t v25 = xpc_string_create(a3);
    os_log_type_t v26 = v25;
    if (v25)
    {
      int v27 = v9[4];
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = __nw_service_connector_start_request_block_invoke;
      block[3] = &unk_1E5243390;
      id v70 = v25;
      int v71 = v9;
      id v72 = v68;
      id v73 = v13;
      id v74 = v12;
      dispatch_async(v27, block);

LABEL_69:
      goto LABEL_70;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v34 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    int v78 = "nw_service_connector_start_request";
    __int16 v79 = 2048;
    size_t v80 = v24;
    uint64_t v35 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v75 = 0;
    if (__nwlog_fault(v35, &type, &v75))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v36 = (id)gLogObj;
        os_log_type_t v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)buf = 136446466;
          int v78 = "nw_service_connector_start_request";
          __int16 v79 = 2048;
          size_t v80 = v24;
          _os_log_impl(&dword_1830D4000, v36, v37, "%{public}s xpc_string_create(%zu) failed", buf, 0x16u);
        }
      }
      else if (v75)
      {
        uint64_t v40 = (char *)__nw_create_backtrace_string();
        uint64_t v36 = __nwlog_obj();
        os_log_type_t v41 = type;
        BOOL v42 = os_log_type_enabled(v36, type);
        if (v40)
        {
          if (v42)
          {
            *(_DWORD *)buf = 136446722;
            int v78 = "nw_service_connector_start_request";
            __int16 v79 = 2048;
            size_t v80 = v24;
            __int16 v81 = 2082;
            v82[0] = v40;
            _os_log_impl(&dword_1830D4000, v36, v41, "%{public}s xpc_string_create(%zu) failed, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(v40);
          if (!v35) {
            goto LABEL_68;
          }
          goto LABEL_67;
        }
        if (v42)
        {
          *(_DWORD *)buf = 136446466;
          int v78 = "nw_service_connector_start_request";
          __int16 v79 = 2048;
          size_t v80 = v24;
          _os_log_impl(&dword_1830D4000, v36, v41, "%{public}s xpc_string_create(%zu) failed, no backtrace", buf, 0x16u);
        }
      }
      else
      {
        uint64_t v36 = __nwlog_obj();
        os_log_type_t v43 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)buf = 136446466;
          int v78 = "nw_service_connector_start_request";
          __int16 v79 = 2048;
          size_t v80 = v24;
          _os_log_impl(&dword_1830D4000, v36, v43, "%{public}s xpc_string_create(%zu) failed, backtrace limit exceeded", buf, 0x16u);
        }
      }
    }
    if (!v35)
    {
LABEL_68:
      nw_service_connector_trigger_request_complete_block_inner(v9, 0, v12, 0, 12);
      goto LABEL_69;
    }
LABEL_67:
    free(v35);
    goto LABEL_68;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v16 = (id)gLogObj;
  *(_DWORD *)buf = 136446722;
  int v78 = "nw_service_connector_start_request";
  __int16 v79 = 2082;
  size_t v80 = (size_t)a3;
  __int16 v81 = 1024;
  LODWORD(v82[0]) = 256;
  int v17 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v75 = 0;
  if (__nwlog_fault(v17, &type, &v75))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unsigned __int8 v18 = (id)gLogObj;
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446722;
        int v78 = "nw_service_connector_start_request";
        __int16 v79 = 2082;
        size_t v80 = (size_t)a3;
        __int16 v81 = 1024;
        LODWORD(v82[0]) = 256;
        _os_log_impl(&dword_1830D4000, v18, v19, "%{public}s Service name \"%{public}s\" too long. Max allowed length is %d", buf, 0x1Cu);
      }
    }
    else if (v75)
    {
      char v31 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unsigned __int8 v18 = (id)gLogObj;
      os_log_type_t v32 = type;
      BOOL v33 = os_log_type_enabled(v18, type);
      if (v31)
      {
        if (v33)
        {
          *(_DWORD *)buf = 136446978;
          int v78 = "nw_service_connector_start_request";
          __int16 v79 = 2082;
          size_t v80 = (size_t)a3;
          __int16 v81 = 1024;
          LODWORD(v82[0]) = 256;
          WORD2(v82[0]) = 2082;
          *(void *)((char *)v82 + 6) = v31;
          _os_log_impl(&dword_1830D4000, v18, v32, "%{public}s Service name \"%{public}s\" too long. Max allowed length is %d, dumping backtrace:%{public}s", buf, 0x26u);
        }

        free(v31);
        if (!v17) {
          goto LABEL_44;
        }
        goto LABEL_58;
      }
      if (v33)
      {
        *(_DWORD *)buf = 136446722;
        int v78 = "nw_service_connector_start_request";
        __int16 v79 = 2082;
        size_t v80 = (size_t)a3;
        __int16 v81 = 1024;
        LODWORD(v82[0]) = 256;
        _os_log_impl(&dword_1830D4000, v18, v32, "%{public}s Service name \"%{public}s\" too long. Max allowed length is %d, no backtrace", buf, 0x1Cu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unsigned __int8 v18 = (id)gLogObj;
      os_log_type_t v39 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446722;
        int v78 = "nw_service_connector_start_request";
        __int16 v79 = 2082;
        size_t v80 = (size_t)a3;
        __int16 v81 = 1024;
        LODWORD(v82[0]) = 256;
        _os_log_impl(&dword_1830D4000, v18, v39, "%{public}s Service name \"%{public}s\" too long. Max allowed length is %d, backtrace limit exceeded", buf, 0x1Cu);
      }
    }
  }
  if (v17) {
LABEL_58:
  }
    free(v17);
LABEL_44:
  nw_service_connector_trigger_request_complete_block_inner(v9, 0, v12, 0, 22);
LABEL_70:
}

void sub_18345EF7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void nw_quic_connection_set_initial_max_stream_data_bidirectional_local(void *a1, uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_initial_max_stream_data_bidirectional_local_block_invoke;
    v12[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v12[4] = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  uint64_t v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v16 = "nw_quic_connection_set_initial_max_stream_data_bidirectional_local";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        id v16 = "nw_quic_connection_set_initial_max_stream_data_bidirectional_local";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          id v16 = "nw_quic_connection_set_initial_max_stream_data_bidirectional_local";
          __int16 v17 = 2082;
          unsigned __int8 v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        id v16 = "nw_quic_connection_set_initial_max_stream_data_bidirectional_local";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        id v16 = "nw_quic_connection_set_initial_max_stream_data_bidirectional_local";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_18345F2AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_quic_connection_close_with_error(void *a1, uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_close_with_error_block_invoke;
    v12[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v12[4] = a2;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v12);
    goto LABEL_3;
  }
  uint64_t v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v16 = "nw_quic_connection_close_with_error";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        id v16 = "nw_quic_connection_close_with_error";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          id v16 = "nw_quic_connection_close_with_error";
          __int16 v17 = 2082;
          unsigned __int8 v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        id v16 = "nw_quic_connection_close_with_error";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        id v16 = "nw_quic_connection_close_with_error";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_18345F5A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_proxy_hop_set_server_raw_public_key(void *a1, const UInt8 *a2, CFIndex a3)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  uint64_t v6 = v5;
  if (!v5)
  {
    os_log_type_t v7 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v34 = "nw_proxy_hop_set_server_raw_public_key";
    int v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (!__nwlog_fault(v8, &type, &v31)) {
      goto LABEL_72;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        id v34 = "nw_proxy_hop_set_server_raw_public_key";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null hop", buf, 0xCu);
      }
    }
    else if (v31)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          id v34 = "nw_proxy_hop_set_server_raw_public_key";
          __int16 v35 = 2082;
          uint64_t v36 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v18, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_72:
        if (!v8) {
          goto LABEL_6;
        }
LABEL_73:
        free(v8);
        goto LABEL_6;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        id v34 = "nw_proxy_hop_set_server_raw_public_key";
        _os_log_impl(&dword_1830D4000, v9, v18, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        id v34 = "nw_proxy_hop_set_server_raw_public_key";
        _os_log_impl(&dword_1830D4000, v9, v27, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_71:

    goto LABEL_72;
  }
  if (!nw_protocol_options_is_masque(v5[5]))
  {
    os_log_type_t v11 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v34 = "nw_proxy_hop_set_server_raw_public_key";
    int v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (!__nwlog_fault(v8, &type, &v31)) {
      goto LABEL_72;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        id v34 = "nw_proxy_hop_set_server_raw_public_key";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null nw_protocol_options_is_masque(hop->options)", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (!v31)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        id v34 = "nw_proxy_hop_set_server_raw_public_key";
        _os_log_impl(&dword_1830D4000, v9, v28, "%{public}s called with null nw_protocol_options_is_masque(hop->options), backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_71;
    }
    id v20 = (char *)__nw_create_backtrace_string();
    os_log_type_t v9 = __nwlog_obj();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v9, type);
    if (!v20)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        id v34 = "nw_proxy_hop_set_server_raw_public_key";
        _os_log_impl(&dword_1830D4000, v9, v21, "%{public}s called with null nw_protocol_options_is_masque(hop->options), no backtrace", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      id v34 = "nw_proxy_hop_set_server_raw_public_key";
      __int16 v35 = 2082;
      uint64_t v36 = v20;
      _os_log_impl(&dword_1830D4000, v9, v21, "%{public}s called with null nw_protocol_options_is_masque(hop->options), dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_46;
  }
  if (!a2)
  {
    char v13 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v34 = "nw_proxy_hop_set_server_raw_public_key";
    int v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (!__nwlog_fault(v8, &type, &v31)) {
      goto LABEL_72;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        id v34 = "nw_proxy_hop_set_server_raw_public_key";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null key_bytes", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (!v31)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        id v34 = "nw_proxy_hop_set_server_raw_public_key";
        _os_log_impl(&dword_1830D4000, v9, v29, "%{public}s called with null key_bytes, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_71;
    }
    id v20 = (char *)__nw_create_backtrace_string();
    os_log_type_t v9 = __nwlog_obj();
    os_log_type_t v23 = type;
    BOOL v24 = os_log_type_enabled(v9, type);
    if (!v20)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        id v34 = "nw_proxy_hop_set_server_raw_public_key";
        _os_log_impl(&dword_1830D4000, v9, v23, "%{public}s called with null key_bytes, no backtrace", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      id v34 = "nw_proxy_hop_set_server_raw_public_key";
      __int16 v35 = 2082;
      uint64_t v36 = v20;
      _os_log_impl(&dword_1830D4000, v9, v23, "%{public}s called with null key_bytes, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_46;
  }
  if (!a3)
  {
    size_t v15 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v34 = "nw_proxy_hop_set_server_raw_public_key";
    int v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (!__nwlog_fault(v8, &type, &v31)) {
      goto LABEL_72;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        id v34 = "nw_proxy_hop_set_server_raw_public_key";
        _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null key_length", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (!v31)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v30 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        id v34 = "nw_proxy_hop_set_server_raw_public_key";
        _os_log_impl(&dword_1830D4000, v9, v30, "%{public}s called with null key_length, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_71;
    }
    id v20 = (char *)__nw_create_backtrace_string();
    os_log_type_t v9 = __nwlog_obj();
    os_log_type_t v25 = type;
    BOOL v26 = os_log_type_enabled(v9, type);
    if (!v20)
    {
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        id v34 = "nw_proxy_hop_set_server_raw_public_key";
        _os_log_impl(&dword_1830D4000, v9, v25, "%{public}s called with null key_length, no backtrace", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      id v34 = "nw_proxy_hop_set_server_raw_public_key";
      __int16 v35 = 2082;
      uint64_t v36 = v20;
      _os_log_impl(&dword_1830D4000, v9, v25, "%{public}s called with null key_length, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_46:

    free(v20);
    if (!v8) {
      goto LABEL_6;
    }
    goto LABEL_73;
  }
  nw_proxy_hop_add_server_raw_public_key(v6, a2, a3);
LABEL_6:
}

void sub_18345FE90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_proxy_config_get_force_multipath(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[171] >> 1) & 1;
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_proxy_config_get_force_multipath";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_proxy_config_get_force_multipath";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null config", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_proxy_config_get_force_multipath";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_proxy_config_get_force_multipath";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_proxy_config_get_force_multipath";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

void nw_protocol_trainer_bottom_set_output_style(uint64_t a1, int a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 40);
    if (v2)
    {
      *(_DWORD *)(v2 + 184) = a2;
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v14 = "nw_protocol_trainer_bottom_set_output_style";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (__nwlog_fault(v3, &type, &v11))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v4 = __nwlog_obj();
        os_log_type_t v5 = type;
        if (!os_log_type_enabled(v4, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v14 = "nw_protocol_trainer_bottom_set_output_style";
        uint64_t v6 = "%{public}s called with null trainer";
        goto LABEL_32;
      }
      if (!v11)
      {
        uint64_t v4 = __nwlog_obj();
        os_log_type_t v5 = type;
        if (!os_log_type_enabled(v4, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v14 = "nw_protocol_trainer_bottom_set_output_style";
        uint64_t v6 = "%{public}s called with null trainer, backtrace limit exceeded";
        goto LABEL_32;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v10 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v14 = "nw_protocol_trainer_bottom_set_output_style";
          __int16 v15 = 2082;
          os_log_type_t v16 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s called with null trainer, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        if (v3) {
          goto LABEL_34;
        }
        return;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v14 = "nw_protocol_trainer_bottom_set_output_style";
        uint64_t v6 = "%{public}s called with null trainer, no backtrace";
LABEL_32:
        _os_log_impl(&dword_1830D4000, v4, v5, v6, buf, 0xCu);
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v14 = "nw_protocol_trainer_bottom_set_output_style";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (!__nwlog_fault(v3, &type, &v11)) {
      goto LABEL_33;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v14 = "nw_protocol_trainer_bottom_set_output_style";
      uint64_t v6 = "%{public}s called with null protocol";
      goto LABEL_32;
    }
    if (!v11)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v14 = "nw_protocol_trainer_bottom_set_output_style";
      uint64_t v6 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_32;
    }
    os_log_type_t v7 = (char *)__nw_create_backtrace_string();
    uint64_t v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v8 = os_log_type_enabled(v4, type);
    if (!v7)
    {
      if (!v8) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v14 = "nw_protocol_trainer_bottom_set_output_style";
      uint64_t v6 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_32;
    }
    if (v8)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v14 = "nw_protocol_trainer_bottom_set_output_style";
      __int16 v15 = 2082;
      os_log_type_t v16 = v7;
      _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v7);
  }
LABEL_33:
  if (v3) {
LABEL_34:
  }
    free(v3);
}

void nw_protocol_instance_report_done(void *a1, unint64_t a2, void *a3)
{
  uint64_t v114 = *MEMORY[0x1E4F143B8];
  os_log_type_t v5 = a1;
  id v6 = a3;
  if (!v5)
  {
    uint64_t v57 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_instance_report_done";
    os_log_type_t v58 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v103) = 0;
    if (!__nwlog_fault(v58, type, &v103)) {
      goto LABEL_171;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      BOOL v59 = __nwlog_obj();
      os_log_type_t v60 = type[0];
      if (os_log_type_enabled(v59, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_report_done";
        _os_log_impl(&dword_1830D4000, v59, v60, "%{public}s called with null instance", buf, 0xCu);
      }
    }
    else if ((_BYTE)v103)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v59 = __nwlog_obj();
      os_log_type_t v65 = type[0];
      BOOL v66 = os_log_type_enabled(v59, type[0]);
      if (backtrace_string)
      {
        if (v66)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_report_done";
          __int16 v108 = 2082;
          int v109 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v59, v65, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_171:
        if (!v58) {
          goto LABEL_104;
        }
        goto LABEL_172;
      }
      if (v66)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_report_done";
        _os_log_impl(&dword_1830D4000, v59, v65, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v59 = __nwlog_obj();
      os_log_type_t v80 = type[0];
      if (os_log_type_enabled(v59, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_report_done";
        _os_log_impl(&dword_1830D4000, v59, v80, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_170:

    goto LABEL_171;
  }
  os_log_type_t v7 = (void *)*((void *)v5 + 15);
  if (v7)
  {
    BOOL v8 = v7;
    os_log_type_t v9 = v8;
    if (((_BYTE)v8[17] & 8) == 0) {
      dispatch_assert_queue_V2(v8[1]);
    }
  }
  if ((v5[405] & 0x80000000) == 0 && gLogDatapath)
  {
    BOOL v61 = __nwlog_obj();
    if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_protocol_instance_report_done";
      __int16 v108 = 2082;
      int v109 = v5 + 407;
      __int16 v110 = 2080;
      uint64_t v111 = " ";
      __int16 v112 = 2048;
      unint64_t v113 = a2;
      _os_log_impl(&dword_1830D4000, v61, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sReporting flow %llx done", buf, 0x2Au);
    }
  }
  if (*(_DWORD *)(*((void *)v5 + 1) + 64) != 3)
  {
    if (a2 == -1)
    {
      if (!v6) {
        goto LABEL_52;
      }
      char v13 = (const char *)*((void *)v5 - 6);
      if (!v13) {
        goto LABEL_52;
      }
      uint64_t v14 = *((void *)v13 + 3);
      if (!v14 || !*(void *)(v14 + 56)) {
        goto LABEL_52;
      }
      __int16 v15 = (unsigned int *)v6;
      uint64_t v16 = v15[3];

      uint64_t v17 = (void *)*((void *)v13 + 5);
      if (v17 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v28 = *((void *)v13 + 11);
        if (v28) {
          *((void *)v13 + 11) = v28 + 1;
        }
        char v18 = -1;
      }
      else
      {
        char v18 = 0;
      }
      *(void *)os_log_type_t type = v13;
      char v106 = v18;
      os_log_type_t v29 = (void *)*((void *)v5 - 7);
      if (v29 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v31 = *((void *)v5 - 1);
        if (v31) {
          *((void *)v5 - 1) = v31 + 1;
        }
        char v30 = -1;
      }
      else
      {
        char v30 = 0;
      }
      char v103 = v5 - 96;
      char v104 = v30;
      uint64_t v32 = *((void *)v13 + 3);
      if (v32)
      {
        BOOL v33 = *(void (**)(const char *, char *, uint64_t))(v32 + 56);
        if (v33)
        {
          v33(v13, v5 - 96, v16);
LABEL_50:
          if (v29 != &nw_protocol_ref_counted_handle)
          {
            if (v17 != &nw_protocol_ref_counted_handle) {
              goto LABEL_52;
            }
LABEL_71:
            nw::release_if_needed<nw_protocol *>((uint64_t *)type);
            id v34 = (void *)*((void *)v5 - 6);
            if (!v34) {
              goto LABEL_104;
            }
LABEL_53:
            uint64_t v35 = v34[3];
            if (!v35) {
              goto LABEL_104;
            }
            uint64_t v36 = *(void (**)(void *, char *))(v35 + 48);
            if (!v36) {
              goto LABEL_104;
            }
            uint64_t v37 = (void *)v34[5];
            if (v37 == &nw_protocol_ref_counted_handle)
            {
              uint64_t v39 = v34[11];
              if (v39) {
                v34[11] = v39 + 1;
              }
              char v38 = -1;
            }
            else
            {
              char v38 = 0;
            }
            *(void *)buf = v34;
            buf[8] = v38;
            uint64_t v40 = (void *)*((void *)v5 - 7);
            if (v40 == &nw_protocol_ref_counted_handle)
            {
              uint64_t v42 = *((void *)v5 - 1);
              if (v42) {
                *((void *)v5 - 1) = v42 + 1;
              }
              char v41 = -1;
            }
            else
            {
              char v41 = 0;
            }
            *(void *)os_log_type_t type = v5 - 96;
            char v106 = v41;
            v36(v34, v5 - 96);
            if (v40 == &nw_protocol_ref_counted_handle)
            {
              nw::release_if_needed<nw_protocol *>((uint64_t *)type);
              if (v37 != &nw_protocol_ref_counted_handle) {
                goto LABEL_104;
              }
            }
            else if (v37 != &nw_protocol_ref_counted_handle)
            {
              goto LABEL_104;
            }
LABEL_103:
            nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
            goto LABEL_104;
          }
          nw::release_if_needed<nw_protocol *>((uint64_t *)&v103);
          if (v17 == &nw_protocol_ref_counted_handle) {
            goto LABEL_71;
          }
LABEL_52:
          id v34 = (void *)*((void *)v5 - 6);
          if (!v34) {
            goto LABEL_104;
          }
          goto LABEL_53;
        }
      }
      os_log_type_t v67 = __nwlog_obj();
      id v68 = (const char *)*((void *)v13 + 2);
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "__nw_protocol_error";
      if (!v68) {
        id v68 = "invalid";
      }
      __int16 v108 = 2082;
      int v109 = (char *)v68;
      __int16 v110 = 2048;
      uint64_t v111 = v13;
      os_log_type_t v69 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t v102 = OS_LOG_TYPE_ERROR;
      char v101 = 0;
      if (__nwlog_fault(v69, &v102, &v101))
      {
        if (v102 == OS_LOG_TYPE_FAULT)
        {
          id v70 = __nwlog_obj();
          os_log_type_t v71 = v102;
          if (os_log_type_enabled(v70, v102))
          {
            id v72 = (const char *)*((void *)v13 + 2);
            if (!v72) {
              id v72 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "__nw_protocol_error";
            __int16 v108 = 2082;
            int v109 = (char *)v72;
            __int16 v110 = 2048;
            uint64_t v111 = v13;
            _os_log_impl(&dword_1830D4000, v70, v71, "%{public}s protocol %{public}s (%p) has invalid error callback", buf, 0x20u);
          }
        }
        else if (v101)
        {
          os_log_type_t v76 = (char *)__nw_create_backtrace_string();
          id v70 = __nwlog_obj();
          os_log_type_t v77 = v102;
          BOOL v78 = os_log_type_enabled(v70, v102);
          if (v76)
          {
            if (v78)
            {
              __int16 v79 = (const char *)*((void *)v13 + 2);
              if (!v79) {
                __int16 v79 = "invalid";
              }
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "__nw_protocol_error";
              __int16 v108 = 2082;
              int v109 = (char *)v79;
              __int16 v110 = 2048;
              uint64_t v111 = v13;
              __int16 v112 = 2082;
              unint64_t v113 = (unint64_t)v76;
              _os_log_impl(&dword_1830D4000, v70, v77, "%{public}s protocol %{public}s (%p) has invalid error callback, dumping backtrace:%{public}s", buf, 0x2Au);
            }

            free(v76);
            goto LABEL_178;
          }
          if (v78)
          {
            uint64_t v90 = (const char *)*((void *)v13 + 2);
            if (!v90) {
              uint64_t v90 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "__nw_protocol_error";
            __int16 v108 = 2082;
            int v109 = (char *)v90;
            __int16 v110 = 2048;
            uint64_t v111 = v13;
            _os_log_impl(&dword_1830D4000, v70, v77, "%{public}s protocol %{public}s (%p) has invalid error callback, no backtrace", buf, 0x20u);
          }
        }
        else
        {
          id v70 = __nwlog_obj();
          os_log_type_t v88 = v102;
          if (os_log_type_enabled(v70, v102))
          {
            BOOL v89 = (const char *)*((void *)v13 + 2);
            if (!v89) {
              BOOL v89 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "__nw_protocol_error";
            __int16 v108 = 2082;
            int v109 = (char *)v89;
            __int16 v110 = 2048;
            uint64_t v111 = v13;
            _os_log_impl(&dword_1830D4000, v70, v88, "%{public}s protocol %{public}s (%p) has invalid error callback, backtrace limit exceeded", buf, 0x20u);
          }
        }
      }
LABEL_178:
      if (v69) {
        free(v69);
      }
      goto LABEL_50;
    }
    os_log_type_t v62 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_instance_report_done";
    os_log_type_t v58 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v103) = 0;
    if (!__nwlog_fault(v58, type, &v103)) {
      goto LABEL_171;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      BOOL v59 = __nwlog_obj();
      os_log_type_t v63 = type[0];
      if (os_log_type_enabled(v59, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_report_done";
        _os_log_impl(&dword_1830D4000, v59, v63, "%{public}s called with null (flow == NW_PROTOCOL_DEFAULT_FLOW)", buf, 0xCu);
      }
    }
    else if ((_BYTE)v103)
    {
      id v73 = (char *)__nw_create_backtrace_string();
      BOOL v59 = __nwlog_obj();
      os_log_type_t v74 = type[0];
      BOOL v75 = os_log_type_enabled(v59, type[0]);
      if (v73)
      {
        if (v75)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_report_done";
          __int16 v108 = 2082;
          int v109 = v73;
          _os_log_impl(&dword_1830D4000, v59, v74, "%{public}s called with null (flow == NW_PROTOCOL_DEFAULT_FLOW), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v73);
        if (!v58) {
          goto LABEL_104;
        }
LABEL_172:
        free(v58);
        goto LABEL_104;
      }
      if (v75)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_report_done";
        _os_log_impl(&dword_1830D4000, v59, v74, "%{public}s called with null (flow == NW_PROTOCOL_DEFAULT_FLOW), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v59 = __nwlog_obj();
      os_log_type_t v81 = type[0];
      if (os_log_type_enabled(v59, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_report_done";
        _os_log_impl(&dword_1830D4000, v59, v81, "%{public}s called with null (flow == NW_PROTOCOL_DEFAULT_FLOW), backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_170;
  }
  if (a2 >= 0xFFFFFFFFFFFFFFFELL)
  {
    if ((v5[405] & 0x40) != 0)
    {
      if ((v5[405] & 0x80) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v26 = (id)gLogObj;
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_report_done";
          __int16 v108 = 2082;
          int v109 = v5 + 407;
          __int16 v110 = 2080;
          uint64_t v111 = " ";
          _os_log_impl(&dword_1830D4000, v26, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%salready in report done, skipping", buf, 0x20u);
        }
      }
    }
    else
    {
      v5[405] |= 0x40u;
      v5[404] |= 4u;
      nw_protocol_remove_instance((uint64_t)(v5 - 96));
      uint64_t v10 = *((void *)v5 + 3);
      if (v10)
      {
        if (*(void *)v10)
        {
          char v11 = *(void (**)(void))(*(void *)v10 + 8);
          if (v11) {
            v11();
          }
        }
        *((void *)v5 + 3) = 0;
      }
      os_log_type_t v12 = (char *)*((void *)v5 + 29);
      v98[0] = MEMORY[0x1E4F143A8];
      v98[1] = 3221225472;
      v98[2] = __nw_protocol_instance_report_done_block_invoke;
      v98[3] = &unk_1E523BCE8;
      id v99 = v6;
      uint64_t v100 = v5;
      nw_hash_table_apply(v12, (uint64_t)v98);
      v5[405] &= ~0x40u;
    }
    goto LABEL_104;
  }
  uint64_t node = nw_hash_table_get_node(*((void *)v5 + 29), a2, 8);
  if (!node)
  {
    if ((v5[405] & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v27 = (id)gLogObj;
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_report_done";
        __int16 v108 = 2082;
        int v109 = v5 + 407;
        __int16 v110 = 2080;
        uint64_t v111 = " ";
        __int16 v112 = 2048;
        unint64_t v113 = a2;
        _os_log_impl(&dword_1830D4000, v27, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sCannot report done, flow %llx does not exist", buf, 0x2Au);
      }
    }
    goto LABEL_104;
  }
  *(_WORD *)(node + 84) |= 0x200u;
  id v20 = *(const char **)(node + 16);
  if (!v20) {
    goto LABEL_104;
  }
  if (!v6) {
    goto LABEL_88;
  }
  uint64_t v21 = *((void *)v20 + 3);
  if (!v21 || !*(void *)(v21 + 56)) {
    goto LABEL_88;
  }
  BOOL v22 = (unsigned int *)v6;
  uint64_t v23 = v22[3];

  BOOL v24 = (void *)*((void *)v20 + 5);
  if (v24 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v43 = *((void *)v20 + 11);
    if (v43) {
      *((void *)v20 + 11) = v43 + 1;
    }
    char v25 = -1;
  }
  else
  {
    char v25 = 0;
  }
  *(void *)os_log_type_t type = v20;
  char v106 = v25;
  os_log_type_t v44 = (void *)*((void *)v5 - 7);
  if (v44 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v46 = *((void *)v5 - 1);
    if (v46) {
      *((void *)v5 - 1) = v46 + 1;
    }
    char v45 = -1;
  }
  else
  {
    char v45 = 0;
  }
  char v103 = v5 - 96;
  char v104 = v45;
  uint64_t v47 = *((void *)v20 + 3);
  if (!v47 || (int v48 = *(void (**)(const char *, char *, uint64_t))(v47 + 56)) == 0)
  {
    os_log_type_t v82 = __nwlog_obj();
    uint64_t v83 = (const char *)*((void *)v20 + 2);
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "__nw_protocol_error";
    if (!v83) {
      uint64_t v83 = "invalid";
    }
    __int16 v108 = 2082;
    int v109 = (char *)v83;
    __int16 v110 = 2048;
    uint64_t v111 = v20;
    int v84 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v102 = OS_LOG_TYPE_ERROR;
    char v101 = 0;
    if (!__nwlog_fault(v84, &v102, &v101)) {
      goto LABEL_197;
    }
    if (v102 == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v85 = __nwlog_obj();
      os_log_type_t v86 = v102;
      if (os_log_type_enabled(v85, v102))
      {
        uint64_t v87 = (const char *)*((void *)v20 + 2);
        if (!v87) {
          uint64_t v87 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "__nw_protocol_error";
        __int16 v108 = 2082;
        int v109 = (char *)v87;
        __int16 v110 = 2048;
        uint64_t v111 = v20;
        _os_log_impl(&dword_1830D4000, v85, v86, "%{public}s protocol %{public}s (%p) has invalid error callback", buf, 0x20u);
      }
    }
    else if (v101)
    {
      os_log_type_t v91 = (char *)__nw_create_backtrace_string();
      os_log_type_t v85 = __nwlog_obj();
      os_log_type_t v92 = v102;
      BOOL v93 = os_log_type_enabled(v85, v102);
      if (v91)
      {
        if (v93)
        {
          uint64_t v94 = (const char *)*((void *)v20 + 2);
          if (!v94) {
            uint64_t v94 = "invalid";
          }
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "__nw_protocol_error";
          __int16 v108 = 2082;
          int v109 = (char *)v94;
          __int16 v110 = 2048;
          uint64_t v111 = v20;
          __int16 v112 = 2082;
          unint64_t v113 = (unint64_t)v91;
          _os_log_impl(&dword_1830D4000, v85, v92, "%{public}s protocol %{public}s (%p) has invalid error callback, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v91);
        goto LABEL_197;
      }
      if (v93)
      {
        uint64_t v97 = (const char *)*((void *)v20 + 2);
        if (!v97) {
          uint64_t v97 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "__nw_protocol_error";
        __int16 v108 = 2082;
        int v109 = (char *)v97;
        __int16 v110 = 2048;
        uint64_t v111 = v20;
        _os_log_impl(&dword_1830D4000, v85, v92, "%{public}s protocol %{public}s (%p) has invalid error callback, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      os_log_type_t v85 = __nwlog_obj();
      os_log_type_t v95 = v102;
      if (os_log_type_enabled(v85, v102))
      {
        uint64_t v96 = (const char *)*((void *)v20 + 2);
        if (!v96) {
          uint64_t v96 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "__nw_protocol_error";
        __int16 v108 = 2082;
        int v109 = (char *)v96;
        __int16 v110 = 2048;
        uint64_t v111 = v20;
        _os_log_impl(&dword_1830D4000, v85, v95, "%{public}s protocol %{public}s (%p) has invalid error callback, backtrace limit exceeded", buf, 0x20u);
      }
    }

LABEL_197:
    if (v84) {
      free(v84);
    }
    goto LABEL_84;
  }
  v48(v20, v5 - 96, v23);
LABEL_84:
  if (v44 == &nw_protocol_ref_counted_handle) {
    nw::release_if_needed<nw_protocol *>((uint64_t *)&v103);
  }
  if (v24 == &nw_protocol_ref_counted_handle) {
    nw::release_if_needed<nw_protocol *>((uint64_t *)type);
  }
LABEL_88:
  uint64_t v49 = *((void *)v20 + 3);
  if (v49)
  {
    int v50 = *(void (**)(const char *))(v49 + 48);
    if (v50)
    {
      os_log_type_t v51 = (void *)*((void *)v20 + 5);
      if (v51 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v53 = *((void *)v20 + 11);
        if (v53) {
          *((void *)v20 + 11) = v53 + 1;
        }
        char v52 = -1;
      }
      else
      {
        char v52 = 0;
      }
      *(void *)buf = v20;
      buf[8] = v52;
      uint64_t v54 = (void *)*((void *)v5 - 7);
      if (v54 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v56 = *((void *)v5 - 1);
        if (v56) {
          *((void *)v5 - 1) = v56 + 1;
        }
        char v55 = -1;
      }
      else
      {
        char v55 = 0;
      }
      *(void *)os_log_type_t type = v5 - 96;
      char v106 = v55;
      v50(v20);
      if (v54 == &nw_protocol_ref_counted_handle) {
        nw::release_if_needed<nw_protocol *>((uint64_t *)type);
      }
      if (v51 == &nw_protocol_ref_counted_handle) {
        goto LABEL_103;
      }
    }
  }
LABEL_104:
}

BOOL nw_protocol_http1_accept(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v43 = "nw_http1_get_http1_protocol";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (!__nwlog_fault(v12, &type, &v40)) {
      goto LABEL_100;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v40)
      {
        char v13 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (!os_log_type_enabled(v13, type)) {
          goto LABEL_100;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v43 = "nw_http1_get_http1_protocol";
        __int16 v15 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_99;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v21 = os_log_type_enabled(v13, type);
      if (!backtrace_string)
      {
        if (!v21) {
          goto LABEL_100;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v43 = "nw_http1_get_http1_protocol";
        __int16 v15 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_99;
      }
      if (v21)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v43 = "nw_http1_get_http1_protocol";
        __int16 v44 = 2082;
        char v45 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_100;
    }
    char v13 = __nwlog_obj();
    os_log_type_t v14 = type;
    if (!os_log_type_enabled(v13, type)) {
      goto LABEL_100;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v43 = "nw_http1_get_http1_protocol";
    __int16 v15 = "%{public}s called with null protocol";
LABEL_99:
    _os_log_impl(&dword_1830D4000, v13, v14, v15, buf, 0xCu);
    goto LABEL_100;
  }
  uint64_t v3 = *(uint64_t **)(a1 + 40);
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v43 = "nw_http1_get_http1_protocol";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (!__nwlog_fault(v12, &type, &v40)) {
      goto LABEL_100;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v40)
      {
        char v13 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (!os_log_type_enabled(v13, type)) {
          goto LABEL_100;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v43 = "nw_http1_get_http1_protocol";
        __int16 v15 = "%{public}s called with null handle, backtrace limit exceeded";
        goto LABEL_99;
      }
      BOOL v22 = (char *)__nw_create_backtrace_string();
      char v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v23 = os_log_type_enabled(v13, type);
      if (!v22)
      {
        if (!v23) {
          goto LABEL_100;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v43 = "nw_http1_get_http1_protocol";
        __int16 v15 = "%{public}s called with null handle, no backtrace";
        goto LABEL_99;
      }
      if (v23)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v43 = "nw_http1_get_http1_protocol";
        __int16 v44 = 2082;
        char v45 = v22;
        BOOL v24 = "%{public}s called with null handle, dumping backtrace:%{public}s";
LABEL_80:
        _os_log_impl(&dword_1830D4000, v13, v14, v24, buf, 0x16u);
      }
LABEL_81:
      free(v22);
      if (!v12)
      {
LABEL_102:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446210;
        uint64_t v43 = "nw_protocol_http1_accept";
        uint64_t v16 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v40 = 0;
        if (!__nwlog_fault(v16, &type, &v40)) {
          goto LABEL_115;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v17 = gLogObj;
          os_log_type_t v18 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_115;
          }
          *(_DWORD *)buf = 136446210;
          uint64_t v43 = "nw_protocol_http1_accept";
          uint64_t v19 = "%{public}s called with null http1";
        }
        else
        {
          if (v40)
          {
            id v34 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v35 = gLogObj;
            os_log_type_t v36 = type;
            BOOL v37 = os_log_type_enabled((os_log_t)gLogObj, type);
            if (v34)
            {
              if (v37)
              {
                *(_DWORD *)buf = 136446466;
                uint64_t v43 = "nw_protocol_http1_accept";
                __int16 v44 = 2082;
                char v45 = v34;
                _os_log_impl(&dword_1830D4000, v35, v36, "%{public}s called with null http1, dumping backtrace:%{public}s", buf, 0x16u);
              }
              free(v34);
              goto LABEL_115;
            }
            if (!v37)
            {
LABEL_115:
              if (v16) {
                free(v16);
              }
              return 0;
            }
            *(_DWORD *)buf = 136446210;
            uint64_t v43 = "nw_protocol_http1_accept";
            uint64_t v19 = "%{public}s called with null http1, no backtrace";
            char v38 = v35;
            os_log_type_t v39 = v36;
LABEL_114:
            _os_log_impl(&dword_1830D4000, v38, v39, v19, buf, 0xCu);
            goto LABEL_115;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v17 = gLogObj;
          os_log_type_t v18 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_115;
          }
          *(_DWORD *)buf = 136446210;
          uint64_t v43 = "nw_protocol_http1_accept";
          uint64_t v19 = "%{public}s called with null http1, backtrace limit exceeded";
        }
        goto LABEL_113;
      }
LABEL_101:
      free(v12);
      goto LABEL_102;
    }
    char v13 = __nwlog_obj();
    os_log_type_t v14 = type;
    if (!os_log_type_enabled(v13, type)) {
      goto LABEL_100;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v43 = "nw_http1_get_http1_protocol";
    __int16 v15 = "%{public}s called with null handle";
    goto LABEL_99;
  }
  int v5 = *((_DWORD *)v3 + 6);
  if (v5 == 1) {
    goto LABEL_10;
  }
  if (v5 != 2)
  {
    if (v5 != 3) {
      goto LABEL_102;
    }
    uint64_t v6 = v3[2];
    if (v6)
    {
      uint64_t v3 = (uint64_t *)(v6 + 480);
      goto LABEL_10;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v43 = "nw_http1_get_http1_protocol";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (__nwlog_fault(v12, &type, &v40))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v13 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (!os_log_type_enabled(v13, type)) {
          goto LABEL_100;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v43 = "nw_http1_get_http1_protocol";
        __int16 v15 = "%{public}s called with null handle->http1_connection";
        goto LABEL_99;
      }
      if (!v40)
      {
        char v13 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (!os_log_type_enabled(v13, type)) {
          goto LABEL_100;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v43 = "nw_http1_get_http1_protocol";
        __int16 v15 = "%{public}s called with null handle->http1_connection, backtrace limit exceeded";
        goto LABEL_99;
      }
      BOOL v22 = (char *)__nw_create_backtrace_string();
      char v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v32 = os_log_type_enabled(v13, type);
      if (!v22)
      {
        if (!v32) {
          goto LABEL_100;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v43 = "nw_http1_get_http1_protocol";
        __int16 v15 = "%{public}s called with null handle->http1_connection, no backtrace";
        goto LABEL_99;
      }
      if (v32)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v43 = "nw_http1_get_http1_protocol";
        __int16 v44 = 2082;
        char v45 = v22;
        BOOL v24 = "%{public}s called with null handle->http1_connection, dumping backtrace:%{public}s";
        goto LABEL_80;
      }
      goto LABEL_81;
    }
LABEL_100:
    if (!v12) {
      goto LABEL_102;
    }
    goto LABEL_101;
  }
  uint64_t v7 = v3[1];
  if (!v7)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v43 = "nw_http1_get_http1_protocol";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (!__nwlog_fault(v12, &type, &v40)) {
      goto LABEL_100;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_100;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v43 = "nw_http1_get_http1_protocol";
      __int16 v15 = "%{public}s called with null handle->http1_stream";
      goto LABEL_99;
    }
    if (!v40)
    {
      char v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_100;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v43 = "nw_http1_get_http1_protocol";
      __int16 v15 = "%{public}s called with null handle->http1_stream, backtrace limit exceeded";
      goto LABEL_99;
    }
    BOOL v22 = (char *)__nw_create_backtrace_string();
    char v13 = __nwlog_obj();
    os_log_type_t v14 = type;
    BOOL v33 = os_log_type_enabled(v13, type);
    if (!v22)
    {
      if (!v33) {
        goto LABEL_100;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v43 = "nw_http1_get_http1_protocol";
      __int16 v15 = "%{public}s called with null handle->http1_stream, no backtrace";
      goto LABEL_99;
    }
    if (v33)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v43 = "nw_http1_get_http1_protocol";
      __int16 v44 = 2082;
      char v45 = v22;
      BOOL v24 = "%{public}s called with null handle->http1_stream, dumping backtrace:%{public}s";
      goto LABEL_80;
    }
    goto LABEL_81;
  }
  uint64_t v3 = (uint64_t *)(v7 + 248);
LABEL_10:
  uint64_t v8 = *v3;
  if (!*v3) {
    goto LABEL_102;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v43 = "nw_protocol_http1_accept";
    uint64_t v16 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (!__nwlog_fault(v16, &type, &v40)) {
      goto LABEL_115;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v40)
      {
        uint64_t v17 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (!os_log_type_enabled(v17, type)) {
          goto LABEL_115;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v43 = "nw_protocol_http1_accept";
        uint64_t v19 = "%{public}s called with null endpoint, backtrace limit exceeded";
        goto LABEL_113;
      }
      char v25 = (char *)__nw_create_backtrace_string();
      uint64_t v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      BOOL v26 = os_log_type_enabled(v17, type);
      if (!v25)
      {
        if (!v26) {
          goto LABEL_115;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v43 = "nw_protocol_http1_accept";
        uint64_t v19 = "%{public}s called with null endpoint, no backtrace";
        goto LABEL_113;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v43 = "nw_protocol_http1_accept";
        __int16 v44 = 2082;
        char v45 = v25;
        os_log_type_t v27 = "%{public}s called with null endpoint, dumping backtrace:%{public}s";
LABEL_52:
        _os_log_impl(&dword_1830D4000, v17, v18, v27, buf, 0x16u);
      }
LABEL_53:
      free(v25);
      goto LABEL_115;
    }
    uint64_t v17 = __nwlog_obj();
    os_log_type_t v18 = type;
    if (!os_log_type_enabled(v17, type)) {
      goto LABEL_115;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v43 = "nw_protocol_http1_accept";
    uint64_t v19 = "%{public}s called with null endpoint";
LABEL_113:
    char v38 = v17;
    os_log_type_t v39 = v18;
    goto LABEL_114;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v43 = "nw_protocol_http1_accept";
    uint64_t v16 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (!__nwlog_fault(v16, &type, &v40)) {
      goto LABEL_115;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_115;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v43 = "nw_protocol_http1_accept";
      uint64_t v19 = "%{public}s called with null parameters";
      goto LABEL_113;
    }
    if (!v40)
    {
      uint64_t v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_115;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v43 = "nw_protocol_http1_accept";
      uint64_t v19 = "%{public}s called with null parameters, backtrace limit exceeded";
      goto LABEL_113;
    }
    char v25 = (char *)__nw_create_backtrace_string();
    uint64_t v17 = __nwlog_obj();
    os_log_type_t v18 = type;
    BOOL v28 = os_log_type_enabled(v17, type);
    if (!v25)
    {
      if (!v28) {
        goto LABEL_115;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v43 = "nw_protocol_http1_accept";
      uint64_t v19 = "%{public}s called with null parameters, no backtrace";
      goto LABEL_113;
    }
    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v43 = "nw_protocol_http1_accept";
      __int16 v44 = 2082;
      char v45 = v25;
      os_log_type_t v27 = "%{public}s called with null parameters, dumping backtrace:%{public}s";
      goto LABEL_52;
    }
    goto LABEL_53;
  }
  if ((*(unsigned char *)(v8 + 376) & 8) != 0)
  {
    if (!(*(unsigned char *)(v8 + 158) & 1 | (gLogDatapath == 0)))
    {
      uint64_t v10 = __nwlog_obj();
      BOOL result = os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG);
      if (!result) {
        return result;
      }
      int v11 = *(_DWORD *)(v8 + 372);
      *(_DWORD *)buf = 136446978;
      uint64_t v43 = "nw_protocol_http1_accept";
      __int16 v44 = 2082;
      char v45 = (char *)(v8 + 74);
      __int16 v46 = 2080;
      uint64_t v47 = " ";
      __int16 v48 = 1024;
      int v49 = v11;
      _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> refusing accept because do not reuse is set", buf, 0x26u);
    }
    return 0;
  }
  if (!(*(unsigned char *)(v8 + 158) & 1 | (gLogDatapath == 0)))
  {
    char v30 = __nwlog_obj();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
    {
      int v31 = *(_DWORD *)(v8 + 372);
      *(_DWORD *)buf = 136447490;
      uint64_t v43 = "nw_protocol_http1_accept";
      __int16 v44 = 2082;
      char v45 = (char *)(v8 + 74);
      __int16 v46 = 2080;
      uint64_t v47 = " ";
      __int16 v48 = 1024;
      int v49 = v31;
      __int16 v50 = 2114;
      uint64_t v51 = a2;
      __int16 v52 = 2114;
      uint64_t v53 = a3;
      _os_log_impl(&dword_1830D4000, v30, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> accepting connection to %{public}@ with %{public}@", buf, 0x3Au);
    }
  }
  return 1;
}

uint64_t nw_protocol_common_waiting_for_output(uint64_t a1, uint64_t a2)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v48 = "nw_protocol_common_waiting_for_output";
    __int16 v15 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (!__nwlog_fault(v15, &type, &v45)) {
      goto LABEL_45;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_45;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v48 = "nw_protocol_common_waiting_for_output";
      os_log_type_t v18 = "%{public}s called with null protocol";
      goto LABEL_43;
    }
    if (!v45)
    {
      uint64_t v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_45;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v48 = "nw_protocol_common_waiting_for_output";
      os_log_type_t v18 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_43;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v16 = __nwlog_obj();
    os_log_type_t v17 = type;
    BOOL v40 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (!v40) {
        goto LABEL_45;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v48 = "nw_protocol_common_waiting_for_output";
      os_log_type_t v18 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_43;
    }
    if (v40)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v48 = "nw_protocol_common_waiting_for_output";
      __int16 v49 = 2082;
      __int16 v50 = backtrace_string;
      char v41 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_82:
      _os_log_impl(&dword_1830D4000, v16, v17, v41, buf, 0x16u);
    }
LABEL_83:
    free(backtrace_string);
    goto LABEL_45;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v48 = "nw_protocol_common_waiting_for_output";
    __int16 v15 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (!__nwlog_fault(v15, &type, &v45)) {
      goto LABEL_45;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_45;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v48 = "nw_protocol_common_waiting_for_output";
      os_log_type_t v18 = "%{public}s called with null other_protocol";
      goto LABEL_43;
    }
    if (!v45)
    {
      uint64_t v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_45;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v48 = "nw_protocol_common_waiting_for_output";
      os_log_type_t v18 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_43;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v16 = __nwlog_obj();
    os_log_type_t v17 = type;
    BOOL v42 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (!v42) {
        goto LABEL_45;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v48 = "nw_protocol_common_waiting_for_output";
      os_log_type_t v18 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_43;
    }
    if (v42)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v48 = "nw_protocol_common_waiting_for_output";
      __int16 v49 = 2082;
      __int16 v50 = backtrace_string;
      char v41 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_82;
    }
    goto LABEL_83;
  }
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3)
  {
    uint64_t v4 = *(void **)(v3 + 40);
    if (v4 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v5 = *(void *)(v3 + 88);
      if (v5) {
        *(void *)(v3 + 88) = v5 + 1;
      }
    }
    uint64_t v6 = *(void **)(a1 + 40);
    if (v6 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v7 = *(void *)(a1 + 88);
      if (v7) {
        *(void *)(a1 + 88) = v7 + 1;
      }
    }
    uint64_t v8 = *(void *)(v3 + 24);
    if (v8)
    {
      os_log_type_t v9 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 216);
      if (v9)
      {
        uint64_t v10 = v9(v3, a1);
        if (v6 != &nw_protocol_ref_counted_handle)
        {
LABEL_14:
          if (v4 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v3 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v11 = *(void *)(v3 + 88);
            if (v11)
            {
              uint64_t v12 = v11 - 1;
              *(void *)(v3 + 88) = v12;
              if (!v12)
              {
                char v13 = *(void (***)(void))(v3 + 64);
                if (v13)
                {
                  *(void *)(v3 + 64) = 0;
                  v13[2](v13);
                  _Block_release(v13);
                }
                if (*(unsigned char *)(v3 + 72))
                {
                  os_log_type_t v14 = *(const void **)(v3 + 64);
                  if (v14) {
                    _Block_release(v14);
                  }
                }
                free((void *)v3);
              }
            }
          }
          return v10;
        }
LABEL_13:
        if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v23 = *(void *)(a1 + 88);
          if (v23)
          {
            uint64_t v24 = v23 - 1;
            *(void *)(a1 + 88) = v24;
            if (!v24)
            {
              char v25 = *(void (***)(void))(a1 + 64);
              if (v25)
              {
                *(void *)(a1 + 64) = 0;
                v25[2](v25);
                _Block_release(v25);
              }
              if (*(unsigned char *)(a1 + 72))
              {
                BOOL v26 = *(const void **)(a1 + 64);
                if (v26) {
                  _Block_release(v26);
                }
              }
              free((void *)a1);
            }
          }
        }
        goto LABEL_14;
      }
    }
    __nwlog_obj();
    char v30 = *(const char **)(v3 + 16);
    *(_DWORD *)buf = 136446722;
    __int16 v48 = "__nw_protocol_waiting_for_output";
    if (!v30) {
      char v30 = "invalid";
    }
    __int16 v49 = 2082;
    __int16 v50 = (void *)v30;
    __int16 v51 = 2048;
    uint64_t v52 = v3;
    int v31 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (__nwlog_fault(v31, &type, &v45))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v32 = __nwlog_obj();
        os_log_type_t v33 = type;
        if (!os_log_type_enabled(v32, type)) {
          goto LABEL_97;
        }
        id v34 = *(const char **)(v3 + 16);
        if (!v34) {
          id v34 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        __int16 v48 = "__nw_protocol_waiting_for_output";
        __int16 v49 = 2082;
        __int16 v50 = (void *)v34;
        __int16 v51 = 2048;
        uint64_t v52 = v3;
        uint64_t v35 = "%{public}s protocol %{public}s (%p) has invalid waiting_for_output callback";
LABEL_96:
        _os_log_impl(&dword_1830D4000, v32, v33, v35, buf, 0x20u);
        goto LABEL_97;
      }
      if (!v45)
      {
        BOOL v32 = __nwlog_obj();
        os_log_type_t v33 = type;
        if (!os_log_type_enabled(v32, type)) {
          goto LABEL_97;
        }
        uint64_t v43 = *(const char **)(v3 + 16);
        if (!v43) {
          uint64_t v43 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        __int16 v48 = "__nw_protocol_waiting_for_output";
        __int16 v49 = 2082;
        __int16 v50 = (void *)v43;
        __int16 v51 = 2048;
        uint64_t v52 = v3;
        uint64_t v35 = "%{public}s protocol %{public}s (%p) has invalid waiting_for_output callback, backtrace limit exceeded";
        goto LABEL_96;
      }
      os_log_type_t v36 = (char *)__nw_create_backtrace_string();
      BOOL v32 = __nwlog_obj();
      os_log_type_t v33 = type;
      BOOL v37 = os_log_type_enabled(v32, type);
      if (!v36)
      {
        if (!v37) {
          goto LABEL_97;
        }
        __int16 v44 = *(const char **)(v3 + 16);
        if (!v44) {
          __int16 v44 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        __int16 v48 = "__nw_protocol_waiting_for_output";
        __int16 v49 = 2082;
        __int16 v50 = (void *)v44;
        __int16 v51 = 2048;
        uint64_t v52 = v3;
        uint64_t v35 = "%{public}s protocol %{public}s (%p) has invalid waiting_for_output callback, no backtrace";
        goto LABEL_96;
      }
      if (v37)
      {
        char v38 = *(const char **)(v3 + 16);
        if (!v38) {
          char v38 = "invalid";
        }
        *(_DWORD *)buf = 136446978;
        __int16 v48 = "__nw_protocol_waiting_for_output";
        __int16 v49 = 2082;
        __int16 v50 = (void *)v38;
        __int16 v51 = 2048;
        uint64_t v52 = v3;
        __int16 v53 = 2082;
        uint64_t v54 = v36;
        _os_log_impl(&dword_1830D4000, v32, v33, "%{public}s protocol %{public}s (%p) has invalid waiting_for_output callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v36);
    }
LABEL_97:
    if (v31) {
      free(v31);
    }
    uint64_t v10 = 0;
    if (v6 != &nw_protocol_ref_counted_handle) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  __int16 v48 = "nw_protocol_common_waiting_for_output";
  __int16 v15 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v45 = 0;
  if (__nwlog_fault(v15, &type, &v45))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v16 = gLogObj;
      os_log_type_t v17 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v48 = "nw_protocol_common_waiting_for_output";
        os_log_type_t v18 = "%{public}s waiting_for_output requires an output handler";
LABEL_43:
        os_log_type_t v27 = v16;
        os_log_type_t v28 = v17;
LABEL_44:
        _os_log_impl(&dword_1830D4000, v27, v28, v18, buf, 0xCu);
      }
    }
    else if (v45)
    {
      uint64_t v19 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v20 = gLogObj;
      os_log_type_t v21 = type;
      BOOL v22 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v19)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v48 = "nw_protocol_common_waiting_for_output";
          __int16 v49 = 2082;
          __int16 v50 = v19;
          _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s waiting_for_output requires an output handler, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v19);
        goto LABEL_45;
      }
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v48 = "nw_protocol_common_waiting_for_output";
        os_log_type_t v18 = "%{public}s waiting_for_output requires an output handler, no backtrace";
        os_log_type_t v27 = v20;
        os_log_type_t v28 = v21;
        goto LABEL_44;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v16 = gLogObj;
      os_log_type_t v17 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v48 = "nw_protocol_common_waiting_for_output";
        os_log_type_t v18 = "%{public}s waiting_for_output requires an output handler, backtrace limit exceeded";
        goto LABEL_43;
      }
    }
  }
LABEL_45:
  if (v15) {
    free(v15);
  }
  return 0;
}

uint64_t nw_protocol_common_register_notification(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v50 = "nw_protocol_common_register_notification";
    uint64_t v16 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v47 = 0;
    if (!__nwlog_fault(v16, &type, &v47)) {
      goto LABEL_46;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v50 = "nw_protocol_common_register_notification";
      uint64_t v19 = "%{public}s called with null protocol";
      goto LABEL_44;
    }
    if (!v47)
    {
      os_log_type_t v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v50 = "nw_protocol_common_register_notification";
      uint64_t v19 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_44;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v17 = __nwlog_obj();
    os_log_type_t v18 = type;
    BOOL v41 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (!v41) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v50 = "nw_protocol_common_register_notification";
      uint64_t v19 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_44;
    }
    if (!v41) {
      goto LABEL_92;
    }
    *(_DWORD *)buf = 136446466;
    __int16 v50 = "nw_protocol_common_register_notification";
    __int16 v51 = 2082;
    uint64_t v52 = backtrace_string;
    BOOL v42 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_91;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v50 = "nw_protocol_common_register_notification";
    uint64_t v16 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v47 = 0;
    if (!__nwlog_fault(v16, &type, &v47)) {
      goto LABEL_46;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v50 = "nw_protocol_common_register_notification";
      uint64_t v19 = "%{public}s called with null other_protocol";
      goto LABEL_44;
    }
    if (!v47)
    {
      os_log_type_t v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v50 = "nw_protocol_common_register_notification";
      uint64_t v19 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_44;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v17 = __nwlog_obj();
    os_log_type_t v18 = type;
    BOOL v43 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (!v43) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v50 = "nw_protocol_common_register_notification";
      uint64_t v19 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_44;
    }
    if (!v43) {
      goto LABEL_92;
    }
    *(_DWORD *)buf = 136446466;
    __int16 v50 = "nw_protocol_common_register_notification";
    __int16 v51 = 2082;
    uint64_t v52 = backtrace_string;
    BOOL v42 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
LABEL_91:
    _os_log_impl(&dword_1830D4000, v17, v18, v42, buf, 0x16u);
    goto LABEL_92;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v50 = "nw_protocol_common_register_notification";
    uint64_t v16 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v47 = 0;
    if (!__nwlog_fault(v16, &type, &v47)) {
      goto LABEL_46;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v50 = "nw_protocol_common_register_notification";
      uint64_t v19 = "%{public}s called with null type";
      goto LABEL_44;
    }
    if (!v47)
    {
      os_log_type_t v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v50 = "nw_protocol_common_register_notification";
      uint64_t v19 = "%{public}s called with null type, backtrace limit exceeded";
      goto LABEL_44;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v17 = __nwlog_obj();
    os_log_type_t v18 = type;
    BOOL v44 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (!v44) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v50 = "nw_protocol_common_register_notification";
      uint64_t v19 = "%{public}s called with null type, no backtrace";
      goto LABEL_44;
    }
    if (v44)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v50 = "nw_protocol_common_register_notification";
      __int16 v51 = 2082;
      uint64_t v52 = backtrace_string;
      BOOL v42 = "%{public}s called with null type, dumping backtrace:%{public}s";
      goto LABEL_91;
    }
LABEL_92:
    free(backtrace_string);
    goto LABEL_46;
  }
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4)
  {
    uint64_t v5 = *(void **)(v4 + 40);
    if (v5 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v6 = *(void *)(v4 + 88);
      if (v6) {
        *(void *)(v4 + 88) = v6 + 1;
      }
    }
    uint64_t v7 = *(void **)(a2 + 40);
    if (v7 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v8 = *(void *)(a2 + 88);
      if (v8) {
        *(void *)(a2 + 88) = v8 + 1;
      }
    }
    uint64_t v9 = *(void *)(v4 + 24);
    if (v9)
    {
      uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 144);
      if (v10)
      {
        uint64_t v11 = v10(v4, a2);
        if (v7 != &nw_protocol_ref_counted_handle)
        {
LABEL_15:
          if (v5 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v4 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v12 = *(void *)(v4 + 88);
            if (v12)
            {
              uint64_t v13 = v12 - 1;
              *(void *)(v4 + 88) = v13;
              if (!v13)
              {
                os_log_type_t v14 = *(void (***)(void))(v4 + 64);
                if (v14)
                {
                  *(void *)(v4 + 64) = 0;
                  v14[2](v14);
                  _Block_release(v14);
                }
                if (*(unsigned char *)(v4 + 72))
                {
                  __int16 v15 = *(const void **)(v4 + 64);
                  if (v15) {
                    _Block_release(v15);
                  }
                }
                free((void *)v4);
              }
            }
          }
          return v11;
        }
LABEL_14:
        if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v24 = *(void *)(a2 + 88);
          if (v24)
          {
            uint64_t v25 = v24 - 1;
            *(void *)(a2 + 88) = v25;
            if (!v25)
            {
              BOOL v26 = *(void (***)(void))(a2 + 64);
              if (v26)
              {
                *(void *)(a2 + 64) = 0;
                v26[2](v26);
                _Block_release(v26);
              }
              if (*(unsigned char *)(a2 + 72))
              {
                os_log_type_t v27 = *(const void **)(a2 + 64);
                if (v27) {
                  _Block_release(v27);
                }
              }
              free((void *)a2);
            }
          }
        }
        goto LABEL_15;
      }
    }
    __nwlog_obj();
    int v31 = *(const char **)(v4 + 16);
    *(_DWORD *)buf = 136446722;
    __int16 v50 = "__nw_protocol_register_notification";
    if (!v31) {
      int v31 = "invalid";
    }
    __int16 v51 = 2082;
    uint64_t v52 = (void *)v31;
    __int16 v53 = 2048;
    uint64_t v54 = v4;
    BOOL v32 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v47 = 0;
    if (__nwlog_fault(v32, &type, &v47))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v33 = __nwlog_obj();
        os_log_type_t v34 = type;
        if (!os_log_type_enabled(v33, type)) {
          goto LABEL_108;
        }
        uint64_t v35 = *(const char **)(v4 + 16);
        if (!v35) {
          uint64_t v35 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        __int16 v50 = "__nw_protocol_register_notification";
        __int16 v51 = 2082;
        uint64_t v52 = (void *)v35;
        __int16 v53 = 2048;
        uint64_t v54 = v4;
        os_log_type_t v36 = "%{public}s protocol %{public}s (%p) has invalid register_notification callback";
LABEL_107:
        _os_log_impl(&dword_1830D4000, v33, v34, v36, buf, 0x20u);
        goto LABEL_108;
      }
      if (!v47)
      {
        os_log_type_t v33 = __nwlog_obj();
        os_log_type_t v34 = type;
        if (!os_log_type_enabled(v33, type)) {
          goto LABEL_108;
        }
        char v45 = *(const char **)(v4 + 16);
        if (!v45) {
          char v45 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        __int16 v50 = "__nw_protocol_register_notification";
        __int16 v51 = 2082;
        uint64_t v52 = (void *)v45;
        __int16 v53 = 2048;
        uint64_t v54 = v4;
        os_log_type_t v36 = "%{public}s protocol %{public}s (%p) has invalid register_notification callback, backtrace limit exceeded";
        goto LABEL_107;
      }
      BOOL v37 = (char *)__nw_create_backtrace_string();
      os_log_type_t v33 = __nwlog_obj();
      os_log_type_t v34 = type;
      BOOL v38 = os_log_type_enabled(v33, type);
      if (!v37)
      {
        if (!v38) {
          goto LABEL_108;
        }
        __int16 v46 = *(const char **)(v4 + 16);
        if (!v46) {
          __int16 v46 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        __int16 v50 = "__nw_protocol_register_notification";
        __int16 v51 = 2082;
        uint64_t v52 = (void *)v46;
        __int16 v53 = 2048;
        uint64_t v54 = v4;
        os_log_type_t v36 = "%{public}s protocol %{public}s (%p) has invalid register_notification callback, no backtrace";
        goto LABEL_107;
      }
      if (v38)
      {
        os_log_type_t v39 = *(const char **)(v4 + 16);
        if (!v39) {
          os_log_type_t v39 = "invalid";
        }
        *(_DWORD *)buf = 136446978;
        __int16 v50 = "__nw_protocol_register_notification";
        __int16 v51 = 2082;
        uint64_t v52 = (void *)v39;
        __int16 v53 = 2048;
        uint64_t v54 = v4;
        __int16 v55 = 2082;
        uint64_t v56 = v37;
        _os_log_impl(&dword_1830D4000, v33, v34, "%{public}s protocol %{public}s (%p) has invalid register_notification callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v37);
    }
LABEL_108:
    if (v32) {
      free(v32);
    }
    uint64_t v11 = 0;
    if (v7 != &nw_protocol_ref_counted_handle) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  __int16 v50 = "nw_protocol_common_register_notification";
  uint64_t v16 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v47 = 0;
  if (__nwlog_fault(v16, &type, &v47))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v17 = gLogObj;
      os_log_type_t v18 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v50 = "nw_protocol_common_register_notification";
        uint64_t v19 = "%{public}s register_notification requires an output handler";
LABEL_44:
        os_log_type_t v28 = v17;
        os_log_type_t v29 = v18;
LABEL_45:
        _os_log_impl(&dword_1830D4000, v28, v29, v19, buf, 0xCu);
      }
    }
    else if (v47)
    {
      id v20 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v21 = gLogObj;
      os_log_type_t v22 = type;
      BOOL v23 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v20)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v50 = "nw_protocol_common_register_notification";
          __int16 v51 = 2082;
          uint64_t v52 = v20;
          _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s register_notification requires an output handler, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v20);
        goto LABEL_46;
      }
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v50 = "nw_protocol_common_register_notification";
        uint64_t v19 = "%{public}s register_notification requires an output handler, no backtrace";
        os_log_type_t v28 = v21;
        os_log_type_t v29 = v22;
        goto LABEL_45;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v17 = gLogObj;
      os_log_type_t v18 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v50 = "nw_protocol_common_register_notification";
        uint64_t v19 = "%{public}s register_notification requires an output handler, backtrace limit exceeded";
        goto LABEL_44;
      }
    }
  }
LABEL_46:
  if (v16) {
    free(v16);
  }
  return 0;
}

void nw_protocol_common_input_finished(uint64_t a1, uint64_t a2)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v45 = "nw_protocol_common_input_finished";
    uint64_t v3 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (!__nwlog_fault((const char *)v3, &type, &v42)) {
      goto LABEL_46;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      char v45 = "nw_protocol_common_input_finished";
      uint64_t v16 = "%{public}s called with null protocol";
      goto LABEL_44;
    }
    if (v42)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v37 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (!v37) {
          goto LABEL_83;
        }
        *(_DWORD *)buf = 136446466;
        char v45 = "nw_protocol_common_input_finished";
        __int16 v46 = 2082;
        char v47 = backtrace_string;
        BOOL v38 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
        goto LABEL_82;
      }
      if (!v37) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      char v45 = "nw_protocol_common_input_finished";
      uint64_t v16 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      char v45 = "nw_protocol_common_input_finished";
      uint64_t v16 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_44:
    uint64_t v25 = v14;
    os_log_type_t v26 = v15;
LABEL_45:
    _os_log_impl(&dword_1830D4000, v25, v26, v16, buf, 0xCu);
    goto LABEL_46;
  }
  if (a2)
  {
    uint64_t v3 = *(void *)(a1 + 48);
    if (v3)
    {
      uint64_t v4 = *(void **)(v3 + 40);
      if (v4 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v5 = *(void *)(v3 + 88);
        if (v5) {
          *(void *)(v3 + 88) = v5 + 1;
        }
      }
      uint64_t v6 = *(void **)(a2 + 40);
      if (v6 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v7 = *(void *)(a2 + 88);
        if (v7) {
          *(void *)(a2 + 88) = v7 + 1;
        }
      }
      uint64_t v8 = *(void *)(v3 + 24);
      if (v8)
      {
        uint64_t v9 = *(void (**)(uint64_t, uint64_t))(v8 + 184);
        if (v9)
        {
          v9(v3, a2);
          goto LABEL_13;
        }
      }
      __nwlog_obj();
      os_log_type_t v27 = *(const char **)(v3 + 16);
      *(_DWORD *)buf = 136446722;
      char v45 = "__nw_protocol_input_finished";
      if (!v27) {
        os_log_type_t v27 = "invalid";
      }
      __int16 v46 = 2082;
      char v47 = (void *)v27;
      __int16 v48 = 2048;
      uint64_t v49 = v3;
      os_log_type_t v28 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v42 = 0;
      if (__nwlog_fault(v28, &type, &v42))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v29 = __nwlog_obj();
          os_log_type_t v30 = type;
          if (!os_log_type_enabled(v29, type)) {
            goto LABEL_98;
          }
          int v31 = *(const char **)(v3 + 16);
          if (!v31) {
            int v31 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          char v45 = "__nw_protocol_input_finished";
          __int16 v46 = 2082;
          char v47 = (void *)v31;
          __int16 v48 = 2048;
          uint64_t v49 = v3;
          BOOL v32 = "%{public}s protocol %{public}s (%p) has invalid input_finished callback";
          goto LABEL_97;
        }
        if (!v42)
        {
          os_log_type_t v29 = __nwlog_obj();
          os_log_type_t v30 = type;
          if (!os_log_type_enabled(v29, type)) {
            goto LABEL_98;
          }
          BOOL v40 = *(const char **)(v3 + 16);
          if (!v40) {
            BOOL v40 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          char v45 = "__nw_protocol_input_finished";
          __int16 v46 = 2082;
          char v47 = (void *)v40;
          __int16 v48 = 2048;
          uint64_t v49 = v3;
          BOOL v32 = "%{public}s protocol %{public}s (%p) has invalid input_finished callback, backtrace limit exceeded";
          goto LABEL_97;
        }
        os_log_type_t v33 = (char *)__nw_create_backtrace_string();
        os_log_type_t v29 = __nwlog_obj();
        os_log_type_t v30 = type;
        BOOL v34 = os_log_type_enabled(v29, type);
        if (v33)
        {
          if (v34)
          {
            uint64_t v35 = *(const char **)(v3 + 16);
            if (!v35) {
              uint64_t v35 = "invalid";
            }
            *(_DWORD *)buf = 136446978;
            char v45 = "__nw_protocol_input_finished";
            __int16 v46 = 2082;
            char v47 = (void *)v35;
            __int16 v48 = 2048;
            uint64_t v49 = v3;
            __int16 v50 = 2082;
            __int16 v51 = v33;
            _os_log_impl(&dword_1830D4000, v29, v30, "%{public}s protocol %{public}s (%p) has invalid input_finished callback, dumping backtrace:%{public}s", buf, 0x2Au);
          }
          free(v33);
          goto LABEL_98;
        }
        if (v34)
        {
          BOOL v41 = *(const char **)(v3 + 16);
          if (!v41) {
            BOOL v41 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          char v45 = "__nw_protocol_input_finished";
          __int16 v46 = 2082;
          char v47 = (void *)v41;
          __int16 v48 = 2048;
          uint64_t v49 = v3;
          BOOL v32 = "%{public}s protocol %{public}s (%p) has invalid input_finished callback, no backtrace";
LABEL_97:
          _os_log_impl(&dword_1830D4000, v29, v30, v32, buf, 0x20u);
        }
      }
LABEL_98:
      if (v28) {
        free(v28);
      }
LABEL_13:
      if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
      {
        uint64_t v21 = *(void *)(a2 + 88);
        if (v21)
        {
          uint64_t v22 = v21 - 1;
          *(void *)(a2 + 88) = v22;
          if (!v22)
          {
            BOOL v23 = *(void (***)(void))(a2 + 64);
            if (v23)
            {
              *(void *)(a2 + 64) = 0;
              v23[2](v23);
              _Block_release(v23);
            }
            if (*(unsigned char *)(a2 + 72))
            {
              uint64_t v24 = *(const void **)(a2 + 64);
              if (v24) {
                _Block_release(v24);
              }
            }
            free((void *)a2);
          }
        }
      }
      if (v4 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v3 + 40) == &nw_protocol_ref_counted_handle)
      {
        uint64_t v10 = *(void *)(v3 + 88);
        if (v10)
        {
          uint64_t v11 = v10 - 1;
          *(void *)(v3 + 88) = v11;
          if (!v11)
          {
            uint64_t v12 = *(void (***)(void))(v3 + 64);
            if (v12)
            {
              *(void *)(v3 + 64) = 0;
              v12[2](v12);
              _Block_release(v12);
            }
            if (*(unsigned char *)(v3 + 72))
            {
              uint64_t v13 = *(const void **)(v3 + 64);
              if (v13) {
                _Block_release(v13);
              }
            }
            goto LABEL_47;
          }
        }
      }
      return;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    char v45 = "nw_protocol_common_input_finished";
    uint64_t v3 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v42))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v14 = gLogObj;
        os_log_type_t v15 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_46;
        }
        *(_DWORD *)buf = 136446210;
        char v45 = "nw_protocol_common_input_finished";
        uint64_t v16 = "%{public}s input_finished requires a default input handler";
        goto LABEL_44;
      }
      if (!v42)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v14 = gLogObj;
        os_log_type_t v15 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_46;
        }
        *(_DWORD *)buf = 136446210;
        char v45 = "nw_protocol_common_input_finished";
        uint64_t v16 = "%{public}s input_finished requires a default input handler, backtrace limit exceeded";
        goto LABEL_44;
      }
      os_log_type_t v17 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v18 = gLogObj;
      os_log_type_t v19 = type;
      BOOL v20 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v17)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          char v45 = "nw_protocol_common_input_finished";
          __int16 v46 = 2082;
          char v47 = v17;
          _os_log_impl(&dword_1830D4000, v18, v19, "%{public}s input_finished requires a default input handler, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v17);
        if (v3) {
          goto LABEL_47;
        }
        return;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        char v45 = "nw_protocol_common_input_finished";
        uint64_t v16 = "%{public}s input_finished requires a default input handler, no backtrace";
        uint64_t v25 = v18;
        os_log_type_t v26 = v19;
        goto LABEL_45;
      }
    }
LABEL_46:
    if (!v3) {
      return;
    }
    goto LABEL_47;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v45 = "nw_protocol_common_input_finished";
  uint64_t v3 = _os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v42 = 0;
  if (!__nwlog_fault((const char *)v3, &type, &v42)) {
    goto LABEL_46;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v14 = __nwlog_obj();
    os_log_type_t v15 = type;
    if (!os_log_type_enabled(v14, type)) {
      goto LABEL_46;
    }
    *(_DWORD *)buf = 136446210;
    char v45 = "nw_protocol_common_input_finished";
    uint64_t v16 = "%{public}s called with null other_protocol";
    goto LABEL_44;
  }
  if (!v42)
  {
    os_log_type_t v14 = __nwlog_obj();
    os_log_type_t v15 = type;
    if (!os_log_type_enabled(v14, type)) {
      goto LABEL_46;
    }
    *(_DWORD *)buf = 136446210;
    char v45 = "nw_protocol_common_input_finished";
    uint64_t v16 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    goto LABEL_44;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  os_log_type_t v14 = __nwlog_obj();
  os_log_type_t v15 = type;
  BOOL v39 = os_log_type_enabled(v14, type);
  if (!backtrace_string)
  {
    if (!v39) {
      goto LABEL_46;
    }
    *(_DWORD *)buf = 136446210;
    char v45 = "nw_protocol_common_input_finished";
    uint64_t v16 = "%{public}s called with null other_protocol, no backtrace";
    goto LABEL_44;
  }
  if (!v39) {
    goto LABEL_83;
  }
  *(_DWORD *)buf = 136446466;
  char v45 = "nw_protocol_common_input_finished";
  __int16 v46 = 2082;
  char v47 = backtrace_string;
  BOOL v38 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
LABEL_82:
  _os_log_impl(&dword_1830D4000, v14, v15, v38, buf, 0x16u);
LABEL_83:
  free(backtrace_string);
  if (v3) {
LABEL_47:
  }
    free((void *)v3);
}

void nw_protocol_common_connected(uint64_t a1, uint64_t a2)
{
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v76 = "nw_protocol_common_connected";
    BOOL v23 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v73 = 0;
    if (!__nwlog_fault(v23, &type, &v73)) {
      goto LABEL_70;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v73)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v24 = __nwlog_obj();
        os_log_type_t v25 = type;
        BOOL v55 = os_log_type_enabled(v24, type);
        if (backtrace_string)
        {
          if (v55)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v76 = "nw_protocol_common_connected";
            __int16 v77 = 2082;
            BOOL v78 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
        }
        else if (v55)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v76 = "nw_protocol_common_connected";
          os_log_type_t v26 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_68;
        }
      }
      else
      {
        uint64_t v24 = __nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v76 = "nw_protocol_common_connected";
          os_log_type_t v26 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_68;
        }
      }
      goto LABEL_70;
    }
    uint64_t v24 = __nwlog_obj();
    os_log_type_t v25 = type;
    if (!os_log_type_enabled(v24, type)) {
      goto LABEL_70;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v76 = "nw_protocol_common_connected";
    os_log_type_t v26 = "%{public}s called with null protocol";
    goto LABEL_68;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v76 = "nw_protocol_common_connected";
    BOOL v23 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v73 = 0;
    if (!__nwlog_fault(v23, &type, &v73)) {
      goto LABEL_70;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v73)
      {
        uint64_t v24 = __nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v76 = "nw_protocol_common_connected";
          os_log_type_t v26 = "%{public}s called with null other_protocol, backtrace limit exceeded";
          goto LABEL_68;
        }
        goto LABEL_70;
      }
      uint64_t v56 = (char *)__nw_create_backtrace_string();
      uint64_t v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      BOOL v57 = os_log_type_enabled(v24, type);
      if (!v56)
      {
        if (v57)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v76 = "nw_protocol_common_connected";
          os_log_type_t v26 = "%{public}s called with null other_protocol, no backtrace";
          goto LABEL_68;
        }
        goto LABEL_70;
      }
      if (!v57) {
        goto LABEL_117;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v76 = "nw_protocol_common_connected";
      __int16 v77 = 2082;
      BOOL v78 = v56;
      os_log_type_t v58 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
LABEL_116:
      _os_log_impl(&dword_1830D4000, v24, v25, v58, buf, 0x16u);
LABEL_117:
      free(v56);
      if (!v23) {
        return;
      }
      goto LABEL_71;
    }
    uint64_t v24 = __nwlog_obj();
    os_log_type_t v25 = type;
    if (!os_log_type_enabled(v24, type)) {
      goto LABEL_70;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v76 = "nw_protocol_common_connected";
    os_log_type_t v26 = "%{public}s called with null other_protocol";
LABEL_68:
    BOOL v39 = v24;
    os_log_type_t v40 = v25;
LABEL_69:
    _os_log_impl(&dword_1830D4000, v39, v40, v26, buf, 0xCu);
    goto LABEL_70;
  }
  uint64_t v4 = *(void *)(a1 + 48);
  if (!v4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v76 = "nw_protocol_common_connected";
    BOOL v23 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v73 = 0;
    if (!__nwlog_fault(v23, &type, &v73)) {
      goto LABEL_70;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v24 = gLogObj;
      os_log_type_t v25 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_70;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v76 = "nw_protocol_common_connected";
      os_log_type_t v26 = "%{public}s connected requires a default input handler";
      goto LABEL_68;
    }
    if (!v73)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v24 = gLogObj;
      os_log_type_t v25 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_70;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v76 = "nw_protocol_common_connected";
      os_log_type_t v26 = "%{public}s connected requires a default input handler, backtrace limit exceeded";
      goto LABEL_68;
    }
    os_log_type_t v27 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v28 = gLogObj;
    os_log_type_t v29 = type;
    BOOL v30 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v27)
    {
      if (v30)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v76 = "nw_protocol_common_connected";
        os_log_type_t v26 = "%{public}s connected requires a default input handler, no backtrace";
        BOOL v39 = v28;
        os_log_type_t v40 = v29;
        goto LABEL_69;
      }
      goto LABEL_70;
    }
    if (v30)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v76 = "nw_protocol_common_connected";
      __int16 v77 = 2082;
      BOOL v78 = v27;
      _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s connected requires a default input handler, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v27);
    if (!v23) {
      return;
    }
LABEL_71:
    uint64_t v22 = (char *)v23;
LABEL_72:
    free(v22);
    return;
  }
  uint64_t v5 = *(void **)(v4 + 40);
  if (v5 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v6 = *(void *)(v4 + 88);
    if (v6) {
      *(void *)(v4 + 88) = v6 + 1;
    }
  }
  uint64_t v7 = *(void **)(a2 + 40);
  if (v7 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v8 = *(void *)(a2 + 88);
    if (v8) {
      *(void *)(a2 + 88) = v8 + 1;
    }
  }
  uint64_t v9 = *(void *)(v4 + 24);
  if (v9)
  {
    uint64_t v10 = *(void (**)(uint64_t, uint64_t))(v9 + 40);
    if (v10)
    {
      v10(v4, a2);
      goto LABEL_13;
    }
  }
  __nwlog_obj();
  char v45 = *(const char **)(v4 + 16);
  *(_DWORD *)buf = 136446722;
  os_log_type_t v76 = "__nw_protocol_connected";
  if (!v45) {
    char v45 = "invalid";
  }
  __int16 v77 = 2082;
  BOOL v78 = (void *)v45;
  __int16 v79 = 2048;
  uint64_t v80 = v4;
  __int16 v46 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v73 = 0;
  if (__nwlog_fault(v46, &type, &v73))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v47 = __nwlog_obj();
      os_log_type_t v48 = type;
      if (!os_log_type_enabled(v47, type)) {
        goto LABEL_151;
      }
      uint64_t v49 = *(const char **)(v4 + 16);
      if (!v49) {
        uint64_t v49 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v76 = "__nw_protocol_connected";
      __int16 v77 = 2082;
      BOOL v78 = (void *)v49;
      __int16 v79 = 2048;
      uint64_t v80 = v4;
      __int16 v50 = "%{public}s protocol %{public}s (%p) has invalid connected callback";
      goto LABEL_150;
    }
    if (!v73)
    {
      char v47 = __nwlog_obj();
      os_log_type_t v48 = type;
      if (!os_log_type_enabled(v47, type)) {
        goto LABEL_151;
      }
      os_log_type_t v65 = *(const char **)(v4 + 16);
      if (!v65) {
        os_log_type_t v65 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v76 = "__nw_protocol_connected";
      __int16 v77 = 2082;
      BOOL v78 = (void *)v65;
      __int16 v79 = 2048;
      uint64_t v80 = v4;
      __int16 v50 = "%{public}s protocol %{public}s (%p) has invalid connected callback, backtrace limit exceeded";
      goto LABEL_150;
    }
    __int16 v51 = (char *)__nw_create_backtrace_string();
    char v47 = __nwlog_obj();
    os_log_type_t v48 = type;
    BOOL v52 = os_log_type_enabled(v47, type);
    if (v51)
    {
      if (v52)
      {
        __int16 v53 = *(const char **)(v4 + 16);
        if (!v53) {
          __int16 v53 = "invalid";
        }
        *(_DWORD *)buf = 136446978;
        os_log_type_t v76 = "__nw_protocol_connected";
        __int16 v77 = 2082;
        BOOL v78 = (void *)v53;
        __int16 v79 = 2048;
        uint64_t v80 = v4;
        __int16 v81 = 2082;
        os_log_type_t v82 = v51;
        _os_log_impl(&dword_1830D4000, v47, v48, "%{public}s protocol %{public}s (%p) has invalid connected callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v51);
      goto LABEL_151;
    }
    if (v52)
    {
      os_log_type_t v69 = *(const char **)(v4 + 16);
      if (!v69) {
        os_log_type_t v69 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v76 = "__nw_protocol_connected";
      __int16 v77 = 2082;
      BOOL v78 = (void *)v69;
      __int16 v79 = 2048;
      uint64_t v80 = v4;
      __int16 v50 = "%{public}s protocol %{public}s (%p) has invalid connected callback, no backtrace";
LABEL_150:
      _os_log_impl(&dword_1830D4000, v47, v48, v50, buf, 0x20u);
    }
  }
LABEL_151:
  if (v46) {
    free(v46);
  }
LABEL_13:
  if (v7 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
  {
    uint64_t v31 = *(void *)(a2 + 88);
    if (v31)
    {
      uint64_t v32 = v31 - 1;
      *(void *)(a2 + 88) = v32;
      if (!v32)
      {
        os_log_type_t v33 = *(void (***)(void))(a2 + 64);
        if (v33)
        {
          *(void *)(a2 + 64) = 0;
          v33[2](v33);
          _Block_release(v33);
        }
        if (*(unsigned char *)(a2 + 72))
        {
          BOOL v34 = *(const void **)(a2 + 64);
          if (v34) {
            _Block_release(v34);
          }
        }
        free((void *)a2);
      }
    }
  }
  if (v5 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v4 + 40) == &nw_protocol_ref_counted_handle)
  {
    uint64_t v35 = *(void *)(v4 + 88);
    if (v35)
    {
      uint64_t v36 = v35 - 1;
      *(void *)(v4 + 88) = v36;
      if (!v36)
      {
        BOOL v37 = *(void (***)(void))(v4 + 64);
        if (v37)
        {
          *(void *)(v4 + 64) = 0;
          v37[2](v37);
          _Block_release(v37);
        }
        if (*(unsigned char *)(v4 + 72))
        {
          BOOL v38 = *(const void **)(v4 + 64);
          if (v38) {
            _Block_release(v38);
          }
        }
        free((void *)v4);
      }
    }
  }
  if (*(void *)(a1 + 32) != a2) {
    return;
  }
  uint64_t v11 = *(void *)(a1 + 48);
  if (!v11)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v76 = "__nw_protocol_connected";
    BOOL v23 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v73 = 0;
    if (!__nwlog_fault(v23, &type, &v73)) {
      goto LABEL_70;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v76 = "__nw_protocol_connected";
        os_log_type_t v26 = "%{public}s called with null protocol";
        goto LABEL_68;
      }
LABEL_70:
      if (!v23) {
        return;
      }
      goto LABEL_71;
    }
    if (!v73)
    {
      uint64_t v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v76 = "__nw_protocol_connected";
        os_log_type_t v26 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_68;
      }
      goto LABEL_70;
    }
    uint64_t v56 = (char *)__nw_create_backtrace_string();
    uint64_t v24 = __nwlog_obj();
    os_log_type_t v25 = type;
    BOOL v70 = os_log_type_enabled(v24, type);
    if (!v56)
    {
      if (v70)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v76 = "__nw_protocol_connected";
        os_log_type_t v26 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_68;
      }
      goto LABEL_70;
    }
    if (!v70) {
      goto LABEL_117;
    }
    *(_DWORD *)buf = 136446466;
    os_log_type_t v76 = "__nw_protocol_connected";
    __int16 v77 = 2082;
    BOOL v78 = v56;
    os_log_type_t v58 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_116;
  }
  uint64_t v12 = *(void **)(v11 + 40);
  if (v12 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v13 = *(void *)(v11 + 88);
    if (v13) {
      *(void *)(v11 + 88) = v13 + 1;
    }
  }
  os_log_type_t v14 = *(void **)(a1 + 40);
  if (v14 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v15 = *(void *)(a1 + 88);
    if (v15) {
      *(void *)(a1 + 88) = v15 + 1;
    }
  }
  uint64_t v16 = *(void *)(v11 + 24);
  if (v16)
  {
    os_log_type_t v17 = *(void (**)(uint64_t, uint64_t))(v16 + 40);
    if (v17)
    {
      v17(v11, a1);
      goto LABEL_28;
    }
  }
  __nwlog_obj();
  BOOL v59 = *(const char **)(v11 + 16);
  *(_DWORD *)buf = 136446722;
  os_log_type_t v76 = "__nw_protocol_connected";
  if (!v59) {
    BOOL v59 = "invalid";
  }
  __int16 v77 = 2082;
  BOOL v78 = (void *)v59;
  __int16 v79 = 2048;
  uint64_t v80 = v11;
  os_log_type_t v60 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v73 = 0;
  if (__nwlog_fault(v60, &type, &v73))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v61 = __nwlog_obj();
      os_log_type_t v62 = type;
      if (!os_log_type_enabled(v61, type)) {
        goto LABEL_170;
      }
      os_log_type_t v63 = *(const char **)(v11 + 16);
      if (!v63) {
        os_log_type_t v63 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v76 = "__nw_protocol_connected";
      __int16 v77 = 2082;
      BOOL v78 = (void *)v63;
      __int16 v79 = 2048;
      uint64_t v80 = v11;
      os_log_type_t v64 = "%{public}s protocol %{public}s (%p) has invalid connected callback";
      goto LABEL_169;
    }
    if (!v73)
    {
      BOOL v61 = __nwlog_obj();
      os_log_type_t v62 = type;
      if (!os_log_type_enabled(v61, type)) {
        goto LABEL_170;
      }
      os_log_type_t v71 = *(const char **)(v11 + 16);
      if (!v71) {
        os_log_type_t v71 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v76 = "__nw_protocol_connected";
      __int16 v77 = 2082;
      BOOL v78 = (void *)v71;
      __int16 v79 = 2048;
      uint64_t v80 = v11;
      os_log_type_t v64 = "%{public}s protocol %{public}s (%p) has invalid connected callback, backtrace limit exceeded";
      goto LABEL_169;
    }
    BOOL v66 = (char *)__nw_create_backtrace_string();
    BOOL v61 = __nwlog_obj();
    os_log_type_t v62 = type;
    BOOL v67 = os_log_type_enabled(v61, type);
    if (v66)
    {
      if (v67)
      {
        id v68 = *(const char **)(v11 + 16);
        if (!v68) {
          id v68 = "invalid";
        }
        *(_DWORD *)buf = 136446978;
        os_log_type_t v76 = "__nw_protocol_connected";
        __int16 v77 = 2082;
        BOOL v78 = (void *)v68;
        __int16 v79 = 2048;
        uint64_t v80 = v11;
        __int16 v81 = 2082;
        os_log_type_t v82 = v66;
        _os_log_impl(&dword_1830D4000, v61, v62, "%{public}s protocol %{public}s (%p) has invalid connected callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v66);
      goto LABEL_170;
    }
    if (v67)
    {
      id v72 = *(const char **)(v11 + 16);
      if (!v72) {
        id v72 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v76 = "__nw_protocol_connected";
      __int16 v77 = 2082;
      BOOL v78 = (void *)v72;
      __int16 v79 = 2048;
      uint64_t v80 = v11;
      os_log_type_t v64 = "%{public}s protocol %{public}s (%p) has invalid connected callback, no backtrace";
LABEL_169:
      _os_log_impl(&dword_1830D4000, v61, v62, v64, buf, 0x20u);
    }
  }
LABEL_170:
  if (v60) {
    free(v60);
  }
LABEL_28:
  if (v14 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
  {
    uint64_t v41 = *(void *)(a1 + 88);
    if (v41)
    {
      uint64_t v42 = v41 - 1;
      *(void *)(a1 + 88) = v42;
      if (!v42)
      {
        BOOL v43 = *(void (***)(void))(a1 + 64);
        if (v43)
        {
          *(void *)(a1 + 64) = 0;
          v43[2](v43);
          _Block_release(v43);
        }
        if (*(unsigned char *)(a1 + 72))
        {
          BOOL v44 = *(const void **)(a1 + 64);
          if (v44) {
            _Block_release(v44);
          }
        }
        free((void *)a1);
      }
    }
  }
  if (v12 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v11 + 40) == &nw_protocol_ref_counted_handle)
  {
    uint64_t v18 = *(void *)(v11 + 88);
    if (v18)
    {
      uint64_t v19 = v18 - 1;
      *(void *)(v11 + 88) = v19;
      if (!v19)
      {
        BOOL v20 = *(void (***)(void))(v11 + 64);
        if (v20)
        {
          *(void *)(v11 + 64) = 0;
          v20[2](v20);
          _Block_release(v20);
        }
        if (*(unsigned char *)(v11 + 72))
        {
          uint64_t v21 = *(const void **)(v11 + 64);
          if (v21) {
            _Block_release(v21);
          }
        }
        uint64_t v22 = (char *)v11;
        goto LABEL_72;
      }
    }
  }
}

id nw_path_copy_proxy_config_for_agent_uuid(const unsigned __int8 *a1, unsigned int a2, void *a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v5 = a3;
  if (!uuid_is_null(a1))
  {
    *(void *)buf = 0;

    id v6 = *(id *)buf;
    goto LABEL_3;
  }
  uint64_t v8 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_path_copy_proxy_config_for_agent_uuid";
  uint64_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_copy_proxy_config_for_agent_uuid";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null (!uuid_is_null(agent_uuid))", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v10 = __nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_path_copy_proxy_config_for_agent_uuid";
          __int16 v19 = 2082;
          BOOL v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null (!uuid_is_null(agent_uuid)), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_copy_proxy_config_for_agent_uuid";
        _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null (!uuid_is_null(agent_uuid)), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v10 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_copy_proxy_config_for_agent_uuid";
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null (!uuid_is_null(agent_uuid)), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v9) {
    free(v9);
  }
  id v6 = 0;
LABEL_3:

  return v6;
}

void sub_18346541C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void nw_parameters_prohibit_interface_type(nw_parameters_t parameters, nw_interface_type_t interface_type)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  nw_parameters_t v3 = parameters;
  p_uint64_t isa = &v3->isa;
  if (!v3)
  {
    os_log_type_t v13 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_parameters_prohibit_interface_type";
    BOOL v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (!__nwlog_fault(v14, &type, &v32)) {
      goto LABEL_47;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_parameters_prohibit_interface_type";
        _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v32)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v15 = __nwlog_obj();
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v15, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_parameters_prohibit_interface_type";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v15, v18, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_47;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_parameters_prohibit_interface_type";
        _os_log_impl(&dword_1830D4000, v15, v18, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v15 = __nwlog_obj();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_parameters_prohibit_interface_type";
        _os_log_impl(&dword_1830D4000, v15, v28, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_47;
  }
  id v5 = (void **)*((void *)v3[13].isa + 22);
  if (v5)
  {
    id v6 = *v5;
    if (!*v5) {
      goto LABEL_9;
    }
    goto LABEL_7;
  }
  uint64_t v7 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
  if (v7)
  {
LABEL_6:
    *(void *)(p_isa[13] + 176) = v7;
    id v6 = **(void ***)(p_isa[13] + 176);
    if (!v6) {
      goto LABEL_9;
    }
LABEL_7:
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000;
    LOBYTE(v35) = 0;
    applier[0] = MEMORY[0x1E4F143A8];
    applier[1] = 3221225472;
    applier[2] = __nw_parameters_prohibit_interface_type_block_invoke;
    applier[3] = &unk_1E523D250;
    nw_interface_type_t v31 = interface_type;
    applier[4] = buf;
    xpc_array_apply(v6, applier);
    int v8 = *(unsigned __int8 *)(*(void *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    if (v8)
    {
LABEL_11:

      return;
    }
    uint64_t v9 = **(void ***)(p_isa[13] + 176);
    if (v9)
    {
LABEL_10:
      xpc_array_set_uint64(v9, 0xFFFFFFFFFFFFFFFFLL, interface_type);
      goto LABEL_11;
    }
LABEL_9:
    xpc_object_t v10 = xpc_array_create(0, 0);
    os_log_type_t v11 = *(void ***)(p_isa[13] + 176);
    uint64_t v12 = *v11;
    *os_log_type_t v11 = v10;

    uint64_t v9 = **(void ***)(p_isa[13] + 176);
    if (v9) {
      goto LABEL_10;
    }
    BOOL v20 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_parameters_prohibit_interface_type";
    BOOL v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (__nwlog_fault(v14, &type, &v32))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v21 = __nwlog_obj();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_parameters_prohibit_interface_type";
          _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s called with null parameters->path_parameters->extended_objects->prohibited_interface_types", buf, 0xCu);
        }
      }
      else if (v32)
      {
        os_log_type_t v25 = (char *)__nw_create_backtrace_string();
        uint64_t v21 = __nwlog_obj();
        os_log_type_t v26 = type;
        BOOL v27 = os_log_type_enabled(v21, type);
        if (v25)
        {
          if (v27)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_parameters_prohibit_interface_type";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v25;
            _os_log_impl(&dword_1830D4000, v21, v26, "%{public}s called with null parameters->path_parameters->extended_objects->prohibited_interface_types, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v25);
          if (!v14) {
            goto LABEL_11;
          }
          goto LABEL_48;
        }
        if (v27)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_parameters_prohibit_interface_type";
          _os_log_impl(&dword_1830D4000, v21, v26, "%{public}s called with null parameters->path_parameters->extended_objects->prohibited_interface_types, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v21 = __nwlog_obj();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_parameters_prohibit_interface_type";
          _os_log_impl(&dword_1830D4000, v21, v29, "%{public}s called with null parameters->path_parameters->extended_objects->prohibited_interface_types, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_47:
    if (!v14) {
      goto LABEL_11;
    }
LABEL_48:
    free(v14);
    goto LABEL_11;
  }
  BOOL v23 = __nwlog_obj();
  os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  *(void *)&uint8_t buf[4] = "strict_calloc";
  *(_WORD *)&unsigned char buf[12] = 2048;
  *(void *)&buf[14] = 1;
  *(_WORD *)&buf[22] = 2048;
  uint64_t v35 = 144;
  uint64_t v24 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v24))
  {
    free(v24);
    goto LABEL_6;
  }
  __break(1u);
}

void sub_183465AB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

id nw_parameters_find_http_messaging_options(void *a1, uint64_t a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  nw_parameters_t v3 = a1;
  uint64_t v4 = v3;
  if (v3)
  {
    id v5 = nw_parameters_copy_default_protocol_stack(v3);
    *(void *)os_log_type_t type = 0;
    os_log_type_t v18 = type;
    uint64_t v19 = 0x2020000000;
    char v20 = 0;
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000;
    BOOL v23 = __Block_byref_object_copy__5_73857;
    uint64_t v24 = __Block_byref_object_dispose__6_73858;
    id v25 = 0;
    iterate_block[0] = MEMORY[0x1E4F143A8];
    iterate_block[1] = 3221225472;
    iterate_block[2] = __nw_parameters_find_http_messaging_options_block_invoke;
    iterate_block[3] = &unk_1E52490C0;
    iterate_void block[4] = type;
    iterate_block[5] = buf;
    iterate_block[6] = a2;
    nw_protocol_stack_iterate_application_protocols(v5, iterate_block);
    id v6 = *(id *)(*(void *)&buf[8] + 40);
    _Block_object_dispose(buf, 8);

    _Block_object_dispose(type, 8);
    goto LABEL_3;
  }
  int v8 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_parameters_find_http_messaging_options";
  uint64_t v9 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  char v21 = 0;
  if (__nwlog_fault(v9, type, &v21))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      xpc_object_t v10 = __nwlog_obj();
      os_log_type_t v11 = type[0];
      if (os_log_type_enabled(v10, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_parameters_find_http_messaging_options";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      xpc_object_t v10 = __nwlog_obj();
      os_log_type_t v13 = type[0];
      BOOL v14 = os_log_type_enabled(v10, type[0]);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_parameters_find_http_messaging_options";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_parameters_find_http_messaging_options";
        _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      xpc_object_t v10 = __nwlog_obj();
      os_log_type_t v15 = type[0];
      if (os_log_type_enabled(v10, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_parameters_find_http_messaging_options";
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v9) {
    free(v9);
  }
  id v6 = 0;
LABEL_3:

  return v6;
}

NSObject *nw_parameters_create_secure_http_messaging(void *a1, void *a2, void *a3, void *a4, void *a5)
{
  uint64_t v166 = *MEMORY[0x1E4F143B8];
  id v9 = a1;
  xpc_object_t v10 = a2;
  uint64_t v158 = a3;
  unsigned int v159 = a4;
  id v11 = a5;
  uint64_t v156 = v10;
  unsigned int v157 = v9;
  int v155 = v11;
  if (!v9)
  {
    int v109 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v163 = "nw_parameters_create_secure_http_messaging";
    __int16 v110 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v160 = 0;
    if (!__nwlog_fault(v110, &type, &v160)) {
      goto LABEL_315;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v111 = __nwlog_obj();
      os_log_type_t v112 = type;
      if (os_log_type_enabled(v111, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v163 = "nw_parameters_create_secure_http_messaging";
        _os_log_impl(&dword_1830D4000, v111, v112, "%{public}s called with null configure_tls", buf, 0xCu);
      }
      goto LABEL_296;
    }
    if (!v160)
    {
      uint64_t v111 = __nwlog_obj();
      os_log_type_t v146 = type;
      if (os_log_type_enabled(v111, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v163 = "nw_parameters_create_secure_http_messaging";
        _os_log_impl(&dword_1830D4000, v111, v146, "%{public}s called with null configure_tls, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_296;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v128 = __nwlog_obj();
    os_log_type_t v129 = type;
    BOOL v130 = os_log_type_enabled(v128, type);
    if (!backtrace_string)
    {
      if (v130)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v163 = "nw_parameters_create_secure_http_messaging";
        _os_log_impl(&dword_1830D4000, v128, v129, "%{public}s called with null configure_tls, no backtrace", buf, 0xCu);
      }
      goto LABEL_314;
    }
    if (v130)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v163 = "nw_parameters_create_secure_http_messaging";
      __int16 v164 = 2082;
      uint64_t v165 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v128, v129, "%{public}s called with null configure_tls, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_267;
  }
  if (!v10)
  {
    unint64_t v113 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v163 = "nw_parameters_create_secure_http_messaging";
    __int16 v110 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v160 = 0;
    if (!__nwlog_fault(v110, &type, &v160)) {
      goto LABEL_315;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v111 = __nwlog_obj();
      os_log_type_t v114 = type;
      if (os_log_type_enabled(v111, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v163 = "nw_parameters_create_secure_http_messaging";
        _os_log_impl(&dword_1830D4000, v111, v114, "%{public}s called with null configure_quic_stream", buf, 0xCu);
      }
      goto LABEL_296;
    }
    if (!v160)
    {
      uint64_t v111 = __nwlog_obj();
      os_log_type_t v147 = type;
      if (os_log_type_enabled(v111, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v163 = "nw_parameters_create_secure_http_messaging";
        _os_log_impl(&dword_1830D4000, v111, v147, "%{public}s called with null configure_quic_stream, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_296;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v128 = __nwlog_obj();
    os_log_type_t v131 = type;
    BOOL v132 = os_log_type_enabled(v128, type);
    if (!backtrace_string)
    {
      if (v132)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v163 = "nw_parameters_create_secure_http_messaging";
        _os_log_impl(&dword_1830D4000, v128, v131, "%{public}s called with null configure_quic_stream, no backtrace", buf, 0xCu);
      }
      goto LABEL_314;
    }
    if (v132)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v163 = "nw_parameters_create_secure_http_messaging";
      __int16 v164 = 2082;
      uint64_t v165 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v128, v131, "%{public}s called with null configure_quic_stream, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_267;
  }
  if (!v158)
  {
    uint64_t v115 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v163 = "nw_parameters_create_secure_http_messaging";
    __int16 v110 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v160 = 0;
    if (!__nwlog_fault(v110, &type, &v160)) {
      goto LABEL_315;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v111 = __nwlog_obj();
      os_log_type_t v116 = type;
      if (os_log_type_enabled(v111, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v163 = "nw_parameters_create_secure_http_messaging";
        _os_log_impl(&dword_1830D4000, v111, v116, "%{public}s called with null configure_quic_connection", buf, 0xCu);
      }
      goto LABEL_296;
    }
    if (!v160)
    {
      uint64_t v111 = __nwlog_obj();
      os_log_type_t v148 = type;
      if (os_log_type_enabled(v111, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v163 = "nw_parameters_create_secure_http_messaging";
        _os_log_impl(&dword_1830D4000, v111, v148, "%{public}s called with null configure_quic_connection, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_296;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v128 = __nwlog_obj();
    os_log_type_t v133 = type;
    BOOL v134 = os_log_type_enabled(v128, type);
    if (!backtrace_string)
    {
      if (v134)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v163 = "nw_parameters_create_secure_http_messaging";
        _os_log_impl(&dword_1830D4000, v128, v133, "%{public}s called with null configure_quic_connection, no backtrace", buf, 0xCu);
      }
      goto LABEL_314;
    }
    if (v134)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v163 = "nw_parameters_create_secure_http_messaging";
      __int16 v164 = 2082;
      uint64_t v165 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v128, v133, "%{public}s called with null configure_quic_connection, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_267;
  }
  if (!v159)
  {
    uint64_t v117 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v163 = "nw_parameters_create_secure_http_messaging";
    __int16 v110 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v160 = 0;
    if (!__nwlog_fault(v110, &type, &v160)) {
      goto LABEL_315;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v111 = __nwlog_obj();
      os_log_type_t v118 = type;
      if (os_log_type_enabled(v111, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v163 = "nw_parameters_create_secure_http_messaging";
        _os_log_impl(&dword_1830D4000, v111, v118, "%{public}s called with null configure_tcp", buf, 0xCu);
      }
      goto LABEL_296;
    }
    if (!v160)
    {
      uint64_t v111 = __nwlog_obj();
      os_log_type_t v149 = type;
      if (os_log_type_enabled(v111, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v163 = "nw_parameters_create_secure_http_messaging";
        _os_log_impl(&dword_1830D4000, v111, v149, "%{public}s called with null configure_tcp, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_296;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v128 = __nwlog_obj();
    os_log_type_t v135 = type;
    BOOL v136 = os_log_type_enabled(v128, type);
    if (!backtrace_string)
    {
      if (v136)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v163 = "nw_parameters_create_secure_http_messaging";
        _os_log_impl(&dword_1830D4000, v128, v135, "%{public}s called with null configure_tcp, no backtrace", buf, 0xCu);
      }
      goto LABEL_314;
    }
    if (v136)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v163 = "nw_parameters_create_secure_http_messaging";
      __int16 v164 = 2082;
      uint64_t v165 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v128, v135, "%{public}s called with null configure_tcp, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_267;
  }
  uint64_t v12 = (void (**)(id, NWConcrete_nw_protocol_options *))v11;
  if (!v11)
  {
    int v119 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v163 = "nw_parameters_create_secure_http_messaging";
    __int16 v110 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v160 = 0;
    if (!__nwlog_fault(v110, &type, &v160)) {
      goto LABEL_315;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v111 = __nwlog_obj();
      os_log_type_t v120 = type;
      if (os_log_type_enabled(v111, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v163 = "nw_parameters_create_secure_http_messaging";
        _os_log_impl(&dword_1830D4000, v111, v120, "%{public}s called with null configure_http_messaging", buf, 0xCu);
      }
      goto LABEL_296;
    }
    if (!v160)
    {
      uint64_t v111 = __nwlog_obj();
      os_log_type_t v150 = type;
      if (os_log_type_enabled(v111, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v163 = "nw_parameters_create_secure_http_messaging";
        _os_log_impl(&dword_1830D4000, v111, v150, "%{public}s called with null configure_http_messaging, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_296;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v128 = __nwlog_obj();
    os_log_type_t v137 = type;
    BOOL v138 = os_log_type_enabled(v128, type);
    if (!backtrace_string)
    {
      if (v138)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v163 = "nw_parameters_create_secure_http_messaging";
        _os_log_impl(&dword_1830D4000, v128, v137, "%{public}s called with null configure_http_messaging, no backtrace", buf, 0xCu);
      }
      goto LABEL_314;
    }
    if (v138)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v163 = "nw_parameters_create_secure_http_messaging";
      __int16 v164 = 2082;
      uint64_t v165 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v128, v137, "%{public}s called with null configure_http_messaging, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_267:

    free(backtrace_string);
    if (!v110) {
      goto LABEL_317;
    }
    goto LABEL_316;
  }
  if (v11 == &__block_literal_global_19196)
  {
    int v121 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v163 = "nw_parameters_create_secure_http_messaging";
    __int16 v110 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v160 = 0;
    if (!__nwlog_fault(v110, &type, &v160)) {
      goto LABEL_315;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v111 = __nwlog_obj();
      os_log_type_t v122 = type;
      if (os_log_type_enabled(v111, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v163 = "nw_parameters_create_secure_http_messaging";
        _os_log_impl(&dword_1830D4000, v111, v122, "%{public}s called with null (configure_http_messaging != (_nw_parameters_configure_protocol_disable))", buf, 0xCu);
      }
LABEL_296:

      goto LABEL_315;
    }
    if (!v160)
    {
      uint64_t v111 = __nwlog_obj();
      os_log_type_t v151 = type;
      if (os_log_type_enabled(v111, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v163 = "nw_parameters_create_secure_http_messaging";
        _os_log_impl(&dword_1830D4000, v111, v151, "%{public}s called with null (configure_http_messaging != (_nw_parameters_configure_protocol_disable)), backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_296;
    }
    uint64_t v139 = (char *)__nw_create_backtrace_string();
    uint64_t v128 = __nwlog_obj();
    os_log_type_t v140 = type;
    BOOL v141 = os_log_type_enabled(v128, type);
    if (v139)
    {
      if (v141)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v163 = "nw_parameters_create_secure_http_messaging";
        __int16 v164 = 2082;
        uint64_t v165 = v139;
        _os_log_impl(&dword_1830D4000, v128, v140, "%{public}s called with null (configure_http_messaging != (_nw_parameters_configure_protocol_disable)), dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(v139);
LABEL_315:
      if (!v110)
      {
LABEL_317:
        os_log_type_t v69 = 0;
        goto LABEL_207;
      }
LABEL_316:
      free(v110);
      goto LABEL_317;
    }
    if (v141)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v163 = "nw_parameters_create_secure_http_messaging";
      _os_log_impl(&dword_1830D4000, v128, v140, "%{public}s called with null (configure_http_messaging != (_nw_parameters_configure_protocol_disable)), no backtrace", buf, 0xCu);
    }
LABEL_314:

    goto LABEL_315;
  }
  nw_parameters_t v13 = nw_parameters_create();
  nw_parameters_t v14 = v13;
  if (v13)
  {
    stack = v13[19].isa;
    if (stack)
    {
      if (nw_protocol_copy_http_messaging_definition_onceToken != -1) {
        dispatch_once(&nw_protocol_copy_http_messaging_definition_onceToken, &__block_literal_global_81);
      }
      options = nw_protocol_create_options((void *)nw_protocol_copy_http_messaging_definition_definition);
      if (v12 != (void (**)(id, NWConcrete_nw_protocol_options *))&__block_literal_global_98) {
        v12[2](v12, options);
      }
      id v16 = nw_http_messaging_options_copy_http1_options(options);

      id v17 = nw_http_messaging_options_copy_http2_options(options);
      id v18 = nw_http_messaging_options_copy_http3_options(options);

      if (v9 == &__block_literal_global_19196)
      {
        char v21 = 0;
        goto LABEL_30;
      }
      uint64_t v19 = (void *)nw_protocol_boringssl_copy_definition();
      char v20 = nw_protocol_create_options(v19);

      if (v20)
      {
        char v21 = v20;
        if (v18) {
          sec_protocol_options_add_transport_specific_application_protocol();
        }
        if (v17) {
          sec_protocol_options_add_transport_specific_application_protocol();
        }
        if (v16) {
          sec_protocol_options_add_transport_specific_application_protocol();
        }
        if (v9 != &__block_literal_global_98) {
          (*((void (**)(id, NWConcrete_nw_protocol_options *))v9 + 2))(v9, v21);
        }

LABEL_30:
        uint64_t v26 = 0;
        if (v156 == (void (**)(id, NWConcrete_nw_protocol_options *))&__block_literal_global_19196
          || v158 == (void (**)(void))&__block_literal_global_19196
          || !v18)
        {
          goto LABEL_41;
        }
        if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
          dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_15_56153);
        }
        BOOL v27 = nw_protocol_create_options((void *)nw_protocol_copy_quic_stream_definition::quic_definition);
        if (v27)
        {
          uint64_t v26 = v27;
          Class isa = stack[3].isa;
          stack[3].Class isa = (Class)v26;
          os_log_type_t v29 = stack;

          if (v156 != (void (**)(id, NWConcrete_nw_protocol_options *))&__block_literal_global_98) {
            v156[2](v156, v26);
          }
          id v30 = nw_quic_stream_copy_shared_connection_options(v26);
          nw_interface_type_t v31 = v21;
          nw_quic_connection_set_sec_protocol_options(v30, v31);

          if (v158 != (void (**)(void))&__block_literal_global_98) {
            v158[2]();
          }

LABEL_41:
          if (v16)
          {
            if (v159 == (void (**)(id, NWConcrete_nw_protocol_options *))&__block_literal_global_19196)
            {
              char v32 = 0;
              goto LABEL_84;
            }
          }
          else
          {
            char v32 = 0;
            if (v159 == (void (**)(id, NWConcrete_nw_protocol_options *))&__block_literal_global_19196
              || !v17)
            {
              goto LABEL_84;
            }
          }
          if (nw_protocol_setup_tcp_definition(void)::onceToken != -1) {
            dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_64304);
          }
          uint64_t v41 = nw_protocol_create_options((void *)g_tcp_definition);
          if (v41)
          {
            if (v159 != (void (**)(id, NWConcrete_nw_protocol_options *))&__block_literal_global_98) {
              v159[2](v159, v41);
            }
            if (v26)
            {
              char v32 = v41;
            }
            else
            {
              char v32 = v41;
              Class v55 = stack[3].isa;
              stack[3].Class isa = (Class)v32;
              uint64_t v56 = stack;
            }
LABEL_84:
            nw_protocol_stack_prepend_application_protocol(stack, &options->super);
            uint64_t v57 = nw_array_create();
            if (!v26 || !v32)
            {
LABEL_88:
              if (!v21 || !v32) {
                goto LABEL_97;
              }
              if (nw_get_http3_override_onceToken != -1) {
                dispatch_once(&nw_get_http3_override_onceToken, &__block_literal_global_10_74195);
              }
              if (nw_get_http3_override_value != 1)
              {
                os_log_type_t v62 = objc_alloc_init(NWConcrete_nw_protocol_transform);
                if (!v62)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  id v92 = (id)gLogObj;
                  *(_DWORD *)buf = 136446210;
                  uint64_t v163 = "nw_parameters_create_secure_http_messaging";
                  int v84 = (const char *)_os_log_send_and_compose_impl();

                  os_log_type_t type = OS_LOG_TYPE_ERROR;
                  char v160 = 0;
                  if (!__nwlog_fault(v84, &type, &v160)) {
                    goto LABEL_197;
                  }
                  if (type == OS_LOG_TYPE_FAULT)
                  {
                    os_log_type_t v85 = __nwlog_obj();
                    os_log_type_t v93 = type;
                    if (os_log_type_enabled(v85, type))
                    {
                      *(_DWORD *)buf = 136446210;
                      uint64_t v163 = "nw_parameters_create_secure_http_messaging";
                      _os_log_impl(&dword_1830D4000, v85, v93, "%{public}s nw_protocol_transform_create failed", buf, 0xCu);
                    }
                    goto LABEL_193;
                  }
                  if (!v160)
                  {
                    os_log_type_t v85 = __nwlog_obj();
                    os_log_type_t v107 = type;
                    if (os_log_type_enabled(v85, type))
                    {
                      *(_DWORD *)buf = 136446210;
                      uint64_t v163 = "nw_parameters_create_secure_http_messaging";
                      _os_log_impl(&dword_1830D4000, v85, v107, "%{public}s nw_protocol_transform_create failed, backtrace limit exceeded", buf, 0xCu);
                    }
                    goto LABEL_193;
                  }
                  char v101 = __nw_create_backtrace_string();
                  os_log_type_t v95 = __nwlog_obj();
                  os_log_type_t v102 = type;
                  BOOL v103 = os_log_type_enabled(v95, type);
                  BOOL v153 = (char *)v101;
                  if (v101)
                  {
                    if (v103)
                    {
                      *(_DWORD *)buf = 136446466;
                      uint64_t v163 = "nw_parameters_create_secure_http_messaging";
                      __int16 v164 = 2082;
                      uint64_t v165 = (char *)v101;
                      _os_log_impl(&dword_1830D4000, v95, v102, "%{public}s nw_protocol_transform_create failed, dumping backtrace:%{public}s", buf, 0x16u);
                    }
                    goto LABEL_163;
                  }
                  if (v103)
                  {
                    *(_DWORD *)buf = 136446210;
                    uint64_t v163 = "nw_parameters_create_secure_http_messaging";
                    _os_log_impl(&dword_1830D4000, v95, v102, "%{public}s nw_protocol_transform_create failed, no backtrace", buf, 0xCu);
                  }
                  goto LABEL_196;
                }
                os_log_type_t v63 = v62;
                *((unsigned char *)v63 + 8) |= 2u;

                os_log_type_t v64 = nw_protocol_options_copy(v21);
                nw_protocol_transform_append_protocol(v63, 4, v64);

                nw_protocol_transform_append_protocol(v63, 3, v32);
                nw_protocol_transform_add_match_url_scheme(v63, "https");
                nw_protocol_transform_add_match_url_scheme(v63, "wss");
                os_log_type_t v65 = v63;
                *((unsigned char *)v63 + 8) |= 0x10u;

                nw_array_append(v57, v65);
              }
              BOOL v66 = objc_alloc_init(NWConcrete_nw_protocol_transform);
              if (v66)
              {
                BOOL v67 = v66;
                *((unsigned char *)v67 + 8) |= 2u;

                nw_protocol_transform_append_protocol(v67, 3, v32);
                nw_protocol_transform_add_match_url_scheme(v67, "http");
                nw_protocol_transform_add_match_url_scheme(v67, "ws");
                id v68 = v67;
                *((unsigned char *)v67 + 8) |= 0x10u;

                nw_array_append(v57, v68);
LABEL_97:
                if (v57 && *(void *)(v57 + 24) != *(void *)(v57 + 16)) {
                  nw_parameters_set_transform_array(v14, (void *)v57);
                }
                nw_parameters_set_data_mode(v14, 2u);
                os_log_type_t v69 = v14;
                goto LABEL_201;
              }
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              id v83 = (id)gLogObj;
              *(_DWORD *)buf = 136446210;
              uint64_t v163 = "nw_parameters_create_secure_http_messaging";
              int v84 = (const char *)_os_log_send_and_compose_impl();

              os_log_type_t type = OS_LOG_TYPE_ERROR;
              char v160 = 0;
              if (!__nwlog_fault(v84, &type, &v160))
              {
LABEL_197:
                if (v84)
                {
                  char v106 = (char *)v84;
                  goto LABEL_199;
                }
                goto LABEL_200;
              }
              if (type == OS_LOG_TYPE_FAULT)
              {
                os_log_type_t v85 = __nwlog_obj();
                os_log_type_t v86 = type;
                if (os_log_type_enabled(v85, type))
                {
                  *(_DWORD *)buf = 136446210;
                  uint64_t v163 = "nw_parameters_create_secure_http_messaging";
                  _os_log_impl(&dword_1830D4000, v85, v86, "%{public}s nw_protocol_transform_create failed", buf, 0xCu);
                }
LABEL_193:

                goto LABEL_197;
              }
              if (!v160)
              {
                os_log_type_t v85 = __nwlog_obj();
                os_log_type_t v105 = type;
                if (os_log_type_enabled(v85, type))
                {
                  *(_DWORD *)buf = 136446210;
                  uint64_t v163 = "nw_parameters_create_secure_http_messaging";
                  _os_log_impl(&dword_1830D4000, v85, v105, "%{public}s nw_protocol_transform_create failed, backtrace limit exceeded", buf, 0xCu);
                }
                goto LABEL_193;
              }
              uint64_t v94 = __nw_create_backtrace_string();
              os_log_type_t v95 = __nwlog_obj();
              os_log_type_t v96 = type;
              BOOL v97 = os_log_type_enabled(v95, type);
              BOOL v153 = (char *)v94;
              if (v94)
              {
                if (v97)
                {
                  *(_DWORD *)buf = 136446466;
                  uint64_t v163 = "nw_parameters_create_secure_http_messaging";
                  __int16 v164 = 2082;
                  uint64_t v165 = (char *)v94;
                  _os_log_impl(&dword_1830D4000, v95, v96, "%{public}s nw_protocol_transform_create failed, dumping backtrace:%{public}s", buf, 0x16u);
                }
LABEL_163:

                free(v153);
                goto LABEL_197;
              }
              if (v97)
              {
                *(_DWORD *)buf = 136446210;
                uint64_t v163 = "nw_parameters_create_secure_http_messaging";
                _os_log_impl(&dword_1830D4000, v95, v96, "%{public}s nw_protocol_transform_create failed, no backtrace", buf, 0xCu);
              }
LABEL_196:

              goto LABEL_197;
            }
            os_log_type_t v58 = objc_alloc_init(NWConcrete_nw_protocol_transform);
            if (v58)
            {
              BOOL v59 = v58;
              *((unsigned char *)v59 + 8) |= 2u;

              nw_protocol_transform_append_protocol(v59, 3, v26);
              os_log_type_t v60 = v59;
              v60->fallback_mode = 2;

              nw_protocol_transform_add_match_url_scheme(v60, "https");
              nw_protocol_transform_add_match_url_scheme(v60, "wss");
              BOOL v61 = v60;
              *((unsigned char *)v59 + 8) |= 0x10u;

              nw_array_append(v57, v61);
              goto LABEL_88;
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v70 = (id)gLogObj;
            *(_DWORD *)buf = 136446210;
            uint64_t v163 = "nw_parameters_create_secure_http_messaging";
            os_log_type_t v71 = (const char *)_os_log_send_and_compose_impl();

            os_log_type_t type = OS_LOG_TYPE_ERROR;
            char v160 = 0;
            id v72 = v71;
            if (!__nwlog_fault(v71, &type, &v160))
            {
LABEL_186:
              if (v72)
              {
                char v106 = (char *)v72;
LABEL_199:
                free(v106);
              }
LABEL_200:
              os_log_type_t v69 = 0;
LABEL_201:

              goto LABEL_202;
            }
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              char v73 = (id)gLogObj;
              os_log_type_t v74 = type;
              if (os_log_type_enabled(v73, type))
              {
                *(_DWORD *)buf = 136446210;
                uint64_t v163 = "nw_parameters_create_secure_http_messaging";
                _os_log_impl(&dword_1830D4000, v73, v74, "%{public}s nw_protocol_transform_create failed", buf, 0xCu);
              }
            }
            else
            {
              if (v160)
              {
                uint64_t v87 = (char *)__nw_create_backtrace_string();
                os_log_type_t v88 = __nwlog_obj();
                os_log_type_t v89 = type;
                BOOL v90 = os_log_type_enabled(v88, type);
                if (v87)
                {
                  if (v90)
                  {
                    *(_DWORD *)buf = 136446466;
                    uint64_t v163 = "nw_parameters_create_secure_http_messaging";
                    __int16 v164 = 2082;
                    uint64_t v165 = v87;
                    _os_log_impl(&dword_1830D4000, v88, v89, "%{public}s nw_protocol_transform_create failed, dumping backtrace:%{public}s", buf, 0x16u);
                  }

                  free(v87);
                }
                else
                {
                  if (v90)
                  {
                    *(_DWORD *)buf = 136446210;
                    uint64_t v163 = "nw_parameters_create_secure_http_messaging";
                    _os_log_impl(&dword_1830D4000, v88, v89, "%{public}s nw_protocol_transform_create failed, no backtrace", buf, 0xCu);
                  }
                }
                goto LABEL_185;
              }
              char v73 = __nwlog_obj();
              os_log_type_t v104 = type;
              if (os_log_type_enabled(v73, type))
              {
                *(_DWORD *)buf = 136446210;
                uint64_t v163 = "nw_parameters_create_secure_http_messaging";
                _os_log_impl(&dword_1830D4000, v73, v104, "%{public}s nw_protocol_transform_create failed, backtrace limit exceeded", buf, 0xCu);
              }
            }

LABEL_185:
            id v72 = v71;
            goto LABEL_186;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v46 = (id)gLogObj;
          *(_DWORD *)buf = 136446210;
          uint64_t v163 = "nw_parameters_create_secure_http_messaging";
          char v47 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v160 = 0;
          if (__nwlog_fault(v47, &type, &v160))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              os_log_type_t v48 = (id)gLogObj;
              os_log_type_t v49 = type;
              if (os_log_type_enabled(v48, type))
              {
                *(_DWORD *)buf = 136446210;
                uint64_t v163 = "nw_parameters_create_secure_http_messaging";
                _os_log_impl(&dword_1830D4000, v48, v49, "%{public}s nw_tcp_create_options failed", buf, 0xCu);
              }
LABEL_73:

              goto LABEL_176;
            }
            if (!v160)
            {
              os_log_type_t v48 = __nwlog_obj();
              os_log_type_t v100 = type;
              if (os_log_type_enabled(v48, type))
              {
                *(_DWORD *)buf = 136446210;
                uint64_t v163 = "nw_parameters_create_secure_http_messaging";
                _os_log_impl(&dword_1830D4000, v48, v100, "%{public}s nw_tcp_create_options failed, backtrace limit exceeded", buf, 0xCu);
              }
              goto LABEL_73;
            }
            __int16 v79 = (char *)__nw_create_backtrace_string();
            uint64_t v80 = __nwlog_obj();
            os_log_type_t v81 = type;
            BOOL v82 = os_log_type_enabled(v80, type);
            if (v79)
            {
              if (v82)
              {
                *(_DWORD *)buf = 136446466;
                uint64_t v163 = "nw_parameters_create_secure_http_messaging";
                __int16 v164 = 2082;
                uint64_t v165 = v79;
                _os_log_impl(&dword_1830D4000, v80, v81, "%{public}s nw_tcp_create_options failed, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v79);
              if (!v47) {
                goto LABEL_178;
              }
              goto LABEL_177;
            }
            if (v82)
            {
              *(_DWORD *)buf = 136446210;
              uint64_t v163 = "nw_parameters_create_secure_http_messaging";
              _os_log_impl(&dword_1830D4000, v80, v81, "%{public}s nw_tcp_create_options failed, no backtrace", buf, 0xCu);
            }
          }
LABEL_176:
          if (!v47)
          {
LABEL_178:
            os_log_type_t v69 = 0;
LABEL_202:

            goto LABEL_203;
          }
LABEL_177:
          free(v47);
          goto LABEL_178;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v42 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        uint64_t v163 = "nw_parameters_create_secure_http_messaging";
        BOOL v43 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v160 = 0;
        if (__nwlog_fault(v43, &type, &v160))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v44 = (id)gLogObj;
            os_log_type_t v45 = type;
            if (os_log_type_enabled(v44, type))
            {
              *(_DWORD *)buf = 136446210;
              uint64_t v163 = "nw_parameters_create_secure_http_messaging";
              _os_log_impl(&dword_1830D4000, v44, v45, "%{public}s nw_quic_create_stream_options failed", buf, 0xCu);
            }
LABEL_68:

            goto LABEL_170;
          }
          if (!v160)
          {
            BOOL v44 = __nwlog_obj();
            os_log_type_t v99 = type;
            if (os_log_type_enabled(v44, type))
            {
              *(_DWORD *)buf = 136446210;
              uint64_t v163 = "nw_parameters_create_secure_http_messaging";
              _os_log_impl(&dword_1830D4000, v44, v99, "%{public}s nw_quic_create_stream_options failed, backtrace limit exceeded", buf, 0xCu);
            }
            goto LABEL_68;
          }
          BOOL v75 = (char *)__nw_create_backtrace_string();
          os_log_type_t v76 = __nwlog_obj();
          os_log_type_t v77 = type;
          BOOL v78 = os_log_type_enabled(v76, type);
          if (v75)
          {
            if (v78)
            {
              *(_DWORD *)buf = 136446466;
              uint64_t v163 = "nw_parameters_create_secure_http_messaging";
              __int16 v164 = 2082;
              uint64_t v165 = v75;
              _os_log_impl(&dword_1830D4000, v76, v77, "%{public}s nw_quic_create_stream_options failed, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v75);
            if (!v43) {
              goto LABEL_172;
            }
            goto LABEL_171;
          }
          if (v78)
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v163 = "nw_parameters_create_secure_http_messaging";
            _os_log_impl(&dword_1830D4000, v76, v77, "%{public}s nw_quic_create_stream_options failed, no backtrace", buf, 0xCu);
          }
        }
LABEL_170:
        if (!v43)
        {
LABEL_172:
          os_log_type_t v69 = 0;
LABEL_203:

          goto LABEL_204;
        }
LABEL_171:
        free(v43);
        goto LABEL_172;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v37 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      uint64_t v163 = "nw_parameters_create_secure_http_messaging";
      BOOL v38 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v160 = 0;
      if (__nwlog_fault(v38, &type, &v160))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v39 = (id)gLogObj;
          os_log_type_t v40 = type;
          if (os_log_type_enabled(v39, type))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v163 = "nw_parameters_create_secure_http_messaging";
            _os_log_impl(&dword_1830D4000, v39, v40, "%{public}s nw_tls_create_options failed", buf, 0xCu);
          }
        }
        else if (v160)
        {
          __int16 v50 = __nw_create_backtrace_string();
          if (v50)
          {
            __int16 v51 = (char *)v50;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v52 = (id)gLogObj;
            os_log_type_t v53 = type;
            if (os_log_type_enabled(v52, type))
            {
              *(_DWORD *)buf = 136446466;
              uint64_t v163 = "nw_parameters_create_secure_http_messaging";
              __int16 v164 = 2082;
              uint64_t v165 = v51;
              _os_log_impl(&dword_1830D4000, v52, v53, "%{public}s nw_tls_create_options failed, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v51);
            if (!v38) {
              goto LABEL_152;
            }
            goto LABEL_151;
          }
          BOOL v39 = __nwlog_obj();
          os_log_type_t v98 = type;
          if (os_log_type_enabled(v39, type))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v163 = "nw_parameters_create_secure_http_messaging";
            _os_log_impl(&dword_1830D4000, v39, v98, "%{public}s nw_tls_create_options failed, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v39 = (id)gLogObj;
          os_log_type_t v91 = type;
          if (os_log_type_enabled(v39, type))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v163 = "nw_parameters_create_secure_http_messaging";
            _os_log_impl(&dword_1830D4000, v39, v91, "%{public}s nw_tls_create_options failed, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }
      if (!v38)
      {
LABEL_152:
        os_log_type_t v69 = 0;
LABEL_204:

LABEL_205:
        goto LABEL_206;
      }
LABEL_151:
      free(v38);
      goto LABEL_152;
    }
    char v123 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v163 = "nw_parameters_create_secure_http_messaging";
    BOOL v124 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v160 = 0;
    if (__nwlog_fault(v124, &type, &v160))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v125 = __nwlog_obj();
        os_log_type_t v126 = type;
        if (os_log_type_enabled(v125, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v163 = "nw_parameters_create_secure_http_messaging";
          _os_log_impl(&dword_1830D4000, v125, v126, "%{public}s called with null stack", buf, 0xCu);
        }
      }
      else
      {
        if (v160)
        {
          v142 = (char *)__nw_create_backtrace_string();
          uint64_t v143 = __nwlog_obj();
          os_log_type_t v144 = type;
          BOOL v145 = os_log_type_enabled(v143, type);
          if (v142)
          {
            if (v145)
            {
              *(_DWORD *)buf = 136446466;
              uint64_t v163 = "nw_parameters_create_secure_http_messaging";
              __int16 v164 = 2082;
              uint64_t v165 = v142;
              _os_log_impl(&dword_1830D4000, v143, v144, "%{public}s called with null stack, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v142);
          }
          else
          {
            if (v145)
            {
              *(_DWORD *)buf = 136446210;
              uint64_t v163 = "nw_parameters_create_secure_http_messaging";
              _os_log_impl(&dword_1830D4000, v143, v144, "%{public}s called with null stack, no backtrace", buf, 0xCu);
            }
          }
          goto LABEL_324;
        }
        char v125 = __nwlog_obj();
        os_log_type_t v152 = type;
        if (os_log_type_enabled(v125, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v163 = "nw_parameters_create_secure_http_messaging";
          _os_log_impl(&dword_1830D4000, v125, v152, "%{public}s called with null stack, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_324:
    if (v124) {
      free(v124);
    }
    os_log_type_t v69 = 0;
    goto LABEL_205;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v22 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  uint64_t v163 = "nw_parameters_create_secure_http_messaging";
  BOOL v23 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v160 = 0;
  if (__nwlog_fault(v23, &type, &v160))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v24 = (id)gLogObj;
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v163 = "nw_parameters_create_secure_http_messaging";
        _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s nw_parameters_create failed", buf, 0xCu);
      }
LABEL_28:

      goto LABEL_115;
    }
    if (!v160)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v24 = (id)gLogObj;
      os_log_type_t v54 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v163 = "nw_parameters_create_secure_http_messaging";
        _os_log_impl(&dword_1830D4000, v24, v54, "%{public}s nw_parameters_create failed, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_28;
    }
    os_log_type_t v33 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v34 = (id)gLogObj;
    os_log_type_t v35 = type;
    BOOL v36 = os_log_type_enabled(v34, type);
    if (v33)
    {
      if (v36)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v163 = "nw_parameters_create_secure_http_messaging";
        __int16 v164 = 2082;
        uint64_t v165 = v33;
        _os_log_impl(&dword_1830D4000, v34, v35, "%{public}s nw_parameters_create failed, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(v33);
      if (!v23) {
        goto LABEL_117;
      }
      goto LABEL_116;
    }
    if (v36)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v163 = "nw_parameters_create_secure_http_messaging";
      _os_log_impl(&dword_1830D4000, v34, v35, "%{public}s nw_parameters_create failed, no backtrace", buf, 0xCu);
    }
  }
LABEL_115:
  if (v23) {
LABEL_116:
  }
    free(v23);
LABEL_117:
  os_log_type_t v69 = 0;
LABEL_206:

LABEL_207:
  return v69;
}

void sub_18346838C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, void *a17, void *a18, void *a19, void *a20,void *a21)
{
  _Unwind_Resume(a1);
}

void sub_183468468()
{
}

void sub_183468470()
{
}

void nw_parameters_allow_sharing_port_with_listener_for_connection(void *a1, void *a2, void *a3)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = a2;
  id v39 = a3;
  if (!v5)
  {
    BOOL v23 = __nwlog_obj();
    *(_DWORD *)aBlock = 136446210;
    *(void *)&aBlock[4] = "nw_parameters_allow_sharing_port_with_listener_for_connection";
    uint64_t v24 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (!__nwlog_fault(v24, &type, &v40)) {
      goto LABEL_53;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)aBlock = 136446210;
        *(void *)&aBlock[4] = "nw_parameters_allow_sharing_port_with_listener_for_connection";
        _os_log_impl(&dword_1830D4000, v25, v26, "%{public}s called with null parameters", aBlock, 0xCu);
      }
    }
    else if (v40)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v25 = __nwlog_obj();
      os_log_type_t v30 = type;
      BOOL v31 = os_log_type_enabled(v25, type);
      if (backtrace_string)
      {
        if (v31)
        {
          *(_DWORD *)aBlock = 136446466;
          *(void *)&aBlock[4] = "nw_parameters_allow_sharing_port_with_listener_for_connection";
          *(_WORD *)&aBlock[12] = 2082;
          *(void *)&aBlock[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v25, v30, "%{public}s called with null parameters, dumping backtrace:%{public}s", aBlock, 0x16u);
        }

        free(backtrace_string);
LABEL_53:
        if (!v24) {
          goto LABEL_19;
        }
LABEL_54:
        free(v24);
        goto LABEL_19;
      }
      if (v31)
      {
        *(_DWORD *)aBlock = 136446210;
        *(void *)&aBlock[4] = "nw_parameters_allow_sharing_port_with_listener_for_connection";
        _os_log_impl(&dword_1830D4000, v25, v30, "%{public}s called with null parameters, no backtrace", aBlock, 0xCu);
      }
    }
    else
    {
      os_log_type_t v25 = __nwlog_obj();
      os_log_type_t v35 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)aBlock = 136446210;
        *(void *)&aBlock[4] = "nw_parameters_allow_sharing_port_with_listener_for_connection";
        _os_log_impl(&dword_1830D4000, v25, v35, "%{public}s called with null parameters, backtrace limit exceeded", aBlock, 0xCu);
      }
    }
LABEL_52:

    goto LABEL_53;
  }
  if (v6)
  {
    uint64_t v7 = (os_unfair_lock_s *)v6;
    *(void *)aBlock = MEMORY[0x1E4F143A8];
    *(void *)&aBlock[8] = 3221225472;
    *(void *)&aBlock[16] = __nw_listener_get_path_uuid_block_invoke;
    BOOL v43 = &unk_1E52491B0;
    int v8 = v7;
    nw_protocol_metadata_t v44 = (nw_protocol_metadata_t)v8;
    id v45 = v5 + 24;
    id v9 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock(v7 + 2);
    v9[2](v9);
    os_unfair_lock_unlock(v7 + 2);

    xpc_object_t v10 = v5;
    id v11 = v8;
    id v12 = v39;
    if (v12)
    {
      uint64_t v13 = *(void *)(*((void *)v10 + 13) + 176);
      if (v13)
      {
        id v14 = *(id *)(v13 + 128);
        if (v14)
        {
          os_log_type_t v15 = v14;
          id v16 = v12;
          id v17 = v16[2].isa;

          if (nw_parameters_get_server_mode(v17))
          {
            *(_DWORD *)(*((void *)v10 + 13) + 84) = 0;
            *((void *)v10 + 12) = *((void *)v10 + 12) & 0xFFFFFFFFFFFF7F3FLL | 0x8080;
            nw_listener_register_client_demux_options_if_needed(v11, v15, v16);
          }
          else
          {
            if (nw_protocol_masque_get_definition(void)::onceToken != -1) {
              dispatch_once(&nw_protocol_masque_get_definition(void)::onceToken, &__block_literal_global_27403);
            }
            BOOL v38 = v17;
            if (nw_protocol_masque_get_definition(void)::definition
              && (id v18 = os_retain((void *)nw_protocol_masque_get_definition(void)::definition)) != 0)
            {
              uint64_t v19 = os_retain(v18);
            }
            else
            {
              uint64_t v19 = 0;
            }
            nw_protocol_metadata_t v20 = nw_connection_copy_protocol_metadata(v16, v19);

            if (v20)
            {
              char v21 = v16;
              id v37 = v16[2].isa;

              id v22 = nw_parameters_copy_context(v37);
              *(void *)aBlock = MEMORY[0x1E4F143A8];
              *(void *)&aBlock[8] = 3221225472;
              *(void *)&aBlock[16] = ___ZL46nw_parameters_register_demux_options_if_neededP24NWConcrete_nw_parametersPU25objcproto14OS_nw_listener8NSObjectPU27objcproto16OS_nw_connectionS1__block_invoke;
              BOOL v43 = &unk_1E524B9A0;
              nw_protocol_metadata_t v44 = v20;
              id v45 = v15;
              nw_queue_context_async_if_needed(v22, aBlock);
            }
            id v17 = v38;
          }
        }
      }
    }

    goto LABEL_19;
  }
  BOOL v27 = __nwlog_obj();
  *(_DWORD *)aBlock = 136446210;
  *(void *)&aBlock[4] = "nw_parameters_allow_sharing_port_with_listener_for_connection";
  uint64_t v24 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v40 = 0;
  if (!__nwlog_fault(v24, &type, &v40)) {
    goto LABEL_53;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v25 = __nwlog_obj();
    os_log_type_t v28 = type;
    if (os_log_type_enabled(v25, type))
    {
      *(_DWORD *)aBlock = 136446210;
      *(void *)&aBlock[4] = "nw_parameters_allow_sharing_port_with_listener_for_connection";
      _os_log_impl(&dword_1830D4000, v25, v28, "%{public}s called with null listener", aBlock, 0xCu);
    }
    goto LABEL_52;
  }
  if (!v40)
  {
    os_log_type_t v25 = __nwlog_obj();
    os_log_type_t v36 = type;
    if (os_log_type_enabled(v25, type))
    {
      *(_DWORD *)aBlock = 136446210;
      *(void *)&aBlock[4] = "nw_parameters_allow_sharing_port_with_listener_for_connection";
      _os_log_impl(&dword_1830D4000, v25, v36, "%{public}s called with null listener, backtrace limit exceeded", aBlock, 0xCu);
    }
    goto LABEL_52;
  }
  char v32 = (char *)__nw_create_backtrace_string();
  os_log_type_t v25 = __nwlog_obj();
  os_log_type_t v33 = type;
  BOOL v34 = os_log_type_enabled(v25, type);
  if (!v32)
  {
    if (v34)
    {
      *(_DWORD *)aBlock = 136446210;
      *(void *)&aBlock[4] = "nw_parameters_allow_sharing_port_with_listener_for_connection";
      _os_log_impl(&dword_1830D4000, v25, v33, "%{public}s called with null listener, no backtrace", aBlock, 0xCu);
    }
    goto LABEL_52;
  }
  if (v34)
  {
    *(_DWORD *)aBlock = 136446466;
    *(void *)&aBlock[4] = "nw_parameters_allow_sharing_port_with_listener_for_connection";
    *(_WORD *)&aBlock[12] = 2082;
    *(void *)&aBlock[14] = v32;
    _os_log_impl(&dword_1830D4000, v25, v33, "%{public}s called with null listener, dumping backtrace:%{public}s", aBlock, 0x16u);
  }

  free(v32);
  if (v24) {
    goto LABEL_54;
  }
LABEL_19:
}

void sub_183468B8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,void *a22)
{
  _Unwind_Resume(a1);
}

void nw_parameters_add_custom_proxy_config(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  nw_parameters_t v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (!v3)
  {
    id v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v26 = "nw_parameters_add_custom_proxy_config";
    xpc_object_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v10, &type, &v23)) {
      goto LABEL_40;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v26 = "nw_parameters_add_custom_proxy_config";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v26 = "nw_parameters_add_custom_proxy_config";
          __int16 v27 = 2082;
          os_log_type_t v28 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_40:
        if (!v10) {
          goto LABEL_6;
        }
LABEL_41:
        free(v10);
        goto LABEL_6;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v26 = "nw_parameters_add_custom_proxy_config";
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v11 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v26 = "nw_parameters_add_custom_proxy_config";
        _os_log_impl(&dword_1830D4000, v11, v21, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_39:

    goto LABEL_40;
  }
  if (v4)
  {
    uint64_t v6 = v3[22];
    if (!v6)
    {
      BOOL v7 = nw_array_create();
      int v8 = (void *)v3[22];
      v3[22] = v7;

      uint64_t v6 = v3[22];
    }
    nw_array_append(v6, v5);
    goto LABEL_6;
  }
  uint64_t v13 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v26 = "nw_parameters_add_custom_proxy_config";
  xpc_object_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (!__nwlog_fault(v10, &type, &v23)) {
    goto LABEL_40;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    id v11 = __nwlog_obj();
    os_log_type_t v14 = type;
    if (os_log_type_enabled(v11, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v26 = "nw_parameters_add_custom_proxy_config";
      _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null config", buf, 0xCu);
    }
    goto LABEL_39;
  }
  if (!v23)
  {
    id v11 = __nwlog_obj();
    os_log_type_t v22 = type;
    if (os_log_type_enabled(v11, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v26 = "nw_parameters_add_custom_proxy_config";
      _os_log_impl(&dword_1830D4000, v11, v22, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_39;
  }
  id v18 = (char *)__nw_create_backtrace_string();
  id v11 = __nwlog_obj();
  os_log_type_t v19 = type;
  BOOL v20 = os_log_type_enabled(v11, type);
  if (!v18)
  {
    if (v20)
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v26 = "nw_parameters_add_custom_proxy_config";
      _os_log_impl(&dword_1830D4000, v11, v19, "%{public}s called with null config, no backtrace", buf, 0xCu);
    }
    goto LABEL_39;
  }
  if (v20)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v26 = "nw_parameters_add_custom_proxy_config";
    __int16 v27 = 2082;
    os_log_type_t v28 = v18;
    _os_log_impl(&dword_1830D4000, v11, v19, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v18);
  if (v10) {
    goto LABEL_41;
  }
LABEL_6:
}

uint64_t nw_nexus_bind_client_port(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  *(void *)&v30[13] = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v28 = "nw_nexus_bind_client_port";
    BOOL v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (!__nwlog_fault(v7, &type, &v25)) {
      goto LABEL_49;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v11 = gLogObj;
      os_log_type_t v12 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_49;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v28 = "nw_nexus_bind_client_port";
      xpc_object_t v10 = "%{public}s called with null nexus";
LABEL_46:
      os_log_type_t v22 = v11;
      os_log_type_t v23 = v12;
LABEL_47:
      uint32_t v24 = 12;
      goto LABEL_48;
    }
    if (!v25)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v11 = gLogObj;
      os_log_type_t v12 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_49;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v28 = "nw_nexus_bind_client_port";
      xpc_object_t v10 = "%{public}s called with null nexus, backtrace limit exceeded";
      goto LABEL_46;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v14 = gLogObj;
    os_log_type_t v15 = type;
    BOOL v16 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (backtrace_string)
    {
      if (!v16) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v28 = "nw_nexus_bind_client_port";
      __int16 v29 = 2082;
      *(void *)os_log_type_t v30 = backtrace_string;
      BOOL v17 = "%{public}s called with null nexus, dumping backtrace:%{public}s";
      goto LABEL_32;
    }
    if (!v16) {
      goto LABEL_49;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v28 = "nw_nexus_bind_client_port";
    xpc_object_t v10 = "%{public}s called with null nexus, no backtrace";
LABEL_54:
    os_log_type_t v22 = v14;
    os_log_type_t v23 = v15;
    goto LABEL_47;
  }
  if (!(a3 | a4) && (!a5 || !a6))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v28 = "nw_nexus_bind_client_port";
    BOOL v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (!__nwlog_fault(v7, &type, &v25)) {
      goto LABEL_49;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v11 = gLogObj;
      os_log_type_t v12 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_49;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v28 = "nw_nexus_bind_client_port";
      xpc_object_t v10 = "%{public}s called with null process_uuid_ptr, pid_ptr, key";
      goto LABEL_46;
    }
    if (!v25)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v11 = gLogObj;
      os_log_type_t v12 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_49;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v28 = "nw_nexus_bind_client_port";
      xpc_object_t v10 = "%{public}s called with null process_uuid_ptr, pid_ptr, key, backtrace limit exceeded";
      goto LABEL_46;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v14 = gLogObj;
    os_log_type_t v15 = type;
    BOOL v21 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (backtrace_string)
    {
      if (!v21) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v28 = "nw_nexus_bind_client_port";
      __int16 v29 = 2082;
      *(void *)os_log_type_t v30 = backtrace_string;
      BOOL v17 = "%{public}s called with null process_uuid_ptr, pid_ptr, key, dumping backtrace:%{public}s";
LABEL_32:
      _os_log_impl(&dword_1830D4000, v14, v15, v17, buf, 0x16u);
LABEL_33:
      free(backtrace_string);
      if (!v7) {
        return 0;
      }
      goto LABEL_50;
    }
    if (!v21) {
      goto LABEL_49;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v28 = "nw_nexus_bind_client_port";
    xpc_object_t v10 = "%{public}s called with null process_uuid_ptr, pid_ptr, key, no backtrace";
    goto LABEL_54;
  }
  if (!os_nexus_controller_bind_provider_instance()) {
    return 1;
  }
  int v6 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446466;
  os_log_type_t v28 = "nw_nexus_bind_client_port";
  __int16 v29 = 1024;
  *(_DWORD *)os_log_type_t v30 = v6;
  BOOL v7 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v25 = 0;
  if (__nwlog_fault(v7, &type, &v25))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v8 = gLogObj;
      os_log_type_t v9 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_49;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v28 = "nw_nexus_bind_client_port";
      __int16 v29 = 1024;
      *(_DWORD *)os_log_type_t v30 = v6;
      xpc_object_t v10 = "%{public}s os_nexus_controller_bind_provider_instance(SERVER) %{darwin.errno}d";
LABEL_43:
      os_log_type_t v22 = v8;
      os_log_type_t v23 = v9;
      uint32_t v24 = 18;
LABEL_48:
      _os_log_impl(&dword_1830D4000, v22, v23, v10, buf, v24);
      goto LABEL_49;
    }
    if (!v25)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v8 = gLogObj;
      os_log_type_t v9 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_49;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v28 = "nw_nexus_bind_client_port";
      __int16 v29 = 1024;
      *(_DWORD *)os_log_type_t v30 = v6;
      xpc_object_t v10 = "%{public}s os_nexus_controller_bind_provider_instance(SERVER) %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_43;
    }
    os_log_type_t v19 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v8 = gLogObj;
    os_log_type_t v9 = type;
    BOOL v20 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v19)
    {
      if (!v20) {
        goto LABEL_49;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v28 = "nw_nexus_bind_client_port";
      __int16 v29 = 1024;
      *(_DWORD *)os_log_type_t v30 = v6;
      xpc_object_t v10 = "%{public}s os_nexus_controller_bind_provider_instance(SERVER) %{darwin.errno}d, no backtrace";
      goto LABEL_43;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446722;
      os_log_type_t v28 = "nw_nexus_bind_client_port";
      __int16 v29 = 1024;
      *(_DWORD *)os_log_type_t v30 = v6;
      v30[2] = 2082;
      *(void *)&v30[3] = v19;
      _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s os_nexus_controller_bind_provider_instance(SERVER) %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
    }
    free(v19);
  }
LABEL_49:
  if (v7) {
LABEL_50:
  }
    free(v7);
  return 0;
}

void nw_http_transaction_metadata_set_event_handler(void *a1, void *a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (!v3)
  {
    xpc_object_t v10 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v29 = "nw_http_transaction_metadata_set_event_handler";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v11, &type, &v26)) {
      goto LABEL_42;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v29 = "nw_http_transaction_metadata_set_event_handler";
        _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v29 = "nw_http_transaction_metadata_set_event_handler";
          __int16 v30 = 2082;
          BOOL v31 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_42:
        if (!v11) {
          goto LABEL_8;
        }
LABEL_43:
        free(v11);
        goto LABEL_8;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v29 = "nw_http_transaction_metadata_set_event_handler";
        _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v29 = "nw_http_transaction_metadata_set_event_handler";
        _os_log_impl(&dword_1830D4000, v12, v22, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_41:

    goto LABEL_42;
  }
  id v5 = v3;
  id v6 = *((id *)v5 + 1);

  if (nw_protocol_copy_http_transaction_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_transaction_definition_onceToken, &__block_literal_global_84_75899);
  }
  BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v6, nw_protocol_copy_http_transaction_definition_definition);

  if (is_equal_unsafe)
  {
    v24[0] = MEMORY[0x1E4F143A8];
    v24[1] = 3221225472;
    v24[2] = __nw_http_transaction_metadata_set_event_handler_block_invoke;
    v24[3] = &unk_1E5248ED8;
    id v8 = v4;
    id v25 = v8;
    uint64_t v9 = *((void *)v5 + 4);
    if (v9)
    {
      __nw_http_transaction_metadata_set_event_handler_block_invoke((uint64_t)v24, v9);
      id v8 = v25;
    }

    goto LABEL_8;
  }
  os_log_type_t v14 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v29 = "nw_http_transaction_metadata_set_event_handler";
  uint64_t v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v26 = 0;
  if (!__nwlog_fault(v11, &type, &v26)) {
    goto LABEL_42;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v12 = __nwlog_obj();
    os_log_type_t v15 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v29 = "nw_http_transaction_metadata_set_event_handler";
      _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s metadata must be http_transaction", buf, 0xCu);
    }
    goto LABEL_41;
  }
  if (!v26)
  {
    os_log_type_t v12 = __nwlog_obj();
    os_log_type_t v23 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v29 = "nw_http_transaction_metadata_set_event_handler";
      _os_log_impl(&dword_1830D4000, v12, v23, "%{public}s metadata must be http_transaction, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_41;
  }
  os_log_type_t v19 = (char *)__nw_create_backtrace_string();
  os_log_type_t v12 = __nwlog_obj();
  os_log_type_t v20 = type;
  BOOL v21 = os_log_type_enabled(v12, type);
  if (!v19)
  {
    if (v21)
    {
      *(_DWORD *)buf = 136446210;
      __int16 v29 = "nw_http_transaction_metadata_set_event_handler";
      _os_log_impl(&dword_1830D4000, v12, v20, "%{public}s metadata must be http_transaction, no backtrace", buf, 0xCu);
    }
    goto LABEL_41;
  }
  if (v21)
  {
    *(_DWORD *)buf = 136446466;
    __int16 v29 = "nw_http_transaction_metadata_set_event_handler";
    __int16 v30 = 2082;
    BOOL v31 = v19;
    _os_log_impl(&dword_1830D4000, v12, v20, "%{public}s metadata must be http_transaction, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v19);
  if (v11) {
    goto LABEL_43;
  }
LABEL_8:
}

void nw_http_transaction_metadata_set_converted_url_response(void *a1, uint64_t a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    uint64_t v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v27 = "nw_http_transaction_metadata_set_converted_url_response";
    xpc_object_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (!__nwlog_fault(v10, &type, &v24)) {
      goto LABEL_41;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v27 = "nw_http_transaction_metadata_set_converted_url_response";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v27 = "nw_http_transaction_metadata_set_converted_url_response";
          __int16 v28 = 2082;
          __int16 v29 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_41:
        if (!v10) {
          goto LABEL_7;
        }
LABEL_42:
        free(v10);
        goto LABEL_7;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v27 = "nw_http_transaction_metadata_set_converted_url_response";
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v27 = "nw_http_transaction_metadata_set_converted_url_response";
        _os_log_impl(&dword_1830D4000, v11, v21, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_40:

    goto LABEL_41;
  }
  id v5 = v3;
  id v6 = *((id *)v5 + 1);

  if (nw_protocol_copy_http_transaction_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_transaction_definition_onceToken, &__block_literal_global_84_75899);
  }
  BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v6, nw_protocol_copy_http_transaction_definition_definition);

  if (is_equal_unsafe)
  {
    v23[0] = MEMORY[0x1E4F143A8];
    v23[1] = 3221225472;
    v23[2] = __nw_http_transaction_metadata_set_converted_url_response_block_invoke;
    v23[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v23[4] = a2;
    uint64_t v8 = *((void *)v5 + 4);
    if (v8) {
      __nw_http_transaction_metadata_set_converted_url_response_block_invoke((uint64_t)v23, v8);
    }
    goto LABEL_7;
  }
  os_log_type_t v13 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v27 = "nw_http_transaction_metadata_set_converted_url_response";
  xpc_object_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v24 = 0;
  if (!__nwlog_fault(v10, &type, &v24)) {
    goto LABEL_41;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v11 = __nwlog_obj();
    os_log_type_t v14 = type;
    if (os_log_type_enabled(v11, type))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v27 = "nw_http_transaction_metadata_set_converted_url_response";
      _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s metadata must be http_transaction", buf, 0xCu);
    }
    goto LABEL_40;
  }
  if (!v24)
  {
    uint64_t v11 = __nwlog_obj();
    os_log_type_t v22 = type;
    if (os_log_type_enabled(v11, type))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v27 = "nw_http_transaction_metadata_set_converted_url_response";
      _os_log_impl(&dword_1830D4000, v11, v22, "%{public}s metadata must be http_transaction, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_40;
  }
  BOOL v18 = (char *)__nw_create_backtrace_string();
  uint64_t v11 = __nwlog_obj();
  os_log_type_t v19 = type;
  BOOL v20 = os_log_type_enabled(v11, type);
  if (!v18)
  {
    if (v20)
    {
      *(_DWORD *)buf = 136446210;
      __int16 v27 = "nw_http_transaction_metadata_set_converted_url_response";
      _os_log_impl(&dword_1830D4000, v11, v19, "%{public}s metadata must be http_transaction, no backtrace", buf, 0xCu);
    }
    goto LABEL_40;
  }
  if (v20)
  {
    *(_DWORD *)buf = 136446466;
    __int16 v27 = "nw_http_transaction_metadata_set_converted_url_response";
    __int16 v28 = 2082;
    __int16 v29 = v18;
    _os_log_impl(&dword_1830D4000, v11, v19, "%{public}s metadata must be http_transaction, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v18);
  if (v10) {
    goto LABEL_42;
  }
LABEL_7:
}

uint64_t nw_http_transaction_metadata_get_inbound_message_end_time(void *a1)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = nw_protocol_metadata_copy_definition(v1);
    if (nw_protocol_copy_http_transaction_definition_onceToken != -1) {
      dispatch_once(&nw_protocol_copy_http_transaction_definition_onceToken, &__block_literal_global_84_75899);
    }
    BOOL is_equal = nw_protocol_definition_is_equal(v3, (nw_protocol_definition_t)nw_protocol_copy_http_transaction_definition_definition);

    if (is_equal)
    {
      *(void *)buf = 0;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x2020000000;
      uint64_t v25 = 0;
      v21[0] = MEMORY[0x1E4F143A8];
      v21[1] = 3221225472;
      v21[2] = __nw_http_transaction_metadata_get_inbound_message_end_time_block_invoke;
      v21[3] = &unk_1E5248E90;
      v21[4] = buf;
      uint64_t isa = (uint64_t)v2[4].isa;
      if (isa)
      {
        __nw_http_transaction_metadata_get_inbound_message_end_time_block_invoke((uint64_t)v21, isa);
        uint64_t v6 = *(void *)(*(void *)&buf[8] + 24);
      }
      else
      {
        uint64_t v6 = 0;
      }
      _Block_object_dispose(buf, 8);
      goto LABEL_9;
    }
    os_log_type_t v12 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_get_inbound_message_end_time";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (__nwlog_fault(v9, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        xpc_object_t v10 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_get_inbound_message_end_time";
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s metadata must be http_transaction", buf, 0xCu);
        }
LABEL_41:

        goto LABEL_42;
      }
      if (!v22)
      {
        xpc_object_t v10 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_get_inbound_message_end_time";
          _os_log_impl(&dword_1830D4000, v10, v20, "%{public}s metadata must be http_transaction, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_41;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      xpc_object_t v10 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_get_inbound_message_end_time";
          _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s metadata must be http_transaction, no backtrace", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_get_inbound_message_end_time";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s metadata must be http_transaction, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_29;
    }
  }
  else
  {
    uint64_t v8 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_get_inbound_message_end_time";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (__nwlog_fault(v9, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        xpc_object_t v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_get_inbound_message_end_time";
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null metadata", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (!v22)
      {
        xpc_object_t v10 = __nwlog_obj();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_get_inbound_message_end_time";
          _os_log_impl(&dword_1830D4000, v10, v19, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_41;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      xpc_object_t v10 = __nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_get_inbound_message_end_time";
          _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_get_inbound_message_end_time";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_29:

      free(backtrace_string);
    }
  }
LABEL_42:
  if (v9) {
    free(v9);
  }
  uint64_t v6 = 0;
LABEL_9:

  return v6;
}

BOOL nw_http_parsed_fields_add(void *a1, unint64_t a2, uint64_t a3, const char *a4, int64_t a5, char a6)
{
  id v11 = a1;
  if (!v11)
  {
    os_log_type_t v14 = __nwlog_obj();
    os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    os_log_type_t v15 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v15);
    if (result) {
      goto LABEL_11;
    }
    free(v15);
    if (a2) {
      goto LABEL_3;
    }
LABEL_7:
    BOOL v16 = __nwlog_obj();
    os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
    os_log_type_t v17 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v17);
    if (result) {
      goto LABEL_11;
    }
    free(v17);
    if (a4) {
      goto LABEL_4;
    }
    goto LABEL_9;
  }
  if (!a2) {
    goto LABEL_7;
  }
LABEL_3:
  if (a4)
  {
LABEL_4:
    uint64_t v12 = _nw_http_parsed_fields_add((uint64_t)v11, a2, a3, a4, a5, a6);

    return v12;
  }
LABEL_9:
  BOOL v18 = __nwlog_obj();
  os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
  os_log_type_t v19 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v19);
  if (!result)
  {
    free(v19);
    goto LABEL_4;
  }
LABEL_11:
  __break(1u);
  return result;
}

void nw_http_metadata_set_version(void *a1, int a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    uint64_t v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v28 = "nw_http_metadata_set_version";
    xpc_object_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (!__nwlog_fault(v10, &type, &v25)) {
      goto LABEL_41;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_http_metadata_set_version";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v28 = "nw_http_metadata_set_version";
          __int16 v29 = 2082;
          uint64_t v30 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_41:
        if (!v10) {
          goto LABEL_7;
        }
LABEL_42:
        free(v10);
        goto LABEL_7;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_http_metadata_set_version";
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v11 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_http_metadata_set_version";
        _os_log_impl(&dword_1830D4000, v11, v21, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_40:

    goto LABEL_41;
  }
  id v5 = v3;
  id v6 = *((id *)v5 + 1);

  if (nw_protocol_copy_http_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_15_74223);
  }
  BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v6, nw_protocol_copy_http_definition_http_definition);

  if (is_equal_unsafe)
  {
    v23[0] = MEMORY[0x1E4F143A8];
    v23[1] = 3221225472;
    v23[2] = __nw_http_metadata_set_version_block_invoke;
    v23[3] = &__block_descriptor_36_e9_B16__0_v8l;
    int v24 = a2;
    uint64_t v8 = *((void *)v5 + 4);
    if (v8) {
      __nw_http_metadata_set_version_block_invoke((uint64_t)v23, v8);
    }
    goto LABEL_7;
  }
  os_log_type_t v13 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v28 = "nw_http_metadata_set_version";
  xpc_object_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v25 = 0;
  if (!__nwlog_fault(v10, &type, &v25)) {
    goto LABEL_41;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    id v11 = __nwlog_obj();
    os_log_type_t v14 = type;
    if (os_log_type_enabled(v11, type))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v28 = "nw_http_metadata_set_version";
      _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s metadata must be http", buf, 0xCu);
    }
    goto LABEL_40;
  }
  if (!v25)
  {
    id v11 = __nwlog_obj();
    os_log_type_t v22 = type;
    if (os_log_type_enabled(v11, type))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v28 = "nw_http_metadata_set_version";
      _os_log_impl(&dword_1830D4000, v11, v22, "%{public}s metadata must be http, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_40;
  }
  BOOL v18 = (char *)__nw_create_backtrace_string();
  id v11 = __nwlog_obj();
  os_log_type_t v19 = type;
  BOOL v20 = os_log_type_enabled(v11, type);
  if (!v18)
  {
    if (v20)
    {
      *(_DWORD *)buf = 136446210;
      __int16 v28 = "nw_http_metadata_set_version";
      _os_log_impl(&dword_1830D4000, v11, v19, "%{public}s metadata must be http, no backtrace", buf, 0xCu);
    }
    goto LABEL_40;
  }
  if (v20)
  {
    *(_DWORD *)buf = 136446466;
    __int16 v28 = "nw_http_metadata_set_version";
    __int16 v29 = 2082;
    uint64_t v30 = v18;
    _os_log_impl(&dword_1830D4000, v11, v19, "%{public}s metadata must be http, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v18);
  if (v10) {
    goto LABEL_42;
  }
LABEL_7:
}

void nw_http_metadata_set_trailer_fields(void *a1, void *a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (!v3)
  {
    xpc_object_t v10 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v29 = "nw_http_metadata_set_trailer_fields";
    id v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v11, &type, &v26)) {
      goto LABEL_42;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v29 = "nw_http_metadata_set_trailer_fields";
        _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v29 = "nw_http_metadata_set_trailer_fields";
          __int16 v30 = 2082;
          uint64_t v31 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_42:
        if (!v11) {
          goto LABEL_8;
        }
LABEL_43:
        free(v11);
        goto LABEL_8;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v29 = "nw_http_metadata_set_trailer_fields";
        _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v29 = "nw_http_metadata_set_trailer_fields";
        _os_log_impl(&dword_1830D4000, v12, v22, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_41:

    goto LABEL_42;
  }
  id v5 = v3;
  id v6 = *((id *)v5 + 1);

  if (nw_protocol_copy_http_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_15_74223);
  }
  BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v6, nw_protocol_copy_http_definition_http_definition);

  if (is_equal_unsafe)
  {
    v24[0] = MEMORY[0x1E4F143A8];
    v24[1] = 3221225472;
    v24[2] = __nw_http_metadata_set_trailer_fields_block_invoke;
    v24[3] = &unk_1E5248F68;
    id v8 = v4;
    id v25 = v8;
    uint64_t v9 = *((void *)v5 + 4);
    if (v9)
    {
      __nw_http_metadata_set_trailer_fields_block_invoke((uint64_t)v24, v9);
      id v8 = v25;
    }

    goto LABEL_8;
  }
  os_log_type_t v14 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v29 = "nw_http_metadata_set_trailer_fields";
  id v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v26 = 0;
  if (!__nwlog_fault(v11, &type, &v26)) {
    goto LABEL_42;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v12 = __nwlog_obj();
    os_log_type_t v15 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v29 = "nw_http_metadata_set_trailer_fields";
      _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s metadata must be http", buf, 0xCu);
    }
    goto LABEL_41;
  }
  if (!v26)
  {
    os_log_type_t v12 = __nwlog_obj();
    os_log_type_t v23 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v29 = "nw_http_metadata_set_trailer_fields";
      _os_log_impl(&dword_1830D4000, v12, v23, "%{public}s metadata must be http, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_41;
  }
  os_log_type_t v19 = (char *)__nw_create_backtrace_string();
  os_log_type_t v12 = __nwlog_obj();
  os_log_type_t v20 = type;
  BOOL v21 = os_log_type_enabled(v12, type);
  if (!v19)
  {
    if (v21)
    {
      *(_DWORD *)buf = 136446210;
      __int16 v29 = "nw_http_metadata_set_trailer_fields";
      _os_log_impl(&dword_1830D4000, v12, v20, "%{public}s metadata must be http, no backtrace", buf, 0xCu);
    }
    goto LABEL_41;
  }
  if (v21)
  {
    *(_DWORD *)buf = 136446466;
    __int16 v29 = "nw_http_metadata_set_trailer_fields";
    __int16 v30 = 2082;
    uint64_t v31 = v19;
    _os_log_impl(&dword_1830D4000, v12, v20, "%{public}s metadata must be http, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v19);
  if (v11) {
    goto LABEL_43;
  }
LABEL_8:
}

void nw_http_metadata_set_request(void *a1, void *a2)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  id v5 = v3;
  id v6 = v5;
  if (v5)
  {
    id v7 = *((id *)v5 + 1);
    goto LABEL_3;
  }
  xpc_object_t v10 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v39 = "nw_protocol_metadata_copy_definition";
  id v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v36 = 0;
  if (__nwlog_fault(v11, &type, &v36))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        id v39 = "nw_protocol_metadata_copy_definition";
        _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v36)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v23 = type;
      BOOL v24 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446466;
          id v39 = "nw_protocol_metadata_copy_definition";
          __int16 v40 = 2082;
          uint64_t v41 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v12, v23, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_53;
      }
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        id v39 = "nw_protocol_metadata_copy_definition";
        _os_log_impl(&dword_1830D4000, v12, v23, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v31 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        id v39 = "nw_protocol_metadata_copy_definition";
        _os_log_impl(&dword_1830D4000, v12, v31, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_53:
  if (v11) {
    free(v11);
  }
  id v7 = 0;
LABEL_3:

  if (nw_protocol_copy_http_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_15_74223);
  }
  BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v7, nw_protocol_copy_http_definition_http_definition);

  if (is_equal_unsafe)
  {
    v34[0] = MEMORY[0x1E4F143A8];
    v34[1] = 3221225472;
    v34[2] = __nw_http_metadata_set_request_block_invoke;
    v34[3] = &unk_1E5248F68;
    id v35 = v4;
    if (v6)
    {
      uint64_t v9 = v6[4];
      if (v9) {
        __nw_http_metadata_set_request_block_invoke((uint64_t)v34, v9);
      }
LABEL_9:

      goto LABEL_10;
    }
    BOOL v18 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v39 = "nw_protocol_metadata_access_handle";
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (__nwlog_fault(v19, &type, &v36))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v20 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446210;
          id v39 = "nw_protocol_metadata_access_handle";
          _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s called with null metadata", buf, 0xCu);
        }
      }
      else if (v36)
      {
        __int16 v28 = (char *)__nw_create_backtrace_string();
        os_log_type_t v20 = __nwlog_obj();
        os_log_type_t v29 = type;
        BOOL v30 = os_log_type_enabled(v20, type);
        if (v28)
        {
          if (v30)
          {
            *(_DWORD *)buf = 136446466;
            id v39 = "nw_protocol_metadata_access_handle";
            __int16 v40 = 2082;
            uint64_t v41 = v28;
            _os_log_impl(&dword_1830D4000, v20, v29, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v28);
          goto LABEL_64;
        }
        if (v30)
        {
          *(_DWORD *)buf = 136446210;
          id v39 = "nw_protocol_metadata_access_handle";
          _os_log_impl(&dword_1830D4000, v20, v29, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v20 = __nwlog_obj();
        os_log_type_t v33 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446210;
          id v39 = "nw_protocol_metadata_access_handle";
          _os_log_impl(&dword_1830D4000, v20, v33, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_64:
    if (v19) {
      free(v19);
    }
    goto LABEL_9;
  }
  os_log_type_t v14 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v39 = "nw_http_metadata_set_request";
  os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v36 = 0;
  if (__nwlog_fault(v15, &type, &v36))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        id v39 = "nw_http_metadata_set_request";
        _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s metadata must be http", buf, 0xCu);
      }
    }
    else if (v36)
    {
      id v25 = (char *)__nw_create_backtrace_string();
      os_log_type_t v16 = __nwlog_obj();
      os_log_type_t v26 = type;
      BOOL v27 = os_log_type_enabled(v16, type);
      if (v25)
      {
        if (v27)
        {
          *(_DWORD *)buf = 136446466;
          id v39 = "nw_http_metadata_set_request";
          __int16 v40 = 2082;
          uint64_t v41 = v25;
          _os_log_impl(&dword_1830D4000, v16, v26, "%{public}s metadata must be http, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v25);
        goto LABEL_59;
      }
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        id v39 = "nw_http_metadata_set_request";
        _os_log_impl(&dword_1830D4000, v16, v26, "%{public}s metadata must be http, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v16 = __nwlog_obj();
      os_log_type_t v32 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        id v39 = "nw_http_metadata_set_request";
        _os_log_impl(&dword_1830D4000, v16, v32, "%{public}s metadata must be http, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_59:
  if (v15) {
    free(v15);
  }
LABEL_10:
}

void nw_http_metadata_set_path(void *a1, uint64_t a2)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    uint64_t v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v32 = "nw_http_metadata_set_path";
    xpc_object_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (!__nwlog_fault(v10, &type, &v29)) {
      goto LABEL_58;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v32 = "nw_http_metadata_set_path";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v29)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v11 = __nwlog_obj();
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v32 = "nw_http_metadata_set_path";
          __int16 v33 = 2082;
          BOOL v34 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_58:
        if (!v10) {
          goto LABEL_8;
        }
LABEL_59:
        free(v10);
        goto LABEL_8;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v32 = "nw_http_metadata_set_path";
        _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v11 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v32 = "nw_http_metadata_set_path";
        _os_log_impl(&dword_1830D4000, v11, v25, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_57:

    goto LABEL_58;
  }
  id v5 = v3;
  id v6 = *((id *)v5 + 1);

  if (nw_protocol_copy_http_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_15_74223);
  }
  BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v6, nw_protocol_copy_http_definition_http_definition);

  if (!is_equal_unsafe)
  {
    os_log_type_t v13 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v32 = "nw_http_metadata_set_path";
    xpc_object_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (!__nwlog_fault(v10, &type, &v29)) {
      goto LABEL_58;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v11 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v32 = "nw_http_metadata_set_path";
        _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s metadata must be http", buf, 0xCu);
      }
      goto LABEL_57;
    }
    if (!v29)
    {
      id v11 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v32 = "nw_http_metadata_set_path";
        _os_log_impl(&dword_1830D4000, v11, v26, "%{public}s metadata must be http, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_57;
    }
    os_log_type_t v20 = (char *)__nw_create_backtrace_string();
    id v11 = __nwlog_obj();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v11, type);
    if (!v20)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v32 = "nw_http_metadata_set_path";
        _os_log_impl(&dword_1830D4000, v11, v21, "%{public}s metadata must be http, no backtrace", buf, 0xCu);
      }
      goto LABEL_57;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v32 = "nw_http_metadata_set_path";
      __int16 v33 = 2082;
      BOOL v34 = v20;
      _os_log_impl(&dword_1830D4000, v11, v21, "%{public}s metadata must be http, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_38;
  }
  if (!a2)
  {
    os_log_type_t v15 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v32 = "nw_http_metadata_set_path";
    xpc_object_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (!__nwlog_fault(v10, &type, &v29)) {
      goto LABEL_58;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v32 = "nw_http_metadata_set_path";
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null path", buf, 0xCu);
      }
      goto LABEL_57;
    }
    if (!v29)
    {
      id v11 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v32 = "nw_http_metadata_set_path";
        _os_log_impl(&dword_1830D4000, v11, v27, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_57;
    }
    os_log_type_t v20 = (char *)__nw_create_backtrace_string();
    id v11 = __nwlog_obj();
    os_log_type_t v23 = type;
    BOOL v24 = os_log_type_enabled(v11, type);
    if (!v20)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v32 = "nw_http_metadata_set_path";
        _os_log_impl(&dword_1830D4000, v11, v23, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
      goto LABEL_57;
    }
    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v32 = "nw_http_metadata_set_path";
      __int16 v33 = 2082;
      BOOL v34 = v20;
      _os_log_impl(&dword_1830D4000, v11, v23, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_38:

    free(v20);
    if (!v10) {
      goto LABEL_8;
    }
    goto LABEL_59;
  }
  v28[0] = MEMORY[0x1E4F143A8];
  v28[1] = 3221225472;
  v28[2] = __nw_http_metadata_set_path_block_invoke;
  v28[3] = &__block_descriptor_40_e9_B16__0_v8l;
  v28[4] = a2;
  uint64_t v8 = *((void *)v5 + 4);
  if (v8) {
    __nw_http_metadata_set_path_block_invoke((uint64_t)v28, v8);
  }
LABEL_8:
}

uint64_t nw_http_metadata_get_status(void *a1)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = nw_protocol_metadata_copy_definition(v1);
    if (nw_protocol_copy_http_definition_onceToken != -1) {
      dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_15_74223);
    }
    BOOL is_equal = nw_protocol_definition_is_equal(v3, (nw_protocol_definition_t)nw_protocol_copy_http_definition_http_definition);

    if (is_equal)
    {
      *(void *)buf = 0;
      *(void *)&buf[8] = buf;
      int v26 = 0;
      *(void *)&buf[16] = 0x2020000000;
      v22[0] = MEMORY[0x1E4F143A8];
      v22[1] = 3221225472;
      v22[2] = __nw_http_metadata_get_status_block_invoke;
      v22[3] = &unk_1E5248E90;
      v22[4] = buf;
      uint64_t isa = (uint64_t)v2[4].isa;
      if (isa)
      {
        __nw_http_metadata_get_status_block_invoke((uint64_t)v22, isa);
        id v6 = (unsigned int *)(*(void *)&buf[8] + 24);
      }
      else
      {
        id v6 = (unsigned int *)&v26;
      }
      uint64_t v7 = *v6;
      _Block_object_dispose(buf, 8);
      goto LABEL_9;
    }
    os_log_type_t v13 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_metadata_get_status";
    xpc_object_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v10, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v11 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_get_status";
          _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s metadata must be http", buf, 0xCu);
        }
LABEL_41:

        goto LABEL_42;
      }
      if (!v23)
      {
        id v11 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_get_status";
          _os_log_impl(&dword_1830D4000, v11, v21, "%{public}s metadata must be http, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_41;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v11 = __nwlog_obj();
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_get_status";
          _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s metadata must be http, no backtrace", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_metadata_get_status";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s metadata must be http, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_29;
    }
  }
  else
  {
    uint64_t v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_metadata_get_status";
    xpc_object_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v10, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_get_status";
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null metadata", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (!v23)
      {
        id v11 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_get_status";
          _os_log_impl(&dword_1830D4000, v11, v20, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_41;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_get_status";
          _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_metadata_get_status";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_29:

      free(backtrace_string);
    }
  }
LABEL_42:
  if (v10) {
    free(v10);
  }
  uint64_t v7 = 0;
LABEL_9:

  return v7;
}

void sub_18346CA18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t nw_http_metadata_get_path(void *a1)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = nw_protocol_metadata_copy_definition(v1);
    if (nw_protocol_copy_http_definition_onceToken != -1) {
      dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_15_74223);
    }
    BOOL is_equal = nw_protocol_definition_is_equal(v3, (nw_protocol_definition_t)nw_protocol_copy_http_definition_http_definition);

    if (is_equal)
    {
      *(void *)buf = 0;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x3032000000;
      int v26 = __Block_byref_object_copy__5_73857;
      uint64_t v27 = __Block_byref_object_dispose__6_73858;
      id v28 = 0;
      v22[0] = MEMORY[0x1E4F143A8];
      v22[1] = 3221225472;
      v22[2] = __nw_http_metadata_get_path_block_invoke;
      v22[3] = &unk_1E5248E90;
      v22[4] = buf;
      uint64_t isa = (uint64_t)v2[4].isa;
      if (isa)
      {
        __nw_http_metadata_get_path_block_invoke((uint64_t)v22, isa);
        id v6 = *(void **)(*(void *)&buf[8] + 40);
      }
      else
      {
        id v6 = 0;
      }
      uint64_t v7 = [v6 cStringUsingEncoding:5];
      _Block_object_dispose(buf, 8);

      goto LABEL_9;
    }
    os_log_type_t v13 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_metadata_get_path";
    xpc_object_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v10, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v11 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_get_path";
          _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s metadata must be http", buf, 0xCu);
        }
LABEL_41:

        goto LABEL_42;
      }
      if (!v23)
      {
        id v11 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_get_path";
          _os_log_impl(&dword_1830D4000, v11, v21, "%{public}s metadata must be http, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_41;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v11 = __nwlog_obj();
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_get_path";
          _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s metadata must be http, no backtrace", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_metadata_get_path";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s metadata must be http, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_29;
    }
  }
  else
  {
    uint64_t v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_metadata_get_path";
    xpc_object_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v10, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_get_path";
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null metadata", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (!v23)
      {
        id v11 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_get_path";
          _os_log_impl(&dword_1830D4000, v11, v20, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_41;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_get_path";
          _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_metadata_get_path";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_29:

      free(backtrace_string);
    }
  }
LABEL_42:
  if (v10) {
    free(v10);
  }
  uint64_t v7 = 0;
LABEL_9:

  return v7;
}

void sub_18346CFE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t nw_http_metadata_get_datagram_context_id(void *a1)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = nw_protocol_metadata_copy_definition(v1);
    if (nw_protocol_copy_http_definition_onceToken != -1) {
      dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_15_74223);
    }
    BOOL is_equal = nw_protocol_definition_is_equal(v3, (nw_protocol_definition_t)nw_protocol_copy_http_definition_http_definition);

    if (is_equal)
    {
      *(void *)buf = 0;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x2020000000;
      uint64_t v25 = 0;
      v21[0] = MEMORY[0x1E4F143A8];
      v21[1] = 3221225472;
      v21[2] = __nw_http_metadata_get_datagram_context_id_block_invoke;
      v21[3] = &unk_1E5248E90;
      v21[4] = buf;
      uint64_t isa = (uint64_t)v2[4].isa;
      if (isa)
      {
        __nw_http_metadata_get_datagram_context_id_block_invoke((uint64_t)v21, isa);
        uint64_t v6 = *(void *)(*(void *)&buf[8] + 24);
      }
      else
      {
        uint64_t v6 = 0;
      }
      _Block_object_dispose(buf, 8);
      goto LABEL_9;
    }
    os_log_type_t v12 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_metadata_get_datagram_context_id";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (__nwlog_fault(v9, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        xpc_object_t v10 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_get_datagram_context_id";
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s metadata must be http", buf, 0xCu);
        }
LABEL_41:

        goto LABEL_42;
      }
      if (!v22)
      {
        xpc_object_t v10 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_get_datagram_context_id";
          _os_log_impl(&dword_1830D4000, v10, v20, "%{public}s metadata must be http, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_41;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      xpc_object_t v10 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_get_datagram_context_id";
          _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s metadata must be http, no backtrace", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_metadata_get_datagram_context_id";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s metadata must be http, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_29;
    }
  }
  else
  {
    uint64_t v8 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_metadata_get_datagram_context_id";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (__nwlog_fault(v9, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        xpc_object_t v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_get_datagram_context_id";
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null metadata", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (!v22)
      {
        xpc_object_t v10 = __nwlog_obj();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_get_datagram_context_id";
          _os_log_impl(&dword_1830D4000, v10, v19, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_41;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      xpc_object_t v10 = __nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_get_datagram_context_id";
          _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_metadata_get_datagram_context_id";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_29:

      free(backtrace_string);
    }
  }
LABEL_42:
  if (v9) {
    free(v9);
  }
  uint64_t v6 = 0;
LABEL_9:

  return v6;
}

void nw_http_metadata_enumerate_modern_header_fields_combined(void *a1, void *a2)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  id v5 = v3;
  uint64_t v6 = v5;
  if (v5)
  {
    id v7 = *((id *)v5 + 1);
    goto LABEL_3;
  }
  xpc_object_t v10 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v39 = "nw_protocol_metadata_copy_definition";
  os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v36 = 0;
  if (__nwlog_fault(v11, &type, &v36))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        id v39 = "nw_protocol_metadata_copy_definition";
        _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v36)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v23 = type;
      BOOL v24 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446466;
          id v39 = "nw_protocol_metadata_copy_definition";
          __int16 v40 = 2082;
          uint64_t v41 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v12, v23, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_53;
      }
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        id v39 = "nw_protocol_metadata_copy_definition";
        _os_log_impl(&dword_1830D4000, v12, v23, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v31 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        id v39 = "nw_protocol_metadata_copy_definition";
        _os_log_impl(&dword_1830D4000, v12, v31, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_53:
  if (v11) {
    free(v11);
  }
  id v7 = 0;
LABEL_3:

  if (nw_protocol_copy_http_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_15_74223);
  }
  BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v7, nw_protocol_copy_http_definition_http_definition);

  if (is_equal_unsafe)
  {
    v34[0] = MEMORY[0x1E4F143A8];
    v34[1] = 3221225472;
    v34[2] = __nw_http_metadata_enumerate_modern_header_fields_combined_block_invoke;
    v34[3] = &unk_1E5248ED8;
    id v35 = v4;
    if (v6)
    {
      uint64_t v9 = v6[4];
      if (v9) {
        __nw_http_metadata_enumerate_modern_header_fields_combined_block_invoke((uint64_t)v34, v9);
      }
LABEL_9:

      goto LABEL_10;
    }
    BOOL v18 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v39 = "nw_protocol_metadata_access_handle";
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (__nwlog_fault(v19, &type, &v36))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v20 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446210;
          id v39 = "nw_protocol_metadata_access_handle";
          _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s called with null metadata", buf, 0xCu);
        }
      }
      else if (v36)
      {
        id v28 = (char *)__nw_create_backtrace_string();
        os_log_type_t v20 = __nwlog_obj();
        os_log_type_t v29 = type;
        BOOL v30 = os_log_type_enabled(v20, type);
        if (v28)
        {
          if (v30)
          {
            *(_DWORD *)buf = 136446466;
            id v39 = "nw_protocol_metadata_access_handle";
            __int16 v40 = 2082;
            uint64_t v41 = v28;
            _os_log_impl(&dword_1830D4000, v20, v29, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v28);
          goto LABEL_64;
        }
        if (v30)
        {
          *(_DWORD *)buf = 136446210;
          id v39 = "nw_protocol_metadata_access_handle";
          _os_log_impl(&dword_1830D4000, v20, v29, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v20 = __nwlog_obj();
        os_log_type_t v33 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446210;
          id v39 = "nw_protocol_metadata_access_handle";
          _os_log_impl(&dword_1830D4000, v20, v33, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_64:
    if (v19) {
      free(v19);
    }
    goto LABEL_9;
  }
  os_log_type_t v14 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v39 = "nw_http_metadata_enumerate_modern_header_fields_combined";
  os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v36 = 0;
  if (__nwlog_fault(v15, &type, &v36))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        id v39 = "nw_http_metadata_enumerate_modern_header_fields_combined";
        _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s metadata must be http", buf, 0xCu);
      }
    }
    else if (v36)
    {
      uint64_t v25 = (char *)__nw_create_backtrace_string();
      BOOL v16 = __nwlog_obj();
      os_log_type_t v26 = type;
      BOOL v27 = os_log_type_enabled(v16, type);
      if (v25)
      {
        if (v27)
        {
          *(_DWORD *)buf = 136446466;
          id v39 = "nw_http_metadata_enumerate_modern_header_fields_combined";
          __int16 v40 = 2082;
          uint64_t v41 = v25;
          _os_log_impl(&dword_1830D4000, v16, v26, "%{public}s metadata must be http, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v25);
        goto LABEL_59;
      }
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        id v39 = "nw_http_metadata_enumerate_modern_header_fields_combined";
        _os_log_impl(&dword_1830D4000, v16, v26, "%{public}s metadata must be http, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v16 = __nwlog_obj();
      os_log_type_t v32 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        id v39 = "nw_http_metadata_enumerate_modern_header_fields_combined";
        _os_log_impl(&dword_1830D4000, v16, v32, "%{public}s metadata must be http, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_59:
  if (v15) {
    free(v15);
  }
LABEL_10:
}

id nw_http_metadata_copy_header_fields(void *a1)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = nw_protocol_metadata_copy_definition(v1);
    if (nw_protocol_copy_http_definition_onceToken != -1) {
      dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_15_74223);
    }
    BOOL is_equal = nw_protocol_definition_is_equal(v3, (nw_protocol_definition_t)nw_protocol_copy_http_definition_http_definition);

    if (is_equal)
    {
      *(void *)buf = 0;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x3032000000;
      os_log_type_t v26 = __Block_byref_object_copy__5_73857;
      BOOL v27 = __Block_byref_object_dispose__6_73858;
      id v28 = 0;
      v22[0] = MEMORY[0x1E4F143A8];
      v22[1] = 3221225472;
      v22[2] = __nw_http_metadata_copy_header_fields_block_invoke;
      v22[3] = &unk_1E5248E90;
      v22[4] = buf;
      uint64_t isa = (uint64_t)v2[4].isa;
      if (isa)
      {
        __nw_http_metadata_copy_header_fields_block_invoke((uint64_t)v22, isa);
        uint64_t v6 = *(void **)(*(void *)&buf[8] + 40);
      }
      else
      {
        uint64_t v6 = 0;
      }
      id v7 = v6;
      _Block_object_dispose(buf, 8);

      goto LABEL_9;
    }
    os_log_type_t v13 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_header_fields";
    xpc_object_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v10, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_header_fields";
          _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s metadata must be http", buf, 0xCu);
        }
LABEL_41:

        goto LABEL_42;
      }
      if (!v23)
      {
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_header_fields";
          _os_log_impl(&dword_1830D4000, v11, v21, "%{public}s metadata must be http, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_41;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_header_fields";
          _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s metadata must be http, no backtrace", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_header_fields";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s metadata must be http, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_29;
    }
  }
  else
  {
    uint64_t v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_header_fields";
    xpc_object_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v10, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_header_fields";
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null metadata", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (!v23)
      {
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_header_fields";
          _os_log_impl(&dword_1830D4000, v11, v20, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_41;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_header_fields";
          _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_header_fields";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_29:

      free(backtrace_string);
    }
  }
LABEL_42:
  if (v10) {
    free(v10);
  }
  id v7 = 0;
LABEL_9:

  return v7;
}

id nw_http_metadata_copy_endpoint(void *a1)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = nw_protocol_metadata_copy_definition(v1);
    if (nw_protocol_copy_http_definition_onceToken != -1) {
      dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_15_74223);
    }
    BOOL is_equal = nw_protocol_definition_is_equal(v3, (nw_protocol_definition_t)nw_protocol_copy_http_definition_http_definition);

    if (is_equal)
    {
      *(void *)buf = 0;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x3032000000;
      os_log_type_t v26 = __Block_byref_object_copy__5_73857;
      BOOL v27 = __Block_byref_object_dispose__6_73858;
      id v28 = 0;
      v22[0] = MEMORY[0x1E4F143A8];
      v22[1] = 3221225472;
      v22[2] = __nw_http_metadata_copy_endpoint_block_invoke;
      v22[3] = &unk_1E5248E90;
      v22[4] = buf;
      uint64_t isa = (uint64_t)v2[4].isa;
      if (isa)
      {
        __nw_http_metadata_copy_endpoint_block_invoke((uint64_t)v22, isa);
        uint64_t v6 = *(void **)(*(void *)&buf[8] + 40);
      }
      else
      {
        uint64_t v6 = 0;
      }
      id v7 = v6;
      _Block_object_dispose(buf, 8);

      goto LABEL_9;
    }
    os_log_type_t v13 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_endpoint";
    xpc_object_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v10, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_endpoint";
          _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s metadata must be http", buf, 0xCu);
        }
LABEL_41:

        goto LABEL_42;
      }
      if (!v23)
      {
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_endpoint";
          _os_log_impl(&dword_1830D4000, v11, v21, "%{public}s metadata must be http, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_41;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_endpoint";
          _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s metadata must be http, no backtrace", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_endpoint";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s metadata must be http, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_29;
    }
  }
  else
  {
    uint64_t v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_endpoint";
    xpc_object_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v10, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_endpoint";
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null metadata", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (!v23)
      {
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_endpoint";
          _os_log_impl(&dword_1830D4000, v11, v20, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_41;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_endpoint";
          _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_endpoint";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_29:

      free(backtrace_string);
    }
  }
LABEL_42:
  if (v10) {
    free(v10);
  }
  id v7 = 0;
LABEL_9:

  return v7;
}

void sub_18346E850(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void nw_http_messaging_options_set_client_metadata(void *a1, void *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (!v3)
  {
    uint64_t v8 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v27 = "nw_http_messaging_options_set_client_metadata";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (!__nwlog_fault(v9, &type, &v24)) {
      goto LABEL_40;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      xpc_object_t v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v27 = "nw_http_messaging_options_set_client_metadata";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null options", buf, 0xCu);
      }
    }
    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      xpc_object_t v10 = __nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v27 = "nw_http_messaging_options_set_client_metadata";
          __int16 v28 = 2082;
          uint64_t v29 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_40:
        if (!v9) {
          goto LABEL_6;
        }
LABEL_41:
        free(v9);
        goto LABEL_6;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v27 = "nw_http_messaging_options_set_client_metadata";
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      xpc_object_t v10 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v27 = "nw_http_messaging_options_set_client_metadata";
        _os_log_impl(&dword_1830D4000, v10, v20, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_39:

    goto LABEL_40;
  }
  id v5 = (id *)v3;
  id v6 = v5[1];

  if (nw_protocol_copy_http_messaging_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_messaging_definition_onceToken, &__block_literal_global_81);
  }
  BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v6, nw_protocol_copy_http_messaging_definition_definition);

  if (is_equal_unsafe)
  {
    v22[0] = MEMORY[0x1E4F143A8];
    v22[1] = 3221225472;
    v22[2] = __nw_http_messaging_options_set_client_metadata_block_invoke;
    v22[3] = &unk_1E5248F68;
    id v23 = v4;
    nw_protocol_options_access_handle(v5, v22);

    goto LABEL_6;
  }
  os_log_type_t v12 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v27 = "nw_http_messaging_options_set_client_metadata";
  uint64_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v24 = 0;
  if (!__nwlog_fault(v9, &type, &v24)) {
    goto LABEL_40;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    xpc_object_t v10 = __nwlog_obj();
    os_log_type_t v13 = type;
    if (os_log_type_enabled(v10, type))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v27 = "nw_http_messaging_options_set_client_metadata";
      _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s protocol options are not http_messaging", buf, 0xCu);
    }
    goto LABEL_39;
  }
  if (!v24)
  {
    xpc_object_t v10 = __nwlog_obj();
    os_log_type_t v21 = type;
    if (os_log_type_enabled(v10, type))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v27 = "nw_http_messaging_options_set_client_metadata";
      _os_log_impl(&dword_1830D4000, v10, v21, "%{public}s protocol options are not http_messaging, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_39;
  }
  BOOL v17 = (char *)__nw_create_backtrace_string();
  xpc_object_t v10 = __nwlog_obj();
  os_log_type_t v18 = type;
  BOOL v19 = os_log_type_enabled(v10, type);
  if (!v17)
  {
    if (v19)
    {
      *(_DWORD *)buf = 136446210;
      BOOL v27 = "nw_http_messaging_options_set_client_metadata";
      _os_log_impl(&dword_1830D4000, v10, v18, "%{public}s protocol options are not http_messaging, no backtrace", buf, 0xCu);
    }
    goto LABEL_39;
  }
  if (v19)
  {
    *(_DWORD *)buf = 136446466;
    BOOL v27 = "nw_http_messaging_options_set_client_metadata";
    __int16 v28 = 2082;
    uint64_t v29 = v17;
    _os_log_impl(&dword_1830D4000, v10, v18, "%{public}s protocol options are not http_messaging, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v17);
  if (v9) {
    goto LABEL_41;
  }
LABEL_6:
}

BOOL nw_http_messaging_options_override_version_specific_protocol(void *a1, uint64_t a2, void *a3)
{
  id v5 = a1;
  id v6 = a3;
  id v7 = nw_protocol_options_copy_definition(v5);
  if (nw_protocol_copy_http_messaging_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_messaging_definition_onceToken, &__block_literal_global_81);
  }
  BOOL is_equal = nw_protocol_definition_is_equal(v7, (nw_protocol_definition_t)nw_protocol_copy_http_messaging_definition_definition);

  if (is_equal)
  {
    uint64_t v15 = 0;
    BOOL v16 = &v15;
    uint64_t v17 = 0x2020000000;
    char v18 = 0;
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 3221225472;
    v11[2] = __nw_http_messaging_options_override_version_specific_protocol_block_invoke;
    v11[3] = &unk_1E52490E8;
    os_log_type_t v13 = &v15;
    uint64_t v14 = a2;
    id v12 = v6;
    nw_protocol_options_access_handle(v5, v11);
    BOOL v9 = *((unsigned char *)v16 + 24) != 0;

    _Block_object_dispose(&v15, 8);
  }
  else
  {
    BOOL v9 = 0;
  }

  return v9;
}

void sub_18346EF20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *nw_http_messaging_options_find_or_create_client_metadata_in_parameters(void *a1, uint64_t a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    if (a2)
    {
      id http_messaging_options = nw_parameters_find_http_messaging_options(v3, a2);
      id v6 = http_messaging_options;
      if (http_messaging_options)
      {
        singleton = nw_http_messaging_options_copy_client_metadata(http_messaging_options);
        if (!singleton)
        {
          if (nw_protocol_copy_http_client_definition_onceToken != -1) {
            dispatch_once(&nw_protocol_copy_http_client_definition_onceToken, &__block_literal_global_72_75798);
          }
          singleton = nw_protocol_metadata_create_singleton((void *)nw_protocol_copy_http_client_definition_definition);
          nw_http_client_metadata_create_next_transaction(singleton, 0);
          nw_http_messaging_options_set_client_metadata(v6, singleton);
        }
LABEL_8:

        goto LABEL_9;
      }
      uint64_t v15 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      uint64_t v29 = "nw_http_messaging_options_find_or_create_client_metadata_in_parameters";
      BOOL v16 = (void *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v26 = 0;
      if (!__nwlog_fault((const char *)v16, &type, &v26))
      {
LABEL_56:
        if (v16) {
          free(v16);
        }
        singleton = 0;
        goto LABEL_8;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v17 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v29 = "nw_http_messaging_options_find_or_create_client_metadata_in_parameters";
          BOOL v19 = "%{public}s called with null messaging_options";
LABEL_54:
          _os_log_impl(&dword_1830D4000, v17, v18, v19, buf, 0xCu);
        }
      }
      else
      {
        if (v26)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          uint64_t v17 = __nwlog_obj();
          os_log_type_t v18 = type;
          BOOL v25 = os_log_type_enabled(v17, type);
          if (backtrace_string)
          {
            if (v25)
            {
              *(_DWORD *)buf = 136446466;
              uint64_t v29 = "nw_http_messaging_options_find_or_create_client_metadata_in_parameters";
              __int16 v30 = 2082;
              os_log_type_t v31 = backtrace_string;
              _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s called with null messaging_options, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_56;
          }
          if (!v25) {
            goto LABEL_55;
          }
          *(_DWORD *)buf = 136446210;
          uint64_t v29 = "nw_http_messaging_options_find_or_create_client_metadata_in_parameters";
          BOOL v19 = "%{public}s called with null messaging_options, no backtrace";
          goto LABEL_54;
        }
        uint64_t v17 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v29 = "nw_http_messaging_options_find_or_create_client_metadata_in_parameters";
          BOOL v19 = "%{public}s called with null messaging_options, backtrace limit exceeded";
          goto LABEL_54;
        }
      }
LABEL_55:

      goto LABEL_56;
    }
    uint64_t v14 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v29 = "nw_http_messaging_options_find_or_create_client_metadata_in_parameters";
    xpc_object_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (__nwlog_fault(v10, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v29 = "nw_http_messaging_options_find_or_create_client_metadata_in_parameters";
          os_log_type_t v13 = "%{public}s called with null below_protocol";
          goto LABEL_47;
        }
        goto LABEL_48;
      }
      if (!v26)
      {
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v29 = "nw_http_messaging_options_find_or_create_client_metadata_in_parameters";
          os_log_type_t v13 = "%{public}s called with null below_protocol, backtrace limit exceeded";
          goto LABEL_47;
        }
        goto LABEL_48;
      }
      os_log_type_t v20 = (char *)__nw_create_backtrace_string();
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v23 = os_log_type_enabled(v11, type);
      if (!v20)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v29 = "nw_http_messaging_options_find_or_create_client_metadata_in_parameters";
          os_log_type_t v13 = "%{public}s called with null below_protocol, no backtrace";
          goto LABEL_47;
        }
        goto LABEL_48;
      }
      if (!v23) {
        goto LABEL_31;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v29 = "nw_http_messaging_options_find_or_create_client_metadata_in_parameters";
      __int16 v30 = 2082;
      os_log_type_t v31 = v20;
      char v22 = "%{public}s called with null below_protocol, dumping backtrace:%{public}s";
LABEL_30:
      _os_log_impl(&dword_1830D4000, v11, v12, v22, buf, 0x16u);
LABEL_31:

      free(v20);
    }
  }
  else
  {
    BOOL v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v29 = "nw_http_messaging_options_find_or_create_client_metadata_in_parameters";
    xpc_object_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (__nwlog_fault(v10, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v29 = "nw_http_messaging_options_find_or_create_client_metadata_in_parameters";
          os_log_type_t v13 = "%{public}s called with null parameters";
LABEL_47:
          _os_log_impl(&dword_1830D4000, v11, v12, v13, buf, 0xCu);
        }
LABEL_48:

        goto LABEL_49;
      }
      if (!v26)
      {
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v29 = "nw_http_messaging_options_find_or_create_client_metadata_in_parameters";
          os_log_type_t v13 = "%{public}s called with null parameters, backtrace limit exceeded";
          goto LABEL_47;
        }
        goto LABEL_48;
      }
      os_log_type_t v20 = (char *)__nw_create_backtrace_string();
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v21 = os_log_type_enabled(v11, type);
      if (!v20)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v29 = "nw_http_messaging_options_find_or_create_client_metadata_in_parameters";
          os_log_type_t v13 = "%{public}s called with null parameters, no backtrace";
          goto LABEL_47;
        }
        goto LABEL_48;
      }
      if (!v21) {
        goto LABEL_31;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v29 = "nw_http_messaging_options_find_or_create_client_metadata_in_parameters";
      __int16 v30 = 2082;
      os_log_type_t v31 = v20;
      char v22 = "%{public}s called with null parameters, dumping backtrace:%{public}s";
      goto LABEL_30;
    }
  }
LABEL_49:
  if (v10) {
    free(v10);
  }
  singleton = 0;
LABEL_9:

  return singleton;
}

id nw_http_messaging_options_copy_transaction_metadata(void *a1)
{
  id v1 = a1;
  uint64_t v2 = nw_protocol_options_copy_definition(v1);
  if (nw_protocol_copy_http_messaging_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_messaging_definition_onceToken, &__block_literal_global_81);
  }
  BOOL is_equal = nw_protocol_definition_is_equal(v2, (nw_protocol_definition_t)nw_protocol_copy_http_messaging_definition_definition);

  if (is_equal)
  {
    uint64_t v7 = 0;
    uint64_t v8 = &v7;
    uint64_t v9 = 0x3032000000;
    xpc_object_t v10 = __Block_byref_object_copy__5_73857;
    os_log_type_t v11 = __Block_byref_object_dispose__6_73858;
    id v12 = 0;
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 3221225472;
    v6[2] = __nw_http_messaging_options_copy_transaction_metadata_block_invoke;
    v6[3] = &unk_1E5248E90;
    v6[4] = &v7;
    nw_protocol_options_access_handle(v1, v6);
    id v4 = (id)v8[5];
    _Block_object_dispose(&v7, 8);
  }
  else
  {
    id v4 = 0;
  }

  return v4;
}

void sub_18346F6C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL nw_http_encrypt_chunked_oblivious_response_chunk(uint64_t a1, uint64_t a2, const char *a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, const void *a8, size_t a9, const void *a10, size_t a11, size_t *a12)
{
  uint64_t v110 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    nw_protocol_metadata_t v44 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v88 = 0;
    if (!__nwlog_fault(v44, &buf, &v88)) {
      goto LABEL_220;
    }
    if (buf == 17)
    {
      id v45 = __nwlog_obj();
      os_log_type_t v46 = buf;
      if (!os_log_type_enabled(v45, (os_log_type_t)buf)) {
        goto LABEL_220;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      char v47 = "%{public}s called with null message_buffer";
      goto LABEL_219;
    }
    if (!v88)
    {
      id v45 = __nwlog_obj();
      os_log_type_t v46 = buf;
      if (!os_log_type_enabled(v45, (os_log_type_t)buf)) {
        goto LABEL_220;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      char v47 = "%{public}s called with null message_buffer, backtrace limit exceeded";
      goto LABEL_219;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    id v45 = __nwlog_obj();
    os_log_type_t v46 = buf;
    BOOL v51 = os_log_type_enabled(v45, (os_log_type_t)buf);
    if (!backtrace_string)
    {
      if (!v51) {
        goto LABEL_220;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      char v47 = "%{public}s called with null message_buffer, no backtrace";
      goto LABEL_219;
    }
    if (!v51) {
      goto LABEL_162;
    }
    *(_DWORD *)__str = 136446466;
    *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    *(_WORD *)&__str[12] = 2082;
    *(void *)&__str[14] = backtrace_string;
    BOOL v52 = "%{public}s called with null message_buffer, dumping backtrace:%{public}s";
LABEL_161:
    _os_log_impl(&dword_1830D4000, v45, v46, v52, (uint8_t *)__str, 0x16u);
    goto LABEL_162;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    nw_protocol_metadata_t v44 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v88 = 0;
    if (!__nwlog_fault(v44, &buf, &v88)) {
      goto LABEL_220;
    }
    if (buf == 17)
    {
      id v45 = __nwlog_obj();
      os_log_type_t v46 = buf;
      if (!os_log_type_enabled(v45, (os_log_type_t)buf)) {
        goto LABEL_220;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      char v47 = "%{public}s called with null message_length";
      goto LABEL_219;
    }
    if (!v88)
    {
      id v45 = __nwlog_obj();
      os_log_type_t v46 = buf;
      if (!os_log_type_enabled(v45, (os_log_type_t)buf)) {
        goto LABEL_220;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      char v47 = "%{public}s called with null message_length, backtrace limit exceeded";
      goto LABEL_219;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    id v45 = __nwlog_obj();
    os_log_type_t v46 = buf;
    BOOL v53 = os_log_type_enabled(v45, (os_log_type_t)buf);
    if (!backtrace_string)
    {
      if (!v53) {
        goto LABEL_220;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      char v47 = "%{public}s called with null message_length, no backtrace";
      goto LABEL_219;
    }
    if (!v53) {
      goto LABEL_162;
    }
    *(_DWORD *)__str = 136446466;
    *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    *(_WORD *)&__str[12] = 2082;
    *(void *)&__str[14] = backtrace_string;
    BOOL v52 = "%{public}s called with null message_length, dumping backtrace:%{public}s";
    goto LABEL_161;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    nw_protocol_metadata_t v44 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v88 = 0;
    if (!__nwlog_fault(v44, &buf, &v88)) {
      goto LABEL_220;
    }
    if (buf == 17)
    {
      id v45 = __nwlog_obj();
      os_log_type_t v46 = buf;
      if (!os_log_type_enabled(v45, (os_log_type_t)buf)) {
        goto LABEL_220;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      char v47 = "%{public}s called with null media_type";
      goto LABEL_219;
    }
    if (!v88)
    {
      id v45 = __nwlog_obj();
      os_log_type_t v46 = buf;
      if (!os_log_type_enabled(v45, (os_log_type_t)buf)) {
        goto LABEL_220;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      char v47 = "%{public}s called with null media_type, backtrace limit exceeded";
      goto LABEL_219;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    id v45 = __nwlog_obj();
    os_log_type_t v46 = buf;
    BOOL v54 = os_log_type_enabled(v45, (os_log_type_t)buf);
    if (!backtrace_string)
    {
      if (!v54) {
        goto LABEL_220;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      char v47 = "%{public}s called with null media_type, no backtrace";
      goto LABEL_219;
    }
    if (!v54) {
      goto LABEL_162;
    }
    *(_DWORD *)__str = 136446466;
    *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    *(_WORD *)&__str[12] = 2082;
    *(void *)&__str[14] = backtrace_string;
    BOOL v52 = "%{public}s called with null media_type, dumping backtrace:%{public}s";
    goto LABEL_161;
  }
  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    nw_protocol_metadata_t v44 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v88 = 0;
    if (!__nwlog_fault(v44, &buf, &v88)) {
      goto LABEL_220;
    }
    if (buf == 17)
    {
      id v45 = __nwlog_obj();
      os_log_type_t v46 = buf;
      if (!os_log_type_enabled(v45, (os_log_type_t)buf)) {
        goto LABEL_220;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      char v47 = "%{public}s called with null request_context";
      goto LABEL_219;
    }
    if (!v88)
    {
      id v45 = __nwlog_obj();
      os_log_type_t v46 = buf;
      if (!os_log_type_enabled(v45, (os_log_type_t)buf)) {
        goto LABEL_220;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      char v47 = "%{public}s called with null request_context, backtrace limit exceeded";
      goto LABEL_219;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    id v45 = __nwlog_obj();
    os_log_type_t v46 = buf;
    BOOL v55 = os_log_type_enabled(v45, (os_log_type_t)buf);
    if (!backtrace_string)
    {
      if (!v55) {
        goto LABEL_220;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      char v47 = "%{public}s called with null request_context, no backtrace";
      goto LABEL_219;
    }
    if (!v55) {
      goto LABEL_162;
    }
    *(_DWORD *)__str = 136446466;
    *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    *(_WORD *)&__str[12] = 2082;
    *(void *)&__str[14] = backtrace_string;
    BOOL v52 = "%{public}s called with null request_context, dumping backtrace:%{public}s";
    goto LABEL_161;
  }
  if (!a7)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    nw_protocol_metadata_t v44 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v88 = 0;
    if (!__nwlog_fault(v44, &buf, &v88)) {
      goto LABEL_220;
    }
    if (buf == 17)
    {
      id v45 = __nwlog_obj();
      os_log_type_t v46 = buf;
      if (!os_log_type_enabled(v45, (os_log_type_t)buf)) {
        goto LABEL_220;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      char v47 = "%{public}s called with null request_context_length";
      goto LABEL_219;
    }
    if (!v88)
    {
      id v45 = __nwlog_obj();
      os_log_type_t v46 = buf;
      if (!os_log_type_enabled(v45, (os_log_type_t)buf)) {
        goto LABEL_220;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      char v47 = "%{public}s called with null request_context_length, backtrace limit exceeded";
      goto LABEL_219;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    id v45 = __nwlog_obj();
    os_log_type_t v46 = buf;
    BOOL v56 = os_log_type_enabled(v45, (os_log_type_t)buf);
    if (!backtrace_string)
    {
      if (!v56) {
        goto LABEL_220;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      char v47 = "%{public}s called with null request_context_length, no backtrace";
      goto LABEL_219;
    }
    if (!v56) {
      goto LABEL_162;
    }
    *(_DWORD *)__str = 136446466;
    *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    *(_WORD *)&__str[12] = 2082;
    *(void *)&__str[14] = backtrace_string;
    BOOL v52 = "%{public}s called with null request_context_length, dumping backtrace:%{public}s";
    goto LABEL_161;
  }
  if (!a8)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    nw_protocol_metadata_t v44 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v88 = 0;
    if (!__nwlog_fault(v44, &buf, &v88)) {
      goto LABEL_220;
    }
    if (buf == 17)
    {
      id v45 = __nwlog_obj();
      os_log_type_t v46 = buf;
      if (!os_log_type_enabled(v45, (os_log_type_t)buf)) {
        goto LABEL_220;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      char v47 = "%{public}s called with null request_enc";
      goto LABEL_219;
    }
    if (!v88)
    {
      id v45 = __nwlog_obj();
      os_log_type_t v46 = buf;
      if (!os_log_type_enabled(v45, (os_log_type_t)buf)) {
        goto LABEL_220;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      char v47 = "%{public}s called with null request_enc, backtrace limit exceeded";
      goto LABEL_219;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    id v45 = __nwlog_obj();
    os_log_type_t v46 = buf;
    BOOL v57 = os_log_type_enabled(v45, (os_log_type_t)buf);
    if (!backtrace_string)
    {
      if (!v57) {
        goto LABEL_220;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      char v47 = "%{public}s called with null request_enc, no backtrace";
      goto LABEL_219;
    }
    if (!v57) {
      goto LABEL_162;
    }
    *(_DWORD *)__str = 136446466;
    *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    *(_WORD *)&__str[12] = 2082;
    *(void *)&__str[14] = backtrace_string;
    BOOL v52 = "%{public}s called with null request_enc, dumping backtrace:%{public}s";
    goto LABEL_161;
  }
  if (!a9)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    nw_protocol_metadata_t v44 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v88 = 0;
    if (!__nwlog_fault(v44, &buf, &v88)) {
      goto LABEL_220;
    }
    if (buf == 17)
    {
      id v45 = __nwlog_obj();
      os_log_type_t v46 = buf;
      if (!os_log_type_enabled(v45, (os_log_type_t)buf)) {
        goto LABEL_220;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      char v47 = "%{public}s called with null request_enc_length";
      goto LABEL_219;
    }
    if (!v88)
    {
      id v45 = __nwlog_obj();
      os_log_type_t v46 = buf;
      if (!os_log_type_enabled(v45, (os_log_type_t)buf)) {
        goto LABEL_220;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      char v47 = "%{public}s called with null request_enc_length, backtrace limit exceeded";
      goto LABEL_219;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    id v45 = __nwlog_obj();
    os_log_type_t v46 = buf;
    BOOL v58 = os_log_type_enabled(v45, (os_log_type_t)buf);
    if (!backtrace_string)
    {
      if (!v58) {
        goto LABEL_220;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      char v47 = "%{public}s called with null request_enc_length, no backtrace";
      goto LABEL_219;
    }
    if (!v58) {
      goto LABEL_162;
    }
    *(_DWORD *)__str = 136446466;
    *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    *(_WORD *)&__str[12] = 2082;
    *(void *)&__str[14] = backtrace_string;
    BOOL v52 = "%{public}s called with null request_enc_length, dumping backtrace:%{public}s";
    goto LABEL_161;
  }
  if (!a10)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    nw_protocol_metadata_t v44 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v88 = 0;
    if (!__nwlog_fault(v44, &buf, &v88)) {
      goto LABEL_220;
    }
    if (buf == 17)
    {
      id v45 = __nwlog_obj();
      os_log_type_t v46 = buf;
      if (!os_log_type_enabled(v45, (os_log_type_t)buf)) {
        goto LABEL_220;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      char v47 = "%{public}s called with null response_nonce";
      goto LABEL_219;
    }
    if (!v88)
    {
      id v45 = __nwlog_obj();
      os_log_type_t v46 = buf;
      if (!os_log_type_enabled(v45, (os_log_type_t)buf)) {
        goto LABEL_220;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      char v47 = "%{public}s called with null response_nonce, backtrace limit exceeded";
      goto LABEL_219;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    id v45 = __nwlog_obj();
    os_log_type_t v46 = buf;
    BOOL v59 = os_log_type_enabled(v45, (os_log_type_t)buf);
    if (!backtrace_string)
    {
      if (!v59) {
        goto LABEL_220;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      char v47 = "%{public}s called with null response_nonce, no backtrace";
      goto LABEL_219;
    }
    if (!v59) {
      goto LABEL_162;
    }
    *(_DWORD *)__str = 136446466;
    *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    *(_WORD *)&__str[12] = 2082;
    *(void *)&__str[14] = backtrace_string;
    BOOL v52 = "%{public}s called with null response_nonce, dumping backtrace:%{public}s";
    goto LABEL_161;
  }
  if (!a11)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    nw_protocol_metadata_t v44 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v88 = 0;
    if (!__nwlog_fault(v44, &buf, &v88)) {
      goto LABEL_220;
    }
    if (buf == 17)
    {
      id v45 = __nwlog_obj();
      os_log_type_t v46 = buf;
      if (!os_log_type_enabled(v45, (os_log_type_t)buf)) {
        goto LABEL_220;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      char v47 = "%{public}s called with null response_nonce_length";
      goto LABEL_219;
    }
    if (!v88)
    {
      id v45 = __nwlog_obj();
      os_log_type_t v46 = buf;
      if (!os_log_type_enabled(v45, (os_log_type_t)buf)) {
        goto LABEL_220;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      char v47 = "%{public}s called with null response_nonce_length, backtrace limit exceeded";
      goto LABEL_219;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    id v45 = __nwlog_obj();
    os_log_type_t v46 = buf;
    BOOL v60 = os_log_type_enabled(v45, (os_log_type_t)buf);
    if (!backtrace_string)
    {
      if (!v60) {
        goto LABEL_220;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      char v47 = "%{public}s called with null response_nonce_length, no backtrace";
      goto LABEL_219;
    }
    if (!v60) {
      goto LABEL_162;
    }
    *(_DWORD *)__str = 136446466;
    *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    *(_WORD *)&__str[12] = 2082;
    *(void *)&__str[14] = backtrace_string;
    BOOL v52 = "%{public}s called with null response_nonce_length, dumping backtrace:%{public}s";
    goto LABEL_161;
  }
  if (!a12)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    nw_protocol_metadata_t v44 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v88 = 0;
    if (!__nwlog_fault(v44, &buf, &v88)) {
      goto LABEL_220;
    }
    if (buf == 17)
    {
      id v45 = __nwlog_obj();
      os_log_type_t v46 = buf;
      if (!os_log_type_enabled(v45, (os_log_type_t)buf)) {
        goto LABEL_220;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      char v47 = "%{public}s called with null out_encrypted_length";
      goto LABEL_219;
    }
    if (!v88)
    {
      id v45 = __nwlog_obj();
      os_log_type_t v46 = buf;
      if (!os_log_type_enabled(v45, (os_log_type_t)buf)) {
        goto LABEL_220;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      char v47 = "%{public}s called with null out_encrypted_length, backtrace limit exceeded";
      goto LABEL_219;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    id v45 = __nwlog_obj();
    os_log_type_t v46 = buf;
    BOOL v61 = os_log_type_enabled(v45, (os_log_type_t)buf);
    if (!backtrace_string)
    {
      if (!v61) {
        goto LABEL_220;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      char v47 = "%{public}s called with null out_encrypted_length, no backtrace";
      goto LABEL_219;
    }
    if (!v61) {
      goto LABEL_162;
    }
    *(_DWORD *)__str = 136446466;
    *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    *(_WORD *)&__str[12] = 2082;
    *(void *)&__str[14] = backtrace_string;
    BOOL v52 = "%{public}s called with null out_encrypted_length, dumping backtrace:%{public}s";
    goto LABEL_161;
  }
  cchpke_params_x25519_AESGCM128_HKDF_SHA256();
  unint64_t v14 = cchpke_params_sizeof_aead_key();
  unint64_t v15 = cchpke_params_sizeof_aead_nonce();
  uint64_t v85 = cchpke_params_sizeof_aead_tag();
  size_t size = v15;
  if (v14 <= v15) {
    unint64_t v16 = v15;
  }
  else {
    unint64_t v16 = v14;
  }
  if (v16 != a11)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    nw_protocol_metadata_t v44 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v88 = 0;
    if (!__nwlog_fault(v44, &buf, &v88)) {
      goto LABEL_220;
    }
    if (buf == 17)
    {
      id v45 = __nwlog_obj();
      os_log_type_t v46 = buf;
      if (!os_log_type_enabled(v45, (os_log_type_t)buf)) {
        goto LABEL_220;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      char v47 = "%{public}s called with null (exported_secret_length == response_nonce_length)";
      goto LABEL_219;
    }
    if (!v88)
    {
      id v45 = __nwlog_obj();
      os_log_type_t v46 = buf;
      if (!os_log_type_enabled(v45, (os_log_type_t)buf)) {
        goto LABEL_220;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      char v47 = "%{public}s called with null (exported_secret_length == response_nonce_length), backtrace limit exceeded";
      goto LABEL_219;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    id v45 = __nwlog_obj();
    os_log_type_t v46 = buf;
    BOOL v62 = os_log_type_enabled(v45, (os_log_type_t)buf);
    if (backtrace_string)
    {
      if (v62)
      {
        *(_DWORD *)__str = 136446466;
        *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
        *(_WORD *)&__str[12] = 2082;
        *(void *)&__str[14] = backtrace_string;
        BOOL v52 = "%{public}s called with null (exported_secret_length == response_nonce_length), dumping backtrace:%{public}s";
        goto LABEL_161;
      }
LABEL_162:
      free(backtrace_string);
      goto LABEL_220;
    }
    if (!v62) {
      goto LABEL_220;
    }
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    char v47 = "%{public}s called with null (exported_secret_length == response_nonce_length), no backtrace";
LABEL_219:
    _os_log_impl(&dword_1830D4000, v45, v46, v47, (uint8_t *)__str, 0xCu);
LABEL_220:
    if (v44) {
      free(v44);
    }
    return 0;
  }
  size_t v17 = v14;
  uint64_t v84 = a2;
  os_log_type_t v18 = malloc_type_calloc(1uLL, a11, 0xEAFB8F1AuLL);
  if (!v18)
  {
    os_log_type_t v48 = __nwlog_obj();
    os_log_type_enabled(v48, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__str = 136446722;
    *(void *)&__str[4] = "strict_calloc";
    *(_WORD *)&__str[12] = 2048;
    *(void *)&__str[14] = 1;
    *(_WORD *)&__str[22] = 2048;
    *(void *)&__str[24] = a11;
    os_log_type_t v49 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v49);
    if (result) {
      goto LABEL_230;
    }
    free(v49);
  }
  long long v102 = 0u;
  long long v103 = 0u;
  long long v100 = 0u;
  long long v101 = 0u;
  long long v98 = 0u;
  long long v99 = 0u;
  long long v96 = 0u;
  long long v97 = 0u;
  long long v94 = 0u;
  long long v95 = 0u;
  long long v92 = 0u;
  long long v93 = 0u;
  long long v90 = 0u;
  long long v91 = 0u;
  memset(__str, 0, sizeof(__str));
  snprintf(__str, 0x100uLL, "%s chunked response", a3);
  strlen(__str);
  int v19 = cchpke_responder_export();
  if (v19)
  {
    int v20 = v19;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v21 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      int buf = 136446466;
      os_log_type_t v105 = "nw_http_encrypt_chunked_oblivious_response_chunk";
      __int16 v106 = 1024;
      LODWORD(v107) = v20;
      _os_log_impl(&dword_1830D4000, v21, OS_LOG_TYPE_ERROR, "%{public}s Export error: %d", (uint8_t *)&buf, 0x12u);
    }
    if (!v18) {
      return 0;
    }
    goto LABEL_20;
  }
  if (!(a11 + a9))
  {
    os_log_type_t v63 = __nwlog_obj();
    os_log_type_enabled(v63, OS_LOG_TYPE_ERROR);
    int buf = 136446210;
    os_log_type_t v105 = "strict_calloc";
    os_log_type_t v64 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v64);
    if (result) {
      goto LABEL_230;
    }
    free(v64);
  }
  BOOL v23 = (char *)malloc_type_calloc(1uLL, a11 + a9, 0xEAFB8F1AuLL);
  if (!v23)
  {
    os_log_type_t v65 = __nwlog_obj();
    os_log_type_enabled(v65, OS_LOG_TYPE_ERROR);
    int buf = 136446722;
    os_log_type_t v105 = "strict_calloc";
    __int16 v106 = 2048;
    uint64_t v107 = 1;
    __int16 v108 = 2048;
    size_t v109 = a11 + a9;
    BOOL v66 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v66);
    if (result) {
      goto LABEL_230;
    }
    free(v66);
  }
  memcpy(v23, a8, a9);
  memcpy(&v23[a9], a10, a11);
  size_t v24 = cchpke_params_sizeof_kdf_hash();
  if (!v24)
  {
    BOOL v67 = __nwlog_obj();
    os_log_type_enabled(v67, OS_LOG_TYPE_ERROR);
    int buf = 136446210;
    os_log_type_t v105 = "strict_calloc";
    id v68 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v68);
    if (result) {
      goto LABEL_230;
    }
    free(v68);
  }
  BOOL v25 = malloc_type_calloc(1uLL, v24, 0xEAFB8F1AuLL);
  if (!v25)
  {
    os_log_type_t v69 = __nwlog_obj();
    os_log_type_enabled(v69, OS_LOG_TYPE_ERROR);
    int buf = 136446722;
    os_log_type_t v105 = "strict_calloc";
    __int16 v106 = 2048;
    uint64_t v107 = 1;
    __int16 v108 = 2048;
    size_t v109 = v24;
    id v70 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v70);
    if (result) {
      goto LABEL_230;
    }
    free(v70);
  }
  ccsha256_di();
  int v26 = cchkdf_extract();
  if (v23) {
    free(v23);
  }
  if (v18) {
    free(v18);
  }
  if (v26)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v27 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      int buf = 136446466;
      os_log_type_t v105 = "nw_http_encrypt_chunked_oblivious_response_chunk";
      __int16 v106 = 1024;
      LODWORD(v107) = v26;
      _os_log_impl(&dword_1830D4000, v27, OS_LOG_TYPE_ERROR, "%{public}s Extract error: %d", (uint8_t *)&buf, 0x12u);
    }
    if (!v25) {
      return 0;
    }
    char v22 = v25;
    goto LABEL_34;
  }
  if (!v17)
  {
    os_log_type_t v71 = __nwlog_obj();
    os_log_type_enabled(v71, OS_LOG_TYPE_ERROR);
    int buf = 136446210;
    os_log_type_t v105 = "strict_calloc";
    id v72 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v72);
    if (result) {
      goto LABEL_230;
    }
    free(v72);
  }
  os_log_type_t v18 = malloc_type_calloc(1uLL, v17, 0xEAFB8F1AuLL);
  if (!v18)
  {
    char v73 = __nwlog_obj();
    os_log_type_enabled(v73, OS_LOG_TYPE_ERROR);
    int buf = 136446722;
    os_log_type_t v105 = "strict_calloc";
    __int16 v106 = 2048;
    uint64_t v107 = 1;
    __int16 v108 = 2048;
    size_t v109 = v17;
    os_log_type_t v74 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v74);
    if (result) {
      goto LABEL_230;
    }
    free(v74);
  }
  int v30 = cchkdf_expand();
  if (v30)
  {
    int v31 = v30;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v32 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      int buf = 136446466;
      os_log_type_t v105 = "nw_http_encrypt_chunked_oblivious_response_chunk";
      __int16 v106 = 1024;
      LODWORD(v107) = v31;
      _os_log_impl(&dword_1830D4000, v32, OS_LOG_TYPE_ERROR, "%{public}s Key expand error: %d", (uint8_t *)&buf, 0x12u);
    }
    if (v25) {
      free(v25);
    }
    if (!v18) {
      return 0;
    }
LABEL_20:
    char v22 = v18;
LABEL_34:
    free(v22);
    return 0;
  }
  size_t v33 = size;
  if (!size)
  {
    BOOL v75 = __nwlog_obj();
    os_log_type_enabled(v75, OS_LOG_TYPE_ERROR);
    int buf = 136446210;
    os_log_type_t v105 = "strict_calloc";
    os_log_type_t v76 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v76);
    if (result) {
      goto LABEL_230;
    }
    free(v76);
    size_t v33 = 0;
  }
  BOOL v34 = (char *)malloc_type_calloc(1uLL, v33, 0xEAFB8F1AuLL);
  if (!v34)
  {
    os_log_type_t v77 = __nwlog_obj();
    os_log_type_enabled(v77, OS_LOG_TYPE_ERROR);
    int buf = 136446722;
    os_log_type_t v105 = "strict_calloc";
    __int16 v106 = 2048;
    uint64_t v107 = 1;
    __int16 v108 = 2048;
    size_t v109 = v33;
    BOOL v78 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v78);
    if (result) {
      goto LABEL_230;
    }
    free(v78);
  }
  int v35 = cchkdf_expand();
  if (v25) {
    free(v25);
  }
  if (v35)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v36 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      int buf = 136446466;
      os_log_type_t v105 = "nw_http_encrypt_chunked_oblivious_response_chunk";
      __int16 v106 = 1024;
      LODWORD(v107) = v35;
      id v37 = "%{public}s Nonce expand error: %d";
      BOOL v38 = v36;
      uint32_t v39 = 18;
LABEL_56:
      _os_log_impl(&dword_1830D4000, v38, OS_LOG_TYPE_ERROR, v37, (uint8_t *)&buf, v39);
      goto LABEL_57;
    }
    goto LABEL_57;
  }
  if (size <= 7)
  {
    __int16 v40 = __nwlog_obj();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
    {
      int buf = 136446466;
      os_log_type_t v105 = "nw_http_encrypt_chunked_oblivious_response_chunk";
      __int16 v106 = 2048;
      uint64_t v107 = size;
      id v37 = "%{public}s Bad nonce length: %zu";
      BOOL v38 = v40;
      uint32_t v39 = 22;
      goto LABEL_56;
    }
LABEL_57:
    if (v18) {
      free(v18);
    }
    if (!v34) {
      return 0;
    }
    char v22 = v34;
    goto LABEL_34;
  }
  *(void *)&v34[size - 8] ^= bswap64(a4);
  size_t v41 = v85 + v84;
  if (!(v85 + v84))
  {
    __int16 v79 = __nwlog_obj();
    os_log_type_enabled(v79, OS_LOG_TYPE_ERROR);
    int buf = 136446210;
    os_log_type_t v105 = "strict_calloc";
    uint64_t v80 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v80);
    if (result) {
      goto LABEL_230;
    }
    free(v80);
  }
  __int16 v28 = malloc_type_calloc(1uLL, v41, 0xEAFB8F1AuLL);
  if (v28)
  {
LABEL_63:
    ccaes_gcm_encrypt_mode();
    int v42 = ccgcm_one_shot();
    if (v18) {
      free(v18);
    }
    free(v34);
    if (!v42)
    {
      *a12 = v41;
      return (BOOL)v28;
    }
    BOOL v43 = __nwlog_obj();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
    {
      int buf = 136446466;
      os_log_type_t v105 = "nw_http_encrypt_chunked_oblivious_response_chunk";
      __int16 v106 = 1024;
      LODWORD(v107) = v42;
      _os_log_impl(&dword_1830D4000, v43, OS_LOG_TYPE_ERROR, "%{public}s Encrypt error: %u", (uint8_t *)&buf, 0x12u);
    }
    if (!v28) {
      return (BOOL)v28;
    }
    char v22 = v28;
    goto LABEL_34;
  }
  os_log_type_t v81 = __nwlog_obj();
  os_log_type_enabled(v81, OS_LOG_TYPE_ERROR);
  int buf = 136446722;
  os_log_type_t v105 = "strict_calloc";
  __int16 v106 = 2048;
  uint64_t v107 = 1;
  __int16 v108 = 2048;
  size_t v109 = v85 + v84;
  BOOL v82 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v82);
  if (!result)
  {
    free(v82);
    goto LABEL_63;
  }
LABEL_230:
  __break(1u);
  return result;
}

void nw_http_connection_metadata_increment_inbound_message_count(void *a1)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    uint64_t v7 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    size_t v24 = "nw_http_connection_metadata_increment_inbound_message_count";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (!__nwlog_fault(v8, &type, &v21)) {
      goto LABEL_41;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        size_t v24 = "nw_http_connection_metadata_increment_inbound_message_count";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)int buf = 136446466;
          size_t v24 = "nw_http_connection_metadata_increment_inbound_message_count";
          __int16 v25 = 2082;
          int v26 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_41:
        if (!v8) {
          goto LABEL_7;
        }
LABEL_42:
        free(v8);
        goto LABEL_7;
      }
      if (v15)
      {
        *(_DWORD *)int buf = 136446210;
        size_t v24 = "nw_http_connection_metadata_increment_inbound_message_count";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        size_t v24 = "nw_http_connection_metadata_increment_inbound_message_count";
        _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_40:

    goto LABEL_41;
  }
  id v3 = v1;
  id v4 = *((id *)v3 + 1);

  if (nw_protocol_copy_http_connection_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_connection_definition_onceToken, &__block_literal_global_89);
  }
  BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v4, nw_protocol_copy_http_connection_definition_definition);

  if (is_equal_unsafe)
  {
    uint64_t v6 = *((void *)v3 + 4);
    if (v6) {
      __nw_http_connection_metadata_increment_inbound_message_count_block_invoke((uint64_t)&__block_literal_global_98_76827, v6);
    }
    goto LABEL_7;
  }
  os_log_type_t v11 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  size_t v24 = "nw_http_connection_metadata_increment_inbound_message_count";
  uint64_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v21 = 0;
  if (!__nwlog_fault(v8, &type, &v21)) {
    goto LABEL_41;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v9 = __nwlog_obj();
    os_log_type_t v12 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)int buf = 136446210;
      size_t v24 = "nw_http_connection_metadata_increment_inbound_message_count";
      _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s metadata must be http_connection", buf, 0xCu);
    }
    goto LABEL_40;
  }
  if (!v21)
  {
    uint64_t v9 = __nwlog_obj();
    os_log_type_t v20 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)int buf = 136446210;
      size_t v24 = "nw_http_connection_metadata_increment_inbound_message_count";
      _os_log_impl(&dword_1830D4000, v9, v20, "%{public}s metadata must be http_connection, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_40;
  }
  unint64_t v16 = (char *)__nw_create_backtrace_string();
  uint64_t v9 = __nwlog_obj();
  os_log_type_t v17 = type;
  BOOL v18 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)int buf = 136446210;
      size_t v24 = "nw_http_connection_metadata_increment_inbound_message_count";
      _os_log_impl(&dword_1830D4000, v9, v17, "%{public}s metadata must be http_connection, no backtrace", buf, 0xCu);
    }
    goto LABEL_40;
  }
  if (v18)
  {
    *(_DWORD *)int buf = 136446466;
    size_t v24 = "nw_http_connection_metadata_increment_inbound_message_count";
    __int16 v25 = 2082;
    int v26 = v16;
    _os_log_impl(&dword_1830D4000, v9, v17, "%{public}s metadata must be http_connection, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v8) {
    goto LABEL_42;
  }
LABEL_7:
}

void nw_http_client_metadata_set_sniffed_media_type(void *a1, uint64_t a2)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    id v5 = *((id *)v3 + 1);
    goto LABEL_3;
  }
  uint64_t v8 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  BOOL v34 = "nw_protocol_metadata_copy_definition";
  uint64_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v31 = 0;
  if (__nwlog_fault(v9, &type, &v31))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v34 = "nw_protocol_metadata_copy_definition";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v31)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v20 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v34 = "nw_protocol_metadata_copy_definition";
          __int16 v35 = 2082;
          uint64_t v36 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v10, v19, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_53;
      }
      if (v20)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v34 = "nw_protocol_metadata_copy_definition";
        _os_log_impl(&dword_1830D4000, v10, v19, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v34 = "nw_protocol_metadata_copy_definition";
        _os_log_impl(&dword_1830D4000, v10, v27, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_53:
  if (v9) {
    free(v9);
  }
  id v5 = 0;
LABEL_3:

  if (nw_protocol_copy_http_client_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_client_definition_onceToken, &__block_literal_global_72_75798);
  }
  BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v5, nw_protocol_copy_http_client_definition_definition);

  if (!is_equal_unsafe)
  {
    os_log_type_t v12 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v34 = "nw_http_client_metadata_set_sniffed_media_type";
    os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (!__nwlog_fault(v13, &type, &v31)) {
      goto LABEL_62;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v34 = "nw_http_client_metadata_set_sniffed_media_type";
        _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s metadata must be http_client", buf, 0xCu);
      }
    }
    else if (v31)
    {
      char v21 = (char *)__nw_create_backtrace_string();
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v22 = type;
      BOOL v23 = os_log_type_enabled(v14, type);
      if (v21)
      {
        if (v23)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v34 = "nw_http_client_metadata_set_sniffed_media_type";
          __int16 v35 = 2082;
          uint64_t v36 = v21;
          _os_log_impl(&dword_1830D4000, v14, v22, "%{public}s metadata must be http_client, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v21);
LABEL_62:
        if (!v13) {
          goto LABEL_9;
        }
LABEL_63:
        free(v13);
        goto LABEL_9;
      }
      if (v23)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v34 = "nw_http_client_metadata_set_sniffed_media_type";
        _os_log_impl(&dword_1830D4000, v14, v22, "%{public}s metadata must be http_client, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v34 = "nw_http_client_metadata_set_sniffed_media_type";
        _os_log_impl(&dword_1830D4000, v14, v28, "%{public}s metadata must be http_client, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_61:

    goto LABEL_62;
  }
  v30[0] = MEMORY[0x1E4F143A8];
  v30[1] = 3221225472;
  v30[2] = __nw_http_client_metadata_set_sniffed_media_type_block_invoke;
  v30[3] = &__block_descriptor_40_e9_B16__0_v8l;
  v30[4] = a2;
  if (v4)
  {
    uint64_t v7 = v4[4];
    if (v7) {
      __nw_http_client_metadata_set_sniffed_media_type_block_invoke((uint64_t)v30, v7);
    }
    goto LABEL_9;
  }
  unint64_t v16 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  BOOL v34 = "nw_protocol_metadata_access_handle";
  os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v31 = 0;
  if (!__nwlog_fault(v13, &type, &v31)) {
    goto LABEL_62;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v14 = __nwlog_obj();
    os_log_type_t v17 = type;
    if (os_log_type_enabled(v14, type))
    {
      *(_DWORD *)int buf = 136446210;
      BOOL v34 = "nw_protocol_metadata_access_handle";
      _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null metadata", buf, 0xCu);
    }
    goto LABEL_61;
  }
  if (!v31)
  {
    os_log_type_t v14 = __nwlog_obj();
    os_log_type_t v29 = type;
    if (os_log_type_enabled(v14, type))
    {
      *(_DWORD *)int buf = 136446210;
      BOOL v34 = "nw_protocol_metadata_access_handle";
      _os_log_impl(&dword_1830D4000, v14, v29, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_61;
  }
  size_t v24 = (char *)__nw_create_backtrace_string();
  os_log_type_t v14 = __nwlog_obj();
  os_log_type_t v25 = type;
  BOOL v26 = os_log_type_enabled(v14, type);
  if (!v24)
  {
    if (v26)
    {
      *(_DWORD *)int buf = 136446210;
      BOOL v34 = "nw_protocol_metadata_access_handle";
      _os_log_impl(&dword_1830D4000, v14, v25, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
    }
    goto LABEL_61;
  }
  if (v26)
  {
    *(_DWORD *)int buf = 136446466;
    BOOL v34 = "nw_protocol_metadata_access_handle";
    __int16 v35 = 2082;
    uint64_t v36 = v24;
    _os_log_impl(&dword_1830D4000, v14, v25, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v24);
  if (v13) {
    goto LABEL_63;
  }
LABEL_9:
}

void nw_http_client_metadata_set_client_error(void *a1, int a2)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    id v5 = *((id *)v3 + 1);
    goto LABEL_3;
  }
  uint64_t v8 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  __int16 v35 = "nw_protocol_metadata_copy_definition";
  uint64_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v32 = 0;
  if (__nwlog_fault(v9, &type, &v32))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v35 = "nw_protocol_metadata_copy_definition";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v32)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v20 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)int buf = 136446466;
          __int16 v35 = "nw_protocol_metadata_copy_definition";
          __int16 v36 = 2082;
          uint64_t v37 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v10, v19, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_53;
      }
      if (v20)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v35 = "nw_protocol_metadata_copy_definition";
        _os_log_impl(&dword_1830D4000, v10, v19, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v35 = "nw_protocol_metadata_copy_definition";
        _os_log_impl(&dword_1830D4000, v10, v27, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_53:
  if (v9) {
    free(v9);
  }
  id v5 = 0;
LABEL_3:

  if (nw_protocol_copy_http_client_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_client_definition_onceToken, &__block_literal_global_72_75798);
  }
  BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v5, nw_protocol_copy_http_client_definition_definition);

  if (!is_equal_unsafe)
  {
    os_log_type_t v12 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v35 = "nw_http_client_metadata_set_client_error";
    os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (!__nwlog_fault(v13, &type, &v32)) {
      goto LABEL_62;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v35 = "nw_http_client_metadata_set_client_error";
        _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s metadata must be http_client", buf, 0xCu);
      }
    }
    else if (v32)
    {
      char v21 = (char *)__nw_create_backtrace_string();
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v22 = type;
      BOOL v23 = os_log_type_enabled(v14, type);
      if (v21)
      {
        if (v23)
        {
          *(_DWORD *)int buf = 136446466;
          __int16 v35 = "nw_http_client_metadata_set_client_error";
          __int16 v36 = 2082;
          uint64_t v37 = v21;
          _os_log_impl(&dword_1830D4000, v14, v22, "%{public}s metadata must be http_client, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v21);
LABEL_62:
        if (!v13) {
          goto LABEL_9;
        }
LABEL_63:
        free(v13);
        goto LABEL_9;
      }
      if (v23)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v35 = "nw_http_client_metadata_set_client_error";
        _os_log_impl(&dword_1830D4000, v14, v22, "%{public}s metadata must be http_client, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v35 = "nw_http_client_metadata_set_client_error";
        _os_log_impl(&dword_1830D4000, v14, v28, "%{public}s metadata must be http_client, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_61:

    goto LABEL_62;
  }
  v30[0] = MEMORY[0x1E4F143A8];
  v30[1] = 3221225472;
  v30[2] = __nw_http_client_metadata_set_client_error_block_invoke;
  v30[3] = &__block_descriptor_36_e9_B16__0_v8l;
  int v31 = a2;
  if (v4)
  {
    uint64_t v7 = v4[4];
    if (v7) {
      __nw_http_client_metadata_set_client_error_block_invoke((uint64_t)v30, v7);
    }
    goto LABEL_9;
  }
  unint64_t v16 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  __int16 v35 = "nw_protocol_metadata_access_handle";
  os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v32 = 0;
  if (!__nwlog_fault(v13, &type, &v32)) {
    goto LABEL_62;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v14 = __nwlog_obj();
    os_log_type_t v17 = type;
    if (os_log_type_enabled(v14, type))
    {
      *(_DWORD *)int buf = 136446210;
      __int16 v35 = "nw_protocol_metadata_access_handle";
      _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null metadata", buf, 0xCu);
    }
    goto LABEL_61;
  }
  if (!v32)
  {
    os_log_type_t v14 = __nwlog_obj();
    os_log_type_t v29 = type;
    if (os_log_type_enabled(v14, type))
    {
      *(_DWORD *)int buf = 136446210;
      __int16 v35 = "nw_protocol_metadata_access_handle";
      _os_log_impl(&dword_1830D4000, v14, v29, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_61;
  }
  size_t v24 = (char *)__nw_create_backtrace_string();
  os_log_type_t v14 = __nwlog_obj();
  os_log_type_t v25 = type;
  BOOL v26 = os_log_type_enabled(v14, type);
  if (!v24)
  {
    if (v26)
    {
      *(_DWORD *)int buf = 136446210;
      __int16 v35 = "nw_protocol_metadata_access_handle";
      _os_log_impl(&dword_1830D4000, v14, v25, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
    }
    goto LABEL_61;
  }
  if (v26)
  {
    *(_DWORD *)int buf = 136446466;
    __int16 v35 = "nw_protocol_metadata_access_handle";
    __int16 v36 = 2082;
    uint64_t v37 = v24;
    _os_log_impl(&dword_1830D4000, v14, v25, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v24);
  if (v13) {
    goto LABEL_63;
  }
LABEL_9:
}

id nw_http_client_metadata_get_sec_metadata(void *a1)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = nw_protocol_metadata_copy_definition(v1);
    if (nw_protocol_copy_http_client_definition_onceToken != -1) {
      dispatch_once(&nw_protocol_copy_http_client_definition_onceToken, &__block_literal_global_72_75798);
    }
    BOOL is_equal = nw_protocol_definition_is_equal(v3, (nw_protocol_definition_t)nw_protocol_copy_http_client_definition_definition);

    if (is_equal)
    {
      *(void *)int buf = 0;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x3032000000;
      BOOL v26 = __Block_byref_object_copy__5_73857;
      os_log_type_t v27 = __Block_byref_object_dispose__6_73858;
      id v28 = 0;
      v22[0] = MEMORY[0x1E4F143A8];
      v22[1] = 3221225472;
      v22[2] = __nw_http_client_metadata_get_sec_metadata_block_invoke;
      v22[3] = &unk_1E5248E90;
      void v22[4] = buf;
      uint64_t isa = (uint64_t)v2[4].isa;
      if (isa)
      {
        __nw_http_client_metadata_get_sec_metadata_block_invoke((uint64_t)v22, isa);
        uint64_t v6 = *(void **)(*(void *)&buf[8] + 40);
      }
      else
      {
        uint64_t v6 = 0;
      }
      id v7 = v6;
      _Block_object_dispose(buf, 8);

      goto LABEL_9;
    }
    os_log_type_t v13 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_client_metadata_get_sec_metadata";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v10, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_client_metadata_get_sec_metadata";
          _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s metadata must be http_client", buf, 0xCu);
        }
LABEL_41:

        goto LABEL_42;
      }
      if (!v23)
      {
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_client_metadata_get_sec_metadata";
          _os_log_impl(&dword_1830D4000, v11, v21, "%{public}s metadata must be http_client, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_41;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_client_metadata_get_sec_metadata";
          _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s metadata must be http_client, no backtrace", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (v19)
      {
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_client_metadata_get_sec_metadata";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s metadata must be http_client, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_29;
    }
  }
  else
  {
    uint64_t v9 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_client_metadata_get_sec_metadata";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v10, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_client_metadata_get_sec_metadata";
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null metadata", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (!v23)
      {
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_client_metadata_get_sec_metadata";
          _os_log_impl(&dword_1830D4000, v11, v20, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_41;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_client_metadata_get_sec_metadata";
          _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (v17)
      {
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_client_metadata_get_sec_metadata";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_29:

      free(backtrace_string);
    }
  }
LABEL_42:
  if (v10) {
    free(v10);
  }
  id v7 = 0;
LABEL_9:

  return v7;
}

void nw_http_client_metadata_enumerate_transactions(void *a1, void *a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (!v3)
  {
    os_log_type_t v10 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v29 = "nw_http_client_metadata_enumerate_transactions";
    os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v11, &type, &v26)) {
      goto LABEL_42;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v29 = "nw_http_client_metadata_enumerate_transactions";
        _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v29 = "nw_http_client_metadata_enumerate_transactions";
          __int16 v30 = 2082;
          int v31 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_42:
        if (!v11) {
          goto LABEL_8;
        }
LABEL_43:
        free(v11);
        goto LABEL_8;
      }
      if (v18)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v29 = "nw_http_client_metadata_enumerate_transactions";
        _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v29 = "nw_http_client_metadata_enumerate_transactions";
        _os_log_impl(&dword_1830D4000, v12, v22, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_41:

    goto LABEL_42;
  }
  id v5 = v3;
  id v6 = *((id *)v5 + 1);

  if (nw_protocol_copy_http_client_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_client_definition_onceToken, &__block_literal_global_72_75798);
  }
  BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v6, nw_protocol_copy_http_client_definition_definition);

  if (is_equal_unsafe)
  {
    v24[0] = MEMORY[0x1E4F143A8];
    v24[1] = 3221225472;
    v24[2] = __nw_http_client_metadata_enumerate_transactions_block_invoke;
    v24[3] = &unk_1E5248ED8;
    id v8 = v4;
    id v25 = v8;
    uint64_t v9 = *((void *)v5 + 4);
    if (v9)
    {
      __nw_http_client_metadata_enumerate_transactions_block_invoke((uint64_t)v24, v9);
      id v8 = v25;
    }

    goto LABEL_8;
  }
  os_log_type_t v14 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  uint64_t v29 = "nw_http_client_metadata_enumerate_transactions";
  os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v26 = 0;
  if (!__nwlog_fault(v11, &type, &v26)) {
    goto LABEL_42;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v12 = __nwlog_obj();
    os_log_type_t v15 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)int buf = 136446210;
      uint64_t v29 = "nw_http_client_metadata_enumerate_transactions";
      _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s metadata must be http_client", buf, 0xCu);
    }
    goto LABEL_41;
  }
  if (!v26)
  {
    os_log_type_t v12 = __nwlog_obj();
    os_log_type_t v23 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)int buf = 136446210;
      uint64_t v29 = "nw_http_client_metadata_enumerate_transactions";
      _os_log_impl(&dword_1830D4000, v12, v23, "%{public}s metadata must be http_client, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_41;
  }
  BOOL v19 = (char *)__nw_create_backtrace_string();
  os_log_type_t v12 = __nwlog_obj();
  os_log_type_t v20 = type;
  BOOL v21 = os_log_type_enabled(v12, type);
  if (!v19)
  {
    if (v21)
    {
      *(_DWORD *)int buf = 136446210;
      uint64_t v29 = "nw_http_client_metadata_enumerate_transactions";
      _os_log_impl(&dword_1830D4000, v12, v20, "%{public}s metadata must be http_client, no backtrace", buf, 0xCu);
    }
    goto LABEL_41;
  }
  if (v21)
  {
    *(_DWORD *)int buf = 136446466;
    uint64_t v29 = "nw_http_client_metadata_enumerate_transactions";
    __int16 v30 = 2082;
    int v31 = v19;
    _os_log_impl(&dword_1830D4000, v12, v20, "%{public}s metadata must be http_client, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v19);
  if (v11) {
    goto LABEL_43;
  }
LABEL_8:
}

char *nw_http_access_body_chunk_from_indeterminate_binary_message(_DWORD *a1, unint64_t a2, int a3, unint64_t *a4, unsigned char *a5, char **a6, unint64_t *a7)
{
  uint64_t v79 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
    BOOL v60 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v73 = 0;
    if (!__nwlog_fault(v60, &type, &v73)) {
      goto LABEL_218;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v61 = __nwlog_obj();
      os_log_type_t v62 = type;
      if (!os_log_type_enabled(v61, type)) {
        goto LABEL_218;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      os_log_type_t v63 = "%{public}s called with null buffer";
      goto LABEL_217;
    }
    if (!v73)
    {
      BOOL v61 = __nwlog_obj();
      os_log_type_t v62 = type;
      if (!os_log_type_enabled(v61, type)) {
        goto LABEL_218;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      os_log_type_t v63 = "%{public}s called with null buffer, backtrace limit exceeded";
      goto LABEL_217;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v61 = __nwlog_obj();
    os_log_type_t v62 = type;
    BOOL v65 = os_log_type_enabled(v61, type);
    if (!backtrace_string)
    {
      if (!v65) {
        goto LABEL_218;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      os_log_type_t v63 = "%{public}s called with null buffer, no backtrace";
      goto LABEL_217;
    }
    if (!v65) {
      goto LABEL_188;
    }
    *(_DWORD *)int buf = 136446466;
    os_log_type_t v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
    __int16 v77 = 2082;
    unint64_t v78 = (unint64_t)backtrace_string;
    BOOL v66 = "%{public}s called with null buffer, dumping backtrace:%{public}s";
LABEL_187:
    _os_log_impl(&dword_1830D4000, v61, v62, v66, buf, 0x16u);
    goto LABEL_188;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
    BOOL v60 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v73 = 0;
    if (!__nwlog_fault(v60, &type, &v73)) {
      goto LABEL_218;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v61 = __nwlog_obj();
      os_log_type_t v62 = type;
      if (!os_log_type_enabled(v61, type)) {
        goto LABEL_218;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      os_log_type_t v63 = "%{public}s called with null buffer_length";
      goto LABEL_217;
    }
    if (!v73)
    {
      BOOL v61 = __nwlog_obj();
      os_log_type_t v62 = type;
      if (!os_log_type_enabled(v61, type)) {
        goto LABEL_218;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      os_log_type_t v63 = "%{public}s called with null buffer_length, backtrace limit exceeded";
      goto LABEL_217;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v61 = __nwlog_obj();
    os_log_type_t v62 = type;
    BOOL v67 = os_log_type_enabled(v61, type);
    if (!backtrace_string)
    {
      if (!v67) {
        goto LABEL_218;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      os_log_type_t v63 = "%{public}s called with null buffer_length, no backtrace";
      goto LABEL_217;
    }
    if (!v67) {
      goto LABEL_188;
    }
    *(_DWORD *)int buf = 136446466;
    os_log_type_t v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
    __int16 v77 = 2082;
    unint64_t v78 = (unint64_t)backtrace_string;
    BOOL v66 = "%{public}s called with null buffer_length, dumping backtrace:%{public}s";
    goto LABEL_187;
  }
  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
    BOOL v60 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v73 = 0;
    if (!__nwlog_fault(v60, &type, &v73)) {
      goto LABEL_218;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v61 = __nwlog_obj();
      os_log_type_t v62 = type;
      if (!os_log_type_enabled(v61, type)) {
        goto LABEL_218;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      os_log_type_t v63 = "%{public}s called with null out_chunk_length";
      goto LABEL_217;
    }
    if (!v73)
    {
      BOOL v61 = __nwlog_obj();
      os_log_type_t v62 = type;
      if (!os_log_type_enabled(v61, type)) {
        goto LABEL_218;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      os_log_type_t v63 = "%{public}s called with null out_chunk_length, backtrace limit exceeded";
      goto LABEL_217;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v61 = __nwlog_obj();
    os_log_type_t v62 = type;
    BOOL v68 = os_log_type_enabled(v61, type);
    if (!backtrace_string)
    {
      if (!v68) {
        goto LABEL_218;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      os_log_type_t v63 = "%{public}s called with null out_chunk_length, no backtrace";
      goto LABEL_217;
    }
    if (!v68) {
      goto LABEL_188;
    }
    *(_DWORD *)int buf = 136446466;
    os_log_type_t v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
    __int16 v77 = 2082;
    unint64_t v78 = (unint64_t)backtrace_string;
    BOOL v66 = "%{public}s called with null out_chunk_length, dumping backtrace:%{public}s";
    goto LABEL_187;
  }
  if (!a5)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
    BOOL v60 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v73 = 0;
    if (!__nwlog_fault(v60, &type, &v73)) {
      goto LABEL_218;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v61 = __nwlog_obj();
      os_log_type_t v62 = type;
      if (!os_log_type_enabled(v61, type)) {
        goto LABEL_218;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      os_log_type_t v63 = "%{public}s called with null out_is_complete";
      goto LABEL_217;
    }
    if (!v73)
    {
      BOOL v61 = __nwlog_obj();
      os_log_type_t v62 = type;
      if (!os_log_type_enabled(v61, type)) {
        goto LABEL_218;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      os_log_type_t v63 = "%{public}s called with null out_is_complete, backtrace limit exceeded";
      goto LABEL_217;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v61 = __nwlog_obj();
    os_log_type_t v62 = type;
    BOOL v69 = os_log_type_enabled(v61, type);
    if (!backtrace_string)
    {
      if (!v69) {
        goto LABEL_218;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      os_log_type_t v63 = "%{public}s called with null out_is_complete, no backtrace";
      goto LABEL_217;
    }
    if (!v69) {
      goto LABEL_188;
    }
    *(_DWORD *)int buf = 136446466;
    os_log_type_t v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
    __int16 v77 = 2082;
    unint64_t v78 = (unint64_t)backtrace_string;
    BOOL v66 = "%{public}s called with null out_is_complete, dumping backtrace:%{public}s";
    goto LABEL_187;
  }
  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
    BOOL v60 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v73 = 0;
    if (!__nwlog_fault(v60, &type, &v73)) {
      goto LABEL_218;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v61 = __nwlog_obj();
      os_log_type_t v62 = type;
      if (!os_log_type_enabled(v61, type)) {
        goto LABEL_218;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      os_log_type_t v63 = "%{public}s called with null out_next_chunk";
      goto LABEL_217;
    }
    if (!v73)
    {
      BOOL v61 = __nwlog_obj();
      os_log_type_t v62 = type;
      if (!os_log_type_enabled(v61, type)) {
        goto LABEL_218;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      os_log_type_t v63 = "%{public}s called with null out_next_chunk, backtrace limit exceeded";
      goto LABEL_217;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v61 = __nwlog_obj();
    os_log_type_t v62 = type;
    BOOL v70 = os_log_type_enabled(v61, type);
    if (!backtrace_string)
    {
      if (!v70) {
        goto LABEL_218;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      os_log_type_t v63 = "%{public}s called with null out_next_chunk, no backtrace";
      goto LABEL_217;
    }
    if (!v70) {
      goto LABEL_188;
    }
    *(_DWORD *)int buf = 136446466;
    os_log_type_t v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
    __int16 v77 = 2082;
    unint64_t v78 = (unint64_t)backtrace_string;
    BOOL v66 = "%{public}s called with null out_next_chunk, dumping backtrace:%{public}s";
    goto LABEL_187;
  }
  if (!a7)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
    BOOL v60 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v73 = 0;
    if (!__nwlog_fault(v60, &type, &v73)) {
      goto LABEL_218;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v61 = __nwlog_obj();
      os_log_type_t v62 = type;
      if (!os_log_type_enabled(v61, type)) {
        goto LABEL_218;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      os_log_type_t v63 = "%{public}s called with null out_remaining_length";
      goto LABEL_217;
    }
    if (!v73)
    {
      BOOL v61 = __nwlog_obj();
      os_log_type_t v62 = type;
      if (!os_log_type_enabled(v61, type)) {
        goto LABEL_218;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      os_log_type_t v63 = "%{public}s called with null out_remaining_length, backtrace limit exceeded";
      goto LABEL_217;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v61 = __nwlog_obj();
    os_log_type_t v62 = type;
    BOOL v71 = os_log_type_enabled(v61, type);
    if (backtrace_string)
    {
      if (v71)
      {
        *(_DWORD *)int buf = 136446466;
        os_log_type_t v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
        __int16 v77 = 2082;
        unint64_t v78 = (unint64_t)backtrace_string;
        BOOL v66 = "%{public}s called with null out_remaining_length, dumping backtrace:%{public}s";
        goto LABEL_187;
      }
LABEL_188:
      free(backtrace_string);
      goto LABEL_218;
    }
    if (!v71) {
      goto LABEL_218;
    }
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
    os_log_type_t v63 = "%{public}s called with null out_remaining_length, no backtrace";
LABEL_217:
    _os_log_impl(&dword_1830D4000, v61, v62, v63, buf, 0xCu);
LABEL_218:
    if (v60) {
      free(v60);
    }
    return 0;
  }
  *a4 = 0;
  *a5 = 0;
  *a6 = 0;
  *a7 = a2;
  if (!a3) {
    goto LABEL_110;
  }
  unint64_t v7 = *(unsigned __int8 *)a1;
  if (v7 > 0x3F)
  {
    unsigned int v14 = v7 >> 6;
    if (v14 == 2)
    {
      if (a2 < 4) {
        return 0;
      }
      unint64_t v7 = bswap32(*a1 & 0xFFFFFF7F);
      uint64_t v8 = 4;
    }
    else if (v14 == 1)
    {
      if (a2 < 2) {
        return 0;
      }
      unint64_t v7 = bswap32(*(_WORD *)a1 & 0xFFBF) >> 16;
      uint64_t v8 = 2;
    }
    else
    {
      if (a2 < 8) {
        return 0;
      }
      unint64_t v7 = bswap64(*(void *)a1 & 0xFFFFFFFFFFFFFF3FLL);
      uint64_t v8 = 8;
    }
  }
  else
  {
    uint64_t v8 = 1;
  }
  if (v7 > 3) {
    return 0;
  }
  if ((v7 & 0x3FFFFFFFFFFFFFFELL) != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v15 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
    os_log_type_t v16 = "%{public}s Message is not indeterminate";
    os_log_type_t v17 = v15;
    uint32_t v18 = 12;
    goto LABEL_22;
  }
  uint64_t v9 = (_DWORD *)((char *)a1 + v8);
  unint64_t v10 = a2 - v8;
  if ((v7 & 0xFFFFFFFFFFFFFFFDLL) != 0)
  {
    if (a2 == v8) {
      return 0;
    }
    unint64_t v11 = *(unsigned __int8 *)v9;
    if (v11 <= 0x3F)
    {
      os_log_type_t v12 = (_DWORD *)((char *)v9 + 1);
      unint64_t v13 = v10 - 1;
      goto LABEL_65;
    }
    if (v11 >> 6 == 2)
    {
      if (v10 < 4) {
        return 0;
      }
      unint64_t v11 = bswap32(*v9 & 0xFFFFFF7F);
      uint64_t v39 = 4;
    }
    else if (v11 >> 6 == 1)
    {
      if (v10 < 2) {
        return 0;
      }
      unint64_t v11 = bswap32(*(_WORD *)v9 & 0xFFBF) >> 16;
      uint64_t v39 = 2;
    }
    else
    {
      if (v10 < 8) {
        return 0;
      }
      unint64_t v11 = bswap64(*(void *)v9 & 0xFFFFFFFFFFFFFF3FLL);
      uint64_t v39 = 8;
    }
    if (v11 <= 0x3E8)
    {
      os_log_type_t v12 = (_DWORD *)((char *)v9 + v39);
      unint64_t v13 = v10 - v39;
LABEL_65:
      if (v11 - 601 <= 0xFFFFFFFFFFFFFE6ELL)
      {
        __int16 v40 = __nwlog_obj();
        if (!os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
          return 0;
        }
        *(_DWORD *)int buf = 136446466;
        os_log_type_t v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
        __int16 v77 = 2048;
        unint64_t v78 = v11;
        os_log_type_t v16 = "%{public}s Informational statuses not supported: %llu";
        os_log_type_t v17 = v40;
        uint32_t v18 = 22;
LABEL_22:
        _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_ERROR, v16, buf, v18);
        return 0;
      }
      goto LABEL_68;
    }
    return 0;
  }
  if (a2 == v8) {
    return 0;
  }
  unint64_t v19 = *(unsigned __int8 *)v9;
  if (v19 > 0x3F)
  {
    if (v19 >> 6 == 2)
    {
      if (v10 < 4) {
        return 0;
      }
      unint64_t v19 = bswap32(*v9 & 0xFFFFFF7F);
      uint64_t v20 = 4;
    }
    else if (v19 >> 6 == 1)
    {
      if (v10 < 2) {
        return 0;
      }
      unint64_t v19 = bswap32(*(_WORD *)v9 & 0xFFBF) >> 16;
      uint64_t v20 = 2;
    }
    else
    {
      if (v10 < 8) {
        return 0;
      }
      unint64_t v19 = bswap64(*(void *)v9 & 0xFFFFFFFFFFFFFF3FLL);
      uint64_t v20 = 8;
    }
  }
  else
  {
    uint64_t v20 = 1;
  }
  BOOL v21 = 0;
  if (v19 >> 16) {
    return v21;
  }
  unint64_t v22 = v10 - v20;
  if (v22 < v19) {
    return v21;
  }
  unint64_t v23 = v22 - v19;
  if (!v23) {
    return 0;
  }
  size_t v24 = (_DWORD *)((char *)v9 + v20 + v19);
  unint64_t v25 = *(unsigned __int8 *)v24;
  if (v25 > 0x3F)
  {
    if (v25 >> 6 == 2)
    {
      if (v23 < 4) {
        return 0;
      }
      unint64_t v25 = bswap32(*v24 & 0xFFFFFF7F);
      uint64_t v26 = 4;
    }
    else if (v25 >> 6 == 1)
    {
      if (v23 < 2) {
        return 0;
      }
      unint64_t v25 = bswap32(*(_WORD *)v24 & 0xFFBF) >> 16;
      uint64_t v26 = 2;
    }
    else
    {
      if (v23 < 8) {
        return 0;
      }
      unint64_t v25 = bswap64(*(void *)v24 & 0xFFFFFFFFFFFFFF3FLL);
      uint64_t v26 = 8;
    }
  }
  else
  {
    uint64_t v26 = 1;
  }
  BOOL v21 = 0;
  if (v25 >> 16) {
    return v21;
  }
  unint64_t v27 = v23 - v26;
  if (v27 < v25) {
    return v21;
  }
  unint64_t v28 = v27 - v25;
  if (!v28) {
    return 0;
  }
  uint64_t v29 = (_DWORD *)((char *)v24 + v26 + v25);
  unint64_t v30 = *(unsigned __int8 *)v29;
  if (v30 > 0x3F)
  {
    if (v30 >> 6 == 2)
    {
      if (v28 < 4) {
        return 0;
      }
      unint64_t v30 = bswap32(*v29 & 0xFFFFFF7F);
      uint64_t v31 = 4;
    }
    else if (v30 >> 6 == 1)
    {
      if (v28 < 2) {
        return 0;
      }
      unint64_t v30 = bswap32(*(_WORD *)v29 & 0xFFBF) >> 16;
      uint64_t v31 = 2;
    }
    else
    {
      if (v28 < 8) {
        return 0;
      }
      unint64_t v30 = bswap64(*(void *)v29 & 0xFFFFFFFFFFFFFF3FLL);
      uint64_t v31 = 8;
    }
  }
  else
  {
    uint64_t v31 = 1;
  }
  BOOL v21 = 0;
  if (v30 >> 16) {
    return v21;
  }
  unint64_t v32 = v28 - v31;
  if (v32 < v30) {
    return v21;
  }
  unint64_t v33 = v32 - v30;
  if (!v33) {
    return 0;
  }
  BOOL v34 = (_DWORD *)((char *)v29 + v31 + v30);
  unint64_t v35 = *(unsigned __int8 *)v34;
  if (v35 > 0x3F)
  {
    unsigned int v72 = v35 >> 6;
    if (v72 == 2)
    {
      if (v33 < 4) {
        return 0;
      }
      unint64_t v35 = bswap32(*v34 & 0xFFFFFF7F);
      uint64_t v36 = 4;
    }
    else if (v72 == 1)
    {
      if (v33 < 2) {
        return 0;
      }
      unint64_t v35 = bswap32(*(_WORD *)v34 & 0xFFBF) >> 16;
      uint64_t v36 = 2;
    }
    else
    {
      if (v33 < 8) {
        return 0;
      }
      unint64_t v35 = bswap64(*(void *)v34 & 0xFFFFFFFFFFFFFF3FLL);
      uint64_t v36 = 8;
    }
  }
  else
  {
    uint64_t v36 = 1;
  }
  unint64_t v37 = v33 - v36;
  if (v35 >> 16) {
    BOOL v38 = 0;
  }
  else {
    BOOL v38 = v37 >= v35;
  }
  if (!v38) {
    return 0;
  }
  os_log_type_t v12 = (_DWORD *)((char *)v34 + v36 + v35);
  unint64_t v13 = v37 - v35;
LABEL_68:
  if (!v13) {
    return 0;
  }
  while (1)
  {
    unint64_t v45 = *(unsigned __int8 *)v12;
    if (v45 <= 0x3F)
    {
      uint64_t v46 = 1;
      goto LABEL_86;
    }
    unsigned int v47 = v45 >> 6;
    if (v47 != 2) {
      break;
    }
    if (v13 < 4) {
      return 0;
    }
    unint64_t v45 = bswap32(*v12 & 0xFFFFFF7F);
    uint64_t v46 = 4;
LABEL_86:
    a1 = (_DWORD *)((char *)v12 + v46);
    a2 = v13 - v46;
    if (!v45) {
      goto LABEL_109;
    }
LABEL_87:
    unint64_t v48 = a2 - v45;
    if (a2 <= v45) {
      return 0;
    }
    os_log_type_t v49 = (_DWORD *)((char *)a1 + v45);
    unint64_t v50 = *((unsigned __int8 *)a1 + v45);
    if (v50 <= 0x3F)
    {
      uint64_t v41 = 1;
    }
    else if (v50 >> 6 == 2)
    {
      if (v48 < 4) {
        return 0;
      }
      unint64_t v50 = bswap32(*v49 & 0xFFFFFF7F);
      uint64_t v41 = 4;
    }
    else if (v50 >> 6 == 1)
    {
      if (v48 < 2) {
        return 0;
      }
      unint64_t v50 = bswap32(*(_WORD *)v49 & 0xFFBF) >> 16;
      uint64_t v41 = 2;
    }
    else
    {
      if (v48 < 8) {
        return 0;
      }
      unint64_t v50 = bswap64(*(void *)v49 & 0xFFFFFFFFFFFFFF3FLL);
      uint64_t v41 = 8;
    }
    BOOL v21 = 0;
    unint64_t v42 = v48 - v41;
    os_log_type_t v12 = (_DWORD *)((char *)v49 + v41 + v50);
    unint64_t v13 = v48 - v41 - v50;
    if (HIDWORD(v50)) {
      BOOL v43 = 0;
    }
    else {
      BOOL v43 = v42 >= v50;
    }
    if (!v43 || v13 == 0) {
      return v21;
    }
  }
  if (v47 == 1)
  {
    if (v13 < 2) {
      return 0;
    }
    unint64_t v45 = bswap32(*(_WORD *)v12 & 0xFFBF) >> 16;
    uint64_t v46 = 2;
    goto LABEL_86;
  }
  if (v13 < 8) {
    return 0;
  }
  uint64_t v51 = *(void *)v12;
  a1 = v12 + 2;
  unint64_t v45 = bswap64(v51 & 0xFFFFFFFFFFFFFF3FLL);
  if (HIDWORD(v45)) {
    return 0;
  }
  a2 = v13 - 8;
  if (v45) {
    goto LABEL_87;
  }
LABEL_109:
  if (!a2) {
    return 0;
  }
LABEL_110:
  unint64_t v52 = *(unsigned __int8 *)a1;
  if (v52 <= 0x3F)
  {
    uint64_t v53 = 1;
    goto LABEL_112;
  }
  if (v52 >> 6 == 2)
  {
    if (a2 < 4) {
      return 0;
    }
    unint64_t v52 = bswap32(*a1 & 0xFFFFFF7F);
    uint64_t v53 = 4;
LABEL_112:
    BOOL v21 = (char *)a1 + v53;
    unint64_t v54 = a2 - v53;
    if (!v52) {
      goto LABEL_126;
    }
  }
  else
  {
    if (v52 >> 6 == 1)
    {
      if (a2 >= 2)
      {
        unint64_t v52 = bswap32(*(_WORD *)a1 & 0xFFBF) >> 16;
        uint64_t v53 = 2;
        goto LABEL_112;
      }
      return 0;
    }
    if (a2 < 8) {
      return 0;
    }
    uint64_t v58 = *(void *)a1;
    BOOL v57 = (char *)(a1 + 2);
    unint64_t v52 = bswap64(v58 & 0xFFFFFFFFFFFFFF3FLL);
    if (HIDWORD(v52)) {
      return 0;
    }
    uint64_t v53 = 8;
    BOOL v21 = v57;
    unint64_t v54 = a2 - 8;
    if (!v52)
    {
LABEL_126:
      *a5 = 1;
      *a7 = v54;
      if (a2 == v53) {
        BOOL v21 = 0;
      }
      *a6 = v21;
      return 0;
    }
  }
  BOOL v55 = v54 == v52;
  if (v54 < v52) {
    return 0;
  }
  *a4 = v52;
  *a7 = v54 - v52;
  BOOL v56 = &v21[v52];
  if (v55) {
    BOOL v56 = 0;
  }
  *a6 = v56;
  return v21;
}

void nw_ethernet_channel_send(nw_ethernet_channel_t ethernet_channel, dispatch_data_t content, uint16_t vlan_tag, unsigned __int8 *remote_address, nw_ethernet_channel_send_completion_t completion)
{
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  nw_ethernet_channel_t v7 = ethernet_channel;
  uint64_t v8 = content;
  uint64_t v9 = completion;
  if (!v7)
  {
    uint64_t v15 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_ethernet_channel_send";
    os_log_type_t v16 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v69[0] = 0;
    if (!__nwlog_fault(v16, type, v69)) {
      goto LABEL_52;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v17 = __nwlog_obj();
      os_log_type_t v18 = type[0];
      if (os_log_type_enabled(v17, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ethernet_channel_send";
        _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s called with null ethernet_channel", buf, 0xCu);
      }
    }
    else if (v69[0])
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v17 = __nwlog_obj();
      os_log_type_t v22 = type[0];
      BOOL v23 = os_log_type_enabled(v17, type[0]);
      if (backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ethernet_channel_send";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v17, v22, "%{public}s called with null ethernet_channel, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_52:
        if (!v16) {
          goto LABEL_11;
        }
LABEL_53:
        free(v16);
        goto LABEL_11;
      }
      if (v23)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ethernet_channel_send";
        _os_log_impl(&dword_1830D4000, v17, v22, "%{public}s called with null ethernet_channel, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v17 = __nwlog_obj();
      os_log_type_t v30 = type[0];
      if (os_log_type_enabled(v17, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ethernet_channel_send";
        _os_log_impl(&dword_1830D4000, v17, v30, "%{public}s called with null ethernet_channel, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_51:

    goto LABEL_52;
  }
  if (v8)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&v7[1]);
    if (BYTE1(v7[14].isa))
    {
      unint64_t v10 = -[NWConcrete_nw_error initWithDomain:code:]([NWConcrete_nw_error alloc], 1, 57);
LABEL_8:
      os_unfair_lock_unlock((os_unfair_lock_t)&v7[1]);
      if (v9) {
        v9[2](v9, v10);
      }

      goto LABEL_11;
    }
    unint64_t v11 = v7;
    os_log_type_t v12 = v8;
    unint64_t v13 = v12;
    if (!v11[19].isa)
    {
      posix_error = -[NWConcrete_nw_error initWithDomain:code:]([NWConcrete_nw_error alloc], 1, 53);
LABEL_7:
      unint64_t v10 = posix_error;

      goto LABEL_8;
    }
    if (dispatch_data_get_size(v12) - 4294967278u < 0xFFFFFFFF00000013)
    {
      unint64_t v27 = __nwlog_obj();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        Class isa = v11[3].isa;
        int v29 = (int)v11[21].isa;
        *(_DWORD *)int buf = 136447490;
        *(void *)&uint8_t buf[4] = "send_data_on_ring_locked";
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = isa;
        __int16 v71 = 1042;
        *(_DWORD *)unsigned int v72 = 16;
        *(_WORD *)&v72[4] = 2098;
        *(void *)&v72[6] = (char *)v11 + 115;
        __int16 v73 = 1024;
        int v74 = v29;
        __int16 v75 = 2112;
        os_log_type_t v76 = @"Bad TX data size";
        _os_log_impl(&dword_1830D4000, v27, OS_LOG_TYPE_ERROR, "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>]  %@", buf, 0x36u);
      }

      if (!v11[19].isa) {
        goto LABEL_39;
      }
      goto LABEL_37;
    }
    if (!v11[23].isa)
    {
      unint64_t v32 = __nwlog_obj();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        Class v33 = v11[3].isa;
        int v34 = (int)v11[21].isa;
        *(_DWORD *)int buf = 136447490;
        *(void *)&uint8_t buf[4] = "send_data_on_ring_locked";
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v33;
        __int16 v71 = 1042;
        *(_DWORD *)unsigned int v72 = 16;
        *(_WORD *)&v72[4] = 2098;
        *(void *)&v72[6] = (char *)v11 + 115;
        __int16 v73 = 1024;
        int v74 = v34;
        __int16 v75 = 2112;
        os_log_type_t v76 = @"No rx_ring";
        _os_log_impl(&dword_1830D4000, v32, OS_LOG_TYPE_ERROR, "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>]  %@", buf, 0x36u);
      }

      if (!v11[19].isa) {
        goto LABEL_39;
      }
LABEL_37:
      if (os_channel_is_defunct()) {
        -[NWConcrete_nw_ethernet_channel closeChannel:]((uint64_t)v11, 0);
      }
      goto LABEL_39;
    }
    if (os_channel_available_slot_count())
    {
LABEL_60:
      uint64_t v68 = 0;
      if (os_channel_packet_alloc())
      {
        Class v35 = v11[19].isa;
        uint64_t v36 = __nwlog_obj();
        BOOL v37 = os_log_type_enabled(v36, OS_LOG_TYPE_ERROR);
        if (v35)
        {
          if (!v37) {
            goto LABEL_71;
          }
          Class v38 = v11[3].isa;
          int v39 = (int)v11[21].isa;
          *(_DWORD *)int buf = 136447490;
          *(void *)&uint8_t buf[4] = "send_data_on_ring_locked";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v38;
          __int16 v71 = 1042;
          *(_DWORD *)unsigned int v72 = 16;
          *(_WORD *)&v72[4] = 2098;
          *(void *)&v72[6] = (char *)v11 + 115;
          __int16 v73 = 1024;
          int v74 = v39;
          __int16 v75 = 2112;
          os_log_type_t v76 = @"Failed to alloc TX packet";
          __int16 v40 = "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>]  %@";
          uint64_t v41 = v36;
          uint32_t v42 = 54;
        }
        else
        {
          if (!v37) {
            goto LABEL_71;
          }
          *(_DWORD *)int buf = 136446722;
          *(void *)&uint8_t buf[4] = "send_data_on_ring_locked";
          *(_WORD *)&unsigned char buf[12] = 2114;
          *(void *)&buf[14] = v11;
          __int16 v71 = 2112;
          *(void *)unsigned int v72 = @"Failed to alloc TX packet";
          __int16 v40 = "%{public}s [%{public}@]  %@";
          uint64_t v41 = v36;
          uint32_t v42 = 32;
        }
        _os_log_impl(&dword_1830D4000, v41, OS_LOG_TYPE_ERROR, v40, buf, v42);
LABEL_71:

        if (v11[19].isa) {
          goto LABEL_72;
        }
        goto LABEL_74;
      }
      Class v51 = v11[19].isa;
      unint64_t v52 = __nwlog_obj();
      BOOL v53 = os_log_type_enabled(v52, OS_LOG_TYPE_ERROR);
      if (v51)
      {
        if (!v53) {
          goto LABEL_92;
        }
        Class v54 = v11[3].isa;
        int v55 = (int)v11[21].isa;
        *(_DWORD *)int buf = 136447490;
        *(void *)&uint8_t buf[4] = "send_data_on_ring_locked";
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v54;
        __int16 v71 = 1042;
        *(_DWORD *)unsigned int v72 = 16;
        *(_WORD *)&v72[4] = 2098;
        *(void *)&v72[6] = (char *)v11 + 115;
        __int16 v73 = 1024;
        int v74 = v55;
        __int16 v75 = 2112;
        os_log_type_t v76 = @"no TX packet";
        BOOL v56 = "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>]  %@";
        BOOL v57 = v52;
        uint32_t v58 = 54;
      }
      else
      {
        if (!v53) {
          goto LABEL_92;
        }
        *(_DWORD *)int buf = 136446722;
        *(void *)&uint8_t buf[4] = "send_data_on_ring_locked";
        *(_WORD *)&unsigned char buf[12] = 2114;
        *(void *)&buf[14] = v11;
        __int16 v71 = 2112;
        *(void *)unsigned int v72 = @"no TX packet";
        BOOL v56 = "%{public}s [%{public}@]  %@";
        BOOL v57 = v52;
        uint32_t v58 = 32;
      }
      _os_log_impl(&dword_1830D4000, v57, OS_LOG_TYPE_ERROR, v56, buf, v58);
LABEL_92:

      if (v11[19].isa)
      {
LABEL_72:
        if (os_channel_is_defunct()) {
          -[NWConcrete_nw_ethernet_channel closeChannel:]((uint64_t)v11, 0);
        }
      }
LABEL_74:
      posix_error = nw_error_create_posix_error(55);
      goto LABEL_7;
    }
    if (os_channel_sync())
    {
      Class v43 = v11[19].isa;
      nw_protocol_metadata_t v44 = __nwlog_obj();
      BOOL v45 = os_log_type_enabled(v44, OS_LOG_TYPE_ERROR);
      if (v43)
      {
        if (!v45) {
          goto LABEL_78;
        }
        Class v46 = v11[3].isa;
        int v47 = (int)v11[21].isa;
        *(_DWORD *)int buf = 136447490;
        *(void *)&uint8_t buf[4] = "send_data_on_ring_locked";
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v46;
        __int16 v71 = 1042;
        *(_DWORD *)unsigned int v72 = 16;
        *(_WORD *)&v72[4] = 2098;
        *(void *)&v72[6] = (char *)v11 + 115;
        __int16 v73 = 1024;
        int v74 = v47;
        __int16 v75 = 2112;
        os_log_type_t v76 = @"Failed to sync TX";
        unint64_t v48 = "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>]  %@";
        os_log_type_t v49 = v44;
        uint32_t v50 = 54;
      }
      else
      {
        if (!v45) {
          goto LABEL_78;
        }
        *(_DWORD *)int buf = 136446722;
        *(void *)&uint8_t buf[4] = "send_data_on_ring_locked";
        *(_WORD *)&unsigned char buf[12] = 2114;
        *(void *)&buf[14] = v11;
        __int16 v71 = 2112;
        *(void *)unsigned int v72 = @"Failed to sync TX";
        unint64_t v48 = "%{public}s [%{public}@]  %@";
        os_log_type_t v49 = v44;
        uint32_t v50 = 32;
      }
      _os_log_impl(&dword_1830D4000, v49, OS_LOG_TYPE_ERROR, v48, buf, v50);
LABEL_78:

      if (v11[19].isa) {
        goto LABEL_79;
      }
      goto LABEL_39;
    }
    if (!os_channel_available_slot_count()) {
      goto LABEL_60;
    }
    Class v59 = v11[19].isa;
    BOOL v60 = __nwlog_obj();
    BOOL v61 = os_log_type_enabled(v60, OS_LOG_TYPE_ERROR);
    if (v59)
    {
      if (!v61) {
        goto LABEL_97;
      }
      Class v62 = v11[3].isa;
      int v63 = (int)v11[21].isa;
      *(_DWORD *)int buf = 136447490;
      *(void *)&uint8_t buf[4] = "send_data_on_ring_locked";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v62;
      __int16 v71 = 1042;
      *(_DWORD *)unsigned int v72 = 16;
      *(_WORD *)&v72[4] = 2098;
      *(void *)&v72[6] = (char *)v11 + 115;
      __int16 v73 = 1024;
      int v74 = v63;
      __int16 v75 = 2112;
      os_log_type_t v76 = @"TX no available slot";
      os_log_type_t v64 = "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>]  %@";
      BOOL v65 = v60;
      uint32_t v66 = 54;
    }
    else
    {
      if (!v61) {
        goto LABEL_97;
      }
      *(_DWORD *)int buf = 136446722;
      *(void *)&uint8_t buf[4] = "send_data_on_ring_locked";
      *(_WORD *)&unsigned char buf[12] = 2114;
      *(void *)&buf[14] = v11;
      __int16 v71 = 2112;
      *(void *)unsigned int v72 = @"TX no available slot";
      os_log_type_t v64 = "%{public}s [%{public}@]  %@";
      BOOL v65 = v60;
      uint32_t v66 = 32;
    }
    _os_log_impl(&dword_1830D4000, v65, OS_LOG_TYPE_ERROR, v64, buf, v66);
LABEL_97:

    if (v11[19].isa)
    {
LABEL_79:
      if (os_channel_is_defunct()) {
        -[NWConcrete_nw_ethernet_channel closeChannel:]((uint64_t)v11, 0);
      }
    }
LABEL_39:
    posix_error = nw_error_create_posix_error(53);
    goto LABEL_7;
  }
  unint64_t v19 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ethernet_channel_send";
  os_log_type_t v16 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v69[0] = 0;
  if (!__nwlog_fault(v16, type, v69)) {
    goto LABEL_52;
  }
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v17 = __nwlog_obj();
    os_log_type_t v20 = type[0];
    if (os_log_type_enabled(v17, type[0]))
    {
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_ethernet_channel_send";
      _os_log_impl(&dword_1830D4000, v17, v20, "%{public}s called with null content", buf, 0xCu);
    }
    goto LABEL_51;
  }
  if (!v69[0])
  {
    os_log_type_t v17 = __nwlog_obj();
    os_log_type_t v31 = type[0];
    if (os_log_type_enabled(v17, type[0]))
    {
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_ethernet_channel_send";
      _os_log_impl(&dword_1830D4000, v17, v31, "%{public}s called with null content, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_51;
  }
  size_t v24 = (char *)__nw_create_backtrace_string();
  os_log_type_t v17 = __nwlog_obj();
  os_log_type_t v25 = type[0];
  BOOL v26 = os_log_type_enabled(v17, type[0]);
  if (!v24)
  {
    if (v26)
    {
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_ethernet_channel_send";
      _os_log_impl(&dword_1830D4000, v17, v25, "%{public}s called with null content, no backtrace", buf, 0xCu);
    }
    goto LABEL_51;
  }
  if (v26)
  {
    *(_DWORD *)int buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_ethernet_channel_send";
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = v24;
    _os_log_impl(&dword_1830D4000, v17, v25, "%{public}s called with null content, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v24);
  if (v16) {
    goto LABEL_53;
  }
LABEL_11:
}

void sub_183475F1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  _Block_object_dispose(&a28, 8);
  _Unwind_Resume(a1);
}

int nw_error_get_error_code(nw_error_t error)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_error_t v1 = error;
  nw_error_t v2 = v1;
  if (v1)
  {
    int isa_high = HIDWORD(v1[1].isa);
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v16 = "nw_error_get_error_code";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      nw_ethernet_channel_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_error_get_error_code";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null error", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      nw_ethernet_channel_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v16 = "nw_error_get_error_code";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null error, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_error_get_error_code";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null error, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      nw_ethernet_channel_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_error_get_error_code";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null error, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  int isa_high = 0;
LABEL_3:

  return isa_high;
}

void nw_demux_options_add_pattern(void *a1, __int16 a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v21 = "nw_demux_options_add_pattern";
    id v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v19 = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (!__nwlog_fault(v5, &v19, &v18)) {
      goto LABEL_47;
    }
    if (v19 != OS_LOG_TYPE_FAULT)
    {
      if (!v18)
      {
        id v6 = __nwlog_obj();
        os_log_type_t v7 = v19;
        if (!os_log_type_enabled(v6, v19)) {
          goto LABEL_47;
        }
        *(_DWORD *)int buf = 136446210;
        BOOL v21 = "nw_demux_options_add_pattern";
        os_log_type_t v8 = "%{public}s called with null options, backtrace limit exceeded";
        goto LABEL_46;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v7 = v19;
      BOOL v10 = os_log_type_enabled(v6, v19);
      if (!backtrace_string)
      {
        if (!v10) {
          goto LABEL_47;
        }
        *(_DWORD *)int buf = 136446210;
        BOOL v21 = "nw_demux_options_add_pattern";
        os_log_type_t v8 = "%{public}s called with null options, no backtrace";
        goto LABEL_46;
      }
      if (v10)
      {
        *(_DWORD *)int buf = 136446466;
        BOOL v21 = "nw_demux_options_add_pattern";
        __int16 v22 = 2082;
        BOOL v23 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_47;
    }
    id v6 = __nwlog_obj();
    os_log_type_t v7 = v19;
    if (!os_log_type_enabled(v6, v19)) {
      goto LABEL_47;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v21 = "nw_demux_options_add_pattern";
    os_log_type_t v8 = "%{public}s called with null options";
LABEL_46:
    _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0xCu);
    goto LABEL_47;
  }
  if (a3 < 0x1F)
  {
    if (a4)
    {
      v15[0] = MEMORY[0x1E4F143A8];
      v15[1] = 0x40000000;
      v15[2] = __nw_demux_options_add_pattern_block_invoke;
      v15[3] = &__block_descriptor_tmp_10_26220;
      __int16 v16 = a2;
      __int16 v17 = a3;
      v15[4] = a4;
      v15[5] = a5;
      nw_protocol_options_access_handle(a1, v15);
      return;
    }
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v21 = "nw_demux_options_add_pattern";
    id v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v19 = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v5, &v19, &v18))
    {
      if (v19 == OS_LOG_TYPE_FAULT)
      {
        id v6 = __nwlog_obj();
        os_log_type_t v7 = v19;
        if (!os_log_type_enabled(v6, v19)) {
          goto LABEL_47;
        }
        *(_DWORD *)int buf = 136446210;
        BOOL v21 = "nw_demux_options_add_pattern";
        os_log_type_t v8 = "%{public}s called with null pattern";
        goto LABEL_46;
      }
      if (!v18)
      {
        id v6 = __nwlog_obj();
        os_log_type_t v7 = v19;
        if (!os_log_type_enabled(v6, v19)) {
          goto LABEL_47;
        }
        *(_DWORD *)int buf = 136446210;
        BOOL v21 = "nw_demux_options_add_pattern";
        os_log_type_t v8 = "%{public}s called with null pattern, backtrace limit exceeded";
        goto LABEL_46;
      }
      BOOL v11 = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v7 = v19;
      BOOL v14 = os_log_type_enabled(v6, v19);
      if (!v11)
      {
        if (!v14) {
          goto LABEL_47;
        }
        *(_DWORD *)int buf = 136446210;
        BOOL v21 = "nw_demux_options_add_pattern";
        os_log_type_t v8 = "%{public}s called with null pattern, no backtrace";
        goto LABEL_46;
      }
      if (v14)
      {
        *(_DWORD *)int buf = 136446466;
        BOOL v21 = "nw_demux_options_add_pattern";
        __int16 v22 = 2082;
        BOOL v23 = v11;
        char v13 = "%{public}s called with null pattern, dumping backtrace:%{public}s";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
LABEL_47:
    if (v5) {
      goto LABEL_48;
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  BOOL v21 = "nw_demux_options_add_pattern";
  id v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t v19 = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (!__nwlog_fault(v5, &v19, &v18)) {
    goto LABEL_47;
  }
  if (v19 == OS_LOG_TYPE_FAULT)
  {
    id v6 = __nwlog_obj();
    os_log_type_t v7 = v19;
    if (!os_log_type_enabled(v6, v19)) {
      goto LABEL_47;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v21 = "nw_demux_options_add_pattern";
    os_log_type_t v8 = "%{public}s called with null (pattern_length <= NW_DEMUX_MAX_PATTERN_LENGTH)";
    goto LABEL_46;
  }
  if (!v18)
  {
    id v6 = __nwlog_obj();
    os_log_type_t v7 = v19;
    if (!os_log_type_enabled(v6, v19)) {
      goto LABEL_47;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v21 = "nw_demux_options_add_pattern";
    os_log_type_t v8 = "%{public}s called with null (pattern_length <= NW_DEMUX_MAX_PATTERN_LENGTH), backtrace limit exceeded";
    goto LABEL_46;
  }
  BOOL v11 = (char *)__nw_create_backtrace_string();
  id v6 = __nwlog_obj();
  os_log_type_t v7 = v19;
  BOOL v12 = os_log_type_enabled(v6, v19);
  if (!v11)
  {
    if (!v12) {
      goto LABEL_47;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v21 = "nw_demux_options_add_pattern";
    os_log_type_t v8 = "%{public}s called with null (pattern_length <= NW_DEMUX_MAX_PATTERN_LENGTH), no backtrace";
    goto LABEL_46;
  }
  if (v12)
  {
    *(_DWORD *)int buf = 136446466;
    BOOL v21 = "nw_demux_options_add_pattern";
    __int16 v22 = 2082;
    BOOL v23 = v11;
    char v13 = "%{public}s called with null (pattern_length <= NW_DEMUX_MAX_PATTERN_LENGTH), dumping backtrace:%{public}s";
LABEL_31:
    _os_log_impl(&dword_1830D4000, v6, v7, v13, buf, 0x16u);
  }
LABEL_32:
  free(v11);
  if (v5) {
LABEL_48:
  }
    free(v5);
}

uint64_t nw_data_transfer_report_get_duration_milliseconds(nw_data_transfer_report_t report)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  nw_error_t v1 = report;
  nw_error_t v2 = v1;
  if (!v1)
  {
    id v5 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v17 = "nw_data_transfer_report_get_duration_milliseconds";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v7 = __nwlog_obj();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)int buf = 136446210;
          __int16 v17 = "nw_data_transfer_report_get_duration_milliseconds";
          _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null report", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v7 = __nwlog_obj();
        os_log_type_t v11 = type;
        BOOL v12 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)int buf = 136446466;
            __int16 v17 = "nw_data_transfer_report_get_duration_milliseconds";
            __int16 v18 = 2082;
            os_log_type_t v19 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v7, v11, "%{public}s called with null report, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_24;
        }
        if (v12)
        {
          *(_DWORD *)int buf = 136446210;
          __int16 v17 = "nw_data_transfer_report_get_duration_milliseconds";
          _os_log_impl(&dword_1830D4000, v7, v11, "%{public}s called with null report, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v7 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)int buf = 136446210;
          __int16 v17 = "nw_data_transfer_report_get_duration_milliseconds";
          _os_log_impl(&dword_1830D4000, v7, v13, "%{public}s called with null report, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_24:
    if (v6) {
      free(v6);
    }
    goto LABEL_26;
  }
  if (nw_data_transfer_report_get_state(v1) != nw_data_transfer_report_state_collected)
  {
    uint64_t v9 = __nwlog_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      __int16 v17 = "nw_data_transfer_report_get_duration_milliseconds";
      _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_ERROR, "%{public}s Cannot retrieve data report values until collected", buf, 0xCu);
    }

LABEL_26:
    uint64_t isa = 0;
    goto LABEL_4;
  }
  uint64_t isa = (uint64_t)v2[2].isa;
LABEL_4:

  return isa;
}

void sub_183476AE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_context_clear_proxies(void *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  nw_error_t v1 = a1;
  nw_error_t v2 = v1;
  if (v1)
  {
    if ((v1[17] & 0x48) == 0x40 && !dispatch_workloop_is_current())
    {
      v14[0] = MEMORY[0x1E4F143A8];
      v14[1] = 3221225472;
      v14[2] = __nw_context_clear_proxies_block_invoke;
      v14[3] = &unk_1E524BAA8;
      uint64_t v15 = v2;
      nw_queue_context_async(v15, v14);
    }
    else
    {
      id v3 = (void *)v2[7];
      v2[7] = 0;

      uint64_t v4 = v2[5];
      if (v4)
      {
        id v5 = *(void **)(v4 + 56);
        *(void *)(v4 + 56) = 0;
      }
    }
    goto LABEL_7;
  }
  id v6 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v19 = "nw_context_clear_proxies";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v7, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v19 = "nw_context_clear_proxies";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v19 = "nw_context_clear_proxies";
          __int16 v20 = 2082;
          BOOL v21 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }
      if (v12)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v19 = "nw_context_clear_proxies";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v19 = "nw_context_clear_proxies";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_24:
  if (v7) {
    free(v7);
  }
LABEL_7:
}

void sub_183476E28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

CFTypeRef nw_authentication_credential_cache_entry_get_http_authentication(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_error_t v2 = v1;
  if (!v1)
  {
    id v5 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    char v16 = "nw_authentication_credential_cache_entry_get_http_authentication";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (!__nwlog_fault(v6, &type, &v13)) {
      goto LABEL_19;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v16 = "nw_authentication_credential_cache_entry_get_http_authentication";
        os_log_type_t v9 = "%{public}s called with null cache_entry";
LABEL_17:
        _os_log_impl(&dword_1830D4000, v7, v8, v9, buf, 0xCu);
      }
    }
    else
    {
      if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v7 = __nwlog_obj();
        os_log_type_t v8 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)int buf = 136446466;
            char v16 = "nw_authentication_credential_cache_entry_get_http_authentication";
            __int16 v17 = 2082;
            __int16 v18 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null cache_entry, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }
        if (!v11) {
          goto LABEL_18;
        }
        *(_DWORD *)int buf = 136446210;
        char v16 = "nw_authentication_credential_cache_entry_get_http_authentication";
        os_log_type_t v9 = "%{public}s called with null cache_entry, no backtrace";
        goto LABEL_17;
      }
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v16 = "nw_authentication_credential_cache_entry_get_http_authentication";
        os_log_type_t v9 = "%{public}s called with null cache_entry, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
LABEL_18:

LABEL_19:
    if (v6) {
      free(v6);
    }
    goto LABEL_21;
  }
  id v3 = (const void *)*((void *)v1 + 1);
  if (!v3)
  {
LABEL_21:
    CFTypeRef v4 = 0;
    goto LABEL_22;
  }
  CFTypeRef v4 = CFRetain(v3);
LABEL_22:

  return v4;
}

BOOL nw_application_id_create_with_audit_token(long long *a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  long long v1 = a1[1];
  long long v12 = *a1;
  long long v13 = v1;
  if ((unint64_t)v12 | *((void *)&v12 + 1) | (unint64_t)v1 | *((void *)&v1 + 1))
  {
    *(void *)int buf = 0;
    *(void *)&buf[8] = 0;
    return -[NWConcrete_nw_application_id initWithUUID:auditToken:pid:bundleID:isBundleIDExternal:systemService:]([NWConcrete_nw_application_id alloc], buf, a1, 0, 0);
  }
  id v3 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_application_id_create_with_audit_token";
  CFTypeRef v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_application_id_create_with_audit_token";
        os_log_type_t v7 = "%{public}s audit token is null";
LABEL_17:
        _os_log_impl(&dword_1830D4000, v5, v6, v7, buf, 0xCu);
      }
    }
    else
    {
      if (v10)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        id v5 = __nwlog_obj();
        os_log_type_t v6 = type;
        BOOL v9 = os_log_type_enabled(v5, type);
        if (backtrace_string)
        {
          if (v9)
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_application_id_create_with_audit_token";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s audit token is null, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }
        if (!v9) {
          goto LABEL_18;
        }
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_application_id_create_with_audit_token";
        os_log_type_t v7 = "%{public}s audit token is null, no backtrace";
        goto LABEL_17;
      }
      id v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_application_id_create_with_audit_token";
        os_log_type_t v7 = "%{public}s audit token is null, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
LABEL_18:
  }
LABEL_19:
  if (v4) {
    free(v4);
  }
  return 0;
}

void nw_agent_set_assert_handlers(void *a1, void *a2, void *a3)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  os_log_type_t v8 = v7;
  if (!v5)
  {
    char v10 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v36 = "nw_agent_set_assert_handlers";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v11, &type, &v33)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      long long v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v36 = "nw_agent_set_assert_handlers";
        _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null agent", buf, 0xCu);
      }
    }
    else if (v33)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      long long v12 = __nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v20 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v36 = "nw_agent_set_assert_handlers";
          __int16 v37 = 2082;
          Class v38 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v12, v19, "%{public}s called with null agent, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v11) {
          goto LABEL_5;
        }
LABEL_56:
        free(v11);
        goto LABEL_5;
      }
      if (v20)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v36 = "nw_agent_set_assert_handlers";
        _os_log_impl(&dword_1830D4000, v12, v19, "%{public}s called with null agent, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      long long v12 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v36 = "nw_agent_set_assert_handlers";
        _os_log_impl(&dword_1830D4000, v12, v26, "%{public}s called with null agent, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_54:

    goto LABEL_55;
  }
  if (!v6)
  {
    char v14 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v36 = "nw_agent_set_assert_handlers";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v11, &type, &v33)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      long long v12 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v36 = "nw_agent_set_assert_handlers";
        _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null assert_handler", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v33)
    {
      long long v12 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v36 = "nw_agent_set_assert_handlers";
        _os_log_impl(&dword_1830D4000, v12, v27, "%{public}s called with null assert_handler, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    BOOL v21 = (char *)__nw_create_backtrace_string();
    long long v12 = __nwlog_obj();
    os_log_type_t v22 = type;
    BOOL v23 = os_log_type_enabled(v12, type);
    if (!v21)
    {
      if (v23)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v36 = "nw_agent_set_assert_handlers";
        _os_log_impl(&dword_1830D4000, v12, v22, "%{public}s called with null assert_handler, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v23)
    {
      *(_DWORD *)int buf = 136446466;
      uint64_t v36 = "nw_agent_set_assert_handlers";
      __int16 v37 = 2082;
      Class v38 = v21;
      _os_log_impl(&dword_1830D4000, v12, v22, "%{public}s called with null assert_handler, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_35;
  }
  if (!v7)
  {
    char v16 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v36 = "nw_agent_set_assert_handlers";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v11, &type, &v33)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      long long v12 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v36 = "nw_agent_set_assert_handlers";
        _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null unassert_handler", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v33)
    {
      long long v12 = __nwlog_obj();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v36 = "nw_agent_set_assert_handlers";
        _os_log_impl(&dword_1830D4000, v12, v28, "%{public}s called with null unassert_handler, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    BOOL v21 = (char *)__nw_create_backtrace_string();
    long long v12 = __nwlog_obj();
    os_log_type_t v24 = type;
    BOOL v25 = os_log_type_enabled(v12, type);
    if (!v21)
    {
      if (v25)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v36 = "nw_agent_set_assert_handlers";
        _os_log_impl(&dword_1830D4000, v12, v24, "%{public}s called with null unassert_handler, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v25)
    {
      *(_DWORD *)int buf = 136446466;
      uint64_t v36 = "nw_agent_set_assert_handlers";
      __int16 v37 = 2082;
      Class v38 = v21;
      _os_log_impl(&dword_1830D4000, v12, v24, "%{public}s called with null unassert_handler, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_35:

    free(v21);
    if (!v11) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }
  v29[0] = MEMORY[0x1E4F143A8];
  v29[1] = 3221225472;
  v29[2] = __nw_agent_set_assert_handlers_block_invoke;
  v29[3] = &unk_1E5249FD8;
  BOOL v9 = (os_unfair_lock_s *)v5;
  os_log_type_t v30 = v9;
  id v31 = v6;
  id v32 = v8;
  os_unfair_lock_lock(v9 + 2);
  __nw_agent_set_assert_handlers_block_invoke((uint64_t)v29);
  os_unfair_lock_unlock(v9 + 2);

LABEL_5:
}

void sub_183477AB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

uint64_t nw_activity_get_underlying_error_domain_string(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  long long v1 = a1;
  nw_error_t v2 = v1;
  if (!v1)
  {
    id v6 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v17 = "nw_activity_get_underlying_error_domain_string";
    id v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault(v7, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v17 = "nw_activity_get_underlying_error_domain_string";
          _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null activity", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v11 = type;
        BOOL v12 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)int buf = 136446466;
            os_log_type_t v17 = "nw_activity_get_underlying_error_domain_string";
            __int16 v18 = 2082;
            os_log_type_t v19 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_27;
        }
        if (v12)
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v17 = "nw_activity_get_underlying_error_domain_string";
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null activity, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v17 = "nw_activity_get_underlying_error_domain_string";
          _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_27:
    if (v7) {
      free(v7);
    }
    goto LABEL_8;
  }
  if ((v1[140] & 8) != 0)
  {
    uint64_t v4 = *((void *)v1 + 9);
    goto LABEL_10;
  }
  if (__nwlog_activity_log::onceToken != -1) {
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
  }
  id v3 = (id)gactivityLogObj;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)int buf = 138543362;
    os_log_type_t v17 = v2;
    _os_log_impl(&dword_1830D4000, v3, OS_LOG_TYPE_DEBUG, "%{public}@ not complete, returning NULL for underlying error domain string", buf, 0xCu);
  }

LABEL_8:
  uint64_t v4 = 0;
LABEL_10:

  return v4;
}

uint64_t nw_activity_get_underlying_error_domain(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  long long v1 = a1;
  nw_error_t v2 = (char *)v1;
  if (!v1)
  {
    id v6 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v17 = "nw_activity_get_underlying_error_domain";
    id v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault(v7, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v17 = "nw_activity_get_underlying_error_domain";
          _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null activity", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v11 = type;
        BOOL v12 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)int buf = 136446466;
            os_log_type_t v17 = "nw_activity_get_underlying_error_domain";
            __int16 v18 = 2082;
            os_log_type_t v19 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_27;
        }
        if (v12)
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v17 = "nw_activity_get_underlying_error_domain";
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null activity, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v17 = "nw_activity_get_underlying_error_domain";
          _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_27:
    if (v7) {
      free(v7);
    }
    goto LABEL_8;
  }
  if ((v1[35] & 8) != 0)
  {
    uint64_t v4 = v1[31];
    goto LABEL_10;
  }
  if (__nwlog_activity_log::onceToken != -1) {
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
  }
  id v3 = (id)gactivityLogObj;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)int buf = 138543362;
    os_log_type_t v17 = v2;
    _os_log_impl(&dword_1830D4000, v3, OS_LOG_TYPE_DEBUG, "%{public}@ not complete, returning 0 for underlying error domain", buf, 0xCu);
  }

LABEL_8:
  uint64_t v4 = 0;
LABEL_10:

  return v4;
}

uint64_t nw_activity_get_underlying_error_code(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  long long v1 = a1;
  nw_error_t v2 = (char *)v1;
  if (!v1)
  {
    id v6 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v17 = "nw_activity_get_underlying_error_code";
    id v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault(v7, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v17 = "nw_activity_get_underlying_error_code";
          _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null activity", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v11 = type;
        BOOL v12 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)int buf = 136446466;
            os_log_type_t v17 = "nw_activity_get_underlying_error_code";
            __int16 v18 = 2082;
            os_log_type_t v19 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_27;
        }
        if (v12)
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v17 = "nw_activity_get_underlying_error_code";
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null activity, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v17 = "nw_activity_get_underlying_error_code";
          _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_27:
    if (v7) {
      free(v7);
    }
    goto LABEL_8;
  }
  if ((v1[35] & 8) != 0)
  {
    uint64_t v4 = v1[32];
    goto LABEL_10;
  }
  if (__nwlog_activity_log::onceToken != -1) {
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
  }
  id v3 = (id)gactivityLogObj;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)int buf = 138543362;
    os_log_type_t v17 = v2;
    _os_log_impl(&dword_1830D4000, v3, OS_LOG_TYPE_DEBUG, "%{public}@ not complete, returning 0 for underlying error code", buf, 0xCu);
  }

LABEL_8:
  uint64_t v4 = 0;
LABEL_10:

  return v4;
}

uint64_t nw_activity_get_fragments_quenched(void *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  long long v1 = a1;
  nw_error_t v2 = v1;
  if (v1)
  {
    *(void *)int buf = 0;
    *(void *)&buf[8] = buf;
    int v21 = 0;
    *(void *)&buf[16] = 0x2020000000;
    aBlock[0] = MEMORY[0x1E4F143A8];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_activity_get_fragments_quenched_block_invoke;
    aBlock[3] = &unk_1E524B978;
    char v16 = buf;
    os_log_type_t v15 = v1;
    id v3 = _Block_copy(aBlock);
    os_log_type_t v17 = v3;
    nw_synchronize<nw::unfair_mutex,void({block_pointer} {__strong})(void)>(v2 + 20, (uint64_t)&v17);

    uint64_t v4 = *(unsigned int *)(*(void *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  id v6 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_activity_get_fragments_quenched";
  id v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (__nwlog_fault(v7, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_activity_get_fragments_quenched";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null activity", buf, 0xCu);
      }
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_activity_get_fragments_quenched";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_activity_get_fragments_quenched";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_activity_get_fragments_quenched";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v7) {
    free(v7);
  }
  uint64_t v4 = 0;
LABEL_3:

  return v4;
}

void sub_183478780(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t nw_activity_get_completion_reason(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  long long v1 = a1;
  nw_error_t v2 = (char *)v1;
  if (!v1)
  {
    id v6 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v17 = "nw_activity_get_completion_reason";
    id v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault(v7, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v17 = "nw_activity_get_completion_reason";
          _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null activity", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v11 = type;
        BOOL v12 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)int buf = 136446466;
            os_log_type_t v17 = "nw_activity_get_completion_reason";
            __int16 v18 = 2082;
            os_log_type_t v19 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_27;
        }
        if (v12)
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v17 = "nw_activity_get_completion_reason";
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null activity, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v17 = "nw_activity_get_completion_reason";
          _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_27:
    if (v7) {
      free(v7);
    }
    goto LABEL_8;
  }
  if ((v1[35] & 8) != 0)
  {
    uint64_t v4 = v1[34];
    goto LABEL_10;
  }
  if (__nwlog_activity_log::onceToken != -1) {
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
  }
  id v3 = (id)gactivityLogObj;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)int buf = 138543362;
    os_log_type_t v17 = v2;
    _os_log_impl(&dword_1830D4000, v3, OS_LOG_TYPE_DEBUG, "%{public}@ not complete, returning nw_activity_completion_reason_invalid", buf, 0xCu);
  }

LABEL_8:
  uint64_t v4 = 0;
LABEL_10:

  return v4;
}

void networkd_privileged_teardown_feth_pair(const char *a1, const char *a2)
{
  uint64_t v106 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    os_log_type_t v76 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    long long v101 = "networkd_privileged_teardown_feth_pair";
    uint64_t v77 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v98 = 0;
    if (!__nwlog_fault(v77, &type, &v98)) {
      goto LABEL_225;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v78 = __nwlog_obj();
      os_log_type_t v79 = type;
      if (os_log_type_enabled(v78, type))
      {
        *(_DWORD *)int buf = 136446210;
        long long v101 = "networkd_privileged_teardown_feth_pair";
        _os_log_impl(&dword_1830D4000, v78, v79, "%{public}s called with null ifname1", buf, 0xCu);
      }
    }
    else if (v98)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unint64_t v78 = __nwlog_obj();
      os_log_type_t v87 = type;
      BOOL v88 = os_log_type_enabled(v78, type);
      if (backtrace_string)
      {
        if (v88)
        {
          *(_DWORD *)int buf = 136446466;
          long long v101 = "networkd_privileged_teardown_feth_pair";
          __int16 v102 = 2082;
          *(void *)long long v103 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v78, v87, "%{public}s called with null ifname1, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_225;
      }
      if (v88)
      {
        *(_DWORD *)int buf = 136446210;
        long long v101 = "networkd_privileged_teardown_feth_pair";
        _os_log_impl(&dword_1830D4000, v78, v87, "%{public}s called with null ifname1, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      unint64_t v78 = __nwlog_obj();
      os_log_type_t v95 = type;
      if (os_log_type_enabled(v78, type))
      {
        *(_DWORD *)int buf = 136446210;
        long long v101 = "networkd_privileged_teardown_feth_pair";
        _os_log_impl(&dword_1830D4000, v78, v95, "%{public}s called with null ifname1, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_224:

    goto LABEL_225;
  }
  if (a2)
  {
    xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
    id v5 = v4;
    if (v4)
    {
      xpc_dictionary_set_uint64(v4, (const char *)networkd_privileged_key_type, 0x12uLL);
      xpc_dictionary_set_string(v5, (const char *)networkd_privileged_key_interface_name, a1);
      xpc_dictionary_set_string(v5, (const char *)networkd_privileged_key_second_interface_name, a2);
      xpc_object_t v6 = networkd_privileged_send_sync_inner((uint64_t)"networkd_privileged_teardown_feth_pair", v5);
      id v7 = v6;
      if (!v6)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v14 = (id)gLogObj;
        *(_DWORD *)int buf = 136446210;
        long long v101 = "networkd_privileged_teardown_feth_pair";
        os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v98 = 0;
        if (!__nwlog_fault(v9, &type, &v98)) {
          goto LABEL_77;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v15 = (id)gLogObj;
          os_log_type_t v16 = type;
          if (os_log_type_enabled(v15, type))
          {
            *(_DWORD *)int buf = 136446210;
            long long v101 = "networkd_privileged_teardown_feth_pair";
            _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s received NULL response", buf, 0xCu);
          }
          goto LABEL_76;
        }
        if (!v98)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v15 = (id)gLogObj;
          os_log_type_t v33 = type;
          if (os_log_type_enabled(v15, type))
          {
            *(_DWORD *)int buf = 136446210;
            long long v101 = "networkd_privileged_teardown_feth_pair";
            _os_log_impl(&dword_1830D4000, v15, v33, "%{public}s received NULL response, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_76;
        }
        BOOL v23 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v15 = (id)gLogObj;
        os_log_type_t v24 = type;
        BOOL v25 = os_log_type_enabled(v15, type);
        if (!v23)
        {
          if (v25)
          {
            *(_DWORD *)int buf = 136446210;
            long long v101 = "networkd_privileged_teardown_feth_pair";
            _os_log_impl(&dword_1830D4000, v15, v24, "%{public}s received NULL response, no backtrace", buf, 0xCu);
          }
          goto LABEL_76;
        }
        if (v25)
        {
          *(_DWORD *)int buf = 136446466;
          long long v101 = "networkd_privileged_teardown_feth_pair";
          __int16 v102 = 2082;
          *(void *)long long v103 = v23;
          _os_log_impl(&dword_1830D4000, v15, v24, "%{public}s received NULL response, dumping backtrace:%{public}s", buf, 0x16u);
        }
        goto LABEL_28;
      }
      Class Class = object_getClass(v6);
      if (Class != (Class)MEMORY[0x1E4F14590])
      {
        if (Class != (Class)MEMORY[0x1E4F145A8])
        {
          os_log_type_t v9 = (char *)MEMORY[0x185319370](v7);
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v10 = (id)gLogObj;
          *(_DWORD *)int buf = 136446466;
          long long v101 = "networkd_privileged_teardown_feth_pair";
          __int16 v102 = 2082;
          *(void *)long long v103 = v9;
          os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v98 = 0;
          if (!__nwlog_fault(v11, &type, &v98)) {
            goto LABEL_67;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v12 = (id)gLogObj;
            os_log_type_t v13 = type;
            if (os_log_type_enabled(v12, type))
            {
              *(_DWORD *)int buf = 136446466;
              long long v101 = "networkd_privileged_teardown_feth_pair";
              __int16 v102 = 2082;
              *(void *)long long v103 = v9;
              _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s received unknown type XPC %{public}s", buf, 0x16u);
            }
LABEL_66:

LABEL_67:
            if (!v11) {
              goto LABEL_77;
            }
            goto LABEL_68;
          }
          if (!v98)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v12 = (id)gLogObj;
            os_log_type_t v42 = type;
            if (os_log_type_enabled(v12, type))
            {
              *(_DWORD *)int buf = 136446466;
              long long v101 = "networkd_privileged_teardown_feth_pair";
              __int16 v102 = 2082;
              *(void *)long long v103 = v9;
              _os_log_impl(&dword_1830D4000, v12, v42, "%{public}s received unknown type XPC %{public}s, backtrace limit exceeded", buf, 0x16u);
            }
            goto LABEL_66;
          }
          os_log_type_t v28 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v12 = (id)gLogObj;
          os_log_type_t v29 = type;
          BOOL v30 = os_log_type_enabled(v12, type);
          if (!v28)
          {
            if (v30)
            {
              *(_DWORD *)int buf = 136446466;
              long long v101 = "networkd_privileged_teardown_feth_pair";
              __int16 v102 = 2082;
              *(void *)long long v103 = v9;
              _os_log_impl(&dword_1830D4000, v12, v29, "%{public}s received unknown type XPC %{public}s, no backtrace", buf, 0x16u);
            }
            goto LABEL_66;
          }
          if (v30)
          {
            *(_DWORD *)int buf = 136446722;
            long long v101 = "networkd_privileged_teardown_feth_pair";
            __int16 v102 = 2082;
            *(void *)long long v103 = v9;
            *(_WORD *)&v103[8] = 2082;
            *(void *)&v103[10] = v28;
            _os_log_impl(&dword_1830D4000, v12, v29, "%{public}s received unknown type XPC %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(v28);
          if (!v11)
          {
LABEL_77:
            if (!v9)
            {
LABEL_136:

LABEL_137:
              return;
            }
LABEL_78:
            free(v9);
            goto LABEL_136;
          }
LABEL_68:
          free(v11);
          goto LABEL_77;
        }
        if (v7 == (void *)MEMORY[0x1E4F14520])
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v34 = (id)gLogObj;
          *(_DWORD *)int buf = 136446210;
          long long v101 = "networkd_privileged_teardown_feth_pair";
          os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v98 = 0;
          if (!__nwlog_fault(v9, &type, &v98)) {
            goto LABEL_77;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v15 = (id)gLogObj;
            os_log_type_t v35 = type;
            if (os_log_type_enabled(v15, type))
            {
              *(_DWORD *)int buf = 136446210;
              long long v101 = "networkd_privileged_teardown_feth_pair";
              _os_log_impl(&dword_1830D4000, v15, v35, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED", buf, 0xCu);
            }
            goto LABEL_76;
          }
          if (!v98)
          {
            os_log_type_t v15 = __nwlog_obj();
            os_log_type_t v64 = type;
            if (os_log_type_enabled(v15, type))
            {
              *(_DWORD *)int buf = 136446210;
              long long v101 = "networkd_privileged_teardown_feth_pair";
              _os_log_impl(&dword_1830D4000, v15, v64, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, backtrace limit exceeded", buf, 0xCu);
            }
            goto LABEL_76;
          }
          BOOL v23 = (char *)__nw_create_backtrace_string();
          os_log_type_t v15 = __nwlog_obj();
          os_log_type_t v49 = type;
          BOOL v50 = os_log_type_enabled(v15, type);
          if (!v23)
          {
            if (v50)
            {
              *(_DWORD *)int buf = 136446210;
              long long v101 = "networkd_privileged_teardown_feth_pair";
              _os_log_impl(&dword_1830D4000, v15, v49, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, no backtrace", buf, 0xCu);
            }
            goto LABEL_76;
          }
          if (v50)
          {
            *(_DWORD *)int buf = 136446466;
            long long v101 = "networkd_privileged_teardown_feth_pair";
            __int16 v102 = 2082;
            *(void *)long long v103 = v23;
            _os_log_impl(&dword_1830D4000, v15, v49, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, dumping backtrace:%{public}s", buf, 0x16u);
          }
        }
        else
        {
          if (v7 == (void *)MEMORY[0x1E4F14528])
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            unint64_t v48 = (id)gLogObj;
            if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)int buf = 136446210;
              long long v101 = "networkd_privileged_teardown_feth_pair";
              _os_log_impl(&dword_1830D4000, v48, OS_LOG_TYPE_ERROR, "%{public}s received XPC_ERROR_CONNECTION_INVALID", buf, 0xCu);
            }

            goto LABEL_136;
          }
          if (v7 != (void *)MEMORY[0x1E4F14550])
          {
            os_log_type_t v9 = (char *)MEMORY[0x185319370](v7);
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v26 = (id)gLogObj;
            *(_DWORD *)int buf = 136446466;
            long long v101 = "networkd_privileged_teardown_feth_pair";
            __int16 v102 = 2082;
            *(void *)long long v103 = v9;
            os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

            os_log_type_t type = OS_LOG_TYPE_ERROR;
            char v98 = 0;
            if (!__nwlog_fault(v11, &type, &v98)) {
              goto LABEL_67;
            }
            if (type == OS_LOG_TYPE_FAULT)
            {
              BOOL v12 = __nwlog_obj();
              os_log_type_t v27 = type;
              if (os_log_type_enabled(v12, type))
              {
                *(_DWORD *)int buf = 136446466;
                long long v101 = "networkd_privileged_teardown_feth_pair";
                __int16 v102 = 2082;
                *(void *)long long v103 = v9;
                _os_log_impl(&dword_1830D4000, v12, v27, "%{public}s received returned unknown XPC error %{public}s", buf, 0x16u);
              }
              goto LABEL_66;
            }
            if (!v98)
            {
              BOOL v12 = __nwlog_obj();
              os_log_type_t v72 = type;
              if (os_log_type_enabled(v12, type))
              {
                *(_DWORD *)int buf = 136446466;
                long long v101 = "networkd_privileged_teardown_feth_pair";
                __int16 v102 = 2082;
                *(void *)long long v103 = v9;
                _os_log_impl(&dword_1830D4000, v12, v72, "%{public}s received returned unknown XPC error %{public}s, backtrace limit exceeded", buf, 0x16u);
              }
              goto LABEL_66;
            }
            BOOL v53 = (char *)__nw_create_backtrace_string();
            BOOL v12 = __nwlog_obj();
            os_log_type_t v54 = type;
            BOOL v55 = os_log_type_enabled(v12, type);
            if (!v53)
            {
              if (v55)
              {
                *(_DWORD *)int buf = 136446466;
                long long v101 = "networkd_privileged_teardown_feth_pair";
                __int16 v102 = 2082;
                *(void *)long long v103 = v9;
                _os_log_impl(&dword_1830D4000, v12, v54, "%{public}s received returned unknown XPC error %{public}s, no backtrace", buf, 0x16u);
              }
              goto LABEL_66;
            }
            if (v55)
            {
              *(_DWORD *)int buf = 136446722;
              long long v101 = "networkd_privileged_teardown_feth_pair";
              __int16 v102 = 2082;
              *(void *)long long v103 = v9;
              *(_WORD *)&v103[8] = 2082;
              *(void *)&v103[10] = v53;
              _os_log_impl(&dword_1830D4000, v12, v54, "%{public}s received returned unknown XPC error %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
            }

            free(v53);
            if (!v11) {
              goto LABEL_77;
            }
            goto LABEL_68;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v51 = (id)gLogObj;
          *(_DWORD *)int buf = 136446210;
          long long v101 = "networkd_privileged_teardown_feth_pair";
          os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v98 = 0;
          if (!__nwlog_fault(v9, &type, &v98)) {
            goto LABEL_77;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            os_log_type_t v15 = __nwlog_obj();
            os_log_type_t v52 = type;
            if (os_log_type_enabled(v15, type))
            {
              *(_DWORD *)int buf = 136446210;
              long long v101 = "networkd_privileged_teardown_feth_pair";
              _os_log_impl(&dword_1830D4000, v15, v52, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT", buf, 0xCu);
            }
LABEL_76:

            goto LABEL_77;
          }
          if (!v98)
          {
            os_log_type_t v15 = __nwlog_obj();
            os_log_type_t v73 = type;
            if (os_log_type_enabled(v15, type))
            {
              *(_DWORD *)int buf = 136446210;
              long long v101 = "networkd_privileged_teardown_feth_pair";
              _os_log_impl(&dword_1830D4000, v15, v73, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, backtrace limit exceeded", buf, 0xCu);
            }
            goto LABEL_76;
          }
          BOOL v23 = (char *)__nw_create_backtrace_string();
          os_log_type_t v15 = __nwlog_obj();
          os_log_type_t v62 = type;
          BOOL v63 = os_log_type_enabled(v15, type);
          if (!v23)
          {
            if (v63)
            {
              *(_DWORD *)int buf = 136446210;
              long long v101 = "networkd_privileged_teardown_feth_pair";
              _os_log_impl(&dword_1830D4000, v15, v62, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, no backtrace", buf, 0xCu);
            }
            goto LABEL_76;
          }
          if (v63)
          {
            *(_DWORD *)int buf = 136446466;
            long long v101 = "networkd_privileged_teardown_feth_pair";
            __int16 v102 = 2082;
            *(void *)long long v103 = v23;
            _os_log_impl(&dword_1830D4000, v15, v62, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, dumping backtrace:%{public}s", buf, 0x16u);
          }
        }
LABEL_28:

        free(v23);
        if (!v9) {
          goto LABEL_136;
        }
        goto LABEL_78;
      }
      os_log_type_t v17 = xpc_dictionary_get_value(v7, (const char *)networkd_privileged_key_result);
      __int16 v18 = v17;
      if (!v17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v31 = (id)gLogObj;
        *(_DWORD *)int buf = 136446210;
        long long v101 = "networkd_privileged_teardown_feth_pair";
        uint64_t v20 = (const char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v98 = 0;
        if (!__nwlog_fault(v20, &type, &v98)) {
          goto LABEL_132;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v21 = (id)gLogObj;
          os_log_type_t v32 = type;
          if (os_log_type_enabled(v21, type))
          {
            *(_DWORD *)int buf = 136446210;
            long long v101 = "networkd_privileged_teardown_feth_pair";
            _os_log_impl(&dword_1830D4000, v21, v32, "%{public}s received response without result code", buf, 0xCu);
          }
          goto LABEL_131;
        }
        if (!v98)
        {
          int v21 = __nwlog_obj();
          os_log_type_t v61 = type;
          if (os_log_type_enabled(v21, type))
          {
            *(_DWORD *)int buf = 136446210;
            long long v101 = "networkd_privileged_teardown_feth_pair";
            _os_log_impl(&dword_1830D4000, v21, v61, "%{public}s received response without result code, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_131;
        }
        Class v43 = (char *)__nw_create_backtrace_string();
        int v21 = __nwlog_obj();
        os_log_type_t v46 = type;
        BOOL v47 = os_log_type_enabled(v21, type);
        if (!v43)
        {
          if (v47)
          {
            *(_DWORD *)int buf = 136446210;
            long long v101 = "networkd_privileged_teardown_feth_pair";
            _os_log_impl(&dword_1830D4000, v21, v46, "%{public}s received response without result code, no backtrace", buf, 0xCu);
          }
          goto LABEL_131;
        }
        if (v47)
        {
          *(_DWORD *)int buf = 136446466;
          long long v101 = "networkd_privileged_teardown_feth_pair";
          __int16 v102 = 2082;
          *(void *)long long v103 = v43;
          _os_log_impl(&dword_1830D4000, v21, v46, "%{public}s received response without result code, dumping backtrace:%{public}s", buf, 0x16u);
        }
        goto LABEL_83;
      }
      if (object_getClass(v17) != (Class)MEMORY[0x1E4F145C0])
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v19 = (id)gLogObj;
        *(_DWORD *)int buf = 136446210;
        long long v101 = "networkd_privileged_teardown_feth_pair";
        uint64_t v20 = (const char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v98 = 0;
        if (!__nwlog_fault(v20, &type, &v98)) {
          goto LABEL_132;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v21 = (id)gLogObj;
          os_log_type_t v22 = type;
          if (os_log_type_enabled(v21, type))
          {
            *(_DWORD *)int buf = 136446210;
            long long v101 = "networkd_privileged_teardown_feth_pair";
            _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s received invalid result type", buf, 0xCu);
          }
LABEL_131:

LABEL_132:
          if (v20)
          {
LABEL_133:
            BOOL v65 = (char *)v20;
LABEL_134:
            free(v65);
          }
LABEL_135:

          goto LABEL_136;
        }
        if (!v98)
        {
          int v21 = __nwlog_obj();
          os_log_type_t v60 = type;
          if (os_log_type_enabled(v21, type))
          {
            *(_DWORD *)int buf = 136446210;
            long long v101 = "networkd_privileged_teardown_feth_pair";
            _os_log_impl(&dword_1830D4000, v21, v60, "%{public}s received invalid result type, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_131;
        }
        Class v43 = (char *)__nw_create_backtrace_string();
        int v21 = __nwlog_obj();
        os_log_type_t v44 = type;
        BOOL v45 = os_log_type_enabled(v21, type);
        if (!v43)
        {
          if (v45)
          {
            *(_DWORD *)int buf = 136446210;
            long long v101 = "networkd_privileged_teardown_feth_pair";
            _os_log_impl(&dword_1830D4000, v21, v44, "%{public}s received invalid result type, no backtrace", buf, 0xCu);
          }
          goto LABEL_131;
        }
        if (v45)
        {
          *(_DWORD *)int buf = 136446466;
          long long v101 = "networkd_privileged_teardown_feth_pair";
          __int16 v102 = 2082;
          *(void *)long long v103 = v43;
          _os_log_impl(&dword_1830D4000, v21, v44, "%{public}s received invalid result type, dumping backtrace:%{public}s", buf, 0x16u);
        }
LABEL_83:

        free(v43);
        if (!v20) {
          goto LABEL_135;
        }
        goto LABEL_133;
      }
      unint64_t value = xpc_int64_get_value(v18);
      uint64_t v37 = value;
      if (!value) {
        goto LABEL_135;
      }
      if (!(value >> 31))
      {
        Class v38 = __nwlog_obj();
        *(_DWORD *)int buf = 136446466;
        long long v101 = "networkd_privileged_teardown_feth_pair";
        __int16 v102 = 1024;
        *(_DWORD *)long long v103 = v37;
        uint64_t v39 = (const char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v98 = 0;
        if (__nwlog_fault(v39, &type, &v98))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            __int16 v40 = __nwlog_obj();
            os_log_type_t v41 = type;
            if (os_log_type_enabled(v40, type))
            {
              *(_DWORD *)int buf = 136446466;
              long long v101 = "networkd_privileged_teardown_feth_pair";
              __int16 v102 = 1024;
              *(_DWORD *)long long v103 = v37;
              _os_log_impl(&dword_1830D4000, v40, v41, "%{public}s received failure result code %{darwin.errno}d", buf, 0x12u);
            }
          }
          else if (v98)
          {
            uint32_t v66 = (char *)__nw_create_backtrace_string();
            __int16 v40 = __nwlog_obj();
            os_log_type_t v67 = type;
            BOOL v68 = os_log_type_enabled(v40, type);
            if (v66)
            {
              if (v68)
              {
                *(_DWORD *)int buf = 136446722;
                long long v101 = "networkd_privileged_teardown_feth_pair";
                __int16 v102 = 1024;
                *(_DWORD *)long long v103 = v37;
                *(_WORD *)&v103[4] = 2082;
                *(void *)&v103[6] = v66;
                _os_log_impl(&dword_1830D4000, v40, v67, "%{public}s received failure result code %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
              }

              free(v66);
              if (!v39) {
                goto LABEL_135;
              }
LABEL_178:
              BOOL v65 = (char *)v39;
              goto LABEL_134;
            }
            if (v68)
            {
              *(_DWORD *)int buf = 136446466;
              long long v101 = "networkd_privileged_teardown_feth_pair";
              __int16 v102 = 1024;
              *(_DWORD *)long long v103 = v37;
              _os_log_impl(&dword_1830D4000, v40, v67, "%{public}s received failure result code %{darwin.errno}d, no backtrace", buf, 0x12u);
            }
          }
          else
          {
            __int16 v40 = __nwlog_obj();
            os_log_type_t v74 = type;
            if (os_log_type_enabled(v40, type))
            {
              *(_DWORD *)int buf = 136446466;
              long long v101 = "networkd_privileged_teardown_feth_pair";
              __int16 v102 = 1024;
              *(_DWORD *)long long v103 = v37;
              _os_log_impl(&dword_1830D4000, v40, v74, "%{public}s received failure result code %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
            }
          }
        }
LABEL_177:
        if (!v39) {
          goto LABEL_135;
        }
        goto LABEL_178;
      }
      BOOL v56 = __nwlog_obj();
      BOOL v57 = networkd_privileged_result_to_string(v37);
      *(_DWORD *)int buf = 136446722;
      long long v101 = "networkd_privileged_teardown_feth_pair";
      __int16 v102 = 2048;
      *(void *)long long v103 = v37;
      *(_WORD *)&v103[8] = 2082;
      *(void *)&v103[10] = v57;
      uint64_t v39 = (const char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v98 = 0;
      if (!__nwlog_fault(v39, &type, &v98)) {
        goto LABEL_177;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint32_t v58 = __nwlog_obj();
        os_log_type_t v59 = type;
        if (os_log_type_enabled(v58, type))
        {
          *(_DWORD *)int buf = 136446722;
          long long v101 = "networkd_privileged_teardown_feth_pair";
          __int16 v102 = 2048;
          *(void *)long long v103 = v37;
          *(_WORD *)&v103[8] = 2082;
          *(void *)&v103[10] = v57;
          _os_log_impl(&dword_1830D4000, v58, v59, "%{public}s received internal failure result code: [%lld] %{public}s", buf, 0x20u);
        }
      }
      else if (v98)
      {
        BOOL v69 = (char *)__nw_create_backtrace_string();
        uint32_t v58 = __nwlog_obj();
        os_log_type_t v70 = type;
        BOOL v71 = os_log_type_enabled(v58, type);
        if (v69)
        {
          if (v71)
          {
            *(_DWORD *)int buf = 136446978;
            long long v101 = "networkd_privileged_teardown_feth_pair";
            __int16 v102 = 2048;
            *(void *)long long v103 = v37;
            *(_WORD *)&v103[8] = 2082;
            *(void *)&v103[10] = v57;
            __int16 v104 = 2082;
            os_log_type_t v105 = v69;
            _os_log_impl(&dword_1830D4000, v58, v70, "%{public}s received internal failure result code: [%lld] %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v69);
          goto LABEL_177;
        }
        if (v71)
        {
          *(_DWORD *)int buf = 136446722;
          long long v101 = "networkd_privileged_teardown_feth_pair";
          __int16 v102 = 2048;
          *(void *)long long v103 = v37;
          *(_WORD *)&v103[8] = 2082;
          *(void *)&v103[10] = v57;
          _os_log_impl(&dword_1830D4000, v58, v70, "%{public}s received internal failure result code: [%lld] %{public}s, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        uint32_t v58 = __nwlog_obj();
        os_log_type_t v75 = type;
        if (os_log_type_enabled(v58, type))
        {
          *(_DWORD *)int buf = 136446722;
          long long v101 = "networkd_privileged_teardown_feth_pair";
          __int16 v102 = 2048;
          *(void *)long long v103 = v37;
          *(_WORD *)&v103[8] = 2082;
          *(void *)&v103[10] = v57;
          _os_log_impl(&dword_1830D4000, v58, v75, "%{public}s received internal failure result code: [%lld] %{public}s, backtrace limit exceeded", buf, 0x20u);
        }
      }

      goto LABEL_177;
    }
    BOOL v82 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    long long v101 = "networkd_privileged_teardown_feth_pair";
    id v83 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v98 = 0;
    if (__nwlog_fault(v83, &type, &v98))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v84 = __nwlog_obj();
        os_log_type_t v85 = type;
        if (os_log_type_enabled(v84, type))
        {
          *(_DWORD *)int buf = 136446210;
          long long v101 = "networkd_privileged_teardown_feth_pair";
          _os_log_impl(&dword_1830D4000, v84, v85, "%{public}s xpc_dictionary_create failed", buf, 0xCu);
        }
      }
      else if (v98)
      {
        long long v92 = (char *)__nw_create_backtrace_string();
        uint64_t v84 = __nwlog_obj();
        os_log_type_t v93 = type;
        BOOL v94 = os_log_type_enabled(v84, type);
        if (v92)
        {
          if (v94)
          {
            *(_DWORD *)int buf = 136446466;
            long long v101 = "networkd_privileged_teardown_feth_pair";
            __int16 v102 = 2082;
            *(void *)long long v103 = v92;
            _os_log_impl(&dword_1830D4000, v84, v93, "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v92);
          goto LABEL_230;
        }
        if (v94)
        {
          *(_DWORD *)int buf = 136446210;
          long long v101 = "networkd_privileged_teardown_feth_pair";
          _os_log_impl(&dword_1830D4000, v84, v93, "%{public}s xpc_dictionary_create failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v84 = __nwlog_obj();
        os_log_type_t v97 = type;
        if (os_log_type_enabled(v84, type))
        {
          *(_DWORD *)int buf = 136446210;
          long long v101 = "networkd_privileged_teardown_feth_pair";
          _os_log_impl(&dword_1830D4000, v84, v97, "%{public}s xpc_dictionary_create failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_230:
    if (v83) {
      free(v83);
    }
    goto LABEL_137;
  }
  uint64_t v80 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  long long v101 = "networkd_privileged_teardown_feth_pair";
  uint64_t v77 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v98 = 0;
  if (__nwlog_fault(v77, &type, &v98))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v78 = __nwlog_obj();
      os_log_type_t v81 = type;
      if (os_log_type_enabled(v78, type))
      {
        *(_DWORD *)int buf = 136446210;
        long long v101 = "networkd_privileged_teardown_feth_pair";
        _os_log_impl(&dword_1830D4000, v78, v81, "%{public}s called with null ifname2", buf, 0xCu);
      }
    }
    else if (v98)
    {
      os_log_type_t v89 = (char *)__nw_create_backtrace_string();
      unint64_t v78 = __nwlog_obj();
      os_log_type_t v90 = type;
      BOOL v91 = os_log_type_enabled(v78, type);
      if (v89)
      {
        if (v91)
        {
          *(_DWORD *)int buf = 136446466;
          long long v101 = "networkd_privileged_teardown_feth_pair";
          __int16 v102 = 2082;
          *(void *)long long v103 = v89;
          _os_log_impl(&dword_1830D4000, v78, v90, "%{public}s called with null ifname2, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v89);
        if (v77) {
          goto LABEL_226;
        }
        return;
      }
      if (v91)
      {
        *(_DWORD *)int buf = 136446210;
        long long v101 = "networkd_privileged_teardown_feth_pair";
        _os_log_impl(&dword_1830D4000, v78, v90, "%{public}s called with null ifname2, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      unint64_t v78 = __nwlog_obj();
      os_log_type_t v96 = type;
      if (os_log_type_enabled(v78, type))
      {
        *(_DWORD *)int buf = 136446210;
        long long v101 = "networkd_privileged_teardown_feth_pair";
        _os_log_impl(&dword_1830D4000, v78, v96, "%{public}s called with null ifname2, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_224;
  }
LABEL_225:
  if (v77) {
LABEL_226:
  }
    free(v77);
}

void sub_18347A810(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t copymptcpinfo(int a1, void *a2)
{
  uint64_t v76 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v72 = "copymptcpinfo";
    BOOL v53 = (char *)_os_log_send_and_compose_impl();
    v70[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v69) = 0;
    if (!__nwlog_fault(v53, v70, &v69)) {
      goto LABEL_95;
    }
    if (v70[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v54 = __nwlog_obj();
      os_log_type_t v55 = v70[0];
      if (!os_log_type_enabled(v54, v70[0])) {
        goto LABEL_95;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v72 = "copymptcpinfo";
      BOOL v56 = "%{public}s called with null mpinfo";
    }
    else if ((_BYTE)v69)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v54 = __nwlog_obj();
      os_log_type_t v55 = v70[0];
      BOOL v60 = os_log_type_enabled(v54, v70[0]);
      if (backtrace_string)
      {
        if (v60)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v72 = "copymptcpinfo";
          __int16 v73 = 2082;
          *(void *)os_log_type_t v74 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v54, v55, "%{public}s called with null mpinfo, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_95;
      }
      if (!v60)
      {
LABEL_95:
        if (v53) {
          free(v53);
        }
        return 0xFFFFFFFFLL;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v72 = "copymptcpinfo";
      BOOL v56 = "%{public}s called with null mpinfo, no backtrace";
    }
    else
    {
      os_log_type_t v54 = __nwlog_obj();
      os_log_type_t v55 = v70[0];
      if (!os_log_type_enabled(v54, v70[0])) {
        goto LABEL_95;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v72 = "copymptcpinfo";
      BOOL v56 = "%{public}s called with null mpinfo, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v54, v55, v56, buf, 0xCu);
    goto LABEL_95;
  }
  nw_error_t v2 = a2;
  *(void *)os_log_type_t v70 = 0;
  xpc_object_t v4 = malloc_type_calloc(1uLL, 0x18uLL, 0xEAFB8F1AuLL);
  if (!v4)
  {
    BOOL v57 = __nwlog_obj();
    os_log_type_enabled(v57, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int buf = 136446722;
    os_log_type_t v72 = "strict_calloc";
    __int16 v73 = 2048;
    *(void *)os_log_type_t v74 = 1;
    *(_WORD *)&v74[8] = 2048;
    *(void *)&long long v75 = 24;
    uint32_t v58 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort((uint64_t)v58);
    if (result)
    {
LABEL_98:
      __break(1u);
      return result;
    }
    free(v58);
  }
  if (copyconninfo(a1, -1, v70)) {
    goto LABEL_4;
  }
  xpc_object_t v6 = *(void **)v70;
  if (*(_DWORD *)(*(void *)v70 + 28) != 2)
  {
    freemptcpinfo(v4);
    os_log_type_t v49 = *(void **)v70;
    if (*(void *)v70)
    {
      BOOL v50 = *(void **)(*(void *)v70 + 8);
      if (v50)
      {
        free(v50);
        v49[1] = 0;
      }
      id v51 = (void *)v49[2];
      if (v51)
      {
        free(v51);
        v49[2] = 0;
      }
      os_log_type_t v52 = (void *)v49[4];
      if (v52) {
        free(v52);
      }
      free(v49);
      return 0xFFFFFFFFLL;
    }
    return 0xFFFFFFFFLL;
  }
  *xpc_object_t v4 = *(void *)v70;
  id v7 = (_WORD *)v6[4];
  if (v7[20]) {
    unsigned int v8 = (v7[56] != 0) + 1;
  }
  else {
    unsigned int v8 = v7[56] != 0;
  }
  if (v7[92]) {
    ++v8;
  }
  if (v7[128]) {
    size_t v9 = v8 + 1;
  }
  else {
    size_t v9 = v8;
  }
  if (v9)
  {
    BOOL v63 = v2;
    id v10 = malloc_type_calloc(v9, 8uLL, 0xEAFB8F1AuLL);
    if (v10)
    {
LABEL_17:
      unsigned int v11 = 0;
      uint64_t v12 = 20;
      v4[1] = v10;
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      while (1)
      {
        int v13 = (unsigned __int16)v7[v12];
        if (v7[v12])
        {
          BOOL v69 = 0;
          if (copyconninfo(a1, v13, &v69))
          {
            int v14 = **(_DWORD **)(StatusReg + 8);
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v15 = gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)int buf = 136446978;
              os_log_type_t v72 = "copymptcpinfo";
              __int16 v73 = 1024;
              *(_DWORD *)os_log_type_t v74 = v13;
              *(_WORD *)&v74[4] = 1024;
              *(_DWORD *)&v74[6] = a1;
              LOWORD(v75) = 1024;
              *(_DWORD *)((char *)&v75 + 2) = v14;
              _os_log_impl(&dword_1830D4000, v15, OS_LOG_TYPE_ERROR, "%{public}s copyconninfo failed for ifindex %u on fd %d %{darwin.errno}d", buf, 0x1Eu);
            }
          }
          else
          {
            if (*((_DWORD *)v69 + 7) != 1)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              int v16 = *((_DWORD *)v69 + 7);
              *(_DWORD *)int buf = 136446978;
              os_log_type_t v72 = "copymptcpinfo";
              __int16 v73 = 1024;
              *(_DWORD *)os_log_type_t v74 = v16;
              *(_WORD *)&v74[4] = 1024;
              *(_DWORD *)&v74[6] = v13;
              LOWORD(v75) = 1024;
              *(_DWORD *)((char *)&v75 + 2) = a1;
              os_log_type_t v17 = (char *)_os_log_send_and_compose_impl();
              os_log_type_t type = OS_LOG_TYPE_ERROR;
              char v67 = 0;
              if (!__nwlog_fault(v17, &type, &v67)) {
                goto LABEL_49;
              }
              if (type != OS_LOG_TYPE_FAULT)
              {
                if (v67)
                {
                  unsigned int v64 = v11;
                  os_log_type_t v24 = (char *)__nw_create_backtrace_string();
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  BOOL v25 = gLogObj;
                  os_log_type_t v26 = type;
                  BOOL v27 = os_log_type_enabled((os_log_t)gLogObj, type);
                  if (v24)
                  {
                    if (v27)
                    {
                      int v28 = *((_DWORD *)v69 + 7);
                      *(_DWORD *)int buf = 136447234;
                      os_log_type_t v72 = "copymptcpinfo";
                      __int16 v73 = 1024;
                      *(_DWORD *)os_log_type_t v74 = v28;
                      *(_WORD *)&v74[4] = 1024;
                      *(_DWORD *)&v74[6] = v13;
                      LOWORD(v75) = 1024;
                      *(_DWORD *)((char *)&v75 + 2) = a1;
                      WORD3(v75) = 2082;
                      *((void *)&v75 + 1) = v24;
                      _os_log_impl(&dword_1830D4000, v25, v26, "%{public}s Unknown conninfo type %u for ifindex %u on fd %d, dumping backtrace:%{public}s", buf, 0x28u);
                    }
                    free(v24);
                    unsigned int v11 = v64;
                    goto LABEL_49;
                  }
                  unsigned int v11 = v64;
                  if (!v27) {
                    goto LABEL_49;
                  }
                  int v42 = *((_DWORD *)v69 + 7);
                  *(_DWORD *)int buf = 136446978;
                  os_log_type_t v72 = "copymptcpinfo";
                  __int16 v73 = 1024;
                  *(_DWORD *)os_log_type_t v74 = v42;
                  *(_WORD *)&v74[4] = 1024;
                  *(_DWORD *)&v74[6] = v13;
                  LOWORD(v75) = 1024;
                  *(_DWORD *)((char *)&v75 + 2) = a1;
                  int v21 = v25;
                  os_log_type_t v22 = v26;
                  BOOL v23 = "%{public}s Unknown conninfo type %u for ifindex %u on fd %d, no backtrace";
                }
                else
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  uint64_t v35 = gLogObj;
                  os_log_type_t v36 = type;
                  if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
                    goto LABEL_49;
                  }
                  int v37 = *((_DWORD *)v69 + 7);
                  *(_DWORD *)int buf = 136446978;
                  os_log_type_t v72 = "copymptcpinfo";
                  __int16 v73 = 1024;
                  *(_DWORD *)os_log_type_t v74 = v37;
                  *(_WORD *)&v74[4] = 1024;
                  *(_DWORD *)&v74[6] = v13;
                  LOWORD(v75) = 1024;
                  *(_DWORD *)((char *)&v75 + 2) = a1;
                  int v21 = v35;
                  os_log_type_t v22 = v36;
                  BOOL v23 = "%{public}s Unknown conninfo type %u for ifindex %u on fd %d, backtrace limit exceeded";
                }
LABEL_48:
                _os_log_impl(&dword_1830D4000, v21, v22, v23, buf, 0x1Eu);
                goto LABEL_49;
              }
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v18 = gLogObj;
              os_log_type_t v19 = type;
              if (os_log_type_enabled((os_log_t)gLogObj, type))
              {
                int v20 = *((_DWORD *)v69 + 7);
                *(_DWORD *)int buf = 136446978;
                os_log_type_t v72 = "copymptcpinfo";
                __int16 v73 = 1024;
                *(_DWORD *)os_log_type_t v74 = v20;
                *(_WORD *)&v74[4] = 1024;
                *(_DWORD *)&v74[6] = v13;
                LOWORD(v75) = 1024;
                *(_DWORD *)((char *)&v75 + 2) = a1;
                int v21 = v18;
                os_log_type_t v22 = v19;
                BOOL v23 = "%{public}s Unknown conninfo type %u for ifindex %u on fd %d";
                goto LABEL_48;
              }
LABEL_49:
              if (v17) {
                free(v17);
              }
              Class v43 = v69;
LABEL_60:
              if (v43)
              {
                os_log_type_t v46 = (void *)v43[1];
                if (v46)
                {
                  free(v46);
                  v43[1] = 0;
                }
                BOOL v47 = (void *)v43[2];
                if (v47)
                {
                  free(v47);
                  v43[2] = 0;
                }
                unint64_t v48 = (void *)v43[4];
                if (v48) {
                  free(v48);
                }
                free(v43);
              }
              goto LABEL_20;
            }
            if (!*((void *)v69 + 4))
            {
              unsigned int v65 = v11;
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              *(_DWORD *)int buf = 136446722;
              os_log_type_t v72 = "copymptcpinfo";
              __int16 v73 = 1024;
              *(_DWORD *)os_log_type_t v74 = v13;
              *(_WORD *)&v74[4] = 1024;
              *(_DWORD *)&v74[6] = a1;
              os_log_type_t v29 = (char *)_os_log_send_and_compose_impl();
              os_log_type_t type = OS_LOG_TYPE_ERROR;
              char v67 = 0;
              if (!__nwlog_fault(v29, &type, &v67)) {
                goto LABEL_57;
              }
              if (type == OS_LOG_TYPE_FAULT)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                uint64_t v30 = gLogObj;
                os_log_type_t v31 = type;
                if (os_log_type_enabled((os_log_t)gLogObj, type))
                {
                  *(_DWORD *)int buf = 136446722;
                  os_log_type_t v72 = "copymptcpinfo";
                  __int16 v73 = 1024;
                  *(_DWORD *)os_log_type_t v74 = v13;
                  *(_WORD *)&v74[4] = 1024;
                  *(_DWORD *)&v74[6] = a1;
                  os_log_type_t v32 = v30;
                  os_log_type_t v33 = v31;
                  id v34 = "%{public}s NULL conninfo aux data for ifindex %u on fd %d";
                  goto LABEL_56;
                }
                goto LABEL_57;
              }
              if (v67)
              {
                Class v38 = (char *)__nw_create_backtrace_string();
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                uint64_t v39 = gLogObj;
                os_log_type_t v40 = type;
                BOOL v41 = os_log_type_enabled((os_log_t)gLogObj, type);
                if (v38)
                {
                  if (v41)
                  {
                    *(_DWORD *)int buf = 136446978;
                    os_log_type_t v72 = "copymptcpinfo";
                    __int16 v73 = 1024;
                    *(_DWORD *)os_log_type_t v74 = v13;
                    *(_WORD *)&v74[4] = 1024;
                    *(_DWORD *)&v74[6] = a1;
                    LOWORD(v75) = 2082;
                    *(void *)((char *)&v75 + 2) = v38;
                    _os_log_impl(&dword_1830D4000, v39, v40, "%{public}s NULL conninfo aux data for ifindex %u on fd %d, dumping backtrace:%{public}s", buf, 0x22u);
                  }
                  free(v38);
                  goto LABEL_57;
                }
                if (!v41)
                {
LABEL_57:
                  if (v29) {
                    free(v29);
                  }
                  Class v43 = v69;
                  unsigned int v11 = v65;
                  goto LABEL_60;
                }
                *(_DWORD *)int buf = 136446722;
                os_log_type_t v72 = "copymptcpinfo";
                __int16 v73 = 1024;
                *(_DWORD *)os_log_type_t v74 = v13;
                *(_WORD *)&v74[4] = 1024;
                *(_DWORD *)&v74[6] = a1;
                os_log_type_t v32 = v39;
                os_log_type_t v33 = v40;
                id v34 = "%{public}s NULL conninfo aux data for ifindex %u on fd %d, no backtrace";
              }
              else
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                uint64_t v44 = gLogObj;
                os_log_type_t v45 = type;
                if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
                  goto LABEL_57;
                }
                *(_DWORD *)int buf = 136446722;
                os_log_type_t v72 = "copymptcpinfo";
                __int16 v73 = 1024;
                *(_DWORD *)os_log_type_t v74 = v13;
                *(_WORD *)&v74[4] = 1024;
                *(_DWORD *)&v74[6] = a1;
                os_log_type_t v32 = v44;
                os_log_type_t v33 = v45;
                id v34 = "%{public}s NULL conninfo aux data for ifindex %u on fd %d, backtrace limit exceeded";
              }
LABEL_56:
              _os_log_impl(&dword_1830D4000, v32, v33, v34, buf, 0x18u);
              goto LABEL_57;
            }
            *(void *)(v4[1] + 8 * v11++) = v69;
          }
        }
LABEL_20:
        v12 += 36;
        if (v12 == 164)
        {
          *((_DWORD *)v4 + 4) = v11;
          nw_error_t v2 = v63;
          goto LABEL_4;
        }
      }
    }
    os_log_type_t v61 = __nwlog_obj();
    os_log_type_enabled(v61, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int buf = 136446722;
    os_log_type_t v72 = "strict_calloc";
    __int16 v73 = 2048;
    *(void *)os_log_type_t v74 = v9;
    *(_WORD *)&v74[8] = 2048;
    *(void *)&long long v75 = 8;
    os_log_type_t v62 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort((uint64_t)v62);
    if (!result)
    {
      free(v62);
      goto LABEL_17;
    }
    goto LABEL_98;
  }
LABEL_4:
  uint64_t result = 0;
  void *v2 = v4;
  return result;
}

uint64_t __nw_quic_connection_close_with_error_block_invoke(uint64_t a1, uint64_t a2)
{
  xpc_object_t v4 = (os_unfair_lock_s *)(a2 + 208);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 208));
  uint64_t v5 = *(void *)(a2 + 144);
  if (v5) {
    (*(void (**)(uint64_t, void))(v5 + 16))(v5, *(void *)(a1 + 32));
  }
  os_unfair_lock_unlock(v4);
  return 1;
}

uint64_t __nw_protocol_plugin_metadata_process_frames_block_invoke(uint64_t a1, _DWORD *a2)
{
  uint64_t v297 = *MEMORY[0x1E4F143B8];
  v290 = a2;
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
    v257 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v288 = 0;
    if (!__nwlog_fault(v257, &type, &v288)) {
      goto LABEL_364;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v258 = __nwlog_obj();
      os_log_type_t v259 = type;
      if (!os_log_type_enabled(v258, type)) {
        goto LABEL_364;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
      v260 = "%{public}s called with null frame";
    }
    else if (v288)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v258 = __nwlog_obj();
      os_log_type_t v259 = type;
      BOOL v263 = os_log_type_enabled(v258, type);
      if (backtrace_string)
      {
        if (v263)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v258, v259, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_364;
      }
      if (!v263)
      {
LABEL_364:
        if (v257) {
          free(v257);
        }
        return 0;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
      v260 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      os_log_type_t v258 = __nwlog_obj();
      os_log_type_t v259 = type;
      if (!os_log_type_enabled(v258, type)) {
        goto LABEL_364;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
      v260 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v258, v259, v260, buf, 0xCu);
    goto LABEL_364;
  }
  if (!**(_DWORD **)(a1 + 40))
  {
    if (!gLogDatapath) {
      return 0;
    }
    uint64_t v264 = __nwlog_obj();
    if (!os_log_type_enabled(v264, OS_LOG_TYPE_DEBUG)) {
      return 0;
    }
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
    Class v43 = "%{public}s stopping after reaching maximum frame count";
    uint64_t v44 = v264;
    uint32_t v45 = 12;
    goto LABEL_344;
  }
  id v3 = a2;
  if (gLogDatapath)
  {
    os_log_type_t v261 = __nwlog_obj();
    if (os_log_type_enabled(v261, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = v3;
      _os_log_impl(&dword_1830D4000, v261, OS_LOG_TYPE_DEBUG, "%{public}s processing frame %p", buf, 0x16u);
      id v3 = v290;
    }
  }
  xpc_object_t v4 = nw_frame_copy_metadata_for_protocol((uint64_t)v3, *(void *)(*(void *)(a1 + 48) + 80));
  if (v4)
  {
    uint64_t v5 = v4;
    int v6 = *(unsigned __int8 *)(a1 + 120);
    uint64_t v7 = *(void *)(a1 + 48);
    uint64_t v8 = 48;
    if (!*(unsigned char *)(a1 + 120)) {
      uint64_t v8 = 64;
    }
    if (*(void **)(v7 + v8) == v4 || (*(unsigned char *)(v7 + 142) & 1) == 0)
    {
      BOOL v9 = v6 == 0;
      uint64_t v10 = 140;
      if (v9) {
        uint64_t v10 = 141;
      }
      BOOL v11 = 0;
      switch(*(unsigned char *)(v7 + v10))
      {
        case 0:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          uint64_t v12 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v288 = 0;
          if (!__nwlog_fault(v12, &type, &v288)) {
            goto LABEL_128;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            int v13 = gLogObj;
            os_log_type_t v14 = type;
            if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
              goto LABEL_128;
            }
            *(_DWORD *)int buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            os_log_type_t v15 = "%{public}s current metadata processor result must not be unknown";
LABEL_127:
            _os_log_impl(&dword_1830D4000, v13, v14, v15, buf, 0xCu);
            goto LABEL_128;
          }
          if (!v288)
          {
            int v13 = __nwlog_obj();
            os_log_type_t v14 = type;
            if (!os_log_type_enabled(v13, type)) {
              goto LABEL_128;
            }
            *(_DWORD *)int buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            os_log_type_t v15 = "%{public}s current metadata processor result must not be unknown, backtrace limit exceeded";
            goto LABEL_127;
          }
          BOOL v82 = (char *)__nw_create_backtrace_string();
          int v13 = __nwlog_obj();
          os_log_type_t v14 = type;
          BOOL v83 = os_log_type_enabled(v13, type);
          if (!v82)
          {
            if (!v83) {
              goto LABEL_128;
            }
            *(_DWORD *)int buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            os_log_type_t v15 = "%{public}s current metadata processor result must not be unknown, no backtrace";
            goto LABEL_127;
          }
          if (v83)
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v82;
            _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s current metadata processor result must not be unknown, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v82);
LABEL_128:
          if (v12) {
            free(v12);
          }
LABEL_281:
          BOOL v11 = 1;
          break;
        case 1:
          unsigned int v28 = nw_frame_unclaimed_length(v290);
          if (v28 > **(_DWORD **)(a1 + 56))
          {
            if (!*(unsigned char *)(a1 + 120))
            {
              if (gLogDatapath)
              {
                BOOL v91 = __nwlog_obj();
                if (os_log_type_enabled(v91, OS_LOG_TYPE_DEBUG))
                {
                  int v92 = **(_DWORD **)(a1 + 56);
                  *(_DWORD *)int buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                  *(_WORD *)&unsigned char buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v28;
                  *(_WORD *)&buf[18] = 1024;
                  *(_DWORD *)&buf[20] = v92;
                  _os_log_impl(&dword_1830D4000, v91, OS_LOG_TYPE_DEBUG, "%{public}s not delivering frame with length %u maximum bytes %u", buf, 0x18u);
                }
              }
              goto LABEL_313;
            }
            if (gLogDatapath)
            {
              uint64_t v282 = __nwlog_obj();
              if (os_log_type_enabled(v282, OS_LOG_TYPE_DEBUG))
              {
                int v283 = **(_DWORD **)(a1 + 56);
                *(_DWORD *)int buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                *(_WORD *)&unsigned char buf[12] = 2048;
                *(void *)&buf[14] = v290;
                *(_WORD *)&unsigned char buf[22] = 1024;
                LODWORD(v292) = v283;
                _os_log_impl(&dword_1830D4000, v282, OS_LOG_TYPE_DEBUG, "%{public}s splitting frame %p that is part of handled message by offset %d", buf, 0x1Cu);
              }
            }
            os_log_type_t v29 = v290;
            uint64_t v30 = v290 + 8;
            uint64_t v31 = *((void *)v290 + 4);
            os_log_type_t v32 = (void *)*((void *)v290 + 5);
            if (v31)
            {
              *(void *)(v31 + 40) = v32;
              os_log_type_t v32 = (void *)*((void *)v29 + 5);
            }
            else
            {
              *(void *)(*(void *)(a1 + 64) + 8) = v32;
            }
            void *v32 = v31;
            void *v30 = 0;
            v30[1] = 0;
            uint64_t v108 = nw_frame_split((uint64_t *)&v290, **(_DWORD **)(a1 + 56));
            size_t v109 = *(uint64_t **)(a1 + 64);
            uint64_t v110 = v290;
            uint64_t v111 = *v109;
            os_log_type_t v112 = v290;
            *((void *)v290 + 4) = *v109;
            unint64_t v113 = v112 + 8;
            if (v111) {
              os_log_type_t v114 = (void *)(v111 + 40);
            }
            else {
              os_log_type_t v114 = v109 + 1;
            }
            *os_log_type_t v114 = v113;
            uint64_t *v109 = (uint64_t)v110;
            *((void *)v110 + 5) = v109;
            uint64_t v115 = *(void *)(a1 + 72);
            *(void *)(v108 + 32) = 0;
            os_log_type_t v116 = *(uint64_t **)(v115 + 8);
            *(void *)(v108 + 40) = v116;
            *os_log_type_t v116 = v108;
            *(void *)(v115 + 8) = v108 + 32;
            **(_DWORD **)(a1 + 80) = 0;
            **(_DWORD **)(a1 + 56) = 0;
            uint64_t v117 = *(_DWORD **)(a1 + 40);
            if ((*v117)--)
            {
LABEL_292:
              os_log_type_t v225 = *(_DWORD **)(a1 + 88);
              int v226 = **(_DWORD **)(a1 + 56);
              BOOL v51 = __CFADD__(*v225, v226);
              *v225 += v226;
              if (!v51) {
                goto LABEL_311;
              }
              __nwlog_obj();
              uint64_t v227 = **(unsigned int **)(a1 + 56);
              int v228 = (_DWORD *)**(unsigned int **)(a1 + 88);
              *(_DWORD *)int buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = "moved_bytes";
              *(_WORD *)&unsigned char buf[22] = 2048;
              uint64_t v292 = v227;
              __int16 v293 = 2048;
              BOOL v294 = v228;
              uint64_t v229 = (char *)_os_log_send_and_compose_impl();
              os_log_type_t type = OS_LOG_TYPE_ERROR;
              char v288 = 0;
              if (__nwlog_fault(v229, &type, &v288))
              {
                if (type == OS_LOG_TYPE_FAULT)
                {
                  int v230 = __nwlog_obj();
                  os_log_type_t v231 = type;
                  if (os_log_type_enabled(v230, type))
                  {
                    uint64_t v232 = **(unsigned int **)(a1 + 56);
                    v233 = (_DWORD *)**(unsigned int **)(a1 + 88);
                    *(_DWORD *)int buf = 136446978;
                    *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                    *(_WORD *)&unsigned char buf[12] = 2082;
                    *(void *)&buf[14] = "moved_bytes";
                    *(_WORD *)&unsigned char buf[22] = 2048;
                    uint64_t v292 = v232;
                    __int16 v293 = 2048;
                    BOOL v294 = v233;
                    os_log_type_t v234 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_307:
                    _os_log_impl(&dword_1830D4000, v230, v231, v234, buf, 0x2Au);
                  }
                }
                else if (v288)
                {
                  v235 = (char *)__nw_create_backtrace_string();
                  int v230 = __nwlog_obj();
                  os_log_type_t v231 = type;
                  BOOL v236 = os_log_type_enabled(v230, type);
                  if (v235)
                  {
                    if (v236)
                    {
                      uint64_t v237 = **(unsigned int **)(a1 + 56);
                      v238 = (_DWORD *)**(unsigned int **)(a1 + 88);
                      *(_DWORD *)int buf = 136447234;
                      *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                      *(_WORD *)&unsigned char buf[12] = 2082;
                      *(void *)&buf[14] = "moved_bytes";
                      *(_WORD *)&unsigned char buf[22] = 2048;
                      uint64_t v292 = v237;
                      __int16 v293 = 2048;
                      BOOL v294 = v238;
                      __int16 v295 = 2082;
                      uint64_t v296 = v235;
                      _os_log_impl(&dword_1830D4000, v230, v231, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
                    }
                    free(v235);
                    goto LABEL_308;
                  }
                  if (v236)
                  {
                    uint64_t v241 = **(unsigned int **)(a1 + 56);
                    os_log_type_t v242 = (_DWORD *)**(unsigned int **)(a1 + 88);
                    *(_DWORD *)int buf = 136446978;
                    *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                    *(_WORD *)&unsigned char buf[12] = 2082;
                    *(void *)&buf[14] = "moved_bytes";
                    *(_WORD *)&unsigned char buf[22] = 2048;
                    uint64_t v292 = v241;
                    __int16 v293 = 2048;
                    BOOL v294 = v242;
                    os_log_type_t v234 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
                    goto LABEL_307;
                  }
                }
                else
                {
                  int v230 = __nwlog_obj();
                  os_log_type_t v231 = type;
                  if (os_log_type_enabled(v230, type))
                  {
                    uint64_t v239 = **(unsigned int **)(a1 + 56);
                    os_log_type_t v240 = (_DWORD *)**(unsigned int **)(a1 + 88);
                    *(_DWORD *)int buf = 136446978;
                    *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                    *(_WORD *)&unsigned char buf[12] = 2082;
                    *(void *)&buf[14] = "moved_bytes";
                    *(_WORD *)&unsigned char buf[22] = 2048;
                    uint64_t v292 = v239;
                    __int16 v293 = 2048;
                    BOOL v294 = v240;
                    os_log_type_t v234 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
                    goto LABEL_307;
                  }
                }
              }
LABEL_308:
              if (v229) {
                free(v229);
              }
              **(_DWORD **)(a1 + 88) = -1;
LABEL_311:
              uint64_t v243 = *(void *)(*(void *)(a1 + 32) + 8);
              uint64_t v244 = *(unsigned int *)(v243 + 24) + 1;
              uint64_t v245 = v244 << 31 >> 31;
              *(_DWORD *)(v243 + 24) = v244;
              if (v245 == v244 && (v245 & 0x8000000000000000) == 0)
              {
LABEL_313:
                BOOL v11 = 0;
                break;
              }
              __nwlog_obj();
              os_log_type_t v246 = (_DWORD *)*(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
              *(_DWORD *)int buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = "count";
              *(_WORD *)&unsigned char buf[22] = 2048;
              uint64_t v292 = 1;
              __int16 v293 = 2048;
              BOOL v294 = v246;
              BOOL v247 = (char *)_os_log_send_and_compose_impl();
              os_log_type_t type = OS_LOG_TYPE_ERROR;
              char v288 = 0;
              if (!__nwlog_fault(v247, &type, &v288)) {
                goto LABEL_328;
              }
              if (type == OS_LOG_TYPE_FAULT)
              {
                v248 = __nwlog_obj();
                os_log_type_t v249 = type;
                if (os_log_type_enabled(v248, type))
                {
                  os_log_type_t v250 = (_DWORD *)*(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
                  *(_DWORD *)int buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                  *(_WORD *)&unsigned char buf[12] = 2082;
                  *(void *)&buf[14] = "count";
                  *(_WORD *)&unsigned char buf[22] = 2048;
                  uint64_t v292 = 1;
                  __int16 v293 = 2048;
                  BOOL v294 = v250;
                  BOOL v251 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_327:
                  _os_log_impl(&dword_1830D4000, v248, v249, v251, buf, 0x2Au);
                }
              }
              else if (v288)
              {
                v252 = (char *)__nw_create_backtrace_string();
                v248 = __nwlog_obj();
                os_log_type_t v249 = type;
                BOOL v253 = os_log_type_enabled(v248, type);
                if (v252)
                {
                  if (v253)
                  {
                    os_log_type_t v254 = (_DWORD *)*(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
                    *(_DWORD *)int buf = 136447234;
                    *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                    *(_WORD *)&unsigned char buf[12] = 2082;
                    *(void *)&buf[14] = "count";
                    *(_WORD *)&unsigned char buf[22] = 2048;
                    uint64_t v292 = 1;
                    __int16 v293 = 2048;
                    BOOL v294 = v254;
                    __int16 v295 = 2082;
                    uint64_t v296 = v252;
                    _os_log_impl(&dword_1830D4000, v248, v249, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
                  }
                  free(v252);
                  goto LABEL_328;
                }
                if (v253)
                {
                  uint64_t v256 = (_DWORD *)*(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
                  *(_DWORD *)int buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                  *(_WORD *)&unsigned char buf[12] = 2082;
                  *(void *)&buf[14] = "count";
                  *(_WORD *)&unsigned char buf[22] = 2048;
                  uint64_t v292 = 1;
                  __int16 v293 = 2048;
                  BOOL v294 = v256;
                  BOOL v251 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
                  goto LABEL_327;
                }
              }
              else
              {
                v248 = __nwlog_obj();
                os_log_type_t v249 = type;
                if (os_log_type_enabled(v248, type))
                {
                  BOOL v255 = (_DWORD *)*(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
                  *(_DWORD *)int buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                  *(_WORD *)&unsigned char buf[12] = 2082;
                  *(void *)&buf[14] = "count";
                  *(_WORD *)&unsigned char buf[22] = 2048;
                  uint64_t v292 = 1;
                  __int16 v293 = 2048;
                  BOOL v294 = v255;
                  BOOL v251 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
                  goto LABEL_327;
                }
              }
LABEL_328:
              if (v247) {
                free(v247);
              }
              BOOL v11 = 0;
              *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = -1;
              break;
            }
            __nwlog_obj();
            int v119 = (_DWORD *)**(unsigned int **)(a1 + 40);
            *(_DWORD *)int buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = "maximum_frame_count";
            *(_WORD *)&unsigned char buf[22] = 2048;
            uint64_t v292 = 1;
            __int16 v293 = 2048;
            BOOL v294 = v119;
            os_log_type_t v120 = (char *)_os_log_send_and_compose_impl();
            os_log_type_t type = OS_LOG_TYPE_ERROR;
            char v288 = 0;
            if (__nwlog_fault(v120, &type, &v288))
            {
              if (type == OS_LOG_TYPE_FAULT)
              {
                int v121 = __nwlog_obj();
                os_log_type_t v122 = type;
                if (os_log_type_enabled(v121, type))
                {
                  char v123 = (_DWORD *)**(unsigned int **)(a1 + 40);
                  *(_DWORD *)int buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                  *(_WORD *)&unsigned char buf[12] = 2082;
                  *(void *)&buf[14] = "maximum_frame_count";
                  *(_WORD *)&unsigned char buf[22] = 2048;
                  uint64_t v292 = 1;
                  __int16 v293 = 2048;
                  BOOL v294 = v123;
                  BOOL v124 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_288:
                  _os_log_impl(&dword_1830D4000, v121, v122, v124, buf, 0x2Au);
                }
              }
              else if (v288)
              {
                BOOL v190 = (char *)__nw_create_backtrace_string();
                int v121 = __nwlog_obj();
                os_log_type_t v122 = type;
                BOOL v191 = os_log_type_enabled(v121, type);
                if (v190)
                {
                  if (v191)
                  {
                    os_log_type_t v192 = (_DWORD *)**(unsigned int **)(a1 + 40);
                    *(_DWORD *)int buf = 136447234;
                    *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                    *(_WORD *)&unsigned char buf[12] = 2082;
                    *(void *)&buf[14] = "maximum_frame_count";
                    *(_WORD *)&unsigned char buf[22] = 2048;
                    uint64_t v292 = 1;
                    __int16 v293 = 2048;
                    BOOL v294 = v192;
                    __int16 v295 = 2082;
                    uint64_t v296 = v190;
                    _os_log_impl(&dword_1830D4000, v121, v122, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
                  }
                  free(v190);
                  goto LABEL_289;
                }
                if (v191)
                {
                  v224 = (_DWORD *)**(unsigned int **)(a1 + 40);
                  *(_DWORD *)int buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                  *(_WORD *)&unsigned char buf[12] = 2082;
                  *(void *)&buf[14] = "maximum_frame_count";
                  *(_WORD *)&unsigned char buf[22] = 2048;
                  uint64_t v292 = 1;
                  __int16 v293 = 2048;
                  BOOL v294 = v224;
                  BOOL v124 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
                  goto LABEL_288;
                }
              }
              else
              {
                int v121 = __nwlog_obj();
                os_log_type_t v122 = type;
                if (os_log_type_enabled(v121, type))
                {
                  v223 = (_DWORD *)**(unsigned int **)(a1 + 40);
                  *(_DWORD *)int buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                  *(_WORD *)&unsigned char buf[12] = 2082;
                  *(void *)&buf[14] = "maximum_frame_count";
                  *(_WORD *)&unsigned char buf[22] = 2048;
                  uint64_t v292 = 1;
                  __int16 v293 = 2048;
                  BOOL v294 = v223;
                  BOOL v124 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
                  goto LABEL_288;
                }
              }
            }
LABEL_289:
            if (v120) {
              free(v120);
            }
            **(_DWORD **)(a1 + 40) = 0;
            goto LABEL_292;
          }
          if (gLogDatapath)
          {
            int v281 = __nwlog_obj();
            if (os_log_type_enabled(v281, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)int buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              *(_WORD *)&unsigned char buf[12] = 2048;
              *(void *)&buf[14] = v290;
              _os_log_impl(&dword_1830D4000, v281, OS_LOG_TYPE_DEBUG, "%{public}s delivering frame %p that is part of handled message", buf, 0x16u);
            }
          }
          unint64_t v78 = v290;
          os_log_type_t v79 = v290 + 8;
          uint64_t v80 = *((void *)v290 + 4);
          os_log_type_t v81 = (void *)*((void *)v290 + 5);
          if (v80)
          {
            *(void *)(v80 + 40) = v81;
            os_log_type_t v81 = (void *)*((void *)v78 + 5);
          }
          else
          {
            *(void *)(*(void *)(a1 + 64) + 8) = v81;
          }
          void *v81 = v80;
          *os_log_type_t v79 = 0;
          v79[1] = 0;
          uint64_t v93 = *(void *)(a1 + 72);
          BOOL v94 = v290;
          os_log_type_t v95 = v290;
          *((void *)v290 + 4) = 0;
          os_log_type_t v96 = *(void **)(v93 + 8);
          *((void *)v94 + 5) = v96;
          *os_log_type_t v96 = v94;
          *(void *)(v93 + 8) = v95 + 8;
          os_log_type_t v97 = *(unsigned int **)(a1 + 80);
          BOOL v51 = *v97 >= v28;
          *v97 -= v28;
          if (!v51)
          {
            if (gLogDatapath)
            {
              uint64_t v284 = __nwlog_obj();
              if (os_log_type_enabled(v284, OS_LOG_TYPE_DEBUG))
              {
                os_log_type_t v285 = (_DWORD *)**(unsigned int **)(a1 + 80);
                *(_DWORD *)int buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                *(_WORD *)&unsigned char buf[12] = 2082;
                *(void *)&buf[14] = "minimum_bytes";
                *(_WORD *)&unsigned char buf[22] = 2048;
                uint64_t v292 = v28;
                __int16 v293 = 2048;
                BOOL v294 = v285;
                _os_log_impl(&dword_1830D4000, v284, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
              }
            }
            **(_DWORD **)(a1 + 80) = 0;
          }
          char v98 = *(unsigned int **)(a1 + 56);
          BOOL v51 = *v98 >= v28;
          *v98 -= v28;
          if (!v51)
          {
            if (gLogDatapath)
            {
              v286 = __nwlog_obj();
              if (os_log_type_enabled(v286, OS_LOG_TYPE_DEBUG))
              {
                os_log_type_t v287 = (_DWORD *)**(unsigned int **)(a1 + 56);
                *(_DWORD *)int buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                *(_WORD *)&unsigned char buf[12] = 2082;
                *(void *)&buf[14] = "maximum_bytes";
                *(_WORD *)&unsigned char buf[22] = 2048;
                uint64_t v292 = v28;
                __int16 v293 = 2048;
                BOOL v294 = v287;
                _os_log_impl(&dword_1830D4000, v286, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
              }
            }
            **(_DWORD **)(a1 + 56) = 0;
          }
          long long v99 = *(_DWORD **)(a1 + 40);
          if ((*v99)--) {
            goto LABEL_241;
          }
          __nwlog_obj();
          long long v101 = (_DWORD *)**(unsigned int **)(a1 + 40);
          *(_DWORD *)int buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = "maximum_frame_count";
          *(_WORD *)&unsigned char buf[22] = 2048;
          uint64_t v292 = 1;
          __int16 v293 = 2048;
          BOOL v294 = v101;
          __int16 v102 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v288 = 0;
          if (!__nwlog_fault(v102, &type, &v288)) {
            goto LABEL_238;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            long long v103 = __nwlog_obj();
            os_log_type_t v104 = type;
            if (!os_log_type_enabled(v103, type)) {
              goto LABEL_238;
            }
            os_log_type_t v105 = (_DWORD *)**(unsigned int **)(a1 + 40);
            *(_DWORD *)int buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = "maximum_frame_count";
            *(_WORD *)&unsigned char buf[22] = 2048;
            uint64_t v292 = 1;
            __int16 v293 = 2048;
            BOOL v294 = v105;
            uint64_t v106 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_237:
            _os_log_impl(&dword_1830D4000, v103, v104, v106, buf, 0x2Au);
            goto LABEL_238;
          }
          if (!v288)
          {
            long long v103 = __nwlog_obj();
            os_log_type_t v104 = type;
            if (!os_log_type_enabled(v103, type)) {
              goto LABEL_238;
            }
            id v193 = (_DWORD *)**(unsigned int **)(a1 + 40);
            *(_DWORD *)int buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = "maximum_frame_count";
            *(_WORD *)&unsigned char buf[22] = 2048;
            uint64_t v292 = 1;
            __int16 v293 = 2048;
            BOOL v294 = v193;
            uint64_t v106 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
            goto LABEL_237;
          }
          uint64_t v154 = (char *)__nw_create_backtrace_string();
          long long v103 = __nwlog_obj();
          os_log_type_t v104 = type;
          BOOL v155 = os_log_type_enabled(v103, type);
          if (!v154)
          {
            if (!v155) {
              goto LABEL_238;
            }
            v194 = (_DWORD *)**(unsigned int **)(a1 + 40);
            *(_DWORD *)int buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = "maximum_frame_count";
            *(_WORD *)&unsigned char buf[22] = 2048;
            uint64_t v292 = 1;
            __int16 v293 = 2048;
            BOOL v294 = v194;
            uint64_t v106 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
            goto LABEL_237;
          }
          if (v155)
          {
            uint64_t v156 = (_DWORD *)**(unsigned int **)(a1 + 40);
            *(_DWORD *)int buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = "maximum_frame_count";
            *(_WORD *)&unsigned char buf[22] = 2048;
            uint64_t v292 = 1;
            __int16 v293 = 2048;
            BOOL v294 = v156;
            __int16 v295 = 2082;
            uint64_t v296 = v154;
            _os_log_impl(&dword_1830D4000, v103, v104, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v154);
LABEL_238:
          if (v102) {
            free(v102);
          }
          **(_DWORD **)(a1 + 40) = 0;
LABEL_241:
          uint64_t v195 = *(_DWORD **)(a1 + 88);
          BOOL v51 = __CFADD__(*v195, v28);
          *v195 += v28;
          if (!v51) {
            goto LABEL_260;
          }
          __nwlog_obj();
          uint64_t v196 = v28;
          int v197 = (_DWORD *)**(unsigned int **)(a1 + 88);
          *(_DWORD *)int buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = "moved_bytes";
          *(_WORD *)&unsigned char buf[22] = 2048;
          uint64_t v292 = v28;
          __int16 v293 = 2048;
          BOOL v294 = v197;
          v198 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v288 = 0;
          if (!__nwlog_fault(v198, &type, &v288)) {
            goto LABEL_257;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            v199 = __nwlog_obj();
            os_log_type_t v200 = type;
            if (!os_log_type_enabled(v199, type)) {
              goto LABEL_257;
            }
            nw_protocol_options_t v201 = (_DWORD *)**(unsigned int **)(a1 + 88);
            *(_DWORD *)int buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = "moved_bytes";
            *(_WORD *)&unsigned char buf[22] = 2048;
            uint64_t v292 = v196;
            __int16 v293 = 2048;
            BOOL v294 = v201;
            nw_protocol_options_t v202 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_256:
            _os_log_impl(&dword_1830D4000, v199, v200, v202, buf, 0x2Au);
            goto LABEL_257;
          }
          if (!v288)
          {
            v199 = __nwlog_obj();
            os_log_type_t v200 = type;
            if (!os_log_type_enabled(v199, type)) {
              goto LABEL_257;
            }
            char v206 = (_DWORD *)**(unsigned int **)(a1 + 88);
            *(_DWORD *)int buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = "moved_bytes";
            *(_WORD *)&unsigned char buf[22] = 2048;
            uint64_t v292 = v196;
            __int16 v293 = 2048;
            BOOL v294 = v206;
            nw_protocol_options_t v202 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
            goto LABEL_256;
          }
          nw_protocol_definition_t v203 = (char *)__nw_create_backtrace_string();
          v199 = __nwlog_obj();
          os_log_type_t v200 = type;
          BOOL v204 = os_log_type_enabled(v199, type);
          if (!v203)
          {
            if (!v204) {
              goto LABEL_257;
            }
            uint64_t v207 = (_DWORD *)**(unsigned int **)(a1 + 88);
            *(_DWORD *)int buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = "moved_bytes";
            *(_WORD *)&unsigned char buf[22] = 2048;
            uint64_t v292 = v196;
            __int16 v293 = 2048;
            BOOL v294 = v207;
            nw_protocol_options_t v202 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
            goto LABEL_256;
          }
          if (v204)
          {
            uint64_t v205 = (_DWORD *)**(unsigned int **)(a1 + 88);
            *(_DWORD *)int buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = "moved_bytes";
            *(_WORD *)&unsigned char buf[22] = 2048;
            uint64_t v292 = v196;
            __int16 v293 = 2048;
            BOOL v294 = v205;
            __int16 v295 = 2082;
            uint64_t v296 = v203;
            _os_log_impl(&dword_1830D4000, v199, v200, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v203);
LABEL_257:
          if (v198) {
            free(v198);
          }
          **(_DWORD **)(a1 + 88) = -1;
LABEL_260:
          uint64_t v208 = *(void *)(*(void *)(a1 + 32) + 8);
          uint64_t v209 = *(unsigned int *)(v208 + 24) + 1;
          uint64_t v210 = v209 << 31 >> 31;
          *(_DWORD *)(v208 + 24) = v209;
          if (v210 == v209 && (v210 & 0x8000000000000000) == 0) {
            goto LABEL_279;
          }
          __nwlog_obj();
          int v211 = (_DWORD *)*(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
          *(_DWORD *)int buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = "count";
          *(_WORD *)&unsigned char buf[22] = 2048;
          uint64_t v292 = 1;
          __int16 v293 = 2048;
          BOOL v294 = v211;
          v212 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v288 = 0;
          if (!__nwlog_fault(v212, &type, &v288)) {
            goto LABEL_276;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            uint64_t v213 = __nwlog_obj();
            os_log_type_t v214 = type;
            if (!os_log_type_enabled(v213, type)) {
              goto LABEL_276;
            }
            int v215 = (_DWORD *)*(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
            *(_DWORD *)int buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = "count";
            *(_WORD *)&unsigned char buf[22] = 2048;
            uint64_t v292 = 1;
            __int16 v293 = 2048;
            BOOL v294 = v215;
            uint64_t v216 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_275:
            _os_log_impl(&dword_1830D4000, v213, v214, v216, buf, 0x2Au);
            goto LABEL_276;
          }
          if (!v288)
          {
            uint64_t v213 = __nwlog_obj();
            os_log_type_t v214 = type;
            if (!os_log_type_enabled(v213, type)) {
              goto LABEL_276;
            }
            uint64_t v220 = (_DWORD *)*(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
            *(_DWORD *)int buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = "count";
            *(_WORD *)&unsigned char buf[22] = 2048;
            uint64_t v292 = 1;
            __int16 v293 = 2048;
            BOOL v294 = v220;
            uint64_t v216 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
            goto LABEL_275;
          }
          int v217 = (char *)__nw_create_backtrace_string();
          uint64_t v213 = __nwlog_obj();
          os_log_type_t v214 = type;
          BOOL v218 = os_log_type_enabled(v213, type);
          if (!v217)
          {
            if (!v218) {
              goto LABEL_276;
            }
            int v221 = (_DWORD *)*(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
            *(_DWORD *)int buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = "count";
            *(_WORD *)&unsigned char buf[22] = 2048;
            uint64_t v292 = 1;
            __int16 v293 = 2048;
            BOOL v294 = v221;
            uint64_t v216 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
            goto LABEL_275;
          }
          if (v218)
          {
            v219 = (_DWORD *)*(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
            *(_DWORD *)int buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = "count";
            *(_WORD *)&unsigned char buf[22] = 2048;
            uint64_t v292 = 1;
            __int16 v293 = 2048;
            BOOL v294 = v219;
            __int16 v295 = 2082;
            uint64_t v296 = v217;
            _os_log_impl(&dword_1830D4000, v213, v214, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v217);
LABEL_276:
          if (v212) {
            free(v212);
          }
          *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = -1;
LABEL_279:
          if (!nw_frame_is_metadata_complete((uint64_t)v290)) {
            goto LABEL_281;
          }
          **(_DWORD **)(a1 + 80) = 0;
          BOOL v11 = 1;
          break;
        case 2:
          break;
        case 3:
          int is_metadata_complete = nw_frame_is_metadata_complete((uint64_t)v290);
          if (gLogDatapath)
          {
            v280 = __nwlog_obj();
            if (os_log_type_enabled(v280, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)int buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              *(_WORD *)&unsigned char buf[12] = 2048;
              *(void *)&buf[14] = v290;
              _os_log_impl(&dword_1830D4000, v280, OS_LOG_TYPE_DEBUG, "%{public}s discarding frame %p that is part of handled message", buf, 0x16u);
            }
          }
          id v34 = v290;
          uint64_t v35 = v290 + 8;
          uint64_t v36 = *((void *)v290 + 4);
          int v37 = (void *)*((void *)v290 + 5);
          if (v36)
          {
            *(void *)(v36 + 40) = v37;
            int v37 = (void *)*((void *)v34 + 5);
          }
          else
          {
            *(void *)(*(void *)(a1 + 64) + 8) = v37;
          }
          void *v37 = v36;
          *uint64_t v35 = 0;
          v35[1] = 0;
          nw_frame_finalize((uint64_t)v290);
          if (is_metadata_complete)
          {
            os_log_type_t v87 = *(void (**)(void))(*(void *)(a1 + 48) + 120);
            if (v87) {
              v87(*(void *)(a1 + 96));
            }
          }
          goto LABEL_281;
        default:
          goto LABEL_45;
      }
LABEL_282:
      os_release(v5);
      return v11;
    }
    if (gLogDatapath)
    {
      v270 = __nwlog_obj();
      BOOL v271 = os_log_type_enabled(v270, OS_LOG_TYPE_DEBUG);
      int v6 = *(unsigned __int8 *)(a1 + 120);
      if (v271)
      {
        *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
        *(_DWORD *)int buf = 136446722;
        if (v6) {
          v272 = "input";
        }
        else {
          v272 = "output";
        }
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v290;
        *(_WORD *)&unsigned char buf[22] = 2080;
        uint64_t v292 = (uint64_t)v272;
        _os_log_impl(&dword_1830D4000, v270, OS_LOG_TYPE_DEBUG, "%{public}s frame %p begins a %s new message", buf, 0x20u);
        int v6 = *(unsigned __int8 *)(a1 + 120);
      }
    }
    uint64_t v21 = *(void *)(a1 + 48);
    if (v6)
    {
      char v22 = *(unsigned char *)(v21 + 56);
      if (v22)
      {
        BOOL v23 = *(void **)(v21 + 48);
        if (v23)
        {
          os_release(v23);
          char v22 = *(unsigned char *)(v21 + 56);
        }
      }
      *(void *)(v21 + 48) = v5;
      *(unsigned char *)(v21 + 56) = v22 | 1;
      *(unsigned char *)(*(void *)(a1 + 48) + 140) = 0;
    }
    else
    {
      char v38 = *(unsigned char *)(v21 + 72);
      if (v38)
      {
        uint64_t v39 = *(void **)(v21 + 64);
        if (v39)
        {
          os_release(v39);
          char v38 = *(unsigned char *)(v21 + 72);
        }
      }
      *(void *)(v21 + 64) = v5;
      *(unsigned char *)(v21 + 72) = v38 | 1;
      *(unsigned char *)(*(void *)(a1 + 48) + 141) = 0;
    }
    uint64_t v5 = 0;
LABEL_45:
    if (nw_frame_unclaimed_length(v290))
    {
      int v40 = 0;
      if (!gLogDatapath) {
        goto LABEL_49;
      }
    }
    else
    {
      int v40 = nw_frame_is_metadata_complete((uint64_t)v290);
      if (!gLogDatapath) {
        goto LABEL_49;
      }
    }
    uint64_t v265 = __nwlog_obj();
    if (os_log_type_enabled(v265, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v266 = *(void *)(a1 + 96);
      uint64_t v267 = "invalid";
      if (v266)
      {
        v268 = *(const char **)(v266 + 16);
        if (v268) {
          uint64_t v267 = v268;
        }
      }
      uint64_t v269 = "input";
      if (!*(unsigned char *)(a1 + 120)) {
        uint64_t v269 = "output";
      }
      *(_DWORD *)int buf = 136447234;
      *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v267;
      *(_WORD *)&unsigned char buf[22] = 2080;
      uint64_t v292 = (uint64_t)v269;
      __int16 v293 = 2048;
      BOOL v294 = v290;
      __int16 v295 = 1024;
      LODWORD(v296) = v40;
      _os_log_impl(&dword_1830D4000, v265, OS_LOG_TYPE_DEBUG, "%{public}s calling %s processor with %s frame %p metadata_only %{BOOL}d", buf, 0x30u);
    }
LABEL_49:
    *(void *)int buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2000000000;
    LOBYTE(v292) = 1;
    (*(void (**)(void))(a1 + 104))();
    BOOL v11 = *(unsigned char *)(*(void *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    if (!v5) {
      return v11;
    }
    goto LABEL_282;
  }
  unsigned int v16 = nw_frame_unclaimed_length(v290);
  if (v16 > **(_DWORD **)(a1 + 56))
  {
    if (*(unsigned char *)(a1 + 120))
    {
      if (gLogDatapath)
      {
        v274 = __nwlog_obj();
        if (os_log_type_enabled(v274, OS_LOG_TYPE_DEBUG))
        {
          int v275 = **(_DWORD **)(a1 + 56);
          *(_DWORD *)int buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v290;
          *(_WORD *)&unsigned char buf[22] = 1024;
          LODWORD(v292) = v275;
          _os_log_impl(&dword_1830D4000, v274, OS_LOG_TYPE_DEBUG, "%{public}s splitting frame %p with unknown metadata by offset %d", buf, 0x1Cu);
        }
      }
      os_log_type_t v17 = v290;
      uint64_t v18 = v290 + 8;
      uint64_t v19 = *((void *)v290 + 4);
      int v20 = (void *)*((void *)v290 + 5);
      if (v19)
      {
        *(void *)(v19 + 40) = v20;
        int v20 = (void *)*((void *)v17 + 5);
      }
      else
      {
        *(void *)(*(void *)(a1 + 64) + 8) = v20;
      }
      *int v20 = v19;
      *uint64_t v18 = 0;
      v18[1] = 0;
      uint64_t v61 = nw_frame_split((uint64_t *)&v290, **(_DWORD **)(a1 + 56));
      os_log_type_t v62 = *(uint64_t **)(a1 + 64);
      BOOL v63 = v290;
      uint64_t v64 = *v62;
      unsigned int v65 = v290;
      *((void *)v290 + 4) = *v62;
      uint32_t v66 = v65 + 8;
      if (v64) {
        char v67 = (void *)(v64 + 40);
      }
      else {
        char v67 = v62 + 1;
      }
      *char v67 = v66;
      uint64_t *v62 = (uint64_t)v63;
      *((void *)v63 + 5) = v62;
      uint64_t v68 = *(void *)(a1 + 72);
      *(void *)(v61 + 32) = 0;
      BOOL v69 = *(uint64_t **)(v68 + 8);
      *(void *)(v61 + 40) = v69;
      uint64_t *v69 = v61;
      *(void *)(v68 + 8) = v61 + 32;
      **(_DWORD **)(a1 + 80) = 0;
      **(_DWORD **)(a1 + 56) = 0;
      os_log_type_t v70 = *(_DWORD **)(a1 + 40);
      if ((*v70)--)
      {
LABEL_190:
        uint64_t v158 = *(_DWORD **)(a1 + 88);
        int v159 = **(_DWORD **)(a1 + 56);
        BOOL v51 = __CFADD__(*v158, v159);
        *v158 += v159;
        if (!v51) {
          goto LABEL_209;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v160 = **(unsigned int **)(a1 + 56);
        uint64_t v161 = (_DWORD *)**(unsigned int **)(a1 + 88);
        *(_DWORD *)int buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = "moved_bytes";
        *(_WORD *)&unsigned char buf[22] = 2048;
        uint64_t v292 = v160;
        __int16 v293 = 2048;
        BOOL v294 = v161;
        int v162 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v288 = 0;
        if (__nwlog_fault(v162, &type, &v288))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            uint64_t v163 = __nwlog_obj();
            os_log_type_t v164 = type;
            if (os_log_type_enabled(v163, type))
            {
              uint64_t v165 = **(unsigned int **)(a1 + 56);
              uint64_t v166 = (_DWORD *)**(unsigned int **)(a1 + 88);
              *(_DWORD *)int buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = "moved_bytes";
              *(_WORD *)&unsigned char buf[22] = 2048;
              uint64_t v292 = v165;
              __int16 v293 = 2048;
              BOOL v294 = v166;
              uint64_t v167 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_205:
              _os_log_impl(&dword_1830D4000, v163, v164, v167, buf, 0x2Au);
            }
          }
          else if (v288)
          {
            BOOL v168 = (char *)__nw_create_backtrace_string();
            uint64_t v163 = __nwlog_obj();
            os_log_type_t v164 = type;
            BOOL v169 = os_log_type_enabled(v163, type);
            if (v168)
            {
              if (v169)
              {
                uint64_t v170 = **(unsigned int **)(a1 + 56);
                uint64_t v171 = (_DWORD *)**(unsigned int **)(a1 + 88);
                *(_DWORD *)int buf = 136447234;
                *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                *(_WORD *)&unsigned char buf[12] = 2082;
                *(void *)&buf[14] = "moved_bytes";
                *(_WORD *)&unsigned char buf[22] = 2048;
                uint64_t v292 = v170;
                __int16 v293 = 2048;
                BOOL v294 = v171;
                __int16 v295 = 2082;
                uint64_t v296 = v168;
                _os_log_impl(&dword_1830D4000, v163, v164, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
              }
              free(v168);
              goto LABEL_206;
            }
            if (v169)
            {
              uint64_t v174 = **(unsigned int **)(a1 + 56);
              uint64_t v175 = (_DWORD *)**(unsigned int **)(a1 + 88);
              *(_DWORD *)int buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = "moved_bytes";
              *(_WORD *)&unsigned char buf[22] = 2048;
              uint64_t v292 = v174;
              __int16 v293 = 2048;
              BOOL v294 = v175;
              uint64_t v167 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
              goto LABEL_205;
            }
          }
          else
          {
            uint64_t v163 = __nwlog_obj();
            os_log_type_t v164 = type;
            if (os_log_type_enabled(v163, type))
            {
              uint64_t v172 = **(unsigned int **)(a1 + 56);
              uint64_t v173 = (_DWORD *)**(unsigned int **)(a1 + 88);
              *(_DWORD *)int buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = "moved_bytes";
              *(_WORD *)&unsigned char buf[22] = 2048;
              uint64_t v292 = v172;
              __int16 v293 = 2048;
              BOOL v294 = v173;
              uint64_t v167 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
              goto LABEL_205;
            }
          }
        }
LABEL_206:
        if (v162) {
          free(v162);
        }
        **(_DWORD **)(a1 + 88) = -1;
LABEL_209:
        uint64_t v176 = *(void *)(*(void *)(a1 + 32) + 8);
        uint64_t v177 = *(unsigned int *)(v176 + 24) + 1;
        uint64_t v178 = v177 << 31 >> 31;
        *(_DWORD *)(v176 + 24) = v177;
        if (v178 != v177 || v178 < 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v179 = (_DWORD *)*(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
          *(_DWORD *)int buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = "count";
          *(_WORD *)&unsigned char buf[22] = 2048;
          uint64_t v292 = 1;
          __int16 v293 = 2048;
          BOOL v294 = v179;
          uint64_t v180 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v288 = 0;
          if (__nwlog_fault(v180, &type, &v288))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              int v181 = __nwlog_obj();
              os_log_type_t v182 = type;
              if (os_log_type_enabled(v181, type))
              {
                uint64_t v183 = (_DWORD *)*(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
                *(_DWORD *)int buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                *(_WORD *)&unsigned char buf[12] = 2082;
                *(void *)&buf[14] = "count";
                *(_WORD *)&unsigned char buf[22] = 2048;
                uint64_t v292 = 1;
                __int16 v293 = 2048;
                BOOL v294 = v183;
                int v184 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_224:
                _os_log_impl(&dword_1830D4000, v181, v182, v184, buf, 0x2Au);
              }
            }
            else if (v288)
            {
              uint64_t v185 = (char *)__nw_create_backtrace_string();
              int v181 = __nwlog_obj();
              os_log_type_t v182 = type;
              BOOL v186 = os_log_type_enabled(v181, type);
              if (v185)
              {
                if (v186)
                {
                  uint64_t v187 = (_DWORD *)*(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
                  *(_DWORD *)int buf = 136447234;
                  *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                  *(_WORD *)&unsigned char buf[12] = 2082;
                  *(void *)&buf[14] = "count";
                  *(_WORD *)&unsigned char buf[22] = 2048;
                  uint64_t v292 = 1;
                  __int16 v293 = 2048;
                  BOOL v294 = v187;
                  __int16 v295 = 2082;
                  uint64_t v296 = v185;
                  _os_log_impl(&dword_1830D4000, v181, v182, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
                }
                free(v185);
                goto LABEL_225;
              }
              if (v186)
              {
                v189 = (_DWORD *)*(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
                *(_DWORD *)int buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                *(_WORD *)&unsigned char buf[12] = 2082;
                *(void *)&buf[14] = "count";
                *(_WORD *)&unsigned char buf[22] = 2048;
                uint64_t v292 = 1;
                __int16 v293 = 2048;
                BOOL v294 = v189;
                int v184 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
                goto LABEL_224;
              }
            }
            else
            {
              int v181 = __nwlog_obj();
              os_log_type_t v182 = type;
              if (os_log_type_enabled(v181, type))
              {
                v188 = (_DWORD *)*(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
                *(_DWORD *)int buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                *(_WORD *)&unsigned char buf[12] = 2082;
                *(void *)&buf[14] = "count";
                *(_WORD *)&unsigned char buf[22] = 2048;
                uint64_t v292 = 1;
                __int16 v293 = 2048;
                BOOL v294 = v188;
                int v184 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
                goto LABEL_224;
              }
            }
          }
LABEL_225:
          if (v180) {
            free(v180);
          }
          BOOL v11 = 0;
          *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = -1;
          return v11;
        }
        return 0;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v72 = (_DWORD *)**(unsigned int **)(a1 + 40);
      *(_DWORD *)int buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = "maximum_frame_count";
      *(_WORD *)&unsigned char buf[22] = 2048;
      uint64_t v292 = 1;
      __int16 v293 = 2048;
      BOOL v294 = v72;
      __int16 v73 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v288 = 0;
      if (__nwlog_fault(v73, &type, &v288))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v74 = __nwlog_obj();
          os_log_type_t v75 = type;
          if (os_log_type_enabled(v74, type))
          {
            uint64_t v76 = (_DWORD *)**(unsigned int **)(a1 + 40);
            *(_DWORD *)int buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = "maximum_frame_count";
            *(_WORD *)&unsigned char buf[22] = 2048;
            uint64_t v292 = 1;
            __int16 v293 = 2048;
            BOOL v294 = v76;
            uint64_t v77 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_186:
            _os_log_impl(&dword_1830D4000, v74, v75, v77, buf, 0x2Au);
          }
        }
        else if (v288)
        {
          BOOL v88 = (char *)__nw_create_backtrace_string();
          os_log_type_t v74 = __nwlog_obj();
          os_log_type_t v75 = type;
          BOOL v89 = os_log_type_enabled(v74, type);
          if (v88)
          {
            if (v89)
            {
              os_log_type_t v90 = (_DWORD *)**(unsigned int **)(a1 + 40);
              *(_DWORD *)int buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = "maximum_frame_count";
              *(_WORD *)&unsigned char buf[22] = 2048;
              uint64_t v292 = 1;
              __int16 v293 = 2048;
              BOOL v294 = v90;
              __int16 v295 = 2082;
              uint64_t v296 = v88;
              _os_log_impl(&dword_1830D4000, v74, v75, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
            }
            free(v88);
            goto LABEL_187;
          }
          if (v89)
          {
            unsigned int v157 = (_DWORD *)**(unsigned int **)(a1 + 40);
            *(_DWORD *)int buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = "maximum_frame_count";
            *(_WORD *)&unsigned char buf[22] = 2048;
            uint64_t v292 = 1;
            __int16 v293 = 2048;
            BOOL v294 = v157;
            uint64_t v77 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
            goto LABEL_186;
          }
        }
        else
        {
          os_log_type_t v74 = __nwlog_obj();
          os_log_type_t v75 = type;
          if (os_log_type_enabled(v74, type))
          {
            BOOL v153 = (_DWORD *)**(unsigned int **)(a1 + 40);
            *(_DWORD *)int buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = "maximum_frame_count";
            *(_WORD *)&unsigned char buf[22] = 2048;
            uint64_t v292 = 1;
            __int16 v293 = 2048;
            BOOL v294 = v153;
            uint64_t v77 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
            goto LABEL_186;
          }
        }
      }
LABEL_187:
      if (v73) {
        free(v73);
      }
      **(_DWORD **)(a1 + 40) = 0;
      goto LABEL_190;
    }
    if (!gLogDatapath) {
      return 0;
    }
    BOOL v41 = __nwlog_obj();
    if (!os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG)) {
      return 0;
    }
    int v42 = **(_DWORD **)(a1 + 56);
    *(_DWORD *)int buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v16;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v42;
    Class v43 = "%{public}s not delivering frame with length %u maximum bytes %u";
    uint64_t v44 = v41;
    uint32_t v45 = 24;
LABEL_344:
    _os_log_impl(&dword_1830D4000, v44, OS_LOG_TYPE_DEBUG, v43, buf, v45);
    return 0;
  }
  if (gLogDatapath)
  {
    uint64_t v273 = __nwlog_obj();
    if (os_log_type_enabled(v273, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = v290;
      _os_log_impl(&dword_1830D4000, v273, OS_LOG_TYPE_DEBUG, "%{public}s delivering frame %p with unknown metadata", buf, 0x16u);
    }
  }
  os_log_type_t v24 = v290;
  BOOL v25 = v290 + 8;
  uint64_t v26 = *((void *)v290 + 4);
  BOOL v27 = (void *)*((void *)v290 + 5);
  if (v26)
  {
    *(void *)(v26 + 40) = v27;
    BOOL v27 = (void *)*((void *)v24 + 5);
  }
  else
  {
    *(void *)(*(void *)(a1 + 64) + 8) = v27;
  }
  *BOOL v27 = v26;
  void *v25 = 0;
  v25[1] = 0;
  uint64_t v46 = *(void *)(a1 + 72);
  BOOL v47 = v290;
  unint64_t v48 = v290;
  *((void *)v290 + 4) = 0;
  os_log_type_t v49 = *(void **)(v46 + 8);
  *((void *)v47 + 5) = v49;
  *os_log_type_t v49 = v47;
  *(void *)(v46 + 8) = v48 + 8;
  BOOL v50 = *(unsigned int **)(a1 + 80);
  BOOL v51 = *v50 >= v16;
  *v50 -= v16;
  if (!v51)
  {
    if (gLogDatapath)
    {
      uint64_t v276 = __nwlog_obj();
      if (os_log_type_enabled(v276, OS_LOG_TYPE_DEBUG))
      {
        v277 = (_DWORD *)**(unsigned int **)(a1 + 80);
        *(_DWORD *)int buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = "minimum_bytes";
        *(_WORD *)&unsigned char buf[22] = 2048;
        uint64_t v292 = v16;
        __int16 v293 = 2048;
        BOOL v294 = v277;
        _os_log_impl(&dword_1830D4000, v276, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
      }
    }
    **(_DWORD **)(a1 + 80) = 0;
  }
  os_log_type_t v52 = *(unsigned int **)(a1 + 56);
  BOOL v51 = *v52 >= v16;
  *v52 -= v16;
  if (!v51)
  {
    if (gLogDatapath)
    {
      uint64_t v278 = __nwlog_obj();
      if (os_log_type_enabled(v278, OS_LOG_TYPE_DEBUG))
      {
        v279 = (_DWORD *)**(unsigned int **)(a1 + 56);
        *(_DWORD *)int buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = "maximum_bytes";
        *(_WORD *)&unsigned char buf[22] = 2048;
        uint64_t v292 = v16;
        __int16 v293 = 2048;
        BOOL v294 = v279;
        _os_log_impl(&dword_1830D4000, v278, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
      }
    }
    **(_DWORD **)(a1 + 56) = 0;
  }
  BOOL v53 = *(_DWORD **)(a1 + 40);
  if (!(*v53)--)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v55 = (_DWORD *)**(unsigned int **)(a1 + 40);
    *(_DWORD *)int buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = "maximum_frame_count";
    *(_WORD *)&unsigned char buf[22] = 2048;
    uint64_t v292 = 1;
    __int16 v293 = 2048;
    BOOL v294 = v55;
    BOOL v56 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v288 = 0;
    if (__nwlog_fault(v56, &type, &v288))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v57 = gLogObj;
        os_log_type_t v58 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          os_log_type_t v59 = (_DWORD *)**(unsigned int **)(a1 + 40);
          *(_DWORD *)int buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = "maximum_frame_count";
          *(_WORD *)&unsigned char buf[22] = 2048;
          uint64_t v292 = 1;
          __int16 v293 = 2048;
          BOOL v294 = v59;
          BOOL v60 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_132:
          _os_log_impl(&dword_1830D4000, v57, v58, v60, buf, 0x2Au);
        }
      }
      else if (v288)
      {
        uint64_t v84 = (char *)__nw_create_backtrace_string();
        BOOL v57 = __nwlog_obj();
        os_log_type_t v58 = type;
        BOOL v85 = os_log_type_enabled(v57, type);
        if (v84)
        {
          if (v85)
          {
            os_log_type_t v86 = (_DWORD *)**(unsigned int **)(a1 + 40);
            *(_DWORD *)int buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = "maximum_frame_count";
            *(_WORD *)&unsigned char buf[22] = 2048;
            uint64_t v292 = 1;
            __int16 v293 = 2048;
            BOOL v294 = v86;
            __int16 v295 = 2082;
            uint64_t v296 = v84;
            _os_log_impl(&dword_1830D4000, v57, v58, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v84);
          goto LABEL_133;
        }
        if (v85)
        {
          char v125 = (_DWORD *)**(unsigned int **)(a1 + 40);
          *(_DWORD *)int buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = "maximum_frame_count";
          *(_WORD *)&unsigned char buf[22] = 2048;
          uint64_t v292 = 1;
          __int16 v293 = 2048;
          BOOL v294 = v125;
          BOOL v60 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          goto LABEL_132;
        }
      }
      else
      {
        BOOL v57 = __nwlog_obj();
        os_log_type_t v58 = type;
        if (os_log_type_enabled(v57, type))
        {
          uint64_t v107 = (_DWORD *)**(unsigned int **)(a1 + 40);
          *(_DWORD *)int buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = "maximum_frame_count";
          *(_WORD *)&unsigned char buf[22] = 2048;
          uint64_t v292 = 1;
          __int16 v293 = 2048;
          BOOL v294 = v107;
          BOOL v60 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_132;
        }
      }
    }
LABEL_133:
    if (v56) {
      free(v56);
    }
    **(_DWORD **)(a1 + 40) = 0;
  }
  os_log_type_t v126 = *(_DWORD **)(a1 + 88);
  BOOL v51 = __CFADD__(*v126, v16);
  *v126 += v16;
  if (!v51) {
    goto LABEL_155;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v127 = v16;
  uint64_t v128 = (_DWORD *)**(unsigned int **)(a1 + 88);
  *(_DWORD *)int buf = 136446978;
  *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
  *(_WORD *)&unsigned char buf[12] = 2082;
  *(void *)&buf[14] = "moved_bytes";
  *(_WORD *)&unsigned char buf[22] = 2048;
  uint64_t v292 = v16;
  __int16 v293 = 2048;
  BOOL v294 = v128;
  os_log_type_t v129 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v288 = 0;
  if (__nwlog_fault(v129, &type, &v288))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v130 = gLogObj;
      os_log_type_t v131 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        BOOL v132 = (_DWORD *)**(unsigned int **)(a1 + 88);
        *(_DWORD *)int buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = "moved_bytes";
        *(_WORD *)&unsigned char buf[22] = 2048;
        uint64_t v292 = v127;
        __int16 v293 = 2048;
        BOOL v294 = v132;
        os_log_type_t v133 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_151:
        _os_log_impl(&dword_1830D4000, v130, v131, v133, buf, 0x2Au);
      }
    }
    else if (v288)
    {
      BOOL v134 = (char *)__nw_create_backtrace_string();
      BOOL v130 = __nwlog_obj();
      os_log_type_t v131 = type;
      BOOL v135 = os_log_type_enabled(v130, type);
      if (v134)
      {
        if (v135)
        {
          BOOL v136 = (_DWORD *)**(unsigned int **)(a1 + 88);
          *(_DWORD *)int buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = "moved_bytes";
          *(_WORD *)&unsigned char buf[22] = 2048;
          uint64_t v292 = v127;
          __int16 v293 = 2048;
          BOOL v294 = v136;
          __int16 v295 = 2082;
          uint64_t v296 = v134;
          _os_log_impl(&dword_1830D4000, v130, v131, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
        }
        free(v134);
        goto LABEL_152;
      }
      if (v135)
      {
        BOOL v138 = (_DWORD *)**(unsigned int **)(a1 + 88);
        *(_DWORD *)int buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = "moved_bytes";
        *(_WORD *)&unsigned char buf[22] = 2048;
        uint64_t v292 = v127;
        __int16 v293 = 2048;
        BOOL v294 = v138;
        os_log_type_t v133 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
        goto LABEL_151;
      }
    }
    else
    {
      BOOL v130 = __nwlog_obj();
      os_log_type_t v131 = type;
      if (os_log_type_enabled(v130, type))
      {
        os_log_type_t v137 = (_DWORD *)**(unsigned int **)(a1 + 88);
        *(_DWORD *)int buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = "moved_bytes";
        *(_WORD *)&unsigned char buf[22] = 2048;
        uint64_t v292 = v127;
        __int16 v293 = 2048;
        BOOL v294 = v137;
        os_log_type_t v133 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
        goto LABEL_151;
      }
    }
  }
LABEL_152:
  if (v129) {
    free(v129);
  }
  **(_DWORD **)(a1 + 88) = -1;
LABEL_155:
  uint64_t v139 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v140 = *(unsigned int *)(v139 + 24) + 1;
  uint64_t v141 = v140 << 31 >> 31;
  *(_DWORD *)(v139 + 24) = v140;
  if (v141 != v140 || v141 < 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v142 = (_DWORD *)*(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    *(_DWORD *)int buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = "count";
    *(_WORD *)&unsigned char buf[22] = 2048;
    uint64_t v292 = 1;
    __int16 v293 = 2048;
    BOOL v294 = v142;
    uint64_t v143 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v288 = 0;
    if (__nwlog_fault(v143, &type, &v288))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v144 = gLogObj;
        os_log_type_t v145 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          os_log_type_t v146 = (_DWORD *)*(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
          *(_DWORD *)int buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = "count";
          *(_WORD *)&unsigned char buf[22] = 2048;
          uint64_t v292 = 1;
          __int16 v293 = 2048;
          BOOL v294 = v146;
          os_log_type_t v147 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_170:
          _os_log_impl(&dword_1830D4000, v144, v145, v147, buf, 0x2Au);
        }
      }
      else if (v288)
      {
        os_log_type_t v148 = (char *)__nw_create_backtrace_string();
        os_log_type_t v144 = __nwlog_obj();
        os_log_type_t v145 = type;
        BOOL v149 = os_log_type_enabled(v144, type);
        if (v148)
        {
          if (v149)
          {
            os_log_type_t v150 = (_DWORD *)*(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
            *(_DWORD *)int buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = "count";
            *(_WORD *)&unsigned char buf[22] = 2048;
            uint64_t v292 = 1;
            __int16 v293 = 2048;
            BOOL v294 = v150;
            __int16 v295 = 2082;
            uint64_t v296 = v148;
            _os_log_impl(&dword_1830D4000, v144, v145, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v148);
          goto LABEL_171;
        }
        if (v149)
        {
          os_log_type_t v152 = (_DWORD *)*(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
          *(_DWORD *)int buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = "count";
          *(_WORD *)&unsigned char buf[22] = 2048;
          uint64_t v292 = 1;
          __int16 v293 = 2048;
          BOOL v294 = v152;
          os_log_type_t v147 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
          goto LABEL_170;
        }
      }
      else
      {
        os_log_type_t v144 = __nwlog_obj();
        os_log_type_t v145 = type;
        if (os_log_type_enabled(v144, type))
        {
          os_log_type_t v151 = (_DWORD *)*(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
          *(_DWORD *)int buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = "count";
          *(_WORD *)&unsigned char buf[22] = 2048;
          uint64_t v292 = 1;
          __int16 v293 = 2048;
          BOOL v294 = v151;
          os_log_type_t v147 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
          goto LABEL_170;
        }
      }
    }
LABEL_171:
    if (v143) {
      free(v143);
    }
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = -1;
  }
  if (nw_frame_is_metadata_complete((uint64_t)v290)) {
    **(_DWORD **)(a1 + 80) = 0;
  }
  return 1;
}

uint64_t __nw_path_has_unsatisfied_cellular_agent_block_invoke(uint64_t a1, int a2, xpc_object_t xdict)
{
  size_t length = 0;
  if (!xdict) {
    return 1;
  }
  data = (const char *)xpc_dictionary_get_data(xdict, "data", &length);
  if (!data) {
    return 1;
  }
  if (length < 0xD8) {
    return 1;
  }
  uint64_t v5 = data;
  if (length != *((unsigned int *)data + 53) + 216
    || strncmp(data + 16, "Cellular", 0x20uLL)
    || *(unsigned char *)(a1 + 40) && strncmp(v5 + 48, "Internet", 0x20uLL))
  {
    return 1;
  }
  uint64_t result = 1;
  if ((*((_DWORD *)v5 + 52) & 3) == 1)
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
    return 0;
  }
  return result;
}

uint64_t __nw_http_metadata_get_datagram_context_id_block_invoke(uint64_t a1, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(void *)(a2 + 8);
  return 1;
}

BOOL __nw_http_metadata_enumerate_modern_header_fields_combined_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  id v3 = *(void **)(a2 + 24);
  if (!v3)
  {
    id v4 = *(id *)(a2 + 32);
    if (v4) {
      goto LABEL_4;
    }
    BOOL v11 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v21 = "nw_http_metadata_enumerate_modern_header_fields_combined_block_invoke";
    uint64_t v12 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (!__nwlog_fault((const char *)v12, &type, &v18))
    {
LABEL_24:
      if (v12) {
        free(v12);
      }
      return 0;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v21 = "nw_http_metadata_enumerate_modern_header_fields_combined_block_invoke";
        os_log_type_t v15 = "%{public}s called with null header_fields";
LABEL_22:
        _os_log_impl(&dword_1830D4000, v13, v14, v15, buf, 0xCu);
      }
    }
    else
    {
      if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v13 = __nwlog_obj();
        os_log_type_t v14 = type;
        BOOL v17 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v17)
          {
            *(_DWORD *)int buf = 136446466;
            uint64_t v21 = "nw_http_metadata_enumerate_modern_header_fields_combined_block_invoke";
            __int16 v22 = 2082;
            BOOL v23 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null header_fields, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_24;
        }
        if (!v17) {
          goto LABEL_23;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v21 = "nw_http_metadata_enumerate_modern_header_fields_combined_block_invoke";
        os_log_type_t v15 = "%{public}s called with null header_fields, no backtrace";
        goto LABEL_22;
      }
      int v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v21 = "nw_http_metadata_enumerate_modern_header_fields_combined_block_invoke";
        os_log_type_t v15 = "%{public}s called with null header_fields, backtrace limit exceeded";
        goto LABEL_22;
      }
    }
LABEL_23:

    goto LABEL_24;
  }
  id v4 = v3;
LABEL_4:
  uint64_t v5 = *(void **)(a1 + 32);
  id v6 = v4;
  id v7 = v5;
  if (!v7)
  {
    BOOL v9 = __nwlog_obj();
    os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int buf = 136446210;
    uint64_t v21 = "nw_http_fields_enumerate_modern_header_fields_combined";
    uint64_t v10 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v10);
    if (result)
    {
      __break(1u);
      return result;
    }
    free(v10);
  }
  _nw_http_fields_enumerate_modern_header_fields_combined((uint64_t)v6, v7);

  return 1;
}

BOOL __nw_http_metadata_copy_endpoint_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  nw_error_t v2 = *(void **)(a2 + 24);
  if (!v2)
  {
    BOOL v11 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v21 = "nw_http_metadata_copy_endpoint_block_invoke";
    uint64_t v12 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (!__nwlog_fault(v12, &type, &v18))
    {
LABEL_21:
      if (!v12) {
        return v2 != 0;
      }
      BOOL v9 = (char *)v12;
      goto LABEL_4;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v21 = "nw_http_metadata_copy_endpoint_block_invoke";
        os_log_type_t v15 = "%{public}s metadata not request";
LABEL_19:
        _os_log_impl(&dword_1830D4000, v13, v14, v15, buf, 0xCu);
      }
    }
    else
    {
      if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v13 = __nwlog_obj();
        os_log_type_t v14 = type;
        BOOL v17 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v17)
          {
            *(_DWORD *)int buf = 136446466;
            uint64_t v21 = "nw_http_metadata_copy_endpoint_block_invoke";
            __int16 v22 = 2082;
            BOOL v23 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s metadata not request, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_21;
        }
        if (!v17) {
          goto LABEL_20;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v21 = "nw_http_metadata_copy_endpoint_block_invoke";
        os_log_type_t v15 = "%{public}s metadata not request, no backtrace";
        goto LABEL_19;
      }
      int v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v21 = "nw_http_metadata_copy_endpoint_block_invoke";
        os_log_type_t v15 = "%{public}s metadata not request, backtrace limit exceeded";
        goto LABEL_19;
      }
    }
LABEL_20:

    goto LABEL_21;
  }
  id v4 = v2;
  uint64_t v5 = (const char *)_nw_http_request_copy_url();

  if (v5)
  {
    nw_endpoint_t url = nw_endpoint_create_url(v5);
    uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
    uint64_t v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = url;

    BOOL v9 = (char *)v5;
LABEL_4:
    free(v9);
  }
  return v2 != 0;
}

uint64_t __nw_http_messaging_options_copy_transaction_metadata_block_invoke(uint64_t a1, uint64_t a2)
{
  nw_error_t v2 = *(void **)(a2 + 24);
  if (v2)
  {
    id v4 = v2;
    id v5 = nw_http_client_metadata_copy_current_transaction_metadata(v4);
    uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
    uint64_t v7 = *(void **)(v6 + 40);
    *(void *)(v6 + 40) = v5;
  }
  return 1;
}

uint64_t __nw_http_connection_metadata_closed_block_invoke(uint64_t a1, os_unfair_lock_s *a2)
{
  nw_error_t v2 = a2 + 44;
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = __nw_http_connection_metadata_closed_block_invoke_2;
  v4[3] = &__block_descriptor_40_e5_v8__0l;
  v4[4] = a2;
  os_unfair_lock_lock(a2 + 44);
  __nw_http_connection_metadata_closed_block_invoke_2((uint64_t)v4);
  os_unfair_lock_unlock(v2);
  return 1;
}

void __nw_connection_group_start_block_invoke(uint64_t a1)
{
  uint64_t v182 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)(*(void *)(a1 + 32) + 16) = qos_class_self();
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(_DWORD *)(v2 + 40);
  if (!v3)
  {
    if (!*(void *)(v2 + 8))
    {
      if (!nw_parameters_get_logging_disabled(*(void *)(v2 + 56)))
      {
        if (__nwlog_connection_group_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_32);
        }
        id v4 = (id)gconnection_groupLogObj;
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        {
          int v17 = *(_DWORD *)(*(void *)(a1 + 32) + 168);
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_group_start_block_invoke";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v17;
          _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s [G%u] The group's client_queue is not set. You must set this group's client_queue using group() prior to calling start.", buf, 0x12u);
        }
        goto LABEL_77;
      }
      return;
    }
    if (!*(void *)(v2 + 136) && !*(void *)(v2 + 144))
    {
      if (!nw_parameters_get_logging_disabled(*(void *)(v2 + 56)))
      {
        if (__nwlog_connection_group_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_32);
        }
        id v4 = (id)gconnection_groupLogObj;
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        {
          int v63 = *(_DWORD *)(*(void *)(a1 + 32) + 168);
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_group_start_block_invoke";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v63;
          _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s [G%u] The group does not have a receive handler or new connection handler set, You must set this group's receive handler or new connection handler prior to calling start.", buf, 0x12u);
        }
        goto LABEL_77;
      }
      return;
    }
    if (!*(void *)(v2 + 32) && !nw_parameters_get_logging_disabled(*(void *)(v2 + 56)))
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_32);
      }
      uint64_t v6 = (id)gconnection_groupLogObj;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        int v7 = *(_DWORD *)(*(void *)(a1 + 32) + 168);
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_connection_group_start_block_invoke";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v7;
        _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_ERROR, "%{public}s [G%u] The group does not have a state changed handler set, no state updates will be delivered.", buf, 0x12u);
      }
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (*(void *)(v8 + 88))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v9 = (id)gLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v10 = *(void *)(a1 + 32);
        int v11 = *(_DWORD *)(v10 + 168);
        int port = nw_listener_get_port(*(nw_listener_t *)(v10 + 88));
        uint64_t v13 = *(void *)(a1 + 32);
        uint64_t v14 = *(void *)(v13 + 56);
        id_string = nw_listener_get_id_string(*(void **)(v13 + 88));
        *(_DWORD *)int buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_connection_group_start_block_invoke";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v11;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = port;
        *(_WORD *)uint64_t v175 = 2112;
        *(void *)&v175[2] = v14;
        *(_WORD *)&v175[10] = 2080;
        *(void *)&v175[12] = id_string;
        _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_DEFAULT, "%{public}s [G%u port: %u, parameters: %@, listener: [%s]] start", buf, 0x2Cu);
      }

      uint64_t v8 = *(void *)(a1 + 32);
      if (*(_DWORD *)(v8 + 184))
      {
        nw_listener_set_new_connection_limit(*(nw_listener_t *)(v8 + 88), *(_DWORD *)(v8 + 184));
        uint64_t v8 = *(void *)(a1 + 32);
      }
    }
    objc_storeStrong((id *)(v8 + 24), (id)v8);
    *(unsigned char *)(*(void *)(a1 + 32) + 190) |= 1u;
    char v18 = *(void **)(a1 + 32);
    if (!v18[10])
    {
      os_log_type_t v29 = v18;
LABEL_45:
      if (v29[13])
      {
        if (!nw_parameters_get_logging_disabled(v29[7]) && gLogDatapath)
        {
          if (__nwlog_connection_group_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_32);
          }
          os_log_type_t v95 = (id)gconnection_groupLogObj;
          if (os_log_type_enabled(v95, OS_LOG_TYPE_DEBUG))
          {
            int v96 = *((_DWORD *)v29 + 42);
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_connection_group_start_existing_connections_locked";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v96;
            _os_log_impl(&dword_1830D4000, v95, OS_LOG_TYPE_DEBUG, "%{public}s [G%u] starting existing connections", buf, 0x12u);
          }
        }
        nw_array_apply((atomic_uchar *)v29[13], (uint64_t)&__block_literal_global_166);
      }
      goto LABEL_49;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v19 = (id)gLogObj;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_group_start_block_invoke";
      _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_DEBUG, "%{public}s Calling nw_path_create_evaluator_for_group", buf, 0xCu);
    }

    evaluator_for_group = nw_path_create_evaluator_for_group(*(void **)(*(void *)(a1 + 32) + 64), *(void **)(*(void *)(a1 + 32) + 56));
    uint64_t v21 = *(void **)(*(void *)(a1 + 32) + 72);
    *(void *)(*(void *)(a1 + 32) + 72) = evaluator_for_group;

    *(void *)int buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000;
    v175[0] = 0;
    __int16 v22 = *(void **)(a1 + 32);
    BOOL v23 = (void *)v22[9];
    uint64_t v24 = (void *)v22[1];
    v165[0] = MEMORY[0x1E4F143A8];
    v165[1] = 3221225472;
    v165[2] = __nw_connection_group_start_block_invoke_29;
    v165[3] = &unk_1E523BAA8;
    uint64_t v167 = buf;
    uint64_t v166 = v22;
    nw_path_evaluator_set_update_handler(v23, v24, v165);
    BOOL v25 = *(os_unfair_lock_s **)(*(void *)(a1 + 32) + 72);
    if (v25)
    {
      uint64_t v26 = v25 + 24;
      BOOL v27 = v25;
      os_unfair_lock_lock(v26);
      id v28 = v27[6];
      os_unfair_lock_unlock(v26);

      if (v28)
      {
        v161[0] = MEMORY[0x1E4F143A8];
        v161[1] = 3221225472;
        v161[2] = __nw_connection_group_start_block_invoke_32;
        v161[3] = &unk_1E523BA58;
        id v162 = *(id *)(a1 + 32);
        id v28 = v28;
        id v163 = v28;
        os_log_type_t v164 = buf;
        nw_path_enumerate_group_options(v28, v161);
      }
    }
    else
    {
      id v28 = 0;
    }

    _Block_object_dispose(buf, 8);
    os_log_type_t v29 = *(id *)(a1 + 32);
    if (v29) {
      goto LABEL_45;
    }
    BOOL v91 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_group_start_existing_connections_locked";
    int v92 = (char *)_os_log_send_and_compose_impl();

    v179[0] = 16;
    handler[0] = 0;
    if (__nwlog_fault(v92, v179, handler))
    {
      if (v179[0] == 17)
      {
        uint64_t v93 = __nwlog_obj();
        os_log_type_t v94 = v179[0];
        if (os_log_type_enabled(v93, (os_log_type_t)v179[0]))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_group_start_existing_connections_locked";
          _os_log_impl(&dword_1830D4000, v93, v94, "%{public}s called with null group", buf, 0xCu);
        }
      }
      else if (handler[0])
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v93 = __nwlog_obj();
        os_log_type_t v98 = v179[0];
        BOOL v99 = os_log_type_enabled(v93, (os_log_type_t)v179[0]);
        if (backtrace_string)
        {
          if (v99)
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_connection_group_start_existing_connections_locked";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v93, v98, "%{public}s called with null group, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_210;
        }
        if (v99)
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_group_start_existing_connections_locked";
          _os_log_impl(&dword_1830D4000, v93, v98, "%{public}s called with null group, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v93 = __nwlog_obj();
        os_log_type_t v129 = v179[0];
        if (os_log_type_enabled(v93, (os_log_type_t)v179[0]))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_group_start_existing_connections_locked";
          _os_log_impl(&dword_1830D4000, v93, v129, "%{public}s called with null group, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_210:
    if (v92) {
      free(v92);
    }
    os_log_type_t v29 = 0;
LABEL_49:

    uint64_t v30 = *(void **)(*(void *)(a1 + 32) + 64);
    if (!v30) {
      return;
    }
    uint64_t v31 = v30;
    int v32 = v31[2];

    if (v32 != 1)
    {
      os_log_type_t v33 = *(void **)(*(void *)(a1 + 32) + 64);
      if (!v33) {
        return;
      }
      id v34 = v33;
      int v35 = v34[2];

      if (v35 != 4) {
        return;
      }
    }
    uint64_t v36 = (nw_listener_t *)*(id *)(a1 + 32);
    int v37 = v36;
    if (v36)
    {
      char v38 = v36[11];
      if (v38)
      {
        uint64_t v39 = v36;
        id v40 = v39[7];
        BOOL v41 = v40;
        if (v40)
        {
          int v42 = v40;
          id v43 = *(id *)(v42[13] + 136);

          if (!v43)
          {
            uint64_t v110 = __nwlog_obj();
            *(_DWORD *)int buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
            uint64_t v111 = (char *)_os_log_send_and_compose_impl();

            v179[0] = 16;
            handler[0] = 0;
            if (!__nwlog_fault(v111, v179, handler)) {
              goto LABEL_263;
            }
            if (v179[0] == 17)
            {
              os_log_type_t v112 = __nwlog_obj();
              os_log_type_t v113 = v179[0];
              if (os_log_type_enabled(v112, (os_log_type_t)v179[0]))
              {
                *(_DWORD *)int buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
                _os_log_impl(&dword_1830D4000, v112, v113, "%{public}s called with null context", buf, 0xCu);
              }
            }
            else if (handler[0])
            {
              char v125 = (char *)__nw_create_backtrace_string();
              os_log_type_t v112 = __nwlog_obj();
              os_log_type_t type = v179[0];
              BOOL v126 = os_log_type_enabled(v112, (os_log_type_t)v179[0]);
              if (v125)
              {
                if (v126)
                {
                  *(_DWORD *)int buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
                  *(_WORD *)&unsigned char buf[12] = 2082;
                  *(void *)&buf[14] = v125;
                  _os_log_impl(&dword_1830D4000, v112, type, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
                }

                free(v125);
                if (!v111) {
                  goto LABEL_265;
                }
                goto LABEL_264;
              }
              if (v126)
              {
                *(_DWORD *)int buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
                _os_log_impl(&dword_1830D4000, v112, type, "%{public}s called with null context, no backtrace", buf, 0xCu);
              }
            }
            else
            {
              os_log_type_t v112 = __nwlog_obj();
              os_log_type_t v142 = v179[0];
              if (os_log_type_enabled(v112, (os_log_type_t)v179[0]))
              {
                *(_DWORD *)int buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
                _os_log_impl(&dword_1830D4000, v112, v142, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
              }
            }
            goto LABEL_262;
          }
          BOOL v44 = nw_context_copy_workloop(v43);
          if (v44) {
            goto LABEL_61;
          }
          if (nw_context_copy_implicit_context::onceToken != -1) {
            dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
          }
          id v45 = (id)nw_context_copy_implicit_context::implicit_context;
          BOOL v44 = nw_context_copy_workloop(v45);

          if (v44) {
            goto LABEL_61;
          }
          os_log_type_t v114 = __nwlog_obj();
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
          uint64_t v111 = (char *)_os_log_send_and_compose_impl();

          v179[0] = 16;
          handler[0] = 0;
          if (__nwlog_fault(v111, v179, handler))
          {
            if (v179[0] == 17)
            {
              os_log_type_t v112 = __nwlog_obj();
              os_log_type_t v115 = v179[0];
              if (os_log_type_enabled(v112, (os_log_type_t)v179[0]))
              {
                *(_DWORD *)int buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
                _os_log_impl(&dword_1830D4000, v112, v115, "%{public}s called with null workloop", buf, 0xCu);
              }
LABEL_262:

              goto LABEL_263;
            }
            if (!handler[0])
            {
              os_log_type_t v112 = __nwlog_obj();
              os_log_type_t v143 = v179[0];
              if (os_log_type_enabled(v112, (os_log_type_t)v179[0]))
              {
                *(_DWORD *)int buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
                _os_log_impl(&dword_1830D4000, v112, v143, "%{public}s called with null workloop, backtrace limit exceeded", buf, 0xCu);
              }
              goto LABEL_262;
            }
            uint64_t v127 = (char *)__nw_create_backtrace_string();
            os_log_type_t v112 = __nwlog_obj();
            os_log_type_t typea = v179[0];
            BOOL v128 = os_log_type_enabled(v112, (os_log_type_t)v179[0]);
            if (!v127)
            {
              if (v128)
              {
                *(_DWORD *)int buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
                _os_log_impl(&dword_1830D4000, v112, typea, "%{public}s called with null workloop, no backtrace", buf, 0xCu);
              }
              goto LABEL_262;
            }
            if (v128)
            {
              *(_DWORD *)int buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = v127;
              _os_log_impl(&dword_1830D4000, v112, typea, "%{public}s called with null workloop, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v127);
          }
LABEL_263:
          if (!v111)
          {
LABEL_265:
            BOOL v44 = 0;
LABEL_61:

            goto LABEL_62;
          }
LABEL_264:
          free(v111);
          goto LABEL_265;
        }
        uint64_t v106 = __nwlog_obj();
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
        uint64_t v107 = (char *)_os_log_send_and_compose_impl();

        v179[0] = 16;
        handler[0] = 0;
        if (__nwlog_fault(v107, v179, handler))
        {
          if (v179[0] == 17)
          {
            uint64_t v108 = __nwlog_obj();
            os_log_type_t v109 = v179[0];
            if (os_log_type_enabled(v108, (os_log_type_t)v179[0]))
            {
              *(_DWORD *)int buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
              _os_log_impl(&dword_1830D4000, v108, v109, "%{public}s called with null parameters", buf, 0xCu);
            }
          }
          else if (handler[0])
          {
            os_log_type_t v122 = (char *)__nw_create_backtrace_string();
            uint64_t v108 = __nwlog_obj();
            os_log_type_t v123 = v179[0];
            BOOL v124 = os_log_type_enabled(v108, (os_log_type_t)v179[0]);
            if (v122)
            {
              if (v124)
              {
                *(_DWORD *)int buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
                *(_WORD *)&unsigned char buf[12] = 2082;
                *(void *)&buf[14] = v122;
                _os_log_impl(&dword_1830D4000, v108, v123, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v122);
              goto LABEL_254;
            }
            if (v124)
            {
              *(_DWORD *)int buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
              _os_log_impl(&dword_1830D4000, v108, v123, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
            }
          }
          else
          {
            uint64_t v108 = __nwlog_obj();
            os_log_type_t v141 = v179[0];
            if (os_log_type_enabled(v108, (os_log_type_t)v179[0]))
            {
              *(_DWORD *)int buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
              _os_log_impl(&dword_1830D4000, v108, v141, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
            }
          }
        }
LABEL_254:
        if (v107) {
          free(v107);
        }
        BOOL v44 = 0;
LABEL_62:

        nw_listener_set_queue(v38, (dispatch_queue_t)v44);
        uint64_t v46 = v37[11];
        *(void *)int buf = MEMORY[0x1E4F143A8];
        *(void *)&buf[8] = 3221225472;
        *(void *)&buf[16] = ___ZL52nw_connection_group_set_up_and_start_listener_lockedP30NWConcrete_nw_connection_group_block_invoke;
        *(void *)uint64_t v175 = &unk_1E524BA60;
        BOOL v47 = v39;
        *(void *)&v175[8] = v47;
        nw_listener_set_state_changed_handler(v46, buf);
        id v48 = v47[8];
        if (!v48) {
          goto LABEL_86;
        }
        os_log_type_t v49 = v48;
        int v50 = v49[2];

        if (v50 == 1)
        {
          nw_listener_t v51 = v37[11];
          *(void *)uint64_t v179 = MEMORY[0x1E4F143A8];
          *(void *)&v179[8] = 3221225472;
          *(void *)&v179[16] = ___ZL52nw_connection_group_set_up_and_start_listener_lockedP30NWConcrete_nw_connection_group_block_invoke_2;
          uint64_t v180 = (char *)&unk_1E523BBE0;
          os_log_type_t v52 = v47;
          int v181 = v52;
          nw_listener_set_new_packet_handler(v51, v179);
          BOOL v53 = v52[12];
          if (!v53)
          {
LABEL_71:

LABEL_105:
            *((unsigned char *)v47 + 190) |= 8u;
            nw_listener_start(v37[11]);

LABEL_106:
            return;
          }
          uint64_t v160 = v52;
          id v54 = v39[7];
          os_log_type_t v55 = v54;
          if (v54)
          {
            id v56 = nw_parameters_copy_context(v54);
            BOOL v57 = v56;
            if (v56)
            {
              BOOL v58 = nw_context_copy_workloop(v56);
              if (v58
                || (v59 = nw_context_copy_implicit_context(), BOOL v58 = nw_context_copy_workloop(v59),
                                                              v59,
                                                              v58))
              {
LABEL_69:

LABEL_70:
                nw_listener_set_queue(v53, (dispatch_queue_t)v58);

                BOOL v60 = v52[12];
                *(void *)handler = MEMORY[0x1E4F143A8];
                *(void *)&handler[8] = 3221225472;
                *(void *)&handler[16] = ___ZL52nw_connection_group_set_up_and_start_listener_lockedP30NWConcrete_nw_connection_group_block_invoke_3;
                uint64_t v177 = &unk_1E523BC08;
                uint64_t v61 = v160;
                uint64_t v178 = v61;
                nw_listener_set_new_connection_handler(v60, handler);
                os_log_type_t v62 = v52[12];
                *(void *)BOOL v168 = MEMORY[0x1E4F143A8];
                uint64_t v169 = 3221225472;
                uint64_t v170 = ___ZL52nw_connection_group_set_up_and_start_listener_lockedP30NWConcrete_nw_connection_group_block_invoke_4;
                uint64_t v171 = &unk_1E524BA60;
                uint64_t v172 = v61;
                nw_listener_set_state_changed_handler(v62, v168);
                nw_listener_start(v52[12]);

                goto LABEL_71;
              }
              os_log_type_t v137 = __nwlog_obj();
              *(_DWORD *)handler = 136446210;
              *(void *)&handler[4] = "nw_connection_group_copy_workloop";
              typeb = (char *)_os_log_send_and_compose_impl();

              v168[0] = OS_LOG_TYPE_ERROR;
              char v173 = 0;
              if (__nwlog_fault(typeb, v168, &v173))
              {
                if (v168[0] == OS_LOG_TYPE_FAULT)
                {
                  BOOL v135 = __nwlog_obj();
                  os_log_type_t v138 = v168[0];
                  if (os_log_type_enabled(v135, v168[0]))
                  {
                    *(_DWORD *)handler = 136446210;
                    *(void *)&handler[4] = "nw_connection_group_copy_workloop";
                    _os_log_impl(&dword_1830D4000, v135, v138, "%{public}s called with null workloop", handler, 0xCu);
                  }
                }
                else
                {
                  if (v173)
                  {
                    os_log_type_t v148 = (char *)__nw_create_backtrace_string();
                    BOOL v149 = __nwlog_obj();
                    os_log_type_t v155 = v168[0];
                    BOOL v150 = os_log_type_enabled(v149, v168[0]);
                    if (v148)
                    {
                      if (v150)
                      {
                        *(_DWORD *)handler = 136446466;
                        *(void *)&handler[4] = "nw_connection_group_copy_workloop";
                        *(_WORD *)&handler[12] = 2082;
                        *(void *)&handler[14] = v148;
                        _os_log_impl(&dword_1830D4000, v149, v155, "%{public}s called with null workloop, dumping backtrace:%{public}s", handler, 0x16u);
                      }

                      free(v148);
                    }
                    else
                    {
                      if (v150)
                      {
                        *(_DWORD *)handler = 136446210;
                        *(void *)&handler[4] = "nw_connection_group_copy_workloop";
                        _os_log_impl(&dword_1830D4000, v149, v155, "%{public}s called with null workloop, no backtrace", handler, 0xCu);
                      }
                    }
                    goto LABEL_302;
                  }
                  BOOL v135 = __nwlog_obj();
                  os_log_type_t v153 = v168[0];
                  if (os_log_type_enabled(v135, v168[0]))
                  {
                    *(_DWORD *)handler = 136446210;
                    *(void *)&handler[4] = "nw_connection_group_copy_workloop";
                    _os_log_impl(&dword_1830D4000, v135, v153, "%{public}s called with null workloop, backtrace limit exceeded", handler, 0xCu);
                  }
                }
                goto LABEL_298;
              }
            }
            else
            {
              BOOL v134 = __nwlog_obj();
              *(_DWORD *)handler = 136446210;
              *(void *)&handler[4] = "nw_connection_group_copy_workloop";
              typeb = (char *)_os_log_send_and_compose_impl();

              v168[0] = OS_LOG_TYPE_ERROR;
              char v173 = 0;
              if (__nwlog_fault(typeb, v168, &v173))
              {
                if (v168[0] == OS_LOG_TYPE_FAULT)
                {
                  BOOL v135 = __nwlog_obj();
                  os_log_type_t v136 = v168[0];
                  if (os_log_type_enabled(v135, v168[0]))
                  {
                    *(_DWORD *)handler = 136446210;
                    *(void *)&handler[4] = "nw_connection_group_copy_workloop";
                    _os_log_impl(&dword_1830D4000, v135, v136, "%{public}s called with null context", handler, 0xCu);
                  }
                }
                else if (v173)
                {
                  os_log_type_t v146 = (char *)__nw_create_backtrace_string();
                  BOOL v135 = __nwlog_obj();
                  os_log_type_t v154 = v168[0];
                  BOOL v147 = os_log_type_enabled(v135, v168[0]);
                  if (v146)
                  {
                    if (v147)
                    {
                      *(_DWORD *)handler = 136446466;
                      *(void *)&handler[4] = "nw_connection_group_copy_workloop";
                      *(_WORD *)&handler[12] = 2082;
                      *(void *)&handler[14] = v146;
                      _os_log_impl(&dword_1830D4000, v135, v154, "%{public}s called with null context, dumping backtrace:%{public}s", handler, 0x16u);
                    }

                    free(v146);
                    goto LABEL_302;
                  }
                  if (v147)
                  {
                    *(_DWORD *)handler = 136446210;
                    *(void *)&handler[4] = "nw_connection_group_copy_workloop";
                    _os_log_impl(&dword_1830D4000, v135, v154, "%{public}s called with null context, no backtrace", handler, 0xCu);
                  }
                }
                else
                {
                  BOOL v135 = __nwlog_obj();
                  os_log_type_t v152 = v168[0];
                  if (os_log_type_enabled(v135, v168[0]))
                  {
                    *(_DWORD *)handler = 136446210;
                    *(void *)&handler[4] = "nw_connection_group_copy_workloop";
                    _os_log_impl(&dword_1830D4000, v135, v152, "%{public}s called with null context, backtrace limit exceeded", handler, 0xCu);
                  }
                }
LABEL_298:
              }
            }
LABEL_302:
            if (typeb) {
              free(typeb);
            }
            BOOL v58 = 0;
            goto LABEL_69;
          }
          BOOL v130 = __nwlog_obj();
          *(_DWORD *)handler = 136446210;
          *(void *)&handler[4] = "nw_connection_group_copy_workloop";
          os_log_type_t v131 = (char *)_os_log_send_and_compose_impl();

          v168[0] = OS_LOG_TYPE_ERROR;
          char v173 = 0;
          if (__nwlog_fault(v131, v168, &v173))
          {
            if (v168[0] == OS_LOG_TYPE_FAULT)
            {
              BOOL v132 = __nwlog_obj();
              os_log_type_t v133 = v168[0];
              if (os_log_type_enabled(v132, v168[0]))
              {
                *(_DWORD *)handler = 136446210;
                *(void *)&handler[4] = "nw_connection_group_copy_workloop";
                _os_log_impl(&dword_1830D4000, v132, v133, "%{public}s called with null parameters", handler, 0xCu);
              }
            }
            else if (v173)
            {
              os_log_type_t v144 = (char *)__nw_create_backtrace_string();
              BOOL v132 = __nwlog_obj();
              os_log_type_t v156 = v168[0];
              BOOL v145 = os_log_type_enabled(v132, v168[0]);
              if (v144)
              {
                if (v145)
                {
                  *(_DWORD *)handler = 136446466;
                  *(void *)&handler[4] = "nw_connection_group_copy_workloop";
                  *(_WORD *)&handler[12] = 2082;
                  *(void *)&handler[14] = v144;
                  _os_log_impl(&dword_1830D4000, v132, v156, "%{public}s called with null parameters, dumping backtrace:%{public}s", handler, 0x16u);
                }

                free(v144);
                goto LABEL_293;
              }
              if (v145)
              {
                *(_DWORD *)handler = 136446210;
                *(void *)&handler[4] = "nw_connection_group_copy_workloop";
                _os_log_impl(&dword_1830D4000, v132, v156, "%{public}s called with null parameters, no backtrace", handler, 0xCu);
              }
            }
            else
            {
              BOOL v132 = __nwlog_obj();
              os_log_type_t v151 = v168[0];
              if (os_log_type_enabled(v132, v168[0]))
              {
                *(_DWORD *)handler = 136446210;
                *(void *)&handler[4] = "nw_connection_group_copy_workloop";
                _os_log_impl(&dword_1830D4000, v132, v151, "%{public}s called with null parameters, backtrace limit exceeded", handler, 0xCu);
              }
            }
          }
LABEL_293:
          if (v131) {
            free(v131);
          }
          BOOL v58 = 0;
          goto LABEL_70;
        }
        id v64 = v47[8];
        if (!v64) {
          goto LABEL_86;
        }
        if (nw_group_descriptor_get_type(v64) == 2)
        {
LABEL_82:
          uint32_t v66 = v37[11];
          *(void *)uint64_t v179 = MEMORY[0x1E4F143A8];
          *(void *)&v179[8] = 3221225472;
          *(void *)&v179[16] = ___ZL52nw_connection_group_set_up_and_start_listener_lockedP30NWConcrete_nw_connection_group_block_invoke_2_174;
          uint64_t v180 = (char *)&unk_1E523BC08;
          int v181 = v47;
          nw_listener_set_new_connection_handler(v66, v179);

          goto LABEL_105;
        }
        id v65 = v47[8];
        if (!v65) {
          goto LABEL_86;
        }
        if (nw_group_descriptor_get_type(v65) == 4) {
          goto LABEL_82;
        }
        if (!v47[8])
        {
LABEL_86:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v70 = (id)gLogObj;
          *(_DWORD *)uint64_t v179 = 136446210;
          *(void *)&v179[4] = "nw_connection_group_set_up_and_start_listener_locked";
          BOOL v71 = (char *)_os_log_send_and_compose_impl();

          handler[0] = 16;
          v168[0] = OS_LOG_TYPE_DEFAULT;
          if (!__nwlog_fault(v71, handler, v168)) {
            goto LABEL_103;
          }
          if (handler[0] == 17)
          {
            os_log_type_t v72 = __nwlog_obj();
            os_log_type_t v73 = handler[0];
            if (os_log_type_enabled(v72, (os_log_type_t)handler[0]))
            {
              *(_DWORD *)uint64_t v179 = 136446210;
              *(void *)&v179[4] = "nw_connection_group_set_up_and_start_listener_locked";
              _os_log_impl(&dword_1830D4000, v72, v73, "%{public}s Group descriptor is not set", v179, 0xCu);
            }
          }
          else if (v168[0])
          {
            os_log_type_t v74 = (char *)__nw_create_backtrace_string();
            os_log_type_t v72 = __nwlog_obj();
            os_log_type_t v75 = handler[0];
            BOOL v76 = os_log_type_enabled(v72, (os_log_type_t)handler[0]);
            if (v74)
            {
              if (v76)
              {
                *(_DWORD *)uint64_t v179 = 136446466;
                *(void *)&v179[4] = "nw_connection_group_set_up_and_start_listener_locked";
                *(_WORD *)&v179[12] = 2082;
                *(void *)&v179[14] = v74;
                _os_log_impl(&dword_1830D4000, v72, v75, "%{public}s Group descriptor is not set, dumping backtrace:%{public}s", v179, 0x16u);
              }

              free(v74);
              if (!v71) {
                goto LABEL_105;
              }
              goto LABEL_104;
            }
            if (v76)
            {
              *(_DWORD *)uint64_t v179 = 136446210;
              *(void *)&v179[4] = "nw_connection_group_set_up_and_start_listener_locked";
              _os_log_impl(&dword_1830D4000, v72, v75, "%{public}s Group descriptor is not set, no backtrace", v179, 0xCu);
            }
          }
          else
          {
            os_log_type_t v72 = __nwlog_obj();
            os_log_type_t v77 = handler[0];
            if (os_log_type_enabled(v72, (os_log_type_t)handler[0]))
            {
              *(_DWORD *)uint64_t v179 = 136446210;
              *(void *)&v179[4] = "nw_connection_group_set_up_and_start_listener_locked";
              _os_log_impl(&dword_1830D4000, v72, v77, "%{public}s Group descriptor is not set, backtrace limit exceeded", v179, 0xCu);
            }
          }
          goto LABEL_102;
        }
        char v67 = __nwlog_obj();
        unsigned int v68 = nw_group_descriptor_get_type(v47[8]);
        if (v68 > 4) {
          BOOL v69 = "unknown";
        }
        else {
          BOOL v69 = off_1E523BC90[v68];
        }
        *(_DWORD *)uint64_t v179 = 136446466;
        *(void *)&v179[4] = "nw_connection_group_set_up_and_start_listener_locked";
        *(_WORD *)&v179[12] = 2080;
        *(void *)&v179[14] = v69;
        BOOL v71 = (char *)_os_log_send_and_compose_impl();

        handler[0] = 16;
        v168[0] = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v71, handler, v168))
        {
          if (handler[0] == 17)
          {
            os_log_type_t v72 = __nwlog_obj();
            os_log_type_t v78 = handler[0];
            if (os_log_type_enabled(v72, (os_log_type_t)handler[0]))
            {
              unsigned int v79 = nw_group_descriptor_get_type(v47[8]);
              if (v79 > 4) {
                uint64_t v80 = "unknown";
              }
              else {
                uint64_t v80 = off_1E523BC90[v79];
              }
              *(_DWORD *)uint64_t v179 = 136446466;
              *(void *)&v179[4] = "nw_connection_group_set_up_and_start_listener_locked";
              *(_WORD *)&v179[12] = 2080;
              *(void *)&v179[14] = v80;
              _os_log_impl(&dword_1830D4000, v72, v78, "%{public}s Unsupported group descriptor type: %s", v179, 0x16u);
            }
LABEL_102:

            goto LABEL_103;
          }
          if (v168[0] == OS_LOG_TYPE_DEFAULT)
          {
            os_log_type_t v72 = __nwlog_obj();
            os_log_type_t v86 = handler[0];
            if (os_log_type_enabled(v72, (os_log_type_t)handler[0]))
            {
              unsigned int v87 = nw_group_descriptor_get_type(v47[8]);
              if (v87 > 4) {
                BOOL v88 = "unknown";
              }
              else {
                BOOL v88 = off_1E523BC90[v87];
              }
              *(_DWORD *)uint64_t v179 = 136446466;
              *(void *)&v179[4] = "nw_connection_group_set_up_and_start_listener_locked";
              *(_WORD *)&v179[12] = 2080;
              *(void *)&v179[14] = v88;
              _os_log_impl(&dword_1830D4000, v72, v86, "%{public}s Unsupported group descriptor type: %s, backtrace limit exceeded", v179, 0x16u);
            }
            goto LABEL_102;
          }
          os_log_type_t v81 = (char *)__nw_create_backtrace_string();
          os_log_type_t v72 = __nwlog_obj();
          os_log_type_t v82 = handler[0];
          BOOL v83 = os_log_type_enabled(v72, (os_log_type_t)handler[0]);
          if (!v81)
          {
            if (v83)
            {
              unsigned int v89 = nw_group_descriptor_get_type(v47[8]);
              if (v89 > 4) {
                os_log_type_t v90 = "unknown";
              }
              else {
                os_log_type_t v90 = off_1E523BC90[v89];
              }
              *(_DWORD *)uint64_t v179 = 136446466;
              *(void *)&v179[4] = "nw_connection_group_set_up_and_start_listener_locked";
              *(_WORD *)&v179[12] = 2080;
              *(void *)&v179[14] = v90;
              _os_log_impl(&dword_1830D4000, v72, v82, "%{public}s Unsupported group descriptor type: %s, no backtrace", v179, 0x16u);
            }
            goto LABEL_102;
          }
          if (v83)
          {
            unsigned int v84 = nw_group_descriptor_get_type(v47[8]);
            if (v84 > 4) {
              BOOL v85 = "unknown";
            }
            else {
              BOOL v85 = off_1E523BC90[v84];
            }
            *(_DWORD *)uint64_t v179 = 136446722;
            *(void *)&v179[4] = "nw_connection_group_set_up_and_start_listener_locked";
            *(_WORD *)&v179[12] = 2080;
            *(void *)&v179[14] = v85;
            *(_WORD *)&v179[22] = 2082;
            uint64_t v180 = v81;
            _os_log_impl(&dword_1830D4000, v72, v82, "%{public}s Unsupported group descriptor type: %s, dumping backtrace:%{public}s", v179, 0x20u);
          }

          free(v81);
        }
LABEL_103:
        if (!v71) {
          goto LABEL_105;
        }
LABEL_104:
        free(v71);
        goto LABEL_105;
      }
      os_log_type_t v104 = __nwlog_obj();
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_group_set_up_and_start_listener_locked";
      long long v101 = (char *)_os_log_send_and_compose_impl();

      v179[0] = 16;
      handler[0] = 0;
      if (!__nwlog_fault(v101, v179, handler)) {
        goto LABEL_249;
      }
      if (v179[0] == 17)
      {
        __int16 v102 = __nwlog_obj();
        os_log_type_t v105 = v179[0];
        if (os_log_type_enabled(v102, (os_log_type_t)v179[0]))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_group_set_up_and_start_listener_locked";
          _os_log_impl(&dword_1830D4000, v102, v105, "%{public}s called with null group->listener", buf, 0xCu);
        }
      }
      else if (handler[0])
      {
        int v119 = (char *)__nw_create_backtrace_string();
        __int16 v102 = __nwlog_obj();
        os_log_type_t v120 = v179[0];
        BOOL v121 = os_log_type_enabled(v102, (os_log_type_t)v179[0]);
        if (v119)
        {
          if (v121)
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_connection_group_set_up_and_start_listener_locked";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v119;
            _os_log_impl(&dword_1830D4000, v102, v120, "%{public}s called with null group->listener, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v119);
          if (!v101) {
            goto LABEL_106;
          }
          goto LABEL_250;
        }
        if (v121)
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_group_set_up_and_start_listener_locked";
          _os_log_impl(&dword_1830D4000, v102, v120, "%{public}s called with null group->listener, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __int16 v102 = __nwlog_obj();
        os_log_type_t v140 = v179[0];
        if (os_log_type_enabled(v102, (os_log_type_t)v179[0]))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_group_set_up_and_start_listener_locked";
          _os_log_impl(&dword_1830D4000, v102, v140, "%{public}s called with null group->listener, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    else
    {
      long long v100 = __nwlog_obj();
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_group_set_up_and_start_listener_locked";
      long long v101 = (char *)_os_log_send_and_compose_impl();

      v179[0] = 16;
      handler[0] = 0;
      if (!__nwlog_fault(v101, v179, handler)) {
        goto LABEL_249;
      }
      if (v179[0] == 17)
      {
        __int16 v102 = __nwlog_obj();
        os_log_type_t v103 = v179[0];
        if (os_log_type_enabled(v102, (os_log_type_t)v179[0]))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_group_set_up_and_start_listener_locked";
          _os_log_impl(&dword_1830D4000, v102, v103, "%{public}s called with null group", buf, 0xCu);
        }
      }
      else if (handler[0])
      {
        os_log_type_t v116 = (char *)__nw_create_backtrace_string();
        __int16 v102 = __nwlog_obj();
        os_log_type_t v117 = v179[0];
        BOOL v118 = os_log_type_enabled(v102, (os_log_type_t)v179[0]);
        if (v116)
        {
          if (v118)
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_connection_group_set_up_and_start_listener_locked";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v116;
            _os_log_impl(&dword_1830D4000, v102, v117, "%{public}s called with null group, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v116);
LABEL_249:
          if (!v101) {
            goto LABEL_106;
          }
LABEL_250:
          free(v101);
          goto LABEL_106;
        }
        if (v118)
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_group_set_up_and_start_listener_locked";
          _os_log_impl(&dword_1830D4000, v102, v117, "%{public}s called with null group, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __int16 v102 = __nwlog_obj();
        os_log_type_t v139 = v179[0];
        if (os_log_type_enabled(v102, (os_log_type_t)v179[0]))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_group_set_up_and_start_listener_locked";
          _os_log_impl(&dword_1830D4000, v102, v139, "%{public}s called with null group, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

    goto LABEL_249;
  }
  if (v3 == 4)
  {
    if (!nw_parameters_get_logging_disabled(*(void *)(v2 + 56)))
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_32);
      }
      id v4 = (id)gconnection_groupLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 168);
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_connection_group_start_block_invoke";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v5;
        _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s [G%u] The group has already been cancelled and cannot be started again. You must create a new group object and start it.", buf, 0x12u);
      }
LABEL_77:
    }
  }
  else if (!nw_parameters_get_logging_disabled(*(void *)(v2 + 56)))
  {
    if (__nwlog_connection_group_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_32);
    }
    id v4 = (id)gconnection_groupLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v16 = *(_DWORD *)(*(void *)(a1 + 32) + 168);
      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_connection_group_start_block_invoke";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v16;
      _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s [G%u] The group has already been started, ignoring nw_connection_group_start().", buf, 0x12u);
    }
    goto LABEL_77;
  }
}

void sub_1834813BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41)
{
  _Unwind_Resume(a1);
}

void __nw_candidate_manager_start_advertise_block_invoke_2(uint64_t a1, int a2, void *a3)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  id v5 = a3;
  uint64_t v6 = v5;
  if (a2 == 3)
  {
    if (__nwlog_candidate_manager_log::onceToken != -1) {
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_24);
    }
    int v7 = (id)gcandidate_managerLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      uint64_t v8 = *(void *)(a1 + 40);
      uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8);
      int v19 = 136446722;
      int v20 = "nw_candidate_manager_start_advertise_block_invoke_2";
      __int16 v21 = 2048;
      uint64_t v22 = v9;
      __int16 v23 = 2112;
      uint64_t v24 = v8;
      _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_INFO, "%{public}s [CM%zu] Incoming connection %@ entered ready state", (uint8_t *)&v19, 0x20u);
    }

    uint64_t v10 = *(NSObject **)(a1 + 40);
    if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
      dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_15_56153);
    }
    int v11 = (id)nw_protocol_copy_quic_stream_definition::quic_definition;
    nw_protocol_metadata_t v12 = nw_connection_copy_protocol_metadata(v10, v11);

    if (!v12) {
      goto LABEL_19;
    }
    uint64_t v13 = v12;
    if (nw_protocol_metadata_is_quic_connection(v13))
    {
    }
    else
    {
      BOOL is_quic_stream = nw_protocol_metadata_is_quic_stream(v13);

      if (!is_quic_stream)
      {
LABEL_19:
        nw_candidate_manager_set_state(*(void **)(a1 + 32), 2);

        goto LABEL_20;
      }
    }
    id v18 = nw_quic_stream_copy_connection_metadata(v13);
    nw_quic_connection_set_keepalive(v18, 10);

    goto LABEL_19;
  }
  if (v5)
  {
    if (__nwlog_candidate_manager_log::onceToken != -1) {
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_24);
    }
    uint64_t v14 = (id)gcandidate_managerLogObj;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      uint64_t v15 = *(void *)(a1 + 40);
      uint64_t v16 = *(void *)(*(void *)(a1 + 32) + 8);
      int v19 = 136446978;
      int v20 = "nw_candidate_manager_start_advertise_block_invoke";
      __int16 v21 = 2048;
      uint64_t v22 = v16;
      __int16 v23 = 2112;
      uint64_t v24 = v15;
      __int16 v25 = 2112;
      uint64_t v26 = v6;
      _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_INFO, "%{public}s [CM%zu] Incoming connection %@ failed with error '%@'", (uint8_t *)&v19, 0x2Au);
    }

    nw_candidate_manager_cancel(*(void **)(a1 + 32));
  }
LABEL_20:
}

void sub_183481750(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_candidate_manager_start_advertise_block_invoke_142(uint64_t a1, int a2, void *a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v5 = a3;
  uint64_t v6 = v5;
  if (a2 == 2)
  {
    int port = nw_listener_get_port(*(nw_listener_t *)(a1 + 32));
    if (__nwlog_candidate_manager_log::onceToken != -1) {
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_24);
    }
    uint64_t v8 = (id)gcandidate_managerLogObj;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_INFO)) {
      goto LABEL_12;
    }
    uint64_t v9 = *(void *)(*(void *)(a1 + 40) + 8);
    int v14 = 136446722;
    uint64_t v15 = "nw_candidate_manager_start_advertise_block_invoke";
    __int16 v16 = 2048;
    uint64_t v17 = v9;
    __int16 v18 = 1024;
    LODWORD(v19) = port;
    uint64_t v10 = "%{public}s [CM%zu] Listener entered ready state, using port %d";
    int v11 = v8;
    uint32_t v12 = 28;
LABEL_11:
    _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_INFO, v10, (uint8_t *)&v14, v12);
LABEL_12:

    goto LABEL_13;
  }
  if (v5)
  {
    if (__nwlog_candidate_manager_log::onceToken != -1) {
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_24);
    }
    uint64_t v8 = (id)gcandidate_managerLogObj;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_INFO)) {
      goto LABEL_12;
    }
    uint64_t v13 = *(void *)(*(void *)(a1 + 40) + 8);
    int v14 = 136446722;
    uint64_t v15 = "nw_candidate_manager_start_advertise_block_invoke";
    __int16 v16 = 2048;
    uint64_t v17 = v13;
    __int16 v18 = 2112;
    int v19 = v6;
    uint64_t v10 = "%{public}s [CM%zu] Listener failed with error '%@'";
    int v11 = v8;
    uint32_t v12 = 32;
    goto LABEL_11;
  }
LABEL_13:
}

void sub_183481960(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_agent_set_flow_handlers_block_invoke(uint64_t a1)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(void *)(v2 + 248)) {
    goto LABEL_20;
  }
  int v3 = nw_nexus_create_with_options(v2 + 52, *(void *)(v2 + 264), *(void *)(v2 + 272), *(void *)(v2 + 280));
  uint64_t v4 = *(void *)(a1 + 32);
  id v5 = *(void **)(v4 + 248);
  *(void *)(v4 + 248) = v3;

  uint64_t v2 = *(void *)(a1 + 32);
  if (*(void *)(v2 + 248)) {
    goto LABEL_20;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v6 = (id)gLogObj;
  *(_DWORD *)int buf = 136446210;
  __int16 v25 = "nw_agent_set_flow_handlers_block_invoke";
  int v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v22 = 0;
  if (__nwlog_fault(v7, &type, &v22))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v8 = (id)gLogObj;
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v25 = "nw_agent_set_flow_handlers_block_invoke";
        uint64_t v10 = "%{public}s nw_nexus_create failed";
LABEL_14:
        int v14 = v8;
        os_log_type_t v15 = v9;
LABEL_15:
        _os_log_impl(&dword_1830D4000, v14, v15, v10, buf, 0xCu);
      }
    }
    else
    {
      if (v22)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v8 = (id)gLogObj;
        os_log_type_t v12 = type;
        BOOL v13 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)int buf = 136446466;
            __int16 v25 = "nw_agent_set_flow_handlers_block_invoke";
            __int16 v26 = 2082;
            uint64_t v27 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v8, v12, "%{public}s nw_nexus_create failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_17;
        }
        if (!v13) {
          goto LABEL_16;
        }
        *(_DWORD *)int buf = 136446210;
        __int16 v25 = "nw_agent_set_flow_handlers_block_invoke";
        uint64_t v10 = "%{public}s nw_nexus_create failed, no backtrace";
        int v14 = v8;
        os_log_type_t v15 = v12;
        goto LABEL_15;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v8 = (id)gLogObj;
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v25 = "nw_agent_set_flow_handlers_block_invoke";
        uint64_t v10 = "%{public}s nw_nexus_create failed, backtrace limit exceeded";
        goto LABEL_14;
      }
    }
LABEL_16:
  }
LABEL_17:
  if (v7) {
    free(v7);
  }
  uint64_t v2 = *(void *)(a1 + 32);
LABEL_20:
  *(unsigned char *)(v2 + 856) |= 8u;
  *(_DWORD *)(*(void *)(a1 + 32) + 256) = *(_DWORD *)(a1 + 56);
  *(_DWORD *)(*(void *)(a1 + 32) + 260) = *(_DWORD *)(a1 + 60);
  *(unsigned char *)(*(void *)(a1 + 32) + 856) = *(unsigned char *)(*(void *)(a1 + 32) + 856) & 0xFD | (2 * *(unsigned char *)(a1 + 64));
  __int16 v16 = _Block_copy(*(const void **)(a1 + 40));
  uint64_t v17 = *(void *)(a1 + 32);
  __int16 v18 = *(void **)(v17 + 776);
  *(void *)(v17 + 776) = v16;

  int v19 = _Block_copy(*(const void **)(a1 + 48));
  uint64_t v20 = *(void *)(a1 + 32);
  __int16 v21 = *(void **)(v20 + 784);
  *(void *)(v20 + 784) = v19;
}

void __nw_activity_submit_metrics_block_invoke(void *a1)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a1[4];
  if ((*(unsigned char *)(v2 + 140) & 4) == 0)
  {
    id v5 = __nwlog_obj();
    *(_DWORD *)int buf = 136446466;
    uint64_t v20 = "nw_activity_submit_metrics_block_invoke";
    __int16 v21 = 2082;
    char v22 = "Cannot submit metrics before activation";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (!__nwlog_fault(v6, &type, &v17)) {
      goto LABEL_40;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446466;
        uint64_t v20 = "nw_activity_submit_metrics_block_invoke";
        __int16 v21 = 2082;
        char v22 = "Cannot submit metrics before activation";
        os_log_type_t v9 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s";
LABEL_38:
        _os_log_impl(&dword_1830D4000, v7, v8, v9, buf, 0x16u);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v12 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)int buf = 136446722;
          uint64_t v20 = "nw_activity_submit_metrics_block_invoke";
          __int16 v21 = 2082;
          char v22 = "Cannot submit metrics before activation";
          __int16 v23 = 2082;
          uint64_t v24 = (uint64_t)backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(backtrace_string);
LABEL_40:
        if (!v6)
        {
LABEL_42:
          *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = 0;
          return;
        }
LABEL_41:
        free(v6);
        goto LABEL_42;
      }
      if (v12)
      {
        *(_DWORD *)int buf = 136446466;
        uint64_t v20 = "nw_activity_submit_metrics_block_invoke";
        __int16 v21 = 2082;
        char v22 = "Cannot submit metrics before activation";
        os_log_type_t v9 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace";
        goto LABEL_38;
      }
    }
    else
    {
      int v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446466;
        uint64_t v20 = "nw_activity_submit_metrics_block_invoke";
        __int16 v21 = 2082;
        char v22 = "Cannot submit metrics before activation";
        os_log_type_t v9 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded";
        goto LABEL_38;
      }
    }
LABEL_39:

    goto LABEL_40;
  }
  if ((*(unsigned char *)(v2 + 140) & 8) != 0)
  {
    uint64_t v10 = __nwlog_obj();
    *(_DWORD *)int buf = 136446466;
    uint64_t v20 = "nw_activity_submit_metrics_block_invoke";
    __int16 v21 = 2082;
    char v22 = "Cannot submit metrics after completion";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (!__nwlog_fault(v6, &type, &v17)) {
      goto LABEL_40;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446466;
        uint64_t v20 = "nw_activity_submit_metrics_block_invoke";
        __int16 v21 = 2082;
        char v22 = "Cannot submit metrics after completion";
        os_log_type_t v9 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s";
        goto LABEL_38;
      }
    }
    else
    {
      if (v17)
      {
        os_log_type_t v15 = (char *)__nw_create_backtrace_string();
        int v7 = __nwlog_obj();
        os_log_type_t v8 = type;
        BOOL v16 = os_log_type_enabled(v7, type);
        if (v15)
        {
          if (v16)
          {
            *(_DWORD *)int buf = 136446722;
            uint64_t v20 = "nw_activity_submit_metrics_block_invoke";
            __int16 v21 = 2082;
            char v22 = "Cannot submit metrics after completion";
            __int16 v23 = 2082;
            uint64_t v24 = (uint64_t)v15;
            _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(v15);
          if (!v6) {
            goto LABEL_42;
          }
          goto LABEL_41;
        }
        if (!v16) {
          goto LABEL_39;
        }
        *(_DWORD *)int buf = 136446466;
        uint64_t v20 = "nw_activity_submit_metrics_block_invoke";
        __int16 v21 = 2082;
        char v22 = "Cannot submit metrics after completion";
        os_log_type_t v9 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace";
        goto LABEL_38;
      }
      int v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446466;
        uint64_t v20 = "nw_activity_submit_metrics_block_invoke";
        __int16 v21 = 2082;
        char v22 = "Cannot submit metrics after completion";
        os_log_type_t v9 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded";
        goto LABEL_38;
      }
    }
    goto LABEL_39;
  }
  uint64_t v3 = *(unsigned int *)(v2 + 120) + 1;
  uint64_t v4 = v3 << 31 >> 31;
  *(_DWORD *)(v2 + 120) = v3;
  if (v4 != v3 || v4 < 0)
  {
    if (gLogDatapath)
    {
      BOOL v13 = __nwlog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v14 = *(unsigned int *)(a1[4] + 120);
        *(_DWORD *)int buf = 136446978;
        uint64_t v20 = "nw_activity_submit_metrics_block_invoke";
        __int16 v21 = 2082;
        char v22 = "activity->client_metric_count";
        __int16 v23 = 2048;
        uint64_t v24 = 1;
        __int16 v25 = 2048;
        uint64_t v26 = v14;
        _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_DEBUG, "%{public}s Overflow: %{public}s, increment %llu, result %llu", buf, 0x2Au);
      }
    }
    *(_DWORD *)(a1[4] + 120) = -1;
  }
  *(_DWORD *)(*(void *)(a1[6] + 8) + 24) = *(_DWORD *)(a1[4] + 120);
}

uint64_t __nw_activity_get_fragments_quenched_block_invoke(uint64_t result)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 40) + 8) + 24) = *(_DWORD *)(*(void *)(result + 32) + 48);
  return result;
}

void __clang_call_terminate(void *a1)
{
}

uint64_t ___ZL51nw_protocol_implementation_deliver_output_availableP31NWConcrete_nw_protocol_instance_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  uint64_t extra = nw_hash_node_get_extra(a2);
  object = (void *)nw_hash_node_get_object(a2);
  if (!extra) {
    return 1;
  }
  if ((*(_WORD *)(extra + 52) & 0x100) == 0) {
    return 1;
  }
  id v6 = object;
  if (!object) {
    return 1;
  }
  uint64_t v7 = object[3];
  if (!v7 || !*(void *)(a1 + 32) || !*(void *)(v7 + 72)) {
    return 1;
  }
  *(_WORD *)(extra + 52) &= ~0x100u;
  uint64_t v8 = *(void *)(a1 + 32);
  if (v8) {
    uint64_t v9 = v8 - 96;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = (void *)object[5];
  if (v10 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v12 = object[11];
    if (v12) {
      object[11] = v12 + 1;
    }
    char v11 = -1;
  }
  else
  {
    char v11 = 0;
  }
  BOOL v44 = object;
  char v45 = v11;
  if (!v8)
  {
    __int16 v25 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v47 = "__nw_protocol_output_available";
    uint64_t v26 = (char *)_os_log_send_and_compose_impl();

    v41[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v26, v41, &type))
    {
      if (v41[0] == OS_LOG_TYPE_FAULT)
      {
        uint64_t v27 = __nwlog_obj();
        os_log_type_t v28 = v41[0];
        if (os_log_type_enabled(v27, v41[0]))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v47 = "__nw_protocol_output_available";
          _os_log_impl(&dword_1830D4000, v27, v28, "%{public}s called with null other_protocol", buf, 0xCu);
        }
      }
      else if (type)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v27 = __nwlog_obj();
        os_log_type_t v34 = v41[0];
        BOOL v35 = os_log_type_enabled(v27, v41[0]);
        if (backtrace_string)
        {
          if (v35)
          {
            *(_DWORD *)int buf = 136446466;
            BOOL v47 = "__nw_protocol_output_available";
            __int16 v48 = 2082;
            os_log_type_t v49 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v27, v34, "%{public}s called with null other_protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_73;
        }
        if (v35)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v47 = "__nw_protocol_output_available";
          _os_log_impl(&dword_1830D4000, v27, v34, "%{public}s called with null other_protocol, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v27 = __nwlog_obj();
        os_log_type_t v39 = v41[0];
        if (os_log_type_enabled(v27, v41[0]))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v47 = "__nw_protocol_output_available";
          _os_log_impl(&dword_1830D4000, v27, v39, "%{public}s called with null other_protocol, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_73:
    if (v26) {
      free(v26);
    }
    goto LABEL_26;
  }
  BOOL v13 = *(void **)(v9 + 40);
  if (v13 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v15 = *(void *)(v9 + 88);
    if (v15) {
      *(void *)(v9 + 88) = v15 + 1;
    }
    char v14 = -1;
  }
  else
  {
    char v14 = 0;
  }
  *(void *)BOOL v41 = v9;
  char v42 = v14;
  uint64_t v16 = object[3];
  if (!v16 || (char v17 = *(void (**)(void *))(v16 + 72)) == 0)
  {
    int v19 = __nwlog_obj();
    uint64_t v20 = (const char *)v6[2];
    *(_DWORD *)int buf = 136446722;
    BOOL v47 = "__nw_protocol_output_available";
    if (!v20) {
      uint64_t v20 = "invalid";
    }
    __int16 v48 = 2082;
    os_log_type_t v49 = (void *)v20;
    __int16 v50 = 2048;
    nw_listener_t v51 = v6;
    __int16 v21 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (!__nwlog_fault(v21, &type, &v40)) {
      goto LABEL_65;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        uint64_t v24 = (const char *)v6[2];
        if (!v24) {
          uint64_t v24 = "invalid";
        }
        *(_DWORD *)int buf = 136446722;
        BOOL v47 = "__nw_protocol_output_available";
        __int16 v48 = 2082;
        os_log_type_t v49 = (void *)v24;
        __int16 v50 = 2048;
        nw_listener_t v51 = v6;
        _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s protocol %{public}s (%p) has invalid output_available callback", buf, 0x20u);
      }
    }
    else if (v40)
    {
      os_log_type_t v29 = (char *)__nw_create_backtrace_string();
      char v22 = __nwlog_obj();
      os_log_type_t v30 = type;
      BOOL v31 = os_log_type_enabled(v22, type);
      if (v29)
      {
        if (v31)
        {
          int v32 = (const char *)v6[2];
          if (!v32) {
            int v32 = "invalid";
          }
          *(_DWORD *)int buf = 136446978;
          BOOL v47 = "__nw_protocol_output_available";
          __int16 v48 = 2082;
          os_log_type_t v49 = (void *)v32;
          __int16 v50 = 2048;
          nw_listener_t v51 = v6;
          __int16 v52 = 2082;
          BOOL v53 = v29;
          _os_log_impl(&dword_1830D4000, v22, v30, "%{public}s protocol %{public}s (%p) has invalid output_available callback, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v29);
        goto LABEL_65;
      }
      if (v31)
      {
        char v38 = (const char *)v6[2];
        if (!v38) {
          char v38 = "invalid";
        }
        *(_DWORD *)int buf = 136446722;
        BOOL v47 = "__nw_protocol_output_available";
        __int16 v48 = 2082;
        os_log_type_t v49 = (void *)v38;
        __int16 v50 = 2048;
        nw_listener_t v51 = v6;
        _os_log_impl(&dword_1830D4000, v22, v30, "%{public}s protocol %{public}s (%p) has invalid output_available callback, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      char v22 = __nwlog_obj();
      os_log_type_t v36 = type;
      if (os_log_type_enabled(v22, type))
      {
        int v37 = (const char *)v6[2];
        if (!v37) {
          int v37 = "invalid";
        }
        *(_DWORD *)int buf = 136446722;
        BOOL v47 = "__nw_protocol_output_available";
        __int16 v48 = 2082;
        os_log_type_t v49 = (void *)v37;
        __int16 v50 = 2048;
        nw_listener_t v51 = v6;
        _os_log_impl(&dword_1830D4000, v22, v36, "%{public}s protocol %{public}s (%p) has invalid output_available callback, backtrace limit exceeded", buf, 0x20u);
      }
    }

LABEL_65:
    if (v21) {
      free(v21);
    }
    goto LABEL_24;
  }
  v17(object);
LABEL_24:
  if (v13 == &nw_protocol_ref_counted_handle) {
    nw::release_if_needed<nw_protocol *>((uint64_t *)v41);
  }
LABEL_26:
  if (v10 == &nw_protocol_ref_counted_handle) {
    nw::release_if_needed<nw_protocol *>((uint64_t *)&v44);
  }
  return 1;
}

void sub_183482908(_Unwind_Exception *exception_object)
{
}

void ___ZL46nwsc_request_create_and_start_connection_innerP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_requestPU25objcproto14OS_nw_endpoint8NSObject21nwsc_operation_code_e_block_invoke_202(uint64_t a1)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v2 = (id)gLogObj;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    *(_DWORD *)int buf = 136446722;
    os_log_type_t v29 = "nwsc_request_create_and_start_connection_inner_block_invoke";
    __int16 v30 = 2114;
    uint64_t v31 = v3;
    __int16 v32 = 2114;
    uint64_t v33 = v4;
    _os_log_impl(&dword_1830D4000, v2, OS_LOG_TYPE_INFO, "%{public}s %{public}@ enabling keep alives for request %{public}@", buf, 0x20u);
  }

  if (nw_tcp_reset_keepalives(*(void **)(a1 + 48), 1, 5, 5, 5))
  {
    int v5 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    uint64_t v7 = v6;
    if (v5 == 22)
    {
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        uint64_t v8 = *(void *)(a1 + 32);
        uint64_t v9 = *(void *)(a1 + 40);
        *(_DWORD *)int buf = 136446978;
        os_log_type_t v29 = "nwsc_request_create_and_start_connection_inner_block_invoke";
        __int16 v30 = 2114;
        uint64_t v31 = v8;
        __int16 v32 = 2114;
        uint64_t v33 = v9;
        __int16 v34 = 1024;
        int v35 = 22;
        _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ error enabling keep alives for request %{public}@ %{darwin.errno}d", buf, 0x26u);
      }

      return;
    }
    uint64_t v10 = *(void *)(a1 + 32);
    uint64_t v11 = *(void *)(a1 + 40);
    *(_DWORD *)int buf = 136446978;
    os_log_type_t v29 = "nwsc_request_create_and_start_connection_inner_block_invoke";
    __int16 v30 = 2114;
    uint64_t v31 = v10;
    __int16 v32 = 2114;
    uint64_t v33 = v11;
    __int16 v34 = 1024;
    int v35 = v5;
    uint64_t v12 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (__nwlog_fault((const char *)v12, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v13 = (id)gLogObj;
        os_log_type_t v14 = type;
        if (!os_log_type_enabled(v13, type)) {
          goto LABEL_25;
        }
        uint64_t v15 = *(void *)(a1 + 32);
        uint64_t v16 = *(void *)(a1 + 40);
        *(_DWORD *)int buf = 136446978;
        os_log_type_t v29 = "nwsc_request_create_and_start_connection_inner_block_invoke";
        __int16 v30 = 2114;
        uint64_t v31 = v15;
        __int16 v32 = 2114;
        uint64_t v33 = v16;
        __int16 v34 = 1024;
        int v35 = v5;
        char v17 = "%{public}s %{public}@ error enabling keep alives for request %{public}@ %{darwin.errno}d";
        goto LABEL_24;
      }
      if (!v26)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v13 = (id)gLogObj;
        os_log_type_t v14 = type;
        if (!os_log_type_enabled(v13, type)) {
          goto LABEL_25;
        }
        uint64_t v22 = *(void *)(a1 + 32);
        uint64_t v23 = *(void *)(a1 + 40);
        *(_DWORD *)int buf = 136446978;
        os_log_type_t v29 = "nwsc_request_create_and_start_connection_inner_block_invoke";
        __int16 v30 = 2114;
        uint64_t v31 = v22;
        __int16 v32 = 2114;
        uint64_t v33 = v23;
        __int16 v34 = 1024;
        int v35 = v5;
        char v17 = "%{public}s %{public}@ error enabling keep alives for request %{public}@ %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_24;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v13 = (id)gLogObj;
      os_log_type_t v14 = type;
      BOOL v19 = os_log_type_enabled(v13, type);
      if (!backtrace_string)
      {
        if (!v19) {
          goto LABEL_25;
        }
        uint64_t v24 = *(void *)(a1 + 32);
        uint64_t v25 = *(void *)(a1 + 40);
        *(_DWORD *)int buf = 136446978;
        os_log_type_t v29 = "nwsc_request_create_and_start_connection_inner_block_invoke";
        __int16 v30 = 2114;
        uint64_t v31 = v24;
        __int16 v32 = 2114;
        uint64_t v33 = v25;
        __int16 v34 = 1024;
        int v35 = v5;
        char v17 = "%{public}s %{public}@ error enabling keep alives for request %{public}@ %{darwin.errno}d, no backtrace";
LABEL_24:
        _os_log_impl(&dword_1830D4000, v13, v14, v17, buf, 0x26u);
LABEL_25:

        if (!v12) {
          return;
        }
LABEL_18:
        free(v12);
        return;
      }
      if (v19)
      {
        uint64_t v20 = *(void *)(a1 + 32);
        uint64_t v21 = *(void *)(a1 + 40);
        *(_DWORD *)int buf = 136447234;
        os_log_type_t v29 = "nwsc_request_create_and_start_connection_inner_block_invoke";
        __int16 v30 = 2114;
        uint64_t v31 = v20;
        __int16 v32 = 2114;
        uint64_t v33 = v21;
        __int16 v34 = 1024;
        int v35 = v5;
        __int16 v36 = 2082;
        int v37 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s %{public}@ error enabling keep alives for request %{public}@ %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x30u);
      }

      free(backtrace_string);
    }
    if (!v12) {
      return;
    }
    goto LABEL_18;
  }
}

void ___ZL46nw_masque_connection_pair_read_outer_datagramsP36NWConcrete_nw_masque_connection_pair_block_invoke_325(uint64_t a1)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 48))
  {
    for (unint64_t i = 0; i < *(unsigned int *)(a1 + 48); ++i)
    {
      uint64_t v3 = *(id *)(*(void *)(a1 + 40) + 8 * i);
      uint64_t v29 = 0;
      __int16 v30 = &v29;
      uint64_t v31 = 0x2020000000;
      char v32 = 0;
      uint64_t v4 = *(void *)(a1 + 32);
      if (*(void *)(v4 + 32))
      {
        if (gLogDatapath)
        {
          uint64_t v11 = __nwlog_obj();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v12 = *(void *)(*(void *)(a1 + 32) + 16);
            *(_DWORD *)applier = 136446722;
            *(void *)&applier[4] = "nw_masque_connection_pair_read_outer_datagrams_block_invoke";
            *(_WORD *)&applier[12] = 2114;
            *(void *)&applier[14] = v12;
            *(_WORD *)&applier[22] = 2112;
            uint64_t v38 = v3;
            _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_DEBUG, "%{public}s %{public}@ Received content %@", applier, 0x20u);
          }

          uint64_t v4 = *(void *)(a1 + 32);
          uint64_t v5 = *(unsigned __int16 *)(v4 + 72);
          if (!*(_WORD *)(v4 + 72))
          {
LABEL_17:
            if (*(void *)(v4 + 192))
            {
              v25[0] = MEMORY[0x1E4F143A8];
              v25[1] = 3221225472;
              v25[2] = ___ZL46nw_masque_connection_pair_read_outer_datagramsP36NWConcrete_nw_masque_connection_pair_block_invoke_326;
              v25[3] = &unk_1E523F6E0;
              id v26 = (id)v4;
              uint64_t v27 = &v29;
              dispatch_data_apply(v3, v25);
            }
            goto LABEL_19;
          }
        }
        else
        {
          uint64_t v5 = *(unsigned __int16 *)(v4 + 72);
          if (!*(_WORD *)(v4 + 72)) {
            goto LABEL_17;
          }
        }
        __s1[0] = 0;
        __s1[1] = 0;
        int v36 = 0;
        size_t v6 = nw_dispatch_data_copyout_from_offset(v3, (uint64_t)__s1, v5, 1);
        uint64_t v7 = *(void *)(a1 + 32);
        if (v6 == *(unsigned __int16 *)(v7 + 72))
        {
          size_t v8 = v6;
          if (!memcmp(__s1, (const void *)(v7 + 74), v6))
          {
            *((unsigned char *)v30 + 24) = 1;
            if (v8 == *(unsigned __int16 *)(*(void *)(a1 + 32) + 94))
            {
              size_t size = dispatch_data_get_size(v3);
              uint64_t v28 = 0;
              alloc = (void *)dispatch_data_create_alloc();
              v34[0] = 0;
              v34[1] = v34;
              v34[2] = 0x2000000000;
              v34[3] = 0;
              v33[0] = 0;
              v33[1] = v33;
              v33[2] = 0x2000000000;
              v33[3] = v28;
              if (v3)
              {
                *(void *)applier = MEMORY[0x1E4F143A8];
                *(void *)&applier[8] = 0x40000000;
                *(void *)&applier[16] = __nw_dispatch_data_copyout_block_invoke;
                uint64_t v38 = &unk_1E5242B60;
                *((void *)&v39 + 1) = v33;
                size_t v40 = size;
                *(void *)&long long v39 = v34;
                dispatch_data_apply(v3, applier);
              }
              _Block_object_dispose(v33, 8);
              _Block_object_dispose(v34, 8);
              memcpy((void *)(v28 + 1), (const void *)(*(void *)(a1 + 32) + 96), v8);
              uint64_t v10 = alloc;

              if (gLogDatapath)
              {
                uint64_t v20 = __nwlog_obj();
                if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
                {
                  uint64_t v21 = *(void *)(*(void *)(a1 + 32) + 16);
                  *(_DWORD *)applier = 136446466;
                  *(void *)&applier[4] = "nw_masque_connection_pair_read_outer_datagrams_block_invoke";
                  *(_WORD *)&applier[12] = 2114;
                  *(void *)&applier[14] = v21;
                  _os_log_impl(&dword_1830D4000, v20, OS_LOG_TYPE_DEBUG, "%{public}s %{public}@ Replaced with Virtual Client CID before proxying", applier, 0x16u);
                }
              }
              uint64_t v3 = v10;
            }
          }
        }
      }
LABEL_19:
      if (gLogDatapath)
      {
        uint64_t v16 = __nwlog_obj();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v17 = *(void *)(*(void *)(a1 + 32) + 16);
          if (v3) {
            size_t v18 = dispatch_data_get_size(v3);
          }
          else {
            size_t v18 = 0;
          }
          BOOL v19 = " directly";
          if (!*((unsigned char *)v30 + 24)) {
            BOOL v19 = "";
          }
          *(_DWORD *)applier = 136446978;
          *(void *)&applier[4] = "nw_masque_connection_pair_read_outer_datagrams_block_invoke_2";
          *(_WORD *)&applier[12] = 2114;
          *(void *)&applier[14] = v17;
          *(_WORD *)&applier[22] = 2048;
          uint64_t v38 = (void *)v18;
          LOWORD(v39) = 2080;
          *(void *)((char *)&v39 + 2) = v19;
          _os_log_impl(&dword_1830D4000, v16, OS_LOG_TYPE_DEBUG, "%{public}s %{public}@ Proxying %zu bytes%s to client", applier, 0x2Au);
        }
      }
      dispatch_group_enter(*(dispatch_group_t *)(*(void *)(a1 + 32) + 232));
      BOOL v13 = *(NSObject ***)(a1 + 32);
      if (*((unsigned char *)v30 + 24)) {
        os_log_type_t v14 = v13 + 4;
      }
      else {
        os_log_type_t v14 = (NSObject **)&v13[2][6];
      }
      uint64_t v15 = *v14;
      completion[0] = MEMORY[0x1E4F143A8];
      completion[1] = 3221225472;
      completion[2] = ___ZL46nw_masque_connection_pair_read_outer_datagramsP36NWConcrete_nw_masque_connection_pair_block_invoke_329;
      completion[3] = &unk_1E5248CD0;
      uint64_t v24 = v13;
      nw_connection_send(v15, v3, (nw_content_context_t)&__block_literal_global_42249, 1, completion);

      _Block_object_dispose(&v29, 8);
    }
  }
}

void sub_18348334C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  _Block_object_dispose(&a30, 8);
  _Unwind_Resume(a1);
}

void ___ZL44nw_http1_establish_new_connection_for_streamP17nw_protocol_http1P15nw_http1_stream_block_invoke(void *a1, void *a2)
{
  uint64_t v2 = a2;
  if (*(unsigned char *)(*(void *)(a1[4] + 8) + 24))
  {
    if (!*(void *)(*(void *)(a1[5] + 8) + 40) && nw_protocol_options_is_tls(a2))
    {
      if (v2) {
        uint64_t v2 = os_retain(v2);
      }
      uint64_t v4 = *(void *)(a1[5] + 8);
      char v5 = *(unsigned char *)(v4 + 48);
      if (v5)
      {
        size_t v6 = *(void **)(v4 + 40);
        if (v6)
        {
          os_release(v6);
          char v5 = *(unsigned char *)(v4 + 48);
        }
      }
      *(void *)(v4 + 40) = v2;
      *(unsigned char *)(v4 + 48) = v5 | 1;
    }
  }
  else if (nw_protocol_options_get_protocol_handle(a2) == a1[6])
  {
    *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = 1;
  }
}

uint64_t ___ZL38nw_endpoint_transform_start_next_childP30NWConcrete_nw_endpoint_handler_block_invoke(uint64_t a1)
{
  return nw_endpoint_transform_start_next_child(*(NWConcrete_nw_endpoint_handler **)(a1 + 32));
}

void ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  uint64_t v287 = *MEMORY[0x1E4F143B8];
  id v197 = a2;
  uint64_t v7 = a3;
  id v8 = a5;
  nw_content_context_t context = v7;
  if (!v7 || v8) {
    goto LABEL_37;
  }
  if (nw_protocol_copy_http_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_15_74223);
  }
  uint64_t v9 = (id)nw_protocol_copy_http_definition_http_definition;
  nw_protocol_metadata_t v10 = nw_content_context_copy_protocol_metadata(v7, v9);

  nw_protocol_metadata_t v195 = v10;
  if (!v10)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    long long v39 = (id)gLogObj;
    if (os_log_type_enabled(v39, OS_LOG_TYPE_INFO))
    {
      uint64_t v40 = *(void *)(a1 + 32);
      uint64_t v41 = *(void *)(v40 + 48);
      *(_DWORD *)applier = 136446722;
      *(void *)&applier[4] = "nw_masque_read_inner_request_on_queue_block_invoke";
      *(_WORD *)&applier[12] = 2114;
      *(void *)&applier[14] = v40;
      *(_WORD *)&applier[22] = 2112;
      *(void *)int v283 = v41;
      _os_log_impl(&dword_1830D4000, v39, OS_LOG_TYPE_INFO, "%{public}s %{public}@ Received non-HTTP message, cancelling %@", applier, 0x20u);
    }

    nw_masque_connection_cancel_on_queue(*(void **)(a1 + 32), 0);
    goto LABEL_36;
  }
  id v11 = nw_http_metadata_copy_request(v10);
  id v193 = v11;
  if (!v11)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v42 = (id)gLogObj;
    if (os_log_type_enabled(v42, OS_LOG_TYPE_INFO))
    {
      uint64_t v43 = *(void *)(a1 + 32);
      uint64_t v44 = *(void *)(v43 + 48);
      *(_DWORD *)applier = 136446722;
      *(void *)&applier[4] = "nw_masque_read_inner_request_on_queue_block_invoke";
      *(_WORD *)&applier[12] = 2114;
      *(void *)&applier[14] = v43;
      *(_WORD *)&applier[22] = 2112;
      *(void *)int v283 = v44;
      _os_log_impl(&dword_1830D4000, v42, OS_LOG_TYPE_INFO, "%{public}s %{public}@ Received non-request HTTP message, cancelling %@", applier, 0x20u);
    }

    nw_masque_connection_cancel_on_queue(*(void **)(a1 + 32), 0);
    goto LABEL_35;
  }
  v274[0] = MEMORY[0x1E4F143A8];
  v274[1] = 3221225472;
  v274[2] = ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_201;
  v274[3] = &unk_1E5248B60;
  id v275 = *(id *)(a1 + 32);
  id v12 = v11;
  BOOL v13 = v274;
  _nw_http_request_access_method((uint64_t)v12, v13);

  uint64_t v268 = 0;
  uint64_t v269 = &v268;
  uint64_t v270 = 0x3032000000;
  BOOL v271 = __Block_byref_object_copy__29668;
  v272 = __Block_byref_object_dispose__29669;
  id v273 = 0;
  uint64_t v262 = 0;
  BOOL v263 = &v262;
  uint64_t v264 = 0x3032000000;
  uint64_t v265 = __Block_byref_object_copy__29668;
  uint64_t v266 = __Block_byref_object_dispose__29669;
  id v267 = 0;
  uint64_t v256 = 0;
  v257 = &v256;
  uint64_t v258 = 0x3032000000;
  os_log_type_t v259 = __Block_byref_object_copy__29668;
  v260 = __Block_byref_object_dispose__29669;
  id v261 = 0;
  uint64_t v250 = 0;
  BOOL v251 = &v250;
  uint64_t v252 = 0x3032000000;
  BOOL v253 = __Block_byref_object_copy__29668;
  os_log_type_t v254 = __Block_byref_object_dispose__29669;
  id v255 = 0;
  v249[0] = MEMORY[0x1E4F143A8];
  v249[1] = 3221225472;
  v249[2] = ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_203;
  v249[3] = &unk_1E523F5D0;
  v249[4] = &v256;
  v249[5] = &v268;
  id v14 = v12;
  uint64_t v15 = v249;
  _nw_http_fields_access_value_by_name((uint64_t)v14, (unint64_t)"Client-Connection-Id", v15);

  v248[0] = MEMORY[0x1E4F143A8];
  v248[1] = 3221225472;
  v248[2] = ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_2;
  v248[3] = &unk_1E523F5D0;
  v248[4] = &v250;
  v248[5] = &v262;
  id v16 = v14;
  uint64_t v17 = v248;
  _nw_http_fields_access_value_by_name((uint64_t)v16, (unint64_t)"Server-Connection-Id", v17);

  uint64_t v242 = 0;
  uint64_t v243 = &v242;
  uint64_t v244 = 0x3032000000;
  uint64_t v245 = __Block_byref_object_copy__29668;
  os_log_type_t v246 = __Block_byref_object_dispose__29669;
  id v247 = 0;
  v241[0] = MEMORY[0x1E4F143A8];
  v241[1] = 3221225472;
  v241[2] = ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_3;
  v241[3] = &unk_1E5248FD0;
  v241[4] = &v242;
  id v18 = v16;
  BOOL v19 = v241;
  _nw_http_request_access_authority((uint64_t)v18, v19);

  uint64_t v237 = 0;
  v238 = &v237;
  uint64_t v239 = 0x2020000000;
  char v240 = 0;
  uint64_t v233 = 0;
  os_log_type_t v234 = &v233;
  uint64_t v235 = 0x2020000000;
  char v236 = 0;
  v232[0] = MEMORY[0x1E4F143A8];
  v232[1] = 3221225472;
  v232[2] = ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_4;
  v232[3] = &unk_1E523F5D0;
  v232[4] = &v237;
  v232[5] = &v233;
  id v20 = v18;
  uint64_t v21 = v232;
  _nw_http_request_access_extended_connect_protocol((uint64_t)v20, v21);

  uint64_t v281 = 0;
  v231[0] = MEMORY[0x1E4F143A8];
  v231[1] = 3221225472;
  v231[2] = ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_5;
  v231[3] = &__block_descriptor_40_e9_v16__0r_8l;
  v231[4] = &v281;
  id v22 = v20;
  uint64_t v23 = v231;
  _nw_http_fields_access_value_by_name((uint64_t)v22, (unint64_t)"Datagram-Flow-Id", v23);

  uint64_t v225 = 0;
  int v226 = &v225;
  uint64_t v227 = 0x3032000000;
  int v228 = __Block_byref_object_copy__29668;
  uint64_t v229 = __Block_byref_object_dispose__29669;
  id v230 = 0;
  v224[0] = MEMORY[0x1E4F143A8];
  v224[1] = 3221225472;
  v224[2] = ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_6;
  v224[3] = &unk_1E5248FD0;
  v224[4] = &v225;
  id v24 = v22;
  uint64_t v25 = v224;
  _nw_http_request_access_path((uint64_t)v24, v25);

  uint64_t v26 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v26 + 97))
  {
    if (gLogDatapath)
    {
      uint64_t v158 = __nwlog_obj();
      if (os_log_type_enabled(v158, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v159 = *(void *)(a1 + 32);
        *(_DWORD *)applier = 136446466;
        *(void *)&applier[4] = "nw_masque_read_inner_request_on_queue_block_invoke_7";
        *(_WORD *)&applier[12] = 2114;
        *(void *)&applier[14] = v159;
        _os_log_impl(&dword_1830D4000, v158, OS_LOG_TYPE_DEBUG, "%{public}s %{public}@ Reverse proxying, responding 200 OK", applier, 0x16u);
      }

      uint64_t v26 = *(void *)(a1 + 32);
    }
    uint64_t v27 = nw_masque_connection_pair_create((NWConcrete_nw_masque_connection *)v26);
    uint64_t v28 = v27;
    int v29 = v281;
    BYTE2(v27[44]._os_unfair_lock_opaque) = v281;
    if (v29)
    {
      int v30 = BYTE1(v281);
      HIBYTE(v27[44]._os_unfair_lock_opaque) = BYTE1(v281);
      if (v30)
      {
        int v31 = BYTE2(v281);
        LOBYTE(v27[45]._os_unfair_lock_opaque) = BYTE2(v281);
        if (v31)
        {
          int v32 = BYTE3(v281);
          BYTE1(v27[45]._os_unfair_lock_opaque) = BYTE3(v281);
          if (v32)
          {
            int v33 = BYTE4(v281);
            BYTE2(v27[45]._os_unfair_lock_opaque) = BYTE4(v281);
            if (v33)
            {
              int v34 = BYTE5(v281);
              HIBYTE(v27[45]._os_unfair_lock_opaque) = BYTE5(v281);
              if (v34)
              {
                int v35 = BYTE6(v281);
                LOBYTE(v27[46]._os_unfair_lock_opaque) = BYTE6(v281);
                if (v35) {
                  BYTE1(v27[46]._os_unfair_lock_opaque) = 0;
                }
              }
            }
          }
        }
      }
    }
    int v36 = v269[5];
    if (v36)
    {
      *(void *)int buf = 0;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x2000000000;
      uint64_t v286 = 0;
      uint64_t v276 = 0;
      v277 = &v276;
      uint64_t v278 = 0x2000000000;
      v279 = (os_unfair_lock_s *)((char *)v28 + 74);
      *(void *)applier = MEMORY[0x1E4F143A8];
      *(void *)&applier[8] = 0x40000000;
      *(void *)&applier[16] = __nw_dispatch_data_copyout_block_invoke;
      *(void *)int v283 = &unk_1E5242B60;
      *(void *)&v283[16] = &v276;
      uint64_t v284 = 20;
      *(void *)&v283[8] = buf;
      dispatch_data_apply(v36, applier);
      uint64_t v37 = *(void *)(*(void *)&buf[8] + 24);
      _Block_object_dispose(&v276, 8);
      _Block_object_dispose(buf, 8);
      LOWORD(v28[18]._os_unfair_lock_opaque) = v37;
      uint64_t v38 = v257[5];
      *(void *)int buf = 0;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x2000000000;
      uint64_t v286 = 0;
      uint64_t v276 = 0;
      v277 = &v276;
      uint64_t v278 = 0x2000000000;
      v279 = v28 + 29;
      if (v38)
      {
        *(void *)applier = MEMORY[0x1E4F143A8];
        *(void *)&applier[8] = 0x40000000;
        *(void *)&applier[16] = __nw_dispatch_data_copyout_block_invoke;
        *(void *)int v283 = &unk_1E5242B60;
        *(void *)&v283[16] = &v276;
        uint64_t v284 = 20;
        *(void *)&v283[8] = buf;
        dispatch_data_apply(v38, applier);
      }
      _Block_object_dispose(&v276, 8);
      _Block_object_dispose(buf, 8);
      if (gLogDatapath)
      {
        uint64_t v160 = __nwlog_obj();
        if (os_log_type_enabled(v160, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v161 = *(void *)(a1 + 32);
          int os_unfair_lock_opaque_low = LOWORD(v28[18]._os_unfair_lock_opaque);
          *(_DWORD *)applier = 136446722;
          *(void *)&applier[4] = "nw_masque_read_inner_request_on_queue_block_invoke";
          *(_WORD *)&applier[12] = 2114;
          *(void *)&applier[14] = v161;
          *(_WORD *)&applier[22] = 1024;
          *(_DWORD *)int v283 = os_unfair_lock_opaque_low;
          _os_log_impl(&dword_1830D4000, v160, OS_LOG_TYPE_DEBUG, "%{public}s %{public}@ Received client connection ID of length %u", applier, 0x1Cu);
        }
      }
    }
    objc_storeStrong((id *)&v28[60], *(id *)(*(void *)(a1 + 32) + 72));
    LOBYTE(v28[62]._os_unfair_lock_opaque) = 1;
    nw_masque_connection_pair_setup_outer_connection(v28, (void *)v243[5], 17, v24);

    goto LABEL_34;
  }
  if (gLogDatapath)
  {
    id v163 = __nwlog_obj();
    if (os_log_type_enabled(v163, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v164 = *(void *)(a1 + 32);
      uint64_t v165 = v243[5];
      *(_DWORD *)applier = 136446722;
      *(void *)&applier[4] = "nw_masque_read_inner_request_on_queue_block_invoke";
      *(_WORD *)&applier[12] = 2114;
      *(void *)&applier[14] = v164;
      *(_WORD *)&applier[22] = 2112;
      *(void *)int v283 = v165;
      _os_log_impl(&dword_1830D4000, v163, OS_LOG_TYPE_DEBUG, "%{public}s %{public}@ Received authority %@", applier, 0x20u);
    }
  }
  if (!v243[5])
  {
    uint64_t v166 = __nwlog_obj();
    *(_DWORD *)applier = 136446210;
    *(void *)&applier[4] = "nw_masque_read_inner_request_on_queue_block_invoke";
    uint64_t v167 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    LOBYTE(v276) = 0;
    if (__nwlog_fault(v167, buf, &v276))
    {
      if (buf[0] == 17)
      {
        BOOL v168 = __nwlog_obj();
        os_log_type_t v169 = buf[0];
        if (os_log_type_enabled(v168, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_masque_read_inner_request_on_queue_block_invoke";
          _os_log_impl(&dword_1830D4000, v168, v169, "%{public}s called with null authority_endpoint", applier, 0xCu);
        }
      }
      else if ((_BYTE)v276)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v168 = __nwlog_obj();
        os_log_type_t v171 = buf[0];
        BOOL v172 = os_log_type_enabled(v168, (os_log_type_t)buf[0]);
        if (backtrace_string)
        {
          if (v172)
          {
            *(_DWORD *)applier = 136446466;
            *(void *)&applier[4] = "nw_masque_read_inner_request_on_queue_block_invoke";
            *(_WORD *)&applier[12] = 2082;
            *(void *)&applier[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v168, v171, "%{public}s called with null authority_endpoint, dumping backtrace:%{public}s", applier, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_169;
        }
        if (v172)
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_masque_read_inner_request_on_queue_block_invoke";
          _os_log_impl(&dword_1830D4000, v168, v171, "%{public}s called with null authority_endpoint, no backtrace", applier, 0xCu);
        }
      }
      else
      {
        BOOL v168 = __nwlog_obj();
        os_log_type_t v173 = buf[0];
        if (os_log_type_enabled(v168, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_masque_read_inner_request_on_queue_block_invoke";
          _os_log_impl(&dword_1830D4000, v168, v173, "%{public}s called with null authority_endpoint, backtrace limit exceeded", applier, 0xCu);
        }
      }
    }
LABEL_169:
    if (v167) {
      free(v167);
    }
    goto LABEL_34;
  }
  if (*(unsigned char *)(*(void *)(a1 + 32) + 96))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v45 = (id)gLogObj;
    if (os_log_type_enabled(v45, OS_LOG_TYPE_INFO))
    {
      uint64_t v46 = *(void *)(a1 + 32);
      *(_DWORD *)applier = 136446466;
      *(void *)&applier[4] = "nw_masque_read_inner_request_on_queue_block_invoke";
      *(_WORD *)&applier[12] = 2114;
      *(void *)&applier[14] = v46;
      _os_log_impl(&dword_1830D4000, v45, OS_LOG_TYPE_INFO, "%{public}s %{public}@ Dropping request, sending no reply", applier, 0x16u);
    }

    goto LABEL_34;
  }
  id v47 = v24;
  int has_method = _nw_http_request_has_method((uint64_t)v47);
  os_log_type_t v192 = v47;

  if (has_method)
  {
    os_log_type_t v49 = v47;
    if ([(id)v226[5] containsString:@"%"])
    {
      uint64_t v50 = _CFStringCreateByRemovingPercentEncoding();
      if (v50)
      {
        nw_listener_t v51 = __nwlog_obj();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_INFO))
        {
          uint64_t v52 = *(void *)(a1 + 32);
          uint64_t v53 = v226[5];
          *(_DWORD *)applier = 136446978;
          *(void *)&applier[4] = "nw_masque_read_inner_request_on_queue_block_invoke";
          *(_WORD *)&applier[12] = 2114;
          *(void *)&applier[14] = v52;
          *(_WORD *)&applier[22] = 2112;
          *(void *)int v283 = v53;
          *(_WORD *)&v283[8] = 2112;
          *(void *)&v283[10] = v50;
          _os_log_impl(&dword_1830D4000, v51, OS_LOG_TYPE_INFO, "%{public}s %{public}@ decoded path %@ -> %@", applier, 0x2Au);
        }

        uint64_t v54 = (void *)v226[5];
        v226[5] = v50;

        os_log_type_t v49 = v192;
      }
    }
    if (*((unsigned char *)v238 + 24))
    {
      if ([(id)v226[5] hasPrefix:@"/.well-known/masque/udp/"])
      {
        os_log_type_t v55 = [(id)v226[5] substringFromIndex:objc_msgSend(@"/.well-known/masque/udp/", "length")];
        id v56 = [v55 componentsSeparatedByString:@"/"];
        if ((unint64_t)[v56 count] < 2)
        {
          BOOL v58 = 0;
          BOOL v57 = 0;
        }
        else
        {
          BOOL v57 = [v56 objectAtIndexedSubscript:0];
          BOOL v58 = [v56 objectAtIndexedSubscript:1];
        }

        if (v57 && v58)
        {
          if ([v57 isEqualToString:@"*"]
            && [v58 isEqualToString:@"*"])
          {
            os_log_type_t v109 = __nwlog_obj();
            if (os_log_type_enabled(v109, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v110 = *(void *)(a1 + 32);
              *(_DWORD *)applier = 136446466;
              *(void *)&applier[4] = "nw_masque_read_inner_request_on_queue_block_invoke_2";
              *(_WORD *)&applier[12] = 2114;
              *(void *)&applier[14] = v110;
              _os_log_impl(&dword_1830D4000, v109, OS_LOG_TYPE_DEBUG, "%{public}s %{public}@ requested listener mode", applier, 0x16u);
            }

            uint64_t well_known = (uint64_t)nw_masque_listener_pair_create(*(NWConcrete_nw_masque_connection **)(a1 + 32));
            *(unsigned char *)(well_known + 84) = 1;
            nw_masque_listener_pair_setup_outer_connection_group((void *)well_known, v192);
            nw_masque_listener_pair_read_inner((NWConcrete_nw_masque_listener_pair *)well_known);
            int v96 = v57;
            goto LABEL_106;
          }
          uint64_t well_known = (uint64_t)nw_masque_connection_pair_create(*(NWConcrete_nw_masque_connection **)(a1 + 32));
          *(unsigned char *)(well_known + 221) = 1;
          host = nw_endpoint_create_host((const char *)[v57 UTF8String], (const char *)objc_msgSend(v58, "UTF8String"));
          nw_masque_connection_pair_setup_outer_connection((void *)well_known, host, 17, v192);
          int v96 = v57;
LABEL_105:

LABEL_106:
          goto LABEL_34;
        }
        int v96 = v57;
      }
      else
      {
        int v96 = 0;
        BOOL v58 = 0;
      }
      if (gLogDatapath)
      {
        uint64_t v174 = __nwlog_obj();
        if (os_log_type_enabled(v174, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v175 = *(void *)(a1 + 32);
          uint64_t v176 = v226[5];
          *(_DWORD *)applier = 136446722;
          *(void *)&applier[4] = "nw_masque_read_inner_request_on_queue_block_invoke";
          *(_WORD *)&applier[12] = 2114;
          *(void *)&applier[14] = v175;
          *(_WORD *)&applier[22] = 2112;
          *(void *)int v283 = v176;
          _os_log_impl(&dword_1830D4000, v174, OS_LOG_TYPE_DEBUG, "%{public}s %{public}@ Failed to parse target out of path: %@", applier, 0x20u);
        }
      }
      uint64_t well_known = _nw_http_response_create_well_known(400);
      host = nw_http_create_metadata_for_response((void *)well_known);
      os_log_type_t v113 = nw_content_context_create("response");
      nw_content_context_set_metadata_for_protocol(v113, host);
      os_log_type_t v114 = *(void **)(a1 + 32);
      os_log_type_t v115 = v114[6];
      v222[0] = MEMORY[0x1E4F143A8];
      v222[1] = 3221225472;
      v222[2] = ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_218;
      v222[3] = &unk_1E5248CD0;
      v223 = v114;
      nw_connection_send(v115, 0, v113, 1, v222);

      goto LABEL_105;
    }
    if (!*((unsigned char *)v234 + 24))
    {
      os_log_type_t v116 = nw_masque_connection_pair_create(*(NWConcrete_nw_masque_connection **)(a1 + 32));
      nw_masque_connection_pair_setup_outer_connection(v116, (void *)v243[5], 6, v49);

      goto LABEL_34;
    }
    if ([(id)v226[5] hasPrefix:@"/.well-known/masque/ip/"])
    {
      int v92 = [(id)v226[5] substringFromIndex:objc_msgSend(@"/.well-known/masque/ip/", "length")];
      uint64_t v93 = [v92 componentsSeparatedByString:@"/"];
      if ((unint64_t)[v93 count] < 2)
      {
        os_log_type_t v95 = 0;
        os_log_type_t v94 = 0;
      }
      else
      {
        os_log_type_t v94 = [v93 objectAtIndexedSubscript:0];
        os_log_type_t v95 = [v93 objectAtIndexedSubscript:1];
      }

      if (v94 && v95)
      {
        unsigned __int8 v131 = [v95 integerValue];
        BOOL v132 = nw_masque_connection_pair_create(*(NWConcrete_nw_masque_connection **)(a1 + 32));
        metadata_for_response = nw_endpoint_create_host((const char *)[v94 UTF8String], "0");
        nw_masque_connection_pair_setup_outer_connection(v132, metadata_for_response, v131, v192);
        os_log_type_t v117 = v94;
LABEL_122:

        goto LABEL_34;
      }
      os_log_type_t v117 = v94;
    }
    else
    {
      os_log_type_t v117 = 0;
      os_log_type_t v95 = 0;
    }
    if (gLogDatapath)
    {
      uint64_t v180 = __nwlog_obj();
      if (os_log_type_enabled(v180, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v181 = *(void *)(a1 + 32);
        uint64_t v182 = v226[5];
        *(_DWORD *)applier = 136446722;
        *(void *)&applier[4] = "nw_masque_read_inner_request_on_queue_block_invoke";
        *(_WORD *)&applier[12] = 2114;
        *(void *)&applier[14] = v181;
        *(_WORD *)&applier[22] = 2112;
        *(void *)int v283 = v182;
        _os_log_impl(&dword_1830D4000, v180, OS_LOG_TYPE_DEBUG, "%{public}s %{public}@ Failed to parse target out of path: %@", applier, 0x20u);
      }
    }
    BOOL v132 = (void *)_nw_http_response_create_well_known(400);
    metadata_for_response = nw_http_create_metadata_for_response(v132);
    BOOL v134 = nw_content_context_create("response");
    nw_content_context_set_metadata_for_protocol(v134, metadata_for_response);
    BOOL v135 = *(void **)(a1 + 32);
    os_log_type_t v136 = v135[6];
    v220[0] = MEMORY[0x1E4F143A8];
    v220[1] = 3221225472;
    v220[2] = ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_227;
    v220[3] = &unk_1E5248CD0;
    int v221 = v135;
    nw_connection_send(v136, 0, v134, 1, v220);

    goto LABEL_122;
  }
  id v59 = v47;
  if (nw_http_request_has_method(v47, (uint64_t)"CONNECT-UDP"))
  {
    uint64_t v60 = *(void *)(a1 + 32);
    if (*(void *)(v60 + 72))
    {
      uint64_t v61 = nw_masque_connection_pair_create((NWConcrete_nw_masque_connection *)v60);
      os_log_type_t v62 = v61;
      int v63 = v281;
      BYTE2(v61[44]._os_unfair_lock_opaque) = v281;
      if (v63)
      {
        int v64 = BYTE1(v281);
        HIBYTE(v61[44]._os_unfair_lock_opaque) = BYTE1(v281);
        if (v64)
        {
          int v65 = BYTE2(v281);
          LOBYTE(v61[45]._os_unfair_lock_opaque) = BYTE2(v281);
          if (v65)
          {
            int v66 = BYTE3(v281);
            BYTE1(v61[45]._os_unfair_lock_opaque) = BYTE3(v281);
            if (v66)
            {
              int v67 = BYTE4(v281);
              BYTE2(v61[45]._os_unfair_lock_opaque) = BYTE4(v281);
              if (v67)
              {
                int v68 = BYTE5(v281);
                HIBYTE(v61[45]._os_unfair_lock_opaque) = BYTE5(v281);
                if (v68)
                {
                  int v69 = BYTE6(v281);
                  LOBYTE(v61[46]._os_unfair_lock_opaque) = BYTE6(v281);
                  if (v69) {
                    BYTE1(v61[46]._os_unfair_lock_opaque) = 0;
                  }
                }
              }
            }
          }
        }
      }
      id v70 = v269[5];
      if (v70)
      {
        LOWORD(v62[18]._os_unfair_lock_opaque) = nw_dispatch_data_copyout(v70, (uint64_t)&v62[18]._os_unfair_lock_opaque + 2, 20);
        nw_dispatch_data_copyout(v257[5], (uint64_t)&v62[29], 20);
        if (gLogDatapath)
        {
          uint64_t v177 = __nwlog_obj();
          if (os_log_type_enabled(v177, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v178 = *(void *)(a1 + 32);
            int v179 = LOWORD(v62[18]._os_unfair_lock_opaque);
            *(_DWORD *)applier = 136446722;
            *(void *)&applier[4] = "nw_masque_read_inner_request_on_queue_block_invoke_2";
            *(_WORD *)&applier[12] = 2114;
            *(void *)&applier[14] = v178;
            *(_WORD *)&applier[22] = 1024;
            *(_DWORD *)int v283 = v179;
            _os_log_impl(&dword_1830D4000, v177, OS_LOG_TYPE_DEBUG, "%{public}s %{public}@ Received client connection ID of length %u", applier, 0x1Cu);
          }
        }
      }
      objc_storeStrong((id *)&v62[60], *(id *)(*(void *)(a1 + 32) + 72));
      nw_masque_connection_pair_setup_outer_connection(v62, (void *)v243[5], 17, v192);
      *(unsigned char *)(*(void *)(a1 + 32) + 97) = 1;
    }
    else if ((_BYTE)v281)
    {
      if (v263[5])
      {
        nw_endpoint_t v102 = nw_connection_copy_endpoint(*(nw_connection_t *)(v60 + 48));
        id v103 = nw_masque_copy_matching_connection_pair(*(void **)(a1 + 32), v102, (uint64_t)&v281);
        os_log_type_t v104 = v103;
        if (v103 && *((_WORD *)v103 + 36))
        {
          objc_storeStrong((id *)v103 + 3, *(id *)(*(void *)(a1 + 32) + 48));
          v104[68] = nw_dispatch_data_copyout(v263[5], (uint64_t)(v104 + 69), 20);
          nw_dispatch_data_copyout(v251[5], (uint64_t)(v104 + 79), 20);
          if (gLogDatapath)
          {
            uint64_t v183 = __nwlog_obj();
            if (os_log_type_enabled(v183, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v184 = *(void *)(a1 + 32);
              int v185 = (unsigned __int16)v104[68];
              *(_DWORD *)applier = 136447234;
              *(void *)&applier[4] = "nw_masque_read_inner_request_on_queue_block_invoke_2";
              *(_WORD *)&applier[12] = 2114;
              *(void *)&applier[14] = v184;
              *(_WORD *)&applier[22] = 1024;
              *(_DWORD *)int v283 = v185;
              *(_WORD *)&v283[4] = 2080;
              *(void *)&v283[6] = &v281;
              *(_WORD *)&v283[14] = 2112;
              *(void *)&v283[16] = v102;
              _os_log_impl(&dword_1830D4000, v183, OS_LOG_TYPE_DEBUG, "%{public}s %{public}@ Received server connection ID of length %u for datagram flow %s from %@", applier, 0x30u);
            }
          }
          options = nw_demux_create_options();
          nw_demux_options_add_pattern(options, 1, (unsigned __int16)v104[68], (uint64_t)(v104 + 69), 0);
          nw_masque_connection_pair_setup_inner_direct_connections(v104, options);
          uint64_t v106 = _nw_http_response_create_well_known(200);
          nw_http_fields_append(v106, (uint64_t)"Datagram-Flow-Id", (uint64_t)&v281);
          nw_http_fields_append(v106, (uint64_t)"Server-Connection-Id", (uint64_t)(v104 + 79));
          uint64_t v107 = nw_http_create_metadata_for_response(v106);
          uint64_t v108 = nw_content_context_create("response");
          nw_content_context_set_metadata_for_protocol(v108, v107);
          nw_connection_send(*(nw_connection_t *)(*(void *)(a1 + 32) + 48), 0, v108, 1, &__block_literal_global_24376);
        }
        else
        {
          os_log_type_t v137 = __nwlog_obj();
          if (os_log_type_enabled(v137, OS_LOG_TYPE_ERROR))
          {
            uint64_t v138 = *(void *)(a1 + 32);
            *(_DWORD *)applier = 136446978;
            *(void *)&applier[4] = "nw_masque_read_inner_request_on_queue_block_invoke";
            *(_WORD *)&applier[12] = 2114;
            *(void *)&applier[14] = v138;
            *(_WORD *)&applier[22] = 2080;
            *(void *)int v283 = &v281;
            *(_WORD *)&v283[8] = 2112;
            *(void *)&v283[10] = v102;
            _os_log_impl(&dword_1830D4000, v137, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ Rejecting server connection ID for unknown datagram flow %s from %@", applier, 0x2Au);
          }

          options = (void *)_nw_http_response_create_well_known(501);
          uint64_t v106 = nw_http_create_metadata_for_response(options);
          uint64_t v107 = nw_content_context_create("response");
          nw_content_context_set_metadata_for_protocol(v107, v106);
          os_log_type_t v139 = *(void **)(a1 + 32);
          os_log_type_t v140 = v139[6];
          v216[0] = MEMORY[0x1E4F143A8];
          v216[1] = 3221225472;
          v216[2] = ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_230;
          v216[3] = &unk_1E5248CD0;
          int v217 = v139;
          nw_connection_send(v140, 0, v107, 1, v216);
          uint64_t v108 = v217;
        }
      }
      else
      {
        os_log_type_t v141 = nw_masque_connection_pair_create((NWConcrete_nw_masque_connection *)v60);
        os_log_type_t v142 = v141;
        int v143 = v281;
        BYTE2(v141[44]._os_unfair_lock_opaque) = v281;
        if (v143)
        {
          int v144 = BYTE1(v281);
          HIBYTE(v141[44]._os_unfair_lock_opaque) = BYTE1(v281);
          if (v144)
          {
            int v145 = BYTE2(v281);
            LOBYTE(v141[45]._os_unfair_lock_opaque) = BYTE2(v281);
            if (v145)
            {
              int v146 = BYTE3(v281);
              BYTE1(v141[45]._os_unfair_lock_opaque) = BYTE3(v281);
              if (v146)
              {
                int v147 = BYTE4(v281);
                BYTE2(v141[45]._os_unfair_lock_opaque) = BYTE4(v281);
                if (v147)
                {
                  int v148 = BYTE5(v281);
                  HIBYTE(v141[45]._os_unfair_lock_opaque) = BYTE5(v281);
                  if (v148)
                  {
                    int v149 = BYTE6(v281);
                    LOBYTE(v141[46]._os_unfair_lock_opaque) = BYTE6(v281);
                    if (v149) {
                      BYTE1(v141[46]._os_unfair_lock_opaque) = 0;
                    }
                  }
                }
              }
            }
          }
        }
        BOOL v150 = v269[5];
        if (v150)
        {
          LOWORD(v142[18]._os_unfair_lock_opaque) = nw_dispatch_data_copyout(v150, (uint64_t)&v142[18]._os_unfair_lock_opaque + 2, 20);
          nw_dispatch_data_copyout(v257[5], (uint64_t)&v142[29], 20);
          if (gLogDatapath)
          {
            BOOL v186 = __nwlog_obj();
            if (os_log_type_enabled(v186, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v187 = *(void *)(a1 + 32);
              int v188 = LOWORD(v142[18]._os_unfair_lock_opaque);
              *(_DWORD *)applier = 136446722;
              *(void *)&applier[4] = "nw_masque_read_inner_request_on_queue_block_invoke_2";
              *(_WORD *)&applier[12] = 2114;
              *(void *)&applier[14] = v187;
              *(_WORD *)&applier[22] = 1024;
              *(_DWORD *)int v283 = v188;
              _os_log_impl(&dword_1830D4000, v186, OS_LOG_TYPE_DEBUG, "%{public}s %{public}@ Received client connection ID of length %u", applier, 0x1Cu);
            }

            id v59 = v192;
          }
        }
        nw_masque_connection_pair_setup_outer_connection(v142, (void *)v243[5], 17, v59);
      }
    }
    else
    {
      BOOL v126 = (void *)_nw_http_response_create_well_known(501);
      uint64_t v127 = nw_http_create_metadata_for_response(v126);
      BOOL v128 = nw_content_context_create("response");
      nw_content_context_set_metadata_for_protocol(v128, v127);
      os_log_type_t v129 = *(void **)(a1 + 32);
      BOOL v130 = v129[6];
      v218[0] = MEMORY[0x1E4F143A8];
      v218[1] = 3221225472;
      v218[2] = ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_229;
      v218[3] = &unk_1E5248CD0;
      v219 = v129;
      nw_connection_send(v130, 0, v128, 1, v218);
    }
    goto LABEL_34;
  }
  if (!nw_http_request_has_method(v47, (uint64_t)"POST"))
  {
    os_log_type_t v97 = (void *)_nw_http_response_create_well_known(501);
    os_log_type_t v98 = nw_http_create_metadata_for_response(v97);
    BOOL v99 = nw_content_context_create("response");
    nw_content_context_set_metadata_for_protocol(v99, v98);
    long long v100 = *(void **)(a1 + 32);
    long long v101 = v100[6];
    completion[0] = MEMORY[0x1E4F143A8];
    completion[1] = 3221225472;
    completion[2] = ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_2_267;
    completion[3] = &unk_1E5248CD0;
    nw_protocol_options_t v201 = v100;
    nw_connection_send(v101, 0, v99, 1, completion);

    goto LABEL_34;
  }
  v189 = [NSString stringWithFormat:@"https://host.com%@", v226[5]];
  BOOL v190 = (void *)[objc_alloc(MEMORY[0x1E4F1CB10]) initWithString:v189];
  BOOL v191 = [v190 query];
  [v191 componentsSeparatedByString:@"&"];
  long long v214 = 0u;
  long long v215 = 0u;
  long long v212 = 0u;
  long long v213 = 0u;
  id v71 = (id)objc_claimAutoreleasedReturnValue();
  uint64_t v72 = [v71 countByEnumeratingWithState:&v212 objects:v280 count:16];
  if (!v72)
  {

    v194 = 0;
    uint64_t v196 = 0;
    goto LABEL_111;
  }
  uint64_t v196 = 0;
  v194 = 0;
  uint64_t v73 = *(void *)v213;
  do
  {
    for (uint64_t i = 0; i != v72; ++i)
    {
      if (*(void *)v213 != v73) {
        objc_enumerationMutation(v71);
      }
      os_log_type_t v75 = [*(id *)(*((void *)&v212 + 1) + 8 * i) componentsSeparatedByString:@"="];
      if ([v75 count] == 2)
      {
        BOOL v76 = [v75 firstObject];
        int v77 = [v76 isEqualToString:@"targethost"];

        if (v77)
        {
          uint64_t v78 = [v75 lastObject];
          unsigned int v79 = v196;
          uint64_t v196 = (void *)v78;
LABEL_73:

          goto LABEL_74;
        }
      }
      if ([v75 count] == 2)
      {
        uint64_t v80 = [v75 firstObject];
        int v81 = [v80 isEqualToString:@"targetpath"];

        if (v81)
        {
          uint64_t v82 = [v75 lastObject];
          unsigned int v79 = v194;
          v194 = (void *)v82;
          goto LABEL_73;
        }
      }
LABEL_74:
    }
    uint64_t v72 = [v71 countByEnumeratingWithState:&v212 objects:v280 count:16];
  }
  while (v72);

  if (v196 && v194)
  {
    BOOL v83 = __nwlog_obj();
    if (os_log_type_enabled(v83, OS_LOG_TYPE_INFO))
    {
      uint64_t v84 = *(void *)(a1 + 32);
      *(_DWORD *)applier = 136446978;
      *(void *)&applier[4] = "nw_masque_read_inner_request_on_queue_block_invoke";
      *(_WORD *)&applier[12] = 2114;
      *(void *)&applier[14] = v84;
      *(_WORD *)&applier[22] = 2112;
      *(void *)int v283 = v196;
      *(_WORD *)&v283[8] = 2112;
      *(void *)&v283[10] = v194;
      _os_log_impl(&dword_1830D4000, v83, OS_LOG_TYPE_INFO, "%{public}s %{public}@ Parsed target host %@ and path %@", applier, 0x2Au);
    }

    BOOL v85 = [NSString stringWithFormat:@"https://%@%@", v196, v194];
    os_log_type_t v86 = (void *)[objc_alloc(MEMORY[0x1E4F1CB10]) initWithString:v85];
    unsigned int v87 = (void *)[objc_alloc(MEMORY[0x1E4F18D50]) initWithURL:v86];
    [v87 setHTTPMethod:@"POST"];
    *(void *)applier = 0;
    *(void *)&applier[8] = applier;
    *(_DWORD *)int v283 = 0;
    *(void *)&applier[16] = 0x2020000000;
    v209[0] = MEMORY[0x1E4F143A8];
    v209[1] = 3221225472;
    v209[2] = ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_254;
    v209[3] = &unk_1E523F618;
    id v88 = v87;
    id v210 = v88;
    int v211 = applier;
    nw_http_fields_enumerate(v192, v209);
    unsigned int v89 = *(_DWORD *)(*(void *)&applier[8] + 24);
    if (v89)
    {
      os_log_type_t v90 = *(void **)(*(void *)(a1 + 32) + 48);
      v204[0] = MEMORY[0x1E4F143A8];
      v204[1] = 3221225472;
      v204[2] = ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_2_260;
      v204[3] = &unk_1E5248D98;
      id v205 = v88;
      id v206 = *(id *)(a1 + 32);
      nw_connection_receive_internal(v90, 0, v89, v89, v204);

      BOOL v91 = v205;
    }
    else
    {
      os_log_type_t v151 = __nwlog_obj();
      if (os_log_type_enabled(v151, OS_LOG_TYPE_ERROR))
      {
        uint64_t v152 = *(void *)(a1 + 32);
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_masque_read_inner_request_on_queue_block_invoke_2";
        *(_WORD *)&unsigned char buf[12] = 2114;
        *(void *)&buf[14] = v152;
        _os_log_impl(&dword_1830D4000, v151, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ Request missing content length", buf, 0x16u);
      }

      BOOL v91 = (void *)_nw_http_response_create_well_known(501);
      os_log_type_t v153 = nw_http_create_metadata_for_response(v91);
      os_log_type_t v154 = nw_content_context_create("response");
      os_log_type_t v155 = v153;
      nw_content_context_set_metadata_for_protocol(v154, v153);
      os_log_type_t v156 = *(void **)(a1 + 32);
      unsigned int v157 = v156[6];
      v207[0] = MEMORY[0x1E4F143A8];
      v207[1] = 3221225472;
      v207[2] = ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_259;
      v207[3] = &unk_1E5248CD0;
      uint64_t v208 = v156;
      nw_connection_send(v157, 0, v154, 1, v207);
    }
    _Block_object_dispose(applier, 8);

    if (v89) {
      goto LABEL_142;
    }

    goto LABEL_34;
  }
LABEL_111:
  BOOL v118 = __nwlog_obj();
  if (os_log_type_enabled(v118, OS_LOG_TYPE_ERROR))
  {
    uint64_t v119 = *(void *)(a1 + 32);
    uint64_t v120 = v226[5];
    *(_DWORD *)applier = 136446722;
    *(void *)&applier[4] = "nw_masque_read_inner_request_on_queue_block_invoke_2";
    *(_WORD *)&applier[12] = 2114;
    *(void *)&applier[14] = v119;
    *(_WORD *)&applier[22] = 2112;
    *(void *)int v283 = v120;
    _os_log_impl(&dword_1830D4000, v118, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ Failed to parse target host and path out of request path: %@", applier, 0x20u);
  }

  BOOL v121 = (void *)_nw_http_response_create_well_known(501);
  os_log_type_t v122 = nw_http_create_metadata_for_response(v121);
  os_log_type_t v123 = nw_content_context_create("response");
  nw_content_context_set_metadata_for_protocol(v123, v122);
  BOOL v124 = *(void **)(a1 + 32);
  char v125 = v124[6];
  v202[0] = MEMORY[0x1E4F143A8];
  v202[1] = 3221225472;
  v202[2] = ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_266;
  v202[3] = &unk_1E5248CD0;
  nw_protocol_definition_t v203 = v124;
  nw_connection_send(v125, 0, v123, 1, v202);

LABEL_142:
LABEL_34:
  _Block_object_dispose(&v225, 8);

  _Block_object_dispose(&v233, 8);
  _Block_object_dispose(&v237, 8);
  _Block_object_dispose(&v242, 8);

  _Block_object_dispose(&v250, 8);
  _Block_object_dispose(&v256, 8);

  _Block_object_dispose(&v262, 8);
  _Block_object_dispose(&v268, 8);

LABEL_35:
LABEL_36:

  id v8 = 0;
LABEL_37:
}

void sub_18348570C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, uint64_t a14, void *a15, void *a16, uint64_t a17, void *a18, void *a19, void *a20,_Unwind_Exception *exception_objecta,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,void *a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49)
{
  _Block_object_dispose((const void *)(v56 - 224), 8);
  _Block_object_dispose(&STACK[0x260], 8);

  _Block_object_dispose(&STACK[0x2E8], 8);
  _Block_object_dispose(&STACK[0x308], 8);
  _Block_object_dispose(&STACK[0x350], 8);

  _Block_object_dispose(&STACK[0x3E0], 8);
  _Block_object_dispose(&STACK[0x410], 8);

  _Block_object_dispose(&STACK[0x440], 8);
  _Block_object_dispose(&STACK[0x470], 8);

  _Unwind_Resume(a1);
}

uint64_t ___ZL37nw_data_transfer_report_collect_innerP34NWConcrete_nw_data_transfer_reportPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvS0_Eb_block_invoke_239(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

void ___ZL36nw_socks5_connection_cancel_on_queueP31NWConcrete_nw_socks5_connectionPU22objcproto11OS_nw_error8NSObject_block_invoke(uint64_t a1, char a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  char v5 = *(NSObject **)(v4 + 144);
  if (v5)
  {
    nw_connection_cancel(v5);
    uint64_t v6 = *(void *)(a1 + 32);
    uint64_t v7 = *(void **)(v6 + 144);
    *(void *)(v6 + 144) = 0;

    uint64_t v4 = *(void *)(a1 + 32);
  }
  if ((*(unsigned char *)(v4 + 160) & 0x90) != 0) {
    a2 = 0;
  }
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  v8[2] = ___ZL36nw_socks5_connection_cancel_on_queueP31NWConcrete_nw_socks5_connectionPU22objcproto11OS_nw_error8NSObject_block_invoke_2;
  v8[3] = &unk_1E524BAA8;
  id v9 = (id)v4;
  nw_socks5_connection_drain_and_cancel_in_on_queue(v9, a2, v8);
}

void sub_183485D10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void ___ZL35nw_socks5_connection_start_on_queueP31NWConcrete_nw_socks5_connectionPU27objcproto16OS_dispatch_data8NSObject_block_invoke(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(unsigned __int8 *)(v2 + 56);
  if (v3 != 200)
  {
    if (v3 == 255) {
      return;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = (id)gLogObj;
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_12;
    }
    uint64_t v5 = *(void *)(a1 + 32);
    int v11 = 136446466;
    id v12 = "nw_socks5_connection_start_on_queue_block_invoke";
    __int16 v13 = 2114;
    uint64_t v14 = v5;
    uint64_t v6 = "%{public}s %{public}@ in connection read close before proxy connection ready, cancelling";
    goto LABEL_11;
  }
  int v7 = *(char *)(v2 + 160);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v4 = (id)gLogObj;
  BOOL v8 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v7 < 0)
  {
    if (!v8)
    {
LABEL_12:

      nw_socks5_connection_cancel_on_queue(*(void **)(a1 + 32), 0);
      return;
    }
    uint64_t v10 = *(void *)(a1 + 32);
    int v11 = 136446466;
    id v12 = "nw_socks5_connection_start_on_queue_block_invoke";
    __int16 v13 = 2114;
    uint64_t v14 = v10;
    uint64_t v6 = "%{public}s %{public}@ in connection read close for associated UDP connection, cancelling";
LABEL_11:
    _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&v11, 0x16u);
    goto LABEL_12;
  }
  if (v8)
  {
    uint64_t v9 = *(void *)(a1 + 32);
    int v11 = 136446466;
    id v12 = "nw_socks5_connection_start_on_queue_block_invoke";
    __int16 v13 = 2114;
    uint64_t v14 = v9;
    _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ ignoring in connection read close event", (uint8_t *)&v11, 0x16u);
  }
}

BOOL ___ZL34nw_protocol_http3_stream_connectedP11nw_protocolS0__block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  BOOL is_quic_stream = nw_protocol_metadata_is_quic_stream(a3);
  if (is_quic_stream)
  {
    uint64_t v6 = a3 ? os_retain(a3) : 0;
    *(void *)(*(void *)(a1 + 32) + 416) = v6;
    uint64_t id = nw_quic_stream_get_id(a3);
    uint64_t v8 = *(void *)(a1 + 32);
    *(void *)(v8 + 240) = id;
    if ((*(_WORD *)(v8 + 736) & 0x800) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v9 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        uint64_t v10 = *(void *)(a1 + 32);
        int v11 = (const char *)(v10 + 636);
        id v12 = "";
        if (!v10) {
          int v11 = "";
        }
        int v13 = *(_DWORD *)(*(void *)(v10 + 336) + 1280);
        uint64_t v14 = *(void *)(v10 + 240);
        if (v10) {
          id v12 = " ";
        }
        int v16 = 136447746;
        uint64_t v17 = "nw_protocol_http3_stream_connected_block_invoke";
        __int16 v18 = 2082;
        BOOL v19 = v11;
        __int16 v20 = 2080;
        uint64_t v21 = v12;
        __int16 v22 = 1024;
        int v23 = v13;
        __int16 v24 = 2048;
        uint64_t v25 = v14;
        __int16 v26 = 2048;
        uint64_t v27 = v10;
        __int16 v28 = 2048;
        uint64_t v29 = v14;
        _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%llu> http3 stream %p assigned ID %llu", (uint8_t *)&v16, 0x44u);
      }
    }
  }
  return !is_quic_stream;
}

uint64_t ___ZL34nw_endpoint_proxy_complete_resolveP30NWConcrete_nw_endpoint_handler_block_invoke_160(uint64_t a1, uint64_t a2, void *a3)
{
  int v3 = a3;
  uint64_t v194 = *MEMORY[0x1E4F143B8];
  id v170 = a3;
  int mode = nw_proxy_config_get_mode(v170);
  if (mode != 4 && mode != 1) {
    goto LABEL_103;
  }
  int v7 = mode;
  if (*(unsigned char *)(a1 + 56) && !*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)) {
    goto LABEL_100;
  }
  uint64_t v8 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
  uint64_t v9 = (NWConcrete_nw_endpoint_handler *)*(id *)(a1 + 32);
  id v10 = v170;
  id v166 = v8;
  os_log_type_t v171 = v9;
  uint64_t v160 = v10;
  os_log_type_t v169 = nw_endpoint_handler_copy_proxy(v9);
  uint64_t v158 = a1;
  uint64_t v159 = v3;
  int v157 = v7;
  if (!v10)
  {
    int v92 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v178 = "nw_endpoint_proxy_add_child_for_config";
    uint64_t v93 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(iterate_block[0]) = 16;
    LOBYTE(v193) = 0;
    if (__nwlog_fault(v93, iterate_block, &v193))
    {
      if (LOBYTE(iterate_block[0]) == 17)
      {
        os_log_type_t v94 = __nwlog_obj();
        os_log_type_t v95 = iterate_block[0];
        if (os_log_type_enabled(v94, iterate_block[0]))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v178 = "nw_endpoint_proxy_add_child_for_config";
          _os_log_impl(&dword_1830D4000, v94, v95, "%{public}s called with null config", buf, 0xCu);
        }
      }
      else
      {
        if ((_BYTE)v193)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          os_log_type_t v112 = __nwlog_obj();
          os_log_type_t v113 = iterate_block[0];
          BOOL v114 = os_log_type_enabled(v112, iterate_block[0]);
          if (backtrace_string)
          {
            if (v114)
            {
              *(_DWORD *)int buf = 136446466;
              uint64_t v178 = "nw_endpoint_proxy_add_child_for_config";
              __int16 v179 = 2082;
              uint64_t v180 = backtrace_string;
              _os_log_impl(&dword_1830D4000, v112, v113, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
          }
          else
          {
            if (v114)
            {
              *(_DWORD *)int buf = 136446210;
              uint64_t v178 = "nw_endpoint_proxy_add_child_for_config";
              _os_log_impl(&dword_1830D4000, v112, v113, "%{public}s called with null config, no backtrace", buf, 0xCu);
            }
          }
          goto LABEL_173;
        }
        os_log_type_t v94 = __nwlog_obj();
        os_log_type_t v129 = iterate_block[0];
        if (os_log_type_enabled(v94, iterate_block[0]))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v178 = "nw_endpoint_proxy_add_child_for_config";
          _os_log_impl(&dword_1830D4000, v94, v129, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_173:
    if (v93) {
      free(v93);
    }
    goto LABEL_99;
  }
  int v11 = v10;
  int v12 = v11[38];

  int v13 = v11;
  uint64_t v14 = v13;
  int v15 = 1;
  switch(v11[38])
  {
    case 1:
      int v15 = v13[39];
      break;
    case 2:
      int v15 = 1002;
      break;
    case 3:
      int v15 = 1001;
      break;
    case 4:
      break;
    default:
      int v15 = 0;
      break;
  }

  nw_endpoint_t v16 = nw_endpoint_handler_copy_endpoint(v171);
  nw_endpoint_t v17 = v16;
  nw_endpoint_t v155 = v16;
  int v164 = v12;
  obj = v8;
  if (v12 == 1)
  {
    __int16 v18 = v14;
    id v19 = v18[5];

    nw_endpoint_t v167 = (nw_endpoint_t)nw_endpoint_copy(v19);
    if (v15 != 2001) {
      nw_endpoint_set_parent_endpoint(v167, v17, 1);
    }
    nw_endpoint_set_do_not_redact(v167);
  }
  else if (v12 == 4)
  {
    nw_endpoint_t v167 = v16;
  }
  else
  {
    if ((nw_endpoint_handler_get_logging_disabled(v171) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      __int16 v20 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        id_string = nw_endpoint_handler_get_id_string(v171);
        __int16 v22 = nw_endpoint_handler_dry_run_string(v171);
        nw_endpoint_t v23 = nw_endpoint_handler_copy_endpoint(v171);
        int v168 = v15;
        logging_description = nw_endpoint_get_logging_description(v23);
        uint64_t v25 = nw_endpoint_handler_state_string(v171);
        __int16 v26 = nw_endpoint_handler_mode_string(v171);
        id v27 = nw_endpoint_handler_copy_current_path(v171);
        *(_DWORD *)int buf = 136448002;
        uint64_t v178 = "nw_endpoint_proxy_add_child_for_config";
        __int16 v179 = 2082;
        uint64_t v180 = (void *)id_string;
        __int16 v181 = 2082;
        uint64_t v182 = v22;
        __int16 v183 = 2082;
        uint64_t v184 = logging_description;
        __int16 v185 = 2082;
        BOOL v186 = v25;
        __int16 v187 = 2082;
        int v188 = v26;
        __int16 v189 = 2114;
        id v190 = v27;
        __int16 v191 = 1024;
        LODWORD(v192) = v164;
        _os_log_impl(&dword_1830D4000, v20, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] invalid proxy mode %u", buf, 0x4Eu);

        int v15 = v168;
      }
    }
    nw_endpoint_t v167 = 0;
  }
  id v28 = nw_endpoint_handler_copy_parameters(v171);
  BOOL v29 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]((id *)[NWConcrete_nw_parameters alloc], v28, 0, 0);

  uint64_t v30 = nw_parameters_copy_default_protocol_stack((nw_parameters_t)v29);
  options = nw_protocol_stack_copy_transport_protocol(v30);
  id v163 = v30;
  nw_protocol_options_t v161 = nw_protocol_stack_copy_internet_protocol(v30);
  id v31 = nw_endpoint_handler_copy_current_path(v171);
  long long v193 = 0uLL;
  os_log_type_t v156 = v31;
  if (nw_path_get_client_id(v31, &v193)) {
    nw_parameters_set_parent_id_inner((NWConcrete_nw_parameters *)v29, (const unsigned __int8 *)&v193, 0);
  }
  nw_parameters_set_proxy_applied((void *)v29, 1);
  nw_parameters_set_effective_proxy_config((void *)v29, v14);
  if (v166)
  {
    id v32 = v14;
    int v33 = v11[38];

    if (v33 == 4)
    {
      int v34 = v166;
      BOOL v35 = (v34[171] & 0x40) == 0;

      if (!v35)
      {
        int v36 = (id *)(id)v29;
        uint64_t v37 = v34;
        if (v36)
        {
          objc_storeStrong(v36 + 24, obj);
LABEL_34:

          goto LABEL_35;
        }
        unsigned __int8 v131 = __nwlog_obj();
        *(_DWORD *)int buf = 136446210;
        uint64_t v178 = "nw_parameters_set_raced_proxy_config";
        BOOL v132 = (char *)_os_log_send_and_compose_impl();

        LOBYTE(iterate_block[0]) = 16;
        os_log_type_t v176 = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v132, iterate_block, &v176))
        {
          if (LOBYTE(iterate_block[0]) == 17)
          {
            os_log_type_t v133 = __nwlog_obj();
            os_log_type_t v134 = iterate_block[0];
            if (os_log_type_enabled(v133, iterate_block[0]))
            {
              *(_DWORD *)int buf = 136446210;
              uint64_t v178 = "nw_parameters_set_raced_proxy_config";
              _os_log_impl(&dword_1830D4000, v133, v134, "%{public}s called with null parameters", buf, 0xCu);
            }
          }
          else
          {
            if (v176)
            {
              int v148 = (char *)__nw_create_backtrace_string();
              int v149 = __nwlog_obj();
              os_log_type_t v150 = iterate_block[0];
              BOOL v151 = os_log_type_enabled(v149, iterate_block[0]);
              if (v148)
              {
                if (v151)
                {
                  *(_DWORD *)int buf = 136446466;
                  uint64_t v178 = "nw_parameters_set_raced_proxy_config";
                  __int16 v179 = 2082;
                  uint64_t v180 = v148;
                  _os_log_impl(&dword_1830D4000, v149, v150, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
                }

                free(v148);
              }
              else
              {
                if (v151)
                {
                  *(_DWORD *)int buf = 136446210;
                  uint64_t v178 = "nw_parameters_set_raced_proxy_config";
                  _os_log_impl(&dword_1830D4000, v149, v150, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
                }
              }
              goto LABEL_206;
            }
            os_log_type_t v133 = __nwlog_obj();
            os_log_type_t v153 = iterate_block[0];
            if (os_log_type_enabled(v133, iterate_block[0]))
            {
              *(_DWORD *)int buf = 136446210;
              uint64_t v178 = "nw_parameters_set_raced_proxy_config";
              _os_log_impl(&dword_1830D4000, v133, v153, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
            }
          }
        }
LABEL_206:
        if (v132) {
          free(v132);
        }
        goto LABEL_34;
      }
    }
  }
LABEL_35:
  nw_parameters_set_preferred_netagent_classes((void *)v29, 0, 0);
  if (v164 == 1 || (*((unsigned char *)v169 + 97) & 0x40) != 0)
  {
    uint64_t v38 = (NWConcrete_nw_parameters *)(id)v29;
    long long v39 = v38;
    if (v38)
    {
      LOWORD(v38->path_parameters->joinable_path_value.multipath_service) |= 0x2000u;
LABEL_39:

      goto LABEL_40;
    }
    long long v100 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v178 = "nw_parameters_set_is_system_proxy_connection";
    long long v101 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(iterate_block[0]) = 16;
    os_log_type_t v176 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v101, iterate_block, &v176))
    {
      if (LOBYTE(iterate_block[0]) == 17)
      {
        nw_endpoint_t v102 = __nwlog_obj();
        os_log_type_t v103 = iterate_block[0];
        if (os_log_type_enabled(v102, iterate_block[0]))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v178 = "nw_parameters_set_is_system_proxy_connection";
          _os_log_impl(&dword_1830D4000, v102, v103, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else
      {
        int v119 = v15;
        if (v176)
        {
          uint64_t v120 = (char *)__nw_create_backtrace_string();
          BOOL v121 = __nwlog_obj();
          os_log_type_t v122 = iterate_block[0];
          BOOL v123 = os_log_type_enabled(v121, iterate_block[0]);
          if (v120)
          {
            if (v123)
            {
              *(_DWORD *)int buf = 136446466;
              uint64_t v178 = "nw_parameters_set_is_system_proxy_connection";
              __int16 v179 = 2082;
              uint64_t v180 = v120;
              _os_log_impl(&dword_1830D4000, v121, v122, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
            }

            int v15 = v119;
            free(v120);
            goto LABEL_184;
          }
          if (v123)
          {
            *(_DWORD *)int buf = 136446210;
            uint64_t v178 = "nw_parameters_set_is_system_proxy_connection";
            _os_log_impl(&dword_1830D4000, v121, v122, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          BOOL v135 = __nwlog_obj();
          os_log_type_t v136 = iterate_block[0];
          if (os_log_type_enabled(v135, iterate_block[0]))
          {
            *(_DWORD *)int buf = 136446210;
            uint64_t v178 = "nw_parameters_set_is_system_proxy_connection";
            _os_log_impl(&dword_1830D4000, v135, v136, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
          }
        }
        int v15 = v119;
      }
    }
LABEL_184:
    if (v101) {
      free(v101);
    }
    goto LABEL_39;
  }
LABEL_40:
  uint64_t v40 = v14;
  BOOL v41 = (v40[170] & 1) == 0;

  if (!v41) {
    *((unsigned char *)v169 + 96) |= 1u;
  }
  if (nw_proxy_config_supports_listeners(v40)) {
    nw_parameters_set_local_endpoint((nw_parameters_t)v29, 0);
  }
  if (v164 != 1)
  {
LABEL_85:
    if (v167)
    {
      inner = nw_endpoint_handler_create_inner(v167, (void *)v29, nw_endpoint_proxy_receive_report, v171, v171, 0, 0);
      if (!inner)
      {
LABEL_97:

        goto LABEL_98;
      }
      if (!*((void *)v169 + 1))
      {
        BOOL v77 = nw_array_create();
        uint64_t v78 = (void *)*((void *)v169 + 1);
        *((void *)v169 + 1) = v77;
      }
      int minimize_logging = nw_endpoint_handler_get_minimize_logging(v171);
      char logging_disabled = nw_endpoint_handler_get_logging_disabled(v171);
      if (minimize_logging)
      {
        if (logging_disabled) {
          goto LABEL_96;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v81 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v81, OS_LOG_TYPE_DEBUG))
        {
          os_log_type_t v104 = nw_endpoint_handler_get_id_string(v171);
          os_log_type_t v105 = nw_endpoint_handler_dry_run_string(v171);
          nw_endpoint_t v165 = nw_endpoint_handler_copy_endpoint(v171);
          uint64_t v106 = nw_endpoint_get_logging_description(v165);
          uint64_t v107 = nw_endpoint_handler_state_string(v171);
          uint64_t v108 = nw_endpoint_handler_mode_string(v171);
          id v109 = nw_endpoint_handler_copy_current_path(v171);
          uint64_t v110 = nw_endpoint_get_logging_description(v167);
          *(_DWORD *)int buf = 136448002;
          uint64_t v178 = "nw_endpoint_proxy_add_child_for_config";
          __int16 v179 = 2082;
          uint64_t v180 = (void *)v104;
          __int16 v181 = 2082;
          uint64_t v182 = v105;
          __int16 v183 = 2082;
          uint64_t v184 = v106;
          __int16 v185 = 2082;
          BOOL v186 = v107;
          __int16 v187 = 2082;
          int v188 = v108;
          __int16 v189 = 2114;
          id v190 = v109;
          __int16 v191 = 2082;
          os_log_type_t v192 = v110;
          _os_log_impl(&dword_1830D4000, v81, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] adding endpoint handler for %{public}s", buf, 0x52u);
        }
      }
      else
      {
        if (logging_disabled)
        {
LABEL_96:
          nw_array_append(*((void *)v169 + 1), inner);
          goto LABEL_97;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v81 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v81, OS_LOG_TYPE_INFO))
        {
          uint64_t v82 = nw_endpoint_handler_get_id_string(v171);
          BOOL v83 = nw_endpoint_handler_dry_run_string(v171);
          nw_endpoint_t v84 = nw_endpoint_handler_copy_endpoint(v171);
          BOOL v85 = nw_endpoint_get_logging_description(v84);
          os_log_type_t v86 = nw_endpoint_handler_state_string(v171);
          unsigned int v87 = nw_endpoint_handler_mode_string(v171);
          id v88 = nw_endpoint_handler_copy_current_path(v171);
          unsigned int v89 = nw_endpoint_get_logging_description(v167);
          *(_DWORD *)int buf = 136448002;
          uint64_t v178 = "nw_endpoint_proxy_add_child_for_config";
          __int16 v179 = 2082;
          uint64_t v180 = (void *)v82;
          __int16 v181 = 2082;
          uint64_t v182 = v83;
          __int16 v183 = 2082;
          uint64_t v184 = v85;
          __int16 v185 = 2082;
          BOOL v186 = v86;
          __int16 v187 = 2082;
          int v188 = v87;
          __int16 v189 = 2114;
          id v190 = v88;
          __int16 v191 = 2082;
          os_log_type_t v192 = v89;
          _os_log_impl(&dword_1830D4000, v81, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] adding endpoint handler for %{public}s", buf, 0x52u);
        }
      }

      goto LABEL_96;
    }
    int v96 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v178 = "nw_endpoint_proxy_add_child_for_config";
    os_log_type_t v97 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v176 = OS_LOG_TYPE_ERROR;
    char v172 = 0;
    if (__nwlog_fault(v97, &v176, &v172))
    {
      if (v176 == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v98 = __nwlog_obj();
        os_log_type_t v99 = v176;
        if (os_log_type_enabled(v98, v176))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v178 = "nw_endpoint_proxy_add_child_for_config";
          _os_log_impl(&dword_1830D4000, v98, v99, "%{public}s called with null child_endpoint", buf, 0xCu);
        }
      }
      else
      {
        if (v172)
        {
          os_log_type_t v115 = (char *)__nw_create_backtrace_string();
          os_log_type_t v116 = __nwlog_obj();
          os_log_type_t v117 = v176;
          BOOL v118 = os_log_type_enabled(v116, v176);
          if (v115)
          {
            if (v118)
            {
              *(_DWORD *)int buf = 136446466;
              uint64_t v178 = "nw_endpoint_proxy_add_child_for_config";
              __int16 v179 = 2082;
              uint64_t v180 = v115;
              _os_log_impl(&dword_1830D4000, v116, v117, "%{public}s called with null child_endpoint, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v115);
          }
          else
          {
            if (v118)
            {
              *(_DWORD *)int buf = 136446210;
              uint64_t v178 = "nw_endpoint_proxy_add_child_for_config";
              _os_log_impl(&dword_1830D4000, v116, v117, "%{public}s called with null child_endpoint, no backtrace", buf, 0xCu);
            }
          }
          goto LABEL_178;
        }
        os_log_type_t v98 = __nwlog_obj();
        os_log_type_t v130 = v176;
        if (os_log_type_enabled(v98, v176))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v178 = "nw_endpoint_proxy_add_child_for_config";
          _os_log_impl(&dword_1830D4000, v98, v130, "%{public}s called with null child_endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_178:
    if (v97) {
      free(v97);
    }
    goto LABEL_98;
  }
  if (nw_parameters_get_is_known_tracker((void *)v29))
  {
    nw_parameters_set_is_known_tracker((void *)v29, 0);
    char v42 = (NWConcrete_nw_parameters *)(id)v29;
    uint64_t v43 = v42;
    if (v42)
    {
      *((void *)&v42->value + 11) |= 0x80000000uLL;
LABEL_48:

      goto LABEL_49;
    }
    BOOL v124 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v178 = "nw_parameters_set_parent_is_known_tracker";
    char v125 = (void *)_os_log_send_and_compose_impl();

    LOBYTE(iterate_block[0]) = 16;
    os_log_type_t v176 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault((const char *)v125, iterate_block, &v176))
    {
LABEL_201:
      if (v125) {
        free(v125);
      }
      goto LABEL_48;
    }
    int v126 = v15;
    if (LOBYTE(iterate_block[0]) == 17)
    {
      uint64_t v127 = __nwlog_obj();
      os_log_type_t v128 = iterate_block[0];
      if (os_log_type_enabled(v127, iterate_block[0]))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v178 = "nw_parameters_set_parent_is_known_tracker";
        _os_log_impl(&dword_1830D4000, v127, v128, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else
    {
      if (v176)
      {
        int v144 = (char *)__nw_create_backtrace_string();
        int v145 = __nwlog_obj();
        os_log_type_t v146 = iterate_block[0];
        BOOL v147 = os_log_type_enabled(v145, iterate_block[0]);
        if (v144)
        {
          if (v147)
          {
            *(_DWORD *)int buf = 136446466;
            uint64_t v178 = "nw_parameters_set_parent_is_known_tracker";
            __int16 v179 = 2082;
            uint64_t v180 = v144;
            _os_log_impl(&dword_1830D4000, v145, v146, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          int v15 = v126;
          free(v144);
          goto LABEL_201;
        }
        if (v147)
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v178 = "nw_parameters_set_parent_is_known_tracker";
          _os_log_impl(&dword_1830D4000, v145, v146, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }

        goto LABEL_200;
      }
      uint64_t v127 = __nwlog_obj();
      os_log_type_t v152 = iterate_block[0];
      if (os_log_type_enabled(v127, iterate_block[0]))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v178 = "nw_parameters_set_parent_is_known_tracker";
        _os_log_impl(&dword_1830D4000, v127, v152, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_200:
    int v15 = v126;
    goto LABEL_201;
  }
LABEL_49:
  if ((v15 - 2001) > 1)
  {
    *(_DWORD *)int buf = 4;
    nw_proxy_config_remove_protocols_from_stack(v40, v163);
    nw_protocol_definition_t v54 = nw_protocol_options_copy_definition(options);
    os_log_type_t v55 = nw_proxy_config_copy_protocol_stack(v40, v54, buf);

    if (!v55)
    {
LABEL_84:

      goto LABEL_85;
    }
    if (*(_DWORD *)buf == 2)
    {
      BOOL v57 = v163;
      nw_protocol_stack_append_application_protocol(v163, options);
      nw_protocol_options_t v56 = v161;
    }
    else
    {
      nw_protocol_options_t v56 = options;
      BOOL v57 = v163;
      if (*(_DWORD *)buf != 3) {
        goto LABEL_69;
      }
    }
    nw_protocol_stack_append_application_protocol(v57, v56);
LABEL_69:
    iterate_block[0] = MEMORY[0x1E4F143A8];
    iterate_block[1] = 3221225472;
    iterate_block[2] = ___ZL38nw_endpoint_proxy_add_child_for_configP30NWConcrete_nw_endpoint_handlerPU29objcproto18OS_nw_proxy_config8NSObjectS3__block_invoke;
    iterate_block[3] = &unk_1E5248AC0;
    uint64_t v61 = (id)v29;
    uint64_t v174 = v61;
    os_log_type_t v62 = v57;
    uint64_t v175 = v62;
    nw_protocol_stack_iterate_application_protocols(v55, iterate_block);
    int v63 = v55;
    int v64 = v63[3];

    if (v64)
    {
      nw_protocol_stack_set_original_proxied_transport_protocol(v62, options);
      nw_protocol_stack_set_transport_protocol(v62, v64);
    }
    int v65 = v40;
    BOOL v66 = (v65[171] & 4) == 0;

    if (!v66)
    {
      if (nw_protocol_setup_tcp_definition(void)::onceToken != -1) {
        dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_64304);
      }
      id v67 = (id)g_tcp_definition;
      int v68 = nw_parameters_copy_protocol_options_for_definition(v61, v67);

      if (v68)
      {
        nw_tcp_options_set_enable_fast_open(v68, 1);
        int v69 = v65;
        BOOL v70 = (v65[171] & 1) == 0;

        if (!v70) {
          nw_tcp_options_set_fast_open_force_enable(v68, 1);
        }
        id v71 = v69;
        BOOL v72 = (v65[171] & 8) == 0;

        if (!v72) {
          nw_tcp_options_set_no_fast_open_cookie(v68, 1);
        }
      }
    }
    uint64_t v73 = v65;
    nw_multipath_service_t v74 = v73[40];

    if (v74)
    {
      nw_parameters_set_multipath_service(v61, v74);
      os_log_type_t v75 = v73;
      BOOL v76 = (v65[171] & 2) == 0;

      if (!v76) {
        nw_parameters_set_multipath_force_enable(v61, 1);
      }
    }

    goto LABEL_84;
  }
  if (!nw_parameters_get_no_opaque_proxy((void *)v29))
  {
    nw_parameters_set_fast_open_enabled((nw_parameters_t)v29, 0);
    if (nw_protocol_setup_tcp_definition(void)::onceToken != -1) {
      dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_64304);
    }
    id v58 = (id)g_tcp_definition;
    id v59 = nw_parameters_copy_protocol_options_for_definition((void *)v29, v58);

    if (v59) {
      nw_tcp_options_set_enable_fast_open(v59, 0);
    }
    uint64_t v60 = (void *)nw_protocol_boringssl_copy_definition();
    nw_parameters_remove_definition_from_protocol_stack((void *)v29, v60);

    nw_proxy_config_remove_protocols_from_stack(v40, v163);
    goto LABEL_85;
  }
  int v44 = nw_endpoint_handler_get_minimize_logging(v171);
  char v45 = nw_endpoint_handler_get_logging_disabled(v171);
  if (v44)
  {
    if (v45) {
      goto LABEL_98;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    inner = (id)gconnectionLogObj;
    if (os_log_type_enabled(inner, OS_LOG_TYPE_DEBUG))
    {
      os_log_type_t v137 = nw_endpoint_handler_get_id_string(v171);
      uint64_t v138 = nw_endpoint_handler_dry_run_string(v171);
      nw_endpoint_t v139 = nw_endpoint_handler_copy_endpoint(v171);
      os_log_type_t v140 = nw_endpoint_get_logging_description(v139);
      os_log_type_t v141 = nw_endpoint_handler_state_string(v171);
      os_log_type_t v142 = nw_endpoint_handler_mode_string(v171);
      id v143 = nw_endpoint_handler_copy_current_path(v171);
      *(_DWORD *)int buf = 136447746;
      uint64_t v178 = "nw_endpoint_proxy_add_child_for_config";
      __int16 v179 = 2082;
      uint64_t v180 = (void *)v137;
      __int16 v181 = 2082;
      uint64_t v182 = v138;
      __int16 v183 = 2082;
      uint64_t v184 = v140;
      __int16 v185 = 2082;
      BOOL v186 = v141;
      __int16 v187 = 2082;
      int v188 = v142;
      __int16 v189 = 2114;
      id v190 = v143;
      _os_log_impl(&dword_1830D4000, inner, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] opaque proxy not supported on connection, skipping", buf, 0x48u);
    }
    goto LABEL_97;
  }
  if ((v45 & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    inner = (id)gconnectionLogObj;
    if (os_log_type_enabled(inner, OS_LOG_TYPE_INFO))
    {
      id v47 = nw_endpoint_handler_get_id_string(v171);
      __int16 v48 = nw_endpoint_handler_dry_run_string(v171);
      nw_endpoint_t v49 = nw_endpoint_handler_copy_endpoint(v171);
      uint64_t v50 = nw_endpoint_get_logging_description(v49);
      nw_listener_t v51 = nw_endpoint_handler_state_string(v171);
      uint64_t v52 = nw_endpoint_handler_mode_string(v171);
      id v53 = nw_endpoint_handler_copy_current_path(v171);
      *(_DWORD *)int buf = 136447746;
      uint64_t v178 = "nw_endpoint_proxy_add_child_for_config";
      __int16 v179 = 2082;
      uint64_t v180 = (void *)v47;
      __int16 v181 = 2082;
      uint64_t v182 = v48;
      __int16 v183 = 2082;
      uint64_t v184 = v50;
      __int16 v185 = 2082;
      BOOL v186 = v51;
      __int16 v187 = 2082;
      int v188 = v52;
      __int16 v189 = 2114;
      id v190 = v53;
      _os_log_impl(&dword_1830D4000, inner, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] opaque proxy not supported on connection, skipping", buf, 0x48u);
    }
    goto LABEL_97;
  }
LABEL_98:

LABEL_99:
  a1 = v158;
  int v3 = v159;
  int v7 = v157;
LABEL_100:
  if (v7 != 4 || (*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1, !*(unsigned char *)(a1 + 57)))
  {
LABEL_103:
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40), v3);
    uint64_t v90 = 1;
    goto LABEL_104;
  }
  uint64_t v90 = 0;
LABEL_104:

  return v90;
}

void sub_1834878F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20,void *a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,void *a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,void *a32)
{
  _Unwind_Resume(a1);
}

void ___ZL32nw_flow_passthrough_disconnectedP11nw_protocolS0__block_invoke(void *a1)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  long long v1 = (void *)a1[4];
  if (v1)
  {
    int v3 = v1;
    uint64_t v4 = v3[29];

    if (v4 == 2)
    {
      if (a1[7] == a1[5] + 376)
      {
        uint64_t v5 = (void *)a1[4];
        uint64_t v6 = (void *)a1[6];
        nw_endpoint_flow_failed_with_error(v5, 1, v6);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v7 = (id)gLogObj;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        if (v4 > 5) {
          uint64_t v8 = "unknown-mode";
        }
        else {
          uint64_t v8 = off_1E523FB08[v4];
        }
        *(_DWORD *)int buf = 136446722;
        __int16 v20 = "nw_flow_passthrough_disconnected_block_invoke";
        __int16 v21 = 2082;
        __int16 v22 = (void *)v8;
        __int16 v23 = 2082;
        __int16 v24 = "flow";
        _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
      }
    }
    return;
  }
  uint64_t v9 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  __int16 v20 = "nw_flow_passthrough_disconnected_block_invoke";
  id v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v20 = "nw_flow_passthrough_disconnected_block_invoke";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v11 = __nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)int buf = 136446466;
          __int16 v20 = "nw_flow_passthrough_disconnected_block_invoke";
          __int16 v21 = 2082;
          __int16 v22 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_30;
      }
      if (v15)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v20 = "nw_flow_passthrough_disconnected_block_invoke";
        _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v20 = "nw_flow_passthrough_disconnected_block_invoke";
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_30:
  if (v10) {
    free(v10);
  }
}

uint64_t ___ZL29nw_candidate_manager_stop_idsP31NWConcrete_nw_candidate_manager_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  id v5 = a3;
  if (__nwlog_candidate_manager_log::onceToken != -1) {
    dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_24);
  }
  uint64_t v6 = (id)gcandidate_managerLogObj;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
    int v9 = 136446722;
    id v10 = "nw_candidate_manager_stop_ids_block_invoke";
    __int16 v11 = 2048;
    uint64_t v12 = v7;
    __int16 v13 = 2082;
    uint64_t v14 = a2;
    _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_INFO, "%{public}s [CM%zu] closed resolver flow to %{public}s", (uint8_t *)&v9, 0x20u);
  }

  nw_path_flow_registration_close(v5);
  return 1;
}

void sub_183487F70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL26nw_http1_connection_createP11nw_protocolP17nw_protocol_http1P11nw_endpointP13nw_parameters_block_invoke(uint64_t a1)
{
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    if ((*(unsigned char *)(v1 + 158) & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v2 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v3 = *(void *)(v1 + 488);
        int v4 = *(_DWORD *)(*(void *)(v1 + 480) + 372);
        int v5 = *(_DWORD *)(v1 + 860);
        if (v3) {
          LODWORD(v3) = *(_DWORD *)(v3 + 424);
        }
        *(_DWORD *)int buf = 136447490;
        *(void *)&uint8_t buf[4] = "nw_http1_connection_cancel";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v1 + 74;
        *(_WORD *)&unsigned char buf[22] = 2080;
        uint64_t v75 = (uint64_t)" ";
        *(_WORD *)BOOL v76 = 1024;
        *(_DWORD *)&v76[2] = v4;
        *(_WORD *)&v76[6] = 1024;
        *(_DWORD *)&v76[8] = v5;
        LOWORD(v77) = 1024;
        *(_DWORD *)((char *)&v77 + 2) = v3;
        _os_log_impl(&dword_1830D4000, v2, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s%s<i%u:c%u:s%u> cancelling http1 connection", buf, 0x32u);
      }
    }
    int v6 = *(unsigned __int16 *)(v1 + 872);
    int v7 = v6 | (*(unsigned __int8 *)(v1 + 874) << 16);
    if ((v6 & 0x100) != 0)
    {
      if ((*(unsigned char *)(v1 + 158) & 1) == 0)
      {
        if (gLogDatapath)
        {
          __int16 v20 = __nwlog_obj();
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v21 = *(void *)(v1 + 488);
            int v22 = *(_DWORD *)(*(void *)(v1 + 480) + 372);
            int v23 = *(_DWORD *)(v1 + 860);
            if (v21) {
              LODWORD(v21) = *(_DWORD *)(v21 + 424);
            }
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "nw_http1_connection_close";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v1 + 74;
            *(_WORD *)&unsigned char buf[22] = 2080;
            uint64_t v75 = (uint64_t)" ";
            *(_WORD *)BOOL v76 = 1024;
            *(_DWORD *)&v76[2] = v22;
            *(_WORD *)&v76[6] = 1024;
            *(_DWORD *)&v76[8] = v23;
            LOWORD(v77) = 1024;
            *(_DWORD *)((char *)&v77 + 2) = v21;
            _os_log_impl(&dword_1830D4000, v20, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:c%u:s%u> already closed", buf, 0x32u);
          }
        }
      }
      goto LABEL_49;
    }
    uint64_t v8 = (_WORD *)(v1 + 872);
    *(unsigned char *)(v1 + 874) = BYTE2(v7);
    *(_WORD *)(v1 + 872) = v7 | 0x100;
    if ((*(unsigned char *)(v1 + 158) & 1) == 0)
    {
      if (gLogDatapath)
      {
        nw_protocol_options_t v56 = __nwlog_obj();
        if (os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v57 = *(void *)(v1 + 488);
          int v58 = *(_DWORD *)(*(void *)(v1 + 480) + 372);
          int v59 = *(_DWORD *)(v1 + 860);
          if (v57) {
            LODWORD(v57) = *(_DWORD *)(v57 + 424);
          }
          *(_DWORD *)int buf = 136447490;
          *(void *)&uint8_t buf[4] = "nw_http1_connection_close";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v1 + 74;
          *(_WORD *)&unsigned char buf[22] = 2080;
          uint64_t v75 = (uint64_t)" ";
          *(_WORD *)BOOL v76 = 1024;
          *(_DWORD *)&v76[2] = v58;
          *(_WORD *)&v76[6] = 1024;
          *(_DWORD *)&v76[8] = v59;
          LOWORD(v77) = 1024;
          *(_DWORD *)((char *)&v77 + 2) = v57;
          _os_log_impl(&dword_1830D4000, v56, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:c%u:s%u> http connection closed, increasing pool width", buf, 0x32u);
        }
      }
    }
    uint64_t v9 = *(void *)(v1 + 480);
    if (!v9)
    {
      __nwlog_obj();
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
      uint64_t v50 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      os_log_type_t v73 = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v50, type, &v73)) {
        goto LABEL_134;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        nw_listener_t v51 = __nwlog_obj();
        os_log_type_t v52 = type[0];
        if (!os_log_type_enabled(v51, type[0])) {
          goto LABEL_134;
        }
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
        id v53 = "%{public}s called with null http1";
      }
      else if (v73)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        nw_listener_t v51 = __nwlog_obj();
        os_log_type_t v52 = type[0];
        BOOL v61 = os_log_type_enabled(v51, type[0]);
        if (backtrace_string)
        {
          if (v61)
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v51, v52, "%{public}s called with null http1, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_134;
        }
        if (!v61) {
          goto LABEL_134;
        }
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
        id v53 = "%{public}s called with null http1, no backtrace";
      }
      else
      {
        nw_listener_t v51 = __nwlog_obj();
        os_log_type_t v52 = type[0];
        if (!os_log_type_enabled(v51, type[0])) {
          goto LABEL_134;
        }
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
        id v53 = "%{public}s called with null http1, backtrace limit exceeded";
      }
      id v71 = buf;
LABEL_133:
      _os_log_impl(&dword_1830D4000, v51, v52, v53, v71, 0xCu);
      goto LABEL_134;
    }
    int v10 = (unsigned __int16)*v8;
    int v11 = v10 | (*(unsigned __int8 *)(v1 + 874) << 16);
    if ((v10 & 0x800) != 0)
    {
      if ((*(unsigned char *)(v1 + 158) & 1) == 0)
      {
        if (gLogDatapath)
        {
          __int16 v24 = __nwlog_obj();
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v25 = *(void *)(v1 + 488);
            int v26 = *(_DWORD *)(*(void *)(v1 + 480) + 372);
            int v27 = *(_DWORD *)(v1 + 860);
            if (v25) {
              LODWORD(v25) = *(_DWORD *)(v25 + 424);
            }
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v1 + 74;
            *(_WORD *)&unsigned char buf[22] = 2080;
            uint64_t v75 = (uint64_t)" ";
            *(_WORD *)BOOL v76 = 1024;
            *(_DWORD *)&v76[2] = v26;
            *(_WORD *)&v76[6] = 1024;
            *(_DWORD *)&v76[8] = v27;
            LOWORD(v77) = 1024;
            *(_DWORD *)((char *)&v77 + 2) = v25;
            _os_log_impl(&dword_1830D4000, v24, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:c%u:s%u> Connection already marked as not-reusable, ignoring", buf, 0x32u);
          }
        }
      }
      goto LABEL_48;
    }
    *(unsigned char *)(v1 + 874) = BYTE2(v11);
    _WORD *v8 = v11 | 0x800;
    uint64_t v12 = *(unsigned int *)(v9 + 368) + 1;
    uint64_t v13 = v12 << 31 >> 31;
    *(_DWORD *)(v9 + 368) = v12;
    if (v13 == v12 && (v13 & 0x8000000000000000) == 0)
    {
LABEL_43:
      if ((*(unsigned char *)(v1 + 158) & 1) == 0)
      {
        if (gLogDatapath)
        {
          os_log_type_t v62 = __nwlog_obj();
          if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v63 = *(void *)(v1 + 488);
            int v64 = *(_DWORD *)(*(void *)(v1 + 480) + 372);
            int v65 = *(_DWORD *)(v1 + 860);
            if (v63) {
              LODWORD(v63) = *(_DWORD *)(v63 + 424);
            }
            int v66 = *(_DWORD *)(v9 + 368) + *(_DWORD *)(v9 + 364);
            *(_DWORD *)int buf = 136447746;
            *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v1 + 74;
            *(_WORD *)&unsigned char buf[22] = 2080;
            uint64_t v75 = (uint64_t)" ";
            *(_WORD *)BOOL v76 = 1024;
            *(_DWORD *)&v76[2] = v64;
            *(_WORD *)&v76[6] = 1024;
            *(_DWORD *)&v76[8] = v65;
            LOWORD(v77) = 1024;
            *(_DWORD *)((char *)&v77 + 2) = v63;
            HIWORD(v77) = 1024;
            int v78 = v66;
            _os_log_impl(&dword_1830D4000, v62, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:c%u:s%u> connection marked as not-reusable, increased pool width to %u", buf, 0x38u);
          }
        }
      }
      int v33 = *(void **)(v1 + 496);
      if (!v33)
      {
        __nwlog_obj();
        *(_DWORD *)os_log_type_t type = 136446210;
        uint64_t v80 = "nw_http1_match_idle_connection_with_pending_stream_async";
        uint64_t v50 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t v73 = OS_LOG_TYPE_ERROR;
        char v72 = 0;
        if (!__nwlog_fault(v50, &v73, &v72)) {
          goto LABEL_134;
        }
        if (v73 == OS_LOG_TYPE_FAULT)
        {
          nw_listener_t v51 = __nwlog_obj();
          os_log_type_t v52 = v73;
          if (!os_log_type_enabled(v51, v73)) {
            goto LABEL_134;
          }
          *(_DWORD *)os_log_type_t type = 136446210;
          uint64_t v80 = "nw_http1_match_idle_connection_with_pending_stream_async";
          id v53 = "%{public}s called with null http1_connection->context";
LABEL_132:
          id v71 = (uint8_t *)type;
          goto LABEL_133;
        }
        if (!v72)
        {
          nw_listener_t v51 = __nwlog_obj();
          os_log_type_t v52 = v73;
          if (!os_log_type_enabled(v51, v73)) {
            goto LABEL_134;
          }
          *(_DWORD *)os_log_type_t type = 136446210;
          uint64_t v80 = "nw_http1_match_idle_connection_with_pending_stream_async";
          id v53 = "%{public}s called with null http1_connection->context, backtrace limit exceeded";
          goto LABEL_132;
        }
        id v67 = (char *)__nw_create_backtrace_string();
        nw_listener_t v51 = __nwlog_obj();
        os_log_type_t v52 = v73;
        BOOL v68 = os_log_type_enabled(v51, v73);
        if (!v67)
        {
          if (!v68) {
            goto LABEL_134;
          }
          *(_DWORD *)os_log_type_t type = 136446210;
          uint64_t v80 = "nw_http1_match_idle_connection_with_pending_stream_async";
          id v53 = "%{public}s called with null http1_connection->context, no backtrace";
          goto LABEL_132;
        }
        if (v68)
        {
          *(_DWORD *)os_log_type_t type = 136446466;
          uint64_t v80 = "nw_http1_match_idle_connection_with_pending_stream_async";
          __int16 v81 = 2082;
          uint64_t v82 = v67;
          int v69 = "%{public}s called with null http1_connection->context, dumping backtrace:%{public}s";
LABEL_111:
          _os_log_impl(&dword_1830D4000, v51, v52, v69, (uint8_t *)type, 0x16u);
        }
LABEL_112:
        free(v67);
        if (!v50)
        {
LABEL_48:
          if (!*(void *)(v1 + 488))
          {
            uint64_t v39 = *(void *)(v1 + 784);
            if (v39)
            {
              if (*(void *)v39)
              {
                dispatch_source_set_timer(*(dispatch_source_t *)v39, 0x8000000000000000, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
              }
              else
              {
                *(_OWORD *)(v39 + 32) = xmmword_183D5CD50;
                if (*(unsigned char *)(v39 + 48) && *(unsigned char *)(v39 + 49)) {
                  nw_queue_source_run_timer(v39);
                }
              }
            }
            else
            {
              if ((*(unsigned char *)(v1 + 158) & 1) == 0)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                uint64_t v40 = gLogObj;
                if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                {
                  uint64_t v41 = *(void *)(v1 + 488);
                  int v42 = *(_DWORD *)(*(void *)(v1 + 480) + 372);
                  int v43 = *(_DWORD *)(v1 + 860);
                  if (v41) {
                    LODWORD(v41) = *(_DWORD *)(v41 + 424);
                  }
                  *(_DWORD *)int buf = 136447490;
                  *(void *)&uint8_t buf[4] = "nw_http1_connection_close";
                  *(_WORD *)&unsigned char buf[12] = 2082;
                  *(void *)&buf[14] = v1 + 74;
                  *(_WORD *)&unsigned char buf[22] = 2080;
                  uint64_t v75 = (uint64_t)" ";
                  *(_WORD *)BOOL v76 = 1024;
                  *(_DWORD *)&v76[2] = v42;
                  *(_WORD *)&v76[6] = 1024;
                  *(_DWORD *)&v76[8] = v43;
                  LOWORD(v77) = 1024;
                  *(_DWORD *)((char *)&v77 + 2) = v41;
                  _os_log_impl(&dword_1830D4000, v40, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:c%u:s%u> No destroy timer on HTTP/1 connection when closing", buf, 0x32u);
                }
              }
              uint64_t v44 = *(void *)(v1 + 608);
              char v45 = *(void **)(v1 + 496);
              *(void *)int buf = MEMORY[0x1E4F143A8];
              *(void *)&buf[8] = 0x40000000;
              *(void *)&buf[16] = ___ZL25nw_http1_connection_closeP19nw_http1_connection_block_invoke;
              uint64_t v75 = (uint64_t)&unk_1E52411A0;
              *(void *)BOOL v76 = v44;
              nw_queue_context_async(v45, buf);
            }
          }
LABEL_49:
          uint64_t v36 = *(void *)(v1 + 488);
          if (v36)
          {
            nw_protocol_error(*(void **)(v36 + 48), v36);
            uint64_t v37 = *(void *)(v1 + 488);
            if (v37) {
              uint64_t v38 = *(void **)(v37 + 48);
            }
            else {
              uint64_t v38 = 0;
            }
            nw_protocol_disconnected(v38, v37);
          }
          return;
        }
LABEL_135:
        free(v50);
        goto LABEL_48;
      }
      uint64_t v34 = *(void *)(v1 + 480);
      if (v34)
      {
        uint64_t v35 = *(void *)(v34 + 200);
        *(void *)int buf = MEMORY[0x1E4F143A8];
        *(void *)&buf[8] = 0x40000000;
        *(void *)&buf[16] = ___ZL56nw_http1_match_idle_connection_with_pending_stream_asyncP19nw_http1_connection_block_invoke;
        uint64_t v75 = (uint64_t)&unk_1E52411C8;
        *(void *)BOOL v76 = v35;
        nw_queue_context_async(v33, buf);
        goto LABEL_48;
      }
      __nwlog_obj();
      *(_DWORD *)os_log_type_t type = 136446210;
      uint64_t v80 = "nw_http1_match_idle_connection_with_pending_stream_async";
      uint64_t v50 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t v73 = OS_LOG_TYPE_ERROR;
      char v72 = 0;
      if (__nwlog_fault(v50, &v73, &v72))
      {
        if (v73 == OS_LOG_TYPE_FAULT)
        {
          nw_listener_t v51 = __nwlog_obj();
          os_log_type_t v52 = v73;
          if (!os_log_type_enabled(v51, v73)) {
            goto LABEL_134;
          }
          *(_DWORD *)os_log_type_t type = 136446210;
          uint64_t v80 = "nw_http1_match_idle_connection_with_pending_stream_async";
          id v53 = "%{public}s called with null http1";
          goto LABEL_132;
        }
        if (!v72)
        {
          nw_listener_t v51 = __nwlog_obj();
          os_log_type_t v52 = v73;
          if (!os_log_type_enabled(v51, v73)) {
            goto LABEL_134;
          }
          *(_DWORD *)os_log_type_t type = 136446210;
          uint64_t v80 = "nw_http1_match_idle_connection_with_pending_stream_async";
          id v53 = "%{public}s called with null http1, backtrace limit exceeded";
          goto LABEL_132;
        }
        id v67 = (char *)__nw_create_backtrace_string();
        nw_listener_t v51 = __nwlog_obj();
        os_log_type_t v52 = v73;
        BOOL v70 = os_log_type_enabled(v51, v73);
        if (!v67)
        {
          if (!v70) {
            goto LABEL_134;
          }
          *(_DWORD *)os_log_type_t type = 136446210;
          uint64_t v80 = "nw_http1_match_idle_connection_with_pending_stream_async";
          id v53 = "%{public}s called with null http1, no backtrace";
          goto LABEL_132;
        }
        if (v70)
        {
          *(_DWORD *)os_log_type_t type = 136446466;
          uint64_t v80 = "nw_http1_match_idle_connection_with_pending_stream_async";
          __int16 v81 = 2082;
          uint64_t v82 = v67;
          int v69 = "%{public}s called with null http1, dumping backtrace:%{public}s";
          goto LABEL_111;
        }
        goto LABEL_112;
      }
LABEL_134:
      if (!v50) {
        goto LABEL_48;
      }
      goto LABEL_135;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v14 = *(unsigned int *)(v9 + 368);
    *(_DWORD *)int buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = "http1->nonresuable_connections";
    *(_WORD *)&unsigned char buf[22] = 2048;
    uint64_t v75 = 1;
    *(_WORD *)BOOL v76 = 2048;
    *(void *)&v76[2] = v14;
    uint64_t v15 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v73 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v15, type, &v73))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v16 = gLogObj;
        os_log_type_t v17 = type[0];
        if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
        {
          uint64_t v18 = *(unsigned int *)(v9 + 368);
          *(_DWORD *)int buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = "http1->nonresuable_connections";
          *(_WORD *)&unsigned char buf[22] = 2048;
          uint64_t v75 = 1;
          *(_WORD *)BOOL v76 = 2048;
          *(void *)&v76[2] = v18;
          id v19 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_39:
          _os_log_impl(&dword_1830D4000, v16, v17, v19, buf, 0x2Au);
        }
      }
      else if (v73)
      {
        id v28 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v16 = gLogObj;
        os_log_type_t v17 = type[0];
        BOOL v29 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
        if (v28)
        {
          if (v29)
          {
            uint64_t v30 = *(unsigned int *)(v9 + 368);
            *(_DWORD *)int buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = "http1->nonresuable_connections";
            *(_WORD *)&unsigned char buf[22] = 2048;
            uint64_t v75 = 1;
            *(_WORD *)BOOL v76 = 2048;
            *(void *)&v76[2] = v30;
            *(_WORD *)&v76[10] = 2082;
            BOOL v77 = v28;
            _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v28);
          goto LABEL_40;
        }
        if (v29)
        {
          uint64_t v32 = *(unsigned int *)(v9 + 368);
          *(_DWORD *)int buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = "http1->nonresuable_connections";
          *(_WORD *)&unsigned char buf[22] = 2048;
          uint64_t v75 = 1;
          *(_WORD *)BOOL v76 = 2048;
          *(void *)&v76[2] = v32;
          id v19 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
          goto LABEL_39;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v16 = gLogObj;
        os_log_type_t v17 = type[0];
        if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
        {
          uint64_t v31 = *(unsigned int *)(v9 + 368);
          *(_DWORD *)int buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = "http1->nonresuable_connections";
          *(_WORD *)&unsigned char buf[22] = 2048;
          uint64_t v75 = 1;
          *(_WORD *)BOOL v76 = 2048;
          *(void *)&v76[2] = v31;
          id v19 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
          goto LABEL_39;
        }
      }
    }
LABEL_40:
    if (v15) {
      free(v15);
    }
    *(_DWORD *)(v9 + 368) = -1;
    goto LABEL_43;
  }
  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_http1_connection_cancel";
  uint64_t v46 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  os_log_type_t v73 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v46, type, &v73))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      id v47 = __nwlog_obj();
      os_log_type_t v48 = type[0];
      if (!os_log_type_enabled(v47, type[0])) {
        goto LABEL_117;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_connection_cancel";
      nw_endpoint_t v49 = "%{public}s called with null http1_connection";
      goto LABEL_116;
    }
    if (v73 == OS_LOG_TYPE_DEFAULT)
    {
      id v47 = __nwlog_obj();
      os_log_type_t v48 = type[0];
      if (!os_log_type_enabled(v47, type[0])) {
        goto LABEL_117;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_connection_cancel";
      nw_endpoint_t v49 = "%{public}s called with null http1_connection, backtrace limit exceeded";
      goto LABEL_116;
    }
    nw_protocol_definition_t v54 = (char *)__nw_create_backtrace_string();
    id v47 = __nwlog_obj();
    os_log_type_t v48 = type[0];
    BOOL v55 = os_log_type_enabled(v47, type[0]);
    if (v54)
    {
      if (v55)
      {
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http1_connection_cancel";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v54;
        _os_log_impl(&dword_1830D4000, v47, v48, "%{public}s called with null http1_connection, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v54);
      goto LABEL_117;
    }
    if (v55)
    {
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_connection_cancel";
      nw_endpoint_t v49 = "%{public}s called with null http1_connection, no backtrace";
LABEL_116:
      _os_log_impl(&dword_1830D4000, v47, v48, v49, buf, 0xCu);
    }
  }
LABEL_117:
  if (v46) {
    free(v46);
  }
}

void sub_18348A78C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, uint64_t a14, void *a15, uint64_t a16, void *a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void sub_18348AAB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, ...)
{
  va_start(va, a7);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void nw_protocol_new_objc::$_0::__invoke(char *this, objc_object *a2, objc_selector *a3)
{
  {
    nw_protocol_new_objc::$_0::operator() const(objc_object *,objc_selector *)::destroy = (uint64_t)sel_registerName("destroy");
  }
  int v4 = (const char *)nw_protocol_new_objc::$_0::operator() const(objc_object *,objc_selector *)::destroy;
  Class Class = object_getClass(this);
  if (class_getInstanceMethod(Class, v4)) {
    [this v4];
  }
  objc_destructInstance(this);
  if (this)
  {
    if (*((_UNKNOWN **)this - 7) == &nw_protocol_ref_counted_handle)
    {
      uint64_t v6 = *((void *)this - 1);
      if (v6)
      {
        uint64_t v7 = v6 - 1;
        *((void *)this - 1) = v7;
        if (!v7)
        {
          uint64_t v8 = (void (**)(void))*((void *)this - 4);
          if (v8)
          {
            *((void *)this - 4) = 0;
            v8[2](v8);
            _Block_release(v8);
          }
          if (*(this - 24))
          {
            uint64_t v9 = (const void *)*((void *)this - 4);
            if (v9) {
              _Block_release(v9);
            }
          }
          *((void *)this - 4) = 0;
          free(this - 96);
        }
      }
    }
  }
}

void nw_protocol_webtransport_session_listen_protocol_disconnected(nw_listen_protocol *a1, nw_protocol *a2, int a3)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (!__nwlog_fault(v6, &type, &v41)) {
      goto LABEL_28;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_28;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
      uint64_t v9 = "%{public}s called with null listener";
    }
    else if (v41)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v38 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v38)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null listener, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_28;
      }
      if (!v38) {
        goto LABEL_28;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
      uint64_t v9 = "%{public}s called with null listener, no backtrace";
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_28;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
      uint64_t v9 = "%{public}s called with null listener, backtrace limit exceeded";
    }
LABEL_26:
    uint64_t v21 = v7;
    os_log_type_t v22 = v8;
LABEL_27:
    _os_log_impl(&dword_1830D4000, v21, v22, v9, buf, 0xCu);
    goto LABEL_28;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (!__nwlog_fault(v6, &type, &v41)) {
      goto LABEL_28;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_28;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
      uint64_t v9 = "%{public}s called with null webtransport_session";
    }
    else if (v41)
    {
      uint64_t v39 = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v40 = os_log_type_enabled(v7, type);
      if (v39)
      {
        if (v40)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v39;
          _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null webtransport_session, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v39);
        if (v6) {
          goto LABEL_29;
        }
        return;
      }
      if (!v40) {
        goto LABEL_28;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
      uint64_t v9 = "%{public}s called with null webtransport_session, no backtrace";
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_28;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
      uint64_t v9 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
    }
    goto LABEL_26;
  }
  if ((handle[548] & 2) == 0)
  {
    if (gLogDatapath)
    {
      uint64_t v35 = __nwlog_obj();
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
      {
        int v36 = *((_DWORD *)handle + 115);
        *(_DWORD *)int buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = handle + 464;
        *(_WORD *)&unsigned char buf[22] = 2080;
        uint64_t v44 = " ";
        *(_WORD *)char v45 = 1024;
        *(_DWORD *)&v45[2] = v36;
        _os_log_impl(&dword_1830D4000, v35, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> listen protocol is disconnected", buf, 0x26u);
      }
    }
  }
  if (*((nw_protocol **)handle + 4) == a2)
  {
    if (*((_DWORD *)handle + 111) == 5)
    {
      if ((handle[548] & 2) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v10 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        {
          int v11 = *((_DWORD *)handle + 115);
          *(_DWORD *)int buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_terminate";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = handle + 464;
          *(_WORD *)&unsigned char buf[22] = 2080;
          uint64_t v44 = " ";
          *(_WORD *)char v45 = 1024;
          *(_DWORD *)&v45[2] = v11;
          _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Session already terminated, ignoring", buf, 0x26u);
        }
      }
      return;
    }
    if (a3)
    {
      if ((handle[548] & 2) != 0) {
        goto LABEL_36;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v16 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
        goto LABEL_36;
      }
      int v17 = *((_DWORD *)handle + 115);
      *(_DWORD *)int buf = 136447234;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_terminate";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = handle + 464;
      *(_WORD *)&unsigned char buf[22] = 2080;
      uint64_t v44 = " ";
      *(_WORD *)char v45 = 1024;
      *(_DWORD *)&v45[2] = v17;
      __int16 v46 = 1024;
      int v47 = a3;
      uint64_t v18 = "%{public}s %{public}s%s<i%u> Closing webtransport session with error %{darwin.errno}d";
      id v19 = v16;
      uint32_t v20 = 44;
    }
    else
    {
      if ((handle[548] & 2) != 0) {
        goto LABEL_36;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v23 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
        goto LABEL_36;
      }
      int v24 = *((_DWORD *)handle + 115);
      *(_DWORD *)int buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_terminate";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = handle + 464;
      *(_WORD *)&unsigned char buf[22] = 2080;
      uint64_t v44 = " ";
      *(_WORD *)char v45 = 1024;
      *(_DWORD *)&v45[2] = v24;
      uint64_t v18 = "%{public}s %{public}s%s<i%u> Closing webtransport session without error";
      id v19 = v23;
      uint32_t v20 = 38;
    }
    _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_INFO, v18, buf, v20);
LABEL_36:
    *((_DWORD *)handle + 111) = 5;
    uint64_t v25 = (char *)*((void *)handle + 23);
    if (v25)
    {
      *(void *)int buf = MEMORY[0x1E4F143A8];
      *(void *)&buf[8] = 0x40000000;
      *(void *)&buf[16] = ___ZL33nw_webtransport_session_terminateP23nw_webtransport_sessioni_block_invoke;
      uint64_t v44 = (const char *)&__block_descriptor_tmp_26_33833;
      *(_DWORD *)char v45 = a3;
      nw_hash_table_apply(v25, (uint64_t)buf);
    }
    uint64_t v26 = *((void *)handle + 53);
    if (v26)
    {
      int v27 = *(void **)(v26 + 48);
      if (a3) {
        nw_protocol_error(*(void **)(v26 + 48), *((void *)handle + 53));
      }
      nw_protocol_disconnected(v27, v26);
    }
    uint64_t v28 = *((void *)handle + 41);
    if (v28)
    {
      if (a3)
      {
        do
        {
          uint64_t v29 = *(void *)(v28 + 112);
          uint64_t v30 = *(void **)(v28 + 48);
          nw_protocol_error(v30, v28);
          uint64_t v31 = v28;
          uint64_t v28 = v29;
          nw_protocol_disconnected(v30, v31);
        }
        while (v29);
      }
      else
      {
        do
        {
          uint64_t v32 = *(void *)(v28 + 112);
          nw_protocol_disconnected(*(void **)(v28 + 48), v28);
          uint64_t v28 = v32;
        }
        while (v32);
      }
    }
    uint64_t v33 = *((void *)handle + 52);
    if (v33)
    {
      uint64_t v34 = *(void **)(v33 + 48);
      if (a3) {
        nw_protocol_error(*(void **)(v33 + 48), *((void *)handle + 52));
      }
      nw_protocol_disconnected(v34, v33);
    }
    if (*((void *)handle + 4))
    {
      nw_protocol_remove_instance((uint64_t)handle);
      nw_protocol_disconnect(*((void **)handle + 4), (uint64_t)handle);
    }
    return;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v41 = 0;
  if (!__nwlog_fault(v6, &type, &v41)) {
    goto LABEL_28;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = gLogObj;
    os_log_type_t v8 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
      goto LABEL_28;
    }
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
    uint64_t v9 = "%{public}s Ignoring webtransport listen protocol disconnected, not sent by connected output handler";
    goto LABEL_26;
  }
  if (!v41)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = gLogObj;
    os_log_type_t v8 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
      goto LABEL_28;
    }
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
    uint64_t v9 = "%{public}s Ignoring webtransport listen protocol disconnected, not sent by connected output handler, backtrace limit exceeded";
    goto LABEL_26;
  }
  uint64_t v12 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v13 = gLogObj;
  os_log_type_t v14 = type;
  BOOL v15 = os_log_type_enabled((os_log_t)gLogObj, type);
  if (v12)
  {
    if (v15)
    {
      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = v12;
      _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s Ignoring webtransport listen protocol disconnected, not sent by connected output handler, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v12);
    if (v6) {
      goto LABEL_29;
    }
    return;
  }
  if (v15)
  {
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
    uint64_t v9 = "%{public}s Ignoring webtransport listen protocol disconnected, not sent by connected output handler, no backtrace";
    uint64_t v21 = v13;
    os_log_type_t v22 = v14;
    goto LABEL_27;
  }
LABEL_28:
  if (v6) {
LABEL_29:
  }
    free(v6);
}

nw_endpoint_t *nw_candidate_manager_resolver_for_service_resolved_endpoint(void *a1, void *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  id v4 = a2;
  id v5 = v3[10];
  BOOL v6 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]((id *)[NWConcrete_nw_parameters alloc], v5, 0, 0);

  uint64_t v7 = nw_endpoint_copy_interface(v4);
  nw_parameters_require_interface((nw_parameters_t)v6, v7);

  nw_parameters_set_preferred_interface_subtypes((void *)v6, 0);
  nw_parameters_set_multipath_service((nw_parameters_t)v6, nw_multipath_service_disabled);
  evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(v4, (void *)v6);
  uint64_t v9 = (os_unfair_lock_s *)evaluator_for_endpoint;
  if (evaluator_for_endpoint)
  {
    int v10 = evaluator_for_endpoint;
    os_unfair_lock_lock(v9 + 24);
    id v11 = v10[6];
    os_unfair_lock_unlock(v9 + 24);
  }
  else
  {
    id v11 = 0;
  }
  uint64_t v12 = nw_resolver_create_with_path(v11);

  if (v12)
  {
    v18[0] = MEMORY[0x1E4F143A8];
    v18[1] = 3221225472;
    v18[2] = ___ZL59nw_candidate_manager_resolver_for_service_resolved_endpointP31NWConcrete_nw_candidate_managerPU25objcproto14OS_nw_endpoint8NSObject_block_invoke;
    v18[3] = &unk_1E523AC70;
    uint64_t v13 = v3;
    id v19 = v13;
    id v14 = v4;
    id v20 = v14;
    id v21 = (id)v6;
    nw_resolver_set_update_handler(v12, 0, v18);
    if (__nwlog_candidate_manager_log::onceToken != -1) {
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_24);
    }
    BOOL v15 = (id)gcandidate_managerLogObj;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      id v16 = v13[1];
      *(_DWORD *)int buf = 136446978;
      uint64_t v23 = "nw_candidate_manager_resolver_for_service_resolved_endpoint";
      __int16 v24 = 2048;
      id v25 = v16;
      __int16 v26 = 2112;
      int v27 = v12;
      __int16 v28 = 2112;
      id v29 = v14;
      _os_log_impl(&dword_1830D4000, v15, OS_LOG_TYPE_DEBUG, "%{public}s [CM%zu] Adding %@ for %@", buf, 0x2Au);
    }
  }

  return v12;
}

void sub_18348B878(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

uint64_t nw_browser_copy_key_for_application_service_endpoint(void *a1, char *a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    os_log_type_t v8 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    id v25 = "nw_browser_copy_key_for_application_service_endpoint";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (!__nwlog_fault(v9, &type, &v22)) {
      goto LABEL_37;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v25 = "nw_browser_copy_key_for_application_service_endpoint";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null endpoint", buf, 0xCu);
      }
      goto LABEL_36;
    }
    if (!v22)
    {
      int v10 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v25 = "nw_browser_copy_key_for_application_service_endpoint";
        _os_log_impl(&dword_1830D4000, v10, v19, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_36;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int v10 = __nwlog_obj();
    os_log_type_t v15 = type;
    BOOL v16 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)int buf = 136446210;
        id v25 = "nw_browser_copy_key_for_application_service_endpoint";
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
      goto LABEL_36;
    }
    if (v16)
    {
      *(_DWORD *)int buf = 136446466;
      id v25 = "nw_browser_copy_key_for_application_service_endpoint";
      __int16 v26 = 2082;
      int v27 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_24;
  }
  if (!a2)
  {
    uint64_t v12 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    id v25 = "nw_browser_copy_key_for_application_service_endpoint";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (!__nwlog_fault(v9, &type, &v22)) {
      goto LABEL_37;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v10 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v25 = "nw_browser_copy_key_for_application_service_endpoint";
        _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null key_buffer", buf, 0xCu);
      }
LABEL_36:

LABEL_37:
      if (v9) {
        free(v9);
      }
      goto LABEL_39;
    }
    if (!v22)
    {
      int v10 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v25 = "nw_browser_copy_key_for_application_service_endpoint";
        _os_log_impl(&dword_1830D4000, v10, v20, "%{public}s called with null key_buffer, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_36;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int v10 = __nwlog_obj();
    os_log_type_t v17 = type;
    BOOL v18 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)int buf = 136446210;
        id v25 = "nw_browser_copy_key_for_application_service_endpoint";
        _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s called with null key_buffer, no backtrace", buf, 0xCu);
      }
      goto LABEL_36;
    }
    if (v18)
    {
      *(_DWORD *)int buf = 136446466;
      id v25 = "nw_browser_copy_key_for_application_service_endpoint";
      __int16 v26 = 2082;
      int v27 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s called with null key_buffer, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_24:

    free(backtrace_string);
    goto LABEL_37;
  }
  id v5 = v3;
  int v6 = [v5 type];

  if (v6 != 6)
  {
LABEL_39:
    uint64_t v7 = 0;
    goto LABEL_40;
  }
  snprintf(a2, 0x3F1uLL, "%016zx", [v5 getHash]);
  uint64_t v7 = 1;
LABEL_40:

  return v7;
}

void sub_18348BDC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_implementation_replace_input_handler(nw_protocol *a1, nw_protocol *a2, nw_protocol *a3)
{
  uint64_t v155 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0;
    }
    os_log_type_t v8 = p_output_handler;
    uint64_t v9 = v8;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      uint64_t v10 = *((void *)v8 + 1);
      if (v10)
      {
        if (*(void *)(v10 + 80))
        {
          if (a2)
          {
            if (a3)
            {
              if (*(_DWORD *)(v10 + 64) == 3)
              {
                if ((v8[405] & 0x80000000) == 0 && gLogDatapath)
                {
                  uint64_t v127 = __nwlog_obj();
                  if (os_log_type_enabled(v127, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)int buf = 136447234;
                    *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                    __int16 v148 = 2082;
                    int v149 = v9 + 407;
                    __int16 v150 = 2080;
                    BOOL v151 = " ";
                    __int16 v152 = 2048;
                    *(void *)os_log_type_t v153 = nw_protocol_flow_for_protocol((NWConcrete_nw_protocol_instance *)v9, (uint64_t)a2);
                    *(_WORD *)&v153[8] = 2048;
                    *(void *)&v153[10] = a3;
                    _os_log_impl(&dword_1830D4000, v127, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sReplacing input handler for flow %llx to %p", buf, 0x34u);
                  }
                }
                output_handler_nw_content_context_t context = a2->output_handler_context;
                if (!output_handler_context)
                {
                  if ((v9[405] & 0x80000000) == 0)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    char v41 = (id)gLogObj;
                    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)int buf = 136446978;
                      *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                      __int16 v148 = 2082;
                      int v149 = v9 + 407;
                      __int16 v150 = 2080;
                      BOOL v151 = " ";
                      __int16 v152 = 2048;
                      *(void *)os_log_type_t v153 = a2;
                      _os_log_impl(&dword_1830D4000, v41, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sOutput handler context doesn't exist on protocol %p", buf, 0x2Au);
                    }
                  }
                  goto LABEL_157;
                }
                a2->output_handler_nw_content_context_t context = 0;
                char v145 = 0;
                BOOL v12 = nw_hash_table_add_object(*((void *)v9 + 29), (uint64_t)a3, &v145);
                if (v145)
                {
                  os_log_type_t v13 = (void *)v12;
                  if ((v9[405] & 0x80000000) == 0 && gLogDatapath)
                  {
                    unsigned __int8 v131 = __nwlog_obj();
                    if (os_log_type_enabled(v131, OS_LOG_TYPE_DEBUG))
                    {
                      uint64_t v132 = nw_protocol_flow_for_protocol((NWConcrete_nw_protocol_instance *)v9, (uint64_t)a3);
                      *(_DWORD *)int buf = 136447234;
                      *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                      __int16 v148 = 2082;
                      int v149 = v9 + 407;
                      __int16 v150 = 2080;
                      BOOL v151 = " ";
                      __int16 v152 = 2048;
                      *(void *)os_log_type_t v153 = a3;
                      *(_WORD *)&v153[8] = 2048;
                      *(void *)&v153[10] = v132;
                      _os_log_impl(&dword_1830D4000, v131, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sMultiplexing protocol added protocol %p to hash table for flow %llx", buf, 0x34u);
                    }
                  }
                  a3->output_handler_nw_content_context_t context = v13;
                  uint64_t extra = nw_hash_node_get_extra((uint64_t)v13);
                  uint64_t v15 = extra;
                  if (extra)
                  {
                    *(void *)(extra + 16) = 0;
                    *(void *)(extra + 24) = extra + 16;
                    BOOL v16 = (char *)(output_handler_context + 6);
                    uint64_t v17 = output_handler_context[6];
                    if (v17)
                    {
                      *(void *)(extra + 16) = v17;
                      *(void *)(output_handler_context[6] + 40) = extra + 16;
                      *(void *)(extra + 24) = output_handler_context[7];
                      output_handler_context[6] = 0;
                      output_handler_context[7] = v16;
                    }
                    BOOL v18 = (void *)output_handler_context[5];
                    output_handler_context[6] = 0;
                    output_handler_context[7] = v16;
                    *(void *)uint64_t extra = output_handler_context[4];
                    objc_storeStrong((id *)(extra + 8), v18);
                    os_log_type_t v19 = (void *)output_handler_context[5];
                    output_handler_context[5] = 0;

                    *(_OWORD *)(v15 + 32) = *((_OWORD *)output_handler_context + 4);
                    int v20 = *(_WORD *)(v15 + 52) & 0xFFFE | *((_WORD *)output_handler_context + 42) & 1;
                    *(_WORD *)(v15 + 52) = *(_WORD *)(v15 + 52) & 0xFFFE | *((_WORD *)output_handler_context + 42) & 1;
                    unsigned int v21 = v20 & 0xFFFFFFFD | (2 * ((*((unsigned __int16 *)output_handler_context + 42) >> 1) & 1));
                    *(_WORD *)(v15 + 52) = v21;
                    unsigned int v22 = v21 & 0xFFFFFFFB | (4 * ((*((unsigned __int16 *)output_handler_context + 42) >> 2) & 1));
                    *(_WORD *)(v15 + 52) = v22;
                    unsigned int v23 = v22 & 0xFFFFFFF7 | (8 * ((*((unsigned __int16 *)output_handler_context + 42) >> 3) & 1));
                    *(_WORD *)(v15 + 52) = v23;
                    unsigned int v24 = v23 & 0xFFFFFFEF | (16 * ((*((unsigned __int16 *)output_handler_context + 42) >> 4) & 1));
                    *(_WORD *)(v15 + 52) = v24;
                    unsigned int v25 = v24 & 0xFFFFFFDF | (32 * ((*((unsigned __int16 *)output_handler_context + 42) >> 5) & 1));
                    *(_WORD *)(v15 + 52) = v25;
                    unsigned int v26 = v25 & 0xFFFFFF7F | (((*((unsigned __int16 *)output_handler_context + 42) >> 7) & 1) << 7);
                    *(_WORD *)(v15 + 52) = v26;
                    unsigned int v27 = v26 & 0xFFFFFEFF | ((HIBYTE(*((unsigned __int16 *)output_handler_context + 42)) & 1) << 8);
                    *(_WORD *)(v15 + 52) = v27;
                    unsigned int v28 = v27 & 0xFFFFFDFF | (((*((unsigned __int16 *)output_handler_context + 42) >> 9) & 1) << 9);
                    *(_WORD *)(v15 + 52) = v28;
                    unsigned int v29 = v28 & 0xFFFFFBFF | (((*((unsigned __int16 *)output_handler_context + 42) >> 10) & 1) << 10);
                    *(_WORD *)(v15 + 52) = v29;
                    *(_WORD *)(v15 + 52) = v29 & 0xF7FF | *((_WORD *)output_handler_context + 42) & 0x800;
                    goto LABEL_20;
                  }
                  os_log_type_t v128 = __nwlog_obj();
                  *(_DWORD *)int buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_protocol_flow_state_move";
                  id v143 = (char *)_os_log_send_and_compose_impl();

                  LOBYTE(v154) = 16;
                  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
                  if (__nwlog_fault(v143, &v154, &type))
                  {
                    if (v154 == 17)
                    {
                      os_log_type_t v129 = __nwlog_obj();
                      os_log_type_t v130 = v154;
                      if (os_log_type_enabled(v129, (os_log_type_t)v154))
                      {
                        *(_DWORD *)int buf = 136446210;
                        *(void *)&uint8_t buf[4] = "nw_protocol_flow_state_move";
                        _os_log_impl(&dword_1830D4000, v129, v130, "%{public}s called with null dst", buf, 0xCu);
                      }
                    }
                    else if (type)
                    {
                      backtrace_string = (char *)__nw_create_backtrace_string();
                      os_log_type_t v129 = __nwlog_obj();
                      os_log_type_t v142 = v154;
                      BOOL v140 = os_log_type_enabled(v129, (os_log_type_t)v154);
                      if (backtrace_string)
                      {
                        if (v140)
                        {
                          *(_DWORD *)int buf = 136446466;
                          *(void *)&uint8_t buf[4] = "nw_protocol_flow_state_move";
                          __int16 v148 = 2082;
                          int v149 = backtrace_string;
                          _os_log_impl(&dword_1830D4000, v129, v142, "%{public}s called with null dst, dumping backtrace:%{public}s", buf, 0x16u);
                        }

                        free(backtrace_string);
                        goto LABEL_281;
                      }
                      if (v140)
                      {
                        *(_DWORD *)int buf = 136446210;
                        *(void *)&uint8_t buf[4] = "nw_protocol_flow_state_move";
                        _os_log_impl(&dword_1830D4000, v129, v142, "%{public}s called with null dst, no backtrace", buf, 0xCu);
                      }
                    }
                    else
                    {
                      os_log_type_t v129 = __nwlog_obj();
                      os_log_type_t v141 = v154;
                      if (os_log_type_enabled(v129, (os_log_type_t)v154))
                      {
                        *(_DWORD *)int buf = 136446210;
                        *(void *)&uint8_t buf[4] = "nw_protocol_flow_state_move";
                        _os_log_impl(&dword_1830D4000, v129, v141, "%{public}s called with null dst, backtrace limit exceeded", buf, 0xCu);
                      }
                    }
                  }
LABEL_281:
                  if (v143) {
                    free(v143);
                  }
LABEL_20:
                  if (!a3->output_handler)
                  {
                    a3->output_handler = a1;
                    if (a1->handle == &nw_protocol_ref_counted_handle)
                    {
                      callbacks = a1[1].callbacks;
                      if (callbacks) {
                        a1[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
                      }
                    }
                  }
                  uint64_t v31 = a3->callbacks;
                  if (v31)
                  {
                    supports_external_data = (uint64_t (*)(nw_protocol *))v31->supports_external_data;
                    if (supports_external_data)
                    {
                      uint64_t v33 = a3->handle;
                      if (v33 == &nw_protocol_ref_counted_handle)
                      {
                        os_log_type_t v62 = a3[1].callbacks;
                        if (v62) {
                          a3[1].callbacks = (nw_protocol_callbacks *)((char *)&v62->add_input_handler + 1);
                        }
                        char v34 = -1;
                      }
                      else
                      {
                        char v34 = 0;
                      }
                      *(void *)int buf = a3;
                      buf[8] = v34;
                      int v63 = supports_external_data(a3);
                      int v64 = v63;
                      if (v33 == &nw_protocol_ref_counted_handle)
                      {
                        nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
                        if (v64) {
                          goto LABEL_78;
                        }
                      }
                      else if (v63)
                      {
LABEL_78:
                        __int16 v65 = *(_WORD *)(v15 + 52) | 0x400;
                        goto LABEL_81;
                      }
                    }
                  }
                  __int16 v65 = *(_WORD *)(v15 + 52) & 0xFBFF;
LABEL_81:
                  *(_WORD *)(v15 + 52) = v65;
                  if (a1->default_input_handler == a2)
                  {
                    if (a2 != a3)
                    {
                      if (a2->handle == &nw_protocol_ref_counted_handle)
                      {
                        int v92 = a2[1].callbacks;
                        if (v92)
                        {
                          uint64_t v93 = (nw_protocol_callbacks *)((char *)v92 - 1);
                          a2[1].callbacks = v93;
                          if (!v93)
                          {
                            os_log_type_t v94 = *(void (***)(void))a2[1].flow_id;
                            if (v94)
                            {
                              *(void *)a2[1].flow_uint64_t id = 0;
                              v94[2](v94);
                              _Block_release(v94);
                            }
                            if (a2[1].flow_id[8])
                            {
                              os_log_type_t v95 = *(const void **)a2[1].flow_id;
                              if (v95) {
                                _Block_release(v95);
                              }
                            }
                            free(a2);
                          }
                        }
                      }
                      a1->default_input_handler = a3;
                      if (a3->handle == &nw_protocol_ref_counted_handle)
                      {
                        int v66 = a3[1].callbacks;
                        if (v66) {
                          a3[1].callbacks = (nw_protocol_callbacks *)((char *)&v66->add_input_handler + 1);
                        }
                      }
                    }
                    *(_OWORD *)a1->flow_uint64_t id = *(_OWORD *)a3->flow_id;
                    uint64_t v67 = nw_protocol_instance_copy_path(v9, -1);
                    BOOL v68 = (void *)*((void *)v9 + 36);
                    *((void *)v9 + 36) = v67;
                  }
                  if (nw_hash_table_remove_node(*((void *)v9 + 29), (uint64_t)output_handler_context))
                  {
                    uint64_t v69 = *((void *)v9 + 1);
                    BOOL v70 = *(void (**)(uint64_t, void))(*(void *)(v69 + 80) + 32);
                    if (v70 && *(void *)v15)
                    {
                      v70(v69, *(void *)v15);
                    }
                    else
                    {
                      uint64_t v75 = 1;
                      if (v9[405] < 0 || !gLogDatapath) {
                        goto LABEL_158;
                      }
                      BOOL v76 = __nwlog_obj();
                      if (os_log_type_enabled(v76, OS_LOG_TYPE_DEBUG))
                      {
                        *(_DWORD *)int buf = 136446722;
                        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                        __int16 v148 = 2082;
                        int v149 = v9 + 407;
                        __int16 v150 = 2080;
                        BOOL v151 = " ";
                        _os_log_impl(&dword_1830D4000, v76, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sNot calling instance replace flow state", buf, 0x20u);
                      }
                    }
                    goto LABEL_126;
                  }
                  if ((v9[405] & 0x80000000) == 0)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    id v71 = (id)gLogObj;
                    *(_DWORD *)int buf = 136446978;
                    *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                    __int16 v148 = 2082;
                    int v149 = v9 + 407;
                    __int16 v150 = 2080;
                    BOOL v151 = " ";
                    __int16 v152 = 2048;
                    *(void *)os_log_type_t v153 = a2;
                    char v72 = (const char *)_os_log_send_and_compose_impl();

                    LOBYTE(v154) = 16;
                    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
                    if (__nwlog_fault(v72, &v154, &type))
                    {
                      if (v154 == 17)
                      {
                        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                        networkd_settings_init();
                        os_log_type_t v73 = (id)gLogObj;
                        os_log_type_t v74 = v154;
                        if (os_log_type_enabled(v73, (os_log_type_t)v154))
                        {
                          *(_DWORD *)int buf = 136446978;
                          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                          __int16 v148 = 2082;
                          int v149 = v9 + 407;
                          __int16 v150 = 2080;
                          BOOL v151 = " ";
                          __int16 v152 = 2048;
                          *(void *)os_log_type_t v153 = a2;
                          _os_log_impl(&dword_1830D4000, v73, v74, "%{public}s %{public}s%sFailed to remove protocol node for protocol %p from table", buf, 0x2Au);
                        }
                      }
                      else if (type)
                      {
                        BOOL v77 = (char *)__nw_create_backtrace_string();
                        os_log_type_t v73 = __nwlog_obj();
                        os_log_type_t v78 = v154;
                        BOOL v79 = os_log_type_enabled(v73, (os_log_type_t)v154);
                        if (v77)
                        {
                          if (v79)
                          {
                            *(_DWORD *)int buf = 136447234;
                            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                            __int16 v148 = 2082;
                            int v149 = v9 + 407;
                            __int16 v150 = 2080;
                            BOOL v151 = " ";
                            __int16 v152 = 2048;
                            *(void *)os_log_type_t v153 = a2;
                            *(_WORD *)&v153[8] = 2082;
                            *(void *)&v153[10] = v77;
                            _os_log_impl(&dword_1830D4000, v73, v78, "%{public}s %{public}s%sFailed to remove protocol node for protocol %p from table, dumping backtrace:%{public}s", buf, 0x34u);
                          }

                          free(v77);
                          if (!v72) {
                            goto LABEL_157;
                          }
                          goto LABEL_155;
                        }
                        if (v79)
                        {
                          *(_DWORD *)int buf = 136446978;
                          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                          __int16 v148 = 2082;
                          int v149 = v9 + 407;
                          __int16 v150 = 2080;
                          BOOL v151 = " ";
                          __int16 v152 = 2048;
                          *(void *)os_log_type_t v153 = a2;
                          _os_log_impl(&dword_1830D4000, v73, v78, "%{public}s %{public}s%sFailed to remove protocol node for protocol %p from table, no backtrace", buf, 0x2Au);
                        }
                      }
                      else
                      {
                        os_log_type_t v73 = __nwlog_obj();
                        os_log_type_t v91 = v154;
                        if (os_log_type_enabled(v73, (os_log_type_t)v154))
                        {
                          *(_DWORD *)int buf = 136446978;
                          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                          __int16 v148 = 2082;
                          int v149 = v9 + 407;
                          __int16 v150 = 2080;
                          BOOL v151 = " ";
                          __int16 v152 = 2048;
                          *(void *)os_log_type_t v153 = a2;
                          _os_log_impl(&dword_1830D4000, v73, v91, "%{public}s %{public}s%sFailed to remove protocol node for protocol %p from table, backtrace limit exceeded", buf, 0x2Au);
                        }
                      }
                    }
                    if (v72)
                    {
LABEL_155:
                      unsigned int v89 = (char *)v72;
                      goto LABEL_156;
                    }
                  }
LABEL_157:
                  uint64_t v75 = 0;
                  goto LABEL_158;
                }
                long long v154 = *(_OWORD *)a3->flow_id;
                if (v9[405] < 0) {
                  goto LABEL_157;
                }
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                id v52 = (id)gLogObj;
                *(_DWORD *)int buf = 136447234;
                *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                __int16 v148 = 2082;
                int v149 = v9 + 407;
                __int16 v150 = 2080;
                BOOL v151 = " ";
                __int16 v152 = 1042;
                *(_DWORD *)os_log_type_t v153 = 16;
                *(_WORD *)&v153[4] = 2098;
                *(void *)&v153[6] = &v154;
                id v53 = (const char *)_os_log_send_and_compose_impl();

                os_log_type_t type = OS_LOG_TYPE_ERROR;
                char v144 = 0;
                if (__nwlog_fault(v53, &type, &v144))
                {
                  if (type == OS_LOG_TYPE_FAULT)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    nw_protocol_definition_t v54 = (id)gLogObj;
                    os_log_type_t v55 = type;
                    if (os_log_type_enabled(v54, type))
                    {
                      *(_DWORD *)int buf = 136447234;
                      *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                      __int16 v148 = 2082;
                      int v149 = v9 + 407;
                      __int16 v150 = 2080;
                      BOOL v151 = " ";
                      __int16 v152 = 1042;
                      *(_DWORD *)os_log_type_t v153 = 16;
                      *(_WORD *)&v153[4] = 2098;
                      *(void *)&v153[6] = &v154;
                      _os_log_impl(&dword_1830D4000, v54, v55, "%{public}s %{public}s%sMultiplexing protocol already has input handler registered for %{public,uuid_t}.16P", buf, 0x30u);
                    }
                  }
                  else if (v144)
                  {
                    int v58 = __nw_create_backtrace_string();
                    if (v58)
                    {
                      int v59 = (char *)v58;
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      uint64_t v60 = (id)gLogObj;
                      os_log_type_t v61 = type;
                      if (os_log_type_enabled(v60, type))
                      {
                        *(_DWORD *)int buf = 136447490;
                        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                        __int16 v148 = 2082;
                        int v149 = v9 + 407;
                        __int16 v150 = 2080;
                        BOOL v151 = " ";
                        __int16 v152 = 1042;
                        *(_DWORD *)os_log_type_t v153 = 16;
                        *(_WORD *)&v153[4] = 2098;
                        *(void *)&v153[6] = &v154;
                        *(_WORD *)&v153[14] = 2082;
                        *(void *)&v153[16] = v59;
                        _os_log_impl(&dword_1830D4000, v60, v61, "%{public}s %{public}s%sMultiplexing protocol already has input handler registered for %{public,uuid_t}.16P, dumping backtrace:%{public}s", buf, 0x3Au);
                      }

                      free(v59);
                      if (!v53) {
                        goto LABEL_157;
                      }
LABEL_150:
                      unsigned int v89 = (char *)v53;
                      goto LABEL_156;
                    }
                    nw_protocol_definition_t v54 = __nwlog_obj();
                    os_log_type_t v96 = type;
                    if (os_log_type_enabled(v54, type))
                    {
                      *(_DWORD *)int buf = 136447234;
                      *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                      __int16 v148 = 2082;
                      int v149 = v9 + 407;
                      __int16 v150 = 2080;
                      BOOL v151 = " ";
                      __int16 v152 = 1042;
                      *(_DWORD *)os_log_type_t v153 = 16;
                      *(_WORD *)&v153[4] = 2098;
                      *(void *)&v153[6] = &v154;
                      _os_log_impl(&dword_1830D4000, v54, v96, "%{public}s %{public}s%sMultiplexing protocol already has input handler registered for %{public,uuid_t}.16P, no backtrace", buf, 0x30u);
                    }
                  }
                  else
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    nw_protocol_definition_t v54 = (id)gLogObj;
                    os_log_type_t v90 = type;
                    if (os_log_type_enabled(v54, type))
                    {
                      *(_DWORD *)int buf = 136447234;
                      *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                      __int16 v148 = 2082;
                      int v149 = v9 + 407;
                      __int16 v150 = 2080;
                      BOOL v151 = " ";
                      __int16 v152 = 1042;
                      *(_DWORD *)os_log_type_t v153 = 16;
                      *(_WORD *)&v153[4] = 2098;
                      *(void *)&v153[6] = &v154;
                      _os_log_impl(&dword_1830D4000, v54, v90, "%{public}s %{public}s%sMultiplexing protocol already has input handler registered for %{public,uuid_t}.16P, backtrace limit exceeded", buf, 0x30u);
                    }
                  }
                }
LABEL_149:
                if (!v53) {
                  goto LABEL_157;
                }
                goto LABEL_150;
              }
              if (a1->default_input_handler != a2)
              {
                if (v8[405] < 0) {
                  goto LABEL_157;
                }
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                id v35 = (id)gLogObj;
                default_input_handler = a1->default_input_handler;
                *(_DWORD *)int buf = 136447234;
                *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                __int16 v148 = 2082;
                int v149 = v9 + 407;
                __int16 v150 = 2080;
                BOOL v151 = " ";
                __int16 v152 = 2048;
                *(void *)os_log_type_t v153 = default_input_handler;
                *(_WORD *)&v153[8] = 2048;
                *(void *)&v153[10] = a2;
                uint64_t v37 = (const char *)_os_log_send_and_compose_impl();

                LOBYTE(v154) = 16;
                os_log_type_t type = OS_LOG_TYPE_DEFAULT;
                if (__nwlog_fault(v37, &v154, &type))
                {
                  if (v154 == 17)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    BOOL v38 = (id)gLogObj;
                    os_log_type_t v39 = v154;
                    if (os_log_type_enabled(v38, (os_log_type_t)v154))
                    {
                      BOOL v40 = a1->default_input_handler;
                      *(_DWORD *)int buf = 136447234;
                      *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                      __int16 v148 = 2082;
                      int v149 = v9 + 407;
                      __int16 v150 = 2080;
                      BOOL v151 = " ";
                      __int16 v152 = 2048;
                      *(void *)os_log_type_t v153 = v40;
                      *(_WORD *)&v153[8] = 2048;
                      *(void *)&v153[10] = a2;
                      _os_log_impl(&dword_1830D4000, v38, v39, "%{public}s %{public}s%sOld input handler does not match (%p != %p)", buf, 0x34u);
                    }
                  }
                  else if (type)
                  {
                    uint64_t v48 = (char *)__nw_create_backtrace_string();
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    BOOL v38 = (id)gLogObj;
                    os_log_type_t v49 = v154;
                    BOOL v50 = os_log_type_enabled(v38, (os_log_type_t)v154);
                    if (v48)
                    {
                      if (v50)
                      {
                        nw_listener_t v51 = a1->default_input_handler;
                        *(_DWORD *)int buf = 136447490;
                        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                        __int16 v148 = 2082;
                        int v149 = v9 + 407;
                        __int16 v150 = 2080;
                        BOOL v151 = " ";
                        __int16 v152 = 2048;
                        *(void *)os_log_type_t v153 = v51;
                        *(_WORD *)&v153[8] = 2048;
                        *(void *)&v153[10] = a2;
                        *(_WORD *)&v153[18] = 2082;
                        *(void *)&v153[20] = v48;
                        _os_log_impl(&dword_1830D4000, v38, v49, "%{public}s %{public}s%sOld input handler does not match (%p != %p), dumping backtrace:%{public}s", buf, 0x3Eu);
                      }

                      free(v48);
                      if (!v37) {
                        goto LABEL_157;
                      }
LABEL_131:
                      unsigned int v89 = (char *)v37;
LABEL_156:
                      free(v89);
                      goto LABEL_157;
                    }
                    if (v50)
                    {
                      id v88 = a1->default_input_handler;
                      *(_DWORD *)int buf = 136447234;
                      *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                      __int16 v148 = 2082;
                      int v149 = v9 + 407;
                      __int16 v150 = 2080;
                      BOOL v151 = " ";
                      __int16 v152 = 2048;
                      *(void *)os_log_type_t v153 = v88;
                      *(_WORD *)&v153[8] = 2048;
                      *(void *)&v153[10] = a2;
                      _os_log_impl(&dword_1830D4000, v38, v49, "%{public}s %{public}s%sOld input handler does not match (%p != %p), no backtrace", buf, 0x34u);
                    }
                  }
                  else
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    BOOL v38 = (id)gLogObj;
                    os_log_type_t v56 = v154;
                    if (os_log_type_enabled(v38, (os_log_type_t)v154))
                    {
                      uint64_t v57 = a1->default_input_handler;
                      *(_DWORD *)int buf = 136447234;
                      *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                      __int16 v148 = 2082;
                      int v149 = v9 + 407;
                      __int16 v150 = 2080;
                      BOOL v151 = " ";
                      __int16 v152 = 2048;
                      *(void *)os_log_type_t v153 = v57;
                      *(_WORD *)&v153[8] = 2048;
                      *(void *)&v153[10] = a2;
                      _os_log_impl(&dword_1830D4000, v38, v56, "%{public}s %{public}s%sOld input handler does not match (%p != %p), backtrace limit exceeded", buf, 0x34u);
                    }
                  }
                }
                if (!v37) {
                  goto LABEL_157;
                }
                goto LABEL_131;
              }
              if (a2 != a3)
              {
                if (a2->handle == &nw_protocol_ref_counted_handle)
                {
                  uint64_t v80 = a2[1].callbacks;
                  if (v80)
                  {
                    __int16 v81 = (nw_protocol_callbacks *)((char *)v80 - 1);
                    a2[1].callbacks = v81;
                    if (!v81)
                    {
                      uint64_t v82 = *(void (***)(void))a2[1].flow_id;
                      if (v82)
                      {
                        *(void *)a2[1].flow_uint64_t id = 0;
                        v82[2](v82);
                        _Block_release(v82);
                      }
                      if (a2[1].flow_id[8])
                      {
                        uint64_t v83 = *(const void **)a2[1].flow_id;
                        if (v83) {
                          _Block_release(v83);
                        }
                      }
                      free(a2);
                    }
                  }
                }
                a1->default_input_handler = a3;
                if (a3->handle == &nw_protocol_ref_counted_handle)
                {
                  int v42 = a3[1].callbacks;
                  if (v42) {
                    a3[1].callbacks = (nw_protocol_callbacks *)((char *)&v42->add_input_handler + 1);
                  }
                }
              }
              *(_OWORD *)a1->flow_uint64_t id = *(_OWORD *)a3->flow_id;
              if (!a3->output_handler)
              {
                a3->output_handler = a1;
                if (a1->handle == &nw_protocol_ref_counted_handle)
                {
                  int v43 = a1[1].callbacks;
                  if (v43) {
                    a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v43->add_input_handler + 1);
                  }
                }
              }
              uint64_t v44 = a3->callbacks;
              if (v44)
              {
                char v45 = (uint64_t (*)(nw_protocol *))v44->supports_external_data;
                if (v45)
                {
                  __int16 v46 = a3->handle;
                  if (v46 == &nw_protocol_ref_counted_handle)
                  {
                    nw_endpoint_t v84 = a3[1].callbacks;
                    if (v84) {
                      a3[1].callbacks = (nw_protocol_callbacks *)((char *)&v84->add_input_handler + 1);
                    }
                    char v47 = -1;
                  }
                  else
                  {
                    char v47 = 0;
                  }
                  *(void *)int buf = a3;
                  buf[8] = v47;
                  int v85 = v45(a3);
                  int v86 = v85;
                  if (v46 == &nw_protocol_ref_counted_handle)
                  {
                    nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
                    if (v86) {
                      goto LABEL_122;
                    }
                  }
                  else if (v85)
                  {
LABEL_122:
                    char v87 = v9[403] | 2;
LABEL_125:
                    v9[403] = v87;
LABEL_126:
                    uint64_t v75 = 1;
LABEL_158:

                    return v75;
                  }
                }
              }
              char v87 = v9[403] & 0xFD;
              goto LABEL_125;
            }
            uint64_t v111 = __nwlog_obj();
            *(_DWORD *)int buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
            id v53 = (const char *)_os_log_send_and_compose_impl();

            LOBYTE(v154) = 16;
            os_log_type_t type = OS_LOG_TYPE_DEFAULT;
            if (!__nwlog_fault(v53, &v154, &type)) {
              goto LABEL_149;
            }
            if (v154 == 17)
            {
              os_log_type_t v103 = __nwlog_obj();
              os_log_type_t v112 = v154;
              if (os_log_type_enabled(v103, (os_log_type_t)v154))
              {
                *(_DWORD *)int buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                _os_log_impl(&dword_1830D4000, v103, v112, "%{public}s called with null new_input_handler", buf, 0xCu);
              }
LABEL_269:

              goto LABEL_149;
            }
            if (type == OS_LOG_TYPE_DEFAULT)
            {
              os_log_type_t v103 = __nwlog_obj();
              os_log_type_t v138 = v154;
              if (os_log_type_enabled(v103, (os_log_type_t)v154))
              {
                *(_DWORD *)int buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                _os_log_impl(&dword_1830D4000, v103, v138, "%{public}s called with null new_input_handler, backtrace limit exceeded", buf, 0xCu);
              }
              goto LABEL_269;
            }
            os_log_type_t v116 = (char *)__nw_create_backtrace_string();
            os_log_type_t v103 = __nwlog_obj();
            os_log_type_t v125 = v154;
            BOOL v126 = os_log_type_enabled(v103, (os_log_type_t)v154);
            if (!v116)
            {
              if (v126)
              {
                *(_DWORD *)int buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                _os_log_impl(&dword_1830D4000, v103, v125, "%{public}s called with null new_input_handler, no backtrace", buf, 0xCu);
              }
              goto LABEL_269;
            }
            if (v126)
            {
              *(_DWORD *)int buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
              __int16 v148 = 2082;
              int v149 = v116;
              _os_log_impl(&dword_1830D4000, v103, v125, "%{public}s called with null new_input_handler, dumping backtrace:%{public}s", buf, 0x16u);
            }
          }
          else
          {
            id v109 = __nwlog_obj();
            *(_DWORD *)int buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
            id v53 = (const char *)_os_log_send_and_compose_impl();

            LOBYTE(v154) = 16;
            os_log_type_t type = OS_LOG_TYPE_DEFAULT;
            if (!__nwlog_fault(v53, &v154, &type)) {
              goto LABEL_149;
            }
            if (v154 == 17)
            {
              os_log_type_t v103 = __nwlog_obj();
              os_log_type_t v110 = v154;
              if (os_log_type_enabled(v103, (os_log_type_t)v154))
              {
                *(_DWORD *)int buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                _os_log_impl(&dword_1830D4000, v103, v110, "%{public}s called with null old_input_handler", buf, 0xCu);
              }
              goto LABEL_269;
            }
            if (type == OS_LOG_TYPE_DEFAULT)
            {
              os_log_type_t v103 = __nwlog_obj();
              os_log_type_t v137 = v154;
              if (os_log_type_enabled(v103, (os_log_type_t)v154))
              {
                *(_DWORD *)int buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                _os_log_impl(&dword_1830D4000, v103, v137, "%{public}s called with null old_input_handler, backtrace limit exceeded", buf, 0xCu);
              }
              goto LABEL_269;
            }
            os_log_type_t v116 = (char *)__nw_create_backtrace_string();
            os_log_type_t v103 = __nwlog_obj();
            os_log_type_t v123 = v154;
            BOOL v124 = os_log_type_enabled(v103, (os_log_type_t)v154);
            if (!v116)
            {
              if (v124)
              {
                *(_DWORD *)int buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                _os_log_impl(&dword_1830D4000, v103, v123, "%{public}s called with null old_input_handler, no backtrace", buf, 0xCu);
              }
              goto LABEL_269;
            }
            if (v124)
            {
              *(_DWORD *)int buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
              __int16 v148 = 2082;
              int v149 = v116;
              _os_log_impl(&dword_1830D4000, v103, v123, "%{public}s called with null old_input_handler, dumping backtrace:%{public}s", buf, 0x16u);
            }
          }
        }
        else
        {
          uint64_t v107 = __nwlog_obj();
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
          id v53 = (const char *)_os_log_send_and_compose_impl();

          LOBYTE(v154) = 16;
          os_log_type_t type = OS_LOG_TYPE_DEFAULT;
          if (!__nwlog_fault(v53, &v154, &type)) {
            goto LABEL_149;
          }
          if (v154 == 17)
          {
            os_log_type_t v103 = __nwlog_obj();
            os_log_type_t v108 = v154;
            if (os_log_type_enabled(v103, (os_log_type_t)v154))
            {
              *(_DWORD *)int buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
              _os_log_impl(&dword_1830D4000, v103, v108, "%{public}s called with null instance->parent_definition->extended_state", buf, 0xCu);
            }
            goto LABEL_269;
          }
          if (type == OS_LOG_TYPE_DEFAULT)
          {
            os_log_type_t v103 = __nwlog_obj();
            os_log_type_t v136 = v154;
            if (os_log_type_enabled(v103, (os_log_type_t)v154))
            {
              *(_DWORD *)int buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
              _os_log_impl(&dword_1830D4000, v103, v136, "%{public}s called with null instance->parent_definition->extended_state, backtrace limit exceeded", buf, 0xCu);
            }
            goto LABEL_269;
          }
          os_log_type_t v116 = (char *)__nw_create_backtrace_string();
          os_log_type_t v103 = __nwlog_obj();
          os_log_type_t v121 = v154;
          BOOL v122 = os_log_type_enabled(v103, (os_log_type_t)v154);
          if (!v116)
          {
            if (v122)
            {
              *(_DWORD *)int buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
              _os_log_impl(&dword_1830D4000, v103, v121, "%{public}s called with null instance->parent_definition->extended_state, no backtrace", buf, 0xCu);
            }
            goto LABEL_269;
          }
          if (v122)
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
            __int16 v148 = 2082;
            int v149 = v116;
            _os_log_impl(&dword_1830D4000, v103, v121, "%{public}s called with null instance->parent_definition->extended_state, dumping backtrace:%{public}s", buf, 0x16u);
          }
        }
      }
      else
      {
        os_log_type_t v105 = __nwlog_obj();
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
        id v53 = (const char *)_os_log_send_and_compose_impl();

        LOBYTE(v154) = 16;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        if (!__nwlog_fault(v53, &v154, &type)) {
          goto LABEL_149;
        }
        if (v154 == 17)
        {
          os_log_type_t v103 = __nwlog_obj();
          os_log_type_t v106 = v154;
          if (os_log_type_enabled(v103, (os_log_type_t)v154))
          {
            *(_DWORD *)int buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
            _os_log_impl(&dword_1830D4000, v103, v106, "%{public}s called with null instance->parent_definition", buf, 0xCu);
          }
          goto LABEL_269;
        }
        if (type == OS_LOG_TYPE_DEFAULT)
        {
          os_log_type_t v103 = __nwlog_obj();
          os_log_type_t v135 = v154;
          if (os_log_type_enabled(v103, (os_log_type_t)v154))
          {
            *(_DWORD *)int buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
            _os_log_impl(&dword_1830D4000, v103, v135, "%{public}s called with null instance->parent_definition, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_269;
        }
        os_log_type_t v116 = (char *)__nw_create_backtrace_string();
        os_log_type_t v103 = __nwlog_obj();
        os_log_type_t v119 = v154;
        BOOL v120 = os_log_type_enabled(v103, (os_log_type_t)v154);
        if (!v116)
        {
          if (v120)
          {
            *(_DWORD *)int buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
            _os_log_impl(&dword_1830D4000, v103, v119, "%{public}s called with null instance->parent_definition, no backtrace", buf, 0xCu);
          }
          goto LABEL_269;
        }
        if (v120)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
          __int16 v148 = 2082;
          int v149 = v116;
          _os_log_impl(&dword_1830D4000, v103, v119, "%{public}s called with null instance->parent_definition, dumping backtrace:%{public}s", buf, 0x16u);
        }
      }
    }
    else
    {
      nw_endpoint_t v102 = __nwlog_obj();
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
      id v53 = (const char *)_os_log_send_and_compose_impl();

      LOBYTE(v154) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v53, &v154, &type)) {
        goto LABEL_149;
      }
      if (v154 == 17)
      {
        os_log_type_t v103 = __nwlog_obj();
        os_log_type_t v104 = v154;
        if (os_log_type_enabled(v103, (os_log_type_t)v154))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
          _os_log_impl(&dword_1830D4000, v103, v104, "%{public}s called with null instance", buf, 0xCu);
        }
        goto LABEL_269;
      }
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        os_log_type_t v103 = __nwlog_obj();
        os_log_type_t v134 = v154;
        if (os_log_type_enabled(v103, (os_log_type_t)v154))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
          _os_log_impl(&dword_1830D4000, v103, v134, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_269;
      }
      os_log_type_t v116 = (char *)__nw_create_backtrace_string();
      os_log_type_t v103 = __nwlog_obj();
      os_log_type_t v117 = v154;
      BOOL v118 = os_log_type_enabled(v103, (os_log_type_t)v154);
      if (!v116)
      {
        if (v118)
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
          _os_log_impl(&dword_1830D4000, v103, v117, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }
        goto LABEL_269;
      }
      if (v118)
      {
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
        __int16 v148 = 2082;
        int v149 = v116;
        _os_log_impl(&dword_1830D4000, v103, v117, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
      }
    }

    free(v116);
    goto LABEL_149;
  }
  os_log_type_t v98 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
  os_log_type_t v99 = (char *)_os_log_send_and_compose_impl();

  LOBYTE(v154) = 16;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v99, &v154, &type))
  {
    if (v154 == 17)
    {
      long long v100 = __nwlog_obj();
      os_log_type_t v101 = v154;
      if (os_log_type_enabled(v100, (os_log_type_t)v154))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
        _os_log_impl(&dword_1830D4000, v100, v101, "%{public}s called with null protocol", buf, 0xCu);
      }
    }
    else if (type)
    {
      os_log_type_t v113 = (char *)__nw_create_backtrace_string();
      long long v100 = __nwlog_obj();
      os_log_type_t v114 = v154;
      BOOL v115 = os_log_type_enabled(v100, (os_log_type_t)v154);
      if (v113)
      {
        if (v115)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
          __int16 v148 = 2082;
          int v149 = v113;
          _os_log_impl(&dword_1830D4000, v100, v114, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v113);
        goto LABEL_252;
      }
      if (v115)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
        _os_log_impl(&dword_1830D4000, v100, v114, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      long long v100 = __nwlog_obj();
      os_log_type_t v133 = v154;
      if (os_log_type_enabled(v100, (os_log_type_t)v154))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
        _os_log_impl(&dword_1830D4000, v100, v133, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_252:
  if (v99) {
    free(v99);
  }
  return 0;
}

void sub_18348DE10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_implementation_remove_listen_handler(nw_protocol *a1, nw_listen_protocol *a2)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0;
    }
    id v5 = p_output_handler;
    int v6 = v5;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      uint64_t v7 = *((void *)v5 + 1);
      if (v7)
      {
        if (*(void *)(v7 + 80))
        {
          if (*((nw_listen_protocol **)v5 + 3) == a2)
          {
            *((void *)v5 + 3) = 0;
            a2->protocol_handler = 0;
          }
          if ((v5[405] & 0x80000000) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v8 = (id)gLogObj;
            if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)int buf = 136446722;
              BOOL v40 = "nw_protocol_implementation_remove_listen_handler";
              __int16 v41 = 2082;
              int v42 = v6 + 407;
              __int16 v43 = 2080;
              uint64_t v44 = " ";
              _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sRemoved protocol listen handler", buf, 0x20u);
            }
          }
          v6[404] |= 4u;
          nw_protocol_remove_instance((uint64_t)(v6 - 96));
          uint64_t v9 = 1;
LABEL_14:

          return v9;
        }
        unsigned int v21 = __nwlog_obj();
        *(_DWORD *)int buf = 136446210;
        BOOL v40 = "nw_protocol_implementation_remove_listen_handler";
        BOOL v16 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v37 = 0;
        if (__nwlog_fault(v16, &type, &v37))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            uint64_t v17 = __nwlog_obj();
            os_log_type_t v22 = type;
            if (os_log_type_enabled(v17, type))
            {
              *(_DWORD *)int buf = 136446210;
              BOOL v40 = "nw_protocol_implementation_remove_listen_handler";
              _os_log_impl(&dword_1830D4000, v17, v22, "%{public}s called with null instance->parent_definition->extended_state", buf, 0xCu);
            }
LABEL_82:

            goto LABEL_83;
          }
          if (!v37)
          {
            uint64_t v17 = __nwlog_obj();
            os_log_type_t v36 = type;
            if (os_log_type_enabled(v17, type))
            {
              *(_DWORD *)int buf = 136446210;
              BOOL v40 = "nw_protocol_implementation_remove_listen_handler";
              _os_log_impl(&dword_1830D4000, v17, v36, "%{public}s called with null instance->parent_definition->extended_state, backtrace limit exceeded", buf, 0xCu);
            }
            goto LABEL_82;
          }
          backtrace_string = (char *)__nw_create_backtrace_string();
          uint64_t v17 = __nwlog_obj();
          os_log_type_t v31 = type;
          BOOL v32 = os_log_type_enabled(v17, type);
          if (!backtrace_string)
          {
            if (v32)
            {
              *(_DWORD *)int buf = 136446210;
              BOOL v40 = "nw_protocol_implementation_remove_listen_handler";
              _os_log_impl(&dword_1830D4000, v17, v31, "%{public}s called with null instance->parent_definition->extended_state, no backtrace", buf, 0xCu);
            }
            goto LABEL_82;
          }
          if (v32)
          {
            *(_DWORD *)int buf = 136446466;
            BOOL v40 = "nw_protocol_implementation_remove_listen_handler";
            __int16 v41 = 2082;
            int v42 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v17, v31, "%{public}s called with null instance->parent_definition->extended_state, dumping backtrace:%{public}s", buf, 0x16u);
          }
          goto LABEL_55;
        }
LABEL_83:
        if (v16) {
          free(v16);
        }
        uint64_t v9 = 0;
        goto LABEL_14;
      }
      os_log_type_t v19 = __nwlog_obj();
      *(_DWORD *)int buf = 136446210;
      BOOL v40 = "nw_protocol_implementation_remove_listen_handler";
      BOOL v16 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v37 = 0;
      if (!__nwlog_fault(v16, &type, &v37)) {
        goto LABEL_83;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v17 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v40 = "nw_protocol_implementation_remove_listen_handler";
          _os_log_impl(&dword_1830D4000, v17, v20, "%{public}s called with null instance->parent_definition", buf, 0xCu);
        }
        goto LABEL_82;
      }
      if (!v37)
      {
        uint64_t v17 = __nwlog_obj();
        os_log_type_t v35 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v40 = "nw_protocol_implementation_remove_listen_handler";
          _os_log_impl(&dword_1830D4000, v17, v35, "%{public}s called with null instance->parent_definition, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_82;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v17 = __nwlog_obj();
      os_log_type_t v29 = type;
      BOOL v30 = os_log_type_enabled(v17, type);
      if (!backtrace_string)
      {
        if (v30)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v40 = "nw_protocol_implementation_remove_listen_handler";
          _os_log_impl(&dword_1830D4000, v17, v29, "%{public}s called with null instance->parent_definition, no backtrace", buf, 0xCu);
        }
        goto LABEL_82;
      }
      if (v30)
      {
        *(_DWORD *)int buf = 136446466;
        BOOL v40 = "nw_protocol_implementation_remove_listen_handler";
        __int16 v41 = 2082;
        int v42 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v17, v29, "%{public}s called with null instance->parent_definition, dumping backtrace:%{public}s", buf, 0x16u);
      }
    }
    else
    {
      uint64_t v15 = __nwlog_obj();
      *(_DWORD *)int buf = 136446210;
      BOOL v40 = "nw_protocol_implementation_remove_listen_handler";
      BOOL v16 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v37 = 0;
      if (!__nwlog_fault(v16, &type, &v37)) {
        goto LABEL_83;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v17 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v40 = "nw_protocol_implementation_remove_listen_handler";
          _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s called with null instance", buf, 0xCu);
        }
        goto LABEL_82;
      }
      if (!v37)
      {
        uint64_t v17 = __nwlog_obj();
        os_log_type_t v34 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v40 = "nw_protocol_implementation_remove_listen_handler";
          _os_log_impl(&dword_1830D4000, v17, v34, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_82;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v17 = __nwlog_obj();
      os_log_type_t v27 = type;
      BOOL v28 = os_log_type_enabled(v17, type);
      if (!backtrace_string)
      {
        if (v28)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v40 = "nw_protocol_implementation_remove_listen_handler";
          _os_log_impl(&dword_1830D4000, v17, v27, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }
        goto LABEL_82;
      }
      if (v28)
      {
        *(_DWORD *)int buf = 136446466;
        BOOL v40 = "nw_protocol_implementation_remove_listen_handler";
        __int16 v41 = 2082;
        int v42 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v17, v27, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
      }
    }
LABEL_55:

    free(backtrace_string);
    goto LABEL_83;
  }
  os_log_type_t v11 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  BOOL v40 = "nw_protocol_implementation_remove_listen_handler";
  BOOL v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v37 = 0;
  if (__nwlog_fault(v12, &type, &v37))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v40 = "nw_protocol_implementation_remove_listen_handler";
        _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null protocol", buf, 0xCu);
      }
    }
    else if (v37)
    {
      unsigned int v23 = (char *)__nw_create_backtrace_string();
      os_log_type_t v13 = __nwlog_obj();
      os_log_type_t v24 = type;
      BOOL v25 = os_log_type_enabled(v13, type);
      if (v23)
      {
        if (v25)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v40 = "nw_protocol_implementation_remove_listen_handler";
          __int16 v41 = 2082;
          int v42 = v23;
          _os_log_impl(&dword_1830D4000, v13, v24, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v23);
        goto LABEL_71;
      }
      if (v25)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v40 = "nw_protocol_implementation_remove_listen_handler";
        _os_log_impl(&dword_1830D4000, v13, v24, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v13 = __nwlog_obj();
      os_log_type_t v33 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v40 = "nw_protocol_implementation_remove_listen_handler";
        _os_log_impl(&dword_1830D4000, v13, v33, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_71:
  if (v12) {
    free(v12);
  }
  return 0;
}

void nw_masque_connection_pair_setup_outer_connection(void *a1, void *a2, int a3, void *a4)
{
  uint64_t v70 = *MEMORY[0x1E4F143B8];
  id v7 = a1;
  id v8 = a2;
  id v9 = a4;
  uint64_t v10 = (os_unfair_lock_s *)v7;
  id v11 = v9;
  if (v10)
  {
    *(void *)int buf = MEMORY[0x1E4F143A8];
    *(void *)&buf[8] = 3221225472;
    *(void *)&buf[16] = ___ZL40nw_masque_connection_pair_handle_headersP36NWConcrete_nw_masque_connection_pairPU29objcproto18OS_nw_http_request8NSObject_block_invoke;
    uint64_t v67 = (uint64_t (*)(uint64_t, uint64_t))&unk_1E5242598;
    BOOL v68 = v10;
    nw_http_fields_enumerate(v11, buf);

    goto LABEL_3;
  }
  unsigned int v26 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_masque_connection_pair_handle_headers";
  os_log_type_t v27 = (char *)_os_log_send_and_compose_impl();

  LOBYTE(v62[0]) = 16;
  LOBYTE(v56) = 0;
  if (__nwlog_fault(v27, v62, &v56))
  {
    if (LOBYTE(v62[0]) == 17)
    {
      BOOL v28 = __nwlog_obj();
      os_log_type_t v29 = v62[0];
      if (os_log_type_enabled(v28, v62[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_connection_pair_handle_headers";
        _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s called with null pair", buf, 0xCu);
      }
    }
    else if ((_BYTE)v56)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v28 = __nwlog_obj();
      os_log_type_t v35 = v62[0];
      BOOL v36 = os_log_type_enabled(v28, v62[0]);
      if (backtrace_string)
      {
        if (v36)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_masque_connection_pair_handle_headers";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v28, v35, "%{public}s called with null pair, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_44;
      }
      if (v36)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_connection_pair_handle_headers";
        _os_log_impl(&dword_1830D4000, v28, v35, "%{public}s called with null pair, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v28 = __nwlog_obj();
      os_log_type_t v39 = v62[0];
      if (os_log_type_enabled(v28, v62[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_connection_pair_handle_headers";
        _os_log_impl(&dword_1830D4000, v28, v39, "%{public}s called with null pair, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_44:
  if (v27) {
    free(v27);
  }
LABEL_3:

  if (a3 == 6)
  {
    nw_parameters_t secure_tcp = nw_parameters_create_secure_tcp(&__block_literal_global_19196, &__block_literal_global_98);
  }
  else if (a3 == 17)
  {
    nw_parameters_t secure_tcp = nw_parameters_create_secure_udp(&__block_literal_global_19196, &__block_literal_global_98);
  }
  else
  {
    nw_parameters_t secure_tcp = nw_parameters_create_custom_ip(a3, &__block_literal_global_98);
  }
  nw_parameters_t v13 = secure_tcp;
  uint64_t v56 = 0;
  uint64_t v57 = &v56;
  uint64_t v58 = 0x3032000000;
  int v59 = __Block_byref_object_copy__271;
  uint64_t v60 = __Block_byref_object_dispose__272;
  id v61 = 0;
  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 3221225472;
  aBlock[2] = ___ZL48nw_masque_connection_pair_setup_outer_connectionP36NWConcrete_nw_masque_connection_pairPU25objcproto14OS_nw_endpoint8NSObjecthPU29objcproto18OS_nw_http_requestS1__block_invoke;
  aBlock[3] = &unk_1E524B978;
  os_log_type_t v55 = &v56;
  os_log_type_t v14 = v10;
  nw_protocol_definition_t v54 = v14;
  uint64_t v15 = (void (**)(void))_Block_copy(aBlock);
  os_unfair_lock_lock(v10 + 2);
  v15[2](v15);
  os_unfair_lock_unlock(v10 + 2);

  BOOL v16 = (os_unfair_lock_s *)objc_loadWeakRetained((id *)(*(void *)&v14[4]._os_unfair_lock_opaque + 40));
  uint64_t v17 = v16;
  if (v16)
  {
    *(void *)int buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000;
    uint64_t v67 = __Block_byref_object_copy__89219;
    BOOL v68 = __Block_byref_object_dispose__89220;
    id v69 = 0;
    v62[0] = MEMORY[0x1E4F143A8];
    v62[1] = 3221225472;
    v62[2] = __nw_masque_server_copy_client_queue_block_invoke;
    v62[3] = &unk_1E524B978;
    int v64 = buf;
    int v63 = v16;
    os_log_type_t v18 = (void (**)(void))_Block_copy(v62);
    os_unfair_lock_lock(v17 + 4);
    v18[2](v18);
    os_unfair_lock_unlock(v17 + 4);

    os_log_type_t v19 = *(id *)(*(void *)&buf[8] + 40);
    _Block_object_dispose(buf, 8);

    goto LABEL_10;
  }
  BOOL v30 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_masque_server_copy_client_queue";
  int v42 = (const char *)_os_log_send_and_compose_impl();

  LOBYTE(v62[0]) = 16;
  char v65 = 0;
  os_log_type_t v31 = (char *)v42;
  if (__nwlog_fault(v42, v62, &v65))
  {
    if (LOBYTE(v62[0]) == 17)
    {
      BOOL v32 = __nwlog_obj();
      os_log_type_t v33 = v62[0];
      if (os_log_type_enabled(v32, v62[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_server_copy_client_queue";
        _os_log_impl(&dword_1830D4000, v32, v33, "%{public}s called with null server", buf, 0xCu);
      }
    }
    else if (v65)
    {
      char v37 = (char *)__nw_create_backtrace_string();
      BOOL v32 = __nwlog_obj();
      os_log_type_t type = v62[0];
      BOOL v38 = os_log_type_enabled(v32, v62[0]);
      if (v37)
      {
        if (v38)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_masque_server_copy_client_queue";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v37;
          _os_log_impl(&dword_1830D4000, v32, type, "%{public}s called with null server, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v37);
        goto LABEL_49;
      }
      if (v38)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_server_copy_client_queue";
        _os_log_impl(&dword_1830D4000, v32, type, "%{public}s called with null server, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v32 = __nwlog_obj();
      os_log_type_t v40 = v62[0];
      if (os_log_type_enabled(v32, v62[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_server_copy_client_queue";
        _os_log_impl(&dword_1830D4000, v32, v40, "%{public}s called with null server, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_49:
    os_log_type_t v31 = (char *)v42;
  }
  if (v31) {
    free(v31);
  }
  os_log_type_t v19 = 0;
LABEL_10:

  if (v57[5] && v19)
  {
    uint64_t v20 = *(void *)&v14[4]._os_unfair_lock_opaque;
    uint64_t v21 = *(void *)(v20 + 16);
    nw_endpoint_t v22 = nw_connection_copy_endpoint(*(nw_connection_t *)(v20 + 48));
    id v23 = *(id *)(*(void *)&v14[4]._os_unfair_lock_opaque + 32);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = ___ZL48nw_masque_connection_pair_setup_outer_connectionP36NWConcrete_nw_masque_connection_pairPU25objcproto14OS_nw_endpoint8NSObjecthPU29objcproto18OS_nw_http_requestS1__block_invoke_2;
    block[3] = &unk_1E523F690;
    BOOL v50 = &v56;
    uint64_t v51 = v21;
    id v44 = v8;
    uint64_t v45 = v13;
    nw_endpoint_t v46 = v22;
    id v47 = v11;
    id v48 = v23;
    os_log_type_t v49 = v14;
    char v52 = a3;
    id v24 = v23;
    BOOL v25 = v22;
    dispatch_async(v19, block);
  }
  else
  {
    nw_masque_connection_pair_setup_outer_connection_inner(v14, v8, a3, v13);
  }

  _Block_object_dispose(&v56, 8);
}

void sub_18348F0C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,id a39)
{
  _Block_object_dispose(&a34, 8);
  _Unwind_Resume(a1);
}

void nw_protocol_webtransport_http3_stream_connected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v116 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v101 = "nw_protocol_webtransport_http3_stream_connected";
    os_log_type_t v29 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v98 = 0;
    if (!__nwlog_fault(v29, &type, &v98)) {
      goto LABEL_87;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v30 = __nwlog_obj();
      os_log_type_t v31 = type;
      if (!os_log_type_enabled(v30, type)) {
        goto LABEL_87;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v101 = "nw_protocol_webtransport_http3_stream_connected";
      BOOL v32 = "%{public}s called with null protocol";
      goto LABEL_86;
    }
    if (!v98)
    {
      BOOL v30 = __nwlog_obj();
      os_log_type_t v31 = type;
      if (!os_log_type_enabled(v30, type)) {
        goto LABEL_87;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v101 = "nw_protocol_webtransport_http3_stream_connected";
      BOOL v32 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_86;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v30 = __nwlog_obj();
    os_log_type_t v31 = type;
    BOOL v37 = os_log_type_enabled(v30, type);
    if (!backtrace_string)
    {
      if (!v37) {
        goto LABEL_87;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v101 = "nw_protocol_webtransport_http3_stream_connected";
      BOOL v32 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_86;
    }
    if (v37)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v101 = "nw_protocol_webtransport_http3_stream_connected";
      __int16 v102 = 2082;
      os_log_type_t v103 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v30, v31, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_87:
    if (!v29) {
      return;
    }
    goto LABEL_88;
  }
  handle = (unsigned __int8 *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v101 = "nw_protocol_webtransport_http3_stream_connected";
    os_log_type_t v29 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v98 = 0;
    if (!__nwlog_fault(v29, &type, &v98)) {
      goto LABEL_87;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v30 = __nwlog_obj();
      os_log_type_t v31 = type;
      if (!os_log_type_enabled(v30, type)) {
        goto LABEL_87;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v101 = "nw_protocol_webtransport_http3_stream_connected";
      BOOL v32 = "%{public}s called with null webtransport_stream";
      goto LABEL_86;
    }
    if (!v98)
    {
      BOOL v30 = __nwlog_obj();
      os_log_type_t v31 = type;
      if (!os_log_type_enabled(v30, type)) {
        goto LABEL_87;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v101 = "nw_protocol_webtransport_http3_stream_connected";
      BOOL v32 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
      goto LABEL_86;
    }
    BOOL v38 = (char *)__nw_create_backtrace_string();
    BOOL v30 = __nwlog_obj();
    os_log_type_t v31 = type;
    BOOL v39 = os_log_type_enabled(v30, type);
    if (v38)
    {
      if (v39)
      {
        *(_DWORD *)int buf = 136446466;
        os_log_type_t v101 = "nw_protocol_webtransport_http3_stream_connected";
        __int16 v102 = 2082;
        os_log_type_t v103 = v38;
        _os_log_impl(&dword_1830D4000, v30, v31, "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v38);
      if (!v29) {
        return;
      }
LABEL_88:
      free(v29);
      return;
    }
    if (v39)
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v101 = "nw_protocol_webtransport_http3_stream_connected";
      BOOL v32 = "%{public}s called with null webtransport_stream, no backtrace";
LABEL_86:
      _os_log_impl(&dword_1830D4000, v30, v31, v32, buf, 0xCu);
      goto LABEL_87;
    }
    goto LABEL_87;
  }
  id v4 = (nw_protocol *)*((void *)handle + 11);
  int v5 = (handle[276] >> 4) & 1;
  p_cache = NWConcrete_nw_resolution_report.cache;
  if (!gLogDatapath) {
    LOBYTE(v5) = 1;
  }
  if (!v4)
  {
    if (v5) {
      return;
    }
    id v11 = __nwlog_obj();
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG)) {
      return;
    }
    uint64_t v40 = *((void *)handle + 11);
    if (v40) {
      int v41 = *(_DWORD *)(v40 + 460);
    }
    else {
      int v41 = -1;
    }
    uint64_t v49 = *((void *)handle + 8);
    *(_DWORD *)int buf = 136447234;
    os_log_type_t v101 = "nw_protocol_webtransport_http3_stream_connected";
    __int16 v102 = 2082;
    os_log_type_t v103 = (char *)(handle + 192);
    __int16 v104 = 2080;
    os_log_type_t v105 = " ";
    __int16 v106 = 1024;
    int v107 = v41;
    __int16 v108 = 2048;
    uint64_t v109 = v49;
    uint64_t v45 = "%{public}s %{public}s%s<i%u:s%lld> Stream is not fully setup. Ignoring connected.";
    goto LABEL_95;
  }
  if ((v5 & 1) == 0)
  {
    os_log_type_t v33 = __nwlog_obj();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v34 = *((void *)handle + 11);
      if (v34) {
        int v35 = *(_DWORD *)(v34 + 460);
      }
      else {
        int v35 = -1;
      }
      uint64_t v42 = *((void *)handle + 8);
      *(_DWORD *)int buf = 136447234;
      os_log_type_t v101 = "nw_protocol_webtransport_http3_stream_connected";
      __int16 v102 = 2082;
      os_log_type_t v103 = (char *)(handle + 192);
      __int16 v104 = 2080;
      os_log_type_t v105 = " ";
      __int16 v106 = 1024;
      int v107 = v35;
      __int16 v108 = 2048;
      uint64_t v109 = v42;
      _os_log_impl(&dword_1830D4000, v33, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Got a connected event from the lower layer", buf, 0x30u);
    }
  }
  nw_protocol_connected(a1->default_input_handler->flow_id, (uint64_t)a2);
  if (a1->output_handler == a2)
  {
    if (*((_DWORD *)handle + 46) == 2 || *((_DWORD *)handle + 47) == 2)
    {
      if ((handle[276] & 0x10) != 0) {
        return;
      }
      if (!gLogDatapath) {
        return;
      }
      id v11 = __nwlog_obj();
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG)) {
        return;
      }
      uint64_t v12 = *((void *)handle + 11);
      if (v12) {
        int v13 = *(_DWORD *)(v12 + 460);
      }
      else {
        int v13 = -1;
      }
      uint64_t v50 = *((void *)handle + 8);
      *(_DWORD *)int buf = 136447234;
      os_log_type_t v101 = "nw_protocol_webtransport_http3_stream_connected";
      __int16 v102 = 2082;
      os_log_type_t v103 = (char *)(handle + 192);
      __int16 v104 = 2080;
      os_log_type_t v105 = " ";
      __int16 v106 = 1024;
      int v107 = v13;
      __int16 v108 = 2048;
      uint64_t v109 = v50;
      uint64_t v45 = "%{public}s %{public}s%s<i%u:s%lld> stream is already connected, not forwarding";
LABEL_95:
      nw_endpoint_t v46 = v11;
      os_log_type_t v47 = OS_LOG_TYPE_DEBUG;
      goto LABEL_177;
    }
    if ((handle[276] & 8) != 0)
    {
      if (v4 != a2)
      {
        if ((handle[276] & 0x10) == 0)
        {
          if (gLogDatapath)
          {
            uint64_t v17 = __nwlog_obj();
            if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v18 = *((void *)handle + 11);
              if (v18) {
                int v19 = *(_DWORD *)(v18 + 460);
              }
              else {
                int v19 = -1;
              }
              uint64_t v62 = *((void *)handle + 8);
              *(_DWORD *)int buf = 136447490;
              os_log_type_t v101 = "nw_protocol_webtransport_http3_stream_connected";
              __int16 v102 = 2082;
              os_log_type_t v103 = (char *)(handle + 192);
              __int16 v104 = 2080;
              os_log_type_t v105 = " ";
              __int16 v106 = 1024;
              int v107 = v19;
              __int16 v108 = 2048;
              uint64_t v109 = v62;
              __int16 v110 = 2048;
              uint64_t v111 = v4;
              uint64_t v45 = "%{public}s %{public}s%s<i%u:s%lld> connected protocol is not our WebTransport session (%p), ignoring";
              nw_endpoint_t v46 = v17;
              os_log_type_t v47 = OS_LOG_TYPE_DEBUG;
              uint32_t v48 = 58;
              goto LABEL_178;
            }
          }
        }
        return;
      }
      goto LABEL_157;
    }
    if (*((void *)handle + 8) != -1)
    {
      if ((handle[276] & 0x10) == 0)
      {
        if (gLogDatapath)
        {
          os_log_type_t v14 = __nwlog_obj();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v15 = *((void *)handle + 11);
            if (v15) {
              int v16 = *(_DWORD *)(v15 + 460);
            }
            else {
              int v16 = -1;
            }
            id v61 = (nw_protocol *)*((void *)handle + 8);
            *(_DWORD *)int buf = 136447490;
            os_log_type_t v101 = "nw_webtransport_http3_stream_assign_stream_id";
            __int16 v102 = 2082;
            os_log_type_t v103 = (char *)(handle + 192);
            __int16 v104 = 2080;
            os_log_type_t v105 = " ";
            __int16 v106 = 1024;
            int v107 = v16;
            __int16 v108 = 2048;
            uint64_t v109 = (uint64_t)v61;
            __int16 v110 = 2048;
            uint64_t v111 = v61;
            _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Stream ID %llu already set, skipping", buf, 0x3Au);
          }
        }
      }
      goto LABEL_140;
    }
    uint64_t v20 = *((void *)handle + 11);
    if (v20)
    {
      uint64_t v21 = *((void *)handle + 4);
      if (v21)
      {
        nw_endpoint_t v22 = (void *)nw_protocol_copy_info(v21, 255);
        if (v22) {
          os_release(v22);
        }
        id v23 = *(void **)(v20 + 376);
        if (v23) {
          last_application_stream_uint64_t id = nw_http_connection_metadata_get_last_application_stream_id(v23);
        }
        else {
          last_application_stream_uint64_t id = -1;
        }
        if ((*(unsigned char *)(v20 + 548) & 2) == 0)
        {
          if (gLogDatapath)
          {
            os_log_type_t v55 = __nwlog_obj();
            if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
            {
              int v56 = *(_DWORD *)(v20 + 460);
              *(_DWORD *)int buf = 136447490;
              os_log_type_t v101 = "nw_webtransport_http3_get_quic_stream_id";
              __int16 v102 = 2082;
              os_log_type_t v103 = (char *)(v20 + 464);
              __int16 v104 = 2080;
              os_log_type_t v105 = " ";
              __int16 v106 = 1024;
              int v107 = v56;
              __int16 v108 = 2048;
              uint64_t v109 = last_application_stream_id;
              __int16 v110 = 1024;
              LODWORD(v111) = 0;
              _os_log_impl(&dword_1830D4000, v55, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> Got stream ID: %llu from session: %u", buf, 0x36u);
            }
          }
        }
        if (last_application_stream_id != -1)
        {
          *((void *)handle + 8) = last_application_stream_id;
          nw_webtransport_metadata_set_stream_id(*((void **)handle + 20), last_application_stream_id);
          if ((handle[276] & 0x10) == 0)
          {
            BOOL v25 = __nwlog_obj();
            if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
            {
              uint64_t v26 = *((void *)handle + 11);
              if (v26) {
                int v27 = *(_DWORD *)(v26 + 460);
              }
              else {
                int v27 = -1;
              }
              BOOL v28 = (nw_protocol *)*((void *)handle + 8);
              *(_DWORD *)int buf = 136448002;
              os_log_type_t v101 = "nw_webtransport_http3_stream_assign_stream_id";
              __int16 v102 = 2082;
              os_log_type_t v103 = (char *)(handle + 192);
              __int16 v104 = 2080;
              os_log_type_t v105 = " ";
              __int16 v106 = 1024;
              int v107 = v27;
              __int16 v108 = 2048;
              uint64_t v109 = (uint64_t)v28;
              __int16 v110 = 2048;
              uint64_t v111 = v28;
              __int16 v112 = 2048;
              os_log_type_t v113 = (nw_protocol_identifier *)handle;
              __int16 v114 = 1024;
              LODWORD(v115) = 0;
              _os_log_impl(&dword_1830D4000, v25, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> Assigned stream ID: %llu to stream with protocol %p, incoming: %u", buf, 0x4Au);
            }
          }
          goto LABEL_140;
        }
LABEL_133:
        if ((handle[276] & 0x10) == 0)
        {
          int v63 = __nwlog_obj();
          if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
          {
            uint64_t v64 = *((void *)handle + 11);
            if (v64) {
              int v65 = *(_DWORD *)(v64 + 460);
            }
            else {
              int v65 = -1;
            }
            uint64_t v66 = *((void *)handle + 8);
            *(_DWORD *)int buf = 136447234;
            os_log_type_t v101 = "nw_webtransport_http3_stream_assign_stream_id";
            __int16 v102 = 2082;
            os_log_type_t v103 = (char *)(handle + 192);
            __int16 v104 = 2080;
            os_log_type_t v105 = " ";
            __int16 v106 = 1024;
            int v107 = v65;
            __int16 v108 = 2048;
            uint64_t v109 = v66;
            _os_log_impl(&dword_1830D4000, v63, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> Failed to get stream ID for HTTP/3 webtransport stream, failing", buf, 0x30u);
          }
        }
        uint64_t v67 = (void *)*((void *)handle + 6);
        nw_protocol_error(v67, (uint64_t)handle);
        nw_protocol_disconnected(v67, (uint64_t)handle);
LABEL_140:
        uint64_t v68 = *((void *)handle + 11);
        if (v68)
        {
          if (*((void *)handle + 8) == -2)
          {
            if (*(void *)(v68 + 424))
            {
              if ((*(unsigned char *)(v68 + 548) & 2) == 0)
              {
                id v69 = __nwlog_obj();
                if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
                {
                  int v70 = *(_DWORD *)(v68 + 460);
                  *(_DWORD *)int buf = 136446978;
                  os_log_type_t v101 = "nw_webtransport_session_add_stream";
                  __int16 v102 = 2082;
                  os_log_type_t v103 = (char *)(v68 + 464);
                  __int16 v104 = 2080;
                  os_log_type_t v105 = " ";
                  __int16 v106 = 1024;
                  int v107 = v70;
                  id v71 = "%{public}s %{public}s%s<i%u> WebTransport already has datagram stream registered";
                  char v72 = v69;
                  os_log_type_t v73 = OS_LOG_TYPE_ERROR;
                  uint32_t v74 = 38;
LABEL_153:
                  _os_log_impl(&dword_1830D4000, v72, v73, v71, buf, v74);
                }
              }
LABEL_157:
              default_input_handler = a1->default_input_handler;
              if (!default_input_handler)
              {
                if ((handle[276] & 0x10) != 0) {
                  return;
                }
                nw_endpoint_t v84 = __nwlog_obj();
                if (!os_log_type_enabled(v84, OS_LOG_TYPE_ERROR)) {
                  return;
                }
                uint64_t v85 = *((void *)handle + 11);
                if (v85) {
                  int v86 = *(_DWORD *)(v85 + 460);
                }
                else {
                  int v86 = -1;
                }
                uint64_t v87 = *((void *)handle + 8);
                *(_DWORD *)int buf = 136447234;
                os_log_type_t v101 = "nw_protocol_webtransport_http3_stream_connected";
                __int16 v102 = 2082;
                os_log_type_t v103 = (char *)(handle + 192);
                __int16 v104 = 2080;
                os_log_type_t v105 = " ";
                __int16 v106 = 1024;
                int v107 = v86;
                __int16 v108 = 2048;
                uint64_t v109 = v87;
                uint64_t v45 = "%{public}s %{public}s%s<i%u:s%lld> No input handler found, ignoring connected call";
                nw_endpoint_t v46 = v84;
                os_log_type_t v47 = OS_LOG_TYPE_ERROR;
LABEL_177:
                uint32_t v48 = 48;
LABEL_178:
                _os_log_impl(&dword_1830D4000, v46, v47, v45, buf, v48);
                return;
              }
              if ((handle[276] & 4) != 0)
              {
                int v80 = 3;
                if ((handle[276] & 2) != 0) {
                  goto LABEL_163;
                }
                *((_DWORD *)handle + 46) = 3;
              }
              if (*((_DWORD *)handle + 47)) {
                goto LABEL_164;
              }
              int v80 = 2;
LABEL_163:
              *((_DWORD *)handle + 47) = v80;
LABEL_164:
              if (!*((_DWORD *)handle + 46)) {
                *((_DWORD *)handle + 46) = 2;
              }
              nw_protocol_connected(default_input_handler, (uint64_t)a1);
              if ((handle[276] & 0x10) == 0)
              {
                if (*((unsigned char *)p_cache + 3665))
                {
                  __int16 v81 = __nwlog_obj();
                  if (os_log_type_enabled(v81, OS_LOG_TYPE_DEBUG))
                  {
                    uint64_t v82 = *((void *)handle + 11);
                    if (v82) {
                      int v83 = *(_DWORD *)(v82 + 460);
                    }
                    else {
                      int v83 = -1;
                    }
                    os_log_type_t v97 = (nw_protocol_identifier *)*((void *)handle + 8);
                    *(_DWORD *)int buf = 136448002;
                    os_log_type_t v101 = "nw_protocol_webtransport_http3_stream_connected";
                    __int16 v102 = 2082;
                    os_log_type_t v103 = (char *)(handle + 192);
                    __int16 v104 = 2080;
                    os_log_type_t v105 = " ";
                    __int16 v106 = 1024;
                    int v107 = v83;
                    __int16 v108 = 2048;
                    uint64_t v109 = (uint64_t)v97;
                    __int16 v110 = 2048;
                    uint64_t v111 = a1;
                    __int16 v112 = 2048;
                    os_log_type_t v113 = v97;
                    __int16 v114 = 2048;
                    BOOL v115 = a2;
                    uint64_t v45 = "%{public}s %{public}s%s<i%u:s%lld> webtransport http3 stream %p with id %llu connected with output_handler %p";
                    nw_endpoint_t v46 = v81;
                    os_log_type_t v47 = OS_LOG_TYPE_DEBUG;
                    uint32_t v48 = 78;
                    goto LABEL_178;
                  }
                }
              }
              return;
            }
            *(void *)(v68 + 424) = handle;
          }
          else
          {
            uint64_t no_lock = *(void *)(v68 + 184);
            if (!no_lock)
            {
              uint64_t no_lock = nw_hash_table_create_no_lock(0x11u, 0, (const void *(*)(const void *, unsigned int *))nw_webtransport_stream_get_key, (unsigned int (*)(const void *, unsigned int))nw_webtransport_stream_key_hash, (BOOL (*)(const void *, const void *, unsigned int))nw_webtransport_stream_matches_key, 0);
              *(void *)(v68 + 184) = no_lock;
            }
            os_log_type_t type = OS_LOG_TYPE_DEFAULT;
            nw_hash_table_add_object(no_lock, (uint64_t)handle, (char *)&type);
            if (type == OS_LOG_TYPE_DEFAULT)
            {
              if ((*(unsigned char *)(v68 + 548) & 2) != 0) {
                goto LABEL_157;
              }
              BOOL v76 = __nwlog_obj();
              if (!os_log_type_enabled(v76, OS_LOG_TYPE_ERROR)) {
                goto LABEL_157;
              }
              int v77 = *(_DWORD *)(v68 + 460);
              uint64_t v78 = *((void *)handle + 8);
              *(_DWORD *)int buf = 136447234;
              os_log_type_t v101 = "nw_webtransport_session_add_stream";
              __int16 v102 = 2082;
              os_log_type_t v103 = (char *)(v68 + 464);
              __int16 v104 = 2080;
              os_log_type_t v105 = " ";
              __int16 v106 = 1024;
              int v107 = v77;
              __int16 v108 = 2048;
              uint64_t v109 = v78;
              id v71 = "%{public}s %{public}s%s<i%u> WebTransport already has stream id registered for %llu";
              char v72 = v76;
              os_log_type_t v73 = OS_LOG_TYPE_ERROR;
LABEL_152:
              uint32_t v74 = 48;
              goto LABEL_153;
            }
          }
          if ((*(unsigned char *)(v68 + 548) & 2) != 0) {
            goto LABEL_157;
          }
          if (!gLogDatapath) {
            goto LABEL_157;
          }
          int v92 = __nwlog_obj();
          if (!os_log_type_enabled(v92, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_157;
          }
          int v93 = *(_DWORD *)(v68 + 460);
          uint64_t v94 = *((void *)handle + 8);
          *(_DWORD *)int buf = 136447234;
          os_log_type_t v101 = "nw_webtransport_session_add_stream";
          __int16 v102 = 2082;
          os_log_type_t v103 = (char *)(v68 + 464);
          __int16 v104 = 2080;
          os_log_type_t v105 = " ";
          __int16 v106 = 1024;
          int v107 = v93;
          __int16 v108 = 2048;
          uint64_t v109 = v94;
          id v71 = "%{public}s %{public}s%s<i%u> Added stream %llu to WebTransport streams";
          char v72 = v92;
          os_log_type_t v73 = OS_LOG_TYPE_DEBUG;
          goto LABEL_152;
        }
        __nwlog_obj();
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v101 = "nw_webtransport_session_add_stream";
        id v88 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v98 = 0;
        if (__nwlog_fault(v88, &type, &v98))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            unsigned int v89 = __nwlog_obj();
            os_log_type_t v90 = type;
            if (os_log_type_enabled(v89, type))
            {
              *(_DWORD *)int buf = 136446210;
              os_log_type_t v101 = "nw_webtransport_session_add_stream";
              os_log_type_t v91 = "%{public}s called with null webtransport_session";
LABEL_196:
              _os_log_impl(&dword_1830D4000, v89, v90, v91, buf, 0xCu);
            }
          }
          else if (v98)
          {
            os_log_type_t v95 = (char *)__nw_create_backtrace_string();
            unsigned int v89 = __nwlog_obj();
            os_log_type_t v90 = type;
            BOOL v96 = os_log_type_enabled(v89, type);
            if (v95)
            {
              if (v96)
              {
                *(_DWORD *)int buf = 136446466;
                os_log_type_t v101 = "nw_webtransport_session_add_stream";
                __int16 v102 = 2082;
                os_log_type_t v103 = v95;
                _os_log_impl(&dword_1830D4000, v89, v90, "%{public}s called with null webtransport_session, dumping backtrace:%{public}s", buf, 0x16u);
              }
              free(v95);
              goto LABEL_197;
            }
            if (v96)
            {
              *(_DWORD *)int buf = 136446210;
              os_log_type_t v101 = "nw_webtransport_session_add_stream";
              os_log_type_t v91 = "%{public}s called with null webtransport_session, no backtrace";
              goto LABEL_196;
            }
          }
          else
          {
            unsigned int v89 = __nwlog_obj();
            os_log_type_t v90 = type;
            if (os_log_type_enabled(v89, type))
            {
              *(_DWORD *)int buf = 136446210;
              os_log_type_t v101 = "nw_webtransport_session_add_stream";
              os_log_type_t v91 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
              goto LABEL_196;
            }
          }
        }
LABEL_197:
        if (v88) {
          free(v88);
        }
        p_cache = (void **)(NWConcrete_nw_resolution_report + 16);
        goto LABEL_157;
      }
      __nwlog_obj();
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v101 = "nw_webtransport_http3_get_quic_stream_id";
      uint64_t v51 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v98 = 0;
      if (__nwlog_fault(v51, &type, &v98))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          char v52 = __nwlog_obj();
          os_log_type_t v53 = type;
          if (!os_log_type_enabled(v52, type)) {
            goto LABEL_130;
          }
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v101 = "nw_webtransport_http3_get_quic_stream_id";
          nw_protocol_definition_t v54 = "%{public}s called with null output_protocol";
          goto LABEL_129;
        }
        if (!v98)
        {
          char v52 = __nwlog_obj();
          os_log_type_t v53 = type;
          if (!os_log_type_enabled(v52, type)) {
            goto LABEL_130;
          }
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v101 = "nw_webtransport_http3_get_quic_stream_id";
          nw_protocol_definition_t v54 = "%{public}s called with null output_protocol, backtrace limit exceeded";
          goto LABEL_129;
        }
        int v59 = (char *)__nw_create_backtrace_string();
        char v52 = __nwlog_obj();
        os_log_type_t v53 = type;
        BOOL v60 = os_log_type_enabled(v52, type);
        if (!v59)
        {
          if (!v60) {
            goto LABEL_130;
          }
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v101 = "nw_webtransport_http3_get_quic_stream_id";
          nw_protocol_definition_t v54 = "%{public}s called with null output_protocol, no backtrace";
          goto LABEL_129;
        }
        if (v60)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v101 = "nw_webtransport_http3_get_quic_stream_id";
          __int16 v102 = 2082;
          os_log_type_t v103 = v59;
          _os_log_impl(&dword_1830D4000, v52, v53, "%{public}s called with null output_protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v59);
      }
LABEL_130:
      if (!v51)
      {
LABEL_132:
        p_cache = NWConcrete_nw_resolution_report.cache;
        goto LABEL_133;
      }
LABEL_131:
      free(v51);
      goto LABEL_132;
    }
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v101 = "nw_webtransport_http3_get_quic_stream_id";
    uint64_t v51 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v98 = 0;
    if (!__nwlog_fault(v51, &type, &v98)) {
      goto LABEL_130;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v52 = __nwlog_obj();
      os_log_type_t v53 = type;
      if (!os_log_type_enabled(v52, type)) {
        goto LABEL_130;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v101 = "nw_webtransport_http3_get_quic_stream_id";
      nw_protocol_definition_t v54 = "%{public}s called with null webtransport_session";
    }
    else
    {
      if (!v98)
      {
        char v52 = __nwlog_obj();
        os_log_type_t v53 = type;
        if (!os_log_type_enabled(v52, type)) {
          goto LABEL_130;
        }
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v101 = "nw_webtransport_http3_get_quic_stream_id";
        nw_protocol_definition_t v54 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
        goto LABEL_129;
      }
      uint64_t v57 = (char *)__nw_create_backtrace_string();
      char v52 = __nwlog_obj();
      os_log_type_t v53 = type;
      BOOL v58 = os_log_type_enabled(v52, type);
      if (v57)
      {
        if (v58)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v101 = "nw_webtransport_http3_get_quic_stream_id";
          __int16 v102 = 2082;
          os_log_type_t v103 = v57;
          _os_log_impl(&dword_1830D4000, v52, v53, "%{public}s called with null webtransport_session, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v57);
        if (!v51) {
          goto LABEL_132;
        }
        goto LABEL_131;
      }
      if (!v58) {
        goto LABEL_130;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v101 = "nw_webtransport_http3_get_quic_stream_id";
      nw_protocol_definition_t v54 = "%{public}s called with null webtransport_session, no backtrace";
    }
LABEL_129:
    _os_log_impl(&dword_1830D4000, v52, v53, v54, buf, 0xCu);
    goto LABEL_130;
  }
  if ((handle[276] & 0x10) == 0)
  {
    if (gLogDatapath)
    {
      id v8 = __nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v9 = *((void *)handle + 11);
        if (v9) {
          int v10 = *(_DWORD *)(v9 + 460);
        }
        else {
          int v10 = -1;
        }
        uint64_t v43 = *((void *)handle + 8);
        identifier = a2->identifier;
        *(_DWORD *)int buf = 136447746;
        os_log_type_t v101 = "nw_protocol_webtransport_http3_stream_connected";
        __int16 v102 = 2082;
        os_log_type_t v103 = (char *)(handle + 192);
        __int16 v104 = 2080;
        os_log_type_t v105 = " ";
        __int16 v106 = 1024;
        int v107 = v10;
        __int16 v108 = 2048;
        uint64_t v109 = v43;
        __int16 v110 = 2048;
        uint64_t v111 = a2;
        __int16 v112 = 2080;
        os_log_type_t v113 = identifier;
        uint64_t v45 = "%{public}s %{public}s%s<i%u:s%lld> connected protocol %p (%s) is not our output_handler, ignoring";
        nw_endpoint_t v46 = v8;
        os_log_type_t v47 = OS_LOG_TYPE_DEBUG;
        uint32_t v48 = 68;
        goto LABEL_178;
      }
    }
  }
}

uint64_t nw_browser_check_and_remove_endpoints_locked(void *a1, void *a2, void *a3, void *a4)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  id v7 = a1;
  id v8 = a2;
  id v9 = a3;
  id v10 = a4;
  if (!v7)
  {
    uint64_t v20 = __nwlog_obj();
    *(_DWORD *)__s = 136446210;
    uint64_t v42 = "nw_browser_check_and_remove_endpoints_locked";
    uint64_t v21 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    char v36 = 0;
    if (__nwlog_fault(v21, buf, &v36))
    {
      if (buf[0] == 17)
      {
        nw_endpoint_t v22 = __nwlog_obj();
        os_log_type_t v23 = buf[0];
        if (os_log_type_enabled(v22, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)__s = 136446210;
          uint64_t v42 = "nw_browser_check_and_remove_endpoints_locked";
          _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s called with null browser", (uint8_t *)__s, 0xCu);
        }
        goto LABEL_50;
      }
      if (!v36)
      {
        nw_endpoint_t v22 = __nwlog_obj();
        os_log_type_t v31 = buf[0];
        if (os_log_type_enabled(v22, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)__s = 136446210;
          uint64_t v42 = "nw_browser_check_and_remove_endpoints_locked";
          _os_log_impl(&dword_1830D4000, v22, v31, "%{public}s called with null browser, backtrace limit exceeded", (uint8_t *)__s, 0xCu);
        }
        goto LABEL_50;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      nw_endpoint_t v22 = __nwlog_obj();
      os_log_type_t v27 = buf[0];
      BOOL v28 = os_log_type_enabled(v22, (os_log_type_t)buf[0]);
      if (!backtrace_string)
      {
        if (v28)
        {
          *(_DWORD *)__s = 136446210;
          uint64_t v42 = "nw_browser_check_and_remove_endpoints_locked";
          _os_log_impl(&dword_1830D4000, v22, v27, "%{public}s called with null browser, no backtrace", (uint8_t *)__s, 0xCu);
        }
        goto LABEL_50;
      }
      if (v28)
      {
        *(_DWORD *)__s = 136446466;
        uint64_t v42 = "nw_browser_check_and_remove_endpoints_locked";
        __int16 v43 = 2082;
        id v44 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v22, v27, "%{public}s called with null browser, dumping backtrace:%{public}s", (uint8_t *)__s, 0x16u);
      }
LABEL_38:

      free(backtrace_string);
    }
LABEL_51:
    if (v21) {
      free(v21);
    }
    uint64_t v18 = 0;
    goto LABEL_18;
  }
  if (!v9)
  {
    id v24 = __nwlog_obj();
    *(_DWORD *)__s = 136446210;
    uint64_t v42 = "nw_browser_check_and_remove_endpoints_locked";
    uint64_t v21 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    char v36 = 0;
    if (__nwlog_fault(v21, buf, &v36))
    {
      if (buf[0] == 17)
      {
        nw_endpoint_t v22 = __nwlog_obj();
        os_log_type_t v25 = buf[0];
        if (os_log_type_enabled(v22, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)__s = 136446210;
          uint64_t v42 = "nw_browser_check_and_remove_endpoints_locked";
          _os_log_impl(&dword_1830D4000, v22, v25, "%{public}s called with null old_endpoint", (uint8_t *)__s, 0xCu);
        }
LABEL_50:

        goto LABEL_51;
      }
      if (!v36)
      {
        nw_endpoint_t v22 = __nwlog_obj();
        os_log_type_t v32 = buf[0];
        if (os_log_type_enabled(v22, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)__s = 136446210;
          uint64_t v42 = "nw_browser_check_and_remove_endpoints_locked";
          _os_log_impl(&dword_1830D4000, v22, v32, "%{public}s called with null old_endpoint, backtrace limit exceeded", (uint8_t *)__s, 0xCu);
        }
        goto LABEL_50;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      nw_endpoint_t v22 = __nwlog_obj();
      os_log_type_t v29 = buf[0];
      BOOL v30 = os_log_type_enabled(v22, (os_log_type_t)buf[0]);
      if (!backtrace_string)
      {
        if (v30)
        {
          *(_DWORD *)__s = 136446210;
          uint64_t v42 = "nw_browser_check_and_remove_endpoints_locked";
          _os_log_impl(&dword_1830D4000, v22, v29, "%{public}s called with null old_endpoint, no backtrace", (uint8_t *)__s, 0xCu);
        }
        goto LABEL_50;
      }
      if (v30)
      {
        *(_DWORD *)__s = 136446466;
        uint64_t v42 = "nw_browser_check_and_remove_endpoints_locked";
        __int16 v43 = 2082;
        id v44 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v22, v29, "%{public}s called with null old_endpoint, dumping backtrace:%{public}s", (uint8_t *)__s, 0x16u);
      }
      goto LABEL_38;
    }
    goto LABEL_51;
  }
  v33[0] = MEMORY[0x1E4F143A8];
  v33[1] = 3221225472;
  v33[2] = ___ZL44nw_browser_check_and_remove_endpoints_lockedP21NWConcrete_nw_browserPU22objcproto11OS_nw_array8NSObjectPU25objcproto14OS_nw_endpointS1_PU26objcproto15OS_nw_interfaceS1__block_invoke;
  v33[3] = &unk_1E5247FB8;
  id v11 = v9;
  id v34 = v11;
  id v12 = v10;
  id v35 = v12;
  if (nw_array_apply(v8, (uint64_t)v33))
  {
    bzero(__s, 0x3F1uLL);
    uint64_t domain_for_policy = nw_endpoint_get_domain_for_policy(v11);
    if (domain_for_policy)
    {
      uint64_t v14 = 0;
      while (1)
      {
        int v15 = *(unsigned __int8 *)(domain_for_policy + v14);
        __s[v14] = v15;
        if (!v15) {
          break;
        }
        if (++v14 == 1008)
        {
          char v45 = 0;
          break;
        }
      }
      for (size_t i = 0; i < strlen(__s); ++i)
        __s[i] = __tolower(__s[i]);
    }
    else
    {
      nw_browser_copy_key_for_application_service_endpoint(v11, __s);
    }
    if ((nw_browser_remove_result_locked(v7, __s, v12) & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v17 = (id)gLogObj;
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446466;
        BOOL v38 = "nw_browser_check_and_remove_endpoints_locked";
        __int16 v39 = 2080;
        uint64_t v40 = __s;
        _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_ERROR, "%{public}s Failed to remove result for %s", buf, 0x16u);
      }
    }
  }

  uint64_t v18 = 1;
LABEL_18:

  return v18;
}

void sub_183490BC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_default_unregister_notification(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v14 = "nw_protocol_default_unregister_notification";
    int v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (!__nwlog_fault(v5, &type, &v11)) {
      goto LABEL_22;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_22;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v14 = "nw_protocol_default_unregister_notification";
      id v8 = "%{public}s called with null protocol";
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v14 = "nw_protocol_default_unregister_notification";
          __int16 v15 = 2082;
          int v16 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_22;
      }
      if (!v10)
      {
LABEL_22:
        if (v5) {
          free(v5);
        }
        return 0;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v14 = "nw_protocol_default_unregister_notification";
      id v8 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_22;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v14 = "nw_protocol_default_unregister_notification";
      id v8 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0xCu);
    goto LABEL_22;
  }
  uint64_t v1 = *(void *)(a1 + 32);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = *(void *)(v1 + 24);
  if (!v2) {
    return 0;
  }
  id v3 = *(uint64_t (**)(void))(v2 + 152);
  if (!v3) {
    return 0;
  }

  return v3();
}

uint64_t nw_protocol_default_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  if (!a1)
  {
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v25 = "nw_protocol_default_finalize_output_frames";
    id v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (!__nwlog_fault(v4, &type, &v22)) {
      goto LABEL_27;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_27;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v25 = "nw_protocol_default_finalize_output_frames";
      id v8 = "%{public}s called with null protocol";
    }
    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v21 = os_log_type_enabled(v18, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v25 = "nw_protocol_default_finalize_output_frames";
          __int16 v26 = 2082;
          os_log_type_t v27 = (nw_protocol_identifier *)backtrace_string;
          _os_log_impl(&dword_1830D4000, v18, v19, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        if (v4) {
          goto LABEL_28;
        }
        return 0;
      }
      if (!v21) {
        goto LABEL_27;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v25 = "nw_protocol_default_finalize_output_frames";
      id v8 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      uint64_t v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_27;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v25 = "nw_protocol_default_finalize_output_frames";
      id v8 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    uint64_t v14 = v18;
    os_log_type_t v15 = v19;
    uint32_t v16 = 12;
    goto LABEL_26;
  }
  identifier = a1->identifier;
  if (!identifier) {
    identifier = (nw_protocol_identifier *)"invalid";
  }
  *(_DWORD *)int buf = 136446466;
  os_log_type_t v25 = "nw_protocol_default_finalize_output_frames";
  __int16 v26 = 2082;
  os_log_type_t v27 = identifier;
  id v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v22 = 0;
  if (__nwlog_fault(v4, &type, &v22))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v5 = gLogObj;
      os_log_type_t v6 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_27;
      }
      os_log_type_t v7 = a1->identifier;
      if (!v7) {
        os_log_type_t v7 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v25 = "nw_protocol_default_finalize_output_frames";
      __int16 v26 = 2082;
      os_log_type_t v27 = v7;
      id v8 = "%{public}s Default protocol handler does not support finalize_output_frames for %{public}s";
LABEL_25:
      uint64_t v14 = v5;
      os_log_type_t v15 = v6;
      uint32_t v16 = 22;
LABEL_26:
      _os_log_impl(&dword_1830D4000, v14, v15, v8, buf, v16);
      goto LABEL_27;
    }
    if (!v22)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v5 = gLogObj;
      os_log_type_t v6 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_27;
      }
      id v12 = a1->identifier;
      if (!v12) {
        id v12 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v25 = "nw_protocol_default_finalize_output_frames";
      __int16 v26 = 2082;
      os_log_type_t v27 = v12;
      id v8 = "%{public}s Default protocol handler does not support finalize_output_frames for %{public}s, backtrace limit exceeded";
      goto LABEL_25;
    }
    id v9 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v5 = gLogObj;
    os_log_type_t v6 = type;
    BOOL v10 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v9)
    {
      if (!v10) {
        goto LABEL_27;
      }
      int v13 = a1->identifier;
      if (!v13) {
        int v13 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v25 = "nw_protocol_default_finalize_output_frames";
      __int16 v26 = 2082;
      os_log_type_t v27 = v13;
      id v8 = "%{public}s Default protocol handler does not support finalize_output_frames for %{public}s, no backtrace";
      goto LABEL_25;
    }
    if (v10)
    {
      char v11 = a1->identifier;
      if (!v11) {
        char v11 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)int buf = 136446722;
      os_log_type_t v25 = "nw_protocol_default_finalize_output_frames";
      __int16 v26 = 2082;
      os_log_type_t v27 = v11;
      __int16 v28 = 2082;
      os_log_type_t v29 = v9;
      _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s Default protocol handler does not support finalize_output_frames for %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
    }
    free(v9);
  }
LABEL_27:
  if (v4) {
LABEL_28:
  }
    free(v4);
  return 0;
}

uint64_t nw_protocol_default_remove_listen_handler(nw_protocol *a1, nw_listen_protocol *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v3 = gLogObj;
  if (a1)
  {
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      identifier = (nw_protocol_identifier *)"invalid";
      if (a1->identifier) {
        identifier = a1->identifier;
      }
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v15 = "nw_protocol_default_remove_listen_handler";
      __int16 v16 = 2082;
      uint64_t v17 = identifier;
      _os_log_impl(&dword_1830D4000, v3, OS_LOG_TYPE_INFO, "%{public}s Default protocol handler does not support remove_listen_handler for %{public}s", buf, 0x16u);
    }
    return 0;
  }
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v15 = "nw_protocol_default_remove_listen_handler";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v6, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v15 = "nw_protocol_default_remove_listen_handler";
      id v9 = "%{public}s called with null protocol";
      goto LABEL_20;
    }
    if (!v12)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v15 = "nw_protocol_default_remove_listen_handler";
      id v9 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_20;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v7 = __nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v11 = os_log_type_enabled(v7, type);
    if (backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)int buf = 136446466;
        os_log_type_t v15 = "nw_protocol_default_remove_listen_handler";
        __int16 v16 = 2082;
        uint64_t v17 = (nw_protocol_identifier *)backtrace_string;
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_21;
    }
    if (v11)
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v15 = "nw_protocol_default_remove_listen_handler";
      id v9 = "%{public}s called with null protocol, no backtrace";
LABEL_20:
      _os_log_impl(&dword_1830D4000, v7, v8, v9, buf, 0xCu);
    }
  }
LABEL_21:
  if (v6) {
    free(v6);
  }
  return 0;
}

void nw_socks5_connection_send_reply_on_queue(void *a1, char a2, void *a3)
{
  uint64_t v126 = *MEMORY[0x1E4F143B8];
  int v5 = a1;
  os_log_type_t v6 = a3;
  int sc_state = v5->sc_state;
  if (sc_state == 255 || (*((unsigned char *)v5 + 160) & 8) != 0) {
    goto LABEL_33;
  }
  if (!v5->sc_in_connection)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v10 = (id)gLogObj;
    *(_DWORD *)int buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_socks5_connection_send_reply_on_queue";
    *(_WORD *)&unsigned char buf[12] = 2114;
    *(void *)&buf[14] = v5;
    BOOL v11 = (char *)_os_log_send_and_compose_impl();

    v124[0] = 16;
    LOBYTE(buffer) = 0;
    if (__nwlog_fault(v11, v124, &buffer))
    {
      if (v124[0] == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v12 = (id)gLogObj;
        os_log_type_t v13 = v124[0];
        if (os_log_type_enabled(v12, (os_log_type_t)v124[0]))
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_socks5_connection_send_reply_on_queue";
          *(_WORD *)&unsigned char buf[12] = 2114;
          *(void *)&buf[14] = v5;
          _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s %{public}@ cannot send reply without inner connection", buf, 0x16u);
        }
      }
      else if ((_BYTE)buffer)
      {
        backtrace_string = __nw_create_backtrace_string();
        if (backtrace_string)
        {
          os_log_type_t v15 = (uint64_t (*)(uint64_t, uint64_t))backtrace_string;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v16 = (id)gLogObj;
          os_log_type_t v17 = v124[0];
          if (os_log_type_enabled(v16, (os_log_type_t)v124[0]))
          {
            *(_DWORD *)int buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_socks5_connection_send_reply_on_queue";
            *(_WORD *)&unsigned char buf[12] = 2114;
            *(void *)&buf[14] = v5;
            *(_WORD *)&unsigned char buf[22] = 2082;
            os_log_type_t v121 = v15;
            _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s %{public}@ cannot send reply without inner connection, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(v15);
          if (!v11) {
            goto LABEL_33;
          }
          goto LABEL_32;
        }
        char v12 = __nwlog_obj();
        os_log_type_t v23 = v124[0];
        if (os_log_type_enabled(v12, (os_log_type_t)v124[0]))
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_socks5_connection_send_reply_on_queue";
          *(_WORD *)&unsigned char buf[12] = 2114;
          *(void *)&buf[14] = v5;
          _os_log_impl(&dword_1830D4000, v12, v23, "%{public}s %{public}@ cannot send reply without inner connection, no backtrace", buf, 0x16u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v12 = (id)gLogObj;
        os_log_type_t v22 = v124[0];
        if (os_log_type_enabled(v12, (os_log_type_t)v124[0]))
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_socks5_connection_send_reply_on_queue";
          *(_WORD *)&unsigned char buf[12] = 2114;
          *(void *)&buf[14] = v5;
          _os_log_impl(&dword_1830D4000, v12, v22, "%{public}s %{public}@ cannot send reply without inner connection, backtrace limit exceeded", buf, 0x16u);
        }
      }
    }
    if (!v11)
    {
LABEL_33:
      v6[2](v6, 0);
LABEL_34:

      return;
    }
LABEL_32:
    free(v11);
    goto LABEL_33;
  }
  if ((sc_state - 101) < 5)
  {
    int v8 = 0;
    int v9 = 1;
    goto LABEL_49;
  }
  if ((sc_state - 7) < 2)
  {
    int v9 = 0;
    int v8 = 1;
    goto LABEL_49;
  }
  if (!v5->sc_state)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v18 = (id)gLogObj;
    *(_DWORD *)int buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_socks5_connection_send_reply_on_queue";
    *(_WORD *)&unsigned char buf[12] = 2114;
    *(void *)&buf[14] = v5;
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

    v124[0] = 16;
    LOBYTE(buffer) = 0;
    if (__nwlog_fault(v19, v124, &buffer))
    {
      if (v124[0] == 17)
      {
        uint64_t v20 = __nwlog_obj();
        os_log_type_t v21 = v124[0];
        if (os_log_type_enabled(v20, (os_log_type_t)v124[0]))
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_socks5_connection_send_reply_on_queue";
          *(_WORD *)&unsigned char buf[12] = 2114;
          *(void *)&buf[14] = v5;
          _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s %{public}@ cannot send reply from invalid state", buf, 0x16u);
        }
      }
      else if ((_BYTE)buffer)
      {
        id v24 = (char *)__nw_create_backtrace_string();
        uint64_t v20 = __nwlog_obj();
        os_log_type_t v25 = v124[0];
        BOOL v26 = os_log_type_enabled(v20, (os_log_type_t)v124[0]);
        if (v24)
        {
          if (v26)
          {
            *(_DWORD *)int buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_socks5_connection_send_reply_on_queue";
            *(_WORD *)&unsigned char buf[12] = 2114;
            *(void *)&buf[14] = v5;
            *(_WORD *)&unsigned char buf[22] = 2082;
            os_log_type_t v121 = (uint64_t (*)(uint64_t, uint64_t))v24;
            _os_log_impl(&dword_1830D4000, v20, v25, "%{public}s %{public}@ cannot send reply from invalid state, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(v24);
          goto LABEL_46;
        }
        if (v26)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_socks5_connection_send_reply_on_queue";
          *(_WORD *)&unsigned char buf[12] = 2114;
          *(void *)&buf[14] = v5;
          _os_log_impl(&dword_1830D4000, v20, v25, "%{public}s %{public}@ cannot send reply from invalid state, no backtrace", buf, 0x16u);
        }
      }
      else
      {
        uint64_t v20 = __nwlog_obj();
        os_log_type_t v27 = v124[0];
        if (os_log_type_enabled(v20, (os_log_type_t)v124[0]))
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_socks5_connection_send_reply_on_queue";
          *(_WORD *)&unsigned char buf[12] = 2114;
          *(void *)&buf[14] = v5;
          _os_log_impl(&dword_1830D4000, v20, v27, "%{public}s %{public}@ cannot send reply from invalid state, backtrace limit exceeded", buf, 0x16u);
        }
      }
    }
LABEL_46:
    if (v19) {
      free(v19);
    }
  }
  int v9 = 0;
  int v8 = 0;
LABEL_49:
  *(void *)int buf = 0;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x3032000000;
  os_log_type_t v121 = __Block_byref_object_copy__16230;
  BOOL v122 = __Block_byref_object_dispose__16231;
  id v123 = 0;
  if (!v9)
  {
    if (!v8) {
      goto LABEL_161;
    }
    LOBYTE(buffer) = 5;
    BYTE1(buffer) = a2 ^ 1;
    *(_DWORD *)((char *)&buffer + 2) = 768;
    BYTE6(buffer) = 0;
    dispatch_data_t v37 = dispatch_data_create(&buffer, 7uLL, 0, 0);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v38 = (id)gLogObj;
    __int16 v39 = v38;
    if (a2)
    {
      if (!os_log_type_enabled(v38, OS_LOG_TYPE_INFO)) {
        goto LABEL_103;
      }
      *(_DWORD *)BOOL v124 = 136446466;
      *(void *)&v124[4] = "nw_socks5_connection_send_reply_on_queue";
      *(_WORD *)&v124[12] = 2114;
      *(void *)&v124[14] = v5;
      uint64_t v40 = "%{public}s %{public}@ sending SOCKS success reply";
      int v41 = v39;
      os_log_type_t v42 = OS_LOG_TYPE_INFO;
    }
    else
    {
      if (!os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
        goto LABEL_103;
      }
      *(_DWORD *)BOOL v124 = 136446466;
      *(void *)&v124[4] = "nw_socks5_connection_send_reply_on_queue";
      *(_WORD *)&v124[12] = 2114;
      *(void *)&v124[14] = v5;
      uint64_t v40 = "%{public}s %{public}@ sending SOCKS failure reply";
      int v41 = v39;
      os_log_type_t v42 = OS_LOG_TYPE_ERROR;
    }
    _os_log_impl(&dword_1830D4000, v41, v42, v40, v124, 0x16u);
LABEL_103:

    if (v37) {
      goto LABEL_104;
    }
LABEL_161:
    v6[2](v6, 0);
    dispatch_data_t v37 = 0;
LABEL_162:
    _Block_object_dispose(buf, 8);

    goto LABEL_34;
  }
  char __src = 0;
  if (a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v28 = (id)gLogObj;
    if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)BOOL v124 = 136446466;
      *(void *)&v124[4] = "nw_socks5_connection_send_reply_on_queue";
      *(_WORD *)&v124[12] = 2114;
      *(void *)&v124[14] = v5;
      _os_log_impl(&dword_1830D4000, v28, OS_LOG_TYPE_INFO, "%{public}s %{public}@ sending SHOES success reply", v124, 0x16u);
    }

    os_log_type_t v29 = nw_connection_copy_connected_path(v5->sc_out_connection);
    uint64_t v30 = v29;
    if (v29)
    {
      BOOL is_expensive = nw_path_is_expensive(v29);
      BOOL v32 = nw_path_uses_interface_type(v30, nw_interface_type_wifi);
      BOOL v33 = nw_path_uses_interface_type(v30, nw_interface_type_cellular);
      BOOL is_constrained = nw_path_is_constrained(v30);
      if (is_expensive || v32 || v33 || is_constrained)
      {
        if (is_expensive) {
          char v35 = 0x80;
        }
        else {
          char v35 = 0;
        }
        if (v32) {
          v35 |= 0x20u;
        }
        if (v33) {
          v35 |= 0x40u;
        }
        if (is_constrained) {
          char v36 = v35 | 0x10;
        }
        else {
          char v36 = v35;
        }
        char __src = v36;
      }
      else
      {
        char v36 = 0;
      }
      if ((*((unsigned char *)v5 + 160) & 0x40) != 0) {
        nw_socks5_connection_add_prefer_wifi_request(v5);
      }
      unsigned __int8 v103 = v36;
      if ((*((unsigned char *)v5 + 161) & 2) != 0)
      {
        os_log_type_t v73 = nw_connection_copy_connected_remote_endpoint(v5->sc_out_connection);
        uint32_t v74 = v73;
        if (v73) {
          address = nw_endpoint_get_address(v73);
        }
        else {
          address = 0;
        }

        int v72 = 4 * (v103 != 0);
        id v71 = address;
        if (address)
        {
          int v57 = 0;
          int v72 = (v72 | 3) + address->sa_len;
          uint64_t v102 = 1;
        }
        else
        {
          uint64_t v102 = 0;
          int v57 = 0;
        }
        goto LABEL_139;
      }

      if (v36)
      {
        uint64_t v102 = 0;
        id v71 = 0;
        int v57 = 0;
LABEL_138:
        int v72 = 4;
        goto LABEL_139;
      }
    }
    else
    {

      unsigned __int8 v103 = 0;
    }
    uint64_t v102 = 0;
    id v71 = 0;
    int v57 = 0;
    int v72 = 0;
  }
  else
  {
    __int16 v43 = v5->sc_error;
    id v44 = v43;
    if (v43)
    {
      char v45 = v43;
      unsigned int v46 = *((_DWORD *)v45 + 3);

      os_log_type_t v47 = v45;
      int v48 = *((_DWORD *)v47 + 2);

      int v49 = v46 + 71;
      if (v46 + 10055 <= 0xFF)
      {
        char v50 = 4;
      }
      else
      {
        int v49 = 3;
        char v50 = 1;
      }
      if ((v46 & 0xFFFFFF00) == 0xFFFEFF00) {
        int v51 = v46;
      }
      else {
        int v51 = 2;
      }
      if ((v46 & 0xFFFFFF00) == 0xFFFEFF00) {
        char v52 = 3;
      }
      else {
        char v52 = 1;
      }
      if (v46 >= 0x100) {
        int v53 = 1;
      }
      else {
        int v53 = v46;
      }
      if (v46 >= 0x100) {
        char v54 = 1;
      }
      else {
        char v54 = 2;
      }
      if (v48 == 1)
      {
        char v55 = v54;
      }
      else
      {
        int v53 = 0;
        char v55 = 1;
      }
      if (v48 == 2) {
        int v56 = v51;
      }
      else {
        int v56 = v53;
      }
      if (v48 == 2) {
        char v55 = v52;
      }
      if (v48 == 3) {
        int v57 = v49;
      }
      else {
        int v57 = v56;
      }
      if (v48 == 3) {
        char v55 = v50;
      }
    }
    else
    {
      int v57 = 0;
      char v55 = 1;
    }
    BYTE4(v102) = v55;

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v65 = (id)gLogObj;
    if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)BOOL v124 = 136446978;
      *(void *)&v124[4] = "nw_socks5_connection_send_reply_on_queue";
      *(_WORD *)&v124[12] = 2114;
      *(void *)&v124[14] = v5;
      *(_WORD *)&v124[22] = 1024;
      LODWORD(v125) = BYTE4(v102);
      WORD2(v125) = 1024;
      *(_DWORD *)((char *)&v125 + 6) = v57;
      _os_log_impl(&dword_1830D4000, v65, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ sending SHOES failure reply domain %u code %u", v124, 0x22u);
    }

    p_super = &v5->sc_out_connection->super;
    if (p_super)
    {
      uint64_t v67 = nw_connection_copy_current_path(p_super);
      uint64_t v68 = v67;
      if (v67 && nw_path_get_status(v67) == nw_path_status_unsatisfied)
      {
        switch(nw_path_get_reason(v68))
        {
          case 5u:
            char v69 = 0x80;
            char v70 = 0x80;
            break;
          case 6u:
            char v69 = 64;
            char v70 = 64;
            break;
          case 0x1Au:
            char v69 = 16;
            char v70 = 16;
            break;
          case 0x1Bu:
            char v69 = 72;
            char v70 = 72;
            break;
          case 0x1Cu:
            char v69 = 40;
            char v70 = 40;
            break;
          default:
            goto LABEL_117;
        }
        unsigned __int8 v103 = v70;
        char __src = v69;

        LODWORD(v102) = 0;
        id v71 = 0;
        goto LABEL_138;
      }
LABEL_117:
    }
    unsigned __int8 v103 = 0;
    LODWORD(v102) = 0;
    id v71 = 0;
    int v72 = 0;
  }
LABEL_139:
  os_log_type_t v101 = (sockaddr *)v71;
  if ((*((unsigned char *)v5 + 161) & 4) != 0 && (sc_out_establishment_reint port = v5->sc_out_establishment_report) != 0)
  {
    uint64_t buffer = 0;
    p_uint64_t buffer = &buffer;
    uint64_t v117 = 0x2020000000;
    __int16 v118 = 0;
    v114[0] = MEMORY[0x1E4F143A8];
    v114[1] = 3221225472;
    v114[2] = ___ZL40nw_socks5_connection_send_reply_on_queueP31NWConcrete_nw_socks5_connectionbU13block_pointerFvbE_block_invoke;
    v114[3] = &unk_1E523EE38;
    v114[4] = buf;
    int v77 = sc_out_establishment_report;
    uint64_t v78 = v114;
    int v79 = v57;
    int v80 = (atomic_uchar *)*((void *)v77 + 9);
    *(void *)BOOL v124 = MEMORY[0x1E4F143A8];
    *(void *)&v124[8] = 3221225472;
    *(void *)&v124[16] = __nw_establishment_report_enumerate_resolution_reports_block_invoke;
    *(void *)&long long v125 = &unk_1E524AE90;
    __int16 v81 = v78;
    *((void *)&v125 + 1) = v81;
    uint64_t v82 = v80;
    int v57 = v79;
    nw_array_apply(v82, (uint64_t)v124);

    int v83 = *(atomic_uchar **)(*(void *)&buf[8] + 40);
    v113[0] = MEMORY[0x1E4F143A8];
    v113[1] = 3221225472;
    v113[2] = ___ZL40nw_socks5_connection_send_reply_on_queueP31NWConcrete_nw_socks5_connectionbU13block_pointerFvbE_block_invoke_3;
    v113[3] = &unk_1E5248058;
    v113[4] = &buffer;
    nw_array_apply(v83, (uint64_t)v113);
    BOOL v84 = *((_WORD *)p_buffer + 12) != 0;
    v72 += *((unsigned __int16 *)p_buffer + 12);
    _Block_object_dispose(&buffer, 8);
  }
  else
  {
    BOOL v84 = 0;
  }
  unsigned __int16 v85 = v72 + 4;
  if ((_WORD)v72 == 0xFFFC)
  {
    BOOL v96 = __nwlog_obj();
    os_log_type_enabled(v96, OS_LOG_TYPE_ERROR);
    *(_DWORD *)BOOL v124 = 136446210;
    *(void *)&v124[4] = "strict_malloc";
    os_log_type_t v97 = (void *)_os_log_send_and_compose_impl();

    if (__nwlog_abort((uint64_t)v97)) {
      goto LABEL_167;
    }
    free(v97);
  }
  int v86 = malloc_type_malloc((unsigned __int16)(v72 + 4), 0xF2B69DE5uLL);
  if (v86)
  {
LABEL_145:
    uint64_t buffer = 0;
    p_uint64_t buffer = &buffer;
    uint64_t v117 = 0x2020000000;
    __int16 v118 = 0;
    _DWORD *v86 = (BYTE4(v102) << 16) | (v57 << 24) | (bswap32(v72 + 2) >> 16);
    unsigned __int16 v87 = *((_WORD *)p_buffer + 12) + 4;
    *((_WORD *)p_buffer + 12) = v87;
    if (v103 && v87 < v85)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v88 = (id)gLogObj;
      if (os_log_type_enabled(v88, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)BOOL v124 = 136446978;
        *(void *)&v124[4] = "nw_socks5_connection_send_reply_on_queue";
        *(_WORD *)&v124[12] = 2114;
        *(void *)&v124[14] = v5;
        *(_WORD *)&v124[22] = 2082;
        *(void *)&long long v125 = "path_flags";
        WORD4(v125) = 1024;
        *(_DWORD *)((char *)&v125 + 10) = v103;
        _os_log_impl(&dword_1830D4000, v88, OS_LOG_TYPE_INFO, "%{public}s %{public}@ sending reply tlv: %{public}s(%#x)", v124, 0x26u);
      }

      __int16 v89 = nw_shoes_add_tlv((uint64_t)v86 + *((unsigned __int16 *)p_buffer + 12), (unsigned __int16)(v85 - *((_WORD *)p_buffer + 12)), 4u, 1uLL, &__src);
      unsigned __int16 v87 = *((_WORD *)p_buffer + 12) + v89;
      *((_WORD *)p_buffer + 12) = v87;
    }
    BOOL v90 = v87 >= v85;
    int v91 = v102;
    if (v90) {
      int v91 = 0;
    }
    if (v91 == 1)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v92 = (id)gLogObj;
      if (os_log_type_enabled(v92, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)BOOL v124 = 136446722;
        *(void *)&v124[4] = "nw_socks5_connection_send_reply_on_queue";
        *(_WORD *)&v124[12] = 2114;
        *(void *)&v124[14] = v5;
        *(_WORD *)&v124[22] = 2082;
        *(void *)&long long v125 = "connected_endpoint";
        _os_log_impl(&dword_1830D4000, v92, OS_LOG_TYPE_INFO, "%{public}s %{public}@ sending reply tlv: %{public}s", v124, 0x20u);
      }

      __int16 v93 = nw_shoes_add_tlv((uint64_t)v86 + *((unsigned __int16 *)p_buffer + 12), (unsigned __int16)(v85 - *((_WORD *)p_buffer + 12)), 7u, v101->sa_len, v101);
      *((_WORD *)p_buffer + 12) += v93;
    }
    if (v84)
    {
      uint64_t v94 = *(atomic_uchar **)(*(void *)&buf[8] + 40);
      v108[0] = MEMORY[0x1E4F143A8];
      v108[1] = 3221225472;
      v108[2] = ___ZL40nw_socks5_connection_send_reply_on_queueP31NWConcrete_nw_socks5_connectionbU13block_pointerFvbE_block_invoke_169;
      v108[3] = &unk_1E523C908;
      __int16 v110 = &buffer;
      __int16 v112 = v72 + 4;
      uint64_t v109 = v5;
      uint64_t v111 = v86;
      nw_array_apply(v94, (uint64_t)v108);
    }
    dispatch_data_t v37 = dispatch_data_create(v86, (unsigned __int16)(v72 + 4), 0, (dispatch_block_t)*MEMORY[0x1E4F143F0]);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v95 = (id)gLogObj;
    if (os_log_type_enabled(v95, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)BOOL v124 = 136446722;
      *(void *)&v124[4] = "nw_socks5_connection_send_reply_on_queue";
      *(_WORD *)&v124[12] = 2114;
      *(void *)&v124[14] = v5;
      *(_WORD *)&v124[22] = 2112;
      *(void *)&long long v125 = v37;
      _os_log_impl(&dword_1830D4000, v95, OS_LOG_TYPE_INFO, "%{public}s %{public}@ sending SHOES %@", v124, 0x20u);
    }

    _Block_object_dispose(&buffer, 8);
    if (!v37) {
      goto LABEL_161;
    }
LABEL_104:
    *((unsigned char *)v5 + 160) |= 8u;
    BOOL v58 = &__block_literal_global_42249;
    id v59 = &__block_literal_global_42249;
    if ((a2 & 1) == 0)
    {
      id v60 = &__block_literal_global_6_42258;

      BOOL v58 = &__block_literal_global_6_42258;
    }
    id v61 = v5->sc_in_connection;
    if (*((char *)v5 + 160) < 0)
    {
      uint64_t v62 = v5->sc_in_udp_associated_tcp_connection;

      id v61 = v62;
    }
    id WeakRetained = objc_loadWeakRetained((id *)&v5->sc_parent);
    nw_socks5_connection_increment_busy_on_queue(v5, WeakRetained);
    completion[0] = MEMORY[0x1E4F143A8];
    completion[1] = 3221225472;
    completion[2] = ___ZL40nw_socks5_connection_send_reply_on_queueP31NWConcrete_nw_socks5_connectionbU13block_pointerFvbE_block_invoke_170;
    completion[3] = &unk_1E523C930;
    os_log_type_t v105 = v5;
    id v64 = WeakRetained;
    id v106 = v64;
    int v107 = v6;
    nw_connection_send(v61, v37, v58, 1, completion);

    goto LABEL_162;
  }
  __nwlog_obj();
  v100 = int v99 = v57;
  os_log_type_enabled(v100, OS_LOG_TYPE_ERROR);
  *(_DWORD *)BOOL v124 = 136446466;
  *(void *)&v124[4] = "strict_malloc";
  *(_WORD *)&v124[12] = 2048;
  *(void *)&v124[14] = (unsigned __int16)(v72 + 4);
  char v98 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v98))
  {
    free(v98);
    int v57 = v99;
    goto LABEL_145;
  }
LABEL_167:
  __break(1u);
}

void sub_18349295C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v5 - 208), 8);
  _Unwind_Resume(a1);
}

void nw_protocol_http3_stream_output_finished(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    unsigned int v46 = "nw_protocol_http3_stream_output_finished";
    id v18 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (!__nwlog_fault(v18, &type, &v43)) {
      goto LABEL_88;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_88;
      }
      *(_DWORD *)int buf = 136446210;
      unsigned int v46 = "nw_protocol_http3_stream_output_finished";
      os_log_type_t v21 = "%{public}s called with null protocol";
    }
    else if (v43)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      BOOL v31 = os_log_type_enabled(v19, type);
      if (backtrace_string)
      {
        if (v31)
        {
          *(_DWORD *)int buf = 136446466;
          unsigned int v46 = "nw_protocol_http3_stream_output_finished";
          __int16 v47 = 2082;
          int v48 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_88:
        if (!v18) {
          return;
        }
        goto LABEL_89;
      }
      if (!v31) {
        goto LABEL_88;
      }
      *(_DWORD *)int buf = 136446210;
      unsigned int v46 = "nw_protocol_http3_stream_output_finished";
      os_log_type_t v21 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      os_log_type_t v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_88;
      }
      *(_DWORD *)int buf = 136446210;
      unsigned int v46 = "nw_protocol_http3_stream_output_finished";
      os_log_type_t v21 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_87;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    unsigned int v46 = "nw_protocol_http3_stream_output_finished";
    id v18 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (!__nwlog_fault(v18, &type, &v43)) {
      goto LABEL_88;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v43)
      {
        os_log_type_t v19 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (!os_log_type_enabled(v19, type)) {
          goto LABEL_88;
        }
        *(_DWORD *)int buf = 136446210;
        unsigned int v46 = "nw_protocol_http3_stream_output_finished";
        os_log_type_t v21 = "%{public}s called with null http3_stream, backtrace limit exceeded";
        goto LABEL_87;
      }
      BOOL v32 = (char *)__nw_create_backtrace_string();
      os_log_type_t v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      BOOL v33 = os_log_type_enabled(v19, type);
      if (!v32)
      {
        if (!v33) {
          goto LABEL_88;
        }
        *(_DWORD *)int buf = 136446210;
        unsigned int v46 = "nw_protocol_http3_stream_output_finished";
        os_log_type_t v21 = "%{public}s called with null http3_stream, no backtrace";
        goto LABEL_87;
      }
      if (v33)
      {
        *(_DWORD *)int buf = 136446466;
        unsigned int v46 = "nw_protocol_http3_stream_output_finished";
        __int16 v47 = 2082;
        int v48 = v32;
        id v34 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
LABEL_59:
        _os_log_impl(&dword_1830D4000, v19, v20, v34, buf, 0x16u);
      }
LABEL_60:
      free(v32);
      if (!v18) {
        return;
      }
LABEL_89:
      os_log_type_t v42 = (char *)v18;
      goto LABEL_90;
    }
    os_log_type_t v19 = __nwlog_obj();
    os_log_type_t v20 = type;
    if (!os_log_type_enabled(v19, type)) {
      goto LABEL_88;
    }
    *(_DWORD *)int buf = 136446210;
    unsigned int v46 = "nw_protocol_http3_stream_output_finished";
    os_log_type_t v21 = "%{public}s called with null http3_stream";
LABEL_87:
    _os_log_impl(&dword_1830D4000, v19, v20, v21, buf, 0xCu);
    goto LABEL_88;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    unsigned int v46 = "nw_protocol_http3_stream_output_finished";
    id v18 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (!__nwlog_fault(v18, &type, &v43)) {
      goto LABEL_88;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_88;
      }
      *(_DWORD *)int buf = 136446210;
      unsigned int v46 = "nw_protocol_http3_stream_output_finished";
      os_log_type_t v21 = "%{public}s called with null other_protocol";
      goto LABEL_87;
    }
    if (!v43)
    {
      os_log_type_t v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_88;
      }
      *(_DWORD *)int buf = 136446210;
      unsigned int v46 = "nw_protocol_http3_stream_output_finished";
      os_log_type_t v21 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_87;
    }
    BOOL v32 = (char *)__nw_create_backtrace_string();
    os_log_type_t v19 = __nwlog_obj();
    os_log_type_t v20 = type;
    BOOL v35 = os_log_type_enabled(v19, type);
    if (!v32)
    {
      if (!v35) {
        goto LABEL_88;
      }
      *(_DWORD *)int buf = 136446210;
      unsigned int v46 = "nw_protocol_http3_stream_output_finished";
      os_log_type_t v21 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_87;
    }
    if (v35)
    {
      *(_DWORD *)int buf = 136446466;
      unsigned int v46 = "nw_protocol_http3_stream_output_finished";
      __int16 v47 = 2082;
      int v48 = v32;
      id v34 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_59;
    }
    goto LABEL_60;
  }
  if ((*((_WORD *)handle + 368) & 0x800) == 0)
  {
    if (gLogDatapath)
    {
      os_log_type_t v22 = __nwlog_obj();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
      {
        int v23 = *(_DWORD *)(*((void *)handle + 42) + 1280);
        uint64_t v24 = *((void *)handle + 30);
        *(_DWORD *)int buf = 136447234;
        unsigned int v46 = "nw_protocol_http3_stream_output_finished";
        __int16 v47 = 2082;
        int v48 = handle + 636;
        __int16 v49 = 2080;
        char v50 = " ";
        __int16 v51 = 1024;
        int v52 = v23;
        __int16 v53 = 2048;
        uint64_t v54 = v24;
        _os_log_impl(&dword_1830D4000, v22, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called", buf, 0x30u);
      }
    }
  }
  unsigned int v4 = *((_DWORD *)handle + 92);
  if (v4 > 5) {
    return;
  }
  if (((1 << v4) & 0x2B) == 0)
  {
    *((_WORD *)handle + 368) |= 0x200u;
    return;
  }
  output_handler = a1->output_handler;
  if (output_handler)
  {
    callbacks = output_handler->callbacks;
    if (callbacks)
    {
      output_finished = (void (*)(void))callbacks->output_finished;
      if (output_finished)
      {
        output_finished();
        return;
      }
    }
  }
  __nwlog_obj();
  int v8 = a1->output_handler;
  int v9 = "invalid";
  if (v8)
  {
    identifier = v8->identifier;
    if (identifier) {
      int v9 = (const char *)identifier;
    }
  }
  *(_DWORD *)int buf = 136446466;
  unsigned int v46 = "nw_protocol_http3_stream_output_finished";
  __int16 v47 = 2082;
  int v48 = (char *)v9;
  BOOL v11 = (const char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v43 = 0;
  if (__nwlog_fault(v11, &type, &v43))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_73;
      }
      uint64_t v14 = a1->output_handler;
      os_log_type_t v15 = "invalid";
      if (v14)
      {
        __int16 v16 = v14->identifier;
        if (v16) {
          os_log_type_t v15 = (const char *)v16;
        }
      }
      *(_DWORD *)int buf = 136446466;
      unsigned int v46 = "nw_protocol_http3_stream_output_finished";
      __int16 v47 = 2082;
      int v48 = (char *)v15;
      os_log_type_t v17 = "%{public}s protocol %{public}s has invalid output_finished callback";
LABEL_72:
      _os_log_impl(&dword_1830D4000, v12, v13, v17, buf, 0x16u);
      goto LABEL_73;
    }
    if (!v43)
    {
      char v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_73;
      }
      char v36 = a1->output_handler;
      dispatch_data_t v37 = "invalid";
      if (v36)
      {
        BOOL v38 = v36->identifier;
        if (v38) {
          dispatch_data_t v37 = (const char *)v38;
        }
      }
      *(_DWORD *)int buf = 136446466;
      unsigned int v46 = "nw_protocol_http3_stream_output_finished";
      __int16 v47 = 2082;
      int v48 = (char *)v37;
      os_log_type_t v17 = "%{public}s protocol %{public}s has invalid output_finished callback, backtrace limit exceeded";
      goto LABEL_72;
    }
    os_log_type_t v25 = (char *)__nw_create_backtrace_string();
    char v12 = __nwlog_obj();
    os_log_type_t v13 = type;
    BOOL v26 = os_log_type_enabled(v12, type);
    if (!v25)
    {
      if (!v26) {
        goto LABEL_73;
      }
      __int16 v39 = a1->output_handler;
      uint64_t v40 = "invalid";
      if (v39)
      {
        int v41 = v39->identifier;
        if (v41) {
          uint64_t v40 = (const char *)v41;
        }
      }
      *(_DWORD *)int buf = 136446466;
      unsigned int v46 = "nw_protocol_http3_stream_output_finished";
      __int16 v47 = 2082;
      int v48 = (char *)v40;
      os_log_type_t v17 = "%{public}s protocol %{public}s has invalid output_finished callback, no backtrace";
      goto LABEL_72;
    }
    if (v26)
    {
      os_log_type_t v27 = a1->output_handler;
      __int16 v28 = "invalid";
      if (v27)
      {
        os_log_type_t v29 = v27->identifier;
        if (v29) {
          __int16 v28 = (const char *)v29;
        }
      }
      *(_DWORD *)int buf = 136446722;
      unsigned int v46 = "nw_protocol_http3_stream_output_finished";
      __int16 v47 = 2082;
      int v48 = (char *)v28;
      __int16 v49 = 2082;
      char v50 = v25;
      _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s protocol %{public}s has invalid output_finished callback, dumping backtrace:%{public}s", buf, 0x20u);
    }
    free(v25);
  }
LABEL_73:
  if (v11)
  {
    os_log_type_t v42 = (char *)v11;
LABEL_90:
    free(v42);
  }
}

uint64_t nw_protocol_demux_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v15 = "nw_protocol_demux_finalize_output_frames";
    unsigned int v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (!__nwlog_fault(v4, &type, &v12)) {
      goto LABEL_34;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v15 = "nw_protocol_demux_finalize_output_frames";
      os_log_type_t v7 = "%{public}s called with null protocol";
      goto LABEL_33;
    }
    if (!v12)
    {
      uint64_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v15 = "nw_protocol_demux_finalize_output_frames";
      os_log_type_t v7 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_33;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v5 = __nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v9 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (!v9) {
        goto LABEL_34;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v15 = "nw_protocol_demux_finalize_output_frames";
      os_log_type_t v7 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_33;
    }
    if (v9)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v15 = "nw_protocol_demux_finalize_output_frames";
      __int16 v16 = 2082;
      os_log_type_t v17 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_34:
    if (!v4) {
      return 0;
    }
LABEL_35:
    free(v4);
    return 0;
  }
  if (!a1->handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v15 = "nw_protocol_demux_finalize_output_frames";
    unsigned int v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (!__nwlog_fault(v4, &type, &v12)) {
      goto LABEL_34;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v15 = "nw_protocol_demux_finalize_output_frames";
      os_log_type_t v7 = "%{public}s called with null demux";
      goto LABEL_33;
    }
    if (!v12)
    {
      uint64_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v15 = "nw_protocol_demux_finalize_output_frames";
      os_log_type_t v7 = "%{public}s called with null demux, backtrace limit exceeded";
      goto LABEL_33;
    }
    id v10 = (char *)__nw_create_backtrace_string();
    uint64_t v5 = __nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v11 = os_log_type_enabled(v5, type);
    if (v10)
    {
      if (v11)
      {
        *(_DWORD *)int buf = 136446466;
        os_log_type_t v15 = "nw_protocol_demux_finalize_output_frames";
        __int16 v16 = 2082;
        os_log_type_t v17 = v10;
        _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s called with null demux, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v10);
      if (!v4) {
        return 0;
      }
      goto LABEL_35;
    }
    if (v11)
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v15 = "nw_protocol_demux_finalize_output_frames";
      os_log_type_t v7 = "%{public}s called with null demux, no backtrace";
LABEL_33:
      _os_log_impl(&dword_1830D4000, v5, v6, v7, buf, 0xCu);
      goto LABEL_34;
    }
    goto LABEL_34;
  }
  output_handler = a1->output_handler;

  return nw_protocol_finalize_output_frames((uint64_t)output_handler, (uint64_t)a2);
}

void nw_http_encoding_inbound_frame_finalizer(nw_frame *a1, int a2, unsigned char *a3)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v21 = "nw_http_encoding_inbound_frame_finalizer";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (!__nwlog_fault(v9, &type, &v18)) {
      goto LABEL_47;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_47;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v21 = "nw_http_encoding_inbound_frame_finalizer";
      char v12 = "%{public}s called with null frame";
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v15 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v21 = "nw_http_encoding_inbound_frame_finalizer";
          __int16 v22 = 2082;
          int v23 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_47:
        if (!v9) {
          return;
        }
LABEL_48:
        free(v9);
        return;
      }
      if (!v15) {
        goto LABEL_47;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v21 = "nw_http_encoding_inbound_frame_finalizer";
      char v12 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      id v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_47;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v21 = "nw_http_encoding_inbound_frame_finalizer";
      char v12 = "%{public}s called with null frame, backtrace limit exceeded";
    }
LABEL_46:
    _os_log_impl(&dword_1830D4000, v10, v11, v12, buf, 0xCu);
    goto LABEL_47;
  }
  if (a3)
  {
    if ((a3[198] & 1) == 0)
    {
      if (gLogDatapath)
      {
        os_log_type_t v13 = __nwlog_obj();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)int buf = 136447490;
          os_log_type_t v21 = "nw_http_encoding_inbound_frame_finalizer";
          __int16 v22 = 2082;
          int v23 = a3 + 114;
          __int16 v24 = 2080;
          os_log_type_t v25 = " ";
          __int16 v26 = 2048;
          os_log_type_t v27 = a1;
          __int16 v28 = 1024;
          int v29 = a2;
          __int16 v30 = 2048;
          BOOL v31 = a3;
          _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sfinalizing inbound frame %p (success %u, context %p)", buf, 0x3Au);
        }
      }
    }
    uint64_t v6 = *((void *)a1 + 2);
    os_log_type_t v7 = (void *)*((void *)a1 + 3);
    if (v6)
    {
      *(void *)(v6 + 24) = v7;
      os_log_type_t v7 = (void *)*((void *)a1 + 3);
    }
    else
    {
      *((void *)a3 + 71) = v7;
    }
    void *v7 = v6;
    *((void *)a1 + 2) = 0;
    *((void *)a1 + 3) = 0;
    *((void *)a1 + 10) = 0;
    *((void *)a1 + 11) = 0;
    if (a2)
    {
      nw_frame_cache_return_frame((uint64_t)(a3 + 432), (uint64_t)a1);
    }
    else
    {
      if ((*((_WORD *)a1 + 102) & 0x100) == 0
        || !g_channel_check_validity
        || g_channel_check_validity(a1, 0))
      {
        int v8 = (void *)*((void *)a1 + 14);
        if (v8) {
          free(v8);
        }
      }
      nw_frame_reset((uint64_t)a1, 0, 0, 0, 0);
      os_release(a1);
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v21 = "nw_http_encoding_inbound_frame_finalizer";
  BOOL v9 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (!__nwlog_fault(v9, &type, &v18)) {
    goto LABEL_47;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    id v10 = __nwlog_obj();
    os_log_type_t v11 = type;
    if (!os_log_type_enabled(v10, type)) {
      goto LABEL_47;
    }
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v21 = "nw_http_encoding_inbound_frame_finalizer";
    char v12 = "%{public}s called with null context";
    goto LABEL_46;
  }
  if (!v18)
  {
    id v10 = __nwlog_obj();
    os_log_type_t v11 = type;
    if (!os_log_type_enabled(v10, type)) {
      goto LABEL_47;
    }
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v21 = "nw_http_encoding_inbound_frame_finalizer";
    char v12 = "%{public}s called with null context, backtrace limit exceeded";
    goto LABEL_46;
  }
  __int16 v16 = (char *)__nw_create_backtrace_string();
  id v10 = __nwlog_obj();
  os_log_type_t v11 = type;
  BOOL v17 = os_log_type_enabled(v10, type);
  if (!v16)
  {
    if (!v17) {
      goto LABEL_47;
    }
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v21 = "nw_http_encoding_inbound_frame_finalizer";
    char v12 = "%{public}s called with null context, no backtrace";
    goto LABEL_46;
  }
  if (v17)
  {
    *(_DWORD *)int buf = 136446466;
    os_log_type_t v21 = "nw_http_encoding_inbound_frame_finalizer";
    __int16 v22 = 2082;
    int v23 = v16;
    _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v16);
  if (v9) {
    goto LABEL_48;
  }
}

void nw_protocol_http2_frame_input_finalizer(nw_frame *a1, int a2, void *a3)
{
  uint64_t v108 = *MEMORY[0x1E4F143B8];
  if (gLogDatapath)
  {
    BOOL v76 = __nwlog_obj();
    if (os_log_type_enabled(v76, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)int buf = 136446210;
      char v98 = "nw_protocol_http2_frame_input_finalizer";
      _os_log_impl(&dword_1830D4000, v76, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    char v98 = "nw_protocol_http2_frame_input_finalizer";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v95 = 0;
    if (__nwlog_fault(v6, &type, &v95))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v7 = __nwlog_obj();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)int buf = 136446210;
          char v98 = "nw_protocol_http2_frame_input_finalizer";
          BOOL v9 = "%{public}s called with null frame";
          goto LABEL_38;
        }
      }
      else if (v95)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v7 = __nwlog_obj();
        os_log_type_t v8 = type;
        BOOL v78 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v78)
          {
            *(_DWORD *)int buf = 136446466;
            char v98 = "nw_protocol_http2_frame_input_finalizer";
            __int16 v99 = 2082;
            long long v100 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
        }
        else if (v78)
        {
          *(_DWORD *)int buf = 136446210;
          char v98 = "nw_protocol_http2_frame_input_finalizer";
          BOOL v9 = "%{public}s called with null frame, no backtrace";
          goto LABEL_38;
        }
      }
      else
      {
        os_log_type_t v7 = __nwlog_obj();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)int buf = 136446210;
          char v98 = "nw_protocol_http2_frame_input_finalizer";
          BOOL v9 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_38;
        }
      }
    }
    goto LABEL_40;
  }
  if (a3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)int buf = 136446210;
    char v98 = "nw_protocol_http2_frame_input_finalizer";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v95 = 0;
    if (!__nwlog_fault(v6, &type, &v95)) {
      goto LABEL_40;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v7 = gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_40;
      }
      *(_DWORD *)int buf = 136446210;
      char v98 = "nw_protocol_http2_frame_input_finalizer";
      BOOL v9 = "%{public}s http2 input frame has nonnull context";
    }
    else
    {
      if (v95)
      {
        BOOL v15 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v16 = gLogObj;
        os_log_type_t v17 = type;
        BOOL v18 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v15)
        {
          if (v18)
          {
            *(_DWORD *)int buf = 136446466;
            char v98 = "nw_protocol_http2_frame_input_finalizer";
            __int16 v99 = 2082;
            long long v100 = v15;
            _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s http2 input frame has nonnull context, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v15);
          if (v6) {
            goto LABEL_41;
          }
          return;
        }
        if (!v18) {
          goto LABEL_40;
        }
        *(_DWORD *)int buf = 136446210;
        char v98 = "nw_protocol_http2_frame_input_finalizer";
        BOOL v9 = "%{public}s http2 input frame has nonnull context, no backtrace";
        BOOL v31 = v16;
        os_log_type_t v32 = v17;
        goto LABEL_39;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v7 = gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_40;
      }
      *(_DWORD *)int buf = 136446210;
      char v98 = "nw_protocol_http2_frame_input_finalizer";
      BOOL v9 = "%{public}s http2 input frame has nonnull context, backtrace limit exceeded";
    }
LABEL_38:
    BOOL v31 = v7;
    os_log_type_t v32 = v8;
LABEL_39:
    _os_log_impl(&dword_1830D4000, v31, v32, v9, buf, 0xCu);
    goto LABEL_40;
  }
  __int16 v10 = *((_WORD *)a1 + 102);
  if ((v10 & 4) != 0) {
    os_log_type_t v11 = (char *)a1 + 208;
  }
  else {
    os_log_type_t v11 = 0;
  }
  if ((v10 & 4) == 0)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    char v98 = "nw_protocol_http2_frame_input_finalizer";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v95 = 0;
    if (!__nwlog_fault(v6, &type, &v95)) {
      goto LABEL_40;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v98 = "nw_protocol_http2_frame_input_finalizer";
        BOOL v9 = "%{public}s called with null input_frame_context";
        goto LABEL_38;
      }
      goto LABEL_40;
    }
    if (!v95)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v98 = "nw_protocol_http2_frame_input_finalizer";
        BOOL v9 = "%{public}s called with null input_frame_context, backtrace limit exceeded";
        goto LABEL_38;
      }
      goto LABEL_40;
    }
    __int16 v81 = (char *)__nw_create_backtrace_string();
    os_log_type_t v7 = __nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v82 = os_log_type_enabled(v7, type);
    if (!v81)
    {
      if (v82)
      {
        *(_DWORD *)int buf = 136446210;
        char v98 = "nw_protocol_http2_frame_input_finalizer";
        BOOL v9 = "%{public}s called with null input_frame_context, no backtrace";
        goto LABEL_38;
      }
      goto LABEL_40;
    }
    if (!v82) {
      goto LABEL_167;
    }
    *(_DWORD *)int buf = 136446466;
    char v98 = "nw_protocol_http2_frame_input_finalizer";
    __int16 v99 = 2082;
    long long v100 = v81;
    int v83 = "%{public}s called with null input_frame_context, dumping backtrace:%{public}s";
LABEL_166:
    _os_log_impl(&dword_1830D4000, v7, v8, v83, buf, 0x16u);
    goto LABEL_167;
  }
  uint64_t v12 = *(void *)v11;
  if (!*(void *)v11)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    char v98 = "nw_protocol_http2_frame_input_finalizer";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v95 = 0;
    if (!__nwlog_fault(v6, &type, &v95)) {
      goto LABEL_40;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v98 = "nw_protocol_http2_frame_input_finalizer";
        BOOL v9 = "%{public}s called with null http2";
        goto LABEL_38;
      }
      goto LABEL_40;
    }
    if (!v95)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v98 = "nw_protocol_http2_frame_input_finalizer";
        BOOL v9 = "%{public}s called with null http2, backtrace limit exceeded";
        goto LABEL_38;
      }
      goto LABEL_40;
    }
    __int16 v81 = (char *)__nw_create_backtrace_string();
    os_log_type_t v7 = __nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v84 = os_log_type_enabled(v7, type);
    if (!v81)
    {
      if (v84)
      {
        *(_DWORD *)int buf = 136446210;
        char v98 = "nw_protocol_http2_frame_input_finalizer";
        BOOL v9 = "%{public}s called with null http2, no backtrace";
        goto LABEL_38;
      }
      goto LABEL_40;
    }
    if (!v84) {
      goto LABEL_167;
    }
    *(_DWORD *)int buf = 136446466;
    char v98 = "nw_protocol_http2_frame_input_finalizer";
    __int16 v99 = 2082;
    long long v100 = v81;
    int v83 = "%{public}s called with null http2, dumping backtrace:%{public}s";
    goto LABEL_166;
  }
  uint64_t v13 = *((void *)a1 + 2);
  uint64_t v14 = (void *)*((void *)a1 + 3);
  if (v13)
  {
    *(void *)(v13 + 24) = v14;
    uint64_t v14 = (void *)*((void *)a1 + 3);
  }
  else
  {
    *(void *)(v12 + 176) = v14;
  }
  *uint64_t v14 = v13;
  *((void *)a1 + 2) = 0;
  *((void *)a1 + 3) = 0;
  if ((*(__int16 *)(v12 + 388) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v79 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v80 = *(_DWORD *)(v12 + 368);
      *(_DWORD *)int buf = 136447234;
      char v98 = "nw_protocol_http2_frame_input_finalizer";
      __int16 v99 = 2082;
      long long v100 = (const char *)(v12 + 390);
      __int16 v101 = 2080;
      uint64_t v102 = " ";
      __int16 v103 = 1024;
      *(_DWORD *)__int16 v104 = v80;
      *(_WORD *)&v104[4] = 2048;
      *(void *)&v104[6] = a1;
      _os_log_impl(&dword_1830D4000, v79, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> finalizing input frame %p", buf, 0x30u);
    }
  }
  uint64_t v19 = *((void *)v11 + 1);
  if (v19)
  {
    int v20 = *(unsigned __int16 *)(v19 + 188);
    int v21 = v20 | (*(unsigned __int8 *)(v19 + 190) << 16);
    if ((v20 & 1) == 0 || *(_DWORD *)(v19 + 176) == -1)
    {
      if ((v21 & 0x80000) != 0 || !gLogDatapath) {
        goto LABEL_113;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v25 = gconnectionLogObj;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_113;
      }
      int v27 = *(_DWORD *)(v19 + 176);
      int v26 = *(_DWORD *)(v19 + 180);
      *(_DWORD *)int buf = 136447490;
      char v98 = "nw_protocol_http2_frame_input_finalizer";
      __int16 v99 = 2082;
      long long v100 = (const char *)(v19 + 191);
      __int16 v101 = 2080;
      uint64_t v102 = " ";
      __int16 v103 = 1024;
      *(_DWORD *)__int16 v104 = v26;
      *(_WORD *)&v104[4] = 1024;
      *(_DWORD *)&v104[6] = v27;
      *(_WORD *)&v104[10] = 1024;
      *(_DWORD *)&v104[12] = v27;
      __int16 v28 = "%{public}s %{public}s%s<i%u:s%d> skipping stream flow control update on closed stream %d";
      int v29 = v25;
      uint32_t v30 = 50;
      goto LABEL_179;
    }
    __int16 v22 = (char *)*((unsigned int *)v11 + 4);
    int v23 = *((_DWORD *)a1 + 13);
    if (v23)
    {
      int v24 = v23 - (*((_DWORD *)a1 + 14) + *((_DWORD *)a1 + 15));
      if (v22 == v24) {
        goto LABEL_50;
      }
    }
    else
    {
      int v24 = 0;
      if (!v22) {
        goto LABEL_50;
      }
    }
    if ((v21 & 0x80000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v33 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        int v35 = *(_DWORD *)(v19 + 176);
        int v34 = *(_DWORD *)(v19 + 180);
        *(_DWORD *)int buf = 136448002;
        char v98 = "nw_protocol_http2_frame_input_finalizer";
        __int16 v99 = 2082;
        long long v100 = (const char *)(v19 + 191);
        __int16 v101 = 2080;
        uint64_t v102 = " ";
        __int16 v103 = 1024;
        *(_DWORD *)__int16 v104 = v34;
        *(_WORD *)&v104[4] = 1024;
        *(_DWORD *)&v104[6] = v35;
        *(_WORD *)&v104[10] = 2048;
        *(void *)&v104[12] = a1;
        *(_WORD *)&v104[20] = 1024;
        int v105 = (int)v22;
        __int16 v106 = 1024;
        int v107 = v24;
        _os_log_impl(&dword_1830D4000, v33, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%d> http2 input frame %p original length (%u) does not match unclaimed length (%u) when finalized", buf, 0x42u);
      }
    }
LABEL_50:
    unint64_t v36 = *(int *)(v19 + 184) - (unint64_t)v22;
    *(_DWORD *)(v19 + 184) = v36;
    if (v36 == (uint64_t)(v36 << 31) >> 31 && (v36 & 0x1FFFFFFFFLL) == ((int)v36 & 0x1FFFFFFFFLL))
    {
      if ((int)v36 > 1597151)
      {
LABEL_111:
        if (((*(unsigned __int16 *)(v19 + 188) | (*(unsigned __int8 *)(v19 + 190) << 16)) & 0x80000) != 0
          || !gLogDatapath)
        {
          goto LABEL_113;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v89 = gconnectionLogObj;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_113;
        }
        int v91 = *(_DWORD *)(v19 + 176);
        int v90 = *(_DWORD *)(v19 + 180);
        *(_DWORD *)int buf = 136447746;
        char v98 = "nw_protocol_http2_frame_input_finalizer";
        __int16 v99 = 2082;
        long long v100 = (const char *)(v19 + 191);
        __int16 v101 = 2080;
        uint64_t v102 = " ";
        __int16 v103 = 1024;
        *(_DWORD *)__int16 v104 = v90;
        *(_WORD *)&v104[4] = 1024;
        *(_DWORD *)&v104[6] = v91;
        *(_WORD *)&v104[10] = 1024;
        *(_DWORD *)&v104[12] = v22;
        *(_WORD *)&v104[16] = 1024;
        *(_DWORD *)&v104[18] = v91;
        __int16 v28 = "%{public}s %{public}s%s<i%u:s%d> consumed %u bytes on stream %d";
        int v29 = v89;
        uint32_t v30 = 56;
LABEL_179:
        _os_log_impl(&dword_1830D4000, v29, OS_LOG_TYPE_DEBUG, v28, buf, v30);
LABEL_113:
        if (a2)
        {
          http2_input_frame_metadata_reset((uint64_t)a1, 0, 0, 0);
          nw_frame_cache_return_frame(v12 + 200, (uint64_t)a1);
        }
        else
        {
          if (((*(unsigned __int16 *)(v19 + 188) | (*(unsigned __int8 *)(v19 + 190) << 16)) & 0x80000) == 0
            && gLogDatapath)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            int v86 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              int v88 = *(_DWORD *)(v19 + 176);
              int v87 = *(_DWORD *)(v19 + 180);
              *(_DWORD *)int buf = 136447234;
              char v98 = "nw_protocol_http2_frame_input_finalizer";
              __int16 v99 = 2082;
              long long v100 = (const char *)(v19 + 191);
              __int16 v101 = 2080;
              uint64_t v102 = " ";
              __int16 v103 = 1024;
              *(_DWORD *)__int16 v104 = v87;
              *(_WORD *)&v104[4] = 1024;
              *(_DWORD *)&v104[6] = v88;
              _os_log_impl(&dword_1830D4000, v86, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> disposing of input frame, finalizer called with success == false", buf, 0x2Cu);
            }
          }
          if ((*((_WORD *)a1 + 102) & 0x100) == 0
            || !g_channel_check_validity
            || g_channel_check_validity(a1, *((void *)a1 + 11)))
          {
            uint64_t v75 = (void *)*((void *)a1 + 14);
            if (v75) {
              free(v75);
            }
          }
          nw_frame_reset((uint64_t)a1, 0, 0, 0, 0);
          os_release(a1);
        }
        nw_http2_session_send(v12);
        return;
      }
      unsigned int v44 = 0x200000 - v36;
LABEL_73:
      if (!nghttp2_submit_window_update()) {
        goto LABEL_90;
      }
      int v93 = (int)v22;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v50 = nghttp2_strerror();
      *(_DWORD *)int buf = 136446466;
      char v98 = "nw_protocol_http2_frame_input_finalizer";
      __int16 v99 = 2082;
      long long v100 = (const char *)v50;
      __int16 v51 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v95 = 0;
      if (__nwlog_fault(v51, &type, &v95))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v52 = gLogObj;
          os_log_type_t v53 = type;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            uint64_t v54 = nghttp2_strerror();
            *(_DWORD *)int buf = 136446466;
            char v98 = "nw_protocol_http2_frame_input_finalizer";
            __int16 v99 = 2082;
            long long v100 = (const char *)v54;
            uint64_t v55 = "%{public}s nghttp2_submit_window_update: %{public}s failed";
LABEL_85:
            id v61 = v52;
LABEL_86:
            _os_log_impl(&dword_1830D4000, v61, v53, v55, buf, 0x16u);
          }
        }
        else if (v95)
        {
          int v56 = (char *)__nw_create_backtrace_string();
          int v57 = __nwlog_obj();
          os_log_type_t v53 = type;
          log = v57;
          BOOL v58 = os_log_type_enabled(v57, type);
          if (v56)
          {
            if (v58)
            {
              uint64_t v59 = nghttp2_strerror();
              *(_DWORD *)int buf = 136446722;
              char v98 = "nw_protocol_http2_frame_input_finalizer";
              __int16 v99 = 2082;
              long long v100 = (const char *)v59;
              __int16 v101 = 2082;
              uint64_t v102 = v56;
              _os_log_impl(&dword_1830D4000, log, v53, "%{public}s nghttp2_submit_window_update: %{public}s failed, dumping backtrace:%{public}s", buf, 0x20u);
            }
            free(v56);
            goto LABEL_87;
          }
          if (v58)
          {
            uint64_t v73 = nghttp2_strerror();
            *(_DWORD *)int buf = 136446466;
            char v98 = "nw_protocol_http2_frame_input_finalizer";
            __int16 v99 = 2082;
            long long v100 = (const char *)v73;
            uint64_t v55 = "%{public}s nghttp2_submit_window_update: %{public}s failed, no backtrace";
            id v61 = log;
            goto LABEL_86;
          }
        }
        else
        {
          int v52 = __nwlog_obj();
          os_log_type_t v53 = type;
          if (os_log_type_enabled(v52, type))
          {
            uint64_t v60 = nghttp2_strerror();
            *(_DWORD *)int buf = 136446466;
            char v98 = "nw_protocol_http2_frame_input_finalizer";
            __int16 v99 = 2082;
            long long v100 = (const char *)v60;
            uint64_t v55 = "%{public}s nghttp2_submit_window_update: %{public}s failed, backtrace limit exceeded";
            goto LABEL_85;
          }
        }
      }
LABEL_87:
      if (v51) {
        free(v51);
      }
      LODWORD(v22) = v93;
LABEL_90:
      int v62 = *(_DWORD *)(v19 + 184);
      *(_DWORD *)(v19 + 184) = v62 + v44;
      if (!__OFADD__(v62, v44)) {
        goto LABEL_111;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v63 = (char *)v44;
      uint64_t v64 = *(int *)(v19 + 184);
      *(_DWORD *)int buf = 136446978;
      char v98 = "nw_protocol_http2_frame_input_finalizer";
      __int16 v99 = 2082;
      long long v100 = "stream->window_remaining";
      __int16 v101 = 2048;
      uint64_t v102 = (char *)v44;
      __int16 v103 = 2048;
      *(void *)__int16 v104 = v64;
      int v65 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v95 = 0;
      if (__nwlog_fault(v65, &type, &v95))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v66 = gLogObj;
          os_log_type_t v67 = type;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            uint64_t v68 = *(int *)(v19 + 184);
            *(_DWORD *)int buf = 136446978;
            char v98 = "nw_protocol_http2_frame_input_finalizer";
            __int16 v99 = 2082;
            long long v100 = "stream->window_remaining";
            __int16 v101 = 2048;
            uint64_t v102 = v63;
            __int16 v103 = 2048;
            *(void *)__int16 v104 = v68;
            char v69 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_107:
            _os_log_impl(&dword_1830D4000, v66, v67, v69, buf, 0x2Au);
          }
        }
        else if (v95)
        {
          int v94 = (int)v22;
          __int16 v22 = (char *)__nw_create_backtrace_string();
          uint64_t v66 = __nwlog_obj();
          os_log_type_t v67 = type;
          BOOL v70 = os_log_type_enabled(v66, type);
          if (v22)
          {
            if (v70)
            {
              uint64_t v71 = *(int *)(v19 + 184);
              *(_DWORD *)int buf = 136447234;
              char v98 = "nw_protocol_http2_frame_input_finalizer";
              __int16 v99 = 2082;
              long long v100 = "stream->window_remaining";
              __int16 v101 = 2048;
              uint64_t v102 = v63;
              __int16 v103 = 2048;
              *(void *)__int16 v104 = v71;
              *(_WORD *)&v104[8] = 2082;
              *(void *)&v104[10] = v22;
              _os_log_impl(&dword_1830D4000, v66, v67, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
            }
            free(v22);
            LODWORD(v22) = v94;
            goto LABEL_108;
          }
          LODWORD(v22) = v94;
          if (v70)
          {
            uint64_t v74 = *(int *)(v19 + 184);
            *(_DWORD *)int buf = 136446978;
            char v98 = "nw_protocol_http2_frame_input_finalizer";
            __int16 v99 = 2082;
            long long v100 = "stream->window_remaining";
            __int16 v101 = 2048;
            uint64_t v102 = v63;
            __int16 v103 = 2048;
            *(void *)__int16 v104 = v74;
            char v69 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
            goto LABEL_107;
          }
        }
        else
        {
          uint64_t v66 = __nwlog_obj();
          os_log_type_t v67 = type;
          if (os_log_type_enabled(v66, type))
          {
            uint64_t v72 = *(int *)(v19 + 184);
            *(_DWORD *)int buf = 136446978;
            char v98 = "nw_protocol_http2_frame_input_finalizer";
            __int16 v99 = 2082;
            long long v100 = "stream->window_remaining";
            __int16 v101 = 2048;
            uint64_t v102 = v63;
            __int16 v103 = 2048;
            *(void *)__int16 v104 = v72;
            char v69 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
            goto LABEL_107;
          }
        }
      }
LABEL_108:
      if (v65) {
        free(v65);
      }
      *(_DWORD *)(v19 + 184) = 0x200000;
      goto LABEL_111;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v38 = *(int *)(v19 + 184);
    *(_DWORD *)int buf = 136446978;
    char v98 = "nw_protocol_http2_frame_input_finalizer";
    __int16 v99 = 2082;
    long long v100 = "stream->window_remaining";
    __int16 v101 = 2048;
    uint64_t v102 = v22;
    __int16 v103 = 2048;
    *(void *)__int16 v104 = v38;
    __int16 v39 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v95 = 0;
    if (__nwlog_fault(v39, &type, &v95))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v40 = gLogObj;
        os_log_type_t v41 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          uint64_t v42 = *(int *)(v19 + 184);
          *(_DWORD *)int buf = 136446978;
          char v98 = "nw_protocol_http2_frame_input_finalizer";
          __int16 v99 = 2082;
          long long v100 = "stream->window_remaining";
          __int16 v101 = 2048;
          uint64_t v102 = v22;
          __int16 v103 = 2048;
          *(void *)__int16 v104 = v42;
          char v43 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_69:
          _os_log_impl(&dword_1830D4000, v40, v41, v43, buf, 0x2Au);
        }
      }
      else if (v95)
      {
        char v45 = v22;
        __int16 v22 = (char *)__nw_create_backtrace_string();
        uint64_t v40 = __nwlog_obj();
        os_log_type_t v41 = type;
        BOOL v46 = os_log_type_enabled(v40, type);
        if (v22)
        {
          if (v46)
          {
            uint64_t v47 = *(int *)(v19 + 184);
            *(_DWORD *)int buf = 136447234;
            char v98 = "nw_protocol_http2_frame_input_finalizer";
            __int16 v99 = 2082;
            long long v100 = "stream->window_remaining";
            __int16 v101 = 2048;
            uint64_t v102 = (char *)v45;
            __int16 v103 = 2048;
            *(void *)__int16 v104 = v47;
            *(_WORD *)&v104[8] = 2082;
            *(void *)&v104[10] = v22;
            _os_log_impl(&dword_1830D4000, v40, v41, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v22);
          LODWORD(v22) = v45;
          goto LABEL_70;
        }
        LODWORD(v22) = v45;
        if (v46)
        {
          uint64_t v49 = *(int *)(v19 + 184);
          *(_DWORD *)int buf = 136446978;
          char v98 = "nw_protocol_http2_frame_input_finalizer";
          __int16 v99 = 2082;
          long long v100 = "stream->window_remaining";
          __int16 v101 = 2048;
          uint64_t v102 = (char *)v45;
          __int16 v103 = 2048;
          *(void *)__int16 v104 = v49;
          char v43 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          goto LABEL_69;
        }
      }
      else
      {
        uint64_t v40 = __nwlog_obj();
        os_log_type_t v41 = type;
        if (os_log_type_enabled(v40, type))
        {
          uint64_t v48 = *(int *)(v19 + 184);
          *(_DWORD *)int buf = 136446978;
          char v98 = "nw_protocol_http2_frame_input_finalizer";
          __int16 v99 = 2082;
          long long v100 = "stream->window_remaining";
          __int16 v101 = 2048;
          uint64_t v102 = v22;
          __int16 v103 = 2048;
          *(void *)__int16 v104 = v48;
          char v43 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_69;
        }
      }
    }
LABEL_70:
    if (v39) {
      free(v39);
    }
    *(_DWORD *)(v19 + 184) = 0;
    unsigned int v44 = 0x200000;
    goto LABEL_73;
  }
  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  char v98 = "nw_protocol_http2_frame_input_finalizer";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v95 = 0;
  if (__nwlog_fault(v6, &type, &v95))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v98 = "nw_protocol_http2_frame_input_finalizer";
        BOOL v9 = "%{public}s called with null stream";
        goto LABEL_38;
      }
      goto LABEL_40;
    }
    if (!v95)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v98 = "nw_protocol_http2_frame_input_finalizer";
        BOOL v9 = "%{public}s called with null stream, backtrace limit exceeded";
        goto LABEL_38;
      }
      goto LABEL_40;
    }
    __int16 v81 = (char *)__nw_create_backtrace_string();
    os_log_type_t v7 = __nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v85 = os_log_type_enabled(v7, type);
    if (!v81)
    {
      if (v85)
      {
        *(_DWORD *)int buf = 136446210;
        char v98 = "nw_protocol_http2_frame_input_finalizer";
        BOOL v9 = "%{public}s called with null stream, no backtrace";
        goto LABEL_38;
      }
      goto LABEL_40;
    }
    if (v85)
    {
      *(_DWORD *)int buf = 136446466;
      char v98 = "nw_protocol_http2_frame_input_finalizer";
      __int16 v99 = 2082;
      long long v100 = v81;
      int v83 = "%{public}s called with null stream, dumping backtrace:%{public}s";
      goto LABEL_166;
    }
LABEL_167:
    free(v81);
    if (v6) {
      goto LABEL_41;
    }
    return;
  }
LABEL_40:
  if (v6) {
LABEL_41:
  }
    free(v6);
}

BOOL nw_browser_copy_result_to_modify_locked(NWConcrete_nw_browser *a1, const char *a2, uint64_t a3)
{
  *(void *)&v33[13] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a1;
  uint64_t v6 = v5;
  if (!a2)
  {
    BOOL v15 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v31 = "nw_browser_copy_result_to_modify_locked";
    __int16 v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (__nwlog_fault(v16, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v17 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v31 = "nw_browser_copy_result_to_modify_locked";
          _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s called with null key_name", buf, 0xCu);
        }
      }
      else if (v28)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v17 = __nwlog_obj();
        os_log_type_t v20 = type;
        BOOL v21 = os_log_type_enabled(v17, type);
        if (backtrace_string)
        {
          if (v21)
          {
            *(_DWORD *)int buf = 136446466;
            BOOL v31 = "nw_browser_copy_result_to_modify_locked";
            __int16 v32 = 2082;
            *(void *)BOOL v33 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v17, v20, "%{public}s called with null key_name, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_41;
        }
        if (v21)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v31 = "nw_browser_copy_result_to_modify_locked";
          _os_log_impl(&dword_1830D4000, v17, v20, "%{public}s called with null key_name, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v17 = __nwlog_obj();
        os_log_type_t v27 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v31 = "nw_browser_copy_result_to_modify_locked";
          _os_log_impl(&dword_1830D4000, v17, v27, "%{public}s called with null key_name, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_41:
    if (v16) {
      free(v16);
    }
    goto LABEL_43;
  }
  if (!a3)
  {
LABEL_43:
    mutable_copy = 0;
    goto LABEL_44;
  }
  id v7 = nw_browser_copy_new_result_locked(v5, a2);
  os_log_type_t v8 = v7;
  if (v7)
  {
    mutable_copy = (NWConcrete_nw_browse_result *)v7;
LABEL_20:

LABEL_44:
    return (BOOL)mutable_copy;
  }
  id v10 = nw_browser_copy_old_result_locked(v6, a2);
  if (!v10)
  {
    __int16 v22 = __nwlog_obj();
    os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int buf = 136446210;
    BOOL v31 = "nw_browser_copy_result_to_modify_locked";
    int v23 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v23);
    if (result) {
      goto LABEL_45;
    }
    free(v23);
  }
  mutable_copy = nw_browse_result_create_mutable_copy(v10);
  if (mutable_copy)
  {
LABEL_7:
    if (!nw_parameters_get_logging_disabled(*((void *)v6 + 5)))
    {
      if (__nwlog_browser_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
      }
      os_log_type_t v11 = (id)gbrowserLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        int v12 = *((_DWORD *)v6 + 48);
        *(_DWORD *)int buf = 136446722;
        BOOL v31 = "nw_browser_copy_result_to_modify_locked";
        __int16 v32 = 1024;
        *(_DWORD *)BOOL v33 = v12;
        v33[2] = 2112;
        *(void *)&v33[3] = mutable_copy;
        _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] copy %@", buf, 0x1Cu);
      }
    }
    nw_array_append(*((void *)v6 + 18), mutable_copy);
    if (!nw_parameters_get_logging_disabled(*((void *)v6 + 5)))
    {
      if (__nwlog_browser_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
      }
      uint64_t v13 = (id)gbrowserLogObj;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        int v14 = *((_DWORD *)v6 + 48);
        *(_DWORD *)int buf = 136446722;
        BOOL v31 = "nw_browser_copy_result_to_modify_locked";
        __int16 v32 = 1024;
        *(_DWORD *)BOOL v33 = v14;
        v33[2] = 2112;
        *(void *)&v33[3] = mutable_copy;
        _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] add %@ to new_results", buf, 0x1Cu);
      }
    }
    goto LABEL_20;
  }
  uint64_t v25 = __nwlog_obj();
  os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
  *(_DWORD *)int buf = 136446210;
  BOOL v31 = "nw_browser_copy_result_to_modify_locked";
  int v26 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v26);
  if (!result)
  {
    free(v26);
    goto LABEL_7;
  }
LABEL_45:
  __break(1u);
  return result;
}

void sub_1834958CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_default_add_listen_handler(nw_protocol *a1, nw_listen_protocol *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v3 = gLogObj;
  if (a1)
  {
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      identifier = (nw_protocol_identifier *)"invalid";
      if (a1->identifier) {
        identifier = a1->identifier;
      }
      *(_DWORD *)int buf = 136446466;
      BOOL v15 = "nw_protocol_default_add_listen_handler";
      __int16 v16 = 2082;
      os_log_type_t v17 = identifier;
      _os_log_impl(&dword_1830D4000, v3, OS_LOG_TYPE_INFO, "%{public}s Default protocol handler does not support add_listen_handler for %{public}s", buf, 0x16u);
    }
    return 0;
  }
  *(_DWORD *)int buf = 136446210;
  BOOL v15 = "nw_protocol_default_add_listen_handler";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v6, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v15 = "nw_protocol_default_add_listen_handler";
      BOOL v9 = "%{public}s called with null protocol";
      goto LABEL_20;
    }
    if (!v12)
    {
      id v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v15 = "nw_protocol_default_add_listen_handler";
      BOOL v9 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_20;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    id v7 = __nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v11 = os_log_type_enabled(v7, type);
    if (backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)int buf = 136446466;
        BOOL v15 = "nw_protocol_default_add_listen_handler";
        __int16 v16 = 2082;
        os_log_type_t v17 = (nw_protocol_identifier *)backtrace_string;
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_21;
    }
    if (v11)
    {
      *(_DWORD *)int buf = 136446210;
      BOOL v15 = "nw_protocol_default_add_listen_handler";
      BOOL v9 = "%{public}s called with null protocol, no backtrace";
LABEL_20:
      _os_log_impl(&dword_1830D4000, v7, v8, v9, buf, 0xCu);
    }
  }
LABEL_21:
  if (v6) {
    free(v6);
  }
  return 0;
}

uint64_t nw_nat64_get_interface_state_internal(unsigned int *a1, id *a2)
{
  *(void *)&v64[13] = *MEMORY[0x1E4F143B8];
  unsigned int v4 = *a1;
  if (a2)
  {
    id v5 = *a2;
    *a2 = 0;
  }
  if (!v4)
  {
    evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(0, 0);
    if (evaluator_for_endpoint) {
      goto LABEL_17;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v8 = (id)gLogObj;
    *(_DWORD *)int buf = 136446210;
    int v62 = "nw_nat64_get_interface_state_internal";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v59 = 0;
    if (__nwlog_fault(v9, &type, &v59))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v10 = (id)gLogObj;
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)int buf = 136446210;
          int v62 = "nw_nat64_get_interface_state_internal";
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s nw_path_create_default_evaluator failed", buf, 0xCu);
        }
      }
      else if (v59)
      {
        backtrace_string = __nw_create_backtrace_string();
        if (backtrace_string)
        {
          int v34 = (char *)backtrace_string;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v35 = (id)gLogObj;
          os_log_type_t v36 = type;
          if (os_log_type_enabled(v35, type))
          {
            *(_DWORD *)int buf = 136446466;
            int v62 = "nw_nat64_get_interface_state_internal";
            __int16 v63 = 2082;
            *(void *)uint64_t v64 = v34;
            _os_log_impl(&dword_1830D4000, v35, v36, "%{public}s nw_path_create_default_evaluator failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v34);
          if (!v9) {
            return 4;
          }
          goto LABEL_84;
        }
        id v10 = __nwlog_obj();
        os_log_type_t v53 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)int buf = 136446210;
          int v62 = "nw_nat64_get_interface_state_internal";
          _os_log_impl(&dword_1830D4000, v10, v53, "%{public}s nw_path_create_default_evaluator failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v10 = (id)gLogObj;
        os_log_type_t v51 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)int buf = 136446210;
          int v62 = "nw_nat64_get_interface_state_internal";
          _os_log_impl(&dword_1830D4000, v10, v51, "%{public}s nw_path_create_default_evaluator failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    if (!v9) {
      return 4;
    }
LABEL_84:
    free(v9);
    return 4;
  }
  if (v4 != -1)
  {
    char v12 = nw_interface_create_with_index(v4);
    if (!v12)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v21 = (id)gLogObj;
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446466;
        int v62 = "nw_nat64_get_interface_state_internal";
        __int16 v63 = 1024;
        *(_DWORD *)uint64_t v64 = v4;
        _os_log_impl(&dword_1830D4000, v21, OS_LOG_TYPE_ERROR, "%{public}s nw_interface_create_with_index failed for index %u", buf, 0x12u);
      }

      return 4;
    }
    p_super = &v12->super;
    int v14 = nw_parameters_create();
    BOOL v15 = v14;
    if (v14)
    {
      nw_parameters_require_interface(v14, p_super);
      evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(0, v15);
      if (evaluator_for_endpoint)
      {

LABEL_17:
        __int16 v16 = evaluator_for_endpoint;
        os_unfair_lock_lock((os_unfair_lock_t)evaluator_for_endpoint + 24);
        os_log_type_t v17 = (void *)*((void *)v16 + 6);
        id v18 = v17;
        os_unfair_lock_unlock((os_unfair_lock_t)evaluator_for_endpoint + 24);

        if (v18)
        {
          uint64_t v19 = (NWConcrete_nw_path *)v18;
          if (nw_path_network_is_satisfied_update_reason(v19, 0)) {
            unsigned int routed_interface_index = v19->policy_result.routed_interface_index;
          }
          else {
            unsigned int routed_interface_index = 0;
          }

          char is_eligible_for_CrazyIvan46 = nw_path_is_eligible_for_CrazyIvan46(v19);
          if (gLogDatapath)
          {
            BOOL v27 = nw_path_copy_description(v19);
            *a1 = routed_interface_index;
            if (routed_interface_index)
            {
LABEL_31:
              if (is_eligible_for_CrazyIvan46)
              {
                char v28 = v19;
                if (*((unsigned char *)v28 + 474)) {
                  uint64_t v6 = 1;
                }
                else {
                  uint64_t v6 = 2;
                }

                if (!a2)
                {
LABEL_114:
                  if (v27) {
                    free((void *)v27);
                  }
                  goto LABEL_116;
                }
LABEL_113:
                objc_storeStrong(a2, v17);
                goto LABEL_114;
              }
              if (gLogDatapath)
              {
                dispatch_data_t v37 = __nwlog_obj();
                if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)int buf = 136446466;
                  int v62 = "nw_nat64_get_interface_state_internal";
                  __int16 v63 = 2082;
                  *(void *)uint64_t v64 = v27;
                  _os_log_impl(&dword_1830D4000, v37, OS_LOG_TYPE_DEBUG, "%{public}s bailing because path not eligible: %{public}s", buf, 0x16u);
                }
LABEL_51:

                goto LABEL_112;
              }
              goto LABEL_112;
            }
          }
          else
          {
            BOOL v27 = 0;
            *a1 = routed_interface_index;
            if (routed_interface_index) {
              goto LABEL_31;
            }
          }
          if (gLogDatapath)
          {
            dispatch_data_t v37 = __nwlog_obj();
            if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)int buf = 136446466;
              int v62 = "nw_nat64_get_interface_state_internal";
              __int16 v63 = 2082;
              *(void *)uint64_t v64 = v27;
              _os_log_impl(&dword_1830D4000, v37, OS_LOG_TYPE_DEBUG, "%{public}s bailing because path not satisfied: %{public}s", buf, 0x16u);
            }
            goto LABEL_51;
          }
LABEL_112:
          uint64_t v6 = 3;
          if (!a2) {
            goto LABEL_114;
          }
          goto LABEL_113;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v22 = (id)gLogObj;
        *(_DWORD *)int buf = 136446210;
        int v62 = "nw_nat64_get_interface_state_internal";
        int v23 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v59 = 0;
        if (__nwlog_fault(v23, &type, &v59))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            int v24 = (id)gLogObj;
            os_log_type_t v25 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)int buf = 136446210;
              int v62 = "nw_nat64_get_interface_state_internal";
              _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s nw_path_evaluator_copy_path failed", buf, 0xCu);
            }
          }
          else if (v59)
          {
            uint64_t v38 = __nw_create_backtrace_string();
            if (v38)
            {
              __int16 v39 = (char *)v38;
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v40 = (id)gLogObj;
              os_log_type_t v41 = type;
              if (os_log_type_enabled(v40, type))
              {
                *(_DWORD *)int buf = 136446466;
                int v62 = "nw_nat64_get_interface_state_internal";
                __int16 v63 = 2082;
                *(void *)uint64_t v64 = v39;
                _os_log_impl(&dword_1830D4000, v40, v41, "%{public}s nw_path_evaluator_copy_path failed, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v39);
              if (!v23) {
                goto LABEL_93;
              }
              goto LABEL_92;
            }
            int v24 = __nwlog_obj();
            os_log_type_t v55 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)int buf = 136446210;
              int v62 = "nw_nat64_get_interface_state_internal";
              _os_log_impl(&dword_1830D4000, v24, v55, "%{public}s nw_path_evaluator_copy_path failed, no backtrace", buf, 0xCu);
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            int v24 = (id)gLogObj;
            os_log_type_t v52 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)int buf = 136446210;
              int v62 = "nw_nat64_get_interface_state_internal";
              _os_log_impl(&dword_1830D4000, v24, v52, "%{public}s nw_path_evaluator_copy_path failed, backtrace limit exceeded", buf, 0xCu);
            }
          }
        }
        if (!v23)
        {
LABEL_93:
          uint64_t v6 = 4;
LABEL_116:

          return v6;
        }
LABEL_92:
        free(v23);
        goto LABEL_93;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v42 = (id)gLogObj;
      *(_DWORD *)int buf = 136446466;
      int v62 = "nw_nat64_get_interface_state_internal";
      __int16 v63 = 1024;
      *(_DWORD *)uint64_t v64 = v4;
      uint32_t v30 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v59 = 0;
      if (__nwlog_fault(v30, &type, &v59))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          char v43 = (id)gLogObj;
          os_log_type_t v44 = type;
          if (os_log_type_enabled(v43, type))
          {
            *(_DWORD *)int buf = 136446466;
            int v62 = "nw_nat64_get_interface_state_internal";
            __int16 v63 = 1024;
            *(_DWORD *)uint64_t v64 = v4;
            _os_log_impl(&dword_1830D4000, v43, v44, "%{public}s nw_path_create_evaluator_for_endpoint, ifindex=%u failed", buf, 0x12u);
          }
LABEL_102:

          goto LABEL_103;
        }
        if (!v59)
        {
          char v43 = __nwlog_obj();
          os_log_type_t v56 = type;
          if (os_log_type_enabled(v43, type))
          {
            *(_DWORD *)int buf = 136446466;
            int v62 = "nw_nat64_get_interface_state_internal";
            __int16 v63 = 1024;
            *(_DWORD *)uint64_t v64 = v4;
            _os_log_impl(&dword_1830D4000, v43, v56, "%{public}s nw_path_create_evaluator_for_endpoint, ifindex=%u failed, backtrace limit exceeded", buf, 0x12u);
          }
          goto LABEL_102;
        }
        uint64_t v48 = (char *)__nw_create_backtrace_string();
        char v43 = __nwlog_obj();
        os_log_type_t v49 = type;
        BOOL v50 = os_log_type_enabled(v43, type);
        if (!v48)
        {
          if (v50)
          {
            *(_DWORD *)int buf = 136446466;
            int v62 = "nw_nat64_get_interface_state_internal";
            __int16 v63 = 1024;
            *(_DWORD *)uint64_t v64 = v4;
            _os_log_impl(&dword_1830D4000, v43, v49, "%{public}s nw_path_create_evaluator_for_endpoint, ifindex=%u failed, no backtrace", buf, 0x12u);
          }
          goto LABEL_102;
        }
        if (v50)
        {
          *(_DWORD *)int buf = 136446722;
          int v62 = "nw_nat64_get_interface_state_internal";
          __int16 v63 = 1024;
          *(_DWORD *)uint64_t v64 = v4;
          v64[2] = 2082;
          *(void *)&v64[3] = v48;
          _os_log_impl(&dword_1830D4000, v43, v49, "%{public}s nw_path_create_evaluator_for_endpoint, ifindex=%u failed, dumping backtrace:%{public}s", buf, 0x1Cu);
        }

        free(v48);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v29 = (id)gLogObj;
      *(_DWORD *)int buf = 136446210;
      int v62 = "nw_nat64_get_interface_state_internal";
      uint32_t v30 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v59 = 0;
      if (__nwlog_fault(v30, &type, &v59))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v31 = (id)gLogObj;
          os_log_type_t v32 = type;
          if (os_log_type_enabled(v31, type))
          {
            *(_DWORD *)int buf = 136446210;
            int v62 = "nw_nat64_get_interface_state_internal";
            _os_log_impl(&dword_1830D4000, v31, v32, "%{public}s nw_parameters_create failed", buf, 0xCu);
          }
        }
        else if (v59)
        {
          char v45 = (char *)__nw_create_backtrace_string();
          BOOL v31 = __nwlog_obj();
          os_log_type_t v46 = type;
          BOOL v47 = os_log_type_enabled(v31, type);
          if (v45)
          {
            if (v47)
            {
              *(_DWORD *)int buf = 136446466;
              int v62 = "nw_nat64_get_interface_state_internal";
              __int16 v63 = 2082;
              *(void *)uint64_t v64 = v45;
              _os_log_impl(&dword_1830D4000, v31, v46, "%{public}s nw_parameters_create failed, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v45);
            if (!v30) {
              goto LABEL_105;
            }
            goto LABEL_104;
          }
          if (v47)
          {
            *(_DWORD *)int buf = 136446210;
            int v62 = "nw_nat64_get_interface_state_internal";
            _os_log_impl(&dword_1830D4000, v31, v46, "%{public}s nw_parameters_create failed, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          BOOL v31 = __nwlog_obj();
          os_log_type_t v54 = type;
          if (os_log_type_enabled(v31, type))
          {
            *(_DWORD *)int buf = 136446210;
            int v62 = "nw_nat64_get_interface_state_internal";
            _os_log_impl(&dword_1830D4000, v31, v54, "%{public}s nw_parameters_create failed, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }
    }
LABEL_103:
    if (!v30)
    {
LABEL_105:

      return 4;
    }
LABEL_104:
    free(v30);
    goto LABEL_105;
  }
  if (gLogDatapath)
  {
    int v57 = __nwlog_obj();
    if (os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)int buf = 136446210;
      int v62 = "nw_nat64_get_interface_state_internal";
      _os_log_impl(&dword_1830D4000, v57, OS_LOG_TYPE_DEBUG, "%{public}s bailing because local only", buf, 0xCu);
    }
  }
  return 3;
}

void sub_183496978(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_udp_remove_input_handler(nw_protocol *a1, nw_protocol *a2, uint64_t a3)
{
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    int v65 = "nw_protocol_udp_remove_input_handler";
    os_log_type_t v32 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v62 = 0;
    if (!__nwlog_fault(v32, &type, &v62)) {
      goto LABEL_130;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v62)
      {
        BOOL v33 = __nwlog_obj();
        os_log_type_t v34 = type;
        if (!os_log_type_enabled(v33, type)) {
          goto LABEL_130;
        }
        *(_DWORD *)int buf = 136446210;
        int v65 = "nw_protocol_udp_remove_input_handler";
        int v35 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_129;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v33 = __nwlog_obj();
      os_log_type_t v34 = type;
      BOOL v47 = os_log_type_enabled(v33, type);
      if (!backtrace_string)
      {
        if (!v47) {
          goto LABEL_130;
        }
        *(_DWORD *)int buf = 136446210;
        int v65 = "nw_protocol_udp_remove_input_handler";
        int v35 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_129;
      }
      if (v47)
      {
        *(_DWORD *)int buf = 136446466;
        int v65 = "nw_protocol_udp_remove_input_handler";
        __int16 v66 = 2082;
        os_log_type_t v67 = backtrace_string;
        uint64_t v48 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_91:
        _os_log_impl(&dword_1830D4000, v33, v34, v48, buf, 0x16u);
      }
LABEL_92:
      free(backtrace_string);
      goto LABEL_130;
    }
    BOOL v33 = __nwlog_obj();
    os_log_type_t v34 = type;
    if (!os_log_type_enabled(v33, type)) {
      goto LABEL_130;
    }
    *(_DWORD *)int buf = 136446210;
    int v65 = "nw_protocol_udp_remove_input_handler";
    int v35 = "%{public}s called with null protocol";
LABEL_129:
    _os_log_impl(&dword_1830D4000, v33, v34, v35, buf, 0xCu);
LABEL_130:
    if (v32) {
      free(v32);
    }
    return 0;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    int v65 = "nw_protocol_udp_remove_input_handler";
    os_log_type_t v32 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v62 = 0;
    if (!__nwlog_fault(v32, &type, &v62)) {
      goto LABEL_130;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v33 = __nwlog_obj();
      os_log_type_t v34 = type;
      if (!os_log_type_enabled(v33, type)) {
        goto LABEL_130;
      }
      *(_DWORD *)int buf = 136446210;
      int v65 = "nw_protocol_udp_remove_input_handler";
      int v35 = "%{public}s called with null udp";
      goto LABEL_129;
    }
    if (!v62)
    {
      BOOL v33 = __nwlog_obj();
      os_log_type_t v34 = type;
      if (!os_log_type_enabled(v33, type)) {
        goto LABEL_130;
      }
      *(_DWORD *)int buf = 136446210;
      int v65 = "nw_protocol_udp_remove_input_handler";
      int v35 = "%{public}s called with null udp, backtrace limit exceeded";
      goto LABEL_129;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v33 = __nwlog_obj();
    os_log_type_t v34 = type;
    BOOL v49 = os_log_type_enabled(v33, type);
    if (backtrace_string)
    {
      if (v49)
      {
        *(_DWORD *)int buf = 136446466;
        int v65 = "nw_protocol_udp_remove_input_handler";
        __int16 v66 = 2082;
        os_log_type_t v67 = backtrace_string;
        uint64_t v48 = "%{public}s called with null udp, dumping backtrace:%{public}s";
        goto LABEL_91;
      }
      goto LABEL_92;
    }
    if (!v49) {
      goto LABEL_130;
    }
    *(_DWORD *)int buf = 136446210;
    int v65 = "nw_protocol_udp_remove_input_handler";
    int v35 = "%{public}s called with null udp, no backtrace";
    goto LABEL_129;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    int v65 = "__nw_protocol_get_output_handler";
    os_log_type_t v36 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v62 = 0;
    if (!__nwlog_fault(v36, &type, &v62)) {
      goto LABEL_135;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      dispatch_data_t v37 = __nwlog_obj();
      os_log_type_t v38 = type;
      if (!os_log_type_enabled(v37, type)) {
        goto LABEL_135;
      }
      *(_DWORD *)int buf = 136446210;
      int v65 = "__nw_protocol_get_output_handler";
      __int16 v39 = "%{public}s called with null protocol";
    }
    else if (v62)
    {
      BOOL v50 = (char *)__nw_create_backtrace_string();
      dispatch_data_t v37 = __nwlog_obj();
      os_log_type_t v38 = type;
      BOOL v51 = os_log_type_enabled(v37, type);
      if (v50)
      {
        if (v51)
        {
          *(_DWORD *)int buf = 136446466;
          int v65 = "__nw_protocol_get_output_handler";
          __int16 v66 = 2082;
          os_log_type_t v67 = v50;
          _os_log_impl(&dword_1830D4000, v37, v38, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v50);
LABEL_135:
        if (v36) {
          free(v36);
        }
        if (a1->default_input_handler) {
          return 0;
        }
        goto LABEL_18;
      }
      if (!v51) {
        goto LABEL_135;
      }
      *(_DWORD *)int buf = 136446210;
      int v65 = "__nw_protocol_get_output_handler";
      __int16 v39 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      dispatch_data_t v37 = __nwlog_obj();
      os_log_type_t v38 = type;
      if (!os_log_type_enabled(v37, type)) {
        goto LABEL_135;
      }
      *(_DWORD *)int buf = 136446210;
      int v65 = "__nw_protocol_get_output_handler";
      __int16 v39 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v37, v38, v39, buf, 0xCu);
    goto LABEL_135;
  }
  if (a2->output_handler == a1)
  {
    callbacks = a1[1].callbacks;
    if (callbacks)
    {
      id v7 = (nw_protocol_callbacks *)((char *)callbacks - 1);
      a1[1].callbacks = v7;
      if (!v7)
      {
        id v8 = *(void (***)(void))a1[1].flow_id;
        if (v8)
        {
          *(void *)a1[1].flow_uint64_t id = 0;
          v8[2](v8);
          _Block_release(v8);
        }
        if (a1[1].flow_id[8])
        {
          BOOL v9 = *(const void **)a1[1].flow_id;
          if (v9) {
            _Block_release(v9);
          }
        }
        free(a1);
      }
    }
    a2->uint64_t output_handler = 0;
  }
  if (a1->default_input_handler != a2) {
    return 0;
  }
  if (a2->handle == &nw_protocol_ref_counted_handle)
  {
    os_log_type_t v20 = a2[1].callbacks;
    if (v20)
    {
      BOOL v21 = (nw_protocol_callbacks *)((char *)v20 - 1);
      a2[1].callbacks = v21;
      if (!v21)
      {
        id v22 = *(void (***)(void))a2[1].flow_id;
        if (v22)
        {
          *(void *)a2[1].flow_uint64_t id = 0;
          v22[2](v22);
          _Block_release(v22);
        }
        if (a2[1].flow_id[8])
        {
          int v23 = *(const void **)a2[1].flow_id;
          if (v23) {
            _Block_release(v23);
          }
        }
        free(a2);
      }
    }
  }
  a1->default_input_handler = 0;
LABEL_18:
  uint64_t output_handler = (uint64_t)a1->output_handler;
  if (output_handler)
  {
    char v12 = *(void **)(output_handler + 40);
    if (v12 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v13 = *(void *)(output_handler + 88);
      if (v13) {
        *(void *)(output_handler + 88) = v13 + 1;
      }
    }
    handle = a1->handle;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      BOOL v15 = a1[1].callbacks;
      if (v15) {
        a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v15->add_input_handler + 1);
      }
    }
    uint64_t v16 = *(void *)(output_handler + 24);
    if (v16)
    {
      os_log_type_t v17 = *(void (**)(uint64_t, nw_protocol *, uint64_t))(v16 + 8);
      if (v17)
      {
        v17(output_handler, a1, a3);
LABEL_28:
        if (handle == &nw_protocol_ref_counted_handle && a1->handle == &nw_protocol_ref_counted_handle)
        {
          int v24 = a1[1].callbacks;
          if (v24)
          {
            os_log_type_t v25 = (nw_protocol_callbacks *)((char *)v24 - 1);
            a1[1].callbacks = v25;
            if (!v25)
            {
              int v26 = *(void (***)(void))a1[1].flow_id;
              if (v26)
              {
                *(void *)a1[1].flow_uint64_t id = 0;
                v26[2](v26);
                _Block_release(v26);
              }
              if (a1[1].flow_id[8])
              {
                BOOL v27 = *(const void **)a1[1].flow_id;
                if (v27) {
                  _Block_release(v27);
                }
              }
              free(a1);
            }
          }
        }
        if (v12 != &nw_protocol_ref_counted_handle) {
          goto LABEL_32;
        }
        if (*(_UNKNOWN **)(output_handler + 40) != &nw_protocol_ref_counted_handle) {
          goto LABEL_32;
        }
        uint64_t v28 = *(void *)(output_handler + 88);
        if (!v28) {
          goto LABEL_32;
        }
        uint64_t v29 = v28 - 1;
        *(void *)(output_handler + 88) = v29;
        if (v29) {
          goto LABEL_32;
        }
        uint32_t v30 = *(void (***)(void))(output_handler + 64);
        if (v30)
        {
          *(void *)(output_handler + 64) = 0;
          v30[2](v30);
          _Block_release(v30);
        }
        if (*(unsigned char *)(output_handler + 72))
        {
          BOOL v31 = *(const void **)(output_handler + 64);
          if (v31) {
            _Block_release(v31);
          }
        }
        goto LABEL_62;
      }
    }
    __nwlog_obj();
    uint64_t v40 = *(const char **)(output_handler + 16);
    *(_DWORD *)int buf = 136446722;
    int v65 = "__nw_protocol_remove_input_handler";
    if (!v40) {
      uint64_t v40 = "invalid";
    }
    __int16 v66 = 2082;
    os_log_type_t v67 = (void *)v40;
    __int16 v68 = 2048;
    uint64_t v69 = output_handler;
    os_log_type_t v41 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v62 = 0;
    if (__nwlog_fault(v41, &type, &v62))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v42 = __nwlog_obj();
        os_log_type_t v43 = type;
        if (!os_log_type_enabled(v42, type)) {
          goto LABEL_144;
        }
        os_log_type_t v44 = *(const char **)(output_handler + 16);
        if (!v44) {
          os_log_type_t v44 = "invalid";
        }
        *(_DWORD *)int buf = 136446722;
        int v65 = "__nw_protocol_remove_input_handler";
        __int16 v66 = 2082;
        os_log_type_t v67 = (void *)v44;
        __int16 v68 = 2048;
        uint64_t v69 = output_handler;
        char v45 = "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback";
        goto LABEL_143;
      }
      if (!v62)
      {
        id v42 = __nwlog_obj();
        os_log_type_t v43 = type;
        if (!os_log_type_enabled(v42, type)) {
          goto LABEL_144;
        }
        uint64_t v60 = *(const char **)(output_handler + 16);
        if (!v60) {
          uint64_t v60 = "invalid";
        }
        *(_DWORD *)int buf = 136446722;
        int v65 = "__nw_protocol_remove_input_handler";
        __int16 v66 = 2082;
        os_log_type_t v67 = (void *)v60;
        __int16 v68 = 2048;
        uint64_t v69 = output_handler;
        char v45 = "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, backtrace limit exceeded";
        goto LABEL_143;
      }
      os_log_type_t v55 = (char *)__nw_create_backtrace_string();
      id v42 = __nwlog_obj();
      os_log_type_t v43 = type;
      BOOL v56 = os_log_type_enabled(v42, type);
      if (v55)
      {
        if (v56)
        {
          int v57 = *(const char **)(output_handler + 16);
          if (!v57) {
            int v57 = "invalid";
          }
          *(_DWORD *)int buf = 136446978;
          int v65 = "__nw_protocol_remove_input_handler";
          __int16 v66 = 2082;
          os_log_type_t v67 = (void *)v57;
          __int16 v68 = 2048;
          uint64_t v69 = output_handler;
          __int16 v70 = 2082;
          uint64_t v71 = v55;
          _os_log_impl(&dword_1830D4000, v42, v43, "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        free(v55);
        goto LABEL_144;
      }
      if (v56)
      {
        id v61 = *(const char **)(output_handler + 16);
        if (!v61) {
          id v61 = "invalid";
        }
        *(_DWORD *)int buf = 136446722;
        int v65 = "__nw_protocol_remove_input_handler";
        __int16 v66 = 2082;
        os_log_type_t v67 = (void *)v61;
        __int16 v68 = 2048;
        uint64_t v69 = output_handler;
        char v45 = "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, no backtrace";
LABEL_143:
        _os_log_impl(&dword_1830D4000, v42, v43, v45, buf, 0x20u);
      }
    }
LABEL_144:
    if (v41) {
      free(v41);
    }
    goto LABEL_28;
  }
  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  int v65 = "__nw_protocol_remove_input_handler";
  uint64_t output_handler = _os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v62 = 0;
  if (!__nwlog_fault((const char *)output_handler, &type, &v62))
  {
LABEL_151:
    if (!output_handler) {
      goto LABEL_32;
    }
    goto LABEL_62;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v52 = __nwlog_obj();
    os_log_type_t v53 = type;
    if (!os_log_type_enabled(v52, type)) {
      goto LABEL_151;
    }
    *(_DWORD *)int buf = 136446210;
    int v65 = "__nw_protocol_remove_input_handler";
    os_log_type_t v54 = "%{public}s called with null protocol";
LABEL_150:
    _os_log_impl(&dword_1830D4000, v52, v53, v54, buf, 0xCu);
    goto LABEL_151;
  }
  if (!v62)
  {
    os_log_type_t v52 = __nwlog_obj();
    os_log_type_t v53 = type;
    if (!os_log_type_enabled(v52, type)) {
      goto LABEL_151;
    }
    *(_DWORD *)int buf = 136446210;
    int v65 = "__nw_protocol_remove_input_handler";
    os_log_type_t v54 = "%{public}s called with null protocol, backtrace limit exceeded";
    goto LABEL_150;
  }
  BOOL v58 = (char *)__nw_create_backtrace_string();
  os_log_type_t v52 = __nwlog_obj();
  os_log_type_t v53 = type;
  BOOL v59 = os_log_type_enabled(v52, type);
  if (!v58)
  {
    if (!v59) {
      goto LABEL_151;
    }
    *(_DWORD *)int buf = 136446210;
    int v65 = "__nw_protocol_remove_input_handler";
    os_log_type_t v54 = "%{public}s called with null protocol, no backtrace";
    goto LABEL_150;
  }
  if (v59)
  {
    *(_DWORD *)int buf = 136446466;
    int v65 = "__nw_protocol_remove_input_handler";
    __int16 v66 = 2082;
    os_log_type_t v67 = v58;
    _os_log_impl(&dword_1830D4000, v52, v53, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v58);
  if (!output_handler) {
    goto LABEL_32;
  }
LABEL_62:
  free((void *)output_handler);
LABEL_32:
  if (a3)
  {
    default_input_handler = a1[1].default_input_handler;
    if (default_input_handler)
    {
      os_release(default_input_handler);
      a1[1].default_input_handler = 0;
    }
    output_handler_nw_content_context_t context = a1[1].output_handler_context;
    if (output_handler_context)
    {
      os_release(output_handler_context);
      a1[1].output_handler_nw_content_context_t context = 0;
    }
    nw_protocol_destroy((uint64_t)&a1[1].output_handler, 0);
  }
  return 1;
}

void nw_masque_connection_pair_read_inner(NWConcrete_nw_masque_connection_pair *a1)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    unsigned int v4 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v28 = "nw_masque_connection_pair_read_inner";
    id v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (!__nwlog_fault(v5, &type, &v25)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v28 = "nw_masque_connection_pair_read_inner";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null pair", buf, 0xCu);
      }
    }
    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v28 = "nw_masque_connection_pair_read_inner";
          __int16 v29 = 2082;
          uint32_t v30 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v13, "%{public}s called with null pair, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v5) {
          goto LABEL_5;
        }
LABEL_56:
        free(v5);
        goto LABEL_5;
      }
      if (v14)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v28 = "nw_masque_connection_pair_read_inner";
        _os_log_impl(&dword_1830D4000, v6, v13, "%{public}s called with null pair, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v28 = "nw_masque_connection_pair_read_inner";
        _os_log_impl(&dword_1830D4000, v6, v20, "%{public}s called with null pair, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_54:

    goto LABEL_55;
  }
  id v3 = *(void **)(*((void *)v1 + 2) + 48);
  if (!v3)
  {
    id v8 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v28 = "nw_masque_connection_pair_read_inner";
    id v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (!__nwlog_fault(v5, &type, &v25)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v28 = "nw_masque_connection_pair_read_inner";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null pair->mcp_parent->mc_in_connection", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v25)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v28 = "nw_masque_connection_pair_read_inner";
        _os_log_impl(&dword_1830D4000, v6, v21, "%{public}s called with null pair->mcp_parent->mc_in_connection, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    BOOL v15 = (char *)__nw_create_backtrace_string();
    uint64_t v6 = __nwlog_obj();
    os_log_type_t v16 = type;
    BOOL v17 = os_log_type_enabled(v6, type);
    if (!v15)
    {
      if (v17)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v28 = "nw_masque_connection_pair_read_inner";
        _os_log_impl(&dword_1830D4000, v6, v16, "%{public}s called with null pair->mcp_parent->mc_in_connection, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v17)
    {
      *(_DWORD *)int buf = 136446466;
      uint64_t v28 = "nw_masque_connection_pair_read_inner";
      __int16 v29 = 2082;
      uint32_t v30 = v15;
      _os_log_impl(&dword_1830D4000, v6, v16, "%{public}s called with null pair->mcp_parent->mc_in_connection, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_35;
  }
  if (!*((void *)v1 + 6))
  {
    id v10 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v28 = "nw_masque_connection_pair_read_inner";
    id v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (!__nwlog_fault(v5, &type, &v25)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v28 = "nw_masque_connection_pair_read_inner";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null pair->mcp_outer_connection", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v25)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v28 = "nw_masque_connection_pair_read_inner";
        _os_log_impl(&dword_1830D4000, v6, v22, "%{public}s called with null pair->mcp_outer_connection, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    BOOL v15 = (char *)__nw_create_backtrace_string();
    uint64_t v6 = __nwlog_obj();
    os_log_type_t v18 = type;
    BOOL v19 = os_log_type_enabled(v6, type);
    if (!v15)
    {
      if (v19)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v28 = "nw_masque_connection_pair_read_inner";
        _os_log_impl(&dword_1830D4000, v6, v18, "%{public}s called with null pair->mcp_outer_connection, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v19)
    {
      *(_DWORD *)int buf = 136446466;
      uint64_t v28 = "nw_masque_connection_pair_read_inner";
      __int16 v29 = 2082;
      uint32_t v30 = v15;
      _os_log_impl(&dword_1830D4000, v6, v18, "%{public}s called with null pair->mcp_outer_connection, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_35:

    free(v15);
    if (!v5) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }
  v23[0] = MEMORY[0x1E4F143A8];
  v23[1] = 3221225472;
  v23[2] = ___ZL36nw_masque_connection_pair_read_innerP36NWConcrete_nw_masque_connection_pair_block_invoke;
  v23[3] = &unk_1E52427C0;
  int v24 = v1;
  nw_connection_receive_internal(v3, 0, 1u, 0xFFFFFFFF, v23);

LABEL_5:
}

void sub_183497CF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void nw_candidate_manager_handle_ids_path(void *a1, void *a2)
{
  uint64_t v93 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  uint64_t v60 = a2;
  BOOL v58 = v3;
  if (!v3)
  {
    id v42 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    int v88 = "nw_candidate_manager_handle_ids_path";
    os_log_type_t v43 = (char *)_os_log_send_and_compose_impl();

    v72[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v76[0]) = 0;
    if (__nwlog_fault(v43, v72, v76))
    {
      if (v72[0] == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v44 = __nwlog_obj();
        os_log_type_t v45 = v72[0];
        if (os_log_type_enabled(v44, v72[0]))
        {
          *(_DWORD *)int buf = 136446210;
          int v88 = "nw_candidate_manager_handle_ids_path";
          _os_log_impl(&dword_1830D4000, v44, v45, "%{public}s called with null manager", buf, 0xCu);
        }
      }
      else
      {
        if (LOBYTE(v76[0]))
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          BOOL v47 = __nwlog_obj();
          os_log_type_t v48 = v72[0];
          BOOL v49 = os_log_type_enabled(v47, v72[0]);
          if (backtrace_string)
          {
            if (v49)
            {
              *(_DWORD *)int buf = 136446466;
              int v88 = "nw_candidate_manager_handle_ids_path";
              __int16 v89 = 2082;
              int v90 = backtrace_string;
              _os_log_impl(&dword_1830D4000, v47, v48, "%{public}s called with null manager, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
          }
          else
          {
            if (v49)
            {
              *(_DWORD *)int buf = 136446210;
              int v88 = "nw_candidate_manager_handle_ids_path";
              _os_log_impl(&dword_1830D4000, v47, v48, "%{public}s called with null manager, no backtrace", buf, 0xCu);
            }
          }
          goto LABEL_75;
        }
        os_log_type_t v44 = __nwlog_obj();
        os_log_type_t v50 = v72[0];
        if (os_log_type_enabled(v44, v72[0]))
        {
          *(_DWORD *)int buf = 136446210;
          int v88 = "nw_candidate_manager_handle_ids_path";
          _os_log_impl(&dword_1830D4000, v44, v50, "%{public}s called with null manager, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_75:
    if (v43) {
      free(v43);
    }
    goto LABEL_55;
  }
  if (__nwlog_candidate_manager_log::onceToken != -1) {
    dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_24);
  }
  unsigned int v4 = (id)gcandidate_managerLogObj;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = (char *)v3[1];
    *(_DWORD *)int buf = 136446722;
    int v88 = "nw_candidate_manager_handle_ids_path";
    __int16 v89 = 2048;
    int v90 = v5;
    __int16 v91 = 2112;
    int v92 = v60;
    _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_INFO, "%{public}s [CM%zu] path: %@", buf, 0x20u);
  }

  uint64_t v64 = 0;
  int v65 = &v64;
  uint64_t v66 = 0x3032000000;
  os_log_type_t v67 = __Block_byref_object_copy__2746;
  __int16 v68 = __Block_byref_object_dispose__2747;
  id v69 = 0;
  v61[0] = MEMORY[0x1E4F143A8];
  v61[1] = 3221225472;
  v61[2] = ___ZL36nw_candidate_manager_handle_ids_pathP31NWConcrete_nw_candidate_managerPU21objcproto10OS_nw_path8NSObject_block_invoke;
  v61[3] = &unk_1E523AC98;
  __int16 v63 = &v64;
  uint64_t v6 = v3;
  char v62 = v6;
  nw_path_enumerate_resolve_options(v60, v61);
  objc_storeStrong(v6 + 3, (id)v65[5]);
  id v7 = nw_path_copy_resolved_endpoints(v60);
  id v8 = v6;
  object = (atomic_uchar *)v7;
  if (__nwlog_candidate_manager_log::onceToken != -1) {
    dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_24);
  }
  os_log_type_t v9 = (id)gcandidate_managerLogObj;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    id v10 = (char *)v8[1];
    *(_DWORD *)int buf = 136446722;
    int v88 = "nw_candidate_manager_handle_ids_endpoints";
    __int16 v89 = 2048;
    int v90 = v10;
    __int16 v91 = 2112;
    int v92 = object;
    _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_DEFAULT, "%{public}s [CM%zu] endpoints: %@", buf, 0x20u);
  }

  id v11 = v8[4];
  if (v11)
  {
    char v12 = (void *)MEMORY[0x1E4F1CA48];
    id v13 = [v11 allKeys];
    BOOL v14 = [v12 arrayWithArray:v13];
LABEL_12:

    v76[0] = MEMORY[0x1E4F143A8];
    v76[1] = 3221225472;
    v76[2] = ___ZL41nw_candidate_manager_handle_ids_endpointsP31NWConcrete_nw_candidate_managerPU22objcproto11OS_nw_array8NSObject_block_invoke;
    v76[3] = &unk_1E5247FB8;
    id v15 = v14;
    id v77 = v15;
    os_log_type_t v16 = v8;
    BOOL v78 = v16;
    nw_array_apply(object, (uint64_t)v76);
    *(_OWORD *)uint64_t v72 = 0u;
    long long v73 = 0u;
    long long v74 = 0u;
    long long v75 = 0u;
    id v17 = v15;
    uint64_t v18 = [v17 countByEnumeratingWithState:v72 objects:buf count:16];
    if (!v18) {
      goto LABEL_53;
    }
    uint64_t v19 = *(void *)v73;
    while (1)
    {
      uint64_t v20 = 0;
      do
      {
        if (*(void *)v73 != v19) {
          objc_enumerationMutation(v17);
        }
        uint64_t v21 = *(void *)(*(void *)&v72[8] + 8 * v20);
        uint64_t v22 = objc_msgSend(v8[4], "objectForKeyedSubscript:", v21, v51, v52);
        [v8[4] removeObjectForKey:v21];
        if (v22)
        {
          if (nw_array_remove_object((uint64_t)v16[18], v22) && (*(unsigned char *)(v22 + 40) & 8) != 0) {
            nw_candidate_manager_remove((NWConcrete_nw_candidate_manager *)v16, (NWCandidate *)v22);
          }
        }
        else
        {
          if (__nwlog_candidate_manager_log::onceToken != -1) {
            dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_24);
          }
          id v23 = (id)gcandidate_managerLogObj;
          id v24 = v16[1];
          *(_DWORD *)int v79 = 136446722;
          int v80 = "nw_candidate_manager_handle_ids_endpoints";
          __int16 v81 = 2048;
          id v82 = v24;
          __int16 v83 = 2112;
          uint64_t v84 = v21;
          LODWORD(v52) = 32;
          BOOL v51 = v79;
          int v57 = (const char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v70 = 0;
          if (!__nwlog_fault(v57, &type, &v70)) {
            goto LABEL_32;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            BOOL v56 = v6;
            if (__nwlog_candidate_manager_log::onceToken != -1) {
              dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_24);
            }
            char v25 = (id)gcandidate_managerLogObj;
            os_log_type_t v26 = type;
            if (os_log_type_enabled(v25, type))
            {
              id v27 = v16[1];
              *(_DWORD *)int v79 = 136446722;
              int v80 = "nw_candidate_manager_handle_ids_endpoints";
              __int16 v81 = 2048;
              id v82 = v27;
              __int16 v83 = 2112;
              uint64_t v84 = v21;
              _os_log_impl(&dword_1830D4000, v25, v26, "%{public}s [CM%zu] No resolver for %@", v79, 0x20u);
            }

            uint64_t v6 = v56;
LABEL_32:
            uint64_t v28 = (char *)v57;
            if (!v57) {
              goto LABEL_21;
            }
LABEL_33:
            free(v28);
            goto LABEL_21;
          }
          if (!v70)
          {
            if (__nwlog_candidate_manager_log::onceToken != -1) {
              dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_24);
            }
            BOOL v33 = (id)gcandidate_managerLogObj;
            os_log_type_t v34 = type;
            loga = v33;
            if (os_log_type_enabled(v33, type))
            {
              id v35 = v16[1];
              *(_DWORD *)int v79 = 136446722;
              int v80 = "nw_candidate_manager_handle_ids_endpoints";
              __int16 v81 = 2048;
              id v82 = v35;
              __int16 v83 = 2112;
              uint64_t v84 = v21;
              _os_log_impl(&dword_1830D4000, loga, v34, "%{public}s [CM%zu] No resolver for %@, backtrace limit exceeded", v79, 0x20u);
            }
            goto LABEL_46;
          }
          __int16 v29 = __nw_create_backtrace_string();
          if (!v29)
          {
            if (__nwlog_candidate_manager_log::onceToken != -1) {
              dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_24);
            }
            os_log_type_t v36 = (id)gcandidate_managerLogObj;
            os_log_type_t v37 = type;
            loga = v36;
            if (os_log_type_enabled(v36, type))
            {
              id v38 = v16[1];
              *(_DWORD *)int v79 = 136446722;
              int v80 = "nw_candidate_manager_handle_ids_endpoints";
              __int16 v81 = 2048;
              id v82 = v38;
              __int16 v83 = 2112;
              uint64_t v84 = v21;
              _os_log_impl(&dword_1830D4000, loga, v37, "%{public}s [CM%zu] No resolver for %@, no backtrace", v79, 0x20u);
            }
LABEL_46:

            goto LABEL_32;
          }
          os_log_type_t v53 = (char *)v29;
          if (__nwlog_candidate_manager_log::onceToken != -1) {
            dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_24);
          }
          uint32_t v30 = (id)gcandidate_managerLogObj;
          os_log_type_t v31 = type;
          log = v30;
          if (os_log_type_enabled(v30, type))
          {
            id v32 = v16[1];
            *(_DWORD *)int v79 = 136446978;
            int v80 = "nw_candidate_manager_handle_ids_endpoints";
            __int16 v81 = 2048;
            id v82 = v32;
            __int16 v83 = 2112;
            uint64_t v84 = v21;
            __int16 v85 = 2082;
            int v86 = v53;
            _os_log_impl(&dword_1830D4000, log, v31, "%{public}s [CM%zu] No resolver for %@, dumping backtrace:%{public}s", v79, 0x2Au);
          }

          free(v53);
          uint64_t v28 = (char *)v57;
          if (v57) {
            goto LABEL_33;
          }
        }
LABEL_21:

        ++v20;
      }
      while (v18 != v20);
      uint64_t v39 = [v17 countByEnumeratingWithState:v72 objects:buf count:16];
      uint64_t v18 = v39;
      if (!v39)
      {
LABEL_53:

        uint64_t v40 = object;
        goto LABEL_54;
      }
    }
  }
  uint64_t v40 = object;
  if (object && *((void *)object + 2) != *((void *)object + 3))
  {
    uint64_t v41 = [MEMORY[0x1E4F1CA60] dictionary];
    BOOL v14 = 0;
    id v13 = v8[4];
    void v8[4] = (id)v41;
    goto LABEL_12;
  }
LABEL_54:

  _Block_object_dispose(&v64, 8);
LABEL_55:
}

void sub_1834987A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,id a37)
{
  _Block_object_dispose(&a32, 8);
  _Unwind_Resume(a1);
}

void nw_activity_fill_out_activity_report(NWConcrete_nw_activity *a1, nw_activity_report_s *a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  unsigned int v4 = v3;
  if (!a2)
  {
    id v10 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v21 = "nw_activity_fill_out_activity_report";
    id v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v11, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v12 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v21 = "nw_activity_fill_out_activity_report";
          _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null report", buf, 0xCu);
        }
      }
      else if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        char v12 = __nwlog_obj();
        os_log_type_t v15 = type;
        BOOL v16 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)int buf = 136446466;
            uint64_t v21 = "nw_activity_fill_out_activity_report";
            __int16 v22 = 2082;
            id v23 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null report, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_29;
        }
        if (v16)
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v21 = "nw_activity_fill_out_activity_report";
          _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null report, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        char v12 = __nwlog_obj();
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v21 = "nw_activity_fill_out_activity_report";
          _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null report, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_29:
    if (v11) {
      free(v11);
    }
    goto LABEL_12;
  }
  a2->domain = v3->domain;
  a2->label = v3->label;
  *(_OWORD *)a2->activity_uuuint64_t id = *(_OWORD *)v3->token;
  m_obj = v3->parent.m_obj;
  if (m_obj && !uuid_is_null(m_obj->token)) {
    *(_OWORD *)a2->parent_activity_uuuint64_t id = *(_OWORD *)v4->parent.m_obj->token;
  }
  *((unsigned char *)a2 + 304) = *((unsigned char *)a2 + 304) & 0xFE | *((unsigned char *)v4 + 140) & 1;
  a2->investigation_identifier = v4->investigation_identifier;
  if (nw_utilities_get_self_bundle_id::onceToken != -1) {
    dispatch_once(&nw_utilities_get_self_bundle_id::onceToken, &__block_literal_global_9);
  }
  uint64_t v6 = (unsigned __int8 *)nw_utilities_get_self_bundle_id::bundle_identifier_string;
  if (nw_utilities_get_self_bundle_id::bundle_identifier_string)
  {
    bundle_uint64_t id = a2->bundle_id;
    uint64_t v8 = 256;
    while (1)
    {
      int v9 = *v6;
      *bundle_uint64_t id = v9;
      if (!v9) {
        break;
      }
      ++bundle_id;
      ++v6;
      if ((unint64_t)--v8 <= 1)
      {
        *bundle_uint64_t id = 0;
        break;
      }
    }
  }
LABEL_12:
}

void sub_183498B84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_implementation_teardown(NWConcrete_nw_protocol_instance *a1)
{
  uint64_t v97 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    os_log_type_t v34 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    int v90 = "nw_protocol_implementation_teardown";
    id v35 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(p_paths_log_id_num) = 0;
    if (__nwlog_fault(v35, type, &p_paths_log_id_num))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v36 = __nwlog_obj();
        os_log_type_t v37 = type[0];
        if (os_log_type_enabled(v36, type[0]))
        {
          *(_DWORD *)int buf = 136446210;
          int v90 = "nw_protocol_implementation_teardown";
          _os_log_impl(&dword_1830D4000, v36, v37, "%{public}s called with null instance", buf, 0xCu);
        }
      }
      else if ((_BYTE)p_paths_log_id_num)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v36 = __nwlog_obj();
        os_log_type_t v39 = type[0];
        BOOL v40 = os_log_type_enabled(v36, type[0]);
        if (backtrace_string)
        {
          if (v40)
          {
            *(_DWORD *)int buf = 136446466;
            int v90 = "nw_protocol_implementation_teardown";
            __int16 v91 = 2082;
            int v92 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v36, v39, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_93;
        }
        if (v40)
        {
          *(_DWORD *)int buf = 136446210;
          int v90 = "nw_protocol_implementation_teardown";
          _os_log_impl(&dword_1830D4000, v36, v39, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v36 = __nwlog_obj();
        os_log_type_t v51 = type[0];
        if (os_log_type_enabled(v36, type[0]))
        {
          *(_DWORD *)int buf = 136446210;
          int v90 = "nw_protocol_implementation_teardown";
          _os_log_impl(&dword_1830D4000, v36, v51, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_93:
    if (v35) {
      free(v35);
    }
    goto LABEL_145;
  }
  char v3 = BYTE6(v1->flow_in_connected);
  BOOL v5 = (v1->flow_in_connected & 0x800000000000) != 0 || gLogDatapath == 0;
  if ((v1->flow_in_connected & 0x1000000000000) == 0)
  {
    if (!v5)
    {
      uint64_t v41 = __nwlog_obj();
      if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)int buf = 136446722;
        int v90 = "nw_protocol_implementation_teardown";
        __int16 v91 = 2082;
        int v92 = (char *)&v2->flow_in_connected + 7;
        __int16 v93 = 2080;
        int v94 = " ";
        _os_log_impl(&dword_1830D4000, v41, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sTearing down protocol", buf, 0x20u);
      }

      char v3 = BYTE6(v2->flow_in_connected);
    }
    BYTE6(v2->flow_in_connected) = v3 | 1;
    uint64_t internal_reference = (uint64_t)v2->internal_reference;
    if (internal_reference)
    {
      nw_queue_cancel_source(internal_reference);
      v2->uint64_t internal_reference = 0;
    }
    id v7 = *(void **)&v2->level;
    if (v7)
    {
      nw_protocol_instance_registrar_remove_instance(v7, (uint64_t)&v2[-1].paths_log_id_num);
      uint64_t v8 = *(void **)&v2->level;
      *(void *)&v2->level = 0;
    }
    var16 = (uint64_t (*)(NWConcrete_nw_protocol_instance *, uint64_t, uint64_t))v2->parent_definition->extended_state->var16;
    if (!var16 || (var16(v2, -1, 3) & 1) != 0) {
      goto LABEL_39;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v10 = (id)gLogObj;
    *(_DWORD *)int buf = 136446210;
    int v90 = "nw_protocol_implementation_teardown";
    id v11 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(p_paths_log_id_num) = 0;
    if (__nwlog_fault(v11, type, &p_paths_log_id_num))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v12 = (id)gLogObj;
        os_log_type_t v13 = type[0];
        if (os_log_type_enabled(v12, type[0]))
        {
          *(_DWORD *)int buf = 136446210;
          int v90 = "nw_protocol_implementation_teardown";
          _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s Cannot defer stop of NW_PROTOCOL_ALL_FLOWS", buf, 0xCu);
        }
      }
      else if ((_BYTE)p_paths_log_id_num)
      {
        os_log_type_t v15 = __nw_create_backtrace_string();
        if (v15)
        {
          BOOL v16 = (char *)v15;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v17 = (id)gLogObj;
          os_log_type_t v18 = type[0];
          if (os_log_type_enabled(v17, type[0]))
          {
            *(_DWORD *)int buf = 136446466;
            int v90 = "nw_protocol_implementation_teardown";
            __int16 v91 = 2082;
            int v92 = v16;
            _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s Cannot defer stop of NW_PROTOCOL_ALL_FLOWS, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v16);
          if (v11) {
            goto LABEL_38;
          }
          goto LABEL_39;
        }
        char v12 = __nwlog_obj();
        os_log_type_t v20 = type[0];
        if (os_log_type_enabled(v12, type[0]))
        {
          *(_DWORD *)int buf = 136446210;
          int v90 = "nw_protocol_implementation_teardown";
          _os_log_impl(&dword_1830D4000, v12, v20, "%{public}s Cannot defer stop of NW_PROTOCOL_ALL_FLOWS, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v12 = (id)gLogObj;
        os_log_type_t v19 = type[0];
        if (os_log_type_enabled(v12, type[0]))
        {
          *(_DWORD *)int buf = 136446210;
          int v90 = "nw_protocol_implementation_teardown";
          _os_log_impl(&dword_1830D4000, v12, v19, "%{public}s Cannot defer stop of NW_PROTOCOL_ALL_FLOWS, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    if (v11) {
LABEL_38:
    }
      free(v11);
LABEL_39:
    BYTE4(v2->flow_in_connected) |= 4u;
    nw_protocol_remove_instance((uint64_t)&v2[-1].paths_log_id_num);
    uint64_t v21 = v2;
    nw_array_apply((atomic_uchar *)v21->pending_outbound_frames.tqh_first, (uint64_t)&__block_literal_global_298);
    tqh_first = v21->pending_outbound_frames.tqh_first;
    v21->pending_outbound_frames.tqh_first = 0;

    id v23 = *(const char **)&v21[-1].log_str[25];
    if (!v23) {
      goto LABEL_133;
    }
    flow_registration = (char *)v21->flow_registration;
    if (flow_registration)
    {
      v81[0] = MEMORY[0x1E4F143A8];
      v81[1] = 3221225472;
      v81[2] = ___ZL35nw_protocol_implementation_teardownP31NWConcrete_nw_protocol_instance_block_invoke;
      v81[3] = &unk_1E524AF58;
      id v82 = v21;
      nw_hash_table_apply(flow_registration, (uint64_t)v81);

      id v23 = *(const char **)&v21[-1].log_str[25];
      if (!v23)
      {
LABEL_133:
        uint64_t v66 = *(void *)&v21->_anon_0[8];
        if (v66)
        {
          if (*(void *)v66)
          {
            os_log_type_t v67 = *(void (**)(uint64_t, unsigned __int16 *))(*(void *)v66 + 8);
            if (v67) {
              v67(v66, &v2[-1].paths_log_id_num);
            }
          }
          *(void *)&v21->_anon_0[8] = 0;
        }
        ((void (*)(NWConcrete_nw_protocol_instance *))v2->parent_definition->extended_state->var6)(v21);
        id v68 = nw_parameters_copy_context(v21->destroy_timer);
        nw_context_reset_timer_block_with_time(v68, (uint64_t)v21, -1, 0);

        new_flow_metadata = v21->new_flow_metadata;
        v21->new_flow_metadata = 0;

        BYTE4(v2->flow_in_connected) &= ~0x10u;
        uint64_t handle = (uint64_t)v21->handle;
        do
        {
          if (!handle) {
            break;
          }
          uint64_t v71 = *(void *)(handle + 16);
          char v72 = ___ZL35nw_protocol_implementation_teardownP31NWConcrete_nw_protocol_instance_block_invoke_292((uint64_t)&__block_literal_global_294, handle);
          uint64_t handle = v71;
        }
        while ((v72 & 1) != 0);
        uint64_t v73 = (uint64_t)v21->inbound_frames.tqh_first;
        do
        {
          if (!v73) {
            break;
          }
          uint64_t v74 = *(void *)(v73 + 16);
          char v75 = ___ZL35nw_protocol_implementation_teardownP31NWConcrete_nw_protocol_instance_block_invoke_2((uint64_t)&__block_literal_global_296, v73);
          uint64_t v73 = v74;
        }
        while ((v75 & 1) != 0);
        nw_protocol_implementation_destroy(v21);
        BYTE6(v2->flow_in_connected) &= ~1u;
        goto LABEL_145;
      }
    }
    char v25 = (void *)*((void *)v23 + 5);
    if (v25 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v27 = *((void *)v23 + 11);
      if (v27) {
        *((void *)v23 + 11) = v27 + 1;
      }
      char v26 = -1;
    }
    else
    {
      char v26 = 0;
    }
    *(void *)os_log_type_t type = v23;
    char v88 = v26;
    uint64_t v28 = *(void **)&v21[-1].log_str[33];
    if (v28 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v30 = *(void *)&v21[-1].log_str[81];
      if (v30) {
        *(void *)&v21[-1].log_str[81] = v30 + 1;
      }
      char v29 = -1;
    }
    else
    {
      char v29 = 0;
    }
    p_paths_log_id_num = &v2[-1].paths_log_id_num;
    char v86 = v29;
    uint64_t v31 = *((void *)v23 + 3);
    if (v31)
    {
      id v32 = *(uint64_t (**)(const char *, unsigned __int16 *, uint64_t))(v31 + 8);
      if (v32)
      {
        char v33 = v32(v23, &v2[-1].paths_log_id_num, 1);
        if (v28 != &nw_protocol_ref_counted_handle) {
          goto LABEL_55;
        }
        goto LABEL_108;
      }
    }
    id v42 = __nwlog_obj();
    os_log_type_t v43 = (const char *)*((void *)v23 + 2);
    *(_DWORD *)int buf = 136446722;
    int v90 = "__nw_protocol_remove_input_handler";
    if (!v43) {
      os_log_type_t v43 = "invalid";
    }
    __int16 v91 = 2082;
    int v92 = (char *)v43;
    __int16 v93 = 2048;
    int v94 = v23;
    os_log_type_t v44 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v84 = OS_LOG_TYPE_ERROR;
    char v83 = 0;
    if (__nwlog_fault(v44, &v84, &v83))
    {
      if (v84 == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v45 = __nwlog_obj();
        os_log_type_t v46 = v84;
        if (os_log_type_enabled(v45, v84))
        {
          BOOL v47 = (const char *)*((void *)v23 + 2);
          if (!v47) {
            BOOL v47 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          int v90 = "__nw_protocol_remove_input_handler";
          __int16 v91 = 2082;
          int v92 = (char *)v47;
          __int16 v93 = 2048;
          int v94 = v23;
          _os_log_impl(&dword_1830D4000, v45, v46, "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback", buf, 0x20u);
        }
LABEL_104:

        goto LABEL_105;
      }
      if (!v83)
      {
        os_log_type_t v45 = __nwlog_obj();
        os_log_type_t v52 = v84;
        if (os_log_type_enabled(v45, v84))
        {
          os_log_type_t v53 = (const char *)*((void *)v23 + 2);
          if (!v53) {
            os_log_type_t v53 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          int v90 = "__nw_protocol_remove_input_handler";
          __int16 v91 = 2082;
          int v92 = (char *)v53;
          __int16 v93 = 2048;
          int v94 = v23;
          _os_log_impl(&dword_1830D4000, v45, v52, "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, backtrace limit exceeded", buf, 0x20u);
        }
        goto LABEL_104;
      }
      os_log_type_t v48 = (char *)__nw_create_backtrace_string();
      os_log_type_t v45 = __nwlog_obj();
      os_log_type_t v80 = v84;
      BOOL v49 = os_log_type_enabled(v45, v84);
      if (!v48)
      {
        if (v49)
        {
          os_log_type_t v54 = (const char *)*((void *)v23 + 2);
          if (!v54) {
            os_log_type_t v54 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          int v90 = "__nw_protocol_remove_input_handler";
          __int16 v91 = 2082;
          int v92 = (char *)v54;
          __int16 v93 = 2048;
          int v94 = v23;
          _os_log_impl(&dword_1830D4000, v45, v80, "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, no backtrace", buf, 0x20u);
        }
        goto LABEL_104;
      }
      if (v49)
      {
        os_log_type_t v50 = (const char *)*((void *)v23 + 2);
        if (!v50) {
          os_log_type_t v50 = "invalid";
        }
        *(_DWORD *)int buf = 136446978;
        int v90 = "__nw_protocol_remove_input_handler";
        __int16 v91 = 2082;
        int v92 = (char *)v50;
        __int16 v93 = 2048;
        int v94 = v23;
        __int16 v95 = 2082;
        BOOL v96 = v48;
        _os_log_impl(&dword_1830D4000, v45, v80, "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }

      free(v48);
    }
LABEL_105:
    if (v44) {
      free(v44);
    }
    char v33 = 0;
    if (v28 != &nw_protocol_ref_counted_handle)
    {
LABEL_55:
      if (v25 != &nw_protocol_ref_counted_handle) {
        goto LABEL_56;
      }
      goto LABEL_109;
    }
LABEL_108:
    nw::release_if_needed<nw_protocol *>((uint64_t *)&p_paths_log_id_num);
    if (v25 != &nw_protocol_ref_counted_handle)
    {
LABEL_56:
      if (v33)
      {
LABEL_130:
        uint64_t v65 = *(void *)&v21[-1].log_str[25];
        if (v65)
        {
          if (*(_UNKNOWN **)(v65 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v76 = *(void *)(v65 + 88);
            if (v76)
            {
              uint64_t v77 = v76 - 1;
              *(void *)(v65 + 88) = v77;
              if (!v77)
              {
                BOOL v78 = *(void (***)(void))(v65 + 64);
                if (v78)
                {
                  *(void *)(v65 + 64) = 0;
                  v78[2](v78);
                  _Block_release(v78);
                }
                if (*(unsigned char *)(v65 + 72))
                {
                  int v79 = *(const void **)(v65 + 64);
                  if (v79) {
                    _Block_release(v79);
                  }
                }
                free((void *)v65);
              }
            }
          }
          *(void *)&v21[-1].log_str[25] = 0;
        }
        goto LABEL_133;
      }
LABEL_110:
      if (SBYTE5(v2->flow_in_connected) < 0) {
        goto LABEL_130;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v55 = (id)gLogObj;
      *(_DWORD *)int buf = 136446722;
      int v90 = "nw_protocol_implementation_teardown";
      __int16 v91 = 2082;
      int v92 = (char *)&v21->flow_in_connected + 7;
      __int16 v93 = 2080;
      int v94 = " ";
      BOOL v56 = (void *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(p_paths_log_id_num) = 0;
      if (__nwlog_fault((const char *)v56, type, &p_paths_log_id_num))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v57 = (id)gLogObj;
          os_log_type_t v58 = type[0];
          if (os_log_type_enabled(v57, type[0]))
          {
            *(_DWORD *)int buf = 136446722;
            int v90 = "nw_protocol_implementation_teardown";
            __int16 v91 = 2082;
            int v92 = (char *)&v21->flow_in_connected + 7;
            __int16 v93 = 2080;
            int v94 = " ";
            _os_log_impl(&dword_1830D4000, v57, v58, "%{public}s %{public}s%sUnable to remove output handler", buf, 0x20u);
          }
        }
        else if ((_BYTE)p_paths_log_id_num)
        {
          BOOL v59 = __nw_create_backtrace_string();
          if (v59)
          {
            uint64_t v60 = (char *)v59;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v61 = (id)gLogObj;
            os_log_type_t v62 = type[0];
            if (os_log_type_enabled(v61, type[0]))
            {
              *(_DWORD *)int buf = 136446978;
              int v90 = "nw_protocol_implementation_teardown";
              __int16 v91 = 2082;
              int v92 = (char *)&v21->flow_in_connected + 7;
              __int16 v93 = 2080;
              int v94 = " ";
              __int16 v95 = 2082;
              BOOL v96 = v60;
              _os_log_impl(&dword_1830D4000, v61, v62, "%{public}s %{public}s%sUnable to remove output handler, dumping backtrace:%{public}s", buf, 0x2Au);
            }

            free(v60);
            if (!v56) {
              goto LABEL_130;
            }
LABEL_129:
            free(v56);
            goto LABEL_130;
          }
          int v57 = __nwlog_obj();
          os_log_type_t v64 = type[0];
          if (os_log_type_enabled(v57, type[0]))
          {
            *(_DWORD *)int buf = 136446722;
            int v90 = "nw_protocol_implementation_teardown";
            __int16 v91 = 2082;
            int v92 = (char *)&v21->flow_in_connected + 7;
            __int16 v93 = 2080;
            int v94 = " ";
            _os_log_impl(&dword_1830D4000, v57, v64, "%{public}s %{public}s%sUnable to remove output handler, no backtrace", buf, 0x20u);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v57 = (id)gLogObj;
          os_log_type_t v63 = type[0];
          if (os_log_type_enabled(v57, type[0]))
          {
            *(_DWORD *)int buf = 136446722;
            int v90 = "nw_protocol_implementation_teardown";
            __int16 v91 = 2082;
            int v92 = (char *)&v21->flow_in_connected + 7;
            __int16 v93 = 2080;
            int v94 = " ";
            _os_log_impl(&dword_1830D4000, v57, v63, "%{public}s %{public}s%sUnable to remove output handler, backtrace limit exceeded", buf, 0x20u);
          }
        }
      }
      if (!v56) {
        goto LABEL_130;
      }
      goto LABEL_129;
    }
LABEL_109:
    nw::release_if_needed<nw_protocol *>((uint64_t *)type);
    if (v33) {
      goto LABEL_130;
    }
    goto LABEL_110;
  }
  if (!v5)
  {
    BOOL v14 = __nwlog_obj();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)int buf = 136446722;
      int v90 = "nw_protocol_implementation_teardown";
      __int16 v91 = 2082;
      int v92 = (char *)&v2->flow_in_connected + 7;
      __int16 v93 = 2080;
      int v94 = " ";
      _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sAlready tearing down protocol", buf, 0x20u);
    }
  }
LABEL_145:
}

void nw_ip_channel_inbox_input_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    unsigned int v4 = a1->handle;
    if (v4)
    {
      if (a2)
      {
        *(void *)os_log_type_t type = 0;
        uint64_t v41 = type;
        long long v44 = 0u;
        long long v45 = 0u;
        memset(buf, 0, sizeof(buf));
        while (((unsigned int (*)(nw_protocol *, nw_protocol *, uint64_t, uint64_t, uint64_t, os_log_type_t *))a2->callbacks->get_input_frames)(a2, a1, 1, 0xFFFFFFFFLL, 0xFFFFFFFFLL, type))
        {
          BOOL v5 = nw_array_create();
          v32[0] = MEMORY[0x1E4F143A8];
          v32[1] = 3221225472;
          char v33 = ___ZL35nw_ip_channel_inbox_input_availableP11nw_protocolS0__block_invoke;
          os_log_type_t v34 = &unk_1E5243FF8;
          os_log_type_t v37 = type;
          id v35 = v4;
          id v38 = a2;
          id v6 = (id)v5;
          id v36 = v6;
          os_log_type_t v39 = buf;
          uint64_t v7 = *(void *)type;
          do
          {
            if (!v7) {
              break;
            }
            uint64_t v8 = *(void *)(v7 + 32);
            char v9 = ((uint64_t (*)(void *))v33)(v32);
            uint64_t v7 = v8;
          }
          while ((v9 & 1) != 0);
        }
        goto LABEL_63;
      }
      os_log_type_t v18 = __nwlog_obj();
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_input_available";
      os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      char v42 = 0;
      if (__nwlog_fault(v15, type, &v42))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          BOOL v16 = __nwlog_obj();
          os_log_type_t v19 = type[0];
          if (os_log_type_enabled(v16, type[0]))
          {
            *(_DWORD *)int buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_input_available";
            _os_log_impl(&dword_1830D4000, v16, v19, "%{public}s called with null from", buf, 0xCu);
          }
        }
        else if (v42)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          BOOL v16 = __nwlog_obj();
          os_log_type_t v27 = type[0];
          BOOL v28 = os_log_type_enabled(v16, type[0]);
          if (backtrace_string)
          {
            if (v28)
            {
              *(_DWORD *)int buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_input_available";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = backtrace_string;
              _os_log_impl(&dword_1830D4000, v16, v27, "%{public}s called with null from, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            if (!v15) {
              goto LABEL_63;
            }
            goto LABEL_62;
          }
          if (v28)
          {
            *(_DWORD *)int buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_input_available";
            _os_log_impl(&dword_1830D4000, v16, v27, "%{public}s called with null from, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          BOOL v16 = __nwlog_obj();
          os_log_type_t v31 = type[0];
          if (os_log_type_enabled(v16, type[0]))
          {
            *(_DWORD *)int buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_input_available";
            _os_log_impl(&dword_1830D4000, v16, v31, "%{public}s called with null from, backtrace limit exceeded", buf, 0xCu);
          }
        }
        goto LABEL_60;
      }
LABEL_61:
      if (!v15)
      {
LABEL_63:

        return;
      }
LABEL_62:
      free(v15);
      goto LABEL_63;
    }
    BOOL v14 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_input_available";
    os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (!__nwlog_fault(v15, type, &v42)) {
      goto LABEL_61;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      BOOL v16 = __nwlog_obj();
      os_log_type_t v17 = type[0];
      if (os_log_type_enabled(v16, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_input_available";
        _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s called with null inbox", buf, 0xCu);
      }
    }
    else if (v42)
    {
      id v23 = (char *)__nw_create_backtrace_string();
      BOOL v16 = __nwlog_obj();
      os_log_type_t v24 = type[0];
      BOOL v25 = os_log_type_enabled(v16, type[0]);
      if (v23)
      {
        if (v25)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_input_available";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v23;
          _os_log_impl(&dword_1830D4000, v16, v24, "%{public}s called with null inbox, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v23);
        goto LABEL_61;
      }
      if (v25)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_input_available";
        _os_log_impl(&dword_1830D4000, v16, v24, "%{public}s called with null inbox, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v16 = __nwlog_obj();
      os_log_type_t v30 = type[0];
      if (os_log_type_enabled(v16, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_input_available";
        _os_log_impl(&dword_1830D4000, v16, v30, "%{public}s called with null inbox, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_60:

    goto LABEL_61;
  }
  id v10 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_input_available";
  id v11 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  char v42 = 0;
  if (__nwlog_fault(v11, type, &v42))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      char v12 = __nwlog_obj();
      os_log_type_t v13 = type[0];
      if (os_log_type_enabled(v12, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_input_available";
        _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null to", buf, 0xCu);
      }
    }
    else if (v42)
    {
      os_log_type_t v20 = (char *)__nw_create_backtrace_string();
      char v12 = __nwlog_obj();
      os_log_type_t v21 = type[0];
      BOOL v22 = os_log_type_enabled(v12, type[0]);
      if (v20)
      {
        if (v22)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_input_available";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v20;
          _os_log_impl(&dword_1830D4000, v12, v21, "%{public}s called with null to, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v20);
        goto LABEL_53;
      }
      if (v22)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_input_available";
        _os_log_impl(&dword_1830D4000, v12, v21, "%{public}s called with null to, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      char v12 = __nwlog_obj();
      os_log_type_t v29 = type[0];
      if (os_log_type_enabled(v12, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_input_available";
        _os_log_impl(&dword_1830D4000, v12, v29, "%{public}s called with null to, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_53:
  if (v11) {
    free(v11);
  }
}

void sub_18349A34C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_context_timer_object_matches_key(void *a1, const void *a2)
{
  return a1[3] == (void)a2;
}

void nw_resolver_deallocate_cache_entry(uint64_t a1, void **a2)
{
  char v3 = *a2;
  *a2 = 0;

  unsigned int v4 = a2[1];
  a2[1] = 0;

  BOOL v5 = a2[2];
  a2[2] = 0;

  free(a2);
}

void nw_protocol_implementation_destroy(NWConcrete_nw_protocol_instance *a1)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    os_log_type_t v20 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_implementation_destroy";
    os_log_type_t v21 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (__nwlog_fault(v21, type, &v29))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        BOOL v22 = __nwlog_obj();
        os_log_type_t v23 = type[0];
        if (os_log_type_enabled(v22, type[0]))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_destroy";
          _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s called with null instance", buf, 0xCu);
        }
      }
      else if (v29)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v22 = __nwlog_obj();
        os_log_type_t v25 = type[0];
        BOOL v26 = os_log_type_enabled(v22, type[0]);
        if (backtrace_string)
        {
          if (v26)
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_destroy";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v22, v25, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_45;
        }
        if (v26)
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_destroy";
          _os_log_impl(&dword_1830D4000, v22, v25, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        BOOL v22 = __nwlog_obj();
        os_log_type_t v28 = type[0];
        if (os_log_type_enabled(v22, type[0]))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_destroy";
          _os_log_impl(&dword_1830D4000, v22, v28, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_45:
    if (v21) {
      free(v21);
    }
    goto LABEL_25;
  }
  char v3 = v1;
  unsigned int v4 = v3;
  tqh_last = v3->pending_outbound_frames.tqh_last;
  if (tqh_last)
  {
    int v6 = *((_DWORD *)tqh_last + 10);

    if (v6)
    {
LABEL_8:
      BYTE4(v4->flow_in_connected) |= 8u;
      if ((SBYTE5(v4->flow_in_connected) & 0x80000000) == 0 && gLogDatapath)
      {
        id v10 = __nwlog_obj();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)int buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_destroy";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = (char *)&v4->flow_in_connected + 7;
          *(_WORD *)&unsigned char buf[22] = 2080;
          id v35 = " ";
          _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sDeferring destroying protocol", buf, 0x20u);
        }
      }
LABEL_25:

      return;
    }
  }
  else
  {
  }
  uint64_t v7 = v4;
  *(void *)os_log_type_t type = 0;
  os_log_type_t v31 = type;
  uint64_t v32 = 0x2020000000;
  char v33 = 0;
  flow_registration = (char *)v7->flow_registration;
  if (flow_registration)
  {
    *(void *)int buf = MEMORY[0x1E4F143A8];
    *(void *)&buf[8] = 3221225472;
    *(void *)&buf[16] = ___ZL43nw_protocol_implementation_has_active_pathsP31NWConcrete_nw_protocol_instance_block_invoke;
    id v35 = (const char *)&unk_1E523BE48;
    id v36 = type;
    nw_hash_table_apply(flow_registration, (uint64_t)buf);
    BOOL v9 = *((unsigned char *)v31 + 24) == 0;
    _Block_object_dispose(type, 8);

    if (!v9) {
      goto LABEL_8;
    }
  }
  else
  {
    _Block_object_dispose(type, 8);
  }
  id v11 = *(char **)v7->_anon_0;
  if (v11 == (char *)v7)
  {
LABEL_17:
    if ((SBYTE5(v7->flow_in_connected) & 0x80000000) == 0 && gLogDatapath)
    {
      os_log_type_t v27 = __nwlog_obj();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)int buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_destroy";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = (char *)&v7->flow_in_connected + 7;
        *(_WORD *)&unsigned char buf[22] = 2080;
        id v35 = " ";
        _os_log_impl(&dword_1830D4000, v27, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sDestroying protocol", buf, 0x20u);
      }
    }
    maximum_content_size_t size = v7->maximum_content_size;
    if (maximum_content_size)
    {
      parent_definition = v7->parent_definition;
      var1 = (void (*)(NWConcrete_nw_protocol_definition *, unint64_t))parent_definition->extended_state->var1;
      if (var1)
      {
        var1(parent_definition, maximum_content_size);
        v7->maximum_content_size_t size = 0;
      }
    }
    parameters = v7->parameters;
    if (parameters)
    {
      nw_association_unregister(parameters, v7);
      os_log_type_t v18 = v7->parameters;
      v7->parameters = 0;
    }
    id wakeup = v7->wakeup;
    v7->id wakeup = 0;

    *(void *)v7->_anon_0 = 0;
    BYTE4(v7->flow_in_connected) &= ~8u;
    nw_protocol_destroy((uint64_t)v7, 0);
    goto LABEL_25;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  char v12 = (id)gLogObj;
  os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
  *(_DWORD *)int buf = 136446722;
  *(void *)&uint8_t buf[4] = "nw_protocol_implementation_destroy";
  *(_WORD *)&unsigned char buf[12] = 2048;
  *(void *)&buf[14] = v11;
  *(_WORD *)&unsigned char buf[22] = 2048;
  id v35 = (const char *)v7;
  os_log_type_t v13 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v13))
  {
    free(v13);
    goto LABEL_17;
  }
  __break(1u);
}

void sub_18349A994(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_http3_stream_connected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v106 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v93 = "nw_protocol_http3_stream_connected";
    BOOL v47 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v90 = 0;
    if (!__nwlog_fault(v47, &type, &v90)) {
      goto LABEL_121;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v48 = __nwlog_obj();
      os_log_type_t v49 = type;
      if (!os_log_type_enabled(v48, type)) {
        goto LABEL_121;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v93 = "nw_protocol_http3_stream_connected";
      os_log_type_t v50 = "%{public}s called with null protocol";
      goto LABEL_120;
    }
    if (!v90)
    {
      os_log_type_t v48 = __nwlog_obj();
      os_log_type_t v49 = type;
      if (!os_log_type_enabled(v48, type)) {
        goto LABEL_121;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v93 = "nw_protocol_http3_stream_connected";
      os_log_type_t v50 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_120;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v48 = __nwlog_obj();
    os_log_type_t v49 = type;
    BOOL v68 = os_log_type_enabled(v48, type);
    if (!backtrace_string)
    {
      if (!v68) {
        goto LABEL_121;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v93 = "nw_protocol_http3_stream_connected";
      os_log_type_t v50 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_120;
    }
    if (v68)
    {
      *(_DWORD *)int buf = 136446466;
      __int16 v93 = "nw_protocol_http3_stream_connected";
      __int16 v94 = 2082;
      __int16 v95 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v48, v49, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_121:
    if (!v47) {
      return;
    }
    goto LABEL_122;
  }
  uint64_t handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v93 = "nw_protocol_http3_stream_connected";
    BOOL v47 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v90 = 0;
    if (!__nwlog_fault(v47, &type, &v90)) {
      goto LABEL_121;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v48 = __nwlog_obj();
      os_log_type_t v49 = type;
      if (!os_log_type_enabled(v48, type)) {
        goto LABEL_121;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v93 = "nw_protocol_http3_stream_connected";
      os_log_type_t v50 = "%{public}s called with null http3_stream";
      goto LABEL_120;
    }
    if (!v90)
    {
      os_log_type_t v48 = __nwlog_obj();
      os_log_type_t v49 = type;
      if (!os_log_type_enabled(v48, type)) {
        goto LABEL_121;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v93 = "nw_protocol_http3_stream_connected";
      os_log_type_t v50 = "%{public}s called with null http3_stream, backtrace limit exceeded";
      goto LABEL_120;
    }
    id v69 = (char *)__nw_create_backtrace_string();
    os_log_type_t v48 = __nwlog_obj();
    os_log_type_t v49 = type;
    BOOL v70 = os_log_type_enabled(v48, type);
    if (v69)
    {
      if (v70)
      {
        *(_DWORD *)int buf = 136446466;
        __int16 v93 = "nw_protocol_http3_stream_connected";
        __int16 v94 = 2082;
        __int16 v95 = v69;
        _os_log_impl(&dword_1830D4000, v48, v49, "%{public}s called with null http3_stream, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v69);
      if (!v47) {
        return;
      }
LABEL_122:
      free(v47);
      return;
    }
    if (v70)
    {
      *(_DWORD *)int buf = 136446210;
      __int16 v93 = "nw_protocol_http3_stream_connected";
      os_log_type_t v50 = "%{public}s called with null http3_stream, no backtrace";
LABEL_120:
      _os_log_impl(&dword_1830D4000, v48, v49, v50, buf, 0xCu);
      goto LABEL_121;
    }
    goto LABEL_121;
  }
  if ((*((_WORD *)handle + 368) & 0x800) == 0)
  {
    if (gLogDatapath)
    {
      os_log_type_t v51 = __nwlog_obj();
      if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
      {
        int v52 = *(_DWORD *)(*((void *)handle + 42) + 1280);
        os_log_type_t v53 = (nw_protocol *)*((void *)handle + 30);
        *(_DWORD *)int buf = 136447234;
        __int16 v93 = "nw_protocol_http3_stream_connected";
        __int16 v94 = 2082;
        __int16 v95 = handle + 636;
        __int16 v96 = 2080;
        uint64_t v97 = " ";
        __int16 v98 = 1024;
        int v99 = v52;
        __int16 v100 = 2048;
        __int16 v101 = v53;
        _os_log_impl(&dword_1830D4000, v51, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> Got a connected event from the lower layer", buf, 0x30u);
      }
    }
  }
  default_input_handler = a1->default_input_handler;
  if (default_input_handler)
  {
    callbacks = default_input_handler->callbacks;
    if (callbacks)
    {
      connected = (void (*)(void))callbacks->connected;
      if (connected)
      {
        connected();
        goto LABEL_9;
      }
    }
  }
  __nwlog_obj();
  uint64_t v32 = a1->default_input_handler;
  char v33 = "invalid";
  if (v32)
  {
    identifier = v32->identifier;
    if (identifier) {
      char v33 = (const char *)identifier;
    }
  }
  *(_DWORD *)int buf = 136446466;
  __int16 v93 = "nw_protocol_http3_stream_connected";
  __int16 v94 = 2082;
  __int16 v95 = (char *)v33;
  id v35 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v90 = 0;
  if (__nwlog_fault(v35, &type, &v90))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v36 = __nwlog_obj();
      os_log_type_t v37 = type;
      if (!os_log_type_enabled(v36, type)) {
        goto LABEL_100;
      }
      id v38 = a1->default_input_handler;
      os_log_type_t v39 = "invalid";
      if (v38)
      {
        BOOL v40 = v38->identifier;
        if (v40) {
          os_log_type_t v39 = (const char *)v40;
        }
      }
      *(_DWORD *)int buf = 136446466;
      __int16 v93 = "nw_protocol_http3_stream_connected";
      __int16 v94 = 2082;
      __int16 v95 = (char *)v39;
      uint64_t v41 = "%{public}s protocol %{public}s has invalid connected callback";
      goto LABEL_99;
    }
    if (!v90)
    {
      id v36 = __nwlog_obj();
      os_log_type_t v37 = type;
      if (!os_log_type_enabled(v36, type)) {
        goto LABEL_100;
      }
      os_log_type_t v54 = a1->default_input_handler;
      id v55 = "invalid";
      if (v54)
      {
        BOOL v56 = v54->identifier;
        if (v56) {
          id v55 = (const char *)v56;
        }
      }
      *(_DWORD *)int buf = 136446466;
      __int16 v93 = "nw_protocol_http3_stream_connected";
      __int16 v94 = 2082;
      __int16 v95 = (char *)v55;
      uint64_t v41 = "%{public}s protocol %{public}s has invalid connected callback, backtrace limit exceeded";
      goto LABEL_99;
    }
    char v42 = (char *)__nw_create_backtrace_string();
    id v36 = __nwlog_obj();
    os_log_type_t v37 = type;
    BOOL v43 = os_log_type_enabled(v36, type);
    if (v42)
    {
      if (v43)
      {
        long long v44 = a1->default_input_handler;
        long long v45 = "invalid";
        if (v44)
        {
          uint64_t v46 = v44->identifier;
          if (v46) {
            long long v45 = (const char *)v46;
          }
        }
        *(_DWORD *)int buf = 136446722;
        __int16 v93 = "nw_protocol_http3_stream_connected";
        __int16 v94 = 2082;
        __int16 v95 = (char *)v45;
        __int16 v96 = 2082;
        uint64_t v97 = v42;
        _os_log_impl(&dword_1830D4000, v36, v37, "%{public}s protocol %{public}s has invalid connected callback, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(v42);
      goto LABEL_100;
    }
    if (v43)
    {
      uint64_t v71 = a1->default_input_handler;
      char v72 = "invalid";
      if (v71)
      {
        uint64_t v73 = v71->identifier;
        if (v73) {
          char v72 = (const char *)v73;
        }
      }
      *(_DWORD *)int buf = 136446466;
      __int16 v93 = "nw_protocol_http3_stream_connected";
      __int16 v94 = 2082;
      __int16 v95 = (char *)v72;
      uint64_t v41 = "%{public}s protocol %{public}s has invalid connected callback, no backtrace";
LABEL_99:
      _os_log_impl(&dword_1830D4000, v36, v37, v41, buf, 0x16u);
    }
  }
LABEL_100:
  if (v35) {
    free(v35);
  }
LABEL_9:
  uint64_t v8 = handle + 736;
  if (a1->output_handler != a2)
  {
    if ((*v8 & 0x800) == 0)
    {
      if (gLogDatapath)
      {
        BOOL v9 = __nwlog_obj();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
        {
          int v10 = *(_DWORD *)(*((void *)handle + 42) + 1280);
          id v11 = (nw_protocol *)*((void *)handle + 30);
          uint64_t output_handler = a1->output_handler;
          *(_DWORD *)int buf = 136447490;
          __int16 v93 = "nw_protocol_http3_stream_connected";
          __int16 v94 = 2082;
          __int16 v95 = handle + 636;
          __int16 v96 = 2080;
          uint64_t v97 = " ";
          __int16 v98 = 1024;
          int v99 = v10;
          __int16 v100 = 2048;
          __int16 v101 = v11;
          __int16 v102 = 2048;
          __int16 v103 = output_handler;
          os_log_type_t v13 = "%{public}s %{public}s%s<i%u:s%llu> connected protocol is not our output_handler (%p), ignoring";
          BOOL v14 = v9;
LABEL_14:
          _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_DEBUG, v13, buf, 0x3Au);
          return;
        }
      }
    }
    return;
  }
  if (a2)
  {
    if (!*((void *)handle + 52))
    {
      os_log_type_t v15 = a2->callbacks;
      if (v15)
      {
        copy_info = (uint64_t (*)(nw_protocol *, uint64_t, char *))v15->copy_info;
        if (copy_info)
        {
          os_log_type_t v17 = (atomic_uchar *)copy_info(a2, 255, handle);
          v89[0] = MEMORY[0x1E4F143A8];
          v89[1] = 0x40000000;
          v89[2] = ___ZL34nw_protocol_http3_stream_connectedP11nw_protocolS0__block_invoke;
          v89[3] = &__block_descriptor_tmp_139;
          v89[4] = handle;
          nw_array_apply(v17, (uint64_t)v89);
          if (v17) {
            os_release(v17);
          }
        }
      }
    }
  }
  if (!a1->default_input_handler)
  {
    if ((*v8 & 0x800) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v24 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        int v25 = *(_DWORD *)(*((void *)handle + 42) + 1280);
        BOOL v26 = (nw_protocol *)*((void *)handle + 30);
        *(_DWORD *)int buf = 136447234;
        __int16 v93 = "nw_protocol_http3_stream_connected";
        __int16 v94 = 2082;
        __int16 v95 = handle + 636;
        __int16 v96 = 2080;
        uint64_t v97 = " ";
        __int16 v98 = 1024;
        int v99 = v25;
        __int16 v100 = 2048;
        __int16 v101 = v26;
        _os_log_impl(&dword_1830D4000, v24, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%llu> No input handler found, ignoring connected call", buf, 0x30u);
      }
    }
    return;
  }
  if ((*v8 & 0x800) == 0)
  {
    if (gLogDatapath)
    {
      int v79 = __nwlog_obj();
      if (os_log_type_enabled(v79, OS_LOG_TYPE_DEBUG))
      {
        int v80 = *(_DWORD *)(*((void *)handle + 42) + 1280);
        __int16 v81 = (nw_protocol *)*((void *)handle + 30);
        *(_DWORD *)int buf = 136447746;
        __int16 v93 = "nw_protocol_http3_stream_connected";
        __int16 v94 = 2082;
        __int16 v95 = handle + 636;
        __int16 v96 = 2080;
        uint64_t v97 = " ";
        __int16 v98 = 1024;
        int v99 = v80;
        __int16 v100 = 2048;
        __int16 v101 = v81;
        __int16 v102 = 2048;
        __int16 v103 = a1;
        __int16 v104 = 2048;
        int v105 = a2;
        _os_log_impl(&dword_1830D4000, v79, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> http3 stream %p connected with output_handler %p", buf, 0x44u);
      }
    }
  }
  uint64_t v18 = *((void *)handle + 42);
  if (!v18)
  {
    int v20 = (unsigned __int16)*v8 | (handle[738] << 16);
    goto LABEL_34;
  }
  int v19 = *(_DWORD *)(v18 + 1272);
  int v20 = (unsigned __int16)*v8 | (handle[738] << 16);
  if (v19)
  {
LABEL_34:
    _WORD *v8 = v20;
    handle[738] = (v20 | 0x80000u) >> 16;
    os_log_type_t v27 = (void *)*((void *)handle + 49);
    v88[0] = MEMORY[0x1E4F143A8];
    v88[1] = 0x40000000;
    v88[2] = ___ZL34nw_protocol_http3_stream_connectedP11nw_protocolS0__block_invoke_140;
    v88[3] = &__block_descriptor_tmp_148_63062;
    v88[4] = handle;
    nw_http_transaction_metadata_set_event_handler(v27, v88);
    int v28 = *((_WORD *)handle + 368) & 0xFF7F | (handle[738] << 16);
    _WORD *v8 = *v8 & 0xFF3F | 0x40;
    handle[738] = BYTE2(v28);
    nw_http3_signal_output_pending(*((void *)handle + 42), 1);
    char v29 = a1->default_input_handler;
    if (v29)
    {
      os_log_type_t v30 = v29->callbacks;
      if (v30)
      {
        os_log_type_t v31 = (void (*)(nw_protocol *, nw_protocol *))v30->connected;
        if (v31)
        {
          v31(v29, a1);
LABEL_38:
          nw_http3_signal_output_pending(*((void *)handle + 42), 0);
          return;
        }
      }
    }
    __nwlog_obj();
    int v57 = a1->default_input_handler;
    os_log_type_t v58 = "invalid";
    if (v57)
    {
      BOOL v59 = v57->identifier;
      if (v59) {
        os_log_type_t v58 = (const char *)v59;
      }
    }
    *(_DWORD *)int buf = 136446466;
    __int16 v93 = "nw_protocol_http3_stream_connected";
    __int16 v94 = 2082;
    __int16 v95 = (char *)v58;
    uint64_t v60 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v90 = 0;
    if (__nwlog_fault(v60, &type, &v90))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v61 = __nwlog_obj();
        os_log_type_t v62 = type;
        if (!os_log_type_enabled(v61, type)) {
          goto LABEL_134;
        }
        os_log_type_t v63 = a1->default_input_handler;
        os_log_type_t v64 = "invalid";
        if (v63)
        {
          uint64_t v65 = v63->identifier;
          if (v65) {
            os_log_type_t v64 = (const char *)v65;
          }
        }
        *(_DWORD *)int buf = 136446466;
        __int16 v93 = "nw_protocol_http3_stream_connected";
        __int16 v94 = 2082;
        __int16 v95 = (char *)v64;
        uint64_t v66 = "%{public}s protocol %{public}s has invalid connected callback";
        goto LABEL_133;
      }
      if (!v90)
      {
        id v61 = __nwlog_obj();
        os_log_type_t v62 = type;
        if (!os_log_type_enabled(v61, type)) {
          goto LABEL_134;
        }
        id v82 = a1->default_input_handler;
        char v83 = "invalid";
        if (v82)
        {
          os_log_type_t v84 = v82->identifier;
          if (v84) {
            char v83 = (const char *)v84;
          }
        }
        *(_DWORD *)int buf = 136446466;
        __int16 v93 = "nw_protocol_http3_stream_connected";
        __int16 v94 = 2082;
        __int16 v95 = (char *)v83;
        uint64_t v66 = "%{public}s protocol %{public}s has invalid connected callback, backtrace limit exceeded";
        goto LABEL_133;
      }
      uint64_t v74 = (char *)__nw_create_backtrace_string();
      id v61 = __nwlog_obj();
      os_log_type_t v62 = type;
      BOOL v75 = os_log_type_enabled(v61, type);
      if (v74)
      {
        if (v75)
        {
          uint64_t v76 = a1->default_input_handler;
          uint64_t v77 = "invalid";
          if (v76)
          {
            BOOL v78 = v76->identifier;
            if (v78) {
              uint64_t v77 = (const char *)v78;
            }
          }
          *(_DWORD *)int buf = 136446722;
          __int16 v93 = "nw_protocol_http3_stream_connected";
          __int16 v94 = 2082;
          __int16 v95 = (char *)v77;
          __int16 v96 = 2082;
          uint64_t v97 = v74;
          _os_log_impl(&dword_1830D4000, v61, v62, "%{public}s protocol %{public}s has invalid connected callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v74);
        goto LABEL_134;
      }
      if (v75)
      {
        __int16 v85 = a1->default_input_handler;
        char v86 = "invalid";
        if (v85)
        {
          int v87 = v85->identifier;
          if (v87) {
            char v86 = (const char *)v87;
          }
        }
        *(_DWORD *)int buf = 136446466;
        __int16 v93 = "nw_protocol_http3_stream_connected";
        __int16 v94 = 2082;
        __int16 v95 = (char *)v86;
        uint64_t v66 = "%{public}s protocol %{public}s has invalid connected callback, no backtrace";
LABEL_133:
        _os_log_impl(&dword_1830D4000, v61, v62, v66, buf, 0x16u);
      }
    }
LABEL_134:
    if (v60) {
      free(v60);
    }
    goto LABEL_38;
  }
  handle[738] = BYTE2(v20);
  _WORD *v8 = v20 | 0x80;
  if ((v20 & 0x800) == 0)
  {
    if (gLogDatapath)
    {
      os_log_type_t v21 = __nwlog_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
      {
        int v22 = *(_DWORD *)(*((void *)handle + 42) + 1280);
        os_log_type_t v23 = (nw_protocol *)*((void *)handle + 30);
        *(_DWORD *)int buf = 136447490;
        __int16 v93 = "nw_protocol_http3_stream_connected";
        __int16 v94 = 2082;
        __int16 v95 = handle + 636;
        __int16 v96 = 2080;
        uint64_t v97 = " ";
        __int16 v98 = 1024;
        int v99 = v22;
        __int16 v100 = 2048;
        __int16 v101 = v23;
        __int16 v102 = 2048;
        __int16 v103 = v23;
        os_log_type_t v13 = "%{public}s %{public}s%s<i%u:s%llu> Pending connected event for stream %llu until SETTINGS are sent";
        BOOL v14 = v21;
        goto LABEL_14;
      }
    }
  }
}

void nw_protocol_shoes_input_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v93 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v85 = "nw_protocol_shoes_input_available";
    BOOL v68 = (char *)_os_log_send_and_compose_impl();
    v80[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v68, v80, &type)) {
      goto LABEL_155;
    }
    if (v80[0] == OS_LOG_TYPE_FAULT)
    {
      id v69 = __nwlog_obj();
      os_log_type_t v70 = v80[0];
      if (!os_log_type_enabled(v69, v80[0])) {
        goto LABEL_155;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v85 = "nw_protocol_shoes_input_available";
      uint64_t v71 = "%{public}s called with null protocol";
      goto LABEL_154;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      id v69 = __nwlog_obj();
      os_log_type_t v70 = v80[0];
      if (!os_log_type_enabled(v69, v80[0])) {
        goto LABEL_155;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v85 = "nw_protocol_shoes_input_available";
      uint64_t v71 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_154;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    id v69 = __nwlog_obj();
    os_log_type_t v70 = v80[0];
    BOOL v73 = os_log_type_enabled(v69, v80[0]);
    if (!backtrace_string)
    {
      if (!v73) {
        goto LABEL_155;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v85 = "nw_protocol_shoes_input_available";
      uint64_t v71 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_154;
    }
    if (v73)
    {
      *(_DWORD *)int buf = 136446466;
      __int16 v85 = "nw_protocol_shoes_input_available";
      __int16 v86 = 2082;
      int v87 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v69, v70, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_155:
    if (!v68) {
      return;
    }
    goto LABEL_156;
  }
  uint64_t handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v85 = "nw_protocol_shoes_input_available";
    BOOL v68 = (char *)_os_log_send_and_compose_impl();
    v80[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v68, v80, &type)) {
      goto LABEL_155;
    }
    if (v80[0] == OS_LOG_TYPE_FAULT)
    {
      id v69 = __nwlog_obj();
      os_log_type_t v70 = v80[0];
      if (!os_log_type_enabled(v69, v80[0])) {
        goto LABEL_155;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v85 = "nw_protocol_shoes_input_available";
      uint64_t v71 = "%{public}s called with null shoes";
      goto LABEL_154;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      id v69 = __nwlog_obj();
      os_log_type_t v70 = v80[0];
      if (!os_log_type_enabled(v69, v80[0])) {
        goto LABEL_155;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v85 = "nw_protocol_shoes_input_available";
      uint64_t v71 = "%{public}s called with null shoes, backtrace limit exceeded";
      goto LABEL_154;
    }
    uint64_t v74 = (char *)__nw_create_backtrace_string();
    id v69 = __nwlog_obj();
    os_log_type_t v70 = v80[0];
    BOOL v75 = os_log_type_enabled(v69, v80[0]);
    if (v74)
    {
      if (v75)
      {
        *(_DWORD *)int buf = 136446466;
        __int16 v85 = "nw_protocol_shoes_input_available";
        __int16 v86 = 2082;
        int v87 = v74;
        _os_log_impl(&dword_1830D4000, v69, v70, "%{public}s called with null shoes, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v74);
      if (!v68) {
        return;
      }
LABEL_156:
      free(v68);
      return;
    }
    if (v75)
    {
      *(_DWORD *)int buf = 136446210;
      __int16 v85 = "nw_protocol_shoes_input_available";
      uint64_t v71 = "%{public}s called with null shoes, no backtrace";
LABEL_154:
      _os_log_impl(&dword_1830D4000, v69, v70, v71, buf, 0xCu);
      goto LABEL_155;
    }
    goto LABEL_155;
  }
  default_input_handler = a1->default_input_handler;
  if (!default_input_handler)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v6 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446466;
      __int16 v85 = "nw_protocol_shoes_input_available";
      __int16 v86 = 2082;
      int v87 = handle + 151;
      uint64_t v7 = "%{public}s %{public}s No input handler";
      uint64_t v8 = v6;
LABEL_93:
      os_log_type_t v56 = OS_LOG_TYPE_ERROR;
LABEL_94:
      uint32_t v57 = 22;
LABEL_95:
      _os_log_impl(&dword_1830D4000, v8, v56, v7, buf, v57);
    }
    return;
  }
  if (handle[150] == 6)
  {
    input_available = (void (*)(void))default_input_handler->callbacks->input_available;
    input_available();
    return;
  }
  uint64_t output_handler = a1->output_handler;
  *(void *)int v80 = 0;
  __int16 v81 = v80;
  if (((unsigned int (*)(void))output_handler->callbacks->get_input_frames)())
  {
    uint64_t v10 = *(void *)v80;
    if (*(void *)v80)
    {
      do
      {
        char v12 = (void *)(v10 + 32);
        uint64_t v13 = *(void *)(v10 + 32);
        if (v13 || *(void *)(v10 + 40))
        {
          if (!*(void *)(v10 + 112)) {
            goto LABEL_26;
          }
        }
        else
        {
          uint64_t v13 = 0;
          if (!*(void *)(v10 + 112)) {
            goto LABEL_26;
          }
        }
        if ((*(_WORD *)(v10 + 204) & 0x100) == 0
          || !g_channel_check_validity
          || g_channel_check_validity(v10, *(void *)(v10 + 88)))
        {
          int v15 = *(_DWORD *)(v10 + 52);
          uint64_t v14 = *(unsigned int *)(v10 + 56);
          if (v15) {
            int v16 = v15 - (v14 + *(_DWORD *)(v10 + 60));
          }
          else {
            int v16 = 0;
          }
          uint64_t v17 = *(void *)(v10 + 112) + v14;
          goto LABEL_27;
        }
LABEL_26:
        int v16 = 0;
        uint64_t v17 = 0;
LABEL_27:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v18 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)int buf = 136446978;
          __int16 v85 = "nw_protocol_shoes_input_available";
          __int16 v86 = 2082;
          int v87 = handle + 151;
          __int16 v88 = 1024;
          int v89 = v16;
          __int16 v90 = 2048;
          *(void *)__int16 v91 = v17;
          _os_log_impl(&dword_1830D4000, v18, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Read frame has %u bytes (%p)", buf, 0x26u);
        }
        uint64_t v19 = *(void *)(v10 + 32);
        int v20 = *(void **)(v10 + 40);
        if (v19)
        {
          *(void *)(v19 + 40) = v20;
          int v20 = *(void **)(v10 + 40);
        }
        else
        {
          __int16 v81 = *(os_log_type_t **)(v10 + 40);
        }
        *int v20 = v19;
        void *v12 = 0;
        *(void *)(v10 + 40) = 0;
        id v11 = (void *)*((void *)handle + 16);
        *(void *)(v10 + 40) = v11;
        *id v11 = v10;
        *((void *)handle + 16) = v12;
        uint64_t v10 = v13;
      }
      while (v13);
    }
  }
  else if (gLogDatapath)
  {
    uint64_t v76 = __nwlog_obj();
    if (os_log_type_enabled(v76, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)int buf = 136446466;
      __int16 v85 = "nw_protocol_shoes_input_available";
      __int16 v86 = 2082;
      int v87 = handle + 151;
      _os_log_impl(&dword_1830D4000, v76, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Got 0 input frames", buf, 0x16u);
    }
  }
  os_log_type_t v21 = handle + 151;
  while (1)
  {
    if (!*((void *)handle + 15)) {
      return;
    }
    if (handle[150] != 5)
    {
      switch(handle[150])
      {
        case 1:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v55 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)int buf = 136446466;
            __int16 v85 = "nw_shoes_service_reads";
            __int16 v86 = 2082;
            int v87 = v21;
            uint64_t v7 = "%{public}s %{public}s Tried to read packets in initial state";
            goto LABEL_92;
          }
          break;
        case 2:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v55 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)int buf = 136446466;
            __int16 v85 = "nw_shoes_service_reads";
            __int16 v86 = 2082;
            int v87 = v21;
            uint64_t v7 = "%{public}s %{public}s Tried to read packets in waiting for TFO state";
            goto LABEL_92;
          }
          break;
        case 3:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v55 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)int buf = 136446466;
            __int16 v85 = "nw_shoes_service_reads";
            __int16 v86 = 2082;
            int v87 = v21;
            uint64_t v7 = "%{public}s %{public}s Tried to read packets in waiting for UDP associate state";
            goto LABEL_92;
          }
          break;
        case 6:
          (*(void (**)(void, char *))(*(void *)(*((void *)handle + 6) + 24) + 64))(*((void *)handle + 6), handle);
          break;
        case 7:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v55 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)int buf = 136446466;
            __int16 v85 = "nw_shoes_service_reads";
            __int16 v86 = 2082;
            int v87 = v21;
            uint64_t v7 = "%{public}s %{public}s Tried to read packets in failed state";
LABEL_92:
            uint64_t v8 = v55;
            goto LABEL_93;
          }
          break;
        default:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v58 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            int v59 = handle[150];
            *(_DWORD *)int buf = 136446722;
            __int16 v85 = "nw_shoes_service_reads";
            __int16 v86 = 2082;
            int v87 = handle + 151;
            __int16 v88 = 1024;
            int v89 = v59;
            uint64_t v7 = "%{public}s %{public}s Tried to read packets in unknown state %u";
            uint64_t v8 = v58;
            os_log_type_t v56 = OS_LOG_TYPE_ERROR;
            uint32_t v57 = 28;
            goto LABEL_95;
          }
          break;
      }
      return;
    }
    unsigned int v22 = *((_DWORD *)handle + 34);
    if (v22 <= 1 && !nw_shoes_read_into_buffer((uint64_t)handle, (uint64_t)(handle + 146), 2 - v22, v22)) {
      break;
    }
    uint64_t v23 = bswap32(*((unsigned __int16 *)handle + 73)) >> 16;
    if (!v23)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v28 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)int buf = 136446466;
        __int16 v85 = "nw_shoes_read_reply";
        __int16 v86 = 2082;
        int v87 = handle + 151;
        _os_log_impl(&dword_1830D4000, v28, OS_LOG_TYPE_INFO, "%{public}s %{public}s Received successful empty shoes reply from server", buf, 0x16u);
      }
      goto LABEL_56;
    }
    if (v23 == 1)
    {
      id v61 = __nwlog_obj();
      if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446466;
        __int16 v85 = "nw_shoes_read_reply";
        __int16 v86 = 2082;
        int v87 = handle + 151;
        _os_log_impl(&dword_1830D4000, v61, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Received invalid shoes reply length one", buf, 0x16u);
      }
      nw_protocol_shoes_error((nw_protocol *)handle, (nw_protocol *)handle, 422052353);
      handle[235] |= 0x10u;
      os_log_type_t v62 = __nwlog_obj();
      if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136446466;
        __int16 v85 = "nw_shoes_internal_disconnect";
        __int16 v86 = 2082;
        int v87 = handle + 151;
        _os_log_impl(&dword_1830D4000, v62, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s ", buf, 0x16u);
      }
      handle[150] = 7;
      (*(void (**)(char *, void))(*((void *)handle + 3) + 48))(handle, 0);
      return;
    }
    unsigned int v24 = *((_DWORD *)handle + 34);
    if (v24 <= 3)
    {
      if (!nw_shoes_read_into_buffer((uint64_t)handle, (uint64_t)(handle + 146), 4 - v24, v24))
      {
        if (gLogDatapath)
        {
          uint64_t v60 = __nwlog_obj();
          if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)int buf = 136446466;
            __int16 v85 = "nw_shoes_read_reply";
            __int16 v86 = 2082;
            int v87 = v21;
            uint64_t v7 = "%{public}s %{public}s Failed to read shoes reply domain and error code";
            goto LABEL_112;
          }
        }
        return;
      }
      unsigned int v24 = *((_DWORD *)handle + 34);
    }
    unint64_t v25 = v23 + 2;
    unsigned __int16 v26 = v23 + 2 - v24;
    if (v26)
    {
      BOOL v27 = nw_calloc_type<unsigned char>((unsigned __int16)(v23 + 2 - v24));
      if (v25 > *((unsigned int *)handle + 34)) {
        goto LABEL_50;
      }
    }
    else
    {
      BOOL v27 = 0;
      if (v25 > v24)
      {
LABEL_50:
        if (!nw_shoes_read_into_buffer((uint64_t)handle, v27, v26, 0))
        {
          if (gLogDatapath)
          {
            uint64_t v77 = __nwlog_obj();
            if (os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)int buf = 136446466;
              __int16 v85 = "nw_shoes_read_reply";
              __int16 v86 = 2082;
              int v87 = v21;
              _os_log_impl(&dword_1830D4000, v77, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Failed to read shoes rest of reply", buf, 0x16u);
            }
          }
          if (!v27) {
            return;
          }
LABEL_124:
          free((void *)v27);
          return;
        }
      }
    }
    if (handle[148])
    {
      int v63 = handle[149];
      switch(handle[148])
      {
        case 1:
          v63 |= 0x19280100u;
          break;
        case 2:
          break;
        case 3:
          v63 |= 0xFFFEFF00;
          break;
        case 4:
          v63 -= 10055;
          break;
        default:
          int v63 = 422052352;
          break;
      }
      os_log_type_t v64 = __nwlog_obj();
      if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
      {
        int v65 = handle[148];
        int v66 = handle[149];
        *(_DWORD *)int buf = 136447490;
        __int16 v85 = "nw_shoes_read_reply";
        __int16 v86 = 2082;
        int v87 = handle + 151;
        __int16 v88 = 1024;
        int v89 = v63;
        __int16 v90 = 1024;
        *(_DWORD *)__int16 v91 = v65;
        *(_WORD *)&v91[4] = 1024;
        *(_DWORD *)&v91[6] = v66;
        LOWORD(v92) = 1024;
        *(_DWORD *)((char *)&v92 + 2) = v23;
        _os_log_impl(&dword_1830D4000, v64, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Received shoes error %d domain %u code %u inner length %u", buf, 0x2Eu);
      }
      nw_shoes_read_reply_tlvs((uint64_t)handle, (unsigned __int8 *)v27, v26, 0);
      nw_protocol_shoes_error((nw_protocol *)handle, (nw_protocol *)handle, v63);
      handle[235] |= 0x10u;
      os_log_type_t v67 = __nwlog_obj();
      if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136446466;
        __int16 v85 = "nw_shoes_internal_disconnect";
        __int16 v86 = 2082;
        int v87 = handle + 151;
        _os_log_impl(&dword_1830D4000, v67, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s ", buf, 0x16u);
      }
      handle[150] = 7;
      (*(void (**)(char *, void))(*((void *)handle + 3) + 48))(handle, 0);
      if (!v27) {
        return;
      }
      goto LABEL_124;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v29 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      int v30 = handle[149];
      *(_DWORD *)int buf = 136446978;
      __int16 v85 = "nw_shoes_read_reply";
      __int16 v86 = 2082;
      int v87 = handle + 151;
      __int16 v88 = 1024;
      int v89 = v23;
      __int16 v90 = 1024;
      *(_DWORD *)__int16 v91 = v30;
      _os_log_impl(&dword_1830D4000, v29, OS_LOG_TYPE_INFO, "%{public}s %{public}s Received successful shoes reply from server with inner length %u code %u", buf, 0x22u);
    }
    nw_shoes_read_reply_tlvs((uint64_t)handle, (unsigned __int8 *)v27, v26, 1);
    if (v27) {
      free((void *)v27);
    }
LABEL_56:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v31 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)int buf = 136446466;
      __int16 v85 = "nw_shoes_internal_connect";
      __int16 v86 = 2082;
      int v87 = handle + 151;
      _os_log_impl(&dword_1830D4000, v31, OS_LOG_TYPE_INFO, "%{public}s %{public}s ", buf, 0x16u);
    }
    handle[150] = 6;
    uint64_t v32 = *((void *)handle + 6);
    if ((handle[235] & 2) != 0)
    {
      uint64_t v33 = *((void *)handle + 5);
      if (!v33)
      {
        __nwlog_obj();
        *(_DWORD *)int buf = 136446210;
        __int16 v85 = "nw_protocol_shoes_process_udp_associate_completion";
        long long v44 = (const char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v82 = 0;
        int v79 = (char *)v44;
        if (!__nwlog_fault(v44, &type, &v82)) {
          goto LABEL_80;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          long long v45 = __nwlog_obj();
          os_log_type_t v46 = type;
          if (os_log_type_enabled(v45, type))
          {
            *(_DWORD *)int buf = 136446210;
            __int16 v85 = "nw_protocol_shoes_process_udp_associate_completion";
            BOOL v47 = v45;
            os_log_type_t v48 = v46;
            os_log_type_t v49 = "%{public}s called with null shoes";
            goto LABEL_79;
          }
          goto LABEL_80;
        }
        if (v82)
        {
          os_log_type_t v50 = (char *)__nw_create_backtrace_string();
          os_log_type_t v51 = __nwlog_obj();
          os_log_type_t v78 = type;
          BOOL v52 = os_log_type_enabled(v51, type);
          if (v50)
          {
            if (v52)
            {
              *(_DWORD *)int buf = 136446466;
              __int16 v85 = "nw_protocol_shoes_process_udp_associate_completion";
              __int16 v86 = 2082;
              int v87 = v50;
              _os_log_impl(&dword_1830D4000, v51, v78, "%{public}s called with null shoes, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v50);
            goto LABEL_80;
          }
          if (!v52)
          {
LABEL_80:
            if (v79) {
              free(v79);
            }
            goto LABEL_34;
          }
          *(_DWORD *)int buf = 136446210;
          __int16 v85 = "nw_protocol_shoes_process_udp_associate_completion";
          BOOL v47 = v51;
          os_log_type_t v48 = v78;
          os_log_type_t v49 = "%{public}s called with null shoes, no backtrace";
        }
        else
        {
          os_log_type_t v53 = __nwlog_obj();
          os_log_type_t v54 = type;
          if (!os_log_type_enabled(v53, type)) {
            goto LABEL_80;
          }
          *(_DWORD *)int buf = 136446210;
          __int16 v85 = "nw_protocol_shoes_process_udp_associate_completion";
          BOOL v47 = v53;
          os_log_type_t v48 = v54;
          os_log_type_t v49 = "%{public}s called with null shoes, backtrace limit exceeded";
        }
LABEL_79:
        _os_log_impl(&dword_1830D4000, v47, v48, v49, buf, 0xCu);
        goto LABEL_80;
      }
      if ((*(unsigned char *)(v33 + 235) & 0xE) == 6)
      {
        uint64_t v34 = *(void *)(v33 + 64);
        if (v34)
        {
          *(void *)(v33 + 64) = *(void *)(v33 + 32);
          nw_protocol_set_output_handler((uint64_t)handle, v34);
          nw_protocol_set_output_handler(v33, v34);
          *(unsigned char *)(v33 + 235) |= 8u;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v35 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
          {
            int v36 = *(unsigned __int16 *)(v33 + 144);
            uint64_t v38 = *(void *)(v33 + 96);
            uint64_t v37 = *(void *)(v33 + 104);
            *(_DWORD *)int buf = 136447234;
            __int16 v85 = "nw_protocol_shoes_process_udp_associate_completion";
            __int16 v86 = 2082;
            int v87 = (char *)(v33 + 151);
            __int16 v88 = 1024;
            int v89 = v36;
            __int16 v90 = 2112;
            *(void *)__int16 v91 = v37;
            *(_WORD *)&v91[8] = 2112;
            uint64_t v92 = v38;
            os_log_type_t v39 = v35;
            os_log_type_t v40 = OS_LOG_TYPE_DEFAULT;
            uint64_t v41 = "%{public}s %{public}s udp-associate completed with port %d to %@ and remote %@";
            uint32_t v42 = 48;
LABEL_33:
            _os_log_impl(&dword_1830D4000, v39, v40, v41, buf, v42);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v43 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)int buf = 136446466;
            __int16 v85 = "nw_protocol_shoes_process_udp_associate_completion";
            __int16 v86 = 2082;
            int v87 = (char *)(v33 + 151);
            os_log_type_t v39 = v43;
            os_log_type_t v40 = OS_LOG_TYPE_ERROR;
            uint64_t v41 = "%{public}s %{public}s udp-associate no output handler";
            uint32_t v42 = 22;
            goto LABEL_33;
          }
        }
      }
    }
LABEL_34:
    (*(void (**)(uint64_t, char *))(*(void *)(v32 + 24) + 40))(v32, handle);
  }
  if (gLogDatapath)
  {
    uint64_t v60 = __nwlog_obj();
    if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)int buf = 136446466;
      __int16 v85 = "nw_shoes_read_reply";
      __int16 v86 = 2082;
      int v87 = v21;
      uint64_t v7 = "%{public}s %{public}s Failed to read shoes reply length";
LABEL_112:
      uint64_t v8 = v60;
      os_log_type_t v56 = OS_LOG_TYPE_DEBUG;
      goto LABEL_94;
    }
  }
}

void http2_input_frame_metadata_reset(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  v55[2] = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v47 = "http2_input_frame_metadata_reset";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v44 = 0;
    if (!__nwlog_fault(v8, &type, &v44)) {
      goto LABEL_31;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v29 = __nwlog_obj();
      os_log_type_t v30 = type;
      if (!os_log_type_enabled(v29, type)) {
        goto LABEL_31;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v47 = "http2_input_frame_metadata_reset";
      uint64_t v13 = "%{public}s called with null frame";
    }
    else if (v44)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v29 = __nwlog_obj();
      os_log_type_t v30 = type;
      BOOL v33 = os_log_type_enabled(v29, type);
      if (backtrace_string)
      {
        if (v33)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v47 = "http2_input_frame_metadata_reset";
          __int16 v48 = 2082;
          os_log_type_t v49 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v29, v30, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_31;
      }
      if (!v33) {
        goto LABEL_31;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v47 = "http2_input_frame_metadata_reset";
      uint64_t v13 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      char v29 = __nwlog_obj();
      os_log_type_t v30 = type;
      if (!os_log_type_enabled(v29, type)) {
        goto LABEL_31;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v47 = "http2_input_frame_metadata_reset";
      uint64_t v13 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    unsigned __int16 v26 = v29;
    os_log_type_t v27 = v30;
    uint32_t v28 = 12;
    goto LABEL_30;
  }
  if ((*(_WORD *)(a1 + 204) & 4) != 0)
  {
    *(void *)(a1 + 208) = a2;
    *(void *)(a1 + 216) = a3;
    *(_DWORD *)(a1 + 224) = a4;
    return;
  }
  if (a3)
  {
    if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) != 0) {
      return;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v7 = *(_DWORD *)(a3 + 176);
    int v6 = *(_DWORD *)(a3 + 180);
    *(_DWORD *)int buf = 136447234;
    BOOL v47 = "http2_input_frame_metadata_reset";
    __int16 v48 = 2082;
    os_log_type_t v49 = (void *)(a3 + 191);
    __int16 v50 = 2080;
    os_log_type_t v51 = " ";
    __int16 v52 = 1024;
    int v53 = v6;
    __int16 v54 = 1024;
    LODWORD(v55[0]) = v7;
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v44 = 0;
    if (!__nwlog_fault(v8, &type, &v44)) {
      goto LABEL_31;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v9 = gconnectionLogObj;
      os_log_type_t v10 = type;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
      {
        int v12 = *(_DWORD *)(a3 + 176);
        int v11 = *(_DWORD *)(a3 + 180);
        *(_DWORD *)int buf = 136447234;
        BOOL v47 = "http2_input_frame_metadata_reset";
        __int16 v48 = 2082;
        os_log_type_t v49 = (void *)(a3 + 191);
        __int16 v50 = 2080;
        os_log_type_t v51 = " ";
        __int16 v52 = 1024;
        int v53 = v11;
        __int16 v54 = 1024;
        LODWORD(v55[0]) = v12;
        uint64_t v13 = "%{public}s %{public}s%s<i%u:s%d> frame has no metadata";
LABEL_29:
        unsigned __int16 v26 = v9;
        os_log_type_t v27 = v10;
        uint32_t v28 = 44;
LABEL_30:
        _os_log_impl(&dword_1830D4000, v26, v27, v13, buf, v28);
        goto LABEL_31;
      }
      goto LABEL_31;
    }
    if (!v44)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v9 = gconnectionLogObj;
      os_log_type_t v10 = type;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
      {
        int v23 = *(_DWORD *)(a3 + 176);
        int v22 = *(_DWORD *)(a3 + 180);
        *(_DWORD *)int buf = 136447234;
        BOOL v47 = "http2_input_frame_metadata_reset";
        __int16 v48 = 2082;
        os_log_type_t v49 = (void *)(a3 + 191);
        __int16 v50 = 2080;
        os_log_type_t v51 = " ";
        __int16 v52 = 1024;
        int v53 = v22;
        __int16 v54 = 1024;
        LODWORD(v55[0]) = v23;
        uint64_t v13 = "%{public}s %{public}s%s<i%u:s%d> frame has no metadata, backtrace limit exceeded";
        goto LABEL_29;
      }
LABEL_31:
      if (!v8) {
        return;
      }
      goto LABEL_32;
    }
    uint64_t v14 = (char *)__nw_create_backtrace_string();
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v9 = gconnectionLogObj;
    os_log_type_t v10 = type;
    BOOL v15 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
    if (!v14)
    {
      if (!v15) {
        goto LABEL_31;
      }
      int v25 = *(_DWORD *)(a3 + 176);
      int v24 = *(_DWORD *)(a3 + 180);
      *(_DWORD *)int buf = 136447234;
      BOOL v47 = "http2_input_frame_metadata_reset";
      __int16 v48 = 2082;
      os_log_type_t v49 = (void *)(a3 + 191);
      __int16 v50 = 2080;
      os_log_type_t v51 = " ";
      __int16 v52 = 1024;
      int v53 = v24;
      __int16 v54 = 1024;
      LODWORD(v55[0]) = v25;
      uint64_t v13 = "%{public}s %{public}s%s<i%u:s%d> frame has no metadata, no backtrace";
      goto LABEL_29;
    }
    if (v15)
    {
      int v17 = *(_DWORD *)(a3 + 176);
      int v16 = *(_DWORD *)(a3 + 180);
      *(_DWORD *)int buf = 136447490;
      BOOL v47 = "http2_input_frame_metadata_reset";
      __int16 v48 = 2082;
      os_log_type_t v49 = (void *)(a3 + 191);
      __int16 v50 = 2080;
      os_log_type_t v51 = " ";
      __int16 v52 = 1024;
      int v53 = v16;
      __int16 v54 = 1024;
      LODWORD(v55[0]) = v17;
      WORD2(v55[0]) = 2082;
      *(void *)((char *)v55 + 6) = v14;
      uint64_t v18 = "%{public}s %{public}s%s<i%u:s%d> frame has no metadata, dumping backtrace:%{public}s";
      uint64_t v19 = v9;
      os_log_type_t v20 = v10;
      uint32_t v21 = 54;
LABEL_20:
      _os_log_impl(&dword_1830D4000, v19, v20, v18, buf, v21);
      goto LABEL_21;
    }
    goto LABEL_21;
  }
  if (!a2)
  {
    os_log_type_t v31 = "";
LABEL_47:
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    if (a2) {
      uint64_t v34 = (const char *)(a2 + 390);
    }
    else {
      uint64_t v34 = "";
    }
    int v35 = *(_DWORD *)(a2 + 368);
    *(_DWORD *)int buf = 136446978;
    BOOL v47 = "http2_input_frame_metadata_reset";
    __int16 v48 = 2082;
    os_log_type_t v49 = (void *)v34;
    __int16 v50 = 2080;
    os_log_type_t v51 = v31;
    __int16 v52 = 1024;
    int v53 = v35;
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v44 = 0;
    if (!__nwlog_fault(v8, &type, &v44)) {
      goto LABEL_31;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v36 = gconnectionLogObj;
      os_log_type_t v37 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
        goto LABEL_31;
      }
      int v38 = *(_DWORD *)(a2 + 368);
      *(_DWORD *)int buf = 136446978;
      BOOL v47 = "http2_input_frame_metadata_reset";
      __int16 v48 = 2082;
      os_log_type_t v49 = (void *)v34;
      __int16 v50 = 2080;
      os_log_type_t v51 = v31;
      __int16 v52 = 1024;
      int v53 = v38;
      uint64_t v13 = "%{public}s %{public}s%s<i%u> frame has no metadata";
    }
    else
    {
      os_log_type_t v39 = v31;
      if (v44)
      {
        uint64_t v14 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v36 = gconnectionLogObj;
        os_log_type_t v37 = type;
        BOOL v40 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
        if (v14)
        {
          if (v40)
          {
            int v41 = *(_DWORD *)(a2 + 368);
            *(_DWORD *)int buf = 136447234;
            BOOL v47 = "http2_input_frame_metadata_reset";
            __int16 v48 = 2082;
            os_log_type_t v49 = (void *)v34;
            __int16 v50 = 2080;
            os_log_type_t v51 = v39;
            __int16 v52 = 1024;
            int v53 = v41;
            __int16 v54 = 2082;
            v55[0] = v14;
            uint64_t v18 = "%{public}s %{public}s%s<i%u> frame has no metadata, dumping backtrace:%{public}s";
            uint64_t v19 = v36;
            os_log_type_t v20 = v37;
            uint32_t v21 = 48;
            goto LABEL_20;
          }
LABEL_21:
          free(v14);
          if (!v8) {
            return;
          }
LABEL_32:
          free(v8);
          return;
        }
        if (!v40) {
          goto LABEL_31;
        }
        int v43 = *(_DWORD *)(a2 + 368);
        *(_DWORD *)int buf = 136446978;
        BOOL v47 = "http2_input_frame_metadata_reset";
        __int16 v48 = 2082;
        os_log_type_t v49 = (void *)v34;
        __int16 v50 = 2080;
        os_log_type_t v51 = v39;
        __int16 v52 = 1024;
        int v53 = v43;
        uint64_t v13 = "%{public}s %{public}s%s<i%u> frame has no metadata, no backtrace";
      }
      else
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v36 = gconnectionLogObj;
        os_log_type_t v37 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_31;
        }
        int v42 = *(_DWORD *)(a2 + 368);
        *(_DWORD *)int buf = 136446978;
        BOOL v47 = "http2_input_frame_metadata_reset";
        __int16 v48 = 2082;
        os_log_type_t v49 = (void *)v34;
        __int16 v50 = 2080;
        os_log_type_t v51 = v31;
        __int16 v52 = 1024;
        int v53 = v42;
        uint64_t v13 = "%{public}s %{public}s%s<i%u> frame has no metadata, backtrace limit exceeded";
      }
    }
    unsigned __int16 v26 = v36;
    os_log_type_t v27 = v37;
    uint32_t v28 = 38;
    goto LABEL_30;
  }
  if ((*(__int16 *)(a2 + 388) & 0x80000000) == 0)
  {
    os_log_type_t v31 = " ";
    goto LABEL_47;
  }
}

uint64_t nw_socket_register_notification(uint64_t a1, uint64_t a2, int a3, int *a4, uint64_t a5)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    int v41 = "nw_socket_register_notification";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v38 = 0;
    if (!__nwlog_fault(v8, &type, &v38)) {
      goto LABEL_85;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v30 = __nwlog_obj();
      os_log_type_t v31 = type;
      if (!os_log_type_enabled(v30, type)) {
        goto LABEL_85;
      }
      *(_DWORD *)int buf = 136446210;
      int v41 = "nw_socket_register_notification";
      int v11 = "%{public}s called with null protocol";
      goto LABEL_145;
    }
    if (!v38)
    {
      os_log_type_t v30 = __nwlog_obj();
      os_log_type_t v31 = type;
      if (!os_log_type_enabled(v30, type)) {
        goto LABEL_85;
      }
      *(_DWORD *)int buf = 136446210;
      int v41 = "nw_socket_register_notification";
      int v11 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_145;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v30 = __nwlog_obj();
    os_log_type_t v31 = type;
    BOOL v33 = os_log_type_enabled(v30, type);
    if (!backtrace_string)
    {
      if (!v33) {
        goto LABEL_85;
      }
      *(_DWORD *)int buf = 136446210;
      int v41 = "nw_socket_register_notification";
      int v11 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_145;
    }
    if (!v33)
    {
LABEL_111:
      free(backtrace_string);
      if (!v8) {
        return 0;
      }
      goto LABEL_86;
    }
    *(_DWORD *)int buf = 136446466;
    int v41 = "nw_socket_register_notification";
    __int16 v42 = 2082;
    int v43 = backtrace_string;
    uint64_t v34 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_110:
    _os_log_impl(&dword_1830D4000, v30, v31, v34, buf, 0x16u);
    goto LABEL_111;
  }
  if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
  {
    uint64_t v6 = a1 + 96;
    switch(a3)
    {
      case 0:
        if ((*(_WORD *)(a1 + 397) & 0x80) != 0) {
          return 0;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v7 = (char *)(a1 + 404);
        *(_DWORD *)int buf = 136446722;
        int v41 = "nw_socket_register_notification";
        __int16 v42 = 2082;
        int v43 = (char *)(a1 + 404);
        __int16 v44 = 2082;
        long long v45 = "undefined";
        uint64_t v8 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v38 = 0;
        if (!__nwlog_fault(v8, &type, &v38)) {
          goto LABEL_85;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v9 = gconnectionLogObj;
          os_log_type_t v10 = type;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
          {
            *(_DWORD *)int buf = 136446722;
            int v41 = "nw_socket_register_notification";
            __int16 v42 = 2082;
            int v43 = v7;
            __int16 v44 = 2082;
            long long v45 = "undefined";
            int v11 = "%{public}s %{public}s invalid registration notification: %{public}s";
            goto LABEL_82;
          }
          goto LABEL_85;
        }
        if (!v38)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v9 = gconnectionLogObj;
          os_log_type_t v10 = type;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
          {
            *(_DWORD *)int buf = 136446722;
            int v41 = "nw_socket_register_notification";
            __int16 v42 = 2082;
            int v43 = v7;
            __int16 v44 = 2082;
            long long v45 = "undefined";
            int v11 = "%{public}s %{public}s invalid registration notification: %{public}s, backtrace limit exceeded";
            goto LABEL_82;
          }
          goto LABEL_85;
        }
        os_log_type_t v20 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint32_t v21 = gconnectionLogObj;
        os_log_type_t v22 = type;
        BOOL v23 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
        if (v20)
        {
          if (v23)
          {
            *(_DWORD *)int buf = 136446978;
            int v41 = "nw_socket_register_notification";
            __int16 v42 = 2082;
            int v43 = v7;
            __int16 v44 = 2082;
            long long v45 = "undefined";
            __int16 v46 = 2082;
            BOOL v47 = v20;
            _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s %{public}s invalid registration notification: %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
          }
          free(v20);
          goto LABEL_85;
        }
        if (!v23) {
          goto LABEL_85;
        }
        *(_DWORD *)int buf = 136446722;
        int v41 = "nw_socket_register_notification";
        __int16 v42 = 2082;
        int v43 = v7;
        __int16 v44 = 2082;
        long long v45 = "undefined";
        int v11 = "%{public}s %{public}s invalid registration notification: %{public}s, no backtrace";
        goto LABEL_93;
      case 1:
        if (!a4)
        {
          __nwlog_obj();
          *(_DWORD *)int buf = 136446210;
          int v41 = "nw_socket_register_notification";
          uint64_t v8 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v38 = 0;
          if (!__nwlog_fault(v8, &type, &v38)) {
            goto LABEL_85;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            os_log_type_t v30 = __nwlog_obj();
            os_log_type_t v31 = type;
            if (!os_log_type_enabled(v30, type)) {
              goto LABEL_85;
            }
            *(_DWORD *)int buf = 136446210;
            int v41 = "nw_socket_register_notification";
            int v11 = "%{public}s called with null val";
            goto LABEL_145;
          }
          if (v38)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            os_log_type_t v30 = __nwlog_obj();
            os_log_type_t v31 = type;
            BOOL v36 = os_log_type_enabled(v30, type);
            if (backtrace_string)
            {
              if (!v36) {
                goto LABEL_111;
              }
              goto LABEL_132;
            }
            if (!v36) {
              goto LABEL_85;
            }
            *(_DWORD *)int buf = 136446210;
            int v41 = "nw_socket_register_notification";
            int v11 = "%{public}s called with null val, no backtrace";
          }
          else
          {
            os_log_type_t v30 = __nwlog_obj();
            os_log_type_t v31 = type;
            if (!os_log_type_enabled(v30, type)) {
              goto LABEL_85;
            }
            *(_DWORD *)int buf = 136446210;
            int v41 = "nw_socket_register_notification";
            int v11 = "%{public}s called with null val, backtrace limit exceeded";
          }
          goto LABEL_145;
        }
        if (a5)
        {
          int v12 = *a4;
          int v13 = *(_DWORD *)(a1 + 288);
          if (!*a4) {
            int v12 = 5;
          }
          *(_DWORD *)(a1 + 288) = v12;
          uint64_t v14 = 1;
          if ((nw_socket_add_socket_events(v6, 1, 1024, 0) & 1) == 0)
          {
            uint64_t v14 = 0;
            *(_DWORD *)(a1 + 288) = v13;
          }
          return v14;
        }
        if ((*(_WORD *)(a1 + 397) & 0x80) != 0) {
          return 0;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v18 = (char *)(a1 + 404);
        *(_DWORD *)int buf = 136446722;
        int v41 = "nw_socket_register_notification";
        __int16 v42 = 2082;
        int v43 = (char *)(a1 + 404);
        __int16 v44 = 2082;
        long long v45 = "read_timeout";
        uint64_t v8 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v38 = 0;
        if (!__nwlog_fault(v8, &type, &v38)) {
          goto LABEL_85;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v9 = gconnectionLogObj;
          os_log_type_t v10 = type;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
          {
            *(_DWORD *)int buf = 136446722;
            int v41 = "nw_socket_register_notification";
            __int16 v42 = 2082;
            int v43 = v18;
            __int16 v44 = 2082;
            long long v45 = "read_timeout";
            int v11 = "%{public}s %{public}s register notification for %{public}s called with zero length";
            goto LABEL_82;
          }
          goto LABEL_85;
        }
        if (!v38)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v9 = gconnectionLogObj;
          os_log_type_t v10 = type;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
          {
            *(_DWORD *)int buf = 136446722;
            int v41 = "nw_socket_register_notification";
            __int16 v42 = 2082;
            int v43 = v18;
            __int16 v44 = 2082;
            long long v45 = "read_timeout";
            int v11 = "%{public}s %{public}s register notification for %{public}s called with zero length, backtrace limit exceeded";
            goto LABEL_82;
          }
          goto LABEL_85;
        }
        int v24 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint32_t v21 = gconnectionLogObj;
        os_log_type_t v22 = type;
        BOOL v25 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
        if (v24)
        {
          if (!v25) {
            goto LABEL_70;
          }
          *(_DWORD *)int buf = 136446978;
          int v41 = "nw_socket_register_notification";
          __int16 v42 = 2082;
          int v43 = v18;
          __int16 v44 = 2082;
          long long v45 = "read_timeout";
          __int16 v46 = 2082;
          BOOL v47 = v24;
          goto LABEL_69;
        }
        if (!v25) {
          goto LABEL_85;
        }
        *(_DWORD *)int buf = 136446722;
        int v41 = "nw_socket_register_notification";
        __int16 v42 = 2082;
        int v43 = v18;
        __int16 v44 = 2082;
        long long v45 = "read_timeout";
        int v11 = "%{public}s %{public}s register notification for %{public}s called with zero length, no backtrace";
        goto LABEL_93;
      case 2:
        if (a4)
        {
          if (a5)
          {
            int v15 = *a4;
            int v16 = *(_DWORD *)(a1 + 292);
            if (!*a4) {
              int v15 = 5;
            }
            *(_DWORD *)(a1 + 292) = v15;
            uint64_t v14 = 1;
            if ((nw_socket_add_socket_events(v6, 1, 512, 0) & 1) == 0)
            {
              uint64_t v14 = 0;
              *(_DWORD *)(a1 + 292) = v16;
            }
            return v14;
          }
          if ((*(_WORD *)(a1 + 397) & 0x80) != 0) {
            return 0;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v19 = (char *)(a1 + 404);
          *(_DWORD *)int buf = 136446722;
          int v41 = "nw_socket_register_notification";
          __int16 v42 = 2082;
          int v43 = (char *)(a1 + 404);
          __int16 v44 = 2082;
          long long v45 = "write_timeout";
          uint64_t v8 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v38 = 0;
          if (!__nwlog_fault(v8, &type, &v38)) {
            goto LABEL_85;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            uint64_t v9 = gconnectionLogObj;
            os_log_type_t v10 = type;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
            {
              *(_DWORD *)int buf = 136446722;
              int v41 = "nw_socket_register_notification";
              __int16 v42 = 2082;
              int v43 = v19;
              __int16 v44 = 2082;
              long long v45 = "write_timeout";
              int v11 = "%{public}s %{public}s register notification for %{public}s called with zero length";
LABEL_82:
              os_log_type_t v27 = v9;
              os_log_type_t v28 = v10;
LABEL_83:
              uint32_t v29 = 32;
              goto LABEL_84;
            }
            goto LABEL_85;
          }
          if (!v38)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            uint64_t v9 = gconnectionLogObj;
            os_log_type_t v10 = type;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
            {
              *(_DWORD *)int buf = 136446722;
              int v41 = "nw_socket_register_notification";
              __int16 v42 = 2082;
              int v43 = v19;
              __int16 v44 = 2082;
              long long v45 = "write_timeout";
              int v11 = "%{public}s %{public}s register notification for %{public}s called with zero length, backtrace limit exceeded";
              goto LABEL_82;
            }
            goto LABEL_85;
          }
          int v24 = (char *)__nw_create_backtrace_string();
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint32_t v21 = gconnectionLogObj;
          os_log_type_t v22 = type;
          BOOL v26 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
          if (!v24)
          {
            if (v26)
            {
              *(_DWORD *)int buf = 136446722;
              int v41 = "nw_socket_register_notification";
              __int16 v42 = 2082;
              int v43 = v19;
              __int16 v44 = 2082;
              long long v45 = "write_timeout";
              int v11 = "%{public}s %{public}s register notification for %{public}s called with zero length, no backtrace";
LABEL_93:
              os_log_type_t v27 = v21;
              os_log_type_t v28 = v22;
              goto LABEL_83;
            }
            goto LABEL_85;
          }
          if (v26)
          {
            *(_DWORD *)int buf = 136446978;
            int v41 = "nw_socket_register_notification";
            __int16 v42 = 2082;
            int v43 = v19;
            __int16 v44 = 2082;
            long long v45 = "write_timeout";
            __int16 v46 = 2082;
            BOOL v47 = v24;
LABEL_69:
            _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s %{public}s register notification for %{public}s called with zero length, dumping backtrace:%{public}s", buf, 0x2Au);
          }
LABEL_70:
          free(v24);
          if (v8) {
            goto LABEL_86;
          }
          return 0;
        }
        __nwlog_obj();
        *(_DWORD *)int buf = 136446210;
        int v41 = "nw_socket_register_notification";
        uint64_t v8 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v38 = 0;
        if (!__nwlog_fault(v8, &type, &v38)) {
          goto LABEL_85;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v30 = __nwlog_obj();
          os_log_type_t v31 = type;
          if (!os_log_type_enabled(v30, type)) {
            goto LABEL_85;
          }
          *(_DWORD *)int buf = 136446210;
          int v41 = "nw_socket_register_notification";
          int v11 = "%{public}s called with null val";
          goto LABEL_145;
        }
        if (v38)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          os_log_type_t v30 = __nwlog_obj();
          os_log_type_t v31 = type;
          BOOL v37 = os_log_type_enabled(v30, type);
          if (backtrace_string)
          {
            if (v37)
            {
LABEL_132:
              *(_DWORD *)int buf = 136446466;
              int v41 = "nw_socket_register_notification";
              __int16 v42 = 2082;
              int v43 = backtrace_string;
              uint64_t v34 = "%{public}s called with null val, dumping backtrace:%{public}s";
              goto LABEL_110;
            }
            goto LABEL_111;
          }
          if (!v37) {
            goto LABEL_85;
          }
          *(_DWORD *)int buf = 136446210;
          int v41 = "nw_socket_register_notification";
          int v11 = "%{public}s called with null val, no backtrace";
        }
        else
        {
          os_log_type_t v30 = __nwlog_obj();
          os_log_type_t v31 = type;
          if (!os_log_type_enabled(v30, type)) {
            goto LABEL_85;
          }
          *(_DWORD *)int buf = 136446210;
          int v41 = "nw_socket_register_notification";
          int v11 = "%{public}s called with null val, backtrace limit exceeded";
        }
        break;
      case 3:
        return nw_socket_add_socket_events(v6, 1, 256, 0);
      default:
        return 0;
    }
    goto LABEL_145;
  }
  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  int v41 = "nw_socket_register_notification";
  uint64_t v8 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v38 = 0;
  if (!__nwlog_fault(v8, &type, &v38)) {
    goto LABEL_85;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v30 = __nwlog_obj();
    os_log_type_t v31 = type;
    if (!os_log_type_enabled(v30, type)) {
      goto LABEL_85;
    }
    *(_DWORD *)int buf = 136446210;
    int v41 = "nw_socket_register_notification";
    int v11 = "%{public}s called with null socket_handler";
    goto LABEL_145;
  }
  if (!v38)
  {
    os_log_type_t v30 = __nwlog_obj();
    os_log_type_t v31 = type;
    if (!os_log_type_enabled(v30, type)) {
      goto LABEL_85;
    }
    *(_DWORD *)int buf = 136446210;
    int v41 = "nw_socket_register_notification";
    int v11 = "%{public}s called with null socket_handler, backtrace limit exceeded";
    goto LABEL_145;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  os_log_type_t v30 = __nwlog_obj();
  os_log_type_t v31 = type;
  BOOL v35 = os_log_type_enabled(v30, type);
  if (backtrace_string)
  {
    if (!v35) {
      goto LABEL_111;
    }
    *(_DWORD *)int buf = 136446466;
    int v41 = "nw_socket_register_notification";
    __int16 v42 = 2082;
    int v43 = backtrace_string;
    uint64_t v34 = "%{public}s called with null socket_handler, dumping backtrace:%{public}s";
    goto LABEL_110;
  }
  if (!v35) {
    goto LABEL_85;
  }
  *(_DWORD *)int buf = 136446210;
  int v41 = "nw_socket_register_notification";
  int v11 = "%{public}s called with null socket_handler, no backtrace";
LABEL_145:
  os_log_type_t v27 = v30;
  os_log_type_t v28 = v31;
  uint32_t v29 = 12;
LABEL_84:
  _os_log_impl(&dword_1830D4000, v27, v28, v11, buf, v29);
LABEL_85:
  if (v8) {
LABEL_86:
  }
    free(v8);
  return 0;
}

void nw_endpoint_proxy_record_result(NWConcrete_nw_endpoint_handler *a1, int a2)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  char v3 = a1;
  unsigned int v4 = v3;
  if (!v3)
  {
    int v13 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v32 = "nw_endpoint_proxy_record_result";
    uint64_t v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (__nwlog_fault(v14, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v15 = __nwlog_obj();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v32 = "nw_endpoint_proxy_record_result";
          _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s called with null child_handler", buf, 0xCu);
        }
      }
      else if (v29)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v15 = __nwlog_obj();
        os_log_type_t v18 = type;
        BOOL v19 = os_log_type_enabled(v15, type);
        if (backtrace_string)
        {
          if (v19)
          {
            *(_DWORD *)int buf = 136446466;
            uint64_t v32 = "nw_endpoint_proxy_record_result";
            __int16 v33 = 2082;
            uint64_t v34 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v15, v18, "%{public}s called with null child_handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_44;
        }
        if (v19)
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v32 = "nw_endpoint_proxy_record_result";
          _os_log_impl(&dword_1830D4000, v15, v18, "%{public}s called with null child_handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        int v15 = __nwlog_obj();
        os_log_type_t v27 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v32 = "nw_endpoint_proxy_record_result";
          _os_log_impl(&dword_1830D4000, v15, v27, "%{public}s called with null child_handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_44:
    if (v14) {
      free(v14);
    }
    goto LABEL_34;
  }
  BOOL v5 = v3;
  id v6 = v5[7];

  if (!v6)
  {
LABEL_33:

LABEL_34:
    return;
  }
  if (nw_protocol_copy_proxy_definition(void)::onceToken != -1) {
    dispatch_once(&nw_protocol_copy_proxy_definition(void)::onceToken, &__block_literal_global_26625);
  }
  cached_content_for_protocol = (unsigned int *)nw_association_get_cached_content_for_protocol(v6, (void *)nw_protocol_copy_proxy_definition(void)::proxy_definition);
  if (cached_content_for_protocol
    || (cached_content_for_protocol = (unsigned int *)malloc_type_calloc(1uLL, 8uLL, 0xEAFB8F1AuLL)) != 0)
  {
    if (a2)
    {
LABEL_8:
      uint64_t v8 = *cached_content_for_protocol + 1;
      uint64_t v9 = v8 << 31 >> 31;
      unsigned int *cached_content_for_protocol = v8;
      if (v9 != v8 || v9 < 0)
      {
        os_log_type_t v10 = cached_content_for_protocol;
        if (gLogDatapath)
        {
          int v11 = __nwlog_obj();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v12 = *cached_content_for_protocol;
            *(_DWORD *)int buf = 136446978;
            uint64_t v32 = "nw_endpoint_proxy_record_result";
            __int16 v33 = 2082;
            uint64_t v34 = "result_cache->success_count";
            __int16 v35 = 2048;
            uint64_t v36 = 1;
            __int16 v37 = 2048;
            uint64_t v38 = v12;
            _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_DEBUG, "%{public}s Overflow: %{public}s, increment %llu, result %llu", buf, 0x2Au);
          }
          os_log_type_t v10 = cached_content_for_protocol;
LABEL_40:

          goto LABEL_29;
        }
        goto LABEL_29;
      }
      goto LABEL_30;
    }
LABEL_26:
    os_log_type_t v10 = cached_content_for_protocol + 1;
    uint64_t v22 = cached_content_for_protocol[1] + 1;
    uint64_t v23 = v22 << 31 >> 31;
    cached_content_for_protocol[1] = v22;
    if (v23 != v22 || v23 < 0)
    {
      if (gLogDatapath)
      {
        int v11 = __nwlog_obj();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v28 = *v10;
          *(_DWORD *)int buf = 136446978;
          uint64_t v32 = "nw_endpoint_proxy_record_result";
          __int16 v33 = 2082;
          uint64_t v34 = "result_cache->failure_count";
          __int16 v35 = 2048;
          uint64_t v36 = 1;
          __int16 v37 = 2048;
          uint64_t v38 = v28;
          _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_DEBUG, "%{public}s Overflow: %{public}s, increment %llu, result %llu", buf, 0x2Au);
        }
        goto LABEL_40;
      }
LABEL_29:
      _DWORD *v10 = -1;
    }
LABEL_30:
    int64_t int64_with_default = networkd_settings_get_int64_with_default((const char *)nw_setting_proxy_fallback_cache_seconds, 1800);
    if (nw_protocol_copy_proxy_definition(void)::onceToken != -1) {
      dispatch_once(&nw_protocol_copy_proxy_definition(void)::onceToken, &__block_literal_global_26625);
    }
    id v25 = (id)nw_protocol_copy_proxy_definition(void)::proxy_definition;
    time_t v26 = time(0);
    nw_association_set_cached_content_for_protocol(v6, v25, (uint64_t)cached_content_for_protocol, v26 + int64_with_default);

    goto LABEL_33;
  }
  os_log_type_t v20 = __nwlog_obj();
  os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
  *(_DWORD *)int buf = 136446722;
  uint64_t v32 = "strict_calloc";
  __int16 v33 = 2048;
  uint64_t v34 = (char *)1;
  __int16 v35 = 2048;
  uint64_t v36 = 8;
  uint32_t v21 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v21))
  {
    free(v21);
    cached_content_for_protocol = 0;
    if (a2) {
      goto LABEL_8;
    }
    goto LABEL_26;
  }
  __break(1u);
}

void sub_18349E8E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_masque_deserialize_options(nw_protocol_definition *a1, const char *a2, uint64_t a3)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    time_t v26 = "nw_masque_deserialize_options";
    int v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v13, &type, &v23)) {
      goto LABEL_49;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)int buf = 136446210;
        time_t v26 = "nw_masque_deserialize_options";
        os_log_type_t v16 = "%{public}s called with null serialized_bytes";
LABEL_48:
        _os_log_impl(&dword_1830D4000, v14, v15, v16, buf, 0xCu);
      }
LABEL_49:
      if (v13) {
        free(v13);
      }
      return 0;
    }
    if (!v23)
    {
      uint64_t v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)int buf = 136446210;
        time_t v26 = "nw_masque_deserialize_options";
        os_log_type_t v16 = "%{public}s called with null serialized_bytes, backtrace limit exceeded";
        goto LABEL_48;
      }
      goto LABEL_49;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v14 = __nwlog_obj();
    os_log_type_t v15 = type;
    BOOL v20 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v20)
      {
        *(_DWORD *)int buf = 136446210;
        time_t v26 = "nw_masque_deserialize_options";
        os_log_type_t v16 = "%{public}s called with null serialized_bytes, no backtrace";
        goto LABEL_48;
      }
      goto LABEL_49;
    }
    if (v20)
    {
      *(_DWORD *)int buf = 136446466;
      time_t v26 = "nw_masque_deserialize_options";
      __int16 v27 = 2082;
      uint64_t v28 = (uint64_t)backtrace_string;
      uint32_t v21 = "%{public}s called with null serialized_bytes, dumping backtrace:%{public}s";
LABEL_38:
      _os_log_impl(&dword_1830D4000, v14, v15, v21, buf, 0x16u);
    }
LABEL_39:
    free(backtrace_string);
    goto LABEL_49;
  }
  if ((unint64_t)a3 <= 0x4B)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    time_t v26 = "nw_masque_deserialize_options";
    int v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v13, &type, &v23)) {
      goto LABEL_49;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)int buf = 136446210;
        time_t v26 = "nw_masque_deserialize_options";
        os_log_type_t v16 = "%{public}s called with null (serialized_length >= sizeof(struct nw_masque_serialized_options))";
        goto LABEL_48;
      }
      goto LABEL_49;
    }
    if (!v23)
    {
      uint64_t v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)int buf = 136446210;
        time_t v26 = "nw_masque_deserialize_options";
        os_log_type_t v16 = "%{public}s called with null (serialized_length >= sizeof(struct nw_masque_serialized_options)), backtrace limit exceeded";
        goto LABEL_48;
      }
      goto LABEL_49;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v14 = __nwlog_obj();
    os_log_type_t v15 = type;
    BOOL v22 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v22)
      {
        *(_DWORD *)int buf = 136446210;
        time_t v26 = "nw_masque_deserialize_options";
        os_log_type_t v16 = "%{public}s called with null (serialized_length >= sizeof(struct nw_masque_serialized_options)), no backtrace";
        goto LABEL_48;
      }
      goto LABEL_49;
    }
    if (v22)
    {
      *(_DWORD *)int buf = 136446466;
      time_t v26 = "nw_masque_deserialize_options";
      __int16 v27 = 2082;
      uint64_t v28 = (uint64_t)backtrace_string;
      uint32_t v21 = "%{public}s called with null (serialized_length >= sizeof(struct nw_masque_serialized_options)), dumping back"
            "trace:%{public}s";
      goto LABEL_38;
    }
    goto LABEL_39;
  }
  BOOL v5 = malloc_type_calloc(1uLL, 0x28uLL, 0xEAFB8F1AuLL);
  if (v5)
  {
LABEL_4:
    *((void *)v5 + 3) = *(void *)a2;
    *((_WORD *)v5 + 16) = *((_WORD *)a2 + 37);
    if (*((_WORD *)a2 + 4) && a2[10]) {
      *(void *)BOOL v5 = nw_endpoint_create_host_with_numeric_port(a2 + 10, *((unsigned __int16 *)a2 + 4));
    }
    if (a3 == 76) {
      return (BOOL)v5;
    }
    id v6 = a2 + 76;
    if (a2[a3 - 1]) {
      return (BOOL)v5;
    }
    if (*((void *)v5 + 1))
    {
      if (*((void *)v5 + 2)) {
        goto LABEL_11;
      }
    }
    else
    {
      *((void *)v5 + 1) = xpc_array_create(0, 0);
      if (*((void *)v5 + 2))
      {
LABEL_11:
        if (a3 < 77) {
          return (BOOL)v5;
        }
        goto LABEL_15;
      }
    }
    *((void *)v5 + 2) = xpc_array_create(0, 0);
    if (a3 < 77) {
      return (BOOL)v5;
    }
LABEL_15:
    int v7 = &a2[a3];
    do
    {
      size_t v8 = strlen(v6);
      if (&v6[v8 + 1] >= v7) {
        break;
      }
      uint64_t v9 = &v6[v8 + 1];
      size_t v10 = strlen(v9);
      if (&v9[v10 + 1] > v7) {
        break;
      }
      unint64_t v11 = (unint64_t)&v9[v10 + 1];
      xpc_array_set_string(*((xpc_object_t *)v5 + 1), 0xFFFFFFFFFFFFFFFFLL, v6);
      xpc_array_set_string(*((xpc_object_t *)v5 + 2), 0xFFFFFFFFFFFFFFFFLL, v9);
      id v6 = (const char *)v11;
    }
    while (v11 < (unint64_t)v7);
    return (BOOL)v5;
  }
  int v17 = __nwlog_obj();
  os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
  *(_DWORD *)int buf = 136446722;
  time_t v26 = "strict_calloc";
  __int16 v27 = 2048;
  uint64_t v28 = 1;
  __int16 v29 = 2048;
  uint64_t v30 = 40;
  os_log_type_t v18 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v18);
  if (!result)
  {
    free(v18);
    goto LABEL_4;
  }
  __break(1u);
  return result;
}

void nw_flow_listener_disconnected(nw_listen_protocol *a1, nw_protocol *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  id v4 = *((id *)a1->handle + 20);
  BOOL v5 = v4;
  if (v4)
  {
    id v6 = (unsigned int *)v4;
    uint64_t v7 = v6[29];

    if (v7 == 2)
    {
      ((void (*)(nw_protocol *, nw_listen_protocol *))a2->callbacks->remove_listen_handler)(a2, a1);
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      size_t v8 = (id)gLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        if (v7 > 5) {
          uint64_t v9 = "unknown-mode";
        }
        else {
          uint64_t v9 = off_1E523FB08[v7];
        }
        int v10 = 136446722;
        unint64_t v11 = "nw_flow_listener_disconnected";
        __int16 v12 = 2082;
        int v13 = v9;
        __int16 v14 = 2082;
        os_log_type_t v15 = "flow";
        _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", (uint8_t *)&v10, 0x20u);
      }
    }
  }
}

void sub_18349F00C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_listen_protocol_new_flow(uint64_t a1, void *a2, void *a3)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    uint64_t v7 = (id *)*(id *)(a1 + 24);
    if (v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      size_t v8 = (id)gLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)int buf = 136446978;
        uint64_t v32 = "nw_listen_protocol_new_flow";
        __int16 v33 = 2114;
        uint64_t v34 = v7;
        __int16 v35 = 2114;
        id v36 = v5;
        __int16 v37 = 2114;
        id v38 = v6;
        _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_DEBUG, "%{public}s Listener %{public}@ received new flow %{public}@ : %{public}@", buf, 0x2Au);
      }

      nw_parameters_set_server_mode(v6, 1);
      [v7[1] updateParametersForNewConnection:v6];
      uint64_t v9 = nw_connection_create_from_protocol_on_nw_queue(v5, v6, *(nw_protocol **)(a1 + 8));
      BOOL v10 = v9 != 0;
      if (v9)
      {
        [v7[1] handleInbound:v9 addProtocolInbox:0];
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v11 = (id)gLogObj;
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v32 = "nw_listen_protocol_new_flow";
          _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_ERROR, "%{public}s nw_connection_create_from_protocol_on_nw_queue failed", buf, 0xCu);
        }
      }
LABEL_11:

      goto LABEL_12;
    }
    int v17 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v32 = "nw_listen_protocol_new_flow";
    os_log_type_t v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (__nwlog_fault(v18, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v19 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v32 = "nw_listen_protocol_new_flow";
          _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s called with null inbox", buf, 0xCu);
        }
      }
      else if (v29)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v19 = __nwlog_obj();
        os_log_type_t v25 = type;
        BOOL v26 = os_log_type_enabled(v19, type);
        if (backtrace_string)
        {
          if (v26)
          {
            *(_DWORD *)int buf = 136446466;
            uint64_t v32 = "nw_listen_protocol_new_flow";
            __int16 v33 = 2082;
            uint64_t v34 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v19, v25, "%{public}s called with null inbox, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_48;
        }
        if (v26)
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v32 = "nw_listen_protocol_new_flow";
          _os_log_impl(&dword_1830D4000, v19, v25, "%{public}s called with null inbox, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        BOOL v19 = __nwlog_obj();
        os_log_type_t v28 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v32 = "nw_listen_protocol_new_flow";
          _os_log_impl(&dword_1830D4000, v19, v28, "%{public}s called with null inbox, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_48:
    if (v18) {
      free(v18);
    }
    BOOL v10 = 0;
    goto LABEL_11;
  }
  int v13 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  uint64_t v32 = "nw_listen_protocol_new_flow";
  __int16 v14 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v29 = 0;
  if (__nwlog_fault(v14, &type, &v29))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v32 = "nw_listen_protocol_new_flow";
        _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s called with null listener", buf, 0xCu);
      }
    }
    else if (v29)
    {
      uint32_t v21 = (char *)__nw_create_backtrace_string();
      os_log_type_t v15 = __nwlog_obj();
      os_log_type_t v22 = type;
      BOOL v23 = os_log_type_enabled(v15, type);
      if (v21)
      {
        if (v23)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v32 = "nw_listen_protocol_new_flow";
          __int16 v33 = 2082;
          uint64_t v34 = v21;
          _os_log_impl(&dword_1830D4000, v15, v22, "%{public}s called with null listener, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v21);
        goto LABEL_42;
      }
      if (v23)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v32 = "nw_listen_protocol_new_flow";
        _os_log_impl(&dword_1830D4000, v15, v22, "%{public}s called with null listener, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v15 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v32 = "nw_listen_protocol_new_flow";
        _os_log_impl(&dword_1830D4000, v15, v27, "%{public}s called with null listener, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_42:
  if (v14) {
    free(v14);
  }
  BOOL v10 = 0;
LABEL_12:

  return v10;
}

void sub_18349F64C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_http1_notify(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v113 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v100 = "nw_http1_get_http1_protocol";
    __int16 v44 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v97 = 0;
    if (!__nwlog_fault(v44, &type, &v97)) {
      goto LABEL_159;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v97)
      {
        long long v45 = __nwlog_obj();
        os_log_type_t v46 = type;
        if (!os_log_type_enabled(v45, type)) {
          goto LABEL_159;
        }
        *(_DWORD *)int buf = 136446210;
        __int16 v100 = "nw_http1_get_http1_protocol";
        BOOL v47 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_158;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      long long v45 = __nwlog_obj();
      os_log_type_t v46 = type;
      BOOL v53 = os_log_type_enabled(v45, type);
      if (!backtrace_string)
      {
        if (!v53) {
          goto LABEL_159;
        }
        *(_DWORD *)int buf = 136446210;
        __int16 v100 = "nw_http1_get_http1_protocol";
        BOOL v47 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_158;
      }
      if (v53)
      {
        *(_DWORD *)int buf = 136446466;
        __int16 v100 = "nw_http1_get_http1_protocol";
        __int16 v101 = 2082;
        __int16 v102 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v45, v46, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_159;
    }
    long long v45 = __nwlog_obj();
    os_log_type_t v46 = type;
    if (!os_log_type_enabled(v45, type)) {
      goto LABEL_159;
    }
    *(_DWORD *)int buf = 136446210;
    __int16 v100 = "nw_http1_get_http1_protocol";
    BOOL v47 = "%{public}s called with null protocol";
LABEL_158:
    _os_log_impl(&dword_1830D4000, v45, v46, v47, buf, 0xCu);
    goto LABEL_159;
  }
  uint64_t v3 = *(void *)(a1 + 40);
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v100 = "nw_http1_get_http1_protocol";
    __int16 v44 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v97 = 0;
    if (!__nwlog_fault(v44, &type, &v97)) {
      goto LABEL_159;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v97)
      {
        long long v45 = __nwlog_obj();
        os_log_type_t v46 = type;
        if (!os_log_type_enabled(v45, type)) {
          goto LABEL_159;
        }
        *(_DWORD *)int buf = 136446210;
        __int16 v100 = "nw_http1_get_http1_protocol";
        BOOL v47 = "%{public}s called with null handle, backtrace limit exceeded";
        goto LABEL_158;
      }
      __int16 v54 = (char *)__nw_create_backtrace_string();
      long long v45 = __nwlog_obj();
      os_log_type_t v46 = type;
      BOOL v55 = os_log_type_enabled(v45, type);
      if (!v54)
      {
        if (!v55) {
          goto LABEL_159;
        }
        *(_DWORD *)int buf = 136446210;
        __int16 v100 = "nw_http1_get_http1_protocol";
        BOOL v47 = "%{public}s called with null handle, no backtrace";
        goto LABEL_158;
      }
      if (v55)
      {
        *(_DWORD *)int buf = 136446466;
        __int16 v100 = "nw_http1_get_http1_protocol";
        __int16 v101 = 2082;
        __int16 v102 = v54;
        os_log_type_t v56 = "%{public}s called with null handle, dumping backtrace:%{public}s";
LABEL_95:
        _os_log_impl(&dword_1830D4000, v45, v46, v56, buf, 0x16u);
      }
LABEL_96:
      free(v54);
      if (!v44)
      {
LABEL_161:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)int buf = 136446210;
        __int16 v100 = "nw_protocol_http1_notify";
        uint64_t v48 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v97 = 0;
        if (!__nwlog_fault(v48, &type, &v97)) {
          goto LABEL_279;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v49 = gLogObj;
          os_log_type_t v50 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_279;
          }
          *(_DWORD *)int buf = 136446210;
          __int16 v100 = "nw_protocol_http1_notify";
          os_log_type_t v51 = "%{public}s called with null http1";
        }
        else
        {
          if (v97)
          {
            BOOL v75 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v76 = gLogObj;
            os_log_type_t v77 = type;
            BOOL v78 = os_log_type_enabled((os_log_t)gLogObj, type);
            if (v75)
            {
              if (v78)
              {
                *(_DWORD *)int buf = 136446466;
                __int16 v100 = "nw_protocol_http1_notify";
                __int16 v101 = 2082;
                __int16 v102 = v75;
                _os_log_impl(&dword_1830D4000, v76, v77, "%{public}s called with null http1, dumping backtrace:%{public}s", buf, 0x16u);
              }
              free(v75);
LABEL_279:
              if (!v48) {
                return;
              }
              goto LABEL_280;
            }
            if (!v78) {
              goto LABEL_279;
            }
            *(_DWORD *)int buf = 136446210;
            __int16 v100 = "nw_protocol_http1_notify";
            os_log_type_t v51 = "%{public}s called with null http1, no backtrace";
            int v79 = v76;
            os_log_type_t v80 = v77;
LABEL_278:
            _os_log_impl(&dword_1830D4000, v79, v80, v51, buf, 0xCu);
            goto LABEL_279;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v49 = gLogObj;
          os_log_type_t v50 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_279;
          }
          *(_DWORD *)int buf = 136446210;
          __int16 v100 = "nw_protocol_http1_notify";
          os_log_type_t v51 = "%{public}s called with null http1, backtrace limit exceeded";
        }
LABEL_277:
        int v79 = v49;
        os_log_type_t v80 = v50;
        goto LABEL_278;
      }
LABEL_160:
      free(v44);
      goto LABEL_161;
    }
    long long v45 = __nwlog_obj();
    os_log_type_t v46 = type;
    if (!os_log_type_enabled(v45, type)) {
      goto LABEL_159;
    }
    *(_DWORD *)int buf = 136446210;
    __int16 v100 = "nw_http1_get_http1_protocol";
    BOOL v47 = "%{public}s called with null handle";
    goto LABEL_158;
  }
  int v5 = *(_DWORD *)(v3 + 24);
  id v6 = *(void **)(a1 + 40);
  if (v5 == 1) {
    goto LABEL_10;
  }
  if (v5 != 2)
  {
    if (v5 != 3) {
      goto LABEL_161;
    }
    uint64_t v7 = *(void *)(v3 + 16);
    if (v7)
    {
      id v6 = (void *)(v7 + 480);
      goto LABEL_10;
    }
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v100 = "nw_http1_get_http1_protocol";
    __int16 v44 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v97 = 0;
    if (__nwlog_fault(v44, &type, &v97))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        long long v45 = __nwlog_obj();
        os_log_type_t v46 = type;
        if (!os_log_type_enabled(v45, type)) {
          goto LABEL_159;
        }
        *(_DWORD *)int buf = 136446210;
        __int16 v100 = "nw_http1_get_http1_protocol";
        BOOL v47 = "%{public}s called with null handle->http1_connection";
        goto LABEL_158;
      }
      if (!v97)
      {
        long long v45 = __nwlog_obj();
        os_log_type_t v46 = type;
        if (!os_log_type_enabled(v45, type)) {
          goto LABEL_159;
        }
        *(_DWORD *)int buf = 136446210;
        __int16 v100 = "nw_http1_get_http1_protocol";
        BOOL v47 = "%{public}s called with null handle->http1_connection, backtrace limit exceeded";
        goto LABEL_158;
      }
      __int16 v54 = (char *)__nw_create_backtrace_string();
      long long v45 = __nwlog_obj();
      os_log_type_t v46 = type;
      BOOL v61 = os_log_type_enabled(v45, type);
      if (!v54)
      {
        if (!v61) {
          goto LABEL_159;
        }
        *(_DWORD *)int buf = 136446210;
        __int16 v100 = "nw_http1_get_http1_protocol";
        BOOL v47 = "%{public}s called with null handle->http1_connection, no backtrace";
        goto LABEL_158;
      }
      if (v61)
      {
        *(_DWORD *)int buf = 136446466;
        __int16 v100 = "nw_http1_get_http1_protocol";
        __int16 v101 = 2082;
        __int16 v102 = v54;
        os_log_type_t v56 = "%{public}s called with null handle->http1_connection, dumping backtrace:%{public}s";
        goto LABEL_95;
      }
      goto LABEL_96;
    }
LABEL_159:
    if (!v44) {
      goto LABEL_161;
    }
    goto LABEL_160;
  }
  uint64_t v8 = *(void *)(v3 + 8);
  if (!v8)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v100 = "nw_http1_get_http1_protocol";
    __int16 v44 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v97 = 0;
    if (!__nwlog_fault(v44, &type, &v97)) {
      goto LABEL_159;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      long long v45 = __nwlog_obj();
      os_log_type_t v46 = type;
      if (!os_log_type_enabled(v45, type)) {
        goto LABEL_159;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v100 = "nw_http1_get_http1_protocol";
      BOOL v47 = "%{public}s called with null handle->http1_stream";
      goto LABEL_158;
    }
    if (!v97)
    {
      long long v45 = __nwlog_obj();
      os_log_type_t v46 = type;
      if (!os_log_type_enabled(v45, type)) {
        goto LABEL_159;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v100 = "nw_http1_get_http1_protocol";
      BOOL v47 = "%{public}s called with null handle->http1_stream, backtrace limit exceeded";
      goto LABEL_158;
    }
    __int16 v54 = (char *)__nw_create_backtrace_string();
    long long v45 = __nwlog_obj();
    os_log_type_t v46 = type;
    BOOL v62 = os_log_type_enabled(v45, type);
    if (!v54)
    {
      if (!v62) {
        goto LABEL_159;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v100 = "nw_http1_get_http1_protocol";
      BOOL v47 = "%{public}s called with null handle->http1_stream, no backtrace";
      goto LABEL_158;
    }
    if (v62)
    {
      *(_DWORD *)int buf = 136446466;
      __int16 v100 = "nw_http1_get_http1_protocol";
      __int16 v101 = 2082;
      __int16 v102 = v54;
      os_log_type_t v56 = "%{public}s called with null handle->http1_stream, dumping backtrace:%{public}s";
      goto LABEL_95;
    }
    goto LABEL_96;
  }
  id v6 = (void *)(v8 + 248);
LABEL_10:
  if (!*v6) {
    goto LABEL_161;
  }
  if (a2)
  {
    switch(a3)
    {
      case 0u:
        __nwlog_obj();
        *(_DWORD *)int buf = 136446210;
        __int16 v100 = "nw_protocol_http1_notify";
        uint64_t v48 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v97 = 0;
        if (!__nwlog_fault(v48, &type, &v97)) {
          goto LABEL_279;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v49 = __nwlog_obj();
          os_log_type_t v50 = type;
          if (!os_log_type_enabled(v49, type)) {
            goto LABEL_279;
          }
          *(_DWORD *)int buf = 136446210;
          __int16 v100 = "nw_protocol_http1_notify";
          os_log_type_t v51 = "%{public}s called with null type";
          goto LABEL_277;
        }
        if (v97)
        {
          uint32_t v57 = (char *)__nw_create_backtrace_string();
          os_log_type_t v49 = __nwlog_obj();
          os_log_type_t v50 = type;
          BOOL v60 = os_log_type_enabled(v49, type);
          if (v57)
          {
            if (!v60) {
              goto LABEL_271;
            }
            *(_DWORD *)int buf = 136446466;
            __int16 v100 = "nw_protocol_http1_notify";
            __int16 v101 = 2082;
            __int16 v102 = v57;
            int v59 = "%{public}s called with null type, dumping backtrace:%{public}s";
            goto LABEL_270;
          }
          if (!v60) {
            goto LABEL_279;
          }
          *(_DWORD *)int buf = 136446210;
          __int16 v100 = "nw_protocol_http1_notify";
          os_log_type_t v51 = "%{public}s called with null type, no backtrace";
        }
        else
        {
          os_log_type_t v49 = __nwlog_obj();
          os_log_type_t v50 = type;
          if (!os_log_type_enabled(v49, type)) {
            goto LABEL_279;
          }
          *(_DWORD *)int buf = 136446210;
          __int16 v100 = "nw_protocol_http1_notify";
          os_log_type_t v51 = "%{public}s called with null type, backtrace limit exceeded";
        }
        goto LABEL_277;
      case 7u:
      case 0x15u:
        return;
      case 0xDu:
      case 0x10u:
        if (v5 == 2)
        {
          int v13 = (uint64_t *)(v3 + 8);
          goto LABEL_44;
        }
        if (v5 != 3) {
          goto LABEL_243;
        }
        uint64_t v12 = *(void *)(v3 + 16);
        if (v12)
        {
          int v13 = (uint64_t *)(v12 + 488);
LABEL_44:
          uint64_t v29 = *v13;
          if (*v13)
          {
            uint64_t v30 = *(void *)(v29 + 256);
            if (v30)
            {
              uint64_t v31 = *(void **)(v30 + 32);
              goto LABEL_57;
            }
            if ((*(unsigned char *)(v29 + 158) & 1) == 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v32 = gLogObj;
              if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v33 = *(void *)(v29 + 256);
                int v34 = *(_DWORD *)(*(void *)(v29 + 248) + 372);
                if (v33) {
                  LODWORD(v33) = *(_DWORD *)(v33 + 860);
                }
                __int16 v35 = off_1E5241E58[a3];
                int v36 = *(_DWORD *)(v29 + 424);
                *(_DWORD *)int buf = 136447746;
                __int16 v100 = "nw_protocol_http1_notify";
                __int16 v101 = 2082;
                __int16 v102 = (char *)(v29 + 74);
                __int16 v103 = 2080;
                __int16 v104 = " ";
                __int16 v105 = 1024;
                int v106 = v34;
                __int16 v107 = 1024;
                int v108 = v33;
                __int16 v109 = 1024;
                int v110 = v36;
                __int16 v111 = 2080;
                __int16 v112 = v35;
                os_log_type_t v27 = "%{public}s %{public}s%s<i%u:c%u:s%u> dropping notification type %s";
                goto LABEL_68;
              }
            }
            return;
          }
LABEL_243:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          *(_DWORD *)int buf = 136446210;
          __int16 v100 = "nw_protocol_http1_notify";
          uint64_t v48 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v97 = 0;
          if (!__nwlog_fault(v48, &type, &v97)) {
            goto LABEL_279;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            os_log_type_t v49 = __nwlog_obj();
            os_log_type_t v50 = type;
            if (!os_log_type_enabled(v49, type)) {
              goto LABEL_279;
            }
            *(_DWORD *)int buf = 136446210;
            __int16 v100 = "nw_protocol_http1_notify";
            os_log_type_t v51 = "%{public}s called with null http1_stream";
            goto LABEL_277;
          }
          if (v97)
          {
            uint32_t v57 = (char *)__nw_create_backtrace_string();
            os_log_type_t v49 = __nwlog_obj();
            os_log_type_t v50 = type;
            BOOL v95 = os_log_type_enabled(v49, type);
            if (v57)
            {
              if (!v95) {
                goto LABEL_271;
              }
              goto LABEL_216;
            }
            if (!v95) {
              goto LABEL_279;
            }
            *(_DWORD *)int buf = 136446210;
            __int16 v100 = "nw_protocol_http1_notify";
            os_log_type_t v51 = "%{public}s called with null http1_stream, no backtrace";
          }
          else
          {
            os_log_type_t v49 = __nwlog_obj();
            os_log_type_t v50 = type;
            if (!os_log_type_enabled(v49, type)) {
              goto LABEL_279;
            }
            *(_DWORD *)int buf = 136446210;
            __int16 v100 = "nw_protocol_http1_notify";
            os_log_type_t v51 = "%{public}s called with null http1_stream, backtrace limit exceeded";
          }
          goto LABEL_277;
        }
        __nwlog_obj();
        *(_DWORD *)int buf = 136446210;
        __int16 v100 = "nw_http1_get_stream_for_protocol";
        uint64_t v71 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v97 = 0;
        if (!__nwlog_fault(v71, &type, &v97)) {
          goto LABEL_241;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          char v72 = __nwlog_obj();
          os_log_type_t v73 = type;
          if (!os_log_type_enabled(v72, type)) {
            goto LABEL_241;
          }
          *(_DWORD *)int buf = 136446210;
          __int16 v100 = "nw_http1_get_stream_for_protocol";
          uint64_t v74 = "%{public}s called with null handle->http1_connection";
        }
        else if (v97)
        {
          int v89 = (char *)__nw_create_backtrace_string();
          char v72 = __nwlog_obj();
          os_log_type_t v73 = type;
          BOOL v90 = os_log_type_enabled(v72, type);
          if (v89)
          {
            if (v90)
            {
              *(_DWORD *)int buf = 136446466;
              __int16 v100 = "nw_http1_get_stream_for_protocol";
              __int16 v101 = 2082;
              __int16 v102 = v89;
              _os_log_impl(&dword_1830D4000, v72, v73, "%{public}s called with null handle->http1_connection, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v89);
            goto LABEL_241;
          }
          if (!v90)
          {
LABEL_241:
            if (v71) {
              free(v71);
            }
            goto LABEL_243;
          }
          *(_DWORD *)int buf = 136446210;
          __int16 v100 = "nw_http1_get_stream_for_protocol";
          uint64_t v74 = "%{public}s called with null handle->http1_connection, no backtrace";
        }
        else
        {
          char v72 = __nwlog_obj();
          os_log_type_t v73 = type;
          if (!os_log_type_enabled(v72, type)) {
            goto LABEL_241;
          }
          *(_DWORD *)int buf = 136446210;
          __int16 v100 = "nw_http1_get_stream_for_protocol";
          uint64_t v74 = "%{public}s called with null handle->http1_connection, backtrace limit exceeded";
        }
        _os_log_impl(&dword_1830D4000, v72, v73, v74, buf, 0xCu);
        goto LABEL_241;
      case 0xFu:
        if (v5 == 2)
        {
          BOOL v10 = (uint64_t *)(v3 + 8);
          goto LABEL_28;
        }
        if (v5 != 3) {
          goto LABEL_209;
        }
        uint64_t v9 = *(void *)(v3 + 16);
        if (v9)
        {
          BOOL v10 = (uint64_t *)(v9 + 488);
LABEL_28:
          uint64_t v15 = *v10;
          if (v15)
          {
            uint64_t v16 = *(void *)(v15 + 48);
            nw_protocol_reset(a1, v16);
            return;
          }
LABEL_209:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          *(_DWORD *)int buf = 136446210;
          __int16 v100 = "nw_protocol_http1_notify";
          uint64_t v48 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v97 = 0;
          if (!__nwlog_fault(v48, &type, &v97)) {
            goto LABEL_279;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v49 = gLogObj;
            os_log_type_t v50 = type;
            if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
              goto LABEL_279;
            }
            *(_DWORD *)int buf = 136446210;
            __int16 v100 = "nw_protocol_http1_notify";
            os_log_type_t v51 = "%{public}s called with null http1_stream";
            goto LABEL_277;
          }
          if (!v97)
          {
            os_log_type_t v49 = __nwlog_obj();
            os_log_type_t v50 = type;
            if (!os_log_type_enabled(v49, type)) {
              goto LABEL_279;
            }
            *(_DWORD *)int buf = 136446210;
            __int16 v100 = "nw_protocol_http1_notify";
            os_log_type_t v51 = "%{public}s called with null http1_stream, backtrace limit exceeded";
            goto LABEL_277;
          }
          uint32_t v57 = (char *)__nw_create_backtrace_string();
          os_log_type_t v49 = __nwlog_obj();
          os_log_type_t v50 = type;
          BOOL v93 = os_log_type_enabled(v49, type);
          if (!v57)
          {
            if (!v93) {
              goto LABEL_279;
            }
            *(_DWORD *)int buf = 136446210;
            __int16 v100 = "nw_protocol_http1_notify";
            os_log_type_t v51 = "%{public}s called with null http1_stream, no backtrace";
            goto LABEL_277;
          }
          if (!v93) {
            goto LABEL_271;
          }
LABEL_216:
          *(_DWORD *)int buf = 136446466;
          __int16 v100 = "nw_protocol_http1_notify";
          __int16 v101 = 2082;
          __int16 v102 = v57;
          int v59 = "%{public}s called with null http1_stream, dumping backtrace:%{public}s";
          goto LABEL_270;
        }
        __nwlog_obj();
        *(_DWORD *)int buf = 136446210;
        __int16 v100 = "nw_http1_get_stream_for_protocol";
        int v63 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v97 = 0;
        if (!__nwlog_fault(v63, &type, &v97)) {
          goto LABEL_207;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v64 = __nwlog_obj();
          os_log_type_t v65 = type;
          if (!os_log_type_enabled(v64, type)) {
            goto LABEL_207;
          }
          *(_DWORD *)int buf = 136446210;
          __int16 v100 = "nw_http1_get_stream_for_protocol";
          int v66 = "%{public}s called with null handle->http1_connection";
        }
        else if (v97)
        {
          __int16 v81 = (char *)__nw_create_backtrace_string();
          os_log_type_t v64 = __nwlog_obj();
          os_log_type_t v65 = type;
          BOOL v82 = os_log_type_enabled(v64, type);
          if (v81)
          {
            if (v82)
            {
              *(_DWORD *)int buf = 136446466;
              __int16 v100 = "nw_http1_get_stream_for_protocol";
              __int16 v101 = 2082;
              __int16 v102 = v81;
              _os_log_impl(&dword_1830D4000, v64, v65, "%{public}s called with null handle->http1_connection, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v81);
            goto LABEL_207;
          }
          if (!v82)
          {
LABEL_207:
            if (v63) {
              free(v63);
            }
            goto LABEL_209;
          }
          *(_DWORD *)int buf = 136446210;
          __int16 v100 = "nw_http1_get_stream_for_protocol";
          int v66 = "%{public}s called with null handle->http1_connection, no backtrace";
        }
        else
        {
          os_log_type_t v64 = __nwlog_obj();
          os_log_type_t v65 = type;
          if (!os_log_type_enabled(v64, type)) {
            goto LABEL_207;
          }
          *(_DWORD *)int buf = 136446210;
          __int16 v100 = "nw_http1_get_stream_for_protocol";
          int v66 = "%{public}s called with null handle->http1_connection, backtrace limit exceeded";
        }
        _os_log_impl(&dword_1830D4000, v64, v65, v66, buf, 0xCu);
        goto LABEL_207;
      case 0x1Au:
        if (v5 != 2)
        {
          if (v5 != 3) {
            goto LABEL_226;
          }
          unint64_t v11 = (uint64_t *)(v3 + 16);
LABEL_34:
          uint64_t v18 = *v11;
          if (*v11)
          {
            uint64_t v19 = *(void *)(v18 + 488);
            if (!v19) {
              return;
            }
            uint64_t v20 = *(void *)(v19 + 32);
            if (!v20) {
              return;
            }
            uint64_t v21 = *(void *)(v18 + 32);
            if (v21 == v20) {
              return;
            }
            nw_protocol_set_output_handler(*(void *)(v18 + 488), v21);
            if (*(unsigned char *)(v19 + 158)) {
              return;
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v22 = gLogObj;
            if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG)) {
              return;
            }
            uint64_t v23 = *(void *)(v19 + 256);
            int v24 = *(_DWORD *)(*(void *)(v19 + 248) + 372);
            if (v23) {
              LODWORD(v23) = *(_DWORD *)(v23 + 860);
            }
            int v25 = *(_DWORD *)(v19 + 424);
            BOOL v26 = *(void **)(v18 + 32);
            *(_DWORD *)int buf = 136447746;
            __int16 v100 = "nw_protocol_http1_notify";
            __int16 v101 = 2082;
            __int16 v102 = (char *)(v19 + 74);
            __int16 v103 = 2080;
            __int16 v104 = " ";
            __int16 v105 = 1024;
            int v106 = v24;
            __int16 v107 = 1024;
            int v108 = v23;
            __int16 v109 = 1024;
            int v110 = v25;
            __int16 v111 = 2048;
            __int16 v112 = v26;
            os_log_type_t v27 = "%{public}s %{public}s%s<i%u:c%u:s%u> Output handler for stream replaced to: %p";
            os_log_type_t v28 = v22;
            goto LABEL_69;
          }
LABEL_226:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          *(_DWORD *)int buf = 136446210;
          __int16 v100 = "nw_protocol_http1_notify";
          uint64_t v48 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v97 = 0;
          if (!__nwlog_fault(v48, &type, &v97)) {
            goto LABEL_279;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v49 = gLogObj;
            os_log_type_t v50 = type;
            if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
              goto LABEL_279;
            }
            *(_DWORD *)int buf = 136446210;
            __int16 v100 = "nw_protocol_http1_notify";
            os_log_type_t v51 = "%{public}s called with null http1_connection";
            goto LABEL_277;
          }
          if (v97)
          {
            uint32_t v57 = (char *)__nw_create_backtrace_string();
            os_log_type_t v49 = __nwlog_obj();
            os_log_type_t v50 = type;
            BOOL v94 = os_log_type_enabled(v49, type);
            if (v57)
            {
              if (!v94) {
                goto LABEL_271;
              }
              goto LABEL_269;
            }
            if (!v94) {
              goto LABEL_279;
            }
            *(_DWORD *)int buf = 136446210;
            __int16 v100 = "nw_protocol_http1_notify";
            os_log_type_t v51 = "%{public}s called with null http1_connection, no backtrace";
          }
          else
          {
            os_log_type_t v49 = __nwlog_obj();
            os_log_type_t v50 = type;
            if (!os_log_type_enabled(v49, type)) {
              goto LABEL_279;
            }
            *(_DWORD *)int buf = 136446210;
            __int16 v100 = "nw_protocol_http1_notify";
            os_log_type_t v51 = "%{public}s called with null http1_connection, backtrace limit exceeded";
          }
          goto LABEL_277;
        }
        uint64_t v17 = *(void *)(v3 + 8);
        if (v17)
        {
          unint64_t v11 = (uint64_t *)(v17 + 256);
          goto LABEL_34;
        }
        __nwlog_obj();
        *(_DWORD *)int buf = 136446210;
        __int16 v100 = "nw_http1_get_connection_for_protocol";
        os_log_type_t v67 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v97 = 0;
        if (!__nwlog_fault(v67, &type, &v97)) {
          goto LABEL_224;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          BOOL v68 = __nwlog_obj();
          os_log_type_t v69 = type;
          if (!os_log_type_enabled(v68, type)) {
            goto LABEL_224;
          }
          *(_DWORD *)int buf = 136446210;
          __int16 v100 = "nw_http1_get_connection_for_protocol";
          os_log_type_t v70 = "%{public}s called with null handle->http1_stream";
        }
        else if (v97)
        {
          char v83 = (char *)__nw_create_backtrace_string();
          BOOL v68 = __nwlog_obj();
          os_log_type_t v69 = type;
          BOOL v84 = os_log_type_enabled(v68, type);
          if (v83)
          {
            if (v84)
            {
              *(_DWORD *)int buf = 136446466;
              __int16 v100 = "nw_http1_get_connection_for_protocol";
              __int16 v101 = 2082;
              __int16 v102 = v83;
              _os_log_impl(&dword_1830D4000, v68, v69, "%{public}s called with null handle->http1_stream, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v83);
            goto LABEL_224;
          }
          if (!v84)
          {
LABEL_224:
            if (v67) {
              free(v67);
            }
            goto LABEL_226;
          }
          *(_DWORD *)int buf = 136446210;
          __int16 v100 = "nw_http1_get_connection_for_protocol";
          os_log_type_t v70 = "%{public}s called with null handle->http1_stream, no backtrace";
        }
        else
        {
          BOOL v68 = __nwlog_obj();
          os_log_type_t v69 = type;
          if (!os_log_type_enabled(v68, type)) {
            goto LABEL_224;
          }
          *(_DWORD *)int buf = 136446210;
          __int16 v100 = "nw_http1_get_connection_for_protocol";
          os_log_type_t v70 = "%{public}s called with null handle->http1_stream, backtrace limit exceeded";
        }
        _os_log_impl(&dword_1830D4000, v68, v69, v70, buf, 0xCu);
        goto LABEL_224;
      default:
        if (v5 != 2)
        {
          if (v5 != 3) {
            goto LABEL_262;
          }
          __int16 v14 = (uint64_t *)(v3 + 16);
LABEL_54:
          uint64_t v38 = *v14;
          if (*v14)
          {
            uint64_t v39 = *(void *)(v38 + 488);
            if (v39)
            {
              uint64_t v31 = *(void **)(v39 + 48);
LABEL_57:
              nw_protocol_notify(v31, a2, a3);
            }
            else if ((*(unsigned char *)(v38 + 158) & 1) == 0)
            {
              uint64_t v32 = __nwlog_obj();
              if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v40 = *(void *)(v38 + 488);
                if (v40) {
                  LODWORD(v40) = *(_DWORD *)(v40 + 424);
                }
                int v41 = *(_DWORD *)(*(void *)(v38 + 480) + 372);
                int v42 = *(_DWORD *)(v38 + 860);
                if (a3 > 0x1A) {
                  int v43 = "unknown";
                }
                else {
                  int v43 = off_1E5241E58[a3];
                }
                *(_DWORD *)int buf = 136447746;
                __int16 v100 = "nw_protocol_http1_notify";
                __int16 v101 = 2082;
                __int16 v102 = (char *)(v38 + 74);
                __int16 v103 = 2080;
                __int16 v104 = " ";
                __int16 v105 = 1024;
                int v106 = v41;
                __int16 v107 = 1024;
                int v108 = v42;
                __int16 v109 = 1024;
                int v110 = v40;
                __int16 v111 = 2080;
                __int16 v112 = (void *)v43;
                os_log_type_t v27 = "%{public}s %{public}s%s<i%u:c%u:s%u> dropping notification type %s";
LABEL_68:
                os_log_type_t v28 = v32;
LABEL_69:
                _os_log_impl(&dword_1830D4000, v28, OS_LOG_TYPE_DEBUG, v27, buf, 0x3Cu);
              }
            }
            return;
          }
LABEL_262:
          __nwlog_obj();
          *(_DWORD *)int buf = 136446210;
          __int16 v100 = "nw_protocol_http1_notify";
          uint64_t v48 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v97 = 0;
          if (!__nwlog_fault(v48, &type, &v97)) {
            goto LABEL_279;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            os_log_type_t v49 = __nwlog_obj();
            os_log_type_t v50 = type;
            if (!os_log_type_enabled(v49, type)) {
              goto LABEL_279;
            }
            *(_DWORD *)int buf = 136446210;
            __int16 v100 = "nw_protocol_http1_notify";
            os_log_type_t v51 = "%{public}s called with null http1_connection";
            goto LABEL_277;
          }
          if (!v97)
          {
            os_log_type_t v49 = __nwlog_obj();
            os_log_type_t v50 = type;
            if (!os_log_type_enabled(v49, type)) {
              goto LABEL_279;
            }
            *(_DWORD *)int buf = 136446210;
            __int16 v100 = "nw_protocol_http1_notify";
            os_log_type_t v51 = "%{public}s called with null http1_connection, backtrace limit exceeded";
            goto LABEL_277;
          }
          uint32_t v57 = (char *)__nw_create_backtrace_string();
          os_log_type_t v49 = __nwlog_obj();
          os_log_type_t v50 = type;
          BOOL v96 = os_log_type_enabled(v49, type);
          if (!v57)
          {
            if (!v96) {
              goto LABEL_279;
            }
            *(_DWORD *)int buf = 136446210;
            __int16 v100 = "nw_protocol_http1_notify";
            os_log_type_t v51 = "%{public}s called with null http1_connection, no backtrace";
            goto LABEL_277;
          }
          if (!v96) {
            goto LABEL_271;
          }
LABEL_269:
          *(_DWORD *)int buf = 136446466;
          __int16 v100 = "nw_protocol_http1_notify";
          __int16 v101 = 2082;
          __int16 v102 = v57;
          int v59 = "%{public}s called with null http1_connection, dumping backtrace:%{public}s";
          goto LABEL_270;
        }
        uint64_t v37 = *(void *)(v3 + 8);
        if (v37)
        {
          __int16 v14 = (uint64_t *)(v37 + 256);
          goto LABEL_54;
        }
        __nwlog_obj();
        *(_DWORD *)int buf = 136446210;
        __int16 v100 = "nw_http1_get_connection_for_protocol";
        __int16 v85 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v97 = 0;
        if (!__nwlog_fault(v85, &type, &v97)) {
          goto LABEL_260;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          __int16 v86 = __nwlog_obj();
          os_log_type_t v87 = type;
          if (!os_log_type_enabled(v86, type)) {
            goto LABEL_260;
          }
          *(_DWORD *)int buf = 136446210;
          __int16 v100 = "nw_http1_get_connection_for_protocol";
          __int16 v88 = "%{public}s called with null handle->http1_stream";
        }
        else if (v97)
        {
          __int16 v91 = (char *)__nw_create_backtrace_string();
          __int16 v86 = __nwlog_obj();
          os_log_type_t v87 = type;
          BOOL v92 = os_log_type_enabled(v86, type);
          if (v91)
          {
            if (v92)
            {
              *(_DWORD *)int buf = 136446466;
              __int16 v100 = "nw_http1_get_connection_for_protocol";
              __int16 v101 = 2082;
              __int16 v102 = v91;
              _os_log_impl(&dword_1830D4000, v86, v87, "%{public}s called with null handle->http1_stream, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v91);
            goto LABEL_260;
          }
          if (!v92)
          {
LABEL_260:
            if (v85) {
              free(v85);
            }
            goto LABEL_262;
          }
          *(_DWORD *)int buf = 136446210;
          __int16 v100 = "nw_http1_get_connection_for_protocol";
          __int16 v88 = "%{public}s called with null handle->http1_stream, no backtrace";
        }
        else
        {
          __int16 v86 = __nwlog_obj();
          os_log_type_t v87 = type;
          if (!os_log_type_enabled(v86, type)) {
            goto LABEL_260;
          }
          *(_DWORD *)int buf = 136446210;
          __int16 v100 = "nw_http1_get_connection_for_protocol";
          __int16 v88 = "%{public}s called with null handle->http1_stream, backtrace limit exceeded";
        }
        _os_log_impl(&dword_1830D4000, v86, v87, v88, buf, 0xCu);
        goto LABEL_260;
    }
  }
  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  __int16 v100 = "nw_protocol_http1_notify";
  uint64_t v48 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v97 = 0;
  if (!__nwlog_fault(v48, &type, &v97)) {
    goto LABEL_279;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v49 = __nwlog_obj();
    os_log_type_t v50 = type;
    if (!os_log_type_enabled(v49, type)) {
      goto LABEL_279;
    }
    *(_DWORD *)int buf = 136446210;
    __int16 v100 = "nw_protocol_http1_notify";
    os_log_type_t v51 = "%{public}s called with null other_protocol";
    goto LABEL_277;
  }
  if (!v97)
  {
    os_log_type_t v49 = __nwlog_obj();
    os_log_type_t v50 = type;
    if (!os_log_type_enabled(v49, type)) {
      goto LABEL_279;
    }
    *(_DWORD *)int buf = 136446210;
    __int16 v100 = "nw_protocol_http1_notify";
    os_log_type_t v51 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    goto LABEL_277;
  }
  uint32_t v57 = (char *)__nw_create_backtrace_string();
  os_log_type_t v49 = __nwlog_obj();
  os_log_type_t v50 = type;
  BOOL v58 = os_log_type_enabled(v49, type);
  if (!v57)
  {
    if (!v58) {
      goto LABEL_279;
    }
    *(_DWORD *)int buf = 136446210;
    __int16 v100 = "nw_protocol_http1_notify";
    os_log_type_t v51 = "%{public}s called with null other_protocol, no backtrace";
    goto LABEL_277;
  }
  if (v58)
  {
    *(_DWORD *)int buf = 136446466;
    __int16 v100 = "nw_protocol_http1_notify";
    __int16 v101 = 2082;
    __int16 v102 = v57;
    int v59 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
LABEL_270:
    _os_log_impl(&dword_1830D4000, v49, v50, v59, buf, 0x16u);
  }
LABEL_271:
  free(v57);
  if (v48) {
LABEL_280:
  }
    free(v48);
}

uint64_t nw_channel_check_defunct(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v12 = "nw_channel_check_defunct";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v9 = 0;
    if (__nwlog_fault(v3, &type, &v9))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v4 = __nwlog_obj();
        os_log_type_t v5 = type;
        if (os_log_type_enabled(v4, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v12 = "nw_channel_check_defunct";
          id v6 = "%{public}s called with null channel";
LABEL_26:
          _os_log_impl(&dword_1830D4000, v4, v5, v6, buf, 0xCu);
        }
      }
      else if (v9)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        id v4 = __nwlog_obj();
        os_log_type_t v5 = type;
        BOOL v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *(_DWORD *)int buf = 136446466;
            uint64_t v12 = "nw_channel_check_defunct";
            __int16 v13 = 2082;
            __int16 v14 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s called with null channel, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_27;
        }
        if (v8)
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v12 = "nw_channel_check_defunct";
          id v6 = "%{public}s called with null channel, no backtrace";
          goto LABEL_26;
        }
      }
      else
      {
        id v4 = __nwlog_obj();
        os_log_type_t v5 = type;
        if (os_log_type_enabled(v4, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v12 = "nw_channel_check_defunct";
          id v6 = "%{public}s called with null channel, backtrace limit exceeded";
          goto LABEL_26;
        }
      }
    }
LABEL_27:
    if (v3) {
      free(v3);
    }
    return 0;
  }
  if (*(void *)(a1 + 136))
  {
    if (((*(unsigned __int16 *)(a1 + 444) | (*(unsigned __int8 *)(a1 + 446) << 16)) & 0x80000) == 0)
    {
      uint64_t result = os_channel_is_defunct();
      if (!result) {
        return result;
      }
      nw_channel_handle_defunct(a1);
    }
  }
  else
  {
    if (_nw_signposts_once != -1) {
      dispatch_once(&_nw_signposts_once, &__block_literal_global_73_88215);
    }
    if (_nw_signposts_enabled)
    {
      if (kdebug_is_enabled()) {
        kdebug_trace();
      }
    }
  }
  return 1;
}

uint64_t http2_create_input_frame(uint64_t a1, uint64_t a2, size_t a3)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v28 = "http2_create_input_frame";
    BOOL v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (!__nwlog_fault(v10, &type, &v25)) {
      goto LABEL_56;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_56;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v28 = "http2_create_input_frame";
      __int16 v13 = "%{public}s called with null http2";
LABEL_55:
      _os_log_impl(&dword_1830D4000, v11, v12, v13, buf, 0xCu);
      goto LABEL_56;
    }
    if (!v25)
    {
      unint64_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v28 = "http2_create_input_frame";
        __int16 v13 = "%{public}s called with null http2, backtrace limit exceeded";
        goto LABEL_55;
      }
      goto LABEL_56;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    unint64_t v11 = __nwlog_obj();
    os_log_type_t v12 = type;
    BOOL v21 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v28 = "http2_create_input_frame";
        __int16 v13 = "%{public}s called with null http2, no backtrace";
        goto LABEL_55;
      }
      goto LABEL_56;
    }
    if (!v21) {
      goto LABEL_42;
    }
    *(_DWORD *)int buf = 136446466;
    os_log_type_t v28 = "http2_create_input_frame";
    __int16 v29 = 2082;
    uint64_t v30 = backtrace_string;
    uint64_t v22 = "%{public}s called with null http2, dumping backtrace:%{public}s";
LABEL_41:
    _os_log_impl(&dword_1830D4000, v11, v12, v22, buf, 0x16u);
    goto LABEL_42;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v28 = "http2_create_input_frame";
    BOOL v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (!__nwlog_fault(v10, &type, &v25)) {
      goto LABEL_56;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_56;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v28 = "http2_create_input_frame";
      __int16 v13 = "%{public}s called with null stream";
      goto LABEL_55;
    }
    if (!v25)
    {
      unint64_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v28 = "http2_create_input_frame";
        __int16 v13 = "%{public}s called with null stream, backtrace limit exceeded";
        goto LABEL_55;
      }
      goto LABEL_56;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    unint64_t v11 = __nwlog_obj();
    os_log_type_t v12 = type;
    BOOL v23 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v28 = "http2_create_input_frame";
        __int16 v13 = "%{public}s called with null stream, no backtrace";
        goto LABEL_55;
      }
      goto LABEL_56;
    }
    if (!v23) {
      goto LABEL_42;
    }
    *(_DWORD *)int buf = 136446466;
    os_log_type_t v28 = "http2_create_input_frame";
    __int16 v29 = 2082;
    uint64_t v30 = backtrace_string;
    uint64_t v22 = "%{public}s called with null stream, dumping backtrace:%{public}s";
    goto LABEL_41;
  }
  if (((*(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    __int16 v14 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v16 = *(_DWORD *)(a2 + 176);
      int v15 = *(_DWORD *)(a2 + 180);
      *(_DWORD *)int buf = 136447490;
      os_log_type_t v28 = "http2_create_input_frame";
      __int16 v29 = 2082;
      uint64_t v30 = (char *)(a2 + 191);
      __int16 v31 = 2080;
      uint64_t v32 = " ";
      __int16 v33 = 1024;
      int v34 = v15;
      __int16 v35 = 1024;
      int v36 = v16;
      __int16 v37 = 1024;
      LODWORD(v38) = a3;
      _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> requested input frame of length %u", buf, 0x32u);
    }
  }
  uint64_t frame = nw_frame_cache_create_frame((uint64_t *)(a1 + 200), a3);
  if (frame)
  {
    uint64_t v7 = frame;
    *(void *)(frame + 16) = 0;
    BOOL v8 = *(uint64_t **)(a1 + 176);
    *(void *)(frame + 24) = v8;
    uint64_t *v8 = frame;
    *(void *)(a1 + 176) = frame + 16;
    *(void *)(frame + 80) = nw_protocol_http2_frame_input_finalizer;
    *(void *)(frame + 88) = 0;
    http2_input_frame_metadata_reset(frame, a1, a2, a3);
    if (((*(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v17 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v19 = *(_DWORD *)(a2 + 176);
        int v18 = *(_DWORD *)(a2 + 180);
        *(_DWORD *)int buf = 136447746;
        os_log_type_t v28 = "http2_create_input_frame";
        __int16 v29 = 2082;
        uint64_t v30 = (char *)(a2 + 191);
        __int16 v31 = 2080;
        uint64_t v32 = " ";
        __int16 v33 = 1024;
        int v34 = v18;
        __int16 v35 = 1024;
        int v36 = v19;
        __int16 v37 = 2048;
        uint64_t v38 = v7;
        __int16 v39 = 1024;
        int v40 = a3;
        _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> input_frame_create returning frame %p for requested length %u", buf, 0x3Cu);
      }
    }
    return v7;
  }
  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v28 = "http2_create_input_frame";
  BOOL v10 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v25 = 0;
  if (!__nwlog_fault(v10, &type, &v25)) {
    goto LABEL_56;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v25)
    {
      unint64_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v28 = "http2_create_input_frame";
        __int16 v13 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_55;
      }
      goto LABEL_56;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    unint64_t v11 = __nwlog_obj();
    os_log_type_t v12 = type;
    BOOL v24 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v24)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v28 = "http2_create_input_frame";
        __int16 v13 = "%{public}s called with null frame, no backtrace";
        goto LABEL_55;
      }
      goto LABEL_56;
    }
    if (v24)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v28 = "http2_create_input_frame";
      __int16 v29 = 2082;
      uint64_t v30 = backtrace_string;
      uint64_t v22 = "%{public}s called with null frame, dumping backtrace:%{public}s";
      goto LABEL_41;
    }
LABEL_42:
    free(backtrace_string);
    goto LABEL_56;
  }
  unint64_t v11 = __nwlog_obj();
  os_log_type_t v12 = type;
  if (os_log_type_enabled(v11, type))
  {
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v28 = "http2_create_input_frame";
    __int16 v13 = "%{public}s called with null frame";
    goto LABEL_55;
  }
LABEL_56:
  if (v10) {
    free(v10);
  }
  return 0;
}

id nw_candidate_create(void *a1, void *a2, void *a3)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  if (v5)
  {
    if (v6)
    {
      id v8 = [[NWCandidate alloc] initCandidate:v6 forManager:v5 evaluator:v7];
      goto LABEL_4;
    }
    __int16 v14 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v26 = "nw_candidate_create";
    unint64_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v11, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v12 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v26 = "nw_candidate_create";
          _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null details", buf, 0xCu);
        }
LABEL_38:

        goto LABEL_39;
      }
      if (!v23)
      {
        os_log_type_t v12 = __nwlog_obj();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v26 = "nw_candidate_create";
          _os_log_impl(&dword_1830D4000, v12, v22, "%{public}s called with null details, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_38;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v20 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v26 = "nw_candidate_create";
          _os_log_impl(&dword_1830D4000, v12, v19, "%{public}s called with null details, no backtrace", buf, 0xCu);
        }
        goto LABEL_38;
      }
      if (v20)
      {
        *(_DWORD *)int buf = 136446466;
        BOOL v26 = "nw_candidate_create";
        __int16 v27 = 2082;
        os_log_type_t v28 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v12, v19, "%{public}s called with null details, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_26;
    }
  }
  else
  {
    BOOL v10 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v26 = "nw_candidate_create";
    unint64_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v11, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v12 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v26 = "nw_candidate_create";
          _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null manager", buf, 0xCu);
        }
        goto LABEL_38;
      }
      if (!v23)
      {
        os_log_type_t v12 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v26 = "nw_candidate_create";
          _os_log_impl(&dword_1830D4000, v12, v21, "%{public}s called with null manager, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_38;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v26 = "nw_candidate_create";
          _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null manager, no backtrace", buf, 0xCu);
        }
        goto LABEL_38;
      }
      if (v18)
      {
        *(_DWORD *)int buf = 136446466;
        BOOL v26 = "nw_candidate_create";
        __int16 v27 = 2082;
        os_log_type_t v28 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null manager, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_26:

      free(backtrace_string);
    }
  }
LABEL_39:
  if (v11) {
    free(v11);
  }
  id v8 = 0;
LABEL_4:

  return v8;
}

void sub_1834A2310(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_socket_reset(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v18 = "nw_socket_reset";
    id v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (!__nwlog_fault(v7, &type, &v15)) {
      goto LABEL_39;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v15)
      {
        id v8 = __nwlog_obj();
        os_log_type_t v9 = type;
        if (!os_log_type_enabled(v8, type)) {
          goto LABEL_39;
        }
        *(_DWORD *)int buf = 136446210;
        BOOL v18 = "nw_socket_reset";
        BOOL v10 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_38;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (!v12) {
          goto LABEL_39;
        }
        *(_DWORD *)int buf = 136446210;
        BOOL v18 = "nw_socket_reset";
        BOOL v10 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_38;
      }
      if (v12)
      {
        *(_DWORD *)int buf = 136446466;
        BOOL v18 = "nw_socket_reset";
        __int16 v19 = 2082;
        BOOL v20 = backtrace_string;
        os_log_type_t v13 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_28:
        _os_log_impl(&dword_1830D4000, v8, v9, v13, buf, 0x16u);
      }
LABEL_29:
      free(backtrace_string);
      goto LABEL_39;
    }
    id v8 = __nwlog_obj();
    os_log_type_t v9 = type;
    if (!os_log_type_enabled(v8, type)) {
      goto LABEL_39;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v18 = "nw_socket_reset";
    BOOL v10 = "%{public}s called with null protocol";
LABEL_38:
    _os_log_impl(&dword_1830D4000, v8, v9, v10, buf, 0xCu);
LABEL_39:
    if (v7) {
      free(v7);
    }
    return 0;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v18 = "nw_socket_reset";
    id v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (!__nwlog_fault(v7, &type, &v15)) {
      goto LABEL_39;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_39;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v18 = "nw_socket_reset";
      BOOL v10 = "%{public}s called with null socket_handler";
      goto LABEL_38;
    }
    if (!v15)
    {
      id v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_39;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v18 = "nw_socket_reset";
      BOOL v10 = "%{public}s called with null socket_handler, backtrace limit exceeded";
      goto LABEL_38;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    id v8 = __nwlog_obj();
    os_log_type_t v9 = type;
    BOOL v14 = os_log_type_enabled(v8, type);
    if (backtrace_string)
    {
      if (v14)
      {
        *(_DWORD *)int buf = 136446466;
        BOOL v18 = "nw_socket_reset";
        __int16 v19 = 2082;
        BOOL v20 = backtrace_string;
        os_log_type_t v13 = "%{public}s called with null socket_handler, dumping backtrace:%{public}s";
        goto LABEL_28;
      }
      goto LABEL_29;
    }
    if (!v14) {
      goto LABEL_39;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v18 = "nw_socket_reset";
    BOOL v10 = "%{public}s called with null socket_handler, no backtrace";
    goto LABEL_38;
  }
  if ((nw_protocol *)a1[2].identifier != a2) {
    return 0;
  }
  nw_socket_cancel_input_source((uint64_t)&a1[1].output_handler);
  callbacks = a1[3].callbacks;
  if (callbacks)
  {
    nw_queue_cancel_source((uint64_t)a1[3].callbacks);
    a1[3].callbacks = 0;
    if ((*(_WORD *)&a1[6].flow_id[13] & 0x800) == 0)
    {
      nw_queue_resume_source((uint64_t)callbacks);
      *(_WORD *)&a1[6].flow_id[13] |= 0x800u;
    }
  }
  uint64_t v5 = *(void *)a1[3].flow_id;
  if (v5)
  {
    nw_queue_cancel_source(v5);
    *(void *)a1[3].flow_uint64_t id = 0;
  }
  nw_protocol_socket_cancel((uint64_t)&a1[1].output_handler);
  *(_DWORD *)&a1[4].flow_id[12] = -1;
  HIDWORD(a1[4].identifier) = 6159;
  a1[3].output_handler_nw_content_context_t context = (void *)0x100000001;
  int v6 = (*(unsigned __int16 *)&a1[6].flow_id[13] | (a1[6].flow_id[15] << 16)) & 0xFC31C0;
  *(_WORD *)&a1[6].flow_id[13] = *(_WORD *)&a1[6].flow_id[13] & 0x31C0 | 0x20;
  a1[6].flow_id[15] = BYTE2(v6);
  nw_socket_initialize_socket(a1);
  return 1;
}

void nw_socket_error(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v39 = "nw_socket_error";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (!__nwlog_fault(v9, &type, &v36)) {
      goto LABEL_67;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v21 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_67;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v39 = "nw_socket_error";
      char v15 = "%{public}s called with null protocol";
LABEL_65:
      __int16 v33 = v21;
      os_log_type_t v34 = v22;
      uint32_t v35 = 12;
      goto LABEL_66;
    }
    if (!v36)
    {
      uint64_t v21 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_67;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v39 = "nw_socket_error";
      char v15 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_65;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v21 = __nwlog_obj();
    os_log_type_t v22 = type;
    BOOL v27 = os_log_type_enabled(v21, type);
    if (!backtrace_string)
    {
      if (!v27) {
        goto LABEL_67;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v39 = "nw_socket_error";
      char v15 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_65;
    }
    if (v27)
    {
      *(_DWORD *)int buf = 136446466;
      __int16 v39 = "nw_socket_error";
      __int16 v40 = 2082;
      uint64_t v41 = backtrace_string;
      os_log_type_t v28 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_48:
      _os_log_impl(&dword_1830D4000, v21, v22, v28, buf, 0x16u);
    }
LABEL_49:
    free(backtrace_string);
    if (!v9) {
      return;
    }
LABEL_68:
    free(v9);
    return;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v39 = "nw_socket_error";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (!__nwlog_fault(v9, &type, &v36)) {
      goto LABEL_67;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v21 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_67;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v39 = "nw_socket_error";
      char v15 = "%{public}s called with null socket_handler";
      goto LABEL_65;
    }
    if (!v36)
    {
      uint64_t v21 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_67;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v39 = "nw_socket_error";
      char v15 = "%{public}s called with null socket_handler, backtrace limit exceeded";
      goto LABEL_65;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v21 = __nwlog_obj();
    os_log_type_t v22 = type;
    BOOL v29 = os_log_type_enabled(v21, type);
    if (!backtrace_string)
    {
      if (!v29) {
        goto LABEL_67;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v39 = "nw_socket_error";
      char v15 = "%{public}s called with null socket_handler, no backtrace";
      goto LABEL_65;
    }
    if (v29)
    {
      *(_DWORD *)int buf = 136446466;
      __int16 v39 = "nw_socket_error";
      __int16 v40 = 2082;
      uint64_t v41 = backtrace_string;
      os_log_type_t v28 = "%{public}s called with null socket_handler, dumping backtrace:%{public}s";
      goto LABEL_48;
    }
    goto LABEL_49;
  }
  identifier = a1[2].identifier;
  if (!identifier || (uint64_t v4 = *(void *)&identifier->name[24]) == 0 || (v5 = *(void (**)(void))(v4 + 56)) == 0)
  {
    __nwlog_obj();
    int v6 = a1[2].identifier;
    id v7 = "invalid";
    if (v6)
    {
      id v8 = *(const char **)&v6->name[16];
      if (v8) {
        id v7 = v8;
      }
    }
    *(_DWORD *)int buf = 136446466;
    __int16 v39 = "nw_socket_error";
    __int16 v40 = 2082;
    uint64_t v41 = (void *)v7;
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (__nwlog_fault(v9, &type, &v36))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (!os_log_type_enabled(v10, type)) {
          goto LABEL_67;
        }
        BOOL v12 = a1[2].identifier;
        os_log_type_t v13 = "invalid";
        if (v12)
        {
          BOOL v14 = *(const char **)&v12->name[16];
          if (v14) {
            os_log_type_t v13 = v14;
          }
        }
        *(_DWORD *)int buf = 136446466;
        __int16 v39 = "nw_socket_error";
        __int16 v40 = 2082;
        uint64_t v41 = (void *)v13;
        char v15 = "%{public}s protocol %{public}s has invalid error callback";
LABEL_56:
        __int16 v33 = v10;
        os_log_type_t v34 = v11;
        uint32_t v35 = 22;
LABEL_66:
        _os_log_impl(&dword_1830D4000, v33, v34, v15, buf, v35);
        goto LABEL_67;
      }
      if (!v36)
      {
        BOOL v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (!os_log_type_enabled(v10, type)) {
          goto LABEL_67;
        }
        char v23 = a1[2].identifier;
        BOOL v24 = "invalid";
        if (v23)
        {
          char v25 = *(const char **)&v23->name[16];
          if (v25) {
            BOOL v24 = v25;
          }
        }
        *(_DWORD *)int buf = 136446466;
        __int16 v39 = "nw_socket_error";
        __int16 v40 = 2082;
        uint64_t v41 = (void *)v24;
        char v15 = "%{public}s protocol %{public}s has invalid error callback, backtrace limit exceeded";
        goto LABEL_56;
      }
      int v16 = (char *)__nw_create_backtrace_string();
      BOOL v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v17 = os_log_type_enabled(v10, type);
      if (!v16)
      {
        if (!v17) {
          goto LABEL_67;
        }
        uint64_t v30 = a1[2].identifier;
        __int16 v31 = "invalid";
        if (v30)
        {
          uint64_t v32 = *(const char **)&v30->name[16];
          if (v32) {
            __int16 v31 = v32;
          }
        }
        *(_DWORD *)int buf = 136446466;
        __int16 v39 = "nw_socket_error";
        __int16 v40 = 2082;
        uint64_t v41 = (void *)v31;
        char v15 = "%{public}s protocol %{public}s has invalid error callback, no backtrace";
        goto LABEL_56;
      }
      if (v17)
      {
        BOOL v18 = a1[2].identifier;
        __int16 v19 = "invalid";
        if (v18)
        {
          BOOL v20 = *(const char **)&v18->name[16];
          if (v20) {
            __int16 v19 = v20;
          }
        }
        *(_DWORD *)int buf = 136446722;
        __int16 v39 = "nw_socket_error";
        __int16 v40 = 2082;
        uint64_t v41 = (void *)v19;
        __int16 v42 = 2082;
        int v43 = v16;
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s protocol %{public}s has invalid error callback, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(v16);
    }
LABEL_67:
    if (!v9) {
      return;
    }
    goto LABEL_68;
  }

  v5();
}

void nw_flow_error(nw_protocol *a1, nw_protocol *a2, unsigned int a3)
{
  uint64_t v5 = a1;
  uint64_t v119 = *MEMORY[0x1E4F143B8];
  uint64_t handle = (id *)a1->handle;
  id v7 = handle[20];
  id v8 = v7;
  if (!v7)
  {
    BOOL v60 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v102 = "nw_flow_error";
    BOOL v61 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v99 = 0;
    if (__nwlog_fault(v61, &type, &v99))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v62 = __nwlog_obj();
        os_log_type_t v63 = type;
        if (os_log_type_enabled(v62, type))
        {
          *(_DWORD *)int buf = 136446210;
          __int16 v102 = "nw_flow_error";
          _os_log_impl(&dword_1830D4000, v62, v63, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v99)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v62 = __nwlog_obj();
        os_log_type_t v65 = type;
        BOOL v66 = os_log_type_enabled(v62, type);
        if (backtrace_string)
        {
          if (v66)
          {
            *(_DWORD *)int buf = 136446466;
            __int16 v102 = "nw_flow_error";
            __int16 v103 = 2082;
            __int16 v104 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v62, v65, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_94;
        }
        if (v66)
        {
          *(_DWORD *)int buf = 136446210;
          __int16 v102 = "nw_flow_error";
          _os_log_impl(&dword_1830D4000, v62, v65, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        BOOL v62 = __nwlog_obj();
        os_log_type_t v80 = type;
        if (os_log_type_enabled(v62, type))
        {
          *(_DWORD *)int buf = 136446210;
          __int16 v102 = "nw_flow_error";
          _os_log_impl(&dword_1830D4000, v62, v80, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_94:
    if (v61) {
      free(v61);
    }
    goto LABEL_64;
  }
  os_log_type_t v9 = (NWConcrete_nw_endpoint_handler *)v7;
  uint64_t mode = v9->mode;

  if (mode == 2)
  {
    os_log_type_t v11 = nw_endpoint_handler_copy_flow(v9);
    __int16 v98 = a2;
    if (a3)
    {
      if (a3 >> 8 == 16776959)
      {
        dns_error = nw_error_create_dns_error(a3);
      }
      else if (a3 + 9899 > 0x63)
      {
        dns_error = nw_error_create_posix_error(a3);
      }
      else
      {
        dns_error = nw_error_create_tls_error(a3);
      }
      id v30 = handle[40];
      handle[40] = dns_error;

      id v31 = handle[40];
      if (v31)
      {
        objc_storeStrong((id *)v11 + 109, v31);
        *((unsigned char *)v11 + 36) &= ~1u;
      }
      if (!nw_endpoint_handler_get_minimize_logging(v9))
      {
        uint64_t v32 = v9;
        char v33 = *((unsigned char *)v32 + 268);

        if ((v33 & 0x20) != 0) {
          goto LABEL_59;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        __int16 v19 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
        {
          loga = v19;
          os_log_type_t v34 = v32;

          uint32_t v35 = v34;
          char v36 = *((unsigned char *)v32 + 268);

          if (v36) {
            __int16 v37 = "dry-run ";
          }
          else {
            __int16 v37 = "";
          }
          nw_endpoint_t v38 = nw_endpoint_handler_copy_endpoint(v35);
          logging_description = nw_endpoint_get_logging_description(v38);
          __int16 v39 = v35;
          __int16 v40 = v39;
          uint64_t v41 = v39[30];
          BOOL v92 = v5;
          if (v41 > 5) {
            __int16 v42 = "unknown-state";
          }
          else {
            __int16 v42 = off_1E523FB38[v41];
          }
          BOOL v84 = v42;
          __int16 v86 = v37;
          id_str = v34->id_str;

          uint64_t v44 = v40;
          long long v45 = v44;
          nw_endpoint_t v87 = v38;
          os_log_type_t v46 = v11;
          BOOL v47 = "path";
          switch(v9->mode)
          {
            case 0:
              break;
            case 1:
              BOOL v47 = "resolver";
              break;
            case 2:
              BOOL v47 = nw_endpoint_flow_mode_string(v44[31]);
              break;
            case 3:
              BOOL v47 = "proxy";
              break;
            case 4:
              BOOL v47 = "fallback";
              break;
            case 5:
              BOOL v47 = "transform";
              break;
            default:
              BOOL v47 = "unknown-mode";
              break;
          }

          os_log_type_t v51 = v45;
          os_unfair_lock_lock((os_unfair_lock_t)v51 + 28);
          id v52 = v51[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v51 + 28);

          name = "?";
          if (v98 && v98->identifier) {
            name = v98->identifier->name;
          }
          os_log_type_t v11 = v46;
          __int16 v19 = loga;
          id v54 = handle[40];
          *(_DWORD *)int buf = 136448258;
          __int16 v102 = "nw_flow_error";
          __int16 v103 = 2082;
          __int16 v104 = id_str;
          __int16 v105 = 2082;
          int v106 = v86;
          __int16 v107 = 2082;
          int v108 = logging_description;
          __int16 v109 = 2082;
          int v110 = v84;
          __int16 v111 = 2082;
          __int16 v112 = v47;
          __int16 v113 = 2114;
          id v114 = v52;
          __int16 v115 = 2082;
          uint64_t v116 = name;
          __int16 v117 = 2114;
          id v118 = v54;
          _os_log_impl(&dword_1830D4000, loga, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Output protocol (%{public}s) sent error: %{public}@", buf, 0x5Cu);

          uint64_t v5 = v92;
        }
        goto LABEL_58;
      }
      if ((nw_endpoint_handler_get_logging_disabled(v9) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        __int16 v19 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
        {
          BOOL v93 = v5;
          BOOL v82 = v11;
          logb = nw_endpoint_handler_get_id_string(v9);
          BOOL v90 = nw_endpoint_handler_dry_run_string(v9);
          nw_endpoint_t v67 = nw_endpoint_handler_copy_endpoint(v9);
          BOOL v68 = nw_endpoint_get_logging_description(v67);
          os_log_type_t v69 = nw_endpoint_handler_state_string(v9);
          os_log_type_t v70 = nw_endpoint_handler_mode_string(v9);
          id v71 = nw_endpoint_handler_copy_current_path(v9);
          char v72 = v71;
          os_log_type_t v73 = "?";
          if (v98 && v98->identifier) {
            os_log_type_t v73 = v98->identifier->name;
          }
          id v74 = handle[40];
          *(_DWORD *)int buf = 136448258;
          __int16 v102 = "nw_flow_error";
          __int16 v103 = 2082;
          __int16 v104 = (void *)logb;
          __int16 v105 = 2082;
          int v106 = v90;
          __int16 v107 = 2082;
          int v108 = v68;
          __int16 v109 = 2082;
          int v110 = v69;
          __int16 v111 = 2082;
          __int16 v112 = v70;
          __int16 v113 = 2114;
          id v114 = v71;
          __int16 v115 = 2082;
          uint64_t v116 = v73;
          __int16 v117 = 2114;
          id v118 = v74;
          _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Output protocol (%{public}s) sent error: %{public}@", buf, 0x5Cu);

          os_log_type_t v11 = v82;
          uint64_t v5 = v93;
        }
LABEL_58:
      }
    }
    else
    {
      id v15 = handle[40];
      handle[40] = 0;

      int v16 = (void *)*((void *)v11 + 109);
      *((void *)v11 + 109) = 0;

      *((unsigned char *)v11 + 36) &= ~1u;
      if (!nw_endpoint_handler_get_minimize_logging(v9))
      {
        BOOL v17 = v9;
        char v18 = *((unsigned char *)v17 + 268);

        if ((v18 & 0x20) != 0) {
          goto LABEL_59;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        __int16 v19 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
        {
          log = v19;
          __int16 v81 = v11;
          BOOL v20 = v17;

          uint64_t v21 = v20;
          char v22 = *((unsigned char *)v17 + 268);

          if (v22) {
            char v23 = "dry-run ";
          }
          else {
            char v23 = "";
          }
          nw_endpoint_t v24 = nw_endpoint_handler_copy_endpoint(v21);
          char v25 = nw_endpoint_get_logging_description(v24);
          __int16 v88 = v23;
          __int16 v85 = v20->id_str;
          BOOL v26 = v21;
          BOOL v27 = v26;
          uint64_t v28 = v26[30];
          if (v28 > 5) {
            BOOL v29 = "unknown-state";
          }
          else {
            BOOL v29 = off_1E523FB38[v28];
          }

          uint64_t v48 = v27;
          os_log_type_t v49 = v48;
          os_log_type_t v50 = "path";
          switch(v9->mode)
          {
            case 0:
              break;
            case 1:
              os_log_type_t v50 = "resolver";
              break;
            case 2:
              os_log_type_t v50 = nw_endpoint_flow_mode_string(v48[31]);
              break;
            case 3:
              os_log_type_t v50 = "proxy";
              break;
            case 4:
              os_log_type_t v50 = "fallback";
              break;
            case 5:
              os_log_type_t v50 = "transform";
              break;
            default:
              os_log_type_t v50 = "unknown-mode";
              break;
          }

          BOOL v55 = v49;
          os_unfair_lock_lock((os_unfair_lock_t)v55 + 28);
          id v56 = v55[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v55 + 28);

          *(_DWORD *)int buf = 136447746;
          __int16 v102 = "nw_flow_error";
          __int16 v103 = 2082;
          __int16 v104 = v85;
          __int16 v105 = 2082;
          int v106 = v88;
          __int16 v107 = 2082;
          int v108 = v25;
          __int16 v109 = 2082;
          int v110 = v29;
          __int16 v111 = 2082;
          __int16 v112 = v50;
          __int16 v113 = 2114;
          id v114 = v56;
          __int16 v19 = log;
          _os_log_impl(&dword_1830D4000, log, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Output protocol cleared error", buf, 0x48u);

          os_log_type_t v11 = v81;
        }
        goto LABEL_58;
      }
      if ((nw_endpoint_handler_get_logging_disabled(v9) & 1) == 0)
      {
        char v83 = v11;
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        __int16 v19 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
        {
          logc = nw_endpoint_handler_get_id_string(v9);
          __int16 v91 = nw_endpoint_handler_dry_run_string(v9);
          nw_endpoint_t v75 = nw_endpoint_handler_copy_endpoint(v9);
          uint64_t v76 = nw_endpoint_get_logging_description(v75);
          os_log_type_t v77 = nw_endpoint_handler_state_string(v9);
          BOOL v78 = nw_endpoint_handler_mode_string(v9);
          id v79 = nw_endpoint_handler_copy_current_path(v9);
          *(_DWORD *)int buf = 136447746;
          __int16 v102 = "nw_flow_error";
          __int16 v103 = 2082;
          __int16 v104 = (void *)logc;
          __int16 v105 = 2082;
          int v106 = v91;
          __int16 v107 = 2082;
          int v108 = v76;
          __int16 v109 = 2082;
          int v110 = v77;
          __int16 v111 = 2082;
          __int16 v112 = v78;
          __int16 v113 = 2114;
          id v114 = v79;
          _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Output protocol cleared error", buf, 0x48u);

          os_log_type_t v11 = v83;
        }
        goto LABEL_58;
      }
    }
LABEL_59:
    default_input_handler = v5->default_input_handler;
    if (default_input_handler)
    {
      callbacks = default_input_handler->callbacks;
      if (callbacks)
      {
        error = (void (*)(void))callbacks->error;
        if (error) {
          error();
        }
      }
    }

    goto LABEL_64;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v13 = (id)gLogObj;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    if (mode > 5) {
      BOOL v14 = "unknown-mode";
    }
    else {
      BOOL v14 = off_1E523FB08[mode];
    }
    *(_DWORD *)int buf = 136446722;
    __int16 v102 = "nw_flow_error";
    __int16 v103 = 2082;
    __int16 v104 = (void *)v14;
    __int16 v105 = 2082;
    int v106 = "flow";
    _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
  }

LABEL_64:
}

void sub_1834A39AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1834A3A3C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void (**)(uint64_t, uint64_t))(a1 + 32);
  swift_retain();
  swift_unknownObjectRetain();
  v5(a2, a3);
  swift_release();

  return swift_unknownObjectRelease();
}

uint64_t NSURLSessionTask._nwActivity.setter(uint64_t a1)
{
  if (a1)
  {
    swift_getObjectType();
    swift_unknownObjectRetain();
    __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_1E8F61E90);
    if (swift_dynamicCast()) {
      uint64_t v2 = v4;
    }
    else {
      uint64_t v2 = 0;
    }
  }
  else
  {
    uint64_t v2 = 0;
  }
  objc_msgSend(v1, sel_set_nw_activity_, v2);
  swift_unknownObjectRelease();
  return swift_release();
}

uint64_t sub_1834A3B60()
{
  id v1 = objc_msgSend(*(id *)(*(void *)v0 + 16), sel_description);
  uint64_t v2 = sub_183D44AFC();

  return v2;
}

unsigned int *sub_1834A3BBC(unsigned int *result, uint64_t a2)
{
  if (a2 < 2) {
    unint64_t v2 = (*result | ((unint64_t)*((unsigned __int8 *)result + 4) << 32)) & 0x3FFFFFFFFLL | (a2 << 38);
  }
  else {
    unint64_t v2 = (a2 - 2) | 0xFFFFFF8000000000;
  }
  *uint64_t result = v2;
  *((unsigned char *)result + 4) = BYTE4(v2);
  return result;
}

uint64_t _s7Network10NWListenerC5StateO2eeoiySbAE_AEtFZ_0(unsigned int *a1, unsigned int *a2)
{
  unsigned int v2 = *((unsigned __int8 *)a1 + 4);
  unint64_t v3 = *a1 | ((unint64_t)*((unsigned __int8 *)a1 + 4) << 32);
  unint64_t v4 = *a2 | ((unint64_t)*((unsigned __int8 *)a2 + 4) << 32);
  unsigned int v5 = v2 >> 6;
  if (!v5)
  {
    if (((v4 >> 38) & 3) != 0) {
      return 0;
    }
    LODWORD(v7) = BYTE4(v4);
    if (HIDWORD(v3))
    {
      if (HIDWORD(v3) == 1) {
        return v7 == 1 && v3 == *a2;
      }
      return v7 == 2 && v3 == *a2;
    }
LABEL_25:
    if (!v7)
    {
      int v11 = sub_183D449BC();
      if (v11 == sub_183D449BC()) {
        return 1;
      }
    }
    return 0;
  }
  if (v5 == 1)
  {
    if (((v4 >> 38) & 3) != 1) {
      return 0;
    }
    uint64_t v6 = HIDWORD(v3) & 0x3F;
    uint64_t v7 = HIDWORD(v4) & 0x3F;
    if (v6)
    {
      if (v6 == 1) {
        return v7 == 1 && v3 == *a2;
      }
      return v7 == 2 && v3 == *a2;
    }
    goto LABEL_25;
  }
  uint64_t v10 = 0x8000000000;
  if (v3 == 0x8000000000 || (uint64_t v10 = 0x8000000001, v3 == 0x8000000001))
  {
    if ((v4 & 0xFFFFFFFFFFLL) == v10) {
      return 1;
    }
  }
  else if ((v4 & 0xFFFFFFFFFFLL) == 0x8000000002)
  {
    return 1;
  }
  return 0;
}

void sub_1834A3CFC()
{
  sub_1834A5418(319, (unint64_t *)&qword_1EB266AE0, (uint64_t (*)(uint64_t))type metadata accessor for NWEndpoint, MEMORY[0x1E4FBB718]);
  if (v0 <= 0x3F) {
    swift_initStructMetadata();
  }
}

uint64_t NWPath.availableInterfaces.getter()
{
  return swift_bridgeObjectRetain();
}

uint64_t sub_1834A3DF8(uint64_t (*a1)(void))
{
  uint64_t result = *(void *)(v1 + *(int *)(type metadata accessor for NWPath(0) + 52));
  if (result) {
    return a1();
  }
  return result;
}

uint64_t NWPath.isConstrained.getter()
{
  return sub_1834A3DF8((uint64_t (*)(void))nw_path_is_constrained);
}

uint64_t NWPath.isExpensive.getter()
{
  return *(unsigned __int8 *)(v0 + 16);
}

uint64_t sub_1834A3E58(unsigned __int8 *a1)
{
  return *a1;
}

uint64_t sub_1834A3E60()
{
  uint64_t result = swift_checkMetadataState();
  if (v1 <= 0x3F)
  {
    swift_initStructMetadata();
    return 0;
  }
  return result;
}

uint64_t type metadata accessor for UncheckedSendable()
{
  return __swift_instantiateGenericMetadata();
}

void *sub_1834A3F08(void *a1, void *a2, uint64_t a3, void (*a4)(void, uint64_t, uint64_t))
{
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  uint64_t v7 = a2[2];
  a4(*a2, v6, v7);
  *a1 = v5;
  a1[1] = v6;
  a1[2] = v7;
  return a1;
}

uint64_t static NWApplicationID.self.getter@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result = nw_application_id_create_self();
  *a1 = result;
  return result;
}

uint64_t NWApplicationID.nw.getter()
{
  return swift_unknownObjectRetain();
}

uint64_t sub_1834A3F88(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a2 - 8);
  uint64_t v7 = MEMORY[0x1F4188790](a1);
  os_log_type_t v9 = (char *)&v17 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v7);
  int v11 = (char *)&v17 - v10;
  if (sub_183D44D8C())
  {
    BOOL v17 = *(uint64_t (**)(char *, uint64_t, uint64_t))(v6 + 16);
    uint64_t v18 = a1;
    uint64_t v12 = v17(v11, a1, a2);
    MEMORY[0x1F4188790](v12);
    *(&v17 - 2) = (uint64_t (*)(char *, uint64_t, uint64_t))a2;
    *(&v17 - 1) = (uint64_t (*)(char *, uint64_t, uint64_t))a3;
    sub_183D44D7C();
    if (v21[1])
    {
      uint64_t v13 = v21[0];
    }
    else
    {
      v17(v9, (uint64_t)v11, a2);
      __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F644A0);
      if (swift_dynamicCast())
      {
        sub_1834D9964(v19, (uint64_t)v21);
        __swift_project_boxed_opaque_existential_2(v21, v22);
        if (sub_183D4573C())
        {
          __swift_project_boxed_opaque_existential_2(v21, v22);
          sub_183D4572C();
          BOOL v14 = *(void (**)(char *, uint64_t))(v6 + 8);
          v14(v11, a2);
          uint64_t v13 = *(void *)&v19[0];
          __swift_destroy_boxed_opaque_existential_2((uint64_t)v21);
          v14((char *)v18, a2);
          return v13;
        }
        __swift_destroy_boxed_opaque_existential_2((uint64_t)v21);
      }
      else
      {
        uint64_t v20 = 0;
        memset(v19, 0, sizeof(v19));
        sub_1834FC4F4((uint64_t)v19);
      }
      uint64_t v13 = sub_1835A5378((uint64_t)v11, a2, a3);
    }
    id v15 = *(void (**)(char *, uint64_t))(v6 + 8);
    v15(v11, a2);
    v15((char *)v18, a2);
  }
  else
  {
    uint64_t v13 = sub_1835A355C(a1, a2, a3);
    (*(void (**)(uint64_t, uint64_t))(v6 + 8))(a1, a2);
  }
  return v13;
}

uint64_t sub_1834A42B0@<X0>(char *a1@<X0>, char *a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X4>, char *a6@<X5>, char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v28 = a5;
  if ((a4 & 0x2000000000000000) != 0) {
    uint64_t v9 = HIBYTE(a4) & 0xF;
  }
  else {
    uint64_t v9 = a3 & 0xFFFFFFFFFFFFLL;
  }
  if (!v9)
  {
LABEL_28:
    uint64_t v22 = v28;
    sub_1834BE9E4(a1, a2, v28, a6, a7, a8);
    return sub_18312A0D8(v22);
  }
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = a4 & 0xFFFFFFFFFFFFFFLL;
  uint64_t v15 = (a4 & 0xFFFFFFFFFFFFFFFLL) + 32;
  while (1)
  {
    if ((a4 & 0x1000000000000000) != 0)
    {
      uint64_t result = sub_183D4546C();
      goto LABEL_16;
    }
    if ((a4 & 0x2000000000000000) == 0)
    {
      uint64_t v16 = v15;
      if ((a3 & 0x1000000000000000) == 0) {
        uint64_t v16 = sub_183D4557C();
      }
      uint64_t result = *(unsigned __int8 *)(v16 + v13);
      if (*(char *)(v16 + v13) < 0)
      {
        switch(__clz(result ^ 0xFF))
        {
          case 0x1Au:
            uint64_t v18 = (char *)(v13 + v16);
            goto LABEL_21;
          case 0x1Bu:
            uint64_t v20 = (char *)(v13 + v16);
            goto LABEL_25;
          case 0x1Cu:
            uint64_t v21 = (char *)(v13 + v16);
            goto LABEL_27;
          default:
            break;
        }
      }
LABEL_15:
      uint64_t v19 = 1;
      goto LABEL_16;
    }
    v27[0] = a3;
    v27[1] = v14;
    uint64_t result = *((unsigned __int8 *)v27 + v13);
    if ((*((char *)v27 + v13) & 0x80000000) == 0) {
      goto LABEL_15;
    }
    switch(__clz(result ^ 0xFF))
    {
      case 0x1Au:
        uint64_t v18 = (char *)v27 + v13;
LABEL_21:
        uint64_t result = v18[1] & 0x3F | ((result & 0x1F) << 6);
        uint64_t v19 = 2;
        break;
      case 0x1Bu:
        uint64_t v20 = (char *)v27 + v13;
LABEL_25:
        uint64_t result = v20[2] & 0x3F | ((v20[1] & 0x3F) << 6);
        uint64_t v19 = 3;
        break;
      case 0x1Cu:
        uint64_t v21 = (char *)v27 + v13;
LABEL_27:
        uint64_t result = v21[3] & 0x3F | ((v21[2] & 0x3F) << 6);
        uint64_t v19 = 4;
        break;
      default:
        goto LABEL_15;
    }
LABEL_16:
    if (__OFADD__(v12, 1)) {
      break;
    }
    v13 += v19;
    a1[v12++] = result;
    if (v13 >= v9) {
      goto LABEL_28;
    }
  }
  __break(1u);
  return result;
}

uint64_t _s7Network13NWProtocolTCPC7OptionsCfD_0()
{
  swift_unknownObjectRelease();

  return swift_deallocClassInstance();
}

uint64_t type metadata accessor for NWProtocolTCP.Options()
{
  return self;
}

uint64_t NWProtocolTCP.Options.init()()
{
  *(void *)(v0 + 16) = nw_tcp_create_options();
  return v0;
}

uint64_t type metadata accessor for NWPathMonitor()
{
  return self;
}

void sub_1834A4558()
{
  sub_1834A5418(319, &qword_1EB266A48, type metadata accessor for NWPath, MEMORY[0x1E4FBB718]);
  if (v0 <= 0x3F) {
    swift_initStructMetadata();
  }
}

uint64_t type metadata accessor for NWParameters()
{
  return self;
}

uint64_t sub_1834A4678@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  return sub_1834A4764(a1, a2);
}

uint64_t sub_1834A4690@<X0>(void *a1@<X0>, uint64_t (*a2)(void)@<X1>, void (*a3)(void)@<X2>, uint64_t *a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v8 = a2(*a1);
  a3();
  uint64_t v9 = swift_allocObject();
  __swift_instantiateConcreteTypeFromMangledName(a4);
  uint64_t result = swift_allocObject();
  *(_DWORD *)(result + 24) = 0;
  *(void *)(result + 16) = v8;
  *(void *)(v9 + 16) = result;
  *a5 = v9;
  return result;
}

uint64_t sub_1834A471C@<X0>(void *a1@<X0>, uint64_t *a2@<X8>)
{
  return sub_1834A4690(a1, (uint64_t (*)(void))nw_parameters_copy_default_protocol_stack, (void (*)(void))type metadata accessor for NWParameters.ProtocolStack, &qword_1E8F61E78, a2);
}

uint64_t sub_1834A4764@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  *a2 = *a1;
  return swift_unknownObjectRetain();
}

uint64_t _s7Network12NWParametersC13ProtocolStackCfD_0()
{
  swift_release();

  return swift_deallocClassInstance();
}

uint64_t type metadata accessor for NWParameters.ProtocolStack()
{
  return self;
}

uint64_t sub_1834A47E4(nw_protocol_stack_t *a1)
{
  return sub_1834A4800(a1, *(void *)(v1 + 16));
}

uint64_t sub_1834A4800(nw_protocol_stack_t *a1, unint64_t a2)
{
  unint64_t v3 = *a1;
  nw_protocol_stack_clear_application_protocols(*a1);
  if (a2 >> 62) {
    goto LABEL_15;
  }
  uint64_t v4 = *(void *)((a2 & 0xFFFFFFFFFFFFFF8) + 0x10);
  swift_bridgeObjectRetain();
  for (; v4; uint64_t v4 = sub_183D456DC())
  {
    if ((a2 & 0xC000000000000001) != 0)
    {
      while (1)
      {
        BOOL v5 = __OFSUB__(v4--, 1);
        if (v5) {
          break;
        }
        uint64_t v6 = MEMORY[0x1853148B0](v4, a2);
        nw_protocol_stack_prepend_application_protocol(v3, *(nw_protocol_options_t *)(v6 + 16));
        swift_unknownObjectRelease();
        if (!v4) {
          return swift_bridgeObjectRelease();
        }
      }
      __break(1u);
    }
    else
    {
      unint64_t v7 = *(void *)((a2 & 0xFFFFFFFFFFFFFF8) + 0x10);
      unint64_t v8 = v4 - 1;
      while (1)
      {
        BOOL v5 = __OFSUB__(v4--, 1);
        if (v5) {
          break;
        }
        if (v8 >= v7) {
          goto LABEL_14;
        }
        nw_protocol_stack_prepend_application_protocol(v3, *(nw_protocol_options_t *)(*(void *)(a2 + 32 + 8 * v4) + 16));
        if (!v4) {
          return swift_bridgeObjectRelease();
        }
      }
    }
    __break(1u);
LABEL_14:
    __break(1u);
LABEL_15:
    swift_bridgeObjectRetain();
  }
  return swift_bridgeObjectRelease();
}

void sub_1834A4914(nw_protocol_stack_t *a1)
{
}

void sub_1834A492C(nw_protocol_stack_t *a1)
{
  nw_protocol_stack_set_transport_protocol(*a1, *(nw_protocol_options_t *)(v1 + 16));
}

uint64_t sub_1834A495C()
{
  uint64_t result = type metadata accessor for NWEndpoint();
  if (v1 <= 0x3F)
  {
    uint64_t result = swift_updateClassMetadata2();
    if (!result) {
      return 0;
    }
  }
  return result;
}

uint64_t sub_1834A4A04(uint64_t a1, NSObject **a2, uint64_t *a3)
{
  uint64_t v4 = *a2;
  type metadata accessor for NWConnection.ContentContext();
  uint64_t v5 = swift_allocObject();
  *(void *)(v5 + 16) = v4;
  *(void *)(v5 + 48) = 0;
  *(void *)(v5 + 56) = 0;
  *(void *)(v5 + 40) = 0;
  uint64_t v6 = swift_unknownObjectRetain_n();
  *(unsigned char *)(v5 + 64) = nw_content_context_get_is_final(v6);
  nw_content_context_get_identifier(v4);
  uint64_t v7 = sub_183D44C9C();
  uint64_t v9 = v8;
  uint64_t result = swift_unknownObjectRelease();
  *(void *)(v5 + 24) = v7;
  *(void *)(v5 + 32) = v9;
  *a3 = v5;
  return result;
}

uint64_t sub_1834A4A90(uint64_t a1)
{
  return sub_1834A4A04(a1, (NSObject **)&_nw_content_context_default_message, &qword_1E8F61D40);
}

ValueMetadata *type metadata accessor for NWConnection.LockedState()
{
  return &type metadata for NWConnection.LockedState;
}

uint64_t sub_1834A4AB4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F41863F8](a1, a2, a3, 16);
}

uint64_t destroy for NWInterface()
{
  return swift_unknownObjectRelease();
}

uint64_t storeEnumTagSinglePayload for NWInterface(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0x7FFFFFFE)
  {
    *(void *)uint64_t result = a2 - 0x7FFFFFFF;
    if (a3 >= 0x7FFFFFFF) {
      *(unsigned char *)(result + 8) = 1;
    }
  }
  else
  {
    if (a3 >= 0x7FFFFFFF) {
      *(unsigned char *)(result + 8) = 0;
    }
    if (a2) {
      *(void *)uint64_t result = a2;
    }
  }
  return result;
}

uint64_t getEnumTagSinglePayload for NWInterface(uint64_t *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0x7FFFFFFF && *((unsigned char *)a1 + 8)) {
    return (*(_DWORD *)a1 + 0x7FFFFFFF);
  }
  uint64_t v3 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF) {
    LODWORD(v3) = -1;
  }
  int v4 = v3 - 1;
  if (v4 < 0) {
    int v4 = -1;
  }
  return (v4 + 1);
}

void *initializeBufferWithCopyOfBuffer for NWInterface(void *a1, void *a2)
{
  *a1 = *a2;
  swift_unknownObjectRetain();
  return a1;
}

NSObject *NWInterface.type.getter@<X0>(unsigned char *a1@<X8>)
{
  uint64_t result = *v1;
  if (*v1)
  {
    uint64_t result = nw_interface_get_type(result);
    if (result >= 5) {
      char v4 = 0;
    }
    else {
      char v4 = (char)result;
    }
  }
  else
  {
    char v4 = 0;
  }
  *a1 = v4;
  return result;
}

unsigned char *_s7Network11NWInterfaceV13InterfaceTypeOwst_0(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 4 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 4) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFC) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xFB)
  {
    unsigned int v6 = ((a2 - 252) >> 8) + 1;
    *uint64_t result = a2 + 4;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        break;
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *uint64_t result = a2 + 4;
        break;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for NWInterface.InterfaceType()
{
  return &type metadata for NWInterface.InterfaceType;
}

uint64_t getEnumTagSinglePayload for IPv6Address.Scope(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xFC) {
    goto LABEL_17;
  }
  if (a2 + 4 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 4) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 4;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 4;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 4;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 5;
  int v8 = v6 - 5;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

uint64_t type metadata accessor for NWListener()
{
  return self;
}

void NWListener.init(using:on:)(uint64_t a1, unsigned __int16 *a2)
{
  int v4 = v2;
  int v6 = *a2;
  __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F61E60);
  uint64_t v7 = swift_allocObject();
  *(_DWORD *)(v7 + 192) = 0;
  *(_OWORD *)(v7 + 16) = 0u;
  *(_OWORD *)(v7 + 32) = 0u;
  *(_OWORD *)(v7 + 48) = 0u;
  *(_OWORD *)(v7 + 64) = 0u;
  *(_OWORD *)(v7 + 80) = 0u;
  *(_OWORD *)(v7 + 96) = 0u;
  *(_OWORD *)(v7 + 112) = 0u;
  *(_OWORD *)(v7 + 128) = 0u;
  *(_OWORD *)(v7 + 144) = 0u;
  *(_OWORD *)(v7 + 155) = 0u;
  *(void *)(v7 + 176) = 0;
  *(_DWORD *)(v7 + 184) = 0;
  *(_WORD *)(v7 + 188) = 128;
  v4[2] = v7;
  if (v6)
  {
    parameters[0] = 0;
    parameters[1] = (nw_parameters_t)0xE000000000000000;
    sub_183D4566C();
    int v8 = (os_unfair_lock_s *)0xE000000000000000;
    uint64_t v9 = *(os_unfair_lock_s **)(a1 + 16);
    uint64_t v10 = v9 + 4;
    int v11 = v9 + 6;
    os_unfair_lock_lock(v9 + 6);
    sub_1834A4678(v10, parameters);
    if (!v3)
    {
      os_unfair_lock_unlock(v11);
      uint64_t v12 = parameters[0];
      uint64_t v13 = sub_183D44BAC();
      swift_bridgeObjectRelease();
      nw_listener_t v14 = nw_listener_create_with_port((const char *)(v13 + 32), v12);
      swift_unknownObjectRelease();
      swift_release();
      if (v14)
      {
LABEL_4:
        v4[3] = v14;
        v4[4] = a1;
        return;
      }
      goto LABEL_7;
    }
    os_unfair_lock_unlock(v11);
    __break(1u);
  }
  else
  {
    uint64_t v15 = *(os_unfair_lock_s **)(a1 + 16);
    uint64_t v16 = v15 + 4;
    int v8 = v15 + 6;
    os_unfair_lock_lock(v15 + 6);
    sub_1834A4678(v16, parameters);
    if (!v3)
    {
      os_unfair_lock_unlock(v8);
      nw_listener_t v14 = nw_listener_create(parameters[0]);
      swift_unknownObjectRelease();
      if (v14) {
        goto LABEL_4;
      }
LABEL_7:
      sub_1834AC424();
      swift_allocError();
      *(_DWORD *)uint64_t v17 = 22;
      *(unsigned char *)(v17 + 4) = 0;
      swift_willThrow();
      swift_release();
      swift_release();
      swift_deallocPartialClassInstance();
      return;
    }
  }
  os_unfair_lock_unlock(v8);
  __break(1u);
}

void sub_1834A4FC0(uint64_t a1)
{
  uint64_t v3 = *(void **)(v1 + 16);
  int v4 = *(void **)(a1 + 160);
  id v5 = v3;

  *(void *)(a1 + 160) = v3;
  *(unsigned char *)(a1 + 173) = 1;
}

uint64_t sub_1834A500C@<X0>(nw_error_t error@<X1>, uint64_t result@<X0>, uint64_t a3@<X8>)
{
  switch((int)result)
  {
    case 0:
      uint64_t result = swift_unknownObjectRelease();
      unint64_t v5 = 0x8000000000;
      break;
    case 1:
      if (error)
      {
        nw_error_domain_t error_domain = nw_error_get_error_domain(error);
        switch(error_domain)
        {
          case nw_error_domain_tls:
            unsigned int error_code = nw_error_get_error_code(error);
            uint64_t result = swift_unknownObjectRelease();
            unint64_t v5 = error_code | 0x200000000;
            break;
          case nw_error_domain_dns:
            unsigned int v9 = nw_error_get_error_code(error);
            uint64_t result = swift_unknownObjectRelease();
            unint64_t v5 = v9 | 0x100000000;
            break;
          case nw_error_domain_posix:
            nw_error_get_error_code(error);
            uint64_t v7 = sub_183D449AC();
            uint64_t result = swift_unknownObjectRelease();
            unint64_t v5 = 22;
            if ((v7 & 0x100000000) == 0) {
              unint64_t v5 = v7;
            }
            break;
          default:
            uint64_t result = swift_unknownObjectRelease();
            unint64_t v5 = 22;
            break;
        }
      }
      else
      {
        unint64_t v5 = 50;
      }
      break;
    case 2:
      uint64_t result = swift_unknownObjectRelease();
      unint64_t v5 = 0x8000000001;
      break;
    case 3:
      uint64_t result = (uint64_t)sub_1832E6D08(error, (uint64_t)&v10);
      unint64_t v5 = 0x4000000016;
      if (v11 != 255) {
        unint64_t v5 = v10 | ((unint64_t)v11 << 32) | 0x4000000000;
      }
      break;
    default:
      uint64_t result = swift_unknownObjectRelease();
      unint64_t v5 = 0x8000000002;
      break;
  }
  *(_DWORD *)a3 = v5;
  *(unsigned char *)(a3 + 4) = BYTE4(v5);
  return result;
}

ValueMetadata *type metadata accessor for NWListener.State()
{
  return &type metadata for NWListener.State;
}

uint64_t sub_1834A519C(uint64_t *a1)
{
  uint64_t v4 = *(void *)(v1 + 16);
  uint64_t v3 = *(void *)(v1 + 24);
  uint64_t v5 = *a1;
  sub_18315ED5C(v4);
  uint64_t result = sub_18313D870(v5);
  *a1 = v4;
  a1[1] = v3;
  return result;
}

void sub_1834A51F8(uint64_t a1, uint64_t a2)
{
  sub_1834A52EC(a1, a2, *(void *)(v2 + 16), *(void (**)(int *))(v2 + 24));
}

uint64_t sub_1834A5204@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return sub_1834A5224(a1, *(unsigned int *)(v2 + 16), *(NSObject **)(v2 + 24), a2);
}

uint64_t sub_1834A5224@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, NSObject *a3@<X2>, uint64_t a4@<X8>)
{
  swift_unknownObjectRetain();
  uint64_t result = sub_1834A500C(a3, a2, (uint64_t)&v11);
  unsigned int v9 = v11;
  unint64_t v10 = v11 | ((unint64_t)v12 << 32);
  *(unsigned char *)(a1 + 172) = v12;
  *(_DWORD *)(a1 + 168) = v9;
  if (v10 >= 0x8000000002)
  {
    uint64_t result = nw_utilities_minos_atleast(1);
    if (result)
    {
      sub_18313D870(*(void *)(a1 + 32));
      *(void *)(a1 + 32) = 0;
      *(void *)(a1 + 40) = 0;
      sub_18313D870(*(void *)(a1 + 16));
      *(void *)(a1 + 16) = 0;
      *(void *)(a1 + 24) = 0;
      sub_18313D870(*(void *)a1);
      *(void *)a1 = 0;
      *(void *)(a1 + 8) = 0;
      uint64_t result = sub_18313D870(*(void *)(a1 + 48));
      *(void *)(a1 + 48) = 0;
      *(void *)(a1 + 56) = 0;
    }
  }
  *(_DWORD *)a4 = v10;
  *(unsigned char *)(a4 + 4) = BYTE4(v10);
  return result;
}

void sub_1834A52EC(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(int *))
{
  uint64_t v5 = *(os_unfair_lock_s **)(a3 + 16);
  uint64_t v6 = (uint64_t)&v5[4];
  uint64_t v7 = v5 + 48;
  os_unfair_lock_lock(v5 + 48);
  sub_1834A5204(v6, (uint64_t)&v8);
  os_unfair_lock_unlock(v7);
  if (a4) {
    a4(&v8);
  }
}

uint64_t sub_1834A538C@<X0>(uint64_t a1@<X0>, uint64_t (**a2)()@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  if (v3)
  {
    uint64_t v5 = swift_allocObject();
    *(void *)(v5 + 16) = v3;
    *(void *)(v5 + 24) = v4;
    uint64_t v6 = sub_18313D760;
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v5 = 0;
  }
  *a2 = v6;
  a2[1] = (uint64_t (*)())v5;
  return sub_18315ED5C(v3);
}

ValueMetadata *type metadata accessor for NWListener.LockedState()
{
  return &type metadata for NWListener.LockedState;
}

void sub_1834A5418(uint64_t a1, unint64_t *a2, uint64_t (*a3)(uint64_t), uint64_t (*a4)(uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v7 = a3(255);
    unint64_t v8 = a4(a1, v7);
    if (!v9) {
      atomic_store(v8, a2);
    }
  }
}

uint64_t sub_1834A547C()
{
  uint64_t result = sub_183D4447C();
  if (v1 <= 0x3F)
  {
    swift_initEnumMetadataMultiPayload();
    return 0;
  }
  return result;
}

uint64_t sub_1834A552C()
{
  return sub_183D4589C();
}

ValueMetadata *type metadata accessor for NWEndpoint.Port()
{
  return &type metadata for NWEndpoint.Port;
}

uint64_t NWEndpoint.Port.init(rawValue:)@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(_WORD *)a2 = result;
  *(unsigned char *)(a2 + 2) = 0;
  return result;
}

uint64_t NWActivity.domain.getter()
{
  return *(void *)(v0 + 24);
}

uint64_t NWActivity.init(token:)(uint64_t a1)
{
  uint64_t v2 = v1;
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v16 = sub_183D445DC();
  WORD4(v16) = v4;
  BYTE10(v16) = v5;
  BYTE11(v16) = v6;
  BYTE12(v16) = v7;
  BYTE13(v16) = v8;
  BYTE14(v16) = v9;
  HIBYTE(v16) = v10;
  unsigned int v11 = nw_activity_create_from_token(&v16);
  if (v11)
  {
    unsigned __int8 v12 = v11;
    uint64_t v13 = sub_183D445FC();
    nw_listener_t v14 = *(void (**)(uint64_t, uint64_t))(*(void *)(v13 - 8) + 8);
    swift_unknownObjectRetain();
    v14(a1, v13);
    v2[3] = 0;
    v2[4] = 0;
    v2[2] = v12;
    swift_unknownObjectRelease();
    return (uint64_t)v2;
  }
  else
  {
    uint64_t result = sub_183D456CC();
    __break(1u);
  }
  return result;
}

uint64_t NWActivity.token.getter()
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  long long v2 = 0uLL;
  nw_activity_get_token(*(void **)(v0 + 16), &v2);
  return sub_183D445CC();
}

uint64_t NWActivity.label.getter()
{
  return *(void *)(v0 + 32);
}

uint64_t NWActivity.nw.getter@<X0>(void *a1@<X8>)
{
  uint64_t v3 = *(void *)(v1 + 16);
  a1[3] = swift_getObjectType();
  *a1 = v3;

  return swift_unknownObjectRetain();
}

void sub_1834A5C20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1834A7A70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1834A9AF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1834AA328(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location)
{
  objc_destroyWeak(v19);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1834AB628(_Unwind_Exception *a1)
{
}

void sub_1834AB73C(_Unwind_Exception *exception_object)
{
}

uint64_t sub_1834ABE4C()
{
  nw_protocol_definition_t v0 = nw_protocol_copy_ws_definition();
  type metadata accessor for NWProtocolDefinition();
  uint64_t v1 = swift_allocObject();
  *(void *)(v1 + 32) = v0;
  id v2 = objc_msgSend((id)swift_unknownObjectRetain(), sel_description);
  uint64_t v3 = sub_183D44AFC();
  uint64_t v5 = v4;

  uint64_t result = swift_unknownObjectRelease();
  *(void *)(v1 + 16) = v3;
  *(void *)(v1 + 24) = v5;
  off_1E8F61FE8 = (_UNKNOWN *)v1;
  return result;
}

uint64_t static NWProtocolWebSocket.definition.getter()
{
  if (qword_1E8F61FE0 != -1) {
    swift_once();
  }

  return swift_retain();
}

uint64_t static NWProtocolWebSocket.Version.== infix(_:_:)()
{
  return 1;
}

uint64_t NWProtocolWebSocket.Version.hash(into:)()
{
  return sub_183D45B0C();
}

uint64_t NWProtocolWebSocket.Version.hashValue.getter()
{
  return sub_183D45B4C();
}

uint64_t sub_1834ABFB0()
{
  return 1;
}

uint64_t sub_1834ABFB8()
{
  return sub_183D45B4C();
}

uint64_t sub_1834ABFFC()
{
  return sub_183D45B0C();
}

uint64_t sub_1834AC024()
{
  return sub_183D45B4C();
}

Network::NWProtocolWebSocket::Opcode_optional __swiftcall NWProtocolWebSocket.Opcode.init(rawValue:)(Network::NWProtocolWebSocket::Opcode_optional rawValue)
{
  if (rawValue.value > 0xAu) {
    unsigned char *v1 = 6;
  }
  else {
    unsigned char *v1 = byte_183D535D6[rawValue.value];
  }
  return rawValue;
}

unint64_t NWProtocolWebSocket.Opcode.rawValue.getter()
{
  return 0xA0908020100uLL >> (8 * *v0);
}

BOOL sub_1834AC0B0(unsigned char *a1, unsigned char *a2)
{
  return (0xA0908020100uLL >> (8 * *a1)) == (0xA0908020100uLL >> (8 * *a2));
}

uint64_t sub_1834AC0E8()
{
  return sub_183D45B4C();
}

uint64_t sub_1834AC140()
{
  return sub_183D45B1C();
}

uint64_t sub_1834AC180()
{
  return sub_183D45B4C();
}

Network::NWProtocolWebSocket::Opcode_optional sub_1834AC1D4(Swift::UInt8 *a1)
{
  return NWProtocolWebSocket.Opcode.init(rawValue:)(*a1);
}

void sub_1834AC1DC(unsigned char *a1@<X8>)
{
  *a1 = 0xA0908020100uLL >> (8 * *v1);
}

Network::NWProtocolWebSocket::CloseCode::Defined_optional __swiftcall NWProtocolWebSocket.CloseCode.Defined.init(rawValue:)(Swift::UInt16 rawValue)
{
  if ((unsigned __int16)(rawValue - 1000) > 0xFu) {
    unsigned char *v1 = 12;
  }
  else {
    unsigned char *v1 = byte_183D53650[(__int16)(rawValue - 1000)];
  }
  return (Network::NWProtocolWebSocket::CloseCode::Defined_optional)rawValue;
}

uint64_t NWProtocolWebSocket.CloseCode.Defined.rawValue.getter()
{
  return word_183D5362C[*v0];
}

BOOL sub_1834AC244(char *a1, char *a2)
{
  return word_183D5362C[*a1] == word_183D5362C[*a2];
}

uint64_t sub_1834AC268()
{
  return sub_183D45B4C();
}

uint64_t sub_1834AC2B8()
{
  return sub_183D45B2C();
}

uint64_t sub_1834AC2F0()
{
  return sub_183D45B4C();
}

Network::NWProtocolWebSocket::CloseCode::Defined_optional sub_1834AC33C(Swift::UInt16 *a1)
{
  return NWProtocolWebSocket.CloseCode.Defined.init(rawValue:)(*a1);
}

void sub_1834AC344(_WORD *a1@<X8>)
{
  *a1 = word_183D5362C[*v1];
}

uint64_t NWProtocolWebSocket.CloseCode.init(rawValue:)@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  if ((unsigned __int16)(result - 1000) > 0x7CFu)
  {
    if ((unsigned __int16)(result - 3000) < 0x3E8u)
    {
      char v3 = 1;
      goto LABEL_8;
    }
    if ((unsigned __int16)(result - 4000) < 0x3E8u)
    {
      char v3 = 2;
      goto LABEL_8;
    }
  }
  else
  {
    NWProtocolWebSocket.CloseCode.Defined.init(rawValue:)(result);
    uint64_t result = v5;
    if (v5 != 12)
    {
      char v3 = 0;
LABEL_8:
      *(_WORD *)a2 = result;
      *(unsigned char *)(a2 + 2) = v3;
      return result;
    }
  }
  sub_1834AC424();
  swift_allocError();
  *(_DWORD *)uint64_t v4 = 22;
  *(unsigned char *)(v4 + 4) = 0;
  return swift_willThrow();
}

unint64_t sub_1834AC424()
{
  unint64_t result = qword_1E8F61D20;
  if (!qword_1E8F61D20)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F61D20);
  }
  return result;
}

uint64_t sub_1834AC480@<X0>(uint64_t *a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *a1;
  uint64_t result = swift_beginAccess();
  *a2 = *(unsigned char *)(v3 + 24);
  return result;
}

void sub_1834AC4C8(char *a1, uint64_t *a2)
{
  char v2 = *a1;
  uint64_t v3 = *a2;
  swift_beginAccess();
  *(unsigned char *)(v3 + 24) = v2;
  nw_ws_options_set_auto_reply_ping(*(nw_protocol_options_t *)(v3 + 16), v2);
}

uint64_t sub_1834AC518()
{
  swift_beginAccess();
  return *(unsigned __int8 *)(v0 + 24);
}

void sub_1834AC54C(char a1)
{
  swift_beginAccess();
  *(unsigned char *)(v1 + 24) = a1;
  nw_ws_options_set_auto_reply_ping(*(nw_protocol_options_t *)(v1 + 16), a1 & 1);
}

void (*sub_1834AC598(uint64_t a1))(uint64_t a1, char a2)
{
  *(void *)(a1 + 24) = v1;
  swift_beginAccess();
  return sub_1834AC5F0;
}

void sub_1834AC5F0(uint64_t a1, char a2)
{
  swift_endAccess();
  if ((a2 & 1) == 0)
  {
    uint64_t v4 = *(void *)(a1 + 24);
    unsigned __int8 v5 = *(NSObject **)(v4 + 16);
    char v6 = *(unsigned char *)(v4 + 24);
    nw_ws_options_set_auto_reply_ping(v5, v6);
  }
}

uint64_t sub_1834AC644@<X0>(uint64_t *a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *a1;
  uint64_t result = swift_beginAccess();
  *a2 = *(void *)(v3 + 32);
  return result;
}

void sub_1834AC68C(size_t *a1, uint64_t *a2)
{
  size_t v2 = *a1;
  uint64_t v3 = *a2;
  swift_beginAccess();
  *(void *)(v3 + 32) = v2;
  nw_ws_options_set_maximum_message_size(*(nw_protocol_options_t *)(v3 + 16), v2);
}

uint64_t sub_1834AC6DC()
{
  swift_beginAccess();
  return *(void *)(v0 + 32);
}

void sub_1834AC710(size_t a1)
{
  swift_beginAccess();
  *(void *)(v1 + 32) = a1;
  nw_ws_options_set_maximum_message_size(*(nw_protocol_options_t *)(v1 + 16), a1);
}

void (*sub_1834AC75C(uint64_t a1))(uint64_t a1, char a2)
{
  *(void *)(a1 + 24) = v1;
  swift_beginAccess();
  return sub_1834AC7B4;
}

void sub_1834AC7B4(uint64_t a1, char a2)
{
  swift_endAccess();
  if ((a2 & 1) == 0)
  {
    uint64_t v4 = *(void *)(a1 + 24);
    unsigned __int8 v5 = *(NSObject **)(v4 + 16);
    size_t v6 = *(void *)(v4 + 32);
    nw_ws_options_set_maximum_message_size(v5, v6);
  }
}

uint64_t sub_1834AC808@<X0>(uint64_t *a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *a1;
  uint64_t result = swift_beginAccess();
  *a2 = *(unsigned char *)(v3 + 40);
  return result;
}

void sub_1834AC850(char *a1, uint64_t *a2)
{
  char v2 = *a1;
  uint64_t v3 = *a2;
  swift_beginAccess();
  *(unsigned char *)(v3 + 40) = v2;
  nw_ws_options_set_skip_handshake(*(nw_protocol_options_t *)(v3 + 16), v2);
}

uint64_t sub_1834AC8A0()
{
  swift_beginAccess();
  return *(unsigned __int8 *)(v0 + 40);
}

void sub_1834AC8D4(char a1)
{
  swift_beginAccess();
  *(unsigned char *)(v1 + 40) = a1;
  nw_ws_options_set_skip_handshake(*(nw_protocol_options_t *)(v1 + 16), a1 & 1);
}

void (*sub_1834AC920(uint64_t a1))(uint64_t a1, char a2)
{
  *(void *)(a1 + 24) = v1;
  swift_beginAccess();
  return sub_1834AC978;
}

void sub_1834AC978(uint64_t a1, char a2)
{
  swift_endAccess();
  if ((a2 & 1) == 0)
  {
    uint64_t v4 = *(void *)(a1 + 24);
    unsigned __int8 v5 = *(NSObject **)(v4 + 16);
    char v6 = *(unsigned char *)(v4 + 40);
    nw_ws_options_set_skip_handshake(v5, v6);
  }
}

BOOL sub_1834AC9CC(NSObject *a1)
{
  uint64_t v1 = nw_protocol_options_copy_definition(a1);
  char v2 = nw_protocol_copy_ws_definition();
  BOOL is_equal = nw_protocol_definition_is_equal(v1, v2);
  swift_unknownObjectRelease();
  swift_unknownObjectRelease();
  return is_equal;
}

uint64_t NWProtocolWebSocket.Options.__allocating_init(_:)()
{
  uint64_t v0 = swift_allocObject();
  *(unsigned char *)(v0 + 24) = 0;
  *(void *)(v0 + 32) = 0;
  *(unsigned char *)(v0 + 40) = 0;
  *(void *)(v0 + 16) = nw_ws_create_options(nw_ws_version_13);
  return v0;
}

uint64_t NWProtocolWebSocket.Options.init(_:)()
{
  *(unsigned char *)(v0 + 24) = 0;
  *(void *)(v0 + 32) = 0;
  *(unsigned char *)(v0 + 40) = 0;
  *(void *)(v0 + 16) = nw_ws_create_options(nw_ws_version_13);
  return v0;
}

uint64_t sub_1834ACAA0(uint64_t a1)
{
  uint64_t result = swift_allocObject();
  *(unsigned char *)(result + 24) = 0;
  *(void *)(result + 32) = 0;
  *(unsigned char *)(result + 40) = 0;
  *(void *)(result + 16) = a1;
  return result;
}

uint64_t sub_1834ACAE0(uint64_t result)
{
  uint64_t v2 = *(void *)(result + 16);
  if (v2)
  {
    uint64_t v3 = *(NSObject **)(v1 + 16);
    uint64_t v4 = swift_bridgeObjectRetain() + 56;
    do
    {
      unsigned __int8 v5 = (const char *)(sub_183D44BAC() + 32);
      uint64_t v6 = sub_183D44BAC();
      nw_ws_options_add_additional_header(v3, v5, (const char *)(v6 + 32));
      swift_release();
      swift_release();
      v4 += 32;
      --v2;
    }
    while (v2);
    return swift_bridgeObjectRelease();
  }
  return result;
}

uint64_t sub_1834ACBA8(uint64_t result)
{
  uint64_t v2 = *(void *)(result + 16);
  if (v2)
  {
    uint64_t v3 = *(NSObject **)(v1 + 16);
    uint64_t v4 = swift_bridgeObjectRetain() + 40;
    do
    {
      uint64_t v5 = sub_183D44BAC();
      nw_ws_options_add_subprotocol(v3, (const char *)(v5 + 32));
      swift_release();
      v4 += 16;
      --v2;
    }
    while (v2);
    return swift_bridgeObjectRelease();
  }
  return result;
}

void sub_1834ACC40(NSObject *a1, uint64_t a2, uint64_t a3)
{
  char v7 = *(NSObject **)(v3 + 16);
  uint64_t v8 = swift_allocObject();
  *(void *)(v8 + 16) = a2;
  *(void *)(v8 + 24) = a3;
  v10[4] = sub_1834ADE6C;
  v10[5] = v8;
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 1107296256;
  v10[2] = sub_1834AD334;
  v10[3] = &block_descriptor;
  char v9 = _Block_copy(v10);
  swift_retain();
  swift_release();
  nw_ws_options_set_client_request_handler(v7, a1, v9);
  _Block_release(v9);
}

uint64_t sub_1834ACD2C(NSObject *a1, void (*a2)(uint64_t *__return_ptr, uint64_t, uint64_t))
{
  uint64_t v4 = MEMORY[0x1E4FBC860];
  uint64_t v31 = MEMORY[0x1E4FBC860];
  uint64_t v5 = swift_allocObject();
  *(void *)(v5 + 16) = &v31;
  uint64_t v6 = swift_allocObject();
  *(void *)(v6 + 16) = sub_1834AEF48;
  *(void *)(v6 + 24) = v5;
  BOOL v29 = sub_1834AEF60;
  uint64_t v30 = v6;
  uint64_t aBlock = MEMORY[0x1E4F143A8];
  uint64_t v26 = 1107296256;
  BOOL v27 = sub_1834BFC00;
  uint64_t v28 = &block_descriptor_84;
  char v7 = _Block_copy(&aBlock);
  swift_retain();
  swift_release();
  nw_ws_request_enumerate_subprotocols(a1, v7);
  _Block_release(v7);
  LOBYTE(v7) = swift_isEscapingClosureAtFileLocation();
  uint64_t result = swift_release();
  if (v7)
  {
    __break(1u);
    goto LABEL_17;
  }
  uint64_t v24 = v4;
  uint64_t v9 = swift_allocObject();
  *(void *)(v9 + 16) = &v24;
  uint64_t v10 = swift_allocObject();
  *(void *)(v10 + 16) = sub_1834AEF78;
  *(void *)(v10 + 24) = v9;
  BOOL v29 = sub_1834AF048;
  uint64_t v30 = v10;
  uint64_t aBlock = MEMORY[0x1E4F143A8];
  uint64_t v26 = 1107296256;
  BOOL v27 = sub_1834AD194;
  uint64_t v28 = &block_descriptor_94;
  unsigned int v11 = _Block_copy(&aBlock);
  swift_retain();
  swift_release();
  nw_ws_request_enumerate_additional_headers(a1, v11);
  _Block_release(v11);
  char isEscapingClosureAtFileLocation = swift_isEscapingClosureAtFileLocation();
  uint64_t result = swift_release();
  if (isEscapingClosureAtFileLocation)
  {
LABEL_17:
    __break(1u);
    return result;
  }
  uint64_t v13 = v31;
  swift_bridgeObjectRetain();
  uint64_t v14 = swift_bridgeObjectRetain();
  uint64_t v15 = sub_1834AD1C8(v14);
  swift_bridgeObjectRelease();
  a2(&aBlock, v13, v15);
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  long long v16 = v28;
  if ((_BYTE)aBlock) {
    nw_ws_response_status_t v17 = nw_ws_response_status_reject;
  }
  else {
    nw_ws_response_status_t v17 = nw_ws_response_status_accept;
  }
  if (v27) {
    uint64_t v18 = (const char *)(sub_183D44BAC() + 32);
  }
  else {
    uint64_t v18 = 0;
  }
  uint64_t v19 = nw_ws_response_create(v17, v18);
  swift_unknownObjectRelease();
  if (v16)
  {
    swift_bridgeObjectRelease();
    uint64_t v20 = v16[2];
    if (v20)
    {
      uint64_t v21 = (char *)(v16 + 7);
      do
      {
        uint64_t v22 = (const char *)(sub_183D44BAC() + 32);
        uint64_t v23 = sub_183D44BAC();
        nw_ws_response_add_additional_header(v19, v22, (const char *)(v23 + 32));
        swift_release();
        swift_release();
        v21 += 32;
        --v20;
      }
      while (v20);
    }
  }
  else
  {
    swift_bridgeObjectRelease();
  }
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_release();
  swift_release();
  swift_bridgeObjectRelease();
  return (uint64_t)v19;
}

uint64_t sub_1834AD0DC(uint64_t a1, void **a2)
{
  uint64_t v3 = sub_183D44C9C();
  uint64_t v5 = v4;
  uint64_t v6 = *a2;
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  *a2 = v6;
  if ((isUniquelyReferenced_nonNull_native & 1) == 0)
  {
    uint64_t v6 = sub_1834B423C(0, v6[2] + 1, 1, v6);
    *a2 = v6;
  }
  unint64_t v9 = v6[2];
  unint64_t v8 = v6[3];
  if (v9 >= v8 >> 1)
  {
    uint64_t v6 = sub_1834B423C((void *)(v8 > 1), v9 + 1, 1, v6);
    *a2 = v6;
  }
  v6[2] = v9 + 1;
  uint64_t v10 = &v6[2 * v9];
  v10[4] = v3;
  v10[5] = v5;
  return 1;
}

uint64_t sub_1834AD194(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 32))(a2, a3) & 1;
}

uint64_t sub_1834AD1C8(uint64_t a1)
{
  int64_t v1 = *(void *)(a1 + 16);
  uint64_t v2 = MEMORY[0x1E4FBC860];
  if (v1)
  {
    uint64_t v13 = MEMORY[0x1E4FBC860];
    sub_1835AF3C4(0, v1, 0);
    uint64_t v2 = v13;
    uint64_t v4 = a1 + 56;
    do
    {
      swift_bridgeObjectRetain_n();
      swift_bridgeObjectRetain_n();
      __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F627B8);
      __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F627C0);
      swift_dynamicCast();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
      {
        sub_1835AF3C4(0, *(void *)(v2 + 16) + 1, 1);
        uint64_t v2 = v13;
      }
      unint64_t v6 = *(void *)(v2 + 16);
      unint64_t v5 = *(void *)(v2 + 24);
      if (v6 >= v5 >> 1)
      {
        sub_1835AF3C4(v5 > 1, v6 + 1, 1);
        uint64_t v2 = v13;
      }
      v4 += 32;
      *(void *)(v2 + 16) = v6 + 1;
      char v7 = (void *)(v2 + 32 * v6);
      v7[4] = v9;
      v7[5] = v10;
      v7[6] = v11;
      v7[7] = v12;
      --v1;
    }
    while (v1);
  }
  return v2;
}

id sub_1834AD334(uint64_t a1)
{
  int64_t v1 = *(uint64_t (**)(uint64_t))(a1 + 32);
  swift_retain();
  uint64_t v2 = swift_unknownObjectRetain();
  uint64_t v3 = (void *)v1(v2);
  swift_release();
  swift_unknownObjectRelease();

  return v3;
}

uint64_t NWProtocolWebSocket.Options.deinit()
{
  swift_unknownObjectRelease();
  return v0;
}

uint64_t NWProtocolWebSocket.Options.__deallocating_deinit()
{
  swift_unknownObjectRelease();

  return swift_deallocClassInstance();
}

BOOL sub_1834AD3F8(NSObject *a1)
{
  return nw_protocol_metadata_is_ws(a1);
}

void NWProtocolWebSocket.Metadata.opcode.getter(unsigned char *a1@<X8>)
{
  *a1 = *(unsigned char *)(v1 + 24);
}

uint64_t NWProtocolWebSocket.Metadata.__allocating_init(opcode:)(char *a1)
{
  uint64_t v2 = swift_allocObject();
  NWProtocolWebSocket.Metadata.init(opcode:)(a1);
  return v2;
}

uint64_t NWProtocolWebSocket.Metadata.init(opcode:)(char *a1)
{
  uint64_t v2 = *a1;
  *(unsigned char *)(v1 + 24) = v2;
  *(_WORD *)(v1 + 40) = 4;
  *(unsigned char *)(v1 + 42) = 0;
  *(void *)(v1 + 32) = 0;
  *(void *)(v1 + 16) = nw_ws_create_metadata((nw_ws_opcode_t)dword_183D535E4[v2]);
  return v1;
}

uint64_t sub_1834AD4A0(NSObject *a1)
{
  uint64_t v2 = swift_allocObject();
  uint64_t v3 = sub_1834AEDB8(a1, v2);
  swift_release();
  return v3;
}

uint64_t sub_1834AD4F0@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *a1;
  uint64_t result = swift_beginAccess();
  char v5 = *(unsigned char *)(v3 + 42);
  *(_WORD *)a2 = *(_WORD *)(v3 + 40);
  *(unsigned char *)(a2 + 2) = v5;
  return result;
}

void sub_1834AD540(uint64_t a1)
{
  char v1 = *(unsigned char *)(a1 + 2);
  unsigned __int16 v2 = *(_WORD *)a1;
  char v3 = v1;
  sub_1834AD5CC(&v2);
}

uint64_t sub_1834AD580@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = swift_beginAccess();
  char v4 = *(unsigned char *)(v1 + 42);
  *(_WORD *)a1 = *(_WORD *)(v1 + 40);
  *(unsigned char *)(a1 + 2) = v4;
  return result;
}

void sub_1834AD5CC(unsigned __int16 *a1)
{
  nw_ws_close_code_t v2 = *a1;
  int v3 = *((unsigned __int8 *)a1 + 2);
  swift_beginAccess();
  *(_WORD *)(v1 + 40) = v2;
  *(unsigned char *)(v1 + 42) = v3;
  if (v3) {
    nw_ws_close_code_t v4 = v2;
  }
  else {
    nw_ws_close_code_t v4 = dword_183D535FC[(char)v2];
  }
  nw_ws_metadata_set_close_code(*(nw_protocol_metadata_t *)(v1 + 16), v4);
}

void (*sub_1834AD648(uint64_t a1))(uint64_t a1, char a2)
{
  *(void *)(a1 + 24) = v1;
  swift_beginAccess();
  return sub_1834AD6A0;
}

void sub_1834AD6A0(uint64_t a1, char a2)
{
  swift_endAccess();
  if ((a2 & 1) == 0)
  {
    uint64_t v4 = *(void *)(a1 + 24);
    if (*(unsigned char *)(v4 + 42))
    {
      char v5 = *(NSObject **)(v4 + 16);
      nw_ws_close_code_t v6 = *(unsigned __int16 *)(v4 + 40);
    }
    else
    {
      char v5 = *(NSObject **)(v4 + 16);
      nw_ws_close_code_t v6 = nw_ws_close_code_normal_closure;
      switch(*(_WORD *)(v4 + 40))
      {
        case 1u:
          nw_ws_close_code_t v6 = nw_ws_close_code_going_away;
          break;
        case 2u:
          nw_ws_close_code_t v6 = nw_ws_close_code_protocol_error;
          break;
        case 3u:
          nw_ws_close_code_t v6 = nw_ws_close_code_unsupported_data;
          break;
        case 4u:
          nw_ws_close_code_t v6 = nw_ws_close_code_no_status_received;
          break;
        case 5u:
          nw_ws_close_code_t v6 = nw_ws_close_code_abnormal_closure;
          break;
        case 6u:
          nw_ws_close_code_t v6 = nw_ws_close_code_invalid_frame_payload_data;
          break;
        case 7u:
          nw_ws_close_code_t v6 = nw_ws_close_code_policy_violation;
          break;
        case 8u:
          nw_ws_close_code_t v6 = nw_ws_close_code_message_too_big;
          break;
        case 9u:
          nw_ws_close_code_t v6 = nw_ws_close_code_mandatory_extension;
          break;
        case 0xAu:
          nw_ws_close_code_t v6 = nw_ws_close_code_internal_server_error;
          break;
        case 0xBu:
          nw_ws_close_code_t v6 = nw_ws_close_code_tls_handshake;
          break;
        default:
          break;
      }
    }
    nw_ws_metadata_set_close_code(v5, v6);
  }
}

void sub_1834AD7B8(NSObject *a1, uint64_t a2, uint64_t a3)
{
  char v7 = *(NSObject **)(v3 + 16);
  uint64_t v8 = swift_allocObject();
  *(void *)(v8 + 16) = a2;
  *(void *)(v8 + 24) = a3;
  v10[4] = sub_1832E6CC8;
  v10[5] = v8;
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 1107296256;
  v10[2] = sub_1832E6C64;
  v10[3] = &block_descriptor_21;
  uint64_t v9 = _Block_copy(v10);
  swift_retain();
  swift_release();
  nw_ws_metadata_set_pong_handler(v7, a1, v9);
  _Block_release(v9);
}

uint64_t sub_1834AD8A4()
{
  if (!*(void *)(v0 + 32)) {
    return 0;
  }
  uint64_t v1 = swift_unknownObjectRetain();
  if (!nw_ws_response_get_selected_subprotocol(v1))
  {
    swift_unknownObjectRelease();
    return 0;
  }
  uint64_t v2 = sub_183D44C9C();
  swift_unknownObjectRelease();
  return v2;
}

uint64_t sub_1834AD910()
{
  uint64_t v1 = *(NSObject **)(v0 + 32);
  if (!v1) {
    return (uint64_t)v1;
  }
  uint64_t v8 = MEMORY[0x1E4FBC860];
  uint64_t v2 = swift_allocObject();
  *(void *)(v2 + 16) = &v8;
  uint64_t v3 = swift_allocObject();
  *(void *)(v3 + 16) = sub_1834AF018;
  *(void *)(v3 + 24) = v2;
  void aBlock[4] = sub_1834ADE94;
  aBlock[5] = v3;
  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 1107296256;
  aBlock[2] = sub_1834AD194;
  aBlock[3] = &block_descriptor_30;
  uint64_t v4 = _Block_copy(aBlock);
  swift_unknownObjectRetain();
  swift_retain();
  swift_release();
  nw_ws_response_enumerate_additional_headers(v1, v4);
  swift_unknownObjectRelease();
  _Block_release(v4);
  char isEscapingClosureAtFileLocation = swift_isEscapingClosureAtFileLocation();
  uint64_t result = swift_release();
  if ((isEscapingClosureAtFileLocation & 1) == 0)
  {
    uint64_t v1 = v8;
    swift_release();
    return (uint64_t)v1;
  }
  __break(1u);
  return result;
}

uint64_t sub_1834ADA84(uint64_t a1, uint64_t a2, void **a3)
{
  uint64_t v4 = sub_183D44C9C();
  uint64_t v6 = v5;
  uint64_t v7 = sub_183D44C9C();
  uint64_t v9 = v8;
  uint64_t v10 = *a3;
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  *a3 = v10;
  if ((isUniquelyReferenced_nonNull_native & 1) == 0)
  {
    uint64_t v10 = sub_1834B434C(0, v10[2] + 1, 1, v10);
    *a3 = v10;
  }
  unint64_t v13 = v10[2];
  unint64_t v12 = v10[3];
  if (v13 >= v12 >> 1)
  {
    uint64_t v10 = sub_1834B434C((void *)(v12 > 1), v13 + 1, 1, v10);
    *a3 = v10;
  }
  v10[2] = v13 + 1;
  uint64_t v14 = &v10[4 * v13];
  void v14[4] = v4;
  v14[5] = v6;
  v14[6] = v7;
  v14[7] = v9;
  return 1;
}

uint64_t sub_1834ADB5C()
{
  return swift_unknownObjectRelease();
}

uint64_t NWProtocolWebSocket.Metadata.deinit()
{
  swift_unknownObjectRelease();
  swift_unknownObjectRelease();
  return v0;
}

uint64_t NWProtocolWebSocket.Metadata.__deallocating_deinit()
{
  swift_unknownObjectRelease();
  swift_unknownObjectRelease();

  return swift_deallocClassInstance();
}

BOOL static NWProtocolWebSocket.Response.Status.== infix(_:_:)(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return ((*a1 ^ *a2) & 1) == 0;
}

uint64_t NWProtocolWebSocket.Response.Status.hash(into:)()
{
  return sub_183D45B0C();
}

uint64_t NWProtocolWebSocket.Response.Status.hashValue.getter()
{
  return sub_183D45B4C();
}

BOOL sub_1834ADC58(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return ((*a1 ^ *a2) & 1) == 0;
}

uint64_t _s7Network14NWProtocolQUICC7OptionsC9DirectionO9hashValueSivg_0()
{
  return sub_183D45B4C();
}

uint64_t sub_1834ADCB8()
{
  return sub_183D45B0C();
}

uint64_t sub_1834ADCE4()
{
  return sub_183D45B4C();
}

void NWProtocolWebSocket.Response.status.getter(unsigned char *a1@<X8>)
{
  *a1 = *v1;
}

uint64_t NWProtocolWebSocket.Response.subprotocol.getter()
{
  uint64_t v1 = *(void *)(v0 + 8);
  swift_bridgeObjectRetain();
  return v1;
}

uint64_t NWProtocolWebSocket.Response.additionalHeaders.getter()
{
  return swift_bridgeObjectRetain();
}

unsigned char *NWProtocolWebSocket.Response.init(status:subprotocol:additionalHeaders:)@<X0>(unsigned char *result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  *(unsigned char *)a5 = *result;
  *(void *)(a5 + 8) = a2;
  *(void *)(a5 + 16) = a3;
  *(void *)(a5 + 24) = a4;
  return result;
}

uint64_t NWProtocolWebSocket.deinit()
{
  return v0;
}

uint64_t NWProtocolWebSocket.__deallocating_deinit()
{
  return swift_deallocClassInstance();
}

BOOL sub_1834ADD9C(_DWORD *a1, _DWORD *a2)
{
  return *a1 == *a2;
}

void sub_1834ADDB0(_DWORD *a1@<X8>)
{
  *a1 = *v1;
}

_DWORD *sub_1834ADDBC@<X0>(_DWORD *result@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)a2 = *result;
  *(unsigned char *)(a2 + 4) = 0;
  return result;
}

BOOL _s7Network19NWProtocolWebSocketC9CloseCodeO2eeoiySbAE_AEtFZ_0(unsigned __int16 *a1, unsigned __int16 *a2)
{
  int v2 = *a1;
  int v3 = *a2;
  int v4 = *((unsigned __int8 *)a2 + 2);
  if (*((unsigned char *)a1 + 2))
  {
    BOOL v6 = v4 == 1 && v2 == v3;
    BOOL v8 = v4 == 2 && v2 == v3;
    if (*((unsigned char *)a1 + 2) == 1) {
      return v6;
    }
    else {
      return v8;
    }
  }
  else
  {
    return !*((unsigned char *)a2 + 2) && word_183D5362C[(char)v2] == word_183D5362C[(char)v3];
  }
}

uint64_t sub_1834ADE34()
{
  swift_release();

  return swift_deallocObject();
}

uint64_t sub_1834ADE6C(NSObject *a1)
{
  return sub_1834ACD2C(a1, *(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v1 + 16));
}

uint64_t sub_1834ADE74()
{
  return swift_deallocObject();
}

uint64_t sub_1834ADE84()
{
  return swift_deallocObject();
}

uint64_t sub_1834ADE94()
{
  return (*(uint64_t (**)(void))(v0 + 16))() & 1;
}

unint64_t sub_1834ADEC4()
{
  unint64_t result = qword_1E8F62350;
  if (!qword_1E8F62350)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F62350);
  }
  return result;
}

unint64_t sub_1834ADF1C()
{
  unint64_t result = qword_1E8F62358;
  if (!qword_1E8F62358)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F62358);
  }
  return result;
}

unint64_t sub_1834ADF74()
{
  unint64_t result = qword_1E8F62360;
  if (!qword_1E8F62360)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F62360);
  }
  return result;
}

unint64_t sub_1834ADFCC()
{
  unint64_t result = qword_1E8F62368;
  if (!qword_1E8F62368)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F62368);
  }
  return result;
}

uint64_t type metadata accessor for NWProtocolWebSocket()
{
  return self;
}

uint64_t getEnumTagSinglePayload for NWProtocolWebSocket.Version(unsigned int *a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if ((a2 + 1) >= 0x10000) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 1) < 0x100) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4) {
    return *a1;
  }
  if (v3 == 2) {
    return *(unsigned __int16 *)a1;
  }
  return *(unsigned __int8 *)a1;
}

unsigned char *storeEnumTagSinglePayload for NWProtocolWebSocket.Version(unsigned char *result, int a2, int a3)
{
  if ((a3 + 1) >= 0x10000) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 1) < 0x100) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2)
  {
    switch(v5)
    {
      case 1:
        *unint64_t result = a2;
        return result;
      case 2:
        *(_WORD *)unint64_t result = a2;
        return result;
      case 3:
        goto LABEL_19;
      case 4:
        *(_DWORD *)unint64_t result = a2;
        return result;
      default:
        return result;
    }
  }
  switch(v5)
  {
    case 1:
      *unint64_t result = 0;
      break;
    case 2:
      *(_WORD *)unint64_t result = 0;
      break;
    case 3:
LABEL_19:
      __break(1u);
      JUMPOUT(0x1834AE134);
    case 4:
      *(_DWORD *)unint64_t result = 0;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t sub_1834AE15C()
{
  return 0;
}

ValueMetadata *type metadata accessor for NWProtocolWebSocket.Version()
{
  return &type metadata for NWProtocolWebSocket.Version;
}

unsigned char *__swift_memcpy1_1(unsigned char *result, unsigned char *a2)
{
  *unint64_t result = *a2;
  return result;
}

uint64_t getEnumTagSinglePayload for NWProtocolWebSocket.Opcode(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xFB) {
    goto LABEL_17;
  }
  if (a2 + 5 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 5) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 5;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 5;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 5;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 6;
  int v8 = v6 - 6;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *storeEnumTagSinglePayload for NWProtocolWebSocket.Opcode(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 5 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 5) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFB) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xFA)
  {
    unsigned int v6 = ((a2 - 251) >> 8) + 1;
    *unint64_t result = a2 + 5;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x1834AE2DCLL);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *unint64_t result = a2 + 5;
        break;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for NWProtocolWebSocket.Opcode()
{
  return &type metadata for NWProtocolWebSocket.Opcode;
}

uint64_t __swift_memcpy3_2(uint64_t result, __int16 *a2)
{
  __int16 v2 = *a2;
  *(unsigned char *)(result + 2) = *((unsigned char *)a2 + 2);
  *(_WORD *)unint64_t result = v2;
  return result;
}

uint64_t getEnumTagSinglePayload for NWProtocolWebSocket.CloseCode(unsigned __int16 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0xFE)
  {
    if ((a2 + 33554178) >> 24)
    {
      int v2 = *((unsigned __int8 *)a1 + 3);
      if (*((unsigned char *)a1 + 3)) {
        return (*a1 | (*((unsigned __int8 *)a1 + 2) << 16) | (v2 << 24)) - 16776962;
      }
    }
    else
    {
      int v2 = *(unsigned __int16 *)((char *)a1 + 3);
      if (*(unsigned __int16 *)((char *)a1 + 3)) {
        return (*a1 | (*((unsigned __int8 *)a1 + 2) << 16) | (v2 << 24)) - 16776962;
      }
    }
  }
  unsigned int v4 = *((unsigned __int8 *)a1 + 2);
  if (v4 <= 2) {
    int v5 = -1;
  }
  else {
    int v5 = v4 ^ 0xFF;
  }
  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for NWProtocolWebSocket.CloseCode(uint64_t result, unsigned int a2, unsigned int a3)
{
  if ((a3 + 33554178) >> 24) {
    int v3 = 1;
  }
  else {
    int v3 = 2;
  }
  if (a3 <= 0xFD) {
    int v3 = 0;
  }
  if (a2 > 0xFD)
  {
    *(_WORD *)unint64_t result = a2 - 254;
    *(unsigned char *)(result + 2) = (a2 - 254) >> 16;
    if (v3)
    {
      unsigned int v4 = ((a2 - 254) >> 24) + 1;
      if (v3 == 2) {
        *(_WORD *)(result + 3) = v4;
      }
      else {
        *(unsigned char *)(result + 3) = v4;
      }
    }
  }
  else
  {
    if (!v3) {
      goto LABEL_10;
    }
    if (v3 == 2)
    {
      *(_WORD *)(result + 3) = 0;
LABEL_10:
      if (!a2) {
        return result;
      }
LABEL_16:
      *(unsigned char *)(result + 2) = -(char)a2;
      return result;
    }
    *(unsigned char *)(result + 3) = 0;
    if (a2) {
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t sub_1834AE428(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 2);
}

uint64_t sub_1834AE430(uint64_t result, char a2)
{
  *(unsigned char *)(result + 2) = a2;
  return result;
}

ValueMetadata *type metadata accessor for NWProtocolWebSocket.CloseCode()
{
  return &type metadata for NWProtocolWebSocket.CloseCode;
}

uint64_t getEnumTagSinglePayload for NWProtocolWebSocket.CloseCode.Defined(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xF5) {
    goto LABEL_17;
  }
  if (a2 + 11 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 11) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 11;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 11;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 11;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 0xC;
  int v8 = v6 - 12;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *storeEnumTagSinglePayload for NWProtocolWebSocket.CloseCode.Defined(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 11 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 11) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xF5) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xF4)
  {
    unsigned int v6 = ((a2 - 245) >> 8) + 1;
    *unint64_t result = a2 + 11;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x1834AE5A4);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *unint64_t result = a2 + 11;
        break;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for NWProtocolWebSocket.CloseCode.Defined()
{
  return &type metadata for NWProtocolWebSocket.CloseCode.Defined;
}

uint64_t type metadata accessor for NWProtocolWebSocket.Options()
{
  return self;
}

uint64_t method lookup function for NWProtocolWebSocket.Options(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F4186708](a1, a2, &nominal type descriptor for NWProtocolWebSocket.Options);
}

uint64_t dispatch thunk of NWProtocolWebSocket.Options.autoReplyPing.getter()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 128))();
}

uint64_t dispatch thunk of NWProtocolWebSocket.Options.autoReplyPing.setter()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 136))();
}

uint64_t dispatch thunk of NWProtocolWebSocket.Options.autoReplyPing.modify()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 144))();
}

uint64_t dispatch thunk of NWProtocolWebSocket.Options.maximumMessageSize.getter()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 152))();
}

uint64_t dispatch thunk of NWProtocolWebSocket.Options.maximumMessageSize.setter()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 160))();
}

uint64_t dispatch thunk of NWProtocolWebSocket.Options.maximumMessageSize.modify()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 168))();
}

uint64_t dispatch thunk of NWProtocolWebSocket.Options.skipHandshake.getter()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 176))();
}

uint64_t dispatch thunk of NWProtocolWebSocket.Options.skipHandshake.setter()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 184))();
}

uint64_t dispatch thunk of NWProtocolWebSocket.Options.skipHandshake.modify()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 192))();
}

uint64_t dispatch thunk of NWProtocolWebSocket.Options.__allocating_init(_:)()
{
  return (*(uint64_t (**)(void))(v0 + 200))();
}

uint64_t dispatch thunk of NWProtocolWebSocket.Options.setAdditionalHeaders(_:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 208))();
}

uint64_t dispatch thunk of NWProtocolWebSocket.Options.setSubprotocols(_:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 216))();
}

uint64_t dispatch thunk of NWProtocolWebSocket.Options.setClientRequestHandler(_:handler:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 224))();
}

uint64_t type metadata accessor for NWProtocolWebSocket.Metadata()
{
  return self;
}

uint64_t method lookup function for NWProtocolWebSocket.Metadata(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F4186708](a1, a2, &nominal type descriptor for NWProtocolWebSocket.Metadata);
}

uint64_t dispatch thunk of NWProtocolWebSocket.Metadata.__allocating_init(opcode:)()
{
  return (*(uint64_t (**)(void))(v0 + 128))();
}

uint64_t dispatch thunk of NWProtocolWebSocket.Metadata.closeCode.getter()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 136))();
}

uint64_t dispatch thunk of NWProtocolWebSocket.Metadata.closeCode.setter()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 144))();
}

uint64_t dispatch thunk of NWProtocolWebSocket.Metadata.closeCode.modify()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 152))();
}

uint64_t dispatch thunk of NWProtocolWebSocket.Metadata.setPongHandler(_:handler:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 160))();
}

uint64_t dispatch thunk of NWProtocolWebSocket.Metadata.selectedSubprotocol.getter()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 168))();
}

uint64_t dispatch thunk of NWProtocolWebSocket.Metadata.additionalServerHeaders.getter()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 176))();
}

uint64_t initializeBufferWithCopyOfBuffer for NWProtocolWebSocket.Response(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a1 = *a2;
  uint64_t v3 = v2 + 16;
  swift_retain();
  return v3;
}

uint64_t destroy for NWProtocolWebSocket.Response()
{
  swift_bridgeObjectRelease();

  return swift_bridgeObjectRelease();
}

uint64_t initializeWithCopy for NWProtocolWebSocket.Response(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = *(unsigned char *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(void *)(a1 + 16) = v3;
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t assignWithCopy for NWProtocolWebSocket.Response(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = *(unsigned char *)a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

__n128 __swift_memcpy32_8(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

uint64_t assignWithTake for NWProtocolWebSocket.Response(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = *(unsigned char *)a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  swift_bridgeObjectRelease();
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for NWProtocolWebSocket.Response(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0x7FFFFFFF && *(unsigned char *)(a1 + 32)) {
    return (*(_DWORD *)a1 + 0x7FFFFFFF);
  }
  unint64_t v3 = *(void *)(a1 + 16);
  if (v3 >= 0xFFFFFFFF) {
    LODWORD(v3) = -1;
  }
  int v4 = v3 - 1;
  if (v4 < 0) {
    int v4 = -1;
  }
  return (v4 + 1);
}

uint64_t storeEnumTagSinglePayload for NWProtocolWebSocket.Response(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0x7FFFFFFE)
  {
    *(void *)(result + 16) = 0;
    *(void *)(result + 24) = 0;
    *(void *)__n128 result = a2 - 0x7FFFFFFF;
    *(void *)(result + 8) = 0;
    if (a3 >= 0x7FFFFFFF) {
      *(unsigned char *)(result + 32) = 1;
    }
  }
  else
  {
    if (a3 >= 0x7FFFFFFF) {
      *(unsigned char *)(result + 32) = 0;
    }
    if (a2) {
      *(void *)(result + 16) = a2;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for NWProtocolWebSocket.Response()
{
  return &type metadata for NWProtocolWebSocket.Response;
}

uint64_t getEnumTagSinglePayload for NWProtocolWebSocket.Response.Status(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xFF) {
    goto LABEL_17;
  }
  if (a2 + 1 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 1) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 1;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 1;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 1;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 2;
  int v8 = v6 - 2;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *storeEnumTagSinglePayload for NWProtocolWebSocket.Response.Status(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 1 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 1) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFF) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xFE)
  {
    unsigned int v6 = ((a2 - 255) >> 8) + 1;
    *__n128 result = a2 + 1;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x1834AECA4);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *__n128 result = a2 + 1;
        break;
    }
  }
  return result;
}

unsigned char *sub_1834AECCC(unsigned char *result, char a2)
{
  *__n128 result = a2 & 1;
  return result;
}

ValueMetadata *type metadata accessor for NWProtocolWebSocket.Response.Status()
{
  return &type metadata for NWProtocolWebSocket.Response.Status;
}

void type metadata accessor for nw_report_resolution_protocol_t(uint64_t a1)
{
}

uint64_t __swift_memcpy6_1(uint64_t result, int *a2)
{
  int v2 = *a2;
  *(_WORD *)(result + 4) = *((_WORD *)a2 + 2);
  *(_DWORD *)__n128 result = v2;
  return result;
}

uint64_t getEnumTagSinglePayload for EthernetAddress(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 6)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for EthernetAddress(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(_WORD *)(result + 4) = 0;
    *(_DWORD *)__n128 result = a2 - 1;
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }
  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }
  *(unsigned char *)(result + 6) = v3;
  return result;
}

void type metadata accessor for ether_addr(uint64_t a1)
{
}

__n128 __swift_memcpy16_4(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

void type metadata accessor for in6_addr(uint64_t a1)
{
}

void type metadata accessor for in_addr(uint64_t a1)
{
}

void type metadata accessor for CFURLResponse(uint64_t a1)
{
}

uint64_t sub_1834AEDB8(NSObject *a1, uint64_t a2)
{
  swift_retain();
  if (nw_ws_metadata_get_opcode(a1) == nw_ws_opcode_invalid)
  {
    char v5 = 0;
  }
  else
  {
    nw_ws_opcode_t opcode = nw_ws_metadata_get_opcode(a1);
    if (opcode < 0 || opcode >= 0x100) {
      goto LABEL_11;
    }
    if (opcode > nw_ws_opcode_pong || ((0x707u >> opcode) & 1) == 0)
    {
      __break(1u);
      goto LABEL_11;
    }
    char v5 = byte_183D53644[(char)opcode];
  }
  *(unsigned char *)(a2 + 24) = v5;
  uint64_t close_code = nw_ws_metadata_get_close_code(a1);
  if (close_code < 0x10000)
  {
    NWProtocolWebSocket.CloseCode.init(rawValue:)(close_code, (uint64_t)&v9);
    char v7 = v10;
    *(_WORD *)(a2 + 40) = v9;
    *(unsigned char *)(a2 + 42) = v7;
    *(void *)(a2 + 32) = nw_ws_metadata_copy_server_response(a1);
    *(void *)(a2 + 16) = a1;
    return a2;
  }
LABEL_11:
  uint64_t result = sub_183D456BC();
  __break(1u);
  return result;
}

uint64_t sub_1834AEF38()
{
  return swift_deallocObject();
}

uint64_t sub_1834AEF48(uint64_t a1)
{
  return sub_1834AD0DC(a1, *(void ***)(v1 + 16));
}

uint64_t sub_1834AEF50()
{
  return swift_deallocObject();
}

uint64_t sub_1834AEF60(uint64_t a1)
{
  return sub_1834BFBD4(a1, *(uint64_t (**)(void))(v1 + 16));
}

uint64_t sub_1834AEF68()
{
  return swift_deallocObject();
}

uint64_t sub_1834AEF78(uint64_t a1, uint64_t a2)
{
  return sub_1834ADA84(a1, a2, *(void ***)(v2 + 16)) & 1;
}

uint64_t sub_1834AEF98()
{
  return swift_deallocObject();
}

void type metadata accessor for nw_interface_type_t(uint64_t a1)
{
}

uint64_t sub_1834AEFBC(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 16)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t sub_1834AEFDC(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(void *)uint64_t result = (a2 - 1);
    *(void *)(result + 8) = 0;
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }
  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }
  *(unsigned char *)(result + 16) = v3;
  return result;
}

void type metadata accessor for in6_addr.__Unnamed_union___u6_addr(uint64_t a1)
{
}

uint64_t BrowseResult.Change.description.getter(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  uint64_t v2 = *(void *)(v1 - 8);
  uint64_t v3 = MEMORY[0x1F4188790](a1);
  char v5 = (char *)&v18 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v6 = MEMORY[0x1F4188790](v3);
  int v8 = (char *)&v18 - v7;
  MEMORY[0x1F4188790](v6);
  char v10 = (char *)&v18 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *))(v11 + 16))(v10);
  int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
  if (EnumCaseMultiPayload)
  {
    if (EnumCaseMultiPayload != 1)
    {
      uint64_t v14 = &v10[*(int *)(swift_getTupleTypeMetadata2() + 48)];
      uint64_t v15 = *(void (**)(char *, char *, uint64_t))(v2 + 32);
      v15(v8, v10, v1);
      v15(v5, v14, v1);
      uint64_t v18 = 0;
      unint64_t v19 = 0xE000000000000000;
      sub_183D4547C();
      sub_183D44C8C();
      sub_183D4590C();
      sub_183D44C8C();
      sub_183D4590C();
      sub_183D44C8C();
      uint64_t v13 = v18;
      long long v16 = *(void (**)(char *, uint64_t))(v2 + 8);
      v16(v5, v1);
      v16(v8, v1);
      return v13;
    }
    (*(void (**)(char *, char *, uint64_t))(v2 + 32))(v8, v10, v1);
    uint64_t v18 = 0;
    unint64_t v19 = 0xE000000000000000;
    sub_183D44C8C();
    sub_183D4590C();
  }
  else
  {
    (*(void (**)(char *, char *, uint64_t))(v2 + 32))(v8, v10, v1);
    uint64_t v18 = 0;
    unint64_t v19 = 0xE000000000000000;
    sub_183D44C8C();
    sub_183D4590C();
    sub_183D44C8C();
  }
  uint64_t v13 = v18;
  (*(void (**)(char *, uint64_t))(v2 + 8))(v8, v1);
  return v13;
}

uint64_t BrowseResult.endpoints.getter()
{
  sub_1834B55F4();

  return swift_bridgeObjectRetain();
}

uint64_t BrowseResult.changes.getter()
{
  sub_1834B55FC();

  return swift_bridgeObjectRetain();
}

uint64_t BrowseResult.init(endpoints:changes:)@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  *a3 = result;
  a3[1] = a2;
  return result;
}

uint64_t BrowseResult.description.getter()
{
  uint64_t v1 = type metadata accessor for BrowseResult.Change();
  uint64_t v2 = *(void *)(v1 - 8);
  uint64_t v3 = *(void *)(v2 + 64);
  MEMORY[0x1F4188790](v1);
  char v5 = (char *)&v21 - v4;
  uint64_t v6 = *(void *)(v0 + 8);
  uint64_t v7 = swift_bridgeObjectRetain();
  if (!MEMORY[0x1853142D0](v7, v1))
  {
    swift_bridgeObjectRelease();
    uint64_t v9 = (void *)MEMORY[0x1E4FBC860];
LABEL_17:
    uint64_t v26 = v9;
    __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F61F60);
    sub_1834B561C();
    uint64_t v20 = sub_183D44A8C();
    swift_bridgeObjectRelease();
    return v20;
  }
  uint64_t v8 = 0;
  char v25 = (void (**)(char *, void **, uint64_t))(v2 + 16);
  uint64_t v22 = v3;
  uint64_t v23 = (void (**)(char *, uint64_t))(v2 + 8);
  uint64_t v9 = (void *)MEMORY[0x1E4FBC860];
  uint64_t v24 = v2;
  while (1)
  {
    char v10 = sub_183D44ECC();
    sub_183D44E7C();
    if ((v10 & 1) == 0) {
      break;
    }
    uint64_t result = (*(uint64_t (**)(char *, unint64_t, uint64_t))(v2 + 16))(v5, v6+ ((*(unsigned __int8 *)(v2 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v2 + 80))+ *(void *)(v2 + 72) * v8, v1);
    uint64_t v12 = v8 + 1;
    if (__OFADD__(v8, 1)) {
      goto LABEL_18;
    }
LABEL_5:
    uint64_t v13 = BrowseResult.Change.description.getter(v1);
    uint64_t v15 = v14;
    if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
      uint64_t v9 = sub_1834B423C(0, v9[2] + 1, 1, v9);
    }
    unint64_t v17 = v9[2];
    unint64_t v16 = v9[3];
    if (v17 >= v16 >> 1) {
      uint64_t v9 = sub_1834B423C((void *)(v16 > 1), v17 + 1, 1, v9);
    }
    v9[2] = v17 + 1;
    uint64_t v18 = &v9[2 * v17];
    void v18[4] = v13;
    v18[5] = v15;
    (*v23)(v5, v1);
    ++v8;
    BOOL v19 = v12 == MEMORY[0x1853142D0](v6, v1);
    uint64_t v2 = v24;
    if (v19)
    {
      swift_bridgeObjectRelease();
      goto LABEL_17;
    }
  }
  uint64_t result = sub_183D454CC();
  if (v22 != 8) {
    goto LABEL_19;
  }
  uint64_t v26 = (void *)result;
  (*v25)(v5, &v26, v1);
  uint64_t result = swift_unknownObjectRelease();
  uint64_t v12 = v8 + 1;
  if (!__OFADD__(v8, 1)) {
    goto LABEL_5;
  }
LABEL_18:
  __break(1u);
LABEL_19:
  __break(1u);
  return result;
}

uint64_t BrowseResult.makeIterator()@<X0>(void *a1@<X8>)
{
  *a1 = *v1;
  a1[1] = 0;
  return swift_bridgeObjectRetain();
}

uint64_t BrowseResult.Iterator.next()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5 = *v2;
  uint64_t v4 = v2[1];
  uint64_t v6 = *(void *)(a1 + 16);
  if (v4 != MEMORY[0x1853142D0](*v2, v6))
  {
    char v9 = sub_183D44ECC();
    sub_183D44E7C();
    if (v9)
    {
      uint64_t v10 = *(void *)(v6 - 8);
      uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(v10 + 16))(a2, v5+ ((*(unsigned __int8 *)(v10 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80))+ *(void *)(v10 + 72) * v4, v6);
      uint64_t v11 = v4 + 1;
      if (!__OFADD__(v4, 1))
      {
LABEL_7:
        v2[1] = v11;
        return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v10 + 56))(a2, 0, 1, v6);
      }
    }
    else
    {
      uint64_t result = sub_183D454CC();
      uint64_t v10 = *(void *)(v6 - 8);
      if (*(void *)(v10 + 64) != 8)
      {
LABEL_12:
        __break(1u);
        return result;
      }
      uint64_t v12 = result;
      (*(void (**)(uint64_t, uint64_t *, uint64_t))(v10 + 16))(a2, &v12, v6);
      uint64_t result = swift_unknownObjectRelease();
      uint64_t v11 = v4 + 1;
      if (!__OFADD__(v4, 1)) {
        goto LABEL_7;
      }
    }
    __break(1u);
    goto LABEL_12;
  }
  uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v6 - 8) + 56);

  return v7(a2, 1, 1, v6);
}

uint64_t BrowseResult.startIndex.getter()
{
  return 0;
}

void BrowseResult.endIndex.getter()
{
}

Swift::Int __swiftcall BrowseResult.index(after:)(Swift::Int after)
{
  BOOL v1 = __OFADD__(after, 1);
  Swift::Int result = after + 1;
  if (v1) {
    __break(1u);
  }
  return result;
}

uint64_t BrowseResult.subscript.getter()
{
  return sub_183D44F1C();
}

uint64_t sub_1834AF920@<X0>(void *a1@<X8>)
{
  BrowseResult.makeIterator()(a1);
  swift_bridgeObjectRelease();

  return swift_bridgeObjectRelease();
}

uint64_t sub_1834AF95C(uint64_t a1)
{
  uint64_t WitnessTable = swift_getWitnessTable();

  return MEMORY[0x1F4184360](a1, WitnessTable);
}

uint64_t sub_1834AF9B0()
{
  return 2;
}

uint64_t sub_1834AF9B8()
{
  swift_getWitnessTable();
  uint64_t v0 = sub_1834B59F4();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  return v0;
}

uint64_t sub_1834AFA28()
{
  return sub_183D44DAC();
}

void sub_1834AFA4C(void *a1@<X8>)
{
  *a1 = 0;
}

void sub_1834AFA54()
{
}

uint64_t sub_1834AFA6C(uint64_t result)
{
  void *v1 = result;
  return result;
}

void (*sub_1834AFA7C(void *a1, uint64_t *a2, uint64_t a3))(void *a1)
{
  uint64_t v6 = malloc(0x28uLL);
  *a1 = v6;
  v6[4] = sub_1834AFB34(v6, *a2, a3);
  return sub_1834AFAEC;
}

void sub_1834AFAEC(void *a1)
{
  BOOL v1 = (void *)*a1;
  (*(void (**)(void))(*a1 + 32))(*a1);

  free(v1);
}

void (*sub_1834AFB34(void *a1, uint64_t a2, uint64_t a3))(void *a1)
{
  uint64_t v3 = *(void *)(a3 + 16);
  *a1 = v3;
  uint64_t v4 = *(void *)(v3 - 8);
  a1[1] = v4;
  a1[2] = malloc(*(void *)(v4 + 64));
  sub_183D44F1C();
  return sub_1834AFBF0;
}

void sub_1834AFBF0(void *a1)
{
  BOOL v1 = (void *)a1[2];
  (*(void (**)(void *, void))(a1[1] + 8))(v1, *a1);

  free(v1);
}

uint64_t sub_1834AFC40(uint64_t a1)
{
  uint64_t WitnessTable = swift_getWitnessTable();
  uint64_t v3 = MEMORY[0x1E4FBB590];

  return MEMORY[0x1F41842C0](a1, WitnessTable, v3);
}

void sub_1834AFCB4(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(_WORD *)(a1 + 8) = 256;
}

uint64_t sub_1834AFCC4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1834B5784(a1, a2, a3, a4, MEMORY[0x1E4FBB6A0], MEMORY[0x1E4FBAFC8]);
}

uint64_t sub_1834AFD04(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1834B5784(a1, a2, a3, a4, MEMORY[0x1E4FBB010], MEMORY[0x1E4FBAFD8]);
}

void *sub_1834AFD48@<X0>(void *result@<X0>, void *a2@<X8>)
{
  if (__OFADD__(*result, 1)) {
    __break(1u);
  }
  else {
    *a2 = *result + 1;
  }
  return result;
}

void *sub_1834AFD60(void *result)
{
  if (__OFADD__(*result, 1)) {
    __break(1u);
  }
  else {
    ++*result;
  }
  return result;
}

uint64_t sub_1834AFD78(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F41842B8](a1, a2, a3, a4, MEMORY[0x1E4FBB590]);
}

uint64_t sub_1834AFD88(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F41842C8](a1, a2, a3, a4, MEMORY[0x1E4FBB590]);
}

uint64_t sub_1834AFD94()
{
  sub_1834B55F4();

  return swift_bridgeObjectRetain();
}

uint64_t sub_1834AFDBC()
{
  sub_1834B55FC();

  return swift_bridgeObjectRetain();
}

uint64_t sub_1834AFDE8()
{
  swift_getWitnessTable();

  return sub_183D451BC();
}

uint64_t sub_1834AFE58(void *a1)
{
  swift_getWitnessTable();
  uint64_t result = sub_183D451BC();
  *a1 = v3;
  return result;
}

uint64_t sub_1834AFEC8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable();
  uint64_t v7 = MEMORY[0x1E4FBB590];

  return MEMORY[0x1F41842B8](a1, a2, a3, WitnessTable, v7);
}

uint64_t sub_1834AFF4C()
{
  swift_getWitnessTable();

  return sub_183D451AC();
}

uint64_t sub_1834AFFD0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable();
  uint64_t v7 = MEMORY[0x1E4FBB590];

  return MEMORY[0x1F41842C8](a1, a2, a3, WitnessTable, v7);
}

uint64_t _s7Network8Browser1C8provider5usingACyxGx_AA12NWParametersCtcfC_0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = swift_allocObject();
  (*(void (**)(uint64_t, uint64_t))(*(void *)(*(void *)(*(void *)v4 + 80) - 8) + 32))(v4 + *(void *)(*(void *)v4 + 96), a1);
  *(void *)(v4 + *(void *)(*(void *)v4 + 104)) = a2;
  return v4;
}

uint64_t _s7Network8Browser1C8provider5usingACyxGx_AA12NWParametersCtcfc_0(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, uint64_t))(*(void *)(*(void *)(*(void *)v2 + 80) - 8) + 32))(v2 + *(void *)(*(void *)v2 + 96), a1);
  *(void *)(v2 + *(void *)(*(void *)v2 + 104)) = a2;
  return v2;
}

uint64_t Browser1.__allocating_init<>(for:using:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3;
  swift_allocObject();
  uint64_t v8 = sub_1834B5C04(a1, a2, a3);
  (*(void (**)(uint64_t))(*(void *)(*(void *)(v4 + 80) - 8) + 8))(a1);
  return v8;
}

uint64_t Browser1.init<>(for:using:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *v3;
  uint64_t v6 = sub_1834B5C04(a1, a2, a3);
  (*(void (**)(uint64_t))(*(void *)(*(void *)(v5 + 80) - 8) + 8))(a1);
  return v6;
}

uint64_t Browser1.makeAsyncIterator()()
{
  uint64_t v1 = *v0;
  swift_getAssociatedTypeWitness();
  type metadata accessor for BrowseResult();
  __swift_instantiateConcreteTypeFromMangledNameAbstract(&qword_1E8F63CE0);
  uint64_t v2 = sub_183D450EC();
  uint64_t v3 = *(void *)(v2 - 8);
  MEMORY[0x1F4188790](v2);
  uint64_t v5 = &v11[-v4];
  uint64_t v6 = sub_183D4515C();
  uint64_t v7 = *(void *)(v6 - 8);
  MEMORY[0x1F4188790](v6);
  char v9 = &v11[-v8];
  (*(void (**)(unsigned char *, void, uint64_t))(v3 + 104))(v5, *MEMORY[0x1E4FBD120], v2);
  uint64_t v12 = v0;
  uint64_t v13 = v1;
  sub_183D4516C();
  sub_183D4501C();
  return (*(uint64_t (**)(unsigned char *, uint64_t))(v7 + 8))(v9, v6);
}

void sub_1834B0504(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v30 = a3;
  uint64_t v31 = a1;
  uint64_t v4 = *(void *)(*(void *)a2 + 88);
  uint64_t v5 = *(void *)(*(void *)a2 + 80);
  swift_getAssociatedTypeWitness();
  type metadata accessor for BrowseResult();
  __swift_instantiateConcreteTypeFromMangledNameAbstract(&qword_1E8F63CE0);
  uint64_t v6 = sub_183D4511C();
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v29 = *(void *)(v7 + 64);
  MEMORY[0x1F4188790](v6);
  char v9 = (char *)&v23 - v8;
  (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(v4 + 16))(&v33, v5, v4);
  uint64_t v28 = a2;
  uint64_t v10 = *(void *)(a2 + *(void *)(*(void *)a2 + 104));
  type metadata accessor for NWBrowser();
  swift_allocObject();
  swift_retain();
  uint64_t v11 = NWBrowser.init(for:using:)((uint64_t)&v33, v10);
  uint64_t v12 = (void *)swift_allocObject();
  v12[2] = v5;
  v12[3] = v4;
  uint64_t v27 = v5;
  uint64_t v32 = v11;
  v12[4] = v11;
  swift_retain();
  uint64_t v13 = v6;
  uint64_t v14 = v31;
  sub_183D450DC();
  uint64_t v26 = *(void (**)(char *, uint64_t, uint64_t))(v7 + 16);
  uint64_t v15 = v9;
  v26(v9, v14, v6);
  uint64_t v16 = *(unsigned __int8 *)(v7 + 80);
  uint64_t v17 = v29;
  uint64_t v25 = v16 | 7;
  uint64_t v18 = swift_allocObject();
  *(void *)(v18 + 16) = v5;
  *(void *)(v18 + 24) = v4;
  uint64_t v24 = *(void (**)(uint64_t, char *, uint64_t))(v7 + 32);
  v24(v18 + ((v16 + 32) & ~v16), v15, v13);
  sub_18315ED5C((uint64_t)sub_1834B9294);
  NWBrowser.stateUpdateHandler.setter((uint64_t)sub_1834B9294, v18);
  swift_release();
  v26(v15, v31, v13);
  uint64_t v19 = (v16 + 40) & ~v16;
  unint64_t v20 = (v17 + v19 + 7) & 0xFFFFFFFFFFFFFFF8;
  uint64_t v21 = (void *)swift_allocObject();
  v21[2] = v27;
  void v21[3] = v4;
  v21[4] = v28;
  v24((uint64_t)v21 + v19, v15, v13);
  *(void *)((char *)v21 + v20) = v30;
  swift_retain();
  sub_18315ED5C((uint64_t)sub_1834B948C);
  NWBrowser.browseResultsChangedHandler.setter((uint64_t)sub_1834B948C, (uint64_t)v21);
  swift_release();
  sub_1834B9584();
  uint64_t v22 = sub_183D452FC();
  NWBrowser.start(queue:)(v22);
  swift_release();
}

void sub_1834B08D0(uint64_t a1, uint64_t a2)
{
  if (nw_utilities_minos_atleast(1))
  {
    uint64_t v3 = *(os_unfair_lock_s **)(a2 + 24);
    uint64_t v4 = (uint64_t *)&v3[4];
    uint64_t v5 = v3 + 20;
    os_unfair_lock_lock(v3 + 20);
    sub_1834C39B8(v4);
    os_unfair_lock_unlock(v5);
  }
  uint64_t v6 = *(NSObject **)(a2 + 16);

  nw_browser_cancel(v6);
}

unsigned int *sub_1834B094C(unsigned int *result)
{
  uint64_t v1 = *((char *)result + 4);
  int64_t v2 = *result | (unint64_t)(v1 << 32);
  int v3 = v1 >> 6;
  if (!v3)
  {
    sub_1834AC424();
    swift_allocError();
    *(_DWORD *)uint64_t v4 = v2;
    *(unsigned char *)(v4 + 4) = BYTE4(v2);
LABEL_6:
    swift_getAssociatedTypeWitness();
    type metadata accessor for BrowseResult();
    __swift_instantiateConcreteTypeFromMangledNameAbstract(&qword_1E8F63CE0);
    sub_183D4511C();
    return (unsigned int *)sub_183D4510C();
  }
  if (v3 != 1 && v2 >= (uint64_t)0xFFFFFF8000000002) {
    goto LABEL_6;
  }
  return result;
}

uint64_t sub_1834B0A4C(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v110 = a4;
  uint64_t v115 = a2;
  uint64_t v6 = *a3;
  uint64_t v143 = *(void *)(*a3 + 88);
  uint64_t v142 = *(void *)(v6 + 80);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness();
  uint64_t v8 = type metadata accessor for BrowseResult.Change();
  MEMORY[0x1F4188790](v8);
  id v118 = (char *)&v104 - v9;
  uint64_t v10 = type metadata accessor for BrowseResult();
  uint64_t v11 = __swift_instantiateConcreteTypeFromMangledNameAbstract(&qword_1E8F63CE0);
  uint64_t v109 = v10;
  uint64_t v108 = v11;
  uint64_t v106 = sub_183D450CC();
  uint64_t v105 = *(void *)(v106 - 8);
  MEMORY[0x1F4188790](v106);
  __int16 v104 = (char *)&v104 - v12;
  uint64_t v128 = type metadata accessor for NWBrowser.Result.Change(0);
  uint64_t v127 = *(void *)(v128 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v128);
  id v123 = (char *)&v104 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v13);
  uint64_t v126 = (uint64_t)&v104 - v15;
  uint64_t v134 = sub_183D4536C();
  uint64_t v138 = *(void *)(v134 - 8);
  uint64_t v16 = MEMORY[0x1F4188790](v134);
  __int16 v113 = (char *)&v104 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  id v114 = (char *)&v104 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  long long v125 = (char *)&v104 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  __int16 v117 = (char *)&v104 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  uint64_t v26 = (char *)&v104 - v25;
  uint64_t v27 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v28 = MEMORY[0x1F4188790](v24);
  __int16 v107 = (char *)&v104 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v30 = MEMORY[0x1F4188790](v28);
  uint64_t v116 = (char *)&v104 - v31;
  uint64_t v32 = MEMORY[0x1F4188790](v30);
  __int16 v112 = (char *)&v104 - v33;
  uint64_t v34 = MEMORY[0x1F4188790](v32);
  __int16 v111 = (char *)&v104 - v35;
  uint64_t v36 = MEMORY[0x1F4188790](v34);
  os_log_type_t v129 = (char *)&v104 - v37;
  MEMORY[0x1F4188790](v36);
  __int16 v39 = (char *)&v104 - v38;
  uint64_t v40 = type metadata accessor for NWBrowser.Result(0);
  int64_t v137 = *(void *)(v40 - 8);
  uint64_t v41 = MEMORY[0x1F4188790](v40 - 8);
  uint64_t v124 = (uint64_t)&v104 - ((v42 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v43 = MEMORY[0x1F4188790](v41);
  uint64_t v120 = (uint64_t)&v104 - v44;
  uint64_t v45 = MEMORY[0x1F4188790](v43);
  uint64_t v122 = (uint64_t)&v104 - v46;
  uint64_t v47 = MEMORY[0x1F4188790](v45);
  uint64_t v121 = (uint64_t)&v104 - v48;
  uint64_t v49 = MEMORY[0x1F4188790](v47);
  os_log_type_t v51 = (char *)&v104 - v50;
  MEMORY[0x1F4188790](v49);
  BOOL v53 = (char *)&v104 - v52;
  uint64_t v147 = sub_183D44EAC();
  uint64_t v119 = v8;
  uint64_t v146 = sub_183D44EAC();
  uint64_t v54 = *(void *)(a1 + 56);
  uint64_t v135 = a1 + 56;
  uint64_t v55 = 1 << *(unsigned char *)(a1 + 32);
  uint64_t v56 = -1;
  if (v55 < 64) {
    uint64_t v56 = ~(-1 << v55);
  }
  unint64_t v57 = v56 & v54;
  uint64_t v141 = (uint64_t)a3 + *(void *)(*a3 + 96);
  int64_t v136 = (unint64_t)(v55 + 63) >> 6;
  nw_endpoint_t v139 = (unsigned int (**)(char *, uint64_t, uint64_t))(v27 + 48);
  uint64_t v140 = v143 + 24;
  os_log_type_t v130 = (void (**)(char *, char *, uint64_t))(v27 + 16);
  unsigned __int8 v131 = (void (**)(char *, uint64_t))(v27 + 8);
  uint64_t v132 = (void (**)(char *, uint64_t))(v138 + 8);
  os_log_type_t v133 = (void (**)(char *, char *, uint64_t))(v27 + 32);
  uint64_t v138 = a1;
  swift_bridgeObjectRetain();
  int64_t v58 = 0;
  int v59 = v129;
  if (v57) {
    goto LABEL_6;
  }
LABEL_7:
  BOOL v62 = __OFADD__(v58++, 1);
  if (v62)
  {
    __break(1u);
LABEL_62:
    __break(1u);
    goto LABEL_63;
  }
  if (v58 >= v136) {
    goto LABEL_25;
  }
  unint64_t v63 = *(void *)(v135 + 8 * v58);
  if (v63)
  {
LABEL_17:
    unint64_t v57 = (v63 - 1) & v63;
    for (unint64_t i = __clz(__rbit64(v63)) + (v58 << 6); ; unint64_t i = v60 | (v58 << 6))
    {
      sub_1834B95C4(*(void *)(v138 + 48) + *(void *)(v137 + 72) * i, (uint64_t)v53, type metadata accessor for NWBrowser.Result);
      sub_1834B962C((uint64_t)v53, (uint64_t)v51, type metadata accessor for NWBrowser.Result);
      (*(void (**)(char *, uint64_t))(v143 + 24))(v51, v142);
      if ((*v139)(v26, 1, AssociatedTypeWitness) == 1)
      {
        sub_18315E3FC((uint64_t)v51, type metadata accessor for NWBrowser.Result);
        (*v132)(v26, v134);
        if (!v57) {
          goto LABEL_7;
        }
      }
      else
      {
        (*v133)(v39, v26, AssociatedTypeWitness);
        (*v130)(v59, v39, AssociatedTypeWitness);
        sub_183D44F0C();
        sub_183D44EEC();
        (*v131)(v39, AssociatedTypeWitness);
        sub_18315E3FC((uint64_t)v51, type metadata accessor for NWBrowser.Result);
        if (!v57) {
          goto LABEL_7;
        }
      }
LABEL_6:
      unint64_t v60 = __clz(__rbit64(v57));
      v57 &= v57 - 1;
    }
  }
  int64_t v64 = v58 + 1;
  if (v58 + 1 >= v136) {
    goto LABEL_25;
  }
  unint64_t v63 = *(void *)(v135 + 8 * v64);
  if (v63) {
    goto LABEL_16;
  }
  int64_t v64 = v58 + 2;
  if (v58 + 2 < v136)
  {
    unint64_t v63 = *(void *)(v135 + 8 * v64);
    if (!v63)
    {
      int64_t v64 = v58 + 3;
      if (v58 + 3 < v136)
      {
        unint64_t v63 = *(void *)(v135 + 8 * v64);
        if (v63) {
          goto LABEL_16;
        }
        while (1)
        {
          int64_t v58 = v64 + 1;
          if (__OFADD__(v64, 1)) {
            break;
          }
          if (v58 >= v136) {
            goto LABEL_25;
          }
          unint64_t v63 = *(void *)(v135 + 8 * v58);
          ++v64;
          if (v63) {
            goto LABEL_17;
          }
        }
LABEL_63:
        __break(1u);
        goto LABEL_64;
      }
      goto LABEL_25;
    }
LABEL_16:
    int64_t v58 = v64;
    goto LABEL_17;
  }
LABEL_25:
  uint64_t v65 = v115;
  uint64_t v66 = (uint64_t)v123;
  nw_endpoint_t v67 = v114;
  swift_release();
  uint64_t v68 = *(void *)(v65 + 56);
  uint64_t v138 = v65 + 56;
  uint64_t v69 = 1 << *(unsigned char *)(v65 + 32);
  uint64_t v70 = -1;
  if (v69 < 64) {
    uint64_t v70 = ~(-1 << v69);
  }
  unint64_t v71 = v70 & v68;
  int64_t v72 = (unint64_t)(v69 + 63) >> 6;
  swift_bridgeObjectRetain();
  int64_t v73 = 0;
  int64_t v137 = v72;
  while (1)
  {
    nw_endpoint_t v75 = v67;
    if (v71)
    {
      unint64_t v76 = __clz(__rbit64(v71));
      v71 &= v71 - 1;
      unint64_t v77 = v76 | (v73 << 6);
      goto LABEL_43;
    }
    BOOL v62 = __OFADD__(v73++, 1);
    if (v62) {
      goto LABEL_62;
    }
    if (v73 >= v72) {
      break;
    }
    unint64_t v78 = *(void *)(v138 + 8 * v73);
    if (!v78)
    {
      int64_t v79 = v73 + 1;
      if (v73 + 1 >= v72) {
        break;
      }
      unint64_t v78 = *(void *)(v138 + 8 * v79);
      if (!v78)
      {
        int64_t v79 = v73 + 2;
        if (v73 + 2 >= v72) {
          break;
        }
        unint64_t v78 = *(void *)(v138 + 8 * v79);
        if (!v78)
        {
          int64_t v79 = v73 + 3;
          if (v73 + 3 >= v72) {
            break;
          }
          unint64_t v78 = *(void *)(v138 + 8 * v79);
          if (!v78)
          {
            while (1)
            {
              int64_t v73 = v79 + 1;
              if (__OFADD__(v79, 1)) {
                break;
              }
              if (v73 >= v72) {
                goto LABEL_60;
              }
              unint64_t v78 = *(void *)(v138 + 8 * v73);
              ++v79;
              if (v78) {
                goto LABEL_42;
              }
            }
LABEL_64:
            __break(1u);
            JUMPOUT(0x1834B1C94);
          }
        }
      }
      int64_t v73 = v79;
    }
LABEL_42:
    unint64_t v71 = (v78 - 1) & v78;
    unint64_t v77 = __clz(__rbit64(v78)) + (v73 << 6);
LABEL_43:
    uint64_t v80 = v126;
    sub_1834B95C4(*(void *)(v65 + 48) + *(void *)(v127 + 72) * v77, v126, type metadata accessor for NWBrowser.Result.Change);
    sub_1834B962C(v80, v66, type metadata accessor for NWBrowser.Result.Change);
    int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
    BOOL v82 = v125;
    nw_endpoint_t v67 = v75;
    switch(EnumCaseMultiPayload)
    {
      case 1:
        uint64_t v87 = v122;
        sub_1834B962C(v66, v122, type metadata accessor for NWBrowser.Result);
        (*(void (**)(uint64_t, uint64_t))(v143 + 24))(v87, v142);
        if ((*v139)(v82, 1, AssociatedTypeWitness) == 1)
        {
          id v74 = &v149;
          goto LABEL_29;
        }
        BOOL v93 = v112;
        (*v133)(v112, v82, AssociatedTypeWitness);
        (*v130)(v118, v93, AssociatedTypeWitness);
        swift_storeEnumTagMultiPayload();
        sub_183D44F0C();
        uint64_t v66 = (uint64_t)v123;
        sub_183D44EEC();
        BOOL v94 = v93;
        int64_t v72 = v137;
        (*v131)(v94, AssociatedTypeWitness);
        __int16 v86 = &v149;
        goto LABEL_51;
      case 2:
        uint64_t v88 = v66 + *(int *)(__swift_instantiateConcreteTypeFromMangledName(&qword_1E8F619E0) + 48);
        uint64_t v89 = v66;
        uint64_t v90 = v120;
        sub_1834B962C(v89, v120, type metadata accessor for NWBrowser.Result);
        sub_1834B962C(v88, v124, type metadata accessor for NWBrowser.Result);
        __int16 v91 = *(void (**)(uint64_t, uint64_t))(v143 + 24);
        v91(v90, v142);
        BOOL v92 = *v139;
        nw_endpoint_t v67 = v75;
        if ((*v139)(v75, 1, AssociatedTypeWitness) == 1)
        {
          sub_18315E3FC(v124, type metadata accessor for NWBrowser.Result);
          sub_18315E3FC(v120, type metadata accessor for NWBrowser.Result);
          (*v132)(v75, v134);
          uint64_t v66 = (uint64_t)v123;
        }
        else
        {
          BOOL v95 = *v133;
          (*v133)(v116, v75, AssociatedTypeWitness);
          BOOL v96 = v113;
          ((void (*)(uint64_t, uint64_t, uint64_t))v91)(v124, v142, v143);
          if (v92(v96, 1, AssociatedTypeWitness) == 1)
          {
            (*v131)(v116, AssociatedTypeWitness);
            sub_18315E3FC(v124, type metadata accessor for NWBrowser.Result);
            sub_18315E3FC(v120, type metadata accessor for NWBrowser.Result);
            (*v132)(v96, v134);
          }
          else
          {
            char v97 = v107;
            v95(v107, v96, AssociatedTypeWitness);
            __int16 v98 = &v118[*(int *)(swift_getTupleTypeMetadata2() + 48)];
            char v99 = *v130;
            __int16 v100 = v116;
            (*v130)(v118, v116, AssociatedTypeWitness);
            v99(v98, v97, AssociatedTypeWitness);
            swift_storeEnumTagMultiPayload();
            sub_183D44F0C();
            sub_183D44EEC();
            __int16 v101 = *v131;
            (*v131)(v97, AssociatedTypeWitness);
            v101(v100, AssociatedTypeWitness);
            sub_18315E3FC(v124, type metadata accessor for NWBrowser.Result);
            sub_18315E3FC(v120, type metadata accessor for NWBrowser.Result);
          }
          uint64_t v65 = v115;
          uint64_t v66 = (uint64_t)v123;
          nw_endpoint_t v67 = v114;
          int64_t v72 = v137;
        }
        break;
      case 3:
        continue;
      default:
        uint64_t v83 = v121;
        sub_1834B962C(v66, v121, type metadata accessor for NWBrowser.Result);
        BOOL v82 = v117;
        (*(void (**)(uint64_t, uint64_t))(v143 + 24))(v83, v142);
        if ((*v139)(v82, 1, AssociatedTypeWitness) == 1)
        {
          id v74 = &v148;
LABEL_29:
          sub_18315E3FC(*(v74 - 32), type metadata accessor for NWBrowser.Result);
          (*v132)(v82, v134);
          nw_endpoint_t v67 = v75;
        }
        else
        {
          BOOL v84 = v111;
          (*v133)(v111, v82, AssociatedTypeWitness);
          (*v130)(v118, v84, AssociatedTypeWitness);
          swift_storeEnumTagMultiPayload();
          sub_183D44F0C();
          uint64_t v66 = (uint64_t)v123;
          sub_183D44EEC();
          __int16 v85 = v84;
          int64_t v72 = v137;
          (*v131)(v85, AssociatedTypeWitness);
          __int16 v86 = &v148;
LABEL_51:
          sub_18315E3FC(*(v86 - 32), type metadata accessor for NWBrowser.Result);
          nw_endpoint_t v67 = v75;
        }
        break;
    }
  }
LABEL_60:
  swift_release();
  uint64_t v144 = v147;
  uint64_t v145 = v146;
  sub_183D4511C();
  __int16 v102 = v104;
  sub_183D450FC();
  return (*(uint64_t (**)(char *, uint64_t))(v105 + 8))(v102, v106);
}

uint64_t Browser1.deinit()
{
  (*(void (**)(uint64_t))(*(void *)(*(void *)(*(void *)v0 + 80) - 8) + 8))(v0 + *(void *)(*(void *)v0 + 96));
  swift_release();
  return v0;
}

uint64_t Browser1.__deallocating_deinit()
{
  Browser1.deinit();

  return swift_deallocClassInstance();
}

uint64_t sub_1834B1D88()
{
  Browser1.makeAsyncIterator()();

  return swift_release();
}

uint64_t AsyncSequence<>.firstFoundEndpoint(where:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v7[6] = a5;
  v7[7] = v6;
  v7[4] = a3;
  v7[5] = a4;
  v7[2] = a1;
  v7[3] = a2;
  v7[8] = *(void *)(*(void *)(*(void *)(*(void *)(a6 + 8) + 8) + 8) + 8);
  swift_getAssociatedTypeWitness();
  v7[9] = swift_getAssociatedTypeWitness();
  sub_183D4536C();
  v7[10] = swift_task_alloc();
  uint64_t v9 = swift_checkMetadataState();
  v7[11] = v9;
  v7[12] = *(void *)(v9 - 8);
  v7[13] = swift_task_alloc();
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness();
  v7[14] = AssociatedTypeWitness;
  v7[15] = *(void *)(AssociatedTypeWitness - 8);
  v7[16] = swift_task_alloc();
  uint64_t v11 = swift_getAssociatedTypeWitness();
  v7[17] = v11;
  v7[18] = *(void *)(v11 - 8);
  v7[19] = swift_task_alloc();
  v7[20] = swift_task_alloc();
  sub_183D4536C();
  v7[21] = swift_task_alloc();
  v7[22] = *(void *)(a4 - 8);
  v7[23] = swift_task_alloc();
  uint64_t v12 = swift_getAssociatedTypeWitness();
  v7[24] = v12;
  v7[25] = *(void *)(v12 - 8);
  v7[26] = swift_task_alloc();
  return MEMORY[0x1F4188298](sub_1834B212C, 0, 0);
}

uint64_t sub_1834B212C()
{
  (*(void (**)(void, void, void))(v0[22] + 16))(v0[23], v0[7], v0[5]);
  sub_183D4509C();
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness();
  v0[27] = AssociatedConformanceWitness;
  int64_t v2 = (void *)swift_task_alloc();
  v0[28] = v2;
  void *v2 = v0;
  v2[1] = sub_1834B2240;
  uint64_t v3 = v0[24];
  uint64_t v5 = v0[20];
  uint64_t v4 = v0[21];
  return MEMORY[0x1F4187C80](v4, 0, 0, v5, v3, AssociatedConformanceWitness);
}

uint64_t sub_1834B2240()
{
  *(void *)(*(void *)v1 + 232) = v0;
  swift_task_dealloc();
  if (v0) {
    int64_t v2 = sub_1834B2770;
  }
  else {
    int64_t v2 = sub_1834B2354;
  }
  return MEMORY[0x1F4188298](v2, 0, 0);
}

uint64_t sub_1834B2354()
{
  uint64_t v1 = v0[21];
  uint64_t v2 = v0[11];
  uint64_t v3 = v0[12];
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v3 + 48))(v1, 1, v2) == 1)
  {
    uint64_t v4 = v0[29];
    (*(void (**)(void, void))(v0[25] + 8))(v0[26], v0[24]);
    sub_183D4508C();
    if (v4)
    {
      swift_task_dealloc();
      swift_task_dealloc();
      swift_task_dealloc();
      swift_task_dealloc();
      swift_task_dealloc();
      swift_task_dealloc();
      swift_task_dealloc();
      swift_task_dealloc();
      uint64_t v5 = (uint64_t (*)(void))v0[1];
LABEL_12:
      return v5();
    }
    else
    {
      return sub_183D456CC();
    }
  }
  else
  {
    (*(void (**)(void, uint64_t, uint64_t))(v3 + 32))(v0[13], v1, v2);
    sub_183D44D5C();
    while (1)
    {
      uint64_t v6 = v0[10];
      uint64_t v7 = v0[9];
      swift_getAssociatedConformanceWitness();
      sub_183D4539C();
      uint64_t v8 = *(void *)(v7 - 8);
      if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v8 + 48))(v6, 1, v7) == 1) {
        break;
      }
      uint64_t v9 = (uint64_t (*)(uint64_t))v0[3];
      uint64_t v10 = v0[2];
      (*(void (**)(uint64_t, void, void))(v8 + 32))(v10, v0[10], v0[9]);
      if (v9(v10))
      {
        uint64_t v17 = v0[25];
        uint64_t v16 = v0[26];
        uint64_t v18 = v0[24];
        (*(void (**)(void, void))(v0[15] + 8))(v0[16], v0[14]);
        (*(void (**)(uint64_t, uint64_t))(v17 + 8))(v16, v18);
        swift_task_dealloc();
        swift_task_dealloc();
        swift_task_dealloc();
        swift_task_dealloc();
        swift_task_dealloc();
        swift_task_dealloc();
        swift_task_dealloc();
        swift_task_dealloc();
        uint64_t v5 = (uint64_t (*)(void))v0[1];
        goto LABEL_12;
      }
      (*(void (**)(void, void))(v8 + 8))(v0[2], v0[9]);
    }
    (*(void (**)(void, void))(v0[15] + 8))(v0[16], v0[14]);
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness();
    v0[27] = AssociatedConformanceWitness;
    uint64_t v12 = (void *)swift_task_alloc();
    v0[28] = v12;
    void *v12 = v0;
    v12[1] = sub_1834B2240;
    uint64_t v13 = v0[24];
    uint64_t v15 = v0[20];
    uint64_t v14 = v0[21];
    return MEMORY[0x1F4187C80](v14, 0, 0, v15, v13, AssociatedConformanceWitness);
  }
}

uint64_t sub_1834B2770()
{
  uint64_t v1 = *(void (**)(uint64_t, uint64_t, uint64_t))(v0[18] + 32);
  v1(v0[19], v0[20], v0[17]);
  swift_getAssociatedConformanceWitness();
  uint64_t v2 = sub_183D458FC();
  uint64_t v3 = v0[19];
  if (v2)
  {
    (*(void (**)(void, void))(v0[18] + 8))(v0[19], v0[17]);
  }
  else
  {
    uint64_t v4 = v0[17];
    swift_allocError();
    v1(v5, v3, v4);
  }
  (*(void (**)(void, void))(v0[25] + 8))(v0[26], v0[24]);
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  uint64_t v6 = (uint64_t (*)(void))v0[1];
  return v6();
}

uint64_t AsyncSequence<>.mapEndpoints<A>(to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  MEMORY[0x1F4188790](a1);
  (*(void (**)(char *, uint64_t))(v13 + 16))((char *)&v17 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0), v14);
  uint64_t v15 = (void *)swift_allocObject();
  v15[2] = a3;
  v15[3] = a4;
  v15[4] = a5;
  v15[5] = a6;
  void v15[6] = a1;
  v15[7] = a2;
  type metadata accessor for BrowseResult();
  swift_retain();
  sub_183D450AC();
  return swift_release();
}

uint64_t sub_1834B2A60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v8[9] = a6;
  v8[10] = a8;
  v8[7] = a3;
  v8[8] = a4;
  v8[5] = a1;
  v8[6] = a2;
  v8[11] = type metadata accessor for BrowseResult.Change();
  v8[12] = swift_task_alloc();
  v8[13] = swift_getAssociatedTypeWitness();
  swift_getAssociatedTypeWitness();
  uint64_t v10 = type metadata accessor for BrowseResult.Change();
  v8[14] = v10;
  uint64_t v11 = *(void *)(v10 - 8);
  v8[15] = v11;
  v8[16] = *(void *)(v11 + 64);
  v8[17] = swift_task_alloc();
  v8[18] = swift_task_alloc();
  v8[19] = swift_task_alloc();
  v8[20] = *(void *)(a6 - 8);
  v8[21] = swift_task_alloc();
  v8[22] = swift_task_alloc();
  uint64_t v12 = swift_checkMetadataState();
  v8[23] = v12;
  uint64_t v13 = *(void *)(v12 - 8);
  v8[24] = v13;
  v8[25] = *(void *)(v13 + 64);
  v8[26] = swift_task_alloc();
  v8[27] = swift_task_alloc();
  v8[28] = swift_task_alloc();
  return MEMORY[0x1F4188298](sub_1834B2CD8, 0, 0);
}

uint64_t sub_1834B2CD8()
{
  uint64_t v1 = v0[23];
  uint64_t v2 = v0[10];
  uint64_t v95 = sub_183D44EAC();
  uint64_t v96 = sub_183D44EAC();
  uint64_t v3 = *(uint64_t (**)(uint64_t, uint64_t))(v2 + 24);
  uint64_t v76 = swift_checkMetadataState();
  uint64_t v4 = v3(v76, v2);
  if (MEMORY[0x1853142D0](v4, v1))
  {
    uint64_t v5 = 0;
    int64_t v73 = v0 + 2;
    uint64_t v74 = v0[25];
    uint64_t v6 = v0[24];
    uint64_t v90 = (void (**)(uint64_t, void *, uint64_t))(v6 + 16);
    uint64_t v7 = v0[20];
    BOOL v82 = (void (**)(uint64_t, uint64_t, uint64_t))(v7 + 16);
    __int16 v85 = (void (**)(uint64_t, uint64_t, uint64_t))(v6 + 32);
    uint64_t v88 = v6;
    unint64_t v78 = (void (**)(uint64_t, uint64_t))(v6 + 8);
    uint64_t v80 = (void (**)(uint64_t, uint64_t))(v7 + 8);
    do
    {
      char v8 = sub_183D44ECC();
      sub_183D44E7C();
      if (v8)
      {
        uint64_t v9 = v0;
        (*(void (**)(void, unint64_t, void))(v88 + 16))(v0[28], v4+ ((*(unsigned __int8 *)(v88 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v88 + 80))+ *(void *)(v88 + 72) * v5, v0[23]);
        uint64_t v10 = v5 + 1;
        if (__OFADD__(v5, 1)) {
          goto LABEL_10;
        }
      }
      else
      {
        uint64_t result = sub_183D454CC();
        if (v74 != 8)
        {
          __break(1u);
LABEL_37:
          __break(1u);
LABEL_38:
          __break(1u);
          return result;
        }
        uint64_t v20 = result;
        uint64_t v21 = v0[28];
        uint64_t v22 = v0[23];
        uint64_t v9 = v0;
        v0[2] = v20;
        (*v90)(v21, v73, v22);
        swift_unknownObjectRelease();
        uint64_t v10 = v5 + 1;
        if (__OFADD__(v5, 1))
        {
LABEL_10:
          __break(1u);
          break;
        }
      }
      uint64_t v0 = v9;
      uint64_t v12 = v9[27];
      uint64_t v11 = v9[28];
      uint64_t v14 = v9[22];
      uint64_t v13 = v9[23];
      uint64_t v15 = v9[21];
      uint64_t v16 = v9[9];
      uint64_t v17 = v4;
      uint64_t v18 = (void (*)(uint64_t))v0[7];
      uint64_t v92 = v10;
      (*v85)(v12, v11, v13);
      v18(v12);
      uint64_t v4 = v17;
      (*v82)(v15, v14, v16);
      sub_183D44F0C();
      sub_183D44EEC();
      (*v80)(v14, v16);
      (*v78)(v12, v13);
      ++v5;
    }
    while (v92 != MEMORY[0x1853142D0](v17, v13));
  }
  swift_bridgeObjectRelease();
  uint64_t v23 = v0[14];
  __int16 v86 = *(uint64_t (**)(uint64_t))(v0[10] + 32);
  uint64_t v24 = v86(v76);
  if (!MEMORY[0x1853142D0](v24, v23)) {
    goto LABEL_21;
  }
  uint64_t v25 = 0;
  uint64_t v26 = v0[15];
  uint64_t v83 = v0[16];
  BOOL v93 = (void (**)(uint64_t, uint64_t, uint64_t))(v26 + 16);
  while (1)
  {
    char v27 = sub_183D44ECC();
    sub_183D44E7C();
    if (v27)
    {
      uint64_t v28 = *(void (**)(uint64_t, uint64_t, uint64_t))(v26 + 16);
      v28(v0[19], v24+ ((*(unsigned __int8 *)(v26 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v26 + 80))+ *(void *)(v26 + 72) * v25, v0[14]);
      uint64_t v29 = v25 + 1;
      if (__OFADD__(v25, 1)) {
        break;
      }
      goto LABEL_15;
    }
    uint64_t result = sub_183D454CC();
    if (v83 != 8) {
      goto LABEL_37;
    }
    uint64_t v34 = result;
    uint64_t v35 = v0[19];
    uint64_t v36 = v0[14];
    v0[3] = v34;
    uint64_t v28 = *v93;
    (*v93)(v35, (uint64_t)(v0 + 3), v36);
    swift_unknownObjectRelease();
    uint64_t v29 = v25 + 1;
    if (__OFADD__(v25, 1)) {
      break;
    }
LABEL_15:
    uint64_t v30 = v0[19];
    uint64_t v31 = v0[14];
    __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F62B30);
    uint64_t v32 = swift_allocObject();
    *(_OWORD *)(v32 + 16) = xmmword_183D53660;
    *(void *)(v32 + 56) = v31;
    boxed_opaque_existential_0 = __swift_allocate_boxed_opaque_existential_0((uint64_t *)(v32 + 32));
    v28((uint64_t)boxed_opaque_existential_0, v30, v31);
    sub_183D45ADC();
    swift_bridgeObjectRelease();
    (*(void (**)(uint64_t, uint64_t))(v26 + 8))(v30, v31);
    ++v25;
    if (v29 == MEMORY[0x1853142D0](v24, v31)) {
      goto LABEL_21;
    }
  }
  __break(1u);
LABEL_21:
  uint64_t v37 = v0[14];
  uint64_t v38 = v0[10];
  swift_bridgeObjectRelease();
  uint64_t v39 = ((uint64_t (*)(uint64_t, uint64_t))v86)(v76, v38);
  if (!MEMORY[0x1853142D0](v39, v37)) {
    goto LABEL_33;
  }
  uint64_t v40 = 0;
  uint64_t v41 = v0[24];
  uint64_t v42 = v0[20];
  uint64_t v67 = v0[16];
  uint64_t v43 = v0[15];
  __int16 v91 = (void (**)(uint64_t, uint64_t, uint64_t))(v43 + 16);
  uint64_t v89 = v43;
  uint64_t v87 = (void (**)(uint64_t, uint64_t, uint64_t))(v41 + 32);
  __int16 v81 = (void (**)(uint64_t, uint64_t))(v42 + 8);
  BOOL v84 = (void (**)(uint64_t, uint64_t, uint64_t))(v42 + 16);
  unint64_t v77 = (void (**)(void, void, void))(v43 + 32);
  int64_t v79 = (void (**)(uint64_t, uint64_t))(v41 + 8);
  uint64_t v68 = v39;
  while (2)
  {
    char v49 = sub_183D44ECC();
    sub_183D44E7C();
    if (v49)
    {
      (*(void (**)(void, unint64_t, void))(v89 + 16))(v0[18], v39+ ((*(unsigned __int8 *)(v89 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v89 + 80))+ *(void *)(v89 + 72) * v40, v0[14]);
      uint64_t v50 = v40 + 1;
      if (__OFADD__(v40, 1)) {
        break;
      }
      goto LABEL_26;
    }
    uint64_t result = sub_183D454CC();
    if (v67 != 8) {
      goto LABEL_38;
    }
    uint64_t v62 = result;
    uint64_t v63 = v0[18];
    uint64_t v64 = v0[14];
    v0[4] = v62;
    (*v91)(v63, (uint64_t)(v0 + 4), v64);
    swift_unknownObjectRelease();
    uint64_t v50 = v40 + 1;
    if (!__OFADD__(v40, 1))
    {
LABEL_26:
      uint64_t v94 = v50;
      (*v77)(v0[17], v0[18], v0[14]);
      if (swift_getEnumCaseMultiPayload() > 1)
      {
        uint64_t v51 = v0[26];
        uint64_t v52 = v0[27];
        uint64_t v53 = v0[23];
        uint64_t v70 = v0[22];
        uint64_t v71 = v0[21];
        uint64_t v54 = v0[17];
        uint64_t v72 = v0[12];
        uint64_t v55 = v0[9];
        uint64_t v69 = (void (*)(uint64_t))v0[7];
        uint64_t v56 = v54 + *(int *)(swift_getTupleTypeMetadata2() + 48);
        unint64_t v57 = *v87;
        (*v87)(v52, v54, v53);
        v57(v51, v56, v53);
        uint64_t v39 = v68;
        v69(v52);
        v69(v51);
        uint64_t v58 = v72 + *(int *)(swift_getTupleTypeMetadata2() + 48);
        int v59 = *v84;
        (*v84)(v72, v70, v55);
        v59(v58, v71, v55);
        swift_storeEnumTagMultiPayload();
        sub_183D44F0C();
        sub_183D44EEC();
        unint64_t v60 = *v81;
        (*v81)(v71, v55);
        v60(v70, v55);
        BOOL v61 = *v79;
        (*v79)(v51, v53);
        v61(v52, v53);
      }
      else
      {
        uint64_t v44 = v0[27];
        uint64_t v45 = v0[22];
        uint64_t v75 = v0[23];
        uint64_t v46 = v0[12];
        uint64_t v47 = v0[9];
        uint64_t v48 = (void (*)(uint64_t))v0[7];
        ((void (*)(uint64_t, void))*v87)(v44, v0[17]);
        v48(v44);
        (*v84)(v46, v45, v47);
        swift_storeEnumTagMultiPayload();
        sub_183D44F0C();
        sub_183D44EEC();
        (*v81)(v45, v47);
        (*v79)(v44, v75);
      }
      ++v40;
      if (v94 == MEMORY[0x1853142D0](v39, v0[14])) {
        goto LABEL_33;
      }
      continue;
    }
    break;
  }
  __break(1u);
LABEL_33:
  uint64_t v65 = (uint64_t *)v0[5];
  swift_bridgeObjectRelease();
  *uint64_t v65 = v95;
  v65[1] = v96;
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  uint64_t v66 = (uint64_t (*)(void))v0[1];
  return v66();
}

uint64_t AsyncSequence<>.filterEndpoints(where:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  MEMORY[0x1F4188790](a1);
  (*(void (**)(char *, uint64_t))(v11 + 16))((char *)&v15 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0), v12);
  uint64_t v13 = (void *)swift_allocObject();
  v13[2] = a3;
  v13[3] = a4;
  v13[4] = a5;
  v13[5] = a1;
  v13[6] = a2;
  swift_getAssociatedTypeWitness();
  swift_getAssociatedTypeWitness();
  type metadata accessor for BrowseResult();
  swift_retain();
  sub_183D450AC();
  return swift_release();
}

uint64_t sub_1834B3830(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v7[7] = a4;
  v7[8] = a7;
  v7[5] = a2;
  v7[6] = a3;
  v7[4] = a1;
  v7[9] = swift_getAssociatedTypeWitness();
  swift_getAssociatedTypeWitness();
  uint64_t v8 = type metadata accessor for BrowseResult.Change();
  v7[10] = v8;
  uint64_t v9 = *(void *)(v8 - 8);
  v7[11] = v9;
  v7[12] = *(void *)(v9 + 64);
  v7[13] = swift_task_alloc();
  v7[14] = swift_task_alloc();
  v7[15] = swift_task_alloc();
  uint64_t v10 = swift_checkMetadataState();
  v7[16] = v10;
  uint64_t v11 = *(void *)(v10 - 8);
  v7[17] = v11;
  v7[18] = *(void *)(v11 + 64);
  v7[19] = swift_task_alloc();
  v7[20] = swift_task_alloc();
  v7[21] = swift_task_alloc();
  v7[22] = swift_task_alloc();
  v7[23] = swift_task_alloc();
  v7[24] = swift_task_alloc();
  v7[25] = swift_task_alloc();
  return MEMORY[0x1F4188298](sub_1834B3A30, 0, 0);
}

uint64_t sub_1834B3A30()
{
  uint64_t v1 = v0[16];
  uint64_t v2 = v0[8];
  uint64_t v67 = sub_183D44EAC();
  uint64_t v68 = sub_183D44EAC();
  uint64_t v3 = *(uint64_t (**)(uint64_t, uint64_t))(v2 + 24);
  uint64_t v62 = swift_checkMetadataState();
  uint64_t v4 = v3(v62, v2);
  if (MEMORY[0x1853142D0](v4, v1))
  {
    uint64_t v5 = 0;
    uint64_t v6 = v0[17];
    uint64_t v60 = v0[18];
    uint64_t v65 = (void (**)(uint64_t, uint64_t, uint64_t))(v6 + 16);
    do
    {
      char v8 = sub_183D44ECC();
      sub_183D44E7C();
      if (v8)
      {
        uint64_t v9 = *(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 16);
        v9(v0[25], v4+ ((*(unsigned __int8 *)(v6 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80))+ *(void *)(v6 + 72) * v5, v0[16]);
        uint64_t v10 = v5 + 1;
        if (__OFADD__(v5, 1)) {
          goto LABEL_11;
        }
      }
      else
      {
        uint64_t result = sub_183D454CC();
        if (v60 != 8)
        {
          __break(1u);
LABEL_36:
          __break(1u);
          return result;
        }
        uint64_t v14 = result;
        uint64_t v15 = v0[25];
        uint64_t v16 = v0[16];
        v0[2] = v14;
        uint64_t v9 = *v65;
        (*v65)(v15, (uint64_t)(v0 + 2), v16);
        swift_unknownObjectRelease();
        uint64_t v10 = v5 + 1;
        if (__OFADD__(v5, 1))
        {
LABEL_11:
          __break(1u);
          break;
        }
      }
      uint64_t v11 = v0[24];
      uint64_t v12 = (uint64_t (*)(uint64_t))v0[6];
      (*(void (**)(uint64_t, void, void))(v6 + 32))(v11, v0[25], v0[16]);
      if (v12(v11))
      {
        v9(v0[23], v0[24], v0[16]);
        sub_183D44F0C();
        sub_183D44EEC();
      }
      uint64_t v7 = v0[16];
      (*(void (**)(void, uint64_t))(v6 + 8))(v0[24], v7);
      ++v5;
    }
    while (v10 != MEMORY[0x1853142D0](v4, v7));
  }
  swift_bridgeObjectRelease();
  uint64_t v17 = v0[10];
  uint64_t v18 = (*(uint64_t (**)(uint64_t))(v0[8] + 32))(v62);
  if (!MEMORY[0x1853142D0](v18, v17)) {
    goto LABEL_32;
  }
  uint64_t v19 = 0;
  uint64_t v20 = v0[17];
  uint64_t v21 = v0[11];
  uint64_t v54 = v0[12];
  uint64_t v64 = (void (**)(void, void, void))(v21 + 32);
  uint64_t v66 = (void (**)(uint64_t, uint64_t, uint64_t))(v21 + 16);
  uint64_t v63 = (void (**)(uint64_t, uint64_t, uint64_t))(v20 + 32);
  uint64_t v22 = (void (**)(uint64_t, uint64_t))(v20 + 8);
  uint64_t v57 = v18;
  uint64_t v58 = (void (**)(uint64_t, uint64_t, uint64_t))(v20 + 16);
  uint64_t v55 = (void (**)(uint64_t, uint64_t))(v20 + 8);
  uint64_t v56 = v21;
  while (1)
  {
    char v24 = sub_183D44ECC();
    sub_183D44E7C();
    if ((v24 & 1) == 0) {
      break;
    }
    (*(void (**)(void, unint64_t, void))(v21 + 16))(v0[15], v18+ ((*(unsigned __int8 *)(v21 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v21 + 80))+ *(void *)(v21 + 72) * v19, v0[10]);
    uint64_t v23 = v19 + 1;
    if (__OFADD__(v19, 1)) {
      goto LABEL_31;
    }
LABEL_19:
    (*v64)(v0[14], v0[15], v0[10]);
    int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
    if (!EnumCaseMultiPayload)
    {
      uint64_t v32 = v0[22];
      uint64_t v33 = (uint64_t (*)(uint64_t))v0[6];
      (*v63)(v32, v0[14], v0[16]);
      char v34 = v33(v32);
      uint64_t v29 = v0[22];
      uint64_t v30 = v0[16];
      if ((v34 & 1) == 0) {
        goto LABEL_15;
      }
      uint64_t v31 = v23;
      (*v58)(v0[13], v0[22], v0[16]);
      goto LABEL_14;
    }
    if (EnumCaseMultiPayload != 1)
    {
      uint64_t v61 = v23;
      uint64_t v36 = v0[19];
      uint64_t v35 = v0[20];
      uint64_t v37 = v0[16];
      uint64_t v38 = v0[14];
      int v59 = (uint64_t (*)(uint64_t))v0[6];
      TupleTypeMetadata2 = swift_getTupleTypeMetadata2();
      uint64_t v40 = v38 + *(int *)(TupleTypeMetadata2 + 48);
      uint64_t v41 = *v63;
      (*v63)(v35, v38, v37);
      v41(v36, v40, v37);
      char v42 = v59(v36);
      uint64_t v44 = v0[19];
      uint64_t v43 = v0[20];
      uint64_t v45 = v0[16];
      if (v42)
      {
        uint64_t v46 = v0[13] + *(int *)(TupleTypeMetadata2 + 48);
        uint64_t v47 = *v58;
        (*v58)(v0[13], v0[20], v0[16]);
        v47(v46, v44, v45);
        swift_storeEnumTagMultiPayload();
        sub_183D44F0C();
        sub_183D44EEC();
      }
      uint64_t v22 = v55;
      uint64_t v48 = *v55;
      (*v55)(v44, v45);
      v48(v43, v45);
      uint64_t v21 = v56;
      uint64_t v18 = v57;
      uint64_t v23 = v61;
      goto LABEL_16;
    }
    uint64_t v26 = v0[21];
    char v27 = (uint64_t (*)(uint64_t))v0[6];
    (*v63)(v26, v0[14], v0[16]);
    char v28 = v27(v26);
    uint64_t v29 = v0[21];
    uint64_t v30 = v0[16];
    if (v28)
    {
      uint64_t v31 = v23;
      (*v58)(v0[13], v0[21], v0[16]);
LABEL_14:
      swift_storeEnumTagMultiPayload();
      sub_183D44F0C();
      uint64_t v23 = v31;
      sub_183D44EEC();
    }
LABEL_15:
    (*v22)(v29, v30);
LABEL_16:
    ++v19;
    if (v23 == MEMORY[0x1853142D0](v18, v0[10])) {
      goto LABEL_32;
    }
  }
  uint64_t result = sub_183D454CC();
  if (v54 != 8) {
    goto LABEL_36;
  }
  uint64_t v49 = result;
  uint64_t v50 = v0[15];
  uint64_t v51 = v0[10];
  v0[3] = v49;
  (*v66)(v50, (uint64_t)(v0 + 3), v51);
  swift_unknownObjectRelease();
  uint64_t v23 = v19 + 1;
  if (!__OFADD__(v19, 1)) {
    goto LABEL_19;
  }
LABEL_31:
  __break(1u);
LABEL_32:
  uint64_t v52 = (uint64_t *)v0[4];
  swift_bridgeObjectRelease();
  *uint64_t v52 = v67;
  v52[1] = v68;
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  uint64_t v53 = (uint64_t (*)(void))v0[1];
  return v53();
}

void *sub_1834B412C(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }
  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2) {
    goto LABEL_8;
  }
  if (v7 + 0x4000000000000000 >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
      uint64_t v7 = a2;
    }
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F61F58);
      uint64_t v10 = (void *)swift_allocObject();
      int64_t v11 = _swift_stdlib_malloc_size(v10);
      uint64_t v12 = v11 - 32;
      if (v11 < 32) {
        uint64_t v12 = v11 + 31;
      }
      v10[2] = v8;
      v10[3] = 2 * (v12 >> 6);
      uint64_t v13 = v10 + 4;
      if (v5) {
        goto LABEL_15;
      }
    }
    else
    {
      uint64_t v10 = (void *)MEMORY[0x1E4FBC860];
      uint64_t v13 = (void *)(MEMORY[0x1E4FBC860] + 32);
      if (result)
      {
LABEL_15:
        if (v10 != a4 || v13 >= &a4[8 * v8 + 4]) {
          memmove(v13, a4 + 4, v8 << 6);
        }
        a4[2] = 0;
        goto LABEL_24;
      }
    }
    sub_1834B5678(0, v8, (unint64_t)v13, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease();
    return v10;
  }
  __break(1u);
  return result;
}

void *sub_1834B423C(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }
  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2) {
    goto LABEL_8;
  }
  if (v7 + 0x4000000000000000 >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
      uint64_t v7 = a2;
    }
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F61F78);
      uint64_t v10 = (void *)swift_allocObject();
      int64_t v11 = _swift_stdlib_malloc_size(v10);
      uint64_t v12 = v11 - 32;
      if (v11 < 32) {
        uint64_t v12 = v11 - 17;
      }
      v10[2] = v8;
      v10[3] = 2 * (v12 >> 4);
      uint64_t v13 = v10 + 4;
      if (v5) {
        goto LABEL_15;
      }
    }
    else
    {
      uint64_t v10 = (void *)MEMORY[0x1E4FBC860];
      uint64_t v13 = (void *)(MEMORY[0x1E4FBC860] + 32);
      if (result)
      {
LABEL_15:
        if (v10 != a4 || v13 >= &a4[2 * v8 + 4]) {
          memmove(v13, a4 + 4, 16 * v8);
        }
        a4[2] = 0;
        goto LABEL_24;
      }
    }
    sub_1834B5500(0, v8, (unint64_t)v13, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease();
    return v10;
  }
  __break(1u);
  return result;
}

void *sub_1834B434C(void *a1, int64_t a2, char a3, void *a4)
{
  return sub_1834B52C0(a1, a2, a3, a4, &qword_1E8F62B38, &qword_1E8F627B8);
}

void *sub_1834B4360(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }
  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2) {
    goto LABEL_8;
  }
  if (v7 + 0x4000000000000000 >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
      uint64_t v7 = a2;
    }
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F62B20);
      uint64_t v10 = (void *)swift_allocObject();
      size_t v11 = _swift_stdlib_malloc_size(v10);
      v10[2] = v8;
      v10[3] = 2 * ((uint64_t)(v11 - 32) / 48);
      uint64_t v12 = v10 + 4;
      if (v5)
      {
LABEL_13:
        if (v10 != a4 || v12 >= &a4[6 * v8 + 4]) {
          memmove(v12, a4 + 4, 48 * v8);
        }
        a4[2] = 0;
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v10 = (void *)MEMORY[0x1E4FBC860];
      uint64_t v12 = (void *)(MEMORY[0x1E4FBC860] + 32);
      if (result) {
        goto LABEL_13;
      }
    }
    sub_1834B84E8(0, v8, (unint64_t)v12, (uint64_t)a4);
LABEL_22:
    swift_bridgeObjectRelease();
    return v10;
  }
  __break(1u);
  return result;
}

void *sub_1834B4488(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }
  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2) {
    goto LABEL_8;
  }
  if (v7 + 0x4000000000000000 >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
      uint64_t v7 = a2;
    }
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F62AF0);
      uint64_t v10 = (void *)swift_allocObject();
      int64_t v11 = _swift_stdlib_malloc_size(v10);
      uint64_t v12 = v11 - 32;
      if (v11 < 32) {
        uint64_t v12 = v11 - 17;
      }
      v10[2] = v8;
      v10[3] = 2 * (v12 >> 4);
      uint64_t v13 = v10 + 4;
      if (v5) {
        goto LABEL_15;
      }
    }
    else
    {
      uint64_t v10 = (void *)MEMORY[0x1E4FBC860];
      uint64_t v13 = (void *)(MEMORY[0x1E4FBC860] + 32);
      if (result)
      {
LABEL_15:
        if (v10 != a4 || v13 >= &a4[2 * v8 + 4]) {
          memmove(v13, a4 + 4, 16 * v8);
        }
        a4[2] = 0;
        goto LABEL_24;
      }
    }
    sub_1834B85F8(0, v8, (unint64_t)v13, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease();
    return v10;
  }
  __break(1u);
  return result;
}

char *sub_1834B4598(char *a1, int64_t a2, char a3, char *a4)
{
  return sub_1834B45B8(a1, a2, a3, a4, &qword_1E8F61ED0);
}

uint64_t sub_1834B45A4(char a1, int64_t a2, char a3, unint64_t a4)
{
  return sub_1834B46C4(a1, a2, a3, a4, &qword_1E8F62B10, &qword_1E8F62B18);
}

char *sub_1834B45B8(char *result, int64_t a2, char a3, char *a4, uint64_t *a5)
{
  char v6 = (char)result;
  if ((a3 & 1) == 0)
  {
    int64_t v8 = a2;
    goto LABEL_8;
  }
  unint64_t v7 = *((void *)a4 + 3);
  int64_t v8 = v7 >> 1;
  if ((uint64_t)(v7 >> 1) >= a2) {
    goto LABEL_8;
  }
  if (v8 + 0x4000000000000000 >= 0)
  {
    int64_t v8 = v7 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v7 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
      int64_t v8 = a2;
    }
LABEL_8:
    int64_t v9 = *((void *)a4 + 2);
    if (v8 <= v9) {
      int64_t v10 = *((void *)a4 + 2);
    }
    else {
      int64_t v10 = v8;
    }
    if (v10)
    {
      __swift_instantiateConcreteTypeFromMangledName(a5);
      int64_t v11 = (char *)swift_allocObject();
      size_t v12 = _swift_stdlib_malloc_size(v11);
      *((void *)v11 + 2) = v9;
      *((void *)v11 + 3) = 2 * v12 - 64;
      uint64_t v13 = v11 + 32;
      if (v6)
      {
LABEL_13:
        if (v11 != a4 || v13 >= &a4[v9 + 32]) {
          memmove(v13, a4 + 32, v9);
        }
        *((void *)a4 + 2) = 0;
        goto LABEL_22;
      }
    }
    else
    {
      int64_t v11 = (char *)MEMORY[0x1E4FBC860];
      uint64_t v13 = (char *)(MEMORY[0x1E4FBC860] + 32);
      if (result) {
        goto LABEL_13;
      }
    }
    sub_1834B8DCC(0, v9, v13, (uint64_t)a4);
LABEL_22:
    swift_bridgeObjectRelease();
    return v11;
  }
  __break(1u);
  return result;
}

uint64_t sub_1834B46B0(char a1, int64_t a2, char a3, unint64_t a4)
{
  return sub_1834B46C4(a1, a2, a3, a4, &qword_1E8F62AE0, &qword_1E8F61A50);
}

uint64_t sub_1834B46C4(char a1, int64_t a2, char a3, unint64_t a4, uint64_t *a5, uint64_t *a6)
{
  if (a3)
  {
    unint64_t v9 = *(void *)(a4 + 24);
    uint64_t v10 = v9 >> 1;
    if ((uint64_t)(v9 >> 1) < a2)
    {
      if (v10 + 0x4000000000000000 < 0)
      {
        __break(1u);
        goto LABEL_29;
      }
      uint64_t v10 = v9 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v9 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
        uint64_t v10 = a2;
      }
    }
  }
  else
  {
    uint64_t v10 = a2;
  }
  uint64_t v11 = *(void *)(a4 + 16);
  if (v10 <= v11) {
    uint64_t v12 = *(void *)(a4 + 16);
  }
  else {
    uint64_t v12 = v10;
  }
  if (!v12)
  {
    uint64_t v16 = (void *)MEMORY[0x1E4FBC860];
    goto LABEL_19;
  }
  __swift_instantiateConcreteTypeFromMangledName(a5);
  uint64_t v13 = *(void *)(__swift_instantiateConcreteTypeFromMangledName(a6) - 8);
  uint64_t v14 = *(void *)(v13 + 72);
  unint64_t v15 = (*(unsigned __int8 *)(v13 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v13 + 80);
  uint64_t v16 = (void *)swift_allocObject();
  size_t v17 = _swift_stdlib_malloc_size(v16);
  if (!v14 || (v17 - v15 == 0x8000000000000000 ? (BOOL v18 = v14 == -1) : (BOOL v18 = 0), v18))
  {
LABEL_29:
    uint64_t result = sub_183D456BC();
    __break(1u);
    return result;
  }
  v16[2] = v11;
  v16[3] = 2 * ((uint64_t)(v17 - v15) / v14);
LABEL_19:
  uint64_t v19 = *(void *)(__swift_instantiateConcreteTypeFromMangledName(a6) - 8);
  unint64_t v20 = (*(unsigned __int8 *)(v19 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v19 + 80);
  unint64_t v21 = (unint64_t)v16 + v20;
  if (a1)
  {
    if ((unint64_t)v16 < a4 || v21 >= a4 + v20 + *(void *)(v19 + 72) * v11)
    {
      swift_arrayInitWithTakeFrontToBack();
    }
    else if (v16 != (void *)a4)
    {
      swift_arrayInitWithTakeBackToFront();
    }
    *(void *)(a4 + 16) = 0;
  }
  else
  {
    sub_1834B8FBC(0, v11, v21, a4, a6);
  }
  swift_bridgeObjectRelease();
  return (uint64_t)v16;
}

void *sub_1834B4930(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }
  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2) {
    goto LABEL_8;
  }
  if (v7 + 0x4000000000000000 >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
      uint64_t v7 = a2;
    }
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F62B00);
      uint64_t v10 = (void *)swift_allocObject();
      int64_t v11 = _swift_stdlib_malloc_size(v10);
      uint64_t v12 = v11 - 32;
      if (v11 < 32) {
        uint64_t v12 = v11 - 1;
      }
      v10[2] = v8;
      v10[3] = 2 * (v12 >> 5);
      uint64_t v13 = v10 + 4;
      if (v5) {
        goto LABEL_15;
      }
    }
    else
    {
      uint64_t v10 = (void *)MEMORY[0x1E4FBC860];
      uint64_t v13 = (void *)(MEMORY[0x1E4FBC860] + 32);
      if (result)
      {
LABEL_15:
        if (v10 != a4 || v13 >= &a4[4 * v8 + 4]) {
          memmove(v13, a4 + 4, 32 * v8);
        }
        a4[2] = 0;
        goto LABEL_24;
      }
    }
    sub_1834B87FC(0, v8, (unint64_t)v13, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease();
    return v10;
  }
  __break(1u);
  return result;
}

void *sub_1834B4A40(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }
  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2) {
    goto LABEL_8;
  }
  if (v7 + 0x4000000000000000 >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
      uint64_t v7 = a2;
    }
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F62AF8);
      uint64_t v10 = (void *)swift_allocObject();
      int64_t v11 = _swift_stdlib_malloc_size(v10);
      uint64_t v12 = v11 - 32;
      if (v11 < 32) {
        uint64_t v12 = v11 - 25;
      }
      v10[2] = v8;
      v10[3] = 2 * (v12 >> 3);
      uint64_t v13 = v10 + 4;
      if (v5) {
        goto LABEL_15;
      }
    }
    else
    {
      uint64_t v10 = (void *)MEMORY[0x1E4FBC860];
      uint64_t v13 = (void *)(MEMORY[0x1E4FBC860] + 32);
      if (result)
      {
LABEL_15:
        if (v10 != a4 || v13 >= &a4[v8 + 4]) {
          memmove(v13, a4 + 4, 8 * v8);
        }
        a4[2] = 0;
        goto LABEL_24;
      }
    }
    sub_1834B88F0(0, v8, (char *)v13, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease();
    return v10;
  }
  __break(1u);
  return result;
}

void *sub_1834B4B50(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }
  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2) {
    goto LABEL_8;
  }
  if (v7 + 0x4000000000000000 >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
      uint64_t v7 = a2;
    }
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      sub_183531248();
      uint64_t v10 = (void *)swift_allocObject();
      int64_t v11 = _swift_stdlib_malloc_size(v10);
      uint64_t v12 = v11 - 32;
      if (v11 < 32) {
        uint64_t v12 = v11 - 25;
      }
      v10[2] = v8;
      v10[3] = 2 * (v12 >> 3);
      uint64_t v13 = v10 + 4;
      if (v5) {
        goto LABEL_15;
      }
    }
    else
    {
      uint64_t v10 = (void *)MEMORY[0x1E4FBC860];
      uint64_t v13 = (void *)(MEMORY[0x1E4FBC860] + 32);
      if (result)
      {
LABEL_15:
        if (v10 != a4 || v13 >= &a4[v8 + 4]) {
          memmove(v13, a4 + 4, 8 * v8);
        }
        a4[2] = 0;
        goto LABEL_24;
      }
    }
    sub_1834B88F0(0, v8, (char *)v13, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease();
    return v10;
  }
  __break(1u);
  return result;
}

uint64_t sub_1834B4C64(char a1, int64_t a2, char a3, unint64_t a4)
{
  return sub_1832FF9B0(a1, a2, a3, a4, &qword_1E8F62B08, (uint64_t (*)(void))type metadata accessor for NWActorID, (uint64_t (*)(void))type metadata accessor for NWActorID);
}

void *sub_1834B4C98(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }
  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2) {
    goto LABEL_8;
  }
  if (v7 + 0x4000000000000000 >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
      uint64_t v7 = a2;
    }
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F62A80);
      uint64_t v10 = (void *)swift_allocObject();
      int64_t v11 = _swift_stdlib_malloc_size(v10);
      uint64_t v12 = v11 - 32;
      if (v11 < 32) {
        uint64_t v12 = v11 - 17;
      }
      v10[2] = v8;
      v10[3] = 2 * (v12 >> 4);
      uint64_t v13 = v10 + 4;
      if (v5) {
        goto LABEL_15;
      }
    }
    else
    {
      uint64_t v10 = (void *)MEMORY[0x1E4FBC860];
      uint64_t v13 = (void *)(MEMORY[0x1E4FBC860] + 32);
      if (result)
      {
LABEL_15:
        if (v10 != a4 || v13 >= &a4[2 * v8 + 4]) {
          memmove(v13, a4 + 4, 16 * v8);
        }
        a4[2] = 0;
        goto LABEL_24;
      }
    }
    sub_1834B8AD4(0, v8, (unint64_t)v13, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease();
    return v10;
  }
  __break(1u);
  return result;
}

void *sub_1834B4DA8(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }
  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2) {
    goto LABEL_8;
  }
  if (v7 + 0x4000000000000000 >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
      uint64_t v7 = a2;
    }
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F62AE8);
      uint64_t v10 = (void *)swift_allocObject();
      size_t v11 = _swift_stdlib_malloc_size(v10);
      v10[2] = v8;
      v10[3] = 2 * ((uint64_t)(v11 - 32) / 40);
      uint64_t v12 = v10 + 4;
      if (v5)
      {
LABEL_13:
        if (v10 != a4 || v12 >= &a4[5 * v8 + 4]) {
          memmove(v12, a4 + 4, 40 * v8);
        }
        a4[2] = 0;
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v10 = (void *)MEMORY[0x1E4FBC860];
      uint64_t v12 = (void *)(MEMORY[0x1E4FBC860] + 32);
      if (result) {
        goto LABEL_13;
      }
    }
    sub_1834B86EC(0, v8, (unint64_t)v12, (uint64_t)a4);
LABEL_22:
    swift_bridgeObjectRelease();
    return v10;
  }
  __break(1u);
  return result;
}

uint64_t sub_1834B4ECC(char a1, int64_t a2, char a3, unint64_t a4)
{
  return sub_1834B46C4(a1, a2, a3, a4, &qword_1E8F62AD8, &qword_1E8F644D0);
}

uint64_t sub_1834B4EE0(char a1, int64_t a2, char a3, unint64_t a4)
{
  return sub_1832FF9B0(a1, a2, a3, a4, &qword_1E8F62AD0, type metadata accessor for NWConnection.EstablishmentReport.Resolution, type metadata accessor for NWConnection.EstablishmentReport.Resolution);
}

void *sub_1834B4F14(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }
  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2) {
    goto LABEL_8;
  }
  if (v7 + 0x4000000000000000 >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
      uint64_t v7 = a2;
    }
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F62AC8);
      uint64_t v10 = (void *)swift_allocObject();
      size_t v11 = _swift_stdlib_malloc_size(v10);
      v10[2] = v8;
      v10[3] = 2 * ((uint64_t)(v11 - 32) / 24);
      uint64_t v12 = v10 + 4;
      if (v5)
      {
LABEL_13:
        if (v10 != a4 || v12 >= &a4[3 * v8 + 4]) {
          memmove(v12, a4 + 4, 24 * v8);
        }
        a4[2] = 0;
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v10 = (void *)MEMORY[0x1E4FBC860];
      uint64_t v12 = (void *)(MEMORY[0x1E4FBC860] + 32);
      if (result) {
        goto LABEL_13;
      }
    }
    sub_1834B8BE0(0, v8, (unint64_t)v12, (uint64_t)a4);
LABEL_22:
    swift_bridgeObjectRelease();
    return v10;
  }
  __break(1u);
  return result;
}

void *sub_1834B503C(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }
  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2) {
    goto LABEL_8;
  }
  if (v7 + 0x4000000000000000 >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
      uint64_t v7 = a2;
    }
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F61DB8);
      uint64_t v10 = (void *)swift_allocObject();
      size_t v11 = _swift_stdlib_malloc_size(v10);
      v10[2] = v8;
      v10[3] = 2 * ((uint64_t)(v11 - 32) / 104);
      uint64_t v12 = v10 + 4;
      if (v5)
      {
LABEL_13:
        if (v10 != a4 || v12 >= &a4[13 * v8 + 4]) {
          memmove(v12, a4 + 4, 104 * v8);
        }
        a4[2] = 0;
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v10 = (void *)MEMORY[0x1E4FBC860];
      uint64_t v12 = (void *)(MEMORY[0x1E4FBC860] + 32);
      if (result) {
        goto LABEL_13;
      }
    }
    sub_1834B8CD8(0, v8, (unint64_t)v12, (uint64_t)a4);
LABEL_22:
    swift_bridgeObjectRelease();
    return v10;
  }
  __break(1u);
  return result;
}

void *sub_1834B5168(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }
  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2) {
    goto LABEL_8;
  }
  if (v7 + 0x4000000000000000 >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
      uint64_t v7 = a2;
    }
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F61F70);
      uint64_t v10 = (void *)swift_allocObject();
      size_t v11 = _swift_stdlib_malloc_size(v10);
      v10[2] = v8;
      v10[3] = 2 * ((uint64_t)(v11 - 32) / 56);
      uint64_t v12 = v10 + 4;
      if (v5)
      {
LABEL_13:
        if (v10 != a4 || v12 >= &a4[7 * v8 + 4]) {
          memmove(v12, a4 + 4, 56 * v8);
        }
        a4[2] = 0;
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v10 = (void *)MEMORY[0x1E4FBC860];
      uint64_t v12 = (void *)(MEMORY[0x1E4FBC860] + 32);
      if (result) {
        goto LABEL_13;
      }
    }
    sub_1834B89DC(0, v8, (unint64_t)v12, (uint64_t)a4);
LABEL_22:
    swift_bridgeObjectRelease();
    return v10;
  }
  __break(1u);
  return result;
}

char *sub_1834B5294(char *a1, int64_t a2, char a3, char *a4)
{
  return sub_1834B45B8(a1, a2, a3, a4, &qword_1E8F62AC0);
}

char *sub_1834B52A0(char *a1, int64_t a2, char a3, char *a4)
{
  return sub_1834B45B8(a1, a2, a3, a4, &qword_1E8F62AB8);
}

void *sub_1834B52AC(void *a1, int64_t a2, char a3, void *a4)
{
  return sub_1834B52C0(a1, a2, a3, a4, &qword_1E8F62AA8, &qword_1E8F62AB0);
}

void *sub_1834B52C0(void *result, int64_t a2, char a3, void *a4, uint64_t *a5, uint64_t *a6)
{
  char v8 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v10 = a2;
    goto LABEL_8;
  }
  unint64_t v9 = a4[3];
  uint64_t v10 = v9 >> 1;
  if ((uint64_t)(v9 >> 1) >= a2) {
    goto LABEL_8;
  }
  if (v10 + 0x4000000000000000 >= 0)
  {
    uint64_t v10 = v9 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v9 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
      uint64_t v10 = a2;
    }
LABEL_8:
    uint64_t v11 = a4[2];
    if (v10 <= v11) {
      uint64_t v12 = a4[2];
    }
    else {
      uint64_t v12 = v10;
    }
    if (v12)
    {
      __swift_instantiateConcreteTypeFromMangledName(a5);
      uint64_t v13 = (void *)swift_allocObject();
      int64_t v14 = _swift_stdlib_malloc_size(v13);
      uint64_t v15 = v14 - 32;
      if (v14 < 32) {
        uint64_t v15 = v14 - 1;
      }
      v13[2] = v11;
      v13[3] = 2 * (v15 >> 5);
      uint64_t v16 = v13 + 4;
      if (v8) {
        goto LABEL_15;
      }
    }
    else
    {
      uint64_t v13 = (void *)MEMORY[0x1E4FBC860];
      uint64_t v16 = (void *)(MEMORY[0x1E4FBC860] + 32);
      if (result)
      {
LABEL_15:
        if (v13 != a4 || v16 >= &a4[4 * v11 + 4]) {
          memmove(v16, a4 + 4, 32 * v11);
        }
        a4[2] = 0;
        goto LABEL_24;
      }
    }
    sub_1834B8EB4(0, v11, (unint64_t)v16, (uint64_t)a4, a6);
LABEL_24:
    swift_bridgeObjectRelease();
    return v13;
  }
  __break(1u);
  return result;
}

uint64_t sub_1834B53DC(char a1, int64_t a2, char a3, unint64_t a4)
{
  return sub_1834B46C4(a1, a2, a3, a4, &qword_1E8F62A98, &qword_1E8F62AA0);
}

void *sub_1834B53F0(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }
  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2) {
    goto LABEL_8;
  }
  if (v7 + 0x4000000000000000 >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
      uint64_t v7 = a2;
    }
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F62A90);
      uint64_t v10 = (void *)swift_allocObject();
      int64_t v11 = _swift_stdlib_malloc_size(v10);
      uint64_t v12 = v11 - 32;
      if (v11 < 32) {
        uint64_t v12 = v11 - 25;
      }
      v10[2] = v8;
      v10[3] = 2 * (v12 >> 3);
      uint64_t v13 = v10 + 4;
      if (v5) {
        goto LABEL_15;
      }
    }
    else
    {
      uint64_t v10 = (void *)MEMORY[0x1E4FBC860];
      uint64_t v13 = (void *)(MEMORY[0x1E4FBC860] + 32);
      if (result)
      {
LABEL_15:
        if (v10 != a4 || v13 >= &a4[v8 + 4]) {
          memmove(v13, a4 + 4, 8 * v8);
        }
        a4[2] = 0;
        goto LABEL_24;
      }
    }
    sub_1834B88F0(0, v8, (char *)v13, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease();
    return v10;
  }
  __break(1u);
  return result;
}

uint64_t sub_1834B5500(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else if ((v4 & 0x8000000000000000) == 0)
  {
    unint64_t v5 = a4 + 16 * a1 + 32;
    unint64_t v6 = a3 + 16 * v4;
    if (v5 >= v6 || v5 + 16 * v4 <= a3)
    {
      swift_arrayInitWithCopy();
      return v6;
    }
  }
  uint64_t result = sub_183D4571C();
  __break(1u);
  return result;
}

uint64_t sub_1834B55F4()
{
  return *(void *)v0;
}

uint64_t sub_1834B55FC()
{
  return *(void *)(v0 + 8);
}

uint64_t type metadata accessor for BrowseResult.Change()
{
  return __swift_instantiateGenericMetadata();
}

unint64_t sub_1834B561C()
{
  unint64_t result = qword_1E8F61F68;
  if (!qword_1E8F61F68)
  {
    __swift_instantiateConcreteTypeFromMangledNameAbstract(&qword_1E8F61F60);
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F61F68);
  }
  return result;
}

uint64_t sub_1834B5678(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else if ((v4 & 0x8000000000000000) == 0)
  {
    unint64_t v5 = a4 + (a1 << 6) + 32;
    unint64_t v6 = a3 + (v4 << 6);
    if (v5 >= v6 || v5 + (v4 << 6) <= a3)
    {
      __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F61F48);
      swift_arrayInitWithCopy();
      return v6;
    }
  }
  uint64_t result = sub_183D4571C();
  __break(1u);
  return result;
}

uint64_t sub_1834B5784(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(void, uint64_t, uint64_t), uint64_t (*a6)(char *, char *, uint64_t, uint64_t))
{
  uint64_t v23 = a6;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness();
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness();
  uint64_t v11 = a5(0, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v12 = *(void *)(v11 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v22 - v14;
  uint64_t v16 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1F4188790](v13);
  BOOL v18 = (char *)&v22 - v17;
  char v19 = sub_183D44A9C();
  (*(void (**)(char *, uint64_t, uint64_t))(v16 + 16))(v18, a1, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v15, a2, v11);
  if ((v19 & 1) == 0)
  {
    (*(void (**)(char *, uint64_t))(v12 + 8))(v15, v11);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v16 + 8))(v18, AssociatedTypeWitness);
    goto LABEL_5;
  }
  char v20 = v23(v18, &v15[*(int *)(v11 + 36)], AssociatedTypeWitness, AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t))(v12 + 8))(v15, v11);
  uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v16 + 8))(v18, AssociatedTypeWitness);
  if ((v20 & 1) == 0) {
LABEL_5:
  }
    __break(1u);
  return result;
}

uint64_t sub_1834B59F8(uint64_t a1, uint64_t a2)
{
  swift_getAssociatedTypeWitness();
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness();
  uint64_t v5 = sub_183D4527C();
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = MEMORY[0x1F4188790](v5);
  uint64_t v9 = (char *)v17 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v7);
  uint64_t v11 = (char *)v17 - v10;
  v17[1] = AssociatedConformanceWitness;
  LOBYTE(AssociatedConformanceWitness) = sub_183D44A9C();
  uint64_t v12 = *(void (**)(char *, uint64_t, uint64_t))(v6 + 16);
  v12(v11, a1, v5);
  v12(v9, a2, v5);
  if ((AssociatedConformanceWitness & 1) == 0)
  {
    uint64_t v16 = *(void (**)(char *, uint64_t))(v6 + 8);
    v16(v9, v5);
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v16)(v11, v5);
    goto LABEL_5;
  }
  char v13 = sub_183D44A9C();
  uint64_t v14 = *(void (**)(char *, uint64_t))(v6 + 8);
  v14(v9, v5);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v14)(v11, v5);
  if ((v13 & 1) == 0) {
LABEL_5:
  }
    __break(1u);
  return result;
}

uint64_t sub_1834B5C04(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3;
  uint64_t v8 = *(void *)(*(void *)v4 + 80);
  uint64_t v9 = *(void *)(v8 - 8);
  MEMORY[0x1F4188790]();
  uint64_t v11 = (char *)&v15 - v10;
  char v13 = *(void (**)(char *, uint64_t, uint64_t))(v9 + 16);
  v13((char *)(v4 + *(void *)(v12 + 96)), a1, v8);
  v13(v11, a1, v8);
  if (!a2) {
    a2 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 8))(v8, a3);
  }
  (*(void (**)(char *, uint64_t))(v9 + 8))(v11, v8);
  *(void *)(v4 + *(void *)(*(void *)v4 + 104)) = a2;
  return v4;
}

uint64_t type metadata accessor for BrowseResult()
{
  return __swift_instantiateGenericMetadata();
}

void sub_1834B5D94(uint64_t a1)
{
  sub_1834B0504(a1, *(void *)(v1 + 16), *(void *)(v1 + 24));
}

uint64_t sub_1834B5D9C()
{
  swift_release();

  return swift_deallocObject();
}

uint64_t sub_1834B5DD4(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = v2[2];
  uint64_t v7 = v2[3];
  uint64_t v8 = v2[4];
  uint64_t v9 = v2[5];
  uint64_t v11 = v2[6];
  uint64_t v10 = v2[7];
  uint64_t v12 = (void *)swift_task_alloc();
  *(void *)(v3 + 16) = v12;
  void *v12 = v3;
  v12[1] = sub_1834B5EB0;
  return sub_1834B2A60(a1, a2, v11, v10, v6, v7, v8, v9);
}

uint64_t sub_1834B5EB0()
{
  uint64_t v3 = *v0;
  swift_task_dealloc();
  uint64_t v1 = *(uint64_t (**)(void))(v3 + 8);
  return v1();
}

uint64_t sub_1834B5FA4()
{
  swift_release();

  return swift_deallocObject();
}

uint64_t sub_1834B5FDC(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = v2[2];
  uint64_t v7 = v2[3];
  uint64_t v8 = v2[4];
  uint64_t v9 = v2[5];
  uint64_t v10 = v2[6];
  uint64_t v11 = (void *)swift_task_alloc();
  *(void *)(v3 + 16) = v11;
  *uint64_t v11 = v3;
  v11[1] = sub_1834B96A4;
  return sub_1834B3830(a1, a2, v9, v10, v6, v7, v8);
}

uint64_t sub_1834B60B4()
{
  return swift_getWitnessTable();
}

uint64_t sub_1834B60D0()
{
  return swift_getWitnessTable();
}

uint64_t sub_1834B60EC()
{
  return MEMORY[0x1E4FBB568];
}

uint64_t sub_1834B60F8()
{
  return sub_1834B6288();
}

unint64_t sub_1834B6110()
{
  unint64_t result = qword_1E8F62868;
  if (!qword_1E8F62868)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F62868);
  }
  return result;
}

uint64_t sub_1834B6164()
{
  return swift_getWitnessTable();
}

uint64_t sub_1834B6180()
{
  return swift_getWitnessTable();
}

uint64_t sub_1834B619C()
{
  return sub_1834B6288();
}

uint64_t sub_1834B61B4()
{
  return swift_getWitnessTable();
}

uint64_t sub_1834B6218(uint64_t a1)
{
  uint64_t result = swift_getWitnessTable();
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t sub_1834B6254()
{
  return swift_getWitnessTable();
}

uint64_t sub_1834B6270()
{
  return sub_1834B6288();
}

uint64_t sub_1834B6288()
{
  return swift_getWitnessTable();
}

uint64_t sub_1834B62D4()
{
  return swift_getWitnessTable();
}

uint64_t sub_1834B6338()
{
  return swift_getWitnessTable();
}

uint64_t dispatch thunk of Connectable.nw.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

unint64_t initializeBufferWithCopyOfBuffer for UnexpectedEndpointType(unint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(*(void *)(type metadata accessor for NWEndpoint() - 8) + 80);
  if ((v4 & 0x20000) != 0)
  {
    uint64_t v9 = *(void *)a2;
    *(void *)a1 = *(void *)a2;
    a1 = v9 + ((v4 + 16) & ~(unint64_t)v4);
    swift_retain();
  }
  else
  {
    switch(swift_getEnumCaseMultiPayload())
    {
      case 1u:
        uint64_t v12 = *(void *)(a2 + 8);
        *(void *)a1 = *(void *)a2;
        *(void *)(a1 + 8) = v12;
        uint64_t v13 = *(void *)(a2 + 24);
        *(void *)(a1 + 16) = *(void *)(a2 + 16);
        *(void *)(a1 + 24) = v13;
        uint64_t v14 = *(void *)(a2 + 40);
        *(void *)(a1 + 32) = *(void *)(a2 + 32);
        *(void *)(a1 + 40) = v14;
        uint64_t v15 = *(void *)(a2 + 48);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        if (v15 != 1) {
          swift_unknownObjectRetain();
        }
        *(void *)(a1 + 48) = v15;
        break;
      case 2u:
        uint64_t v10 = *(void *)(a2 + 8);
        *(void *)a1 = *(void *)a2;
        *(void *)(a1 + 8) = v10;
        swift_bridgeObjectRetain();
        break;
      case 3u:
        uint64_t v11 = sub_183D4447C();
        (*(void (**)(unint64_t, uint64_t, uint64_t))(*(void *)(v11 - 8) + 16))(a1, a2, v11);
        break;
      case 4u:
        *(void *)a1 = *(void *)a2;
        swift_unknownObjectRetain();
        break;
      default:
        uint64_t v5 = *(void *)a2;
        uint64_t v6 = *(void *)(a2 + 8);
        uint64_t v7 = *(void *)(a2 + 16);
        char v8 = *(unsigned char *)(a2 + 24);
        sub_18315E9E4(*(void *)a2, v6, v7, v8);
        *(void *)a1 = v5;
        *(void *)(a1 + 8) = v6;
        *(void *)(a1 + 16) = v7;
        *(unsigned char *)(a1 + 24) = v8;
        *(_WORD *)(a1 + 26) = *(_WORD *)(a2 + 26);
        break;
    }
    swift_storeEnumTagMultiPayload();
  }
  return a1;
}

void destroy for UnexpectedEndpointType(uint64_t a1)
{
  type metadata accessor for NWEndpoint();
  switch(swift_getEnumCaseMultiPayload())
  {
    case 0u:
      uint64_t v2 = *(void *)a1;
      uint64_t v3 = *(void *)(a1 + 8);
      uint64_t v4 = *(void *)(a1 + 16);
      char v5 = *(unsigned char *)(a1 + 24);
      sub_18315E658(v2, v3, v4, v5);
      break;
    case 1u:
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      if (*(void *)(a1 + 48) != 1) {
        goto LABEL_13;
      }
      break;
    case 2u:
      swift_bridgeObjectRelease();
      break;
    case 3u:
      uint64_t v6 = sub_183D4447C();
      uint64_t v7 = *(void (**)(uint64_t, uint64_t))(*(void *)(v6 - 8) + 8);
      v7(a1, v6);
      break;
    case 4u:
LABEL_13:
      swift_unknownObjectRelease();
      break;
    default:
      return;
  }
}

uint64_t initializeWithCopy for UnexpectedEndpointType(uint64_t a1, uint64_t *a2)
{
  type metadata accessor for NWEndpoint();
  switch(swift_getEnumCaseMultiPayload())
  {
    case 1u:
      uint64_t v8 = a2[1];
      *(void *)a1 = *a2;
      *(void *)(a1 + 8) = v8;
      uint64_t v9 = a2[3];
      *(void *)(a1 + 16) = a2[2];
      *(void *)(a1 + 24) = v9;
      uint64_t v10 = a2[5];
      *(void *)(a1 + 32) = a2[4];
      *(void *)(a1 + 40) = v10;
      uint64_t v11 = a2[6];
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      if (v11 != 1) {
        swift_unknownObjectRetain();
      }
      *(void *)(a1 + 48) = v11;
      break;
    case 2u:
      uint64_t v12 = a2[1];
      *(void *)a1 = *a2;
      *(void *)(a1 + 8) = v12;
      swift_bridgeObjectRetain();
      break;
    case 3u:
      uint64_t v13 = sub_183D4447C();
      (*(void (**)(uint64_t, uint64_t *, uint64_t))(*(void *)(v13 - 8) + 16))(a1, a2, v13);
      break;
    case 4u:
      *(void *)a1 = *a2;
      swift_unknownObjectRetain();
      break;
    default:
      uint64_t v4 = *a2;
      uint64_t v5 = a2[1];
      uint64_t v6 = a2[2];
      char v7 = *((unsigned char *)a2 + 24);
      sub_18315E9E4(*a2, v5, v6, v7);
      *(void *)a1 = v4;
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = v6;
      *(unsigned char *)(a1 + 24) = v7;
      *(_WORD *)(a1 + 26) = *((_WORD *)a2 + 13);
      break;
  }
  swift_storeEnumTagMultiPayload();
  return a1;
}

uint64_t assignWithCopy for UnexpectedEndpointType(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    sub_18315E3FC(a1, (uint64_t (*)(void))type metadata accessor for NWEndpoint);
    type metadata accessor for NWEndpoint();
    switch(swift_getEnumCaseMultiPayload())
    {
      case 1u:
        *(void *)a1 = *a2;
        *(void *)(a1 + 8) = a2[1];
        *(void *)(a1 + 16) = a2[2];
        *(void *)(a1 + 24) = a2[3];
        *(void *)(a1 + 32) = a2[4];
        *(void *)(a1 + 40) = a2[5];
        uint64_t v9 = a2[6];
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        if (v9 != 1) {
          swift_unknownObjectRetain();
        }
        *(void *)(a1 + 48) = v9;
        break;
      case 2u:
        *(void *)a1 = *a2;
        *(void *)(a1 + 8) = a2[1];
        swift_bridgeObjectRetain();
        break;
      case 3u:
        uint64_t v8 = sub_183D4447C();
        (*(void (**)(uint64_t, uint64_t *, uint64_t))(*(void *)(v8 - 8) + 16))(a1, a2, v8);
        break;
      case 4u:
        *(void *)a1 = *a2;
        swift_unknownObjectRetain();
        break;
      default:
        uint64_t v4 = *a2;
        uint64_t v5 = a2[1];
        uint64_t v6 = a2[2];
        char v7 = *((unsigned char *)a2 + 24);
        sub_18315E9E4(*a2, v5, v6, v7);
        *(void *)a1 = v4;
        *(void *)(a1 + 8) = v5;
        *(void *)(a1 + 16) = v6;
        *(unsigned char *)(a1 + 24) = v7;
        *(_WORD *)(a1 + 26) = *((_WORD *)a2 + 13);
        break;
    }
    swift_storeEnumTagMultiPayload();
  }
  return a1;
}

void *initializeWithTake for UnexpectedEndpointType(void *a1, const void *a2)
{
  uint64_t v4 = type metadata accessor for NWEndpoint();
  if (swift_getEnumCaseMultiPayload() == 3)
  {
    uint64_t v5 = sub_183D4447C();
    (*(void (**)(void *, const void *, uint64_t))(*(void *)(v5 - 8) + 32))(a1, a2, v5);
    swift_storeEnumTagMultiPayload();
  }
  else
  {
    memcpy(a1, a2, *(void *)(*(void *)(v4 - 8) + 64));
  }
  return a1;
}

void *assignWithTake for UnexpectedEndpointType(void *a1, const void *a2)
{
  if (a1 != a2)
  {
    sub_18315E3FC((uint64_t)a1, (uint64_t (*)(void))type metadata accessor for NWEndpoint);
    uint64_t v4 = type metadata accessor for NWEndpoint();
    if (swift_getEnumCaseMultiPayload() == 3)
    {
      uint64_t v5 = sub_183D4447C();
      (*(void (**)(void *, const void *, uint64_t))(*(void *)(v5 - 8) + 32))(a1, a2, v5);
      swift_storeEnumTagMultiPayload();
    }
    else
    {
      memcpy(a1, a2, *(void *)(*(void *)(v4 - 8) + 64));
    }
  }
  return a1;
}

uint64_t getEnumTagSinglePayload for UnexpectedEndpointType(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4186578](a1, a2, a3, sub_1834B6C08);
}

uint64_t sub_1834B6C08(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = type metadata accessor for NWEndpoint();
  uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 48);

  return v5(a1, a2, v4);
}

uint64_t storeEnumTagSinglePayload for UnexpectedEndpointType(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F41867C0](a1, a2, a3, a4, sub_1834B6C88);
}

uint64_t sub_1834B6C88(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = type metadata accessor for NWEndpoint();
  uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 56);

  return v5(a1, a2, a2, v4);
}

uint64_t type metadata accessor for UnexpectedEndpointType()
{
  uint64_t result = qword_1E8F62870;
  if (!qword_1E8F62870) {
    return swift_getSingletonMetadata();
  }
  return result;
}

uint64_t sub_1834B6D44()
{
  uint64_t result = type metadata accessor for NWEndpoint();
  if (v1 <= 0x3F)
  {
    swift_initStructMetadata();
    return 0;
  }
  return result;
}

uint64_t dispatch thunk of BrowseDescriptorProvider.makeDescriptor()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 16))();
}

uint64_t dispatch thunk of BrowseDescriptorProvider.makeEndpoint(from:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 24))();
}

uint64_t dispatch thunk of BrowseResultProtocol.endpoints.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))();
}

uint64_t dispatch thunk of BrowseResultProtocol.changes.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

uint64_t dispatch thunk of BrowseParametersProvider.browseParameters.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t destroy for NWActorSystemInvocationEncoder()
{
  swift_bridgeObjectRelease();

  return swift_bridgeObjectRelease();
}

void *_s7Network30NWActorSystemInvocationEncoderVwCP_0(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  return a1;
}

void *assignWithCopy for NWActorSystemInvocationEncoder(void *a1, void *a2)
{
  *a1 = *a2;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  a1[1] = a2[1];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

__n128 __swift_memcpy16_8(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

_OWORD *assignWithTake for NWActorSystemInvocationEncoder(_OWORD *a1, _OWORD *a2)
{
  *a1 = *a2;
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t sub_1834B6F74()
{
  uint64_t result = swift_checkMetadataState();
  if (v1 <= 0x3F)
  {
    uint64_t v3 = *(void *)(result - 8) + 64;
    uint64_t v4 = v3;
    swift_getTupleTypeLayout2();
    uint64_t v5 = &v2;
    swift_initEnumMetadataMultiPayload();
    return 0;
  }
  return result;
}

void *sub_1834B7014(void *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v4 = a1;
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  unint64_t v7 = *(void *)(v6 + 64);
  int v8 = *(_DWORD *)(v6 + 80);
  uint64_t v9 = v8;
  unint64_t v10 = ~(unint64_t)v8;
  uint64_t v11 = v7 + v8;
  if (((v7 + v9) & ~v9) + v7 <= v7) {
    uint64_t v12 = *(void *)(v6 + 64);
  }
  else {
    uint64_t v12 = ((v7 + v8) & ~(unint64_t)v8) + v7;
  }
  int v13 = v8 & 0x100000;
  if (v9 > 7 || v13 != 0 || (unint64_t)(v12 + 1) > 0x18)
  {
    uint64_t v16 = *(void *)a2;
    *uint64_t v4 = *(void *)a2;
    uint64_t v4 = (void *)(v16 + ((v9 + 16) & v10));
    swift_retain();
  }
  else
  {
    unsigned int v17 = a2[v12];
    unsigned int v18 = v17 - 3;
    if (v17 >= 3)
    {
      if (v12 <= 3) {
        uint64_t v19 = v12;
      }
      else {
        uint64_t v19 = 4;
      }
      switch(v19)
      {
        case 1:
          int v20 = *a2;
          goto LABEL_22;
        case 2:
          int v20 = *(unsigned __int16 *)a2;
          goto LABEL_22;
        case 3:
          int v20 = *(unsigned __int16 *)a2 | (a2[2] << 16);
          goto LABEL_22;
        case 4:
          int v20 = *(_DWORD *)a2;
LABEL_22:
          int v21 = (v20 | (v18 << (8 * v12))) + 3;
          unsigned int v17 = v20 + 3;
          if (v12 < 4) {
            unsigned int v17 = v21;
          }
          break;
        default:
          break;
      }
    }
    if (v17 == 2)
    {
      uint64_t v22 = *(void (**)(void *, unsigned __int8 *, uint64_t))(v6 + 16);
      v22(a1, a2, v5);
      v22((void *)(((unint64_t)v4 + v11) & v10), (unsigned __int8 *)((unint64_t)&a2[v11] & v10), v5);
      *((unsigned char *)v4 + v12) = 2;
    }
    else if (v17 == 1)
    {
      (*(void (**)(void *, unsigned __int8 *, uint64_t))(v6 + 16))(a1, a2, v5);
      *((unsigned char *)v4 + v12) = 1;
    }
    else
    {
      (*(void (**)(void *, unsigned __int8 *, uint64_t))(v6 + 16))(a1, a2, v5);
      *((unsigned char *)v4 + v12) = 0;
    }
  }
  return v4;
}

uint64_t sub_1834B721C(unsigned __int8 *a1, uint64_t a2)
{
  char v2 = a1;
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = *(void *)(v3 - 8);
  unint64_t v5 = *(void *)(v4 + 64);
  uint64_t v6 = *(unsigned __int8 *)(v4 + 80);
  uint64_t v7 = v5 + v6;
  if (((v5 + v6) & ~v6) + v5 > v5) {
    v5 += (v5 + v6) & ~v6;
  }
  unsigned int v8 = a1[v5];
  unsigned int v9 = v8 - 3;
  if (v8 >= 3)
  {
    if (v5 <= 3) {
      uint64_t v10 = v5;
    }
    else {
      uint64_t v10 = 4;
    }
    switch(v10)
    {
      case 1:
        int v11 = *a1;
        goto LABEL_12;
      case 2:
        int v11 = *(unsigned __int16 *)a1;
        goto LABEL_12;
      case 3:
        int v11 = *(unsigned __int16 *)a1 | (a1[2] << 16);
        goto LABEL_12;
      case 4:
        int v11 = *(_DWORD *)a1;
LABEL_12:
        int v12 = (v11 | (v9 << (8 * v5))) + 3;
        unsigned int v8 = v11 + 3;
        if (v5 < 4) {
          unsigned int v8 = v12;
        }
        break;
      default:
        break;
    }
  }
  if (v8 == 2)
  {
    uint64_t v15 = ~v6;
    unsigned int v17 = *(void (**)(unsigned __int8 *, uint64_t))(v4 + 8);
    v17(a1, v3);
    a1 = (unsigned __int8 *)((unint64_t)&v2[v7] & v15);
    uint64_t v14 = v3;
    int v13 = (uint64_t (*)(unsigned __int8 *, uint64_t))v17;
  }
  else
  {
    int v13 = *(uint64_t (**)(unsigned __int8 *, uint64_t))(v4 + 8);
    uint64_t v14 = *(void *)(a2 + 16);
  }

  return v13(a1, v14);
}

uint64_t sub_1834B73A0(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  unint64_t v7 = *(void *)(v6 + 64);
  uint64_t v8 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v9 = v7 + v8;
  if (((v7 + v8) & ~v8) + v7 <= v7) {
    uint64_t v10 = *(void *)(v6 + 64);
  }
  else {
    uint64_t v10 = ((v7 + v8) & ~v8) + v7;
  }
  unsigned int v11 = a2[v10];
  unsigned int v12 = v11 - 3;
  if (v11 >= 3)
  {
    if (v10 <= 3) {
      uint64_t v13 = v10;
    }
    else {
      uint64_t v13 = 4;
    }
    switch(v13)
    {
      case 1:
        int v14 = *a2;
        goto LABEL_13;
      case 2:
        int v14 = *(unsigned __int16 *)a2;
        goto LABEL_13;
      case 3:
        int v14 = *(unsigned __int16 *)a2 | (a2[2] << 16);
        goto LABEL_13;
      case 4:
        int v14 = *(_DWORD *)a2;
LABEL_13:
        int v15 = (v14 | (v12 << (8 * v10))) + 3;
        unsigned int v11 = v14 + 3;
        if (v10 < 4) {
          unsigned int v11 = v15;
        }
        break;
      default:
        break;
    }
  }
  if (v11 == 2)
  {
    uint64_t v17 = ~v8;
    unsigned int v18 = *(void (**)(uint64_t, unsigned __int8 *, uint64_t))(v6 + 16);
    v18(a1, a2, v5);
    v18((v9 + a1) & v17, (unsigned __int8 *)((unint64_t)&a2[v9] & v17), v5);
    char v16 = 2;
  }
  else if (v11 == 1)
  {
    (*(void (**)(uint64_t, unsigned __int8 *, uint64_t))(v6 + 16))(a1, a2, v5);
    char v16 = 1;
  }
  else
  {
    (*(void (**)(uint64_t, unsigned __int8 *, uint64_t))(v6 + 16))(a1, a2, v5);
    char v16 = 0;
  }
  *(unsigned char *)(a1 + v10) = v16;
  return a1;
}

unsigned __int8 *sub_1834B756C(unsigned __int8 *a1, unsigned __int8 *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = *(void *)(a3 + 16);
    uint64_t v6 = *(void *)(v5 - 8);
    unint64_t v7 = *(void *)(v6 + 64);
    uint64_t v8 = *(unsigned __int8 *)(v6 + 80);
    uint64_t v9 = v7 + v8;
    if (((v7 + v8) & ~v8) + v7 <= v7) {
      uint64_t v10 = *(void *)(v6 + 64);
    }
    else {
      uint64_t v10 = ((v7 + v8) & ~v8) + v7;
    }
    unsigned int v11 = a1[v10];
    unsigned int v12 = v11 - 3;
    if (v11 >= 3)
    {
      if (v10 <= 3) {
        uint64_t v13 = v10;
      }
      else {
        uint64_t v13 = 4;
      }
      switch(v13)
      {
        case 1:
          int v14 = *a1;
          goto LABEL_14;
        case 2:
          int v14 = *(unsigned __int16 *)a1;
          goto LABEL_14;
        case 3:
          int v14 = *(unsigned __int16 *)a1 | (a1[2] << 16);
          goto LABEL_14;
        case 4:
          int v14 = *(_DWORD *)a1;
LABEL_14:
          int v15 = (v14 | (v12 << (8 * v10))) + 3;
          unsigned int v11 = v14 + 3;
          if (v10 < 4) {
            unsigned int v11 = v15;
          }
          break;
        default:
          break;
      }
    }
    uint64_t v16 = ~v8;
    if (v11 == 2)
    {
      uint64_t v17 = *(void (**)(unsigned __int8 *, uint64_t))(v6 + 8);
      v17(a1, v5);
      v17((unsigned __int8 *)((unint64_t)&a1[v9] & v16), v5);
    }
    else
    {
      (*(void (**)(unsigned __int8 *, uint64_t))(v6 + 8))(a1, v5);
    }
    unsigned int v18 = a2[v10];
    unsigned int v19 = v18 - 3;
    if (v18 >= 3)
    {
      if (v10 <= 3) {
        uint64_t v20 = v10;
      }
      else {
        uint64_t v20 = 4;
      }
      switch(v20)
      {
        case 1:
          int v21 = *a2;
          goto LABEL_28;
        case 2:
          int v21 = *(unsigned __int16 *)a2;
          goto LABEL_28;
        case 3:
          int v21 = *(unsigned __int16 *)a2 | (a2[2] << 16);
          goto LABEL_28;
        case 4:
          int v21 = *(_DWORD *)a2;
LABEL_28:
          int v22 = (v21 | (v19 << (8 * v10))) + 3;
          unsigned int v18 = v21 + 3;
          if (v10 < 4) {
            unsigned int v18 = v22;
          }
          break;
        default:
          break;
      }
    }
    if (v18 == 2)
    {
      char v24 = *(void (**)(unsigned __int8 *, unsigned __int8 *, uint64_t))(v6 + 16);
      v24(a1, a2, v5);
      v24((unsigned __int8 *)((unint64_t)&a1[v9] & v16), (unsigned __int8 *)((unint64_t)&a2[v9] & v16), v5);
      char v23 = 2;
    }
    else if (v18 == 1)
    {
      (*(void (**)(unsigned __int8 *, unsigned __int8 *, uint64_t))(v6 + 16))(a1, a2, v5);
      char v23 = 1;
    }
    else
    {
      (*(void (**)(unsigned __int8 *, unsigned __int8 *, uint64_t))(v6 + 16))(a1, a2, v5);
      char v23 = 0;
    }
    a1[v10] = v23;
  }
  return a1;
}

uint64_t sub_1834B7834(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  unint64_t v7 = *(void *)(v6 + 64);
  uint64_t v8 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v9 = v7 + v8;
  if (((v7 + v8) & ~v8) + v7 <= v7) {
    uint64_t v10 = *(void *)(v6 + 64);
  }
  else {
    uint64_t v10 = ((v7 + v8) & ~v8) + v7;
  }
  unsigned int v11 = a2[v10];
  unsigned int v12 = v11 - 3;
  if (v11 >= 3)
  {
    if (v10 <= 3) {
      uint64_t v13 = v10;
    }
    else {
      uint64_t v13 = 4;
    }
    switch(v13)
    {
      case 1:
        int v14 = *a2;
        goto LABEL_13;
      case 2:
        int v14 = *(unsigned __int16 *)a2;
        goto LABEL_13;
      case 3:
        int v14 = *(unsigned __int16 *)a2 | (a2[2] << 16);
        goto LABEL_13;
      case 4:
        int v14 = *(_DWORD *)a2;
LABEL_13:
        int v15 = (v14 | (v12 << (8 * v10))) + 3;
        unsigned int v11 = v14 + 3;
        if (v10 < 4) {
          unsigned int v11 = v15;
        }
        break;
      default:
        break;
    }
  }
  if (v11 == 2)
  {
    uint64_t v17 = ~v8;
    unsigned int v18 = *(void (**)(uint64_t, unsigned __int8 *, uint64_t))(v6 + 32);
    v18(a1, a2, v5);
    v18((v9 + a1) & v17, (unsigned __int8 *)((unint64_t)&a2[v9] & v17), v5);
    char v16 = 2;
  }
  else if (v11 == 1)
  {
    (*(void (**)(uint64_t, unsigned __int8 *, uint64_t))(v6 + 32))(a1, a2, v5);
    char v16 = 1;
  }
  else
  {
    (*(void (**)(uint64_t, unsigned __int8 *, uint64_t))(v6 + 32))(a1, a2, v5);
    char v16 = 0;
  }
  *(unsigned char *)(a1 + v10) = v16;
  return a1;
}

unsigned __int8 *sub_1834B7A00(unsigned __int8 *a1, unsigned __int8 *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = *(void *)(a3 + 16);
    uint64_t v6 = *(void *)(v5 - 8);
    unint64_t v7 = *(void *)(v6 + 64);
    uint64_t v8 = *(unsigned __int8 *)(v6 + 80);
    uint64_t v9 = v7 + v8;
    if (((v7 + v8) & ~v8) + v7 <= v7) {
      uint64_t v10 = *(void *)(v6 + 64);
    }
    else {
      uint64_t v10 = ((v7 + v8) & ~v8) + v7;
    }
    unsigned int v11 = a1[v10];
    unsigned int v12 = v11 - 3;
    if (v11 >= 3)
    {
      if (v10 <= 3) {
        uint64_t v13 = v10;
      }
      else {
        uint64_t v13 = 4;
      }
      switch(v13)
      {
        case 1:
          int v14 = *a1;
          goto LABEL_14;
        case 2:
          int v14 = *(unsigned __int16 *)a1;
          goto LABEL_14;
        case 3:
          int v14 = *(unsigned __int16 *)a1 | (a1[2] << 16);
          goto LABEL_14;
        case 4:
          int v14 = *(_DWORD *)a1;
LABEL_14:
          int v15 = (v14 | (v12 << (8 * v10))) + 3;
          unsigned int v11 = v14 + 3;
          if (v10 < 4) {
            unsigned int v11 = v15;
          }
          break;
        default:
          break;
      }
    }
    uint64_t v16 = ~v8;
    if (v11 == 2)
    {
      uint64_t v17 = *(void (**)(unsigned __int8 *, uint64_t))(v6 + 8);
      v17(a1, v5);
      v17((unsigned __int8 *)((unint64_t)&a1[v9] & v16), v5);
    }
    else
    {
      (*(void (**)(unsigned __int8 *, uint64_t))(v6 + 8))(a1, v5);
    }
    unsigned int v18 = a2[v10];
    unsigned int v19 = v18 - 3;
    if (v18 >= 3)
    {
      if (v10 <= 3) {
        uint64_t v20 = v10;
      }
      else {
        uint64_t v20 = 4;
      }
      switch(v20)
      {
        case 1:
          int v21 = *a2;
          goto LABEL_28;
        case 2:
          int v21 = *(unsigned __int16 *)a2;
          goto LABEL_28;
        case 3:
          int v21 = *(unsigned __int16 *)a2 | (a2[2] << 16);
          goto LABEL_28;
        case 4:
          int v21 = *(_DWORD *)a2;
LABEL_28:
          int v22 = (v21 | (v19 << (8 * v10))) + 3;
          unsigned int v18 = v21 + 3;
          if (v10 < 4) {
            unsigned int v18 = v22;
          }
          break;
        default:
          break;
      }
    }
    if (v18 == 2)
    {
      char v24 = *(void (**)(unsigned __int8 *, unsigned __int8 *, uint64_t))(v6 + 32);
      v24(a1, a2, v5);
      v24((unsigned __int8 *)((unint64_t)&a1[v9] & v16), (unsigned __int8 *)((unint64_t)&a2[v9] & v16), v5);
      char v23 = 2;
    }
    else if (v18 == 1)
    {
      (*(void (**)(unsigned __int8 *, unsigned __int8 *, uint64_t))(v6 + 32))(a1, a2, v5);
      char v23 = 1;
    }
    else
    {
      (*(void (**)(unsigned __int8 *, unsigned __int8 *, uint64_t))(v6 + 32))(a1, a2, v5);
      char v23 = 0;
    }
    a1[v10] = v23;
  }
  return a1;
}

uint64_t sub_1834B7CC8(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(*(void *)(a3 + 16) - 8);
  unint64_t v4 = *(void *)(v3 + 64);
  unint64_t v5 = ((v4 + *(unsigned __int8 *)(v3 + 80)) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80)) + v4;
  if (v5 <= v4) {
    unint64_t v5 = v4;
  }
  if (!a2) {
    return 0;
  }
  if (a2 < 0xFE) {
    goto LABEL_22;
  }
  unint64_t v6 = v5 + 1;
  char v7 = 8 * (v5 + 1);
  if ((v5 + 1) <= 3)
  {
    unsigned int v10 = ((a2 + ~(-1 << v7) - 253) >> v7) + 1;
    if (HIWORD(v10))
    {
      int v8 = *(_DWORD *)((char *)a1 + v6);
      if (!v8) {
        goto LABEL_22;
      }
      goto LABEL_14;
    }
    if (v10 > 0xFF)
    {
      int v8 = *(unsigned __int16 *)((char *)a1 + v6);
      if (!*(unsigned __int16 *)((char *)a1 + v6)) {
        goto LABEL_22;
      }
      goto LABEL_14;
    }
    if (v10 < 2)
    {
LABEL_22:
      unsigned int v12 = *((unsigned __int8 *)a1 + v5);
      if (v12 >= 3) {
        return (v12 ^ 0xFF) + 1;
      }
      else {
        return 0;
      }
    }
  }
  int v8 = *((unsigned __int8 *)a1 + v6);
  if (!*((unsigned char *)a1 + v6)) {
    goto LABEL_22;
  }
LABEL_14:
  int v11 = (v8 - 1) << v7;
  if (v6 > 3) {
    int v11 = 0;
  }
  if (v6)
  {
    if (v6 > 3) {
      LODWORD(v6) = 4;
    }
    switch((int)v6)
    {
      case 2:
        LODWORD(v6) = *a1;
        break;
      case 3:
        LODWORD(v6) = *a1 | (*((unsigned __int8 *)a1 + 2) << 16);
        break;
      case 4:
        LODWORD(v6) = *(_DWORD *)a1;
        break;
      default:
        LODWORD(v6) = *(unsigned __int8 *)a1;
        break;
    }
  }
  return (v6 | v11) + 254;
}

void sub_1834B7E34(char *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(*(void *)(a4 + 16) - 8);
  unint64_t v6 = *(void *)(v5 + 64);
  unint64_t v7 = ((v6 + *(unsigned __int8 *)(v5 + 80)) & ~(unint64_t)*(unsigned __int8 *)(v5 + 80)) + v6;
  if (v7 > v6) {
    unint64_t v6 = v7;
  }
  size_t v8 = v6 + 1;
  if (a3 < 0xFE)
  {
    int v9 = 0;
  }
  else if (v8 <= 3)
  {
    unsigned int v12 = ((a3 + ~(-1 << (8 * v8)) - 253) >> (8 * v8)) + 1;
    if (HIWORD(v12))
    {
      int v9 = 4;
    }
    else if (v12 >= 0x100)
    {
      int v9 = 2;
    }
    else
    {
      int v9 = v12 > 1;
    }
  }
  else
  {
    int v9 = 1;
  }
  if (a2 > 0xFD)
  {
    unsigned int v10 = a2 - 254;
    if (v8 < 4)
    {
      int v11 = (v10 >> (8 * v8)) + 1;
      if (v6 != -1)
      {
        int v13 = v10 & ~(-1 << (8 * v8));
        bzero(a1, v8);
        if (v8 == 3)
        {
          *(_WORD *)a1 = v13;
          a1[2] = BYTE2(v13);
        }
        else if (v8 == 2)
        {
          *(_WORD *)a1 = v13;
        }
        else
        {
          *a1 = v13;
        }
      }
    }
    else
    {
      bzero(a1, v6 + 1);
      *(_DWORD *)a1 = v10;
      int v11 = 1;
    }
    switch(v9)
    {
      case 1:
        a1[v8] = v11;
        break;
      case 2:
        *(_WORD *)&a1[v8] = v11;
        break;
      case 3:
LABEL_34:
        __break(1u);
        JUMPOUT(0x1834B8034);
      case 4:
        *(_DWORD *)&a1[v8] = v11;
        break;
      default:
        return;
    }
  }
  else
  {
    switch(v9)
    {
      case 1:
        a1[v8] = 0;
        if (!a2) {
          return;
        }
        goto LABEL_23;
      case 2:
        *(_WORD *)&a1[v8] = 0;
        goto LABEL_22;
      case 3:
        goto LABEL_34;
      case 4:
        *(_DWORD *)&a1[v8] = 0;
        if (!a2) {
          return;
        }
        goto LABEL_23;
      default:
LABEL_22:
        if (a2) {
LABEL_23:
        }
          a1[v6] = -(char)a2;
        break;
    }
  }
}

uint64_t sub_1834B805C(unsigned __int8 *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)(a2 + 16) - 8);
  unint64_t v3 = *(void *)(v2 + 64);
  unint64_t v4 = ((v3 + *(unsigned __int8 *)(v2 + 80)) & ~(unint64_t)*(unsigned __int8 *)(v2 + 80)) + v3;
  if (v4 <= v3) {
    unint64_t v4 = v3;
  }
  uint64_t v5 = a1[v4];
  int v6 = v5 - 3;
  if (v5 >= 3)
  {
    if (v4 <= 3) {
      uint64_t v7 = v4;
    }
    else {
      uint64_t v7 = 4;
    }
    switch(v7)
    {
      case 1:
        int v8 = *a1;
        goto LABEL_12;
      case 2:
        int v8 = *(unsigned __int16 *)a1;
        goto LABEL_12;
      case 3:
        int v8 = *(unsigned __int16 *)a1 | (a1[2] << 16);
        goto LABEL_12;
      case 4:
        int v8 = *(_DWORD *)a1;
LABEL_12:
        unsigned int v9 = (v8 | (v6 << (8 * v4))) + 3;
        LODWORD(v5) = v8 + 3;
        if (v4 >= 4) {
          uint64_t v5 = v5;
        }
        else {
          uint64_t v5 = v9;
        }
        break;
      default:
        return v5;
    }
  }
  return v5;
}

void sub_1834B814C(unsigned char *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8);
  size_t v5 = *(void *)(v4 + 64);
  size_t v6 = ((v5 + *(unsigned __int8 *)(v4 + 80)) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80)) + v5;
  if (a2 > 2)
  {
    if (v6 <= v5) {
      size_t v7 = v5;
    }
    else {
      size_t v7 = v6;
    }
    unsigned int v8 = a2 - 3;
    if (v7 < 4)
    {
      unsigned int v9 = v8 >> (8 * v7);
      int v10 = v8 & ~(-1 << (8 * v7));
      a1[v7] = v9 + 3;
      bzero(a1, v7);
      if (v7 == 3)
      {
        *(_WORD *)a1 = v10;
        a1[2] = BYTE2(v10);
      }
      else if (v7 == 2)
      {
        *(_WORD *)a1 = v10;
      }
      else
      {
        *a1 = v10;
      }
    }
    else
    {
      a1[v7] = 3;
      bzero(a1, v7);
      *(_DWORD *)a1 = v8;
    }
  }
  else
  {
    if (v6 > v5) {
      size_t v5 = v6;
    }
    a1[v5] = a2;
  }
}

void *sub_1834B8264(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t destroy for NWBrowser.Descriptor.Options()
{
  return swift_bridgeObjectRelease();
}

void *sub_1834B829C(void *a1, void *a2)
{
  *a1 = *a2;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  a1[1] = a2[1];
  return a1;
}

void *sub_1834B82EC(void *a1, void *a2)
{
  *a1 = *a2;
  swift_bridgeObjectRelease();
  a1[1] = a2[1];
  return a1;
}

uint64_t getEnumTagSinglePayload for NWTXTRecord(uint64_t *a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *((unsigned char *)a1 + 16)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for NWTXTRecord(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)uint64_t result = a2 ^ 0x80000000;
    *(void *)(result + 8) = 0;
    if (a3 < 0) {
      *(unsigned char *)(result + 16) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)uint64_t result = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 16) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

uint64_t type metadata accessor for BrowseResult.Iterator()
{
  return __swift_instantiateGenericMetadata();
}

uint64_t sub_1834B83CC()
{
  uint64_t result = swift_checkMetadataState();
  if (v1 <= 0x3F)
  {
    uint64_t result = swift_initClassMetadata2();
    if (!result) {
      return 0;
    }
  }
  return result;
}

uint64_t type metadata accessor for Browser1()
{
  return __swift_instantiateGenericMetadata();
}

uint64_t method lookup function for Browser1(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F4186708](a1, a2, &nominal type descriptor for Browser1);
}

uint64_t dispatch thunk of Browser1.__allocating_init(provider:using:)()
{
  return (*(uint64_t (**)(void))(v0 + 112))();
}

uint64_t dispatch thunk of Browser1.__allocating_init(for:using:)()
{
  return (*(uint64_t (**)(void))(v0 + 120))();
}

uint64_t dispatch thunk of Browser1.__allocating_init<>(for:using:)()
{
  return (*(uint64_t (**)(void))(v0 + 128))();
}

ValueMetadata *type metadata accessor for BrowseDescriptorFactories()
{
  return &type metadata for BrowseDescriptorFactories;
}

uint64_t sub_1834B84E8(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else if ((v4 & 0x8000000000000000) == 0)
  {
    unint64_t v5 = a4 + 48 * a1 + 32;
    unint64_t v6 = a3 + 48 * v4;
    if (v5 >= v6 || v5 + 48 * v4 <= a3)
    {
      __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F62B28);
      swift_arrayInitWithCopy();
      return v6;
    }
  }
  uint64_t result = sub_183D4571C();
  __break(1u);
  return result;
}

uint64_t sub_1834B85F8(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else if ((v4 & 0x8000000000000000) == 0)
  {
    unint64_t v5 = a4 + 16 * a1 + 32;
    unint64_t v6 = a3 + 16 * v4;
    if (v5 >= v6 || v5 + 16 * v4 <= a3)
    {
      swift_arrayInitWithCopy();
      return v6;
    }
  }
  uint64_t result = sub_183D4571C();
  __break(1u);
  return result;
}

uint64_t sub_1834B86EC(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else if ((v4 & 0x8000000000000000) == 0)
  {
    unint64_t v5 = a4 + 40 * a1 + 32;
    unint64_t v6 = a3 + 40 * v4;
    if (v5 >= v6 || v5 + 40 * v4 <= a3)
    {
      __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F63EE0);
      swift_arrayInitWithCopy();
      return v6;
    }
  }
  uint64_t result = sub_183D4571C();
  __break(1u);
  return result;
}

uint64_t sub_1834B87FC(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else if ((v4 & 0x8000000000000000) == 0)
  {
    unint64_t v5 = a4 + 32 * a1 + 32;
    unint64_t v6 = a3 + 32 * v4;
    if (v5 >= v6 || v5 + 32 * v4 <= a3)
    {
      swift_arrayInitWithCopy();
      return v6;
    }
  }
  uint64_t result = sub_183D4571C();
  __break(1u);
  return result;
}

char *sub_1834B88F0(uint64_t a1, uint64_t a2, char *__dst, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else if ((v4 & 0x8000000000000000) == 0)
  {
    unint64_t v5 = (char *)(a4 + 8 * a1 + 32);
    size_t v6 = 8 * v4;
    size_t v7 = &__dst[v6];
    if (v5 >= &__dst[v6] || &v5[v6] <= __dst)
    {
      memcpy(__dst, v5, v6);
      return v7;
    }
  }
  uint64_t result = (char *)sub_183D4571C();
  __break(1u);
  return result;
}

uint64_t sub_1834B89DC(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else if ((v4 & 0x8000000000000000) == 0)
  {
    unint64_t v5 = a4 + 56 * a1 + 32;
    unint64_t v6 = a3 + 56 * v4;
    if (v5 >= v6 || v5 + 56 * v4 <= a3)
    {
      swift_arrayInitWithCopy();
      return v6;
    }
  }
  uint64_t result = sub_183D4571C();
  __break(1u);
  return result;
}

uint64_t sub_1834B8AD4(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else if ((v4 & 0x8000000000000000) == 0)
  {
    unint64_t v5 = a4 + 16 * a1 + 32;
    unint64_t v6 = a3 + 16 * v4;
    if (v5 >= v6 || v5 + 16 * v4 <= a3)
    {
      __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F62A88);
      swift_arrayInitWithCopy();
      return v6;
    }
  }
  uint64_t result = sub_183D4571C();
  __break(1u);
  return result;
}

uint64_t sub_1834B8BE0(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else if ((v4 & 0x8000000000000000) == 0)
  {
    unint64_t v5 = a4 + 24 * a1 + 32;
    unint64_t v6 = a3 + 24 * v4;
    if (v5 >= v6 || v5 + 24 * v4 <= a3)
    {
      swift_arrayInitWithCopy();
      return v6;
    }
  }
  uint64_t result = sub_183D4571C();
  __break(1u);
  return result;
}

uint64_t sub_1834B8CD8(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else if ((v4 & 0x8000000000000000) == 0)
  {
    unint64_t v5 = a4 + 104 * a1 + 32;
    unint64_t v6 = a3 + 104 * v4;
    if (v5 >= v6 || v5 + 104 * v4 <= a3)
    {
      swift_arrayInitWithCopy();
      return v6;
    }
  }
  uint64_t result = sub_183D4571C();
  __break(1u);
  return result;
}

char *sub_1834B8DCC(uint64_t a1, uint64_t a2, char *__dst, uint64_t a4)
{
  size_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else if ((v4 & 0x8000000000000000) == 0)
  {
    unint64_t v5 = (char *)(a4 + a1 + 32);
    unint64_t v6 = &__dst[v4];
    if (v5 >= &__dst[v4] || &v5[v4] <= __dst)
    {
      memcpy(__dst, v5, v4);
      return v6;
    }
  }
  uint64_t result = (char *)sub_183D4571C();
  __break(1u);
  return result;
}

uint64_t sub_1834B8EB4(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v5 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else if ((v5 & 0x8000000000000000) == 0)
  {
    unint64_t v6 = a4 + 32 * a1 + 32;
    unint64_t v7 = a3 + 32 * v5;
    if (v6 >= v7 || v6 + 32 * v5 <= a3)
    {
      __swift_instantiateConcreteTypeFromMangledName(a5);
      swift_arrayInitWithCopy();
      return v7;
    }
  }
  uint64_t result = sub_183D4571C();
  __break(1u);
  return result;
}

uint64_t sub_1834B8FBC(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v5 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else if ((v5 & 0x8000000000000000) == 0)
  {
    uint64_t v9 = *(void *)(__swift_instantiateConcreteTypeFromMangledName(a5) - 8);
    uint64_t v10 = a4 + ((*(unsigned __int8 *)(v9 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v9 + 80));
    uint64_t v11 = *(void *)(v9 + 72);
    unint64_t v12 = v10 + v11 * a1;
    unint64_t v13 = a3 + v11 * v5;
    if (v12 >= v13 || v12 + v11 * v5 <= a3)
    {
      swift_arrayInitWithCopy();
      return v13;
    }
  }
  uint64_t result = sub_183D4571C();
  __break(1u);
  return result;
}

uint64_t *__swift_allocate_boxed_opaque_existential_0(uint64_t *a1)
{
  unint64_t v1 = a1;
  if ((*(unsigned char *)(*(void *)(a1[3] - 8) + 82) & 2) != 0)
  {
    *a1 = swift_allocBox();
    return (uint64_t *)v2;
  }
  return v1;
}

uint64_t sub_1834B9178()
{
  swift_release();

  return swift_deallocObject();
}

void sub_1834B91B0(uint64_t a1)
{
  sub_1834B08D0(a1, *(void *)(v1 + 32));
}

uint64_t sub_1834B91BC()
{
  swift_getAssociatedTypeWitness();
  type metadata accessor for BrowseResult();
  __swift_instantiateConcreteTypeFromMangledNameAbstract(&qword_1E8F63CE0);
  uint64_t v1 = sub_183D4511C();
  (*(void (**)(unint64_t, uint64_t))(*(void *)(v1 - 8) + 8))(v0+ ((*(unsigned __int8 *)(*(void *)(v1 - 8) + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(v1 - 8) + 80)), v1);

  return swift_deallocObject();
}

unsigned int *sub_1834B9294(unsigned int *a1)
{
  swift_getAssociatedTypeWitness();
  type metadata accessor for BrowseResult();
  __swift_instantiateConcreteTypeFromMangledNameAbstract(&qword_1E8F63CE0);
  sub_183D4511C();

  return sub_1834B094C(a1);
}

uint64_t sub_1834B936C()
{
  swift_getAssociatedTypeWitness();
  type metadata accessor for BrowseResult();
  __swift_instantiateConcreteTypeFromMangledNameAbstract(&qword_1E8F63CE0);
  uint64_t v1 = sub_183D4511C();
  uint64_t v2 = *(void *)(v1 - 8);
  unint64_t v3 = (*(unsigned __int8 *)(v2 + 80) + 40) & ~(unint64_t)*(unsigned __int8 *)(v2 + 80);
  swift_release();
  (*(void (**)(unint64_t, uint64_t))(v2 + 8))(v0 + v3, v1);

  return swift_deallocObject();
}

uint64_t sub_1834B948C(uint64_t a1, uint64_t a2)
{
  swift_getAssociatedTypeWitness();
  type metadata accessor for BrowseResult();
  __swift_instantiateConcreteTypeFromMangledNameAbstract(&qword_1E8F63CE0);
  uint64_t v5 = *(void *)(sub_183D4511C() - 8);
  unint64_t v6 = *(uint64_t **)(v2 + 32);
  uint64_t v7 = v2 + ((*(unsigned __int8 *)(v5 + 80) + 40) & ~(unint64_t)*(unsigned __int8 *)(v5 + 80));

  return sub_1834B0A4C(a1, a2, v6, v7);
}

unint64_t sub_1834B9584()
{
  unint64_t result = qword_1E8F63D40;
  if (!qword_1E8F63D40)
  {
    self;
    unint64_t result = swift_getObjCClassMetadata();
    atomic_store(result, (unint64_t *)&qword_1E8F63D40);
  }
  return result;
}

uint64_t sub_1834B95C4(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v5 = a3(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16))(a2, a1, v5);
  return a2;
}

uint64_t sub_1834B962C(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v5 = a3(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 32))(a2, a1, v5);
  return a2;
}

uint64_t TXTRecordDecoder.decode<A>(_:from:)(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2[1];
  swift_bridgeObjectRetain();
  swift_unknownObjectRetain();
  uint64_t v4 = MEMORY[0x1E4FBC860];
  unint64_t v5 = sub_183595EA8(MEMORY[0x1E4FBC860]);
  sub_1834B9770();
  uint64_t v7 = (void *)swift_allocObject();
  v7[2] = v2;
  v7[3] = v3;
  v7[4] = v4;
  v7[5] = v5;
  return sub_183D4517C();
}

unint64_t sub_1834B9770()
{
  unint64_t result = qword_1E8F62B40;
  if (!qword_1E8F62B40)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F62B40);
  }
  return result;
}

uint64_t sub_1834B97C4()
{
  swift_bridgeObjectRelease();
  swift_unknownObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();

  return swift_deallocObject();
}

void *initializeWithCopy for NotSupported(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  uint64_t v4 = a2[3];
  a1[2] = a2[2];
  a1[3] = v4;
  a1[4] = a2[4];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  return a1;
}

void *assignWithCopy for NotSupported(void *a1, void *a2)
{
  *a1 = *a2;
  a1[1] = a2[1];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  a1[2] = a2[2];
  a1[3] = a2[3];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  a1[4] = a2[4];
  return a1;
}

__n128 __swift_memcpy40_8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

void *assignWithTake for NotSupported(void *a1, void *a2)
{
  uint64_t v4 = a2[1];
  *a1 = *a2;
  a1[1] = v4;
  swift_bridgeObjectRelease();
  uint64_t v5 = a2[3];
  a1[2] = a2[2];
  a1[3] = v5;
  swift_bridgeObjectRelease();
  a1[4] = a2[4];
  return a1;
}

uint64_t getEnumTagSinglePayload for NotSupported(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *(unsigned char *)(a1 + 40)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 8);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for NotSupported(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_OWORD *)(result + 8) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 40) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 8) = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 40) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for NotSupported()
{
  return &type metadata for NotSupported;
}

ValueMetadata *type metadata accessor for MissingRequiredKey()
{
  return &type metadata for MissingRequiredKey;
}

uint64_t _s4NameVwxx()
{
  swift_bridgeObjectRelease();

  return swift_bridgeObjectRelease();
}

void *initializeWithCopy for InvalidValue(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  uint64_t v4 = a2[3];
  a1[2] = a2[2];
  a1[3] = v4;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  return a1;
}

void *assignWithCopy for InvalidValue(void *a1, void *a2)
{
  *a1 = *a2;
  a1[1] = a2[1];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  a1[2] = a2[2];
  a1[3] = a2[3];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

void *assignWithTake for InvalidValue(void *a1, void *a2)
{
  uint64_t v4 = a2[1];
  *a1 = *a2;
  a1[1] = v4;
  swift_bridgeObjectRelease();
  uint64_t v5 = a2[3];
  a1[2] = a2[2];
  a1[3] = v5;
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for InvalidValue(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *(unsigned char *)(a1 + 32)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 8);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for InvalidValue(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 16) = 0;
    *(void *)(result + 24) = 0;
    *(void *)__n128 result = a2 ^ 0x80000000;
    *(void *)(result + 8) = 0;
    if (a3 < 0) {
      *(unsigned char *)(result + 32) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 8) = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 32) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for InvalidValue()
{
  return &type metadata for InvalidValue;
}

void *initializeBufferWithCopyOfBuffer for FailedConvertion(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t destroy for FailedConvertion()
{
  return swift_bridgeObjectRelease();
}

void *assignWithCopy for NWTXTRecord.CaseInsensitiveString(void *a1, void *a2)
{
  *a1 = *a2;
  a1[1] = a2[1];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

void *assignWithTake for FailedConvertion(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for NWTXTRecord.CaseInsensitiveString(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *(unsigned char *)(a1 + 16)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 8);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for NWTXTRecord.CaseInsensitiveString(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)__n128 result = a2 ^ 0x80000000;
    *(void *)(result + 8) = 0;
    if (a3 < 0) {
      *(unsigned char *)(result + 16) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 8) = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 16) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for FailedConvertion()
{
  return &type metadata for FailedConvertion;
}

ValueMetadata *type metadata accessor for TXTRecordDecoder()
{
  return &type metadata for TXTRecordDecoder;
}

ValueMetadata *type metadata accessor for TXTRecordDecoder._Decoder()
{
  return &type metadata for TXTRecordDecoder._Decoder;
}

uint64_t sub_1834B9D40()
{
  return sub_183D4580C();
}

uint64_t sub_1834B9E00()
{
  swift_bridgeObjectRetain();
  swift_unknownObjectRetain();
  uint64_t v0 = sub_183D45C2C();
  uint64_t v2 = NWTXTRecord.subscript.getter(v0, v1);
  uint64_t v4 = v3;
  swift_unknownObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  if (!v4)
  {
    uint64_t v2 = sub_183D45C2C();
    uint64_t v6 = v5;
    sub_1834BD13C();
    swift_allocError();
    uint64_t *v7 = v2;
    v7[1] = v6;
    swift_willThrow();
  }
  return v2;
}

uint64_t sub_1834B9EF8@<X0>(uint64_t a1@<X0>, void (*a2)(uint64_t)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v23 = a5;
  uint64_t v24 = a3;
  char v27 = a2;
  uint64_t v9 = sub_183D4536C();
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1F4188790](v9);
  unint64_t v12 = (char *)&v21 - v11;
  long long v13 = v5[1];
  long long v25 = *v5;
  long long v26 = v13;
  uint64_t result = sub_1834B9E00();
  if (!v6)
  {
    uint64_t v21 = a1;
    uint64_t v22 = v10;
    uint64_t v15 = v23;
    v27(result);
    swift_bridgeObjectRelease();
    uint64_t v16 = *(void *)(a4 - 8);
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v16 + 48))(v12, 1, a4) == 1)
    {
      (*(void (**)(char *, uint64_t))(v22 + 8))(v12, v9);
      uint64_t v17 = sub_183D45C2C();
      uint64_t v19 = v18;
      sub_1834BD0E8();
      swift_allocError();
      *uint64_t v20 = v17;
      v20[1] = v19;
      return swift_willThrow();
    }
    else
    {
      return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v16 + 32))(v15, v12, a4);
    }
  }
  return result;
}

BOOL sub_1834BA0E8()
{
  swift_bridgeObjectRetain();
  swift_unknownObjectRetain();
  uint64_t v0 = sub_183D45C2C();
  NWTXTRecord.subscript.getter(v0, v1);
  uint64_t v3 = v2;
  swift_unknownObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  if (v3) {
    swift_bridgeObjectRelease();
  }
  return v3 != 0;
}

BOOL sub_1834BA188()
{
  swift_bridgeObjectRetain();
  swift_unknownObjectRetain();
  uint64_t v0 = sub_183D45C2C();
  NWTXTRecord.subscript.getter(v0, v1);
  uint64_t v3 = v2;
  swift_unknownObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  if (v3) {
    swift_bridgeObjectRelease();
  }
  return v3 == 0;
}

uint64_t sub_1834BA230()
{
  uint64_t v1 = sub_1834B9E00();
  if (!v0)
  {
    uint64_t v4 = v1;
    uint64_t v5 = v2;
    uint64_t v6 = sub_183D44B8C();
    BOOL v8 = v6 == 1702195828 && v7 == 0xE400000000000000;
    if (v8
      || (uint64_t v9 = v6, v10 = v7, (sub_183D4592C() & 1) != 0)
      || v9 == 7562617 && v10 == 0xE300000000000000
      || (sub_183D4592C() & 1) != 0
      || v9 == 49 && v10 == 0xE100000000000000
      || (sub_183D4592C() & 1) != 0)
    {
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      char v3 = 1;
    }
    else
    {
      if (v9 == 0x65736C6166 && v10 == 0xE500000000000000
        || (sub_183D4592C() & 1) != 0
        || v9 == 28526 && v10 == 0xE200000000000000
        || (sub_183D4592C() & 1) != 0
        || v9 == 48 && v10 == 0xE100000000000000)
      {
        swift_bridgeObjectRelease();
      }
      else
      {
        char v12 = sub_183D4592C();
        swift_bridgeObjectRelease();
        if ((v12 & 1) == 0)
        {
          uint64_t v13 = sub_183D45C2C();
          uint64_t v15 = v14;
          sub_1834BD27C();
          swift_allocError();
          *uint64_t v16 = v13;
          v16[1] = v15;
          v16[2] = v4;
          v16[3] = v5;
          swift_willThrow();
          return v3 & 1;
        }
      }
      swift_bridgeObjectRelease();
      char v3 = 0;
    }
  }
  return v3 & 1;
}

uint64_t sub_1834BA4B0()
{
  return sub_1834B9E00();
}

double sub_1834BA4E4(uint64_t a1)
{
  sub_1834B9EF8(a1, (void (*)(uint64_t))sub_1834BA54C, 0, MEMORY[0x1E4FBB3D0], (uint64_t)&v3);
  if (!v1) {
    return v3;
  }
  return result;
}

uint64_t sub_1834BA54C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if ((a2 & 0x1000000000000000) != 0 || !(a2 & 0x2000000000000000 | a1 & 0x1000000000000000))
  {
    swift_bridgeObjectRetain();
    sub_183D4544C();
    uint64_t result = swift_bridgeObjectRelease();
    char v8 = v12;
  }
  else
  {
    MEMORY[0x1F4188790](a1);
    if ((a2 & 0x2000000000000000) != 0)
    {
      switch((char)a1)
      {
        case 0:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 32:
          swift_bridgeObjectRetain();
          goto LABEL_9;
        default:
          swift_bridgeObjectRetain();
          uint64_t v10 = (unsigned char *)_swift_stdlib_strtod_clocale();
          if (v10) {
            char v8 = *v10 == 0;
          }
          else {
LABEL_9:
          }
            char v8 = 0;
          uint64_t result = swift_bridgeObjectRelease();
          break;
      }
    }
    else
    {
      if ((a1 & 0x1000000000000000) != 0)
      {
        uint64_t v6 = (a2 & 0xFFFFFFFFFFFFFFFLL) + 32;
        uint64_t v7 = a1 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        uint64_t v6 = sub_183D4557C();
        uint64_t v7 = v11;
      }
      swift_bridgeObjectRetain();
      char v8 = sub_183594320(v6, v7, (void (*)(uint64_t *__return_ptr))sub_1834BD2D8);
      uint64_t result = swift_bridgeObjectRelease();
    }
  }
  *(void *)a3 = 0;
  *(unsigned char *)(a3 + 8) = (v8 & 1) == 0;
  return result;
}

float sub_1834BA7BC(uint64_t a1)
{
  sub_1834B9EF8(a1, (void (*)(uint64_t))sub_1834BA824, 0, MEMORY[0x1E4FBB470], (uint64_t)&v3);
  if (!v1) {
    return v3;
  }
  return result;
}

uint64_t sub_1834BA824@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if ((a2 & 0x1000000000000000) != 0 || !(a2 & 0x2000000000000000 | a1 & 0x1000000000000000))
  {
    swift_bridgeObjectRetain();
    sub_183D4544C();
    uint64_t result = swift_bridgeObjectRelease();
    char v8 = v12;
  }
  else
  {
    MEMORY[0x1F4188790](a1);
    if ((a2 & 0x2000000000000000) != 0)
    {
      switch((char)a1)
      {
        case 0:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 32:
          swift_bridgeObjectRetain();
          goto LABEL_9;
        default:
          swift_bridgeObjectRetain();
          uint64_t v10 = (unsigned char *)_swift_stdlib_strtof_clocale();
          if (v10) {
            char v8 = *v10 == 0;
          }
          else {
LABEL_9:
          }
            char v8 = 0;
          uint64_t result = swift_bridgeObjectRelease();
          break;
      }
    }
    else
    {
      if ((a1 & 0x1000000000000000) != 0)
      {
        uint64_t v6 = (a2 & 0xFFFFFFFFFFFFFFFLL) + 32;
        uint64_t v7 = a1 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        uint64_t v6 = sub_183D4557C();
        uint64_t v7 = v11;
      }
      swift_bridgeObjectRetain();
      char v8 = sub_183594320(v6, v7, (void (*)(uint64_t *__return_ptr))sub_1834BD1BC);
      uint64_t result = swift_bridgeObjectRelease();
    }
  }
  *(_DWORD *)a3 = 0;
  *(unsigned char *)(a3 + 4) = (v8 & 1) == 0;
  return result;
}

uint64_t sub_1834BAA94@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return sub_1834BB368(a1, a2, (uint64_t (*)(uint64_t, unint64_t, uint64_t))sub_18352D978, (uint64_t (*)(uint64_t))sub_18352D8B8, a3);
}

unint64_t sub_1834BAAC0@<X0>(unint64_t result@<X0>, unint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t v5 = HIBYTE(a2) & 0xF;
  uint64_t v6 = result & 0xFFFFFFFFFFFFLL;
  if ((a2 & 0x2000000000000000) != 0) {
    uint64_t v7 = v5;
  }
  else {
    uint64_t v7 = result & 0xFFFFFFFFFFFFLL;
  }
  if (!v7)
  {
    LOBYTE(v5) = 1;
LABEL_44:
    *a3 = v7;
    a3[1] = v5;
    return result;
  }
  uint64_t v8 = result;
  if ((a2 & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRetain();
    unsigned int v10 = sub_18352DA0C(v8, a2, 10);
    uint64_t result = swift_bridgeObjectRelease();
    LODWORD(v5) = (v10 >> 8) & 1;
    goto LABEL_41;
  }
  if ((a2 & 0x2000000000000000) == 0)
  {
    if ((result & 0x1000000000000000) != 0) {
      uint64_t v9 = (unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else {
      uint64_t v9 = (unsigned __int8 *)sub_183D4557C();
    }
    uint64_t result = (unint64_t)sub_18352D8D0(v9, v6, 10);
    LOBYTE(v10) = result;
    LODWORD(v5) = (result >> 8) & 1;
    goto LABEL_41;
  }
  v23[0] = result;
  v23[1] = a2 & 0xFFFFFFFFFFFFFFLL;
  if (result == 43)
  {
    if (v5)
    {
      if (v5 != 1)
      {
        unsigned int v10 = (result >> 8) - 48;
        if ((BYTE1(result) - 48) > 9u) {
          goto LABEL_38;
        }
        if (v5 != 2)
        {
          if ((BYTE2(result) - 48) > 9u) {
            goto LABEL_38;
          }
          unsigned int v10 = (result >> 16) - 48 + 10 * v10;
          uint64_t v15 = v5 - 3;
          if (v5 != 3)
          {
            uint64_t v16 = (unsigned __int8 *)v23 + 3;
            while (1)
            {
              unsigned int v17 = *v16 - 48;
              if (v17 > 9) {
                goto LABEL_38;
              }
              int v18 = (char)(10 * v10);
              if (v18 != 10 * (char)v10) {
                goto LABEL_38;
              }
              unsigned int v10 = v18 + (char)v17;
              if ((char)(v18 + v17) != v10) {
                goto LABEL_38;
              }
              LODWORD(v5) = 0;
              ++v16;
              if (!--v15) {
                goto LABEL_41;
              }
            }
          }
        }
        goto LABEL_40;
      }
      goto LABEL_56;
    }
  }
  else
  {
    if (result != 45)
    {
      if (!v5) {
        goto LABEL_38;
      }
      unsigned int v10 = result - 48;
      if ((result - 48) > 9u) {
        goto LABEL_38;
      }
      if (v5 != 1)
      {
        if ((BYTE1(result) - 48) > 9u) {
          goto LABEL_38;
        }
        unsigned int v10 = (result >> 8) - 48 + 10 * v10;
        uint64_t v19 = v5 - 2;
        if (v5 != 2)
        {
          uint64_t v20 = (unsigned __int8 *)v23 + 2;
          while (1)
          {
            unsigned int v21 = *v20 - 48;
            if (v21 > 9) {
              goto LABEL_38;
            }
            int v22 = (char)(10 * v10);
            if (v22 != 10 * (char)v10) {
              goto LABEL_38;
            }
            unsigned int v10 = v22 + (char)v21;
            if ((char)(v22 + v21) != v10) {
              goto LABEL_38;
            }
            LODWORD(v5) = 0;
            ++v20;
            if (!--v19) {
              goto LABEL_41;
            }
          }
        }
      }
      goto LABEL_40;
    }
    if (v5)
    {
      if (v5 != 1)
      {
        if ((BYTE1(result) - 48) > 9u) {
          goto LABEL_38;
        }
        unsigned int v10 = 48 - (result >> 8);
        if (v5 != 2)
        {
          if ((BYTE2(result) - 48) <= 9u)
          {
            unsigned int v10 = 10 * v10 - ((result >> 16) - 48);
            uint64_t v11 = v5 - 3;
            if (v5 != 3)
            {
              char v12 = (unsigned __int8 *)v23 + 3;
              while (1)
              {
                unsigned int v13 = *v12 - 48;
                if (v13 > 9) {
                  goto LABEL_38;
                }
                int v14 = (char)(10 * v10);
                if (v14 != 10 * (char)v10) {
                  goto LABEL_38;
                }
                unsigned int v10 = v14 - (char)v13;
                if ((char)(v14 - v13) != v10) {
                  goto LABEL_38;
                }
                LODWORD(v5) = 0;
                ++v12;
                if (!--v11) {
                  goto LABEL_41;
                }
              }
            }
            goto LABEL_40;
          }
LABEL_38:
          LOBYTE(v10) = 0;
          LODWORD(v5) = 1;
          goto LABEL_41;
        }
LABEL_40:
        LODWORD(v5) = 0;
        goto LABEL_41;
      }
LABEL_56:
      LOBYTE(v10) = 0;
LABEL_41:
      if (v5) {
        LOBYTE(v7) = 0;
      }
      else {
        LOBYTE(v7) = v10;
      }
      goto LABEL_44;
    }
    __break(1u);
  }
  __break(1u);
  return result;
}

uint64_t sub_1834BADAC@<X0>(uint64_t result@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = HIBYTE(a2) & 0xF;
  uint64_t v6 = result & 0xFFFFFFFFFFFFLL;
  if ((a2 & 0x2000000000000000) != 0) {
    uint64_t v7 = v5;
  }
  else {
    uint64_t v7 = result & 0xFFFFFFFFFFFFLL;
  }
  if (!v7)
  {
    LOBYTE(v5) = 1;
LABEL_37:
    *(_WORD *)a3 = v7;
    *(unsigned char *)(a3 + 2) = v5;
    return result;
  }
  uint64_t v8 = result;
  if ((a2 & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRetain();
    unsigned int v10 = sub_18352DA24(v8, a2, 10);
    uint64_t result = swift_bridgeObjectRelease();
    LODWORD(v5) = HIWORD(v10) & 1;
    goto LABEL_34;
  }
  if ((a2 & 0x2000000000000000) == 0)
  {
    if ((result & 0x1000000000000000) != 0) {
      uint64_t v9 = (unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else {
      uint64_t v9 = (unsigned __int8 *)sub_183D4557C();
    }
    uint64_t result = (uint64_t)sub_18352D8E8(v9, v6, 10);
    LOWORD(v10) = result;
    LODWORD(v5) = WORD1(result) & 1;
    goto LABEL_34;
  }
  v24[0] = result;
  v24[1] = a2 & 0xFFFFFFFFFFFFFFLL;
  if (result == 43)
  {
    if (!v5) {
      goto LABEL_59;
    }
    if (v5 == 1)
    {
LABEL_57:
      LOWORD(v10) = 0;
LABEL_34:
      if (v5) {
        LOWORD(v7) = 0;
      }
      else {
        LOWORD(v7) = v10;
      }
      goto LABEL_37;
    }
    unsigned int v10 = (BYTE1(result) - 48);
    if (v10 <= 9)
    {
      if (v5 == 2) {
        goto LABEL_33;
      }
      if ((BYTE2(result) - 48) <= 9u)
      {
        LOWORD(v10) = 10 * v10 + (BYTE2(result) - 48);
        uint64_t v12 = v5 - 3;
        if (v5 != 3)
        {
          unsigned int v13 = (unsigned __int8 *)v24 + 3;
          while (1)
          {
            unsigned int v14 = *v13 - 48;
            if (v14 > 9) {
              goto LABEL_31;
            }
            int v15 = (__int16)(10 * v10);
            if (v15 != 10 * (__int16)v10) {
              goto LABEL_31;
            }
            unsigned int v10 = v15 + v14;
            if ((__int16)(v15 + v14) != v10) {
              goto LABEL_31;
            }
            LODWORD(v5) = 0;
            ++v13;
            if (!--v12) {
              goto LABEL_34;
            }
          }
        }
        goto LABEL_33;
      }
    }
LABEL_31:
    LOWORD(v10) = 0;
    LODWORD(v5) = 1;
    goto LABEL_34;
  }
  if (result != 45)
  {
    if (!v5) {
      goto LABEL_31;
    }
    unsigned int v10 = (result - 48);
    if (v10 > 9) {
      goto LABEL_31;
    }
    if (v5 == 1)
    {
LABEL_33:
      LODWORD(v5) = 0;
      goto LABEL_34;
    }
    if ((BYTE1(result) - 48) <= 9u)
    {
      LOWORD(v10) = 10 * v10 + (BYTE1(result) - 48);
      uint64_t v16 = v5 - 2;
      if (v5 != 2)
      {
        unsigned int v17 = (unsigned __int8 *)v24 + 2;
        while (1)
        {
          unsigned int v18 = *v17 - 48;
          if (v18 > 9) {
            goto LABEL_31;
          }
          int v19 = (__int16)(10 * v10);
          if (v19 != 10 * (__int16)v10) {
            goto LABEL_31;
          }
          unsigned int v10 = v19 + v18;
          if ((__int16)(v19 + v18) != v10) {
            goto LABEL_31;
          }
          LODWORD(v5) = 0;
          ++v17;
          if (!--v16) {
            goto LABEL_34;
          }
        }
      }
      goto LABEL_33;
    }
    goto LABEL_31;
  }
  if (v5)
  {
    if (v5 != 1)
    {
      unsigned int v11 = (BYTE1(result) - 48);
      if (v11 > 9) {
        goto LABEL_31;
      }
      if (v5 == 2)
      {
        LODWORD(v5) = 0;
        unsigned int v10 = -v11;
        goto LABEL_34;
      }
      if ((BYTE2(result) - 48) > 9u) {
        goto LABEL_31;
      }
      LOWORD(v10) = -10 * v11 - (BYTE2(result) - 48);
      uint64_t v20 = v5 - 3;
      if (v5 != 3)
      {
        unsigned int v21 = (unsigned __int8 *)v24 + 3;
        while (1)
        {
          unsigned int v22 = *v21 - 48;
          if (v22 > 9) {
            goto LABEL_31;
          }
          int v23 = (__int16)(10 * v10);
          if (v23 != 10 * (__int16)v10) {
            goto LABEL_31;
          }
          unsigned int v10 = v23 - v22;
          if ((__int16)(v23 - v22) != v10) {
            goto LABEL_31;
          }
          LODWORD(v5) = 0;
          ++v21;
          if (!--v20) {
            goto LABEL_34;
          }
        }
      }
      goto LABEL_33;
    }
    goto LABEL_57;
  }
  __break(1u);
LABEL_59:
  __break(1u);
  return result;
}

uint64_t sub_1834BB0A0@<X0>(uint64_t result@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = HIBYTE(a2) & 0xF;
  uint64_t v6 = result & 0xFFFFFFFFFFFFLL;
  if ((a2 & 0x2000000000000000) != 0) {
    uint64_t v7 = v5;
  }
  else {
    uint64_t v7 = result & 0xFFFFFFFFFFFFLL;
  }
  if (!v7)
  {
    LOBYTE(v5) = 1;
LABEL_38:
    *(_DWORD *)a3 = v7;
    *(unsigned char *)(a3 + 4) = v5;
    return result;
  }
  uint64_t v8 = result;
  if ((a2 & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRetain();
    unint64_t v23 = sub_18352DA3C(v8, a2, 10);
    swift_bridgeObjectRelease();
    uint64_t v5 = HIDWORD(v23) & 1;
    uint64_t result = v23;
LABEL_35:
    if (v5) {
      LODWORD(v7) = 0;
    }
    else {
      LODWORD(v7) = result;
    }
    goto LABEL_38;
  }
  if ((a2 & 0x2000000000000000) == 0)
  {
    if ((result & 0x1000000000000000) != 0) {
      uint64_t v9 = (unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else {
      uint64_t v9 = (unsigned __int8 *)sub_183D4557C();
    }
    uint64_t result = (uint64_t)sub_18352D900(v9, v6, 10);
    char v25 = BYTE4(result) & 1;
    LOBYTE(v5) = BYTE4(result) & 1;
    goto LABEL_34;
  }
  v24[0] = result;
  v24[1] = a2 & 0xFFFFFFFFFFFFFFLL;
  if (result == 43)
  {
    if (v5)
    {
      if (v5 != 1)
      {
        uint64_t result = (BYTE1(result) - 48);
        if (result <= 9)
        {
          if (v5 == 2) {
            goto LABEL_33;
          }
          if ((BYTE2(v8) - 48) <= 9u)
          {
            uint64_t result = 10 * result + (BYTE2(v8) - 48);
            uint64_t v11 = v5 - 3;
            if (v5 != 3)
            {
              uint64_t v12 = (unsigned __int8 *)v24 + 3;
              while (1)
              {
                unsigned int v13 = *v12 - 48;
                if (v13 > 9) {
                  goto LABEL_31;
                }
                uint64_t v14 = 10 * (int)result;
                if (v14 != (int)v14) {
                  goto LABEL_31;
                }
                uint64_t result = v14 + v13;
                if (__OFADD__(v14, v13)) {
                  goto LABEL_31;
                }
                LOBYTE(v5) = 0;
                ++v12;
                if (!--v11) {
                  goto LABEL_34;
                }
              }
            }
            goto LABEL_33;
          }
        }
        goto LABEL_31;
      }
      goto LABEL_58;
    }
  }
  else
  {
    if (result != 45)
    {
      if (v5)
      {
        uint64_t result = (result - 48);
        if (result <= 9)
        {
          if (v5 == 1) {
            goto LABEL_33;
          }
          if ((BYTE1(v8) - 48) <= 9u)
          {
            uint64_t result = 10 * result + (BYTE1(v8) - 48);
            uint64_t v15 = v5 - 2;
            if (v5 != 2)
            {
              uint64_t v16 = (unsigned __int8 *)v24 + 2;
              while (1)
              {
                unsigned int v17 = *v16 - 48;
                if (v17 > 9) {
                  goto LABEL_31;
                }
                uint64_t v18 = 10 * (int)result;
                if (v18 != (int)v18) {
                  goto LABEL_31;
                }
                uint64_t result = v18 + v17;
                if (__OFADD__(v18, v17)) {
                  goto LABEL_31;
                }
                LOBYTE(v5) = 0;
                ++v16;
                if (!--v15) {
                  goto LABEL_34;
                }
              }
            }
            goto LABEL_33;
          }
        }
      }
LABEL_31:
      uint64_t result = 0;
      LOBYTE(v5) = 1;
      goto LABEL_34;
    }
    if (v5)
    {
      if (v5 != 1)
      {
        unsigned int v10 = (BYTE1(result) - 48);
        if (v10 <= 9)
        {
          if (v5 == 2)
          {
            LOBYTE(v5) = 0;
            uint64_t result = -v10;
LABEL_34:
            LODWORD(v5) = v5 & 1;
            goto LABEL_35;
          }
          if ((BYTE2(result) - 48) <= 9u)
          {
            uint64_t result = -10 * v10 - (BYTE2(result) - 48);
            uint64_t v19 = v5 - 3;
            if (v5 != 3)
            {
              uint64_t v20 = (unsigned __int8 *)v24 + 3;
              while (1)
              {
                unsigned int v21 = *v20 - 48;
                if (v21 > 9) {
                  goto LABEL_31;
                }
                uint64_t v22 = 10 * (int)result;
                if (v22 != (int)v22) {
                  goto LABEL_31;
                }
                uint64_t result = v22 - v21;
                if (__OFSUB__(v22, v21)) {
                  goto LABEL_31;
                }
                LOBYTE(v5) = 0;
                ++v20;
                if (!--v19) {
                  goto LABEL_34;
                }
              }
            }
LABEL_33:
            LOBYTE(v5) = 0;
            goto LABEL_34;
          }
        }
        goto LABEL_31;
      }
LABEL_58:
      uint64_t result = 0;
      goto LABEL_34;
    }
    __break(1u);
  }
  __break(1u);
  return result;
}

uint64_t sub_1834BB368@<X0>(uint64_t result@<X0>, unint64_t a2@<X1>, uint64_t (*a3)(uint64_t, unint64_t, uint64_t)@<X2>, uint64_t (*a4)(uint64_t)@<X3>, uint64_t a5@<X8>)
{
  uint64_t v7 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000) != 0) {
    uint64_t v8 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v8 = result & 0xFFFFFFFFFFFFLL;
  }
  if (!v8)
  {
    char v24 = 1;
LABEL_47:
    *(void *)a5 = v8;
    *(unsigned char *)(a5 + 8) = v24 & 1;
    return result;
  }
  uint64_t v9 = result;
  if ((a2 & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRetain();
    uint64_t v12 = a3(v9, a2, 10);
    char v14 = v29;
    uint64_t result = swift_bridgeObjectRelease();
LABEL_44:
    char v24 = v14 & 1;
    if (v14) {
      uint64_t v8 = 0;
    }
    else {
      uint64_t v8 = v12;
    }
    goto LABEL_47;
  }
  if ((a2 & 0x2000000000000000) == 0)
  {
    if ((result & 0x1000000000000000) != 0) {
      uint64_t v11 = (a2 & 0xFFFFFFFFFFFFFFFLL) + 32;
    }
    else {
      uint64_t v11 = sub_183D4557C();
    }
    uint64_t result = a4(v11);
    uint64_t v12 = result;
    char v14 = v13 & 1;
    goto LABEL_44;
  }
  v30[0] = result;
  v30[1] = a2 & 0xFFFFFFFFFFFFFFLL;
  if (result == 43)
  {
    if (!v7) {
      goto LABEL_58;
    }
    if (v7 == 1 || (BYTE1(result) - 48) > 9u) {
      goto LABEL_31;
    }
    uint64_t v12 = (BYTE1(result) - 48);
    if (v7 != 2)
    {
      if ((BYTE2(result) - 48) > 9u) {
        goto LABEL_31;
      }
      uint64_t v12 = 10 * (BYTE1(result) - 48) + (BYTE2(result) - 48);
      uint64_t v15 = v7 - 3;
      if (v15)
      {
        uint64_t v16 = (unsigned __int8 *)v30 + 3;
        while (1)
        {
          unsigned int v17 = *v16 - 48;
          if (v17 > 9) {
            goto LABEL_31;
          }
          uint64_t v18 = 10 * v12;
          if ((unsigned __int128)(v12 * (__int128)10) >> 64 != (10 * v12) >> 63) {
            goto LABEL_31;
          }
          uint64_t v12 = v18 + v17;
          if (__OFADD__(v18, v17)) {
            goto LABEL_31;
          }
          char v14 = 0;
          ++v16;
          if (!--v15) {
            goto LABEL_44;
          }
        }
      }
    }
LABEL_43:
    char v14 = 0;
    goto LABEL_44;
  }
  if (result != 45)
  {
    if (!v7 || (result - 48) > 9u) {
      goto LABEL_31;
    }
    uint64_t v12 = (result - 48);
    if (v7 != 1)
    {
      if ((BYTE1(result) - 48) > 9u) {
        goto LABEL_31;
      }
      uint64_t v12 = 10 * (result - 48) + (BYTE1(result) - 48);
      uint64_t v19 = v7 - 2;
      if (v19)
      {
        uint64_t v20 = (unsigned __int8 *)v30 + 2;
        while (1)
        {
          unsigned int v21 = *v20 - 48;
          if (v21 > 9) {
            goto LABEL_31;
          }
          uint64_t v22 = 10 * v12;
          if ((unsigned __int128)(v12 * (__int128)10) >> 64 != (10 * v12) >> 63) {
            goto LABEL_31;
          }
          uint64_t v12 = v22 + v21;
          if (__OFADD__(v22, v21)) {
            goto LABEL_31;
          }
          char v14 = 0;
          ++v20;
          if (!--v19) {
            goto LABEL_44;
          }
        }
      }
    }
    goto LABEL_43;
  }
  if (v7)
  {
    if (v7 != 1 && (BYTE1(result) - 48) <= 9u)
    {
      if (v7 == 2)
      {
        char v14 = 0;
        uint64_t v12 = -(uint64_t)(BYTE1(result) - 48);
        goto LABEL_44;
      }
      if ((BYTE2(result) - 48) <= 9u)
      {
        uint64_t v12 = -10 * (BYTE1(result) - 48) - (BYTE2(result) - 48);
        uint64_t v23 = v7 - 3;
        if (!v23) {
          goto LABEL_43;
        }
        char v25 = (unsigned __int8 *)v30 + 3;
        while (1)
        {
          unsigned int v26 = *v25 - 48;
          if (v26 > 9) {
            break;
          }
          uint64_t v27 = 10 * v12;
          if ((unsigned __int128)(v12 * (__int128)10) >> 64 != (10 * v12) >> 63) {
            break;
          }
          uint64_t v12 = v27 - v26;
          if (__OFSUB__(v27, v26)) {
            break;
          }
          char v14 = 0;
          ++v25;
          if (!--v23) {
            goto LABEL_44;
          }
        }
      }
    }
LABEL_31:
    uint64_t v12 = 0;
    char v14 = 1;
    goto LABEL_44;
  }
  __break(1u);
LABEL_58:
  __break(1u);
  return result;
}

uint64_t sub_1834BB664@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return sub_1834BC0D4(a1, a2, (uint64_t (*)(uint64_t, unint64_t, uint64_t))sub_18352DB4C, (uint64_t (*)(uint64_t))sub_18352D918, a3);
}

uint64_t sub_1834BB690(uint64_t a1, uint64_t a2, void (*a3)(uint64_t), uint64_t a4)
{
  uint64_t result = sub_1834B9EF8(a1, a3, 0, a4, (uint64_t)&v6);
  if (!v4) {
    return v6;
  }
  return result;
}

unint64_t sub_1834BB6E4@<X0>(unint64_t result@<X0>, unint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t v5 = HIBYTE(a2) & 0xF;
  uint64_t v6 = result & 0xFFFFFFFFFFFFLL;
  if ((a2 & 0x2000000000000000) != 0) {
    uint64_t v7 = v5;
  }
  else {
    uint64_t v7 = result & 0xFFFFFFFFFFFFLL;
  }
  if (!v7)
  {
    LOBYTE(v5) = 1;
LABEL_39:
    *a3 = v7;
    a3[1] = v5;
    return result;
  }
  uint64_t v8 = result;
  if ((a2 & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRetain();
    unsigned int v10 = sub_18352DB64(v8, a2, 10);
    uint64_t result = swift_bridgeObjectRelease();
    LODWORD(v5) = (v10 >> 8) & 1;
    goto LABEL_36;
  }
  if ((a2 & 0x2000000000000000) == 0)
  {
    if ((result & 0x1000000000000000) != 0) {
      uint64_t v9 = (unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else {
      uint64_t v9 = (unsigned __int8 *)sub_183D4557C();
    }
    uint64_t result = (unint64_t)sub_18352D930(v9, v6, 10);
    LOBYTE(v10) = result;
    LODWORD(v5) = (result >> 8) & 1;
    goto LABEL_36;
  }
  v20[0] = result;
  v20[1] = a2 & 0xFFFFFFFFFFFFFFLL;
  if (result == 43)
  {
    if (!v5) {
      goto LABEL_63;
    }
    if (v5 == 1)
    {
LABEL_61:
      LOBYTE(v10) = 0;
LABEL_36:
      if (v5) {
        LOBYTE(v7) = 0;
      }
      else {
        LOBYTE(v7) = v10;
      }
      goto LABEL_39;
    }
    unsigned int v10 = (result >> 8) - 48;
    if ((BYTE1(result) - 48) > 9u) {
      goto LABEL_32;
    }
    if (v5 != 2)
    {
      if ((BYTE2(result) - 48) > 9u) {
        goto LABEL_32;
      }
      unsigned int v10 = (result >> 16) - 48 + 10 * v10;
      uint64_t v11 = v5 - 3;
      if (v5 != 3)
      {
        uint64_t v12 = (unsigned __int8 *)v20 + 3;
        while (1)
        {
          unsigned int v13 = *v12 - 48;
          if (v13 > 9) {
            goto LABEL_32;
          }
          if (((10 * v10) & 0xF00) != 0) {
            goto LABEL_32;
          }
          unsigned int v10 = (10 * v10) + v13;
          if ((v10 >> 8)) {
            goto LABEL_32;
          }
          LODWORD(v5) = 0;
          ++v12;
          if (!--v11) {
            goto LABEL_36;
          }
        }
      }
    }
LABEL_35:
    LODWORD(v5) = 0;
    goto LABEL_36;
  }
  if (result != 45)
  {
    if (!v5) {
      goto LABEL_32;
    }
    unsigned int v10 = result - 48;
    if ((result - 48) > 9u) {
      goto LABEL_32;
    }
    if (v5 != 1)
    {
      if ((BYTE1(result) - 48) > 9u) {
        goto LABEL_32;
      }
      unsigned int v10 = (result >> 8) - 48 + 10 * v10;
      uint64_t v14 = v5 - 2;
      if (v5 != 2)
      {
        uint64_t v15 = (unsigned __int8 *)v20 + 2;
        while (1)
        {
          unsigned int v16 = *v15 - 48;
          if (v16 > 9) {
            goto LABEL_32;
          }
          if (((10 * v10) & 0xF00) != 0) {
            goto LABEL_32;
          }
          unsigned int v10 = (10 * v10) + v16;
          if ((v10 >> 8)) {
            goto LABEL_32;
          }
          LODWORD(v5) = 0;
          ++v15;
          if (!--v14) {
            goto LABEL_36;
          }
        }
      }
    }
    goto LABEL_35;
  }
  if (v5)
  {
    if (v5 != 1)
    {
      if ((BYTE1(result) - 48) <= 9u)
      {
        LOBYTE(v10) = 0;
        if ((-(BYTE1(result) - 48) & 0xFFFFFF00) != 0)
        {
LABEL_33:
          LODWORD(v5) = 1;
          goto LABEL_36;
        }
        if (v5 == 2)
        {
          LODWORD(v5) = 0;
          LOBYTE(v10) = 48 - BYTE1(result);
          goto LABEL_36;
        }
        if ((BYTE2(result) - 48) <= 9u && ((10 * (48 - BYTE1(result))) & 0xF00) == 0)
        {
          unsigned int v10 = (10 * (48 - BYTE1(result))) - (BYTE2(result) - 48);
          if ((v10 & 0xFFFFFF00) == 0)
          {
            uint64_t v17 = v5 - 3;
            if (v5 != 3)
            {
              uint64_t v18 = (unsigned __int8 *)v20 + 3;
              while (1)
              {
                unsigned int v19 = *v18 - 48;
                if (v19 > 9) {
                  goto LABEL_32;
                }
                if (((10 * v10) & 0xF00) != 0) {
                  goto LABEL_32;
                }
                unsigned int v10 = (10 * v10) - v19;
                if ((v10 & 0xFFFFFF00) != 0) {
                  goto LABEL_32;
                }
                LODWORD(v5) = 0;
                ++v18;
                if (!--v17) {
                  goto LABEL_36;
                }
              }
            }
            goto LABEL_35;
          }
        }
      }
LABEL_32:
      LOBYTE(v10) = 0;
      goto LABEL_33;
    }
    goto LABEL_61;
  }
  __break(1u);
LABEL_63:
  __break(1u);
  return result;
}

uint64_t sub_1834BB9EC(uint64_t a1, uint64_t a2, void (*a3)(uint64_t), uint64_t a4)
{
  uint64_t result = sub_1834B9EF8(a1, a3, 0, a4, (uint64_t)&v6);
  if (!v4) {
    return v6;
  }
  return result;
}

uint64_t sub_1834BBA40@<X0>(uint64_t result@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = HIBYTE(a2) & 0xF;
  uint64_t v6 = result & 0xFFFFFFFFFFFFLL;
  if ((a2 & 0x2000000000000000) != 0) {
    uint64_t v7 = v5;
  }
  else {
    uint64_t v7 = result & 0xFFFFFFFFFFFFLL;
  }
  if (!v7)
  {
    LOBYTE(v5) = 1;
LABEL_39:
    *(_WORD *)a3 = v7;
    *(unsigned char *)(a3 + 2) = v5;
    return result;
  }
  uint64_t v8 = result;
  if ((a2 & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRetain();
    unsigned int v10 = sub_18352DC70(v8, a2, 10);
    uint64_t result = swift_bridgeObjectRelease();
    LODWORD(v5) = HIWORD(v10) & 1;
    goto LABEL_36;
  }
  if ((a2 & 0x2000000000000000) == 0)
  {
    if ((result & 0x1000000000000000) != 0) {
      uint64_t v9 = (unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else {
      uint64_t v9 = (unsigned __int8 *)sub_183D4557C();
    }
    uint64_t result = (uint64_t)sub_18352D948(v9, v6, 10);
    LOWORD(v10) = result;
    LODWORD(v5) = WORD1(result) & 1;
    goto LABEL_36;
  }
  v20[0] = result;
  v20[1] = a2 & 0xFFFFFFFFFFFFFFLL;
  if (result == 43)
  {
    if (!v5) {
      goto LABEL_63;
    }
    if (v5 == 1)
    {
LABEL_61:
      LOWORD(v10) = 0;
LABEL_36:
      if (v5) {
        LOWORD(v7) = 0;
      }
      else {
        LOWORD(v7) = v10;
      }
      goto LABEL_39;
    }
    unsigned int v10 = (BYTE1(result) - 48);
    if (v10 > 9) {
      goto LABEL_32;
    }
    if (v5 != 2)
    {
      if ((BYTE2(result) - 48) > 9u) {
        goto LABEL_32;
      }
      LOWORD(v10) = 10 * v10 + (BYTE2(result) - 48);
      uint64_t v11 = v5 - 3;
      if (v5 != 3)
      {
        uint64_t v12 = (unsigned __int8 *)v20 + 3;
        while (1)
        {
          unsigned int v13 = *v12 - 48;
          if (v13 > 9) {
            goto LABEL_32;
          }
          if (((10 * (unsigned __int16)v10) & 0xF0000) != 0) {
            goto LABEL_32;
          }
          unsigned int v10 = (unsigned __int16)(10 * v10) + v13;
          if ((v10 & 0x10000) != 0) {
            goto LABEL_32;
          }
          LODWORD(v5) = 0;
          ++v12;
          if (!--v11) {
            goto LABEL_36;
          }
        }
      }
    }
LABEL_35:
    LODWORD(v5) = 0;
    goto LABEL_36;
  }
  if (result != 45)
  {
    if (!v5) {
      goto LABEL_32;
    }
    unsigned int v10 = (result - 48);
    if (v10 > 9) {
      goto LABEL_32;
    }
    if (v5 != 1)
    {
      if ((BYTE1(result) - 48) > 9u) {
        goto LABEL_32;
      }
      LOWORD(v10) = 10 * v10 + (BYTE1(result) - 48);
      uint64_t v14 = v5 - 2;
      if (v5 != 2)
      {
        uint64_t v15 = (unsigned __int8 *)v20 + 2;
        while (1)
        {
          unsigned int v16 = *v15 - 48;
          if (v16 > 9) {
            goto LABEL_32;
          }
          if (((10 * (unsigned __int16)v10) & 0xF0000) != 0) {
            goto LABEL_32;
          }
          unsigned int v10 = (unsigned __int16)(10 * v10) + v16;
          if ((v10 & 0x10000) != 0) {
            goto LABEL_32;
          }
          LODWORD(v5) = 0;
          ++v15;
          if (!--v14) {
            goto LABEL_36;
          }
        }
      }
    }
    goto LABEL_35;
  }
  if (v5)
  {
    if (v5 != 1)
    {
      if ((BYTE1(result) - 48) <= 9u)
      {
        LOWORD(v10) = 0;
        if ((-(BYTE1(result) - 48) & 0xFFFF0000) != 0)
        {
LABEL_33:
          LODWORD(v5) = 1;
          goto LABEL_36;
        }
        if (v5 == 2)
        {
          LODWORD(v5) = 0;
          LOWORD(v10) = -(BYTE1(result) - 48);
          goto LABEL_36;
        }
        if ((BYTE2(result) - 48) <= 9u
          && ((10 * (unsigned __int16)-(BYTE1(result) - 48)) & 0xF0000) == 0)
        {
          unsigned int v10 = (unsigned __int16)(-10 * (BYTE1(result) - 48)) - (BYTE2(result) - 48);
          if ((v10 & 0xFFFF0000) == 0)
          {
            uint64_t v17 = v5 - 3;
            if (v5 != 3)
            {
              uint64_t v18 = (unsigned __int8 *)v20 + 3;
              while (1)
              {
                unsigned int v19 = *v18 - 48;
                if (v19 > 9) {
                  goto LABEL_32;
                }
                if (((10 * (unsigned __int16)v10) & 0xF0000) != 0) {
                  goto LABEL_32;
                }
                unsigned int v10 = (unsigned __int16)(10 * v10) - v19;
                if ((v10 & 0xFFFF0000) != 0) {
                  goto LABEL_32;
                }
                LODWORD(v5) = 0;
                ++v18;
                if (!--v17) {
                  goto LABEL_36;
                }
              }
            }
            goto LABEL_35;
          }
        }
      }
LABEL_32:
      LOWORD(v10) = 0;
      goto LABEL_33;
    }
    goto LABEL_61;
  }
  __break(1u);
LABEL_63:
  __break(1u);
  return result;
}

uint64_t sub_1834BBD50(uint64_t a1, uint64_t a2, void (*a3)(uint64_t), uint64_t a4)
{
  uint64_t result = sub_1834B9EF8(a1, a3, 0, a4, (uint64_t)&v6);
  if (!v4) {
    return v6;
  }
  return result;
}

uint64_t sub_1834BBDA4@<X0>(uint64_t result@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = HIBYTE(a2) & 0xF;
  uint64_t v6 = result & 0xFFFFFFFFFFFFLL;
  if ((a2 & 0x2000000000000000) != 0) {
    uint64_t v7 = v5;
  }
  else {
    uint64_t v7 = result & 0xFFFFFFFFFFFFLL;
  }
  if (!v7)
  {
    LOBYTE(v5) = 1;
LABEL_41:
    *(_DWORD *)a3 = v7;
    *(unsigned char *)(a3 + 4) = v5;
    return result;
  }
  uint64_t v8 = result;
  if ((a2 & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRetain();
    unint64_t v27 = sub_18352DD78(v8, a2, 10);
    swift_bridgeObjectRelease();
    uint64_t v5 = HIDWORD(v27) & 1;
    uint64_t result = v27;
LABEL_38:
    if (v5) {
      LODWORD(v7) = 0;
    }
    else {
      LODWORD(v7) = result;
    }
    goto LABEL_41;
  }
  if ((a2 & 0x2000000000000000) == 0)
  {
    if ((result & 0x1000000000000000) != 0) {
      uint64_t v9 = (unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else {
      uint64_t v9 = (unsigned __int8 *)sub_183D4557C();
    }
    uint64_t result = (uint64_t)sub_18352D960(v9, v6, 10);
    char v29 = BYTE4(result) & 1;
    LOBYTE(v5) = BYTE4(result) & 1;
    goto LABEL_37;
  }
  v28[0] = result;
  v28[1] = a2 & 0xFFFFFFFFFFFFFFLL;
  if (result == 43)
  {
    if (v5)
    {
      if (v5 != 1)
      {
        uint64_t result = (BYTE1(result) - 48);
        if (result <= 9)
        {
          if (v5 == 2) {
            goto LABEL_36;
          }
          if ((BYTE2(v8) - 48) <= 9u)
          {
            uint64_t result = 10 * result + (BYTE2(v8) - 48);
            uint64_t v13 = v5 - 3;
            if (v5 != 3)
            {
              uint64_t v14 = (unsigned __int8 *)v28 + 3;
              while (1)
              {
                unsigned int v15 = *v14 - 48;
                if (v15 > 9) {
                  goto LABEL_33;
                }
                uint64_t v16 = 10 * result;
                if ((v16 & 0xFFFFFFFF00000000) != 0) {
                  goto LABEL_33;
                }
                uint64_t result = v16 + v15;
                if (__CFADD__(v16, v15)) {
                  goto LABEL_33;
                }
                LOBYTE(v5) = 0;
                ++v14;
                if (!--v13) {
                  goto LABEL_37;
                }
              }
            }
            goto LABEL_36;
          }
        }
        goto LABEL_33;
      }
      goto LABEL_63;
    }
  }
  else
  {
    if (result != 45)
    {
      if (v5)
      {
        uint64_t result = (result - 48);
        if (result <= 9)
        {
          if (v5 == 1) {
            goto LABEL_36;
          }
          if ((BYTE1(v8) - 48) <= 9u)
          {
            uint64_t result = 10 * result + (BYTE1(v8) - 48);
            uint64_t v17 = v5 - 2;
            if (v5 != 2)
            {
              uint64_t v18 = (unsigned __int8 *)v28 + 2;
              while (1)
              {
                unsigned int v19 = *v18 - 48;
                if (v19 > 9) {
                  goto LABEL_33;
                }
                uint64_t v20 = 10 * result;
                if ((v20 & 0xFFFFFFFF00000000) != 0) {
                  goto LABEL_33;
                }
                uint64_t result = v20 + v19;
                if (__CFADD__(v20, v19)) {
                  goto LABEL_33;
                }
                LOBYTE(v5) = 0;
                ++v18;
                if (!--v17) {
                  goto LABEL_37;
                }
              }
            }
            goto LABEL_36;
          }
        }
      }
LABEL_33:
      uint64_t result = 0;
LABEL_34:
      LOBYTE(v5) = 1;
      goto LABEL_37;
    }
    if (v5)
    {
      if (v5 != 1)
      {
        unsigned __int8 v10 = BYTE1(result) - 48;
        if ((BYTE1(result) - 48) <= 9u)
        {
          uint64_t result = 0;
          BOOL v11 = v10 == 0;
          uint64_t v12 = -v10;
          if (!v11) {
            goto LABEL_34;
          }
          if (v5 == 2)
          {
            LOBYTE(v5) = 0;
            uint64_t result = v12;
LABEL_37:
            LODWORD(v5) = v5 & 1;
            goto LABEL_38;
          }
          unsigned __int8 v21 = BYTE2(v8) - 48;
          if ((BYTE2(v8) - 48) <= 9u)
          {
            uint64_t v22 = 10 * v12;
            if ((v22 & 0xFFFFFFFF00000000) == 0)
            {
              uint64_t result = v22 - v21;
              if (v22 >= v21)
              {
                uint64_t v23 = v5 - 3;
                if (v5 != 3)
                {
                  char v24 = (unsigned __int8 *)v28 + 3;
                  while (1)
                  {
                    unsigned int v25 = *v24 - 48;
                    if (v25 > 9) {
                      goto LABEL_33;
                    }
                    uint64_t v26 = 10 * result;
                    if ((v26 & 0xFFFFFFFF00000000) != 0) {
                      goto LABEL_33;
                    }
                    uint64_t result = v26 - v25;
                    if (v26 < v25) {
                      goto LABEL_33;
                    }
                    LOBYTE(v5) = 0;
                    ++v24;
                    if (!--v23) {
                      goto LABEL_37;
                    }
                  }
                }
LABEL_36:
                LOBYTE(v5) = 0;
                goto LABEL_37;
              }
            }
          }
        }
        goto LABEL_33;
      }
LABEL_63:
      uint64_t result = 0;
      goto LABEL_37;
    }
    __break(1u);
  }
  __break(1u);
  return result;
}

uint64_t sub_1834BC080(uint64_t a1, uint64_t a2, void (*a3)(uint64_t), uint64_t a4)
{
  uint64_t result = sub_1834B9EF8(a1, a3, 0, a4, (uint64_t)&v6);
  if (!v4) {
    return v6;
  }
  return result;
}

uint64_t sub_1834BC0D4@<X0>(uint64_t result@<X0>, unint64_t a2@<X1>, uint64_t (*a3)(uint64_t, unint64_t, uint64_t)@<X2>, uint64_t (*a4)(uint64_t)@<X3>, uint64_t a5@<X8>)
{
  uint64_t v7 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000) != 0) {
    uint64_t v8 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v8 = result & 0xFFFFFFFFFFFFLL;
  }
  if (!v8)
  {
    char v21 = 1;
LABEL_40:
    *(void *)a5 = v8;
    *(unsigned char *)(a5 + 8) = v21 & 1;
    return result;
  }
  uint64_t v9 = result;
  if ((a2 & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRetain();
    unint64_t v12 = a3(v9, a2, 10);
    char v14 = v31;
    uint64_t result = swift_bridgeObjectRelease();
LABEL_37:
    char v21 = v14 & 1;
    if (v14) {
      uint64_t v8 = 0;
    }
    else {
      uint64_t v8 = v12;
    }
    goto LABEL_40;
  }
  if ((a2 & 0x2000000000000000) == 0)
  {
    if ((result & 0x1000000000000000) != 0) {
      uint64_t v11 = (a2 & 0xFFFFFFFFFFFFFFFLL) + 32;
    }
    else {
      uint64_t v11 = sub_183D4557C();
    }
    uint64_t result = a4(v11);
    unint64_t v12 = result;
    char v14 = v13 & 1;
    goto LABEL_37;
  }
  v32[0] = result;
  v32[1] = a2 & 0xFFFFFFFFFFFFFFLL;
  if (result == 43)
  {
    if (!v7) {
      goto LABEL_64;
    }
    if (v7 == 1 || (BYTE1(result) - 48) > 9u) {
      goto LABEL_33;
    }
    unint64_t v12 = (BYTE1(result) - 48);
    if (v7 != 2)
    {
      if ((BYTE2(result) - 48) > 9u) {
        goto LABEL_33;
      }
      unint64_t v12 = 10 * (BYTE1(result) - 48) + (BYTE2(result) - 48);
      uint64_t v18 = v7 - 3;
      if (v18)
      {
        unsigned int v19 = (unsigned __int8 *)v32 + 3;
        while (1)
        {
          unsigned int v20 = *v19 - 48;
          if (v20 > 9) {
            goto LABEL_33;
          }
          if (!is_mul_ok(v12, 0xAuLL)) {
            goto LABEL_33;
          }
          BOOL v16 = __CFADD__(10 * v12, v20);
          unint64_t v12 = 10 * v12 + v20;
          if (v16) {
            goto LABEL_33;
          }
          char v14 = 0;
          ++v19;
          if (!--v18) {
            goto LABEL_37;
          }
        }
      }
    }
LABEL_36:
    char v14 = 0;
    goto LABEL_37;
  }
  if (result != 45)
  {
    if (!v7 || (result - 48) > 9u) {
      goto LABEL_33;
    }
    unint64_t v12 = (result - 48);
    if (v7 != 1)
    {
      if ((BYTE1(result) - 48) > 9u) {
        goto LABEL_33;
      }
      unint64_t v12 = 10 * (result - 48) + (BYTE1(result) - 48);
      uint64_t v22 = v7 - 2;
      if (v22)
      {
        uint64_t v23 = (unsigned __int8 *)v32 + 2;
        while (1)
        {
          unsigned int v24 = *v23 - 48;
          if (v24 > 9) {
            goto LABEL_33;
          }
          if (!is_mul_ok(v12, 0xAuLL)) {
            goto LABEL_33;
          }
          BOOL v16 = __CFADD__(10 * v12, v24);
          unint64_t v12 = 10 * v12 + v24;
          if (v16) {
            goto LABEL_33;
          }
          char v14 = 0;
          ++v23;
          if (!--v22) {
            goto LABEL_37;
          }
        }
      }
    }
    goto LABEL_36;
  }
  if (v7)
  {
    if (v7 != 1)
    {
      unsigned __int8 v15 = BYTE1(result) - 48;
      if ((BYTE1(result) - 48) <= 9u)
      {
        unint64_t v12 = 0;
        BOOL v16 = v15 == 0;
        unint64_t v17 = -(uint64_t)v15;
        if (!v16) {
          goto LABEL_34;
        }
        if (v7 == 2)
        {
          char v14 = 0;
          unint64_t v12 = v17;
          goto LABEL_37;
        }
        unsigned __int8 v25 = BYTE2(result) - 48;
        if ((BYTE2(result) - 48) <= 9u && is_mul_ok(v17, 0xAuLL))
        {
          unint64_t v26 = 10 * v17;
          unint64_t v12 = v26 - v25;
          if (v26 >= v25)
          {
            uint64_t v27 = v7 - 3;
            if (v27)
            {
              char v28 = (unsigned __int8 *)v32 + 3;
              while (1)
              {
                unsigned int v29 = *v28 - 48;
                if (v29 > 9) {
                  goto LABEL_33;
                }
                if (!is_mul_ok(v12, 0xAuLL)) {
                  goto LABEL_33;
                }
                BOOL v16 = 10 * v12 >= v29;
                unint64_t v12 = 10 * v12 - v29;
                if (!v16) {
                  goto LABEL_33;
                }
                char v14 = 0;
                ++v28;
                if (!--v27) {
                  goto LABEL_37;
                }
              }
            }
            goto LABEL_36;
          }
        }
      }
    }
LABEL_33:
    unint64_t v12 = 0;
LABEL_34:
    char v14 = 1;
    goto LABEL_37;
  }
  __break(1u);
LABEL_64:
  __break(1u);
  return result;
}

uint64_t sub_1834BC3EC()
{
  sub_1834BCE58();
  swift_allocError();
  *uint64_t v0 = 0xD000000000000011;
  v0[1] = 0x8000000183E23D30;
  v0[2] = 0xD00000000000005ELL;
  v0[3] = 0x8000000183E23C40;
  v0[4] = 165;
  return swift_willThrow();
}

uint64_t sub_1834BC470()
{
  sub_1834BCE58();
  swift_allocError();
  *uint64_t v0 = 0xD000000000000020;
  v0[1] = 0x8000000183E23D00;
  v0[2] = 0xD00000000000005ELL;
  v0[3] = 0x8000000183E23C40;
  v0[4] = 169;
  return swift_willThrow();
}

uint64_t sub_1834BC4F4()
{
  sub_1834BCE58();
  swift_allocError();
  *uint64_t v0 = 0xD00000000000001FLL;
  v0[1] = 0x8000000183E23CE0;
  v0[2] = 0xD00000000000005ELL;
  v0[3] = 0x8000000183E23C40;
  v0[4] = 173;
  return swift_willThrow();
}

uint64_t sub_1834BC578()
{
  sub_1834BCE58();
  swift_allocError();
  strcpy(v0, "superDecoder()");
  v0[15] = -18;
  *((void *)v0 + 2) = 0xD00000000000005ELL;
  *((void *)v0 + 3) = 0x8000000183E23C40;
  *((void *)v0 + 4) = 177;
  return swift_willThrow();
}

uint64_t sub_1834BC608()
{
  sub_1834BCE58();
  swift_allocError();
  *uint64_t v0 = 0xD000000000000015;
  v0[1] = 0x8000000183E23CC0;
  v0[2] = 0xD00000000000005ELL;
  v0[3] = 0x8000000183E23C40;
  v0[4] = 181;
  return swift_willThrow();
}

uint64_t _s7Network25NWApplicationServiceGroupC7membersSayAA10NWEndpointOGvg_0()
{
  return swift_bridgeObjectRetain();
}

uint64_t sub_1834BC694()
{
  return swift_bridgeObjectRetain();
}

BOOL sub_1834BC6A0()
{
  return sub_1834BA188();
}

uint64_t sub_1834BC6BC()
{
  return sub_1834BA230() & 1;
}

uint64_t sub_1834BC6D8()
{
  return sub_1834BA4B0();
}

double sub_1834BC6F0(uint64_t a1)
{
  return sub_1834BA4E4(a1);
}

float sub_1834BC708(uint64_t a1)
{
  return sub_1834BA7BC(a1);
}

uint64_t sub_1834BC720(uint64_t a1, uint64_t a2)
{
  return sub_1834BC080(a1, a2, (void (*)(uint64_t))sub_1834BAA94, MEMORY[0x1E4FBB550]);
}

uint64_t sub_1834BC754(uint64_t a1, uint64_t a2)
{
  return sub_1834BB690(a1, a2, (void (*)(uint64_t))sub_1834BAAC0, MEMORY[0x1E4FBC098]);
}

uint64_t sub_1834BC788(uint64_t a1, uint64_t a2)
{
  return sub_1834BB9EC(a1, a2, (void (*)(uint64_t))sub_1834BADAC, MEMORY[0x1E4FBC0F8]);
}

uint64_t sub_1834BC7BC(uint64_t a1, uint64_t a2)
{
  return sub_1834BBD50(a1, a2, (void (*)(uint64_t))sub_1834BB0A0, MEMORY[0x1E4FBC150]);
}

uint64_t sub_1834BC7F0(uint64_t a1, uint64_t a2)
{
  return sub_1834BC080(a1, a2, (void (*)(uint64_t))sub_1834BAA94, MEMORY[0x1E4FBC1C8]);
}

uint64_t sub_1834BC824()
{
  return sub_183D459EC();
}

uint64_t sub_1834BC83C(uint64_t a1, uint64_t a2)
{
  return sub_1834BC080(a1, a2, (void (*)(uint64_t))sub_1834BB664, MEMORY[0x1E4FBB808]);
}

uint64_t sub_1834BC870(uint64_t a1, uint64_t a2)
{
  return sub_1834BB690(a1, a2, (void (*)(uint64_t))sub_1834BB6E4, MEMORY[0x1E4FBC358]);
}

uint64_t sub_1834BC8A4(uint64_t a1, uint64_t a2)
{
  return sub_1834BB9EC(a1, a2, (void (*)(uint64_t))sub_1834BBA40, MEMORY[0x1E4FBC450]);
}

uint64_t sub_1834BC8D8(uint64_t a1, uint64_t a2)
{
  return sub_1834BBD50(a1, a2, (void (*)(uint64_t))sub_1834BBDA4, MEMORY[0x1E4FBC4C0]);
}

uint64_t sub_1834BC90C(uint64_t a1, uint64_t a2)
{
  return sub_1834BC080(a1, a2, (void (*)(uint64_t))sub_1834BB664, MEMORY[0x1E4FBC538]);
}

uint64_t sub_1834BC940()
{
  return sub_183D459FC();
}

uint64_t sub_1834BC958()
{
  return sub_1834BC3EC();
}

uint64_t sub_1834BC970()
{
  return sub_183D4597C();
}

uint64_t sub_1834BC988()
{
  return sub_183D4596C();
}

uint64_t sub_1834BC9A0()
{
  uint64_t result = sub_183D4598C();
  if (v0) {
    return v2;
  }
  return result;
}

uint64_t sub_1834BC9C4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1834BCBF0(a1, a2, a3, MEMORY[0x1E4FBBF60]);
}

uint64_t sub_1834BC9F0()
{
  uint64_t result = sub_183D4599C();
  if (v0) {
    return v2;
  }
  return result;
}

uint64_t sub_1834BCA14(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1834BCB38(a1, a2, a3, MEMORY[0x1E4FBBF78]);
}

uint64_t sub_1834BCA40(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1834BCB94(a1, a2, a3, MEMORY[0x1E4FBBF80]);
}

uint64_t sub_1834BCA6C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1834BCBF0(a1, a2, a3, MEMORY[0x1E4FBBF88]);
}

uint64_t sub_1834BCA98()
{
  uint64_t result = sub_183D459CC();
  if (v0) {
    return v2;
  }
  return result;
}

uint64_t sub_1834BCABC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1834BCC78(a1, a2, a3, MEMORY[0x1E4FBBFA0]);
}

uint64_t sub_1834BCAE8()
{
  uint64_t result = sub_183D459AC();
  if (v0) {
    return v2;
  }
  return result;
}

uint64_t sub_1834BCB0C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1834BCB38(a1, a2, a3, MEMORY[0x1E4FBBF98]);
}

uint64_t sub_1834BCB38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void))
{
  return a4() & 0x1FF;
}

uint64_t sub_1834BCB68(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1834BCB94(a1, a2, a3, MEMORY[0x1E4FBBFA8]);
}

uint64_t sub_1834BCB94(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void))
{
  return a4() & 0x1FFFF;
}

uint64_t sub_1834BCBC4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1834BCBF0(a1, a2, a3, MEMORY[0x1E4FBBFB0]);
}

uint64_t sub_1834BCBF0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void))
{
  unint64_t v4 = a4();
  return v4 | ((HIDWORD(v4) & 1) << 32);
}

uint64_t sub_1834BCC28()
{
  uint64_t result = sub_183D459DC();
  if (v0) {
    return v2;
  }
  return result;
}

uint64_t sub_1834BCC4C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1834BCC78(a1, a2, a3, MEMORY[0x1E4FBBFC0]);
}

uint64_t sub_1834BCC78(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void))
{
  uint64_t result = a4();
  if (v4) {
    return v6;
  }
  return result;
}

uint64_t sub_1834BCCA4()
{
  return sub_183D459BC();
}

uint64_t sub_1834BCCD0()
{
  return sub_1834BC470();
}

uint64_t sub_1834BCCE8()
{
  return sub_1834BC4F4();
}

uint64_t sub_1834BCD00()
{
  return sub_1834BC578();
}

uint64_t sub_1834BCD18()
{
  return sub_1834BC608();
}

uint64_t sub_1834BCD30()
{
  return sub_1834B9D40();
}

uint64_t sub_1834BCD48()
{
  sub_1834BCE58();
  swift_allocError();
  *uint64_t v0 = 0xD000000000000012;
  v0[1] = 0x8000000183E23CA0;
  v0[2] = 0xD00000000000005ELL;
  v0[3] = 0x8000000183E23C40;
  v0[4] = 58;
  return swift_willThrow();
}

uint64_t sub_1834BCDD0()
{
  sub_1834BCE58();
  swift_allocError();
  *uint64_t v0 = 0xD000000000000016;
  v0[1] = 0x8000000183E23C20;
  v0[2] = 0xD00000000000005ELL;
  v0[3] = 0x8000000183E23C40;
  v0[4] = 62;
  return swift_willThrow();
}

unint64_t sub_1834BCE58()
{
  unint64_t result = qword_1E8F62B48[0];
  if (!qword_1E8F62B48[0])
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, qword_1E8F62B48);
  }
  return result;
}

uint64_t type metadata accessor for TXTRecordDecoder._Decoder._Container()
{
  return __swift_instantiateGenericMetadata();
}

uint64_t sub_1834BCEC4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F41863F8](a1, a2, a3, 32);
}

uint64_t _s7Network16TXTRecordDecoderV8_DecoderVwxx_0()
{
  swift_bridgeObjectRelease();
  swift_unknownObjectRelease();
  swift_bridgeObjectRelease();

  return swift_bridgeObjectRelease();
}

void *_s7Network16TXTRecordDecoderV8_DecoderVwcp_0(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  uint64_t v4 = a2[3];
  a1[2] = a2[2];
  a1[3] = v4;
  swift_bridgeObjectRetain();
  swift_unknownObjectRetain();
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  return a1;
}

void *_s7Network16TXTRecordDecoderV8_DecoderVwca_0(void *a1, void *a2)
{
  *a1 = *a2;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  a1[1] = a2[1];
  swift_unknownObjectRetain();
  swift_unknownObjectRelease();
  a1[2] = a2[2];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  a1[3] = a2[3];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

_OWORD *_s7Network16TXTRecordDecoderV8_DecoderVwta_0(_OWORD *a1, _OWORD *a2)
{
  *a1 = *a2;
  swift_unknownObjectRelease();
  swift_bridgeObjectRelease();
  a1[1] = a2[1];
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t _s7Network16TXTRecordDecoderV8_DecoderVwet_0(uint64_t *a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *((unsigned char *)a1 + 32)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t sub_1834BD0A0(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 16) = 0;
    *(void *)(result + 24) = 0;
    *(void *)unint64_t result = a2 ^ 0x80000000;
    *(void *)(result + 8) = 0;
    if (a3 < 0) {
      *(unsigned char *)(result + 32) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)unint64_t result = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 32) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

uint64_t sub_1834BD0E0(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 24);
}

unint64_t sub_1834BD0E8()
{
  unint64_t result = qword_1E8F62BD0;
  if (!qword_1E8F62BD0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F62BD0);
  }
  return result;
}

unint64_t sub_1834BD13C()
{
  unint64_t result = qword_1E8F62BD8;
  if (!qword_1E8F62BD8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F62BD8);
  }
  return result;
}

unsigned char *sub_1834BD190@<X0>(unsigned char *a1@<X0>, BOOL *a2@<X8>)
{
  return sub_1834BD204(a1, MEMORY[0x1E4FBC880], a2);
}

void *sub_1834BD1BC@<X0>(unsigned char *a1@<X8>)
{
  return sub_1835947B8(*(void *(**)(uint64_t *__return_ptr))(v1 + 16), a1);
}

unsigned char *sub_1834BD1D8@<X0>(unsigned char *a1@<X0>, BOOL *a2@<X8>)
{
  return sub_1834BD204(a1, MEMORY[0x1E4FBC878], a2);
}

unsigned char *sub_1834BD204@<X0>(unsigned char *result@<X0>, uint64_t (*a2)(void)@<X1>, BOOL *a3@<X8>)
{
  unsigned int v4 = *result;
  BOOL v5 = v4 > 0x20;
  uint64_t v6 = (1 << v4) & 0x100003E01;
  BOOL v7 = v5 || v6 == 0;
  BOOL v8 = v7 && (result = (unsigned char *)a2()) != 0 && *result == 0;
  *a3 = v8;
  return result;
}

unint64_t sub_1834BD27C()
{
  unint64_t result = qword_1E8F62BE0;
  if (!qword_1E8F62BE0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F62BE0);
  }
  return result;
}

void *sub_1834BD2D8@<X0>(unsigned char *a1@<X8>)
{
  return sub_1834BD1BC(a1);
}

uint64_t sub_1834BD300()
{
  nw_protocol_definition_t v0 = nw_protocol_copy_tls_definition();
  type metadata accessor for NWProtocolDefinition();
  uint64_t v1 = (void *)swift_allocObject();
  v1[4] = v0;
  id v2 = objc_msgSend((id)swift_unknownObjectRetain(), sel_description);
  uint64_t v3 = sub_183D44AFC();
  uint64_t v5 = v4;

  uint64_t result = swift_unknownObjectRelease();
  v1[2] = v3;
  v1[3] = v5;
  qword_1E8F61D60 = (uint64_t)v1;
  return result;
}

uint64_t static NWProtocolTLS.definition.getter()
{
  if (qword_1E8F61D10 != -1) {
    swift_once();
  }

  return swift_retain();
}

sec_protocol_options_t sub_1834BD3F0()
{
  return nw_tls_copy_sec_protocol_options(*(nw_protocol_options_t *)(v0 + 16));
}

BOOL sub_1834BD3F8(NSObject *a1)
{
  uint64_t v1 = nw_protocol_options_copy_definition(a1);
  id v2 = nw_protocol_copy_tls_definition();
  BOOL is_equal = nw_protocol_definition_is_equal(v1, v2);
  swift_unknownObjectRelease();
  swift_unknownObjectRelease();
  return is_equal;
}

uint64_t NWProtocolTLS.Options.__allocating_init()()
{
  uint64_t v0 = swift_allocObject();
  *(void *)(v0 + 16) = nw_tls_create_options();
  return v0;
}

uint64_t NWProtocolTLS.Options.init()()
{
  *(void *)(v0 + 16) = nw_tls_create_options();
  return v0;
}

uint64_t sub_1834BD4AC(uint64_t a1)
{
  uint64_t result = swift_allocObject();
  *(void *)(result + 16) = a1;
  return result;
}

uint64_t NWProtocolTLS.Options.deinit()
{
  swift_unknownObjectRelease();
  return v0;
}

sec_protocol_metadata_t sub_1834BD504()
{
  return nw_tls_copy_sec_protocol_metadata(*(nw_protocol_metadata_t *)(v0 + 16));
}

BOOL sub_1834BD50C(NSObject *a1)
{
  return nw_protocol_metadata_is_tls(a1);
}

uint64_t NWProtocolTLS.deinit()
{
  return v0;
}

uint64_t NWProtocolTLS.__deallocating_deinit()
{
  return swift_deallocClassInstance();
}

uint64_t type metadata accessor for NWProtocolTLS()
{
  return self;
}

uint64_t type metadata accessor for NWProtocolTLS.Options()
{
  return self;
}

uint64_t method lookup function for NWProtocolTLS.Options(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F4186708](a1, a2, &nominal type descriptor for NWProtocolTLS.Options);
}

uint64_t dispatch thunk of NWProtocolTLS.Options.securityProtocolOptions.getter()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 104))();
}

uint64_t dispatch thunk of NWProtocolTLS.Options.__allocating_init()()
{
  return (*(uint64_t (**)(void))(v0 + 112))();
}

uint64_t type metadata accessor for NWProtocolTLS.Metadata()
{
  return self;
}

uint64_t method lookup function for NWProtocolTLS.Metadata(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F4186708](a1, a2, &nominal type descriptor for NWProtocolTLS.Metadata);
}

uint64_t dispatch thunk of NWProtocolTLS.Metadata.securityProtocolMetadata.getter()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 104))();
}

uint64_t NWActorSystemInvocationEncoder.recordGenericSubstitution<A>(_:)()
{
  uint64_t result = sub_183D4567C();
  if (v2)
  {
    uint64_t v3 = result;
    uint64_t v4 = v2;
    uint64_t v5 = *v0;
    uint64_t result = swift_isUniquelyReferenced_nonNull_native();
    if ((result & 1) == 0)
    {
      uint64_t result = (uint64_t)sub_1834B423C(0, v5[2] + 1, 1, v5);
      uint64_t v5 = (void *)result;
    }
    unint64_t v7 = v5[2];
    unint64_t v6 = v5[3];
    if (v7 >= v6 >> 1)
    {
      uint64_t result = (uint64_t)sub_1834B423C((void *)(v6 > 1), v7 + 1, 1, v5);
      uint64_t v5 = (void *)result;
    }
    v5[2] = v7 + 1;
    BOOL v8 = &v5[2 * v7];
    void v8[4] = v3;
    v8[5] = v4;
    *uint64_t v0 = v5;
  }
  return result;
}

uint64_t NWActorSystemInvocationEncoder.recordArgument<A>(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = swift_conformsToProtocol();
  uint64_t v5 = swift_conformsToProtocol();
  uint64_t v6 = *(void *)(a2 - 8);
  uint64_t v7 = MEMORY[0x1F4188790](v5);
  uint64_t v9 = (char *)&v18 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v7);
  uint64_t v11 = (char *)&v18 - v10;
  sub_183D4468C();
  sub_183D4467C();
  char v13 = (uint64_t *)(v2 + 8);
  unint64_t v12 = *(void **)(v2 + 8);
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  uint64_t *v13 = (uint64_t)v12;
  if ((isUniquelyReferenced_nonNull_native & 1) == 0)
  {
    unint64_t v12 = sub_1834B4360(0, v12[2] + 1, 1, v12);
    uint64_t *v13 = (uint64_t)v12;
  }
  unint64_t v16 = v12[2];
  unint64_t v15 = v12[3];
  if (v16 >= v15 >> 1) {
    uint64_t *v13 = (uint64_t)sub_1834B4360((void *)(v15 > 1), v16 + 1, 1, v12);
  }
  (*(void (**)(char *, char *, uint64_t))(v6 + 16))(v9, v11, a2);
  sub_1834BDD78(v16, (uint64_t)v9, v13, a2, v4, v5);
  return (*(uint64_t (**)(char *, uint64_t))(v6 + 8))(v11, a2);
}

uint64_t NWActorSystemInvocationEncoder.recordReturnType<A>(_:)()
{
  return swift_conformsToProtocol();
}

void *sub_1834BD91C(uint64_t a1, uint64_t a2, int a3)
{
  LODWORD(v36) = a3;
  uint64_t v7 = sub_183D456AC();
  uint64_t v8 = *(void *)(v7 - 8);
  MEMORY[0x1F4188790](v7);
  uint64_t v10 = (char *)&v31 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = type metadata accessor for NWFileSerializationContext(0);
  MEMORY[0x1F4188790](v11);
  char v13 = (char *)&v31 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v32 = *(void *)(v3 + 8);
  sub_1834BDE24(a1, (uint64_t)v13);
  sub_1834BDEC0(a2, (uint64_t)&v13[*(int *)(v11 + 20)], (uint64_t (*)(void))type metadata accessor for NWActorID);
  sub_183D442AC();
  swift_allocObject();
  uint64_t v14 = sub_183D4429C();
  if (qword_1E8F621B8 != -1) {
    swift_once();
  }
  uint64_t v15 = __swift_project_value_buffer(v7, (uint64_t)qword_1E8F7A928);
  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 16))(v10, v15, v7);
  uint64_t v34 = v11;
  boxed_opaque_existential_0 = __swift_allocate_boxed_opaque_existential_0(v33);
  sub_1834BDEC0((uint64_t)v13, (uint64_t)boxed_opaque_existential_0, type metadata accessor for NWFileSerializationContext);
  unint64_t v17 = (void (*)(unsigned char *, void))sub_183D4428C();
  sub_183533F90((uint64_t)v33, (uint64_t)v10);
  v17(v35, 0);
  sub_1834BDF28((uint64_t)v13);
  uint64_t v18 = *(void *)(v32 + 16);
  if (v18)
  {
    uint64_t v19 = v32 + 32;
    swift_bridgeObjectRetain();
    unsigned int v20 = (void *)MEMORY[0x1E4FBC860];
    uint64_t v21 = v36 & 1;
    uint64_t v36 = v14;
    while (1)
    {
      sub_1834BDF84(v19, (uint64_t)v33);
      uint64_t v22 = v34;
      __swift_project_boxed_opaque_existential_2(v33, v34);
      uint64_t v23 = sub_183559DE4(v14, v21, v22);
      if (v4) {
        break;
      }
      uint64_t v25 = v23;
      unint64_t v26 = v24;
      sub_1832E5D6C(v23, v24);
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
        unsigned int v20 = sub_1834B4488(0, v20[2] + 1, 1, v20);
      }
      unint64_t v28 = v20[2];
      unint64_t v27 = v20[3];
      if (v28 >= v27 >> 1) {
        unsigned int v20 = sub_1834B4488((void *)(v27 > 1), v28 + 1, 1, v20);
      }
      v20[2] = v28 + 1;
      unsigned int v29 = &v20[2 * v28];
      void v29[4] = v25;
      v29[5] = v26;
      sub_1832E5E9C(v25, v26);
      __swift_destroy_boxed_opaque_existential_2((uint64_t)v33);
      v19 += 48;
      --v18;
      uint64_t v14 = v36;
      if (!v18)
      {
        swift_release();
        swift_bridgeObjectRelease();
        return v20;
      }
    }
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_release();
    __swift_destroy_boxed_opaque_existential_2((uint64_t)v33);
  }
  else
  {
    swift_release();
    return (void *)MEMORY[0x1E4FBC860];
  }
  return v20;
}

uint64_t sub_1834BDCB0()
{
  return NWActorSystemInvocationEncoder.recordGenericSubstitution<A>(_:)();
}

uint64_t sub_1834BDCC8(uint64_t a1, uint64_t a2)
{
  return NWActorSystemInvocationEncoder.recordArgument<A>(_:)(a1, a2);
}

uint64_t sub_1834BDD28()
{
  return NWActorSystemInvocationEncoder.recordReturnType<A>(_:)();
}

_OWORD *sub_1834BDD78(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v14 = a4;
  uint64_t v15 = a5;
  uint64_t v16 = a6;
  boxed_opaque_existential_0 = __swift_allocate_boxed_opaque_existential_0((uint64_t *)&v13);
  (*(void (**)(uint64_t *, uint64_t, uint64_t))(*(void *)(a4 - 8) + 32))(boxed_opaque_existential_0, a2, a4);
  uint64_t v11 = *a3;
  *(void *)(v11 + 16) = a1 + 1;
  return sub_1834BDFE8(&v13, (_OWORD *)(v11 + 48 * a1 + 32));
}

ValueMetadata *type metadata accessor for NWActorSystemInvocationEncoder()
{
  return &type metadata for NWActorSystemInvocationEncoder;
}

uint64_t sub_1834BDE24(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  *(void *)(a2 + 24) = v3;
  *(void *)(a2 + 32) = *(void *)(a1 + 32);
  (**(void (***)(uint64_t, uint64_t))(v3 - 8))(a2, a1);
  return a2;
}

uint64_t __swift_project_value_buffer(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned char *)(*(void *)(a1 - 8) + 82) & 2) != 0) {
    return *(void *)a2;
  }
  return a2;
}

uint64_t sub_1834BDEC0(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v5 = a3(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16))(a2, a1, v5);
  return a2;
}

uint64_t sub_1834BDF28(uint64_t a1)
{
  uint64_t v2 = type metadata accessor for NWFileSerializationContext(0);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v2 - 8) + 8))(a1, v2);
  return a1;
}

uint64_t sub_1834BDF84(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  *(void *)(a2 + 24) = v3;
  *(_OWORD *)(a2 + 32) = *(_OWORD *)(a1 + 32);
  (**(void (***)(uint64_t, uint64_t))(v3 - 8))(a2, a1);
  return a2;
}

_OWORD *sub_1834BDFE8(long long *a1, _OWORD *a2)
{
  long long v2 = *a1;
  long long v3 = a1[2];
  a2[1] = a1[1];
  a2[2] = v3;
  *a2 = v2;
  return a2;
}

uint64_t sub_1834BE000(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_183D456AC();
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](v4);
  uint64_t v7 = &v14[-((v6 + 15) & 0xFFFFFFFFFFFFFFF0)];
  sub_183D4426C();
  swift_allocObject();
  uint64_t v8 = sub_183D4425C();
  sub_183D4568C();
  uint64_t v16 = type metadata accessor for NWActorSystem();
  v15[0] = a1;
  swift_retain();
  uint64_t v9 = (void (*)(unsigned char *, void))sub_183D4424C();
  sub_183533F90((uint64_t)v15, (uint64_t)v7);
  v9(v14, 0);
  if (qword_1E8F621B8 != -1) {
    swift_once();
  }
  uint64_t v10 = __swift_project_value_buffer(v4, (uint64_t)qword_1E8F7A928);
  (*(void (**)(unsigned char *, uint64_t, uint64_t))(v5 + 16))(v7, v10, v4);
  uint64_t v16 = type metadata accessor for NWFileSerializationContext(0);
  boxed_opaque_existential_0 = __swift_allocate_boxed_opaque_existential_0(v15);
  sub_1834BE1E8(a2, (uint64_t)boxed_opaque_existential_0);
  uint64_t v12 = (void (*)(unsigned char *, void))sub_183D4424C();
  sub_183533F90((uint64_t)v15, (uint64_t)v7);
  v12(v14, 0);
  return v8;
}

uint64_t sub_1834BE1E8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = type metadata accessor for NWFileSerializationContext(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16))(a2, a1, v4);
  return a2;
}

uint64_t HTTPRequest.url.getter@<X0>(uint64_t a1@<X8>)
{
  if (!v1[8]) {
    goto LABEL_6;
  }
  uint64_t v3 = v1[15];
  if (!v3) {
    goto LABEL_6;
  }
  unint64_t v4 = v1[13];
  uint64_t v5 = v1[14];
  uint64_t v6 = v1[16];
  uint64_t v7 = v1[17];
  uint64_t v9 = v1[18];
  uint64_t v8 = v1[19];
  uint64_t v11 = v1[20];
  uint64_t v10 = v1[21];
  uint64_t v12 = v1[22];
  uint64_t v13 = v1[23];
  uint64_t v15 = v1[24];
  uint64_t v14 = v1[25];
  uint64_t v17 = v1[26];
  uint64_t v16 = v1[27];
  unint64_t v18 = v1[12];
  v26[0] = v5;
  v26[1] = v3;
  v26[2] = v6;
  v26[3] = v7;
  char v27 = v9;
  uint64_t v28 = v8;
  uint64_t v29 = v11;
  if (v12)
  {
    uint64_t v23 = v5;
    uint64_t v24 = v12;
    unint64_t v22 = v4;
    v30[0] = v10;
    v30[1] = v12;
    v30[2] = v13;
    void v30[3] = v15;
    char v31 = v14;
    uint64_t v32 = v17;
    uint64_t v33 = v16;
    if (sub_1834BF534(v18, v4))
    {
      v25[0] = v18;
      v25[1] = v22;
      sub_1834BF9F8(v23, v3);
      sub_1834BF9F8(v10, v24);
      sub_1834BF9F8(v23, v3);
      sub_1834BF9F8(v10, v24);
      sub_1834BF9F8(v23, v3);
      sub_1834BF9F8(v10, v24);
      swift_bridgeObjectRetain();
      sub_1834BF6CC(v25, (uint64_t)v26, (uint64_t)v30, a1);
      swift_bridgeObjectRelease();
      sub_1834BFA48(v23, v3);
      sub_1834BFA48(v10, v24);
      sub_1834BFA48(v23, v3);
    }
    else
    {
      sub_1834BF9F8(v10, v24);
      sub_1834BF9F8(v23, v3);
      sub_1834BF9F8(v10, v24);
      sub_1834BF9F8(v23, v3);
      sub_1835A3910(v18, v22, (uint64_t)v26, (uint64_t)v30, a1);
      sub_1834BFA48(v23, v3);
    }
    return sub_1834BFA48(v10, v24);
  }
  else
  {
LABEL_6:
    uint64_t v19 = sub_183D4447C();
    unsigned int v20 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v19 - 8) + 56);
    return v20(a1, 1, 1, v19);
  }
}

uint64_t sub_1834BE698(uint64_t a1)
{
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F61F40);
  MEMORY[0x1F4188790](v2 - 8);
  unint64_t v4 = (char *)&v6 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_1834BFA98(a1, (uint64_t)v4);
  return HTTPRequest.url.setter((uint64_t)v4);
}

uint64_t HTTPRequest.url.setter(uint64_t a1)
{
  uint64_t v2 = v1;
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F61F40);
  MEMORY[0x1F4188790](v4 - 8);
  uint64_t v6 = (char *)&v23 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = sub_183D4447C();
  uint64_t v8 = *(void *)(v7 - 8);
  MEMORY[0x1F4188790](v7);
  uint64_t v10 = (char *)&v23 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_1834BFA98(a1, (uint64_t)v6);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v8 + 48))(v6, 1, v7) == 1)
  {
    sub_1834BFB00((uint64_t)v6);
    sub_1834BFA48(*(void *)(v2 + 56), *(void *)(v2 + 64));
    *(void *)(v2 + 104) = 0;
    *(_OWORD *)(v2 + 88) = 0u;
    *(_OWORD *)(v2 + 72) = 0u;
    *(_OWORD *)(v2 + 56) = 0u;
    sub_1834BFA48(*(void *)(v2 + 112), *(void *)(v2 + 120));
    *(void *)(v2 + 160) = 0;
    *(_OWORD *)(v2 + 128) = 0u;
    *(_OWORD *)(v2 + 144) = 0u;
    *(_OWORD *)(v2 + 112) = 0u;
    sub_1834BFA48(*(void *)(v2 + 168), *(void *)(v2 + 176));
    *(void *)(v2 + 216) = 0;
    *(_OWORD *)(v2 + 200) = 0u;
    *(_OWORD *)(v2 + 184) = 0u;
    *(_OWORD *)(v2 + 168) = 0u;
    return sub_1834BFB00(a1);
  }
  else
  {
    (*(void (**)(char *, char *, uint64_t))(v8 + 32))(v10, v6, v7);
    sub_1834BEDF0();
    uint64_t v13 = v12;
    unint64_t v14 = sub_183D44C1C();
    unint64_t v16 = v15;
    swift_bridgeObjectRelease();
    HTTPRequest.scheme.setter(v14, v16);
    if (v13)
    {
      swift_bridgeObjectRetain();
      unint64_t v17 = sub_183D44C1C();
      unint64_t v19 = v18;
      swift_bridgeObjectRelease_n();
    }
    else
    {
      unint64_t v17 = 0;
      unint64_t v19 = 0;
    }
    HTTPRequest.authority.setter(v17, v19);
    unint64_t v20 = sub_183D44C1C();
    unint64_t v22 = v21;
    swift_bridgeObjectRelease();
    HTTPRequest.path.setter(v20, v22);
    sub_1834BFB00(a1);
    return (*(uint64_t (**)(char *, uint64_t))(v8 + 8))(v10, v7);
  }
}

uint64_t sub_1834BE9E4@<X0>(char *a1@<X0>, char *a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, char *a5@<X4>, uint64_t a6@<X8>)
{
  unint64_t v12 = *(void *)(a3 + 40);
  unint64_t v11 = *(void *)(a3 + 48);
  if ((sub_1834BF534(v12, v11) & 1) == 0) {
    return sub_1835A3BB0(v12, v11, a4, a5, a1, a2, a6);
  }
  swift_bridgeObjectRetain();
  if ((v11 & 0x1000000000000000) != 0)
  {
    unint64_t v12 = sub_18359979C();
    unint64_t v17 = v16;
    swift_bridgeObjectRelease();
    unint64_t v11 = v17;
    if ((v17 & 0x2000000000000000) == 0)
    {
LABEL_4:
      if ((v12 & 0x1000000000000000) != 0)
      {
        uint64_t v13 = (char *)((v11 & 0xFFFFFFFFFFFFFFFLL) + 32);
        unint64_t v14 = (char *)(v12 & 0xFFFFFFFFFFFFLL);
      }
      else
      {
        uint64_t v13 = (char *)sub_183D4557C();
        unint64_t v14 = v18;
      }
      goto LABEL_9;
    }
  }
  else if ((v11 & 0x2000000000000000) == 0)
  {
    goto LABEL_4;
  }
  unint64_t v14 = (char *)(HIBYTE(v11) & 0xF);
  v19[0] = v12;
  v19[1] = v11 & 0xFFFFFFFFFFFFFFLL;
  uint64_t v13 = (char *)v19;
LABEL_9:
  sub_1834BEB10(a4, a5, a1, a2, v13, v14, a6);
  return swift_bridgeObjectRelease();
}

uint64_t sub_1834BEB10@<X0>(char *a1@<X0>, char *a2@<X1>, char *a3@<X2>, char *a4@<X3>, char *a5@<X4>, char *a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v35 = a5;
  uint64_t v13 = sub_183D4447C();
  uint64_t v14 = *(void *)(v13 - 8);
  MEMORY[0x1F4188790](v13);
  unint64_t v16 = (char *)&v33 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v17 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F61F40);
  uint64_t result = MEMORY[0x1F4188790](v17 - 8);
  unint64_t v20 = (char *)&v33 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  unint64_t v21 = a2 + 3;
  if (__OFADD__(a2, 3))
  {
    __break(1u);
    goto LABEL_12;
  }
  BOOL v22 = __OFADD__(v21, a4);
  uint64_t v23 = &a4[(void)v21];
  if (v22)
  {
LABEL_12:
    __break(1u);
    goto LABEL_13;
  }
  BOOL v22 = __OFADD__(v23, a6);
  uint64_t v24 = (uint64_t)&a6[(void)v23];
  if (v22)
  {
LABEL_13:
    __break(1u);
    return result;
  }
  uint64_t v34 = a7;
  uint64_t v36 = sub_1834B4598(0, v24 & ~(v24 >> 63), 0, MEMORY[0x1E4FBC860]);
  sub_183559FE4(a1, a2);
  sub_18355A1FC(3092282, 0xE300000000000000);
  sub_183559FE4(a3, a4);
  sub_183559FE4(v35, a6);
  uint64_t v25 = v36;
  CFIndex v26 = *((void *)v36 + 2);
  CFAllocatorRef v27 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  swift_bridgeObjectRetain();
  CFURLRef v28 = CFURLCreateAbsoluteURLWithBytes(v27, (const UInt8 *)v25 + 32, v26, 0x600u, 0, 0);
  if (v28)
  {
    CFURLRef v29 = v28;
    sub_183D4443C();
    (*(void (**)(char *, char *, uint64_t))(v14 + 32))(v20, v16, v13);
    uint64_t v30 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v14 + 56);
    v30(v20, 0, 1, v13);
  }
  else
  {
    uint64_t v30 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v14 + 56);
    v30(v20, 1, 1, v13);
  }
  uint64_t v31 = v34;
  swift_bridgeObjectRelease_n();
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v14 + 48))(v20, 1, v13) == 1)
  {
    sub_1834BFB00((uint64_t)v20);
    uint64_t v32 = 1;
  }
  else
  {
    (*(void (**)(uint64_t, char *, uint64_t))(v14 + 32))(v31, v20, v13);
    uint64_t v32 = 0;
  }
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))v30)(v31, v32, 1, v13);
}

uint64_t sub_1834BEDF0()
{
  v12[3] = *MEMORY[0x1E4F143B8];
  uint64_t v0 = sub_183D4447C();
  uint64_t v1 = *(void *)(v0 - 8);
  MEMORY[0x1F4188790](v0);
  uint64_t v3 = &v11[-((v2 + 15) & 0xFFFFFFFFFFFFFFF0)];
  sub_183D443EC();
  CFURLRef v4 = (const __CFURL *)sub_183D4441C();
  (*(void (**)(unsigned char *, uint64_t))(v1 + 8))(v3, v0);
  CFIndex isStackAllocationSafe = CFURLGetBytes(v4, 0, 0);
  if (isStackAllocationSafe < 0) {
    __break(1u);
  }
  CFIndex v6 = isStackAllocationSafe;
  if (isStackAllocationSafe <= 1024
    || (CFIndex isStackAllocationSafe = swift_stdlib_isStackAllocationSafe(), isStackAllocationSafe))
  {
    MEMORY[0x1F4188790](isStackAllocationSafe);
    sub_1834BF284(&v11[-v7], v6, v4, v12);
    uint64_t v8 = v12[0];
  }
  else
  {
    uint64_t v9 = (UInt8 *)swift_slowAlloc();
    sub_1834BF284(v9, v6, v4, v12);
    MEMORY[0x185318E50](v9, -1, -1);

    return v12[0];
  }
  return v8;
}

void (*HTTPRequest.url.modify(void *a1))(uint64_t a1, char a2)
{
  *a1 = v1;
  size_t v3 = *(void *)(*(void *)(__swift_instantiateConcreteTypeFromMangledName(&qword_1E8F61F40) - 8) + 64);
  a1[1] = malloc(v3);
  CFURLRef v4 = malloc(v3);
  a1[2] = v4;
  memcpy(v6, v1, sizeof(v6));
  HTTPRequest.url.getter((uint64_t)v4);
  return sub_1834BF0B8;
}

void sub_1834BF0B8(uint64_t a1, char a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  size_t v3 = *(void **)(a1 + 16);
  if (a2)
  {
    sub_1834BFA98((uint64_t)v3, (uint64_t)v2);
    HTTPRequest.url.setter((uint64_t)v2);
    sub_1834BFB00((uint64_t)v3);
  }
  else
  {
    HTTPRequest.url.setter((uint64_t)v3);
  }
  free(v3);

  free(v2);
}

void *HTTPRequest.init(method:url:headerFields:)@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, void *a4@<X8>)
{
  uint64_t v6 = *a1;
  uint64_t v5 = a1[1];
  uint64_t v20 = *a3;
  sub_1834BEDF0();
  uint64_t v8 = v7;
  unint64_t v9 = sub_183D44C1C();
  unint64_t v11 = v10;
  swift_bridgeObjectRelease();
  if (v8)
  {
    swift_bridgeObjectRetain();
    unint64_t v12 = sub_183D44C1C();
    unint64_t v14 = v13;
    swift_bridgeObjectRelease_n();
  }
  else
  {
    unint64_t v12 = 0;
    unint64_t v14 = 0;
  }
  unint64_t v15 = sub_183D44C1C();
  unint64_t v17 = v16;
  swift_bridgeObjectRelease();
  v23[0] = v6;
  v23[1] = v5;
  uint64_t v22 = v20;
  HTTPRequest.init(method:scheme:authority:path:headerFields:)(v23, v9, v11, v12, v14, v15, v17, &v22, (uint64_t)__src);
  uint64_t v18 = sub_183D4447C();
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v18 - 8) + 8))(a2, v18);
  return memcpy(a4, __src, 0x120uLL);
}

uint64_t sub_1834BF284@<X0>(UInt8 *buffer@<X0>, CFIndex bufferLength@<X1>, CFURLRef url@<X2>, uint64_t *a4@<X8>)
{
  CFURLGetBytes(url, buffer, bufferLength);
  CFRange v7 = CFURLGetByteRangeForComponent(url, kCFURLComponentScheme, 0);
  if (v7.location == -1)
  {
    __break(1u);
    goto LABEL_41;
  }
  if (__OFADD__(v7.location, v7.length))
  {
LABEL_41:
    __break(1u);
    goto LABEL_42;
  }
  if (v7.location + v7.length < v7.location)
  {
LABEL_42:
    __break(1u);
LABEL_43:
    __break(1u);
    goto LABEL_44;
  }
  uint64_t v8 = sub_183599ED4((char *)v7.location, v7.length);
  CFRange v9 = CFURLGetByteRangeForComponent(url, kCFURLComponentHost, 0);
  if (v9.location == -1)
  {
    uint64_t v14 = 0;
    goto LABEL_15;
  }
  CFIndex length = v9.length;
  CFRange v11 = CFURLGetByteRangeForComponent(url, kCFURLComponentPort, 0);
  if (v11.location != -1)
  {
    CFIndex v12 = v11.location + v11.length;
    if (__OFADD__(v11.location, v11.length))
    {
LABEL_47:
      __break(1u);
      goto LABEL_48;
    }
    CFIndex length = v12 - v9.location;
    if (__OFSUB__(v12, v9.location))
    {
LABEL_48:
      __break(1u);
      goto LABEL_49;
    }
  }
  if (__OFADD__(v9.location, length)) {
    goto LABEL_43;
  }
  if (v9.location + length < v9.location)
  {
LABEL_44:
    __break(1u);
    goto LABEL_45;
  }
  if (buffer) {
    unint64_t v13 = (char *)&buffer[v9.location];
  }
  else {
    unint64_t v13 = 0;
  }
  uint64_t v14 = sub_183599ED4(v13, length);
LABEL_15:
  CFRange v15 = CFURLGetByteRangeForComponent(url, kCFURLComponentPath, 0);
  CFIndex location = v15.location;
  CFRange v18 = CFURLGetByteRangeForComponent(url, kCFURLComponentQuery, 0);
  CFIndex v17 = v18.length;
  if (v15.location == -1) {
    goto LABEL_21;
  }
  if (v18.location != -1)
  {
    CFIndex v19 = v18.location + v18.length;
    if (__OFADD__(v18.location, v18.length))
    {
LABEL_49:
      __break(1u);
LABEL_50:
      __break(1u);
      goto LABEL_51;
    }
    CFIndex v17 = v19 - v15.location;
    if (!__OFSUB__(v19, v15.location))
    {
LABEL_22:
      if (v15.length) {
        goto LABEL_23;
      }
      goto LABEL_31;
    }
    __break(1u);
LABEL_21:
    CFIndex location = v18.location;
    goto LABEL_22;
  }
  CFIndex v17 = v15.length;
  if (v15.length)
  {
LABEL_23:
    if (!__OFADD__(location, v17))
    {
      if (location + v17 >= location)
      {
        if (buffer) {
          uint64_t v20 = (char *)&buffer[location];
        }
        else {
          uint64_t v20 = 0;
        }
        uint64_t result = sub_183599ED4(v20, v17);
        goto LABEL_29;
      }
      goto LABEL_46;
    }
LABEL_45:
    __break(1u);
LABEL_46:
    __break(1u);
    goto LABEL_47;
  }
LABEL_31:
  if (!v17)
  {
    uint64_t result = sub_1834F0198(47, 0xE100000000000000);
LABEL_29:
    uint64_t v22 = result;
LABEL_38:
    *a4 = v8;
    a4[1] = v14;
    a4[2] = v22;
    return result;
  }
  if (__OFADD__(location, v17)) {
    goto LABEL_50;
  }
  if (location + v17 < location)
  {
LABEL_51:
    __break(1u);
    goto LABEL_52;
  }
  CFIndex v23 = v17 + 1;
  if (__OFADD__(v17, 1))
  {
LABEL_52:
    __break(1u);
LABEL_53:
    *(unsigned char *)(MEMORY[0x1E4FBC860] + 32) = 47;
    __break(1u);
    goto LABEL_54;
  }
  if ((v23 & 0x8000000000000000) == 0)
  {
    if (v17 != -1)
    {
      uint64_t v22 = sub_183D44EBC();
      *(void *)(v22 + 16) = v23;
      *(unsigned char *)(v22 + 32) = 47;
      uint64_t result = sub_183D453AC();
      *(void *)(v22 + 16) = v23;
      goto LABEL_38;
    }
    goto LABEL_53;
  }
LABEL_54:
  uint64_t result = sub_183D456BC();
  __break(1u);
  return result;
}

unint64_t sub_1834BF534(unint64_t a1, unint64_t a2)
{
  if ((a2 & 0x2000000000000000) != 0) {
    unint64_t v4 = HIBYTE(a2) & 0xF;
  }
  else {
    unint64_t v4 = a1 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v5 = 4 * v4;
  uint64_t v6 = (a1 >> 59) & 1;
  if ((a2 & 0x1000000000000000) == 0) {
    LOBYTE(v6) = 1;
  }
  uint64_t v7 = 4 << v6;
  uint64_t v16 = a2 & 0xFFFFFFFFFFFFFFLL;
  uint64_t v14 = (a2 & 0xFFFFFFFFFFFFFFFLL) + 32;
  unint64_t v8 = 15;
  while (1)
  {
    unint64_t v9 = v8 >> 14;
    if (v8 >> 14 == v5) {
      return v9 == v5;
    }
    unint64_t v10 = v8 & 0xC;
    unint64_t result = v8;
    if (v10 == v7) {
      unint64_t result = sub_183520284(v8, a1, a2);
    }
    unint64_t v12 = result >> 16;
    if (result >> 16 >= v4) {
      break;
    }
    if ((a2 & 0x1000000000000000) != 0)
    {
      unint64_t result = sub_183D44CFC();
      char v13 = result;
      if (v10 == v7) {
        goto LABEL_24;
      }
LABEL_19:
      if ((a2 & 0x1000000000000000) == 0) {
        goto LABEL_7;
      }
LABEL_20:
      if (v4 <= v8 >> 16) {
        goto LABEL_28;
      }
      unint64_t v8 = sub_183D44CBC();
      if (v13 < 0) {
        return v9 == v5;
      }
    }
    else
    {
      if ((a2 & 0x2000000000000000) != 0)
      {
        v15[0] = a1;
        v15[1] = v16;
        char v13 = *((unsigned char *)v15 + v12);
        if (v10 == v7) {
          goto LABEL_24;
        }
        goto LABEL_19;
      }
      unint64_t result = v14;
      if ((a1 & 0x1000000000000000) == 0) {
        unint64_t result = sub_183D4557C();
      }
      char v13 = *(unsigned char *)(result + v12);
      if (v10 != v7) {
        goto LABEL_19;
      }
LABEL_24:
      unint64_t result = sub_183520284(v8, a1, a2);
      unint64_t v8 = result;
      if ((a2 & 0x1000000000000000) != 0) {
        goto LABEL_20;
      }
LABEL_7:
      unint64_t v8 = (v8 & 0xFFFFFFFFFFFF0000) + 65540;
      if (v13 < 0) {
        return v9 == v5;
      }
    }
  }
  __break(1u);
LABEL_28:
  __break(1u);
  return result;
}

uint64_t sub_1834BF6CC@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8 = *a1;
  unint64_t v9 = a1[1];
  if ((v9 & 0x1000000000000000) != 0)
  {
    uint64_t v8 = sub_18359979C();
    uint64_t v22 = v21;
    swift_bridgeObjectRelease();
    *a1 = v8;
    a1[1] = v22;
    unint64_t v9 = v22;
    if ((v22 & 0x2000000000000000) == 0) {
      goto LABEL_3;
    }
  }
  else if ((v9 & 0x2000000000000000) == 0)
  {
LABEL_3:
    if ((v8 & 0x1000000000000000) != 0)
    {
      unint64_t v10 = (char *)((v9 & 0xFFFFFFFFFFFFFFFLL) + 32);
      CFRange v11 = (char *)(v8 & 0xFFFFFFFFFFFFLL);
    }
    else
    {
      unint64_t v10 = (char *)sub_183D4557C();
      CFRange v11 = v27;
    }
    unint64_t v13 = *(void *)(a2 + 40);
    unint64_t v12 = *(void *)(a2 + 48);
    if (sub_1834BF534(v13, v12))
    {
      unint64_t v29 = v13;
      uint64_t v30 = v12;
      sub_1834BFB88(a3);
      sub_1834BFB88(a3);
      sub_1834BFB88(a3);
      swift_bridgeObjectRetain();
      sub_1834BF90C((uint64_t *)&v29, a3, v10, v11, a4);
      if (!v4) {
        goto LABEL_12;
      }
      sub_18312A0D8(a3);
      sub_18312A0D8(a3);
      swift_bridgeObjectRelease();
      __break(1u);
      goto LABEL_18;
    }
    sub_1834BFB88(a3);
    uint64_t v14 = a4;
    unint64_t v15 = v13;
    unint64_t v16 = v12;
    uint64_t v17 = a3;
    CFRange v18 = v10;
    CFIndex v19 = v11;
LABEL_14:
    sub_183129E54(v15, v16, v17, v18, v19, v14);
    goto LABEL_15;
  }
  CFIndex v23 = (char *)(HIBYTE(v9) & 0xF);
  unint64_t v29 = v8;
  uint64_t v30 = v9 & 0xFFFFFFFFFFFFFFLL;
  unint64_t v25 = *(void *)(a2 + 40);
  unint64_t v24 = *(void *)(a2 + 48);
  if ((sub_1834BF534(v25, v24) & 1) == 0)
  {
    sub_1834BFB88(a3);
    CFRange v18 = (char *)&v29;
    uint64_t v14 = a4;
    unint64_t v15 = v25;
    unint64_t v16 = v24;
    uint64_t v17 = a3;
    CFIndex v19 = v23;
    goto LABEL_14;
  }
  v28[0] = v25;
  v28[1] = v24;
  sub_1834BFB88(a3);
  sub_1834BFB88(a3);
  sub_1834BFB88(a3);
  swift_bridgeObjectRetain();
  sub_1834BF90C(v28, a3, (char *)&v29, v23, a4);
  if (!v4)
  {
LABEL_12:
    swift_bridgeObjectRelease();
    sub_18312A0D8(a3);
    sub_18312A0D8(a3);
LABEL_15:
    sub_18312A0D8(a2);
    return sub_18312A0D8(a3);
  }
LABEL_18:
  sub_18312A0D8(a3);
  sub_18312A0D8(a3);
  uint64_t result = swift_bridgeObjectRelease();
  __break(1u);
  return result;
}

uint64_t sub_1834BF90C@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, char *a3@<X2>, char *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9 = *a1;
  unint64_t v10 = a1[1];
  if ((v10 & 0x1000000000000000) == 0)
  {
    if ((v10 & 0x2000000000000000) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    unint64_t v12 = (char *)(HIBYTE(v10) & 0xF);
    v17[0] = v9;
    v17[1] = v10 & 0xFFFFFFFFFFFFFFLL;
    CFRange v11 = (char *)v17;
    goto LABEL_7;
  }
  uint64_t v9 = sub_18359979C();
  uint64_t v15 = v14;
  swift_bridgeObjectRelease();
  *a1 = v9;
  a1[1] = v15;
  unint64_t v10 = v15;
  if ((v15 & 0x2000000000000000) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((v9 & 0x1000000000000000) != 0)
  {
    CFRange v11 = (char *)((v10 & 0xFFFFFFFFFFFFFFFLL) + 32);
    unint64_t v12 = (char *)(v9 & 0xFFFFFFFFFFFFLL);
  }
  else
  {
    CFRange v11 = (char *)sub_183D4557C();
  }
LABEL_7:
  sub_1834BE9E4(v11, v12, a2, a3, a4, a5);
  return sub_18312A0D8(a2);
}

uint64_t sub_1834BF9F8(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    return swift_bridgeObjectRetain();
  }
  return result;
}

uint64_t sub_1834BFA48(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    return swift_bridgeObjectRelease();
  }
  return result;
}

uint64_t sub_1834BFA98(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F61F40);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16))(a2, a1, v4);
  return a2;
}

uint64_t sub_1834BFB00(uint64_t a1)
{
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F61F40);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v2 - 8) + 8))(a1, v2);
  return a1;
}

uint64_t sub_1834BFB60@<X0>(uint64_t a1@<X8>)
{
  return HTTPRequest.url.getter(a1);
}

uint64_t sub_1834BFB88(uint64_t a1)
{
  return a1;
}

uint64_t sub_1834BFBD4(uint64_t a1, uint64_t (*a2)(void))
{
  return a2() & 1;
}

uint64_t sub_1834BFC00(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 32))(a2) & 1;
}

uint64_t NWBrowser.__allocating_init(for:using:)(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = swift_allocObject();
  NWBrowser.init(for:using:)(a1, a2);
  return v4;
}

Swift::Void __swiftcall NWBrowser.cancel()()
{
  uint64_t v1 = v0;
  if (nw_utilities_minos_atleast(1))
  {
    uint64_t v2 = *(os_unfair_lock_s **)(v0 + 24);
    size_t v3 = (uint64_t *)&v2[4];
    uint64_t v4 = v2 + 20;
    os_unfair_lock_lock(v2 + 20);
    sub_1834C39B8(v3);
    os_unfair_lock_unlock(v4);
  }
  uint64_t v5 = *(NSObject **)(v1 + 16);

  nw_browser_cancel(v5);
}

void NWBrowser.stateUpdateHandler.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(os_unfair_lock_s **)(v2 + 24);
  uint64_t v6 = (uint64_t)&v5[4];
  uint64_t v7 = v5 + 20;
  os_unfair_lock_lock(v5 + 20);
  sub_1834C39FC(v6);
  os_unfair_lock_unlock(v7);
  if (a1)
  {
    uint64_t v8 = *(NSObject **)(v2 + 16);
    uint64_t v9 = swift_allocObject();
    *(void *)(v9 + 16) = a1;
    *(void *)(v9 + 24) = a2;
    void aBlock[4] = sub_1834C3A90;
    aBlock[5] = v9;
    aBlock[0] = MEMORY[0x1E4F143A8];
    aBlock[1] = 1107296256;
    aBlock[2] = sub_1834C2B94;
    aBlock[3] = &block_descriptor_0;
    unint64_t v10 = _Block_copy(aBlock);
    sub_18315ED5C(a1);
    sub_18315ED5C(a1);
    swift_unknownObjectRetain();
    swift_release();
    nw_browser_set_state_changed_handler(v8, v10);
    sub_18313D870(a1);
    _Block_release(v10);
    swift_unknownObjectRelease();
    sub_18313D870(a1);
  }
  else
  {
    nw_browser_set_state_changed_handler(*(nw_browser_t *)(v2 + 16), 0);
  }
}

uint64_t NWBrowser.browseResultsChangedHandler.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = v2;
  uint64_t v6 = *(os_unfair_lock_s **)(v2 + 24);
  uint64_t v7 = (uint64_t)&v6[4];
  uint64_t v8 = v6 + 20;
  os_unfair_lock_lock(v6 + 20);
  sub_1834C3AEC(v7, aBlock);
  os_unfair_lock_unlock(v8);
  if (LOBYTE(aBlock[0]) != 1) {
    return sub_18313D870(a1);
  }
  uint64_t v9 = *(NSObject **)(v2 + 16);
  unint64_t v10 = (void *)swift_allocObject();
  v10[2] = v3;
  v10[3] = a1;
  v10[4] = a2;
  void aBlock[4] = sub_1834C3BA4;
  aBlock[5] = v10;
  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 1107296256;
  aBlock[2] = sub_1834C35DC;
  aBlock[3] = &block_descriptor_6;
  CFRange v11 = _Block_copy(aBlock);
  swift_unknownObjectRetain();
  swift_retain();
  sub_18315ED5C(a1);
  swift_release();
  nw_browser_set_browse_results_changed_handler(v9, v11);
  sub_18313D870(a1);
  _Block_release(v11);
  return swift_unknownObjectRelease();
}

void NWBrowser.start(queue:)(NSObject *a1)
{
  uint64_t v2 = v1;
  uint64_t v4 = *(os_unfair_lock_s **)(v1 + 24);
  uint64_t v5 = (uint64_t)&v4[4];
  uint64_t v6 = v4 + 20;
  os_unfair_lock_lock(v4 + 20);
  sub_1834C3BB0(v5);
  os_unfair_lock_unlock(v6);
  os_unfair_lock_lock(v6);
  sub_1834C3668(v5, &v11);
  os_unfair_lock_unlock(v6);
  if ((void)v11)
  {
    long long v10 = v11;
    uint64_t v7 = swift_allocObject();
    *(_OWORD *)(v7 + 16) = v10;
    uint64_t v8 = sub_1834C3BFC;
  }
  else
  {
    uint64_t v8 = 0;
    uint64_t v7 = 0;
  }
  sub_18315ED5C((uint64_t)v8);
  sub_18315ED5C((uint64_t)v8);
  NWBrowser.browseResultsChangedHandler.setter((uint64_t)v8, v7);
  sub_18313D870((uint64_t)v8);
  sub_18313D870((uint64_t)v8);
  uint64_t v9 = *(NSObject **)(v1 + 16);
  nw_browser_set_queue(*(nw_browser_t *)(v2 + 16), a1);
  nw_browser_start(v9);
}

uint64_t NWBrowser.debugDescription.getter()
{
  id v1 = objc_msgSend(*(id *)(v0 + 16), sel_description);
  uint64_t v2 = sub_183D44AFC();

  return v2;
}

void *static NWBrowser.Descriptor.Options.Scope.all.getter@<X0>(_DWORD *a1@<X8>)
{
  return sub_1834C02E4(&qword_1E8F619D8, &dword_1E8F61AC0, a1);
}

int *NWBrowser.Descriptor.Options.init(scope:)@<X0>(int *result@<X0>, uint64_t a2@<X8>)
{
  int v3 = *result;
  if (qword_1E8F619D8 != -1) {
    uint64_t result = (int *)swift_once();
  }
  if (qword_1E8F61AB0 != -1) {
    uint64_t result = (int *)swift_once();
  }
  int v4 = dword_1E8F61AA4;
  *(void *)a2 = MEMORY[0x1E4FBC860];
  *(_DWORD *)(a2 + 8) = v3;
  *(_DWORD *)(a2 + 12) = v4;
  *(unsigned char *)(a2 + 16) = 0;
  return result;
}

int *NWBrowser.Descriptor.Options.init(scope:deviceFilter:)@<X0>(int *result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v5 = *result;
  if (qword_1E8F619D8 != -1) {
    uint64_t result = (int *)swift_once();
  }
  if (qword_1E8F61AB0 != -1) {
    uint64_t result = (int *)swift_once();
  }
  int v6 = dword_1E8F61AA4;
  *(void *)a3 = a2;
  *(_DWORD *)(a3 + 8) = v5;
  *(_DWORD *)(a3 + 12) = v6;
  *(unsigned char *)(a3 + 16) = 0;
  return result;
}

void *static NWBrowser.Descriptor.Options.DeviceType.all.getter@<X0>(_DWORD *a1@<X8>)
{
  return sub_1834C02E4(&qword_1E8F61AB0, &dword_1E8F61AA4, a1);
}

void *sub_1834C02E4@<X0>(void *result@<X0>, _DWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  if (*result != -1) {
    uint64_t result = (void *)swift_once();
  }
  *a3 = *a2;
  return result;
}

int *NWBrowser.Descriptor.Options.init(scope:deviceFilter:deviceTypes:)@<X0>(int *result@<X0>, uint64_t a2@<X1>, int *a3@<X2>, uint64_t a4@<X8>)
{
  int v6 = *result;
  int v7 = *a3;
  if (qword_1E8F619D8 != -1) {
    uint64_t result = (int *)swift_once();
  }
  if (qword_1E8F61AB0 != -1) {
    uint64_t result = (int *)swift_once();
  }
  *(void *)a4 = a2;
  *(_DWORD *)(a4 + 8) = v6;
  *(_DWORD *)(a4 + 12) = v7;
  *(unsigned char *)(a4 + 16) = 0;
  return result;
}

uint64_t NWBrowser.Descriptor.Options.Scope.rawValue.getter()
{
  return *v0;
}

void static NWBrowser.Descriptor.Options.Scope.everyone.getter(_DWORD *a1@<X8>)
{
  *a1 = 128;
}

void sub_1834C03DC()
{
  int v0 = unk_1ECF601B4;
  if ((unk_1ECF601B4 & ~dword_1ECF601B0) == 0) {
    int v0 = 0;
  }
  int v1 = v0 | dword_1ECF601B0;
  int v2 = dword_1ECF601B8;
  if ((dword_1ECF601B8 & ~v1) == 0) {
    int v2 = 0;
  }
  int v3 = v2 | v1;
  if ((unk_1ECF601BC & ~v3) != 0) {
    int v4 = unk_1ECF601BC;
  }
  else {
    int v4 = 0;
  }
  int v5 = v4 | v3;
  int v6 = dword_1ECF601C0;
  if ((dword_1ECF601C0 & ~v5) == 0) {
    int v6 = 0;
  }
  int v7 = v6 | v5;
  if ((unk_1ECF601C4 & ~v7) != 0) {
    int v8 = unk_1ECF601C4;
  }
  else {
    int v8 = 0;
  }
  int v9 = v8 | v7;
  int v11 = dword_1ECF601C8;
  int v10 = unk_1ECF601CC;
  if ((dword_1ECF601C8 & ~v9) == 0) {
    int v11 = 0;
  }
  int v12 = v11 | v9;
  if ((unk_1ECF601CC & ~v12) == 0) {
    int v10 = 0;
  }
  dword_1E8F61AC0 = v10 | v12;
}

uint64_t sub_1834C0454@<X0>(uint64_t a1@<X0>, _DWORD *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3)
  {
    int v4 = 0;
    int v5 = (int *)(a1 + 32);
    do
    {
      int v7 = *v5++;
      int v6 = v7;
      if ((v7 & ~v4) == 0) {
        int v6 = 0;
      }
      v4 |= v6;
      --v3;
    }
    while (v3);
  }
  else
  {
    int v4 = 0;
  }
  uint64_t result = swift_bridgeObjectRelease();
  *a2 = v4;
  return result;
}

uint64_t sub_1834C04AC@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3)
  {
    int v4 = 0;
    int v5 = (unsigned __int8 *)(a1 + 32);
    do
    {
      int v7 = *v5++;
      int v6 = v7;
      if ((v7 & ~v4) == 0) {
        int v6 = 0;
      }
      v4 |= v6;
      --v3;
    }
    while (v3);
  }
  else
  {
    LOBYTE(v4) = 0;
  }
  uint64_t result = swift_bridgeObjectRelease();
  *a2 = v4;
  return result;
}

uint64_t sub_1834C050C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1F4184B08](a1, a4, a2, a5, a3);
}

uint64_t sub_1834C0524@<X0>(uint64_t a1@<X0>, _DWORD *a2@<X8>)
{
  return sub_1834C0454(a1, a2);
}

uint64_t NWBrowser.Descriptor.Options.DeviceType.init(rawValue:)@<X0>(uint64_t result@<X0>, _DWORD *a2@<X8>)
{
  *a2 = result;
  return result;
}

uint64_t NWBrowser.Descriptor.Options.DeviceType.rawValue.getter()
{
  return *v0;
}

void static NWBrowser.Descriptor.Options.DeviceType.iphone.getter(_DWORD *a1@<X8>)
{
  *a1 = 1;
}

void static NWBrowser.Descriptor.Options.DeviceType.ipad.getter(_DWORD *a1@<X8>)
{
  *a1 = 2;
}

void static NWBrowser.Descriptor.Options.DeviceType.mac.getter(_DWORD *a1@<X8>)
{
  *a1 = 4;
}

void static NWBrowser.Descriptor.Options.DeviceType.watch.getter(_DWORD *a1@<X8>)
{
  *a1 = 8;
}

void static NWBrowser.Descriptor.Options.DeviceType.tv.getter(_DWORD *a1@<X8>)
{
  *a1 = 16;
}

void static NWBrowser.Descriptor.Options.DeviceType.homepod.getter(_DWORD *a1@<X8>)
{
  *a1 = 32;
}

void static NWBrowser.Descriptor.Options.DeviceType.vision.getter(_DWORD *a1@<X8>)
{
  *a1 = 64;
}

void sub_1834C05A0()
{
  int v0 = unk_1ECF6014C;
  if ((unk_1ECF6014C & ~dword_1ECF60148) == 0) {
    int v0 = 0;
  }
  int v1 = v0 | dword_1ECF60148;
  int v2 = dword_1ECF60150;
  if ((dword_1ECF60150 & ~v1) == 0) {
    int v2 = 0;
  }
  int v3 = v2 | v1;
  if ((unk_1ECF60154 & ~v3) != 0) {
    int v4 = unk_1ECF60154;
  }
  else {
    int v4 = 0;
  }
  int v5 = v4 | v3;
  int v6 = dword_1ECF60158;
  if ((dword_1ECF60158 & ~v5) == 0) {
    int v6 = 0;
  }
  int v7 = v6 | v5;
  if ((unk_1ECF6015C & ~v7) != 0) {
    int v8 = unk_1ECF6015C;
  }
  else {
    int v8 = 0;
  }
  int v9 = v8 | v7;
  int v10 = dword_1ECF60160;
  if ((dword_1ECF60160 & ~v9) == 0) {
    int v10 = 0;
  }
  dword_1E8F61AA4 = v10 | v9;
}

_DWORD *sub_1834C060C@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X8>)
{
  *a2 = *result;
  return result;
}

void sub_1834C0618(_DWORD *a1@<X8>)
{
  *a1 = 0;
}

_DWORD *sub_1834C0620@<X0>(_DWORD *result@<X0>, int *a2@<X8>)
{
  *a2 = *v2 | *result;
  return result;
}

_DWORD *sub_1834C0634@<X0>(_DWORD *result@<X0>, int *a2@<X8>)
{
  *a2 = *v2 & *result;
  return result;
}

_DWORD *sub_1834C0648@<X0>(_DWORD *result@<X0>, int *a2@<X8>)
{
  *a2 = *v2 ^ *result;
  return result;
}

BOOL sub_1834C065C(_DWORD *a1, int *a2)
{
  int v3 = *a2;
  int v4 = *v2 & *a2;
  if (v4 != *a2) {
    *v2 |= v3;
  }
  *a1 = v3;
  return v4 != v3;
}

_DWORD *sub_1834C068C@<X0>(_DWORD *result@<X0>, uint64_t a2@<X8>)
{
  int v3 = *v2 & *result;
  if (v3) {
    *v2 &= ~*result;
  }
  *(_DWORD *)a2 = v3;
  *(unsigned char *)(a2 + 4) = v3 == 0;
  return result;
}

int *sub_1834C06B8@<X0>(int *result@<X0>, uint64_t a2@<X8>)
{
  int v3 = *result;
  int v4 = *v2;
  *v2 |= *result;
  int v5 = v4 & v3;
  *(_DWORD *)a2 = v5;
  *(unsigned char *)(a2 + 4) = v5 == 0;
  return result;
}

_DWORD *sub_1834C06DC(_DWORD *result)
{
  *v1 |= *result;
  return result;
}

_DWORD *sub_1834C06F0(_DWORD *result)
{
  *v1 &= *result;
  return result;
}

_DWORD *sub_1834C0704(_DWORD *result)
{
  *v1 ^= *result;
  return result;
}

_DWORD *sub_1834C0718@<X0>(_DWORD *result@<X0>, int *a2@<X8>)
{
  *a2 = *v2 & ~*result;
  return result;
}

BOOL sub_1834C072C(_DWORD *a1)
{
  return (*v1 & ~*a1) == 0;
}

BOOL sub_1834C0740(_DWORD *a1)
{
  return (*v1 & *a1) == 0;
}

BOOL sub_1834C0754(_DWORD *a1)
{
  return (*a1 & ~*v1) == 0;
}

BOOL sub_1834C0768()
{
  return *v0 == 0;
}

_DWORD *sub_1834C0778(_DWORD *result)
{
  *v1 &= ~*result;
  return result;
}

uint64_t NWBrowser.Descriptor.Options.deviceFilter.getter()
{
  return swift_bridgeObjectRetain();
}

uint64_t NWBrowser.Descriptor.Options.deviceFilter.setter(uint64_t a1)
{
  uint64_t result = swift_bridgeObjectRelease();
  void *v1 = a1;
  return result;
}

uint64_t (*NWBrowser.Descriptor.Options.deviceFilter.modify())()
{
  return nullsub_1;
}

void NWBrowser.Descriptor.Options.scope.getter(_DWORD *a1@<X8>)
{
  *a1 = *(_DWORD *)(v1 + 8);
}

_DWORD *NWBrowser.Descriptor.Options.scope.setter(_DWORD *result)
{
  *(_DWORD *)(v1 + 8) = *result;
  return result;
}

uint64_t (*NWBrowser.Descriptor.Options.scope.modify())()
{
  return nullsub_1;
}

void NWBrowser.Descriptor.Options.deviceTypes.getter(_DWORD *a1@<X8>)
{
  *a1 = *(_DWORD *)(v1 + 12);
}

_DWORD *NWBrowser.Descriptor.Options.deviceTypes.setter(_DWORD *result)
{
  *(_DWORD *)(v1 + 12) = *result;
  return result;
}

uint64_t (*NWBrowser.Descriptor.Options.deviceTypes.modify())()
{
  return nullsub_1;
}

uint64_t NWBrowser.Descriptor.Options.applicationServiceEndpointsOnly.getter()
{
  return *(unsigned __int8 *)(v0 + 16);
}

uint64_t NWBrowser.Descriptor.Options.applicationServiceEndpointsOnly.setter(uint64_t result)
{
  *(unsigned char *)(v1 + 16) = result;
  return result;
}

uint64_t (*NWBrowser.Descriptor.Options.applicationServiceEndpointsOnly.modify())()
{
  return nullsub_1;
}

NSObject *NWBrowser.Descriptor.nw.getter()
{
  uint64_t v1 = *(void *)(v0 + 16);
  uint64_t v2 = *(void *)(v0 + 24);
  unsigned int v3 = *(unsigned __int8 *)(v0 + 32);
  switch(v3 >> 5)
  {
    case 1u:
      int v6 = (const char *)(sub_183D44BAC() + 32);
      if (v2) {
        int v7 = (const char *)(sub_183D44BAC() + 32);
      }
      else {
        int v7 = 0;
      }
      bonjour_service = nw_browse_descriptor_create_bonjour_service(v6, v7);
      swift_release();
      swift_unknownObjectRelease();
      nw_browse_descriptor_set_include_txt_record(bonjour_service, 1);
      goto LABEL_17;
    case 2u:
      uint64_t v8 = sub_183D44BAC();
      bonjour_service = nw_browse_descriptor_create_application_service((const char *)(v8 + 32));
      swift_release();
      goto LABEL_17;
    case 3u:
      uint64_t v10 = sub_183D44BAC();
      bonjour_service = nw_browse_descriptor_create_application_service((const char *)(v10 + 32));
      swift_release();
      int v11 = (void *)swift_unknownObjectRetain();
      nw_browse_descriptor_set_browse_scope(v11, v2);
      nw_browse_descriptor_set_device_types(bonjour_service, SHIDWORD(v2));
      uint64_t v12 = *(void *)(v1 + 16);
      if (v12)
      {
        swift_bridgeObjectRetain();
        uint64_t v13 = v1 + 40;
        do
        {
          uint64_t v14 = sub_183D44BAC();
          nw_browse_descriptor_add_device_filter(bonjour_service, v14 + 32);
          swift_release();
          v13 += 16;
          --v12;
        }
        while (v12);
        swift_bridgeObjectRelease();
      }
      nw_browse_descriptor_set_discover_application_service_endpoints_only(bonjour_service, v3 & 1);
      swift_unknownObjectRelease();
      goto LABEL_17;
    case 4u:
      uint64_t v15 = sub_183D44BAC();
      bonjour_service = nw_browse_descriptor_create_application_service((const char *)(v15 + 32));
      swift_release();
      nw_browse_descriptor_set_invitation_scope(bonjour_service, v1 + 1);
LABEL_17:
      uint64_t result = bonjour_service;
      break;
    default:
      int v4 = (const char *)(sub_183D44BAC() + 32);
      if (v2) {
        int v5 = (const char *)(sub_183D44BAC() + 32);
      }
      else {
        int v5 = 0;
      }
      nw_browse_descriptor_t v16 = nw_browse_descriptor_create_bonjour_service(v4, v5);
      swift_release();
      swift_unknownObjectRelease();
      uint64_t result = v16;
      break;
  }
  return result;
}

uint64_t NWBrowser.Descriptor.init(_:)@<X0>(NSObject *a1@<X0>, uint64_t a2@<X8>)
{
  int type = nw_browse_descriptor_get_type(a1);
  if (type == 2)
  {
    application_service_name = nw_browse_descriptor_get_application_service_name(a1);
    if (!application_service_name) {
      goto LABEL_8;
    }
    uint64_t v12 = (uint64_t)application_service_name;
    uint64_t v13 = nw_browse_descriptor_get_invitation_scope(a1) - 1;
    if (v13 < 3)
    {
      uint64_t v14 = sub_183D44C9C();
      uint64_t v16 = v15;
      uint64_t result = swift_unknownObjectRelease();
      *(void *)a2 = v14;
      *(void *)(a2 + 8) = v16;
      *(void *)(a2 + 16) = v13;
      *(void *)(a2 + 24) = 0;
      char v18 = 0x80;
      goto LABEL_18;
    }
    unsigned int browse_scope = nw_browse_descriptor_get_browse_scope(a1);
    uint64_t device_types = nw_browse_descriptor_get_device_types(a1);
    uint64_t v29 = MEMORY[0x1E4FBC860];
    uint64_t v22 = swift_allocObject();
    *(void *)(v22 + 16) = &v29;
    uint64_t v23 = swift_allocObject();
    *(void *)(v23 + 16) = sub_1834AEF48;
    *(void *)(v23 + 24) = v22;
    void aBlock[4] = sub_1834C4608;
    aBlock[5] = v23;
    aBlock[0] = MEMORY[0x1E4F143A8];
    aBlock[1] = 1107296256;
    aBlock[2] = sub_1834BFC00;
    aBlock[3] = &block_descriptor_18;
    unint64_t v24 = _Block_copy(aBlock);
    swift_retain();
    swift_release();
    nw_browse_descriptor_enumerate_device_filters(a1, v24);
    _Block_release(v24);
    uint64_t isEscapingClosureAtFileLocation = swift_isEscapingClosureAtFileLocation();
    swift_release();
    if (isEscapingClosureAtFileLocation)
    {
      __break(1u);
    }
    else
    {
      uint64_t v12 = sub_183D44C9C();
      uint64_t v23 = v26;
      uint64_t isEscapingClosureAtFileLocation = v29;
      uint64_t v27 = qword_1E8F619D8;
      swift_bridgeObjectRetain();
      if (v27 == -1)
      {
LABEL_15:
        if (qword_1E8F61AB0 != -1) {
          swift_once();
        }
        swift_unknownObjectRelease();
        swift_release();
        uint64_t result = swift_bridgeObjectRelease();
        *(void *)a2 = v12;
        *(void *)(a2 + 8) = v23;
        *(void *)(a2 + 16) = isEscapingClosureAtFileLocation;
        *(void *)(a2 + 24) = browse_scope | (unint64_t)(device_types << 32);
        char v18 = 96;
        goto LABEL_18;
      }
    }
    swift_once();
    goto LABEL_15;
  }
  if (type != 1)
  {
LABEL_8:
    uint64_t result = swift_unknownObjectRelease();
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    char v18 = -2;
    goto LABEL_18;
  }
  nw_browse_descriptor_get_bonjour_service_type(a1);
  uint64_t v5 = sub_183D44C9C();
  uint64_t v7 = v6;
  if (nw_browse_descriptor_get_bonjour_service_domain(a1))
  {
    uint64_t v8 = sub_183D44C9C();
    unint64_t v10 = v9;
  }
  else
  {
    uint64_t v8 = 0;
    unint64_t v10 = 0xE000000000000000;
  }
  BOOL include_txt_record = nw_browse_descriptor_get_include_txt_record(a1);
  uint64_t result = swift_unknownObjectRelease();
  *(void *)a2 = v5;
  *(void *)(a2 + 8) = v7;
  *(void *)(a2 + 16) = v8;
  *(void *)(a2 + 24) = v10;
  if (!include_txt_record)
  {
    *(unsigned char *)(a2 + 32) = 0;
    return result;
  }
  char v18 = 32;
LABEL_18:
  *(unsigned char *)(a2 + 32) = v18;
  return result;
}

uint64_t sub_1834C0D98@<X0>(NSObject *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName(qword_1EB266A50);
  MEMORY[0x1F4188790](v4 - 8);
  uint64_t v6 = (char *)&v27 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = (int *)type metadata accessor for NWBrowser.Result(0);
  MEMORY[0x1F4188790](v7);
  unint64_t v10 = (NSObject **)((char *)&v27 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0));
  if (a1)
  {
    uint64_t v27 = v8;
    void *v10 = a1;
    int v11 = (void *)swift_unknownObjectRetain_n();
    endpoint = nw_browse_result_get_endpoint(v11);
    sub_18315A830(endpoint, (uint64_t)v6);
    uint64_t v13 = type metadata accessor for NWEndpoint();
    uint64_t result = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(v13 - 8) + 48))(v6, 1, v13);
    if (result != 1)
    {
      sub_1834C81A0((uint64_t)v6, (uint64_t)v10 + v7[5], (uint64_t (*)(void))type metadata accessor for NWEndpoint);
      uint64_t v34 = MEMORY[0x1E4FBC860];
      uint64_t v15 = swift_allocObject();
      *(void *)(v15 + 16) = &v34;
      uint64_t v16 = swift_allocObject();
      *(void *)(v16 + 16) = sub_1832FF1BC;
      *(void *)(v16 + 24) = v15;
      uint64_t v32 = sub_1832FF15C;
      uint64_t v33 = v16;
      uint64_t aBlock = MEMORY[0x1E4F143A8];
      uint64_t v29 = 1107296256;
      uint64_t v30 = sub_1832FF10C;
      uint64_t v31 = &block_descriptor_82;
      uint64_t v17 = _Block_copy(&aBlock);
      swift_retain();
      swift_release();
      nw_browse_result_enumerate_interfaces(a1, v17);
      _Block_release(v17);
      LOBYTE(v17) = swift_isEscapingClosureAtFileLocation();
      uint64_t result = swift_release();
      if ((v17 & 1) == 0)
      {
        *(NSObject **)((char *)v10 + v7[6]) = v34;
        swift_bridgeObjectRetain();
        nw_txt_record_t v18 = nw_browse_result_copy_txt_record_object(a1);
        if (v18)
        {
          CFIndex v19 = v18;
          uint64_t v20 = swift_allocObject();
          *(void *)(v20 + 16) = MEMORY[0x1E4FBC868];
          uint64_t v21 = (uint64_t *)(v20 + 16);
          uint64_t v32 = sub_1834CCA38;
          uint64_t v33 = v20;
          uint64_t aBlock = MEMORY[0x1E4F143A8];
          uint64_t v29 = 1107296256;
          uint64_t v30 = sub_183597F24;
          uint64_t v31 = &block_descriptor_88;
          uint64_t v22 = _Block_copy(&aBlock);
          swift_retain();
          swift_release();
          nw_txt_record_apply(v19, v22);
          _Block_release(v22);
          swift_beginAccess();
          uint64_t v23 = *v21;
          swift_bridgeObjectRetain();
          swift_unknownObjectRelease_n();
          swift_release();
          unint64_t v24 = (NSObject **)((char *)v10 + v7[7]);
          void *v24 = v23;
          v24[1] = v19;
        }
        else
        {
          swift_unknownObjectRelease_n();
          uint64_t v26 = (NSObject **)((char *)v10 + v7[7]);
          *uint64_t v26 = 0;
          v26[1] = 0;
        }
        swift_bridgeObjectRelease();
        sub_1834C81A0((uint64_t)v10, a2, type metadata accessor for NWBrowser.Result);
        (*(void (**)(uint64_t, void, uint64_t, int *))(v27 + 56))(a2, 0, 1, v7);
        return swift_release();
      }
      __break(1u);
    }
    __break(1u);
    return result;
  }
  unint64_t v25 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int *))(v8 + 56);

  return v25(a2, 1, 1, v7);
}

uint64_t NWBrowser.Result.endpoint.getter@<X0>(uint64_t a1@<X8>)
{
  uint64_t v3 = type metadata accessor for NWBrowser.Result(0);
  return sub_18315E6C0(v1 + *(int *)(v3 + 20), a1, (uint64_t (*)(void))type metadata accessor for NWEndpoint);
}

uint64_t NWBrowser.Result.interfaces.getter()
{
  type metadata accessor for NWBrowser.Result(0);

  return swift_bridgeObjectRetain();
}

uint64_t NWBrowser.Result.metadata.getter@<X0>(uint64_t *a1@<X8>)
{
  uint64_t v3 = (uint64_t *)(v1 + *(int *)(type metadata accessor for NWBrowser.Result(0) + 28));
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  *a1 = *v3;
  a1[1] = v5;

  return sub_1834C4654(v4);
}

uint64_t NWBrowser.Result.Metadata.debugDescription.getter()
{
  uint64_t v1 = *v0;
  if (!*v0) {
    return 0x3E656E6F6E3CLL;
  }
  uint64_t v5 = MEMORY[0x1E4FBC868];
  sub_1834C4654(v1);
  sub_1834C4654(v1);
  uint64_t v2 = swift_bridgeObjectRetain();
  sub_1834C3DA8(v2, &v5);
  swift_bridgeObjectRelease();
  uint64_t v3 = sub_183D44A4C();
  swift_bridgeObjectRelease();
  sub_1834C80D8(v1);
  sub_1834C80D8(v1);
  return v3;
}

void NWBrowser.Result.hash(into:)()
{
}

uint64_t NWBrowser.Result.Change.Flags.rawValue.getter()
{
  return *v0;
}

uint64_t NWBrowser.Result.Change.Flags.init(rawValue:)@<X0>(uint64_t result@<X0>, unsigned char *a2@<X8>)
{
  *a2 = result;
  return result;
}

void static NWBrowser.Result.Change.Flags.identical.getter(unsigned char *a1@<X8>)
{
  *a1 = 1;
}

void static NWBrowser.Result.Change.Flags.interfaceAdded.getter(unsigned char *a1@<X8>)
{
  *a1 = 2;
}

void static NWBrowser.Result.Change.Flags.interfaceRemoved.getter(unsigned char *a1@<X8>)
{
  *a1 = 4;
}

void static NWBrowser.Result.Change.Flags.metadataChanged.getter(unsigned char *a1@<X8>)
{
  *a1 = 8;
}

unsigned char *sub_1834C1458@<X0>(unsigned char *result@<X0>, unsigned char *a2@<X8>)
{
  *a2 = *result;
  return result;
}

uint64_t sub_1834C1464()
{
  return sub_183D45B4C();
}

uint64_t sub_1834C14AC()
{
  return sub_183D45B1C();
}

uint64_t sub_1834C14D8()
{
  return sub_183D45B4C();
}

void sub_1834C151C(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

unsigned char *sub_1834C1524@<X0>(unsigned char *result@<X0>, unsigned char *a2@<X8>)
{
  *a2 = *v2 | *result;
  return result;
}

unsigned char *sub_1834C1538@<X0>(unsigned char *result@<X0>, unsigned char *a2@<X8>)
{
  *a2 = *v2 & *result;
  return result;
}

unsigned char *sub_1834C154C@<X0>(unsigned char *result@<X0>, unsigned char *a2@<X8>)
{
  *a2 = *v2 ^ *result;
  return result;
}

BOOL sub_1834C1560(unsigned char *a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  int v4 = *v2;
  if ((v4 & v3) != v3) {
    unsigned char *v2 = v4 | v3;
  }
  *a1 = v3;
  return (v4 & v3) != v3;
}

unsigned __int8 *sub_1834C1590@<X0>(unsigned __int8 *result@<X0>, unsigned char *a2@<X8>)
{
  int v3 = *result;
  int v4 = *v2;
  int v5 = v4 & v3;
  if ((v4 & v3) != 0) {
    unsigned char *v2 = v4 & ~(_BYTE)v3;
  }
  *a2 = v5;
  a2[1] = v5 == 0;
  return result;
}

unsigned __int8 *sub_1834C15BC@<X0>(unsigned __int8 *result@<X0>, unsigned char *a2@<X8>)
{
  int v3 = *result;
  int v4 = *v2;
  unsigned char *v2 = v4 | v3;
  int v5 = v4 & v3;
  *a2 = v5;
  a2[1] = v5 == 0;
  return result;
}

unsigned char *sub_1834C15E0(unsigned char *result)
{
  *v1 |= *result;
  return result;
}

unsigned char *sub_1834C15F4(unsigned char *result)
{
  *v1 &= *result;
  return result;
}

unsigned char *sub_1834C1608(unsigned char *result)
{
  *v1 ^= *result;
  return result;
}

unsigned char *sub_1834C161C@<X0>(unsigned char *result@<X0>, unsigned char *a2@<X8>)
{
  *a2 = *v2 & ~*result;
  return result;
}

BOOL sub_1834C1630(unsigned __int8 *a1)
{
  return (*v1 & ~*a1) == 0;
}

BOOL sub_1834C1644(unsigned char *a1)
{
  return (*v1 & *a1) == 0;
}

BOOL sub_1834C1658(unsigned __int8 *a1)
{
  return (*a1 & ~*v1) == 0;
}

BOOL sub_1834C166C()
{
  return *v0 == 0;
}

unsigned char *sub_1834C167C(unsigned char *result)
{
  *v1 &= ~*result;
  return result;
}

unsigned __int8 *sub_1834C1690@<X0>(unsigned __int8 *result@<X0>, _WORD *a2@<X8>)
{
  *a2 = *result;
  return result;
}

void sub_1834C16A0(unsigned char *a1@<X8>)
{
  *a1 = *v1;
}

BOOL sub_1834C16AC(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 == *a2;
}

uint64_t NWBrowser.Result.Change.init(between:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v54 = a2;
  uint64_t v52 = a3;
  uint64_t v51 = type metadata accessor for NWBrowser.Result.Change(0);
  uint64_t v4 = MEMORY[0x1F4188790](v51);
  uint64_t v49 = (uint64_t)&v47 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v6 = MEMORY[0x1F4188790](v4);
  uint64_t v50 = (uint64_t)&v47 - v7;
  MEMORY[0x1F4188790](v6);
  uint64_t v9 = (char *)&v47 - v8;
  uint64_t v10 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F61B08);
  uint64_t v11 = MEMORY[0x1F4188790](v10 - 8);
  uint64_t v48 = (uint64_t)&v47 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (NSObject **)((char *)&v47 - v14);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  nw_txt_record_t v18 = (NSObject **)((char *)&v47 - v17);
  uint64_t v19 = MEMORY[0x1F4188790](v16);
  uint64_t v21 = (NSObject **)((char *)&v47 - v20);
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  unint64_t v24 = (NSObject **)((char *)&v47 - v23);
  MEMORY[0x1F4188790](v22);
  uint64_t v26 = (NSObject **)((char *)&v47 - v25);
  uint64_t v53 = a1;
  sub_1834C8138(a1, (uint64_t)&v47 - v25);
  uint64_t v27 = type metadata accessor for NWBrowser.Result(0);
  CFURLRef v28 = *(unsigned int (**)(NSObject **, uint64_t, uint64_t))(*(void *)(v27 - 8) + 48);
  if (v28(v26, 1, v27) == 1)
  {
    sub_183138A24((uint64_t)v26, &qword_1E8F61B08);
    uint64_t v29 = 0;
  }
  else
  {
    uint64_t v29 = *v26;
    swift_unknownObjectRetain();
    sub_1834C94F4((uint64_t)v26, type metadata accessor for NWBrowser.Result);
  }
  sub_1834C8138(v54, (uint64_t)v24);
  if (v28(v24, 1, v27) == 1)
  {
    sub_183138A24((uint64_t)v24, &qword_1E8F61B08);
    uint64_t v30 = 0;
  }
  else
  {
    uint64_t v30 = *v24;
    swift_unknownObjectRetain();
    sub_1834C94F4((uint64_t)v24, type metadata accessor for NWBrowser.Result);
  }
  nw_browse_result_change_t changes = nw_browse_result_get_changes(v29, v30);
  swift_unknownObjectRelease();
  swift_unknownObjectRelease();
  if ((changes & 0x8000000000000000) != 0)
  {
    __break(1u);
LABEL_23:
    __break(1u);
LABEL_24:
    __break(1u);
LABEL_25:
    __break(1u);
LABEL_26:
    __break(1u);
    JUMPOUT(0x1834C1C88);
  }
  switch(changes)
  {
    case 0uLL:
    case 1uLL:
      sub_183138A24(v54, &qword_1E8F61B08);
      sub_183138A24(v53, &qword_1E8F61B08);
      return swift_storeEnumTagMultiPayload();
    case 2uLL:
      uint64_t v33 = v54;
      sub_1834C8138(v54, (uint64_t)v21);
      if (v28(v21, 1, v27) == 1) {
        goto LABEL_23;
      }
      sub_183138A24(v33, &qword_1E8F61B08);
      sub_183138A24(v53, &qword_1E8F61B08);
      sub_1834C81A0((uint64_t)v21, (uint64_t)v9, type metadata accessor for NWBrowser.Result);
      swift_storeEnumTagMultiPayload();
      uint64_t v34 = (uint64_t)v9;
      return sub_1834C81A0(v34, v52, type metadata accessor for NWBrowser.Result.Change);
    case 4uLL:
      uint64_t v45 = v53;
      sub_1834C8138(v53, (uint64_t)v18);
      if (v28(v18, 1, v27) == 1) {
        goto LABEL_26;
      }
      sub_183138A24(v54, &qword_1E8F61B08);
      sub_183138A24(v45, &qword_1E8F61B08);
      uint64_t v46 = v50;
      sub_1834C81A0((uint64_t)v18, v50, type metadata accessor for NWBrowser.Result);
      swift_storeEnumTagMultiPayload();
      uint64_t v34 = v46;
      return sub_1834C81A0(v34, v52, type metadata accessor for NWBrowser.Result.Change);
    default:
      unsigned int v35 = (changes >> 2) & 0xE;
      if (v35) {
        char v36 = v35;
      }
      else {
        char v36 = 1;
      }
      uint64_t v37 = v53;
      sub_1834C8138(v53, (uint64_t)v15);
      if (v28(v15, 1, v27) == 1) {
        goto LABEL_24;
      }
      uint64_t v38 = (uint64_t)v15;
      uint64_t v39 = v49;
      sub_1834C81A0(v38, v49, type metadata accessor for NWBrowser.Result);
      uint64_t v40 = v54;
      uint64_t v41 = v48;
      sub_1834C8138(v54, v48);
      if (v28((NSObject **)v41, 1, v27) == 1) {
        goto LABEL_25;
      }
      uint64_t v42 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F619E0);
      uint64_t v43 = v39 + *(int *)(v42 + 48);
      uint64_t v44 = *(int *)(v42 + 64);
      sub_183138A24(v40, &qword_1E8F61B08);
      sub_183138A24(v37, &qword_1E8F61B08);
      sub_1834C81A0(v41, v43, type metadata accessor for NWBrowser.Result);
      *(unsigned char *)(v39 + v44) = v36;
      swift_storeEnumTagMultiPayload();
      uint64_t v34 = v39;
      return sub_1834C81A0(v34, v52, type metadata accessor for NWBrowser.Result.Change);
  }
}

uint64_t NWBrowser.Result.Change.hash(into:)()
{
  uint64_t v1 = v0;
  uint64_t v2 = type metadata accessor for NWBrowser.Result(0);
  uint64_t v3 = MEMORY[0x1F4188790](v2);
  uint64_t v5 = (char *)&v14 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v3);
  uint64_t v7 = (char *)&v14 - v6;
  uint64_t v8 = type metadata accessor for NWBrowser.Result.Change(0);
  MEMORY[0x1F4188790](v8);
  uint64_t v10 = (char *)&v14 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_18315E6C0(v1, (uint64_t)v10, type metadata accessor for NWBrowser.Result.Change);
  switch(swift_getEnumCaseMultiPayload())
  {
    case 2u:
      uint64_t v11 = (uint64_t)&v10[*(int *)(__swift_instantiateConcreteTypeFromMangledName(&qword_1E8F619E0) + 48)];
      sub_1834C81A0((uint64_t)v10, (uint64_t)v7, type metadata accessor for NWBrowser.Result);
      sub_1834C81A0(v11, (uint64_t)v5, type metadata accessor for NWBrowser.Result);
      sub_183D45B0C();
      NWEndpoint.hash(into:)();
      NWEndpoint.hash(into:)();
      sub_183D45B1C();
      sub_1834C94F4((uint64_t)v5, type metadata accessor for NWBrowser.Result);
      uint64_t v12 = (uint64_t)v7;
      goto LABEL_5;
    case 3u:
      uint64_t result = sub_183D45B0C();
      break;
    default:
      sub_1834C81A0((uint64_t)v10, (uint64_t)v7, type metadata accessor for NWBrowser.Result);
      sub_183D45B0C();
      NWEndpoint.hash(into:)();
      uint64_t v12 = (uint64_t)v7;
LABEL_5:
      uint64_t result = sub_1834C94F4(v12, type metadata accessor for NWBrowser.Result);
      break;
  }
  return result;
}

uint64_t NWBrowser.Result.Change.hashValue.getter()
{
  return sub_183D45B4C();
}

uint64_t sub_1834C1F78()
{
  return sub_183D45B4C();
}

uint64_t sub_1834C1FBC()
{
  return sub_183D45B4C();
}

uint64_t NWBrowser.Result.hashValue.getter()
{
  return sub_183D45B4C();
}

uint64_t sub_1834C204C()
{
  return sub_183D45B4C();
}

void sub_1834C2098()
{
}

uint64_t sub_1834C20C0()
{
  return sub_183D45B4C();
}

uint64_t sub_1834C210C@<X0>(nw_error_t error@<X1>, int a2@<W0>, uint64_t a3@<X8>)
{
  switch(a2)
  {
    case 0:
      uint64_t result = swift_unknownObjectRelease();
      uint64_t v6 = 0x8000000000;
      break;
    case 1:
      uint64_t result = swift_unknownObjectRelease();
      uint64_t v6 = 0x8000000001;
      break;
    case 2:
      if (!error) {
        goto LABEL_28;
      }
      nw_error_domain_t error_domain = nw_error_get_error_domain(error);
      switch(error_domain)
      {
        case nw_error_domain_tls:
          unsigned int error_code = nw_error_get_error_code(error);
          uint64_t result = swift_unknownObjectRelease();
          uint64_t v6 = error_code | 0x200000000;
          break;
        case nw_error_domain_dns:
          unsigned int v12 = nw_error_get_error_code(error);
          uint64_t result = swift_unknownObjectRelease();
          uint64_t v6 = v12 | 0x100000000;
          break;
        case nw_error_domain_posix:
          nw_error_get_error_code(error);
          uint64_t v6 = sub_183D449AC();
          uint64_t result = swift_unknownObjectRelease();
          if ((v6 & 0x100000000) != 0) {
            uint64_t v6 = 22;
          }
          else {
            uint64_t v6 = v6;
          }
          break;
        default:
          uint64_t result = swift_unknownObjectRelease();
          uint64_t v6 = 22;
          break;
      }
      break;
    case 4:
      if (!error)
      {
        __break(1u);
LABEL_28:
        __break(1u);
        JUMPOUT(0x1834C22F8);
      }
      nw_error_domain_t v7 = nw_error_get_error_domain(error);
      switch(v7)
      {
        case nw_error_domain_tls:
          unsigned int v10 = nw_error_get_error_code(error);
          uint64_t result = swift_unknownObjectRelease();
          uint64_t v6 = v10 | 0x4200000000;
          break;
        case nw_error_domain_dns:
          unsigned int v11 = nw_error_get_error_code(error);
          uint64_t result = swift_unknownObjectRelease();
          uint64_t v6 = v11 | 0x4100000000;
          break;
        case nw_error_domain_posix:
          nw_error_get_error_code(error);
          uint64_t v8 = sub_183D449AC();
          uint64_t result = swift_unknownObjectRelease();
          if ((v8 & 0x100000000) != 0) {
            uint64_t v6 = 0x4000000016;
          }
          else {
            uint64_t v6 = v8 | 0x4000000000;
          }
          break;
        default:
          uint64_t v6 = 0x4000000016;
LABEL_4:
          uint64_t result = swift_unknownObjectRelease();
          break;
      }
      break;
    default:
      uint64_t v6 = 0x8000000002;
      goto LABEL_4;
  }
  *(_DWORD *)a3 = v6;
  *(unsigned char *)(a3 + 4) = BYTE4(v6);
  return result;
}

Network::NWBrowser::Invitation::Scope_optional __swiftcall NWBrowser.Invitation.Scope.init(rawValue:)(Swift::String rawValue)
{
  uint64_t v2 = v1;
  unint64_t v3 = sub_183D4575C();
  result.unint64_t value = swift_bridgeObjectRelease();
  char v5 = 3;
  if (v3 < 3) {
    char v5 = v3;
  }
  char *v2 = v5;
  return result;
}

uint64_t NWBrowser.Invitation.Scope.rawValue.getter()
{
  uint64_t v1 = 0x73646E65697266;
  if (*v0 != 1) {
    uint64_t v1 = 0x656E6F7972657665;
  }
  if (*v0) {
    return v1;
  }
  else {
    return 0x74696D69786F7270;
  }
}

uint64_t sub_1834C23D0(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return sub_1835C0E4C(*a1, *a2);
}

uint64_t sub_1834C23DC()
{
  return sub_183D45B4C();
}

uint64_t sub_1834C2484()
{
  sub_183D44C4C();

  return swift_bridgeObjectRelease();
}

uint64_t sub_1834C2518()
{
  return sub_183D45B4C();
}

Network::NWBrowser::Invitation::Scope_optional sub_1834C25BC(Swift::String *a1)
{
  return NWBrowser.Invitation.Scope.init(rawValue:)(*a1);
}

void sub_1834C25C8(uint64_t *a1@<X8>)
{
  int v2 = *v1;
  unint64_t v3 = 0xE900000000000079;
  unint64_t v4 = 0xE700000000000000;
  uint64_t v5 = 0x73646E65697266;
  if (v2 != 1)
  {
    uint64_t v5 = 0x656E6F7972657665;
    unint64_t v4 = 0xE800000000000000;
  }
  BOOL v6 = v2 == 0;
  if (*v1) {
    uint64_t v7 = v5;
  }
  else {
    uint64_t v7 = 0x74696D69786F7270;
  }
  if (!v6) {
    unint64_t v3 = v4;
  }
  *a1 = v7;
  a1[1] = v3;
}

void NWBrowser.Invitation.scope.getter(unsigned char *a1@<X8>)
{
  *a1 = *v1;
}

unsigned char *static NWBrowser.Invitation.wrangler(scope:)@<X0>(unsigned char *result@<X0>, unsigned char *a2@<X8>)
{
  *a2 = *result;
  return result;
}

uint64_t NWBrowser.descriptor.getter@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = *(void *)(v1 + 32);
  uint64_t v3 = *(void *)(v1 + 40);
  uint64_t v4 = *(void *)(v1 + 48);
  uint64_t v5 = *(void *)(v1 + 56);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v3;
  *(void *)(a1 + 16) = v4;
  *(void *)(a1 + 24) = v5;
  unsigned __int8 v6 = *(unsigned char *)(v1 + 64);
  *(unsigned char *)(a1 + 32) = v6;
  return sub_1834C8208(v2, v3, v4, v5, v6);
}

uint64_t NWBrowser.parameters.getter()
{
  return swift_retain();
}

uint64_t NWBrowser.state.getter@<X0>(uint64_t a1@<X8>)
{
  v16[1] = *MEMORY[0x1E4F143B8];
  v16[0] = 0;
  int state = nw_browser_get_state(*(void **)(v1 + 16), (uint64_t)v16);
  uint64_t v4 = v16[0];
  switch(state)
  {
    case 0:
      uint64_t result = swift_unknownObjectRelease();
      uint64_t v6 = 0x8000000000;
      break;
    case 1:
      uint64_t result = swift_unknownObjectRelease();
      uint64_t v6 = 0x8000000001;
      break;
    case 2:
      if (!v16[0]) {
        goto LABEL_27;
      }
      unsigned int v10 = swift_unknownObjectRetain();
      nw_error_domain_t error_domain = nw_error_get_error_domain(v10);
      switch(error_domain)
      {
        case nw_error_domain_tls:
          unsigned int error_code = nw_error_get_error_code(v4);
          uint64_t result = swift_unknownObjectRelease_n();
          uint64_t v6 = error_code | 0x200000000;
          break;
        case nw_error_domain_dns:
          unsigned int v14 = nw_error_get_error_code(v4);
          uint64_t result = swift_unknownObjectRelease_n();
          uint64_t v6 = v14 | 0x100000000;
          break;
        case nw_error_domain_posix:
          nw_error_get_error_code(v4);
          uint64_t v6 = sub_183D449AC();
          uint64_t result = swift_unknownObjectRelease_n();
          if ((v6 & 0x100000000) != 0) {
            uint64_t v6 = 22;
          }
          else {
            uint64_t v6 = v6;
          }
          break;
        default:
          uint64_t result = swift_unknownObjectRelease_n();
          uint64_t v6 = 22;
          break;
      }
      break;
    case 4:
      if (!v16[0])
      {
        __break(1u);
LABEL_27:
        __break(1u);
        JUMPOUT(0x1834C28C8);
      }
      uint64_t v7 = swift_unknownObjectRetain();
      nw_error_domain_t v8 = nw_error_get_error_domain(v7);
      switch(v8)
      {
        case nw_error_domain_posix:
          nw_error_get_error_code(v4);
          uint64_t v12 = sub_183D449AC();
          uint64_t result = swift_unknownObjectRelease_n();
          if ((v12 & 0x100000000) != 0) {
            uint64_t v6 = 0x4000000016;
          }
          else {
            uint64_t v6 = v12 | 0x4000000000;
          }
          break;
        case nw_error_domain_dns:
          unsigned int v13 = nw_error_get_error_code(v4);
          uint64_t result = swift_unknownObjectRelease_n();
          uint64_t v6 = v13 | 0x4100000000;
          break;
        case nw_error_domain_tls:
          unsigned int v9 = nw_error_get_error_code(v4);
          uint64_t result = swift_unknownObjectRelease_n();
          uint64_t v6 = v9 | 0x4200000000;
          break;
        default:
          uint64_t v6 = 0x4000000016;
          uint64_t result = swift_unknownObjectRelease_n();
          break;
      }
      break;
    default:
      uint64_t v6 = 0x8000000002;
      uint64_t result = swift_unknownObjectRelease();
      break;
  }
  *(_DWORD *)a1 = v6;
  *(unsigned char *)(a1 + 4) = BYTE4(v6);
  return result;
}

uint64_t NWBrowser.browseResults.getter()
{
  uint64_t v1 = *(os_unfair_lock_s **)(v0 + 24);
  uint64_t v2 = v1 + 4;
  uint64_t v3 = v1 + 20;
  os_unfair_lock_lock(v1 + 20);
  sub_1834C293C(v2, &v5);
  os_unfair_lock_unlock(v3);
  return v5;
}

uint64_t sub_1834C293C@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  *a2 = *a1;
  return swift_bridgeObjectRetain();
}

uint64_t NWBrowser.queue.getter()
{
  uint64_t v1 = *(os_unfair_lock_s **)(v0 + 24);
  uint64_t v2 = (uint64_t)&v1[4];
  uint64_t v3 = v1 + 20;
  os_unfair_lock_lock(v1 + 20);
  sub_1834C29BC(v2, &v5);
  os_unfair_lock_unlock(v3);
  return v5;
}

id sub_1834C29BC@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void **)(a1 + 56);
  *a2 = v2;
  return v2;
}

uint64_t (*NWBrowser.stateUpdateHandler.getter())()
{
  uint64_t v1 = *(os_unfair_lock_s **)(v0 + 24);
  uint64_t v2 = (uint64_t)&v1[4];
  uint64_t v3 = v1 + 20;
  os_unfair_lock_lock(v1 + 20);
  sub_1834C2C04(v2, (uint64_t (**)())&v6);
  os_unfair_lock_unlock(v3);
  if (!(void)v6) {
    return 0;
  }
  long long v5 = v6;
  *(_OWORD *)(swift_allocObject() + 16) = v5;
  return sub_18313D738;
}

double sub_1834C2A98@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  uint64_t v3 = *(os_unfair_lock_s **)(*(void *)a1 + 24);
  uint64_t v4 = (uint64_t)&v3[4];
  long long v5 = v3 + 20;
  os_unfair_lock_lock(v3 + 20);
  sub_1834C2C04(v4, (uint64_t (**)())&v7);
  os_unfair_lock_unlock(v5);
  double result = *(double *)&v7;
  *a2 = v7;
  return result;
}

void sub_1834C2B04(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = a1[1];
  if (*a1)
  {
    uint64_t v3 = swift_allocObject();
    *(void *)(v3 + 16) = v1;
    *(void *)(v3 + 24) = v2;
    uint64_t v4 = sub_1834CCB54;
  }
  else
  {
    uint64_t v4 = 0;
    uint64_t v3 = 0;
  }
  sub_18315ED5C(v1);
  NWBrowser.stateUpdateHandler.setter((uint64_t)v4, v3);
}

uint64_t sub_1834C2B94(uint64_t a1, uint64_t a2, uint64_t a3)
{
  long long v5 = *(void (**)(uint64_t, uint64_t))(a1 + 32);
  swift_retain();
  swift_unknownObjectRetain();
  v5(a2, a3);
  swift_release();

  return swift_unknownObjectRelease();
}

uint64_t sub_1834C2C04@<X0>(uint64_t a1@<X0>, uint64_t (**a2)()@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 32);
  if (v3)
  {
    uint64_t v5 = swift_allocObject();
    *(void *)(v5 + 16) = v3;
    *(void *)(v5 + 24) = v4;
    long long v6 = sub_18313D760;
  }
  else
  {
    long long v6 = 0;
    uint64_t v5 = 0;
  }
  *a2 = v6;
  a2[1] = (uint64_t (*)())v5;
  return sub_18315ED5C(v3);
}

uint64_t (*NWBrowser.stateUpdateHandler.modify(uint64_t (**a1)()))(uint64_t *a1, char a2)
{
  a1[2] = (uint64_t (*)())v1;
  uint64_t v3 = *(os_unfair_lock_s **)(v1 + 24);
  uint64_t v4 = (uint64_t)&v3[4];
  uint64_t v5 = v3 + 20;
  os_unfair_lock_lock(v3 + 20);
  sub_1834C2C04(v4, v10);
  os_unfair_lock_unlock(v5);
  if (v10[0])
  {
    long long v9 = *(_OWORD *)v10;
    uint64_t v6 = swift_allocObject();
    *(_OWORD *)(v6 + 16) = v9;
    long long v7 = sub_1834CCB54;
  }
  else
  {
    long long v7 = 0;
    uint64_t v6 = 0;
  }
  *a1 = v7;
  a1[1] = (uint64_t (*)())v6;
  return sub_1834C2D4C;
}

uint64_t sub_1834C2D4C(uint64_t *a1, char a2)
{
  return sub_1834C37F0(a1, a2, (uint64_t (*)(uint64_t, uint64_t))NWBrowser.stateUpdateHandler.setter, (void (*)(uint64_t, uint64_t))sub_18315ED5C, (uint64_t (*)(uint64_t, uint64_t))sub_18313D870);
}

uint64_t (*NWBrowser.browseResultsChangedHandler.getter())(uint64_t, uint64_t)
{
  uint64_t v1 = *(os_unfair_lock_s **)(v0 + 24);
  uint64_t v2 = (uint64_t)&v1[4];
  uint64_t v3 = v1 + 20;
  os_unfair_lock_lock(v1 + 20);
  sub_1834C3668(v2, &v6);
  os_unfair_lock_unlock(v3);
  if (!(void)v6) {
    return 0;
  }
  long long v5 = v6;
  *(_OWORD *)(swift_allocObject() + 16) = v5;
  return sub_1834C3BFC;
}

double sub_1834C2E38@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  uint64_t v3 = *(os_unfair_lock_s **)(*(void *)a1 + 24);
  uint64_t v4 = (uint64_t)&v3[4];
  long long v5 = v3 + 20;
  os_unfair_lock_lock(v3 + 20);
  sub_1834C3668(v4, &v7);
  os_unfair_lock_unlock(v5);
  double result = *(double *)&v7;
  *a2 = v7;
  return result;
}

uint64_t sub_1834C2EA4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = a1[1];
  if (*a1)
  {
    uint64_t v3 = swift_allocObject();
    *(void *)(v3 + 16) = v1;
    *(void *)(v3 + 24) = v2;
    uint64_t v4 = sub_1834C3BFC;
  }
  else
  {
    uint64_t v4 = 0;
    uint64_t v3 = 0;
  }
  sub_18315ED5C(v1);
  return NWBrowser.browseResultsChangedHandler.setter((uint64_t)v4, v3);
}

uint64_t sub_1834C2F34(uint64_t a1, uint64_t a2, char a3, uint64_t a4, void (*a5)(void, void), uint64_t a6)
{
  v30[1] = a6;
  uint64_t v9 = type metadata accessor for NWBrowser.Result.Change(0);
  MEMORY[0x1F4188790](v9 - 8);
  unsigned int v11 = (char *)v30 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F61B08);
  uint64_t v13 = MEMORY[0x1F4188790](v12 - 8);
  uint64_t v15 = (char *)v30 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  nw_txt_record_t v18 = (char *)v30 - v17;
  uint64_t v19 = MEMORY[0x1F4188790](v16);
  uint64_t v21 = (char *)v30 - v20;
  MEMORY[0x1F4188790](v19);
  uint64_t v23 = (char *)v30 - v22;
  unint64_t v24 = swift_unknownObjectRetain();
  sub_1834C0D98(v24, (uint64_t)v23);
  uint64_t v25 = swift_unknownObjectRetain();
  sub_1834C0D98(v25, (uint64_t)v21);
  sub_1834C8138((uint64_t)v23, (uint64_t)v18);
  sub_1834C8138((uint64_t)v21, (uint64_t)v15);
  NWBrowser.Result.Change.init(between:_:)((uint64_t)v18, (uint64_t)v15, (uint64_t)v11);
  uint64_t v26 = *(os_unfair_lock_s **)(a4 + 24);
  void v30[4] = v11;
  uint64_t v27 = (long long *)&v26[4];
  CFURLRef v28 = v26 + 20;
  os_unfair_lock_lock(v26 + 20);
  sub_1834CC9C4((uint64_t)v27);
  os_unfair_lock_unlock(v28);
  if (a3)
  {
    os_unfair_lock_lock(v28);
    sub_1834C35AC(v27, &v31);
    os_unfair_lock_unlock(v28);
    if (a5) {
      a5(v31, *((void *)&v31 + 1));
    }
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
  }
  sub_183138A24((uint64_t)v21, &qword_1E8F61B08);
  sub_183138A24((uint64_t)v23, &qword_1E8F61B08);
  return sub_1834C94F4((uint64_t)v11, type metadata accessor for NWBrowser.Result.Change);
}

uint64_t sub_1834C3184(uint64_t a1, uint64_t a2)
{
  uint64_t v35 = a1;
  uint64_t v3 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F61B08);
  MEMORY[0x1F4188790](v3 - 8);
  uint64_t v33 = (uint64_t)&v31 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v5 = type metadata accessor for NWBrowser.Result(0);
  uint64_t v6 = MEMORY[0x1F4188790](v5 - 8);
  uint64_t v32 = (uint64_t)&v31 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = MEMORY[0x1F4188790](v6);
  uint64_t v10 = (char *)&v31 - v9;
  uint64_t v11 = MEMORY[0x1F4188790](v8);
  uint64_t v13 = (char *)&v31 - v12;
  MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v31 - v14;
  uint64_t v16 = type metadata accessor for NWBrowser.Result.Change(0);
  uint64_t v17 = MEMORY[0x1F4188790](v16);
  uint64_t v19 = (char *)&v31 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  uint64_t v22 = (char *)&v31 - v21;
  MEMORY[0x1F4188790](v20);
  unint64_t v24 = (char *)&v31 - v23;
  uint64_t v34 = a2;
  sub_18315E6C0(a2, (uint64_t)&v31 - v23, type metadata accessor for NWBrowser.Result.Change);
  switch(swift_getEnumCaseMultiPayload())
  {
    case 1u:
      sub_1834C81A0((uint64_t)v24, (uint64_t)v15, type metadata accessor for NWBrowser.Result);
      uint64_t v26 = v33;
      sub_1834C4F78((uint64_t)v15, v33);
      sub_183138A24(v26, &qword_1E8F61B08);
      goto LABEL_6;
    case 2u:
      uint64_t v27 = (uint64_t)&v24[*(int *)(__swift_instantiateConcreteTypeFromMangledName(&qword_1E8F619E0) + 48)];
      sub_1834C81A0((uint64_t)v24, (uint64_t)v15, type metadata accessor for NWBrowser.Result);
      sub_1834C81A0(v27, (uint64_t)v13, type metadata accessor for NWBrowser.Result);
      uint64_t v28 = v33;
      sub_1834C4F78((uint64_t)v15, v33);
      sub_183138A24(v28, &qword_1E8F61B08);
      uint64_t v29 = v32;
      sub_18315E6C0((uint64_t)v13, v32, type metadata accessor for NWBrowser.Result);
      sub_1834C4918((uint64_t)v10, v29);
      sub_1834C94F4((uint64_t)v10, type metadata accessor for NWBrowser.Result);
      uint64_t v25 = (uint64_t)v13;
      goto LABEL_5;
    case 3u:
      __break(1u);
      JUMPOUT(0x1834C359CLL);
    default:
      sub_1834C81A0((uint64_t)v24, (uint64_t)v15, type metadata accessor for NWBrowser.Result);
      sub_18315E6C0((uint64_t)v15, (uint64_t)v10, type metadata accessor for NWBrowser.Result);
      sub_1834C4918((uint64_t)v13, (uint64_t)v10);
      uint64_t v25 = (uint64_t)v13;
LABEL_5:
      sub_1834C94F4(v25, type metadata accessor for NWBrowser.Result);
LABEL_6:
      sub_1834C94F4((uint64_t)v15, type metadata accessor for NWBrowser.Result);
      sub_18315E6C0(v34, (uint64_t)v19, type metadata accessor for NWBrowser.Result.Change);
      sub_1834C4694((uint64_t)v22, (uint64_t)v19);
      return sub_1834C94F4((uint64_t)v22, type metadata accessor for NWBrowser.Result.Change);
  }
}

uint64_t sub_1834C35AC@<X0>(long long *a1@<X0>, _OWORD *a2@<X8>)
{
  long long v2 = *a1;
  *((void *)a1 + 1) = MEMORY[0x1E4FBC870];
  *a2 = v2;
  return swift_bridgeObjectRetain();
}

uint64_t sub_1834C35DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 32);
  swift_retain();
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  v7(a2, a3, a4);
  swift_release();
  swift_unknownObjectRelease();

  return swift_unknownObjectRelease();
}

uint64_t sub_1834C3668@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 48);
  if (v3)
  {
    uint64_t v5 = swift_allocObject();
    *(void *)(v5 + 16) = v3;
    *(void *)(v5 + 24) = v4;
    uint64_t v6 = sub_1834CC994;
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v5 = 0;
  }
  *a2 = v6;
  a2[1] = v5;
  return sub_18315ED5C(v3);
}

uint64_t (*NWBrowser.browseResultsChangedHandler.modify(uint64_t (**a1)(uint64_t, uint64_t)))(uint64_t *a1, char a2)
{
  a1[2] = (uint64_t (*)(uint64_t, uint64_t))v1;
  uint64_t v3 = *(os_unfair_lock_s **)(v1 + 24);
  uint64_t v4 = (uint64_t)&v3[4];
  uint64_t v5 = v3 + 20;
  os_unfair_lock_lock(v3 + 20);
  sub_1834C3668(v4, &v10);
  os_unfair_lock_unlock(v5);
  if ((void)v10)
  {
    long long v9 = v10;
    uint64_t v6 = swift_allocObject();
    *(_OWORD *)(v6 + 16) = v9;
    uint64_t v7 = sub_1834C3BFC;
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t v6 = 0;
  }
  *a1 = v7;
  a1[1] = (uint64_t (*)(uint64_t, uint64_t))v6;
  return sub_1834C37B0;
}

uint64_t sub_1834C37B0(uint64_t *a1, char a2)
{
  return sub_1834C37F0(a1, a2, NWBrowser.browseResultsChangedHandler.setter, (void (*)(uint64_t, uint64_t))sub_1834CCAF0, sub_1834CCAEC);
}

uint64_t sub_1834C37F0(uint64_t *a1, char a2, uint64_t (*a3)(uint64_t, uint64_t), void (*a4)(uint64_t, uint64_t), uint64_t (*a5)(uint64_t, uint64_t))
{
  uint64_t v6 = *a1;
  uint64_t v7 = a1[1];
  if ((a2 & 1) == 0) {
    return a3(*a1, v7);
  }
  a4(*a1, v7);
  a3(v6, v7);

  return a5(v6, v7);
}

uint64_t NWBrowser.init(for:using:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = v2;
  uint64_t v5 = *(NSObject **)a1;
  uint64_t v6 = *(NSObject **)(a1 + 8);
  uint64_t v7 = *(NSObject **)(a1 + 16);
  uint64_t v8 = *(NSObject **)(a1 + 24);
  char v9 = *(unsigned char *)(a1 + 32);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_1E8F61B28);
  uint64_t v10 = swift_allocObject();
  *(_DWORD *)(v10 + 80) = 0;
  uint64_t v11 = MEMORY[0x1E4FBC870];
  *(void *)(v10 + 16) = MEMORY[0x1E4FBC870];
  *(void *)(v10 + 24) = v11;
  *(unsigned char *)(v10 + 32) = 0;
  *(_OWORD *)(v10 + 40) = 0u;
  *(_OWORD *)(v10 + 56) = 0u;
  *(void *)(v10 + 72) = 0;
  *(void *)(v3 + 24) = v10;
  *(void *)(v3 + 32) = v5;
  *(void *)(v3 + 40) = v6;
  *(void *)(v3 + 48) = v7;
  *(void *)(v3 + 56) = v8;
  *(unsigned char *)(v3 + 64) = v9;
  *(void *)(v3 + 72) = a2;
  parameters[0] = v5;
  parameters[1] = v6;
  nw_parameters_t parameters[2] = v7;
  parameters[3] = v8;
  char v19 = v9;
  swift_retain();
  uint64_t v12 = NWBrowser.Descriptor.nw.getter();
  uint64_t v13 = *(os_unfair_lock_s **)(a2 + 16);
  uint64_t v14 = v13 + 4;
  uint64_t v15 = v13 + 6;
  os_unfair_lock_lock(v13 + 6);
  sub_1834A4678(v14, parameters);
  os_unfair_lock_unlock(v15);
  nw_browser_t v16 = nw_browser_create(v12, parameters[0]);
  swift_unknownObjectRelease();
  swift_unknownObjectRelease();
  swift_release();
  *(void *)(v3 + 16) = v16;
  return v3;
}

uint64_t sub_1834C39B8(uint64_t *a1)
{
  sub_18313D870(a1[3]);
  a1[3] = 0;
  a1[4] = 0;
  uint64_t result = sub_18313D870(a1[5]);
  a1[5] = 0;
  a1[6] = 0;
  return result;
}

uint64_t sub_1834C39FC(uint64_t a1)
{
  uint64_t v4 = *(void *)(v1 + 16);
  uint64_t v3 = *(void *)(v1 + 24);
  uint64_t v5 = *(void *)(a1 + 24);
  sub_18315ED5C(v4);
  uint64_t result = sub_18313D870(v5);
  *(void *)(a1 + 24) = v4;
  *(void *)(a1 + 32) = v3;
  return result;
}

uint64_t sub_1834C3A58()
{
  swift_release();

  return swift_deallocObject();
}

uint64_t sub_1834C3A90(int a1, NSObject *a2)
{
  uint64_t v5 = *(uint64_t (**)(unsigned char *))(v2 + 16);
  swift_unknownObjectRetain();
  sub_1834C210C(a2, a1, (uint64_t)v7);
  return v5(v7);
}

uint64_t sub_1834C3AEC@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v6 = *(void *)(v2 + 16);
  uint64_t v5 = *(void *)(v2 + 24);
  uint64_t v7 = *(void *)(a1 + 40);
  sub_18315ED5C(v6);
  uint64_t result = sub_18313D870(v7);
  *(void *)(a1 + 40) = v6;
  *(void *)(a1 + 48) = v5;
  *a2 = *(unsigned char *)(a1 + 16);
  return result;
}

uint64_t sub_1834C3B5C()
{
  swift_release();
  if (*(void *)(v0 + 24)) {
    swift_release();
  }

  return swift_deallocObject();
}

uint64_t sub_1834C3BA4(uint64_t a1, uint64_t a2, char a3)
{
  return sub_1834C2F34(a1, a2, a3, *(void *)(v3 + 16), *(void (**)(void, void))(v3 + 24), *(void *)(v3 + 32));
}

void sub_1834C3BB0(uint64_t a1)
{
  uint64_t v3 = *(void **)(v1 + 16);
  uint64_t v4 = *(void **)(a1 + 56);
  id v5 = v3;

  *(void *)(a1 + 56) = v3;
  *(unsigned char *)(a1 + 16) = 1;
}

uint64_t static NWBrowser.browseIterator(on:)(uint64_t *a1)
{
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F62BF0);
  MEMORY[0x1F4188790](v2);
  uint64_t v4 = &v8[-((v3 + 15) & 0xFFFFFFFFFFFFFFF0)];
  uint64_t v5 = *a1;
  int v9 = 64;
  uint64_t v10 = v5;
  (*(void (**)(unsigned char *, void))(v6 + 104))(v4, *MEMORY[0x1E4FBD120]);
  return sub_183D4516C();
}

uint64_t NWBrowser.deinit()
{
  swift_unknownObjectRelease();
  swift_release();
  sub_1834C829C(*(void *)(v0 + 32), *(void *)(v0 + 40), *(void *)(v0 + 48), *(void *)(v0 + 56), *(unsigned char *)(v0 + 64));
  swift_release();
  return v0;
}

uint64_t NWBrowser.__deallocating_deinit()
{
  swift_unknownObjectRelease();
  swift_release();
  sub_1834C829C(*(void *)(v0 + 32), *(void *)(v0 + 40), *(void *)(v0 + 48), *(void *)(v0 + 56), *(unsigned char *)(v0 + 64));
  swift_release();

  return swift_deallocClassInstance();
}

uint64_t sub_1834C3DA8(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = sub_183D44B6C();
  MEMORY[0x1F4188790](v4 - 8);
  v96[2] = (char *)v96 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v6 = *(void *)(a1 + 64);
  uint64_t v97 = a1 + 64;
  uint64_t v7 = 1 << *(unsigned char *)(a1 + 32);
  uint64_t v8 = -1;
  if (v7 < 64) {
    uint64_t v8 = ~(-1 << v7);
  }
  unint64_t v9 = v8 & v6;
  int64_t v98 = (unint64_t)(v7 + 63) >> 6;
  uint64_t v100 = a1;
  swift_bridgeObjectRetain();
  int64_t v10 = 0;
  char v99 = a2;
  while (1)
  {
    if (v9)
    {
      unint64_t v15 = __clz(__rbit64(v9));
      v9 &= v9 - 1;
      unint64_t v16 = v15 | (v10 << 6);
      goto LABEL_26;
    }
    int64_t v17 = v10 + 1;
    if (__OFADD__(v10, 1))
    {
      __break(1u);
LABEL_73:
      __break(1u);
LABEL_74:
      __break(1u);
LABEL_75:
      __break(1u);
LABEL_76:
      __break(1u);
LABEL_77:
      __break(1u);
LABEL_78:
      __break(1u);
      goto LABEL_79;
    }
    if (v17 >= v98) {
      return swift_release();
    }
    unint64_t v18 = *(void *)(v97 + 8 * v17);
    ++v10;
    if (!v18)
    {
      int64_t v10 = v17 + 1;
      if (v17 + 1 >= v98) {
        return swift_release();
      }
      unint64_t v18 = *(void *)(v97 + 8 * v10);
      if (!v18)
      {
        int64_t v10 = v17 + 2;
        if (v17 + 2 >= v98) {
          return swift_release();
        }
        unint64_t v18 = *(void *)(v97 + 8 * v10);
        if (!v18)
        {
          int64_t v10 = v17 + 3;
          if (v17 + 3 >= v98) {
            return swift_release();
          }
          unint64_t v18 = *(void *)(v97 + 8 * v10);
          if (!v18) {
            break;
          }
        }
      }
    }
LABEL_25:
    unint64_t v9 = (v18 - 1) & v18;
    unint64_t v16 = __clz(__rbit64(v18)) + (v10 << 6);
LABEL_26:
    uint64_t v20 = (uint64_t *)(*(void *)(v100 + 48) + 16 * v16);
    uint64_t v21 = *v20;
    uint64_t v22 = v20[1];
    uint64_t v23 = *(void *)(v100 + 56) + 24 * v16;
    unint64_t v24 = *(void *)(v23 + 8);
    uint64_t v103 = *(void *)v23;
    int v25 = *(unsigned __int8 *)(v23 + 16);
    if (!v25)
    {
      int64_t v101 = v10;
      unint64_t v102 = v9;
      swift_bridgeObjectRetain_n();
      uint64_t v42 = v103;
      sub_1834CC954(v103, v24, 0);
      uint64_t v43 = v22;
      uint64_t v44 = v42;
      unint64_t v45 = v24;
      sub_1834CC954(v42, v24, 0);
      char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
      __int16 v104 = (void *)*a2;
      uint64_t v47 = v104;
      *a2 = 0x8000000000000000;
      uint64_t v48 = v21;
      unint64_t v50 = sub_18359A408(v21, v43);
      uint64_t v51 = v47[2];
      BOOL v52 = (v49 & 1) == 0;
      uint64_t v53 = v51 + v52;
      if (__OFADD__(v51, v52)) {
        goto LABEL_73;
      }
      char v54 = v49;
      if (v47[3] < v53)
      {
        sub_18359E354(v53, isUniquelyReferenced_nonNull_native);
        uint64_t v55 = sub_18359A408(v48, v43);
        if ((v54 & 1) != (v56 & 1)) {
          goto LABEL_80;
        }
        unint64_t v50 = v55;
        uint64_t v57 = v104;
        if ((v54 & 1) == 0) {
          goto LABEL_47;
        }
LABEL_4:
        uint64_t v11 = (uint64_t *)(v57[7] + 16 * v50);
        swift_bridgeObjectRelease();
        *uint64_t v11 = v44;
        v11[1] = v45;
LABEL_5:
        a2 = v99;
        *char v99 = (uint64_t)v57;
        swift_bridgeObjectRelease_n();
        swift_bridgeObjectRelease();
        uint64_t v12 = v44;
        unint64_t v13 = v45;
        char v14 = 0;
LABEL_6:
        sub_1834CC974(v12, v13, v14);
        goto LABEL_7;
      }
      if (isUniquelyReferenced_nonNull_native)
      {
        uint64_t v57 = v104;
        if (v49) {
          goto LABEL_4;
        }
      }
      else
      {
        sub_1835A1A10();
        uint64_t v57 = v104;
        if (v54) {
          goto LABEL_4;
        }
      }
LABEL_47:
      v57[(v50 >> 6) + 8] |= 1 << v50;
      uint64_t v71 = (uint64_t *)(v57[6] + 16 * v50);
      uint64_t *v71 = v48;
      v71[1] = v43;
      uint64_t v72 = (uint64_t *)(v57[7] + 16 * v50);
      uint64_t *v72 = v44;
      v72[1] = v45;
      uint64_t v73 = v57[2];
      BOOL v74 = __OFADD__(v73, 1);
      uint64_t v75 = v73 + 1;
      if (v74) {
        goto LABEL_76;
      }
      v57[2] = v75;
      swift_bridgeObjectRetain();
      goto LABEL_5;
    }
    if (v25 == 1)
    {
      int64_t v101 = v10;
      unint64_t v102 = v9;
      swift_bridgeObjectRetain_n();
      uint64_t v26 = v103;
      sub_1834CC954(v103, v24, 1);
      sub_1834CC954(v26, v24, 1);
      sub_183D44B4C();
      uint64_t v27 = sub_183D44B1C();
      if (v28)
      {
        uint64_t v29 = v28;
        uint64_t v30 = v27;
        char v31 = swift_isUniquelyReferenced_nonNull_native();
        __int16 v104 = (void *)*a2;
        uint64_t v32 = v104;
        *a2 = 0x8000000000000000;
        unint64_t v34 = sub_18359A408(v21, v22);
        uint64_t v35 = v32[2];
        BOOL v36 = (v33 & 1) == 0;
        uint64_t v37 = v35 + v36;
        if (__OFADD__(v35, v36)) {
          goto LABEL_74;
        }
        char v38 = v33;
        if (v32[3] < v37)
        {
          sub_18359E354(v37, v31);
          uint64_t v39 = sub_18359A408(v21, v22);
          if ((v38 & 1) != (v40 & 1)) {
            goto LABEL_80;
          }
          unint64_t v34 = v39;
          uint64_t v41 = v104;
          if ((v38 & 1) == 0) {
            goto LABEL_64;
          }
LABEL_56:
          uint64_t v83 = (uint64_t *)(v41[7] + 16 * v34);
          swift_bridgeObjectRelease();
          uint64_t *v83 = v30;
          v83[1] = v29;
LABEL_66:
          a2 = v99;
          *char v99 = (uint64_t)v41;
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
          uint64_t v90 = v103;
          sub_1834CC974(v103, v24, 1);
          swift_bridgeObjectRelease();
          uint64_t v12 = v90;
          unint64_t v13 = v24;
          char v14 = 1;
          goto LABEL_6;
        }
        if (v31)
        {
          uint64_t v41 = v104;
          if (v33) {
            goto LABEL_56;
          }
        }
        else
        {
          sub_1835A1A10();
          uint64_t v41 = v104;
          if (v38) {
            goto LABEL_56;
          }
        }
LABEL_64:
        v41[(v34 >> 6) + 8] |= 1 << v34;
        __int16 v86 = (uint64_t *)(v41[6] + 16 * v34);
        uint64_t *v86 = v21;
        v86[1] = v22;
        uint64_t v87 = (uint64_t *)(v41[7] + 16 * v34);
        *uint64_t v87 = v30;
        v87[1] = v29;
        uint64_t v88 = v41[2];
        BOOL v74 = __OFADD__(v88, 1);
        uint64_t v89 = v88 + 1;
        if (v74) {
          goto LABEL_77;
        }
        v41[2] = v89;
        swift_bridgeObjectRetain();
        goto LABEL_66;
      }
      swift_bridgeObjectRetain();
      unint64_t v76 = sub_18359A408(v21, v22);
      char v78 = v77;
      swift_bridgeObjectRelease();
      if (v78)
      {
        int64_t v79 = v99;
        char v80 = swift_isUniquelyReferenced_nonNull_native();
        uint64_t v81 = *v79;
        __int16 v104 = (void *)*v79;
        *int64_t v79 = 0x8000000000000000;
        if ((v80 & 1) == 0)
        {
          sub_1835A1A10();
          uint64_t v81 = (uint64_t)v104;
        }
        swift_bridgeObjectRelease();
        sub_1835511D0(v76, v81);
        *int64_t v79 = v81;
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        uint64_t v82 = v103;
        sub_1834CC974(v103, v24, 1);
        swift_bridgeObjectRelease();
        sub_1834CC974(v82, v24, 1);
        a2 = v79;
      }
      else
      {
        swift_bridgeObjectRelease();
        uint64_t v85 = v103;
        sub_1834CC974(v103, v24, 1);
        swift_bridgeObjectRelease();
        sub_1834CC974(v85, v24, 1);
        a2 = v99;
      }
LABEL_7:
      int64_t v10 = v101;
      unint64_t v9 = v102;
    }
    else if (v103 | v24)
    {
      unint64_t v102 = v9;
      swift_bridgeObjectRetain_n();
      unint64_t v58 = v24;
      sub_1834CC954(v103, v24, 2);
      char v59 = swift_isUniquelyReferenced_nonNull_native();
      __int16 v104 = (void *)*a2;
      uint64_t v60 = v104;
      *a2 = 0x8000000000000000;
      uint64_t v61 = v21;
      unint64_t v63 = sub_18359A408(v21, v22);
      uint64_t v64 = v60[2];
      BOOL v65 = (v62 & 1) == 0;
      uint64_t v66 = v64 + v65;
      if (__OFADD__(v64, v65)) {
        goto LABEL_75;
      }
      char v67 = v62;
      if (v60[3] >= v66)
      {
        if (v59)
        {
          uint64_t v70 = v104;
          if (v62) {
            goto LABEL_59;
          }
        }
        else
        {
          sub_1835A1A10();
          uint64_t v70 = v104;
          if (v67) {
            goto LABEL_59;
          }
        }
      }
      else
      {
        sub_18359E354(v66, v59);
        uint64_t v68 = sub_18359A408(v61, v22);
        if ((v67 & 1) != (v69 & 1)) {
          goto LABEL_80;
        }
        unint64_t v63 = v68;
        uint64_t v70 = v104;
        if (v67)
        {
LABEL_59:
          BOOL v84 = (void *)(v70[7] + 16 * v63);
          swift_bridgeObjectRelease();
          *BOOL v84 = 0;
          v84[1] = 0xE000000000000000;
          goto LABEL_70;
        }
      }
      v70[(v63 >> 6) + 8] |= 1 << v63;
      __int16 v91 = (uint64_t *)(v70[6] + 16 * v63);
      uint64_t *v91 = v61;
      v91[1] = v22;
      uint64_t v92 = (void *)(v70[7] + 16 * v63);
      *uint64_t v92 = 0;
      v92[1] = 0xE000000000000000;
      uint64_t v93 = v70[2];
      BOOL v74 = __OFADD__(v93, 1);
      uint64_t v94 = v93 + 1;
      if (v74) {
        goto LABEL_78;
      }
      v70[2] = v94;
      swift_bridgeObjectRetain();
LABEL_70:
      a2 = v99;
      *char v99 = (uint64_t)v70;
      swift_bridgeObjectRelease_n();
      swift_bridgeObjectRelease();
      sub_1834CC974(v103, v58, 2);
      unint64_t v9 = v102;
    }
    else
    {
      sub_1834CC974(v103, v24, 2);
    }
  }
  int64_t v19 = v17 + 4;
  if (v19 >= v98) {
    return swift_release();
  }
  unint64_t v18 = *(void *)(v97 + 8 * v19);
  if (v18)
  {
    int64_t v10 = v19;
    goto LABEL_25;
  }
  while (1)
  {
    int64_t v10 = v19 + 1;
    if (__OFADD__(v19, 1)) {
      break;
    }
    if (v10 >= v98) {
      return swift_release();
    }
    unint64_t v18 = *(void *)(v97 + 8 * v10);
    ++v19;
    if (v18) {
      goto LABEL_25;
    }
  }
LABEL_79:
  __break(1u);
LABEL_80:
  uint64_t result = sub_183D45A4C();
  __break(1u);
  return result;
}

uint64_t sub_1834C45E8()
{
  return swift_deallocObject();
}

uint64_t sub_1834C45F8()
{
  return swift_deallocObject();
}

uint64_t sub_1834C4608()
{
  return (*(uint64_t (**)(void))(v0 + 16))() & 1;
}

uint64_t type metadata accessor for NWBrowser.Result(uint64_t a1)
{
  return sub_18315A7F8(a1, qword_1E8F61AF0);
}

uint64_t sub_1834C4654(uint64_t result)
{
  if (result)
  {
    swift_bridgeObjectRetain();
    return swift_unknownObjectRetain();
  }
  return result;
}

uint64_t sub_1834C4694(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = v2;
  uint64_t v6 = type metadata accessor for NWBrowser.Result.Change(0);
  uint64_t v7 = *(void *)(v6 - 8);
  MEMORY[0x1F4188790](v6 - 8);
  unint64_t v9 = (char *)&v19 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = *v2;
  sub_183D45AFC();
  swift_bridgeObjectRetain();
  NWBrowser.Result.Change.hash(into:)();
  uint64_t v11 = sub_183D45B4C();
  uint64_t v12 = -1 << *(unsigned char *)(v10 + 32);
  unint64_t v13 = v11 & ~v12;
  if ((*(void *)(v10 + 56 + ((v13 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v13))
  {
    uint64_t v19 = a1;
    uint64_t v14 = ~v12;
    uint64_t v15 = *(void *)(v7 + 72);
    while (1)
    {
      sub_18315E6C0(*(void *)(v10 + 48) + v15 * v13, (uint64_t)v9, type metadata accessor for NWBrowser.Result.Change);
      BOOL v16 = _s7Network9NWBrowserC6ResultV6ChangeO2eeoiySbAG_AGtFZ_0((uint64_t)v9, a2);
      sub_1834C94F4((uint64_t)v9, type metadata accessor for NWBrowser.Result.Change);
      if (v16) {
        break;
      }
      unint64_t v13 = (v13 + 1) & v14;
      if (((*(void *)(v10 + 56 + ((v13 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v13) & 1) == 0)
      {
        swift_bridgeObjectRelease();
        a1 = v19;
        goto LABEL_7;
      }
    }
    swift_bridgeObjectRelease();
    sub_1834C94F4(a2, type metadata accessor for NWBrowser.Result.Change);
    sub_18315E6C0(*(void *)(*v3 + 48) + v15 * v13, v19, type metadata accessor for NWBrowser.Result.Change);
    return 0;
  }
  else
  {
    swift_bridgeObjectRelease();
LABEL_7:
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
    sub_18315E6C0(a2, (uint64_t)v9, type metadata accessor for NWBrowser.Result.Change);
    uint64_t v20 = *v3;
    *uint64_t v3 = 0x8000000000000000;
    sub_1834C6DD4((uint64_t)v9, v13, isUniquelyReferenced_nonNull_native);
    *uint64_t v3 = v20;
    swift_bridgeObjectRelease();
    sub_1834C81A0(a2, a1, type metadata accessor for NWBrowser.Result.Change);
    return 1;
  }
}

uint64_t sub_1834C4918(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = v2;
  uint64_t v6 = type metadata accessor for NWBrowser.Result(0);
  uint64_t v55 = *(void *)(v6 - 8);
  uint64_t v7 = MEMORY[0x1F4188790](v6);
  unint64_t v9 = (char *)&v46 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = MEMORY[0x1F4188790](v7);
  uint64_t v12 = (char *)&v46 - v11;
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v58 = (uint64_t)&v46 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  int64_t v17 = (char *)&v46 - v16;
  uint64_t v18 = MEMORY[0x1F4188790](v15);
  uint64_t v20 = (char *)&v46 - v19;
  MEMORY[0x1F4188790](v18);
  char v49 = (char *)&v46 - v21;
  uint64_t v22 = *v3;
  sub_183D45AFC();
  uint64_t v59 = v6;
  uint64_t v23 = a2 + *(int *)(v6 + 20);
  swift_bridgeObjectRetain();
  uint64_t v57 = v23;
  NWEndpoint.hash(into:)();
  uint64_t v24 = sub_183D45B4C();
  uint64_t v25 = -1 << *(unsigned char *)(v22 + 32);
  unint64_t v26 = v24 & ~v25;
  uint64_t v27 = v22;
  uint64_t v56 = v22 + 56;
  if (((*(void *)(v22 + 56 + ((v26 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v26) & 1) == 0)
  {
    swift_bridgeObjectRelease();
LABEL_16:
    uint64_t v43 = (uint64_t)v49;
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
    sub_18315E6C0(a2, v43, type metadata accessor for NWBrowser.Result);
    uint64_t v60 = *v3;
    *uint64_t v3 = 0x8000000000000000;
    sub_1834C7068(v43, v26, isUniquelyReferenced_nonNull_native);
    *uint64_t v3 = v60;
    swift_bridgeObjectRelease();
    sub_1834C81A0(a2, a1, type metadata accessor for NWBrowser.Result);
    return 1;
  }
  uint64_t v47 = v3;
  uint64_t v48 = a1;
  uint64_t v53 = ~v25;
  uint64_t v54 = v22;
  uint64_t v55 = *(void *)(v55 + 72);
  unint64_t v50 = v9;
  uint64_t v51 = a2;
  while (1)
  {
    uint64_t v28 = (uint64_t)v12;
    uint64_t v29 = *(void *)(v27 + 48);
    unint64_t v52 = v55 * v26;
    sub_18315E6C0(v29 + v55 * v26, (uint64_t)v20, type metadata accessor for NWBrowser.Result);
    uint64_t v30 = v59;
    char v31 = _s7Network10NWEndpointO2eeoiySbAC_ACtFZ_0((uint64_t)&v20[*(int *)(v59 + 20)], v57);
    sub_18315E6C0((uint64_t)v20, (uint64_t)v17, type metadata accessor for NWBrowser.Result);
    uint64_t v32 = (uint64_t)v17;
    uint64_t v33 = v58;
    sub_18315E6C0(a2, v58, type metadata accessor for NWBrowser.Result);
    if ((v31 & 1) == 0)
    {
      sub_1834C94F4(v32, type metadata accessor for NWBrowser.Result);
      sub_1834C94F4(v33, type metadata accessor for NWBrowser.Result);
      uint64_t v12 = (char *)v28;
      sub_18315E6C0((uint64_t)v20, v28, type metadata accessor for NWBrowser.Result);
      sub_18315E6C0(a2, (uint64_t)v9, type metadata accessor for NWBrowser.Result);
      int64_t v17 = (char *)v32;
LABEL_12:
      sub_1834C94F4((uint64_t)v9, type metadata accessor for NWBrowser.Result);
      sub_1834C94F4((uint64_t)v12, type metadata accessor for NWBrowser.Result);
      sub_1834C94F4((uint64_t)v20, type metadata accessor for NWBrowser.Result);
      uint64_t v27 = v54;
      goto LABEL_13;
    }
    char v34 = sub_18351461C(*(void *)(v32 + *(int *)(v30 + 24)), *(void *)(v33 + *(int *)(v30 + 24)));
    sub_1834C94F4(v32, type metadata accessor for NWBrowser.Result);
    sub_1834C94F4(v33, type metadata accessor for NWBrowser.Result);
    uint64_t v12 = (char *)v28;
    sub_18315E6C0((uint64_t)v20, v28, type metadata accessor for NWBrowser.Result);
    sub_18315E6C0(a2, (uint64_t)v9, type metadata accessor for NWBrowser.Result);
    int64_t v17 = (char *)v32;
    if ((v34 & 1) == 0) {
      goto LABEL_12;
    }
    uint64_t v35 = *(int *)(v59 + 28);
    BOOL v36 = v9;
    uint64_t v37 = *(void *)(v28 + v35);
    char v38 = *(NSObject **)(v28 + v35 + 8);
    uint64_t v39 = (uint64_t *)&v36[v35];
    uint64_t v41 = *v39;
    char v40 = v39[1];
    if (!v37) {
      break;
    }
    if (!v41) {
      goto LABEL_11;
    }
    sub_1834C4654(v37);
    sub_1834C4654(v41);
    sub_1834C4654(v37);
    sub_1834C4654(v41);
    sub_1834C4654(v37);
    sub_1834C4654(v41);
    BOOL is_equal = nw_txt_record_is_equal(v38, v40);
    sub_1834C80D8(v37);
    sub_1834C80D8(v41);
    sub_1834C80D8(v41);
    sub_1834C80D8(v37);
    sub_1834C80D8(v41);
    sub_1834C80D8(v37);
    unint64_t v9 = v50;
    sub_1834C94F4((uint64_t)v50, type metadata accessor for NWBrowser.Result);
    sub_1834C94F4((uint64_t)v12, type metadata accessor for NWBrowser.Result);
    sub_1834C94F4((uint64_t)v20, type metadata accessor for NWBrowser.Result);
    a2 = v51;
    uint64_t v27 = v54;
    if (is_equal) {
      goto LABEL_19;
    }
LABEL_13:
    unint64_t v26 = (v26 + 1) & v53;
    if (((*(void *)(v56 + ((v26 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v26) & 1) == 0)
    {
      swift_bridgeObjectRelease();
      a1 = v48;
      uint64_t v3 = v47;
      goto LABEL_16;
    }
  }
  if (v41)
  {
LABEL_11:
    sub_1834C4654(v37);
    sub_1834C4654(v41);
    sub_1834C80D8(v37);
    sub_1834C80D8(v41);
    unint64_t v9 = v50;
    a2 = v51;
    goto LABEL_12;
  }
  sub_1834C80D8(0);
  sub_1834C80D8(0);
  sub_1834C94F4((uint64_t)v50, type metadata accessor for NWBrowser.Result);
  sub_1834C94F4(v28, type metadata accessor for NWBrowser.Result);
  sub_1834C94F4((uint64_t)v20, type metadata accessor for NWBrowser.Result);
  a2 = v51;
LABEL_19:
  swift_bridgeObjectRelease();
  sub_1834C94F4(a2, type metadata accessor for NWBrowser.Result);
  sub_18315E6C0(*(void *)(*v47 + 48) + v52, v48, type metadata accessor for NWBrowser.Result);
  return 0;
}

uint64_t sub_1834C4F78@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5 = (int *)type metadata accessor for NWBrowser.Result(0);
  uint64_t v6 = *((void *)v5 - 1);
  uint64_t v7 = MEMORY[0x1F4188790](v5);
  uint64_t v53 = (uint64_t)&v42 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v9 = MEMORY[0x1F4188790](v7);
  uint64_t v52 = (uint64_t)&v42 - v10;
  uint64_t v11 = MEMORY[0x1F4188790](v9);
  uint64_t v13 = (char *)&v42 - v12;
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v16 = (char *)&v42 - v15;
  MEMORY[0x1F4188790](v14);
  uint64_t v18 = (char *)&v42 - v17;
  uint64_t v42 = v2;
  uint64_t v19 = *v2;
  sub_183D45AFC();
  uint64_t v20 = a1 + v5[5];
  swift_bridgeObjectRetain();
  uint64_t v51 = v20;
  NWEndpoint.hash(into:)();
  uint64_t v21 = sub_183D45B4C();
  uint64_t v22 = -1 << *(unsigned char *)(v19 + 32);
  unint64_t v23 = v21 & ~v22;
  uint64_t v50 = v19 + 56;
  if (((*(void *)(v19 + 56 + ((v23 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v23) & 1) == 0)
  {
    swift_bridgeObjectRelease();
    uint64_t v37 = 1;
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, int *))(v6 + 56))(a2, v37, 1, v5);
  }
  uint64_t v43 = v6;
  uint64_t v44 = a2;
  uint64_t v46 = v5;
  uint64_t v47 = ~v22;
  uint64_t v48 = *(void *)(v6 + 72);
  uint64_t v49 = v19;
  uint64_t v45 = a1;
  while (1)
  {
    unint64_t v24 = v48 * v23;
    sub_18315E6C0(*(void *)(v19 + 48) + v48 * v23, (uint64_t)v18, type metadata accessor for NWBrowser.Result);
    char v25 = _s7Network10NWEndpointO2eeoiySbAC_ACtFZ_0((uint64_t)&v18[v5[5]], v51);
    sub_18315E6C0((uint64_t)v18, (uint64_t)v16, type metadata accessor for NWBrowser.Result);
    sub_18315E6C0(a1, (uint64_t)v13, type metadata accessor for NWBrowser.Result);
    if ((v25 & 1) == 0)
    {
      sub_1834C94F4((uint64_t)v16, type metadata accessor for NWBrowser.Result);
      sub_1834C94F4((uint64_t)v13, type metadata accessor for NWBrowser.Result);
      uint64_t v27 = v52;
      sub_18315E6C0((uint64_t)v18, v52, type metadata accessor for NWBrowser.Result);
      uint64_t v28 = v53;
      sub_18315E6C0(a1, v53, type metadata accessor for NWBrowser.Result);
LABEL_12:
      sub_1834C94F4(v28, type metadata accessor for NWBrowser.Result);
      sub_1834C94F4(v27, type metadata accessor for NWBrowser.Result);
      sub_1834C94F4((uint64_t)v18, type metadata accessor for NWBrowser.Result);
      goto LABEL_13;
    }
    char v26 = sub_18351461C(*(void *)&v16[v5[6]], *(void *)&v13[v5[6]]);
    sub_1834C94F4((uint64_t)v16, type metadata accessor for NWBrowser.Result);
    sub_1834C94F4((uint64_t)v13, type metadata accessor for NWBrowser.Result);
    uint64_t v27 = v52;
    sub_18315E6C0((uint64_t)v18, v52, type metadata accessor for NWBrowser.Result);
    uint64_t v28 = v53;
    sub_18315E6C0(a1, v53, type metadata accessor for NWBrowser.Result);
    if ((v26 & 1) == 0) {
      goto LABEL_12;
    }
    uint64_t v29 = v5[7];
    uint64_t v30 = v28;
    uint64_t v31 = *(void *)(v27 + v29);
    uint64_t v32 = *(NSObject **)(v27 + v29 + 8);
    uint64_t v33 = (uint64_t *)(v30 + v29);
    uint64_t v35 = *v33;
    char v34 = v33[1];
    if (!v31) {
      break;
    }
    if (!v35) {
      goto LABEL_11;
    }
    sub_1834C4654(v31);
    sub_1834C4654(v35);
    sub_1834C4654(v31);
    sub_1834C4654(v35);
    sub_1834C4654(v31);
    sub_1834C4654(v35);
    BOOL is_equal = nw_txt_record_is_equal(v32, v34);
    sub_1834C80D8(v31);
    sub_1834C80D8(v35);
    sub_1834C80D8(v35);
    sub_1834C80D8(v31);
    sub_1834C80D8(v35);
    sub_1834C80D8(v31);
    sub_1834C94F4(v53, type metadata accessor for NWBrowser.Result);
    sub_1834C94F4(v52, type metadata accessor for NWBrowser.Result);
    sub_1834C94F4((uint64_t)v18, type metadata accessor for NWBrowser.Result);
    a1 = v45;
    uint64_t v5 = v46;
    if (is_equal) {
      goto LABEL_17;
    }
LABEL_13:
    unint64_t v23 = (v23 + 1) & v47;
    uint64_t v19 = v49;
    if (((*(void *)(v50 + ((v23 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v23) & 1) == 0)
    {
      swift_bridgeObjectRelease();
      uint64_t v37 = 1;
      uint64_t v6 = v43;
      a2 = v44;
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, int *))(v6 + 56))(a2, v37, 1, v5);
    }
  }
  if (v35)
  {
LABEL_11:
    sub_1834C4654(v31);
    sub_1834C4654(v35);
    sub_1834C80D8(v31);
    sub_1834C80D8(v35);
    a1 = v45;
    uint64_t v5 = v46;
    uint64_t v27 = v52;
    uint64_t v28 = v53;
    goto LABEL_12;
  }
  sub_1834C80D8(0);
  sub_1834C80D8(0);
  sub_1834C94F4(v53, type metadata accessor for NWBrowser.Result);
  sub_1834C94F4(v52, type metadata accessor for NWBrowser.Result);
  sub_1834C94F4((uint64_t)v18, type metadata accessor for NWBrowser.Result);
  uint64_t v5 = v46;
LABEL_17:
  swift_bridgeObjectRelease();
  char v38 = v42;
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  uint64_t v40 = *v38;
  uint64_t v54 = *v38;
  *char v38 = 0x8000000000000000;
  if ((isUniquelyReferenced_nonNull_native & 1) == 0)
  {
    sub_1834C558C(type metadata accessor for NWBrowser.Result, (uint64_t *)&unk_1E8F61B18, type metadata accessor for NWBrowser.Result, type metadata accessor for NWBrowser.Result);
    uint64_t v40 = v54;
  }
  a2 = v44;
  sub_1834C81A0(*(void *)(v40 + 48) + v24, v44, type metadata accessor for NWBrowser.Result);
  sub_1834C6B24(v23);
  *char v38 = v54;
  swift_bridgeObjectRelease();
  uint64_t v37 = 0;
  uint64_t v6 = v43;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, int *))(v6 + 56))(a2, v37, 1, v5);
}

void *sub_1834C558C(uint64_t (*a1)(void), uint64_t *a2, uint64_t (*a3)(void), uint64_t (*a4)(void))
{
  uint64_t v8 = v4;
  uint64_t v9 = a1(0);
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1F4188790](v9 - 8);
  uint64_t v12 = (char *)&v30 - v11;
  __swift_instantiateConcreteTypeFromMangledName(a2);
  uint64_t v13 = *v4;
  uint64_t v14 = sub_183D4542C();
  uint64_t v15 = v14;
  if (!*(void *)(v13 + 16))
  {
    uint64_t result = (void *)swift_release();
LABEL_30:
    uint64_t *v8 = v15;
    return result;
  }
  uint64_t result = (void *)(v14 + 56);
  unint64_t v17 = (unint64_t)((1 << *(unsigned char *)(v15 + 32)) + 63) >> 6;
  uint64_t v30 = v8;
  uint64_t v31 = (const void *)(v13 + 56);
  if (v15 != v13 || (unint64_t)result >= v13 + 56 + 8 * v17) {
    uint64_t result = memmove(result, v31, 8 * v17);
  }
  int64_t v19 = 0;
  *(void *)(v15 + 16) = *(void *)(v13 + 16);
  uint64_t v20 = 1 << *(unsigned char *)(v13 + 32);
  uint64_t v21 = -1;
  if (v20 < 64) {
    uint64_t v21 = ~(-1 << v20);
  }
  unint64_t v22 = v21 & *(void *)(v13 + 56);
  int64_t v23 = (unint64_t)(v20 + 63) >> 6;
  while (1)
  {
    if (v22)
    {
      unint64_t v24 = __clz(__rbit64(v22));
      v22 &= v22 - 1;
      unint64_t v25 = v24 | (v19 << 6);
      goto LABEL_12;
    }
    int64_t v27 = v19 + 1;
    if (__OFADD__(v19, 1))
    {
      __break(1u);
      goto LABEL_32;
    }
    if (v27 >= v23) {
      goto LABEL_28;
    }
    unint64_t v28 = *((void *)v31 + v27);
    ++v19;
    if (!v28)
    {
      int64_t v19 = v27 + 1;
      if (v27 + 1 >= v23) {
        goto LABEL_28;
      }
      unint64_t v28 = *((void *)v31 + v19);
      if (!v28)
      {
        int64_t v19 = v27 + 2;
        if (v27 + 2 >= v23) {
          goto LABEL_28;
        }
        unint64_t v28 = *((void *)v31 + v19);
        if (!v28) {
          break;
        }
      }
    }
LABEL_27:
    unint64_t v22 = (v28 - 1) & v28;
    unint64_t v25 = __clz(__rbit64(v28)) + (v19 << 6);
LABEL_12:
    unint64_t v26 = *(void *)(v10 + 72) * v25;
    sub_18315E6C0(*(void *)(v13 + 48) + v26, (uint64_t)v12, a3);
    uint64_t result = (void *)sub_1834C81A0((uint64_t)v12, *(void *)(v15 + 48) + v26, a4);
  }
  int64_t v29 = v27 + 3;
  if (v29 >= v23)
  {
LABEL_28:
    uint64_t result = (void *)swift_release();
    uint64_t v8 = v30;
    goto LABEL_30;
  }
  unint64_t v28 = *((void *)v31 + v29);
  if (v28)
  {
    int64_t v19 = v29;
    goto LABEL_27;
  }
  while (1)
  {
    int64_t v19 = v29 + 1;
    if (__OFADD__(v29, 1)) {
      break;
    }
    if (v19 >= v23) {
      goto LABEL_28;
    }
    unint64_t v28 = *((void *)v31 + v19);
    ++v29;
    if (v28) {
      goto LABEL_27;
    }
  }
LABEL_32:
  __break(1u);
  return result;
}

uint64_t sub_1834C5804()
{
  uint64_t v1 = v0;
  uint64_t v48 = type metadata accessor for NWBrowser.Result(0);
  uint64_t v2 = MEMORY[0x1F4188790](v48);
  uint64_t v44 = (uint64_t)v43 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v2);
  uint64_t v5 = (char *)v43 - v4;
  uint64_t v6 = type metadata accessor for NWBrowser.Result.Change(0);
  uint64_t v49 = *(void *)(v6 - 8);
  uint64_t v7 = MEMORY[0x1F4188790](v6);
  uint64_t v51 = (uint64_t)v43 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v7);
  uint64_t v10 = (char *)v43 - v9;
  uint64_t v11 = *v0;
  __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F61B10);
  uint64_t v12 = sub_183D4543C();
  uint64_t v13 = v12;
  if (!*(void *)(v11 + 16))
  {
    uint64_t result = swift_release();
    goto LABEL_40;
  }
  v43[0] = v0;
  uint64_t v14 = 1 << *(unsigned char *)(v11 + 32);
  uint64_t v15 = *(void *)(v11 + 56);
  uint64_t v46 = v11 + 56;
  if (v14 < 64) {
    uint64_t v16 = ~(-1 << v14);
  }
  else {
    uint64_t v16 = -1;
  }
  unint64_t v17 = v16 & v15;
  int64_t v47 = (unint64_t)(v14 + 63) >> 6;
  uint64_t v18 = v12 + 56;
  swift_retain();
  int64_t v19 = 0;
  uint64_t v50 = v11;
  v43[1] = v6;
  while (1)
  {
    if (v17)
    {
      unint64_t v21 = __clz(__rbit64(v17));
      v17 &= v17 - 1;
      unint64_t v22 = v21 | (v19 << 6);
      goto LABEL_24;
    }
    int64_t v23 = v19 + 1;
    if (__OFADD__(v19, 1)) {
      goto LABEL_41;
    }
    if (v23 >= v47) {
      break;
    }
    unint64_t v24 = *(void *)(v46 + 8 * v23);
    ++v19;
    if (!v24)
    {
      int64_t v19 = v23 + 1;
      if (v23 + 1 >= v47) {
        break;
      }
      unint64_t v24 = *(void *)(v46 + 8 * v19);
      if (!v24)
      {
        int64_t v19 = v23 + 2;
        if (v23 + 2 >= v47) {
          break;
        }
        unint64_t v24 = *(void *)(v46 + 8 * v19);
        if (!v24)
        {
          int64_t v25 = v23 + 3;
          if (v25 >= v47) {
            break;
          }
          unint64_t v24 = *(void *)(v46 + 8 * v25);
          if (!v24)
          {
            while (1)
            {
              int64_t v19 = v25 + 1;
              if (__OFADD__(v25, 1)) {
                goto LABEL_42;
              }
              if (v19 >= v47) {
                goto LABEL_38;
              }
              unint64_t v24 = *(void *)(v46 + 8 * v19);
              ++v25;
              if (v24) {
                goto LABEL_23;
              }
            }
          }
          int64_t v19 = v25;
        }
      }
    }
LABEL_23:
    unint64_t v17 = (v24 - 1) & v24;
    unint64_t v22 = __clz(__rbit64(v24)) + (v19 << 6);
LABEL_24:
    uint64_t v26 = *(void *)(v49 + 72);
    sub_18315E6C0(*(void *)(v50 + 48) + v26 * v22, (uint64_t)v10, type metadata accessor for NWBrowser.Result.Change);
    sub_183D45AFC();
    uint64_t v27 = (uint64_t)v10;
    sub_18315E6C0((uint64_t)v10, v51, type metadata accessor for NWBrowser.Result.Change);
    switch(swift_getEnumCaseMultiPayload())
    {
      case 2u:
        uint64_t v29 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F619E0);
        uint64_t v30 = v51 + *(int *)(v29 + 48);
        int v45 = *(unsigned __int8 *)(v51 + *(int *)(v29 + 64));
        sub_1834C81A0(v51, (uint64_t)v5, type metadata accessor for NWBrowser.Result);
        uint64_t v31 = v5;
        uint64_t v32 = v44;
        sub_1834C81A0(v30, v44, type metadata accessor for NWBrowser.Result);
        sub_183D45B0C();
        NWEndpoint.hash(into:)();
        NWEndpoint.hash(into:)();
        sub_183D45B1C();
        uint64_t v33 = v32;
        uint64_t v5 = v31;
        sub_1834C94F4(v33, type metadata accessor for NWBrowser.Result);
        uint64_t v28 = (uint64_t)v31;
        goto LABEL_27;
      case 3u:
        sub_183D45B0C();
        break;
      default:
        sub_1834C81A0(v51, (uint64_t)v5, type metadata accessor for NWBrowser.Result);
        sub_183D45B0C();
        NWEndpoint.hash(into:)();
        uint64_t v28 = (uint64_t)v5;
LABEL_27:
        sub_1834C94F4(v28, type metadata accessor for NWBrowser.Result);
        break;
    }
    uint64_t v10 = (char *)v27;
    uint64_t v34 = sub_183D45B4C();
    uint64_t v35 = -1 << *(unsigned char *)(v13 + 32);
    unint64_t v36 = v34 & ~v35;
    unint64_t v37 = v36 >> 6;
    if (((-1 << v36) & ~*(void *)(v18 + 8 * (v36 >> 6))) != 0)
    {
      unint64_t v20 = __clz(__rbit64((-1 << v36) & ~*(void *)(v18 + 8 * (v36 >> 6)))) | v36 & 0x7FFFFFFFFFFFFFC0;
      goto LABEL_7;
    }
    char v38 = 0;
    unint64_t v39 = (unint64_t)(63 - v35) >> 6;
    do
    {
      if (++v37 == v39 && (v38 & 1) != 0)
      {
        __break(1u);
LABEL_41:
        __break(1u);
LABEL_42:
        __break(1u);
        JUMPOUT(0x1834C5DC4);
      }
      BOOL v40 = v37 == v39;
      if (v37 == v39) {
        unint64_t v37 = 0;
      }
      v38 |= v40;
      uint64_t v41 = *(void *)(v18 + 8 * v37);
    }
    while (v41 == -1);
    unint64_t v20 = __clz(__rbit64(~v41)) + (v37 << 6);
LABEL_7:
    *(void *)(v18 + ((v20 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v20;
    sub_1834C81A0(v27, *(void *)(v13 + 48) + v20 * v26, type metadata accessor for NWBrowser.Result.Change);
    ++*(void *)(v13 + 16);
  }
LABEL_38:
  uint64_t result = swift_release_n();
  uint64_t v1 = (uint64_t *)v43[0];
LABEL_40:
  uint64_t *v1 = v13;
  return result;
}

uint64_t sub_1834C5DD4()
{
  uint64_t v1 = v0;
  uint64_t v2 = type metadata accessor for NWBrowser.Result(0);
  uint64_t v33 = *(void *)(v2 - 8);
  MEMORY[0x1F4188790](v2);
  uint64_t v4 = (char *)&v29 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v5 = *v0;
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_1E8F61B18);
  uint64_t v6 = sub_183D4543C();
  uint64_t v7 = v6;
  if (!*(void *)(v5 + 16))
  {
    uint64_t result = swift_release();
LABEL_35:
    uint64_t *v1 = v7;
    return result;
  }
  uint64_t v8 = 1 << *(unsigned char *)(v5 + 32);
  uint64_t v9 = *(void *)(v5 + 56);
  uint64_t v30 = v0;
  uint64_t v31 = v5 + 56;
  if (v8 < 64) {
    uint64_t v10 = ~(-1 << v8);
  }
  else {
    uint64_t v10 = -1;
  }
  unint64_t v11 = v10 & v9;
  int64_t v32 = (unint64_t)(v8 + 63) >> 6;
  uint64_t v12 = v6 + 56;
  uint64_t result = swift_retain();
  int64_t v14 = 0;
  while (1)
  {
    if (v11)
    {
      unint64_t v16 = __clz(__rbit64(v11));
      v11 &= v11 - 1;
      unint64_t v17 = v16 | (v14 << 6);
      goto LABEL_24;
    }
    int64_t v18 = v14 + 1;
    if (__OFADD__(v14, 1))
    {
LABEL_36:
      __break(1u);
      goto LABEL_37;
    }
    if (v18 >= v32) {
      goto LABEL_33;
    }
    unint64_t v19 = *(void *)(v31 + 8 * v18);
    ++v14;
    if (!v19)
    {
      int64_t v14 = v18 + 1;
      if (v18 + 1 >= v32) {
        goto LABEL_33;
      }
      unint64_t v19 = *(void *)(v31 + 8 * v14);
      if (!v19)
      {
        int64_t v14 = v18 + 2;
        if (v18 + 2 >= v32) {
          goto LABEL_33;
        }
        unint64_t v19 = *(void *)(v31 + 8 * v14);
        if (!v19) {
          break;
        }
      }
    }
LABEL_23:
    unint64_t v11 = (v19 - 1) & v19;
    unint64_t v17 = __clz(__rbit64(v19)) + (v14 << 6);
LABEL_24:
    uint64_t v21 = *(void *)(v33 + 72);
    sub_18315E6C0(*(void *)(v5 + 48) + v21 * v17, (uint64_t)v4, type metadata accessor for NWBrowser.Result);
    sub_183D45AFC();
    NWEndpoint.hash(into:)();
    uint64_t result = sub_183D45B4C();
    uint64_t v22 = -1 << *(unsigned char *)(v7 + 32);
    unint64_t v23 = result & ~v22;
    unint64_t v24 = v23 >> 6;
    if (((-1 << v23) & ~*(void *)(v12 + 8 * (v23 >> 6))) != 0)
    {
      unint64_t v15 = __clz(__rbit64((-1 << v23) & ~*(void *)(v12 + 8 * (v23 >> 6)))) | v23 & 0x7FFFFFFFFFFFFFC0;
    }
    else
    {
      char v25 = 0;
      unint64_t v26 = (unint64_t)(63 - v22) >> 6;
      do
      {
        if (++v24 == v26 && (v25 & 1) != 0)
        {
          __break(1u);
          goto LABEL_36;
        }
        BOOL v27 = v24 == v26;
        if (v24 == v26) {
          unint64_t v24 = 0;
        }
        v25 |= v27;
        uint64_t v28 = *(void *)(v12 + 8 * v24);
      }
      while (v28 == -1);
      unint64_t v15 = __clz(__rbit64(~v28)) + (v24 << 6);
    }
    *(void *)(v12 + ((v15 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v15;
    uint64_t result = sub_1834C81A0((uint64_t)v4, *(void *)(v7 + 48) + v15 * v21, type metadata accessor for NWBrowser.Result);
    ++*(void *)(v7 + 16);
  }
  int64_t v20 = v18 + 3;
  if (v20 >= v32)
  {
LABEL_33:
    uint64_t result = swift_release_n();
    uint64_t v1 = v30;
    goto LABEL_35;
  }
  unint64_t v19 = *(void *)(v31 + 8 * v20);
  if (v19)
  {
    int64_t v14 = v20;
    goto LABEL_23;
  }
  while (1)
  {
    int64_t v14 = v20 + 1;
    if (__OFADD__(v20, 1)) {
      break;
    }
    if (v14 >= v32) {
      goto LABEL_33;
    }
    unint64_t v19 = *(void *)(v31 + 8 * v14);
    ++v20;
    if (v19) {
      goto LABEL_23;
    }
  }
LABEL_37:
  __break(1u);
  return result;
}

uint64_t sub_1834C6148()
{
  uint64_t v1 = v0;
  uint64_t v2 = type metadata accessor for NWBrowser.Result(0);
  uint64_t v3 = MEMORY[0x1F4188790](v2);
  uint64_t v48 = (uint64_t)&v46 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v3);
  uint64_t v6 = (char *)&v46 - v5;
  uint64_t v7 = type metadata accessor for NWBrowser.Result.Change(0);
  uint64_t v8 = *(void *)(v7 - 8);
  uint64_t v9 = MEMORY[0x1F4188790](v7);
  uint64_t v50 = (uint64_t)&v46 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v9);
  uint64_t v55 = (uint64_t)&v46 - v11;
  uint64_t v12 = *v0;
  __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F61B10);
  uint64_t v13 = sub_183D4543C();
  uint64_t v14 = v13;
  if (!*(void *)(v12 + 16)) {
    goto LABEL_42;
  }
  uint64_t v46 = v0;
  uint64_t v15 = 1 << *(unsigned char *)(v12 + 32);
  unint64_t v16 = (void *)(v12 + 56);
  if (v15 < 64) {
    uint64_t v17 = ~(-1 << v15);
  }
  else {
    uint64_t v17 = -1;
  }
  unint64_t v18 = v17 & *(void *)(v12 + 56);
  int64_t v51 = (unint64_t)(v15 + 63) >> 6;
  uint64_t v19 = v13 + 56;
  swift_retain();
  int64_t v20 = 0;
  uint64_t v21 = v50;
  int64_t v47 = (void *)(v12 + 56);
  while (1)
  {
    if (v18)
    {
      int64_t v53 = v20;
      uint64_t v54 = (v18 - 1) & v18;
      unint64_t v23 = __clz(__rbit64(v18)) | (v20 << 6);
      goto LABEL_24;
    }
    int64_t v24 = v20 + 1;
    if (__OFADD__(v20, 1)) {
      goto LABEL_43;
    }
    if (v24 >= v51) {
      break;
    }
    unint64_t v25 = v16[v24];
    int64_t v26 = v20 + 1;
    if (!v25)
    {
      int64_t v26 = v20 + 2;
      if (v20 + 2 >= v51) {
        break;
      }
      unint64_t v25 = v16[v26];
      if (!v25)
      {
        int64_t v26 = v20 + 3;
        if (v20 + 3 >= v51) {
          break;
        }
        unint64_t v25 = v16[v26];
        if (!v25)
        {
          uint64_t v27 = v20 + 4;
          if (v20 + 4 >= v51) {
            break;
          }
          unint64_t v25 = v16[v27];
          if (!v25)
          {
            while (1)
            {
              int64_t v26 = v27 + 1;
              if (__OFADD__(v27, 1)) {
                goto LABEL_44;
              }
              if (v26 >= v51) {
                goto LABEL_38;
              }
              unint64_t v25 = v16[v26];
              ++v27;
              if (v25) {
                goto LABEL_23;
              }
            }
          }
          int64_t v26 = v20 + 4;
        }
      }
    }
LABEL_23:
    int64_t v53 = v26;
    uint64_t v54 = (v25 - 1) & v25;
    unint64_t v23 = __clz(__rbit64(v25)) + (v26 << 6);
LABEL_24:
    uint64_t v28 = *(void *)(v12 + 48);
    uint64_t v52 = *(void *)(v8 + 72);
    uint64_t v29 = v55;
    sub_1834C81A0(v28 + v52 * v23, v55, type metadata accessor for NWBrowser.Result.Change);
    sub_183D45AFC();
    sub_18315E6C0(v29, v21, type metadata accessor for NWBrowser.Result.Change);
    switch(swift_getEnumCaseMultiPayload())
    {
      case 2u:
        uint64_t v31 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F619E0);
        uint64_t v32 = v21 + *(int *)(v31 + 48);
        int v49 = *(unsigned __int8 *)(v21 + *(int *)(v31 + 64));
        sub_1834C81A0(v50, (uint64_t)v6, type metadata accessor for NWBrowser.Result);
        uint64_t v33 = v6;
        uint64_t v34 = v48;
        uint64_t v21 = v50;
        sub_1834C81A0(v32, v48, type metadata accessor for NWBrowser.Result);
        sub_183D45B0C();
        NWEndpoint.hash(into:)();
        NWEndpoint.hash(into:)();
        sub_183D45B1C();
        uint64_t v35 = v34;
        uint64_t v6 = v33;
        unint64_t v16 = v47;
        sub_1834C94F4(v35, type metadata accessor for NWBrowser.Result);
        uint64_t v30 = (uint64_t)v6;
        goto LABEL_27;
      case 3u:
        sub_183D45B0C();
        break;
      default:
        sub_1834C81A0(v21, (uint64_t)v6, type metadata accessor for NWBrowser.Result);
        sub_183D45B0C();
        NWEndpoint.hash(into:)();
        uint64_t v30 = (uint64_t)v6;
LABEL_27:
        sub_1834C94F4(v30, type metadata accessor for NWBrowser.Result);
        break;
    }
    uint64_t v36 = sub_183D45B4C();
    uint64_t v37 = -1 << *(unsigned char *)(v14 + 32);
    unint64_t v38 = v36 & ~v37;
    unint64_t v39 = v38 >> 6;
    if (((-1 << v38) & ~*(void *)(v19 + 8 * (v38 >> 6))) != 0)
    {
      unint64_t v22 = __clz(__rbit64((-1 << v38) & ~*(void *)(v19 + 8 * (v38 >> 6)))) | v38 & 0x7FFFFFFFFFFFFFC0;
      unint64_t v18 = v54;
      goto LABEL_7;
    }
    char v40 = 0;
    unint64_t v41 = (unint64_t)(63 - v37) >> 6;
    unint64_t v18 = v54;
    do
    {
      if (++v39 == v41 && (v40 & 1) != 0)
      {
        __break(1u);
LABEL_43:
        __break(1u);
LABEL_44:
        __break(1u);
        JUMPOUT(0x1834C6764);
      }
      BOOL v42 = v39 == v41;
      if (v39 == v41) {
        unint64_t v39 = 0;
      }
      v40 |= v42;
      uint64_t v43 = *(void *)(v19 + 8 * v39);
    }
    while (v43 == -1);
    unint64_t v22 = __clz(__rbit64(~v43)) + (v39 << 6);
LABEL_7:
    *(void *)(v19 + ((v22 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v22;
    sub_1834C81A0(v55, *(void *)(v14 + 48) + v22 * v52, type metadata accessor for NWBrowser.Result.Change);
    ++*(void *)(v14 + 16);
    int64_t v20 = v53;
  }
LABEL_38:
  swift_release();
  uint64_t v1 = v46;
  uint64_t v44 = 1 << *(unsigned char *)(v12 + 32);
  if (v44 > 63) {
    bzero(v16, ((unint64_t)(v44 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8);
  }
  else {
    *unint64_t v16 = -1 << v44;
  }
  *(void *)(v12 + 16) = 0;
LABEL_42:
  uint64_t result = swift_release();
  uint64_t *v1 = v14;
  return result;
}

uint64_t sub_1834C6774()
{
  uint64_t v1 = v0;
  uint64_t v2 = type metadata accessor for NWBrowser.Result(0);
  uint64_t v34 = *(void *)(v2 - 8);
  MEMORY[0x1F4188790](v2);
  uint64_t v4 = (char *)&v30 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v5 = *v0;
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_1E8F61B18);
  uint64_t v6 = sub_183D4543C();
  uint64_t v7 = v6;
  if (*(void *)(v5 + 16))
  {
    uint64_t v31 = v0;
    uint64_t v8 = 1 << *(unsigned char *)(v5 + 32);
    uint64_t v9 = *(void *)(v5 + 56);
    uint64_t v33 = (void *)(v5 + 56);
    if (v8 < 64) {
      uint64_t v10 = ~(-1 << v8);
    }
    else {
      uint64_t v10 = -1;
    }
    unint64_t v11 = v10 & v9;
    int64_t v32 = (unint64_t)(v8 + 63) >> 6;
    uint64_t v12 = v6 + 56;
    uint64_t result = swift_retain();
    int64_t v14 = 0;
    while (1)
    {
      if (v11)
      {
        unint64_t v16 = __clz(__rbit64(v11));
        v11 &= v11 - 1;
        unint64_t v17 = v16 | (v14 << 6);
      }
      else
      {
        int64_t v18 = v14 + 1;
        if (__OFADD__(v14, 1))
        {
LABEL_38:
          __break(1u);
LABEL_39:
          __break(1u);
          return result;
        }
        if (v18 >= v32) {
          goto LABEL_33;
        }
        unint64_t v19 = v33[v18];
        ++v14;
        if (!v19)
        {
          int64_t v14 = v18 + 1;
          if (v18 + 1 >= v32) {
            goto LABEL_33;
          }
          unint64_t v19 = v33[v14];
          if (!v19)
          {
            int64_t v14 = v18 + 2;
            if (v18 + 2 >= v32) {
              goto LABEL_33;
            }
            unint64_t v19 = v33[v14];
            if (!v19)
            {
              int64_t v20 = v18 + 3;
              if (v20 >= v32)
              {
LABEL_33:
                swift_release();
                uint64_t v1 = v31;
                uint64_t v29 = 1 << *(unsigned char *)(v5 + 32);
                if (v29 > 63) {
                  bzero(v33, ((unint64_t)(v29 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8);
                }
                else {
                  *uint64_t v33 = -1 << v29;
                }
                *(void *)(v5 + 16) = 0;
                break;
              }
              unint64_t v19 = v33[v20];
              if (!v19)
              {
                while (1)
                {
                  int64_t v14 = v20 + 1;
                  if (__OFADD__(v20, 1)) {
                    goto LABEL_39;
                  }
                  if (v14 >= v32) {
                    goto LABEL_33;
                  }
                  unint64_t v19 = v33[v14];
                  ++v20;
                  if (v19) {
                    goto LABEL_23;
                  }
                }
              }
              int64_t v14 = v20;
            }
          }
        }
LABEL_23:
        unint64_t v11 = (v19 - 1) & v19;
        unint64_t v17 = __clz(__rbit64(v19)) + (v14 << 6);
      }
      uint64_t v21 = *(void *)(v34 + 72);
      sub_1834C81A0(*(void *)(v5 + 48) + v21 * v17, (uint64_t)v4, type metadata accessor for NWBrowser.Result);
      sub_183D45AFC();
      NWEndpoint.hash(into:)();
      uint64_t result = sub_183D45B4C();
      uint64_t v22 = -1 << *(unsigned char *)(v7 + 32);
      unint64_t v23 = result & ~v22;
      unint64_t v24 = v23 >> 6;
      if (((-1 << v23) & ~*(void *)(v12 + 8 * (v23 >> 6))) != 0)
      {
        unint64_t v15 = __clz(__rbit64((-1 << v23) & ~*(void *)(v12 + 8 * (v23 >> 6)))) | v23 & 0x7FFFFFFFFFFFFFC0;
      }
      else
      {
        char v25 = 0;
        unint64_t v26 = (unint64_t)(63 - v22) >> 6;
        do
        {
          if (++v24 == v26 && (v25 & 1) != 0)
          {
            __break(1u);
            goto LABEL_38;
          }
          BOOL v27 = v24 == v26;
          if (v24 == v26) {
            unint64_t v24 = 0;
          }
          v25 |= v27;
          uint64_t v28 = *(void *)(v12 + 8 * v24);
        }
        while (v28 == -1);
        unint64_t v15 = __clz(__rbit64(~v28)) + (v24 << 6);
      }
      *(void *)(v12 + ((v15 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v15;
      uint64_t result = sub_1834C81A0((uint64_t)v4, *(void *)(v7 + 48) + v15 * v21, type metadata accessor for NWBrowser.Result);
      ++*(void *)(v7 + 16);
    }
  }
  uint64_t result = swift_release();
  uint64_t *v1 = v7;
  return result;
}

uint64_t sub_1834C6B24(unint64_t a1)
{
  uint64_t v3 = type metadata accessor for NWBrowser.Result(0);
  uint64_t result = MEMORY[0x1F4188790](v3);
  uint64_t v7 = (char *)&v24 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = *v1;
  uint64_t v9 = *v1 + 56;
  uint64_t v10 = -1 << *(unsigned char *)(*v1 + 32);
  unint64_t v11 = (a1 + 1) & ~v10;
  if (((1 << v11) & *(void *)(v9 + 8 * (v11 >> 6))) != 0)
  {
    uint64_t v24 = v5;
    char v25 = v1;
    uint64_t v12 = ~v10;
    swift_retain();
    uint64_t v13 = sub_183D4540C();
    uint64_t v26 = v9;
    if ((*(void *)(v9 + 8 * (v11 >> 6)) & (1 << v11)) != 0)
    {
      unint64_t v14 = (v13 + 1) & v12;
      uint64_t v15 = *(void *)(v24 + 72);
      while (1)
      {
        int64_t v16 = v15 * v11;
        sub_18315E6C0(*(void *)(v8 + 48) + v15 * v11, (uint64_t)v7, type metadata accessor for NWBrowser.Result);
        sub_183D45AFC();
        NWEndpoint.hash(into:)();
        uint64_t v17 = sub_183D45B4C();
        sub_1834C94F4((uint64_t)v7, type metadata accessor for NWBrowser.Result);
        unint64_t v18 = v17 & v12;
        if ((uint64_t)a1 >= (uint64_t)v14) {
          break;
        }
        if (v18 < v14) {
          goto LABEL_11;
        }
LABEL_12:
        unint64_t v19 = v15 * a1;
        if ((uint64_t)(v15 * a1) < v16 || *(void *)(v8 + 48) + v15 * a1 >= *(void *)(v8 + 48) + v16 + v15)
        {
          swift_arrayInitWithTakeFrontToBack();
        }
        else
        {
          a1 = v11;
          if (v19 == v16) {
            goto LABEL_6;
          }
          swift_arrayInitWithTakeBackToFront();
        }
        a1 = v11;
LABEL_6:
        unint64_t v11 = (v11 + 1) & v12;
        if (((*(void *)(v26 + ((v11 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v11) & 1) == 0) {
          goto LABEL_16;
        }
      }
      if (v18 < v14) {
        goto LABEL_6;
      }
LABEL_11:
      if ((uint64_t)a1 < (uint64_t)v18) {
        goto LABEL_6;
      }
      goto LABEL_12;
    }
LABEL_16:
    *(void *)(v26 + ((a1 >> 3) & 0x1FFFFFFFFFFFFFF8)) &= (-1 << a1) - 1;
    uint64_t result = swift_release();
    uint64_t v1 = v25;
  }
  else
  {
    *(void *)(v9 + ((a1 >> 3) & 0x1FFFFFFFFFFFFFF8)) &= (-1 << a1) - 1;
  }
  uint64_t v20 = *v1;
  uint64_t v21 = *(void *)(*v1 + 16);
  BOOL v22 = __OFSUB__(v21, 1);
  uint64_t v23 = v21 - 1;
  if (v22)
  {
    __break(1u);
  }
  else
  {
    *(void *)(v20 + 16) = v23;
    ++*(_DWORD *)(v20 + 36);
  }
  return result;
}

uint64_t sub_1834C6DD4(uint64_t a1, unint64_t a2, char a3)
{
  uint64_t v4 = v3;
  uint64_t v8 = type metadata accessor for NWBrowser.Result.Change(0);
  uint64_t v9 = *(void *)(v8 - 8);
  MEMORY[0x1F4188790](v8);
  unint64_t v11 = (char *)&v26 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  unint64_t v12 = *(void *)(*v4 + 16);
  unint64_t v13 = *(void *)(*v4 + 24);
  if (v13 > v12 && (a3 & 1) != 0)
  {
LABEL_13:
    uint64_t v14 = v9;
    goto LABEL_14;
  }
  if (a3)
  {
    sub_1834C6148();
    goto LABEL_8;
  }
  if (v13 <= v12)
  {
    sub_1834C5804();
LABEL_8:
    uint64_t v15 = *v4;
    sub_183D45AFC();
    NWBrowser.Result.Change.hash(into:)();
    uint64_t v16 = sub_183D45B4C();
    uint64_t v17 = -1 << *(unsigned char *)(v15 + 32);
    a2 = v16 & ~v17;
    if ((*(void *)(v15 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a2))
    {
      uint64_t v26 = v8;
      uint64_t v18 = ~v17;
      uint64_t v14 = v9;
      uint64_t v19 = *(void *)(v9 + 72);
      while (1)
      {
        sub_18315E6C0(*(void *)(v15 + 48) + v19 * a2, (uint64_t)v11, type metadata accessor for NWBrowser.Result.Change);
        BOOL v20 = _s7Network9NWBrowserC6ResultV6ChangeO2eeoiySbAG_AGtFZ_0((uint64_t)v11, a1);
        sub_1834C94F4((uint64_t)v11, type metadata accessor for NWBrowser.Result.Change);
        if (v20) {
          goto LABEL_17;
        }
        a2 = (a2 + 1) & v18;
        if (((*(void *)(v15 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a2) & 1) == 0) {
          goto LABEL_14;
        }
      }
    }
    goto LABEL_13;
  }
  uint64_t v14 = v9;
  sub_1834C558C(type metadata accessor for NWBrowser.Result.Change, &qword_1E8F61B10, type metadata accessor for NWBrowser.Result.Change, type metadata accessor for NWBrowser.Result.Change);
LABEL_14:
  uint64_t v21 = *v4;
  *(void *)(*v4 + 8 * (a2 >> 6) + 56) |= 1 << a2;
  uint64_t result = sub_1834C81A0(a1, *(void *)(v21 + 48) + *(void *)(v14 + 72) * a2, type metadata accessor for NWBrowser.Result.Change);
  uint64_t v23 = *(void *)(v21 + 16);
  BOOL v24 = __OFADD__(v23, 1);
  uint64_t v25 = v23 + 1;
  if (!v24)
  {
    *(void *)(v21 + 16) = v25;
    return result;
  }
  __break(1u);
LABEL_17:
  uint64_t result = sub_183D45A3C();
  __break(1u);
  return result;
}

uint64_t sub_1834C7068(uint64_t a1, unint64_t a2, char a3)
{
  uint64_t v7 = (int *)type metadata accessor for NWBrowser.Result(0);
  uint64_t v45 = *((void *)v7 - 1);
  uint64_t v8 = MEMORY[0x1F4188790](v7);
  uint64_t v10 = &v40[-((v9 + 15) & 0xFFFFFFFFFFFFFFF0)];
  uint64_t v11 = MEMORY[0x1F4188790](v8);
  unint64_t v13 = &v40[-v12];
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v16 = &v40[-v15];
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  uint64_t v19 = &v40[-v18];
  MEMORY[0x1F4188790](v17);
  uint64_t v21 = &v40[-v20];
  unint64_t v22 = *(void *)(*v3 + 16);
  unint64_t v23 = *(void *)(*v3 + 24);
  BOOL v42 = v3;
  if (v23 <= v22 || (a3 & 1) == 0)
  {
    if (a3)
    {
      sub_1834C6774();
    }
    else
    {
      if (v23 > v22)
      {
        sub_1834C558C(type metadata accessor for NWBrowser.Result, (uint64_t *)&unk_1E8F61B18, type metadata accessor for NWBrowser.Result, type metadata accessor for NWBrowser.Result);
        goto LABEL_21;
      }
      sub_1834C5DD4();
    }
    uint64_t v24 = *v3;
    sub_183D45AFC();
    uint64_t v49 = a1 + v7[5];
    NWEndpoint.hash(into:)();
    uint64_t v25 = sub_183D45B4C();
    uint64_t v26 = -1 << *(unsigned char *)(v24 + 32);
    a2 = v25 & ~v26;
    uint64_t v50 = v24;
    uint64_t v48 = v24 + 56;
    if ((*(void *)(v24 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a2))
    {
      uint64_t v47 = ~v26;
      uint64_t v46 = *(void *)(v45 + 72);
      uint64_t v43 = v7;
      uint64_t v44 = a1;
      while (1)
      {
        sub_18315E6C0(*(void *)(v50 + 48) + v46 * a2, (uint64_t)v21, type metadata accessor for NWBrowser.Result);
        char v27 = _s7Network10NWEndpointO2eeoiySbAC_ACtFZ_0((uint64_t)&v21[v7[5]], v49);
        sub_18315E6C0((uint64_t)v21, (uint64_t)v19, type metadata accessor for NWBrowser.Result);
        sub_18315E6C0(a1, (uint64_t)v16, type metadata accessor for NWBrowser.Result);
        if ((v27 & 1) == 0) {
          break;
        }
        char v28 = sub_18351461C(*(void *)&v19[v7[6]], *(void *)&v16[v7[6]]);
        sub_1834C94F4((uint64_t)v19, type metadata accessor for NWBrowser.Result);
        sub_1834C94F4((uint64_t)v16, type metadata accessor for NWBrowser.Result);
        sub_18315E6C0((uint64_t)v21, (uint64_t)v13, type metadata accessor for NWBrowser.Result);
        sub_18315E6C0(a1, (uint64_t)v10, type metadata accessor for NWBrowser.Result);
        if ((v28 & 1) == 0) {
          goto LABEL_11;
        }
        uint64_t v29 = v7[7];
        uint64_t v31 = *(void *)&v13[v29];
        uint64_t v30 = *(NSObject **)&v13[v29 + 8];
        int64_t v32 = (uint64_t *)&v10[v29];
        uint64_t v33 = *v32;
        uint64_t v34 = v32[1];
        if (!v31)
        {
          if (!v33) {
            goto LABEL_24;
          }
LABEL_20:
          sub_1834C4654(v31);
          sub_1834C4654(v33);
          sub_1834C80D8(v31);
          sub_1834C80D8(v33);
          uint64_t v7 = v43;
          a1 = v44;
LABEL_11:
          sub_1834C94F4((uint64_t)v10, type metadata accessor for NWBrowser.Result);
          sub_1834C94F4((uint64_t)v13, type metadata accessor for NWBrowser.Result);
          sub_1834C94F4((uint64_t)v21, type metadata accessor for NWBrowser.Result);
          goto LABEL_12;
        }
        if (!v33) {
          goto LABEL_20;
        }
        sub_1834C4654(v31);
        sub_1834C4654(v33);
        sub_1834C4654(v31);
        sub_1834C4654(v33);
        sub_1834C4654(v31);
        sub_1834C4654(v33);
        BOOL is_equal = nw_txt_record_is_equal(v30, v34);
        sub_1834C80D8(v31);
        sub_1834C80D8(v33);
        sub_1834C80D8(v33);
        sub_1834C80D8(v31);
        sub_1834C80D8(v33);
        sub_1834C80D8(v31);
        sub_1834C94F4((uint64_t)v10, type metadata accessor for NWBrowser.Result);
        sub_1834C94F4((uint64_t)v13, type metadata accessor for NWBrowser.Result);
        sub_1834C94F4((uint64_t)v21, type metadata accessor for NWBrowser.Result);
        uint64_t v7 = v43;
        a1 = v44;
        if (is_equal) {
          goto LABEL_25;
        }
LABEL_12:
        a2 = (a2 + 1) & v47;
        if (((*(void *)(v48 + ((a2 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a2) & 1) == 0) {
          goto LABEL_21;
        }
      }
      sub_1834C94F4((uint64_t)v19, type metadata accessor for NWBrowser.Result);
      sub_1834C94F4((uint64_t)v16, type metadata accessor for NWBrowser.Result);
      sub_18315E6C0((uint64_t)v21, (uint64_t)v13, type metadata accessor for NWBrowser.Result);
      sub_18315E6C0(a1, (uint64_t)v10, type metadata accessor for NWBrowser.Result);
      goto LABEL_11;
    }
  }
LABEL_21:
  uint64_t v35 = *v42;
  *(void *)(*v42 + 8 * (a2 >> 6) + 56) |= 1 << a2;
  uint64_t result = sub_1834C81A0(a1, *(void *)(v35 + 48) + *(void *)(v45 + 72) * a2, type metadata accessor for NWBrowser.Result);
  uint64_t v37 = *(void *)(v35 + 16);
  BOOL v38 = __OFADD__(v37, 1);
  uint64_t v39 = v37 + 1;
  if (v38)
  {
    __break(1u);
LABEL_24:
    sub_1834C80D8(0);
    sub_1834C80D8(0);
    sub_1834C94F4((uint64_t)v10, type metadata accessor for NWBrowser.Result);
    sub_1834C94F4((uint64_t)v13, type metadata accessor for NWBrowser.Result);
    sub_1834C94F4((uint64_t)v21, type metadata accessor for NWBrowser.Result);
LABEL_25:
    uint64_t result = sub_183D45A3C();
    __break(1u);
  }
  else
  {
    *(void *)(v35 + 16) = v39;
  }
  return result;
}

BOOL _s7Network9NWBrowserC6ResultV2eeoiySbAE_AEtFZ_0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = type metadata accessor for NWBrowser.Result(0);
  uint64_t v5 = MEMORY[0x1F4188790](v4);
  uint64_t v7 = (char *)&v27 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = MEMORY[0x1F4188790](v5);
  uint64_t v10 = (char *)&v27 - v9;
  uint64_t v11 = MEMORY[0x1F4188790](v8);
  unint64_t v13 = (char *)&v27 - v12;
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v16 = (char *)&v27 - v15;
  char v17 = _s7Network10NWEndpointO2eeoiySbAC_ACtFZ_0(a1 + *(int *)(v14 + 20), a2 + *(int *)(v14 + 20));
  sub_18315E6C0(a1, (uint64_t)v16, type metadata accessor for NWBrowser.Result);
  sub_18315E6C0(a2, (uint64_t)v13, type metadata accessor for NWBrowser.Result);
  if ((v17 & 1) == 0)
  {
    sub_1834C94F4((uint64_t)v16, type metadata accessor for NWBrowser.Result);
    sub_1834C94F4((uint64_t)v13, type metadata accessor for NWBrowser.Result);
    sub_18315E6C0(a1, (uint64_t)v10, type metadata accessor for NWBrowser.Result);
    sub_18315E6C0(a2, (uint64_t)v7, type metadata accessor for NWBrowser.Result);
    goto LABEL_7;
  }
  char v18 = sub_18351461C(*(void *)&v16[*(int *)(v4 + 24)], *(void *)&v13[*(int *)(v4 + 24)]);
  sub_1834C94F4((uint64_t)v16, type metadata accessor for NWBrowser.Result);
  sub_1834C94F4((uint64_t)v13, type metadata accessor for NWBrowser.Result);
  sub_18315E6C0(a1, (uint64_t)v10, type metadata accessor for NWBrowser.Result);
  sub_18315E6C0(a2, (uint64_t)v7, type metadata accessor for NWBrowser.Result);
  if ((v18 & 1) == 0)
  {
LABEL_7:
    BOOL is_equal = 0;
    goto LABEL_8;
  }
  uint64_t v19 = *(int *)(v4 + 28);
  uint64_t v21 = *(void *)&v10[v19];
  uint64_t v20 = *(NSObject **)&v10[v19 + 8];
  unint64_t v22 = (uint64_t *)&v7[v19];
  uint64_t v24 = *v22;
  unint64_t v23 = v22[1];
  if (!v21)
  {
    if (!v24)
    {
      sub_1834C80D8(0);
      sub_1834C80D8(0);
      BOOL is_equal = 1;
      goto LABEL_8;
    }
    goto LABEL_10;
  }
  if (!v24)
  {
LABEL_10:
    sub_1834C4654(v21);
    sub_1834C4654(v24);
    sub_1834C80D8(v21);
    sub_1834C80D8(v24);
    goto LABEL_7;
  }
  sub_1834C4654(v21);
  sub_1834C4654(v24);
  sub_1834C4654(v21);
  sub_1834C4654(v24);
  sub_1834C4654(v21);
  sub_1834C4654(v24);
  BOOL is_equal = nw_txt_record_is_equal(v20, v23);
  sub_1834C80D8(v21);
  sub_1834C80D8(v24);
  sub_1834C80D8(v24);
  sub_1834C80D8(v21);
  sub_1834C80D8(v24);
  sub_1834C80D8(v21);
LABEL_8:
  sub_1834C94F4((uint64_t)v7, type metadata accessor for NWBrowser.Result);
  sub_1834C94F4((uint64_t)v10, type metadata accessor for NWBrowser.Result);
  return is_equal;
}

BOOL _s7Network9NWBrowserC6ResultV6ChangeO2eeoiySbAG_AGtFZ_0(uint64_t a1, uint64_t a2)
{
  uint64_t v57 = a2;
  uint64_t v3 = type metadata accessor for NWBrowser.Result.Change(0);
  uint64_t v4 = MEMORY[0x1F4188790](v3);
  uint64_t v6 = (char *)&v50 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = MEMORY[0x1F4188790](v4);
  uint64_t v9 = (char *)&v50 - v8;
  MEMORY[0x1F4188790](v7);
  uint64_t v11 = (char *)&v50 - v10;
  uint64_t v12 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F619E8);
  uint64_t v13 = v12 - 8;
  MEMORY[0x1F4188790](v12);
  uint64_t v15 = (char *)&v50 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = type metadata accessor for NWBrowser.Result(0);
  uint64_t v17 = MEMORY[0x1F4188790](v16 - 8);
  uint64_t v51 = (uint64_t)&v50 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v52 = (uint64_t)&v50 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v56 = (uint64_t)&v50 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  uint64_t v55 = (uint64_t)&v50 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  uint64_t v54 = (uint64_t)&v50 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  uint64_t v53 = (uint64_t)&v50 - v28;
  uint64_t v29 = MEMORY[0x1F4188790](v27);
  uint64_t v31 = (char *)&v50 - v30;
  MEMORY[0x1F4188790](v29);
  uint64_t v33 = (char *)&v50 - v32;
  uint64_t v34 = (uint64_t)&v15[*(int *)(v13 + 56)];
  sub_18315E6C0(a1, (uint64_t)v15, type metadata accessor for NWBrowser.Result.Change);
  sub_18315E6C0(v57, v34, type metadata accessor for NWBrowser.Result.Change);
  switch(swift_getEnumCaseMultiPayload())
  {
    case 1u:
      sub_18315E6C0((uint64_t)v15, (uint64_t)v9, type metadata accessor for NWBrowser.Result.Change);
      uint64_t v11 = v9;
      if (swift_getEnumCaseMultiPayload() != 1) {
        goto LABEL_10;
      }
      goto LABEL_5;
    case 2u:
      sub_18315E6C0((uint64_t)v15, (uint64_t)v6, type metadata accessor for NWBrowser.Result.Change);
      uint64_t v36 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F619E0);
      uint64_t v37 = *(int *)(v36 + 48);
      uint64_t v38 = (uint64_t)&v6[v37];
      uint64_t v39 = *(int *)(v36 + 64);
      int v40 = v6[v39];
      if (swift_getEnumCaseMultiPayload() == 2)
      {
        uint64_t v41 = v34 + v37;
        LODWORD(v57) = *(unsigned __int8 *)(v34 + v39);
        uint64_t v42 = v53;
        sub_1834C81A0((uint64_t)v6, v53, type metadata accessor for NWBrowser.Result);
        uint64_t v43 = v54;
        sub_1834C81A0(v34, v54, type metadata accessor for NWBrowser.Result);
        uint64_t v44 = v55;
        sub_1834C81A0(v38, v55, type metadata accessor for NWBrowser.Result);
        uint64_t v45 = v56;
        sub_1834C81A0(v41, v56, type metadata accessor for NWBrowser.Result);
        LOBYTE(v41) = _s7Network9NWBrowserC6ResultV2eeoiySbAE_AEtFZ_0(v42, v43);
        uint64_t v46 = v52;
        sub_18315E6C0(v44, v52, type metadata accessor for NWBrowser.Result);
        uint64_t v47 = v51;
        sub_18315E6C0(v45, v51, type metadata accessor for NWBrowser.Result);
        if (v41)
        {
          BOOL v48 = _s7Network9NWBrowserC6ResultV2eeoiySbAE_AEtFZ_0(v46, v47);
          sub_1834C94F4(v47, type metadata accessor for NWBrowser.Result);
          sub_1834C94F4(v46, type metadata accessor for NWBrowser.Result);
          BOOL v35 = v48 && v40 == v57;
        }
        else
        {
          sub_1834C94F4(v47, type metadata accessor for NWBrowser.Result);
          sub_1834C94F4(v46, type metadata accessor for NWBrowser.Result);
          BOOL v35 = 0;
        }
        sub_1834C94F4(v45, type metadata accessor for NWBrowser.Result);
        sub_1834C94F4(v44, type metadata accessor for NWBrowser.Result);
        sub_1834C94F4(v43, type metadata accessor for NWBrowser.Result);
        sub_1834C94F4(v42, type metadata accessor for NWBrowser.Result);
        sub_1834C94F4((uint64_t)v15, type metadata accessor for NWBrowser.Result.Change);
      }
      else
      {
        sub_1834C94F4((uint64_t)&v6[v37], type metadata accessor for NWBrowser.Result);
        uint64_t v11 = v6;
LABEL_10:
        sub_1834C94F4((uint64_t)v11, type metadata accessor for NWBrowser.Result);
LABEL_11:
        sub_183138A24((uint64_t)v15, &qword_1E8F619E8);
        BOOL v35 = 0;
      }
      break;
    case 3u:
      goto LABEL_11;
    default:
      sub_18315E6C0((uint64_t)v15, (uint64_t)v11, type metadata accessor for NWBrowser.Result.Change);
      if (swift_getEnumCaseMultiPayload()) {
        goto LABEL_10;
      }
LABEL_5:
      sub_1834C81A0((uint64_t)v11, (uint64_t)v33, type metadata accessor for NWBrowser.Result);
      sub_1834C81A0(v34, (uint64_t)v31, type metadata accessor for NWBrowser.Result);
      sub_1834C94F4((uint64_t)v15, type metadata accessor for NWBrowser.Result.Change);
      BOOL v35 = _s7Network9NWBrowserC6ResultV2eeoiySbAE_AEtFZ_0((uint64_t)v33, (uint64_t)v31);
      sub_1834C94F4((uint64_t)v31, type metadata accessor for NWBrowser.Result);
      sub_1834C94F4((uint64_t)v33, type metadata accessor for NWBrowser.Result);
      break;
  }
  return v35;
}

uint64_t _s7Network9NWBrowserC6ResultV8MetadataO2eeoiySbAG_AGtFZ_0(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  uint64_t v5 = *a2;
  uint64_t v4 = a2[1];
  if (!*a1)
  {
    if (!v5)
    {
      sub_1834C80D8(0);
      sub_1834C80D8(0);
      return 1;
    }
    goto LABEL_5;
  }
  if (!v5)
  {
LABEL_5:
    sub_1834C4654(*a2);
    sub_1834C4654(v3);
    sub_1834C80D8(v3);
    sub_1834C80D8(v5);
    return 0;
  }
  sub_1834C4654(*a2);
  sub_1834C4654(v3);
  sub_1834C4654(v5);
  sub_1834C4654(v3);
  BOOL is_equal = nw_txt_record_is_equal(v2, v4);
  sub_1834C80D8(v3);
  sub_1834C80D8(v5);
  sub_1834C80D8(v5);
  sub_1834C80D8(v3);
  return is_equal;
}

uint64_t sub_1834C80D8(uint64_t result)
{
  if (result)
  {
    swift_bridgeObjectRelease();
    return swift_unknownObjectRelease();
  }
  return result;
}

uint64_t type metadata accessor for NWBrowser.Result.Change(uint64_t a1)
{
  return sub_18315A7F8(a1, (uint64_t *)&unk_1E8F61AD0);
}

uint64_t sub_1834C8138(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F61B08);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16))(a2, a1, v4);
  return a2;
}

uint64_t sub_1834C81A0(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v5 = a3(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 32))(a2, a1, v5);
  return a2;
}

uint64_t sub_1834C8208(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int8 a5)
{
  switch(a5 >> 5)
  {
    case 0:
    case 1:
    case 3:
      swift_bridgeObjectRetain();
      goto LABEL_3;
    case 2:
    case 4:
LABEL_3:
      uint64_t result = swift_bridgeObjectRetain();
      break;
    default:
      return result;
  }
  return result;
}

void sub_1834C8290(uint64_t a1)
{
  sub_183554B24(a1, *(_DWORD *)(v1 + 16), *(NSObject **)(v1 + 24));
}

uint64_t sub_1834C829C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int8 a5)
{
  uint64_t result = a2;
  switch(a5 >> 5)
  {
    case 0:
    case 1:
    case 3:
      swift_bridgeObjectRelease();
      goto LABEL_3;
    case 2:
    case 4:
LABEL_3:
      uint64_t result = swift_bridgeObjectRelease();
      break;
    default:
      return result;
  }
  return result;
}

unint64_t sub_1834C8324()
{
  unint64_t result = qword_1E8F62BF8;
  if (!qword_1E8F62BF8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F62BF8);
  }
  return result;
}

unint64_t sub_1834C837C()
{
  unint64_t result = qword_1E8F62C00;
  if (!qword_1E8F62C00)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F62C00);
  }
  return result;
}

unint64_t sub_1834C83D4()
{
  unint64_t result = qword_1E8F61CA8;
  if (!qword_1E8F61CA8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F61CA8);
  }
  return result;
}

unint64_t sub_1834C842C()
{
  unint64_t result = qword_1E8F61CB0;
  if (!qword_1E8F61CB0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F61CB0);
  }
  return result;
}

unint64_t sub_1834C8484()
{
  unint64_t result = qword_1E8F62C08;
  if (!qword_1E8F62C08)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F62C08);
  }
  return result;
}

unint64_t sub_1834C84DC()
{
  unint64_t result = qword_1E8F62C10;
  if (!qword_1E8F62C10)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F62C10);
  }
  return result;
}

unint64_t sub_1834C8534()
{
  unint64_t result = qword_1E8F62C18;
  if (!qword_1E8F62C18)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F62C18);
  }
  return result;
}

unint64_t sub_1834C858C()
{
  unint64_t result = qword_1E8F62C20;
  if (!qword_1E8F62C20)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F62C20);
  }
  return result;
}

unint64_t sub_1834C85E4()
{
  unint64_t result = qword_1E8F62C28;
  if (!qword_1E8F62C28)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F62C28);
  }
  return result;
}

unint64_t sub_1834C863C()
{
  unint64_t result = qword_1E8F62C30;
  if (!qword_1E8F62C30)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F62C30);
  }
  return result;
}

unint64_t sub_1834C8694()
{
  unint64_t result = qword_1E8F62C38;
  if (!qword_1E8F62C38)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F62C38);
  }
  return result;
}

unint64_t sub_1834C86EC()
{
  unint64_t result = qword_1E8F62C40;
  if (!qword_1E8F62C40)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F62C40);
  }
  return result;
}

uint64_t sub_1834C8740()
{
  return sub_1834C87D0(&qword_1E8F61AC8, (void (*)(uint64_t))type metadata accessor for NWBrowser.Result.Change);
}

uint64_t sub_1834C8788()
{
  return sub_1834C87D0((unint64_t *)&unk_1E8F61AE0, (void (*)(uint64_t))type metadata accessor for NWBrowser.Result);
}

uint64_t sub_1834C87D0(unint64_t *a1, void (*a2)(uint64_t))
{
  uint64_t result = *a1;
  if (!result)
  {
    a2(255);
    uint64_t result = swift_getWitnessTable();
    atomic_store(result, a1);
  }
  return result;
}

unint64_t sub_1834C881C()
{
  unint64_t result = qword_1E8F62C48;
  if (!qword_1E8F62C48)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F62C48);
  }
  return result;
}

uint64_t type metadata accessor for NWBrowser()
{
  return self;
}

uint64_t method lookup function for NWBrowser(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F4186708](a1, a2, &nominal type descriptor for NWBrowser);
}

uint64_t dispatch thunk of NWBrowser.__allocating_init(for:using:)()
{
  return (*(uint64_t (**)(void))(v0 + 112))();
}

uint64_t destroy for NWBrowser.Descriptor(uint64_t a1)
{
  return sub_1834C829C(*(void *)a1, *(void *)(a1 + 8), *(void *)(a1 + 16), *(void *)(a1 + 24), *(unsigned char *)(a1 + 32));
}

uint64_t initializeWithCopy for NWBrowser.Descriptor(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)a2;
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v6 = *(void *)(a2 + 24);
  unsigned __int8 v7 = *(unsigned char *)(a2 + 32);
  sub_1834C8208(*(void *)a2, v4, v5, v6, v7);
  *(void *)a1 = v3;
  *(void *)(a1 + 8) = v4;
  *(void *)(a1 + 16) = v5;
  *(void *)(a1 + 24) = v6;
  *(unsigned char *)(a1 + 32) = v7;
  return a1;
}

uint64_t assignWithCopy for NWBrowser.Descriptor(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)a2;
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v6 = *(void *)(a2 + 24);
  unsigned __int8 v7 = *(unsigned char *)(a2 + 32);
  sub_1834C8208(*(void *)a2, v4, v5, v6, v7);
  uint64_t v8 = *(void *)a1;
  uint64_t v9 = *(void *)(a1 + 8);
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v11 = *(void *)(a1 + 24);
  *(void *)a1 = v3;
  *(void *)(a1 + 8) = v4;
  *(void *)(a1 + 16) = v5;
  *(void *)(a1 + 24) = v6;
  unsigned __int8 v12 = *(unsigned char *)(a1 + 32);
  *(unsigned char *)(a1 + 32) = v7;
  sub_1834C829C(v8, v9, v10, v11, v12);
  return a1;
}

__n128 __swift_memcpy33_8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *(unsigned char *)(a1 + 32) = *(unsigned char *)(a2 + 32);
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

uint64_t assignWithTake for NWBrowser.Descriptor(uint64_t a1, uint64_t a2)
{
  char v3 = *(unsigned char *)(a2 + 32);
  uint64_t v4 = *(void *)a1;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v7 = *(void *)(a1 + 24);
  long long v8 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v8;
  unsigned __int8 v9 = *(unsigned char *)(a1 + 32);
  *(unsigned char *)(a1 + 32) = v3;
  sub_1834C829C(v4, v6, v5, v7, v9);
  return a1;
}

uint64_t getEnumTagSinglePayload for NWBrowser.Descriptor(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0x7C && *(unsigned char *)(a1 + 33)) {
    return (*(_DWORD *)a1 + 124);
  }
  unsigned int v3 = ((*(unsigned __int8 *)(a1 + 32) >> 5) & 0xFFFFFF87 | (8 * ((*(unsigned __int8 *)(a1 + 32) >> 1) & 0xF))) ^ 0x7F;
  if (v3 >= 0x7B) {
    unsigned int v3 = -1;
  }
  return v3 + 1;
}

uint64_t storeEnumTagSinglePayload for NWBrowser.Descriptor(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0x7B)
  {
    *(void *)(result + 16) = 0;
    *(void *)(result + 24) = 0;
    *(unsigned char *)(result + 32) = 0;
    *(void *)__n128 result = a2 - 124;
    *(void *)(result + 8) = 0;
    if (a3 >= 0x7C) {
      *(unsigned char *)(result + 33) = 1;
    }
  }
  else
  {
    if (a3 >= 0x7C) {
      *(unsigned char *)(result + 33) = 0;
    }
    if (a2)
    {
      *(_OWORD *)__n128 result = 0u;
      *(_OWORD *)(result + 16) = 0u;
      *(unsigned char *)(result + 32) = 2 * (((-a2 >> 3) & 0xF) - 16 * a2);
    }
  }
  return result;
}

uint64_t sub_1834C8ACC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 32) >> 5;
}

uint64_t sub_1834C8AD8(uint64_t result)
{
  *(unsigned char *)(result + 32) &= 0x1Fu;
  return result;
}

uint64_t sub_1834C8AE8(uint64_t result, char a2)
{
  *(unsigned char *)(result + 32) = *(unsigned char *)(result + 32) & 1 | (32 * a2);
  return result;
}

ValueMetadata *type metadata accessor for NWBrowser.Descriptor()
{
  return &type metadata for NWBrowser.Descriptor;
}

uint64_t sub_1834C8B10(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t assignWithCopy for NWBrowser.Descriptor.Options(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  return a1;
}

__n128 __swift_memcpy17_8(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  a1[1].n128_u8[0] = a2[1].n128_u8[0];
  *a1 = result;
  return result;
}

uint64_t assignWithTake for NWBrowser.Descriptor.Options(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  swift_bridgeObjectRelease();
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  return a1;
}

uint64_t getEnumTagSinglePayload for NWBrowser.Descriptor.Options(uint64_t *a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *((unsigned char *)a1 + 17)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for NWBrowser.Descriptor.Options(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(unsigned char *)(result + 16) = 0;
    *(void *)__n128 result = a2 ^ 0x80000000;
    *(void *)(result + 8) = 0;
    if (a3 < 0) {
      *(unsigned char *)(result + 17) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)__n128 result = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 17) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for NWBrowser.Descriptor.Options()
{
  return &type metadata for NWBrowser.Descriptor.Options;
}

ValueMetadata *type metadata accessor for NWBrowser.Descriptor.Options.Scope()
{
  return &type metadata for NWBrowser.Descriptor.Options.Scope;
}

ValueMetadata *type metadata accessor for NWBrowser.Descriptor.Options.DeviceType()
{
  return &type metadata for NWBrowser.Descriptor.Options.DeviceType;
}

uint64_t *initializeBufferWithCopyOfBuffer for NWBrowser.Result(uint64_t *a1, uint64_t *a2, int *a3)
{
  int v3 = *(_DWORD *)(*((void *)a3 - 1) + 80);
  uint64_t v4 = *a2;
  *a1 = *a2;
  if ((v3 & 0x20000) != 0)
  {
    uint64_t v7 = (uint64_t *)(v4 + ((v3 + 16) & ~(unint64_t)v3));
    swift_retain();
  }
  else
  {
    uint64_t v7 = a1;
    uint64_t v8 = a3[5];
    unsigned __int8 v9 = (char *)a1 + v8;
    uint64_t v10 = (char *)a2 + v8;
    type metadata accessor for NWEndpoint();
    swift_unknownObjectRetain();
    switch(swift_getEnumCaseMultiPayload())
    {
      case 1u:
        uint64_t v16 = *((void *)v10 + 1);
        *(void *)unsigned __int8 v9 = *(void *)v10;
        *((void *)v9 + 1) = v16;
        uint64_t v17 = *((void *)v10 + 3);
        *((void *)v9 + 2) = *((void *)v10 + 2);
        *((void *)v9 + 3) = v17;
        uint64_t v18 = *((void *)v10 + 5);
        *((void *)v9 + 4) = *((void *)v10 + 4);
        *((void *)v9 + 5) = v18;
        uint64_t v19 = *((void *)v10 + 6);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        if (v19 != 1) {
          swift_unknownObjectRetain();
        }
        *((void *)v9 + 6) = v19;
        break;
      case 2u:
        uint64_t v14 = *((void *)v10 + 1);
        *(void *)unsigned __int8 v9 = *(void *)v10;
        *((void *)v9 + 1) = v14;
        swift_bridgeObjectRetain();
        break;
      case 3u:
        uint64_t v15 = sub_183D4447C();
        (*(void (**)(char *, char *, uint64_t))(*(void *)(v15 - 8) + 16))(v9, v10, v15);
        break;
      case 4u:
        *(void *)unsigned __int8 v9 = *(void *)v10;
        swift_unknownObjectRetain();
        break;
      default:
        uint64_t v11 = *(void *)v10;
        uint64_t v12 = *((void *)v10 + 1);
        uint64_t v13 = *((void *)v10 + 2);
        char v26 = v10[24];
        sub_18315E9E4(*(void *)v10, v12, v13, v26);
        *(void *)unsigned __int8 v9 = v11;
        *((void *)v9 + 1) = v12;
        *((void *)v9 + 2) = v13;
        v9[24] = v26;
        *((_WORD *)v9 + 13) = *((_WORD *)v10 + 13);
        break;
    }
    swift_storeEnumTagMultiPayload();
    uint64_t v20 = a3[7];
    *(uint64_t *)((char *)v7 + a3[6]) = *(uint64_t *)((char *)a2 + a3[6]);
    uint64_t v21 = (uint64_t *)((char *)v7 + v20);
    uint64_t v22 = (char *)a2 + v20;
    uint64_t v23 = *(uint64_t *)((char *)a2 + v20);
    swift_bridgeObjectRetain();
    if (v23)
    {
      uint64_t v24 = *((void *)v22 + 1);
      void *v21 = v23;
      v21[1] = v24;
      swift_bridgeObjectRetain();
      swift_unknownObjectRetain();
    }
    else
    {
      *(_OWORD *)uint64_t v21 = *(_OWORD *)v22;
    }
  }
  return v7;
}

uint64_t destroy for NWBrowser.Result(uint64_t a1, uint64_t a2)
{
  swift_unknownObjectRelease();
  uint64_t v4 = a1 + *(int *)(a2 + 20);
  type metadata accessor for NWEndpoint();
  switch(swift_getEnumCaseMultiPayload())
  {
    case 0u:
      sub_18315E658(*(void *)v4, *(void *)(v4 + 8), *(void *)(v4 + 16), *(unsigned char *)(v4 + 24));
      break;
    case 1u:
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      if (*(void *)(v4 + 48) != 1) {
        goto LABEL_7;
      }
      break;
    case 2u:
      swift_bridgeObjectRelease();
      break;
    case 3u:
      uint64_t v5 = sub_183D4447C();
      (*(void (**)(uint64_t, uint64_t))(*(void *)(v5 - 8) + 8))(v4, v5);
      break;
    case 4u:
LABEL_7:
      swift_unknownObjectRelease();
      break;
    default:
      break;
  }
  swift_bridgeObjectRelease();
  uint64_t result = *(void *)(a1 + *(int *)(a2 + 28));
  if (result)
  {
    swift_bridgeObjectRelease();
    return swift_unknownObjectRelease();
  }
  return result;
}

void *initializeWithCopy for NWBrowser.Result(void *a1, void *a2, int *a3)
{
  *a1 = *a2;
  uint64_t v6 = a3[5];
  uint64_t v7 = (char *)a1 + v6;
  uint64_t v8 = (char *)a2 + v6;
  type metadata accessor for NWEndpoint();
  swift_unknownObjectRetain();
  switch(swift_getEnumCaseMultiPayload())
  {
    case 1u:
      uint64_t v12 = *((void *)v8 + 1);
      *(void *)uint64_t v7 = *(void *)v8;
      *((void *)v7 + 1) = v12;
      uint64_t v13 = *((void *)v8 + 3);
      *((void *)v7 + 2) = *((void *)v8 + 2);
      *((void *)v7 + 3) = v13;
      uint64_t v14 = *((void *)v8 + 5);
      *((void *)v7 + 4) = *((void *)v8 + 4);
      *((void *)v7 + 5) = v14;
      uint64_t v15 = *((void *)v8 + 6);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      if (v15 != 1) {
        swift_unknownObjectRetain();
      }
      *((void *)v7 + 6) = v15;
      break;
    case 2u:
      uint64_t v16 = *((void *)v8 + 1);
      *(void *)uint64_t v7 = *(void *)v8;
      *((void *)v7 + 1) = v16;
      swift_bridgeObjectRetain();
      break;
    case 3u:
      uint64_t v17 = sub_183D4447C();
      (*(void (**)(char *, char *, uint64_t))(*(void *)(v17 - 8) + 16))(v7, v8, v17);
      break;
    case 4u:
      *(void *)uint64_t v7 = *(void *)v8;
      swift_unknownObjectRetain();
      break;
    default:
      uint64_t v9 = *(void *)v8;
      uint64_t v10 = *((void *)v8 + 1);
      uint64_t v11 = *((void *)v8 + 2);
      char v24 = v8[24];
      sub_18315E9E4(*(void *)v8, v10, v11, v24);
      *(void *)uint64_t v7 = v9;
      *((void *)v7 + 1) = v10;
      *((void *)v7 + 2) = v11;
      v7[24] = v24;
      *((_WORD *)v7 + 13) = *((_WORD *)v8 + 13);
      break;
  }
  swift_storeEnumTagMultiPayload();
  uint64_t v18 = a3[7];
  *(void *)((char *)a1 + a3[6]) = *(void *)((char *)a2 + a3[6]);
  uint64_t v19 = (void *)((char *)a1 + v18);
  uint64_t v20 = (char *)a2 + v18;
  uint64_t v21 = *(void *)((char *)a2 + v18);
  swift_bridgeObjectRetain();
  if (v21)
  {
    uint64_t v22 = *((void *)v20 + 1);
    void *v19 = v21;
    v19[1] = v22;
    swift_bridgeObjectRetain();
    swift_unknownObjectRetain();
  }
  else
  {
    *(_OWORD *)uint64_t v19 = *(_OWORD *)v20;
  }
  return a1;
}

void *assignWithCopy for NWBrowser.Result(void *a1, void *a2, int *a3)
{
  *a1 = *a2;
  swift_unknownObjectRetain();
  swift_unknownObjectRelease();
  if (a1 != a2)
  {
    uint64_t v6 = a3[5];
    uint64_t v7 = (char *)a1 + v6;
    uint64_t v8 = (char *)a2 + v6;
    sub_1834C94F4((uint64_t)a1 + v6, (uint64_t (*)(void))type metadata accessor for NWEndpoint);
    type metadata accessor for NWEndpoint();
    switch(swift_getEnumCaseMultiPayload())
    {
      case 1u:
        *(void *)uint64_t v7 = *(void *)v8;
        *((void *)v7 + 1) = *((void *)v8 + 1);
        *((void *)v7 + 2) = *((void *)v8 + 2);
        *((void *)v7 + 3) = *((void *)v8 + 3);
        *((void *)v7 + 4) = *((void *)v8 + 4);
        *((void *)v7 + 5) = *((void *)v8 + 5);
        uint64_t v13 = *((void *)v8 + 6);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        if (v13 != 1) {
          swift_unknownObjectRetain();
        }
        *((void *)v7 + 6) = v13;
        break;
      case 2u:
        *(void *)uint64_t v7 = *(void *)v8;
        *((void *)v7 + 1) = *((void *)v8 + 1);
        swift_bridgeObjectRetain();
        break;
      case 3u:
        uint64_t v12 = sub_183D4447C();
        (*(void (**)(char *, char *, uint64_t))(*(void *)(v12 - 8) + 16))(v7, v8, v12);
        break;
      case 4u:
        *(void *)uint64_t v7 = *(void *)v8;
        swift_unknownObjectRetain();
        break;
      default:
        uint64_t v9 = *(void *)v8;
        uint64_t v10 = *((void *)v8 + 1);
        uint64_t v11 = *((void *)v8 + 2);
        char v19 = v8[24];
        sub_18315E9E4(*(void *)v8, v10, v11, v19);
        *(void *)uint64_t v7 = v9;
        *((void *)v7 + 1) = v10;
        *((void *)v7 + 2) = v11;
        v7[24] = v19;
        *((_WORD *)v7 + 13) = *((_WORD *)v8 + 13);
        break;
    }
    swift_storeEnumTagMultiPayload();
  }
  *(void *)((char *)a1 + a3[6]) = *(void *)((char *)a2 + a3[6]);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v14 = a3[7];
  uint64_t v15 = (void *)((char *)a1 + v14);
  uint64_t v16 = (char *)a2 + v14;
  uint64_t v17 = *(void *)((char *)a2 + v14);
  if (!*(void *)((char *)a1 + v14))
  {
    if (v17)
    {
      void *v15 = v17;
      v15[1] = *((void *)v16 + 1);
      swift_bridgeObjectRetain();
      swift_unknownObjectRetain();
      return a1;
    }
LABEL_17:
    *(_OWORD *)uint64_t v15 = *(_OWORD *)v16;
    return a1;
  }
  if (!v17)
  {
    sub_1834C9554((uint64_t)a1 + v14);
    goto LABEL_17;
  }
  void *v15 = v17;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v15[1] = *((void *)v16 + 1);
  swift_unknownObjectRetain();
  swift_unknownObjectRelease();
  return a1;
}

uint64_t sub_1834C94F4(uint64_t a1, uint64_t (*a2)(void))
{
  uint64_t v3 = a2(0);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v3 - 8) + 8))(a1, v3);
  return a1;
}

uint64_t sub_1834C9554(uint64_t a1)
{
  return a1;
}

void *initializeWithTake for NWBrowser.Result(void *a1, void *a2, int *a3)
{
  *a1 = *a2;
  uint64_t v6 = a3[5];
  uint64_t v7 = (char *)a1 + v6;
  uint64_t v8 = (char *)a2 + v6;
  uint64_t v9 = type metadata accessor for NWEndpoint();
  if (swift_getEnumCaseMultiPayload() == 3)
  {
    uint64_t v10 = sub_183D4447C();
    (*(void (**)(char *, char *, uint64_t))(*(void *)(v10 - 8) + 32))(v7, v8, v10);
    swift_storeEnumTagMultiPayload();
  }
  else
  {
    memcpy(v7, v8, *(void *)(*(void *)(v9 - 8) + 64));
  }
  uint64_t v11 = a3[7];
  *(void *)((char *)a1 + a3[6]) = *(void *)((char *)a2 + a3[6]);
  *(_OWORD *)((char *)a1 + v11) = *(_OWORD *)((char *)a2 + v11);
  return a1;
}

void *assignWithTake for NWBrowser.Result(void *a1, void *a2, int *a3)
{
  *a1 = *a2;
  swift_unknownObjectRelease();
  if (a1 != a2)
  {
    uint64_t v6 = a3[5];
    uint64_t v7 = (char *)a1 + v6;
    uint64_t v8 = (char *)a2 + v6;
    sub_1834C94F4((uint64_t)a1 + v6, (uint64_t (*)(void))type metadata accessor for NWEndpoint);
    uint64_t v9 = type metadata accessor for NWEndpoint();
    if (swift_getEnumCaseMultiPayload() == 3)
    {
      uint64_t v10 = sub_183D4447C();
      (*(void (**)(char *, char *, uint64_t))(*(void *)(v10 - 8) + 32))(v7, v8, v10);
      swift_storeEnumTagMultiPayload();
    }
    else
    {
      memcpy(v7, v8, *(void *)(*(void *)(v9 - 8) + 64));
    }
  }
  *(void *)((char *)a1 + a3[6]) = *(void *)((char *)a2 + a3[6]);
  swift_bridgeObjectRelease();
  uint64_t v11 = a3[7];
  uint64_t v12 = (uint64_t)a1 + v11;
  uint64_t v13 = (char *)a2 + v11;
  if (!*(void *)((char *)a1 + v11)) {
    goto LABEL_9;
  }
  if (!*(void *)v13)
  {
    sub_1834C9554(v12);
LABEL_9:
    *(_OWORD *)uint64_t v12 = *(_OWORD *)v13;
    return a1;
  }
  *(void *)uint64_t v12 = *(void *)v13;
  swift_bridgeObjectRelease();
  *(void *)(v12 + 8) = *((void *)v13 + 1);
  swift_unknownObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for NWBrowser.Result(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4186578](a1, a2, a3, sub_1834C9818);
}

uint64_t sub_1834C9818(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  if (a2 == 0x7FFFFFFF)
  {
    uint64_t v4 = *a1;
    if ((unint64_t)*a1 >= 0xFFFFFFFF) {
      LODWORD(v4) = -1;
    }
    return (v4 + 1);
  }
  else
  {
    uint64_t v8 = type metadata accessor for NWEndpoint();
    uint64_t v9 = *(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(v8 - 8) + 48);
    uint64_t v10 = v8;
    uint64_t v11 = (char *)a1 + *(int *)(a3 + 20);
    return v9(v11, a2, v10);
  }
}

uint64_t storeEnumTagSinglePayload for NWBrowser.Result(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F41867C0](a1, a2, a3, a4, sub_1834C98DC);
}

void *sub_1834C98DC(void *result, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v5 = result;
  if (a3 == 0x7FFFFFFF)
  {
    *uint64_t result = (a2 - 1);
  }
  else
  {
    uint64_t v7 = type metadata accessor for NWEndpoint();
    uint64_t v8 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v7 - 8) + 56);
    uint64_t v9 = v7;
    uint64_t v10 = (char *)v5 + *(int *)(a4 + 20);
    return (void *)v8(v10, a2, a2, v9);
  }
  return result;
}

uint64_t sub_1834C9984()
{
  uint64_t result = type metadata accessor for NWEndpoint();
  if (v1 <= 0x3F)
  {
    swift_initStructMetadata();
    return 0;
  }
  return result;
}

unint64_t destroy for NWBrowser.Result.Metadata(unint64_t *a1)
{
  unint64_t result = *a1;
  if (result >= 0xFFFFFFFF)
  {
    swift_bridgeObjectRelease();
    return swift_unknownObjectRelease();
  }
  return result;
}

uint64_t _s7Network9NWBrowserC6ResultV8MetadataOwCP_0(uint64_t a1, uint64_t a2)
{
  if (*(void *)a2 < 0xFFFFFFFFuLL)
  {
    *(_OWORD *)a1 = *(_OWORD *)a2;
  }
  else
  {
    uint64_t v3 = *(void *)(a2 + 8);
    *(void *)a1 = *(void *)a2;
    *(void *)(a1 + 8) = v3;
    swift_bridgeObjectRetain();
    swift_unknownObjectRetain();
  }
  return a1;
}

unint64_t *assignWithCopy for NWBrowser.Result.Metadata(unint64_t *a1, unint64_t *a2)
{
  unint64_t v4 = *a1;
  unint64_t v5 = *a2;
  if (v4 < 0xFFFFFFFF)
  {
    if (v5 >= 0xFFFFFFFF)
    {
      *a1 = v5;
      a1[1] = a2[1];
      swift_bridgeObjectRetain();
      swift_unknownObjectRetain();
      return a1;
    }
LABEL_7:
    *(_OWORD *)a1 = *(_OWORD *)a2;
    return a1;
  }
  if (v5 < 0xFFFFFFFF)
  {
    swift_bridgeObjectRelease();
    swift_unknownObjectRelease();
    goto LABEL_7;
  }
  *a1 = v5;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  a1[1] = a2[1];
  swift_unknownObjectRetain();
  swift_unknownObjectRelease();
  return a1;
}

void *assignWithTake for NWBrowser.Result.Metadata(void *a1, uint64_t a2)
{
  if (*a1 < 0xFFFFFFFFuLL) {
    goto LABEL_5;
  }
  if (*(void *)a2 < 0xFFFFFFFFuLL)
  {
    swift_bridgeObjectRelease();
    swift_unknownObjectRelease();
LABEL_5:
    *(_OWORD *)a1 = *(_OWORD *)a2;
    return a1;
  }
  *a1 = *(void *)a2;
  swift_bridgeObjectRelease();
  a1[1] = *(void *)(a2 + 8);
  swift_unknownObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for NWBrowser.Result.Metadata(uint64_t *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0x7FFFFFFF && *((unsigned char *)a1 + 16)) {
    return (*(_DWORD *)a1 + 0x7FFFFFFF);
  }
  uint64_t v3 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF) {
    LODWORD(v3) = -1;
  }
  if ((v3 + 1) >= 2) {
    return v3;
  }
  else {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for NWBrowser.Result.Metadata(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0x7FFFFFFE)
  {
    *(void *)unint64_t result = 0;
    *(void *)(result + 8) = 0;
    *(_DWORD *)unint64_t result = a2 - 0x7FFFFFFF;
    if (a3 >= 0x7FFFFFFF) {
      *(unsigned char *)(result + 16) = 1;
    }
  }
  else
  {
    if (a3 >= 0x7FFFFFFF) {
      *(unsigned char *)(result + 16) = 0;
    }
    if (a2) {
      *(void *)unint64_t result = a2;
    }
  }
  return result;
}

uint64_t sub_1834C9CB8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF) {
    LODWORD(v1) = -1;
  }
  return (v1 + 1);
}

ValueMetadata *type metadata accessor for NWBrowser.Result.Metadata()
{
  return &type metadata for NWBrowser.Result.Metadata;
}

void *initializeBufferWithCopyOfBuffer for NWBrowser.Result.Change(void *a1, void *a2, uint64_t a3)
{
  int v5 = *(_DWORD *)(*(void *)(a3 - 8) + 80);
  if ((v5 & 0x20000) != 0)
  {
    uint64_t v14 = *a2;
    *a1 = *a2;
    a1 = (void *)(v14 + ((v5 + 16) & ~(unint64_t)v5));
    swift_retain();
  }
  else
  {
    uint64_t v6 = *(void *)(a3 - 8);
    int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
    switch(EnumCaseMultiPayload)
    {
      case 2:
        *a1 = *a2;
        uint64_t v16 = (int *)type metadata accessor for NWBrowser.Result(0);
        uint64_t v17 = v16[5];
        uint64_t v18 = (char *)a1 + v17;
        char v19 = (char *)a2 + v17;
        type metadata accessor for NWEndpoint();
        swift_unknownObjectRetain();
        switch(swift_getEnumCaseMultiPayload())
        {
          case 1u:
            uint64_t v31 = *((void *)v19 + 1);
            *(void *)uint64_t v18 = *(void *)v19;
            *((void *)v18 + 1) = v31;
            uint64_t v32 = *((void *)v19 + 3);
            *((void *)v18 + 2) = *((void *)v19 + 2);
            *((void *)v18 + 3) = v32;
            uint64_t v33 = *((void *)v19 + 5);
            *((void *)v18 + 4) = *((void *)v19 + 4);
            *((void *)v18 + 5) = v33;
            uint64_t v34 = *((void *)v19 + 6);
            swift_bridgeObjectRetain();
            swift_bridgeObjectRetain();
            swift_bridgeObjectRetain();
            if (v34 != 1) {
              swift_unknownObjectRetain();
            }
            *((void *)v18 + 6) = v34;
            break;
          case 2u:
            uint64_t v35 = *((void *)v19 + 1);
            *(void *)uint64_t v18 = *(void *)v19;
            *((void *)v18 + 1) = v35;
            swift_bridgeObjectRetain();
            break;
          case 3u:
            uint64_t v36 = sub_183D4447C();
            (*(void (**)(char *, char *, uint64_t))(*(void *)(v36 - 8) + 16))(v18, v19, v36);
            break;
          case 4u:
            *(void *)uint64_t v18 = *(void *)v19;
            swift_unknownObjectRetain();
            break;
          default:
            uint64_t v20 = *(void *)v19;
            uint64_t v21 = *((void *)v19 + 1);
            uint64_t v22 = *((void *)v19 + 2);
            char v82 = v19[24];
            sub_18315E9E4(*(void *)v19, v21, v22, v82);
            *(void *)uint64_t v18 = v20;
            *((void *)v18 + 1) = v21;
            *((void *)v18 + 2) = v22;
            v18[24] = v82;
            *((_WORD *)v18 + 13) = *((_WORD *)v19 + 13);
            break;
        }
        swift_storeEnumTagMultiPayload();
        *(void *)((char *)a1 + v16[6]) = *(void *)((char *)a2 + v16[6]);
        uint64_t v37 = v16[7];
        uint64_t v38 = (void *)((char *)a1 + v37);
        uint64_t v39 = (char *)a2 + v37;
        uint64_t v40 = *(void *)((char *)a2 + v37);
        swift_bridgeObjectRetain();
        if (v40)
        {
          uint64_t v41 = *((void *)v39 + 1);
          *uint64_t v38 = v40;
          v38[1] = v41;
          swift_bridgeObjectRetain();
          swift_unknownObjectRetain();
        }
        else
        {
          *(_OWORD *)uint64_t v38 = *(_OWORD *)v39;
        }
        uint64_t v84 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F619E0);
        uint64_t v42 = *(int *)(v84 + 48);
        uint64_t v43 = (void *)((char *)a1 + v42);
        uint64_t v44 = (char *)a2 + v42;
        *uint64_t v43 = *(void *)((char *)a2 + v42);
        uint64_t v45 = v16[5];
        uint64_t v46 = (char *)v43 + v45;
        uint64_t v47 = &v44[v45];
        swift_unknownObjectRetain();
        switch(swift_getEnumCaseMultiPayload())
        {
          case 1u:
            uint64_t v60 = *((void *)v47 + 1);
            *(void *)uint64_t v46 = *(void *)v47;
            *((void *)v46 + 1) = v60;
            uint64_t v61 = *((void *)v47 + 3);
            *((void *)v46 + 2) = *((void *)v47 + 2);
            *((void *)v46 + 3) = v61;
            uint64_t v62 = *((void *)v47 + 5);
            *((void *)v46 + 4) = *((void *)v47 + 4);
            *((void *)v46 + 5) = v62;
            uint64_t v63 = *((void *)v47 + 6);
            swift_bridgeObjectRetain();
            swift_bridgeObjectRetain();
            swift_bridgeObjectRetain();
            if (v63 != 1) {
              swift_unknownObjectRetain();
            }
            *((void *)v46 + 6) = v63;
            break;
          case 2u:
            uint64_t v64 = *((void *)v47 + 1);
            *(void *)uint64_t v46 = *(void *)v47;
            *((void *)v46 + 1) = v64;
            swift_bridgeObjectRetain();
            break;
          case 3u:
            uint64_t v65 = sub_183D4447C();
            (*(void (**)(char *, char *, uint64_t))(*(void *)(v65 - 8) + 16))(v46, v47, v65);
            break;
          case 4u:
            *(void *)uint64_t v46 = *(void *)v47;
            swift_unknownObjectRetain();
            break;
          default:
            uint64_t v78 = *(void *)v47;
            uint64_t v48 = *((void *)v47 + 1);
            uint64_t v77 = *((void *)v47 + 2);
            char v76 = v47[24];
            sub_18315E9E4(*(void *)v47, v48, v77, v76);
            *(void *)uint64_t v46 = v78;
            *((void *)v46 + 1) = v48;
            *((void *)v46 + 2) = v77;
            v46[24] = v76;
            *((_WORD *)v46 + 13) = *((_WORD *)v47 + 13);
            break;
        }
        swift_storeEnumTagMultiPayload();
        *(void *)((char *)v43 + v16[6]) = *(void *)&v44[v16[6]];
        uint64_t v66 = v16[7];
        char v67 = (void *)((char *)v43 + v66);
        uint64_t v68 = &v44[v66];
        uint64_t v69 = *(void *)&v44[v66];
        swift_bridgeObjectRetain();
        if (v69)
        {
          uint64_t v70 = *((void *)v68 + 1);
          *char v67 = v69;
          v67[1] = v70;
          swift_bridgeObjectRetain();
          swift_unknownObjectRetain();
        }
        else
        {
          *(_OWORD *)char v67 = *(_OWORD *)v68;
        }
        *((unsigned char *)a1 + *(int *)(v84 + 64)) = *((unsigned char *)a2 + *(int *)(v84 + 64));
        swift_storeEnumTagMultiPayload();
        break;
      case 1:
        *a1 = *a2;
        uint64_t v23 = (int *)type metadata accessor for NWBrowser.Result(0);
        uint64_t v24 = v23[5];
        uint64_t v25 = (char *)a1 + v24;
        char v26 = (char *)a2 + v24;
        type metadata accessor for NWEndpoint();
        swift_unknownObjectRetain();
        switch(swift_getEnumCaseMultiPayload())
        {
          case 1u:
            uint64_t v49 = *((void *)v26 + 1);
            *(void *)uint64_t v25 = *(void *)v26;
            *((void *)v25 + 1) = v49;
            uint64_t v50 = *((void *)v26 + 3);
            *((void *)v25 + 2) = *((void *)v26 + 2);
            *((void *)v25 + 3) = v50;
            uint64_t v51 = *((void *)v26 + 5);
            *((void *)v25 + 4) = *((void *)v26 + 4);
            *((void *)v25 + 5) = v51;
            uint64_t v52 = *((void *)v26 + 6);
            swift_bridgeObjectRetain();
            swift_bridgeObjectRetain();
            swift_bridgeObjectRetain();
            if (v52 != 1) {
              swift_unknownObjectRetain();
            }
            *((void *)v25 + 6) = v52;
            break;
          case 2u:
            uint64_t v53 = *((void *)v26 + 1);
            *(void *)uint64_t v25 = *(void *)v26;
            *((void *)v25 + 1) = v53;
            swift_bridgeObjectRetain();
            break;
          case 3u:
            uint64_t v54 = sub_183D4447C();
            (*(void (**)(char *, char *, uint64_t))(*(void *)(v54 - 8) + 16))(v25, v26, v54);
            break;
          case 4u:
            *(void *)uint64_t v25 = *(void *)v26;
            swift_unknownObjectRetain();
            break;
          default:
            uint64_t v27 = *(void *)v26;
            uint64_t v28 = *((void *)v26 + 1);
            uint64_t v83 = *((void *)v26 + 2);
            char v80 = v26[24];
            sub_18315E9E4(*(void *)v26, v28, v83, v80);
            *(void *)uint64_t v25 = v27;
            *((void *)v25 + 1) = v28;
            *((void *)v25 + 2) = v83;
            v25[24] = v80;
            *((_WORD *)v25 + 13) = *((_WORD *)v26 + 13);
            break;
        }
        swift_storeEnumTagMultiPayload();
        *(void *)((char *)a1 + v23[6]) = *(void *)((char *)a2 + v23[6]);
        uint64_t v55 = v23[7];
        uint64_t v56 = (char *)a1 + v55;
        uint64_t v57 = (char *)a2 + v55;
        uint64_t v58 = *(void *)((char *)a2 + v55);
        swift_bridgeObjectRetain();
        if (!v58)
        {
          *(_OWORD *)uint64_t v56 = *(_OWORD *)v57;
          goto LABEL_37;
        }
LABEL_35:
        uint64_t v59 = *((void *)v57 + 1);
        *(void *)uint64_t v56 = v58;
        *((void *)v56 + 1) = v59;
        swift_bridgeObjectRetain();
        swift_unknownObjectRetain();
LABEL_37:
        swift_storeEnumTagMultiPayload();
        return a1;
      case 0:
        *a1 = *a2;
        uint64_t v8 = (int *)type metadata accessor for NWBrowser.Result(0);
        uint64_t v9 = v8[5];
        uint64_t v10 = (char *)a1 + v9;
        uint64_t v11 = (char *)a2 + v9;
        type metadata accessor for NWEndpoint();
        swift_unknownObjectRetain();
        switch(swift_getEnumCaseMultiPayload())
        {
          case 1u:
            uint64_t v71 = *((void *)v11 + 1);
            *(void *)uint64_t v10 = *(void *)v11;
            *((void *)v10 + 1) = v71;
            uint64_t v72 = *((void *)v11 + 3);
            *((void *)v10 + 2) = *((void *)v11 + 2);
            *((void *)v10 + 3) = v72;
            uint64_t v73 = *((void *)v11 + 5);
            *((void *)v10 + 4) = *((void *)v11 + 4);
            *((void *)v10 + 5) = v73;
            uint64_t v74 = *((void *)v11 + 6);
            swift_bridgeObjectRetain();
            swift_bridgeObjectRetain();
            swift_bridgeObjectRetain();
            if (v74 != 1) {
              swift_unknownObjectRetain();
            }
            *((void *)v10 + 6) = v74;
            break;
          case 2u:
            uint64_t v29 = *((void *)v11 + 1);
            *(void *)uint64_t v10 = *(void *)v11;
            *((void *)v10 + 1) = v29;
            swift_bridgeObjectRetain();
            break;
          case 3u:
            uint64_t v30 = sub_183D4447C();
            (*(void (**)(char *, char *, uint64_t))(*(void *)(v30 - 8) + 16))(v10, v11, v30);
            break;
          case 4u:
            *(void *)uint64_t v10 = *(void *)v11;
            swift_unknownObjectRetain();
            break;
          default:
            uint64_t v12 = *(void *)v11;
            uint64_t v13 = *((void *)v11 + 1);
            uint64_t v81 = *((void *)v11 + 2);
            char v79 = v11[24];
            sub_18315E9E4(*(void *)v11, v13, v81, v79);
            *(void *)uint64_t v10 = v12;
            *((void *)v10 + 1) = v13;
            *((void *)v10 + 2) = v81;
            v10[24] = v79;
            *((_WORD *)v10 + 13) = *((_WORD *)v11 + 13);
            break;
        }
        swift_storeEnumTagMultiPayload();
        *(void *)((char *)a1 + v8[6]) = *(void *)((char *)a2 + v8[6]);
        uint64_t v75 = v8[7];
        uint64_t v56 = (char *)a1 + v75;
        uint64_t v57 = (char *)a2 + v75;
        uint64_t v58 = *(void *)((char *)a2 + v75);
        swift_bridgeObjectRetain();
        if (!v58)
        {
          *(_OWORD *)uint64_t v56 = *(_OWORD *)v57;
          goto LABEL_37;
        }
        goto LABEL_35;
      default:
        memcpy(a1, a2, *(void *)(v6 + 64));
        break;
    }
  }
  return a1;
}

uint64_t destroy for NWBrowser.Result.Change(uint64_t a1)
{
  uint64_t result = swift_getEnumCaseMultiPayload();
  if (result == 2)
  {
    swift_unknownObjectRelease();
    uint64_t v5 = type metadata accessor for NWBrowser.Result(0);
    uint64_t v6 = a1 + *(int *)(v5 + 20);
    type metadata accessor for NWEndpoint();
    switch(swift_getEnumCaseMultiPayload())
    {
      case 0u:
        sub_18315E658(*(void *)v6, *(void *)(v6 + 8), *(void *)(v6 + 16), *(unsigned char *)(v6 + 24));
        break;
      case 1u:
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        if (*(void *)(v6 + 48) != 1) {
          goto LABEL_22;
        }
        break;
      case 2u:
        swift_bridgeObjectRelease();
        break;
      case 3u:
        uint64_t v8 = sub_183D4447C();
        (*(void (**)(uint64_t, uint64_t))(*(void *)(v8 - 8) + 8))(v6, v8);
        break;
      case 4u:
LABEL_22:
        swift_unknownObjectRelease();
        break;
      default:
        break;
    }
    swift_bridgeObjectRelease();
    if (*(void *)(a1 + *(int *)(v5 + 28)))
    {
      swift_bridgeObjectRelease();
      swift_unknownObjectRelease();
    }
    uint64_t v9 = a1 + *(int *)(__swift_instantiateConcreteTypeFromMangledName(&qword_1E8F619E0) + 48);
    swift_unknownObjectRelease();
    uint64_t v10 = v9 + *(int *)(v5 + 20);
    switch(swift_getEnumCaseMultiPayload())
    {
      case 0u:
        sub_18315E658(*(void *)v10, *(void *)(v10 + 8), *(void *)(v10 + 16), *(unsigned char *)(v10 + 24));
        break;
      case 1u:
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        if (*(void *)(v10 + 48) != 1) {
          goto LABEL_31;
        }
        break;
      case 2u:
        swift_bridgeObjectRelease();
        break;
      case 3u:
        uint64_t v11 = sub_183D4447C();
        (*(void (**)(uint64_t, uint64_t))(*(void *)(v11 - 8) + 8))(v10, v11);
        break;
      case 4u:
LABEL_31:
        swift_unknownObjectRelease();
        break;
      default:
        break;
    }
    swift_bridgeObjectRelease();
    uint64_t result = *(void *)(v9 + *(int *)(v5 + 28));
    if (result)
    {
LABEL_15:
      swift_bridgeObjectRelease();
      return swift_unknownObjectRelease();
    }
  }
  else
  {
    if (result == 1)
    {
      swift_unknownObjectRelease();
      uint64_t v3 = type metadata accessor for NWBrowser.Result(0);
      uint64_t v4 = a1 + *(int *)(v3 + 20);
      type metadata accessor for NWEndpoint();
      switch(swift_getEnumCaseMultiPayload())
      {
        case 0u:
LABEL_8:
          sub_18315E658(*(void *)v4, *(void *)(v4 + 8), *(void *)(v4 + 16), *(unsigned char *)(v4 + 24));
          break;
        case 1u:
LABEL_9:
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
          if (*(void *)(v4 + 48) != 1) {
            goto LABEL_13;
          }
          break;
        case 2u:
LABEL_11:
          swift_bridgeObjectRelease();
          break;
        case 3u:
LABEL_12:
          uint64_t v7 = sub_183D4447C();
          (*(void (**)(uint64_t, uint64_t))(*(void *)(v7 - 8) + 8))(v4, v7);
          break;
        case 4u:
LABEL_13:
          swift_unknownObjectRelease();
          break;
        default:
          break;
      }
    }
    else
    {
      if (result) {
        return result;
      }
      swift_unknownObjectRelease();
      uint64_t v3 = type metadata accessor for NWBrowser.Result(0);
      uint64_t v4 = a1 + *(int *)(v3 + 20);
      type metadata accessor for NWEndpoint();
      switch(swift_getEnumCaseMultiPayload())
      {
        case 0u:
          goto LABEL_8;
        case 1u:
          goto LABEL_9;
        case 2u:
          goto LABEL_11;
        case 3u:
          goto LABEL_12;
        case 4u:
          goto LABEL_13;
        default:
          break;
      }
    }
    swift_bridgeObjectRelease();
    uint64_t result = *(void *)(a1 + *(int *)(v3 + 28));
    if (result) {
      goto LABEL_15;
    }
  }
  return result;
}

void *initializeWithCopy for NWBrowser.Result.Change(void *a1, void *a2, uint64_t a3)
{
  int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
  switch(EnumCaseMultiPayload)
  {
    case 2:
      *a1 = *a2;
      uint64_t v13 = (int *)type metadata accessor for NWBrowser.Result(0);
      uint64_t v14 = v13[5];
      uint64_t v15 = (char *)a1 + v14;
      uint64_t v16 = (char *)a2 + v14;
      type metadata accessor for NWEndpoint();
      swift_unknownObjectRetain();
      switch(swift_getEnumCaseMultiPayload())
      {
        case 1u:
          uint64_t v37 = *((void *)v16 + 1);
          *(void *)uint64_t v15 = *(void *)v16;
          *((void *)v15 + 1) = v37;
          uint64_t v38 = *((void *)v16 + 3);
          *((void *)v15 + 2) = *((void *)v16 + 2);
          *((void *)v15 + 3) = v38;
          uint64_t v39 = *((void *)v16 + 5);
          *((void *)v15 + 4) = *((void *)v16 + 4);
          *((void *)v15 + 5) = v39;
          uint64_t v40 = *((void *)v16 + 6);
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          if (v40 != 1) {
            swift_unknownObjectRetain();
          }
          *((void *)v15 + 6) = v40;
          break;
        case 2u:
          uint64_t v41 = *((void *)v16 + 1);
          *(void *)uint64_t v15 = *(void *)v16;
          *((void *)v15 + 1) = v41;
          swift_bridgeObjectRetain();
          break;
        case 3u:
          uint64_t v42 = sub_183D4447C();
          (*(void (**)(char *, char *, uint64_t))(*(void *)(v42 - 8) + 16))(v15, v16, v42);
          break;
        case 4u:
          *(void *)uint64_t v15 = *(void *)v16;
          swift_unknownObjectRetain();
          break;
        default:
          uint64_t v17 = *(void *)v16;
          uint64_t v18 = *((void *)v16 + 1);
          uint64_t v19 = *((void *)v16 + 2);
          char v80 = v16[24];
          sub_18315E9E4(*(void *)v16, v18, v19, v80);
          *(void *)uint64_t v15 = v17;
          *((void *)v15 + 1) = v18;
          *((void *)v15 + 2) = v19;
          v15[24] = v80;
          *((_WORD *)v15 + 13) = *((_WORD *)v16 + 13);
          break;
      }
      swift_storeEnumTagMultiPayload();
      *(void *)((char *)a1 + v13[6]) = *(void *)((char *)a2 + v13[6]);
      uint64_t v43 = v13[7];
      uint64_t v44 = (void *)((char *)a1 + v43);
      uint64_t v45 = (char *)a2 + v43;
      uint64_t v46 = *(void *)((char *)a2 + v43);
      swift_bridgeObjectRetain();
      if (v46)
      {
        uint64_t v47 = *((void *)v45 + 1);
        void *v44 = v46;
        v44[1] = v47;
        swift_bridgeObjectRetain();
        swift_unknownObjectRetain();
      }
      else
      {
        *(_OWORD *)uint64_t v44 = *(_OWORD *)v45;
      }
      uint64_t v82 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F619E0);
      uint64_t v48 = *(int *)(v82 + 48);
      uint64_t v49 = (void *)((char *)a1 + v48);
      uint64_t v50 = (char *)a2 + v48;
      *uint64_t v49 = *(void *)((char *)a2 + v48);
      uint64_t v51 = v13[5];
      uint64_t v52 = (char *)v49 + v51;
      uint64_t v53 = &v50[v51];
      swift_unknownObjectRetain();
      switch(swift_getEnumCaseMultiPayload())
      {
        case 1u:
          uint64_t v62 = *((void *)v53 + 1);
          *(void *)uint64_t v52 = *(void *)v53;
          *((void *)v52 + 1) = v62;
          uint64_t v63 = *((void *)v53 + 3);
          *((void *)v52 + 2) = *((void *)v53 + 2);
          *((void *)v52 + 3) = v63;
          uint64_t v64 = *((void *)v53 + 5);
          *((void *)v52 + 4) = *((void *)v53 + 4);
          *((void *)v52 + 5) = v64;
          uint64_t v65 = *((void *)v53 + 6);
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          if (v65 != 1) {
            swift_unknownObjectRetain();
          }
          *((void *)v52 + 6) = v65;
          break;
        case 2u:
          uint64_t v66 = *((void *)v53 + 1);
          *(void *)uint64_t v52 = *(void *)v53;
          *((void *)v52 + 1) = v66;
          swift_bridgeObjectRetain();
          break;
        case 3u:
          uint64_t v67 = sub_183D4447C();
          (*(void (**)(char *, char *, uint64_t))(*(void *)(v67 - 8) + 16))(v52, v53, v67);
          break;
        case 4u:
          *(void *)uint64_t v52 = *(void *)v53;
          swift_unknownObjectRetain();
          break;
        default:
          uint64_t v76 = *(void *)v53;
          uint64_t v54 = *((void *)v53 + 1);
          uint64_t v75 = *((void *)v53 + 2);
          char v74 = v53[24];
          sub_18315E9E4(*(void *)v53, v54, v75, v74);
          *(void *)uint64_t v52 = v76;
          *((void *)v52 + 1) = v54;
          *((void *)v52 + 2) = v75;
          v52[24] = v74;
          *((_WORD *)v52 + 13) = *((_WORD *)v53 + 13);
          break;
      }
      swift_storeEnumTagMultiPayload();
      *(void *)((char *)v49 + v13[6]) = *(void *)&v50[v13[6]];
      uint64_t v68 = v13[7];
      uint64_t v69 = (void *)((char *)v49 + v68);
      uint64_t v70 = &v50[v68];
      uint64_t v71 = *(void *)&v50[v68];
      swift_bridgeObjectRetain();
      if (v71)
      {
        uint64_t v72 = *((void *)v70 + 1);
        void *v69 = v71;
        v69[1] = v72;
        swift_bridgeObjectRetain();
        swift_unknownObjectRetain();
      }
      else
      {
        *(_OWORD *)uint64_t v69 = *(_OWORD *)v70;
      }
      *((unsigned char *)a1 + *(int *)(v82 + 64)) = *((unsigned char *)a2 + *(int *)(v82 + 64));
      goto LABEL_49;
    case 1:
      *a1 = *a2;
      uint64_t v20 = (int *)type metadata accessor for NWBrowser.Result(0);
      uint64_t v21 = v20[5];
      uint64_t v22 = (char *)a1 + v21;
      uint64_t v23 = (char *)a2 + v21;
      type metadata accessor for NWEndpoint();
      swift_unknownObjectRetain();
      switch(swift_getEnumCaseMultiPayload())
      {
        case 1u:
          uint64_t v55 = *((void *)v23 + 1);
          *(void *)uint64_t v22 = *(void *)v23;
          *((void *)v22 + 1) = v55;
          uint64_t v56 = *((void *)v23 + 3);
          *((void *)v22 + 2) = *((void *)v23 + 2);
          *((void *)v22 + 3) = v56;
          uint64_t v57 = *((void *)v23 + 5);
          *((void *)v22 + 4) = *((void *)v23 + 4);
          *((void *)v22 + 5) = v57;
          uint64_t v58 = *((void *)v23 + 6);
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          if (v58 != 1) {
            swift_unknownObjectRetain();
          }
          *((void *)v22 + 6) = v58;
          break;
        case 2u:
          uint64_t v59 = *((void *)v23 + 1);
          *(void *)uint64_t v22 = *(void *)v23;
          *((void *)v22 + 1) = v59;
          swift_bridgeObjectRetain();
          break;
        case 3u:
          uint64_t v60 = sub_183D4447C();
          (*(void (**)(char *, char *, uint64_t))(*(void *)(v60 - 8) + 16))(v22, v23, v60);
          break;
        case 4u:
          *(void *)uint64_t v22 = *(void *)v23;
          swift_unknownObjectRetain();
          break;
        default:
          uint64_t v24 = *(void *)v23;
          uint64_t v25 = *((void *)v23 + 1);
          uint64_t v81 = *((void *)v23 + 2);
          char v78 = v23[24];
          sub_18315E9E4(*(void *)v23, v25, v81, v78);
          *(void *)uint64_t v22 = v24;
          *((void *)v22 + 1) = v25;
          *((void *)v22 + 2) = v81;
          v22[24] = v78;
          *((_WORD *)v22 + 13) = *((_WORD *)v23 + 13);
          break;
      }
      swift_storeEnumTagMultiPayload();
      *(void *)((char *)a1 + v20[6]) = *(void *)((char *)a2 + v20[6]);
      uint64_t v61 = v20[7];
      uint64_t v33 = (char *)a1 + v61;
      uint64_t v34 = (char *)a2 + v61;
      uint64_t v35 = *(void *)((char *)a2 + v61);
      swift_bridgeObjectRetain();
      if (!v35)
      {
        *(_OWORD *)uint64_t v33 = *(_OWORD *)v34;
        goto LABEL_49;
      }
      goto LABEL_18;
    case 0:
      *a1 = *a2;
      uint64_t v7 = (int *)type metadata accessor for NWBrowser.Result(0);
      uint64_t v8 = v7[5];
      uint64_t v9 = (char *)a1 + v8;
      uint64_t v10 = (char *)a2 + v8;
      type metadata accessor for NWEndpoint();
      swift_unknownObjectRetain();
      switch(swift_getEnumCaseMultiPayload())
      {
        case 1u:
          uint64_t v26 = *((void *)v10 + 1);
          *(void *)uint64_t v9 = *(void *)v10;
          *((void *)v9 + 1) = v26;
          uint64_t v27 = *((void *)v10 + 3);
          *((void *)v9 + 2) = *((void *)v10 + 2);
          *((void *)v9 + 3) = v27;
          uint64_t v28 = *((void *)v10 + 5);
          *((void *)v9 + 4) = *((void *)v10 + 4);
          *((void *)v9 + 5) = v28;
          uint64_t v29 = *((void *)v10 + 6);
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          if (v29 != 1) {
            swift_unknownObjectRetain();
          }
          *((void *)v9 + 6) = v29;
          break;
        case 2u:
          uint64_t v30 = *((void *)v10 + 1);
          *(void *)uint64_t v9 = *(void *)v10;
          *((void *)v9 + 1) = v30;
          swift_bridgeObjectRetain();
          break;
        case 3u:
          uint64_t v31 = sub_183D4447C();
          (*(void (**)(char *, char *, uint64_t))(*(void *)(v31 - 8) + 16))(v9, v10, v31);
          break;
        case 4u:
          *(void *)uint64_t v9 = *(void *)v10;
          swift_unknownObjectRetain();
          break;
        default:
          uint64_t v11 = *(void *)v10;
          uint64_t v12 = *((void *)v10 + 1);
          uint64_t v79 = *((void *)v10 + 2);
          char v77 = v10[24];
          sub_18315E9E4(*(void *)v10, v12, v79, v77);
          *(void *)uint64_t v9 = v11;
          *((void *)v9 + 1) = v12;
          *((void *)v9 + 2) = v79;
          v9[24] = v77;
          *((_WORD *)v9 + 13) = *((_WORD *)v10 + 13);
          break;
      }
      swift_storeEnumTagMultiPayload();
      *(void *)((char *)a1 + v7[6]) = *(void *)((char *)a2 + v7[6]);
      uint64_t v32 = v7[7];
      uint64_t v33 = (char *)a1 + v32;
      uint64_t v34 = (char *)a2 + v32;
      uint64_t v35 = *(void *)((char *)a2 + v32);
      swift_bridgeObjectRetain();
      if (!v35)
      {
        *(_OWORD *)uint64_t v33 = *(_OWORD *)v34;
        goto LABEL_49;
      }
LABEL_18:
      uint64_t v36 = *((void *)v34 + 1);
      *(void *)uint64_t v33 = v35;
      *((void *)v33 + 1) = v36;
      swift_bridgeObjectRetain();
      swift_unknownObjectRetain();
LABEL_49:
      swift_storeEnumTagMultiPayload();
      return a1;
  }
  memcpy(a1, a2, *(void *)(*(void *)(a3 - 8) + 64));
  return a1;
}

void *assignWithCopy for NWBrowser.Result.Change(void *a1, void *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    sub_1834C94F4((uint64_t)a1, type metadata accessor for NWBrowser.Result.Change);
    int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
    switch(EnumCaseMultiPayload)
    {
      case 2:
        *a1 = *a2;
        uint64_t v13 = (int *)type metadata accessor for NWBrowser.Result(0);
        uint64_t v14 = v13[5];
        uint64_t v15 = (char *)a1 + v14;
        uint64_t v16 = (char *)a2 + v14;
        type metadata accessor for NWEndpoint();
        swift_unknownObjectRetain();
        switch(swift_getEnumCaseMultiPayload())
        {
          case 1u:
            *(void *)uint64_t v15 = *(void *)v16;
            *((void *)v15 + 1) = *((void *)v16 + 1);
            *((void *)v15 + 2) = *((void *)v16 + 2);
            *((void *)v15 + 3) = *((void *)v16 + 3);
            *((void *)v15 + 4) = *((void *)v16 + 4);
            *((void *)v15 + 5) = *((void *)v16 + 5);
            uint64_t v27 = *((void *)v16 + 6);
            swift_bridgeObjectRetain();
            swift_bridgeObjectRetain();
            swift_bridgeObjectRetain();
            if (v27 != 1) {
              swift_unknownObjectRetain();
            }
            *((void *)v15 + 6) = v27;
            break;
          case 2u:
            *(void *)uint64_t v15 = *(void *)v16;
            *((void *)v15 + 1) = *((void *)v16 + 1);
            swift_bridgeObjectRetain();
            break;
          case 3u:
            uint64_t v28 = sub_183D4447C();
            (*(void (**)(char *, char *, uint64_t))(*(void *)(v28 - 8) + 16))(v15, v16, v28);
            break;
          case 4u:
            *(void *)uint64_t v15 = *(void *)v16;
            swift_unknownObjectRetain();
            break;
          default:
            uint64_t v17 = *(void *)v16;
            uint64_t v18 = *((void *)v16 + 1);
            uint64_t v19 = *((void *)v16 + 2);
            char v61 = v16[24];
            sub_18315E9E4(*(void *)v16, v18, v19, v61);
            *(void *)uint64_t v15 = v17;
            *((void *)v15 + 1) = v18;
            *((void *)v15 + 2) = v19;
            v15[24] = v61;
            *((_WORD *)v15 + 13) = *((_WORD *)v16 + 13);
            break;
        }
        swift_storeEnumTagMultiPayload();
        *(void *)((char *)a1 + v13[6]) = *(void *)((char *)a2 + v13[6]);
        uint64_t v29 = v13[7];
        uint64_t v30 = (void *)((char *)a1 + v29);
        uint64_t v31 = (char *)a2 + v29;
        uint64_t v32 = *(void *)((char *)a2 + v29);
        swift_bridgeObjectRetain();
        if (v32)
        {
          void *v30 = v32;
          v30[1] = *((void *)v31 + 1);
          swift_bridgeObjectRetain();
          swift_unknownObjectRetain();
        }
        else
        {
          *(_OWORD *)uint64_t v30 = *(_OWORD *)v31;
        }
        uint64_t v63 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F619E0);
        uint64_t v33 = *(int *)(v63 + 48);
        uint64_t v34 = (void *)((char *)a1 + v33);
        uint64_t v35 = (char *)a2 + v33;
        *uint64_t v34 = *(void *)((char *)a2 + v33);
        uint64_t v36 = v13[5];
        uint64_t v37 = (char *)v34 + v36;
        uint64_t v38 = &v35[v36];
        swift_unknownObjectRetain();
        switch(swift_getEnumCaseMultiPayload())
        {
          case 1u:
            *(void *)uint64_t v37 = *(void *)v38;
            *((void *)v37 + 1) = *((void *)v38 + 1);
            *((void *)v37 + 2) = *((void *)v38 + 2);
            *((void *)v37 + 3) = *((void *)v38 + 3);
            *((void *)v37 + 4) = *((void *)v38 + 4);
            *((void *)v37 + 5) = *((void *)v38 + 5);
            uint64_t v46 = *((void *)v38 + 6);
            swift_bridgeObjectRetain();
            swift_bridgeObjectRetain();
            swift_bridgeObjectRetain();
            if (v46 != 1) {
              swift_unknownObjectRetain();
            }
            *((void *)v37 + 6) = v46;
            break;
          case 2u:
            *(void *)uint64_t v37 = *(void *)v38;
            *((void *)v37 + 1) = *((void *)v38 + 1);
            swift_bridgeObjectRetain();
            break;
          case 3u:
            uint64_t v47 = sub_183D4447C();
            (*(void (**)(char *, char *, uint64_t))(*(void *)(v47 - 8) + 16))(v37, v38, v47);
            break;
          case 4u:
            *(void *)uint64_t v37 = *(void *)v38;
            swift_unknownObjectRetain();
            break;
          default:
            uint64_t v57 = *(void *)v38;
            uint64_t v39 = *((void *)v38 + 1);
            uint64_t v56 = *((void *)v38 + 2);
            char v55 = v38[24];
            sub_18315E9E4(*(void *)v38, v39, v56, v55);
            *(void *)uint64_t v37 = v57;
            *((void *)v37 + 1) = v39;
            *((void *)v37 + 2) = v56;
            v37[24] = v55;
            *((_WORD *)v37 + 13) = *((_WORD *)v38 + 13);
            break;
        }
        swift_storeEnumTagMultiPayload();
        *(void *)((char *)v34 + v13[6]) = *(void *)&v35[v13[6]];
        uint64_t v48 = v13[7];
        uint64_t v49 = (void *)((char *)v34 + v48);
        uint64_t v50 = &v35[v48];
        uint64_t v51 = *(void *)&v35[v48];
        swift_bridgeObjectRetain();
        if (v51)
        {
          *uint64_t v49 = v51;
          v49[1] = *((void *)v50 + 1);
          swift_bridgeObjectRetain();
          swift_unknownObjectRetain();
        }
        else
        {
          *(_OWORD *)uint64_t v49 = *(_OWORD *)v50;
        }
        *((unsigned char *)a1 + *(int *)(v63 + 64)) = *((unsigned char *)a2 + *(int *)(v63 + 64));
        goto LABEL_50;
      case 1:
        *a1 = *a2;
        uint64_t v20 = (int *)type metadata accessor for NWBrowser.Result(0);
        uint64_t v21 = v20[5];
        uint64_t v22 = (char *)a1 + v21;
        uint64_t v23 = (char *)a2 + v21;
        type metadata accessor for NWEndpoint();
        swift_unknownObjectRetain();
        switch(swift_getEnumCaseMultiPayload())
        {
          case 1u:
            *(void *)uint64_t v22 = *(void *)v23;
            *((void *)v22 + 1) = *((void *)v23 + 1);
            *((void *)v22 + 2) = *((void *)v23 + 2);
            *((void *)v22 + 3) = *((void *)v23 + 3);
            *((void *)v22 + 4) = *((void *)v23 + 4);
            *((void *)v22 + 5) = *((void *)v23 + 5);
            uint64_t v40 = *((void *)v23 + 6);
            swift_bridgeObjectRetain();
            swift_bridgeObjectRetain();
            swift_bridgeObjectRetain();
            if (v40 != 1) {
              swift_unknownObjectRetain();
            }
            *((void *)v22 + 6) = v40;
            break;
          case 2u:
            *(void *)uint64_t v22 = *(void *)v23;
            *((void *)v22 + 1) = *((void *)v23 + 1);
            swift_bridgeObjectRetain();
            break;
          case 3u:
            uint64_t v41 = sub_183D4447C();
            (*(void (**)(char *, char *, uint64_t))(*(void *)(v41 - 8) + 16))(v22, v23, v41);
            break;
          case 4u:
            *(void *)uint64_t v22 = *(void *)v23;
            swift_unknownObjectRetain();
            break;
          default:
            uint64_t v24 = *(void *)v23;
            uint64_t v25 = *((void *)v23 + 1);
            uint64_t v62 = *((void *)v23 + 2);
            char v59 = v23[24];
            sub_18315E9E4(*(void *)v23, v25, v62, v59);
            *(void *)uint64_t v22 = v24;
            *((void *)v22 + 1) = v25;
            *((void *)v22 + 2) = v62;
            v22[24] = v59;
            *((_WORD *)v22 + 13) = *((_WORD *)v23 + 13);
            break;
        }
        swift_storeEnumTagMultiPayload();
        *(void *)((char *)a1 + v20[6]) = *(void *)((char *)a2 + v20[6]);
        uint64_t v42 = v20[7];
        uint64_t v43 = (char *)a1 + v42;
        uint64_t v44 = (char *)a2 + v42;
        uint64_t v45 = *(void *)((char *)a2 + v42);
        swift_bridgeObjectRetain();
        if (!v45)
        {
          *(_OWORD *)uint64_t v43 = *(_OWORD *)v44;
LABEL_50:
          swift_storeEnumTagMultiPayload();
          return a1;
        }
LABEL_48:
        *(void *)uint64_t v43 = v45;
        *((void *)v43 + 1) = *((void *)v44 + 1);
        swift_bridgeObjectRetain();
        swift_unknownObjectRetain();
        goto LABEL_50;
      case 0:
        *a1 = *a2;
        uint64_t v7 = (int *)type metadata accessor for NWBrowser.Result(0);
        uint64_t v8 = v7[5];
        uint64_t v9 = (char *)a1 + v8;
        uint64_t v10 = (char *)a2 + v8;
        type metadata accessor for NWEndpoint();
        swift_unknownObjectRetain();
        switch(swift_getEnumCaseMultiPayload())
        {
          case 1u:
            *(void *)uint64_t v9 = *(void *)v10;
            *((void *)v9 + 1) = *((void *)v10 + 1);
            *((void *)v9 + 2) = *((void *)v10 + 2);
            *((void *)v9 + 3) = *((void *)v10 + 3);
            *((void *)v9 + 4) = *((void *)v10 + 4);
            *((void *)v9 + 5) = *((void *)v10 + 5);
            uint64_t v52 = *((void *)v10 + 6);
            swift_bridgeObjectRetain();
            swift_bridgeObjectRetain();
            swift_bridgeObjectRetain();
            if (v52 != 1) {
              swift_unknownObjectRetain();
            }
            *((void *)v9 + 6) = v52;
            break;
          case 2u:
            *(void *)uint64_t v9 = *(void *)v10;
            *((void *)v9 + 1) = *((void *)v10 + 1);
            swift_bridgeObjectRetain();
            break;
          case 3u:
            uint64_t v26 = sub_183D4447C();
            (*(void (**)(char *, char *, uint64_t))(*(void *)(v26 - 8) + 16))(v9, v10, v26);
            break;
          case 4u:
            *(void *)uint64_t v9 = *(void *)v10;
            swift_unknownObjectRetain();
            break;
          default:
            uint64_t v11 = *(void *)v10;
            uint64_t v12 = *((void *)v10 + 1);
            uint64_t v60 = *((void *)v10 + 2);
            char v58 = v10[24];
            sub_18315E9E4(*(void *)v10, v12, v60, v58);
            *(void *)uint64_t v9 = v11;
            *((void *)v9 + 1) = v12;
            *((void *)v9 + 2) = v60;
            v9[24] = v58;
            *((_WORD *)v9 + 13) = *((_WORD *)v10 + 13);
            break;
        }
        swift_storeEnumTagMultiPayload();
        *(void *)((char *)a1 + v7[6]) = *(void *)((char *)a2 + v7[6]);
        uint64_t v53 = v7[7];
        uint64_t v43 = (char *)a1 + v53;
        uint64_t v44 = (char *)a2 + v53;
        uint64_t v45 = *(void *)((char *)a2 + v53);
        swift_bridgeObjectRetain();
        if (!v45)
        {
          *(_OWORD *)uint64_t v43 = *(_OWORD *)v44;
          goto LABEL_50;
        }
        goto LABEL_48;
    }
    memcpy(a1, a2, *(void *)(*(void *)(a3 - 8) + 64));
  }
  return a1;
}

void *initializeWithTake for NWBrowser.Result.Change(void *a1, void *a2, uint64_t a3)
{
  int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
  switch(EnumCaseMultiPayload)
  {
    case 2:
      *a1 = *a2;
      uint64_t v13 = (int *)type metadata accessor for NWBrowser.Result(0);
      uint64_t v14 = v13[5];
      uint64_t v15 = (char *)a1 + v14;
      uint64_t v16 = (char *)a2 + v14;
      uint64_t v17 = type metadata accessor for NWEndpoint();
      if (swift_getEnumCaseMultiPayload() == 3)
      {
        uint64_t v18 = sub_183D4447C();
        (*(void (**)(char *, char *, uint64_t))(*(void *)(v18 - 8) + 32))(v15, v16, v18);
        swift_storeEnumTagMultiPayload();
      }
      else
      {
        memcpy(v15, v16, *(void *)(*(void *)(v17 - 8) + 64));
      }
      *(void *)((char *)a1 + v13[6]) = *(void *)((char *)a2 + v13[6]);
      *(_OWORD *)((char *)a1 + v13[7]) = *(_OWORD *)((char *)a2 + v13[7]);
      uint64_t v25 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F619E0);
      uint64_t v26 = *(int *)(v25 + 48);
      uint64_t v27 = (void *)((char *)a1 + v26);
      uint64_t v28 = (char *)a2 + v26;
      *uint64_t v27 = *(void *)((char *)a2 + v26);
      uint64_t v29 = v13[5];
      uint64_t v30 = (char *)v27 + v29;
      uint64_t v31 = &v28[v29];
      if (swift_getEnumCaseMultiPayload() == 3)
      {
        uint64_t v32 = sub_183D4447C();
        (*(void (**)(char *, char *, uint64_t))(*(void *)(v32 - 8) + 32))(v30, v31, v32);
        swift_storeEnumTagMultiPayload();
      }
      else
      {
        memcpy(v30, v31, *(void *)(*(void *)(v17 - 8) + 64));
      }
      *(void *)((char *)v27 + v13[6]) = *(void *)&v28[v13[6]];
      *(_OWORD *)((char *)v27 + v13[7]) = *(_OWORD *)&v28[v13[7]];
      *((unsigned char *)a1 + *(int *)(v25 + 64)) = *((unsigned char *)a2 + *(int *)(v25 + 64));
      goto LABEL_20;
    case 1:
      *a1 = *a2;
      uint64_t v19 = (int *)type metadata accessor for NWBrowser.Result(0);
      uint64_t v20 = v19[5];
      uint64_t v21 = (char *)a1 + v20;
      uint64_t v22 = (char *)a2 + v20;
      uint64_t v23 = type metadata accessor for NWEndpoint();
      if (swift_getEnumCaseMultiPayload() == 3)
      {
        uint64_t v24 = sub_183D4447C();
        (*(void (**)(char *, char *, uint64_t))(*(void *)(v24 - 8) + 32))(v21, v22, v24);
        swift_storeEnumTagMultiPayload();
      }
      else
      {
        memcpy(v21, v22, *(void *)(*(void *)(v23 - 8) + 64));
      }
      *(void *)((char *)a1 + v19[6]) = *(void *)((char *)a2 + v19[6]);
      *(_OWORD *)((char *)a1 + v19[7]) = *(_OWORD *)((char *)a2 + v19[7]);
      goto LABEL_20;
    case 0:
      *a1 = *a2;
      uint64_t v7 = (int *)type metadata accessor for NWBrowser.Result(0);
      uint64_t v8 = v7[5];
      uint64_t v9 = (char *)a1 + v8;
      uint64_t v10 = (char *)a2 + v8;
      uint64_t v11 = type metadata accessor for NWEndpoint();
      if (swift_getEnumCaseMultiPayload() == 3)
      {
        uint64_t v12 = sub_183D4447C();
        (*(void (**)(char *, char *, uint64_t))(*(void *)(v12 - 8) + 32))(v9, v10, v12);
        swift_storeEnumTagMultiPayload();
      }
      else
      {
        memcpy(v9, v10, *(void *)(*(void *)(v11 - 8) + 64));
      }
      *(void *)((char *)a1 + v7[6]) = *(void *)((char *)a2 + v7[6]);
      *(_OWORD *)((char *)a1 + v7[7]) = *(_OWORD *)((char *)a2 + v7[7]);
LABEL_20:
      swift_storeEnumTagMultiPayload();
      return a1;
  }
  memcpy(a1, a2, *(void *)(*(void *)(a3 - 8) + 64));
  return a1;
}

void *assignWithTake for NWBrowser.Result.Change(void *a1, void *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    sub_1834C94F4((uint64_t)a1, type metadata accessor for NWBrowser.Result.Change);
    int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
    switch(EnumCaseMultiPayload)
    {
      case 2:
        *a1 = *a2;
        uint64_t v13 = (int *)type metadata accessor for NWBrowser.Result(0);
        uint64_t v14 = v13[5];
        uint64_t v15 = (char *)a1 + v14;
        uint64_t v16 = (char *)a2 + v14;
        uint64_t v17 = type metadata accessor for NWEndpoint();
        if (swift_getEnumCaseMultiPayload() == 3)
        {
          uint64_t v18 = sub_183D4447C();
          (*(void (**)(char *, char *, uint64_t))(*(void *)(v18 - 8) + 32))(v15, v16, v18);
          swift_storeEnumTagMultiPayload();
        }
        else
        {
          memcpy(v15, v16, *(void *)(*(void *)(v17 - 8) + 64));
        }
        *(void *)((char *)a1 + v13[6]) = *(void *)((char *)a2 + v13[6]);
        *(_OWORD *)((char *)a1 + v13[7]) = *(_OWORD *)((char *)a2 + v13[7]);
        uint64_t v25 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F619E0);
        uint64_t v26 = *(int *)(v25 + 48);
        uint64_t v27 = (void *)((char *)a1 + v26);
        uint64_t v28 = (char *)a2 + v26;
        *uint64_t v27 = *(void *)((char *)a2 + v26);
        uint64_t v29 = v13[5];
        uint64_t v30 = (char *)v27 + v29;
        uint64_t v31 = &v28[v29];
        if (swift_getEnumCaseMultiPayload() == 3)
        {
          uint64_t v32 = sub_183D4447C();
          (*(void (**)(char *, char *, uint64_t))(*(void *)(v32 - 8) + 32))(v30, v31, v32);
          swift_storeEnumTagMultiPayload();
        }
        else
        {
          memcpy(v30, v31, *(void *)(*(void *)(v17 - 8) + 64));
        }
        *(void *)((char *)v27 + v13[6]) = *(void *)&v28[v13[6]];
        *(_OWORD *)((char *)v27 + v13[7]) = *(_OWORD *)&v28[v13[7]];
        *((unsigned char *)a1 + *(int *)(v25 + 64)) = *((unsigned char *)a2 + *(int *)(v25 + 64));
        goto LABEL_21;
      case 1:
        *a1 = *a2;
        uint64_t v19 = (int *)type metadata accessor for NWBrowser.Result(0);
        uint64_t v20 = v19[5];
        uint64_t v21 = (char *)a1 + v20;
        uint64_t v22 = (char *)a2 + v20;
        uint64_t v23 = type metadata accessor for NWEndpoint();
        if (swift_getEnumCaseMultiPayload() == 3)
        {
          uint64_t v24 = sub_183D4447C();
          (*(void (**)(char *, char *, uint64_t))(*(void *)(v24 - 8) + 32))(v21, v22, v24);
          swift_storeEnumTagMultiPayload();
        }
        else
        {
          memcpy(v21, v22, *(void *)(*(void *)(v23 - 8) + 64));
        }
        *(void *)((char *)a1 + v19[6]) = *(void *)((char *)a2 + v19[6]);
        *(_OWORD *)((char *)a1 + v19[7]) = *(_OWORD *)((char *)a2 + v19[7]);
        goto LABEL_21;
      case 0:
        *a1 = *a2;
        uint64_t v7 = (int *)type metadata accessor for NWBrowser.Result(0);
        uint64_t v8 = v7[5];
        uint64_t v9 = (char *)a1 + v8;
        uint64_t v10 = (char *)a2 + v8;
        uint64_t v11 = type metadata accessor for NWEndpoint();
        if (swift_getEnumCaseMultiPayload() == 3)
        {
          uint64_t v12 = sub_183D4447C();
          (*(void (**)(char *, char *, uint64_t))(*(void *)(v12 - 8) + 32))(v9, v10, v12);
          swift_storeEnumTagMultiPayload();
        }
        else
        {
          memcpy(v9, v10, *(void *)(*(void *)(v11 - 8) + 64));
        }
        *(void *)((char *)a1 + v7[6]) = *(void *)((char *)a2 + v7[6]);
        *(_OWORD *)((char *)a1 + v7[7]) = *(_OWORD *)((char *)a2 + v7[7]);
LABEL_21:
        swift_storeEnumTagMultiPayload();
        return a1;
    }
    memcpy(a1, a2, *(void *)(*(void *)(a3 - 8) + 64));
  }
  return a1;
}

uint64_t getEnumTagSinglePayload for NWEndpoint(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(*(void *)(a3 - 8) + 48))();
}

uint64_t storeEnumTagSinglePayload for NWEndpoint(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(*(void *)(a4 - 8) + 56))();
}

uint64_t sub_1834CC1E0()
{
  return swift_storeEnumTagMultiPayload();
}

uint64_t sub_1834CC1F0()
{
  uint64_t result = type metadata accessor for NWBrowser.Result(319);
  if (v1 <= 0x3F)
  {
    uint64_t v3 = *(void *)(result - 8) + 64;
    uint64_t v4 = v3;
    swift_getTupleTypeLayout3();
    uint64_t v5 = &v2;
    swift_initEnumMetadataMultiPayload();
    return 0;
  }
  return result;
}

ValueMetadata *type metadata accessor for NWBrowser.Result.Change.Flags()
{
  return &type metadata for NWBrowser.Result.Change.Flags;
}

uint64_t getEnumTagSinglePayload for NWBrowser.State(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0x3E && *(unsigned char *)(a1 + 5)) {
    return (*(_DWORD *)a1 + 62);
  }
  unsigned int v3 = ((*(unsigned __int8 *)(a1 + 4) >> 6) & 0xFFFFFFC3 | (4 * ((*(unsigned __int8 *)(a1 + 4) >> 2) & 0xF))) ^ 0x3F;
  if (v3 >= 0x3D) {
    unsigned int v3 = -1;
  }
  return v3 + 1;
}

uint64_t storeEnumTagSinglePayload for NWBrowser.State(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0x3D)
  {
    *(unsigned char *)(result + 4) = 0;
    *(_DWORD *)uint64_t result = a2 - 62;
    if (a3 >= 0x3E) {
      *(unsigned char *)(result + 5) = 1;
    }
  }
  else
  {
    if (a3 >= 0x3E) {
      *(unsigned char *)(result + 5) = 0;
    }
    if (a2)
    {
      *(_DWORD *)uint64_t result = 0;
      *(unsigned char *)(result + 4) = 4 * (((-a2 >> 2) & 0xF) - 16 * a2);
    }
  }
  return result;
}

uint64_t sub_1834CC350(uint64_t result)
{
  *(unsigned char *)(result + 4) &= 0x3Fu;
  return result;
}

ValueMetadata *type metadata accessor for NWBrowser.State()
{
  return &type metadata for NWBrowser.State;
}

ValueMetadata *type metadata accessor for NWBrowser.Invitation()
{
  return &type metadata for NWBrowser.Invitation;
}

uint64_t getEnumTagSinglePayload for HTTPField.CodingKeys(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xFE) {
    goto LABEL_17;
  }
  if (a2 + 2 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 2) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 2;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 2;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 2;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 3;
  int v8 = v6 - 3;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *_s7Network9NWBrowserC10InvitationV5ScopeOwst_0(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 2 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 2) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFE) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xFD)
  {
    unsigned int v6 = ((a2 - 254) >> 8) + 1;
    *uint64_t result = a2 + 2;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x1834CC4ECLL);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *uint64_t result = a2 + 2;
        break;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for NWBrowser.Invitation.Scope()
{
  return &type metadata for NWBrowser.Invitation.Scope;
}

void destroy for NWBrowser.LockedState(void *a1)
{
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  if (a1[3]) {
    swift_release();
  }
  if (a1[5]) {
    swift_release();
  }
  int v2 = (void *)a1[7];
}

uint64_t initializeWithCopy for NWBrowser.LockedState(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v4;
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  unsigned int v6 = (_OWORD *)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 24);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  if (v5)
  {
    uint64_t v7 = *(void *)(a2 + 32);
    *(void *)(a1 + 24) = v5;
    *(void *)(a1 + 32) = v7;
    swift_retain();
  }
  else
  {
    *(_OWORD *)(a1 + 24) = *v6;
  }
  uint64_t v8 = *(void *)(a2 + 40);
  if (v8)
  {
    uint64_t v9 = *(void *)(a2 + 48);
    *(void *)(a1 + 40) = v8;
    *(void *)(a1 + 48) = v9;
    swift_retain();
  }
  else
  {
    *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  }
  uint64_t v10 = *(void **)(a2 + 56);
  *(void *)(a1 + 56) = v10;
  id v11 = v10;
  return a1;
}

uint64_t assignWithCopy for NWBrowser.LockedState(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v4 = *(void *)(a1 + 24);
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  uint64_t v5 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v5)
    {
      uint64_t v6 = *(void *)(a2 + 32);
      *(void *)(a1 + 24) = v5;
      *(void *)(a1 + 32) = v6;
      swift_retain();
      swift_release();
      goto LABEL_8;
    }
    swift_release();
  }
  else if (v5)
  {
    uint64_t v7 = *(void *)(a2 + 32);
    *(void *)(a1 + 24) = v5;
    *(void *)(a1 + 32) = v7;
    swift_retain();
    goto LABEL_8;
  }
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
LABEL_8:
  uint64_t v8 = *(void *)(a2 + 40);
  if (!*(void *)(a1 + 40))
  {
    if (v8)
    {
      uint64_t v10 = *(void *)(a2 + 48);
      *(void *)(a1 + 40) = v8;
      *(void *)(a1 + 48) = v10;
      swift_retain();
      goto LABEL_15;
    }
LABEL_14:
    *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
    goto LABEL_15;
  }
  if (!v8)
  {
    swift_release();
    goto LABEL_14;
  }
  uint64_t v9 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = v8;
  *(void *)(a1 + 48) = v9;
  swift_retain();
  swift_release();
LABEL_15:
  id v11 = *(void **)(a1 + 56);
  uint64_t v12 = *(void **)(a2 + 56);
  *(void *)(a1 + 56) = v12;
  id v13 = v12;

  return a1;
}

__n128 __swift_memcpy64_8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  long long v4 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 48) = v4;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

uint64_t assignWithTake for NWBrowser.LockedState(uint64_t a1, uint64_t a2)
{
  swift_bridgeObjectRelease();
  *(_OWORD *)a1 = *(_OWORD *)a2;
  swift_bridgeObjectRelease();
  uint64_t v4 = *(void *)(a2 + 24);
  uint64_t v5 = *(void *)(a1 + 24);
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  if (v5)
  {
    if (v4)
    {
      uint64_t v6 = *(void *)(a2 + 32);
      *(void *)(a1 + 24) = v4;
      *(void *)(a1 + 32) = v6;
      swift_release();
      goto LABEL_8;
    }
    swift_release();
  }
  else if (v4)
  {
    uint64_t v7 = *(void *)(a2 + 32);
    *(void *)(a1 + 24) = v4;
    *(void *)(a1 + 32) = v7;
    goto LABEL_8;
  }
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
LABEL_8:
  uint64_t v8 = *(void *)(a2 + 40);
  if (!*(void *)(a1 + 40))
  {
    if (v8)
    {
      uint64_t v10 = *(void *)(a2 + 48);
      *(void *)(a1 + 40) = v8;
      *(void *)(a1 + 48) = v10;
      goto LABEL_15;
    }
LABEL_14:
    *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
    goto LABEL_15;
  }
  if (!v8)
  {
    swift_release();
    goto LABEL_14;
  }
  uint64_t v9 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = v8;
  *(void *)(a1 + 48) = v9;
  swift_release();
LABEL_15:
  id v11 = *(void **)(a1 + 56);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);

  return a1;
}

uint64_t getEnumTagSinglePayload for NWBrowser.LockedState(uint64_t *a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *((unsigned char *)a1 + 64)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for NWBrowser.LockedState(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 56) = 0;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 64) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)__n128 result = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 64) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for NWBrowser.LockedState()
{
  return &type metadata for NWBrowser.LockedState;
}

uint64_t sub_1834CC918(uint64_t a1, uint64_t a2)
{
  long long v3 = *(uint64_t (**)(uint64_t *, uint64_t *))(v2 + 16);
  uint64_t v5 = a2;
  uint64_t v6 = a1;
  return v3(&v6, &v5);
}

uint64_t sub_1834CC954(uint64_t result, unint64_t a2, char a3)
{
  if (a3 == 1) {
    return sub_1832E5D6C(result, a2);
  }
  if (!a3) {
    return swift_bridgeObjectRetain();
  }
  return result;
}

uint64_t sub_1834CC974(uint64_t result, unint64_t a2, char a3)
{
  if (a3 == 1) {
    return sub_1832E5E9C(result, a2);
  }
  if (!a3) {
    return swift_bridgeObjectRelease();
  }
  return result;
}

uint64_t sub_1834CC994(void *a1, void *a2)
{
  return (*(uint64_t (**)(void, void))(v2 + 16))(*a1, *a2);
}

uint64_t sub_1834CC9C4(uint64_t a1)
{
  return sub_1834C3184(a1, *(void *)(v1 + 16));
}

uint64_t sub_1834CC9E0()
{
  return swift_deallocObject();
}

uint64_t sub_1834CC9F0()
{
  return swift_deallocObject();
}

uint64_t sub_1834CCA00()
{
  swift_bridgeObjectRelease();

  return swift_deallocObject();
}

uint64_t sub_1834CCA38(uint64_t a1, int a2, unsigned char *a3, uint64_t a4)
{
  return sub_183597D88(a1, a2, a3, a4, v4);
}

uint64_t sub_1834CCA40(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = result;
  LODWORD(result) = 0;
  long long v3 = (int *)(v2 + 32);
  do
  {
    int v5 = *v3++;
    int v4 = v5;
    if ((v5 & ~result) == 0) {
      int v4 = 0;
    }
    __n128 result = v4 | result;
    --v1;
  }
  while (v1);
  return result;
}

uint64_t sub_1834CCA78(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (!v1) {
    return 0;
  }
  uint64_t result = 0;
  int v4 = (uint64_t *)(a1 + 32);
  do
  {
    uint64_t v6 = *v4++;
    uint64_t v5 = v6;
    if ((v6 & ~result) == 0) {
      uint64_t v5 = 0;
    }
    result |= v5;
    --v1;
  }
  while (v1);
  return result;
}

uint64_t sub_1834CCB60@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  v42[2] = *(addrinfo **)MEMORY[0x1E4F143B8];
  uint64_t v8 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F61DE8);
  MEMORY[0x1F4188790](v8 - 8);
  uint64_t v10 = (char *)v40 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  v40[1] = a1;
  v40[2] = a2;
  *(void *)&v41.ai_flags = a1;
  *(void *)&v41.ai_sockint type = a2;
  v42[0] = (addrinfo *)37;
  v42[1] = (addrinfo *)0xE100000000000000;
  uint64_t v11 = sub_183D4460C();
  uint64_t v12 = 1;
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v11 - 8) + 56))(v10, 1, 1, v11);
  sub_1834D7EAC();
  swift_bridgeObjectRetain_n();
  unint64_t v13 = sub_183D453CC();
  unint64_t v15 = v14;
  char v17 = v16;
  sub_183138A24((uint64_t)v10, &qword_1E8F61DE8);
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  if ((v17 & 1) == 0)
  {
    swift_bridgeObjectRetain();
    unint64_t v18 = sub_1834CCEC8(v15, a1, a2);
    uint64_t v20 = v19;
    uint64_t v22 = v21;
    uint64_t v24 = v23;
    swift_bridgeObjectRelease();
    MEMORY[0x185313F90](v18, v20, v22, v24);
    swift_bridgeObjectRelease();
    uint64_t v25 = sub_183D44BAC();
    swift_bridgeObjectRelease();
    uint64_t v12 = (uint64_t)nw_interface_create_with_name((char *)(v25 + 32));
    swift_release();
    if (v12) {
      sub_1834CCF14(v13);
    }
    else {
      uint64_t v12 = 1;
    }
  }
  int v26 = a3;
  v41.ai_flags = 4;
  v41.ai_family = a3;
  *(void *)&v41.ai_sockint type = 1;
  v41.ai_addrlen = 0;
  memset(&v41.ai_canonname, 0, 24);
  v42[0] = 0;
  uint64_t v27 = sub_183D44BAC();
  swift_bridgeObjectRelease();
  int v28 = getaddrinfo((const char *)(v27 + 32), 0, &v41, v42);
  swift_release();
  if (v28 || (uint64_t v30 = v42[0]) == 0)
  {
    uint64_t result = sub_18315E51C(v12);
    *(void *)a4 = 0;
    *(void *)(a4 + 8) = 0;
    *(void *)(a4 + 16) = 0;
    *(unsigned char *)(a4 + 24) = -1;
    return result;
  }
  ai_addr = v42[0]->ai_addr;
  if (ai_addr)
  {
    int sa_family = ai_addr->sa_family;
    if (sa_family == 30)
    {
      unint64_t v34 = *(void *)&ai_addr->sa_data[6];
      unint64_t v35 = *(void *)&ai_addr[1].sa_len;
      unsigned int v37 = *(_DWORD *)&ai_addr[1].sa_data[6];
      if (v37)
      {
        uint64_t v38 = nw_interface_create_with_index(v37);
        if (v38) {
          uint64_t v39 = (uint64_t)v38;
        }
        else {
          uint64_t v39 = 1;
        }
        sub_18315E51C(v12);
        uint64_t v12 = v39;
      }
      if (v34 || v35 != -65536 || v26)
      {
        char v36 = 2;
        uint64_t v33 = v12;
        goto LABEL_24;
      }
      uint64_t v33 = 0;
      unint64_t v34 = HIDWORD(v35);
LABEL_22:
      char v36 = 1;
      unint64_t v35 = v12;
LABEL_24:
      sub_18315E9D4(v12);
      goto LABEL_25;
    }
    if (sa_family == 2)
    {
      uint64_t v33 = 0;
      unint64_t v34 = *(unsigned int *)&ai_addr->sa_data[2];
      goto LABEL_22;
    }
  }
  unint64_t v34 = 0;
  unint64_t v35 = 0;
  uint64_t v33 = 0;
  char v36 = -1;
LABEL_25:
  freeaddrinfo(v30);
  uint64_t result = sub_18315E51C(v12);
  *(void *)a4 = v34;
  *(void *)(a4 + 8) = v35;
  *(void *)(a4 + 16) = v33;
  *(unsigned char *)(a4 + 24) = v36;
  return result;
}

unint64_t sub_1834CCEC8(unint64_t result, uint64_t a2, unint64_t a3)
{
  uint64_t v3 = HIBYTE(a3) & 0xF;
  if ((a3 & 0x2000000000000000) == 0) {
    uint64_t v3 = a2 & 0xFFFFFFFFFFFFLL;
  }
  if (4 * v3 >= result >> 14) {
    return sub_183D44D4C();
  }
  __break(1u);
  return result;
}

uint64_t sub_1834CCF14(unint64_t a1)
{
  unint64_t v2 = v1[1];
  uint64_t v3 = HIBYTE(v2) & 0xF;
  if ((v2 & 0x2000000000000000) == 0) {
    uint64_t v3 = *v1 & 0xFFFFFFFFFFFFLL;
  }
  if (4 * v3 < a1 >> 14) {
    __break(1u);
  }
  return MEMORY[0x1F41838E8]();
}

BOOL IPv6Address.isIPv4Mapped.getter()
{
  return (*(void *)v0 | *(unsigned int *)(v0 + 8) ^ 0xFFFF0000) == 0;
}

void IPv6Address.asIPv4.getter(unint64_t *a1@<X8>)
{
  if (!*v1
    && ((unint64_t v3 = v1[1], v2 = v1[2], v3 == -65536)
     || ((v3 & 0xFEFFFFFF00000000) != 0 ? (BOOL v4 = v3 == 0) : (BOOL v4 = 0), v4)))
  {
    *a1 = HIDWORD(v3);
    a1[1] = v2;
    sub_18315E9D4(v2);
  }
  else
  {
    *(_OWORD *)a1 = xmmword_183D54800;
  }
}

void sub_1834CCFBC()
{
  dword_1E8F62CB0 = 0;
  qword_1E8F62CB8 = 1;
}

uint64_t static IPv4Address.any.getter@<X0>(uint64_t a1@<X8>)
{
  return sub_1834CD1A8(&qword_1E8F61FF8, &dword_1E8F62CB0, &qword_1E8F62CB8, a1);
}

void sub_1834CCFFC()
{
  dword_1E8F62CC0 = -1;
  qword_1E8F62CC8 = 1;
}

uint64_t static IPv4Address.broadcast.getter@<X0>(uint64_t a1@<X8>)
{
  return sub_1834CD1A8(&qword_1E8F62000, &dword_1E8F62CC0, &qword_1E8F62CC8, a1);
}

void sub_1834CD040()
{
  dword_1E8F62CD0 = 16777343;
  qword_1E8F62CD8 = 1;
}

uint64_t static IPv4Address.loopback.getter@<X0>(uint64_t a1@<X8>)
{
  return sub_1834CD1A8(&qword_1E8F62008, &dword_1E8F62CD0, &qword_1E8F62CD8, a1);
}

void sub_1834CD088()
{
  dword_1E8F62CE0 = 16777440;
  qword_1E8F62CE8 = 1;
}

uint64_t static IPv4Address.allHostsGroup.getter@<X0>(uint64_t a1@<X8>)
{
  return sub_1834CD1A8(&qword_1E8F62010, &dword_1E8F62CE0, &qword_1E8F62CE8, a1);
}

void sub_1834CD0D0()
{
  dword_1E8F62CF0 = 33554656;
  qword_1E8F62CF8 = 1;
}

uint64_t static IPv4Address.allRoutersGroup.getter@<X0>(uint64_t a1@<X8>)
{
  return sub_1834CD1A8(&qword_1E8F62018, &dword_1E8F62CF0, &qword_1E8F62CF8, a1);
}

void sub_1834CD118()
{
  dword_1E8F62D00 = 369098976;
  qword_1E8F62D08 = 1;
}

uint64_t static IPv4Address.allReportsGroup.getter@<X0>(uint64_t a1@<X8>)
{
  return sub_1834CD1A8(&qword_1E8F62020, &dword_1E8F62D00, &qword_1E8F62D08, a1);
}

void sub_1834CD160()
{
  dword_1E8F62D10 = -83885856;
  qword_1E8F62D18 = 1;
}

uint64_t static IPv4Address.mdnsGroup.getter@<X0>(uint64_t a1@<X8>)
{
  return sub_1834CD1A8(&qword_1E8F62028, &dword_1E8F62D10, &qword_1E8F62D18, a1);
}

uint64_t sub_1834CD1A8@<X0>(void *a1@<X0>, _DWORD *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  if (*a1 != -1) {
    swift_once();
  }
  uint64_t v7 = *a3;
  *(_DWORD *)a4 = *a2;
  *(void *)(a4 + 8) = v7;

  return sub_18315E9D4(v7);
}

uint64_t IPv4Address.isLoopback.getter()
{
  int v1 = *v0;
  uint64_t v2 = *((void *)v0 + 1);
  if (qword_1E8F62008 != -1) {
    swift_once();
  }
  if (v1 == dword_1E8F62CD0)
  {
    uint64_t v3 = qword_1E8F62CD8;
    if (v2 == 1)
    {
      if (qword_1E8F62CD8 == 1) {
        return v3 & 1;
      }
    }
    else
    {
      nw_interface_t v6 = v2;
      if (qword_1E8F62CD8 != 1)
      {
        uint64_t v5 = qword_1E8F62CD8;
        swift_unknownObjectRetain_n();
        LOBYTE(v3) = _s7Network11NWInterfaceV2eeoiySbAC_ACtFZ_0(&v6, (nw_interface_t *)&v5);
        swift_unknownObjectRelease();
        sub_18315E51C((uint64_t)v2);
        return v3 & 1;
      }
      swift_unknownObjectRetain();
    }
    sub_18315E9D4(v3);
    sub_18315E51C((uint64_t)v2);
    sub_18315E51C(v3);
    LOBYTE(v3) = 0;
  }
  else
  {
    LOBYTE(v3) = 0;
  }
  return v3 & 1;
}

BOOL IPv4Address.isLinkLocal.getter()
{
  return *v0 == -343;
}

BOOL IPv4Address.isMulticast.getter()
{
  return (*v0 & 0xF0) == 224;
}

uint64_t IPv4Address.rawValue.getter()
{
  v8[5] = *MEMORY[0x1E4F143B8];
  int v7 = *v0;
  v8[3] = MEMORY[0x1E4FBB2B8];
  void v8[4] = MEMORY[0x1E4F27EF0];
  v8[0] = &v7;
  v8[1] = v8;
  int v1 = __swift_project_boxed_opaque_existential_2(v8, MEMORY[0x1E4FBB2B8]);
  uint64_t v2 = (unsigned char *)*v1;
  if (*v1 && (uint64_t v3 = (unsigned char *)v1[1], v4 = v3 - v2, v3 != v2))
  {
    if (v4 <= 14)
    {
      uint64_t v5 = sub_1834D7CD4(v2, v3);
    }
    else if ((unint64_t)v4 >= 0x7FFFFFFF)
    {
      uint64_t v5 = sub_1834D7D98((uint64_t)v2, (uint64_t)v3);
    }
    else
    {
      uint64_t v5 = sub_1834D7E14((uint64_t)v2, (uint64_t)v3);
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
  __swift_destroy_boxed_opaque_existential_2((uint64_t)v8);
  return v5;
}

uint64_t sub_1834CD42C(unint64_t a1, unint64_t a2)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v40 = a1;
  *((void *)&v40 + 1) = a2;
  swift_bridgeObjectRetain();
  __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F62E40);
  if (swift_dynamicCast())
  {
    sub_1834D9964(v38, (uint64_t)&v41);
    __swift_project_boxed_opaque_existential_2(&v41, v43);
    sub_183D443AC();
    swift_bridgeObjectRelease();
    v38[0] = v40;
    __swift_destroy_boxed_opaque_existential_2((uint64_t)&v41);
    return *(void *)&v38[0];
  }
  uint64_t v39 = 0;
  memset(v38, 0, sizeof(v38));
  sub_183138A24((uint64_t)v38, &qword_1E8F62E48);
  unint64_t v2 = a1;
  unint64_t v3 = a2;
  if ((a2 & 0x1000000000000000) == 0)
  {
    if ((a2 & 0x2000000000000000) != 0)
    {
      uint64_t v41 = a1;
      uint64_t v42 = a2 & 0xFFFFFFFFFFFFFFLL;
      nw_interface_t v6 = (char *)&v41 + (HIBYTE(a2) & 0xF);
      int v7 = &v41;
    }
    else
    {
      if ((a1 & 0x1000000000000000) != 0)
      {
        uint64_t v4 = (a2 & 0xFFFFFFFFFFFFFFFLL) + 32;
        uint64_t v5 = a1 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        uint64_t v4 = sub_183D4557C();
      }
      if (v4) {
        nw_interface_t v6 = (unsigned char *)(v4 + v5);
      }
      else {
        nw_interface_t v6 = 0;
      }
      int v7 = (uint64_t *)v4;
    }
    uint64_t v8 = sub_1834D80D0(v7, v6);
    unint64_t v10 = v9;
    if (v9 >> 60 != 15)
    {
      swift_bridgeObjectRelease();
      *(void *)&v38[0] = v8;
      *((void *)&v38[0] + 1) = v10;
      return *(void *)&v38[0];
    }
    unint64_t v2 = a1;
    unint64_t v3 = a2;
    if ((a2 & 0x1000000000000000) == 0) {
      goto LABEL_14;
    }
LABEL_70:
    uint64_t v11 = sub_183D44CAC();
    goto LABEL_17;
  }
LABEL_69:
  uint64_t v8 = 0;
  unint64_t v10 = 0xF000000000000000;
  if ((v3 & 0x1000000000000000) != 0) {
    goto LABEL_70;
  }
LABEL_14:
  if ((v3 & 0x2000000000000000) != 0) {
    uint64_t v11 = HIBYTE(v3) & 0xF;
  }
  else {
    uint64_t v11 = v2 & 0xFFFFFFFFFFFFLL;
  }
LABEL_17:
  *(void *)&v38[0] = sub_1834D8134(v11);
  *((void *)&v38[0] + 1) = v12;
  MEMORY[0x1F4188790](*(void *)&v38[0]);
  unint64_t v13 = (unint64_t)sub_1834D696C((void *(*)(uint64_t *__return_ptr, char *, char *))sub_1834D98F8);
  uint64_t v16 = *((void *)&v38[0] + 1) >> 62;
  uint64_t v17 = v13;
  uint64_t v18 = v3;
  unint64_t v19 = v14;
  switch(*((void *)&v38[0] + 1) >> 62)
  {
    case 1:
      LODWORD(v20) = DWORD1(v38[0]) - LODWORD(v38[0]);
      if (__OFSUB__(DWORD1(v38[0]), v38[0])) {
        goto LABEL_73;
      }
      uint64_t v20 = (int)v20;
LABEL_23:
      if (v15 != v20)
      {
        if (v16)
        {
          if (v16 == 1) {
            uint64_t v24 = *(uint64_t *)&v38[0] >> 32;
          }
          else {
            uint64_t v24 = *(void *)(*(void *)&v38[0] + 24);
          }
        }
        else
        {
          uint64_t v24 = BYTE14(v38[0]);
        }
LABEL_61:
        if (v24 < v15)
        {
          __break(1u);
LABEL_73:
          __break(1u);
LABEL_74:
          __break(1u);
        }
        sub_183D444EC();
LABEL_63:
        swift_bridgeObjectRelease();
        goto LABEL_64;
      }
LABEL_29:
      if ((v3 & 0x2000000000000000) != 0) {
        unint64_t v25 = HIBYTE(v3) & 0xF;
      }
      else {
        unint64_t v25 = v13 & 0xFFFFFFFFFFFFLL;
      }
      *(void *)((char *)&v40 + 7) = 0;
      *(void *)&long long v40 = 0;
      if (4 * v25 == v14 >> 14) {
        goto LABEL_58;
      }
      LOBYTE(v26) = 0;
      uint64_t v27 = (v13 >> 59) & 1;
      if ((v3 & 0x1000000000000000) == 0) {
        LOBYTE(v27) = 1;
      }
      uint64_t v28 = 4 << v27;
      uint64_t v35 = v3 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v33 = (uint64_t)v8;
      uint64_t v34 = (v3 & 0xFFFFFFFFFFFFFFFLL) + 32;
      break;
    case 2:
      uint64_t v22 = *(void *)(*(void *)&v38[0] + 16);
      uint64_t v21 = *(void *)(*(void *)&v38[0] + 24);
      BOOL v23 = __OFSUB__(v21, v22);
      uint64_t v20 = v21 - v22;
      if (!v23) {
        goto LABEL_23;
      }
      goto LABEL_74;
    case 3:
      if (!v15) {
        goto LABEL_29;
      }
      uint64_t v24 = 0;
      goto LABEL_61;
    default:
      uint64_t v20 = BYTE14(v38[0]);
      goto LABEL_23;
  }
  do
  {
    unint64_t v29 = v19 & 0xC;
    unint64_t v2 = v19;
    if (v29 == v28) {
      unint64_t v2 = sub_183520284(v19, v17, v18);
    }
    unint64_t v30 = v2 >> 16;
    if (v2 >> 16 >= v25)
    {
      __break(1u);
LABEL_67:
      __break(1u);
LABEL_68:
      __break(1u);
      goto LABEL_69;
    }
    if ((v18 & 0x1000000000000000) != 0)
    {
      unint64_t v2 = sub_183D44CFC();
      char v31 = v2;
      if (v29 != v28) {
        goto LABEL_47;
      }
    }
    else if ((v18 & 0x2000000000000000) != 0)
    {
      uint64_t v41 = v17;
      uint64_t v42 = v35;
      char v31 = *((unsigned char *)&v41 + v30);
      if (v29 != v28) {
        goto LABEL_47;
      }
    }
    else
    {
      unint64_t v2 = v34;
      if ((v17 & 0x1000000000000000) == 0) {
        unint64_t v2 = sub_183D4557C();
      }
      char v31 = *(unsigned char *)(v2 + v30);
      if (v29 != v28)
      {
LABEL_47:
        if ((v18 & 0x1000000000000000) == 0) {
          goto LABEL_48;
        }
        goto LABEL_51;
      }
    }
    unint64_t v2 = sub_183520284(v19, v17, v18);
    unint64_t v19 = v2;
    if ((v18 & 0x1000000000000000) == 0)
    {
LABEL_48:
      unint64_t v19 = (v19 & 0xFFFFFFFFFFFF0000) + 65540;
      goto LABEL_53;
    }
LABEL_51:
    if (v25 <= v19 >> 16) {
      goto LABEL_68;
    }
    unint64_t v2 = sub_183D44CBC();
    unint64_t v19 = v2;
LABEL_53:
    *((unsigned char *)&v40 + v26) = v31;
    unsigned int v26 = v26 + 1;
    if ((v26 >> 8)) {
      goto LABEL_67;
    }
    BYTE14(v40) = v26;
    if (v26 == 14)
    {
      uint64_t v41 = v40;
      LODWORD(v42) = DWORD2(v40);
      WORD2(v42) = WORD6(v40);
      sub_183D4450C();
      LOBYTE(v26) = 0;
      BYTE14(v40) = 0;
    }
  }
  while (4 * v25 != v19 >> 14);
  uint64_t v8 = (unsigned char *)v33;
  if ((_BYTE)v26)
  {
    uint64_t v41 = v40;
    LODWORD(v42) = DWORD2(v40);
    WORD2(v42) = WORD6(v40);
    sub_183D4450C();
    sub_1832E669C(v33, v10);
    goto LABEL_63;
  }
LABEL_58:
  swift_bridgeObjectRelease();
  sub_1832E669C((uint64_t)v8, v10);
LABEL_64:
  swift_bridgeObjectRelease();
  return *(void *)&v38[0];
}

uint64_t sub_1834CD95C(uint64_t a1, uint64_t a2)
{
  v8[3] = MEMORY[0x1E4FBB2B8];
  void v8[4] = MEMORY[0x1E4F27EF0];
  v8[0] = a1;
  v8[1] = a2;
  unint64_t v2 = __swift_project_boxed_opaque_existential_2(v8, MEMORY[0x1E4FBB2B8]);
  unint64_t v3 = (unsigned char *)*v2;
  if (*v2 && (uint64_t v4 = (unsigned char *)v2[1], v5 = v4 - v3, v4 != v3))
  {
    if (v5 <= 14)
    {
      uint64_t v6 = sub_1834D7CD4(v3, v4);
    }
    else if ((unint64_t)v5 >= 0x7FFFFFFF)
    {
      uint64_t v6 = sub_1834D7D98((uint64_t)v3, (uint64_t)v4);
    }
    else
    {
      uint64_t v6 = sub_1834D7E14((uint64_t)v3, (uint64_t)v4);
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
  __swift_destroy_boxed_opaque_existential_2((uint64_t)v8);
  return v6;
}

uint64_t IPv4Address.init(_:_:)@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X2>, void *a4@<X8>)
{
  uint64_t v5 = *a3;
  unint64_t v6 = a2 >> 62;
  switch(a2 >> 62)
  {
    case 1uLL:
      LODWORD(v9) = HIDWORD(a1) - a1;
      if (__OFSUB__(HIDWORD(a1), a1))
      {
        __break(1u);
LABEL_21:
        __break(1u);
        goto LABEL_22;
      }
      uint64_t v9 = (int)v9;
LABEL_6:
      if (v9 == 4)
      {
        if (!v6)
        {
          unsigned int v17 = a1;
          goto LABEL_18;
        }
        if (v6 != 1)
        {
          uint64_t v20 = *(void *)(a1 + 16);
          swift_retain();
          swift_retain();
          uint64_t v21 = sub_183D4434C();
          if (!v21)
          {
LABEL_26:
            sub_183D4436C();
            __break(1u);
            JUMPOUT(0x1834CDB9CLL);
          }
          uint64_t v22 = v21;
          uint64_t v23 = sub_183D4437C();
          BOOL v12 = __OFSUB__(v20, v23);
          uint64_t v24 = v20 - v23;
          if (!v12)
          {
            sub_183D4436C();
            unsigned int v17 = *(_DWORD *)(v22 + v24);
            swift_release();
            swift_release();
            goto LABEL_18;
          }
          goto LABEL_23;
        }
        if ((int)a1 <= a1 >> 32)
        {
          uint64_t v13 = sub_183D4434C();
          if (!v13)
          {
LABEL_25:
            sub_183D4436C();
            __break(1u);
            goto LABEL_26;
          }
          uint64_t v14 = v13;
          uint64_t v15 = sub_183D4437C();
          uint64_t v16 = (int)a1 - v15;
          if (!__OFSUB__((int)a1, v15))
          {
            sub_183D4436C();
            unsigned int v17 = *(_DWORD *)(v14 + v16);
LABEL_18:
            uint64_t result = sub_1832E5E9C(a1, a2);
            uint64_t v19 = v17;
            goto LABEL_19;
          }
LABEL_24:
          __break(1u);
          goto LABEL_25;
        }
LABEL_22:
        __break(1u);
LABEL_23:
        __break(1u);
        goto LABEL_24;
      }
LABEL_13:
      sub_1832E5E9C(a1, a2);
      uint64_t result = sub_18315E51C(v5);
      uint64_t v19 = 0;
      uint64_t v5 = 2;
LABEL_19:
      *a4 = v19;
      a4[1] = v5;
      return result;
    case 2uLL:
      uint64_t v11 = *(void *)(a1 + 16);
      uint64_t v10 = *(void *)(a1 + 24);
      BOOL v12 = __OFSUB__(v10, v11);
      uint64_t v9 = v10 - v11;
      if (!v12) {
        goto LABEL_6;
      }
      goto LABEL_21;
    case 3uLL:
      goto LABEL_13;
    default:
      uint64_t v9 = BYTE6(a2);
      goto LABEL_6;
  }
}

void IPv4Address.init(_:)(uint64_t a1@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v4 = 2;
  sub_1834CCB60(a1, a2, 2, (uint64_t)&v6);
  swift_bridgeObjectRelease();
  if (v9 == 255)
  {
    uint64_t v5 = 0;
  }
  else
  {
    uint64_t v4 = v7;
    if (v9 == 1)
    {
      uint64_t v5 = v6;
    }
    else
    {
      sub_1834D7E98(v6, v7, v8, v9);
      uint64_t v5 = 0;
      uint64_t v4 = 2;
    }
  }
  *a3 = v5;
  a3[1] = v4;
}

uint64_t IPv4Address.interface.getter@<X0>(uint64_t *a1@<X8>)
{
  uint64_t v2 = *(void *)(v1 + 8);
  *a1 = v2;
  return sub_18315E9D4(v2);
}

uint64_t IPv4Address.hash(into:)()
{
  uint64_t v1 = *(NSObject **)(v0 + 8);
  sub_183D45B3C();
  if (v1 == 1) {
    return sub_183D45B1C();
  }
  sub_183D45B1C();
  if (v1)
  {
    nw_interface_get_index(v1);
    sub_183D45B0C();
    unint64_t v3 = swift_unknownObjectRetain();
    nw_interface_get_name(v3);
    sub_183D44C9C();
  }
  else
  {
    sub_183D45B0C();
  }
  sub_18315E51C((uint64_t)v1);
  sub_183D44C4C();

  return swift_bridgeObjectRelease();
}

uint64_t IPv4Address.debugDescription.getter()
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  int v1 = *v0;
  uint64_t v2 = *((void *)v0 + 1);
  *(_DWORD *)&v6.size_t sa_len = 528;
  *(_DWORD *)&v6.sa_data[2] = v1;
  *(void *)&v6.sa_data[6] = 0;
  unint64_t v3 = (char *)swift_slowAlloc();
  if (getnameinfo(&v6, 0x10u, v3, 0x64u, 0, 0, 2)) {
    uint64_t v4 = 63;
  }
  else {
    uint64_t v4 = sub_183D44C9C();
  }
  MEMORY[0x185318E50](v3, -1, -1);
  if (v2 != 1)
  {
    swift_unknownObjectRetain();
    sub_183D44C8C();
    swift_bridgeObjectRelease();
    sub_183D44C8C();
    uint64_t v7 = v2;
    sub_183D4566C();
    sub_18315E51C(v2);
    return 0;
  }
  return v4;
}

uint64_t IPv4Address.hashValue.getter()
{
  int v1 = *(NSObject **)(v0 + 8);
  sub_183D45AFC();
  sub_183D45B3C();
  if (v1 == 1)
  {
    sub_183D45B1C();
  }
  else
  {
    sub_183D45B1C();
    if (v1)
    {
      nw_interface_get_index(v1);
      sub_183D45B0C();
      uint64_t v2 = swift_unknownObjectRetain();
      nw_interface_get_name(v2);
      sub_183D44C9C();
    }
    else
    {
      sub_183D45B0C();
    }
    sub_18315E51C((uint64_t)v1);
    sub_183D44C4C();
    swift_bridgeObjectRelease();
  }
  return sub_183D45B4C();
}

uint64_t sub_1834CDF4C()
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  int v2 = *v0;
  return sub_1834CD95C((uint64_t)&v2, (uint64_t)&v3);
}

void sub_1834CDFB0(uint64_t a1@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v4 = 2;
  sub_1834CCB60(a1, a2, 2, (uint64_t)&v6);
  swift_bridgeObjectRelease();
  if (v9 == 255)
  {
    uint64_t v5 = 0;
  }
  else
  {
    uint64_t v4 = v7;
    if (v9 == 1)
    {
      uint64_t v5 = v6;
    }
    else
    {
      sub_1834D7E98(v6, v7, v8, v9);
      uint64_t v5 = 0;
      uint64_t v4 = 2;
    }
  }
  *a3 = v5;
  a3[1] = v4;
}

uint64_t sub_1834CE03C@<X0>(uint64_t *a1@<X8>)
{
  uint64_t v2 = *(void *)(v1 + 8);
  *a1 = v2;
  return sub_18315E9D4(v2);
}

uint64_t sub_1834CE048()
{
  uint64_t v1 = *((void *)v0 + 1);
  int v5 = *v0;
  uint64_t v6 = v1;
  if (qword_1E8F62008 != -1) {
    swift_once();
  }
  int v3 = dword_1E8F62CD0;
  uint64_t v4 = qword_1E8F62CD8;
  return _s7Network11IPv4AddressV2eeoiySbAC_ACtFZ_0((uint64_t)&v5, (uint64_t)&v3) & 1;
}

BOOL sub_1834CE0CC()
{
  return *v0 == -343;
}

BOOL sub_1834CE0DC()
{
  return (*v0 & 0xF0) == 224;
}

uint64_t sub_1834CE0F4()
{
  uint64_t v1 = *(NSObject **)(v0 + 8);
  sub_183D45B3C();
  if (v1 == 1) {
    return sub_183D45B1C();
  }
  sub_183D45B1C();
  if (v1)
  {
    nw_interface_get_index(v1);
    sub_183D45B0C();
    int v3 = swift_unknownObjectRetain();
    nw_interface_get_name(v3);
    sub_183D44C9C();
  }
  else
  {
    sub_183D45B0C();
  }
  sub_18315E51C((uint64_t)v1);
  sub_183D44C4C();

  return swift_bridgeObjectRelease();
}

uint64_t sub_1834CE1CC()
{
  uint64_t v1 = *(NSObject **)(v0 + 8);
  sub_183D45AFC();
  sub_183D45B3C();
  if (v1 == 1)
  {
    sub_183D45B1C();
  }
  else
  {
    sub_183D45B1C();
    if (v1)
    {
      nw_interface_get_index(v1);
      sub_183D45B0C();
      uint64_t v2 = swift_unknownObjectRetain();
      nw_interface_get_name(v2);
      sub_183D44C9C();
    }
    else
    {
      sub_183D45B0C();
    }
    sub_18315E51C((uint64_t)v1);
    sub_183D44C4C();
    swift_bridgeObjectRelease();
  }
  return sub_183D45B4C();
}

void sub_1834CE2B8()
{
  uint64_t v0 = *(void *)(MEMORY[0x1E4F148B8] + 8);
  qword_1E8F62D20 = *MEMORY[0x1E4F148B8];
  *(void *)algn_1E8F62D28 = v0;
  qword_1E8F62D30 = 1;
}

uint64_t static IPv6Address.any.getter@<X0>(void *a1@<X8>)
{
  return sub_1834CE480(&qword_1E8F62030, &qword_1E8F62D20, &qword_1E8F62D30, a1);
}

void sub_1834CE304()
{
  uint64_t v0 = *(void *)(MEMORY[0x1E4F148B8] + 8);
  qword_1E8F62D38 = *MEMORY[0x1E4F148B8];
  unk_1E8F62D40 = v0;
  qword_1E8F62D48 = 1;
}

uint64_t static IPv6Address.broadcast.getter@<X0>(void *a1@<X8>)
{
  return sub_1834CE480(&qword_1E8F62038, &qword_1E8F62D38, &qword_1E8F62D48, a1);
}

void sub_1834CE350()
{
  uint64_t v0 = *(void *)(MEMORY[0x1E4F148D0] + 8);
  qword_1E8F62D50 = *MEMORY[0x1E4F148D0];
  *(void *)algn_1E8F62D58 = v0;
  qword_1E8F62D60 = 1;
}

uint64_t static IPv6Address.loopback.getter@<X0>(void *a1@<X8>)
{
  return sub_1834CE480(&qword_1E8F62040, &qword_1E8F62D50, &qword_1E8F62D60, a1);
}

void sub_1834CE39C()
{
  uint64_t v0 = *(void *)(MEMORY[0x1E4F148D8] + 8);
  qword_1E8F62D68 = *MEMORY[0x1E4F148D8];
  unk_1E8F62D70 = v0;
  qword_1E8F62D78 = 1;
}

uint64_t static IPv6Address.nodeLocalNodes.getter@<X0>(void *a1@<X8>)
{
  return sub_1834CE480(&qword_1E8F62048, &qword_1E8F62D68, &qword_1E8F62D78, a1);
}

void sub_1834CE3E8()
{
  uint64_t v0 = *(void *)(MEMORY[0x1E4F148C0] + 8);
  qword_1E8F62D80 = *MEMORY[0x1E4F148C0];
  *(void *)algn_1E8F62D88 = v0;
  qword_1E8F62D90 = 1;
}

uint64_t static IPv6Address.linkLocalNodes.getter@<X0>(void *a1@<X8>)
{
  return sub_1834CE480(&qword_1E8F62050, &qword_1E8F62D80, &qword_1E8F62D90, a1);
}

void sub_1834CE434()
{
  uint64_t v0 = *(void *)(MEMORY[0x1E4F148C8] + 8);
  qword_1E8F62D98 = *MEMORY[0x1E4F148C8];
  unk_1E8F62DA0 = v0;
  qword_1E8F62DA8 = 1;
}

uint64_t static IPv6Address.linkLocalRouters.getter@<X0>(void *a1@<X8>)
{
  return sub_1834CE480(&qword_1E8F62058, &qword_1E8F62D98, &qword_1E8F62DA8, a1);
}

uint64_t sub_1834CE480@<X0>(void *a1@<X0>, void *a2@<X1>, uint64_t *a3@<X2>, void *a4@<X8>)
{
  if (*a1 != -1) {
    swift_once();
  }
  uint64_t v7 = a2[1];
  uint64_t v8 = *a3;
  *a4 = *a2;
  a4[1] = v7;
  a4[2] = v8;

  return sub_18315E9D4(v8);
}

Network::IPv6Address::Scope_optional __swiftcall IPv6Address.Scope.init(rawValue:)(Network::IPv6Address::Scope_optional rawValue)
{
  char v2 = 1;
  switch(rawValue.value)
  {
    case 1:
      char v2 = 0;
      goto LABEL_3;
    case 2:
LABEL_3:
      char *v1 = v2;
      break;
    case 5:
      char *v1 = 2;
      break;
    case 8:
      char *v1 = 3;
      break;
    case 0xE:
      char *v1 = 4;
      break;
    default:
      char *v1 = 5;
      break;
  }
  return rawValue;
}

unint64_t IPv6Address.Scope.rawValue.getter()
{
  return 0xE08050201uLL >> (8 * *v0);
}

BOOL sub_1834CE5AC(unsigned char *a1, unsigned char *a2)
{
  return ((0xE08050201uLL >> (8 * *a1)) & 0xF) == ((0xE08050201uLL >> (8 * *a2)) & 0xF);
}

uint64_t sub_1834CE5E4()
{
  return sub_183D45B4C();
}

uint64_t sub_1834CE63C()
{
  return sub_183D45B1C();
}

uint64_t sub_1834CE67C()
{
  return sub_183D45B4C();
}

Network::IPv6Address::Scope_optional sub_1834CE6D0(Swift::UInt8 *a1)
{
  return IPv6Address.Scope.init(rawValue:)(*a1);
}

void sub_1834CE6D8(unsigned char *a1@<X8>)
{
  *a1 = 0xE08050201uLL >> (8 * *v1);
}

BOOL IPv6Address.isAny.getter()
{
  return *v0 == 0;
}

BOOL IPv6Address.isLoopback.getter()
{
  return (*v0 | v0[1] ^ 0x100000000000000) == 0;
}

BOOL IPv6Address.isIPv4Compatabile.getter()
{
  uint64_t v1 = HIDWORD(v0[1]);
  if (*v0 | v0[1]) {
    BOOL v2 = 1;
  }
  else {
    BOOL v2 = v1 == 0;
  }
  return !v2 && v1 != 0x1000000;
}

BOOL IPv6Address.is6to4.getter()
{
  return *v0 == 544;
}

BOOL IPv6Address.isLinkLocal.getter()
{
  return (*v0 & 0xC0FFLL) == 33022;
}

BOOL IPv6Address.isMulticast.getter()
{
  return *v0 == 255;
}

void IPv6Address.multicastScope.getter(char *a1@<X8>)
{
  if (*(unsigned char *)v1 == 0xFF)
  {
    char v2 = 0;
    switch((*v1 >> 8) & 0xF)
    {
      case 1u:
        goto LABEL_3;
      case 2u:
        *a1 = 1;
        break;
      case 5u:
        *a1 = 2;
        break;
      case 8u:
        *a1 = 3;
        break;
      case 0xEu:
        *a1 = 4;
        break;
      default:
        goto LABEL_2;
    }
  }
  else
  {
LABEL_2:
    char v2 = 5;
LABEL_3:
    *a1 = v2;
  }
}

uint64_t IPv6Address.rawValue.getter()
{
  v10[1] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = v0[1];
  v9[0] = *v0;
  v9[1] = v1;
  v8[3] = MEMORY[0x1E4FBB2B8];
  void v8[4] = MEMORY[0x1E4F27EF0];
  v8[0] = v9;
  v8[1] = v10;
  char v2 = __swift_project_boxed_opaque_existential_2(v8, MEMORY[0x1E4FBB2B8]);
  int v3 = (unsigned char *)*v2;
  if (*v2 && (uint64_t v4 = (unsigned char *)v2[1], v5 = v4 - v3, v4 != v3))
  {
    if (v5 <= 14)
    {
      uint64_t v6 = sub_1834D7CD4(v3, v4);
    }
    else if ((unint64_t)v5 >= 0x7FFFFFFF)
    {
      uint64_t v6 = sub_1834D7D98((uint64_t)v3, (uint64_t)v4);
    }
    else
    {
      uint64_t v6 = sub_1834D7E14((uint64_t)v3, (uint64_t)v4);
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
  __swift_destroy_boxed_opaque_existential_2((uint64_t)v8);
  return v6;
}

BOOL sub_1834CE934(BOOL result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 16);
  if (!v2) {
    return 0;
  }
  int v3 = result;
  if (*(unsigned char *)(a2 + 32) == result) {
    return 1;
  }
  if (v2 == 1) {
    return 0;
  }
  for (uint64_t i = 33; ; ++i)
  {
    uint64_t v5 = i - 31;
    if (__OFADD__(i - 32, 1)) {
      break;
    }
    int v6 = *(unsigned __int8 *)(a2 + i);
    uint64_t result = v6 == v3;
    if (v6 == v3 || v5 == v2) {
      return result;
    }
  }
  __break(1u);
  return result;
}

BOOL IPv6Address.isUniqueLocal.getter()
{
  v8[1] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = v0[1];
  v7[0] = *v0;
  v7[1] = v1;
  uint64_t v2 = sub_1834CD95C((uint64_t)v7, (uint64_t)v8);
  unint64_t v4 = v3;
  uint64_t v5 = sub_183D4458C();
  sub_1832E5E9C(v2, v4);
  return sub_1834CE934(v5, (uint64_t)&unk_1ECF5C9B8);
}

uint64_t IPv6Address.init(_:_:)@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v5 = *a3;
  unint64_t v6 = a2 >> 62;
  uint64_t v8 = a1;
  switch(a2 >> 62)
  {
    case 1uLL:
      LODWORD(v9) = HIDWORD(a1) - a1;
      if (__OFSUB__(HIDWORD(a1), a1))
      {
        __break(1u);
LABEL_20:
        __break(1u);
        goto LABEL_21;
      }
      uint64_t v9 = (int)v9;
LABEL_6:
      if (v9 != 16)
      {
LABEL_13:
        sub_1832E5E9C(a1, a2);
        uint64_t result = sub_18315E51C(v5);
        *a4 = 0;
        a4[1] = 0;
        a4[2] = 2;
        return result;
      }
      if (!v6)
      {
        uint64_t result = sub_1832E5E9C(a1, a2);
        uint64_t v18 = a2 & 0xFFFFFFFFFFFFLL;
        goto LABEL_18;
      }
      if (v6 != 1)
      {
        uint64_t v20 = *(void *)(a1 + 16);
        swift_retain();
        swift_retain();
        uint64_t v21 = sub_183D4434C();
        if (!v21)
        {
LABEL_25:
          sub_183D4436C();
          __break(1u);
          JUMPOUT(0x1834CEBF0);
        }
        uint64_t v22 = v21;
        uint64_t v23 = sub_183D4437C();
        BOOL v12 = __OFSUB__(v20, v23);
        uint64_t v24 = v20 - v23;
        if (!v12)
        {
          sub_183D4436C();
          uint64_t v25 = v22 + v24;
          uint64_t v26 = *(void *)(v22 + v24);
          uint64_t v18 = *(void *)(v25 + 8);
          swift_release();
          swift_release();
          uint64_t result = sub_1832E5E9C(v8, a2);
          uint64_t v8 = v26;
          goto LABEL_18;
        }
        goto LABEL_22;
      }
      if ((int)a1 > a1 >> 32)
      {
LABEL_21:
        __break(1u);
LABEL_22:
        __break(1u);
        goto LABEL_23;
      }
      uint64_t v13 = sub_183D4434C();
      if (!v13)
      {
LABEL_24:
        sub_183D4436C();
        __break(1u);
        goto LABEL_25;
      }
      uint64_t v14 = v13;
      uint64_t v15 = sub_183D4437C();
      uint64_t v16 = (int)v8 - v15;
      if (__OFSUB__((int)v8, v15))
      {
LABEL_23:
        __break(1u);
        goto LABEL_24;
      }
      sub_183D4436C();
      uint64_t v17 = *(void *)(v14 + v16);
      uint64_t v18 = *(void *)(v14 + v16 + 8);
      uint64_t result = sub_1832E5E9C(v8, a2);
      uint64_t v8 = v17;
LABEL_18:
      *a4 = v8;
      a4[1] = v18;
      a4[2] = v5;
      return result;
    case 2uLL:
      uint64_t v11 = *(void *)(a1 + 16);
      uint64_t v10 = *(void *)(a1 + 24);
      BOOL v12 = __OFSUB__(v10, v11);
      uint64_t v9 = v10 - v11;
      if (!v12) {
        goto LABEL_6;
      }
      goto LABEL_20;
    case 3uLL:
      goto LABEL_13;
    default:
      uint64_t v9 = BYTE6(a2);
      goto LABEL_6;
  }
}

void IPv6Address.init(_:)(uint64_t a1@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  sub_1834CCB60(a1, a2, 30, (uint64_t)&v6);
  swift_bridgeObjectRelease();
  if (v9 != 255)
  {
    uint64_t v4 = v7;
    uint64_t v5 = v8;
    if (v9 == 2)
    {
      *a3 = v6;
      a3[1] = v4;
      a3[2] = v5;
      return;
    }
    sub_1834D7E98(v6, v7, v8, v9);
  }
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 2;
}

uint64_t IPv6Address.interface.getter@<X0>(uint64_t *a1@<X8>)
{
  uint64_t v2 = *(void *)(v1 + 16);
  *a1 = v2;
  return sub_18315E9D4(v2);
}

uint64_t IPv6Address.hash(into:)()
{
  uint64_t v1 = *(NSObject **)(v0 + 16);
  sub_183D45B3C();
  sub_183D45B3C();
  sub_183D45B3C();
  sub_183D45B3C();
  if (v1 == 1) {
    return sub_183D45B1C();
  }
  sub_183D45B1C();
  if (v1)
  {
    nw_interface_get_index(v1);
    sub_183D45B0C();
    unint64_t v3 = swift_unknownObjectRetain();
    nw_interface_get_name(v3);
    sub_183D44C9C();
  }
  else
  {
    sub_183D45B0C();
  }
  sub_18315E51C((uint64_t)v1);
  sub_183D44C4C();

  return swift_bridgeObjectRelease();
}

uint64_t IPv6Address.debugDescription.getter()
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *v0;
  uint64_t v2 = v0[2];
  uint64_t v7 = v0[1];
  *(void *)&v6.size_t sa_len = 7708;
  *(void *)&v6.sa_data[6] = v1;
  int v8 = 0;
  unint64_t v3 = (char *)swift_slowAlloc();
  if (getnameinfo(&v6, 0x1Cu, v3, 0x64u, 0, 0, 2)) {
    uint64_t v4 = 63;
  }
  else {
    uint64_t v4 = sub_183D44C9C();
  }
  MEMORY[0x185318E50](v3, -1, -1);
  if (v2 != 1)
  {
    swift_unknownObjectRetain();
    sub_183D44C8C();
    swift_bridgeObjectRelease();
    sub_183D44C8C();
    sub_183D4566C();
    sub_18315E51C(v2);
    return 0;
  }
  return v4;
}

uint64_t IPv6Address.hashValue.getter()
{
  uint64_t v1 = *(NSObject **)(v0 + 16);
  sub_183D45AFC();
  sub_183D45B3C();
  sub_183D45B3C();
  sub_183D45B3C();
  sub_183D45B3C();
  if (v1 == 1)
  {
    sub_183D45B1C();
  }
  else
  {
    sub_183D45B1C();
    if (v1)
    {
      nw_interface_get_index(v1);
      sub_183D45B0C();
      uint64_t v2 = swift_unknownObjectRetain();
      nw_interface_get_name(v2);
      sub_183D44C9C();
    }
    else
    {
      sub_183D45B0C();
    }
    sub_18315E51C((uint64_t)v1);
    sub_183D44C4C();
    swift_bridgeObjectRelease();
  }
  return sub_183D45B4C();
}

uint64_t sub_1834CEFF0()
{
  v4[1] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = v0[1];
  v3[0] = *v0;
  v3[1] = v1;
  return sub_1834CD95C((uint64_t)v3, (uint64_t)v4);
}

void sub_1834CF054(uint64_t a1@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  sub_1834CCB60(a1, a2, 30, (uint64_t)&v6);
  swift_bridgeObjectRelease();
  if (v9 != 255)
  {
    uint64_t v4 = v7;
    uint64_t v5 = v8;
    if (v9 == 2)
    {
      *a3 = v6;
      a3[1] = v4;
      a3[2] = v5;
      return;
    }
    sub_1834D7E98(v6, v7, v8, v9);
  }
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 2;
}

uint64_t sub_1834CF0CC@<X0>(uint64_t *a1@<X8>)
{
  uint64_t v2 = *(void *)(v1 + 16);
  *a1 = v2;
  return sub_18315E9D4(v2);
}

BOOL sub_1834CF0D8()
{
  return (*v0 | v0[1] ^ 0x100000000000000) == 0;
}

BOOL sub_1834CF0F0()
{
  return (*v0 & 0xC0FFLL) == 33022;
}

BOOL sub_1834CF10C()
{
  return *v0 == 255;
}

uint64_t sub_1834CF124()
{
  uint64_t v1 = *(NSObject **)(v0 + 16);
  sub_183D45AFC();
  sub_183D45B3C();
  sub_183D45B3C();
  sub_183D45B3C();
  sub_183D45B3C();
  if (v1 == 1)
  {
    sub_183D45B1C();
  }
  else
  {
    sub_183D45B1C();
    if (v1)
    {
      nw_interface_get_index(v1);
      sub_183D45B0C();
      uint64_t v2 = swift_unknownObjectRetain();
      nw_interface_get_name(v2);
      sub_183D44C9C();
    }
    else
    {
      sub_183D45B0C();
    }
    sub_18315E51C((uint64_t)v1);
    sub_183D44C4C();
    swift_bridgeObjectRelease();
  }
  return sub_183D45B4C();
}

void __swiftcall EthernetAddress.init(_:)(Network::EthernetAddress *__return_ptr retstr, ether_addr *a2)
{
  *(_WORD *)retstr->addr.octet = (_WORD)a2;
  retstr->addr.octet[2] = BYTE2(a2);
  retstr->addr.octet[3] = BYTE3(a2);
  retstr->addr.octet[4] = BYTE4(a2);
  retstr->addr.octet[5] = BYTE5(a2);
}

uint64_t EthernetAddress.init(_:)@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v4 = a2 >> 62;
  switch(a2 >> 62)
  {
    case 1uLL:
      LODWORD(v7) = HIDWORD(a1) - a1;
      if (__OFSUB__(HIDWORD(a1), a1))
      {
        __break(1u);
LABEL_21:
        __break(1u);
        goto LABEL_22;
      }
      uint64_t v7 = (int)v7;
LABEL_6:
      if (v7 == 6)
      {
        if (!v4)
        {
          uint64x2_t v22 = (uint64x2_t)vdupq_n_s64(a1);
          *(int16x4_t *)v34.i8 = vmovn_s32(vuzp1q_s32((int32x4_t)vshlq_u64(v22, (uint64x2_t)xmmword_183D54820), (int32x4_t)vshlq_u64(v22, (uint64x2_t)xmmword_183D54810)));
          unint64_t v18 = (unint64_t)a1 >> 40;
          unsigned __int8 v16 = a1;
          goto LABEL_18;
        }
        if (v4 != 1)
        {
          uint64_t v23 = *(void *)(a1 + 16);
          swift_retain();
          swift_retain();
          uint64_t v24 = sub_183D4434C();
          if (!v24)
          {
LABEL_26:
            sub_183D4436C();
            __break(1u);
            JUMPOUT(0x1834CF490);
          }
          uint64_t v25 = v24;
          uint64_t v26 = sub_183D4437C();
          BOOL v10 = __OFSUB__(v23, v26);
          uint64_t v27 = v23 - v26;
          if (!v10)
          {
            sub_183D4436C();
            uint64_t v28 = v25 + v27;
            unsigned __int8 v16 = *(unsigned char *)(v25 + v27);
            v29.i32[0] = *(_DWORD *)(v28 + 1);
            uint16x8_t v34 = vmovl_u8(v29);
            unint64_t v18 = *(unsigned __int8 *)(v28 + 5);
            swift_release();
            swift_release();
            goto LABEL_18;
          }
          goto LABEL_23;
        }
        if ((int)a1 <= a1 >> 32)
        {
          uint64_t v11 = sub_183D4434C();
          if (!v11)
          {
LABEL_25:
            sub_183D4436C();
            __break(1u);
            goto LABEL_26;
          }
          uint64_t v12 = v11;
          uint64_t v13 = sub_183D4437C();
          uint64_t v14 = (int)a1 - v13;
          if (!__OFSUB__((int)a1, v13))
          {
            sub_183D4436C();
            uint64_t v15 = v12 + v14;
            unsigned __int8 v16 = *(unsigned char *)(v12 + v14);
            v17.i32[0] = *(_DWORD *)(v15 + 1);
            uint16x8_t v34 = vmovl_u8(v17);
            unint64_t v18 = *(unsigned __int8 *)(v15 + 5);
LABEL_18:
            uint64_t result = sub_1832E5E9C(a1, a2);
            char v21 = 0;
            uint32x4_t v30 = vmovl_u16((uint16x4_t)(v34.i64[0] & 0xFF00FF00FF00FFLL));
            v31.i64[0] = v30.u32[0];
            v31.i64[1] = v30.u32[1];
            uint64x2_t v32 = v31;
            v31.i64[0] = v30.u32[2];
            v31.i64[1] = v30.u32[3];
            int8x16_t v33 = vorrq_s8((int8x16_t)vshlq_u64(v32, (uint64x2_t)xmmword_183D54840), (int8x16_t)vshlq_u64(v31, (uint64x2_t)xmmword_183D54830));
            unint64_t v20 = *(void *)&vorr_s8(*(int8x8_t *)v33.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v33, v33, 8uLL)) | (v18 << 40) | v16;
            goto LABEL_19;
          }
LABEL_24:
          __break(1u);
          goto LABEL_25;
        }
LABEL_22:
        __break(1u);
LABEL_23:
        __break(1u);
        goto LABEL_24;
      }
LABEL_13:
      uint64_t result = sub_1832E5E9C(a1, a2);
      unint64_t v20 = 0;
      char v21 = 1;
LABEL_19:
      *(_DWORD *)a3 = v20;
      *(_WORD *)(a3 + 4) = WORD2(v20);
      *(unsigned char *)(a3 + 6) = v21;
      return result;
    case 2uLL:
      uint64_t v9 = *(void *)(a1 + 16);
      uint64_t v8 = *(void *)(a1 + 24);
      BOOL v10 = __OFSUB__(v8, v9);
      uint64_t v7 = v8 - v9;
      if (!v10) {
        goto LABEL_6;
      }
      goto LABEL_21;
    case 3uLL:
      goto LABEL_13;
    default:
      uint64_t v7 = BYTE6(a2);
      goto LABEL_6;
  }
}

uint64_t EthernetAddress.hash(into:)()
{
  return sub_183D45B1C();
}

uint64_t EthernetAddress.debugDescription.getter()
{
  char v1 = *v0;
  char v2 = v0[1];
  char v3 = v0[2];
  char v4 = v0[3];
  char v5 = v0[4];
  char v6 = v0[5];
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_1E8F62DB0);
  uint64_t v7 = swift_allocObject();
  *(_OWORD *)(v7 + 16) = xmmword_183D54850;
  uint64_t v8 = MEMORY[0x1E4FBC358];
  uint64_t v9 = MEMORY[0x1E4FBC3B0];
  *(void *)(v7 + 56) = MEMORY[0x1E4FBC358];
  *(void *)(v7 + 64) = v9;
  *(unsigned char *)(v7 + 32) = v1;
  *(void *)(v7 + 96) = v8;
  *(void *)(v7 + 104) = v9;
  *(unsigned char *)(v7 + 72) = v2;
  *(void *)(v7 + 136) = v8;
  *(void *)(v7 + 144) = v9;
  *(unsigned char *)(v7 + 112) = v3;
  *(void *)(v7 + 176) = v8;
  *(void *)(v7 + 184) = v9;
  *(unsigned char *)(v7 + 152) = v4;
  *(void *)(v7 + 216) = v8;
  *(void *)(v7 + 224) = v9;
  *(unsigned char *)(v7 + 192) = v5;
  *(void *)(v7 + 256) = v8;
  *(void *)(v7 + 264) = v9;
  *(unsigned char *)(v7 + 232) = v6;

  return MEMORY[0x1F40E6238](0xD00000000000001DLL, 0x8000000183E23EF0, v7);
}

uint64_t EthernetAddress.hashValue.getter()
{
  return sub_183D45B4C();
}

uint64_t sub_1834CF6A8()
{
  return sub_183D45B4C();
}

uint64_t sub_1834CF758()
{
  return sub_183D45B1C();
}

uint64_t sub_1834CF7D8()
{
  return sub_183D45B4C();
}

double NWEndpoint.Host.init(stringLiteral:)@<D0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  NWEndpoint.Host.init(_:)(a1, a2, (uint64_t)&v7);
  uint64_t v4 = v8;
  char v5 = v9;
  double result = *(double *)&v7;
  *(_OWORD *)a3 = v7;
  *(void *)(a3 + 16) = v4;
  *(unsigned char *)(a3 + 24) = v5;
  return result;
}

uint64_t NWEndpoint.Host.init(_:)@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F61DE8);
  MEMORY[0x1F4188790](v6 - 8);
  uint64_t v8 = (char *)v34 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_1834CCB60(a1, a2, 0, (uint64_t)&v35);
  unsigned __int8 v9 = v38;
  if (v38 == 255)
  {
    uint64_t v35 = a1;
    unint64_t v36 = a2;
    v34[0] = 37;
    v34[1] = 0xE100000000000000;
    uint64_t v13 = sub_183D4460C();
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v13 - 8) + 56))(v8, 1, 1, v13);
    sub_1834D7EAC();
    sub_183D453CC();
    unint64_t v15 = v14;
    char v17 = v16;
    sub_183138A24((uint64_t)v8, &qword_1E8F61DE8);
    swift_bridgeObjectRelease();
    if (v17) {
      goto LABEL_6;
    }
    swift_bridgeObjectRetain();
    unint64_t v18 = sub_1834CCEC8(v15, a1, a2);
    uint64_t v20 = v19;
    uint64_t v22 = v21;
    uint64_t v24 = v23;
    swift_bridgeObjectRelease();
    MEMORY[0x185313F90](v18, v20, v22, v24);
    swift_bridgeObjectRelease();
    uint64_t v25 = sub_183D44BAC();
    swift_bridgeObjectRelease();
    uint64_t v10 = (uint64_t)nw_interface_create_with_name((char *)(v25 + 32));
    swift_release();
    if (!v10)
    {
LABEL_6:
      uint64_t result = sub_183D44C5C();
      if (result < 1)
      {
        uint64_t result = swift_bridgeObjectRelease();
        unsigned __int8 v9 = 0;
        unint64_t v11 = 0xE100000000000000;
        uint64_t v10 = 1;
        a1 = 46;
      }
      else
      {
        unsigned __int8 v9 = 0;
        uint64_t v10 = 1;
        unint64_t v11 = a2;
      }
    }
    else
    {
      uint64_t v26 = sub_183D44D4C();
      uint64_t v28 = v27;
      uint64_t v30 = v29;
      uint64_t v32 = v31;
      swift_bridgeObjectRelease();
      a1 = MEMORY[0x185313F90](v26, v28, v30, v32);
      unint64_t v11 = v33;
      uint64_t result = swift_bridgeObjectRelease();
      unsigned __int8 v9 = 0;
    }
  }
  else
  {
    unint64_t v11 = v36;
    uint64_t v10 = v37;
    a1 = v35;
    uint64_t result = swift_bridgeObjectRelease();
  }
  *(void *)a3 = a1;
  *(void *)(a3 + 8) = v11;
  *(void *)(a3 + 16) = v10;
  *(unsigned char *)(a3 + 24) = v9;
  return result;
}

uint64_t NWEndpoint.Host.interface.getter@<X0>(uint64_t *a1@<X8>)
{
  uint64_t v2 = 16;
  if (*(unsigned char *)(v1 + 24) == 1) {
    uint64_t v2 = 8;
  }
  uint64_t v3 = *(void *)(v1 + v2);
  *a1 = v3;
  return sub_18315E9D4(v3);
}

uint64_t NWEndpoint.Host.debugDescription.getter()
{
  uint64_t v1 = *v0;
  uint64_t v2 = v0[2];
  if (*((unsigned char *)v0 + 24))
  {
    if (*((unsigned char *)v0 + 24) == 1) {
      return IPv4Address.debugDescription.getter();
    }
    else {
      return IPv6Address.debugDescription.getter();
    }
  }
  else if (v2 == 1)
  {
    swift_bridgeObjectRetain();
  }
  else
  {
    sub_18315E9D4(v2);
    swift_bridgeObjectRetain();
    sub_183D44C8C();
    swift_bridgeObjectRelease();
    sub_183D44C8C();
    sub_183D4566C();
    sub_18315E51C(v2);
    return 0;
  }
  return v1;
}

void NWEndpoint.Host.hash(into:)()
{
  uint64_t v1 = *(void *)v0;
  uint64_t v2 = *(NSObject **)(v0 + 8);
  uint64_t v3 = *(NSObject **)(v0 + 16);
  if (*(unsigned char *)(v0 + 24))
  {
    if (*(unsigned char *)(v0 + 24) == 1)
    {
      sub_183D45B0C();
      sub_183D45B3C();
      if (v2 == 1)
      {
        sub_183D45B1C();
        uint64_t v4 = v1;
        uint64_t v5 = 1;
      }
      else
      {
        sub_183D45B1C();
        if (v2)
        {
          sub_18315E9D4((uint64_t)v2);
          nw_interface_get_index(v2);
          sub_183D45B0C();
          uint64_t v6 = swift_unknownObjectRetain();
          nw_interface_get_name(v6);
          sub_183D44C9C();
          uint64_t v7 = (uint64_t)v2;
        }
        else
        {
          sub_183D45B0C();
          uint64_t v7 = 0;
        }
        sub_18315E658(v1, v7, (uint64_t)v3, 1);
        sub_183D44C4C();
        swift_bridgeObjectRelease();
        uint64_t v4 = v1;
        uint64_t v5 = (uint64_t)v2;
      }
      sub_18315E658(v4, v5, (uint64_t)v3, 1);
    }
    else
    {
      sub_183D45B0C();
      IPv6Address.hash(into:)();
    }
  }
  else
  {
    sub_183D45B0C();
    sub_18315E9D4((uint64_t)v3);
    sub_183D44C4C();
    if (v3 == 1)
    {
      sub_183D45B1C();
    }
    else
    {
      sub_183D45B1C();
      if (v3)
      {
        nw_interface_get_index(v3);
        sub_183D45B0C();
        uint64_t v8 = swift_unknownObjectRetain();
        nw_interface_get_name(v8);
        sub_183D44C9C();
        uint64_t v9 = (uint64_t)v3;
      }
      else
      {
        sub_183D45B0C();
        uint64_t v9 = 0;
      }
      sub_18315E51C(v9);
      sub_183D44C4C();
      swift_bridgeObjectRelease();
      sub_18315E51C((uint64_t)v3);
    }
  }
}

uint64_t NWEndpoint.Host.hashValue.getter()
{
  return sub_183D45B4C();
}

uint64_t sub_1834CFF50()
{
  return sub_183D45B4C();
}

uint64_t sub_1834CFFB0()
{
  return sub_183D45B4C();
}

double sub_1834D0014@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  NWEndpoint.Host.init(_:)(*(void *)a1, *(void *)(a1 + 8), (uint64_t)&v6);
  uint64_t v3 = v7;
  char v4 = v8;
  double result = *(double *)&v6;
  *(_OWORD *)a2 = v6;
  *(void *)(a2 + 16) = v3;
  *(unsigned char *)(a2 + 24) = v4;
  return result;
}

uint64_t NWEndpoint.Port.init(integerLiteral:)@<X0>(uint64_t result@<X0>, _WORD *a2@<X8>)
{
  *a2 = result;
  return result;
}

void static NWEndpoint.Port.any.getter(_WORD *a1@<X8>)
{
  *a1 = 0;
}

void static NWEndpoint.Port.ssh.getter(_WORD *a1@<X8>)
{
  *a1 = 22;
}

void static NWEndpoint.Port.smtp.getter(_WORD *a1@<X8>)
{
  *a1 = 25;
}

void static NWEndpoint.Port.http.getter(_WORD *a1@<X8>)
{
  *a1 = 80;
}

void static NWEndpoint.Port.pop.getter(_WORD *a1@<X8>)
{
  *a1 = 110;
}

void static NWEndpoint.Port.imap.getter(_WORD *a1@<X8>)
{
  *a1 = 143;
}

void static NWEndpoint.Port.https.getter(_WORD *a1@<X8>)
{
  *a1 = 443;
}

void static NWEndpoint.Port.imaps.getter(_WORD *a1@<X8>)
{
  *a1 = 993;
}

void static NWEndpoint.Port.socks.getter(_WORD *a1@<X8>)
{
  *a1 = 1080;
}

uint64_t NWEndpoint.Port.rawValue.getter()
{
  return *v0;
}

void NWEndpoint.Port.init(_:)(uint64_t a1@<X8>)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)&v8.ai_flags = xmmword_183D54860;
  v8.ai_addrlen = 0;
  memset(&v8.ai_canonname, 0, 24);
  uint64_t v7 = 0;
  uint64_t v2 = sub_183D44BAC();
  swift_bridgeObjectRelease();
  int v3 = getaddrinfo(0, (const char *)(v2 + 32), &v8, &v7);
  swift_release();
  if (v3 || !v7) {
    goto LABEL_7;
  }
  ai_addr = v7->ai_addr;
  if (!ai_addr || ai_addr->sa_family != 30)
  {
    freeaddrinfo(v7);
LABEL_7:
    LOWORD(v5) = 0;
    char v6 = 1;
    goto LABEL_8;
  }
  unsigned int v5 = bswap32(*(unsigned __int16 *)ai_addr->sa_data) >> 16;
  freeaddrinfo(v7);
  char v6 = 0;
LABEL_8:
  *(_WORD *)a1 = v5;
  *(unsigned char *)(a1 + 2) = v6;
}

uint64_t NWEndpoint.Port.debugDescription.getter()
{
  return sub_183D4589C();
}

uint64_t sub_1834D0218()
{
  return sub_183D45B4C();
}

uint64_t sub_1834D0260()
{
  return sub_183D45B2C();
}

uint64_t sub_1834D028C()
{
  return sub_183D45B4C();
}

_WORD *sub_1834D02D0@<X0>(_WORD *result@<X0>, _WORD *a2@<X8>)
{
  *a2 = *result;
  return result;
}

_WORD *sub_1834D02DC@<X0>(_WORD *result@<X0>, uint64_t a2@<X8>)
{
  *(_WORD *)a2 = *result;
  *(unsigned char *)(a2 + 2) = 0;
  return result;
}

void sub_1834D02EC(_WORD *a1@<X8>)
{
  *a1 = *v1;
}

BOOL sub_1834D02F8(unsigned __int16 *a1, unsigned __int16 *a2)
{
  return *a1 == *a2;
}

void NWEndpoint.interface.getter(uint64_t *a1@<X8>)
{
  uint64_t v2 = v1;
  uint64_t v4 = type metadata accessor for NWEndpoint();
  MEMORY[0x1F4188790](v4);
  char v6 = (char *)&v12 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_1834D7F00(v2, (uint64_t)v6);
  switch(swift_getEnumCaseMultiPayload())
  {
    case 1u:
      uint64_t v9 = *((void *)v6 + 6);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      *a1 = v9;
      break;
    case 2u:
      swift_bridgeObjectRelease();
      goto LABEL_10;
    case 3u:
      *a1 = 1;
      sub_1834D7F64((uint64_t)v6);
      break;
    case 4u:
      id v10 = nw_endpoint_copy_interface(*(void **)v6);
      swift_unknownObjectRelease();
      if (v10) {
        *a1 = (uint64_t)v10;
      }
      else {
LABEL_10:
      }
        *a1 = 1;
      break;
    default:
      uint64_t v7 = *((void *)v6 + 1);
      uint64_t v8 = *((void *)v6 + 2);
      if (v6[24])
      {
        if (v6[24] == 1) {
          *a1 = v7;
        }
        else {
          *a1 = v8;
        }
      }
      else
      {
        uint64_t v11 = *(void *)v6;
        *a1 = v8;
        sub_18315E9D4(v8);
        sub_18315E658(v11, v7, v8, 0);
      }
      break;
  }
}

void NWEndpoint.txtRecord.getter(void *a1@<X8>)
{
  uint64_t v2 = v1;
  uint64_t v4 = type metadata accessor for NWEndpoint();
  MEMORY[0x1F4188790](v4);
  char v6 = (char *)aBlock - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_1834D7F00(v2, (uint64_t)v6);
  switch(swift_getEnumCaseMultiPayload())
  {
    case 1u:
      uint64_t v7 = *((void *)v6 + 6);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      sub_18315E51C(v7);
      goto LABEL_9;
    case 2u:
      swift_bridgeObjectRelease();
      goto LABEL_9;
    case 3u:
      *a1 = 0;
      a1[1] = 0;
      sub_1834D7F64((uint64_t)v6);
      return;
    case 4u:
      nw_txt_record_t v8 = nw_endpoint_copy_txt_record(*(nw_endpoint_t *)v6);
      if (v8)
      {
        uint64_t v9 = v8;
        uint64_t v10 = swift_allocObject();
        *(void *)(v10 + 16) = MEMORY[0x1E4FBC868];
        uint64_t v11 = (uint64_t *)(v10 + 16);
        void aBlock[4] = sub_1834CCA38;
        aBlock[5] = v10;
        aBlock[0] = MEMORY[0x1E4F143A8];
        aBlock[1] = 1107296256;
        aBlock[2] = sub_183597F24;
        aBlock[3] = &block_descriptor_1;
        uint64_t v12 = _Block_copy(aBlock);
        swift_retain();
        swift_release();
        nw_txt_record_apply(v9, v12);
        _Block_release(v12);
        swift_beginAccess();
        uint64_t v13 = *v11;
        swift_bridgeObjectRetain();
        swift_unknownObjectRelease();
        swift_release();
        *a1 = v13;
        a1[1] = v9;
      }
      else
      {
        swift_unknownObjectRelease();
LABEL_9:
        *a1 = 0;
        a1[1] = 0;
      }
      return;
    default:
      sub_18315E658(*(void *)v6, *((void *)v6 + 1), *((void *)v6 + 2), v6[24]);
      goto LABEL_9;
  }
}

BOOL static NWEndpoint.EndpointType.== infix(_:_:)(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 == *a2;
}

uint64_t NWEndpoint.EndpointType.hash(into:)()
{
  return sub_183D45B0C();
}

uint64_t NWEndpoint.EndpointType.hashValue.getter()
{
  return sub_183D45B4C();
}

Swift::String_optional __swiftcall NWEndpoint.parentEndpointDomain()()
{
  uint64_t v0 = sub_1834D3B3C((uint64_t (*)(void))nw_endpoint_get_parent_endpoint_domain);
  result.value._object = v1;
  result.value._countAndFlagsBits = v0;
  return result;
}

uint64_t NWEndpoint.parentEndpoint()@<X0>(uint64_t a1@<X8>)
{
  return sub_1834D1028((uint64_t (*)(void))nw_endpoint_copy_parent_endpoint, a1);
}

uint64_t NWEndpoint.init(_:)@<X0>(NSObject *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName(qword_1EB266A50);
  MEMORY[0x1F4188790](v4 - 8);
  char v6 = (char *)&v11 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_18315A830(a1, (uint64_t)v6);
  uint64_t v7 = type metadata accessor for NWEndpoint();
  uint64_t v8 = *(void *)(v7 - 8);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v8 + 48))(v6, 1, v7))
  {
    sub_183138A24((uint64_t)v6, qword_1EB266A50);
    uint64_t v9 = 1;
  }
  else
  {
    sub_18315E28C((uint64_t)v6, a2);
    uint64_t v9 = 0;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v8 + 56))(a2, v9, 1, v7);
}

nw_endpoint_t NWEndpoint.setParentEndpoint(endpoint:isProxy:)(uint64_t a1, char a2)
{
  nw_endpoint_t result = NWEndpoint.nw.getter();
  if (result)
  {
    nw_endpoint_t v5 = result;
    sub_1834D7F64((uint64_t)v2);
    nw_endpoint_t v6 = NWEndpoint.nw.getter();
    nw_endpoint_set_parent_endpoint(v5, v6, a2 & 1);
    swift_unknownObjectRelease();
    nw_endpoint_t *v2 = v5;
    type metadata accessor for NWEndpoint();
    return (nw_endpoint_t)swift_storeEnumTagMultiPayload();
  }
  return result;
}

nw_endpoint_t NWEndpoint.nw.getter()
{
  uint64_t v1 = v0;
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = sub_183D4447C();
  uint64_t v3 = *(void *)(v2 - 8);
  MEMORY[0x1F4188790](v2);
  nw_endpoint_t v5 = &v27[-((v4 + 15) & 0xFFFFFFFFFFFFFFF0)];
  uint64_t v6 = type metadata accessor for NWEndpoint();
  MEMORY[0x1F4188790](v6);
  uint64_t v8 = &v27[-((v7 + 15) & 0xFFFFFFFFFFFFFFF0)];
  sub_1834D7F00(v1, (uint64_t)v8);
  switch(swift_getEnumCaseMultiPayload())
  {
    case 1u:
      uint64_t v9 = (void *)*((void *)v8 + 6);
      uint64_t v17 = sub_183D44BAC();
      swift_bridgeObjectRelease();
      uint64_t v18 = sub_183D44BAC();
      swift_bridgeObjectRelease();
      uint64_t v19 = sub_183D44BAC();
      swift_bridgeObjectRelease();
      nw_endpoint_t bonjour_service = nw_endpoint_create_bonjour_service((const char *)(v17 + 32), (const char *)(v18 + 32), (const char *)(v19 + 32));
      swift_release();
      swift_release();
      swift_release();
      if (v9 != (void *)1) {
        goto LABEL_22;
      }
      return bonjour_service;
    case 2u:
      uint64_t v15 = sub_183D44BAC();
      swift_bridgeObjectRelease();
      nw_endpoint_t bonjour_service = nw_endpoint_create_unix((const char *)(v15 + 32));
      swift_release();
      return bonjour_service;
    case 3u:
      (*(void (**)(unsigned char *, unsigned char *, uint64_t))(v3 + 32))(v5, v8, v2);
      CFURLRef v16 = (const __CFURL *)sub_183D4441C();
      nw_endpoint_t bonjour_service = (nw_endpoint_t)nw_endpoint_create_with_cfurl(v16);

      (*(void (**)(unsigned char *, uint64_t))(v3 + 8))(v5, v2);
      return bonjour_service;
    case 4u:
      return *(nw_endpoint_t *)v8;
    default:
      uint64_t v10 = *(void *)v8;
      uint64_t v9 = (void *)*((void *)v8 + 1);
      uint64_t v11 = *((void *)v8 + 2);
      int v12 = v8[24];
      unsigned int v13 = *((unsigned __int16 *)v8 + 13);
      if (!v12)
      {
        *(_WORD *)&address.size_t sa_len = v13;
        sub_18315E9D4((uint64_t)v11);
        sub_183D4589C();
        uint64_t v20 = (const char *)(sub_183D44BAC() + 32);
        uint64_t v21 = sub_183D44BAC();
        swift_bridgeObjectRelease();
        nw_endpoint_t bonjour_service = nw_endpoint_create_host(v20, (const char *)(v21 + 32));
        sub_18315E658(v10, (uint64_t)v9, (uint64_t)v11, 0);
        swift_release();
        swift_release();
        uint64_t v9 = v11;
        if (v11 == 1) {
          return bonjour_service;
        }
        goto LABEL_22;
      }
      if (v12 == 1)
      {
        *(_WORD *)&address.size_t sa_len = 528;
        *(_WORD *)address.sa_data = __rev16(v13);
        *(_DWORD *)&address.sa_data[2] = v10;
        *(void *)&address.sa_data[6] = 0;
        nw_endpoint_t bonjour_service = nw_endpoint_create_address(&address);
        if (v9 == (void *)1) {
          return bonjour_service;
        }
        goto LABEL_22;
      }
      if (v10 != 254 || ((v10 & 0xC000) == 0x8000 ? (BOOL v22 = v11 == 1) : (BOOL v22 = 1), v22))
      {
        sub_18315E9D4((uint64_t)v11);
        sub_18315E9D4((uint64_t)v11);
        uint32_t index = 0;
        uint64_t v24 = (uint64_t)v11;
      }
      else
      {
        if (!v11)
        {
          sub_183D456BC();
          __break(1u);
          JUMPOUT(0x1834D0E10);
        }
        sub_18315E9D4((uint64_t)v11);
        uint32_t index = nw_interface_get_index(v11);
        uint64_t v24 = 1;
      }
      *(_WORD *)&address.size_t sa_len = 7708;
      *(_WORD *)address.sa_data = __rev16(v13);
      *(_DWORD *)&address.sa_data[2] = 0;
      *(void *)&address.sa_data[6] = v10;
      uint64_t v29 = v9;
      uint32_t v30 = index;
      nw_endpoint_t bonjour_service = nw_endpoint_create_address(&address);
      sub_18315E658(v10, (uint64_t)v9, (uint64_t)v11, 2);
      sub_18315E658(v10, (uint64_t)v9, (uint64_t)v11, 2);
      uint64_t v9 = (void *)v24;
      if (v24 != 1)
      {
LABEL_22:
        if (bonjour_service)
        {
          uint64_t v25 = (void *)swift_unknownObjectRetain();
          nw_endpoint_set_interface(v25, v9);
          swift_unknownObjectRelease();
          swift_unknownObjectRelease();
        }
        else
        {
          sub_18315E51C((uint64_t)v9);
        }
      }
      return bonjour_service;
  }
}

uint64_t NWEndpoint.originalEndpoint(_:)@<X0>(char *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = v2;
  uint64_t v6 = __swift_instantiateConcreteTypeFromMangledName(qword_1EB266A50);
  MEMORY[0x1F4188790](v6 - 8);
  uint64_t v8 = (char *)&v17 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v9 = type metadata accessor for NWEndpoint();
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1F4188790](v9);
  int v12 = (void **)((char *)&v17 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v13 = *a1;
  sub_1834D7F00(v3, (uint64_t)v12);
  if (swift_getEnumCaseMultiPayload() == 4)
  {
    BOOL v14 = nw_endpoint_copy_original_endpoint(*v12, dword_183D54F6C[v13]);
    sub_18315A830(v14, (uint64_t)v8);
    uint64_t v15 = (void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v10 + 56);
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v10 + 48))(v8, 1, v9))
    {
      sub_183138A24((uint64_t)v8, qword_1EB266A50);
      (*v15)(a2, 1, 1, v9);
    }
    else
    {
      sub_18315E28C((uint64_t)v8, a2);
      (*v15)(a2, 0, 1, v9);
    }
    return swift_unknownObjectRelease();
  }
  else
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v10 + 56))(a2, 1, 1, v9);
    return sub_1834D7F64((uint64_t)v12);
  }
}

uint64_t NWEndpoint.proxyOriginalEndpoint()@<X0>(uint64_t a1@<X8>)
{
  return sub_1834D1028((uint64_t (*)(void))nw_endpoint_copy_proxy_original_endpoint, a1);
}

uint64_t sub_1834D1028@<X0>(uint64_t (*a1)(void)@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2;
  uint64_t v6 = __swift_instantiateConcreteTypeFromMangledName(qword_1EB266A50);
  MEMORY[0x1F4188790](v6 - 8);
  uint64_t v8 = (char *)&v16 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v9 = type metadata accessor for NWEndpoint();
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1F4188790](v9);
  int v12 = (uint64_t *)((char *)&v16 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0));
  sub_1834D7F00(v4, (uint64_t)v12);
  if (swift_getEnumCaseMultiPayload() == 4)
  {
    if (a1(*v12))
    {
      uint64_t v13 = swift_unknownObjectRetain();
      sub_18315A830(v13, (uint64_t)v8);
      BOOL v14 = (void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v10 + 56);
      if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v10 + 48))(v8, 1, v9))
      {
        sub_183138A24((uint64_t)v8, qword_1EB266A50);
        (*v14)(a2, 1, 1, v9);
      }
      else
      {
        sub_18315E28C((uint64_t)v8, a2);
        (*v14)(a2, 0, 1, v9);
      }
      swift_unknownObjectRelease();
    }
    else
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v10 + 56))(a2, 1, 1, v9);
    }
    return swift_unknownObjectRelease();
  }
  else
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v10 + 56))(a2, 1, 1, v9);
    return sub_1834D7F64((uint64_t)v12);
  }
}

nw_endpoint_t NWEndpoint.setCustomMetadataForKey(key:metadata:)(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  v19[3] = *MEMORY[0x1E4F143B8];
  nw_endpoint_t result = NWEndpoint.nw.getter();
  if (result)
  {
    nw_endpoint_t v10 = result;
    if (a4 >> 60 == 15)
    {
      sub_1834D7F64((uint64_t)v4);
      uint64_t v11 = sub_183D44BAC();
      nw_endpoint_set_custom_metadata_for_key(v10, (const char *)(v11 + 32), 0, 0);
      swift_release();
    }
    else
    {
      switch(a4 >> 62)
      {
        case 1uLL:
          if (a3 >> 32 < (int)a3) {
            __break(1u);
          }
          sub_1834D7FF8(a3, a4);
          swift_bridgeObjectRetain();
          sub_1834D7FF8(a3, a4);
          swift_unknownObjectRetain();
          swift_bridgeObjectRetain();
          sub_1834D7FF8(a3, a4);
          swift_unknownObjectRetain();
          sub_1834D7FF8(a3, a4);
          sub_1834D6E0C((int)a3, a3 >> 32, a4 & 0x3FFFFFFFFFFFFFFFLL, v10, a1, a2, a3, a4);
          sub_1832E669C(a3, a4);
          goto LABEL_12;
        case 2uLL:
          uint64_t v16 = *(void *)(a3 + 16);
          uint64_t v17 = *(void *)(a3 + 24);
          sub_1834D7FF8(a3, a4);
          swift_bridgeObjectRetain();
          sub_1834D7FF8(a3, a4);
          swift_unknownObjectRetain();
          swift_bridgeObjectRetain();
          sub_1834D7FF8(a3, a4);
          swift_unknownObjectRetain();
          sub_1834D7FF8(a3, a4);
          swift_retain();
          swift_retain();
          sub_1834D6E0C(v16, v17, a4 & 0x3FFFFFFFFFFFFFFFLL, v10, a1, a2, a3, a4);
          swift_release();
          goto LABEL_9;
        case 3uLL:
          memset(v19, 0, 14);
          uint64_t v18 = sub_183D44BAC() + 32;
          swift_unknownObjectRetain_n();
          swift_bridgeObjectRetain_n();
          nw_endpoint_t v13 = v10;
          BOOL v14 = (const char *)v18;
          size_t v15 = 0;
          goto LABEL_8;
        default:
          v19[0] = a3;
          LOWORD(v19[1]) = a4;
          BYTE2(v19[1]) = BYTE2(a4);
          BYTE3(v19[1]) = BYTE3(a4);
          BYTE4(v19[1]) = BYTE4(a4);
          BYTE5(v19[1]) = BYTE5(a4);
          uint64_t v12 = sub_183D44BAC() + 32;
          swift_unknownObjectRetain_n();
          swift_bridgeObjectRetain_n();
          nw_endpoint_t v13 = v10;
          BOOL v14 = (const char *)v12;
          size_t v15 = BYTE6(a4);
LABEL_8:
          nw_endpoint_set_custom_metadata_for_key(v13, v14, (const uint8_t *)v19, v15);
          swift_bridgeObjectRelease();
          swift_unknownObjectRelease();
LABEL_9:
          swift_release();
          sub_1832E669C(a3, a4);
LABEL_12:
          swift_bridgeObjectRelease();
          swift_unknownObjectRelease();
          sub_1832E669C(a3, a4);
          sub_1834D7F64((uint64_t)v4);
          sub_1832E669C(a3, a4);
          break;
      }
    }
    *uint64_t v4 = v10;
    type metadata accessor for NWEndpoint();
    return (nw_endpoint_t)swift_storeEnumTagMultiPayload();
  }
  return result;
}

uint64_t sub_1834D1650(const uint8_t *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7)
{
  if (!a1) {
    goto LABEL_10;
  }
  size_t v9 = 0;
  switch(a7 >> 62)
  {
    case 1uLL:
      if (__OFSUB__(HIDWORD(a6), a6))
      {
        __break(1u);
LABEL_9:
        __break(1u);
LABEL_10:
        __break(1u);
        JUMPOUT(0x1834D1718);
      }
      size_t v9 = HIDWORD(a6) - (int)a6;
LABEL_7:
      uint64_t v12 = sub_183D44BAC();
      nw_endpoint_set_custom_metadata_for_key(a3, (const char *)(v12 + 32), a1, v9);
      return swift_release();
    case 2uLL:
      uint64_t v11 = *(void *)(a6 + 16);
      uint64_t v10 = *(void *)(a6 + 24);
      size_t v9 = v10 - v11;
      if (!__OFSUB__(v10, v11)) {
        goto LABEL_7;
      }
      goto LABEL_9;
    case 3uLL:
      goto LABEL_7;
    default:
      size_t v9 = BYTE6(a7);
      goto LABEL_7;
  }
}

uint64_t NWEndpoint.customMetadataForKey(key:)()
{
  uint64_t v1 = type metadata accessor for NWEndpoint();
  MEMORY[0x1F4188790](v1);
  uint64_t v3 = (void **)((char *)aBlock - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0));
  sub_1834D7F00(v0, (uint64_t)v3);
  if (swift_getEnumCaseMultiPayload() == 4)
  {
    uint64_t v4 = *v3;
    uint64_t v5 = swift_allocObject();
    *(_OWORD *)(v5 + 16) = xmmword_183D54870;
    void aBlock[4] = sub_1834D8054;
    aBlock[5] = v5;
    aBlock[0] = MEMORY[0x1E4F143A8];
    aBlock[1] = 1107296256;
    aBlock[2] = sub_1834D1970;
    aBlock[3] = &block_descriptor_6_0;
    uint64_t v6 = _Block_copy(aBlock);
    swift_retain();
    swift_release();
    uint64_t v7 = sub_183D44BAC();
    nw_endpoint_access_custom_metadata_for_key(v4, (const char *)(v7 + 32), v6);
    swift_release();
    swift_unknownObjectRelease();
    _Block_release(v6);
    swift_beginAccess();
    uint64_t v8 = *(void *)(v5 + 16);
    sub_1834D7FF8(v8, *(void *)(v5 + 24));
    swift_release();
  }
  else
  {
    sub_1834D7F64((uint64_t)v3);
    return 0;
  }
  return v8;
}

uint64_t sub_1834D1904(unsigned char *a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v4 = sub_1835572E0(a1, a2);
    uint64_t v6 = v5;
    swift_beginAccess();
    uint64_t v7 = *(void *)(a3 + 16);
    unint64_t v8 = *(void *)(a3 + 24);
    *(void *)(a3 + 16) = v4;
    *(void *)(a3 + 24) = v6;
    sub_1832E669C(v7, v8);
  }
  return 1;
}

uint64_t sub_1834D1970(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t))(a1 + 32);
  swift_retain();
  LOBYTE(a3) = v5(a2, a3);
  swift_release();
  return a3 & 1;
}

void *NWEndpoint.setSignature(_:)(uint64_t a1, unint64_t a2)
{
  void v10[2] = *MEMORY[0x1E4F143B8];
  nw_endpoint_t result = NWEndpoint.nw.getter();
  if (result)
  {
    v10[0] = a1;
    v10[1] = a2;
    uint64_t v6 = result;
    size_t v7 = 0;
    switch(a2 >> 62)
    {
      case 1uLL:
        if (__OFSUB__(HIDWORD(a1), a1))
        {
          __break(1u);
LABEL_10:
          __break(1u);
        }
        size_t v7 = HIDWORD(a1) - (int)a1;
LABEL_7:
        nw_endpoint_set_signature(result, v10, v7);
        sub_1834D7F64((uint64_t)v2);
        void *v2 = v6;
        type metadata accessor for NWEndpoint();
        nw_endpoint_t result = (void *)swift_storeEnumTagMultiPayload();
        break;
      case 2uLL:
        uint64_t v9 = *(void *)(a1 + 16);
        uint64_t v8 = *(void *)(a1 + 24);
        size_t v7 = v8 - v9;
        if (!__OFSUB__(v8, v9)) {
          goto LABEL_7;
        }
        goto LABEL_10;
      case 3uLL:
        goto LABEL_7;
      default:
        size_t v7 = BYTE6(a2);
        goto LABEL_7;
    }
  }
  return result;
}

Swift::Bool __swiftcall NWEndpoint.hasSignature()()
{
  uint64_t v1 = type metadata accessor for NWEndpoint();
  MEMORY[0x1F4188790](v1);
  uint64_t v3 = (void **)((char *)&v6 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0));
  sub_1834D7F00(v0, (uint64_t)v3);
  if (swift_getEnumCaseMultiPayload() == 4)
  {
    Swift::Bool has_signature = nw_endpoint_has_signature(*v3);
    swift_unknownObjectRelease();
  }
  else
  {
    sub_1834D7F64((uint64_t)v3);
    return 0;
  }
  return has_signature;
}

uint64_t NWEndpoint.echConfig.getter@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_1E8F62DC0);
  MEMORY[0x1F4188790](v4 - 8);
  uint64_t v6 = (char *)&v16 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = type metadata accessor for NWEndpoint();
  MEMORY[0x1F4188790](v7);
  uint64_t v9 = (void **)((char *)&v16 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0));
  sub_1834D7F00(v2, (uint64_t)v9);
  if (swift_getEnumCaseMultiPayload() == 4)
  {
    uint64_t v10 = nw_endpoint_copy_ech_config(*v9);
    if (v10)
    {
      uint64_t v11 = (void *)v10;
      sub_183D44A0C();
      swift_unknownObjectRelease();

      uint64_t v12 = sub_183D44A1C();
      (*(void (**)(char *, void, uint64_t, uint64_t))(*(void *)(v12 - 8) + 56))(v6, 0, 1, v12);
    }
    else
    {
      swift_unknownObjectRelease();
      uint64_t v15 = sub_183D44A1C();
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v15 - 8) + 56))(v6, 1, 1, v15);
    }
    return sub_183138964((uint64_t)v6, a1, (uint64_t *)&unk_1E8F62DC0);
  }
  else
  {
    uint64_t v13 = sub_183D44A1C();
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v13 - 8) + 56))(a1, 1, 1, v13);
    return sub_1834D7F64((uint64_t)v9);
  }
}

uint64_t NWEndpoint.echConfig.setter(uint64_t a1)
{
  uint64_t v2 = (void *)v1;
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_1E8F62DC0);
  MEMORY[0x1F4188790](v4 - 8);
  uint64_t v6 = (char *)&v15 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = sub_183D44A1C();
  uint64_t v8 = *(void *)(v7 - 8);
  MEMORY[0x1F4188790](v7);
  uint64_t v10 = (char *)&v15 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  nw_endpoint_t v11 = NWEndpoint.nw.getter();
  if (!v11) {
    return sub_183138A24(a1, (uint64_t *)&unk_1E8F62DC0);
  }
  nw_endpoint_t v12 = v11;
  sub_1834D7F64(v1);
  sub_183138900(a1, (uint64_t)v6, (uint64_t *)&unk_1E8F62DC0);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v8 + 48))(v6, 1, v7) == 1)
  {
    sub_183138A24((uint64_t)v6, (uint64_t *)&unk_1E8F62DC0);
    nw_endpoint_set_ech_config(v12, 0);
    sub_183138A24(a1, (uint64_t *)&unk_1E8F62DC0);
  }
  else
  {
    (*(void (**)(char *, char *, uint64_t))(v8 + 32))(v10, v6, v7);
    BOOL v14 = (void *)sub_183D449FC();
    nw_endpoint_set_ech_config(v12, v14);

    sub_183138A24(a1, (uint64_t *)&unk_1E8F62DC0);
    (*(void (**)(char *, uint64_t))(v8 + 8))(v10, v7);
  }
  void *v2 = v12;
  type metadata accessor for NWEndpoint();
  return swift_storeEnumTagMultiPayload();
}

void (*NWEndpoint.echConfig.modify(void *a1))(uint64_t a1, char a2)
{
  *a1 = v1;
  size_t v3 = *(void *)(*(void *)(__swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_1E8F62DC0) - 8) + 64);
  a1[1] = malloc(v3);
  uint64_t v4 = malloc(v3);
  a1[2] = v4;
  NWEndpoint.echConfig.getter((uint64_t)v4);
  return sub_1834D2024;
}

void sub_1834D2024(uint64_t a1, char a2)
{
}

uint64_t NWEndpoint.alternatives.getter()
{
  uint64_t v1 = type metadata accessor for NWEndpoint();
  MEMORY[0x1F4188790](v1);
  size_t v3 = (void **)((char *)&aBlock[-1] - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0));
  sub_1834D7F00(v0, (uint64_t)v3);
  if (swift_getEnumCaseMultiPayload() != 4)
  {
    sub_1834D7F64((uint64_t)v3);
    return 0;
  }
  uint64_t v4 = *v3;
  uint64_t v13 = MEMORY[0x1E4FBC860];
  uint64_t v5 = swift_allocObject();
  *(void *)(v5 + 16) = &v13;
  uint64_t v6 = swift_allocObject();
  *(void *)(v6 + 16) = sub_1834D806C;
  *(void *)(v6 + 24) = v5;
  void aBlock[4] = sub_1834D8084;
  aBlock[5] = v6;
  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 1107296256;
  aBlock[2] = sub_1834D276C;
  aBlock[3] = &block_descriptor_15;
  uint64_t v7 = _Block_copy(aBlock);
  swift_retain();
  swift_release();
  nw_endpoint_enumerate_alternatives(v4, v7);
  swift_unknownObjectRelease();
  _Block_release(v7);
  LOBYTE(v4) = swift_isEscapingClosureAtFileLocation();
  uint64_t result = swift_release();
  if ((v4 & 1) == 0)
  {
    uint64_t v9 = v13;
    uint64_t v10 = *(void *)(v13 + 16);
    swift_release();
    if (v10) {
      return v9;
    }
    swift_bridgeObjectRelease();
    return 0;
  }
  __break(1u);
  return result;
}

uint64_t NWEndpoint.alternatives.setter(uint64_t a1)
{
  uint64_t v3 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F62B18);
  uint64_t v4 = *(void *)(v3 - 8);
  uint64_t v5 = MEMORY[0x1F4188790](v3);
  uint64_t v36 = (uint64_t)&v31 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = MEMORY[0x1F4188790](v5);
  uint64_t v9 = (char *)&v31 - v8;
  uint64_t v10 = MEMORY[0x1F4188790](v7);
  nw_endpoint_t v12 = (char *)&v31 - v11;
  MEMORY[0x1F4188790](v10);
  BOOL v14 = (char *)&v31 - v13;
  nw_endpoint_t v15 = NWEndpoint.nw.getter();
  if (v15)
  {
    nw_endpoint_t v16 = v15;
    sub_1834D7F64((uint64_t)v1);
    nw_endpoint_clear_alternatives(v16);
    if (a1)
    {
      uint64_t v17 = *(void *)(a1 + 16);
      if (v17)
      {
        uint64_t v32 = v1;
        nw_endpoint_t v33 = v16;
        uint64_t v18 = *(int *)(v3 + 48);
        uint64_t v19 = *(unsigned __int8 *)(v4 + 80);
        uint64_t v31 = a1;
        uint64_t v20 = a1 + ((v19 + 32) & ~v19);
        uint64_t v34 = *(void *)(v4 + 72);
        uint64_t v35 = v18;
        do
        {
          sub_183138900(v20, (uint64_t)v14, &qword_1E8F62B18);
          uint64_t v21 = *(void *)&v14[v35];
          uint64_t v22 = *(int *)(v3 + 48);
          sub_18315E28C((uint64_t)v14, (uint64_t)v12);
          *(void *)&v12[v22] = v21;
          uint64_t v23 = *(int *)(v3 + 48);
          sub_1834D7F00((uint64_t)v12, (uint64_t)v9);
          *(void *)&v9[v23] = v21;
          swift_retain();
          nw_endpoint_t v24 = NWEndpoint.nw.getter();
          if (v24)
          {
            nw_endpoint_t v25 = v24;
            sub_1834D7F64((uint64_t)v9);
            uint64_t v26 = v3;
            uint64_t v27 = *(int *)(v3 + 48);
            uint64_t v28 = v36;
            sub_1834D7F00((uint64_t)v12, v36);
            *(void *)(v28 + v27) = v21;
            if (v21)
            {
              uint64_t v29 = *(void **)(v21 + 32);
              swift_unknownObjectRetain();
              swift_release();
            }
            else
            {
              uint64_t v29 = 0;
            }
            uint64_t v3 = v26;
            sub_1834D7F64(v36);
            nw_endpoint_add_alternative(v33, v25, v29);
            swift_unknownObjectRelease();
            swift_unknownObjectRelease();
            sub_183138A24((uint64_t)v12, &qword_1E8F62B18);
          }
          else
          {
            sub_183138A24((uint64_t)v12, &qword_1E8F62B18);
            swift_release();
            sub_1834D7F64((uint64_t)v9);
          }
          v20 += v34;
          --v17;
        }
        while (v17);
        swift_bridgeObjectRelease();
        uint64_t v1 = v32;
        nw_endpoint_t v16 = v33;
      }
      else
      {
        swift_bridgeObjectRelease();
      }
    }
    nw_endpoint_t *v1 = v16;
    type metadata accessor for NWEndpoint();
    return swift_storeEnumTagMultiPayload();
  }
  else
  {
    return swift_bridgeObjectRelease();
  }
}

uint64_t sub_1834D252C(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t v6 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F62B18);
  uint64_t v7 = *(void *)(v6 - 8);
  MEMORY[0x1F4188790](v6);
  uint64_t v9 = (char *)&v24 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = type metadata accessor for NWEndpoint();
  MEMORY[0x1F4188790](v10);
  nw_endpoint_t v12 = (uint64_t *)((char *)&v24 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0));
  void *v12 = a1;
  swift_storeEnumTagMultiPayload();
  if (a2)
  {
    type metadata accessor for NWProtocolDefinition();
    uint64_t v13 = (void *)swift_allocObject();
    v13[4] = a2;
    swift_unknownObjectRetain();
    id v14 = objc_msgSend((id)swift_unknownObjectRetain(), sel_description);
    uint64_t v15 = sub_183D44AFC();
    uint64_t v17 = v16;

    v13[2] = v15;
    v13[3] = v17;
  }
  else
  {
    swift_unknownObjectRetain();
    uint64_t v13 = 0;
  }
  uint64_t v18 = *(int *)(v6 + 48);
  sub_18315E28C((uint64_t)v12, (uint64_t)v9);
  *(void *)&v9[v18] = v13;
  unint64_t v19 = *a3;
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  *a3 = v19;
  if ((isUniquelyReferenced_nonNull_native & 1) == 0)
  {
    unint64_t v19 = sub_1834B45A4(0, *(void *)(v19 + 16) + 1, 1, v19);
    *a3 = v19;
  }
  unint64_t v22 = *(void *)(v19 + 16);
  unint64_t v21 = *(void *)(v19 + 24);
  if (v22 >= v21 >> 1)
  {
    unint64_t v19 = sub_1834B45A4(v21 > 1, v22 + 1, 1, v19);
    *a3 = v19;
  }
  *(void *)(v19 + 16) = v22 + 1;
  sub_183138964((uint64_t)v9, v19+ ((*(unsigned __int8 *)(v7 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80))+ *(void *)(v7 + 72) * v22, &qword_1E8F62B18);
  return 1;
}

uint64_t sub_1834D276C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t))(a1 + 32);
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  char v6 = v5(a2, a3);
  swift_unknownObjectRelease();
  swift_unknownObjectRelease();
  return v6 & 1;
}

uint64_t (*NWEndpoint.alternatives.modify(uint64_t *a1))(uint64_t *a1, char a2)
{
  a1[1] = v1;
  *a1 = NWEndpoint.alternatives.getter();
  return sub_1834D281C;
}

uint64_t sub_1834D281C(uint64_t *a1, char a2)
{
  if ((a2 & 1) == 0) {
    return NWEndpoint.alternatives.setter(*a1);
  }
  uint64_t v2 = swift_bridgeObjectRetain();
  NWEndpoint.alternatives.setter(v2);

  return swift_bridgeObjectRelease();
}

uint64_t NWEndpoint.alternatePort.getter()
{
  return sub_1834D3C58((uint64_t (*)(void))nw_endpoint_get_alternate_port);
}

uint64_t sub_1834D288C@<X0>(uint64_t a1@<X0>, _WORD *a2@<X8>)
{
  uint64_t v4 = type metadata accessor for NWEndpoint();
  MEMORY[0x1F4188790](v4);
  char v6 = (void **)((char *)&v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0));
  sub_1834D7F00(a1, (uint64_t)v6);
  if (swift_getEnumCaseMultiPayload() == 4)
  {
    alternate_int port = nw_endpoint_get_alternate_port(*v6);
    uint64_t result = swift_unknownObjectRelease();
  }
  else
  {
    uint64_t result = sub_1834D7F64((uint64_t)v6);
    alternate_int port = 0;
  }
  *a2 = alternate_port;
  return result;
}

nw_endpoint_t sub_1834D2954(__int16 *a1, nw_endpoint_t *a2)
{
  __int16 v3 = *a1;
  nw_endpoint_t result = NWEndpoint.nw.getter();
  if (result)
  {
    nw_endpoint_t v5 = result;
    sub_1834D7F64((uint64_t)a2);
    nw_endpoint_set_alternate_port(v5, v3);
    *a2 = v5;
    type metadata accessor for NWEndpoint();
    return (nw_endpoint_t)swift_storeEnumTagMultiPayload();
  }
  return result;
}

nw_endpoint_t NWEndpoint.alternatePort.setter(__int16 a1)
{
  nw_endpoint_t result = NWEndpoint.nw.getter();
  if (result)
  {
    nw_endpoint_t v4 = result;
    sub_1834D7F64((uint64_t)v1);
    nw_endpoint_set_alternate_port(v4, a1);
    nw_endpoint_t *v1 = v4;
    type metadata accessor for NWEndpoint();
    return (nw_endpoint_t)swift_storeEnumTagMultiPayload();
  }
  return result;
}

void (*NWEndpoint.alternatePort.modify(uint64_t a1))(uint64_t a1)
{
  uint64_t v2 = v1;
  *(void *)a1 = v2;
  uint64_t v4 = type metadata accessor for NWEndpoint();
  *(void *)(a1 + 8) = v4;
  nw_endpoint_t v5 = (void **)malloc(*(void *)(*(void *)(v4 - 8) + 64));
  *(void *)(a1 + 16) = v5;
  sub_1834D7F00(v2, (uint64_t)v5);
  if (swift_getEnumCaseMultiPayload() == 4)
  {
    alternate_int port = nw_endpoint_get_alternate_port(*v5);
    swift_unknownObjectRelease();
  }
  else
  {
    sub_1834D7F64((uint64_t)v5);
    alternate_int port = 0;
  }
  *(_WORD *)(a1 + 24) = alternate_port;
  return sub_1834D2B30;
}

void sub_1834D2B30(uint64_t a1)
{
  __int16 v2 = *(_WORD *)(a1 + 24);
  __int16 v3 = *(nw_endpoint_t **)a1;
  nw_endpoint_t v4 = NWEndpoint.nw.getter();
  if (v4)
  {
    nw_endpoint_t v5 = v4;
    sub_1834D7F64((uint64_t)v3);
    nw_endpoint_set_alternate_port(v5, v2);
    *__int16 v3 = v5;
    swift_storeEnumTagMultiPayload();
  }
  char v6 = *(void **)(a1 + 16);

  free(v6);
}

uint64_t NWEndpoint.agentIdentifier.getter@<X0>(uint64_t a1@<X8>)
{
  return sub_1834D3218((void (*)(uint64_t, unsigned __int8 *))nw_endpoint_get_agent_identifier, a1);
}

uint64_t NWEndpoint.agentIdentifier.setter(uint64_t a1)
{
  return sub_1834D3484(a1, (void (*)(nw_endpoint_t, unsigned char *))nw_endpoint_set_agent_identifier);
}

void (*NWEndpoint.agentIdentifier.modify(void *a1))(uint64_t a1, char a2)
{
  *a1 = v1;
  size_t v3 = *(void *)(*(void *)(__swift_instantiateConcreteTypeFromMangledName(&qword_1E8F62DD0) - 8) + 64);
  a1[1] = malloc(v3);
  nw_endpoint_t v4 = malloc(v3);
  a1[2] = v4;
  NWEndpoint.agentIdentifier.getter((uint64_t)v4);
  return sub_1834D2D1C;
}

void sub_1834D2D1C(uint64_t a1, char a2)
{
}

uint64_t NWEndpoint.remoteInterfaceType.getter@<X0>(unsigned char *a1@<X8>)
{
  uint64_t v2 = v1;
  uint64_t v4 = type metadata accessor for NWEndpoint();
  MEMORY[0x1F4188790](v4);
  char v6 = (void **)((char *)&v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0));
  sub_1834D7F00(v2, (uint64_t)v6);
  if (swift_getEnumCaseMultiPayload() == 4)
  {
    remote_interface_int type = nw_endpoint_get_remote_interface_type(*v6);
    uint64_t result = swift_unknownObjectRelease();
    switch(remote_interface_type)
    {
      case 1:
        *a1 = 1;
        break;
      case 2:
        *a1 = 2;
        break;
      case 3:
        *a1 = 3;
        break;
      case 4:
        *a1 = 4;
        break;
      default:
        *a1 = 0;
        break;
    }
  }
  else
  {
    *a1 = 5;
    return sub_1834D7F64((uint64_t)v6);
  }
  return result;
}

nw_endpoint_t sub_1834D2E74(unsigned __int8 *a1, nw_endpoint_t *a2)
{
  int v3 = *a1;
  nw_endpoint_t result = NWEndpoint.nw.getter();
  if (result)
  {
    nw_endpoint_t v5 = result;
    if (v3 == 5)
    {
      return (nw_endpoint_t)swift_unknownObjectRelease();
    }
    else
    {
      sub_1834D7F64((uint64_t)a2);
      nw_endpoint_set_remote_interface_type(v5, v3);
      *a2 = v5;
      type metadata accessor for NWEndpoint();
      return (nw_endpoint_t)swift_storeEnumTagMultiPayload();
    }
  }
  return result;
}

nw_endpoint_t NWEndpoint.remoteInterfaceType.setter(unsigned __int8 *a1)
{
  int v2 = *a1;
  nw_endpoint_t result = NWEndpoint.nw.getter();
  if (result)
  {
    nw_endpoint_t v4 = result;
    if (v2 == 5)
    {
      return (nw_endpoint_t)swift_unknownObjectRelease();
    }
    else
    {
      sub_1834D7F64((uint64_t)v1);
      nw_endpoint_set_remote_interface_type(v4, v2);
      nw_endpoint_t *v1 = v4;
      type metadata accessor for NWEndpoint();
      return (nw_endpoint_t)swift_storeEnumTagMultiPayload();
    }
  }
  return result;
}

void (*NWEndpoint.remoteInterfaceType.modify(uint64_t *a1))(uint64_t a1)
{
  uint64_t v2 = v1;
  nw_endpoint_t v4 = (char *)(a1 + 3);
  *a1 = v2;
  uint64_t v5 = type metadata accessor for NWEndpoint();
  a1[1] = v5;
  char v6 = (void **)malloc(*(void *)(*(void *)(v5 - 8) + 64));
  a1[2] = (uint64_t)v6;
  sub_1834D7F00(v2, (uint64_t)v6);
  if (swift_getEnumCaseMultiPayload() == 4)
  {
    remote_interface_int type = nw_endpoint_get_remote_interface_type(*v6);
    swift_unknownObjectRelease();
    switch(remote_interface_type)
    {
      case 1:
        char v8 = 1;
        goto LABEL_9;
      case 2:
        char v8 = 2;
        goto LABEL_9;
      case 3:
        char v8 = 3;
        goto LABEL_9;
      case 4:
        char v8 = 4;
LABEL_9:
        *nw_endpoint_t v4 = v8;
        break;
      default:
        *nw_endpoint_t v4 = 0;
        break;
    }
  }
  else
  {
    *nw_endpoint_t v4 = 5;
    sub_1834D7F64((uint64_t)v6);
  }
  return sub_1834D310C;
}

void sub_1834D310C(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 24);
  int v3 = *(nw_endpoint_t **)a1;
  nw_endpoint_t v4 = NWEndpoint.nw.getter();
  if (v4)
  {
    if (v2 == 5)
    {
      swift_unknownObjectRelease();
    }
    else
    {
      sub_1834D7F64((uint64_t)v3);
      nw_endpoint_set_remote_interface_type(v4, v2);
      *int v3 = v4;
      swift_storeEnumTagMultiPayload();
    }
  }
  uint64_t v5 = *(void **)(a1 + 16);

  free(v5);
}

uint64_t NWEndpoint.serviceIdentifier.getter@<X0>(uint64_t a1@<X8>)
{
  return sub_1834D3218((void (*)(uint64_t, unsigned __int8 *))nw_endpoint_get_service_identifier, a1);
}

uint64_t sub_1834D3218@<X0>(void (*a1)(uint64_t, unsigned __int8 *)@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2;
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = type metadata accessor for NWEndpoint();
  MEMORY[0x1F4188790](v6);
  char v8 = &uu[-((v7 + 15) & 0xFFFFFFFFFFFFFFF0) - 8];
  sub_1834D7F00(v4, (uint64_t)v8);
  if (swift_getEnumCaseMultiPayload() == 4)
  {
    uint64_t v9 = *(void *)v8;
    *(void *)uu = 0;
    uint64_t v16 = 0;
    a1(v9, uu);
    if (uuid_is_null(uu))
    {
      swift_unknownObjectRelease();
      uint64_t v10 = sub_183D445FC();
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v10 - 8) + 56))(a2, 1, 1, v10);
    }
    else
    {
      sub_183D445CC();
      swift_unknownObjectRelease();
      uint64_t v13 = sub_183D445FC();
      return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(v13 - 8) + 56))(a2, 0, 1, v13);
    }
  }
  else
  {
    uint64_t v12 = sub_183D445FC();
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v12 - 8) + 56))(a2, 1, 1, v12);
    return sub_1834D7F64((uint64_t)v8);
  }
}

uint64_t NWEndpoint.serviceIdentifier.setter(uint64_t a1)
{
  return sub_1834D3484(a1, (void (*)(nw_endpoint_t, unsigned char *))nw_endpoint_set_service_identifier);
}

uint64_t sub_1834D3484(uint64_t a1, void (*a2)(nw_endpoint_t, unsigned char *))
{
  uint64_t v4 = v2;
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = sub_183D445FC();
  uint64_t v7 = *(void *)(v6 - 8);
  MEMORY[0x1F4188790](v6);
  uint64_t v9 = &v34[-((v8 + 15) & 0xFFFFFFFFFFFFFFF0) - 8];
  uint64_t v10 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F62DD0);
  MEMORY[0x1F4188790](v10 - 8);
  uint64_t v12 = &v34[-((v11 + 15) & 0xFFFFFFFFFFFFFFF0) - 8];
  nw_endpoint_t v13 = NWEndpoint.nw.getter();
  if (!v13) {
    return sub_183138A24(a1, &qword_1E8F62DD0);
  }
  nw_endpoint_t v14 = v13;
  sub_183138900(a1, (uint64_t)v12, &qword_1E8F62DD0);
  if ((*(unsigned int (**)(unsigned char *, uint64_t, uint64_t))(v7 + 48))(v12, 1, v6) == 1)
  {
    LOBYTE(v15) = 0;
    LOBYTE(v16) = 0;
    LOBYTE(v17) = 0;
    LOBYTE(v18) = 0;
    LOBYTE(v19) = 0;
    LOBYTE(v20) = 0;
    LOBYTE(v21) = 0;
    LOBYTE(v22) = 0;
    LOBYTE(v23) = 0;
    LOBYTE(v24) = 0;
    LOBYTE(v25) = 0;
    LOBYTE(v26) = 0;
    LOBYTE(v27) = 0;
    LOBYTE(v28) = 0;
    LOBYTE(v29) = 0;
    LOBYTE(v30) = 0;
  }
  else
  {
    (*(void (**)(unsigned char *, unsigned char *, uint64_t))(v7 + 32))(v9, v12, v6);
    unint64_t v30 = sub_183D445DC();
    unint64_t v22 = v32;
    (*(void (**)(unsigned char *, uint64_t))(v7 + 8))(v9, v6);
    unint64_t v29 = v30 >> 8;
    unint64_t v28 = v30 >> 16;
    unint64_t v27 = v30 >> 24;
    unint64_t v26 = HIDWORD(v30);
    unint64_t v25 = v30 >> 40;
    unint64_t v24 = HIWORD(v30);
    unint64_t v23 = HIBYTE(v30);
    unint64_t v21 = v22 >> 8;
    unint64_t v20 = v22 >> 16;
    unint64_t v19 = v22 >> 24;
    unint64_t v18 = HIDWORD(v22);
    unint64_t v17 = v22 >> 40;
    unint64_t v16 = HIWORD(v22);
    unint64_t v15 = HIBYTE(v22);
  }
  v34[0] = v30;
  v34[1] = v29;
  void v34[2] = v28;
  v34[3] = v27;
  void v34[4] = v26;
  v34[5] = v25;
  v34[6] = v24;
  v34[7] = v23;
  v34[8] = v22;
  v34[9] = v21;
  v34[10] = v20;
  v34[11] = v19;
  v34[12] = v18;
  v34[13] = v17;
  v34[14] = v16;
  v34[15] = v15;
  a2(v14, v34);
  sub_1834D7F64((uint64_t)v4);
  sub_183138A24(a1, &qword_1E8F62DD0);
  *uint64_t v4 = v14;
  type metadata accessor for NWEndpoint();
  return swift_storeEnumTagMultiPayload();
}

void (*NWEndpoint.serviceIdentifier.modify(void *a1))(uint64_t a1, char a2)
{
  *a1 = v1;
  size_t v3 = *(void *)(*(void *)(__swift_instantiateConcreteTypeFromMangledName(&qword_1E8F62DD0) - 8) + 64);
  a1[1] = malloc(v3);
  uint64_t v4 = malloc(v3);
  a1[2] = v4;
  NWEndpoint.serviceIdentifier.getter((uint64_t)v4);
  return sub_1834D37F0;
}

void sub_1834D37F0(uint64_t a1, char a2)
{
}

uint64_t NWEndpoint.cnames.getter()
{
  uint64_t v1 = type metadata accessor for NWEndpoint();
  MEMORY[0x1F4188790](v1);
  size_t v3 = (void **)((char *)&aBlock[-1] - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0));
  sub_1834D7F00(v0, (uint64_t)v3);
  if (swift_getEnumCaseMultiPayload() != 4)
  {
    sub_1834D7F64((uint64_t)v3);
    return 0;
  }
  uint64_t v4 = *v3;
  uint64_t v12 = MEMORY[0x1E4FBC860];
  uint64_t v5 = swift_allocObject();
  *(void *)(v5 + 16) = &v12;
  uint64_t v6 = swift_allocObject();
  *(void *)(v6 + 16) = sub_1834AEF48;
  *(void *)(v6 + 24) = v5;
  void aBlock[4] = sub_1834AEF60;
  aBlock[5] = v6;
  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 1107296256;
  aBlock[2] = sub_1834BFC00;
  aBlock[3] = &block_descriptor_25;
  uint64_t v7 = _Block_copy(aBlock);
  swift_retain();
  swift_release();
  nw_endpoint_enumerate_cnames(v4, v7);
  swift_unknownObjectRelease();
  _Block_release(v7);
  LOBYTE(v4) = swift_isEscapingClosureAtFileLocation();
  uint64_t result = swift_release();
  if ((v4 & 1) == 0)
  {
    uint64_t v9 = v12;
    swift_release();
    return v9;
  }
  __break(1u);
  return result;
}

uint64_t NWEndpoint.ethernetAddress.getter@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  uint64_t v4 = type metadata accessor for NWEndpoint();
  MEMORY[0x1F4188790](v4);
  uint64_t v6 = (void **)((char *)&v12 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0));
  sub_1834D7F00(v2, (uint64_t)v6);
  if (swift_getEnumCaseMultiPayload() == 4)
  {
    ethernet_sockaddr address = nw_endpoint_get_ethernet_address(*v6);
    if (ethernet_address)
    {
      int v8 = *(_DWORD *)ethernet_address;
      uint64_t v9 = ethernet_address[4];
      uint64_t v10 = ethernet_address[5];
      uint64_t result = swift_unknownObjectRelease();
      *(_DWORD *)a1 = v8;
      *(_WORD *)(a1 + 4) = ((v10 << 40) | (unint64_t)(v9 << 32)) >> 32;
      *(unsigned char *)(a1 + 6) = 0;
    }
    else
    {
      uint64_t result = swift_unknownObjectRelease();
      *(_WORD *)(a1 + 4) = 0;
      *(_DWORD *)a1 = 0;
      *(unsigned char *)(a1 + 6) = 1;
    }
  }
  else
  {
    *(_WORD *)(a1 + 4) = 0;
    *(_DWORD *)a1 = 0;
    *(unsigned char *)(a1 + 6) = 1;
    return sub_1834D7F64((uint64_t)v6);
  }
  return result;
}

uint64_t NWEndpoint.knownTrackerOwner.getter()
{
  return sub_1834D3B3C(nw_endpoint_get_known_tracker_name);
}

uint64_t NWEndpoint.trackerOwner.getter()
{
  return sub_1834D3B3C(nw_endpoint_get_tracker_owner);
}

uint64_t sub_1834D3B3C(uint64_t (*a1)(void))
{
  uint64_t v3 = v1;
  uint64_t v4 = type metadata accessor for NWEndpoint();
  MEMORY[0x1F4188790](v4);
  uint64_t v6 = (uint64_t *)((char *)&v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0));
  sub_1834D7F00(v3, (uint64_t)v6);
  if (swift_getEnumCaseMultiPayload() != 4)
  {
    sub_1834D7F64((uint64_t)v6);
    return 0;
  }
  if (!a1(*v6))
  {
    swift_unknownObjectRelease();
    return 0;
  }
  uint64_t v7 = sub_183D44C9C();
  swift_unknownObjectRelease();
  return v7;
}

uint64_t NWEndpoint.priority.getter()
{
  return sub_1834D3C58((uint64_t (*)(void))nw_endpoint_get_priority);
}

uint64_t NWEndpoint.weight.getter()
{
  return sub_1834D3C58((uint64_t (*)(void))nw_endpoint_get_weight);
}

uint64_t sub_1834D3C58(uint64_t (*a1)(void))
{
  uint64_t v3 = v1;
  uint64_t v4 = type metadata accessor for NWEndpoint();
  MEMORY[0x1F4188790](v4);
  uint64_t v6 = (uint64_t *)((char *)&v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0));
  sub_1834D7F00(v3, (uint64_t)v6);
  if (swift_getEnumCaseMultiPayload() == 4)
  {
    uint64_t v7 = a1(*v6);
    swift_unknownObjectRelease();
  }
  else
  {
    sub_1834D7F64((uint64_t)v6);
    return 0;
  }
  return v7;
}

uint64_t NWEndpoint.publicKeys.getter()
{
  uint64_t v1 = type metadata accessor for NWEndpoint();
  MEMORY[0x1F4188790](v1);
  uint64_t v3 = (void **)((char *)&v8 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0));
  sub_1834D7F00(v0, (uint64_t)v3);
  if (swift_getEnumCaseMultiPayload() != 4)
  {
    sub_1834D7F64((uint64_t)v3);
    return 0;
  }
  id v4 = nw_endpoint_copy_public_keys(*v3);
  if (!v4)
  {
    swift_unknownObjectRelease();
    return 0;
  }
  uint64_t v5 = v4;
  uint64_t v6 = sub_183D44E4C();

  swift_unknownObjectRelease();
  return v6;
}

uint64_t sub_1834D3E08(uint64_t *a1, nw_endpoint_t *a2)
{
  uint64_t v3 = *a1;
  swift_bridgeObjectRetain();
  nw_endpoint_t v4 = NWEndpoint.nw.getter();
  if (v4)
  {
    nw_endpoint_t v5 = v4;
    sub_1834D7F64((uint64_t)a2);
    if (v3)
    {
      uint64_t v6 = (void *)sub_183D44E3C();
      swift_bridgeObjectRelease();
    }
    else
    {
      uint64_t v6 = 0;
    }
    nw_endpoint_set_public_keys(v5, v6);

    *a2 = v5;
    type metadata accessor for NWEndpoint();
    return swift_storeEnumTagMultiPayload();
  }
  else
  {
    return swift_bridgeObjectRelease();
  }
}

uint64_t NWEndpoint.publicKeys.setter(uint64_t a1)
{
  nw_endpoint_t v3 = NWEndpoint.nw.getter();
  if (v3)
  {
    nw_endpoint_t v4 = v3;
    sub_1834D7F64((uint64_t)v1);
    if (a1)
    {
      nw_endpoint_t v5 = (void *)sub_183D44E3C();
      swift_bridgeObjectRelease();
    }
    else
    {
      nw_endpoint_t v5 = 0;
    }
    nw_endpoint_set_public_keys(v4, v5);

    nw_endpoint_t *v1 = v4;
    type metadata accessor for NWEndpoint();
    return swift_storeEnumTagMultiPayload();
  }
  else
  {
    return swift_bridgeObjectRelease();
  }
}

void (*NWEndpoint.publicKeys.modify(uint64_t *a1))(uint64_t *a1, char a2)
{
  uint64_t v2 = v1;
  a1[1] = v1;
  uint64_t v4 = type metadata accessor for NWEndpoint();
  a1[2] = v4;
  nw_endpoint_t v5 = (void **)malloc(*(void *)(*(void *)(v4 - 8) + 64));
  a1[3] = (uint64_t)v5;
  sub_1834D7F00(v2, (uint64_t)v5);
  if (swift_getEnumCaseMultiPayload() != 4)
  {
    sub_1834D7F64((uint64_t)v5);
LABEL_6:
    uint64_t v8 = 0;
    goto LABEL_7;
  }
  id v6 = nw_endpoint_copy_public_keys(*v5);
  if (!v6)
  {
    swift_unknownObjectRelease();
    goto LABEL_6;
  }
  uint64_t v7 = v6;
  uint64_t v8 = sub_183D44E4C();
  swift_unknownObjectRelease();

LABEL_7:
  *a1 = v8;
  return sub_1834D4084;
}

void sub_1834D4084(uint64_t *a1, char a2)
{
  uint64_t v4 = *a1;
  nw_endpoint_t v3 = (nw_endpoint_t *)a1[1];
  if (a2)
  {
    swift_bridgeObjectRetain();
    nw_endpoint_t v5 = NWEndpoint.nw.getter();
    if (v5)
    {
      nw_endpoint_t v6 = v5;
      sub_1834D7F64((uint64_t)v3);
      if (v4)
      {
        uint64_t v7 = (void *)sub_183D44E3C();
        swift_bridgeObjectRelease();
      }
      else
      {
        uint64_t v7 = 0;
      }
      nw_endpoint_set_public_keys(v6, v7);

      *nw_endpoint_t v3 = v6;
      swift_storeEnumTagMultiPayload();
    }
    else
    {
      swift_bridgeObjectRelease();
    }
    uint64_t v11 = (void *)a1[3];
    swift_bridgeObjectRelease();
  }
  else
  {
    nw_endpoint_t v8 = NWEndpoint.nw.getter();
    if (v8)
    {
      nw_endpoint_t v9 = v8;
      sub_1834D7F64((uint64_t)v3);
      if (v4)
      {
        uint64_t v10 = (void *)sub_183D44E3C();
        swift_bridgeObjectRelease();
      }
      else
      {
        uint64_t v10 = 0;
      }
      nw_endpoint_set_public_keys(v9, v10);

      *nw_endpoint_t v3 = v9;
      swift_storeEnumTagMultiPayload();
    }
    else
    {
      swift_bridgeObjectRelease();
    }
    uint64_t v11 = (void *)a1[3];
  }

  free(v11);
}

uint64_t NWEndpoint.applicationServiceName.getter()
{
  return sub_1834D5200((void (*))nw_endpoint_get_application_service_name);
}

uint64_t NWEndpoint.applicationServiceAlias.getter()
{
  return sub_1834D5200((void (*))nw_endpoint_get_application_service_alias);
}

uint64_t NWEndpoint.deviceName.getter()
{
  return sub_1834D4E58((uint64_t (*))nw_endpoint_get_device_name);
}

uint64_t NWEndpoint.deviceName.setter(uint64_t a1, uint64_t a2)
{
  return sub_1834D4F6C(a1, a2, (void (*)(NSObject *, uint64_t))nw_endpoint_set_device_name);
}

void (*NWEndpoint.deviceName.modify(void *a1))(uint64_t **a1, char a2)
{
  uint64_t v2 = v1;
  uint64_t v4 = malloc(0x30uLL);
  *a1 = v4;
  void v4[2] = v2;
  uint64_t v5 = type metadata accessor for NWEndpoint();
  v4[3] = v5;
  size_t v6 = *(void *)(*(void *)(v5 - 8) + 64);
  v4[4] = malloc(v6);
  uint64_t v7 = (NSObject **)malloc(v6);
  void v4[5] = v7;
  sub_1834D7F00(v2, (uint64_t)v7);
  if (swift_getEnumCaseMultiPayload() != 4)
  {
    sub_1834D7F64((uint64_t)v7);
LABEL_7:
    uint64_t v9 = 0;
    uint64_t v11 = 0;
    goto LABEL_8;
  }
  nw_endpoint_t v8 = *v7;
  if (nw_endpoint_get_type(v8) != (nw_endpoint_type_url|nw_endpoint_type_host) || !nw_endpoint_get_device_name(v8))
  {
    swift_unknownObjectRelease();
    goto LABEL_7;
  }
  uint64_t v9 = sub_183D44C9C();
  uint64_t v11 = v10;
  swift_unknownObjectRelease();
LABEL_8:
  *uint64_t v4 = v9;
  v4[1] = v11;
  return sub_1834D434C;
}

void sub_1834D434C(uint64_t **a1, char a2)
{
}

uint64_t NWEndpoint.deviceModel.getter()
{
  return sub_1834D4E58((uint64_t (*))nw_endpoint_get_device_model);
}

uint64_t NWEndpoint.deviceModel.setter(uint64_t a1, uint64_t a2)
{
  return sub_1834D4F6C(a1, a2, (void (*)(NSObject *, uint64_t))nw_endpoint_set_device_model);
}

void (*NWEndpoint.deviceModel.modify(void *a1))(uint64_t **a1, char a2)
{
  uint64_t v2 = v1;
  uint64_t v4 = malloc(0x30uLL);
  *a1 = v4;
  void v4[2] = v2;
  uint64_t v5 = type metadata accessor for NWEndpoint();
  v4[3] = v5;
  size_t v6 = *(void *)(*(void *)(v5 - 8) + 64);
  v4[4] = malloc(v6);
  uint64_t v7 = (NSObject **)malloc(v6);
  void v4[5] = v7;
  sub_1834D7F00(v2, (uint64_t)v7);
  if (swift_getEnumCaseMultiPayload() != 4)
  {
    sub_1834D7F64((uint64_t)v7);
LABEL_7:
    uint64_t v9 = 0;
    uint64_t v11 = 0;
    goto LABEL_8;
  }
  nw_endpoint_t v8 = *v7;
  if (nw_endpoint_get_type(v8) != (nw_endpoint_type_url|nw_endpoint_type_host) || !nw_endpoint_get_device_model(v8))
  {
    swift_unknownObjectRelease();
    goto LABEL_7;
  }
  uint64_t v9 = sub_183D44C9C();
  uint64_t v11 = v10;
  swift_unknownObjectRelease();
LABEL_8:
  *uint64_t v4 = v9;
  v4[1] = v11;
  return sub_1834D44C8;
}

void sub_1834D44C8(uint64_t **a1, char a2)
{
}

void sub_1834D44F4(uint64_t **a1, char a2, void (*a3)(NSObject *, uint64_t), void (*a4)(uint64_t, uint64_t))
{
  uint64_t v4 = *a1;
  uint64_t v6 = **a1;
  uint64_t v5 = (*a1)[1];
  if (a2)
  {
    uint64_t v9 = (void *)v4[4];
    nw_endpoint_t v8 = (void *)v4[5];
    swift_bridgeObjectRetain();
    a4(v6, v5);
    swift_bridgeObjectRelease();
  }
  else
  {
    sub_1834D7F00((*a1)[2], v4[4]);
    int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
    uint64_t v12 = (NSObject **)v4[4];
    if (EnumCaseMultiPayload == 4)
    {
      nw_endpoint_t v13 = *v12;
      if (nw_endpoint_get_type(v13) == (nw_endpoint_type_url|nw_endpoint_type_host))
      {
        if (v5)
        {
          uint64_t v14 = sub_183D44BAC();
          swift_bridgeObjectRelease();
          uint64_t v15 = v14 + 32;
        }
        else
        {
          uint64_t v15 = 0;
        }
        a3(v13, v15);
        swift_unknownObjectRelease();
        swift_unknownObjectRelease();
      }
      else
      {
        swift_unknownObjectRelease();
        swift_bridgeObjectRelease();
      }
    }
    else
    {
      swift_bridgeObjectRelease();
      sub_1834D7F64((uint64_t)v12);
    }
    uint64_t v9 = (void *)v4[4];
    nw_endpoint_t v8 = (void *)v4[5];
  }
  free(v8);
  free(v9);

  free(v4);
}

uint64_t NWEndpoint.deviceColor.getter()
{
  uint64_t v1 = type metadata accessor for NWEndpoint();
  MEMORY[0x1F4188790](v1);
  nw_endpoint_t v3 = (NSObject **)((char *)&v7 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0));
  sub_1834D7F00(v0, (uint64_t)v3);
  if (swift_getEnumCaseMultiPayload() != 4)
  {
    sub_1834D7F64((uint64_t)v3);
    return 0;
  }
  uint64_t v4 = *v3;
  if (nw_endpoint_get_type(v4) != (nw_endpoint_type_url|nw_endpoint_type_host))
  {
    swift_unknownObjectRelease();
    return 0;
  }
  uint64_t device_color = nw_endpoint_get_device_color(v4);
  swift_unknownObjectRelease();
  return device_color;
}

uint64_t sub_1834D471C@<X0>(uint64_t a1@<X0>, _DWORD *a2@<X8>)
{
  uint64_t v4 = type metadata accessor for NWEndpoint();
  MEMORY[0x1F4188790](v4);
  uint64_t v6 = (NSObject **)((char *)&v10 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0));
  sub_1834D7F00(a1, (uint64_t)v6);
  if (swift_getEnumCaseMultiPayload() != 4)
  {
    uint64_t result = sub_1834D7F64((uint64_t)v6);
LABEL_6:
    int device_color = 0;
    goto LABEL_7;
  }
  uint64_t v7 = *v6;
  if (nw_endpoint_get_type(v7) != (nw_endpoint_type_url|nw_endpoint_type_host))
  {
    uint64_t result = swift_unknownObjectRelease();
    goto LABEL_6;
  }
  int device_color = nw_endpoint_get_device_color(v7);
  uint64_t result = swift_unknownObjectRelease();
LABEL_7:
  *a2 = device_color;
  return result;
}

uint64_t sub_1834D4800(int *a1, uint64_t a2)
{
  uint64_t v4 = type metadata accessor for NWEndpoint();
  MEMORY[0x1F4188790](v4);
  uint64_t v6 = (NSObject **)((char *)&v10 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0));
  int v7 = *a1;
  sub_1834D7F00(a2, (uint64_t)v6);
  if (swift_getEnumCaseMultiPayload() != 4) {
    return sub_1834D7F64((uint64_t)v6);
  }
  nw_endpoint_t v8 = *v6;
  if (nw_endpoint_get_type(v8) == (nw_endpoint_type_url|nw_endpoint_type_host)) {
    nw_endpoint_set_device_color(v8, v7);
  }
  return swift_unknownObjectRelease();
}

uint64_t NWEndpoint.deviceColor.setter(int a1)
{
  uint64_t v2 = v1;
  uint64_t v4 = type metadata accessor for NWEndpoint();
  MEMORY[0x1F4188790](v4);
  uint64_t v6 = (NSObject **)((char *)&v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0));
  sub_1834D7F00(v2, (uint64_t)v6);
  if (swift_getEnumCaseMultiPayload() != 4) {
    return sub_1834D7F64((uint64_t)v6);
  }
  int v7 = *v6;
  if (nw_endpoint_get_type(v7) == (nw_endpoint_type_url|nw_endpoint_type_host)) {
    nw_endpoint_set_device_color(v7, a1);
  }
  return swift_unknownObjectRelease();
}

void (*NWEndpoint.deviceColor.modify(void *a1))(uint64_t **a1, char a2)
{
  nw_endpoint_t v3 = malloc(0x30uLL);
  *a1 = v3;
  *nw_endpoint_t v3 = v1;
  uint64_t v4 = type metadata accessor for NWEndpoint();
  v3[1] = v4;
  size_t v5 = *(void *)(*(void *)(v4 - 8) + 64);
  void v3[2] = malloc(v5);
  v3[3] = malloc(v5);
  uint64_t v6 = (NSObject **)malloc(v5);
  v3[4] = v6;
  sub_1834D7F00(v1, (uint64_t)v6);
  if (swift_getEnumCaseMultiPayload() != 4)
  {
    sub_1834D7F64((uint64_t)v6);
LABEL_6:
    int device_color = 0;
    goto LABEL_7;
  }
  int v7 = *v6;
  if (nw_endpoint_get_type(v7) != (nw_endpoint_type_url|nw_endpoint_type_host))
  {
    swift_unknownObjectRelease();
    goto LABEL_6;
  }
  int device_color = nw_endpoint_get_device_color(v7);
  swift_unknownObjectRelease();
LABEL_7:
  *((_DWORD *)v3 + 10) = device_color;
  return sub_1834D4AC4;
}

void sub_1834D4AC4(uint64_t **a1, char a2)
{
  uint64_t v2 = *a1;
  int v3 = *((_DWORD *)*a1 + 10);
  uint64_t v4 = **a1;
  if (a2)
  {
    sub_1834D7F00(v4, v2[2]);
    int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
    uint64_t v6 = (nw_endpoint_t *)v2[2];
    if (EnumCaseMultiPayload != 4)
    {
LABEL_3:
      sub_1834D7F64((uint64_t)v6);
      goto LABEL_8;
    }
  }
  else
  {
    sub_1834D7F00(v4, v2[3]);
    int v7 = swift_getEnumCaseMultiPayload();
    uint64_t v6 = (nw_endpoint_t *)v2[3];
    if (v7 != 4) {
      goto LABEL_3;
    }
  }
  nw_endpoint_t v8 = *v6;
  if (nw_endpoint_get_type(*v6) == (nw_endpoint_type_url|nw_endpoint_type_host)) {
    nw_endpoint_set_device_color(v8, v3);
  }
  swift_unknownObjectRelease();
LABEL_8:
  uint64_t v9 = (void *)v2[3];
  uint64_t v10 = (void *)v2[2];
  free((void *)v2[4]);
  free(v9);
  free(v10);

  free(v2);
}

uint64_t NWEndpoint.route.getter@<X0>(char *a1@<X8>)
{
  uint64_t v2 = v1;
  uint64_t v4 = type metadata accessor for NWEndpoint();
  MEMORY[0x1F4188790](v4);
  uint64_t v6 = (NSObject **)((char *)&v11 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0));
  sub_1834D7F00(v2, (uint64_t)v6);
  if (swift_getEnumCaseMultiPayload() != 4)
  {
    *a1 = 3;
    return sub_1834D7F64((uint64_t)v6);
  }
  int v7 = *v6;
  if (nw_endpoint_get_type(v7) == (nw_endpoint_type_url|nw_endpoint_type_host))
  {
    int advertised_route = nw_endpoint_get_advertised_route(v7);
    uint64_t result = swift_unknownObjectRelease();
    switch(advertised_route)
    {
      case 3:
        char v10 = 2;
        goto LABEL_10;
      case 2:
        char v10 = 1;
        goto LABEL_10;
      case 1:
        *a1 = 0;
        return result;
    }
  }
  else
  {
    uint64_t result = swift_unknownObjectRelease();
  }
  char v10 = 3;
LABEL_10:
  *a1 = v10;
  return result;
}

uint64_t NWEndpoint.deviceID.getter()
{
  return sub_1834D4E58((uint64_t (*))nw_endpoint_get_device_id);
}

uint64_t NWEndpoint.deviceID.setter(uint64_t a1, uint64_t a2)
{
  return sub_1834D4F6C(a1, a2, (void (*)(NSObject *, uint64_t))nw_endpoint_set_device_id);
}

void (*NWEndpoint.deviceID.modify(void *a1))(uint64_t **a1, char a2)
{
  uint64_t v2 = v1;
  uint64_t v4 = malloc(0x30uLL);
  *a1 = v4;
  void v4[2] = v2;
  uint64_t v5 = type metadata accessor for NWEndpoint();
  v4[3] = v5;
  size_t v6 = *(void *)(*(void *)(v5 - 8) + 64);
  v4[4] = malloc(v6);
  int v7 = (NSObject **)malloc(v6);
  void v4[5] = v7;
  sub_1834D7F00(v2, (uint64_t)v7);
  if (swift_getEnumCaseMultiPayload() != 4)
  {
    sub_1834D7F64((uint64_t)v7);
LABEL_7:
    uint64_t v9 = 0;
    uint64_t v11 = 0;
    goto LABEL_8;
  }
  nw_endpoint_t v8 = *v7;
  if (nw_endpoint_get_type(v8) != (nw_endpoint_type_url|nw_endpoint_type_host) || !nw_endpoint_get_device_id(v8))
  {
    swift_unknownObjectRelease();
    goto LABEL_7;
  }
  uint64_t v9 = sub_183D44C9C();
  uint64_t v11 = v10;
  swift_unknownObjectRelease();
LABEL_8:
  *uint64_t v4 = v9;
  v4[1] = v11;
  return sub_1834D4E14;
}

void sub_1834D4E14(uint64_t **a1, char a2)
{
}

uint64_t NWEndpoint.contactID.getter()
{
  return sub_1834D4E58((uint64_t (*))nw_endpoint_get_contact_id);
}

uint64_t sub_1834D4E58(uint64_t (*a1)(NSObject *))
{
  uint64_t v3 = v1;
  uint64_t v4 = type metadata accessor for NWEndpoint();
  MEMORY[0x1F4188790](v4);
  size_t v6 = (NSObject **)((char *)&v10 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0));
  sub_1834D7F00(v3, (uint64_t)v6);
  if (swift_getEnumCaseMultiPayload() != 4)
  {
    sub_1834D7F64((uint64_t)v6);
    return 0;
  }
  int v7 = *v6;
  if (nw_endpoint_get_type(v7) != (nw_endpoint_type_url|nw_endpoint_type_host) || !a1(v7))
  {
    swift_unknownObjectRelease();
    return 0;
  }
  uint64_t v8 = sub_183D44C9C();
  swift_unknownObjectRelease();
  return v8;
}

uint64_t NWEndpoint.contactID.setter(uint64_t a1, uint64_t a2)
{
  return sub_1834D4F6C(a1, a2, (void (*)(NSObject *, uint64_t))nw_endpoint_set_contact_id);
}

uint64_t sub_1834D4F6C(uint64_t a1, uint64_t a2, void (*a3)(NSObject *, uint64_t))
{
  uint64_t v5 = v3;
  uint64_t v7 = type metadata accessor for NWEndpoint();
  MEMORY[0x1F4188790](v7);
  uint64_t v9 = (NSObject **)((char *)&v14 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0));
  sub_1834D7F00(v5, (uint64_t)v9);
  if (swift_getEnumCaseMultiPayload() == 4)
  {
    uint64_t v10 = *v9;
    if (nw_endpoint_get_type(v10) == (nw_endpoint_type_url|nw_endpoint_type_host))
    {
      if (a2)
      {
        uint64_t v11 = sub_183D44BAC();
        swift_bridgeObjectRelease();
        uint64_t v12 = v11 + 32;
      }
      else
      {
        uint64_t v12 = 0;
      }
      a3(v10, v12);
      swift_unknownObjectRelease();
      return swift_unknownObjectRelease();
    }
    else
    {
      swift_unknownObjectRelease();
      return swift_bridgeObjectRelease();
    }
  }
  else
  {
    swift_bridgeObjectRelease();
    return sub_1834D7F64((uint64_t)v9);
  }
}

void (*NWEndpoint.contactID.modify(void *a1))(uint64_t **a1, char a2)
{
  uint64_t v2 = v1;
  uint64_t v4 = malloc(0x30uLL);
  *a1 = v4;
  void v4[2] = v2;
  uint64_t v5 = type metadata accessor for NWEndpoint();
  v4[3] = v5;
  size_t v6 = *(void *)(*(void *)(v5 - 8) + 64);
  v4[4] = malloc(v6);
  uint64_t v7 = (NSObject **)malloc(v6);
  void v4[5] = v7;
  sub_1834D7F00(v2, (uint64_t)v7);
  if (swift_getEnumCaseMultiPayload() != 4)
  {
    sub_1834D7F64((uint64_t)v7);
LABEL_7:
    uint64_t v9 = 0;
    uint64_t v11 = 0;
    goto LABEL_8;
  }
  uint64_t v8 = *v7;
  if (nw_endpoint_get_type(v8) != (nw_endpoint_type_url|nw_endpoint_type_host) || !nw_endpoint_get_contact_id(v8))
  {
    swift_unknownObjectRelease();
    goto LABEL_7;
  }
  uint64_t v9 = sub_183D44C9C();
  uint64_t v11 = v10;
  swift_unknownObjectRelease();
LABEL_8:
  *uint64_t v4 = v9;
  v4[1] = v11;
  return sub_1834D51BC;
}

void sub_1834D51BC(uint64_t **a1, char a2)
{
}

uint64_t NWEndpoint.applicationService.getter()
{
  return sub_1834D5200((void (*))nw_endpoint_get_application_service_name);
}

uint64_t sub_1834D5200(void (*a1)(NSObject *))
{
  uint64_t v3 = v1;
  uint64_t v4 = type metadata accessor for NWEndpoint();
  MEMORY[0x1F4188790](v4);
  size_t v6 = (NSObject **)((char *)&v10 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0));
  sub_1834D7F00(v3, (uint64_t)v6);
  if (swift_getEnumCaseMultiPayload() != 4)
  {
    sub_1834D7F64((uint64_t)v6);
    return 0;
  }
  uint64_t v7 = *v6;
  if (nw_endpoint_get_type(v7) != (nw_endpoint_type_url|nw_endpoint_type_host))
  {
    swift_unknownObjectRelease();
    return 0;
  }
  a1(v7);
  uint64_t v8 = sub_183D44C9C();
  swift_unknownObjectRelease();
  return v8;
}

uint64_t NWEndpoint.applicationService.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = type metadata accessor for NWEndpoint();
  MEMORY[0x1F4188790](v4);
  size_t v6 = (NSObject **)((char *)&v10 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0));
  sub_1834D7F00(v2, (uint64_t)v6);
  if (swift_getEnumCaseMultiPayload() == 4)
  {
    uint64_t v7 = *v6;
    if (a2)
    {
      if (nw_endpoint_get_type(v7) == (nw_endpoint_type_url|nw_endpoint_type_host))
      {
        uint64_t v8 = sub_183D44BAC();
        swift_bridgeObjectRelease();
        nw_endpoint_set_application_service_name(v7, (const char *)(v8 + 32));
        swift_release();
      }
      else
      {
        swift_bridgeObjectRelease();
      }
    }
    return swift_unknownObjectRelease();
  }
  else
  {
    swift_bridgeObjectRelease();
    return sub_1834D7F64((uint64_t)v6);
  }
}

void (*NWEndpoint.applicationService.modify(void *a1))(uint64_t **a1, char a2)
{
  uint64_t v2 = v1;
  uint64_t v4 = malloc(0x30uLL);
  *a1 = v4;
  void v4[2] = v2;
  uint64_t v5 = type metadata accessor for NWEndpoint();
  v4[3] = v5;
  size_t v6 = *(void *)(*(void *)(v5 - 8) + 64);
  v4[4] = malloc(v6);
  uint64_t v7 = (NSObject **)malloc(v6);
  void v4[5] = v7;
  sub_1834D7F00(v2, (uint64_t)v7);
  if (swift_getEnumCaseMultiPayload() != 4)
  {
    sub_1834D7F64((uint64_t)v7);
LABEL_6:
    uint64_t v9 = 0;
    uint64_t v11 = 0;
    goto LABEL_7;
  }
  uint64_t v8 = *v7;
  if (nw_endpoint_get_type(v8) != (nw_endpoint_type_url|nw_endpoint_type_host))
  {
    swift_unknownObjectRelease();
    goto LABEL_6;
  }
  nw_endpoint_get_application_service_name(v8);
  uint64_t v9 = sub_183D44C9C();
  uint64_t v11 = v10;
  swift_unknownObjectRelease();
LABEL_7:
  *uint64_t v4 = v9;
  v4[1] = v11;
  return sub_1834D5528;
}

void sub_1834D5528(uint64_t **a1, char a2)
{
  uint64_t v2 = *a1;
  uint64_t v4 = **a1;
  uint64_t v3 = (*a1)[1];
  if (a2)
  {
    size_t v6 = (void *)v2[4];
    uint64_t v5 = (void *)v2[5];
    swift_bridgeObjectRetain();
    NWEndpoint.applicationService.setter(v4, v3);
    swift_bridgeObjectRelease();
  }
  else
  {
    sub_1834D7F00((*a1)[2], v2[4]);
    int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
    uint64_t v8 = (NSObject **)v2[4];
    if (EnumCaseMultiPayload == 4)
    {
      uint64_t v9 = *v8;
      if (v3)
      {
        if (nw_endpoint_get_type(v9) == (nw_endpoint_type_url|nw_endpoint_type_host))
        {
          uint64_t v10 = sub_183D44BAC();
          swift_bridgeObjectRelease();
          nw_endpoint_set_application_service_name(v9, (const char *)(v10 + 32));
          swift_unknownObjectRelease();
          swift_release();
        }
        else
        {
          swift_unknownObjectRelease();
          swift_bridgeObjectRelease();
        }
      }
      else
      {
        swift_unknownObjectRelease();
      }
    }
    else
    {
      swift_bridgeObjectRelease();
      sub_1834D7F64((uint64_t)v8);
    }
    size_t v6 = (void *)v2[4];
    uint64_t v5 = (void *)v2[5];
  }
  free(v5);
  free(v6);

  free(v2);
}

uint64_t NWEndpoint.serviceID.getter@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = type metadata accessor for NWEndpoint();
  MEMORY[0x1F4188790](v4);
  size_t v6 = (NSObject **)((char *)&v12 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0));
  sub_1834D7F00(v2, (uint64_t)v6);
  if (swift_getEnumCaseMultiPayload() == 4)
  {
    uint64_t v7 = *v6;
    if (nw_endpoint_get_type(v7) == (nw_endpoint_type_url|nw_endpoint_type_host))
    {
      long long v13 = 0uLL;
      nw_endpoint_get_service_identifier(v7, &v13);
      sub_183D445CC();
      swift_unknownObjectRelease();
      uint64_t v8 = sub_183D445FC();
      return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(v8 - 8) + 56))(a1, 0, 1, v8);
    }
    else
    {
      uint64_t v11 = sub_183D445FC();
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v11 - 8) + 56))(a1, 1, 1, v11);
      return swift_unknownObjectRelease();
    }
  }
  else
  {
    uint64_t v10 = sub_183D445FC();
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v10 - 8) + 56))(a1, 1, 1, v10);
    return sub_1834D7F64((uint64_t)v6);
  }
}

uint64_t sub_1834D5860(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t (*a6)(char *))
{
  uint64_t v9 = __swift_instantiateConcreteTypeFromMangledName(a5);
  MEMORY[0x1F4188790](v9 - 8);
  uint64_t v11 = (char *)&v13 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_183138900(a1, (uint64_t)v11, a5);
  return a6(v11);
}

uint64_t NWEndpoint.serviceID.setter(uint64_t a1)
{
  uint64_t v2 = v1;
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F62DD0);
  MEMORY[0x1F4188790](v4 - 8);
  size_t v6 = (char *)&v23 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = sub_183D445FC();
  uint64_t v8 = *(void *)(v7 - 8);
  MEMORY[0x1F4188790](v7);
  uint64_t v10 = (char *)&v23 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = type metadata accessor for NWEndpoint();
  MEMORY[0x1F4188790](v11);
  uint64_t v13 = (nw_endpoint_t *)((char *)&v23 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0));
  sub_1834D7F00(v2, (uint64_t)v13);
  if (swift_getEnumCaseMultiPayload() == 4)
  {
    nw_endpoint_t v14 = *v13;
    if (nw_endpoint_get_type(*v13) == (nw_endpoint_type_url|nw_endpoint_type_host))
    {
      sub_183138900(a1, (uint64_t)v6, &qword_1E8F62DD0);
      if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v8 + 48))(v6, 1, v7) == 1)
      {
        sub_183138A24(a1, &qword_1E8F62DD0);
        swift_unknownObjectRelease();
        return sub_183138A24((uint64_t)v6, &qword_1E8F62DD0);
      }
      else
      {
        (*(void (**)(char *, char *, uint64_t))(v8 + 32))(v10, v6, v7);
        *(void *)&long long v24 = sub_183D445DC();
        WORD4(v24) = v16;
        BYTE10(v24) = v17;
        BYTE11(v24) = v18;
        BYTE12(v24) = v19;
        BYTE13(v24) = v20;
        BYTE14(v24) = v21;
        HIBYTE(v24) = v22;
        nw_endpoint_set_service_identifier(v14, &v24);
        swift_unknownObjectRelease();
        sub_183138A24(a1, &qword_1E8F62DD0);
        return (*(uint64_t (**)(char *, uint64_t))(v8 + 8))(v10, v7);
      }
    }
    else
    {
      sub_183138A24(a1, &qword_1E8F62DD0);
      return swift_unknownObjectRelease();
    }
  }
  else
  {
    sub_183138A24(a1, &qword_1E8F62DD0);
    return sub_1834D7F64((uint64_t)v13);
  }
}

void (*NWEndpoint.serviceID.modify(void *a1))(uint64_t a1, char a2)
{
  *a1 = v1;
  size_t v3 = *(void *)(*(void *)(__swift_instantiateConcreteTypeFromMangledName(&qword_1E8F62DD0) - 8) + 64);
  a1[1] = malloc(v3);
  uint64_t v4 = malloc(v3);
  a1[2] = v4;
  NWEndpoint.serviceID.getter((uint64_t)v4);
  return sub_1834D5CB8;
}

void sub_1834D5CB8(uint64_t a1, char a2)
{
}

void sub_1834D5CD8(uint64_t a1, char a2, void (*a3)(void *), uint64_t *a4)
{
  uint64_t v5 = *(void **)(a1 + 8);
  size_t v6 = *(void **)(a1 + 16);
  if (a2)
  {
    sub_183138900(*(void *)(a1 + 16), (uint64_t)v5, a4);
    a3(v5);
    sub_183138A24((uint64_t)v6, a4);
  }
  else
  {
    a3(*(void **)(a1 + 16));
  }
  free(v6);

  free(v5);
}

uint64_t static NWEndpoint.applicationService(_:uuid:)@<X0>(uint64_t a1@<X8>)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(qword_1EB266A50);
  MEMORY[0x1F4188790](v2 - 8);
  uint64_t v4 = (char *)&v19 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v20 = sub_183D445DC();
  char v21 = v5;
  char v22 = v6;
  char v23 = v7;
  char v24 = v8;
  char v25 = v9;
  char v26 = v10;
  char v27 = v11;
  char v28 = v12;
  uint64_t v13 = sub_183D44BAC();
  nw_endpoint_create_application_service((const char *)(v13 + 32), (const unsigned __int8 *)&v20);
  swift_release();
  nw_endpoint_t v14 = swift_unknownObjectRetain();
  sub_18315A830(v14, (uint64_t)v4);
  uint64_t v15 = type metadata accessor for NWEndpoint();
  uint64_t v16 = *(void *)(v15 - 8);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v16 + 48))(v4, 1, v15))
  {
    sub_183138A24((uint64_t)v4, qword_1EB266A50);
    uint64_t v17 = 1;
  }
  else
  {
    sub_18315E28C((uint64_t)v4, a1);
    uint64_t v17 = 0;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v16 + 56))(a1, v17, 1, v15);
  return swift_unknownObjectRelease();
}

void NWEndpoint.hash(into:)()
{
  uint64_t v1 = v0;
  uint64_t v2 = sub_183D4447C();
  uint64_t v3 = *(void *)(v2 - 8);
  MEMORY[0x1F4188790](v2);
  char v5 = (char *)v17 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v6 = type metadata accessor for NWEndpoint();
  MEMORY[0x1F4188790](v6);
  char v8 = (char *)v17 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_1834D7F00(v1, (uint64_t)v8);
  switch(swift_getEnumCaseMultiPayload())
  {
    case 1u:
      uint64_t v13 = *((void *)v8 + 6);
      sub_183D45B0C();
      sub_183D44C4C();
      swift_bridgeObjectRelease();
      sub_183D44C4C();
      swift_bridgeObjectRelease();
      sub_183D44C4C();
      swift_bridgeObjectRelease();
      if (v13 == 1)
      {
        sub_183D45B1C();
      }
      else
      {
        sub_183D45B1C();
        if (v13)
        {
          nw_interface_get_index(v13);
          sub_183D45B0C();
          uint64_t v15 = swift_unknownObjectRetain();
          nw_interface_get_name(v15);
          sub_183D44C9C();
          uint64_t v16 = (uint64_t)v13;
        }
        else
        {
          sub_183D45B0C();
          uint64_t v16 = 0;
        }
        sub_18315E51C(v16);
        sub_183D44C4C();
        swift_bridgeObjectRelease();
        sub_18315E51C((uint64_t)v13);
      }
      break;
    case 2u:
      sub_183D45B0C();
      sub_183D44C4C();
      swift_bridgeObjectRelease();
      break;
    case 3u:
      (*(void (**)(char *, char *, uint64_t))(v3 + 32))(v5, v8, v2);
      sub_183D45B0C();
      sub_1834D8648(&qword_1E8F62DD8, MEMORY[0x1E4F276F0]);
      sub_183D44A7C();
      (*(void (**)(char *, uint64_t))(v3 + 8))(v5, v2);
      break;
    case 4u:
      uint64_t v14 = *(void *)v8;
      sub_183D45B0C();
      nw_endpoint_get_hash(v14);
      sub_183D45B0C();
      swift_unknownObjectRelease();
      break;
    default:
      uint64_t v9 = *(void *)v8;
      uint64_t v10 = *((void *)v8 + 1);
      uint64_t v11 = *((void *)v8 + 2);
      char v12 = v8[24];
      sub_183D45B0C();
      v17[0] = v9;
      v17[1] = v10;
      void v17[2] = v11;
      char v18 = v12;
      NWEndpoint.Host.hash(into:)();
      sub_183D45B2C();
      sub_18315E658(v9, v10, v11, v12);
      break;
  }
}

uint64_t NWEndpoint.debugDescription.getter()
{
  uint64_t v1 = v0;
  uint64_t v2 = sub_183D4447C();
  uint64_t v3 = *(void *)(v2 - 8);
  MEMORY[0x1F4188790](v2);
  char v5 = (char *)&v33 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v6 = type metadata accessor for NWEndpoint();
  MEMORY[0x1F4188790](v6);
  char v8 = (char *)&v33 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_1834D7F00(v1, (uint64_t)v8);
  switch(swift_getEnumCaseMultiPayload())
  {
    case 1u:
      unint64_t v15 = *((void *)v8 + 1);
      uint64_t v16 = *((void *)v8 + 2);
      uint64_t v17 = *((void *)v8 + 3);
      uint64_t v38 = *(void *)v8;
      uint64_t v39 = v16;
      uint64_t v18 = *((void *)v8 + 5);
      uint64_t v40 = *((void *)v8 + 4);
      uint64_t v19 = *((void *)v8 + 6);
      uint64_t v20 = sub_183D44EBC();
      *(void *)(v20 + 16) = 1026;
      bzero((void *)(v20 + 32), 0x402uLL);
      uint64_t v37 = v19;
      if (v19 == 1)
      {
        unint64_t v21 = 0;
      }
      else if (v19)
      {
        char v23 = swift_unknownObjectRetain();
        nw_interface_get_name(v23);
        sub_183D44C9C();
        unint64_t v21 = v24;
        sub_18315E51C(v19);
      }
      else
      {
        sub_18315E51C(0);
        unint64_t v21 = 0xE700000000000000;
      }
      unint64_t v34 = v15;
      char v25 = (char *)(sub_183D44BAC() + 32);
      uint64_t v35 = v17;
      char v26 = (char *)(sub_183D44BAC() + 32);
      uint64_t v36 = v18;
      char v27 = (char *)(sub_183D44BAC() + 32);
      if (v21)
      {
        uint64_t v28 = sub_183D44BAC();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRelease();
        uint64_t v29 = v28 + 32;
      }
      else
      {
        swift_bridgeObjectRetain();
        uint64_t v29 = 0;
      }
      int v30 = nw_endpoint_construct_composite_bonjour_name((char *)(v20 + 32), 0x402uLL, v25, v26, v27, v29);
      swift_bridgeObjectRelease();
      swift_release();
      swift_release();
      swift_release();
      swift_unknownObjectRelease();
      if (v30)
      {
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        uint64_t v14 = sub_1834D8270(v20);
        swift_bridgeObjectRelease();
        sub_18315E51C(v37);
      }
      else
      {
        swift_bridgeObjectRelease();
        uint64_t v31 = v37;
        if (v37 == 1)
        {
          uint64_t v41 = v38;
          unint64_t v42 = v34;
          sub_183D44C8C();
          sub_183D44C8C();
          swift_bridgeObjectRelease();
          sub_183D44C8C();
          swift_bridgeObjectRelease();
        }
        else
        {
          uint64_t v41 = 0;
          unint64_t v42 = 0xE000000000000000;
          swift_unknownObjectRetain();
          sub_183D44C8C();
          swift_bridgeObjectRelease();
          sub_183D44C8C();
          sub_183D44C8C();
          swift_bridgeObjectRelease();
          sub_183D44C8C();
          swift_bridgeObjectRelease();
          sub_183D44C8C();
          uint64_t v45 = v31;
          sub_183D4566C();
          sub_18315E51C(v31);
          sub_18315E51C(v31);
        }
        uint64_t v14 = v41;
      }
      break;
    case 2u:
      uint64_t v14 = *(void *)v8;
      break;
    case 3u:
      (*(void (**)(char *, char *, uint64_t))(v3 + 32))(v5, v8, v2);
      sub_1834D8648(&qword_1E8F62DE0, MEMORY[0x1E4F276F0]);
      uint64_t v14 = sub_183D4589C();
      (*(void (**)(char *, uint64_t))(v3 + 8))(v5, v2);
      break;
    case 4u:
      id v22 = objc_msgSend(*(id *)v8, sel_description);
      uint64_t v14 = sub_183D44AFC();
      swift_unknownObjectRelease();

      break;
    default:
      uint64_t v9 = *(void *)v8;
      uint64_t v10 = *((void *)v8 + 1);
      uint64_t v11 = *((void *)v8 + 2);
      __int16 v12 = *((_WORD *)v8 + 13);
      char v13 = v8[24];
      uint64_t v45 = 0;
      unint64_t v46 = 0xE000000000000000;
      uint64_t v41 = v9;
      unint64_t v42 = v10;
      uint64_t v43 = v11;
      char v44 = v13;
      sub_183D4566C();
      sub_183D44C8C();
      LOWORD(v41) = v12;
      sub_183D4566C();
      sub_18315E658(v9, v10, v11, v13);
      uint64_t v14 = v45;
      break;
  }
  return v14;
}

uint64_t NWEndpoint.hashValue.getter()
{
  return sub_183D45B4C();
}

uint64_t sub_1834D68E4()
{
  return sub_183D45B4C();
}

uint64_t sub_1834D6928()
{
  return sub_183D45B4C();
}

char *sub_1834D696C(void *(*a1)(uint64_t *__return_ptr, char *, char *))
{
  void v16[2] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *v1;
  unint64_t v3 = v1[1];
  char v5 = v1;
  switch(v3 >> 62)
  {
    case 1uLL:
      uint64_t v9 = v3 & 0x3FFFFFFFFFFFFFFFLL;
      *(_OWORD *)uint64_t v1 = xmmword_183D54880;
      char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
      uint64_t v11 = v4 >> 32;
      if (isUniquelyReferenced_nonNull_native) {
        goto LABEL_16;
      }
      if (v11 < (int)v4) {
        goto LABEL_23;
      }
      if (sub_183D4434C() && __OFSUB__((int)v4, sub_183D4437C())) {
        goto LABEL_24;
      }
      sub_183D4439C();
      swift_allocObject();
      uint64_t v13 = sub_183D4432C();
      swift_release();
      uint64_t v9 = v13;
      uint64_t v11 = v4 >> 32;
LABEL_16:
      if (v11 < (int)v4)
      {
        __break(1u);
LABEL_23:
        __break(1u);
LABEL_24:
        __break(1u);
      }
      uint64_t result = sub_1834D6D58((int)v4, v11, a1);
      unint64_t v12 = v9 | 0x4000000000000000;
      if (v2)
      {
        uint64_t *v5 = v4;
        goto LABEL_19;
      }
      uint64_t *v5 = v4;
      v5[1] = v12;
      break;
    case 2uLL:
      uint64_t v14 = *v1;
      uint64_t v15 = v3 & 0x3FFFFFFFFFFFFFFFLL;
      sub_183D4448C();
      uint64_t result = sub_1834D6D58(*(void *)(v14 + 16), *(void *)(v14 + 24), a1);
      unint64_t v12 = v15 | 0x8000000000000000;
      if (v2)
      {
        uint64_t *v1 = v14;
LABEL_19:
        v5[1] = v12;
      }
      else
      {
        uint64_t *v1 = v14;
        v1[1] = v12;
      }
      break;
    case 3uLL:
      memset(v16, 0, 15);
      uint64_t result = (char *)a1(&v14, (char *)v16, (char *)v16);
      if (!v2) {
        return (char *)v14;
      }
      return result;
    default:
      v16[0] = *v1;
      LOWORD(v16[1]) = v3;
      BYTE2(v16[1]) = BYTE2(v3);
      BYTE3(v16[1]) = BYTE3(v3);
      BYTE4(v16[1]) = BYTE4(v3);
      BYTE5(v16[1]) = BYTE5(v3);
      BYTE6(v16[1]) = BYTE6(v3);
      uint64_t result = (char *)a1(&v14, (char *)v16, (char *)v16 + BYTE6(v3));
      if (!v2) {
        uint64_t result = (char *)v14;
      }
      unint64_t v8 = LODWORD(v16[1]) | ((unint64_t)BYTE4(v16[1]) << 32) | ((unint64_t)BYTE5(v16[1]) << 40) | ((unint64_t)BYTE6(v16[1]) << 48);
      uint64_t *v1 = v16[0];
      v1[1] = v8;
      return result;
  }
  return result;
}

unsigned char *sub_1834D6C70@<X0>(unsigned char *result@<X0>, unsigned char *a2@<X1>, void *a3@<X8>)
{
  if (!result) {
    goto LABEL_4;
  }
  uint64_t v4 = a2 - result;
  if (a2 == result)
  {
    uint64_t result = 0;
LABEL_4:
    unint64_t v5 = 0xC000000000000000;
    goto LABEL_5;
  }
  if (v4 <= 14)
  {
    uint64_t result = (unsigned char *)sub_1834D7CD4(result, a2);
    unint64_t v5 = v7 & 0xFFFFFFFFFFFFFFLL;
  }
  else if ((unint64_t)v4 >= 0x7FFFFFFF)
  {
    uint64_t result = (unsigned char *)sub_1834D7D98((uint64_t)result, (uint64_t)a2);
    unint64_t v5 = v8 | 0x8000000000000000;
  }
  else
  {
    uint64_t result = (unsigned char *)sub_1834D7E14((uint64_t)result, (uint64_t)a2);
    unint64_t v5 = v6 | 0x4000000000000000;
  }
LABEL_5:
  *a3 = result;
  a3[1] = v5;
  return result;
}

void *sub_1834D6CE8(void *(*a1)(uint64_t *__return_ptr, uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    uint64_t result = a1(&v6, a3, a4 - a3);
    if (v4) {
      return result;
    }
    return (void *)v6;
  }
  uint64_t result = a1(&v6, 0, 0);
  if (!v4) {
    return (void *)v6;
  }
  return result;
}

char *sub_1834D6D58(uint64_t a1, uint64_t a2, void *(*a3)(uint64_t *__return_ptr, char *, char *))
{
  uint64_t result = (char *)sub_183D4434C();
  if (!result) {
    goto LABEL_12;
  }
  uint64_t v8 = result;
  uint64_t result = (char *)sub_183D4437C();
  uint64_t v9 = a1 - (void)result;
  if (__OFSUB__(a1, result))
  {
    __break(1u);
    goto LABEL_11;
  }
  BOOL v10 = __OFSUB__(a2, a1);
  uint64_t v11 = a2 - a1;
  if (v10)
  {
LABEL_11:
    __break(1u);
LABEL_12:
    __break(1u);
    return result;
  }
  uint64_t v12 = sub_183D4436C();
  if (v12 >= v11) {
    uint64_t v13 = v11;
  }
  else {
    uint64_t v13 = v12;
  }
  uint64_t result = (char *)a3(&v14, &v8[v9], &v8[v9 + v13]);
  if (!v3) {
    return (char *)v14;
  }
  return result;
}

uint64_t sub_1834D6E0C(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, unint64_t a8)
{
  uint64_t result = sub_183D4434C();
  uint64_t v15 = (const uint8_t *)result;
  if (result)
  {
    uint64_t result = sub_183D4437C();
    if (__OFSUB__(a1, result))
    {
LABEL_13:
      __break(1u);
      return result;
    }
    v15 += a1 - result;
  }
  BOOL v16 = __OFSUB__(a2, a1);
  uint64_t v17 = a2 - a1;
  if (v16)
  {
    __break(1u);
    goto LABEL_13;
  }
  uint64_t v18 = sub_183D4436C();
  if (v18 >= v17) {
    uint64_t v19 = v17;
  }
  else {
    uint64_t v19 = v18;
  }
  uint64_t v20 = &v15[v19];
  if (v15) {
    uint64_t v21 = (uint64_t)v20;
  }
  else {
    uint64_t v21 = 0;
  }
  sub_1834D1650(v15, v21, a4, a5, a6, a7, a8);
  swift_bridgeObjectRelease();
  swift_unknownObjectRelease();
  return sub_1832E5E9C(a7, a8);
}

uint64_t sub_1834D6F00@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  if (result)
  {
    swift_bridgeObjectRetain();
    uint64_t result = sub_183D4548C();
    if ((v3 & 1) == 0)
    {
      uint64_t v4 = result;
      uint64_t result = swift_bridgeObjectRelease();
      *a2 = 0;
      a2[1] = 0xE000000000000000;
      a2[2] = 15;
      a2[3] = v4;
      return result;
    }
  }
  else
  {
    __break(1u);
  }
  __break(1u);
  return result;
}

uint64_t _s7Network11IPv4AddressV2eeoiySbAC_ACtFZ_0(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a1 == *(_DWORD *)a2)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(a2 + 8);
    if (v2 == 1)
    {
      if (v3 == 1) {
        return v3 & 1;
      }
    }
    else
    {
      nw_interface_t v6 = *(nw_interface_t *)(a1 + 8);
      if (v3 != 1)
      {
        uint64_t v5 = v3;
        sub_18315E9D4(v2);
        swift_unknownObjectRetain();
        LOBYTE(v3) = _s7Network11NWInterfaceV2eeoiySbAC_ACtFZ_0(&v6, (nw_interface_t *)&v5);
        swift_unknownObjectRelease();
        sub_18315E51C(v2);
        return v3 & 1;
      }
      swift_unknownObjectRetain();
    }
    sub_18315E9D4(v3);
    sub_18315E51C(v2);
    sub_18315E51C(v3);
  }
  LOBYTE(v3) = 0;
  return v3 & 1;
}

uint64_t _s7Network11IPv6AddressV2eeoiySbAC_ACtFZ_0(void *a1, void *a2)
{
  if (a1[1] == a2[1] && *a1 == *a2)
  {
    uint64_t v3 = a1[2];
    uint64_t v4 = a2[2];
    if (v3 == 1)
    {
      if (v4 == 1) {
        return v4 & 1;
      }
    }
    else
    {
      nw_interface_t v7 = (nw_interface_t)a1[2];
      if (v4 != 1)
      {
        uint64_t v6 = v4;
        sub_18315E9D4(v3);
        swift_unknownObjectRetain();
        LOBYTE(v4) = _s7Network11NWInterfaceV2eeoiySbAC_ACtFZ_0(&v7, (nw_interface_t *)&v6);
        swift_unknownObjectRelease();
        sub_18315E51C(v3);
        return v4 & 1;
      }
      swift_unknownObjectRetain();
    }
    sub_18315E9D4(v4);
    sub_18315E51C(v3);
    sub_18315E51C(v4);
  }
  LOBYTE(v4) = 0;
  return v4 & 1;
}

uint64_t _s7Network10NWEndpointO4HostO2eeoiySbAE_AEtFZ_0(uint64_t a1, uint64_t a2)
{
  nw_interface_t v3 = *(nw_interface_t *)a1;
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v4 = *(NSObject **)(a1 + 16);
  int v5 = *(unsigned __int8 *)(a1 + 24);
  nw_interface_t v7 = *(NSObject **)a2;
  uint64_t v6 = *(void *)(a2 + 8);
  uint64_t v8 = *(NSObject **)(a2 + 16);
  int v9 = *(unsigned __int8 *)(a2 + 24);
  if (!*(unsigned char *)(a1 + 24))
  {
    if (!*(unsigned char *)(a2 + 24))
    {
      BOOL v11 = v3 == v7 && v2 == v6;
      if (v11 || (sub_183D4592C() & 1) != 0)
      {
        if (v4 == 1)
        {
          sub_18315E9D4((uint64_t)v8);
          sub_18315E9E4((uint64_t)v7, v6, (uint64_t)v8, 0);
          char v10 = 1;
          sub_18315E9E4((uint64_t)v3, v2, 1, 0);
          sub_18315E658((uint64_t)v3, v2, 1, 0);
          sub_18315E658((uint64_t)v7, v6, (uint64_t)v8, 0);
          if (v8 == 1) {
            return v10 & 1;
          }
        }
        else
        {
          nw_interface_t v21 = v4;
          if (v8 != 1)
          {
            nw_interface_t v18 = v8;
            sub_18315E9D4((uint64_t)v4);
            sub_18315E9D4((uint64_t)v8);
            sub_18315E9D4((uint64_t)v4);
            sub_18315E9D4((uint64_t)v8);
            sub_18315E9E4((uint64_t)v7, v6, (uint64_t)v8, 0);
            sub_18315E9E4((uint64_t)v3, v2, (uint64_t)v4, 0);
            sub_18315E9D4((uint64_t)v4);
            char v17 = _s7Network11NWInterfaceV2eeoiySbAC_ACtFZ_0(&v21, &v18);
            sub_18315E658((uint64_t)v3, v2, (uint64_t)v4, 0);
            sub_18315E658((uint64_t)v7, v6, (uint64_t)v8, 0);
            sub_18315E51C((uint64_t)v8);
            sub_18315E51C((uint64_t)v4);
            sub_18315E51C((uint64_t)v8);
            swift_unknownObjectRelease();
            sub_18315E51C((uint64_t)v4);
            if (v17)
            {
              char v10 = 1;
              return v10 & 1;
            }
            goto LABEL_18;
          }
          sub_18315E9D4((uint64_t)v4);
          sub_18315E9E4((uint64_t)v7, v6, 1, 0);
          sub_18315E9E4((uint64_t)v3, v2, (uint64_t)v4, 0);
          sub_18315E9D4((uint64_t)v4);
          sub_18315E658((uint64_t)v3, v2, (uint64_t)v4, 0);
          sub_18315E658((uint64_t)v7, v6, 1, 0);
          swift_unknownObjectRelease();
        }
        sub_18315E51C((uint64_t)v4);
        sub_18315E51C((uint64_t)v8);
LABEL_18:
        char v10 = 0;
        return v10 & 1;
      }
      sub_18315E9E4((uint64_t)v7, v6, (uint64_t)v8, 0);
      sub_18315E9E4((uint64_t)v3, v2, (uint64_t)v4, 0);
      sub_18315E658((uint64_t)v3, v2, (uint64_t)v4, 0);
      uint64_t v12 = (uint64_t)v7;
      uint64_t v13 = v6;
      uint64_t v14 = (uint64_t)v8;
      char v15 = 0;
LABEL_17:
      sub_18315E658(v12, v13, v14, v15);
      goto LABEL_18;
    }
    goto LABEL_16;
  }
  if (v5 != 1)
  {
    if (v9 == 2)
    {
      nw_interface_t v21 = *(nw_interface_t *)a1;
      uint64_t v22 = v2;
      char v23 = v4;
      nw_interface_t v18 = v7;
      uint64_t v19 = v6;
      uint64_t v20 = v8;
      sub_18315E9E4((uint64_t)v7, v6, (uint64_t)v8, 2);
      sub_18315E9E4((uint64_t)v3, v2, (uint64_t)v4, 2);
      sub_18315E9E4((uint64_t)v7, v6, (uint64_t)v8, 2);
      sub_18315E9E4((uint64_t)v3, v2, (uint64_t)v4, 2);
      char v10 = _s7Network11IPv6AddressV2eeoiySbAC_ACtFZ_0(&v21, &v18);
      sub_18315E658((uint64_t)v3, v2, (uint64_t)v4, 2);
      sub_18315E658((uint64_t)v7, v6, (uint64_t)v8, 2);
      sub_18315E658((uint64_t)v7, v6, (uint64_t)v8, 2);
      sub_18315E658((uint64_t)v3, v2, (uint64_t)v4, 2);
      return v10 & 1;
    }
    goto LABEL_16;
  }
  if (v9 != 1)
  {
LABEL_16:
    sub_18315E9E4(*(void *)a2, *(void *)(a2 + 8), (uint64_t)v8, v9);
    sub_18315E9E4((uint64_t)v3, v2, (uint64_t)v4, v5);
    sub_18315E658((uint64_t)v3, v2, (uint64_t)v4, v5);
    uint64_t v12 = (uint64_t)v7;
    uint64_t v13 = v6;
    uint64_t v14 = (uint64_t)v8;
    char v15 = v9;
    goto LABEL_17;
  }
  LODWORD(v21) = *(void *)a1;
  uint64_t v22 = v2;
  LODWORD(v18) = v7;
  uint64_t v19 = v6;
  sub_18315E9E4((uint64_t)v7, v6, (uint64_t)v8, 1);
  sub_18315E9E4((uint64_t)v3, v2, (uint64_t)v4, 1);
  sub_18315E9E4((uint64_t)v7, v6, (uint64_t)v8, 1);
  sub_18315E9E4((uint64_t)v3, v2, (uint64_t)v4, 1);
  char v10 = _s7Network11IPv4AddressV2eeoiySbAC_ACtFZ_0((uint64_t)&v21, (uint64_t)&v18);
  sub_18315E658((uint64_t)v3, v2, (uint64_t)v4, 1);
  sub_18315E658((uint64_t)v7, v6, (uint64_t)v8, 1);
  sub_18315E658((uint64_t)v7, v6, (uint64_t)v8, 1);
  sub_18315E658((uint64_t)v3, v2, (uint64_t)v4, 1);
  return v10 & 1;
}

uint64_t _s7Network10NWEndpointO2eeoiySbAC_ACtFZ_0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_183D4447C();
  uint64_t v79 = *(void *)(v4 - 8);
  char v80 = v4;
  uint64_t v5 = MEMORY[0x1F4188790](v4);
  char v78 = ((char *)&v75 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1F4188790](v5);
  uint64_t v8 = (char *)&v75 - v7;
  uint64_t v9 = type metadata accessor for NWEndpoint();
  uint64_t v10 = MEMORY[0x1F4188790](v9);
  uint64_t v12 = (void **)((char *)&v75 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  char v15 = (char *)&v75 - v14;
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  nw_interface_t v18 = (uint64_t *)((char *)&v75 - v17);
  uint64_t v19 = MEMORY[0x1F4188790](v16);
  nw_interface_t v21 = (uint64_t *)((char *)&v75 - v20);
  MEMORY[0x1F4188790](v19);
  char v23 = (char *)&v75 - v22;
  uint64_t v24 = __swift_instantiateConcreteTypeFromMangledName(qword_1E8F61A80);
  uint64_t v25 = MEMORY[0x1F4188790](v24 - 8);
  char v27 = (char *)&v75 + *(int *)(v25 + 56) - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v28 = a1;
  uint64_t v29 = ((char *)&v75 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0));
  sub_1834D7F00(v28, (uint64_t)v29);
  sub_1834D7F00(a2, (uint64_t)v27);
  switch(swift_getEnumCaseMultiPayload())
  {
    case 1u:
      unint64_t v34 = v29;
      sub_1834D7F00((uint64_t)v29, (uint64_t)v21);
      uint64_t v36 = *v21;
      uint64_t v35 = v21[1];
      uint64_t v38 = v21[2];
      uint64_t v37 = v21[3];
      uint64_t v40 = v21[4];
      uint64_t v39 = v21[5];
      uint64_t v41 = v21[6];
      if (swift_getEnumCaseMultiPayload() != 1)
      {
        sub_18315E51C(v41);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        uint64_t v29 = v34;
        goto LABEL_25;
      }
      uint64_t v77 = v40;
      char v80 = v41;
      uint64_t v42 = *(void *)v27;
      uint64_t v43 = *((void *)v27 + 1);
      uint64_t v44 = *((void *)v27 + 2);
      uint64_t v45 = *((void *)v27 + 3);
      uint64_t v46 = *((void *)v27 + 4);
      uint64_t v47 = *((void *)v27 + 5);
      char v78 = *((void *)v27 + 6);
      uint64_t v79 = v47;
      BOOL v48 = v36 == v42 && v35 == v43;
      uint64_t v76 = v46;
      if (v48)
      {
        swift_bridgeObjectRelease_n();
      }
      else
      {
        char v49 = sub_183D4592C();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        if ((v49 & 1) == 0)
        {
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
LABEL_33:
          uint64_t v69 = v78;
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
          sub_18315E51C((uint64_t)v69);
          uint64_t v70 = (uint64_t)v80;
          goto LABEL_48;
        }
      }
      if (v38 == v44 && v37 == v45)
      {
        swift_bridgeObjectRelease_n();
      }
      else
      {
        char v68 = sub_183D4592C();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        if ((v68 & 1) == 0) {
          goto LABEL_33;
        }
      }
      uint64_t v71 = v80;
      if (v77 == v76 && v39 == v79)
      {
        swift_bridgeObjectRelease_n();
      }
      else
      {
        char v72 = sub_183D4592C();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        if ((v72 & 1) == 0)
        {
          sub_18315E51C((uint64_t)v78);
          uint64_t v70 = (uint64_t)v71;
          goto LABEL_48;
        }
      }
      uint64_t v73 = v78;
      if (v71 == 1)
      {
        if (v78 == 1)
        {
          unsigned __int8 v53 = 1;
LABEL_49:
          uint64_t v66 = (uint64_t)v34;
          goto LABEL_50;
        }
      }
      else
      {
        v83[0] = v71;
        if (v78 != 1)
        {
          v81[0] = v78;
          swift_unknownObjectRetain();
          unsigned __int8 v53 = _s7Network11NWInterfaceV2eeoiySbAC_ACtFZ_0(v83, v81);
          sub_18315E51C((uint64_t)v73);
          swift_unknownObjectRelease();
          sub_18315E51C((uint64_t)v71);
          goto LABEL_49;
        }
      }
      sub_18315E51C((uint64_t)v71);
      uint64_t v70 = (uint64_t)v73;
LABEL_48:
      sub_18315E51C(v70);
      unsigned __int8 v53 = 0;
      goto LABEL_49;
    case 2u:
      sub_1834D7F00((uint64_t)v29, (uint64_t)v18);
      uint64_t v51 = *v18;
      uint64_t v50 = v18[1];
      if (swift_getEnumCaseMultiPayload() != 2)
      {
        swift_bridgeObjectRelease();
        goto LABEL_25;
      }
      if (v51 == *(void *)v27 && v50 == *((void *)v27 + 1)) {
        unsigned __int8 v53 = 1;
      }
      else {
        unsigned __int8 v53 = sub_183D4592C();
      }
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      goto LABEL_36;
    case 3u:
      sub_1834D7F00((uint64_t)v29, (uint64_t)v15);
      if (swift_getEnumCaseMultiPayload() == 3)
      {
        uint64_t v55 = v79;
        uint64_t v54 = v80;
        uint64_t v56 = *(void (**)(char *, char *, NSObject *))(v79 + 32);
        v56(v8, v15, v80);
        uint64_t v57 = v78;
        v56((char *)v78, v27, v54);
        unsigned __int8 v53 = MEMORY[0x185313800](v8, v57);
        char v58 = *(void (**)(NSObject *, NSObject *))(v55 + 8);
        v58(v57, v54);
        v58(v8, v54);
        goto LABEL_36;
      }
      (*(void (**)(char *, NSObject *))(v79 + 8))(v15, v80);
      goto LABEL_25;
    case 4u:
      sub_1834D7F00((uint64_t)v29, (uint64_t)v12);
      char v59 = *v12;
      if (swift_getEnumCaseMultiPayload() != 4)
      {
        swift_unknownObjectRelease();
        goto LABEL_25;
      }
      unsigned __int8 v53 = objc_msgSend(v59, sel_isEqual_, *(void *)v27);
      swift_unknownObjectRelease();
      swift_unknownObjectRelease();
LABEL_36:
      uint64_t v66 = (uint64_t)v29;
      goto LABEL_50;
    default:
      sub_1834D7F00((uint64_t)v29, (uint64_t)v23);
      uint64_t v31 = *(NSObject **)v23;
      int v30 = *((void *)v23 + 1);
      unint64_t v32 = *((void *)v23 + 2);
      char v33 = v23[24];
      if (swift_getEnumCaseMultiPayload())
      {
        sub_18315E658((uint64_t)v31, (uint64_t)v30, (uint64_t)v32, v33);
LABEL_25:
        sub_183138A24((uint64_t)v29, qword_1E8F61A80);
        unsigned __int8 v53 = 0;
      }
      else
      {
        LODWORD(v79) = *((unsigned __int16 *)v23 + 13);
        uint64_t v60 = *(NSObject **)v27;
        char v61 = *((void *)v27 + 1);
        char v80 = v29;
        v81[0] = v60;
        uint64_t v62 = *((void *)v27 + 2);
        int v63 = *((unsigned __int16 *)v27 + 13);
        char v64 = v27[24];
        v83[0] = v31;
        v83[1] = v30;
        v83[2] = v32;
        char v84 = v33;
        v81[1] = v61;
        v81[2] = v62;
        char v82 = v64;
        char v65 = _s7Network10NWEndpointO4HostO2eeoiySbAE_AEtFZ_0((uint64_t)v83, (uint64_t)v81);
        sub_18315E658((uint64_t)v60, (uint64_t)v61, (uint64_t)v62, v64);
        sub_18315E658((uint64_t)v31, (uint64_t)v30, (uint64_t)v32, v33);
        unsigned __int8 v53 = v65 & (v79 == v63);
        uint64_t v66 = (uint64_t)v80;
LABEL_50:
        sub_1834D7F64(v66);
      }
      return v53 & 1;
  }
}

BOOL _s7Network15EthernetAddressV2eeoiySbAC_ACtFZ_0(uint64_t a1, uint64_t a2, uint8x8_t a3, uint8x8_t a4)
{
  BOOL result = 0;
  a3.i32[0] = *(_DWORD *)a1;
  a4.i32[0] = *(_DWORD *)a2;
  if ((vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vceq_s16((int16x4_t)*(_OWORD *)&vmovl_u8(a3), (int16x4_t)*(_OWORD *)&vmovl_u8(a4)), 0xFuLL))) & 1) != 0&& *(unsigned __int8 *)(a1 + 4) == *(unsigned __int8 *)(a2 + 4))
  {
    return *(unsigned __int8 *)(a1 + 5) == *(unsigned __int8 *)(a2 + 5);
  }
  return result;
}

uint64_t sub_1834D7CD4(unsigned char *__src, unsigned char *a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (__src) {
    unint64_t v2 = a2 - __src;
  }
  else {
    unint64_t v2 = 0;
  }
  if ((v2 & 0x8000000000000000) != 0)
  {
    __break(1u);
LABEL_11:
    __break(1u);
  }
  if (v2 > 0xFF) {
    goto LABEL_11;
  }
  memset(__dst, 0, sizeof(__dst));
  char v5 = v2;
  if (__src && a2 != __src) {
    memcpy(__dst, __src, a2 - __src);
  }
  return *(void *)__dst;
}

uint64_t sub_1834D7D98(uint64_t a1, uint64_t a2)
{
  if (a1) {
    uint64_t v2 = a2 - a1;
  }
  else {
    uint64_t v2 = 0;
  }
  sub_183D4439C();
  swift_allocObject();
  uint64_t result = sub_183D4433C();
  if (v2 < 0)
  {
    __break(1u);
  }
  else
  {
    sub_183D444DC();
    uint64_t result = swift_allocObject();
    *(void *)(result + 16) = 0;
    *(void *)(result + 24) = v2;
  }
  return result;
}

uint64_t sub_1834D7E14(uint64_t a1, uint64_t a2)
{
  if (a1) {
    uint64_t v2 = a2 - a1;
  }
  else {
    uint64_t v2 = 0;
  }
  sub_183D4439C();
  swift_allocObject();
  uint64_t result = sub_183D4433C();
  if (v2 < (uint64_t)0xFFFFFFFF80000000)
  {
    __break(1u);
    goto LABEL_9;
  }
  if (v2 > 0x7FFFFFFF)
  {
LABEL_9:
    __break(1u);
    goto LABEL_10;
  }
  if ((v2 & 0x80000000) == 0) {
    return v2 << 32;
  }
LABEL_10:
  __break(1u);
  return result;
}

void sub_1834D7E98(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  if (a4 != -1) {
    sub_18315E658(a1, a2, a3, a4);
  }
}

unint64_t sub_1834D7EAC()
{
  unint64_t result = qword_1E8F61DF0;
  if (!qword_1E8F61DF0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F61DF0);
  }
  return result;
}

uint64_t sub_1834D7F00(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = type metadata accessor for NWEndpoint();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16))(a2, a1, v4);
  return a2;
}

uint64_t sub_1834D7F64(uint64_t a1)
{
  uint64_t v2 = type metadata accessor for NWEndpoint();
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v2 - 8) + 8))(a1, v2);
  return a1;
}

uint64_t sub_1834D7FC0()
{
  swift_bridgeObjectRelease();

  return swift_deallocObject();
}

uint64_t sub_1834D7FF8(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60 != 15) {
    return sub_1832E5D6C(a1, a2);
  }
  return a1;
}

uint64_t sub_1834D800C()
{
  unint64_t v1 = *(void *)(v0 + 24);
  if (v1 >> 60 != 15) {
    sub_1832E5E9C(*(void *)(v0 + 16), v1);
  }

  return swift_deallocObject();
}

uint64_t sub_1834D8054(unsigned char *a1, uint64_t a2)
{
  return sub_1834D1904(a1, a2, v2);
}

uint64_t sub_1834D805C()
{
  return swift_deallocObject();
}

uint64_t sub_1834D806C(uint64_t a1, uint64_t a2)
{
  return sub_1834D252C(a1, a2, *(unint64_t **)(v2 + 16));
}

uint64_t sub_1834D8074()
{
  return swift_deallocObject();
}

uint64_t sub_1834D8084()
{
  return (*(uint64_t (**)(void))(v0 + 16))() & 1;
}

uint64_t sub_1834D80B0()
{
  return swift_deallocObject();
}

uint64_t sub_1834D80C0()
{
  return swift_deallocObject();
}

unsigned char *sub_1834D80D0(unsigned char *result, unsigned char *a2)
{
  if (result)
  {
    uint64_t v2 = a2 - result;
    if (a2 == result)
    {
      return 0;
    }
    else if (v2 <= 14)
    {
      return (unsigned char *)sub_1834D7CD4(result, a2);
    }
    else if ((unint64_t)v2 >= 0x7FFFFFFF)
    {
      return (unsigned char *)sub_1834D7D98((uint64_t)result, (uint64_t)a2);
    }
    else
    {
      return (unsigned char *)sub_1834D7E14((uint64_t)result, (uint64_t)a2);
    }
  }
  return result;
}

uint64_t sub_1834D8134(uint64_t result)
{
  if (result)
  {
    unint64_t v1 = result;
    if (result <= 14)
    {
      if (result < 0) {
        __break(1u);
      }
      else {
        return 0;
      }
    }
    else
    {
      sub_183D4439C();
      swift_allocObject();
      sub_183D4435C();
      if (v1 >= 0x7FFFFFFF)
      {
        sub_183D444DC();
        unint64_t result = swift_allocObject();
        *(void *)(result + 16) = 0;
        *(void *)(result + 24) = v1;
      }
      else
      {
        return v1 << 32;
      }
    }
  }
  return result;
}

uint64_t sub_1834D81D4(uint64_t a1)
{
  uint64_t v9 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F62E50);
  unint64_t v10 = sub_1834D999C();
  v8[0] = a1;
  uint64_t v2 = __swift_project_boxed_opaque_existential_2(v8, v9);
  nw_interface_t v3 = (unsigned char *)(*v2 + 32);
  uint64_t v4 = &v3[*(void *)(*v2 + 16)];
  swift_bridgeObjectRetain();
  sub_1834D6C70(v3, v4, &v7);
  uint64_t v5 = v7;
  __swift_destroy_boxed_opaque_existential_2((uint64_t)v8);
  return v5;
}

uint64_t sub_1834D8270(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    uint64_t v2 = result;
    int v3 = *(unsigned __int8 *)(result + 32);
    result += 32;
    if (!v3) {
      return sub_183D44C1C();
    }
    uint64_t v4 = 0;
    uint64_t v5 = v1 - 1;
    uint64_t v6 = v2 + 33;
    while (v5 != v4)
    {
      if (!*(unsigned __int8 *)(v6 + v4++)) {
        return sub_183D44C1C();
      }
    }
    __break(1u);
  }
  __break(1u);
  return result;
}

unint64_t sub_1834D82BC()
{
  unint64_t result = qword_1E8F62DE8;
  if (!qword_1E8F62DE8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F62DE8);
  }
  return result;
}

unint64_t sub_1834D8314()
{
  unint64_t result = qword_1E8F62DF0;
  if (!qword_1E8F62DF0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F62DF0);
  }
  return result;
}

unint64_t sub_1834D836C()
{
  unint64_t result = qword_1E8F62DF8;
  if (!qword_1E8F62DF8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F62DF8);
  }
  return result;
}

unint64_t sub_1834D83C4()
{
  unint64_t result = qword_1E8F62E00;
  if (!qword_1E8F62E00)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F62E00);
  }
  return result;
}

unint64_t sub_1834D841C()
{
  unint64_t result = qword_1E8F62E08;
  if (!qword_1E8F62E08)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F62E08);
  }
  return result;
}

unint64_t sub_1834D8474()
{
  unint64_t result = qword_1E8F62E10;
  if (!qword_1E8F62E10)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F62E10);
  }
  return result;
}

uint64_t sub_1834D84C8()
{
  return MEMORY[0x1E4FBB220];
}

unint64_t sub_1834D84D8()
{
  unint64_t result = qword_1E8F62E18;
  if (!qword_1E8F62E18)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F62E18);
  }
  return result;
}

uint64_t sub_1834D852C()
{
  return MEMORY[0x1E4FBB230];
}

uint64_t sub_1834D8538()
{
  return MEMORY[0x1E4FBB228];
}

unint64_t sub_1834D8548()
{
  unint64_t result = qword_1E8F62E20;
  if (!qword_1E8F62E20)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F62E20);
  }
  return result;
}

uint64_t sub_1834D859C()
{
  return MEMORY[0x1E4FBC4B0];
}

unint64_t sub_1834D85AC()
{
  unint64_t result = qword_1E8F62E28;
  if (!qword_1E8F62E28)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F62E28);
  }
  return result;
}

uint64_t sub_1834D8600()
{
  return sub_1834D8648((unint64_t *)&unk_1E8F62E30, (void (*)(uint64_t))type metadata accessor for NWEndpoint);
}

uint64_t sub_1834D8648(unint64_t *a1, void (*a2)(uint64_t))
{
  uint64_t result = *a1;
  if (!result)
  {
    a2(255);
    uint64_t result = swift_getWitnessTable();
    atomic_store(result, a1);
  }
  return result;
}

uint64_t sub_1834D8690@<X0>(uint64_t a1@<X8>)
{
  return NWEndpoint.echConfig.getter(a1);
}

uint64_t sub_1834D86B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1834D5860(a1, a2, a3, a4, (uint64_t *)&unk_1E8F62DC0, (uint64_t (*)(char *))NWEndpoint.echConfig.setter);
}

uint64_t sub_1834D86E8@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result = NWEndpoint.alternatives.getter();
  *a1 = result;
  return result;
}

uint64_t sub_1834D8714()
{
  uint64_t v0 = swift_bridgeObjectRetain();
  return NWEndpoint.alternatives.setter(v0);
}

uint64_t sub_1834D8748@<X0>(uint64_t a1@<X8>)
{
  return NWEndpoint.agentIdentifier.getter(a1);
}

uint64_t sub_1834D876C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1834D5860(a1, a2, a3, a4, &qword_1E8F62DD0, (uint64_t (*)(char *))NWEndpoint.agentIdentifier.setter);
}

uint64_t sub_1834D87A0@<X0>(unsigned char *a1@<X8>)
{
  uint64_t result = NWEndpoint.remoteInterfaceType.getter(&v3);
  *a1 = v3;
  return result;
}

uint64_t sub_1834D87E0@<X0>(uint64_t a1@<X8>)
{
  return NWEndpoint.serviceIdentifier.getter(a1);
}

uint64_t sub_1834D8804(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1834D5860(a1, a2, a3, a4, &qword_1E8F62DD0, (uint64_t (*)(char *))NWEndpoint.serviceIdentifier.setter);
}

uint64_t sub_1834D8838@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result = NWEndpoint.publicKeys.getter();
  *a1 = result;
  return result;
}

uint64_t sub_1834D8868@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result = NWEndpoint.deviceName.getter();
  *a1 = result;
  a1[1] = v3;
  return result;
}

uint64_t sub_1834D8894(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return keypath_set_44Tm(a1, a2, a3, a4, NWEndpoint.deviceName.setter);
}

uint64_t sub_1834D88AC@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result = NWEndpoint.deviceModel.getter();
  *a1 = result;
  a1[1] = v3;
  return result;
}

uint64_t sub_1834D88D8(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return keypath_set_44Tm(a1, a2, a3, a4, NWEndpoint.deviceModel.setter);
}

uint64_t keypath_set_44Tm(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t))
{
  uint64_t v6 = *a1;
  uint64_t v7 = a1[1];
  swift_bridgeObjectRetain();
  return a5(v6, v7);
}

uint64_t sub_1834D8940@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result = NWEndpoint.deviceID.getter();
  *a1 = result;
  a1[1] = v3;
  return result;
}

uint64_t sub_1834D896C(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return keypath_set_44Tm(a1, a2, a3, a4, NWEndpoint.deviceID.setter);
}

uint64_t sub_1834D8984@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result = NWEndpoint.contactID.getter();
  *a1 = result;
  a1[1] = v3;
  return result;
}

uint64_t sub_1834D89B0(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return keypath_set_44Tm(a1, a2, a3, a4, NWEndpoint.contactID.setter);
}

uint64_t sub_1834D89C8@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result = NWEndpoint.applicationService.getter();
  *a1 = result;
  a1[1] = v3;
  return result;
}

uint64_t sub_1834D89F4(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return keypath_set_44Tm(a1, a2, a3, a4, NWEndpoint.applicationService.setter);
}

uint64_t sub_1834D8A0C@<X0>(uint64_t a1@<X8>)
{
  return NWEndpoint.serviceID.getter(a1);
}

uint64_t sub_1834D8A30(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1834D5860(a1, a2, a3, a4, &qword_1E8F62DD0, (uint64_t (*)(char *))NWEndpoint.serviceID.setter);
}

uint64_t dispatch thunk of IPAddress.rawValue.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of IPAddress.init(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 16))();
}

uint64_t dispatch thunk of IPAddress.init(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 24))();
}

uint64_t dispatch thunk of IPAddress.interface.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

uint64_t dispatch thunk of IPAddress.isLoopback.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 40))();
}

uint64_t dispatch thunk of IPAddress.isLinkLocal.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 48))();
}

uint64_t dispatch thunk of IPAddress.isMulticast.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 56))();
}

uint64_t destroy for IPv4Address(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result != 1) {
    return swift_unknownObjectRelease();
  }
  return result;
}

uint64_t _s7Network11IPv4AddressVwCP_0(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 != 1) {
    uint64_t v3 = swift_unknownObjectRetain();
  }
  *(void *)(a1 + 8) = v3;
  return a1;
}

uint64_t assignWithCopy for IPv4Address(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  uint64_t v3 = (uint64_t *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a2 + 8);
  if (v4 == 1)
  {
    if (v5 != 1)
    {
      *uint64_t v3 = v5;
      swift_unknownObjectRetain();
      return a1;
    }
    uint64_t v6 = 1;
  }
  else
  {
    if (v5 != 1)
    {
      *uint64_t v3 = v5;
      swift_unknownObjectRetain();
      swift_unknownObjectRelease();
      return a1;
    }
    sub_1834D8BDC((uint64_t)v3);
    uint64_t v6 = *(void *)(a2 + 8);
  }
  *uint64_t v3 = v6;
  return a1;
}

uint64_t sub_1834D8BDC(uint64_t a1)
{
  return a1;
}

uint64_t assignWithTake for IPv4Address(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  uint64_t v3 = (uint64_t *)(a1 + 8);
  uint64_t v4 = *(void *)(a2 + 8);
  if (*(void *)(a1 + 8) != 1)
  {
    if (v4 != 1)
    {
      *uint64_t v3 = v4;
      swift_unknownObjectRelease();
      return a1;
    }
    sub_1834D8BDC((uint64_t)v3);
    uint64_t v4 = 1;
  }
  *uint64_t v3 = v4;
  return a1;
}

uint64_t getEnumTagSinglePayload for IPv4Address(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 > 0x7FFFFFFD && *(unsigned char *)(a1 + 16)) {
    return (*(_DWORD *)a1 + 2147483646);
  }
  unint64_t v3 = *(void *)(a1 + 8);
  if (v3 >= 0xFFFFFFFF) {
    LODWORD(v3) = -1;
  }
  int v4 = v3 - 1;
  if (v4 < 0) {
    int v4 = -1;
  }
  BOOL v5 = __OFSUB__(v4, 1);
  int v6 = v4 - 1;
  if (v6 < 0 != v5) {
    int v6 = -1;
  }
  return (v6 + 1);
}

uint64_t storeEnumTagSinglePayload for IPv4Address(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0x7FFFFFFD)
  {
    *(void *)uint64_t result = a2 - 2147483646;
    *(void *)(result + 8) = 0;
    if (a3 > 0x7FFFFFFD) {
      *(unsigned char *)(result + 16) = 1;
    }
  }
  else
  {
    if (a3 > 0x7FFFFFFD) {
      *(unsigned char *)(result + 16) = 0;
    }
    if (a2) {
      *(void *)(result + 8) = a2 + 1;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for IPv4Address()
{
  return &type metadata for IPv4Address;
}

uint64_t destroy for IPv6Address(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result != 1) {
    return swift_unknownObjectRelease();
  }
  return result;
}

uint64_t _s7Network11IPv6AddressVwCP_0(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  if (v3 != 1) {
    uint64_t v3 = swift_unknownObjectRetain();
  }
  *(void *)(a1 + 16) = v3;
  return a1;
}

void *assignWithCopy for IPv6Address(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  int v4 = a1 + 2;
  uint64_t v5 = a1[2];
  uint64_t v6 = a2[2];
  if (v5 == 1)
  {
    if (v6 != 1)
    {
      *int v4 = v6;
      swift_unknownObjectRetain();
      return a1;
    }
    uint64_t v7 = 1;
  }
  else
  {
    if (v6 != 1)
    {
      *int v4 = v6;
      swift_unknownObjectRetain();
      swift_unknownObjectRelease();
      return a1;
    }
    sub_1834D8BDC((uint64_t)v4);
    uint64_t v7 = a2[2];
  }
  *int v4 = v7;
  return a1;
}

__n128 __swift_memcpy24_8(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  *a1 = result;
  return result;
}

void *assignWithTake for IPv6Address(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  int v4 = a1 + 2;
  uint64_t v5 = a2[2];
  if (a1[2] != 1)
  {
    if (v5 != 1)
    {
      *int v4 = v5;
      swift_unknownObjectRelease();
      return a1;
    }
    sub_1834D8BDC((uint64_t)v4);
    uint64_t v5 = 1;
  }
  *int v4 = v5;
  return a1;
}

uint64_t getEnumTagSinglePayload for IPv6Address(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 > 0x7FFFFFFD && *(unsigned char *)(a1 + 24)) {
    return (*(_DWORD *)a1 + 2147483646);
  }
  unint64_t v3 = *(void *)(a1 + 16);
  if (v3 >= 0xFFFFFFFF) {
    LODWORD(v3) = -1;
  }
  int v4 = v3 - 1;
  if (v4 < 0) {
    int v4 = -1;
  }
  BOOL v5 = __OFSUB__(v4, 1);
  int v6 = v4 - 1;
  if (v6 < 0 != v5) {
    int v6 = -1;
  }
  return (v6 + 1);
}

uint64_t storeEnumTagSinglePayload for IPv6Address(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0x7FFFFFFD)
  {
    *(void *)(result + 8) = 0;
    *(void *)(result + 16) = 0;
    *(void *)__n128 result = a2 - 2147483646;
    if (a3 > 0x7FFFFFFD) {
      *(unsigned char *)(result + 24) = 1;
    }
  }
  else
  {
    if (a3 > 0x7FFFFFFD) {
      *(unsigned char *)(result + 24) = 0;
    }
    if (a2) {
      *(void *)(result + 16) = a2 + 1;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for IPv6Address()
{
  return &type metadata for IPv6Address;
}

unsigned char *storeEnumTagSinglePayload for IPv6Address.Scope(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 4 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 4) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFC) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xFB)
  {
    unsigned int v6 = ((a2 - 252) >> 8) + 1;
    *__n128 result = a2 + 4;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x1834D9058);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *__n128 result = a2 + 4;
        break;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for IPv6Address.Scope()
{
  return &type metadata for IPv6Address.Scope;
}

ValueMetadata *type metadata accessor for EthernetAddress()
{
  return &type metadata for EthernetAddress;
}

unint64_t initializeBufferWithCopyOfBuffer for NWEndpoint(unint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = *(_DWORD *)(*(void *)(a3 - 8) + 80);
  if ((v5 & 0x20000) != 0)
  {
    uint64_t v10 = *(void *)a2;
    *(void *)a1 = *(void *)a2;
    a1 = v10 + ((v5 + 16) & ~(unint64_t)v5);
    swift_retain();
  }
  else
  {
    switch(swift_getEnumCaseMultiPayload())
    {
      case 1u:
        uint64_t v13 = *(void *)(a2 + 8);
        *(void *)a1 = *(void *)a2;
        *(void *)(a1 + 8) = v13;
        uint64_t v14 = *(void *)(a2 + 24);
        *(void *)(a1 + 16) = *(void *)(a2 + 16);
        *(void *)(a1 + 24) = v14;
        uint64_t v15 = *(void *)(a2 + 40);
        *(void *)(a1 + 32) = *(void *)(a2 + 32);
        *(void *)(a1 + 40) = v15;
        uint64_t v16 = *(void *)(a2 + 48);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        if (v16 != 1) {
          swift_unknownObjectRetain();
        }
        *(void *)(a1 + 48) = v16;
        break;
      case 2u:
        uint64_t v11 = *(void *)(a2 + 8);
        *(void *)a1 = *(void *)a2;
        *(void *)(a1 + 8) = v11;
        swift_bridgeObjectRetain();
        break;
      case 3u:
        uint64_t v12 = sub_183D4447C();
        (*(void (**)(unint64_t, uint64_t, uint64_t))(*(void *)(v12 - 8) + 16))(a1, a2, v12);
        break;
      case 4u:
        *(void *)a1 = *(void *)a2;
        swift_unknownObjectRetain();
        break;
      default:
        uint64_t v6 = *(void *)a2;
        uint64_t v7 = *(void *)(a2 + 8);
        uint64_t v8 = *(void *)(a2 + 16);
        char v9 = *(unsigned char *)(a2 + 24);
        sub_18315E9E4(*(void *)a2, v7, v8, v9);
        *(void *)a1 = v6;
        *(void *)(a1 + 8) = v7;
        *(void *)(a1 + 16) = v8;
        *(unsigned char *)(a1 + 24) = v9;
        *(_WORD *)(a1 + 26) = *(_WORD *)(a2 + 26);
        break;
    }
    swift_storeEnumTagMultiPayload();
  }
  return a1;
}

uint64_t assignWithCopy for NWEndpoint(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    sub_1834D7F64(a1);
    switch(swift_getEnumCaseMultiPayload())
    {
      case 1u:
        *(void *)a1 = *a2;
        *(void *)(a1 + 8) = a2[1];
        *(void *)(a1 + 16) = a2[2];
        *(void *)(a1 + 24) = a2[3];
        *(void *)(a1 + 32) = a2[4];
        *(void *)(a1 + 40) = a2[5];
        uint64_t v9 = a2[6];
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        if (v9 != 1) {
          swift_unknownObjectRetain();
        }
        *(void *)(a1 + 48) = v9;
        break;
      case 2u:
        *(void *)a1 = *a2;
        *(void *)(a1 + 8) = a2[1];
        swift_bridgeObjectRetain();
        break;
      case 3u:
        uint64_t v8 = sub_183D4447C();
        (*(void (**)(uint64_t, uint64_t *, uint64_t))(*(void *)(v8 - 8) + 16))(a1, a2, v8);
        break;
      case 4u:
        *(void *)a1 = *a2;
        swift_unknownObjectRetain();
        break;
      default:
        uint64_t v4 = *a2;
        uint64_t v5 = a2[1];
        uint64_t v6 = a2[2];
        char v7 = *((unsigned char *)a2 + 24);
        sub_18315E9E4(*a2, v5, v6, v7);
        *(void *)a1 = v4;
        *(void *)(a1 + 8) = v5;
        *(void *)(a1 + 16) = v6;
        *(unsigned char *)(a1 + 24) = v7;
        *(_WORD *)(a1 + 26) = *((_WORD *)a2 + 13);
        break;
    }
    swift_storeEnumTagMultiPayload();
  }
  return a1;
}

void *initializeWithTake for NWEndpoint(void *a1, const void *a2, uint64_t a3)
{
  if (swift_getEnumCaseMultiPayload() == 3)
  {
    uint64_t v6 = sub_183D4447C();
    (*(void (**)(void *, const void *, uint64_t))(*(void *)(v6 - 8) + 32))(a1, a2, v6);
    swift_storeEnumTagMultiPayload();
  }
  else
  {
    memcpy(a1, a2, *(void *)(*(void *)(a3 - 8) + 64));
  }
  return a1;
}

void *assignWithTake for NWEndpoint(void *a1, const void *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    sub_1834D7F64((uint64_t)a1);
    if (swift_getEnumCaseMultiPayload() == 3)
    {
      uint64_t v6 = sub_183D4447C();
      (*(void (**)(void *, const void *, uint64_t))(*(void *)(v6 - 8) + 32))(a1, a2, v6);
      swift_storeEnumTagMultiPayload();
    }
    else
    {
      memcpy(a1, a2, *(void *)(*(void *)(a3 - 8) + 64));
    }
  }
  return a1;
}

void destroy for NWEndpoint.Host(uint64_t a1)
{
}

uint64_t initializeWithCopy for NWEndpoint.Host(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)a2;
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v5 = *(void *)(a2 + 16);
  char v6 = *(unsigned char *)(a2 + 24);
  sub_18315E9E4(*(void *)a2, v4, v5, v6);
  *(void *)a1 = v3;
  *(void *)(a1 + 8) = v4;
  *(void *)(a1 + 16) = v5;
  *(unsigned char *)(a1 + 24) = v6;
  return a1;
}

uint64_t assignWithCopy for NWEndpoint.Host(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)a2;
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v5 = *(void *)(a2 + 16);
  char v6 = *(unsigned char *)(a2 + 24);
  sub_18315E9E4(*(void *)a2, v4, v5, v6);
  uint64_t v7 = *(void *)a1;
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *(void *)(a1 + 16);
  *(void *)a1 = v3;
  *(void *)(a1 + 8) = v4;
  *(void *)(a1 + 16) = v5;
  char v10 = *(unsigned char *)(a1 + 24);
  *(unsigned char *)(a1 + 24) = v6;
  sub_18315E658(v7, v8, v9, v10);
  return a1;
}

uint64_t assignWithTake for NWEndpoint.Host(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  char v4 = *(unsigned char *)(a2 + 24);
  uint64_t v5 = *(void *)a1;
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v6 = *(void *)(a1 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = v3;
  char v8 = *(unsigned char *)(a1 + 24);
  *(unsigned char *)(a1 + 24) = v4;
  sub_18315E658(v5, v7, v6, v8);
  return a1;
}

uint64_t sub_1834D9744(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 24);
}

uint64_t sub_1834D974C(uint64_t result, char a2)
{
  *(unsigned char *)(result + 24) = a2;
  return result;
}

ValueMetadata *type metadata accessor for NWEndpoint.Host()
{
  return &type metadata for NWEndpoint.Host;
}

uint64_t getEnumTagSinglePayload for NWEndpoint.EndpointType(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xFA) {
    goto LABEL_17;
  }
  if (a2 + 6 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 6) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 6;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 6;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 6;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 7;
  int v8 = v6 - 7;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *storeEnumTagSinglePayload for NWEndpoint.EndpointType(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 6 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 6) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFA) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xF9)
  {
    unsigned int v6 = ((a2 - 250) >> 8) + 1;
    *__n128 result = a2 + 6;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x1834D98C0);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *__n128 result = a2 + 6;
        break;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for NWEndpoint.EndpointType()
{
  return &type metadata for NWEndpoint.EndpointType;
}

void *sub_1834D98F8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *(uint64_t **)(v3 + 16);
  uint64_t v7 = *v5;
  uint64_t v6 = v5[1];
  v13[0] = v7;
  v13[1] = v6;
  v12[2] = v13;
  __n128 result = sub_1834D6CE8((void *(*)(uint64_t *__return_ptr, uint64_t, uint64_t))sub_1834D997C, (uint64_t)v12, a1, a2);
  *a3 = result;
  a3[1] = v9;
  a3[2] = v10;
  a3[3] = v11;
  return result;
}

uint64_t sub_1834D9964(long long *a1, uint64_t a2)
{
  long long v2 = *a1;
  long long v3 = a1[1];
  *(void *)(a2 + 32) = *((void *)a1 + 4);
  *(_OWORD *)a2 = v2;
  *(_OWORD *)(a2 + 16) = v3;
  return a2;
}

uint64_t sub_1834D997C@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  return sub_1834D6F00(a1, a2);
}

unint64_t sub_1834D999C()
{
  unint64_t result = qword_1E8F62E58;
  if (!qword_1E8F62E58)
  {
    __swift_instantiateConcreteTypeFromMangledNameAbstract(&qword_1E8F62E50);
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F62E58);
  }
  return result;
}

ValueMetadata *type metadata accessor for NWOptionalError()
{
  return &type metadata for NWOptionalError;
}

uint64_t sub_1834D9A1C(void (*a1)(uint64_t *))
{
  uint64_t v3 = v1[1];
  uint64_t v4 = v1[2];
  uint64_t v5 = v1[3];
  char v6 = *((unsigned char *)v1 + 32);
  uint64_t v7 = v1[5];
  uint64_t v8 = v1[6];
  uint64_t v9 = v1[8];
  uint64_t v30 = v1[9];
  uint64_t v31 = v1[7];
  uint64_t v29 = v1[10];
  uint64_t v33 = v1[12];
  uint64_t v34 = v1[11];
  uint64_t v32 = v1[13];
  uint64_t v10 = v1[15];
  uint64_t v36 = v1[16];
  uint64_t v37 = v1[14];
  uint64_t v35 = v1[17];
  uint64_t v39 = v1[19];
  uint64_t v40 = v1[18];
  uint64_t v38 = v1[20];
  uint64_t v11 = v1[22];
  uint64_t v43 = v1[23];
  uint64_t v44 = v1[21];
  uint64_t v12 = v1[24];
  uint64_t v45 = v1[26];
  uint64_t v46 = v1[25];
  uint64_t v53 = *v1;
  uint64_t v54 = v3;
  uint64_t v41 = v1[27];
  uint64_t v42 = v12;
  uint64_t v13 = v1[29];
  uint64_t v51 = v1[28];
  uint64_t v55 = v4;
  uint64_t v56 = v5;
  char v57 = v6;
  uint64_t v14 = v1[30];
  uint64_t v58 = v7;
  uint64_t v59 = v8;
  uint64_t v47 = v1[31];
  uint64_t v48 = v14;
  uint64_t v49 = v1[32];
  uint64_t v50 = v1[33];
  uint64_t v15 = v1[35];
  uint64_t v52 = v1[34];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  a1(&v53);
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  if (v9)
  {
    uint64_t v53 = v31;
    uint64_t v54 = v9;
    uint64_t v55 = v30;
    uint64_t v56 = v29;
    char v57 = v34;
    uint64_t v58 = v33;
    uint64_t v59 = v32;
    a1(&v53);
  }
  if (v10)
  {
    uint64_t v53 = v37;
    uint64_t v54 = v10;
    uint64_t v55 = v36;
    uint64_t v56 = v35;
    char v57 = v40;
    uint64_t v58 = v39;
    uint64_t v59 = v38;
    a1(&v53);
  }
  if (v11)
  {
    uint64_t v53 = v44;
    uint64_t v54 = v11;
    uint64_t v55 = v43;
    uint64_t v56 = v42;
    char v57 = v46;
    uint64_t v58 = v45;
    uint64_t v59 = v41;
    a1(&v53);
  }
  if (v13)
  {
    uint64_t v53 = v51;
    uint64_t v54 = v13;
    uint64_t v55 = v48;
    uint64_t v56 = v47;
    char v57 = v49;
    uint64_t v58 = v50;
    uint64_t v59 = v52;
    a1(&v53);
  }
  uint64_t v16 = (uint64_t *)(v15 + 16);
  swift_retain();
  uint64_t result = swift_beginAccess();
  uint64_t v18 = *(void *)(v15 + 16);
  unint64_t v19 = *(void *)(v18 + 16);
  if (!v19) {
    return swift_release();
  }
  uint64_t v20 = 0;
  unint64_t v21 = 0;
  while (v21 < v19)
  {
    ++v21;
    uint64_t v22 = v18 + v20;
    uint64_t v23 = *(void *)(v22 + 72);
    uint64_t v24 = *(void *)(v22 + 80);
    char v25 = *(unsigned char *)(v22 + 64);
    uint64_t v26 = *(void *)(v22 + 48);
    uint64_t v27 = *(void *)(v22 + 56);
    uint64_t v28 = *(void *)(v22 + 40);
    uint64_t v53 = *(void *)(v22 + 32);
    uint64_t v54 = v28;
    uint64_t v55 = v26;
    uint64_t v56 = v27;
    char v57 = v25;
    uint64_t v58 = v23;
    uint64_t v59 = v24;
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    a1(&v53);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    uint64_t result = swift_bridgeObjectRelease();
    uint64_t v18 = *v16;
    unint64_t v19 = *(void *)(*v16 + 16);
    v20 += 64;
    if (v21 == v19) {
      return swift_release();
    }
  }
  __break(1u);
  return result;
}

uint64_t sub_1834D9D04()
{
  unint64_t v2 = v0[5];
  unint64_t v1 = v0[6];
  uint64_t v4 = v0[14];
  uint64_t v3 = v0[15];
  unint64_t v5 = v0[19];
  unint64_t v65 = v0[20];
  uint64_t v57 = v0[22];
  uint64_t v59 = v0[21];
  unint64_t v61 = v0[27];
  unint64_t v62 = v0[26];
  uint64_t v55 = v0[35];
  uint64_t v72 = MEMORY[0x1E4FBC860];
  uint64_t v6 = 0;
  if (sub_1834BF534(v2, v1))
  {
    unint64_t v70 = v2;
    unint64_t v71 = v1;
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain_n();
    sub_1834DB1E4((uint64_t *)&v70);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
  }
  else
  {
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    sub_1835A3DE0(v2, v1);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
  }
  swift_bridgeObjectRelease();
  sub_18355A1FC(32, 0xE100000000000000);
  unint64_t v7 = v5;
  if (v2 == 0x5443454E4E4F43 && v1 == 0xE700000000000000)
  {
    uint64_t v8 = v3;
    unint64_t v9 = v5;
    unint64_t v10 = v65;
    unint64_t v11 = v65;
    if (!v3) {
      goto LABEL_22;
    }
    goto LABEL_18;
  }
  char v12 = sub_183D4592C();
  if (v12)
  {
    uint64_t v8 = v3;
  }
  else
  {
    uint64_t v4 = v59;
    uint64_t v8 = v57;
  }
  unint64_t v10 = v65;
  if (v12) {
    unint64_t v9 = v5;
  }
  else {
    unint64_t v9 = v62;
  }
  if (v12) {
    unint64_t v11 = v65;
  }
  else {
    unint64_t v11 = v61;
  }
  if (v8)
  {
LABEL_18:
    if (sub_1834BF534(v9, v11))
    {
      unint64_t v70 = v9;
      unint64_t v71 = v11;
      uint64_t v13 = v4;
      sub_1834BF9F8(v4, v8);
      swift_bridgeObjectRetain();
      sub_1834DB1E4((uint64_t *)&v70);
      swift_bridgeObjectRelease();
    }
    else
    {
      uint64_t v13 = v4;
      sub_1834BF9F8(v4, v8);
      sub_1835A3DE0(v9, v11);
    }
    sub_1834BFA48(v13, v8);
    unint64_t v7 = v5;
  }
LABEL_22:
  sub_18355A1FC(0x2E312F5054544820, 0xEB000000000A0D31);
  if (v3)
  {
    sub_18355A1FC(0x203A74736F48, 0xE600000000000000);
    if (sub_1834BF534(v7, v10))
    {
      unint64_t v70 = v7;
      unint64_t v71 = v10;
      swift_bridgeObjectRetain();
      sub_1834DB1E4((uint64_t *)&v70);
      swift_bridgeObjectRelease();
    }
    else
    {
      sub_1835A3DE0(v7, v10);
    }
    sub_18355A1FC(2573, 0xE200000000000000);
  }
  swift_retain();
  int v63 = (uint64_t *)(v55 + 16);
  swift_beginAccess();
  uint64_t v14 = *(void *)(v55 + 16);
  unint64_t v15 = *(void *)(v14 + 16);
  if (v15)
  {
    BOOL v54 = 0;
    unint64_t v16 = 0;
    while (v16 < v15)
    {
      uint64_t v17 = (void *)(v14 + (v16 << 6));
      uint64_t v18 = v17[4];
      unint64_t v19 = v17[5];
      ++v16;
      BOOL v20 = v17[6] == 0x65696B6F6F63 && v17[7] == 0xE600000000000000;
      unint64_t v66 = v16;
      if (v20 || (v22 = v17[9], unint64_t v21 = v17[10], (sub_183D4592C() & 1) != 0))
      {
        if (!v54)
        {
          swift_bridgeObjectRetain();
          sub_18355A1FC(v18, v19);
          sub_18355A1FC(8250, 0xE200000000000000);
          uint64_t v32 = sub_18351A02C();
          if (*(void *)(v32 + 16) && (uint64_t v33 = sub_18359A408(0x65696B6F6F63, 0xE600000000000000), (v34 & 1) != 0)) {
            unsigned __int16 v35 = *(_WORD *)(*(void *)(v32 + 56) + 4 * v33);
          }
          else {
            unsigned __int16 v35 = -1;
          }
          swift_bridgeObjectRelease();
          swift_beginAccess();
          uint64_t v36 = swift_bridgeObjectRetain();
          uint64_t v37 = sub_1835204B0(v36, v35);
          swift_bridgeObjectRelease();
          uint64_t v38 = *(void *)(v37 + 16);
          uint64_t v60 = v38;
          BOOL v54 = v38 != 0;
          if (!v38)
          {
LABEL_102:
            swift_release();
            sub_18355A1FC(2573, 0xE200000000000000);
            unint64_t v16 = v66;
            goto LABEL_103;
          }
          char v39 = 0;
          unint64_t v40 = 0;
          uint64_t v56 = v37;
          uint64_t v58 = v37 + 32;
LABEL_73:
          if (v40 >= *(void *)(v37 + 16)) {
            goto LABEL_110;
          }
          uint64_t v67 = v6;
          uint64_t v41 = v58 + 56 * v40;
          unint64_t v43 = *(void *)(v41 + 40);
          unint64_t v42 = *(void *)(v41 + 48);
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          if (v39) {
            sub_18355A1FC(8251, 0xE200000000000000);
          }
          unint64_t v64 = v40 + 1;
          if ((v42 & 0x2000000000000000) != 0) {
            unint64_t v44 = HIBYTE(v42) & 0xF;
          }
          else {
            unint64_t v44 = v43 & 0xFFFFFFFFFFFFLL;
          }
          uint64_t v45 = (v43 >> 59) & 1;
          if ((v42 & 0x1000000000000000) == 0) {
            LOBYTE(v45) = 1;
          }
          uint64_t v46 = 4 << v45;
          unint64_t v47 = 15;
          while (1)
          {
            while (1)
            {
              if (4 * v44 == v47 >> 14)
              {
                unint64_t v68 = v43;
                uint64_t v69 = v42;
                swift_bridgeObjectRetain();
                uint64_t v6 = v67;
                sub_1834DB1E4((uint64_t *)&v68);
                swift_bridgeObjectRelease();
                swift_bridgeObjectRelease();
                swift_bridgeObjectRelease();
LABEL_72:
                swift_bridgeObjectRelease();
                uint64_t v37 = v56;
                ++v40;
                char v39 = 1;
                if (v64 == v60) {
                  goto LABEL_102;
                }
                goto LABEL_73;
              }
              unint64_t v48 = v47 & 0xC;
              unint64_t v49 = v47;
              if (v48 == v46) {
                unint64_t v49 = sub_183520284(v47, v43, v42);
              }
              unint64_t v50 = v49 >> 16;
              if (v49 >> 16 >= v44)
              {
LABEL_107:
                __break(1u);
LABEL_108:
                __break(1u);
                goto LABEL_109;
              }
              if ((v42 & 0x1000000000000000) == 0) {
                break;
              }
              char v52 = sub_183D44CFC();
              if (v48 == v46) {
                goto LABEL_92;
              }
LABEL_95:
              if ((v42 & 0x1000000000000000) == 0) {
                goto LABEL_82;
              }
LABEL_96:
              if (v44 <= v47 >> 16) {
                goto LABEL_108;
              }
              unint64_t v47 = sub_183D44CBC();
              if (v52 < 0)
              {
LABEL_71:
                uint64_t v6 = v67;
                sub_1835A3DE0(v43, v42);
                swift_bridgeObjectRelease();
                swift_bridgeObjectRelease();
                goto LABEL_72;
              }
            }
            if ((v42 & 0x2000000000000000) != 0)
            {
              unint64_t v68 = v43;
              uint64_t v69 = v42 & 0xFFFFFFFFFFFFFFLL;
              char v52 = *((unsigned char *)&v68 + v50);
              if (v48 == v46) {
                goto LABEL_92;
              }
              goto LABEL_95;
            }
            uint64_t v51 = (v42 & 0xFFFFFFFFFFFFFFFLL) + 32;
            if ((v43 & 0x1000000000000000) == 0) {
              uint64_t v51 = sub_183D4557C();
            }
            char v52 = *(unsigned char *)(v51 + v50);
            if (v48 != v46) {
              goto LABEL_95;
            }
LABEL_92:
            unint64_t v47 = sub_183520284(v47, v43, v42);
            if ((v42 & 0x1000000000000000) != 0) {
              goto LABEL_96;
            }
LABEL_82:
            unint64_t v47 = (v47 & 0xFFFFFFFFFFFF0000) + 65540;
            if (v52 < 0) {
              goto LABEL_71;
            }
          }
        }
        BOOL v54 = 1;
LABEL_103:
        swift_beginAccess();
        uint64_t v14 = *v63;
        unint64_t v15 = *(void *)(*v63 + 16);
        if (v16 == v15) {
          goto LABEL_104;
        }
      }
      else
      {
        swift_bridgeObjectRetain_n();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        sub_18355A1FC(v18, v19);
        sub_18355A1FC(8250, 0xE200000000000000);
        if ((v21 & 0x2000000000000000) != 0) {
          unint64_t v23 = HIBYTE(v21) & 0xF;
        }
        else {
          unint64_t v23 = v22 & 0xFFFFFFFFFFFFLL;
        }
        uint64_t v24 = (v22 >> 59) & 1;
        if ((v21 & 0x1000000000000000) == 0) {
          LOBYTE(v24) = 1;
        }
        uint64_t v25 = 4 << v24;
        unint64_t v26 = 15;
        while (4 * v23 != v26 >> 14)
        {
          unint64_t v27 = v26 & 0xC;
          unint64_t v28 = v26;
          if (v27 == v25) {
            unint64_t v28 = sub_183520284(v26, v22, v21);
          }
          unint64_t v29 = v28 >> 16;
          if (v28 >> 16 >= v23)
          {
            __break(1u);
LABEL_106:
            __break(1u);
            goto LABEL_107;
          }
          if ((v21 & 0x1000000000000000) != 0)
          {
            char v31 = sub_183D44CFC();
            if (v27 == v25) {
              goto LABEL_53;
            }
LABEL_56:
            if ((v21 & 0x1000000000000000) == 0) {
              goto LABEL_43;
            }
LABEL_57:
            if (v23 <= v26 >> 16) {
              goto LABEL_106;
            }
            unint64_t v26 = sub_183D44CBC();
            if (v31 < 0)
            {
LABEL_29:
              sub_1835A3DE0(v22, v21);
              swift_bridgeObjectRelease();
              swift_bridgeObjectRelease();
              goto LABEL_30;
            }
          }
          else
          {
            if ((v21 & 0x2000000000000000) != 0)
            {
              unint64_t v68 = v22;
              uint64_t v69 = v21 & 0xFFFFFFFFFFFFFFLL;
              char v31 = *((unsigned char *)&v68 + v29);
              if (v27 == v25) {
                goto LABEL_53;
              }
              goto LABEL_56;
            }
            uint64_t v30 = (v21 & 0xFFFFFFFFFFFFFFFLL) + 32;
            if ((v22 & 0x1000000000000000) == 0) {
              uint64_t v30 = sub_183D4557C();
            }
            char v31 = *(unsigned char *)(v30 + v29);
            if (v27 != v25) {
              goto LABEL_56;
            }
LABEL_53:
            unint64_t v26 = sub_183520284(v26, v22, v21);
            if ((v21 & 0x1000000000000000) != 0) {
              goto LABEL_57;
            }
LABEL_43:
            unint64_t v26 = (v26 & 0xFFFFFFFFFFFF0000) + 65540;
            if (v31 < 0) {
              goto LABEL_29;
            }
          }
        }
        unint64_t v68 = v22;
        uint64_t v69 = v21;
        swift_bridgeObjectRetain();
        sub_1834DB1E4((uint64_t *)&v68);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
LABEL_30:
        swift_bridgeObjectRelease();
        sub_18355A1FC(2573, 0xE200000000000000);
        swift_beginAccess();
        uint64_t v14 = *v63;
        unint64_t v15 = *(void *)(*v63 + 16);
        unint64_t v16 = v66;
        if (v66 == v15) {
          goto LABEL_104;
        }
      }
    }
LABEL_109:
    __break(1u);
LABEL_110:
    __break(1u);
    swift_bridgeObjectRelease();
    __break(1u);
    uint64_t result = swift_bridgeObjectRelease();
    __break(1u);
  }
  else
  {
LABEL_104:
    swift_release();
    sub_18355A1FC(2573, 0xE200000000000000);
    return v72;
  }
  return result;
}