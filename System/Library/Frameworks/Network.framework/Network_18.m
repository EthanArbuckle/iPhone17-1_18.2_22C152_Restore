void nw_http3_encoder_stream_process_input(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  char v4;
  void *v5;
  void (*v6)(void *, void, uint64_t);
  void *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  os_log_type_t v11;
  NSObject *v12;
  os_log_type_t v13;
  const char *v14;
  char *backtrace_string;
  NSObject *v16;
  os_log_type_t v17;
  BOOL v18;
  uint64_t v19;
  os_log_type_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  unsigned int v24;
  int v25;
  char *v26;
  uint64_t v27;
  os_log_type_t v28;
  int v29;
  NSObject *v30;
  os_log_type_t v31;
  const char *v32;
  char *v33;
  NSObject *v34;
  os_log_type_t v35;
  BOOL v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  os_log_type_t v40;
  int v41;
  nw_protocol *v42;
  nw_protocol *output_handler;
  char v44;
  uint64_t v45;
  void *v46;
  int v47;
  char *v48;
  NSObject *v49;
  os_log_type_t v50;
  const char *v51;
  char *v52;
  BOOL v53;
  void v54[2];
  uint64_t (*v55)(uint64_t, uint64_t);
  void *v56;
  unsigned char *v57;
  uint64_t v58;
  os_log_type_t type[8];
  uint64_t v60;
  void (*v61)(uint64_t);
  void *v62;
  uint64_t v63;
  uint64_t v64;
  char v65;
  os_log_type_t v66;
  unsigned char v67[24];
  __n128 (*v68)(uint64_t, uint64_t);
  uint64_t (*v69)();
  void v70[3];
  unsigned char buf[24];
  void *v72;
  unsigned char *v73;
  uint64_t v74;
  unsigned char v75[28];
  uint64_t v76;

  v76 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    while (1)
    {
      *(void *)v67 = 0;
      *(void *)&v67[8] = v67;
      *(void *)&v67[16] = 0x3802000000;
      v68 = __Block_byref_object_copy__61309;
      v69 = __Block_byref_object_dispose__61310;
      v70[0] = 0;
      v70[1] = v70;
      if (!(*(unsigned int (**)(void, uint64_t))(*(void *)(*(void *)(a1 + 1064) + 24) + 80))(*(void *)(a1 + 1064), a1))
      {
        _Block_object_dispose(v67, 8);
        return;
      }
      v54[0] = MEMORY[0x1E4F143A8];
      v54[1] = 0x40000000;
      v55 = ___ZL37nw_http3_encoder_stream_process_inputP17nw_protocol_http3_block_invoke;
      v56 = &unk_1E52473B8;
      v57 = v67;
      v58 = a1;
      v2 = *(void *)(*(void *)&v67[8] + 40);
      do
      {
        if (!v2) {
          break;
        }
        v3 = *(void *)(v2 + 32);
        v4 = ((uint64_t (*)(void *))v55)(v54);
        v2 = v3;
      }
      while ((v4 & 1) != 0);
      v5 = *(void **)(*(void *)&v67[8] + 40);
      if (v5)
      {
        while (1)
        {
          v6 = (void (*)(void *, void, uint64_t))v5[10];
          v7 = (void *)v5[4];
          if (!v6) {
            break;
          }
          v8 = v5[11];
          v5[10] = 0;
          v5[11] = 0;
          v6(v5, 0, v8);
LABEL_11:
          v5 = v7;
          if (!v7) {
            goto LABEL_30;
          }
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "__nw_frame_finalize";
        v9 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        v75[0] = 0;
        if (!__nwlog_fault(v9, type, v75)) {
          goto LABEL_27;
        }
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v10 = gLogObj;
          v11 = type[0];
          if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "__nw_frame_finalize";
            v12 = v10;
            v13 = v11;
            v14 = "%{public}s called with null frame->finalizer";
            goto LABEL_26;
          }
          goto LABEL_27;
        }
        if (v75[0])
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v16 = gLogObj;
          v17 = type[0];
          v18 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
          if (backtrace_string)
          {
            if (v18)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&buf[4] = "__nw_frame_finalize";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = backtrace_string;
              _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(backtrace_string);
            goto LABEL_27;
          }
          if (!v18)
          {
LABEL_27:
            if (v9) {
              free(v9);
            }
            goto LABEL_11;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = "__nw_frame_finalize";
          v12 = v16;
          v13 = v17;
          v14 = "%{public}s called with null frame->finalizer, no backtrace";
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v19 = gLogObj;
          v20 = type[0];
          if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
            goto LABEL_27;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = "__nw_frame_finalize";
          v12 = v19;
          v13 = v20;
          v14 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
        }
LABEL_26:
        _os_log_impl(&dword_1830D4000, v12, v13, v14, buf, 0xCu);
        goto LABEL_27;
      }
LABEL_30:
      while (1)
      {
        v21 = *(void *)(a1 + 960);
        if (!v21) {
          break;
        }
        v22 = *(void *)(v21 + 608);
        v23 = *(void **)(v21 + 616);
        if (v22)
        {
          *(void *)(v22 + 616) = v23;
          v23 = *(void **)(v21 + 616);
        }
        else
        {
          *(void *)(a1 + 968) = v23;
        }
        *v23 = v22;
        *(void *)(v21 + 608) = 0;
        *(void *)(v21 + 616) = 0;
        v24 = *(_DWORD *)(v21 + 372);
        if (v24 > 8)
        {
LABEL_50:
          *(void *)v75 = 0;
          *(void *)&v75[8] = v75;
          *(_DWORD *)&v75[24] = 0;
          *(void *)&v75[16] = 0x2000000000;
          *(void *)buf = MEMORY[0x1E4F143A8];
          *(void *)&buf[8] = 0x40000000;
          *(void *)&buf[16] = ___ZL40nw_http3_stream_fields_process_unblockedP24nw_protocol_http3_stream_block_invoke;
          v72 = &unk_1E52473E0;
          v73 = v75;
          v74 = v21;
          v42 = *(nw_protocol **)(v21 + 216);
          do
          {
            if (!v42) {
              break;
            }
            output_handler = v42->output_handler;
            v44 = (*(uint64_t (**)(unsigned char *))&buf[16])(buf);
            v42 = output_handler;
          }
          while ((v44 & 1) != 0);
          if (!*(_DWORD *)(*(void *)&v75[8] + 24)) {
            nw_protocol_http3_stream_input_available((nw_protocol *)v21, v42);
          }
          if ((*(_WORD *)(v21 + 736) & 0x100) != 0)
          {
            v45 = *(void *)(v21 + 328);
            v46 = *(void **)(*(void *)(v21 + 336) + 1256);
            *(void *)type = MEMORY[0x1E4F143A8];
            v60 = 0x40000000;
            v61 = ___ZL40nw_http3_stream_fields_process_unblockedP24nw_protocol_http3_stream_block_invoke_2;
            v62 = &unk_1E5247408;
            v63 = v45;
            v64 = v21;
            nw_queue_context_async(v46, type);
          }
          _Block_object_dispose(v75, 8);
        }
        else
        {
          if (((1 << v24) & 0x1BB) == 0)
          {
            if (v24 == 2)
            {
              *(_DWORD *)(v21 + 372) = 1;
              v38 = nw_http3_encoder_stream_get_and_reset_received_size(*(void *)(v21 + 336));
              nw_http_transaction_metadata_increment_inbound_header_size(*(void **)(v21 + 392), v38);
            }
            else
            {
              *(_DWORD *)(v21 + 372) = 5;
            }
            goto LABEL_50;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v25 = *(_DWORD *)(v21 + 372);
          *(_DWORD *)v75 = 136446466;
          *(void *)&v75[4] = "nw_http3_stream_fields_process_unblocked";
          *(_WORD *)&v75[12] = 1024;
          *(_DWORD *)&v75[14] = v25;
          v26 = (char *)_os_log_send_and_compose_impl();
          v66 = OS_LOG_TYPE_ERROR;
          v65 = 0;
          if (__nwlog_fault(v26, &v66, &v65))
          {
            if (v66 == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v27 = gLogObj;
              v28 = v66;
              if (os_log_type_enabled((os_log_t)gLogObj, v66))
              {
                v29 = *(_DWORD *)(v21 + 372);
                *(_DWORD *)v75 = 136446466;
                *(void *)&v75[4] = "nw_http3_stream_fields_process_unblocked";
                *(_WORD *)&v75[12] = 1024;
                *(_DWORD *)&v75[14] = v29;
                v30 = v27;
                v31 = v28;
                v32 = "%{public}s Unexpected input state %d";
LABEL_59:
                _os_log_impl(&dword_1830D4000, v30, v31, v32, v75, 0x12u);
              }
            }
            else if (v65)
            {
              v33 = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v34 = gLogObj;
              v35 = v66;
              v36 = os_log_type_enabled((os_log_t)gLogObj, v66);
              if (v33)
              {
                if (v36)
                {
                  v37 = *(_DWORD *)(v21 + 372);
                  *(_DWORD *)v75 = 136446722;
                  *(void *)&v75[4] = "nw_http3_stream_fields_process_unblocked";
                  *(_WORD *)&v75[12] = 1024;
                  *(_DWORD *)&v75[14] = v37;
                  *(_WORD *)&v75[18] = 2082;
                  *(void *)&v75[20] = v33;
                  _os_log_impl(&dword_1830D4000, v34, v35, "%{public}s Unexpected input state %d, dumping backtrace:%{public}s", v75, 0x1Cu);
                }
                free(v33);
              }
              else if (v36)
              {
                v47 = *(_DWORD *)(v21 + 372);
                *(_DWORD *)v75 = 136446466;
                *(void *)&v75[4] = "nw_http3_stream_fields_process_unblocked";
                *(_WORD *)&v75[12] = 1024;
                *(_DWORD *)&v75[14] = v47;
                v30 = v34;
                v31 = v35;
                v32 = "%{public}s Unexpected input state %d, no backtrace";
                goto LABEL_59;
              }
            }
            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v39 = gLogObj;
              v40 = v66;
              if (os_log_type_enabled((os_log_t)gLogObj, v66))
              {
                v41 = *(_DWORD *)(v21 + 372);
                *(_DWORD *)v75 = 136446466;
                *(void *)&v75[4] = "nw_http3_stream_fields_process_unblocked";
                *(_WORD *)&v75[12] = 1024;
                *(_DWORD *)&v75[14] = v41;
                v30 = v39;
                v31 = v40;
                v32 = "%{public}s Unexpected input state %d, backtrace limit exceeded";
                goto LABEL_59;
              }
            }
          }
          if (v26) {
            free(v26);
          }
        }
      }
      if (*(_DWORD *)(a1 + 528) != *(_DWORD *)(a1 + 532))
      {
        nw_http3_start_decoder_stream_if_needed(a1);
        nw_http3_decoder_stream_process_output(a1);
      }
      _Block_object_dispose(v67, 8);
    }
  }
  __nwlog_obj();
  *(_DWORD *)v67 = 136446210;
  *(void *)&v67[4] = "nw_http3_encoder_stream_process_input";
  v48 = (char *)_os_log_send_and_compose_impl();
  buf[0] = 16;
  type[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v48, buf, type))
  {
    if (buf[0] == 17)
    {
      v49 = __nwlog_obj();
      v50 = buf[0];
      if (!os_log_type_enabled(v49, (os_log_type_t)buf[0])) {
        goto LABEL_80;
      }
      *(_DWORD *)v67 = 136446210;
      *(void *)&v67[4] = "nw_http3_encoder_stream_process_input";
      v51 = "%{public}s called with null http3";
      goto LABEL_79;
    }
    if (type[0] == OS_LOG_TYPE_DEFAULT)
    {
      v49 = __nwlog_obj();
      v50 = buf[0];
      if (!os_log_type_enabled(v49, (os_log_type_t)buf[0])) {
        goto LABEL_80;
      }
      *(_DWORD *)v67 = 136446210;
      *(void *)&v67[4] = "nw_http3_encoder_stream_process_input";
      v51 = "%{public}s called with null http3, backtrace limit exceeded";
      goto LABEL_79;
    }
    v52 = (char *)__nw_create_backtrace_string();
    v49 = __nwlog_obj();
    v50 = buf[0];
    v53 = os_log_type_enabled(v49, (os_log_type_t)buf[0]);
    if (v52)
    {
      if (v53)
      {
        *(_DWORD *)v67 = 136446466;
        *(void *)&v67[4] = "nw_http3_encoder_stream_process_input";
        *(_WORD *)&v67[12] = 2082;
        *(void *)&v67[14] = v52;
        _os_log_impl(&dword_1830D4000, v49, v50, "%{public}s called with null http3, dumping backtrace:%{public}s", v67, 0x16u);
      }
      free(v52);
      goto LABEL_80;
    }
    if (v53)
    {
      *(_DWORD *)v67 = 136446210;
      *(void *)&v67[4] = "nw_http3_encoder_stream_process_input";
      v51 = "%{public}s called with null http3, no backtrace";
LABEL_79:
      _os_log_impl(&dword_1830D4000, v49, v50, v51, v67, 0xCu);
    }
  }
LABEL_80:
  if (v48) {
    free(v48);
  }
}

void nw_http3_decoder_stream_process_input(uint64_t a1)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)v35 = 136446210;
    *(void *)&v35[4] = "nw_http3_decoder_stream_process_input";
    v17 = (char *)_os_log_send_and_compose_impl();
    buf[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v17, buf, &type)) {
      goto LABEL_46;
    }
    if (buf[0] == 17)
    {
      v18 = __nwlog_obj();
      os_log_type_t v19 = buf[0];
      if (!os_log_type_enabled(v18, (os_log_type_t)buf[0])) {
        goto LABEL_46;
      }
      *(_DWORD *)v35 = 136446210;
      *(void *)&v35[4] = "nw_http3_decoder_stream_process_input";
      v20 = "%{public}s called with null http3";
    }
    else if (type)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v18 = __nwlog_obj();
      os_log_type_t v19 = buf[0];
      BOOL v22 = os_log_type_enabled(v18, (os_log_type_t)buf[0]);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)v35 = 136446466;
          *(void *)&v35[4] = "nw_http3_decoder_stream_process_input";
          *(_WORD *)&v35[12] = 2082;
          *(void *)&v35[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v18, v19, "%{public}s called with null http3, dumping backtrace:%{public}s", v35, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_46;
      }
      if (!v22)
      {
LABEL_46:
        if (v17) {
          free(v17);
        }
        return;
      }
      *(_DWORD *)v35 = 136446210;
      *(void *)&v35[4] = "nw_http3_decoder_stream_process_input";
      v20 = "%{public}s called with null http3, no backtrace";
    }
    else
    {
      v18 = __nwlog_obj();
      os_log_type_t v19 = buf[0];
      if (!os_log_type_enabled(v18, (os_log_type_t)buf[0])) {
        goto LABEL_46;
      }
      *(_DWORD *)v35 = 136446210;
      *(void *)&v35[4] = "nw_http3_decoder_stream_process_input";
      v20 = "%{public}s called with null http3, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v18, v19, v20, v35, 0xCu);
    goto LABEL_46;
  }
  while (1)
  {
    *(void *)v35 = 0;
    *(void *)&v35[8] = v35;
    *(void *)&v35[16] = 0x3802000000;
    v36 = __Block_byref_object_copy__61309;
    v37 = __Block_byref_object_dispose__61310;
    v38[0] = 0;
    v38[1] = v38;
    if (!(*(unsigned int (**)(void, uint64_t))(*(void *)(*(void *)(a1 + 1080) + 24) + 80))(*(void *)(a1 + 1080), a1))break; {
    v28[0] = MEMORY[0x1E4F143A8];
    }
    v28[1] = 0x40000000;
    v29 = ___ZL37nw_http3_decoder_stream_process_inputP17nw_protocol_http3_block_invoke;
    v30 = &unk_1E5247548;
    v31 = v35;
    uint64_t v32 = a1;
    uint64_t v2 = *(void *)(*(void *)&v35[8] + 40);
    do
    {
      if (!v2) {
        break;
      }
      uint64_t v3 = *(void *)(v2 + 32);
      char v4 = ((uint64_t (*)(void *))v29)(v28);
      uint64_t v2 = v3;
    }
    while ((v4 & 1) != 0);
    v5 = *(void **)(*(void *)&v35[8] + 40);
    if (v5)
    {
      do
      {
        while (1)
        {
          v6 = (void (*)(void *, void, uint64_t))v5[10];
          v7 = (void *)v5[4];
          if (!v6) {
            break;
          }
          uint64_t v8 = v5[11];
          v5[10] = 0;
          v5[11] = 0;
          v6(v5, 0, v8);
          v5 = v7;
          if (!v7) {
            goto LABEL_3;
          }
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446210;
        v40 = "__nw_frame_finalize";
        v9 = (const char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v33 = 0;
        v27 = (char *)v9;
        if (!__nwlog_fault(v9, &type, &v33)) {
          goto LABEL_26;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v10 = type;
          os_log_t log = (os_log_t)gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            *(_DWORD *)buf = 136446210;
            v40 = "__nw_frame_finalize";
            v11 = log;
            os_log_type_t v12 = v10;
            v13 = "%{public}s called with null frame->finalizer";
LABEL_25:
            _os_log_impl(&dword_1830D4000, v11, v12, v13, buf, 0xCu);
          }
        }
        else if (v33)
        {
          v14 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          loga = gLogObj;
          os_log_type_t v23 = type;
          BOOL v15 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (v14)
          {
            if (v15)
            {
              *(_DWORD *)buf = 136446466;
              v40 = "__nw_frame_finalize";
              __int16 v41 = 2082;
              v42 = v14;
              _os_log_impl(&dword_1830D4000, loga, v23, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v14);
            goto LABEL_26;
          }
          if (v15)
          {
            *(_DWORD *)buf = 136446210;
            v40 = "__nw_frame_finalize";
            v11 = loga;
            os_log_type_t v12 = v23;
            v13 = "%{public}s called with null frame->finalizer, no backtrace";
            goto LABEL_25;
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v16 = type;
          os_log_t logb = (os_log_t)gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            *(_DWORD *)buf = 136446210;
            v40 = "__nw_frame_finalize";
            v11 = logb;
            os_log_type_t v12 = v16;
            v13 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
            goto LABEL_25;
          }
        }
LABEL_26:
        if (v27) {
          free(v27);
        }
        v5 = v7;
      }
      while (v7);
    }
LABEL_3:
    _Block_object_dispose(v35, 8);
  }
  _Block_object_dispose(v35, 8);
}

uint64_t ___ZL45nw_protocol_http3_uni_stream_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_2(uint64_t a1, _DWORD *a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += nw_frame_unclaimed_length(a2);
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  return 1;
}

BOOL ___ZL33nw_http3_uni_stream_type_receivedP17nw_protocol_http3P28nw_protocol_http3_uni_streamy_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  BOOL is_quic_stream = nw_protocol_metadata_is_quic_stream(a3);
  if (is_quic_stream) {
    nw_quic_stream_set_application_error(a3, 259);
  }
  return !is_quic_stream;
}

uint64_t ___ZL37nw_http3_decoder_stream_process_inputP17nw_protocol_http3_block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned int v29 = 0;
  char v4 = (unsigned __int8 *)nw_frame_unclaimed_bytes(a2, &v29);
  uint64_t v5 = *(void *)(a1 + 40);
  uint64_t v6 = v29;
  v7 = *(FILE **)(v5 + 456);
  if (v7)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v7);
    fprintf(*(FILE **)(v5 + 456), "got %zu bytes of decoder stream", v6);
    fputc(10, *(FILE **)(v5 + 456));
  }
  if (v6)
  {
    uint64_t v8 = (char *)&v4[v6];
    int v9 = *(_DWORD *)(v5 + 416);
    do
    {
      while (v9 == 1)
      {
        char v14 = 0;
        uint64_t v15 = *(void *)(v5 + 432);
        unsigned int v16 = *(_DWORD *)(v5 + 420);
        v17 = v4;
        while (1)
        {
          unsigned int v21 = *v17++;
          unsigned int v20 = v21;
          v15 += (unint64_t)(v21 & 0x7F) << v16;
          v16 += 7;
          if ((v21 & 0x80) == 0) {
            break;
          }
LABEL_17:
          if (v17 >= (unsigned __int8 *)v8)
          {
            if (v14) {
              int v26 = 0;
            }
            else {
              int v26 = *(_DWORD *)(v5 + 424);
            }
            unsigned int v27 = v26 + v17 - v4;
            if (v27 < 0xB)
            {
              *(void *)(v5 + 432) = v15;
              *(_DWORD *)(v5 + 420) = v16;
              *(_DWORD *)(v5 + 424) = v27;
              *(_DWORD *)(v5 + 416) = 1;
              goto LABEL_28;
            }
            goto LABEL_37;
          }
        }
        if (v16 >= 0x40)
        {
          BOOL v22 = v16 != 70 || v20 > 1;
          if (v22 || (v15 & 0x8000000000000000) == 0) {
            goto LABEL_37;
          }
        }
LABEL_25:
        if ((*(unsigned int (**)(uint64_t))(v5 + 440))(v5 + 256))
        {
LABEL_37:
          nw_http3_fail_all_streams(*(void *)(a1 + 40), 514);
          return 0;
        }
        int v9 = 0;
        *(_DWORD *)(v5 + 416) = 0;
        char v4 = v17;
        if (v17 >= (unsigned __int8 *)v8) {
          goto LABEL_27;
        }
      }
      if (!v9)
      {
        int v10 = (char)*v4;
        v11 = enc_proc_header_ack;
        if (v10 < 0)
        {
          char v13 = 7;
        }
        else
        {
          v11 = enc_proc_ici;
          int v12 = v10 & 0xC0;
          if (v12)
          {
            if (v12 != 64) {
              __assert_rtn("lsqpack_enc_decoder_in", "lsqpack.c", 2459, "(buf[0] & 0xC0) == 0x40");
            }
            char v13 = 6;
            v11 = enc_proc_stream_cancel;
          }
          else
          {
            char v13 = 6;
          }
        }
        *(void *)(v5 + 440) = v11;
        v17 = v4 + 1;
        unint64_t v18 = *v4;
        unint64_t v19 = (-1 << v13) & 0x40 ^ 0x7Fu;
        uint64_t v15 = v19 & v18;
        if ((v19 & v18) >= v19)
        {
          unsigned int v16 = 0;
          char v14 = 1;
          goto LABEL_17;
        }
        goto LABEL_25;
      }
    }
    while (v4 < (unsigned __int8 *)v8);
  }
LABEL_27:
  *(_DWORD *)(v5 + 452) += v6;
LABEL_28:
  uint64_t v23 = *(void *)(a2 + 32);
  v24 = *(void **)(a2 + 40);
  if (v23)
  {
    *(void *)(v23 + 40) = v24;
    v24 = *(void **)(a2 + 40);
  }
  else
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 48) = v24;
  }
  void *v24 = v23;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  uint64_t v25 = 1;
  nw_frame_finalize(a2);
  return v25;
}

uint64_t ___ZL37nw_http3_encoder_stream_process_inputP17nw_protocol_http3_block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned int v143 = 0;
  char v4 = (unsigned __int8 *)nw_frame_unclaimed_bytes(a2, &v143);
  uint64_t v5 = v143;
  uint64_t v139 = a1;
  uint64_t v6 = *(void *)(a1 + 40);
  *(void *)(v6 + 1032) += v143;
  v7 = *(FILE **)(v6 + 544);
  if (v7)
  {
    fwrite("qdec: debug: ", 0xDuLL, 1uLL, v7);
    fprintf(*(FILE **)(v6 + 544), "got %zu bytes of encoder stream", v5);
    fputc(10, *(FILE **)(v6 + 544));
  }
  *(_DWORD *)(v6 + 520) += v5;
  if (!v5) {
    goto LABEL_215;
  }
  uint64_t v8 = &v4[v5];
  int v9 = (void *)(v6 + 788);
  int v10 = (const char **)(v6 + 776);
  v141 = (int *)(v6 + 768);
  uint64_t v142 = v6 + 496;
  v140 = (_DWORD *)(v6 + 760);
  char v11 = -1;
LABEL_8:
  switch(*(_DWORD *)(v6 + 728))
  {
    case 0:
      char v13 = *v4;
      if (((char)*v4 & 0x80000000) == 0)
      {
        if ((*v4 & 0x40) == 0)
        {
          *(_DWORD *)(v6 + 736) = 0;
          if ((v13 & 0x20) != 0)
          {
            *(_DWORD *)(v6 + 728) = 7;
            char v11 = 5;
LABEL_98:
            v17 = v4 + 1;
            uint64_t v79 = *v4;
            unint64_t v80 = ~(-1 << v11);
            unint64_t v15 = v79 & v80;
            if ((v79 & v80) < v80) {
              goto LABEL_239;
            }
            unsigned int v16 = 0;
            char v18 = 1;
            do
            {
              if (v17 >= v8) {
                goto LABEL_210;
              }
LABEL_162:
              unsigned int v113 = *v17++;
              unsigned int v112 = v113;
              v15 += (unint64_t)(v113 & 0x7F) << v16;
              v16 += 7;
            }
            while ((v113 & 0x80) != 0);
            if (v16 < 0x40 || (v16 == 70 ? (BOOL v114 = v112 > 1) : (BOOL v114 = 1), !v114 && (v15 & 0x8000000000000000) != 0))
            {
LABEL_239:
              *(void *)(v6 + 760) = v15;
              if (v15 <= *(unsigned int *)(v6 + 500))
              {
                *(_DWORD *)(v6 + 728) = 0;
                v115 = *(FILE **)(v6 + 544);
                if (v115)
                {
                  fwrite("qdec: debug: ", 0xDuLL, 1uLL, v115);
                  fprintf(*(FILE **)(v6 + 544), "got TSU=%llu", *(void *)(v6 + 760));
                  fputc(10, *(FILE **)(v6 + 544));
                  unint64_t v15 = *(void *)(v6 + 760);
                }
                *(_DWORD *)(v6 + 504) = v15;
                int v116 = *(_DWORD *)(v6 + 516);
                unsigned int v117 = v15 >> 5;
                *(_DWORD *)(v6 + 516) = v117;
                if (v116 != v117)
                {
                  int v118 = *(_DWORD *)(v6 + 528);
                  if (v118 == *(_DWORD *)(v6 + 532) && v118 == 2 * v116 - 1)
                  {
                    int v119 = 2 * v117 - 1;
                    *(_DWORD *)(v6 + 528) = v119;
                    *(_DWORD *)(v6 + 532) = v119;
                  }
                }
                qdec_remove_overflow_entries(v142);
                goto LABEL_7;
              }
            }
          }
          else
          {
            *(_DWORD *)(v6 + 728) = 6;
            char v11 = 5;
LABEL_74:
            v17 = v4 + 1;
            uint64_t v60 = *v4;
            unint64_t v61 = ~(-1 << v11);
            unint64_t v15 = v60 & v61;
            if ((v60 & v61) < v61) {
              goto LABEL_240;
            }
            unsigned int v16 = 0;
            char v18 = 1;
            do
            {
              if (v17 >= v8) {
                goto LABEL_210;
              }
LABEL_101:
              char v81 = *v17++;
              v15 += (unint64_t)(v81 & 0x7F) << v16;
              v16 += 7;
            }
            while (v81 < 0);
            if (v16 <= 0x3F && v15 >> 24 == 0)
            {
LABEL_240:
              *(_DWORD *)(v6 + 760) = v15;
              unsigned int v83 = *(_DWORD *)(v6 + 552);
              if (v83)
              {
                unsigned int v84 = *(_DWORD *)(v6 + 556);
                unsigned int v85 = *(_DWORD *)(v6 + 560);
                int v86 = v84 >= v85 ? 0 : *(_DWORD *)(v6 + 552);
                if (v84 + v86 - v85 > v15)
                {
                  v87 = *(unsigned int **)(*(void *)(v6 + 568) + 8 * ((v83 + v84 + ~v15) % v83));
                  if (v87)
                  {
                    size_t v88 = *v87 + (unint64_t)v87[1] + 28;
                    v89 = (char *)malloc_type_malloc(v88, 0x943048F6uLL);
                    if (v89)
                    {
                      v90 = v89;
                      memcpy(v89, v87, v88);
                      *((_DWORD *)v90 + 2) = 1;
                      if (!lsqpack_dec_push_entry(v142, v90))
                      {
                        *(_DWORD *)(v6 + 728) = 0;
                        goto LABEL_7;
                      }
                      int v137 = *((_DWORD *)v90 + 2) - 1;
                      *((_DWORD *)v90 + 2) = v137;
                      if (!v137) {
                        free(v90);
                      }
                    }
                  }
                }
              }
            }
          }
          goto LABEL_231;
        }
        *(unsigned char *)(v6 + 796) = (v13 & 0x20) != 0;
        *(_DWORD *)(v6 + 736) = 0;
        *(void *)(v6 + 776) = 0;
        *(_DWORD *)(v6 + 728) = 8;
        char v11 = 5;
LABEL_95:
        v17 = v4 + 1;
        uint64_t v77 = *v4;
        unint64_t v78 = ~(-1 << v11);
        unint64_t v15 = v77 & v78;
        if ((v77 & v78) < v78) {
          goto LABEL_241;
        }
        unsigned int v16 = 0;
        char v18 = 1;
        do
        {
          if (v17 >= v8) {
            goto LABEL_210;
          }
LABEL_179:
          char v120 = *v17++;
          v15 += (unint64_t)(v120 & 0x7F) << v16;
          v16 += 7;
        }
        while (v120 < 0);
        if (v16 <= 0x3F && v15 >> 24 == 0)
        {
LABEL_241:
          *(_DWORD *)(v6 + 768) = v15;
          if (*(_DWORD *)(v6 + 504) << (2 * *(unsigned char *)(v6 + 796)) >= v15)
          {
            uint64_t v122 = v15 ? v15 + (v15 >> 1) : 16;
            *(_DWORD *)(v6 + 784) = v122;
            v123 = malloc_type_malloc(v122 + 28, 0x922E1F78uLL);
            *(void *)(v6 + 776) = v123;
            if (v123)
            {
              v123[6] = 0;
              void *v9 = 0;
              if (!*(unsigned char *)(v6 + 796))
              {
                int v12 = 10;
                goto LABEL_6;
              }
              int v109 = 9;
LABEL_192:
              *(_DWORD *)(v6 + 728) = v109;
              *(_DWORD *)(v6 + 760) = 0;
              goto LABEL_7;
            }
          }
        }
        goto LABEL_231;
      }
      *(unsigned char *)(v6 + 817) = (v13 & 0x40) != 0;
      *(_DWORD *)(v6 + 736) = 0;
      *int v10 = 0;
      *(void *)(v6 + 784) = 0;
      char v11 = 6;
      *(_DWORD *)(v6 + 728) = 1;
LABEL_83:
      v17 = v4 + 1;
      uint64_t v66 = *v4;
      unint64_t v67 = ~(-1 << v11);
      unint64_t v15 = v66 & v67;
      if ((v66 & v67) < v67) {
        goto LABEL_122;
      }
      unsigned int v16 = 0;
      char v14 = 1;
      while (v17 < v8)
      {
LABEL_116:
        char v91 = *v17++;
        v15 += (unint64_t)(v91 & 0x7F) << v16;
        v16 += 7;
        if ((v91 & 0x80) == 0)
        {
          if (v16 > 0x3F || v15 >> 24 != 0) {
            goto LABEL_231;
          }
LABEL_122:
          *(_DWORD *)(v6 + 768) = v15;
          if (*(unsigned char *)(v6 + 817))
          {
            if (v15 > 0x62) {
              goto LABEL_231;
            }
            *int v10 = 0;
            int v12 = 2;
            goto LABEL_6;
          }
          unsigned int v93 = *(_DWORD *)(v6 + 552);
          if (!v93) {
            goto LABEL_223;
          }
          unsigned int v94 = *(_DWORD *)(v6 + 556);
          unsigned int v95 = *(_DWORD *)(v6 + 560);
          int v96 = v94 >= v95 ? 0 : *(_DWORD *)(v6 + 552);
          if (v94 + v96 - v95 <= v15) {
            goto LABEL_223;
          }
          uint64_t v97 = *(void *)(*(void *)(v6 + 568) + 8 * ((v93 + v94 + ~v15) % v93));
          *(void *)(v6 + 776) = v97;
          if (!v97) {
            goto LABEL_231;
          }
          ++*(_DWORD *)(v97 + 8);
          int v12 = 2;
LABEL_6:
          *(_DWORD *)(v6 + 728) = v12;
LABEL_7:
          char v4 = v17;
          if (v17 >= v8) {
            goto LABEL_215;
          }
          goto LABEL_8;
        }
      }
      if (v14) {
        int v132 = 0;
      }
      else {
        int v132 = *(_DWORD *)(v6 + 744);
      }
      unsigned int v128 = v132 + v17 - v4;
      if (v128 >= 0xB) {
        goto LABEL_231;
      }
LABEL_214:
      *(void *)(v6 + 752) = v15;
      *(_DWORD *)(v6 + 740) = v16;
      *(_DWORD *)(v6 + 744) = v128;
      *(_DWORD *)(v6 + 736) = 1;
LABEL_215:
      uint64_t v129 = *(void *)(a2 + 32);
      v130 = *(void **)(a2 + 40);
      if (v129)
      {
        *(void *)(v129 + 40) = v130;
        v130 = *(void **)(a2 + 40);
      }
      else
      {
        *(void *)(*(void *)(*(void *)(v139 + 32) + 8) + 48) = v130;
      }
      void *v130 = v129;
      *(void *)(a2 + 32) = 0;
      *(void *)(a2 + 40) = 0;
      uint64_t v131 = 1;
      nw_frame_finalize(a2);
      return v131;
    case 1:
      if (!*(_DWORD *)(v6 + 736)) {
        goto LABEL_83;
      }
      char v14 = 0;
      unint64_t v15 = *(void *)(v6 + 752);
      unsigned int v16 = *(_DWORD *)(v6 + 740);
      v17 = v4;
      goto LABEL_116;
    case 2:
      *(unsigned char *)(v6 + 816) = *v4 >> 7;
      *(_DWORD *)(v6 + 736) = 0;
      *(_DWORD *)(v6 + 728) = 3;
      char v11 = 7;
      goto LABEL_18;
    case 3:
      if (*(_DWORD *)(v6 + 736))
      {
        char v18 = 0;
        unint64_t v15 = *(void *)(v6 + 752);
        unsigned int v16 = *(_DWORD *)(v6 + 740);
        v17 = v4;
        while (1)
        {
          char v98 = *v17++;
          v15 += (unint64_t)(v98 & 0x7F) << v16;
          v16 += 7;
          if ((v98 & 0x80) == 0) {
            break;
          }
LABEL_142:
          if (v17 >= v8) {
            goto LABEL_210;
          }
        }
        if (v16 > 0x3F || v15 >> 24 != 0) {
          goto LABEL_231;
        }
      }
      else
      {
LABEL_18:
        v17 = v4 + 1;
        uint64_t v19 = *v4;
        unint64_t v20 = ~(-1 << v11);
        unint64_t v15 = v19 & v20;
        if ((v19 & v20) >= v20)
        {
          unsigned int v16 = 0;
          char v18 = 1;
          goto LABEL_142;
        }
      }
      *(_DWORD *)(v6 + 772) = v15;
      if (*(unsigned char *)(v6 + 817))
      {
        v100 = &(&static_table)[3 * *v141];
        v103 = *v100;
        v101 = (const char *)(v100 + 2);
        uint64_t v102 = (uint64_t)v103;
      }
      else
      {
        v101 = *v10;
        uint64_t v102 = (uint64_t)(*v10 + 28);
      }
      uint64_t v104 = *(unsigned int *)v101;
      *(_DWORD *)(v6 + 812) = v104;
      *(void *)(v6 + 792) = v102;
      if ((*(_DWORD *)(v6 + 504) - (int)v104) << (2 * *(unsigned char *)(v6 + 816)) < v15) {
        goto LABEL_231;
      }
      unsigned int v105 = v15 >> 1;
      if (!*(unsigned char *)(v6 + 816)) {
        unsigned int v105 = 0;
      }
      uint64_t v106 = v105 + v15;
      *(_DWORD *)(v6 + 800) = v106;
      v107 = malloc_type_malloc(v104 + v106 + 28, 0x555E5004uLL);
      *(void *)(v6 + 784) = v107;
      if (!v107) {
        goto LABEL_231;
      }
      if (*(unsigned char *)(v6 + 817))
      {
        v107[6] = 5;
        *(_DWORD *)(*(void *)(v6 + 784) + 12) = name_hashes[*(unsigned int *)(v6 + 768)];
        v108 = (_DWORD *)(v6 + 768);
      }
      else
      {
        v107[6] = *(_DWORD *)(*(void *)(v6 + 776) + 24) & 5;
        *(_DWORD *)(*(void *)(v6 + 784) + 12) = *(_DWORD *)(*(void *)(v6 + 776) + 12);
        v108 = (_DWORD *)(*(void *)(v6 + 776) + 20);
      }
      *(_DWORD *)(*(void *)(v6 + 784) + 20) = *v108;
      **(_DWORD **)(v6 + 784) = *(_DWORD *)(v6 + 812);
      *(void *)(v6 + 804) = 0;
      int v25 = *(_DWORD *)(v6 + 772);
      if (v25)
      {
        if (!*(unsigned char *)(v6 + 816))
        {
          int v12 = 4;
          goto LABEL_6;
        }
        int v109 = 5;
        goto LABEL_192;
      }
LABEL_155:
      *(_DWORD *)(*(void *)(v6 + 784) + 4) = v25;
      *(_DWORD *)(*(void *)(v6 + 784) + 8) = 1;
      memcpy((void *)(*(void *)(v6 + 784) + 28), *(const void **)(v6 + 792), *(unsigned int *)(v6 + 812));
      v110 = *(_DWORD **)(v6 + 776);
      if (v110)
      {
        int v111 = v110[2] - 1;
        v110[2] = v111;
        if (!v111) {
          free(v110);
        }
        *int v10 = 0;
      }
      if (!lsqpack_dec_push_entry(v142, *(const char **)(v6 + 784))) {
        goto LABEL_160;
      }
      goto LABEL_224;
    case 4:
      unsigned int v21 = *(_DWORD *)(v6 + 772);
      if (*(_DWORD *)(v6 + 800) < v21) {
        __assert_rtn("lsqpack_dec_enc_in", "lsqpack.c", 4714, "WINR.alloced_val_len >= WINR.val_len");
      }
      uint64_t v22 = *(unsigned int *)(v6 + 804);
      unsigned int v23 = v21 - v22;
      if (v23 >= (int)v8 - (int)v4) {
        size_t v24 = (v8 - v4);
      }
      else {
        size_t v24 = v23;
      }
      memcpy((void *)(*(void *)(v6 + 784) + v22 + **(unsigned int **)(v6 + 784) + 28), v4, v24);
      int v25 = *(_DWORD *)(v6 + 804) + v24;
      *(_DWORD *)(v6 + 804) = v25;
      v17 = &v4[v24];
      if (v25 == *(_DWORD *)(v6 + 772)) {
        goto LABEL_155;
      }
      goto LABEL_7;
    case 5:
      uint64_t v26 = *(unsigned int *)(v6 + 772);
      uint64_t v27 = *(unsigned int *)(v6 + 808);
      if ((int)v26 - (int)v27 >= (v8 - v4)) {
        uint64_t v28 = (v8 - v4);
      }
      else {
        uint64_t v28 = (v26 - v27);
      }
      unint64_t v29 = lsqpack_huff_decode(v4, v28, (char *)(*(void *)(v6 + 784) + *(unsigned int *)(v6 + 804) + **(unsigned int **)(v6 + 784) + 28), (*(_DWORD *)(v6 + 800) - *(_DWORD *)(v6 + 804)), v140, v28 + v27 == v26);
      int v31 = v30;
      unint64_t v32 = HIDWORD(v29);
      if (v29 == 2)
      {
        uint64_t v68 = (2 * *(_DWORD *)(v6 + 800));
        *(_DWORD *)(v6 + 800) = v68;
        v69 = malloc_type_realloc(*(void **)(v6 + 784), v68 + *(unsigned int *)(v6 + 812) + 28, 0x2406461BuLL);
        if (!v69) {
          goto LABEL_231;
        }
        *(void *)(v6 + 784) = v69;
      }
      else if (v29 != 1)
      {
        if (v29) {
          goto LABEL_231;
        }
        *(_DWORD *)(*(void *)(v6 + 784) + 4) = *(_DWORD *)(v6 + 804) + HIDWORD(v29);
        *(_DWORD *)(*(void *)(v6 + 784) + 8) = 1;
        memcpy((void *)(*(void *)(v6 + 784) + 28), *(const void **)(v6 + 792), *(unsigned int *)(v6 + 812));
        char v33 = *(_DWORD **)(v6 + 776);
        if (v33)
        {
          int v34 = v33[2] - 1;
          v33[2] = v34;
          if (!v34) {
            free(v33);
          }
          *int v10 = 0;
        }
        if (!lsqpack_dec_push_entry(v142, *(const char **)(v6 + 784)))
        {
          v17 = &v4[v31];
LABEL_160:
          *(_DWORD *)(v6 + 728) = 0;
          *(void *)(v6 + 784) = 0;
          goto LABEL_7;
        }
LABEL_224:
        v135 = *(_DWORD **)(v6 + 784);
        int v136 = v135[2] - 1;
        v135[2] = v136;
        if (!v136) {
          free(v135);
        }
        *(void *)(v6 + 784) = 0;
LABEL_231:
        nw_http3_fail_all_streams(*(void *)(v139 + 40), 513);
        return 0;
      }
      v17 = &v4[v31];
      *(_DWORD *)(v6 + 808) += v31;
      *(_DWORD *)(v6 + 804) += v32;
      goto LABEL_7;
    case 6:
      if (!*(_DWORD *)(v6 + 736)) {
        goto LABEL_74;
      }
      char v18 = 0;
      unint64_t v15 = *(void *)(v6 + 752);
      unsigned int v16 = *(_DWORD *)(v6 + 740);
      v17 = v4;
      goto LABEL_101;
    case 7:
      if (!*(_DWORD *)(v6 + 736)) {
        goto LABEL_98;
      }
      char v18 = 0;
      unint64_t v15 = *(void *)(v6 + 752);
      unsigned int v16 = *(_DWORD *)(v6 + 740);
      v17 = v4;
      goto LABEL_162;
    case 8:
      if (!*(_DWORD *)(v6 + 736)) {
        goto LABEL_95;
      }
      char v18 = 0;
      unint64_t v15 = *(void *)(v6 + 752);
      unsigned int v16 = *(_DWORD *)(v6 + 740);
      v17 = v4;
      goto LABEL_179;
    case 9:
      uint64_t v35 = *(unsigned int *)(v6 + 768);
      uint64_t v36 = *(unsigned int *)(v6 + 792);
      if ((int)v35 - (int)v36 >= (v8 - v4)) {
        uint64_t v37 = (v8 - v4);
      }
      else {
        uint64_t v37 = (v35 - v36);
      }
      unint64_t v38 = lsqpack_huff_decode(v4, v37, (char *)(*(void *)(v6 + 776) + *(unsigned int *)(v6 + 788) + 28), (*(_DWORD *)(v6 + 784) - *(_DWORD *)(v6 + 788)), v140, v37 + v36 == v35);
      int v40 = v39;
      unint64_t v41 = HIDWORD(v38);
      if (v38 == 2)
      {
        uint64_t v70 = (2 * *(_DWORD *)(v6 + 784));
        *(_DWORD *)(v6 + 784) = v70;
        v71 = *(void **)(v6 + 776);
        size_t v72 = v70 + 28;
        malloc_type_id_t v73 = 2184326241;
        goto LABEL_91;
      }
      if (v38 == 1) {
        goto LABEL_93;
      }
      if (v38) {
        goto LABEL_231;
      }
      v17 = &v4[v39];
      v42 = *(int **)(v6 + 776);
      int v43 = *(_DWORD *)(v6 + 788) + HIDWORD(v38);
LABEL_57:
      int *v42 = v43;
      int v12 = 11;
      goto LABEL_6;
    case 0xA:
      unsigned int v44 = *(_DWORD *)(v6 + 768);
      if (*(_DWORD *)(v6 + 784) < v44) {
        __assert_rtn("lsqpack_dec_enc_in", "lsqpack.c", 4809, "WONR.alloced_len >= WONR.str_len");
      }
      uint64_t v45 = *(unsigned int *)v9;
      unsigned int v46 = v44 - v45;
      if (v46 >= (int)v8 - (int)v4) {
        size_t v47 = (v8 - v4);
      }
      else {
        size_t v47 = v46;
      }
      memcpy((void *)&(*v10)[v45 + 28], v4, v47);
      int v43 = *(_DWORD *)v9 + v47;
      *(_DWORD *)int v9 = v43;
      v17 = &v4[v47];
      if (v43 != *v141) {
        goto LABEL_7;
      }
      v42 = *(int **)(v6 + 776);
      goto LABEL_57;
    case 0xB:
      *(unsigned char *)(v6 + 796) = *v4 >> 7;
      *(_DWORD *)(v6 + 736) = 0;
      *(_DWORD *)(v6 + 728) = 12;
      char v11 = 7;
      goto LABEL_61;
    case 0xC:
      if (*(_DWORD *)(v6 + 736))
      {
        char v18 = 0;
        unint64_t v15 = *(void *)(v6 + 752);
        unsigned int v16 = *(_DWORD *)(v6 + 740);
        v17 = v4;
        while (1)
        {
          char v124 = *v17++;
          v15 += (unint64_t)(v124 & 0x7F) << v16;
          v16 += 7;
          if ((v124 & 0x80) == 0) {
            break;
          }
LABEL_207:
          if (v17 >= v8)
          {
LABEL_210:
            if (v18) {
              int v127 = 0;
            }
            else {
              int v127 = *(_DWORD *)(v6 + 744);
            }
            unsigned int v128 = v127 + v17 - v4;
            if (v128 >= 0xB) {
              goto LABEL_231;
            }
            goto LABEL_214;
          }
        }
        if (v16 > 0x3F || v15 >> 24 != 0) {
          goto LABEL_231;
        }
      }
      else
      {
LABEL_61:
        v17 = v4 + 1;
        uint64_t v48 = *v4;
        unint64_t v49 = ~(-1 << v11);
        unint64_t v15 = v48 & v49;
        if ((v48 & v49) >= v49)
        {
          unsigned int v16 = 0;
          char v18 = 1;
          goto LABEL_207;
        }
      }
      *(_DWORD *)(v6 + 768) = v15;
      v65 = *(const char **)(v6 + 776);
      char v126 = *(unsigned char *)(v6 + 796);
      if ((*(_DWORD *)(v6 + 504) - *(_DWORD *)v65) << (2 * v126) < v15) {
        goto LABEL_231;
      }
      void *v9 = 0;
      if (v15)
      {
        if (!v126)
        {
          int v12 = 14;
          goto LABEL_6;
        }
        *(_DWORD *)(v6 + 728) = 13;
        *(_DWORD *)(v6 + 760) = 0;
        goto LABEL_7;
      }
LABEL_205:
      *((_DWORD *)v65 + 1) = v15;
      *((_DWORD *)*v10 + 2) = 1;
      if (!lsqpack_dec_push_entry(v142, *v10)) {
        goto LABEL_206;
      }
      goto LABEL_221;
    case 0xD:
      uint64_t v50 = *(unsigned int *)(v6 + 768);
      uint64_t v51 = *(unsigned int *)(v6 + 792);
      if ((int)v50 - (int)v51 >= (v8 - v4)) {
        uint64_t v52 = (v8 - v4);
      }
      else {
        uint64_t v52 = (v50 - v51);
      }
      unint64_t v53 = lsqpack_huff_decode(v4, v52, (char *)(*(void *)(v6 + 776) + *(unsigned int *)(v6 + 788) + **(unsigned int **)(v6 + 776) + 28), (*(_DWORD *)(v6 + 784) - *(_DWORD *)(v6 + 788) - **(_DWORD **)(v6 + 776)), v140, v52 + v51 == v50);
      int v40 = v54;
      unint64_t v41 = HIDWORD(v53);
      if (v53 == 2)
      {
        int v74 = *(_DWORD *)(v6 + 784);
        if (!v74) {
          __assert_rtn("lsqpack_dec_enc_in", "lsqpack.c", 4885, "WONR.alloced_len");
        }
        uint64_t v75 = (2 * v74);
        *(_DWORD *)(v6 + 784) = v75;
        v71 = *(void **)(v6 + 776);
        size_t v72 = v75 + 28;
        malloc_type_id_t v73 = 2751939443;
LABEL_91:
        v76 = malloc_type_realloc(v71, v72, v73);
        if (!v76) {
          goto LABEL_231;
        }
        *(void *)(v6 + 776) = v76;
      }
      else if (v53 != 1)
      {
        if (v53) {
          goto LABEL_231;
        }
        *((_DWORD *)*v10 + 1) = *(_DWORD *)v9 + HIDWORD(v53);
        *((_DWORD *)*v10 + 2) = 1;
        if (!lsqpack_dec_push_entry(v142, *v10))
        {
          v17 = &v4[v40];
LABEL_206:
          *(_DWORD *)(v6 + 728) = 0;
          *(void *)(v6 + 776) = 0;
          goto LABEL_7;
        }
LABEL_221:
        v133 = (char *)*v10;
        int v134 = *((_DWORD *)*v10 + 2) - 1;
        *((_DWORD *)*v10 + 2) = v134;
        if (!v134) {
          free(v133);
        }
LABEL_223:
        *int v10 = 0;
        goto LABEL_231;
      }
LABEL_93:
      v17 = &v4[v40];
      *(_DWORD *)(v6 + 792) += v40;
      *(_DWORD *)(v6 + 788) += v41;
      goto LABEL_7;
    case 0xE:
      v55 = *(unsigned int **)(v6 + 776);
      unsigned int v56 = *v55;
      int v57 = *(_DWORD *)(v6 + 768);
      uint64_t v58 = v57 + *v55;
      if (*(_DWORD *)(v6 + 784) >= v58)
      {
        v59 = (_DWORD *)(v6 + 768);
      }
      else
      {
        *(_DWORD *)(v6 + 784) = v58;
        v55 = (unsigned int *)malloc_type_realloc(v55, v58 + 28, 0x9D13A7E5uLL);
        if (!v55) {
          goto LABEL_231;
        }
        *int v10 = (const char *)v55;
        v59 = (_DWORD *)(v6 + 768);
        int v57 = *v141;
        unsigned int v56 = *v55;
      }
      uint64_t v62 = *(unsigned int *)v9;
      unsigned int v63 = v57 - v62;
      if (v63 >= (int)v8 - (int)v4) {
        size_t v64 = (v8 - v4);
      }
      else {
        size_t v64 = v63;
      }
      memcpy((char *)v55 + v56 + v62 + 28, v4, v64);
      LODWORD(v15) = *(_DWORD *)v9 + v64;
      *(_DWORD *)int v9 = v15;
      v17 = &v4[v64];
      if (v15 != *v59) {
        goto LABEL_7;
      }
      v65 = *v10;
      goto LABEL_205;
    default:
      __assert_rtn("lsqpack_dec_enc_in", "lsqpack.c", 4981, "0");
  }
}

uint64_t nw_http3_encoder_stream_get_and_reset_received_size(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t result = *(void *)(a1 + 1032);
    *(void *)(a1 + 1032) = 0;
    return result;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v12 = "nw_http3_encoder_stream_get_and_reset_received_size";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        int v12 = "nw_http3_encoder_stream_get_and_reset_received_size";
        uint64_t v6 = "%{public}s called with null http3";
LABEL_17:
        _os_log_impl(&dword_1830D4000, v4, v5, v6, buf, 0xCu);
      }
    }
    else if (v9)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v8 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v8)
        {
          *(_DWORD *)buf = 136446466;
          int v12 = "nw_http3_encoder_stream_get_and_reset_received_size";
          __int16 v13 = 2082;
          char v14 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s called with null http3, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        int v12 = "nw_http3_encoder_stream_get_and_reset_received_size";
        uint64_t v6 = "%{public}s called with null http3, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      char v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        int v12 = "nw_http3_encoder_stream_get_and_reset_received_size";
        uint64_t v6 = "%{public}s called with null http3, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v3) {
    free(v3);
  }
  return 0;
}

BOOL ___ZL40nw_http3_stream_fields_process_unblockedP24nw_protocol_http3_stream_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 32);
  char v4 = *(void **)(a2 + 40);
  if (v3)
  {
    *(void *)(v3 + 40) = v4;
    char v4 = *(void **)(a2 + 40);
  }
  else
  {
    *(void *)(*(void *)(a1 + 40) + 224) = v4;
  }
  *char v4 = v3;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  nw_http3_stream_handle_fields(*(void *)(a1 + 40), 0, a2, (*(unsigned __int16 *)(*(void *)(a1 + 40) + 736) >> 3) & 1);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v5;
  return *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
}

void nw_protocol_http3_stream_input_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      if ((handle[92] & 0x800) == 0)
      {
        if (gLogDatapath)
        {
          size_t v24 = __nwlog_obj();
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
          {
            int v25 = *(_DWORD *)(handle[42] + 1280);
            uint64_t v26 = handle[30];
            *(_DWORD *)buf = 136447234;
            int v43 = "nw_protocol_http3_stream_input_available";
            __int16 v44 = 2082;
            uint64_t v45 = (char *)handle + 636;
            __int16 v46 = 2080;
            size_t v47 = " ";
            __int16 v48 = 1024;
            int v49 = v25;
            __int16 v50 = 2048;
            uint64_t v51 = v26;
            _os_log_impl(&dword_1830D4000, v24, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called", buf, 0x30u);
          }
        }
      }
      uint64_t v4 = handle[6];
      if (v4)
      {
        uint64_t v5 = *(void *)(v4 + 24);
        if (v5)
        {
          uint64_t v6 = *(void (**)(nw_protocol *, void *))(v5 + 64);
          if (v6)
          {
            v6(a1->default_input_handler, handle);
            return;
          }
        }
      }
      __nwlog_obj();
      uint64_t v7 = handle[6];
      BOOL v8 = "invalid";
      if (v7)
      {
        char v9 = *(const char **)(v7 + 16);
        if (v9) {
          BOOL v8 = v9;
        }
      }
      *(_DWORD *)buf = 136446466;
      int v43 = "nw_protocol_http3_stream_input_available";
      __int16 v44 = 2082;
      uint64_t v45 = (char *)v8;
      int v10 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v40 = 0;
      if (__nwlog_fault(v10, &type, &v40))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          char v11 = __nwlog_obj();
          os_log_type_t v12 = type;
          if (!os_log_type_enabled(v11, type)) {
            goto LABEL_70;
          }
          uint64_t v13 = handle[6];
          char v14 = "invalid";
          if (v13)
          {
            uint64_t v15 = *(const char **)(v13 + 16);
            if (v15) {
              char v14 = v15;
            }
          }
          *(_DWORD *)buf = 136446466;
          int v43 = "nw_protocol_http3_stream_input_available";
          __int16 v44 = 2082;
          uint64_t v45 = (char *)v14;
          unsigned int v16 = "%{public}s protocol %{public}s has invalid input_available callback";
LABEL_59:
          uint64_t v37 = v11;
          os_log_type_t v38 = v12;
          uint32_t v39 = 22;
LABEL_69:
          _os_log_impl(&dword_1830D4000, v37, v38, v16, buf, v39);
          goto LABEL_70;
        }
        if (!v40)
        {
          char v11 = __nwlog_obj();
          os_log_type_t v12 = type;
          if (!os_log_type_enabled(v11, type)) {
            goto LABEL_70;
          }
          uint64_t v27 = handle[6];
          uint64_t v28 = "invalid";
          if (v27)
          {
            unint64_t v29 = *(const char **)(v27 + 16);
            if (v29) {
              uint64_t v28 = v29;
            }
          }
          *(_DWORD *)buf = 136446466;
          int v43 = "nw_protocol_http3_stream_input_available";
          __int16 v44 = 2082;
          uint64_t v45 = (char *)v28;
          unsigned int v16 = "%{public}s protocol %{public}s has invalid input_available callback, backtrace limit exceeded";
          goto LABEL_59;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        char v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        BOOL v18 = os_log_type_enabled(v11, type);
        if (!backtrace_string)
        {
          if (!v18) {
            goto LABEL_70;
          }
          uint64_t v34 = handle[6];
          uint64_t v35 = "invalid";
          if (v34)
          {
            uint64_t v36 = *(const char **)(v34 + 16);
            if (v36) {
              uint64_t v35 = v36;
            }
          }
          *(_DWORD *)buf = 136446466;
          int v43 = "nw_protocol_http3_stream_input_available";
          __int16 v44 = 2082;
          uint64_t v45 = (char *)v35;
          unsigned int v16 = "%{public}s protocol %{public}s has invalid input_available callback, no backtrace";
          goto LABEL_59;
        }
        if (v18)
        {
          uint64_t v19 = handle[6];
          unint64_t v20 = "invalid";
          if (v19)
          {
            unsigned int v21 = *(const char **)(v19 + 16);
            if (v21) {
              unint64_t v20 = v21;
            }
          }
          *(_DWORD *)buf = 136446722;
          int v43 = "nw_protocol_http3_stream_input_available";
          __int16 v44 = 2082;
          uint64_t v45 = (char *)v20;
          __int16 v46 = 2082;
          size_t v47 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s protocol %{public}s has invalid input_available callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(backtrace_string);
      }
LABEL_70:
      if (v10) {
        goto LABEL_71;
      }
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v43 = "nw_protocol_http3_stream_input_available";
    int v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (!__nwlog_fault(v10, &type, &v40)) {
      goto LABEL_70;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_70;
      }
      *(_DWORD *)buf = 136446210;
      int v43 = "nw_protocol_http3_stream_input_available";
      unsigned int v16 = "%{public}s called with null http3_stream";
      goto LABEL_68;
    }
    if (!v40)
    {
      uint64_t v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_70;
      }
      *(_DWORD *)buf = 136446210;
      int v43 = "nw_protocol_http3_stream_input_available";
      unsigned int v16 = "%{public}s called with null http3_stream, backtrace limit exceeded";
      goto LABEL_68;
    }
    int v30 = (char *)__nw_create_backtrace_string();
    uint64_t v22 = __nwlog_obj();
    os_log_type_t v23 = type;
    BOOL v33 = os_log_type_enabled(v22, type);
    if (!v30)
    {
      if (!v33) {
        goto LABEL_70;
      }
      *(_DWORD *)buf = 136446210;
      int v43 = "nw_protocol_http3_stream_input_available";
      unsigned int v16 = "%{public}s called with null http3_stream, no backtrace";
      goto LABEL_68;
    }
    if (v33)
    {
      *(_DWORD *)buf = 136446466;
      int v43 = "nw_protocol_http3_stream_input_available";
      __int16 v44 = 2082;
      uint64_t v45 = v30;
      unint64_t v32 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
      goto LABEL_51;
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v43 = "nw_protocol_http3_stream_input_available";
    int v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (!__nwlog_fault(v10, &type, &v40)) {
      goto LABEL_70;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_70;
      }
      *(_DWORD *)buf = 136446210;
      int v43 = "nw_protocol_http3_stream_input_available";
      unsigned int v16 = "%{public}s called with null protocol";
LABEL_68:
      uint64_t v37 = v22;
      os_log_type_t v38 = v23;
      uint32_t v39 = 12;
      goto LABEL_69;
    }
    if (!v40)
    {
      uint64_t v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_70;
      }
      *(_DWORD *)buf = 136446210;
      int v43 = "nw_protocol_http3_stream_input_available";
      unsigned int v16 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_68;
    }
    int v30 = (char *)__nw_create_backtrace_string();
    uint64_t v22 = __nwlog_obj();
    os_log_type_t v23 = type;
    BOOL v31 = os_log_type_enabled(v22, type);
    if (!v30)
    {
      if (!v31) {
        goto LABEL_70;
      }
      *(_DWORD *)buf = 136446210;
      int v43 = "nw_protocol_http3_stream_input_available";
      unsigned int v16 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_68;
    }
    if (v31)
    {
      *(_DWORD *)buf = 136446466;
      int v43 = "nw_protocol_http3_stream_input_available";
      __int16 v44 = 2082;
      uint64_t v45 = v30;
      unint64_t v32 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_51:
      _os_log_impl(&dword_1830D4000, v22, v23, v32, buf, 0x16u);
    }
  }
  free(v30);
  if (v10) {
LABEL_71:
  }
    free(v10);
}

void ___ZL40nw_http3_stream_fields_process_unblockedP24nw_protocol_http3_stream_block_invoke_2(uint64_t a1)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  if ((*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))())
  {
    uint64_t v2 = *(void *)(a1 + 40);
    if ((*(_WORD *)(v2 + 736) & 0x100) != 0)
    {
      if ((*(_WORD *)(v2 + 736) & 0x800) == 0)
      {
        if (gLogDatapath)
        {
          os_log_type_t v23 = __nwlog_obj();
          BOOL v24 = os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG);
          uint64_t v2 = *(void *)(a1 + 40);
          if (v24)
          {
            int v25 = (const char *)(v2 + 636);
            uint64_t v26 = "";
            int v27 = *(_DWORD *)(*(void *)(v2 + 336) + 1280);
            BOOL v28 = v2 == 0;
            uint64_t v29 = *(void *)(v2 + 240);
            if (v28) {
              int v25 = "";
            }
            else {
              uint64_t v26 = " ";
            }
            *(_DWORD *)buf = 136447234;
            uint32_t v39 = "nw_http3_stream_fields_process_unblocked_block_invoke_2";
            __int16 v40 = 2082;
            unint64_t v41 = v25;
            __int16 v42 = 2080;
            int v43 = (void *)v26;
            __int16 v44 = 1024;
            int v45 = v27;
            __int16 v46 = 2048;
            uint64_t v47 = v29;
            _os_log_impl(&dword_1830D4000, v23, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> delivering deferred input finished", buf, 0x30u);
            uint64_t v2 = *(void *)(a1 + 40);
          }
        }
      }
      int v3 = *(unsigned __int16 *)(v2 + 736);
      unsigned int v4 = v3 & 0xFFFFFEFF | (*(unsigned __int8 *)(v2 + 738) << 16);
      *(_WORD *)(v2 + 736) = v3 & 0xFEFF;
      *(unsigned char *)(v2 + 738) = BYTE2(v4);
      uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 48);
      if (v5)
      {
        uint64_t v6 = *(void *)(v5 + 24);
        if (v6)
        {
          uint64_t v7 = *(void (**)(void))(v6 + 184);
          if (v7)
          {
            v7();
            return;
          }
        }
      }
      __nwlog_obj();
      uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 48);
      char v9 = "invalid";
      if (v8)
      {
        int v10 = *(const char **)(v8 + 16);
        if (v10) {
          char v9 = v10;
        }
      }
      *(_DWORD *)buf = 136446466;
      uint32_t v39 = "nw_http3_stream_fields_process_unblocked_block_invoke";
      __int16 v40 = 2082;
      unint64_t v41 = v9;
      char v11 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v36 = 0;
      if (!__nwlog_fault(v11, &type, &v36)) {
        goto LABEL_44;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v12 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (!os_log_type_enabled(v12, type)) {
          goto LABEL_44;
        }
        uint64_t v14 = *(void *)(*(void *)(a1 + 40) + 48);
        uint64_t v15 = "invalid";
        if (v14)
        {
          unsigned int v16 = *(const char **)(v14 + 16);
          if (v16) {
            uint64_t v15 = v16;
          }
        }
        *(_DWORD *)buf = 136446466;
        uint32_t v39 = "nw_http3_stream_fields_process_unblocked_block_invoke";
        __int16 v40 = 2082;
        unint64_t v41 = v15;
        v17 = "%{public}s protocol %{public}s has invalid input_finished callback";
      }
      else if (v36)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v12 = __nwlog_obj();
        os_log_type_t v13 = type;
        BOOL v19 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v19)
          {
            uint64_t v20 = *(void *)(*(void *)(a1 + 40) + 48);
            unsigned int v21 = "invalid";
            if (v20)
            {
              uint64_t v22 = *(const char **)(v20 + 16);
              if (v22) {
                unsigned int v21 = v22;
              }
            }
            *(_DWORD *)buf = 136446722;
            uint32_t v39 = "nw_http3_stream_fields_process_unblocked_block_invoke";
            __int16 v40 = 2082;
            unint64_t v41 = v21;
            __int16 v42 = 2082;
            int v43 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s protocol %{public}s has invalid input_finished callback, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(backtrace_string);
          goto LABEL_44;
        }
        if (!v19)
        {
LABEL_44:
          if (v11) {
            free(v11);
          }
          return;
        }
        uint64_t v33 = *(void *)(*(void *)(a1 + 40) + 48);
        uint64_t v34 = "invalid";
        if (v33)
        {
          uint64_t v35 = *(const char **)(v33 + 16);
          if (v35) {
            uint64_t v34 = v35;
          }
        }
        *(_DWORD *)buf = 136446466;
        uint32_t v39 = "nw_http3_stream_fields_process_unblocked_block_invoke";
        __int16 v40 = 2082;
        unint64_t v41 = v34;
        v17 = "%{public}s protocol %{public}s has invalid input_finished callback, no backtrace";
      }
      else
      {
        os_log_type_t v12 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (!os_log_type_enabled(v12, type)) {
          goto LABEL_44;
        }
        uint64_t v30 = *(void *)(*(void *)(a1 + 40) + 48);
        BOOL v31 = "invalid";
        if (v30)
        {
          unint64_t v32 = *(const char **)(v30 + 16);
          if (v32) {
            BOOL v31 = v32;
          }
        }
        *(_DWORD *)buf = 136446466;
        uint32_t v39 = "nw_http3_stream_fields_process_unblocked_block_invoke";
        __int16 v40 = 2082;
        unint64_t v41 = v31;
        v17 = "%{public}s protocol %{public}s has invalid input_finished callback, backtrace limit exceeded";
      }
      _os_log_impl(&dword_1830D4000, v12, v13, v17, buf, 0x16u);
      goto LABEL_44;
    }
  }
}

void nw_http3_start_decoder_stream_if_needed(uint64_t a1)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  if (!*(void *)(a1 + 1072))
  {
    outbound = (_OWORD *)nw_http3_uni_stream_create_outbound(a1, 3, 0);
    *(void *)(a1 + 1072) = outbound;
    _OWORD *outbound = *(_OWORD *)a1;
    nw_protocol_set_input_handler(*(void *)(a1 + 1072), a1);
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      unsigned int v4 = *(void (***)(void, void))(v3 + 24);
      if (v4)
      {
        uint64_t v5 = *v4;
        if (v5)
        {
          v5(*(void *)(a1 + 32), *(void *)(a1 + 1072));
          goto LABEL_6;
        }
      }
      __nwlog_obj();
      uint64_t v8 = *(const char **)(v3 + 16);
      if (!v8) {
        uint64_t v8 = "invalid";
      }
    }
    else
    {
      __nwlog_obj();
      uint64_t v8 = "invalid";
    }
    *(_DWORD *)buf = 136446466;
    uint64_t v33 = "nw_http3_start_decoder_stream_if_needed";
    __int16 v34 = 2082;
    uint64_t v35 = v8;
    int v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (__nwlog_fault(v10, &type, &v30))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (!os_log_type_enabled(v11, type)) {
          goto LABEL_43;
        }
        os_log_type_t v13 = "invalid";
        if (v3 && *(void *)(v3 + 16)) {
          os_log_type_t v13 = *(const char **)(v3 + 16);
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v33 = "nw_http3_start_decoder_stream_if_needed";
        __int16 v34 = 2082;
        uint64_t v35 = v13;
        uint64_t v14 = "%{public}s protocol %{public}s has invalid add_input_handler callback";
LABEL_42:
        _os_log_impl(&dword_1830D4000, v11, v12, v14, buf, 0x16u);
        goto LABEL_43;
      }
      if (!v30)
      {
        char v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (!os_log_type_enabled(v11, type)) {
          goto LABEL_43;
        }
        BOOL v18 = "invalid";
        if (v3 && *(void *)(v3 + 16)) {
          BOOL v18 = *(const char **)(v3 + 16);
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v33 = "nw_http3_start_decoder_stream_if_needed";
        __int16 v34 = 2082;
        uint64_t v35 = v18;
        uint64_t v14 = "%{public}s protocol %{public}s has invalid add_input_handler callback, backtrace limit exceeded";
        goto LABEL_42;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v16 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (!v16) {
          goto LABEL_43;
        }
        BOOL v19 = "invalid";
        if (v3 && *(void *)(v3 + 16)) {
          BOOL v19 = *(const char **)(v3 + 16);
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v33 = "nw_http3_start_decoder_stream_if_needed";
        __int16 v34 = 2082;
        uint64_t v35 = v19;
        uint64_t v14 = "%{public}s protocol %{public}s has invalid add_input_handler callback, no backtrace";
        goto LABEL_42;
      }
      if (v16)
      {
        v17 = "invalid";
        if (v3 && *(void *)(v3 + 16)) {
          v17 = *(const char **)(v3 + 16);
        }
        *(_DWORD *)buf = 136446722;
        uint64_t v33 = "nw_http3_start_decoder_stream_if_needed";
        __int16 v34 = 2082;
        uint64_t v35 = v17;
        __int16 v36 = 2082;
        uint64_t v37 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s protocol %{public}s has invalid add_input_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(backtrace_string);
    }
LABEL_43:
    if (v10) {
      free(v10);
    }
    if (!v3)
    {
      __nwlog_obj();
      char v9 = "invalid";
      goto LABEL_47;
    }
LABEL_6:
    uint64_t v6 = *(void *)(v3 + 24);
    if (v6)
    {
      uint64_t v7 = *(void (**)(uint64_t, void))(v6 + 24);
      if (v7)
      {
        v7(v3, *(void *)(a1 + 1072));
        return;
      }
    }
    __nwlog_obj();
    char v9 = *(const char **)(v3 + 16);
    if (!v9) {
      char v9 = "invalid";
    }
LABEL_47:
    *(_DWORD *)buf = 136446466;
    uint64_t v33 = "nw_http3_start_decoder_stream_if_needed";
    __int16 v34 = 2082;
    uint64_t v35 = v9;
    uint64_t v20 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (!__nwlog_fault(v20, &type, &v30)) {
      goto LABEL_73;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v21 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_73;
      }
      os_log_type_t v23 = "invalid";
      if (v3 && *(void *)(v3 + 16)) {
        os_log_type_t v23 = *(const char **)(v3 + 16);
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v33 = "nw_http3_start_decoder_stream_if_needed";
      __int16 v34 = 2082;
      uint64_t v35 = v23;
      BOOL v24 = "%{public}s protocol %{public}s has invalid connect callback";
    }
    else if (v30)
    {
      int v25 = (char *)__nw_create_backtrace_string();
      unsigned int v21 = __nwlog_obj();
      os_log_type_t v22 = type;
      BOOL v26 = os_log_type_enabled(v21, type);
      if (v25)
      {
        if (v26)
        {
          int v27 = "invalid";
          if (v3 && *(void *)(v3 + 16)) {
            int v27 = *(const char **)(v3 + 16);
          }
          *(_DWORD *)buf = 136446722;
          uint64_t v33 = "nw_http3_start_decoder_stream_if_needed";
          __int16 v34 = 2082;
          uint64_t v35 = v27;
          __int16 v36 = 2082;
          uint64_t v37 = v25;
          _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s protocol %{public}s has invalid connect callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v25);
        goto LABEL_73;
      }
      if (!v26)
      {
LABEL_73:
        if (v20) {
          free(v20);
        }
        return;
      }
      uint64_t v29 = "invalid";
      if (v3 && *(void *)(v3 + 16)) {
        uint64_t v29 = *(const char **)(v3 + 16);
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v33 = "nw_http3_start_decoder_stream_if_needed";
      __int16 v34 = 2082;
      uint64_t v35 = v29;
      BOOL v24 = "%{public}s protocol %{public}s has invalid connect callback, no backtrace";
    }
    else
    {
      unsigned int v21 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_73;
      }
      BOOL v28 = "invalid";
      if (v3 && *(void *)(v3 + 16)) {
        BOOL v28 = *(const char **)(v3 + 16);
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v33 = "nw_http3_start_decoder_stream_if_needed";
      __int16 v34 = 2082;
      uint64_t v35 = v28;
      BOOL v24 = "%{public}s protocol %{public}s has invalid connect callback, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v21, v22, v24, buf, 0x16u);
    goto LABEL_73;
  }
}

void nw_http3_decoder_stream_process_output(uint64_t a1)
{
  uint64_t v2 = (_WORD *)(a1 + 1373);
  uint64_t v106 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = "nw_http3_decoder_stream_process_output";
  while ((*v2 & 0x4000) == 0)
  {
    if (*(_DWORD *)(a1 + 528) == *(_DWORD *)(a1 + 532)) {
      goto LABEL_53;
    }
    v103[0] = 0;
    v103[1] = v103;
    uint64_t v4 = *(void *)(a1 + 1072);
    if (!v4) {
      return;
    }
    uint64_t v5 = *(void *)(v4 + 24);
    if (!v5) {
      return;
    }
    uint64_t v6 = *(unsigned int (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, void *))(v5 + 88);
    if (!v6 || !v6(*(void *)(a1 + 1072), a1, 6, 6, 0xFFFFFFFFLL, v103)) {
      return;
    }
    int v7 = *(_DWORD *)(a1 + 528);
    int v8 = v7 - *(_DWORD *)(a1 + 532);
    if (!v8)
    {
      char v9 = *(FILE **)(a1 + 544);
      if (v9)
      {
        fwrite("qdec: debug: ", 0xDuLL, 1uLL, v9);
        fwrite("no ICI instruction necessary: emitting zero bytes", 0x31uLL, 1uLL, *(FILE **)(a1 + 544));
        fputc(10, *(FILE **)(a1 + 544));
      }
      goto LABEL_34;
    }
    int v10 = *(_DWORD *)(a1 + 516);
    if (v10)
    {
      uint64_t v11 = (v8 + 2 * v10) % (2 * v10);
      if (v11 > 0x3E)
      {
        char v98 = 63;
        unint64_t v12 = v11 - 63;
        if ((unint64_t)(v11 - 63) < 0x80)
        {
          uint64_t v14 = &v98;
          uint64_t v13 = 1;
        }
        else
        {
          char v99 = v12 | 0x80;
          if (v12 < 0x4000)
          {
            v12 >>= 7;
            uint64_t v13 = 2;
            uint64_t v14 = &v99;
          }
          else
          {
            char v100 = (v12 >> 7) | 0x80;
            if (v12 < 0x200000)
            {
              v12 >>= 14;
              uint64_t v13 = 3;
              uint64_t v14 = &v100;
            }
            else
            {
              char v101 = (v12 >> 14) | 0x80;
              if (v12 >> 28)
              {
                char v102 = (v12 >> 21) | 0x80;
                uint64_t v13 = 5;
                v12 >>= 28;
                uint64_t v14 = &v102;
              }
              else
              {
                v12 >>= 21;
                uint64_t v13 = 4;
                uint64_t v14 = &v101;
              }
            }
          }
        }
        uint64_t v15 = v14 + 2;
        *(&v98 + v13) = v12;
        if (v14 + 2 <= &v98) {
          goto LABEL_34;
        }
        goto LABEL_22;
      }
    }
    else
    {
      LODWORD(v11) = 0;
    }
    char v98 = v11;
    uint64_t v15 = &v99;
LABEL_22:
    BOOL v16 = *(FILE **)(a1 + 544);
    if (v16)
    {
      fwrite("qdec: debug: ", 0xDuLL, 1uLL, v16);
      fprintf(*(FILE **)(a1 + 544), "wrote ICI: count=%u", v11);
      fputc(10, *(FILE **)(a1 + 544));
      int v7 = *(_DWORD *)(a1 + 528);
    }
    *(_DWORD *)(a1 + 532) = v7;
    *(_DWORD *)(a1 + 520) += v15 - &v98;
    if (v15 - &v98 >= 1)
    {
      *(void *)buf = 0;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x2000000000;
      unsigned int v105 = 0;
      v91[0] = MEMORY[0x1E4F143A8];
      v91[1] = 0x40000000;
      v92 = (uint64_t (*)(void *))___ZL38nw_http3_decoder_stream_process_outputP17nw_protocol_http3_block_invoke;
      unsigned int v93 = &unk_1E5247520;
      unsigned int v94 = buf;
      uint64_t v95 = v15 - &v98;
      int v96 = &v98;
      uint64_t v97 = a1;
      uint64_t v17 = v103[0];
      do
      {
        if (!v17) {
          break;
        }
        uint64_t v18 = *(void *)(v17 + 32);
        char v19 = v92(v91);
        uint64_t v17 = v18;
      }
      while ((v19 & 1) != 0);
      _Block_object_dispose(buf, 8);
      goto LABEL_50;
    }
LABEL_34:
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = v3;
    uint64_t v20 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v89 = 0;
    if (!__nwlog_fault(v20, &type, &v89)) {
      goto LABEL_48;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v21 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = v3;
      os_log_type_t v23 = v21;
      os_log_type_t v24 = v22;
      int v25 = "%{public}s Failed to generate ici";
      goto LABEL_47;
    }
    if (!v89)
    {
      BOOL v31 = __nwlog_obj();
      os_log_type_t v32 = type;
      if (!os_log_type_enabled(v31, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = v3;
      os_log_type_t v23 = v31;
      os_log_type_t v24 = v32;
      int v25 = "%{public}s Failed to generate ici, backtrace limit exceeded";
      goto LABEL_47;
    }
    BOOL v26 = v3;
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v28 = __nwlog_obj();
    os_log_type_t v29 = type;
    BOOL v30 = os_log_type_enabled(v28, type);
    if (backtrace_string)
    {
      if (v30)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = v26;
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s Failed to generate ici, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      uint64_t v3 = v26;
      goto LABEL_48;
    }
    uint64_t v3 = v26;
    if (v30)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = v26;
      os_log_type_t v23 = v28;
      os_log_type_t v24 = v29;
      int v25 = "%{public}s Failed to generate ici, no backtrace";
LABEL_47:
      _os_log_impl(&dword_1830D4000, v23, v24, v25, buf, 0xCu);
    }
LABEL_48:
    if (v20) {
      free(v20);
    }
LABEL_50:
    uint64_t v33 = *(void *)(v4 + 24);
    if (v33)
    {
      __int16 v34 = *(void (**)(uint64_t, void *))(v33 + 96);
      if (v34)
      {
        v34(v4, v103);
        goto LABEL_53;
      }
    }
    __nwlog_obj();
    __int16 v44 = *(const char **)(v4 + 16);
    if (!v44) {
      __int16 v44 = "invalid";
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = v3;
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v44;
    int v45 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v89 = 0;
    v87 = (char *)v45;
    if (__nwlog_fault(v45, &type, &v89))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __int16 v46 = __nwlog_obj();
        os_log_type_t v47 = type;
        if (!os_log_type_enabled(v46, type)) {
          goto LABEL_93;
        }
        uint64_t v48 = *(const char **)(v4 + 16);
        if (!v48) {
          uint64_t v48 = "invalid";
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = v3;
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v48;
        int v49 = v46;
        os_log_type_t v50 = v47;
        uint64_t v51 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback";
        goto LABEL_92;
      }
      if (!v89)
      {
        unsigned int v56 = __nwlog_obj();
        os_log_type_t v57 = type;
        if (!os_log_type_enabled(v56, type)) {
          goto LABEL_93;
        }
        uint64_t v58 = *(const char **)(v4 + 16);
        if (!v58) {
          uint64_t v58 = "invalid";
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = v3;
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v58;
        int v49 = v56;
        os_log_type_t v50 = v57;
        uint64_t v51 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback, backtrace limit exceeded";
        goto LABEL_92;
      }
      uint64_t v52 = (char *)__nw_create_backtrace_string();
      unint64_t v53 = __nwlog_obj();
      os_log_type_t v85 = type;
      BOOL v54 = os_log_type_enabled(v53, type);
      if (v52)
      {
        if (v54)
        {
          v55 = *(const char **)(v4 + 16);
          if (!v55) {
            v55 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = v3;
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v55;
          *(_WORD *)&buf[22] = 2082;
          unsigned int v105 = v52;
          _os_log_impl(&dword_1830D4000, v53, v85, "%{public}s protocol %{public}s has invalid finalize_output_frames callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v52);
        goto LABEL_93;
      }
      if (v54)
      {
        v59 = *(const char **)(v4 + 16);
        if (!v59) {
          v59 = "invalid";
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = v3;
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v59;
        int v49 = v53;
        os_log_type_t v50 = v85;
        uint64_t v51 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback, no backtrace";
LABEL_92:
        _os_log_impl(&dword_1830D4000, v49, v50, v51, buf, 0x16u);
      }
    }
LABEL_93:
    if (v87) {
      free(v87);
    }
LABEL_53:
    uint64_t v35 = *(void *)(a1 + 944);
    if (!v35) {
      return;
    }
    if (*(unsigned char *)(v35 + 634)
      && nw_http3_stream_send_section_ack(*(void *)(a1 + 944))
      && !nw_http3_stream_received_fields_done(v35))
    {
      nw_protocol_http3_stream_input_available((nw_protocol *)v35, v36);
    }
    nw_http3_stream_send_stream_cancellation(v35);
    int v37 = *(unsigned __int16 *)(v35 + 736);
    if ((v37 & 0x400) != 0 && !*(void *)(v35 + 528) && !*(unsigned char *)(v35 + 634) && !*(unsigned char *)(v35 + 635))
    {
      unsigned int v38 = v37 & 0xFFFFFBFF | (*(unsigned __int8 *)(v35 + 738) << 16);
      *(_WORD *)(v35 + 736) = v37 & 0xFBFF;
      *(unsigned char *)(v35 + 738) = BYTE2(v38);
      uint64_t v39 = *(void *)(v35 + 32);
      if (!v39
        || (uint64_t v40 = *(void *)(v39 + 24)) == 0
        || (unint64_t v41 = *(void (**)(uint64_t, uint64_t))(v40 + 32)) == 0)
      {
        __nwlog_obj();
        uint64_t v42 = *(void *)(v35 + 32);
        if (v42)
        {
          int v43 = *(const char **)(v42 + 16);
          if (!v43) {
            int v43 = "invalid";
          }
        }
        else
        {
          int v43 = "invalid";
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_decoder_stream_output_available";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v43;
        uint64_t v60 = (const char *)_os_log_send_and_compose_impl();
        LOBYTE(v103[0]) = 16;
        char v98 = 0;
        size_t v88 = (char *)v60;
        if (!__nwlog_fault(v60, v103, &v98)) {
          goto LABEL_130;
        }
        if (LOBYTE(v103[0]) == 17)
        {
          unint64_t v61 = __nwlog_obj();
          os_log_type_t v62 = v103[0];
          if (os_log_type_enabled(v61, v103[0]))
          {
            uint64_t v63 = *(void *)(v35 + 32);
            if (v63)
            {
              size_t v64 = *(const char **)(v63 + 16);
              if (!v64) {
                size_t v64 = "invalid";
              }
            }
            else
            {
              size_t v64 = "invalid";
            }
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_decoder_stream_output_available";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v64;
            v76 = v61;
            os_log_type_t v77 = v62;
            unint64_t v78 = "%{public}s protocol %{public}s has invalid disconnect callback";
            goto LABEL_129;
          }
          goto LABEL_130;
        }
        if (v98)
        {
          v65 = (char *)__nw_create_backtrace_string();
          uint64_t v66 = __nwlog_obj();
          os_log_type_t v86 = v103[0];
          BOOL v67 = os_log_type_enabled(v66, v103[0]);
          if (v65)
          {
            if (v67)
            {
              uint64_t v68 = *(void *)(v35 + 32);
              if (v68)
              {
                v69 = *(const char **)(v68 + 16);
                if (!v69) {
                  v69 = "invalid";
                }
              }
              else
              {
                v69 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_http3_stream_decoder_stream_output_available";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v69;
              *(_WORD *)&buf[22] = 2082;
              unsigned int v105 = v65;
              _os_log_impl(&dword_1830D4000, v66, v86, "%{public}s protocol %{public}s has invalid disconnect callback, dumping backtrace:%{public}s", buf, 0x20u);
            }
            free(v65);
            goto LABEL_130;
          }
          if (!v67)
          {
LABEL_130:
            if (v88) {
              free(v88);
            }
            goto LABEL_3;
          }
          uint64_t v74 = *(void *)(v35 + 32);
          if (v74)
          {
            uint64_t v75 = *(const char **)(v74 + 16);
            if (!v75) {
              uint64_t v75 = "invalid";
            }
          }
          else
          {
            uint64_t v75 = "invalid";
          }
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_decoder_stream_output_available";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v75;
          v76 = v66;
          os_log_type_t v77 = v86;
          unint64_t v78 = "%{public}s protocol %{public}s has invalid disconnect callback, no backtrace";
        }
        else
        {
          uint64_t v70 = __nwlog_obj();
          os_log_type_t v71 = v103[0];
          if (!os_log_type_enabled(v70, v103[0])) {
            goto LABEL_130;
          }
          uint64_t v72 = *(void *)(v35 + 32);
          if (v72)
          {
            malloc_type_id_t v73 = *(const char **)(v72 + 16);
            if (!v73) {
              malloc_type_id_t v73 = "invalid";
            }
          }
          else
          {
            malloc_type_id_t v73 = "invalid";
          }
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_decoder_stream_output_available";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v73;
          v76 = v70;
          os_log_type_t v77 = v71;
          unint64_t v78 = "%{public}s protocol %{public}s has invalid disconnect callback, backtrace limit exceeded";
        }
LABEL_129:
        _os_log_impl(&dword_1830D4000, v76, v77, v78, buf, 0x16u);
        goto LABEL_130;
      }
      v41(v39, v35);
    }
LABEL_3:
    if (v35 == *(void *)(a1 + 944)) {
      return;
    }
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = v3;
  uint64_t v79 = (char *)_os_log_send_and_compose_impl();
  LOBYTE(v103[0]) = 16;
  char v98 = 0;
  if (!__nwlog_fault(v79, v103, &v98)) {
    goto LABEL_146;
  }
  if (LOBYTE(v103[0]) == 17)
  {
    unint64_t v80 = __nwlog_obj();
    os_log_type_t v81 = v103[0];
    if (os_log_type_enabled(v80, v103[0]))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = v3;
      v82 = "%{public}s Must finalize output frames from decoder stream immediately";
      goto LABEL_145;
    }
    goto LABEL_146;
  }
  if (!v98)
  {
    unint64_t v80 = __nwlog_obj();
    os_log_type_t v81 = v103[0];
    if (!os_log_type_enabled(v80, v103[0])) {
      goto LABEL_146;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = v3;
    v82 = "%{public}s Must finalize output frames from decoder stream immediately, backtrace limit exceeded";
    goto LABEL_145;
  }
  unsigned int v83 = (char *)__nw_create_backtrace_string();
  unint64_t v80 = __nwlog_obj();
  os_log_type_t v81 = v103[0];
  BOOL v84 = os_log_type_enabled(v80, v103[0]);
  if (v83)
  {
    if (v84)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = v3;
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v83;
      _os_log_impl(&dword_1830D4000, v80, v81, "%{public}s Must finalize output frames from decoder stream immediately, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v83);
    goto LABEL_146;
  }
  if (v84)
  {
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = v3;
    v82 = "%{public}s Must finalize output frames from decoder stream immediately, no backtrace";
LABEL_145:
    _os_log_impl(&dword_1830D4000, v80, v81, v82, buf, 0xCu);
  }
LABEL_146:
  if (v79) {
    free(v79);
  }
}

uint64_t ___ZL38nw_http3_decoder_stream_process_outputP17nw_protocol_http3_block_invoke(void *a1, uint64_t a2)
{
  LODWORD(__n) = 0;
  uint64_t v4 = (void *)nw_frame_unclaimed_bytes(a2, &__n);
  uint64_t v5 = *(void *)(*(void *)(a1[4] + 8) + 24);
  unint64_t v6 = a1[5] - v5;
  int v7 = (const void *)(a1[6] + v5);
  if (v6 >= __n)
  {
    memcpy(v4, v7, __n);
  }
  else
  {
    memcpy(v4, v7, a1[5] - v5);
    nw_frame_claim(a2, v8, 0, __n - v6);
  }
  *(void *)(*(void *)(a1[4] + 8) + 24) += __n;
  return 1;
}

uint64_t nw_http3_stream_send_section_ack(uint64_t a1)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (*(unsigned char *)(a1 + 634))
    {
      *(void *)os_log_type_t type = 0;
      BOOL v26 = type;
      int output_frames = nw_http3_decoder_stream_get_output_frames(*(void *)(a1 + 336), a1);
      BOOL v3 = output_frames != 0;
      if (output_frames)
      {
        *(void *)buf = 0;
        *(void *)&buf[8] = buf;
        *(void *)&buf[16] = 0x2000000000;
        uint64_t v29 = 0;
        v20[0] = MEMORY[0x1E4F143A8];
        v20[1] = 0x40000000;
        unsigned int v21 = ___ZL32nw_http3_stream_send_section_ackP24nw_protocol_http3_stream_block_invoke;
        os_log_type_t v22 = &unk_1E5247430;
        os_log_type_t v23 = buf;
        uint64_t v24 = a1;
        uint64_t v4 = *(void *)type;
        do
        {
          if (!v4) {
            break;
          }
          uint64_t v5 = *(void *)(v4 + 32);
          char v6 = ((uint64_t (*)(void *))v21)(v20);
          uint64_t v4 = v5;
        }
        while ((v6 & 1) != 0);
        nw_http3_decoder_stream_finalize_output_frames(*(void *)(a1 + 336), a1, (uint64_t)type);
        *(unsigned char *)(a1 + 634) = 0;
        _Block_object_dispose(buf, 8);
      }
      return v3;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http3_stream_send_section_ack";
    unint64_t v12 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (!__nwlog_fault(v12, type, &v27)) {
      goto LABEL_40;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v13 = __nwlog_obj();
      os_log_type_t v14 = type[0];
      if (os_log_type_enabled(v13, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_send_section_ack";
        uint64_t v15 = "%{public}s No section ack to send";
LABEL_39:
        _os_log_impl(&dword_1830D4000, v13, v14, v15, buf, 0xCu);
      }
    }
    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v13 = __nwlog_obj();
      os_log_type_t v14 = type[0];
      BOOL v19 = os_log_type_enabled(v13, type[0]);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_send_section_ack";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s No section ack to send, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_40;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_send_section_ack";
        uint64_t v15 = "%{public}s No section ack to send, no backtrace";
        goto LABEL_39;
      }
    }
    else
    {
      uint64_t v13 = __nwlog_obj();
      os_log_type_t v14 = type[0];
      if (os_log_type_enabled(v13, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_send_section_ack";
        uint64_t v15 = "%{public}s No section ack to send, backtrace limit exceeded";
        goto LABEL_39;
      }
    }
LABEL_40:
    if (v12) {
      free(v12);
    }
    return 1;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_http3_stream_send_section_ack";
  uint64_t v8 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  char v27 = 0;
  if (__nwlog_fault(v8, type, &v27))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      char v9 = __nwlog_obj();
      os_log_type_t v10 = type[0];
      if (os_log_type_enabled(v9, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_send_section_ack";
        uint64_t v11 = "%{public}s called with null http3_stream";
LABEL_33:
        _os_log_impl(&dword_1830D4000, v9, v10, v11, buf, 0xCu);
      }
    }
    else if (v27)
    {
      BOOL v16 = (char *)__nw_create_backtrace_string();
      char v9 = __nwlog_obj();
      os_log_type_t v10 = type[0];
      BOOL v17 = os_log_type_enabled(v9, type[0]);
      if (v16)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_send_section_ack";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v16;
          _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null http3_stream, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v16);
        goto LABEL_34;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_send_section_ack";
        uint64_t v11 = "%{public}s called with null http3_stream, no backtrace";
        goto LABEL_33;
      }
    }
    else
    {
      char v9 = __nwlog_obj();
      os_log_type_t v10 = type[0];
      if (os_log_type_enabled(v9, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_send_section_ack";
        uint64_t v11 = "%{public}s called with null http3_stream, backtrace limit exceeded";
        goto LABEL_33;
      }
    }
  }
LABEL_34:
  if (v8) {
    free(v8);
  }
  return 0;
}

uint64_t nw_http3_stream_received_fields_done(uint64_t a1)
{
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 372);
  if (v1 > 8) {
    return 0;
  }
  int v3 = 1 << v1;
  if ((v3 & 0x155) != 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v4 = *(_DWORD *)(a1 + 372);
    *(_DWORD *)buf = 136446466;
    unsigned int v56 = "nw_http3_stream_received_fields_done";
    __int16 v57 = 1024;
    *(_DWORD *)uint64_t v58 = v4;
    uint64_t v5 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v53 = 0;
    if (!__nwlog_fault(v5, &type, &v53)) {
      goto LABEL_48;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v6 = gLogObj;
      os_log_type_t v7 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_48;
      }
      int v8 = *(_DWORD *)(a1 + 372);
      *(_DWORD *)buf = 136446466;
      unsigned int v56 = "nw_http3_stream_received_fields_done";
      __int16 v57 = 1024;
      *(_DWORD *)uint64_t v58 = v8;
      char v9 = "%{public}s Unexpected input state %d";
    }
    else if (v53)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v6 = gLogObj;
      os_log_type_t v7 = type;
      BOOL v25 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v25)
        {
          int v26 = *(_DWORD *)(a1 + 372);
          *(_DWORD *)buf = 136446722;
          unsigned int v56 = "nw_http3_stream_received_fields_done";
          __int16 v57 = 1024;
          *(_DWORD *)uint64_t v58 = v26;
          *(_WORD *)&v58[4] = 2082;
          *(void *)&v58[6] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s Unexpected input state %d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(backtrace_string);
LABEL_48:
        if (v5)
        {
          uint64_t v42 = (char *)v5;
LABEL_50:
          free(v42);
        }
        return 2;
      }
      if (!v25) {
        goto LABEL_48;
      }
      int v41 = *(_DWORD *)(a1 + 372);
      *(_DWORD *)buf = 136446466;
      unsigned int v56 = "nw_http3_stream_received_fields_done";
      __int16 v57 = 1024;
      *(_DWORD *)uint64_t v58 = v41;
      char v9 = "%{public}s Unexpected input state %d, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v6 = gLogObj;
      os_log_type_t v7 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_48;
      }
      int v33 = *(_DWORD *)(a1 + 372);
      *(_DWORD *)buf = 136446466;
      unsigned int v56 = "nw_http3_stream_received_fields_done";
      __int16 v57 = 1024;
      *(_DWORD *)uint64_t v58 = v33;
      char v9 = "%{public}s Unexpected input state %d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v6, v7, v9, buf, 0x12u);
    goto LABEL_48;
  }
  if ((v3 & 0xA) == 0)
  {
    BOOL v27 = nw_http_parsed_fields_copy_trailer_fields(*(void **)(a1 + 504));
    if (v27)
    {
      BOOL v28 = (void *)v27;
      nw_http_metadata_set_trailer_fields(*(void **)(a1 + 400), (void *)v27);
      uint64_t v29 = *(_DWORD **)(a1 + 376);
      int v30 = nw_frame_unclaimed_length(v29);
      nw_frame_claim((uint64_t)v29, v31, v30, 0);
      nw_frame_set_metadata(*(void *)(a1 + 376), *(NSObject **)(a1 + 400), 1, 1);
      goto LABEL_33;
    }
LABEL_34:
    *(void *)(a1 + 264) = 270;
    nw_protocol_http3_stream_error((nw_protocol *)a1, (nw_protocol *)a1, 94);
    nw_protocol_http3_stream_disconnect((nw_protocol *)a1, (nw_protocol *)a1);
    return 2;
  }
  uint64_t v10 = *(void *)(a1 + 336);
  if (!v10)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    unsigned int v56 = "nw_http3_stream_received_fields_done";
    int v43 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v53 = 0;
    if (__nwlog_fault(v43, &type, &v53))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __int16 v44 = __nwlog_obj();
        os_log_type_t v45 = type;
        if (os_log_type_enabled(v44, type))
        {
          *(_DWORD *)buf = 136446210;
          unsigned int v56 = "nw_http3_stream_received_fields_done";
          __int16 v46 = "%{public}s called with null http3";
LABEL_73:
          _os_log_impl(&dword_1830D4000, v44, v45, v46, buf, 0xCu);
        }
      }
      else if (v53)
      {
        os_log_type_t v47 = (char *)__nw_create_backtrace_string();
        __int16 v44 = __nwlog_obj();
        os_log_type_t v45 = type;
        BOOL v48 = os_log_type_enabled(v44, type);
        if (v47)
        {
          if (v48)
          {
            *(_DWORD *)buf = 136446466;
            unsigned int v56 = "nw_http3_stream_received_fields_done";
            __int16 v57 = 2082;
            *(void *)uint64_t v58 = v47;
            _os_log_impl(&dword_1830D4000, v44, v45, "%{public}s called with null http3, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v47);
          goto LABEL_74;
        }
        if (v48)
        {
          *(_DWORD *)buf = 136446210;
          unsigned int v56 = "nw_http3_stream_received_fields_done";
          __int16 v46 = "%{public}s called with null http3, no backtrace";
          goto LABEL_73;
        }
      }
      else
      {
        __int16 v44 = __nwlog_obj();
        os_log_type_t v45 = type;
        if (os_log_type_enabled(v44, type))
        {
          *(_DWORD *)buf = 136446210;
          unsigned int v56 = "nw_http3_stream_received_fields_done";
          __int16 v46 = "%{public}s called with null http3, backtrace limit exceeded";
          goto LABEL_73;
        }
      }
    }
LABEL_74:
    if (!v43) {
      return 2;
    }
    uint64_t v42 = (char *)v43;
    goto LABEL_50;
  }
  uint64_t v11 = (_WORD *)(v10 + 1373);
  metadata_with_parsed_fields = nw_http_create_metadata_with_parsed_fields(*(void **)(a1 + 504), *(_WORD *)(v10 + 1373) & 1);
  char v13 = *(unsigned char *)(a1 + 408);
  if (v13)
  {
    os_log_type_t v14 = *(void **)(a1 + 400);
    if (v14)
    {
      os_release(v14);
      char v13 = *(unsigned char *)(a1 + 408);
    }
  }
  *(void *)(a1 + 400) = metadata_with_parsed_fields;
  *(unsigned char *)(a1 + 408) = v13 | 1;
  if (!metadata_with_parsed_fields) {
    goto LABEL_34;
  }
  nw_http_metadata_set_version(metadata_with_parsed_fields, 5);
  int v15 = (unsigned __int16)*v11;
  int v16 = v15 | (*(unsigned __int8 *)(v10 + 1375) << 16);
  if (v15)
  {
    BOOL v23 = 0;
  }
  else
  {
    if ((v16 & 0x100000) != 0 && *(void *)(v10 + 1240) && *(_DWORD *)(v10 + 1276))
    {
      if ((v16 & 0x400000) == 0)
      {
        BOOL v17 = __nwlog_obj();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
        {
          int v18 = *(_DWORD *)(v10 + 1280);
          *(_DWORD *)buf = 136446978;
          unsigned int v56 = "nw_http3_stream_received_fields_done";
          __int16 v57 = 2082;
          *(void *)uint64_t v58 = v10 + 1289;
          *(_WORD *)&v58[8] = 2080;
          *(void *)&v58[10] = " ";
          __int16 v59 = 1024;
          LODWORD(v60) = v18;
          _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> decreasing QUIC keepalive frequency after receiving a response", buf, 0x26u);
        }
      }
      int v19 = (unsigned __int16)*v11;
      unsigned int v20 = (v19 | (*(unsigned __int8 *)(v10 + 1375) << 16)) & 0xFFEFFFFF;
      _WORD *v11 = v19;
      *(unsigned char *)(v10 + 1375) = BYTE2(v20);
      nw_quic_connection_set_keepalive(*(void **)(v10 + 1240), 0xFFFF);
    }
    uint64_t v21 = *(void *)(v10 + 1024);
    *(void *)(v10 + 1024) = v21 - 1;
    if (!v21)
    {
      if (gLogDatapath)
      {
        int v49 = __nwlog_obj();
        if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v50 = *(void *)(v10 + 1024);
          *(_DWORD *)buf = 136446978;
          unsigned int v56 = "nw_http3_stream_received_fields_done";
          __int16 v57 = 2082;
          *(void *)uint64_t v58 = "http3->outstanding_sent_requests";
          *(_WORD *)&v58[8] = 2048;
          *(void *)&v58[10] = 1;
          __int16 v59 = 2048;
          uint64_t v60 = v50;
          _os_log_impl(&dword_1830D4000, v49, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
        }
      }
      *(void *)(v10 + 1024) = 0;
    }
    id v22 = nw_http_metadata_copy_response(*(void **)(a1 + 400));
    BOOL v23 = (nw_http_response_get_status_code(v22) - 100) < 0x64;
    if (v22) {
      os_release(v22);
    }
  }
  nw_http_connection_metadata_increment_inbound_message_count(*(void **)(v10 + 1248));
  nw_http_transaction_metadata_set_inbound_message(*(void **)(a1 + 392), *(void **)(a1 + 400));
  nw::http::content_length_manager::set_inbound_message((nw::http::content_length_manager *)(a1 + 272), *(nw_protocol_metadata **)(a1 + 400));
  __int16 v34 = *(_DWORD **)(a1 + 376);
  int v35 = nw_frame_unclaimed_length(v34);
  nw_frame_claim((uint64_t)v34, v36, v35, 0);
  uint64_t v37 = *(void *)(a1 + 376);
  unsigned int v38 = *(NSObject **)(a1 + 400);
  int is_metadata_complete = nw_frame_is_metadata_complete(v37);
  nw_frame_set_metadata(v37, v38, 1, is_metadata_complete | v23);
  int v40 = 0;
  if (v23) {
    goto LABEL_54;
  }
  if ((*(_WORD *)(a1 + 736) & 0x10) != 0)
  {
    int v40 = 8;
LABEL_54:
    uint64_t result = 0;
    *(_DWORD *)(a1 + 372) = v40;
    return result;
  }
  *(_DWORD *)(a1 + 372) = 4;
  uint64_t result = *(void *)(a1 + 400);
  if (result)
  {
    uint64_t result = (uint64_t)nw_http_metadata_copy_request((void *)result);
    if (result)
    {
      BOOL v28 = (void *)result;
      if (nw_http_request_has_method((void *)result, (uint64_t)"CONNECT-UDP"))
      {
        v52[0] = MEMORY[0x1E4F143A8];
        v52[1] = 0x40000000;
        v52[2] = ___ZL36nw_http3_stream_received_fields_doneP24nw_protocol_http3_stream_block_invoke;
        v52[3] = &__block_descriptor_tmp_92_61768;
        v52[4] = a1;
        nw_http_fields_access_value_by_name(v28, (unint64_t)"Datagram-Flow-Id", v52);
LABEL_57:
        *(_WORD *)(a1 + 736) |= 0x8000u;
        goto LABEL_33;
      }
      if (nw_http_request_has_method(v28, (uint64_t)"CONNECT"))
      {
        v51[0] = MEMORY[0x1E4F143A8];
        v51[1] = 0x40000000;
        v51[2] = ___ZL36nw_http3_stream_received_fields_doneP24nw_protocol_http3_stream_block_invoke_93;
        v51[3] = &__block_descriptor_tmp_96_61769;
        v51[4] = a1;
        v51[5] = v10;
        nw_http_request_access_extended_connect_protocol(v28, v51);
        goto LABEL_57;
      }
LABEL_33:
      os_release(v28);
      return 0;
    }
  }
  return result;
}

void nw_http3_stream_send_stream_cancellation(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 635))
  {
    v11[0] = 0;
    v11[1] = v11;
    if (nw_http3_decoder_stream_get_output_frames(*(void *)(a1 + 336), a1))
    {
      v10[0] = 0;
      v10[1] = v10;
      v10[2] = 0x2000000000;
      v10[3] = 0;
      v5[0] = MEMORY[0x1E4F143A8];
      v5[1] = 0x40000000;
      char v6 = ___ZL40nw_http3_stream_send_stream_cancellationP24nw_protocol_http3_stream_block_invoke;
      os_log_type_t v7 = &unk_1E52474F8;
      int v8 = v10;
      uint64_t v9 = a1;
      uint64_t v2 = v11[0];
      do
      {
        if (!v2) {
          break;
        }
        uint64_t v3 = *(void *)(v2 + 32);
        char v4 = ((uint64_t (*)(void *))v6)(v5);
        uint64_t v2 = v3;
      }
      while ((v4 & 1) != 0);
      nw_http3_decoder_stream_finalize_output_frames(*(void *)(a1 + 336), a1, (uint64_t)v11);
      *(unsigned char *)(a1 + 635) = 0;
      _Block_object_dispose(v10, 8);
    }
  }
}

uint64_t nw_http3_decoder_stream_get_output_frames(uint64_t a1, uint64_t a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v18 = "nw_http3_decoder_stream_get_output_frames";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (!__nwlog_fault(v9, &type, &v15)) {
      goto LABEL_26;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_26;
      }
      *(_DWORD *)buf = 136446210;
      int v18 = "nw_http3_decoder_stream_get_output_frames";
      unint64_t v12 = "%{public}s called with null http3";
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          int v18 = "nw_http3_decoder_stream_get_output_frames";
          __int16 v19 = 2082;
          unsigned int v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null http3, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_26;
      }
      if (!v14)
      {
LABEL_26:
        if (v9) {
          free(v9);
        }
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      int v18 = "nw_http3_decoder_stream_get_output_frames";
      unint64_t v12 = "%{public}s called with null http3, no backtrace";
    }
    else
    {
      uint64_t v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_26;
      }
      *(_DWORD *)buf = 136446210;
      int v18 = "nw_http3_decoder_stream_get_output_frames";
      unint64_t v12 = "%{public}s called with null http3, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v10, v11, v12, buf, 0xCu);
    goto LABEL_26;
  }
  uint64_t v3 = *(void *)(a1 + 944);
  if (v3)
  {
    if (v3 != a2)
    {
      uint64_t result = 0;
      *(void *)(a2 + 592) = 0;
      uint64_t v5 = *(void **)(a1 + 952);
      *(void *)(a2 + 600) = v5;
      void *v5 = a2;
      *(void *)(a1 + 952) = a2 + 592;
      return result;
    }
  }
  else
  {
    *(void *)(a2 + 592) = 0;
    char v6 = *(void **)(a1 + 952);
    *(void *)(a2 + 600) = v6;
    *char v6 = a2;
    *(void *)(a1 + 952) = a2 + 592;
  }
  nw_http3_start_decoder_stream_if_needed(a1);
  uint64_t result = *(void *)(a1 + 1072);
  if (result)
  {
    uint64_t v7 = *(void *)(result + 24);
    if (v7)
    {
      int v8 = *(uint64_t (**)(void))(v7 + 88);
      if (v8)
      {
        uint64_t result = v8();
        if (result) {
          *(_WORD *)(a1 + 1373) |= 0x4000u;
        }
        return result;
      }
    }
    return 0;
  }
  return result;
}

uint64_t ___ZL40nw_http3_stream_send_stream_cancellationP24nw_protocol_http3_stream_block_invoke(uint64_t a1, uint64_t a2)
{
  LODWORD(__n) = 0;
  uint64_t v3 = (void *)nw_frame_unclaimed_bytes(a2, &__n);
  memcpy(v3, (const void *)(*(void *)(a1 + 40) + *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) + 730), __n);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += __n;
  return 1;
}

void nw_http3_decoder_stream_finalize_output_frames(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (*(void *)(a1 + 944) != a2)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      uint64_t v36 = "nw_http3_decoder_stream_finalize_output_frames";
      uint64_t v3 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v33 = 0;
      if (!__nwlog_fault(v3, &type, &v33)) {
        goto LABEL_27;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v4 = gLogObj;
        os_log_type_t v5 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_27;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v36 = "nw_http3_decoder_stream_finalize_output_frames";
        char v6 = "%{public}s Decoder stream is not being used by current stream";
        goto LABEL_24;
      }
      if (!v33)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v4 = gLogObj;
        os_log_type_t v5 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_27;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v36 = "nw_http3_decoder_stream_finalize_output_frames";
        char v6 = "%{public}s Decoder stream is not being used by current stream, backtrace limit exceeded";
        goto LABEL_24;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v10 = gLogObj;
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v36 = "nw_http3_decoder_stream_finalize_output_frames";
          __int16 v37 = 2082;
          unsigned int v38 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s Decoder stream is not being used by current stream, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        if (!v3) {
          return;
        }
LABEL_28:
        free(v3);
        return;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v36 = "nw_http3_decoder_stream_finalize_output_frames";
        char v6 = "%{public}s Decoder stream is not being used by current stream, no backtrace";
        __int16 v19 = v10;
        os_log_type_t v20 = v11;
        goto LABEL_25;
      }
LABEL_27:
      if (!v3) {
        return;
      }
      goto LABEL_28;
    }
    uint64_t v7 = *(void *)(a2 + 592);
    int v8 = *(void **)(a2 + 600);
    if (v7)
    {
      *(void *)(v7 + 600) = v8;
      int v8 = *(void **)(a2 + 600);
    }
    else
    {
      *(void *)(a1 + 952) = v8;
    }
    *int v8 = v7;
    *(void *)(a2 + 592) = 0;
    *(void *)(a2 + 600) = 0;
    int v13 = *(unsigned __int16 *)(a1 + 1373);
    unsigned int v14 = v13 & 0xFFFFBFFF | (*(unsigned __int8 *)(a1 + 1375) << 16);
    *(_WORD *)(a1 + 1373) = v13 & 0xBFFF;
    *(unsigned char *)(a1 + 1375) = BYTE2(v14);
    uint64_t v15 = *(void *)(a1 + 1072);
    if (v15)
    {
      uint64_t v16 = *(void *)(v15 + 24);
      if (v16)
      {
        BOOL v17 = *(void (**)(uint64_t, uint64_t))(v16 + 96);
        if (v17)
        {
          uint64_t v18 = *(void *)(a1 + 1072);
          v17(v18, a3);
          return;
        }
      }
      __nwlog_obj();
      id v22 = *(const char **)(v15 + 16);
      if (!v22) {
        id v22 = "invalid";
      }
    }
    else
    {
      __nwlog_obj();
      id v22 = "invalid";
    }
    *(_DWORD *)buf = 136446466;
    uint64_t v36 = "nw_http3_decoder_stream_finalize_output_frames";
    __int16 v37 = 2082;
    unsigned int v38 = (void *)v22;
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v3, &type, &v33)) {
      goto LABEL_27;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (!os_log_type_enabled(v25, type)) {
        goto LABEL_27;
      }
      BOOL v27 = "invalid";
      if (v15 && *(void *)(v15 + 16)) {
        BOOL v27 = *(const char **)(v15 + 16);
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v36 = "nw_http3_decoder_stream_finalize_output_frames";
      __int16 v37 = 2082;
      unsigned int v38 = (void *)v27;
      char v6 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback";
    }
    else if (v33)
    {
      BOOL v28 = (char *)__nw_create_backtrace_string();
      BOOL v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      BOOL v29 = os_log_type_enabled(v25, type);
      if (v28)
      {
        if (v29)
        {
          int v30 = "invalid";
          if (v15 && *(void *)(v15 + 16)) {
            int v30 = *(const char **)(v15 + 16);
          }
          *(_DWORD *)buf = 136446722;
          uint64_t v36 = "nw_http3_decoder_stream_finalize_output_frames";
          __int16 v37 = 2082;
          unsigned int v38 = (void *)v30;
          __int16 v39 = 2082;
          int v40 = v28;
          _os_log_impl(&dword_1830D4000, v25, v26, "%{public}s protocol %{public}s has invalid finalize_output_frames callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v28);
        goto LABEL_27;
      }
      if (!v29) {
        goto LABEL_27;
      }
      os_log_type_t v32 = "invalid";
      if (v15 && *(void *)(v15 + 16)) {
        os_log_type_t v32 = *(const char **)(v15 + 16);
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v36 = "nw_http3_decoder_stream_finalize_output_frames";
      __int16 v37 = 2082;
      unsigned int v38 = (void *)v32;
      char v6 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback, no backtrace";
    }
    else
    {
      BOOL v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (!os_log_type_enabled(v25, type)) {
        goto LABEL_27;
      }
      uint64_t v31 = "invalid";
      if (v15 && *(void *)(v15 + 16)) {
        uint64_t v31 = *(const char **)(v15 + 16);
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v36 = "nw_http3_decoder_stream_finalize_output_frames";
      __int16 v37 = 2082;
      unsigned int v38 = (void *)v31;
      char v6 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback, backtrace limit exceeded";
    }
    __int16 v19 = v25;
    os_log_type_t v20 = v26;
    uint32_t v21 = 22;
    goto LABEL_26;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v36 = "nw_http3_decoder_stream_finalize_output_frames";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v33 = 0;
  if (!__nwlog_fault(v3, &type, &v33)) {
    goto LABEL_27;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    char v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_27;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v36 = "nw_http3_decoder_stream_finalize_output_frames";
    char v6 = "%{public}s called with null http3";
    goto LABEL_24;
  }
  if (!v33)
  {
    char v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_27;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v36 = "nw_http3_decoder_stream_finalize_output_frames";
    char v6 = "%{public}s called with null http3, backtrace limit exceeded";
    goto LABEL_24;
  }
  BOOL v23 = (char *)__nw_create_backtrace_string();
  char v4 = __nwlog_obj();
  os_log_type_t v5 = type;
  BOOL v24 = os_log_type_enabled(v4, type);
  if (!v23)
  {
    if (!v24) {
      goto LABEL_27;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v36 = "nw_http3_decoder_stream_finalize_output_frames";
    char v6 = "%{public}s called with null http3, no backtrace";
LABEL_24:
    __int16 v19 = v4;
    os_log_type_t v20 = v5;
LABEL_25:
    uint32_t v21 = 12;
LABEL_26:
    _os_log_impl(&dword_1830D4000, v19, v20, v6, buf, v21);
    goto LABEL_27;
  }
  if (v24)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v36 = "nw_http3_decoder_stream_finalize_output_frames";
    __int16 v37 = 2082;
    unsigned int v38 = v23;
    _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s called with null http3, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v23);
  if (v3) {
    goto LABEL_28;
  }
}

void nw_protocol_http3_stream_disconnect(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v85 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v76 = "nw_protocol_http3_stream_disconnect";
    __int16 v37 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v73 = 0;
    if (!__nwlog_fault(v37, &type, &v73)) {
      goto LABEL_144;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v38 = __nwlog_obj();
      os_log_type_t v39 = type;
      if (!os_log_type_enabled(v38, type)) {
        goto LABEL_144;
      }
      *(_DWORD *)buf = 136446210;
      v76 = "nw_protocol_http3_stream_disconnect";
      int v40 = "%{public}s called with null protocol";
    }
    else if (v73)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unsigned int v38 = __nwlog_obj();
      os_log_type_t v39 = type;
      BOOL v45 = os_log_type_enabled(v38, type);
      if (backtrace_string)
      {
        if (v45)
        {
          *(_DWORD *)buf = 136446466;
          v76 = "nw_protocol_http3_stream_disconnect";
          __int16 v77 = 2082;
          unint64_t v78 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v38, v39, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_144:
        if (!v37) {
          return;
        }
        goto LABEL_145;
      }
      if (!v45) {
        goto LABEL_144;
      }
      *(_DWORD *)buf = 136446210;
      v76 = "nw_protocol_http3_stream_disconnect";
      int v40 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      unsigned int v38 = __nwlog_obj();
      os_log_type_t v39 = type;
      if (!os_log_type_enabled(v38, type)) {
        goto LABEL_144;
      }
      *(_DWORD *)buf = 136446210;
      v76 = "nw_protocol_http3_stream_disconnect";
      int v40 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_143;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v76 = "nw_protocol_http3_stream_disconnect";
    __int16 v37 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v73 = 0;
    if (!__nwlog_fault(v37, &type, &v73)) {
      goto LABEL_144;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v73)
      {
        unsigned int v38 = __nwlog_obj();
        os_log_type_t v39 = type;
        if (!os_log_type_enabled(v38, type)) {
          goto LABEL_144;
        }
        *(_DWORD *)buf = 136446210;
        v76 = "nw_protocol_http3_stream_disconnect";
        int v40 = "%{public}s called with null http3_stream, backtrace limit exceeded";
        goto LABEL_143;
      }
      __int16 v46 = (char *)__nw_create_backtrace_string();
      unsigned int v38 = __nwlog_obj();
      os_log_type_t v39 = type;
      BOOL v47 = os_log_type_enabled(v38, type);
      if (!v46)
      {
        if (!v47) {
          goto LABEL_144;
        }
        *(_DWORD *)buf = 136446210;
        v76 = "nw_protocol_http3_stream_disconnect";
        int v40 = "%{public}s called with null http3_stream, no backtrace";
        goto LABEL_143;
      }
      if (!v47) {
        goto LABEL_114;
      }
      *(_DWORD *)buf = 136446466;
      v76 = "nw_protocol_http3_stream_disconnect";
      __int16 v77 = 2082;
      unint64_t v78 = v46;
      BOOL v48 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
      goto LABEL_113;
    }
    unsigned int v38 = __nwlog_obj();
    os_log_type_t v39 = type;
    if (!os_log_type_enabled(v38, type)) {
      goto LABEL_144;
    }
    *(_DWORD *)buf = 136446210;
    v76 = "nw_protocol_http3_stream_disconnect";
    int v40 = "%{public}s called with null http3_stream";
LABEL_143:
    _os_log_impl(&dword_1830D4000, v38, v39, v40, buf, 0xCu);
    goto LABEL_144;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v76 = "nw_protocol_http3_stream_disconnect";
    __int16 v37 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v73 = 0;
    if (!__nwlog_fault(v37, &type, &v73)) {
      goto LABEL_144;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v38 = __nwlog_obj();
      os_log_type_t v39 = type;
      if (!os_log_type_enabled(v38, type)) {
        goto LABEL_144;
      }
      *(_DWORD *)buf = 136446210;
      v76 = "nw_protocol_http3_stream_disconnect";
      int v40 = "%{public}s called with null other_protocol";
      goto LABEL_143;
    }
    if (!v73)
    {
      unsigned int v38 = __nwlog_obj();
      os_log_type_t v39 = type;
      if (!os_log_type_enabled(v38, type)) {
        goto LABEL_144;
      }
      *(_DWORD *)buf = 136446210;
      v76 = "nw_protocol_http3_stream_disconnect";
      int v40 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_143;
    }
    __int16 v46 = (char *)__nw_create_backtrace_string();
    unsigned int v38 = __nwlog_obj();
    os_log_type_t v39 = type;
    BOOL v49 = os_log_type_enabled(v38, type);
    if (!v46)
    {
      if (!v49) {
        goto LABEL_144;
      }
      *(_DWORD *)buf = 136446210;
      v76 = "nw_protocol_http3_stream_disconnect";
      int v40 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_143;
    }
    if (!v49) {
      goto LABEL_114;
    }
    *(_DWORD *)buf = 136446466;
    v76 = "nw_protocol_http3_stream_disconnect";
    __int16 v77 = 2082;
    unint64_t v78 = v46;
    BOOL v48 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
LABEL_113:
    _os_log_impl(&dword_1830D4000, v38, v39, v48, buf, 0x16u);
    goto LABEL_114;
  }
  if ((*((_WORD *)handle + 368) & 0x800) == 0)
  {
    if (gLogDatapath)
    {
      uint64_t v41 = __nwlog_obj();
      if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
      {
        int v42 = *(_DWORD *)(*((void *)handle + 42) + 1280);
        uint64_t v43 = *((void *)handle + 30);
        *(_DWORD *)buf = 136447234;
        v76 = "nw_protocol_http3_stream_disconnect";
        __int16 v77 = 2082;
        unint64_t v78 = handle + 636;
        __int16 v79 = 2080;
        unint64_t v80 = " ";
        __int16 v81 = 1024;
        int v82 = v42;
        __int16 v83 = 2048;
        uint64_t v84 = v43;
        _os_log_impl(&dword_1830D4000, v41, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called", buf, 0x30u);
      }
    }
  }
  uint64_t v3 = handle + 736;
  char v4 = (void *)*((void *)handle + 52);
  if (v4)
  {
    uint64_t v5 = *((void *)handle + 33);
    if (v5 == -1)
    {
      uint64_t v6 = *((void *)handle + 54);
      if (v6)
      {
        uint64_t v5 = (*(uint64_t (**)(void))(v6 + 16))(*((void *)handle + 54));
        char v4 = (void *)*((void *)handle + 52);
      }
      else if ((*v3 & 0x10) != 0)
      {
        uint64_t v5 = 256;
      }
      else
      {
        uint64_t v5 = 268;
      }
    }
    nw_quic_stream_set_application_error(v4, v5);
  }
  uint64_t v7 = *((void *)handle + 12);
  if (v7)
  {
    uint64_t v8 = *(void *)(v7 + 24);
    if (v8)
    {
      uint64_t v9 = *(void (**)(void))(v8 + 32);
      if (v9) {
        v9();
      }
    }
  }
  uint64_t v10 = *((void *)handle + 42);
  if (!v10)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v76 = "nw_protocol_http3_stream_disconnect";
    __int16 v37 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v73 = 0;
    if (!__nwlog_fault(v37, &type, &v73)) {
      goto LABEL_144;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v38 = __nwlog_obj();
      os_log_type_t v39 = type;
      if (!os_log_type_enabled(v38, type)) {
        goto LABEL_144;
      }
      *(_DWORD *)buf = 136446210;
      v76 = "nw_protocol_http3_stream_disconnect";
      int v40 = "%{public}s called with null http3_stream->http3_connection";
      goto LABEL_143;
    }
    if (!v73)
    {
      unsigned int v38 = __nwlog_obj();
      os_log_type_t v39 = type;
      if (!os_log_type_enabled(v38, type)) {
        goto LABEL_144;
      }
      *(_DWORD *)buf = 136446210;
      v76 = "nw_protocol_http3_stream_disconnect";
      int v40 = "%{public}s called with null http3_stream->http3_connection, backtrace limit exceeded";
      goto LABEL_143;
    }
    __int16 v46 = (char *)__nw_create_backtrace_string();
    unsigned int v38 = __nwlog_obj();
    os_log_type_t v39 = type;
    BOOL v50 = os_log_type_enabled(v38, type);
    if (!v46)
    {
      if (!v50) {
        goto LABEL_144;
      }
      *(_DWORD *)buf = 136446210;
      v76 = "nw_protocol_http3_stream_disconnect";
      int v40 = "%{public}s called with null http3_stream->http3_connection, no backtrace";
      goto LABEL_143;
    }
    if (v50)
    {
      *(_DWORD *)buf = 136446466;
      v76 = "nw_protocol_http3_stream_disconnect";
      __int16 v77 = 2082;
      unint64_t v78 = v46;
      BOOL v48 = "%{public}s called with null http3_stream->http3_connection, dumping backtrace:%{public}s";
      goto LABEL_113;
    }
LABEL_114:
    free(v46);
    if (!v37) {
      return;
    }
LABEL_145:
    free(v37);
    return;
  }
  os_log_type_t v11 = handle + 730;
  BOOL v12 = (void *)(v10 + 576);
  while (1)
  {
    BOOL v12 = (void *)*v12;
    if (!v12) {
      break;
    }
    if ((char *)v12[4] == handle)
    {
      char *v11 = 64;
      unint64_t v13 = v12[5];
      if (v13 <= 0x3E)
      {
        unsigned int v14 = handle + 731;
        handle[730] = v13 | 0x40;
LABEL_38:
        __int16 v19 = *(FILE **)(v10 + 544);
        if (v19)
        {
          fwrite("qdec: debug: ", 0xDuLL, 1uLL, v19);
          fprintf(*(FILE **)(v10 + 544), "cancelled stream %llu; generate instruction of %u bytes",
            v12[5],
            v14 - v11);
          fputc(10, *(FILE **)(v10 + 544));
        }
        os_log_type_t v20 = (void *)*v12;
        uint32_t v21 = (void *)v12[1];
        if (*v12)
        {
          v20[1] = v21;
          uint32_t v21 = (void *)v12[1];
        }
        else
        {
          *(void *)(v10 + 584) = v21;
        }
        *uint32_t v21 = v20;
        if ((v12[13] & 4) != 0)
        {
          uint64_t v22 = v12[2];
          if (v22) {
            *(void *)(v22 + 24) = v12[3];
          }
          else {
            *(void *)(v10 + 16 * (v12[8] & 7) + 600) = v12[3];
          }
          *(void *)v12[3] = v22;
          --*(_DWORD *)(v10 + 720);
        }
        free(v12);
        *(_DWORD *)(v10 + 520) += v14 - v11;
        if (v14 - v11 >= 0)
        {
          handle[635] = (_BYTE)v14 - ((_BYTE)handle - 38);
          goto LABEL_67;
        }
LABEL_52:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446210;
        v76 = "nw_protocol_http3_stream_disconnect";
        BOOL v24 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v73 = 0;
        if (!__nwlog_fault(v24, &type, &v73)) {
          goto LABEL_65;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v25 = gLogObj;
          os_log_type_t v26 = type;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            *(_DWORD *)buf = 136446210;
            v76 = "nw_protocol_http3_stream_disconnect";
            BOOL v27 = "%{public}s Failed to generate stream cancellation instruction";
            goto LABEL_63;
          }
          goto LABEL_65;
        }
        if (v73)
        {
          BOOL v28 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v29 = gLogObj;
          os_log_type_t v30 = type;
          BOOL v31 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (v28)
          {
            if (v31)
            {
              *(_DWORD *)buf = 136446466;
              v76 = "nw_protocol_http3_stream_disconnect";
              __int16 v77 = 2082;
              unint64_t v78 = v28;
              _os_log_impl(&dword_1830D4000, v29, v30, "%{public}s Failed to generate stream cancellation instruction, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v28);
            goto LABEL_65;
          }
          if (!v31)
          {
LABEL_65:
            if (v24) {
              free(v24);
            }
            goto LABEL_67;
          }
          *(_DWORD *)buf = 136446210;
          v76 = "nw_protocol_http3_stream_disconnect";
          BOOL v27 = "%{public}s Failed to generate stream cancellation instruction, no backtrace";
          os_log_type_t v32 = v29;
          os_log_type_t v33 = v30;
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v25 = gLogObj;
          os_log_type_t v26 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_65;
          }
          *(_DWORD *)buf = 136446210;
          v76 = "nw_protocol_http3_stream_disconnect";
          BOOL v27 = "%{public}s Failed to generate stream cancellation instruction, backtrace limit exceeded";
LABEL_63:
          os_log_type_t v32 = v25;
          os_log_type_t v33 = v26;
        }
        _os_log_impl(&dword_1830D4000, v32, v33, v27, buf, 0xCu);
        goto LABEL_65;
      }
      char *v11 = 127;
      unint64_t v16 = v13 - 63;
      if (v16 < 0x80)
      {
        uint64_t v17 = 1;
        uint64_t v18 = handle + 730;
      }
      else
      {
        handle[731] = v16 | 0x80;
        if (v16 < 0x4000)
        {
          uint64_t v18 = handle + 731;
          v16 >>= 7;
          uint64_t v17 = 2;
        }
        else
        {
          handle[732] = (v16 >> 7) | 0x80;
          if (v16 < 0x200000)
          {
            uint64_t v18 = handle + 732;
            v16 >>= 14;
            uint64_t v17 = 3;
          }
          else
          {
            handle[733] = (v16 >> 14) | 0x80;
            if (v16 >> 28)
            {
              handle[734] = (v16 >> 21) | 0x80;
              if (v16 >> 35)
              {
                handle[735] = (v16 >> 28) | 0x80;
LABEL_46:
                BOOL v23 = *(FILE **)(v10 + 544);
                if (v23)
                {
                  fwrite("qdec: warn: ", 0xCuLL, 1uLL, v23);
                  fprintf(*(FILE **)(v10 + 544), "cannot generate Cancel Stream instruction for stream %llu; buf size=%zu",
                    v12[5],
                    6uLL);
                  fputc(10, *(FILE **)(v10 + 544));
                }
                goto LABEL_52;
              }
              uint64_t v18 = handle + 734;
              uint64_t v17 = 5;
              LOBYTE(v16) = v16 >> 28;
            }
            else
            {
              uint64_t v18 = handle + 733;
              v16 >>= 21;
              uint64_t v17 = 4;
            }
          }
        }
      }
      unsigned int v14 = v18 + 2;
      v11[v17] = v16;
      if (v18 + 2 > v11) {
        goto LABEL_38;
      }
      goto LABEL_46;
    }
  }
  uint64_t v15 = *(FILE **)(v10 + 544);
  if (v15)
  {
    fwrite("qdec: info: ", 0xCuLL, 1uLL, v15);
    fwrite("could not find stream to cancel", 0x1FuLL, 1uLL, *(FILE **)(v10 + 544));
    fputc(10, *(FILE **)(v10 + 544));
  }
  handle[635] = 0;
LABEL_67:
  nw_http3_stream_send_stream_cancellation((uint64_t)handle);
  if (*((void *)handle + 66) || handle[634] || handle[635])
  {
    *v3 |= 0x400u;
    return;
  }
  uint64_t v34 = *((void *)handle + 4);
  if (v34)
  {
    uint64_t v35 = *(void *)(v34 + 24);
    if (v35)
    {
      uint64_t v36 = *(void (**)(uint64_t, char *))(v35 + 32);
      if (v36)
      {
        v36(v34, handle);
        return;
      }
    }
  }
  __nwlog_obj();
  uint64_t v51 = *((void *)handle + 4);
  uint64_t v52 = "invalid";
  if (v51)
  {
    char v53 = *(const char **)(v51 + 16);
    if (v53) {
      uint64_t v52 = v53;
    }
  }
  *(_DWORD *)buf = 136446466;
  v76 = "nw_protocol_http3_stream_disconnect";
  __int16 v77 = 2082;
  unint64_t v78 = (char *)v52;
  BOOL v54 = (const char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v73 = 0;
  v55 = (char *)v54;
  if (!__nwlog_fault(v54, &type, &v73)) {
    goto LABEL_165;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    unsigned int v56 = __nwlog_obj();
    os_log_type_t v57 = type;
    if (!os_log_type_enabled(v56, type)) {
      goto LABEL_165;
    }
    uint64_t v58 = *((void *)handle + 4);
    __int16 v59 = "invalid";
    if (v58)
    {
      uint64_t v60 = *(const char **)(v58 + 16);
      if (v60) {
        __int16 v59 = v60;
      }
    }
    *(_DWORD *)buf = 136446466;
    v76 = "nw_protocol_http3_stream_disconnect";
    __int16 v77 = 2082;
    unint64_t v78 = (char *)v59;
    uint64_t v61 = "%{public}s protocol %{public}s has invalid disconnect callback";
    goto LABEL_164;
  }
  if (!v73)
  {
    unsigned int v56 = __nwlog_obj();
    os_log_type_t v57 = type;
    if (!os_log_type_enabled(v56, type)) {
      goto LABEL_165;
    }
    uint64_t v67 = *((void *)handle + 4);
    uint64_t v68 = "invalid";
    if (v67)
    {
      v69 = *(const char **)(v67 + 16);
      if (v69) {
        uint64_t v68 = v69;
      }
    }
    *(_DWORD *)buf = 136446466;
    v76 = "nw_protocol_http3_stream_disconnect";
    __int16 v77 = 2082;
    unint64_t v78 = (char *)v68;
    uint64_t v61 = "%{public}s protocol %{public}s has invalid disconnect callback, backtrace limit exceeded";
    goto LABEL_164;
  }
  os_log_type_t v62 = (char *)__nw_create_backtrace_string();
  unsigned int v56 = __nwlog_obj();
  os_log_type_t v57 = type;
  BOOL v63 = os_log_type_enabled(v56, type);
  if (v62)
  {
    if (v63)
    {
      uint64_t v64 = *((void *)handle + 4);
      v65 = "invalid";
      if (v64)
      {
        uint64_t v66 = *(const char **)(v64 + 16);
        if (v66) {
          v65 = v66;
        }
      }
      *(_DWORD *)buf = 136446722;
      v76 = "nw_protocol_http3_stream_disconnect";
      __int16 v77 = 2082;
      unint64_t v78 = (char *)v65;
      __int16 v79 = 2082;
      unint64_t v80 = v62;
      _os_log_impl(&dword_1830D4000, v56, v57, "%{public}s protocol %{public}s has invalid disconnect callback, dumping backtrace:%{public}s", buf, 0x20u);
    }
    free(v62);
    goto LABEL_165;
  }
  if (v63)
  {
    uint64_t v70 = *((void *)handle + 4);
    os_log_type_t v71 = "invalid";
    if (v70)
    {
      uint64_t v72 = *(const char **)(v70 + 16);
      if (v72) {
        os_log_type_t v71 = v72;
      }
    }
    *(_DWORD *)buf = 136446466;
    v76 = "nw_protocol_http3_stream_disconnect";
    __int16 v77 = 2082;
    unint64_t v78 = (char *)v71;
    uint64_t v61 = "%{public}s protocol %{public}s has invalid disconnect callback, no backtrace";
LABEL_164:
    _os_log_impl(&dword_1830D4000, v56, v57, v61, buf, 0x16u);
  }
LABEL_165:
  if (v55) {
    free(v55);
  }
}

void nw::http::content_length_manager::set_inbound_message(nw::http::content_length_manager *this, nw_protocol_metadata *a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v19 = "set_inbound_message";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v17 = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (!__nwlog_fault(v6, &v17, &v16)) {
      goto LABEL_42;
    }
    if (v17 == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = v17;
      if (!os_log_type_enabled(v7, v17)) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v19 = "set_inbound_message";
      uint64_t v9 = "%{public}s called with null metadata";
      goto LABEL_41;
    }
    if (!v16)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = v17;
      if (!os_log_type_enabled(v7, v17)) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v19 = "set_inbound_message";
      uint64_t v9 = "%{public}s called with null metadata, backtrace limit exceeded";
      goto LABEL_41;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v7 = __nwlog_obj();
    os_log_type_t v8 = v17;
    BOOL v11 = os_log_type_enabled(v7, v17);
    if (!backtrace_string)
    {
      if (!v11) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v19 = "set_inbound_message";
      uint64_t v9 = "%{public}s called with null metadata, no backtrace";
      goto LABEL_41;
    }
    if (v11)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v19 = "set_inbound_message";
      __int16 v20 = 2082;
      uint32_t v21 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_42:
    if (!v6) {
      return;
    }
    goto LABEL_43;
  }
  if (!nw_protocol_metadata_is_http(a2))
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v19 = "set_inbound_message";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v17 = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (!__nwlog_fault(v6, &v17, &v16)) {
      goto LABEL_42;
    }
    if (v17 == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = v17;
      if (!os_log_type_enabled(v7, v17)) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v19 = "set_inbound_message";
      uint64_t v9 = "%{public}s called with null (nw_protocol_metadata_is_http(metadata))";
      goto LABEL_41;
    }
    if (!v16)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = v17;
      if (!os_log_type_enabled(v7, v17)) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v19 = "set_inbound_message";
      uint64_t v9 = "%{public}s called with null (nw_protocol_metadata_is_http(metadata)), backtrace limit exceeded";
      goto LABEL_41;
    }
    BOOL v12 = (char *)__nw_create_backtrace_string();
    uint64_t v7 = __nwlog_obj();
    os_log_type_t v8 = v17;
    BOOL v13 = os_log_type_enabled(v7, v17);
    if (v12)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v19 = "set_inbound_message";
        __int16 v20 = 2082;
        uint32_t v21 = v12;
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null (nw_protocol_metadata_is_http(metadata)), dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v12);
      if (!v6) {
        return;
      }
LABEL_43:
      free(v6);
      return;
    }
    if (v13)
    {
      *(_DWORD *)buf = 136446210;
      __int16 v19 = "set_inbound_message";
      uint64_t v9 = "%{public}s called with null (nw_protocol_metadata_is_http(metadata)), no backtrace";
LABEL_41:
      _os_log_impl(&dword_1830D4000, v7, v8, v9, buf, 0xCu);
      goto LABEL_42;
    }
    goto LABEL_42;
  }
  if (*((unsigned char *)this + 48))
  {
    id v4 = nw_http_metadata_copy_request(a2);
    *((unsigned char *)this + 49) = nw_http_request_has_method(v4, (uint64_t)"HEAD");
    v15[0] = MEMORY[0x1E4F143A8];
    v15[1] = 0x40000000;
    v15[2] = ___ZN2nw4http22content_length_manager19set_inbound_messageEP20nw_protocol_metadata_block_invoke;
    v15[3] = &__block_descriptor_tmp_97_61807;
    v15[4] = this;
    uint64_t v5 = v15;
    goto LABEL_5;
  }
  id v4 = nw_http_metadata_copy_response(a2);
  nw_http_response_get_status_code(v4);
  if (!*((unsigned char *)this + 49))
  {
    v14[0] = MEMORY[0x1E4F143A8];
    v14[1] = 0x40000000;
    v14[2] = ___ZN2nw4http22content_length_manager19set_inbound_messageEP20nw_protocol_metadata_block_invoke_2;
    v14[3] = &__block_descriptor_tmp_98;
    v14[4] = this;
    uint64_t v5 = v14;
LABEL_5:
    nw_http_fields_access_value_by_name(v4, (unint64_t)"Content-Length", v5);
    if (!v4) {
      return;
    }
    goto LABEL_11;
  }
  if (!*((unsigned char *)this + 32)) {
    *((unsigned char *)this + 32) = 1;
  }
  *((void *)this + 3) = 0;
  if (v4) {
LABEL_11:
  }
    os_release(v4);
}

unint64_t ___ZL36nw_http3_stream_received_fields_doneP24nw_protocol_http3_stream_block_invoke(unint64_t result, char *__s)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  *(void *)BOOL v23 = 0;
  if (__s)
  {
    uint64_t v3 = result;
    uint64_t result = strlen(__s);
    if (result <= 7)
    {
      v23[0] = *__s;
      if (v23[0])
      {
        v23[1] = __s[1];
        if (v23[1])
        {
          v23[2] = __s[2];
          if (v23[2])
          {
            v23[3] = __s[3];
            if (v23[3])
            {
              v23[4] = __s[4];
              if (v23[4])
              {
                v23[5] = __s[5];
                if (v23[5])
                {
                  v23[6] = __s[6];
                  if (v23[6]) {
                    v23[7] = 0;
                  }
                }
              }
            }
          }
        }
      }
      uint64_t v4 = *(void *)(v3 + 32);
      if (!v4 || (*(_WORD *)(v4 + 736) & 0x800) == 0)
      {
        if (gLogDatapath)
        {
          uint64_t v5 = __nwlog_obj();
          BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG);
          uint64_t v4 = *(void *)(v3 + 32);
          if (v6)
          {
            uint64_t v7 = (const char *)(v4 + 636);
            os_log_type_t v8 = "";
            int v9 = *(_DWORD *)(*(void *)(v4 + 336) + 1280);
            if (!v4) {
              uint64_t v7 = "";
            }
            uint64_t v10 = *(void *)(v4 + 240);
            if (v4) {
              os_log_type_t v8 = " ";
            }
            int v11 = 136447490;
            BOOL v12 = "nw_http3_stream_received_fields_done_block_invoke";
            __int16 v13 = 2082;
            unsigned int v14 = v7;
            __int16 v15 = 2080;
            char v16 = v8;
            __int16 v17 = 1024;
            int v18 = v9;
            __int16 v19 = 2048;
            uint64_t v20 = v10;
            __int16 v21 = 2082;
            uint64_t v22 = v23;
            _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> received CONNECT-UDP for flow ID %{public}s", (uint8_t *)&v11, 0x3Au);
            uint64_t v4 = *(void *)(v3 + 32);
          }
        }
      }
      uint64_t result = atoi(v23);
      *(void *)(v4 + 248) = (int)result;
      *(_WORD *)(v4 + 736) |= 0x20u;
      *(_DWORD *)(*(void *)(v3 + 32) + 372) = 8;
    }
  }
  return result;
}

void ___ZL36nw_http3_stream_received_fields_doneP24nw_protocol_http3_stream_block_invoke_93(uint64_t a1, char *__s1)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  if (!__s1 || strcmp(__s1, "connect-udp") && strcmp(__s1, "connect-ip")) {
    return;
  }
  uint64_t v4 = *(void *)(a1 + 32);
  unint64_t v5 = *(void *)(v4 + 240);
  if ((v5 & 3) != 0)
  {
    if ((*(_WORD *)(v4 + 736) & 0x800) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        uint64_t v7 = *(void *)(a1 + 32);
        os_log_type_t v8 = (const char *)(v7 + 636);
        int v9 = "";
        BOOL v10 = v7 == 0;
        if (!v7) {
          os_log_type_t v8 = "";
        }
        int v11 = *(_DWORD *)(*(void *)(v7 + 336) + 1280);
        uint64_t v12 = *(void *)(v7 + 240);
        if (!v10) {
          int v9 = " ";
        }
        int v24 = 136447490;
        uint64_t v25 = "nw_http3_stream_received_fields_done_block_invoke";
        __int16 v26 = 2082;
        BOOL v27 = v8;
        __int16 v28 = 2080;
        BOOL v29 = v9;
        __int16 v30 = 1024;
        int v31 = v11;
        __int16 v32 = 2048;
        uint64_t v33 = v12;
        __int16 v34 = 2048;
        uint64_t v35 = v12;
        __int16 v13 = "%{public}s %{public}s%s<i%u:s%llu> received CONNECT(connect-udp/ip) for invalid stream ID %llu";
        unsigned int v14 = v6;
        os_log_type_t v15 = OS_LOG_TYPE_ERROR;
LABEL_12:
        _os_log_impl(&dword_1830D4000, v14, v15, v13, (uint8_t *)&v24, 0x3Au);
      }
    }
  }
  else
  {
    *(void *)(v4 + 248) = v5 >> 2;
    if ((*(_WORD *)(v4 + 736) & 0x800) == 0)
    {
      if (gLogDatapath)
      {
        __int16 v17 = __nwlog_obj();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v18 = *(void *)(a1 + 32);
          __int16 v19 = (const char *)(v18 + 636);
          uint64_t v20 = "";
          BOOL v21 = v18 == 0;
          if (!v18) {
            __int16 v19 = "";
          }
          int v22 = *(_DWORD *)(*(void *)(v18 + 336) + 1280);
          uint64_t v23 = *(void *)(v18 + 240);
          if (!v21) {
            uint64_t v20 = " ";
          }
          int v24 = 136447490;
          uint64_t v25 = "nw_http3_stream_received_fields_done_block_invoke";
          __int16 v26 = 2082;
          BOOL v27 = v19;
          __int16 v28 = 2080;
          BOOL v29 = v20;
          __int16 v30 = 1024;
          int v31 = v22;
          __int16 v32 = 2048;
          uint64_t v33 = v23;
          __int16 v34 = 2048;
          uint64_t v35 = v23;
          __int16 v13 = "%{public}s %{public}s%s<i%u:s%llu> received CONNECT(connect-udp/ip) for stream ID %llu";
          unsigned int v14 = v17;
          os_log_type_t v15 = OS_LOG_TYPE_DEBUG;
          goto LABEL_12;
        }
      }
    }
  }
  uint64_t v16 = *(void *)(a1 + 32);
  if ((*(_WORD *)(*(void *)(a1 + 40) + 1373) & 4) != 0) {
    *(_WORD *)(v16 + 736) |= 0x20u;
  }
  else {
    nw_protocol_http3_stream_start_datagram_flow(v16);
  }
  *(_DWORD *)(*(void *)(a1 + 32) + 372) = 8;
}

void nw_protocol_http3_stream_start_datagram_flow(uint64_t a1)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v53 = "nw_protocol_http3_stream_start_datagram_flow";
    unsigned int v14 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v50 = 0;
    if (!__nwlog_fault(v14, &type, &v50)) {
      goto LABEL_104;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_104;
      }
      *(_DWORD *)buf = 136446210;
      char v53 = "nw_protocol_http3_stream_start_datagram_flow";
      __int16 v17 = "%{public}s called with null http3_stream";
    }
    else if (v50)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v32 = os_log_type_enabled(v15, type);
      if (backtrace_string)
      {
        if (v32)
        {
          *(_DWORD *)buf = 136446466;
          char v53 = "nw_protocol_http3_stream_start_datagram_flow";
          __int16 v54 = 2082;
          v55 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s called with null http3_stream, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_104;
      }
      if (!v32)
      {
LABEL_104:
        if (v14) {
          free(v14);
        }
        return;
      }
      *(_DWORD *)buf = 136446210;
      char v53 = "nw_protocol_http3_stream_start_datagram_flow";
      __int16 v17 = "%{public}s called with null http3_stream, no backtrace";
    }
    else
    {
      os_log_type_t v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_104;
      }
      *(_DWORD *)buf = 136446210;
      char v53 = "nw_protocol_http3_stream_start_datagram_flow";
      __int16 v17 = "%{public}s called with null http3_stream, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v15, v16, v17, buf, 0xCu);
    goto LABEL_104;
  }
  uint64_t v2 = (unsigned __int16 *)(a1 + 736);
  if ((*(_WORD *)(a1 + 736) & 0x800) == 0)
  {
    if (gLogDatapath)
    {
      uint64_t v18 = __nwlog_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        int v19 = *(_DWORD *)(*(void *)(a1 + 336) + 1280);
        uint64_t v20 = *(void *)(a1 + 240);
        *(_DWORD *)buf = 136447234;
        char v53 = "nw_protocol_http3_stream_start_datagram_flow";
        __int16 v54 = 2082;
        v55 = (void *)(a1 + 636);
        __int16 v56 = 2080;
        os_log_type_t v57 = " ";
        __int16 v58 = 1024;
        int v59 = v19;
        __int16 v60 = 2048;
        uint64_t v61 = v20;
        _os_log_impl(&dword_1830D4000, v18, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called", buf, 0x30u);
      }
    }
  }
  int v3 = *v2;
  int v4 = v3 | (*((unsigned __int8 *)v2 + 2) << 16);
  if ((v3 & 0x10) == 0)
  {
    *((unsigned char *)v2 + 2) = BYTE2(v4);
    *uint64_t v2 = v4 | 0x10;
    nw_protocol_set_input_handler(a1 + 64, *(void *)(a1 + 48));
    *(_OWORD *)(a1 + 64) = *(_OWORD *)a1;
    uint64_t default_output_handler = nw_http3_get_default_output_handler(*(void *)(a1 + 336));
    uint64_t v6 = default_output_handler;
    if (default_output_handler)
    {
      uint64_t v7 = *(void (***)(uint64_t, uint64_t))(default_output_handler + 24);
      if (v7)
      {
        os_log_type_t v8 = *v7;
        if (v8)
        {
          v8(default_output_handler, a1 + 64);
          nw_protocol_set_output_handler(a1 + 64, v6);
          goto LABEL_9;
        }
      }
      __nwlog_obj();
      BOOL v21 = *(const char **)(v6 + 16);
      if (!v21) {
        BOOL v21 = "invalid";
      }
    }
    else
    {
      __nwlog_obj();
      BOOL v21 = "invalid";
    }
    *(_DWORD *)buf = 136446466;
    char v53 = "nw_protocol_http3_stream_start_datagram_flow";
    __int16 v54 = 2082;
    v55 = (void *)v21;
    uint64_t v23 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v50 = 0;
    if (__nwlog_fault(v23, &type, &v50))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v24 = __nwlog_obj();
        os_log_type_t v25 = type;
        if (!os_log_type_enabled(v24, type)) {
          goto LABEL_67;
        }
        __int16 v26 = "invalid";
        if (v6 && *(void *)(v6 + 16)) {
          __int16 v26 = *(const char **)(v6 + 16);
        }
        *(_DWORD *)buf = 136446466;
        char v53 = "nw_protocol_http3_stream_start_datagram_flow";
        __int16 v54 = 2082;
        v55 = (void *)v26;
        BOOL v27 = "%{public}s protocol %{public}s has invalid add_input_handler callback";
LABEL_66:
        _os_log_impl(&dword_1830D4000, v24, v25, v27, buf, 0x16u);
        goto LABEL_67;
      }
      if (!v50)
      {
        int v24 = __nwlog_obj();
        os_log_type_t v25 = type;
        if (!os_log_type_enabled(v24, type)) {
          goto LABEL_67;
        }
        __int16 v37 = "invalid";
        if (v6 && *(void *)(v6 + 16)) {
          __int16 v37 = *(const char **)(v6 + 16);
        }
        *(_DWORD *)buf = 136446466;
        char v53 = "nw_protocol_http3_stream_start_datagram_flow";
        __int16 v54 = 2082;
        v55 = (void *)v37;
        BOOL v27 = "%{public}s protocol %{public}s has invalid add_input_handler callback, backtrace limit exceeded";
        goto LABEL_66;
      }
      __int16 v28 = (char *)__nw_create_backtrace_string();
      int v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      BOOL v29 = os_log_type_enabled(v24, type);
      if (!v28)
      {
        if (!v29) {
          goto LABEL_67;
        }
        unsigned int v38 = "invalid";
        if (v6 && *(void *)(v6 + 16)) {
          unsigned int v38 = *(const char **)(v6 + 16);
        }
        *(_DWORD *)buf = 136446466;
        char v53 = "nw_protocol_http3_stream_start_datagram_flow";
        __int16 v54 = 2082;
        v55 = (void *)v38;
        BOOL v27 = "%{public}s protocol %{public}s has invalid add_input_handler callback, no backtrace";
        goto LABEL_66;
      }
      if (v29)
      {
        __int16 v30 = "invalid";
        if (v6 && *(void *)(v6 + 16)) {
          __int16 v30 = *(const char **)(v6 + 16);
        }
        *(_DWORD *)buf = 136446722;
        char v53 = "nw_protocol_http3_stream_start_datagram_flow";
        __int16 v54 = 2082;
        v55 = (void *)v30;
        __int16 v56 = 2082;
        os_log_type_t v57 = v28;
        _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s protocol %{public}s has invalid add_input_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(v28);
    }
LABEL_67:
    if (v23) {
      free(v23);
    }
    nw_protocol_set_output_handler(a1 + 64, v6);
    if (!v6)
    {
      __nwlog_obj();
      int v22 = "invalid";
      goto LABEL_71;
    }
LABEL_9:
    uint64_t v9 = *(void *)(v6 + 24);
    if (v9)
    {
      BOOL v10 = *(void (**)(uint64_t, uint64_t))(v9 + 24);
      if (v10)
      {
        v10(v6, a1 + 64);
LABEL_12:
        uint64_t v11 = *(void *)(v6 + 24);
        if (v11)
        {
          uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v11 + 224);
          if (v12)
          {
            __int16 v13 = (atomic_uchar *)v12(v6, 255, a1 + 64);
            v49[0] = MEMORY[0x1E4F143A8];
            v49[1] = 0x40000000;
            v49[2] = ___ZL44nw_protocol_http3_stream_start_datagram_flowP24nw_protocol_http3_stream_block_invoke;
            v49[3] = &__block_descriptor_tmp_99;
            v49[4] = a1;
            nw_array_apply(v13, (uint64_t)v49);
            if (v13) {
              os_release(v13);
            }
          }
        }
LABEL_16:
        if ((*v2 & 0x800) == 0 && gLogDatapath)
        {
          uint64_t v33 = __nwlog_obj();
          if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
          {
            int v34 = *(_DWORD *)(*(void *)(a1 + 336) + 1280);
            uint64_t v35 = *(void *)(a1 + 240);
            uint64_t v36 = *(void *)(a1 + 248);
            *(_DWORD *)buf = 136447490;
            char v53 = "nw_protocol_http3_stream_start_datagram_flow";
            __int16 v54 = 2082;
            v55 = (void *)(a1 + 636);
            __int16 v56 = 2080;
            os_log_type_t v57 = " ";
            __int16 v58 = 1024;
            int v59 = v34;
            __int16 v60 = 2048;
            uint64_t v61 = v35;
            __int16 v62 = 2048;
            uint64_t v63 = v36;
            _os_log_impl(&dword_1830D4000, v33, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> Opened datagram flow %llu", buf, 0x3Au);
          }
        }
        return;
      }
    }
    __nwlog_obj();
    int v22 = *(const char **)(v6 + 16);
    if (!v22) {
      int v22 = "invalid";
    }
LABEL_71:
    *(_DWORD *)buf = 136446466;
    char v53 = "nw_protocol_http3_stream_start_datagram_flow";
    __int16 v54 = 2082;
    v55 = (void *)v22;
    os_log_type_t v39 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v50 = 0;
    if (!__nwlog_fault(v39, &type, &v50)) {
      goto LABEL_97;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v40 = __nwlog_obj();
      os_log_type_t v41 = type;
      if (!os_log_type_enabled(v40, type)) {
        goto LABEL_97;
      }
      int v42 = "invalid";
      if (v6 && *(void *)(v6 + 16)) {
        int v42 = *(const char **)(v6 + 16);
      }
      *(_DWORD *)buf = 136446466;
      char v53 = "nw_protocol_http3_stream_start_datagram_flow";
      __int16 v54 = 2082;
      v55 = (void *)v42;
      uint64_t v43 = "%{public}s protocol %{public}s has invalid connect callback";
    }
    else if (v50)
    {
      __int16 v44 = (char *)__nw_create_backtrace_string();
      int v40 = __nwlog_obj();
      os_log_type_t v41 = type;
      BOOL v45 = os_log_type_enabled(v40, type);
      if (v44)
      {
        if (v45)
        {
          __int16 v46 = "invalid";
          if (v6 && *(void *)(v6 + 16)) {
            __int16 v46 = *(const char **)(v6 + 16);
          }
          *(_DWORD *)buf = 136446722;
          char v53 = "nw_protocol_http3_stream_start_datagram_flow";
          __int16 v54 = 2082;
          v55 = (void *)v46;
          __int16 v56 = 2082;
          os_log_type_t v57 = v44;
          _os_log_impl(&dword_1830D4000, v40, v41, "%{public}s protocol %{public}s has invalid connect callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v44);
LABEL_97:
        if (v39) {
          free(v39);
        }
        if (!v6) {
          goto LABEL_16;
        }
        goto LABEL_12;
      }
      if (!v45) {
        goto LABEL_97;
      }
      BOOL v48 = "invalid";
      if (v6 && *(void *)(v6 + 16)) {
        BOOL v48 = *(const char **)(v6 + 16);
      }
      *(_DWORD *)buf = 136446466;
      char v53 = "nw_protocol_http3_stream_start_datagram_flow";
      __int16 v54 = 2082;
      v55 = (void *)v48;
      uint64_t v43 = "%{public}s protocol %{public}s has invalid connect callback, no backtrace";
    }
    else
    {
      int v40 = __nwlog_obj();
      os_log_type_t v41 = type;
      if (!os_log_type_enabled(v40, type)) {
        goto LABEL_97;
      }
      BOOL v47 = "invalid";
      if (v6 && *(void *)(v6 + 16)) {
        BOOL v47 = *(const char **)(v6 + 16);
      }
      *(_DWORD *)buf = 136446466;
      char v53 = "nw_protocol_http3_stream_start_datagram_flow";
      __int16 v54 = 2082;
      v55 = (void *)v47;
      uint64_t v43 = "%{public}s protocol %{public}s has invalid connect callback, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v40, v41, v43, buf, 0x16u);
    goto LABEL_97;
  }
}

uint64_t ___ZL44nw_protocol_http3_stream_start_datagram_flowP24nw_protocol_http3_stream_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  if (!*(void *)(*(void *)(a1 + 32) + 424) && nw_protocol_metadata_is_quic_stream(a3))
  {
    if (a3) {
      unint64_t v5 = os_retain(a3);
    }
    else {
      unint64_t v5 = 0;
    }
    *(void *)(*(void *)(a1 + 32) + 424) = v5;
    if (nw_quic_stream_get_has_datagram_variant_flow_id(a3))
    {
      *(void *)(*(void *)(a1 + 32) + 248) = nw_quic_stream_get_datagram_variant_flow_id(a3);
      *(_DWORD *)(*(void *)(a1 + 32) + 628) = nw_quic_stream_get_usable_datagram_frame_size(a3);
    }
  }
  return 1;
}

void ___ZN2nw4http22content_length_manager19set_inbound_messageEP20nw_protocol_metadata_block_invoke(uint64_t a1, char *__s)
{
  if (__s)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    size_t v4 = strlen(__s);
    if (v4 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    std::string::size_type v5 = v4;
    if (v4 >= 0x17)
    {
      uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v4 | 7) != 0x17) {
        uint64_t v7 = v4 | 7;
      }
      uint64_t v8 = v7 + 1;
      p_dst = (std::string *)operator new(v7 + 1);
      __dst.__r_.__value_.__l.__size_ = v5;
      __dst.__r_.__value_.__r.__words[2] = v8 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v4;
      p_dst = &__dst;
      if (!v4)
      {
LABEL_10:
        p_dst->__r_.__value_.__s.__data_[v5] = 0;
        *(void *)(v3 + 24) = std::stoull(&__dst, 0, 10);
        *(unsigned char *)(v3 + 32) = 1;
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        return;
      }
    }
    memcpy(p_dst, __s, v5);
    goto LABEL_10;
  }
}

void ___ZN2nw4http22content_length_manager19set_inbound_messageEP20nw_protocol_metadata_block_invoke_2(uint64_t a1, char *__s)
{
  if (__s)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    size_t v4 = strlen(__s);
    if (v4 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    std::string::size_type v5 = v4;
    if (v4 >= 0x17)
    {
      uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v4 | 7) != 0x17) {
        uint64_t v7 = v4 | 7;
      }
      uint64_t v8 = v7 + 1;
      p_dst = (std::string *)operator new(v7 + 1);
      __dst.__r_.__value_.__l.__size_ = v5;
      __dst.__r_.__value_.__r.__words[2] = v8 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v4;
      p_dst = &__dst;
      if (!v4)
      {
LABEL_10:
        p_dst->__r_.__value_.__s.__data_[v5] = 0;
        *(void *)(v3 + 24) = std::stoull(&__dst, 0, 10);
        *(unsigned char *)(v3 + 32) = 1;
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        return;
      }
    }
    memcpy(p_dst, __s, v5);
    goto LABEL_10;
  }
}

uint64_t ___ZL32nw_http3_stream_send_section_ackP24nw_protocol_http3_stream_block_invoke(uint64_t a1, uint64_t a2)
{
  LODWORD(__n) = 0;
  uint64_t v3 = (void *)nw_frame_unclaimed_bytes(a2, &__n);
  memcpy(v3, (const void *)(*(void *)(a1 + 40) + *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) + 720), __n);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += __n;
  return 1;
}

BOOL nw_http3_uni_stream_create_outbound(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = malloc_type_calloc(1uLL, 0x88uLL, 0xEAFB8F1AuLL);
  if (!v6)
  {
    BOOL v10 = __nwlog_obj();
    os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "strict_calloc";
    *(_WORD *)&buf[12] = 2048;
    *(void *)&buf[14] = 1;
    *(_WORD *)&buf[22] = 2048;
    uint64_t v15 = 136;
    uint64_t v11 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v11);
    if (result)
    {
      __break(1u);
      return result;
    }
    free(v11);
  }
  v6[16] = 0;
  *((_OWORD *)v6 + 6) = 0u;
  *((_OWORD *)v6 + 7) = 0u;
  *((_OWORD *)v6 + 4) = 0u;
  *((_OWORD *)v6 + 5) = 0u;
  *((_OWORD *)v6 + 2) = 0u;
  *((_OWORD *)v6 + 3) = 0u;
  *(_OWORD *)uint64_t v6 = 0u;
  *((_OWORD *)v6 + 1) = 0u;
  if (gLogDatapath)
  {
    uint64_t v12 = __nwlog_obj();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_http3_uni_stream_create_outbound";
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = v6;
      _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_DEBUG, "%{public}s created uni_stream %p", buf, 0x16u);
    }
  }
  *(void *)buf = 0;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x2000000000;
  uint64_t v15 = (uint64_t)v6;
  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZL35nw_http3_uni_stream_create_outboundP17nw_protocol_http3yb_block_invoke;
  aBlock[3] = &unk_1E52471F0;
  aBlock[4] = buf;
  v6[12] = _Block_copy(aBlock);
  _Block_object_dispose(buf, 8);
  v6[2] = &g_http3_uni_stream_protocol_identifier;
  if (nw_protocol_http3_uni_stream_get_callbacks(void)::onceToken != -1) {
    dispatch_once(&nw_protocol_http3_uni_stream_get_callbacks(void)::onceToken, &__block_literal_global_67);
  }
  v6[3] = &nw_protocol_http3_uni_stream_get_callbacks(void)::protocol_callbacks;
  v6[5] = v6;
  char v7 = *((unsigned char *)v6 + 131);
  v6[8] = a2;
  v6[9] = a1;
  *((unsigned char *)v6 + 130) = 0;
  if (a3) {
    char v8 = 16;
  }
  else {
    char v8 = 0;
  }
  *((unsigned char *)v6 + 131) = v7 & 0xEF | v8 | 1;
  return (BOOL)v6;
}

uint64_t ___ZL35nw_http3_uni_stream_create_outboundP17nw_protocol_http3yb_block_invoke(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
  }
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

void nw_http3_stream_handle_fields(uint64_t a1, unint64_t a2, uint64_t a3, int a4)
{
  uint64_t v5 = a3;
  uint64_t v86 = *MEMORY[0x1E4F143B8];
  unsigned int v70 = 0;
  uint64_t v8 = nw_frame_unclaimed_bytes(a3, &v70);
  if (!v8)
  {
LABEL_44:
    nw_frame_finalize(v5);
    return;
  }
  int v10 = v8;
  uint64_t v68 = v8;
  uint64_t v69 = 10;
  uint64_t v11 = a1 + 736;
  uint64_t v12 = *(void *)(a1 + 336);
  if ((*(_WORD *)(a1 + 736) & 4) != 0)
  {
    uint64_t v17 = v5;
    int v18 = a4;
    uint64_t v19 = *(void *)(a1 + 240);
    if (a2 > 1)
    {
      uint64_t v23 = v70;
      long long v78 = 0u;
      uint64_t v80 = 0;
      long long v84 = 0u;
      long long v85 = 0u;
      long long v82 = 0u;
      long long v83 = 0u;
      long long v81 = 0u;
      long long v77 = 0u;
      memset(buf, 0, 32);
      *(void *)&buf[32] = a1;
      uint64_t v74 = v19;
      unint64_t v75 = a2;
      unint64_t v76 = a2;
      __int16 v79 = parse_header_prefix;
      int v24 = *(FILE **)(v12 + 544);
      if (v24)
      {
        uint64_t v25 = v70;
        fwrite("qdec: debug: ", 0xDuLL, 1uLL, v24);
        fprintf(*(FILE **)(v12 + 544), "begin reading header block for stream %llu", v19);
        fputc(10, *(FILE **)(v12 + 544));
        uint64_t v23 = v25;
      }
      int v16 = qdec_header_process(v12 + 496, buf, &v68, v23, (unsigned char *)(a1 + 720), &v69);
    }
    else
    {
      uint64_t v20 = *(FILE **)(v12 + 544);
      if (v20)
      {
        fwrite("qdec: debug: ", 0xDuLL, 1uLL, v20);
        fprintf(*(FILE **)(v12 + 544), "header block for stream %llu is too short (%zd byte%.*s)", v19, a2, a2 != 1, "s");
        fputc(10, *(FILE **)(v12 + 544));
      }
      *(void *)(v12 + 824) = 0x10AF00000000;
      *(void *)(v12 + 832) = 0;
      *(void *)(v12 + 840) = v19;
      int v16 = 3;
    }
    int v22 = *(_WORD *)(a1 + 736) & 0xFFFB | (*(unsigned __int8 *)(a1 + 738) << 16);
    *(_WORD *)v11 &= ~4u;
    *(unsigned char *)(a1 + 738) = BYTE2(v22);
    a4 = v18;
    uint64_t v5 = v17;
  }
  else
  {
    uint64_t v13 = v70;
    unsigned int v14 = (void *)(v12 + 576);
    while (1)
    {
      unsigned int v14 = (void *)*v14;
      if (!v14) {
        break;
      }
      if (v14[4] == a1)
      {
        uint64_t v15 = *(FILE **)(v12 + 544);
        if (v15)
        {
          fwrite("qdec: debug: ", 0xDuLL, 1uLL, v15);
          fprintf(*(FILE **)(v12 + 544), "continue reading header block for stream %llu", v14[5]);
          fputc(10, *(FILE **)(v12 + 544));
        }
        int v16 = qdec_header_process(v12 + 496, v14, &v68, v13, (unsigned char *)(a1 + 720), &v69);
        goto LABEL_16;
      }
    }
    BOOL v21 = *(FILE **)(v12 + 544);
    if (v21)
    {
      fwrite("qdec: info: ", 0xCuLL, 1uLL, v21);
      fwrite("could not find header block to continue reading", 0x2FuLL, 1uLL, *(FILE **)(v12 + 544));
      fputc(10, *(FILE **)(v12 + 544));
    }
    int v16 = 3;
LABEL_16:
    LOWORD(v22) = *(_WORD *)v11;
  }
  unsigned int v26 = v68 - v10;
  if ((v22 & 0x800) == 0)
  {
    if (gLogDatapath)
    {
      v65 = __nwlog_obj();
      if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG))
      {
        int v66 = *(_DWORD *)(*(void *)(a1 + 336) + 1280);
        uint64_t v67 = *(void *)(a1 + 240);
        *(_DWORD *)buf = 136447746;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_handle_fields";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = a1 + 636;
        *(_WORD *)&buf[22] = 2080;
        *(void *)&unsigned char buf[24] = " ";
        *(_WORD *)&buf[32] = 1024;
        *(_DWORD *)&buf[34] = v66;
        *(_WORD *)&buf[38] = 2048;
        uint64_t v74 = v67;
        LOWORD(v75) = 1024;
        *(_DWORD *)((char *)&v75 + 2) = v16;
        HIWORD(v75) = 1024;
        LODWORD(v76) = v26;
        _os_log_impl(&dword_1830D4000, v65, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> qpack returned status %d, consumed %u bytes", buf, 0x3Cu);
      }
    }
  }
  switch(v16)
  {
    case 0:
      BOOL v27 = *(void **)(a1 + 488);
      if (v27)
      {
        free(v27);
        *(void *)(a1 + 488) = 0;
      }
      *(void *)(a1 + 496) = 0;
      *(_WORD *)v11 |= 4u;
      if (!a4 || v70 > v26) {
        goto LABEL_43;
      }
      if (!v69)
      {
        *(void *)(a1 + 376) = v5;
LABEL_102:
        nw_http3_stream_received_fields_done(a1);
        return;
      }
      *(unsigned char *)(a1 + 634) = v69;
      unsigned int v28 = *(_DWORD *)(a1 + 372);
      if (v28 > 8) {
        goto LABEL_101;
      }
      if (((1 << v28) & 0x1DD) != 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v29 = *(_DWORD *)(a1 + 372);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_need_section_ack";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v29;
        __int16 v30 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v71 = 0;
        if (!__nwlog_fault(v30, &type, &v71)) {
          goto LABEL_99;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          int v31 = __nwlog_obj();
          os_log_type_t v32 = type;
          if (!os_log_type_enabled(v31, type)) {
            goto LABEL_99;
          }
          int v33 = *(_DWORD *)(a1 + 372);
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_need_section_ack";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v33;
          int v34 = "%{public}s Unexpected input state %d";
        }
        else if (v71)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          int v31 = __nwlog_obj();
          os_log_type_t v32 = type;
          BOOL v53 = os_log_type_enabled(v31, type);
          if (backtrace_string)
          {
            if (v53)
            {
              int v54 = *(_DWORD *)(a1 + 372);
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_http3_stream_need_section_ack";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v54;
              *(_WORD *)&buf[18] = 2082;
              *(void *)&buf[20] = backtrace_string;
              _os_log_impl(&dword_1830D4000, v31, v32, "%{public}s Unexpected input state %d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }
            free(backtrace_string);
            goto LABEL_99;
          }
          if (!v53)
          {
LABEL_99:
            if (v30) {
              free(v30);
            }
            goto LABEL_101;
          }
          int v63 = *(_DWORD *)(a1 + 372);
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_need_section_ack";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v63;
          int v34 = "%{public}s Unexpected input state %d, no backtrace";
        }
        else
        {
          int v31 = __nwlog_obj();
          os_log_type_t v32 = type;
          if (!os_log_type_enabled(v31, type)) {
            goto LABEL_99;
          }
          int v62 = *(_DWORD *)(a1 + 372);
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_need_section_ack";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v62;
          int v34 = "%{public}s Unexpected input state %d, backtrace limit exceeded";
        }
        _os_log_impl(&dword_1830D4000, v31, v32, v34, buf, 0x12u);
        goto LABEL_99;
      }
      if (v28 == 1) {
        *(_DWORD *)(a1 + 372) = 3;
      }
      else {
        *(_DWORD *)(a1 + 372) = 7;
      }
LABEL_101:
      char v64 = nw_http3_stream_send_section_ack(a1);
      *(void *)(a1 + 376) = v5;
      if (v64) {
        goto LABEL_102;
      }
      return;
    case 1:
      nw_frame_claim(v5, v9, v26, 0);
      unsigned int v35 = *(_DWORD *)(a1 + 372);
      if (v35 > 8) {
        goto LABEL_78;
      }
      if (((1 << v35) & 0x1DD) == 0)
      {
        if (v35 == 1) {
          *(_DWORD *)(a1 + 372) = 2;
        }
        else {
          *(_DWORD *)(a1 + 372) = 6;
        }
        goto LABEL_78;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v36 = *(_DWORD *)(a1 + 372);
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_http3_stream_received_fields_blocked";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v36;
      __int16 v37 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v71 = 0;
      if (!__nwlog_fault(v37, &type, &v71)) {
        goto LABEL_76;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unsigned int v38 = gLogObj;
        os_log_type_t v39 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_76;
        }
        int v40 = *(_DWORD *)(a1 + 372);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_received_fields_blocked";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v40;
        os_log_type_t v41 = "%{public}s Unexpected input state %d";
LABEL_75:
        _os_log_impl(&dword_1830D4000, v38, v39, v41, buf, 0x12u);
        goto LABEL_76;
      }
      if (!v71)
      {
        unsigned int v38 = __nwlog_obj();
        os_log_type_t v39 = type;
        if (!os_log_type_enabled(v38, type)) {
          goto LABEL_76;
        }
        int v51 = *(_DWORD *)(a1 + 372);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_received_fields_blocked";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v51;
        os_log_type_t v41 = "%{public}s Unexpected input state %d, backtrace limit exceeded";
        goto LABEL_75;
      }
      __int16 v46 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unsigned int v38 = gLogObj;
      os_log_type_t v39 = type;
      BOOL v47 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (!v46)
      {
        if (!v47) {
          goto LABEL_76;
        }
        int v55 = *(_DWORD *)(a1 + 372);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_received_fields_blocked";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v55;
        os_log_type_t v41 = "%{public}s Unexpected input state %d, no backtrace";
        goto LABEL_75;
      }
      if (v47)
      {
        int v48 = *(_DWORD *)(a1 + 372);
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_received_fields_blocked";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v48;
        *(_WORD *)&buf[18] = 2082;
        *(void *)&buf[20] = v46;
        _os_log_impl(&dword_1830D4000, v38, v39, "%{public}s Unexpected input state %d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }
      free(v46);
LABEL_76:
      if (v37) {
        free(v37);
      }
LABEL_78:
      uint64_t v57 = *(void *)(a1 + 216);
      __int16 v56 = (uint64_t *)(a1 + 216);
      *(void *)(v5 + 32) = v57;
      __int16 v58 = (void *)(v57 + 40);
      if (v57) {
        int v59 = v58;
      }
      else {
        int v59 = v56 + 1;
      }
      void *v59 = v5 + 32;
      *__int16 v56 = v5;
      *(void *)(v5 + 40) = v56;
      if (a4) {
        __int16 v60 = 8;
      }
      else {
        __int16 v60 = 0;
      }
      int v61 = *(_WORD *)v11 & 0xFFF7 | (*(unsigned __int8 *)(v11 + 2) << 16);
      *(_WORD *)uint64_t v11 = *(_WORD *)v11 & 0xFFF7 | v60;
      *(unsigned char *)(v11 + 2) = BYTE2(v61);
      return;
    case 2:
      if (v70 != v26)
      {
        nw_frame_finalize(v5);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_handle_fields";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v26;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v70;
        int v42 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v71 = 0;
        if (!__nwlog_fault(v42, &type, &v71)) {
          goto LABEL_90;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v43 = gLogObj;
          os_log_type_t v44 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_90;
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_handle_fields";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v26;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v70;
          BOOL v45 = "%{public}s Expected consumed_size (%u) to be equal to frame_size (%u)";
        }
        else if (v71)
        {
          BOOL v49 = (char *)__nw_create_backtrace_string();
          uint64_t v43 = __nwlog_obj();
          os_log_type_t v44 = type;
          BOOL v50 = os_log_type_enabled(v43, type);
          if (v49)
          {
            if (v50)
            {
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_http3_stream_handle_fields";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v26;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v70;
              *(_WORD *)&unsigned char buf[24] = 2082;
              *(void *)&buf[26] = v49;
              _os_log_impl(&dword_1830D4000, v43, v44, "%{public}s Expected consumed_size (%u) to be equal to frame_size (%u), dumping backtrace:%{public}s", buf, 0x22u);
            }
            free(v49);
            goto LABEL_90;
          }
          if (!v50)
          {
LABEL_90:
            if (v42) {
              free(v42);
            }
            return;
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_handle_fields";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v26;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v70;
          BOOL v45 = "%{public}s Expected consumed_size (%u) to be equal to frame_size (%u), no backtrace";
        }
        else
        {
          uint64_t v43 = __nwlog_obj();
          os_log_type_t v44 = type;
          if (!os_log_type_enabled(v43, type)) {
            goto LABEL_90;
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_handle_fields";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v26;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v70;
          BOOL v45 = "%{public}s Expected consumed_size (%u) to be equal to frame_size (%u), backtrace limit exceeded";
        }
        _os_log_impl(&dword_1830D4000, v43, v44, v45, buf, 0x18u);
        goto LABEL_90;
      }
      if (!a4) {
        goto LABEL_44;
      }
LABEL_43:
      nw_frame_finalize(v5);
      nw_http3_fail_all_streams(*(void *)(a1 + 336), 512);
      return;
    case 3:
      nw_frame_finalize(v5);
      *(void *)(a1 + 264) = 270;
      nw_protocol_http3_stream_error((nw_protocol *)a1, (nw_protocol *)a1, 94);
      nw_protocol_http3_stream_disconnect((nw_protocol *)a1, (nw_protocol *)a1);
      return;
    default:
      return;
  }
}

uint64_t nw_http3_framer_get_input_frames(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4, void *a5, void *a6, unsigned char *a7, uint64_t a8, uint64_t a9)
{
  if (*(void *)(a1 + 16))
  {
    return nw_http3_framer_deliver_http3_frame_body(a1, a2, a3, a4, a5, a6, a7, a9);
  }
  else
  {
    uint64_t v15 = *(void *)(a1 + 48);
    if (v15) {
      goto LABEL_15;
    }
LABEL_8:
    uint64_t v16 = *(void *)(a1 + 40);
    if (!v16) {
      return 0;
    }
    uint64_t v17 = *(void *)(v16 + 24);
    if (!v17) {
      return 0;
    }
    int v18 = *(unsigned int (**)(void))(v17 + 80);
    if (!v18) {
      return 0;
    }
    uint64_t v32 = 0;
    int v33 = &v32;
    if (!v18()) {
      return 0;
    }
    if (v32)
    {
      **(void **)(a1 + 56) = v32;
      uint64_t v19 = v33;
      *(void *)(v32 + 40) = *(void *)(a1 + 56);
      *(void *)(a1 + 56) = v19;
    }
    uint64_t v15 = *(void *)(a1 + 48);
LABEL_15:
    while (1)
    {
      uint64_t v32 = 0;
      int v33 = &v32;
      uint64_t v34 = 0x2000000000;
      char v35 = 0;
      v26[0] = MEMORY[0x1E4F143A8];
      v26[1] = 0x40000000;
      BOOL v27 = (uint64_t (*)(void *))___ZL32nw_http3_framer_get_input_framesP15nw_http3_framerjjjPyS1_PbPjP16nw_frame_array_s_block_invoke;
      unsigned int v28 = &unk_1E5247320;
      int v29 = &v32;
      uint64_t v30 = a1;
      uint64_t v31 = a8;
      do
      {
        if (!v15) {
          break;
        }
        uint64_t v20 = *(void *)(v15 + 32);
        char v21 = v27(v26);
        uint64_t v15 = v20;
      }
      while ((v21 & 1) != 0);
      if (*((unsigned char *)v33 + 24)) {
        break;
      }
      _Block_object_dispose(&v32, 8);
      uint64_t v15 = *(void *)(a1 + 48);
      if (!v15) {
        goto LABEL_8;
      }
    }
    uint64_t v22 = nw_http3_framer_deliver_http3_frame_body(a1, a2, a3, a4, a5, a6, a7, a9);
    _Block_object_dispose(&v32, 8);
    return v22;
  }
}

uint64_t ___ZL37nw_http3_control_stream_process_inputP17nw_protocol_http3_block_invoke(void *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 32);
  uint64_t v5 = *(void **)(a2 + 40);
  if (v4)
  {
    *(void *)(v4 + 40) = v5;
    uint64_t v5 = *(void **)(a2 + 40);
  }
  else
  {
    *(void *)(*(void *)(a1[4] + 8) + 48) = v5;
  }
  void *v5 = v4;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  LODWORD(__n) = 0;
  uint64_t v6 = (const void *)nw_frame_unclaimed_bytes(a2, &__n);
  memcpy((void *)(a1[6] + *(unsigned int *)(*(void *)(a1[5] + 8) + 24)), v6, __n);
  *(_DWORD *)(*(void *)(a1[5] + 8) + 24) += __n;
  nw_frame_finalize(a2);
  return 1;
}

BOOL nw_http3_parse_settings(uint64_t a1, _DWORD *a2, unsigned int a3, __n128 a4)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    unint64_t v5 = 0;
    unint64_t v6 = 0;
    char v7 = 0;
    char v8 = 0;
    char v9 = 0;
    unint64_t v10 = a3;
    uint64_t v11 = (unsigned __int16 *)(a1 + 1373);
    uint64_t v12 = a1 + 1289;
    unint64_t v13 = -1;
    p_cache = NWConcrete_nw_resolution_report.cache;
    a4.n128_u64[0] = 136447490;
    while (2)
    {
      if (a2)
      {
        unint64_t v15 = *(unsigned __int8 *)a2;
        if (v15 > 0x3F)
        {
          if (v15 >> 6 == 2)
          {
            if (v10 < 4) {
              return 0;
            }
            unint64_t v15 = bswap32(*a2 & 0xFFFFFF7F);
            uint64_t v16 = 4;
            unint64_t v17 = v10 - 4;
            if (v10 == 4) {
              return 0;
            }
          }
          else if (v15 >> 6 == 1)
          {
            if (v10 < 2) {
              return 0;
            }
            unint64_t v15 = bswap32(*(_WORD *)a2 & 0xFFBF) >> 16;
            uint64_t v16 = 2;
            unint64_t v17 = v10 - 2;
            if (v10 == 2) {
              return 0;
            }
          }
          else
          {
            if (v10 < 8) {
              return 0;
            }
            unint64_t v15 = bswap64(*(void *)a2 & 0xFFFFFFFFFFFFFF3FLL);
            uint64_t v16 = 8;
            unint64_t v17 = v10 - 8;
            if (v10 == 8) {
              return 0;
            }
          }
        }
        else
        {
          uint64_t v16 = 1;
          unint64_t v17 = v10 - 1;
          if (v10 == 1) {
            return 0;
          }
        }
        int v18 = (_DWORD *)((char *)a2 + v16);
        unint64_t v19 = *((unsigned __int8 *)a2 + v16);
        if (v19 <= 0x3F)
        {
          uint64_t v20 = 1;
LABEL_28:
          if (((*v11 | (*(unsigned __int8 *)(a1 + 1375) << 16)) & 0x400000) == 0)
          {
            if (*((unsigned char *)p_cache + 3665))
            {
              unint64_t v48 = v6;
              unint64_t v49 = v5;
              __int16 v46 = (char *)v12;
              unint64_t v47 = v13;
              __n128 v45 = a4;
              os_log_t log = __nwlog_obj();
              BOOL v22 = os_log_type_enabled(log, OS_LOG_TYPE_DEBUG);
              a4 = v45;
              p_cache = (void **)(NWConcrete_nw_resolution_report + 16);
              uint64_t v12 = (uint64_t)v46;
              unint64_t v13 = v47;
              unint64_t v6 = v48;
              unint64_t v5 = v49;
              if (v22)
              {
                int v23 = *(_DWORD *)(a1 + 1280);
                *(_DWORD *)buf = v45.n128_u32[0];
                BOOL v53 = "nw_http3_parse_settings";
                __int16 v54 = 2082;
                int v55 = v46;
                __int16 v56 = 2080;
                uint64_t v57 = " ";
                __int16 v58 = 1024;
                int v59 = v23;
                __int16 v60 = 2048;
                unint64_t v61 = v15;
                __int16 v62 = 2048;
                unint64_t v63 = v19;
                _os_log_impl(&dword_1830D4000, log, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> setting %llu = %llu", buf, 0x3Au);
                a4 = v45;
                p_cache = (void **)(NWConcrete_nw_resolution_report + 16);
                uint64_t v12 = (uint64_t)v46;
                unint64_t v13 = v47;
                unint64_t v6 = v48;
                unint64_t v5 = v49;
              }
            }
          }
          BOOL result = 0;
          switch(v15)
          {
            case 1uLL:
              if (v9) {
                return 0;
              }
              char v9 = 1;
              unint64_t v6 = v19;
              goto LABEL_3;
            case 2uLL:
            case 3uLL:
            case 4uLL:
            case 5uLL:
              return result;
            case 6uLL:
              if (v8) {
                return 0;
              }
              char v8 = 1;
              unint64_t v13 = v19;
              goto LABEL_3;
            case 7uLL:
              if (v7) {
                return 0;
              }
              char v7 = 1;
              unint64_t v5 = v19;
              goto LABEL_3;
            default:
LABEL_3:
              a2 = (_DWORD *)((char *)v18 + v20);
              unint64_t v10 = v17 - v20;
              if (v17 != v20) {
                continue;
              }
              goto LABEL_40;
          }
        }
        if (v19 >> 6 == 2)
        {
          if (v17 >= 4)
          {
            unint64_t v19 = bswap32(*v18 & 0xFFFFFF7F);
            uint64_t v20 = 4;
            goto LABEL_28;
          }
        }
        else if (v19 >> 6 == 1)
        {
          if (v17 >= 2)
          {
            unint64_t v19 = bswap32(*(_WORD *)v18 & 0xFFBF) >> 16;
            uint64_t v20 = 2;
            goto LABEL_28;
          }
        }
        else if (v17 >= 8)
        {
          unint64_t v19 = bswap64(*(void *)v18 & 0xFFFFFFFFFFFFFF3FLL);
          uint64_t v20 = 8;
          goto LABEL_28;
        }
        return 0;
      }
      break;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v53 = "_http_vle_decode";
    unsigned int v38 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v50 = 0;
    if (__nwlog_fault(v38, &type, &v50))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v39 = __nwlog_obj();
        os_log_type_t v40 = type;
        if (!os_log_type_enabled(v39, type)) {
          goto LABEL_92;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v53 = "_http_vle_decode";
        os_log_type_t v41 = "%{public}s called with null *buffer";
        goto LABEL_91;
      }
      if (!v50)
      {
        os_log_type_t v39 = __nwlog_obj();
        os_log_type_t v40 = type;
        if (!os_log_type_enabled(v39, type)) {
          goto LABEL_92;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v53 = "_http_vle_decode";
        os_log_type_t v41 = "%{public}s called with null *buffer, backtrace limit exceeded";
        goto LABEL_91;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v39 = __nwlog_obj();
      os_log_type_t v40 = type;
      BOOL v43 = os_log_type_enabled(v39, type);
      if (backtrace_string)
      {
        if (v43)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v53 = "_http_vle_decode";
          __int16 v54 = 2082;
          int v55 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v39, v40, "%{public}s called with null *buffer, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_92;
      }
      if (v43)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v53 = "_http_vle_decode";
        os_log_type_t v41 = "%{public}s called with null *buffer, no backtrace";
LABEL_91:
        _os_log_impl(&dword_1830D4000, v39, v40, v41, buf, 0xCu);
      }
    }
LABEL_92:
    if (v38) {
      free(v38);
    }
    return 0;
  }
  unint64_t v6 = 0;
  unint64_t v5 = 0;
  unint64_t v13 = -1;
LABEL_40:
  if ((*(_WORD *)(a1 + 1373) & 0x100) == 0)
  {
    *(void *)(a1 + 992) = v6;
    *(void *)(a1 + 1008) = v13;
    *(void *)(a1 + 1000) = v5;
    if (v6 >= 0x10000) {
      uint64_t v24 = 0x10000;
    }
    else {
      uint64_t v24 = v6;
    }
    if (v24 > v6)
    {
      int v25 = 22;
LABEL_46:
      *__error() = v25;
      size_t v26 = 8;
LABEL_73:
      *(void *)(a1 + 1200) = dispatch_data_create(buf, v26, 0, 0);
      nw_http3_start_encoder_stream_if_needed(a1);
      nw_http3_encoder_stream_process_output(a1);
      return 1;
    }
    if (v24)
    {
      buf[0] = 32;
      if (v24 > 0x1E)
      {
        buf[0] = 63;
        unint64_t v30 = v24 - 31;
        if ((unint64_t)(v24 - 31) < 0x80)
        {
          uint64_t v32 = 1;
          uint64_t v31 = buf;
        }
        else
        {
          buf[1] = v30 | 0x80;
          if (v30 < 0x4000)
          {
            uint64_t v31 = &buf[1];
            v30 >>= 7;
            uint64_t v32 = 2;
          }
          else
          {
            uint64_t v31 = &buf[2];
            buf[2] = (v30 >> 7) | 0x80;
            v30 >>= 14;
            uint64_t v32 = 3;
          }
        }
        BOOL v27 = v31 + 2;
        buf[v32] = v30;
        if (v31 + 2 <= buf)
        {
          int v25 = 55;
          goto LABEL_46;
        }
      }
      else
      {
        BOOL v27 = &buf[1];
        buf[0] = v24 | 0x20;
      }
      unsigned int v28 = v6;
      int v29 = v5;
      int v33 = *(FILE **)(a1 + 456);
      if (v33)
      {
        fwrite("qenc: debug: ", 0xDuLL, 1uLL, v33);
        size_t v26 = v27 - buf;
        fprintf(*(FILE **)(a1 + 456), "generated TSU=%u instruction %zd byte%.*s in size", v24, v26, v26 != 1, "s");
        fputc(10, *(FILE **)(a1 + 456));
      }
      else
      {
        size_t v26 = v27 - buf;
      }
    }
    else
    {
      unsigned int v28 = v6;
      int v29 = v5;
      size_t v26 = 0;
    }
    unsigned int v34 = v24 / 0x60;
    if (v24 <= 0x4DF) {
      unsigned int v34 = 12;
    }
    *(_DWORD *)(a1 + 484) = v34;
    char v35 = malloc_type_malloc(8 * v34 + 8, 0x100004000313F17uLL);
    *(void *)(a1 + 472) = v35;
    if (v35)
    {
      if (v28 >= 0x20)
      {
        int v36 = malloc_type_malloc(0x80uLL, 0xA004088793A40uLL);
        if (!v36)
        {
          free(*(void **)(a1 + 472));
          if (v26) {
            goto LABEL_73;
          }
          goto LABEL_77;
        }
        v36[2] = 0;
        v36[3] = v36 + 2;
        v36[4] = 0;
        v36[5] = v36 + 4;
        v36[6] = 0;
        v36[7] = v36 + 6;
        v36[8] = 0;
        v36[9] = v36 + 8;
        v36[10] = 0;
        v36[11] = v36 + 10;
        v36[12] = 0;
        v36[13] = v36 + 12;
        v36[14] = 0;
        v36[15] = v36 + 14;
        int v37 = 2;
        *int v36 = 0;
        v36[1] = v36;
      }
      else
      {
        int v36 = 0;
        int v37 = 0;
      }
      *(_DWORD *)(a1 + 284) = v28 >> 5;
      *(_DWORD *)(a1 + 280) = v28;
      *(_DWORD *)(a1 + 276) = v24;
      *(_DWORD *)(a1 + 292) = v29;
      *(void *)(a1 + 328) = v36;
      *(_DWORD *)(a1 + 308) = v37;
      *(void *)(a1 + 456) = 0;
      *(_DWORD *)(a1 + 268) |= 2u;
    }
    if (v26) {
      goto LABEL_73;
    }
LABEL_77:
    *(_WORD *)(a1 + 1373) |= 0x2000u;
    return 1;
  }
  if (*(void *)(a1 + 992) > v6 || *(void *)(a1 + 1008) > v13) {
    return 0;
  }
  return *(void *)(a1 + 1000) <= v5;
}

void nw_http3_try_persist_0rtt_state(uint64_t a1)
{
  if (uuid_is_null((const unsigned __int8 *)(a1 + 848))
    && *(void *)(a1 + 1160)
    && *(void *)(a1 + 1168)
    && *(void *)(a1 + 1176))
  {
    BOOL v2 = nw_array_create();
    nw_array_append(v2, *(void **)(a1 + 1176));
    nw_array_append(v2, *(void **)(a1 + 1160));
    nw_array_append(v2, *(void **)(a1 + 1168));
    BOOL v3 = nw_array_create();
    nw_array_append(v3, (void *)v2);
    if (nw_storage_copy_shared_token[0] != -1) {
      dispatch_once(nw_storage_copy_shared_token, &__block_literal_global_45557);
    }
    id v4 = (id)nw_storage_copy_shared_storage;
    unint64_t v5 = *(void **)(a1 + 1096);
    if (v5) {
      unint64_t v6 = os_retain(v5);
    }
    else {
      unint64_t v6 = 0;
    }
    while (1)
    {
      char v7 = v6;
      id v8 = nw_endpoint_copy_parent_endpoint(v6);
      if (!v8) {
        break;
      }
      unint64_t v6 = v8;
      if (v7) {
        os_release(v7);
      }
    }
    nw_storage_store_items(v4, (uint64_t)"h3_0rtt", (void *)v3, v6, *(void **)(a1 + 1256), &__block_literal_global_85);
    if (v6) {
      os_release(v6);
    }
    if (v4) {
      os_release(v4);
    }
    if (v2) {
      os_release((void *)v2);
    }
    if (v3)
    {
      os_release((void *)v3);
    }
  }
}

void nw_http3_notify_do_not_reuse(uint64_t a1)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 880);
  if (v1)
  {
    BOOL v3 = (unsigned __int16 *)(a1 + 1373);
    id v4 = (const char *)(a1 + 1289);
    do
    {
      uint64_t v5 = v1;
      uint64_t v1 = *(void *)(v1 + 544);
      if ((*(_WORD *)(v5 + 736) & 0x8000) != 0)
      {
        if (((*v3 | (*((unsigned __int8 *)v3 + 2) << 16)) & 0x400000) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          unint64_t v6 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          {
            int v7 = *(_DWORD *)(a1 + 1280);
            uint64_t v8 = *(void *)(v5 + 240);
            *(_DWORD *)buf = 136447234;
            unsigned int v34 = "nw_http3_notify_do_not_reuse";
            __int16 v35 = 2082;
            int v36 = v4;
            __int16 v37 = 2080;
            unsigned int v38 = " ";
            __int16 v39 = 1024;
            int v40 = v7;
            __int16 v41 = 2048;
            uint64_t v42 = v8;
            _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Notifying stream %llu to not reuse the connection", buf, 0x30u);
          }
        }
        uint64_t v9 = *(void *)(v5 + 24);
        if (!v9 || (unint64_t v10 = *(void (**)(uint64_t, uint64_t, uint64_t, void, void))(v9 + 160)) == 0)
        {
          __nwlog_obj();
          uint64_t v11 = *(const char **)(v5 + 16);
          if (!v11) {
            uint64_t v11 = "invalid";
          }
          *(_DWORD *)buf = 136446466;
          unsigned int v34 = "nw_http3_notify_do_not_reuse";
          __int16 v35 = 2082;
          int v36 = v11;
          uint64_t v12 = (const char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v31 = 0;
          unint64_t v30 = (char *)v12;
          if (!__nwlog_fault(v12, &type, &v31)) {
            goto LABEL_35;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            unint64_t v13 = __nwlog_obj();
            os_log_type_t v14 = type;
            *(void *)BOOL v27 = v13;
            if (os_log_type_enabled(v13, type))
            {
              unint64_t v15 = *(const char **)(v5 + 16);
              if (!v15) {
                unint64_t v15 = "invalid";
              }
              *(_DWORD *)buf = 136446466;
              unsigned int v34 = "nw_http3_notify_do_not_reuse";
              __int16 v35 = 2082;
              int v36 = v15;
              uint64_t v16 = *(NSObject **)v27;
              os_log_type_t v17 = v14;
              int v18 = "%{public}s protocol %{public}s has invalid notify callback";
              goto LABEL_34;
            }
            goto LABEL_35;
          }
          if (v31)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            os_log_t log = __nwlog_obj();
            os_log_type_t v28 = type;
            BOOL v20 = os_log_type_enabled(log, type);
            if (backtrace_string)
            {
              if (v20)
              {
                char v21 = *(const char **)(v5 + 16);
                if (!v21) {
                  char v21 = "invalid";
                }
                *(_DWORD *)buf = 136446722;
                unsigned int v34 = "nw_http3_notify_do_not_reuse";
                __int16 v35 = 2082;
                int v36 = v21;
                __int16 v37 = 2082;
                unsigned int v38 = backtrace_string;
                _os_log_impl(&dword_1830D4000, log, v28, "%{public}s protocol %{public}s has invalid notify callback, dumping backtrace:%{public}s", buf, 0x20u);
              }
              free(backtrace_string);
              goto LABEL_35;
            }
            if (!v20)
            {
LABEL_35:
              if (v30) {
                free(v30);
              }
              continue;
            }
            int v25 = *(const char **)(v5 + 16);
            if (!v25) {
              int v25 = "invalid";
            }
            *(_DWORD *)buf = 136446466;
            unsigned int v34 = "nw_http3_notify_do_not_reuse";
            __int16 v35 = 2082;
            int v36 = v25;
            uint64_t v16 = log;
            os_log_type_t v17 = v28;
            int v18 = "%{public}s protocol %{public}s has invalid notify callback, no backtrace";
          }
          else
          {
            BOOL v22 = __nwlog_obj();
            os_log_type_t v23 = type;
            *(void *)int v29 = v22;
            if (!os_log_type_enabled(v22, type)) {
              goto LABEL_35;
            }
            uint64_t v24 = *(const char **)(v5 + 16);
            if (!v24) {
              uint64_t v24 = "invalid";
            }
            *(_DWORD *)buf = 136446466;
            unsigned int v34 = "nw_http3_notify_do_not_reuse";
            __int16 v35 = 2082;
            int v36 = v24;
            uint64_t v16 = *(NSObject **)v29;
            os_log_type_t v17 = v23;
            int v18 = "%{public}s protocol %{public}s has invalid notify callback, backtrace limit exceeded";
          }
LABEL_34:
          _os_log_impl(&dword_1830D4000, v16, v17, v18, buf, 0x16u);
          goto LABEL_35;
        }
        v10(v5, v5, 12, 0, 0);
      }
    }
    while (v1);
  }
}

uint64_t ___ZL37nw_http3_control_stream_process_inputP17nw_protocol_http3_block_invoke_76(void *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 32);
  uint64_t v5 = *(void **)(a2 + 40);
  if (v4)
  {
    *(void *)(v4 + 40) = v5;
    uint64_t v5 = *(void **)(a2 + 40);
  }
  else
  {
    *(void *)(*(void *)(a1[4] + 8) + 48) = v5;
  }
  void *v5 = v4;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  LODWORD(__n) = 0;
  unint64_t v6 = (const void *)nw_frame_unclaimed_bytes(a2, &__n);
  memcpy((void *)(a1[6] + *(unsigned int *)(*(void *)(a1[5] + 8) + 24)), v6, __n);
  *(_DWORD *)(*(void *)(a1[5] + 8) + 24) += __n;
  nw_frame_finalize(a2);
  return 1;
}

void nw_http3_start_encoder_stream_if_needed(uint64_t a1)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  if (!*(void *)(a1 + 1056))
  {
    outbound = (_OWORD *)nw_http3_uni_stream_create_outbound(a1, 2, 1);
    *(void *)(a1 + 1056) = outbound;
    _OWORD *outbound = *(_OWORD *)a1;
    nw_protocol_set_input_handler(*(void *)(a1 + 1056), a1);
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void (***)(void, void))(v3 + 24);
      if (v4)
      {
        uint64_t v5 = *v4;
        if (v5)
        {
          v5(*(void *)(a1 + 32), *(void *)(a1 + 1056));
          goto LABEL_6;
        }
      }
      __nwlog_obj();
      uint64_t v8 = *(const char **)(v3 + 16);
      if (!v8) {
        uint64_t v8 = "invalid";
      }
    }
    else
    {
      __nwlog_obj();
      uint64_t v8 = "invalid";
    }
    *(_DWORD *)buf = 136446466;
    int v33 = "nw_http3_start_encoder_stream_if_needed";
    __int16 v34 = 2082;
    __int16 v35 = v8;
    unint64_t v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (__nwlog_fault(v10, &type, &v30))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (!os_log_type_enabled(v11, type)) {
          goto LABEL_43;
        }
        unint64_t v13 = "invalid";
        if (v3 && *(void *)(v3 + 16)) {
          unint64_t v13 = *(const char **)(v3 + 16);
        }
        *(_DWORD *)buf = 136446466;
        int v33 = "nw_http3_start_encoder_stream_if_needed";
        __int16 v34 = 2082;
        __int16 v35 = v13;
        os_log_type_t v14 = "%{public}s protocol %{public}s has invalid add_input_handler callback";
LABEL_42:
        _os_log_impl(&dword_1830D4000, v11, v12, v14, buf, 0x16u);
        goto LABEL_43;
      }
      if (!v30)
      {
        uint64_t v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (!os_log_type_enabled(v11, type)) {
          goto LABEL_43;
        }
        int v18 = "invalid";
        if (v3 && *(void *)(v3 + 16)) {
          int v18 = *(const char **)(v3 + 16);
        }
        *(_DWORD *)buf = 136446466;
        int v33 = "nw_http3_start_encoder_stream_if_needed";
        __int16 v34 = 2082;
        __int16 v35 = v18;
        os_log_type_t v14 = "%{public}s protocol %{public}s has invalid add_input_handler callback, backtrace limit exceeded";
        goto LABEL_42;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v16 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (!v16) {
          goto LABEL_43;
        }
        unint64_t v19 = "invalid";
        if (v3 && *(void *)(v3 + 16)) {
          unint64_t v19 = *(const char **)(v3 + 16);
        }
        *(_DWORD *)buf = 136446466;
        int v33 = "nw_http3_start_encoder_stream_if_needed";
        __int16 v34 = 2082;
        __int16 v35 = v19;
        os_log_type_t v14 = "%{public}s protocol %{public}s has invalid add_input_handler callback, no backtrace";
        goto LABEL_42;
      }
      if (v16)
      {
        os_log_type_t v17 = "invalid";
        if (v3 && *(void *)(v3 + 16)) {
          os_log_type_t v17 = *(const char **)(v3 + 16);
        }
        *(_DWORD *)buf = 136446722;
        int v33 = "nw_http3_start_encoder_stream_if_needed";
        __int16 v34 = 2082;
        __int16 v35 = v17;
        __int16 v36 = 2082;
        __int16 v37 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s protocol %{public}s has invalid add_input_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(backtrace_string);
    }
LABEL_43:
    if (v10) {
      free(v10);
    }
    if (!v3)
    {
      __nwlog_obj();
      uint64_t v9 = "invalid";
      goto LABEL_47;
    }
LABEL_6:
    uint64_t v6 = *(void *)(v3 + 24);
    if (v6)
    {
      int v7 = *(void (**)(uint64_t, void))(v6 + 24);
      if (v7)
      {
        v7(v3, *(void *)(a1 + 1056));
        return;
      }
    }
    __nwlog_obj();
    uint64_t v9 = *(const char **)(v3 + 16);
    if (!v9) {
      uint64_t v9 = "invalid";
    }
LABEL_47:
    *(_DWORD *)buf = 136446466;
    int v33 = "nw_http3_start_encoder_stream_if_needed";
    __int16 v34 = 2082;
    __int16 v35 = v9;
    BOOL v20 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (!__nwlog_fault(v20, &type, &v30)) {
      goto LABEL_73;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v21 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_73;
      }
      os_log_type_t v23 = "invalid";
      if (v3 && *(void *)(v3 + 16)) {
        os_log_type_t v23 = *(const char **)(v3 + 16);
      }
      *(_DWORD *)buf = 136446466;
      int v33 = "nw_http3_start_encoder_stream_if_needed";
      __int16 v34 = 2082;
      __int16 v35 = v23;
      uint64_t v24 = "%{public}s protocol %{public}s has invalid connect callback";
    }
    else if (v30)
    {
      int v25 = (char *)__nw_create_backtrace_string();
      char v21 = __nwlog_obj();
      os_log_type_t v22 = type;
      BOOL v26 = os_log_type_enabled(v21, type);
      if (v25)
      {
        if (v26)
        {
          BOOL v27 = "invalid";
          if (v3 && *(void *)(v3 + 16)) {
            BOOL v27 = *(const char **)(v3 + 16);
          }
          *(_DWORD *)buf = 136446722;
          int v33 = "nw_http3_start_encoder_stream_if_needed";
          __int16 v34 = 2082;
          __int16 v35 = v27;
          __int16 v36 = 2082;
          __int16 v37 = v25;
          _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s protocol %{public}s has invalid connect callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v25);
        goto LABEL_73;
      }
      if (!v26)
      {
LABEL_73:
        if (v20) {
          free(v20);
        }
        return;
      }
      int v29 = "invalid";
      if (v3 && *(void *)(v3 + 16)) {
        int v29 = *(const char **)(v3 + 16);
      }
      *(_DWORD *)buf = 136446466;
      int v33 = "nw_http3_start_encoder_stream_if_needed";
      __int16 v34 = 2082;
      __int16 v35 = v29;
      uint64_t v24 = "%{public}s protocol %{public}s has invalid connect callback, no backtrace";
    }
    else
    {
      char v21 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_73;
      }
      os_log_type_t v28 = "invalid";
      if (v3 && *(void *)(v3 + 16)) {
        os_log_type_t v28 = *(const char **)(v3 + 16);
      }
      *(_DWORD *)buf = 136446466;
      int v33 = "nw_http3_start_encoder_stream_if_needed";
      __int16 v34 = 2082;
      __int16 v35 = v28;
      uint64_t v24 = "%{public}s protocol %{public}s has invalid connect callback, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v21, v22, v24, buf, 0x16u);
    goto LABEL_73;
  }
}

void nw_http3_encoder_stream_process_output(uint64_t a1)
{
  v138[2] = *MEMORY[0x1E4F143B8];
  BOOL v2 = (_WORD *)(a1 + 1373);
  if ((*(_WORD *)(a1 + 1373) & 0x2000) != 0) {
    goto LABEL_28;
  }
  uint64_t v3 = *(NSObject **)(a1 + 1200);
  if (v3)
  {
    *(void *)char v126 = 0;
    int v127 = v126;
    int v129 = 0;
    uint64_t v128 = 0x2000000000;
    size_t size = dispatch_data_get_size(v3);
    int v129 = size;
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3802000000;
    *(void *)&unsigned char buf[24] = __Block_byref_object_copy__61309;
    int v137 = __Block_byref_object_dispose__61310;
    v138[0] = 0;
    v138[1] = v138;
    uint64_t v5 = *(void *)(a1 + 1056);
    if (!v5) {
      goto LABEL_162;
    }
    uint64_t v6 = *(void *)(v5 + 24);
    if (!v6) {
      goto LABEL_162;
    }
    int v7 = *(unsigned int (**)(void, uint64_t, size_t, size_t, uint64_t))(v6 + 88);
    if (!v7 || !v7(*(void *)(a1 + 1056), a1, size, size, 0xFFFFFFFFLL)) {
      goto LABEL_162;
    }
    v120[0] = MEMORY[0x1E4F143A8];
    v120[1] = 0x40000000;
    v121 = (uint64_t (*)(void *))___ZL38nw_http3_encoder_stream_process_outputP17nw_protocol_http3_block_invoke;
    uint64_t v122 = &unk_1E5247570;
    v123 = v126;
    char v124 = buf;
    uint64_t v125 = a1;
    uint64_t v8 = *(void *)(*(void *)&buf[8] + 40);
    do
    {
      if (!v8) {
        break;
      }
      uint64_t v9 = *(void *)(v8 + 32);
      char v10 = v121(v120);
      uint64_t v8 = v9;
    }
    while ((v10 & 1) != 0);
    if (*(void *)(a1 + 1200))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)v130 = 136446210;
      uint64_t v131 = "nw_http3_encoder_stream_process_output";
      uint64_t v11 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v118 = 0;
      if (!__nwlog_fault(v11, &type, &v118)) {
        goto LABEL_160;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v12 = gLogObj;
        os_log_type_t v13 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_160;
        }
        *(_DWORD *)v130 = 136446210;
        uint64_t v131 = "nw_http3_encoder_stream_process_output";
        os_log_type_t v14 = "%{public}s Not enough space for sdtc";
      }
      else
      {
        if (v118)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          char v100 = gLogObj;
          os_log_type_t v101 = type;
          BOOL v102 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (backtrace_string)
          {
            if (v102)
            {
              *(_DWORD *)v130 = 136446466;
              uint64_t v131 = "nw_http3_encoder_stream_process_output";
              __int16 v132 = 2082;
              v133 = backtrace_string;
              _os_log_impl(&dword_1830D4000, v100, v101, "%{public}s Not enough space for sdtc, dumping backtrace:%{public}s", v130, 0x16u);
            }
            free(backtrace_string);
            goto LABEL_160;
          }
          if (!v102)
          {
LABEL_160:
            if (v11) {
              free(v11);
            }
LABEL_162:
            _Block_object_dispose(buf, 8);
            _Block_object_dispose(v126, 8);
            return;
          }
          *(_DWORD *)v130 = 136446210;
          uint64_t v131 = "nw_http3_encoder_stream_process_output";
          os_log_type_t v14 = "%{public}s Not enough space for sdtc, no backtrace";
          unsigned int v105 = v100;
          os_log_type_t v106 = v101;
LABEL_159:
          _os_log_impl(&dword_1830D4000, v105, v106, v14, v130, 0xCu);
          goto LABEL_160;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v12 = gLogObj;
        os_log_type_t v13 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_160;
        }
        *(_DWORD *)v130 = 136446210;
        uint64_t v131 = "nw_http3_encoder_stream_process_output";
        os_log_type_t v14 = "%{public}s Not enough space for sdtc, backtrace limit exceeded";
      }
      unsigned int v105 = v12;
      os_log_type_t v106 = v13;
      goto LABEL_159;
    }
    uint64_t v23 = *(void *)(v5 + 24);
    if (v23)
    {
      uint64_t v24 = *(void (**)(uint64_t, uint64_t))(v23 + 96);
      if (v24)
      {
        v24(v5, *(void *)&buf[8] + 40);
LABEL_27:
        *v2 |= 0x2000u;
        _Block_object_dispose(buf, 8);
        _Block_object_dispose(v126, 8);
LABEL_28:
        uint64_t v25 = *(void *)(a1 + 928);
        while (1)
        {
          if (!v25) {
            return;
          }
          int v27 = *(_DWORD *)(v25 + 368);
          if (v27 != 2) {
            break;
          }
          int is_metadata_complete = nw_frame_is_metadata_complete(*(void *)(v25 + 384));
          if (nw_http3_stream_send_fields(v25, is_metadata_complete))
          {
            uint64_t v37 = *(void *)(v25 + 48);
            if (!v37
              || (uint64_t v38 = *(void *)(v37 + 24)) == 0
              || (__int16 v39 = *(void (**)(uint64_t, uint64_t))(v38 + 72)) == 0)
            {
              __nwlog_obj();
              uint64_t v57 = *(void *)(v25 + 48);
              if (v57)
              {
                __int16 v58 = *(const char **)(v57 + 16);
                if (!v58) {
                  __int16 v58 = "invalid";
                }
              }
              else
              {
                __int16 v58 = "invalid";
              }
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_http3_stream_encoder_stream_output_available";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v58;
              int v59 = (const char *)_os_log_send_and_compose_impl();
              v126[0] = OS_LOG_TYPE_ERROR;
              v130[0] = 0;
              if (__nwlog_fault(v59, v126, v130))
              {
                if (v126[0] != OS_LOG_TYPE_FAULT)
                {
                  if (v130[0])
                  {
                    uint64_t v64 = (char *)__nw_create_backtrace_string();
                    v65 = __nwlog_obj();
                    os_log_type_t v66 = v126[0];
                    BOOL v67 = os_log_type_enabled(v65, v126[0]);
                    if (v64)
                    {
                      if (v67)
                      {
                        uint64_t v68 = *(void *)(v25 + 48);
                        if (v68)
                        {
                          uint64_t v69 = *(const char **)(v68 + 16);
                          if (!v69) {
                            uint64_t v69 = "invalid";
                          }
                        }
                        else
                        {
                          uint64_t v69 = "invalid";
                        }
                        *(_DWORD *)buf = 136446722;
                        *(void *)&uint8_t buf[4] = "nw_http3_stream_encoder_stream_output_available";
                        *(_WORD *)&buf[12] = 2082;
                        *(void *)&buf[14] = v69;
                        *(_WORD *)&buf[22] = 2082;
                        *(void *)&unsigned char buf[24] = v64;
                        _os_log_impl(&dword_1830D4000, v65, v66, "%{public}s protocol %{public}s has invalid output_available callback, dumping backtrace:%{public}s", buf, 0x20u);
                      }
                      free(v64);
                      goto LABEL_126;
                    }
                    if (!v67) {
                      goto LABEL_126;
                    }
                    uint64_t v74 = *(void *)(v25 + 48);
                    if (v74)
                    {
                      unint64_t v75 = *(const char **)(v74 + 16);
                      if (!v75) {
                        unint64_t v75 = "invalid";
                      }
                    }
                    else
                    {
                      unint64_t v75 = "invalid";
                    }
                    *(_DWORD *)buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_http3_stream_encoder_stream_output_available";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = v75;
                    unint64_t v76 = v65;
                    os_log_type_t v77 = v66;
                    long long v78 = "%{public}s protocol %{public}s has invalid output_available callback, no backtrace";
                  }
                  else
                  {
                    unsigned int v70 = __nwlog_obj();
                    os_log_type_t v71 = v126[0];
                    if (!os_log_type_enabled(v70, v126[0])) {
                      goto LABEL_126;
                    }
                    uint64_t v72 = *(void *)(v25 + 48);
                    if (v72)
                    {
                      char v73 = *(const char **)(v72 + 16);
                      if (!v73) {
                        char v73 = "invalid";
                      }
                    }
                    else
                    {
                      char v73 = "invalid";
                    }
                    *(_DWORD *)buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_http3_stream_encoder_stream_output_available";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = v73;
                    unint64_t v76 = v70;
                    os_log_type_t v77 = v71;
                    long long v78 = "%{public}s protocol %{public}s has invalid output_available callback, backtrace limit exceeded";
                  }
LABEL_125:
                  _os_log_impl(&dword_1830D4000, v76, v77, v78, buf, 0x16u);
                  goto LABEL_126;
                }
                __int16 v60 = __nwlog_obj();
                os_log_type_t v61 = v126[0];
                if (os_log_type_enabled(v60, v126[0]))
                {
                  uint64_t v62 = *(void *)(v25 + 48);
                  if (v62)
                  {
                    unint64_t v63 = *(const char **)(v62 + 16);
                    if (!v63) {
                      unint64_t v63 = "invalid";
                    }
                  }
                  else
                  {
                    unint64_t v63 = "invalid";
                  }
                  *(_DWORD *)buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_http3_stream_encoder_stream_output_available";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v63;
                  unint64_t v76 = v60;
                  os_log_type_t v77 = v61;
                  long long v78 = "%{public}s protocol %{public}s has invalid output_available callback";
                  goto LABEL_125;
                }
              }
LABEL_126:
              if (!v59) {
                goto LABEL_56;
              }
              unint64_t v49 = (char *)v59;
LABEL_55:
              free(v49);
              goto LABEL_56;
            }
            v39(v37, v25);
          }
LABEL_56:
          int v50 = *(unsigned __int16 *)(v25 + 736);
          if ((v50 & 0x400) != 0 && !*(void *)(v25 + 528) && !*(unsigned char *)(v25 + 634) && !*(unsigned char *)(v25 + 635))
          {
            unsigned int v51 = v50 & 0xFFFFFBFF | (*(unsigned __int8 *)(v25 + 738) << 16);
            *(_WORD *)(v25 + 736) = v50 & 0xFBFF;
            *(unsigned char *)(v25 + 738) = BYTE2(v51);
            uint64_t v52 = *(void *)(v25 + 32);
            if (!v52
              || (uint64_t v53 = *(void *)(v52 + 24)) == 0
              || (__int16 v54 = *(void (**)(uint64_t, uint64_t))(v53 + 32)) == 0)
            {
              __nwlog_obj();
              uint64_t v55 = *(void *)(v25 + 32);
              if (v55)
              {
                __int16 v56 = *(const char **)(v55 + 16);
                if (!v56) {
                  __int16 v56 = "invalid";
                }
              }
              else
              {
                __int16 v56 = "invalid";
              }
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_http3_stream_encoder_stream_output_available";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v56;
              __int16 v79 = (char *)_os_log_send_and_compose_impl();
              v126[0] = OS_LOG_TYPE_ERROR;
              v130[0] = 0;
              if (!__nwlog_fault(v79, v126, v130)) {
                goto LABEL_143;
              }
              if (v126[0] == OS_LOG_TYPE_FAULT)
              {
                uint64_t v80 = __nwlog_obj();
                os_log_type_t v81 = v126[0];
                if (os_log_type_enabled(v80, v126[0]))
                {
                  uint64_t v82 = *(void *)(v25 + 32);
                  if (v82)
                  {
                    long long v83 = *(const char **)(v82 + 16);
                    if (!v83) {
                      long long v83 = "invalid";
                    }
                  }
                  else
                  {
                    long long v83 = "invalid";
                  }
                  *(_DWORD *)buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_http3_stream_encoder_stream_output_available";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v83;
                  int v96 = v80;
                  os_log_type_t v97 = v81;
                  char v98 = "%{public}s protocol %{public}s has invalid disconnect callback";
                  goto LABEL_142;
                }
                goto LABEL_143;
              }
              if (v130[0])
              {
                long long v84 = (char *)__nw_create_backtrace_string();
                long long v85 = __nwlog_obj();
                os_log_type_t v86 = v126[0];
                BOOL v87 = os_log_type_enabled(v85, v126[0]);
                if (v84)
                {
                  if (v87)
                  {
                    uint64_t v88 = *(void *)(v25 + 32);
                    if (v88)
                    {
                      char v89 = *(const char **)(v88 + 16);
                      if (!v89) {
                        char v89 = "invalid";
                      }
                    }
                    else
                    {
                      char v89 = "invalid";
                    }
                    *(_DWORD *)buf = 136446722;
                    *(void *)&uint8_t buf[4] = "nw_http3_stream_encoder_stream_output_available";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = v89;
                    *(_WORD *)&buf[22] = 2082;
                    *(void *)&unsigned char buf[24] = v84;
                    _os_log_impl(&dword_1830D4000, v85, v86, "%{public}s protocol %{public}s has invalid disconnect callback, dumping backtrace:%{public}s", buf, 0x20u);
                  }
                  free(v84);
                  goto LABEL_143;
                }
                if (!v87)
                {
LABEL_143:
                  if (v79) {
                    free(v79);
                  }
                  goto LABEL_30;
                }
                uint64_t v94 = *(void *)(v25 + 32);
                if (v94)
                {
                  uint64_t v95 = *(const char **)(v94 + 16);
                  if (!v95) {
                    uint64_t v95 = "invalid";
                  }
                }
                else
                {
                  uint64_t v95 = "invalid";
                }
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_http3_stream_encoder_stream_output_available";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v95;
                int v96 = v85;
                os_log_type_t v97 = v86;
                char v98 = "%{public}s protocol %{public}s has invalid disconnect callback, no backtrace";
              }
              else
              {
                v90 = __nwlog_obj();
                os_log_type_t v91 = v126[0];
                if (!os_log_type_enabled(v90, v126[0])) {
                  goto LABEL_143;
                }
                uint64_t v92 = *(void *)(v25 + 32);
                if (v92)
                {
                  unsigned int v93 = *(const char **)(v92 + 16);
                  if (!v93) {
                    unsigned int v93 = "invalid";
                  }
                }
                else
                {
                  unsigned int v93 = "invalid";
                }
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_http3_stream_encoder_stream_output_available";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v93;
                int v96 = v90;
                os_log_type_t v97 = v91;
                char v98 = "%{public}s protocol %{public}s has invalid disconnect callback, backtrace limit exceeded";
              }
LABEL_142:
              _os_log_impl(&dword_1830D4000, v96, v97, v98, buf, 0x16u);
              goto LABEL_143;
            }
            v54(v52, v25);
          }
LABEL_30:
          BOOL v26 = v25 == *(void *)(a1 + 928);
          uint64_t v25 = *(void *)(a1 + 928);
          if (v26) {
            return;
          }
        }
        if (v27) {
          goto LABEL_56;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v28 = *(_DWORD *)(v25 + 368);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_encoder_stream_output_available";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v28;
        int v29 = (const char *)_os_log_send_and_compose_impl();
        v126[0] = OS_LOG_TYPE_ERROR;
        v130[0] = 0;
        if (__nwlog_fault(v29, v126, v130))
        {
          if (v126[0] == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v30 = gLogObj;
            os_log_type_t v31 = v126[0];
            if (!os_log_type_enabled((os_log_t)gLogObj, v126[0])) {
              goto LABEL_53;
            }
            int v32 = *(_DWORD *)(v25 + 368);
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_encoder_stream_output_available";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v32;
            int v33 = v30;
            os_log_type_t v34 = v31;
            __int16 v35 = "%{public}s Unexpected output state %d";
LABEL_52:
            _os_log_impl(&dword_1830D4000, v33, v34, v35, buf, 0x12u);
            goto LABEL_53;
          }
          if (!v130[0])
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v45 = gLogObj;
            os_log_type_t v46 = v126[0];
            if (!os_log_type_enabled((os_log_t)gLogObj, v126[0])) {
              goto LABEL_53;
            }
            int v47 = *(_DWORD *)(v25 + 368);
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_encoder_stream_output_available";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v47;
            int v33 = v45;
            os_log_type_t v34 = v46;
            __int16 v35 = "%{public}s Unexpected output state %d, backtrace limit exceeded";
            goto LABEL_52;
          }
          int v40 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v41 = gLogObj;
          os_log_type_t v42 = v126[0];
          BOOL v43 = os_log_type_enabled((os_log_t)gLogObj, v126[0]);
          if (!v40)
          {
            if (!v43) {
              goto LABEL_53;
            }
            int v48 = *(_DWORD *)(v25 + 368);
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_encoder_stream_output_available";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v48;
            int v33 = v41;
            os_log_type_t v34 = v42;
            __int16 v35 = "%{public}s Unexpected output state %d, no backtrace";
            goto LABEL_52;
          }
          if (v43)
          {
            int v44 = *(_DWORD *)(v25 + 368);
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_encoder_stream_output_available";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v44;
            *(_WORD *)&buf[18] = 2082;
            *(void *)&buf[20] = v40;
            _os_log_impl(&dword_1830D4000, v41, v42, "%{public}s Unexpected output state %d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }
          free(v40);
        }
LABEL_53:
        if (v29)
        {
          unint64_t v49 = (char *)v29;
          goto LABEL_55;
        }
        goto LABEL_56;
      }
    }
    __nwlog_obj();
    v107 = *(const char **)(v5 + 16);
    if (!v107) {
      v107 = "invalid";
    }
    *(_DWORD *)v130 = 136446466;
    uint64_t v131 = "nw_http3_encoder_stream_process_output";
    __int16 v132 = 2082;
    v133 = (void *)v107;
    v108 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v118 = 0;
    if (__nwlog_fault(v108, &type, &v118))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v109 = __nwlog_obj();
        os_log_type_t v110 = type;
        if (!os_log_type_enabled(v109, type)) {
          goto LABEL_192;
        }
        int v111 = *(const char **)(v5 + 16);
        if (!v111) {
          int v111 = "invalid";
        }
        *(_DWORD *)v130 = 136446466;
        uint64_t v131 = "nw_http3_encoder_stream_process_output";
        __int16 v132 = 2082;
        v133 = (void *)v111;
        unsigned int v112 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback";
        goto LABEL_191;
      }
      if (!v118)
      {
        int v109 = __nwlog_obj();
        os_log_type_t v110 = type;
        if (!os_log_type_enabled(v109, type)) {
          goto LABEL_192;
        }
        int v116 = *(const char **)(v5 + 16);
        if (!v116) {
          int v116 = "invalid";
        }
        *(_DWORD *)v130 = 136446466;
        uint64_t v131 = "nw_http3_encoder_stream_process_output";
        __int16 v132 = 2082;
        v133 = (void *)v116;
        unsigned int v112 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback, backtrace limit exceeded";
        goto LABEL_191;
      }
      unsigned int v113 = (char *)__nw_create_backtrace_string();
      int v109 = __nwlog_obj();
      os_log_type_t v110 = type;
      BOOL v114 = os_log_type_enabled(v109, type);
      if (v113)
      {
        if (v114)
        {
          v115 = *(const char **)(v5 + 16);
          if (!v115) {
            v115 = "invalid";
          }
          *(_DWORD *)v130 = 136446722;
          uint64_t v131 = "nw_http3_encoder_stream_process_output";
          __int16 v132 = 2082;
          v133 = (void *)v115;
          __int16 v134 = 2082;
          v135 = v113;
          _os_log_impl(&dword_1830D4000, v109, v110, "%{public}s protocol %{public}s has invalid finalize_output_frames callback, dumping backtrace:%{public}s", v130, 0x20u);
        }
        free(v113);
        goto LABEL_192;
      }
      if (v114)
      {
        unsigned int v117 = *(const char **)(v5 + 16);
        if (!v117) {
          unsigned int v117 = "invalid";
        }
        *(_DWORD *)v130 = 136446466;
        uint64_t v131 = "nw_http3_encoder_stream_process_output";
        __int16 v132 = 2082;
        v133 = (void *)v117;
        unsigned int v112 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback, no backtrace";
LABEL_191:
        _os_log_impl(&dword_1830D4000, v109, v110, v112, v130, 0x16u);
      }
    }
LABEL_192:
    if (v108) {
      free(v108);
    }
    goto LABEL_27;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_http3_encoder_stream_process_output";
  unint64_t v15 = (char *)_os_log_send_and_compose_impl();
  v126[0] = OS_LOG_TYPE_ERROR;
  v130[0] = 0;
  if (__nwlog_fault(v15, v126, v130))
  {
    if (v126[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v16 = gLogObj;
      os_log_type_t v17 = v126[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, v126[0])) {
        goto LABEL_154;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http3_encoder_stream_process_output";
      int v18 = "%{public}s Attempting to send on encoder stream before initial sdtc";
LABEL_152:
      v103 = v16;
      os_log_type_t v104 = v17;
LABEL_153:
      _os_log_impl(&dword_1830D4000, v103, v104, v18, buf, 0xCu);
      goto LABEL_154;
    }
    if (!v130[0])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v16 = gLogObj;
      os_log_type_t v17 = v126[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, v126[0])) {
        goto LABEL_154;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http3_encoder_stream_process_output";
      int v18 = "%{public}s Attempting to send on encoder stream before initial sdtc, backtrace limit exceeded";
      goto LABEL_152;
    }
    unint64_t v19 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v20 = gLogObj;
    os_log_type_t v21 = v126[0];
    BOOL v22 = os_log_type_enabled((os_log_t)gLogObj, v126[0]);
    if (v19)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http3_encoder_stream_process_output";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v19;
        _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s Attempting to send on encoder stream before initial sdtc, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v19);
      goto LABEL_154;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http3_encoder_stream_process_output";
      int v18 = "%{public}s Attempting to send on encoder stream before initial sdtc, no backtrace";
      v103 = v20;
      os_log_type_t v104 = v21;
      goto LABEL_153;
    }
  }
LABEL_154:
  if (v15) {
    free(v15);
  }
}

BOOL ___ZL38nw_http3_encoder_stream_process_outputP17nw_protocol_http3_block_invoke(void *a1, uint64_t a2)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if ((nw_frame_uses_external_data(a2) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    int v32 = "nw_http3_encoder_stream_process_output_block_invoke";
    int v7 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(offset) = 16;
    os_log_type_t offset_7 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v7, &offset, &offset_7))
    {
      if (offset == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v8 = gLogObj;
        os_log_type_t v9 = offset;
        if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)offset))
        {
          *(_DWORD *)buf = 136446210;
          int v32 = "nw_http3_encoder_stream_process_output_block_invoke";
          char v10 = "%{public}s Encoder stream does not support external data";
LABEL_24:
          unint64_t v19 = v8;
          os_log_type_t v20 = v9;
LABEL_25:
          _os_log_impl(&dword_1830D4000, v19, v20, v10, buf, 0xCu);
        }
      }
      else if (offset_7)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v16 = gLogObj;
        os_log_type_t v17 = offset;
        BOOL v18 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)offset);
        if (backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)buf = 136446466;
            int v32 = "nw_http3_encoder_stream_process_output_block_invoke";
            __int16 v33 = 2082;
            os_log_type_t v34 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s Encoder stream does not support external data, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_26;
        }
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          int v32 = "nw_http3_encoder_stream_process_output_block_invoke";
          char v10 = "%{public}s Encoder stream does not support external data, no backtrace";
          unint64_t v19 = v16;
          os_log_type_t v20 = v17;
          goto LABEL_25;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v8 = gLogObj;
        os_log_type_t v9 = offset;
        if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)offset))
        {
          *(_DWORD *)buf = 136446210;
          int v32 = "nw_http3_encoder_stream_process_output_block_invoke";
          char v10 = "%{public}s Encoder stream does not support external data, backtrace limit exceeded";
          goto LABEL_24;
        }
      }
    }
LABEL_26:
    if (v7) {
      free(v7);
    }
    return 0;
  }
  unsigned int offset = 0;
  nw_frame_set_external_data(a2, *(dispatch_data_t *)(a1[6] + 1200), &offset);
  unsigned int v4 = *(_DWORD *)(*(void *)(a1[4] + 8) + 24);
  uint64_t v5 = *(NSObject **)(a1[6] + 1200);
  BOOL v6 = offset < v4;
  if (offset < v4)
  {
    *(void *)(a1[6] + 1200) = dispatch_data_create_subrange(*(dispatch_data_t *)(a1[6] + 1200), offset, 0xFFFFFFFFFFFFFFFFLL);
    if (v5) {
      dispatch_release(v5);
    }
    *(_DWORD *)(*(void *)(a1[4] + 8) + 24) -= offset;
    return v6;
  }
  if (v5)
  {
    dispatch_release(*(dispatch_object_t *)(a1[6] + 1200));
    *(void *)(a1[6] + 1200) = 0;
  }
  if (**(void **)(*(void *)(*(void *)(a1[5] + 8) + 48) + 8) != a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    int v32 = "nw_http3_encoder_stream_process_output_block_invoke";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t offset_7 = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (!__nwlog_fault(v11, &offset_7, &v28)) {
      goto LABEL_41;
    }
    if (offset_7 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v12 = gLogObj;
      os_log_type_t v13 = offset_7;
      if (!os_log_type_enabled((os_log_t)gLogObj, offset_7)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      int v32 = "nw_http3_encoder_stream_process_output_block_invoke";
      os_log_type_t v14 = "%{public}s Too much space for sdtc";
    }
    else
    {
      if (v28)
      {
        BOOL v22 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v23 = gLogObj;
        os_log_type_t v24 = offset_7;
        BOOL v25 = os_log_type_enabled((os_log_t)gLogObj, offset_7);
        if (v22)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            int v32 = "nw_http3_encoder_stream_process_output_block_invoke";
            __int16 v33 = 2082;
            os_log_type_t v34 = v22;
            _os_log_impl(&dword_1830D4000, v23, v24, "%{public}s Too much space for sdtc, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v22);
          goto LABEL_41;
        }
        if (!v25)
        {
LABEL_41:
          if (v11) {
            free(v11);
          }
          return v6;
        }
        *(_DWORD *)buf = 136446210;
        int v32 = "nw_http3_encoder_stream_process_output_block_invoke";
        os_log_type_t v14 = "%{public}s Too much space for sdtc, no backtrace";
        BOOL v26 = v23;
        os_log_type_t v27 = v24;
LABEL_40:
        _os_log_impl(&dword_1830D4000, v26, v27, v14, buf, 0xCu);
        goto LABEL_41;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v12 = gLogObj;
      os_log_type_t v13 = offset_7;
      if (!os_log_type_enabled((os_log_t)gLogObj, offset_7)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      int v32 = "nw_http3_encoder_stream_process_output_block_invoke";
      os_log_type_t v14 = "%{public}s Too much space for sdtc, backtrace limit exceeded";
    }
    BOOL v26 = v12;
    os_log_type_t v27 = v13;
    goto LABEL_40;
  }
  return v6;
}

BOOL nw_http3_stream_send_fields(uint64_t a1, int a2)
{
  uint64_t v426 = *MEMORY[0x1E4F143B8];
  unsigned int v3 = *(unsigned __int16 *)(a1 + 736) | (*(unsigned __int8 *)(a1 + 738) << 16);
  int v4 = (v3 >> 11) & 1;
  if (!gLogDatapath) {
    LOBYTE(v4) = 1;
  }
  if ((v3 & 0x40000) == 0)
  {
    if ((v4 & 1) == 0)
    {
      v180 = __nwlog_obj();
      if (os_log_type_enabled(v180, OS_LOG_TYPE_DEBUG))
      {
        int v181 = *(_DWORD *)(*(void *)(a1 + 336) + 1280);
        v182 = *(void **)(a1 + 240);
        int v183 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)buf = 136447490;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = a1 + 636;
        *(_WORD *)&buf[22] = 2080;
        v415 = (__n128 (*)(uint64_t, uint64_t))" ";
        LOWORD(v416) = 1024;
        *(_DWORD *)((char *)&v416 + 2) = v181;
        HIWORD(v416) = 2048;
        v417 = v182;
        *(_WORD *)v418 = 1024;
        *(_DWORD *)&v418[2] = v183;
        _os_log_impl(&dword_1830D4000, v180, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called, state %u", buf, 0x36u);
      }
    }
    BOOL v6 = (_WORD *)(a1 + 736);
    if (*(void *)(a1 + 520)) {
      goto LABEL_6;
    }
    if (nw_protocol_copy_http_definition_onceToken != -1) {
      dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_15_74223);
    }
    id v17 = (id)nw_protocol_copy_http_definition_http_definition;
    BOOL v18 = nw_frame_copy_metadata_for_protocol(*(void *)(a1 + 384), (uint64_t)v17);
    unint64_t v19 = v18;
    if (!v18) {
      goto LABEL_194;
    }
    if ((*(_WORD *)(*(void *)(a1 + 336) + 1373) & 1) == 0)
    {
      id v20 = nw_http_metadata_copy_request(v18);
      if (!v20)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
        os_log_type_t v21 = (char *)_os_log_send_and_compose_impl();
        type[0] = 16;
        LOBYTE(v401) = 0;
        if (!__nwlog_fault(v21, type, &v401)) {
          goto LABEL_187;
        }
        if (type[0] == 17)
        {
          BOOL v22 = __nwlog_obj();
          os_log_type_t v23 = type[0];
          if (!os_log_type_enabled(v22, (os_log_type_t)type[0])) {
            goto LABEL_187;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
          os_log_type_t v24 = "%{public}s did not find request on frame";
        }
        else if ((_BYTE)v401)
        {
          id v359 = v17;
          backtrace_string = (char *)__nw_create_backtrace_string();
          BOOL v22 = __nwlog_obj();
          os_log_type_t v23 = type[0];
          BOOL v85 = os_log_type_enabled(v22, (os_log_type_t)type[0]);
          if (backtrace_string)
          {
            if (v85)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = backtrace_string;
              _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s did not find request on frame, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(backtrace_string);
            id v17 = v359;
LABEL_187:
            if (v21) {
              goto LABEL_193;
            }
            goto LABEL_194;
          }
          id v17 = v359;
          if (!v85) {
            goto LABEL_187;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
          os_log_type_t v24 = "%{public}s did not find request on frame, no backtrace";
        }
        else
        {
          BOOL v22 = __nwlog_obj();
          os_log_type_t v23 = type[0];
          if (!os_log_type_enabled(v22, (os_log_type_t)type[0])) {
            goto LABEL_187;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
          os_log_type_t v24 = "%{public}s did not find request on frame, backtrace limit exceeded";
        }
        _os_log_impl(&dword_1830D4000, v22, v23, v24, buf, 0xCu);
        goto LABEL_187;
      }
LABEL_40:
      os_release(v20);
      nw_http_transaction_metadata_set_outbound_message(*(void **)(a1 + 392), v19);
      nw::http::content_length_manager::set_outbound_message((nw::http::content_length_manager *)(a1 + 272), (nw_protocol_metadata *)v19);
      if ((*(_WORD *)(*(void *)(a1 + 336) + 1373) & 1) == 0)
      {
        id v36 = nw_http_metadata_copy_request(v19);
        if (!v36)
        {
          if ((*v6 & 0x800) == 0)
          {
            uint64_t v37 = __nwlog_obj();
            if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
            {
              int v38 = *(_DWORD *)(*(void *)(a1 + 336) + 1280);
              __int16 v39 = *(void **)(a1 + 240);
              uint64_t v40 = *(void *)(a1 + 384);
              *(_DWORD *)buf = 136447490;
              *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = a1 + 636;
              *(_WORD *)&buf[22] = 2080;
              v415 = (__n128 (*)(uint64_t, uint64_t))" ";
              LOWORD(v416) = 1024;
              *(_DWORD *)((char *)&v416 + 2) = v38;
              HIWORD(v416) = 2048;
              v417 = v39;
              *(_WORD *)v418 = 2048;
              *(void *)&v418[2] = v40;
              _os_log_impl(&dword_1830D4000, v37, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%llu> No request found in frame %p", buf, 0x3Au);
            }
          }
          uint64_t v41 = *(void *)(a1 + 48);
          if (v41)
          {
            uint64_t v42 = *(void *)(v41 + 24);
            if (v42)
            {
              BOOL v43 = *(void (**)(void))(v42 + 56);
              if (v43)
              {
                v43();
                uint64_t v44 = *(void *)(a1 + 48);
                if (!v44) {
                  goto LABEL_51;
                }
LABEL_49:
                uint64_t v45 = *(void *)(v44 + 24);
                if (!v45) {
                  goto LABEL_51;
                }
                os_log_type_t v46 = *(void (**)(uint64_t, uint64_t))(v45 + 48);
                if (!v46) {
                  goto LABEL_51;
                }
LABEL_91:
                v46(v44, a1);
                int v81 = 1;
                goto LABEL_305;
              }
            }
          }
          id v360 = v17;
          __nwlog_obj();
          uint64_t v231 = *(void *)(a1 + 48);
          v232 = "invalid";
          if (v231)
          {
            v233 = *(const char **)(v231 + 16);
            if (v233) {
              v232 = v233;
            }
          }
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v232;
          v234 = (char *)_os_log_send_and_compose_impl();
          type[0] = 16;
          LOBYTE(v401) = 0;
          if (__nwlog_fault(v234, type, &v401))
          {
            if (type[0] == 17)
            {
              v235 = __nwlog_obj();
              os_log_type_t v236 = type[0];
              if (!os_log_type_enabled(v235, (os_log_type_t)type[0])) {
                goto LABEL_560;
              }
              uint64_t v237 = *(void *)(a1 + 48);
              v238 = "invalid";
              if (v237)
              {
                v239 = *(const char **)(v237 + 16);
                if (v239) {
                  v238 = v239;
                }
              }
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v238;
              v240 = "%{public}s protocol %{public}s has invalid error callback";
LABEL_559:
              _os_log_impl(&dword_1830D4000, v235, v236, v240, buf, 0x16u);
              goto LABEL_560;
            }
            if (!(_BYTE)v401)
            {
              v235 = __nwlog_obj();
              os_log_type_t v236 = type[0];
              if (!os_log_type_enabled(v235, (os_log_type_t)type[0])) {
                goto LABEL_560;
              }
              uint64_t v311 = *(void *)(a1 + 48);
              v312 = "invalid";
              if (v311)
              {
                v313 = *(const char **)(v311 + 16);
                if (v313) {
                  v312 = v313;
                }
              }
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v312;
              v240 = "%{public}s protocol %{public}s has invalid error callback, backtrace limit exceeded";
              goto LABEL_559;
            }
            v290 = (char *)__nw_create_backtrace_string();
            v235 = __nwlog_obj();
            os_log_type_t v236 = type[0];
            BOOL v291 = os_log_type_enabled(v235, (os_log_type_t)type[0]);
            if (!v290)
            {
              if (!v291) {
                goto LABEL_560;
              }
              uint64_t v331 = *(void *)(a1 + 48);
              v332 = "invalid";
              if (v331)
              {
                v333 = *(const char **)(v331 + 16);
                if (v333) {
                  v332 = v333;
                }
              }
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v332;
              v240 = "%{public}s protocol %{public}s has invalid error callback, no backtrace";
              goto LABEL_559;
            }
            if (v291)
            {
              uint64_t v292 = *(void *)(a1 + 48);
              v293 = "invalid";
              if (v292)
              {
                v294 = *(const char **)(v292 + 16);
                if (v294) {
                  v293 = v294;
                }
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v293;
              *(_WORD *)&buf[22] = 2082;
              v415 = (__n128 (*)(uint64_t, uint64_t))v290;
              _os_log_impl(&dword_1830D4000, v235, v236, "%{public}s protocol %{public}s has invalid error callback, dumping backtrace:%{public}s", buf, 0x20u);
            }
            free(v290);
          }
LABEL_560:
          if (v234) {
            free(v234);
          }
          id v17 = v360;
          uint64_t v44 = *(void *)(a1 + 48);
          if (!v44)
          {
LABEL_51:
            id v357 = v17;
            __nwlog_obj();
            uint64_t v47 = *(void *)(a1 + 48);
            int v48 = "invalid";
            if (v47)
            {
              unint64_t v49 = *(const char **)(v47 + 16);
              if (v49) {
                int v48 = v49;
              }
            }
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v48;
            int v50 = (char *)_os_log_send_and_compose_impl();
            type[0] = 16;
            LOBYTE(v401) = 0;
            if (__nwlog_fault(v50, type, &v401))
            {
              if (type[0] == 17)
              {
                unsigned int v51 = __nwlog_obj();
                os_log_type_t v52 = type[0];
                if (!os_log_type_enabled(v51, (os_log_type_t)type[0])) {
                  goto LABEL_603;
                }
                uint64_t v53 = *(void *)(a1 + 48);
                __int16 v54 = "invalid";
                if (v53)
                {
                  uint64_t v55 = *(const char **)(v53 + 16);
                  if (v55) {
                    __int16 v54 = v55;
                  }
                }
LABEL_60:
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v54;
                __int16 v56 = "%{public}s protocol %{public}s has invalid disconnected callback";
LABEL_602:
                _os_log_impl(&dword_1830D4000, v51, v52, v56, buf, 0x16u);
                goto LABEL_603;
              }
              if ((_BYTE)v401)
              {
                v285 = (char *)__nw_create_backtrace_string();
                unsigned int v51 = __nwlog_obj();
                os_log_type_t v52 = type[0];
                BOOL v286 = os_log_type_enabled(v51, (os_log_type_t)type[0]);
                if (v285)
                {
                  if (v286)
                  {
                    uint64_t v287 = *(void *)(a1 + 48);
                    v288 = "invalid";
                    if (v287)
                    {
                      v289 = *(const char **)(v287 + 16);
                      if (v289) {
                        v288 = v289;
                      }
                    }
                    *(_DWORD *)buf = 136446722;
                    *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = v288;
                    *(_WORD *)&buf[22] = 2082;
                    v415 = (__n128 (*)(uint64_t, uint64_t))v285;
                    _os_log_impl(&dword_1830D4000, v51, v52, "%{public}s protocol %{public}s has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x20u);
                  }
                  free(v285);
                  goto LABEL_603;
                }
                if (!v286) {
                  goto LABEL_603;
                }
                uint64_t v328 = *(void *)(a1 + 48);
                v329 = "invalid";
                if (v328)
                {
                  v330 = *(const char **)(v328 + 16);
                  if (v330) {
                    v329 = v330;
                  }
                }
LABEL_601:
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v329;
                __int16 v56 = "%{public}s protocol %{public}s has invalid disconnected callback, no backtrace";
                goto LABEL_602;
              }
              unsigned int v51 = __nwlog_obj();
              os_log_type_t v52 = type[0];
              if (!os_log_type_enabled(v51, (os_log_type_t)type[0])) {
                goto LABEL_603;
              }
              uint64_t v308 = *(void *)(a1 + 48);
              v309 = "invalid";
              if (v308)
              {
                v310 = *(const char **)(v308 + 16);
                if (v310) {
                  v309 = v310;
                }
              }
LABEL_501:
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v309;
              __int16 v56 = "%{public}s protocol %{public}s has invalid disconnected callback, backtrace limit exceeded";
              goto LABEL_602;
            }
            goto LABEL_603;
          }
          goto LABEL_49;
        }
        goto LABEL_64;
      }
      id v57 = nw_http_metadata_copy_response(v19);
      if (v57)
      {
        id v58 = v57;
        int status_code = _nw_http_response_get_status_code();

        int v60 = (unsigned __int16)*v6;
        unsigned int v61 = (v60 | (*(unsigned __int8 *)(a1 + 738) << 16)) & 0xFFFEFFFF;
        *BOOL v6 = v60;
        *(unsigned char *)(a1 + 738) = (v61 | (((status_code - 100) < 0x64) << 16)) >> 16;
        uint64_t v62 = *(void **)(a1 + 400);
        if (v62)
        {
          id v36 = nw_http_metadata_copy_request(v62);
          os_release(v58);
          if (v36)
          {
LABEL_64:
            id v63 = v36;
            int has_method = _nw_http_request_has_method((uint64_t)v63);

            id v358 = v17;
            if (has_method)
            {
              if (!nw_http_fields_have_field_with_name(v63, (unint64_t)"Datagram-Flow-Id"))
              {
                nw_protocol_http3_stream_start_datagram_flow(a1);
                *(void *)buf = 0;
                *(void *)&buf[8] = 0;
                snprintf(buf, 0x10uLL, "%llu", *(void *)(a1 + 248));
                nw_http_fields_append(v63, (uint64_t)"Datagram-Flow-Id", (uint64_t)buf);
              }
              *v6 |= 0x8000u;
            }
            else if (nw_http_request_has_method(v63, (uint64_t)"CONNECT"))
            {
              v375[0] = MEMORY[0x1E4F143A8];
              v375[1] = 0x40000000;
              v375[2] = ___ZL27nw_http3_stream_send_fieldsP24nw_protocol_http3_streamb_block_invoke;
              v375[3] = &__block_descriptor_tmp_106_62048;
              v375[4] = a1;
              nw_http_fields_access_value_by_name(v63, (unint64_t)"Capsule-Protocol", v375);
              *(void *)buf = 0;
              *(void *)&buf[8] = buf;
              *(void *)&buf[16] = 0x2000000000;
              LOBYTE(v415) = 0;
              v374[0] = MEMORY[0x1E4F143A8];
              v374[1] = 0x40000000;
              v374[2] = ___ZL27nw_http3_stream_send_fieldsP24nw_protocol_http3_streamb_block_invoke_2;
              v374[3] = &unk_1E52475B8;
              v374[4] = buf;
              nw_http_request_access_extended_connect_protocol(v63, v374);
              if (*(unsigned char *)(*(void *)&buf[8] + 24))
              {
                *(void *)(a1 + 256) = nw_http_metadata_get_datagram_context_id(v19);
                nw_protocol_http3_stream_start_datagram_flow(a1);
              }
              *v6 |= 0x8000u;
              _Block_object_dispose(buf, 8);
            }
LABEL_111:
            uint64_t v89 = *(void *)(a1 + 336);
            if (v89)
            {
              if ((*v6 & 0x800) == 0)
              {
                if (gLogDatapath)
                {
                  v227 = __nwlog_obj();
                  BOOL v228 = os_log_type_enabled(v227, OS_LOG_TYPE_DEBUG);
                  uint64_t v89 = *(void *)(a1 + 336);
                  if (v228)
                  {
                    int v229 = *(_DWORD *)(v89 + 1280);
                    v230 = *(void **)(a1 + 240);
                    *(_DWORD *)buf = 136447234;
                    *(void *)&uint8_t buf[4] = "nw_http3_stream_serialize_fields";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = a1 + 636;
                    *(_WORD *)&buf[22] = 2080;
                    v415 = (__n128 (*)(uint64_t, uint64_t))" ";
                    LOWORD(v416) = 1024;
                    *(_DWORD *)((char *)&v416 + 2) = v229;
                    HIWORD(v416) = 2048;
                    v417 = v230;
                    _os_log_impl(&dword_1830D4000, v227, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called", buf, 0x30u);
                    uint64_t v89 = *(void *)(a1 + 336);
                  }
                }
              }
              *(void *)os_log_type_t type = 0;
              *(void *)&os_log_type_t type[8] = type;
              *(void *)&type[16] = 0x2000000000;
              v406 = 0;
              uint64_t v401 = 0;
              v402 = &v401;
              uint64_t v403 = 0x2000000000;
              uint64_t v404 = 0;
              *(void *)v397 = 0;
              v398 = v397;
              uint64_t v399 = 0x2000000000;
              uint64_t v400 = 0;
              v396[0] = 0;
              v396[1] = v396;
              v396[2] = 0x2000000000;
              v396[3] = 0;
              uint64_t v392 = 0;
              v393 = &v392;
              uint64_t v394 = 0x2000000000;
              uint64_t v395 = 22;
              uint64_t v388 = 0;
              v389 = &v388;
              uint64_t v390 = 0x2000000000;
              uint64_t v391 = 0;
              v387[0] = 0;
              v387[1] = v387;
              v387[2] = 0x2000000000;
              v387[3] = 512;
              v386[0] = 0;
              v386[1] = v386;
              v386[2] = 0x2000000000;
              v386[3] = 512;
              uint64_t v382 = 0;
              v383 = &v382;
              uint64_t v384 = 0x2000000000;
              uint64_t alloc = 0;
              uint64_t alloc = dispatch_data_create_alloc();
              uint64_t v378 = 0;
              v379 = &v378;
              uint64_t v380 = 0x2000000000;
              uint64_t v381 = 0;
              uint64_t v381 = dispatch_data_create_alloc();
              int v90 = *(_DWORD *)(a1 + 624);
              if ((*(unsigned char *)(v89 + 268) & 1) == 0)
              {
                id v356 = v63;
                uint64_t v91 = *(void *)(*(void *)&type[8] + 24);
                uint64_t v92 = *(void *)(a1 + 240);
                unsigned int v93 = *(FILE **)(v89 + 456);
                if (v93)
                {
                  fwrite("qenc: debug: ", 0xDuLL, 1uLL, v93);
                  fprintf(*(FILE **)(v89 + 456), "Start header for stream %llu", v92);
                  fputc(10, *(FILE **)(v89 + 456));
                }
                uint64_t v94 = (void *)(v89 + 336);
                while (1)
                {
                  uint64_t v94 = (void *)*v94;
                  if (!v94) {
                    break;
                  }
                  uint64_t v95 = v94[1];
                  if (v95 != -1) {
                    goto LABEL_129;
                  }
                }
                if ((*(unsigned char *)(v89 + 268) & 4) != 0
                  || 4112 * (unint64_t)*(unsigned int *)(v89 + 300) < *(unsigned int *)(v89 + 276))
                {
                  uint64_t v94 = malloc_type_malloc(0x1010uLL, 0x10A0040497EC00CuLL);
                  if (v94)
                  {
                    uint64_t v95 = 0;
                    *uint64_t v94 = 0;
                    v94[1] = 0;
                    **(void **)(v89 + 344) = v94;
                    *(void *)(v89 + 344) = v94;
                    ++*(_DWORD *)(v89 + 300);
LABEL_129:
                    unint64_t v100 = __clz(__rbit64(~v95));
                    v94[1] = (1 << v100) | v95;
                    os_log_type_t v101 = &v94[8 * v100];
                    v101[2] = 0;
                    v101 += 2;
                    *(_OWORD *)(v101 + 3) = 0u;
                    *(_OWORD *)(v101 + 5) = 0u;
                    v101[7] = 0;
                    *(_OWORD *)(v101 + 1) = 0u;
                    v101[4] = v101;
                    BOOL v102 = *(void **)(v89 + 360);
                    v101[1] = v102;
                    *BOOL v102 = v101;
                    *(void *)(v89 + 360) = v101;
                    v103 = (void *)(v89 + 384);
                    *(void *)(v89 + 384) = v101;
                    v101[5] = v92;
                    *((_DWORD *)v101 + 12) = v90;
                    goto LABEL_130;
                  }
                }
                v103 = (void *)(v89 + 384);
                *(void *)(v89 + 384) = 0;
                int v109 = *(FILE **)(v89 + 456);
                if (v109)
                {
                  fwrite("qenc: info: ", 0xCuLL, 1uLL, v109);
                  fprintf(*(FILE **)(v89 + 456), "could not allocate hinfo for stream %llu", v92);
                  fputc(10, *(FILE **)(v89 + 456));
                }
LABEL_130:
                *(_DWORD *)(v89 + 408) = 0;
                *(void *)(v89 + 392) = 0;
                *(_DWORD *)(v89 + 400) = 0;
                *(_DWORD *)(v89 + 412) = *(_DWORD *)(v89 + 256);
                if (v90)
                {
                  if (*v103)
                  {
                    uint64_t v104 = *(void *)(v89 + 368);
                    if (v104)
                    {
                      while (*(void *)(v104 + 40) != v92)
                      {
                        uint64_t v104 = *(void *)(v104 + 16);
                        if (!v104) {
                          goto LABEL_158;
                        }
                      }
                      *(void *)(v89 + 392) = v104;
                    }
                  }
                }
LABEL_158:
                *(_DWORD *)(v89 + 268) |= 1u;
                ++*(_DWORD *)(a1 + 624);
                *(void *)buf = MEMORY[0x1E4F143A8];
                *(void *)&buf[8] = 0x40000000;
                *(void *)&buf[16] = ___ZL32nw_http3_stream_serialize_fieldsP24nw_protocol_http3_streamP20nw_protocol_metadata_block_invoke;
                v415 = (__n128 (*)(uint64_t, uint64_t))&unk_1E5247630;
                v416 = v397;
                v417 = v387;
                *(void *)v418 = &v392;
                *(void *)&v418[8] = v396;
                *(void *)&v418[16] = v386;
                v419 = &v388;
                uint64_t v424 = a1;
                uint64_t v425 = v89 + 256;
                v420 = &v401;
                v421 = type;
                v422 = &v378;
                v423 = &v382;
                nw_http_metadata_enumerate_modern_header_fields_combined(v19, buf);
                size_t v114 = lsqpack_enc_end_header(v89 + 256, (uint64_t)__src);
                if ((v114 & 0x8000000000000000) == 0)
                {
                  size_t v115 = v114;
                  memcpy((void *)(v91 - v114 + 22), __src, v114);
                  *(void *)(a1 + 520) = dispatch_data_create_subrange((dispatch_data_t)v383[3], 22 - v115, v115 + v393[3] - 22);
                  int v116 = v383[3];
                  if (v116)
                  {
                    dispatch_release(v116);
                    v383[3] = 0;
                  }
                  size_t v117 = v389[3];
                  id v17 = v358;
                  id v63 = v356;
                  if (v117) {
                    dispatch_data_t subrange = dispatch_data_create_subrange((dispatch_data_t)v379[3], 0, v117);
                  }
                  else {
                    dispatch_data_t subrange = 0;
                  }
                  *(void *)(a1 + 528) = subrange;
                  int v119 = v379[3];
                  if (v119)
                  {
                    dispatch_release(v119);
                    v379[3] = 0;
                  }
                  goto LABEL_302;
                }
                __nwlog_obj();
                *(_DWORD *)v409 = 136446210;
                v410 = "nw_http3_stream_serialize_fields";
                int v96 = (char *)_os_log_send_and_compose_impl();
                os_log_type_t v377 = OS_LOG_TYPE_ERROR;
                char v376 = 0;
                id v63 = v356;
                if (!__nwlog_fault(v96, &v377, &v376)) {
                  goto LABEL_299;
                }
                if (v377 == OS_LOG_TYPE_FAULT)
                {
                  os_log_type_t v97 = __nwlog_obj();
                  os_log_type_t v98 = v377;
                  if (os_log_type_enabled(v97, v377))
                  {
                    *(_DWORD *)v409 = 136446210;
                    v410 = "nw_http3_stream_serialize_fields";
                    char v99 = "%{public}s lsqpack end header before starting";
LABEL_297:
                    v121 = v409;
                    goto LABEL_298;
                  }
                  goto LABEL_299;
                }
                if (!v376)
                {
                  os_log_type_t v97 = __nwlog_obj();
                  os_log_type_t v98 = v377;
                  if (os_log_type_enabled(v97, v377))
                  {
                    *(_DWORD *)v409 = 136446210;
                    v410 = "nw_http3_stream_serialize_fields";
                    char v99 = "%{public}s lsqpack end header before starting, backtrace limit exceeded";
                    goto LABEL_297;
                  }
LABEL_299:
                  if (v96) {
                    free(v96);
                  }
                  id v17 = v358;
LABEL_302:
                  _Block_object_dispose(&v378, 8);
                  _Block_object_dispose(&v382, 8);
                  _Block_object_dispose(v386, 8);
                  _Block_object_dispose(v387, 8);
                  _Block_object_dispose(&v388, 8);
                  _Block_object_dispose(&v392, 8);
                  _Block_object_dispose(v396, 8);
                  _Block_object_dispose(v397, 8);
                  _Block_object_dispose(&v401, 8);
                  _Block_object_dispose(type, 8);
                  if (!v63)
                  {
LABEL_304:
                    int v81 = 0;
                    goto LABEL_305;
                  }
LABEL_303:
                  os_release(v63);
                  goto LABEL_304;
                }
                unsigned int v105 = (char *)__nw_create_backtrace_string();
                os_log_type_t v97 = __nwlog_obj();
                os_log_type_t v98 = v377;
                BOOL v120 = os_log_type_enabled(v97, v377);
                if (!v105)
                {
                  if (v120)
                  {
                    *(_DWORD *)v409 = 136446210;
                    v410 = "nw_http3_stream_serialize_fields";
                    char v99 = "%{public}s lsqpack end header before starting, no backtrace";
                    goto LABEL_297;
                  }
                  goto LABEL_299;
                }
                if (v120)
                {
                  *(_DWORD *)v409 = 136446466;
                  v410 = "nw_http3_stream_serialize_fields";
                  __int16 v411 = 2082;
                  v412 = v105;
                  v107 = "%{public}s lsqpack end header before starting, dumping backtrace:%{public}s";
                  v108 = v409;
                  goto LABEL_174;
                }
                goto LABEL_175;
              }
              *(_DWORD *)(a1 + 624) = v90 + 1;
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http3_stream_serialize_fields";
              int v96 = (char *)_os_log_send_and_compose_impl();
              __src[0] = OS_LOG_TYPE_ERROR;
              v409[0] = 0;
              if ((__nwlog_fault(v96, __src, v409) & 1) == 0) {
                goto LABEL_299;
              }
              if (__src[0] == OS_LOG_TYPE_FAULT)
              {
                os_log_type_t v97 = __nwlog_obj();
                os_log_type_t v98 = __src[0];
                if (!os_log_type_enabled(v97, __src[0])) {
                  goto LABEL_299;
                }
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_http3_stream_serialize_fields";
                char v99 = "%{public}s lsqpack header already started";
              }
              else if (v409[0])
              {
                unsigned int v105 = (char *)__nw_create_backtrace_string();
                os_log_type_t v97 = __nwlog_obj();
                os_log_type_t v98 = __src[0];
                BOOL v106 = os_log_type_enabled(v97, __src[0]);
                if (v105)
                {
                  if (v106)
                  {
                    *(_DWORD *)buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_http3_stream_serialize_fields";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = v105;
                    v107 = "%{public}s lsqpack header already started, dumping backtrace:%{public}s";
                    v108 = buf;
LABEL_174:
                    _os_log_impl(&dword_1830D4000, v97, v98, v107, v108, 0x16u);
                  }
LABEL_175:
                  free(v105);
                  goto LABEL_299;
                }
                if (!v106) {
                  goto LABEL_299;
                }
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_http3_stream_serialize_fields";
                char v99 = "%{public}s lsqpack header already started, no backtrace";
              }
              else
              {
                os_log_type_t v97 = __nwlog_obj();
                os_log_type_t v98 = __src[0];
                if (!os_log_type_enabled(v97, __src[0])) {
                  goto LABEL_299;
                }
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_http3_stream_serialize_fields";
                char v99 = "%{public}s lsqpack header already started, backtrace limit exceeded";
              }
              v121 = buf;
LABEL_298:
              _os_log_impl(&dword_1830D4000, v97, v98, v99, v121, 0xCu);
              goto LABEL_299;
            }
            __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_serialize_fields";
            v223 = (char *)_os_log_send_and_compose_impl();
            type[0] = 16;
            LOBYTE(v401) = 0;
            if (__nwlog_fault(v223, type, &v401))
            {
              if (type[0] == 17)
              {
                v224 = __nwlog_obj();
                os_log_type_t v225 = type[0];
                if (!os_log_type_enabled(v224, (os_log_type_t)type[0])) {
                  goto LABEL_529;
                }
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_http3_stream_serialize_fields";
                v226 = "%{public}s called with null http3_stream->http3_connection";
LABEL_528:
                _os_log_impl(&dword_1830D4000, v224, v225, v226, buf, 0xCu);
                goto LABEL_529;
              }
              if (!(_BYTE)v401)
              {
                v224 = __nwlog_obj();
                os_log_type_t v225 = type[0];
                if (!os_log_type_enabled(v224, (os_log_type_t)type[0])) {
                  goto LABEL_529;
                }
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_http3_stream_serialize_fields";
                v226 = "%{public}s called with null http3_stream->http3_connection, backtrace limit exceeded";
                goto LABEL_528;
              }
              v283 = (char *)__nw_create_backtrace_string();
              v224 = __nwlog_obj();
              os_log_type_t v225 = type[0];
              BOOL v284 = os_log_type_enabled(v224, (os_log_type_t)type[0]);
              if (!v283)
              {
                if (!v284) {
                  goto LABEL_529;
                }
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_http3_stream_serialize_fields";
                v226 = "%{public}s called with null http3_stream->http3_connection, no backtrace";
                goto LABEL_528;
              }
              if (v284)
              {
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_http3_stream_serialize_fields";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v283;
                _os_log_impl(&dword_1830D4000, v224, v225, "%{public}s called with null http3_stream->http3_connection, dumping backtrace:%{public}s", buf, 0x16u);
              }
              free(v283);
            }
LABEL_529:
            if (v223) {
              free(v223);
            }
            id v17 = v358;
            if (!v63) {
              goto LABEL_304;
            }
            goto LABEL_303;
          }
          id v358 = v17;
        }
        else
        {
          id v358 = v17;
          os_release(v58);
        }
        id v63 = 0;
        goto LABEL_111;
      }
      if ((*v6 & 0x800) == 0)
      {
        char v73 = __nwlog_obj();
        if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
        {
          int v74 = *(_DWORD *)(*(void *)(a1 + 336) + 1280);
          unint64_t v75 = *(void **)(a1 + 240);
          uint64_t v76 = *(void *)(a1 + 384);
          *(_DWORD *)buf = 136447490;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = a1 + 636;
          *(_WORD *)&buf[22] = 2080;
          v415 = (__n128 (*)(uint64_t, uint64_t))" ";
          LOWORD(v416) = 1024;
          *(_DWORD *)((char *)&v416 + 2) = v74;
          HIWORD(v416) = 2048;
          v417 = v75;
          *(_WORD *)v418 = 2048;
          *(void *)&v418[2] = v76;
          _os_log_impl(&dword_1830D4000, v73, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%llu> No response found in frame %p", buf, 0x3Au);
        }
      }
      uint64_t v77 = *(void *)(a1 + 48);
      if (v77)
      {
        uint64_t v78 = *(void *)(v77 + 24);
        if (v78)
        {
          __int16 v79 = *(void (**)(void))(v78 + 56);
          if (v79)
          {
            v79();
            uint64_t v44 = *(void *)(a1 + 48);
            if (!v44) {
              goto LABEL_573;
            }
LABEL_89:
            uint64_t v80 = *(void *)(v44 + 24);
            if (v80)
            {
              os_log_type_t v46 = *(void (**)(uint64_t, uint64_t))(v80 + 48);
              if (v46) {
                goto LABEL_91;
              }
            }
LABEL_573:
            id v357 = v17;
            __nwlog_obj();
            uint64_t v337 = *(void *)(a1 + 48);
            v338 = "invalid";
            if (v337)
            {
              v339 = *(const char **)(v337 + 16);
              if (v339) {
                v338 = v339;
              }
            }
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v338;
            int v50 = (char *)_os_log_send_and_compose_impl();
            type[0] = 16;
            LOBYTE(v401) = 0;
            if (__nwlog_fault(v50, type, &v401))
            {
              if (type[0] == 17)
              {
                unsigned int v51 = __nwlog_obj();
                os_log_type_t v52 = type[0];
                if (!os_log_type_enabled(v51, (os_log_type_t)type[0])) {
                  goto LABEL_603;
                }
                uint64_t v340 = *(void *)(a1 + 48);
                __int16 v54 = "invalid";
                if (v340)
                {
                  v341 = *(const char **)(v340 + 16);
                  if (v341) {
                    __int16 v54 = v341;
                  }
                }
                goto LABEL_60;
              }
              if (!(_BYTE)v401)
              {
                unsigned int v51 = __nwlog_obj();
                os_log_type_t v52 = type[0];
                if (!os_log_type_enabled(v51, (os_log_type_t)type[0])) {
                  goto LABEL_603;
                }
                uint64_t v347 = *(void *)(a1 + 48);
                v309 = "invalid";
                if (v347)
                {
                  v348 = *(const char **)(v347 + 16);
                  if (v348) {
                    v309 = v348;
                  }
                }
                goto LABEL_501;
              }
              v342 = (char *)__nw_create_backtrace_string();
              unsigned int v51 = __nwlog_obj();
              os_log_type_t v52 = type[0];
              BOOL v343 = os_log_type_enabled(v51, (os_log_type_t)type[0]);
              if (v342)
              {
                if (v343)
                {
                  uint64_t v344 = *(void *)(a1 + 48);
                  v345 = "invalid";
                  if (v344)
                  {
                    v346 = *(const char **)(v344 + 16);
                    if (v346) {
                      v345 = v346;
                    }
                  }
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v345;
                  *(_WORD *)&buf[22] = 2082;
                  v415 = (__n128 (*)(uint64_t, uint64_t))v342;
                  _os_log_impl(&dword_1830D4000, v51, v52, "%{public}s protocol %{public}s has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x20u);
                }
                free(v342);
                if (!v50) {
                  goto LABEL_605;
                }
                goto LABEL_604;
              }
              if (v343)
              {
                uint64_t v349 = *(void *)(a1 + 48);
                v329 = "invalid";
                if (v349)
                {
                  v350 = *(const char **)(v349 + 16);
                  if (v350) {
                    v329 = v350;
                  }
                }
                goto LABEL_601;
              }
            }
LABEL_603:
            if (!v50)
            {
LABEL_605:
              int v81 = 1;
              id v17 = v357;
              goto LABEL_305;
            }
LABEL_604:
            free(v50);
            goto LABEL_605;
          }
        }
      }
      id v361 = v17;
      __nwlog_obj();
      uint64_t v241 = *(void *)(a1 + 48);
      v242 = "invalid";
      if (v241)
      {
        v243 = *(const char **)(v241 + 16);
        if (v243) {
          v242 = v243;
        }
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v242;
      v244 = (char *)_os_log_send_and_compose_impl();
      type[0] = 16;
      LOBYTE(v401) = 0;
      if (__nwlog_fault(v244, type, &v401))
      {
        if (type[0] == 17)
        {
          v245 = __nwlog_obj();
          os_log_type_t v246 = type[0];
          if (!os_log_type_enabled(v245, (os_log_type_t)type[0])) {
            goto LABEL_570;
          }
          uint64_t v247 = *(void *)(a1 + 48);
          v248 = "invalid";
          if (v247)
          {
            v249 = *(const char **)(v247 + 16);
            if (v249) {
              v248 = v249;
            }
          }
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v248;
          v250 = "%{public}s protocol %{public}s has invalid error callback";
LABEL_569:
          _os_log_impl(&dword_1830D4000, v245, v246, v250, buf, 0x16u);
          goto LABEL_570;
        }
        if (!(_BYTE)v401)
        {
          v245 = __nwlog_obj();
          os_log_type_t v246 = type[0];
          if (!os_log_type_enabled(v245, (os_log_type_t)type[0])) {
            goto LABEL_570;
          }
          uint64_t v314 = *(void *)(a1 + 48);
          v315 = "invalid";
          if (v314)
          {
            v316 = *(const char **)(v314 + 16);
            if (v316) {
              v315 = v316;
            }
          }
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v315;
          v250 = "%{public}s protocol %{public}s has invalid error callback, backtrace limit exceeded";
          goto LABEL_569;
        }
        v295 = (char *)__nw_create_backtrace_string();
        v245 = __nwlog_obj();
        os_log_type_t v246 = type[0];
        BOOL v296 = os_log_type_enabled(v245, (os_log_type_t)type[0]);
        if (!v295)
        {
          if (!v296) {
            goto LABEL_570;
          }
          uint64_t v334 = *(void *)(a1 + 48);
          v335 = "invalid";
          if (v334)
          {
            v336 = *(const char **)(v334 + 16);
            if (v336) {
              v335 = v336;
            }
          }
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v335;
          v250 = "%{public}s protocol %{public}s has invalid error callback, no backtrace";
          goto LABEL_569;
        }
        if (v296)
        {
          uint64_t v297 = *(void *)(a1 + 48);
          v298 = "invalid";
          if (v297)
          {
            v299 = *(const char **)(v297 + 16);
            if (v299) {
              v298 = v299;
            }
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v298;
          *(_WORD *)&buf[22] = 2082;
          v415 = (__n128 (*)(uint64_t, uint64_t))v295;
          _os_log_impl(&dword_1830D4000, v245, v246, "%{public}s protocol %{public}s has invalid error callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v295);
      }
LABEL_570:
      if (v244) {
        free(v244);
      }
      id v17 = v361;
      uint64_t v44 = *(void *)(a1 + 48);
      if (!v44) {
        goto LABEL_573;
      }
      goto LABEL_89;
    }
    id v20 = nw_http_metadata_copy_response(v18);
    if (v20) {
      goto LABEL_40;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
    os_log_type_t v21 = (char *)_os_log_send_and_compose_impl();
    type[0] = 16;
    LOBYTE(v401) = 0;
    if (__nwlog_fault(v21, type, &v401))
    {
      if (type[0] == 17)
      {
        v65 = __nwlog_obj();
        os_log_type_t v66 = type[0];
        if (!os_log_type_enabled(v65, (os_log_type_t)type[0])) {
          goto LABEL_192;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
        BOOL v67 = "%{public}s did not find response on frame";
LABEL_191:
        _os_log_impl(&dword_1830D4000, v65, v66, v67, buf, 0xCu);
        goto LABEL_192;
      }
      if (!(_BYTE)v401)
      {
        v65 = __nwlog_obj();
        os_log_type_t v66 = type[0];
        if (!os_log_type_enabled(v65, (os_log_type_t)type[0])) {
          goto LABEL_192;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
        BOOL v67 = "%{public}s did not find response on frame, backtrace limit exceeded";
        goto LABEL_191;
      }
      id v86 = v17;
      BOOL v87 = (char *)__nw_create_backtrace_string();
      v65 = __nwlog_obj();
      os_log_type_t v66 = type[0];
      BOOL v88 = os_log_type_enabled(v65, (os_log_type_t)type[0]);
      if (!v87)
      {
        id v17 = v86;
        if (!v88) {
          goto LABEL_192;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
        BOOL v67 = "%{public}s did not find response on frame, no backtrace";
        goto LABEL_191;
      }
      if (v88)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v87;
        _os_log_impl(&dword_1830D4000, v65, v66, "%{public}s did not find response on frame, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v87);
      id v17 = v86;
    }
LABEL_192:
    if (v21) {
LABEL_193:
    }
      free(v21);
LABEL_194:
    if ((*v6 & 0x800) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v122 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        int v123 = *(_DWORD *)(*(void *)(a1 + 336) + 1280);
        char v124 = *(void **)(a1 + 240);
        uint64_t v125 = *(void *)(a1 + 384);
        *(_DWORD *)buf = 136447490;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = a1 + 636;
        *(_WORD *)&buf[22] = 2080;
        v415 = (__n128 (*)(uint64_t, uint64_t))" ";
        LOWORD(v416) = 1024;
        *(_DWORD *)((char *)&v416 + 2) = v123;
        HIWORD(v416) = 2048;
        v417 = v124;
        *(_WORD *)v418 = 2048;
        *(void *)&v418[2] = v125;
        _os_log_impl(&dword_1830D4000, v122, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%llu> Invalid http metadata found in frame %p", buf, 0x3Au);
      }
    }
    uint64_t v126 = *(void *)(a1 + 48);
    if (v126)
    {
      uint64_t v127 = *(void *)(v126 + 24);
      if (v127)
      {
        uint64_t v128 = *(void (**)(uint64_t, uint64_t))(v127 + 56);
        if (v128)
        {
          v128(v126, a1);
          uint64_t v129 = *(void *)(a1 + 48);
          if (!v129) {
            goto LABEL_403;
          }
LABEL_201:
          uint64_t v130 = *(void *)(v129 + 24);
          if (v130)
          {
            uint64_t v131 = *(void (**)(uint64_t, uint64_t))(v130 + 48);
            if (v131)
            {
              v131(v129, a1);
              goto LABEL_204;
            }
          }
LABEL_403:
          __nwlog_obj();
          uint64_t v254 = *(void *)(a1 + 48);
          v255 = "invalid";
          if (v254)
          {
            v256 = *(const char **)(v254 + 16);
            if (v256) {
              v255 = v256;
            }
          }
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v255;
          v257 = (char *)_os_log_send_and_compose_impl();
          type[0] = 16;
          LOBYTE(v401) = 0;
          if (!__nwlog_fault(v257, type, &v401)) {
            goto LABEL_433;
          }
          if (type[0] == 17)
          {
            v258 = __nwlog_obj();
            os_log_type_t v259 = type[0];
            if (os_log_type_enabled(v258, (os_log_type_t)type[0]))
            {
              uint64_t v260 = *(void *)(a1 + 48);
              v261 = "invalid";
              if (v260)
              {
                v262 = *(const char **)(v260 + 16);
                if (v262) {
                  v261 = v262;
                }
              }
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v261;
              _os_log_impl(&dword_1830D4000, v258, v259, "%{public}s protocol %{public}s has invalid disconnected callback", buf, 0x16u);
            }
            goto LABEL_433;
          }
          id v263 = v17;
          if ((_BYTE)v401)
          {
            v264 = (char *)__nw_create_backtrace_string();
            v265 = __nwlog_obj();
            os_log_type_t v266 = type[0];
            BOOL v267 = os_log_type_enabled(v265, (os_log_type_t)type[0]);
            if (v264)
            {
              if (v267)
              {
                uint64_t v268 = *(void *)(a1 + 48);
                v269 = "invalid";
                if (v268)
                {
                  v270 = *(const char **)(v268 + 16);
                  if (v270) {
                    v269 = v270;
                  }
                }
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v269;
                *(_WORD *)&buf[22] = 2082;
                v415 = (__n128 (*)(uint64_t, uint64_t))v264;
                _os_log_impl(&dword_1830D4000, v265, v266, "%{public}s protocol %{public}s has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x20u);
              }
              free(v264);
              goto LABEL_432;
            }
            id v17 = v263;
            if (!v267) {
              goto LABEL_433;
            }
            uint64_t v275 = *(void *)(a1 + 48);
            v276 = "invalid";
            if (v275)
            {
              v277 = *(const char **)(v275 + 16);
              if (v277) {
                v276 = v277;
              }
            }
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v276;
            v274 = "%{public}s protocol %{public}s has invalid disconnected callback, no backtrace";
          }
          else
          {
            v265 = __nwlog_obj();
            os_log_type_t v266 = type[0];
            if (!os_log_type_enabled(v265, (os_log_type_t)type[0])) {
              goto LABEL_433;
            }
            uint64_t v271 = *(void *)(a1 + 48);
            v272 = "invalid";
            if (v271)
            {
              v273 = *(const char **)(v271 + 16);
              if (v273) {
                v272 = v273;
              }
            }
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v272;
            v274 = "%{public}s protocol %{public}s has invalid disconnected callback, backtrace limit exceeded";
          }
          _os_log_impl(&dword_1830D4000, v265, v266, v274, buf, 0x16u);
LABEL_432:
          id v17 = v263;
LABEL_433:
          if (v257) {
            free(v257);
          }
LABEL_204:
          int v81 = 1;
          if (!v19)
          {
LABEL_306:
            if (v17) {
              os_release(v17);
            }
            if (v81) {
              return 0;
            }
LABEL_6:
            int v7 = *(NSObject **)(a1 + 528);
            if (!v7) {
              goto LABEL_221;
            }
            *(void *)buf = 0;
            *(void *)&buf[8] = buf;
            *(void *)&buf[16] = 0x3802000000;
            v415 = __Block_byref_object_copy__61309;
            v416 = (os_log_type_t *)__Block_byref_object_dispose__61310;
            v417 = 0;
            *(void *)v418 = &v417;
            uint64_t v401 = 0;
            v402 = &v401;
            LODWORD(v404) = 0;
            uint64_t v403 = 0x2000000000;
            LODWORD(v404) = dispatch_data_get_size(v7);
            uint64_t v8 = *(void *)(a1 + 336);
            if (!v8)
            {
              __nwlog_obj();
              *(_DWORD *)os_log_type_t type = 136446210;
              *(void *)&type[4] = "nw_http3_encoder_stream_get_output_frames";
              int v32 = (char *)_os_log_send_and_compose_impl();
              v397[0] = OS_LOG_TYPE_ERROR;
              LOBYTE(v396[0]) = 0;
              if (__nwlog_fault(v32, v397, v396))
              {
                if (v397[0] == OS_LOG_TYPE_FAULT)
                {
                  __int16 v33 = __nwlog_obj();
                  os_log_type_t v34 = v397[0];
                  if (os_log_type_enabled(v33, v397[0]))
                  {
                    *(_DWORD *)os_log_type_t type = 136446210;
                    *(void *)&type[4] = "nw_http3_encoder_stream_get_output_frames";
                    uint64_t v35 = "%{public}s called with null http3";
                    goto LABEL_178;
                  }
                }
                else if (LOBYTE(v396[0]))
                {
                  v205 = (char *)__nw_create_backtrace_string();
                  __int16 v33 = __nwlog_obj();
                  os_log_type_t v34 = v397[0];
                  BOOL v206 = os_log_type_enabled(v33, v397[0]);
                  if (v205)
                  {
                    if (v206)
                    {
                      *(_DWORD *)os_log_type_t type = 136446466;
                      *(void *)&type[4] = "nw_http3_encoder_stream_get_output_frames";
                      *(_WORD *)&type[12] = 2082;
                      *(void *)&type[14] = v205;
                      _os_log_impl(&dword_1830D4000, v33, v34, "%{public}s called with null http3, dumping backtrace:%{public}s", type, 0x16u);
                    }
                    free(v205);
                  }
                  else if (v206)
                  {
                    *(_DWORD *)os_log_type_t type = 136446210;
                    *(void *)&type[4] = "nw_http3_encoder_stream_get_output_frames";
                    uint64_t v35 = "%{public}s called with null http3, no backtrace";
                    goto LABEL_178;
                  }
                }
                else
                {
                  __int16 v33 = __nwlog_obj();
                  os_log_type_t v34 = v397[0];
                  if (os_log_type_enabled(v33, v397[0]))
                  {
                    *(_DWORD *)os_log_type_t type = 136446210;
                    *(void *)&type[4] = "nw_http3_encoder_stream_get_output_frames";
                    uint64_t v35 = "%{public}s called with null http3, backtrace limit exceeded";
                    goto LABEL_178;
                  }
                }
              }
LABEL_179:
              if (!v32) {
                goto LABEL_12;
              }
LABEL_180:
              free(v32);
              goto LABEL_12;
            }
            if ((*(_WORD *)(v8 + 1373) & 0x2000) == 0 || (uint64_t v9 = *(void *)(v8 + 928)) != 0 && v9 != a1)
            {
              *(void *)(a1 + 576) = 0;
              char v10 = *(uint64_t **)(v8 + 936);
              *(void *)(a1 + 584) = v10;
              *char v10 = a1;
              *(void *)(v8 + 936) = a1 + 576;
LABEL_12:
              _Block_object_dispose(&v401, 8);
              uint64_t v11 = buf;
LABEL_287:
              _Block_object_dispose(v11, 8);
              return 0;
            }
            if (!v9)
            {
              *(void *)(a1 + 576) = 0;
              BOOL v25 = *(uint64_t **)(v8 + 936);
              *(void *)(a1 + 584) = v25;
              *BOOL v25 = a1;
              *(void *)(v8 + 936) = a1 + 576;
            }
            nw_http3_start_encoder_stream_if_needed(v8);
            uint64_t v26 = *(void *)(v8 + 1056);
            if (!v26) {
              goto LABEL_12;
            }
            uint64_t v27 = *(void *)(v26 + 24);
            if (!v27) {
              goto LABEL_12;
            }
            char v28 = *(unsigned int (**)(uint64_t, uint64_t))(v27 + 88);
            if (!v28 || !v28(v26, a1)) {
              goto LABEL_12;
            }
            v368[0] = MEMORY[0x1E4F143A8];
            v368[1] = 0x40000000;
            v369 = (uint64_t (*)(void *))___ZL27nw_http3_stream_send_fieldsP24nw_protocol_http3_streamb_block_invoke_3;
            v370 = &unk_1E52475E0;
            v371 = &v401;
            v372 = buf;
            uint64_t v373 = a1;
            uint64_t v29 = *(void *)(*(void *)&buf[8] + 40);
            do
            {
              if (!v29) {
                break;
              }
              uint64_t v30 = *(void *)(v29 + 32);
              char v31 = v369(v368);
              uint64_t v29 = v30;
            }
            while ((v31 & 1) != 0);
            if (*(void *)(a1 + 528))
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              *(_DWORD *)os_log_type_t type = 136446210;
              *(void *)&type[4] = "nw_http3_stream_send_fields";
              int v32 = (char *)_os_log_send_and_compose_impl();
              v397[0] = OS_LOG_TYPE_ERROR;
              LOBYTE(v396[0]) = 0;
              if (!__nwlog_fault(v32, v397, v396)) {
                goto LABEL_179;
              }
              if (v397[0] == OS_LOG_TYPE_FAULT)
              {
                __int16 v33 = __nwlog_obj();
                os_log_type_t v34 = v397[0];
                if (!os_log_type_enabled(v33, v397[0])) {
                  goto LABEL_179;
                }
                *(_DWORD *)os_log_type_t type = 136446210;
                *(void *)&type[4] = "nw_http3_stream_send_fields";
                uint64_t v35 = "%{public}s Not enough space on encoder stream";
                goto LABEL_178;
              }
              if (!LOBYTE(v396[0]))
              {
                __int16 v33 = __nwlog_obj();
                os_log_type_t v34 = v397[0];
                if (!os_log_type_enabled(v33, v397[0])) {
                  goto LABEL_179;
                }
                *(_DWORD *)os_log_type_t type = 136446210;
                *(void *)&type[4] = "nw_http3_stream_send_fields";
                uint64_t v35 = "%{public}s Not enough space on encoder stream, backtrace limit exceeded";
                goto LABEL_178;
              }
              uint64_t v82 = (char *)__nw_create_backtrace_string();
              __int16 v33 = __nwlog_obj();
              os_log_type_t v34 = v397[0];
              BOOL v83 = os_log_type_enabled(v33, v397[0]);
              if (v82)
              {
                if (v83)
                {
                  *(_DWORD *)os_log_type_t type = 136446466;
                  *(void *)&type[4] = "nw_http3_stream_send_fields";
                  *(_WORD *)&type[12] = 2082;
                  *(void *)&type[14] = v82;
                  _os_log_impl(&dword_1830D4000, v33, v34, "%{public}s Not enough space on encoder stream, dumping backtrace:%{public}s", type, 0x16u);
                }
                free(v82);
                if (!v32) {
                  goto LABEL_12;
                }
                goto LABEL_180;
              }
              if (v83)
              {
                *(_DWORD *)os_log_type_t type = 136446210;
                *(void *)&type[4] = "nw_http3_stream_send_fields";
                uint64_t v35 = "%{public}s Not enough space on encoder stream, no backtrace";
LABEL_178:
                _os_log_impl(&dword_1830D4000, v33, v34, v35, type, 0xCu);
                goto LABEL_179;
              }
              goto LABEL_179;
            }
            *(unsigned char *)(a1 + 738) |= 4u;
            uint64_t v68 = *(void **)(a1 + 336);
            if (v68)
            {
              if (v68[116] != a1)
              {
                __nwlog_obj();
                *(_DWORD *)os_log_type_t type = 136446210;
                *(void *)&type[4] = "nw_http3_encoder_stream_finalize_output_frames";
                uint64_t v69 = (char *)_os_log_send_and_compose_impl();
                v397[0] = OS_LOG_TYPE_ERROR;
                LOBYTE(v396[0]) = 0;
                if (!__nwlog_fault(v69, v397, v396)) {
                  goto LABEL_218;
                }
                if (v397[0] == OS_LOG_TYPE_FAULT)
                {
                  unsigned int v70 = __nwlog_obj();
                  os_log_type_t v71 = v397[0];
                  if (!os_log_type_enabled(v70, v397[0])) {
                    goto LABEL_218;
                  }
                  *(_DWORD *)os_log_type_t type = 136446210;
                  *(void *)&type[4] = "nw_http3_encoder_stream_finalize_output_frames";
                  uint64_t v72 = "%{public}s Encoder stream is not being used by current stream";
                }
                else if (LOBYTE(v396[0]))
                {
                  unsigned int v112 = (char *)__nw_create_backtrace_string();
                  unsigned int v70 = __nwlog_obj();
                  os_log_type_t v71 = v397[0];
                  BOOL v113 = os_log_type_enabled(v70, v397[0]);
                  if (v112)
                  {
                    if (v113)
                    {
                      *(_DWORD *)os_log_type_t type = 136446466;
                      *(void *)&type[4] = "nw_http3_encoder_stream_finalize_output_frames";
                      *(_WORD *)&type[12] = 2082;
                      *(void *)&type[14] = v112;
                      _os_log_impl(&dword_1830D4000, v70, v71, "%{public}s Encoder stream is not being used by current stream, dumping backtrace:%{public}s", type, 0x16u);
                    }
                    free(v112);
                    goto LABEL_218;
                  }
                  if (!v113)
                  {
LABEL_218:
                    if (v69) {
                      free(v69);
                    }
                    goto LABEL_220;
                  }
                  *(_DWORD *)os_log_type_t type = 136446210;
                  *(void *)&type[4] = "nw_http3_encoder_stream_finalize_output_frames";
                  uint64_t v72 = "%{public}s Encoder stream is not being used by current stream, no backtrace";
                }
                else
                {
                  unsigned int v70 = __nwlog_obj();
                  os_log_type_t v71 = v397[0];
                  if (!os_log_type_enabled(v70, v397[0])) {
                    goto LABEL_218;
                  }
                  *(_DWORD *)os_log_type_t type = 136446210;
                  *(void *)&type[4] = "nw_http3_encoder_stream_finalize_output_frames";
                  uint64_t v72 = "%{public}s Encoder stream is not being used by current stream, backtrace limit exceeded";
                }
                _os_log_impl(&dword_1830D4000, v70, v71, v72, type, 0xCu);
                goto LABEL_218;
              }
              uint64_t v110 = *(void *)(a1 + 576);
              int v111 = *(void **)(a1 + 584);
              if (v110)
              {
                *(void *)(v110 + 584) = v111;
                int v111 = *(void **)(a1 + 584);
              }
              else
              {
                v68[117] = v111;
              }
              uint64_t v132 = *(void *)&buf[8];
              *int v111 = v110;
              *(void *)(a1 + 576) = 0;
              *(void *)(a1 + 584) = 0;
              uint64_t v133 = v68[132];
              if (v133)
              {
                uint64_t v134 = *(void *)(v133 + 24);
                if (v134)
                {
                  v135 = *(void (**)(uint64_t, uint64_t))(v134 + 96);
                  if (v135)
                  {
                    v135(v133, v132 + 40);
LABEL_220:
                    nw_http_transaction_metadata_increment_outbound_header_size(*(void **)(a1 + 392), *((unsigned int *)v402 + 6));
                    int v136 = (unsigned __int16)*v6;
                    unsigned int v137 = (v136 | (*(unsigned __int8 *)(a1 + 738) << 16)) & 0xFFFBFFFF;
                    *BOOL v6 = v136;
                    *(unsigned char *)(a1 + 738) = BYTE2(v137);
                    _Block_object_dispose(&v401, 8);
                    _Block_object_dispose(buf, 8);
LABEL_221:
                    v138 = *(NSObject **)(a1 + 520);
                    if (v138)
                    {
                      *(void *)os_log_type_t type = 0;
                      *(void *)&os_log_type_t type[8] = type;
                      *(void *)&type[16] = 0x3802000000;
                      v406 = __Block_byref_object_copy__61309;
                      v407 = __Block_byref_object_dispose__61310;
                      v408[0] = 0;
                      v408[1] = v408;
                      uint64_t v401 = 0;
                      v402 = &v401;
                      LODWORD(v404) = 0;
                      uint64_t v403 = 0x2000000000;
                      LODWORD(v404) = dispatch_data_get_size(v138);
                      if (!nw_http3_framer_get_output_frames_for_single_http3_frame(a1 + 128, 1uLL, v404, v408))
                      {
LABEL_286:
                        _Block_object_dispose(&v401, 8);
                        uint64_t v11 = type;
                        goto LABEL_287;
                      }
                      v362[0] = MEMORY[0x1E4F143A8];
                      v362[1] = 0x40000000;
                      v363 = (uint64_t (*)(void *))___ZL27nw_http3_stream_send_fieldsP24nw_protocol_http3_streamb_block_invoke_110;
                      v364 = &unk_1E5247608;
                      v366 = type;
                      uint64_t v367 = a1;
                      v365 = &v401;
                      uint64_t v139 = *(void *)(*(void *)&type[8] + 40);
                      do
                      {
                        if (!v139) {
                          break;
                        }
                        uint64_t v140 = *(void *)(v139 + 32);
                        char v141 = v363(v362);
                        uint64_t v139 = v140;
                      }
                      while ((v141 & 1) != 0);
                      if (*(void *)(a1 + 520))
                      {
                        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                        networkd_settings_init();
                        *(_DWORD *)buf = 136446210;
                        *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
                        uint64_t v142 = (char *)_os_log_send_and_compose_impl();
                        v397[0] = OS_LOG_TYPE_ERROR;
                        LOBYTE(v396[0]) = 0;
                        if (!__nwlog_fault(v142, v397, v396)) {
                          goto LABEL_284;
                        }
                        if (v397[0] == OS_LOG_TYPE_FAULT)
                        {
                          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                          networkd_settings_init();
                          unsigned int v143 = gLogObj;
                          os_log_type_t v144 = v397[0];
                          if (!os_log_type_enabled((os_log_t)gLogObj, v397[0])) {
                            goto LABEL_284;
                          }
                          *(_DWORD *)buf = 136446210;
                          *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
                          v145 = "%{public}s Not enough space in fields frame";
                        }
                        else if (LOBYTE(v396[0]))
                        {
                          v167 = (char *)__nw_create_backtrace_string();
                          unsigned int v143 = __nwlog_obj();
                          os_log_type_t v144 = v397[0];
                          BOOL v168 = os_log_type_enabled(v143, v397[0]);
                          if (v167)
                          {
                            if (v168)
                            {
                              *(_DWORD *)buf = 136446466;
                              *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
                              *(_WORD *)&buf[12] = 2082;
                              *(void *)&buf[14] = v167;
                              _os_log_impl(&dword_1830D4000, v143, v144, "%{public}s Not enough space in fields frame, dumping backtrace:%{public}s", buf, 0x16u);
                            }
                            free(v167);
                            goto LABEL_284;
                          }
                          if (!v168)
                          {
LABEL_284:
                            if (v142) {
                              free(v142);
                            }
                            goto LABEL_286;
                          }
                          *(_DWORD *)buf = 136446210;
                          *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
                          v145 = "%{public}s Not enough space in fields frame, no backtrace";
                        }
                        else
                        {
                          unsigned int v143 = __nwlog_obj();
                          os_log_type_t v144 = v397[0];
                          if (!os_log_type_enabled(v143, v397[0])) {
                            goto LABEL_284;
                          }
                          *(_DWORD *)buf = 136446210;
                          *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
                          v145 = "%{public}s Not enough space in fields frame, backtrace limit exceeded";
                        }
                        _os_log_impl(&dword_1830D4000, v143, v144, v145, buf, 0xCu);
                        goto LABEL_284;
                      }
                      int v146 = *(unsigned __int16 *)(a1 + 736) | (*(unsigned __int8 *)(a1 + 738) << 16);
                      uint64_t v147 = *(void *)&type[8];
                      if (a2 && (v146 & 0x14000) == 0)
                      {
                        uint64_t v148 = **(void **)(*(void *)(*(void *)&type[8] + 48) + 8);
                        *(unsigned char *)(v148 + 186) |= 0x80u;
                        int v146 = (unsigned __int16)*v6 | (*(unsigned __int8 *)(a1 + 738) << 16);
                      }
                      *BOOL v6 = v146;
                      *(unsigned char *)(a1 + 738) = (v146 | 0x40000u) >> 16;
                      uint64_t v149 = *(void *)(a1 + 160);
                      if (v149 && (uint64_t v150 = *(void *)(v149 + 24)) != 0 && *(void *)(v150 + 96))
                      {
                        unsigned int v151 = *((_DWORD *)v402 + 6);
                        v152 = (uint64_t *)(v147 + 40);
                        if (v151 >> 30) {
                          int v153 = 8;
                        }
                        else {
                          int v153 = 4;
                        }
                        if (v151 >= 0x4000) {
                          int v154 = v153;
                        }
                        else {
                          int v154 = 2;
                        }
                        if (v151 >= 0x40) {
                          int v155 = v154;
                        }
                        else {
                          int v155 = 1;
                        }
                        unsigned int v156 = nw_http3_framer_write_http3_frame_header(a1 + 128, 1uLL, *((_DWORD *)v402 + 6), v155 + 1, *v152)+ v151;
                        (*(void (**)(uint64_t, uint64_t *))(*(void *)(v149 + 24) + 96))(v149, v152);
                      }
                      else
                      {
                        unsigned int v156 = 0;
                      }
                      nw_http_transaction_metadata_increment_outbound_header_size(*(void **)(a1 + 392), v156);
                      int v157 = (unsigned __int16)*v6;
                      unsigned int v158 = (v157 | (*(unsigned __int8 *)(a1 + 738) << 16)) & 0xFFFBFFFF;
                      *BOOL v6 = v157;
                      *(unsigned char *)(a1 + 738) = BYTE2(v158);
                      if (a2)
                      {
                        nw_http_transaction_metadata_mark_outbound_message_end(*(void **)(a1 + 392));
                        if (*(unsigned char *)(a1 + 280))
                        {
                          if (*(void *)(a1 + 272) != *(void *)(a1 + 288))
                          {
                            if ((*v6 & 0x800) == 0)
                            {
                              v175 = __nwlog_obj();
                              if (os_log_type_enabled(v175, OS_LOG_TYPE_ERROR))
                              {
                                int v176 = *(_DWORD *)(*(void *)(a1 + 336) + 1280);
                                v177 = *(void **)(a1 + 240);
                                if (*(unsigned char *)(a1 + 280)) {
                                  uint64_t v178 = *(void *)(a1 + 272);
                                }
                                else {
                                  uint64_t v178 = -1;
                                }
                                uint64_t v179 = *(void *)(a1 + 288);
                                *(_DWORD *)buf = 136447746;
                                *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
                                *(_WORD *)&buf[12] = 2082;
                                *(void *)&buf[14] = a1 + 636;
                                *(_WORD *)&buf[22] = 2080;
                                v415 = (__n128 (*)(uint64_t, uint64_t))" ";
                                LOWORD(v416) = 1024;
                                *(_DWORD *)((char *)&v416 + 2) = v176;
                                HIWORD(v416) = 2048;
                                v417 = v177;
                                *(_WORD *)v418 = 2048;
                                *(void *)&v418[2] = v178;
                                *(_WORD *)&v418[10] = 2048;
                                *(void *)&v418[12] = v179;
                                _os_log_impl(&dword_1830D4000, v175, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%llu> Content length header %llu does not equal body size %llu", buf, 0x44u);
                              }
                            }
                            *(void *)(a1 + 264) = 270;
                            nw_protocol_http3_stream_error((nw_protocol *)a1, (nw_protocol *)a1, 22);
                            nw_protocol_http3_stream_disconnect((nw_protocol *)a1, (nw_protocol *)a1);
                            goto LABEL_286;
                          }
                        }
                      }
                      _Block_object_dispose(&v401, 8);
                      _Block_object_dispose(type, 8);
                      int v159 = (unsigned __int16)*v6 | (*(unsigned __int8 *)(a1 + 738) << 16);
                      if ((v159 & 0x10000) != 0)
                      {
                        nw_frame_reset(*(void *)(a1 + 384), 0, 0, 0, 0);
                        v169 = *(void **)(a1 + 384);
                        if (v169)
                        {
                          os_release(v169);
                          *(void *)(a1 + 384) = 0;
                        }
                        *(void *)(a1 + 384) = nw_frame_create(0, 0, 0, 0, 0);
                        *(_DWORD *)(a1 + 368) = 1;
                      }
                      else
                      {
                        if ((*v6 & 0x30) != 0) {
                          int v160 = 5;
                        }
                        else {
                          int v160 = 3;
                        }
                        *(_DWORD *)(a1 + 368) = v160;
                        if ((v159 & 1) == 0)
                        {
                          uint64_t v161 = *(void *)(a1 + 32);
                          if (v161)
                          {
                            uint64_t v162 = *(void *)(v161 + 24);
                            if (v162)
                            {
                              v163 = *(void (**)(uint64_t, uint64_t))(v162 + 160);
                              if (v163)
                              {
                                v163(v161, a1);
                                LOWORD(v159) = *v6;
                              }
                            }
                          }
                          if ((v159 & 0x10) != 0)
                          {
                            uint64_t v164 = *(void *)(a1 + 32);
                            if (v164)
                            {
                              uint64_t v165 = *(void *)(v164 + 24);
                              if (v165)
                              {
                                v166 = *(void (**)(uint64_t, uint64_t))(v165 + 160);
                                if (v166) {
                                  v166(v164, a1 + 64);
                                }
                              }
                            }
                          }
                        }
                      }
                      if ((*v6 & 0x200) == 0) {
                        return 1;
                      }
                      uint64_t v170 = *(void *)(a1 + 32);
                      if (v170)
                      {
                        uint64_t v171 = *(void *)(v170 + 24);
                        if (v171)
                        {
                          v172 = *(void (**)(uint64_t, uint64_t))(v171 + 192);
                          if (v172)
                          {
                            v172(v170, a1);
LABEL_277:
                            int v173 = (unsigned __int16)*v6;
                            unsigned int v174 = v173 & 0xFFFFFDFF | (*(unsigned __int8 *)(a1 + 738) << 16);
                            *BOOL v6 = v173 & 0xFDFF;
                            *(unsigned char *)(a1 + 738) = BYTE2(v174);
                            return 1;
                          }
                        }
                      }
                      __nwlog_obj();
                      uint64_t v213 = *(void *)(a1 + 32);
                      v214 = "invalid";
                      if (v213)
                      {
                        v215 = *(const char **)(v213 + 16);
                        if (v215) {
                          v214 = v215;
                        }
                      }
                      *(_DWORD *)buf = 136446466;
                      *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&buf[14] = v214;
                      v216 = (char *)_os_log_send_and_compose_impl();
                      type[0] = 16;
                      LOBYTE(v401) = 0;
                      if (__nwlog_fault(v216, type, &v401))
                      {
                        if (type[0] == 17)
                        {
                          v217 = __nwlog_obj();
                          os_log_type_t v218 = type[0];
                          if (!os_log_type_enabled(v217, (os_log_type_t)type[0])) {
                            goto LABEL_524;
                          }
                          uint64_t v219 = *(void *)(a1 + 32);
                          v220 = "invalid";
                          if (v219)
                          {
                            v221 = *(const char **)(v219 + 16);
                            if (v221) {
                              v220 = v221;
                            }
                          }
                          *(_DWORD *)buf = 136446466;
                          *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
                          *(_WORD *)&buf[12] = 2082;
                          *(void *)&buf[14] = v220;
                          v222 = "%{public}s protocol %{public}s has invalid output_finished callback";
                          goto LABEL_523;
                        }
                        if (!(_BYTE)v401)
                        {
                          v217 = __nwlog_obj();
                          os_log_type_t v218 = type[0];
                          if (!os_log_type_enabled(v217, (os_log_type_t)type[0])) {
                            goto LABEL_524;
                          }
                          uint64_t v305 = *(void *)(a1 + 32);
                          v306 = "invalid";
                          if (v305)
                          {
                            v307 = *(const char **)(v305 + 16);
                            if (v307) {
                              v306 = v307;
                            }
                          }
                          *(_DWORD *)buf = 136446466;
                          *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
                          *(_WORD *)&buf[12] = 2082;
                          *(void *)&buf[14] = v306;
                          v222 = "%{public}s protocol %{public}s has invalid output_finished callback, backtrace limit exceeded";
                          goto LABEL_523;
                        }
                        v278 = (char *)__nw_create_backtrace_string();
                        v217 = __nwlog_obj();
                        os_log_type_t v218 = type[0];
                        BOOL v279 = os_log_type_enabled(v217, (os_log_type_t)type[0]);
                        if (v278)
                        {
                          if (v279)
                          {
                            uint64_t v280 = *(void *)(a1 + 32);
                            v281 = "invalid";
                            if (v280)
                            {
                              v282 = *(const char **)(v280 + 16);
                              if (v282) {
                                v281 = v282;
                              }
                            }
                            *(_DWORD *)buf = 136446722;
                            *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
                            *(_WORD *)&buf[12] = 2082;
                            *(void *)&buf[14] = v281;
                            *(_WORD *)&buf[22] = 2082;
                            v415 = (__n128 (*)(uint64_t, uint64_t))v278;
                            _os_log_impl(&dword_1830D4000, v217, v218, "%{public}s protocol %{public}s has invalid output_finished callback, dumping backtrace:%{public}s", buf, 0x20u);
                          }
                          free(v278);
                          goto LABEL_524;
                        }
                        if (v279)
                        {
                          uint64_t v319 = *(void *)(a1 + 32);
                          v320 = "invalid";
                          if (v319)
                          {
                            v321 = *(const char **)(v319 + 16);
                            if (v321) {
                              v320 = v321;
                            }
                          }
                          *(_DWORD *)buf = 136446466;
                          *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
                          *(_WORD *)&buf[12] = 2082;
                          *(void *)&buf[14] = v320;
                          v222 = "%{public}s protocol %{public}s has invalid output_finished callback, no backtrace";
LABEL_523:
                          _os_log_impl(&dword_1830D4000, v217, v218, v222, buf, 0x16u);
                        }
                      }
LABEL_524:
                      if (v216) {
                        free(v216);
                      }
                      goto LABEL_277;
                    }
                    __nwlog_obj();
                    *(_DWORD *)buf = 136446210;
                    *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
                    v201 = (char *)_os_log_send_and_compose_impl();
                    type[0] = 16;
                    LOBYTE(v401) = 0;
                    if (__nwlog_fault(v201, type, &v401))
                    {
                      if (type[0] == 17)
                      {
                        v202 = __nwlog_obj();
                        os_log_type_t v203 = type[0];
                        if (!os_log_type_enabled(v202, (os_log_type_t)type[0])) {
                          goto LABEL_481;
                        }
                        *(_DWORD *)buf = 136446210;
                        *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
                        v204 = "%{public}s called with null http3_stream->output_fields_frame_data";
                        goto LABEL_480;
                      }
                      if (!(_BYTE)v401)
                      {
                        v202 = __nwlog_obj();
                        os_log_type_t v203 = type[0];
                        if (!os_log_type_enabled(v202, (os_log_type_t)type[0])) {
                          goto LABEL_481;
                        }
                        *(_DWORD *)buf = 136446210;
                        *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
                        v204 = "%{public}s called with null http3_stream->output_fields_frame_data, backtrace limit exceeded";
                        goto LABEL_480;
                      }
                      v207 = (char *)__nw_create_backtrace_string();
                      v202 = __nwlog_obj();
                      os_log_type_t v203 = type[0];
                      BOOL v208 = os_log_type_enabled(v202, (os_log_type_t)type[0]);
                      if (v207)
                      {
                        if (v208)
                        {
                          *(_DWORD *)buf = 136446466;
                          *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
                          *(_WORD *)&buf[12] = 2082;
                          *(void *)&buf[14] = v207;
                          _os_log_impl(&dword_1830D4000, v202, v203, "%{public}s called with null http3_stream->output_fields_frame_data, dumping backtrace:%{public}s", buf, 0x16u);
                        }
                        free(v207);
                        goto LABEL_481;
                      }
                      if (v208)
                      {
                        *(_DWORD *)buf = 136446210;
                        *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
                        v204 = "%{public}s called with null http3_stream->output_fields_frame_data, no backtrace";
LABEL_480:
                        _os_log_impl(&dword_1830D4000, v202, v203, v204, buf, 0xCu);
                      }
                    }
LABEL_481:
                    if (v201) {
                      free(v201);
                    }
                    return 0;
                  }
                }
                __nwlog_obj();
                v304 = *(const char **)(v133 + 16);
                if (!v304) {
                  v304 = "invalid";
                }
              }
              else
              {
                __nwlog_obj();
                v304 = "invalid";
              }
              *(_DWORD *)os_log_type_t type = 136446466;
              *(void *)&type[4] = "nw_http3_encoder_stream_finalize_output_frames";
              *(_WORD *)&type[12] = 2082;
              *(void *)&type[14] = v304;
              v300 = (char *)_os_log_send_and_compose_impl();
              v397[0] = OS_LOG_TYPE_ERROR;
              LOBYTE(v396[0]) = 0;
              if (!__nwlog_fault(v300, v397, v396)) {
                goto LABEL_623;
              }
              if (v397[0] == OS_LOG_TYPE_FAULT)
              {
                v322 = __nwlog_obj();
                os_log_type_t v323 = v397[0];
                if (!os_log_type_enabled(v322, v397[0])) {
                  goto LABEL_623;
                }
                v324 = "invalid";
                if (v133 && *(void *)(v133 + 16)) {
                  v324 = *(const char **)(v133 + 16);
                }
                *(_DWORD *)os_log_type_t type = 136446466;
                *(void *)&type[4] = "nw_http3_encoder_stream_finalize_output_frames";
                *(_WORD *)&type[12] = 2082;
                *(void *)&type[14] = v324;
                v303 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback";
LABEL_618:
                v353 = v322;
                os_log_type_t v354 = v323;
                uint32_t v355 = 22;
LABEL_622:
                _os_log_impl(&dword_1830D4000, v353, v354, v303, type, v355);
                goto LABEL_623;
              }
              if (!LOBYTE(v396[0]))
              {
                v322 = __nwlog_obj();
                os_log_type_t v323 = v397[0];
                if (!os_log_type_enabled(v322, v397[0])) {
                  goto LABEL_623;
                }
                v351 = "invalid";
                if (v133 && *(void *)(v133 + 16)) {
                  v351 = *(const char **)(v133 + 16);
                }
                *(_DWORD *)os_log_type_t type = 136446466;
                *(void *)&type[4] = "nw_http3_encoder_stream_finalize_output_frames";
                *(_WORD *)&type[12] = 2082;
                *(void *)&type[14] = v351;
                v303 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback, backtrace limit exceeded";
                goto LABEL_618;
              }
              v325 = (char *)__nw_create_backtrace_string();
              v322 = __nwlog_obj();
              os_log_type_t v323 = v397[0];
              BOOL v326 = os_log_type_enabled(v322, v397[0]);
              if (!v325)
              {
                if (!v326) {
                  goto LABEL_623;
                }
                v352 = "invalid";
                if (v133 && *(void *)(v133 + 16)) {
                  v352 = *(const char **)(v133 + 16);
                }
                *(_DWORD *)os_log_type_t type = 136446466;
                *(void *)&type[4] = "nw_http3_encoder_stream_finalize_output_frames";
                *(_WORD *)&type[12] = 2082;
                *(void *)&type[14] = v352;
                v303 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback, no backtrace";
                goto LABEL_618;
              }
              if (v326)
              {
                v327 = "invalid";
                if (v133 && *(void *)(v133 + 16)) {
                  v327 = *(const char **)(v133 + 16);
                }
                *(_DWORD *)os_log_type_t type = 136446722;
                *(void *)&type[4] = "nw_http3_encoder_stream_finalize_output_frames";
                *(_WORD *)&type[12] = 2082;
                *(void *)&type[14] = v327;
                *(_WORD *)&type[22] = 2082;
                v406 = (__n128 (*)(uint64_t, uint64_t))v325;
                _os_log_impl(&dword_1830D4000, v322, v323, "%{public}s protocol %{public}s has invalid finalize_output_frames callback, dumping backtrace:%{public}s", type, 0x20u);
              }
              free(v325);
LABEL_623:
              if (!v300) {
                goto LABEL_220;
              }
LABEL_624:
              free(v300);
              goto LABEL_220;
            }
            __nwlog_obj();
            *(_DWORD *)os_log_type_t type = 136446210;
            *(void *)&type[4] = "nw_http3_encoder_stream_finalize_output_frames";
            v300 = (char *)_os_log_send_and_compose_impl();
            v397[0] = OS_LOG_TYPE_ERROR;
            LOBYTE(v396[0]) = 0;
            if (!__nwlog_fault(v300, v397, v396)) {
              goto LABEL_623;
            }
            if (v397[0] == OS_LOG_TYPE_FAULT)
            {
              v301 = __nwlog_obj();
              os_log_type_t v302 = v397[0];
              if (!os_log_type_enabled(v301, v397[0])) {
                goto LABEL_623;
              }
              *(_DWORD *)os_log_type_t type = 136446210;
              *(void *)&type[4] = "nw_http3_encoder_stream_finalize_output_frames";
              v303 = "%{public}s called with null http3";
            }
            else if (LOBYTE(v396[0]))
            {
              v317 = (char *)__nw_create_backtrace_string();
              v301 = __nwlog_obj();
              os_log_type_t v302 = v397[0];
              BOOL v318 = os_log_type_enabled(v301, v397[0]);
              if (v317)
              {
                if (v318)
                {
                  *(_DWORD *)os_log_type_t type = 136446466;
                  *(void *)&type[4] = "nw_http3_encoder_stream_finalize_output_frames";
                  *(_WORD *)&type[12] = 2082;
                  *(void *)&type[14] = v317;
                  _os_log_impl(&dword_1830D4000, v301, v302, "%{public}s called with null http3, dumping backtrace:%{public}s", type, 0x16u);
                }
                free(v317);
                if (!v300) {
                  goto LABEL_220;
                }
                goto LABEL_624;
              }
              if (!v318) {
                goto LABEL_623;
              }
              *(_DWORD *)os_log_type_t type = 136446210;
              *(void *)&type[4] = "nw_http3_encoder_stream_finalize_output_frames";
              v303 = "%{public}s called with null http3, no backtrace";
            }
            else
            {
              v301 = __nwlog_obj();
              os_log_type_t v302 = v397[0];
              if (!os_log_type_enabled(v301, v397[0])) {
                goto LABEL_623;
              }
              *(_DWORD *)os_log_type_t type = 136446210;
              *(void *)&type[4] = "nw_http3_encoder_stream_finalize_output_frames";
              v303 = "%{public}s called with null http3, backtrace limit exceeded";
            }
            v353 = v301;
            os_log_type_t v354 = v302;
            uint32_t v355 = 12;
            goto LABEL_622;
          }
LABEL_305:
          os_release(v19);
          goto LABEL_306;
        }
      }
    }
    __nwlog_obj();
    uint64_t v184 = *(void *)(a1 + 48);
    v185 = "invalid";
    if (v184)
    {
      v186 = *(const char **)(v184 + 16);
      if (v186) {
        v185 = v186;
      }
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v185;
    v187 = (void *)_os_log_send_and_compose_impl();
    type[0] = 16;
    LOBYTE(v401) = 0;
    if (!__nwlog_fault((const char *)v187, type, &v401))
    {
LABEL_400:
      if (v187) {
        free(v187);
      }
      uint64_t v129 = *(void *)(a1 + 48);
      if (!v129) {
        goto LABEL_403;
      }
      goto LABEL_201;
    }
    if (type[0] == 17)
    {
      v188 = __nwlog_obj();
      os_log_type_t v189 = type[0];
      if (os_log_type_enabled(v188, (os_log_type_t)type[0]))
      {
        uint64_t v190 = *(void *)(a1 + 48);
        v191 = "invalid";
        if (v190)
        {
          v192 = *(const char **)(v190 + 16);
          if (v192) {
            v191 = v192;
          }
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v191;
        _os_log_impl(&dword_1830D4000, v188, v189, "%{public}s protocol %{public}s has invalid error callback", buf, 0x16u);
      }
      goto LABEL_400;
    }
    id v193 = v17;
    if ((_BYTE)v401)
    {
      v194 = (char *)__nw_create_backtrace_string();
      v195 = __nwlog_obj();
      os_log_type_t v196 = type[0];
      BOOL v197 = os_log_type_enabled(v195, (os_log_type_t)type[0]);
      if (v194)
      {
        if (v197)
        {
          uint64_t v198 = *(void *)(a1 + 48);
          v199 = "invalid";
          if (v198)
          {
            v200 = *(const char **)(v198 + 16);
            if (v200) {
              v199 = v200;
            }
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v199;
          *(_WORD *)&buf[22] = 2082;
          v415 = (__n128 (*)(uint64_t, uint64_t))v194;
          _os_log_impl(&dword_1830D4000, v195, v196, "%{public}s protocol %{public}s has invalid error callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v194);
        goto LABEL_399;
      }
      id v17 = v193;
      if (!v197) {
        goto LABEL_400;
      }
      uint64_t v251 = *(void *)(a1 + 48);
      v252 = "invalid";
      if (v251)
      {
        v253 = *(const char **)(v251 + 16);
        if (v253) {
          v252 = v253;
        }
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v252;
      v212 = "%{public}s protocol %{public}s has invalid error callback, no backtrace";
    }
    else
    {
      v195 = __nwlog_obj();
      os_log_type_t v196 = type[0];
      if (!os_log_type_enabled(v195, (os_log_type_t)type[0])) {
        goto LABEL_400;
      }
      uint64_t v209 = *(void *)(a1 + 48);
      v210 = "invalid";
      if (v209)
      {
        v211 = *(const char **)(v209 + 16);
        if (v211) {
          v210 = v211;
        }
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v210;
      v212 = "%{public}s protocol %{public}s has invalid error callback, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v195, v196, v212, buf, 0x16u);
LABEL_399:
    id v17 = v193;
    goto LABEL_400;
  }
  if ((v4 & 1) == 0)
  {
    uint64_t v12 = __nwlog_obj();
    BOOL result = os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG);
    if (!result) {
      return result;
    }
    int v14 = *(_DWORD *)(*(void *)(a1 + 336) + 1280);
    unint64_t v15 = *(void **)(a1 + 240);
    int v16 = *(_DWORD *)(a1 + 368);
    *(_DWORD *)buf = 136447490;
    *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = a1 + 636;
    *(_WORD *)&buf[22] = 2080;
    v415 = (__n128 (*)(uint64_t, uint64_t))" ";
    LOWORD(v416) = 1024;
    *(_DWORD *)((char *)&v416 + 2) = v14;
    HIWORD(v416) = 2048;
    v417 = v15;
    *(_WORD *)v418 = 1024;
    *(_DWORD *)&v418[2] = v16;
    _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called, state %u - already sending headers", buf, 0x36u);
  }
  return 0;
}

uint64_t ___ZL27nw_http3_stream_send_fieldsP24nw_protocol_http3_streamb_block_invoke(uint64_t result, char *__s1)
{
  uint64_t v2 = result;
  if (__s1)
  {
    BOOL result = strcmp(__s1, "?1");
    __int16 v3 = (result == 0) << 14;
  }
  else
  {
    __int16 v3 = 0;
  }
  uint64_t v4 = *(void *)(v2 + 32);
  int v5 = *(unsigned __int16 *)(v4 + 736);
  unsigned int v6 = v5 & 0xFFFFBFFF | (*(unsigned __int8 *)(v4 + 738) << 16);
  *(_WORD *)(v4 + 736) = v5 & 0xBFFF | v3;
  *(unsigned char *)(v4 + 738) = BYTE2(v6);
  return result;
}

uint64_t ___ZL27nw_http3_stream_send_fieldsP24nw_protocol_http3_streamb_block_invoke_2(uint64_t result, char *__s1)
{
  uint64_t v2 = result;
  if (__s1)
  {
    BOOL result = strcmp(__s1, "connect-udp");
    if (result)
    {
      BOOL result = strcmp(__s1, "connect-ip");
      BOOL v4 = result == 0;
    }
    else
    {
      BOOL v4 = 1;
    }
  }
  else
  {
    BOOL v4 = 0;
  }
  *(unsigned char *)(*(void *)(*(void *)(v2 + 32) + 8) + 24) = v4;
  return result;
}

void ___ZL32nw_http3_stream_serialize_fieldsP24nw_protocol_http3_streamP20nw_protocol_metadata_block_invoke(void *a1, char *a2, unint64_t a3, unint64_t a4, int a5)
{
  uint64_t v9 = a1;
  uint64_t v329 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = a1[14];
  if (!v10 || (*(_WORD *)(v10 + 736) & 0x800) == 0)
  {
    if (gLogDatapath)
    {
      v258 = __nwlog_obj();
      if (os_log_type_enabled(v258, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v259 = v9[14];
        uint64_t v260 = (const char *)(v259 + 636);
        v261 = "";
        BOOL v262 = v259 == 0;
        if (!v259) {
          uint64_t v260 = "";
        }
        int v263 = *(_DWORD *)(*(void *)(v259 + 336) + 1280);
        uint64_t v264 = *(void *)(v259 + 240);
        if (!v262) {
          v261 = " ";
        }
        *(_DWORD *)buf = 136447746;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_serialize_fields_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v260;
        __int16 v319 = 2080;
        v320 = v261;
        __int16 v321 = 1024;
        int v322 = v263;
        __int16 v323 = 2048;
        uint64_t v324 = v264;
        __int16 v325 = 1040;
        int v326 = a3;
        __int16 v327 = 2080;
        uint64_t v328 = a2;
        _os_log_impl(&dword_1830D4000, v258, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> encoding %.*s", buf, 0x40u);
      }
    }
  }
  if (a4 + a3 >= 0x10000)
  {
    uint64_t v11 = v9[14];
    if (!v11 || (*(_WORD *)(v11 + 736) & 0x800) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v12 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        uint64_t v13 = v9[14];
        int v14 = (const char *)(v13 + 636);
        unint64_t v15 = "";
        BOOL v16 = v13 == 0;
        if (!v13) {
          int v14 = "";
        }
        int v17 = *(_DWORD *)(*(void *)(v13 + 336) + 1280);
        uint64_t v18 = *(void *)(v13 + 240);
        if (!v16) {
          unint64_t v15 = " ";
        }
        *(_DWORD *)buf = 136447746;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_serialize_fields_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v14;
        __int16 v319 = 2080;
        v320 = v15;
        __int16 v321 = 1024;
        int v322 = v17;
        __int16 v323 = 2048;
        uint64_t v324 = v18;
        __int16 v325 = 1040;
        int v326 = a3;
        __int16 v327 = 2080;
        uint64_t v328 = a2;
        _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%llu> dropping oversized field %.*s", buf, 0x40u);
      }
    }
    return;
  }
  if (a3 >= 0x10000) {
    __assert_rtn("lsxpack_header_set_offset2", "lsxpack_header.h", 120, "name_len <= LSXPACK_MAX_STRLEN");
  }
  if (a4 >= 0x10000) {
    __assert_rtn("lsxpack_header_set_offset2", "lsxpack_header.h", 124, "val_len <= LSXPACK_MAX_STRLEN");
  }
  if (a5 == 3) {
    unsigned int v19 = 2;
  }
  else {
    unsigned int v19 = a5 == 2;
  }
  id v20 = &a2[(int)a3];
  size_t v301 = (unsigned __int16)a4;
  unint64_t v21 = (unint64_t)&v20[(unsigned __int16)a4];
  uint64_t v275 = (unsigned __int8 *)(v20 + 1);
  unint64_t v299 = v21;
  if (v21 <= (unint64_t)(v20 + 1)) {
    unint64_t v21 = (unint64_t)(v20 + 1);
  }
  v289 = v9 + 4;
  v290 = v9 + 6;
  BOOL v286 = v9 + 7;
  uint64_t v287 = v9 + 9;
  int v285 = (unsigned __int16)a3 + 414139866;
  unint64_t v277 = a3 & 0xF;
  unint64_t v282 = v21 - (void)v20;
  uint64_t v311 = &a2[(int)a3];
  unint64_t v279 = (v21 - (void)v20) & 0xFFFFFFFFFFFFFFFELL;
  v274 = &v20[v279];
  char v270 = (16 * v19) | 0x50;
  char v266 = (16 * v19) | 0x5F;
  int v268 = (32 * ((v19 >> 1) & 1)) | 0x40;
  int v265 = (32 * ((v19 >> 1) & 1)) | 0x4F;
  unsigned int v280 = v19;
  char v271 = (4 * v19) & 8;
  char v267 = (4 * v19) | 7;
  int v269 = (16 * ((v19 >> 1) & 1)) | 0x20;
  if ((_WORD)a3) {
    BOOL v22 = a2;
  }
  else {
    BOOL v22 = 0;
  }
  size_t __n = (unsigned __int16)a3;
  v273 = (unsigned __int8 *)(v22 + 1);
  if (&v22[(unsigned __int16)a3] <= v22 + 1) {
    os_log_type_t v23 = v22 + 1;
  }
  else {
    os_log_type_t v23 = &v22[(unsigned __int16)a3];
  }
  size_t v302 = (unsigned __int16)a4;
  int v284 = (unsigned __int16)a4 + (unsigned __int16)a3;
  unint64_t v283 = (v284 + 32);
  size_t v307 = (unsigned __int16)a3;
  unint64_t v276 = (unsigned __int16)a3 + 32;
  v312 = &v22[(unsigned __int16)a3];
  unint64_t v281 = v23 - v22;
  v316 = v22;
  unint64_t v278 = (v23 - v22) & 0xFFFFFFFFFFFFFFFELL;
  v272 = &v22[v278];
  v300 = v9;
  while (2)
  {
    uint64_t v24 = *(void *)(*(void *)(v9[4] + 8) + 24);
    uint64_t v25 = *(void *)(*(void *)(v9[5] + 8) + 24);
    uint64_t v26 = *(void *)(*(void *)(v9[6] + 8) + 24);
    uint64_t v27 = *(void *)(*(void *)(v9[7] + 8) + 24);
    uint64_t v28 = *(void *)(*(void *)(v9[8] + 8) + 24);
    uint64_t v29 = *(void *)(*(void *)(v9[9] + 8) + 24);
    uint64_t v30 = v9[15];
    uint64_t v31 = v9[11];
    uint64_t v32 = *(void *)(*(void *)(v9[10] + 8) + 24);
    uint64_t v33 = *(void *)(*(void *)(v31 + 8) + 24);
    *(void *)buf = 0;
    *(void *)&buf[8] = 0;
    os_log_type_t v34 = *(FILE **)(v30 + 200);
    if (v34)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v34);
      fputc(10, *(FILE **)(v30 + 200));
    }
    uint64_t v35 = v25 + v24;
    if (v35 == v26) {
      goto LABEL_32;
    }
    uint64_t v303 = v30;
    unsigned int v42 = 414139866;
    if (v316)
    {
      unint64_t v43 = __n;
      unsigned int v42 = v285;
      uint64_t v44 = v316;
      if (v307 >= 0x10)
      {
        int v45 = 1679910008;
        int v46 = 39378473;
        int v47 = -2008766304;
        int v48 = 645669457;
        uint64_t v44 = v316;
        do
        {
          HIDWORD(v49) = v48 - 2048144777 * *(_DWORD *)v44;
          LODWORD(v49) = HIDWORD(v49);
          int v48 = -1640531535 * (v49 >> 19);
          HIDWORD(v49) = v47 - 2048144777 * *((_DWORD *)v44 + 1);
          LODWORD(v49) = HIDWORD(v49);
          int v47 = -1640531535 * (v49 >> 19);
          HIDWORD(v49) = v46 - 2048144777 * *((_DWORD *)v44 + 2);
          LODWORD(v49) = HIDWORD(v49);
          int v46 = -1640531535 * (v49 >> 19);
          HIDWORD(v49) = v45 - 2048144777 * *((_DWORD *)v44 + 3);
          LODWORD(v49) = HIDWORD(v49);
          int v45 = -1640531535 * (v49 >> 19);
          v44 += 16;
        }
        while (v44 < v312 - 15);
        HIDWORD(v51) = v48;
        LODWORD(v51) = v48;
        int v50 = v51 >> 31;
        HIDWORD(v51) = v47;
        LODWORD(v51) = v47;
        int v52 = v51 >> 25;
        HIDWORD(v51) = v46;
        LODWORD(v51) = v46;
        int v53 = v51 >> 20;
        HIDWORD(v51) = v45;
        LODWORD(v51) = v45;
        unsigned int v42 = v50 + v307 + v52 + v53 + (v51 >> 14);
        unint64_t v43 = v277;
      }
      if (v43 >= 4)
      {
        do
        {
          int v54 = *(_DWORD *)v44;
          v44 += 4;
          HIDWORD(v55) = v42 - 1028477379 * v54;
          LODWORD(v55) = HIDWORD(v55);
          unsigned int v42 = 668265263 * (v55 >> 15);
          v43 -= 4;
        }
        while (v43 > 3);
      }
      for (; v43; --v43)
      {
        int v56 = *v44++;
        HIDWORD(v57) = v42 + 374761393 * v56;
        LODWORD(v57) = HIDWORD(v57);
        unsigned int v42 = -1640531535 * (v57 >> 21);
      }
    }
    uint64_t v58 = v32;
    uint64_t v59 = v27;
    unsigned int v60 = -1028477379 * ((-2048144777 * (v42 ^ (v42 >> 15))) ^ ((-2048144777 * (v42 ^ (v42 >> 15))) >> 13));
    int v61 = v60 ^ HIWORD(v60);
    int v62 = XXH_INLINE_XXH32((int *)v311, v301, v61);
    id v63 = *(FILE **)(v303 + 200);
    if (v63)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v63);
      fprintf(*(FILE **)(v303 + 200), "name hash: 0x%X; nameval hash: 0x%X", v61, v62);
      fputc(10, *(FILE **)(v303 + 200));
    }
    int v314 = v61;
    int64_t v297 = v28 + v59 - v29;
    v298 = (unsigned char *)(v58 + v29 - v59);
    v306 = &v298[v297];
    int64_t v292 = v35 - v26;
    v293 = (unsigned char *)(v33 + v26 - v24);
    unint64_t v291 = v33 - v24 + v35;
    size_t v64 = v307;
    size_t v65 = v302;
    size_t v66 = __n;
    if (nameval2id_plus_one[v62 & 0x1FF])
    {
      unsigned int v67 = nameval2id_plus_one[v62 & 0x1FF] - 1;
      uint64_t v68 = &(&static_table)[3 * v67];
      if (*((_DWORD *)v68 + 4) == v307
        && *((_DWORD *)&static_table + 6 * v67 + 5) == v302
        && !memcmp(*v68, v316, __n)
        && !memcmp((&static_table)[3 * v67 + 1], v311, v301))
      {
        uint64_t v309 = 0;
        BOOL v288 = 0;
        int v308 = 0;
        unsigned int v310 = 0;
        BOOL v73 = 0;
        int v82 = 0;
        uint64_t v83 = 0;
        uint64_t v84 = 0;
        uint64_t v80 = 0;
        unsigned int v85 = v67;
        uint64_t v86 = 1;
        unint64_t v71 = v299;
        uint64_t v9 = v300;
        unint64_t v72 = (unint64_t)v312;
        uint64_t v69 = v303;
        goto LABEL_202;
      }
    }
    uint64_t v69 = v303;
    uint64_t v9 = v300;
    if (*(_DWORD *)(v303 + 28))
    {
      uint64_t v70 = *(void *)(v303 + 128);
      unint64_t v71 = v299;
      unint64_t v72 = (unint64_t)v312;
      if (!v70)
      {
        BOOL v76 = 0;
        BOOL v73 = 0;
LABEL_62:
        int v77 = v61;
        goto LABEL_63;
      }
      BOOL v73 = 0;
      unsigned int v74 = *(_DWORD *)(v70 + 52);
      unsigned int v75 = *(_DWORD *)(v303 + 20) >> 1;
      BOOL v76 = v74 < v75;
      if (v280) {
        goto LABEL_62;
      }
      int v77 = v61;
      if (v74 < v75)
      {
        BOOL v73 = *(_DWORD *)v303 != -1;
        BOOL v76 = 1;
      }
    }
    else
    {
      BOOL v76 = 0;
      BOOL v73 = 0;
      unint64_t v71 = v299;
      unint64_t v72 = (unint64_t)v312;
      int v77 = v61;
    }
LABEL_63:
    int v308 = v76;
    if (*(void *)(v303 + 136) || *(_DWORD *)(v303 + 40) < *(_DWORD *)(v303 + 36))
    {
      BOOL v78 = 1;
    }
    else
    {
      uint64_t v81 = *(void *)(v303 + 128);
      if (!v81)
      {
        unsigned int v310 = 0;
        goto LABEL_67;
      }
      BOOL v78 = *(_DWORD *)(v81 + 60) > *(_DWORD *)(v303 + 4);
    }
    unsigned int v310 = v78;
LABEL_67:
    uint64_t v309 = 0;
    unsigned int v79 = 0;
    uint64_t v80 = 0;
    BOOL v288 = *(void *)(v303 + 216) != 0;
    while (1)
    {
      unsigned int v304 = v79;
      if (!v308) {
        goto LABEL_105;
      }
      uint64_t v80 = *(uint64_t **)(*(void *)(v69 + 72) + 32 * (v62 & ~(-1 << *(_DWORD *)(v69 + 52))) + 16);
      if (!v80)
      {
        uint64_t v309 = 0;
        uint64_t v80 = 0;
        goto LABEL_105;
      }
      uint64_t v309 = 0;
      do
      {
        if (v62 == *((_DWORD *)v80 + 10)
          && *((_DWORD *)v80 + 12) == v64
          && *((_DWORD *)v80 + 13) == v65)
        {
          if (memcmp(v316, v80 + 7, v66) || memcmp(v311, (char *)v80 + v66 + 56, v301))
          {
            unint64_t v72 = (unint64_t)v312;
            int v77 = v314;
            goto LABEL_76;
          }
          *(void *)&buf[8 * v309] = v80;
          unint64_t v72 = (unint64_t)v312;
          int v77 = v314;
          if (!v309)
          {
            uint64_t v309 = 1;
            goto LABEL_76;
          }
          unsigned int v85 = *(_DWORD *)(*(void *)&buf[8] + 24);
          unsigned int v125 = *(_DWORD *)(*(void *)buf + 24);
          if (v85 <= v125) {
            __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 1767, "candidates[1]->ete_id > candidates[0]->ete_id");
          }
          uint64_t v309 = 2;
          if (v310)
          {
            uint64_t v83 = 0;
            int v82 = 2;
            int v308 = 1;
            unsigned int v310 = 1;
LABEL_201:
            uint64_t v86 = 2;
            uint64_t v84 = 0;
            uint64_t v80 = *(uint64_t **)&buf[8];
            goto LABEL_202;
          }
          unsigned int v130 = *(_DWORD *)(v69 + 4);
          uint64_t v309 = 2;
          if (v85 <= v130)
          {
            uint64_t v83 = 0;
            int v82 = 2;
            unsigned int v310 = 0;
            int v308 = 1;
            goto LABEL_201;
          }
          if (v125 <= v130)
          {
            uint64_t v309 = 2;
            if ((*(_DWORD *)(*(void *)buf + 32)
                              + *(_DWORD *)(*(void *)buf + 28)
                              + *(_DWORD *)(v69 + 20)
                              - (*(_DWORD *)(v69 + 32)
                               + *(_DWORD *)(v69 + 16))) >= *(_DWORD *)(v69 + 20) >> 2)
            {
              uint64_t v83 = 0;
              int v82 = 2;
              unsigned int v310 = 0;
              unsigned int v85 = *(_DWORD *)(*(void *)buf + 24);
              int v308 = 1;
              uint64_t v86 = 2;
              uint64_t v84 = 0;
              uint64_t v80 = *(uint64_t **)buf;
              goto LABEL_202;
            }
          }
          else
          {
            uint64_t v93 = 2;
LABEL_103:
            uint64_t v309 = v93;
          }
LABEL_105:
          if (name2id_plus_one[v77 & 0x1FF])
          {
            unsigned int v94 = name2id_plus_one[v77 & 0x1FF] - 1;
            if (LODWORD((&static_table)[3 * v94 + 2]) == v64)
            {
              int v95 = memcmp((&static_table)[3 * v94], v316, v66);
              unint64_t v72 = (unint64_t)v312;
              int v77 = v314;
              if (!v95)
              {
                if (v73)
                {
                  BOOL v73 = 1;
                  if (qenc_has_or_can_evict_at_least(v69, v283))
                  {
                    uint64_t v111 = *(void *)(v69 + 216);
                    BOOL v112 = 1;
                    unint64_t v72 = (unint64_t)v312;
                    unsigned int v85 = v94;
                    if (v111)
                    {
                      uint64_t v113 = 228;
                      if (!*(_DWORD *)(v69 + 232)) {
                        uint64_t v113 = 224;
                      }
                      unint64_t v114 = v111 + 8 * *(unsigned int *)(v69 + v113);
                      *(_DWORD *)(v114 + 4) = v62;
                      unint64_t v115 = v111 - 8;
                      do
                      {
                        int v116 = *(_DWORD *)(v115 + 12);
                        v115 += 8;
                      }
                      while (v116 != v62);
                      BOOL v112 = v115 < v114;
                    }
                    if (v308) {
                      BOOL v117 = v309 == 0;
                    }
                    else {
                      BOOL v117 = 1;
                    }
                    unsigned int v118 = !v117;
                    int v119 = (unsigned int *)((char *)&lsqpack_enc_encode_programs + 64 * v112 + 32 * v310 + 16 * v118);
                    uint64_t v84 = *v119;
                    uint64_t v86 = v119[1];
                    uint64_t v83 = v119[2];
                    int v82 = v119[3];
                    BOOL v73 = 1;
                  }
                  else
                  {
                    int v82 = 0;
                    uint64_t v86 = 3;
                    uint64_t v84 = 0;
                    unint64_t v72 = (unint64_t)v312;
                    unsigned int v85 = v94;
                    uint64_t v83 = 0;
                  }
                }
                else
                {
                  unsigned int v85 = v94;
                  uint64_t v83 = 0;
                  int v82 = 0;
                  BOOL v73 = 0;
                  uint64_t v86 = 3;
                  uint64_t v84 = 0;
                }
                goto LABEL_202;
              }
            }
          }
          int v96 = -1;
          if (v308)
          {
            uint64_t v80 = 0;
            uint64_t v97 = *(void *)(v69 + 72);
            if (*(void *)(v97 + 32 * (v77 & ~(-1 << *(_DWORD *)(v69 + 52)))))
            {
              uint64_t v80 = *(uint64_t **)(v97 + 32 * (v77 & ~(-1 << *(_DWORD *)(v69 + 52))));
              do
              {
                if (v77 != *((_DWORD *)v80 + 11)
                  || (*((_DWORD *)v80 + 8)
                                  + *((_DWORD *)v80 + 7)
                                  + *(_DWORD *)(v69 + 20)
                                  - (*(_DWORD *)(v69 + 32)
                                   + *(_DWORD *)(v69 + 16))) < *(_DWORD *)(v69 + 20) >> 2
                  || *((_DWORD *)v80 + 12) != v64
                  || !v310 && *((_DWORD *)v80 + 6) > *(_DWORD *)(v69 + 4))
                {
                  goto LABEL_115;
                }
                if (!v73) {
                  goto LABEL_113;
                }
                if (v96 < 0)
                {
                  if (qenc_has_or_can_evict_at_least(v69, v283)) {
                    goto LABEL_112;
                  }
                  int v96 = 0;
                }
                else if (v96)
                {
LABEL_112:
                  int v96 = 1;
LABEL_113:
                  if (!memcmp(v316, v80 + 7, v66))
                  {
                    unsigned int v85 = *((_DWORD *)v80 + 6);
                    unint64_t v72 = (unint64_t)v312;
                    if (!v310 || !v73 || !v96) {
                      goto LABEL_185;
                    }
                    uint64_t v120 = *(void *)(v69 + 216);
                    int v82 = 6;
                    uint64_t v83 = 1;
                    if (v120)
                    {
                      uint64_t v121 = 228;
                      if (!*(_DWORD *)(v69 + 232)) {
                        uint64_t v121 = 224;
                      }
                      unint64_t v122 = v120 + 8 * *(unsigned int *)(v69 + v121);
                      *(_DWORD *)(v122 + 4) = v62;
                      unint64_t v123 = v120 - 8;
                      do
                      {
                        int v124 = *(_DWORD *)(v123 + 12);
                        v123 += 8;
                      }
                      while (v124 != v62);
                      int v82 = 6;
                      uint64_t v83 = 1;
                      int v308 = 1;
                      if (v123 < v122)
                      {
                        uint64_t v86 = 0;
                        goto LABEL_190;
                      }
LABEL_185:
                      uint64_t v83 = 0;
                      uint64_t v84 = 0;
                      int v82 = 2;
                      int v308 = 1;
                      uint64_t v86 = 4;
                      unint64_t v71 = v299;
                    }
                    else
                    {
                      uint64_t v86 = 0;
                      int v308 = 1;
LABEL_190:
                      unsigned int v310 = 1;
                      BOOL v73 = 1;
                      uint64_t v84 = 3;
                      unint64_t v71 = v299;
                    }
                    goto LABEL_202;
                  }
                }
                unint64_t v72 = (unint64_t)v312;
                int v77 = v314;
LABEL_115:
                uint64_t v80 = (uint64_t *)v80[1];
              }
              while (v80);
            }
          }
          if (!v73)
          {
            uint64_t v83 = 0;
            int v82 = 0;
            unsigned int v85 = v304;
            BOOL v73 = 0;
            uint64_t v86 = 6;
            uint64_t v84 = 0;
            unint64_t v71 = v299;
            goto LABEL_202;
          }
          uint64_t v98 = *(void *)(v69 + 216);
          if (!v98) {
            goto LABEL_133;
          }
          uint64_t v99 = 228;
          if (!*(_DWORD *)(v69 + 232)) {
            uint64_t v99 = 224;
          }
          unint64_t v100 = v98 + 8 * *(unsigned int *)(v69 + v99);
          *(_DWORD *)(v100 + 4) = v62;
          unint64_t v101 = v98 - 8;
          do
          {
            int v102 = *(_DWORD *)(v101 + 12);
            v101 += 8;
          }
          while (v102 != v62);
          if (v101 < v100)
          {
LABEL_133:
            if (v96 < 0)
            {
              int can_evict_at_least = qenc_has_or_can_evict_at_least(v69, v283);
              unint64_t v72 = (unint64_t)v312;
              int v77 = v314;
              if (!can_evict_at_least)
              {
                uint64_t v98 = *(void *)(v69 + 216);
                unint64_t v71 = v299;
                if (v98)
                {
LABEL_136:
                  uint64_t v103 = 228;
                  if (!*(_DWORD *)(v69 + 232)) {
                    uint64_t v103 = 224;
                  }
                  uint64_t v104 = (int *)(v98 + 8 * *(unsigned int *)(v69 + v103));
                  *uint64_t v104 = v77;
                  unint64_t v105 = v98 - 8;
                  do
                  {
                    int v106 = *(_DWORD *)(v105 + 8);
                    v105 += 8;
                  }
                  while (v106 != v77);
                  BOOL v73 = 1;
                  if (v105 >= (unint64_t)v104)
                  {
                    uint64_t v83 = 0;
                    int v82 = 0;
                    unsigned int v85 = v304;
                    uint64_t v86 = 6;
                    uint64_t v84 = 0;
                    goto LABEL_202;
                  }
                }
LABEL_141:
                BOOL v73 = 1;
                if (!qenc_has_or_can_evict_at_least(v69, v276))
                {
                  int v82 = 0;
                  unsigned int v85 = v304;
                  uint64_t v86 = 6;
                  uint64_t v84 = 0;
                  unint64_t v72 = (unint64_t)v312;
                  uint64_t v83 = 0;
                  goto LABEL_202;
                }
                v107 = (unsigned int *)((char *)&lsqpack_enc_encode_programs_21 + 16 * v310);
                uint64_t v83 = 2;
                uint64_t v84 = 5;
                unint64_t v72 = (unint64_t)v312;
LABEL_152:
                uint64_t v86 = v107[1];
                int v82 = v107[3];
                BOOL v73 = 1;
                unsigned int v85 = v304;
                goto LABEL_202;
              }
            }
            else if (!v96)
            {
              goto LABEL_135;
            }
            if (v308) {
              BOOL v109 = v309 == 0;
            }
            else {
              BOOL v109 = 1;
            }
            unsigned int v110 = !v109;
            v107 = (unsigned int *)((char *)&lsqpack_enc_encode_programs_20 + 32 * v310 + 16 * v110);
            uint64_t v84 = *v107;
            uint64_t v83 = v107[2];
            unint64_t v71 = v299;
            goto LABEL_152;
          }
LABEL_135:
          unint64_t v71 = v299;
          if (v98) {
            goto LABEL_136;
          }
          goto LABEL_141;
        }
LABEL_76:
        uint64_t v80 = (uint64_t *)*v80;
      }
      while (v80);
      if (v309 != 1) {
        goto LABEL_105;
      }
      uint64_t v80 = *(uint64_t **)buf;
      unsigned int v87 = *(_DWORD *)(*(void *)buf + 24);
      unsigned int v304 = v87;
      if (v310)
      {
        if (!v73) {
          goto LABEL_104;
        }
      }
      else
      {
        unsigned int v88 = *(_DWORD *)(v69 + 4);
        if (v87 > v88 || !v73) {
          goto LABEL_101;
        }
      }
      if ((*(unsigned char *)(v69 + 12) & 2) == 0
        || (unint64_t v90 = (*(_DWORD *)(*(void *)buf + 48) + *(_DWORD *)(*(void *)buf + 52) + 32),
            float v91 = (float)*(unsigned int *)(v69 + 20),
            (float)((float)(v90 + *(_DWORD *)(v69 + 16)) / v91) < 0.8)
        || (float)((float)(*(_DWORD *)(*(void *)buf + 28)
                                       - *(_DWORD *)(v69 + 32)
                                       + *(_DWORD *)(*(void *)buf + 32))
                 / v91) >= 0.2
        || (v92 = qenc_has_or_can_evict_at_least(v69, v90), unint64_t v72 = (unint64_t)v312, v77 = v314, !v92))
      {
        if (v310) {
          goto LABEL_104;
        }
        unsigned int v87 = *((_DWORD *)v80 + 6);
        unsigned int v88 = *(_DWORD *)(v69 + 4);
LABEL_101:
        if (v87 <= v88)
        {
LABEL_104:
          int v82 = 2;
          uint64_t v309 = 1;
          if ((*((_DWORD *)v80 + 8)
                            + *((_DWORD *)v80 + 7)
                            + *(_DWORD *)(v69 + 20)
                            - (*(_DWORD *)(v69 + 32)
                             + *(_DWORD *)(v69 + 16))) >= *(_DWORD *)(v69 + 20) >> 2)
          {
            uint64_t v83 = 0;
            unsigned int v85 = v304;
            int v308 = 1;
            uint64_t v84 = 0;
            uint64_t v86 = 2;
            goto LABEL_202;
          }
          goto LABEL_105;
        }
LABEL_102:
        uint64_t v93 = 1;
        goto LABEL_103;
      }
      int v82 = 6;
      uint64_t v309 = 1;
      if (v310)
      {
        unsigned int v85 = v304;
        int v308 = 1;
        unsigned int v310 = 1;
        uint64_t v83 = 1;
        uint64_t v84 = 1;
        uint64_t v86 = 0;
        goto LABEL_202;
      }
      int v127 = *(_DWORD *)(v69 + 16);
      unsigned int v126 = *(_DWORD *)(v69 + 20);
      if (*((_DWORD *)v80 + 8) + *((_DWORD *)v80 + 7) + v126 - (*(_DWORD *)(v69 + 32) + v127) < v126 >> 2) {
        goto LABEL_102;
      }
      unsigned int v128 = v127 + *((_DWORD *)v80 + 12) + *((_DWORD *)v80 + 13) + 32;
      uint64_t v86 = 2;
      int v308 = 1;
      if (v128 <= v126)
      {
        int v82 = 2;
        uint64_t v309 = 1;
        unsigned int v310 = 0;
        unsigned int v85 = v304;
      }
      else
      {
        uint64_t v129 = *(void *)(v69 + 56);
        uint64_t v86 = 2;
        if ((uint64_t *)v129 == v80)
        {
          uint64_t v83 = 0;
          int v82 = 2;
          uint64_t v309 = 1;
          int v308 = 1;
          unsigned int v310 = 0;
          unsigned int v85 = v304;
          uint64_t v84 = 0;
          goto LABEL_202;
        }
        while (1)
        {
          unsigned int v128 = v128 - (*(_DWORD *)(v129 + 48) + *(_DWORD *)(v129 + 52)) - 32;
          if (v128 <= v126) {
            break;
          }
          uint64_t v129 = *(void *)(v129 + 16);
          int v82 = 2;
          if ((uint64_t *)v129 == v80)
          {
            uint64_t v309 = 1;
            unsigned int v310 = 0;
            uint64_t v83 = 0;
            uint64_t v84 = 0;
            unsigned int v85 = v304;
            int v308 = 1;
            uint64_t v86 = 2;
            goto LABEL_202;
          }
        }
        unsigned int v310 = 0;
        uint64_t v86 = 2;
        uint64_t v309 = 1;
        unsigned int v85 = v304;
        int v308 = 1;
        int v82 = 2;
      }
      uint64_t v83 = 1;
      uint64_t v84 = 1;
LABEL_202:
      if (((1 << v84) & 0x3C) == 0 || ((1 << v86) & 0x78) == 0) {
        break;
      }
      unsigned int v131 = 0;
      if (v64)
      {
        unsigned int v131 = 0;
        uint64_t v132 = v316;
        if (v281 < 2) {
          goto LABEL_461;
        }
        int v133 = 0;
        int v134 = 0;
        v135 = v273;
        unint64_t v136 = v278;
        do
        {
          uint64_t v137 = *(v135 - 1);
          int v138 = *v135;
          v135 += 2;
          v133 += encode_table[2 * v137 + 1];
          v134 += encode_table[2 * v138 + 1];
          v136 -= 2;
        }
        while (v136);
        unsigned int v131 = v134 + v133;
        uint64_t v132 = v272;
        if (v281 != v278)
        {
LABEL_461:
          do
          {
            int v139 = *v132++;
            v131 += encode_table[2 * v139 + 1];
          }
          while ((unint64_t)v132 < v72);
        }
      }
      unsigned int v140 = 0;
      unsigned int v141 = v131 >> 3;
      BOOL v142 = (v131 & 7) != 0;
      if (v301)
      {
        unsigned int v140 = 0;
        unsigned int v143 = v311;
        if (v282 < 2) {
          goto LABEL_462;
        }
        int v144 = 0;
        int v145 = 0;
        int v146 = v275;
        unint64_t v147 = v279;
        do
        {
          uint64_t v148 = *(v146 - 1);
          int v149 = *v146;
          v146 += 2;
          v144 += encode_table[2 * v148 + 1];
          v145 += encode_table[2 * v149 + 1];
          v147 -= 2;
        }
        while (v147);
        unsigned int v140 = v145 + v144;
        unsigned int v143 = v274;
        if (v282 != v279)
        {
LABEL_462:
          do
          {
            int v150 = *v143++;
            v140 += encode_table[2 * v150 + 1];
          }
          while ((unint64_t)v143 < v71);
        }
      }
      unsigned int v151 = v141 + *(_DWORD *)(v69 + 196) + v142 + (v140 >> 3);
      if ((v140 & 7) != 0) {
        ++v151;
      }
      if ((float)((float)v151 / (float)(v284 + *(_DWORD *)(v69 + 192))) <= 0.95) {
        break;
      }
      if (!v73) {
        __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 1917, "index");
      }
      v152 = *(FILE **)(v69 + 200);
      if (v152)
      {
        unsigned int v153 = v85;
        fwrite("qenc: debug: ", 0xDuLL, 1uLL, v152);
        fwrite("double lit would result in ratio > 0.95, reset", 0x2EuLL, 1uLL, *(FILE **)(v69 + 200));
        fputc(10, *(FILE **)(v69 + 200));
        BOOL v73 = 0;
        unsigned int v79 = v153;
      }
      else
      {
        BOOL v73 = 0;
        unsigned int v79 = v85;
      }
LABEL_341:
      size_t v66 = __n;
      unint64_t v72 = (unint64_t)v312;
      int v77 = v314;
    }
    size_t v154 = v65;
    unint64_t v155 = v86;
    uint64_t v296 = v83;
    int v294 = v82;
    unsigned int v156 = *(FILE **)(v69 + 200);
    unsigned int v305 = v85;
    if (v156)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v156);
      fprintf(*(FILE **)(v69 + 200), "program: %s; %s; %s; flags: 0x%X",
        eea2str[v84],
        eha2str[v155],
        eta2str[v296],
        v294);
      fputc(10, *(FILE **)(v69 + 200));
      unsigned int v85 = v305;
    }
    switch(v84)
    {
      case 0:
        goto LABEL_247;
      case 1:
        if (v297 < 1) {
          goto LABEL_315;
        }
        unsigned char *v298 = 0;
        unint64_t v162 = *(_DWORD *)v69 - v85;
        if (v162 > 0x1E)
        {
          unsigned char *v298 = 31;
          uint64_t v184 = v298 + 1;
          unint64_t v185 = v162 - 31;
          if (v162 - 31 < 0x80)
          {
            v187 = v298;
            LOBYTE(v162) = v162 - 31;
          }
          else
          {
            do
            {
              if (v184 >= v306) {
                goto LABEL_315;
              }
              *v184++ = v185 | 0x80;
              unint64_t v162 = v185 >> 7;
              unint64_t v186 = v185 >> 14;
              v185 >>= 7;
            }
            while (v186);
            v187 = v184 - 1;
          }
          if (v184 >= v306) {
            goto LABEL_315;
          }
          v163 = v187 + 2;
          *uint64_t v184 = v162;
          if (v187 + 2 <= v298) {
            goto LABEL_315;
          }
        }
        else
        {
          unsigned char *v298 = *(unsigned char *)v69 - v85;
          v163 = v298 + 1;
        }
        uint64_t v84 = v163 - v298;
        if (v155 > 6) {
LABEL_446:
        }
          __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 2075, "prog.ep_hea_action == EHA_LIT_WITH_NAME_STAT");
        goto LABEL_247;
      case 2:
        if (v297 < 1) {
          goto LABEL_315;
        }
        unsigned char *v298 = -64;
        if (v85 <= 0x3E)
        {
          char v164 = v85 | 0xC0;
LABEL_243:
          unsigned char *v298 = v164;
          v166 = v298 + 1;
          goto LABEL_244;
        }
        unsigned char *v298 = -1;
        v188 = v298 + 1;
        unint64_t v189 = v85 - 63;
        if (v189 >= 0x80)
        {
          while (v188 < v306)
          {
            *v188++ = v189 | 0x80;
            unint64_t v190 = v189 >> 7;
            unint64_t v191 = v189 >> 14;
            v189 >>= 7;
            if (!v191) {
              goto LABEL_286;
            }
          }
LABEL_315:
          size_t v208 = *(void *)(*(void *)(v9[9] + 8) + 24);
          if (v208 < *(void *)(*(void *)(v9[8] + 8) + 24) + *(void *)(*(void *)(v9[7] + 8) + 24))
          {
            uint64_t v209 = *(NSObject **)(*(void *)(v9[12] + 8) + 24);
            *(void *)(*(void *)(v9[12] + 8) + 24) = dispatch_data_create_subrange(v209, 0, v208);
            if (v209) {
              dispatch_release(v209);
            }
          }
          *(void *)(*(void *)(v9[8] + 8) + 24) += 512;
          uint64_t alloc = dispatch_data_create_alloc();
          v210 = *(NSObject **)(*(void *)(v9[12] + 8) + 24);
          *(void *)(*(void *)(v9[12] + 8) + 24) = dispatch_data_create_concat(v210, alloc);
          if (v210) {
            dispatch_release(v210);
          }
          uint64_t v40 = v286;
          uint64_t v41 = v287;
          if (alloc) {
LABEL_27:
          }
            dispatch_release(alloc);
LABEL_28:
          *(void *)(*(void *)(*v40 + 8) + 24) = *(void *)(*(void *)(*v41 + 8) + 24);
          continue;
        }
LABEL_287:
        id v193 = v298;
        LOBYTE(v190) = v189;
LABEL_288:
        if (v188 >= v306) {
          goto LABEL_315;
        }
        v166 = v193 + 2;
        unsigned char *v188 = v190;
        if (v193 + 2 <= v298) {
          goto LABEL_315;
        }
LABEL_244:
        int v167 = lsqpack_enc_enc_str(7, v166, v306 - v166, (unsigned __int8 *)v311, v154);
        unsigned int v85 = v305;
        if (v167 < 0) {
          goto LABEL_315;
        }
        uint64_t v161 = &v166[v167];
LABEL_246:
        uint64_t v84 = v161 - v298;
LABEL_247:
        switch(v155)
        {
          case 0uLL:
            unsigned int v85 = *(_DWORD *)v69 + 1;
            int v168 = v314;
            v169 = v293;
            goto LABEL_255;
          case 1uLL:
            v169 = v293;
            unsigned char *v293 = -64;
            if (v292 <= 0) {
              goto LABEL_441;
            }
            if (v85 <= 0x3E)
            {
              unsigned char *v293 = v85 | 0xC0;
              uint64_t v170 = v293 + 1;
              int v168 = v314;
              goto LABEL_335;
            }
            unsigned char *v293 = -1;
            v194 = v293 + 1;
            unint64_t v195 = v85 - 63;
            int v168 = v314;
            unint64_t v171 = v291;
            if (v195 < 0x80) {
              goto LABEL_347;
            }
            while ((unint64_t)v194 < v291)
            {
              *v194++ = v195 | 0x80;
              unint64_t v196 = v195 >> 7;
              unint64_t v203 = v195 >> 14;
              v195 >>= 7;
              if (!v203) {
                goto LABEL_345;
              }
            }
            goto LABEL_32;
          case 2uLL:
            v169 = v293;
            if (v85 > *(_DWORD *)(v69 + 156))
            {
              int v168 = v314;
LABEL_255:
              unint64_t v171 = v291;
              unsigned char *v169 = 16;
              unsigned int v172 = *(_DWORD *)(v69 + 156);
              if (v85 <= v172) {
                __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 2008, "id > enc->qpe_cur_header.base_idx");
              }
              if (v292 <= 0) {
LABEL_441:
              }
                __assert_rtn("lsqpack_enc_int", "lsqpack.c", 759, "dst < end");
              uint64_t v173 = v85 + ~v172;
              if (v173 <= 0xE)
              {
                char v174 = (v85 + ~(_BYTE)v172) | 0x10;
LABEL_303:
                unsigned char *v169 = v174;
                uint64_t v170 = v169 + 1;
                goto LABEL_335;
              }
              unsigned char *v169 = 31;
              v194 = v169 + 1;
              unint64_t v195 = v173 - 15;
              if ((unint64_t)(v173 - 15) >= 0x80)
              {
                while ((unint64_t)v194 < v291)
                {
                  *v194++ = v195 | 0x80;
                  unint64_t v196 = v195 >> 7;
                  unint64_t v197 = v195 >> 14;
                  v195 >>= 7;
                  if (!v197) {
                    goto LABEL_345;
                  }
                }
                goto LABEL_32;
              }
              goto LABEL_347;
            }
            unsigned char *v293 = 0x80;
            unint64_t v171 = v291;
            int v168 = v314;
            if (v292 <= 0) {
              goto LABEL_441;
            }
            uint64_t v202 = *(_DWORD *)(v69 + 156) - v85;
            if (v202 <= 0x3E)
            {
              char v174 = (*(unsigned char *)(v69 + 156) - v85) | 0x80;
              goto LABEL_303;
            }
            unsigned char *v293 = -65;
            v194 = v293 + 1;
            unint64_t v195 = v202 - 63;
            if ((unint64_t)(v202 - 63) < 0x80)
            {
LABEL_347:
              v217 = v169;
              LOBYTE(v196) = v195;
              if ((unint64_t)v194 >= v171) {
                goto LABEL_32;
              }
              goto LABEL_348;
            }
            do
            {
              if ((unint64_t)v194 >= v291) {
                goto LABEL_32;
              }
              *v194++ = v195 | 0x80;
              unint64_t v196 = v195 >> 7;
              unint64_t v216 = v195 >> 14;
              v195 >>= 7;
            }
            while (v216);
LABEL_345:
            v217 = v194 - 1;
            if ((unint64_t)v194 >= v171) {
              goto LABEL_32;
            }
LABEL_348:
            uint64_t v170 = v217 + 2;
            unsigned char *v194 = v196;
            if (v217 + 2 <= v169) {
              goto LABEL_32;
            }
LABEL_335:
            if ((unint64_t)(v296 - 1) > 1)
            {
              if (v296) {
                __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 2117, "prog.ep_tab_action == ETA_NOOP");
              }
              uint64_t v313 = v170 - v169;
              os_log_type_t v218 = v298;
              if ((v294 & 2) != 0) {
                goto LABEL_367;
              }
              goto LABEL_373;
            }
            unsigned int v213 = v85;
            size_t v65 = v302;
            if (v296 == 1) {
              unsigned int v214 = v302;
            }
            else {
              unsigned int v214 = 0;
            }
            size_t v64 = v307;
            v215 = lsqpack_enc_push_entry(v69, v168, v62, v316, v307, v311, v214);
            if (!v215)
            {
              BOOL v73 = 0;
              unsigned int v79 = v213;
              unint64_t v71 = v299;
              uint64_t v9 = v300;
              goto LABEL_341;
            }
            uint64_t v313 = v170 - v169;
            uint64_t v219 = *(_DWORD **)(v69 + 128);
            v219[13] += v215[12] + v215[13] + 32;
            if ((v294 & 4) != 0)
            {
              ++v215[9];
              *(_DWORD *)(v69 + 152) |= 2u;
              unsigned int v220 = v219[15];
              unsigned int v221 = v215[6];
              os_log_type_t v218 = v298;
              if (!v220)
              {
                v219[14] = v221;
                v219[15] = v221;
                if ((v294 & 2) == 0) {
                  goto LABEL_373;
                }
                goto LABEL_367;
              }
              if (v221 <= v220) {
                __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 2111, "new_entry->ete_id > enc->qpe_cur_header.hinfo->qhi_max_id");
              }
              v219[15] = v221;
              if ((v294 & 2) != 0) {
                goto LABEL_367;
              }
            }
            else
            {
              os_log_type_t v218 = v298;
              if ((v294 & 2) == 0) {
                goto LABEL_373;
              }
LABEL_367:
              ++*((_DWORD *)v80 + 9);
              uint64_t v222 = *(void *)(v69 + 128);
              unsigned int v223 = *((_DWORD *)v80 + 6);
              unsigned int v224 = *(_DWORD *)(v222 + 60);
              if (!v224)
              {
                *(_DWORD *)(v222 + 60) = v223;
LABEL_372:
                *(_DWORD *)(v222 + 56) = v223;
                goto LABEL_373;
              }
              if (v224 < v223)
              {
                *(_DWORD *)(v222 + 60) = v223;
                goto LABEL_373;
              }
              if (*(_DWORD *)(v222 + 56) > v223) {
                goto LABEL_372;
              }
            }
LABEL_373:
            qenc_remove_overflow_entries(v69);
            if (v288)
            {
              uint64_t v225 = *(void *)(v69 + 216);
              if (!v225) {
                __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 2132, "enc->qpe_hist_els");
              }
              unsigned int v226 = *(_DWORD *)(v69 + 228);
              if (*(_DWORD *)(v69 + 144) < v226)
              {
LABEL_378:
                *(_DWORD *)(v225 + 8 * *(unsigned int *)(v69 + 224)) = v314;
                *(_DWORD *)(v225 + 8 * *(unsigned int *)(v69 + 224) + 4) = v62;
                unsigned int v227 = (*(_DWORD *)(v69 + 224) + 1) % *(_DWORD *)(v69 + 228);
                *(_DWORD *)(v69 + 224) = v227;
                *(_DWORD *)(v69 + 232) |= v227 == 0;
              }
              else
              {
                qenc_hist_update_size(v69, v226 + 4);
                if (*(_DWORD *)(v69 + 228))
                {
                  uint64_t v225 = *(void *)(v69 + 216);
                  goto LABEL_378;
                }
              }
              ++*(_DWORD *)(v69 + 144);
            }
            uint64_t v228 = v84;
            int64_t v229 = v297;
            if (v297 != v228)
            {
              uint64_t v230 = v228;
              while ((*(unsigned char *)(v69 + 12) & 2) != 0 && *(_DWORD *)v69 != -1)
              {
                float v231 = *(float *)(v69 + 208);
                if ((v231 != 0.0
                   || *(void *)(v69 + 136)
                   || *(_DWORD *)(v69 + 40) < *(_DWORD *)(v69 + 36)
                   || (uint64_t v232 = *(void *)(v69 + 128)) != 0 && *(_DWORD *)(v232 + 60) > *(_DWORD *)(v69 + 4))
                  && v231 < *(float *)(v69 + 212))
                {
                  break;
                }
                v233 = *(uint64_t **)(v69 + 56);
                if (!v233) {
                  break;
                }
                v234 = 0;
                v317 = &v218[v230];
                uint64_t v315 = v229 - v230;
                do
                {
                  if ((*((_DWORD *)v233 + 8)
                                    + *((_DWORD *)v233 + 7)
                                    + *(_DWORD *)(v69 + 20)
                                    - (*(_DWORD *)(v69 + 32)
                                     + *(_DWORD *)(v69 + 16))) >= *(_DWORD *)(v69 + 20) >> 2)
                    break;
                  if (!v234
                    || *((_DWORD *)v233 + 12) + *((_DWORD *)v233 + 13) + 32 >= (v234[12] + v234[13] + 32))
                  {
                    int64_t v235 = v229;
                    os_log_type_t v236 = (uint64_t *)*v233;
                    int v237 = *((_DWORD *)v233 + 10);
                    if (*v233)
                    {
                      while (1)
                      {
                        if (*((_DWORD *)v236 + 10) == v237)
                        {
                          uint64_t v238 = *((unsigned int *)v236 + 12);
                          if (v238 == *((_DWORD *)v233 + 12))
                          {
                            size_t v239 = *((unsigned int *)v236 + 13);
                            if (v239 == *((_DWORD *)v233 + 13)
                              && !memcmp(v236 + 7, v233 + 7, *((unsigned int *)v236 + 12))
                              && !memcmp((char *)v236 + v238 + 56, (char *)v233 + v238 + 56, v239))
                            {
                              break;
                            }
                          }
                        }
                        os_log_type_t v236 = (uint64_t *)*v236;
                        if (!v236) {
                          goto LABEL_407;
                        }
                      }
                      int64_t v229 = v235;
                      os_log_type_t v218 = v298;
                    }
                    else
                    {
LABEL_407:
                      uint64_t v240 = *(void *)(v69 + 216);
                      int64_t v229 = v235;
                      os_log_type_t v218 = v298;
                      if (!v240) {
                        goto LABEL_463;
                      }
                      uint64_t v241 = 228;
                      if (!*(_DWORD *)(v69 + 232)) {
                        uint64_t v241 = 224;
                      }
                      unint64_t v242 = v240 + 8 * *(unsigned int *)(v69 + v241);
                      *(_DWORD *)(v242 + 4) = v237;
                      unint64_t v243 = v240 - 8;
                      do
                      {
                        int v244 = *(_DWORD *)(v243 + 12);
                        v243 += 8;
                      }
                      while (v244 != v237);
                      if (v243 < v242)
                      {
LABEL_463:
                        if (qenc_has_or_can_evict_at_least(v69, (*((_DWORD *)v233 + 12) + *((_DWORD *)v233 + 13) + 32)))v234 = v233; {
                      }
                        }
                    }
                  }
                  v233 = (uint64_t *)v233[2];
                }
                while (v233);
                if (!v234) {
                  break;
                }
                v245 = *(FILE **)(v69 + 200);
                if (v245)
                {
                  fwrite("qenc: debug: ", 0xDuLL, 1uLL, v245);
                  fwrite("dup draining", 0xCuLL, 1uLL, *(FILE **)(v69 + 200));
                  fputc(10, *(FILE **)(v69 + 200));
                }
                unsigned char *v317 = 0;
                if (v315 <= 0) {
                  goto LABEL_441;
                }
                unint64_t v246 = (*(_DWORD *)v69 - v234[6]);
                if (v246 > 0x1E)
                {
                  unsigned char *v317 = 31;
                  v248 = v317 + 1;
                  unint64_t v249 = v246 - 31;
                  if (v246 - 31 < 0x80)
                  {
                    uint64_t v251 = v317;
                    LOBYTE(v246) = v246 - 31;
                  }
                  else
                  {
                    do
                    {
                      if (v248 >= v306) {
                        goto LABEL_431;
                      }
                      *v248++ = v249 | 0x80;
                      unint64_t v246 = v249 >> 7;
                      unint64_t v250 = v249 >> 14;
                      v249 >>= 7;
                    }
                    while (v250);
                    uint64_t v251 = v248 - 1;
                  }
                  if (v248 >= v306) {
                    break;
                  }
                  int v247 = v251 + 2;
                  unsigned char *v248 = v246;
                  if (v251 + 2 <= v317) {
                    break;
                  }
                }
                else
                {
                  unsigned char *v317 = *(unsigned char *)v69 - *((unsigned char *)v234 + 24);
                  int v247 = v317 + 1;
                }
                if (!lsqpack_enc_push_entry(v69, v234[11], v234[10], v234 + 14, v234[12], (char *)v234 + v234[12] + 56, v234[13])|| v247 == v317)
                {
                  break;
                }
                qenc_remove_overflow_entries(v69);
                v230 += (v247 - v317);
                if (v229 == v230) {
                  goto LABEL_432;
                }
              }
LABEL_431:
              int64_t v229 = v230;
            }
LABEL_432:
            unsigned int v252 = v284 + *(_DWORD *)(v69 + 192);
            unsigned int v253 = *(_DWORD *)(v69 + 196) + v229 + v313;
            *(_DWORD *)(v69 + 192) = v252;
            *(_DWORD *)(v69 + 196) = v253;
            if (v253 >= 0x80000001)
            {
              *(_DWORD *)(v69 + 192) = (int)(float)((float)((float)v252 * 1000.0) / (float)v253);
              *(_DWORD *)(v69 + 196) = 1000;
              uint64_t v254 = *(FILE **)(v69 + 200);
              if (v254)
              {
                fwrite("qenc: debug: ", 0xDuLL, 1uLL, v254);
                v255 = *(FILE **)(v69 + 200);
                unsigned int v256 = *(_DWORD *)(v69 + 192);
                if (v256)
                {
                  float v257 = (float)*(unsigned int *)(v69 + 196) / (float)v256;
                  if (v255)
                  {
                    fwrite("qenc: debug: ", 0xDuLL, 1uLL, *(FILE **)(v69 + 200));
                    fprintf(*(FILE **)(v69 + 200), "bytes out: %u; bytes in: %u, ratio: %.3f",
                      *(_DWORD *)(v69 + 196),
                      *(_DWORD *)(v69 + 192),
                      v257);
                    fputc(10, *(FILE **)(v69 + 200));
                  }
                }
                else
                {
                  float v257 = 0.0;
                }
                fprintf(v255, "reset bytes in/out counters, ratio: %.3f", v257);
                fputc(10, *(FILE **)(v69 + 200));
              }
            }
            *(void *)(*(void *)(*v290 + 8) + 24) += v313;
            *(void *)(*(void *)(*v287 + 8) + 24) += v229;
            return;
          case 3uLL:
            v169 = v293;
            unsigned char *v293 = v270;
            if (v292 <= 0) {
              goto LABEL_441;
            }
            if (v85 > 0xE)
            {
              unsigned char *v293 = v266;
              v204 = v293 + 1;
              unint64_t v205 = v85 - 15;
              unint64_t v175 = v291;
              if (v205 >= 0x80)
              {
                while ((unint64_t)v204 < v291)
                {
                  *v204++ = v205 | 0x80;
                  unint64_t v206 = v205 >> 7;
                  unint64_t v207 = v205 >> 14;
                  v205 >>= 7;
                  if (!v207) {
                    goto LABEL_328;
                  }
                }
LABEL_32:
                uint64_t v9 = v300;
                size_t v36 = *(void *)(*(void *)(v300[6] + 8) + 24);
                if (v36 < *(void *)(*(void *)(v300[5] + 8) + 24)
                         + *(void *)(*(void *)(v300[4] + 8) + 24))
                {
                  uint64_t v37 = *(NSObject **)(*(void *)(v300[13] + 8) + 24);
                  *(void *)(*(void *)(v300[13] + 8) + 24) = dispatch_data_create_subrange(v37, 0, v36);
                  if (v37) {
                    dispatch_release(v37);
                  }
                }
                *(void *)(*(void *)(v300[5] + 8) + 24) += 512;
                uint64_t alloc = dispatch_data_create_alloc();
                __int16 v39 = *(NSObject **)(*(void *)(v300[13] + 8) + 24);
                *(void *)(*(void *)(v300[13] + 8) + 24) = dispatch_data_create_concat(v39, alloc);
                if (v39) {
                  dispatch_release(v39);
                }
                uint64_t v40 = v289;
                uint64_t v41 = v290;
                if (alloc) {
                  goto LABEL_27;
                }
                goto LABEL_28;
              }
LABEL_330:
              v212 = v169;
              LOBYTE(v206) = v205;
              if ((unint64_t)v204 >= v175) {
                goto LABEL_32;
              }
LABEL_331:
              v177 = v212 + 2;
              unsigned char *v204 = v206;
              if (v212 + 2 <= v169) {
                goto LABEL_32;
              }
            }
            else
            {
              unsigned char *v293 = v270 | v85;
              v177 = v293 + 1;
              unint64_t v175 = v291;
            }
LABEL_332:
            unint64_t v183 = v175 - (void)v177;
LABEL_333:
            int v181 = lsqpack_enc_enc_str(7, v177, v183, (unsigned __int8 *)v311, v302);
            unsigned int v85 = v305;
            int v168 = v314;
            if (v181 < 0) {
              goto LABEL_32;
            }
LABEL_334:
            uint64_t v170 = &v177[v181];
            goto LABEL_335;
          case 4uLL:
            v169 = v293;
            if (v85 > *(_DWORD *)(v69 + 156)) {
              goto LABEL_264;
            }
            unsigned char *v293 = v268;
            unint64_t v175 = v291;
            if (v292 <= 0) {
              goto LABEL_441;
            }
            uint64_t v176 = *(_DWORD *)(v69 + 156) - v85;
            if (v176 <= 0xE)
            {
              unsigned char *v293 = v268 | (*(unsigned char *)(v69 + 156) - v85);
              v177 = v293 + 1;
              goto LABEL_332;
            }
            unsigned char *v293 = v265;
            v204 = v293 + 1;
            unint64_t v205 = v176 - 15;
            if ((unint64_t)(v176 - 15) < 0x80) {
              goto LABEL_330;
            }
            do
            {
              if ((unint64_t)v204 >= v291) {
                goto LABEL_32;
              }
              *v204++ = v205 | 0x80;
              unint64_t v206 = v205 >> 7;
              unint64_t v211 = v205 >> 14;
              v205 >>= 7;
            }
            while (v211);
LABEL_328:
            v212 = v204 - 1;
            if ((unint64_t)v204 >= v175) {
              goto LABEL_32;
            }
            goto LABEL_331;
          case 5uLL:
            unsigned int v85 = *(_DWORD *)v69 + 1;
            v169 = v293;
LABEL_264:
            unsigned char *v169 = v271;
            unsigned int v178 = *(_DWORD *)(v69 + 156);
            if (v85 <= v178) {
              __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 2045, "id > enc->qpe_cur_header.base_idx");
            }
            if (v292 <= 0) {
              goto LABEL_441;
            }
            unint64_t v179 = v85 + ~v178;
            if (v179 > 6)
            {
              unsigned char *v169 = v267;
              uint64_t v198 = v169 + 1;
              unint64_t v199 = v179 - 7;
              if (v179 - 7 < 0x80)
              {
                v201 = v169;
                LOBYTE(v179) = v179 - 7;
                if ((unint64_t)v198 >= v291) {
                  goto LABEL_32;
                }
              }
              else
              {
                do
                {
                  if ((unint64_t)v198 >= v291) {
                    goto LABEL_32;
                  }
                  *v198++ = v199 | 0x80;
                  unint64_t v179 = v199 >> 7;
                  unint64_t v200 = v199 >> 14;
                  v199 >>= 7;
                }
                while (v200);
                v201 = v198 - 1;
                if ((unint64_t)v198 >= v291) {
                  goto LABEL_32;
                }
              }
              v177 = v201 + 2;
              *uint64_t v198 = v179;
              if (v201 + 2 <= v169) {
                goto LABEL_32;
              }
            }
            else
            {
              unsigned char *v169 = v271 | (v85 + ~(_BYTE)v178);
              v177 = v169 + 1;
            }
            unsigned int v180 = v85;
            int v181 = lsqpack_enc_enc_str(7, v177, v291 - (void)v177, (unsigned __int8 *)v311, v302);
            int v168 = v314;
            if (v181 < 0) {
              goto LABEL_32;
            }
            unsigned int v85 = v180;
            goto LABEL_334;
          case 6uLL:
            v169 = v293;
            unsigned char *v293 = v269;
            int v182 = lsqpack_enc_enc_str(3, v293, v292, (unsigned __int8 *)v316, v64);
            if (v182 < 0) {
              goto LABEL_32;
            }
            v177 = &v293[v182];
            unint64_t v183 = v291 - (void)v177;
            goto LABEL_333;
          default:
            goto LABEL_446;
        }
      case 3:
        if (v297 < 1) {
          goto LABEL_315;
        }
        unsigned char *v298 = 0x80;
        uint64_t v165 = *(_DWORD *)v69 - v85;
        if (v165 <= 0x3E)
        {
          char v164 = (*(unsigned char *)v69 - v85) | 0x80;
          goto LABEL_243;
        }
        unsigned char *v298 = -65;
        v188 = v298 + 1;
        unint64_t v189 = v165 - 63;
        if ((unint64_t)(v165 - 63) < 0x80) {
          goto LABEL_287;
        }
        do
        {
          if (v188 >= v306) {
            goto LABEL_315;
          }
          *v188++ = v189 | 0x80;
          unint64_t v190 = v189 >> 7;
          unint64_t v192 = v189 >> 14;
          v189 >>= 7;
        }
        while (v192);
LABEL_286:
        id v193 = v188 - 1;
        goto LABEL_288;
      case 4:
      case 5:
        if (v297 < 1) {
          goto LABEL_315;
        }
        unsigned char *v298 = 64;
        int v157 = lsqpack_enc_enc_str(5, v298, v297, (unsigned __int8 *)v316, v64);
        if (v157 < 0) {
          goto LABEL_315;
        }
        unsigned int v158 = &v298[v157];
        size_t v159 = v84 == 4 ? v154 : 0;
        int v160 = lsqpack_enc_enc_str(7, v158, v306 - v158, (unsigned __int8 *)v311, v159);
        unsigned int v85 = v305;
        if (v160 < 0) {
          goto LABEL_315;
        }
        uint64_t v161 = &v158[v160];
        goto LABEL_246;
      default:
        __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 1989, "EEA_NONE == prog.ep_enc_action");
    }
  }
}

BOOL ___ZL27nw_http3_stream_send_fieldsP24nw_protocol_http3_streamb_block_invoke_3(void *a1, uint64_t a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if ((nw_frame_uses_external_data(a2) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    uint64_t v28 = "nw_http3_stream_send_fields_block_invoke_3";
    int v7 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(offset) = 16;
    os_log_type_t offset_7 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v7, &offset, &offset_7))
    {
      if (offset == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v8 = gLogObj;
        os_log_type_t v9 = offset;
        if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)offset))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v28 = "nw_http3_stream_send_fields_block_invoke";
          uint64_t v10 = "%{public}s Encoder stream does not support external data";
LABEL_31:
          _os_log_impl(&dword_1830D4000, v8, v9, v10, buf, 0xCu);
        }
      }
      else if (offset_7)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v8 = gLogObj;
        os_log_type_t v9 = offset;
        BOOL v16 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)offset);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v28 = "nw_http3_stream_send_fields_block_invoke";
            __int16 v29 = 2082;
            uint64_t v30 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s Encoder stream does not support external data, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_32;
        }
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v28 = "nw_http3_stream_send_fields_block_invoke";
          uint64_t v10 = "%{public}s Encoder stream does not support external data, no backtrace";
          goto LABEL_31;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v8 = gLogObj;
        os_log_type_t v9 = offset;
        if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)offset))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v28 = "nw_http3_stream_send_fields_block_invoke";
          uint64_t v10 = "%{public}s Encoder stream does not support external data, backtrace limit exceeded";
          goto LABEL_31;
        }
      }
    }
LABEL_32:
    if (v7) {
      free(v7);
    }
    return 0;
  }
  unsigned int offset = 0;
  nw_frame_set_external_data(a2, *(dispatch_data_t *)(a1[6] + 528), &offset);
  unsigned int v4 = *(_DWORD *)(*(void *)(a1[4] + 8) + 24);
  int v5 = *(NSObject **)(a1[6] + 528);
  BOOL v6 = offset < v4;
  if (offset < v4)
  {
    *(void *)(a1[6] + 528) = dispatch_data_create_subrange(*(dispatch_data_t *)(a1[6] + 528), offset, 0xFFFFFFFFFFFFFFFFLL);
    if (v5) {
      dispatch_release(v5);
    }
    *(_DWORD *)(*(void *)(a1[4] + 8) + 24) -= offset;
    return v6;
  }
  if (v5)
  {
    dispatch_release(*(dispatch_object_t *)(a1[6] + 528));
    *(void *)(a1[6] + 528) = 0;
  }
  if (**(void **)(*(void *)(*(void *)(a1[5] + 8) + 48) + 8) != a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    uint64_t v28 = "nw_http3_stream_send_fields_block_invoke";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t offset_7 = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (!__nwlog_fault(v11, &offset_7, &v24)) {
      goto LABEL_40;
    }
    if (offset_7 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v12 = gLogObj;
      os_log_type_t v13 = offset_7;
      if (!os_log_type_enabled((os_log_t)gLogObj, offset_7)) {
        goto LABEL_40;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v28 = "nw_http3_stream_send_fields_block_invoke";
      int v14 = "%{public}s Too much space on encoder stream";
    }
    else
    {
      if (v24)
      {
        int v17 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v18 = gLogObj;
        os_log_type_t v19 = offset_7;
        BOOL v20 = os_log_type_enabled((os_log_t)gLogObj, offset_7);
        if (v17)
        {
          if (v20)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v28 = "nw_http3_stream_send_fields_block_invoke";
            __int16 v29 = 2082;
            uint64_t v30 = v17;
            _os_log_impl(&dword_1830D4000, v18, v19, "%{public}s Too much space on encoder stream, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v17);
          goto LABEL_40;
        }
        if (!v20)
        {
LABEL_40:
          if (v11) {
            free(v11);
          }
          return v6;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v28 = "nw_http3_stream_send_fields_block_invoke";
        int v14 = "%{public}s Too much space on encoder stream, no backtrace";
        BOOL v22 = v18;
        os_log_type_t v23 = v19;
LABEL_39:
        _os_log_impl(&dword_1830D4000, v22, v23, v14, buf, 0xCu);
        goto LABEL_40;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v12 = gLogObj;
      os_log_type_t v13 = offset_7;
      if (!os_log_type_enabled((os_log_t)gLogObj, offset_7)) {
        goto LABEL_40;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v28 = "nw_http3_stream_send_fields_block_invoke";
      int v14 = "%{public}s Too much space on encoder stream, backtrace limit exceeded";
    }
    BOOL v22 = v12;
    os_log_type_t v23 = v13;
    goto LABEL_39;
  }
  return v6;
}

BOOL ___ZL27nw_http3_stream_send_fieldsP24nw_protocol_http3_streamb_block_invoke_110(void *a1, uint64_t a2)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if ((nw_frame_uses_external_data(a2) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    uint64_t v32 = "nw_http3_stream_send_fields_block_invoke";
    int v7 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(offset) = 16;
    os_log_type_t offset_7 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v7, &offset, &offset_7))
    {
      if (offset == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v8 = gLogObj;
        os_log_type_t v9 = offset;
        if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)offset))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v32 = "nw_http3_stream_send_fields_block_invoke";
          uint64_t v10 = "%{public}s Fields frame does not support external data";
LABEL_24:
          os_log_type_t v19 = v8;
          os_log_type_t v20 = v9;
LABEL_25:
          _os_log_impl(&dword_1830D4000, v19, v20, v10, buf, 0xCu);
        }
      }
      else if (offset_7)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v16 = gLogObj;
        os_log_type_t v17 = offset;
        BOOL v18 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)offset);
        if (backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v32 = "nw_http3_stream_send_fields_block_invoke";
            __int16 v33 = 2082;
            os_log_type_t v34 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s Fields frame does not support external data, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_26;
        }
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v32 = "nw_http3_stream_send_fields_block_invoke";
          uint64_t v10 = "%{public}s Fields frame does not support external data, no backtrace";
          os_log_type_t v19 = v16;
          os_log_type_t v20 = v17;
          goto LABEL_25;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v8 = gLogObj;
        os_log_type_t v9 = offset;
        if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)offset))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v32 = "nw_http3_stream_send_fields_block_invoke";
          uint64_t v10 = "%{public}s Fields frame does not support external data, backtrace limit exceeded";
          goto LABEL_24;
        }
      }
    }
LABEL_26:
    if (v7) {
      free(v7);
    }
    return 0;
  }
  unsigned int offset = 0;
  nw_frame_set_external_data(a2, *(dispatch_data_t *)(a1[6] + 520), &offset);
  unsigned int v4 = *(_DWORD *)(*(void *)(a1[4] + 8) + 24);
  int v5 = *(NSObject **)(a1[6] + 520);
  BOOL v6 = offset < v4;
  if (offset < v4)
  {
    *(void *)(a1[6] + 520) = dispatch_data_create_subrange(*(dispatch_data_t *)(a1[6] + 520), offset, 0xFFFFFFFFFFFFFFFFLL);
    if (v5) {
      dispatch_release(v5);
    }
    *(_DWORD *)(*(void *)(a1[4] + 8) + 24) -= offset;
    return v6;
  }
  if (v5)
  {
    dispatch_release(*(dispatch_object_t *)(a1[6] + 520));
    *(void *)(a1[6] + 520) = 0;
  }
  if (**(void **)(*(void *)(*(void *)(a1[5] + 8) + 48) + 8) != a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    uint64_t v32 = "nw_http3_stream_send_fields_block_invoke";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t offset_7 = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (!__nwlog_fault(v11, &offset_7, &v28)) {
      goto LABEL_41;
    }
    if (offset_7 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v12 = gLogObj;
      os_log_type_t v13 = offset_7;
      if (!os_log_type_enabled((os_log_t)gLogObj, offset_7)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v32 = "nw_http3_stream_send_fields_block_invoke";
      int v14 = "%{public}s Too much space in fields frame";
    }
    else
    {
      if (v28)
      {
        BOOL v22 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v23 = gLogObj;
        os_log_type_t v24 = offset_7;
        BOOL v25 = os_log_type_enabled((os_log_t)gLogObj, offset_7);
        if (v22)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v32 = "nw_http3_stream_send_fields_block_invoke";
            __int16 v33 = 2082;
            os_log_type_t v34 = v22;
            _os_log_impl(&dword_1830D4000, v23, v24, "%{public}s Too much space in fields frame, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v22);
          goto LABEL_41;
        }
        if (!v25)
        {
LABEL_41:
          if (v11) {
            free(v11);
          }
          return v6;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v32 = "nw_http3_stream_send_fields_block_invoke";
        int v14 = "%{public}s Too much space in fields frame, no backtrace";
        uint64_t v26 = v23;
        os_log_type_t v27 = v24;
LABEL_40:
        _os_log_impl(&dword_1830D4000, v26, v27, v14, buf, 0xCu);
        goto LABEL_41;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v12 = gLogObj;
      os_log_type_t v13 = offset_7;
      if (!os_log_type_enabled((os_log_t)gLogObj, offset_7)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v32 = "nw_http3_stream_send_fields_block_invoke";
      int v14 = "%{public}s Too much space in fields frame, backtrace limit exceeded";
    }
    uint64_t v26 = v12;
    os_log_type_t v27 = v13;
    goto LABEL_40;
  }
  return v6;
}

uint64_t ___ZL32nw_http3_framer_get_input_framesP15nw_http3_framerjjjPyS1_PbPjP16nw_frame_array_s_block_invoke(void *a1, uint64_t a2)
{
  unsigned int v24 = 0;
  unsigned int v4 = (const void *)nw_frame_unclaimed_bytes(a2, &v24);
  uint64_t v5 = a1[5];
  if (!v4) {
    goto LABEL_28;
  }
  uint64_t v6 = *(unsigned __int16 *)(v5 + 84);
  if (16 - v6 >= (unint64_t)v24) {
    size_t v7 = v24;
  }
  else {
    size_t v7 = 16 - v6;
  }
  memcpy((void *)(v5 + v6 + 68), v4, v7);
  uint64_t v5 = a1[5];
  unsigned __int16 v9 = *(_WORD *)(v5 + 84) + v7;
  *(_WORD *)(v5 + 84) = v9;
  if (!v9) {
    goto LABEL_23;
  }
  uint64_t v10 = (_DWORD *)(v5 + 68);
  unint64_t v11 = *(unsigned __int8 *)(v5 + 68);
  if (v11 <= 0x3F)
  {
    unsigned int v12 = 1;
    goto LABEL_8;
  }
  unsigned int v17 = v11 >> 6;
  if (v17 == 2)
  {
    if (v9 < 4u) {
      goto LABEL_23;
    }
    unint64_t v11 = bswap32(*v10 & 0xFFFFFF7F);
    unsigned int v12 = 4;
  }
  else
  {
    if (v17 == 1)
    {
      if (v9 >= 2u)
      {
        unint64_t v11 = bswap32(*(_WORD *)v10 & 0xFFBF) >> 16;
        unsigned int v12 = 2;
        goto LABEL_8;
      }
LABEL_23:
      unsigned int v12 = 0;
      goto LABEL_24;
    }
    if (v9 < 8u) {
      goto LABEL_23;
    }
    unint64_t v11 = bswap64(*(void *)v10 & 0xFFFFFFFFFFFFFF3FLL);
    unsigned int v12 = 8;
  }
LABEL_8:
  *(void *)uint64_t v5 = v11;
  unint64_t v13 = v9 - (unint64_t)v12;
  if (v9 != (unint64_t)v12)
  {
    unint64_t v14 = *((unsigned __int8 *)v10 + v12);
    if (v14 <= 0x3F)
    {
      int v15 = 1;
LABEL_11:
      v12 += v15;
      *(_WORD *)(v5 + 84) = 0;
      char v16 = 1;
      *(void *)(v5 + 8) = v14;
      *(void *)(v5 + 16) = v14;
      goto LABEL_25;
    }
    unsigned int v18 = v14 >> 6;
    if (v18 == 2)
    {
      if (v13 >= 4)
      {
        unint64_t v14 = bswap32(*(_DWORD *)((char *)v10 + v12) & 0xFFFFFF7F);
        int v15 = 4;
        goto LABEL_11;
      }
    }
    else if (v18 == 1)
    {
      if (v13 >= 2)
      {
        unint64_t v14 = bswap32(*(_WORD *)((unsigned char *)v10 + v12) & 0xFFBF) >> 16;
        int v15 = 2;
        goto LABEL_11;
      }
    }
    else if (v13 >= 8)
    {
      unint64_t v14 = bswap64(*(void *)((unsigned char *)v10 + v12) & 0xFFFFFFFFFFFFFF3FLL);
      int v15 = 8;
      goto LABEL_11;
    }
  }
LABEL_24:
  char v16 = 0;
LABEL_25:
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = v16;
  if (*(unsigned char *)(*(void *)(a1[4] + 8) + 24))
  {
    nw_frame_claim(a2, v8, v12 - v6, 0);
    os_log_type_t v19 = (unsigned int *)a1[6];
    uint64_t v20 = 0;
    if (v19) {
      *os_log_type_t v19 = v12;
    }
    return v20;
  }
LABEL_28:
  uint64_t v21 = *(void *)(a2 + 32);
  BOOL v22 = *(void **)(a2 + 40);
  if (v21)
  {
    *(void *)(v21 + 40) = v22;
    BOOL v22 = *(void **)(a2 + 40);
  }
  else
  {
    *(void *)(v5 + 56) = v22;
  }
  *BOOL v22 = v21;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  uint64_t v20 = 1;
  nw_frame_finalize(a2);
  return v20;
}

uint64_t nw_http3_framer_deliver_http3_frame_body(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4, void *a5, void *a6, unsigned char *a7, uint64_t a8)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  uint64_t v57 = 0;
  uint64_t v58 = &v57;
  int v60 = 0;
  uint64_t v59 = 0x2000000000;
  uint64_t v53 = 0;
  int v54 = &v53;
  int v56 = 0;
  uint64_t v55 = 0x2000000000;
  v48[0] = MEMORY[0x1E4F143A8];
  v48[1] = 0x40000000;
  unint64_t v49 = (uint64_t (*)(void *))___ZL40nw_http3_framer_deliver_http3_frame_bodyP15nw_http3_framerjjjPyS1_PbP16nw_frame_array_s_block_invoke;
  int v50 = &unk_1E5247348;
  unint64_t v51 = &v57;
  int v52 = &v53;
  uint64_t v16 = *(void *)(a1 + 48);
  do
  {
    if (!v16) {
      break;
    }
    uint64_t v17 = *(void *)(v16 + 32);
    char v18 = v49(v48);
    uint64_t v16 = v17;
  }
  while ((v18 & 1) != 0);
  unint64_t v19 = *((unsigned int *)v58 + 6);
  unint64_t v20 = *(void *)(a1 + 16);
  if (v19 < a3 && v20 > v19)
  {
    uint64_t v22 = *(void *)(a1 + 40);
    if (*((_DWORD *)v54 + 6) < a4 && v22 != 0)
    {
      uint64_t v24 = *(void *)(v22 + 24);
      if (v24)
      {
        if (*(void *)(v24 + 80))
        {
          uint64_t v44 = 0;
          int v45 = &v44;
          if (v20 >= a2) {
            LODWORD(v20) = a2;
          }
          uint64_t v25 = (v20 - v19);
          if (v20 < v19 && gLogDatapath)
          {
            uint64_t v34 = v22;
            uint64_t v32 = __nwlog_obj();
            if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v33 = *((unsigned int *)v58 + 6);
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_http3_framer_deliver_http3_frame_body";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = "final_minimum_bytes";
              *(_WORD *)&unsigned char buf[22] = 2048;
              uint64_t v62 = v33;
              __int16 v63 = 2048;
              uint64_t v64 = v25;
              _os_log_impl(&dword_1830D4000, v32, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
            }
            uint64_t v22 = v34;
          }
          if (!(*(unsigned int (**)(void))(*(void *)(v22 + 24) + 80))())
          {
            uint64_t v30 = 0;
            goto LABEL_26;
          }
          if (v44)
          {
            **(void **)(a1 + 56) = v44;
            uint64_t v26 = v45;
            *(void *)(v44 + 40) = *(void *)(a1 + 56);
            *(void *)(a1 + 56) = v26;
          }
        }
      }
    }
  }
  *a5 = *(void *)a1;
  *a6 = *(void *)(a1 + 8);
  *a7 = 0;
  *(void *)buf = 0;
  *(void *)&buf[8] = buf;
  LODWORD(v62) = 0;
  *(void *)&buf[16] = 0x2000000000;
  uint64_t v44 = 0;
  int v45 = &v44;
  int v47 = 0;
  uint64_t v46 = 0x2000000000;
  v35[0] = MEMORY[0x1E4F143A8];
  v35[1] = 0x40000000;
  size_t v36 = ___ZL40nw_http3_framer_deliver_http3_frame_bodyP15nw_http3_framerjjjPyS1_PbP16nw_frame_array_s_block_invoke_81;
  uint64_t v37 = &unk_1E5247370;
  unsigned int v43 = a3;
  uint64_t v40 = a1;
  uint64_t v41 = a8;
  int v38 = buf;
  __int16 v39 = &v44;
  unsigned int v42 = a7;
  uint64_t v27 = *(void *)(a1 + 48);
  do
  {
    if (!v27) {
      break;
    }
    uint64_t v28 = *(void *)(v27 + 32);
    char v29 = ((uint64_t (*)(void *))v36)(v35);
    uint64_t v27 = v28;
  }
  while ((v29 & 1) != 0);
  uint64_t v30 = *((unsigned int *)v45 + 6);
  _Block_object_dispose(&v44, 8);
  _Block_object_dispose(buf, 8);
LABEL_26:
  _Block_object_dispose(&v53, 8);
  _Block_object_dispose(&v57, 8);
  return v30;
}

uint64_t ___ZL40nw_http3_framer_deliver_http3_frame_bodyP15nw_http3_framerjjjPyS1_PbP16nw_frame_array_s_block_invoke(uint64_t a1, _DWORD *a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += nw_frame_unclaimed_length(a2);
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  return 1;
}

uint64_t ___ZL40nw_http3_framer_deliver_http3_frame_bodyP15nw_http3_framerjjjPyS1_PbP16nw_frame_array_s_block_invoke_81(uint64_t a1, uint64_t a2)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a2 + 32);
  uint64_t v5 = *(void **)(a2 + 40);
  uint64_t v6 = (void *)(a2 + 32);
  if (v4)
  {
    *(void *)(v4 + 40) = v5;
    uint64_t v5 = *(void **)(a2 + 40);
  }
  else
  {
    *(void *)(*(void *)(a1 + 48) + 56) = v5;
  }
  void *v5 = v4;
  *uint64_t v6 = 0;
  *(void *)(a2 + 40) = 0;
  unsigned int v7 = nw_frame_unclaimed_length((_DWORD *)a2);
  uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8);
  unint64_t v9 = *(unsigned int *)(v8 + 24);
  unint64_t v10 = *(unsigned int *)(a1 + 72);
  unint64_t v11 = v10 - v9;
  if (v10 < v9) {
    unint64_t v11 = 0;
  }
  if (*(void *)(*(void *)(a1 + 48) + 16) + v9 <= v10) {
    unint64_t v12 = *(void *)(*(void *)(a1 + 48) + 16);
  }
  else {
    unint64_t v12 = v11;
  }
  uint64_t v13 = v7;
  if (v12 < v7)
  {
    uint64_t v44 = a2;
    uint64_t v14 = nw_frame_split(&v44, v12);
    uint64_t v15 = *(void *)(a1 + 48);
    unint64_t v16 = *(void *)(v15 + 16) - v12;
    *(void *)(v15 + 16) = v16;
    if (!v16) {
      **(unsigned char **)(a1 + 64) = 1;
    }
    if (v14)
    {
      uint64_t v17 = *(void *)(a1 + 56);
      *(void *)(v14 + 32) = 0;
      char v18 = *(uint64_t **)(v17 + 8);
      *(void *)(v14 + 40) = v18;
      uint64_t *v18 = v14;
      *(void *)(v17 + 8) = v14 + 32;
      ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
      uint64_t v19 = *(void *)(a1 + 48);
      uint64_t v20 = v44;
      uint64_t v22 = *(void *)(v19 + 48);
      uint64_t v21 = (uint64_t *)(v19 + 48);
      uint64_t v23 = v44;
      *(void *)(v44 + 32) = v22;
      uint64_t v24 = v23 + 32;
      uint64_t v25 = (uint64_t *)(v22 + 40);
      if (v22) {
        uint64_t v26 = v25;
      }
      else {
        uint64_t v26 = v21 + 1;
      }
      *uint64_t v26 = v24;
      *uint64_t v21 = v20;
      *(void *)(v20 + 40) = v21;
      return 0;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    uint64_t v46 = "nw_http3_framer_deliver_http3_frame_body_block_invoke";
    uint64_t v32 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (__nwlog_fault(v32, &type, &v42))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v33 = gLogObj;
        os_log_type_t v34 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_32;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v46 = "nw_http3_framer_deliver_http3_frame_body_block_invoke";
        uint64_t v35 = "%{public}s nw_frame_split returned NULL frame";
LABEL_30:
        uint64_t v40 = v33;
        os_log_type_t v41 = v34;
LABEL_31:
        _os_log_impl(&dword_1830D4000, v40, v41, v35, buf, 0xCu);
        goto LABEL_32;
      }
      if (!v42)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v33 = gLogObj;
        os_log_type_t v34 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_32;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v46 = "nw_http3_framer_deliver_http3_frame_body_block_invoke";
        uint64_t v35 = "%{public}s nw_frame_split returned NULL frame, backtrace limit exceeded";
        goto LABEL_30;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v37 = gLogObj;
      os_log_type_t v38 = type;
      BOOL v39 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v39)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v46 = "nw_http3_framer_deliver_http3_frame_body_block_invoke";
          __int16 v47 = 2082;
          int v48 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v37, v38, "%{public}s nw_frame_split returned NULL frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_32;
      }
      if (v39)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v46 = "nw_http3_framer_deliver_http3_frame_body_block_invoke";
        uint64_t v35 = "%{public}s nw_frame_split returned NULL frame, no backtrace";
        uint64_t v40 = v37;
        os_log_type_t v41 = v38;
        goto LABEL_31;
      }
    }
LABEL_32:
    if (v32) {
      free(v32);
    }
    return 0;
  }
  *(_DWORD *)(v8 + 24) = v9 + v7;
  uint64_t v27 = *(void *)(a1 + 56);
  *(void *)(a2 + 32) = 0;
  uint64_t v28 = *(uint64_t **)(v27 + 8);
  *(void *)(a2 + 40) = v28;
  *uint64_t v28 = a2;
  *(void *)(v27 + 8) = v6;
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  uint64_t v29 = *(void *)(a1 + 48);
  uint64_t result = 1;
  uint64_t v31 = *(void *)(v29 + 16) - v13;
  *(void *)(v29 + 16) = v31;
  if (v31) {
    return result;
  }
  **(unsigned char **)(a1 + 64) = 1;
  return 0;
}

void nw_protocol_http3_uni_stream_input_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    handle = (nw_protocol *)a1->handle;
    if (handle)
    {
      if (gLogDatapath)
      {
        unint64_t v10 = __nwlog_obj();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v40 = "nw_protocol_http3_uni_stream_input_available";
          __int16 v41 = 2048;
          char v42 = handle;
          _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_DEBUG, "%{public}s called on http3_uni_stream %p", buf, 0x16u);
        }
      }
      if ((handle[2].flow_id[3] & 2) == 0) {
        return;
      }
      if ((handle[2].flow_id[3] & 4) == 0)
      {
        nw_protocol_http3_uni_stream_get_input_frames(handle, a2, 0, 0, 0xFFFFFFFF, 0);
        return;
      }
      default_input_handler = handle->default_input_handler;
      if (default_input_handler)
      {
        callbacks = default_input_handler->callbacks;
        if (callbacks)
        {
          input_available = (void (*)(void))callbacks->input_available;
          if (input_available)
          {
            input_available();
            return;
          }
        }
      }
      __nwlog_obj();
      unint64_t v11 = handle->default_input_handler;
      unint64_t v12 = "invalid";
      if (v11)
      {
        name = v11->identifier->name;
        if (name) {
          unint64_t v12 = name;
        }
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v40 = "nw_protocol_http3_uni_stream_input_available";
      __int16 v41 = 2082;
      char v42 = (nw_protocol *)v12;
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v37 = 0;
      if (!__nwlog_fault(v6, &type, &v37)) {
        goto LABEL_72;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v14 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (!os_log_type_enabled(v14, type)) {
          goto LABEL_72;
        }
        unint64_t v16 = handle->default_input_handler;
        uint64_t v17 = "invalid";
        if (v16)
        {
          char v18 = v16->identifier->name;
          if (v18) {
            uint64_t v17 = v18;
          }
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v40 = "nw_protocol_http3_uni_stream_input_available";
        __int16 v41 = 2082;
        char v42 = (nw_protocol *)v17;
        unint64_t v9 = "%{public}s protocol %{public}s has invalid input_available callback";
      }
      else if (v37)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v14 = __nwlog_obj();
        os_log_type_t v15 = type;
        BOOL v24 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v24)
          {
            uint64_t v25 = handle->default_input_handler;
            uint64_t v26 = "invalid";
            if (v25)
            {
              uint64_t v27 = v25->identifier->name;
              if (v27) {
                uint64_t v26 = v27;
              }
            }
            *(_DWORD *)buf = 136446722;
            uint64_t v40 = "nw_protocol_http3_uni_stream_input_available";
            __int16 v41 = 2082;
            char v42 = (nw_protocol *)v26;
            __int16 v43 = 2082;
            uint64_t v44 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s protocol %{public}s has invalid input_available callback, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(backtrace_string);
LABEL_72:
          if (v6) {
            goto LABEL_73;
          }
          return;
        }
        if (!v24) {
          goto LABEL_72;
        }
        os_log_type_t v34 = handle->default_input_handler;
        uint64_t v35 = "invalid";
        if (v34)
        {
          size_t v36 = v34->identifier->name;
          if (v36) {
            uint64_t v35 = v36;
          }
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v40 = "nw_protocol_http3_uni_stream_input_available";
        __int16 v41 = 2082;
        char v42 = (nw_protocol *)v35;
        unint64_t v9 = "%{public}s protocol %{public}s has invalid input_available callback, no backtrace";
      }
      else
      {
        uint64_t v14 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (!os_log_type_enabled(v14, type)) {
          goto LABEL_72;
        }
        uint64_t v28 = handle->default_input_handler;
        uint64_t v29 = "invalid";
        if (v28)
        {
          uint64_t v30 = v28->identifier->name;
          if (v30) {
            uint64_t v29 = v30;
          }
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v40 = "nw_protocol_http3_uni_stream_input_available";
        __int16 v41 = 2082;
        char v42 = (nw_protocol *)v29;
        unint64_t v9 = "%{public}s protocol %{public}s has invalid input_available callback, backtrace limit exceeded";
      }
      uint64_t v31 = v14;
      os_log_type_t v32 = v15;
      uint32_t v33 = 22;
LABEL_71:
      _os_log_impl(&dword_1830D4000, v31, v32, v9, buf, v33);
      goto LABEL_72;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v40 = "nw_protocol_http3_uni_stream_input_available";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (!__nwlog_fault(v6, &type, &v37)) {
      goto LABEL_72;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_72;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v40 = "nw_protocol_http3_uni_stream_input_available";
      unint64_t v9 = "%{public}s called with null http3_stream";
      goto LABEL_64;
    }
    if (!v37)
    {
      unsigned int v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_72;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v40 = "nw_protocol_http3_uni_stream_input_available";
      unint64_t v9 = "%{public}s called with null http3_stream, backtrace limit exceeded";
      goto LABEL_64;
    }
    uint64_t v19 = (char *)__nw_create_backtrace_string();
    unsigned int v7 = __nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v22 = os_log_type_enabled(v7, type);
    if (!v19)
    {
      if (!v22) {
        goto LABEL_72;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v40 = "nw_protocol_http3_uni_stream_input_available";
      unint64_t v9 = "%{public}s called with null http3_stream, no backtrace";
      goto LABEL_64;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v40 = "nw_protocol_http3_uni_stream_input_available";
      __int16 v41 = 2082;
      char v42 = (nw_protocol *)v19;
      uint64_t v21 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
      goto LABEL_40;
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v40 = "nw_protocol_http3_uni_stream_input_available";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (!__nwlog_fault(v6, &type, &v37)) {
      goto LABEL_72;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_72;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v40 = "nw_protocol_http3_uni_stream_input_available";
      unint64_t v9 = "%{public}s called with null protocol";
LABEL_64:
      uint64_t v31 = v7;
      os_log_type_t v32 = v8;
      uint32_t v33 = 12;
      goto LABEL_71;
    }
    if (!v37)
    {
      unsigned int v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_72;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v40 = "nw_protocol_http3_uni_stream_input_available";
      unint64_t v9 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_64;
    }
    uint64_t v19 = (char *)__nw_create_backtrace_string();
    unsigned int v7 = __nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v20 = os_log_type_enabled(v7, type);
    if (!v19)
    {
      if (!v20) {
        goto LABEL_72;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v40 = "nw_protocol_http3_uni_stream_input_available";
      unint64_t v9 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_64;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v40 = "nw_protocol_http3_uni_stream_input_available";
      __int16 v41 = 2082;
      char v42 = (nw_protocol *)v19;
      uint64_t v21 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_40:
      _os_log_impl(&dword_1830D4000, v7, v8, v21, buf, 0x16u);
    }
  }
  free(v19);
  if (v6) {
LABEL_73:
  }
    free(v6);
}

void nw_protocol_http3_uni_stream_input_finished(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      if (gLogDatapath)
      {
        BOOL v20 = __nwlog_obj();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v55 = "nw_protocol_http3_uni_stream_input_finished";
          __int16 v56 = 2048;
          uint64_t v57 = (nw_protocol_identifier *)handle;
          _os_log_impl(&dword_1830D4000, v20, OS_LOG_TYPE_DEBUG, "%{public}s called on http3_uni_stream %p", buf, 0x16u);
        }
      }
      if ((*((unsigned char *)handle + 131) & 2) == 0) {
        return;
      }
      if ((*((unsigned char *)handle + 131) & 8) == 0)
      {
        uint64_t v4 = (nw_protocol *)*((void *)handle + 6);
        if (!v4
          || (callbacks = v4->callbacks) == 0
          || (input_finished = (void (*)(nw_protocol *, nw_protocol *))callbacks->input_finished) == 0)
        {
          __nwlog_obj();
          uint64_t v7 = *((void *)handle + 6);
          os_log_type_t v8 = "invalid";
          if (v7)
          {
            unint64_t v9 = *(const char **)(v7 + 16);
            if (v9) {
              os_log_type_t v8 = v9;
            }
          }
          *(_DWORD *)buf = 136446466;
          uint64_t v55 = "nw_protocol_http3_uni_stream_input_finished";
          __int16 v56 = 2082;
          uint64_t v57 = (nw_protocol_identifier *)v8;
          unint64_t v10 = (const char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v52 = 0;
          if (__nwlog_fault(v10, &type, &v52))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              unint64_t v11 = __nwlog_obj();
              os_log_type_t v12 = type;
              if (!os_log_type_enabled(v11, type)) {
                goto LABEL_93;
              }
              uint64_t v13 = *((void *)handle + 6);
              uint64_t v14 = "invalid";
              if (v13)
              {
                os_log_type_t v15 = *(const char **)(v13 + 16);
                if (v15) {
                  uint64_t v14 = v15;
                }
              }
              *(_DWORD *)buf = 136446466;
              uint64_t v55 = "nw_protocol_http3_uni_stream_input_finished";
              __int16 v56 = 2082;
              uint64_t v57 = (nw_protocol_identifier *)v14;
              unint64_t v16 = "%{public}s protocol %{public}s has invalid input_finished callback";
LABEL_91:
              char v42 = v11;
              os_log_type_t v43 = v12;
              uint32_t v44 = 22;
              goto LABEL_92;
            }
            if (!v52)
            {
              unint64_t v11 = __nwlog_obj();
              os_log_type_t v12 = type;
              if (!os_log_type_enabled(v11, type)) {
                goto LABEL_93;
              }
              uint64_t v39 = *((void *)handle + 6);
              uint64_t v40 = "invalid";
              if (v39)
              {
                __int16 v41 = *(const char **)(v39 + 16);
                if (v41) {
                  uint64_t v40 = v41;
                }
              }
              *(_DWORD *)buf = 136446466;
              uint64_t v55 = "nw_protocol_http3_uni_stream_input_finished";
              __int16 v56 = 2082;
              uint64_t v57 = (nw_protocol_identifier *)v40;
              unint64_t v16 = "%{public}s protocol %{public}s has invalid input_finished callback, backtrace limit exceeded";
              goto LABEL_91;
            }
            backtrace_string = (char *)__nw_create_backtrace_string();
            unint64_t v11 = __nwlog_obj();
            os_log_type_t v12 = type;
            BOOL v32 = os_log_type_enabled(v11, type);
            if (!backtrace_string)
            {
              if (!v32) {
                goto LABEL_93;
              }
              uint64_t v47 = *((void *)handle + 6);
              int v48 = "invalid";
              if (v47)
              {
                uint64_t v49 = *(const char **)(v47 + 16);
                if (v49) {
                  int v48 = v49;
                }
              }
              *(_DWORD *)buf = 136446466;
              uint64_t v55 = "nw_protocol_http3_uni_stream_input_finished";
              __int16 v56 = 2082;
              uint64_t v57 = (nw_protocol_identifier *)v48;
              unint64_t v16 = "%{public}s protocol %{public}s has invalid input_finished callback, no backtrace";
              goto LABEL_91;
            }
            if (v32)
            {
              uint64_t v33 = *((void *)handle + 6);
              os_log_type_t v34 = "invalid";
              if (v33)
              {
                uint64_t v35 = *(const char **)(v33 + 16);
                if (v35) {
                  os_log_type_t v34 = v35;
                }
              }
              *(_DWORD *)buf = 136446722;
              uint64_t v55 = "nw_protocol_http3_uni_stream_input_finished";
              __int16 v56 = 2082;
              uint64_t v57 = (nw_protocol_identifier *)v34;
              __int16 v58 = 2082;
              uint64_t v59 = backtrace_string;
              _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s protocol %{public}s has invalid input_finished callback, dumping backtrace:%{public}s", buf, 0x20u);
            }
            free(backtrace_string);
          }
LABEL_93:
          if (v10) {
            goto LABEL_94;
          }
          return;
        }
LABEL_22:
        input_finished(v4, a1);
        return;
      }
      uint64_t v17 = a1->callbacks;
      if (v17)
      {
        input_finished = (void (*)(nw_protocol *, nw_protocol *))v17->disconnect;
        if (input_finished)
        {
          uint64_t v4 = a1;
          goto LABEL_22;
        }
      }
      __nwlog_obj();
      identifier = a1->identifier;
      if (!identifier) {
        identifier = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v55 = "nw_protocol_http3_uni_stream_input_finished";
      __int16 v56 = 2082;
      uint64_t v57 = identifier;
      uint64_t v26 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v52 = 0;
      if (__nwlog_fault(v26, &type, &v52))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          uint64_t v27 = __nwlog_obj();
          os_log_type_t v28 = type;
          if (!os_log_type_enabled(v27, type)) {
            goto LABEL_101;
          }
          uint64_t v29 = a1->identifier;
          if (!v29) {
            uint64_t v29 = (nw_protocol_identifier *)"invalid";
          }
          *(_DWORD *)buf = 136446466;
          uint64_t v55 = "nw_protocol_http3_uni_stream_input_finished";
          __int16 v56 = 2082;
          uint64_t v57 = v29;
          uint64_t v30 = "%{public}s protocol %{public}s has invalid disconnect callback";
LABEL_100:
          _os_log_impl(&dword_1830D4000, v27, v28, v30, buf, 0x16u);
          goto LABEL_101;
        }
        if (!v52)
        {
          uint64_t v27 = __nwlog_obj();
          os_log_type_t v28 = type;
          BOOL v45 = os_log_type_enabled(v27, type);
          uint64_t v46 = (nw_protocol_identifier *)"invalid";
          if (!v45) {
            goto LABEL_101;
          }
          if (a1->identifier) {
            uint64_t v46 = a1->identifier;
          }
          *(_DWORD *)buf = 136446466;
          uint64_t v55 = "nw_protocol_http3_uni_stream_input_finished";
          __int16 v56 = 2082;
          uint64_t v57 = v46;
          uint64_t v30 = "%{public}s protocol %{public}s has invalid disconnect callback, backtrace limit exceeded";
          goto LABEL_100;
        }
        size_t v36 = (char *)__nw_create_backtrace_string();
        uint64_t v27 = __nwlog_obj();
        os_log_type_t v28 = type;
        BOOL v37 = os_log_type_enabled(v27, type);
        if (!v36)
        {
          unint64_t v51 = (nw_protocol_identifier *)"invalid";
          if (!v37) {
            goto LABEL_101;
          }
          if (a1->identifier) {
            unint64_t v51 = a1->identifier;
          }
          *(_DWORD *)buf = 136446466;
          uint64_t v55 = "nw_protocol_http3_uni_stream_input_finished";
          __int16 v56 = 2082;
          uint64_t v57 = v51;
          uint64_t v30 = "%{public}s protocol %{public}s has invalid disconnect callback, no backtrace";
          goto LABEL_100;
        }
        if (v37)
        {
          os_log_type_t v38 = (nw_protocol_identifier *)"invalid";
          if (a1->identifier) {
            os_log_type_t v38 = a1->identifier;
          }
          *(_DWORD *)buf = 136446722;
          uint64_t v55 = "nw_protocol_http3_uni_stream_input_finished";
          __int16 v56 = 2082;
          uint64_t v57 = v38;
          __int16 v58 = 2082;
          uint64_t v59 = v36;
          _os_log_impl(&dword_1830D4000, v27, v28, "%{public}s protocol %{public}s has invalid disconnect callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v36);
      }
LABEL_101:
      if (v26)
      {
        int v50 = (char *)v26;
        goto LABEL_95;
      }
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v55 = "nw_protocol_http3_uni_stream_input_finished";
    unint64_t v10 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v52 = 0;
    if (!__nwlog_fault(v10, &type, &v52)) {
      goto LABEL_93;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_93;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v55 = "nw_protocol_http3_uni_stream_input_finished";
      unint64_t v16 = "%{public}s called with null http3_stream";
      goto LABEL_81;
    }
    if (!v52)
    {
      char v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_93;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v55 = "nw_protocol_http3_uni_stream_input_finished";
      unint64_t v16 = "%{public}s called with null http3_stream, backtrace limit exceeded";
      goto LABEL_81;
    }
    uint64_t v21 = (char *)__nw_create_backtrace_string();
    char v18 = __nwlog_obj();
    os_log_type_t v19 = type;
    BOOL v24 = os_log_type_enabled(v18, type);
    if (!v21)
    {
      if (!v24) {
        goto LABEL_93;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v55 = "nw_protocol_http3_uni_stream_input_finished";
      unint64_t v16 = "%{public}s called with null http3_stream, no backtrace";
      goto LABEL_81;
    }
    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v55 = "nw_protocol_http3_uni_stream_input_finished";
      __int16 v56 = 2082;
      uint64_t v57 = (nw_protocol_identifier *)v21;
      uint64_t v23 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
      goto LABEL_42;
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v55 = "nw_protocol_http3_uni_stream_input_finished";
    unint64_t v10 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v52 = 0;
    if (!__nwlog_fault(v10, &type, &v52)) {
      goto LABEL_93;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_93;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v55 = "nw_protocol_http3_uni_stream_input_finished";
      unint64_t v16 = "%{public}s called with null protocol";
LABEL_81:
      char v42 = v18;
      os_log_type_t v43 = v19;
      uint32_t v44 = 12;
LABEL_92:
      _os_log_impl(&dword_1830D4000, v42, v43, v16, buf, v44);
      goto LABEL_93;
    }
    if (!v52)
    {
      char v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_93;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v55 = "nw_protocol_http3_uni_stream_input_finished";
      unint64_t v16 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_81;
    }
    uint64_t v21 = (char *)__nw_create_backtrace_string();
    char v18 = __nwlog_obj();
    os_log_type_t v19 = type;
    BOOL v22 = os_log_type_enabled(v18, type);
    if (!v21)
    {
      if (!v22) {
        goto LABEL_93;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v55 = "nw_protocol_http3_uni_stream_input_finished";
      unint64_t v16 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_81;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v55 = "nw_protocol_http3_uni_stream_input_finished";
      __int16 v56 = 2082;
      uint64_t v57 = (nw_protocol_identifier *)v21;
      uint64_t v23 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_42:
      _os_log_impl(&dword_1830D4000, v18, v19, v23, buf, 0x16u);
    }
  }
  free(v21);
  if (v10)
  {
LABEL_94:
    int v50 = (char *)v10;
LABEL_95:
    free(v50);
  }
}

void nw_protocol_http3_uni_stream_error(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v41 = "nw_protocol_http3_uni_stream_error";
    unint64_t v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v38 = 0;
    if (!__nwlog_fault(v10, &type, &v38)) {
      goto LABEL_74;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_74;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v41 = "nw_protocol_http3_uni_stream_error";
      unint64_t v16 = "%{public}s called with null protocol";
LABEL_72:
      uint64_t v35 = v17;
      os_log_type_t v36 = v18;
      uint32_t v37 = 12;
      goto LABEL_73;
    }
    if (!v38)
    {
      uint64_t v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_74;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v41 = "nw_protocol_http3_uni_stream_error";
      unint64_t v16 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_72;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v17 = __nwlog_obj();
    os_log_type_t v18 = type;
    BOOL v26 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (!v26) {
        goto LABEL_74;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v41 = "nw_protocol_http3_uni_stream_error";
      unint64_t v16 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_72;
    }
    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v41 = "nw_protocol_http3_uni_stream_error";
      __int16 v42 = 2082;
      os_log_type_t v43 = backtrace_string;
      uint64_t v27 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_50:
      _os_log_impl(&dword_1830D4000, v17, v18, v27, buf, 0x16u);
    }
LABEL_51:
    free(backtrace_string);
    if (!v10) {
      return;
    }
LABEL_75:
    free(v10);
    return;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v41 = "nw_protocol_http3_uni_stream_error";
    unint64_t v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v38 = 0;
    if (!__nwlog_fault(v10, &type, &v38)) {
      goto LABEL_74;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_74;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v41 = "nw_protocol_http3_uni_stream_error";
      unint64_t v16 = "%{public}s called with null http3_stream";
      goto LABEL_72;
    }
    if (!v38)
    {
      uint64_t v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_74;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v41 = "nw_protocol_http3_uni_stream_error";
      unint64_t v16 = "%{public}s called with null http3_stream, backtrace limit exceeded";
      goto LABEL_72;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v17 = __nwlog_obj();
    os_log_type_t v18 = type;
    BOOL v28 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (!v28) {
        goto LABEL_74;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v41 = "nw_protocol_http3_uni_stream_error";
      unint64_t v16 = "%{public}s called with null http3_stream, no backtrace";
      goto LABEL_72;
    }
    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v41 = "nw_protocol_http3_uni_stream_error";
      __int16 v42 = 2082;
      os_log_type_t v43 = backtrace_string;
      uint64_t v27 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
      goto LABEL_50;
    }
    goto LABEL_51;
  }
  if (gLogDatapath)
  {
    os_log_type_t v19 = __nwlog_obj();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      __int16 v41 = "nw_protocol_http3_uni_stream_error";
      __int16 v42 = 2048;
      os_log_type_t v43 = handle;
      _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_DEBUG, "%{public}s called on http3_uni_stream %p", buf, 0x16u);
    }
  }
  if ((*((unsigned char *)handle + 131) & 3) != 0 && (*((unsigned char *)handle + 131) & 8) == 0)
  {
    uint64_t v4 = handle[6];
    if (v4)
    {
      uint64_t v5 = *(void *)(v4 + 24);
      if (v5)
      {
        uint64_t v6 = *(void (**)(void))(v5 + 56);
        if (v6)
        {
          v6();
          return;
        }
      }
    }
    __nwlog_obj();
    uint64_t v7 = handle[6];
    os_log_type_t v8 = "invalid";
    if (v7)
    {
      unint64_t v9 = *(const char **)(v7 + 16);
      if (v9) {
        os_log_type_t v8 = v9;
      }
    }
    *(_DWORD *)buf = 136446466;
    __int16 v41 = "nw_protocol_http3_uni_stream_error";
    __int16 v42 = 2082;
    os_log_type_t v43 = v8;
    unint64_t v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v38 = 0;
    if (__nwlog_fault(v10, &type, &v38))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        unint64_t v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (!os_log_type_enabled(v11, type)) {
          goto LABEL_74;
        }
        uint64_t v13 = handle[6];
        uint64_t v14 = "invalid";
        if (v13)
        {
          os_log_type_t v15 = *(const char **)(v13 + 16);
          if (v15) {
            uint64_t v14 = v15;
          }
        }
        *(_DWORD *)buf = 136446466;
        __int16 v41 = "nw_protocol_http3_uni_stream_error";
        __int16 v42 = 2082;
        os_log_type_t v43 = v14;
        unint64_t v16 = "%{public}s protocol %{public}s has invalid error callback";
LABEL_67:
        uint64_t v35 = v11;
        os_log_type_t v36 = v12;
        uint32_t v37 = 22;
LABEL_73:
        _os_log_impl(&dword_1830D4000, v35, v36, v16, buf, v37);
        goto LABEL_74;
      }
      if (!v38)
      {
        unint64_t v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (!os_log_type_enabled(v11, type)) {
          goto LABEL_74;
        }
        uint64_t v29 = handle[6];
        uint64_t v30 = "invalid";
        if (v29)
        {
          uint64_t v31 = *(const char **)(v29 + 16);
          if (v31) {
            uint64_t v30 = v31;
          }
        }
        *(_DWORD *)buf = 136446466;
        __int16 v41 = "nw_protocol_http3_uni_stream_error";
        __int16 v42 = 2082;
        os_log_type_t v43 = v30;
        unint64_t v16 = "%{public}s protocol %{public}s has invalid error callback, backtrace limit exceeded";
        goto LABEL_67;
      }
      BOOL v20 = (char *)__nw_create_backtrace_string();
      unint64_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v21 = os_log_type_enabled(v11, type);
      if (!v20)
      {
        if (!v21) {
          goto LABEL_74;
        }
        uint64_t v32 = handle[6];
        uint64_t v33 = "invalid";
        if (v32)
        {
          os_log_type_t v34 = *(const char **)(v32 + 16);
          if (v34) {
            uint64_t v33 = v34;
          }
        }
        *(_DWORD *)buf = 136446466;
        __int16 v41 = "nw_protocol_http3_uni_stream_error";
        __int16 v42 = 2082;
        os_log_type_t v43 = v33;
        unint64_t v16 = "%{public}s protocol %{public}s has invalid error callback, no backtrace";
        goto LABEL_67;
      }
      if (v21)
      {
        uint64_t v22 = handle[6];
        uint64_t v23 = "invalid";
        if (v22)
        {
          BOOL v24 = *(const char **)(v22 + 16);
          if (v24) {
            uint64_t v23 = v24;
          }
        }
        *(_DWORD *)buf = 136446722;
        __int16 v41 = "nw_protocol_http3_uni_stream_error";
        __int16 v42 = 2082;
        os_log_type_t v43 = v23;
        __int16 v44 = 2082;
        BOOL v45 = v20;
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s protocol %{public}s has invalid error callback, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(v20);
    }
LABEL_74:
    if (!v10) {
      return;
    }
    goto LABEL_75;
  }
}

void nw_protocol_http3_uni_stream_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v48 = "nw_protocol_http3_uni_stream_disconnected";
    BOOL v21 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (!__nwlog_fault(v21, &type, &v45)) {
      goto LABEL_94;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_94;
      }
      *(_DWORD *)buf = 136446210;
      int v48 = "nw_protocol_http3_uni_stream_disconnected";
      BOOL v24 = "%{public}s called with null protocol";
    }
    else if (v45)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      BOOL v32 = os_log_type_enabled(v22, type);
      if (backtrace_string)
      {
        if (v32)
        {
          *(_DWORD *)buf = 136446466;
          int v48 = "nw_protocol_http3_uni_stream_disconnected";
          __int16 v49 = 2082;
          int v50 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_94:
        if (!v21) {
          return;
        }
        goto LABEL_95;
      }
      if (!v32) {
        goto LABEL_94;
      }
      *(_DWORD *)buf = 136446210;
      int v48 = "nw_protocol_http3_uni_stream_disconnected";
      BOOL v24 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      uint64_t v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_94;
      }
      *(_DWORD *)buf = 136446210;
      int v48 = "nw_protocol_http3_uni_stream_disconnected";
      BOOL v24 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_93;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v48 = "nw_protocol_http3_uni_stream_disconnected";
    BOOL v21 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (!__nwlog_fault(v21, &type, &v45)) {
      goto LABEL_94;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v45)
      {
        uint64_t v22 = __nwlog_obj();
        os_log_type_t v23 = type;
        if (!os_log_type_enabled(v22, type)) {
          goto LABEL_94;
        }
        *(_DWORD *)buf = 136446210;
        int v48 = "nw_protocol_http3_uni_stream_disconnected";
        BOOL v24 = "%{public}s called with null http3_stream, backtrace limit exceeded";
        goto LABEL_93;
      }
      uint64_t v33 = (char *)__nw_create_backtrace_string();
      uint64_t v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      BOOL v34 = os_log_type_enabled(v22, type);
      if (!v33)
      {
        if (!v34) {
          goto LABEL_94;
        }
        *(_DWORD *)buf = 136446210;
        int v48 = "nw_protocol_http3_uni_stream_disconnected";
        BOOL v24 = "%{public}s called with null http3_stream, no backtrace";
        goto LABEL_93;
      }
      if (v34)
      {
        *(_DWORD *)buf = 136446466;
        int v48 = "nw_protocol_http3_uni_stream_disconnected";
        __int16 v49 = 2082;
        int v50 = v33;
        uint64_t v35 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
LABEL_65:
        _os_log_impl(&dword_1830D4000, v22, v23, v35, buf, 0x16u);
      }
LABEL_66:
      free(v33);
      if (!v21) {
        return;
      }
LABEL_95:
      os_log_type_t v43 = (char *)v21;
      goto LABEL_96;
    }
    uint64_t v22 = __nwlog_obj();
    os_log_type_t v23 = type;
    if (!os_log_type_enabled(v22, type)) {
      goto LABEL_94;
    }
    *(_DWORD *)buf = 136446210;
    int v48 = "nw_protocol_http3_uni_stream_disconnected";
    BOOL v24 = "%{public}s called with null http3_stream";
LABEL_93:
    _os_log_impl(&dword_1830D4000, v22, v23, v24, buf, 0xCu);
    goto LABEL_94;
  }
  if (!handle[9])
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v48 = "nw_protocol_http3_uni_stream_disconnected";
    BOOL v21 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (!__nwlog_fault(v21, &type, &v45)) {
      goto LABEL_94;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_94;
      }
      *(_DWORD *)buf = 136446210;
      int v48 = "nw_protocol_http3_uni_stream_disconnected";
      BOOL v24 = "%{public}s called with null http3_stream->http3_connection";
      goto LABEL_93;
    }
    if (!v45)
    {
      uint64_t v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_94;
      }
      *(_DWORD *)buf = 136446210;
      int v48 = "nw_protocol_http3_uni_stream_disconnected";
      BOOL v24 = "%{public}s called with null http3_stream->http3_connection, backtrace limit exceeded";
      goto LABEL_93;
    }
    uint64_t v33 = (char *)__nw_create_backtrace_string();
    uint64_t v22 = __nwlog_obj();
    os_log_type_t v23 = type;
    BOOL v36 = os_log_type_enabled(v22, type);
    if (!v33)
    {
      if (!v36) {
        goto LABEL_94;
      }
      *(_DWORD *)buf = 136446210;
      int v48 = "nw_protocol_http3_uni_stream_disconnected";
      BOOL v24 = "%{public}s called with null http3_stream->http3_connection, no backtrace";
      goto LABEL_93;
    }
    if (v36)
    {
      *(_DWORD *)buf = 136446466;
      int v48 = "nw_protocol_http3_uni_stream_disconnected";
      __int16 v49 = 2082;
      int v50 = v33;
      uint64_t v35 = "%{public}s called with null http3_stream->http3_connection, dumping backtrace:%{public}s";
      goto LABEL_65;
    }
    goto LABEL_66;
  }
  if (gLogDatapath)
  {
    uint64_t v25 = __nwlog_obj();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      int v48 = "nw_protocol_http3_uni_stream_disconnected";
      __int16 v49 = 2048;
      int v50 = handle;
      _os_log_impl(&dword_1830D4000, v25, OS_LOG_TYPE_DEBUG, "%{public}s called on http3_uni_stream %p", buf, 0x16u);
    }
  }
  char v3 = *((unsigned char *)handle + 131);
  if ((v3 & 1) == 0)
  {
    if ((*((unsigned char *)handle + 131) & 2) == 0) {
      return;
    }
    v3 &= ~2u;
    *((unsigned char *)handle + 131) = v3;
  }
  if ((v3 & 8) != 0)
  {
    if ((v3 & 4) == 0)
    {
      uint64_t v7 = handle[10];
      os_log_type_t v8 = (void *)handle[11];
      if (v7)
      {
        *(void *)(v7 + 88) = v8;
        os_log_type_t v8 = (void *)handle[11];
      }
      else
      {
        *(void *)(handle[9] + 904) = v8;
      }
      *os_log_type_t v8 = v7;
    }
    uint64_t v9 = handle[12];
    unint64_t v10 = *(void **)(handle[9] + 1256);
    v44[0] = MEMORY[0x1E4F143A8];
    v44[1] = 0x40000000;
    v44[2] = ___ZL41nw_protocol_http3_uni_stream_disconnectedP11nw_protocolS0__block_invoke;
    v44[3] = &unk_1E5247238;
    v44[4] = v9;
    nw_queue_context_async(v10, v44);
    return;
  }
  uint64_t v4 = handle[6];
  if (v4)
  {
    uint64_t v5 = *(void *)(v4 + 24);
    if (v5)
    {
      uint64_t v6 = *(void (**)(void))(v5 + 48);
      if (v6)
      {
        v6();
        return;
      }
    }
  }
  __nwlog_obj();
  uint64_t v11 = handle[6];
  os_log_type_t v12 = "invalid";
  if (v11)
  {
    uint64_t v13 = *(const char **)(v11 + 16);
    if (v13) {
      os_log_type_t v12 = v13;
    }
  }
  *(_DWORD *)buf = 136446466;
  int v48 = "nw_protocol_http3_uni_stream_disconnected";
  __int16 v49 = 2082;
  int v50 = v12;
  uint64_t v14 = (const char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v45 = 0;
  if (__nwlog_fault(v14, &type, &v45))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_85;
      }
      uint64_t v17 = handle[6];
      os_log_type_t v18 = "invalid";
      if (v17)
      {
        os_log_type_t v19 = *(const char **)(v17 + 16);
        if (v19) {
          os_log_type_t v18 = v19;
        }
      }
      *(_DWORD *)buf = 136446466;
      int v48 = "nw_protocol_http3_uni_stream_disconnected";
      __int16 v49 = 2082;
      int v50 = v18;
      BOOL v20 = "%{public}s protocol %{public}s has invalid disconnected callback";
LABEL_84:
      _os_log_impl(&dword_1830D4000, v15, v16, v20, buf, 0x16u);
      goto LABEL_85;
    }
    if (!v45)
    {
      os_log_type_t v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_85;
      }
      uint64_t v37 = handle[6];
      char v38 = "invalid";
      if (v37)
      {
        uint64_t v39 = *(const char **)(v37 + 16);
        if (v39) {
          char v38 = v39;
        }
      }
      *(_DWORD *)buf = 136446466;
      int v48 = "nw_protocol_http3_uni_stream_disconnected";
      __int16 v49 = 2082;
      int v50 = v38;
      BOOL v20 = "%{public}s protocol %{public}s has invalid disconnected callback, backtrace limit exceeded";
      goto LABEL_84;
    }
    BOOL v26 = (char *)__nw_create_backtrace_string();
    os_log_type_t v15 = __nwlog_obj();
    os_log_type_t v16 = type;
    BOOL v27 = os_log_type_enabled(v15, type);
    if (!v26)
    {
      if (!v27) {
        goto LABEL_85;
      }
      uint64_t v40 = handle[6];
      __int16 v41 = "invalid";
      if (v40)
      {
        __int16 v42 = *(const char **)(v40 + 16);
        if (v42) {
          __int16 v41 = v42;
        }
      }
      *(_DWORD *)buf = 136446466;
      int v48 = "nw_protocol_http3_uni_stream_disconnected";
      __int16 v49 = 2082;
      int v50 = v41;
      BOOL v20 = "%{public}s protocol %{public}s has invalid disconnected callback, no backtrace";
      goto LABEL_84;
    }
    if (v27)
    {
      uint64_t v28 = handle[6];
      uint64_t v29 = "invalid";
      if (v28)
      {
        uint64_t v30 = *(const char **)(v28 + 16);
        if (v30) {
          uint64_t v29 = v30;
        }
      }
      *(_DWORD *)buf = 136446722;
      int v48 = "nw_protocol_http3_uni_stream_disconnected";
      __int16 v49 = 2082;
      int v50 = v29;
      __int16 v51 = 2082;
      char v52 = v26;
      _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s protocol %{public}s has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x20u);
    }
    free(v26);
  }
LABEL_85:
  if (v14)
  {
    os_log_type_t v43 = (char *)v14;
LABEL_96:
    free(v43);
  }
}

void ___ZL41nw_protocol_http3_uni_stream_disconnectedP11nw_protocolS0__block_invoke(uint64_t a1)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  if (v1)
  {
    uint64_t v2 = v1;
    char v3 = (void *)(v1 + 104);
    if (gLogDatapath)
    {
      uint64_t v25 = __nwlog_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
        _os_log_impl(&dword_1830D4000, v25, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
      }
    }
    *(void *)buf = MEMORY[0x1E4F143A8];
    *(void *)&buf[8] = 0x40000000;
    *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_61444;
    uint64_t v35 = (char *)&__block_descriptor_tmp_30_61445;
    BOOL v36 = v3;
    char v37 = 0;
    uint64_t v4 = *v3;
    do
    {
      if (!v4) {
        break;
      }
      uint64_t v5 = *(void *)(v4 + 32);
      char v6 = (*(uint64_t (**)(unsigned char *))&buf[16])(buf);
      uint64_t v4 = v5;
    }
    while ((v6 & 1) != 0);
    uint64_t v7 = *(void *)(v2 + 32);
    if (v7)
    {
      uint64_t v8 = *(void *)(v7 + 24);
      if (v8)
      {
        uint64_t v9 = *(void (**)(void))(v8 + 8);
        if (v9)
        {
          v9();
LABEL_10:
          nw_protocol_http3_uni_stream_destroy(v2);
          return;
        }
      }
    }
    __nwlog_obj();
    uint64_t v10 = *(void *)(v2 + 32);
    uint64_t v11 = "invalid";
    if (v10)
    {
      os_log_type_t v12 = *(const char **)(v10 + 16);
      if (v12) {
        uint64_t v11 = v12;
      }
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_uni_stream_disconnected_block_invoke";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v11;
    uint64_t v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (__nwlog_fault(v13, &type, &v32))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v14 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (!os_log_type_enabled(v14, type)) {
          goto LABEL_43;
        }
        uint64_t v16 = *(void *)(v2 + 32);
        uint64_t v17 = "invalid";
        if (v16)
        {
          os_log_type_t v18 = *(const char **)(v16 + 16);
          if (v18) {
            uint64_t v17 = v18;
          }
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_uni_stream_disconnected_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v17;
        os_log_type_t v19 = "%{public}s protocol %{public}s has invalid remove_input_handler callback";
        goto LABEL_42;
      }
      if (!v32)
      {
        uint64_t v14 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (!os_log_type_enabled(v14, type)) {
          goto LABEL_43;
        }
        uint64_t v26 = *(void *)(v2 + 32);
        BOOL v27 = "invalid";
        if (v26)
        {
          uint64_t v28 = *(const char **)(v26 + 16);
          if (v28) {
            BOOL v27 = v28;
          }
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_uni_stream_disconnected_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v27;
        os_log_type_t v19 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, backtrace limit exceeded";
        goto LABEL_42;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v21 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v21)
        {
          uint64_t v22 = *(void *)(v2 + 32);
          os_log_type_t v23 = "invalid";
          if (v22)
          {
            BOOL v24 = *(const char **)(v22 + 16);
            if (v24) {
              os_log_type_t v23 = v24;
            }
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_http3_uni_stream_disconnected_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v23;
          *(_WORD *)&unsigned char buf[22] = 2082;
          uint64_t v35 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s protocol %{public}s has invalid remove_input_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(backtrace_string);
        goto LABEL_43;
      }
      if (v21)
      {
        uint64_t v29 = *(void *)(v2 + 32);
        uint64_t v30 = "invalid";
        if (v29)
        {
          uint64_t v31 = *(const char **)(v29 + 16);
          if (v31) {
            uint64_t v30 = v31;
          }
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_uni_stream_disconnected_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v30;
        os_log_type_t v19 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, no backtrace";
LABEL_42:
        _os_log_impl(&dword_1830D4000, v14, v15, v19, buf, 0x16u);
      }
    }
LABEL_43:
    if (v13) {
      free(v13);
    }
    goto LABEL_10;
  }
}

void nw_protocol_http3_uni_stream_connected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v41 = "nw_protocol_http3_uni_stream_connected";
    os_log_type_t v18 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v38 = 0;
    if (!__nwlog_fault(v18, &type, &v38)) {
      goto LABEL_75;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_75;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v41 = "nw_protocol_http3_uni_stream_connected";
      BOOL v21 = "%{public}s called with null protocol";
      goto LABEL_74;
    }
    if (!v38)
    {
      os_log_type_t v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_75;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v41 = "nw_protocol_http3_uni_stream_connected";
      BOOL v21 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_74;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v19 = __nwlog_obj();
    os_log_type_t v20 = type;
    BOOL v29 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (!v29) {
        goto LABEL_75;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v41 = "nw_protocol_http3_uni_stream_connected";
      BOOL v21 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_74;
    }
    if (v29)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v41 = "nw_protocol_http3_uni_stream_connected";
      __int16 v42 = 2082;
      os_log_type_t v43 = (nw_protocol *)backtrace_string;
      _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_75:
    if (!v18) {
      return;
    }
    goto LABEL_76;
  }
  handle = (nw_protocol *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v41 = "nw_protocol_http3_uni_stream_connected";
    os_log_type_t v18 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v38 = 0;
    if (!__nwlog_fault(v18, &type, &v38)) {
      goto LABEL_75;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_75;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v41 = "nw_protocol_http3_uni_stream_connected";
      BOOL v21 = "%{public}s called with null http3_stream";
      goto LABEL_74;
    }
    if (!v38)
    {
      os_log_type_t v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_75;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v41 = "nw_protocol_http3_uni_stream_connected";
      BOOL v21 = "%{public}s called with null http3_stream, backtrace limit exceeded";
      goto LABEL_74;
    }
    uint64_t v30 = (char *)__nw_create_backtrace_string();
    os_log_type_t v19 = __nwlog_obj();
    os_log_type_t v20 = type;
    BOOL v31 = os_log_type_enabled(v19, type);
    if (v30)
    {
      if (v31)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v41 = "nw_protocol_http3_uni_stream_connected";
        __int16 v42 = 2082;
        os_log_type_t v43 = (nw_protocol *)v30;
        _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s called with null http3_stream, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v30);
      if (!v18) {
        return;
      }
LABEL_76:
      free(v18);
      return;
    }
    if (v31)
    {
      *(_DWORD *)buf = 136446210;
      __int16 v41 = "nw_protocol_http3_uni_stream_connected";
      BOOL v21 = "%{public}s called with null http3_stream, no backtrace";
LABEL_74:
      _os_log_impl(&dword_1830D4000, v19, v20, v21, buf, 0xCu);
      goto LABEL_75;
    }
    goto LABEL_75;
  }
  if (gLogDatapath)
  {
    uint64_t v22 = __nwlog_obj();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      __int16 v41 = "nw_protocol_http3_uni_stream_connected";
      __int16 v42 = 2048;
      os_log_type_t v43 = handle;
      _os_log_impl(&dword_1830D4000, v22, OS_LOG_TYPE_DEBUG, "%{public}s called on http3_uni_stream %p", buf, 0x16u);
    }
  }
  if (handle->output_handler == a2)
  {
    if ((handle[2].flow_id[3] & 1) == 0) {
      handle[2].flow_id[3] |= 2u;
    }
    default_input_handler = handle->default_input_handler;
    if (default_input_handler)
    {
      callbacks = default_input_handler->callbacks;
      if (callbacks)
      {
        connected = (void (*)(void))callbacks->connected;
        if (connected)
        {
          connected();
LABEL_11:
          if ((handle[2].flow_id[3] & 1) == 0) {
            nw_protocol_http3_uni_stream_get_input_frames(handle, v7, 0, 0, 0xFFFFFFFF, 0);
          }
          return;
        }
      }
    }
    __nwlog_obj();
    uint64_t v8 = handle->default_input_handler;
    uint64_t v9 = "invalid";
    if (v8)
    {
      name = v8->identifier->name;
      if (name) {
        uint64_t v9 = name;
      }
    }
    *(_DWORD *)buf = 136446466;
    __int16 v41 = "nw_protocol_http3_uni_stream_connected";
    __int16 v42 = 2082;
    os_log_type_t v43 = (nw_protocol *)v9;
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v38 = 0;
    if (__nwlog_fault(v11, &type, &v38))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v12 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (!os_log_type_enabled(v12, type)) {
          goto LABEL_68;
        }
        uint64_t v14 = handle->default_input_handler;
        os_log_type_t v15 = "invalid";
        if (v14)
        {
          uint64_t v16 = v14->identifier->name;
          if (v16) {
            os_log_type_t v15 = v16;
          }
        }
        *(_DWORD *)buf = 136446466;
        __int16 v41 = "nw_protocol_http3_uni_stream_connected";
        __int16 v42 = 2082;
        os_log_type_t v43 = (nw_protocol *)v15;
        uint64_t v17 = "%{public}s protocol %{public}s has invalid connected callback";
        goto LABEL_67;
      }
      if (!v38)
      {
        os_log_type_t v12 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (!os_log_type_enabled(v12, type)) {
          goto LABEL_68;
        }
        char v32 = handle->default_input_handler;
        uint64_t v33 = "invalid";
        if (v32)
        {
          BOOL v34 = v32->identifier->name;
          if (v34) {
            uint64_t v33 = v34;
          }
        }
        *(_DWORD *)buf = 136446466;
        __int16 v41 = "nw_protocol_http3_uni_stream_connected";
        __int16 v42 = 2082;
        os_log_type_t v43 = (nw_protocol *)v33;
        uint64_t v17 = "%{public}s protocol %{public}s has invalid connected callback, backtrace limit exceeded";
        goto LABEL_67;
      }
      os_log_type_t v23 = (char *)__nw_create_backtrace_string();
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v24 = os_log_type_enabled(v12, type);
      if (v23)
      {
        if (v24)
        {
          uint64_t v25 = handle->default_input_handler;
          uint64_t v26 = "invalid";
          if (v25)
          {
            BOOL v27 = v25->identifier->name;
            if (v27) {
              uint64_t v26 = v27;
            }
          }
          *(_DWORD *)buf = 136446722;
          __int16 v41 = "nw_protocol_http3_uni_stream_connected";
          __int16 v42 = 2082;
          os_log_type_t v43 = (nw_protocol *)v26;
          __int16 v44 = 2082;
          char v45 = v23;
          _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s protocol %{public}s has invalid connected callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v23);
        goto LABEL_68;
      }
      if (v24)
      {
        uint64_t v35 = handle->default_input_handler;
        BOOL v36 = "invalid";
        if (v35)
        {
          char v37 = v35->identifier->name;
          if (v37) {
            BOOL v36 = v37;
          }
        }
        *(_DWORD *)buf = 136446466;
        __int16 v41 = "nw_protocol_http3_uni_stream_connected";
        __int16 v42 = 2082;
        os_log_type_t v43 = (nw_protocol *)v36;
        uint64_t v17 = "%{public}s protocol %{public}s has invalid connected callback, no backtrace";
LABEL_67:
        _os_log_impl(&dword_1830D4000, v12, v13, v17, buf, 0x16u);
      }
    }
LABEL_68:
    if (v11) {
      free(v11);
    }
    goto LABEL_11;
  }
}

void ___ZL31nw_protocol_http3_get_callbacksv_block_invoke()
{
  qword_1E8F6B3B0 = (uint64_t)nw_protocol_default_replace_input_handler;
  qword_1E8F6B4A8 = (uint64_t)nw_protocol_default_input_flush;
  qword_1E8F6B498 = (uint64_t)nw_protocol_default_get_message_properties;
  qword_1E8F6B448 = (uint64_t)nw_protocol_default_updated_path;
  qword_1E8F6B470 = (uint64_t)nw_protocol_default_get_output_interface;
  qword_1E8F6B478 = (uint64_t)nw_protocol_default_waiting_for_output;
  qword_1E8F6B480 = (uint64_t)nw_protocol_default_copy_info;
  qword_1E8F6B430 = (uint64_t)nw_protocol_default_register_notification;
  qword_1E8F6B438 = (uint64_t)nw_protocol_default_unregister_notification;
  qword_1E8F6B3B8 = (uint64_t)nw_protocol_http3_connect;
  qword_1E8F6B3C8 = (uint64_t)nw_protocol_http3_connected;
  qword_1E8F6B3C0 = (uint64_t)nw_protocol_http3_disconnect;
  qword_1E8F6B3D0 = (uint64_t)nw_protocol_http3_disconnected;
  qword_1E8F6B3D8 = (uint64_t)nw_protocol_http3_error;
  qword_1E8F6B460 = (uint64_t)nw_protocol_http3_output_finished;
  qword_1E8F6B458 = (uint64_t)nw_protocol_http3_input_finished;
  nw_protocol_http3_get_callbacks(void)::protocol_callbacks = (uint64_t)nw_protocol_http3_add_input_handler;
  qword_1E8F6B3A8 = (uint64_t)nw_protocol_http3_remove_input_handler;
  qword_1E8F6B3E0 = (uint64_t)nw_protocol_http3_input_available;
  qword_1E8F6B3E8 = (uint64_t)nw_protocol_http3_output_available;
  qword_1E8F6B3F0 = (uint64_t)nw_protocol_http3_get_input_frames;
  qword_1E8F6B3F8 = (uint64_t)nw_protocol_http3_uni_stream_get_output_frames;
  qword_1E8F6B400 = (uint64_t)nw_protocol_http3_uni_stream_finalize_output_frames;
  qword_1E8F6B488 = (uint64_t)nw_protocol_http3_add_listen_handler;
  qword_1E8F6B490 = (uint64_t)nw_protocol_http3_remove_listen_handler;
  qword_1E8F6B410 = (uint64_t)nw_protocol_http3_get_parameters;
  qword_1E8F6B420 = (uint64_t)nw_protocol_http3_get_local_endpoint;
  qword_1E8F6B428 = (uint64_t)nw_protocol_http3_get_remote_endpoint;
  qword_1E8F6B418 = (uint64_t)nw_protocol_http3_get_path;
  qword_1E8F6B440 = (uint64_t)nw_protocol_http3_notify;
  qword_1E8F6B408 = (uint64_t)nw_protocol_http3_link_state;
  qword_1E8F6B468 = (uint64_t)nw_protocol_http3_get_output_local_endpoint;
  qword_1E8F6B4A0 = (uint64_t)nw_protocol_http3_reset;
  qword_1E8F6B450 = (uint64_t)nw_protocol_http3_supports_external_data;
}

uint64_t nw_protocol_http3_supports_external_data(nw_protocol *a1)
{
  return 0;
}

uint64_t nw_protocol_http3_reset(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v21 = "nw_protocol_http3_reset";
    char v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (!__nwlog_fault(v3, &type, &v18)) {
      goto LABEL_16;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_16;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v21 = "nw_protocol_http3_reset";
      char v6 = "%{public}s called with null protocol";
      goto LABEL_14;
    }
    if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v15 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (!v15) {
          goto LABEL_38;
        }
        *(_DWORD *)buf = 136446466;
        BOOL v21 = "nw_protocol_http3_reset";
        __int16 v22 = 2082;
        os_log_type_t v23 = backtrace_string;
        uint64_t v16 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
        goto LABEL_37;
      }
      if (!v15) {
        goto LABEL_16;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v21 = "nw_protocol_http3_reset";
      char v6 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_16;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v21 = "nw_protocol_http3_reset";
      char v6 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_14:
    uint64_t v11 = v4;
    os_log_type_t v12 = v5;
LABEL_15:
    _os_log_impl(&dword_1830D4000, v11, v12, v6, buf, 0xCu);
    goto LABEL_16;
  }
  handle = a1->handle;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  if (!handle)
  {
    *(_DWORD *)buf = 136446210;
    BOOL v21 = "nw_protocol_http3_reset";
    char v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (!__nwlog_fault(v3, &type, &v18)) {
      goto LABEL_16;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_16;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v21 = "nw_protocol_http3_reset";
      char v6 = "%{public}s called with null http3";
      goto LABEL_14;
    }
    if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v17 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (!v17) {
          goto LABEL_38;
        }
        *(_DWORD *)buf = 136446466;
        BOOL v21 = "nw_protocol_http3_reset";
        __int16 v22 = 2082;
        os_log_type_t v23 = backtrace_string;
        uint64_t v16 = "%{public}s called with null http3, dumping backtrace:%{public}s";
LABEL_37:
        _os_log_impl(&dword_1830D4000, v4, v5, v16, buf, 0x16u);
LABEL_38:
        free(backtrace_string);
        if (!v3) {
          return 0;
        }
        goto LABEL_17;
      }
      if (!v17) {
        goto LABEL_16;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v21 = "nw_protocol_http3_reset";
      char v6 = "%{public}s called with null http3, no backtrace";
    }
    else
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_16;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v21 = "nw_protocol_http3_reset";
      char v6 = "%{public}s called with null http3, backtrace limit exceeded";
    }
    goto LABEL_14;
  }
  *(_DWORD *)buf = 136446210;
  BOOL v21 = "nw_protocol_http3_reset";
  char v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (!__nwlog_fault(v3, &type, &v18)) {
    goto LABEL_16;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = gLogObj;
    os_log_type_t v5 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
      goto LABEL_16;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v21 = "nw_protocol_http3_reset";
    char v6 = "%{public}s Reset is not supported on http3 connection";
    goto LABEL_14;
  }
  if (!v18)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = gLogObj;
    os_log_type_t v5 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
      goto LABEL_16;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v21 = "nw_protocol_http3_reset";
    char v6 = "%{public}s Reset is not supported on http3 connection, backtrace limit exceeded";
    goto LABEL_14;
  }
  uint64_t v7 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v8 = gLogObj;
  os_log_type_t v9 = type;
  BOOL v10 = os_log_type_enabled((os_log_t)gLogObj, type);
  if (v7)
  {
    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v21 = "nw_protocol_http3_reset";
      __int16 v22 = 2082;
      os_log_type_t v23 = v7;
      _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s Reset is not supported on http3 connection, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v7);
  }
  else if (v10)
  {
    *(_DWORD *)buf = 136446210;
    BOOL v21 = "nw_protocol_http3_reset";
    char v6 = "%{public}s Reset is not supported on http3 connection, no backtrace";
    uint64_t v11 = v8;
    os_log_type_t v12 = v9;
    goto LABEL_15;
  }
LABEL_16:
  if (v3) {
LABEL_17:
  }
    free(v3);
  return 0;
}

uint64_t nw_protocol_http3_get_output_local_endpoint(nw_protocol *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      uint64_t result = nw_protocol_get_output_local_endpoint((uint64_t)a1->output_handler);
      if (!result) {
        return handle[138];
      }
      return result;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v14 = "nw_protocol_http3_get_output_local_endpoint";
    char v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (!__nwlog_fault(v3, &type, &v11)) {
      goto LABEL_33;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v14 = "nw_protocol_http3_get_output_local_endpoint";
        char v6 = "%{public}s called with null http3";
        goto LABEL_32;
      }
      goto LABEL_33;
    }
    if (!v11)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v14 = "nw_protocol_http3_get_output_local_endpoint";
        char v6 = "%{public}s called with null http3, backtrace limit exceeded";
        goto LABEL_32;
      }
      goto LABEL_33;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v10 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v14 = "nw_protocol_http3_get_output_local_endpoint";
        char v6 = "%{public}s called with null http3, no backtrace";
        goto LABEL_32;
      }
      goto LABEL_33;
    }
    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v14 = "nw_protocol_http3_get_output_local_endpoint";
      __int16 v15 = 2082;
      uint64_t v16 = backtrace_string;
      os_log_type_t v9 = "%{public}s called with null http3, dumping backtrace:%{public}s";
      goto LABEL_22;
    }
    goto LABEL_23;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v14 = "nw_protocol_http3_get_output_local_endpoint";
  char v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (!__nwlog_fault(v3, &type, &v11)) {
    goto LABEL_33;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v11)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v14 = "nw_protocol_http3_get_output_local_endpoint";
        char v6 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_32;
      }
      goto LABEL_33;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v8 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v14 = "nw_protocol_http3_get_output_local_endpoint";
        char v6 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_32;
      }
      goto LABEL_33;
    }
    if (v8)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v14 = "nw_protocol_http3_get_output_local_endpoint";
      __int16 v15 = 2082;
      uint64_t v16 = backtrace_string;
      os_log_type_t v9 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_22:
      _os_log_impl(&dword_1830D4000, v4, v5, v9, buf, 0x16u);
    }
LABEL_23:
    free(backtrace_string);
    goto LABEL_33;
  }
  uint64_t v4 = __nwlog_obj();
  os_log_type_t v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    uint64_t v14 = "nw_protocol_http3_get_output_local_endpoint";
    char v6 = "%{public}s called with null protocol";
LABEL_32:
    _os_log_impl(&dword_1830D4000, v4, v5, v6, buf, 0xCu);
  }
LABEL_33:
  if (v3) {
    free(v3);
  }
  return 0;
}

void nw_protocol_http3_notify(uint64_t a1, uint64_t a2, int a3, unsigned char *a4, uint64_t a5)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v50 = "nw_protocol_http3_notify";
    char v37 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v47 = 0;
    if (!__nwlog_fault(v37, &type, &v47)) {
      goto LABEL_103;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v38 = __nwlog_obj();
      os_log_type_t v39 = type;
      if (!os_log_type_enabled(v38, type)) {
        goto LABEL_103;
      }
      *(_DWORD *)buf = 136446210;
      int v50 = "nw_protocol_http3_notify";
      uint64_t v40 = "%{public}s called with null protocol";
    }
    else if (v47)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v38 = __nwlog_obj();
      os_log_type_t v39 = type;
      BOOL v42 = os_log_type_enabled(v38, type);
      if (backtrace_string)
      {
        if (v42)
        {
          *(_DWORD *)buf = 136446466;
          int v50 = "nw_protocol_http3_notify";
          __int16 v51 = 2082;
          char v52 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v38, v39, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_103:
        if (!v37) {
          return;
        }
        goto LABEL_104;
      }
      if (!v42) {
        goto LABEL_103;
      }
      *(_DWORD *)buf = 136446210;
      int v50 = "nw_protocol_http3_notify";
      uint64_t v40 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      char v38 = __nwlog_obj();
      os_log_type_t v39 = type;
      if (!os_log_type_enabled(v38, type)) {
        goto LABEL_103;
      }
      *(_DWORD *)buf = 136446210;
      int v50 = "nw_protocol_http3_notify";
      uint64_t v40 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_102;
  }
  uint64_t v6 = *(void *)(a1 + 40);
  if (!v6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v50 = "nw_protocol_http3_notify";
    char v37 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v47 = 0;
    if (!__nwlog_fault(v37, &type, &v47)) {
      goto LABEL_103;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v47)
      {
        char v38 = __nwlog_obj();
        os_log_type_t v39 = type;
        if (!os_log_type_enabled(v38, type)) {
          goto LABEL_103;
        }
        *(_DWORD *)buf = 136446210;
        int v50 = "nw_protocol_http3_notify";
        uint64_t v40 = "%{public}s called with null http3, backtrace limit exceeded";
        goto LABEL_102;
      }
      os_log_type_t v43 = (char *)__nw_create_backtrace_string();
      char v38 = __nwlog_obj();
      os_log_type_t v39 = type;
      BOOL v44 = os_log_type_enabled(v38, type);
      if (!v43)
      {
        if (!v44) {
          goto LABEL_103;
        }
        *(_DWORD *)buf = 136446210;
        int v50 = "nw_protocol_http3_notify";
        uint64_t v40 = "%{public}s called with null http3, no backtrace";
        goto LABEL_102;
      }
      if (v44)
      {
        *(_DWORD *)buf = 136446466;
        int v50 = "nw_protocol_http3_notify";
        __int16 v51 = 2082;
        char v52 = v43;
        char v45 = "%{public}s called with null http3, dumping backtrace:%{public}s";
LABEL_87:
        _os_log_impl(&dword_1830D4000, v38, v39, v45, buf, 0x16u);
      }
LABEL_88:
      free(v43);
      if (!v37) {
        return;
      }
LABEL_104:
      free(v37);
      return;
    }
    char v38 = __nwlog_obj();
    os_log_type_t v39 = type;
    if (!os_log_type_enabled(v38, type)) {
      goto LABEL_103;
    }
    *(_DWORD *)buf = 136446210;
    int v50 = "nw_protocol_http3_notify";
    uint64_t v40 = "%{public}s called with null http3";
LABEL_102:
    _os_log_impl(&dword_1830D4000, v38, v39, v40, buf, 0xCu);
    goto LABEL_103;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v50 = "nw_protocol_http3_notify";
    char v37 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v47 = 0;
    if (!__nwlog_fault(v37, &type, &v47)) {
      goto LABEL_103;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v38 = __nwlog_obj();
      os_log_type_t v39 = type;
      if (!os_log_type_enabled(v38, type)) {
        goto LABEL_103;
      }
      *(_DWORD *)buf = 136446210;
      int v50 = "nw_protocol_http3_notify";
      uint64_t v40 = "%{public}s called with null other_protocol";
      goto LABEL_102;
    }
    if (!v47)
    {
      char v38 = __nwlog_obj();
      os_log_type_t v39 = type;
      if (!os_log_type_enabled(v38, type)) {
        goto LABEL_103;
      }
      *(_DWORD *)buf = 136446210;
      int v50 = "nw_protocol_http3_notify";
      uint64_t v40 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_102;
    }
    os_log_type_t v43 = (char *)__nw_create_backtrace_string();
    char v38 = __nwlog_obj();
    os_log_type_t v39 = type;
    BOOL v46 = os_log_type_enabled(v38, type);
    if (!v43)
    {
      if (!v46) {
        goto LABEL_103;
      }
      *(_DWORD *)buf = 136446210;
      int v50 = "nw_protocol_http3_notify";
      uint64_t v40 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_102;
    }
    if (v46)
    {
      *(_DWORD *)buf = 136446466;
      int v50 = "nw_protocol_http3_notify";
      __int16 v51 = 2082;
      char v52 = v43;
      char v45 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_87;
    }
    goto LABEL_88;
  }
  switch(a3)
  {
    case 12:
      if ((*(_WORD *)(v6 + 1373) & 8) == 0)
      {
        nw_http3_async_close_connection_if_no_stream(*(void *)(a1 + 40));
        nw_http3_notify_do_not_reuse(v6);
      }
      return;
    case 13:
      int v7 = *(unsigned __int16 *)(v6 + 1373) | (*(unsigned __int8 *)(v6 + 1375) << 16);
      if ((v7 & 0x100000) == 0 && *(void *)(v6 + 1240) && *(_DWORD *)(v6 + 1276))
      {
        if ((v7 & 0x400000) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v8 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          {
            int v9 = *(_DWORD *)(v6 + 1280);
            *(_DWORD *)buf = 136446978;
            int v50 = "nw_protocol_http3_notify";
            __int16 v51 = 2082;
            char v52 = (char *)(v6 + 1289);
            __int16 v53 = 2080;
            int v54 = " ";
            __int16 v55 = 1024;
            int v56 = v9;
            _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> increasing QUIC keepalive frequency due to data stall", buf, 0x26u);
          }
        }
        *(unsigned char *)(v6 + 1375) |= 0x10u;
        nw_quic_connection_set_keepalive(*(void **)(v6 + 1240), 2);
      }
      uint64_t v10 = *(void *)(a1 + 32);
      if (v10)
      {
        uint64_t v11 = *(void *)(v10 + 24);
        if (v11)
        {
          os_log_type_t v12 = *(void (**)(void))(v11 + 160);
          if (v12) {
            goto LABEL_55;
          }
        }
      }
      return;
    case 16:
      if (!a4 || a5 != 1) {
        goto LABEL_52;
      }
      if (!*a4)
      {
        BOOL v27 = (_WORD *)(v6 + 1373);
        int v28 = *(unsigned __int16 *)(v6 + 1373) | (*(unsigned __int8 *)(v6 + 1375) << 16);
        if ((v28 & 0x200000) != 0 && *(void *)(v6 + 1240))
        {
          __int16 v15 = (void **)(v6 + 1240);
          if ((v28 & 0x400000) == 0)
          {
            BOOL v29 = __nwlog_obj();
            if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
            {
              int v30 = *(_DWORD *)(v6 + 1280);
              *(_DWORD *)buf = 136446978;
              int v50 = "nw_protocol_http3_notify";
              __int16 v51 = 2082;
              char v52 = (char *)(v6 + 1289);
              __int16 v53 = 2080;
              int v54 = " ";
              __int16 v55 = 1024;
              int v56 = v30;
              _os_log_impl(&dword_1830D4000, v29, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> re-enabling QUIC keepalives due to connection reuse", buf, 0x26u);
            }
          }
          int v31 = (unsigned __int16)*v27;
          unsigned int v32 = (v31 | (*(unsigned __int8 *)(v6 + 1375) << 16)) & 0xFFDFFFFF;
          _WORD *v27 = v31;
          *(unsigned char *)(v6 + 1375) = BYTE2(v32);
          __int16 v18 = -1;
          goto LABEL_51;
        }
LABEL_52:
        uint64_t v33 = *(void *)(a1 + 32);
        if (v33)
        {
          uint64_t v34 = *(void *)(v33 + 24);
          if (v34)
          {
            os_log_type_t v12 = *(void (**)(void))(v34 + 160);
            if (v12) {
LABEL_55:
            }
              v12();
          }
        }
        return;
      }
      uint64_t v13 = *(void *)(v6 + 880);
      if (!v13)
      {
LABEL_26:
        int v14 = *(unsigned __int16 *)(v6 + 1373) | (*(unsigned __int8 *)(v6 + 1375) << 16);
        if ((v14 & 0x200000) == 0 && *(void *)(v6 + 1240) && *(_DWORD *)(v6 + 1276) == 2)
        {
          __int16 v15 = (void **)(v6 + 1240);
          if ((v14 & 0x400000) == 0)
          {
            uint64_t v16 = __nwlog_obj();
            if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
            {
              int v17 = *(_DWORD *)(v6 + 1280);
              *(_DWORD *)buf = 136446978;
              int v50 = "nw_protocol_http3_notify";
              __int16 v51 = 2082;
              char v52 = (char *)(v6 + 1289);
              __int16 v53 = 2080;
              int v54 = " ";
              __int16 v55 = 1024;
              int v56 = v17;
              _os_log_impl(&dword_1830D4000, v16, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> disabling QUIC keepalives due to idleness", buf, 0x26u);
            }
          }
          __int16 v18 = 0;
          *(unsigned char *)(v6 + 1375) |= 0x20u;
LABEL_51:
          nw_quic_connection_set_keepalive(*v15, v18);
          goto LABEL_52;
        }
        goto LABEL_52;
      }
      while ((*(_WORD *)(v13 + 736) & 0x2000) != 0)
      {
        uint64_t v13 = *(void *)(v13 + 544);
        if (!v13) {
          goto LABEL_26;
        }
      }
      return;
    case 18:
      os_log_type_t v19 = (_WORD *)(v6 + 1373);
      int v20 = *(unsigned __int16 *)(v6 + 1373);
      int v21 = v20 | (*(unsigned __int8 *)(v6 + 1375) << 16);
      if ((v20 & 8) == 0 && a4 && a5 == 1)
      {
        if (*a4)
        {
          if ((v21 & 0x400000) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            __int16 v22 = gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
            {
              int v23 = *(_DWORD *)(v6 + 1280);
              *(_DWORD *)buf = 136446978;
              int v50 = "nw_protocol_http3_notify";
              __int16 v51 = 2082;
              char v52 = (char *)(v6 + 1289);
              __int16 v53 = 2080;
              int v54 = " ";
              __int16 v55 = 1024;
              int v56 = v23;
              _os_log_impl(&dword_1830D4000, v22, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Path recovered from lower protocol, recommending that new flows join", buf, 0x26u);
            }
          }
          unsigned int v24 = ((unsigned __int16)*v19 | (*(unsigned __int8 *)(v6 + 1375) << 16)) & 0xFFF7FFFF;
        }
        else
        {
          if ((v21 & 0x400000) == 0)
          {
            uint64_t v35 = __nwlog_obj();
            if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
            {
              int v36 = *(_DWORD *)(v6 + 1280);
              *(_DWORD *)buf = 136446978;
              int v50 = "nw_protocol_http3_notify";
              __int16 v51 = 2082;
              char v52 = (char *)(v6 + 1289);
              __int16 v53 = 2080;
              int v54 = " ";
              __int16 v55 = 1024;
              int v56 = v36;
              _os_log_impl(&dword_1830D4000, v35, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Bad path from lower protocol, recommending that new flows not join", buf, 0x26u);
            }
          }
          unsigned int v24 = (unsigned __int16)*v19 | (*(unsigned __int8 *)(v6 + 1375) << 16) | 0x80000;
        }
        *os_log_type_t v19 = v24;
        *(unsigned char *)(v6 + 1375) = BYTE2(v24);
      }
      return;
    case 22:
      if (((*(unsigned __int16 *)(v6 + 1373) | (*(unsigned __int8 *)(v6 + 1375) << 16)) & 0x400000) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v25 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        {
          int v26 = *(_DWORD *)(v6 + 1280);
          *(_DWORD *)buf = 136446978;
          int v50 = "nw_protocol_http3_notify";
          __int16 v51 = 2082;
          char v52 = (char *)(v6 + 1289);
          __int16 v53 = 2080;
          int v54 = " ";
          __int16 v55 = 1024;
          int v56 = v26;
          _os_log_impl(&dword_1830D4000, v25, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> restart received, assuming connection closed", buf, 0x26u);
        }
      }
      *(_WORD *)(v6 + 1373) |= 8u;
      return;
    default:
      return;
  }
}

uint64_t nw_protocol_http3_get_path(nw_protocol *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    handle = a1->handle;
    if (handle) {
      return handle[139];
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v14 = "nw_protocol_http3_get_path";
    char v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (!__nwlog_fault(v3, &type, &v11)) {
      goto LABEL_32;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        int v14 = "nw_protocol_http3_get_path";
        uint64_t v6 = "%{public}s called with null http3";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (!v11)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        int v14 = "nw_protocol_http3_get_path";
        uint64_t v6 = "%{public}s called with null http3, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v10 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        int v14 = "nw_protocol_http3_get_path";
        uint64_t v6 = "%{public}s called with null http3, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      int v14 = "nw_protocol_http3_get_path";
      __int16 v15 = 2082;
      uint64_t v16 = backtrace_string;
      int v9 = "%{public}s called with null http3, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
    goto LABEL_22;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v14 = "nw_protocol_http3_get_path";
  char v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (!__nwlog_fault(v3, &type, &v11)) {
    goto LABEL_32;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v11)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        int v14 = "nw_protocol_http3_get_path";
        uint64_t v6 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v8 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        int v14 = "nw_protocol_http3_get_path";
        uint64_t v6 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v8)
    {
      *(_DWORD *)buf = 136446466;
      int v14 = "nw_protocol_http3_get_path";
      __int16 v15 = 2082;
      uint64_t v16 = backtrace_string;
      int v9 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_1830D4000, v4, v5, v9, buf, 0x16u);
    }
LABEL_22:
    free(backtrace_string);
    goto LABEL_32;
  }
  uint64_t v4 = __nwlog_obj();
  os_log_type_t v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    int v14 = "nw_protocol_http3_get_path";
    uint64_t v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_1830D4000, v4, v5, v6, buf, 0xCu);
  }
LABEL_32:
  if (v3) {
    free(v3);
  }
  return 0;
}

uint64_t nw_protocol_http3_get_remote_endpoint(nw_protocol *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    handle = a1->handle;
    if (handle) {
      return handle[137];
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v14 = "nw_protocol_http3_get_remote_endpoint";
    char v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (!__nwlog_fault(v3, &type, &v11)) {
      goto LABEL_32;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        int v14 = "nw_protocol_http3_get_remote_endpoint";
        uint64_t v6 = "%{public}s called with null http3";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (!v11)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        int v14 = "nw_protocol_http3_get_remote_endpoint";
        uint64_t v6 = "%{public}s called with null http3, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v10 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        int v14 = "nw_protocol_http3_get_remote_endpoint";
        uint64_t v6 = "%{public}s called with null http3, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      int v14 = "nw_protocol_http3_get_remote_endpoint";
      __int16 v15 = 2082;
      uint64_t v16 = backtrace_string;
      int v9 = "%{public}s called with null http3, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
    goto LABEL_22;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v14 = "nw_protocol_http3_get_remote_endpoint";
  char v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (!__nwlog_fault(v3, &type, &v11)) {
    goto LABEL_32;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v11)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        int v14 = "nw_protocol_http3_get_remote_endpoint";
        uint64_t v6 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v8 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        int v14 = "nw_protocol_http3_get_remote_endpoint";
        uint64_t v6 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v8)
    {
      *(_DWORD *)buf = 136446466;
      int v14 = "nw_protocol_http3_get_remote_endpoint";
      __int16 v15 = 2082;
      uint64_t v16 = backtrace_string;
      int v9 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_1830D4000, v4, v5, v9, buf, 0x16u);
    }
LABEL_22:
    free(backtrace_string);
    goto LABEL_32;
  }
  uint64_t v4 = __nwlog_obj();
  os_log_type_t v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    int v14 = "nw_protocol_http3_get_remote_endpoint";
    uint64_t v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_1830D4000, v4, v5, v6, buf, 0xCu);
  }
LABEL_32:
  if (v3) {
    free(v3);
  }
  return 0;
}

uint64_t nw_protocol_http3_get_local_endpoint(nw_protocol *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    handle = a1->handle;
    if (handle) {
      return handle[138];
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v14 = "nw_protocol_http3_get_local_endpoint";
    char v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (!__nwlog_fault(v3, &type, &v11)) {
      goto LABEL_32;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        int v14 = "nw_protocol_http3_get_local_endpoint";
        uint64_t v6 = "%{public}s called with null http3";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (!v11)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        int v14 = "nw_protocol_http3_get_local_endpoint";
        uint64_t v6 = "%{public}s called with null http3, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v10 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        int v14 = "nw_protocol_http3_get_local_endpoint";
        uint64_t v6 = "%{public}s called with null http3, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      int v14 = "nw_protocol_http3_get_local_endpoint";
      __int16 v15 = 2082;
      uint64_t v16 = backtrace_string;
      int v9 = "%{public}s called with null http3, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
    goto LABEL_22;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v14 = "nw_protocol_http3_get_local_endpoint";
  char v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (!__nwlog_fault(v3, &type, &v11)) {
    goto LABEL_32;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v11)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        int v14 = "nw_protocol_http3_get_local_endpoint";
        uint64_t v6 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v8 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        int v14 = "nw_protocol_http3_get_local_endpoint";
        uint64_t v6 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v8)
    {
      *(_DWORD *)buf = 136446466;
      int v14 = "nw_protocol_http3_get_local_endpoint";
      __int16 v15 = 2082;
      uint64_t v16 = backtrace_string;
      int v9 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_1830D4000, v4, v5, v9, buf, 0x16u);
    }
LABEL_22:
    free(backtrace_string);
    goto LABEL_32;
  }
  uint64_t v4 = __nwlog_obj();
  os_log_type_t v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    int v14 = "nw_protocol_http3_get_local_endpoint";
    uint64_t v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_1830D4000, v4, v5, v6, buf, 0xCu);
  }
LABEL_32:
  if (v3) {
    free(v3);
  }
  return 0;
}

uint64_t nw_protocol_http3_get_parameters(nw_protocol *a1)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    handle = (char *)a1->handle;
    if (handle)
    {
      if (((*(unsigned __int16 *)(handle + 1373) | (handle[1375] << 16)) & 0x400000) == 0)
      {
        if (gLogDatapath)
        {
          BOOL v8 = __nwlog_obj();
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
          {
            int v9 = *((_DWORD *)handle + 320);
            *(_DWORD *)buf = 136447490;
            uint64_t v17 = "nw_protocol_http3_get_parameters";
            __int16 v18 = 2082;
            os_log_type_t v19 = handle + 1289;
            __int16 v20 = 2080;
            int v21 = " ";
            __int16 v22 = 1024;
            int v23 = v9;
            __int16 v24 = 2048;
            uint64_t v25 = a1;
            __int16 v26 = 2048;
            BOOL v27 = handle;
            _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called with protocol %p (control_outbound_protocol is %p)", buf, 0x3Au);
          }
        }
      }
      uint64_t result = *((void *)handle + 141);
      if (!result) {
        return *((void *)handle + 140);
      }
      return result;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v17 = "nw_protocol_http3_get_parameters";
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (!__nwlog_fault(v4, &type, &v14)) {
      goto LABEL_37;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_protocol_http3_get_parameters";
        int v7 = "%{public}s called with null http3";
        goto LABEL_36;
      }
      goto LABEL_37;
    }
    if (!v14)
    {
      os_log_type_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_protocol_http3_get_parameters";
        int v7 = "%{public}s called with null http3, backtrace limit exceeded";
        goto LABEL_36;
      }
      goto LABEL_37;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v5 = __nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v13 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_protocol_http3_get_parameters";
        int v7 = "%{public}s called with null http3, no backtrace";
        goto LABEL_36;
      }
      goto LABEL_37;
    }
    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v17 = "nw_protocol_http3_get_parameters";
      __int16 v18 = 2082;
      os_log_type_t v19 = backtrace_string;
      os_log_type_t v12 = "%{public}s called with null http3, dumping backtrace:%{public}s";
      goto LABEL_26;
    }
    goto LABEL_27;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_protocol_http3_get_parameters";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (!__nwlog_fault(v4, &type, &v14)) {
    goto LABEL_37;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v14)
    {
      os_log_type_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_protocol_http3_get_parameters";
        int v7 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_36;
      }
      goto LABEL_37;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v5 = __nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v11 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_protocol_http3_get_parameters";
        int v7 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_36;
      }
      goto LABEL_37;
    }
    if (v11)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v17 = "nw_protocol_http3_get_parameters";
      __int16 v18 = 2082;
      os_log_type_t v19 = backtrace_string;
      os_log_type_t v12 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_26:
      _os_log_impl(&dword_1830D4000, v5, v6, v12, buf, 0x16u);
    }
LABEL_27:
    free(backtrace_string);
    goto LABEL_37;
  }
  os_log_type_t v5 = __nwlog_obj();
  os_log_type_t v6 = type;
  if (os_log_type_enabled(v5, type))
  {
    *(_DWORD *)buf = 136446210;
    uint64_t v17 = "nw_protocol_http3_get_parameters";
    int v7 = "%{public}s called with null protocol";
LABEL_36:
    _os_log_impl(&dword_1830D4000, v5, v6, v7, buf, 0xCu);
  }
LABEL_37:
  if (v4) {
    free(v4);
  }
  return 0;
}

uint64_t nw_protocol_http3_remove_listen_handler(nw_protocol *a1, nw_listen_protocol *a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v25 = "nw_protocol_http3_remove_listen_handler";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (!__nwlog_fault(v12, &type, &v22)) {
      goto LABEL_48;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v25 = "nw_protocol_http3_remove_listen_handler";
        __int16 v15 = "%{public}s called with null protocol";
LABEL_47:
        _os_log_impl(&dword_1830D4000, v13, v14, v15, buf, 0xCu);
      }
LABEL_48:
      if (v12) {
        free(v12);
      }
      return 0;
    }
    if (!v22)
    {
      BOOL v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v25 = "nw_protocol_http3_remove_listen_handler";
        __int16 v15 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_47;
      }
      goto LABEL_48;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v13 = __nwlog_obj();
    os_log_type_t v14 = type;
    BOOL v17 = os_log_type_enabled(v13, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v25 = "nw_protocol_http3_remove_listen_handler";
        __int16 v15 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_47;
      }
      goto LABEL_48;
    }
    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v25 = "nw_protocol_http3_remove_listen_handler";
      __int16 v26 = 2082;
      BOOL v27 = backtrace_string;
      __int16 v18 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_35:
      _os_log_impl(&dword_1830D4000, v13, v14, v18, buf, 0x16u);
    }
LABEL_36:
    free(backtrace_string);
    goto LABEL_48;
  }
  handle = (unsigned __int8 *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v25 = "nw_protocol_http3_remove_listen_handler";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (!__nwlog_fault(v12, &type, &v22)) {
      goto LABEL_48;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v25 = "nw_protocol_http3_remove_listen_handler";
        __int16 v15 = "%{public}s called with null http3";
        goto LABEL_47;
      }
      goto LABEL_48;
    }
    if (!v22)
    {
      BOOL v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v25 = "nw_protocol_http3_remove_listen_handler";
        __int16 v15 = "%{public}s called with null http3, backtrace limit exceeded";
        goto LABEL_47;
      }
      goto LABEL_48;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v13 = __nwlog_obj();
    os_log_type_t v14 = type;
    BOOL v19 = os_log_type_enabled(v13, type);
    if (!backtrace_string)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v25 = "nw_protocol_http3_remove_listen_handler";
        __int16 v15 = "%{public}s called with null http3, no backtrace";
        goto LABEL_47;
      }
      goto LABEL_48;
    }
    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v25 = "nw_protocol_http3_remove_listen_handler";
      __int16 v26 = 2082;
      BOOL v27 = backtrace_string;
      __int16 v18 = "%{public}s called with null http3, dumping backtrace:%{public}s";
      goto LABEL_35;
    }
    goto LABEL_36;
  }
  int v4 = (handle[1375] >> 6) & 1;
  if (!gLogDatapath) {
    LOBYTE(v4) = 1;
  }
  if (*((nw_listen_protocol **)handle + 136) == a2)
  {
    int v7 = handle + 1373;
    if ((v4 & 1) == 0)
    {
      __int16 v20 = __nwlog_obj();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        int v21 = *((_DWORD *)handle + 320);
        *(_DWORD *)buf = 136446978;
        uint64_t v25 = "nw_protocol_http3_remove_listen_handler";
        __int16 v26 = 2082;
        BOOL v27 = (char *)(handle + 1289);
        __int16 v28 = 2080;
        BOOL v29 = " ";
        __int16 v30 = 1024;
        int v31 = v21;
        _os_log_impl(&dword_1830D4000, v20, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> removing protocol listen handler", buf, 0x26u);
      }
    }
    handle[1375] = (*(unsigned __int16 *)(handle + 1373) | (handle[1375] << 16) | 0x10000u) >> 16;
    *((void *)handle + 136) = 0;
    a2->protocol_handler = 0;
    int v8 = (unsigned __int16)*v7;
    int v9 = v8 | (handle[1375] << 16);
    if ((v8 & 1) != 0 && *((void *)handle + 25))
    {
      if (*((_DWORD *)handle + 318) == 3 && !*((void *)handle + 114))
      {
        uint64_t v10 = 1;
        *((_DWORD *)handle + 318) = 1;
        nw_http3_control_stream_process_output((uint64_t)handle);
        return v10;
      }
      _WORD *v7 = v8;
      handle[1375] = (v9 | 0x20000u) >> 16;
    }
    else
    {
      nw_http3_async_close_connection_if_no_stream((uint64_t)handle);
    }
  }
  else if ((v4 & 1) == 0)
  {
    os_log_type_t v5 = __nwlog_obj();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      int v6 = *((_DWORD *)handle + 320);
      *(_DWORD *)buf = 136446978;
      uint64_t v25 = "nw_protocol_http3_remove_listen_handler";
      __int16 v26 = 2082;
      BOOL v27 = (char *)(handle + 1289);
      __int16 v28 = 2080;
      BOOL v29 = " ";
      __int16 v30 = 1024;
      int v31 = v6;
      _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> ignoring request to remove http3 listen handler, does not match our handler", buf, 0x26u);
    }
  }
  return 1;
}

BOOL nw_protocol_http3_add_listen_handler(nw_protocol *a1, nw_listen_protocol *a2, char a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v21 = "nw_protocol_http3_add_listen_handler";
    int v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (!__nwlog_fault(v8, &type, &v18)) {
      goto LABEL_42;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v18)
      {
        int v9 = __nwlog_obj();
        os_log_type_t v10 = type;
        if (!os_log_type_enabled(v9, type)) {
          goto LABEL_42;
        }
        *(_DWORD *)buf = 136446210;
        int v21 = "nw_protocol_http3_add_listen_handler";
        BOOL v11 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_41;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (!v13) {
          goto LABEL_42;
        }
        *(_DWORD *)buf = 136446210;
        int v21 = "nw_protocol_http3_add_listen_handler";
        BOOL v11 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_41;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        int v21 = "nw_protocol_http3_add_listen_handler";
        __int16 v22 = 2082;
        int v23 = backtrace_string;
        os_log_type_t v14 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_28:
        _os_log_impl(&dword_1830D4000, v9, v10, v14, buf, 0x16u);
      }
LABEL_29:
      free(backtrace_string);
      goto LABEL_42;
    }
    int v9 = __nwlog_obj();
    os_log_type_t v10 = type;
    if (!os_log_type_enabled(v9, type)) {
      goto LABEL_42;
    }
    *(_DWORD *)buf = 136446210;
    int v21 = "nw_protocol_http3_add_listen_handler";
    BOOL v11 = "%{public}s called with null protocol";
LABEL_41:
    _os_log_impl(&dword_1830D4000, v9, v10, v11, buf, 0xCu);
LABEL_42:
    if (v8) {
      free(v8);
    }
    return 0;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v21 = "nw_protocol_http3_add_listen_handler";
    int v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (!__nwlog_fault(v8, &type, &v18)) {
      goto LABEL_42;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      int v21 = "nw_protocol_http3_add_listen_handler";
      BOOL v11 = "%{public}s called with null http3";
      goto LABEL_41;
    }
    if (!v18)
    {
      int v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      int v21 = "nw_protocol_http3_add_listen_handler";
      BOOL v11 = "%{public}s called with null http3, backtrace limit exceeded";
      goto LABEL_41;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int v9 = __nwlog_obj();
    os_log_type_t v10 = type;
    BOOL v15 = os_log_type_enabled(v9, type);
    if (backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        int v21 = "nw_protocol_http3_add_listen_handler";
        __int16 v22 = 2082;
        int v23 = backtrace_string;
        os_log_type_t v14 = "%{public}s called with null http3, dumping backtrace:%{public}s";
        goto LABEL_28;
      }
      goto LABEL_29;
    }
    if (!v15) {
      goto LABEL_42;
    }
    *(_DWORD *)buf = 136446210;
    int v21 = "nw_protocol_http3_add_listen_handler";
    BOOL v11 = "%{public}s called with null http3, no backtrace";
    goto LABEL_41;
  }
  if (*((void *)handle + 136))
  {
    if (((*(unsigned __int16 *)(handle + 1373) | (handle[1375] << 16)) & 0x400000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v4 = gLogObj;
      BOOL result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
      if (result)
      {
        int v6 = *((_DWORD *)handle + 320);
        *(_DWORD *)buf = 136446978;
        int v21 = "nw_protocol_http3_add_listen_handler";
        __int16 v22 = 2082;
        int v23 = handle + 1289;
        __int16 v24 = 2080;
        uint64_t v25 = " ";
        __int16 v26 = 1024;
        int v27 = v6;
        _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> Already have a listen handler, ignoring add", buf, 0x26u);
        return 0;
      }
      return result;
    }
    return 0;
  }
  *((void *)handle + 136) = a2;
  a2->protocol_handler = (nw_protocol *)handle;
  if (a3)
  {
    handle[1375] = (*(unsigned __int16 *)(handle + 1373) | (handle[1375] << 16) | 0x10000u) >> 16;
    nw_protocol_remove_instance((uint64_t)handle);
  }
  BOOL result = 1;
  if (((*(unsigned __int16 *)(handle + 1373) | (handle[1375] << 16)) & 0x400000) == 0 && gLogDatapath)
  {
    uint64_t v16 = __nwlog_obj();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      int v17 = *((_DWORD *)handle + 320);
      *(_DWORD *)buf = 136447234;
      int v21 = "nw_protocol_http3_add_listen_handler";
      __int16 v22 = 2082;
      int v23 = handle + 1289;
      __int16 v24 = 2080;
      uint64_t v25 = " ";
      __int16 v26 = 1024;
      int v27 = v17;
      __int16 v28 = 2048;
      BOOL v29 = a2;
      _os_log_impl(&dword_1830D4000, v16, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> added protocol listen handler %p", buf, 0x30u);
    }
    return 1;
  }
  return result;
}

uint64_t nw_protocol_http3_get_input_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v26 = "nw_protocol_http3_get_input_frames";
    int v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v7, &type, &v23)) {
      goto LABEL_18;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v26 = "nw_protocol_http3_get_input_frames";
      os_log_type_t v10 = "%{public}s called with null protocol";
      goto LABEL_48;
    }
    if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      BOOL v20 = os_log_type_enabled(v17, type);
      if (backtrace_string)
      {
        if (!v20) {
          goto LABEL_38;
        }
        *(_DWORD *)buf = 136446466;
        __int16 v26 = "nw_protocol_http3_get_input_frames";
        __int16 v27 = 2082;
        __int16 v28 = backtrace_string;
        int v21 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
        goto LABEL_37;
      }
      if (!v20) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v26 = "nw_protocol_http3_get_input_frames";
      os_log_type_t v10 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      int v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v26 = "nw_protocol_http3_get_input_frames";
      os_log_type_t v10 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_48:
    BOOL v13 = v17;
    os_log_type_t v14 = v18;
    uint32_t v15 = 12;
    goto LABEL_17;
  }
  handle = (char *)a1->handle;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  if (!handle)
  {
    *(_DWORD *)buf = 136446210;
    __int16 v26 = "nw_protocol_http3_get_input_frames";
    int v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v7, &type, &v23)) {
      goto LABEL_18;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v26 = "nw_protocol_http3_get_input_frames";
      os_log_type_t v10 = "%{public}s called with null http3";
      goto LABEL_48;
    }
    if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      BOOL v22 = os_log_type_enabled(v17, type);
      if (backtrace_string)
      {
        if (!v22) {
          goto LABEL_38;
        }
        *(_DWORD *)buf = 136446466;
        __int16 v26 = "nw_protocol_http3_get_input_frames";
        __int16 v27 = 2082;
        __int16 v28 = backtrace_string;
        int v21 = "%{public}s called with null http3, dumping backtrace:%{public}s";
LABEL_37:
        _os_log_impl(&dword_1830D4000, v17, v18, v21, buf, 0x16u);
LABEL_38:
        free(backtrace_string);
        if (!v7) {
          return 0;
        }
        goto LABEL_19;
      }
      if (!v22) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v26 = "nw_protocol_http3_get_input_frames";
      os_log_type_t v10 = "%{public}s called with null http3, no backtrace";
    }
    else
    {
      int v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v26 = "nw_protocol_http3_get_input_frames";
      os_log_type_t v10 = "%{public}s called with null http3, backtrace limit exceeded";
    }
    goto LABEL_48;
  }
  *(_DWORD *)buf = 136446466;
  __int16 v26 = "nw_protocol_http3_get_input_frames";
  __int16 v27 = 2048;
  __int16 v28 = handle;
  int v7 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (!__nwlog_fault(v7, &type, &v23)) {
    goto LABEL_18;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v8 = gLogObj;
    os_log_type_t v9 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
      goto LABEL_18;
    }
    *(_DWORD *)buf = 136446466;
    __int16 v26 = "nw_protocol_http3_get_input_frames";
    __int16 v27 = 2048;
    __int16 v28 = handle;
    os_log_type_t v10 = "%{public}s http3 %p called";
LABEL_16:
    BOOL v13 = v8;
    os_log_type_t v14 = v9;
    uint32_t v15 = 22;
LABEL_17:
    _os_log_impl(&dword_1830D4000, v13, v14, v10, buf, v15);
    goto LABEL_18;
  }
  if (!v23)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v8 = gLogObj;
    os_log_type_t v9 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
      goto LABEL_18;
    }
    *(_DWORD *)buf = 136446466;
    __int16 v26 = "nw_protocol_http3_get_input_frames";
    __int16 v27 = 2048;
    __int16 v28 = handle;
    os_log_type_t v10 = "%{public}s http3 %p called, backtrace limit exceeded";
    goto LABEL_16;
  }
  BOOL v11 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v8 = gLogObj;
  os_log_type_t v9 = type;
  BOOL v12 = os_log_type_enabled((os_log_t)gLogObj, type);
  if (!v11)
  {
    if (!v12) {
      goto LABEL_18;
    }
    *(_DWORD *)buf = 136446466;
    __int16 v26 = "nw_protocol_http3_get_input_frames";
    __int16 v27 = 2048;
    __int16 v28 = handle;
    os_log_type_t v10 = "%{public}s http3 %p called, no backtrace";
    goto LABEL_16;
  }
  if (v12)
  {
    *(_DWORD *)buf = 136446722;
    __int16 v26 = "nw_protocol_http3_get_input_frames";
    __int16 v27 = 2048;
    __int16 v28 = handle;
    __int16 v29 = 2082;
    uint64_t v30 = v11;
    _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s http3 %p called, dumping backtrace:%{public}s", buf, 0x20u);
  }
  free(v11);
LABEL_18:
  if (v7) {
LABEL_19:
  }
    free(v7);
  return 0;
}

void nw_protocol_http3_output_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v23 = "nw_protocol_http3_output_available";
    int v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (!__nwlog_fault(v4, &type, &v20)) {
      goto LABEL_24;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_24;
      }
      *(_DWORD *)buf = 136446210;
      char v23 = "nw_protocol_http3_output_available";
      int v7 = "%{public}s called with null protocol";
      goto LABEL_22;
    }
    if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      BOOL v17 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (!v17) {
          goto LABEL_48;
        }
        *(_DWORD *)buf = 136446466;
        char v23 = "nw_protocol_http3_output_available";
        __int16 v24 = 2082;
        uint64_t v25 = backtrace_string;
        os_log_type_t v18 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
        goto LABEL_47;
      }
      if (!v17) {
        goto LABEL_24;
      }
      *(_DWORD *)buf = 136446210;
      char v23 = "nw_protocol_http3_output_available";
      int v7 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      os_log_type_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_24;
      }
      *(_DWORD *)buf = 136446210;
      char v23 = "nw_protocol_http3_output_available";
      int v7 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_22:
    BOOL v12 = v5;
    os_log_type_t v13 = v6;
LABEL_23:
    _os_log_impl(&dword_1830D4000, v12, v13, v7, buf, 0xCu);
    goto LABEL_24;
  }
  handle = (char *)a1->handle;
  if (handle)
  {
    if (((*(unsigned __int16 *)(handle + 1373) | (handle[1375] << 16)) & 0x400000) == 0)
    {
      if (gLogDatapath)
      {
        os_log_type_t v14 = __nwlog_obj();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
        {
          int v15 = *((_DWORD *)handle + 320);
          *(_DWORD *)buf = 136446978;
          char v23 = "nw_protocol_http3_output_available";
          __int16 v24 = 2082;
          uint64_t v25 = handle + 1289;
          __int16 v26 = 2080;
          __int16 v27 = " ";
          __int16 v28 = 1024;
          int v29 = v15;
          _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
        }
      }
    }
    if (*((nw_protocol **)handle + 4) == a2)
    {
      nw_http3_control_stream_process_output((uint64_t)handle);
      return;
    }
    if (*((nw_protocol **)handle + 132) == a2)
    {
      nw_http3_encoder_stream_process_output((uint64_t)handle);
      return;
    }
    if (*((nw_protocol **)handle + 134) == a2)
    {
      nw_http3_decoder_stream_process_output((uint64_t)handle);
      return;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    char v23 = "nw_protocol_http3_output_available";
    int v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (__nwlog_fault(v4, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v5 = gLogObj;
        os_log_type_t v6 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_24;
        }
        *(_DWORD *)buf = 136446210;
        char v23 = "nw_protocol_http3_output_available";
        int v7 = "%{public}s output_available for unknown stream";
        goto LABEL_22;
      }
      if (!v20)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v5 = gLogObj;
        os_log_type_t v6 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_24;
        }
        *(_DWORD *)buf = 136446210;
        char v23 = "nw_protocol_http3_output_available";
        int v7 = "%{public}s output_available for unknown stream, backtrace limit exceeded";
        goto LABEL_22;
      }
      int v8 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v9 = gLogObj;
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v8)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v23 = "nw_protocol_http3_output_available";
          __int16 v24 = 2082;
          uint64_t v25 = v8;
          _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s output_available for unknown stream, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v8);
      }
      else if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v23 = "nw_protocol_http3_output_available";
        int v7 = "%{public}s output_available for unknown stream, no backtrace";
        BOOL v12 = v9;
        os_log_type_t v13 = v10;
        goto LABEL_23;
      }
    }
LABEL_24:
    if (!v4) {
      return;
    }
    goto LABEL_25;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v23 = "nw_protocol_http3_output_available";
  int v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (!__nwlog_fault(v4, &type, &v20)) {
    goto LABEL_24;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v5 = __nwlog_obj();
    os_log_type_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_24;
    }
    *(_DWORD *)buf = 136446210;
    char v23 = "nw_protocol_http3_output_available";
    int v7 = "%{public}s called with null http3";
    goto LABEL_22;
  }
  if (!v20)
  {
    os_log_type_t v5 = __nwlog_obj();
    os_log_type_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_24;
    }
    *(_DWORD *)buf = 136446210;
    char v23 = "nw_protocol_http3_output_available";
    int v7 = "%{public}s called with null http3, backtrace limit exceeded";
    goto LABEL_22;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  os_log_type_t v5 = __nwlog_obj();
  os_log_type_t v6 = type;
  BOOL v19 = os_log_type_enabled(v5, type);
  if (!backtrace_string)
  {
    if (!v19) {
      goto LABEL_24;
    }
    *(_DWORD *)buf = 136446210;
    char v23 = "nw_protocol_http3_output_available";
    int v7 = "%{public}s called with null http3, no backtrace";
    goto LABEL_22;
  }
  if (!v19) {
    goto LABEL_48;
  }
  *(_DWORD *)buf = 136446466;
  char v23 = "nw_protocol_http3_output_available";
  __int16 v24 = 2082;
  uint64_t v25 = backtrace_string;
  os_log_type_t v18 = "%{public}s called with null http3, dumping backtrace:%{public}s";
LABEL_47:
  _os_log_impl(&dword_1830D4000, v5, v6, v18, buf, 0x16u);
LABEL_48:
  free(backtrace_string);
  if (v4) {
LABEL_25:
  }
    free(v4);
}

void nw_protocol_http3_input_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v23 = "nw_protocol_http3_input_available";
    int v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (!__nwlog_fault(v4, &type, &v20)) {
      goto LABEL_24;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_24;
      }
      *(_DWORD *)buf = 136446210;
      char v23 = "nw_protocol_http3_input_available";
      int v7 = "%{public}s called with null protocol";
      goto LABEL_22;
    }
    if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      BOOL v17 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (!v17) {
          goto LABEL_48;
        }
        *(_DWORD *)buf = 136446466;
        char v23 = "nw_protocol_http3_input_available";
        __int16 v24 = 2082;
        uint64_t v25 = backtrace_string;
        os_log_type_t v18 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
        goto LABEL_47;
      }
      if (!v17) {
        goto LABEL_24;
      }
      *(_DWORD *)buf = 136446210;
      char v23 = "nw_protocol_http3_input_available";
      int v7 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      os_log_type_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_24;
      }
      *(_DWORD *)buf = 136446210;
      char v23 = "nw_protocol_http3_input_available";
      int v7 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_22:
    BOOL v12 = v5;
    os_log_type_t v13 = v6;
LABEL_23:
    _os_log_impl(&dword_1830D4000, v12, v13, v7, buf, 0xCu);
    goto LABEL_24;
  }
  handle = (char *)a1->handle;
  if (handle)
  {
    if (((*(unsigned __int16 *)(handle + 1373) | (handle[1375] << 16)) & 0x400000) == 0)
    {
      if (gLogDatapath)
      {
        os_log_type_t v14 = __nwlog_obj();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
        {
          int v15 = *((_DWORD *)handle + 320);
          *(_DWORD *)buf = 136446978;
          char v23 = "nw_protocol_http3_input_available";
          __int16 v24 = 2082;
          uint64_t v25 = handle + 1289;
          __int16 v26 = 2080;
          __int16 v27 = " ";
          __int16 v28 = 1024;
          int v29 = v15;
          _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
        }
      }
    }
    if (*((nw_protocol **)handle + 131) == a2)
    {
      nw_http3_control_stream_process_input((uint64_t)handle);
      return;
    }
    if (*((nw_protocol **)handle + 133) == a2)
    {
      nw_http3_encoder_stream_process_input((uint64_t)handle);
      return;
    }
    if (*((nw_protocol **)handle + 135) == a2)
    {
      nw_http3_decoder_stream_process_input((uint64_t)handle);
      return;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    char v23 = "nw_protocol_http3_input_available";
    int v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (__nwlog_fault(v4, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v5 = gLogObj;
        os_log_type_t v6 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_24;
        }
        *(_DWORD *)buf = 136446210;
        char v23 = "nw_protocol_http3_input_available";
        int v7 = "%{public}s input_available for unknown stream";
        goto LABEL_22;
      }
      if (!v20)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v5 = gLogObj;
        os_log_type_t v6 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_24;
        }
        *(_DWORD *)buf = 136446210;
        char v23 = "nw_protocol_http3_input_available";
        int v7 = "%{public}s input_available for unknown stream, backtrace limit exceeded";
        goto LABEL_22;
      }
      int v8 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v9 = gLogObj;
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v8)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v23 = "nw_protocol_http3_input_available";
          __int16 v24 = 2082;
          uint64_t v25 = v8;
          _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s input_available for unknown stream, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v8);
      }
      else if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v23 = "nw_protocol_http3_input_available";
        int v7 = "%{public}s input_available for unknown stream, no backtrace";
        BOOL v12 = v9;
        os_log_type_t v13 = v10;
        goto LABEL_23;
      }
    }
LABEL_24:
    if (!v4) {
      return;
    }
    goto LABEL_25;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v23 = "nw_protocol_http3_input_available";
  int v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (!__nwlog_fault(v4, &type, &v20)) {
    goto LABEL_24;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v5 = __nwlog_obj();
    os_log_type_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_24;
    }
    *(_DWORD *)buf = 136446210;
    char v23 = "nw_protocol_http3_input_available";
    int v7 = "%{public}s called with null http3";
    goto LABEL_22;
  }
  if (!v20)
  {
    os_log_type_t v5 = __nwlog_obj();
    os_log_type_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_24;
    }
    *(_DWORD *)buf = 136446210;
    char v23 = "nw_protocol_http3_input_available";
    int v7 = "%{public}s called with null http3, backtrace limit exceeded";
    goto LABEL_22;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  os_log_type_t v5 = __nwlog_obj();
  os_log_type_t v6 = type;
  BOOL v19 = os_log_type_enabled(v5, type);
  if (!backtrace_string)
  {
    if (!v19) {
      goto LABEL_24;
    }
    *(_DWORD *)buf = 136446210;
    char v23 = "nw_protocol_http3_input_available";
    int v7 = "%{public}s called with null http3, no backtrace";
    goto LABEL_22;
  }
  if (!v19) {
    goto LABEL_48;
  }
  *(_DWORD *)buf = 136446466;
  char v23 = "nw_protocol_http3_input_available";
  __int16 v24 = 2082;
  uint64_t v25 = backtrace_string;
  os_log_type_t v18 = "%{public}s called with null http3, dumping backtrace:%{public}s";
LABEL_47:
  _os_log_impl(&dword_1830D4000, v5, v6, v18, buf, 0x16u);
LABEL_48:
  free(backtrace_string);
  if (v4) {
LABEL_25:
  }
    free(v4);
}

uint64_t nw_protocol_http3_remove_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v63 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v50 = "nw_protocol_http3_remove_input_handler";
    char v38 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v47 = 0;
    if (!__nwlog_fault(v38, &type, &v47)) {
      goto LABEL_83;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v47)
      {
        os_log_type_t v39 = __nwlog_obj();
        os_log_type_t v40 = type;
        if (!os_log_type_enabled(v39, type)) {
          goto LABEL_83;
        }
        *(_DWORD *)buf = 136446210;
        int v50 = "nw_protocol_http3_remove_input_handler";
        __int16 v41 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_82;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v39 = __nwlog_obj();
      os_log_type_t v40 = type;
      BOOL v43 = os_log_type_enabled(v39, type);
      if (!backtrace_string)
      {
        if (!v43) {
          goto LABEL_83;
        }
        *(_DWORD *)buf = 136446210;
        int v50 = "nw_protocol_http3_remove_input_handler";
        __int16 v41 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_82;
      }
      if (v43)
      {
        *(_DWORD *)buf = 136446466;
        int v50 = "nw_protocol_http3_remove_input_handler";
        __int16 v51 = 2082;
        char v52 = backtrace_string;
        BOOL v44 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_72:
        _os_log_impl(&dword_1830D4000, v39, v40, v44, buf, 0x16u);
      }
LABEL_73:
      free(backtrace_string);
      goto LABEL_83;
    }
    os_log_type_t v39 = __nwlog_obj();
    os_log_type_t v40 = type;
    if (!os_log_type_enabled(v39, type)) {
      goto LABEL_83;
    }
    *(_DWORD *)buf = 136446210;
    int v50 = "nw_protocol_http3_remove_input_handler";
    __int16 v41 = "%{public}s called with null protocol";
LABEL_82:
    _os_log_impl(&dword_1830D4000, v39, v40, v41, buf, 0xCu);
LABEL_83:
    if (v38) {
      free(v38);
    }
    return 0;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v50 = "nw_protocol_http3_remove_input_handler";
    char v38 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v47 = 0;
    if (!__nwlog_fault(v38, &type, &v47)) {
      goto LABEL_83;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v39 = __nwlog_obj();
      os_log_type_t v40 = type;
      if (!os_log_type_enabled(v39, type)) {
        goto LABEL_83;
      }
      *(_DWORD *)buf = 136446210;
      int v50 = "nw_protocol_http3_remove_input_handler";
      __int16 v41 = "%{public}s called with null http3";
      goto LABEL_82;
    }
    if (!v47)
    {
      os_log_type_t v39 = __nwlog_obj();
      os_log_type_t v40 = type;
      if (!os_log_type_enabled(v39, type)) {
        goto LABEL_83;
      }
      *(_DWORD *)buf = 136446210;
      int v50 = "nw_protocol_http3_remove_input_handler";
      __int16 v41 = "%{public}s called with null http3, backtrace limit exceeded";
      goto LABEL_82;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v39 = __nwlog_obj();
    os_log_type_t v40 = type;
    BOOL v45 = os_log_type_enabled(v39, type);
    if (backtrace_string)
    {
      if (v45)
      {
        *(_DWORD *)buf = 136446466;
        int v50 = "nw_protocol_http3_remove_input_handler";
        __int16 v51 = 2082;
        char v52 = backtrace_string;
        BOOL v44 = "%{public}s called with null http3, dumping backtrace:%{public}s";
        goto LABEL_72;
      }
      goto LABEL_73;
    }
    if (!v45) {
      goto LABEL_83;
    }
    *(_DWORD *)buf = 136446210;
    int v50 = "nw_protocol_http3_remove_input_handler";
    __int16 v41 = "%{public}s called with null http3, no backtrace";
    goto LABEL_82;
  }
  os_log_type_t v5 = handle + 1373;
  if (((*(unsigned __int16 *)(handle + 1373) | (handle[1375] << 16)) & 0x400000) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v6 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      int v7 = *((_DWORD *)handle + 320);
      default_input_handler = a1->default_input_handler;
      *(_DWORD *)buf = 136447746;
      int v50 = "nw_protocol_http3_remove_input_handler";
      __int16 v51 = 2082;
      char v52 = handle + 1289;
      __int16 v53 = 2080;
      int v54 = " ";
      __int16 v55 = 1024;
      int v56 = v7;
      __int16 v57 = 2048;
      __int16 v58 = a1;
      __int16 v59 = 2048;
      uint64_t v60 = default_input_handler;
      __int16 v61 = 2048;
      uint64_t v62 = a2;
      _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> protocol %p, default_input_handler %p, input protocol %p", buf, 0x44u);
    }
  }
  if (a2->output_handler == a1) {
    nw_protocol_set_output_handler((uint64_t)a2, 0);
  }
  uint64_t v9 = *((void *)handle + 110);
  if (v9)
  {
    int v10 = (unsigned __int16)*v5 | (handle[1375] << 16);
    if ((v10 & 0x200000) == 0 && *((void *)handle + 155) && *((_DWORD *)handle + 319) == 2)
    {
      while ((*(_WORD *)(v9 + 736) & 0x2000) != 0)
      {
        uint64_t v9 = *(void *)(v9 + 544);
        if (!v9)
        {
          if ((v10 & 0x400000) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v11 = gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
            {
              int v12 = *((_DWORD *)handle + 320);
              *(_DWORD *)buf = 136446978;
              int v50 = "nw_protocol_http3_remove_input_handler";
              __int16 v51 = 2082;
              char v52 = handle + 1289;
              __int16 v53 = 2080;
              int v54 = " ";
              __int16 v55 = 1024;
              int v56 = v12;
              _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> disabling QUIC keepalives due to idleness", buf, 0x26u);
            }
          }
          handle[1375] |= 0x20u;
          nw_quic_connection_set_keepalive(*((void **)handle + 155), 0);
          buf[0] = 1;
          output_handler = a1->output_handler;
          if (output_handler)
          {
            callbacks = output_handler->callbacks;
            if (callbacks)
            {
              notify = (void (*)(void))callbacks->notify;
              if (notify) {
                notify();
              }
            }
          }
          break;
        }
      }
    }
  }
  if (a1->default_input_handler != a2) {
    return 0;
  }
  int v17 = (unsigned __int16)*v5;
  if ((v17 & 0x18) == 0)
  {
    if (((v17 | (handle[1375] << 16)) & 0x400000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v18 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        int v19 = *((_DWORD *)handle + 320);
        *(_DWORD *)buf = 136446978;
        int v50 = "nw_protocol_http3_remove_input_handler";
        __int16 v51 = 2082;
        char v52 = handle + 1289;
        __int16 v53 = 2080;
        int v54 = " ";
        __int16 v55 = 1024;
        int v56 = v19;
        _os_log_impl(&dword_1830D4000, v18, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> first input handler bailed, closing", buf, 0x26u);
      }
    }
    *v5 |= 8u;
    nw_protocol_remove_instance((uint64_t)handle);
    char v20 = (void *)*((void *)handle + 110);
    if (!v20) {
      goto LABEL_33;
    }
    do
    {
      int v21 = (void *)v20[68];
      nw_protocol_notify(v20, (uint64_t)handle, 22);
      char v20 = v21;
    }
    while (v21);
  }
  uint64_t v22 = *((void *)handle + 110);
  if (!v22)
  {
LABEL_33:
    nw_protocol_set_input_handler((uint64_t)a1, 0);
    int v25 = (unsigned __int16)*v5;
    if ((v25 & 0x800) == 0)
    {
      if (((v25 | (handle[1375] << 16)) & 0x400000) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v26 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        {
          int v27 = *((_DWORD *)handle + 320);
          *(_DWORD *)buf = 136446978;
          int v50 = "nw_protocol_http3_remove_input_handler";
          __int16 v51 = 2082;
          char v52 = handle + 1289;
          __int16 v53 = 2080;
          int v54 = " ";
          __int16 v55 = 1024;
          int v56 = v27;
          _os_log_impl(&dword_1830D4000, v26, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> called before initial connect, will tear down immediately", buf, 0x26u);
        }
      }
      *v5 |= 8u;
      nw_protocol_remove_instance((uint64_t)handle);
      nw_protocol_set_output_handler((uint64_t)handle, 0);
    }
    if (*((void *)handle + 155))
    {
      int v28 = *((_DWORD *)handle + 319);
      if (v28 == 2 || v28 == 1 && (*(_WORD *)(handle + 1373) & 8) != 0)
      {
        if (((*(unsigned __int16 *)(handle + 1373) | (handle[1375] << 16)) & 0x400000) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v29 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          {
            int v30 = *((_DWORD *)handle + 320);
            *(_DWORD *)buf = 136446978;
            int v50 = "nw_protocol_http3_remove_input_handler";
            __int16 v51 = 2082;
            char v52 = handle + 1289;
            __int16 v53 = 2080;
            int v54 = " ";
            __int16 v55 = 1024;
            int v56 = v30;
            _os_log_impl(&dword_1830D4000, v29, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> disabling QUIC keepalives", buf, 0x26u);
          }
        }
        handle[1375] |= 0x20u;
        nw_quic_connection_set_keepalive(*((void **)handle + 155), 0);
      }
    }
    uint64_t v31 = *((void *)handle + 158);
    if (v31) {
      nw_queue_cancel_source(v31);
    }
    v46[0] = MEMORY[0x1E4F143A8];
    v46[1] = 0x40000000;
    v46[2] = ___ZL38nw_protocol_http3_remove_input_handlerP11nw_protocolS0_b_block_invoke;
    v46[3] = &__block_descriptor_tmp_179;
    v46[4] = handle;
    *((void *)handle + 158) = nw_queue_context_create_source(0, 2, 3, 0, v46, 0);
    uint64_t v32 = (nw_protocol *)*((void *)handle + 127);
    if (!nw_protocol_http3_accept((uint64_t)a1)) {
      uint64_t v32 = 0;
    }
    uint64_t v33 = *((void *)handle + 158);
    dispatch_time_t v34 = dispatch_time(0x8000000000000000, 1000000 * (void)v32);
    nw_queue_set_timer_values(v33, v34, 0xFFFFFFFFFFFFFFFFLL, 1000 * (void)v32);
    if ((((unsigned __int16)*v5 | (handle[1375] << 16)) & 0x400000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v35 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        int v36 = *((_DWORD *)handle + 320);
        *(_DWORD *)buf = 136447234;
        int v50 = "nw_protocol_http3_remove_input_handler";
        __int16 v51 = 2082;
        char v52 = handle + 1289;
        __int16 v53 = 2080;
        int v54 = " ";
        __int16 v55 = 1024;
        int v56 = v36;
        __int16 v57 = 2048;
        __int16 v58 = v32;
        _os_log_impl(&dword_1830D4000, v35, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> activating destroy timer for %lldms", buf, 0x30u);
      }
    }
    nw_queue_activate_source(*((void *)handle + 158));
    return 1;
  }
  nw_protocol_set_input_handler((uint64_t)a1, *(void *)(v22 + 48));
  if ((((unsigned __int16)*v5 | (handle[1375] << 16)) & 0x400000) != 0) {
    return 1;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  char v23 = gLogObj;
  uint64_t v16 = 1;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
  {
    int v24 = *((_DWORD *)handle + 320);
    *(_DWORD *)buf = 136446978;
    int v50 = "nw_protocol_http3_remove_input_handler";
    __int16 v51 = 2082;
    char v52 = handle + 1289;
    __int16 v53 = 2080;
    int v54 = " ";
    __int16 v55 = 1024;
    int v56 = v24;
    _os_log_impl(&dword_1830D4000, v23, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> not destroying, has streams", buf, 0x26u);
  }
  return v16;
}

void ___ZL38nw_protocol_http3_remove_input_handlerP11nw_protocolS0_b_block_invoke(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2 || ((*(unsigned __int16 *)(v2 + 1373) | (*(unsigned __int8 *)(v2 + 1375) << 16)) & 0x400000) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v3 = gLogObj;
    BOOL v4 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO);
    uint64_t v2 = *(void *)(a1 + 32);
    if (v4)
    {
      int v5 = *(_DWORD *)(v2 + 1280);
      BOOL v6 = v2 == 0;
      if (v2) {
        int v7 = (const char *)(v2 + 1289);
      }
      else {
        int v7 = "";
      }
      int v9 = 136446978;
      int v10 = "nw_protocol_http3_remove_input_handler_block_invoke";
      __int16 v11 = 2082;
      int v12 = v7;
      if (v6) {
        int v8 = "";
      }
      else {
        int v8 = " ";
      }
      __int16 v13 = 2080;
      os_log_type_t v14 = v8;
      __int16 v15 = 1024;
      int v16 = v5;
      _os_log_impl(&dword_1830D4000, v3, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> tearing down http3 connection", (uint8_t *)&v9, 0x26u);
      uint64_t v2 = *(void *)(a1 + 32);
    }
  }
  *(_WORD *)(v2 + 1373) |= 8u;
  nw_http3_connection_destroy(*(void *)(a1 + 32));
}

BOOL nw_protocol_http3_accept(uint64_t a1)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v36 = "nw_protocol_http3_accept";
    int v25 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v25, &type, &v33)) {
      goto LABEL_62;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v33)
      {
        __int16 v26 = __nwlog_obj();
        os_log_type_t v27 = type;
        if (!os_log_type_enabled(v26, type)) {
          goto LABEL_62;
        }
        *(_DWORD *)buf = 136446210;
        int v36 = "nw_protocol_http3_accept";
        int v28 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_61;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v26 = __nwlog_obj();
      os_log_type_t v27 = type;
      BOOL v30 = os_log_type_enabled(v26, type);
      if (!backtrace_string)
      {
        if (!v30) {
          goto LABEL_62;
        }
        *(_DWORD *)buf = 136446210;
        int v36 = "nw_protocol_http3_accept";
        int v28 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_61;
      }
      if (v30)
      {
        *(_DWORD *)buf = 136446466;
        int v36 = "nw_protocol_http3_accept";
        __int16 v37 = 2082;
        char v38 = backtrace_string;
        uint64_t v31 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_51:
        _os_log_impl(&dword_1830D4000, v26, v27, v31, buf, 0x16u);
      }
LABEL_52:
      free(backtrace_string);
      goto LABEL_62;
    }
    __int16 v26 = __nwlog_obj();
    os_log_type_t v27 = type;
    if (!os_log_type_enabled(v26, type)) {
      goto LABEL_62;
    }
    *(_DWORD *)buf = 136446210;
    int v36 = "nw_protocol_http3_accept";
    int v28 = "%{public}s called with null protocol";
LABEL_61:
    _os_log_impl(&dword_1830D4000, v26, v27, v28, buf, 0xCu);
LABEL_62:
    if (v25) {
      free(v25);
    }
    return 0;
  }
  uint64_t v1 = *(void *)(a1 + 40);
  if (!v1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v36 = "nw_protocol_http3_accept";
    int v25 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v25, &type, &v33)) {
      goto LABEL_62;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v26 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_62;
      }
      *(_DWORD *)buf = 136446210;
      int v36 = "nw_protocol_http3_accept";
      int v28 = "%{public}s called with null http3";
      goto LABEL_61;
    }
    if (!v33)
    {
      __int16 v26 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_62;
      }
      *(_DWORD *)buf = 136446210;
      int v36 = "nw_protocol_http3_accept";
      int v28 = "%{public}s called with null http3, backtrace limit exceeded";
      goto LABEL_61;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v26 = __nwlog_obj();
    os_log_type_t v27 = type;
    BOOL v32 = os_log_type_enabled(v26, type);
    if (backtrace_string)
    {
      if (v32)
      {
        *(_DWORD *)buf = 136446466;
        int v36 = "nw_protocol_http3_accept";
        __int16 v37 = 2082;
        char v38 = backtrace_string;
        uint64_t v31 = "%{public}s called with null http3, dumping backtrace:%{public}s";
        goto LABEL_51;
      }
      goto LABEL_52;
    }
    if (!v32) {
      goto LABEL_62;
    }
    *(_DWORD *)buf = 136446210;
    int v36 = "nw_protocol_http3_accept";
    int v28 = "%{public}s called with null http3, no backtrace";
    goto LABEL_61;
  }
  uint64_t v2 = (unsigned __int16 *)(v1 + 1373);
  if ((*(_WORD *)(v1 + 1373) & 0x10) == 0)
  {
    uint64_t v3 = *(void *)(v1 + 976);
    if (v3)
    {
      uint64_t v4 = mach_continuous_approximate_time();
      uint64_t v5 = v4 <= 1 ? 1 : v4;
      unint64_t v6 = nw_delta_nanos(v3, v5);
      int64_t int64_with_default = networkd_settings_get_int64_with_default((const char *)nw_setting_proxy_setup_threshold_seconds, 5);
      if (v6 > 1000000000 * int64_with_default)
      {
        if (((*v2 | (*(unsigned __int8 *)(v1 + 1375) << 16)) & 0x400000) == 0)
        {
          int64_t v8 = int64_with_default;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v9 = gLogObj;
          BOOL result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO);
          if (!result) {
            return result;
          }
          int v11 = *(_DWORD *)(v1 + 1280);
          *(_DWORD *)buf = 136447234;
          int v36 = "nw_protocol_http3_accept";
          __int16 v37 = 2082;
          char v38 = (char *)(v1 + 1289);
          __int16 v39 = 2080;
          os_log_type_t v40 = " ";
          __int16 v41 = 1024;
          int v42 = v11;
          __int16 v43 = 2048;
          int64_t v44 = v8;
          int v12 = "%{public}s %{public}s%s<i%u> denying join attempt because http3 connection not ready within %lld seconds";
          __int16 v13 = v9;
          uint32_t v14 = 48;
          goto LABEL_32;
        }
        return 0;
      }
    }
  }
  if (*(_WORD *)(v1 + 1284))
  {
    int64_t v15 = networkd_settings_get_int64_with_default((const char *)nw_setting_proxy_maximum_stall_count, 5);
    int v16 = *(unsigned __int16 *)(v1 + 1373) | (*(unsigned __int8 *)(v1 + 1375) << 16);
    if (v15 < *(unsigned __int16 *)(v1 + 1284))
    {
      if ((v16 & 0x400000) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v17 = gLogObj;
        BOOL result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO);
        if (!result) {
          return result;
        }
        int v18 = *(_DWORD *)(v1 + 1280);
        int v19 = *(unsigned __int16 *)(v1 + 1284);
        *(_DWORD *)buf = 136447234;
        int v36 = "nw_protocol_http3_accept";
        __int16 v37 = 2082;
        char v38 = (char *)(v1 + 1289);
        __int16 v39 = 2080;
        os_log_type_t v40 = " ";
        __int16 v41 = 1024;
        int v42 = v18;
        __int16 v43 = 1024;
        LODWORD(v44) = v19;
        int v12 = "%{public}s %{public}s%s<i%u> denying join attempt because http3 connection has hit %u stalls";
        __int16 v13 = v17;
        uint32_t v14 = 44;
        goto LABEL_32;
      }
      return 0;
    }
  }
  else
  {
    int v16 = *v2 | (*(unsigned __int8 *)(v1 + 1375) << 16);
  }
  if ((v16 & 8) != 0)
  {
    if ((v16 & 0x400000) != 0) {
      return 0;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v22 = gLogObj;
    BOOL result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO);
    if (!result) {
      return result;
    }
    int v23 = *(_DWORD *)(v1 + 1280);
    *(_DWORD *)buf = 136446978;
    int v36 = "nw_protocol_http3_accept";
    __int16 v37 = 2082;
    char v38 = (char *)(v1 + 1289);
    __int16 v39 = 2080;
    os_log_type_t v40 = " ";
    __int16 v41 = 1024;
    int v42 = v23;
    int v12 = "%{public}s %{public}s%s<i%u> denying join attempt because http3 connection is closed";
LABEL_31:
    __int16 v13 = v22;
    uint32_t v14 = 38;
LABEL_32:
    _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_INFO, v12, buf, v14);
    return 0;
  }
  if ((v16 & 0x80000) != 0)
  {
    if ((v16 & 0x400000) != 0) {
      return 0;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v22 = gLogObj;
    BOOL result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO);
    if (!result) {
      return result;
    }
    int v24 = *(_DWORD *)(v1 + 1280);
    *(_DWORD *)buf = 136446978;
    int v36 = "nw_protocol_http3_accept";
    __int16 v37 = 2082;
    char v38 = (char *)(v1 + 1289);
    __int16 v39 = 2080;
    os_log_type_t v40 = " ";
    __int16 v41 = 1024;
    int v42 = v24;
    int v12 = "%{public}s %{public}s%s<i%u> denying join attempt because http3 has a better alternate path";
    goto LABEL_31;
  }
  BOOL result = 1;
  if ((v16 & 0x400000) == 0 && gLogDatapath)
  {
    char v20 = __nwlog_obj();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      int v21 = *(_DWORD *)(v1 + 1280);
      *(_DWORD *)buf = 136446978;
      int v36 = "nw_protocol_http3_accept";
      __int16 v37 = 2082;
      char v38 = (char *)(v1 + 1289);
      __int16 v39 = 2080;
      os_log_type_t v40 = " ";
      __int16 v41 = 1024;
      int v42 = v21;
      _os_log_impl(&dword_1830D4000, v20, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> allowing join attempt", buf, 0x26u);
    }
    return 1;
  }
  return result;
}

BOOL nw_protocol_http3_add_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v228 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
    int v160 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v225[0] = 0;
    if (!__nwlog_fault(v160, type, v225)) {
      goto LABEL_375;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v161 = __nwlog_obj();
      os_log_type_t v162 = type[0];
      if (!os_log_type_enabled(v161, type[0])) {
        goto LABEL_375;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
      v163 = "%{public}s called with null protocol";
      goto LABEL_374;
    }
    if (!v225[0])
    {
      uint64_t v161 = __nwlog_obj();
      os_log_type_t v162 = type[0];
      if (!os_log_type_enabled(v161, type[0])) {
        goto LABEL_375;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
      v163 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_374;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v161 = __nwlog_obj();
    os_log_type_t v162 = type[0];
    BOOL v165 = os_log_type_enabled(v161, type[0]);
    if (!backtrace_string)
    {
      if (!v165) {
        goto LABEL_375;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
      v163 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_374;
    }
    if (!v165) {
      goto LABEL_300;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    v166 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_299:
    _os_log_impl(&dword_1830D4000, v161, v162, v166, buf, 0x16u);
    goto LABEL_300;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
    int v160 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v225[0] = 0;
    if (!__nwlog_fault(v160, type, v225)) {
      goto LABEL_375;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v161 = __nwlog_obj();
      os_log_type_t v162 = type[0];
      if (!os_log_type_enabled(v161, type[0])) {
        goto LABEL_375;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
      v163 = "%{public}s called with null http3";
      goto LABEL_374;
    }
    if (!v225[0])
    {
      uint64_t v161 = __nwlog_obj();
      os_log_type_t v162 = type[0];
      if (!os_log_type_enabled(v161, type[0])) {
        goto LABEL_375;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
      v163 = "%{public}s called with null http3, backtrace limit exceeded";
      goto LABEL_374;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v161 = __nwlog_obj();
    os_log_type_t v162 = type[0];
    BOOL v167 = os_log_type_enabled(v161, type[0]);
    if (!backtrace_string)
    {
      if (!v167) {
        goto LABEL_375;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
      v163 = "%{public}s called with null http3, no backtrace";
      goto LABEL_374;
    }
    if (!v167) {
      goto LABEL_300;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    v166 = "%{public}s called with null http3, dumping backtrace:%{public}s";
    goto LABEL_299;
  }
  uint64_t v219 = handle + 1373;
  if ((*(_WORD *)(handle + 1373) & 8) == 0)
  {
    parameters = (void *)nw_protocol_get_parameters((uint64_t)a2);
    if (parameters)
    {
      uint64_t v5 = parameters;
      id v6 = *(id *)(v5[13] + 136);

      if (nw_context_shares_workloop(*((void **)handle + 157), v6)) {
        goto LABEL_24;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = *((void *)handle + 157);
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = a2;
      *(_WORD *)&unsigned char buf[22] = 2112;
      *(void *)&unsigned char buf[24] = v6;
      *(_WORD *)&unsigned char buf[32] = 2112;
      *(void *)&buf[34] = v7;
      int64_t v8 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v225[0] = 0;
      if (__nwlog_fault(v8, type, v225))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v9 = gLogObj;
          os_log_type_t v10 = type[0];
          if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
            goto LABEL_22;
          }
          uint64_t v11 = *((void *)handle + 157);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
          *(_WORD *)&buf[12] = 2048;
          *(void *)&buf[14] = a2;
          *(_WORD *)&unsigned char buf[22] = 2112;
          *(void *)&unsigned char buf[24] = v6;
          *(_WORD *)&unsigned char buf[32] = 2112;
          *(void *)&buf[34] = v11;
          int v12 = "%{public}s Incoming stream %p has different workloop on context %@ than original one from protocol creat"
                "e, which had workloop %@";
LABEL_20:
          uint64_t v22 = v9;
          os_log_type_t v23 = v10;
LABEL_21:
          _os_log_impl(&dword_1830D4000, v22, v23, v12, buf, 0x2Au);
          goto LABEL_22;
        }
        if (!v225[0])
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v9 = gLogObj;
          os_log_type_t v10 = type[0];
          if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
            goto LABEL_22;
          }
          uint64_t v21 = *((void *)handle + 157);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
          *(_WORD *)&buf[12] = 2048;
          *(void *)&buf[14] = a2;
          *(_WORD *)&unsigned char buf[22] = 2112;
          *(void *)&unsigned char buf[24] = v6;
          *(_WORD *)&unsigned char buf[32] = 2112;
          *(void *)&buf[34] = v21;
          int v12 = "%{public}s Incoming stream %p has different workloop on context %@ than original one from protocol creat"
                "e, which had workloop %@, backtrace limit exceeded";
          goto LABEL_20;
        }
        int v16 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v17 = gLogObj;
        os_log_type_t v18 = type[0];
        BOOL v19 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
        if (v16)
        {
          if (v19)
          {
            uint64_t v20 = *((void *)handle + 157);
            *(_DWORD *)buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
            *(_WORD *)&buf[12] = 2048;
            *(void *)&buf[14] = a2;
            *(_WORD *)&unsigned char buf[22] = 2112;
            *(void *)&unsigned char buf[24] = v6;
            *(_WORD *)&unsigned char buf[32] = 2112;
            *(void *)&buf[34] = v20;
            *(_WORD *)&buf[42] = 2082;
            *(void *)&buf[44] = v16;
            _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s Incoming stream %p has different workloop on context %@ than original one from protocol create, which had workloop %@, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v16);
          goto LABEL_22;
        }
        if (v19)
        {
          uint64_t v141 = *((void *)handle + 157);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
          *(_WORD *)&buf[12] = 2048;
          *(void *)&buf[14] = a2;
          *(_WORD *)&unsigned char buf[22] = 2112;
          *(void *)&unsigned char buf[24] = v6;
          *(_WORD *)&unsigned char buf[32] = 2112;
          *(void *)&buf[34] = v141;
          int v12 = "%{public}s Incoming stream %p has different workloop on context %@ than original one from protocol creat"
                "e, which had workloop %@, no backtrace";
          uint64_t v22 = v17;
          os_log_type_t v23 = v18;
          goto LABEL_21;
        }
      }
LABEL_22:
      if (v8) {
        free(v8);
      }
LABEL_24:
      if (v6) {
        os_release(v6);
      }
      if (!*((void *)handle + 138))
      {
        if (!a2)
        {
          unsigned int v213 = (void **)(handle + 1112);
          goto LABEL_38;
        }
        callbacks = a2->callbacks;
        if (callbacks)
        {
          get_local_endpoint = (uint64_t (*)(nw_protocol *))callbacks->get_local_endpoint;
          if (get_local_endpoint)
          {
            __int16 v26 = (void *)get_local_endpoint(a2);
            if (v26) {
              *((void *)handle + 138) = os_retain(v26);
            }
          }
        }
      }
      unsigned int v213 = (void **)(handle + 1112);
      if (a2)
      {
        if (!*((void *)handle + 139))
        {
          os_log_type_t v27 = a2->callbacks;
          if (v27)
          {
            get_path = (uint64_t (*)(nw_protocol *))v27->get_path;
            if (get_path)
            {
              int v29 = (void *)get_path(a2);
              if (v29) {
                *((void *)handle + 139) = os_retain(v29);
              }
            }
          }
        }
      }
LABEL_38:
      uint64_t v30 = *((void *)handle + 4);
      uint64_t v31 = *((void *)handle + 110);
      BOOL v32 = (v31 | v30) == 0;
      if (v30) {
        BOOL v33 = 1;
      }
      else {
        BOOL v33 = v31 == 0;
      }
      if (v33) {
        uint64_t v34 = *((void *)handle + 4);
      }
      else {
        uint64_t v34 = 0;
      }
      if (v31 && !v30)
      {
        while (1)
        {
          uint64_t v34 = *(void *)(v31 + 32);
          if (v34) {
            break;
          }
          uint64_t v31 = *(void *)(v31 + 544);
          if (!v31)
          {
            uint64_t v34 = 0;
            break;
          }
        }
      }
      os_log_type_t v218 = a2;
      *(void *)uint64_t v225 = 0;
      *(void *)&v225[8] = v225;
      *(void *)&v225[16] = 0x2000000000;
      char v226 = 0;
      unsigned int v214 = v5;
      uint64_t v35 = v5;
      int v36 = v35[19];
      object = v35;

      *(void *)buf = MEMORY[0x1E4F143A8];
      *(void *)&buf[8] = 0x40000000;
      *(void *)&buf[16] = ___ZL43nw_http3_set_prohibit_joining_on_parametersP11nw_protocolP13nw_parameters_block_invoke;
      *(void *)&unsigned char buf[24] = &unk_1E52476F0;
      *(void *)&unsigned char buf[32] = v225;
      *(void *)&unsigned char buf[40] = a1;
      nw_protocol_stack_iterate_application_protocols(v36, buf);
      BOOL v215 = v32;
      if (*(unsigned char *)(*(void *)&v225[8] + 24))
      {
        nw_protocol_options_t v37 = nw_protocol_stack_copy_transport_protocol(v36);
        if (v37)
        {
          char v38 = v37;
          id v39 = v38[1];

          identifier = nw_protocol_definition_get_identifier(v39);
          if (gLogDatapath)
          {
            uint64_t v202 = identifier;
            unint64_t v203 = __nwlog_obj();
            if (os_log_type_enabled(v203, OS_LOG_TYPE_DEBUG))
            {
              v204 = a1->identifier;
              if (!v204) {
                v204 = (nw_protocol_identifier *)"invalid";
              }
              *(_DWORD *)os_log_type_t type = 136446978;
              *(void *)&type[4] = "nw_http3_set_prohibit_joining_on_parameters";
              *(_WORD *)&type[12] = 2080;
              *(void *)&type[14] = v204;
              *(_WORD *)&type[22] = 2048;
              *(void *)&unsigned char type[24] = a1;
              *(_WORD *)&type[32] = 2080;
              *(void *)&type[34] = v202;
              _os_log_impl(&dword_1830D4000, v203, OS_LOG_TYPE_DEBUG, "%{public}s %s (%p) setting prohibit joining on %s", (uint8_t *)type, 0x2Au);
            }
          }
          if (v39) {
            os_release(v39);
          }
          __int16 v41 = v38;
          *((unsigned char *)v41 + 153) = 1;

          BOOL v32 = v215;
          *(unsigned char *)(*(void *)&v225[8] + 24) = 0;
          os_release(v41);
        }
      }
      if (v36) {
        os_release(v36);
      }
      _Block_object_dispose(v225, 8);
      int v42 = a2;
      if (v32)
      {
        __int16 v43 = object;
        int64_t v44 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]((id *)[NWConcrete_nw_parameters alloc], v43, 0, 1);

        uint64_t v45 = nw_parameters_copy_protocol_options_legacy(v44, a1);
        if (v45)
        {
          BOOL v46 = v45;
          char v47 = nw_protocol_options_copy(v45);
          int v42 = a2;
          if (nw_protocol_copy_http3_definition_onceToken != -1) {
            dispatch_once(&nw_protocol_copy_http3_definition_onceToken, &__block_literal_global_13_73886);
          }
          id v48 = (id)nw_protocol_copy_http3_definition_http3_definition;
          nw_parameters_set_protocol_instance(v47, v49, (uint64_t)handle);
          if (v48) {
            os_release(v48);
          }
          nw_protocol_stack_t v50 = nw_parameters_copy_default_protocol_stack(v44);
          nw_protocol_stack_replace_protocol_with_handle(v50, (uint64_t)a1, v47);
          if (v50) {
            os_release(v50);
          }
          if (v47) {
            os_release(v47);
          }
          os_release(v46);
        }
        else
        {
          int v42 = a2;
          if (((*(unsigned __int16 *)(handle + 1373) | (handle[1375] << 16)) & 0x400000) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            __int16 v51 = gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
            {
              int v52 = *((_DWORD *)handle + 320);
              *(_DWORD *)buf = 136447490;
              *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = handle + 1289;
              *(_WORD *)&unsigned char buf[22] = 2080;
              *(void *)&unsigned char buf[24] = " ";
              *(_WORD *)&unsigned char buf[32] = 1024;
              *(_DWORD *)&buf[34] = v52;
              *(_WORD *)&buf[38] = 2048;
              *(void *)&unsigned char buf[40] = v44;
              *(_WORD *)&buf[48] = 2048;
              *(void *)&buf[50] = v43;
              _os_log_impl(&dword_1830D4000, v51, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> failed to find http3 options in new parameters %p, copy of %p", buf, 0x3Au);
            }
          }
        }
        __int16 v53 = (void *)*((void *)handle + 140);
        if (v53) {
          os_release(v53);
        }
        *((void *)handle + 140) = v44;
      }
      uint64_t v54 = *((void *)handle + 2);
      __int16 v55 = (void *)*((void *)handle + 137);
      int v56 = malloc_type_calloc(1uLL, 0x2E8uLL, 0xEAFB8F1AuLL);
      if (!v56)
      {
        int v168 = __nwlog_obj();
        os_log_type_enabled(v168, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "strict_calloc";
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = 1;
        *(_WORD *)&unsigned char buf[22] = 2048;
        *(void *)&unsigned char buf[24] = 744;
        v169 = (void *)_os_log_send_and_compose_impl();
        BOOL result = __nwlog_abort((uint64_t)v169);
        if (result) {
          goto LABEL_387;
        }
        free(v169);
      }
      bzero(v56, 0x2E8uLL);
      *(void *)buf = 0;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x2000000000;
      *(void *)&unsigned char buf[24] = v56;
      *(void *)os_log_type_t type = MEMORY[0x1E4F143A8];
      *(void *)&os_log_type_t type[8] = 0x40000000;
      *(void *)&type[16] = ___ZL22nw_http3_stream_createPK22nw_protocol_identifierP17nw_protocol_http3P11nw_endpointP13nw_parametersb_block_invoke;
      *(void *)&unsigned char type[24] = &unk_1E5247718;
      *(void *)&type[32] = buf;
      *((void *)v56 + 41) = _Block_copy(type);
      _Block_object_dispose(buf, 8);
      *((void *)v56 + 2) = v54;
      if (nw_protocol_http3_stream_get_callbacks(void)::onceToken != -1) {
        dispatch_once(&nw_protocol_http3_stream_get_callbacks(void)::onceToken, &__block_literal_global_137);
      }
      *((void *)v56 + 3) = &nw_protocol_http3_stream_get_callbacks(void)::protocol_callbacks;
      *((void *)v56 + 5) = v56;
      if (nw_protocol_http3_identifier::onceToken[0] != -1) {
        dispatch_once(nw_protocol_http3_identifier::onceToken, &__block_literal_global_13_62491);
      }
      *((void *)v56 + 10) = &nw_protocol_http3_identifier::http3_protocol_identifier;
      if (nw_protocol_http3_stream_get_callbacks(void)::onceToken != -1) {
        dispatch_once(&nw_protocol_http3_stream_get_callbacks(void)::onceToken, &__block_literal_global_137);
      }
      *((void *)v56 + 11) = &nw_protocol_http3_stream_get_callbacks(void)::protocol_callbacks;
      *((void *)v56 + 13) = v56;
      *((void *)v56 + 42) = handle;
      *((void *)v56 + 16) = -1;
      *((void *)v56 + 17) = 0;
      *((void *)v56 + 18) = 0;
      *((void *)v56 + 19) = v56;
      *((void *)v56 + 20) = 0;
      *((void *)v56 + 21) = 0;
      *((void *)v56 + 22) = 0;
      *((void *)v56 + 24) = 0;
      *((void *)v56 + 25) = 0;
      *((void *)v56 + 23) = v56 + 11;
      *(void *)((char *)v56 + 206) = 0;
      if (v55) {
        __int16 v57 = os_retain(v55);
      }
      else {
        __int16 v57 = 0;
      }
      *((void *)v56 + 43) = v57;
      *((void *)v56 + 44) = os_retain(object);
      *((void *)v56 + 46) = 0;
      *((void *)v56 + 33) = -1;
      uint64_t v58 = nw_frame_create(0, 0, 0, 0, 0);
      *((void *)v56 + 27) = 0;
      *((void *)v56 + 48) = v58;
      *((void *)v56 + 28) = (char *)v56 + 216;
      *((void *)v56 + 61) = 0;
      *((void *)v56 + 62) = 0;
      *((_WORD *)v56 + 368) |= 4u;
      if (nw_path_parameters_get_logging_disabled(v214[13])) {
        __int16 v59 = 2048;
      }
      else {
        __int16 v59 = 0;
      }
      int v60 = v56[46] & 0xF7FF | (*((unsigned __int8 *)v56 + 738) << 16);
      *((_WORD *)v56 + 368) = v56[46] & 0xF7FF | v59;
      *((unsigned char *)v56 + 738) = BYTE2(v60);
      *((unsigned char *)v56 + 320) = *v219 & 1;
      __int16 v61 = nw_parameters_copy_protocol_options_legacy(object, (nw_protocol *)handle);
      if (!v61) {
        goto LABEL_92;
      }
      uint64_t v62 = v61;
      singleton = nw_http_messaging_options_copy_transaction_metadata(v61);
      uint64_t v64 = nw_http3_copy_application_error_callback(v62);
      char v65 = *((unsigned char *)v56 + 440);
      if (v65)
      {
        size_t v66 = (const void *)*((void *)v56 + 54);
        if (v66)
        {
          _Block_release(v66);
          char v65 = *((unsigned char *)v56 + 440);
        }
      }
      *((void *)v56 + 54) = v64;
      *((unsigned char *)v56 + 440) = v65 | 1;
      os_release(v62);
      if (!singleton)
      {
LABEL_92:
        if (nw_protocol_copy_http_transaction_definition_onceToken != -1) {
          dispatch_once(&nw_protocol_copy_http_transaction_definition_onceToken, &__block_literal_global_84_75899);
        }
        singleton = nw_protocol_metadata_create_singleton((void *)nw_protocol_copy_http_transaction_definition_definition);
      }
      unsigned int v67 = v56 + 46;
      *((void *)v56 + 49) = singleton;
      BOOL v68 = v215;
      if (v215)
      {
        nw_http_transaction_metadata_set_first_on_connection(singleton);
        singleton = (void *)*((void *)v56 + 49);
      }
      nw_http_transaction_metadata_set_connection_metadata(singleton, *((void **)handle + 156));
      if ((*v67 & 0x800) == 0)
      {
        if (gLogDatapath)
        {
          char v174 = __nwlog_obj();
          if (os_log_type_enabled(v174, OS_LOG_TYPE_DEBUG))
          {
            unint64_t v175 = (char *)v56 + 636;
            uint64_t v176 = " ";
            int v177 = *(_DWORD *)(*((void *)v56 + 42) + 1280);
            uint64_t v178 = *((void *)v56 + 30);
            if (!v56)
            {
              uint64_t v176 = "";
              unint64_t v175 = "";
            }
            *(_DWORD *)buf = 136447490;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_create";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v175;
            *(_WORD *)&unsigned char buf[22] = 2080;
            *(void *)&unsigned char buf[24] = v176;
            *(_WORD *)&unsigned char buf[32] = 1024;
            *(_DWORD *)&buf[34] = v177;
            *(_WORD *)&buf[38] = 2048;
            *(void *)&unsigned char buf[40] = v178;
            *(_WORD *)&buf[48] = 2048;
            *(void *)&buf[50] = v56;
            _os_log_impl(&dword_1830D4000, v174, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> created HTTP/3 stream %p", buf, 0x3Au);
          }
        }
      }
      if (v42)
      {
        nw_protocol_set_input_handler((uint64_t)v56, (uint64_t)v42);
        *int v56 = *(_OWORD *)v42->flow_id;
        nw_protocol_set_output_handler((uint64_t)v42, (uint64_t)v56);
        *((void *)v56 + 19) = v56;
        uint64_t v69 = v42->callbacks;
        if (v69)
        {
          supports_external_data = (uint64_t (*)(nw_protocol *))v69->supports_external_data;
          if (supports_external_data) {
            *unsigned int v67 = *v67 & 0xFFFE | supports_external_data(v42);
          }
        }
        unint64_t v71 = (void *)*((void *)v56 + 44);
        unint64_t v72 = (void *)nw_protocol_get_parameters((uint64_t)v42);
        if (v72)
        {
          BOOL v73 = v72;
          *((void *)v56 + 44) = os_retain(v72);
          id v74 = nw_parameters_copy_context(v71);
          unsigned int v75 = v73;
          id v76 = *(id *)(v75[13] + 136);

          if (nw_context_shares_workloop(v74, v76)) {
            goto LABEL_121;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
          *(_WORD *)&buf[12] = 2048;
          *(void *)&buf[14] = v218;
          *(_WORD *)&unsigned char buf[22] = 2112;
          *(void *)&unsigned char buf[24] = v76;
          *(_WORD *)&unsigned char buf[32] = 2112;
          *(void *)&buf[34] = v74;
          int v77 = (const char *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          v225[0] = 0;
          v212 = (char *)v77;
          if (__nwlog_fault(v77, type, v225))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v78 = gLogObj;
              os_log_type_t v79 = type[0];
              if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
              {
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
                *(_WORD *)&buf[12] = 2048;
                *(void *)&buf[14] = v218;
                *(_WORD *)&unsigned char buf[22] = 2112;
                *(void *)&unsigned char buf[24] = v76;
                *(_WORD *)&unsigned char buf[32] = 2112;
                *(void *)&buf[34] = v74;
                uint64_t v80 = "%{public}s Incoming http3 stream %p has different workloop on context %@ than original one from ht"
                      "tp3_stream, which had workloop %@";
LABEL_116:
                uint64_t v84 = v78;
                os_log_type_t v85 = v79;
LABEL_117:
                _os_log_impl(&dword_1830D4000, v84, v85, v80, buf, 0x2Au);
              }
            }
            else if (v225[0])
            {
              uint64_t v81 = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              os_log_type_t v82 = type[0];
              os_log_t log = gLogObj;
              BOOL v83 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
              if (v81)
              {
                if (v83)
                {
                  *(_DWORD *)buf = 136447234;
                  *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
                  *(_WORD *)&buf[12] = 2048;
                  *(void *)&buf[14] = v218;
                  *(_WORD *)&unsigned char buf[22] = 2112;
                  *(void *)&unsigned char buf[24] = v76;
                  *(_WORD *)&unsigned char buf[32] = 2112;
                  *(void *)&buf[34] = v74;
                  *(_WORD *)&buf[42] = 2082;
                  *(void *)&buf[44] = v81;
                  _os_log_impl(&dword_1830D4000, log, v82, "%{public}s Incoming http3 stream %p has different workloop on context %@ than original one from http3_stream, which had workloop %@, dumping backtrace:%{public}s", buf, 0x34u);
                }
                free(v81);
                goto LABEL_118;
              }
              if (v83)
              {
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
                *(_WORD *)&buf[12] = 2048;
                *(void *)&buf[14] = v218;
                *(_WORD *)&unsigned char buf[22] = 2112;
                *(void *)&unsigned char buf[24] = v76;
                *(_WORD *)&unsigned char buf[32] = 2112;
                *(void *)&buf[34] = v74;
                uint64_t v80 = "%{public}s Incoming http3 stream %p has different workloop on context %@ than original one from ht"
                      "tp3_stream, which had workloop %@, no backtrace";
                uint64_t v84 = log;
                os_log_type_t v85 = v82;
                goto LABEL_117;
              }
            }
            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v78 = gLogObj;
              os_log_type_t v79 = type[0];
              if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
              {
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
                *(_WORD *)&buf[12] = 2048;
                *(void *)&buf[14] = v218;
                *(_WORD *)&unsigned char buf[22] = 2112;
                *(void *)&unsigned char buf[24] = v76;
                *(_WORD *)&unsigned char buf[32] = 2112;
                *(void *)&buf[34] = v74;
                uint64_t v80 = "%{public}s Incoming http3 stream %p has different workloop on context %@ than original one from ht"
                      "tp3_stream, which had workloop %@, backtrace limit exceeded";
                goto LABEL_116;
              }
            }
          }
LABEL_118:
          if (v212) {
            free(v212);
          }
          BOOL v68 = v215;
LABEL_121:
          if (v74) {
            os_release(v74);
          }
          if (v76) {
            os_release(v76);
          }
          if (v71) {
            os_release(v71);
          }
          uint64_t v86 = (nw_protocol *)*((void *)v56 + 42);
          if (v86)
          {
            nw_http3_stream_replace_protocol_instance((uint64_t)v56, *((void **)v56 + 44), v86, (uint64_t)v56);
            unsigned int v87 = nw_parameters_copy_protocol_options_legacy(v75, (nw_protocol *)v56);
            if (v87)
            {
              unsigned int v88 = v87;
              uint64_t v89 = v88;
              *((unsigned char *)v56 + 636) = 0;
              unint64_t v90 = 84;
              uint64_t v91 = 636;
              while (1)
              {
                int v92 = v88[v91 - 588];
                *((unsigned char *)v56 + v91) = v92;
                if (!v92) {
                  break;
                }
                --v90;
                ++v91;
                if (v90 <= 1)
                {
                  *((unsigned char *)v56 + v91) = 0;
                  break;
                }
              }

              uint64_t v93 = v89;
              __int16 v94 = *((_WORD *)v93 + 68);

              *((_WORD *)v56 + 316) = v94;
              os_release(v93);
              int v42 = v218;
            }
            else
            {
              int v42 = v218;
              if ((*v67 & 0x800) == 0)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                int v95 = gLogObj;
                if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                {
                  int v96 = *(_DWORD *)(*((void *)v56 + 42) + 1280);
                  uint64_t v97 = *((void *)v56 + 30);
                  uint64_t v98 = *((void *)v56 + 44);
                  *(_DWORD *)buf = 136447746;
                  *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = (char *)v56 + 636;
                  *(_WORD *)&unsigned char buf[22] = 2080;
                  *(void *)&unsigned char buf[24] = " ";
                  *(_WORD *)&unsigned char buf[32] = 1024;
                  *(_DWORD *)&buf[34] = v96;
                  *(_WORD *)&buf[38] = 2048;
                  *(void *)&unsigned char buf[40] = v97;
                  *(_WORD *)&buf[48] = 2048;
                  *(void *)&buf[50] = v56;
                  *(_WORD *)&buf[58] = 2048;
                  *(void *)&buf[60] = v98;
                  _os_log_impl(&dword_1830D4000, v95, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%llu> Failed to access options for protocol %p, parameters %p", buf, 0x44u);
                }
              }
            }
LABEL_137:
            uint64_t v99 = *((void *)handle + 110);
            *((void *)v56 + 68) = v99;
            if (v99) {
              unint64_t v100 = (void *)(v99 + 552);
            }
            else {
              unint64_t v100 = handle + 888;
            }
            *unint64_t v100 = v56 + 34;
            *((void *)handle + 110) = v56;
            *((void *)v56 + 69) = handle + 880;
            if (*((void *)handle + 6))
            {
              if (v68)
              {
LABEL_142:
                *(_OWORD *)handle = *(_OWORD *)v42->flow_id;
                if (((*(unsigned __int16 *)(handle + 1373) | (handle[1375] << 16)) & 0x400000) == 0)
                {
                  if (gLogDatapath)
                  {
                    id v193 = __nwlog_obj();
                    if (os_log_type_enabled(v193, OS_LOG_TYPE_DEBUG))
                    {
                      int v194 = *((_DWORD *)handle + 320);
                      uint64_t v195 = *((void *)handle + 6);
                      *(_DWORD *)buf = 136447746;
                      *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&buf[14] = handle + 1289;
                      *(_WORD *)&unsigned char buf[22] = 2080;
                      *(void *)&unsigned char buf[24] = " ";
                      *(_WORD *)&unsigned char buf[32] = 1024;
                      *(_DWORD *)&buf[34] = v194;
                      *(_WORD *)&buf[38] = 2048;
                      *(void *)&unsigned char buf[40] = handle;
                      *(_WORD *)&buf[48] = 2048;
                      *(void *)&buf[50] = v195;
                      *(_WORD *)&buf[58] = 2048;
                      *(void *)&buf[60] = v42;
                      _os_log_impl(&dword_1830D4000, v193, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> protocol %p protocol->default_input_handler %p input_protocol %p", buf, 0x44u);
                    }
                  }
                }
                if (!*((void *)handle + 152))
                {
                  unint64_t v123 = object;
                  id v124 = *(id *)(v214[13] + 136);

                  unsigned int v125 = (void *)*((void *)handle + 151);
                  if (v125)
                  {
                    os_release(v125);
                    *((void *)handle + 151) = 0;
                  }
                  id v126 = nw_path_copy_flow_registration(v124, (uint64_t)handle);
                  *((void *)handle + 151) = v126;
                  int v42 = v218;
                  if (v124)
                  {
                    os_release(v124);
                    id v126 = (id)*((void *)handle + 151);
                  }
                  if (v126)
                  {
                    id v127 = nw_path_flow_registration_copy_endpoint(v126);
                    id v128 = nw_path_flow_registration_copy_parameters(*((void **)handle + 151));
                    uint64_t v129 = nw_endpoint_copy_association_with_evaluator(v127, v128, 0);
                    *((void *)handle + 152) = v129;
                    if (v127)
                    {
                      os_release(v127);
                      uint64_t v129 = (id *)*((void *)handle + 152);
                    }
                    if (v129)
                    {
                      unsigned int v130 = nw_protocol_instance_stub_create((nw_protocol *)handle);
                      *((void *)handle + 153) = v130;
                      nw_association_register_internal(*((void **)handle + 152), v123, v130, 0, 0, &__block_literal_global_177);
                      id v131 = nw_association_copy_current_path(*((void **)handle + 152), v128);
                      if (v131)
                      {
                        uint64_t v132 = v131;
                        BOOL v133 = nw_path_copy_for_flow_registration(v131, *((void **)handle + 151));
                        if (v133)
                        {
                          int v134 = (void *)v133;
                          v135 = *v213;
                          if (*v213 != v134)
                          {
                            if (v135)
                            {
                              os_release(v135);
                              *unsigned int v213 = 0;
                            }
                            *unsigned int v213 = os_retain(v134);
                          }
                          if (nw_path_has_flows(v134)) {
                            int v136 = -8388608;
                          }
                          else {
                            int v136 = 0;
                          }
                          handle[1375] = (v136 & 0xFF80FFFF | ((handle[1375] & 0x7F) << 16)) >> 16;
                          id v137 = nw_parameters_copy_effective_proxy_config(v123);
                          if (v137)
                          {
                            int v138 = v137;
                            if (nw_path_has_proxy_config(v132, v137))
                            {
                              int v139 = (void *)*((void *)handle + 154);
                              if (v139) {
                                os_release(v139);
                              }
                              *((void *)handle + 154) = v138;
                            }
                            else
                            {
                              os_release(v138);
                            }
                          }
                          os_release(v132);
                        }
                        else
                        {
                          int v134 = v132;
                        }
                        os_release(v134);
                      }
                    }
                    if (v128) {
                      os_release(v128);
                    }
                  }
                }
                unint64_t v101 = nw_parameters_copy_protocol_options_legacy(object, (nw_protocol *)v56);
                if (!v101) {
                  goto LABEL_233;
                }
                int v102 = v101;
                uint64_t v103 = v102;
                handle[1289] = 0;
                unint64_t v104 = 84;
                uint64_t v105 = 1289;
                while (1)
                {
                  int v106 = v102[v105 - 1241];
                  handle[v105] = v106;
                  if (!v106) {
                    break;
                  }
                  --v104;
                  ++v105;
                  if (v104 <= 1)
                  {
                    handle[v105] = 0;
                    break;
                  }
                }

                v107 = v103;
                __int16 v108 = *((_WORD *)v107 + 68);

                *((_WORD *)handle + 643) = v108;
                *((void *)handle + 127) = 1000 * nw_http3_get_idle_timeout(v107);
                *((_DWORD *)handle + 319) = nw_http3_get_keepalive_mode(v107);
                if (nw_http3_get_0rtt_enabled(v107)) {
                  __int16 v109 = 32;
                }
                else {
                  __int16 v109 = 0;
                }
                int v110 = *(_WORD *)(handle + 1373) & 0xFFDF | (handle[1375] << 16);
                *(_WORD *)uint64_t v219 = *(_WORD *)v219 & 0xFFDF | v109;
                handle[1375] = BYTE2(v110);
                handle[1288] = nw_http3_get_sessions_to_request(v107);
                nw_http3_get_resumable_session_agent(v107, (uint64_t)(handle + 848));
                *((_DWORD *)handle + 320) = nw_protocol_get_next_instance_id();
                uint64_t v111 = v107;
                int v112 = *((_DWORD *)v111 + 33);

                if (((*(unsigned __int16 *)(handle + 1373) | (handle[1375] << 16)) & 0x400000) == 0)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  uint64_t v113 = gLogObj;
                  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
                  {
                    int v114 = *((_DWORD *)handle + 320);
                    *(_DWORD *)buf = 136447490;
                    *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = handle + 1289;
                    *(_WORD *)&unsigned char buf[22] = 2080;
                    *(void *)&unsigned char buf[24] = " ";
                    *(_WORD *)&unsigned char buf[32] = 1024;
                    *(_DWORD *)&buf[34] = v114;
                    *(_WORD *)&buf[38] = 1024;
                    *(_DWORD *)&unsigned char buf[40] = v114;
                    *(_WORD *)&buf[44] = 1024;
                    *(_DWORD *)&buf[46] = v112;
                    _os_log_impl(&dword_1830D4000, v113, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> created HTTP/3 and assigned instance ID: %u from C%u", buf, 0x32u);
                  }
                }
                unint64_t v115 = (const void *)*((void *)handle + 108);
                int v42 = v218;
                if (v115)
                {
                  _Block_release(v115);
                  *((void *)handle + 108) = 0;
                }
                int v116 = *((void *)handle + 109);
                if (v116)
                {
                  dispatch_release(v116);
                  *((void *)handle + 109) = 0;
                }
                *((void *)handle + 108) = nw_http3_copy_resumable_session_handler(v111);
                *((void *)handle + 109) = nw_http3_copy_resumable_session_handler_queue(v111);
                unint64_t v221 = 0;
                unint64_t v222 = 0;
                unint64_t v220 = 0;
                if (!nw_http3_get_initial_remote_settings(v111, (uint64_t)&v222, (uint64_t)&v221, (uint64_t)&v220))goto LABEL_232; {
                memset(type, 0, 63);
                }
                unint64_t v117 = v221;
                unint64_t v118 = v222;
                unint64_t v119 = v220;
                memset(buf, 0, 63);
                if (v222 == -1)
                {
                  size_t v140 = 0;
                }
                else
                {
                  unint64_t __src = 6;
                  buf[0] = 6;
                  if (v222 > 0x3F)
                  {
                    if (v222 >> 14)
                    {
                      if (v222 >> 30)
                      {
                        if (v222 >> 62)
                        {
                          BOOL v142 = __nwlog_obj();
                          os_log_type_enabled(v142, OS_LOG_TYPE_ERROR);
                          *(_DWORD *)uint64_t v225 = 136446466;
                          *(void *)&v225[4] = "_http_vle_encode";
                          *(_WORD *)&v225[12] = 2048;
                          *(void *)&v225[14] = v118;
                          unsigned int v143 = (void *)_os_log_send_and_compose_impl();
                          BOOL result = __nwlog_abort((uint64_t)v143);
                          if (result) {
                            goto LABEL_387;
                          }
                          free(v143);
                          size_t v120 = 0;
                        }
                        else
                        {
                          unint64_t __src = bswap64(v222 | 0xC000000000000000);
                          size_t v120 = 8;
                        }
                      }
                      else
                      {
                        unint64_t __src = bswap32(v222 | 0x80000000);
                        size_t v120 = 4;
                      }
                    }
                    else
                    {
                      unint64_t __src = bswap32(v222 | 0x4000) >> 16;
                      size_t v120 = 2;
                    }
                  }
                  else
                  {
                    unint64_t __src = v222;
                    size_t v120 = 1;
                  }
                  memcpy(&buf[1], &__src, v120);
                  size_t v140 = v120 + 1;
                }
                unint64_t __src = 1;
                buf[v140] = 1;
                if (v117 > 0x3F)
                {
                  if (v117 >> 14)
                  {
                    if (v117 >> 30)
                    {
                      if (v117 >> 62)
                      {
                        int v145 = __nwlog_obj();
                        os_log_type_enabled(v145, OS_LOG_TYPE_ERROR);
                        *(_DWORD *)uint64_t v225 = 136446466;
                        *(void *)&v225[4] = "_http_vle_encode";
                        *(_WORD *)&v225[12] = 2048;
                        *(void *)&v225[14] = v117;
                        int v146 = (void *)_os_log_send_and_compose_impl();
                        BOOL result = __nwlog_abort((uint64_t)v146);
                        if (result) {
                          goto LABEL_387;
                        }
                        free(v146);
                        size_t v144 = 0;
                      }
                      else
                      {
                        unint64_t __src = bswap64(v117 | 0xC000000000000000);
                        size_t v144 = 8;
                      }
                    }
                    else
                    {
                      unint64_t __src = bswap32(v117 | 0x80000000);
                      size_t v144 = 4;
                    }
                  }
                  else
                  {
                    unint64_t __src = bswap32(v117 | 0x4000) >> 16;
                    size_t v144 = 2;
                  }
                }
                else
                {
                  unint64_t __src = v117;
                  size_t v144 = 1;
                }
                memcpy(&buf[v140 + 1], &__src, v144);
                size_t v147 = v144 + v140 + 1;
                unint64_t __src = 7;
                buf[v147] = 7;
                if (v119 <= 0x3F)
                {
                  unint64_t __src = v119;
                  size_t v148 = 1;
LABEL_231:
                  memcpy(&buf[v147 + 1], &__src, v148);
                  size_t v151 = v148 + v147 + 1;
                  memcpy(type, buf, v151);
                  *((void *)handle + 144) = dispatch_data_create(type, v151, 0, 0);
                  *(_WORD *)v219 |= 0x40u;
LABEL_232:
                  os_release(v111);
                  goto LABEL_233;
                }
                if (!(v119 >> 14))
                {
                  unint64_t __src = bswap32(v119 | 0x4000) >> 16;
                  size_t v148 = 2;
                  goto LABEL_231;
                }
                if (!(v119 >> 30))
                {
                  unint64_t __src = bswap32(v119 | 0x80000000);
                  size_t v148 = 4;
                  goto LABEL_231;
                }
                if (!(v119 >> 62))
                {
                  unint64_t __src = bswap64(v119 | 0xC000000000000000);
                  size_t v148 = 8;
                  goto LABEL_231;
                }
                int v149 = __nwlog_obj();
                os_log_type_enabled(v149, OS_LOG_TYPE_ERROR);
                *(_DWORD *)uint64_t v225 = 136446466;
                *(void *)&v225[4] = "_http_vle_encode";
                *(_WORD *)&v225[12] = 2048;
                *(void *)&v225[14] = v119;
                int v150 = (void *)_os_log_send_and_compose_impl();
                BOOL result = __nwlog_abort((uint64_t)v150);
                if (!result)
                {
                  free(v150);
                  size_t v148 = 0;
                  goto LABEL_231;
                }
LABEL_387:
                __break(1u);
                return result;
              }
            }
            else
            {
              nw_protocol_set_input_handler((uint64_t)handle, (uint64_t)v42);
              if (v68) {
                goto LABEL_142;
              }
            }
            if (v34)
            {
              uint64_t v121 = *(void (***)(uint64_t, _OWORD *))(v34 + 24);
              if (v121)
              {
                unint64_t v122 = *v121;
                if (v122)
                {
                  v122(v34, v56);
LABEL_233:
                  if (*((void *)handle + 158))
                  {
                    if (((*(unsigned __int16 *)(handle + 1373) | (handle[1375] << 16)) & 0x400000) == 0)
                    {
                      if (gLogDatapath)
                      {
                        unsigned int v180 = __nwlog_obj();
                        if (os_log_type_enabled(v180, OS_LOG_TYPE_DEBUG))
                        {
                          int v181 = *((_DWORD *)handle + 320);
                          *(_DWORD *)buf = 136446978;
                          *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
                          *(_WORD *)&buf[12] = 2082;
                          *(void *)&buf[14] = handle + 1289;
                          *(_WORD *)&unsigned char buf[22] = 2080;
                          *(void *)&unsigned char buf[24] = " ";
                          *(_WORD *)&unsigned char buf[32] = 1024;
                          *(_DWORD *)&buf[34] = v181;
                          _os_log_impl(&dword_1830D4000, v180, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> deactivating destroy timer because we are active again", buf, 0x26u);
                        }
                      }
                    }
                    nw_queue_cancel_source(*((void *)handle + 158));
                    *((void *)handle + 158) = 0;
                  }
                  int v152 = *(unsigned __int16 *)(handle + 1373) | (handle[1375] << 16);
                  if ((v152 & 0x200000) != 0 && *((void *)handle + 155) && *((_DWORD *)handle + 319) == 2)
                  {
                    if ((v152 & 0x400000) == 0)
                    {
                      if (gLogDatapath)
                      {
                        uint64_t v209 = __nwlog_obj();
                        if (os_log_type_enabled(v209, OS_LOG_TYPE_DEBUG))
                        {
                          int v210 = *((_DWORD *)handle + 320);
                          *(_DWORD *)buf = 136446978;
                          *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
                          *(_WORD *)&buf[12] = 2082;
                          *(void *)&buf[14] = handle + 1289;
                          *(_WORD *)&unsigned char buf[22] = 2080;
                          *(void *)&unsigned char buf[24] = " ";
                          *(_WORD *)&unsigned char buf[32] = 1024;
                          *(_DWORD *)&buf[34] = v210;
                          _os_log_impl(&dword_1830D4000, v209, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> re-enabling QUIC keepalives", buf, 0x26u);
                        }
                      }
                    }
                    int v153 = *(unsigned __int16 *)v219;
                    unsigned int v154 = (v153 | (handle[1375] << 16)) & 0xFFDFFFFF;
                    *(_WORD *)uint64_t v219 = v153;
                    handle[1375] = BYTE2(v154);
                    nw_quic_connection_set_keepalive(*((void **)handle + 155), 0xFFFF);
                    buf[0] = 0;
                    output_handler = a1->output_handler;
                    if (output_handler)
                    {
                      unsigned int v156 = output_handler->callbacks;
                      if (v156)
                      {
                        notify = (void (*)(nw_protocol *, nw_protocol *))v156->notify;
                        if (notify) {
                          notify(output_handler, a1);
                        }
                      }
                    }
                    int v152 = *(unsigned __int16 *)(handle + 1373) | (handle[1375] << 16);
                  }
                  if ((v152 & 0x400000) == 0)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    unsigned int v158 = gLogObj;
                    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
                    {
                      int v159 = *((_DWORD *)handle + 320);
                      *(_DWORD *)buf = 136447490;
                      *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&buf[14] = handle + 1289;
                      *(_WORD *)&unsigned char buf[22] = 2080;
                      *(void *)&unsigned char buf[24] = " ";
                      *(_WORD *)&unsigned char buf[32] = 1024;
                      *(_DWORD *)&buf[34] = v159;
                      *(_WORD *)&buf[38] = 2048;
                      *(void *)&unsigned char buf[40] = v42;
                      *(_WORD *)&buf[48] = 2082;
                      *(void *)&buf[50] = (char *)v56 + 636;
                      _os_log_impl(&dword_1830D4000, v158, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s%s<i%u> added input handler %p from %{public}s", buf, 0x3Au);
                    }
                  }
                  return 1;
                }
              }
              __nwlog_obj();
              unint64_t v179 = *(const char **)(v34 + 16);
              if (!v179) {
                unint64_t v179 = "invalid";
              }
            }
            else
            {
              __nwlog_obj();
              unint64_t v179 = "invalid";
            }
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v179;
            unint64_t v183 = (char *)_os_log_send_and_compose_impl();
            type[0] = OS_LOG_TYPE_ERROR;
            v225[0] = 0;
            if (__nwlog_fault(v183, type, v225))
            {
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                uint64_t v184 = __nwlog_obj();
                os_log_type_t v185 = type[0];
                if (!os_log_type_enabled(v184, type[0])) {
                  goto LABEL_351;
                }
                unint64_t v186 = "invalid";
                if (v34 && *(void *)(v34 + 16)) {
                  unint64_t v186 = *(const char **)(v34 + 16);
                }
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v186;
                v187 = "%{public}s protocol %{public}s has invalid add_input_handler callback";
LABEL_349:
                unint64_t v206 = v184;
                os_log_type_t v207 = v185;
LABEL_350:
                _os_log_impl(&dword_1830D4000, v206, v207, v187, buf, 0x16u);
                int v42 = v218;
                goto LABEL_351;
              }
              if (!v225[0])
              {
                uint64_t v184 = __nwlog_obj();
                os_log_type_t v185 = type[0];
                if (!os_log_type_enabled(v184, type[0])) {
                  goto LABEL_351;
                }
                unint64_t v205 = "invalid";
                if (v34 && *(void *)(v34 + 16)) {
                  unint64_t v205 = *(const char **)(v34 + 16);
                }
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v205;
                v187 = "%{public}s protocol %{public}s has invalid add_input_handler callback, backtrace limit exceeded";
                goto LABEL_349;
              }
              v188 = (char *)__nw_create_backtrace_string();
              unint64_t v189 = __nwlog_obj();
              os_log_type_t v190 = type[0];
              BOOL v191 = os_log_type_enabled(v189, type[0]);
              if (v188)
              {
                if (v191)
                {
                  unint64_t v192 = "invalid";
                  if (v34 && *(void *)(v34 + 16)) {
                    unint64_t v192 = *(const char **)(v34 + 16);
                  }
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v192;
                  *(_WORD *)&unsigned char buf[22] = 2082;
                  *(void *)&unsigned char buf[24] = v188;
                  _os_log_impl(&dword_1830D4000, v189, v190, "%{public}s protocol %{public}s has invalid add_input_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
                  int v42 = v218;
                }
                free(v188);
                goto LABEL_351;
              }
              if (v191)
              {
                size_t v208 = "invalid";
                if (v34 && *(void *)(v34 + 16)) {
                  size_t v208 = *(const char **)(v34 + 16);
                }
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v208;
                v187 = "%{public}s protocol %{public}s has invalid add_input_handler callback, no backtrace";
                unint64_t v206 = v189;
                os_log_type_t v207 = v190;
                goto LABEL_350;
              }
            }
LABEL_351:
            if (v183) {
              free(v183);
            }
            goto LABEL_233;
          }
          __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
          uint64_t v170 = (char *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          v225[0] = 0;
          int v42 = v218;
          if (!__nwlog_fault(v170, type, v225)) {
            goto LABEL_385;
          }
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            unint64_t v171 = __nwlog_obj();
            os_log_type_t v172 = type[0];
            if (!os_log_type_enabled(v171, type[0])) {
              goto LABEL_385;
            }
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
            uint64_t v173 = "%{public}s called with null options_protocol";
            goto LABEL_384;
          }
          if (!v225[0])
          {
            unint64_t v171 = __nwlog_obj();
            os_log_type_t v172 = type[0];
            BOOL v68 = v215;
            if (!os_log_type_enabled(v171, type[0])) {
              goto LABEL_385;
            }
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
            uint64_t v173 = "%{public}s called with null options_protocol, backtrace limit exceeded";
            goto LABEL_384;
          }
          uint64_t v198 = (char *)__nw_create_backtrace_string();
          unint64_t v171 = __nwlog_obj();
          os_log_type_t v172 = type[0];
          BOOL v201 = os_log_type_enabled(v171, type[0]);
          if (!v198)
          {
            int v42 = v218;
            BOOL v68 = v215;
            if (!v201) {
              goto LABEL_385;
            }
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
            uint64_t v173 = "%{public}s called with null options_protocol, no backtrace";
            goto LABEL_384;
          }
          if (v201)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v198;
            unint64_t v200 = "%{public}s called with null options_protocol, dumping backtrace:%{public}s";
            goto LABEL_332;
          }
          goto LABEL_333;
        }
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
        uint64_t v170 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        v225[0] = 0;
        if (!__nwlog_fault(v170, type, v225)) {
          goto LABEL_385;
        }
        if (type[0] != OS_LOG_TYPE_FAULT)
        {
          if (!v225[0])
          {
            unint64_t v171 = __nwlog_obj();
            os_log_type_t v172 = type[0];
            BOOL v68 = v215;
            if (!os_log_type_enabled(v171, type[0])) {
              goto LABEL_385;
            }
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
            uint64_t v173 = "%{public}s called with null parameters, backtrace limit exceeded";
            goto LABEL_384;
          }
          uint64_t v198 = (char *)__nw_create_backtrace_string();
          unint64_t v171 = __nwlog_obj();
          os_log_type_t v172 = type[0];
          BOOL v199 = os_log_type_enabled(v171, type[0]);
          if (!v198)
          {
            int v42 = v218;
            BOOL v68 = v215;
            if (!v199) {
              goto LABEL_385;
            }
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
            uint64_t v173 = "%{public}s called with null parameters, no backtrace";
            goto LABEL_384;
          }
          if (v199)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v198;
            unint64_t v200 = "%{public}s called with null parameters, dumping backtrace:%{public}s";
LABEL_332:
            _os_log_impl(&dword_1830D4000, v171, v172, v200, buf, 0x16u);
          }
LABEL_333:
          free(v198);
          int v42 = v218;
          BOOL v68 = v215;
          if (!v170) {
            goto LABEL_137;
          }
LABEL_386:
          free(v170);
          goto LABEL_137;
        }
        unint64_t v171 = __nwlog_obj();
        os_log_type_t v172 = type[0];
        if (!os_log_type_enabled(v171, type[0])) {
          goto LABEL_385;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
        uint64_t v173 = "%{public}s called with null parameters";
      }
      else
      {
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
        uint64_t v170 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        v225[0] = 0;
        if (!__nwlog_fault(v170, type, v225)) {
          goto LABEL_385;
        }
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          unint64_t v171 = __nwlog_obj();
          os_log_type_t v172 = type[0];
          if (!os_log_type_enabled(v171, type[0])) {
            goto LABEL_385;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
          uint64_t v173 = "%{public}s called with null input_protocol";
        }
        else if (v225[0])
        {
          unint64_t v196 = (char *)__nw_create_backtrace_string();
          unint64_t v171 = __nwlog_obj();
          os_log_type_t v172 = type[0];
          BOOL v197 = os_log_type_enabled(v171, type[0]);
          if (v196)
          {
            if (v197)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v196;
              _os_log_impl(&dword_1830D4000, v171, v172, "%{public}s called with null input_protocol, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v196);
            int v42 = a2;
            BOOL v68 = v215;
LABEL_385:
            if (!v170) {
              goto LABEL_137;
            }
            goto LABEL_386;
          }
          int v42 = a2;
          BOOL v68 = v215;
          if (!v197) {
            goto LABEL_385;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
          uint64_t v173 = "%{public}s called with null input_protocol, no backtrace";
        }
        else
        {
          unint64_t v171 = __nwlog_obj();
          os_log_type_t v172 = type[0];
          BOOL v68 = v215;
          if (!os_log_type_enabled(v171, type[0])) {
            goto LABEL_385;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
          uint64_t v173 = "%{public}s called with null input_protocol, backtrace limit exceeded";
        }
      }
LABEL_384:
      _os_log_impl(&dword_1830D4000, v171, v172, v173, buf, 0xCu);
      goto LABEL_385;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
    int v160 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v225[0] = 0;
    if (!__nwlog_fault(v160, type, v225)) {
      goto LABEL_375;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v161 = __nwlog_obj();
      os_log_type_t v162 = type[0];
      if (!os_log_type_enabled(v161, type[0])) {
        goto LABEL_375;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
      v163 = "%{public}s called with null parameters";
      goto LABEL_374;
    }
    if (!v225[0])
    {
      uint64_t v161 = __nwlog_obj();
      os_log_type_t v162 = type[0];
      if (!os_log_type_enabled(v161, type[0])) {
        goto LABEL_375;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
      v163 = "%{public}s called with null parameters, backtrace limit exceeded";
      goto LABEL_374;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v161 = __nwlog_obj();
    os_log_type_t v162 = type[0];
    BOOL v182 = os_log_type_enabled(v161, type[0]);
    if (backtrace_string)
    {
      if (v182)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        v166 = "%{public}s called with null parameters, dumping backtrace:%{public}s";
        goto LABEL_299;
      }
LABEL_300:
      free(backtrace_string);
      goto LABEL_375;
    }
    if (!v182) {
      goto LABEL_375;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
    v163 = "%{public}s called with null parameters, no backtrace";
LABEL_374:
    _os_log_impl(&dword_1830D4000, v161, v162, v163, buf, 0xCu);
LABEL_375:
    if (v160) {
      free(v160);
    }
    return 0;
  }
  if (((*(unsigned __int16 *)(handle + 1373) | (handle[1375] << 16)) & 0x400000) != 0) {
    return 0;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  __int16 v13 = gLogObj;
  BOOL result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO);
  if (result)
  {
    int v15 = *((_DWORD *)handle + 320);
    *(_DWORD *)buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = handle + 1289;
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&unsigned char buf[24] = " ";
    *(_WORD *)&unsigned char buf[32] = 1024;
    *(_DWORD *)&buf[34] = v15;
    _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> cannot add input handler to closed connection", buf, 0x26u);
    return 0;
  }
  return result;
}

void sub_183B54858(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL43nw_http3_set_prohibit_joining_on_parametersP11nw_protocolP13nw_parameters_block_invoke(uint64_t a1, NSObject *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t protocol_handle = nw_protocol_options_get_protocol_handle(a2);
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    nw_protocol_definition_t v5 = nw_protocol_options_copy_definition(a2);
    identifier = nw_protocol_definition_get_identifier(v5);
    if (gLogDatapath)
    {
      uint64_t v7 = identifier;
      int64_t v8 = __nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v9 = *(void *)(a1 + 40);
        os_log_type_t v10 = "invalid";
        if (v9 && *(void *)(v9 + 16)) {
          os_log_type_t v10 = *(const char **)(v9 + 16);
        }
        int v11 = 136446978;
        int v12 = "nw_http3_set_prohibit_joining_on_parameters_block_invoke";
        __int16 v13 = 2080;
        uint32_t v14 = v10;
        __int16 v15 = 2048;
        uint64_t v16 = v9;
        __int16 v17 = 2080;
        os_log_type_t v18 = v7;
        _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_DEBUG, "%{public}s %s (%p) setting prohibit joining on %s", (uint8_t *)&v11, 0x2Au);
      }
    }
    if (v5) {
      os_release(v5);
    }
    nw_protocol_options_set_prohibit_joining(a2);
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
  }
  if (*(void *)(a1 + 40) == protocol_handle) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  }
}

uint64_t ___ZL22nw_http3_stream_createPK22nw_protocol_identifierP17nw_protocol_http3P11nw_endpointP13nw_parametersb_block_invoke(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
  }
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

void nw_http3_stream_replace_protocol_instance(uint64_t a1, void *a2, nw_protocol *a3, uint64_t a4)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v28 = "nw_http3_stream_replace_protocol_instance";
    int v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (!__nwlog_fault(v12, &type, &v25)) {
      goto LABEL_56;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_56;
      }
      *(_DWORD *)buf = 136446210;
      int v28 = "nw_http3_stream_replace_protocol_instance";
      __int16 v15 = "%{public}s called with null http3_stream";
    }
    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v20 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          int v28 = "nw_http3_stream_replace_protocol_instance";
          __int16 v29 = 2082;
          uint64_t v30 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null http3_stream, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_56:
        if (!v12) {
          return;
        }
        goto LABEL_57;
      }
      if (!v20) {
        goto LABEL_56;
      }
      *(_DWORD *)buf = 136446210;
      int v28 = "nw_http3_stream_replace_protocol_instance";
      __int16 v15 = "%{public}s called with null http3_stream, no backtrace";
    }
    else
    {
      __int16 v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_56;
      }
      *(_DWORD *)buf = 136446210;
      int v28 = "nw_http3_stream_replace_protocol_instance";
      __int16 v15 = "%{public}s called with null http3_stream, backtrace limit exceeded";
    }
    goto LABEL_55;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v28 = "nw_http3_stream_replace_protocol_instance";
    int v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (!__nwlog_fault(v12, &type, &v25)) {
      goto LABEL_56;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v25)
      {
        __int16 v13 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (!os_log_type_enabled(v13, type)) {
          goto LABEL_56;
        }
        *(_DWORD *)buf = 136446210;
        int v28 = "nw_http3_stream_replace_protocol_instance";
        __int16 v15 = "%{public}s called with null parameters, backtrace limit exceeded";
        goto LABEL_55;
      }
      uint64_t v21 = (char *)__nw_create_backtrace_string();
      __int16 v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v22 = os_log_type_enabled(v13, type);
      if (!v21)
      {
        if (!v22) {
          goto LABEL_56;
        }
        *(_DWORD *)buf = 136446210;
        int v28 = "nw_http3_stream_replace_protocol_instance";
        __int16 v15 = "%{public}s called with null parameters, no backtrace";
        goto LABEL_55;
      }
      if (v22)
      {
        *(_DWORD *)buf = 136446466;
        int v28 = "nw_http3_stream_replace_protocol_instance";
        __int16 v29 = 2082;
        uint64_t v30 = v21;
        os_log_type_t v23 = "%{public}s called with null parameters, dumping backtrace:%{public}s";
LABEL_40:
        _os_log_impl(&dword_1830D4000, v13, v14, v23, buf, 0x16u);
      }
LABEL_41:
      free(v21);
      if (!v12) {
        return;
      }
LABEL_57:
      free(v12);
      return;
    }
    __int16 v13 = __nwlog_obj();
    os_log_type_t v14 = type;
    if (!os_log_type_enabled(v13, type)) {
      goto LABEL_56;
    }
    *(_DWORD *)buf = 136446210;
    int v28 = "nw_http3_stream_replace_protocol_instance";
    __int16 v15 = "%{public}s called with null parameters";
LABEL_55:
    _os_log_impl(&dword_1830D4000, v13, v14, v15, buf, 0xCu);
    goto LABEL_56;
  }
  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v28 = "nw_http3_stream_replace_protocol_instance";
    int v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (!__nwlog_fault(v12, &type, &v25)) {
      goto LABEL_56;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_56;
      }
      *(_DWORD *)buf = 136446210;
      int v28 = "nw_http3_stream_replace_protocol_instance";
      __int16 v15 = "%{public}s called with null new_instance";
      goto LABEL_55;
    }
    if (!v25)
    {
      __int16 v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_56;
      }
      *(_DWORD *)buf = 136446210;
      int v28 = "nw_http3_stream_replace_protocol_instance";
      __int16 v15 = "%{public}s called with null new_instance, backtrace limit exceeded";
      goto LABEL_55;
    }
    uint64_t v21 = (char *)__nw_create_backtrace_string();
    __int16 v13 = __nwlog_obj();
    os_log_type_t v14 = type;
    BOOL v24 = os_log_type_enabled(v13, type);
    if (!v21)
    {
      if (!v24) {
        goto LABEL_56;
      }
      *(_DWORD *)buf = 136446210;
      int v28 = "nw_http3_stream_replace_protocol_instance";
      __int16 v15 = "%{public}s called with null new_instance, no backtrace";
      goto LABEL_55;
    }
    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      int v28 = "nw_http3_stream_replace_protocol_instance";
      __int16 v29 = 2082;
      uint64_t v30 = v21;
      os_log_type_t v23 = "%{public}s called with null new_instance, dumping backtrace:%{public}s";
      goto LABEL_40;
    }
    goto LABEL_41;
  }
  int64_t v8 = nw_parameters_copy_protocol_options_legacy(a2, a3);
  if (v8)
  {
    uint64_t v9 = v8;
    if ((*(_WORD *)(a1 + 736) & 0x800) == 0)
    {
      if (gLogDatapath)
      {
        uint64_t v16 = __nwlog_obj();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          int v17 = *(_DWORD *)(*(void *)(a1 + 336) + 1280);
          uint64_t v18 = *(void *)(a1 + 240);
          *(_DWORD *)buf = 136448514;
          int v28 = "nw_http3_stream_replace_protocol_instance";
          __int16 v29 = 2082;
          uint64_t v30 = (char *)(a1 + 636);
          __int16 v31 = 2080;
          BOOL v32 = " ";
          __int16 v33 = 1024;
          int v34 = v17;
          __int16 v35 = 2048;
          uint64_t v36 = v18;
          __int16 v37 = 2048;
          uint64_t v38 = a1;
          __int16 v39 = 2048;
          uint64_t v40 = a4;
          __int16 v41 = 2048;
          int v42 = a3;
          __int16 v43 = 2048;
          int64_t v44 = a2;
          __int16 v45 = 2048;
          BOOL v46 = v9;
          _os_log_impl(&dword_1830D4000, v16, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> http3_stream protocol %p, set protocol instance to %p instead of %p in parameters %p options %p", buf, 0x62u);
        }
      }
    }
    if (nw_protocol_copy_http3_definition_onceToken != -1) {
      dispatch_once(&nw_protocol_copy_http3_definition_onceToken, &__block_literal_global_13_73886);
    }
    id v10 = (id)nw_protocol_copy_http3_definition_http3_definition;
    int v11 = v9;
    *((void *)v11 + 2) = a4;

    if (v10) {
      os_release(v10);
    }
    os_release(v11);
  }
}

void ___ZL36nw_protocol_http3_set_up_associationP17nw_protocol_http3P13nw_parameters_block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t handle = nw_protocol_instance_stub_get_handle(a2);
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v36 = "nw_protocol_http3_set_up_association_block_invoke";
    char v25 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v25, &type, &v33)) {
      goto LABEL_61;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v26 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_61;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v36 = "nw_protocol_http3_set_up_association_block_invoke";
      int v28 = "%{public}s called with null protocol_handle";
      goto LABEL_60;
    }
    if (!v33)
    {
      __int16 v26 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_61;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v36 = "nw_protocol_http3_set_up_association_block_invoke";
      int v28 = "%{public}s called with null protocol_handle, backtrace limit exceeded";
      goto LABEL_60;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v26 = __nwlog_obj();
    os_log_type_t v27 = type;
    BOOL v30 = os_log_type_enabled(v26, type);
    if (!backtrace_string)
    {
      if (!v30) {
        goto LABEL_61;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v36 = "nw_protocol_http3_set_up_association_block_invoke";
      int v28 = "%{public}s called with null protocol_handle, no backtrace";
      goto LABEL_60;
    }
    if (v30)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v36 = "nw_protocol_http3_set_up_association_block_invoke";
      __int16 v37 = 2082;
      uint64_t v38 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v26, v27, "%{public}s called with null protocol_handle, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_61:
    if (!v25) {
      return;
    }
    goto LABEL_62;
  }
  uint64_t v5 = *(void *)(handle + 40);
  if (!v5)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v36 = "nw_protocol_http3_set_up_association_block_invoke";
    char v25 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v25, &type, &v33)) {
      goto LABEL_61;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v26 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_61;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v36 = "nw_protocol_http3_set_up_association_block_invoke";
      int v28 = "%{public}s called with null http3";
      goto LABEL_60;
    }
    if (!v33)
    {
      __int16 v26 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_61;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v36 = "nw_protocol_http3_set_up_association_block_invoke";
      int v28 = "%{public}s called with null http3, backtrace limit exceeded";
      goto LABEL_60;
    }
    __int16 v31 = (char *)__nw_create_backtrace_string();
    __int16 v26 = __nwlog_obj();
    os_log_type_t v27 = type;
    BOOL v32 = os_log_type_enabled(v26, type);
    if (v31)
    {
      if (v32)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v36 = "nw_protocol_http3_set_up_association_block_invoke";
        __int16 v37 = 2082;
        uint64_t v38 = v31;
        _os_log_impl(&dword_1830D4000, v26, v27, "%{public}s called with null http3, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v31);
      if (!v25) {
        return;
      }
LABEL_62:
      free(v25);
      return;
    }
    if (v32)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v36 = "nw_protocol_http3_set_up_association_block_invoke";
      int v28 = "%{public}s called with null http3, no backtrace";
LABEL_60:
      _os_log_impl(&dword_1830D4000, v26, v27, v28, buf, 0xCu);
      goto LABEL_61;
    }
    goto LABEL_61;
  }
  id v6 = (_WORD *)(v5 + 1373);
  if (((*(unsigned __int16 *)(v5 + 1373) | (*(unsigned __int8 *)(v5 + 1375) << 16)) & 0x10008) == 0)
  {
    BOOL v7 = nw_path_copy_for_flow_registration(a3, *(void **)(v5 + 1208));
    if (v7)
    {
      int64_t v8 = (void *)v7;
      uint64_t v9 = *(void **)(v5 + 1112);
      if (v9 != v8)
      {
        if (v9)
        {
          os_release(v9);
          *(void *)(v5 + 1112) = 0;
        }
        *(void *)(v5 + 1112) = os_retain(v8);
      }
      id v10 = *(void **)(v5 + 1232);
      if (v10 && (nw_path_has_proxy_config(v8, v10) & 1) == 0)
      {
        if ((((unsigned __int16)*v6 | (*(unsigned __int8 *)(v5 + 1375) << 16)) & 0x400000) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v19 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          {
            int v20 = *(_DWORD *)(v5 + 1280);
            *(_DWORD *)buf = 136446978;
            uint64_t v36 = "nw_protocol_http3_set_up_association_block_invoke";
            __int16 v37 = 2082;
            uint64_t v38 = (char *)(v5 + 1289);
            __int16 v39 = 2080;
            uint64_t v40 = " ";
            __int16 v41 = 1024;
            int v42 = v20;
            _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Effective proxy configuration lost, treating as a GOAWAY", buf, 0x26u);
          }
        }
        nw_http3_async_close_connection_if_no_stream(v5);
        nw_http3_notify_do_not_reuse(v5);
        goto LABEL_31;
      }
      if (((unsigned __int16)*v6 | (*(char *)(v5 + 1375) << 16)) < 0)
      {
        BOOL is_viable = nw_path_is_viable(v8);
        int alternate_path_state = nw_path_get_alternate_path_state(v8, a3);
        int v13 = (unsigned __int16)*v6 | (*(unsigned __int8 *)(v5 + 1375) << 16);
        if (is_viable && alternate_path_state == 0)
        {
          if ((v13 & 0x80000) != 0)
          {
            if ((v13 & 0x400000) == 0)
            {
              uint64_t v21 = __nwlog_obj();
              if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
              {
                int v22 = *(_DWORD *)(v5 + 1280);
                *(_DWORD *)buf = 136446978;
                uint64_t v36 = "nw_protocol_http3_set_up_association_block_invoke";
                __int16 v37 = 2082;
                uint64_t v38 = (char *)(v5 + 1289);
                __int16 v39 = 2080;
                uint64_t v40 = " ";
                __int16 v41 = 1024;
                int v42 = v22;
                _os_log_impl(&dword_1830D4000, v21, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Path recovered, recommending that new flows join", buf, 0x26u);
              }
            }
            int v23 = (unsigned __int16)*v6;
            unsigned int v24 = (v23 | (*(unsigned __int8 *)(v5 + 1375) << 16)) & 0xFFF7FFFF;
            *id v6 = v23;
            *(unsigned char *)(v5 + 1375) = BYTE2(v24);
            uint64_t v17 = v5;
            int v18 = 1;
            goto LABEL_30;
          }
        }
        else if ((v13 & 0x80000) == 0)
        {
          if ((v13 & 0x400000) == 0)
          {
            __int16 v15 = __nwlog_obj();
            if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
            {
              int v16 = *(_DWORD *)(v5 + 1280);
              *(_DWORD *)buf = 136446978;
              uint64_t v36 = "nw_protocol_http3_set_up_association_block_invoke";
              __int16 v37 = 2082;
              uint64_t v38 = (char *)(v5 + 1289);
              __int16 v39 = 2080;
              uint64_t v40 = " ";
              __int16 v41 = 1024;
              int v42 = v16;
              _os_log_impl(&dword_1830D4000, v15, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Bad path, recommending that new flows not join", buf, 0x26u);
            }
          }
          *(unsigned char *)(v5 + 1375) = ((unsigned __int16)*v6 | (*(unsigned __int8 *)(v5 + 1375) << 16) | 0x80000u) >> 16;
          uint64_t v17 = v5;
          int v18 = 0;
LABEL_30:
          nw_http3_notify_viability_changed(v17, v18);
        }
      }
LABEL_31:
      os_release(v8);
    }
  }
}

void nw_http3_notify_viability_changed(uint64_t a1, int a2)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 880);
  if (v2)
  {
    char v3 = a2;
    uint64_t v5 = (unsigned __int16 *)(a1 + 1373);
    id v6 = (const char *)(a1 + 1289);
    if (a2) {
      BOOL v7 = "";
    }
    else {
      BOOL v7 = "not ";
    }
    do
    {
      uint64_t v8 = *(void *)(v2 + 544);
      if ((*(_WORD *)(v2 + 736) & 0x8000) != 0)
      {
        if (((*v5 | (*((unsigned __int8 *)v5 + 2) << 16)) & 0x400000) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v9 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          {
            int v10 = *(_DWORD *)(a1 + 1280);
            uint64_t v11 = *(void *)(v2 + 240);
            *(_DWORD *)buf = 136447490;
            uint64_t v38 = "nw_http3_notify_viability_changed";
            __int16 v39 = 2082;
            uint64_t v40 = v6;
            __int16 v41 = 2080;
            int v42 = " ";
            __int16 v43 = 1024;
            int v44 = v10;
            __int16 v45 = 2048;
            uint64_t v46 = v11;
            __int16 v47 = 2082;
            id v48 = v7;
            _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Notifying stream %llu that the connection is %{public}sviable", buf, 0x3Au);
          }
        }
        char v36 = v3;
        uint64_t v12 = *(void *)(v2 + 24);
        if (!v12 || (int v13 = *(void (**)(uint64_t, uint64_t, uint64_t, char *, uint64_t))(v12 + 160)) == 0)
        {
          __nwlog_obj();
          os_log_type_t v14 = *(const char **)(v2 + 16);
          if (!v14) {
            os_log_type_t v14 = "invalid";
          }
          *(_DWORD *)buf = 136446466;
          uint64_t v38 = "nw_http3_notify_viability_changed";
          __int16 v39 = 2082;
          uint64_t v40 = v14;
          __int16 v15 = (const char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v34 = 0;
          char v33 = (char *)v15;
          if (!__nwlog_fault(v15, &type, &v34)) {
            goto LABEL_37;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            int v16 = __nwlog_obj();
            os_log_type_t v17 = type;
            *(void *)BOOL v30 = v16;
            if (os_log_type_enabled(v16, type))
            {
              int v18 = *(const char **)(v2 + 16);
              if (!v18) {
                int v18 = "invalid";
              }
              *(_DWORD *)buf = 136446466;
              uint64_t v38 = "nw_http3_notify_viability_changed";
              __int16 v39 = 2082;
              uint64_t v40 = v18;
              uint64_t v19 = *(NSObject **)v30;
              os_log_type_t v20 = v17;
              uint64_t v21 = "%{public}s protocol %{public}s has invalid notify callback";
              goto LABEL_36;
            }
            goto LABEL_37;
          }
          if (v34)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            os_log_t log = __nwlog_obj();
            os_log_type_t v31 = type;
            BOOL v23 = os_log_type_enabled(log, type);
            if (backtrace_string)
            {
              if (v23)
              {
                unsigned int v24 = *(const char **)(v2 + 16);
                if (!v24) {
                  unsigned int v24 = "invalid";
                }
                *(_DWORD *)buf = 136446722;
                uint64_t v38 = "nw_http3_notify_viability_changed";
                __int16 v39 = 2082;
                uint64_t v40 = v24;
                __int16 v41 = 2082;
                int v42 = backtrace_string;
                _os_log_impl(&dword_1830D4000, log, v31, "%{public}s protocol %{public}s has invalid notify callback, dumping backtrace:%{public}s", buf, 0x20u);
              }
              free(backtrace_string);
              goto LABEL_37;
            }
            if (!v23)
            {
LABEL_37:
              if (v33) {
                free(v33);
              }
              goto LABEL_6;
            }
            int v28 = *(const char **)(v2 + 16);
            if (!v28) {
              int v28 = "invalid";
            }
            *(_DWORD *)buf = 136446466;
            uint64_t v38 = "nw_http3_notify_viability_changed";
            __int16 v39 = 2082;
            uint64_t v40 = v28;
            uint64_t v19 = log;
            os_log_type_t v20 = v31;
            uint64_t v21 = "%{public}s protocol %{public}s has invalid notify callback, no backtrace";
          }
          else
          {
            char v25 = __nwlog_obj();
            os_log_type_t v26 = type;
            *(void *)BOOL v32 = v25;
            if (!os_log_type_enabled(v25, type)) {
              goto LABEL_37;
            }
            os_log_type_t v27 = *(const char **)(v2 + 16);
            if (!v27) {
              os_log_type_t v27 = "invalid";
            }
            *(_DWORD *)buf = 136446466;
            uint64_t v38 = "nw_http3_notify_viability_changed";
            __int16 v39 = 2082;
            uint64_t v40 = v27;
            uint64_t v19 = *(NSObject **)v32;
            os_log_type_t v20 = v26;
            uint64_t v21 = "%{public}s protocol %{public}s has invalid notify callback, backtrace limit exceeded";
          }
LABEL_36:
          _os_log_impl(&dword_1830D4000, v19, v20, v21, buf, 0x16u);
          goto LABEL_37;
        }
        v13(v2, v2, 18, &v36, 1);
      }
LABEL_6:
      uint64_t v2 = v8;
    }
    while (v8);
  }
}

double __nw_protocol_http3_identifier_block_invoke()
{
  strcpy((char *)&nw_protocol_http3_identifier::http3_protocol_identifier, "http3");
  *(void *)&double result = 0x200000004;
  qword_1E8F6B7D0 = 0x200000004;
  return result;
}

void ___ZL38nw_protocol_http3_stream_get_callbacksv_block_invoke()
{
  qword_1E8F6B5C0 = (uint64_t)nw_protocol_default_input_flush;
  qword_1E8F6B520 = (uint64_t)nw_protocol_default_link_state;
  qword_1E8F6B538 = (uint64_t)nw_protocol_default_get_local;
  qword_1E8F6B530 = (uint64_t)nw_protocol_default_get_path;
  qword_1E8F6B560 = (uint64_t)nw_protocol_default_updated_path;
  qword_1E8F6B580 = (uint64_t)nw_protocol_default_get_output_local;
  qword_1E8F6B588 = (uint64_t)nw_protocol_default_get_output_interface;
  qword_1E8F6B5B8 = (uint64_t)nw_protocol_default_reset;
  qword_1E8F6B590 = (uint64_t)nw_protocol_default_waiting_for_output;
  qword_1E8F6B4D0 = (uint64_t)nw_protocol_http3_stream_connect;
  qword_1E8F6B4E0 = (uint64_t)nw_protocol_http3_stream_connected;
  qword_1E8F6B4D8 = (uint64_t)nw_protocol_http3_stream_disconnect;
  qword_1E8F6B4E8 = (uint64_t)nw_protocol_http3_stream_disconnected;
  qword_1E8F6B4F0 = (uint64_t)nw_protocol_http3_stream_error;
  qword_1E8F6B578 = (uint64_t)nw_protocol_http3_stream_output_finished;
  qword_1E8F6B570 = (uint64_t)nw_protocol_http3_stream_input_finished;
  nw_protocol_http3_stream_get_callbacks(void)::protocol_callbacks = (uint64_t)nw_protocol_http3_stream_add_input_handler;
  qword_1E8F6B4C0 = (uint64_t)nw_protocol_http3_stream_remove_input_handler;
  qword_1E8F6B4C8 = (uint64_t)nw_protocol_http3_stream_replace_input_handler;
  qword_1E8F6B4F8 = (uint64_t)nw_protocol_http3_stream_input_available;
  qword_1E8F6B500 = (uint64_t)nw_protocol_http3_stream_output_available;
  qword_1E8F6B508 = (uint64_t)nw_protocol_http3_stream_get_input_frames;
  qword_1E8F6B510 = (uint64_t)nw_protocol_http3_stream_get_output_frames;
  qword_1E8F6B518 = (uint64_t)nw_protocol_http3_stream_finalize_output_frames;
  qword_1E8F6B568 = (uint64_t)nw_protocol_http3_stream_supports_external_data;
  qword_1E8F6B5A0 = (uint64_t)nw_protocol_http3_stream_add_listen_handler;
  qword_1E8F6B5A8 = (uint64_t)nw_protocol_http3_stream_remove_listen_handler;
  qword_1E8F6B540 = (uint64_t)nw_protocol_http3_stream_get_remote_endpoint;
  qword_1E8F6B598 = (uint64_t)nw_protocol_http3_stream_copy_info;
  qword_1E8F6B558 = (uint64_t)nw_protocol_http3_stream_notify;
  qword_1E8F6B528 = (uint64_t)nw_protocol_http3_stream_get_parameters;
  qword_1E8F6B5B0 = (uint64_t)nw_protocol_http3_stream_get_message_properties;
  qword_1E8F6B548 = (uint64_t)nw_protocol_http3_stream_register_notification;
  qword_1E8F6B550 = (uint64_t)nw_protocol_http3_stream_unregister_notification;
}

uint64_t nw_protocol_http3_stream_unregister_notification(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 40);
    if (v3)
    {
      if (a3 == 5)
      {
        uint64_t v4 = (_WORD *)(v3 + 736);
        if ((*(_WORD *)(v3 + 736) & 0x800) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v5 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          {
            int v6 = *(_DWORD *)(*(void *)(v3 + 336) + 1280);
            uint64_t v7 = *(void *)(v3 + 240);
            *(_DWORD *)buf = 136447234;
            int v22 = "nw_protocol_http3_stream_unregister_notification";
            __int16 v23 = 2082;
            unsigned int v24 = (char *)(v3 + 636);
            __int16 v25 = 2080;
            os_log_type_t v26 = " ";
            __int16 v27 = 1024;
            int v28 = v6;
            __int16 v29 = 2048;
            uint64_t v30 = v7;
            _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%llu> unregistered metadata_changed notification", buf, 0x30u);
          }
        }
        int v8 = (unsigned __int16)*v4;
        unsigned int v9 = (v8 | (*(unsigned __int8 *)(v3 + 738) << 16)) & 0xFFFDFFFF;
        *uint64_t v4 = v8;
        *(unsigned char *)(v3 + 738) = BYTE2(v9);
        return 1;
      }
      else
      {
        return nw_protocol_common_unregister_notification(a1, a2, a3);
      }
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v22 = "nw_protocol_http3_stream_unregister_notification";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (!__nwlog_fault(v11, &type, &v19)) {
      goto LABEL_39;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        int v22 = "nw_protocol_http3_stream_unregister_notification";
        os_log_type_t v14 = "%{public}s called with null http3_stream";
        goto LABEL_38;
      }
      goto LABEL_39;
    }
    if (!v19)
    {
      uint64_t v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        int v22 = "nw_protocol_http3_stream_unregister_notification";
        os_log_type_t v14 = "%{public}s called with null http3_stream, backtrace limit exceeded";
        goto LABEL_38;
      }
      goto LABEL_39;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v12 = __nwlog_obj();
    os_log_type_t v13 = type;
    BOOL v18 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        int v22 = "nw_protocol_http3_stream_unregister_notification";
        os_log_type_t v14 = "%{public}s called with null http3_stream, no backtrace";
        goto LABEL_38;
      }
      goto LABEL_39;
    }
    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      int v22 = "nw_protocol_http3_stream_unregister_notification";
      __int16 v23 = 2082;
      unsigned int v24 = backtrace_string;
      os_log_type_t v17 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
      goto LABEL_28;
    }
    goto LABEL_29;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v22 = "nw_protocol_http3_stream_unregister_notification";
  uint64_t v11 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (!__nwlog_fault(v11, &type, &v19)) {
    goto LABEL_39;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v19)
    {
      uint64_t v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        int v22 = "nw_protocol_http3_stream_unregister_notification";
        os_log_type_t v14 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_38;
      }
      goto LABEL_39;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v12 = __nwlog_obj();
    os_log_type_t v13 = type;
    BOOL v16 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        int v22 = "nw_protocol_http3_stream_unregister_notification";
        os_log_type_t v14 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_38;
      }
      goto LABEL_39;
    }
    if (v16)
    {
      *(_DWORD *)buf = 136446466;
      int v22 = "nw_protocol_http3_stream_unregister_notification";
      __int16 v23 = 2082;
      unsigned int v24 = backtrace_string;
      os_log_type_t v17 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_28:
      _os_log_impl(&dword_1830D4000, v12, v13, v17, buf, 0x16u);
    }
LABEL_29:
    free(backtrace_string);
    goto LABEL_39;
  }
  uint64_t v12 = __nwlog_obj();
  os_log_type_t v13 = type;
  if (os_log_type_enabled(v12, type))
  {
    *(_DWORD *)buf = 136446210;
    int v22 = "nw_protocol_http3_stream_unregister_notification";
    os_log_type_t v14 = "%{public}s called with null protocol";
LABEL_38:
    _os_log_impl(&dword_1830D4000, v12, v13, v14, buf, 0xCu);
  }
LABEL_39:
  if (v11) {
    free(v11);
  }
  return 0;
}

uint64_t nw_protocol_http3_stream_register_notification(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 40);
    if (v3)
    {
      if (a3 == 5)
      {
        if ((*(_WORD *)(v3 + 736) & 0x800) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v4 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          {
            int v5 = *(_DWORD *)(*(void *)(v3 + 336) + 1280);
            uint64_t v6 = *(void *)(v3 + 240);
            *(_DWORD *)buf = 136447234;
            char v19 = "nw_protocol_http3_stream_register_notification";
            __int16 v20 = 2082;
            uint64_t v21 = (char *)(v3 + 636);
            __int16 v22 = 2080;
            __int16 v23 = " ";
            __int16 v24 = 1024;
            int v25 = v5;
            __int16 v26 = 2048;
            uint64_t v27 = v6;
            _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%llu> registered metadata_changed notification", buf, 0x30u);
          }
        }
        *(unsigned char *)(v3 + 738) |= 2u;
        return 1;
      }
      else
      {
        return nw_protocol_common_register_notification(a1, a2, a3);
      }
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v19 = "nw_protocol_http3_stream_register_notification";
    int v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (!__nwlog_fault(v8, &type, &v16)) {
      goto LABEL_39;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        char v19 = "nw_protocol_http3_stream_register_notification";
        uint64_t v11 = "%{public}s called with null http3_stream";
        goto LABEL_38;
      }
      goto LABEL_39;
    }
    if (!v16)
    {
      unsigned int v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        char v19 = "nw_protocol_http3_stream_register_notification";
        uint64_t v11 = "%{public}s called with null http3_stream, backtrace limit exceeded";
        goto LABEL_38;
      }
      goto LABEL_39;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    unsigned int v9 = __nwlog_obj();
    os_log_type_t v10 = type;
    BOOL v15 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        char v19 = "nw_protocol_http3_stream_register_notification";
        uint64_t v11 = "%{public}s called with null http3_stream, no backtrace";
        goto LABEL_38;
      }
      goto LABEL_39;
    }
    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      char v19 = "nw_protocol_http3_stream_register_notification";
      __int16 v20 = 2082;
      uint64_t v21 = backtrace_string;
      os_log_type_t v14 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
      goto LABEL_28;
    }
    goto LABEL_29;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v19 = "nw_protocol_http3_stream_register_notification";
  int v8 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (!__nwlog_fault(v8, &type, &v16)) {
    goto LABEL_39;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v16)
    {
      unsigned int v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        char v19 = "nw_protocol_http3_stream_register_notification";
        uint64_t v11 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_38;
      }
      goto LABEL_39;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    unsigned int v9 = __nwlog_obj();
    os_log_type_t v10 = type;
    BOOL v13 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        char v19 = "nw_protocol_http3_stream_register_notification";
        uint64_t v11 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_38;
      }
      goto LABEL_39;
    }
    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      char v19 = "nw_protocol_http3_stream_register_notification";
      __int16 v20 = 2082;
      uint64_t v21 = backtrace_string;
      os_log_type_t v14 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_28:
      _os_log_impl(&dword_1830D4000, v9, v10, v14, buf, 0x16u);
    }
LABEL_29:
    free(backtrace_string);
    goto LABEL_39;
  }
  unsigned int v9 = __nwlog_obj();
  os_log_type_t v10 = type;
  if (os_log_type_enabled(v9, type))
  {
    *(_DWORD *)buf = 136446210;
    char v19 = "nw_protocol_http3_stream_register_notification";
    uint64_t v11 = "%{public}s called with null protocol";
LABEL_38:
    _os_log_impl(&dword_1830D4000, v9, v10, v11, buf, 0xCu);
  }
LABEL_39:
  if (v8) {
    free(v8);
  }
  return 0;
}

void nw_protocol_http3_stream_get_message_properties(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v21 = "nw_protocol_http3_stream_get_message_properties";
    int v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (!__nwlog_fault(v8, &type, &v18)) {
      goto LABEL_44;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_44;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v21 = "nw_protocol_http3_stream_get_message_properties";
      uint64_t v11 = "%{public}s called with null protocol";
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unsigned int v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v21 = "nw_protocol_http3_stream_get_message_properties";
          __int16 v22 = 2082;
          __int16 v23 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_44:
        if (!v8) {
          return;
        }
LABEL_45:
        free(v8);
        return;
      }
      if (!v15) {
        goto LABEL_44;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v21 = "nw_protocol_http3_stream_get_message_properties";
      uint64_t v11 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      unsigned int v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_44;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v21 = "nw_protocol_http3_stream_get_message_properties";
      uint64_t v11 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_43:
    _os_log_impl(&dword_1830D4000, v9, v10, v11, buf, 0xCu);
    goto LABEL_44;
  }
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3)
  {
    if (a3)
    {
      if ((*(_WORD *)(v3 + 736) & 0x10) != 0)
      {
        uint64_t v5 = *(void *)(v3 + 96);
        if (v5 && (uint64_t v6 = *(void *)(v5 + 24)) != 0 && (v7 = *(void (**)(void))(v6 + 248)) != 0)
        {
          v7();
        }
        else
        {
          unsigned int v12 = a3[1] & 0xFFFFFFFA;
          a3[1] = v12 | 1;
          int v13 = *(_DWORD *)(v3 + 628);
          if (!v13) {
            int v13 = -1;
          }
          *a3 = v13;
          a3[1] = v12 | 3;
        }
      }
      else
      {
        unsigned int v4 = a3[1] & 0xFFFFFFF8;
        *a3 = -1;
        a3[1] = v4;
      }
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v21 = "nw_protocol_http3_stream_get_message_properties";
  int v8 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (!__nwlog_fault(v8, &type, &v18)) {
    goto LABEL_44;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    unsigned int v9 = __nwlog_obj();
    os_log_type_t v10 = type;
    if (!os_log_type_enabled(v9, type)) {
      goto LABEL_44;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v21 = "nw_protocol_http3_stream_get_message_properties";
    uint64_t v11 = "%{public}s called with null http3_stream";
    goto LABEL_43;
  }
  if (!v18)
  {
    unsigned int v9 = __nwlog_obj();
    os_log_type_t v10 = type;
    if (!os_log_type_enabled(v9, type)) {
      goto LABEL_44;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v21 = "nw_protocol_http3_stream_get_message_properties";
    uint64_t v11 = "%{public}s called with null http3_stream, backtrace limit exceeded";
    goto LABEL_43;
  }
  char v16 = (char *)__nw_create_backtrace_string();
  unsigned int v9 = __nwlog_obj();
  os_log_type_t v10 = type;
  BOOL v17 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (!v17) {
      goto LABEL_44;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v21 = "nw_protocol_http3_stream_get_message_properties";
    uint64_t v11 = "%{public}s called with null http3_stream, no backtrace";
    goto LABEL_43;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v21 = "nw_protocol_http3_stream_get_message_properties";
    __int16 v22 = 2082;
    __int16 v23 = v16;
    _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null http3_stream, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v16);
  if (v8) {
    goto LABEL_45;
  }
}

uint64_t nw_protocol_http3_stream_get_parameters(nw_protocol *a1)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v35 = "nw_protocol_http3_stream_get_parameters";
    char v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (!__nwlog_fault(v19, &type, &v32)) {
      goto LABEL_74;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_74;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v35 = "nw_protocol_http3_stream_get_parameters";
      __int16 v22 = "%{public}s called with null protocol";
LABEL_73:
      _os_log_impl(&dword_1830D4000, v20, v21, v22, buf, 0xCu);
      goto LABEL_74;
    }
    if (!v32)
    {
      __int16 v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_74;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v35 = "nw_protocol_http3_stream_get_parameters";
      __int16 v22 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_73;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v20 = __nwlog_obj();
    os_log_type_t v21 = type;
    BOOL v24 = os_log_type_enabled(v20, type);
    if (!backtrace_string)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v35 = "nw_protocol_http3_stream_get_parameters";
        __int16 v22 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_73;
      }
      goto LABEL_74;
    }
    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v35 = "nw_protocol_http3_stream_get_parameters";
      __int16 v36 = 2082;
      __int16 v37 = backtrace_string;
      int v25 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_57:
      _os_log_impl(&dword_1830D4000, v20, v21, v25, buf, 0x16u);
    }
LABEL_58:
    free(backtrace_string);
    goto LABEL_74;
  }
  uint64_t handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v35 = "nw_protocol_http3_stream_get_parameters";
    char v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (!__nwlog_fault(v19, &type, &v32)) {
      goto LABEL_74;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_74;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v35 = "nw_protocol_http3_stream_get_parameters";
      __int16 v22 = "%{public}s called with null http3_stream";
      goto LABEL_73;
    }
    if (!v32)
    {
      __int16 v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_74;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v35 = "nw_protocol_http3_stream_get_parameters";
      __int16 v22 = "%{public}s called with null http3_stream, backtrace limit exceeded";
      goto LABEL_73;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v20 = __nwlog_obj();
    os_log_type_t v21 = type;
    BOOL v26 = os_log_type_enabled(v20, type);
    if (!backtrace_string)
    {
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v35 = "nw_protocol_http3_stream_get_parameters";
        __int16 v22 = "%{public}s called with null http3_stream, no backtrace";
        goto LABEL_73;
      }
      goto LABEL_74;
    }
    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v35 = "nw_protocol_http3_stream_get_parameters";
      __int16 v36 = 2082;
      __int16 v37 = backtrace_string;
      int v25 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
      goto LABEL_57;
    }
    goto LABEL_58;
  }
  if (handle + 64 != (char *)a1)
  {
    if ((*((_WORD *)handle + 368) & 0x1000) == 0)
    {
      if (*((void *)handle + 4))
      {
        nw_http3_fix_quic_parameters(*((void *)handle + 42), *((NSObject **)handle + 44), 0, 0);
        *((_WORD *)handle + 368) |= 0x1000u;
      }
    }
    return *((void *)handle + 44);
  }
  if (*((void *)handle + 45)) {
    goto LABEL_9;
  }
  uint64_t v3 = (void *)*((void *)handle + 44);
  if (v3)
  {
    id v4 = v3;
    BOOL v5 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]((id *)[NWConcrete_nw_parameters alloc], v4, 0, 1);

    *((void *)handle + 45) = v5;
    uint64_t v6 = *((void *)handle + 4);
    if (v6)
    {
      uint64_t v7 = nw_parameters_copy_protocol_options_legacy((void *)v5, *((nw_protocol **)handle + 4));
      if (v7)
      {
        int v8 = v7;
        if (nw_protocol_options_is_quic_stream(v7))
        {
          unsigned int v9 = nw_protocol_options_copy(v8);
          nw_quic_stream_set_is_unidirectional(v9, 0);
          nw_quic_stream_set_is_datagram(v9, 1);
          nw_quic_stream_set_associated_stream_id(v9, *((void *)handle + 30));
          nw_quic_stream_set_datagram_context_id(v9, *((void *)handle + 32));
          nw_protocol_http3_add_alpn_to_quic_options((nw_protocol_options *)v9);
          if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
            dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_15_56153);
          }
          id v10 = (id)nw_protocol_copy_quic_stream_definition::quic_definition;
          nw_parameters_set_protocol_instance(v9, v11, v6);
          if (v10) {
            os_release(v10);
          }
          nw_protocol_options_inherit_log_id(v8, v9);
          nw_protocol_options_set_prohibit_joining(v9);
          nw_protocol_stack_t v12 = nw_parameters_copy_default_protocol_stack(*((nw_parameters_t *)handle + 45));
          nw_protocol_stack_replace_protocol_with_handle(v12, v6, v9);
          if (v12) {
            os_release(v12);
          }
          if (v9) {
            os_release(v9);
          }
        }
        os_release(v8);
      }
LABEL_9:
      if ((*((_WORD *)handle + 368) & 0x800) == 0)
      {
        if (gLogDatapath)
        {
          uint64_t v27 = __nwlog_obj();
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
          {
            int v28 = *(_DWORD *)(*((void *)handle + 42) + 1280);
            uint64_t v29 = *((void *)handle + 30);
            uint64_t v30 = *((void *)handle + 45);
            *(_DWORD *)buf = 136447490;
            __int16 v35 = "nw_http3_stream_get_datagram_parameters";
            __int16 v36 = 2082;
            __int16 v37 = handle + 636;
            __int16 v38 = 2080;
            __int16 v39 = " ";
            __int16 v40 = 1024;
            int v41 = v28;
            __int16 v42 = 2048;
            uint64_t v43 = v29;
            __int16 v44 = 2048;
            uint64_t v45 = v30;
            _os_log_impl(&dword_1830D4000, v27, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> returning datagram parameters %p", buf, 0x3Au);
          }
        }
      }
      return *((void *)handle + 45);
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446466;
    __int16 v35 = "nw_http3_stream_get_datagram_parameters";
    __int16 v36 = 2048;
    __int16 v37 = handle;
    int v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (__nwlog_fault(v13, &type, &v32))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v14 = gLogObj;
        os_log_type_t v15 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_39;
        }
        *(_DWORD *)buf = 136446466;
        __int16 v35 = "nw_http3_stream_get_datagram_parameters";
        __int16 v36 = 2048;
        __int16 v37 = handle;
        char v16 = "%{public}s no output handler on http3 stream %p yet, cannot create datagram parameters";
        goto LABEL_38;
      }
      if (!v32)
      {
        os_log_type_t v14 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (!os_log_type_enabled(v14, type)) {
          goto LABEL_39;
        }
        *(_DWORD *)buf = 136446466;
        __int16 v35 = "nw_http3_stream_get_datagram_parameters";
        __int16 v36 = 2048;
        __int16 v37 = handle;
        char v16 = "%{public}s no output handler on http3 stream %p yet, cannot create datagram parameters, backtrace limit exceeded";
        goto LABEL_38;
      }
      BOOL v17 = (char *)__nw_create_backtrace_string();
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v18 = os_log_type_enabled(v14, type);
      if (v17)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446722;
          __int16 v35 = "nw_http3_stream_get_datagram_parameters";
          __int16 v36 = 2048;
          __int16 v37 = handle;
          __int16 v38 = 2082;
          __int16 v39 = v17;
          _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s no output handler on http3 stream %p yet, cannot create datagram parameters, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v17);
        goto LABEL_39;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v35 = "nw_http3_stream_get_datagram_parameters";
        __int16 v36 = 2048;
        __int16 v37 = handle;
        char v16 = "%{public}s no output handler on http3 stream %p yet, cannot create datagram parameters, no backtrace";
LABEL_38:
        _os_log_impl(&dword_1830D4000, v14, v15, v16, buf, 0x16u);
      }
    }
LABEL_39:
    if (v13) {
      free(v13);
    }
    goto LABEL_9;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v35 = "nw_http3_stream_get_datagram_parameters";
  char v19 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v32 = 0;
  if (!__nwlog_fault(v19, &type, &v32)) {
    goto LABEL_74;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v32)
    {
      __int16 v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_74;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v35 = "nw_http3_stream_get_datagram_parameters";
      __int16 v22 = "%{public}s called with null http3_stream->parameters, backtrace limit exceeded";
      goto LABEL_73;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v20 = __nwlog_obj();
    os_log_type_t v21 = type;
    BOOL v31 = os_log_type_enabled(v20, type);
    if (!backtrace_string)
    {
      if (!v31) {
        goto LABEL_74;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v35 = "nw_http3_stream_get_datagram_parameters";
      __int16 v22 = "%{public}s called with null http3_stream->parameters, no backtrace";
      goto LABEL_73;
    }
    if (!v31) {
      goto LABEL_58;
    }
    *(_DWORD *)buf = 136446466;
    __int16 v35 = "nw_http3_stream_get_datagram_parameters";
    __int16 v36 = 2082;
    __int16 v37 = backtrace_string;
    int v25 = "%{public}s called with null http3_stream->parameters, dumping backtrace:%{public}s";
    goto LABEL_57;
  }
  __int16 v20 = __nwlog_obj();
  os_log_type_t v21 = type;
  if (os_log_type_enabled(v20, type))
  {
    *(_DWORD *)buf = 136446210;
    __int16 v35 = "nw_http3_stream_get_datagram_parameters";
    __int16 v22 = "%{public}s called with null http3_stream->parameters";
    goto LABEL_73;
  }
LABEL_74:
  if (v19) {
    free(v19);
  }
  return 0;
}

void sub_183B575D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_http3_add_alpn_to_quic_options(nw_protocol_options *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v1 = nw_quic_stream_copy_shared_connection_options(a1);
  id v2 = nw_quic_connection_copy_sec_protocol_options(v1);
  uint64_t v3 = (void *)sec_protocol_options_copy_transport_specific_application_protocol();
  id v4 = v3;
  if (v3 && xpc_array_get_count(v3))
  {
LABEL_19:
    xpc_release(v4);
    goto LABEL_20;
  }
  sec_protocol_options_add_transport_specific_application_protocol();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  BOOL v18 = "nw_protocol_http3_add_alpn_to_quic_options";
  BOOL v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v5, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = gLogObj;
      os_log_type_t v7 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_16;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v18 = "nw_protocol_http3_add_alpn_to_quic_options";
      int v8 = "%{public}s Missing \"h3\" alpn from quic options. Protocol http3 will stop adding it for you in the future si"
           "nce it prevents joining from working properly.";
LABEL_14:
      int v13 = v6;
      os_log_type_t v14 = v7;
LABEL_15:
      _os_log_impl(&dword_1830D4000, v13, v14, v8, buf, 0xCu);
      goto LABEL_16;
    }
    if (!v15)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = gLogObj;
      os_log_type_t v7 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_16;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v18 = "nw_protocol_http3_add_alpn_to_quic_options";
      int v8 = "%{public}s Missing \"h3\" alpn from quic options. Protocol http3 will stop adding it for you in the future si"
           "nce it prevents joining from working properly., backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v10 = gLogObj;
    os_log_type_t v11 = type;
    BOOL v12 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v18 = "nw_protocol_http3_add_alpn_to_quic_options";
        __int16 v19 = 2082;
        __int16 v20 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s Missing \"h3\" alpn from quic options. Protocol http3 will stop adding it for you in the future since it prevents joining from working properly., dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
    }
    else if (v12)
    {
      *(_DWORD *)buf = 136446210;
      BOOL v18 = "nw_protocol_http3_add_alpn_to_quic_options";
      int v8 = "%{public}s Missing \"h3\" alpn from quic options. Protocol http3 will stop adding it for you in the future si"
           "nce it prevents joining from working properly., no backtrace";
      int v13 = v10;
      os_log_type_t v14 = v11;
      goto LABEL_15;
    }
  }
LABEL_16:
  if (v5) {
    free(v5);
  }
  if (v4) {
    goto LABEL_19;
  }
LABEL_20:
  if (v1) {
    os_release(v1);
  }
  if (v2) {
    os_release(v2);
  }
}

NSObject *nw_http3_fix_quic_parameters(uint64_t a1, NSObject *a2, char a3, int a4)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v48 = "nw_http3_fix_quic_parameters";
    __int16 v35 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (!__nwlog_fault(v35, &type, &v45)) {
      goto LABEL_83;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v45)
      {
        __int16 v36 = __nwlog_obj();
        os_log_type_t v37 = type;
        if (!os_log_type_enabled(v36, type)) {
          goto LABEL_83;
        }
        *(_DWORD *)buf = 136446210;
        id v48 = "nw_http3_fix_quic_parameters";
        __int16 v38 = "%{public}s called with null http3, backtrace limit exceeded";
        goto LABEL_82;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v36 = __nwlog_obj();
      os_log_type_t v37 = type;
      BOOL v40 = os_log_type_enabled(v36, type);
      if (!backtrace_string)
      {
        if (!v40) {
          goto LABEL_83;
        }
        *(_DWORD *)buf = 136446210;
        id v48 = "nw_http3_fix_quic_parameters";
        __int16 v38 = "%{public}s called with null http3, no backtrace";
        goto LABEL_82;
      }
      if (v40)
      {
        *(_DWORD *)buf = 136446466;
        id v48 = "nw_http3_fix_quic_parameters";
        __int16 v49 = 2082;
        nw_protocol_stack_t v50 = backtrace_string;
        int v41 = "%{public}s called with null http3, dumping backtrace:%{public}s";
LABEL_72:
        _os_log_impl(&dword_1830D4000, v36, v37, v41, buf, 0x16u);
      }
LABEL_73:
      free(backtrace_string);
      goto LABEL_83;
    }
    __int16 v36 = __nwlog_obj();
    os_log_type_t v37 = type;
    if (!os_log_type_enabled(v36, type)) {
      goto LABEL_83;
    }
    *(_DWORD *)buf = 136446210;
    id v48 = "nw_http3_fix_quic_parameters";
    __int16 v38 = "%{public}s called with null http3";
LABEL_82:
    _os_log_impl(&dword_1830D4000, v36, v37, v38, buf, 0xCu);
LABEL_83:
    if (v35) {
      free(v35);
    }
    return 0;
  }
  id v4 = a2;
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v48 = "nw_http3_fix_quic_parameters";
    __int16 v35 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (!__nwlog_fault(v35, &type, &v45)) {
      goto LABEL_83;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v36 = __nwlog_obj();
      os_log_type_t v37 = type;
      if (!os_log_type_enabled(v36, type)) {
        goto LABEL_83;
      }
      *(_DWORD *)buf = 136446210;
      id v48 = "nw_http3_fix_quic_parameters";
      __int16 v38 = "%{public}s called with null parameters";
      goto LABEL_82;
    }
    if (!v45)
    {
      __int16 v36 = __nwlog_obj();
      os_log_type_t v37 = type;
      if (!os_log_type_enabled(v36, type)) {
        goto LABEL_83;
      }
      *(_DWORD *)buf = 136446210;
      id v48 = "nw_http3_fix_quic_parameters";
      __int16 v38 = "%{public}s called with null parameters, backtrace limit exceeded";
      goto LABEL_82;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v36 = __nwlog_obj();
    os_log_type_t v37 = type;
    BOOL v42 = os_log_type_enabled(v36, type);
    if (backtrace_string)
    {
      if (v42)
      {
        *(_DWORD *)buf = 136446466;
        id v48 = "nw_http3_fix_quic_parameters";
        __int16 v49 = 2082;
        nw_protocol_stack_t v50 = backtrace_string;
        int v41 = "%{public}s called with null parameters, dumping backtrace:%{public}s";
        goto LABEL_72;
      }
      goto LABEL_73;
    }
    if (!v42) {
      goto LABEL_83;
    }
    *(_DWORD *)buf = 136446210;
    id v48 = "nw_http3_fix_quic_parameters";
    __int16 v38 = "%{public}s called with null parameters, no backtrace";
    goto LABEL_82;
  }
  if (a4)
  {
    int v8 = a2;
    id v4 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]((id *)[NWConcrete_nw_parameters alloc], v8, 0, 1);
  }
  uint64_t v9 = *(void *)(a1 + 32);
  if (!v9)
  {
    if (((*(unsigned __int16 *)(a1 + 1373) | (*(unsigned __int8 *)(a1 + 1375) << 16)) & 0x400000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v27 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
      {
        int v28 = *(_DWORD *)(a1 + 1280);
        *(_DWORD *)buf = 136446978;
        id v48 = "nw_http3_fix_quic_parameters";
        __int16 v49 = 2082;
        nw_protocol_stack_t v50 = (char *)(a1 + 1289);
        __int16 v51 = 2080;
        int v52 = " ";
        __int16 v53 = 1024;
        int v54 = v28;
        _os_log_impl(&dword_1830D4000, v27, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s%s<i%u> http3 does not yet have output handler, cannot fix parameters", buf, 0x26u);
        return 0;
      }
    }
    return 0;
  }
  id v10 = nw_parameters_copy_protocol_options_legacy(v4, *(nw_protocol **)(a1 + 32));
  os_log_type_t v11 = v10;
  if (v10 && nw_protocol_options_is_quic_stream(v10))
  {
    BOOL v12 = nw_protocol_options_copy(v11);
    nw_quic_stream_set_is_unidirectional(v12, a3);
    nw_protocol_http3_add_alpn_to_quic_options((nw_protocol_options *)v12);
    id v13 = nw_quic_stream_copy_shared_connection_options(v12);
    os_log_type_t v14 = nw_quic_connection_copy_sec_protocol_options(v13);
    if (*(unsigned char *)(a1 + 1288))
    {
      sec_protocol_options_set_new_session_ticket_request();
      sec_protocol_options_set_resumed_session_ticket_request();
    }
    if ((*(_WORD *)(a1 + 1373) & 0x20) != 0 && uuid_is_null((const unsigned __int8 *)(a1 + 848))
      || *(void *)(a1 + 864) && *(void *)(a1 + 872))
    {
      char v15 = nw_context_copy_workloop(*(void **)(a1 + 1256));
      uint64_t v16 = *(void *)(a1 + 1040);
      v44[0] = MEMORY[0x1E4F143A8];
      v44[1] = 0x40000000;
      v44[2] = ___ZL28nw_http3_fix_quic_parametersP17nw_protocol_http3P13nw_parametersbb_block_invoke;
      v44[3] = &unk_1E5247680;
      v44[4] = v16;
      nw_quic_connection_set_session_state_update_block(v13, v44, v15);
      if (v15) {
        dispatch_release(v15);
      }
    }
    if ((*(_WORD *)(a1 + 1373) & 0x20) != 0 && a4)
    {
      BOOL v17 = *(void **)(a1 + 1136);
      if (v17)
      {
        BOOL v18 = *(void **)(a1 + 1144);
        if (v18) {
          nw_quic_connection_set_session_state(v13, v17, v18);
        }
      }
      sec_protocol_options_set_tls_early_data_enabled();
      sec_protocol_options_set_tls_tickets_enabled(v14, 1);
    }
    if (v14) {
      os_release(v14);
    }
    if (v13) {
      os_release(v13);
    }
    if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
      dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_15_56153);
    }
    id v19 = (id)nw_protocol_copy_quic_stream_definition::quic_definition;
    nw_parameters_set_protocol_instance(v12, v20, v9);
    if (v19) {
      os_release(v19);
    }
    nw_protocol_options_inherit_log_id(v11, v12);
    uint64_t v21 = v11;
    v21[153] = 1;

    nw_protocol_stack_t v22 = nw_parameters_copy_default_protocol_stack(v4);
    nw_protocol_stack_replace_protocol_with_handle(v22, v9, v12);
    if (v22) {
      os_release(v22);
    }
    if (v12) {
      os_release(v12);
    }
LABEL_53:
    os_release(v11);
    return v4;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  id v48 = "nw_http3_fix_quic_parameters";
  __int16 v23 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v45 = 0;
  if (!__nwlog_fault(v23, &type, &v45)) {
    goto LABEL_50;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v24 = gLogObj;
    os_log_type_t v25 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
      goto LABEL_50;
    }
    *(_DWORD *)buf = 136446210;
    id v48 = "nw_http3_fix_quic_parameters";
    BOOL v26 = "%{public}s No quic below http3";
LABEL_48:
    char v33 = v24;
    os_log_type_t v34 = v25;
LABEL_49:
    _os_log_impl(&dword_1830D4000, v33, v34, v26, buf, 0xCu);
    goto LABEL_50;
  }
  if (!v45)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v24 = gLogObj;
    os_log_type_t v25 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
      goto LABEL_50;
    }
    *(_DWORD *)buf = 136446210;
    id v48 = "nw_http3_fix_quic_parameters";
    BOOL v26 = "%{public}s No quic below http3, backtrace limit exceeded";
    goto LABEL_48;
  }
  uint64_t v29 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v30 = gLogObj;
  os_log_type_t v31 = type;
  BOOL v32 = os_log_type_enabled((os_log_t)gLogObj, type);
  if (v29)
  {
    if (v32)
    {
      *(_DWORD *)buf = 136446466;
      id v48 = "nw_http3_fix_quic_parameters";
      __int16 v49 = 2082;
      nw_protocol_stack_t v50 = v29;
      _os_log_impl(&dword_1830D4000, v30, v31, "%{public}s No quic below http3, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v29);
  }
  else if (v32)
  {
    *(_DWORD *)buf = 136446210;
    id v48 = "nw_http3_fix_quic_parameters";
    BOOL v26 = "%{public}s No quic below http3, no backtrace";
    char v33 = v30;
    os_log_type_t v34 = v31;
    goto LABEL_49;
  }
LABEL_50:
  if (v23) {
    free(v23);
  }
  if (v11) {
    goto LABEL_53;
  }
  return v4;
}

void sub_183B58200(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL28nw_http3_fix_quic_parametersP17nw_protocol_http3P13nw_parametersbb_block_invoke(uint64_t a1, NSObject *a2, NSObject *a3)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  if (v5)
  {
    uint64_t v6 = v5;
    if (((*(unsigned __int16 *)(v5 + 1373) | (*(unsigned __int8 *)(v5 + 1375) << 16)) & 0x400000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v7 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        int v8 = *(_DWORD *)(v6 + 1280);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_http3_fix_quic_parameters_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v6 + 1289;
        *(_WORD *)&unsigned char buf[22] = 2080;
        os_log_type_t v25 = (void (*)(uint64_t, uint64_t))" ";
        LOWORD(v26) = 1024;
        *(_DWORD *)((char *)&v26 + 2) = v8;
        _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> received new TLS session ticket", buf, 0x26u);
      }
    }
    uint64_t v9 = *(NSObject **)(v6 + 1160);
    if (v9)
    {
      dispatch_release(v9);
      *(void *)(v6 + 1160) = 0;
    }
    id v10 = *(NSObject **)(v6 + 1168);
    if (v10)
    {
      dispatch_release(v10);
      *(void *)(v6 + 1168) = 0;
    }
    dispatch_retain(a2);
    dispatch_retain(a3);
    *(void *)(v6 + 1160) = a2;
    *(void *)(v6 + 1168) = a3;
    if (*(void *)(v6 + 864) && *(void *)(v6 + 872))
    {
      os_log_type_t v11 = &v23;
      BOOL v12 = *(NSObject **)(v6 + 1176);
      if (!v12) {
        BOOL v12 = *(NSObject **)(v6 + 1152);
      }
      dispatch_data_t v13 = 0;
      uint64_t v20 = 0;
      uint64_t v21 = &v20;
      uint64_t v22 = 0x2000000000;
      dispatch_data_t v23 = 0;
      if (a3 && a2 && v12)
      {
        *(void *)buf = 0;
        uint64_t alloc = dispatch_data_create_alloc();
        char v15 = *(_DWORD **)buf;
        **(_DWORD **)buf = 9685181;
        v15[1] = dispatch_data_get_size(v12);
        v15[2] = dispatch_data_get_size(a2);
        v15[3] = dispatch_data_get_size(a3);
        concat = dispatch_data_create_concat(alloc, v12);
        if (alloc) {
          dispatch_release(alloc);
        }
        BOOL v17 = dispatch_data_create_concat(concat, a2);
        if (concat) {
          dispatch_release(concat);
        }
        dispatch_data_t v13 = dispatch_data_create_concat(v17, a3);
        if (v17) {
          dispatch_release(v17);
        }
        os_log_type_t v11 = (dispatch_data_t *)(v21 + 3);
      }
      dispatch_data_t v23 = v13;
      if (*v11)
      {
        *(void *)buf = 0;
        *(void *)&buf[8] = buf;
        *(void *)&buf[16] = 0x3002000000;
        os_log_type_t v25 = __Block_byref_object_copy__119;
        BOOL v26 = __Block_byref_object_dispose__120;
        uint64_t v27 = 0;
        uint64_t v27 = _Block_copy(*(const void **)(v6 + 864));
        BOOL v18 = *(NSObject **)(v6 + 872);
        v19[0] = MEMORY[0x1E4F143A8];
        v19[1] = 0x40000000;
        v19[2] = ___ZL28nw_http3_fix_quic_parametersP17nw_protocol_http3P13nw_parametersbb_block_invoke_121;
        v19[3] = &unk_1E5247658;
        v19[4] = buf;
        v19[5] = &v20;
        dispatch_async(v18, v19);
        _Block_object_dispose(buf, 8);
      }
      _Block_object_dispose(&v20, 8);
    }
    else
    {
      nw_http3_try_persist_0rtt_state(v6);
    }
  }
}

void __Block_byref_object_copy__119(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__120(uint64_t a1)
{
}

void ___ZL28nw_http3_fix_quic_parametersP17nw_protocol_http3P13nw_parametersbb_block_invoke_121(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) + 16))();
  id v2 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  if (v2)
  {
    _Block_release(v2);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = 0;
  }
  uint64_t v3 = *(NSObject **)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  if (v3)
  {
    dispatch_release(v3);
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
  }
}

void nw_protocol_http3_stream_notify(uint64_t a1, uint64_t a2, int a3, unsigned __int8 *a4, uint64_t a5)
{
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v65 = "nw_protocol_http3_stream_notify";
    BOOL v18 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v62 = 0;
    if (!__nwlog_fault(v18, &type, &v62)) {
      goto LABEL_127;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_127;
      }
      *(_DWORD *)buf = 136446210;
      char v65 = "nw_protocol_http3_stream_notify";
      uint64_t v21 = "%{public}s called with null protocol";
    }
    else if (v62)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      BOOL v34 = os_log_type_enabled(v19, type);
      if (backtrace_string)
      {
        if (v34)
        {
          *(_DWORD *)buf = 136446466;
          char v65 = "nw_protocol_http3_stream_notify";
          __int16 v66 = 2082;
          unsigned int v67 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_127:
        if (!v18) {
          return;
        }
LABEL_128:
        int v60 = (char *)v18;
        goto LABEL_129;
      }
      if (!v34) {
        goto LABEL_127;
      }
      *(_DWORD *)buf = 136446210;
      char v65 = "nw_protocol_http3_stream_notify";
      uint64_t v21 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      id v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_127;
      }
      *(_DWORD *)buf = 136446210;
      char v65 = "nw_protocol_http3_stream_notify";
      uint64_t v21 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_111;
  }
  uint64_t v6 = *(void *)(a1 + 40);
  if (!v6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v65 = "nw_protocol_http3_stream_notify";
    BOOL v18 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v62 = 0;
    if (!__nwlog_fault(v18, &type, &v62)) {
      goto LABEL_127;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v62)
      {
        id v19 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (!os_log_type_enabled(v19, type)) {
          goto LABEL_127;
        }
        *(_DWORD *)buf = 136446210;
        char v65 = "nw_protocol_http3_stream_notify";
        uint64_t v21 = "%{public}s called with null http3_stream, backtrace limit exceeded";
        goto LABEL_111;
      }
      __int16 v35 = (char *)__nw_create_backtrace_string();
      id v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      BOOL v36 = os_log_type_enabled(v19, type);
      if (!v35)
      {
        if (!v36) {
          goto LABEL_127;
        }
        *(_DWORD *)buf = 136446210;
        char v65 = "nw_protocol_http3_stream_notify";
        uint64_t v21 = "%{public}s called with null http3_stream, no backtrace";
        goto LABEL_111;
      }
      if (v36)
      {
        *(_DWORD *)buf = 136446466;
        char v65 = "nw_protocol_http3_stream_notify";
        __int16 v66 = 2082;
        unsigned int v67 = v35;
        os_log_type_t v37 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
LABEL_61:
        _os_log_impl(&dword_1830D4000, v19, v20, v37, buf, 0x16u);
      }
LABEL_62:
      free(v35);
      if (!v18) {
        return;
      }
      goto LABEL_128;
    }
    id v19 = __nwlog_obj();
    os_log_type_t v20 = type;
    if (!os_log_type_enabled(v19, type)) {
      goto LABEL_127;
    }
    *(_DWORD *)buf = 136446210;
    char v65 = "nw_protocol_http3_stream_notify";
    uint64_t v21 = "%{public}s called with null http3_stream";
LABEL_111:
    int v54 = v19;
    os_log_type_t v55 = v20;
    uint32_t v56 = 12;
LABEL_126:
    _os_log_impl(&dword_1830D4000, v54, v55, v21, buf, v56);
    goto LABEL_127;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v65 = "nw_protocol_http3_stream_notify";
    BOOL v18 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v62 = 0;
    if (!__nwlog_fault(v18, &type, &v62)) {
      goto LABEL_127;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_127;
      }
      *(_DWORD *)buf = 136446210;
      char v65 = "nw_protocol_http3_stream_notify";
      uint64_t v21 = "%{public}s called with null other_protocol";
      goto LABEL_111;
    }
    if (!v62)
    {
      id v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_127;
      }
      *(_DWORD *)buf = 136446210;
      char v65 = "nw_protocol_http3_stream_notify";
      uint64_t v21 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_111;
    }
    __int16 v35 = (char *)__nw_create_backtrace_string();
    id v19 = __nwlog_obj();
    os_log_type_t v20 = type;
    BOOL v38 = os_log_type_enabled(v19, type);
    if (!v35)
    {
      if (!v38) {
        goto LABEL_127;
      }
      *(_DWORD *)buf = 136446210;
      char v65 = "nw_protocol_http3_stream_notify";
      uint64_t v21 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_111;
    }
    if (v38)
    {
      *(_DWORD *)buf = 136446466;
      char v65 = "nw_protocol_http3_stream_notify";
      __int16 v66 = 2082;
      unsigned int v67 = v35;
      os_log_type_t v37 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_61;
    }
    goto LABEL_62;
  }
  switch(a3)
  {
    case 7:
    case 15:
    case 21:
      return;
    case 13:
      goto LABEL_8;
    case 16:
      if (a4 && a5 == 1)
      {
        int v7 = *(_WORD *)(v6 + 736) & 0xDFFF | (*(unsigned __int8 *)(v6 + 738) << 16) | (*a4 << 13);
        *(_WORD *)(v6 + 736) = *(_WORD *)(v6 + 736) & 0xDFFF | (*a4 << 13);
        *(unsigned char *)(v6 + 738) = BYTE2(v7);
      }
LABEL_8:
      uint64_t v8 = *(void *)(v6 + 336);
      if (v8)
      {
        uint64_t v9 = *(void *)(v8 + 24);
        if (v9)
        {
          id v10 = *(void (**)(uint64_t))(v9 + 160);
          if (v10)
          {
            uint64_t v11 = *(void *)(v6 + 336);
            v10(v11);
            return;
          }
        }
        __nwlog_obj();
        BOOL v32 = *(const char **)(v8 + 16);
        if (!v32) {
          BOOL v32 = "invalid";
        }
      }
      else
      {
        __nwlog_obj();
        BOOL v32 = "invalid";
      }
      *(_DWORD *)buf = 136446466;
      char v65 = "nw_protocol_http3_stream_notify";
      __int16 v66 = 2082;
      unsigned int v67 = (void *)v32;
      BOOL v18 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v62 = 0;
      if (!__nwlog_fault(v18, &type, &v62)) {
        goto LABEL_127;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        __int16 v44 = __nwlog_obj();
        os_log_type_t v45 = type;
        if (!os_log_type_enabled(v44, type)) {
          goto LABEL_127;
        }
        uint64_t v46 = "invalid";
        if (v8 && *(void *)(v8 + 16)) {
          uint64_t v46 = *(const char **)(v8 + 16);
        }
        *(_DWORD *)buf = 136446466;
        char v65 = "nw_protocol_http3_stream_notify";
        __int16 v66 = 2082;
        unsigned int v67 = (void *)v46;
        uint64_t v21 = "%{public}s protocol %{public}s has invalid notify callback";
LABEL_125:
        int v54 = v44;
        os_log_type_t v55 = v45;
        uint32_t v56 = 22;
        goto LABEL_126;
      }
      if (!v62)
      {
        __int16 v44 = __nwlog_obj();
        os_log_type_t v45 = type;
        if (!os_log_type_enabled(v44, type)) {
          goto LABEL_127;
        }
        __int16 v53 = "invalid";
        if (v8 && *(void *)(v8 + 16)) {
          __int16 v53 = *(const char **)(v8 + 16);
        }
        *(_DWORD *)buf = 136446466;
        char v65 = "nw_protocol_http3_stream_notify";
        __int16 v66 = 2082;
        unsigned int v67 = (void *)v53;
        uint64_t v21 = "%{public}s protocol %{public}s has invalid notify callback, backtrace limit exceeded";
        goto LABEL_125;
      }
      __int16 v47 = (char *)__nw_create_backtrace_string();
      __int16 v44 = __nwlog_obj();
      os_log_type_t v45 = type;
      BOOL v48 = os_log_type_enabled(v44, type);
      if (!v47)
      {
        if (!v48) {
          goto LABEL_127;
        }
        __int16 v61 = "invalid";
        if (v8 && *(void *)(v8 + 16)) {
          __int16 v61 = *(const char **)(v8 + 16);
        }
        *(_DWORD *)buf = 136446466;
        char v65 = "nw_protocol_http3_stream_notify";
        __int16 v66 = 2082;
        unsigned int v67 = (void *)v61;
        uint64_t v21 = "%{public}s protocol %{public}s has invalid notify callback, no backtrace";
        goto LABEL_125;
      }
      if (v48)
      {
        __int16 v49 = "invalid";
        if (v8 && *(void *)(v8 + 16)) {
          __int16 v49 = *(const char **)(v8 + 16);
        }
        *(_DWORD *)buf = 136446722;
        char v65 = "nw_protocol_http3_stream_notify";
        __int16 v66 = 2082;
        unsigned int v67 = (void *)v49;
        __int16 v68 = 2082;
        uint64_t v69 = v47;
        _os_log_impl(&dword_1830D4000, v44, v45, "%{public}s protocol %{public}s has invalid notify callback, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(v47);
      if (!v18) {
        return;
      }
      goto LABEL_128;
    case 22:
      if ((*(_WORD *)(v6 + 736) & 0x800) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v12 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        {
          int v13 = *(_DWORD *)(*(void *)(v6 + 336) + 1280);
          uint64_t v14 = *(void *)(v6 + 240);
          *(_DWORD *)buf = 136447234;
          char v65 = "nw_protocol_http3_stream_notify";
          __int16 v66 = 2082;
          unsigned int v67 = (void *)(v6 + 636);
          __int16 v68 = 2080;
          uint64_t v69 = " ";
          __int16 v70 = 1024;
          int v71 = v13;
          __int16 v72 = 2048;
          uint64_t v73 = v14;
          _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%llu> restart received, assuming connection closed", buf, 0x30u);
        }
      }
      *(_WORD *)(*(void *)(v6 + 336) + 1373) |= 8u;
      goto LABEL_18;
    default:
LABEL_18:
      uint64_t v15 = *(void *)(a1 + 48);
      if (v15)
      {
        uint64_t v16 = *(void *)(v15 + 24);
        if (v16)
        {
          BOOL v17 = *(void (**)(void))(v16 + 160);
          if (v17)
          {
            v17();
            return;
          }
        }
      }
      __nwlog_obj();
      uint64_t v22 = *(void *)(a1 + 48);
      dispatch_data_t v23 = "invalid";
      if (v22)
      {
        uint64_t v24 = *(const char **)(v22 + 16);
        if (v24) {
          dispatch_data_t v23 = v24;
        }
      }
      *(_DWORD *)buf = 136446466;
      char v65 = "nw_protocol_http3_stream_notify";
      __int16 v66 = 2082;
      unsigned int v67 = (void *)v23;
      os_log_type_t v25 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v62 = 0;
      if (!__nwlog_fault(v25, &type, &v62)) {
        goto LABEL_118;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v26 = __nwlog_obj();
        os_log_type_t v27 = type;
        if (!os_log_type_enabled(v26, type)) {
          goto LABEL_118;
        }
        uint64_t v28 = *(void *)(a1 + 48);
        uint64_t v29 = "invalid";
        if (v28)
        {
          uint64_t v30 = *(const char **)(v28 + 16);
          if (v30) {
            uint64_t v29 = v30;
          }
        }
        *(_DWORD *)buf = 136446466;
        char v65 = "nw_protocol_http3_stream_notify";
        __int16 v66 = 2082;
        unsigned int v67 = (void *)v29;
        os_log_type_t v31 = "%{public}s protocol %{public}s has invalid notify callback";
LABEL_117:
        _os_log_impl(&dword_1830D4000, v26, v27, v31, buf, 0x16u);
        goto LABEL_118;
      }
      if (!v62)
      {
        BOOL v26 = __nwlog_obj();
        os_log_type_t v27 = type;
        if (!os_log_type_enabled(v26, type)) {
          goto LABEL_118;
        }
        uint64_t v50 = *(void *)(a1 + 48);
        __int16 v51 = "invalid";
        if (v50)
        {
          int v52 = *(const char **)(v50 + 16);
          if (v52) {
            __int16 v51 = v52;
          }
        }
        *(_DWORD *)buf = 136446466;
        char v65 = "nw_protocol_http3_stream_notify";
        __int16 v66 = 2082;
        unsigned int v67 = (void *)v51;
        os_log_type_t v31 = "%{public}s protocol %{public}s has invalid notify callback, backtrace limit exceeded";
        goto LABEL_117;
      }
      __int16 v39 = (char *)__nw_create_backtrace_string();
      BOOL v26 = __nwlog_obj();
      os_log_type_t v27 = type;
      BOOL v40 = os_log_type_enabled(v26, type);
      if (!v39)
      {
        if (!v40) {
          goto LABEL_118;
        }
        uint64_t v57 = *(void *)(a1 + 48);
        uint64_t v58 = "invalid";
        if (v57)
        {
          __int16 v59 = *(const char **)(v57 + 16);
          if (v59) {
            uint64_t v58 = v59;
          }
        }
        *(_DWORD *)buf = 136446466;
        char v65 = "nw_protocol_http3_stream_notify";
        __int16 v66 = 2082;
        unsigned int v67 = (void *)v58;
        os_log_type_t v31 = "%{public}s protocol %{public}s has invalid notify callback, no backtrace";
        goto LABEL_117;
      }
      if (v40)
      {
        uint64_t v41 = *(void *)(a1 + 48);
        BOOL v42 = "invalid";
        if (v41)
        {
          uint64_t v43 = *(const char **)(v41 + 16);
          if (v43) {
            BOOL v42 = v43;
          }
        }
        *(_DWORD *)buf = 136446722;
        char v65 = "nw_protocol_http3_stream_notify";
        __int16 v66 = 2082;
        unsigned int v67 = (void *)v42;
        __int16 v68 = 2082;
        uint64_t v69 = v39;
        _os_log_impl(&dword_1830D4000, v26, v27, "%{public}s protocol %{public}s has invalid notify callback, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(v39);
LABEL_118:
      if (v25)
      {
        int v60 = (char *)v25;
LABEL_129:
        free(v60);
      }
      return;
  }
}

uint64_t nw_protocol_http3_stream_copy_info(uint64_t a1, int a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "nw_protocol_http3_stream_copy_info";
    id v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (!__nwlog_fault(v10, &type, &v19)) {
      goto LABEL_53;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_53;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v22 = "nw_protocol_http3_stream_copy_info";
      int v13 = "%{public}s called with null protocol";
LABEL_52:
      _os_log_impl(&dword_1830D4000, v11, v12, v13, buf, 0xCu);
      goto LABEL_53;
    }
    if (!v19)
    {
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_protocol_http3_stream_copy_info";
        int v13 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v11 = __nwlog_obj();
    os_log_type_t v12 = type;
    BOOL v15 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_protocol_http3_stream_copy_info";
        int v13 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    if (!v15) {
      goto LABEL_39;
    }
    *(_DWORD *)buf = 136446466;
    uint64_t v22 = "nw_protocol_http3_stream_copy_info";
    __int16 v23 = 2082;
    uint64_t v24 = backtrace_string;
    uint64_t v16 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_38:
    _os_log_impl(&dword_1830D4000, v11, v12, v16, buf, 0x16u);
    goto LABEL_39;
  }
  uint64_t v2 = *(void *)(a1 + 40);
  if (!v2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "nw_protocol_http3_stream_copy_info";
    id v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (!__nwlog_fault(v10, &type, &v19)) {
      goto LABEL_53;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_53;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v22 = "nw_protocol_http3_stream_copy_info";
      int v13 = "%{public}s called with null http3_stream";
      goto LABEL_52;
    }
    if (!v19)
    {
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_protocol_http3_stream_copy_info";
        int v13 = "%{public}s called with null http3_stream, backtrace limit exceeded";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v11 = __nwlog_obj();
    os_log_type_t v12 = type;
    BOOL v17 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_protocol_http3_stream_copy_info";
        int v13 = "%{public}s called with null http3_stream, no backtrace";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    if (!v17) {
      goto LABEL_39;
    }
    *(_DWORD *)buf = 136446466;
    uint64_t v22 = "nw_protocol_http3_stream_copy_info";
    __int16 v23 = 2082;
    uint64_t v24 = backtrace_string;
    uint64_t v16 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
    goto LABEL_38;
  }
  uint64_t v3 = *(void *)(v2 + 336);
  if (v3)
  {
    if (a2 == 253) {
      return *(void *)(v3 + 1088);
    }
    uint64_t v6 = nw_protocol_common_copy_info(a1, a2);
    BOOL v5 = v6;
    if (a2 == 255)
    {
      if (!v6) {
        BOOL v5 = nw_array_create();
      }
      int v7 = *(void **)(*(void *)(v2 + 336) + 1248);
      if (v7) {
        nw_array_append(v5, v7);
      }
      uint64_t v8 = *(void **)(v2 + 392);
      if (v8) {
        nw_array_append(v5, v8);
      }
    }
    return v5;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v22 = "nw_protocol_http3_stream_copy_info";
  id v10 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (!__nwlog_fault(v10, &type, &v19)) {
    goto LABEL_53;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v19)
    {
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_protocol_http3_stream_copy_info";
        int v13 = "%{public}s called with null http3_stream->http3_connection, backtrace limit exceeded";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v11 = __nwlog_obj();
    os_log_type_t v12 = type;
    BOOL v18 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_protocol_http3_stream_copy_info";
        int v13 = "%{public}s called with null http3_stream->http3_connection, no backtrace";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v22 = "nw_protocol_http3_stream_copy_info";
      __int16 v23 = 2082;
      uint64_t v24 = backtrace_string;
      uint64_t v16 = "%{public}s called with null http3_stream->http3_connection, dumping backtrace:%{public}s";
      goto LABEL_38;
    }
LABEL_39:
    free(backtrace_string);
    goto LABEL_53;
  }
  uint64_t v11 = __nwlog_obj();
  os_log_type_t v12 = type;
  if (os_log_type_enabled(v11, type))
  {
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "nw_protocol_http3_stream_copy_info";
    int v13 = "%{public}s called with null http3_stream->http3_connection";
    goto LABEL_52;
  }
LABEL_53:
  if (v10) {
    free(v10);
  }
  return 0;
}

uint64_t nw_protocol_http3_stream_get_remote_endpoint(nw_protocol *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v18 = "nw_protocol_http3_stream_get_remote_endpoint";
    int v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (!__nwlog_fault(v7, &type, &v15)) {
      goto LABEL_37;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_37;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v18 = "nw_protocol_http3_stream_get_remote_endpoint";
      id v10 = "%{public}s called with null protocol";
      goto LABEL_36;
    }
    if (!v15)
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_37;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v18 = "nw_protocol_http3_stream_get_remote_endpoint";
      id v10 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_36;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v8 = __nwlog_obj();
    os_log_type_t v9 = type;
    BOOL v12 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (!v12) {
        goto LABEL_37;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v18 = "nw_protocol_http3_stream_get_remote_endpoint";
      id v10 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_36;
    }
    if (v12)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v18 = "nw_protocol_http3_stream_get_remote_endpoint";
      __int16 v19 = 2082;
      os_log_type_t v20 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_37:
    if (!v7) {
      return 0;
    }
LABEL_38:
    free(v7);
    return 0;
  }
  uint64_t handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v18 = "nw_protocol_http3_stream_get_remote_endpoint";
    int v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (!__nwlog_fault(v7, &type, &v15)) {
      goto LABEL_37;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_37;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v18 = "nw_protocol_http3_stream_get_remote_endpoint";
      id v10 = "%{public}s called with null http3_stream";
      goto LABEL_36;
    }
    if (!v15)
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_37;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v18 = "nw_protocol_http3_stream_get_remote_endpoint";
      id v10 = "%{public}s called with null http3_stream, backtrace limit exceeded";
      goto LABEL_36;
    }
    int v13 = (char *)__nw_create_backtrace_string();
    uint64_t v8 = __nwlog_obj();
    os_log_type_t v9 = type;
    BOOL v14 = os_log_type_enabled(v8, type);
    if (v13)
    {
      if (v14)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v18 = "nw_protocol_http3_stream_get_remote_endpoint";
        __int16 v19 = 2082;
        os_log_type_t v20 = v13;
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null http3_stream, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v13);
      if (!v7) {
        return 0;
      }
      goto LABEL_38;
    }
    if (v14)
    {
      *(_DWORD *)buf = 136446210;
      BOOL v18 = "nw_protocol_http3_stream_get_remote_endpoint";
      id v10 = "%{public}s called with null http3_stream, no backtrace";
LABEL_36:
      _os_log_impl(&dword_1830D4000, v8, v9, v10, buf, 0xCu);
      goto LABEL_37;
    }
    goto LABEL_37;
  }
  uint64_t v2 = handle[6];
  if (!v2) {
    return 0;
  }
  uint64_t v3 = *(void *)(v2 + 24);
  if (!v3) {
    return 0;
  }
  id v4 = *(uint64_t (**)(nw_protocol *))(v3 + 136);
  if (!v4) {
    return 0;
  }
  default_input_handler = a1->default_input_handler;

  return v4(default_input_handler);
}

uint64_t nw_protocol_http3_stream_remove_listen_handler(nw_protocol *a1, nw_listen_protocol *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v21 = "nw_protocol_http3_stream_remove_listen_handler";
    BOOL v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (!__nwlog_fault(v5, &type, &v18)) {
      goto LABEL_49;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_49;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v21 = "nw_protocol_http3_stream_remove_listen_handler";
      uint64_t v8 = "%{public}s called with null protocol";
LABEL_48:
      _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0xCu);
      goto LABEL_49;
    }
    if (!v18)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v21 = "nw_protocol_http3_stream_remove_listen_handler";
        uint64_t v8 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_48;
      }
      goto LABEL_49;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v6 = __nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v14 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v21 = "nw_protocol_http3_stream_remove_listen_handler";
        uint64_t v8 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_48;
      }
      goto LABEL_49;
    }
    if (!v14) {
      goto LABEL_35;
    }
    *(_DWORD *)buf = 136446466;
    uint64_t v21 = "nw_protocol_http3_stream_remove_listen_handler";
    __int16 v22 = 2082;
    __int16 v23 = backtrace_string;
    char v15 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_34:
    _os_log_impl(&dword_1830D4000, v6, v7, v15, buf, 0x16u);
    goto LABEL_35;
  }
  uint64_t handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v21 = "nw_protocol_http3_stream_remove_listen_handler";
    BOOL v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (!__nwlog_fault(v5, &type, &v18)) {
      goto LABEL_49;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_49;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v21 = "nw_protocol_http3_stream_remove_listen_handler";
      uint64_t v8 = "%{public}s called with null http3_stream";
      goto LABEL_48;
    }
    if (!v18)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v21 = "nw_protocol_http3_stream_remove_listen_handler";
        uint64_t v8 = "%{public}s called with null http3_stream, backtrace limit exceeded";
        goto LABEL_48;
      }
      goto LABEL_49;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v6 = __nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v16 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v21 = "nw_protocol_http3_stream_remove_listen_handler";
        uint64_t v8 = "%{public}s called with null http3_stream, no backtrace";
        goto LABEL_48;
      }
      goto LABEL_49;
    }
    if (!v16) {
      goto LABEL_35;
    }
    *(_DWORD *)buf = 136446466;
    uint64_t v21 = "nw_protocol_http3_stream_remove_listen_handler";
    __int16 v22 = 2082;
    __int16 v23 = backtrace_string;
    char v15 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
    goto LABEL_34;
  }
  uint64_t v3 = handle[42];
  if (v3)
  {
    if ((handle[92] & 0x800) == 0 && gLogDatapath)
    {
      os_log_type_t v9 = __nwlog_obj();
      BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG);
      uint64_t v3 = handle[42];
      if (v10)
      {
        int v11 = *(_DWORD *)(v3 + 1280);
        uint64_t v12 = handle[30];
        *(_DWORD *)buf = 136447234;
        uint64_t v21 = "nw_protocol_http3_stream_remove_listen_handler";
        __int16 v22 = 2082;
        __int16 v23 = (char *)handle + 636;
        __int16 v24 = 2080;
        uint64_t v25 = " ";
        __int16 v26 = 1024;
        int v27 = v11;
        __int16 v28 = 2048;
        uint64_t v29 = v12;
        _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called", buf, 0x30u);
        uint64_t v3 = handle[42];
      }
    }
    return (*(uint64_t (**)(void))(*(void *)(v3 + 24) + 240))();
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v21 = "nw_protocol_http3_stream_remove_listen_handler";
  BOOL v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (!__nwlog_fault(v5, &type, &v18)) {
    goto LABEL_49;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v18)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v21 = "nw_protocol_http3_stream_remove_listen_handler";
        uint64_t v8 = "%{public}s called with null http3_stream->http3_connection, backtrace limit exceeded";
        goto LABEL_48;
      }
      goto LABEL_49;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v6 = __nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v17 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v21 = "nw_protocol_http3_stream_remove_listen_handler";
        uint64_t v8 = "%{public}s called with null http3_stream->http3_connection, no backtrace";
        goto LABEL_48;
      }
      goto LABEL_49;
    }
    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v21 = "nw_protocol_http3_stream_remove_listen_handler";
      __int16 v22 = 2082;
      __int16 v23 = backtrace_string;
      char v15 = "%{public}s called with null http3_stream->http3_connection, dumping backtrace:%{public}s";
      goto LABEL_34;
    }
LABEL_35:
    free(backtrace_string);
    goto LABEL_49;
  }
  uint64_t v6 = __nwlog_obj();
  os_log_type_t v7 = type;
  if (os_log_type_enabled(v6, type))
  {
    *(_DWORD *)buf = 136446210;
    uint64_t v21 = "nw_protocol_http3_stream_remove_listen_handler";
    uint64_t v8 = "%{public}s called with null http3_stream->http3_connection";
    goto LABEL_48;
  }
LABEL_49:
  if (v5) {
    free(v5);
  }
  return 0;
}

uint64_t nw_protocol_http3_stream_add_listen_handler(nw_protocol *a1, nw_listen_protocol *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v21 = "nw_protocol_http3_stream_add_listen_handler";
    BOOL v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (!__nwlog_fault(v5, &type, &v18)) {
      goto LABEL_49;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_49;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v21 = "nw_protocol_http3_stream_add_listen_handler";
      uint64_t v8 = "%{public}s called with null protocol";
LABEL_48:
      _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0xCu);
      goto LABEL_49;
    }
    if (!v18)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v21 = "nw_protocol_http3_stream_add_listen_handler";
        uint64_t v8 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_48;
      }
      goto LABEL_49;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v6 = __nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v14 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v21 = "nw_protocol_http3_stream_add_listen_handler";
        uint64_t v8 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_48;
      }
      goto LABEL_49;
    }
    if (!v14) {
      goto LABEL_35;
    }
    *(_DWORD *)buf = 136446466;
    uint64_t v21 = "nw_protocol_http3_stream_add_listen_handler";
    __int16 v22 = 2082;
    __int16 v23 = backtrace_string;
    char v15 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_34:
    _os_log_impl(&dword_1830D4000, v6, v7, v15, buf, 0x16u);
    goto LABEL_35;
  }
  uint64_t handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v21 = "nw_protocol_http3_stream_add_listen_handler";
    BOOL v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (!__nwlog_fault(v5, &type, &v18)) {
      goto LABEL_49;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_49;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v21 = "nw_protocol_http3_stream_add_listen_handler";
      uint64_t v8 = "%{public}s called with null http3_stream";
      goto LABEL_48;
    }
    if (!v18)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v21 = "nw_protocol_http3_stream_add_listen_handler";
        uint64_t v8 = "%{public}s called with null http3_stream, backtrace limit exceeded";
        goto LABEL_48;
      }
      goto LABEL_49;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v6 = __nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v16 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v21 = "nw_protocol_http3_stream_add_listen_handler";
        uint64_t v8 = "%{public}s called with null http3_stream, no backtrace";
        goto LABEL_48;
      }
      goto LABEL_49;
    }
    if (!v16) {
      goto LABEL_35;
    }
    *(_DWORD *)buf = 136446466;
    uint64_t v21 = "nw_protocol_http3_stream_add_listen_handler";
    __int16 v22 = 2082;
    __int16 v23 = backtrace_string;
    char v15 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
    goto LABEL_34;
  }
  uint64_t v3 = handle[42];
  if (v3)
  {
    if ((handle[92] & 0x800) == 0 && gLogDatapath)
    {
      os_log_type_t v9 = __nwlog_obj();
      BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG);
      uint64_t v3 = handle[42];
      if (v10)
      {
        int v11 = *(_DWORD *)(v3 + 1280);
        uint64_t v12 = handle[30];
        *(_DWORD *)buf = 136447234;
        uint64_t v21 = "nw_protocol_http3_stream_add_listen_handler";
        __int16 v22 = 2082;
        __int16 v23 = (char *)handle + 636;
        __int16 v24 = 2080;
        uint64_t v25 = " ";
        __int16 v26 = 1024;
        int v27 = v11;
        __int16 v28 = 2048;
        uint64_t v29 = v12;
        _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called", buf, 0x30u);
        uint64_t v3 = handle[42];
      }
    }
    return (*(uint64_t (**)(void))(*(void *)(v3 + 24) + 232))();
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v21 = "nw_protocol_http3_stream_add_listen_handler";
  BOOL v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (!__nwlog_fault(v5, &type, &v18)) {
    goto LABEL_49;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v18)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v21 = "nw_protocol_http3_stream_add_listen_handler";
        uint64_t v8 = "%{public}s called with null http3_stream->http3_connection, backtrace limit exceeded";
        goto LABEL_48;
      }
      goto LABEL_49;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v6 = __nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v17 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v21 = "nw_protocol_http3_stream_add_listen_handler";
        uint64_t v8 = "%{public}s called with null http3_stream->http3_connection, no backtrace";
        goto LABEL_48;
      }
      goto LABEL_49;
    }
    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v21 = "nw_protocol_http3_stream_add_listen_handler";
      __int16 v22 = 2082;
      __int16 v23 = backtrace_string;
      char v15 = "%{public}s called with null http3_stream->http3_connection, dumping backtrace:%{public}s";
      goto LABEL_34;
    }
LABEL_35:
    free(backtrace_string);
    goto LABEL_49;
  }
  uint64_t v6 = __nwlog_obj();
  os_log_type_t v7 = type;
  if (os_log_type_enabled(v6, type))
  {
    *(_DWORD *)buf = 136446210;
    uint64_t v21 = "nw_protocol_http3_stream_add_listen_handler";
    uint64_t v8 = "%{public}s called with null http3_stream->http3_connection";
    goto LABEL_48;
  }
LABEL_49:
  if (v5) {
    free(v5);
  }
  return 0;
}

uint64_t nw_protocol_http3_stream_supports_external_data(nw_protocol *a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t handle = a1->handle;
    if (handle)
    {
      int v2 = handle[92];
      if (v2 == 3 || v2 == 5 && handle + 16 == (_DWORD *)a1) {
        return handle[184] & 1;
      }
      else {
        return 1;
      }
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v15 = "nw_protocol_http3_stream_supports_external_data";
    id v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (!__nwlog_fault(v4, &type, &v12)) {
      goto LABEL_36;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        char v15 = "nw_protocol_http3_stream_supports_external_data";
        os_log_type_t v7 = "%{public}s called with null http3_stream";
        goto LABEL_35;
      }
      goto LABEL_36;
    }
    if (!v12)
    {
      BOOL v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        char v15 = "nw_protocol_http3_stream_supports_external_data";
        os_log_type_t v7 = "%{public}s called with null http3_stream, backtrace limit exceeded";
        goto LABEL_35;
      }
      goto LABEL_36;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v5 = __nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v11 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v15 = "nw_protocol_http3_stream_supports_external_data";
        os_log_type_t v7 = "%{public}s called with null http3_stream, no backtrace";
        goto LABEL_35;
      }
      goto LABEL_36;
    }
    if (v11)
    {
      *(_DWORD *)buf = 136446466;
      char v15 = "nw_protocol_http3_stream_supports_external_data";
      __int16 v16 = 2082;
      BOOL v17 = backtrace_string;
      BOOL v10 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
      goto LABEL_25;
    }
    goto LABEL_26;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v15 = "nw_protocol_http3_stream_supports_external_data";
  id v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (!__nwlog_fault(v4, &type, &v12)) {
    goto LABEL_36;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v12)
    {
      BOOL v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        char v15 = "nw_protocol_http3_stream_supports_external_data";
        os_log_type_t v7 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_35;
      }
      goto LABEL_36;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v5 = __nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v9 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        char v15 = "nw_protocol_http3_stream_supports_external_data";
        os_log_type_t v7 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_35;
      }
      goto LABEL_36;
    }
    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      char v15 = "nw_protocol_http3_stream_supports_external_data";
      __int16 v16 = 2082;
      BOOL v17 = backtrace_string;
      BOOL v10 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_25:
      _os_log_impl(&dword_1830D4000, v5, v6, v10, buf, 0x16u);
    }
LABEL_26:
    free(backtrace_string);
    goto LABEL_36;
  }
  BOOL v5 = __nwlog_obj();
  os_log_type_t v6 = type;
  if (os_log_type_enabled(v5, type))
  {
    *(_DWORD *)buf = 136446210;
    char v15 = "nw_protocol_http3_stream_supports_external_data";
    os_log_type_t v7 = "%{public}s called with null protocol";
LABEL_35:
    _os_log_impl(&dword_1830D4000, v5, v6, v7, buf, 0xCu);
  }
LABEL_36:
  if (v4) {
    free(v4);
  }
  return 0;
}

uint64_t nw_protocol_http3_stream_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_finalize_output_frames";
    BOOL v11 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    BYTE4(v74) = 0;
    if (!__nwlog_fault(v11, type, (unsigned char *)&v74 + 4)) {
      goto LABEL_72;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      char v12 = __nwlog_obj();
      os_log_type_t v13 = type[0];
      if (!os_log_type_enabled(v12, type[0])) {
        goto LABEL_72;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_finalize_output_frames";
      BOOL v14 = "%{public}s called with null protocol";
      goto LABEL_70;
    }
    if (BYTE4(v74))
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v12 = __nwlog_obj();
      os_log_type_t v13 = type[0];
      BOOL v58 = os_log_type_enabled(v12, type[0]);
      if (backtrace_string)
      {
        if (v58)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_finalize_output_frames";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          __int16 v59 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_101:
          _os_log_impl(&dword_1830D4000, v12, v13, v59, buf, 0x16u);
        }
LABEL_102:
        free(backtrace_string);
        goto LABEL_72;
      }
      if (!v58) {
        goto LABEL_72;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_finalize_output_frames";
      BOOL v14 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      char v12 = __nwlog_obj();
      os_log_type_t v13 = type[0];
      if (!os_log_type_enabled(v12, type[0])) {
        goto LABEL_72;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_finalize_output_frames";
      BOOL v14 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_70:
    __int16 v49 = v12;
    os_log_type_t v50 = v13;
LABEL_71:
    _os_log_impl(&dword_1830D4000, v49, v50, v14, buf, 0xCu);
    goto LABEL_72;
  }
  uint64_t handle = (char *)a1->handle;
  if (handle)
  {
    if ((*((_WORD *)handle + 368) & 0x800) == 0)
    {
      if (gLogDatapath)
      {
        __int16 v53 = __nwlog_obj();
        if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG))
        {
          int v54 = *(_DWORD *)(*((void *)handle + 42) + 1280);
          uint64_t v55 = *((void *)handle + 30);
          int v56 = *((_DWORD *)handle + 92);
          *(_DWORD *)buf = 136447490;
          *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_finalize_output_frames";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = handle + 636;
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)&unsigned char buf[24] = " ";
          LOWORD(v81) = 1024;
          *(_DWORD *)((char *)&v81 + 2) = v54;
          WORD3(v81) = 2048;
          *((void *)&v81 + 1) = v55;
          *(_WORD *)os_log_type_t v82 = 1024;
          *(_DWORD *)&v82[2] = v56;
          _os_log_impl(&dword_1830D4000, v53, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called, state %u", buf, 0x36u);
        }
      }
    }
    uint64_t v4 = 0;
    switch(*((_DWORD *)handle + 92))
    {
      case 0:
      case 1:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v5 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_finalize_output_frames";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v5;
        os_log_type_t v6 = (const char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        BYTE4(v74) = 0;
        if (!__nwlog_fault(v6, type, (unsigned char *)&v74 + 4)) {
          goto LABEL_66;
        }
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v7 = gLogObj;
          os_log_type_t v8 = type[0];
          if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
          {
            int v9 = *((_DWORD *)handle + 92);
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_finalize_output_frames";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v9;
            BOOL v10 = "%{public}s Unexpected output state %d";
LABEL_65:
            _os_log_impl(&dword_1830D4000, v7, v8, v10, buf, 0x12u);
          }
        }
        else if (BYTE4(v74))
        {
          BOOL v38 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v7 = gLogObj;
          os_log_type_t v8 = type[0];
          BOOL v39 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
          if (v38)
          {
            if (v39)
            {
              int v40 = *((_DWORD *)handle + 92);
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_finalize_output_frames";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v40;
              *(_WORD *)&buf[18] = 2082;
              *(void *)&buf[20] = v38;
              _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s Unexpected output state %d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }
            free(v38);
            goto LABEL_66;
          }
          if (v39)
          {
            int v47 = *((_DWORD *)handle + 92);
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_finalize_output_frames";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v47;
            BOOL v10 = "%{public}s Unexpected output state %d, no backtrace";
            goto LABEL_65;
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v7 = gLogObj;
          os_log_type_t v8 = type[0];
          if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
          {
            int v42 = *((_DWORD *)handle + 92);
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_finalize_output_frames";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v42;
            BOOL v10 = "%{public}s Unexpected output state %d, backtrace limit exceeded";
            goto LABEL_65;
          }
        }
LABEL_66:
        if (!v6) {
          return 0;
        }
        BOOL v48 = (char *)v6;
        goto LABEL_74;
      case 2:
        if (a2->tqh_first == (nw_frame *)*((void *)handle + 48))
        {
          int is_metadata_complete = nw_frame_is_metadata_complete((uint64_t)a2->tqh_first);
          nw_http3_stream_send_fields((uint64_t)handle, is_metadata_complete);
          return 1;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_finalize_output_frames";
        BOOL v11 = (const char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        BYTE4(v74) = 0;
        if (!__nwlog_fault(v11, type, (unsigned char *)&v74 + 4)) {
          goto LABEL_72;
        }
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          char v12 = gLogObj;
          os_log_type_t v13 = type[0];
          if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
            goto LABEL_72;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_finalize_output_frames";
          BOOL v14 = "%{public}s Expected frame array first to be the same as http3_stream->output_fields_frame";
          goto LABEL_70;
        }
        if (!BYTE4(v74))
        {
          char v12 = __nwlog_obj();
          os_log_type_t v13 = type[0];
          if (!os_log_type_enabled(v12, type[0])) {
            goto LABEL_72;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_finalize_output_frames";
          BOOL v14 = "%{public}s Expected frame array first to be the same as http3_stream->output_fields_frame, backtrace limit exceeded";
          goto LABEL_70;
        }
        uint64_t v43 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v44 = gLogObj;
        os_log_type_t v45 = type[0];
        BOOL v46 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
        if (v43)
        {
          if (v46)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_finalize_output_frames";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v43;
            _os_log_impl(&dword_1830D4000, v44, v45, "%{public}s Expected frame array first to be the same as http3_stream->output_fields_frame, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v43);
          goto LABEL_72;
        }
        if (!v46) {
          goto LABEL_72;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_finalize_output_frames";
        BOOL v14 = "%{public}s Expected frame array first to be the same as http3_stream->output_fields_frame, no backtrace";
        __int16 v49 = v44;
        os_log_type_t v50 = v45;
        goto LABEL_71;
      case 3:
        char v15 = handle + 736;
        uint64_t v16 = **((void **)a2->tqh_last + 1);
        *(void *)os_log_type_t type = 0;
        int v77 = type;
        uint64_t v78 = 0x2000000000;
        BOOL v79 = 0;
        if (v16)
        {
          unsigned int v17 = *(char *)(v16 + 186);
          char v18 = *(unsigned char *)(v16 + 186);
          int v19 = (v17 >> 7) & 1;
          BOOL v79 = (v17 & 0x80) != 0;
          if ((v17 & 0x80000000) == 0)
          {
            uint64_t v20 = *(void *)(v16 + 64);
            if (v20)
            {
              if ((*(unsigned char *)(v20 + 66) & 0x40) != 0)
              {
                v75[0] = MEMORY[0x1E4F143A8];
                v75[1] = 0x40000000;
                v75[2] = ___ZL47nw_protocol_http3_stream_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke;
                v75[3] = &unk_1E5247978;
                v75[4] = type;
                nw_frame_foreach_protocol_metadata(v16, 0, (uint64_t)v75);
                int v19 = *((unsigned __int8 *)v77 + 24);
                char v18 = *(unsigned char *)(v16 + 186);
              }
            }
          }
          *(unsigned char *)(v16 + 186) = v18 & 0x7F | ((v19 != 0) << 7);
        }
        if ((*v15 & 0x800) == 0)
        {
          if (gLogDatapath)
          {
            __int16 v61 = __nwlog_obj();
            if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG))
            {
              int v62 = *(_DWORD *)(*((void *)handle + 42) + 1280);
              uint64_t v63 = *((void *)handle + 30);
              *(_DWORD *)buf = 0;
              nw_frame_array_get_frame_count((uint64_t *)a2, 1, buf);
              int v64 = *(_DWORD *)buf;
              if (*((unsigned char *)v77 + 24)) {
                char v65 = ", complete";
              }
              else {
                char v65 = "";
              }
              *(_DWORD *)buf = 136447746;
              *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_finalize_output_frames";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = handle + 636;
              *(_WORD *)&unsigned char buf[22] = 2080;
              *(void *)&unsigned char buf[24] = " ";
              LOWORD(v81) = 1024;
              *(_DWORD *)((char *)&v81 + 2) = v62;
              WORD3(v81) = 2048;
              *((void *)&v81 + 1) = v63;
              *(_WORD *)os_log_type_t v82 = 1024;
              *(_DWORD *)&v82[2] = v64;
              *(_WORD *)&v82[6] = 2080;
              *(void *)&v82[8] = v65;
              _os_log_impl(&dword_1830D4000, v61, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> sending %u bytes of body data%s", buf, 0x40u);
            }
          }
        }
        uint64_t v74 = 0;
        uint64_t v4 = *((void *)handle + 20);
        if (v4)
        {
          uint64_t v21 = *(void *)(v4 + 24);
          if (v21 && *(void *)(v21 + 96))
          {
            *(void *)buf = MEMORY[0x1E4F143A8];
            *(void *)&buf[8] = 0x40000000;
            *(void *)&buf[16] = ___ZL64nw_http3_framer_finalize_output_frames_for_multiple_http3_framesP15nw_http3_frameryP16nw_frame_array_sPjS3__block_invoke;
            *(void *)&unsigned char buf[24] = &__block_descriptor_tmp_172;
            *(void *)&long long v81 = 0;
            *((void *)&v81 + 1) = handle + 128;
            *(void *)os_log_type_t v82 = (char *)&v74 + 4;
            *(void *)&v82[8] = &v74;
            tqh_first = a2->tqh_first;
            do
            {
              if (!tqh_first) {
                break;
              }
              __int16 v23 = (nw_frame *)*((void *)tqh_first + 4);
              char v24 = (*(uint64_t (**)(unsigned char *))&buf[16])(buf);
              tqh_first = v23;
            }
            while ((v24 & 1) != 0);
            uint64_t v4 = (*(uint64_t (**)(uint64_t, nw_frame_array_s *))(*(void *)(v4 + 24) + 96))(v4, a2);
            uint64_t v25 = v74;
          }
          else
          {
            uint64_t v25 = 0;
            uint64_t v4 = 0;
          }
        }
        else
        {
          uint64_t v25 = 0;
        }
        nw_http_transaction_metadata_increment_outbound_body_transfer_size(*((void **)handle + 49), v25);
        uint64_t v26 = HIDWORD(v74);
        uint64_t v27 = *((void *)handle + 36);
        BOOL v28 = __CFADD__(v27, HIDWORD(v74));
        *((void *)handle + 36) = v27 + HIDWORD(v74);
        if (v28)
        {
          if (gLogDatapath)
          {
            __int16 v66 = __nwlog_obj();
            if (os_log_type_enabled(v66, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v67 = *((void *)handle + 36);
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "increment_outbound_body_size";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = "outbound_body_size";
              *(_WORD *)&unsigned char buf[22] = 2048;
              *(void *)&unsigned char buf[24] = v26;
              LOWORD(v81) = 2048;
              *(void *)((char *)&v81 + 2) = v67;
              _os_log_impl(&dword_1830D4000, v66, OS_LOG_TYPE_DEBUG, "%{public}s Overflow: %{public}s, increment %llu, result %llu", buf, 0x2Au);
            }
          }
          *((void *)handle + 36) = -1;
        }
        if (*((unsigned char *)v77 + 24))
        {
          nw_http_transaction_metadata_mark_outbound_message_end(*((void **)handle + 49));
          if (handle[280])
          {
            if (*((void *)handle + 34) != *((void *)handle + 36))
            {
              if ((*v15 & 0x800) == 0)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                uint64_t v29 = gLogObj;
                if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                {
                  int v30 = *(_DWORD *)(*((void *)handle + 42) + 1280);
                  uint64_t v31 = *((void *)handle + 30);
                  if (handle[280]) {
                    uint64_t v32 = *((void *)handle + 34);
                  }
                  else {
                    uint64_t v32 = -1;
                  }
                  uint64_t v51 = *((void *)handle + 36);
                  *(_DWORD *)buf = 136447746;
                  *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_finalize_output_frames";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = handle + 636;
                  *(_WORD *)&unsigned char buf[22] = 2080;
                  *(void *)&unsigned char buf[24] = " ";
                  LOWORD(v81) = 1024;
                  *(_DWORD *)((char *)&v81 + 2) = v30;
                  WORD3(v81) = 2048;
                  *((void *)&v81 + 1) = v31;
                  *(_WORD *)os_log_type_t v82 = 2048;
                  *(void *)&v82[2] = v32;
                  *(_WORD *)&v82[10] = 2048;
                  *(void *)&v82[12] = v51;
                  _os_log_impl(&dword_1830D4000, v29, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%llu> Content length header %llu does not equal body size %llu", buf, 0x44u);
                }
              }
              *((void *)handle + 33) = 270;
              nw_protocol_http3_stream_error((nw_protocol *)handle, (nw_protocol *)handle, 22);
              nw_protocol_http3_stream_disconnect((nw_protocol *)handle, (nw_protocol *)handle);
              uint64_t v4 = 0;
            }
          }
        }
        _Block_object_dispose(type, 8);
        return v4;
      case 5:
        if (nw_protocol_copy_http_definition_onceToken != -1) {
          dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_15_74223);
        }
        id v33 = (id)nw_protocol_copy_http_definition_http_definition;
        v68[0] = MEMORY[0x1E4F143A8];
        v68[1] = 0x40000000;
        uint64_t v69 = ___ZL47nw_protocol_http3_stream_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke_170;
        __int16 v70 = &__block_descriptor_tmp_171;
        id v71 = v33;
        __int16 v72 = handle;
        uint64_t v73 = a2;
        BOOL v34 = a2->tqh_first;
        do
        {
          if (!v34) {
            break;
          }
          __int16 v35 = (nw_frame *)*((void *)v34 + 4);
          char v36 = ((uint64_t (*)(void *))v69)(v68);
          BOOL v34 = v35;
        }
        while ((v36 & 1) != 0);
        if (v33) {
          os_release(v33);
        }
        nw_http3_stream_send_pending_capsules((uint64_t)handle);
        uint64_t v37 = *((void *)handle + 12);
        if (!v37) {
          return 0;
        }
        return (*(uint64_t (**)(void))(*(void *)(v37 + 24) + 96))();
      default:
        return v4;
    }
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_finalize_output_frames";
  BOOL v11 = (const char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  BYTE4(v74) = 0;
  if (__nwlog_fault(v11, type, (unsigned char *)&v74 + 4))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      char v12 = __nwlog_obj();
      os_log_type_t v13 = type[0];
      if (!os_log_type_enabled(v12, type[0])) {
        goto LABEL_72;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_finalize_output_frames";
      BOOL v14 = "%{public}s called with null http3_stream";
      goto LABEL_70;
    }
    if (BYTE4(v74))
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v12 = __nwlog_obj();
      os_log_type_t v13 = type[0];
      BOOL v60 = os_log_type_enabled(v12, type[0]);
      if (backtrace_string)
      {
        if (v60)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_finalize_output_frames";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          __int16 v59 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
          goto LABEL_101;
        }
        goto LABEL_102;
      }
      if (!v60) {
        goto LABEL_72;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_finalize_output_frames";
      BOOL v14 = "%{public}s called with null http3_stream, no backtrace";
    }
    else
    {
      char v12 = __nwlog_obj();
      os_log_type_t v13 = type[0];
      if (!os_log_type_enabled(v12, type[0])) {
        goto LABEL_72;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_finalize_output_frames";
      BOOL v14 = "%{public}s called with null http3_stream, backtrace limit exceeded";
    }
    goto LABEL_70;
  }
LABEL_72:
  if (v11)
  {
    BOOL v48 = (char *)v11;
LABEL_74:
    free(v48);
  }
  return 0;
}

uint64_t ___ZL47nw_protocol_http3_stream_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke(uint64_t a1, void *a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = nw_protocol_metadata_is_http(a2);
  return 0;
}

BOOL ___ZL64nw_http3_framer_finalize_output_frames_for_multiple_http3_framesP15nw_http3_frameryP16nw_frame_array_sPjS3__block_invoke(void *a1, _DWORD *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  unsigned int v4 = nw_frame_unclaimed_length(a2);
  if (!v4 && !a1[4]) {
    return 1;
  }
  v15[0] = 0;
  nw_frame_get_buffer((uint64_t)a2, v15);
  unint64_t v5 = a1[4];
  if (v5 < 0x40)
  {
    int v6 = 1;
LABEL_13:
    if (v15[0] >> 30) {
      int v9 = 8;
    }
    else {
      int v9 = 4;
    }
    if (v15[0] >= 0x4000u) {
      int v10 = v9;
    }
    else {
      int v10 = 2;
    }
    if (v15[0] >= 0x40u) {
      int v11 = v10;
    }
    else {
      int v11 = 1;
    }
    BOOL v12 = nw_http3_framer_write_http3_frame_header(a1[5], a1[4], v4, v11 + v6, (uint64_t)a2);
    os_log_type_t v13 = (_DWORD *)a1[6];
    if (v13) {
      *v13 += v4;
    }
    BOOL v14 = (_DWORD *)a1[7];
    if (v14) {
      *v14 += v12 + v4;
    }
    return 1;
  }
  if (v5 < 0x4000)
  {
    int v6 = 2;
    goto LABEL_13;
  }
  if (!(v5 >> 30))
  {
    int v6 = 4;
    goto LABEL_13;
  }
  if (!(v5 >> 62))
  {
    int v6 = 8;
    goto LABEL_13;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  v15[1] = 136446466;
  uint64_t v16 = "_http_vle_length";
  __int16 v17 = 2048;
  unint64_t v18 = v5;
  os_log_type_t v7 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v7);
  if (!result)
  {
    free(v7);
    int v6 = 0;
    goto LABEL_13;
  }
  __break(1u);
  return result;
}

uint64_t ___ZL47nw_protocol_http3_stream_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke_170(uint64_t *a1, uint64_t a2)
{
  unsigned int v4 = nw_frame_copy_metadata_for_protocol(a2, a1[4]);
  if (v4)
  {
    unint64_t v5 = v4;
    if (nw_http_metadata_is_capsule(v4))
    {
      uint64_t v6 = *(void *)(a1[5] + 536);
      if (!v6)
      {
        *(void *)(a1[5] + 536) = nw_array_create();
        uint64_t v6 = *(void *)(a1[5] + 536);
      }
      nw_array_append(v6, v5);
    }
    os_release(v5);
  }
  if (*(void (**)(nw_frame *, BOOL, void *))(a2 + 80) == nw_protocol_http3_capsule_frame_finalizer)
  {
    uint64_t v7 = *(void *)(a2 + 32);
    os_log_type_t v8 = *(void **)(a2 + 40);
    if (v7)
    {
      *(void *)(v7 + 40) = v8;
      os_log_type_t v8 = *(void **)(a2 + 40);
    }
    else
    {
      *(void *)(a1[6] + 8) = v8;
    }
    *os_log_type_t v8 = v7;
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = 0;
    nw_frame_finalize(a2);
  }
  return 1;
}

void nw_http3_stream_send_pending_capsules(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 536);
  if (v1 && *(void *)(v1 + 16) != *(void *)(v1 + 24))
  {
    BOOL v3 = nw_array_create();
    unsigned int v4 = *(atomic_uchar **)(a1 + 536);
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 0x40000000;
    v6[2] = ___ZL37nw_http3_stream_send_pending_capsulesP24nw_protocol_http3_stream_block_invoke;
    v6[3] = &__block_descriptor_tmp_152_62774;
    v6[4] = a1;
    v6[5] = v3;
    nw_array_apply(v4, (uint64_t)v6);
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 0x40000000;
    void v5[2] = ___ZL37nw_http3_stream_send_pending_capsulesP24nw_protocol_http3_stream_block_invoke_153;
    v5[3] = &__block_descriptor_tmp_154;
    v5[4] = a1;
    nw_array_apply((atomic_uchar *)v3, (uint64_t)v5);
    if (v3) {
      os_release((void *)v3);
    }
  }
}

BOOL ___ZL37nw_http3_stream_send_pending_capsulesP24nw_protocol_http3_stream_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v99 = *MEMORY[0x1E4F143B8];
  capsule_os_log_type_t type = nw_http_metadata_get_capsule_type(a3);
  uint64_t v83 = 0;
  uint64_t v84 = &v83;
  uint64_t v85 = 0x2000000000;
  id v86 = 0;
  object = a3;
  id v86 = nw_http_metadata_copy_capsule_data(a3);
  uint64_t v77 = 0;
  uint64_t v78 = &v77;
  uint64_t v79 = 0x3802000000;
  uint64_t v80 = __Block_byref_object_copy__61309;
  long long v81 = __Block_byref_object_dispose__61310;
  v82[0] = 0;
  v82[1] = v82;
  size_t size = dispatch_data_get_size((dispatch_data_t)v84[3]);
  uint64_t v73 = 0;
  uint64_t v74 = &v73;
  uint64_t v75 = 0x2000000000;
  int v76 = size;
  uint64_t v7 = *(void *)(a1 + 32);
  uint64_t v8 = *(void *)(v7 + 160);
  if (!v8 || (uint64_t v9 = *(void *)(v8 + 24)) == 0 || !*(void *)(v9 + 88))
  {
    int v62 = __nwlog_obj();
    if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      unint64_t v90 = "nw_http3_framer_get_output_frames_for_capsule";
      __int16 v91 = 2048;
      int v92 = (const char *)v8;
      _os_log_impl(&dword_1830D4000, v62, OS_LOG_TYPE_ERROR, "%{public}s Output handler (%p)'s get_output_frames callback is not properly set", buf, 0x16u);
    }
    goto LABEL_77;
  }
  unint64_t v66 = capsule_type;
  if (capsule_type >= 0x40)
  {
    if (capsule_type >= 0x4000)
    {
      if (capsule_type >> 30)
      {
        if (capsule_type >> 62)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
          *(_DWORD *)buf = 136446466;
          unint64_t v90 = "_http_vle_length";
          __int16 v91 = 2048;
          int v92 = (const char *)capsule_type;
          int v11 = (void *)_os_log_send_and_compose_impl();
          BOOL result = __nwlog_abort((uint64_t)v11);
          if (result) {
            goto LABEL_113;
          }
          free(v11);
          int v10 = 0;
        }
        else
        {
          int v10 = 8;
        }
      }
      else
      {
        int v10 = 4;
      }
    }
    else
    {
      int v10 = 2;
    }
  }
  else
  {
    int v10 = 1;
  }
  if (size >> 30) {
    int v13 = 8;
  }
  else {
    int v13 = 4;
  }
  if (size >= 0x4000) {
    int v14 = v13;
  }
  else {
    int v14 = 2;
  }
  if (size >= 0x40) {
    int v15 = v14;
  }
  else {
    int v15 = 1;
  }
  int v16 = v15 + v10;
  unsigned int v17 = v15 + v10 + size;
  if (v17 >> 30) {
    int v18 = 9;
  }
  else {
    int v18 = 5;
  }
  if (v17 >= 0x4000) {
    unsigned int v19 = v18;
  }
  else {
    unsigned int v19 = 3;
  }
  if (v17 >= 0x40) {
    uint64_t v20 = v19;
  }
  else {
    uint64_t v20 = 2;
  }
  uint64_t v21 = v17 + v20;
  if (__CFADD__(v17, v20))
  {
    uint64_t v64 = a1;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446978;
    unint64_t v90 = "nw_http3_framer_get_output_frames_for_capsule";
    __int16 v91 = 2082;
    int v92 = "frame_length";
    __int16 v93 = 2048;
    size_t v94 = v20;
    __int16 v95 = 2048;
    uint64_t v96 = v21;
    __int16 v22 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v88 = OS_LOG_TYPE_ERROR;
    char v87 = 0;
    if (__nwlog_fault(v22, &v88, &v87))
    {
      if (v88 == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v23 = gLogObj;
        os_log_type_t v24 = v88;
        if (os_log_type_enabled((os_log_t)gLogObj, v88))
        {
          *(_DWORD *)buf = 136446978;
          unint64_t v90 = "nw_http3_framer_get_output_frames_for_capsule";
          __int16 v91 = 2082;
          int v92 = "frame_length";
          __int16 v93 = 2048;
          size_t v94 = v20;
          __int16 v95 = 2048;
          uint64_t v96 = v21;
          uint64_t v25 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_45:
          BOOL v28 = v23;
LABEL_46:
          _os_log_impl(&dword_1830D4000, v28, v24, v25, buf, 0x2Au);
        }
      }
      else if (v87)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v24 = v88;
        os_log_t log = gLogObj;
        BOOL v27 = os_log_type_enabled((os_log_t)gLogObj, v88);
        if (backtrace_string)
        {
          if (v27)
          {
            *(_DWORD *)buf = 136447234;
            unint64_t v90 = "nw_http3_framer_get_output_frames_for_capsule";
            __int16 v91 = 2082;
            int v92 = "frame_length";
            __int16 v93 = 2048;
            size_t v94 = v20;
            __int16 v95 = 2048;
            uint64_t v96 = v21;
            __int16 v97 = 2082;
            uint64_t v98 = backtrace_string;
            _os_log_impl(&dword_1830D4000, log, v24, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(backtrace_string);
          goto LABEL_47;
        }
        if (v27)
        {
          *(_DWORD *)buf = 136446978;
          unint64_t v90 = "nw_http3_framer_get_output_frames_for_capsule";
          __int16 v91 = 2082;
          int v92 = "frame_length";
          __int16 v93 = 2048;
          size_t v94 = v20;
          __int16 v95 = 2048;
          uint64_t v96 = v21;
          uint64_t v25 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
          BOOL v28 = log;
          goto LABEL_46;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v23 = gLogObj;
        os_log_type_t v24 = v88;
        if (os_log_type_enabled((os_log_t)gLogObj, v88))
        {
          *(_DWORD *)buf = 136446978;
          unint64_t v90 = "nw_http3_framer_get_output_frames_for_capsule";
          __int16 v91 = 2082;
          int v92 = "frame_length";
          __int16 v93 = 2048;
          size_t v94 = v20;
          __int16 v95 = 2048;
          uint64_t v96 = v21;
          uint64_t v25 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
          goto LABEL_45;
        }
      }
    }
LABEL_47:
    if (v22) {
      free(v22);
    }
    uint64_t v21 = 0xFFFFFFFFLL;
    a1 = v64;
  }
  if (!(*(unsigned int (**)(uint64_t, void, uint64_t, uint64_t, uint64_t, _DWORD **))(*(void *)(v8 + 24)
                                                                                              + 88))(v8, *(void *)(v7 + 152), v21, v21, 0xFFFFFFFFLL, v82))
  {
LABEL_77:
    uint64_t v49 = 0;
LABEL_110:
    _Block_object_dispose(&v73, 8);
    _Block_object_dispose(&v77, 8);
    _Block_object_dispose(&v83, 8);
    return v49;
  }
  nw_http3_framer_claim_http3_frame_header(v16 + v20, v82[0]);
  v67[0] = MEMORY[0x1E4F143A8];
  v67[1] = 0x40000000;
  __int16 v68 = (uint64_t (*)(void *))___ZL37nw_http3_stream_send_pending_capsulesP24nw_protocol_http3_stream_block_invoke_2;
  uint64_t v69 = &unk_1E5247850;
  __int16 v70 = &v83;
  id v71 = &v73;
  __int16 v72 = &v77;
  uint64_t v29 = v78[5];
  do
  {
    if (!v29) {
      break;
    }
    uint64_t v30 = *(void *)(v29 + 32);
    char v31 = v68(v67);
    uint64_t v29 = v30;
  }
  while ((v31 & 1) != 0);
  if (v84[3])
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    unint64_t v90 = "nw_http3_stream_send_pending_capsules_block_invoke";
    uint64_t v32 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v88 = OS_LOG_TYPE_ERROR;
    char v87 = 0;
    if (!__nwlog_fault(v32, &v88, &v87)) {
      goto LABEL_75;
    }
    if (v88 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v33 = gLogObj;
      os_log_type_t v34 = v88;
      if (!os_log_type_enabled((os_log_t)gLogObj, v88)) {
        goto LABEL_75;
      }
      *(_DWORD *)buf = 136446210;
      unint64_t v90 = "nw_http3_stream_send_pending_capsules_block_invoke";
      __int16 v35 = "%{public}s Not enough space in capsule frames";
    }
    else
    {
      if (v87)
      {
        uint64_t v43 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v44 = gLogObj;
        os_log_type_t v45 = v88;
        BOOL v46 = os_log_type_enabled((os_log_t)gLogObj, v88);
        if (v43)
        {
          if (v46)
          {
            *(_DWORD *)buf = 136446466;
            unint64_t v90 = "nw_http3_stream_send_pending_capsules_block_invoke";
            __int16 v91 = 2082;
            int v92 = v43;
            _os_log_impl(&dword_1830D4000, v44, v45, "%{public}s Not enough space in capsule frames, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v43);
          goto LABEL_75;
        }
        if (!v46)
        {
LABEL_75:
          if (v32) {
            free(v32);
          }
          goto LABEL_77;
        }
        *(_DWORD *)buf = 136446210;
        unint64_t v90 = "nw_http3_stream_send_pending_capsules_block_invoke";
        __int16 v35 = "%{public}s Not enough space in capsule frames, no backtrace";
        int v47 = v44;
        os_log_type_t v48 = v45;
LABEL_74:
        _os_log_impl(&dword_1830D4000, v47, v48, v35, buf, 0xCu);
        goto LABEL_75;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v33 = gLogObj;
      os_log_type_t v34 = v88;
      if (!os_log_type_enabled((os_log_t)gLogObj, v88)) {
        goto LABEL_75;
      }
      *(_DWORD *)buf = 136446210;
      unint64_t v90 = "nw_http3_stream_send_pending_capsules_block_invoke";
      __int16 v35 = "%{public}s Not enough space in capsule frames, backtrace limit exceeded";
    }
    int v47 = v33;
    os_log_type_t v48 = v34;
    goto LABEL_74;
  }
  uint64_t v36 = *(void *)(a1 + 32);
  uint64_t v37 = *(void *)(v36 + 160);
  if (!v37 || (uint64_t v38 = *(void *)(v37 + 24)) == 0 || !*(void *)(v38 + 96))
  {
LABEL_107:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v61 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446722;
      unint64_t v90 = "nw_http3_stream_send_pending_capsules_block_invoke";
      __int16 v91 = 2048;
      int v92 = (const char *)v66;
      __int16 v93 = 2048;
      size_t v94 = size;
      _os_log_impl(&dword_1830D4000, v61, OS_LOG_TYPE_INFO, "%{public}s Sending capsule type 0x%llx length %zu", buf, 0x20u);
    }
    nw_array_append(*(void *)(a1 + 40), object);
    uint64_t v49 = 1;
    goto LABEL_110;
  }
  unsigned int v39 = *((_DWORD *)v74 + 6);
  int v40 = v78;
  if (v66 < 0x40)
  {
    uint64_t v41 = a1;
    int v42 = 1;
LABEL_88:
    if (v39 >> 30) {
      int v52 = 8;
    }
    else {
      int v52 = 4;
    }
    if (v39 >= 0x4000) {
      int v53 = v52;
    }
    else {
      int v53 = 2;
    }
    if (v39 >= 0x40) {
      int v54 = v53;
    }
    else {
      int v54 = 1;
    }
    unsigned int v55 = v54 + v42;
    unsigned int v56 = v54 + v42 + v39;
    if (v56 >> 30) {
      int v57 = 9;
    }
    else {
      int v57 = 5;
    }
    if (v56 >= 0x4000) {
      int v58 = v57;
    }
    else {
      int v58 = 3;
    }
    if (v56 >= 0x40) {
      unsigned int v59 = v58;
    }
    else {
      unsigned int v59 = 2;
    }
    uint64_t v60 = v40[5];
    nw_http3_framer_write_http3_frame_header(v36 + 128, v66, v39, v55, v60);
    nw_http3_framer_write_http3_frame_header(v36 + 128, 0, v56, v59, v60);
    (*(void (**)(uint64_t, uint64_t *))(*(void *)(v37 + 24) + 96))(v37, v40 + 5);
    a1 = v41;
    goto LABEL_107;
  }
  if (v66 < 0x4000)
  {
    uint64_t v41 = a1;
    int v42 = 2;
    goto LABEL_88;
  }
  if (!(v66 >> 30))
  {
    uint64_t v41 = a1;
    int v42 = 4;
    goto LABEL_88;
  }
  if (!(v66 >> 62))
  {
    uint64_t v41 = a1;
    int v42 = 8;
    goto LABEL_88;
  }
  os_log_type_t v50 = __nwlog_obj();
  os_log_type_enabled(v50, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  unint64_t v90 = "_http_vle_length";
  __int16 v91 = 2048;
  int v92 = (const char *)v66;
  uint64_t v51 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v51);
  if (!result)
  {
    uint64_t v41 = a1;
    free(v51);
    int v42 = 0;
    goto LABEL_88;
  }
LABEL_113:
  __break(1u);
  return result;
}

uint64_t ___ZL37nw_http3_stream_send_pending_capsulesP24nw_protocol_http3_stream_block_invoke_153(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return 1;
}

BOOL ___ZL37nw_http3_stream_send_pending_capsulesP24nw_protocol_http3_stream_block_invoke_2(void *a1, uint64_t a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if ((nw_frame_uses_external_data(a2) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    BOOL v28 = "nw_http3_stream_send_pending_capsules_block_invoke_2";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(offset) = 16;
    os_log_type_t offset_7 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v7, &offset, &offset_7))
    {
      if (offset == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v8 = gLogObj;
        os_log_type_t v9 = offset;
        if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)offset))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v28 = "nw_http3_stream_send_pending_capsules_block_invoke";
          int v10 = "%{public}s Capsule frame does not support external data";
LABEL_32:
          _os_log_impl(&dword_1830D4000, v8, v9, v10, buf, 0xCu);
        }
      }
      else if (offset_7)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v8 = gLogObj;
        os_log_type_t v9 = offset;
        BOOL v16 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)offset);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v28 = "nw_http3_stream_send_pending_capsules_block_invoke";
            __int16 v29 = 2082;
            uint64_t v30 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s Capsule frame does not support external data, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_33;
        }
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v28 = "nw_http3_stream_send_pending_capsules_block_invoke";
          int v10 = "%{public}s Capsule frame does not support external data, no backtrace";
          goto LABEL_32;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v8 = gLogObj;
        os_log_type_t v9 = offset;
        if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)offset))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v28 = "nw_http3_stream_send_pending_capsules_block_invoke";
          int v10 = "%{public}s Capsule frame does not support external data, backtrace limit exceeded";
          goto LABEL_32;
        }
      }
    }
LABEL_33:
    if (v7) {
      free(v7);
    }
    return 0;
  }
  unsigned int offset = 0;
  nw_frame_set_external_data(a2, *(dispatch_data_t *)(*(void *)(a1[4] + 8) + 24), &offset);
  unsigned int v4 = *(_DWORD *)(*(void *)(a1[5] + 8) + 24);
  unint64_t v5 = *(NSObject **)(*(void *)(a1[4] + 8) + 24);
  BOOL v6 = offset < v4;
  if (offset < v4)
  {
    if (v5)
    {
      dispatch_release(*(dispatch_object_t *)(*(void *)(a1[4] + 8) + 24));
      *(void *)(*(void *)(a1[4] + 8) + 24) = 0;
      *(void *)(*(void *)(a1[4] + 8) + 24) = dispatch_data_create_subrange(v5, offset, 0xFFFFFFFFFFFFFFFFLL);
      dispatch_release(v5);
    }
    else
    {
      *(void *)(*(void *)(a1[4] + 8) + 24) = dispatch_data_create_subrange(0, offset, 0xFFFFFFFFFFFFFFFFLL);
    }
    *(_DWORD *)(*(void *)(a1[5] + 8) + 24) -= offset;
    return v6;
  }
  if (v5)
  {
    dispatch_release(*(dispatch_object_t *)(*(void *)(a1[4] + 8) + 24));
    *(void *)(*(void *)(a1[4] + 8) + 24) = 0;
  }
  if (**(void **)(*(void *)(*(void *)(a1[6] + 8) + 48) + 8) != a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    BOOL v28 = "nw_http3_stream_send_pending_capsules_block_invoke";
    int v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t offset_7 = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (!__nwlog_fault(v11, &offset_7, &v24)) {
      goto LABEL_41;
    }
    if (offset_7 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v12 = gLogObj;
      os_log_type_t v13 = offset_7;
      if (!os_log_type_enabled((os_log_t)gLogObj, offset_7)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v28 = "nw_http3_stream_send_pending_capsules_block_invoke";
      int v14 = "%{public}s Too much space in capsule frames";
    }
    else
    {
      if (v24)
      {
        unsigned int v17 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v18 = gLogObj;
        os_log_type_t v19 = offset_7;
        BOOL v20 = os_log_type_enabled((os_log_t)gLogObj, offset_7);
        if (v17)
        {
          if (v20)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v28 = "nw_http3_stream_send_pending_capsules_block_invoke";
            __int16 v29 = 2082;
            uint64_t v30 = v17;
            _os_log_impl(&dword_1830D4000, v18, v19, "%{public}s Too much space in capsule frames, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v17);
          goto LABEL_41;
        }
        if (!v20)
        {
LABEL_41:
          if (v11) {
            free(v11);
          }
          return v6;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v28 = "nw_http3_stream_send_pending_capsules_block_invoke";
        int v14 = "%{public}s Too much space in capsule frames, no backtrace";
        __int16 v22 = v18;
        os_log_type_t v23 = v19;
LABEL_40:
        _os_log_impl(&dword_1830D4000, v22, v23, v14, buf, 0xCu);
        goto LABEL_41;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v12 = gLogObj;
      os_log_type_t v13 = offset_7;
      if (!os_log_type_enabled((os_log_t)gLogObj, offset_7)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v28 = "nw_http3_stream_send_pending_capsules_block_invoke";
      int v14 = "%{public}s Too much space in capsule frames, backtrace limit exceeded";
    }
    __int16 v22 = v12;
    os_log_type_t v23 = v13;
    goto LABEL_40;
  }
  return v6;
}

void nw_protocol_http3_capsule_frame_finalizer(nw_frame *a1, BOOL a2, void *a3)
{
  nw_frame_reset((uint64_t)a1, 0, 0, 0, 0);
  if (a1)
  {
    os_release(a1);
  }
}

uint64_t nw_protocol_http3_stream_get_output_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, uint64_t a5, nw_frame_array_s *a6)
{
  uint64_t v94 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_get_output_frames";
    os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v88 = 0;
    if (!__nwlog_fault(v13, &type, &v88)) {
      goto LABEL_83;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v72 = __nwlog_obj();
      os_log_type_t v73 = type;
      if (!os_log_type_enabled(v72, type)) {
        goto LABEL_83;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_get_output_frames";
      unsigned int v17 = "%{public}s called with null protocol";
      goto LABEL_127;
    }
    if (v88)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v72 = __nwlog_obj();
      os_log_type_t v73 = type;
      BOOL v79 = os_log_type_enabled(v72, type);
      if (backtrace_string)
      {
        if (v79)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_get_output_frames";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          int v47 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
          goto LABEL_118;
        }
LABEL_49:
        free(backtrace_string);
        goto LABEL_83;
      }
      if (!v79) {
        goto LABEL_83;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_get_output_frames";
      unsigned int v17 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      __int16 v72 = __nwlog_obj();
      os_log_type_t v73 = type;
      if (!os_log_type_enabled(v72, type)) {
        goto LABEL_83;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_get_output_frames";
      unsigned int v17 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_127:
    char v65 = v72;
    os_log_type_t v66 = v73;
    uint32_t v67 = 12;
LABEL_82:
    _os_log_impl(&dword_1830D4000, v65, v66, v17, buf, v67);
LABEL_83:
    if (v13) {
      free(v13);
    }
    return 0;
  }
  uint64_t handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_get_output_frames";
    os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v88 = 0;
    if (!__nwlog_fault(v13, &type, &v88)) {
      goto LABEL_83;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v72 = __nwlog_obj();
      os_log_type_t v73 = type;
      if (!os_log_type_enabled(v72, type)) {
        goto LABEL_83;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_get_output_frames";
      unsigned int v17 = "%{public}s called with null http3_stream";
      goto LABEL_127;
    }
    if (v88)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v72 = __nwlog_obj();
      os_log_type_t v73 = type;
      BOOL v80 = os_log_type_enabled(v72, type);
      if (backtrace_string)
      {
        if (v80)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_get_output_frames";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          int v47 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
LABEL_118:
          os_log_type_t v48 = v72;
          os_log_type_t v49 = v73;
          uint32_t v50 = 22;
LABEL_48:
          _os_log_impl(&dword_1830D4000, v48, v49, v47, buf, v50);
          goto LABEL_49;
        }
        goto LABEL_49;
      }
      if (!v80) {
        goto LABEL_83;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_get_output_frames";
      unsigned int v17 = "%{public}s called with null http3_stream, no backtrace";
    }
    else
    {
      __int16 v72 = __nwlog_obj();
      os_log_type_t v73 = type;
      if (!os_log_type_enabled(v72, type)) {
        goto LABEL_83;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_get_output_frames";
      unsigned int v17 = "%{public}s called with null http3_stream, backtrace limit exceeded";
    }
    goto LABEL_127;
  }
  if ((*((_WORD *)handle + 368) & 0x800) == 0)
  {
    if (gLogDatapath)
    {
      uint64_t v74 = __nwlog_obj();
      if (os_log_type_enabled(v74, OS_LOG_TYPE_DEBUG))
      {
        int v75 = *(_DWORD *)(*((void *)handle + 42) + 1280);
        uint64_t v76 = *((void *)handle + 30);
        int v77 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136447490;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_get_output_frames";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = handle + 636;
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&unsigned char buf[24] = " ";
        LOWORD(v91) = 1024;
        *(_DWORD *)((char *)&v91 + 2) = v75;
        WORD3(v91) = 2048;
        *((void *)&v91 + 1) = v76;
        __int16 v92 = 1024;
        int v93 = v77;
        _os_log_impl(&dword_1830D4000, v74, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called, state %u", buf, 0x36u);
      }
    }
  }
  uint64_t v11 = 0;
  switch(*((_DWORD *)handle + 92))
  {
    case 0:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v12 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_get_output_frames";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v12;
      os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v88 = 0;
      if (!__nwlog_fault(v13, &type, &v88)) {
        goto LABEL_83;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v14 = gLogObj;
        os_log_type_t v15 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_83;
        }
        int v16 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_get_output_frames";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v16;
        unsigned int v17 = "%{public}s Unexpected output state %d";
LABEL_81:
        char v65 = v14;
        os_log_type_t v66 = v15;
        uint32_t v67 = 18;
        goto LABEL_82;
      }
      if (!v88)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v14 = gLogObj;
        os_log_type_t v15 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_83;
        }
        int v63 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_get_output_frames";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v63;
        unsigned int v17 = "%{public}s Unexpected output state %d, backtrace limit exceeded";
        goto LABEL_81;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v14 = gLogObj;
      os_log_type_t v15 = type;
      BOOL v45 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (!backtrace_string)
      {
        if (!v45) {
          goto LABEL_83;
        }
        int v64 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_get_output_frames";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v64;
        unsigned int v17 = "%{public}s Unexpected output state %d, no backtrace";
        goto LABEL_81;
      }
      if (!v45) {
        goto LABEL_49;
      }
      int v46 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_get_output_frames";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v46;
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = backtrace_string;
      int v47 = "%{public}s Unexpected output state %d, dumping backtrace:%{public}s";
      os_log_type_t v48 = v14;
      os_log_type_t v49 = v15;
      uint32_t v50 = 28;
      goto LABEL_48;
    case 1:
      uint64_t v18 = *((void *)handle + 48);
      *(void *)(v18 + 32) = 0;
      tqh_last = a6->tqh_last;
      *(void *)(v18 + 40) = tqh_last;
      *tqh_last = (nw_frame *)v18;
      a6->tqh_last = (nw_frame **)(v18 + 32);
      *((_DWORD *)handle + 92) = 2;
      uint64_t v20 = *((void *)handle + 42);
      if (v20)
      {
        int v21 = *(unsigned __int16 *)(v20 + 1373);
        int v22 = v21 | (*(unsigned __int8 *)(v20 + 1375) << 16);
        if ((v21 & 1) == 0)
        {
          uint64_t v23 = *(void *)(v20 + 1024);
          if ((v22 & 0x100000) == 0 && !v23)
          {
            uint64_t v23 = *(void *)(v20 + 1240);
            if (v23)
            {
              if (*(_DWORD *)(v20 + 1276))
              {
                if ((v22 & 0x400000) == 0)
                {
                  char v24 = __nwlog_obj();
                  if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
                  {
                    int v25 = *(_DWORD *)(v20 + 1280);
                    *(_DWORD *)buf = 136446978;
                    *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_get_output_frames";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = v20 + 1289;
                    *(_WORD *)&unsigned char buf[22] = 2080;
                    *(void *)&unsigned char buf[24] = " ";
                    LOWORD(v91) = 1024;
                    *(_DWORD *)((char *)&v91 + 2) = v25;
                    _os_log_impl(&dword_1830D4000, v24, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> increasing QUIC keepalive frequency for requests", buf, 0x26u);
                  }
                }
                *(unsigned char *)(v20 + 1375) |= 0x10u;
                nw_quic_connection_set_keepalive(*(void **)(v20 + 1240), 2);
                uint64_t v23 = *(void *)(v20 + 1024);
              }
              else
              {
                uint64_t v23 = 0;
              }
            }
          }
          BOOL v28 = __CFADD__(v23, 1);
          uint64_t v68 = v23 + 1;
          uint64_t v69 = v28;
          uint64_t v70 = v69 << 63 >> 63;
          *(void *)(v20 + 1024) = v68;
          if (v70 != v69 || v70 < 0)
          {
            if (gLogDatapath)
            {
              id v86 = __nwlog_obj();
              if (os_log_type_enabled(v86, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v87 = *(void *)(v20 + 1024);
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_get_output_frames";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = "http3->outstanding_sent_requests";
                *(_WORD *)&unsigned char buf[22] = 2048;
                *(void *)&unsigned char buf[24] = 1;
                LOWORD(v91) = 2048;
                *(void *)((char *)&v91 + 2) = v87;
                _os_log_impl(&dword_1830D4000, v86, OS_LOG_TYPE_DEBUG, "%{public}s Overflow: %{public}s, increment %llu, result %llu", buf, 0x2Au);
              }
            }
            *(void *)(v20 + 1024) = -1;
          }
        }
        nw_http_connection_metadata_increment_outbound_message_count(*(void **)(v20 + 1248));
      }
      return 1;
    case 3:
      uint64_t v26 = *((void *)handle + 20);
      if (v26)
      {
        uint64_t v27 = *(void *)(v26 + 24);
        if (v27)
        {
          if (*(void *)(v27 + 88))
          {
            if (a3 < 0x40)
            {
              BOOL v28 = __CFADD__(a3, 2);
              uint64_t v29 = a3 + 2;
              if (!v28) {
                goto LABEL_63;
              }
LABEL_26:
              if (gLogDatapath)
              {
                long long v81 = __nwlog_obj();
                if (os_log_type_enabled(v81, OS_LOG_TYPE_DEBUG))
                {
                  if (v29 >= 0x40)
                  {
                    if (v29 >= 0x4000)
                    {
                      uint64_t v82 = 9;
                      if (!(v29 >> 30)) {
                        uint64_t v82 = 5;
                      }
                    }
                    else
                    {
                      uint64_t v82 = 3;
                    }
                  }
                  else
                  {
                    uint64_t v82 = 2;
                  }
                  *(_DWORD *)buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_http3_framer_get_output_frames_for_multiple_http3_frames";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = "minimum_bytes";
                  *(_WORD *)&unsigned char buf[22] = 2048;
                  *(void *)&unsigned char buf[24] = v82;
                  LOWORD(v91) = 2048;
                  *(void *)((char *)&v91 + 2) = v29;
                  _os_log_impl(&dword_1830D4000, v81, OS_LOG_TYPE_DEBUG, "%{public}s Overflow: %{public}s, increment %llu, result %llu", buf, 0x2Au);
                }
              }
              uint64_t v29 = 0xFFFFFFFFLL;
              if (a4 < 0x40)
              {
LABEL_64:
                BOOL v28 = __CFADD__(a4, 2);
                uint64_t v30 = a4 + 2;
                if (!v28) {
                  goto LABEL_68;
                }
                goto LABEL_66;
              }
LABEL_28:
              if (a4 >= 0x4000)
              {
                if (a4 >> 30) {
                  int v51 = 9;
                }
                else {
                  int v51 = 5;
                }
                BOOL v28 = __CFADD__(a4, v51);
                uint64_t v30 = a4 + v51;
                if (!v28)
                {
LABEL_68:
                  uint64_t v11 = (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t, uint64_t, nw_frame_array_s *))(*(void *)(v26 + 24) + 88))(v26, *((void *)handle + 19), v29, v30, a5, a6);
                  if (v11)
                  {
                    *(void *)buf = MEMORY[0x1E4F143A8];
                    *(void *)&buf[8] = 0x40000000;
                    *(void *)&buf[16] = ___ZL59nw_http3_framer_get_output_frames_for_multiple_http3_framesP15nw_http3_frameryjjjP16nw_frame_array_s_block_invoke;
                    *(void *)&unsigned char buf[24] = &__block_descriptor_tmp_166_62821;
                    *(void *)&long long v91 = 0;
                    *((void *)&v91 + 1) = handle + 128;
                    tqh_first = a6->tqh_first;
                    do
                    {
                      if (!tqh_first) {
                        break;
                      }
                      int v54 = (nw_frame *)*((void *)tqh_first + 4);
                      char v55 = (*(uint64_t (**)(unsigned char *))&buf[16])(buf);
                      tqh_first = v54;
                    }
                    while ((v55 & 1) != 0);
                  }
                  return v11;
                }
              }
              else
              {
                BOOL v28 = __CFADD__(a4, 3);
                uint64_t v30 = a4 + 3;
                if (!v28) {
                  goto LABEL_68;
                }
              }
LABEL_66:
              if (gLogDatapath)
              {
                uint64_t v83 = v29;
                uint64_t v84 = __nwlog_obj();
                if (os_log_type_enabled(v84, OS_LOG_TYPE_DEBUG))
                {
                  if (v30 >= 0x40)
                  {
                    if (v30 >= 0x4000)
                    {
                      uint64_t v85 = 9;
                      if (!(v30 >> 30)) {
                        uint64_t v85 = 5;
                      }
                    }
                    else
                    {
                      uint64_t v85 = 3;
                    }
                  }
                  else
                  {
                    uint64_t v85 = 2;
                  }
                  *(_DWORD *)buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_http3_framer_get_output_frames_for_multiple_http3_frames";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = "maximum_bytes";
                  *(_WORD *)&unsigned char buf[22] = 2048;
                  *(void *)&unsigned char buf[24] = v85;
                  LOWORD(v91) = 2048;
                  *(void *)((char *)&v91 + 2) = v30;
                  _os_log_impl(&dword_1830D4000, v84, OS_LOG_TYPE_DEBUG, "%{public}s Overflow: %{public}s, increment %llu, result %llu", buf, 0x2Au);
                }
                uint64_t v30 = 0xFFFFFFFFLL;
                uint64_t v29 = v83;
              }
              else
              {
                uint64_t v30 = 0xFFFFFFFFLL;
              }
              goto LABEL_68;
            }
            if (a3 >= 0x4000)
            {
              if (a3 >> 30) {
                int v52 = 9;
              }
              else {
                int v52 = 5;
              }
              BOOL v28 = __CFADD__(a3, v52);
              uint64_t v29 = a3 + v52;
              if (v28) {
                goto LABEL_26;
              }
            }
            else
            {
              BOOL v28 = __CFADD__(a3, 3);
              uint64_t v29 = a3 + 3;
              if (v28) {
                goto LABEL_26;
              }
            }
LABEL_63:
            if (a4 < 0x40) {
              goto LABEL_64;
            }
            goto LABEL_28;
          }
        }
      }
      uint64_t v78 = __nwlog_obj();
      if (!os_log_type_enabled(v78, OS_LOG_TYPE_ERROR)) {
        return 0;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_http3_framer_get_output_frames_for_multiple_http3_frames";
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = v26;
      unsigned int v59 = "%{public}s Output handler (%p)'s get_output_frames callback is not properly set";
      uint64_t v60 = v78;
      os_log_type_t v61 = OS_LOG_TYPE_ERROR;
      uint32_t v62 = 22;
      goto LABEL_109;
    case 5:
      uint64_t v31 = handle + 736;
      if (a5 && !a4 && (*((_WORD *)handle + 368) & 0x4000) != 0)
      {
        uint64_t v32 = nw_frame_create(0, 0, 0, (uint64_t)nw_protocol_http3_capsule_frame_finalizer, 0);
        *(void *)(v32 + 32) = 0;
        uint64_t v33 = a6->tqh_last;
        *(void *)(v32 + 40) = v33;
        *uint64_t v33 = (nw_frame *)v32;
        a6->tqh_last = (nw_frame **)(v32 + 32);
        uint64_t v11 = 1;
        if ((*v31 & 0x800) == 0)
        {
          if (gLogDatapath)
          {
            os_log_type_t v34 = __nwlog_obj();
            if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
            {
              int v35 = *(_DWORD *)(*((void *)handle + 42) + 1280);
              uint64_t v36 = *((void *)handle + 30);
              *(_DWORD *)buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_get_output_frames";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = handle + 636;
              *(_WORD *)&unsigned char buf[22] = 2080;
              *(void *)&unsigned char buf[24] = " ";
              LOWORD(v91) = 1024;
              *(_DWORD *)((char *)&v91 + 2) = v35;
              WORD3(v91) = 2048;
              *((void *)&v91 + 1) = v36;
              uint64_t v37 = "%{public}s %{public}s%s<i%u:s%llu> returning a metadata-only output frame";
              uint64_t v38 = v34;
              uint32_t v39 = 48;
LABEL_43:
              _os_log_impl(&dword_1830D4000, v38, OS_LOG_TYPE_DEBUG, v37, buf, v39);
              return v11;
            }
          }
        }
      }
      else
      {
        uint64_t v40 = *((void *)handle + 12);
        if (v40)
        {
          uint64_t v11 = (*(uint64_t (**)(void))(*(void *)(v40 + 24) + 88))();
          if ((*v31 & 0x800) == 0)
          {
            if (gLogDatapath)
            {
              uint64_t v41 = __nwlog_obj();
              if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
              {
                int v42 = *(_DWORD *)(*((void *)handle + 42) + 1280);
                uint64_t v43 = *((void *)handle + 30);
                *(_DWORD *)buf = 136447490;
                *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_get_output_frames";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = handle + 636;
                *(_WORD *)&unsigned char buf[22] = 2080;
                *(void *)&unsigned char buf[24] = " ";
                LOWORD(v91) = 1024;
                *(_DWORD *)((char *)&v91 + 2) = v42;
                WORD3(v91) = 2048;
                *((void *)&v91 + 1) = v43;
                __int16 v92 = 1024;
                int v93 = v11;
                uint64_t v37 = "%{public}s %{public}s%s<i%u:s%llu> returning %u output datagrams";
                uint64_t v38 = v41;
                uint32_t v39 = 54;
                goto LABEL_43;
              }
            }
          }
        }
        else
        {
          uint64_t v11 = 0;
          if ((*((_WORD *)handle + 368) & 0x800) == 0 && gLogDatapath)
          {
            unsigned int v56 = __nwlog_obj();
            if (!os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG)) {
              return 0;
            }
            int v57 = *(_DWORD *)(*((void *)handle + 42) + 1280);
            uint64_t v58 = *((void *)handle + 30);
            *(_DWORD *)buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_get_output_frames";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = handle + 636;
            *(_WORD *)&unsigned char buf[22] = 2080;
            *(void *)&unsigned char buf[24] = " ";
            LOWORD(v91) = 1024;
            *(_DWORD *)((char *)&v91 + 2) = v57;
            WORD3(v91) = 2048;
            *((void *)&v91 + 1) = v58;
            unsigned int v59 = "%{public}s %{public}s%s<i%u:s%llu> no datagram output handler";
            uint64_t v60 = v56;
            os_log_type_t v61 = OS_LOG_TYPE_DEBUG;
            uint32_t v62 = 48;
LABEL_109:
            _os_log_impl(&dword_1830D4000, v60, v61, v59, buf, v62);
            uint64_t v11 = 0;
          }
        }
      }
      break;
    default:
      return v11;
  }
  return v11;
}

BOOL ___ZL59nw_http3_framer_get_output_frames_for_multiple_http3_framesP15nw_http3_frameryjjjP16nw_frame_array_s_block_invoke(uint64_t a1, _DWORD *a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  v11[0] = 0;
  nw_frame_get_buffer((uint64_t)a2, v11);
  unint64_t v4 = *(void *)(a1 + 32);
  if (v4 >= 0x40)
  {
    if (v4 >= 0x4000)
    {
      if (v4 >> 30)
      {
        if (v4 >> 62)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
          v11[1] = 136446466;
          int v12 = "_http_vle_length";
          __int16 v13 = 2048;
          unint64_t v14 = v4;
          BOOL v6 = (void *)_os_log_send_and_compose_impl();
          BOOL result = __nwlog_abort((uint64_t)v6);
          if (result)
          {
            __break(1u);
            return result;
          }
          free(v6);
          int v5 = 0;
        }
        else
        {
          int v5 = 8;
        }
      }
      else
      {
        int v5 = 4;
      }
    }
    else
    {
      int v5 = 2;
    }
  }
  else
  {
    int v5 = 1;
  }
  if (v11[0] >> 30) {
    int v8 = 8;
  }
  else {
    int v8 = 4;
  }
  if (v11[0] >= 0x4000u) {
    int v9 = v8;
  }
  else {
    int v9 = 2;
  }
  if (v11[0] >= 0x40u) {
    int v10 = v9;
  }
  else {
    int v10 = 1;
  }
  nw_http3_framer_claim_http3_frame_header(v10 + v5, a2);
  return 1;
}

uint64_t nw_protocol_http3_stream_get_input_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  v181[2] = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t handle = (char *)a1->handle;
    if (handle)
    {
      if ((*((_WORD *)handle + 368) & 0x800) == 0)
      {
        if (gLogDatapath)
        {
          uint64_t v85 = __nwlog_obj();
          if (os_log_type_enabled(v85, OS_LOG_TYPE_DEBUG))
          {
            int v86 = *(_DWORD *)(*((void *)handle + 42) + 1280);
            uint64_t v87 = *((void *)handle + 30);
            *(_DWORD *)buf = 136447234;
            int v168 = "nw_protocol_http3_stream_get_input_frames";
            __int16 v169 = 2082;
            uint64_t v170 = handle + 636;
            __int16 v171 = 2080;
            os_log_type_t v172 = " ";
            __int16 v173 = 1024;
            int v174 = v86;
            __int16 v175 = 2048;
            uint64_t v176 = v87;
            _os_log_impl(&dword_1830D4000, v85, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called", buf, 0x30u);
          }
        }
      }
      uint64_t v8 = 0;
      uint64_t v105 = handle + 736;
      switch(*((_DWORD *)handle + 93))
      {
        case 0:
        case 1:
        case 5:
          uint64_t v9 = a3 + 1;
          uint64_t v10 = v9 << 31 >> 31;
          if (v10 >= 0 && v10 == v9) {
            int v12 = a3 + 1;
          }
          else {
            int v12 = -1;
          }
          uint64_t v13 = a4 + 0x20000;
          uint64_t v14 = v13 << 31 >> 31;
          if (v14 < 0 || v14 != v13) {
            LODWORD(v13) = -1;
          }
          a3 = v12;
          a4 = v13;
          goto LABEL_19;
        case 2:
        case 3:
        case 6:
        case 7:
          return v8;
        case 4:
          goto LABEL_19;
        case 8:
          uint64_t v28 = *((void *)handle + 47);
          if (v28)
          {
            *(void *)(v28 + 32) = 0;
            tqh_last = a6->tqh_last;
            *(void *)(v28 + 40) = tqh_last;
            *tqh_last = (nw_frame *)v28;
            a6->tqh_last = (nw_frame **)(v28 + 32);
            *((void *)handle + 47) = 0;
            return 1;
          }
          uint64_t v8 = 0;
          uint64_t v30 = (uint64_t)(handle + 128);
          unint64_t v100 = (uint64_t *)(handle + 216);
          uint64_t v31 = v121;
          break;
        default:
          a3 = 0;
          a4 = 0;
LABEL_19:
          *(void *)int v160 = 0;
          uint64_t v161 = v160;
          LODWORD(v163) = 0;
          uint64_t v162 = 0x2000000000;
          uint64_t v16 = *((void *)handle + 47);
          if (v16)
          {
            *(void *)(v16 + 32) = 0;
            unsigned int v17 = a6->tqh_last;
            *(void *)(v16 + 40) = v17;
            const char *v17 = (nw_frame *)v16;
            a6->tqh_last = (nw_frame **)(v16 + 32);
            ++*((_DWORD *)v161 + 6);
            *((void *)handle + 47) = 0;
          }
          uint64_t v156 = 0;
          int v157 = &v156;
          int v159 = 0;
          uint64_t v158 = 0x2000000000;
          do
          {
            v155[0] = -1;
            v153[0] = 0;
            LOBYTE(v145) = 0;
            LODWORD(v149) = 0;
            int input_frames = nw_http3_framer_get_input_frames((uint64_t)(handle + 128), a3, a4, a5, v155, v153, &v145, (uint64_t)&v149, (uint64_t)(handle + 216));
            if ((*v105 & 0x800) == 0)
            {
              if (gLogDatapath)
              {
                os_log_t log = __nwlog_obj();
                if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
                {
                  int v22 = *(_DWORD *)(*((void *)handle + 42) + 1280);
                  uint64_t v23 = *((void *)handle + 30);
                  int v24 = *((_DWORD *)handle + 93);
                  *(_DWORD *)buf = 136448514;
                  int v168 = "nw_protocol_http3_stream_get_input_frames";
                  __int16 v169 = 2082;
                  uint64_t v170 = handle + 636;
                  __int16 v171 = 2080;
                  os_log_type_t v172 = " ";
                  __int16 v173 = 1024;
                  int v174 = v22;
                  __int16 v175 = 2048;
                  uint64_t v176 = v23;
                  __int16 v177 = 1024;
                  *(_DWORD *)uint64_t v178 = input_frames;
                  *(_WORD *)&v178[4] = 1024;
                  *(_DWORD *)&v178[6] = v24;
                  *(_WORD *)&v178[10] = 2048;
                  *(void *)&v178[12] = v155[0];
                  *(_WORD *)&v178[20] = 2048;
                  *(void *)&v178[22] = v153[0];
                  __int16 v179 = 1024;
                  int v180 = v145;
                  _os_log_impl(&dword_1830D4000, log, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> read %u input frames, state %u type %llx length %llu complete %u", buf, 0x56u);
                }
              }
            }
            if (!input_frames) {
              break;
            }
            v107[0] = MEMORY[0x1E4F143A8];
            v107[1] = 0x40000000;
            __int16 v108 = ___ZL41nw_protocol_http3_stream_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_159;
            __int16 v109 = &unk_1E5247908;
            int v112 = handle;
            uint64_t v113 = v155[0];
            char v117 = v145;
            int v116 = v149;
            uint64_t v114 = v153[0];
            unint64_t v115 = a6;
            int v110 = &v156;
            uint64_t v111 = v160;
            uint64_t v19 = *((void *)handle + 27);
            do
            {
              if (!v19) {
                break;
              }
              uint64_t v20 = *(void *)(v19 + 32);
              char v21 = ((uint64_t (*)(void *))v108)(v107);
              uint64_t v19 = v20;
            }
            while ((v21 & 1) != 0);
          }
          while (!*((_DWORD *)v161 + 6) && !*((_DWORD *)v157 + 6));
          if ((*v105 & 0x800) == 0)
          {
            if (gLogDatapath)
            {
              __int16 v92 = __nwlog_obj();
              if (os_log_type_enabled(v92, OS_LOG_TYPE_DEBUG))
              {
                int v93 = *(_DWORD *)(*((void *)handle + 42) + 1280);
                uint64_t v94 = *((void *)handle + 30);
                int v95 = *((_DWORD *)v161 + 6);
                *(_DWORD *)buf = 136447490;
                int v168 = "nw_protocol_http3_stream_get_input_frames";
                __int16 v169 = 2082;
                uint64_t v170 = handle + 636;
                __int16 v171 = 2080;
                os_log_type_t v172 = " ";
                __int16 v173 = 1024;
                int v174 = v93;
                __int16 v175 = 2048;
                uint64_t v176 = v94;
                __int16 v177 = 1024;
                *(_DWORD *)uint64_t v178 = v95;
                _os_log_impl(&dword_1830D4000, v92, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> returning %u input frames", buf, 0x36u);
              }
            }
          }
          if ((*v105 & 0x100) != 0 && (*((_DWORD *)handle + 93) | 4) != 6)
          {
            uint64_t v25 = *((void *)handle + 41);
            uint64_t v26 = *(void **)(*((void *)handle + 42) + 1256);
            v106[0] = MEMORY[0x1E4F143A8];
            v106[1] = 0x40000000;
            v106[2] = ___ZL41nw_protocol_http3_stream_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_161;
            v106[3] = &unk_1E5247930;
            v106[4] = v25;
            v106[5] = handle;
            nw_queue_context_async(v26, v106);
          }
          uint64_t v8 = *((unsigned int *)v161 + 6);
          _Block_object_dispose(&v156, 8);
          _Block_object_dispose(v160, 8);
          return v8;
      }
      while (1)
      {
        uint64_t v32 = v31;
        uint64_t v165 = 0;
        uint64_t v166 = -1;
        unsigned __int8 v164 = 0;
        int v33 = nw_http3_framer_get_input_frames(v30, 1u, 0xFFFFFFFF, 0xFFFFFFFF, &v166, &v165, &v164, 0, (uint64_t)v100);
        if ((*v105 & 0x800) == 0)
        {
          if (gLogDatapath)
          {
            id v71 = __nwlog_obj();
            if (os_log_type_enabled(v71, OS_LOG_TYPE_DEBUG))
            {
              int v72 = *(_DWORD *)(*((void *)handle + 42) + 1280);
              uint64_t v73 = *((void *)handle + 30);
              *(_DWORD *)buf = 136448258;
              int v168 = "nw_protocol_http3_stream_get_input_frames";
              __int16 v169 = 2082;
              uint64_t v170 = handle + 636;
              __int16 v171 = 2080;
              os_log_type_t v172 = " ";
              __int16 v173 = 1024;
              int v174 = v72;
              __int16 v175 = 2048;
              uint64_t v176 = v73;
              __int16 v177 = 1024;
              *(_DWORD *)uint64_t v178 = v33;
              *(_WORD *)&v178[4] = 2048;
              *(void *)&v178[6] = v166;
              *(_WORD *)&v178[14] = 2048;
              *(void *)&v178[16] = v165;
              *(_WORD *)&v178[24] = 1024;
              *(_DWORD *)&v178[26] = v164;
              _os_log_impl(&dword_1830D4000, v71, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> read %u input frames on capsule stream, type %llx length %llu complete %u", buf, 0x50u);
            }
          }
        }
        if (!v33)
        {
          if (a5 > v8)
          {
            uint64_t v79 = *((void *)handle + 12);
            if (v79)
            {
              int v80 = (*(uint64_t (**)(void))(*(void *)(v79 + 24) + 80))();
              if ((*v105 & 0x800) == 0)
              {
                if (gLogDatapath)
                {
                  uint64_t v96 = __nwlog_obj();
                  if (os_log_type_enabled(v96, OS_LOG_TYPE_DEBUG))
                  {
                    int v97 = *(_DWORD *)(*((void *)handle + 42) + 1280);
                    uint64_t v98 = *((void *)handle + 30);
                    *(_DWORD *)buf = 136447490;
                    int v168 = "nw_protocol_http3_stream_get_input_frames";
                    __int16 v169 = 2082;
                    uint64_t v170 = handle + 636;
                    __int16 v171 = 2080;
                    os_log_type_t v172 = " ";
                    __int16 v173 = 1024;
                    int v174 = v97;
                    __int16 v175 = 2048;
                    uint64_t v176 = v98;
                    __int16 v177 = 1024;
                    *(_DWORD *)uint64_t v178 = v80;
                    _os_log_impl(&dword_1830D4000, v96, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> read %u input datagrams", buf, 0x36u);
                  }
                }
              }
              return (v80 + v8);
            }
          }
          return v8;
        }
        if (v164) {
          break;
        }
        uint64_t v31 = v32;
LABEL_44:
        if (v8 >= a5) {
          return v8;
        }
      }
      *(void *)int v160 = 0;
      uint64_t v161 = v160;
      uint64_t v162 = 0x2000000000;
      uint64_t v163 = 0;
      uint64_t v156 = 0;
      int v157 = &v156;
      uint64_t v158 = 0x2000000000;
      LOBYTE(v159) = 0;
      v181[0] = 0;
      v181[1] = 0;
      v155[0] = 0;
      v155[1] = v155;
      v155[2] = 0x2000000000;
      v155[3] = v181;
      v153[0] = 0;
      v153[1] = v153;
      v153[2] = 0x2000000000;
      __int16 v154 = 0;
      uint64_t v149 = 0;
      int v150 = &v149;
      uint64_t v151 = 0x2000000000;
      __int16 v152 = 0;
      uint64_t v145 = 0;
      int v146 = &v145;
      uint64_t v147 = 0x2000000000;
      uint64_t v148 = -1;
      uint64_t v141 = 0;
      BOOL v142 = &v141;
      uint64_t v143 = 0x2000000000;
      uint64_t v144 = 0;
      v128[0] = MEMORY[0x1E4F143A8];
      v128[1] = 0x40000000;
      uint64_t v129 = ___ZL41nw_protocol_http3_stream_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
      unsigned int v130 = &unk_1E52478B8;
      id v137 = handle;
      uint64_t v138 = v166;
      uint64_t v139 = v165;
      char v140 = 1;
      id v131 = &v156;
      uint64_t v132 = v153;
      BOOL v133 = v155;
      int v134 = &v145;
      v135 = &v149;
      int v136 = &v141;
      uint64_t v34 = *((void *)handle + 27);
      uint64_t v31 = v32;
      do
      {
        if (!v34) {
          break;
        }
        uint64_t v35 = *(void *)(v34 + 32);
        char v36 = ((uint64_t (*)(void *))v129)(v128);
        uint64_t v34 = v35;
      }
      while ((v36 & 1) != 0);
      if (!*((unsigned char *)v157 + 24))
      {
LABEL_89:
        if (*((void *)v161 + 3))
        {
          uint64_t v65 = nw_frame_create(0, 0, 0, (uint64_t)nw_protocol_http3_capsule_frame_finalizer, 0);
          metadata_for_capsule = nw_http_create_metadata_for_capsule(v146[3], *((void **)v161 + 3));
          nw_frame_set_metadata(v65, metadata_for_capsule, 1, 1);
          if (metadata_for_capsule) {
            os_release(metadata_for_capsule);
          }
          *(void *)(v65 + 32) = 0;
          uint32_t v67 = a6->tqh_last;
          *(void *)(v65 + 40) = v67;
          *uint32_t v67 = (nw_frame *)v65;
          a6->tqh_last = (nw_frame **)(v65 + 32);
          uint64_t v68 = *((void *)v161 + 3);
          if (v68)
          {
            dispatch_release(v68);
            *((void *)v161 + 3) = 0;
          }
          uint64_t v8 = (v8 + 1);
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v69 = gLogObj;
          uint64_t v30 = (uint64_t)(handle + 128);
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          {
            uint64_t v70 = (char *)v146[3];
            *(_DWORD *)buf = 136446466;
            int v168 = "nw_protocol_http3_stream_get_input_frames";
            __int16 v169 = 2048;
            uint64_t v170 = v70;
            _os_log_impl(&dword_1830D4000, v69, OS_LOG_TYPE_INFO, "%{public}s Receiving capsule type 0x%llx", buf, 0x16u);
          }
        }
        _Block_object_dispose(&v141, 8);
        _Block_object_dispose(&v145, 8);
        _Block_object_dispose(&v149, 8);
        _Block_object_dispose(v153, 8);
        _Block_object_dispose(v155, 8);
        _Block_object_dispose(&v156, 8);
        _Block_object_dispose(v160, 8);
        goto LABEL_44;
      }
      unsigned int v37 = 0;
      unsigned int v38 = *((_DWORD *)v142 + 6) + *((unsigned __int16 *)v150 + 12);
      uint64_t v39 = *v100;
      while (v39)
      {
        int v43 = *(_DWORD *)(v39 + 52);
        if (v43) {
          v43 -= *(_DWORD *)(v39 + 56) + *(_DWORD *)(v39 + 60);
        }
        uint64_t v39 = *(void *)(v39 + 32);
        BOOL v40 = __CFADD__(v37, v43);
        unsigned int v41 = v37 + v43;
        v37 += v43;
        if (v40) {
          unsigned int v42 = -1;
        }
        else {
          unsigned int v42 = v41;
        }
        if (v42 >= v38) {
          goto LABEL_63;
        }
      }
      if (v37 < v38) {
        goto LABEL_89;
      }
LABEL_63:
      v126[0] = 0;
      v126[1] = v126;
      v126[2] = 0x2000000000;
      __int16 v127 = 0;
      __int16 v127 = *((_WORD *)v150 + 12);
      uint64_t v122 = 0;
      unint64_t v123 = &v122;
      uint64_t v124 = 0x2000000000;
      uint64_t v125 = 0;
      uint64_t v125 = v142[3];
      if ((*v105 & 0x800) == 0)
      {
        if (gLogDatapath)
        {
          uint64_t v74 = __nwlog_obj();
          if (os_log_type_enabled(v74, OS_LOG_TYPE_DEBUG))
          {
            int v75 = *(_DWORD *)(*((void *)handle + 42) + 1280);
            uint64_t v76 = *((void *)handle + 30);
            uint64_t v77 = v146[3];
            uint64_t v78 = v142[3];
            *(_DWORD *)buf = 136447746;
            int v168 = "nw_protocol_http3_stream_get_input_frames";
            __int16 v169 = 2082;
            uint64_t v170 = handle + 636;
            __int16 v171 = 2080;
            os_log_type_t v172 = " ";
            __int16 v173 = 1024;
            int v174 = v75;
            __int16 v175 = 2048;
            uint64_t v176 = v76;
            __int16 v177 = 2048;
            *(void *)uint64_t v178 = v77;
            *(_WORD *)&v178[8] = 2048;
            *(void *)&v178[10] = v78;
            _os_log_impl(&dword_1830D4000, v74, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> Receiving capsule type 0x%llx length %llu", buf, 0x44u);
          }
        }
      }
      v120[0] = MEMORY[0x1E4F143A8];
      v120[1] = 0x40000000;
      v121[0] = ___ZL41nw_protocol_http3_stream_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_157;
      v121[1] = &unk_1E52478E0;
      v121[5] = handle;
      v121[6] = a1;
      v121[2] = v126;
      v121[3] = &v122;
      v121[4] = v160;
      uint64_t v44 = *((void *)handle + 27);
      do
      {
        if (!v44) {
          break;
        }
        uint64_t v45 = *(void *)(v44 + 32);
        char v46 = ((uint64_t (*)(void *))v121[0])(v120);
        uint64_t v44 = v45;
      }
      while ((v46 & 1) != 0);
      if (!*((void *)v161 + 3) || !v123[3])
      {
LABEL_88:
        _Block_object_dispose(&v122, 8);
        _Block_object_dispose(v126, 8);
        goto LABEL_89;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v47 = (char *)v123[3];
      *(_DWORD *)buf = 136446466;
      int v168 = "nw_protocol_http3_stream_get_input_frames";
      __int16 v169 = 2048;
      uint64_t v170 = v47;
      os_log_type_t v48 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v118 = 0;
      if (__nwlog_fault(v48, &type, &v118))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v49 = gLogObj;
          os_log_type_t v50 = type;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            int v51 = (char *)v123[3];
            *(_DWORD *)buf = 136446466;
            int v168 = "nw_protocol_http3_stream_get_input_frames";
            __int16 v169 = 2048;
            uint64_t v170 = v51;
            int v52 = v49;
            os_log_type_t v53 = v50;
            int v54 = "%{public}s Read capsule data, but still have remaining length %llu";
LABEL_83:
            _os_log_impl(&dword_1830D4000, v52, v53, v54, buf, 0x16u);
          }
        }
        else if (v118)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          unsigned int v56 = __nwlog_obj();
          os_log_type_t v57 = type;
          BOOL v58 = os_log_type_enabled(v56, type);
          if (backtrace_string)
          {
            if (v58)
            {
              unsigned int v59 = (char *)v123[3];
              *(_DWORD *)buf = 136446722;
              int v168 = "nw_protocol_http3_stream_get_input_frames";
              __int16 v169 = 2048;
              uint64_t v170 = v59;
              __int16 v171 = 2082;
              os_log_type_t v172 = backtrace_string;
              _os_log_impl(&dword_1830D4000, v56, v57, "%{public}s Read capsule data, but still have remaining length %llu, dumping backtrace:%{public}s", buf, 0x20u);
            }
            free(backtrace_string);
            goto LABEL_84;
          }
          if (v58)
          {
            int v63 = (char *)v123[3];
            *(_DWORD *)buf = 136446466;
            int v168 = "nw_protocol_http3_stream_get_input_frames";
            __int16 v169 = 2048;
            uint64_t v170 = v63;
            int v52 = v56;
            os_log_type_t v53 = v57;
            int v54 = "%{public}s Read capsule data, but still have remaining length %llu, no backtrace";
            goto LABEL_83;
          }
        }
        else
        {
          uint64_t v60 = __nwlog_obj();
          os_log_type_t v61 = type;
          if (os_log_type_enabled(v60, type))
          {
            uint32_t v62 = (char *)v123[3];
            *(_DWORD *)buf = 136446466;
            int v168 = "nw_protocol_http3_stream_get_input_frames";
            __int16 v169 = 2048;
            uint64_t v170 = v62;
            int v52 = v60;
            os_log_type_t v53 = v61;
            int v54 = "%{public}s Read capsule data, but still have remaining length %llu, backtrace limit exceeded";
            goto LABEL_83;
          }
        }
      }
LABEL_84:
      if (v48) {
        free(v48);
      }
      int v64 = *((void *)v161 + 3);
      uint64_t v30 = (uint64_t)(handle + 128);
      uint64_t v31 = v32;
      if (v64)
      {
        dispatch_release(v64);
        *((void *)v161 + 3) = 0;
      }
      goto LABEL_88;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v168 = "nw_protocol_http3_stream_get_input_frames";
    long long v81 = (char *)_os_log_send_and_compose_impl();
    v160[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v156) = 0;
    if (!__nwlog_fault(v81, v160, &v156)) {
      goto LABEL_136;
    }
    if (v160[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v82 = __nwlog_obj();
      os_log_type_t v83 = v160[0];
      if (os_log_type_enabled(v82, v160[0]))
      {
        *(_DWORD *)buf = 136446210;
        int v168 = "nw_protocol_http3_stream_get_input_frames";
        uint64_t v84 = "%{public}s called with null http3_stream";
        goto LABEL_135;
      }
      goto LABEL_136;
    }
    if (!(_BYTE)v156)
    {
      uint64_t v82 = __nwlog_obj();
      os_log_type_t v83 = v160[0];
      if (os_log_type_enabled(v82, v160[0]))
      {
        *(_DWORD *)buf = 136446210;
        int v168 = "nw_protocol_http3_stream_get_input_frames";
        uint64_t v84 = "%{public}s called with null http3_stream, backtrace limit exceeded";
        goto LABEL_135;
      }
      goto LABEL_136;
    }
    char v88 = (char *)__nw_create_backtrace_string();
    uint64_t v82 = __nwlog_obj();
    os_log_type_t v83 = v160[0];
    BOOL v91 = os_log_type_enabled(v82, v160[0]);
    if (!v88)
    {
      if (v91)
      {
        *(_DWORD *)buf = 136446210;
        int v168 = "nw_protocol_http3_stream_get_input_frames";
        uint64_t v84 = "%{public}s called with null http3_stream, no backtrace";
        goto LABEL_135;
      }
      goto LABEL_136;
    }
    if (v91)
    {
      *(_DWORD *)buf = 136446466;
      int v168 = "nw_protocol_http3_stream_get_input_frames";
      __int16 v169 = 2082;
      uint64_t v170 = v88;
      unint64_t v90 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
      goto LABEL_123;
    }
    goto LABEL_124;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v168 = "nw_protocol_http3_stream_get_input_frames";
  long long v81 = (char *)_os_log_send_and_compose_impl();
  v160[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v156) = 0;
  if (!__nwlog_fault(v81, v160, &v156)) {
    goto LABEL_136;
  }
  if (v160[0] != OS_LOG_TYPE_FAULT)
  {
    if (!(_BYTE)v156)
    {
      uint64_t v82 = __nwlog_obj();
      os_log_type_t v83 = v160[0];
      if (os_log_type_enabled(v82, v160[0]))
      {
        *(_DWORD *)buf = 136446210;
        int v168 = "nw_protocol_http3_stream_get_input_frames";
        uint64_t v84 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_135;
      }
      goto LABEL_136;
    }
    char v88 = (char *)__nw_create_backtrace_string();
    uint64_t v82 = __nwlog_obj();
    os_log_type_t v83 = v160[0];
    BOOL v89 = os_log_type_enabled(v82, v160[0]);
    if (!v88)
    {
      if (v89)
      {
        *(_DWORD *)buf = 136446210;
        int v168 = "nw_protocol_http3_stream_get_input_frames";
        uint64_t v84 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_135;
      }
      goto LABEL_136;
    }
    if (v89)
    {
      *(_DWORD *)buf = 136446466;
      int v168 = "nw_protocol_http3_stream_get_input_frames";
      __int16 v169 = 2082;
      uint64_t v170 = v88;
      unint64_t v90 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_123:
      _os_log_impl(&dword_1830D4000, v82, v83, v90, buf, 0x16u);
    }
LABEL_124:
    free(v88);
    goto LABEL_136;
  }
  uint64_t v82 = __nwlog_obj();
  os_log_type_t v83 = v160[0];
  if (os_log_type_enabled(v82, v160[0]))
  {
    *(_DWORD *)buf = 136446210;
    int v168 = "nw_protocol_http3_stream_get_input_frames";
    uint64_t v84 = "%{public}s called with null protocol";
LABEL_135:
    _os_log_impl(&dword_1830D4000, v82, v83, v84, buf, 0xCu);
  }
LABEL_136:
  if (v81) {
    free(v81);
  }
  return 0;
}

BOOL ___ZL41nw_protocol_http3_stream_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 80);
  if (*(unsigned char *)(a1 + 104)) {
    BOOL v5 = *(void *)(v4 + 216) == 0;
  }
  else {
    BOOL v5 = 0;
  }
  if (*(_DWORD *)(v4 + 372) != 8)
  {
    if ((*(_WORD *)(v4 + 736) & 0x800) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v8 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        int v9 = *(_DWORD *)(*(void *)(v4 + 336) + 1280);
        uint64_t v10 = *(void *)(v4 + 240);
        int v11 = *(_DWORD *)(v4 + 372);
        *(_DWORD *)buf = 136447490;
        uint64_t v45 = "nw_http3_stream_frame_received_for_capsule";
        __int16 v46 = 2082;
        int v47 = (char *)(v4 + 636);
        __int16 v48 = 2080;
        uint64_t v49 = " ";
        __int16 v50 = 1024;
        int v51 = v9;
        __int16 v52 = 2048;
        uint64_t v53 = v10;
        __int16 v54 = 1024;
        LODWORD(v55) = v11;
        _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%llu> processing capsule data in incorrect state %u", buf, 0x36u);
      }
    }
    return 0;
  }
  unint64_t v6 = *(void *)(a1 + 88);
  if ((*(_WORD *)(v4 + 736) & 0x800) == 0)
  {
    if (gLogDatapath)
    {
      uint64_t v28 = *(void *)(a1 + 96);
      uint64_t v29 = __nwlog_obj();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
      {
        int v30 = *(_DWORD *)(*(void *)(v4 + 336) + 1280);
        uint64_t v31 = *(void *)(v4 + 240);
        *(_DWORD *)buf = 136448002;
        uint64_t v45 = "nw_http3_stream_frame_received_for_capsule";
        __int16 v46 = 2082;
        int v47 = (char *)(v4 + 636);
        __int16 v48 = 2080;
        uint64_t v49 = " ";
        __int16 v50 = 1024;
        int v51 = v30;
        __int16 v52 = 2048;
        uint64_t v53 = v31;
        __int16 v54 = 2048;
        unint64_t v55 = v6;
        __int16 v56 = 2048;
        uint64_t v57 = v28;
        __int16 v58 = 1024;
        BOOL v59 = v5;
        _os_log_impl(&dword_1830D4000, v29, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> received frame type %llu, length %llu, complete %{BOOL}d", buf, 0x4Au);
      }
    }
  }
  if (v6 > 0xD) {
    goto LABEL_15;
  }
  if (((1 << v6) & 0x2098) != 0)
  {
LABEL_16:
    nw_http3_fail_all_streams(*(void *)(v4 + 336), 261);
    return 0;
  }
  if (v6)
  {
    if (v6 == 1)
    {
      uint64_t v7 = 0;
      *(_DWORD *)(v4 + 372) = 5;
      return v7;
    }
LABEL_15:
    if (v6 == 4287504053) {
      goto LABEL_16;
    }
    if ((*(_WORD *)(v4 + 736) & 0x800) == 0)
    {
      if (gLogDatapath)
      {
        uint64_t v32 = __nwlog_obj();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
        {
          int v33 = *(_DWORD *)(*(void *)(v4 + 336) + 1280);
          uint64_t v34 = *(void *)(v4 + 240);
          *(_DWORD *)buf = 136447234;
          uint64_t v45 = "nw_http3_stream_frame_received_for_capsule";
          __int16 v46 = 2082;
          int v47 = (char *)(v4 + 636);
          __int16 v48 = 2080;
          uint64_t v49 = " ";
          __int16 v50 = 1024;
          int v51 = v33;
          __int16 v52 = 2048;
          uint64_t v53 = v34;
          _os_log_impl(&dword_1830D4000, v32, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> dropping unknown frame type", buf, 0x30u);
        }
      }
    }
    nw_frame_finalize(a2);
  }
  unsigned int v41 = 0;
  uint64_t v13 = (const void *)nw_frame_unclaimed_bytes(a2, &v41);
  if (v13)
  {
    if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
      return *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
    }
    uint64_t v16 = *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    if (16 - v16 >= (unint64_t)v41) {
      size_t v17 = v41;
    }
    else {
      size_t v17 = 16 - v16;
    }
    memcpy((void *)(*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) + v16), v13, v17);
    *(_WORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) += v17;
    uint64_t v18 = *(_DWORD **)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
    if (v18)
    {
      uint64_t v19 = *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
      if (*(_WORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24))
      {
        unint64_t v20 = *(unsigned __int8 *)v18;
        if (v20 > 0x3F)
        {
          unsigned int v26 = v20 >> 6;
          if (v26 == 2)
          {
            if (v19 < 4) {
              return *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
            }
            unint64_t v20 = bswap32(*v18 & 0xFFFFFF7F);
            unsigned int v21 = 4;
          }
          else if (v26 == 1)
          {
            if (v19 < 2) {
              return *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
            }
            unint64_t v20 = bswap32(*(_WORD *)v18 & 0xFFBF) >> 16;
            unsigned int v21 = 2;
          }
          else
          {
            if (v19 < 8) {
              return *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
            }
            unint64_t v20 = bswap64(*(void *)v18 & 0xFFFFFFFFFFFFFF3FLL);
            unsigned int v21 = 8;
          }
        }
        else
        {
          unsigned int v21 = 1;
        }
        *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = v20;
        uint64_t v22 = v21;
        *(_WORD *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = v21;
        unint64_t v23 = v19 - v21;
        if (v23)
        {
          unint64_t v24 = *((unsigned __int8 *)v18 + v22);
          if (v24 > 0x3F)
          {
            unsigned int v27 = v24 >> 6;
            if (v27 == 2)
            {
              if (v23 < 4) {
                return *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
              }
              unint64_t v24 = bswap32(*(_DWORD *)((char *)v18 + v22) & 0xFFFFFF7F);
              __int16 v25 = 4;
            }
            else if (v27 == 1)
            {
              if (v23 < 2) {
                return *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
              }
              unint64_t v24 = bswap32(*(_WORD *)((unsigned char *)v18 + v22) & 0xFFBF) >> 16;
              __int16 v25 = 2;
            }
            else
            {
              if (v23 < 8) {
                return *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
              }
              unint64_t v24 = bswap64(*(void *)((unsigned char *)v18 + v22) & 0xFFFFFFFFFFFFFF3FLL);
              __int16 v25 = 8;
            }
          }
          else
          {
            __int16 v25 = 1;
          }
          uint64_t v7 = 0;
          *(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) = v24;
          *(_WORD *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) += v25;
          *(_WORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
          *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
          return v7;
        }
      }
      return *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v45 = "_http_vle_decode";
    uint64_t v35 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (__nwlog_fault(v35, &type, &v42))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v36 = __nwlog_obj();
        os_log_type_t v37 = type;
        if (!os_log_type_enabled(v36, type)) {
          goto LABEL_74;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v45 = "_http_vle_decode";
        unsigned int v38 = "%{public}s called with null *buffer";
        goto LABEL_73;
      }
      if (!v42)
      {
        char v36 = __nwlog_obj();
        os_log_type_t v37 = type;
        if (!os_log_type_enabled(v36, type)) {
          goto LABEL_74;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v45 = "_http_vle_decode";
        unsigned int v38 = "%{public}s called with null *buffer, backtrace limit exceeded";
        goto LABEL_73;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v36 = __nwlog_obj();
      os_log_type_t v37 = type;
      BOOL v40 = os_log_type_enabled(v36, type);
      if (backtrace_string)
      {
        if (v40)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v45 = "_http_vle_decode";
          __int16 v46 = 2082;
          int v47 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v36, v37, "%{public}s called with null *buffer, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_74;
      }
      if (v40)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v45 = "_http_vle_decode";
        unsigned int v38 = "%{public}s called with null *buffer, no backtrace";
LABEL_73:
        _os_log_impl(&dword_1830D4000, v36, v37, v38, buf, 0xCu);
      }
    }
LABEL_74:
    if (v35) {
      free(v35);
    }
    return *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
  }
  uint64_t v14 = *(void *)(a2 + 32);
  uint64_t v15 = *(void **)(a2 + 40);
  if (v14)
  {
    *(void *)(v14 + 40) = v15;
    uint64_t v15 = *(void **)(a2 + 40);
  }
  else
  {
    *(void *)(*(void *)(a1 + 80) + 224) = v15;
  }
  *uint64_t v15 = v14;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  uint64_t v7 = 1;
  nw_frame_finalize(a2);
  return v7;
}

BOOL ___ZL41nw_protocol_http3_stream_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_157(void *a1, uint64_t a2)
{
  LODWORD(size) = 0;
  uint64_t v4 = (const void *)nw_frame_unclaimed_bytes(a2, &size);
  uint64_t v6 = *(void *)(a1[4] + 8);
  unsigned int v7 = *(unsigned __int16 *)(v6 + 24);
  if (*(_WORD *)(v6 + 24))
  {
    if (size < v7)
    {
      *(_WORD *)(v6 + 24) = v7 - size;
      uint64_t v8 = *(void *)(a2 + 32);
      int v9 = *(void **)(a2 + 40);
      if (v8)
      {
        *(void *)(v8 + 40) = v9;
        int v9 = *(void **)(a2 + 40);
      }
      else
      {
        *(void *)(a1[7] + 224) = v9;
      }
      void *v9 = v8;
      *(void *)(a2 + 32) = 0;
      *(void *)(a2 + 40) = 0;
      uint64_t v19 = 1;
      nw_frame_finalize(a2);
      return v19;
    }
    nw_frame_claim(a2, v5, v7, 0);
    uint64_t v4 = (const void *)nw_frame_unclaimed_bytes(a2, &size);
    *(_WORD *)(*(void *)(a1[4] + 8) + 24) = 0;
  }
  uint64_t v10 = *(void *)(a1[5] + 8);
  size_t v11 = *(void *)(v10 + 24);
  if (!v11) {
    return 0;
  }
  size_t v12 = size;
  if (v11 <= size)
  {
    dispatch_data_t v20 = dispatch_data_create(v4, v11, 0, 0);
    if (v20)
    {
      uint64_t v22 = v20;
      uint64_t v23 = *(void *)(a1[6] + 8);
      unint64_t v24 = *(NSObject **)(v23 + 24);
      if (v24)
      {
        dispatch_data_t concat = dispatch_data_create_concat(v24, v22);
        unsigned int v26 = *(NSObject **)(*(void *)(a1[6] + 8) + 24);
        if (v26)
        {
          dispatch_release(v26);
          *(void *)(*(void *)(a1[6] + 8) + 24) = 0;
        }
        dispatch_release(v22);
        *(void *)(*(void *)(a1[6] + 8) + 24) = concat;
      }
      else
      {
        *(void *)(v23 + 24) = v22;
      }
    }
    nw_frame_claim(a2, v21, *(_DWORD *)(*(void *)(a1[5] + 8) + 24), 0);
    uint64_t v19 = 0;
    *(void *)(*(void *)(a1[5] + 8) + 24) = 0;
  }
  else
  {
    *(void *)(v10 + 24) = v11 - size;
    dispatch_data_t v13 = dispatch_data_create(v4, v12, 0, 0);
    if (v13)
    {
      uint64_t v14 = v13;
      uint64_t v15 = *(void *)(a1[6] + 8);
      uint64_t v16 = *(NSObject **)(v15 + 24);
      if (v16)
      {
        dispatch_data_t v17 = dispatch_data_create_concat(v16, v14);
        uint64_t v18 = *(NSObject **)(*(void *)(a1[6] + 8) + 24);
        if (v18)
        {
          dispatch_release(v18);
          *(void *)(*(void *)(a1[6] + 8) + 24) = 0;
        }
        dispatch_release(v14);
        *(void *)(*(void *)(a1[6] + 8) + 24) = v17;
      }
      else
      {
        *(void *)(v15 + 24) = v14;
      }
    }
    uint64_t v27 = *(void *)(a2 + 32);
    uint64_t v28 = *(void **)(a2 + 40);
    if (v27)
    {
      *(void *)(v27 + 40) = v28;
      uint64_t v28 = *(void **)(a2 + 40);
    }
    else
    {
      *(void *)(a1[7] + 224) = v28;
    }
    *uint64_t v28 = v27;
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = 0;
    nw_frame_finalize(a2);
    return *(void *)(*(void *)(a1[5] + 8) + 24) != 0;
  }
  return v19;
}

BOOL ___ZL41nw_protocol_http3_stream_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_159(uint64_t a1, uint64_t a2)
{
  uint64_t v137 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 48);
  if (!v4 || (*(_WORD *)(v4 + 736) & 0x800) == 0)
  {
    if (gLogDatapath)
    {
      BOOL v59 = __nwlog_obj();
      if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v60 = *(void *)(a1 + 48);
        os_log_type_t v61 = (const char *)(v60 + 636);
        uint32_t v62 = "";
        BOOL v63 = v60 == 0;
        if (!v60) {
          os_log_type_t v61 = "";
        }
        int v64 = *(_DWORD *)(*(void *)(v60 + 336) + 1280);
        uint64_t v65 = *(void *)(v60 + 240);
        if (!v63) {
          uint32_t v62 = " ";
        }
        *(_DWORD *)buf = 136447490;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_get_input_frames_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v61;
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&unsigned char buf[24] = v62;
        LOWORD(v130) = 1024;
        *(_DWORD *)((char *)&v130 + 2) = v64;
        HIWORD(v130) = 2048;
        uint64_t v131 = v65;
        __int16 v132 = 2048;
        *(void *)BOOL v133 = a2;
        _os_log_impl(&dword_1830D4000, v59, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> processing frame %p", buf, 0x3Au);
      }
    }
  }
  uint64_t v5 = *(void *)(a2 + 32);
  uint64_t v6 = *(void **)(a2 + 40);
  unsigned int v7 = (void *)(a2 + 32);
  if (v5)
  {
    *(void *)(v5 + 40) = v6;
    uint64_t v6 = *(void **)(a2 + 40);
  }
  else
  {
    *(void *)(*(void *)(a1 + 48) + 224) = v6;
  }
  *uint64_t v6 = v5;
  void *v7 = 0;
  *(void *)(a2 + 40) = 0;
  int is_metadata_complete = nw_frame_is_metadata_complete(a2);
  int v9 = is_metadata_complete;
  uint64_t v10 = *(void *)(a1 + 48);
  unint64_t v11 = *(void *)(a1 + 56);
  unint64_t v12 = *(void *)(a1 + 64);
  if (*(unsigned char *)(a1 + 84))
  {
    BOOL v13 = *(void *)(v10 + 216) == 0;
    uint64_t v14 = (void **)(a1 + 72);
    uint64_t v15 = *(void *)(a1 + 72);
    unsigned int v16 = *(_DWORD *)(a1 + 80);
    dispatch_data_t v17 = (_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    BOOL v18 = v10 == 0;
  }
  else
  {
    BOOL v18 = 0;
    uint64_t v14 = (void **)(a1 + 72);
    uint64_t v15 = *(void *)(a1 + 72);
    unsigned int v16 = *(_DWORD *)(a1 + 80);
    dispatch_data_t v17 = (_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    if (!v10)
    {
      int v19 = 1;
      goto LABEL_12;
    }
    BOOL v13 = 0;
  }
  int v19 = v18;
  BOOL v18 = v13;
  if ((*(_WORD *)(v10 + 736) & 0x800) != 0) {
    goto LABEL_13;
  }
LABEL_12:
  if (!gLogDatapath)
  {
LABEL_13:
    if (v11 > 0xD) {
      goto LABEL_87;
    }
    goto LABEL_14;
  }
  unsigned int v124 = v16;
  unint64_t v121 = *(void *)(a1 + 64);
  int v126 = is_metadata_complete;
  object = __nwlog_obj();
  if (os_log_type_enabled(object, OS_LOG_TYPE_DEBUG))
  {
    os_log_type_t v66 = (const char *)(v10 + 636);
    uint32_t v67 = "";
    int v68 = *(_DWORD *)(*(void *)(v10 + 336) + 1280);
    uint64_t v69 = *(void *)(v10 + 240);
    if (v19) {
      os_log_type_t v66 = "";
    }
    else {
      uint32_t v67 = " ";
    }
    *(_DWORD *)buf = 136448002;
    *(void *)&uint8_t buf[4] = "nw_http3_stream_frame_received";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v66;
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&unsigned char buf[24] = v67;
    LOWORD(v130) = 1024;
    *(_DWORD *)((char *)&v130 + 2) = v68;
    HIWORD(v130) = 2048;
    uint64_t v131 = v69;
    __int16 v132 = 2048;
    *(void *)BOOL v133 = v11;
    *(_WORD *)&v133[8] = 2048;
    unint64_t v134 = v121;
    __int16 v135 = 1024;
    BOOL v136 = v18;
    _os_log_impl(&dword_1830D4000, object, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> received frame type %llu, length %llu, complete %{BOOL}d", buf, 0x4Au);
    unint64_t v12 = v121;
    int v9 = v126;
  }
  else
  {
    int v9 = v126;
    unint64_t v12 = v121;
  }
  unsigned int v16 = v124;
  if (v11 > 0xD) {
    goto LABEL_87;
  }
LABEL_14:
  if (((1 << v11) & 0x2098) != 0)
  {
LABEL_88:
    int v70 = v9;
    nw_http3_fail_all_streams(*(void *)(v10 + 336), 261);
    int v9 = v70;
    int v47 = 2;
    p_cache = (void **)(NWConcrete_nw_resolution_report + 16);
    goto LABEL_95;
  }
  if (v11)
  {
    if (v11 == 1)
    {
      p_cache = (void **)(NWConcrete_nw_resolution_report + 16);
      int v125 = v9;
      switch(*(_DWORD *)(v10 + 372))
      {
        case 0:
          unsigned int v42 = v16;
          unint64_t v43 = v12;
          *(_DWORD *)(v10 + 372) = 1;
          uint64_t v44 = *(void *)(v10 + 336);
          if (v44 && *(_WORD *)(v44 + 1284)) {
            *(_WORD *)(v44 + 1284) = 0;
          }
          *(void *)buf = _nw_http_parsed_fields_create();
          nw::retained_ptr<nw_endpoint *>::operator=(v10 + 504, buf);
          unint64_t v12 = v43;
          unsigned int v16 = v42;
          goto LABEL_47;
        case 1:
LABEL_47:
          unsigned int v122 = v16;
          unint64_t v45 = v12;
          nw_http3_stream_handle_fields(v10, v12, a2, v18);
          int v47 = v46;
          uint64_t v48 = *(void *)(v10 + 376);
          if (v48)
          {
            *(void *)(v48 + 32) = 0;
            uint64_t v49 = *(void **)(v15 + 8);
            *(void *)(v48 + 40) = v49;
            *uint64_t v49 = v48;
            *(void *)(v15 + 8) = v48 + 32;
            ++*v17;
            *(void *)(v10 + 376) = 0;
          }
          if (v18)
          {
            uint64_t v50 = nw_http3_encoder_stream_get_and_reset_received_size(*(void *)(v10 + 336));
            nw_http_transaction_metadata_increment_inbound_header_size(*(void **)(v10 + 392), v45 + v122 + v50);
          }
          goto LABEL_54;
        case 2:
        case 3:
        case 6:
        case 7:
        case 8:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v21 = *(_DWORD *)(v10 + 372);
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_frame_received";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v21;
          uint64_t v22 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v127 = 0;
          if (!__nwlog_fault(v22, &type, &v127)) {
            goto LABEL_71;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v23 = gLogObj;
            os_log_type_t v24 = type;
            if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
              goto LABEL_71;
            }
            int v25 = *(_DWORD *)(v10 + 372);
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_frame_received";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v25;
            unsigned int v26 = "%{public}s Unexpected input state %d";
LABEL_70:
            _os_log_impl(&dword_1830D4000, v23, v24, v26, buf, 0x12u);
            goto LABEL_71;
          }
          if (!v127)
          {
            uint64_t v23 = __nwlog_obj();
            os_log_type_t v24 = type;
            if (!os_log_type_enabled(v23, type)) {
              goto LABEL_71;
            }
            int v56 = *(_DWORD *)(v10 + 372);
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_frame_received";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v56;
            unsigned int v26 = "%{public}s Unexpected input state %d, backtrace limit exceeded";
            goto LABEL_70;
          }
          backtrace_string = (char *)__nw_create_backtrace_string();
          uint64_t v23 = __nwlog_obj();
          os_log_type_t v24 = type;
          BOOL v39 = os_log_type_enabled(v23, type);
          if (!backtrace_string)
          {
            p_cache = (void **)(NWConcrete_nw_resolution_report + 16);
            if (!v39) {
              goto LABEL_71;
            }
            int v58 = *(_DWORD *)(v10 + 372);
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_frame_received";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v58;
            unsigned int v26 = "%{public}s Unexpected input state %d, no backtrace";
            goto LABEL_70;
          }
          if (v39)
          {
            int v40 = *(_DWORD *)(v10 + 372);
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_frame_received";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v40;
            *(_WORD *)&buf[18] = 2082;
            *(void *)&buf[20] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v23, v24, "%{public}s Unexpected input state %d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }
          free(backtrace_string);
          p_cache = (void **)(NWConcrete_nw_resolution_report + 16);
LABEL_71:
          if (v22) {
            free(v22);
          }
          break;
        case 4:
          *(_DWORD *)(v10 + 372) = 5;
          goto LABEL_52;
        case 5:
LABEL_52:
          nw_http3_stream_handle_fields(v10, v12, a2, v18);
          int v47 = v51;
          uint64_t v52 = *(void *)(v10 + 376);
          if (v52)
          {
            *(void *)(v52 + 32) = 0;
            uint64_t v53 = *(void **)(v15 + 8);
            *(void *)(v52 + 40) = v53;
            *uint64_t v53 = v52;
            *(void *)(v15 + 8) = v52 + 32;
            ++*v17;
            *(void *)(v10 + 376) = 0;
          }
LABEL_54:
          int v9 = v125;
          if (!v47) {
            goto LABEL_94;
          }
          goto LABEL_95;
        default:
          goto LABEL_94;
      }
      goto LABEL_73;
    }
LABEL_87:
    if (v11 == 4287504053) {
      goto LABEL_88;
    }
    int v71 = v9;
    if (v19)
    {
      p_cache = (void **)(NWConcrete_nw_resolution_report + 16);
    }
    else
    {
      p_cache = NWConcrete_nw_resolution_report.cache;
      if ((*(_WORD *)(v10 + 736) & 0x800) != 0)
      {
LABEL_93:
        nw_frame_finalize(a2);
        int v9 = v71;
        goto LABEL_94;
      }
    }
    if (*((unsigned char *)p_cache + 3665))
    {
      unint64_t v104 = __nwlog_obj();
      if (os_log_type_enabled(v104, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v105 = (const char *)(v10 + 636);
        int v106 = "";
        int v107 = *(_DWORD *)(*(void *)(v10 + 336) + 1280);
        uint64_t v108 = *(void *)(v10 + 240);
        if (v19) {
          uint64_t v105 = "";
        }
        else {
          int v106 = " ";
        }
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_frame_received";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v105;
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&unsigned char buf[24] = v106;
        LOWORD(v130) = 1024;
        *(_DWORD *)((char *)&v130 + 2) = v107;
        HIWORD(v130) = 2048;
        uint64_t v131 = v108;
        _os_log_impl(&dword_1830D4000, v104, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> dropping unknown frame type", buf, 0x30u);
      }
    }
    goto LABEL_93;
  }
  unsigned int v27 = *(_DWORD *)(v10 + 372);
  p_cache = NWConcrete_nw_resolution_report.cache;
  if (v27 > 8)
  {
LABEL_94:
    int v47 = 0;
    goto LABEL_95;
  }
  if (((1 << v27) & 0x1EE) == 0)
  {
    int v125 = v9;
    if (!v27)
    {
      nw_http3_fail_all_streams(*(void *)(v10 + 336), 261);
LABEL_73:
      int v47 = 2;
      int v9 = v125;
      goto LABEL_95;
    }
    unsigned int v123 = v16;
    objectb = *(NSObject **)(v10 + 400);
    uint64_t v120 = v12;
    int v54 = nw_frame_is_metadata_complete(a2);
    nw_frame_set_metadata(a2, objectb, 1, v54);
    if ((*(_WORD *)(v10 + 736) & 0x800) == 0)
    {
      if (gLogDatapath)
      {
        objecta = __nwlog_obj();
        if (os_log_type_enabled(objecta, OS_LOG_TYPE_DEBUG))
        {
          BOOL v111 = v19 == 0;
          if (v19) {
            int v112 = "";
          }
          else {
            int v112 = (const char *)(v10 + 636);
          }
          if (v111) {
            uint64_t v113 = " ";
          }
          else {
            uint64_t v113 = "";
          }
          int v115 = *(_DWORD *)(*(void *)(v10 + 336) + 1280);
          uint64_t v116 = *(void *)(v10 + 240);
          int v114 = nw_frame_unclaimed_length((_DWORD *)a2);
          *(_DWORD *)buf = 136447490;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_frame_received";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v112;
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)&unsigned char buf[24] = v113;
          p_cache = (void **)(NWConcrete_nw_resolution_report + 16);
          LOWORD(v130) = 1024;
          *(_DWORD *)((char *)&v130 + 2) = v115;
          HIWORD(v130) = 2048;
          uint64_t v131 = v116;
          __int16 v132 = 1024;
          *(_DWORD *)BOOL v133 = v114;
          _os_log_impl(&dword_1830D4000, objecta, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> received %u data bytes", buf, 0x36u);
        }
      }
    }
    *(void *)(a2 + 32) = 0;
    unint64_t v55 = *(uint64_t **)(v15 + 8);
    *(void *)(a2 + 40) = v55;
    uint64_t *v55 = a2;
    *(void *)(v15 + 8) = v7;
    ++*v17;
    int v9 = v125;
    if (v18)
    {
      nw_http_transaction_metadata_increment_inbound_body_transfer_size(*(void **)(v10 + 392), v120 + v123);
      nw::http::content_length_manager::increment_inbound_body_size((nw::http::content_length_manager *)(v10 + 272), v120);
      int v9 = v125;
    }
    goto LABEL_94;
  }
  int v28 = v9;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v29 = *(_DWORD *)(v10 + 372);
  *(_DWORD *)buf = 136446466;
  *(void *)&uint8_t buf[4] = "nw_http3_stream_frame_received";
  *(_WORD *)&buf[12] = 1024;
  *(_DWORD *)&buf[14] = v29;
  int v30 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v127 = 0;
  if (__nwlog_fault(v30, &type, &v127))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v31 = gLogObj;
      os_log_type_t v32 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        int v33 = *(_DWORD *)(v10 + 372);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_frame_received";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v33;
        uint64_t v34 = "%{public}s Unexpected input state %d";
LABEL_64:
        _os_log_impl(&dword_1830D4000, v31, v32, v34, buf, 0x12u);
      }
    }
    else if (v127)
    {
      uint64_t v35 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v31 = gLogObj;
      os_log_type_t v32 = type;
      BOOL v36 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v35)
      {
        if (v36)
        {
          int v37 = *(_DWORD *)(v10 + 372);
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_frame_received";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v37;
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = v35;
          _os_log_impl(&dword_1830D4000, v31, v32, "%{public}s Unexpected input state %d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v35);
        p_cache = (void **)(NWConcrete_nw_resolution_report + 16);
        goto LABEL_65;
      }
      p_cache = (void **)(NWConcrete_nw_resolution_report + 16);
      if (v36)
      {
        int v57 = *(_DWORD *)(v10 + 372);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_frame_received";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v57;
        uint64_t v34 = "%{public}s Unexpected input state %d, no backtrace";
        goto LABEL_64;
      }
    }
    else
    {
      uint64_t v31 = __nwlog_obj();
      os_log_type_t v32 = type;
      if (os_log_type_enabled(v31, type))
      {
        int v41 = *(_DWORD *)(v10 + 372);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_frame_received";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v41;
        uint64_t v34 = "%{public}s Unexpected input state %d, backtrace limit exceeded";
        goto LABEL_64;
      }
    }
  }
LABEL_65:
  if (v30) {
    free(v30);
  }
  int v47 = 2;
  int v9 = v28;
LABEL_95:
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v47;
  uint64_t v72 = *(void *)(a1 + 48);
  if (!v72 || (*(_WORD *)(v72 + 736) & 0x800) == 0)
  {
    if (*((unsigned char *)p_cache + 3665))
    {
      int v89 = v9;
      unint64_t v90 = __nwlog_obj();
      BOOL v91 = os_log_type_enabled(v90, OS_LOG_TYPE_DEBUG);
      int v9 = v89;
      if (v91)
      {
        uint64_t v92 = *(void *)(a1 + 48);
        int v93 = (const char *)(v92 + 636);
        uint64_t v94 = "";
        if (v92) {
          uint64_t v94 = " ";
        }
        else {
          int v93 = "";
        }
        int v95 = *(_DWORD *)(*(void *)(v92 + 336) + 1280);
        uint64_t v96 = *(void *)(v92 + 240);
        int v97 = *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
        int v98 = *(_DWORD *)(v92 + 372);
        *(_DWORD *)buf = 136447746;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_get_input_frames_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v93;
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&unsigned char buf[24] = v94;
        LOWORD(v130) = 1024;
        *(_DWORD *)((char *)&v130 + 2) = v95;
        HIWORD(v130) = 2048;
        uint64_t v131 = v96;
        __int16 v132 = 1024;
        *(_DWORD *)BOOL v133 = v97;
        *(_WORD *)&v133[4] = 1024;
        *(_DWORD *)&v133[6] = v98;
        _os_log_impl(&dword_1830D4000, v90, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> status %u http3_stream->input_state %u", buf, 0x3Cu);
        int v9 = v89;
      }
    }
  }
  if (v9)
  {
    nw_http_transaction_metadata_mark_inbound_message_end(*(void **)(*(void *)(a1 + 48) + 392));
    uint64_t v73 = *(void *)(a1 + 48);
    if (*(unsigned char *)(v73 + 304))
    {
      if (*(void *)(v73 + 296) != *(void *)(v73 + 312))
      {
        if ((*(_WORD *)(v73 + 736) & 0x800) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v74 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            uint64_t v75 = *(void *)(a1 + 48);
            uint64_t v76 = " ";
            if (v75) {
              uint64_t v77 = (const char *)(v75 + 636);
            }
            else {
              uint64_t v77 = "";
            }
            if (!v75) {
              uint64_t v76 = "";
            }
            int v78 = *(_DWORD *)(*(void *)(v75 + 336) + 1280);
            uint64_t v79 = *(void *)(v75 + 240);
            if (*(unsigned char *)(v75 + 304)) {
              uint64_t v80 = *(void *)(v75 + 296);
            }
            else {
              uint64_t v80 = -1;
            }
            unint64_t v81 = *(void *)(v75 + 312);
            *(_DWORD *)buf = 136447746;
            *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_get_input_frames_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v77;
            *(_WORD *)&unsigned char buf[22] = 2080;
            *(void *)&unsigned char buf[24] = v76;
            LOWORD(v130) = 1024;
            *(_DWORD *)((char *)&v130 + 2) = v78;
            HIWORD(v130) = 2048;
            uint64_t v131 = v79;
            __int16 v132 = 2048;
            *(void *)BOOL v133 = v80;
            *(_WORD *)&v133[8] = 2048;
            unint64_t v134 = v81;
            _os_log_impl(&dword_1830D4000, v74, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%llu> Content length header %llu does not equal body size %llu", buf, 0x44u);
          }
        }
        uint64_t v82 = *v14;
        if (*v14)
        {
          if (*((unsigned char *)p_cache + 3665))
          {
            uint64_t v103 = __nwlog_obj();
            if (os_log_type_enabled(v103, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
              _os_log_impl(&dword_1830D4000, v103, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
            }
          }
          *(void *)buf = MEMORY[0x1E4F143A8];
          *(void *)&buf[8] = 0x40000000;
          *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_61444;
          *(void *)&unsigned char buf[24] = &__block_descriptor_tmp_30_61445;
          unsigned int v130 = v82;
          LOBYTE(v131) = 0;
          uint64_t v83 = *v82;
          do
          {
            if (!v83) {
              break;
            }
            uint64_t v84 = *(void *)(v83 + 32);
            char v85 = (*(uint64_t (**)(unsigned char *))&buf[16])(buf);
            uint64_t v83 = v84;
          }
          while ((v85 & 1) != 0);
LABEL_117:
          uint64_t v86 = *(void *)(a1 + 48);
          *(void *)(v86 + 264) = 270;
          if (*(void *)(v86 + 312)) {
            int v87 = 40;
          }
          else {
            int v87 = 91;
          }
          nw_protocol_http3_stream_error((nw_protocol *)v86, (nw_protocol *)v86, v87);
          nw_protocol_http3_stream_disconnect(*(nw_protocol **)(a1 + 48), *(nw_protocol **)(a1 + 48));
          *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 2;
          *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
          return *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
        }
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
        uint64_t v99 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v127 = 0;
        if (__nwlog_fault(v99, &type, &v127))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            unint64_t v100 = __nwlog_obj();
            os_log_type_t v101 = type;
            if (!os_log_type_enabled(v100, type)) {
              goto LABEL_148;
            }
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
            int v102 = "%{public}s called with null array";
            goto LABEL_147;
          }
          if (!v127)
          {
            unint64_t v100 = __nwlog_obj();
            os_log_type_t v101 = type;
            if (!os_log_type_enabled(v100, type)) {
              goto LABEL_148;
            }
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
            int v102 = "%{public}s called with null array, backtrace limit exceeded";
            goto LABEL_147;
          }
          __int16 v109 = (char *)__nw_create_backtrace_string();
          unint64_t v100 = __nwlog_obj();
          os_log_type_t v101 = type;
          BOOL v110 = os_log_type_enabled(v100, type);
          if (v109)
          {
            if (v110)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v109;
              _os_log_impl(&dword_1830D4000, v100, v101, "%{public}s called with null array, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v109);
            goto LABEL_148;
          }
          if (v110)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
            int v102 = "%{public}s called with null array, no backtrace";
LABEL_147:
            _os_log_impl(&dword_1830D4000, v100, v101, v102, buf, 0xCu);
          }
        }
LABEL_148:
        if (v99) {
          free(v99);
        }
        goto LABEL_117;
      }
    }
  }
  return *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
}

void ___ZL41nw_protocol_http3_stream_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_161(uint64_t a1)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  if ((*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))())
  {
    uint64_t v2 = *(void *)(a1 + 40);
    if ((*(_WORD *)(v2 + 736) & 0x100) != 0)
    {
      if ((*(_WORD *)(v2 + 736) & 0x800) == 0)
      {
        if (gLogDatapath)
        {
          uint64_t v23 = __nwlog_obj();
          BOOL v24 = os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG);
          uint64_t v2 = *(void *)(a1 + 40);
          if (v24)
          {
            int v25 = (const char *)(v2 + 636);
            unsigned int v26 = "";
            int v27 = *(_DWORD *)(*(void *)(v2 + 336) + 1280);
            BOOL v28 = v2 == 0;
            uint64_t v29 = *(void *)(v2 + 240);
            if (v28) {
              int v25 = "";
            }
            else {
              unsigned int v26 = " ";
            }
            *(_DWORD *)buf = 136447234;
            BOOL v39 = "nw_protocol_http3_stream_get_input_frames_block_invoke";
            __int16 v40 = 2082;
            int v41 = v25;
            __int16 v42 = 2080;
            unint64_t v43 = (void *)v26;
            __int16 v44 = 1024;
            int v45 = v27;
            __int16 v46 = 2048;
            uint64_t v47 = v29;
            _os_log_impl(&dword_1830D4000, v23, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> delivering deferred input finished", buf, 0x30u);
            uint64_t v2 = *(void *)(a1 + 40);
          }
        }
      }
      int v3 = *(unsigned __int16 *)(v2 + 736);
      unsigned int v4 = v3 & 0xFFFFFEFF | (*(unsigned __int8 *)(v2 + 738) << 16);
      *(_WORD *)(v2 + 736) = v3 & 0xFEFF;
      *(unsigned char *)(v2 + 738) = BYTE2(v4);
      uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 48);
      if (v5)
      {
        uint64_t v6 = *(void *)(v5 + 24);
        if (v6)
        {
          unsigned int v7 = *(void (**)(void))(v6 + 184);
          if (v7)
          {
            v7();
            return;
          }
        }
      }
      __nwlog_obj();
      uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 48);
      int v9 = "invalid";
      if (v8)
      {
        uint64_t v10 = *(const char **)(v8 + 16);
        if (v10) {
          int v9 = v10;
        }
      }
      *(_DWORD *)buf = 136446466;
      BOOL v39 = "nw_protocol_http3_stream_get_input_frames_block_invoke";
      __int16 v40 = 2082;
      int v41 = v9;
      unint64_t v11 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v36 = 0;
      if (!__nwlog_fault(v11, &type, &v36)) {
        goto LABEL_44;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        unint64_t v12 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (!os_log_type_enabled(v12, type)) {
          goto LABEL_44;
        }
        uint64_t v14 = *(void *)(*(void *)(a1 + 40) + 48);
        uint64_t v15 = "invalid";
        if (v14)
        {
          unsigned int v16 = *(const char **)(v14 + 16);
          if (v16) {
            uint64_t v15 = v16;
          }
        }
        *(_DWORD *)buf = 136446466;
        BOOL v39 = "nw_protocol_http3_stream_get_input_frames_block_invoke";
        __int16 v40 = 2082;
        int v41 = v15;
        dispatch_data_t v17 = "%{public}s protocol %{public}s has invalid input_finished callback";
      }
      else if (v36)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        unint64_t v12 = __nwlog_obj();
        os_log_type_t v13 = type;
        BOOL v19 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v19)
          {
            uint64_t v20 = *(void *)(*(void *)(a1 + 40) + 48);
            int v21 = "invalid";
            if (v20)
            {
              uint64_t v22 = *(const char **)(v20 + 16);
              if (v22) {
                int v21 = v22;
              }
            }
            *(_DWORD *)buf = 136446722;
            BOOL v39 = "nw_protocol_http3_stream_get_input_frames_block_invoke";
            __int16 v40 = 2082;
            int v41 = v21;
            __int16 v42 = 2082;
            unint64_t v43 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s protocol %{public}s has invalid input_finished callback, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(backtrace_string);
          goto LABEL_44;
        }
        if (!v19)
        {
LABEL_44:
          if (v11) {
            free(v11);
          }
          return;
        }
        uint64_t v33 = *(void *)(*(void *)(a1 + 40) + 48);
        uint64_t v34 = "invalid";
        if (v33)
        {
          uint64_t v35 = *(const char **)(v33 + 16);
          if (v35) {
            uint64_t v34 = v35;
          }
        }
        *(_DWORD *)buf = 136446466;
        BOOL v39 = "nw_protocol_http3_stream_get_input_frames_block_invoke";
        __int16 v40 = 2082;
        int v41 = v34;
        dispatch_data_t v17 = "%{public}s protocol %{public}s has invalid input_finished callback, no backtrace";
      }
      else
      {
        unint64_t v12 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (!os_log_type_enabled(v12, type)) {
          goto LABEL_44;
        }
        uint64_t v30 = *(void *)(*(void *)(a1 + 40) + 48);
        uint64_t v31 = "invalid";
        if (v30)
        {
          os_log_type_t v32 = *(const char **)(v30 + 16);
          if (v32) {
            uint64_t v31 = v32;
          }
        }
        *(_DWORD *)buf = 136446466;
        BOOL v39 = "nw_protocol_http3_stream_get_input_frames_block_invoke";
        __int16 v40 = 2082;
        int v41 = v31;
        dispatch_data_t v17 = "%{public}s protocol %{public}s has invalid input_finished callback, backtrace limit exceeded";
      }
      _os_log_impl(&dword_1830D4000, v12, v13, v17, buf, 0x16u);
      goto LABEL_44;
    }
  }
}

void nw::http::content_length_manager::increment_inbound_body_size(nw::http::content_length_manager *this, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 5);
  *((void *)this + 5) = v2 + a2;
  if (__CFADD__(v2, a2))
  {
    if (gLogDatapath)
    {
      uint64_t v5 = __nwlog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v6 = *((void *)this + 5);
        int v7 = 136446978;
        uint64_t v8 = "increment_inbound_body_size";
        __int16 v9 = 2082;
        uint64_t v10 = "inbound_body_size";
        __int16 v11 = 2048;
        uint64_t v12 = a2;
        __int16 v13 = 2048;
        uint64_t v14 = v6;
        _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_DEBUG, "%{public}s Overflow: %{public}s, increment %llu, result %llu", (uint8_t *)&v7, 0x2Au);
      }
    }
    *((void *)this + 5) = -1;
  }
}

void nw_protocol_http3_stream_output_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v48 = "nw_protocol_http3_stream_output_available";
    int v21 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (!__nwlog_fault(v21, &type, &v45)) {
      goto LABEL_66;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_66;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v48 = "nw_protocol_http3_stream_output_available";
      BOOL v24 = "%{public}s called with null protocol";
      goto LABEL_65;
    }
    if (!v45)
    {
      uint64_t v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_66;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v48 = "nw_protocol_http3_stream_output_available";
      BOOL v24 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_65;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v22 = __nwlog_obj();
    os_log_type_t v23 = type;
    BOOL v29 = os_log_type_enabled(v22, type);
    if (!backtrace_string)
    {
      if (!v29) {
        goto LABEL_66;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v48 = "nw_protocol_http3_stream_output_available";
      BOOL v24 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_65;
    }
    if (v29)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v48 = "nw_protocol_http3_stream_output_available";
      __int16 v49 = 2082;
      uint64_t v50 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_66:
    if (!v21) {
      return;
    }
    goto LABEL_67;
  }
  uint64_t handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v48 = "nw_protocol_http3_stream_output_available";
    int v21 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (!__nwlog_fault(v21, &type, &v45)) {
      goto LABEL_66;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_66;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v48 = "nw_protocol_http3_stream_output_available";
      BOOL v24 = "%{public}s called with null http3_stream";
      goto LABEL_65;
    }
    if (!v45)
    {
      uint64_t v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_66;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v48 = "nw_protocol_http3_stream_output_available";
      BOOL v24 = "%{public}s called with null http3_stream, backtrace limit exceeded";
      goto LABEL_65;
    }
    uint64_t v30 = (char *)__nw_create_backtrace_string();
    uint64_t v22 = __nwlog_obj();
    os_log_type_t v23 = type;
    BOOL v31 = os_log_type_enabled(v22, type);
    if (v30)
    {
      if (v31)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v48 = "nw_protocol_http3_stream_output_available";
        __int16 v49 = 2082;
        uint64_t v50 = v30;
        _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s called with null http3_stream, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v30);
      if (!v21) {
        return;
      }
LABEL_67:
      int v37 = (char *)v21;
LABEL_68:
      free(v37);
      return;
    }
    if (v31)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v48 = "nw_protocol_http3_stream_output_available";
      BOOL v24 = "%{public}s called with null http3_stream, no backtrace";
LABEL_65:
      _os_log_impl(&dword_1830D4000, v22, v23, v24, buf, 0xCu);
      goto LABEL_66;
    }
    goto LABEL_66;
  }
  if ((handle[92] & 0x800) == 0)
  {
    if (gLogDatapath)
    {
      int v25 = __nwlog_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
      {
        int v26 = *(_DWORD *)(handle[42] + 1280);
        uint64_t v27 = handle[30];
        *(_DWORD *)buf = 136447234;
        uint64_t v48 = "nw_protocol_http3_stream_output_available";
        __int16 v49 = 2082;
        uint64_t v50 = (char *)handle + 636;
        __int16 v51 = 2080;
        uint64_t v52 = " ";
        __int16 v53 = 1024;
        int v54 = v26;
        __int16 v55 = 2048;
        uint64_t v56 = v27;
        _os_log_impl(&dword_1830D4000, v25, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called", buf, 0x30u);
      }
    }
  }
  switch(*((_DWORD *)handle + 92))
  {
    case 0:
      if ((handle[92] & 0x800) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v6 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        {
          int v7 = *(_DWORD *)(handle[42] + 1280);
          uint64_t v8 = handle[30];
          *(_DWORD *)buf = 136447234;
          uint64_t v48 = "nw_protocol_http3_stream_output_available";
          __int16 v49 = 2082;
          uint64_t v50 = (char *)handle + 636;
          __int16 v51 = 2080;
          uint64_t v52 = " ";
          __int16 v53 = 1024;
          int v54 = v7;
          __int16 v55 = 2048;
          uint64_t v56 = v8;
          _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%llu> output_available before get_output_frames", buf, 0x30u);
        }
      }
      return;
    case 1:
    case 3:
    case 5:
      nw_http3_stream_send_pending_capsules((uint64_t)handle);
      uint64_t v3 = handle[6];
      if (v3)
      {
        uint64_t v4 = *(void *)(v3 + 24);
        if (v4)
        {
          uint64_t v5 = *(void (**)(void))(v4 + 72);
          if (v5) {
            goto LABEL_9;
          }
        }
      }
      return;
    case 2:
      int is_metadata_complete = nw_frame_is_metadata_complete(handle[48]);
      if (!nw_http3_stream_send_fields((uint64_t)handle, is_metadata_complete)) {
        return;
      }
      uint64_t v10 = handle[6];
      if (v10)
      {
        uint64_t v11 = *(void *)(v10 + 24);
        if (v11)
        {
          uint64_t v5 = *(void (**)(void))(v11 + 72);
          if (v5)
          {
LABEL_9:
            v5();
            return;
          }
        }
      }
      __nwlog_obj();
      uint64_t v12 = handle[6];
      __int16 v13 = "invalid";
      if (v12)
      {
        uint64_t v14 = *(const char **)(v12 + 16);
        if (v14) {
          __int16 v13 = v14;
        }
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v48 = "nw_protocol_http3_stream_output_available";
      __int16 v49 = 2082;
      uint64_t v50 = (char *)v13;
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v45 = 0;
      __int16 v44 = (const char *)_os_log_send_and_compose_impl();
      if (!__nwlog_fault(v44, &type, &v45)) {
        goto LABEL_80;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v15 = __nwlog_obj();
        os_log_type_t v16 = type;
        if (!os_log_type_enabled(v15, type)) {
          goto LABEL_80;
        }
        uint64_t v17 = handle[6];
        BOOL v18 = "invalid";
        if (v17)
        {
          BOOL v19 = *(const char **)(v17 + 16);
          if (v19) {
            BOOL v18 = v19;
          }
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v48 = "nw_protocol_http3_stream_output_available";
        __int16 v49 = 2082;
        uint64_t v50 = (char *)v18;
        uint64_t v20 = "%{public}s protocol %{public}s has invalid output_available callback";
LABEL_79:
        _os_log_impl(&dword_1830D4000, v15, v16, v20, buf, 0x16u);
        goto LABEL_80;
      }
      if (!v45)
      {
        uint64_t v15 = __nwlog_obj();
        os_log_type_t v16 = type;
        if (!os_log_type_enabled(v15, type)) {
          goto LABEL_80;
        }
        uint64_t v38 = handle[6];
        BOOL v39 = "invalid";
        if (v38)
        {
          __int16 v40 = *(const char **)(v38 + 16);
          if (v40) {
            BOOL v39 = v40;
          }
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v48 = "nw_protocol_http3_stream_output_available";
        __int16 v49 = 2082;
        uint64_t v50 = (char *)v39;
        uint64_t v20 = "%{public}s protocol %{public}s has invalid output_available callback, backtrace limit exceeded";
        goto LABEL_79;
      }
      os_log_type_t v32 = (char *)__nw_create_backtrace_string();
      uint64_t v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v33 = os_log_type_enabled(v15, type);
      if (!v32)
      {
        if (!v33) {
          goto LABEL_80;
        }
        uint64_t v41 = handle[6];
        __int16 v42 = "invalid";
        if (v41)
        {
          unint64_t v43 = *(const char **)(v41 + 16);
          if (v43) {
            __int16 v42 = v43;
          }
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v48 = "nw_protocol_http3_stream_output_available";
        __int16 v49 = 2082;
        uint64_t v50 = (char *)v42;
        uint64_t v20 = "%{public}s protocol %{public}s has invalid output_available callback, no backtrace";
        goto LABEL_79;
      }
      if (v33)
      {
        uint64_t v34 = handle[6];
        uint64_t v35 = "invalid";
        if (v34)
        {
          char v36 = *(const char **)(v34 + 16);
          if (v36) {
            uint64_t v35 = v36;
          }
        }
        *(_DWORD *)buf = 136446722;
        uint64_t v48 = "nw_protocol_http3_stream_output_available";
        __int16 v49 = 2082;
        uint64_t v50 = (char *)v35;
        __int16 v51 = 2082;
        uint64_t v52 = v32;
        _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s protocol %{public}s has invalid output_available callback, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(v32);
LABEL_80:
      int v37 = (char *)v44;
      if (v44) {
        goto LABEL_68;
      }
      break;
    default:
      return;
  }
}

uint64_t nw_protocol_http3_stream_replace_input_handler(nw_protocol *a1, nw_protocol *a2, nw_protocol *a3)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v34 = "nw_protocol_http3_stream_replace_input_handler";
    int v21 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (!__nwlog_fault(v21, &type, &v31)) {
      goto LABEL_83;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v31)
      {
        uint64_t v22 = __nwlog_obj();
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v34 = "nw_protocol_http3_stream_replace_input_handler";
          BOOL v24 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_82;
        }
        goto LABEL_83;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      BOOL v26 = os_log_type_enabled(v22, type);
      if (!backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v34 = "nw_protocol_http3_stream_replace_input_handler";
          BOOL v24 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_82;
        }
        goto LABEL_83;
      }
      if (!v26) {
        goto LABEL_65;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v34 = "nw_protocol_http3_stream_replace_input_handler";
      __int16 v35 = 2082;
      char v36 = (nw_protocol *)backtrace_string;
      uint64_t v27 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_64;
    }
    uint64_t v22 = __nwlog_obj();
    os_log_type_t v23 = type;
    if (!os_log_type_enabled(v22, type)) {
      goto LABEL_83;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v34 = "nw_protocol_http3_stream_replace_input_handler";
    BOOL v24 = "%{public}s called with null protocol";
LABEL_82:
    _os_log_impl(&dword_1830D4000, v22, v23, v24, buf, 0xCu);
    goto LABEL_83;
  }
  uint64_t handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v34 = "nw_protocol_http3_stream_replace_input_handler";
    int v21 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (!__nwlog_fault(v21, &type, &v31)) {
      goto LABEL_83;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v31)
      {
        uint64_t v22 = __nwlog_obj();
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v34 = "nw_protocol_http3_stream_replace_input_handler";
          BOOL v24 = "%{public}s called with null http3_stream, backtrace limit exceeded";
          goto LABEL_82;
        }
        goto LABEL_83;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      BOOL v28 = os_log_type_enabled(v22, type);
      if (!backtrace_string)
      {
        if (v28)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v34 = "nw_protocol_http3_stream_replace_input_handler";
          BOOL v24 = "%{public}s called with null http3_stream, no backtrace";
          goto LABEL_82;
        }
        goto LABEL_83;
      }
      if (!v28) {
        goto LABEL_65;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v34 = "nw_protocol_http3_stream_replace_input_handler";
      __int16 v35 = 2082;
      char v36 = (nw_protocol *)backtrace_string;
      uint64_t v27 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
      goto LABEL_64;
    }
    uint64_t v22 = __nwlog_obj();
    os_log_type_t v23 = type;
    if (!os_log_type_enabled(v22, type)) {
      goto LABEL_83;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v34 = "nw_protocol_http3_stream_replace_input_handler";
    BOOL v24 = "%{public}s called with null http3_stream";
    goto LABEL_82;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v34 = "nw_protocol_http3_stream_replace_input_handler";
    int v21 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (!__nwlog_fault(v21, &type, &v31)) {
      goto LABEL_83;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_83;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v34 = "nw_protocol_http3_stream_replace_input_handler";
      BOOL v24 = "%{public}s called with null old_input_handler";
      goto LABEL_82;
    }
    if (!v31)
    {
      uint64_t v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v34 = "nw_protocol_http3_stream_replace_input_handler";
        BOOL v24 = "%{public}s called with null old_input_handler, backtrace limit exceeded";
        goto LABEL_82;
      }
      goto LABEL_83;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v22 = __nwlog_obj();
    os_log_type_t v23 = type;
    BOOL v29 = os_log_type_enabled(v22, type);
    if (!backtrace_string)
    {
      if (v29)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v34 = "nw_protocol_http3_stream_replace_input_handler";
        BOOL v24 = "%{public}s called with null old_input_handler, no backtrace";
        goto LABEL_82;
      }
      goto LABEL_83;
    }
    if (!v29) {
      goto LABEL_65;
    }
    *(_DWORD *)buf = 136446466;
    uint64_t v34 = "nw_protocol_http3_stream_replace_input_handler";
    __int16 v35 = 2082;
    char v36 = (nw_protocol *)backtrace_string;
    uint64_t v27 = "%{public}s called with null old_input_handler, dumping backtrace:%{public}s";
LABEL_64:
    _os_log_impl(&dword_1830D4000, v22, v23, v27, buf, 0x16u);
    goto LABEL_65;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v34 = "nw_protocol_http3_stream_replace_input_handler";
    int v21 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (!__nwlog_fault(v21, &type, &v31)) {
      goto LABEL_83;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v34 = "nw_protocol_http3_stream_replace_input_handler";
        BOOL v24 = "%{public}s called with null new_input_handler";
        goto LABEL_82;
      }
LABEL_83:
      if (!v21) {
        return 0;
      }
      uint64_t v20 = (char *)v21;
      goto LABEL_29;
    }
    if (!v31)
    {
      uint64_t v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v34 = "nw_protocol_http3_stream_replace_input_handler";
        BOOL v24 = "%{public}s called with null new_input_handler, backtrace limit exceeded";
        goto LABEL_82;
      }
      goto LABEL_83;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v22 = __nwlog_obj();
    os_log_type_t v23 = type;
    BOOL v30 = os_log_type_enabled(v22, type);
    if (!backtrace_string)
    {
      if (v30)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v34 = "nw_protocol_http3_stream_replace_input_handler";
        BOOL v24 = "%{public}s called with null new_input_handler, no backtrace";
        goto LABEL_82;
      }
      goto LABEL_83;
    }
    if (v30)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v34 = "nw_protocol_http3_stream_replace_input_handler";
      __int16 v35 = 2082;
      char v36 = (nw_protocol *)backtrace_string;
      uint64_t v27 = "%{public}s called with null new_input_handler, dumping backtrace:%{public}s";
      goto LABEL_64;
    }
LABEL_65:
    free(backtrace_string);
    goto LABEL_83;
  }
  if (a1->default_input_handler == a2)
  {
    nw_protocol_set_input_handler((uint64_t)a1->handle, (uint64_t)a3);
    nw_protocol_set_input_handler((uint64_t)(handle + 8), (uint64_t)a3);
    uint64_t v13 = handle[42];
    if (v13 && *(nw_protocol **)(v13 + 48) == a2)
    {
      nw_protocol_set_input_handler(v13, (uint64_t)a3);
      if (a3->output_handler) {
        return 1;
      }
    }
    else if (a3->output_handler)
    {
      return 1;
    }
    nw_protocol_set_output_handler((uint64_t)a3, (uint64_t)a1);
    return 1;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  default_input_handler = a1->default_input_handler;
  *(_DWORD *)buf = 136446722;
  uint64_t v34 = "nw_protocol_http3_stream_replace_input_handler";
  __int16 v35 = 2048;
  char v36 = default_input_handler;
  __int16 v37 = 2048;
  uint64_t v38 = a2;
  uint64_t v8 = (const char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v31 = 0;
  if (!__nwlog_fault(v8, &type, &v31)) {
    goto LABEL_27;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v9 = gLogObj;
    os_log_type_t v10 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
      goto LABEL_27;
    }
    uint64_t v11 = a1->default_input_handler;
    *(_DWORD *)buf = 136446722;
    uint64_t v34 = "nw_protocol_http3_stream_replace_input_handler";
    __int16 v35 = 2048;
    char v36 = v11;
    __int16 v37 = 2048;
    uint64_t v38 = a2;
    uint64_t v12 = "%{public}s Old input handler does not match (%p != %p)";
LABEL_26:
    _os_log_impl(&dword_1830D4000, v9, v10, v12, buf, 0x20u);
    goto LABEL_27;
  }
  if (!v31)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v9 = gLogObj;
    os_log_type_t v10 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
      goto LABEL_27;
    }
    BOOL v18 = a1->default_input_handler;
    *(_DWORD *)buf = 136446722;
    uint64_t v34 = "nw_protocol_http3_stream_replace_input_handler";
    __int16 v35 = 2048;
    char v36 = v18;
    __int16 v37 = 2048;
    uint64_t v38 = a2;
    uint64_t v12 = "%{public}s Old input handler does not match (%p != %p), backtrace limit exceeded";
    goto LABEL_26;
  }
  uint64_t v15 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  __int16 v9 = gLogObj;
  os_log_type_t v10 = type;
  BOOL v16 = os_log_type_enabled((os_log_t)gLogObj, type);
  if (!v15)
  {
    if (!v16) {
      goto LABEL_27;
    }
    BOOL v19 = a1->default_input_handler;
    *(_DWORD *)buf = 136446722;
    uint64_t v34 = "nw_protocol_http3_stream_replace_input_handler";
    __int16 v35 = 2048;
    char v36 = v19;
    __int16 v37 = 2048;
    uint64_t v38 = a2;
    uint64_t v12 = "%{public}s Old input handler does not match (%p != %p), no backtrace";
    goto LABEL_26;
  }
  if (v16)
  {
    uint64_t v17 = a1->default_input_handler;
    *(_DWORD *)buf = 136446978;
    uint64_t v34 = "nw_protocol_http3_stream_replace_input_handler";
    __int16 v35 = 2048;
    char v36 = v17;
    __int16 v37 = 2048;
    uint64_t v38 = a2;
    __int16 v39 = 2082;
    __int16 v40 = v15;
    _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s Old input handler does not match (%p != %p), dumping backtrace:%{public}s", buf, 0x2Au);
  }
  free(v15);
LABEL_27:
  if (v8)
  {
    uint64_t v20 = (char *)v8;
LABEL_29:
    free(v20);
  }
  return 0;
}

uint64_t nw_protocol_http3_stream_remove_input_handler(nw_protocol *a1, nw_protocol *a2, int a3)
{
  uint64_t v153 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_remove_input_handler";
    os_log_type_t v66 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v142 = 0;
    if (!__nwlog_fault(v66, &type, &v142)) {
      goto LABEL_230;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v142)
      {
        uint32_t v67 = __nwlog_obj();
        os_log_type_t v68 = type;
        if (!os_log_type_enabled(v67, type)) {
          goto LABEL_230;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_remove_input_handler";
        uint64_t v69 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_229;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint32_t v67 = __nwlog_obj();
      os_log_type_t v68 = type;
      BOOL v87 = os_log_type_enabled(v67, type);
      if (!backtrace_string)
      {
        if (!v87) {
          goto LABEL_230;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_remove_input_handler";
        uint64_t v69 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_229;
      }
      if (v87)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_remove_input_handler";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        char v88 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_150:
        _os_log_impl(&dword_1830D4000, v67, v68, v88, buf, 0x16u);
      }
LABEL_151:
      free(backtrace_string);
      goto LABEL_230;
    }
    uint32_t v67 = __nwlog_obj();
    os_log_type_t v68 = type;
    if (!os_log_type_enabled(v67, type)) {
      goto LABEL_230;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_remove_input_handler";
    uint64_t v69 = "%{public}s called with null protocol";
LABEL_229:
    _os_log_impl(&dword_1830D4000, v67, v68, v69, buf, 0xCu);
LABEL_230:
    if (v66) {
      free(v66);
    }
    return 0;
  }
  uint64_t handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_remove_input_handler";
    os_log_type_t v66 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v142 = 0;
    if (!__nwlog_fault(v66, &type, &v142)) {
      goto LABEL_230;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint32_t v67 = __nwlog_obj();
      os_log_type_t v68 = type;
      if (!os_log_type_enabled(v67, type)) {
        goto LABEL_230;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_remove_input_handler";
      uint64_t v69 = "%{public}s called with null http3_stream";
      goto LABEL_229;
    }
    if (!v142)
    {
      uint32_t v67 = __nwlog_obj();
      os_log_type_t v68 = type;
      if (!os_log_type_enabled(v67, type)) {
        goto LABEL_230;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_remove_input_handler";
      uint64_t v69 = "%{public}s called with null http3_stream, backtrace limit exceeded";
      goto LABEL_229;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint32_t v67 = __nwlog_obj();
    os_log_type_t v68 = type;
    BOOL v96 = os_log_type_enabled(v67, type);
    if (backtrace_string)
    {
      if (v96)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_remove_input_handler";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        char v88 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
        goto LABEL_150;
      }
      goto LABEL_151;
    }
    if (!v96) {
      goto LABEL_230;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_remove_input_handler";
    uint64_t v69 = "%{public}s called with null http3_stream, no backtrace";
    goto LABEL_229;
  }
  if ((*((_WORD *)handle + 368) & 0x800) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v7 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = *(_DWORD *)(*((void *)handle + 42) + 1280);
      uint64_t v9 = *((void *)handle + 30);
      default_input_handler = a1->default_input_handler;
      *(_DWORD *)buf = 136448002;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_remove_input_handler";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = handle + 636;
      *(_WORD *)&unsigned char buf[22] = 2080;
      uint64_t v145 = (uint64_t)" ";
      LOWORD(v146) = 1024;
      *(_DWORD *)((char *)&v146 + 2) = v8;
      WORD3(v146) = 2048;
      *((void *)&v146 + 1) = v9;
      __int16 v147 = 2048;
      uint64_t v148 = a1;
      __int16 v149 = 2048;
      int v150 = default_input_handler;
      __int16 v151 = 2048;
      __int16 v152 = a2;
      _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s%s<i%u:s%llu> protocol %p, default_input_handler %p, input protocol %p", buf, 0x4Eu);
    }
  }
  uint64_t v11 = handle + 736;
  nw_http_transaction_metadata_mark_end(*((void **)handle + 49));
  if (a2->output_handler == a1) {
    nw_protocol_set_output_handler((uint64_t)a2, 0);
  }
  if ((*v11 & 0x800) == 0)
  {
    if (gLogDatapath)
    {
      int v70 = __nwlog_obj();
      if (os_log_type_enabled(v70, OS_LOG_TYPE_DEBUG))
      {
        int v71 = *(_DWORD *)(*((void *)handle + 42) + 1280);
        uint64_t v72 = *((void *)handle + 30);
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_stop_datagram_flow";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = handle + 636;
        *(_WORD *)&unsigned char buf[22] = 2080;
        uint64_t v145 = (uint64_t)" ";
        LOWORD(v146) = 1024;
        *(_DWORD *)((char *)&v146 + 2) = v71;
        WORD3(v146) = 2048;
        *((void *)&v146 + 1) = v72;
        _os_log_impl(&dword_1830D4000, v70, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called", buf, 0x30u);
      }
    }
  }
  int v12 = (unsigned __int16)*v11;
  if ((v12 & 0x10) != 0)
  {
    unsigned int v13 = v12 & 0xFFFFFFEF | (handle[738] << 16);
    _WORD *v11 = v12 & 0xFFEF;
    handle[738] = BYTE2(v13);
    uint64_t v14 = *((void *)handle + 12);
    if (v14)
    {
      uint64_t v15 = *(void *)(v14 + 24);
      if (v15)
      {
        BOOL v16 = *(void (**)(void, char *))(v15 + 32);
        if (v16)
        {
          v16(*((void *)handle + 12), handle + 64);
          goto LABEL_15;
        }
      }
      __nwlog_obj();
      uint64_t v73 = *(const char **)(v14 + 16);
      if (!v73) {
        uint64_t v73 = "invalid";
      }
    }
    else
    {
      __nwlog_obj();
      uint64_t v73 = "invalid";
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_stop_datagram_flow";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v73;
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v142 = 0;
    char v140 = (char *)_os_log_send_and_compose_impl();
    if (__nwlog_fault(v140, &type, &v142))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v89 = __nwlog_obj();
        os_log_type_t v90 = type;
        os_log_t log = v89;
        if (!os_log_type_enabled(v89, type)) {
          goto LABEL_170;
        }
        BOOL v91 = "invalid";
        if (v14 && *(void *)(v14 + 16)) {
          BOOL v91 = *(const char **)(v14 + 16);
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_stop_datagram_flow";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v91;
        uint64_t v92 = "%{public}s protocol %{public}s has invalid disconnect callback";
LABEL_168:
        uint64_t v108 = log;
        os_log_type_t v109 = v90;
LABEL_169:
        _os_log_impl(&dword_1830D4000, v108, v109, v92, buf, 0x16u);
        goto LABEL_170;
      }
      if (!v142)
      {
        int v106 = __nwlog_obj();
        os_log_type_t v90 = type;
        os_log_t log = v106;
        if (!os_log_type_enabled(v106, type)) {
          goto LABEL_170;
        }
        int v107 = "invalid";
        if (v14 && *(void *)(v14 + 16)) {
          int v107 = *(const char **)(v14 + 16);
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_stop_datagram_flow";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v107;
        uint64_t v92 = "%{public}s protocol %{public}s has invalid disconnect callback, backtrace limit exceeded";
        goto LABEL_168;
      }
      int v93 = (char *)__nw_create_backtrace_string();
      loga = __nwlog_obj();
      os_log_type_t v133 = type;
      BOOL v94 = os_log_type_enabled(loga, type);
      if (v93)
      {
        if (v94)
        {
          int v95 = "invalid";
          if (v14 && *(void *)(v14 + 16)) {
            int v95 = *(const char **)(v14 + 16);
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_stop_datagram_flow";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v95;
          *(_WORD *)&unsigned char buf[22] = 2082;
          uint64_t v145 = (uint64_t)v93;
          _os_log_impl(&dword_1830D4000, loga, v133, "%{public}s protocol %{public}s has invalid disconnect callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v93);
      }
      else if (v94)
      {
        int v125 = "invalid";
        if (v14 && *(void *)(v14 + 16)) {
          int v125 = *(const char **)(v14 + 16);
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_stop_datagram_flow";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v125;
        uint64_t v92 = "%{public}s protocol %{public}s has invalid disconnect callback, no backtrace";
        uint64_t v108 = loga;
        os_log_type_t v109 = v133;
        goto LABEL_169;
      }
    }
LABEL_170:
    if (v140) {
      free(v140);
    }
    if (!v14)
    {
      __nwlog_obj();
      uint64_t v74 = "invalid";
      goto LABEL_174;
    }
LABEL_15:
    uint64_t v17 = *(void *)(v14 + 24);
    if (v17)
    {
      BOOL v18 = *(void (**)(uint64_t, char *, uint64_t))(v17 + 8);
      if (v18)
      {
        v18(v14, handle + 64, 1);
LABEL_18:
        nw_protocol_set_output_handler((uint64_t)(handle + 64), 0);
        if ((*v11 & 0x800) == 0)
        {
          if (gLogDatapath)
          {
            int v97 = __nwlog_obj();
            if (os_log_type_enabled(v97, OS_LOG_TYPE_DEBUG))
            {
              int v98 = *(_DWORD *)(*((void *)handle + 42) + 1280);
              uint64_t v99 = *((void *)handle + 30);
              unint64_t v100 = (nw_protocol *)*((void *)handle + 31);
              *(_DWORD *)buf = 136447490;
              *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_stop_datagram_flow";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = handle + 636;
              *(_WORD *)&unsigned char buf[22] = 2080;
              uint64_t v145 = (uint64_t)" ";
              LOWORD(v146) = 1024;
              *(_DWORD *)((char *)&v146 + 2) = v98;
              WORD3(v146) = 2048;
              *((void *)&v146 + 1) = v99;
              __int16 v147 = 2048;
              uint64_t v148 = v100;
              _os_log_impl(&dword_1830D4000, v97, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> Closed datagram flow %llu", buf, 0x3Au);
            }
          }
        }
        goto LABEL_20;
      }
    }
    __nwlog_obj();
    uint64_t v74 = *(const char **)(v14 + 16);
    if (!v74) {
      uint64_t v74 = "invalid";
    }
LABEL_174:
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_stop_datagram_flow";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v74;
    BOOL v110 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v142 = 0;
    uint64_t v141 = (char *)v110;
    if (!__nwlog_fault(v110, &type, &v142)) {
      goto LABEL_196;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v111 = __nwlog_obj();
      os_log_type_t v112 = type;
      os_log_t logb = v111;
      if (!os_log_type_enabled(v111, type)) {
        goto LABEL_196;
      }
      uint64_t v113 = "invalid";
      if (v14 && *(void *)(v14 + 16)) {
        uint64_t v113 = *(const char **)(v14 + 16);
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_stop_datagram_flow";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v113;
      int v114 = "%{public}s protocol %{public}s has invalid remove_input_handler callback";
    }
    else
    {
      if (v142)
      {
        int v115 = (char *)__nw_create_backtrace_string();
        logc = __nwlog_obj();
        os_log_type_t v134 = type;
        BOOL v116 = os_log_type_enabled(logc, type);
        if (v115)
        {
          if (v116)
          {
            char v117 = "invalid";
            if (v14 && *(void *)(v14 + 16)) {
              char v117 = *(const char **)(v14 + 16);
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_stop_datagram_flow";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v117;
            *(_WORD *)&unsigned char buf[22] = 2082;
            uint64_t v145 = (uint64_t)v115;
            _os_log_impl(&dword_1830D4000, logc, v134, "%{public}s protocol %{public}s has invalid remove_input_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(v115);
          goto LABEL_196;
        }
        if (!v116)
        {
LABEL_196:
          if (v141) {
            free(v141);
          }
          goto LABEL_18;
        }
        int v126 = "invalid";
        if (v14 && *(void *)(v14 + 16)) {
          int v126 = *(const char **)(v14 + 16);
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_stop_datagram_flow";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v126;
        int v114 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, no backtrace";
        uint64_t v120 = logc;
        os_log_type_t v121 = v134;
LABEL_195:
        _os_log_impl(&dword_1830D4000, v120, v121, v114, buf, 0x16u);
        goto LABEL_196;
      }
      char v118 = __nwlog_obj();
      os_log_type_t v112 = type;
      os_log_t logb = v118;
      if (!os_log_type_enabled(v118, type)) {
        goto LABEL_196;
      }
      unint64_t v119 = "invalid";
      if (v14 && *(void *)(v14 + 16)) {
        unint64_t v119 = *(const char **)(v14 + 16);
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_stop_datagram_flow";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v119;
      int v114 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, backtrace limit exceeded";
    }
    uint64_t v120 = logb;
    os_log_type_t v121 = v112;
    goto LABEL_195;
  }
LABEL_20:
  uint64_t v19 = *((void *)handle + 42);
  if (!v19) {
    goto LABEL_56;
  }
  uint64_t v20 = (void *)(v19 + 576);
  while (1)
  {
    uint64_t v20 = (void *)*v20;
    if (!v20) {
      break;
    }
    if ((char *)v20[4] == handle)
    {
      int v21 = *(FILE **)(v19 + 544);
      if (v21)
      {
        fwrite("qdec: debug: ", 0xDuLL, 1uLL, v21);
        fprintf(*(FILE **)(v19 + 544), "unreffed header block for stream %llu", v20[5]);
        fputc(10, *(FILE **)(v19 + 544));
      }
      uint64_t v22 = (void *)*v20;
      os_log_type_t v23 = (void *)v20[1];
      if (*v20)
      {
        v22[1] = v23;
        os_log_type_t v23 = (void *)v20[1];
      }
      else
      {
        *(void *)(v19 + 584) = v23;
      }
      *os_log_type_t v23 = v22;
      if ((v20[13] & 4) != 0)
      {
        uint64_t v25 = v20[2];
        if (v25) {
          *(void *)(v25 + 24) = v20[3];
        }
        else {
          *(void *)(v19 + 16 * (v20[8] & 7) + 600) = v20[3];
        }
        *(void *)v20[3] = v25;
        --*(_DWORD *)(v19 + 720);
      }
      free(v20);
      goto LABEL_37;
    }
  }
  BOOL v24 = *(FILE **)(v19 + 544);
  if (v24)
  {
    fwrite("qdec: info: ", 0xCuLL, 1uLL, v24);
    fwrite("could not find header block to unref", 0x24uLL, 1uLL, *(FILE **)(v19 + 544));
    fputc(10, *(FILE **)(v19 + 544));
  }
LABEL_37:
  uint64_t v26 = *((void *)handle + 42);
  if (v26)
  {
    if (((*(unsigned __int16 *)(v26 + 1373) | (*(unsigned __int8 *)(v26 + 1375) << 16)) & 0x400000) == 0)
    {
      if (gLogDatapath)
      {
        uint64_t v79 = __nwlog_obj();
        if (os_log_type_enabled(v79, OS_LOG_TYPE_DEBUG))
        {
          int v80 = *(_DWORD *)(v26 + 1280);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_http3_remove_stream";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v26 + 1289;
          *(_WORD *)&unsigned char buf[22] = 2080;
          uint64_t v145 = (uint64_t)" ";
          LOWORD(v146) = 1024;
          *(_DWORD *)((char *)&v146 + 2) = v80;
          _os_log_impl(&dword_1830D4000, v79, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
        }
      }
    }
    if (!*((_DWORD *)handle + 93))
    {
      uint64_t v29 = *((void *)handle + 29);
      if (v29)
      {
        uint64_t v30 = mach_continuous_approximate_time();
        uint64_t v31 = v30 <= 1 ? 1 : v30;
        unint64_t v32 = nw_delta_nanos(v29, v31);
        if (v32 > 1000000000
                 * networkd_settings_get_int64_with_default((const char *)nw_setting_proxy_setup_threshold_seconds, 5))
        {
          int v33 = (unsigned __int16)(*(_WORD *)(v26 + 1284))++ + 1;
          if ((v33 & 0x10000) != 0)
          {
            if (gLogDatapath)
            {
              uint64_t v131 = __nwlog_obj();
              if (os_log_type_enabled(v131, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v132 = *(unsigned __int16 *)(v26 + 1284);
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_http3_remove_stream";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = "http3->stream_stall_count";
                *(_WORD *)&unsigned char buf[22] = 2048;
                uint64_t v145 = 1;
                LOWORD(v146) = 2048;
                *(void *)((char *)&v146 + 2) = v132;
                _os_log_impl(&dword_1830D4000, v131, OS_LOG_TYPE_DEBUG, "%{public}s Overflow: %{public}s, increment %llu, result %llu", buf, 0x2Au);
              }
            }
            *(_WORD *)(v26 + 1284) = -1;
          }
          if (((*(unsigned __int16 *)(v26 + 1373) | (*(unsigned __int8 *)(v26 + 1375) << 16)) & 0x400000) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v34 = gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
            {
              int v35 = *(_DWORD *)(v26 + 1280);
              int v36 = *(unsigned __int16 *)(v26 + 1284);
              *(_DWORD *)buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_http3_remove_stream";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v26 + 1289;
              *(_WORD *)&unsigned char buf[22] = 2080;
              uint64_t v145 = (uint64_t)" ";
              LOWORD(v146) = 1024;
              *(_DWORD *)((char *)&v146 + 2) = v35;
              WORD3(v146) = 1024;
              DWORD2(v146) = v36;
              _os_log_impl(&dword_1830D4000, v34, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> stream setup stalls incremented to %u", buf, 0x2Cu);
            }
          }
        }
      }
    }
    uint64_t v27 = *((void *)handle + 68);
    BOOL v28 = (void *)*((void *)handle + 69);
    if (v27)
    {
      *(void *)(v27 + 552) = v28;
      BOOL v28 = (void *)*((void *)handle + 69);
    }
    else
    {
      *(void *)(v26 + 888) = v28;
    }
    *BOOL v28 = v27;
    *((void *)handle + 68) = 0;
    *((void *)handle + 69) = 0;
    nw_protocol_http3_remove_input_handler((nw_protocol *)v26, *((nw_protocol **)handle + 6));
    goto LABEL_56;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_http3_remove_stream";
  uint64_t v75 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v142 = 0;
  if (__nwlog_fault(v75, &type, &v142))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v76 = __nwlog_obj();
      os_log_type_t v77 = type;
      if (!os_log_type_enabled(v76, type)) {
        goto LABEL_236;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http3_remove_stream";
      int v78 = "%{public}s called with null http3";
LABEL_234:
      unsigned int v130 = v76;
LABEL_235:
      _os_log_impl(&dword_1830D4000, v130, v77, v78, buf, 0xCu);
      goto LABEL_236;
    }
    if (!v142)
    {
      uint64_t v76 = __nwlog_obj();
      os_log_type_t v77 = type;
      if (!os_log_type_enabled(v76, type)) {
        goto LABEL_236;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http3_remove_stream";
      int v78 = "%{public}s called with null http3, backtrace limit exceeded";
      goto LABEL_234;
    }
    uint64_t v103 = (char *)__nw_create_backtrace_string();
    unint64_t v104 = __nwlog_obj();
    os_log_type_t v77 = type;
    uint64_t v139 = v104;
    BOOL v105 = os_log_type_enabled(v104, type);
    if (v103)
    {
      if (v105)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http3_remove_stream";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v103;
        _os_log_impl(&dword_1830D4000, v139, v77, "%{public}s called with null http3, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v103);
      goto LABEL_236;
    }
    if (v105)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http3_remove_stream";
      int v78 = "%{public}s called with null http3, no backtrace";
      unsigned int v130 = v139;
      goto LABEL_235;
    }
  }
LABEL_236:
  if (v75) {
    free(v75);
  }
LABEL_56:
  *((void *)handle + 20) = 0;
  *((void *)handle + 21) = 0;
  if (a1->default_input_handler != a2) {
    return 0;
  }
  nw_protocol_set_input_handler((uint64_t)a1, 0);
  if (gLogDatapath)
  {
    os_log_type_t v101 = __nwlog_obj();
    if (os_log_type_enabled(v101, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
      _os_log_impl(&dword_1830D4000, v101, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }
  *(void *)buf = MEMORY[0x1E4F143A8];
  *(void *)&buf[8] = 0x40000000;
  *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_61444;
  uint64_t v145 = (uint64_t)&__block_descriptor_tmp_30_61445;
  *(void *)&long long v146 = handle + 216;
  BYTE8(v146) = 0;
  uint64_t v38 = *((void *)handle + 27);
  do
  {
    if (!v38) {
      break;
    }
    uint64_t v39 = *(void *)(v38 + 32);
    char v40 = (*(uint64_t (**)(unsigned char *))&buf[16])(buf);
    uint64_t v38 = v39;
  }
  while ((v40 & 1) != 0);
  uint64_t v41 = *((void *)handle + 22);
  do
  {
    if (!v41) {
      break;
    }
    uint64_t v42 = *(void *)(v41 + 32);
    char v43 = ___ZL23nw_http3_framer_cleanupP15nw_http3_framer_block_invoke((uint64_t)&__block_literal_global_29, (_DWORD *)v41);
    uint64_t v41 = v42;
  }
  while ((v43 & 1) != 0);
  if (gLogDatapath)
  {
    int v102 = __nwlog_obj();
    if (os_log_type_enabled(v102, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
      _os_log_impl(&dword_1830D4000, v102, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }
  *(void *)buf = MEMORY[0x1E4F143A8];
  *(void *)&buf[8] = 0x40000000;
  *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_61444;
  uint64_t v145 = (uint64_t)&__block_descriptor_tmp_30_61445;
  *(void *)&long long v146 = handle + 176;
  BYTE8(v146) = 0;
  uint64_t v44 = *((void *)handle + 22);
  do
  {
    if (!v44) {
      break;
    }
    uint64_t v45 = *(void *)(v44 + 32);
    char v46 = (*(uint64_t (**)(unsigned char *))&buf[16])(buf);
    uint64_t v44 = v45;
  }
  while ((v46 & 1) != 0);
  *((_DWORD *)handle + 48) = 0;
  uint64_t v47 = *((void *)handle + 47);
  if (v47)
  {
    nw_frame_finalize(v47);
    *((void *)handle + 47) = 0;
  }
  if (*((void *)handle + 66) || handle[634] || handle[635])
  {
    uint64_t v48 = *((void *)handle + 42);
    if ((*(_WORD *)(v48 + 1373) & 8) == 0 && (*v11 & 0x800) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v49 = gLogObj;
      BOOL v50 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
      uint64_t v48 = *((void *)handle + 42);
      if (v50)
      {
        int v51 = *(_DWORD *)(v48 + 1280);
        uint64_t v52 = *((void *)handle + 30);
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_remove_input_handler";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = handle + 636;
        *(_WORD *)&unsigned char buf[22] = 2080;
        uint64_t v145 = (uint64_t)" ";
        LOWORD(v146) = 1024;
        *(_DWORD *)((char *)&v146 + 2) = v51;
        WORD3(v146) = 2048;
        *((void *)&v146 + 1) = v52;
        _os_log_impl(&dword_1830D4000, v49, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%llu> cancelled while sending data on uni streams", buf, 0x30u);
        uint64_t v48 = *((void *)handle + 42);
      }
    }
    nw_http3_fail_all_streams(v48, 258);
  }
  output_handler = a1->output_handler;
  if (!output_handler
    || (callbacks = output_handler->callbacks) == 0
    || (remove_input_handler = (void (*)(nw_protocol *, nw_protocol *))callbacks->remove_input_handler) == 0)
  {
    __nwlog_obj();
    uint64_t v56 = a1->output_handler;
    uint64_t v57 = "invalid";
    if (v56)
    {
      identifier = v56->identifier;
      if (identifier) {
        uint64_t v57 = (const char *)identifier;
      }
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_remove_input_handler";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v57;
    BOOL v59 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v142 = 0;
    if (!__nwlog_fault(v59, &type, &v142)) {
      goto LABEL_223;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v60 = __nwlog_obj();
      os_log_type_t v61 = type;
      if (!os_log_type_enabled(v60, type)) {
        goto LABEL_223;
      }
      uint32_t v62 = a1->output_handler;
      BOOL v63 = "invalid";
      if (v62)
      {
        int v64 = v62->identifier;
        if (v64) {
          BOOL v63 = (const char *)v64;
        }
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_remove_input_handler";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v63;
      uint64_t v65 = "%{public}s protocol %{public}s has invalid remove_input_handler callback";
    }
    else if (v142)
    {
      unint64_t v81 = (char *)__nw_create_backtrace_string();
      uint64_t v60 = __nwlog_obj();
      os_log_type_t v61 = type;
      BOOL v82 = os_log_type_enabled(v60, type);
      if (v81)
      {
        if (v82)
        {
          uint64_t v83 = a1->output_handler;
          uint64_t v84 = "invalid";
          if (v83)
          {
            char v85 = v83->identifier;
            if (v85) {
              uint64_t v84 = (const char *)v85;
            }
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_remove_input_handler";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v84;
          *(_WORD *)&unsigned char buf[22] = 2082;
          uint64_t v145 = (uint64_t)v81;
          _os_log_impl(&dword_1830D4000, v60, v61, "%{public}s protocol %{public}s has invalid remove_input_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v81);
        goto LABEL_223;
      }
      if (!v82)
      {
LABEL_223:
        if (v59) {
          free(v59);
        }
        goto LABEL_83;
      }
      char v127 = a1->output_handler;
      id v128 = "invalid";
      if (v127)
      {
        uint64_t v129 = v127->identifier;
        if (v129) {
          id v128 = (const char *)v129;
        }
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_remove_input_handler";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v128;
      uint64_t v65 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, no backtrace";
    }
    else
    {
      uint64_t v60 = __nwlog_obj();
      os_log_type_t v61 = type;
      if (!os_log_type_enabled(v60, type)) {
        goto LABEL_223;
      }
      unsigned int v122 = a1->output_handler;
      unsigned int v123 = "invalid";
      if (v122)
      {
        unsigned int v124 = v122->identifier;
        if (v124) {
          unsigned int v123 = (const char *)v124;
        }
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_remove_input_handler";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v123;
      uint64_t v65 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v60, v61, v65, buf, 0x16u);
    goto LABEL_223;
  }
  remove_input_handler(output_handler, a1);
LABEL_83:
  nw_protocol_set_output_handler((uint64_t)a1, 0);
  if (a3)
  {
    a1->uint64_t handle = 0;
    nw_protocol_http3_stream_destroy((uint64_t)handle);
  }
  return 1;
}

BOOL nw_protocol_http3_stream_add_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v42 = "nw_protocol_http3_stream_add_input_handler";
    int v21 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (!__nwlog_fault(v21, &type, &v39)) {
      goto LABEL_62;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_62;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v42 = "nw_protocol_http3_stream_add_input_handler";
      BOOL v24 = "%{public}s called with null protocol";
      goto LABEL_61;
    }
    if (!v39)
    {
      uint64_t v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_62;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v42 = "nw_protocol_http3_stream_add_input_handler";
      BOOL v24 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_61;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v22 = __nwlog_obj();
    os_log_type_t v23 = type;
    BOOL v29 = os_log_type_enabled(v22, type);
    if (!backtrace_string)
    {
      if (!v29) {
        goto LABEL_62;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v42 = "nw_protocol_http3_stream_add_input_handler";
      BOOL v24 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_61;
    }
    if (v29)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v42 = "nw_protocol_http3_stream_add_input_handler";
      __int16 v43 = 2082;
      uint64_t v44 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_62:
    if (!v21) {
      return 0;
    }
LABEL_63:
    free(v21);
    return 0;
  }
  uint64_t handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v42 = "nw_protocol_http3_stream_add_input_handler";
    int v21 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (!__nwlog_fault(v21, &type, &v39)) {
      goto LABEL_62;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_62;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v42 = "nw_protocol_http3_stream_add_input_handler";
      BOOL v24 = "%{public}s called with null http3_stream";
      goto LABEL_61;
    }
    if (!v39)
    {
      uint64_t v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_62;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v42 = "nw_protocol_http3_stream_add_input_handler";
      BOOL v24 = "%{public}s called with null http3_stream, backtrace limit exceeded";
      goto LABEL_61;
    }
    uint64_t v30 = (char *)__nw_create_backtrace_string();
    uint64_t v22 = __nwlog_obj();
    os_log_type_t v23 = type;
    BOOL v31 = os_log_type_enabled(v22, type);
    if (v30)
    {
      if (v31)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v42 = "nw_protocol_http3_stream_add_input_handler";
        __int16 v43 = 2082;
        uint64_t v44 = v30;
        _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s called with null http3_stream, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v30);
      if (!v21) {
        return 0;
      }
      goto LABEL_63;
    }
    if (v31)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v42 = "nw_protocol_http3_stream_add_input_handler";
      BOOL v24 = "%{public}s called with null http3_stream, no backtrace";
LABEL_61:
      _os_log_impl(&dword_1830D4000, v22, v23, v24, buf, 0xCu);
      goto LABEL_62;
    }
    goto LABEL_62;
  }
  if ((*((_WORD *)handle + 368) & 0x800) == 0)
  {
    if (gLogDatapath)
    {
      uint64_t v25 = __nwlog_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
      {
        int v26 = *(_DWORD *)(*((void *)handle + 42) + 1280);
        uint64_t v27 = *((void *)handle + 30);
        *(_DWORD *)buf = 136447234;
        uint64_t v42 = "nw_protocol_http3_stream_add_input_handler";
        __int16 v43 = 2082;
        uint64_t v44 = handle + 636;
        __int16 v45 = 2080;
        char v46 = " ";
        __int16 v47 = 1024;
        int v48 = v26;
        __int16 v49 = 2048;
        uint64_t v50 = v27;
        _os_log_impl(&dword_1830D4000, v25, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called", buf, 0x30u);
      }
    }
  }
  uint64_t v5 = handle + 736;
  uint64_t v6 = (nw_protocol *)*((void *)handle + 42);
  if (v6) {
    BOOL v7 = a1->default_input_handler == a2;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    if ((*v5 & 0x800) == 0)
    {
      if (gLogDatapath)
      {
        unint64_t v32 = __nwlog_obj();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
        {
          int v33 = *(_DWORD *)(*((void *)handle + 42) + 1280);
          uint64_t v34 = *((void *)handle + 30);
          *(_DWORD *)buf = 136447490;
          uint64_t v42 = "nw_protocol_http3_stream_add_input_handler";
          __int16 v43 = 2082;
          uint64_t v44 = handle + 636;
          __int16 v45 = 2080;
          char v46 = " ";
          __int16 v47 = 1024;
          int v48 = v33;
          __int16 v49 = 2048;
          uint64_t v50 = v34;
          __int16 v51 = 2048;
          uint64_t v52 = handle;
          _os_log_impl(&dword_1830D4000, v32, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> Peeling off a new stream from %p", buf, 0x3Au);
        }
      }
    }
    parameters = (char *)nw_protocol_get_parameters((uint64_t)a2);
    if (parameters)
    {
      BOOL v16 = parameters;
      nw_http3_stream_replace_protocol_instance((uint64_t)handle, parameters, (nw_protocol *)handle, (uint64_t)v6);
      if ((*v5 & 0x800) == 0)
      {
        if (gLogDatapath)
        {
          int v35 = __nwlog_obj();
          if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
          {
            int v36 = *(_DWORD *)(*((void *)handle + 42) + 1280);
            uint64_t v37 = *((void *)handle + 30);
            *(_DWORD *)buf = 136447490;
            uint64_t v42 = "nw_protocol_http3_stream_add_input_handler";
            __int16 v43 = 2082;
            uint64_t v44 = handle + 636;
            __int16 v45 = 2080;
            char v46 = " ";
            __int16 v47 = 1024;
            int v48 = v36;
            __int16 v49 = 2048;
            uint64_t v50 = v37;
            __int16 v51 = 2048;
            uint64_t v52 = v16;
            _os_log_impl(&dword_1830D4000, v35, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> Set connection protocol as instance in peeled off parameters %p", buf, 0x3Au);
          }
        }
      }
    }
    uint64_t v17 = *((void *)handle + 42);
    if (v17)
    {
      *(_WORD *)(v17 + 1373) |= 0x8000u;
      BOOL result = nw_protocol_http3_add_input_handler(v6, a2);
      uint64_t v18 = *((void *)handle + 42);
      int v19 = *(unsigned __int16 *)(v18 + 1373);
      unsigned int v20 = v19 & 0xFFFF7FFF | (*(unsigned __int8 *)(v18 + 1375) << 16);
      *(_WORD *)(v18 + 1373) = v19 & 0x7FFF;
      *(unsigned char *)(v18 + 1375) = BYTE2(v20);
      return result;
    }
    return 0;
  }
  if (v6)
  {
    BOOL result = 0;
    if ((*v5 & 0x800) == 0)
    {
      if (gLogDatapath)
      {
        uint64_t v9 = __nwlog_obj();
        BOOL result = os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG);
        if (result)
        {
          int v10 = *(_DWORD *)(*((void *)handle + 42) + 1280);
          uint64_t v11 = *((void *)handle + 30);
          *(_DWORD *)buf = 136447234;
          uint64_t v42 = "nw_protocol_http3_stream_add_input_handler";
          __int16 v43 = 2082;
          uint64_t v44 = handle + 636;
          __int16 v45 = 2080;
          char v46 = " ";
          __int16 v47 = 1024;
          int v48 = v10;
          __int16 v49 = 2048;
          uint64_t v50 = v11;
          int v12 = "%{public}s %{public}s%s<i%u:s%llu> Rejecting duplicate request for a stream";
          unsigned int v13 = v9;
          uint32_t v14 = 48;
LABEL_52:
          _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_DEBUG, v12, buf, v14);
          return 0;
        }
      }
    }
  }
  else
  {
    if (!gLogDatapath) {
      return 0;
    }
    uint64_t v38 = __nwlog_obj();
    BOOL result = os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG);
    if (result)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v42 = "nw_protocol_http3_stream_add_input_handler";
      int v12 = "%{public}s Rejecting duplicate request for a stream";
      unsigned int v13 = v38;
      uint32_t v14 = 12;
      goto LABEL_52;
    }
  }
  return result;
}

void nw_protocol_http3_stream_input_finished(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v104 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v95 = "nw_protocol_http3_stream_input_finished";
    uint64_t v41 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v92 = 0;
    if (!__nwlog_fault(v41, &type, &v92)) {
      goto LABEL_152;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v42 = __nwlog_obj();
      os_log_type_t v43 = type;
      if (!os_log_type_enabled(v42, type)) {
        goto LABEL_152;
      }
      *(_DWORD *)buf = 136446210;
      int v95 = "nw_protocol_http3_stream_input_finished";
      uint64_t v44 = "%{public}s called with null protocol";
    }
    else if (v92)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v42 = __nwlog_obj();
      os_log_type_t v43 = type;
      BOOL v56 = os_log_type_enabled(v42, type);
      if (backtrace_string)
      {
        if (v56)
        {
          *(_DWORD *)buf = 136446466;
          int v95 = "nw_protocol_http3_stream_input_finished";
          __int16 v96 = 2082;
          int v97 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v42, v43, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_152:
        if (!v41) {
          return;
        }
        goto LABEL_153;
      }
      if (!v56) {
        goto LABEL_152;
      }
      *(_DWORD *)buf = 136446210;
      int v95 = "nw_protocol_http3_stream_input_finished";
      uint64_t v44 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      uint64_t v42 = __nwlog_obj();
      os_log_type_t v43 = type;
      if (!os_log_type_enabled(v42, type)) {
        goto LABEL_152;
      }
      *(_DWORD *)buf = 136446210;
      int v95 = "nw_protocol_http3_stream_input_finished";
      uint64_t v44 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_151;
  }
  uint64_t handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v95 = "nw_protocol_http3_stream_input_finished";
    uint64_t v41 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v92 = 0;
    if (!__nwlog_fault(v41, &type, &v92)) {
      goto LABEL_152;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v92)
      {
        uint64_t v42 = __nwlog_obj();
        os_log_type_t v43 = type;
        if (!os_log_type_enabled(v42, type)) {
          goto LABEL_152;
        }
        *(_DWORD *)buf = 136446210;
        int v95 = "nw_protocol_http3_stream_input_finished";
        uint64_t v44 = "%{public}s called with null http3_stream, backtrace limit exceeded";
        goto LABEL_151;
      }
      uint64_t v57 = (char *)__nw_create_backtrace_string();
      uint64_t v42 = __nwlog_obj();
      os_log_type_t v43 = type;
      BOOL v58 = os_log_type_enabled(v42, type);
      if (!v57)
      {
        if (!v58) {
          goto LABEL_152;
        }
        *(_DWORD *)buf = 136446210;
        int v95 = "nw_protocol_http3_stream_input_finished";
        uint64_t v44 = "%{public}s called with null http3_stream, no backtrace";
        goto LABEL_151;
      }
      if (v58)
      {
        *(_DWORD *)buf = 136446466;
        int v95 = "nw_protocol_http3_stream_input_finished";
        __int16 v96 = 2082;
        int v97 = v57;
        BOOL v59 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
LABEL_98:
        _os_log_impl(&dword_1830D4000, v42, v43, v59, buf, 0x16u);
      }
LABEL_99:
      free(v57);
      if (!v41) {
        return;
      }
LABEL_153:
      BOOL v87 = (char *)v41;
LABEL_167:
      free(v87);
      return;
    }
    uint64_t v42 = __nwlog_obj();
    os_log_type_t v43 = type;
    if (!os_log_type_enabled(v42, type)) {
      goto LABEL_152;
    }
    *(_DWORD *)buf = 136446210;
    int v95 = "nw_protocol_http3_stream_input_finished";
    uint64_t v44 = "%{public}s called with null http3_stream";
LABEL_151:
    _os_log_impl(&dword_1830D4000, v42, v43, v44, buf, 0xCu);
    goto LABEL_152;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v95 = "nw_protocol_http3_stream_input_finished";
    uint64_t v41 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v92 = 0;
    if (!__nwlog_fault(v41, &type, &v92)) {
      goto LABEL_152;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v42 = __nwlog_obj();
      os_log_type_t v43 = type;
      if (!os_log_type_enabled(v42, type)) {
        goto LABEL_152;
      }
      *(_DWORD *)buf = 136446210;
      int v95 = "nw_protocol_http3_stream_input_finished";
      uint64_t v44 = "%{public}s called with null other_protocol";
      goto LABEL_151;
    }
    if (!v92)
    {
      uint64_t v42 = __nwlog_obj();
      os_log_type_t v43 = type;
      if (!os_log_type_enabled(v42, type)) {
        goto LABEL_152;
      }
      *(_DWORD *)buf = 136446210;
      int v95 = "nw_protocol_http3_stream_input_finished";
      uint64_t v44 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_151;
    }
    uint64_t v57 = (char *)__nw_create_backtrace_string();
    uint64_t v42 = __nwlog_obj();
    os_log_type_t v43 = type;
    BOOL v60 = os_log_type_enabled(v42, type);
    if (!v57)
    {
      if (!v60) {
        goto LABEL_152;
      }
      *(_DWORD *)buf = 136446210;
      int v95 = "nw_protocol_http3_stream_input_finished";
      uint64_t v44 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_151;
    }
    if (v60)
    {
      *(_DWORD *)buf = 136446466;
      int v95 = "nw_protocol_http3_stream_input_finished";
      __int16 v96 = 2082;
      int v97 = v57;
      BOOL v59 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_98;
    }
    goto LABEL_99;
  }
  unsigned int v4 = *((_DWORD *)handle + 93);
  if (v4 > 8) {
    return;
  }
  if (((1 << v4) & 0x67) != 0)
  {
    uint64_t v5 = handle + 736;
    if ((*((_WORD *)handle + 368) & 0x800) == 0)
    {
      if (gLogDatapath)
      {
        os_log_type_t v61 = __nwlog_obj();
        if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG))
        {
          int v62 = *(_DWORD *)(*((void *)handle + 42) + 1280);
          uint64_t v63 = *((void *)handle + 30);
          *(_DWORD *)buf = 136447234;
          int v95 = "nw_protocol_http3_stream_input_finished";
          __int16 v96 = 2082;
          int v97 = handle + 636;
          __int16 v98 = 2080;
          uint64_t v99 = " ";
          __int16 v100 = 1024;
          int v101 = v62;
          __int16 v102 = 2048;
          uint64_t v103 = v63;
          _os_log_impl(&dword_1830D4000, v61, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> deferring input finished", buf, 0x30u);
        }
      }
    }
    *v5 |= 0x100u;
    default_input_handler = a1->default_input_handler;
    if (default_input_handler)
    {
      callbacks = default_input_handler->callbacks;
      if (callbacks)
      {
        input_available = (void (*)(void))callbacks->input_available;
        if (input_available)
        {
          input_available();
          goto LABEL_12;
        }
      }
    }
    __nwlog_obj();
    int v26 = a1->default_input_handler;
    uint64_t v27 = "invalid";
    if (v26)
    {
      identifier = v26->identifier;
      if (identifier) {
        uint64_t v27 = (const char *)identifier;
      }
    }
    *(_DWORD *)buf = 136446466;
    int v95 = "nw_protocol_http3_stream_input_finished";
    __int16 v96 = 2082;
    int v97 = (char *)v27;
    BOOL v29 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v92 = 0;
    if (__nwlog_fault(v29, &type, &v92))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v30 = __nwlog_obj();
        os_log_type_t v31 = type;
        if (!os_log_type_enabled(v30, type)) {
          goto LABEL_138;
        }
        unint64_t v32 = a1->default_input_handler;
        int v33 = "invalid";
        if (v32)
        {
          uint64_t v34 = v32->identifier;
          if (v34) {
            int v33 = (const char *)v34;
          }
        }
        *(_DWORD *)buf = 136446466;
        int v95 = "nw_protocol_http3_stream_input_finished";
        __int16 v96 = 2082;
        int v97 = (char *)v33;
        int v35 = "%{public}s protocol %{public}s has invalid input_available callback";
        goto LABEL_137;
      }
      if (!v92)
      {
        uint64_t v30 = __nwlog_obj();
        os_log_type_t v31 = type;
        if (!os_log_type_enabled(v30, type)) {
          goto LABEL_138;
        }
        uint64_t v72 = a1->default_input_handler;
        uint64_t v73 = "invalid";
        if (v72)
        {
          uint64_t v74 = v72->identifier;
          if (v74) {
            uint64_t v73 = (const char *)v74;
          }
        }
        *(_DWORD *)buf = 136446466;
        int v95 = "nw_protocol_http3_stream_input_finished";
        __int16 v96 = 2082;
        int v97 = (char *)v73;
        int v35 = "%{public}s protocol %{public}s has invalid input_available callback, backtrace limit exceeded";
        goto LABEL_137;
      }
      __int16 v45 = (char *)__nw_create_backtrace_string();
      uint64_t v30 = __nwlog_obj();
      os_log_type_t v31 = type;
      BOOL v46 = os_log_type_enabled(v30, type);
      if (v45)
      {
        if (v46)
        {
          __int16 v47 = a1->default_input_handler;
          int v48 = "invalid";
          if (v47)
          {
            __int16 v49 = v47->identifier;
            if (v49) {
              int v48 = (const char *)v49;
            }
          }
          *(_DWORD *)buf = 136446722;
          int v95 = "nw_protocol_http3_stream_input_finished";
          __int16 v96 = 2082;
          int v97 = (char *)v48;
          __int16 v98 = 2082;
          uint64_t v99 = v45;
          _os_log_impl(&dword_1830D4000, v30, v31, "%{public}s protocol %{public}s has invalid input_available callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v45);
        goto LABEL_138;
      }
      if (v46)
      {
        unint64_t v81 = a1->default_input_handler;
        BOOL v82 = "invalid";
        if (v81)
        {
          uint64_t v83 = v81->identifier;
          if (v83) {
            BOOL v82 = (const char *)v83;
          }
        }
        *(_DWORD *)buf = 136446466;
        int v95 = "nw_protocol_http3_stream_input_finished";
        __int16 v96 = 2082;
        int v97 = (char *)v82;
        int v35 = "%{public}s protocol %{public}s has invalid input_available callback, no backtrace";
LABEL_137:
        _os_log_impl(&dword_1830D4000, v30, v31, v35, buf, 0x16u);
      }
    }
LABEL_138:
    if (v29) {
      free(v29);
    }
LABEL_12:
    if ((*v5 & 0x100) == 0) {
      return;
    }
    unsigned int v9 = *((_DWORD *)handle + 93);
    if (v9 > 8 || ((1 << v9) & 0x198) == 0) {
      return;
    }
    if ((*v5 & 0x800) == 0)
    {
      if (gLogDatapath)
      {
        int v78 = __nwlog_obj();
        if (os_log_type_enabled(v78, OS_LOG_TYPE_DEBUG))
        {
          int v79 = *(_DWORD *)(*((void *)handle + 42) + 1280);
          uint64_t v80 = *((void *)handle + 30);
          *(_DWORD *)buf = 136447234;
          int v95 = "nw_protocol_http3_stream_input_finished";
          __int16 v96 = 2082;
          int v97 = handle + 636;
          __int16 v98 = 2080;
          uint64_t v99 = " ";
          __int16 v100 = 1024;
          int v101 = v79;
          __int16 v102 = 2048;
          uint64_t v103 = v80;
          _os_log_impl(&dword_1830D4000, v78, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> delivering deferred input finished", buf, 0x30u);
        }
      }
    }
    int v10 = (unsigned __int16)*v5;
    unsigned int v11 = v10 & 0xFFFFFEFF | (handle[738] << 16);
    _WORD *v5 = v10 & 0xFEFF;
    handle[738] = BYTE2(v11);
    int v12 = a1->default_input_handler;
    if (!v12
      || (unsigned int v13 = v12->callbacks) == 0
      || (input_finished = (void (*)(nw_protocol *, nw_protocol *))v13->input_finished) == 0)
    {
      __nwlog_obj();
      uint64_t v15 = a1->default_input_handler;
      BOOL v16 = "invalid";
      if (v15)
      {
        uint64_t v17 = v15->identifier;
        if (v17) {
          BOOL v16 = (const char *)v17;
        }
      }
      *(_DWORD *)buf = 136446466;
      int v95 = "nw_protocol_http3_stream_input_finished";
      __int16 v96 = 2082;
      int v97 = (char *)v16;
      uint64_t v18 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v92 = 0;
      if (!__nwlog_fault(v18, &type, &v92)) {
        goto LABEL_165;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v19 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (!os_log_type_enabled(v19, type)) {
          goto LABEL_165;
        }
        int v21 = a1->default_input_handler;
        uint64_t v22 = "invalid";
        if (v21)
        {
          os_log_type_t v23 = v21->identifier;
          if (v23) {
            uint64_t v22 = (const char *)v23;
          }
        }
LABEL_29:
        *(_DWORD *)buf = 136446466;
        int v95 = "nw_protocol_http3_stream_input_finished";
        __int16 v96 = 2082;
        int v97 = (char *)v22;
        BOOL v24 = "%{public}s protocol %{public}s has invalid input_finished callback";
LABEL_164:
        _os_log_impl(&dword_1830D4000, v19, v20, v24, buf, 0x16u);
        goto LABEL_165;
      }
      if (v92)
      {
        uint32_t v67 = (char *)__nw_create_backtrace_string();
        int v19 = __nwlog_obj();
        os_log_type_t v20 = type;
        BOOL v68 = os_log_type_enabled(v19, type);
        if (v67)
        {
          if (v68)
          {
            uint64_t v69 = a1->default_input_handler;
            int v70 = "invalid";
            if (v69)
            {
              int v71 = v69->identifier;
              if (v71) {
                int v70 = (const char *)v71;
              }
            }
            *(_DWORD *)buf = 136446722;
            int v95 = "nw_protocol_http3_stream_input_finished";
            __int16 v96 = 2082;
            int v97 = (char *)v70;
            __int16 v98 = 2082;
            uint64_t v99 = v67;
            _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s protocol %{public}s has invalid input_finished callback, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(v67);
          if (v18) {
            goto LABEL_166;
          }
          return;
        }
        if (v68)
        {
          os_log_type_t v90 = a1->default_input_handler;
          char v85 = "invalid";
          if (v90)
          {
            BOOL v91 = v90->identifier;
            if (v91) {
              char v85 = (const char *)v91;
            }
          }
LABEL_163:
          *(_DWORD *)buf = 136446466;
          int v95 = "nw_protocol_http3_stream_input_finished";
          __int16 v96 = 2082;
          int v97 = (char *)v85;
          BOOL v24 = "%{public}s protocol %{public}s has invalid input_finished callback, no backtrace";
          goto LABEL_164;
        }
        goto LABEL_165;
      }
      int v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_165;
      }
      char v88 = a1->default_input_handler;
      uint64_t v76 = "invalid";
      if (v88)
      {
        int v89 = v88->identifier;
        if (v89) {
          uint64_t v76 = (const char *)v89;
        }
      }
LABEL_123:
      *(_DWORD *)buf = 136446466;
      int v95 = "nw_protocol_http3_stream_input_finished";
      __int16 v96 = 2082;
      int v97 = (char *)v76;
      BOOL v24 = "%{public}s protocol %{public}s has invalid input_finished callback, backtrace limit exceeded";
      goto LABEL_164;
    }
LABEL_35:
    input_finished(v12, a1);
    return;
  }
  if ((*((_WORD *)handle + 368) & 0x800) == 0)
  {
    if (gLogDatapath)
    {
      int v64 = __nwlog_obj();
      if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
      {
        int v65 = *(_DWORD *)(*((void *)handle + 42) + 1280);
        uint64_t v66 = *((void *)handle + 30);
        *(_DWORD *)buf = 136447234;
        int v95 = "nw_protocol_http3_stream_input_finished";
        __int16 v96 = 2082;
        int v97 = handle + 636;
        __int16 v98 = 2080;
        uint64_t v99 = " ";
        __int16 v100 = 1024;
        int v101 = v65;
        __int16 v102 = 2048;
        uint64_t v103 = v66;
        _os_log_impl(&dword_1830D4000, v64, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called", buf, 0x30u);
      }
    }
  }
  int v12 = a1->default_input_handler;
  if (v12)
  {
    uint64_t v25 = v12->callbacks;
    if (v25)
    {
      input_finished = (void (*)(nw_protocol *, nw_protocol *))v25->input_finished;
      if (input_finished) {
        goto LABEL_35;
      }
    }
  }
  __nwlog_obj();
  int v36 = a1->default_input_handler;
  uint64_t v37 = "invalid";
  if (v36)
  {
    uint64_t v38 = v36->identifier;
    if (v38) {
      uint64_t v37 = (const char *)v38;
    }
  }
  *(_DWORD *)buf = 136446466;
  int v95 = "nw_protocol_http3_stream_input_finished";
  __int16 v96 = 2082;
  int v97 = (char *)v37;
  uint64_t v18 = (const char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v92 = 0;
  if (!__nwlog_fault(v18, &type, &v92)) {
    goto LABEL_165;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    int v19 = __nwlog_obj();
    os_log_type_t v20 = type;
    if (!os_log_type_enabled(v19, type)) {
      goto LABEL_165;
    }
    char v39 = a1->default_input_handler;
    uint64_t v22 = "invalid";
    if (v39)
    {
      char v40 = v39->identifier;
      if (v40) {
        uint64_t v22 = (const char *)v40;
      }
    }
    goto LABEL_29;
  }
  if (!v92)
  {
    int v19 = __nwlog_obj();
    os_log_type_t v20 = type;
    if (!os_log_type_enabled(v19, type)) {
      goto LABEL_165;
    }
    uint64_t v75 = a1->default_input_handler;
    uint64_t v76 = "invalid";
    if (v75)
    {
      os_log_type_t v77 = v75->identifier;
      if (v77) {
        uint64_t v76 = (const char *)v77;
      }
    }
    goto LABEL_123;
  }
  uint64_t v50 = (char *)__nw_create_backtrace_string();
  int v19 = __nwlog_obj();
  os_log_type_t v20 = type;
  BOOL v51 = os_log_type_enabled(v19, type);
  if (!v50)
  {
    if (!v51) {
      goto LABEL_165;
    }
    uint64_t v84 = a1->default_input_handler;
    char v85 = "invalid";
    if (v84)
    {
      uint64_t v86 = v84->identifier;
      if (v86) {
        char v85 = (const char *)v86;
      }
    }
    goto LABEL_163;
  }
  if (v51)
  {
    uint64_t v52 = a1->default_input_handler;
    uint64_t v53 = "invalid";
    if (v52)
    {
      int v54 = v52->identifier;
      if (v54) {
        uint64_t v53 = (const char *)v54;
      }
    }
    *(_DWORD *)buf = 136446722;
    int v95 = "nw_protocol_http3_stream_input_finished";
    __int16 v96 = 2082;
    int v97 = (char *)v53;
    __int16 v98 = 2082;
    uint64_t v99 = v50;
    _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s protocol %{public}s has invalid input_finished callback, dumping backtrace:%{public}s", buf, 0x20u);
  }
  free(v50);
LABEL_165:
  if (v18)
  {
LABEL_166:
    BOOL v87 = (char *)v18;
    goto LABEL_167;
  }
}

void nw_protocol_http3_stream_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v30 = "nw_protocol_http3_stream_disconnected";
    BOOL v16 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (!__nwlog_fault(v16, &type, &v27)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_55;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v30 = "nw_protocol_http3_stream_disconnected";
      int v19 = "%{public}s called with null protocol";
      goto LABEL_54;
    }
    if (!v27)
    {
      uint64_t v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_55;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v30 = "nw_protocol_http3_stream_disconnected";
      int v19 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_54;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v17 = __nwlog_obj();
    os_log_type_t v18 = type;
    BOOL v24 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (!v24) {
        goto LABEL_55;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v30 = "nw_protocol_http3_stream_disconnected";
      int v19 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_54;
    }
    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v30 = "nw_protocol_http3_stream_disconnected";
      __int16 v31 = 2082;
      unint64_t v32 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_55:
    if (!v16) {
      return;
    }
    goto LABEL_56;
  }
  uint64_t handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v30 = "nw_protocol_http3_stream_disconnected";
    BOOL v16 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (!__nwlog_fault(v16, &type, &v27)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_55;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v30 = "nw_protocol_http3_stream_disconnected";
      int v19 = "%{public}s called with null http3_stream";
      goto LABEL_54;
    }
    if (!v27)
    {
      uint64_t v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_55;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v30 = "nw_protocol_http3_stream_disconnected";
      int v19 = "%{public}s called with null http3_stream, backtrace limit exceeded";
      goto LABEL_54;
    }
    uint64_t v25 = (char *)__nw_create_backtrace_string();
    uint64_t v17 = __nwlog_obj();
    os_log_type_t v18 = type;
    BOOL v26 = os_log_type_enabled(v17, type);
    if (v25)
    {
      if (v26)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v30 = "nw_protocol_http3_stream_disconnected";
        __int16 v31 = 2082;
        unint64_t v32 = v25;
        _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s called with null http3_stream, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v25);
      if (!v16) {
        return;
      }
LABEL_56:
      free(v16);
      return;
    }
    if (v26)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v30 = "nw_protocol_http3_stream_disconnected";
      int v19 = "%{public}s called with null http3_stream, no backtrace";
LABEL_54:
      _os_log_impl(&dword_1830D4000, v17, v18, v19, buf, 0xCu);
      goto LABEL_55;
    }
    goto LABEL_55;
  }
  if ((handle[92] & 0x800) == 0)
  {
    if (gLogDatapath)
    {
      os_log_type_t v20 = __nwlog_obj();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        int v21 = *(_DWORD *)(handle[42] + 1280);
        uint64_t v22 = handle[30];
        *(_DWORD *)buf = 136447234;
        uint64_t v30 = "nw_protocol_http3_stream_disconnected";
        __int16 v31 = 2082;
        unint64_t v32 = (char *)handle + 636;
        __int16 v33 = 2080;
        uint64_t v34 = " ";
        __int16 v35 = 1024;
        int v36 = v21;
        __int16 v37 = 2048;
        uint64_t v38 = v22;
        _os_log_impl(&dword_1830D4000, v20, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called", buf, 0x30u);
      }
    }
  }
  if (handle + 8 != (void *)a1)
  {
    uint64_t application_error = nw_http3_stream_get_application_error((uint64_t)handle);
    if (application_error == 272)
    {
      default_input_handler = a1->default_input_handler;
      if (default_input_handler)
      {
        callbacks = default_input_handler->callbacks;
        if (callbacks)
        {
          error = (void (*)(void))callbacks->error;
          if (error) {
            goto LABEL_19;
          }
        }
      }
    }
    else if (application_error == 267)
    {
      uint64_t v5 = a1->default_input_handler;
      if (v5)
      {
        uint64_t v6 = v5->callbacks;
        if (v6)
        {
          error = (void (*)(void))v6->error;
          if (error) {
LABEL_19:
          }
            error();
        }
      }
    }
    unsigned int v13 = a1->default_input_handler;
    if (v13)
    {
      uint32_t v14 = v13->callbacks;
      if (v14)
      {
        disconnected = (void (*)(void))v14->disconnected;
        if (disconnected) {
          disconnected();
        }
      }
    }
    return;
  }
  if ((handle[92] & 0x800) == 0)
  {
    if (gLogDatapath)
    {
      int v8 = __nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        int v9 = *(_DWORD *)(handle[42] + 1280);
        uint64_t v10 = handle[30];
        *(_DWORD *)buf = 136447234;
        uint64_t v30 = "nw_protocol_http3_stream_disconnected";
        __int16 v31 = 2082;
        unint64_t v32 = (char *)handle + 636;
        __int16 v33 = 2080;
        uint64_t v34 = " ";
        __int16 v35 = 1024;
        int v36 = v9;
        __int16 v37 = 2048;
        uint64_t v38 = v10;
        _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> datagram flow disconnected", buf, 0x30u);
      }
    }
  }
}

void ___ZL34nw_protocol_http3_stream_connectedP11nw_protocolS0__block_invoke_140(uint64_t a1, void *a2, int a3)
{
  uint64_t v82 = *MEMORY[0x1E4F143B8];
  switch(a3)
  {
    case 0:
      id outbound_message = nw_http_transaction_metadata_get_outbound_message(a2);
      id v6 = nw_http_metadata_copy_request(outbound_message);
      id v7 = nw_http_metadata_copy_response(outbound_message);
      if (v6)
      {
        v69[0] = MEMORY[0x1E4F143A8];
        v69[1] = 0x40000000;
        v69[2] = ___ZL34nw_protocol_http3_stream_connectedP11nw_protocolS0__block_invoke_2;
        v69[3] = &__block_descriptor_tmp_141;
        v69[4] = *(void *)(a1 + 32);
        id v8 = v6;
        int v9 = v69;
        _nw_http_request_access_method((uint64_t)v8, v9);
      }
      if (!v7) {
        goto LABEL_40;
      }
      id v10 = v7;
      int status_code = _nw_http_response_get_status_code();

      uint64_t v12 = *(void *)(a1 + 32);
      if (v12 && (*(_WORD *)(v12 + 736) & 0x800) != 0) {
        goto LABEL_39;
      }
      if (__nwlog_http_log::onceToken != -1) {
        dispatch_once(&__nwlog_http_log::onceToken, &__block_literal_global_36);
      }
      unsigned int v13 = ghttpLogObj;
      if (!os_log_type_enabled((os_log_t)ghttpLogObj, OS_LOG_TYPE_INFO)) {
        goto LABEL_39;
      }
      uint64_t v14 = *(void *)(a1 + 32);
      uint64_t v15 = (const char *)(v14 + 636);
      BOOL v16 = "";
      BOOL v17 = v14 == 0;
      if (!v14) {
        uint64_t v15 = "";
      }
      int v18 = *(_DWORD *)(*(void *)(v14 + 336) + 1280);
      uint64_t v19 = *(void *)(v14 + 240);
      if (!v17) {
        BOOL v16 = " ";
      }
      *(_DWORD *)buf = 136447490;
      int v71 = "nw_protocol_http3_stream_connected_block_invoke";
      __int16 v72 = 2082;
      uint64_t v73 = v15;
      __int16 v74 = 2080;
      uint64_t v75 = v16;
      __int16 v76 = 1024;
      int v77 = v18;
      __int16 v78 = 2048;
      uint64_t v79 = v19;
      __int16 v80 = 1024;
      LODWORD(v81) = status_code;
      os_log_type_t v20 = "%{public}s %{public}s%s<i%u:s%llu> sending response header {status=%hu}";
      goto LABEL_38;
    case 1:
      outbound_body_size_t size = nw_http_transaction_metadata_get_outbound_body_size(a2);
      uint64_t v22 = *(void *)(a1 + 32);
      if (v22 && (*(_WORD *)(v22 + 736) & 0x800) != 0) {
        return;
      }
      if (__nwlog_http_log::onceToken != -1) {
        dispatch_once(&__nwlog_http_log::onceToken, &__block_literal_global_36);
      }
      os_log_type_t v23 = ghttpLogObj;
      if (!os_log_type_enabled((os_log_t)ghttpLogObj, OS_LOG_TYPE_INFO)) {
        return;
      }
      uint64_t v24 = *(void *)(a1 + 32);
      uint64_t v25 = (const char *)(v24 + 636);
      BOOL v26 = "";
      BOOL v27 = v24 == 0;
      if (!v24) {
        uint64_t v25 = "";
      }
      int v28 = *(_DWORD *)(*(void *)(v24 + 336) + 1280);
      uint64_t v29 = *(void *)(v24 + 240);
      if (!v27) {
        BOOL v26 = " ";
      }
      *(_DWORD *)buf = 136447490;
      int v71 = "nw_protocol_http3_stream_connected_block_invoke";
      __int16 v72 = 2082;
      uint64_t v73 = v25;
      __int16 v74 = 2080;
      uint64_t v75 = v26;
      __int16 v76 = 1024;
      int v77 = v28;
      __int16 v78 = 2048;
      uint64_t v79 = v29;
      __int16 v80 = 2048;
      uint64_t v81 = outbound_body_size;
      uint64_t v30 = "%{public}s %{public}s%s<i%u:s%llu> finished sending {body_bytes=%llu}";
      goto LABEL_54;
    case 2:
      id outbound_message = nw_http_transaction_metadata_get_inbound_message(a2);
      id v6 = nw_http_metadata_copy_request(outbound_message);
      id v31 = nw_http_metadata_copy_response(outbound_message);
      if (v6)
      {
        v68[0] = MEMORY[0x1E4F143A8];
        v68[1] = 0x40000000;
        void v68[2] = ___ZL34nw_protocol_http3_stream_connectedP11nw_protocolS0__block_invoke_142;
        v68[3] = &__block_descriptor_tmp_143_63070;
        v68[4] = *(void *)(a1 + 32);
        id v32 = v6;
        __int16 v33 = v68;
        _nw_http_request_access_method((uint64_t)v32, v33);
      }
      if (v31)
      {
        id v10 = v31;
        int v34 = _nw_http_response_get_status_code();

        uint64_t v35 = *(void *)(a1 + 32);
        if (!v35 || (*(_WORD *)(v35 + 736) & 0x800) == 0)
        {
          if (__nwlog_http_log::onceToken != -1) {
            dispatch_once(&__nwlog_http_log::onceToken, &__block_literal_global_36);
          }
          unsigned int v13 = ghttpLogObj;
          if (os_log_type_enabled((os_log_t)ghttpLogObj, OS_LOG_TYPE_INFO))
          {
            uint64_t v36 = *(void *)(a1 + 32);
            __int16 v37 = (const char *)(v36 + 636);
            uint64_t v38 = "";
            BOOL v39 = v36 == 0;
            if (!v36) {
              __int16 v37 = "";
            }
            int v40 = *(_DWORD *)(*(void *)(v36 + 336) + 1280);
            uint64_t v41 = *(void *)(v36 + 240);
            if (!v39) {
              uint64_t v38 = " ";
            }
            *(_DWORD *)buf = 136447490;
            int v71 = "nw_protocol_http3_stream_connected_block_invoke";
            __int16 v72 = 2082;
            uint64_t v73 = v37;
            __int16 v74 = 2080;
            uint64_t v75 = v38;
            __int16 v76 = 1024;
            int v77 = v40;
            __int16 v78 = 2048;
            uint64_t v79 = v41;
            __int16 v80 = 1024;
            LODWORD(v81) = v34;
            os_log_type_t v20 = "%{public}s %{public}s%s<i%u:s%llu> receiving response header {status=%hu}";
LABEL_38:
            _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_INFO, v20, buf, 0x36u);
          }
        }
LABEL_39:
        os_release(v10);
      }
LABEL_40:
      if (v6) {
        os_release(v6);
      }
      if (!outbound_message) {
        return;
      }
      uint64_t v42 = outbound_message;
      goto LABEL_76;
    case 3:
      inbound_body_size_t size = nw_http_transaction_metadata_get_inbound_body_size(a2);
      uint64_t v44 = *(void *)(a1 + 32);
      if (v44 && (*(_WORD *)(v44 + 736) & 0x800) != 0) {
        return;
      }
      if (__nwlog_http_log::onceToken != -1) {
        dispatch_once(&__nwlog_http_log::onceToken, &__block_literal_global_36);
      }
      os_log_type_t v23 = ghttpLogObj;
      if (!os_log_type_enabled((os_log_t)ghttpLogObj, OS_LOG_TYPE_INFO)) {
        return;
      }
      uint64_t v45 = *(void *)(a1 + 32);
      BOOL v46 = (const char *)(v45 + 636);
      __int16 v47 = "";
      BOOL v48 = v45 == 0;
      if (!v45) {
        BOOL v46 = "";
      }
      int v49 = *(_DWORD *)(*(void *)(v45 + 336) + 1280);
      uint64_t v50 = *(void *)(v45 + 240);
      if (!v48) {
        __int16 v47 = " ";
      }
      *(_DWORD *)buf = 136447490;
      int v71 = "nw_protocol_http3_stream_connected_block_invoke";
      __int16 v72 = 2082;
      uint64_t v73 = v46;
      __int16 v74 = 2080;
      uint64_t v75 = v47;
      __int16 v76 = 1024;
      int v77 = v49;
      __int16 v78 = 2048;
      uint64_t v79 = v50;
      __int16 v80 = 2048;
      uint64_t v81 = inbound_body_size;
      uint64_t v30 = "%{public}s %{public}s%s<i%u:s%llu> finished receiving {body_bytes=%llu}";
LABEL_54:
      _os_log_impl(&dword_1830D4000, v23, OS_LOG_TYPE_INFO, v30, buf, 0x3Au);
      return;
    case 4:
      v63[0] = MEMORY[0x1E4F143A8];
      v63[1] = 0x40000000;
      int v64 = ___ZL34nw_protocol_http3_stream_connectedP11nw_protocolS0__block_invoke_144;
      int v65 = &__block_descriptor_tmp_145;
      uint64_t v51 = *(void *)(a1 + 32);
      uint64_t v66 = a2;
      uint64_t v67 = v51;
      id v52 = nw_http_transaction_metadata_get_outbound_message(a2);
      uint64_t v53 = v52;
      if (v52)
      {
        id v54 = nw_http_metadata_copy_request(v52);
        id v55 = nw_http_metadata_copy_response(v53);
        id inbound_message = nw_http_transaction_metadata_get_inbound_message(a2);
        if (!inbound_message) {
          goto LABEL_64;
        }
        if (v54)
        {
          if (v55) {
            goto LABEL_65;
          }
          goto LABEL_63;
        }
      }
      else
      {
        id v57 = nw_http_transaction_metadata_get_inbound_message(a2);
        id v55 = 0;
        if (!v57)
        {
          uint64_t v58 = 0;
          id inbound_message = 0;
          goto LABEL_79;
        }
        id inbound_message = v57;
      }
      id v54 = nw_http_metadata_copy_request(inbound_message);
      if (v55) {
        goto LABEL_65;
      }
LABEL_63:
      id v55 = nw_http_metadata_copy_response(inbound_message);
LABEL_64:
      if (!v55)
      {
        uint64_t v58 = 0;
        if (!v54) {
          goto LABEL_79;
        }
LABEL_68:
        v61[0] = MEMORY[0x1E4F143A8];
        v61[1] = 0x40000000;
        v61[2] = ___ZL34nw_protocol_http3_stream_connectedP11nw_protocolS0__block_invoke_146;
        v61[3] = &unk_1E5247808;
        v61[4] = v63;
        __int16 v62 = v58;
        id v59 = v54;
        BOOL v60 = v61;
        _nw_http_request_access_method((uint64_t)v59, v60);

        if (!inbound_message) {
          goto LABEL_70;
        }
        goto LABEL_69;
      }
LABEL_65:
      id v55 = v55;
      uint64_t v58 = _nw_http_response_get_status_code();

      if (v54) {
        goto LABEL_68;
      }
LABEL_79:
      v64((uint64_t)v63, (uint64_t)"", v58);
      id v59 = 0;
      if (inbound_message) {
LABEL_69:
      }
        os_release(inbound_message);
LABEL_70:
      if (v53) {
        os_release(v53);
      }
      if (v55) {
        os_release(v55);
      }
      if (v59)
      {
        uint64_t v42 = v59;
LABEL_76:
        os_release(v42);
      }
      return;
    default:
      return;
  }
}

void ___ZL34nw_protocol_http3_stream_connectedP11nw_protocolS0__block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 32);
  if (!v4 || (*(_WORD *)(v4 + 736) & 0x800) == 0)
  {
    if (__nwlog_http_log::onceToken != -1) {
      dispatch_once(&__nwlog_http_log::onceToken, &__block_literal_global_36);
    }
    uint64_t v5 = ghttpLogObj;
    if (os_log_type_enabled((os_log_t)ghttpLogObj, OS_LOG_TYPE_INFO))
    {
      uint64_t v6 = *(void *)(a1 + 32);
      id v7 = (const char *)(v6 + 636);
      id v8 = "";
      BOOL v9 = v6 == 0;
      if (!v6) {
        id v7 = "";
      }
      int v10 = *(_DWORD *)(*(void *)(v6 + 336) + 1280);
      uint64_t v11 = *(void *)(v6 + 240);
      if (!v9) {
        id v8 = " ";
      }
      int v12 = 136447490;
      unsigned int v13 = "nw_protocol_http3_stream_connected_block_invoke_2";
      __int16 v14 = 2082;
      uint64_t v15 = v7;
      __int16 v16 = 2080;
      BOOL v17 = v8;
      __int16 v18 = 1024;
      int v19 = v10;
      __int16 v20 = 2048;
      uint64_t v21 = v11;
      __int16 v22 = 2082;
      uint64_t v23 = a2;
      _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%llu> sending request header {method=\"%{public}s\"}", (uint8_t *)&v12, 0x3Au);
    }
  }
}

void ___ZL34nw_protocol_http3_stream_connectedP11nw_protocolS0__block_invoke_142(uint64_t a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 32);
  if (!v4 || (*(_WORD *)(v4 + 736) & 0x800) == 0)
  {
    if (__nwlog_http_log::onceToken != -1) {
      dispatch_once(&__nwlog_http_log::onceToken, &__block_literal_global_36);
    }
    uint64_t v5 = ghttpLogObj;
    if (os_log_type_enabled((os_log_t)ghttpLogObj, OS_LOG_TYPE_INFO))
    {
      uint64_t v6 = *(void *)(a1 + 32);
      id v7 = (const char *)(v6 + 636);
      id v8 = "";
      BOOL v9 = v6 == 0;
      if (!v6) {
        id v7 = "";
      }
      int v10 = *(_DWORD *)(*(void *)(v6 + 336) + 1280);
      uint64_t v11 = *(void *)(v6 + 240);
      if (!v9) {
        id v8 = " ";
      }
      int v12 = 136447490;
      unsigned int v13 = "nw_protocol_http3_stream_connected_block_invoke";
      __int16 v14 = 2082;
      uint64_t v15 = v7;
      __int16 v16 = 2080;
      BOOL v17 = v8;
      __int16 v18 = 1024;
      int v19 = v10;
      __int16 v20 = 2048;
      uint64_t v21 = v11;
      __int16 v22 = 2082;
      uint64_t v23 = a2;
      _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%llu> receiving request header {method=\"%{public}s\"}", (uint8_t *)&v12, 0x3Au);
    }
  }
}

void ___ZL34nw_protocol_http3_stream_connectedP11nw_protocolS0__block_invoke_144(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  int start_reason = nw_http_transaction_metadata_get_start_reason(*(void **)(a1 + 32));
  uint64_t start_time = nw_http_transaction_metadata_get_start_time(*(void **)(a1 + 32));
  uint64_t end_time = nw_http_transaction_metadata_get_end_time(*(void **)(a1 + 32));
  outbound_message_uint64_t start_time = nw_http_transaction_metadata_get_outbound_message_start_time(*(void **)(a1 + 32));
  outbound_message_uint64_t end_time = nw_http_transaction_metadata_get_outbound_message_end_time(*(void **)(a1 + 32));
  inbound_message_uint64_t start_time = nw_http_transaction_metadata_get_inbound_message_start_time(*(void **)(a1 + 32));
  inbound_message_uint64_t end_time = nw_http_transaction_metadata_get_inbound_message_end_time(*(void **)(a1 + 32));
  outbound_body_size_t size = nw_http_transaction_metadata_get_outbound_body_size(*(void **)(a1 + 32));
  inbound_body_size_t size = nw_http_transaction_metadata_get_inbound_body_size(*(void **)(a1 + 32));
  uint64_t v12 = *(void *)(a1 + 40);
  if (!v12 || (*(_WORD *)(v12 + 736) & 0x800) == 0)
  {
    if (__nwlog_http_log::onceToken != -1) {
      dispatch_once(&__nwlog_http_log::onceToken, &__block_literal_global_36);
    }
    unsigned int v13 = ghttpLogObj;
    if (os_log_type_enabled((os_log_t)ghttpLogObj, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = *(void *)(a1 + 40);
      if (v14) {
        uint64_t v15 = (const char *)(v14 + 636);
      }
      else {
        uint64_t v15 = "";
      }
      if (v14) {
        __int16 v16 = " ";
      }
      else {
        __int16 v16 = "";
      }
      id v31 = v15;
      id v32 = v16;
      if ((start_reason - 1) > 2) {
        BOOL v17 = "initial";
      }
      else {
        BOOL v17 = off_1E52492C0[start_reason - 1];
      }
      int v28 = v17;
      int v29 = *(_DWORD *)(*(void *)(v14 + 336) + 1280);
      uint64_t v30 = *(void *)(v14 + 240);
      int v18 = -1;
      if (start_time && end_time)
      {
        unint64_t v19 = nw_delta_nanos(start_time, end_time);
        if (v19 > 0xF423FFFFFFFFFLL) {
          int v18 = -1;
        }
        else {
          int v18 = v19 / 0xF4240;
        }
      }
      int v20 = -1;
      if (start_time && outbound_message_start_time)
      {
        unint64_t v21 = nw_delta_nanos(start_time, outbound_message_start_time);
        if (v21 > 0xF423FFFFFFFFFLL) {
          int v20 = -1;
        }
        else {
          int v20 = v21 / 0xF4240;
        }
      }
      int v22 = -1;
      if (outbound_message_start_time && outbound_message_end_time)
      {
        unint64_t v23 = nw_delta_nanos(outbound_message_start_time, outbound_message_end_time);
        if (v23 > 0xF423FFFFFFFFFLL) {
          int v22 = -1;
        }
        else {
          int v22 = v23 / 0xF4240;
        }
      }
      int v24 = -1;
      if (start_time && inbound_message_start_time)
      {
        unint64_t v25 = nw_delta_nanos(start_time, inbound_message_start_time);
        if (v25 > 0xF423FFFFFFFFFLL) {
          int v24 = -1;
        }
        else {
          int v24 = v25 / 0xF4240;
        }
      }
      LODWORD(v26) = -1;
      if (inbound_message_start_time && inbound_message_end_time)
      {
        unint64_t v27 = nw_delta_nanos(inbound_message_start_time, inbound_message_end_time);
        unint64_t v26 = v27 / 0xF4240;
        if (v27 > 0xF423FFFFFFFFFLL) {
          LODWORD(v26) = -1;
        }
      }
      *(_DWORD *)buf = 136449794;
      __int16 v37 = "nw_protocol_http3_stream_connected_block_invoke";
      __int16 v38 = 2082;
      BOOL v39 = v31;
      __int16 v40 = 2080;
      uint64_t v41 = v32;
      __int16 v42 = 1024;
      int v43 = v29;
      __int16 v44 = 2048;
      uint64_t v45 = v30;
      __int16 v46 = 2080;
      __int16 v47 = v28;
      __int16 v48 = 1024;
      int v49 = v18;
      __int16 v50 = 2082;
      uint64_t v51 = a2;
      __int16 v52 = 1024;
      int v53 = a3;
      __int16 v54 = 1024;
      int v55 = v20;
      __int16 v56 = 1024;
      int v57 = v22;
      __int16 v58 = 1024;
      int v59 = v24;
      __int16 v60 = 1024;
      int v61 = v26;
      __int16 v62 = 2048;
      uint64_t v63 = outbound_body_size;
      __int16 v64 = 2048;
      uint64_t v65 = inbound_body_size;
      _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s%s<i%u:s%llu> transaction summary {start_reason=\"%s\", duration_ms=%d, request_method=\"%{public}s\", response_status=%hu, outbound_start_ms=%d, outbound_duration_ms=%d, inbound_start_ms=%d, inbound_duration_ms=%d, outbound_body_bytes=%llu, inbound_body_bytes=%llu}", buf, 0x7Cu);
    }
  }
}

uint64_t ___ZL34nw_protocol_http3_stream_connectedP11nw_protocolS0__block_invoke_146(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, uint64_t, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), a2, *(unsigned __int16 *)(a1 + 40));
}

BOOL nw_protocol_http3_stream_connect(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v109 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_connect";
    __int16 v38 = (char *)_os_log_send_and_compose_impl();
    v101[0] = 16;
    LOBYTE(v91) = 0;
    if (!__nwlog_fault(v38, v101, &v91)) {
      goto LABEL_148;
    }
    if (v101[0] == 17)
    {
      BOOL v39 = __nwlog_obj();
      os_log_type_t v40 = v101[0];
      if (!os_log_type_enabled(v39, (os_log_type_t)v101[0])) {
        goto LABEL_148;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_connect";
      uint64_t v41 = "%{public}s called with null protocol";
      goto LABEL_147;
    }
    if (!(_BYTE)v91)
    {
      BOOL v39 = __nwlog_obj();
      os_log_type_t v40 = v101[0];
      if (!os_log_type_enabled(v39, (os_log_type_t)v101[0])) {
        goto LABEL_148;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_connect";
      uint64_t v41 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_147;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v39 = __nwlog_obj();
    os_log_type_t v40 = v101[0];
    BOOL v52 = os_log_type_enabled(v39, (os_log_type_t)v101[0]);
    if (!backtrace_string)
    {
      if (!v52) {
        goto LABEL_148;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_connect";
      uint64_t v41 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_147;
    }
    if (!v52) {
      goto LABEL_97;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_connect";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    int v53 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_96:
    _os_log_impl(&dword_1830D4000, v39, v40, v53, buf, 0x16u);
    goto LABEL_97;
  }
  uint64_t handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_connect";
    __int16 v38 = (char *)_os_log_send_and_compose_impl();
    v101[0] = 16;
    LOBYTE(v91) = 0;
    if (!__nwlog_fault(v38, v101, &v91)) {
      goto LABEL_148;
    }
    if (v101[0] == 17)
    {
      BOOL v39 = __nwlog_obj();
      os_log_type_t v40 = v101[0];
      if (!os_log_type_enabled(v39, (os_log_type_t)v101[0])) {
        goto LABEL_148;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_connect";
      uint64_t v41 = "%{public}s called with null http3_stream";
      goto LABEL_147;
    }
    if (!(_BYTE)v91)
    {
      BOOL v39 = __nwlog_obj();
      os_log_type_t v40 = v101[0];
      if (!os_log_type_enabled(v39, (os_log_type_t)v101[0])) {
        goto LABEL_148;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_connect";
      uint64_t v41 = "%{public}s called with null http3_stream, backtrace limit exceeded";
      goto LABEL_147;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v39 = __nwlog_obj();
    os_log_type_t v40 = v101[0];
    BOOL v54 = os_log_type_enabled(v39, (os_log_type_t)v101[0]);
    if (!backtrace_string)
    {
      if (!v54) {
        goto LABEL_148;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_connect";
      uint64_t v41 = "%{public}s called with null http3_stream, no backtrace";
      goto LABEL_147;
    }
    if (!v54) {
      goto LABEL_97;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_connect";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    int v53 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
    goto LABEL_96;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_connect";
    __int16 v38 = (char *)_os_log_send_and_compose_impl();
    v101[0] = 16;
    LOBYTE(v91) = 0;
    if (!__nwlog_fault(v38, v101, &v91)) {
      goto LABEL_148;
    }
    if (v101[0] == 17)
    {
      BOOL v39 = __nwlog_obj();
      os_log_type_t v40 = v101[0];
      if (!os_log_type_enabled(v39, (os_log_type_t)v101[0])) {
        goto LABEL_148;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_connect";
      uint64_t v41 = "%{public}s called with null other_protocol";
      goto LABEL_147;
    }
    if (!(_BYTE)v91)
    {
      BOOL v39 = __nwlog_obj();
      os_log_type_t v40 = v101[0];
      if (!os_log_type_enabled(v39, (os_log_type_t)v101[0])) {
        goto LABEL_148;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_connect";
      uint64_t v41 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_147;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v39 = __nwlog_obj();
    os_log_type_t v40 = v101[0];
    BOOL v55 = os_log_type_enabled(v39, (os_log_type_t)v101[0]);
    if (backtrace_string)
    {
      if (v55)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_connect";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        int v53 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
        goto LABEL_96;
      }
LABEL_97:
      free(backtrace_string);
      goto LABEL_148;
    }
    if (!v55) {
      goto LABEL_148;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_connect";
    uint64_t v41 = "%{public}s called with null other_protocol, no backtrace";
LABEL_147:
    _os_log_impl(&dword_1830D4000, v39, v40, v41, buf, 0xCu);
LABEL_148:
    if (v38) {
      free(v38);
    }
    return 0;
  }
  uint64_t v5 = handle + 736;
  p_cache = NWConcrete_nw_resolution_report.cache;
  if ((*((_WORD *)handle + 368) & 0x800) == 0)
  {
    if (gLogDatapath)
    {
      __int16 v42 = __nwlog_obj();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
      {
        int v43 = *(_DWORD *)(*((void *)handle + 42) + 1280);
        uint64_t v44 = *((void *)handle + 30);
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_connect";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = handle + 636;
        *(_WORD *)&unsigned char buf[22] = 2080;
        __int16 v96 = " ";
        LOWORD(v97) = 1024;
        *(_DWORD *)((char *)&v97 + 2) = v43;
        HIWORD(v97) = 2048;
        uint64_t v98 = v44;
        _os_log_impl(&dword_1830D4000, v42, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called", buf, 0x30u);
      }
    }
  }
  uint64_t v7 = *((void *)handle + 4);
  if (v7)
  {
    if ((*v5 & 0x40) == 0)
    {
      if (!*((void *)handle + 29))
      {
        uint64_t v8 = mach_continuous_approximate_time();
        if (v8 <= 1) {
          uint64_t v9 = 1;
        }
        else {
          uint64_t v9 = v8;
        }
        *((void *)handle + 29) = v9;
        uint64_t v7 = *((void *)handle + 4);
      }
      *((void *)handle + 20) = v7;
      *((void *)handle + 21) = v7;
      uint64_t v10 = *((void *)handle + 42);
      if (v10)
      {
        if (v7)
        {
          if (*(void *)(v10 + 32)) {
            goto LABEL_42;
          }
          nw_protocol_set_output_handler(*((void *)handle + 42), v7);
          uint64_t v11 = (unsigned __int16 *)(v10 + 1373);
          if (((*(unsigned __int16 *)(v10 + 1373) | (*(unsigned __int8 *)(v10 + 1375) << 16)) & 0x400000) == 0)
          {
            if (gLogDatapath)
            {
              uint64_t v81 = __nwlog_obj();
              if (os_log_type_enabled(v81, OS_LOG_TYPE_DEBUG))
              {
                int v82 = *(_DWORD *)(v10 + 1280);
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_http3_add_edges";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v10 + 1289;
                *(_WORD *)&unsigned char buf[22] = 2080;
                __int16 v96 = " ";
                LOWORD(v97) = 1024;
                *(_DWORD *)((char *)&v97 + 2) = v82;
                _os_log_impl(&dword_1830D4000, v81, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
              }
            }
          }
          uint64_t v12 = *(void **)(v10 + 1096);
          if (v12)
          {
            unsigned int v13 = v12;
            BOOL v14 = (v13[231] & 4) == 0;

            if (!v14)
            {
              nw_endpoint_add_edges_for_instance(*(void **)(v10 + 1096), (atomic_uchar *)v10, 0);
LABEL_21:
              uint64_t v15 = nw_parameters_copy_protocol_options_legacy(*(void **)(v10 + 1120), *(nw_protocol **)(v10 + 32));
              if (v15)
              {
                __int16 v16 = v15;
                if (nw_protocol_options_is_quic_stream(v15))
                {
                  id v17 = nw_quic_stream_copy_shared_connection_options(v16);
                  __int16 v18 = nw_quic_connection_get_max_datagram_frame_size(v17) != 0;
                  int v19 = *v11;
                  unsigned int v20 = v19 & 0xFFFFFFFD | (*((unsigned __int8 *)v11 + 2) << 16);
                  unsigned __int16 *v11 = v19 & 0xFFFD | (2 * v18);
                  *((unsigned char *)v11 + 2) = BYTE2(v20);
                  __int16 v21 = nw_quic_connection_get_datagram_quarter_stream_id(v17) ? 0 : 4;
                  int v22 = *v11 & 0xFFFB | (*((unsigned __int8 *)v11 + 2) << 16);
                  unsigned __int16 *v11 = *v11 & 0xFFFB | v21;
                  *((unsigned char *)v11 + 2) = BYTE2(v22);
                  if (v17) {
                    os_release(v17);
                  }
                }
                os_release(v16);
              }
              if (!*(void *)(v10 + 1240))
              {
                uint64_t v23 = *(void *)(v7 + 24);
                if (v23)
                {
                  int v24 = *(uint64_t (**)(uint64_t, uint64_t, void))(v23 + 224);
                  if (v24)
                  {
                    unint64_t v25 = (atomic_uchar *)v24(v7, 255, 0);
                    uint64_t v91 = 0;
                    char v92 = &v91;
                    uint64_t v93 = 0x2000000000;
                    uint64_t v94 = 0;
                    *(void *)buf = MEMORY[0x1E4F143A8];
                    *(void *)&buf[8] = 0x40000000;
                    *(void *)&buf[16] = ___ZL28nw_http3_save_output_handlerP17nw_protocol_http3P11nw_protocol_block_invoke;
                    __int16 v96 = (const char *)&unk_1E5247760;
                    int v97 = &v91;
                    nw_array_apply(v25, (uint64_t)buf);
                    unint64_t v26 = (void *)v92[3];
                    if (v26)
                    {
                      unint64_t v27 = os_retain(v26);
                      *(void *)(v10 + 1240) = v27;
                      if (*(_DWORD *)(v10 + 1276))
                      {
                        if (((*v11 | (*((unsigned __int8 *)v11 + 2) << 16)) & 0x400000) == 0)
                        {
                          if (*((unsigned char *)p_cache + 3665))
                          {
                            char v88 = __nwlog_obj();
                            if (os_log_type_enabled(v88, OS_LOG_TYPE_DEBUG))
                            {
                              int v89 = *(_DWORD *)(v10 + 1280);
                              *(_DWORD *)int v101 = 136446978;
                              __int16 v102 = "nw_http3_save_output_handler";
                              __int16 v103 = 2082;
                              uint64_t v104 = v10 + 1289;
                              __int16 v105 = 2080;
                              int v106 = " ";
                              __int16 v107 = 1024;
                              int v108 = v89;
                              _os_log_impl(&dword_1830D4000, v88, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> enabling QUIC keepalives", v101, 0x26u);
                            }
                          }
                        }
                        nw_quic_connection_set_keepalive(*(void **)(v10 + 1240), 0xFFFF);
                        unint64_t v27 = *(void **)(v10 + 1240);
                      }
                      id v28 = nw_quic_connection_copy_sec_protocol_metadata(v27);
                      nw_http_connection_metadata_set_sec_metadata(*(void **)(v10 + 1248), v28);
                      if (v28) {
                        os_release(v28);
                      }
                    }
                    if (v25) {
                      os_release(v25);
                    }
                    _Block_object_dispose(&v91, 8);
                  }
                }
              }
              goto LABEL_42;
            }
            os_log_type_t v90 = (unsigned __int16 *)(v10 + 1373);
            __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_http3_add_edges";
            int v77 = (char *)_os_log_send_and_compose_impl();
            v101[0] = 16;
            LOBYTE(v91) = 0;
            if (__nwlog_fault(v77, v101, &v91))
            {
              if (v101[0] == 17)
              {
                __int16 v78 = __nwlog_obj();
                os_log_type_t v79 = v101[0];
                if (!os_log_type_enabled(v78, (os_log_type_t)v101[0])) {
                  goto LABEL_212;
                }
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_http3_add_edges";
                __int16 v80 = "%{public}s http3->remote_endpoint is not registered when connected";
                goto LABEL_211;
              }
              if (!(_BYTE)v91)
              {
                __int16 v78 = __nwlog_obj();
                os_log_type_t v79 = v101[0];
                if (!os_log_type_enabled(v78, (os_log_type_t)v101[0])) {
                  goto LABEL_212;
                }
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_http3_add_edges";
                __int16 v80 = "%{public}s http3->remote_endpoint is not registered when connected, backtrace limit exceeded";
                goto LABEL_211;
              }
              uint64_t v86 = (char *)__nw_create_backtrace_string();
              __int16 v78 = __nwlog_obj();
              os_log_type_t v79 = v101[0];
              BOOL v87 = os_log_type_enabled(v78, (os_log_type_t)v101[0]);
              if (v86)
              {
                if (v87)
                {
                  *(_DWORD *)buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_http3_add_edges";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v86;
                  _os_log_impl(&dword_1830D4000, v78, v79, "%{public}s http3->remote_endpoint is not registered when connected, dumping backtrace:%{public}s", buf, 0x16u);
                }
                free(v86);
                if (!v77) {
                  goto LABEL_214;
                }
                goto LABEL_213;
              }
              if (v87)
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_http3_add_edges";
                __int16 v80 = "%{public}s http3->remote_endpoint is not registered when connected, no backtrace";
LABEL_211:
                _os_log_impl(&dword_1830D4000, v78, v79, v80, buf, 0xCu);
              }
            }
          }
          else
          {
            os_log_type_t v90 = (unsigned __int16 *)(v10 + 1373);
            __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_http3_add_edges";
            int v77 = (char *)_os_log_send_and_compose_impl();
            v101[0] = 16;
            LOBYTE(v91) = 0;
            if (!__nwlog_fault(v77, v101, &v91)) {
              goto LABEL_212;
            }
            if (v101[0] == 17)
            {
              __int16 v78 = __nwlog_obj();
              os_log_type_t v79 = v101[0];
              if (!os_log_type_enabled(v78, (os_log_type_t)v101[0])) {
                goto LABEL_212;
              }
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http3_add_edges";
              __int16 v80 = "%{public}s http3->remote_endpoint is NULL when connected";
              goto LABEL_211;
            }
            if (!(_BYTE)v91)
            {
              __int16 v78 = __nwlog_obj();
              os_log_type_t v79 = v101[0];
              if (!os_log_type_enabled(v78, (os_log_type_t)v101[0])) {
                goto LABEL_212;
              }
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http3_add_edges";
              __int16 v80 = "%{public}s http3->remote_endpoint is NULL when connected, backtrace limit exceeded";
              goto LABEL_211;
            }
            uint64_t v84 = (char *)__nw_create_backtrace_string();
            __int16 v78 = __nwlog_obj();
            os_log_type_t v79 = v101[0];
            BOOL v85 = os_log_type_enabled(v78, (os_log_type_t)v101[0]);
            if (!v84)
            {
              if (!v85) {
                goto LABEL_212;
              }
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http3_add_edges";
              __int16 v80 = "%{public}s http3->remote_endpoint is NULL when connected, no backtrace";
              goto LABEL_211;
            }
            if (v85)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_http3_add_edges";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v84;
              _os_log_impl(&dword_1830D4000, v78, v79, "%{public}s http3->remote_endpoint is NULL when connected, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v84);
          }
LABEL_212:
          if (!v77)
          {
LABEL_214:
            p_cache = (void **)(NWConcrete_nw_resolution_report + 16);
            uint64_t v11 = v90;
            goto LABEL_21;
          }
LABEL_213:
          free(v77);
          goto LABEL_214;
        }
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http3_save_output_handler";
        __int16 v56 = (char *)_os_log_send_and_compose_impl();
        v101[0] = 16;
        LOBYTE(v91) = 0;
        if (!__nwlog_fault(v56, v101, &v91)) {
          goto LABEL_199;
        }
        if (v101[0] == 17)
        {
          int v57 = __nwlog_obj();
          os_log_type_t v58 = v101[0];
          if (!os_log_type_enabled(v57, (os_log_type_t)v101[0])) {
            goto LABEL_199;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http3_save_output_handler";
          int v59 = "%{public}s called with null quic_protocol";
          goto LABEL_198;
        }
        if (!(_BYTE)v91)
        {
          int v57 = __nwlog_obj();
          os_log_type_t v58 = v101[0];
          if (!os_log_type_enabled(v57, (os_log_type_t)v101[0])) {
            goto LABEL_199;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http3_save_output_handler";
          int v59 = "%{public}s called with null quic_protocol, backtrace limit exceeded";
          goto LABEL_198;
        }
        __int16 v74 = (char *)__nw_create_backtrace_string();
        int v57 = __nwlog_obj();
        os_log_type_t v58 = v101[0];
        BOOL v75 = os_log_type_enabled(v57, (os_log_type_t)v101[0]);
        if (v74)
        {
          if (v75)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http3_save_output_handler";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v74;
            _os_log_impl(&dword_1830D4000, v57, v58, "%{public}s called with null quic_protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v74);
          if (!v56)
          {
LABEL_42:
            nw_http3_setup_connection_if_needed(*((void *)handle + 42));
            *v5 |= 2u;
            uint64_t v29 = *((void *)handle + 42);
            if (v29)
            {
              if ((*(_WORD *)(v29 + 1373) & 0x61) != 0x20 || !uuid_is_null((const unsigned __int8 *)(v29 + 848)))
              {
                if (!*(void *)(v29 + 976))
                {
                  uint64_t v30 = mach_continuous_approximate_time();
                  if (v30 <= 1) {
                    uint64_t v31 = 1;
                  }
                  else {
                    uint64_t v31 = v30;
                  }
                  *(void *)(v29 + 976) = v31;
                }
                nw_http3_stream_connect_lower((uint64_t)handle);
              }
LABEL_51:
              nw_http3_signal_output_pending(*((void *)handle + 42), 0);
              return 1;
            }
            __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_http3_should_connect";
            __int16 v60 = (char *)_os_log_send_and_compose_impl();
            v101[0] = 16;
            LOBYTE(v91) = 0;
            if (__nwlog_fault(v60, v101, &v91))
            {
              if (v101[0] == 17)
              {
                int v61 = __nwlog_obj();
                os_log_type_t v62 = v101[0];
                if (!os_log_type_enabled(v61, (os_log_type_t)v101[0])) {
                  goto LABEL_194;
                }
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_http3_should_connect";
                uint64_t v63 = "%{public}s called with null http3";
                goto LABEL_193;
              }
              if (!(_BYTE)v91)
              {
                int v61 = __nwlog_obj();
                os_log_type_t v62 = v101[0];
                if (!os_log_type_enabled(v61, (os_log_type_t)v101[0])) {
                  goto LABEL_194;
                }
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_http3_should_connect";
                uint64_t v63 = "%{public}s called with null http3, backtrace limit exceeded";
                goto LABEL_193;
              }
              __int16 v72 = (char *)__nw_create_backtrace_string();
              int v61 = __nwlog_obj();
              os_log_type_t v62 = v101[0];
              BOOL v73 = os_log_type_enabled(v61, (os_log_type_t)v101[0]);
              if (v72)
              {
                if (v73)
                {
                  *(_DWORD *)buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_http3_should_connect";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v72;
                  _os_log_impl(&dword_1830D4000, v61, v62, "%{public}s called with null http3, dumping backtrace:%{public}s", buf, 0x16u);
                }
                free(v72);
                goto LABEL_194;
              }
              if (v73)
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_http3_should_connect";
                uint64_t v63 = "%{public}s called with null http3, no backtrace";
LABEL_193:
                _os_log_impl(&dword_1830D4000, v61, v62, v63, buf, 0xCu);
              }
            }
LABEL_194:
            if (v60) {
              free(v60);
            }
            goto LABEL_51;
          }
LABEL_200:
          free(v56);
          goto LABEL_42;
        }
        if (v75)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http3_save_output_handler";
          int v59 = "%{public}s called with null quic_protocol, no backtrace";
LABEL_198:
          _os_log_impl(&dword_1830D4000, v57, v58, v59, buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http3_save_output_handler";
        __int16 v56 = (char *)_os_log_send_and_compose_impl();
        v101[0] = 16;
        LOBYTE(v91) = 0;
        if (!__nwlog_fault(v56, v101, &v91)) {
          goto LABEL_199;
        }
        if (v101[0] == 17)
        {
          int v57 = __nwlog_obj();
          os_log_type_t v58 = v101[0];
          if (!os_log_type_enabled(v57, (os_log_type_t)v101[0])) {
            goto LABEL_199;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http3_save_output_handler";
          int v59 = "%{public}s called with null http3";
          goto LABEL_198;
        }
        if (!(_BYTE)v91)
        {
          int v57 = __nwlog_obj();
          os_log_type_t v58 = v101[0];
          if (!os_log_type_enabled(v57, (os_log_type_t)v101[0])) {
            goto LABEL_199;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http3_save_output_handler";
          int v59 = "%{public}s called with null http3, backtrace limit exceeded";
          goto LABEL_198;
        }
        int v70 = (char *)__nw_create_backtrace_string();
        int v57 = __nwlog_obj();
        os_log_type_t v58 = v101[0];
        BOOL v71 = os_log_type_enabled(v57, (os_log_type_t)v101[0]);
        if (!v70)
        {
          if (!v71) {
            goto LABEL_199;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http3_save_output_handler";
          int v59 = "%{public}s called with null http3, no backtrace";
          goto LABEL_198;
        }
        if (v71)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http3_save_output_handler";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v70;
          _os_log_impl(&dword_1830D4000, v57, v58, "%{public}s called with null http3, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v70);
      }
LABEL_199:
      if (!v56) {
        goto LABEL_42;
      }
      goto LABEL_200;
    }
    if ((*v5 & 0x800) == 0)
    {
      if (gLogDatapath)
      {
        __int16 v64 = __nwlog_obj();
        if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
        {
          int v65 = *(_DWORD *)(*((void *)handle + 42) + 1280);
          uint64_t v66 = *((void *)handle + 30);
          *(_DWORD *)buf = 136447490;
          *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_connect";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = handle + 636;
          *(_WORD *)&unsigned char buf[22] = 2080;
          __int16 v96 = " ";
          LOWORD(v97) = 1024;
          *(_DWORD *)((char *)&v97 + 2) = v65;
          HIWORD(v97) = 2048;
          uint64_t v98 = v66;
          __int16 v99 = 2048;
          uint64_t v100 = v66;
          _os_log_impl(&dword_1830D4000, v64, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> stream %llu is already connected", buf, 0x3Au);
        }
      }
    }
    callbacks = a2->callbacks;
    if (callbacks)
    {
      connected = (void (*)(nw_protocol *, nw_protocol *))callbacks->connected;
      if (connected)
      {
        connected(a2, a1);
        return 1;
      }
    }
    __nwlog_obj();
    identifier = a2->identifier;
    if (!identifier) {
      identifier = (nw_protocol_identifier *)"invalid";
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_connect";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = identifier;
    __int16 v46 = (char *)_os_log_send_and_compose_impl();
    v101[0] = 16;
    LOBYTE(v91) = 0;
    if (__nwlog_fault(v46, v101, &v91))
    {
      if (v101[0] == 17)
      {
        __int16 v47 = __nwlog_obj();
        os_log_type_t v48 = v101[0];
        if (!os_log_type_enabled(v47, (os_log_type_t)v101[0])) {
          goto LABEL_170;
        }
        int v49 = a2->identifier;
        if (!v49) {
          int v49 = (nw_protocol_identifier *)"invalid";
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_connect";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v49;
        __int16 v50 = "%{public}s protocol %{public}s has invalid connected callback";
        goto LABEL_169;
      }
      if (!(_BYTE)v91)
      {
        __int16 v47 = __nwlog_obj();
        os_log_type_t v48 = v101[0];
        if (!os_log_type_enabled(v47, (os_log_type_t)v101[0])) {
          goto LABEL_170;
        }
        __int16 v76 = a2->identifier;
        if (!v76) {
          __int16 v76 = (nw_protocol_identifier *)"invalid";
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_connect";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v76;
        __int16 v50 = "%{public}s protocol %{public}s has invalid connected callback, backtrace limit exceeded";
        goto LABEL_169;
      }
      uint64_t v67 = (char *)__nw_create_backtrace_string();
      __int16 v47 = __nwlog_obj();
      os_log_type_t v48 = v101[0];
      BOOL v68 = os_log_type_enabled(v47, (os_log_type_t)v101[0]);
      if (v67)
      {
        if (v68)
        {
          uint64_t v69 = a2->identifier;
          if (!v69) {
            uint64_t v69 = (nw_protocol_identifier *)"invalid";
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_connect";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v69;
          *(_WORD *)&unsigned char buf[22] = 2082;
          __int16 v96 = v67;
          _os_log_impl(&dword_1830D4000, v47, v48, "%{public}s protocol %{public}s has invalid connected callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v67);
        goto LABEL_170;
      }
      if (v68)
      {
        uint64_t v83 = a2->identifier;
        if (!v83) {
          uint64_t v83 = (nw_protocol_identifier *)"invalid";
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_connect";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v83;
        __int16 v50 = "%{public}s protocol %{public}s has invalid connected callback, no backtrace";
LABEL_169:
        _os_log_impl(&dword_1830D4000, v47, v48, v50, buf, 0x16u);
      }
    }
LABEL_170:
    if (v46) {
      free(v46);
    }
    return 1;
  }
  if ((*v5 & 0x800) != 0) {
    return 0;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v32 = gLogObj;
  BOOL result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  if (result)
  {
    int v34 = *(_DWORD *)(*((void *)handle + 42) + 1280);
    uint64_t v35 = *((void *)handle + 30);
    *(_DWORD *)buf = 136447234;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_connect";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = handle + 636;
    *(_WORD *)&unsigned char buf[22] = 2080;
    __int16 v96 = " ";
    LOWORD(v97) = 1024;
    *(_DWORD *)((char *)&v97 + 2) = v34;
    HIWORD(v97) = 2048;
    uint64_t v98 = v35;
    _os_log_impl(&dword_1830D4000, v32, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%llu> output_handler is NULL", buf, 0x30u);
    return 0;
  }
  return result;
}

uint64_t ___ZL28nw_http3_save_output_handlerP17nw_protocol_http3P11nw_protocol_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  if (nw_protocol_metadata_is_quic_connection(a3)) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a3;
  }
  return 1;
}

void nw_http3_setup_connection_if_needed(uint64_t a1)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v2 = (unsigned __int16 *)(a1 + 1373);
    unsigned __int16 v3 = *(_WORD *)(a1 + 1373);
    if ((v3 & 0x800) != 0) {
      return;
    }
    if ((*(_WORD *)(a1 + 1373) & 0x400) == 0)
    {
      uint64_t v4 = *(void *)(a1 + 32);
      if (v4)
      {
        uint64_t v5 = *(void *)(v4 + 24);
        if (v5)
        {
          uint64_t v6 = *(unsigned int (**)(void))(v5 + 232);
          if (v6)
          {
            if (v6()) {
              __int16 v7 = 1024;
            }
            else {
              __int16 v7 = 0;
            }
            unsigned __int16 v3 = *v2 & 0xFBFF | v7;
            *uint64_t v2 = v3;
          }
        }
      }
    }
    if ((v3 & 0x20) != 0 && !uuid_is_null((const unsigned __int8 *)(a1 + 848)))
    {
      __int16 v18 = *(void **)(a1 + 1112);
      if (v18)
      {
        *(void *)os_log_type_t type = 0;
        BOOL v19 = nw_path_copy_token_from_agent(v18, (const unsigned __int8 *)(a1 + 848), type);
        if (v19)
        {
          unsigned int v20 = (int *)v19;
          if (((*v2 | (*((unsigned __int8 *)v2 + 2) << 16)) & 0x400000) == 0)
          {
            if (gLogDatapath)
            {
              os_log_type_t v58 = __nwlog_obj();
              if (os_log_type_enabled(v58, OS_LOG_TYPE_DEBUG))
              {
                int v59 = *(_DWORD *)(a1 + 1280);
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_http3_setup_connection_if_needed";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = a1 + 1289;
                *(_WORD *)&unsigned char buf[22] = 2080;
                uint64_t v63 = " ";
                LOWORD(v64) = 1024;
                *(_DWORD *)((char *)&v64 + 2) = v59;
                _os_log_impl(&dword_1830D4000, v58, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> received session to resume", buf, 0x26u);
              }
            }
          }
          nw_http3_parse_resumable_session_data(a1, v20, *(unint64_t *)type);
          free(v20);
        }
      }
    }
    if ((*v2 & 0x61) == 0x20 && uuid_is_null((const unsigned __int8 *)(a1 + 848)))
    {
      if (nw_storage_copy_shared_token[0] != -1) {
        dispatch_once(nw_storage_copy_shared_token, &__block_literal_global_45557);
      }
      id v8 = (id)nw_storage_copy_shared_storage;
      uint64_t v9 = *(void **)(a1 + 1096);
      if (v9) {
        uint64_t v10 = os_retain(v9);
      }
      else {
        uint64_t v10 = 0;
      }
      while (1)
      {
        __int16 v21 = v10;
        id v22 = nw_endpoint_copy_parent_endpoint(v10);
        if (!v22) {
          break;
        }
        uint64_t v10 = v22;
        if (v21) {
          os_release(v21);
        }
      }
      uint64_t v23 = *(void *)(a1 + 1040);
      int v24 = *(void **)(a1 + 1256);
      *(void *)buf = MEMORY[0x1E4F143A8];
      *(void *)&buf[8] = 0x40000000;
      *(void *)&buf[16] = ___ZL32nw_http3_start_0rtt_state_lookupP17nw_protocol_http3_block_invoke;
      uint64_t v63 = (const char *)&unk_1E52476A8;
      uint64_t v64 = v23;
      nw_storage_lookup_items(v8, (uint64_t)"h3_0rtt", v10, v24, buf);
      if (v10) {
        os_release(v10);
      }
      if (v8) {
        os_release(v8);
      }
      return;
    }
    if (!*(void *)(a1 + 976))
    {
      uint64_t v11 = mach_continuous_approximate_time();
      if (v11 <= 1) {
        uint64_t v12 = 1;
      }
      else {
        uint64_t v12 = v11;
      }
      *(void *)(a1 + 976) = v12;
    }
    if (((*v2 | (*((unsigned __int8 *)v2 + 2) << 16)) & 0x400000) == 0)
    {
      if (gLogDatapath)
      {
        uint64_t v41 = __nwlog_obj();
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
        {
          int v42 = *(_DWORD *)(a1 + 1280);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_http3_setup_connection_if_needed";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = a1 + 1289;
          *(_WORD *)&unsigned char buf[22] = 2080;
          uint64_t v63 = " ";
          LOWORD(v64) = 1024;
          *(_DWORD *)((char *)&v64 + 2) = v42;
          _os_log_impl(&dword_1830D4000, v41, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> starting control stream", buf, 0x26u);
        }
      }
    }
    *v2 |= 0x800u;
    if (!*(void *)(a1 + 1128))
    {
      *(void *)(a1 + 1128) = nw_http3_fix_quic_parameters(a1, *(NSObject **)(a1 + 1120), 1, 1);
      if (((*v2 | (*((unsigned __int8 *)v2 + 2) << 16)) & 0x400000) == 0)
      {
        if (gLogDatapath)
        {
          uint64_t v44 = __nwlog_obj();
          if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
          {
            int v45 = *(_DWORD *)(a1 + 1280);
            uint64_t v46 = *(void *)(a1 + 1128);
            *(_DWORD *)buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_http3_setup_connection_if_needed";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = a1 + 1289;
            *(_WORD *)&unsigned char buf[22] = 2080;
            uint64_t v63 = " ";
            LOWORD(v64) = 1024;
            *(_DWORD *)((char *)&v64 + 2) = v45;
            HIWORD(v64) = 2048;
            uint64_t v65 = v46;
            _os_log_impl(&dword_1830D4000, v44, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> set up unidirectional parameters %p", buf, 0x30u);
          }
        }
      }
    }
    uint64_t v13 = *(void *)(a1 + 32);
    if (v13)
    {
      BOOL v14 = *(void (***)(void, uint64_t))(v13 + 24);
      if (v14)
      {
        uint64_t v15 = *v14;
        if (v15)
        {
          v15(*(void *)(a1 + 32), a1);
          goto LABEL_33;
        }
      }
      __nwlog_obj();
      uint64_t v29 = *(const char **)(v13 + 16);
      if (!v29) {
        uint64_t v29 = "invalid";
      }
    }
    else
    {
      __nwlog_obj();
      uint64_t v29 = "invalid";
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_http3_setup_connection_if_needed";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v29;
    __int16 v33 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v61 = 0;
    if (__nwlog_fault(v33, type, &v61))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        int v34 = __nwlog_obj();
        os_log_type_t v35 = type[0];
        if (!os_log_type_enabled(v34, type[0])) {
          goto LABEL_99;
        }
        uint64_t v36 = "invalid";
        if (v13 && *(void *)(v13 + 16)) {
          uint64_t v36 = *(const char **)(v13 + 16);
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http3_setup_connection_if_needed";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v36;
        __int16 v37 = "%{public}s protocol %{public}s has invalid add_input_handler callback";
LABEL_98:
        _os_log_impl(&dword_1830D4000, v34, v35, v37, buf, 0x16u);
        goto LABEL_99;
      }
      if (!v61)
      {
        int v34 = __nwlog_obj();
        os_log_type_t v35 = type[0];
        if (!os_log_type_enabled(v34, type[0])) {
          goto LABEL_99;
        }
        int v43 = "invalid";
        if (v13 && *(void *)(v13 + 16)) {
          int v43 = *(const char **)(v13 + 16);
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http3_setup_connection_if_needed";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v43;
        __int16 v37 = "%{public}s protocol %{public}s has invalid add_input_handler callback, backtrace limit exceeded";
        goto LABEL_98;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v34 = __nwlog_obj();
      os_log_type_t v35 = type[0];
      BOOL v39 = os_log_type_enabled(v34, type[0]);
      if (!backtrace_string)
      {
        if (!v39) {
          goto LABEL_99;
        }
        __int16 v47 = "invalid";
        if (v13 && *(void *)(v13 + 16)) {
          __int16 v47 = *(const char **)(v13 + 16);
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http3_setup_connection_if_needed";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v47;
        __int16 v37 = "%{public}s protocol %{public}s has invalid add_input_handler callback, no backtrace";
        goto LABEL_98;
      }
      if (v39)
      {
        os_log_type_t v40 = "invalid";
        if (v13 && *(void *)(v13 + 16)) {
          os_log_type_t v40 = *(const char **)(v13 + 16);
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_http3_setup_connection_if_needed";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v40;
        *(_WORD *)&unsigned char buf[22] = 2082;
        uint64_t v63 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v34, v35, "%{public}s protocol %{public}s has invalid add_input_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(backtrace_string);
    }
LABEL_99:
    if (v33) {
      free(v33);
    }
    if (!v13)
    {
      __nwlog_obj();
      uint64_t v30 = "invalid";
      goto LABEL_103;
    }
LABEL_33:
    uint64_t v16 = *(void *)(v13 + 24);
    if (v16)
    {
      id v17 = *(void (**)(uint64_t, uint64_t))(v16 + 24);
      if (v17)
      {
        v17(v13, a1);
LABEL_36:
        nw_http3_control_stream_process_output(a1);
        return;
      }
    }
    __nwlog_obj();
    uint64_t v30 = *(const char **)(v13 + 16);
    if (!v30) {
      uint64_t v30 = "invalid";
    }
LABEL_103:
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_http3_setup_connection_if_needed";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v30;
    os_log_type_t v48 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v61 = 0;
    if (!__nwlog_fault(v48, type, &v61)) {
      goto LABEL_129;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v49 = __nwlog_obj();
      os_log_type_t v50 = type[0];
      if (!os_log_type_enabled(v49, type[0])) {
        goto LABEL_129;
      }
      uint64_t v51 = "invalid";
      if (v13 && *(void *)(v13 + 16)) {
        uint64_t v51 = *(const char **)(v13 + 16);
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_http3_setup_connection_if_needed";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v51;
      BOOL v52 = "%{public}s protocol %{public}s has invalid connect callback";
    }
    else if (v61)
    {
      int v53 = (char *)__nw_create_backtrace_string();
      int v49 = __nwlog_obj();
      os_log_type_t v50 = type[0];
      BOOL v54 = os_log_type_enabled(v49, type[0]);
      if (v53)
      {
        if (v54)
        {
          BOOL v55 = "invalid";
          if (v13 && *(void *)(v13 + 16)) {
            BOOL v55 = *(const char **)(v13 + 16);
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_http3_setup_connection_if_needed";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v55;
          *(_WORD *)&unsigned char buf[22] = 2082;
          uint64_t v63 = v53;
          _os_log_impl(&dword_1830D4000, v49, v50, "%{public}s protocol %{public}s has invalid connect callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v53);
        goto LABEL_129;
      }
      if (!v54)
      {
LABEL_129:
        if (v48) {
          free(v48);
        }
        goto LABEL_36;
      }
      int v57 = "invalid";
      if (v13 && *(void *)(v13 + 16)) {
        int v57 = *(const char **)(v13 + 16);
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_http3_setup_connection_if_needed";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v57;
      BOOL v52 = "%{public}s protocol %{public}s has invalid connect callback, no backtrace";
    }
    else
    {
      int v49 = __nwlog_obj();
      os_log_type_t v50 = type[0];
      if (!os_log_type_enabled(v49, type[0])) {
        goto LABEL_129;
      }
      __int16 v56 = "invalid";
      if (v13 && *(void *)(v13 + 16)) {
        __int16 v56 = *(const char **)(v13 + 16);
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_http3_setup_connection_if_needed";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v56;
      BOOL v52 = "%{public}s protocol %{public}s has invalid connect callback, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v49, v50, v52, buf, 0x16u);
    goto LABEL_129;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_http3_setup_connection_if_needed";
  unint64_t v25 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  char v61 = 0;
  if (__nwlog_fault(v25, type, &v61))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      unint64_t v26 = __nwlog_obj();
      os_log_type_t v27 = type[0];
      if (!os_log_type_enabled(v26, type[0])) {
        goto LABEL_134;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http3_setup_connection_if_needed";
      id v28 = "%{public}s called with null http3";
      goto LABEL_133;
    }
    if (!v61)
    {
      unint64_t v26 = __nwlog_obj();
      os_log_type_t v27 = type[0];
      if (!os_log_type_enabled(v26, type[0])) {
        goto LABEL_134;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http3_setup_connection_if_needed";
      id v28 = "%{public}s called with null http3, backtrace limit exceeded";
      goto LABEL_133;
    }
    uint64_t v31 = (char *)__nw_create_backtrace_string();
    unint64_t v26 = __nwlog_obj();
    os_log_type_t v27 = type[0];
    BOOL v32 = os_log_type_enabled(v26, type[0]);
    if (v31)
    {
      if (v32)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http3_setup_connection_if_needed";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v31;
        _os_log_impl(&dword_1830D4000, v26, v27, "%{public}s called with null http3, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v31);
      goto LABEL_134;
    }
    if (v32)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http3_setup_connection_if_needed";
      id v28 = "%{public}s called with null http3, no backtrace";
LABEL_133:
      _os_log_impl(&dword_1830D4000, v26, v27, v28, buf, 0xCu);
    }
  }
LABEL_134:
  if (v25) {
    free(v25);
  }
}

void nw_http3_stream_connect_lower(uint64_t a1)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    int v2 = *(unsigned __int16 *)(a1 + 736);
    if ((v2 & 2) == 0) {
      return;
    }
    unsigned int v3 = v2 & 0xFFFFFFFD | (*(unsigned __int8 *)(a1 + 738) << 16);
    *(_WORD *)(a1 + 736) = v2 & 0xFFFD;
    *(unsigned char *)(a1 + 738) = BYTE2(v3);
    *(_DWORD *)(a1 + 368) = 1;
    uint64_t v4 = *(void *)(a1 + 32);
    if (v4)
    {
      uint64_t v5 = *(void *)(v4 + 24);
      if (v5)
      {
        uint64_t v6 = *(void (**)(void))(v5 + 24);
        if (v6)
        {
          v6();
          return;
        }
      }
    }
    __nwlog_obj();
    uint64_t v7 = *(void *)(a1 + 32);
    id v8 = "invalid";
    if (v7)
    {
      uint64_t v9 = *(const char **)(v7 + 16);
      if (v9) {
        id v8 = v9;
      }
    }
    *(_DWORD *)buf = 136446466;
    __int16 v38 = "nw_http3_stream_connect_lower";
    __int16 v39 = 2082;
    os_log_type_t v40 = (void *)v8;
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (!__nwlog_fault(v10, &type, &v35)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_55;
      }
      uint64_t v13 = *(void *)(a1 + 32);
      BOOL v14 = "invalid";
      if (v13)
      {
        uint64_t v15 = *(const char **)(v13 + 16);
        if (v15) {
          BOOL v14 = v15;
        }
      }
      *(_DWORD *)buf = 136446466;
      __int16 v38 = "nw_http3_stream_connect_lower";
      __int16 v39 = 2082;
      os_log_type_t v40 = (void *)v14;
      uint64_t v16 = "%{public}s protocol %{public}s has invalid connect callback";
    }
    else if (v35)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v20 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v20)
        {
          uint64_t v21 = *(void *)(a1 + 32);
          id v22 = "invalid";
          if (v21)
          {
            uint64_t v23 = *(const char **)(v21 + 16);
            if (v23) {
              id v22 = v23;
            }
          }
          *(_DWORD *)buf = 136446722;
          __int16 v38 = "nw_http3_stream_connect_lower";
          __int16 v39 = 2082;
          os_log_type_t v40 = (void *)v22;
          __int16 v41 = 2082;
          int v42 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s protocol %{public}s has invalid connect callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(backtrace_string);
LABEL_55:
        if (!v10) {
          return;
        }
LABEL_56:
        free(v10);
        return;
      }
      if (!v20) {
        goto LABEL_55;
      }
      uint64_t v29 = *(void *)(a1 + 32);
      uint64_t v30 = "invalid";
      if (v29)
      {
        uint64_t v31 = *(const char **)(v29 + 16);
        if (v31) {
          uint64_t v30 = v31;
        }
      }
      *(_DWORD *)buf = 136446466;
      __int16 v38 = "nw_http3_stream_connect_lower";
      __int16 v39 = 2082;
      os_log_type_t v40 = (void *)v30;
      uint64_t v16 = "%{public}s protocol %{public}s has invalid connect callback, no backtrace";
    }
    else
    {
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_55;
      }
      uint64_t v26 = *(void *)(a1 + 32);
      os_log_type_t v27 = "invalid";
      if (v26)
      {
        id v28 = *(const char **)(v26 + 16);
        if (v28) {
          os_log_type_t v27 = v28;
        }
      }
      *(_DWORD *)buf = 136446466;
      __int16 v38 = "nw_http3_stream_connect_lower";
      __int16 v39 = 2082;
      os_log_type_t v40 = (void *)v27;
      uint64_t v16 = "%{public}s protocol %{public}s has invalid connect callback, backtrace limit exceeded";
    }
    BOOL v32 = v11;
    os_log_type_t v33 = v12;
    uint32_t v34 = 22;
LABEL_54:
    _os_log_impl(&dword_1830D4000, v32, v33, v16, buf, v34);
    goto LABEL_55;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v38 = "nw_http3_stream_connect_lower";
  uint64_t v10 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v35 = 0;
  if (!__nwlog_fault(v10, &type, &v35)) {
    goto LABEL_55;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    id v17 = __nwlog_obj();
    os_log_type_t v18 = type;
    if (!os_log_type_enabled(v17, type)) {
      goto LABEL_55;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v38 = "nw_http3_stream_connect_lower";
    uint64_t v16 = "%{public}s called with null http3_stream";
LABEL_53:
    BOOL v32 = v17;
    os_log_type_t v33 = v18;
    uint32_t v34 = 12;
    goto LABEL_54;
  }
  if (!v35)
  {
    id v17 = __nwlog_obj();
    os_log_type_t v18 = type;
    if (!os_log_type_enabled(v17, type)) {
      goto LABEL_55;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v38 = "nw_http3_stream_connect_lower";
    uint64_t v16 = "%{public}s called with null http3_stream, backtrace limit exceeded";
    goto LABEL_53;
  }
  int v24 = (char *)__nw_create_backtrace_string();
  id v17 = __nwlog_obj();
  os_log_type_t v18 = type;
  BOOL v25 = os_log_type_enabled(v17, type);
  if (!v24)
  {
    if (!v25) {
      goto LABEL_55;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v38 = "nw_http3_stream_connect_lower";
    uint64_t v16 = "%{public}s called with null http3_stream, no backtrace";
    goto LABEL_53;
  }
  if (v25)
  {
    *(_DWORD *)buf = 136446466;
    __int16 v38 = "nw_http3_stream_connect_lower";
    __int16 v39 = 2082;
    os_log_type_t v40 = v24;
    _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s called with null http3_stream, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v24);
  if (v10) {
    goto LABEL_56;
  }
}

void nw_http3_parse_resumable_session_data(uint64_t a1, int *a2, unint64_t a3)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return;
  }
  if (a3 <= 0xF && ((*(unsigned __int16 *)(a1 + 1373) | (*(unsigned __int8 *)(a1 + 1375) << 16)) & 0x400000) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v6 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      int v7 = *(_DWORD *)(a1 + 1280);
      int v25 = 136447234;
      uint64_t v26 = "nw_http3_parse_resumable_session_data";
      __int16 v27 = 2082;
      uint64_t v28 = a1 + 1289;
      __int16 v29 = 2080;
      uint64_t v30 = " ";
      __int16 v31 = 1024;
      int v32 = v7;
      __int16 v33 = 2048;
      unint64_t v34 = a3;
      _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Resumable session too short (%zu bytes)", (uint8_t *)&v25, 0x30u);
    }
  }
  if (*a2 != 9685181)
  {
    if (((*(unsigned __int16 *)(a1 + 1373) | (*(unsigned __int8 *)(a1 + 1375) << 16)) & 0x400000) != 0) {
      return;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v13 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
      return;
    }
    int v14 = *(_DWORD *)(a1 + 1280);
    int v15 = *a2;
    int v25 = 136447234;
    uint64_t v26 = "nw_http3_parse_resumable_session_data";
    __int16 v27 = 2082;
    uint64_t v28 = a1 + 1289;
    __int16 v29 = 2080;
    uint64_t v30 = " ";
    __int16 v31 = 1024;
    int v32 = v14;
    __int16 v33 = 1024;
    LODWORD(v34) = v15;
    uint64_t v16 = "%{public}s %{public}s%s<i%u> Unrecognized resumable session version %x";
    id v17 = v13;
    os_log_type_t v18 = OS_LOG_TYPE_INFO;
    uint32_t v19 = 44;
LABEL_21:
    _os_log_impl(&dword_1830D4000, v17, v18, v16, (uint8_t *)&v25, v19);
    return;
  }
  size_t v8 = a2[1];
  if (v8 + a2[2] + a2[3] + 16 != a3)
  {
    if (((*(unsigned __int16 *)(a1 + 1373) | (*(unsigned __int8 *)(a1 + 1375) << 16)) & 0x400000) != 0) {
      return;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v20 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v21 = *(_DWORD *)(a1 + 1280);
    int v22 = a2[1];
    int v23 = a2[2];
    int v24 = a2[3];
    int v25 = 136448258;
    uint64_t v26 = "nw_http3_parse_resumable_session_data";
    __int16 v27 = 2082;
    uint64_t v28 = a1 + 1289;
    __int16 v29 = 2080;
    uint64_t v30 = " ";
    __int16 v31 = 1024;
    int v32 = v21;
    __int16 v33 = 2048;
    unint64_t v34 = a3;
    __int16 v35 = 2048;
    uint64_t v36 = 16;
    __int16 v37 = 1024;
    int v38 = v22;
    __int16 v39 = 1024;
    int v40 = v23;
    __int16 v41 = 1024;
    int v42 = v24;
    uint64_t v16 = "%{public}s %{public}s%s<i%u> Invalid resumable session length (%zu != %zu+%u+%u+%u)";
    id v17 = v20;
    os_log_type_t v18 = OS_LOG_TYPE_ERROR;
    uint32_t v19 = 76;
    goto LABEL_21;
  }
  uint64_t v9 = *(NSObject **)(a1 + 1152);
  if (v9)
  {
    dispatch_release(v9);
    *(void *)(a1 + 1152) = 0;
    size_t v8 = a2[1];
  }
  uint64_t v10 = a2 + 4;
  *(void *)(a1 + 1152) = dispatch_data_create(a2 + 4, v8, 0, 0);
  uint64_t v11 = *(NSObject **)(a1 + 1136);
  if (v11)
  {
    dispatch_release(v11);
    *(void *)(a1 + 1136) = 0;
  }
  *(void *)(a1 + 1136) = dispatch_data_create((char *)v10 + a2[1], a2[2], 0, 0);
  os_log_type_t v12 = *(NSObject **)(a1 + 1144);
  if (v12)
  {
    dispatch_release(v12);
    *(void *)(a1 + 1144) = 0;
  }
  *(void *)(a1 + 1144) = dispatch_data_create((char *)v10 + a2[1] + a2[2], a2[3], 0, 0);
}

void ___ZL32nw_http3_start_0rtt_state_lookupP17nw_protocol_http3_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  if (v3)
  {
    uint64_t v4 = v3;
    if (a2 && *(void *)(a2 + 24) - *(void *)(a2 + 16) == 8)
    {
      uint64_t object_at_index = nw_array_get_object_at_index(a2, 0);
      if (!object_at_index) {
        return;
      }
      uint64_t v6 = object_at_index;
      if (*(void *)(object_at_index + 24) - *(void *)(object_at_index + 16) != 24) {
        return;
      }
      int v7 = nw_array_get_object_at_index(object_at_index, 0);
      size_t v8 = nw_array_get_object_at_index(v6, 1uLL);
      uint64_t v9 = nw_array_get_object_at_index(v6, 2uLL);
      *(_WORD *)(v4 + 1373) |= 0x40u;
      if (v7)
      {
        if (v8)
        {
          uint64_t v10 = v9;
          if (v9)
          {
            uint64_t v11 = *(NSObject **)(v4 + 1152);
            if (v11) {
              dispatch_release(v11);
            }
            *(void *)(v4 + 1152) = v7;
            dispatch_retain(v7);
            os_log_type_t v12 = *(NSObject **)(v4 + 1136);
            if (v12) {
              dispatch_release(v12);
            }
            *(void *)(v4 + 1136) = v8;
            dispatch_retain(v8);
            uint64_t v13 = *(NSObject **)(v4 + 1144);
            if (v13) {
              dispatch_release(v13);
            }
            *(void *)(v4 + 1144) = v10;
            dispatch_retain(v10);
          }
        }
      }
      nw_http3_setup_connection_if_needed(v4);
      for (uint64_t i = *(void *)(v4 + 880); i; uint64_t i = *(void *)(i + 544))
        nw_http3_stream_connect_lower(i);
    }
    else
    {
      *(_WORD *)(v3 + 1373) |= 0x40u;
      nw_http3_setup_connection_if_needed(v3);
      for (uint64_t j = *(void *)(v4 + 880); j; uint64_t j = *(void *)(j + 544))
        nw_http3_stream_connect_lower(j);
    }
    nw_http3_signal_output_pending(v4, 0);
  }
}

void nw_protocol_http3_input_finished(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v18 = "nw_protocol_http3_input_finished";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (!__nwlog_fault(v3, &type, &v15)) {
      goto LABEL_52;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v18 = "nw_protocol_http3_input_finished";
      uint64_t v6 = "%{public}s called with null protocol";
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v10 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v18 = "nw_protocol_http3_input_finished";
          __int16 v19 = 2082;
          uint64_t v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_52:
        if (!v3) {
          return;
        }
        goto LABEL_53;
      }
      if (!v10) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v18 = "nw_protocol_http3_input_finished";
      uint64_t v6 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v18 = "nw_protocol_http3_input_finished";
      uint64_t v6 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_51;
  }
  uint64_t handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v18 = "nw_protocol_http3_input_finished";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (!__nwlog_fault(v3, &type, &v15)) {
      goto LABEL_52;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v15)
      {
        uint64_t v4 = __nwlog_obj();
        os_log_type_t v5 = type;
        if (!os_log_type_enabled(v4, type)) {
          goto LABEL_52;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v18 = "nw_protocol_http3_input_finished";
        uint64_t v6 = "%{public}s called with null http3, backtrace limit exceeded";
        goto LABEL_51;
      }
      uint64_t v11 = (char *)__nw_create_backtrace_string();
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v12 = os_log_type_enabled(v4, type);
      if (!v11)
      {
        if (!v12) {
          goto LABEL_52;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v18 = "nw_protocol_http3_input_finished";
        uint64_t v6 = "%{public}s called with null http3, no backtrace";
        goto LABEL_51;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v18 = "nw_protocol_http3_input_finished";
        __int16 v19 = 2082;
        uint64_t v20 = v11;
        uint64_t v13 = "%{public}s called with null http3, dumping backtrace:%{public}s";
LABEL_36:
        _os_log_impl(&dword_1830D4000, v4, v5, v13, buf, 0x16u);
      }
LABEL_37:
      free(v11);
      if (!v3) {
        return;
      }
LABEL_53:
      free(v3);
      return;
    }
    uint64_t v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_52;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v18 = "nw_protocol_http3_input_finished";
    uint64_t v6 = "%{public}s called with null http3";
LABEL_51:
    _os_log_impl(&dword_1830D4000, v4, v5, v6, buf, 0xCu);
    goto LABEL_52;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v18 = "nw_protocol_http3_input_finished";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (!__nwlog_fault(v3, &type, &v15)) {
      goto LABEL_52;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v18 = "nw_protocol_http3_input_finished";
      uint64_t v6 = "%{public}s called with null other_protocol";
      goto LABEL_51;
    }
    if (!v15)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v18 = "nw_protocol_http3_input_finished";
      uint64_t v6 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_51;
    }
    uint64_t v11 = (char *)__nw_create_backtrace_string();
    uint64_t v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v14 = os_log_type_enabled(v4, type);
    if (!v11)
    {
      if (!v14) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v18 = "nw_protocol_http3_input_finished";
      uint64_t v6 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_51;
    }
    if (v14)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v18 = "nw_protocol_http3_input_finished";
      __int16 v19 = 2082;
      uint64_t v20 = v11;
      uint64_t v13 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_36;
    }
    goto LABEL_37;
  }
  if (((*(unsigned __int16 *)(handle + 1373) | (handle[1375] << 16)) & 0x400000) == 0)
  {
    if (gLogDatapath)
    {
      int v7 = __nwlog_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        int v8 = *((_DWORD *)handle + 320);
        *(_DWORD *)buf = 136446978;
        os_log_type_t v18 = "nw_protocol_http3_input_finished";
        __int16 v19 = 2082;
        uint64_t v20 = handle + 1289;
        __int16 v21 = 2080;
        int v22 = " ";
        __int16 v23 = 1024;
        int v24 = v8;
        _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
      }
    }
  }
  if ((*(_WORD *)(handle + 1373) & 8) == 0) {
    nw_http3_fail_all_streams((uint64_t)handle, 260);
  }
}

void nw_protocol_http3_output_finished(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v21 = "nw_protocol_http3_output_finished";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (!__nwlog_fault(v3, &type, &v18)) {
      goto LABEL_17;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_17;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v21 = "nw_protocol_http3_output_finished";
      uint64_t v6 = "%{public}s called with null protocol";
      goto LABEL_15;
    }
    if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v14 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (!v14) {
          goto LABEL_47;
        }
        *(_DWORD *)buf = 136446466;
        __int16 v21 = "nw_protocol_http3_output_finished";
        __int16 v22 = 2082;
        __int16 v23 = backtrace_string;
        char v15 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
        goto LABEL_46;
      }
      if (!v14) {
        goto LABEL_17;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v21 = "nw_protocol_http3_output_finished";
      uint64_t v6 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_17;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v21 = "nw_protocol_http3_output_finished";
      uint64_t v6 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_15:
    uint64_t v11 = v4;
    os_log_type_t v12 = v5;
LABEL_16:
    _os_log_impl(&dword_1830D4000, v11, v12, v6, buf, 0xCu);
    goto LABEL_17;
  }
  if (!a1->handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v21 = "nw_protocol_http3_output_finished";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (!__nwlog_fault(v3, &type, &v18)) {
      goto LABEL_17;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_17;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v21 = "nw_protocol_http3_output_finished";
      uint64_t v6 = "%{public}s called with null http3";
      goto LABEL_15;
    }
    if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v16 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (!v16) {
          goto LABEL_47;
        }
        *(_DWORD *)buf = 136446466;
        __int16 v21 = "nw_protocol_http3_output_finished";
        __int16 v22 = 2082;
        __int16 v23 = backtrace_string;
        char v15 = "%{public}s called with null http3, dumping backtrace:%{public}s";
        goto LABEL_46;
      }
      if (!v16) {
        goto LABEL_17;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v21 = "nw_protocol_http3_output_finished";
      uint64_t v6 = "%{public}s called with null http3, no backtrace";
    }
    else
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_17;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v21 = "nw_protocol_http3_output_finished";
      uint64_t v6 = "%{public}s called with null http3, backtrace limit exceeded";
    }
    goto LABEL_15;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  if (a2)
  {
    *(_DWORD *)buf = 136446210;
    __int16 v21 = "nw_protocol_http3_output_finished";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (!__nwlog_fault(v3, &type, &v18)) {
      goto LABEL_17;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v4 = gLogObj;
      os_log_type_t v5 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_17;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v21 = "nw_protocol_http3_output_finished";
      uint64_t v6 = "%{public}s http3 should not get output_finished";
      goto LABEL_15;
    }
    if (!v18)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v4 = gLogObj;
      os_log_type_t v5 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_17;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v21 = "nw_protocol_http3_output_finished";
      uint64_t v6 = "%{public}s http3 should not get output_finished, backtrace limit exceeded";
      goto LABEL_15;
    }
    int v7 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v8 = gLogObj;
    os_log_type_t v9 = type;
    BOOL v10 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (v7)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v21 = "nw_protocol_http3_output_finished";
        __int16 v22 = 2082;
        __int16 v23 = v7;
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s http3 should not get output_finished, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v7);
    }
    else if (v10)
    {
      *(_DWORD *)buf = 136446210;
      __int16 v21 = "nw_protocol_http3_output_finished";
      uint64_t v6 = "%{public}s http3 should not get output_finished, no backtrace";
      uint64_t v11 = v8;
      os_log_type_t v12 = v9;
      goto LABEL_16;
    }
LABEL_17:
    if (!v3) {
      return;
    }
    goto LABEL_18;
  }
  *(_DWORD *)buf = 136446210;
  __int16 v21 = "nw_protocol_http3_output_finished";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (!__nwlog_fault(v3, &type, &v18)) {
    goto LABEL_17;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_17;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v21 = "nw_protocol_http3_output_finished";
    uint64_t v6 = "%{public}s called with null other_protocol";
    goto LABEL_15;
  }
  if (!v18)
  {
    uint64_t v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_17;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v21 = "nw_protocol_http3_output_finished";
    uint64_t v6 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    goto LABEL_15;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  uint64_t v4 = __nwlog_obj();
  os_log_type_t v5 = type;
  BOOL v17 = os_log_type_enabled(v4, type);
  if (!backtrace_string)
  {
    if (!v17) {
      goto LABEL_17;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v21 = "nw_protocol_http3_output_finished";
    uint64_t v6 = "%{public}s called with null other_protocol, no backtrace";
    goto LABEL_15;
  }
  if (!v17) {
    goto LABEL_47;
  }
  *(_DWORD *)buf = 136446466;
  __int16 v21 = "nw_protocol_http3_output_finished";
  __int16 v22 = 2082;
  __int16 v23 = backtrace_string;
  char v15 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
LABEL_46:
  _os_log_impl(&dword_1830D4000, v4, v5, v15, buf, 0x16u);
LABEL_47:
  free(backtrace_string);
  if (v3) {
LABEL_18:
  }
    free(v3);
}

void nw_protocol_http3_error(nw_protocol *a1, nw_protocol *a2, int a3)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)block = 136446210;
    *(void *)&block[4] = "nw_protocol_http3_error";
    uint64_t v24 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v51 = 0;
    if (!__nwlog_fault(v24, &type, &v51)) {
      goto LABEL_92;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (!os_log_type_enabled(v25, type)) {
        goto LABEL_92;
      }
      *(_DWORD *)block = 136446210;
      *(void *)&block[4] = "nw_protocol_http3_error";
      __int16 v27 = "%{public}s called with null protocol";
    }
    else if (v51)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      BOOL v31 = os_log_type_enabled(v25, type);
      if (backtrace_string)
      {
        if (v31)
        {
          *(_DWORD *)block = 136446466;
          *(void *)&block[4] = "nw_protocol_http3_error";
          *(_WORD *)&block[12] = 2082;
          *(void *)&block[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v25, v26, "%{public}s called with null protocol, dumping backtrace:%{public}s", block, 0x16u);
        }
        free(backtrace_string);
LABEL_92:
        if (!v24) {
          return;
        }
        goto LABEL_93;
      }
      if (!v31) {
        goto LABEL_92;
      }
      *(_DWORD *)block = 136446210;
      *(void *)&block[4] = "nw_protocol_http3_error";
      __int16 v27 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (!os_log_type_enabled(v25, type)) {
        goto LABEL_92;
      }
      *(_DWORD *)block = 136446210;
      *(void *)&block[4] = "nw_protocol_http3_error";
      __int16 v27 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_91;
  }
  uint64_t handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)block = 136446210;
    *(void *)&block[4] = "nw_protocol_http3_error";
    uint64_t v24 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v51 = 0;
    if (!__nwlog_fault(v24, &type, &v51)) {
      goto LABEL_92;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v51)
      {
        uint64_t v25 = __nwlog_obj();
        os_log_type_t v26 = type;
        if (!os_log_type_enabled(v25, type)) {
          goto LABEL_92;
        }
        *(_DWORD *)block = 136446210;
        *(void *)&block[4] = "nw_protocol_http3_error";
        __int16 v27 = "%{public}s called with null http3, backtrace limit exceeded";
        goto LABEL_91;
      }
      int v32 = (char *)__nw_create_backtrace_string();
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      BOOL v33 = os_log_type_enabled(v25, type);
      if (!v32)
      {
        if (!v33) {
          goto LABEL_92;
        }
        *(_DWORD *)block = 136446210;
        *(void *)&block[4] = "nw_protocol_http3_error";
        __int16 v27 = "%{public}s called with null http3, no backtrace";
        goto LABEL_91;
      }
      if (v33)
      {
        *(_DWORD *)block = 136446466;
        *(void *)&block[4] = "nw_protocol_http3_error";
        *(_WORD *)&block[12] = 2082;
        *(void *)&block[14] = v32;
        unint64_t v34 = "%{public}s called with null http3, dumping backtrace:%{public}s";
LABEL_62:
        _os_log_impl(&dword_1830D4000, v25, v26, v34, block, 0x16u);
      }
LABEL_63:
      free(v32);
      if (!v24) {
        return;
      }
LABEL_93:
      free(v24);
      return;
    }
    uint64_t v25 = __nwlog_obj();
    os_log_type_t v26 = type;
    if (!os_log_type_enabled(v25, type)) {
      goto LABEL_92;
    }
    *(_DWORD *)block = 136446210;
    *(void *)&block[4] = "nw_protocol_http3_error";
    __int16 v27 = "%{public}s called with null http3";
LABEL_91:
    _os_log_impl(&dword_1830D4000, v25, v26, v27, block, 0xCu);
    goto LABEL_92;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)block = 136446210;
    *(void *)&block[4] = "nw_protocol_http3_error";
    uint64_t v24 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v51 = 0;
    if (!__nwlog_fault(v24, &type, &v51)) {
      goto LABEL_92;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (!os_log_type_enabled(v25, type)) {
        goto LABEL_92;
      }
      *(_DWORD *)block = 136446210;
      *(void *)&block[4] = "nw_protocol_http3_error";
      __int16 v27 = "%{public}s called with null other_protocol";
      goto LABEL_91;
    }
    if (!v51)
    {
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (!os_log_type_enabled(v25, type)) {
        goto LABEL_92;
      }
      *(_DWORD *)block = 136446210;
      *(void *)&block[4] = "nw_protocol_http3_error";
      __int16 v27 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_91;
    }
    int v32 = (char *)__nw_create_backtrace_string();
    uint64_t v25 = __nwlog_obj();
    os_log_type_t v26 = type;
    BOOL v35 = os_log_type_enabled(v25, type);
    if (!v32)
    {
      if (!v35) {
        goto LABEL_92;
      }
      *(_DWORD *)block = 136446210;
      *(void *)&block[4] = "nw_protocol_http3_error";
      __int16 v27 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_91;
    }
    if (v35)
    {
      *(_DWORD *)block = 136446466;
      *(void *)&block[4] = "nw_protocol_http3_error";
      *(_WORD *)&block[12] = 2082;
      *(void *)&block[14] = v32;
      unint64_t v34 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_62;
    }
    goto LABEL_63;
  }
  int v7 = handle + 1373;
  if (((*(unsigned __int16 *)(handle + 1373) | (handle[1375] << 16)) & 0x400000) == 0)
  {
    if (gLogDatapath)
    {
      uint64_t v28 = __nwlog_obj();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
      {
        int v29 = *((_DWORD *)handle + 320);
        *(_DWORD *)block = 136446978;
        *(void *)&block[4] = "nw_protocol_http3_error";
        *(_WORD *)&block[12] = 2082;
        *(void *)&block[14] = handle + 1289;
        *(_WORD *)&block[22] = 2080;
        BOOL v54 = " ";
        LOWORD(v55) = 1024;
        *(_DWORD *)((char *)&v55 + 2) = v29;
        _os_log_impl(&dword_1830D4000, v28, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", block, 0x26u);
      }
    }
  }
  if (a3 == 35)
  {
    int v8 = (unsigned __int16)*v7;
    if ((v8 & 0x100) != 0)
    {
      if (a1->output_handler != a2) {
        return;
      }
      if (((v8 | (handle[1375] << 16)) & 0x400000) == 0)
      {
        if (gLogDatapath)
        {
          uint64_t v36 = __nwlog_obj();
          if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
          {
            int v37 = *((_DWORD *)handle + 320);
            *(_DWORD *)block = 136446978;
            *(void *)&block[4] = "nw_protocol_http3_error";
            *(_WORD *)&block[12] = 2082;
            *(void *)&block[14] = handle + 1289;
            *(_WORD *)&block[22] = 2080;
            BOOL v54 = " ";
            LOWORD(v55) = 1024;
            *(_DWORD *)((char *)&v55 + 2) = v37;
            _os_log_impl(&dword_1830D4000, v36, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> early data rejected", block, 0x26u);
          }
        }
      }
      if (!uuid_is_null((const unsigned __int8 *)handle + 848))
      {
        BOOL v14 = (void *)*((void *)handle + 139);
        if (v14) {
          nw_path_report_error_to_agent(v14, (const unsigned __int8 *)handle + 848, 35);
        }
        goto LABEL_33;
      }
      if (nw_storage_copy_shared_token[0] != -1) {
        dispatch_once(nw_storage_copy_shared_token, &__block_literal_global_45557);
      }
      id v9 = (id)nw_storage_copy_shared_storage;
      BOOL v10 = (void *)*((void *)handle + 137);
      if (v10) {
        uint64_t v11 = os_retain(v10);
      }
      else {
        uint64_t v11 = 0;
      }
      while (1)
      {
        char v15 = v11;
        id v16 = nw_endpoint_copy_parent_endpoint(v11);
        if (!v16) {
          break;
        }
        uint64_t v11 = v16;
        if (v15) {
          os_release(v15);
        }
      }
      BOOL v17 = (void *)*((void *)handle + 157);
      char v18 = v9;
      id v19 = v15;
      id v20 = v17;
      id v21 = &__block_literal_global_130;
      if (v18)
      {
        if (v19)
        {
          if (v20)
          {
            __int16 v22 = v18[2];
            *(void *)block = MEMORY[0x1E4F143A8];
            *(void *)&block[8] = 3221225472;
            *(void *)&block[16] = __nw_storage_remove_items_block_invoke;
            BOOL v54 = (const char *)&unk_1E52499D0;
            BOOL v55 = v18;
            char v61 = "h3_0rtt";
            id v56 = v19;
            id v57 = 0;
            id v58 = 0;
            id v59 = v20;
            id v23 = &__block_literal_global_130;
            id v60 = &__block_literal_global_130;
            dispatch_async(v22, block);

LABEL_29:
            if (v19) {
              os_release(v19);
            }
            if (v18) {
              os_release(v18);
            }
LABEL_33:
            *v7 |= 0x200u;
            return;
          }
          uint64_t v44 = __nwlog_obj();
          *(_DWORD *)block = 136446210;
          *(void *)&block[4] = "nw_storage_remove_items";
          __int16 v39 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v51 = 0;
          if (!__nwlog_fault(v39, &type, &v51)) {
            goto LABEL_124;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            int v40 = __nwlog_obj();
            os_log_type_t v41 = type;
            if (os_log_type_enabled(v40, type))
            {
              *(_DWORD *)block = 136446210;
              *(void *)&block[4] = "nw_storage_remove_items";
              int v42 = "%{public}s called with null context";
              goto LABEL_122;
            }
LABEL_123:

            goto LABEL_124;
          }
          if (!v51)
          {
            int v40 = __nwlog_obj();
            os_log_type_t v41 = type;
            if (os_log_type_enabled(v40, type))
            {
              *(_DWORD *)block = 136446210;
              *(void *)&block[4] = "nw_storage_remove_items";
              int v42 = "%{public}s called with null context, backtrace limit exceeded";
              goto LABEL_122;
            }
            goto LABEL_123;
          }
          __int16 v47 = (char *)__nw_create_backtrace_string();
          int v40 = __nwlog_obj();
          os_log_type_t v41 = type;
          BOOL v50 = os_log_type_enabled(v40, type);
          if (!v47)
          {
            if (v50)
            {
              *(_DWORD *)block = 136446210;
              *(void *)&block[4] = "nw_storage_remove_items";
              int v42 = "%{public}s called with null context, no backtrace";
              goto LABEL_122;
            }
            goto LABEL_123;
          }
          if (v50)
          {
            *(_DWORD *)block = 136446466;
            *(void *)&block[4] = "nw_storage_remove_items";
            *(_WORD *)&block[12] = 2082;
            *(void *)&block[14] = v47;
            int v49 = "%{public}s called with null context, dumping backtrace:%{public}s";
            goto LABEL_107;
          }
          goto LABEL_108;
        }
        uint64_t v43 = __nwlog_obj();
        *(_DWORD *)block = 136446210;
        *(void *)&block[4] = "nw_storage_remove_items";
        __int16 v39 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v51 = 0;
        if (!__nwlog_fault(v39, &type, &v51)) {
          goto LABEL_124;
        }
        if (type != OS_LOG_TYPE_FAULT)
        {
          if (!v51)
          {
            int v40 = __nwlog_obj();
            os_log_type_t v41 = type;
            if (os_log_type_enabled(v40, type))
            {
              *(_DWORD *)block = 136446210;
              *(void *)&block[4] = "nw_storage_remove_items";
              int v42 = "%{public}s called with null endpoint, backtrace limit exceeded";
              goto LABEL_122;
            }
            goto LABEL_123;
          }
          __int16 v47 = (char *)__nw_create_backtrace_string();
          int v40 = __nwlog_obj();
          os_log_type_t v41 = type;
          BOOL v48 = os_log_type_enabled(v40, type);
          if (!v47)
          {
            if (v48)
            {
              *(_DWORD *)block = 136446210;
              *(void *)&block[4] = "nw_storage_remove_items";
              int v42 = "%{public}s called with null endpoint, no backtrace";
              goto LABEL_122;
            }
            goto LABEL_123;
          }
          if (v48)
          {
            *(_DWORD *)block = 136446466;
            *(void *)&block[4] = "nw_storage_remove_items";
            *(_WORD *)&block[12] = 2082;
            *(void *)&block[14] = v47;
            int v49 = "%{public}s called with null endpoint, dumping backtrace:%{public}s";
LABEL_107:
            _os_log_impl(&dword_1830D4000, v40, v41, v49, block, 0x16u);
          }
LABEL_108:

          free(v47);
          if (!v39) {
            goto LABEL_29;
          }
          goto LABEL_125;
        }
        int v40 = __nwlog_obj();
        os_log_type_t v41 = type;
        if (!os_log_type_enabled(v40, type)) {
          goto LABEL_123;
        }
        *(_DWORD *)block = 136446210;
        *(void *)&block[4] = "nw_storage_remove_items";
        int v42 = "%{public}s called with null endpoint";
      }
      else
      {
        int v38 = __nwlog_obj();
        *(_DWORD *)block = 136446210;
        *(void *)&block[4] = "nw_storage_remove_items";
        __int16 v39 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v51 = 0;
        if (!__nwlog_fault(v39, &type, &v51)) {
          goto LABEL_124;
        }
        if (type != OS_LOG_TYPE_FAULT)
        {
          if (v51)
          {
            int v45 = (char *)__nw_create_backtrace_string();
            int v40 = __nwlog_obj();
            os_log_type_t v41 = type;
            BOOL v46 = os_log_type_enabled(v40, type);
            if (v45)
            {
              if (v46)
              {
                *(_DWORD *)block = 136446466;
                *(void *)&block[4] = "nw_storage_remove_items";
                *(_WORD *)&block[12] = 2082;
                *(void *)&block[14] = v45;
                _os_log_impl(&dword_1830D4000, v40, v41, "%{public}s called with null storage, dumping backtrace:%{public}s", block, 0x16u);
              }

              free(v45);
LABEL_124:
              if (!v39) {
                goto LABEL_29;
              }
LABEL_125:
              free(v39);
              goto LABEL_29;
            }
            if (v46)
            {
              *(_DWORD *)block = 136446210;
              *(void *)&block[4] = "nw_storage_remove_items";
              int v42 = "%{public}s called with null storage, no backtrace";
              goto LABEL_122;
            }
          }
          else
          {
            int v40 = __nwlog_obj();
            os_log_type_t v41 = type;
            if (os_log_type_enabled(v40, type))
            {
              *(_DWORD *)block = 136446210;
              *(void *)&block[4] = "nw_storage_remove_items";
              int v42 = "%{public}s called with null storage, backtrace limit exceeded";
              goto LABEL_122;
            }
          }
          goto LABEL_123;
        }
        int v40 = __nwlog_obj();
        os_log_type_t v41 = type;
        if (!os_log_type_enabled(v40, type)) {
          goto LABEL_123;
        }
        *(_DWORD *)block = 136446210;
        *(void *)&block[4] = "nw_storage_remove_items";
        int v42 = "%{public}s called with null storage";
      }
LABEL_122:
      _os_log_impl(&dword_1830D4000, v40, v41, v42, block, 0xCu);
      goto LABEL_123;
    }
  }
  os_log_type_t v12 = (nw_protocol *)*((void *)handle + 110);
  if (v12)
  {
    do
    {
      output_handler = v12[8].output_handler;
      nw_protocol_http3_stream_error(v12, a2, a3);
      os_log_type_t v12 = output_handler;
    }
    while (output_handler);
  }
}

void nw_protocol_http3_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v122 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v115 = "nw_protocol_http3_disconnected";
    int v49 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v112 = 0;
    if (!__nwlog_fault(v49, &type, &v112)) {
      goto LABEL_153;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v50 = __nwlog_obj();
      os_log_type_t v51 = type;
      if (!os_log_type_enabled(v50, type)) {
        goto LABEL_153;
      }
      *(_DWORD *)buf = 136446210;
      int v115 = "nw_protocol_http3_disconnected";
      BOOL v52 = "%{public}s called with null protocol";
    }
    else if (v112)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v50 = __nwlog_obj();
      os_log_type_t v51 = type;
      BOOL v81 = os_log_type_enabled(v50, type);
      if (backtrace_string)
      {
        if (v81)
        {
          *(_DWORD *)buf = 136446466;
          int v115 = "nw_protocol_http3_disconnected";
          __int16 v116 = 2082;
          char v117 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v50, v51, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_153:
        if (!v49) {
          return;
        }
LABEL_154:
        free(v49);
        return;
      }
      if (!v81) {
        goto LABEL_153;
      }
      *(_DWORD *)buf = 136446210;
      int v115 = "nw_protocol_http3_disconnected";
      BOOL v52 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      BOOL v50 = __nwlog_obj();
      os_log_type_t v51 = type;
      if (!os_log_type_enabled(v50, type)) {
        goto LABEL_153;
      }
      *(_DWORD *)buf = 136446210;
      int v115 = "nw_protocol_http3_disconnected";
      BOOL v52 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_152:
    _os_log_impl(&dword_1830D4000, v50, v51, v52, buf, 0xCu);
    goto LABEL_153;
  }
  uint64_t handle = (char *)a1->handle;
  if (handle)
  {
    uint64_t v4 = handle + 1373;
    if (((*(unsigned __int16 *)(handle + 1373) | (handle[1375] << 16)) & 0x400000) == 0)
    {
      if (gLogDatapath)
      {
        int v53 = __nwlog_obj();
        if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG))
        {
          int v54 = *((_DWORD *)handle + 320);
          *(_DWORD *)buf = 136446978;
          int v115 = "nw_protocol_http3_disconnected";
          __int16 v116 = 2082;
          char v117 = handle + 1289;
          __int16 v118 = 2080;
          unint64_t v119 = " ";
          __int16 v120 = 1024;
          int v121 = v54;
          _os_log_impl(&dword_1830D4000, v53, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
        }
      }
    }
    int v5 = (unsigned __int16)*v4;
    if ((v5 & 0x200) == 0)
    {
      if ((*v4 & 8) == 0) {
        nw_http3_fail_all_streams((uint64_t)handle, 260);
      }
      return;
    }
    unsigned int v6 = v5 & 0xFFFFFDFF | (handle[1375] << 16);
    *uint64_t v4 = v5 & 0xFDFF;
    handle[1375] = BYTE2(v6);
    output_handler = a1->output_handler;
    uint64_t v8 = *((void *)handle + 4);
    if (v8)
    {
      uint64_t v9 = *(void *)(v8 + 24);
      if (v9)
      {
        BOOL v10 = *(void (**)(void))(v9 + 8);
        if (v10)
        {
          v10();
          goto LABEL_12;
        }
      }
    }
    __nwlog_obj();
    uint64_t v39 = *((void *)handle + 4);
    int v40 = "invalid";
    if (v39)
    {
      os_log_type_t v41 = *(const char **)(v39 + 16);
      if (v41) {
        int v40 = v41;
      }
    }
    *(_DWORD *)buf = 136446466;
    int v115 = "nw_http3_reset";
    __int16 v116 = 2082;
    char v117 = (char *)v40;
    int v42 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v112 = 0;
    if (__nwlog_fault(v42, &type, &v112))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v43 = __nwlog_obj();
        os_log_type_t v44 = type;
        if (!os_log_type_enabled(v43, type)) {
          goto LABEL_136;
        }
        uint64_t v45 = *((void *)handle + 4);
        BOOL v46 = "invalid";
        if (v45)
        {
          __int16 v47 = *(const char **)(v45 + 16);
          if (v47) {
            BOOL v46 = v47;
          }
        }
        *(_DWORD *)buf = 136446466;
        int v115 = "nw_http3_reset";
        __int16 v116 = 2082;
        char v117 = (char *)v46;
        BOOL v48 = "%{public}s protocol %{public}s has invalid remove_input_handler callback";
        goto LABEL_135;
      }
      if (!v112)
      {
        uint64_t v43 = __nwlog_obj();
        os_log_type_t v44 = type;
        if (!os_log_type_enabled(v43, type)) {
          goto LABEL_136;
        }
        uint64_t v94 = *((void *)handle + 4);
        int v95 = "invalid";
        if (v94)
        {
          __int16 v96 = *(const char **)(v94 + 16);
          if (v96) {
            int v95 = v96;
          }
        }
        *(_DWORD *)buf = 136446466;
        int v115 = "nw_http3_reset";
        __int16 v116 = 2082;
        char v117 = (char *)v95;
        BOOL v48 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, backtrace limit exceeded";
        goto LABEL_135;
      }
      BOOL v75 = (char *)__nw_create_backtrace_string();
      uint64_t v43 = __nwlog_obj();
      os_log_type_t v44 = type;
      BOOL v76 = os_log_type_enabled(v43, type);
      if (v75)
      {
        if (v76)
        {
          uint64_t v77 = *((void *)handle + 4);
          __int16 v78 = "invalid";
          if (v77)
          {
            os_log_type_t v79 = *(const char **)(v77 + 16);
            if (v79) {
              __int16 v78 = v79;
            }
          }
          *(_DWORD *)buf = 136446722;
          int v115 = "nw_http3_reset";
          __int16 v116 = 2082;
          char v117 = (char *)v78;
          __int16 v118 = 2082;
          unint64_t v119 = v75;
          _os_log_impl(&dword_1830D4000, v43, v44, "%{public}s protocol %{public}s has invalid remove_input_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v75);
        goto LABEL_136;
      }
      if (v76)
      {
        uint64_t v97 = *((void *)handle + 4);
        uint64_t v98 = "invalid";
        if (v97)
        {
          __int16 v99 = *(const char **)(v97 + 16);
          if (v99) {
            uint64_t v98 = v99;
          }
        }
        *(_DWORD *)buf = 136446466;
        int v115 = "nw_http3_reset";
        __int16 v116 = 2082;
        char v117 = (char *)v98;
        BOOL v48 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, no backtrace";
LABEL_135:
        _os_log_impl(&dword_1830D4000, v43, v44, v48, buf, 0x16u);
      }
    }
LABEL_136:
    if (v42) {
      free(v42);
    }
LABEL_12:
    *((void *)handle + 8) = 0;
    handle[130] = 0;
    lsqpack_enc_cleanup((uint64_t)(handle + 256));
    *((_OWORD *)handle + 20) = 0u;
    *((_OWORD *)handle + 21) = 0u;
    *((_OWORD *)handle + 22) = 0u;
    *((_OWORD *)handle + 23) = 0u;
    *((_OWORD *)handle + 29) = 0u;
    *((_OWORD *)handle + 30) = 0u;
    *((_OWORD *)handle + 27) = 0u;
    *((_OWORD *)handle + 28) = 0u;
    *((_OWORD *)handle + 25) = 0u;
    *((_OWORD *)handle + 26) = 0u;
    *((_OWORD *)handle + 24) = 0u;
    *((_OWORD *)handle + 18) = 0u;
    *((_OWORD *)handle + 19) = 0u;
    *((_OWORD *)handle + 16) = 0u;
    *((_OWORD *)handle + 17) = 0u;
    *((void *)handle + 40) = handle + 312;
    *((void *)handle + 43) = handle + 336;
    *((void *)handle + 45) = handle + 352;
    *((void *)handle + 47) = handle + 368;
    lsqpack_dec_cleanup((uint64_t)(handle + 496));
    *((_OWORD *)handle + 51) = 0u;
    *((_OWORD *)handle + 52) = 0u;
    *((_OWORD *)handle + 49) = 0u;
    *((_OWORD *)handle + 50) = 0u;
    *((_OWORD *)handle + 47) = 0u;
    *((_OWORD *)handle + 48) = 0u;
    *((_OWORD *)handle + 45) = 0u;
    *((_OWORD *)handle + 46) = 0u;
    *((_OWORD *)handle + 43) = 0u;
    *((_OWORD *)handle + 44) = 0u;
    *((_OWORD *)handle + 41) = 0u;
    *((_OWORD *)handle + 42) = 0u;
    *((_OWORD *)handle + 39) = 0u;
    *((_OWORD *)handle + 40) = 0u;
    *((_OWORD *)handle + 37) = 0u;
    *((_OWORD *)handle + 38) = 0u;
    *((_OWORD *)handle + 35) = 0u;
    *((_OWORD *)handle + 36) = 0u;
    *((_OWORD *)handle + 33) = 0u;
    *((_OWORD *)handle + 34) = 0u;
    *((_OWORD *)handle + 31) = 0u;
    *((_OWORD *)handle + 32) = 0u;
    *(void *)(handle + 500) = 0x3FFF00003FFFLL;
    *((int32x2_t *)handle + 66) = vdup_n_s32(0x3FDu);
    *((void *)handle + 64) = 0x1FF00000064;
    *((void *)handle + 67) = &nw_qpack_dec_callbacks;
    *((void *)handle + 73) = handle + 576;
    *((void *)handle + 75) = handle + 592;
    *((void *)handle + 77) = handle + 608;
    *((void *)handle + 79) = handle + 624;
    *((void *)handle + 81) = handle + 640;
    *((void *)handle + 83) = handle + 656;
    *((void *)handle + 85) = handle + 672;
    *((void *)handle + 87) = handle + 688;
    *((void *)handle + 89) = handle + 704;
    uint64_t v11 = *((void *)handle + 114);
    if (v11)
    {
      os_log_type_t v12 = (void *)(v11 + 560);
      uint64_t v13 = *(void *)(v11 + 560);
      if (v13)
      {
        do
        {
          uint64_t v14 = v13;
          char v15 = (void *)(v13 + 560);
          *(void *)(v13 + 568) = *(void *)(v11 + 568);
          **(void **)(v11 + 568) = v13;
          *os_log_type_t v12 = 0;
          v12[1] = 0;
          uint64_t v13 = *(void *)(v13 + 560);
          os_log_type_t v12 = v15;
          uint64_t v11 = v14;
        }
        while (v13);
      }
      else
      {
        uint64_t v14 = *((void *)handle + 114);
        char v15 = (void *)(v11 + 560);
      }
      id v16 = *(void **)(v14 + 568);
      *((void *)handle + 115) = v16;
      *id v16 = 0;
      *char v15 = 0;
      v15[1] = 0;
    }
    uint64_t v17 = *((void *)handle + 116);
    if (v17)
    {
      char v18 = (void *)(v17 + 576);
      uint64_t v19 = *(void *)(v17 + 576);
      if (v19)
      {
        do
        {
          uint64_t v20 = v19;
          id v21 = (void *)(v19 + 576);
          *(void *)(v19 + 584) = *(void *)(v17 + 584);
          **(void **)(v17 + 584) = v19;
          void *v18 = 0;
          v18[1] = 0;
          uint64_t v19 = *(void *)(v19 + 576);
          char v18 = v21;
          uint64_t v17 = v20;
        }
        while (v19);
      }
      else
      {
        uint64_t v20 = *((void *)handle + 116);
        id v21 = (void *)(v17 + 576);
      }
      __int16 v22 = *(void **)(v20 + 584);
      *((void *)handle + 117) = v22;
      *__int16 v22 = 0;
      *id v21 = 0;
      v21[1] = 0;
    }
    uint64_t v23 = *((void *)handle + 118);
    if (v23)
    {
      uint64_t v24 = (void *)(v23 + 592);
      uint64_t v25 = *(void *)(v23 + 592);
      if (v25)
      {
        do
        {
          uint64_t v26 = v25;
          __int16 v27 = (void *)(v25 + 592);
          *(void *)(v25 + 600) = *(void *)(v23 + 600);
          **(void **)(v23 + 600) = v25;
          void *v24 = 0;
          v24[1] = 0;
          uint64_t v25 = *(void *)(v25 + 592);
          uint64_t v24 = v27;
          uint64_t v23 = v26;
        }
        while (v25);
      }
      else
      {
        uint64_t v26 = *((void *)handle + 118);
        __int16 v27 = (void *)(v23 + 592);
      }
      uint64_t v28 = *(void **)(v26 + 600);
      *((void *)handle + 119) = v28;
      *uint64_t v28 = 0;
      void *v27 = 0;
      v27[1] = 0;
    }
    *((_OWORD *)handle + 62) = 0u;
    *((void *)handle + 126) = -1;
    uint64_t v29 = *((void *)handle + 132);
    if (!v29)
    {
LABEL_36:
      uint64_t v33 = *((void *)handle + 134);
      if (!v33)
      {
LABEL_42:
        int v37 = *((void *)handle + 150);
        if (v37)
        {
          dispatch_release(v37);
          *((void *)handle + 150) = 0;
        }
        *((_DWORD *)handle + 318) = 0;
        *((void *)handle + 122) = 0;
        *((_WORD *)handle + 642) = 0;
        *((void *)handle + 128) = 0;
        int v38 = (*(unsigned __int16 *)(handle + 1373) | (handle[1375] << 16)) & 0xCF966F;
        *v4 &= 0x966Fu;
        handle[1375] = BYTE2(v38);
        nw_protocol_set_output_handler((uint64_t)a1, (uint64_t)output_handler);
        nw_http3_setup_connection_if_needed((uint64_t)handle);
        return;
      }
      uint64_t v34 = *(void *)(v33 + 32);
      if (v34)
      {
        uint64_t v35 = *(void *)(v34 + 24);
        if (v35)
        {
          uint64_t v36 = *(void (**)(uint64_t, uint64_t))(v35 + 8);
          if (v36)
          {
            v36(v34, v33);
LABEL_41:
            nw_protocol_http3_uni_stream_destroy(*((void *)handle + 134));
            *((void *)handle + 134) = 0;
            goto LABEL_42;
          }
        }
      }
      __nwlog_obj();
      uint64_t v65 = *(void *)(*((void *)handle + 134) + 32);
      uint64_t v66 = "invalid";
      if (v65)
      {
        uint64_t v67 = *(const char **)(v65 + 16);
        if (v67) {
          uint64_t v66 = v67;
        }
      }
      *(_DWORD *)buf = 136446466;
      int v115 = "nw_http3_reset";
      __int16 v116 = 2082;
      char v117 = (char *)v66;
      BOOL v68 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v112 = 0;
      if (__nwlog_fault(v68, &type, &v112))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          uint64_t v69 = __nwlog_obj();
          os_log_type_t v70 = type;
          if (!os_log_type_enabled(v69, type)) {
            goto LABEL_169;
          }
          uint64_t v71 = *(void *)(*((void *)handle + 134) + 32);
          __int16 v72 = "invalid";
          if (v71)
          {
            BOOL v73 = *(const char **)(v71 + 16);
            if (v73) {
              __int16 v72 = v73;
            }
          }
          *(_DWORD *)buf = 136446466;
          int v115 = "nw_http3_reset";
          __int16 v116 = 2082;
          char v117 = (char *)v72;
          __int16 v74 = "%{public}s protocol %{public}s has invalid remove_input_handler callback";
          goto LABEL_168;
        }
        if (!v112)
        {
          uint64_t v69 = __nwlog_obj();
          os_log_type_t v70 = type;
          if (!os_log_type_enabled(v69, type)) {
            goto LABEL_169;
          }
          uint64_t v103 = *(void *)(*((void *)handle + 134) + 32);
          uint64_t v104 = "invalid";
          if (v103)
          {
            __int16 v105 = *(const char **)(v103 + 16);
            if (v105) {
              uint64_t v104 = v105;
            }
          }
          *(_DWORD *)buf = 136446466;
          int v115 = "nw_http3_reset";
          __int16 v116 = 2082;
          char v117 = (char *)v104;
          __int16 v74 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, backtrace limit exceeded";
          goto LABEL_168;
        }
        int v89 = (char *)__nw_create_backtrace_string();
        uint64_t v69 = __nwlog_obj();
        os_log_type_t v70 = type;
        BOOL v90 = os_log_type_enabled(v69, type);
        if (v89)
        {
          if (v90)
          {
            uint64_t v91 = *(void *)(*((void *)handle + 134) + 32);
            char v92 = "invalid";
            if (v91)
            {
              uint64_t v93 = *(const char **)(v91 + 16);
              if (v93) {
                char v92 = v93;
              }
            }
            *(_DWORD *)buf = 136446722;
            int v115 = "nw_http3_reset";
            __int16 v116 = 2082;
            char v117 = (char *)v92;
            __int16 v118 = 2082;
            unint64_t v119 = v89;
            _os_log_impl(&dword_1830D4000, v69, v70, "%{public}s protocol %{public}s has invalid remove_input_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(v89);
          goto LABEL_169;
        }
        if (v90)
        {
          uint64_t v109 = *(void *)(*((void *)handle + 134) + 32);
          BOOL v110 = "invalid";
          if (v109)
          {
            BOOL v111 = *(const char **)(v109 + 16);
            if (v111) {
              BOOL v110 = v111;
            }
          }
          *(_DWORD *)buf = 136446466;
          int v115 = "nw_http3_reset";
          __int16 v116 = 2082;
          char v117 = (char *)v110;
          __int16 v74 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, no backtrace";
LABEL_168:
          _os_log_impl(&dword_1830D4000, v69, v70, v74, buf, 0x16u);
        }
      }
LABEL_169:
      if (v68) {
        free(v68);
      }
      goto LABEL_41;
    }
    uint64_t v30 = *(void *)(v29 + 32);
    if (v30)
    {
      uint64_t v31 = *(void *)(v30 + 24);
      if (v31)
      {
        int v32 = *(void (**)(uint64_t, uint64_t))(v31 + 8);
        if (v32)
        {
          v32(v30, v29);
LABEL_35:
          nw_protocol_http3_uni_stream_destroy(*((void *)handle + 132));
          *((void *)handle + 132) = 0;
          goto LABEL_36;
        }
      }
    }
    __nwlog_obj();
    uint64_t v55 = *(void *)(*((void *)handle + 132) + 32);
    id v56 = "invalid";
    if (v55)
    {
      id v57 = *(const char **)(v55 + 16);
      if (v57) {
        id v56 = v57;
      }
    }
    *(_DWORD *)buf = 136446466;
    int v115 = "nw_http3_reset";
    __int16 v116 = 2082;
    char v117 = (char *)v56;
    id v58 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v112 = 0;
    if (__nwlog_fault(v58, &type, &v112))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v59 = __nwlog_obj();
        os_log_type_t v60 = type;
        if (!os_log_type_enabled(v59, type)) {
          goto LABEL_161;
        }
        uint64_t v61 = *(void *)(*((void *)handle + 132) + 32);
        uint64_t v62 = "invalid";
        if (v61)
        {
          uint64_t v63 = *(const char **)(v61 + 16);
          if (v63) {
            uint64_t v62 = v63;
          }
        }
        *(_DWORD *)buf = 136446466;
        int v115 = "nw_http3_reset";
        __int16 v116 = 2082;
        char v117 = (char *)v62;
        uint64_t v64 = "%{public}s protocol %{public}s has invalid remove_input_handler callback";
        goto LABEL_160;
      }
      if (!v112)
      {
        id v59 = __nwlog_obj();
        os_log_type_t v60 = type;
        if (!os_log_type_enabled(v59, type)) {
          goto LABEL_161;
        }
        uint64_t v100 = *(void *)(*((void *)handle + 132) + 32);
        int v101 = "invalid";
        if (v100)
        {
          __int16 v102 = *(const char **)(v100 + 16);
          if (v102) {
            int v101 = v102;
          }
        }
        *(_DWORD *)buf = 136446466;
        int v115 = "nw_http3_reset";
        __int16 v116 = 2082;
        char v117 = (char *)v101;
        uint64_t v64 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, backtrace limit exceeded";
        goto LABEL_160;
      }
      uint64_t v84 = (char *)__nw_create_backtrace_string();
      id v59 = __nwlog_obj();
      os_log_type_t v60 = type;
      BOOL v85 = os_log_type_enabled(v59, type);
      if (v84)
      {
        if (v85)
        {
          uint64_t v86 = *(void *)(*((void *)handle + 132) + 32);
          BOOL v87 = "invalid";
          if (v86)
          {
            char v88 = *(const char **)(v86 + 16);
            if (v88) {
              BOOL v87 = v88;
            }
          }
          *(_DWORD *)buf = 136446722;
          int v115 = "nw_http3_reset";
          __int16 v116 = 2082;
          char v117 = (char *)v87;
          __int16 v118 = 2082;
          unint64_t v119 = v84;
          _os_log_impl(&dword_1830D4000, v59, v60, "%{public}s protocol %{public}s has invalid remove_input_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v84);
        goto LABEL_161;
      }
      if (v85)
      {
        uint64_t v106 = *(void *)(*((void *)handle + 132) + 32);
        __int16 v107 = "invalid";
        if (v106)
        {
          int v108 = *(const char **)(v106 + 16);
          if (v108) {
            __int16 v107 = v108;
          }
        }
        *(_DWORD *)buf = 136446466;
        int v115 = "nw_http3_reset";
        __int16 v116 = 2082;
        char v117 = (char *)v107;
        uint64_t v64 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, no backtrace";
LABEL_160:
        _os_log_impl(&dword_1830D4000, v59, v60, v64, buf, 0x16u);
      }
    }
LABEL_161:
    if (v58) {
      free(v58);
    }
    goto LABEL_35;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v115 = "nw_protocol_http3_disconnected";
  int v49 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v112 = 0;
  if (!__nwlog_fault(v49, &type, &v112)) {
    goto LABEL_153;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    BOOL v50 = __nwlog_obj();
    os_log_type_t v51 = type;
    if (!os_log_type_enabled(v50, type)) {
      goto LABEL_153;
    }
    *(_DWORD *)buf = 136446210;
    int v115 = "nw_protocol_http3_disconnected";
    BOOL v52 = "%{public}s called with null http3";
    goto LABEL_152;
  }
  if (!v112)
  {
    BOOL v50 = __nwlog_obj();
    os_log_type_t v51 = type;
    if (!os_log_type_enabled(v50, type)) {
      goto LABEL_153;
    }
    *(_DWORD *)buf = 136446210;
    int v115 = "nw_protocol_http3_disconnected";
    BOOL v52 = "%{public}s called with null http3, backtrace limit exceeded";
    goto LABEL_152;
  }
  int v82 = (char *)__nw_create_backtrace_string();
  BOOL v50 = __nwlog_obj();
  os_log_type_t v51 = type;
  BOOL v83 = os_log_type_enabled(v50, type);
  if (!v82)
  {
    if (!v83) {
      goto LABEL_153;
    }
    *(_DWORD *)buf = 136446210;
    int v115 = "nw_protocol_http3_disconnected";
    BOOL v52 = "%{public}s called with null http3, no backtrace";
    goto LABEL_152;
  }
  if (v83)
  {
    *(_DWORD *)buf = 136446466;
    int v115 = "nw_protocol_http3_disconnected";
    __int16 v116 = 2082;
    char v117 = v82;
    _os_log_impl(&dword_1830D4000, v50, v51, "%{public}s called with null http3, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v82);
  if (v49) {
    goto LABEL_154;
  }
}

void nw_protocol_http3_disconnect(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v23 = "nw_protocol_http3_disconnect";
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (!__nwlog_fault(v4, &type, &v20)) {
      goto LABEL_19;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_19;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v23 = "nw_protocol_http3_disconnect";
      int v7 = "%{public}s called with null protocol";
      goto LABEL_61;
    }
    if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v16 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (!v16) {
          goto LABEL_47;
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v23 = "nw_protocol_http3_disconnect";
        __int16 v24 = 2082;
        uint64_t v25 = backtrace_string;
        uint64_t v17 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
        goto LABEL_46;
      }
      if (!v16) {
        goto LABEL_19;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v23 = "nw_protocol_http3_disconnect";
      int v7 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      uint64_t v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_19;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v23 = "nw_protocol_http3_disconnect";
      int v7 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_61:
    BOOL v10 = v13;
    os_log_type_t v11 = v14;
    uint32_t v12 = 12;
    goto LABEL_18;
  }
  uint64_t handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v23 = "nw_protocol_http3_disconnect";
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (!__nwlog_fault(v4, &type, &v20)) {
      goto LABEL_19;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_19;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v23 = "nw_protocol_http3_disconnect";
      int v7 = "%{public}s called with null http3";
      goto LABEL_61;
    }
    if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v18 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (!v18) {
          goto LABEL_47;
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v23 = "nw_protocol_http3_disconnect";
        __int16 v24 = 2082;
        uint64_t v25 = backtrace_string;
        uint64_t v17 = "%{public}s called with null http3, dumping backtrace:%{public}s";
        goto LABEL_46;
      }
      if (!v18) {
        goto LABEL_19;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v23 = "nw_protocol_http3_disconnect";
      int v7 = "%{public}s called with null http3, no backtrace";
    }
    else
    {
      uint64_t v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_19;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v23 = "nw_protocol_http3_disconnect";
      int v7 = "%{public}s called with null http3, backtrace limit exceeded";
    }
    goto LABEL_61;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  if (a2)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v23 = "nw_protocol_http3_disconnect";
    __int16 v24 = 2048;
    uint64_t v25 = handle;
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (!__nwlog_fault(v4, &type, &v20)) {
      goto LABEL_19;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v5 = gLogObj;
      os_log_type_t v6 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_19;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v23 = "nw_protocol_http3_disconnect";
      __int16 v24 = 2048;
      uint64_t v25 = handle;
      int v7 = "%{public}s http3 %p called";
LABEL_17:
      BOOL v10 = v5;
      os_log_type_t v11 = v6;
      uint32_t v12 = 22;
LABEL_18:
      _os_log_impl(&dword_1830D4000, v10, v11, v7, buf, v12);
      goto LABEL_19;
    }
    if (!v20)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v5 = gLogObj;
      os_log_type_t v6 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_19;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v23 = "nw_protocol_http3_disconnect";
      __int16 v24 = 2048;
      uint64_t v25 = handle;
      int v7 = "%{public}s http3 %p called, backtrace limit exceeded";
      goto LABEL_17;
    }
    uint64_t v8 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v5 = gLogObj;
    os_log_type_t v6 = type;
    BOOL v9 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v8)
    {
      if (!v9) {
        goto LABEL_19;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v23 = "nw_protocol_http3_disconnect";
      __int16 v24 = 2048;
      uint64_t v25 = handle;
      int v7 = "%{public}s http3 %p called, no backtrace";
      goto LABEL_17;
    }
    if (v9)
    {
      *(_DWORD *)buf = 136446722;
      uint64_t v23 = "nw_protocol_http3_disconnect";
      __int16 v24 = 2048;
      uint64_t v25 = handle;
      __int16 v26 = 2082;
      __int16 v27 = v8;
      _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s http3 %p called, dumping backtrace:%{public}s", buf, 0x20u);
    }
    free(v8);
LABEL_19:
    if (!v4) {
      return;
    }
    goto LABEL_20;
  }
  *(_DWORD *)buf = 136446210;
  uint64_t v23 = "nw_protocol_http3_disconnect";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (!__nwlog_fault(v4, &type, &v20)) {
    goto LABEL_19;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v13 = __nwlog_obj();
    os_log_type_t v14 = type;
    if (!os_log_type_enabled(v13, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v23 = "nw_protocol_http3_disconnect";
    int v7 = "%{public}s called with null other_protocol";
    goto LABEL_61;
  }
  if (!v20)
  {
    uint64_t v13 = __nwlog_obj();
    os_log_type_t v14 = type;
    if (!os_log_type_enabled(v13, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v23 = "nw_protocol_http3_disconnect";
    int v7 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    goto LABEL_61;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  uint64_t v13 = __nwlog_obj();
  os_log_type_t v14 = type;
  BOOL v19 = os_log_type_enabled(v13, type);
  if (!backtrace_string)
  {
    if (!v19) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v23 = "nw_protocol_http3_disconnect";
    int v7 = "%{public}s called with null other_protocol, no backtrace";
    goto LABEL_61;
  }
  if (!v19) {
    goto LABEL_47;
  }
  *(_DWORD *)buf = 136446466;
  uint64_t v23 = "nw_protocol_http3_disconnect";
  __int16 v24 = 2082;
  uint64_t v25 = backtrace_string;
  uint64_t v17 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
LABEL_46:
  _os_log_impl(&dword_1830D4000, v13, v14, v17, buf, 0x16u);
LABEL_47:
  free(backtrace_string);
  if (v4) {
LABEL_20:
  }
    free(v4);
}

void nw_protocol_http3_connected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v76 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v65 = "nw_protocol_http3_connected";
    __int16 v24 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(buffer_ptr) = 16;
    LOBYTE(size_ptr) = 0;
    if (!__nwlog_fault(v24, &buffer_ptr, &size_ptr)) {
      goto LABEL_50;
    }
    if (buffer_ptr == 17)
    {
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = buffer_ptr;
      if (!os_log_type_enabled(v25, (os_log_type_t)buffer_ptr)) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v65 = "nw_protocol_http3_connected";
      __int16 v27 = "%{public}s called with null protocol";
    }
    else
    {
      if ((_BYTE)size_ptr)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v25 = __nwlog_obj();
        os_log_type_t v26 = buffer_ptr;
        BOOL v48 = os_log_type_enabled(v25, (os_log_type_t)buffer_ptr);
        if (backtrace_string)
        {
          if (v48)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v65 = "nw_protocol_http3_connected";
            __int16 v66 = 2082;
            uint64_t v67 = (nw_protocol *)backtrace_string;
            _os_log_impl(&dword_1830D4000, v25, v26, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
        }
        else if (v48)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v65 = "nw_protocol_http3_connected";
          __int16 v27 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_48;
        }
        goto LABEL_50;
      }
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = buffer_ptr;
      if (!os_log_type_enabled(v25, (os_log_type_t)buffer_ptr)) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v65 = "nw_protocol_http3_connected";
      __int16 v27 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_48;
  }
  uint64_t handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v65 = "nw_protocol_http3_connected";
    __int16 v24 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(buffer_ptr) = 16;
    LOBYTE(size_ptr) = 0;
    if (!__nwlog_fault(v24, &buffer_ptr, &size_ptr)) {
      goto LABEL_50;
    }
    if (buffer_ptr == 17)
    {
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = buffer_ptr;
      if (!os_log_type_enabled(v25, (os_log_type_t)buffer_ptr)) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v65 = "nw_protocol_http3_connected";
      __int16 v27 = "%{public}s called with null http3";
    }
    else
    {
      if ((_BYTE)size_ptr)
      {
        int v49 = (char *)__nw_create_backtrace_string();
        uint64_t v25 = __nwlog_obj();
        os_log_type_t v26 = buffer_ptr;
        BOOL v50 = os_log_type_enabled(v25, (os_log_type_t)buffer_ptr);
        if (!v49)
        {
          if (v50)
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v65 = "nw_protocol_http3_connected";
            __int16 v27 = "%{public}s called with null http3, no backtrace";
            goto LABEL_48;
          }
          goto LABEL_50;
        }
        if (!v50) {
          goto LABEL_86;
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v65 = "nw_protocol_http3_connected";
        __int16 v66 = 2082;
        uint64_t v67 = (nw_protocol *)v49;
        os_log_type_t v51 = "%{public}s called with null http3, dumping backtrace:%{public}s";
        goto LABEL_85;
      }
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = buffer_ptr;
      if (!os_log_type_enabled(v25, (os_log_type_t)buffer_ptr)) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v65 = "nw_protocol_http3_connected";
      __int16 v27 = "%{public}s called with null http3, backtrace limit exceeded";
    }
    goto LABEL_48;
  }
  int v5 = handle + 1373;
  if (((*(unsigned __int16 *)(handle + 1373) | (handle[1375] << 16)) & 0x400000) == 0)
  {
    if (gLogDatapath)
    {
      int v40 = __nwlog_obj();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
      {
        int v41 = *((_DWORD *)handle + 320);
        *(_DWORD *)buf = 136446978;
        uint64_t v65 = "nw_protocol_http3_connected";
        __int16 v66 = 2082;
        uint64_t v67 = (nw_protocol *)(handle + 1289);
        __int16 v68 = 2080;
        uint64_t v69 = " ";
        __int16 v70 = 1024;
        int v71 = v41;
        _os_log_impl(&dword_1830D4000, v40, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> Got a connected event from the lower layer", buf, 0x26u);
      }
    }
  }
  uint64_t v6 = *((void *)handle + 110);
  if (v6)
  {
    int v7 = 0;
    do
    {
      ++v7;
      uint64_t v6 = *(void *)(v6 + 544);
    }
    while (v6);
  }
  else
  {
    int v7 = 0;
  }
  if ((((unsigned __int16)*v5 | (handle[1375] << 16)) & 0x400000) == 0)
  {
    if (gLogDatapath)
    {
      int v42 = __nwlog_obj();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
      {
        int v43 = *((_DWORD *)handle + 320);
        *(_DWORD *)buf = 136447234;
        uint64_t v65 = "nw_protocol_http3_connected";
        __int16 v66 = 2082;
        uint64_t v67 = (nw_protocol *)(handle + 1289);
        __int16 v68 = 2080;
        uint64_t v69 = " ";
        __int16 v70 = 1024;
        int v71 = v43;
        __int16 v72 = 1024;
        LODWORD(v73) = v7;
        _os_log_impl(&dword_1830D4000, v42, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> http3 has %u streams", buf, 0x2Cu);
      }
    }
  }
  int v8 = *(unsigned __int16 *)(handle + 1373) | (handle[1375] << 16);
  if (a1->output_handler != a2)
  {
    if ((v8 & 0x400000) == 0 && gLogDatapath)
    {
      BOOL v9 = __nwlog_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        int v10 = *((_DWORD *)handle + 320);
        identifier = a2->identifier;
        *(_DWORD *)buf = 136447490;
        uint64_t v65 = "nw_protocol_http3_connected";
        __int16 v66 = 2082;
        uint64_t v67 = (nw_protocol *)(handle + 1289);
        __int16 v68 = 2080;
        uint64_t v69 = " ";
        __int16 v70 = 1024;
        int v71 = v10;
        __int16 v72 = 2048;
        BOOL v73 = a2;
        __int16 v74 = 2080;
        BOOL v75 = identifier;
        _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> connected protocol %p (%s) is not our output_handler, ignoring", buf, 0x3Au);
      }
    }
    return;
  }
  handle[1375] = BYTE2(v8);
  _WORD *v5 = v8 | 0x10;
  output_handler = a1->output_handler;
  if (!output_handler
    || (callbacks = output_handler->callbacks) == 0
    || (waiting_for_output = (unsigned int (*)(void))callbacks->waiting_for_output) == 0)
  {
    __nwlog_obj();
    uint64_t v34 = a1->output_handler;
    *(_DWORD *)buf = 136446466;
    uint64_t v65 = "nw_protocol_http3_connected";
    __int16 v66 = 2048;
    uint64_t v67 = v34;
    uint64_t v35 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(buffer_ptr) = 16;
    LOBYTE(size_ptr) = 0;
    if (!__nwlog_fault(v35, &buffer_ptr, &size_ptr)) {
      goto LABEL_109;
    }
    if (buffer_ptr == 17)
    {
      uint64_t v36 = __nwlog_obj();
      os_log_type_t v37 = buffer_ptr;
      if (!os_log_type_enabled(v36, (os_log_type_t)buffer_ptr)) {
        goto LABEL_109;
      }
      int v38 = a1->output_handler;
      *(_DWORD *)buf = 136446466;
      uint64_t v65 = "nw_protocol_http3_connected";
      __int16 v66 = 2048;
      uint64_t v67 = v38;
      uint64_t v39 = "%{public}s Output handler (%p)'s waiting_for_output callback is not properly set";
    }
    else if ((_BYTE)size_ptr)
    {
      os_log_type_t v44 = (char *)__nw_create_backtrace_string();
      uint64_t v36 = __nwlog_obj();
      os_log_type_t v37 = buffer_ptr;
      BOOL v45 = os_log_type_enabled(v36, (os_log_type_t)buffer_ptr);
      if (v44)
      {
        if (v45)
        {
          BOOL v46 = a1->output_handler;
          *(_DWORD *)buf = 136446722;
          uint64_t v65 = "nw_protocol_http3_connected";
          __int16 v66 = 2048;
          uint64_t v67 = v46;
          __int16 v68 = 2082;
          uint64_t v69 = v44;
          _os_log_impl(&dword_1830D4000, v36, v37, "%{public}s Output handler (%p)'s waiting_for_output callback is not properly set, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v44);
LABEL_109:
        if (v35) {
          free(v35);
        }
        if ((*v5 & 0x100) != 0) {
          goto LABEL_24;
        }
        goto LABEL_25;
      }
      if (!v45) {
        goto LABEL_109;
      }
      id v57 = a1->output_handler;
      *(_DWORD *)buf = 136446466;
      uint64_t v65 = "nw_protocol_http3_connected";
      __int16 v66 = 2048;
      uint64_t v67 = v57;
      uint64_t v39 = "%{public}s Output handler (%p)'s waiting_for_output callback is not properly set, no backtrace";
    }
    else
    {
      uint64_t v36 = __nwlog_obj();
      os_log_type_t v37 = buffer_ptr;
      if (!os_log_type_enabled(v36, (os_log_type_t)buffer_ptr)) {
        goto LABEL_109;
      }
      BOOL v52 = a1->output_handler;
      *(_DWORD *)buf = 136446466;
      uint64_t v65 = "nw_protocol_http3_connected";
      __int16 v66 = 2048;
      uint64_t v67 = v52;
      uint64_t v39 = "%{public}s Output handler (%p)'s waiting_for_output callback is not properly set, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v36, v37, v39, buf, 0x16u);
    goto LABEL_109;
  }
  if (waiting_for_output()) {
    __int16 v15 = 256;
  }
  else {
    __int16 v15 = 0;
  }
  __int16 v16 = *(_WORD *)(handle + 1373) & 0xFEFF | v15;
  _WORD *v5 = v16;
  if ((v16 & 0x100) != 0) {
LABEL_24:
  }
    nw_http3_signal_output_pending((uint64_t)handle, 1);
LABEL_25:
  nw_http3_control_stream_process_output((uint64_t)handle);
  int v17 = (unsigned __int16)*v5;
  if ((v17 & 0x100) == 0)
  {
    if (((v17 | (handle[1375] << 16)) & 0x400000) == 0)
    {
      if (gLogDatapath)
      {
        int v53 = __nwlog_obj();
        if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG))
        {
          int v54 = *((_DWORD *)handle + 320);
          *(_DWORD *)buf = 136446978;
          uint64_t v65 = "nw_protocol_http3_connected";
          __int16 v66 = 2082;
          uint64_t v67 = (nw_protocol *)(handle + 1289);
          __int16 v68 = 2080;
          uint64_t v69 = " ";
          __int16 v70 = 1024;
          int v71 = v54;
          _os_log_impl(&dword_1830D4000, v53, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> http3 connection is connected", buf, 0x26u);
        }
      }
    }
    if ((((unsigned __int16)*v5 | (handle[1375] << 16)) & 0x400000) == 0)
    {
      if (gLogDatapath)
      {
        uint64_t v55 = __nwlog_obj();
        if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
        {
          int v56 = *((_DWORD *)handle + 320);
          *(_DWORD *)buf = 136446978;
          uint64_t v65 = "nw_http3_add_edges";
          __int16 v66 = 2082;
          uint64_t v67 = (nw_protocol *)(handle + 1289);
          __int16 v68 = 2080;
          uint64_t v69 = " ";
          __int16 v70 = 1024;
          int v71 = v56;
          _os_log_impl(&dword_1830D4000, v55, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
        }
      }
    }
    BOOL v18 = (void *)*((void *)handle + 137);
    if (v18)
    {
      BOOL v19 = v18;
      BOOL v20 = (v19[231] & 4) == 0;

      if (!v20)
      {
        nw_endpoint_add_edges_for_instance(*((void **)handle + 137), handle, 1);
        return;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      uint64_t v65 = "nw_http3_add_edges";
      __int16 v24 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(buffer_ptr) = 16;
      LOBYTE(size_ptr) = 0;
      if (!__nwlog_fault(v24, &buffer_ptr, &size_ptr)) {
        goto LABEL_50;
      }
      if (buffer_ptr == 17)
      {
        uint64_t v25 = __nwlog_obj();
        os_log_type_t v26 = buffer_ptr;
        if (os_log_type_enabled(v25, (os_log_type_t)buffer_ptr))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v65 = "nw_http3_add_edges";
          __int16 v27 = "%{public}s http3->remote_endpoint is not registered when connected";
          goto LABEL_48;
        }
LABEL_50:
        if (!v24) {
          return;
        }
        goto LABEL_51;
      }
      if (!(_BYTE)size_ptr)
      {
        uint64_t v25 = __nwlog_obj();
        os_log_type_t v26 = buffer_ptr;
        if (os_log_type_enabled(v25, (os_log_type_t)buffer_ptr))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v65 = "nw_http3_add_edges";
          __int16 v27 = "%{public}s http3->remote_endpoint is not registered when connected, backtrace limit exceeded";
          goto LABEL_48;
        }
        goto LABEL_50;
      }
      int v49 = (char *)__nw_create_backtrace_string();
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = buffer_ptr;
      BOOL v59 = os_log_type_enabled(v25, (os_log_type_t)buffer_ptr);
      if (!v49)
      {
        if (v59)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v65 = "nw_http3_add_edges";
          __int16 v27 = "%{public}s http3->remote_endpoint is not registered when connected, no backtrace";
          goto LABEL_48;
        }
        goto LABEL_50;
      }
      if (!v59) {
        goto LABEL_86;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v65 = "nw_http3_add_edges";
      __int16 v66 = 2082;
      uint64_t v67 = (nw_protocol *)v49;
      os_log_type_t v51 = "%{public}s http3->remote_endpoint is not registered when connected, dumping backtrace:%{public}s";
      goto LABEL_85;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v65 = "nw_http3_add_edges";
    __int16 v24 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(buffer_ptr) = 16;
    LOBYTE(size_ptr) = 0;
    if (!__nwlog_fault(v24, &buffer_ptr, &size_ptr)) {
      goto LABEL_50;
    }
    if (buffer_ptr != 17)
    {
      if (!(_BYTE)size_ptr)
      {
        uint64_t v25 = __nwlog_obj();
        os_log_type_t v26 = buffer_ptr;
        if (os_log_type_enabled(v25, (os_log_type_t)buffer_ptr))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v65 = "nw_http3_add_edges";
          __int16 v27 = "%{public}s http3->remote_endpoint is NULL when connected, backtrace limit exceeded";
          goto LABEL_48;
        }
        goto LABEL_50;
      }
      int v49 = (char *)__nw_create_backtrace_string();
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = buffer_ptr;
      BOOL v58 = os_log_type_enabled(v25, (os_log_type_t)buffer_ptr);
      if (!v49)
      {
        if (v58)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v65 = "nw_http3_add_edges";
          __int16 v27 = "%{public}s http3->remote_endpoint is NULL when connected, no backtrace";
          goto LABEL_48;
        }
        goto LABEL_50;
      }
      if (!v58) {
        goto LABEL_86;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v65 = "nw_http3_add_edges";
      __int16 v66 = 2082;
      uint64_t v67 = (nw_protocol *)v49;
      os_log_type_t v51 = "%{public}s http3->remote_endpoint is NULL when connected, dumping backtrace:%{public}s";
LABEL_85:
      _os_log_impl(&dword_1830D4000, v25, v26, v51, buf, 0x16u);
LABEL_86:
      free(v49);
      if (!v24) {
        return;
      }
      goto LABEL_51;
    }
    uint64_t v25 = __nwlog_obj();
    os_log_type_t v26 = buffer_ptr;
    if (!os_log_type_enabled(v25, (os_log_type_t)buffer_ptr)) {
      goto LABEL_50;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v65 = "nw_http3_add_edges";
    __int16 v27 = "%{public}s http3->remote_endpoint is NULL when connected";
LABEL_48:
    int v32 = v25;
    os_log_type_t v33 = v26;
LABEL_49:
    _os_log_impl(&dword_1830D4000, v32, v33, v27, buf, 0xCu);
    goto LABEL_50;
  }
  size_t size_ptr = 0;
  buffer_ptr = 0;
  id v21 = *((void *)handle + 144);
  if (v21)
  {
    __int16 v22 = dispatch_data_create_map(v21, (const void **)&buffer_ptr, &size_ptr);
    nw_http3_parse_settings((uint64_t)handle, buffer_ptr, (unsigned __int16)size_ptr, v23);
    if (v22) {
      dispatch_release(v22);
    }
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    uint64_t v65 = "nw_protocol_http3_connected";
    __int16 v24 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v60 = 0;
    if (!__nwlog_fault(v24, &type, &v60)) {
      goto LABEL_50;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v25 = gLogObj;
      os_log_type_t v26 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v65 = "nw_protocol_http3_connected";
      __int16 v27 = "%{public}s Could not find persisted SETTINGS";
      goto LABEL_48;
    }
    if (!v60)
    {
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (!os_log_type_enabled(v25, type)) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v65 = "nw_protocol_http3_connected";
      __int16 v27 = "%{public}s Could not find persisted SETTINGS, backtrace limit exceeded";
      goto LABEL_48;
    }
    uint64_t v28 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v29 = gLogObj;
    os_log_type_t v30 = type;
    BOOL v31 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v28)
    {
      if (v31)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v65 = "nw_protocol_http3_connected";
        __int16 v27 = "%{public}s Could not find persisted SETTINGS, no backtrace";
        int v32 = v29;
        os_log_type_t v33 = v30;
        goto LABEL_49;
      }
      goto LABEL_50;
    }
    if (v31)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v65 = "nw_protocol_http3_connected";
      __int16 v66 = 2082;
      uint64_t v67 = (nw_protocol *)v28;
      _os_log_impl(&dword_1830D4000, v29, v30, "%{public}s Could not find persisted SETTINGS, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v28);
    if (v24) {
LABEL_51:
    }
      free(v24);
  }
}

uint64_t nw_protocol_http3_connect(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __n128 v23 = "nw_protocol_http3_connect";
    os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (!__nwlog_fault(v11, &type, &v20)) {
      goto LABEL_61;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint32_t v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_61;
      }
      *(_DWORD *)buf = 136446210;
      __n128 v23 = "nw_protocol_http3_connect";
      os_log_type_t v14 = "%{public}s called with null protocol";
LABEL_60:
      _os_log_impl(&dword_1830D4000, v12, v13, v14, buf, 0xCu);
      goto LABEL_61;
    }
    if (!v20)
    {
      uint32_t v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        __n128 v23 = "nw_protocol_http3_connect";
        os_log_type_t v14 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_60;
      }
      goto LABEL_61;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint32_t v12 = __nwlog_obj();
    os_log_type_t v13 = type;
    BOOL v16 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        __n128 v23 = "nw_protocol_http3_connect";
        os_log_type_t v14 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_60;
      }
      goto LABEL_61;
    }
    if (!v16) {
      goto LABEL_47;
    }
    *(_DWORD *)buf = 136446466;
    __n128 v23 = "nw_protocol_http3_connect";
    __int16 v24 = 2082;
    uint64_t v25 = backtrace_string;
    int v17 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_46:
    _os_log_impl(&dword_1830D4000, v12, v13, v17, buf, 0x16u);
    goto LABEL_47;
  }
  uint64_t handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __n128 v23 = "nw_protocol_http3_connect";
    os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (!__nwlog_fault(v11, &type, &v20)) {
      goto LABEL_61;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint32_t v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_61;
      }
      *(_DWORD *)buf = 136446210;
      __n128 v23 = "nw_protocol_http3_connect";
      os_log_type_t v14 = "%{public}s called with null http3";
      goto LABEL_60;
    }
    if (!v20)
    {
      uint32_t v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        __n128 v23 = "nw_protocol_http3_connect";
        os_log_type_t v14 = "%{public}s called with null http3, backtrace limit exceeded";
        goto LABEL_60;
      }
      goto LABEL_61;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint32_t v12 = __nwlog_obj();
    os_log_type_t v13 = type;
    BOOL v18 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        __n128 v23 = "nw_protocol_http3_connect";
        os_log_type_t v14 = "%{public}s called with null http3, no backtrace";
        goto LABEL_60;
      }
      goto LABEL_61;
    }
    if (!v18) {
      goto LABEL_47;
    }
    *(_DWORD *)buf = 136446466;
    __n128 v23 = "nw_protocol_http3_connect";
    __int16 v24 = 2082;
    uint64_t v25 = backtrace_string;
    int v17 = "%{public}s called with null http3, dumping backtrace:%{public}s";
    goto LABEL_46;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  if (a2)
  {
    *(_DWORD *)buf = 136446466;
    __n128 v23 = "nw_protocol_http3_connect";
    __int16 v24 = 2048;
    uint64_t v25 = handle;
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (__nwlog_fault(v4, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v5 = gLogObj;
        os_log_type_t v6 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)buf = 136446466;
          __n128 v23 = "nw_protocol_http3_connect";
          __int16 v24 = 2048;
          uint64_t v25 = handle;
          int v7 = "%{public}s http3 %p called";
LABEL_17:
          _os_log_impl(&dword_1830D4000, v5, v6, v7, buf, 0x16u);
        }
      }
      else if (v20)
      {
        int v8 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v5 = gLogObj;
        os_log_type_t v6 = type;
        BOOL v9 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v8)
        {
          if (v9)
          {
            *(_DWORD *)buf = 136446722;
            __n128 v23 = "nw_protocol_http3_connect";
            __int16 v24 = 2048;
            uint64_t v25 = handle;
            __int16 v26 = 2082;
            __int16 v27 = v8;
            _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s http3 %p called, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(v8);
          goto LABEL_18;
        }
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          __n128 v23 = "nw_protocol_http3_connect";
          __int16 v24 = 2048;
          uint64_t v25 = handle;
          int v7 = "%{public}s http3 %p called, no backtrace";
          goto LABEL_17;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v5 = gLogObj;
        os_log_type_t v6 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)buf = 136446466;
          __n128 v23 = "nw_protocol_http3_connect";
          __int16 v24 = 2048;
          uint64_t v25 = handle;
          int v7 = "%{public}s http3 %p called, backtrace limit exceeded";
          goto LABEL_17;
        }
      }
    }
LABEL_18:
    if (v4) {
      free(v4);
    }
    return 1;
  }
  *(_DWORD *)buf = 136446210;
  __n128 v23 = "nw_protocol_http3_connect";
  os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (!__nwlog_fault(v11, &type, &v20)) {
    goto LABEL_61;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v20)
    {
      uint32_t v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        __n128 v23 = "nw_protocol_http3_connect";
        os_log_type_t v14 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_60;
      }
      goto LABEL_61;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint32_t v12 = __nwlog_obj();
    os_log_type_t v13 = type;
    BOOL v19 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        __n128 v23 = "nw_protocol_http3_connect";
        os_log_type_t v14 = "%{public}s called with null other_protocol, no backtrace";
        goto LABEL_60;
      }
      goto LABEL_61;
    }
    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      __n128 v23 = "nw_protocol_http3_connect";
      __int16 v24 = 2082;
      uint64_t v25 = backtrace_string;
      int v17 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_46;
    }
LABEL_47:
    free(backtrace_string);
    goto LABEL_61;
  }
  uint32_t v12 = __nwlog_obj();
  os_log_type_t v13 = type;
  if (os_log_type_enabled(v12, type))
  {
    *(_DWORD *)buf = 136446210;
    __n128 v23 = "nw_protocol_http3_connect";
    os_log_type_t v14 = "%{public}s called with null other_protocol";
    goto LABEL_60;
  }
LABEL_61:
  if (v11) {
    free(v11);
  }
  return 0;
}

BOOL nw_queue_target_dispatch_queue(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  if (v1)
  {
    if (nw_context_copy_implicit_context::onceToken != -1) {
      dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
    }
    id v2 = (id)nw_context_copy_implicit_context::implicit_context;
    BOOL v3 = nw_context_copy_workloop(v2);

    dispatch_set_target_queue(v1, (dispatch_queue_t)v3);
    goto LABEL_5;
  }
  int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_queue_target_dispatch_queue";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_queue_target_dispatch_queue";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null queue", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_queue_target_dispatch_queue";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_queue_target_dispatch_queue";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null queue, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_queue_target_dispatch_queue";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_22:
  if (v6) {
    free(v6);
  }
LABEL_5:

  return v1 != 0;
}

void sub_183B6EC44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_queue_register_dispatch_queue(void *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v2 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v19 = "nw_queue_register_dispatch_queue";
    BOOL v3 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (!__nwlog_fault(v3, &type, &v16)) {
      goto LABEL_19;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v4 = (id)gLogObj;
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_queue_register_dispatch_queue";
        _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s nw_queue_register_dispatch_queue is deprecated", buf, 0xCu);
      }
LABEL_18:

      goto LABEL_19;
    }
    if (!v16)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v4 = (id)gLogObj;
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_queue_register_dispatch_queue";
        _os_log_impl(&dword_1830D4000, v4, v9, "%{public}s nw_queue_register_dispatch_queue is deprecated, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_18;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = (id)gLogObj;
    os_log_type_t v7 = type;
    BOOL v8 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_queue_register_dispatch_queue";
        _os_log_impl(&dword_1830D4000, v4, v7, "%{public}s nw_queue_register_dispatch_queue is deprecated, no backtrace", buf, 0xCu);
      }
      goto LABEL_18;
    }
    if (v8)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v19 = "nw_queue_register_dispatch_queue";
      __int16 v20 = 2082;
      id v21 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v4, v7, "%{public}s nw_queue_register_dispatch_queue is deprecated, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_11:

    free(backtrace_string);
    if (!v3) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  BOOL v11 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v19 = "nw_queue_register_dispatch_queue";
  BOOL v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v3, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_queue_register_dispatch_queue";
        _os_log_impl(&dword_1830D4000, v4, v12, "%{public}s called with null queue", buf, 0xCu);
      }
      goto LABEL_18;
    }
    if (!v16)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_queue_register_dispatch_queue";
        _os_log_impl(&dword_1830D4000, v4, v15, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_18;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v4 = __nwlog_obj();
    os_log_type_t v13 = type;
    BOOL v14 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_queue_register_dispatch_queue";
        _os_log_impl(&dword_1830D4000, v4, v13, "%{public}s called with null queue, no backtrace", buf, 0xCu);
      }
      goto LABEL_18;
    }
    if (v14)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v19 = "nw_queue_register_dispatch_queue";
      __int16 v20 = 2082;
      id v21 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v4, v13, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_11;
  }
LABEL_19:
  if (v3) {
LABEL_20:
  }
    free(v3);
LABEL_21:

  return 0;
}

void nw_queue_async(void *a1)
{
  dispatch_block_t block = a1;
  if (nw_context_copy_implicit_context::onceToken != -1) {
    dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
  }
  id v1 = (id)nw_context_copy_implicit_context::implicit_context;
  BOOL v2 = nw_context_copy_workloop(v1);

  dispatch_async((dispatch_queue_t)v2, block);
}

void sub_183B6F1E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void nw_queue_async_current(void *a1)
{
  dispatch_block_t block = a1;
  BOOL v1 = nw_queue_copy_current_workloop();
  dispatch_async((dispatch_queue_t)v1, block);
}

BOOL nw_queue_create_source(int a1, int a2, unsigned int a3, void *a4, void *a5)
{
  id v9 = a4;
  id v10 = a5;
  if (nw_context_copy_implicit_context::onceToken != -1) {
    dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
  }
  id v11 = (id)nw_context_copy_implicit_context::implicit_context;
  BOOL source = nw_queue_context_create_source(v11, a1, a2, a3, v9, v10);

  return source;
}

void sub_183B6F300(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_queue_source_run_timer(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 16))
  {
    if (*(void *)(a1 + 40) == -1)
    {
      uint64_t v6 = *(void *)(a1 + 8);
      uint64_t v7 = *(void *)(a1 + 32);
      nw_context_reset_timer_block_with_time(v6, a1, v7);
    }
    else
    {
      BOOL v2 = _Block_copy(*(const void **)(a1 + 16));
      uint64_t v3 = *(void *)(a1 + 8);
      uint64_t v4 = *(void *)(a1 + 32);
      id v9 = v2;
      id v5 = v2;
      nw_context_reset_timer_block_with_time(v3, a1, v4);
    }
  }
  else if (gLogDatapath)
  {
    BOOL v8 = __nwlog_obj();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      id v11 = "nw_queue_source_run_timer";
      _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_DEBUG, "%{public}s Cancelled, not running timer", buf, 0xCu);
    }
  }
}

void sub_183B6F4BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL25nw_queue_source_run_timerP15nw_queue_source_block_invoke(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  uint64_t v2 = *(void *)(a1 + 40);
  int64_t v3 = *(void *)(v2 + 40);
  if (v3 == -1)
  {
    dispatch_time_t v4 = -1;
  }
  else
  {
    dispatch_time_t v4 = dispatch_time(0x8000000000000000, v3);
    uint64_t v2 = *(void *)(a1 + 40);
  }
  *(void *)(v2 + 32) = v4;

  return nw_queue_source_run_timer();
}

void __nw_queue_cancel_source_block_invoke(uint64_t a1)
{
  BOOL v1 = *(void **)(a1 + 32);
  if (v1) {
    free(v1);
  }
}

uint64_t nw_hash_table_create_no_lock(unsigned int a1, int a2, const void *(*a3)(const void *, unsigned int *), unsigned int (*a4)(const void *, unsigned int), BOOL (*a5)(const void *, const void *, unsigned int), void (*a6)(void *))
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t result = nw_hash_table_create_internal(a1, a2, a3, a4, a5, a6);
    if (result) {
      *(_DWORD *)(result + 48) &= ~2u;
    }
    return result;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_hash_table_create_no_lock";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v7, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_hash_table_create_no_lock";
        id v10 = "%{public}s called with null count";
LABEL_18:
        _os_log_impl(&dword_1830D4000, v8, v9, v10, buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          char v16 = "nw_hash_table_create_no_lock";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null count, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_19;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_hash_table_create_no_lock";
        id v10 = "%{public}s called with null count, no backtrace";
        goto LABEL_18;
      }
    }
    else
    {
      BOOL v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_hash_table_create_no_lock";
        id v10 = "%{public}s called with null count, backtrace limit exceeded";
        goto LABEL_18;
      }
    }
  }
LABEL_19:
  if (v7) {
    free(v7);
  }
  return 0;
}

BOOL nw_hash_table_create_with_lock(unsigned int a1, int a2, const void *(*a3)(const void *, unsigned int *), unsigned int (*a4)(const void *, unsigned int), BOOL (*a5)(const void *, const void *, unsigned int), void (*a6)(void *))
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    return nw_hash_table_create_internal(a1, a2, a3, a4, a5, a6);
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_hash_table_create_with_lock";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v7, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_hash_table_create_with_lock";
        id v10 = "%{public}s called with null count";
LABEL_18:
        _os_log_impl(&dword_1830D4000, v8, v9, v10, buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          char v16 = "nw_hash_table_create_with_lock";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null count, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_19;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_hash_table_create_with_lock";
        id v10 = "%{public}s called with null count, no backtrace";
        goto LABEL_18;
      }
    }
    else
    {
      BOOL v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_hash_table_create_with_lock";
        id v10 = "%{public}s called with null count, backtrace limit exceeded";
        goto LABEL_18;
      }
    }
  }
LABEL_19:
  if (v7) {
    free(v7);
  }
  return 0;
}

BOOL ___ZL24__nw_signpost_is_enabledv_block_invoke_63668()
{
  BOOL result = networkd_settings_get_BOOL((const char *)nw_setting_enable_signposts);
  _nw_signposts_enabled = result;
  return result;
}

uint64_t nw_protocol_hash_table_create(unsigned int a1, int a2)
{
  return nw_hash_table_create_no_lock(a1, a2, (const void *(*)(const void *, unsigned int *))nw_protocol_get_key, (unsigned int (*)(const void *, unsigned int))nw_protocol_key_hash, (BOOL (*)(const void *, const void *, unsigned int))nw_protocol_matches_key, 0);
}

BOOL nw_protocol_matches_key(void *a1, void *a2)
{
  return *a1 == *a2 && a1[1] == a2[1];
}

uint64_t nw_protocol_key_hash(int32x4_t *a1)
{
  return vaddvq_s32(*a1);
}

void nw_protocol_get_key(uint64_t a1, _DWORD *a2)
{
  *a2 = 16;
}

uint64_t nw_packet_hash_table_create(unsigned int a1, int a2)
{
  return nw_hash_table_create_no_lock(a1, a2, (const void *(*)(const void *, unsigned int *))nw_packet_get_key, (unsigned int (*)(const void *, unsigned int))nw_packet_key_hash, (BOOL (*)(const void *, const void *, unsigned int))nw_packet_matches_key, nw_packet_release);
}

void nw_packet_release(void *a1)
{
  if (a1) {
    free(a1);
  }
}

BOOL nw_packet_matches_key(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  uint64_t v6 = a1[2];
  uint64_t v7 = a1[3];
  uint64_t v8 = a2[2];
  uint64_t v9 = a2[3];
  uint64_t v10 = a1[4];
  uint64_t v11 = a1[5];
  uint64_t v12 = a2[4];
  uint64_t v13 = a2[5];
  uint64_t v14 = a1[6];
  uint64_t v15 = a2[6];
  uint64_t v16 = *((unsigned int *)a1 + 14);
  uint64_t v17 = *((unsigned int *)a2 + 14);
  return v2 == v4 && v3 == v5 && v6 == v8 && v7 == v9 && v10 == v12 && v11 == v13 && v14 == v15 && v16 == v17;
}

uint64_t nw_packet_key_hash(int32x4_t *a1)
{
  return (vaddvq_s32(vaddq_s32(vaddq_s32(*a1, a1[1]), a1[2])) + a1[3].i32[0] + a1[3].i32[1] + a1[3].i32[2]);
}

_DWORD *nw_fd_wrapper_create_do_not_guard(int a1)
{
  *(void *)&v18[13] = *MEMORY[0x1E4F143B8];
  if (a1 < 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    uint64_t v16 = "nw_fd_wrapper_create_do_not_guard";
    __int16 v17 = 1024;
    *(_DWORD *)BOOL v18 = a1;
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (__nwlog_fault(v5, &type, &v13))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v6 = (id)gLogObj;
        os_log_type_t v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v16 = "nw_fd_wrapper_create_do_not_guard";
          __int16 v17 = 1024;
          *(_DWORD *)BOOL v18 = a1;
          _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with invalid fd %d", buf, 0x12u);
        }
      }
      else if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v6 = (id)gLogObj;
        os_log_type_t v10 = type;
        BOOL v11 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446722;
            uint64_t v16 = "nw_fd_wrapper_create_do_not_guard";
            __int16 v17 = 1024;
            *(_DWORD *)BOOL v18 = a1;
            v18[2] = 2082;
            *(void *)&v18[3] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v6, v10, "%{public}s called with invalid fd %d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(backtrace_string);
          if (!v5) {
            return 0;
          }
          goto LABEL_11;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v16 = "nw_fd_wrapper_create_do_not_guard";
          __int16 v17 = 1024;
          *(_DWORD *)BOOL v18 = a1;
          _os_log_impl(&dword_1830D4000, v6, v10, "%{public}s called with invalid fd %d, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v6 = (id)gLogObj;
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v16 = "nw_fd_wrapper_create_do_not_guard";
          __int16 v17 = 1024;
          *(_DWORD *)BOOL v18 = a1;
          _os_log_impl(&dword_1830D4000, v6, v12, "%{public}s called with invalid fd %d, backtrace limit exceeded", buf, 0x12u);
        }
      }
    }
    if (!v5) {
      return 0;
    }
LABEL_11:
    free(v5);
    return 0;
  }
  uint64_t v2 = -[NWConcrete_nw_fd_wrapper initWithFileDescriptor:]([NWConcrete_nw_fd_wrapper alloc], a1);
  *((unsigned char *)v2 + 24) |= 2u;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v3 = (id)gLogObj;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v16 = "nw_fd_wrapper_create_do_not_guard";
    __int16 v17 = 2114;
    *(void *)BOOL v18 = v2;
    _os_log_impl(&dword_1830D4000, v3, OS_LOG_TYPE_DEBUG, "%{public}s Created %{public}@", buf, 0x16u);
  }

  return v2;
}

uint64_t nw_fd_wrapper_is_guarded(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  BOOL v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 3);
    uint64_t v3 = v2[6]._os_unfair_lock_opaque & 1;
    os_unfair_lock_unlock(v2 + 3);
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v16 = "nw_fd_wrapper_is_guarded";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_fd_wrapper_is_guarded";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null wrapper", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v16 = "nw_fd_wrapper_is_guarded";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null wrapper, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_fd_wrapper_is_guarded";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null wrapper, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_fd_wrapper_is_guarded";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null wrapper, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

void nw_fd_wrapper_relinquish_fd(void *a1)
{
  *(void *)&v39[13] = *MEMORY[0x1E4F143B8];
  BOOL v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 3);
    if ((v2[2]._os_unfair_lock_opaque & 0x80000000) != 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v3 = (id)gLogObj;
      uint32_t os_unfair_lock_opaque = v2[2]._os_unfair_lock_opaque;
      *(_DWORD *)buf = 136446466;
      os_log_type_t v37 = "nw_fd_wrapper_relinquish_fd";
      __int16 v38 = 1024;
      *(_DWORD *)uint64_t v39 = os_unfair_lock_opaque;
      uint64_t v5 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v34 = 0;
      if (!__nwlog_fault(v5, &type, &v34)) {
        goto LABEL_38;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v6 = (id)gLogObj;
        os_log_type_t v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          uint32_t v8 = v2[2]._os_unfair_lock_opaque;
          *(_DWORD *)buf = 136446466;
          os_log_type_t v37 = "nw_fd_wrapper_relinquish_fd";
          __int16 v38 = 1024;
          *(_DWORD *)uint64_t v39 = v8;
          _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s attempt to relinquish invalid fd %d", buf, 0x12u);
        }
        goto LABEL_37;
      }
      if (!v34)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v6 = (id)gLogObj;
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v6, type))
        {
          uint32_t v21 = v2[2]._os_unfair_lock_opaque;
          *(_DWORD *)buf = 136446466;
          os_log_type_t v37 = "nw_fd_wrapper_relinquish_fd";
          __int16 v38 = 1024;
          *(_DWORD *)uint64_t v39 = v21;
          _os_log_impl(&dword_1830D4000, v6, v20, "%{public}s attempt to relinquish invalid fd %d, backtrace limit exceeded", buf, 0x12u);
        }
        goto LABEL_37;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (id)gLogObj;
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          uint32_t v24 = v2[2]._os_unfair_lock_opaque;
          *(_DWORD *)buf = 136446466;
          os_log_type_t v37 = "nw_fd_wrapper_relinquish_fd";
          __int16 v38 = 1024;
          *(_DWORD *)uint64_t v39 = v24;
          _os_log_impl(&dword_1830D4000, v6, v14, "%{public}s attempt to relinquish invalid fd %d, no backtrace", buf, 0x12u);
        }
        goto LABEL_37;
      }
      if (v15)
      {
        uint32_t v16 = v2[2]._os_unfair_lock_opaque;
        *(_DWORD *)buf = 136446722;
        os_log_type_t v37 = "nw_fd_wrapper_relinquish_fd";
        __int16 v38 = 1024;
        *(_DWORD *)uint64_t v39 = v16;
        v39[2] = 2082;
        *(void *)&v39[3] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v6, v14, "%{public}s attempt to relinquish invalid fd %d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }
    }
    else
    {
      if ((v2[6]._os_unfair_lock_opaque & 1) == 0)
      {
        v2[2]._uint32_t os_unfair_lock_opaque = -1;
LABEL_40:
        os_unfair_lock_unlock(v2 + 3);
        goto LABEL_41;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v9 = (id)gLogObj;
      uint32_t v10 = v2[2]._os_unfair_lock_opaque;
      *(_DWORD *)buf = 136446466;
      os_log_type_t v37 = "nw_fd_wrapper_relinquish_fd";
      __int16 v38 = 1024;
      *(_DWORD *)uint64_t v39 = v10;
      uint64_t v5 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v34 = 0;
      if (!__nwlog_fault(v5, &type, &v34)) {
        goto LABEL_38;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v6 = (id)gLogObj;
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v6, type))
        {
          uint32_t v12 = v2[2]._os_unfair_lock_opaque;
          *(_DWORD *)buf = 136446466;
          os_log_type_t v37 = "nw_fd_wrapper_relinquish_fd";
          __int16 v38 = 1024;
          *(_DWORD *)uint64_t v39 = v12;
          _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s attempt to relinquish guarded fd %d", buf, 0x12u);
        }
LABEL_37:

LABEL_38:
        if (!v5) {
          goto LABEL_40;
        }
LABEL_39:
        free(v5);
        goto LABEL_40;
      }
      if (!v34)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v6 = (id)gLogObj;
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v6, type))
        {
          uint32_t v23 = v2[2]._os_unfair_lock_opaque;
          *(_DWORD *)buf = 136446466;
          os_log_type_t v37 = "nw_fd_wrapper_relinquish_fd";
          __int16 v38 = 1024;
          *(_DWORD *)uint64_t v39 = v23;
          _os_log_impl(&dword_1830D4000, v6, v22, "%{public}s attempt to relinquish guarded fd %d, backtrace limit exceeded", buf, 0x12u);
        }
        goto LABEL_37;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (id)gLogObj;
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (v18)
        {
          uint32_t v25 = v2[2]._os_unfair_lock_opaque;
          *(_DWORD *)buf = 136446466;
          os_log_type_t v37 = "nw_fd_wrapper_relinquish_fd";
          __int16 v38 = 1024;
          *(_DWORD *)uint64_t v39 = v25;
          _os_log_impl(&dword_1830D4000, v6, v17, "%{public}s attempt to relinquish guarded fd %d, no backtrace", buf, 0x12u);
        }
        goto LABEL_37;
      }
      if (v18)
      {
        uint32_t v19 = v2[2]._os_unfair_lock_opaque;
        *(_DWORD *)buf = 136446722;
        os_log_type_t v37 = "nw_fd_wrapper_relinquish_fd";
        __int16 v38 = 1024;
        *(_DWORD *)uint64_t v39 = v19;
        v39[2] = 2082;
        *(void *)&v39[3] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v6, v17, "%{public}s attempt to relinquish guarded fd %d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }
    }

    free(backtrace_string);
    if (!v5) {
      goto LABEL_40;
    }
    goto LABEL_39;
  }
  __int16 v26 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v37 = "nw_fd_wrapper_relinquish_fd";
  __int16 v27 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v34 = 0;
  if (__nwlog_fault(v27, &type, &v34))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v28 = __nwlog_obj();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v28, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v37 = "nw_fd_wrapper_relinquish_fd";
        _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s called with null wrapper", buf, 0xCu);
      }
    }
    else if (v34)
    {
      os_log_type_t v30 = (char *)__nw_create_backtrace_string();
      uint64_t v28 = __nwlog_obj();
      os_log_type_t v31 = type;
      BOOL v32 = os_log_type_enabled(v28, type);
      if (v30)
      {
        if (v32)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v37 = "nw_fd_wrapper_relinquish_fd";
          __int16 v38 = 2082;
          *(void *)uint64_t v39 = v30;
          _os_log_impl(&dword_1830D4000, v28, v31, "%{public}s called with null wrapper, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v30);
        goto LABEL_58;
      }
      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v37 = "nw_fd_wrapper_relinquish_fd";
        _os_log_impl(&dword_1830D4000, v28, v31, "%{public}s called with null wrapper, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v28 = __nwlog_obj();
      os_log_type_t v33 = type;
      if (os_log_type_enabled(v28, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v37 = "nw_fd_wrapper_relinquish_fd";
        _os_log_impl(&dword_1830D4000, v28, v33, "%{public}s called with null wrapper, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_58:
  if (v27) {
    free(v27);
  }
LABEL_41:
}

void sub_183B70B3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)NWConcrete_nw_interpose;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

id *nw_interpose_client_register(int a1, void *a2)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  id v4 = a2;
  nw_allow_use_of_dispatch_internal();
  uint64_t v5 = [NWConcrete_nw_interpose alloc];
  id v6 = v4;
  if (!v5)
  {
LABEL_60:

    goto LABEL_61;
  }
  v41.receiver = v5;
  v41.super_class = (Class)NWConcrete_nw_interpose;
  os_log_type_t v7 = (id *)objc_msgSendSuper2(&v41, sel_init);
  if (!v7)
  {
    uint32_t v23 = __nwlog_obj();
    LODWORD(buffer[0]) = 136446210;
    *(void *)((char *)buffer + 4) = "-[NWConcrete_nw_interpose initWithDelegatedPid:nw_context:]";
    uint32_t v24 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    LOBYTE(v42) = 0;
    if (__nwlog_fault(v24, buf, &v42))
    {
      if (buf[0] == 17)
      {
        uint32_t v25 = __nwlog_obj();
        os_log_type_t v26 = buf[0];
        if (os_log_type_enabled(v25, (os_log_type_t)buf[0]))
        {
          LODWORD(buffer[0]) = 136446210;
          *(void *)((char *)buffer + 4) = "-[NWConcrete_nw_interpose initWithDelegatedPid:nw_context:]";
          _os_log_impl(&dword_1830D4000, v25, v26, "%{public}s [super init] failed", (uint8_t *)buffer, 0xCu);
        }
      }
      else if ((_BYTE)v42)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint32_t v25 = __nwlog_obj();
        os_log_type_t v32 = buf[0];
        BOOL v33 = os_log_type_enabled(v25, (os_log_type_t)buf[0]);
        if (backtrace_string)
        {
          if (v33)
          {
            LODWORD(buffer[0]) = 136446466;
            *(void *)((char *)buffer + 4) = "-[NWConcrete_nw_interpose initWithDelegatedPid:nw_context:]";
            WORD6(buffer[0]) = 2082;
            *(void *)((char *)buffer + 14) = backtrace_string;
            _os_log_impl(&dword_1830D4000, v25, v32, "%{public}s [super init] failed, dumping backtrace:%{public}s", (uint8_t *)buffer, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_52;
        }
        if (v33)
        {
          LODWORD(buffer[0]) = 136446210;
          *(void *)((char *)buffer + 4) = "-[NWConcrete_nw_interpose initWithDelegatedPid:nw_context:]";
          _os_log_impl(&dword_1830D4000, v25, v32, "%{public}s [super init] failed, no backtrace", (uint8_t *)buffer, 0xCu);
        }
      }
      else
      {
        uint32_t v25 = __nwlog_obj();
        os_log_type_t v37 = buf[0];
        if (os_log_type_enabled(v25, (os_log_type_t)buf[0]))
        {
          LODWORD(buffer[0]) = 136446210;
          *(void *)((char *)buffer + 4) = "-[NWConcrete_nw_interpose initWithDelegatedPid:nw_context:]";
          _os_log_impl(&dword_1830D4000, v25, v37, "%{public}s [super init] failed, backtrace limit exceeded", (uint8_t *)buffer, 0xCu);
        }
      }
    }
LABEL_52:
    if (v24) {
      free(v24);
    }
    goto LABEL_60;
  }
  uint32_t v8 = v7;
  *((_DWORD *)v7 + 7) = a1;
  id v9 = v7 + 8;
  objc_storeStrong(v7 + 8, a2);
  id v10 = *v9;
  if (!*v9)
  {
    if (nw_context_copy_implicit_context::onceToken != -1) {
      dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
    }
    objc_storeStrong(v9, (id)nw_context_copy_implicit_context::implicit_context);
    id v10 = *v9;
  }
  if (nw_context_is_inline(v10))
  {
    __int16 v27 = __nwlog_obj();
    LODWORD(buffer[0]) = 136446210;
    *(void *)((char *)buffer + 4) = "-[NWConcrete_nw_interpose initWithDelegatedPid:nw_context:]";
    uint64_t v28 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    LOBYTE(v42) = 0;
    if (__nwlog_fault(v28, buf, &v42))
    {
      if (buf[0] == 17)
      {
        os_log_type_t v29 = __nwlog_obj();
        os_log_type_t v30 = buf[0];
        if (os_log_type_enabled(v29, (os_log_type_t)buf[0]))
        {
          LODWORD(buffer[0]) = 136446210;
          *(void *)((char *)buffer + 4) = "-[NWConcrete_nw_interpose initWithDelegatedPid:nw_context:]";
          _os_log_impl(&dword_1830D4000, v29, v30, "%{public}s Cannot use nw_interpose on inline contexts", (uint8_t *)buffer, 0xCu);
        }
      }
      else if ((_BYTE)v42)
      {
        char v34 = (char *)__nw_create_backtrace_string();
        os_log_type_t v29 = __nwlog_obj();
        os_log_type_t v35 = buf[0];
        BOOL v36 = os_log_type_enabled(v29, (os_log_type_t)buf[0]);
        if (v34)
        {
          if (v36)
          {
            LODWORD(buffer[0]) = 136446466;
            *(void *)((char *)buffer + 4) = "-[NWConcrete_nw_interpose initWithDelegatedPid:nw_context:]";
            WORD6(buffer[0]) = 2082;
            *(void *)((char *)buffer + 14) = v34;
            _os_log_impl(&dword_1830D4000, v29, v35, "%{public}s Cannot use nw_interpose on inline contexts, dumping backtrace:%{public}s", (uint8_t *)buffer, 0x16u);
          }

          free(v34);
          goto LABEL_57;
        }
        if (v36)
        {
          LODWORD(buffer[0]) = 136446210;
          *(void *)((char *)buffer + 4) = "-[NWConcrete_nw_interpose initWithDelegatedPid:nw_context:]";
          _os_log_impl(&dword_1830D4000, v29, v35, "%{public}s Cannot use nw_interpose on inline contexts, no backtrace", (uint8_t *)buffer, 0xCu);
        }
      }
      else
      {
        os_log_type_t v29 = __nwlog_obj();
        os_log_type_t v38 = buf[0];
        if (os_log_type_enabled(v29, (os_log_type_t)buf[0]))
        {
          LODWORD(buffer[0]) = 136446210;
          *(void *)((char *)buffer + 4) = "-[NWConcrete_nw_interpose initWithDelegatedPid:nw_context:]";
          _os_log_impl(&dword_1830D4000, v29, v38, "%{public}s Cannot use nw_interpose on inline contexts, backtrace limit exceeded", (uint8_t *)buffer, 0xCu);
        }
      }
    }
LABEL_57:
    if (v28) {
      free(v28);
    }

    goto LABEL_60;
  }
  uint64_t v52 = 0;
  memset(buffer, 0, sizeof(buffer));
  int v11 = proc_pidinfo(a1, 17, 1uLL, buffer, 56);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint32_t v12 = (id)gLogObj;
  char v13 = v12;
  if (v11 != 56)
  {
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      int v20 = *((_DWORD *)v8 + 7);
      *(_DWORD *)buf = 136446722;
      os_log_type_t v44 = "-[NWConcrete_nw_interpose initWithDelegatedPid:nw_context:]";
      __int16 v45 = 2114;
      BOOL v46 = v8;
      __int16 v47 = 1024;
      int v48 = v20;
      _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_ERROR, "%{public}s [%{public}@] failed to get upid for pid %d", buf, 0x1Cu);
    }
    goto LABEL_20;
  }
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136446978;
    os_log_type_t v44 = "-[NWConcrete_nw_interpose initWithDelegatedPid:nw_context:]";
    __int16 v45 = 2114;
    BOOL v46 = v8;
    __int16 v47 = 1024;
    int v48 = a1;
    __int16 v49 = 2048;
    BOOL v50 = *(long long **)&buffer[1];
    _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_DEBUG, "%{public}s [%{public}@] pid %u upid %llu", buf, 0x26u);
  }

  char v13 = nw_parameters_create();
  nw_parameters_set_pid(v13, *((_DWORD *)v8 + 7));
  nw_parameters_set_proc_uuid(v13, buffer);
  nw_parameters_set_e_proc_uuid(v13, buffer);
  nw_parameters_set_delegated_unique_pid(v13, *(uint64_t *)&buffer[1]);
  nw_parameters_set_include_peer_to_peer(v13, 1);
  nw_parameters_set_context(v13, v8[8]);
  evaluator_for_interpose = nw_path_create_evaluator_for_interpose(v13);
  id v15 = v8[5];
  v8[5] = evaluator_for_interpose;

  id v16 = v8[5];
  if (!v16)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint32_t v21 = (id)gLogObj;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      os_log_type_t v44 = "-[NWConcrete_nw_interpose initWithDelegatedPid:nw_context:]";
      __int16 v45 = 2114;
      BOOL v46 = v8;
      __int16 v47 = 1024;
      int v48 = a1;
      _os_log_impl(&dword_1830D4000, v21, OS_LOG_TYPE_ERROR, "%{public}s [%{public}@] failed to create evaluator for pid %d", buf, 0x1Cu);
    }

LABEL_20:
    uint32_t v19 = 0;
    goto LABEL_21;
  }
  os_log_type_t v17 = v16;
  long long v42 = v17[5];

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v18 = (id)gLogObj;
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136446978;
    os_log_type_t v44 = "-[NWConcrete_nw_interpose initWithDelegatedPid:nw_context:]";
    __int16 v45 = 2114;
    BOOL v46 = v8;
    __int16 v47 = 1042;
    int v48 = 16;
    __int16 v49 = 2098;
    BOOL v50 = &v42;
    _os_log_impl(&dword_1830D4000, v18, OS_LOG_TYPE_DEBUG, "%{public}s [%{public}@] registered with client %{public,uuid_t}.16P", buf, 0x26u);
  }

  uint32_t v19 = v8;
LABEL_21:

  if (v19)
  {
    os_log_type_t v22 = v19;
    goto LABEL_64;
  }
LABEL_61:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v39 = (id)gLogObj;
  if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buffer[0]) = 136446466;
    *(void *)((char *)buffer + 4) = "nw_interpose_client_register";
    WORD6(buffer[0]) = 2114;
    *(void *)((char *)buffer + 14) = 0;
    _os_log_impl(&dword_1830D4000, v39, OS_LOG_TYPE_ERROR, "%{public}s [%{public}@] failed to allocate interpose", (uint8_t *)buffer, 0x16u);
  }

  os_log_type_t v22 = 0;
LABEL_64:

  return v22;
}

void sub_183B7145C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_interpose_set_queue(void *a1, void *a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (!v3)
  {
    id v6 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint32_t v23 = "nw_interpose_set_queue";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (!__nwlog_fault(v7, &type, &v20)) {
      goto LABEL_38;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint32_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        uint32_t v23 = "nw_interpose_set_queue";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null interpose", buf, 0xCu);
      }
    }
    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint32_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          uint32_t v23 = "nw_interpose_set_queue";
          __int16 v24 = 2082;
          uint32_t v25 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null interpose, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v7) {
          goto LABEL_4;
        }
LABEL_39:
        free(v7);
        goto LABEL_4;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        uint32_t v23 = "nw_interpose_set_queue";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null interpose, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint32_t v8 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        uint32_t v23 = "nw_interpose_set_queue";
        _os_log_impl(&dword_1830D4000, v8, v18, "%{public}s called with null interpose, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    os_unfair_lock_lock((os_unfair_lock_t)v3 + 2);
    objc_storeStrong((id *)v3 + 9, a2);
    os_unfair_lock_unlock((os_unfair_lock_t)v3 + 2);
    goto LABEL_4;
  }
  id v10 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint32_t v23 = "nw_interpose_set_queue";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (!__nwlog_fault(v7, &type, &v20)) {
    goto LABEL_38;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint32_t v8 = __nwlog_obj();
    os_log_type_t v11 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      uint32_t v23 = "nw_interpose_set_queue";
      _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null queue", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v20)
  {
    uint32_t v8 = __nwlog_obj();
    os_log_type_t v19 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      uint32_t v23 = "nw_interpose_set_queue";
      _os_log_impl(&dword_1830D4000, v8, v19, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  id v15 = (char *)__nw_create_backtrace_string();
  uint32_t v8 = __nwlog_obj();
  os_log_type_t v16 = type;
  BOOL v17 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      uint32_t v23 = "nw_interpose_set_queue";
      _os_log_impl(&dword_1830D4000, v8, v16, "%{public}s called with null queue, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    uint32_t v23 = "nw_interpose_set_queue";
    __int16 v24 = 2082;
    uint32_t v25 = v15;
    _os_log_impl(&dword_1830D4000, v8, v16, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v15);
  if (v7) {
    goto LABEL_39;
  }
LABEL_4:
}

void nw_interpose_set_flow_event_handler(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (!v3)
  {
    os_log_type_t v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v26 = "nw_interpose_set_flow_event_handler";
    id v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v10, &type, &v23)) {
      goto LABEL_38;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_interpose_set_flow_event_handler";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null interpose", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v26 = "nw_interpose_set_flow_event_handler";
          __int16 v27 = 2082;
          uint64_t v28 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null interpose, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v10) {
          goto LABEL_4;
        }
LABEL_39:
        free(v10);
        goto LABEL_4;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_interpose_set_flow_event_handler";
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null interpose, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_interpose_set_flow_event_handler";
        _os_log_impl(&dword_1830D4000, v11, v21, "%{public}s called with null interpose, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    os_unfair_lock_lock(v3 + 2);
    id v6 = v3;
    os_log_type_t v7 = _Block_copy(v5);
    uint32_t v8 = *(void **)&v6[14]._os_unfair_lock_opaque;
    *(void *)&v6[14]._uint32_t os_unfair_lock_opaque = v7;

    os_unfair_lock_unlock(v3 + 2);
    goto LABEL_4;
  }
  os_log_type_t v13 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v26 = "nw_interpose_set_flow_event_handler";
  id v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (!__nwlog_fault(v10, &type, &v23)) {
    goto LABEL_38;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v11 = __nwlog_obj();
    os_log_type_t v14 = type;
    if (os_log_type_enabled(v11, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v26 = "nw_interpose_set_flow_event_handler";
      _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null handler", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v23)
  {
    os_log_type_t v11 = __nwlog_obj();
    os_log_type_t v22 = type;
    if (os_log_type_enabled(v11, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v26 = "nw_interpose_set_flow_event_handler";
      _os_log_impl(&dword_1830D4000, v11, v22, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  os_log_type_t v18 = (char *)__nw_create_backtrace_string();
  os_log_type_t v11 = __nwlog_obj();
  os_log_type_t v19 = type;
  BOOL v20 = os_log_type_enabled(v11, type);
  if (!v18)
  {
    if (v20)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v26 = "nw_interpose_set_flow_event_handler";
      _os_log_impl(&dword_1830D4000, v11, v19, "%{public}s called with null handler, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v20)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v26 = "nw_interpose_set_flow_event_handler";
    __int16 v27 = 2082;
    uint64_t v28 = v18;
    _os_log_impl(&dword_1830D4000, v11, v19, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v18);
  if (v10) {
    goto LABEL_39;
  }
LABEL_4:
}

void nw_interpose_start(void *a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  BOOL v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 2);
    objc_initWeak((id *)location, v2);
    id v3 = *(void **)&v2[10]._os_unfair_lock_opaque;
    id v4 = *(void **)&v2[18]._os_unfair_lock_opaque;
    v16[0] = MEMORY[0x1E4F143A8];
    v16[1] = 3221225472;
    v16[2] = __nw_interpose_start_block_invoke;
    v16[3] = &unk_1E524B478;
    objc_copyWeak(&v17, (id *)location);
    nw_path_evaluator_set_update_handler(v3, v4, v16);
    uint64_t v5 = *(void **)&v2[16]._os_unfair_lock_opaque;
    v14[0] = MEMORY[0x1E4F143A8];
    v14[1] = 3221225472;
    v14[2] = __nw_interpose_start_block_invoke_7;
    v14[3] = &unk_1E524BAA8;
    id v15 = v2;
    nw_queue_context_async(v5, v14);
    os_unfair_lock_unlock(v2 + 2);

    objc_destroyWeak(&v17);
    objc_destroyWeak((id *)location);
    goto LABEL_3;
  }
  id v6 = __nwlog_obj();
  *(_DWORD *)location = 136446210;
  *(void *)&location[4] = "nw_interpose_start";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v19 = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (__nwlog_fault(v7, &v19, &v18))
  {
    if (v19 == OS_LOG_TYPE_FAULT)
    {
      uint32_t v8 = __nwlog_obj();
      os_log_type_t v9 = v19;
      if (os_log_type_enabled(v8, v19))
      {
        *(_DWORD *)location = 136446210;
        *(void *)&location[4] = "nw_interpose_start";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null interpose", location, 0xCu);
      }
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint32_t v8 = __nwlog_obj();
      os_log_type_t v11 = v19;
      BOOL v12 = os_log_type_enabled(v8, v19);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)location = 136446466;
          *(void *)&location[4] = "nw_interpose_start";
          __int16 v21 = 2082;
          os_log_type_t v22 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null interpose, dumping backtrace:%{public}s", location, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)location = 136446210;
        *(void *)&location[4] = "nw_interpose_start";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null interpose, no backtrace", location, 0xCu);
      }
    }
    else
    {
      uint32_t v8 = __nwlog_obj();
      os_log_type_t v13 = v19;
      if (os_log_type_enabled(v8, v19))
      {
        *(_DWORD *)location = 136446210;
        *(void *)&location[4] = "nw_interpose_start";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null interpose, backtrace limit exceeded", location, 0xCu);
      }
    }
  }
LABEL_20:
  if (v7) {
    free(v7);
  }
LABEL_3:
}

void sub_183B721D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  objc_destroyWeak(v19);
  objc_destroyWeak((id *)(v20 - 96));

  _Unwind_Resume(a1);
}

void __nw_interpose_start_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  WeakRetained = (os_unfair_lock_s *)objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v5 = (id)gLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      int v6 = 136446722;
      os_log_type_t v7 = "nw_interpose_start_block_invoke";
      __int16 v8 = 2114;
      os_log_type_t v9 = WeakRetained;
      __int16 v10 = 2114;
      id v11 = v3;
      _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_DEBUG, "%{public}s [%{public}@] Handling new path %{public}@", (uint8_t *)&v6, 0x20u);
    }

    os_unfair_lock_lock(WeakRetained + 2);
    nw_interpose_handle_path_update_locked(WeakRetained, v3);
    os_unfair_lock_unlock(WeakRetained + 2);
  }
}

void sub_183B72334(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_interpose_start_block_invoke_7(uint64_t a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 8));
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = (os_unfair_lock_s *)v2[5];
  if (v3)
  {
    id v4 = v3 + 24;
    uint64_t v5 = v3;
    os_unfair_lock_lock(v4);
    id v6 = v5[6];
    os_unfair_lock_unlock(v4);
  }
  else
  {
    id v6 = 0;
  }
  nw_interpose_handle_path_update_locked(v2, v6);

  os_log_type_t v7 = (os_unfair_lock_s *)(*(void *)(a1 + 32) + 8);

  os_unfair_lock_unlock(v7);
}

void sub_183B723F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_interpose_handle_path_update_locked(void *a1, void *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = nw_dictionary_create();
  v21[0] = MEMORY[0x1E4F143A8];
  v21[1] = 3221225472;
  v21[2] = ___ZL38nw_interpose_handle_path_update_lockedP23NWConcrete_nw_interposePU21objcproto10OS_nw_path8NSObject_block_invoke;
  v21[3] = &unk_1E5247B30;
  id v6 = (uint64_t *)v3;
  os_log_type_t v22 = v6;
  os_log_type_t v7 = v5;
  id v23 = v7;
  nw_path_enumerate_interface_options(v4, v21);
  uint64_t v8 = v6[6];
  if (v8)
  {
    v19[0] = MEMORY[0x1E4F143A8];
    v19[1] = 3221225472;
    v19[2] = ___ZL38nw_interpose_handle_path_update_lockedP23NWConcrete_nw_interposePU21objcproto10OS_nw_path8NSObject_block_invoke_82;
    v19[3] = &unk_1E5247FE0;
    uint64_t v20 = v7;
    nw_dictionary_apply(v8, (uint64_t)v19);
  }
  objc_storeStrong((id *)v6 + 6, v5);
  os_log_type_t v9 = (void *)v6[8];
  v17[0] = MEMORY[0x1E4F143A8];
  v17[1] = 3221225472;
  v17[2] = ___ZL38nw_interpose_handle_path_update_lockedP23NWConcrete_nw_interposePU21objcproto10OS_nw_path8NSObject_block_invoke_2;
  v17[3] = &unk_1E524BAA8;
  __int16 v10 = v6;
  char v18 = v10;
  nw_queue_context_async(v9, v17);
  id v11 = (atomic_uchar *)nw_path_copy_flows(v4);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v12 = (id)gLogObj;
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
  {
    if (v11) {
      uint64_t v13 = (*((void *)v11 + 3) - *((void *)v11 + 2)) >> 3;
    }
    else {
      LODWORD(v13) = 0;
    }
    *(_DWORD *)buf = 136446722;
    uint32_t v25 = "nw_interpose_handle_path_update_locked";
    __int16 v26 = 2114;
    __int16 v27 = v10;
    __int16 v28 = 1024;
    int v29 = v13;
    _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_DEBUG, "%{public}s [%{public}@] got %d flows from path", buf, 0x1Cu);
  }

  v15[0] = MEMORY[0x1E4F143A8];
  v15[1] = 3221225472;
  _DWORD v15[2] = ___ZL38nw_interpose_handle_path_update_lockedP23NWConcrete_nw_interposePU21objcproto10OS_nw_path8NSObject_block_invoke_83;
  v15[3] = &unk_1E524AE18;
  os_log_type_t v14 = v10;
  os_log_type_t v16 = v14;
  nw_array_apply(v11, (uint64_t)v15);
}

void sub_183B72700(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,void *a30)
{
  _Unwind_Resume(a1);
}

void ___ZL38nw_interpose_handle_path_update_lockedP23NWConcrete_nw_interposePU21objcproto10OS_nw_path8NSObject_block_invoke(uint64_t a1, void *a2, const unsigned __int8 *a3)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a2;
  id v6 = (char *)v5;
  if (v5) {
    os_log_type_t v7 = v5 + 104;
  }
  else {
    os_log_type_t v7 = 0;
  }
  if (v5)
  {
    if (uuid_is_null(a3))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      p_super = (id)gLogObj;
      if (os_log_type_enabled(p_super, OS_LOG_TYPE_ERROR))
      {
        uint64_t v9 = *(void *)(a1 + 32);
        *(_DWORD *)buf = 136446466;
        __int16 v28 = "nw_interpose_handle_path_update_locked_block_invoke";
        __int16 v29 = 2114;
        uint64_t v30 = v9;
        __int16 v10 = "%{public}s [%{public}@] no nexus agent";
LABEL_10:
        _os_log_impl(&dword_1830D4000, p_super, OS_LOG_TYPE_ERROR, v10, buf, 0x16u);
        goto LABEL_34;
      }
      goto LABEL_34;
    }
    uint64_t v12 = *(void *)(*(void *)(a1 + 32) + 48);
    if (v12 && (uint64_t v13 = (nw_interpose_flow *)nw_dictionary_copy_value(v12, (uint64_t)v7)) != 0)
    {
      os_log_type_t v14 = v13;
      if ([(nw_interpose_flow *)v13 matchNexusAgent:a3])
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v15 = (id)gLogObj;
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v16 = *(void *)(a1 + 32);
          *(_DWORD *)buf = 136447234;
          __int16 v28 = "nw_interpose_handle_path_update_locked_block_invoke";
          __int16 v29 = 2114;
          uint64_t v30 = v16;
          __int16 v31 = 1042;
          int v32 = 16;
          __int16 v33 = 2098;
          char v34 = a3;
          __int16 v35 = 2080;
          BOOL v36 = v7;
          _os_log_impl(&dword_1830D4000, v15, OS_LOG_TYPE_DEBUG, "%{public}s [%{public}@] flow registration already exists for nexus agent %{public,uuid_t}.16P on %s", buf, 0x30u);
        }

LABEL_26:
        nw_dictionary_set_value(*(void *)(a1 + 40), v7, v14);
        p_super = &v14->super;
        goto LABEL_34;
      }
      p_super = &v14->super;
    }
    else
    {
      p_super = 0;
    }
    long long v26 = *(_OWORD *)a3;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v17 = (id)gLogObj;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v18 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 136447234;
      __int16 v28 = "nw_interpose_handle_path_update_locked_block_invoke";
      __int16 v29 = 2114;
      uint64_t v30 = v18;
      __int16 v31 = 1042;
      int v32 = 16;
      __int16 v33 = 2098;
      char v34 = (const unsigned __int8 *)&v26;
      __int16 v35 = 2080;
      BOOL v36 = v7;
      _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_DEBUG, "%{public}s [%{public}@] adding flow registration for nexus agent %{public,uuid_t}.16P on %s", buf, 0x30u);
    }

    os_log_type_t v19 = nw_path_evaluator_create_flow_inner(*(void **)(*(void *)(a1 + 32) + 40), 0, 1, 0, 0, &v26, 0, 0, 0);
    if (v19)
    {
      os_log_type_t v14 = [[nw_interpose_flow alloc] initWithInterface:v6 registration:v19 eventHandler:*(void *)(*(void *)(a1 + 32) + 56)];

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v20 = (id)gLogObj;
      __int16 v21 = v20;
      if (v14)
      {
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v22 = *(void *)(a1 + 32);
          *(_DWORD *)buf = 136447234;
          __int16 v28 = "nw_interpose_handle_path_update_locked_block_invoke";
          __int16 v29 = 2114;
          uint64_t v30 = v22;
          __int16 v31 = 1042;
          int v32 = 16;
          __int16 v33 = 2098;
          char v34 = (const unsigned __int8 *)&v26;
          __int16 v35 = 2080;
          BOOL v36 = v7;
          _os_log_impl(&dword_1830D4000, v21, OS_LOG_TYPE_DEBUG, "%{public}s [%{public}@] added flow registration for nexus agent %{public,uuid_t}.16P on %s", buf, 0x30u);
        }

        goto LABEL_26;
      }
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        uint64_t v25 = *(void *)(a1 + 32);
        *(_DWORD *)buf = 136447234;
        __int16 v28 = "nw_interpose_handle_path_update_locked_block_invoke";
        __int16 v29 = 2114;
        uint64_t v30 = v25;
        __int16 v31 = 1042;
        int v32 = 16;
        __int16 v33 = 2098;
        char v34 = (const unsigned __int8 *)&v26;
        __int16 v35 = 2080;
        BOOL v36 = v7;
        _os_log_impl(&dword_1830D4000, v21, OS_LOG_TYPE_ERROR, "%{public}s [%{public}@] failed to create flow object for nexus agent %{public,uuid_t}.16P on %s", buf, 0x30u);
      }

      p_super = 0;
      nw_path_flow_registration_close(v19);
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v23 = (id)gLogObj;
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        uint64_t v24 = *(void *)(a1 + 32);
        *(_DWORD *)buf = 136447234;
        __int16 v28 = "nw_interpose_handle_path_update_locked_block_invoke";
        __int16 v29 = 2114;
        uint64_t v30 = v24;
        __int16 v31 = 1042;
        int v32 = 16;
        __int16 v33 = 2098;
        char v34 = (const unsigned __int8 *)&v26;
        __int16 v35 = 2080;
        BOOL v36 = v7;
        _os_log_impl(&dword_1830D4000, v23, OS_LOG_TYPE_ERROR, "%{public}s [%{public}@] failed to create flow registration for nexus agent %{public,uuid_t}.16P on %s", buf, 0x30u);
      }
    }
    goto LABEL_34;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  p_super = (id)gLogObj;
  if (os_log_type_enabled(p_super, OS_LOG_TYPE_ERROR))
  {
    uint64_t v11 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 136446466;
    __int16 v28 = "nw_interpose_handle_path_update_locked_block_invoke";
    __int16 v29 = 2114;
    uint64_t v30 = v11;
    __int16 v10 = "%{public}s [%{public}@] no interface name";
    goto LABEL_10;
  }
LABEL_34:
}

void sub_183B72D14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL38nw_interpose_handle_path_update_lockedP23NWConcrete_nw_interposePU21objcproto10OS_nw_path8NSObject_block_invoke_82(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  id v6 = nw_dictionary_copy_value(*(void *)(a1 + 32), a2);
  os_log_type_t v7 = v6;
  if (v6) {
    BOOL v8 = v6 == v5;
  }
  else {
    BOOL v8 = 0;
  }
  if (!v8) {
    [v5 close];
  }

  return 1;
}

void sub_183B72DBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL38nw_interpose_handle_path_update_lockedP23NWConcrete_nw_interposePU21objcproto10OS_nw_path8NSObject_block_invoke_2(uint64_t a1)
{
}

uint64_t ___ZL38nw_interpose_handle_path_update_lockedP23NWConcrete_nw_interposePU21objcproto10OS_nw_path8NSObject_block_invoke_83(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v5 = *(id *)(a1 + 32);
  id v6 = v4;
  os_log_type_t v7 = v6;
  if (!v5)
  {
    uint64_t v13 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_interpose_flow_get_locked";
    os_log_type_t v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (!__nwlog_fault(v14, &type, &v37)) {
      goto LABEL_57;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_interpose_flow_get_locked";
        _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s called with null interpose", buf, 0xCu);
      }
      goto LABEL_56;
    }
    if (!v37)
    {
      id v15 = __nwlog_obj();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_interpose_flow_get_locked";
        _os_log_impl(&dword_1830D4000, v15, v29, "%{public}s called with null interpose, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_56;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    id v15 = __nwlog_obj();
    os_log_type_t v22 = type;
    BOOL v23 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_interpose_flow_get_locked";
        _os_log_impl(&dword_1830D4000, v15, v22, "%{public}s called with null interpose, no backtrace", buf, 0xCu);
      }
      goto LABEL_56;
    }
    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_interpose_flow_get_locked";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl(&dword_1830D4000, v15, v22, "%{public}s called with null interpose, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_32;
  }
  uint64_t v8 = v5[6];
  if (!v8)
  {
    id v17 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_interpose_flow_get_locked";
    os_log_type_t v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (!__nwlog_fault(v14, &type, &v37)) {
      goto LABEL_57;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v15 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_interpose_flow_get_locked";
        _os_log_impl(&dword_1830D4000, v15, v18, "%{public}s called with null interpose->flows", buf, 0xCu);
      }
      goto LABEL_56;
    }
    if (!v37)
    {
      id v15 = __nwlog_obj();
      os_log_type_t v30 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_interpose_flow_get_locked";
        _os_log_impl(&dword_1830D4000, v15, v30, "%{public}s called with null interpose->flows, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_56;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    id v15 = __nwlog_obj();
    os_log_type_t v24 = type;
    BOOL v25 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_interpose_flow_get_locked";
        _os_log_impl(&dword_1830D4000, v15, v24, "%{public}s called with null interpose->flows, no backtrace", buf, 0xCu);
      }
      goto LABEL_56;
    }
    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_interpose_flow_get_locked";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl(&dword_1830D4000, v15, v24, "%{public}s called with null interpose->flows, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_32:

    free(backtrace_string);
    if (!v14) {
      goto LABEL_59;
    }
    goto LABEL_58;
  }
  if (!v6)
  {
    os_log_type_t v19 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_interpose_flow_get_locked";
    os_log_type_t v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (!__nwlog_fault(v14, &type, &v37)) {
      goto LABEL_57;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v15 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_interpose_flow_get_locked";
        _os_log_impl(&dword_1830D4000, v15, v20, "%{public}s called with null flow", buf, 0xCu);
      }
    }
    else if (v37)
    {
      long long v26 = (char *)__nw_create_backtrace_string();
      id v15 = __nwlog_obj();
      os_log_type_t v27 = type;
      BOOL v28 = os_log_type_enabled(v15, type);
      if (v26)
      {
        if (v28)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_interpose_flow_get_locked";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v26;
          _os_log_impl(&dword_1830D4000, v15, v27, "%{public}s called with null flow, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v26);
LABEL_57:
        if (!v14)
        {
LABEL_59:

          goto LABEL_60;
        }
LABEL_58:
        free(v14);
        goto LABEL_59;
      }
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_interpose_flow_get_locked";
        _os_log_impl(&dword_1830D4000, v15, v27, "%{public}s called with null flow, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v15 = __nwlog_obj();
      os_log_type_t v31 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_interpose_flow_get_locked";
        _os_log_impl(&dword_1830D4000, v15, v31, "%{public}s called with null flow, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_56:

    goto LABEL_57;
  }
  *(void *)buf = 0;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x3032000000;
  int v40 = __Block_byref_object_copy__64137;
  objc_super v41 = __Block_byref_object_dispose__64138;
  id v42 = 0;
  v34[0] = MEMORY[0x1E4F143A8];
  v34[1] = 3221225472;
  v34[2] = ___ZL28nw_interpose_flow_get_lockedP23NWConcrete_nw_interposePU26objcproto15OS_nw_path_flow8NSObject_block_invoke;
  v34[3] = &unk_1E524A1A8;
  id v9 = v6;
  id v35 = v9;
  BOOL v36 = buf;
  nw_dictionary_apply(v8, (uint64_t)v34);
  __int16 v10 = *(id *)(*(void *)&buf[8] + 40);

  _Block_object_dispose(buf, 8);
  if (v10)
  {
    [v10 resetFlow:v9];
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v11 = (id)gLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v12 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_interpose_handle_path_update_locked_block_invoke";
      *(_WORD *)&buf[12] = 2114;
      *(void *)&buf[14] = v12;
      _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_DEBUG, "%{public}s [%{public}@] updated flow", buf, 0x16u);
    }

    goto LABEL_62;
  }
LABEL_60:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  __int16 v10 = (id)gLogObj;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    uint64_t v32 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_interpose_handle_path_update_locked_block_invoke";
    *(_WORD *)&buf[12] = 2114;
    *(void *)&buf[14] = v32;
    _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_ERROR, "%{public}s [%{public}@] failed to find flowObj", buf, 0x16u);
  }
LABEL_62:

  return 1;
}

void sub_183B736B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__64137(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__64138(uint64_t a1)
{
}

uint64_t ___ZL28nw_interpose_flow_get_lockedP23NWConcrete_nw_interposePU26objcproto15OS_nw_path_flow8NSObject_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  int v6 = [v5 matchNexusAgentWithFlow:*(void *)(a1 + 32)];
  if (v6) {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a3);
  }

  return v6 ^ 1u;
}

void sub_183B73758(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_interpose_cancel(void *a1)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  BOOL v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 2);
    id v3 = v2;
    uint64_t v4 = *(void *)&v3[12]._os_unfair_lock_opaque;
    if (v4)
    {
      nw_dictionary_apply(v4, (uint64_t)&__block_literal_global_64160);
LABEL_4:
      id v5 = *(void **)&v3[14]._os_unfair_lock_opaque;
      *(void *)&v3[14]._uint32_t os_unfair_lock_opaque = 0;

      int v6 = *(void **)&v3[10]._os_unfair_lock_opaque;
      if (v6)
      {
        nw_path_evaluator_cancel(v6);
        os_log_type_t v7 = *(void **)&v3[10]._os_unfair_lock_opaque;
        *(void *)&v3[10]._uint32_t os_unfair_lock_opaque = 0;
      }
      os_unfair_lock_unlock(v2 + 2);
      goto LABEL_7;
    }
    uint64_t v12 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v27 = "nw_interpose_flow_clear_handlers_locked";
    uint64_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (__nwlog_fault(v13, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v14 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v27 = "nw_interpose_flow_clear_handlers_locked";
          _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s called with null interpose->flows", buf, 0xCu);
        }
      }
      else if (v24)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v14 = __nwlog_obj();
        os_log_type_t v20 = type;
        BOOL v21 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v21)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v27 = "nw_interpose_flow_clear_handlers_locked";
            __int16 v28 = 2082;
            os_log_type_t v29 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v14, v20, "%{public}s called with null interpose->flows, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_42;
        }
        if (v21)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v27 = "nw_interpose_flow_clear_handlers_locked";
          _os_log_impl(&dword_1830D4000, v14, v20, "%{public}s called with null interpose->flows, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v14 = __nwlog_obj();
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v27 = "nw_interpose_flow_clear_handlers_locked";
          _os_log_impl(&dword_1830D4000, v14, v23, "%{public}s called with null interpose->flows, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_42:
    if (v13) {
      free(v13);
    }
    goto LABEL_4;
  }
  uint64_t v8 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v27 = "nw_interpose_cancel";
  id v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v24 = 0;
  if (__nwlog_fault(v9, &type, &v24))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v27 = "nw_interpose_cancel";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null interpose", buf, 0xCu);
      }
    }
    else if (v24)
    {
      os_log_type_t v16 = (char *)__nw_create_backtrace_string();
      __int16 v10 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v10, type);
      if (v16)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v27 = "nw_interpose_cancel";
          __int16 v28 = 2082;
          os_log_type_t v29 = v16;
          _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s called with null interpose, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v16);
        goto LABEL_37;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v27 = "nw_interpose_cancel";
        _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s called with null interpose, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __int16 v10 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v27 = "nw_interpose_cancel";
        _os_log_impl(&dword_1830D4000, v10, v22, "%{public}s called with null interpose, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_37:
  if (v9) {
    free(v9);
  }
LABEL_7:
}

void sub_183B73C5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL39nw_interpose_flow_clear_handlers_lockedP23NWConcrete_nw_interpose_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  return 1;
}

void __nw_http_cookie_storage_copy_shared_block_invoke()
{
  v0 = objc_alloc_init(NWConcrete_nw_http_cookie_storage);
  BOOL v1 = (void *)nw_http_cookie_storage_copy_shared_storage;
  nw_http_cookie_storage_copy_shared_storage = (uint64_t)v0;

  uint64_t v2 = [MEMORY[0x1E4F18D30] sharedHTTPCookieStorage];
  id v3 = *(void **)(nw_http_cookie_storage_copy_shared_storage + 8);
  *(void *)(nw_http_cookie_storage_copy_shared_storage + 8) = v2;
}

NWConcrete_nw_http_cookie_storage *nw_http_cookie_storage_create_ns(void *a1)
{
  BOOL v1 = a1;
  uint64_t v2 = objc_alloc_init(NWConcrete_nw_http_cookie_storage);
  cookieStorage = v2->cookieStorage;
  v2->cookieStorage = v1;

  return v2;
}

void __nw_http_cookie_enumerate_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  uint64_t v4 = v3;
  if (v3)
  {
    long long v14 = 0u;
    long long v15 = 0u;
    long long v12 = 0u;
    long long v13 = 0u;
    uint64_t v5 = [v3 countByEnumeratingWithState:&v12 objects:v16 count:16];
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)v13;
      do
      {
        for (uint64_t i = 0; i != v6; ++i)
        {
          if (*(void *)v13 != v7) {
            objc_enumerationMutation(v4);
          }
          id v9 = *(void **)(*((void *)&v12 + 1) + 8 * i);
          __int16 v10 = [v9 name];
          os_log_type_t v11 = [v9 value];
          (*(void (**)(void, uint64_t, uint64_t))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), [v10 UTF8String], objc_msgSend(v11, "UTF8String"));
        }
        uint64_t v6 = [v4 countByEnumeratingWithState:&v12 objects:v16 count:16];
      }
      while (v6);
    }
  }
}

uint64_t __nw_http_cookie_parse_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = (void *)[[NSString alloc] initWithBytes:a4 length:a5 encoding:5];
  if (*(void *)(a1 + 40))
  {
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:");
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v8 = [MEMORY[0x1E4F18D28] _cookieForSetCookieString:v6 forURL:*(void *)(a1 + 48) partition:v7];
  if (v8) {
    [*(id *)(a1 + 32) addObject:v8];
  }

  return 1;
}

void nw_tcp_deallocate_globals(uint64_t a1, void *a2)
{
  nw_tcp_destroy_globals();
  if (a2)
  {
    free(a2);
  }
}

void nw_tcp_options_set_reduce_buffering(void *a1, char a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (nw_protocol_options_is_tcp(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_set_reduce_buffering_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    char v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  uint64_t v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_tcp_options_set_reduce_buffering";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_reduce_buffering";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v17 = "nw_tcp_options_set_reduce_buffering";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_reduce_buffering";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_reduce_buffering";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183B74290(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_set_reduce_buffering_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_WORD *)(a2 + 36) = *(_WORD *)(a2 + 36) & 0xFFFE | *(unsigned __int8 *)(a1 + 32);
  return 1;
}

void nw_tcp_options_set_no_timewait(void *a1, char a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (nw_protocol_options_is_tcp(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_set_no_timewait_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    char v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  uint64_t v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_tcp_options_set_no_timewait";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_no_timewait";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v17 = "nw_tcp_options_set_no_timewait";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_no_timewait";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_no_timewait";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183B745A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_set_no_timewait_block_invoke(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int16 *)(a2 + 36);
  uint64_t v2 = a2 + 36;
  unsigned int v4 = v3 & 0xFFFFFFFB | (*(unsigned __int8 *)(v2 + 2) << 16);
  *(_WORD *)uint64_t v2 = v3 & 0xFFFB | (4 * (*(unsigned char *)(a1 + 32) & 0x3F));
  *(unsigned char *)(v2 + 2) = BYTE2(v4);
  return 1;
}

void nw_tcp_options_set_no_push(nw_protocol_options_t options, BOOL no_push)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  int v3 = options;
  if (nw_protocol_options_is_tcp(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_set_no_push_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    BOOL v13 = no_push;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  unsigned int v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_tcp_options_set_no_push";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_no_push";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v17 = "nw_tcp_options_set_no_push";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_no_push";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_no_push";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183B748D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_set_no_push_block_invoke(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int16 *)(a2 + 36);
  uint64_t v2 = a2 + 36;
  unsigned int v4 = v3 & 0xFFFFFFF7 | (*(unsigned __int8 *)(v2 + 2) << 16);
  *(_WORD *)uint64_t v2 = v3 & 0xFFF7 | (8 * (*(unsigned char *)(a1 + 32) & 0x1F));
  *(unsigned char *)(v2 + 2) = BYTE2(v4);
  return 1;
}

void nw_tcp_options_set_no_options(nw_protocol_options_t options, BOOL no_options)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  int v3 = options;
  if (nw_protocol_options_is_tcp(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_set_no_options_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    BOOL v13 = no_options;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  unsigned int v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_tcp_options_set_no_options";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_no_options";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v17 = "nw_tcp_options_set_no_options";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_no_options";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_no_options";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183B74C00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_set_no_options_block_invoke(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int16 *)(a2 + 36);
  uint64_t v2 = a2 + 36;
  unsigned int v4 = v3 & 0xFFFFFFEF | (*(unsigned __int8 *)(v2 + 2) << 16);
  *(_WORD *)uint64_t v2 = v3 & 0xFFEF | (16 * (*(unsigned char *)(a1 + 32) & 0xF));
  *(unsigned char *)(v2 + 2) = BYTE2(v4);
  return 1;
}

void nw_tcp_options_set_enable_keepalive(nw_protocol_options_t options, BOOL enable_keepalive)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  int v3 = options;
  if (nw_protocol_options_is_tcp(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_set_enable_keepalive_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    BOOL v13 = enable_keepalive;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  unsigned int v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_tcp_options_set_enable_keepalive";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_enable_keepalive";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v17 = "nw_tcp_options_set_enable_keepalive";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_enable_keepalive";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_enable_keepalive";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183B74F2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_set_enable_keepalive_block_invoke(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int16 *)(a2 + 36);
  uint64_t v2 = a2 + 36;
  unsigned int v4 = v3 & 0xFFFFFFDF | (*(unsigned __int8 *)(v2 + 2) << 16);
  *(_WORD *)uint64_t v2 = v3 & 0xFFDF | (32 * (*(unsigned char *)(a1 + 32) & 7));
  *(unsigned char *)(v2 + 2) = BYTE2(v4);
  return 1;
}

void nw_tcp_options_set_enable_keepalive_offload(void *a1, char a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (nw_protocol_options_is_tcp(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_set_enable_keepalive_offload_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    char v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  unsigned int v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_tcp_options_set_enable_keepalive_offload";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_enable_keepalive_offload";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v17 = "nw_tcp_options_set_enable_keepalive_offload";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_enable_keepalive_offload";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_enable_keepalive_offload";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183B75258(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_set_enable_keepalive_offload_block_invoke(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int16 *)(a2 + 36);
  uint64_t v2 = a2 + 36;
  unsigned int v4 = v3 & 0xFFFFFFBF | (*(unsigned __int8 *)(v2 + 2) << 16);
  *(_WORD *)uint64_t v2 = v3 & 0xFFBF | ((*(unsigned char *)(a1 + 32) & 3) << 6);
  *(unsigned char *)(v2 + 2) = BYTE2(v4);
  return 1;
}

void nw_tcp_options_set_disable_ack_stretching(nw_protocol_options_t options, BOOL disable_ack_stretching)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  int v3 = options;
  if (nw_protocol_options_is_tcp(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_set_disable_ack_stretching_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    BOOL v13 = disable_ack_stretching;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  unsigned int v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_tcp_options_set_disable_ack_stretching";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_disable_ack_stretching";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v17 = "nw_tcp_options_set_disable_ack_stretching";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_disable_ack_stretching";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_disable_ack_stretching";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183B75584(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_set_disable_ack_stretching_block_invoke(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int16 *)(a2 + 36);
  uint64_t v2 = a2 + 36;
  unsigned int v4 = v3 & 0xFFFFFF7F | (*(unsigned __int8 *)(v2 + 2) << 16);
  *(_WORD *)uint64_t v2 = v3 & 0xFF7F | ((*(unsigned char *)(a1 + 32) & 1) << 7);
  *(unsigned char *)(v2 + 2) = BYTE2(v4);
  return 1;
}

void nw_tcp_options_set_disable_blackhole_detection(void *a1, char a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (nw_protocol_options_is_tcp(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_set_disable_blackhole_detection_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    char v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  unsigned int v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_tcp_options_set_disable_blackhole_detection";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_disable_blackhole_detection";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v17 = "nw_tcp_options_set_disable_blackhole_detection";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_disable_blackhole_detection";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_disable_blackhole_detection";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183B758B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_set_disable_blackhole_detection_block_invoke(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int16 *)(a2 + 36);
  uint64_t v2 = a2 + 36;
  unsigned int v4 = v3 & 0xFFFFFEFF | (*(unsigned __int8 *)(v2 + 2) << 16);
  *(_WORD *)uint64_t v2 = v3 & 0xFEFF | (*(unsigned __int8 *)(a1 + 32) << 8);
  *(unsigned char *)(v2 + 2) = BYTE2(v4);
  return 1;
}

void nw_tcp_options_set_enable_background_traffic_management(void *a1, char a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (nw_protocol_options_is_tcp(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_set_enable_background_traffic_management_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    char v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  unsigned int v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_tcp_options_set_enable_background_traffic_management";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_enable_background_traffic_management";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v17 = "nw_tcp_options_set_enable_background_traffic_management";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_enable_background_traffic_management";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_enable_background_traffic_management";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183B75BD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_set_enable_background_traffic_management_block_invoke(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int16 *)(a2 + 36);
  uint64_t v2 = a2 + 36;
  unsigned int v4 = v3 & 0xFFFFFDFF | (*(unsigned __int8 *)(v2 + 2) << 16) | (*(unsigned __int8 *)(a1 + 32) << 9);
  *(_WORD *)uint64_t v2 = v3 & 0xFDFF | (*(unsigned __int8 *)(a1 + 32) << 9);
  *(unsigned char *)(v2 + 2) = BYTE2(v4);
  return 1;
}

void nw_tcp_options_set_enable_fast_open(nw_protocol_options_t options, BOOL enable_fast_open)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  int v3 = options;
  if (nw_protocol_options_is_tcp(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_set_enable_fast_open_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    BOOL v13 = enable_fast_open;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  unsigned int v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_tcp_options_set_enable_fast_open";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_enable_fast_open";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v17 = "nw_tcp_options_set_enable_fast_open";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_enable_fast_open";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_enable_fast_open";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183B75F00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_set_enable_fast_open_block_invoke(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int16 *)(a2 + 36);
  uint64_t v2 = a2 + 36;
  unsigned int v4 = v3 & 0xFFFFF7FF | (*(unsigned __int8 *)(v2 + 2) << 16) | (*(unsigned __int8 *)(a1 + 32) << 11);
  *(_WORD *)uint64_t v2 = v3 & 0xF7FF | (*(unsigned __int8 *)(a1 + 32) << 11);
  *(unsigned char *)(v2 + 2) = BYTE2(v4);
  return 1;
}

void nw_tcp_options_set_no_fast_open_cookie(void *a1, char a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (nw_protocol_options_is_tcp(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_set_no_fast_open_cookie_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    char v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  unsigned int v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_tcp_options_set_no_fast_open_cookie";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_no_fast_open_cookie";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v17 = "nw_tcp_options_set_no_fast_open_cookie";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_no_fast_open_cookie";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_no_fast_open_cookie";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183B76228(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_set_no_fast_open_cookie_block_invoke(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int16 *)(a2 + 36);
  uint64_t v2 = a2 + 36;
  unsigned int v4 = v3 & 0xFFFFDFFF | (*(unsigned __int8 *)(v2 + 2) << 16) | (*(unsigned __int8 *)(a1 + 32) << 13);
  *(_WORD *)uint64_t v2 = v3 & 0xDFFF | (*(unsigned __int8 *)(a1 + 32) << 13);
  *(unsigned char *)(v2 + 2) = BYTE2(v4);
  return 1;
}

BOOL nw_tcp_options_get_no_fast_open_cookie(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000;
    char v16 = 0;
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_no_fast_open_cookie_block_invoke;
    v12[3] = &unk_1E5248E90;
    void v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    BOOL v2 = *(unsigned char *)(*(void *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  unsigned int v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_tcp_options_get_no_fast_open_cookie";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_no_fast_open_cookie";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcp_options_get_no_fast_open_cookie";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_no_fast_open_cookie";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_no_fast_open_cookie";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
  BOOL v2 = 0;
LABEL_3:

  return v2;
}

void sub_183B76588(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_get_no_fast_open_cookie_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (*(_WORD *)(a2 + 36) & 0x2000) != 0;
  return 1;
}

void nw_tcp_options_set_fast_open_force_enable(void *a1, char a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (nw_protocol_options_is_tcp(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_set_fast_open_force_enable_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    char v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  unsigned int v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_tcp_options_set_fast_open_force_enable";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_fast_open_force_enable";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v17 = "nw_tcp_options_set_fast_open_force_enable";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_fast_open_force_enable";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_fast_open_force_enable";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183B768B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_set_fast_open_force_enable_block_invoke(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int16 *)(a2 + 36);
  uint64_t v2 = a2 + 36;
  unsigned int v4 = v3 & 0xFFFFBFFF | (*(unsigned __int8 *)(v2 + 2) << 16) | (*(unsigned __int8 *)(a1 + 32) << 14);
  *(_WORD *)uint64_t v2 = v3 & 0xBFFF | (*(unsigned __int8 *)(a1 + 32) << 14);
  *(unsigned char *)(v2 + 2) = BYTE2(v4);
  return 1;
}

void nw_tcp_options_set_retransmit_fin_drop(nw_protocol_options_t options, BOOL retransmit_fin_drop)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  int v3 = options;
  if (nw_protocol_options_is_tcp(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_set_retransmit_fin_drop_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    BOOL v13 = retransmit_fin_drop;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  unsigned int v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_tcp_options_set_retransmit_fin_drop";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_retransmit_fin_drop";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v17 = "nw_tcp_options_set_retransmit_fin_drop";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_retransmit_fin_drop";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_retransmit_fin_drop";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183B76BDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_set_retransmit_fin_drop_block_invoke(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int16 *)(a2 + 36);
  uint64_t v2 = a2 + 36;
  unsigned int v4 = v3 & 0xFFFFFBFF | (*(unsigned __int8 *)(v2 + 2) << 16) | (*(unsigned __int8 *)(a1 + 32) << 10);
  *(_WORD *)uint64_t v2 = v3 & 0xFBFF | (*(unsigned __int8 *)(a1 + 32) << 10);
  *(unsigned char *)(v2 + 2) = BYTE2(v4);
  return 1;
}

void nw_tcp_options_set_disable_ecn(nw_protocol_options_t options, BOOL disable_ecn)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  int v3 = options;
  if (nw_protocol_options_is_tcp(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_set_disable_ecn_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    BOOL v13 = disable_ecn;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  unsigned int v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_tcp_options_set_disable_ecn";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_disable_ecn";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v17 = "nw_tcp_options_set_disable_ecn";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_disable_ecn";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_disable_ecn";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183B76F04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_set_disable_ecn_block_invoke(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int16 *)(a2 + 36);
  uint64_t v2 = a2 + 36;
  unsigned int v4 = v3 & 0xFFFF7FFF | (*(unsigned __int8 *)(v2 + 2) << 16) | (*(unsigned __int8 *)(a1 + 32) << 15);
  *(_WORD *)uint64_t v2 = v3 & 0x7FFF | (*(unsigned __int8 *)(a1 + 32) << 15);
  *(unsigned char *)(v2 + 2) = BYTE2(v4);
  return 1;
}

void nw_tcp_options_set_reset_local_port(void *a1, char a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (nw_protocol_options_is_tcp(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_set_reset_local_port_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    char v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  unsigned int v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_tcp_options_set_reset_local_port";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_reset_local_port";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v17 = "nw_tcp_options_set_reset_local_port";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_reset_local_port";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_reset_local_port";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183B7722C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_set_reset_local_port_block_invoke(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int16 *)(a2 + 36);
  uint64_t v2 = a2 + 36;
  unsigned int v4 = (v3 | (*(unsigned __int8 *)(v2 + 2) << 16)) & 0xFFFEFFFF | (*(unsigned __int8 *)(a1 + 32) << 16);
  *(_WORD *)uint64_t v2 = v3;
  *(unsigned char *)(v2 + 2) = BYTE2(v4);
  return 1;
}

void nw_tcp_options_set_maximum_segment_size(nw_protocol_options_t options, uint32_t maximum_segment_size)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  int v3 = options;
  if (nw_protocol_options_is_tcp(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_set_maximum_segment_size_block_invoke;
    v12[3] = &__block_descriptor_36_e9_B16__0_v8l;
    uint32_t v13 = maximum_segment_size;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  unsigned int v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_tcp_options_set_maximum_segment_size";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_maximum_segment_size";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v17 = "nw_tcp_options_set_maximum_segment_size";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_maximum_segment_size";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_maximum_segment_size";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183B77554(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_set_maximum_segment_size_block_invoke(uint64_t a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 32);
  return 1;
}

void nw_tcp_options_set_connection_timeout(nw_protocol_options_t options, uint32_t connection_timeout)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  int v3 = options;
  if (nw_protocol_options_is_tcp(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_set_connection_timeout_block_invoke;
    v12[3] = &__block_descriptor_36_e9_B16__0_v8l;
    uint32_t v13 = connection_timeout;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  unsigned int v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_tcp_options_set_connection_timeout";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_connection_timeout";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v17 = "nw_tcp_options_set_connection_timeout";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_connection_timeout";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_connection_timeout";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183B77860(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_set_connection_timeout_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 32);
  return 1;
}

void nw_tcp_options_set_persist_timeout(nw_protocol_options_t options, uint32_t persist_timeout)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  int v3 = options;
  if (nw_protocol_options_is_tcp(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_set_persist_timeout_block_invoke;
    v12[3] = &__block_descriptor_36_e9_B16__0_v8l;
    uint32_t v13 = persist_timeout;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  unsigned int v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_tcp_options_set_persist_timeout";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_persist_timeout";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v17 = "nw_tcp_options_set_persist_timeout";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_persist_timeout";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_persist_timeout";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183B77B6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_set_persist_timeout_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 32);
  return 1;
}

void nw_tcp_options_set_retransmit_connection_drop_time(nw_protocol_options_t options, uint32_t retransmit_connection_drop_time)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  int v3 = options;
  if (nw_protocol_options_is_tcp(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_set_retransmit_connection_drop_time_block_invoke;
    v12[3] = &__block_descriptor_36_e9_B16__0_v8l;
    uint32_t v13 = retransmit_connection_drop_time;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  unsigned int v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_tcp_options_set_retransmit_connection_drop_time";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_retransmit_connection_drop_time";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v17 = "nw_tcp_options_set_retransmit_connection_drop_time";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_retransmit_connection_drop_time";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_retransmit_connection_drop_time";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183B77E78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_set_retransmit_connection_drop_time_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 12) = *(_DWORD *)(a1 + 32);
  return 1;
}

void nw_tcp_options_set_keepalive_count(nw_protocol_options_t options, uint32_t keepalive_count)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  int v3 = options;
  if (nw_protocol_options_is_tcp(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_set_keepalive_count_block_invoke;
    v12[3] = &__block_descriptor_36_e9_B16__0_v8l;
    uint32_t v13 = keepalive_count;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  unsigned int v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_tcp_options_set_keepalive_count";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_keepalive_count";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v17 = "nw_tcp_options_set_keepalive_count";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_keepalive_count";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_keepalive_count";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183B78184(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_set_keepalive_count_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 32);
  return 1;
}

uint64_t nw_tcp_options_get_keepalive_count(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    int v16 = 0;
    *(void *)&buf[16] = 0x2020000000;
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_keepalive_count_block_invoke;
    v12[3] = &unk_1E5248E90;
    void v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    uint64_t v2 = *(unsigned int *)(*(void *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  unsigned int v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_tcp_options_get_keepalive_count";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_keepalive_count";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcp_options_get_keepalive_count";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_keepalive_count";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_keepalive_count";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
  uint64_t v2 = 0;
LABEL_3:

  return v2;
}

void sub_183B784C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_get_keepalive_count_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(_DWORD *)(a2 + 24);
  return 1;
}

void nw_tcp_options_set_keepalive_idle_time(nw_protocol_options_t options, uint32_t keepalive_idle_time)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  int v3 = options;
  if (nw_protocol_options_is_tcp(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_set_keepalive_idle_time_block_invoke;
    v12[3] = &__block_descriptor_36_e9_B16__0_v8l;
    uint32_t v13 = keepalive_idle_time;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  unsigned int v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_tcp_options_set_keepalive_idle_time";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_keepalive_idle_time";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v17 = "nw_tcp_options_set_keepalive_idle_time";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_keepalive_idle_time";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_keepalive_idle_time";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183B787E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_set_keepalive_idle_time_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 32);
  return 1;
}

uint64_t nw_tcp_options_get_keepalive_idle_time(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    int v16 = 0;
    *(void *)&buf[16] = 0x2020000000;
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_keepalive_idle_time_block_invoke;
    v12[3] = &unk_1E5248E90;
    void v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    uint64_t v2 = *(unsigned int *)(*(void *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  unsigned int v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_tcp_options_get_keepalive_idle_time";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_keepalive_idle_time";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcp_options_get_keepalive_idle_time";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_keepalive_idle_time";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_keepalive_idle_time";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
  uint64_t v2 = 0;
LABEL_3:

  return v2;
}

void sub_183B78B24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_get_keepalive_idle_time_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(_DWORD *)(a2 + 16);
  return 1;
}

void nw_tcp_options_set_keepalive_interval(nw_protocol_options_t options, uint32_t keepalive_interval)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  int v3 = options;
  if (nw_protocol_options_is_tcp(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_set_keepalive_interval_block_invoke;
    v12[3] = &__block_descriptor_36_e9_B16__0_v8l;
    uint32_t v13 = keepalive_interval;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  unsigned int v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_tcp_options_set_keepalive_interval";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_keepalive_interval";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v17 = "nw_tcp_options_set_keepalive_interval";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_keepalive_interval";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_keepalive_interval";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183B78E4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_set_keepalive_interval_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 20) = *(_DWORD *)(a1 + 32);
  return 1;
}

uint64_t nw_tcp_options_get_keepalive_interval(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    int v16 = 0;
    *(void *)&buf[16] = 0x2020000000;
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_keepalive_interval_block_invoke;
    v12[3] = &unk_1E5248E90;
    void v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    uint64_t v2 = *(unsigned int *)(*(void *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  unsigned int v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_tcp_options_get_keepalive_interval";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_keepalive_interval";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcp_options_get_keepalive_interval";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_keepalive_interval";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_keepalive_interval";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
  uint64_t v2 = 0;
LABEL_3:

  return v2;
}

void sub_183B79188(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_get_keepalive_interval_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(_DWORD *)(a2 + 20);
  return 1;
}

void nw_tcp_options_set_multipath_force_version(nw_protocol_options_t options, nw_multipath_version_t multipath_force_version)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  int v3 = options;
  if (nw_protocol_options_is_tcp(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_set_multipath_force_version_block_invoke;
    v12[3] = &__block_descriptor_36_e9_B16__0_v8l;
    nw_multipath_version_t v13 = multipath_force_version;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  unsigned int v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_tcp_options_set_multipath_force_version";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_multipath_force_version";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v17 = "nw_tcp_options_set_multipath_force_version";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_multipath_force_version";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_multipath_force_version";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183B794B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_set_multipath_force_version_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 28) = *(_DWORD *)(a1 + 32);
  return 1;
}

uint64_t nw_tcp_options_get_multipath_force_version(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    int v16 = 0;
    *(void *)&buf[16] = 0x2020000000;
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_multipath_force_version_block_invoke;
    v12[3] = &unk_1E5248E90;
    void v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    uint64_t v2 = *(unsigned int *)(*(void *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  unsigned int v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_tcp_options_get_multipath_force_version";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_multipath_force_version";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcp_options_get_multipath_force_version";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_multipath_force_version";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_multipath_force_version";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
  uint64_t v2 = 0;
LABEL_3:

  return v2;
}

void sub_183B797EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_get_multipath_force_version_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(_DWORD *)(a2 + 28);
  return 1;
}

void nw_tcp_options_set_enable_l4s(void *a1, int a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (nw_protocol_options_is_tcp(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_set_enable_l4s_block_invoke;
    v12[3] = &__block_descriptor_36_e9_B16__0_v8l;
    int v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  unsigned int v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_tcp_options_set_enable_l4s";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_enable_l4s";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v17 = "nw_tcp_options_set_enable_l4s";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_enable_l4s";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_tcp_options_set_enable_l4s";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183B79B14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_set_enable_l4s_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(a1 + 32);
  return 1;
}

uint32_t nw_tcp_get_available_receive_buffer(nw_protocol_metadata_t metadata)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = metadata;
  if (nw_protocol_metadata_is_tcp(v1))
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    int v16 = 0;
    *(void *)&buf[16] = 0x2020000000;
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_get_available_receive_buffer_block_invoke;
    v12[3] = &unk_1E5248E90;
    void v12[4] = buf;
    nw_protocol_metadata_access_handle((uint64_t)v1, (uint64_t)v12);
    uint32_t v2 = *(_DWORD *)(*(void *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  unsigned int v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_tcp_get_available_receive_buffer";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_get_available_receive_buffer";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcp_get_available_receive_buffer";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_get_available_receive_buffer";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_get_available_receive_buffer";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
  uint32_t v2 = 0;
LABEL_3:

  return v2;
}

void sub_183B79E50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_get_available_receive_buffer_block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = (os_unfair_lock_s *)(a2 + 56);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 56));
  if (*(void *)a2) {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (*(uint64_t (**)(void))a2)(*(void *)(a2 + 48));
  }
  os_unfair_lock_unlock(v4);
  return 1;
}

uint32_t nw_tcp_get_available_send_buffer(nw_protocol_metadata_t metadata)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = metadata;
  if (nw_protocol_metadata_is_tcp(v1))
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    int v16 = 0;
    *(void *)&buf[16] = 0x2020000000;
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_get_available_send_buffer_block_invoke;
    v12[3] = &unk_1E5248E90;
    void v12[4] = buf;
    nw_protocol_metadata_access_handle((uint64_t)v1, (uint64_t)v12);
    uint32_t v2 = *(_DWORD *)(*(void *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  unsigned int v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_tcp_get_available_send_buffer";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_get_available_send_buffer";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcp_get_available_send_buffer";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_get_available_send_buffer";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_get_available_send_buffer";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
  uint32_t v2 = 0;
LABEL_3:

  return v2;
}

void sub_183B7A1F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_get_available_send_buffer_block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = (os_unfair_lock_s *)(a2 + 56);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 56));
  uint64_t v5 = *(uint64_t (**)(void))(a2 + 8);
  if (v5) {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v5(*(void *)(a2 + 48));
  }
  os_unfair_lock_unlock(v4);
  return 1;
}

uint64_t nw_tcp_reset_keepalives(void *a1, char a2, int a3, int a4, int a5)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  os_log_type_t v9 = a1;
  if (nw_protocol_metadata_is_tcp(v9))
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    int v28 = 0;
    *(void *)&buf[16] = 0x2020000000;
    v20[0] = MEMORY[0x1E4F143A8];
    v20[1] = 3221225472;
    void v20[2] = __nw_tcp_reset_keepalives_block_invoke;
    v20[3] = &unk_1E5247B80;
    v20[4] = buf;
    char v24 = a2;
    int v21 = a3;
    int v22 = a4;
    int v23 = a5;
    nw_protocol_metadata_access_handle((uint64_t)v9, (uint64_t)v20);
    uint64_t v10 = *(unsigned int *)(*(void *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  long long v12 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_tcp_reset_keepalives";
  char v13 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v25 = 0;
  if (__nwlog_fault(v13, &type, &v25))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_reset_keepalives";
        _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata)", buf, 0xCu);
      }
    }
    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v14 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcp_reset_keepalives";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_reset_keepalives";
        _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      char v14 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_reset_keepalives";
        _os_log_impl(&dword_1830D4000, v14, v19, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v13) {
    free(v13);
  }
  uint64_t v10 = 22;
LABEL_3:

  return v10;
}

void sub_183B7A5AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_reset_keepalives_block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = (os_unfair_lock_s *)(a2 + 56);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 56));
  uint64_t v5 = *(uint64_t (**)(void, void, void, void, void))(a2 + 16);
  if (v5) {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v5(*(void *)(a2 + 48), *(unsigned __int8 *)(a1 + 52), *(unsigned int *)(a1 + 40), *(unsigned int *)(a1 + 44), *(unsigned int *)(a1 + 48));
  }
  os_unfair_lock_unlock(v4);
  return 1;
}

uint64_t nw_tcp_enable_nodelay(void *a1)
{
  return nw_tcp_set_no_delay(a1, 1);
}

uint64_t nw_tcp_set_no_delay(void *a1, char a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (nw_protocol_metadata_is_tcp(v3))
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    int v19 = 0;
    *(void *)&buf[16] = 0x2020000000;
    v14[0] = MEMORY[0x1E4F143A8];
    v14[1] = 3221225472;
    v14[2] = __nw_tcp_set_no_delay_block_invoke;
    v14[3] = &unk_1E5247BA8;
    void v14[4] = buf;
    char v15 = a2;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v14);
    uint64_t v4 = *(unsigned int *)(*(void *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  uint64_t v6 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_tcp_set_no_delay";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v7, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_set_no_delay";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata)", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcp_set_no_delay";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_set_no_delay";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_set_no_delay";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v7) {
    free(v7);
  }
  uint64_t v4 = 22;
LABEL_3:

  return v4;
}

void sub_183B7A968(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_set_no_delay_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(a2 + 56);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 56));
  uint64_t v5 = *(uint64_t (**)(void, void))(a2 + 24);
  if (v5) {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v5(*(void *)(a2 + 48), *(unsigned __int8 *)(a1 + 40));
  }
  os_unfair_lock_unlock(v4);
  return 1;
}

uint64_t nw_tcp_set_no_push(void *a1, char a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (nw_protocol_metadata_is_tcp(v3))
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    int v19 = 0;
    *(void *)&buf[16] = 0x2020000000;
    v14[0] = MEMORY[0x1E4F143A8];
    v14[1] = 3221225472;
    v14[2] = __nw_tcp_set_no_push_block_invoke;
    v14[3] = &unk_1E5247BA8;
    void v14[4] = buf;
    char v15 = a2;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v14);
    uint64_t v4 = *(unsigned int *)(*(void *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  uint64_t v6 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_tcp_set_no_push";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v7, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_set_no_push";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata)", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcp_set_no_push";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_set_no_push";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_set_no_push";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v7) {
    free(v7);
  }
  uint64_t v4 = 22;
LABEL_3:

  return v4;
}

void sub_183B7AD14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_set_no_push_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(a2 + 56);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 56));
  uint64_t v5 = *(uint64_t (**)(void, void))(a2 + 32);
  if (v5) {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v5(*(void *)(a2 + 48), *(unsigned __int8 *)(a1 + 40));
  }
  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_mem_buffer_manager_close(void *a1)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v20 = "nw_mem_buffer_manager_close";
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (!__nwlog_fault(v10, &type, &v17)) {
      goto LABEL_36;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v20 = "nw_mem_buffer_manager_close";
      os_log_type_t v13 = "%{public}s called with null buffer_manager";
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v16 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v20 = "nw_mem_buffer_manager_close";
          __int16 v21 = 2082;
          int v22 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null buffer_manager, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_36;
      }
      if (!v16)
      {
LABEL_36:
        if (v10) {
          free(v10);
        }
        return;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v20 = "nw_mem_buffer_manager_close";
      os_log_type_t v13 = "%{public}s called with null buffer_manager, no backtrace";
    }
    else
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v20 = "nw_mem_buffer_manager_close";
      os_log_type_t v13 = "%{public}s called with null buffer_manager, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v11, v12, v13, buf, 0xCu);
    goto LABEL_36;
  }
  uint32_t v2 = (void *)a1[11];
  if (v2)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&nw_mem_cache_lock);
    uint64_t v3 = v2[10];
    uint64_t v4 = (void *)v2[11];
    if (v3)
    {
      *(void *)(v3 + 88) = v4;
      uint64_t v4 = (void *)v2[11];
    }
    else
    {
      qword_1EB267328 = v2[11];
    }
    *uint64_t v4 = v3;
    os_unfair_lock_unlock((os_unfair_lock_t)&nw_mem_cache_lock);
    nw_mem_cache_magazine_purge((uint64_t)v2);
    if (v2[1])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
      uint64_t v5 = v2[1];
      *(_DWORD *)buf = 136446978;
      uint64_t v20 = "nw_mem_cache_destroy";
      __int16 v21 = 2082;
      int v22 = (char *)(v2 + 12);
      __int16 v23 = 2048;
      char v24 = v2;
      __int16 v25 = 2048;
      uint64_t v26 = v5;
      uint64_t v6 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_abort((uint64_t)v6))
      {
        __break(1u);
        return;
      }
      free(v6);
    }
    v2[23] = -1;
    v2[24] = -1;
    v2[25] = 0;
    os_log_type_t v7 = (void *)v2[36];
    if (v7)
    {
      free(v7);
      v2[36] = 0;
    }
    if (gLogDatapath)
    {
      char v14 = __nwlog_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        uint64_t v20 = "nw_mem_cache_destroy";
        __int16 v21 = 2082;
        int v22 = (char *)(v2 + 12);
        __int16 v23 = 2048;
        char v24 = v2;
        _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_DEBUG, "%{public}s \"%{public}s\": nwm %p", buf, 0x20u);
      }
    }
    nw_mem_region_release(v2[27]);
    v2[27] = 0;
    uint64_t v8 = (void *)*(v2 - 1);
    if (v8) {
      malloc_zone_free((malloc_zone_t *)g_slab_zone, v8);
    }
    a1[11] = 0;
  }
  uint64_t v9 = a1[10];
  if (v9) {
    nw_mem_region_release(v9);
  }

  free(a1);
}

BOOL nw_protocol_http_early_data_create(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v21 = "nw_protocol_http_early_data_create";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v9, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v21 = "nw_protocol_http_early_data_create";
          os_log_type_t v12 = "%{public}s called with null parameters";
LABEL_27:
          _os_log_impl(&dword_1830D4000, v10, v11, v12, buf, 0xCu);
        }
      }
      else if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        BOOL v17 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v17)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v21 = "nw_protocol_http_early_data_create";
            __int16 v22 = 2082;
            uint64_t v23 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_28;
        }
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v21 = "nw_protocol_http_early_data_create";
          os_log_type_t v12 = "%{public}s called with null parameters, no backtrace";
          goto LABEL_27;
        }
      }
      else
      {
        uint64_t v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v21 = "nw_protocol_http_early_data_create";
          os_log_type_t v12 = "%{public}s called with null parameters, backtrace limit exceeded";
          goto LABEL_27;
        }
      }
    }
LABEL_28:
    if (v9) {
      free(v9);
    }
    return 0;
  }
  uint64_t v5 = malloc_type_calloc(1uLL, 0x108uLL, 0xEAFB8F1AuLL);
  if (v5) {
    goto LABEL_3;
  }
  os_log_type_t v13 = __nwlog_obj();
  os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  __int16 v21 = "strict_calloc";
  __int16 v22 = 2048;
  uint64_t v23 = 1;
  __int16 v24 = 2048;
  uint64_t v25 = 264;
  char v14 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v14);
  if (!result)
  {
    free(v14);
LABEL_3:
    v5[32] = 0;
    *((_OWORD *)v5 + 14) = 0u;
    *((_OWORD *)v5 + 15) = 0u;
    *((_OWORD *)v5 + 12) = 0u;
    *((_OWORD *)v5 + 13) = 0u;
    *((_OWORD *)v5 + 10) = 0u;
    *((_OWORD *)v5 + 11) = 0u;
    *((_OWORD *)v5 + 8) = 0u;
    *((_OWORD *)v5 + 9) = 0u;
    *((_OWORD *)v5 + 6) = 0u;
    *((_OWORD *)v5 + 7) = 0u;
    *((_OWORD *)v5 + 4) = 0u;
    *((_OWORD *)v5 + 5) = 0u;
    *((_OWORD *)v5 + 2) = 0u;
    *((_OWORD *)v5 + 3) = 0u;
    *(_OWORD *)uint64_t v5 = 0u;
    *((_OWORD *)v5 + 1) = 0u;
    if (gLogDatapath)
    {
      char v15 = __nwlog_obj();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        __int16 v21 = "nw_protocol_http_early_data_create";
        __int16 v22 = 2082;
        uint64_t v23 = (uint64_t)v5 + 114;
        __int16 v24 = 2080;
        uint64_t v25 = (uint64_t)" ";
        _os_log_impl(&dword_1830D4000, v15, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
      }
    }
    if (nw_protocol_http_early_data_identifier::onceToken != -1) {
      dispatch_once(&nw_protocol_http_early_data_identifier::onceToken, &__block_literal_global_64729);
    }
    void v5[2] = &nw_protocol_http_early_data_identifier::protocol_identifier;
    if (nw_protocol_http_early_data_get_callbacks(void)::onceToken != -1) {
      dispatch_once(&nw_protocol_http_early_data_get_callbacks(void)::onceToken, &__block_literal_global_6_64730);
    }
    v5[3] = &nw_protocol_http_early_data_get_callbacks(void)::protocol_callbacks;
    void v5[5] = v5;
    uint64_t v6 = a4;
    uint64_t v7 = v6[12];

    *((unsigned char *)v5 + 256) = v5[32] & 0xFE | ((v7 & 0x8000) != 0);
    v5[8] = v5 + 13;
    nw_protocol_plugin_name_set_callbacks((uint64_t)v5, (uint64_t)nw_protocol_http_early_data_create::$_0::__invoke);
    return (BOOL)v5;
  }
  __break(1u);
  return result;
}

uint64_t nw_protocol_http_early_data_create::$_0::__invoke(nw_protocol_http_early_data_create::$_0 *this, nw_protocol *a2, nw_protocol *a3)
{
  return 1;
}

void ___ZL41nw_protocol_http_early_data_get_callbacksv_block_invoke()
{
  nw_protocol_http_early_data_get_callbacks(void)::protocol_callbacks = (uint64_t)nw_protocol_common_add_input_handler;
  qword_1E8F7A160 = (uint64_t)nw_protocol_common_replace_input_handler;
  qword_1E8F7A1A0 = (uint64_t)nw_protocol_common_get_input_frames;
  qword_1E8F7A1C0 = (uint64_t)nw_protocol_common_get_parameters;
  qword_1E8F7A1C8 = (uint64_t)nw_protocol_common_get_path;
  qword_1E8F7A1D8 = (uint64_t)nw_protocol_common_get_remote_endpoint;
  qword_1E8F7A1D0 = (uint64_t)nw_protocol_common_get_local_endpoint;
  qword_1E8F7A218 = (uint64_t)nw_protocol_common_get_output_local_endpoint;
  qword_1E8F7A220 = (uint64_t)nw_protocol_common_get_output_interface;
  qword_1E8F7A168 = (uint64_t)nw_protocol_common_connect;
  qword_1E8F7A170 = (uint64_t)nw_protocol_common_disconnect;
  qword_1E8F7A190 = (uint64_t)nw_protocol_common_input_available;
  qword_1E8F7A208 = (uint64_t)nw_protocol_common_input_finished;
  qword_1E8F7A210 = (uint64_t)nw_protocol_common_output_finished;
  qword_1E8F7A258 = (uint64_t)nw_protocol_common_input_flush;
  qword_1E8F7A248 = (uint64_t)nw_protocol_common_get_message_properties;
  qword_1E8F7A230 = (uint64_t)nw_protocol_common_copy_info;
  qword_1E8F7A228 = (uint64_t)nw_protocol_common_waiting_for_output;
  qword_1E8F7A1E0 = (uint64_t)nw_protocol_common_register_notification;
  qword_1E8F7A1E8 = (uint64_t)nw_protocol_common_unregister_notification;
  qword_1E8F7A1F0 = (uint64_t)nw_protocol_common_notify;
  qword_1E8F7A1F8 = (uint64_t)nw_protocol_common_updated_path;
  qword_1E8F7A1B8 = (uint64_t)nw_protocol_common_link_state;
  qword_1E8F7A1A8 = (uint64_t)nw_protocol_http_early_data_get_output_frames;
  qword_1E8F7A1B0 = (uint64_t)nw_protocol_http_early_data_finalize_output_frames;
  qword_1E8F7A198 = (uint64_t)nw_protocol_http_early_data_output_available;
  qword_1E8F7A158 = (uint64_t)nw_protocol_http_early_data_remove_input_handler;
  qword_1E8F7A250 = (uint64_t)nw_protocol_http_early_data_reset;
  qword_1E8F7A178 = (uint64_t)nw_protocol_http_early_data_connected;
  qword_1E8F7A180 = (uint64_t)nw_protocol_http_early_data_disconnected;
  qword_1E8F7A188 = (uint64_t)nw_protocol_http_early_data_error;
  qword_1E8F7A200 = (uint64_t)nw_protocol_http_early_data_supports_external_data;
}

uint64_t nw_protocol_http_early_data_supports_external_data(nw_protocol *a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v15 = "nw_protocol_http_early_data_supports_external_data";
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (!__nwlog_fault(v4, &type, &v12)) {
      goto LABEL_34;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)buf = 136446210;
      char v15 = "nw_protocol_http_early_data_supports_external_data";
      uint64_t v7 = "%{public}s called with null protocol";
      goto LABEL_33;
    }
    if (!v12)
    {
      uint64_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)buf = 136446210;
      char v15 = "nw_protocol_http_early_data_supports_external_data";
      uint64_t v7 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_33;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v5 = __nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v9 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (!v9) {
        goto LABEL_34;
      }
      *(_DWORD *)buf = 136446210;
      char v15 = "nw_protocol_http_early_data_supports_external_data";
      uint64_t v7 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_33;
    }
    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      char v15 = "nw_protocol_http_early_data_supports_external_data";
      __int16 v16 = 2082;
      BOOL v17 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_34:
    if (!v4) {
      return 0;
    }
LABEL_35:
    free(v4);
    return 0;
  }
  uint64_t handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v15 = "nw_protocol_http_early_data_supports_external_data";
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (!__nwlog_fault(v4, &type, &v12)) {
      goto LABEL_34;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)buf = 136446210;
      char v15 = "nw_protocol_http_early_data_supports_external_data";
      uint64_t v7 = "%{public}s called with null http_early_data";
      goto LABEL_33;
    }
    if (!v12)
    {
      uint64_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)buf = 136446210;
      char v15 = "nw_protocol_http_early_data_supports_external_data";
      uint64_t v7 = "%{public}s called with null http_early_data, backtrace limit exceeded";
      goto LABEL_33;
    }
    uint64_t v10 = (char *)__nw_create_backtrace_string();
    uint64_t v5 = __nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v11 = os_log_type_enabled(v5, type);
    if (v10)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        char v15 = "nw_protocol_http_early_data_supports_external_data";
        __int16 v16 = 2082;
        BOOL v17 = v10;
        _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s called with null http_early_data, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v10);
      if (!v4) {
        return 0;
      }
      goto LABEL_35;
    }
    if (v11)
    {
      *(_DWORD *)buf = 136446210;
      char v15 = "nw_protocol_http_early_data_supports_external_data";
      uint64_t v7 = "%{public}s called with null http_early_data, no backtrace";
LABEL_33:
      _os_log_impl(&dword_1830D4000, v5, v6, v7, buf, 0xCu);
      goto LABEL_34;
    }
    goto LABEL_34;
  }
  uint64_t v2 = handle[6];

  return nw_protocol_supports_external_data(v2);
}

void nw_protocol_http_early_data_error(nw_protocol *a1, nw_protocol *a2, int a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v18 = "nw_protocol_http_early_data_error";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (!__nwlog_fault(v5, &type, &v15)) {
      goto LABEL_52;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v18 = "nw_protocol_http_early_data_error";
      uint64_t v8 = "%{public}s called with null protocol";
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v18 = "nw_protocol_http_early_data_error";
          __int16 v19 = 2082;
          uint64_t v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_52:
        if (!v5) {
          return;
        }
        goto LABEL_53;
      }
      if (!v10) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v18 = "nw_protocol_http_early_data_error";
      uint64_t v8 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      os_log_type_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v18 = "nw_protocol_http_early_data_error";
      uint64_t v8 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_51;
  }
  uint64_t handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v18 = "nw_protocol_http_early_data_error";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (!__nwlog_fault(v5, &type, &v15)) {
      goto LABEL_52;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v15)
      {
        os_log_type_t v6 = __nwlog_obj();
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_52;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v18 = "nw_protocol_http_early_data_error";
        uint64_t v8 = "%{public}s called with null http_early_data, backtrace limit exceeded";
        goto LABEL_51;
      }
      BOOL v11 = (char *)__nw_create_backtrace_string();
      os_log_type_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v12 = os_log_type_enabled(v6, type);
      if (!v11)
      {
        if (!v12) {
          goto LABEL_52;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v18 = "nw_protocol_http_early_data_error";
        uint64_t v8 = "%{public}s called with null http_early_data, no backtrace";
        goto LABEL_51;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v18 = "nw_protocol_http_early_data_error";
        __int16 v19 = 2082;
        uint64_t v20 = v11;
        os_log_type_t v13 = "%{public}s called with null http_early_data, dumping backtrace:%{public}s";
LABEL_36:
        _os_log_impl(&dword_1830D4000, v6, v7, v13, buf, 0x16u);
      }
LABEL_37:
      free(v11);
      if (!v5) {
        return;
      }
LABEL_53:
      free(v5);
      return;
    }
    os_log_type_t v6 = __nwlog_obj();
    os_log_type_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_52;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v18 = "nw_protocol_http_early_data_error";
    uint64_t v8 = "%{public}s called with null http_early_data";
LABEL_51:
    _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0xCu);
    goto LABEL_52;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v18 = "nw_protocol_http_early_data_error";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (!__nwlog_fault(v5, &type, &v15)) {
      goto LABEL_52;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v18 = "nw_protocol_http_early_data_error";
      uint64_t v8 = "%{public}s called with null other_protocol";
      goto LABEL_51;
    }
    if (!v15)
    {
      os_log_type_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v18 = "nw_protocol_http_early_data_error";
      uint64_t v8 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_51;
    }
    BOOL v11 = (char *)__nw_create_backtrace_string();
    os_log_type_t v6 = __nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v14 = os_log_type_enabled(v6, type);
    if (!v11)
    {
      if (!v14) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v18 = "nw_protocol_http_early_data_error";
      uint64_t v8 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_51;
    }
    if (v14)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v18 = "nw_protocol_http_early_data_error";
      __int16 v19 = 2082;
      uint64_t v20 = v11;
      os_log_type_t v13 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_36;
    }
    goto LABEL_37;
  }
  if (a3 == 35 && (handle[256] & 2) != 0)
  {
    handle[256] |= 0x10u;
    *((void *)handle + 31) = a2;
  }
  else
  {
    uint64_t v4 = (void *)*((void *)handle + 6);
    nw_protocol_error(v4, (uint64_t)a2);
  }
}

void nw_protocol_http_early_data_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v26 = "nw_protocol_http_early_data_disconnected";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v11, &type, &v23)) {
      goto LABEL_66;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_66;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v26 = "nw_protocol_http_early_data_disconnected";
      BOOL v14 = "%{public}s called with null protocol";
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v16 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v26 = "nw_protocol_http_early_data_disconnected";
          __int16 v27 = 2082;
          int v28 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_66:
        if (!v11) {
          return;
        }
        goto LABEL_67;
      }
      if (!v16) {
        goto LABEL_66;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v26 = "nw_protocol_http_early_data_disconnected";
      BOOL v14 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      BOOL v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_66;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v26 = "nw_protocol_http_early_data_disconnected";
      BOOL v14 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_65;
  }
  uint64_t handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v26 = "nw_protocol_http_early_data_disconnected";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v11, &type, &v23)) {
      goto LABEL_66;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v23)
      {
        BOOL v12 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (!os_log_type_enabled(v12, type)) {
          goto LABEL_66;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_protocol_http_early_data_disconnected";
        BOOL v14 = "%{public}s called with null http_early_data, backtrace limit exceeded";
        goto LABEL_65;
      }
      BOOL v17 = (char *)__nw_create_backtrace_string();
      BOOL v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v18 = os_log_type_enabled(v12, type);
      if (!v17)
      {
        if (!v18) {
          goto LABEL_66;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_protocol_http_early_data_disconnected";
        BOOL v14 = "%{public}s called with null http_early_data, no backtrace";
        goto LABEL_65;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v26 = "nw_protocol_http_early_data_disconnected";
        __int16 v27 = 2082;
        int v28 = v17;
        __int16 v19 = "%{public}s called with null http_early_data, dumping backtrace:%{public}s";
LABEL_48:
        _os_log_impl(&dword_1830D4000, v12, v13, v19, buf, 0x16u);
      }
LABEL_49:
      free(v17);
      if (!v11) {
        return;
      }
LABEL_67:
      free(v11);
      return;
    }
    BOOL v12 = __nwlog_obj();
    os_log_type_t v13 = type;
    if (!os_log_type_enabled(v12, type)) {
      goto LABEL_66;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v26 = "nw_protocol_http_early_data_disconnected";
    BOOL v14 = "%{public}s called with null http_early_data";
LABEL_65:
    _os_log_impl(&dword_1830D4000, v12, v13, v14, buf, 0xCu);
    goto LABEL_66;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v26 = "nw_protocol_http_early_data_disconnected";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v11, &type, &v23)) {
      goto LABEL_66;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_66;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v26 = "nw_protocol_http_early_data_disconnected";
      BOOL v14 = "%{public}s called with null other_protocol";
      goto LABEL_65;
    }
    if (!v23)
    {
      BOOL v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_66;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v26 = "nw_protocol_http_early_data_disconnected";
      BOOL v14 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_65;
    }
    BOOL v17 = (char *)__nw_create_backtrace_string();
    BOOL v12 = __nwlog_obj();
    os_log_type_t v13 = type;
    BOOL v20 = os_log_type_enabled(v12, type);
    if (!v17)
    {
      if (!v20) {
        goto LABEL_66;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v26 = "nw_protocol_http_early_data_disconnected";
      BOOL v14 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_65;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v26 = "nw_protocol_http_early_data_disconnected";
      __int16 v27 = 2082;
      int v28 = v17;
      __int16 v19 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_48;
    }
    goto LABEL_49;
  }
  if ((handle[256] & 0x10) == 0)
  {
    uint64_t v3 = (void *)*((void *)handle + 6);
    nw_protocol_disconnected(v3, (uint64_t)handle);
    return;
  }
  handle[256] &= ~0x10u;
  uint64_t v4 = (nw_protocol *)*((void *)handle + 4);
  parameters = (void *)nw_protocol_get_parameters((uint64_t)handle);
  if (parameters) {
    os_log_type_t v6 = os_retain(parameters);
  }
  else {
    os_log_type_t v6 = 0;
  }
  os_log_type_t v7 = nw_parameters_copy_protocol_options_legacy(v6, v4);
  nw_protocol_remove_input_handler(*((void *)handle + 4), (uint64_t)handle);
  if (!v7)
  {
    handle[256] |= 4u;
    nw_protocol_add_input_handler(*((void *)handle + 31), (uint64_t)handle);
    nw_protocol_connect(*((void *)handle + 4), (uint64_t)handle);
    *((void *)handle + 31) = 0;
    if (!v6) {
      return;
    }
    goto LABEL_21;
  }
  if ((handle[198] & 1) == 0)
  {
    if (gLogDatapath)
    {
      uint64_t v21 = __nwlog_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v22 = *((void *)handle + 31);
        *(_DWORD *)buf = 136447234;
        uint64_t v26 = "nw_protocol_http_early_data_disconnected";
        __int16 v27 = 2082;
        int v28 = handle + 114;
        __int16 v29 = 2080;
        uint64_t v30 = " ";
        __int16 v31 = 2048;
        uint64_t v32 = v4;
        __int16 v33 = 2048;
        uint64_t v34 = v22;
        _os_log_impl(&dword_1830D4000, v21, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sresetting http stream protocol instance %p to connection %p", buf, 0x34u);
      }
    }
  }
  if (nw_protocol_copy_http_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_15_74223);
  }
  id v8 = (id)nw_protocol_copy_http_definition_http_definition;
  uint64_t v9 = *((void *)handle + 31);
  BOOL v10 = v7;
  *((void *)v10 + 2) = v9;

  if (v8) {
    os_release(v8);
  }
  handle[256] |= 4u;
  nw_protocol_add_input_handler(*((void *)handle + 31), (uint64_t)handle);
  nw_protocol_connect(*((void *)handle + 4), (uint64_t)handle);
  *((void *)handle + 31) = 0;
  os_release(v10);
  if (v6) {
LABEL_21:
  }
    os_release(v6);
}

void nw_protocol_http_early_data_connected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v33 = "nw_protocol_http_early_data_connected";
    BOOL v14 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (!__nwlog_fault(v14, &type, &v30)) {
      goto LABEL_42;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v33 = "nw_protocol_http_early_data_connected";
      BOOL v17 = "%{public}s called with null protocol";
    }
    else if (v30)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v25 = os_log_type_enabled(v15, type);
      if (backtrace_string)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v33 = "nw_protocol_http_early_data_connected";
          __int16 v34 = 2082;
          uint64_t v35 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_42;
      }
      if (!v25) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v33 = "nw_protocol_http_early_data_connected";
      BOOL v17 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      char v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v33 = "nw_protocol_http_early_data_connected";
      BOOL v17 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_40;
  }
  uint64_t handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v33 = "nw_protocol_http_early_data_connected";
    BOOL v14 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (!__nwlog_fault(v14, &type, &v30)) {
      goto LABEL_42;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v33 = "nw_protocol_http_early_data_connected";
      BOOL v17 = "%{public}s called with null http_early_data";
      goto LABEL_40;
    }
    if (v30)
    {
      uint64_t v26 = (char *)__nw_create_backtrace_string();
      char v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v27 = os_log_type_enabled(v15, type);
      if (v26)
      {
        if (!v27) {
          goto LABEL_72;
        }
        *(_DWORD *)buf = 136446466;
        __int16 v33 = "nw_protocol_http_early_data_connected";
        __int16 v34 = 2082;
        uint64_t v35 = v26;
        int v28 = "%{public}s called with null http_early_data, dumping backtrace:%{public}s";
        goto LABEL_71;
      }
      if (!v27) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v33 = "nw_protocol_http_early_data_connected";
      BOOL v17 = "%{public}s called with null http_early_data, no backtrace";
    }
    else
    {
      char v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v33 = "nw_protocol_http_early_data_connected";
      BOOL v17 = "%{public}s called with null http_early_data, backtrace limit exceeded";
    }
LABEL_40:
    uint64_t v22 = v15;
    os_log_type_t v23 = v16;
LABEL_41:
    _os_log_impl(&dword_1830D4000, v22, v23, v17, buf, 0xCu);
    goto LABEL_42;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v33 = "nw_protocol_http_early_data_connected";
    BOOL v14 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (!__nwlog_fault(v14, &type, &v30)) {
      goto LABEL_42;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v33 = "nw_protocol_http_early_data_connected";
      BOOL v17 = "%{public}s called with null other_protocol";
      goto LABEL_40;
    }
    if (v30)
    {
      uint64_t v26 = (char *)__nw_create_backtrace_string();
      char v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v29 = os_log_type_enabled(v15, type);
      if (v26)
      {
        if (!v29) {
          goto LABEL_72;
        }
        *(_DWORD *)buf = 136446466;
        __int16 v33 = "nw_protocol_http_early_data_connected";
        __int16 v34 = 2082;
        uint64_t v35 = v26;
        int v28 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
LABEL_71:
        _os_log_impl(&dword_1830D4000, v15, v16, v28, buf, 0x16u);
LABEL_72:
        free(v26);
        if (!v14) {
          return;
        }
LABEL_43:
        free(v14);
        return;
      }
      if (!v29) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v33 = "nw_protocol_http_early_data_connected";
      BOOL v17 = "%{public}s called with null other_protocol, no backtrace";
    }
    else
    {
      char v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v33 = "nw_protocol_http_early_data_connected";
      BOOL v17 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    }
    goto LABEL_40;
  }
  nw_protocol_connected(*((void **)handle + 6), (uint64_t)a2);
  if (*((nw_protocol **)handle + 4) != a2) {
    return;
  }
  int v4 = nw_protocol_waiting_for_output((uint64_t)a2, (uint64_t)handle);
  char v5 = *((unsigned char *)handle + 256);
  if (v4) {
    char v6 = 2;
  }
  else {
    char v6 = 0;
  }
  *((unsigned char *)handle + 256) = v5 & 0xFD | v6;
  if ((v5 & 4) == 0)
  {
    if ((v4 & 1) == 0)
    {
      char v7 = *((unsigned char *)handle + 208);
      if (v7)
      {
        id v8 = (void *)*((void *)handle + 25);
        if (v8)
        {
          os_release(v8);
          char v7 = *((unsigned char *)handle + 208);
        }
      }
      *((void *)handle + 25) = 0;
      *((unsigned char *)handle + 208) = v7 | 1;
      char v9 = *((unsigned char *)handle + 224);
      if (v9)
      {
        BOOL v10 = (void *)*((void *)handle + 27);
        if (v10)
        {
          os_release(v10);
          char v9 = *((unsigned char *)handle + 224);
        }
      }
      *((void *)handle + 27) = 0;
      *((unsigned char *)handle + 224) = v9 | 1;
      char v11 = *((unsigned char *)handle + 240);
      if (v11)
      {
        BOOL v12 = *((void *)handle + 29);
        if (v12)
        {
          dispatch_release(v12);
          char v11 = *((unsigned char *)handle + 240);
        }
      }
      *((void *)handle + 29) = 0;
      *((unsigned char *)handle + 240) = v11 | 1;
    }
    os_log_type_t v13 = (void *)*((void *)handle + 6);
    nw_protocol_connected(v13, (uint64_t)handle);
    return;
  }
  if (!v4)
  {
    nw_http_early_data_replay((uint64_t)handle);
    return;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  __int16 v33 = "nw_protocol_http_early_data_connected";
  BOOL v14 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v30 = 0;
  if (!__nwlog_fault(v14, &type, &v30)) {
    goto LABEL_42;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v15 = gLogObj;
    os_log_type_t v16 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
      goto LABEL_42;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v33 = "nw_protocol_http_early_data_connected";
    BOOL v17 = "%{public}s Attempting early data after failure";
    goto LABEL_40;
  }
  if (!v30)
  {
    char v15 = __nwlog_obj();
    os_log_type_t v16 = type;
    if (!os_log_type_enabled(v15, type)) {
      goto LABEL_42;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v33 = "nw_protocol_http_early_data_connected";
    BOOL v17 = "%{public}s Attempting early data after failure, backtrace limit exceeded";
    goto LABEL_40;
  }
  BOOL v18 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  __int16 v19 = gLogObj;
  os_log_type_t v20 = type;
  BOOL v21 = os_log_type_enabled((os_log_t)gLogObj, type);
  if (!v18)
  {
    if (v21)
    {
      *(_DWORD *)buf = 136446210;
      __int16 v33 = "nw_protocol_http_early_data_connected";
      BOOL v17 = "%{public}s Attempting early data after failure, no backtrace";
      uint64_t v22 = v19;
      os_log_type_t v23 = v20;
      goto LABEL_41;
    }
LABEL_42:
    if (!v14) {
      return;
    }
    goto LABEL_43;
  }
  if (v21)
  {
    *(_DWORD *)buf = 136446466;
    __int16 v33 = "nw_protocol_http_early_data_connected";
    __int16 v34 = 2082;
    uint64_t v35 = v18;
    _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s Attempting early data after failure, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v18);
  if (v14) {
    goto LABEL_43;
  }
}

void nw_http_early_data_replay(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 256) & 4) != 0)
  {
    while (1)
    {
      v12[0] = 0;
      v12[1] = v12;
      uint64_t v2 = *(NSObject **)(a1 + 232);
      uint64_t v3 = v2 ? dispatch_data_get_size(v2) : 0;
      if (!nw_protocol_get_output_frames(*(void *)(a1 + 32), a1, v3 != 0, v3, 0xFFFFFFFFLL, (uint64_t)v12))break; {
      v7[0] = MEMORY[0x1E4F143A8];
      }
      v7[1] = 0x40000000;
      id v8 = ___ZL25nw_http_early_data_replayP27nw_protocol_http_early_data_block_invoke;
      char v9 = &__block_descriptor_tmp_12_64800;
      uint64_t v10 = a1;
      int v11 = v3;
      uint64_t v4 = v12[0];
      do
      {
        if (!v4) {
          break;
        }
        uint64_t v5 = *(void *)(v4 + 32);
        char v6 = ((uint64_t (*)(void *))v8)(v7);
        uint64_t v4 = v5;
      }
      while ((v6 & 1) != 0);
      nw_protocol_finalize_output_frames(*(void *)(a1 + 32), (uint64_t)v12);
      if ((*(unsigned char *)(a1 + 256) & 4) == 0) {
        goto LABEL_2;
      }
    }
  }
  else
  {
LABEL_2:
    nw_protocol_connected(*(void **)(a1 + 48), a1);
  }
}

uint64_t ___ZL25nw_http_early_data_replayP27nw_protocol_http_early_data_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 32);
  if (!*(void *)(v4 + 232))
  {
LABEL_8:
    *(unsigned char *)(v4 + 256) &= ~4u;
    int v8 = (*(unsigned __int8 *)(*(void *)(a1 + 32) + 256) >> 3) & 1;
    goto LABEL_41;
  }
  if (!nw_frame_uses_external_data(a2))
  {
    uint64_t v48 = 0;
    uint64_t v49 = 0;
    int v52 = 0;
    BOOL v50 = &v49;
    uint64_t v51 = 0x2000000000;
    v47[0] = 0;
    v47[1] = v47;
    v47[2] = 0x2000000000;
    uint64_t v48 = nw_frame_unclaimed_bytes(a2, &v52);
    uint64_t v43 = 0;
    os_log_type_t v44 = &v43;
    int v46 = 0;
    uint64_t v45 = 0x2000000000;
    char v9 = *(NSObject **)(*(void *)(a1 + 32) + 232);
    applier[0] = MEMORY[0x1E4F143A8];
    applier[1] = 0x40000000;
    applier[2] = ___ZL25nw_http_early_data_replayP27nw_protocol_http_early_data_block_invoke_2;
    applier[3] = &unk_1E5247C50;
    applier[4] = &v49;
    applier[5] = v47;
    applier[6] = &v43;
    dispatch_data_apply(v9, applier);
    if (!*((_DWORD *)v50 + 6))
    {
LABEL_31:
      size_t v31 = *((unsigned int *)v44 + 6);
      uint64_t v32 = *(void *)(a1 + 32);
      if (*(_DWORD *)(a1 + 40) == v31)
      {
        char v33 = *(unsigned char *)(v32 + 240);
        if (v33)
        {
          __int16 v34 = *(NSObject **)(v32 + 232);
          if (v34)
          {
            dispatch_release(v34);
            char v33 = *(unsigned char *)(v32 + 240);
          }
        }
        *(void *)(v32 + 232) = 0;
        *(unsigned char *)(v32 + 240) = v33 | 1;
        *(unsigned char *)(*(void *)(a1 + 32) + 256) &= ~4u;
        int v8 = (*(unsigned __int8 *)(*(void *)(a1 + 32) + 256) >> 3) & 1;
      }
      else
      {
        dispatch_data_t subrange = dispatch_data_create_subrange(*(dispatch_data_t *)(v32 + 232), v31, 0xFFFFFFFFFFFFFFFFLL);
        uint64_t v36 = *(void *)(a1 + 32);
        char v37 = *(unsigned char *)(v36 + 240);
        if (v37)
        {
          os_log_type_t v38 = *(NSObject **)(v36 + 232);
          if (v38)
          {
            dispatch_release(v38);
            char v37 = *(unsigned char *)(v36 + 240);
          }
        }
        int v8 = 0;
        *(void *)(v36 + 232) = subrange;
        *(unsigned char *)(v36 + 240) = v37 | 1;
      }
      _Block_object_dispose(&v43, 8);
      _Block_object_dispose(v47, 8);
      _Block_object_dispose(&v49, 8);
      goto LABEL_41;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v10 = *((_DWORD *)v44 + 6);
    int v11 = *((_DWORD *)v50 + 6);
    unsigned int buf = 136446722;
    int v54 = "nw_http_early_data_replay_block_invoke";
    __int16 v55 = 1024;
    int v56 = v10;
    __int16 v57 = 1024;
    int v58 = v11;
    BOOL v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (__nwlog_fault(v12, &type, &v40))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v14 = gLogObj;
        os_log_type_t v15 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          int v16 = *((_DWORD *)v44 + 6);
          int v17 = *((_DWORD *)v50 + 6);
          unsigned int buf = 136446722;
          int v54 = "nw_http_early_data_replay_block_invoke";
          __int16 v55 = 1024;
          int v56 = v16;
          __int16 v57 = 1024;
          int v58 = v17;
          BOOL v18 = "%{public}s Frame is larger than requested (copied=%u, remaining=%u)";
LABEL_27:
          _os_log_impl(&dword_1830D4000, v14, v15, v18, (uint8_t *)&buf, 0x18u);
        }
      }
      else if (v40)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v14 = gLogObj;
        os_log_type_t v15 = type;
        BOOL v24 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (backtrace_string)
        {
          if (v24)
          {
            int v25 = *((_DWORD *)v44 + 6);
            int v26 = *((_DWORD *)v50 + 6);
            unsigned int buf = 136446978;
            int v54 = "nw_http_early_data_replay_block_invoke";
            __int16 v55 = 1024;
            int v56 = v25;
            __int16 v57 = 1024;
            int v58 = v26;
            __int16 v59 = 2082;
            char v60 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s Frame is larger than requested (copied=%u, remaining=%u), dumping backtrace:%{public}s", (uint8_t *)&buf, 0x22u);
          }
          free(backtrace_string);
          goto LABEL_28;
        }
        if (v24)
        {
          int v29 = *((_DWORD *)v44 + 6);
          int v30 = *((_DWORD *)v50 + 6);
          unsigned int buf = 136446722;
          int v54 = "nw_http_early_data_replay_block_invoke";
          __int16 v55 = 1024;
          int v56 = v29;
          __int16 v57 = 1024;
          int v58 = v30;
          BOOL v18 = "%{public}s Frame is larger than requested (copied=%u, remaining=%u), no backtrace";
          goto LABEL_27;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v14 = gLogObj;
        os_log_type_t v15 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          int v27 = *((_DWORD *)v44 + 6);
          int v28 = *((_DWORD *)v50 + 6);
          unsigned int buf = 136446722;
          int v54 = "nw_http_early_data_replay_block_invoke";
          __int16 v55 = 1024;
          int v56 = v27;
          __int16 v57 = 1024;
          int v58 = v28;
          BOOL v18 = "%{public}s Frame is larger than requested (copied=%u, remaining=%u), backtrace limit exceeded";
          goto LABEL_27;
        }
      }
    }
LABEL_28:
    if (v12) {
      free(v12);
    }
    nw_frame_claim(a2, v13, 0, *((_DWORD *)v50 + 6));
    goto LABEL_31;
  }
  unsigned int buf = 0;
  nw_frame_set_external_data(a2, *(dispatch_data_t *)(*(void *)(a1 + 32) + 232), &buf);
  uint64_t v5 = *(void *)(a1 + 32);
  if (*(_DWORD *)(a1 + 40) == buf)
  {
    char v6 = *(unsigned char *)(v5 + 240);
    if (v6)
    {
      char v7 = *(NSObject **)(v5 + 232);
      if (v7)
      {
        dispatch_release(v7);
        char v6 = *(unsigned char *)(v5 + 240);
      }
    }
    *(void *)(v5 + 232) = 0;
    *(unsigned char *)(v5 + 240) = v6 | 1;
    uint64_t v4 = *(void *)(a1 + 32);
    goto LABEL_8;
  }
  dispatch_data_t v19 = dispatch_data_create_subrange(*(dispatch_data_t *)(v5 + 232), buf, 0xFFFFFFFFFFFFFFFFLL);
  uint64_t v20 = *(void *)(a1 + 32);
  char v21 = *(unsigned char *)(v20 + 240);
  if (v21)
  {
    uint64_t v22 = *(NSObject **)(v20 + 232);
    if (v22)
    {
      dispatch_release(v22);
      char v21 = *(unsigned char *)(v20 + 240);
    }
  }
  int v8 = 0;
  *(void *)(v20 + 232) = v19;
  *(unsigned char *)(v20 + 240) = v21 | 1;
LABEL_41:
  nw_frame_set_metadata(a2, *(NSObject **)(*(void *)(a1 + 32) + 200), 0, v8);
  return 1;
}

BOOL ___ZL25nw_http_early_data_replayP27nw_protocol_http_early_data_block_invoke_2(void *a1, int a2, int a3, void *__src, unsigned int a5)
{
  unsigned int v6 = *(_DWORD *)(*(void *)(a1[4] + 8) + 24);
  if (v6 >= a5) {
    size_t v7 = a5;
  }
  else {
    size_t v7 = v6;
  }
  memcpy(*(void **)(*(void *)(a1[5] + 8) + 24), __src, v7);
  *(_DWORD *)(*(void *)(a1[4] + 8) + 24) -= v7;
  *(void *)(*(void *)(a1[5] + 8) + 24) += v7;
  *(_DWORD *)(*(void *)(a1[6] + 8) + 24) += v7;
  return *(_DWORD *)(*(void *)(a1[4] + 8) + 24) != 0;
}

uint64_t nw_protocol_http_early_data_reset(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    int v25 = "nw_protocol_http_early_data_reset";
    BOOL v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (!__nwlog_fault(v12, &type, &v22)) {
      goto LABEL_58;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_58;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      int v25 = "nw_protocol_http_early_data_reset";
      os_log_type_t v15 = "%{public}s called with null protocol";
LABEL_57:
      _os_log_impl(&dword_1830D4000, v13, v14, v15, buf, 0xCu);
      goto LABEL_58;
    }
    if (!v22)
    {
      uint64_t v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        int v25 = "nw_protocol_http_early_data_reset";
        os_log_type_t v15 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_57;
      }
      goto LABEL_58;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v13 = __nwlog_obj();
    os_log_type_t v14 = type;
    BOOL v18 = os_log_type_enabled(v13, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        int v25 = "nw_protocol_http_early_data_reset";
        os_log_type_t v15 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_57;
      }
      goto LABEL_58;
    }
    if (!v18) {
      goto LABEL_44;
    }
    *(_DWORD *)unsigned int buf = 136446466;
    int v25 = "nw_protocol_http_early_data_reset";
    __int16 v26 = 2082;
    int v27 = backtrace_string;
    dispatch_data_t v19 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_43:
    _os_log_impl(&dword_1830D4000, v13, v14, v19, buf, 0x16u);
    goto LABEL_44;
  }
  uint64_t handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    int v25 = "nw_protocol_http_early_data_reset";
    BOOL v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (!__nwlog_fault(v12, &type, &v22)) {
      goto LABEL_58;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_58;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      int v25 = "nw_protocol_http_early_data_reset";
      os_log_type_t v15 = "%{public}s called with null http_early_data";
      goto LABEL_57;
    }
    if (!v22)
    {
      uint64_t v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        int v25 = "nw_protocol_http_early_data_reset";
        os_log_type_t v15 = "%{public}s called with null http_early_data, backtrace limit exceeded";
        goto LABEL_57;
      }
      goto LABEL_58;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v13 = __nwlog_obj();
    os_log_type_t v14 = type;
    BOOL v20 = os_log_type_enabled(v13, type);
    if (!backtrace_string)
    {
      if (v20)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        int v25 = "nw_protocol_http_early_data_reset";
        os_log_type_t v15 = "%{public}s called with null http_early_data, no backtrace";
        goto LABEL_57;
      }
      goto LABEL_58;
    }
    if (!v20) {
      goto LABEL_44;
    }
    *(_DWORD *)unsigned int buf = 136446466;
    int v25 = "nw_protocol_http_early_data_reset";
    __int16 v26 = 2082;
    int v27 = backtrace_string;
    dispatch_data_t v19 = "%{public}s called with null http_early_data, dumping backtrace:%{public}s";
    goto LABEL_43;
  }
  if (a2)
  {
    if ((handle[198] & 1) == 0)
    {
      if (gLogDatapath)
      {
        int v16 = __nwlog_obj();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)unsigned int buf = 136446722;
          int v25 = "nw_protocol_http_early_data_reset";
          __int16 v26 = 2082;
          int v27 = handle + 114;
          __int16 v28 = 2080;
          int v29 = " ";
          _os_log_impl(&dword_1830D4000, v16, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
        }
      }
    }
    char v5 = handle[208];
    if (v5)
    {
      unsigned int v6 = (void *)*((void *)handle + 25);
      if (v6)
      {
        os_release(v6);
        char v5 = handle[208];
      }
    }
    *((void *)handle + 25) = 0;
    handle[208] = v5 | 1;
    char v7 = handle[224];
    if (v7)
    {
      int v8 = (void *)*((void *)handle + 27);
      if (v8)
      {
        os_release(v8);
        char v7 = handle[224];
      }
    }
    *((void *)handle + 27) = 0;
    handle[224] = v7 | 1;
    char v9 = handle[240];
    if (v9)
    {
      int v10 = *((void *)handle + 29);
      if (v10)
      {
        dispatch_release(v10);
        char v9 = handle[240];
      }
    }
    *((void *)handle + 29) = 0;
    handle[240] = v9 | 1;
    handle[256] &= 0xF1u;
    nw_protocol_reset((uint64_t)a1->output_handler, (uint64_t)a2);
    return 1;
  }
  __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  int v25 = "nw_protocol_http_early_data_reset";
  BOOL v12 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v22 = 0;
  if (!__nwlog_fault(v12, &type, &v22)) {
    goto LABEL_58;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v22)
    {
      uint64_t v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        int v25 = "nw_protocol_http_early_data_reset";
        os_log_type_t v15 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_57;
      }
      goto LABEL_58;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v13 = __nwlog_obj();
    os_log_type_t v14 = type;
    BOOL v21 = os_log_type_enabled(v13, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        int v25 = "nw_protocol_http_early_data_reset";
        os_log_type_t v15 = "%{public}s called with null other_protocol, no backtrace";
        goto LABEL_57;
      }
      goto LABEL_58;
    }
    if (v21)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      int v25 = "nw_protocol_http_early_data_reset";
      __int16 v26 = 2082;
      int v27 = backtrace_string;
      dispatch_data_t v19 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_43;
    }
LABEL_44:
    free(backtrace_string);
    goto LABEL_58;
  }
  uint64_t v13 = __nwlog_obj();
  os_log_type_t v14 = type;
  if (os_log_type_enabled(v13, type))
  {
    *(_DWORD *)unsigned int buf = 136446210;
    int v25 = "nw_protocol_http_early_data_reset";
    os_log_type_t v15 = "%{public}s called with null other_protocol";
    goto LABEL_57;
  }
LABEL_58:
  if (v12) {
    free(v12);
  }
  return 0;
}

uint64_t nw_protocol_http_early_data_remove_input_handler(nw_protocol *a1, nw_protocol *a2, uint64_t a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t handle = a1->handle;
    if (handle)
    {
      v13[0] = MEMORY[0x1E4F143A8];
      v13[1] = 0x40000000;
      v13[2] = ___ZL48nw_protocol_http_early_data_remove_input_handlerP11nw_protocolS0_b_block_invoke_2;
      v13[3] = &__block_descriptor_tmp_16_64835;
      char v14 = a3;
      v13[4] = handle;
      return nw_protocol_common_remove_input_handler_with_cleanup_blocks(a1, a2, a3, (uint64_t)&__block_literal_global_15_64836, (uint64_t)v13);
    }
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v18 = "nw_protocol_http_early_data_remove_input_handler";
    char v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v16 = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (!__nwlog_fault(v5, &v16, &v15)) {
      goto LABEL_32;
    }
    if (v16 == OS_LOG_TYPE_FAULT)
    {
      unsigned int v6 = __nwlog_obj();
      os_log_type_t v7 = v16;
      if (os_log_type_enabled(v6, v16))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        BOOL v18 = "nw_protocol_http_early_data_remove_input_handler";
        int v8 = "%{public}s called with null http_early_data";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (!v15)
    {
      unsigned int v6 = __nwlog_obj();
      os_log_type_t v7 = v16;
      if (os_log_type_enabled(v6, v16))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        BOOL v18 = "nw_protocol_http_early_data_remove_input_handler";
        int v8 = "%{public}s called with null http_early_data, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    unsigned int v6 = __nwlog_obj();
    os_log_type_t v7 = v16;
    BOOL v12 = os_log_type_enabled(v6, v16);
    if (!backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        BOOL v18 = "nw_protocol_http_early_data_remove_input_handler";
        int v8 = "%{public}s called with null http_early_data, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v12)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      BOOL v18 = "nw_protocol_http_early_data_remove_input_handler";
      __int16 v19 = 2082;
      BOOL v20 = backtrace_string;
      int v11 = "%{public}s called with null http_early_data, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
    goto LABEL_22;
  }
  __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  BOOL v18 = "nw_protocol_http_early_data_remove_input_handler";
  char v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t v16 = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (!__nwlog_fault(v5, &v16, &v15)) {
    goto LABEL_32;
  }
  if (v16 != OS_LOG_TYPE_FAULT)
  {
    if (!v15)
    {
      unsigned int v6 = __nwlog_obj();
      os_log_type_t v7 = v16;
      if (os_log_type_enabled(v6, v16))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        BOOL v18 = "nw_protocol_http_early_data_remove_input_handler";
        int v8 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    unsigned int v6 = __nwlog_obj();
    os_log_type_t v7 = v16;
    BOOL v10 = os_log_type_enabled(v6, v16);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        BOOL v18 = "nw_protocol_http_early_data_remove_input_handler";
        int v8 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v10)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      BOOL v18 = "nw_protocol_http_early_data_remove_input_handler";
      __int16 v19 = 2082;
      BOOL v20 = backtrace_string;
      int v11 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_1830D4000, v6, v7, v11, buf, 0x16u);
    }
LABEL_22:
    free(backtrace_string);
    goto LABEL_32;
  }
  unsigned int v6 = __nwlog_obj();
  os_log_type_t v7 = v16;
  if (os_log_type_enabled(v6, v16))
  {
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v18 = "nw_protocol_http_early_data_remove_input_handler";
    int v8 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0xCu);
  }
LABEL_32:
  if (v5) {
    free(v5);
  }
  return 0;
}

void ___ZL48nw_protocol_http_early_data_remove_input_handlerP11nw_protocolS0_b_block_invoke_2(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 40))
  {
    uint64_t v1 = *(void *)(a1 + 32);
    if ((*(unsigned char *)(v1 + 198) & 1) == 0)
    {
      if (gLogDatapath)
      {
        char v5 = __nwlog_obj();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
        {
          int v6 = 136446722;
          os_log_type_t v7 = "nw_http_early_data_destroy";
          __int16 v8 = 2082;
          uint64_t v9 = v1 + 114;
          __int16 v10 = 2080;
          int v11 = " ";
          _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", (uint8_t *)&v6, 0x20u);
        }
      }
    }
    if (*(unsigned char *)(v1 + 240))
    {
      uint64_t v2 = *(NSObject **)(v1 + 232);
      if (v2) {
        dispatch_release(v2);
      }
    }
    *(void *)(v1 + 232) = 0;
    if (*(unsigned char *)(v1 + 224))
    {
      uint64_t v3 = *(void **)(v1 + 216);
      if (v3) {
        os_release(v3);
      }
    }
    *(void *)(v1 + 216) = 0;
    if (*(unsigned char *)(v1 + 208))
    {
      uint64_t v4 = *(void **)(v1 + 200);
      if (v4) {
        os_release(v4);
      }
    }
    free((void *)v1);
  }
}

void nw_protocol_http_early_data_output_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    char v15 = "nw_protocol_http_early_data_output_available";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (!__nwlog_fault(v3, &type, &v12)) {
      goto LABEL_39;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_39;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      char v15 = "nw_protocol_http_early_data_output_available";
      int v6 = "%{public}s called with null protocol";
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v9 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          char v15 = "nw_protocol_http_early_data_output_available";
          __int16 v16 = 2082;
          int v17 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_39:
        if (!v3) {
          return;
        }
LABEL_40:
        free(v3);
        return;
      }
      if (!v9) {
        goto LABEL_39;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      char v15 = "nw_protocol_http_early_data_output_available";
      int v6 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_39;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      char v15 = "nw_protocol_http_early_data_output_available";
      int v6 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_38:
    _os_log_impl(&dword_1830D4000, v4, v5, v6, buf, 0xCu);
    goto LABEL_39;
  }
  uint64_t handle = a1->handle;
  if (handle)
  {
    if ((handle[198] & 1) == 0)
    {
      if (gLogDatapath)
      {
        os_log_type_t v7 = __nwlog_obj();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)unsigned int buf = 136446722;
          char v15 = "nw_protocol_http_early_data_output_available";
          __int16 v16 = 2082;
          int v17 = handle + 114;
          __int16 v18 = 2080;
          __int16 v19 = " ";
          _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
        }
      }
    }
    if ((handle[256] & 4) != 0) {
      nw_http_early_data_replay((uint64_t)handle);
    }
    else {
      nw_protocol_output_available(*((void **)handle + 6), (uint64_t)handle);
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  char v15 = "nw_protocol_http_early_data_output_available";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (!__nwlog_fault(v3, &type, &v12)) {
    goto LABEL_39;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_39;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    char v15 = "nw_protocol_http_early_data_output_available";
    int v6 = "%{public}s called with null http_early_data";
    goto LABEL_38;
  }
  if (!v12)
  {
    uint64_t v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_39;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    char v15 = "nw_protocol_http_early_data_output_available";
    int v6 = "%{public}s called with null http_early_data, backtrace limit exceeded";
    goto LABEL_38;
  }
  __int16 v10 = (char *)__nw_create_backtrace_string();
  uint64_t v4 = __nwlog_obj();
  os_log_type_t v5 = type;
  BOOL v11 = os_log_type_enabled(v4, type);
  if (!v10)
  {
    if (!v11) {
      goto LABEL_39;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    char v15 = "nw_protocol_http_early_data_output_available";
    int v6 = "%{public}s called with null http_early_data, no backtrace";
    goto LABEL_38;
  }
  if (v11)
  {
    *(_DWORD *)unsigned int buf = 136446466;
    char v15 = "nw_protocol_http_early_data_output_available";
    __int16 v16 = 2082;
    int v17 = v10;
    _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s called with null http_early_data, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v10);
  if (v3) {
    goto LABEL_40;
  }
}

uint64_t nw_protocol_http_early_data_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    __int16 v26 = "nw_protocol_http_early_data_finalize_output_frames";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v9, &type, &v23)) {
      goto LABEL_53;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_53;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      __int16 v26 = "nw_protocol_http_early_data_finalize_output_frames";
      char v12 = "%{public}s called with null protocol";
LABEL_52:
      _os_log_impl(&dword_1830D4000, v10, v11, v12, buf, 0xCu);
      goto LABEL_53;
    }
    if (!v23)
    {
      __int16 v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        __int16 v26 = "nw_protocol_http_early_data_finalize_output_frames";
        char v12 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v10 = __nwlog_obj();
    os_log_type_t v11 = type;
    BOOL v15 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        __int16 v26 = "nw_protocol_http_early_data_finalize_output_frames";
        char v12 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    if (!v15) {
      goto LABEL_39;
    }
    *(_DWORD *)unsigned int buf = 136446466;
    __int16 v26 = "nw_protocol_http_early_data_finalize_output_frames";
    __int16 v27 = 2082;
    __int16 v28 = backtrace_string;
    __int16 v16 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_38:
    _os_log_impl(&dword_1830D4000, v10, v11, v16, buf, 0x16u);
    goto LABEL_39;
  }
  uint64_t handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    __int16 v26 = "nw_protocol_http_early_data_finalize_output_frames";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v9, &type, &v23)) {
      goto LABEL_53;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_53;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      __int16 v26 = "nw_protocol_http_early_data_finalize_output_frames";
      char v12 = "%{public}s called with null http_early_data";
      goto LABEL_52;
    }
    if (!v23)
    {
      __int16 v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        __int16 v26 = "nw_protocol_http_early_data_finalize_output_frames";
        char v12 = "%{public}s called with null http_early_data, backtrace limit exceeded";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v10 = __nwlog_obj();
    os_log_type_t v11 = type;
    BOOL v17 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        __int16 v26 = "nw_protocol_http_early_data_finalize_output_frames";
        char v12 = "%{public}s called with null http_early_data, no backtrace";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    if (!v17) {
      goto LABEL_39;
    }
    *(_DWORD *)unsigned int buf = 136446466;
    __int16 v26 = "nw_protocol_http_early_data_finalize_output_frames";
    __int16 v27 = 2082;
    __int16 v28 = backtrace_string;
    __int16 v16 = "%{public}s called with null http_early_data, dumping backtrace:%{public}s";
    goto LABEL_38;
  }
  if (a2)
  {
    if ((handle[198] & 1) == 0)
    {
      if (gLogDatapath)
      {
        uint64_t v13 = __nwlog_obj();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)unsigned int buf = 136446722;
          __int16 v26 = "nw_protocol_http_early_data_finalize_output_frames";
          __int16 v27 = 2082;
          __int16 v28 = handle + 114;
          __int16 v29 = 2080;
          uint64_t v30 = " ";
          _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
        }
      }
    }
    if ((handle[256] & 2) != 0)
    {
      v19[0] = MEMORY[0x1E4F143A8];
      v19[1] = 0x40000000;
      uint64_t v20 = ___ZL50nw_protocol_http_early_data_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke;
      uint64_t v21 = &__block_descriptor_tmp_9_64867;
      char v22 = handle;
      tqh_first = a2->tqh_first;
      do
      {
        if (!tqh_first) {
          break;
        }
        int v6 = (nw_frame *)*((void *)tqh_first + 4);
        char v7 = ((uint64_t (*)(void *))v20)(v19);
        tqh_first = v6;
      }
      while ((v7 & 1) != 0);
    }
    return nw_protocol_finalize_output_frames((uint64_t)a1->output_handler, (uint64_t)a2);
  }
  __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  __int16 v26 = "nw_protocol_http_early_data_finalize_output_frames";
  BOOL v9 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (!__nwlog_fault(v9, &type, &v23)) {
    goto LABEL_53;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v23)
    {
      __int16 v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        __int16 v26 = "nw_protocol_http_early_data_finalize_output_frames";
        char v12 = "%{public}s called with null frames, backtrace limit exceeded";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v10 = __nwlog_obj();
    os_log_type_t v11 = type;
    BOOL v18 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        __int16 v26 = "nw_protocol_http_early_data_finalize_output_frames";
        char v12 = "%{public}s called with null frames, no backtrace";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    if (v18)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      __int16 v26 = "nw_protocol_http_early_data_finalize_output_frames";
      __int16 v27 = 2082;
      __int16 v28 = backtrace_string;
      __int16 v16 = "%{public}s called with null frames, dumping backtrace:%{public}s";
      goto LABEL_38;
    }
LABEL_39:
    free(backtrace_string);
    goto LABEL_53;
  }
  __int16 v10 = __nwlog_obj();
  os_log_type_t v11 = type;
  if (os_log_type_enabled(v10, type))
  {
    *(_DWORD *)unsigned int buf = 136446210;
    __int16 v26 = "nw_protocol_http_early_data_finalize_output_frames";
    char v12 = "%{public}s called with null frames";
    goto LABEL_52;
  }
LABEL_53:
  if (v9) {
    free(v9);
  }
  return 0;
}

uint64_t ___ZL50nw_protocol_http_early_data_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(*(void *)(a1 + 32) + 200))
  {
    if (nw_protocol_copy_http_definition_onceToken != -1) {
      dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_15_74223);
    }
    id v4 = (id)nw_protocol_copy_http_definition_http_definition;
    os_log_type_t v5 = nw_frame_copy_metadata_for_protocol(a2, (uint64_t)v4);
    if (v4) {
      os_release(v4);
    }
    id v6 = nw_http_metadata_copy_request(v5);
    BOOL v7 = nw_http_request_copy(v6);
    nw_http_fields_append((void *)v7, (uint64_t)"Early-Data", (uint64_t)"1");
    uint64_t v8 = *(void *)(a1 + 32);
    char v9 = *(unsigned char *)(v8 + 208);
    if (v9)
    {
      __int16 v10 = *(void **)(v8 + 200);
      if (v10)
      {
        os_release(v10);
        char v9 = *(unsigned char *)(v8 + 208);
      }
    }
    *(void *)(v8 + 200) = v5;
    *(unsigned char *)(v8 + 208) = v9 | 1;
    metadata_for_request = nw_http_create_metadata_for_request((void *)v7);
    uint64_t v12 = *(void *)(a1 + 32);
    char v13 = *(unsigned char *)(v12 + 224);
    if (v13)
    {
      char v14 = *(void **)(v12 + 216);
      if (v14)
      {
        os_release(v14);
        char v13 = *(unsigned char *)(v12 + 224);
      }
    }
    *(void *)(v12 + 216) = metadata_for_request;
    *(unsigned char *)(v12 + 224) = v13 | 1;
    if (v7) {
      os_release((void *)v7);
    }
    if (v6) {
      os_release(v6);
    }
  }
  if (nw_frame_uses_external_data(a2))
  {
    *(void *)&size[1] = 0;
    BOOL v15 = nw_frame_copy_external_data(a2, &size[2], &size[1]);
    dispatch_data_t subrange = dispatch_data_create_subrange(v15, size[2], size[1]);
    if (v15) {
      dispatch_release(v15);
    }
  }
  else
  {
    size[0] = 0;
    BOOL v17 = (const void *)nw_frame_unclaimed_bytes(a2, size);
    dispatch_data_t subrange = dispatch_data_create(v17, size[0], 0, 0);
  }
  uint64_t v18 = *(void *)(a1 + 32);
  __int16 v19 = *(NSObject **)(v18 + 232);
  if (v19)
  {
    dispatch_data_t concat = dispatch_data_create_concat(v19, subrange);
    uint64_t v21 = *(void *)(a1 + 32);
    char v23 = (unsigned char *)(v21 + 240);
    char v22 = *(unsigned char *)(v21 + 240);
    if (v22)
    {
      BOOL v24 = *(NSObject **)(v21 + 232);
      if (v24)
      {
        dispatch_release(v24);
        char v22 = *v23;
      }
    }
    *(void *)(v21 + 232) = concat;
  }
  else
  {
    char v25 = *(unsigned char *)(v18 + 240);
    char v23 = (unsigned char *)(v18 + 240);
    char v22 = v25;
    *((void *)v23 - 1) = subrange;
    dispatch_data_t subrange = 0;
  }
  *char v23 = v22 | 1;
  if (nw_frame_is_metadata_complete(a2)) {
    char v26 = 8;
  }
  else {
    char v26 = 0;
  }
  *(unsigned char *)(*(void *)(a1 + 32) + 256) = *(unsigned char *)(*(void *)(a1 + 32) + 256) & 0xF7 | v26;
  nw_frame_set_metadata(a2, *(NSObject **)(*(void *)(a1 + 32) + 216), 0, (*(unsigned __int8 *)(*(void *)(a1 + 32) + 256) >> 3) & 1);
  if (subrange) {
    dispatch_release(subrange);
  }
  return 1;
}

uint64_t nw_protocol_http_early_data_get_output_frames(nw_protocol *a1, nw_protocol *a2, uint64_t a3, uint64_t a4, uint64_t a5, nw_frame_array_s *a6)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v24 = "nw_protocol_http_early_data_get_output_frames";
    __int16 v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (!__nwlog_fault(v10, &type, &v21)) {
      goto LABEL_54;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_54;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      BOOL v24 = "nw_protocol_http_early_data_get_output_frames";
      char v13 = "%{public}s called with null protocol";
    }
    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          BOOL v24 = "nw_protocol_http_early_data_get_output_frames";
          __int16 v25 = 2082;
          char v26 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_54:
        if (!v10) {
          return 0;
        }
LABEL_55:
        free(v10);
        return 0;
      }
      if (!v15) {
        goto LABEL_54;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      BOOL v24 = "nw_protocol_http_early_data_get_output_frames";
      char v13 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_54;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      BOOL v24 = "nw_protocol_http_early_data_get_output_frames";
      char v13 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_53;
  }
  uint64_t handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v24 = "nw_protocol_http_early_data_get_output_frames";
    __int16 v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (!__nwlog_fault(v10, &type, &v21)) {
      goto LABEL_54;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v21)
      {
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (!os_log_type_enabled(v11, type)) {
          goto LABEL_54;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        BOOL v24 = "nw_protocol_http_early_data_get_output_frames";
        char v13 = "%{public}s called with null http_early_data, backtrace limit exceeded";
        goto LABEL_53;
      }
      __int16 v16 = (char *)__nw_create_backtrace_string();
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v17 = os_log_type_enabled(v11, type);
      if (!v16)
      {
        if (!v17) {
          goto LABEL_54;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        BOOL v24 = "nw_protocol_http_early_data_get_output_frames";
        char v13 = "%{public}s called with null http_early_data, no backtrace";
        goto LABEL_53;
      }
      if (v17)
      {
        *(_DWORD *)unsigned int buf = 136446466;
        BOOL v24 = "nw_protocol_http_early_data_get_output_frames";
        __int16 v25 = 2082;
        char v26 = v16;
        uint64_t v18 = "%{public}s called with null http_early_data, dumping backtrace:%{public}s";
LABEL_36:
        _os_log_impl(&dword_1830D4000, v11, v12, v18, buf, 0x16u);
      }
LABEL_37:
      free(v16);
      if (!v10) {
        return 0;
      }
      goto LABEL_55;
    }
    os_log_type_t v11 = __nwlog_obj();
    os_log_type_t v12 = type;
    if (!os_log_type_enabled(v11, type)) {
      goto LABEL_54;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v24 = "nw_protocol_http_early_data_get_output_frames";
    char v13 = "%{public}s called with null http_early_data";
LABEL_53:
    _os_log_impl(&dword_1830D4000, v11, v12, v13, buf, 0xCu);
    goto LABEL_54;
  }
  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v24 = "nw_protocol_http_early_data_get_output_frames";
    __int16 v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (!__nwlog_fault(v10, &type, &v21)) {
      goto LABEL_54;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_54;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      BOOL v24 = "nw_protocol_http_early_data_get_output_frames";
      char v13 = "%{public}s called with null return_array";
      goto LABEL_53;
    }
    if (!v21)
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_54;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      BOOL v24 = "nw_protocol_http_early_data_get_output_frames";
      char v13 = "%{public}s called with null return_array, backtrace limit exceeded";
      goto LABEL_53;
    }
    __int16 v16 = (char *)__nw_create_backtrace_string();
    os_log_type_t v11 = __nwlog_obj();
    os_log_type_t v12 = type;
    BOOL v19 = os_log_type_enabled(v11, type);
    if (!v16)
    {
      if (!v19) {
        goto LABEL_54;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      BOOL v24 = "nw_protocol_http_early_data_get_output_frames";
      char v13 = "%{public}s called with null return_array, no backtrace";
      goto LABEL_53;
    }
    if (v19)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      BOOL v24 = "nw_protocol_http_early_data_get_output_frames";
      __int16 v25 = 2082;
      char v26 = v16;
      uint64_t v18 = "%{public}s called with null return_array, dumping backtrace:%{public}s";
      goto LABEL_36;
    }
    goto LABEL_37;
  }
  if ((handle[256] & 4) != 0)
  {
    if ((handle[198] & 1) == 0)
    {
      if (gLogDatapath)
      {
        uint64_t v20 = __nwlog_obj();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)unsigned int buf = 136446722;
          BOOL v24 = "nw_protocol_http_early_data_get_output_frames";
          __int16 v25 = 2082;
          char v26 = handle + 114;
          __int16 v27 = 2080;
          __int16 v28 = " ";
          _os_log_impl(&dword_1830D4000, v20, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%snot vending output frames, still replaying early data", buf, 0x20u);
        }
      }
    }
    return 0;
  }
  output_handler = a1->output_handler;

  return nw_protocol_get_output_frames((uint64_t)output_handler, (uint64_t)a1, a3, a4, a5, (uint64_t)a6);
}

double __nw_protocol_http_early_data_identifier_block_invoke()
{
  strcpy((char *)&nw_protocol_http_early_data_identifier::protocol_identifier, "http_early_data");
  *(void *)&double result = 0x100000004;
  qword_1E8F7A140 = 0x100000004;
  return result;
}

nw_path_monitor_t nw_path_monitor_create_with_type(nw_interface_type_t required_interface_type)
{
  uint64_t v2 = nw_parameters_create();
  nw_parameters_set_multipath_service(v2, nw_multipath_service_handover);
  nw_parameters_set_required_interface_type(v2, required_interface_type);
  evaluator_for_endpoint_no_evaluate = nw_path_create_evaluator_for_endpoint_no_evaluate(0, v2);

  return evaluator_for_endpoint_no_evaluate;
}

void sub_183B7F900(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_path_monitor_t nw_path_monitor_create_for_ethernet_channel(void)
{
  nw_parameters_t v0 = nw_parameters_create();
  uint64_t v1 = nw_path_create_evaluator_for_all_custom_ether_interfaces(v0);

  return v1;
}

void sub_183B7F948(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_183B7FAD0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

long long *nw_socket_protocol_identifier()
{
  if (nw_socket_protocol_identifier::onceToken != -1) {
    dispatch_once(&nw_socket_protocol_identifier::onceToken, &__block_literal_global_65117);
  }
  return &nw_socket_protocol_identifier::identifier;
}

void nw_protocol_socket_notify(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    os_log_type_t v12 = "nw_protocol_socket_notify";
    uint64_t v1 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v9 = 0;
    if (!__nwlog_fault(v1, &type, &v9)) {
      goto LABEL_32;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v2 = __nwlog_obj();
      os_log_type_t v3 = type;
      if (!os_log_type_enabled(v2, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v12 = "nw_protocol_socket_notify";
      id v4 = "%{public}s called with null protocol";
    }
    else
    {
      if (!v9)
      {
        uint64_t v2 = __nwlog_obj();
        os_log_type_t v3 = type;
        if (!os_log_type_enabled(v2, type)) {
          goto LABEL_32;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v12 = "nw_protocol_socket_notify";
        id v4 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v2 = __nwlog_obj();
      os_log_type_t v3 = type;
      BOOL v6 = os_log_type_enabled(v2, type);
      if (backtrace_string)
      {
        if (v6)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          os_log_type_t v12 = "nw_protocol_socket_notify";
          __int16 v13 = 2082;
          char v14 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v2, v3, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        if (v1) {
          goto LABEL_33;
        }
        return;
      }
      if (!v6) {
        goto LABEL_32;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v12 = "nw_protocol_socket_notify";
      id v4 = "%{public}s called with null protocol, no backtrace";
    }
LABEL_31:
    _os_log_impl(&dword_1830D4000, v2, v3, v4, buf, 0xCu);
    goto LABEL_32;
  }
  if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle) {
    return;
  }
  __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  os_log_type_t v12 = "nw_protocol_socket_notify";
  uint64_t v1 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v9 = 0;
  if (__nwlog_fault(v1, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v2 = __nwlog_obj();
      os_log_type_t v3 = type;
      if (!os_log_type_enabled(v2, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v12 = "nw_protocol_socket_notify";
      id v4 = "%{public}s called with null socket_handler";
      goto LABEL_31;
    }
    if (!v9)
    {
      uint64_t v2 = __nwlog_obj();
      os_log_type_t v3 = type;
      if (!os_log_type_enabled(v2, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v12 = "nw_protocol_socket_notify";
      id v4 = "%{public}s called with null socket_handler, backtrace limit exceeded";
      goto LABEL_31;
    }
    BOOL v7 = (char *)__nw_create_backtrace_string();
    uint64_t v2 = __nwlog_obj();
    os_log_type_t v3 = type;
    BOOL v8 = os_log_type_enabled(v2, type);
    if (!v7)
    {
      if (!v8) {
        goto LABEL_32;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v12 = "nw_protocol_socket_notify";
      id v4 = "%{public}s called with null socket_handler, no backtrace";
      goto LABEL_31;
    }
    if (v8)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      os_log_type_t v12 = "nw_protocol_socket_notify";
      __int16 v13 = 2082;
      char v14 = v7;
      _os_log_impl(&dword_1830D4000, v2, v3, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v7);
  }
LABEL_32:
  if (v1) {
LABEL_33:
  }
    free(v1);
}

uint64_t nw_socket_unregister_notification(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v29 = "nw_socket_unregister_notification";
    BOOL v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v6, &type, &v26)) {
      goto LABEL_35;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_35;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v29 = "nw_socket_unregister_notification";
      char v9 = "%{public}s called with null protocol";
LABEL_67:
      BOOL v17 = v20;
      os_log_type_t v18 = v21;
      uint32_t v19 = 12;
LABEL_34:
      _os_log_impl(&dword_1830D4000, v17, v18, v9, buf, v19);
      goto LABEL_35;
    }
    if (!v26)
    {
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_35;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v29 = "nw_socket_unregister_notification";
      char v9 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_67;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v20 = __nwlog_obj();
    os_log_type_t v21 = type;
    BOOL v23 = os_log_type_enabled(v20, type);
    if (!backtrace_string)
    {
      if (!v23) {
        goto LABEL_35;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v29 = "nw_socket_unregister_notification";
      char v9 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_67;
    }
    if (v23)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      uint64_t v29 = "nw_socket_unregister_notification";
      __int16 v30 = 2082;
      uint64_t v31 = backtrace_string;
      BOOL v24 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_56:
      _os_log_impl(&dword_1830D4000, v20, v21, v24, buf, 0x16u);
    }
LABEL_57:
    free(backtrace_string);
    if (!v6) {
      return 0;
    }
    goto LABEL_36;
  }
  if (*(_UNKNOWN **)(a1 + 40) != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v29 = "nw_socket_unregister_notification";
    BOOL v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v6, &type, &v26)) {
      goto LABEL_35;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_35;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v29 = "nw_socket_unregister_notification";
      char v9 = "%{public}s called with null socket_handler";
      goto LABEL_67;
    }
    if (!v26)
    {
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_35;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v29 = "nw_socket_unregister_notification";
      char v9 = "%{public}s called with null socket_handler, backtrace limit exceeded";
      goto LABEL_67;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v20 = __nwlog_obj();
    os_log_type_t v21 = type;
    BOOL v25 = os_log_type_enabled(v20, type);
    if (!backtrace_string)
    {
      if (!v25) {
        goto LABEL_35;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v29 = "nw_socket_unregister_notification";
      char v9 = "%{public}s called with null socket_handler, no backtrace";
      goto LABEL_67;
    }
    if (v25)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      uint64_t v29 = "nw_socket_unregister_notification";
      __int16 v30 = 2082;
      uint64_t v31 = backtrace_string;
      BOOL v24 = "%{public}s called with null socket_handler, dumping backtrace:%{public}s";
      goto LABEL_56;
    }
    goto LABEL_57;
  }
  uint64_t v4 = a1 + 96;
  switch(a3)
  {
    case 0:
      if ((*(_WORD *)(a1 + 397) & 0x80) != 0) {
        return 0;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v5 = (char *)(a1 + 404);
      *(_DWORD *)unsigned int buf = 136446722;
      uint64_t v29 = "nw_socket_unregister_notification";
      __int16 v30 = 2082;
      uint64_t v31 = (char *)(a1 + 404);
      __int16 v32 = 2082;
      char v33 = "undefined";
      BOOL v6 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v26 = 0;
      if (!__nwlog_fault(v6, &type, &v26)) {
        break;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v7 = gconnectionLogObj;
        os_log_type_t v8 = type;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
        {
          *(_DWORD *)unsigned int buf = 136446722;
          uint64_t v29 = "nw_socket_unregister_notification";
          __int16 v30 = 2082;
          uint64_t v31 = v5;
          __int16 v32 = 2082;
          char v33 = "undefined";
          char v9 = "%{public}s %{public}s invalid registration notification: %{public}s";
LABEL_32:
          BOOL v17 = v7;
          os_log_type_t v18 = v8;
LABEL_33:
          uint32_t v19 = 32;
          goto LABEL_34;
        }
      }
      else if (v26)
      {
        __int16 v13 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        char v14 = gconnectionLogObj;
        os_log_type_t v15 = type;
        BOOL v16 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
        if (v13)
        {
          if (v16)
          {
            *(_DWORD *)unsigned int buf = 136446978;
            uint64_t v29 = "nw_socket_unregister_notification";
            __int16 v30 = 2082;
            uint64_t v31 = v5;
            __int16 v32 = 2082;
            char v33 = "undefined";
            __int16 v34 = 2082;
            uint64_t v35 = v13;
            _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s %{public}s invalid registration notification: %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
          }
          free(v13);
        }
        else if (v16)
        {
          *(_DWORD *)unsigned int buf = 136446722;
          uint64_t v29 = "nw_socket_unregister_notification";
          __int16 v30 = 2082;
          uint64_t v31 = v5;
          __int16 v32 = 2082;
          char v33 = "undefined";
          char v9 = "%{public}s %{public}s invalid registration notification: %{public}s, no backtrace";
          BOOL v17 = v14;
          os_log_type_t v18 = v15;
          goto LABEL_33;
        }
      }
      else
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v7 = gconnectionLogObj;
        os_log_type_t v8 = type;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
        {
          *(_DWORD *)unsigned int buf = 136446722;
          uint64_t v29 = "nw_socket_unregister_notification";
          __int16 v30 = 2082;
          uint64_t v31 = v5;
          __int16 v32 = 2082;
          char v33 = "undefined";
          char v9 = "%{public}s %{public}s invalid registration notification: %{public}s, backtrace limit exceeded";
          goto LABEL_32;
        }
      }
      break;
    case 1:
      int v10 = *(_DWORD *)(a1 + 288);
      *(_DWORD *)(a1 + 288) = 0;
      if (nw_socket_add_socket_events(v4, 0, 1024, 0)) {
        return 1;
      }
      uint64_t result = 0;
      *(_DWORD *)(a1 + 288) = v10;
      return result;
    case 2:
      int v12 = *(_DWORD *)(a1 + 292);
      *(_DWORD *)(a1 + 292) = 0;
      if (nw_socket_add_socket_events(v4, 0, 512, 0)) {
        return 1;
      }
      uint64_t result = 0;
      *(_DWORD *)(a1 + 292) = v12;
      return result;
    case 3:
      return nw_socket_add_socket_events(v4, 0, 256, 0);
    default:
      return 0;
  }
LABEL_35:
  if (v6) {
LABEL_36:
  }
    free(v6);
  return 0;
}

uint64_t __Block_byref_object_copy__65160(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(unsigned char *)(result + 48) = *(unsigned char *)(result + 48) & 0xFE | *(unsigned char *)(a2 + 48) & 1;
  *(void *)(a2 + 40) = 0;
  *(unsigned char *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__65161(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 48))
  {
    uint64_t v2 = *(void **)(a1 + 40);
    if (v2) {
      os_release(v2);
    }
  }
  *(void *)(a1 + 40) = 0;
}

void nw_socket_set_maximum_segment_size(uint64_t a1, int a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 176) == 2)
  {
    if ((*(_WORD *)(a1 + 301) & 0x80) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v4 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)unsigned int buf = 136446722;
        os_log_type_t v18 = "nw_socket_set_maximum_segment_size";
        __int16 v19 = 2082;
        *(void *)uint64_t v20 = a1 + 308;
        *(_WORD *)&v20[8] = 1024;
        *(_DWORD *)&v20[10] = a2;
        _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s setting MSS to %d", buf, 0x1Cu);
      }
    }
    int v16 = a2;
    if (setsockopt(*(_DWORD *)(a1 + 172), 6, 2, &v16, 4u))
    {
      int v5 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v6 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)unsigned int buf = 136446722;
        os_log_type_t v18 = "nw_socket_set_maximum_segment_size";
        __int16 v19 = 2080;
        *(void *)uint64_t v20 = a1 + 308;
        *(_WORD *)&v20[8] = 1024;
        *(_DWORD *)&v20[10] = v5;
        _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt TCP_MAXSEG failed %{darwin.errno}d", buf, 0x1Cu);
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = gLogObj;
      if (v5 == 22)
      {
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)unsigned int buf = 136446466;
          os_log_type_t v18 = "nw_socket_set_maximum_segment_size";
          __int16 v19 = 1024;
          *(_DWORD *)uint64_t v20 = 22;
          _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_ERROR, "%{public}s setsockopt TCP_MAXSEG failed %{darwin.errno}d", buf, 0x12u);
        }
        return;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      os_log_type_t v18 = "nw_socket_set_maximum_segment_size";
      __int16 v19 = 1024;
      *(_DWORD *)uint64_t v20 = v5;
      os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v14 = 0;
      if (!__nwlog_fault(v8, &type, &v14)) {
        goto LABEL_29;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v9 = gLogObj;
        os_log_type_t v10 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_29;
        }
        *(_DWORD *)unsigned int buf = 136446466;
        os_log_type_t v18 = "nw_socket_set_maximum_segment_size";
        __int16 v19 = 1024;
        *(_DWORD *)uint64_t v20 = v5;
        os_log_type_t v11 = "%{public}s setsockopt TCP_MAXSEG failed %{darwin.errno}d";
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v9 = gLogObj;
        os_log_type_t v10 = type;
        BOOL v13 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)unsigned int buf = 136446722;
            os_log_type_t v18 = "nw_socket_set_maximum_segment_size";
            __int16 v19 = 1024;
            *(_DWORD *)uint64_t v20 = v5;
            *(_WORD *)&v20[4] = 2082;
            *(void *)&v20[6] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s setsockopt TCP_MAXSEG failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }
          free(backtrace_string);
          goto LABEL_29;
        }
        if (!v13)
        {
LABEL_29:
          if (v8) {
            free(v8);
          }
          return;
        }
        *(_DWORD *)unsigned int buf = 136446466;
        os_log_type_t v18 = "nw_socket_set_maximum_segment_size";
        __int16 v19 = 1024;
        *(_DWORD *)uint64_t v20 = v5;
        os_log_type_t v11 = "%{public}s setsockopt TCP_MAXSEG failed %{darwin.errno}d, no backtrace";
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v9 = gLogObj;
        os_log_type_t v10 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_29;
        }
        *(_DWORD *)unsigned int buf = 136446466;
        os_log_type_t v18 = "nw_socket_set_maximum_segment_size";
        __int16 v19 = 1024;
        *(_DWORD *)uint64_t v20 = v5;
        os_log_type_t v11 = "%{public}s setsockopt TCP_MAXSEG failed %{darwin.errno}d, backtrace limit exceeded";
      }
      _os_log_impl(&dword_1830D4000, v9, v10, v11, buf, 0x12u);
      goto LABEL_29;
    }
  }
}

void ___ZL29nw_socket_handle_socket_eventP9nw_socket_block_invoke(uint64_t a1)
{
  nw_socket_update_output_source(*(char **)(a1 + 40));
  uint64_t v2 = *(void *)(a1 + 40);
  if ((*(_WORD *)(v2 + 301) & 0x200) != 0) {
    nw_socket_update_input_source((char *)v2);
  }
  uint64_t v3 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  if (v3)
  {
    if (*(_UNKNOWN **)(v3 + 40) == &nw_protocol_ref_counted_handle)
    {
      uint64_t v4 = *(void *)(v3 + 88);
      if (v4)
      {
        uint64_t v5 = v4 - 1;
        *(void *)(v3 + 88) = v5;
        if (!v5)
        {
          BOOL v6 = *(void (***)(void))(v3 + 64);
          if (v6)
          {
            *(void *)(v3 + 64) = 0;
            v6[2](v6);
            _Block_release(v6);
          }
          if (*(unsigned char *)(v3 + 72))
          {
            uint64_t v7 = *(const void **)(v3 + 64);
            if (v7) {
              _Block_release(v7);
            }
          }
          free((void *)v3);
        }
      }
    }
  }
}

void nw_socket_internal_error(uint64_t a1, uint64_t a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3)
    {
      uint64_t v4 = *(void (**)(uint64_t, uint64_t, uint64_t))(v3 + 56);
      if (v4)
      {
        uint64_t v6 = a1 - 96;
        uint64_t v7 = *(void *)(a1 + 48);
        v4(v7, v6, a2);
        return;
      }
    }
    __nwlog_obj();
    os_log_type_t v8 = *(const char **)(v2 + 16);
    if (!v8) {
      os_log_type_t v8 = "invalid";
    }
  }
  else
  {
    __nwlog_obj();
    os_log_type_t v8 = "invalid";
  }
  *(_DWORD *)unsigned int buf = 136446466;
  char v22 = "nw_socket_internal_error";
  __int16 v23 = 2082;
  BOOL v24 = v8;
  char v9 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (__nwlog_fault(v9, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_37;
      }
      int v12 = "invalid";
      if (v2 && *(void *)(v2 + 16)) {
        int v12 = *(const char **)(v2 + 16);
      }
      *(_DWORD *)unsigned int buf = 136446466;
      char v22 = "nw_socket_internal_error";
      __int16 v23 = 2082;
      BOOL v24 = v12;
      BOOL v13 = "%{public}s protocol %{public}s has invalid error callback";
      goto LABEL_36;
    }
    if (!v19)
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_37;
      }
      BOOL v17 = "invalid";
      if (v2 && *(void *)(v2 + 16)) {
        BOOL v17 = *(const char **)(v2 + 16);
      }
      *(_DWORD *)unsigned int buf = 136446466;
      char v22 = "nw_socket_internal_error";
      __int16 v23 = 2082;
      BOOL v24 = v17;
      BOOL v13 = "%{public}s protocol %{public}s has invalid error callback, backtrace limit exceeded";
      goto LABEL_36;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v10 = __nwlog_obj();
    os_log_type_t v11 = type;
    BOOL v15 = os_log_type_enabled(v10, type);
    if (backtrace_string)
    {
      if (v15)
      {
        int v16 = "invalid";
        if (v2 && *(void *)(v2 + 16)) {
          int v16 = *(const char **)(v2 + 16);
        }
        *(_DWORD *)unsigned int buf = 136446722;
        char v22 = "nw_socket_internal_error";
        __int16 v23 = 2082;
        BOOL v24 = v16;
        __int16 v25 = 2082;
        char v26 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s protocol %{public}s has invalid error callback, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(backtrace_string);
      goto LABEL_37;
    }
    if (v15)
    {
      os_log_type_t v18 = "invalid";
      if (v2 && *(void *)(v2 + 16)) {
        os_log_type_t v18 = *(const char **)(v2 + 16);
      }
      *(_DWORD *)unsigned int buf = 136446466;
      char v22 = "nw_socket_internal_error";
      __int16 v23 = 2082;
      BOOL v24 = v18;
      BOOL v13 = "%{public}s protocol %{public}s has invalid error callback, no backtrace";
LABEL_36:
      _os_log_impl(&dword_1830D4000, v10, v11, v13, buf, 0x16u);
    }
  }
LABEL_37:
  if (v9) {
    free(v9);
  }
}

void nw_socket_update_output_source(char *a1)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v2 = (unsigned __int16 *)(a1 + 301);
    int v3 = *(unsigned __int16 *)(a1 + 301);
    if ((v3 & 0x4000) == 0)
    {
      if (((v3 | (a1[303] << 16)) & 0x400000) != 0) {
        nw_socket_internal_link_state((uint64_t)a1, 0);
      }
      if (nw_socket_service_writes((uint64_t)a1))
      {
        int v5 = *v2;
        int v6 = v5 | (*((unsigned __int8 *)v2 + 2) << 16);
        if ((v5 & 8) != 0)
        {
          nw_socket_output_finished((nw_protocol *)(a1 - 96), v4);
          int v6 = *v2 | (*((unsigned __int8 *)v2 + 2) << 16);
        }
        if ((v6 & 0x40) != 0)
        {
          if ((v6 & 8) == 0 && (!*((void *)a1 + 29) || (v6 & 0x40000) != 0))
          {
            nw_socket_internal_disconnect((uint64_t)a1);
          }
        }
        else
        {
          uint64_t v7 = *((void *)a1 + 6);
          if (v7)
          {
            uint64_t v8 = *(void *)(v7 + 24);
            if (v8)
            {
              char v9 = *(void (**)(void))(v8 + 72);
              if (v9)
              {
                v9();
              }
            }
          }
        }
      }
    }
    return;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)unsigned int buf = 136446210;
  __int16 v23 = "nw_socket_update_output_source";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v10, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v11 = gLogObj;
      os_log_type_t v12 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      __int16 v23 = "nw_socket_update_output_source";
      BOOL v13 = "%{public}s called with null socket_handler";
LABEL_32:
      os_log_type_t v18 = v11;
      os_log_type_t v19 = v12;
LABEL_33:
      _os_log_impl(&dword_1830D4000, v18, v19, v13, buf, 0xCu);
      goto LABEL_34;
    }
    if (!v20)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v11 = gLogObj;
      os_log_type_t v12 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      __int16 v23 = "nw_socket_update_output_source";
      BOOL v13 = "%{public}s called with null socket_handler, backtrace limit exceeded";
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v15 = gLogObj;
    os_log_type_t v16 = type;
    BOOL v17 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)unsigned int buf = 136446466;
        __int16 v23 = "nw_socket_update_output_source";
        __int16 v24 = 2082;
        __int16 v25 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_34;
    }
    if (v17)
    {
      *(_DWORD *)unsigned int buf = 136446210;
      __int16 v23 = "nw_socket_update_output_source";
      BOOL v13 = "%{public}s called with null socket_handler, no backtrace";
      os_log_type_t v18 = v15;
      os_log_type_t v19 = v16;
      goto LABEL_33;
    }
  }
LABEL_34:
  if (v10) {
    free(v10);
  }
}

void nw_socket_internal_link_state(uint64_t a1, int a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 48);
  int v5 = *(void **)(a1 + 144);
  if (v5)
  {
    int v6 = v5;
    int v7 = v6[2];
    v6[2] = a2;

    if (v7 == a2)
    {
      if (gLogDatapath)
      {
        uint64_t v8 = __nwlog_obj();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          int v16 = 136446466;
          BOOL v17 = "nw_socket_internal_link_state";
          __int16 v18 = 1024;
          LODWORD(v19) = a2;
          _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_DEBUG, "%{public}s Not updating link state because it's the same %d", (uint8_t *)&v16, 0x12u);
        }
      }
      return;
    }
  }
  else
  {
    *(void *)(a1 + 144) = nw_link_info_create(a2);
  }
  char v9 = (_WORD *)(a1 + 301);
  __int16 v10 = *(_WORD *)(a1 + 301);
  if (a2)
  {
    if ((v10 & 0x80) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v11 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
      {
        int v16 = 136446466;
        BOOL v17 = "nw_socket_internal_link_state";
        __int16 v18 = 2082;
        uint64_t v19 = a1 + 308;
        _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_INFO, "%{public}s %{public}s Link is flow controlled", (uint8_t *)&v16, 0x16u);
      }
    }
    unsigned int v12 = (unsigned __int16)*v9 | (*(unsigned __int8 *)(a1 + 303) << 16) | 0x400000;
  }
  else
  {
    if ((v10 & 0x80) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v13 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
      {
        int v16 = 136446466;
        BOOL v17 = "nw_socket_internal_link_state";
        __int16 v18 = 2082;
        uint64_t v19 = a1 + 308;
        _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_INFO, "%{public}s %{public}s Link is no longer flow controlled", (uint8_t *)&v16, 0x16u);
      }
    }
    unsigned int v12 = ((unsigned __int16)*v9 | (*(unsigned __int8 *)(a1 + 303) << 16)) & 0xFFBFFFFF;
  }
  _WORD *v9 = v12;
  *(unsigned char *)(a1 + 303) = BYTE2(v12);
  if (v4)
  {
    uint64_t v14 = *(void *)(v4 + 24);
    if (v14)
    {
      BOOL v15 = *(void (**)(uint64_t, uint64_t, void))(v14 + 104);
      if (v15) {
        v15(v4, a1 - 96, *(void *)(a1 + 144));
      }
    }
  }
}

void nw_socket_set_send_low_water_mark(uint64_t a1, unsigned int a2)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  if (a2 <= 1) {
    unsigned int v2 = 1;
  }
  else {
    unsigned int v2 = a2;
  }
  unsigned int v34 = v2;
  unsigned int v3 = *(_DWORD *)(a1 + 156);
  if (v3 == v2) {
    return;
  }
  if (v2 > v3)
  {
    socklen_t v32 = 4;
    *(_DWORD *)char v33 = 0;
    if (getsockopt(*(_DWORD *)(a1 + 172), 0xFFFF, 4097, v33, &v32))
    {
      int v5 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v6 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)unsigned int buf = 136446722;
        uint64_t v36 = "nw_socket_set_send_low_water_mark";
        __int16 v37 = 2080;
        *(void *)&long long v38 = a1 + 308;
        WORD4(v38) = 1024;
        *(_DWORD *)((char *)&v38 + 10) = v5;
        _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_ERROR, "%{public}s %s getsockopt SO_SNDBUF failed %{darwin.errno}d", buf, 0x1Cu);
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)unsigned int buf = 136446466;
      uint64_t v36 = "nw_socket_set_send_low_water_mark";
      __int16 v37 = 1024;
      LODWORD(v38) = v5;
      int v7 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v30 = 0;
      if (!__nwlog_fault(v7, &type, &v30)) {
        goto LABEL_31;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v8 = gLogObj;
        os_log_type_t v9 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_31;
        }
        *(_DWORD *)unsigned int buf = 136446466;
        uint64_t v36 = "nw_socket_set_send_low_water_mark";
        __int16 v37 = 1024;
        LODWORD(v38) = v5;
        __int16 v10 = "%{public}s getsockopt SO_SNDBUF failed %{darwin.errno}d";
      }
      else if (v30)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v8 = gLogObj;
        os_log_type_t v9 = type;
        BOOL v13 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)unsigned int buf = 136446722;
            uint64_t v36 = "nw_socket_set_send_low_water_mark";
            __int16 v37 = 1024;
            LODWORD(v38) = v5;
            WORD2(v38) = 2082;
            *(void *)((char *)&v38 + 6) = backtrace_string;
            _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s getsockopt SO_SNDBUF failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }
          free(backtrace_string);
          goto LABEL_31;
        }
        if (!v13)
        {
LABEL_31:
          if (v7) {
            free(v7);
          }
          goto LABEL_33;
        }
        *(_DWORD *)unsigned int buf = 136446466;
        uint64_t v36 = "nw_socket_set_send_low_water_mark";
        __int16 v37 = 1024;
        LODWORD(v38) = v5;
        __int16 v10 = "%{public}s getsockopt SO_SNDBUF failed %{darwin.errno}d, no backtrace";
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v8 = gLogObj;
        os_log_type_t v9 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_31;
        }
        *(_DWORD *)unsigned int buf = 136446466;
        uint64_t v36 = "nw_socket_set_send_low_water_mark";
        __int16 v37 = 1024;
        LODWORD(v38) = v5;
        __int16 v10 = "%{public}s getsockopt SO_SNDBUF failed %{darwin.errno}d, backtrace limit exceeded";
      }
      _os_log_impl(&dword_1830D4000, v8, v9, v10, buf, 0x12u);
      goto LABEL_31;
    }
    if (*(_DWORD *)v33 && v2 > *(_DWORD *)v33 / 3u)
    {
      if (*(_DWORD *)v33 < 3u) {
        unsigned int v11 = 1;
      }
      else {
        unsigned int v11 = *(_DWORD *)v33 / 3u;
      }
      unsigned int v34 = v11;
    }
  }
LABEL_33:
  if (!setsockopt(*(_DWORD *)(a1 + 172), 0xFFFF, 4099, &v34, 4u))
  {
    *(_DWORD *)(a1 + 156) = v34;
    return;
  }
  int v14 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
  }
  BOOL v15 = gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    int v16 = *(_DWORD *)(a1 + 172);
    *(_DWORD *)unsigned int buf = 136447234;
    uint64_t v36 = "nw_socket_set_send_low_water_mark";
    __int16 v37 = 2080;
    *(void *)&long long v38 = a1 + 308;
    WORD4(v38) = 1024;
    *(_DWORD *)((char *)&v38 + 10) = v34;
    HIWORD(v38) = 1024;
    *(_DWORD *)uint64_t v39 = v16;
    *(_WORD *)&v39[4] = 1024;
    *(_DWORD *)&v39[6] = v14;
    _os_log_impl(&dword_1830D4000, v15, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_SNDLOWAT %u fd %d failed %{darwin.errno}d", buf, 0x28u);
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v17 = gLogObj;
  if (v14 == 22)
  {
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      int v18 = *(_DWORD *)(a1 + 172);
      *(_DWORD *)unsigned int buf = 136446978;
      uint64_t v36 = "nw_socket_set_send_low_water_mark";
      __int16 v37 = 1024;
      LODWORD(v38) = v34;
      WORD2(v38) = 1024;
      *(_DWORD *)((char *)&v38 + 6) = v18;
      WORD5(v38) = 1024;
      HIDWORD(v38) = 22;
      _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_ERROR, "%{public}s setsockopt SO_SNDLOWAT %u fd %d failed %{darwin.errno}d", buf, 0x1Eu);
    }
    return;
  }
  int v19 = *(_DWORD *)(a1 + 172);
  *(_DWORD *)unsigned int buf = 136446978;
  uint64_t v36 = "nw_socket_set_send_low_water_mark";
  __int16 v37 = 1024;
  LODWORD(v38) = v34;
  WORD2(v38) = 1024;
  *(_DWORD *)((char *)&v38 + 6) = v19;
  WORD5(v38) = 1024;
  HIDWORD(v38) = v14;
  uint64_t v20 = (char *)_os_log_send_and_compose_impl();
  v33[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v32) = 0;
  if (!__nwlog_fault(v20, v33, &v32)) {
    goto LABEL_56;
  }
  if (v33[0] == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v21 = gLogObj;
    os_log_type_t v22 = v33[0];
    if (!os_log_type_enabled((os_log_t)gLogObj, v33[0])) {
      goto LABEL_56;
    }
    int v23 = *(_DWORD *)(a1 + 172);
    *(_DWORD *)unsigned int buf = 136446978;
    uint64_t v36 = "nw_socket_set_send_low_water_mark";
    __int16 v37 = 1024;
    LODWORD(v38) = v34;
    WORD2(v38) = 1024;
    *(_DWORD *)((char *)&v38 + 6) = v23;
    WORD5(v38) = 1024;
    HIDWORD(v38) = v14;
    __int16 v24 = "%{public}s setsockopt SO_SNDLOWAT %u fd %d failed %{darwin.errno}d";
    goto LABEL_55;
  }
  if (!(_BYTE)v32)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v21 = gLogObj;
    os_log_type_t v22 = v33[0];
    if (!os_log_type_enabled((os_log_t)gLogObj, v33[0])) {
      goto LABEL_56;
    }
    int v28 = *(_DWORD *)(a1 + 172);
    *(_DWORD *)unsigned int buf = 136446978;
    uint64_t v36 = "nw_socket_set_send_low_water_mark";
    __int16 v37 = 1024;
    LODWORD(v38) = v34;
    WORD2(v38) = 1024;
    *(_DWORD *)((char *)&v38 + 6) = v28;
    WORD5(v38) = 1024;
    HIDWORD(v38) = v14;
    __int16 v24 = "%{public}s setsockopt SO_SNDLOWAT %u fd %d failed %{darwin.errno}d, backtrace limit exceeded";
    goto LABEL_55;
  }
  __int16 v25 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v21 = gLogObj;
  os_log_type_t v22 = v33[0];
  BOOL v26 = os_log_type_enabled((os_log_t)gLogObj, v33[0]);
  if (v25)
  {
    if (v26)
    {
      int v27 = *(_DWORD *)(a1 + 172);
      *(_DWORD *)unsigned int buf = 136447234;
      uint64_t v36 = "nw_socket_set_send_low_water_mark";
      __int16 v37 = 1024;
      LODWORD(v38) = v34;
      WORD2(v38) = 1024;
      *(_DWORD *)((char *)&v38 + 6) = v27;
      WORD5(v38) = 1024;
      HIDWORD(v38) = v14;
      *(_WORD *)uint64_t v39 = 2082;
      *(void *)&v39[2] = v25;
      _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s setsockopt SO_SNDLOWAT %u fd %d failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x28u);
    }
    free(v25);
    goto LABEL_56;
  }
  if (v26)
  {
    int v29 = *(_DWORD *)(a1 + 172);
    *(_DWORD *)unsigned int buf = 136446978;
    uint64_t v36 = "nw_socket_set_send_low_water_mark";
    __int16 v37 = 1024;
    LODWORD(v38) = v34;
    WORD2(v38) = 1024;
    *(_DWORD *)((char *)&v38 + 6) = v29;
    WORD5(v38) = 1024;
    HIDWORD(v38) = v14;
    __int16 v24 = "%{public}s setsockopt SO_SNDLOWAT %u fd %d failed %{darwin.errno}d, no backtrace";
LABEL_55:
    _os_log_impl(&dword_1830D4000, v21, v22, v24, buf, 0x1Eu);
  }
LABEL_56:
  if (v20) {
    free(v20);
  }
}

BOOL ___ZL24__nw_signpost_is_enabledv_block_invoke_65374()
{
  BOOL result = networkd_settings_get_BOOL((const char *)nw_setting_enable_signposts);
  _nw_signposts_enabled = result;
  return result;
}

BOOL nw_calloc_type<nw_data_transfer_snapshot>(size_t count)
{
  if (!count || count >= 0x1642C8590B21643)
  {
    uint64_t v4 = __nwlog_obj();
    os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
    int v5 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v5);
    if (result) {
      goto LABEL_9;
    }
    free(v5);
  }
  unsigned int v2 = malloc_type_calloc(count, 0xB8uLL, 0xEAFB8F1AuLL);
  if (v2) {
    return (BOOL)v2;
  }
  int v6 = __nwlog_obj();
  os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
  int v7 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v7);
  if (!result)
  {
    free(v7);
    return (BOOL)v2;
  }
LABEL_9:
  __break(1u);
  return result;
}

uint64_t nw_socket_set_no_push(uint64_t a1, int a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 176) != 2) {
    return 22;
  }
  int v15 = a2;
  if (!setsockopt(*(_DWORD *)(a1 + 172), 6, 4, &v15, 4u)) {
    return 0;
  }
  uint64_t v3 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
  }
  uint64_t v4 = gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)unsigned int buf = 136446722;
    BOOL v17 = "nw_socket_set_no_push";
    __int16 v18 = 2080;
    *(void *)int v19 = a1 + 308;
    *(_WORD *)&v19[8] = 1024;
    *(_DWORD *)&v19[10] = v3;
    _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt TCP_NOPUSH failed %{darwin.errno}d", buf, 0x1Cu);
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v5 = gLogObj;
  if (v3 == 22)
  {
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unsigned int buf = 136446466;
      BOOL v17 = "nw_socket_set_no_push";
      __int16 v18 = 1024;
      *(_DWORD *)int v19 = 22;
      _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_ERROR, "%{public}s setsockopt TCP_NOPUSH failed %{darwin.errno}d", buf, 0x12u);
    }
    return v3;
  }
  *(_DWORD *)unsigned int buf = 136446466;
  BOOL v17 = "nw_socket_set_no_push";
  __int16 v18 = 1024;
  *(_DWORD *)int v19 = v3;
  int v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v7 = gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_26;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      BOOL v17 = "nw_socket_set_no_push";
      __int16 v18 = 1024;
      *(_DWORD *)int v19 = v3;
      os_log_type_t v9 = "%{public}s setsockopt TCP_NOPUSH failed %{darwin.errno}d";
      goto LABEL_25;
    }
    if (!v13)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v7 = gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_26;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      BOOL v17 = "nw_socket_set_no_push";
      __int16 v18 = 1024;
      *(_DWORD *)int v19 = v3;
      os_log_type_t v9 = "%{public}s setsockopt TCP_NOPUSH failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_25;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v7 = gLogObj;
    os_log_type_t v8 = type;
    BOOL v11 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)unsigned int buf = 136446722;
        BOOL v17 = "nw_socket_set_no_push";
        __int16 v18 = 1024;
        *(_DWORD *)int v19 = v3;
        *(_WORD *)&void v19[4] = 2082;
        *(void *)&void v19[6] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s setsockopt TCP_NOPUSH failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }
      free(backtrace_string);
      goto LABEL_26;
    }
    if (v11)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      BOOL v17 = "nw_socket_set_no_push";
      __int16 v18 = 1024;
      *(_DWORD *)int v19 = v3;
      os_log_type_t v9 = "%{public}s setsockopt TCP_NOPUSH failed %{darwin.errno}d, no backtrace";
LABEL_25:
      _os_log_impl(&dword_1830D4000, v7, v8, v9, buf, 0x12u);
    }
  }
LABEL_26:
  if (v6) {
    free(v6);
  }
  return v3;
}

uint64_t nw_protocol_socket_set_no_wake_from_sleep(_DWORD *a1, int a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    *(_DWORD *)uint64_t v20 = a2;
    if (!setsockopt(a1[43], 0xFFFF, 0x10000, v20, 4u)) {
      return 0;
    }
    uint64_t v3 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v4 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unsigned int buf = 136446722;
      int v23 = "nw_protocol_socket_set_no_wake_from_sleep";
      __int16 v24 = 2080;
      *(void *)__int16 v25 = a1 + 77;
      *(_WORD *)&v25[8] = 1024;
      *(_DWORD *)&v25[10] = v3;
      _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_NOWAKEFROMSLEEP failed %{darwin.errno}d", buf, 0x1Cu);
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v5 = gLogObj;
    if (v3 == 22)
    {
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)unsigned int buf = 136446466;
        int v23 = "nw_protocol_socket_set_no_wake_from_sleep";
        __int16 v24 = 1024;
        *(_DWORD *)__int16 v25 = 22;
        _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_ERROR, "%{public}s setsockopt SO_NOWAKEFROMSLEEP failed %{darwin.errno}d", buf, 0x12u);
      }
      return v3;
    }
    *(_DWORD *)unsigned int buf = 136446466;
    int v23 = "nw_protocol_socket_set_no_wake_from_sleep";
    __int16 v24 = 1024;
    *(_DWORD *)__int16 v25 = v3;
    int v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19)) {
      goto LABEL_25;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v7 = gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      int v23 = "nw_protocol_socket_set_no_wake_from_sleep";
      __int16 v24 = 1024;
      *(_DWORD *)__int16 v25 = v3;
      os_log_type_t v9 = "%{public}s setsockopt SO_NOWAKEFROMSLEEP failed %{darwin.errno}d";
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v7 = gLogObj;
      os_log_type_t v8 = type;
      BOOL v11 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)unsigned int buf = 136446722;
          int v23 = "nw_protocol_socket_set_no_wake_from_sleep";
          __int16 v24 = 1024;
          *(_DWORD *)__int16 v25 = v3;
          *(_WORD *)&v25[4] = 2082;
          *(void *)&v25[6] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s setsockopt SO_NOWAKEFROMSLEEP failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(backtrace_string);
        goto LABEL_25;
      }
      if (!v11)
      {
LABEL_25:
        if (v6) {
          free(v6);
        }
        return v3;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      int v23 = "nw_protocol_socket_set_no_wake_from_sleep";
      __int16 v24 = 1024;
      *(_DWORD *)__int16 v25 = v3;
      os_log_type_t v9 = "%{public}s setsockopt SO_NOWAKEFROMSLEEP failed %{darwin.errno}d, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v7 = gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      int v23 = "nw_protocol_socket_set_no_wake_from_sleep";
      __int16 v24 = 1024;
      *(_DWORD *)__int16 v25 = v3;
      os_log_type_t v9 = "%{public}s setsockopt SO_NOWAKEFROMSLEEP failed %{darwin.errno}d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v7, v8, v9, buf, 0x12u);
    goto LABEL_25;
  }
  __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  int v23 = "nw_protocol_socket_set_no_wake_from_sleep";
  char v13 = (char *)_os_log_send_and_compose_impl();
  v20[0] = OS_LOG_TYPE_ERROR;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v13, v20, &type))
  {
    if (v20[0] == OS_LOG_TYPE_FAULT)
    {
      int v14 = __nwlog_obj();
      os_log_type_t v15 = v20[0];
      if (os_log_type_enabled(v14, v20[0]))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        int v23 = "nw_protocol_socket_set_no_wake_from_sleep";
        int v16 = "%{public}s called with null handle";
LABEL_41:
        _os_log_impl(&dword_1830D4000, v14, v15, v16, buf, 0xCu);
      }
    }
    else if (type)
    {
      BOOL v17 = (char *)__nw_create_backtrace_string();
      int v14 = __nwlog_obj();
      os_log_type_t v15 = v20[0];
      BOOL v18 = os_log_type_enabled(v14, v20[0]);
      if (v17)
      {
        if (v18)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          int v23 = "nw_protocol_socket_set_no_wake_from_sleep";
          __int16 v24 = 2082;
          *(void *)__int16 v25 = v17;
          _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s called with null handle, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v17);
        goto LABEL_42;
      }
      if (v18)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        int v23 = "nw_protocol_socket_set_no_wake_from_sleep";
        int v16 = "%{public}s called with null handle, no backtrace";
        goto LABEL_41;
      }
    }
    else
    {
      int v14 = __nwlog_obj();
      os_log_type_t v15 = v20[0];
      if (os_log_type_enabled(v14, v20[0]))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        int v23 = "nw_protocol_socket_set_no_wake_from_sleep";
        int v16 = "%{public}s called with null handle, backtrace limit exceeded";
        goto LABEL_41;
      }
    }
  }
LABEL_42:
  if (v13) {
    free(v13);
  }
  return 22;
}

uint64_t nw_protocol_socket_set_no_push(uint64_t a1, int a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    return nw_socket_set_no_push(a1, a2);
  }
  __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  unsigned int v12 = "nw_protocol_socket_set_no_push";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        unsigned int v12 = "nw_protocol_socket_set_no_push";
        int v6 = "%{public}s called with null handle";
LABEL_18:
        _os_log_impl(&dword_1830D4000, v4, v5, v6, buf, 0xCu);
      }
    }
    else if (v9)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v8 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v8)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          unsigned int v12 = "nw_protocol_socket_set_no_push";
          __int16 v13 = 2082;
          int v14 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s called with null handle, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_19;
      }
      if (v8)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        unsigned int v12 = "nw_protocol_socket_set_no_push";
        int v6 = "%{public}s called with null handle, no backtrace";
        goto LABEL_18;
      }
    }
    else
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        unsigned int v12 = "nw_protocol_socket_set_no_push";
        int v6 = "%{public}s called with null handle, backtrace limit exceeded";
        goto LABEL_18;
      }
    }
  }
LABEL_19:
  if (v3) {
    free(v3);
  }
  return 22;
}

uint64_t nw_protocol_socket_set_no_delay(uint64_t a1, int a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    return nw_socket_set_no_delay(a1, a2);
  }
  __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  unsigned int v12 = "nw_protocol_socket_set_no_delay";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        unsigned int v12 = "nw_protocol_socket_set_no_delay";
        int v6 = "%{public}s called with null handle";
LABEL_18:
        _os_log_impl(&dword_1830D4000, v4, v5, v6, buf, 0xCu);
      }
    }
    else if (v9)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v8 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v8)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          unsigned int v12 = "nw_protocol_socket_set_no_delay";
          __int16 v13 = 2082;
          int v14 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s called with null handle, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_19;
      }
      if (v8)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        unsigned int v12 = "nw_protocol_socket_set_no_delay";
        int v6 = "%{public}s called with null handle, no backtrace";
        goto LABEL_18;
      }
    }
    else
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        unsigned int v12 = "nw_protocol_socket_set_no_delay";
        int v6 = "%{public}s called with null handle, backtrace limit exceeded";
        goto LABEL_18;
      }
    }
  }
LABEL_19:
  if (v3) {
    free(v3);
  }
  return 22;
}

uint64_t nw_protocol_socket_reset_keepalives(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  int v19 = a5;
  int v20 = a4;
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    os_log_type_t v22 = "nw_protocol_socket_reset_keepalives";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v17) = 0;
    if (__nwlog_fault(v11, type, &v17))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        unsigned int v12 = __nwlog_obj();
        os_log_type_t v13 = type[0];
        if (os_log_type_enabled(v12, type[0]))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          os_log_type_t v22 = "nw_protocol_socket_reset_keepalives";
          int v14 = "%{public}s called with null handle";
LABEL_38:
          _os_log_impl(&dword_1830D4000, v12, v13, v14, buf, 0xCu);
        }
      }
      else if ((_BYTE)v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        unsigned int v12 = __nwlog_obj();
        os_log_type_t v13 = type[0];
        BOOL v16 = os_log_type_enabled(v12, type[0]);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)unsigned int buf = 136446466;
            os_log_type_t v22 = "nw_protocol_socket_reset_keepalives";
            __int16 v23 = 2082;
            __int16 v24 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null handle, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_39;
        }
        if (v16)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          os_log_type_t v22 = "nw_protocol_socket_reset_keepalives";
          int v14 = "%{public}s called with null handle, no backtrace";
          goto LABEL_38;
        }
      }
      else
      {
        unsigned int v12 = __nwlog_obj();
        os_log_type_t v13 = type[0];
        if (os_log_type_enabled(v12, type[0]))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          os_log_type_t v22 = "nw_protocol_socket_reset_keepalives";
          int v14 = "%{public}s called with null handle, backtrace limit exceeded";
          goto LABEL_38;
        }
      }
    }
LABEL_39:
    if (v11) {
      free(v11);
    }
    return 22;
  }
  *(_DWORD *)os_log_type_t type = a2;
  if (setsockopt(a1[43], 0xFFFF, 8, type, 4u) < 0)
  {
    uint64_t v7 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    BOOL v8 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
      return v7;
    }
    *(_DWORD *)unsigned int buf = 136446722;
    os_log_type_t v22 = "nw_protocol_socket_reset_keepalives";
    __int16 v23 = 2080;
    __int16 v24 = (char *)(a1 + 77);
    __int16 v25 = 1024;
    int v26 = v7;
    char v9 = "%{public}s %s setsockopt SO_KEEPALIVE failed %{darwin.errno}d";
LABEL_23:
    _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_ERROR, v9, buf, 0x1Cu);
    return v7;
  }
  if (setsockopt(a1[43], 6, 16, &v20, 4u) < 0)
  {
    uint64_t v7 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    BOOL v8 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
      return v7;
    }
    *(_DWORD *)unsigned int buf = 136446722;
    os_log_type_t v22 = "nw_protocol_socket_reset_keepalives";
    __int16 v23 = 2080;
    __int16 v24 = (char *)(a1 + 77);
    __int16 v25 = 1024;
    int v26 = v7;
    char v9 = "%{public}s %s setsockopt TCP_KEEPALIVE failed %{darwin.errno}d";
    goto LABEL_23;
  }
  if (setsockopt(a1[43], 6, 257, &v19, 4u) < 0)
  {
    uint64_t v7 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    BOOL v8 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
      return v7;
    }
    *(_DWORD *)unsigned int buf = 136446722;
    os_log_type_t v22 = "nw_protocol_socket_reset_keepalives";
    __int16 v23 = 2080;
    __int16 v24 = (char *)(a1 + 77);
    __int16 v25 = 1024;
    int v26 = v7;
    char v9 = "%{public}s %s setsockopt TCP_KEEPINTVL failed %{darwin.errno}d";
    goto LABEL_23;
  }
  int v17 = a3;
  if ((setsockopt(a1[43], 6, 258, &v17, 4u) & 0x80000000) == 0) {
    return 0;
  }
  uint64_t v7 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
  }
  BOOL v8 = gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)unsigned int buf = 136446722;
    os_log_type_t v22 = "nw_protocol_socket_reset_keepalives";
    __int16 v23 = 2080;
    __int16 v24 = (char *)(a1 + 77);
    __int16 v25 = 1024;
    int v26 = v7;
    char v9 = "%{public}s %s setsockopt TCP_KEEPCNT failed %{darwin.errno}d";
    goto LABEL_23;
  }
  return v7;
}

uint64_t nw_protocol_socket_get_receive_buffer_size(_DWORD *a1)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    socklen_t v19 = 4;
    *(_DWORD *)int v20 = 0;
    if (!getsockopt(a1[43], 0xFFFF, 4128, v20, &v19)) {
      return *(unsigned int *)v20;
    }
    int v2 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v3 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unsigned int buf = 136446722;
      os_log_type_t v22 = "nw_protocol_socket_get_receive_buffer_size";
      __int16 v23 = 2080;
      *(void *)__int16 v24 = a1 + 77;
      *(_WORD *)&v24[8] = 1024;
      *(_DWORD *)&v24[10] = v2;
      _os_log_impl(&dword_1830D4000, v3, OS_LOG_TYPE_ERROR, "%{public}s %s getsockopt SO_NREAD failed %{darwin.errno}d", buf, 0x1Cu);
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)unsigned int buf = 136446466;
    os_log_type_t v22 = "nw_protocol_socket_get_receive_buffer_size";
    __int16 v23 = 1024;
    *(_DWORD *)__int16 v24 = v2;
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v4, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v5 = gLogObj;
        os_log_type_t v6 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_21;
        }
        *(_DWORD *)unsigned int buf = 136446466;
        os_log_type_t v22 = "nw_protocol_socket_get_receive_buffer_size";
        __int16 v23 = 1024;
        *(_DWORD *)__int16 v24 = v2;
        uint64_t v7 = "%{public}s getsockopt SO_NREAD failed %{darwin.errno}d";
        goto LABEL_20;
      }
      if (!v17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v5 = gLogObj;
        os_log_type_t v6 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_21;
        }
        *(_DWORD *)unsigned int buf = 136446466;
        os_log_type_t v22 = "nw_protocol_socket_get_receive_buffer_size";
        __int16 v23 = 1024;
        *(_DWORD *)__int16 v24 = v2;
        uint64_t v7 = "%{public}s getsockopt SO_NREAD failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_20;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v5 = gLogObj;
      os_log_type_t v6 = type;
      BOOL v9 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)unsigned int buf = 136446722;
          os_log_type_t v22 = "nw_protocol_socket_get_receive_buffer_size";
          __int16 v23 = 1024;
          *(_DWORD *)__int16 v24 = v2;
          *(_WORD *)&v24[4] = 2082;
          *(void *)&v24[6] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s getsockopt SO_NREAD failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(backtrace_string);
        goto LABEL_21;
      }
      if (v9)
      {
        *(_DWORD *)unsigned int buf = 136446466;
        os_log_type_t v22 = "nw_protocol_socket_get_receive_buffer_size";
        __int16 v23 = 1024;
        *(_DWORD *)__int16 v24 = v2;
        uint64_t v7 = "%{public}s getsockopt SO_NREAD failed %{darwin.errno}d, no backtrace";
LABEL_20:
        _os_log_impl(&dword_1830D4000, v5, v6, v7, buf, 0x12u);
      }
    }
LABEL_21:
    if (v4) {
      free(v4);
    }
    return *(unsigned int *)v20;
  }
  __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  os_log_type_t v22 = "nw_protocol_socket_get_receive_buffer_size";
  BOOL v11 = (char *)_os_log_send_and_compose_impl();
  v20[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v19) = 0;
  if (__nwlog_fault(v11, v20, &v19))
  {
    if (v20[0] == OS_LOG_TYPE_FAULT)
    {
      unsigned int v12 = __nwlog_obj();
      os_log_type_t v13 = v20[0];
      if (os_log_type_enabled(v12, v20[0]))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v22 = "nw_protocol_socket_get_receive_buffer_size";
        int v14 = "%{public}s called with null handle";
LABEL_37:
        _os_log_impl(&dword_1830D4000, v12, v13, v14, buf, 0xCu);
      }
    }
    else if ((_BYTE)v19)
    {
      uint64_t v15 = (char *)__nw_create_backtrace_string();
      unsigned int v12 = __nwlog_obj();
      os_log_type_t v13 = v20[0];
      BOOL v16 = os_log_type_enabled(v12, v20[0]);
      if (v15)
      {
        if (v16)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          os_log_type_t v22 = "nw_protocol_socket_get_receive_buffer_size";
          __int16 v23 = 2082;
          *(void *)__int16 v24 = v15;
          _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null handle, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v15);
        goto LABEL_38;
      }
      if (v16)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v22 = "nw_protocol_socket_get_receive_buffer_size";
        int v14 = "%{public}s called with null handle, no backtrace";
        goto LABEL_37;
      }
    }
    else
    {
      unsigned int v12 = __nwlog_obj();
      os_log_type_t v13 = v20[0];
      if (os_log_type_enabled(v12, v20[0]))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v22 = "nw_protocol_socket_get_receive_buffer_size";
        int v14 = "%{public}s called with null handle, backtrace limit exceeded";
        goto LABEL_37;
      }
    }
  }
LABEL_38:
  if (v11) {
    free(v11);
  }
  return 0;
}

void ___ZL29nw_socket_setup_output_eventsP9nw_socket_block_invoke(uint64_t a1)
{
}

BOOL ___ZL17nw_socket_connectP11nw_protocolS0__block_invoke(uint64_t a1, int a2)
{
  return *(_DWORD *)(*(void *)(a1 + 32) + 172) == a2;
}

void *nw_socket_get_output_interface(nw_protocol *a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a1->handle == &nw_protocol_ref_counted_handle) {
      return a1[2].output_handler_context;
    }
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    os_log_type_t v13 = "nw_socket_get_output_interface";
    int v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (!__nwlog_fault(v2, &type, &v10)) {
      goto LABEL_32;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v13 = "nw_socket_get_output_interface";
        os_log_type_t v5 = "%{public}s called with null socket_handler";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (!v10)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v13 = "nw_socket_get_output_interface";
        os_log_type_t v5 = "%{public}s called with null socket_handler, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v3 = __nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v9 = os_log_type_enabled(v3, type);
    if (!backtrace_string)
    {
      if (v9)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v13 = "nw_socket_get_output_interface";
        os_log_type_t v5 = "%{public}s called with null socket_handler, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v9)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      os_log_type_t v13 = "nw_socket_get_output_interface";
      __int16 v14 = 2082;
      uint64_t v15 = backtrace_string;
      BOOL v8 = "%{public}s called with null socket_handler, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
    goto LABEL_22;
  }
  __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  os_log_type_t v13 = "nw_socket_get_output_interface";
  int v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (!__nwlog_fault(v2, &type, &v10)) {
    goto LABEL_32;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v10)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v13 = "nw_socket_get_output_interface";
        os_log_type_t v5 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v3 = __nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!backtrace_string)
    {
      if (v7)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v13 = "nw_socket_get_output_interface";
        os_log_type_t v5 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v7)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      os_log_type_t v13 = "nw_socket_get_output_interface";
      __int16 v14 = 2082;
      uint64_t v15 = backtrace_string;
      BOOL v8 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_1830D4000, v3, v4, v8, buf, 0x16u);
    }
LABEL_22:
    free(backtrace_string);
    goto LABEL_32;
  }
  uint64_t v3 = __nwlog_obj();
  os_log_type_t v4 = type;
  if (os_log_type_enabled(v3, type))
  {
    *(_DWORD *)unsigned int buf = 136446210;
    os_log_type_t v13 = "nw_socket_get_output_interface";
    os_log_type_t v5 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
  }
LABEL_32:
  if (v2) {
    free(v2);
  }
  return 0;
}

void nw_socket_output_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v18 = "nw_socket_output_available";
    BOOL v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (!__nwlog_fault(v7, &type, &v15)) {
      goto LABEL_43;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_43;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      BOOL v18 = "nw_socket_output_available";
      char v10 = "%{public}s called with null protocol";
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          BOOL v18 = "nw_socket_output_available";
          __int16 v19 = 2082;
          int v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_43:
        if (!v7) {
          return;
        }
LABEL_44:
        free(v7);
        return;
      }
      if (!v12) {
        goto LABEL_43;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      BOOL v18 = "nw_socket_output_available";
      char v10 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      BOOL v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_43;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      BOOL v18 = "nw_socket_output_available";
      char v10 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_42:
    _os_log_impl(&dword_1830D4000, v8, v9, v10, buf, 0xCu);
    goto LABEL_43;
  }
  if (a1->handle == &nw_protocol_ref_counted_handle)
  {
    identifier = a1[2].identifier;
    if (identifier)
    {
      uint64_t v4 = *(void *)&identifier->name[24];
      if (v4)
      {
        os_log_type_t v5 = *(void (**)(void))(v4 + 72);
        if (v5)
        {
          v5();
        }
      }
    }
    else if ((*(_WORD *)&a1[6].flow_id[13] & 0x80) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v6 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)unsigned int buf = 136446466;
        BOOL v18 = "nw_socket_output_available";
        __int16 v19 = 2082;
        int v20 = (char *)&a1[6].identifier + 4;
        _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_ERROR, "%{public}s %{public}s No input handler", buf, 0x16u);
      }
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  BOOL v18 = "nw_socket_output_available";
  BOOL v7 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (!__nwlog_fault(v7, &type, &v15)) {
    goto LABEL_43;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    BOOL v8 = __nwlog_obj();
    os_log_type_t v9 = type;
    if (!os_log_type_enabled(v8, type)) {
      goto LABEL_43;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v18 = "nw_socket_output_available";
    char v10 = "%{public}s called with null socket_handler";
    goto LABEL_42;
  }
  if (!v15)
  {
    BOOL v8 = __nwlog_obj();
    os_log_type_t v9 = type;
    if (!os_log_type_enabled(v8, type)) {
      goto LABEL_43;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v18 = "nw_socket_output_available";
    char v10 = "%{public}s called with null socket_handler, backtrace limit exceeded";
    goto LABEL_42;
  }
  os_log_type_t v13 = (char *)__nw_create_backtrace_string();
  BOOL v8 = __nwlog_obj();
  os_log_type_t v9 = type;
  BOOL v14 = os_log_type_enabled(v8, type);
  if (!v13)
  {
    if (!v14) {
      goto LABEL_43;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v18 = "nw_socket_output_available";
    char v10 = "%{public}s called with null socket_handler, no backtrace";
    goto LABEL_42;
  }
  if (v14)
  {
    *(_DWORD *)unsigned int buf = 136446466;
    BOOL v18 = "nw_socket_output_available";
    __int16 v19 = 2082;
    int v20 = v13;
    _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v13);
  if (v7) {
    goto LABEL_44;
  }
}

void nw_socket_input_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v18 = "nw_socket_input_available";
    BOOL v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (!__nwlog_fault(v7, &type, &v15)) {
      goto LABEL_43;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_43;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      BOOL v18 = "nw_socket_input_available";
      char v10 = "%{public}s called with null protocol";
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          BOOL v18 = "nw_socket_input_available";
          __int16 v19 = 2082;
          int v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_43:
        if (!v7) {
          return;
        }
LABEL_44:
        free(v7);
        return;
      }
      if (!v12) {
        goto LABEL_43;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      BOOL v18 = "nw_socket_input_available";
      char v10 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      BOOL v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_43;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      BOOL v18 = "nw_socket_input_available";
      char v10 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_42:
    _os_log_impl(&dword_1830D4000, v8, v9, v10, buf, 0xCu);
    goto LABEL_43;
  }
  if (a1->handle == &nw_protocol_ref_counted_handle)
  {
    identifier = a1[2].identifier;
    if (identifier)
    {
      uint64_t v4 = *(void *)&identifier->name[24];
      if (v4)
      {
        os_log_type_t v5 = *(void (**)(void))(v4 + 64);
        if (v5)
        {
          v5();
        }
      }
    }
    else if ((*(_WORD *)&a1[6].flow_id[13] & 0x80) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v6 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)unsigned int buf = 136446466;
        BOOL v18 = "nw_socket_input_available";
        __int16 v19 = 2082;
        int v20 = (char *)&a1[6].identifier + 4;
        _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_ERROR, "%{public}s %{public}s No input handler", buf, 0x16u);
      }
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  BOOL v18 = "nw_socket_input_available";
  BOOL v7 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (!__nwlog_fault(v7, &type, &v15)) {
    goto LABEL_43;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    BOOL v8 = __nwlog_obj();
    os_log_type_t v9 = type;
    if (!os_log_type_enabled(v8, type)) {
      goto LABEL_43;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v18 = "nw_socket_input_available";
    char v10 = "%{public}s called with null socket_handler";
    goto LABEL_42;
  }
  if (!v15)
  {
    BOOL v8 = __nwlog_obj();
    os_log_type_t v9 = type;
    if (!os_log_type_enabled(v8, type)) {
      goto LABEL_43;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v18 = "nw_socket_input_available";
    char v10 = "%{public}s called with null socket_handler, backtrace limit exceeded";
    goto LABEL_42;
  }
  os_log_type_t v13 = (char *)__nw_create_backtrace_string();
  BOOL v8 = __nwlog_obj();
  os_log_type_t v9 = type;
  BOOL v14 = os_log_type_enabled(v8, type);
  if (!v13)
  {
    if (!v14) {
      goto LABEL_43;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v18 = "nw_socket_input_available";
    char v10 = "%{public}s called with null socket_handler, no backtrace";
    goto LABEL_42;
  }
  if (v14)
  {
    *(_DWORD *)unsigned int buf = 136446466;
    BOOL v18 = "nw_socket_input_available";
    __int16 v19 = 2082;
    int v20 = v13;
    _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v13);
  if (v7) {
    goto LABEL_44;
  }
}

BOOL nw_socket_replace_input_handler(nw_protocol *a1, nw_protocol *a2, nw_protocol_identifier *a3)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v40 = "nw_socket_replace_input_handler";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (!__nwlog_fault(v9, &type, &v37)) {
      goto LABEL_53;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_53;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v40 = "nw_socket_replace_input_handler";
      BOOL v12 = "%{public}s called with null protocol";
      goto LABEL_51;
    }
    if (v37)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v34 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v34)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          uint64_t v40 = "nw_socket_replace_input_handler";
          __int16 v41 = 2082;
          id v42 = backtrace_string;
          uint64_t v35 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_84:
          _os_log_impl(&dword_1830D4000, v10, v11, v35, buf, 0x16u);
        }
LABEL_85:
        free(backtrace_string);
        goto LABEL_53;
      }
      if (!v34) {
        goto LABEL_53;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v40 = "nw_socket_replace_input_handler";
      BOOL v12 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      char v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_53;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v40 = "nw_socket_replace_input_handler";
      BOOL v12 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_51:
    uint64_t v27 = v10;
    os_log_type_t v28 = v11;
LABEL_52:
    _os_log_impl(&dword_1830D4000, v27, v28, v12, buf, 0xCu);
    goto LABEL_53;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v40 = "nw_socket_replace_input_handler";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (!__nwlog_fault(v9, &type, &v37)) {
      goto LABEL_53;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_53;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v40 = "nw_socket_replace_input_handler";
      BOOL v12 = "%{public}s called with null socket_handler";
      goto LABEL_51;
    }
    if (v37)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v36 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v36)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          uint64_t v40 = "nw_socket_replace_input_handler";
          __int16 v41 = 2082;
          id v42 = backtrace_string;
          uint64_t v35 = "%{public}s called with null socket_handler, dumping backtrace:%{public}s";
          goto LABEL_84;
        }
        goto LABEL_85;
      }
      if (!v36) {
        goto LABEL_53;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v40 = "nw_socket_replace_input_handler";
      BOOL v12 = "%{public}s called with null socket_handler, no backtrace";
    }
    else
    {
      char v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_53;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v40 = "nw_socket_replace_input_handler";
      BOOL v12 = "%{public}s called with null socket_handler, backtrace limit exceeded";
    }
    goto LABEL_51;
  }
  if (!a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v40 = "nw_socket_replace_input_handler";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (!__nwlog_fault(v9, &type, &v37)) {
      goto LABEL_53;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v37)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v10 = gLogObj;
        os_log_type_t v11 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_53;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v40 = "nw_socket_replace_input_handler";
        BOOL v12 = "%{public}s called with null old_input_handler, backtrace limit exceeded";
        goto LABEL_51;
      }
      os_log_type_t v13 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v14 = gLogObj;
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v13)
      {
        if (v16)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          uint64_t v40 = "nw_socket_replace_input_handler";
          __int16 v41 = 2082;
          id v42 = v13;
          char v17 = "%{public}s called with null old_input_handler, dumping backtrace:%{public}s";
LABEL_34:
          _os_log_impl(&dword_1830D4000, v14, v15, v17, buf, 0x16u);
        }
LABEL_35:
        free(v13);
        goto LABEL_53;
      }
      if (!v16) {
        goto LABEL_53;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v40 = "nw_socket_replace_input_handler";
      BOOL v12 = "%{public}s called with null old_input_handler, no backtrace";
LABEL_59:
      uint64_t v27 = v14;
      os_log_type_t v28 = v15;
      goto LABEL_52;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v10 = gLogObj;
    os_log_type_t v11 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
      goto LABEL_53;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v40 = "nw_socket_replace_input_handler";
    BOOL v12 = "%{public}s called with null old_input_handler";
    goto LABEL_51;
  }
  if (!a3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v40 = "nw_socket_replace_input_handler";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (!__nwlog_fault(v9, &type, &v37)) {
      goto LABEL_53;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v10 = gLogObj;
      os_log_type_t v11 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_53;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v40 = "nw_socket_replace_input_handler";
      BOOL v12 = "%{public}s called with null new_input_handler";
      goto LABEL_51;
    }
    if (!v37)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v10 = gLogObj;
      os_log_type_t v11 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_53;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v40 = "nw_socket_replace_input_handler";
      BOOL v12 = "%{public}s called with null new_input_handler, backtrace limit exceeded";
      goto LABEL_51;
    }
    os_log_type_t v13 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v14 = gLogObj;
    os_log_type_t v15 = type;
    BOOL v22 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (v13)
    {
      if (v22)
      {
        *(_DWORD *)unsigned int buf = 136446466;
        uint64_t v40 = "nw_socket_replace_input_handler";
        __int16 v41 = 2082;
        id v42 = v13;
        char v17 = "%{public}s called with null new_input_handler, dumping backtrace:%{public}s";
        goto LABEL_34;
      }
      goto LABEL_35;
    }
    if (v22)
    {
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v40 = "nw_socket_replace_input_handler";
      BOOL v12 = "%{public}s called with null new_input_handler, no backtrace";
      goto LABEL_59;
    }
LABEL_53:
    if (v9) {
      free(v9);
    }
    return 0;
  }
  if ((nw_protocol *)a1[2].identifier == a2)
  {
    a1[2].identifier = a3;
    if (!*(void *)&a3->level)
    {
      *(void *)&a3->level = a1;
      callbacks = a1[1].callbacks;
      if (callbacks) {
        a1[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
      }
    }
    __int16 v19 = *(nw_protocol_callbacks **)&a3->name[24];
    if (v19
      && (supports_external_data = (uint64_t (*)(nw_protocol_identifier *))v19->supports_external_data) != 0)
    {
      if (*(_UNKNOWN **)a3[1].name == &nw_protocol_ref_counted_handle)
      {
        __int16 v23 = *(nw_protocol_callbacks **)&a3[2].name[8];
        if (v23) {
          *(void *)&a3[2].name[8] = (char *)&v23->add_input_handler + 1;
        }
        int v21 = supports_external_data(a3);
        if (*(_UNKNOWN **)a3[1].name == &nw_protocol_ref_counted_handle)
        {
          int v29 = *(nw_protocol_callbacks **)&a3[2].name[8];
          if (v29)
          {
            char v30 = (nw_protocol_callbacks *)((char *)v29 - 1);
            *(void *)&a3[2].name[8] = v30;
            if (!v30)
            {
              uint64_t v31 = *(void (***)(void))&a3[1].name[24];
              if (v31)
              {
                *(void *)&a3[1].name[24] = 0;
                v31[2](v31);
                _Block_release(v31);
              }
              if (a3[1].level)
              {
                socklen_t v32 = *(const void **)&a3[1].name[24];
                if (v32) {
                  _Block_release(v32);
                }
              }
              free(a3);
            }
          }
        }
      }
      else
      {
        int v21 = supports_external_data(a3);
      }
      __int16 v24 = &a1[6].flow_id[13];
      if ((((*(_WORD *)&a1[6].flow_id[13] & 0x1000) == 0) ^ v21)) {
        return 1;
      }
      nw_socket_release_frame_array((nw_frame_array_s *)&a1[4].handle);
      int v25 = *(unsigned __int16 *)&a1[6].flow_id[13] | (a1[6].flow_id[15] << 16);
      if (v21) {
        __int16 v26 = 4096;
      }
      else {
        __int16 v26 = 0;
      }
    }
    else
    {
      __int16 v24 = &a1[6].flow_id[13];
      if ((*(_WORD *)&a1[6].flow_id[13] & 0x1000) == 0) {
        return 1;
      }
      nw_socket_release_frame_array((nw_frame_array_s *)&a1[4].handle);
      __int16 v26 = 0;
      int v25 = *(unsigned __int16 *)v24 | (a1[6].flow_id[15] << 16);
    }
    v24[2] = BYTE2(v25);
    *(_WORD *)__int16 v24 = v25 & 0xEFFF | v26;
    return 1;
  }
  if ((*(_WORD *)&a1[6].flow_id[13] & 0x80) != 0) {
    return 0;
  }
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
  }
  os_log_type_t v6 = gconnectionLogObj;
  BOOL result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
  if (result)
  {
    identifier = a1[2].identifier;
    *(_DWORD *)unsigned int buf = 136446978;
    uint64_t v40 = "nw_socket_replace_input_handler";
    __int16 v41 = 2082;
    id v42 = (char *)&a1[6].identifier + 4;
    __int16 v43 = 2048;
    os_log_type_t v44 = identifier;
    __int16 v45 = 2048;
    int v46 = a2;
    _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Old input handler does not match (%p != %p)", buf, 0x2Au);
    return 0;
  }
  return result;
}

const sockaddr *NWUtilsCreateNSStringFromSockaddr(const sockaddr *result, int a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (result)
  {
    int v2 = result;
    if (a2)
    {
      if (getnameinfo(result, result->sa_len, v6, 0x46u, v5, 6u, 10))
      {
        return 0;
      }
      else
      {
        if (v2->sa_family == 30) {
          uint64_t v4 = ".";
        }
        else {
          uint64_t v4 = ":";
        }
        objc_msgSend(NSString, "stringWithFormat:", @"%s%s%s", v6, v4, v5);
        return (const sockaddr *)objc_claimAutoreleasedReturnValue();
      }
    }
    else
    {
      int v3 = getnameinfo(result, result->sa_len, v6, 0x46u, 0, 0, 10);
      BOOL result = 0;
      if (!v3)
      {
        [NSString stringWithUTF8String:v6];
        return (const sockaddr *)objc_claimAutoreleasedReturnValue();
      }
    }
  }
  return result;
}

uint64_t NWUtilsStringMatchesPattern(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  objc_opt_class();
  if (objc_opt_isKindOfClass() & 1) != 0 && (objc_opt_class(), (objc_opt_isKindOfClass()))
  {
    if ([v4 hasSuffix:@"*"])
    {
      os_log_type_t v5 = objc_msgSend(v4, "substringWithRange:", 0, objc_msgSend(v4, "length") - 1);
      uint64_t v6 = [v3 hasPrefix:v5];
    }
    else
    {
      if (![v4 hasPrefix:@"*"])
      {
        uint64_t v7 = [v3 isEqualToString:v4];
        goto LABEL_6;
      }
      os_log_type_t v5 = objc_msgSend(v4, "substringWithRange:", 1, objc_msgSend(v4, "length") - 1);
      uint64_t v9 = [v3 length];
      if (v9 == [v5 length] - 1 && objc_msgSend(v5, "hasPrefix:", @"."))
      {
        uint64_t v10 = objc_msgSend(v5, "substringWithRange:", 1, objc_msgSend(v5, "length") - 1);

        os_log_type_t v5 = (void *)v10;
      }
      uint64_t v6 = [v3 hasSuffix:v5];
    }
    uint64_t v7 = v6;
  }
  else
  {
    uint64_t v7 = 0;
  }
LABEL_6:

  return v7;
}

uint64_t NWUtilsStringMatchesPatternSet(void *a1, void *a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    long long v12 = 0u;
    long long v13 = 0u;
    long long v10 = 0u;
    long long v11 = 0u;
    id v5 = v4;
    uint64_t v6 = [v5 countByEnumeratingWithState:&v10 objects:v14 count:16];
    if (v6)
    {
      uint64_t v7 = *(void *)v11;
      while (2)
      {
        for (uint64_t i = 0; i != v6; ++i)
        {
          if (*(void *)v11 != v7) {
            objc_enumerationMutation(v5);
          }
          if (NWUtilsStringMatchesPattern(v3, *(void **)(*((void *)&v10 + 1) + 8 * i)))
          {
            uint64_t v6 = 1;
            goto LABEL_13;
          }
        }
        uint64_t v6 = [v5 countByEnumeratingWithState:&v10 objects:v14 count:16];
        if (v6) {
          continue;
        }
        break;
      }
    }
LABEL_13:
  }
  else
  {
    uint64_t v6 = 0;
  }

  return v6;
}

uint64_t NWUtilsAnyStringsMatchPatternSet(void *a1, void *a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  id v5 = v3;
  uint64_t v6 = [v5 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v6)
  {
    uint64_t v7 = *(void *)v11;
    while (2)
    {
      for (uint64_t i = 0; i != v6; ++i)
      {
        if (*(void *)v11 != v7) {
          objc_enumerationMutation(v5);
        }
        if (NWUtilsStringMatchesPatternSet(*(void **)(*((void *)&v10 + 1) + 8 * i), v4))
        {
          uint64_t v6 = 1;
          goto LABEL_11;
        }
      }
      uint64_t v6 = [v5 countByEnumeratingWithState:&v10 objects:v14 count:16];
      if (v6) {
        continue;
      }
      break;
    }
  }
LABEL_11:

  return v6;
}

uint64_t NWUtilsAreNSObjectsEqual(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  id v5 = v4;
  uint64_t v6 = v3 == v4;
  if (v3 != v4 && v3 && v4)
  {
    if ([v3 isMemberOfClass:objc_opt_class()]) {
      uint64_t v6 = [v3 isEqual:v5];
    }
    else {
      uint64_t v6 = 0;
    }
  }

  return v6;
}

id NWUtilsCreateNSDictionaryFromXPCDictionary(void *a1)
{
  uint64_t v1 = (void *)MEMORY[0x1E4F1CA60];
  id v2 = a1;
  id v3 = [v1 dictionary];
  applier[0] = MEMORY[0x1E4F143A8];
  applier[1] = 3221225472;
  applier[2] = __NWUtilsCreateNSDictionaryFromXPCDictionary_block_invoke;
  applier[3] = &unk_1E52480D0;
  id v4 = v3;
  id v7 = v4;
  xpc_dictionary_apply(v2, applier);

  return v4;
}

BOOL NWUtilsCurrentProcessHasEntitlement(void *a1)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  id v2 = SecTaskCreateFromSelf((CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
  if (!v2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v10 = (id)gLogObj;
    *(_DWORD *)unsigned int buf = 136446210;
    socklen_t v32 = "NWUtilsCurrentProcessHasEntitlement";
    long long v11 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(error) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v11, &error, &type))
    {
      if (error == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        long long v12 = (id)gLogObj;
        os_log_type_t v13 = error;
        if (!os_log_type_enabled(v12, (os_log_type_t)error)) {
          goto LABEL_46;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        socklen_t v32 = "NWUtilsCurrentProcessHasEntitlement";
        BOOL v14 = "%{public}s SecTaskCreateFromSelf failed";
LABEL_44:
        __int16 v26 = v12;
        os_log_type_t v27 = v13;
        goto LABEL_45;
      }
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        long long v12 = (id)gLogObj;
        os_log_type_t v13 = error;
        if (!os_log_type_enabled(v12, (os_log_type_t)error)) {
          goto LABEL_46;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        socklen_t v32 = "NWUtilsCurrentProcessHasEntitlement";
        BOOL v14 = "%{public}s SecTaskCreateFromSelf failed, backtrace limit exceeded";
        goto LABEL_44;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      long long v12 = (id)gLogObj;
      os_log_type_t v21 = error;
      BOOL v22 = os_log_type_enabled(v12, (os_log_type_t)error);
      if (!backtrace_string)
      {
        if (!v22)
        {
LABEL_46:

          if (!v11) {
            goto LABEL_34;
          }
          goto LABEL_33;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        socklen_t v32 = "NWUtilsCurrentProcessHasEntitlement";
        BOOL v14 = "%{public}s SecTaskCreateFromSelf failed, no backtrace";
        __int16 v26 = v12;
        os_log_type_t v27 = v21;
LABEL_45:
        _os_log_impl(&dword_1830D4000, v26, v27, v14, buf, 0xCu);
        goto LABEL_46;
      }
      if (v22)
      {
        *(_DWORD *)unsigned int buf = 136446466;
        socklen_t v32 = "NWUtilsCurrentProcessHasEntitlement";
        __int16 v33 = 2082;
        BOOL v34 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v12, v21, "%{public}s SecTaskCreateFromSelf failed, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    if (!v11)
    {
LABEL_34:
      BOOL v19 = 0;
      goto LABEL_35;
    }
LABEL_33:
    free(v11);
    goto LABEL_34;
  }
  id v3 = v2;
  CFErrorRef error = 0;
  CFTypeRef v4 = SecTaskCopyValueForEntitlement(v2, v1, &error);
  if (error)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v5 = (id)gLogObj;
    *(_DWORD *)unsigned int buf = 136446722;
    socklen_t v32 = "NWUtilsCurrentProcessHasEntitlement";
    __int16 v33 = 2114;
    BOOL v34 = v1;
    __int16 v35 = 2114;
    CFErrorRef v36 = error;
    uint64_t v6 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (__nwlog_fault((const char *)v6, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v7 = (id)gLogObj;
        os_log_type_t v8 = type;
        if (!os_log_type_enabled(v7, type)) {
          goto LABEL_40;
        }
        *(_DWORD *)unsigned int buf = 136446722;
        socklen_t v32 = "NWUtilsCurrentProcessHasEntitlement";
        __int16 v33 = 2114;
        BOOL v34 = v1;
        __int16 v35 = 2114;
        CFErrorRef v36 = error;
        uint64_t v9 = "%{public}s SecTaskCopyValueForEntitlement %{public}@ error %{public}@ failed";
LABEL_38:
        __int16 v24 = v7;
        os_log_type_t v25 = v8;
        goto LABEL_39;
      }
      if (!v28)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v7 = (id)gLogObj;
        os_log_type_t v8 = type;
        if (!os_log_type_enabled(v7, type)) {
          goto LABEL_40;
        }
        *(_DWORD *)unsigned int buf = 136446722;
        socklen_t v32 = "NWUtilsCurrentProcessHasEntitlement";
        __int16 v33 = 2114;
        BOOL v34 = v1;
        __int16 v35 = 2114;
        CFErrorRef v36 = error;
        uint64_t v9 = "%{public}s SecTaskCopyValueForEntitlement %{public}@ error %{public}@ failed, backtrace limit exceeded";
        goto LABEL_38;
      }
      uint64_t v15 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v7 = (id)gLogObj;
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v7, type);
      if (!v15)
      {
        if (!v17)
        {
LABEL_40:

          if (!v6)
          {
LABEL_18:
            if (error)
            {
              CFRelease(error);
              CFErrorRef error = 0;
            }
            goto LABEL_20;
          }
LABEL_17:
          free(v6);
          goto LABEL_18;
        }
        *(_DWORD *)unsigned int buf = 136446722;
        socklen_t v32 = "NWUtilsCurrentProcessHasEntitlement";
        __int16 v33 = 2114;
        BOOL v34 = v1;
        __int16 v35 = 2114;
        CFErrorRef v36 = error;
        uint64_t v9 = "%{public}s SecTaskCopyValueForEntitlement %{public}@ error %{public}@ failed, no backtrace";
        __int16 v24 = v7;
        os_log_type_t v25 = v16;
LABEL_39:
        _os_log_impl(&dword_1830D4000, v24, v25, v9, buf, 0x20u);
        goto LABEL_40;
      }
      if (v17)
      {
        *(_DWORD *)unsigned int buf = 136446978;
        socklen_t v32 = "NWUtilsCurrentProcessHasEntitlement";
        __int16 v33 = 2114;
        BOOL v34 = v1;
        __int16 v35 = 2114;
        CFErrorRef v36 = error;
        __int16 v37 = 2082;
        long long v38 = v15;
        _os_log_impl(&dword_1830D4000, v7, v16, "%{public}s SecTaskCopyValueForEntitlement %{public}@ error %{public}@ failed, dumping backtrace:%{public}s", buf, 0x2Au);
      }

      free(v15);
    }
    if (!v6) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
LABEL_20:
  if (v4)
  {
    CFTypeID v18 = CFGetTypeID(v4);
    BOOL v19 = v18 == CFBooleanGetTypeID() && CFBooleanGetValue((CFBooleanRef)v4) != 0;
    CFRelease(v4);
  }
  else
  {
    BOOL v19 = 0;
  }
  CFRelease(v3);
LABEL_35:

  return v19;
}

uint64_t *nw_protocol_recorder_identifier()
{
  if (nw_protocol_recorder_identifier::onceToken != -1) {
    dispatch_once(&nw_protocol_recorder_identifier::onceToken, &__block_literal_global_66528);
  }
  return &g_recorder_protocol_identifier;
}

BOOL __nw_protocol_recorder_identifier_block_invoke()
{
  unk_1E8F7A281 = 0;
  unk_1E8F7A279 = 0;
  qword_1E8F7A288 = 0;
  strcpy((char *)&g_recorder_protocol_identifier, "recorder");
  qword_1E8F7A290 = 0x100000000;
  qword_1E8F7A2A8 = (uint64_t)nw_protocol_default_replace_input_handler;
  qword_1E8F7A2D8 = (uint64_t)nw_protocol_default_input_available;
  qword_1E8F7A2E0 = (uint64_t)nw_protocol_default_output_available;
  qword_1E8F7A350 = (uint64_t)nw_protocol_default_input_finished;
  qword_1E8F7A358 = (uint64_t)nw_protocol_default_output_finished;
  qword_1E8F7A3A0 = (uint64_t)nw_protocol_default_input_flush;
  qword_1E8F7A390 = (uint64_t)nw_protocol_default_get_message_properties;
  qword_1E8F7A300 = (uint64_t)nw_protocol_default_link_state;
  qword_1E8F7A308 = (uint64_t)nw_protocol_default_get_parameters;
  qword_1E8F7A318 = (uint64_t)nw_protocol_default_get_local;
  qword_1E8F7A320 = (uint64_t)nw_protocol_default_get_remote;
  qword_1E8F7A310 = (uint64_t)nw_protocol_default_get_path;
  qword_1E8F7A340 = (uint64_t)nw_protocol_default_updated_path;
  qword_1E8F7A360 = (uint64_t)nw_protocol_default_get_output_local;
  qword_1E8F7A368 = (uint64_t)nw_protocol_default_get_output_interface;
  qword_1E8F7A2B0 = (uint64_t)nw_protocol_default_connect;
  qword_1E8F7A2B8 = (uint64_t)nw_protocol_default_disconnect;
  qword_1E8F7A2C0 = (uint64_t)nw_protocol_default_connected;
  qword_1E8F7A2C8 = (uint64_t)nw_protocol_default_disconnected;
  qword_1E8F7A2D0 = (uint64_t)nw_protocol_default_error;
  qword_1E8F7A398 = (uint64_t)nw_protocol_default_reset;
  qword_1E8F7A348 = (uint64_t)nw_protocol_default_supports_external_data;
  qword_1E8F7A370 = (uint64_t)nw_protocol_default_waiting_for_output;
  qword_1E8F7A378 = (uint64_t)nw_protocol_default_copy_info;
  qword_1E8F7A328 = (uint64_t)nw_protocol_default_register_notification;
  qword_1E8F7A330 = (uint64_t)nw_protocol_default_unregister_notification;
  qword_1E8F7A338 = (uint64_t)nw_protocol_default_notify;
  qword_1E8F7A380 = (uint64_t)nw_protocol_default_add_listen_handler;
  qword_1E8F7A388 = (uint64_t)nw_protocol_default_remove_listen_handler;
  g_recorder_protocol_callbacks = (uint64_t)nw_protocol_recorder_add_input_handler;
  qword_1E8F7A2A0 = (uint64_t)nw_protocol_recorder_remove_input_handler;
  qword_1E8F7A2E8 = (uint64_t)nw_protocol_recorder_get_input_frames;
  qword_1E8F7A2F0 = (uint64_t)nw_protocol_recorder_get_output_frames;
  qword_1E8F7A2F8 = (uint64_t)nw_protocol_recorder_finalize_output_frames;
  return nw_protocol_register(&g_recorder_protocol_identifier, (uint64_t)nw_protocol_recorder_create);
}

uint64_t nw_protocol_recorder_create(const nw_protocol_identifier *a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  memptr = 0;
  if (!malloc_type_posix_memalign(&memptr, 8uLL, 0x58uLL, 0x68FF3B34uLL))
  {
    uint64_t result = (uint64_t)memptr;
    if (memptr) {
      goto LABEL_3;
    }
  }
  id v2 = __nwlog_obj();
  os_log_type_enabled(v2, OS_LOG_TYPE_ERROR);
  int v5 = 136446722;
  uint64_t v6 = "strict_memalign";
  __int16 v7 = 2048;
  uint64_t v8 = 8;
  __int16 v9 = 2048;
  uint64_t v10 = 88;
  id v3 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort((uint64_t)v3);
  if (!result)
  {
    free(v3);
    uint64_t result = (uint64_t)memptr;
LABEL_3:
    *(void *)(result + 80) = 0;
    *(_OWORD *)(result + 48) = 0u;
    *(_OWORD *)(result + 64) = 0u;
    *(_OWORD *)(result + 16) = 0u;
    *(_OWORD *)(result + 32) = 0u;
    *(_OWORD *)uint64_t result = 0u;
    *(void *)(result + 16) = &g_recorder_protocol_identifier;
    *(void *)(result + 24) = &g_recorder_protocol_callbacks;
    *(void *)(result + 40) = result;
    return result;
  }
  __break(1u);
  return result;
}

uint64_t nw_protocol_recorder_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t handle = a1->handle;
    if (handle)
    {
      v15[0] = MEMORY[0x1E4F143A8];
      v15[1] = 0x40000000;
      os_log_type_t v16 = ___ZL43nw_protocol_recorder_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke;
      BOOL v17 = &__block_descriptor_tmp_15_66545;
      CFTypeID v18 = handle;
      tqh_first = a2->tqh_first;
      do
      {
        if (!tqh_first) {
          break;
        }
        CFTypeRef v4 = (nw_frame *)*((void *)tqh_first + 4);
        char v5 = ((uint64_t (*)(void *))v16)(v15);
        tqh_first = v4;
      }
      while ((v5 & 1) != 0);
      return (*(uint64_t (**)(void))(*(void *)(handle[4] + 24) + 96))();
    }
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v22 = "nw_protocol_recorder_finalize_output_frames";
    __int16 v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v20 = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (!__nwlog_fault(v7, &v20, &v19)) {
      goto LABEL_35;
    }
    if (v20 == OS_LOG_TYPE_FAULT)
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = v20;
      if (os_log_type_enabled(v8, v20))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        BOOL v22 = "nw_protocol_recorder_finalize_output_frames";
        uint64_t v10 = "%{public}s called with null recorder";
        goto LABEL_34;
      }
      goto LABEL_35;
    }
    if (!v19)
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = v20;
      if (os_log_type_enabled(v8, v20))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        BOOL v22 = "nw_protocol_recorder_finalize_output_frames";
        uint64_t v10 = "%{public}s called with null recorder, backtrace limit exceeded";
        goto LABEL_34;
      }
      goto LABEL_35;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v8 = __nwlog_obj();
    os_log_type_t v9 = v20;
    BOOL v14 = os_log_type_enabled(v8, v20);
    if (!backtrace_string)
    {
      if (v14)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        BOOL v22 = "nw_protocol_recorder_finalize_output_frames";
        uint64_t v10 = "%{public}s called with null recorder, no backtrace";
        goto LABEL_34;
      }
      goto LABEL_35;
    }
    if (v14)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      BOOL v22 = "nw_protocol_recorder_finalize_output_frames";
      __int16 v23 = 2082;
      __int16 v24 = backtrace_string;
      os_log_type_t v13 = "%{public}s called with null recorder, dumping backtrace:%{public}s";
      goto LABEL_24;
    }
    goto LABEL_25;
  }
  __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  BOOL v22 = "nw_protocol_recorder_finalize_output_frames";
  __int16 v7 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t v20 = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (!__nwlog_fault(v7, &v20, &v19)) {
    goto LABEL_35;
  }
  if (v20 != OS_LOG_TYPE_FAULT)
  {
    if (!v19)
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = v20;
      if (os_log_type_enabled(v8, v20))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        BOOL v22 = "nw_protocol_recorder_finalize_output_frames";
        uint64_t v10 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_34;
      }
      goto LABEL_35;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v8 = __nwlog_obj();
    os_log_type_t v9 = v20;
    BOOL v12 = os_log_type_enabled(v8, v20);
    if (!backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        BOOL v22 = "nw_protocol_recorder_finalize_output_frames";
        uint64_t v10 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_34;
      }
      goto LABEL_35;
    }
    if (v12)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      BOOL v22 = "nw_protocol_recorder_finalize_output_frames";
      __int16 v23 = 2082;
      __int16 v24 = backtrace_string;
      os_log_type_t v13 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_24:
      _os_log_impl(&dword_1830D4000, v8, v9, v13, buf, 0x16u);
    }
LABEL_25:
    free(backtrace_string);
    goto LABEL_35;
  }
  uint64_t v8 = __nwlog_obj();
  os_log_type_t v9 = v20;
  if (os_log_type_enabled(v8, v20))
  {
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v22 = "nw_protocol_recorder_finalize_output_frames";
    uint64_t v10 = "%{public}s called with null protocol";
LABEL_34:
    _os_log_impl(&dword_1830D4000, v8, v9, v10, buf, 0xCu);
  }
LABEL_35:
  if (v7) {
    free(v7);
  }
  return 0;
}

uint64_t ___ZL43nw_protocol_recorder_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  int v25 = 0;
  if (!nw_frame_unclaimed_bytes(a2, &v25) || !v25) {
    return 1;
  }
  if (pcap_ng_block_alloc_delayInitStub(v3))
  {
    pcap_ng_block_reset_delayInitStub(v4);
    uint64_t enhanced_packet_fields_delayInitStub = pcap_ng_get_enhanced_packet_fields_delayInitStub(v5);
    uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 64);
    uint64_t v8 = mach_continuous_time();
    if (v8 <= 1) {
      uint64_t v9 = 1;
    }
    else {
      uint64_t v9 = v8;
    }
    *(_DWORD *)(enhanced_packet_fields_delayInitStub + 4) = nw_delta_nanos(v7, v9) / 0x3B9ACA00uLL;
    uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 64);
    uint64_t v11 = mach_continuous_time();
    if (v11 <= 1) {
      uint64_t v12 = 1;
    }
    else {
      uint64_t v12 = v11;
    }
    *(_DWORD *)(enhanced_packet_fields_delayInitStub + 8) = nw_delta_nanos(v10, v12) / 0xF4240uLL;
    pcap_ng_block_packet_set_data_delayInitStub(v13);
    pcap_ng_dump_block_delayInitStub(v14);
    pcap_ng_free_block_delayInitStub(v15);
    return 1;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)unsigned int buf = 136446466;
  os_log_type_t v27 = "nw_protocol_recorder_finalize_output_frames_block_invoke";
  __int16 v28 = 1024;
  int v29 = v25 + 2048;
  os_log_type_t v16 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (__nwlog_fault(v16, &type, &v23))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v17 = gLogObj;
      os_log_type_t v18 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      os_log_type_t v27 = "nw_protocol_recorder_finalize_output_frames_block_invoke";
      __int16 v28 = 1024;
      int v29 = v25 + 2048;
      char v19 = "%{public}s pcap_ng_block_alloc(%u) failed";
      goto LABEL_24;
    }
    if (!v23)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v17 = gLogObj;
      os_log_type_t v18 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      os_log_type_t v27 = "nw_protocol_recorder_finalize_output_frames_block_invoke";
      __int16 v28 = 1024;
      int v29 = v25 + 2048;
      char v19 = "%{public}s pcap_ng_block_alloc(%u) failed, backtrace limit exceeded";
      goto LABEL_24;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v17 = gLogObj;
    os_log_type_t v18 = type;
    BOOL v21 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)unsigned int buf = 136446722;
        os_log_type_t v27 = "nw_protocol_recorder_finalize_output_frames_block_invoke";
        __int16 v28 = 1024;
        int v29 = v25 + 2048;
        __int16 v30 = 2082;
        uint64_t v31 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s pcap_ng_block_alloc(%u) failed, dumping backtrace:%{public}s", buf, 0x1Cu);
      }
      free(backtrace_string);
      goto LABEL_25;
    }
    if (v21)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      os_log_type_t v27 = "nw_protocol_recorder_finalize_output_frames_block_invoke";
      __int16 v28 = 1024;
      int v29 = v25 + 2048;
      char v19 = "%{public}s pcap_ng_block_alloc(%u) failed, no backtrace";
LABEL_24:
      _os_log_impl(&dword_1830D4000, v17, v18, v19, buf, 0x12u);
    }
  }
LABEL_25:
  if (v16) {
    free(v16);
  }
  return 1;
}

uint64_t nw_protocol_recorder_get_output_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    os_log_type_t v20 = "nw_protocol_recorder_get_output_frames";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (!__nwlog_fault(v9, &type, &v17)) {
      goto LABEL_34;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v20 = "nw_protocol_recorder_get_output_frames";
      uint64_t v12 = "%{public}s called with null protocol";
      goto LABEL_33;
    }
    if (!v17)
    {
      uint64_t v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v20 = "nw_protocol_recorder_get_output_frames";
      uint64_t v12 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_33;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v10 = __nwlog_obj();
    os_log_type_t v11 = type;
    BOOL v14 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (!v14) {
        goto LABEL_34;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v20 = "nw_protocol_recorder_get_output_frames";
      uint64_t v12 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_33;
    }
    if (v14)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      os_log_type_t v20 = "nw_protocol_recorder_get_output_frames";
      __int16 v21 = 2082;
      BOOL v22 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_34:
    if (!v9) {
      return 0;
    }
LABEL_35:
    free(v9);
    return 0;
  }
  uint64_t handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    os_log_type_t v20 = "nw_protocol_recorder_get_output_frames";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (!__nwlog_fault(v9, &type, &v17)) {
      goto LABEL_34;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v20 = "nw_protocol_recorder_get_output_frames";
      uint64_t v12 = "%{public}s called with null recorder";
      goto LABEL_33;
    }
    if (!v17)
    {
      uint64_t v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v20 = "nw_protocol_recorder_get_output_frames";
      uint64_t v12 = "%{public}s called with null recorder, backtrace limit exceeded";
      goto LABEL_33;
    }
    double v15 = (char *)__nw_create_backtrace_string();
    uint64_t v10 = __nwlog_obj();
    os_log_type_t v11 = type;
    BOOL v16 = os_log_type_enabled(v10, type);
    if (v15)
    {
      if (v16)
      {
        *(_DWORD *)unsigned int buf = 136446466;
        os_log_type_t v20 = "nw_protocol_recorder_get_output_frames";
        __int16 v21 = 2082;
        BOOL v22 = v15;
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null recorder, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v15);
      if (!v9) {
        return 0;
      }
      goto LABEL_35;
    }
    if (v16)
    {
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v20 = "nw_protocol_recorder_get_output_frames";
      uint64_t v12 = "%{public}s called with null recorder, no backtrace";
LABEL_33:
      _os_log_impl(&dword_1830D4000, v10, v11, v12, buf, 0xCu);
      goto LABEL_34;
    }
    goto LABEL_34;
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)(handle[4] + 24) + 88);

  return v7();
}

uint64_t ___ZL37nw_protocol_recorder_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  int v25 = 0;
  if (!nw_frame_unclaimed_bytes(a2, &v25) || !v25) {
    return 1;
  }
  if (pcap_ng_block_alloc_delayInitStub(v3))
  {
    pcap_ng_block_reset_delayInitStub(v4);
    uint64_t enhanced_packet_fields_delayInitStub = pcap_ng_get_enhanced_packet_fields_delayInitStub(v5);
    uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 64);
    uint64_t v8 = mach_continuous_time();
    if (v8 <= 1) {
      uint64_t v9 = 1;
    }
    else {
      uint64_t v9 = v8;
    }
    *(_DWORD *)(enhanced_packet_fields_delayInitStub + 4) = nw_delta_nanos(v7, v9) / 0x3B9ACA00uLL;
    uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 64);
    uint64_t v11 = mach_continuous_time();
    if (v11 <= 1) {
      uint64_t v12 = 1;
    }
    else {
      uint64_t v12 = v11;
    }
    *(_DWORD *)(enhanced_packet_fields_delayInitStub + 8) = nw_delta_nanos(v10, v12) / 0xF4240uLL;
    pcap_ng_block_packet_set_data_delayInitStub(v13);
    pcap_ng_dump_block_delayInitStub(v14);
    pcap_ng_free_block_delayInitStub(v15);
    return 1;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)unsigned int buf = 136446466;
  os_log_type_t v27 = "nw_protocol_recorder_get_input_frames_block_invoke";
  __int16 v28 = 1024;
  int v29 = v25 + 2048;
  BOOL v16 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (__nwlog_fault(v16, &type, &v23))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v17 = gLogObj;
      os_log_type_t v18 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      os_log_type_t v27 = "nw_protocol_recorder_get_input_frames_block_invoke";
      __int16 v28 = 1024;
      int v29 = v25 + 2048;
      char v19 = "%{public}s pcap_ng_block_alloc(%u) failed";
      goto LABEL_24;
    }
    if (!v23)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v17 = gLogObj;
      os_log_type_t v18 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      os_log_type_t v27 = "nw_protocol_recorder_get_input_frames_block_invoke";
      __int16 v28 = 1024;
      int v29 = v25 + 2048;
      char v19 = "%{public}s pcap_ng_block_alloc(%u) failed, backtrace limit exceeded";
      goto LABEL_24;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v17 = gLogObj;
    os_log_type_t v18 = type;
    BOOL v21 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)unsigned int buf = 136446722;
        os_log_type_t v27 = "nw_protocol_recorder_get_input_frames_block_invoke";
        __int16 v28 = 1024;
        int v29 = v25 + 2048;
        __int16 v30 = 2082;
        uint64_t v31 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s pcap_ng_block_alloc(%u) failed, dumping backtrace:%{public}s", buf, 0x1Cu);
      }
      free(backtrace_string);
      goto LABEL_25;
    }
    if (v21)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      os_log_type_t v27 = "nw_protocol_recorder_get_input_frames_block_invoke";
      __int16 v28 = 1024;
      int v29 = v25 + 2048;
      char v19 = "%{public}s pcap_ng_block_alloc(%u) failed, no backtrace";
LABEL_24:
      _os_log_impl(&dword_1830D4000, v17, v18, v19, buf, 0x12u);
    }
  }
LABEL_25:
  if (v16) {
    free(v16);
  }
  return 1;
}

uint64_t nw_protocol_recorder_remove_input_handler(nw_protocol *a1, nw_protocol *a2, int a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v21 = "nw_protocol_recorder_remove_input_handler";
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (!__nwlog_fault(v10, &type, &v18)) {
      goto LABEL_44;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v18)
      {
        uint64_t v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (!os_log_type_enabled(v11, type)) {
          goto LABEL_44;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        BOOL v21 = "nw_protocol_recorder_remove_input_handler";
        double v13 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_43;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (!v15) {
          goto LABEL_44;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        BOOL v21 = "nw_protocol_recorder_remove_input_handler";
        double v13 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_43;
      }
      if (v15)
      {
        *(_DWORD *)unsigned int buf = 136446466;
        BOOL v21 = "nw_protocol_recorder_remove_input_handler";
        __int16 v22 = 2082;
        char v23 = backtrace_string;
        BOOL v16 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_33:
        _os_log_impl(&dword_1830D4000, v11, v12, v16, buf, 0x16u);
      }
LABEL_34:
      free(backtrace_string);
      goto LABEL_44;
    }
    uint64_t v11 = __nwlog_obj();
    os_log_type_t v12 = type;
    if (!os_log_type_enabled(v11, type)) {
      goto LABEL_44;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v21 = "nw_protocol_recorder_remove_input_handler";
    double v13 = "%{public}s called with null protocol";
LABEL_43:
    _os_log_impl(&dword_1830D4000, v11, v12, v13, buf, 0xCu);
LABEL_44:
    if (v10) {
      free(v10);
    }
    return 0;
  }
  uint64_t handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v21 = "nw_protocol_recorder_remove_input_handler";
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (!__nwlog_fault(v10, &type, &v18)) {
      goto LABEL_44;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_44;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      BOOL v21 = "nw_protocol_recorder_remove_input_handler";
      double v13 = "%{public}s called with null recorder";
      goto LABEL_43;
    }
    if (!v18)
    {
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_44;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      BOOL v21 = "nw_protocol_recorder_remove_input_handler";
      double v13 = "%{public}s called with null recorder, backtrace limit exceeded";
      goto LABEL_43;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v11 = __nwlog_obj();
    os_log_type_t v12 = type;
    BOOL v17 = os_log_type_enabled(v11, type);
    if (backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)unsigned int buf = 136446466;
        BOOL v21 = "nw_protocol_recorder_remove_input_handler";
        __int16 v22 = 2082;
        char v23 = backtrace_string;
        BOOL v16 = "%{public}s called with null recorder, dumping backtrace:%{public}s";
        goto LABEL_33;
      }
      goto LABEL_34;
    }
    if (!v17) {
      goto LABEL_44;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v21 = "nw_protocol_recorder_remove_input_handler";
    double v13 = "%{public}s called with null recorder, no backtrace";
    goto LABEL_43;
  }
  if (a2->output_handler == a1) {
    nw_protocol_set_output_handler((uint64_t)a2, 0);
  }
  if (a1->default_input_handler != a2) {
    return 0;
  }
  nw_protocol_set_input_handler((uint64_t)a1, 0);
  output_handler = a1->output_handler;
  if (output_handler) {
    ((void (*)(void))output_handler->callbacks->remove_input_handler)();
  }
  if (a3)
  {
    if (handle[10])
    {
      pcap_ng_dump_close_delayInitStub(v8);
      handle[10] = 0;
    }
    if (handle[9]) {
      pcap_close_delayInitStub(v8);
    }
    a1->uint64_t handle = 0;
    free(handle);
  }
  return 1;
}

uint64_t nw_protocol_recorder_add_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    LODWORD(v40[0]) = 136446210;
    *(void *)((char *)v40 + 4) = "nw_protocol_recorder_add_input_handler";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    __str[0] = 16;
    out[0] = 0;
    if (!__nwlog_fault(v11, __str, out)) {
      goto LABEL_41;
    }
    if (__str[0] == 17)
    {
      __int16 v28 = __nwlog_obj();
      char v29 = __str[0];
      if (!os_log_type_enabled(v28, (os_log_type_t)__str[0])) {
        goto LABEL_41;
      }
      LODWORD(v40[0]) = 136446210;
      *(void *)((char *)v40 + 4) = "nw_protocol_recorder_add_input_handler";
      double v14 = "%{public}s called with null protocol";
      goto LABEL_69;
    }
    if (out[0])
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v28 = __nwlog_obj();
      char v29 = __str[0];
      BOOL v30 = os_log_type_enabled(v28, (os_log_type_t)__str[0]);
      if (backtrace_string)
      {
        if (!v30) {
          goto LABEL_24;
        }
        LODWORD(v40[0]) = 136446466;
        *(void *)((char *)v40 + 4) = "nw_protocol_recorder_add_input_handler";
        WORD6(v40[0]) = 2082;
        *(void *)((char *)v40 + 14) = backtrace_string;
        BOOL v17 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
        goto LABEL_60;
      }
      if (!v30) {
        goto LABEL_41;
      }
      LODWORD(v40[0]) = 136446210;
      *(void *)((char *)v40 + 4) = "nw_protocol_recorder_add_input_handler";
      double v14 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      __int16 v28 = __nwlog_obj();
      char v29 = __str[0];
      if (!os_log_type_enabled(v28, (os_log_type_t)__str[0])) {
        goto LABEL_41;
      }
      LODWORD(v40[0]) = 136446210;
      *(void *)((char *)v40 + 4) = "nw_protocol_recorder_add_input_handler";
      double v14 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_69:
    uint64_t v24 = (uint8_t *)v40;
    int v25 = v28;
    os_log_type_t v26 = v29;
    uint32_t v27 = 12;
    goto LABEL_40;
  }
  uint64_t handle = (unsigned __int8 *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    LODWORD(v40[0]) = 136446210;
    *(void *)((char *)v40 + 4) = "nw_protocol_recorder_add_input_handler";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    __str[0] = 16;
    out[0] = 0;
    if (!__nwlog_fault(v11, __str, out)) {
      goto LABEL_41;
    }
    if (__str[0] == 17)
    {
      __int16 v28 = __nwlog_obj();
      char v29 = __str[0];
      if (!os_log_type_enabled(v28, (os_log_type_t)__str[0])) {
        goto LABEL_41;
      }
      LODWORD(v40[0]) = 136446210;
      *(void *)((char *)v40 + 4) = "nw_protocol_recorder_add_input_handler";
      double v14 = "%{public}s called with null recorder";
      goto LABEL_69;
    }
    if (out[0])
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v28 = __nwlog_obj();
      char v29 = __str[0];
      BOOL v31 = os_log_type_enabled(v28, (os_log_type_t)__str[0]);
      if (backtrace_string)
      {
        if (!v31) {
          goto LABEL_24;
        }
        LODWORD(v40[0]) = 136446466;
        *(void *)((char *)v40 + 4) = "nw_protocol_recorder_add_input_handler";
        WORD6(v40[0]) = 2082;
        *(void *)((char *)v40 + 14) = backtrace_string;
        BOOL v17 = "%{public}s called with null recorder, dumping backtrace:%{public}s";
LABEL_60:
        char v18 = (uint8_t *)v40;
        char v19 = v28;
        os_log_type_t v20 = v29;
        uint32_t v21 = 22;
        goto LABEL_23;
      }
      if (!v31) {
        goto LABEL_41;
      }
      LODWORD(v40[0]) = 136446210;
      *(void *)((char *)v40 + 4) = "nw_protocol_recorder_add_input_handler";
      double v14 = "%{public}s called with null recorder, no backtrace";
    }
    else
    {
      __int16 v28 = __nwlog_obj();
      char v29 = __str[0];
      if (!os_log_type_enabled(v28, (os_log_type_t)__str[0])) {
        goto LABEL_41;
      }
      LODWORD(v40[0]) = 136446210;
      *(void *)((char *)v40 + 4) = "nw_protocol_recorder_add_input_handler";
      double v14 = "%{public}s called with null recorder, backtrace limit exceeded";
    }
    goto LABEL_69;
  }
  nw_protocol_set_input_handler((uint64_t)a1, (uint64_t)a2);
  *(_OWORD *)uint64_t handle = *(_OWORD *)a2->flow_id;
  if (!a2->output_handler) {
    nw_protocol_set_output_handler((uint64_t)a2, (uint64_t)handle);
  }
  uint64_t v4 = mach_continuous_time();
  if (v4 <= 1) {
    uint64_t v5 = 1;
  }
  else {
    uint64_t v5 = v4;
  }
  *((void *)handle + 8) = v5;
  memset(out, 0, 37);
  uuid_unparse_upper(handle, out);
  snprintf(__str, 0x80uLL, "/var/tmp/nw-%s-%s.pcap", a2->identifier->name, out);
  __str[127] = 0;
  memset(v40, 0, sizeof(v40));
  uint64_t delayInitStub = pcap_create_delayInitStub(0.0);
  *((void *)handle + 9) = delayInitStub;
  if (!delayInitStub)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)unsigned int buf = 136446466;
    __int16 v35 = "nw_protocol_recorder_add_input_handler";
    __int16 v36 = 2082;
    __int16 v37 = (char *)v40;
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (!__nwlog_fault(v11, &type, &v32)) {
      goto LABEL_41;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v12 = gLogObj;
      os_log_type_t v13 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      __int16 v35 = "nw_protocol_recorder_add_input_handler";
      __int16 v36 = 2082;
      __int16 v37 = (char *)v40;
      double v14 = "%{public}s pcap_create: %{public}s failed";
LABEL_39:
      uint64_t v24 = buf;
      int v25 = v12;
      os_log_type_t v26 = v13;
      uint32_t v27 = 22;
LABEL_40:
      _os_log_impl(&dword_1830D4000, v25, v26, v14, v24, v27);
      goto LABEL_41;
    }
    if (!v32)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v12 = gLogObj;
      os_log_type_t v13 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      __int16 v35 = "nw_protocol_recorder_add_input_handler";
      __int16 v36 = 2082;
      __int16 v37 = (char *)v40;
      double v14 = "%{public}s pcap_create: %{public}s failed, backtrace limit exceeded";
      goto LABEL_39;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v12 = gLogObj;
    os_log_type_t v13 = type;
    BOOL v16 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v16) {
        goto LABEL_41;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      __int16 v35 = "nw_protocol_recorder_add_input_handler";
      __int16 v36 = 2082;
      __int16 v37 = (char *)v40;
      double v14 = "%{public}s pcap_create: %{public}s failed, no backtrace";
      goto LABEL_39;
    }
    if (v16)
    {
      *(_DWORD *)unsigned int buf = 136446722;
      __int16 v35 = "nw_protocol_recorder_add_input_handler";
      __int16 v36 = 2082;
      __int16 v37 = (char *)v40;
      __int16 v38 = 2082;
      uint64_t v39 = backtrace_string;
      BOOL v17 = "%{public}s pcap_create: %{public}s failed, dumping backtrace:%{public}s";
      char v18 = buf;
      char v19 = v12;
      os_log_type_t v20 = v13;
      uint32_t v21 = 32;
LABEL_23:
      _os_log_impl(&dword_1830D4000, v19, v20, v17, v18, v21);
    }
LABEL_24:
    free(backtrace_string);
    if (!v11) {
      return 0;
    }
    goto LABEL_42;
  }
  pcap_activate_delayInitStub(v7);
  uint64_t inited = pcap_ng_dump_open_delayInitStub(v8);
  *((void *)handle + 10) = inited;
  if (inited) {
    return 1;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)unsigned int buf = 136446466;
  __int16 v35 = "nw_protocol_recorder_add_input_handler";
  __int16 v36 = 2082;
  __int16 v37 = __str;
  uint64_t v11 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v32 = 0;
  if (__nwlog_fault(v11, &type, &v32))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v12 = gLogObj;
      os_log_type_t v13 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      __int16 v35 = "nw_protocol_recorder_add_input_handler";
      __int16 v36 = 2082;
      __int16 v37 = __str;
      double v14 = "%{public}s pcap_create: %{public}s failed";
      goto LABEL_39;
    }
    if (!v32)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v12 = gLogObj;
      os_log_type_t v13 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      __int16 v35 = "nw_protocol_recorder_add_input_handler";
      __int16 v36 = 2082;
      __int16 v37 = __str;
      double v14 = "%{public}s pcap_create: %{public}s failed, backtrace limit exceeded";
      goto LABEL_39;
    }
    __int16 v22 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v12 = gLogObj;
    os_log_type_t v13 = type;
    BOOL v23 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v22)
    {
      if (!v23) {
        goto LABEL_41;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      __int16 v35 = "nw_protocol_recorder_add_input_handler";
      __int16 v36 = 2082;
      __int16 v37 = __str;
      double v14 = "%{public}s pcap_create: %{public}s failed, no backtrace";
      goto LABEL_39;
    }
    if (v23)
    {
      *(_DWORD *)unsigned int buf = 136446722;
      __int16 v35 = "nw_protocol_recorder_add_input_handler";
      __int16 v36 = 2082;
      __int16 v37 = __str;
      __int16 v38 = 2082;
      uint64_t v39 = v22;
      _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s pcap_create: %{public}s failed, dumping backtrace:%{public}s", buf, 0x20u);
    }
    free(v22);
  }
LABEL_41:
  if (v11) {
LABEL_42:
  }
    free(v11);
  return 0;
}

BOOL nw_http_oblivious_config_is_valid(unsigned __int16 *a1, uint64_t a2)
{
  return nw_http_oblivious_config_select(a1, a2, 0) != 0;
}

unsigned __int16 *nw_http_oblivious_config_select(unsigned __int16 *a1, uint64_t a2, void *a3)
{
  double v3 = 0;
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return v3;
  }
  unint64_t v4 = a2;
  if ((unint64_t)a2 < 0x29) {
    return v3;
  }
  if (*(unsigned __int16 *)((char *)a1 + 1) == 0x2000)
  {
    if (*(unsigned __int16 *)((char *)a1 + 37) == 256 && *(unsigned __int16 *)((char *)a1 + 39) == 256) {
      goto LABEL_40;
    }
    if (a2 < 45) {
      goto LABEL_7;
    }
    unint64_t v17 = (unint64_t)a1 + a2;
    char v18 = (char *)a1 + 45;
    char v19 = (unsigned __int16 *)((char *)a1 + 41);
    while (1)
    {
      os_log_type_t v20 = v18;
      if (*v19 == 256)
      {
        int v21 = (unsigned __int16)v19[1];
        if (v21 == 256 || (unint64_t)v20 >= v17)
        {
          if (v21 != 256) {
            goto LABEL_7;
          }
LABEL_40:
          if (a3) {
            *a3 = a2;
          }
          return a1;
        }
      }
      else if ((unint64_t)v18 >= v17)
      {
        goto LABEL_7;
      }
      char v18 = (char *)(v20 + 2);
      char v19 = v20;
      if ((unint64_t)(v20 + 2) > v17) {
        goto LABEL_7;
      }
    }
  }
  while (1)
  {
LABEL_7:
    double v3 = a1 + 1;
    unint64_t v5 = bswap32(*a1) >> 16;
    unint64_t v6 = v4 - 2;
    if (v4 - 2 < v5) {
      return 0;
    }
    if (v5 >= 0x29 && *(unsigned __int16 *)((char *)a1 + 3) == 0x2000) {
      break;
    }
LABEL_23:
    unint64_t v4 = v6 - v5;
    if (v6 < v5)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)unsigned int buf = 136446978;
      char v29 = "nw_http_oblivious_config_select";
      __int16 v30 = 2082;
      BOOL v31 = "remaining_length";
      __int16 v32 = 2048;
      unint64_t v33 = v5;
      __int16 v34 = 2048;
      unint64_t v35 = v4;
      os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v26 = 0;
      if (!__nwlog_fault(v13, &type, &v26)) {
        goto LABEL_56;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        double v14 = gLogObj;
        os_log_type_t v15 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)unsigned int buf = 136446978;
          char v29 = "nw_http_oblivious_config_select";
          __int16 v30 = 2082;
          BOOL v31 = "remaining_length";
          __int16 v32 = 2048;
          unint64_t v33 = v5;
          __int16 v34 = 2048;
          unint64_t v35 = v4;
          BOOL v16 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
          goto LABEL_55;
        }
        goto LABEL_56;
      }
      if (v26)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        double v14 = gLogObj;
        os_log_type_t v15 = type;
        BOOL v24 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (backtrace_string)
        {
          if (v24)
          {
            *(_DWORD *)unsigned int buf = 136447234;
            char v29 = "nw_http_oblivious_config_select";
            __int16 v30 = 2082;
            BOOL v31 = "remaining_length";
            __int16 v32 = 2048;
            unint64_t v33 = v5;
            __int16 v34 = 2048;
            unint64_t v35 = v4;
            __int16 v36 = 2082;
            __int16 v37 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(backtrace_string);
          goto LABEL_56;
        }
        if (!v24)
        {
LABEL_56:
          if (v13) {
            free(v13);
          }
          return 0;
        }
        *(_DWORD *)unsigned int buf = 136446978;
        char v29 = "nw_http_oblivious_config_select";
        __int16 v30 = 2082;
        BOOL v31 = "remaining_length";
        __int16 v32 = 2048;
        unint64_t v33 = v5;
        __int16 v34 = 2048;
        unint64_t v35 = v4;
        BOOL v16 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        double v14 = gLogObj;
        os_log_type_t v15 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_56;
        }
        *(_DWORD *)unsigned int buf = 136446978;
        char v29 = "nw_http_oblivious_config_select";
        __int16 v30 = 2082;
        BOOL v31 = "remaining_length";
        __int16 v32 = 2048;
        unint64_t v33 = v5;
        __int16 v34 = 2048;
        unint64_t v35 = v4;
        BOOL v16 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
      }
LABEL_55:
      _os_log_impl(&dword_1830D4000, v14, v15, v16, buf, 0x2Au);
      goto LABEL_56;
    }
    a1 = (unsigned __int16 *)((char *)v3 + v5);
    if (v4 <= 2) {
      return 0;
    }
  }
  if (*(unsigned __int16 *)((char *)a1 + 39) == 256 && *(unsigned __int16 *)((char *)a1 + 41) == 256) {
    goto LABEL_51;
  }
  if (v5 < 0x2D) {
    goto LABEL_23;
  }
  unint64_t v7 = (unint64_t)a1 + v5 + 2;
  double v8 = (char *)a1 + 47;
  uint64_t v9 = (unsigned __int16 *)((char *)a1 + 43);
  while (1)
  {
    uint64_t v10 = v8;
    if (*v9 != 256)
    {
      if ((unint64_t)v8 >= v7) {
        goto LABEL_23;
      }
      goto LABEL_15;
    }
    int v11 = (unsigned __int16)v9[1];
    if (v11 == 256 || (unint64_t)v10 >= v7) {
      break;
    }
LABEL_15:
    double v8 = (char *)(v10 + 2);
    uint64_t v9 = v10;
    if ((unint64_t)(v10 + 2) > v7) {
      goto LABEL_23;
    }
  }
  if (v11 != 256) {
    goto LABEL_23;
  }
LABEL_51:
  if (a3) {
    *a3 = v5;
  }
  return v3;
}

BOOL nw_http_encrypt_chunked_oblivious_request_header(const char *a1, unsigned __int16 *a2, uint64_t a3, char **a4, void *a5, void *a6, size_t *a7, void *a8)
{
  uint64_t v70 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    unint64_t v33 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v62) = 0;
    if (!__nwlog_fault(v33, type, &v62)) {
      goto LABEL_139;
    }
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!(_BYTE)v62)
      {
        __int16 v34 = __nwlog_obj();
        os_log_type_t v35 = type[0];
        if (os_log_type_enabled(v34, type[0]))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
          __int16 v36 = "%{public}s called with null media_type, backtrace limit exceeded";
          goto LABEL_138;
        }
        goto LABEL_139;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v34 = __nwlog_obj();
      os_log_type_t v35 = type[0];
      BOOL v38 = os_log_type_enabled(v34, type[0]);
      if (!backtrace_string)
      {
        if (v38)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
          __int16 v36 = "%{public}s called with null media_type, no backtrace";
          goto LABEL_138;
        }
        goto LABEL_139;
      }
      if (!v38) {
        goto LABEL_97;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
      __int16 v66 = 2082;
      uint64_t v67 = (uint64_t)backtrace_string;
      uint64_t v39 = "%{public}s called with null media_type, dumping backtrace:%{public}s";
      goto LABEL_96;
    }
    __int16 v34 = __nwlog_obj();
    os_log_type_t v35 = type[0];
    if (!os_log_type_enabled(v34, type[0])) {
      goto LABEL_139;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    __int16 v36 = "%{public}s called with null media_type";
LABEL_138:
    _os_log_impl(&dword_1830D4000, v34, v35, v36, buf, 0xCu);
    goto LABEL_139;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    unint64_t v33 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v62) = 0;
    if (!__nwlog_fault(v33, type, &v62)) {
      goto LABEL_139;
    }
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!(_BYTE)v62)
      {
        __int16 v34 = __nwlog_obj();
        os_log_type_t v35 = type[0];
        if (os_log_type_enabled(v34, type[0]))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
          __int16 v36 = "%{public}s called with null config_buffer, backtrace limit exceeded";
          goto LABEL_138;
        }
        goto LABEL_139;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v34 = __nwlog_obj();
      os_log_type_t v35 = type[0];
      BOOL v40 = os_log_type_enabled(v34, type[0]);
      if (!backtrace_string)
      {
        if (v40)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
          __int16 v36 = "%{public}s called with null config_buffer, no backtrace";
          goto LABEL_138;
        }
        goto LABEL_139;
      }
      if (!v40) {
        goto LABEL_97;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
      __int16 v66 = 2082;
      uint64_t v67 = (uint64_t)backtrace_string;
      uint64_t v39 = "%{public}s called with null config_buffer, dumping backtrace:%{public}s";
      goto LABEL_96;
    }
    __int16 v34 = __nwlog_obj();
    os_log_type_t v35 = type[0];
    if (!os_log_type_enabled(v34, type[0])) {
      goto LABEL_139;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    __int16 v36 = "%{public}s called with null config_buffer";
    goto LABEL_138;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    unint64_t v33 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v62) = 0;
    if (!__nwlog_fault(v33, type, &v62)) {
      goto LABEL_139;
    }
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!(_BYTE)v62)
      {
        __int16 v34 = __nwlog_obj();
        os_log_type_t v35 = type[0];
        if (os_log_type_enabled(v34, type[0]))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
          __int16 v36 = "%{public}s called with null in_config_length, backtrace limit exceeded";
          goto LABEL_138;
        }
        goto LABEL_139;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v34 = __nwlog_obj();
      os_log_type_t v35 = type[0];
      BOOL v41 = os_log_type_enabled(v34, type[0]);
      if (!backtrace_string)
      {
        if (v41)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
          __int16 v36 = "%{public}s called with null in_config_length, no backtrace";
          goto LABEL_138;
        }
        goto LABEL_139;
      }
      if (!v41) {
        goto LABEL_97;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
      __int16 v66 = 2082;
      uint64_t v67 = (uint64_t)backtrace_string;
      uint64_t v39 = "%{public}s called with null in_config_length, dumping backtrace:%{public}s";
      goto LABEL_96;
    }
    __int16 v34 = __nwlog_obj();
    os_log_type_t v35 = type[0];
    if (!os_log_type_enabled(v34, type[0])) {
      goto LABEL_139;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    __int16 v36 = "%{public}s called with null in_config_length";
    goto LABEL_138;
  }
  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    unint64_t v33 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v62) = 0;
    if (!__nwlog_fault(v33, type, &v62)) {
      goto LABEL_139;
    }
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!(_BYTE)v62)
      {
        __int16 v34 = __nwlog_obj();
        os_log_type_t v35 = type[0];
        if (os_log_type_enabled(v34, type[0]))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
          __int16 v36 = "%{public}s called with null out_context, backtrace limit exceeded";
          goto LABEL_138;
        }
        goto LABEL_139;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v34 = __nwlog_obj();
      os_log_type_t v35 = type[0];
      BOOL v42 = os_log_type_enabled(v34, type[0]);
      if (!backtrace_string)
      {
        if (v42)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
          __int16 v36 = "%{public}s called with null out_context, no backtrace";
          goto LABEL_138;
        }
        goto LABEL_139;
      }
      if (!v42) {
        goto LABEL_97;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
      __int16 v66 = 2082;
      uint64_t v67 = (uint64_t)backtrace_string;
      uint64_t v39 = "%{public}s called with null out_context, dumping backtrace:%{public}s";
      goto LABEL_96;
    }
    __int16 v34 = __nwlog_obj();
    os_log_type_t v35 = type[0];
    if (!os_log_type_enabled(v34, type[0])) {
      goto LABEL_139;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    __int16 v36 = "%{public}s called with null out_context";
    goto LABEL_138;
  }
  if (!a5)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    unint64_t v33 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v62) = 0;
    if (!__nwlog_fault(v33, type, &v62)) {
      goto LABEL_139;
    }
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!(_BYTE)v62)
      {
        __int16 v34 = __nwlog_obj();
        os_log_type_t v35 = type[0];
        if (os_log_type_enabled(v34, type[0]))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
          __int16 v36 = "%{public}s called with null out_context_length, backtrace limit exceeded";
          goto LABEL_138;
        }
        goto LABEL_139;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v34 = __nwlog_obj();
      os_log_type_t v35 = type[0];
      BOOL v43 = os_log_type_enabled(v34, type[0]);
      if (!backtrace_string)
      {
        if (v43)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
          __int16 v36 = "%{public}s called with null out_context_length, no backtrace";
          goto LABEL_138;
        }
        goto LABEL_139;
      }
      if (!v43) {
        goto LABEL_97;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
      __int16 v66 = 2082;
      uint64_t v67 = (uint64_t)backtrace_string;
      uint64_t v39 = "%{public}s called with null out_context_length, dumping backtrace:%{public}s";
      goto LABEL_96;
    }
    __int16 v34 = __nwlog_obj();
    os_log_type_t v35 = type[0];
    if (!os_log_type_enabled(v34, type[0])) {
      goto LABEL_139;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    __int16 v36 = "%{public}s called with null out_context_length";
    goto LABEL_138;
  }
  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    unint64_t v33 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v62) = 0;
    if (!__nwlog_fault(v33, type, &v62)) {
      goto LABEL_139;
    }
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!(_BYTE)v62)
      {
        __int16 v34 = __nwlog_obj();
        os_log_type_t v35 = type[0];
        if (os_log_type_enabled(v34, type[0]))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
          __int16 v36 = "%{public}s called with null out_request_enc, backtrace limit exceeded";
          goto LABEL_138;
        }
        goto LABEL_139;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v34 = __nwlog_obj();
      os_log_type_t v35 = type[0];
      BOOL v44 = os_log_type_enabled(v34, type[0]);
      if (!backtrace_string)
      {
        if (v44)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
          __int16 v36 = "%{public}s called with null out_request_enc, no backtrace";
          goto LABEL_138;
        }
        goto LABEL_139;
      }
      if (!v44) {
        goto LABEL_97;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
      __int16 v66 = 2082;
      uint64_t v67 = (uint64_t)backtrace_string;
      uint64_t v39 = "%{public}s called with null out_request_enc, dumping backtrace:%{public}s";
      goto LABEL_96;
    }
    __int16 v34 = __nwlog_obj();
    os_log_type_t v35 = type[0];
    if (!os_log_type_enabled(v34, type[0])) {
      goto LABEL_139;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    __int16 v36 = "%{public}s called with null out_request_enc";
    goto LABEL_138;
  }
  if (!a7)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    unint64_t v33 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v62) = 0;
    if (!__nwlog_fault(v33, type, &v62)) {
      goto LABEL_139;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v34 = __nwlog_obj();
      os_log_type_t v35 = type[0];
      if (!os_log_type_enabled(v34, type[0])) {
        goto LABEL_139;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
      __int16 v36 = "%{public}s called with null out_request_enc_length";
      goto LABEL_138;
    }
    if (!(_BYTE)v62)
    {
      __int16 v34 = __nwlog_obj();
      os_log_type_t v35 = type[0];
      if (os_log_type_enabled(v34, type[0]))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
        __int16 v36 = "%{public}s called with null out_request_enc_length, backtrace limit exceeded";
        goto LABEL_138;
      }
      goto LABEL_139;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v34 = __nwlog_obj();
    os_log_type_t v35 = type[0];
    BOOL v45 = os_log_type_enabled(v34, type[0]);
    if (!backtrace_string)
    {
      if (v45)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
        __int16 v36 = "%{public}s called with null out_request_enc_length, no backtrace";
        goto LABEL_138;
      }
      goto LABEL_139;
    }
    if (!v45) {
      goto LABEL_97;
    }
    *(_DWORD *)unsigned int buf = 136446466;
    uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    __int16 v66 = 2082;
    uint64_t v67 = (uint64_t)backtrace_string;
    uint64_t v39 = "%{public}s called with null out_request_enc_length, dumping backtrace:%{public}s";
LABEL_96:
    _os_log_impl(&dword_1830D4000, v34, v35, v39, buf, 0x16u);
    goto LABEL_97;
  }
  if (!a8)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    unint64_t v33 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v62) = 0;
    if (!__nwlog_fault(v33, type, &v62)) {
      goto LABEL_139;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v34 = __nwlog_obj();
      os_log_type_t v35 = type[0];
      if (os_log_type_enabled(v34, type[0]))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
        __int16 v36 = "%{public}s called with null out_header_length";
        goto LABEL_138;
      }
LABEL_139:
      if (!v33) {
        return 0;
      }
      __int16 v30 = (char *)v33;
      goto LABEL_26;
    }
    if (!(_BYTE)v62)
    {
      __int16 v34 = __nwlog_obj();
      os_log_type_t v35 = type[0];
      if (os_log_type_enabled(v34, type[0]))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
        __int16 v36 = "%{public}s called with null out_header_length, backtrace limit exceeded";
        goto LABEL_138;
      }
      goto LABEL_139;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v34 = __nwlog_obj();
    os_log_type_t v35 = type[0];
    BOOL v46 = os_log_type_enabled(v34, type[0]);
    if (!backtrace_string)
    {
      if (v46)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
        __int16 v36 = "%{public}s called with null out_header_length, no backtrace";
        goto LABEL_138;
      }
      goto LABEL_139;
    }
    if (v46)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
      __int16 v66 = 2082;
      uint64_t v67 = (uint64_t)backtrace_string;
      uint64_t v39 = "%{public}s called with null out_header_length, dumping backtrace:%{public}s";
      goto LABEL_96;
    }
LABEL_97:
    free(backtrace_string);
    goto LABEL_139;
  }
  *(void *)os_log_type_t type = 0;
  double v14 = nw_http_oblivious_config_select(a2, a3, type);
  if (!v14 || *(void *)type <= 0x28uLL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unint64_t v17 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
      char v18 = "%{public}s Config parsing failed";
      goto LABEL_16;
    }
    return 0;
  }
  os_log_type_t v15 = v14;
  size_t v16 = strlen(a1);
  if (v16 >= 0x101)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unint64_t v17 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
      char v18 = "%{public}s Media type exceeds max length";
LABEL_16:
      _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_ERROR, v18, buf, 0xCu);
      return 0;
    }
    return 0;
  }
  size_t v19 = v16;
  cchpke_params_x25519_AESGCM128_HKDF_SHA256();
  uint64_t v20 = cchpke_params_sizeof_kem_enc();
  uint64_t v61 = (char *)malloc_type_calloc(1uLL, 0x60uLL, 0xEAFB8F1AuLL);
  if (!v61)
  {
    uint64_t v47 = __nwlog_obj();
    os_log_type_enabled(v47, OS_LOG_TYPE_ERROR);
    *(_DWORD *)unsigned int buf = 136446722;
    uint64_t v65 = "strict_calloc";
    __int16 v66 = 2048;
    uint64_t v67 = 1;
    __int16 v68 = 2048;
    uint64_t v69 = 96;
    uint64_t v48 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v48);
    if (result) {
      goto LABEL_145;
    }
    free(v48);
  }
  size_t v21 = v20 + 7;
  if (v20 == -7)
  {
    uint64_t v49 = __nwlog_obj();
    os_log_type_enabled(v49, OS_LOG_TYPE_ERROR);
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v65 = "strict_calloc";
    BOOL v50 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v50);
    if (result) {
      goto LABEL_145;
    }
    free(v50);
    size_t v21 = v20 + 7;
  }
  __int16 v59 = a7;
  char v60 = a8;
  __int16 v22 = (char *)malloc_type_calloc(1uLL, v21, 0xEAFB8F1AuLL);
  if (!v22)
  {
    uint64_t v51 = __nwlog_obj();
    os_log_type_enabled(v51, OS_LOG_TYPE_ERROR);
    *(_DWORD *)unsigned int buf = 136446722;
    uint64_t v65 = "strict_calloc";
    __int16 v66 = 2048;
    uint64_t v67 = 1;
    __int16 v68 = 2048;
    uint64_t v69 = v20 + 7;
    int v52 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v52);
    if (result) {
      goto LABEL_145;
    }
    free(v52);
  }
  *__int16 v22 = *(unsigned char *)v15;
  *(_WORD *)(v22 + 1) = *(unsigned __int16 *)((char *)v15 + 1);
  *(_DWORD *)(v22 + 3) = 16777472;
  int v62 = 0;
  ccrng();
  BOOL v23 = (char *)malloc_type_calloc(1uLL, v19 + 24, 0xEAFB8F1AuLL);
  if (!v23)
  {
    uint64_t v53 = __nwlog_obj();
    os_log_type_enabled(v53, OS_LOG_TYPE_ERROR);
    *(_DWORD *)unsigned int buf = 136446722;
    uint64_t v65 = "strict_calloc";
    __int16 v66 = 2048;
    uint64_t v67 = 1;
    __int16 v68 = 2048;
    uint64_t v69 = v19 + 24;
    int v58 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v58);
    if (result) {
      goto LABEL_145;
    }
    free(v58);
  }
  size_t v24 = v19 + 17;
  snprintf(v23, v24, "%s chunked request", a1);
  int v25 = &v23[v24];
  int v26 = *(_DWORD *)(v22 + 3);
  *(_DWORD *)int v25 = *(_DWORD *)v22;
  *(_DWORD *)(v25 + 3) = v26;
  size_t v27 = v20;
  int v28 = cchpke_initiator_setup();
  free(v23);
  if (v28)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v29 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unsigned int buf = 136446466;
      uint64_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
      __int16 v66 = 1024;
      LODWORD(v67) = v28;
      _os_log_impl(&dword_1830D4000, v29, OS_LOG_TYPE_ERROR, "%{public}s Setup error: %d", buf, 0x12u);
    }
    free(v22);
    if (!v61) {
      return 0;
    }
    __int16 v30 = v61;
LABEL_26:
    free(v30);
    return 0;
  }
  *a4 = v61;
  *a5 = 96;
  if (!v20)
  {
    int v54 = __nwlog_obj();
    os_log_type_enabled(v54, OS_LOG_TYPE_ERROR);
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v65 = "strict_calloc";
    __int16 v55 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v55);
    if (result) {
      goto LABEL_145;
    }
    free(v55);
    size_t v27 = v20;
  }
  __int16 v32 = malloc_type_calloc(1uLL, v27, 0xEAFB8F1AuLL);
  if (v32)
  {
LABEL_31:
    *a6 = v32;
    memcpy(v32, v22 + 7, v27);
    size_t *v59 = v27;
    *char v60 = v20 + 7;
    return (BOOL)v22;
  }
  int v56 = __nwlog_obj();
  os_log_type_enabled(v56, OS_LOG_TYPE_ERROR);
  *(_DWORD *)unsigned int buf = 136446722;
  uint64_t v65 = "strict_calloc";
  __int16 v66 = 2048;
  uint64_t v67 = 1;
  __int16 v68 = 2048;
  uint64_t v69 = v27;
  __int16 v57 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v57);
  if (!result)
  {
    free(v57);
    size_t v27 = v20;
    goto LABEL_31;
  }
LABEL_145:
  __break(1u);
  return result;
}

BOOL nw_http_encrypt_chunked_oblivious_request_chunk(const void *a1, size_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, size_t *a8)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
    unint64_t v17 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v34 = 0;
    if (!__nwlog_fault(v17, &type, &v34)) {
      goto LABEL_108;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v34)
      {
        char v18 = __nwlog_obj();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
          uint64_t v20 = "%{public}s called with null message_buffer, backtrace limit exceeded";
          goto LABEL_107;
        }
        goto LABEL_108;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v26 = os_log_type_enabled(v18, type);
      if (!backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
          uint64_t v20 = "%{public}s called with null message_buffer, no backtrace";
          goto LABEL_107;
        }
        goto LABEL_108;
      }
      if (!v26) {
        goto LABEL_78;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
      __int16 v38 = 2082;
      uint64_t v39 = (uint64_t)backtrace_string;
      size_t v27 = "%{public}s called with null message_buffer, dumping backtrace:%{public}s";
      goto LABEL_77;
    }
    char v18 = __nwlog_obj();
    os_log_type_t v19 = type;
    if (!os_log_type_enabled(v18, type)) {
      goto LABEL_108;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
    uint64_t v20 = "%{public}s called with null message_buffer";
LABEL_107:
    _os_log_impl(&dword_1830D4000, v18, v19, v20, buf, 0xCu);
    goto LABEL_108;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
    unint64_t v17 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v34 = 0;
    if (!__nwlog_fault(v17, &type, &v34)) {
      goto LABEL_108;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v34)
      {
        char v18 = __nwlog_obj();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
          uint64_t v20 = "%{public}s called with null message_length, backtrace limit exceeded";
          goto LABEL_107;
        }
        goto LABEL_108;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v28 = os_log_type_enabled(v18, type);
      if (!backtrace_string)
      {
        if (v28)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
          uint64_t v20 = "%{public}s called with null message_length, no backtrace";
          goto LABEL_107;
        }
        goto LABEL_108;
      }
      if (!v28) {
        goto LABEL_78;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
      __int16 v38 = 2082;
      uint64_t v39 = (uint64_t)backtrace_string;
      size_t v27 = "%{public}s called with null message_length, dumping backtrace:%{public}s";
      goto LABEL_77;
    }
    char v18 = __nwlog_obj();
    os_log_type_t v19 = type;
    if (!os_log_type_enabled(v18, type)) {
      goto LABEL_108;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
    uint64_t v20 = "%{public}s called with null message_length";
    goto LABEL_107;
  }
  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
    unint64_t v17 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v34 = 0;
    if (!__nwlog_fault(v17, &type, &v34)) {
      goto LABEL_108;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v34)
      {
        char v18 = __nwlog_obj();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
          uint64_t v20 = "%{public}s called with null request_context, backtrace limit exceeded";
          goto LABEL_107;
        }
        goto LABEL_108;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v29 = os_log_type_enabled(v18, type);
      if (!backtrace_string)
      {
        if (v29)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
          uint64_t v20 = "%{public}s called with null request_context, no backtrace";
          goto LABEL_107;
        }
        goto LABEL_108;
      }
      if (!v29) {
        goto LABEL_78;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
      __int16 v38 = 2082;
      uint64_t v39 = (uint64_t)backtrace_string;
      size_t v27 = "%{public}s called with null request_context, dumping backtrace:%{public}s";
      goto LABEL_77;
    }
    char v18 = __nwlog_obj();
    os_log_type_t v19 = type;
    if (!os_log_type_enabled(v18, type)) {
      goto LABEL_108;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
    uint64_t v20 = "%{public}s called with null request_context";
    goto LABEL_107;
  }
  if (!a5)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
    unint64_t v17 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v34 = 0;
    if (!__nwlog_fault(v17, &type, &v34)) {
      goto LABEL_108;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v34)
      {
        char v18 = __nwlog_obj();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
          uint64_t v20 = "%{public}s called with null request_context_length, backtrace limit exceeded";
          goto LABEL_107;
        }
        goto LABEL_108;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v30 = os_log_type_enabled(v18, type);
      if (!backtrace_string)
      {
        if (v30)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
          uint64_t v20 = "%{public}s called with null request_context_length, no backtrace";
          goto LABEL_107;
        }
        goto LABEL_108;
      }
      if (!v30) {
        goto LABEL_78;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
      __int16 v38 = 2082;
      uint64_t v39 = (uint64_t)backtrace_string;
      size_t v27 = "%{public}s called with null request_context_length, dumping backtrace:%{public}s";
      goto LABEL_77;
    }
    char v18 = __nwlog_obj();
    os_log_type_t v19 = type;
    if (!os_log_type_enabled(v18, type)) {
      goto LABEL_108;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
    uint64_t v20 = "%{public}s called with null request_context_length";
    goto LABEL_107;
  }
  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
    unint64_t v17 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v34 = 0;
    if (!__nwlog_fault(v17, &type, &v34)) {
      goto LABEL_108;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v34)
      {
        char v18 = __nwlog_obj();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
          uint64_t v20 = "%{public}s called with null request_enc, backtrace limit exceeded";
          goto LABEL_107;
        }
        goto LABEL_108;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v31 = os_log_type_enabled(v18, type);
      if (!backtrace_string)
      {
        if (v31)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
          uint64_t v20 = "%{public}s called with null request_enc, no backtrace";
          goto LABEL_107;
        }
        goto LABEL_108;
      }
      if (!v31) {
        goto LABEL_78;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
      __int16 v38 = 2082;
      uint64_t v39 = (uint64_t)backtrace_string;
      size_t v27 = "%{public}s called with null request_enc, dumping backtrace:%{public}s";
      goto LABEL_77;
    }
    char v18 = __nwlog_obj();
    os_log_type_t v19 = type;
    if (!os_log_type_enabled(v18, type)) {
      goto LABEL_108;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
    uint64_t v20 = "%{public}s called with null request_enc";
    goto LABEL_107;
  }
  if (!a7)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
    unint64_t v17 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v34 = 0;
    if (!__nwlog_fault(v17, &type, &v34)) {
      goto LABEL_108;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_108;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
      uint64_t v20 = "%{public}s called with null request_enc_length";
      goto LABEL_107;
    }
    if (!v34)
    {
      char v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
        uint64_t v20 = "%{public}s called with null request_enc_length, backtrace limit exceeded";
        goto LABEL_107;
      }
      goto LABEL_108;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    char v18 = __nwlog_obj();
    os_log_type_t v19 = type;
    BOOL v32 = os_log_type_enabled(v18, type);
    if (!backtrace_string)
    {
      if (v32)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
        uint64_t v20 = "%{public}s called with null request_enc_length, no backtrace";
        goto LABEL_107;
      }
      goto LABEL_108;
    }
    if (!v32) {
      goto LABEL_78;
    }
    *(_DWORD *)unsigned int buf = 136446466;
    __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
    __int16 v38 = 2082;
    uint64_t v39 = (uint64_t)backtrace_string;
    size_t v27 = "%{public}s called with null request_enc_length, dumping backtrace:%{public}s";
LABEL_77:
    _os_log_impl(&dword_1830D4000, v18, v19, v27, buf, 0x16u);
    goto LABEL_78;
  }
  if (!a8)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
    unint64_t v17 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v34 = 0;
    if (!__nwlog_fault(v17, &type, &v34)) {
      goto LABEL_108;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
        uint64_t v20 = "%{public}s called with null out_encrypted_length";
        goto LABEL_107;
      }
LABEL_108:
      if (v17) {
        free(v17);
      }
      return 0;
    }
    if (!v34)
    {
      char v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
        uint64_t v20 = "%{public}s called with null out_encrypted_length, backtrace limit exceeded";
        goto LABEL_107;
      }
      goto LABEL_108;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    char v18 = __nwlog_obj();
    os_log_type_t v19 = type;
    BOOL v33 = os_log_type_enabled(v18, type);
    if (!backtrace_string)
    {
      if (v33)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
        uint64_t v20 = "%{public}s called with null out_encrypted_length, no backtrace";
        goto LABEL_107;
      }
      goto LABEL_108;
    }
    if (v33)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
      __int16 v38 = 2082;
      uint64_t v39 = (uint64_t)backtrace_string;
      size_t v27 = "%{public}s called with null out_encrypted_length, dumping backtrace:%{public}s";
      goto LABEL_77;
    }
LABEL_78:
    free(backtrace_string);
    goto LABEL_108;
  }
  cchpke_params_x25519_AESGCM128_HKDF_SHA256();
  size_t v11 = cchpke_params_sizeof_aead_tag() + a2;
  if (!v11)
  {
    size_t v21 = __nwlog_obj();
    os_log_type_enabled(v21, OS_LOG_TYPE_ERROR);
    *(_DWORD *)unsigned int buf = 136446210;
    __int16 v37 = "strict_calloc";
    __int16 v22 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v22);
    if (result) {
      goto LABEL_111;
    }
    free(v22);
  }
  os_log_type_t v12 = malloc_type_calloc(1uLL, v11, 0xEAFB8F1AuLL);
  if (v12) {
    goto LABEL_10;
  }
  BOOL v23 = __nwlog_obj();
  os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
  *(_DWORD *)unsigned int buf = 136446722;
  __int16 v37 = "strict_calloc";
  __int16 v38 = 2048;
  uint64_t v39 = 1;
  __int16 v40 = 2048;
  size_t v41 = v11;
  size_t v24 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v24);
  if (!result)
  {
    free(v24);
LABEL_10:
    memcpy(v12, a1, a2);
    int v13 = cchpke_initiator_encrypt();
    if (v13)
    {
      int v14 = v13;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v15 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)unsigned int buf = 136446466;
        __int16 v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
        __int16 v38 = 1024;
        LODWORD(v39) = v14;
        _os_log_impl(&dword_1830D4000, v15, OS_LOG_TYPE_ERROR, "%{public}s Encrypt: %d", buf, 0x12u);
      }
      if (v12)
      {
        free(v12);
        return 0;
      }
    }
    else
    {
      *a8 = v11;
    }
    return (BOOL)v12;
  }
LABEL_111:
  __break(1u);
  return result;
}

BOOL nw_http_decrypt_oblivious_request(uint64_t a1, unint64_t a2, char *__s, uint64_t a4, uint64_t a5, char **a6, void *a7, void *a8, size_t *a9, size_t *a10)
{
  uint64_t v87 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    int v82 = "nw_http_decrypt_oblivious_request";
    __int16 v40 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v79 = 0;
    if (!__nwlog_fault(v40, &type, &v79)) {
      goto LABEL_206;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v79)
      {
        size_t v41 = __nwlog_obj();
        os_log_type_t v42 = type;
        if (!os_log_type_enabled(v41, type)) {
          goto LABEL_206;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v82 = "nw_http_decrypt_oblivious_request";
        BOOL v43 = "%{public}s called with null request_buffer, backtrace limit exceeded";
        goto LABEL_205;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      size_t v41 = __nwlog_obj();
      os_log_type_t v42 = type;
      BOOL v45 = os_log_type_enabled(v41, type);
      if (!backtrace_string)
      {
        if (!v45) {
          goto LABEL_206;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v82 = "nw_http_decrypt_oblivious_request";
        BOOL v43 = "%{public}s called with null request_buffer, no backtrace";
        goto LABEL_205;
      }
      if (!v45) {
        goto LABEL_132;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      int v82 = "nw_http_decrypt_oblivious_request";
      __int16 v83 = 2082;
      uint64_t v84 = (uint64_t)backtrace_string;
      BOOL v46 = "%{public}s called with null request_buffer, dumping backtrace:%{public}s";
      goto LABEL_131;
    }
    size_t v41 = __nwlog_obj();
    os_log_type_t v42 = type;
    if (!os_log_type_enabled(v41, type)) {
      goto LABEL_206;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    int v82 = "nw_http_decrypt_oblivious_request";
    BOOL v43 = "%{public}s called with null request_buffer";
LABEL_205:
    _os_log_impl(&dword_1830D4000, v41, v42, v43, buf, 0xCu);
    goto LABEL_206;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    int v82 = "nw_http_decrypt_oblivious_request";
    __int16 v40 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v79 = 0;
    if (!__nwlog_fault(v40, &type, &v79)) {
      goto LABEL_206;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v79)
      {
        size_t v41 = __nwlog_obj();
        os_log_type_t v42 = type;
        if (!os_log_type_enabled(v41, type)) {
          goto LABEL_206;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v82 = "nw_http_decrypt_oblivious_request";
        BOOL v43 = "%{public}s called with null request_length, backtrace limit exceeded";
        goto LABEL_205;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      size_t v41 = __nwlog_obj();
      os_log_type_t v42 = type;
      BOOL v47 = os_log_type_enabled(v41, type);
      if (!backtrace_string)
      {
        if (!v47) {
          goto LABEL_206;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v82 = "nw_http_decrypt_oblivious_request";
        BOOL v43 = "%{public}s called with null request_length, no backtrace";
        goto LABEL_205;
      }
      if (!v47) {
        goto LABEL_132;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      int v82 = "nw_http_decrypt_oblivious_request";
      __int16 v83 = 2082;
      uint64_t v84 = (uint64_t)backtrace_string;
      BOOL v46 = "%{public}s called with null request_length, dumping backtrace:%{public}s";
      goto LABEL_131;
    }
    size_t v41 = __nwlog_obj();
    os_log_type_t v42 = type;
    if (!os_log_type_enabled(v41, type)) {
      goto LABEL_206;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    int v82 = "nw_http_decrypt_oblivious_request";
    BOOL v43 = "%{public}s called with null request_length";
    goto LABEL_205;
  }
  if (!__s)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    int v82 = "nw_http_decrypt_oblivious_request";
    __int16 v40 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v79 = 0;
    if (!__nwlog_fault(v40, &type, &v79)) {
      goto LABEL_206;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v79)
      {
        size_t v41 = __nwlog_obj();
        os_log_type_t v42 = type;
        if (!os_log_type_enabled(v41, type)) {
          goto LABEL_206;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v82 = "nw_http_decrypt_oblivious_request";
        BOOL v43 = "%{public}s called with null media_type, backtrace limit exceeded";
        goto LABEL_205;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      size_t v41 = __nwlog_obj();
      os_log_type_t v42 = type;
      BOOL v48 = os_log_type_enabled(v41, type);
      if (!backtrace_string)
      {
        if (!v48) {
          goto LABEL_206;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v82 = "nw_http_decrypt_oblivious_request";
        BOOL v43 = "%{public}s called with null media_type, no backtrace";
        goto LABEL_205;
      }
      if (!v48) {
        goto LABEL_132;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      int v82 = "nw_http_decrypt_oblivious_request";
      __int16 v83 = 2082;
      uint64_t v84 = (uint64_t)backtrace_string;
      BOOL v46 = "%{public}s called with null media_type, dumping backtrace:%{public}s";
      goto LABEL_131;
    }
    size_t v41 = __nwlog_obj();
    os_log_type_t v42 = type;
    if (!os_log_type_enabled(v41, type)) {
      goto LABEL_206;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    int v82 = "nw_http_decrypt_oblivious_request";
    BOOL v43 = "%{public}s called with null media_type";
    goto LABEL_205;
  }
  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    int v82 = "nw_http_decrypt_oblivious_request";
    __int16 v40 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v79 = 0;
    if (!__nwlog_fault(v40, &type, &v79)) {
      goto LABEL_206;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v79)
      {
        size_t v41 = __nwlog_obj();
        os_log_type_t v42 = type;
        if (!os_log_type_enabled(v41, type)) {
          goto LABEL_206;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v82 = "nw_http_decrypt_oblivious_request";
        BOOL v43 = "%{public}s called with null private_key, backtrace limit exceeded";
        goto LABEL_205;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      size_t v41 = __nwlog_obj();
      os_log_type_t v42 = type;
      BOOL v49 = os_log_type_enabled(v41, type);
      if (!backtrace_string)
      {
        if (!v49) {
          goto LABEL_206;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v82 = "nw_http_decrypt_oblivious_request";
        BOOL v43 = "%{public}s called with null private_key, no backtrace";
        goto LABEL_205;
      }
      if (!v49) {
        goto LABEL_132;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      int v82 = "nw_http_decrypt_oblivious_request";
      __int16 v83 = 2082;
      uint64_t v84 = (uint64_t)backtrace_string;
      BOOL v46 = "%{public}s called with null private_key, dumping backtrace:%{public}s";
      goto LABEL_131;
    }
    size_t v41 = __nwlog_obj();
    os_log_type_t v42 = type;
    if (!os_log_type_enabled(v41, type)) {
      goto LABEL_206;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    int v82 = "nw_http_decrypt_oblivious_request";
    BOOL v43 = "%{public}s called with null private_key";
    goto LABEL_205;
  }
  if (!a5)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    int v82 = "nw_http_decrypt_oblivious_request";
    __int16 v40 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v79 = 0;
    if (!__nwlog_fault(v40, &type, &v79)) {
      goto LABEL_206;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v79)
      {
        size_t v41 = __nwlog_obj();
        os_log_type_t v42 = type;
        if (!os_log_type_enabled(v41, type)) {
          goto LABEL_206;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v82 = "nw_http_decrypt_oblivious_request";
        BOOL v43 = "%{public}s called with null private_key_length, backtrace limit exceeded";
        goto LABEL_205;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      size_t v41 = __nwlog_obj();
      os_log_type_t v42 = type;
      BOOL v50 = os_log_type_enabled(v41, type);
      if (!backtrace_string)
      {
        if (!v50) {
          goto LABEL_206;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v82 = "nw_http_decrypt_oblivious_request";
        BOOL v43 = "%{public}s called with null private_key_length, no backtrace";
        goto LABEL_205;
      }
      if (!v50) {
        goto LABEL_132;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      int v82 = "nw_http_decrypt_oblivious_request";
      __int16 v83 = 2082;
      uint64_t v84 = (uint64_t)backtrace_string;
      BOOL v46 = "%{public}s called with null private_key_length, dumping backtrace:%{public}s";
      goto LABEL_131;
    }
    size_t v41 = __nwlog_obj();
    os_log_type_t v42 = type;
    if (!os_log_type_enabled(v41, type)) {
      goto LABEL_206;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    int v82 = "nw_http_decrypt_oblivious_request";
    BOOL v43 = "%{public}s called with null private_key_length";
    goto LABEL_205;
  }
  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    int v82 = "nw_http_decrypt_oblivious_request";
    __int16 v40 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v79 = 0;
    if (!__nwlog_fault(v40, &type, &v79)) {
      goto LABEL_206;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v79)
      {
        size_t v41 = __nwlog_obj();
        os_log_type_t v42 = type;
        if (!os_log_type_enabled(v41, type)) {
          goto LABEL_206;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v82 = "nw_http_decrypt_oblivious_request";
        BOOL v43 = "%{public}s called with null out_context, backtrace limit exceeded";
        goto LABEL_205;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      size_t v41 = __nwlog_obj();
      os_log_type_t v42 = type;
      BOOL v51 = os_log_type_enabled(v41, type);
      if (!backtrace_string)
      {
        if (!v51) {
          goto LABEL_206;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v82 = "nw_http_decrypt_oblivious_request";
        BOOL v43 = "%{public}s called with null out_context, no backtrace";
        goto LABEL_205;
      }
      if (!v51) {
        goto LABEL_132;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      int v82 = "nw_http_decrypt_oblivious_request";
      __int16 v83 = 2082;
      uint64_t v84 = (uint64_t)backtrace_string;
      BOOL v46 = "%{public}s called with null out_context, dumping backtrace:%{public}s";
      goto LABEL_131;
    }
    size_t v41 = __nwlog_obj();
    os_log_type_t v42 = type;
    if (!os_log_type_enabled(v41, type)) {
      goto LABEL_206;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    int v82 = "nw_http_decrypt_oblivious_request";
    BOOL v43 = "%{public}s called with null out_context";
    goto LABEL_205;
  }
  if (!a7)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    int v82 = "nw_http_decrypt_oblivious_request";
    __int16 v40 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v79 = 0;
    if (!__nwlog_fault(v40, &type, &v79)) {
      goto LABEL_206;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v79)
      {
        size_t v41 = __nwlog_obj();
        os_log_type_t v42 = type;
        if (!os_log_type_enabled(v41, type)) {
          goto LABEL_206;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v82 = "nw_http_decrypt_oblivious_request";
        BOOL v43 = "%{public}s called with null out_context_length, backtrace limit exceeded";
        goto LABEL_205;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      size_t v41 = __nwlog_obj();
      os_log_type_t v42 = type;
      BOOL v52 = os_log_type_enabled(v41, type);
      if (!backtrace_string)
      {
        if (!v52) {
          goto LABEL_206;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v82 = "nw_http_decrypt_oblivious_request";
        BOOL v43 = "%{public}s called with null out_context_length, no backtrace";
        goto LABEL_205;
      }
      if (!v52) {
        goto LABEL_132;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      int v82 = "nw_http_decrypt_oblivious_request";
      __int16 v83 = 2082;
      uint64_t v84 = (uint64_t)backtrace_string;
      BOOL v46 = "%{public}s called with null out_context_length, dumping backtrace:%{public}s";
      goto LABEL_131;
    }
    size_t v41 = __nwlog_obj();
    os_log_type_t v42 = type;
    if (!os_log_type_enabled(v41, type)) {
      goto LABEL_206;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    int v82 = "nw_http_decrypt_oblivious_request";
    BOOL v43 = "%{public}s called with null out_context_length";
    goto LABEL_205;
  }
  if (!a8)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    int v82 = "nw_http_decrypt_oblivious_request";
    __int16 v40 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v79 = 0;
    if (!__nwlog_fault(v40, &type, &v79)) {
      goto LABEL_206;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v79)
      {
        size_t v41 = __nwlog_obj();
        os_log_type_t v42 = type;
        if (!os_log_type_enabled(v41, type)) {
          goto LABEL_206;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v82 = "nw_http_decrypt_oblivious_request";
        BOOL v43 = "%{public}s called with null out_request_enc, backtrace limit exceeded";
        goto LABEL_205;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      size_t v41 = __nwlog_obj();
      os_log_type_t v42 = type;
      BOOL v53 = os_log_type_enabled(v41, type);
      if (!backtrace_string)
      {
        if (!v53) {
          goto LABEL_206;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v82 = "nw_http_decrypt_oblivious_request";
        BOOL v43 = "%{public}s called with null out_request_enc, no backtrace";
        goto LABEL_205;
      }
      if (!v53) {
        goto LABEL_132;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      int v82 = "nw_http_decrypt_oblivious_request";
      __int16 v83 = 2082;
      uint64_t v84 = (uint64_t)backtrace_string;
      BOOL v46 = "%{public}s called with null out_request_enc, dumping backtrace:%{public}s";
      goto LABEL_131;
    }
    size_t v41 = __nwlog_obj();
    os_log_type_t v42 = type;
    if (!os_log_type_enabled(v41, type)) {
      goto LABEL_206;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    int v82 = "nw_http_decrypt_oblivious_request";
    BOOL v43 = "%{public}s called with null out_request_enc";
    goto LABEL_205;
  }
  if (!a9)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    int v82 = "nw_http_decrypt_oblivious_request";
    __int16 v40 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v79 = 0;
    if (!__nwlog_fault(v40, &type, &v79)) {
      goto LABEL_206;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v79)
      {
        size_t v41 = __nwlog_obj();
        os_log_type_t v42 = type;
        if (!os_log_type_enabled(v41, type)) {
          goto LABEL_206;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v82 = "nw_http_decrypt_oblivious_request";
        BOOL v43 = "%{public}s called with null out_request_enc_length, backtrace limit exceeded";
        goto LABEL_205;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      size_t v41 = __nwlog_obj();
      os_log_type_t v42 = type;
      BOOL v54 = os_log_type_enabled(v41, type);
      if (!backtrace_string)
      {
        if (!v54) {
          goto LABEL_206;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v82 = "nw_http_decrypt_oblivious_request";
        BOOL v43 = "%{public}s called with null out_request_enc_length, no backtrace";
        goto LABEL_205;
      }
      if (!v54) {
        goto LABEL_132;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      int v82 = "nw_http_decrypt_oblivious_request";
      __int16 v83 = 2082;
      uint64_t v84 = (uint64_t)backtrace_string;
      BOOL v46 = "%{public}s called with null out_request_enc_length, dumping backtrace:%{public}s";
      goto LABEL_131;
    }
    size_t v41 = __nwlog_obj();
    os_log_type_t v42 = type;
    if (!os_log_type_enabled(v41, type)) {
      goto LABEL_206;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    int v82 = "nw_http_decrypt_oblivious_request";
    BOOL v43 = "%{public}s called with null out_request_enc_length";
    goto LABEL_205;
  }
  if (!a10)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    int v82 = "nw_http_decrypt_oblivious_request";
    __int16 v40 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v79 = 0;
    if (!__nwlog_fault(v40, &type, &v79)) {
      goto LABEL_206;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v79)
      {
        size_t v41 = __nwlog_obj();
        os_log_type_t v42 = type;
        if (!os_log_type_enabled(v41, type)) {
          goto LABEL_206;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v82 = "nw_http_decrypt_oblivious_request";
        BOOL v43 = "%{public}s called with null out_decrypted_length, backtrace limit exceeded";
        goto LABEL_205;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      size_t v41 = __nwlog_obj();
      os_log_type_t v42 = type;
      BOOL v55 = os_log_type_enabled(v41, type);
      if (!backtrace_string)
      {
        if (!v55) {
          goto LABEL_206;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v82 = "nw_http_decrypt_oblivious_request";
        BOOL v43 = "%{public}s called with null out_decrypted_length, no backtrace";
        goto LABEL_205;
      }
      if (!v55) {
        goto LABEL_132;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      int v82 = "nw_http_decrypt_oblivious_request";
      __int16 v83 = 2082;
      uint64_t v84 = (uint64_t)backtrace_string;
      BOOL v46 = "%{public}s called with null out_decrypted_length, dumping backtrace:%{public}s";
      goto LABEL_131;
    }
    size_t v41 = __nwlog_obj();
    os_log_type_t v42 = type;
    if (!os_log_type_enabled(v41, type)) {
      goto LABEL_206;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    int v82 = "nw_http_decrypt_oblivious_request";
    BOOL v43 = "%{public}s called with null out_decrypted_length";
    goto LABEL_205;
  }
  if (a2 <= 7)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    int v82 = "nw_http_decrypt_oblivious_request";
    __int16 v40 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v79 = 0;
    if (!__nwlog_fault(v40, &type, &v79)) {
      goto LABEL_206;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      size_t v41 = __nwlog_obj();
      os_log_type_t v42 = type;
      if (!os_log_type_enabled(v41, type)) {
        goto LABEL_206;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      int v82 = "nw_http_decrypt_oblivious_request";
      BOOL v43 = "%{public}s called with null (request_length > hdr_length)";
      goto LABEL_205;
    }
    if (!v79)
    {
      size_t v41 = __nwlog_obj();
      os_log_type_t v42 = type;
      if (!os_log_type_enabled(v41, type)) {
        goto LABEL_206;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      int v82 = "nw_http_decrypt_oblivious_request";
      BOOL v43 = "%{public}s called with null (request_length > hdr_length), backtrace limit exceeded";
      goto LABEL_205;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    size_t v41 = __nwlog_obj();
    os_log_type_t v42 = type;
    BOOL v56 = os_log_type_enabled(v41, type);
    if (!backtrace_string)
    {
      if (!v56) {
        goto LABEL_206;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      int v82 = "nw_http_decrypt_oblivious_request";
      BOOL v43 = "%{public}s called with null (request_length > hdr_length), no backtrace";
      goto LABEL_205;
    }
    if (!v56) {
      goto LABEL_132;
    }
    *(_DWORD *)unsigned int buf = 136446466;
    int v82 = "nw_http_decrypt_oblivious_request";
    __int16 v83 = 2082;
    uint64_t v84 = (uint64_t)backtrace_string;
    BOOL v46 = "%{public}s called with null (request_length > hdr_length), dumping backtrace:%{public}s";
LABEL_131:
    _os_log_impl(&dword_1830D4000, v41, v42, v46, buf, 0x16u);
    goto LABEL_132;
  }
  if (*(_WORD *)(a1 + 1) != 0x2000 || *(_WORD *)(a1 + 3) != 256 || *(_WORD *)(a1 + 5) != 256) {
    return 0;
  }
  unint64_t v78 = a2 - 7;
  size_t v15 = strlen(__s);
  if (v15 >= 0x101)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    size_t v16 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unsigned int buf = 136446210;
      int v82 = "nw_http_decrypt_oblivious_request";
      _os_log_impl(&dword_1830D4000, v16, OS_LOG_TYPE_ERROR, "%{public}s Media type exceeds max length", buf, 0xCu);
    }
    return 0;
  }
  size_t v17 = v15;
  cchpke_params_x25519_AESGCM128_HKDF_SHA256();
  size_t v18 = cchpke_params_sizeof_aead_tag();
  uint64_t v19 = cchpke_params_sizeof_kem_enc();
  size_t v77 = v19;
  size_t size = v18;
  if (v19 + v18 + 7 >= a2)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    int v82 = "nw_http_decrypt_oblivious_request";
    __int16 v40 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v79 = 0;
    if (!__nwlog_fault(v40, &type, &v79)) {
      goto LABEL_206;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      size_t v41 = __nwlog_obj();
      os_log_type_t v42 = type;
      if (os_log_type_enabled(v41, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        int v82 = "nw_http_decrypt_oblivious_request";
        BOOL v43 = "%{public}s called with null (request_length > (hdr_length + tag_length + enc_length))";
        goto LABEL_205;
      }
LABEL_206:
      if (!v40) {
        return 0;
      }
      os_log_type_t v35 = (char *)v40;
      goto LABEL_37;
    }
    if (!v79)
    {
      size_t v41 = __nwlog_obj();
      os_log_type_t v42 = type;
      if (os_log_type_enabled(v41, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        int v82 = "nw_http_decrypt_oblivious_request";
        BOOL v43 = "%{public}s called with null (request_length > (hdr_length + tag_length + enc_length)), backtrace limit exceeded";
        goto LABEL_205;
      }
      goto LABEL_206;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    size_t v41 = __nwlog_obj();
    os_log_type_t v42 = type;
    BOOL v61 = os_log_type_enabled(v41, type);
    if (!backtrace_string)
    {
      if (v61)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        int v82 = "nw_http_decrypt_oblivious_request";
        BOOL v43 = "%{public}s called with null (request_length > (hdr_length + tag_length + enc_length)), no backtrace";
        goto LABEL_205;
      }
      goto LABEL_206;
    }
    if (v61)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      int v82 = "nw_http_decrypt_oblivious_request";
      __int16 v83 = 2082;
      uint64_t v84 = (uint64_t)backtrace_string;
      BOOL v46 = "%{public}s called with null (request_length > (hdr_length + tag_length + enc_length)), dumping backtrace:%{public}s";
      goto LABEL_131;
    }
LABEL_132:
    free(backtrace_string);
    goto LABEL_206;
  }
  size_t v74 = v19 + v18;
  uint64_t v20 = (char *)malloc_type_calloc(1uLL, v17 + 16, 0xEAFB8F1AuLL);
  if (!v20)
  {
    __int16 v57 = __nwlog_obj();
    os_log_type_enabled(v57, OS_LOG_TYPE_ERROR);
    *(_DWORD *)unsigned int buf = 136446722;
    int v82 = "strict_calloc";
    __int16 v83 = 2048;
    uint64_t v84 = 1;
    __int16 v85 = 2048;
    uint64_t v86 = v17 + 16;
    int v58 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v58);
    if (result) {
      goto LABEL_208;
    }
    free(v58);
  }
  size_t v21 = v17 + 9;
  snprintf(v20, v21, "%s request", __s);
  __int16 v22 = &v20[v21];
  int v23 = *(_DWORD *)(a1 + 3);
  *(_DWORD *)__int16 v22 = *(_DWORD *)a1;
  *(_DWORD *)(v22 + 3) = v23;
  size_t v24 = (char *)malloc_type_calloc(1uLL, 0x60uLL, 0xEAFB8F1AuLL);
  int v25 = a10;
  if (!v24)
  {
    __int16 v59 = __nwlog_obj();
    os_log_type_enabled(v59, OS_LOG_TYPE_ERROR);
    *(_DWORD *)unsigned int buf = 136446722;
    int v82 = "strict_calloc";
    __int16 v83 = 2048;
    uint64_t v84 = 1;
    __int16 v85 = 2048;
    uint64_t v86 = 96;
    char v60 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v60);
    if (result) {
      goto LABEL_208;
    }
    free(v60);
    int v25 = a10;
  }
  BOOL v26 = (char *)(a1 + 7);
  size_t v27 = v77;
  int v28 = cchpke_responder_setup();
  free(v20);
  if (v28)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v29 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unsigned int buf = 136446466;
      int v82 = "nw_http_decrypt_oblivious_request";
      __int16 v83 = 1024;
      LODWORD(v84) = v28;
      _os_log_impl(&dword_1830D4000, v29, OS_LOG_TYPE_ERROR, "%{public}s Setup error: %d", buf, 0x12u);
    }
LABEL_35:
    if (!v24) {
      return 0;
    }
    os_log_type_t v35 = v24;
LABEL_37:
    free(v35);
    return 0;
  }
  if (!v18)
  {
    int v62 = __nwlog_obj();
    os_log_type_enabled(v62, OS_LOG_TYPE_ERROR);
    *(_DWORD *)unsigned int buf = 136446210;
    int v82 = "strict_calloc";
    uint64_t v63 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v63);
    if (result) {
      goto LABEL_208;
    }
    free(v63);
    size_t v27 = v77;
    size_t v18 = 0;
    int v25 = a10;
  }
  BOOL v30 = malloc_type_calloc(1uLL, v18, 0xEAFB8F1AuLL);
  if (!v30)
  {
    uint64_t v64 = __nwlog_obj();
    os_log_type_enabled(v64, OS_LOG_TYPE_ERROR);
    *(_DWORD *)unsigned int buf = 136446722;
    int v82 = "strict_calloc";
    __int16 v83 = 2048;
    uint64_t v84 = 1;
    __int16 v85 = 2048;
    uint64_t v86 = v18;
    uint64_t v65 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v65);
    if (result) {
      goto LABEL_208;
    }
    free(v65);
    size_t v27 = v77;
    size_t v18 = size;
    int v25 = a10;
  }
  size_t v31 = v78 - v74;
  memcpy(v30, &v26[v27 + v78 - v74], v18);
  if (v78 == v74)
  {
    __int16 v66 = __nwlog_obj();
    os_log_type_enabled(v66, OS_LOG_TYPE_ERROR);
    *(_DWORD *)unsigned int buf = 136446210;
    int v82 = "strict_calloc";
    uint64_t v67 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v67);
    if (result) {
      goto LABEL_208;
    }
    free(v67);
    int v25 = a10;
  }
  BOOL v32 = malloc_type_calloc(1uLL, v31, 0xEAFB8F1AuLL);
  if (!v32)
  {
    __int16 v68 = __nwlog_obj();
    os_log_type_enabled(v68, OS_LOG_TYPE_ERROR);
    *(_DWORD *)unsigned int buf = 136446722;
    int v82 = "strict_calloc";
    __int16 v83 = 2048;
    uint64_t v84 = 1;
    __int16 v85 = 2048;
    uint64_t v86 = v78 - v74;
    uint64_t v69 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v69);
    if (result) {
      goto LABEL_208;
    }
    free(v69);
    int v25 = a10;
  }
  int v33 = cchpke_responder_decrypt();
  if (v30) {
    free(v30);
  }
  if (v33)
  {
    char v34 = __nwlog_obj();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unsigned int buf = 136446466;
      int v82 = "nw_http_decrypt_oblivious_request";
      __int16 v83 = 1024;
      LODWORD(v84) = v33;
      _os_log_impl(&dword_1830D4000, v34, OS_LOG_TYPE_ERROR, "%{public}s Decrypt error: %d", buf, 0x12u);
    }
    if (v32) {
      free(v32);
    }
    goto LABEL_35;
  }
  *a6 = v24;
  *a7 = 96;
  size_t v37 = v77;
  if (!v77)
  {
    uint64_t v70 = __nwlog_obj();
    os_log_type_enabled(v70, OS_LOG_TYPE_ERROR);
    *(_DWORD *)unsigned int buf = 136446210;
    int v82 = "strict_calloc";
    int v71 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v71);
    if (result) {
      goto LABEL_208;
    }
    free(v71);
    size_t v37 = 0;
    int v25 = a10;
  }
  __int16 v38 = malloc_type_calloc(1uLL, v37, 0xEAFB8F1AuLL);
  uint64_t v39 = a9;
  if (v38)
  {
LABEL_42:
    *a8 = v38;
    memcpy(v38, v26, v37);
    *uint64_t v39 = v37;
    *int v25 = v31;
    return (BOOL)v32;
  }
  __int16 v72 = __nwlog_obj();
  os_log_type_enabled(v72, OS_LOG_TYPE_ERROR);
  *(_DWORD *)unsigned int buf = 136446722;
  int v82 = "strict_calloc";
  __int16 v83 = 2048;
  uint64_t v84 = 1;
  __int16 v85 = 2048;
  uint64_t v86 = v37;
  BOOL v73 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v73);
  if (!result)
  {
    free(v73);
    size_t v37 = v77;
    uint64_t v39 = a9;
    int v25 = a10;
    goto LABEL_42;
  }
LABEL_208:
  __break(1u);
  return result;
}

uint64_t nw_http_decrypt_get_chunked_oblivious_request_header_length()
{
  return cchpke_params_sizeof_kem_enc() + 7;
}

BOOL nw_http_decrypt_chunked_oblivious_request_header(uint64_t a1, unint64_t a2, char *__s, uint64_t a4, uint64_t a5, void *a6, void *a7, void *a8, size_t *a9)
{
  uint64_t v63 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
    BOOL v29 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v55 = 0;
    if (!__nwlog_fault(v29, &type, &v55)) {
      goto LABEL_173;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v55)
      {
        BOOL v30 = __nwlog_obj();
        os_log_type_t v31 = type;
        if (!os_log_type_enabled(v30, type)) {
          goto LABEL_173;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
        BOOL v32 = "%{public}s called with null header_buffer, backtrace limit exceeded";
        goto LABEL_172;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v30 = __nwlog_obj();
      os_log_type_t v31 = type;
      BOOL v34 = os_log_type_enabled(v30, type);
      if (!backtrace_string)
      {
        if (!v34) {
          goto LABEL_173;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
        BOOL v32 = "%{public}s called with null header_buffer, no backtrace";
        goto LABEL_172;
      }
      if (!v34) {
        goto LABEL_111;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
      __int16 v59 = 2082;
      uint64_t v60 = (uint64_t)backtrace_string;
      os_log_type_t v35 = "%{public}s called with null header_buffer, dumping backtrace:%{public}s";
      goto LABEL_110;
    }
    BOOL v30 = __nwlog_obj();
    os_log_type_t v31 = type;
    if (!os_log_type_enabled(v30, type)) {
      goto LABEL_173;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
    BOOL v32 = "%{public}s called with null header_buffer";
LABEL_172:
    _os_log_impl(&dword_1830D4000, v30, v31, v32, buf, 0xCu);
    goto LABEL_173;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
    BOOL v29 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v55 = 0;
    if (!__nwlog_fault(v29, &type, &v55)) {
      goto LABEL_173;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v55)
      {
        BOOL v30 = __nwlog_obj();
        os_log_type_t v31 = type;
        if (!os_log_type_enabled(v30, type)) {
          goto LABEL_173;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
        BOOL v32 = "%{public}s called with null header_length, backtrace limit exceeded";
        goto LABEL_172;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v30 = __nwlog_obj();
      os_log_type_t v31 = type;
      BOOL v36 = os_log_type_enabled(v30, type);
      if (!backtrace_string)
      {
        if (!v36) {
          goto LABEL_173;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
        BOOL v32 = "%{public}s called with null header_length, no backtrace";
        goto LABEL_172;
      }
      if (!v36) {
        goto LABEL_111;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
      __int16 v59 = 2082;
      uint64_t v60 = (uint64_t)backtrace_string;
      os_log_type_t v35 = "%{public}s called with null header_length, dumping backtrace:%{public}s";
      goto LABEL_110;
    }
    BOOL v30 = __nwlog_obj();
    os_log_type_t v31 = type;
    if (!os_log_type_enabled(v30, type)) {
      goto LABEL_173;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
    BOOL v32 = "%{public}s called with null header_length";
    goto LABEL_172;
  }
  if (!__s)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
    BOOL v29 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v55 = 0;
    if (!__nwlog_fault(v29, &type, &v55)) {
      goto LABEL_173;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v55)
      {
        BOOL v30 = __nwlog_obj();
        os_log_type_t v31 = type;
        if (!os_log_type_enabled(v30, type)) {
          goto LABEL_173;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
        BOOL v32 = "%{public}s called with null media_type, backtrace limit exceeded";
        goto LABEL_172;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v30 = __nwlog_obj();
      os_log_type_t v31 = type;
      BOOL v37 = os_log_type_enabled(v30, type);
      if (!backtrace_string)
      {
        if (!v37) {
          goto LABEL_173;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
        BOOL v32 = "%{public}s called with null media_type, no backtrace";
        goto LABEL_172;
      }
      if (!v37) {
        goto LABEL_111;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
      __int16 v59 = 2082;
      uint64_t v60 = (uint64_t)backtrace_string;
      os_log_type_t v35 = "%{public}s called with null media_type, dumping backtrace:%{public}s";
      goto LABEL_110;
    }
    BOOL v30 = __nwlog_obj();
    os_log_type_t v31 = type;
    if (!os_log_type_enabled(v30, type)) {
      goto LABEL_173;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
    BOOL v32 = "%{public}s called with null media_type";
    goto LABEL_172;
  }
  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
    BOOL v29 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v55 = 0;
    if (!__nwlog_fault(v29, &type, &v55)) {
      goto LABEL_173;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v55)
      {
        BOOL v30 = __nwlog_obj();
        os_log_type_t v31 = type;
        if (!os_log_type_enabled(v30, type)) {
          goto LABEL_173;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
        BOOL v32 = "%{public}s called with null private_key, backtrace limit exceeded";
        goto LABEL_172;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v30 = __nwlog_obj();
      os_log_type_t v31 = type;
      BOOL v38 = os_log_type_enabled(v30, type);
      if (!backtrace_string)
      {
        if (!v38) {
          goto LABEL_173;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
        BOOL v32 = "%{public}s called with null private_key, no backtrace";
        goto LABEL_172;
      }
      if (!v38) {
        goto LABEL_111;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
      __int16 v59 = 2082;
      uint64_t v60 = (uint64_t)backtrace_string;
      os_log_type_t v35 = "%{public}s called with null private_key, dumping backtrace:%{public}s";
      goto LABEL_110;
    }
    BOOL v30 = __nwlog_obj();
    os_log_type_t v31 = type;
    if (!os_log_type_enabled(v30, type)) {
      goto LABEL_173;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
    BOOL v32 = "%{public}s called with null private_key";
    goto LABEL_172;
  }
  if (!a5)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
    BOOL v29 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v55 = 0;
    if (!__nwlog_fault(v29, &type, &v55)) {
      goto LABEL_173;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v55)
      {
        BOOL v30 = __nwlog_obj();
        os_log_type_t v31 = type;
        if (!os_log_type_enabled(v30, type)) {
          goto LABEL_173;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
        BOOL v32 = "%{public}s called with null private_key_length, backtrace limit exceeded";
        goto LABEL_172;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v30 = __nwlog_obj();
      os_log_type_t v31 = type;
      BOOL v39 = os_log_type_enabled(v30, type);
      if (!backtrace_string)
      {
        if (!v39) {
          goto LABEL_173;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
        BOOL v32 = "%{public}s called with null private_key_length, no backtrace";
        goto LABEL_172;
      }
      if (!v39) {
        goto LABEL_111;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
      __int16 v59 = 2082;
      uint64_t v60 = (uint64_t)backtrace_string;
      os_log_type_t v35 = "%{public}s called with null private_key_length, dumping backtrace:%{public}s";
      goto LABEL_110;
    }
    BOOL v30 = __nwlog_obj();
    os_log_type_t v31 = type;
    if (!os_log_type_enabled(v30, type)) {
      goto LABEL_173;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
    BOOL v32 = "%{public}s called with null private_key_length";
    goto LABEL_172;
  }
  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
    BOOL v29 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v55 = 0;
    if (!__nwlog_fault(v29, &type, &v55)) {
      goto LABEL_173;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v55)
      {
        BOOL v30 = __nwlog_obj();
        os_log_type_t v31 = type;
        if (!os_log_type_enabled(v30, type)) {
          goto LABEL_173;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
        BOOL v32 = "%{public}s called with null out_context, backtrace limit exceeded";
        goto LABEL_172;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v30 = __nwlog_obj();
      os_log_type_t v31 = type;
      BOOL v40 = os_log_type_enabled(v30, type);
      if (!backtrace_string)
      {
        if (!v40) {
          goto LABEL_173;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
        BOOL v32 = "%{public}s called with null out_context, no backtrace";
        goto LABEL_172;
      }
      if (!v40) {
        goto LABEL_111;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
      __int16 v59 = 2082;
      uint64_t v60 = (uint64_t)backtrace_string;
      os_log_type_t v35 = "%{public}s called with null out_context, dumping backtrace:%{public}s";
      goto LABEL_110;
    }
    BOOL v30 = __nwlog_obj();
    os_log_type_t v31 = type;
    if (!os_log_type_enabled(v30, type)) {
      goto LABEL_173;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
    BOOL v32 = "%{public}s called with null out_context";
    goto LABEL_172;
  }
  if (!a7)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
    BOOL v29 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v55 = 0;
    if (!__nwlog_fault(v29, &type, &v55)) {
      goto LABEL_173;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v55)
      {
        BOOL v30 = __nwlog_obj();
        os_log_type_t v31 = type;
        if (!os_log_type_enabled(v30, type)) {
          goto LABEL_173;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
        BOOL v32 = "%{public}s called with null out_context_length, backtrace limit exceeded";
        goto LABEL_172;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v30 = __nwlog_obj();
      os_log_type_t v31 = type;
      BOOL v41 = os_log_type_enabled(v30, type);
      if (!backtrace_string)
      {
        if (!v41) {
          goto LABEL_173;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
        BOOL v32 = "%{public}s called with null out_context_length, no backtrace";
        goto LABEL_172;
      }
      if (!v41) {
        goto LABEL_111;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
      __int16 v59 = 2082;
      uint64_t v60 = (uint64_t)backtrace_string;
      os_log_type_t v35 = "%{public}s called with null out_context_length, dumping backtrace:%{public}s";
      goto LABEL_110;
    }
    BOOL v30 = __nwlog_obj();
    os_log_type_t v31 = type;
    if (!os_log_type_enabled(v30, type)) {
      goto LABEL_173;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
    BOOL v32 = "%{public}s called with null out_context_length";
    goto LABEL_172;
  }
  if (!a8)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
    BOOL v29 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v55 = 0;
    if (!__nwlog_fault(v29, &type, &v55)) {
      goto LABEL_173;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v55)
      {
        BOOL v30 = __nwlog_obj();
        os_log_type_t v31 = type;
        if (!os_log_type_enabled(v30, type)) {
          goto LABEL_173;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
        BOOL v32 = "%{public}s called with null out_request_enc, backtrace limit exceeded";
        goto LABEL_172;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v30 = __nwlog_obj();
      os_log_type_t v31 = type;
      BOOL v42 = os_log_type_enabled(v30, type);
      if (!backtrace_string)
      {
        if (!v42) {
          goto LABEL_173;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
        BOOL v32 = "%{public}s called with null out_request_enc, no backtrace";
        goto LABEL_172;
      }
      if (!v42) {
        goto LABEL_111;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
      __int16 v59 = 2082;
      uint64_t v60 = (uint64_t)backtrace_string;
      os_log_type_t v35 = "%{public}s called with null out_request_enc, dumping backtrace:%{public}s";
      goto LABEL_110;
    }
    BOOL v30 = __nwlog_obj();
    os_log_type_t v31 = type;
    if (!os_log_type_enabled(v30, type)) {
      goto LABEL_173;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
    BOOL v32 = "%{public}s called with null out_request_enc";
    goto LABEL_172;
  }
  if (!a9)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
    BOOL v29 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v55 = 0;
    if (!__nwlog_fault(v29, &type, &v55)) {
      goto LABEL_173;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v55)
      {
        BOOL v30 = __nwlog_obj();
        os_log_type_t v31 = type;
        if (!os_log_type_enabled(v30, type)) {
          goto LABEL_173;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
        BOOL v32 = "%{public}s called with null out_request_enc_length, backtrace limit exceeded";
        goto LABEL_172;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v30 = __nwlog_obj();
      os_log_type_t v31 = type;
      BOOL v43 = os_log_type_enabled(v30, type);
      if (!backtrace_string)
      {
        if (!v43) {
          goto LABEL_173;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
        BOOL v32 = "%{public}s called with null out_request_enc_length, no backtrace";
        goto LABEL_172;
      }
      if (!v43) {
        goto LABEL_111;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
      __int16 v59 = 2082;
      uint64_t v60 = (uint64_t)backtrace_string;
      os_log_type_t v35 = "%{public}s called with null out_request_enc_length, dumping backtrace:%{public}s";
      goto LABEL_110;
    }
    BOOL v30 = __nwlog_obj();
    os_log_type_t v31 = type;
    if (!os_log_type_enabled(v30, type)) {
      goto LABEL_173;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
    BOOL v32 = "%{public}s called with null out_request_enc_length";
    goto LABEL_172;
  }
  if (a2 <= 7)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
    BOOL v29 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v55 = 0;
    if (!__nwlog_fault(v29, &type, &v55)) {
      goto LABEL_173;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v30 = __nwlog_obj();
      os_log_type_t v31 = type;
      if (!os_log_type_enabled(v30, type)) {
        goto LABEL_173;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
      BOOL v32 = "%{public}s called with null (header_length > hdr_length)";
      goto LABEL_172;
    }
    if (!v55)
    {
      BOOL v30 = __nwlog_obj();
      os_log_type_t v31 = type;
      if (!os_log_type_enabled(v30, type)) {
        goto LABEL_173;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
      BOOL v32 = "%{public}s called with null (header_length > hdr_length), backtrace limit exceeded";
      goto LABEL_172;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v30 = __nwlog_obj();
    os_log_type_t v31 = type;
    BOOL v44 = os_log_type_enabled(v30, type);
    if (!backtrace_string)
    {
      if (!v44) {
        goto LABEL_173;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
      BOOL v32 = "%{public}s called with null (header_length > hdr_length), no backtrace";
      goto LABEL_172;
    }
    if (!v44) {
      goto LABEL_111;
    }
    *(_DWORD *)unsigned int buf = 136446466;
    int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
    __int16 v59 = 2082;
    uint64_t v60 = (uint64_t)backtrace_string;
    os_log_type_t v35 = "%{public}s called with null (header_length > hdr_length), dumping backtrace:%{public}s";
LABEL_110:
    _os_log_impl(&dword_1830D4000, v30, v31, v35, buf, 0x16u);
    goto LABEL_111;
  }
  if (*(_WORD *)(a1 + 1) != 0x2000 || *(_WORD *)(a1 + 3) != 256 || *(_WORD *)(a1 + 5) != 256) {
    return 0;
  }
  size_t v15 = strlen(__s);
  if (v15 < 0x101)
  {
    size_t v18 = v15;
    cchpke_params_x25519_AESGCM128_HKDF_SHA256();
    uint64_t v54 = cchpke_params_sizeof_kem_enc();
    if (v54 + 7 == a2)
    {
      uint64_t v19 = (char *)malloc_type_calloc(1uLL, v18 + 24, 0xEAFB8F1AuLL);
      if (!v19)
      {
        BOOL v45 = __nwlog_obj();
        os_log_type_enabled(v45, OS_LOG_TYPE_ERROR);
        *(_DWORD *)unsigned int buf = 136446722;
        int v58 = "strict_calloc";
        __int16 v59 = 2048;
        uint64_t v60 = 1;
        __int16 v61 = 2048;
        uint64_t v62 = v18 + 24;
        BOOL v53 = (void *)_os_log_send_and_compose_impl();
        BOOL result = __nwlog_abort((uint64_t)v53);
        if (result) {
          goto LABEL_175;
        }
        free(v53);
      }
      size_t v20 = v18 + 17;
      snprintf(v19, v20, "%s chunked request", __s);
      size_t v21 = &v19[v20];
      int v22 = *(_DWORD *)(a1 + 3);
      *(_DWORD *)size_t v21 = *(_DWORD *)a1;
      *(_DWORD *)(v21 + 3) = v22;
      int v23 = malloc_type_calloc(1uLL, 0x60uLL, 0xEAFB8F1AuLL);
      if (!v23)
      {
        BOOL v46 = __nwlog_obj();
        os_log_type_enabled(v46, OS_LOG_TYPE_ERROR);
        *(_DWORD *)unsigned int buf = 136446722;
        int v58 = "strict_calloc";
        __int16 v59 = 2048;
        uint64_t v60 = 1;
        __int16 v61 = 2048;
        uint64_t v62 = 96;
        BOOL v47 = (void *)_os_log_send_and_compose_impl();
        BOOL result = __nwlog_abort((uint64_t)v47);
        if (result) {
          goto LABEL_175;
        }
        free(v47);
      }
      size_t v24 = (const void *)(a1 + 7);
      size_t v25 = v54;
      int v26 = cchpke_responder_setup();
      free(v19);
      if (v26)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        size_t v27 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)unsigned int buf = 136446466;
          int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
          __int16 v59 = 1024;
          LODWORD(v60) = v26;
          _os_log_impl(&dword_1830D4000, v27, OS_LOG_TYPE_ERROR, "%{public}s Setup error: %d", buf, 0x12u);
        }
        if (v23) {
          free(v23);
        }
        return 0;
      }
      *a6 = v23;
      *a7 = 96;
      if (!v54)
      {
        BOOL v49 = __nwlog_obj();
        os_log_type_enabled(v49, OS_LOG_TYPE_ERROR);
        *(_DWORD *)unsigned int buf = 136446210;
        int v58 = "strict_calloc";
        BOOL v50 = (void *)_os_log_send_and_compose_impl();
        BOOL result = __nwlog_abort((uint64_t)v50);
        if (result) {
          goto LABEL_175;
        }
        free(v50);
        size_t v25 = v54;
      }
      int v28 = malloc_type_calloc(1uLL, v25, 0xEAFB8F1AuLL);
      if (v28)
      {
LABEL_29:
        *a8 = v28;
        memcpy(v28, v24, v25);
        *a9 = v25;
        return 1;
      }
      BOOL v51 = __nwlog_obj();
      os_log_type_enabled(v51, OS_LOG_TYPE_ERROR);
      *(_DWORD *)unsigned int buf = 136446722;
      int v58 = "strict_calloc";
      __int16 v59 = 2048;
      uint64_t v60 = 1;
      __int16 v61 = 2048;
      uint64_t v62 = v25;
      BOOL v52 = (void *)_os_log_send_and_compose_impl();
      BOOL result = __nwlog_abort((uint64_t)v52);
      if (!result)
      {
        free(v52);
        size_t v25 = v54;
        goto LABEL_29;
      }
LABEL_175:
      __break(1u);
      return result;
    }
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
    BOOL v29 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v55 = 0;
    if (!__nwlog_fault(v29, &type, &v55))
    {
LABEL_173:
      if (v29) {
        free(v29);
      }
      return 0;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v30 = __nwlog_obj();
      os_log_type_t v31 = type;
      if (!os_log_type_enabled(v30, type)) {
        goto LABEL_173;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
      BOOL v32 = "%{public}s called with null (header_length == (hdr_length + enc_length))";
      goto LABEL_172;
    }
    if (!v55)
    {
      BOOL v30 = __nwlog_obj();
      os_log_type_t v31 = type;
      if (!os_log_type_enabled(v30, type)) {
        goto LABEL_173;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
      BOOL v32 = "%{public}s called with null (header_length == (hdr_length + enc_length)), backtrace limit exceeded";
      goto LABEL_172;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v30 = __nwlog_obj();
    os_log_type_t v31 = type;
    BOOL v48 = os_log_type_enabled(v30, type);
    if (!backtrace_string)
    {
      if (!v48) {
        goto LABEL_173;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
      BOOL v32 = "%{public}s called with null (header_length == (hdr_length + enc_length)), no backtrace";
      goto LABEL_172;
    }
    if (v48)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
      __int16 v59 = 2082;
      uint64_t v60 = (uint64_t)backtrace_string;
      os_log_type_t v35 = "%{public}s called with null (header_length == (hdr_length + enc_length)), dumping backtrace:%{public}s";
      goto LABEL_110;
    }
LABEL_111:
    free(backtrace_string);
    goto LABEL_173;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  size_t v16 = gLogObj;
  BOOL result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  if (!result) {
    return result;
  }
  *(_DWORD *)unsigned int buf = 136446210;
  int v58 = "nw_http_decrypt_chunked_oblivious_request_header";
  _os_log_impl(&dword_1830D4000, v16, OS_LOG_TYPE_ERROR, "%{public}s Media type exceeds max length", buf, 0xCu);
  return 0;
}

BOOL nw_http_decrypt_chunked_oblivious_request_chunk(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, size_t *a8)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
    uint64_t v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (!__nwlog_fault(v19, &type, &v41)) {
      goto LABEL_129;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v41)
      {
        size_t v20 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
          int v22 = "%{public}s called with null request_buffer, backtrace limit exceeded";
          goto LABEL_128;
        }
        goto LABEL_129;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      size_t v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      BOOL v32 = os_log_type_enabled(v20, type);
      if (!backtrace_string)
      {
        if (v32)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
          int v22 = "%{public}s called with null request_buffer, no backtrace";
          goto LABEL_128;
        }
        goto LABEL_129;
      }
      if (!v32) {
        goto LABEL_95;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
      __int16 v45 = 2082;
      uint64_t v46 = (uint64_t)backtrace_string;
      int v33 = "%{public}s called with null request_buffer, dumping backtrace:%{public}s";
      goto LABEL_94;
    }
    size_t v20 = __nwlog_obj();
    os_log_type_t v21 = type;
    if (!os_log_type_enabled(v20, type)) {
      goto LABEL_129;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
    int v22 = "%{public}s called with null request_buffer";
LABEL_128:
    _os_log_impl(&dword_1830D4000, v20, v21, v22, buf, 0xCu);
    goto LABEL_129;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
    uint64_t v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (!__nwlog_fault(v19, &type, &v41)) {
      goto LABEL_129;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v41)
      {
        size_t v20 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
          int v22 = "%{public}s called with null request_length, backtrace limit exceeded";
          goto LABEL_128;
        }
        goto LABEL_129;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      size_t v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      BOOL v34 = os_log_type_enabled(v20, type);
      if (!backtrace_string)
      {
        if (v34)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
          int v22 = "%{public}s called with null request_length, no backtrace";
          goto LABEL_128;
        }
        goto LABEL_129;
      }
      if (!v34) {
        goto LABEL_95;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
      __int16 v45 = 2082;
      uint64_t v46 = (uint64_t)backtrace_string;
      int v33 = "%{public}s called with null request_length, dumping backtrace:%{public}s";
      goto LABEL_94;
    }
    size_t v20 = __nwlog_obj();
    os_log_type_t v21 = type;
    if (!os_log_type_enabled(v20, type)) {
      goto LABEL_129;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
    int v22 = "%{public}s called with null request_length";
    goto LABEL_128;
  }
  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
    uint64_t v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (!__nwlog_fault(v19, &type, &v41)) {
      goto LABEL_129;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v41)
      {
        size_t v20 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
          int v22 = "%{public}s called with null request_context, backtrace limit exceeded";
          goto LABEL_128;
        }
        goto LABEL_129;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      size_t v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      BOOL v35 = os_log_type_enabled(v20, type);
      if (!backtrace_string)
      {
        if (v35)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
          int v22 = "%{public}s called with null request_context, no backtrace";
          goto LABEL_128;
        }
        goto LABEL_129;
      }
      if (!v35) {
        goto LABEL_95;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
      __int16 v45 = 2082;
      uint64_t v46 = (uint64_t)backtrace_string;
      int v33 = "%{public}s called with null request_context, dumping backtrace:%{public}s";
      goto LABEL_94;
    }
    size_t v20 = __nwlog_obj();
    os_log_type_t v21 = type;
    if (!os_log_type_enabled(v20, type)) {
      goto LABEL_129;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
    int v22 = "%{public}s called with null request_context";
    goto LABEL_128;
  }
  if (!a5)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
    uint64_t v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (!__nwlog_fault(v19, &type, &v41)) {
      goto LABEL_129;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v41)
      {
        size_t v20 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
          int v22 = "%{public}s called with null request_context_length, backtrace limit exceeded";
          goto LABEL_128;
        }
        goto LABEL_129;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      size_t v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      BOOL v36 = os_log_type_enabled(v20, type);
      if (!backtrace_string)
      {
        if (v36)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
          int v22 = "%{public}s called with null request_context_length, no backtrace";
          goto LABEL_128;
        }
        goto LABEL_129;
      }
      if (!v36) {
        goto LABEL_95;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
      __int16 v45 = 2082;
      uint64_t v46 = (uint64_t)backtrace_string;
      int v33 = "%{public}s called with null request_context_length, dumping backtrace:%{public}s";
      goto LABEL_94;
    }
    size_t v20 = __nwlog_obj();
    os_log_type_t v21 = type;
    if (!os_log_type_enabled(v20, type)) {
      goto LABEL_129;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
    int v22 = "%{public}s called with null request_context_length";
    goto LABEL_128;
  }
  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
    uint64_t v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (!__nwlog_fault(v19, &type, &v41)) {
      goto LABEL_129;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v41)
      {
        size_t v20 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
          int v22 = "%{public}s called with null request_enc, backtrace limit exceeded";
          goto LABEL_128;
        }
        goto LABEL_129;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      size_t v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      BOOL v37 = os_log_type_enabled(v20, type);
      if (!backtrace_string)
      {
        if (v37)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
          int v22 = "%{public}s called with null request_enc, no backtrace";
          goto LABEL_128;
        }
        goto LABEL_129;
      }
      if (!v37) {
        goto LABEL_95;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
      __int16 v45 = 2082;
      uint64_t v46 = (uint64_t)backtrace_string;
      int v33 = "%{public}s called with null request_enc, dumping backtrace:%{public}s";
      goto LABEL_94;
    }
    size_t v20 = __nwlog_obj();
    os_log_type_t v21 = type;
    if (!os_log_type_enabled(v20, type)) {
      goto LABEL_129;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
    int v22 = "%{public}s called with null request_enc";
    goto LABEL_128;
  }
  if (!a7)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
    uint64_t v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (!__nwlog_fault(v19, &type, &v41)) {
      goto LABEL_129;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v41)
      {
        size_t v20 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
          int v22 = "%{public}s called with null request_enc_length, backtrace limit exceeded";
          goto LABEL_128;
        }
        goto LABEL_129;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      size_t v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      BOOL v38 = os_log_type_enabled(v20, type);
      if (!backtrace_string)
      {
        if (v38)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
          int v22 = "%{public}s called with null request_enc_length, no backtrace";
          goto LABEL_128;
        }
        goto LABEL_129;
      }
      if (!v38) {
        goto LABEL_95;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
      __int16 v45 = 2082;
      uint64_t v46 = (uint64_t)backtrace_string;
      int v33 = "%{public}s called with null request_enc_length, dumping backtrace:%{public}s";
      goto LABEL_94;
    }
    size_t v20 = __nwlog_obj();
    os_log_type_t v21 = type;
    if (!os_log_type_enabled(v20, type)) {
      goto LABEL_129;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
    int v22 = "%{public}s called with null request_enc_length";
    goto LABEL_128;
  }
  if (!a8)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
    uint64_t v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (!__nwlog_fault(v19, &type, &v41)) {
      goto LABEL_129;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      size_t v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_129;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
      int v22 = "%{public}s called with null out_decrypted_length";
      goto LABEL_128;
    }
    if (!v41)
    {
      size_t v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
        int v22 = "%{public}s called with null out_decrypted_length, backtrace limit exceeded";
        goto LABEL_128;
      }
      goto LABEL_129;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    size_t v20 = __nwlog_obj();
    os_log_type_t v21 = type;
    BOOL v39 = os_log_type_enabled(v20, type);
    if (!backtrace_string)
    {
      if (v39)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
        int v22 = "%{public}s called with null out_decrypted_length, no backtrace";
        goto LABEL_128;
      }
      goto LABEL_129;
    }
    if (!v39) {
      goto LABEL_95;
    }
    *(_DWORD *)unsigned int buf = 136446466;
    BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
    __int16 v45 = 2082;
    uint64_t v46 = (uint64_t)backtrace_string;
    int v33 = "%{public}s called with null out_decrypted_length, dumping backtrace:%{public}s";
LABEL_94:
    _os_log_impl(&dword_1830D4000, v20, v21, v33, buf, 0x16u);
    goto LABEL_95;
  }
  cchpke_params_x25519_AESGCM128_HKDF_SHA256();
  unint64_t v11 = cchpke_params_sizeof_aead_tag();
  size_t v12 = a2 - v11;
  if (a2 <= v11)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
    uint64_t v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (!__nwlog_fault(v19, &type, &v41)) {
      goto LABEL_129;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      size_t v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
        int v22 = "%{public}s called with null (request_length > tag_length)";
        goto LABEL_128;
      }
LABEL_129:
      if (v19) {
        free(v19);
      }
      return 0;
    }
    if (!v41)
    {
      size_t v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
        int v22 = "%{public}s called with null (request_length > tag_length), backtrace limit exceeded";
        goto LABEL_128;
      }
      goto LABEL_129;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    size_t v20 = __nwlog_obj();
    os_log_type_t v21 = type;
    BOOL v40 = os_log_type_enabled(v20, type);
    if (!backtrace_string)
    {
      if (v40)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
        int v22 = "%{public}s called with null (request_length > tag_length), no backtrace";
        goto LABEL_128;
      }
      goto LABEL_129;
    }
    if (v40)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
      __int16 v45 = 2082;
      uint64_t v46 = (uint64_t)backtrace_string;
      int v33 = "%{public}s called with null (request_length > tag_length), dumping backtrace:%{public}s";
      goto LABEL_94;
    }
LABEL_95:
    free(backtrace_string);
    goto LABEL_129;
  }
  size_t v13 = v11;
  if (!v11)
  {
    int v23 = __nwlog_obj();
    os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v44 = "strict_calloc";
    size_t v24 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v24);
    if (result) {
      goto LABEL_132;
    }
    free(v24);
  }
  int v14 = malloc_type_calloc(1uLL, v13, 0xEAFB8F1AuLL);
  if (!v14)
  {
    size_t v25 = __nwlog_obj();
    os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
    *(_DWORD *)unsigned int buf = 136446722;
    BOOL v44 = "strict_calloc";
    __int16 v45 = 2048;
    uint64_t v46 = 1;
    __int16 v47 = 2048;
    size_t v48 = v13;
    int v26 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v26);
    if (result) {
      goto LABEL_132;
    }
    free(v26);
  }
  memcpy(v14, (const void *)(a1 + v12), v13);
  if (a2 == v13)
  {
    size_t v27 = __nwlog_obj();
    os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v44 = "strict_calloc";
    int v28 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v28);
    if (result) {
      goto LABEL_132;
    }
    free(v28);
  }
  size_t v15 = malloc_type_calloc(1uLL, v12, 0xEAFB8F1AuLL);
  if (v15)
  {
LABEL_13:
    int v16 = cchpke_responder_decrypt();
    if (v14) {
      free(v14);
    }
    if (v16)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      size_t v17 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)unsigned int buf = 136446466;
        BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
        __int16 v45 = 1024;
        LODWORD(v46) = v16;
        _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_ERROR, "%{public}s Decrypt error: %d", buf, 0x12u);
      }
      if (v15)
      {
        free(v15);
        return 0;
      }
    }
    else
    {
      *a8 = v12;
    }
    return (BOOL)v15;
  }
  BOOL v29 = __nwlog_obj();
  os_log_type_enabled(v29, OS_LOG_TYPE_ERROR);
  *(_DWORD *)unsigned int buf = 136446722;
  BOOL v44 = "strict_calloc";
  __int16 v45 = 2048;
  uint64_t v46 = 1;
  __int16 v47 = 2048;
  size_t v48 = v12;
  BOOL v30 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v30);
  if (!result)
  {
    free(v30);
    goto LABEL_13;
  }
LABEL_132:
  __break(1u);
  return result;
}

BOOL nw_http_encrypt_oblivious_response(uint64_t a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, const void *a6, size_t a7, void *a8)
{
  uint64_t v98 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
    BOOL v35 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v76 = 0;
    if (!__nwlog_fault(v35, &buf, &v76)) {
      goto LABEL_186;
    }
    if (buf != 17)
    {
      if (!v76)
      {
        BOOL v36 = __nwlog_obj();
        os_log_type_t v37 = buf;
        if (os_log_type_enabled(v36, (os_log_type_t)buf))
        {
          *(_DWORD *)__str = 136446210;
          *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
          BOOL v38 = "%{public}s called with null message_buffer, backtrace limit exceeded";
          goto LABEL_185;
        }
        goto LABEL_186;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v36 = __nwlog_obj();
      os_log_type_t v37 = buf;
      BOOL v43 = os_log_type_enabled(v36, (os_log_type_t)buf);
      if (!backtrace_string)
      {
        if (v43)
        {
          *(_DWORD *)__str = 136446210;
          *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
          BOOL v38 = "%{public}s called with null message_buffer, no backtrace";
          goto LABEL_185;
        }
        goto LABEL_186;
      }
      if (!v43) {
        goto LABEL_136;
      }
      *(_DWORD *)__str = 136446466;
      *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
      *(_WORD *)&__str[12] = 2082;
      *(void *)&__str[14] = backtrace_string;
      BOOL v44 = "%{public}s called with null message_buffer, dumping backtrace:%{public}s";
      goto LABEL_135;
    }
    BOOL v36 = __nwlog_obj();
    os_log_type_t v37 = buf;
    if (!os_log_type_enabled(v36, (os_log_type_t)buf)) {
      goto LABEL_186;
    }
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
    BOOL v38 = "%{public}s called with null message_buffer";
LABEL_185:
    _os_log_impl(&dword_1830D4000, v36, v37, v38, (uint8_t *)__str, 0xCu);
    goto LABEL_186;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
    BOOL v35 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v76 = 0;
    if (!__nwlog_fault(v35, &buf, &v76)) {
      goto LABEL_186;
    }
    if (buf != 17)
    {
      if (!v76)
      {
        BOOL v36 = __nwlog_obj();
        os_log_type_t v37 = buf;
        if (os_log_type_enabled(v36, (os_log_type_t)buf))
        {
          *(_DWORD *)__str = 136446210;
          *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
          BOOL v38 = "%{public}s called with null message_length, backtrace limit exceeded";
          goto LABEL_185;
        }
        goto LABEL_186;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v36 = __nwlog_obj();
      os_log_type_t v37 = buf;
      BOOL v45 = os_log_type_enabled(v36, (os_log_type_t)buf);
      if (!backtrace_string)
      {
        if (v45)
        {
          *(_DWORD *)__str = 136446210;
          *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
          BOOL v38 = "%{public}s called with null message_length, no backtrace";
          goto LABEL_185;
        }
        goto LABEL_186;
      }
      if (!v45) {
        goto LABEL_136;
      }
      *(_DWORD *)__str = 136446466;
      *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
      *(_WORD *)&__str[12] = 2082;
      *(void *)&__str[14] = backtrace_string;
      BOOL v44 = "%{public}s called with null message_length, dumping backtrace:%{public}s";
      goto LABEL_135;
    }
    BOOL v36 = __nwlog_obj();
    os_log_type_t v37 = buf;
    if (!os_log_type_enabled(v36, (os_log_type_t)buf)) {
      goto LABEL_186;
    }
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
    BOOL v38 = "%{public}s called with null message_length";
    goto LABEL_185;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
    BOOL v35 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v76 = 0;
    if (!__nwlog_fault(v35, &buf, &v76)) {
      goto LABEL_186;
    }
    if (buf != 17)
    {
      if (!v76)
      {
        BOOL v36 = __nwlog_obj();
        os_log_type_t v37 = buf;
        if (os_log_type_enabled(v36, (os_log_type_t)buf))
        {
          *(_DWORD *)__str = 136446210;
          *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
          BOOL v38 = "%{public}s called with null media_type, backtrace limit exceeded";
          goto LABEL_185;
        }
        goto LABEL_186;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v36 = __nwlog_obj();
      os_log_type_t v37 = buf;
      BOOL v46 = os_log_type_enabled(v36, (os_log_type_t)buf);
      if (!backtrace_string)
      {
        if (v46)
        {
          *(_DWORD *)__str = 136446210;
          *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
          BOOL v38 = "%{public}s called with null media_type, no backtrace";
          goto LABEL_185;
        }
        goto LABEL_186;
      }
      if (!v46) {
        goto LABEL_136;
      }
      *(_DWORD *)__str = 136446466;
      *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
      *(_WORD *)&__str[12] = 2082;
      *(void *)&__str[14] = backtrace_string;
      BOOL v44 = "%{public}s called with null media_type, dumping backtrace:%{public}s";
      goto LABEL_135;
    }
    BOOL v36 = __nwlog_obj();
    os_log_type_t v37 = buf;
    if (!os_log_type_enabled(v36, (os_log_type_t)buf)) {
      goto LABEL_186;
    }
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
    BOOL v38 = "%{public}s called with null media_type";
    goto LABEL_185;
  }
  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
    BOOL v35 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v76 = 0;
    if (!__nwlog_fault(v35, &buf, &v76)) {
      goto LABEL_186;
    }
    if (buf != 17)
    {
      if (!v76)
      {
        BOOL v36 = __nwlog_obj();
        os_log_type_t v37 = buf;
        if (os_log_type_enabled(v36, (os_log_type_t)buf))
        {
          *(_DWORD *)__str = 136446210;
          *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
          BOOL v38 = "%{public}s called with null request_context, backtrace limit exceeded";
          goto LABEL_185;
        }
        goto LABEL_186;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v36 = __nwlog_obj();
      os_log_type_t v37 = buf;
      BOOL v47 = os_log_type_enabled(v36, (os_log_type_t)buf);
      if (!backtrace_string)
      {
        if (v47)
        {
          *(_DWORD *)__str = 136446210;
          *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
          BOOL v38 = "%{public}s called with null request_context, no backtrace";
          goto LABEL_185;
        }
        goto LABEL_186;
      }
      if (!v47) {
        goto LABEL_136;
      }
      *(_DWORD *)__str = 136446466;
      *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
      *(_WORD *)&__str[12] = 2082;
      *(void *)&__str[14] = backtrace_string;
      BOOL v44 = "%{public}s called with null request_context, dumping backtrace:%{public}s";
      goto LABEL_135;
    }
    BOOL v36 = __nwlog_obj();
    os_log_type_t v37 = buf;
    if (!os_log_type_enabled(v36, (os_log_type_t)buf)) {
      goto LABEL_186;
    }
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
    BOOL v38 = "%{public}s called with null request_context";
    goto LABEL_185;
  }
  if (!a5)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
    BOOL v35 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v76 = 0;
    if (!__nwlog_fault(v35, &buf, &v76)) {
      goto LABEL_186;
    }
    if (buf != 17)
    {
      if (!v76)
      {
        BOOL v36 = __nwlog_obj();
        os_log_type_t v37 = buf;
        if (os_log_type_enabled(v36, (os_log_type_t)buf))
        {
          *(_DWORD *)__str = 136446210;
          *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
          BOOL v38 = "%{public}s called with null request_context_length, backtrace limit exceeded";
          goto LABEL_185;
        }
        goto LABEL_186;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v36 = __nwlog_obj();
      os_log_type_t v37 = buf;
      BOOL v48 = os_log_type_enabled(v36, (os_log_type_t)buf);
      if (!backtrace_string)
      {
        if (v48)
        {
          *(_DWORD *)__str = 136446210;
          *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
          BOOL v38 = "%{public}s called with null request_context_length, no backtrace";
          goto LABEL_185;
        }
        goto LABEL_186;
      }
      if (!v48) {
        goto LABEL_136;
      }
      *(_DWORD *)__str = 136446466;
      *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
      *(_WORD *)&__str[12] = 2082;
      *(void *)&__str[14] = backtrace_string;
      BOOL v44 = "%{public}s called with null request_context_length, dumping backtrace:%{public}s";
      goto LABEL_135;
    }
    BOOL v36 = __nwlog_obj();
    os_log_type_t v37 = buf;
    if (!os_log_type_enabled(v36, (os_log_type_t)buf)) {
      goto LABEL_186;
    }
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
    BOOL v38 = "%{public}s called with null request_context_length";
    goto LABEL_185;
  }
  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
    BOOL v35 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v76 = 0;
    if (!__nwlog_fault(v35, &buf, &v76)) {
      goto LABEL_186;
    }
    if (buf != 17)
    {
      if (!v76)
      {
        BOOL v36 = __nwlog_obj();
        os_log_type_t v37 = buf;
        if (os_log_type_enabled(v36, (os_log_type_t)buf))
        {
          *(_DWORD *)__str = 136446210;
          *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
          BOOL v38 = "%{public}s called with null request_enc, backtrace limit exceeded";
          goto LABEL_185;
        }
        goto LABEL_186;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v36 = __nwlog_obj();
      os_log_type_t v37 = buf;
      BOOL v49 = os_log_type_enabled(v36, (os_log_type_t)buf);
      if (!backtrace_string)
      {
        if (v49)
        {
          *(_DWORD *)__str = 136446210;
          *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
          BOOL v38 = "%{public}s called with null request_enc, no backtrace";
          goto LABEL_185;
        }
        goto LABEL_186;
      }
      if (!v49) {
        goto LABEL_136;
      }
      *(_DWORD *)__str = 136446466;
      *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
      *(_WORD *)&__str[12] = 2082;
      *(void *)&__str[14] = backtrace_string;
      BOOL v44 = "%{public}s called with null request_enc, dumping backtrace:%{public}s";
      goto LABEL_135;
    }
    BOOL v36 = __nwlog_obj();
    os_log_type_t v37 = buf;
    if (!os_log_type_enabled(v36, (os_log_type_t)buf)) {
      goto LABEL_186;
    }
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
    BOOL v38 = "%{public}s called with null request_enc";
    goto LABEL_185;
  }
  if (!a7)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
    BOOL v35 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v76 = 0;
    if (!__nwlog_fault(v35, &buf, &v76)) {
      goto LABEL_186;
    }
    if (buf == 17)
    {
      BOOL v36 = __nwlog_obj();
      os_log_type_t v37 = buf;
      if (!os_log_type_enabled(v36, (os_log_type_t)buf)) {
        goto LABEL_186;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
      BOOL v38 = "%{public}s called with null request_enc_length";
      goto LABEL_185;
    }
    if (!v76)
    {
      BOOL v36 = __nwlog_obj();
      os_log_type_t v37 = buf;
      if (os_log_type_enabled(v36, (os_log_type_t)buf))
      {
        *(_DWORD *)__str = 136446210;
        *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
        BOOL v38 = "%{public}s called with null request_enc_length, backtrace limit exceeded";
        goto LABEL_185;
      }
      goto LABEL_186;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v36 = __nwlog_obj();
    os_log_type_t v37 = buf;
    BOOL v50 = os_log_type_enabled(v36, (os_log_type_t)buf);
    if (!backtrace_string)
    {
      if (v50)
      {
        *(_DWORD *)__str = 136446210;
        *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
        BOOL v38 = "%{public}s called with null request_enc_length, no backtrace";
        goto LABEL_185;
      }
      goto LABEL_186;
    }
    if (!v50) {
      goto LABEL_136;
    }
    *(_DWORD *)__str = 136446466;
    *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
    *(_WORD *)&__str[12] = 2082;
    *(void *)&__str[14] = backtrace_string;
    BOOL v44 = "%{public}s called with null request_enc_length, dumping backtrace:%{public}s";
LABEL_135:
    _os_log_impl(&dword_1830D4000, v36, v37, v44, (uint8_t *)__str, 0x16u);
    goto LABEL_136;
  }
  if (!a8)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
    BOOL v35 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v76 = 0;
    if (!__nwlog_fault(v35, &buf, &v76)) {
      goto LABEL_186;
    }
    if (buf == 17)
    {
      BOOL v36 = __nwlog_obj();
      os_log_type_t v37 = buf;
      if (os_log_type_enabled(v36, (os_log_type_t)buf))
      {
        *(_DWORD *)__str = 136446210;
        *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
        BOOL v38 = "%{public}s called with null out_encrypted_length";
        goto LABEL_185;
      }
LABEL_186:
      if (!v35) {
        return 0;
      }
      size_t v18 = (char *)v35;
LABEL_63:
      free(v18);
      return 0;
    }
    if (!v76)
    {
      BOOL v36 = __nwlog_obj();
      os_log_type_t v37 = buf;
      if (os_log_type_enabled(v36, (os_log_type_t)buf))
      {
        *(_DWORD *)__str = 136446210;
        *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
        BOOL v38 = "%{public}s called with null out_encrypted_length, backtrace limit exceeded";
        goto LABEL_185;
      }
      goto LABEL_186;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v36 = __nwlog_obj();
    os_log_type_t v37 = buf;
    BOOL v51 = os_log_type_enabled(v36, (os_log_type_t)buf);
    if (!backtrace_string)
    {
      if (v51)
      {
        *(_DWORD *)__str = 136446210;
        *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
        BOOL v38 = "%{public}s called with null out_encrypted_length, no backtrace";
        goto LABEL_185;
      }
      goto LABEL_186;
    }
    if (v51)
    {
      *(_DWORD *)__str = 136446466;
      *(void *)&__str[4] = "nw_http_encrypt_oblivious_response";
      *(_WORD *)&__str[12] = 2082;
      *(void *)&__str[14] = backtrace_string;
      BOOL v44 = "%{public}s called with null out_encrypted_length, dumping backtrace:%{public}s";
      goto LABEL_135;
    }
LABEL_136:
    free(backtrace_string);
    goto LABEL_186;
  }
  cchpke_params_x25519_AESGCM128_HKDF_SHA256();
  size_t v11 = cchpke_params_sizeof_aead_key();
  size_t v12 = cchpke_params_sizeof_aead_nonce();
  uint64_t v74 = cchpke_params_sizeof_aead_tag();
  if (v11 <= v12) {
    size_t v13 = v12;
  }
  else {
    size_t v13 = v11;
  }
  if (!v13)
  {
    BOOL v39 = __nwlog_obj();
    os_log_type_enabled(v39, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "strict_calloc";
    BOOL v40 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v40);
    if (result) {
      goto LABEL_192;
    }
    free(v40);
  }
  int v14 = (char *)malloc_type_calloc(1uLL, v13, 0xEAFB8F1AuLL);
  if (!v14)
  {
    char v41 = __nwlog_obj();
    os_log_type_enabled(v41, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__str = 136446722;
    *(void *)&__str[4] = "strict_calloc";
    *(_WORD *)&__str[12] = 2048;
    *(void *)&__str[14] = 1;
    *(_WORD *)&__str[22] = 2048;
    *(void *)&__str[24] = v13;
    __int16 v72 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v72);
    if (result) {
      goto LABEL_192;
    }
    free(v72);
  }
  long long v90 = 0u;
  long long v91 = 0u;
  long long v88 = 0u;
  long long v89 = 0u;
  long long v86 = 0u;
  long long v87 = 0u;
  long long v84 = 0u;
  long long v85 = 0u;
  long long v82 = 0u;
  long long v83 = 0u;
  long long v80 = 0u;
  long long v81 = 0u;
  long long v78 = 0u;
  long long v79 = 0u;
  memset(__str, 0, sizeof(__str));
  snprintf(__str, 0x100uLL, "%s response", a3);
  strlen(__str);
  int v15 = cchpke_responder_export();
  if (v15)
  {
    int v16 = v15;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    size_t v17 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      int buf = 136446466;
      uint64_t v93 = "nw_http_encrypt_oblivious_response";
      __int16 v94 = 1024;
      LODWORD(v95) = v16;
      _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_ERROR, "%{public}s Export error: %d", (uint8_t *)&buf, 0x12u);
    }
    if (!v14) {
      return 0;
    }
    size_t v18 = v14;
    goto LABEL_63;
  }
  if (!(v13 + a2 + v74))
  {
    BOOL v52 = __nwlog_obj();
    os_log_type_enabled(v52, OS_LOG_TYPE_ERROR);
    int buf = 136446210;
    uint64_t v93 = "strict_calloc";
    BOOL v53 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v53);
    if (result) {
      goto LABEL_192;
    }
    free(v53);
  }
  uint64_t v19 = malloc_type_calloc(1uLL, v13 + a2 + v74, 0xEAFB8F1AuLL);
  if (!v19)
  {
    uint64_t v54 = __nwlog_obj();
    os_log_type_enabled(v54, OS_LOG_TYPE_ERROR);
    int buf = 136446722;
    uint64_t v93 = "strict_calloc";
    __int16 v94 = 2048;
    uint64_t v95 = 1;
    __int16 v96 = 2048;
    size_t v97 = v13 + a2 + v74;
    char v55 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v55);
    if (result) {
      goto LABEL_192;
    }
    free(v55);
  }
  arc4random_buf(v19, v13);
  if (!(v13 + a7))
  {
    BOOL v56 = __nwlog_obj();
    os_log_type_enabled(v56, OS_LOG_TYPE_ERROR);
    int buf = 136446210;
    uint64_t v93 = "strict_calloc";
    __int16 v57 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v57);
    if (result) {
      goto LABEL_192;
    }
    free(v57);
  }
  size_t v20 = (char *)malloc_type_calloc(1uLL, v13 + a7, 0xEAFB8F1AuLL);
  if (!v20)
  {
    int v58 = __nwlog_obj();
    os_log_type_enabled(v58, OS_LOG_TYPE_ERROR);
    int buf = 136446722;
    uint64_t v93 = "strict_calloc";
    __int16 v94 = 2048;
    uint64_t v95 = 1;
    __int16 v96 = 2048;
    size_t v97 = v13 + a7;
    int v71 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v71);
    if (result) {
      goto LABEL_192;
    }
    free(v71);
  }
  memcpy(v20, a6, a7);
  memcpy(&v20[a7], v19, v13);
  size_t v21 = cchpke_params_sizeof_kdf_hash();
  if (!v21)
  {
    __int16 v59 = __nwlog_obj();
    os_log_type_enabled(v59, OS_LOG_TYPE_ERROR);
    int buf = 136446210;
    uint64_t v93 = "strict_calloc";
    uint64_t v60 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v60);
    if (result) {
      goto LABEL_192;
    }
    free(v60);
  }
  int v22 = malloc_type_calloc(1uLL, v21, 0xEAFB8F1AuLL);
  if (!v22)
  {
    __int16 v61 = __nwlog_obj();
    os_log_type_enabled(v61, OS_LOG_TYPE_ERROR);
    int buf = 136446722;
    uint64_t v93 = "strict_calloc";
    __int16 v94 = 2048;
    uint64_t v95 = 1;
    __int16 v96 = 2048;
    size_t v97 = v21;
    uint64_t v62 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v62);
    if (result) {
      goto LABEL_192;
    }
    free(v62);
  }
  ccsha256_di();
  int v23 = cchkdf_extract();
  if (v20) {
    free(v20);
  }
  if (v14) {
    free(v14);
  }
  if (v23)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    size_t v24 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      int buf = 136446466;
      uint64_t v93 = "nw_http_encrypt_oblivious_response";
      __int16 v94 = 1024;
      LODWORD(v95) = v23;
      _os_log_impl(&dword_1830D4000, v24, OS_LOG_TYPE_ERROR, "%{public}s Extract error: %d", (uint8_t *)&buf, 0x12u);
    }
    if (v22) {
      free(v22);
    }
LABEL_61:
    if (!v19) {
      return (BOOL)v19;
    }
    size_t v18 = (char *)v19;
    goto LABEL_63;
  }
  if (!v11)
  {
    uint64_t v63 = __nwlog_obj();
    os_log_type_enabled(v63, OS_LOG_TYPE_ERROR);
    int buf = 136446210;
    uint64_t v93 = "strict_calloc";
    uint64_t v64 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v64);
    if (result) {
      goto LABEL_192;
    }
    free(v64);
  }
  size_t v25 = malloc_type_calloc(1uLL, v11, 0xEAFB8F1AuLL);
  if (!v25)
  {
    uint64_t v65 = __nwlog_obj();
    os_log_type_enabled(v65, OS_LOG_TYPE_ERROR);
    int buf = 136446722;
    uint64_t v93 = "strict_calloc";
    __int16 v94 = 2048;
    uint64_t v95 = 1;
    __int16 v96 = 2048;
    size_t v97 = v11;
    __int16 v66 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v66);
    if (result) {
      goto LABEL_192;
    }
    free(v66);
  }
  int v26 = cchkdf_expand();
  if (v26)
  {
    int v27 = v26;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v28 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      int buf = 136446466;
      uint64_t v93 = "nw_http_encrypt_oblivious_response";
      __int16 v94 = 1024;
      LODWORD(v95) = v27;
      _os_log_impl(&dword_1830D4000, v28, OS_LOG_TYPE_ERROR, "%{public}s Key expand error: %d", (uint8_t *)&buf, 0x12u);
    }
    if (v22) {
      free(v22);
    }
    if (v25) {
      free(v25);
    }
    goto LABEL_61;
  }
  if (!v12)
  {
    uint64_t v67 = __nwlog_obj();
    os_log_type_enabled(v67, OS_LOG_TYPE_ERROR);
    int buf = 136446210;
    uint64_t v93 = "strict_calloc";
    __int16 v68 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v68);
    if (result) {
      goto LABEL_192;
    }
    free(v68);
  }
  BOOL v29 = malloc_type_calloc(1uLL, v12, 0xEAFB8F1AuLL);
  if (v29) {
    goto LABEL_45;
  }
  uint64_t v69 = __nwlog_obj();
  os_log_type_enabled(v69, OS_LOG_TYPE_ERROR);
  int buf = 136446722;
  uint64_t v93 = "strict_calloc";
  __int16 v94 = 2048;
  uint64_t v95 = 1;
  __int16 v96 = 2048;
  size_t v97 = v12;
  uint64_t v70 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v70);
  if (!result)
  {
    free(v70);
LABEL_45:
    int v30 = cchkdf_expand();
    if (v22) {
      free(v22);
    }
    if (v30)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v31 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        int buf = 136446466;
        uint64_t v93 = "nw_http_encrypt_oblivious_response";
        __int16 v94 = 1024;
        LODWORD(v95) = v30;
        _os_log_impl(&dword_1830D4000, v31, OS_LOG_TYPE_ERROR, "%{public}s Nonce expand error: %d", (uint8_t *)&buf, 0x12u);
      }
      if (v25) {
        free(v25);
      }
      if (v29) {
        free(v29);
      }
    }
    else
    {
      ccaes_gcm_encrypt_mode();
      int v32 = ccgcm_one_shot();
      if (v25) {
        free(v25);
      }
      if (v29) {
        free(v29);
      }
      if (!v32)
      {
        *a8 = v13 + a2 + v74;
        return (BOOL)v19;
      }
      int v33 = __nwlog_obj();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      {
        int buf = 136446466;
        uint64_t v93 = "nw_http_encrypt_oblivious_response";
        __int16 v94 = 1024;
        LODWORD(v95) = v32;
        _os_log_impl(&dword_1830D4000, v33, OS_LOG_TYPE_ERROR, "%{public}s Encrypt error: %u", (uint8_t *)&buf, 0x12u);
      }
    }
    goto LABEL_61;
  }
LABEL_192:
  __break(1u);
  return result;
}

BOOL nw_http_generate_chunked_oblivious_response_nonce(size_t *a1)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    size_t v20 = "nw_http_generate_chunked_oblivious_response_nonce";
    unint64_t v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v7, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        double v8 = __nwlog_obj();
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)int buf = 136446210;
          size_t v20 = "nw_http_generate_chunked_oblivious_response_nonce";
          uint64_t v10 = "%{public}s called with null out_nonce_length";
LABEL_26:
          _os_log_impl(&dword_1830D4000, v8, v9, v10, buf, 0xCu);
        }
      }
      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        double v8 = __nwlog_obj();
        os_log_type_t v9 = type;
        BOOL v16 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)int buf = 136446466;
            size_t v20 = "nw_http_generate_chunked_oblivious_response_nonce";
            __int16 v21 = 2082;
            uint64_t v22 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null out_nonce_length, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_27;
        }
        if (v16)
        {
          *(_DWORD *)int buf = 136446210;
          size_t v20 = "nw_http_generate_chunked_oblivious_response_nonce";
          uint64_t v10 = "%{public}s called with null out_nonce_length, no backtrace";
          goto LABEL_26;
        }
      }
      else
      {
        double v8 = __nwlog_obj();
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)int buf = 136446210;
          size_t v20 = "nw_http_generate_chunked_oblivious_response_nonce";
          uint64_t v10 = "%{public}s called with null out_nonce_length, backtrace limit exceeded";
          goto LABEL_26;
        }
      }
    }
LABEL_27:
    if (v7) {
      free(v7);
    }
    return 0;
  }
  cchpke_params_x25519_AESGCM128_HKDF_SHA256();
  unint64_t v2 = cchpke_params_sizeof_aead_key();
  unint64_t v3 = cchpke_params_sizeof_aead_nonce();
  if (v2 <= v3) {
    size_t v4 = v3;
  }
  else {
    size_t v4 = v2;
  }
  if (!v4)
  {
    size_t v11 = __nwlog_obj();
    os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int buf = 136446210;
    size_t v20 = "strict_calloc";
    size_t v12 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v12);
    if (result) {
      goto LABEL_30;
    }
    free(v12);
  }
  unint64_t v5 = malloc_type_calloc(1uLL, v4, 0xEAFB8F1AuLL);
  if (v5)
  {
LABEL_7:
    arc4random_buf(v5, v4);
    *a1 = v4;
    return (BOOL)v5;
  }
  size_t v13 = __nwlog_obj();
  os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
  *(_DWORD *)int buf = 136446722;
  size_t v20 = "strict_calloc";
  __int16 v21 = 2048;
  uint64_t v22 = 1;
  __int16 v23 = 2048;
  size_t v24 = v4;
  int v14 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v14);
  if (!result)
  {
    free(v14);
    goto LABEL_7;
  }
LABEL_30:
  __break(1u);
  return result;
}

unint64_t nw_http_get_chunked_oblivious_response_nonce_length()
{
  cchpke_params_x25519_AESGCM128_HKDF_SHA256();
  unint64_t v0 = cchpke_params_sizeof_aead_key();
  unint64_t result = cchpke_params_sizeof_aead_nonce();
  if (v0 > result) {
    return v0;
  }
  return result;
}

BOOL nw_http_decrypt_oblivious_response(char *a1, unint64_t a2, const char *a3, uint64_t a4, uint64_t a5, const void *a6, size_t a7, size_t *a8)
{
  uint64_t v113 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
    char v41 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v91 = 0;
    if (!__nwlog_fault(v41, &buf, &v91)) {
      goto LABEL_201;
    }
    if (buf == 17)
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v43 = buf;
      if (!os_log_type_enabled(v42, (os_log_type_t)buf)) {
        goto LABEL_201;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
      BOOL v44 = "%{public}s called with null response_buffer";
      goto LABEL_200;
    }
    if (!v91)
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v43 = buf;
      if (!os_log_type_enabled(v42, (os_log_type_t)buf)) {
        goto LABEL_201;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
      BOOL v44 = "%{public}s called with null response_buffer, backtrace limit exceeded";
      goto LABEL_200;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v42 = __nwlog_obj();
    os_log_type_t v43 = buf;
    BOOL v53 = os_log_type_enabled(v42, (os_log_type_t)buf);
    if (!backtrace_string)
    {
      if (!v53) {
        goto LABEL_201;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
      BOOL v44 = "%{public}s called with null response_buffer, no backtrace";
      goto LABEL_200;
    }
    if (!v53) {
      goto LABEL_155;
    }
    *(_DWORD *)__str = 136446466;
    *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
    *(_WORD *)&__str[12] = 2082;
    *(void *)&__str[14] = backtrace_string;
    uint64_t v54 = "%{public}s called with null response_buffer, dumping backtrace:%{public}s";
LABEL_154:
    _os_log_impl(&dword_1830D4000, v42, v43, v54, (uint8_t *)__str, 0x16u);
    goto LABEL_155;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
    char v41 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v91 = 0;
    if (!__nwlog_fault(v41, &buf, &v91)) {
      goto LABEL_201;
    }
    if (buf == 17)
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v43 = buf;
      if (!os_log_type_enabled(v42, (os_log_type_t)buf)) {
        goto LABEL_201;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
      BOOL v44 = "%{public}s called with null response_length";
      goto LABEL_200;
    }
    if (!v91)
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v43 = buf;
      if (!os_log_type_enabled(v42, (os_log_type_t)buf)) {
        goto LABEL_201;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
      BOOL v44 = "%{public}s called with null response_length, backtrace limit exceeded";
      goto LABEL_200;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v42 = __nwlog_obj();
    os_log_type_t v43 = buf;
    BOOL v55 = os_log_type_enabled(v42, (os_log_type_t)buf);
    if (!backtrace_string)
    {
      if (!v55) {
        goto LABEL_201;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
      BOOL v44 = "%{public}s called with null response_length, no backtrace";
      goto LABEL_200;
    }
    if (!v55) {
      goto LABEL_155;
    }
    *(_DWORD *)__str = 136446466;
    *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
    *(_WORD *)&__str[12] = 2082;
    *(void *)&__str[14] = backtrace_string;
    uint64_t v54 = "%{public}s called with null response_length, dumping backtrace:%{public}s";
    goto LABEL_154;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
    char v41 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v91 = 0;
    if (!__nwlog_fault(v41, &buf, &v91)) {
      goto LABEL_201;
    }
    if (buf == 17)
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v43 = buf;
      if (!os_log_type_enabled(v42, (os_log_type_t)buf)) {
        goto LABEL_201;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
      BOOL v44 = "%{public}s called with null media_type";
      goto LABEL_200;
    }
    if (!v91)
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v43 = buf;
      if (!os_log_type_enabled(v42, (os_log_type_t)buf)) {
        goto LABEL_201;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
      BOOL v44 = "%{public}s called with null media_type, backtrace limit exceeded";
      goto LABEL_200;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v42 = __nwlog_obj();
    os_log_type_t v43 = buf;
    BOOL v56 = os_log_type_enabled(v42, (os_log_type_t)buf);
    if (!backtrace_string)
    {
      if (!v56) {
        goto LABEL_201;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
      BOOL v44 = "%{public}s called with null media_type, no backtrace";
      goto LABEL_200;
    }
    if (!v56) {
      goto LABEL_155;
    }
    *(_DWORD *)__str = 136446466;
    *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
    *(_WORD *)&__str[12] = 2082;
    *(void *)&__str[14] = backtrace_string;
    uint64_t v54 = "%{public}s called with null media_type, dumping backtrace:%{public}s";
    goto LABEL_154;
  }
  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
    char v41 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v91 = 0;
    if (!__nwlog_fault(v41, &buf, &v91)) {
      goto LABEL_201;
    }
    if (buf == 17)
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v43 = buf;
      if (!os_log_type_enabled(v42, (os_log_type_t)buf)) {
        goto LABEL_201;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
      BOOL v44 = "%{public}s called with null request_context";
      goto LABEL_200;
    }
    if (!v91)
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v43 = buf;
      if (!os_log_type_enabled(v42, (os_log_type_t)buf)) {
        goto LABEL_201;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
      BOOL v44 = "%{public}s called with null request_context, backtrace limit exceeded";
      goto LABEL_200;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v42 = __nwlog_obj();
    os_log_type_t v43 = buf;
    BOOL v57 = os_log_type_enabled(v42, (os_log_type_t)buf);
    if (!backtrace_string)
    {
      if (!v57) {
        goto LABEL_201;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
      BOOL v44 = "%{public}s called with null request_context, no backtrace";
      goto LABEL_200;
    }
    if (!v57) {
      goto LABEL_155;
    }
    *(_DWORD *)__str = 136446466;
    *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
    *(_WORD *)&__str[12] = 2082;
    *(void *)&__str[14] = backtrace_string;
    uint64_t v54 = "%{public}s called with null request_context, dumping backtrace:%{public}s";
    goto LABEL_154;
  }
  if (!a5)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
    char v41 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v91 = 0;
    if (!__nwlog_fault(v41, &buf, &v91)) {
      goto LABEL_201;
    }
    if (buf == 17)
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v43 = buf;
      if (!os_log_type_enabled(v42, (os_log_type_t)buf)) {
        goto LABEL_201;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
      BOOL v44 = "%{public}s called with null request_context_length";
      goto LABEL_200;
    }
    if (!v91)
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v43 = buf;
      if (!os_log_type_enabled(v42, (os_log_type_t)buf)) {
        goto LABEL_201;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
      BOOL v44 = "%{public}s called with null request_context_length, backtrace limit exceeded";
      goto LABEL_200;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v42 = __nwlog_obj();
    os_log_type_t v43 = buf;
    BOOL v58 = os_log_type_enabled(v42, (os_log_type_t)buf);
    if (!backtrace_string)
    {
      if (!v58) {
        goto LABEL_201;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
      BOOL v44 = "%{public}s called with null request_context_length, no backtrace";
      goto LABEL_200;
    }
    if (!v58) {
      goto LABEL_155;
    }
    *(_DWORD *)__str = 136446466;
    *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
    *(_WORD *)&__str[12] = 2082;
    *(void *)&__str[14] = backtrace_string;
    uint64_t v54 = "%{public}s called with null request_context_length, dumping backtrace:%{public}s";
    goto LABEL_154;
  }
  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
    char v41 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v91 = 0;
    if (!__nwlog_fault(v41, &buf, &v91)) {
      goto LABEL_201;
    }
    if (buf == 17)
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v43 = buf;
      if (!os_log_type_enabled(v42, (os_log_type_t)buf)) {
        goto LABEL_201;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
      BOOL v44 = "%{public}s called with null request_enc";
      goto LABEL_200;
    }
    if (!v91)
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v43 = buf;
      if (!os_log_type_enabled(v42, (os_log_type_t)buf)) {
        goto LABEL_201;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
      BOOL v44 = "%{public}s called with null request_enc, backtrace limit exceeded";
      goto LABEL_200;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v42 = __nwlog_obj();
    os_log_type_t v43 = buf;
    BOOL v59 = os_log_type_enabled(v42, (os_log_type_t)buf);
    if (!backtrace_string)
    {
      if (!v59) {
        goto LABEL_201;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
      BOOL v44 = "%{public}s called with null request_enc, no backtrace";
      goto LABEL_200;
    }
    if (!v59) {
      goto LABEL_155;
    }
    *(_DWORD *)__str = 136446466;
    *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
    *(_WORD *)&__str[12] = 2082;
    *(void *)&__str[14] = backtrace_string;
    uint64_t v54 = "%{public}s called with null request_enc, dumping backtrace:%{public}s";
    goto LABEL_154;
  }
  if (!a7)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
    char v41 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v91 = 0;
    if (!__nwlog_fault(v41, &buf, &v91)) {
      goto LABEL_201;
    }
    if (buf == 17)
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v43 = buf;
      if (!os_log_type_enabled(v42, (os_log_type_t)buf)) {
        goto LABEL_201;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
      BOOL v44 = "%{public}s called with null request_enc_length";
      goto LABEL_200;
    }
    if (!v91)
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v43 = buf;
      if (!os_log_type_enabled(v42, (os_log_type_t)buf)) {
        goto LABEL_201;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
      BOOL v44 = "%{public}s called with null request_enc_length, backtrace limit exceeded";
      goto LABEL_200;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v42 = __nwlog_obj();
    os_log_type_t v43 = buf;
    BOOL v60 = os_log_type_enabled(v42, (os_log_type_t)buf);
    if (!backtrace_string)
    {
      if (!v60) {
        goto LABEL_201;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
      BOOL v44 = "%{public}s called with null request_enc_length, no backtrace";
      goto LABEL_200;
    }
    if (!v60) {
      goto LABEL_155;
    }
    *(_DWORD *)__str = 136446466;
    *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
    *(_WORD *)&__str[12] = 2082;
    *(void *)&__str[14] = backtrace_string;
    uint64_t v54 = "%{public}s called with null request_enc_length, dumping backtrace:%{public}s";
    goto LABEL_154;
  }
  if (!a8)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
    char v41 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v91 = 0;
    if (!__nwlog_fault(v41, &buf, &v91)) {
      goto LABEL_201;
    }
    if (buf == 17)
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v43 = buf;
      if (!os_log_type_enabled(v42, (os_log_type_t)buf)) {
        goto LABEL_201;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
      BOOL v44 = "%{public}s called with null out_decrypted_length";
      goto LABEL_200;
    }
    if (!v91)
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v43 = buf;
      if (!os_log_type_enabled(v42, (os_log_type_t)buf)) {
        goto LABEL_201;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
      BOOL v44 = "%{public}s called with null out_decrypted_length, backtrace limit exceeded";
      goto LABEL_200;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v42 = __nwlog_obj();
    os_log_type_t v43 = buf;
    BOOL v61 = os_log_type_enabled(v42, (os_log_type_t)buf);
    if (!backtrace_string)
    {
      if (!v61) {
        goto LABEL_201;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
      BOOL v44 = "%{public}s called with null out_decrypted_length, no backtrace";
      goto LABEL_200;
    }
    if (!v61) {
      goto LABEL_155;
    }
    *(_DWORD *)__str = 136446466;
    *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
    *(_WORD *)&__str[12] = 2082;
    *(void *)&__str[14] = backtrace_string;
    uint64_t v54 = "%{public}s called with null out_decrypted_length, dumping backtrace:%{public}s";
    goto LABEL_154;
  }
  cchpke_params_x25519_AESGCM128_HKDF_SHA256();
  size_t v12 = cchpke_params_sizeof_aead_key();
  unint64_t v13 = cchpke_params_sizeof_aead_nonce();
  uint64_t v14 = cchpke_params_sizeof_aead_tag();
  size_t size = v14;
  size_t v89 = v13;
  if (v12 <= v13) {
    size_t v15 = v13;
  }
  else {
    size_t v15 = v12;
  }
  size_t v87 = a2 - (v15 + v14);
  if (a2 <= v15 + v14)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
    char v41 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v91 = 0;
    if (!__nwlog_fault(v41, &buf, &v91)) {
      goto LABEL_201;
    }
    if (buf == 17)
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v43 = buf;
      if (!os_log_type_enabled(v42, (os_log_type_t)buf)) {
        goto LABEL_201;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
      BOOL v44 = "%{public}s called with null (response_length > response_nonce_length + tag_length)";
      goto LABEL_200;
    }
    if (!v91)
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v43 = buf;
      if (!os_log_type_enabled(v42, (os_log_type_t)buf)) {
        goto LABEL_201;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
      BOOL v44 = "%{public}s called with null (response_length > response_nonce_length + tag_length), backtrace limit exceeded";
      goto LABEL_200;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v42 = __nwlog_obj();
    os_log_type_t v43 = buf;
    BOOL v62 = os_log_type_enabled(v42, (os_log_type_t)buf);
    if (backtrace_string)
    {
      if (v62)
      {
        *(_DWORD *)__str = 136446466;
        *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
        *(_WORD *)&__str[12] = 2082;
        *(void *)&__str[14] = backtrace_string;
        uint64_t v54 = "%{public}s called with null (response_length > response_nonce_length + tag_length), dumping backtrace:%{public}s";
        goto LABEL_154;
      }
LABEL_155:
      free(backtrace_string);
      goto LABEL_201;
    }
    if (!v62) {
      goto LABEL_201;
    }
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
    BOOL v44 = "%{public}s called with null (response_length > response_nonce_length + tag_length), no backtrace";
LABEL_200:
    _os_log_impl(&dword_1830D4000, v42, v43, v44, (uint8_t *)__str, 0xCu);
LABEL_201:
    if (v41) {
      free(v41);
    }
    return 0;
  }
  size_t v85 = v15 + v14;
  unint64_t v86 = a2;
  if (!(v15 + a7))
  {
    BOOL v45 = __nwlog_obj();
    os_log_type_enabled(v45, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "strict_calloc";
    BOOL v46 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v46);
    if (result) {
      goto LABEL_215;
    }
    free(v46);
  }
  BOOL v16 = (char *)malloc_type_calloc(1uLL, v15 + a7, 0xEAFB8F1AuLL);
  if (!v16)
  {
    BOOL v47 = __nwlog_obj();
    os_log_type_enabled(v47, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__str = 136446722;
    *(void *)&__str[4] = "strict_calloc";
    *(_WORD *)&__str[12] = 2048;
    *(void *)&__str[14] = 1;
    *(_WORD *)&__str[22] = 2048;
    *(void *)&__str[24] = v15 + a7;
    long long v83 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v83);
    if (result) {
      goto LABEL_215;
    }
    free(v83);
  }
  memcpy(v16, a6, a7);
  memcpy(&v16[a7], a1, v15);
  if (!v15)
  {
    BOOL v48 = __nwlog_obj();
    os_log_type_enabled(v48, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "strict_calloc";
    BOOL v49 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v49);
    if (result) {
      goto LABEL_215;
    }
    free(v49);
  }
  char v17 = malloc_type_calloc(1uLL, v15, 0xEAFB8F1AuLL);
  if (!v17)
  {
    BOOL v50 = __nwlog_obj();
    os_log_type_enabled(v50, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__str = 136446722;
    *(void *)&__str[4] = "strict_calloc";
    *(_WORD *)&__str[12] = 2048;
    *(void *)&__str[14] = 1;
    *(_WORD *)&__str[22] = 2048;
    *(void *)&__str[24] = v15;
    BOOL v51 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v51);
    if (result) {
      goto LABEL_215;
    }
    free(v51);
  }
  long long v105 = 0u;
  long long v106 = 0u;
  long long v103 = 0u;
  long long v104 = 0u;
  long long v101 = 0u;
  long long v102 = 0u;
  long long v99 = 0u;
  long long v100 = 0u;
  long long v97 = 0u;
  long long v98 = 0u;
  long long v95 = 0u;
  long long v96 = 0u;
  long long v93 = 0u;
  long long v94 = 0u;
  memset(__str, 0, sizeof(__str));
  snprintf(__str, 0x100uLL, "%s response", a3);
  strlen(__str);
  int v18 = cchpke_initiator_export();
  if (v18)
  {
    int v19 = v18;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    size_t v20 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      int buf = 136446466;
      int v108 = "nw_http_decrypt_oblivious_response";
      __int16 v109 = 1024;
      LODWORD(v110) = v19;
      _os_log_impl(&dword_1830D4000, v20, OS_LOG_TYPE_ERROR, "%{public}s Export error: %d", (uint8_t *)&buf, 0x12u);
    }
    if (v17) {
      free(v17);
    }
    if (!v16) {
      return 0;
    }
    goto LABEL_23;
  }
  size_t v22 = cchpke_params_sizeof_kdf_hash();
  if (!v22)
  {
    uint64_t v63 = __nwlog_obj();
    os_log_type_enabled(v63, OS_LOG_TYPE_ERROR);
    int buf = 136446210;
    int v108 = "strict_calloc";
    uint64_t v64 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v64);
    if (result) {
      goto LABEL_215;
    }
    free(v64);
  }
  __int16 v23 = malloc_type_calloc(1uLL, v22, 0xEAFB8F1AuLL);
  if (!v23)
  {
    uint64_t v65 = __nwlog_obj();
    os_log_type_enabled(v65, OS_LOG_TYPE_ERROR);
    int buf = 136446722;
    int v108 = "strict_calloc";
    __int16 v109 = 2048;
    uint64_t v110 = 1;
    __int16 v111 = 2048;
    size_t v112 = v22;
    __int16 v66 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v66);
    if (result) {
      goto LABEL_215;
    }
    free(v66);
  }
  ccsha256_di();
  int v24 = cchkdf_extract();
  if (v16) {
    free(v16);
  }
  if (v17) {
    free(v17);
  }
  if (v24)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v25 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      int buf = 136446466;
      int v108 = "nw_http_decrypt_oblivious_response";
      __int16 v109 = 1024;
      LODWORD(v110) = v24;
      _os_log_impl(&dword_1830D4000, v25, OS_LOG_TYPE_ERROR, "%{public}s Extract error: %d", (uint8_t *)&buf, 0x12u);
    }
    if (!v23) {
      return 0;
    }
    __int16 v21 = v23;
    goto LABEL_35;
  }
  size_t v28 = v89;
  if (!v12)
  {
    uint64_t v67 = __nwlog_obj();
    os_log_type_enabled(v67, OS_LOG_TYPE_ERROR);
    int buf = 136446210;
    int v108 = "strict_calloc";
    __int16 v68 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v68);
    if (result) {
      goto LABEL_215;
    }
    free(v68);
  }
  BOOL v16 = (char *)malloc_type_calloc(1uLL, v12, 0xEAFB8F1AuLL);
  if (!v16)
  {
    uint64_t v69 = __nwlog_obj();
    os_log_type_enabled(v69, OS_LOG_TYPE_ERROR);
    int buf = 136446722;
    int v108 = "strict_calloc";
    __int16 v109 = 2048;
    uint64_t v110 = 1;
    __int16 v111 = 2048;
    size_t v112 = v12;
    uint64_t v70 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v70);
    if (result) {
      goto LABEL_215;
    }
    free(v70);
  }
  int v29 = cchkdf_expand();
  if (v29)
  {
    int v30 = v29;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v31 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      int buf = 136446466;
      int v108 = "nw_http_decrypt_oblivious_response";
      __int16 v109 = 1024;
      LODWORD(v110) = v30;
      _os_log_impl(&dword_1830D4000, v31, OS_LOG_TYPE_ERROR, "%{public}s Key expand error: %d", (uint8_t *)&buf, 0x12u);
    }
    if (v23) {
      free(v23);
    }
    if (!v16) {
      return 0;
    }
LABEL_23:
    __int16 v21 = v16;
LABEL_35:
    free(v21);
    return 0;
  }
  if (!v89)
  {
    int v71 = __nwlog_obj();
    os_log_type_enabled(v71, OS_LOG_TYPE_ERROR);
    int buf = 136446210;
    int v108 = "strict_calloc";
    __int16 v72 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v72);
    if (result) {
      goto LABEL_215;
    }
    free(v72);
    size_t v28 = v89;
  }
  int v32 = malloc_type_calloc(1uLL, v28, 0xEAFB8F1AuLL);
  if (!v32)
  {
    BOOL v73 = __nwlog_obj();
    os_log_type_enabled(v73, OS_LOG_TYPE_ERROR);
    int buf = 136446722;
    int v108 = "strict_calloc";
    __int16 v109 = 2048;
    uint64_t v110 = 1;
    __int16 v111 = 2048;
    size_t v112 = v28;
    uint64_t v74 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v74);
    if (result) {
      goto LABEL_215;
    }
    free(v74);
  }
  int v33 = cchkdf_expand();
  if (v23) {
    free(v23);
  }
  if (v33)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v34 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      int buf = 136446466;
      int v108 = "nw_http_decrypt_oblivious_response";
      __int16 v109 = 1024;
      LODWORD(v110) = v33;
      _os_log_impl(&dword_1830D4000, v34, OS_LOG_TYPE_ERROR, "%{public}s Nonce expand error: %d", (uint8_t *)&buf, 0x12u);
    }
    if (v16) {
      free(v16);
    }
    if (!v32) {
      return 0;
    }
    __int16 v21 = v32;
    goto LABEL_35;
  }
  size_t v35 = size;
  if (!size)
  {
    BOOL v75 = __nwlog_obj();
    os_log_type_enabled(v75, OS_LOG_TYPE_ERROR);
    int buf = 136446210;
    int v108 = "strict_calloc";
    char v76 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v76);
    if (result) {
      goto LABEL_215;
    }
    free(v76);
    size_t v35 = 0;
  }
  BOOL v36 = malloc_type_calloc(1uLL, v35, 0xEAFB8F1AuLL);
  if (!v36)
  {
    size_t v77 = __nwlog_obj();
    os_log_type_enabled(v77, OS_LOG_TYPE_ERROR);
    int buf = 136446722;
    int v108 = "strict_calloc";
    __int16 v109 = 2048;
    uint64_t v110 = 1;
    __int16 v111 = 2048;
    size_t v112 = v35;
    long long v78 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v78);
    if (result) {
      goto LABEL_215;
    }
    free(v78);
    size_t v35 = size;
  }
  os_log_type_t v37 = &a1[v15];
  size_t v38 = v87;
  memcpy(v36, &v37[v87], v35);
  if (v86 == v85)
  {
    long long v79 = __nwlog_obj();
    os_log_type_enabled(v79, OS_LOG_TYPE_ERROR);
    int buf = 136446210;
    int v108 = "strict_calloc";
    long long v80 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v80);
    if (result) {
      goto LABEL_215;
    }
    free(v80);
    size_t v38 = v87;
  }
  int v26 = malloc_type_calloc(1uLL, v38, 0xEAFB8F1AuLL);
  if (v26)
  {
LABEL_62:
    ccaes_gcm_decrypt_mode();
    int v39 = ccgcm_one_shot();
    if (v16) {
      free(v16);
    }
    if (v32) {
      free(v32);
    }
    if (v36) {
      free(v36);
    }
    if (!v39)
    {
      *a8 = v38;
      return (BOOL)v26;
    }
    BOOL v40 = __nwlog_obj();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
    {
      int buf = 136446466;
      int v108 = "nw_http_decrypt_oblivious_response";
      __int16 v109 = 1024;
      LODWORD(v110) = v39;
      _os_log_impl(&dword_1830D4000, v40, OS_LOG_TYPE_ERROR, "%{public}s Decrypt error: %d", (uint8_t *)&buf, 0x12u);
    }
    if (!v26) {
      return (BOOL)v26;
    }
    __int16 v21 = v26;
    goto LABEL_35;
  }
  long long v81 = __nwlog_obj();
  os_log_type_enabled(v81, OS_LOG_TYPE_ERROR);
  int buf = 136446722;
  int v108 = "strict_calloc";
  __int16 v109 = 2048;
  uint64_t v110 = 1;
  __int16 v111 = 2048;
  size_t v112 = v38;
  long long v82 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v82);
  if (!result)
  {
    free(v82);
    size_t v38 = v87;
    goto LABEL_62;
  }
LABEL_215:
  __break(1u);
  return result;
}

BOOL nw_http_decrypt_chunked_oblivious_response_chunk(uint64_t a1, uint64_t a2, const char *a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, const void *a8, size_t a9, const void *a10, size_t a11, void *a12)
{
  uint64_t v118 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    BOOL v46 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v96 = 0;
    if (!__nwlog_fault(v46, &buf, &v96)) {
      goto LABEL_227;
    }
    if (buf != 17)
    {
      if (!v96)
      {
        BOOL v47 = __nwlog_obj();
        os_log_type_t v48 = buf;
        if (os_log_type_enabled(v47, (os_log_type_t)buf))
        {
          *(_DWORD *)__str = 136446210;
          *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          BOOL v49 = "%{public}s called with null response_buffer, backtrace limit exceeded";
          goto LABEL_226;
        }
        goto LABEL_227;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v47 = __nwlog_obj();
      os_log_type_t v48 = buf;
      BOOL v57 = os_log_type_enabled(v47, (os_log_type_t)buf);
      if (!backtrace_string)
      {
        if (v57)
        {
          *(_DWORD *)__str = 136446210;
          *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          BOOL v49 = "%{public}s called with null response_buffer, no backtrace";
          goto LABEL_226;
        }
        goto LABEL_227;
      }
      if (!v57) {
        goto LABEL_173;
      }
      *(_DWORD *)__str = 136446466;
      *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
      *(_WORD *)&__str[12] = 2082;
      *(void *)&__str[14] = backtrace_string;
      BOOL v58 = "%{public}s called with null response_buffer, dumping backtrace:%{public}s";
      goto LABEL_172;
    }
    BOOL v47 = __nwlog_obj();
    os_log_type_t v48 = buf;
    if (!os_log_type_enabled(v47, (os_log_type_t)buf)) {
      goto LABEL_227;
    }
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    BOOL v49 = "%{public}s called with null response_buffer";
LABEL_226:
    _os_log_impl(&dword_1830D4000, v47, v48, v49, (uint8_t *)__str, 0xCu);
    goto LABEL_227;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    BOOL v46 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v96 = 0;
    if (!__nwlog_fault(v46, &buf, &v96)) {
      goto LABEL_227;
    }
    if (buf != 17)
    {
      if (!v96)
      {
        BOOL v47 = __nwlog_obj();
        os_log_type_t v48 = buf;
        if (os_log_type_enabled(v47, (os_log_type_t)buf))
        {
          *(_DWORD *)__str = 136446210;
          *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          BOOL v49 = "%{public}s called with null response_length, backtrace limit exceeded";
          goto LABEL_226;
        }
        goto LABEL_227;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v47 = __nwlog_obj();
      os_log_type_t v48 = buf;
      BOOL v59 = os_log_type_enabled(v47, (os_log_type_t)buf);
      if (!backtrace_string)
      {
        if (v59)
        {
          *(_DWORD *)__str = 136446210;
          *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          BOOL v49 = "%{public}s called with null response_length, no backtrace";
          goto LABEL_226;
        }
        goto LABEL_227;
      }
      if (!v59) {
        goto LABEL_173;
      }
      *(_DWORD *)__str = 136446466;
      *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
      *(_WORD *)&__str[12] = 2082;
      *(void *)&__str[14] = backtrace_string;
      BOOL v58 = "%{public}s called with null response_length, dumping backtrace:%{public}s";
      goto LABEL_172;
    }
    BOOL v47 = __nwlog_obj();
    os_log_type_t v48 = buf;
    if (!os_log_type_enabled(v47, (os_log_type_t)buf)) {
      goto LABEL_227;
    }
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    BOOL v49 = "%{public}s called with null response_length";
    goto LABEL_226;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    BOOL v46 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v96 = 0;
    if (!__nwlog_fault(v46, &buf, &v96)) {
      goto LABEL_227;
    }
    if (buf != 17)
    {
      if (!v96)
      {
        BOOL v47 = __nwlog_obj();
        os_log_type_t v48 = buf;
        if (os_log_type_enabled(v47, (os_log_type_t)buf))
        {
          *(_DWORD *)__str = 136446210;
          *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          BOOL v49 = "%{public}s called with null media_type, backtrace limit exceeded";
          goto LABEL_226;
        }
        goto LABEL_227;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v47 = __nwlog_obj();
      os_log_type_t v48 = buf;
      BOOL v60 = os_log_type_enabled(v47, (os_log_type_t)buf);
      if (!backtrace_string)
      {
        if (v60)
        {
          *(_DWORD *)__str = 136446210;
          *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          BOOL v49 = "%{public}s called with null media_type, no backtrace";
          goto LABEL_226;
        }
        goto LABEL_227;
      }
      if (!v60) {
        goto LABEL_173;
      }
      *(_DWORD *)__str = 136446466;
      *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
      *(_WORD *)&__str[12] = 2082;
      *(void *)&__str[14] = backtrace_string;
      BOOL v58 = "%{public}s called with null media_type, dumping backtrace:%{public}s";
      goto LABEL_172;
    }
    BOOL v47 = __nwlog_obj();
    os_log_type_t v48 = buf;
    if (!os_log_type_enabled(v47, (os_log_type_t)buf)) {
      goto LABEL_227;
    }
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    BOOL v49 = "%{public}s called with null media_type";
    goto LABEL_226;
  }
  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    BOOL v46 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v96 = 0;
    if (!__nwlog_fault(v46, &buf, &v96)) {
      goto LABEL_227;
    }
    if (buf != 17)
    {
      if (!v96)
      {
        BOOL v47 = __nwlog_obj();
        os_log_type_t v48 = buf;
        if (os_log_type_enabled(v47, (os_log_type_t)buf))
        {
          *(_DWORD *)__str = 136446210;
          *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          BOOL v49 = "%{public}s called with null request_context, backtrace limit exceeded";
          goto LABEL_226;
        }
        goto LABEL_227;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v47 = __nwlog_obj();
      os_log_type_t v48 = buf;
      BOOL v61 = os_log_type_enabled(v47, (os_log_type_t)buf);
      if (!backtrace_string)
      {
        if (v61)
        {
          *(_DWORD *)__str = 136446210;
          *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          BOOL v49 = "%{public}s called with null request_context, no backtrace";
          goto LABEL_226;
        }
        goto LABEL_227;
      }
      if (!v61) {
        goto LABEL_173;
      }
      *(_DWORD *)__str = 136446466;
      *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
      *(_WORD *)&__str[12] = 2082;
      *(void *)&__str[14] = backtrace_string;
      BOOL v58 = "%{public}s called with null request_context, dumping backtrace:%{public}s";
      goto LABEL_172;
    }
    BOOL v47 = __nwlog_obj();
    os_log_type_t v48 = buf;
    if (!os_log_type_enabled(v47, (os_log_type_t)buf)) {
      goto LABEL_227;
    }
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    BOOL v49 = "%{public}s called with null request_context";
    goto LABEL_226;
  }
  if (!a7)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    BOOL v46 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v96 = 0;
    if (!__nwlog_fault(v46, &buf, &v96)) {
      goto LABEL_227;
    }
    if (buf != 17)
    {
      if (!v96)
      {
        BOOL v47 = __nwlog_obj();
        os_log_type_t v48 = buf;
        if (os_log_type_enabled(v47, (os_log_type_t)buf))
        {
          *(_DWORD *)__str = 136446210;
          *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          BOOL v49 = "%{public}s called with null request_context_length, backtrace limit exceeded";
          goto LABEL_226;
        }
        goto LABEL_227;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v47 = __nwlog_obj();
      os_log_type_t v48 = buf;
      BOOL v62 = os_log_type_enabled(v47, (os_log_type_t)buf);
      if (!backtrace_string)
      {
        if (v62)
        {
          *(_DWORD *)__str = 136446210;
          *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          BOOL v49 = "%{public}s called with null request_context_length, no backtrace";
          goto LABEL_226;
        }
        goto LABEL_227;
      }
      if (!v62) {
        goto LABEL_173;
      }
      *(_DWORD *)__str = 136446466;
      *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
      *(_WORD *)&__str[12] = 2082;
      *(void *)&__str[14] = backtrace_string;
      BOOL v58 = "%{public}s called with null request_context_length, dumping backtrace:%{public}s";
      goto LABEL_172;
    }
    BOOL v47 = __nwlog_obj();
    os_log_type_t v48 = buf;
    if (!os_log_type_enabled(v47, (os_log_type_t)buf)) {
      goto LABEL_227;
    }
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    BOOL v49 = "%{public}s called with null request_context_length";
    goto LABEL_226;
  }
  if (!a8)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    BOOL v46 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v96 = 0;
    if (!__nwlog_fault(v46, &buf, &v96)) {
      goto LABEL_227;
    }
    if (buf != 17)
    {
      if (!v96)
      {
        BOOL v47 = __nwlog_obj();
        os_log_type_t v48 = buf;
        if (os_log_type_enabled(v47, (os_log_type_t)buf))
        {
          *(_DWORD *)__str = 136446210;
          *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          BOOL v49 = "%{public}s called with null request_enc, backtrace limit exceeded";
          goto LABEL_226;
        }
        goto LABEL_227;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v47 = __nwlog_obj();
      os_log_type_t v48 = buf;
      BOOL v63 = os_log_type_enabled(v47, (os_log_type_t)buf);
      if (!backtrace_string)
      {
        if (v63)
        {
          *(_DWORD *)__str = 136446210;
          *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          BOOL v49 = "%{public}s called with null request_enc, no backtrace";
          goto LABEL_226;
        }
        goto LABEL_227;
      }
      if (!v63) {
        goto LABEL_173;
      }
      *(_DWORD *)__str = 136446466;
      *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
      *(_WORD *)&__str[12] = 2082;
      *(void *)&__str[14] = backtrace_string;
      BOOL v58 = "%{public}s called with null request_enc, dumping backtrace:%{public}s";
      goto LABEL_172;
    }
    BOOL v47 = __nwlog_obj();
    os_log_type_t v48 = buf;
    if (!os_log_type_enabled(v47, (os_log_type_t)buf)) {
      goto LABEL_227;
    }
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    BOOL v49 = "%{public}s called with null request_enc";
    goto LABEL_226;
  }
  if (!a9)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    BOOL v46 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v96 = 0;
    if (!__nwlog_fault(v46, &buf, &v96)) {
      goto LABEL_227;
    }
    if (buf != 17)
    {
      if (!v96)
      {
        BOOL v47 = __nwlog_obj();
        os_log_type_t v48 = buf;
        if (os_log_type_enabled(v47, (os_log_type_t)buf))
        {
          *(_DWORD *)__str = 136446210;
          *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          BOOL v49 = "%{public}s called with null request_enc_length, backtrace limit exceeded";
          goto LABEL_226;
        }
        goto LABEL_227;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v47 = __nwlog_obj();
      os_log_type_t v48 = buf;
      BOOL v64 = os_log_type_enabled(v47, (os_log_type_t)buf);
      if (!backtrace_string)
      {
        if (v64)
        {
          *(_DWORD *)__str = 136446210;
          *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          BOOL v49 = "%{public}s called with null request_enc_length, no backtrace";
          goto LABEL_226;
        }
        goto LABEL_227;
      }
      if (!v64) {
        goto LABEL_173;
      }
      *(_DWORD *)__str = 136446466;
      *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
      *(_WORD *)&__str[12] = 2082;
      *(void *)&__str[14] = backtrace_string;
      BOOL v58 = "%{public}s called with null request_enc_length, dumping backtrace:%{public}s";
      goto LABEL_172;
    }
    BOOL v47 = __nwlog_obj();
    os_log_type_t v48 = buf;
    if (!os_log_type_enabled(v47, (os_log_type_t)buf)) {
      goto LABEL_227;
    }
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    BOOL v49 = "%{public}s called with null request_enc_length";
    goto LABEL_226;
  }
  if (!a10)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    BOOL v46 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v96 = 0;
    if (!__nwlog_fault(v46, &buf, &v96)) {
      goto LABEL_227;
    }
    if (buf != 17)
    {
      if (!v96)
      {
        BOOL v47 = __nwlog_obj();
        os_log_type_t v48 = buf;
        if (os_log_type_enabled(v47, (os_log_type_t)buf))
        {
          *(_DWORD *)__str = 136446210;
          *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          BOOL v49 = "%{public}s called with null response_nonce, backtrace limit exceeded";
          goto LABEL_226;
        }
        goto LABEL_227;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v47 = __nwlog_obj();
      os_log_type_t v48 = buf;
      BOOL v65 = os_log_type_enabled(v47, (os_log_type_t)buf);
      if (!backtrace_string)
      {
        if (v65)
        {
          *(_DWORD *)__str = 136446210;
          *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          BOOL v49 = "%{public}s called with null response_nonce, no backtrace";
          goto LABEL_226;
        }
        goto LABEL_227;
      }
      if (!v65) {
        goto LABEL_173;
      }
      *(_DWORD *)__str = 136446466;
      *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
      *(_WORD *)&__str[12] = 2082;
      *(void *)&__str[14] = backtrace_string;
      BOOL v58 = "%{public}s called with null response_nonce, dumping backtrace:%{public}s";
      goto LABEL_172;
    }
    BOOL v47 = __nwlog_obj();
    os_log_type_t v48 = buf;
    if (!os_log_type_enabled(v47, (os_log_type_t)buf)) {
      goto LABEL_227;
    }
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    BOOL v49 = "%{public}s called with null response_nonce";
    goto LABEL_226;
  }
  if (!a11)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    BOOL v46 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v96 = 0;
    if (!__nwlog_fault(v46, &buf, &v96)) {
      goto LABEL_227;
    }
    if (buf != 17)
    {
      if (!v96)
      {
        BOOL v47 = __nwlog_obj();
        os_log_type_t v48 = buf;
        if (os_log_type_enabled(v47, (os_log_type_t)buf))
        {
          *(_DWORD *)__str = 136446210;
          *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          BOOL v49 = "%{public}s called with null response_nonce_length, backtrace limit exceeded";
          goto LABEL_226;
        }
        goto LABEL_227;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v47 = __nwlog_obj();
      os_log_type_t v48 = buf;
      BOOL v66 = os_log_type_enabled(v47, (os_log_type_t)buf);
      if (!backtrace_string)
      {
        if (v66)
        {
          *(_DWORD *)__str = 136446210;
          *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          BOOL v49 = "%{public}s called with null response_nonce_length, no backtrace";
          goto LABEL_226;
        }
        goto LABEL_227;
      }
      if (!v66) {
        goto LABEL_173;
      }
      *(_DWORD *)__str = 136446466;
      *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
      *(_WORD *)&__str[12] = 2082;
      *(void *)&__str[14] = backtrace_string;
      BOOL v58 = "%{public}s called with null response_nonce_length, dumping backtrace:%{public}s";
      goto LABEL_172;
    }
    BOOL v47 = __nwlog_obj();
    os_log_type_t v48 = buf;
    if (!os_log_type_enabled(v47, (os_log_type_t)buf)) {
      goto LABEL_227;
    }
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    BOOL v49 = "%{public}s called with null response_nonce_length";
    goto LABEL_226;
  }
  if (!a12)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    BOOL v46 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v96 = 0;
    if (!__nwlog_fault(v46, &buf, &v96)) {
      goto LABEL_227;
    }
    if (buf == 17)
    {
      BOOL v47 = __nwlog_obj();
      os_log_type_t v48 = buf;
      if (!os_log_type_enabled(v47, (os_log_type_t)buf)) {
        goto LABEL_227;
      }
      *(_DWORD *)__str = 136446210;
      *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
      BOOL v49 = "%{public}s called with null out_decrypted_length";
      goto LABEL_226;
    }
    if (!v96)
    {
      BOOL v47 = __nwlog_obj();
      os_log_type_t v48 = buf;
      if (os_log_type_enabled(v47, (os_log_type_t)buf))
      {
        *(_DWORD *)__str = 136446210;
        *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
        BOOL v49 = "%{public}s called with null out_decrypted_length, backtrace limit exceeded";
        goto LABEL_226;
      }
      goto LABEL_227;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v47 = __nwlog_obj();
    os_log_type_t v48 = buf;
    BOOL v67 = os_log_type_enabled(v47, (os_log_type_t)buf);
    if (!backtrace_string)
    {
      if (v67)
      {
        *(_DWORD *)__str = 136446210;
        *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
        BOOL v49 = "%{public}s called with null out_decrypted_length, no backtrace";
        goto LABEL_226;
      }
      goto LABEL_227;
    }
    if (!v67) {
      goto LABEL_173;
    }
    *(_DWORD *)__str = 136446466;
    *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    *(_WORD *)&__str[12] = 2082;
    *(void *)&__str[14] = backtrace_string;
    BOOL v58 = "%{public}s called with null out_decrypted_length, dumping backtrace:%{public}s";
LABEL_172:
    _os_log_impl(&dword_1830D4000, v47, v48, v58, (uint8_t *)__str, 0x16u);
    goto LABEL_173;
  }
  cchpke_params_x25519_AESGCM128_HKDF_SHA256();
  unint64_t v13 = cchpke_params_sizeof_aead_key();
  unint64_t v14 = cchpke_params_sizeof_aead_nonce();
  size_t v92 = cchpke_params_sizeof_aead_tag();
  size_t v93 = v14;
  size_t size = v13;
  if (v13 <= v14) {
    unint64_t v15 = v14;
  }
  else {
    unint64_t v15 = v13;
  }
  if (v15 != a11)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    BOOL v46 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(buf) = 16;
    char v96 = 0;
    if (!__nwlog_fault(v46, &buf, &v96)) {
      goto LABEL_227;
    }
    if (buf == 17)
    {
      BOOL v47 = __nwlog_obj();
      os_log_type_t v48 = buf;
      if (os_log_type_enabled(v47, (os_log_type_t)buf))
      {
        *(_DWORD *)__str = 136446210;
        *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
        BOOL v49 = "%{public}s called with null (response_nonce_length == exported_secret_length)";
        goto LABEL_226;
      }
LABEL_227:
      if (!v46) {
        return 0;
      }
      __int16 v21 = (char *)v46;
LABEL_60:
      free(v21);
      return 0;
    }
    if (!v96)
    {
      BOOL v47 = __nwlog_obj();
      os_log_type_t v48 = buf;
      if (os_log_type_enabled(v47, (os_log_type_t)buf))
      {
        *(_DWORD *)__str = 136446210;
        *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
        BOOL v49 = "%{public}s called with null (response_nonce_length == exported_secret_length), backtrace limit exceeded";
        goto LABEL_226;
      }
      goto LABEL_227;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v47 = __nwlog_obj();
    os_log_type_t v48 = buf;
    BOOL v68 = os_log_type_enabled(v47, (os_log_type_t)buf);
    if (!backtrace_string)
    {
      if (v68)
      {
        *(_DWORD *)__str = 136446210;
        *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
        BOOL v49 = "%{public}s called with null (response_nonce_length == exported_secret_length), no backtrace";
        goto LABEL_226;
      }
      goto LABEL_227;
    }
    if (v68)
    {
      *(_DWORD *)__str = 136446466;
      *(void *)&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
      *(_WORD *)&__str[12] = 2082;
      *(void *)&__str[14] = backtrace_string;
      BOOL v58 = "%{public}s called with null (response_nonce_length == exported_secret_length), dumping backtrace:%{public}s";
      goto LABEL_172;
    }
LABEL_173:
    free(backtrace_string);
    goto LABEL_227;
  }
  if (!(a11 + a9))
  {
    BOOL v50 = __nwlog_obj();
    os_log_type_enabled(v50, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "strict_calloc";
    BOOL v51 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v51);
    if (result) {
      goto LABEL_241;
    }
    free(v51);
  }
  BOOL v16 = (char *)malloc_type_calloc(1uLL, a11 + a9, 0xEAFB8F1AuLL);
  if (!v16)
  {
    BOOL v52 = __nwlog_obj();
    os_log_type_enabled(v52, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__str = 136446722;
    *(void *)&__str[4] = "strict_calloc";
    *(_WORD *)&__str[12] = 2048;
    *(void *)&__str[14] = 1;
    *(_WORD *)&__str[22] = 2048;
    *(void *)&__str[24] = a11 + a9;
    BOOL v53 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v53);
    if (result) {
      goto LABEL_241;
    }
    free(v53);
  }
  memcpy(v16, a8, a9);
  memcpy(&v16[a9], a10, a11);
  char v17 = malloc_type_calloc(1uLL, a11, 0xEAFB8F1AuLL);
  if (!v17)
  {
    uint64_t v54 = __nwlog_obj();
    os_log_type_enabled(v54, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__str = 136446722;
    *(void *)&__str[4] = "strict_calloc";
    *(_WORD *)&__str[12] = 2048;
    *(void *)&__str[14] = 1;
    *(_WORD *)&__str[22] = 2048;
    *(void *)&__str[24] = a11;
    BOOL v55 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v55);
    if (result) {
      goto LABEL_241;
    }
    free(v55);
  }
  long long v110 = 0u;
  long long v111 = 0u;
  long long v108 = 0u;
  long long v109 = 0u;
  long long v106 = 0u;
  long long v107 = 0u;
  long long v104 = 0u;
  long long v105 = 0u;
  long long v102 = 0u;
  long long v103 = 0u;
  long long v100 = 0u;
  long long v101 = 0u;
  long long v98 = 0u;
  long long v99 = 0u;
  memset(__str, 0, sizeof(__str));
  snprintf(__str, 0x100uLL, "%s chunked response", a3);
  strlen(__str);
  int v18 = cchpke_initiator_export();
  if (v18)
  {
    int v19 = v18;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    size_t v20 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      int buf = 136446466;
      uint64_t v113 = "nw_http_decrypt_chunked_oblivious_response_chunk";
      __int16 v114 = 1024;
      LODWORD(v115) = v19;
      _os_log_impl(&dword_1830D4000, v20, OS_LOG_TYPE_ERROR, "%{public}s Export error: %d", (uint8_t *)&buf, 0x12u);
    }
    if (v17) {
      free(v17);
    }
LABEL_23:
    if (!v16) {
      return (BOOL)v16;
    }
    __int16 v21 = v16;
    goto LABEL_60;
  }
  size_t v22 = cchpke_params_sizeof_kdf_hash();
  if (!v22)
  {
    uint64_t v69 = __nwlog_obj();
    os_log_type_enabled(v69, OS_LOG_TYPE_ERROR);
    int buf = 136446210;
    uint64_t v113 = "strict_calloc";
    uint64_t v70 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v70);
    if (result) {
      goto LABEL_241;
    }
    free(v70);
  }
  __int16 v23 = (char *)malloc_type_calloc(1uLL, v22, 0xEAFB8F1AuLL);
  if (!v23)
  {
    int v71 = __nwlog_obj();
    os_log_type_enabled(v71, OS_LOG_TYPE_ERROR);
    int buf = 136446722;
    uint64_t v113 = "strict_calloc";
    __int16 v114 = 2048;
    uint64_t v115 = 1;
    __int16 v116 = 2048;
    size_t v117 = v22;
    __int16 v72 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v72);
    if (result) {
      goto LABEL_241;
    }
    free(v72);
  }
  ccsha256_di();
  int v24 = cchkdf_extract();
  if (v16) {
    free(v16);
  }
  if (v17) {
    free(v17);
  }
  if (v24)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v25 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      int buf = 136446466;
      uint64_t v113 = "nw_http_decrypt_chunked_oblivious_response_chunk";
      __int16 v114 = 1024;
      LODWORD(v115) = v24;
      _os_log_impl(&dword_1830D4000, v25, OS_LOG_TYPE_ERROR, "%{public}s Extract error: %d", (uint8_t *)&buf, 0x12u);
    }
    if (!v23) {
      return 0;
    }
    __int16 v21 = v23;
    goto LABEL_60;
  }
  if (!size)
  {
    BOOL v73 = __nwlog_obj();
    os_log_type_enabled(v73, OS_LOG_TYPE_ERROR);
    int buf = 136446210;
    uint64_t v113 = "strict_calloc";
    uint64_t v74 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v74);
    if (result) {
      goto LABEL_241;
    }
    free(v74);
  }
  int v26 = (char *)malloc_type_calloc(1uLL, size, 0xEAFB8F1AuLL);
  if (!v26)
  {
    BOOL v75 = __nwlog_obj();
    os_log_type_enabled(v75, OS_LOG_TYPE_ERROR);
    int buf = 136446722;
    uint64_t v113 = "strict_calloc";
    __int16 v114 = 2048;
    uint64_t v115 = 1;
    __int16 v116 = 2048;
    size_t v117 = size;
    char v76 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v76);
    if (result) {
      goto LABEL_241;
    }
    free(v76);
  }
  int v27 = cchkdf_expand();
  if (v27)
  {
    int v28 = v27;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v29 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      int buf = 136446466;
      uint64_t v113 = "nw_http_decrypt_chunked_oblivious_response_chunk";
      __int16 v114 = 1024;
      LODWORD(v115) = v28;
      _os_log_impl(&dword_1830D4000, v29, OS_LOG_TYPE_ERROR, "%{public}s Key expand error: %d", (uint8_t *)&buf, 0x12u);
    }
    if (v23) {
      free(v23);
    }
    if (!v26) {
      return 0;
    }
    __int16 v21 = v26;
    goto LABEL_60;
  }
  size_t v30 = v93;
  if (!v93)
  {
    size_t v77 = __nwlog_obj();
    os_log_type_enabled(v77, OS_LOG_TYPE_ERROR);
    int buf = 136446210;
    uint64_t v113 = "strict_calloc";
    long long v78 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v78);
    if (result) {
      goto LABEL_241;
    }
    free(v78);
    size_t v30 = 0;
  }
  os_log_type_t v31 = (char *)malloc_type_calloc(1uLL, v30, 0xEAFB8F1AuLL);
  if (!v31)
  {
    long long v79 = __nwlog_obj();
    os_log_type_enabled(v79, OS_LOG_TYPE_ERROR);
    int buf = 136446722;
    uint64_t v113 = "strict_calloc";
    __int16 v114 = 2048;
    uint64_t v115 = 1;
    __int16 v116 = 2048;
    size_t v117 = v30;
    long long v80 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v80);
    if (result) {
      goto LABEL_241;
    }
    free(v80);
    size_t v30 = v93;
    os_log_type_t v31 = 0;
  }
  int v32 = cchkdf_expand();
  if (v23) {
    free(v23);
  }
  if (v32)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v33 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      int buf = 136446466;
      uint64_t v113 = "nw_http_decrypt_chunked_oblivious_response_chunk";
      __int16 v114 = 1024;
      LODWORD(v115) = v32;
      BOOL v34 = "%{public}s Nonce expand error: %d";
      size_t v35 = v33;
      uint32_t v36 = 18;
LABEL_55:
      _os_log_impl(&dword_1830D4000, v35, OS_LOG_TYPE_ERROR, v34, (uint8_t *)&buf, v36);
      goto LABEL_56;
    }
    goto LABEL_56;
  }
  if (v30 <= 7)
  {
    os_log_type_t v37 = __nwlog_obj();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
    {
      int buf = 136446466;
      uint64_t v113 = "nw_http_decrypt_chunked_oblivious_response_chunk";
      __int16 v114 = 2048;
      uint64_t v115 = v30;
      BOOL v34 = "%{public}s Bad nonce length: %zu";
      size_t v35 = v37;
      uint32_t v36 = 22;
      goto LABEL_55;
    }
LABEL_56:
    if (v26) {
      free(v26);
    }
    if (!v31) {
      return 0;
    }
    __int16 v21 = v31;
    goto LABEL_60;
  }
  int v39 = v31;
  *(void *)&v31[v30 - 8] ^= bswap64(a4);
  size_t v40 = v92;
  if (!v92)
  {
    long long v81 = __nwlog_obj();
    os_log_type_enabled(v81, OS_LOG_TYPE_ERROR);
    int buf = 136446210;
    uint64_t v113 = "strict_calloc";
    long long v82 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v82);
    if (result) {
      goto LABEL_241;
    }
    free(v82);
    size_t v40 = 0;
  }
  char v41 = malloc_type_calloc(1uLL, v40, 0xEAFB8F1AuLL);
  uint64_t v42 = a1;
  if (!v41)
  {
    long long v83 = __nwlog_obj();
    os_log_type_enabled(v83, OS_LOG_TYPE_ERROR);
    int buf = 136446722;
    uint64_t v113 = "strict_calloc";
    __int16 v114 = 2048;
    uint64_t v115 = 1;
    __int16 v116 = 2048;
    size_t v117 = v40;
    long long v84 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v84);
    if (result) {
      goto LABEL_241;
    }
    free(v84);
    uint64_t v42 = a1;
    size_t v40 = v92;
  }
  memcpy(v41, (const void *)(v42 + a2 - v40), v40);
  if (a2 == v40) {
    size_t v43 = 1;
  }
  else {
    size_t v43 = a2 - v40;
  }
  if (!v43)
  {
    size_t v85 = __nwlog_obj();
    os_log_type_enabled(v85, OS_LOG_TYPE_ERROR);
    int buf = 136446210;
    uint64_t v113 = "strict_calloc";
    unint64_t v86 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v86);
    if (result) {
      goto LABEL_241;
    }
    free(v86);
  }
  BOOL v16 = (char *)malloc_type_calloc(1uLL, v43, 0xEAFB8F1AuLL);
  if (v16)
  {
LABEL_70:
    ccaes_gcm_decrypt_mode();
    int v44 = ccgcm_one_shot();
    if (v26) {
      free(v26);
    }
    free(v39);
    if (v41) {
      free(v41);
    }
    if (!v44)
    {
      *a12 = a2 - v40;
      return (BOOL)v16;
    }
    BOOL v45 = __nwlog_obj();
    if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
    {
      int buf = 136446466;
      uint64_t v113 = "nw_http_decrypt_chunked_oblivious_response_chunk";
      __int16 v114 = 1024;
      LODWORD(v115) = v44;
      _os_log_impl(&dword_1830D4000, v45, OS_LOG_TYPE_ERROR, "%{public}s Decrypt error: %d", (uint8_t *)&buf, 0x12u);
    }
    goto LABEL_23;
  }
  size_t v87 = __nwlog_obj();
  os_log_type_enabled(v87, OS_LOG_TYPE_ERROR);
  int buf = 136446722;
  uint64_t v113 = "strict_calloc";
  __int16 v114 = 2048;
  uint64_t v115 = 1;
  __int16 v116 = 2048;
  size_t v117 = v43;
  long long v88 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v88);
  if (!result)
  {
    free(v88);
    goto LABEL_70;
  }
LABEL_241:
  __break(1u);
  return result;
}

uint64_t nw_http_get_standalone_aead_header()
{
  return 256;
}

uint64_t nw_http_get_standalone_aead_nonce_length()
{
  cchpke_params_x25519_AESGCM128_HKDF_SHA256();

  return cchpke_params_sizeof_aead_nonce();
}

BOOL nw_http_encrypt_standalone_aead_chunk(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, const void *a7, size_t a8, size_t *a9)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
    size_t v20 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (!__nwlog_fault(v20, &type, &v43)) {
      goto LABEL_137;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v43)
      {
        __int16 v21 = __nwlog_obj();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
          __int16 v23 = "%{public}s called with null message_buffer, backtrace limit exceeded";
          goto LABEL_136;
        }
        goto LABEL_137;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v21 = __nwlog_obj();
      os_log_type_t v22 = type;
      BOOL v30 = os_log_type_enabled(v21, type);
      if (!backtrace_string)
      {
        if (v30)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
          __int16 v23 = "%{public}s called with null message_buffer, no backtrace";
          goto LABEL_136;
        }
        goto LABEL_137;
      }
      if (!v30) {
        goto LABEL_99;
      }
      *(_DWORD *)int buf = 136446466;
      BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
      __int16 v47 = 2082;
      uint64_t v48 = (uint64_t)backtrace_string;
      os_log_type_t v31 = "%{public}s called with null message_buffer, dumping backtrace:%{public}s";
      goto LABEL_98;
    }
    __int16 v21 = __nwlog_obj();
    os_log_type_t v22 = type;
    if (!os_log_type_enabled(v21, type)) {
      goto LABEL_137;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
    __int16 v23 = "%{public}s called with null message_buffer";
LABEL_136:
    _os_log_impl(&dword_1830D4000, v21, v22, v23, buf, 0xCu);
    goto LABEL_137;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
    size_t v20 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (!__nwlog_fault(v20, &type, &v43)) {
      goto LABEL_137;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v43)
      {
        __int16 v21 = __nwlog_obj();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
          __int16 v23 = "%{public}s called with null message_length, backtrace limit exceeded";
          goto LABEL_136;
        }
        goto LABEL_137;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v21 = __nwlog_obj();
      os_log_type_t v22 = type;
      BOOL v32 = os_log_type_enabled(v21, type);
      if (!backtrace_string)
      {
        if (v32)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
          __int16 v23 = "%{public}s called with null message_length, no backtrace";
          goto LABEL_136;
        }
        goto LABEL_137;
      }
      if (!v32) {
        goto LABEL_99;
      }
      *(_DWORD *)int buf = 136446466;
      BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
      __int16 v47 = 2082;
      uint64_t v48 = (uint64_t)backtrace_string;
      os_log_type_t v31 = "%{public}s called with null message_length, dumping backtrace:%{public}s";
      goto LABEL_98;
    }
    __int16 v21 = __nwlog_obj();
    os_log_type_t v22 = type;
    if (!os_log_type_enabled(v21, type)) {
      goto LABEL_137;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
    __int16 v23 = "%{public}s called with null message_length";
    goto LABEL_136;
  }
  if (!a5)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
    size_t v20 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (!__nwlog_fault(v20, &type, &v43)) {
      goto LABEL_137;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v43)
      {
        __int16 v21 = __nwlog_obj();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
          __int16 v23 = "%{public}s called with null aead_key, backtrace limit exceeded";
          goto LABEL_136;
        }
        goto LABEL_137;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v21 = __nwlog_obj();
      os_log_type_t v22 = type;
      BOOL v33 = os_log_type_enabled(v21, type);
      if (!backtrace_string)
      {
        if (v33)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
          __int16 v23 = "%{public}s called with null aead_key, no backtrace";
          goto LABEL_136;
        }
        goto LABEL_137;
      }
      if (!v33) {
        goto LABEL_99;
      }
      *(_DWORD *)int buf = 136446466;
      BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
      __int16 v47 = 2082;
      uint64_t v48 = (uint64_t)backtrace_string;
      os_log_type_t v31 = "%{public}s called with null aead_key, dumping backtrace:%{public}s";
      goto LABEL_98;
    }
    __int16 v21 = __nwlog_obj();
    os_log_type_t v22 = type;
    if (!os_log_type_enabled(v21, type)) {
      goto LABEL_137;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
    __int16 v23 = "%{public}s called with null aead_key";
    goto LABEL_136;
  }
  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
    size_t v20 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (!__nwlog_fault(v20, &type, &v43)) {
      goto LABEL_137;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v43)
      {
        __int16 v21 = __nwlog_obj();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
          __int16 v23 = "%{public}s called with null aead_key_length, backtrace limit exceeded";
          goto LABEL_136;
        }
        goto LABEL_137;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v21 = __nwlog_obj();
      os_log_type_t v22 = type;
      BOOL v34 = os_log_type_enabled(v21, type);
      if (!backtrace_string)
      {
        if (v34)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
          __int16 v23 = "%{public}s called with null aead_key_length, no backtrace";
          goto LABEL_136;
        }
        goto LABEL_137;
      }
      if (!v34) {
        goto LABEL_99;
      }
      *(_DWORD *)int buf = 136446466;
      BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
      __int16 v47 = 2082;
      uint64_t v48 = (uint64_t)backtrace_string;
      os_log_type_t v31 = "%{public}s called with null aead_key_length, dumping backtrace:%{public}s";
      goto LABEL_98;
    }
    __int16 v21 = __nwlog_obj();
    os_log_type_t v22 = type;
    if (!os_log_type_enabled(v21, type)) {
      goto LABEL_137;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
    __int16 v23 = "%{public}s called with null aead_key_length";
    goto LABEL_136;
  }
  if (!a7)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
    size_t v20 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (!__nwlog_fault(v20, &type, &v43)) {
      goto LABEL_137;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v43)
      {
        __int16 v21 = __nwlog_obj();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
          __int16 v23 = "%{public}s called with null input_nonce, backtrace limit exceeded";
          goto LABEL_136;
        }
        goto LABEL_137;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v21 = __nwlog_obj();
      os_log_type_t v22 = type;
      BOOL v35 = os_log_type_enabled(v21, type);
      if (!backtrace_string)
      {
        if (v35)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
          __int16 v23 = "%{public}s called with null input_nonce, no backtrace";
          goto LABEL_136;
        }
        goto LABEL_137;
      }
      if (!v35) {
        goto LABEL_99;
      }
      *(_DWORD *)int buf = 136446466;
      BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
      __int16 v47 = 2082;
      uint64_t v48 = (uint64_t)backtrace_string;
      os_log_type_t v31 = "%{public}s called with null input_nonce, dumping backtrace:%{public}s";
      goto LABEL_98;
    }
    __int16 v21 = __nwlog_obj();
    os_log_type_t v22 = type;
    if (!os_log_type_enabled(v21, type)) {
      goto LABEL_137;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
    __int16 v23 = "%{public}s called with null input_nonce";
    goto LABEL_136;
  }
  if (!a8)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
    size_t v20 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (!__nwlog_fault(v20, &type, &v43)) {
      goto LABEL_137;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v43)
      {
        __int16 v21 = __nwlog_obj();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
          __int16 v23 = "%{public}s called with null aead_nonce_length, backtrace limit exceeded";
          goto LABEL_136;
        }
        goto LABEL_137;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v21 = __nwlog_obj();
      os_log_type_t v22 = type;
      BOOL v36 = os_log_type_enabled(v21, type);
      if (!backtrace_string)
      {
        if (v36)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
          __int16 v23 = "%{public}s called with null aead_nonce_length, no backtrace";
          goto LABEL_136;
        }
        goto LABEL_137;
      }
      if (!v36) {
        goto LABEL_99;
      }
      *(_DWORD *)int buf = 136446466;
      BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
      __int16 v47 = 2082;
      uint64_t v48 = (uint64_t)backtrace_string;
      os_log_type_t v31 = "%{public}s called with null aead_nonce_length, dumping backtrace:%{public}s";
      goto LABEL_98;
    }
    __int16 v21 = __nwlog_obj();
    os_log_type_t v22 = type;
    if (!os_log_type_enabled(v21, type)) {
      goto LABEL_137;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
    __int16 v23 = "%{public}s called with null aead_nonce_length";
    goto LABEL_136;
  }
  if (!a9)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
    size_t v20 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (!__nwlog_fault(v20, &type, &v43)) {
      goto LABEL_137;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v43)
      {
        __int16 v21 = __nwlog_obj();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
          __int16 v23 = "%{public}s called with null out_encrypted_length, backtrace limit exceeded";
          goto LABEL_136;
        }
        goto LABEL_137;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v21 = __nwlog_obj();
      os_log_type_t v22 = type;
      BOOL v37 = os_log_type_enabled(v21, type);
      if (!backtrace_string)
      {
        if (v37)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
          __int16 v23 = "%{public}s called with null out_encrypted_length, no backtrace";
          goto LABEL_136;
        }
        goto LABEL_137;
      }
      if (!v37) {
        goto LABEL_99;
      }
      *(_DWORD *)int buf = 136446466;
      BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
      __int16 v47 = 2082;
      uint64_t v48 = (uint64_t)backtrace_string;
      os_log_type_t v31 = "%{public}s called with null out_encrypted_length, dumping backtrace:%{public}s";
      goto LABEL_98;
    }
    __int16 v21 = __nwlog_obj();
    os_log_type_t v22 = type;
    if (!os_log_type_enabled(v21, type)) {
      goto LABEL_137;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
    __int16 v23 = "%{public}s called with null out_encrypted_length";
    goto LABEL_136;
  }
  cchpke_params_x25519_AESGCM128_HKDF_SHA256();
  uint64_t v42 = cchpke_params_sizeof_aead_tag();
  if (cchpke_params_sizeof_aead_key() != a6)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
    size_t v20 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (!__nwlog_fault(v20, &type, &v43)) {
      goto LABEL_137;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v21 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_137;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
      __int16 v23 = "%{public}s called with null (aead_key_length == cchpke_params_sizeof_aead_key(params))";
      goto LABEL_136;
    }
    if (!v43)
    {
      __int16 v21 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
        __int16 v23 = "%{public}s called with null (aead_key_length == cchpke_params_sizeof_aead_key(params)), backtrace limit exceeded";
        goto LABEL_136;
      }
      goto LABEL_137;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v21 = __nwlog_obj();
    os_log_type_t v22 = type;
    BOOL v38 = os_log_type_enabled(v21, type);
    if (!backtrace_string)
    {
      if (v38)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
        __int16 v23 = "%{public}s called with null (aead_key_length == cchpke_params_sizeof_aead_key(params)), no backtrace";
        goto LABEL_136;
      }
      goto LABEL_137;
    }
    if (!v38) {
      goto LABEL_99;
    }
    *(_DWORD *)int buf = 136446466;
    BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
    __int16 v47 = 2082;
    uint64_t v48 = (uint64_t)backtrace_string;
    os_log_type_t v31 = "%{public}s called with null (aead_key_length == cchpke_params_sizeof_aead_key(params)), dumping backtrace:%{public}s";
LABEL_98:
    _os_log_impl(&dword_1830D4000, v21, v22, v31, buf, 0x16u);
    goto LABEL_99;
  }
  if (cchpke_params_sizeof_aead_nonce() != a8)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
    size_t v20 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (!__nwlog_fault(v20, &type, &v43)) {
      goto LABEL_137;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v21 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
        __int16 v23 = "%{public}s called with null (aead_nonce_length == cchpke_params_sizeof_aead_nonce(params))";
        goto LABEL_136;
      }
LABEL_137:
      if (v20) {
        free(v20);
      }
      return 0;
    }
    if (!v43)
    {
      __int16 v21 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
        __int16 v23 = "%{public}s called with null (aead_nonce_length == cchpke_params_sizeof_aead_nonce(params)), backtrace limit exceeded";
        goto LABEL_136;
      }
      goto LABEL_137;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v21 = __nwlog_obj();
    os_log_type_t v22 = type;
    BOOL v39 = os_log_type_enabled(v21, type);
    if (!backtrace_string)
    {
      if (v39)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
        __int16 v23 = "%{public}s called with null (aead_nonce_length == cchpke_params_sizeof_aead_nonce(params)), no backtrace";
        goto LABEL_136;
      }
      goto LABEL_137;
    }
    if (v39)
    {
      *(_DWORD *)int buf = 136446466;
      BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
      __int16 v47 = 2082;
      uint64_t v48 = (uint64_t)backtrace_string;
      os_log_type_t v31 = "%{public}s called with null (aead_nonce_length == cchpke_params_sizeof_aead_nonce(params)), dumping backtrace:%{public}s";
      goto LABEL_98;
    }
LABEL_99:
    free(backtrace_string);
    goto LABEL_137;
  }
  unint64_t v14 = (char *)malloc_type_calloc(1uLL, a8, 0xEAFB8F1AuLL);
  if (!v14)
  {
    int v24 = __nwlog_obj();
    os_log_type_enabled(v24, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int buf = 136446722;
    BOOL v46 = "strict_calloc";
    __int16 v47 = 2048;
    uint64_t v48 = 1;
    __int16 v49 = 2048;
    size_t v50 = a8;
    char v41 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v41);
    if (result) {
      goto LABEL_140;
    }
    free(v41);
  }
  memcpy(v14, a7, a8);
  *(void *)&v14[a8 - 8] ^= bswap64(a3);
  size_t v15 = v42 + a2;
  if (!(v42 + a2))
  {
    uint64_t v25 = __nwlog_obj();
    os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int buf = 136446210;
    BOOL v46 = "strict_calloc";
    int v26 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v26);
    if (result) {
      goto LABEL_140;
    }
    free(v26);
    size_t v15 = 0;
  }
  size_t v40 = v15;
  BOOL v16 = malloc_type_calloc(1uLL, v15, 0xEAFB8F1AuLL);
  if (v16) {
    goto LABEL_13;
  }
  int v27 = __nwlog_obj();
  os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
  *(_DWORD *)int buf = 136446722;
  BOOL v46 = "strict_calloc";
  __int16 v47 = 2048;
  uint64_t v48 = 1;
  __int16 v49 = 2048;
  size_t v50 = v40;
  int v28 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v28);
  if (!result)
  {
    free(v28);
LABEL_13:
    ccaes_gcm_encrypt_mode();
    int v17 = ccgcm_one_shot();
    free(v14);
    if (v17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v18 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446466;
        BOOL v46 = "nw_http_encrypt_standalone_aead_chunk";
        __int16 v47 = 1024;
        LODWORD(v48) = v17;
        _os_log_impl(&dword_1830D4000, v18, OS_LOG_TYPE_ERROR, "%{public}s Encrypt error: %u", buf, 0x12u);
      }
      if (v16)
      {
        free(v16);
        return 0;
      }
    }
    else
    {
      *a9 = v40;
    }
    return (BOOL)v16;
  }
LABEL_140:
  __break(1u);
  return result;
}

BOOL nw_http_decrypt_standalone_aead_chunk(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, const void *a7, size_t a8, size_t *a9)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
    int v24 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v50 = 0;
    if (!__nwlog_fault(v24, &type, &v50)) {
      goto LABEL_158;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v50)
      {
        uint64_t v25 = __nwlog_obj();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
          int v27 = "%{public}s called with null encrypted_buffer, backtrace limit exceeded";
          goto LABEL_157;
        }
        goto LABEL_158;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      BOOL v38 = os_log_type_enabled(v25, type);
      if (!backtrace_string)
      {
        if (v38)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
          int v27 = "%{public}s called with null encrypted_buffer, no backtrace";
          goto LABEL_157;
        }
        goto LABEL_158;
      }
      if (!v38) {
        goto LABEL_116;
      }
      *(_DWORD *)int buf = 136446466;
      BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
      __int16 v54 = 2082;
      uint64_t v55 = (uint64_t)backtrace_string;
      BOOL v39 = "%{public}s called with null encrypted_buffer, dumping backtrace:%{public}s";
      goto LABEL_115;
    }
    uint64_t v25 = __nwlog_obj();
    os_log_type_t v26 = type;
    if (!os_log_type_enabled(v25, type)) {
      goto LABEL_158;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
    int v27 = "%{public}s called with null encrypted_buffer";
LABEL_157:
    _os_log_impl(&dword_1830D4000, v25, v26, v27, buf, 0xCu);
    goto LABEL_158;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
    int v24 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v50 = 0;
    if (!__nwlog_fault(v24, &type, &v50)) {
      goto LABEL_158;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v50)
      {
        uint64_t v25 = __nwlog_obj();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
          int v27 = "%{public}s called with null encrypted_length, backtrace limit exceeded";
          goto LABEL_157;
        }
        goto LABEL_158;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      BOOL v40 = os_log_type_enabled(v25, type);
      if (!backtrace_string)
      {
        if (v40)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
          int v27 = "%{public}s called with null encrypted_length, no backtrace";
          goto LABEL_157;
        }
        goto LABEL_158;
      }
      if (!v40) {
        goto LABEL_116;
      }
      *(_DWORD *)int buf = 136446466;
      BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
      __int16 v54 = 2082;
      uint64_t v55 = (uint64_t)backtrace_string;
      BOOL v39 = "%{public}s called with null encrypted_length, dumping backtrace:%{public}s";
      goto LABEL_115;
    }
    uint64_t v25 = __nwlog_obj();
    os_log_type_t v26 = type;
    if (!os_log_type_enabled(v25, type)) {
      goto LABEL_158;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
    int v27 = "%{public}s called with null encrypted_length";
    goto LABEL_157;
  }
  if (!a5)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
    int v24 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v50 = 0;
    if (!__nwlog_fault(v24, &type, &v50)) {
      goto LABEL_158;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v50)
      {
        uint64_t v25 = __nwlog_obj();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
          int v27 = "%{public}s called with null aead_key, backtrace limit exceeded";
          goto LABEL_157;
        }
        goto LABEL_158;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      BOOL v41 = os_log_type_enabled(v25, type);
      if (!backtrace_string)
      {
        if (v41)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
          int v27 = "%{public}s called with null aead_key, no backtrace";
          goto LABEL_157;
        }
        goto LABEL_158;
      }
      if (!v41) {
        goto LABEL_116;
      }
      *(_DWORD *)int buf = 136446466;
      BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
      __int16 v54 = 2082;
      uint64_t v55 = (uint64_t)backtrace_string;
      BOOL v39 = "%{public}s called with null aead_key, dumping backtrace:%{public}s";
      goto LABEL_115;
    }
    uint64_t v25 = __nwlog_obj();
    os_log_type_t v26 = type;
    if (!os_log_type_enabled(v25, type)) {
      goto LABEL_158;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
    int v27 = "%{public}s called with null aead_key";
    goto LABEL_157;
  }
  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
    int v24 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v50 = 0;
    if (!__nwlog_fault(v24, &type, &v50)) {
      goto LABEL_158;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v50)
      {
        uint64_t v25 = __nwlog_obj();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
          int v27 = "%{public}s called with null aead_key_length, backtrace limit exceeded";
          goto LABEL_157;
        }
        goto LABEL_158;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      BOOL v42 = os_log_type_enabled(v25, type);
      if (!backtrace_string)
      {
        if (v42)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
          int v27 = "%{public}s called with null aead_key_length, no backtrace";
          goto LABEL_157;
        }
        goto LABEL_158;
      }
      if (!v42) {
        goto LABEL_116;
      }
      *(_DWORD *)int buf = 136446466;
      BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
      __int16 v54 = 2082;
      uint64_t v55 = (uint64_t)backtrace_string;
      BOOL v39 = "%{public}s called with null aead_key_length, dumping backtrace:%{public}s";
      goto LABEL_115;
    }
    uint64_t v25 = __nwlog_obj();
    os_log_type_t v26 = type;
    if (!os_log_type_enabled(v25, type)) {
      goto LABEL_158;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
    int v27 = "%{public}s called with null aead_key_length";
    goto LABEL_157;
  }
  if (!a7)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
    int v24 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v50 = 0;
    if (!__nwlog_fault(v24, &type, &v50)) {
      goto LABEL_158;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v50)
      {
        uint64_t v25 = __nwlog_obj();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
          int v27 = "%{public}s called with null input_nonce, backtrace limit exceeded";
          goto LABEL_157;
        }
        goto LABEL_158;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      BOOL v43 = os_log_type_enabled(v25, type);
      if (!backtrace_string)
      {
        if (v43)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
          int v27 = "%{public}s called with null input_nonce, no backtrace";
          goto LABEL_157;
        }
        goto LABEL_158;
      }
      if (!v43) {
        goto LABEL_116;
      }
      *(_DWORD *)int buf = 136446466;
      BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
      __int16 v54 = 2082;
      uint64_t v55 = (uint64_t)backtrace_string;
      BOOL v39 = "%{public}s called with null input_nonce, dumping backtrace:%{public}s";
      goto LABEL_115;
    }
    uint64_t v25 = __nwlog_obj();
    os_log_type_t v26 = type;
    if (!os_log_type_enabled(v25, type)) {
      goto LABEL_158;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
    int v27 = "%{public}s called with null input_nonce";
    goto LABEL_157;
  }
  if (!a8)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
    int v24 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v50 = 0;
    if (!__nwlog_fault(v24, &type, &v50)) {
      goto LABEL_158;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v50)
      {
        uint64_t v25 = __nwlog_obj();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
          int v27 = "%{public}s called with null aead_nonce_length, backtrace limit exceeded";
          goto LABEL_157;
        }
        goto LABEL_158;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      BOOL v44 = os_log_type_enabled(v25, type);
      if (!backtrace_string)
      {
        if (v44)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
          int v27 = "%{public}s called with null aead_nonce_length, no backtrace";
          goto LABEL_157;
        }
        goto LABEL_158;
      }
      if (!v44) {
        goto LABEL_116;
      }
      *(_DWORD *)int buf = 136446466;
      BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
      __int16 v54 = 2082;
      uint64_t v55 = (uint64_t)backtrace_string;
      BOOL v39 = "%{public}s called with null aead_nonce_length, dumping backtrace:%{public}s";
      goto LABEL_115;
    }
    uint64_t v25 = __nwlog_obj();
    os_log_type_t v26 = type;
    if (!os_log_type_enabled(v25, type)) {
      goto LABEL_158;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
    int v27 = "%{public}s called with null aead_nonce_length";
    goto LABEL_157;
  }
  if (!a9)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
    int v24 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v50 = 0;
    if (!__nwlog_fault(v24, &type, &v50)) {
      goto LABEL_158;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v50)
      {
        uint64_t v25 = __nwlog_obj();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
          int v27 = "%{public}s called with null out_decrypted_length, backtrace limit exceeded";
          goto LABEL_157;
        }
        goto LABEL_158;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      BOOL v45 = os_log_type_enabled(v25, type);
      if (!backtrace_string)
      {
        if (v45)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
          int v27 = "%{public}s called with null out_decrypted_length, no backtrace";
          goto LABEL_157;
        }
        goto LABEL_158;
      }
      if (!v45) {
        goto LABEL_116;
      }
      *(_DWORD *)int buf = 136446466;
      BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
      __int16 v54 = 2082;
      uint64_t v55 = (uint64_t)backtrace_string;
      BOOL v39 = "%{public}s called with null out_decrypted_length, dumping backtrace:%{public}s";
      goto LABEL_115;
    }
    uint64_t v25 = __nwlog_obj();
    os_log_type_t v26 = type;
    if (!os_log_type_enabled(v25, type)) {
      goto LABEL_158;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
    int v27 = "%{public}s called with null out_decrypted_length";
    goto LABEL_157;
  }
  cchpke_params_x25519_AESGCM128_HKDF_SHA256();
  if (cchpke_params_sizeof_aead_key() != a6)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
    int v24 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v50 = 0;
    if (!__nwlog_fault(v24, &type, &v50)) {
      goto LABEL_158;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v50)
      {
        uint64_t v25 = __nwlog_obj();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
          int v27 = "%{public}s called with null (aead_key_length == cchpke_params_sizeof_aead_key(params)), backtrace limit exceeded";
          goto LABEL_157;
        }
        goto LABEL_158;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      BOOL v46 = os_log_type_enabled(v25, type);
      if (!backtrace_string)
      {
        if (v46)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
          int v27 = "%{public}s called with null (aead_key_length == cchpke_params_sizeof_aead_key(params)), no backtrace";
          goto LABEL_157;
        }
        goto LABEL_158;
      }
      if (!v46) {
        goto LABEL_116;
      }
      *(_DWORD *)int buf = 136446466;
      BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
      __int16 v54 = 2082;
      uint64_t v55 = (uint64_t)backtrace_string;
      BOOL v39 = "%{public}s called with null (aead_key_length == cchpke_params_sizeof_aead_key(params)), dumping backtrace:%{public}s";
      goto LABEL_115;
    }
    uint64_t v25 = __nwlog_obj();
    os_log_type_t v26 = type;
    if (!os_log_type_enabled(v25, type)) {
      goto LABEL_158;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
    int v27 = "%{public}s called with null (aead_key_length == cchpke_params_sizeof_aead_key(params))";
    goto LABEL_157;
  }
  if (cchpke_params_sizeof_aead_nonce() != a8)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
    int v24 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v50 = 0;
    if (!__nwlog_fault(v24, &type, &v50)) {
      goto LABEL_158;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (!os_log_type_enabled(v25, type)) {
        goto LABEL_158;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
      int v27 = "%{public}s called with null (aead_nonce_length == cchpke_params_sizeof_aead_nonce(params))";
      goto LABEL_157;
    }
    if (!v50)
    {
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
        int v27 = "%{public}s called with null (aead_nonce_length == cchpke_params_sizeof_aead_nonce(params)), backtrace limit exceeded";
        goto LABEL_157;
      }
      goto LABEL_158;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v25 = __nwlog_obj();
    os_log_type_t v26 = type;
    BOOL v47 = os_log_type_enabled(v25, type);
    if (!backtrace_string)
    {
      if (v47)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
        int v27 = "%{public}s called with null (aead_nonce_length == cchpke_params_sizeof_aead_nonce(params)), no backtrace";
        goto LABEL_157;
      }
      goto LABEL_158;
    }
    if (!v47) {
      goto LABEL_116;
    }
    *(_DWORD *)int buf = 136446466;
    BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
    __int16 v54 = 2082;
    uint64_t v55 = (uint64_t)backtrace_string;
    BOOL v39 = "%{public}s called with null (aead_nonce_length == cchpke_params_sizeof_aead_nonce(params)), dumping backtrace:%{public}s";
LABEL_115:
    _os_log_impl(&dword_1830D4000, v25, v26, v39, buf, 0x16u);
    goto LABEL_116;
  }
  unint64_t v15 = cchpke_params_sizeof_aead_tag();
  size_t v16 = a2 - v15;
  if (a2 <= v15)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
    int v24 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v50 = 0;
    if (!__nwlog_fault(v24, &type, &v50)) {
      goto LABEL_158;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
        int v27 = "%{public}s called with null (encrypted_length > tag_length)";
        goto LABEL_157;
      }
LABEL_158:
      if (v24) {
        free(v24);
      }
      return 0;
    }
    if (!v50)
    {
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
        int v27 = "%{public}s called with null (encrypted_length > tag_length), backtrace limit exceeded";
        goto LABEL_157;
      }
      goto LABEL_158;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v25 = __nwlog_obj();
    os_log_type_t v26 = type;
    BOOL v48 = os_log_type_enabled(v25, type);
    if (!backtrace_string)
    {
      if (v48)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
        int v27 = "%{public}s called with null (encrypted_length > tag_length), no backtrace";
        goto LABEL_157;
      }
      goto LABEL_158;
    }
    if (v48)
    {
      *(_DWORD *)int buf = 136446466;
      BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
      __int16 v54 = 2082;
      uint64_t v55 = (uint64_t)backtrace_string;
      BOOL v39 = "%{public}s called with null (encrypted_length > tag_length), dumping backtrace:%{public}s";
      goto LABEL_115;
    }
LABEL_116:
    free(backtrace_string);
    goto LABEL_158;
  }
  size_t v17 = v15;
  int v18 = (char *)malloc_type_calloc(1uLL, a8, 0xEAFB8F1AuLL);
  if (!v18)
  {
    int v28 = __nwlog_obj();
    os_log_type_enabled(v28, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int buf = 136446722;
    BOOL v53 = "strict_calloc";
    __int16 v54 = 2048;
    uint64_t v55 = 1;
    __int16 v56 = 2048;
    size_t v57 = a8;
    __int16 v49 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v49);
    if (result) {
      goto LABEL_161;
    }
    free(v49);
  }
  memcpy(v18, a7, a8);
  *(void *)&v18[a8 - 8] ^= bswap64(a3);
  if (!v17)
  {
    int v29 = __nwlog_obj();
    os_log_type_enabled(v29, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int buf = 136446210;
    BOOL v53 = "strict_calloc";
    BOOL v30 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v30);
    if (result) {
      goto LABEL_161;
    }
    free(v30);
  }
  int v19 = malloc_type_calloc(1uLL, v17, 0xEAFB8F1AuLL);
  if (!v19)
  {
    os_log_type_t v31 = __nwlog_obj();
    os_log_type_enabled(v31, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int buf = 136446722;
    BOOL v53 = "strict_calloc";
    __int16 v54 = 2048;
    uint64_t v55 = 1;
    __int16 v56 = 2048;
    size_t v57 = v17;
    BOOL v32 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v32);
    if (result) {
      goto LABEL_161;
    }
    free(v32);
  }
  memcpy(v19, (const void *)(a1 + v16), v17);
  if (a2 == v17)
  {
    BOOL v33 = __nwlog_obj();
    os_log_type_enabled(v33, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int buf = 136446210;
    BOOL v53 = "strict_calloc";
    BOOL v34 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v34);
    if (result) {
      goto LABEL_161;
    }
    free(v34);
  }
  size_t v20 = malloc_type_calloc(1uLL, v16, 0xEAFB8F1AuLL);
  if (v20)
  {
LABEL_16:
    ccaes_gcm_decrypt_mode();
    int v21 = ccgcm_one_shot();
    free(v18);
    if (v19) {
      free(v19);
    }
    if (v21)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v22 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446466;
        BOOL v53 = "nw_http_decrypt_standalone_aead_chunk";
        __int16 v54 = 1024;
        LODWORD(v55) = v21;
        _os_log_impl(&dword_1830D4000, v22, OS_LOG_TYPE_ERROR, "%{public}s Decrypt error: %d", buf, 0x12u);
      }
      if (v20)
      {
        free(v20);
        return 0;
      }
    }
    else
    {
      *a9 = v16;
    }
    return (BOOL)v20;
  }
  BOOL v35 = __nwlog_obj();
  os_log_type_enabled(v35, OS_LOG_TYPE_ERROR);
  *(_DWORD *)int buf = 136446722;
  BOOL v53 = "strict_calloc";
  __int16 v54 = 2048;
  uint64_t v55 = 1;
  __int16 v56 = 2048;
  size_t v57 = v16;
  BOOL v36 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v36);
  if (!result)
  {
    free(v36);
    goto LABEL_16;
  }
LABEL_161:
  __break(1u);
  return result;
}

void sub_183B96754(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)NWConcrete_nw_proxy_hop;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

NWConcrete_nw_proxy_hop *nw_proxy_hop_create_masque(void *a1)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  id v2 = a1;
  if (v2)
  {
    unint64_t v3 = objc_alloc_init(NWConcrete_nw_proxy_hop);
    size_t v4 = v3;
    if (v3)
    {
      objc_storeStrong((id *)&v3->endpoint, a1);
      if (nw_protocol_masque_get_definition(void)::onceToken != -1) {
        dispatch_once(&nw_protocol_masque_get_definition(void)::onceToken, &__block_literal_global_27403);
      }
      if (nw_protocol_masque_get_definition(void)::definition
        && (unint64_t v5 = os_retain((void *)nw_protocol_masque_get_definition(void)::definition)) != 0)
      {
        unint64_t v6 = os_retain(v5);
      }
      else
      {
        unint64_t v6 = 0;
      }
      options = nw_proxy_create_options(v6);
      double v8 = v4->options;
      v4->options = (OS_nw_protocol_options *)options;

      os_log_type_t v9 = v4;
      goto LABEL_29;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v10 = (id)gLogObj;
    *(_DWORD *)int buf = 136446210;
    BOOL v30 = "nw_proxy_hop_create_masque";
    size_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (__nwlog_fault(v11, &type, &v27))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        size_t v12 = (id)gLogObj;
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v30 = "nw_proxy_hop_create_masque";
          _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s [nw_proxy_hop init] failed", buf, 0xCu);
        }
      }
      else if (v27)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        size_t v12 = (id)gLogObj;
        os_log_type_t v15 = type;
        BOOL v16 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)int buf = 136446466;
            BOOL v30 = "nw_proxy_hop_create_masque";
            __int16 v31 = 2082;
            BOOL v32 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s [nw_proxy_hop init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v11) {
            goto LABEL_29;
          }
          goto LABEL_28;
        }
        if (v16)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v30 = "nw_proxy_hop_create_masque";
          _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s [nw_proxy_hop init] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        size_t v12 = (id)gLogObj;
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v30 = "nw_proxy_hop_create_masque";
          _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s [nw_proxy_hop init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    if (!v11)
    {
LABEL_29:

      goto LABEL_30;
    }
LABEL_28:
    free(v11);
    goto LABEL_29;
  }
  int v19 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  BOOL v30 = "nw_proxy_hop_create_masque";
  size_t v20 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v27 = 0;
  if (__nwlog_fault(v20, &type, &v27))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v21 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v30 = "nw_proxy_hop_create_masque";
        _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s called with null proxy_endpoint", buf, 0xCu);
      }
    }
    else if (v27)
    {
      __int16 v23 = (char *)__nw_create_backtrace_string();
      int v21 = __nwlog_obj();
      os_log_type_t v24 = type;
      BOOL v25 = os_log_type_enabled(v21, type);
      if (v23)
      {
        if (v25)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v30 = "nw_proxy_hop_create_masque";
          __int16 v31 = 2082;
          BOOL v32 = v23;
          _os_log_impl(&dword_1830D4000, v21, v24, "%{public}s called with null proxy_endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v23);
        goto LABEL_47;
      }
      if (v25)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v30 = "nw_proxy_hop_create_masque";
        _os_log_impl(&dword_1830D4000, v21, v24, "%{public}s called with null proxy_endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v21 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v30 = "nw_proxy_hop_create_masque";
        _os_log_impl(&dword_1830D4000, v21, v26, "%{public}s called with null proxy_endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_47:
  if (v20) {
    free(v20);
  }
  size_t v4 = 0;
LABEL_30:

  return v4;
}

void sub_183B96FD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_proxy_hop_set_masque_version(void *a1, int a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  unint64_t v3 = a1;
  size_t v4 = v3;
  if (!v3)
  {
    unint64_t v5 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v22 = "nw_proxy_hop_set_masque_version";
    unint64_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19)) {
      goto LABEL_38;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v22 = "nw_proxy_hop_set_masque_version";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null hop", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v22 = "nw_proxy_hop_set_masque_version";
          __int16 v23 = 2082;
          os_log_type_t v24 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6) {
          goto LABEL_4;
        }
LABEL_39:
        free(v6);
        goto LABEL_4;
      }
      if (v13)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v22 = "nw_proxy_hop_set_masque_version";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      unint64_t v7 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v22 = "nw_proxy_hop_set_masque_version";
        _os_log_impl(&dword_1830D4000, v7, v17, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (nw_protocol_options_is_masque(v3[5]))
  {
    nw_masque_options_set_version(v4[5], a2);
    goto LABEL_4;
  }
  os_log_type_t v9 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v22 = "nw_proxy_hop_set_masque_version";
  unint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19)) {
    goto LABEL_38;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    unint64_t v7 = __nwlog_obj();
    os_log_type_t v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v22 = "nw_proxy_hop_set_masque_version";
      _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_options_is_masque(hop->options)", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v19)
  {
    unint64_t v7 = __nwlog_obj();
    os_log_type_t v18 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v22 = "nw_proxy_hop_set_masque_version";
      _os_log_impl(&dword_1830D4000, v7, v18, "%{public}s called with null nw_protocol_options_is_masque(hop->options), backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  unint64_t v14 = (char *)__nw_create_backtrace_string();
  unint64_t v7 = __nwlog_obj();
  os_log_type_t v15 = type;
  BOOL v16 = os_log_type_enabled(v7, type);
  if (!v14)
  {
    if (v16)
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v22 = "nw_proxy_hop_set_masque_version";
      _os_log_impl(&dword_1830D4000, v7, v15, "%{public}s called with null nw_protocol_options_is_masque(hop->options), no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v16)
  {
    *(_DWORD *)int buf = 136446466;
    os_log_type_t v22 = "nw_proxy_hop_set_masque_version";
    __int16 v23 = 2082;
    os_log_type_t v24 = v14;
    _os_log_impl(&dword_1830D4000, v7, v15, "%{public}s called with null nw_protocol_options_is_masque(hop->options), dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v6) {
    goto LABEL_39;
  }
LABEL_4:
}

void nw_proxy_hop_set_supports_raw_ip(void *a1, char a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  unint64_t v3 = a1;
  size_t v4 = v3;
  if (v3)
  {
    *((unsigned char *)v3 + 80) = (_BYTE)v3[10] & 0xFE | a2;
    if (nw_protocol_options_is_masque(v3[5]))
    {
      nw_masque_options_set_allow_connect_ip(v4[5], a2);
      if (nw_masque_options_get_version(v4[5]) == 1) {
        nw_masque_options_set_version(v4[5], 2);
      }
    }
    goto LABEL_5;
  }
  unint64_t v5 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  BOOL v16 = "nw_proxy_hop_set_supports_raw_ip";
  unint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v16 = "nw_proxy_hop_set_supports_raw_ip";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null hop", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v16 = "nw_proxy_hop_set_supports_raw_ip";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v16 = "nw_proxy_hop_set_supports_raw_ip";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      unint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v16 = "nw_proxy_hop_set_supports_raw_ip";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_22:
  if (v6) {
    free(v6);
  }
LABEL_5:
}

void nw_proxy_hop_set_supports_udp_listen(void *a1, int a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  unint64_t v3 = a1;
  size_t v4 = v3;
  if (v3)
  {
    if (a2) {
      char v5 = 64;
    }
    else {
      char v5 = 0;
    }
    *((unsigned char *)v3 + 80) = (_BYTE)v3[10] & 0xBF | v5;
    if (nw_protocol_options_is_masque(v3[5]) && nw_masque_options_get_version(v4[5]) == 1) {
      nw_masque_options_set_version(v4[5], 2);
    }
    goto LABEL_8;
  }
  unint64_t v6 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  __int16 v17 = "nw_proxy_hop_set_supports_udp_listen";
  unint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v17 = "nw_proxy_hop_set_supports_udp_listen";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null hop", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)int buf = 136446466;
          __int16 v17 = "nw_proxy_hop_set_supports_udp_listen";
          __int16 v18 = 2082;
          uint64_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_25;
      }
      if (v12)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v17 = "nw_proxy_hop_set_supports_udp_listen";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v17 = "nw_proxy_hop_set_supports_udp_listen";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_25:
  if (v7) {
    free(v7);
  }
LABEL_8:
}

void nw_proxy_hop_set_supports_resumption(void *a1, int a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  size_t v4 = v3;
  if (v3)
  {
    if (a2) {
      char v5 = 2;
    }
    else {
      char v5 = 0;
    }
    *((unsigned char *)v3 + 80) = *((unsigned char *)v3 + 80) & 0xFD | v5;
    goto LABEL_6;
  }
  unint64_t v6 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  __int16 v17 = "nw_proxy_hop_set_supports_resumption";
  unint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v17 = "nw_proxy_hop_set_supports_resumption";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null hop", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)int buf = 136446466;
          __int16 v17 = "nw_proxy_hop_set_supports_resumption";
          __int16 v18 = 2082;
          uint64_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v12)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v17 = "nw_proxy_hop_set_supports_resumption";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v17 = "nw_proxy_hop_set_supports_resumption";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_23:
  if (v7) {
    free(v7);
  }
LABEL_6:
}

void nw_proxy_hop_set_resumable_session_agent(void *a1, _OWORD *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  size_t v4 = v3;
  if (v3)
  {
    *(_OWORD *)(v3 + 8) = *a2;
    goto LABEL_3;
  }
  char v5 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  BOOL v16 = "nw_proxy_hop_set_resumable_session_agent";
  unint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v16 = "nw_proxy_hop_set_resumable_session_agent";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null hop", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v16 = "nw_proxy_hop_set_resumable_session_agent";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v16 = "nw_proxy_hop_set_resumable_session_agent";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      unint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v16 = "nw_proxy_hop_set_resumable_session_agent";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

void nw_proxy_hop_set_supports_l4s(void *a1, int a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  size_t v4 = v3;
  if (v3)
  {
    if (a2) {
      char v5 = 4;
    }
    else {
      char v5 = 0;
    }
    *((unsigned char *)v3 + 80) = *((unsigned char *)v3 + 80) & 0xFB | v5;
    goto LABEL_6;
  }
  unint64_t v6 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  __int16 v17 = "nw_proxy_hop_set_supports_l4s";
  unint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v17 = "nw_proxy_hop_set_supports_l4s";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null hop", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)int buf = 136446466;
          __int16 v17 = "nw_proxy_hop_set_supports_l4s";
          __int16 v18 = 2082;
          uint64_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v12)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v17 = "nw_proxy_hop_set_supports_l4s";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v17 = "nw_proxy_hop_set_supports_l4s";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_23:
  if (v7) {
    free(v7);
  }
LABEL_6:
}

void nw_proxy_hop_set_enable_multipath(void *a1, int a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  size_t v4 = v3;
  if (v3)
  {
    if (a2) {
      char v5 = 8;
    }
    else {
      char v5 = 0;
    }
    *((unsigned char *)v3 + 80) = *((unsigned char *)v3 + 80) & 0xF7 | v5;
    goto LABEL_6;
  }
  unint64_t v6 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  __int16 v17 = "nw_proxy_hop_set_enable_multipath";
  unint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v17 = "nw_proxy_hop_set_enable_multipath";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null hop", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)int buf = 136446466;
          __int16 v17 = "nw_proxy_hop_set_enable_multipath";
          __int16 v18 = 2082;
          uint64_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v12)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v17 = "nw_proxy_hop_set_enable_multipath";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v17 = "nw_proxy_hop_set_enable_multipath";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_23:
  if (v7) {
    free(v7);
  }
LABEL_6:
}

NWConcrete_nw_proxy_hop *nw_proxy_hop_create_oblivious_http(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    uint64_t v19 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v40 = "nw_proxy_hop_create_oblivious_http";
    uint64_t v20 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (!__nwlog_fault(v20, &type, &v37)) {
      goto LABEL_75;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v21 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v40 = "nw_proxy_hop_create_oblivious_http";
        _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s called with null oblivious_config", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (!v37)
    {
      int v21 = __nwlog_obj();
      os_log_type_t v34 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v40 = "nw_proxy_hop_create_oblivious_http";
        _os_log_impl(&dword_1830D4000, v21, v34, "%{public}s called with null oblivious_config, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_74;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int v21 = __nwlog_obj();
    os_log_type_t v28 = type;
    BOOL v29 = os_log_type_enabled(v21, type);
    if (!backtrace_string)
    {
      if (v29)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v40 = "nw_proxy_hop_create_oblivious_http";
        _os_log_impl(&dword_1830D4000, v21, v28, "%{public}s called with null oblivious_config, no backtrace", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (v29)
    {
      *(_DWORD *)int buf = 136446466;
      BOOL v40 = "nw_proxy_hop_create_oblivious_http";
      __int16 v41 = 2082;
      BOOL v42 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v21, v28, "%{public}s called with null oblivious_config, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_56:

    free(backtrace_string);
    goto LABEL_75;
  }
  if (!a2)
  {
    __int16 v23 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v40 = "nw_proxy_hop_create_oblivious_http";
    uint64_t v20 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (!__nwlog_fault(v20, &type, &v37)) {
      goto LABEL_75;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v21 = __nwlog_obj();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v40 = "nw_proxy_hop_create_oblivious_http";
        _os_log_impl(&dword_1830D4000, v21, v24, "%{public}s called with null oblivious_config_length", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (!v37)
    {
      int v21 = __nwlog_obj();
      os_log_type_t v35 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v40 = "nw_proxy_hop_create_oblivious_http";
        _os_log_impl(&dword_1830D4000, v21, v35, "%{public}s called with null oblivious_config_length, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_74;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int v21 = __nwlog_obj();
    os_log_type_t v30 = type;
    BOOL v31 = os_log_type_enabled(v21, type);
    if (!backtrace_string)
    {
      if (v31)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v40 = "nw_proxy_hop_create_oblivious_http";
        _os_log_impl(&dword_1830D4000, v21, v30, "%{public}s called with null oblivious_config_length, no backtrace", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (v31)
    {
      *(_DWORD *)int buf = 136446466;
      BOOL v40 = "nw_proxy_hop_create_oblivious_http";
      __int16 v41 = 2082;
      BOOL v42 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v21, v30, "%{public}s called with null oblivious_config_length, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_56;
  }
  if (a3)
  {
    unint64_t v6 = objc_alloc_init(NWConcrete_nw_proxy_hop);
    if (v6)
    {
      options = nw_oblivious_http_create_options(a1, a2, a3);
      os_log_type_t v8 = v6->options;
      v6->options = (OS_nw_protocol_options *)options;

      os_log_type_t v9 = v6;
LABEL_25:

      return v6;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v10 = (id)gLogObj;
    *(_DWORD *)int buf = 136446210;
    BOOL v40 = "nw_proxy_hop_create_oblivious_http";
    os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (__nwlog_fault(v11, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v12 = (id)gLogObj;
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v40 = "nw_proxy_hop_create_oblivious_http";
          _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s [nw_proxy_hop init] failed", buf, 0xCu);
        }
      }
      else if (v37)
      {
        char v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v12 = (id)gLogObj;
        os_log_type_t v15 = type;
        BOOL v16 = os_log_type_enabled(v12, type);
        if (v14)
        {
          if (v16)
          {
            *(_DWORD *)int buf = 136446466;
            BOOL v40 = "nw_proxy_hop_create_oblivious_http";
            __int16 v41 = 2082;
            BOOL v42 = v14;
            _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s [nw_proxy_hop init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v14);
          if (!v11) {
            goto LABEL_25;
          }
          goto LABEL_24;
        }
        if (v16)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v40 = "nw_proxy_hop_create_oblivious_http";
          _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s [nw_proxy_hop init] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v12 = (id)gLogObj;
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v40 = "nw_proxy_hop_create_oblivious_http";
          _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s [nw_proxy_hop init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    if (!v11) {
      goto LABEL_25;
    }
LABEL_24:
    free(v11);
    goto LABEL_25;
  }
  uint64_t v25 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  BOOL v40 = "nw_proxy_hop_create_oblivious_http";
  uint64_t v20 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v37 = 0;
  if (__nwlog_fault(v20, &type, &v37))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v21 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v40 = "nw_proxy_hop_create_oblivious_http";
        _os_log_impl(&dword_1830D4000, v21, v26, "%{public}s called with null request_path", buf, 0xCu);
      }
LABEL_74:

      goto LABEL_75;
    }
    if (!v37)
    {
      int v21 = __nwlog_obj();
      os_log_type_t v36 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v40 = "nw_proxy_hop_create_oblivious_http";
        _os_log_impl(&dword_1830D4000, v21, v36, "%{public}s called with null request_path, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_74;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int v21 = __nwlog_obj();
    os_log_type_t v32 = type;
    BOOL v33 = os_log_type_enabled(v21, type);
    if (!backtrace_string)
    {
      if (v33)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v40 = "nw_proxy_hop_create_oblivious_http";
        _os_log_impl(&dword_1830D4000, v21, v32, "%{public}s called with null request_path, no backtrace", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (v33)
    {
      *(_DWORD *)int buf = 136446466;
      BOOL v40 = "nw_proxy_hop_create_oblivious_http";
      __int16 v41 = 2082;
      BOOL v42 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v21, v32, "%{public}s called with null request_path, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_56;
  }
LABEL_75:
  if (v20) {
    free(v20);
  }
  return 0;
}

void sub_183B98E2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_proxy_hop *nw_proxy_hop_create_oblivious_http_with_context(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    int v21 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v42 = "nw_proxy_hop_create_oblivious_http_with_context";
    os_log_type_t v22 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (!__nwlog_fault(v22, &type, &v39)) {
      goto LABEL_75;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v23 = __nwlog_obj();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v42 = "nw_proxy_hop_create_oblivious_http_with_context";
        _os_log_impl(&dword_1830D4000, v23, v24, "%{public}s called with null oblivious_config", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (!v39)
    {
      __int16 v23 = __nwlog_obj();
      os_log_type_t v36 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v42 = "nw_proxy_hop_create_oblivious_http_with_context";
        _os_log_impl(&dword_1830D4000, v23, v36, "%{public}s called with null oblivious_config, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_74;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v23 = __nwlog_obj();
    os_log_type_t v30 = type;
    BOOL v31 = os_log_type_enabled(v23, type);
    if (!backtrace_string)
    {
      if (v31)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v42 = "nw_proxy_hop_create_oblivious_http_with_context";
        _os_log_impl(&dword_1830D4000, v23, v30, "%{public}s called with null oblivious_config, no backtrace", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (v31)
    {
      *(_DWORD *)int buf = 136446466;
      BOOL v42 = "nw_proxy_hop_create_oblivious_http_with_context";
      __int16 v43 = 2082;
      BOOL v44 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v23, v30, "%{public}s called with null oblivious_config, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_56:

    free(backtrace_string);
    goto LABEL_75;
  }
  if (!a2)
  {
    uint64_t v25 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v42 = "nw_proxy_hop_create_oblivious_http_with_context";
    os_log_type_t v22 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (!__nwlog_fault(v22, &type, &v39)) {
      goto LABEL_75;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v23 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v42 = "nw_proxy_hop_create_oblivious_http_with_context";
        _os_log_impl(&dword_1830D4000, v23, v26, "%{public}s called with null oblivious_config_length", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (!v39)
    {
      __int16 v23 = __nwlog_obj();
      os_log_type_t v37 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v42 = "nw_proxy_hop_create_oblivious_http_with_context";
        _os_log_impl(&dword_1830D4000, v23, v37, "%{public}s called with null oblivious_config_length, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_74;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v23 = __nwlog_obj();
    os_log_type_t v32 = type;
    BOOL v33 = os_log_type_enabled(v23, type);
    if (!backtrace_string)
    {
      if (v33)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v42 = "nw_proxy_hop_create_oblivious_http_with_context";
        _os_log_impl(&dword_1830D4000, v23, v32, "%{public}s called with null oblivious_config_length, no backtrace", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (v33)
    {
      *(_DWORD *)int buf = 136446466;
      BOOL v42 = "nw_proxy_hop_create_oblivious_http_with_context";
      __int16 v43 = 2082;
      BOOL v44 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v23, v32, "%{public}s called with null oblivious_config_length, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_56;
  }
  if (a3)
  {
    os_log_type_t v8 = objc_alloc_init(NWConcrete_nw_proxy_hop);
    if (v8)
    {
      options_with_context = nw_oblivious_http_create_options_with_context(a1, a2, a3, a4);
      options = v8->options;
      v8->options = (OS_nw_protocol_options *)options_with_context;

      os_log_type_t v11 = v8;
LABEL_25:

      return v8;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v12 = (id)gLogObj;
    *(_DWORD *)int buf = 136446210;
    BOOL v42 = "nw_proxy_hop_create_oblivious_http_with_context";
    os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (__nwlog_fault(v13, &type, &v39))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v14 = (id)gLogObj;
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v42 = "nw_proxy_hop_create_oblivious_http_with_context";
          _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s [nw_proxy_hop init] failed", buf, 0xCu);
        }
      }
      else if (v39)
      {
        BOOL v16 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v14 = (id)gLogObj;
        os_log_type_t v17 = type;
        BOOL v18 = os_log_type_enabled(v14, type);
        if (v16)
        {
          if (v18)
          {
            *(_DWORD *)int buf = 136446466;
            BOOL v42 = "nw_proxy_hop_create_oblivious_http_with_context";
            __int16 v43 = 2082;
            BOOL v44 = v16;
            _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s [nw_proxy_hop init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v16);
          if (!v13) {
            goto LABEL_25;
          }
          goto LABEL_24;
        }
        if (v18)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v42 = "nw_proxy_hop_create_oblivious_http_with_context";
          _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s [nw_proxy_hop init] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v14 = (id)gLogObj;
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v42 = "nw_proxy_hop_create_oblivious_http_with_context";
          _os_log_impl(&dword_1830D4000, v14, v19, "%{public}s [nw_proxy_hop init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    if (!v13) {
      goto LABEL_25;
    }
LABEL_24:
    free(v13);
    goto LABEL_25;
  }
  char v27 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  BOOL v42 = "nw_proxy_hop_create_oblivious_http_with_context";
  os_log_type_t v22 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v39 = 0;
  if (__nwlog_fault(v22, &type, &v39))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v23 = __nwlog_obj();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v42 = "nw_proxy_hop_create_oblivious_http_with_context";
        _os_log_impl(&dword_1830D4000, v23, v28, "%{public}s called with null request_path", buf, 0xCu);
      }
LABEL_74:

      goto LABEL_75;
    }
    if (!v39)
    {
      __int16 v23 = __nwlog_obj();
      os_log_type_t v38 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v42 = "nw_proxy_hop_create_oblivious_http_with_context";
        _os_log_impl(&dword_1830D4000, v23, v38, "%{public}s called with null request_path, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_74;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v23 = __nwlog_obj();
    os_log_type_t v34 = type;
    BOOL v35 = os_log_type_enabled(v23, type);
    if (!backtrace_string)
    {
      if (v35)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v42 = "nw_proxy_hop_create_oblivious_http_with_context";
        _os_log_impl(&dword_1830D4000, v23, v34, "%{public}s called with null request_path, no backtrace", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (v35)
    {
      *(_DWORD *)int buf = 136446466;
      BOOL v42 = "nw_proxy_hop_create_oblivious_http_with_context";
      __int16 v43 = 2082;
      BOOL v44 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v23, v34, "%{public}s called with null request_path, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_56;
  }
LABEL_75:
  if (v22) {
    free(v22);
  }
  return 0;
}

void sub_183B99780(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_proxy_hop_set_enable_chunked_oblivious_http(void *a1, char a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  size_t v4 = v3;
  if (!v3)
  {
    char v5 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v22 = "nw_proxy_hop_set_enable_chunked_oblivious_http";
    unint64_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19)) {
      goto LABEL_38;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v22 = "nw_proxy_hop_set_enable_chunked_oblivious_http";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null hop", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v22 = "nw_proxy_hop_set_enable_chunked_oblivious_http";
          __int16 v23 = 2082;
          os_log_type_t v24 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6) {
          goto LABEL_4;
        }
LABEL_39:
        free(v6);
        goto LABEL_4;
      }
      if (v13)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v22 = "nw_proxy_hop_set_enable_chunked_oblivious_http";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      unint64_t v7 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v22 = "nw_proxy_hop_set_enable_chunked_oblivious_http";
        _os_log_impl(&dword_1830D4000, v7, v17, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (nw_protocol_options_is_oblivious_http(v3[5]))
  {
    nw_oblivious_http_set_use_chunks(v4[5], a2);
    goto LABEL_4;
  }
  os_log_type_t v9 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v22 = "nw_proxy_hop_set_enable_chunked_oblivious_http";
  unint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19)) {
    goto LABEL_38;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    unint64_t v7 = __nwlog_obj();
    os_log_type_t v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v22 = "nw_proxy_hop_set_enable_chunked_oblivious_http";
      _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_options_is_oblivious_http(hop->options)", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v19)
  {
    unint64_t v7 = __nwlog_obj();
    os_log_type_t v18 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v22 = "nw_proxy_hop_set_enable_chunked_oblivious_http";
      _os_log_impl(&dword_1830D4000, v7, v18, "%{public}s called with null nw_protocol_options_is_oblivious_http(hop->options), backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  char v14 = (char *)__nw_create_backtrace_string();
  unint64_t v7 = __nwlog_obj();
  os_log_type_t v15 = type;
  BOOL v16 = os_log_type_enabled(v7, type);
  if (!v14)
  {
    if (v16)
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v22 = "nw_proxy_hop_set_enable_chunked_oblivious_http";
      _os_log_impl(&dword_1830D4000, v7, v15, "%{public}s called with null nw_protocol_options_is_oblivious_http(hop->options), no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v16)
  {
    *(_DWORD *)int buf = 136446466;
    os_log_type_t v22 = "nw_proxy_hop_set_enable_chunked_oblivious_http";
    __int16 v23 = 2082;
    os_log_type_t v24 = v14;
    _os_log_impl(&dword_1830D4000, v7, v15, "%{public}s called with null nw_protocol_options_is_oblivious_http(hop->options), dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v6) {
    goto LABEL_39;
  }
LABEL_4:
}

void sub_183B99C4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_proxy_hop_set_oblivious_http_context_id(void *a1, uint64_t a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  size_t v4 = v3;
  if (!v3)
  {
    char v5 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v22 = "nw_proxy_hop_set_oblivious_http_context_id";
    unint64_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19)) {
      goto LABEL_38;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v22 = "nw_proxy_hop_set_oblivious_http_context_id";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null hop", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v22 = "nw_proxy_hop_set_oblivious_http_context_id";
          __int16 v23 = 2082;
          os_log_type_t v24 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6) {
          goto LABEL_4;
        }
LABEL_39:
        free(v6);
        goto LABEL_4;
      }
      if (v13)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v22 = "nw_proxy_hop_set_oblivious_http_context_id";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      unint64_t v7 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v22 = "nw_proxy_hop_set_oblivious_http_context_id";
        _os_log_impl(&dword_1830D4000, v7, v17, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (nw_protocol_options_is_oblivious_http(v3[5]))
  {
    nw_oblivious_http_set_context_id(v4[5], a2);
    goto LABEL_4;
  }
  os_log_type_t v9 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v22 = "nw_proxy_hop_set_oblivious_http_context_id";
  unint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19)) {
    goto LABEL_38;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    unint64_t v7 = __nwlog_obj();
    os_log_type_t v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v22 = "nw_proxy_hop_set_oblivious_http_context_id";
      _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_options_is_oblivious_http(hop->options)", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v19)
  {
    unint64_t v7 = __nwlog_obj();
    os_log_type_t v18 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v22 = "nw_proxy_hop_set_oblivious_http_context_id";
      _os_log_impl(&dword_1830D4000, v7, v18, "%{public}s called with null nw_protocol_options_is_oblivious_http(hop->options), backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  char v14 = (char *)__nw_create_backtrace_string();
  unint64_t v7 = __nwlog_obj();
  os_log_type_t v15 = type;
  BOOL v16 = os_log_type_enabled(v7, type);
  if (!v14)
  {
    if (v16)
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v22 = "nw_proxy_hop_set_oblivious_http_context_id";
      _os_log_impl(&dword_1830D4000, v7, v15, "%{public}s called with null nw_protocol_options_is_oblivious_http(hop->options), no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v16)
  {
    *(_DWORD *)int buf = 136446466;
    os_log_type_t v22 = "nw_proxy_hop_set_oblivious_http_context_id";
    __int16 v23 = 2082;
    os_log_type_t v24 = v14;
    _os_log_impl(&dword_1830D4000, v7, v15, "%{public}s called with null nw_protocol_options_is_oblivious_http(hop->options), dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v6) {
    goto LABEL_39;
  }
LABEL_4:
}

void sub_183B9A114(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_proxy_hop_add_next_hop_host(void *a1, void *a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  char v5 = v4;
  if (!v3)
  {
    unint64_t v7 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v29 = "nw_proxy_hop_add_next_hop_host";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v29 = "nw_proxy_hop_add_next_hop_host";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null hop", buf, 0xCu);
      }
    }
    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v29 = "nw_proxy_hop_add_next_hop_host";
          __int16 v30 = 2082;
          BOOL v31 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v8) {
          goto LABEL_5;
        }
LABEL_56:
        free(v8);
        goto LABEL_5;
      }
      if (v17)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v29 = "nw_proxy_hop_add_next_hop_host";
        _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v29 = "nw_proxy_hop_add_next_hop_host";
        _os_log_impl(&dword_1830D4000, v9, v23, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_54:

    goto LABEL_55;
  }
  if (!v4)
  {
    os_log_type_t v11 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v29 = "nw_proxy_hop_add_next_hop_host";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v29 = "nw_proxy_hop_add_next_hop_host";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null next_hop_host", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v26)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v29 = "nw_proxy_hop_add_next_hop_host";
        _os_log_impl(&dword_1830D4000, v9, v24, "%{public}s called with null next_hop_host, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    os_log_type_t v18 = (char *)__nw_create_backtrace_string();
    os_log_type_t v9 = __nwlog_obj();
    os_log_type_t v19 = type;
    BOOL v20 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v20)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v29 = "nw_proxy_hop_add_next_hop_host";
        _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s called with null next_hop_host, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v20)
    {
      *(_DWORD *)int buf = 136446466;
      BOOL v29 = "nw_proxy_hop_add_next_hop_host";
      __int16 v30 = 2082;
      BOOL v31 = v18;
      _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s called with null next_hop_host, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_35;
  }
  unint64_t v6 = (void *)v3[5];
  if (!v6)
  {
    BOOL v13 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v29 = "nw_proxy_hop_add_next_hop_host";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v29 = "nw_proxy_hop_add_next_hop_host";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null hop->options", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v26)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v29 = "nw_proxy_hop_add_next_hop_host";
        _os_log_impl(&dword_1830D4000, v9, v25, "%{public}s called with null hop->options, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    os_log_type_t v18 = (char *)__nw_create_backtrace_string();
    os_log_type_t v9 = __nwlog_obj();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v22)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v29 = "nw_proxy_hop_add_next_hop_host";
        _os_log_impl(&dword_1830D4000, v9, v21, "%{public}s called with null hop->options, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v22)
    {
      *(_DWORD *)int buf = 136446466;
      BOOL v29 = "nw_proxy_hop_add_next_hop_host";
      __int16 v30 = 2082;
      BOOL v31 = v18;
      _os_log_impl(&dword_1830D4000, v9, v21, "%{public}s called with null hop->options, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_35:

    free(v18);
    if (!v8) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }
  nw_protocol_options_add_proxy_next_hop(v6, v5);
LABEL_5:
}

void nw_proxy_hop_add_extra_header(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  char v5 = a1;
  unint64_t v6 = v5;
  if (!v5)
  {
    unint64_t v7 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v34 = "nw_proxy_hop_add_extra_header";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (!__nwlog_fault(v8, &type, &v31)) {
      goto LABEL_72;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_proxy_hop_add_extra_header";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null hop", buf, 0xCu);
      }
    }
    else if (v31)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v34 = "nw_proxy_hop_add_extra_header";
          __int16 v35 = 2082;
          os_log_type_t v36 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v18, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_72:
        if (!v8) {
          goto LABEL_6;
        }
LABEL_73:
        free(v8);
        goto LABEL_6;
      }
      if (v19)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_proxy_hop_add_extra_header";
        _os_log_impl(&dword_1830D4000, v9, v18, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_proxy_hop_add_extra_header";
        _os_log_impl(&dword_1830D4000, v9, v27, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_71:

    goto LABEL_72;
  }
  if (!nw_protocol_options_is_masque(v5[5]))
  {
    os_log_type_t v11 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v34 = "nw_proxy_hop_add_extra_header";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (!__nwlog_fault(v8, &type, &v31)) {
      goto LABEL_72;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_proxy_hop_add_extra_header";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null nw_protocol_options_is_masque(hop->options)", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (!v31)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_proxy_hop_add_extra_header";
        _os_log_impl(&dword_1830D4000, v9, v28, "%{public}s called with null nw_protocol_options_is_masque(hop->options), backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_71;
    }
    BOOL v20 = (char *)__nw_create_backtrace_string();
    os_log_type_t v9 = __nwlog_obj();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v9, type);
    if (!v20)
    {
      if (v22)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_proxy_hop_add_extra_header";
        _os_log_impl(&dword_1830D4000, v9, v21, "%{public}s called with null nw_protocol_options_is_masque(hop->options), no backtrace", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (v22)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v34 = "nw_proxy_hop_add_extra_header";
      __int16 v35 = 2082;
      os_log_type_t v36 = v20;
      _os_log_impl(&dword_1830D4000, v9, v21, "%{public}s called with null nw_protocol_options_is_masque(hop->options), dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_46;
  }
  if (!a2)
  {
    BOOL v13 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v34 = "nw_proxy_hop_add_extra_header";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (!__nwlog_fault(v8, &type, &v31)) {
      goto LABEL_72;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_proxy_hop_add_extra_header";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null header", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (!v31)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_proxy_hop_add_extra_header";
        _os_log_impl(&dword_1830D4000, v9, v29, "%{public}s called with null header, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_71;
    }
    BOOL v20 = (char *)__nw_create_backtrace_string();
    os_log_type_t v9 = __nwlog_obj();
    os_log_type_t v23 = type;
    BOOL v24 = os_log_type_enabled(v9, type);
    if (!v20)
    {
      if (v24)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_proxy_hop_add_extra_header";
        _os_log_impl(&dword_1830D4000, v9, v23, "%{public}s called with null header, no backtrace", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (v24)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v34 = "nw_proxy_hop_add_extra_header";
      __int16 v35 = 2082;
      os_log_type_t v36 = v20;
      _os_log_impl(&dword_1830D4000, v9, v23, "%{public}s called with null header, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_46;
  }
  if (!a3)
  {
    os_log_type_t v15 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v34 = "nw_proxy_hop_add_extra_header";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (!__nwlog_fault(v8, &type, &v31)) {
      goto LABEL_72;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_proxy_hop_add_extra_header";
        _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null value", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (!v31)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v30 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_proxy_hop_add_extra_header";
        _os_log_impl(&dword_1830D4000, v9, v30, "%{public}s called with null value, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_71;
    }
    BOOL v20 = (char *)__nw_create_backtrace_string();
    os_log_type_t v9 = __nwlog_obj();
    os_log_type_t v25 = type;
    BOOL v26 = os_log_type_enabled(v9, type);
    if (!v20)
    {
      if (v26)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_proxy_hop_add_extra_header";
        _os_log_impl(&dword_1830D4000, v9, v25, "%{public}s called with null value, no backtrace", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (v26)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v34 = "nw_proxy_hop_add_extra_header";
      __int16 v35 = 2082;
      os_log_type_t v36 = v20;
      _os_log_impl(&dword_1830D4000, v9, v25, "%{public}s called with null value, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_46:

    free(v20);
    if (!v8) {
      goto LABEL_6;
    }
    goto LABEL_73;
  }
  nw_masque_options_add_extra_header(v6[5], a2, a3);
LABEL_6:
}

void nw_proxy_hop_add_token_header(void *a1, uint64_t a2, const char *a3, const char *a4, const unsigned __int8 *a5)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  os_log_type_t v9 = a1;
  os_log_type_t v10 = v9;
  if (!v9)
  {
    os_log_type_t v12 = __nwlog_obj();
    *(_DWORD *)uuid_string_t out = 136446210;
    *(void *)&out[4] = "nw_proxy_hop_add_token_header";
    BOOL v13 = (const char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v54) = 0;
    if (!__nwlog_fault(v13, type, &v54)) {
      goto LABEL_125;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v15 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)uuid_string_t out = 136446210;
        *(void *)&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s called with null hop", (uint8_t *)out, 0xCu);
      }
    }
    else if ((_BYTE)v54)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v30 = type[0];
      BOOL v31 = os_log_type_enabled(v14, type[0]);
      if (backtrace_string)
      {
        if (v31)
        {
          *(_DWORD *)uuid_string_t out = 136446466;
          *(void *)&out[4] = "nw_proxy_hop_add_token_header";
          *(_WORD *)&out[12] = 2082;
          *(void *)&out[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v14, v30, "%{public}s called with null hop, dumping backtrace:%{public}s", (uint8_t *)out, 0x16u);
        }

        free(backtrace_string);
LABEL_125:
        if (!v13) {
          goto LABEL_10;
        }
        goto LABEL_126;
      }
      if (v31)
      {
        *(_DWORD *)uuid_string_t out = 136446210;
        *(void *)&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_1830D4000, v14, v30, "%{public}s called with null hop, no backtrace", (uint8_t *)out, 0xCu);
      }
    }
    else
    {
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v45 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)uuid_string_t out = 136446210;
        *(void *)&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_1830D4000, v14, v45, "%{public}s called with null hop, backtrace limit exceeded", (uint8_t *)out, 0xCu);
      }
    }
LABEL_121:

    goto LABEL_125;
  }
  if (!nw_protocol_options_is_masque(v9[5]))
  {
    os_log_type_t v16 = __nwlog_obj();
    *(_DWORD *)uuid_string_t out = 136446210;
    *(void *)&out[4] = "nw_proxy_hop_add_token_header";
    BOOL v13 = (const char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v54) = 0;
    if (!__nwlog_fault(v13, type, &v54)) {
      goto LABEL_125;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v17 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)uuid_string_t out = 136446210;
        *(void *)&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null nw_protocol_options_is_masque(hop->options)", (uint8_t *)out, 0xCu);
      }
      goto LABEL_121;
    }
    if (!(_BYTE)v54)
    {
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v46 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)uuid_string_t out = 136446210;
        *(void *)&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_1830D4000, v14, v46, "%{public}s called with null nw_protocol_options_is_masque(hop->options), backtrace limit exceeded", (uint8_t *)out, 0xCu);
      }
      goto LABEL_121;
    }
    uint64_t v32 = (char *)__nw_create_backtrace_string();
    os_log_type_t v14 = __nwlog_obj();
    os_log_type_t v33 = type[0];
    BOOL v34 = os_log_type_enabled(v14, type[0]);
    if (!v32)
    {
      if (v34)
      {
        *(_DWORD *)uuid_string_t out = 136446210;
        *(void *)&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_1830D4000, v14, v33, "%{public}s called with null nw_protocol_options_is_masque(hop->options), no backtrace", (uint8_t *)out, 0xCu);
      }
      goto LABEL_121;
    }
    if (v34)
    {
      *(_DWORD *)uuid_string_t out = 136446466;
      *(void *)&out[4] = "nw_proxy_hop_add_token_header";
      *(_WORD *)&out[12] = 2082;
      *(void *)&out[14] = v32;
      _os_log_impl(&dword_1830D4000, v14, v33, "%{public}s called with null nw_protocol_options_is_masque(hop->options), dumping backtrace:%{public}s", (uint8_t *)out, 0x16u);
    }
    goto LABEL_75;
  }
  if (!a2)
  {
    os_log_type_t v18 = __nwlog_obj();
    *(_DWORD *)uuid_string_t out = 136446210;
    *(void *)&out[4] = "nw_proxy_hop_add_token_header";
    BOOL v13 = (const char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v54) = 0;
    if (!__nwlog_fault(v13, type, &v54)) {
      goto LABEL_125;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v19 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)uuid_string_t out = 136446210;
        *(void *)&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_1830D4000, v14, v19, "%{public}s called with null header", (uint8_t *)out, 0xCu);
      }
      goto LABEL_121;
    }
    if (!(_BYTE)v54)
    {
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v47 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)uuid_string_t out = 136446210;
        *(void *)&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_1830D4000, v14, v47, "%{public}s called with null header, backtrace limit exceeded", (uint8_t *)out, 0xCu);
      }
      goto LABEL_121;
    }
    uint64_t v32 = (char *)__nw_create_backtrace_string();
    os_log_type_t v14 = __nwlog_obj();
    os_log_type_t v35 = type[0];
    BOOL v36 = os_log_type_enabled(v14, type[0]);
    if (!v32)
    {
      if (v36)
      {
        *(_DWORD *)uuid_string_t out = 136446210;
        *(void *)&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_1830D4000, v14, v35, "%{public}s called with null header, no backtrace", (uint8_t *)out, 0xCu);
      }
      goto LABEL_121;
    }
    if (v36)
    {
      *(_DWORD *)uuid_string_t out = 136446466;
      *(void *)&out[4] = "nw_proxy_hop_add_token_header";
      *(_WORD *)&out[12] = 2082;
      *(void *)&out[14] = v32;
      _os_log_impl(&dword_1830D4000, v14, v35, "%{public}s called with null header, dumping backtrace:%{public}s", (uint8_t *)out, 0x16u);
    }
    goto LABEL_75;
  }
  if (!a3)
  {
    BOOL v20 = __nwlog_obj();
    *(_DWORD *)uuid_string_t out = 136446210;
    *(void *)&out[4] = "nw_proxy_hop_add_token_header";
    BOOL v13 = (const char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v54) = 0;
    if (!__nwlog_fault(v13, type, &v54)) {
      goto LABEL_125;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v21 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)uuid_string_t out = 136446210;
        *(void *)&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_1830D4000, v14, v21, "%{public}s called with null value_prefix", (uint8_t *)out, 0xCu);
      }
      goto LABEL_121;
    }
    if (!(_BYTE)v54)
    {
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v48 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)uuid_string_t out = 136446210;
        *(void *)&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_1830D4000, v14, v48, "%{public}s called with null value_prefix, backtrace limit exceeded", (uint8_t *)out, 0xCu);
      }
      goto LABEL_121;
    }
    uint64_t v32 = (char *)__nw_create_backtrace_string();
    os_log_type_t v14 = __nwlog_obj();
    os_log_type_t v37 = type[0];
    BOOL v38 = os_log_type_enabled(v14, type[0]);
    if (!v32)
    {
      if (v38)
      {
        *(_DWORD *)uuid_string_t out = 136446210;
        *(void *)&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_1830D4000, v14, v37, "%{public}s called with null value_prefix, no backtrace", (uint8_t *)out, 0xCu);
      }
      goto LABEL_121;
    }
    if (v38)
    {
      *(_DWORD *)uuid_string_t out = 136446466;
      *(void *)&out[4] = "nw_proxy_hop_add_token_header";
      *(_WORD *)&out[12] = 2082;
      *(void *)&out[14] = v32;
      _os_log_impl(&dword_1830D4000, v14, v37, "%{public}s called with null value_prefix, dumping backtrace:%{public}s", (uint8_t *)out, 0x16u);
    }
    goto LABEL_75;
  }
  if (!a4)
  {
    BOOL v22 = __nwlog_obj();
    *(_DWORD *)uuid_string_t out = 136446210;
    *(void *)&out[4] = "nw_proxy_hop_add_token_header";
    BOOL v13 = (const char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v54) = 0;
    if (!__nwlog_fault(v13, type, &v54)) {
      goto LABEL_125;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v23 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)uuid_string_t out = 136446210;
        *(void *)&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_1830D4000, v14, v23, "%{public}s called with null value_suffix", (uint8_t *)out, 0xCu);
      }
      goto LABEL_121;
    }
    if (!(_BYTE)v54)
    {
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v49 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)uuid_string_t out = 136446210;
        *(void *)&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_1830D4000, v14, v49, "%{public}s called with null value_suffix, backtrace limit exceeded", (uint8_t *)out, 0xCu);
      }
      goto LABEL_121;
    }
    uint64_t v32 = (char *)__nw_create_backtrace_string();
    os_log_type_t v14 = __nwlog_obj();
    os_log_type_t v39 = type[0];
    BOOL v40 = os_log_type_enabled(v14, type[0]);
    if (!v32)
    {
      if (v40)
      {
        *(_DWORD *)uuid_string_t out = 136446210;
        *(void *)&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_1830D4000, v14, v39, "%{public}s called with null value_suffix, no backtrace", (uint8_t *)out, 0xCu);
      }
      goto LABEL_121;
    }
    if (v40)
    {
      *(_DWORD *)uuid_string_t out = 136446466;
      *(void *)&out[4] = "nw_proxy_hop_add_token_header";
      *(_WORD *)&out[12] = 2082;
      *(void *)&out[14] = v32;
      _os_log_impl(&dword_1830D4000, v14, v39, "%{public}s called with null value_suffix, dumping backtrace:%{public}s", (uint8_t *)out, 0x16u);
    }
    goto LABEL_75;
  }
  if (!a5)
  {
    BOOL v24 = __nwlog_obj();
    *(_DWORD *)uuid_string_t out = 136446210;
    *(void *)&out[4] = "nw_proxy_hop_add_token_header";
    BOOL v13 = (const char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v54) = 0;
    if (!__nwlog_fault(v13, type, &v54)) {
      goto LABEL_125;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v25 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)uuid_string_t out = 136446210;
        *(void *)&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_1830D4000, v14, v25, "%{public}s called with null token_agent", (uint8_t *)out, 0xCu);
      }
      goto LABEL_121;
    }
    if (!(_BYTE)v54)
    {
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v50 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)uuid_string_t out = 136446210;
        *(void *)&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_1830D4000, v14, v50, "%{public}s called with null token_agent, backtrace limit exceeded", (uint8_t *)out, 0xCu);
      }
      goto LABEL_121;
    }
    uint64_t v32 = (char *)__nw_create_backtrace_string();
    os_log_type_t v14 = __nwlog_obj();
    os_log_type_t v41 = type[0];
    BOOL v42 = os_log_type_enabled(v14, type[0]);
    if (!v32)
    {
      if (v42)
      {
        *(_DWORD *)uuid_string_t out = 136446210;
        *(void *)&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_1830D4000, v14, v41, "%{public}s called with null token_agent, no backtrace", (uint8_t *)out, 0xCu);
      }
      goto LABEL_121;
    }
    if (v42)
    {
      *(_DWORD *)uuid_string_t out = 136446466;
      *(void *)&out[4] = "nw_proxy_hop_add_token_header";
      *(_WORD *)&out[12] = 2082;
      *(void *)&out[14] = v32;
      _os_log_impl(&dword_1830D4000, v14, v41, "%{public}s called with null token_agent, dumping backtrace:%{public}s", (uint8_t *)out, 0x16u);
    }
LABEL_75:

    goto LABEL_81;
  }
  memset(out, 0, sizeof(out));
  uuid_unparse(a5, out);
  __int16 v54 = 0;
  asprintf(&v54, "%s%s%s%s%s", a3, "<token=", out, ">", a4);
  if (!v54)
  {
    BOOL v26 = __nwlog_obj();
    *(_DWORD *)os_log_type_t type = 136446210;
    __int16 v56 = "nw_proxy_hop_add_token_header";
    BOOL v13 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t v53 = OS_LOG_TYPE_ERROR;
    char v52 = 0;
    if (!__nwlog_fault(v13, &v53, &v52)) {
      goto LABEL_125;
    }
    if (v53 == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v27 = __nwlog_obj();
      os_log_type_t v28 = v53;
      if (os_log_type_enabled(v27, v53))
      {
        *(_DWORD *)os_log_type_t type = 136446210;
        __int16 v56 = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_1830D4000, v27, v28, "%{public}s called with null value", (uint8_t *)type, 0xCu);
      }
LABEL_124:

      goto LABEL_125;
    }
    if (!v52)
    {
      os_log_type_t v27 = __nwlog_obj();
      os_log_type_t v51 = v53;
      if (os_log_type_enabled(v27, v53))
      {
        *(_DWORD *)os_log_type_t type = 136446210;
        __int16 v56 = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_1830D4000, v27, v51, "%{public}s called with null value, backtrace limit exceeded", (uint8_t *)type, 0xCu);
      }
      goto LABEL_124;
    }
    uint64_t v32 = (char *)__nw_create_backtrace_string();
    os_log_type_t v27 = __nwlog_obj();
    os_log_type_t v43 = v53;
    BOOL v44 = os_log_type_enabled(v27, v53);
    if (!v32)
    {
      if (v44)
      {
        *(_DWORD *)os_log_type_t type = 136446210;
        __int16 v56 = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_1830D4000, v27, v43, "%{public}s called with null value, no backtrace", (uint8_t *)type, 0xCu);
      }
      goto LABEL_124;
    }
    if (v44)
    {
      *(_DWORD *)os_log_type_t type = 136446466;
      __int16 v56 = "nw_proxy_hop_add_token_header";
      __int16 v57 = 2082;
      uint64_t v58 = v32;
      _os_log_impl(&dword_1830D4000, v27, v43, "%{public}s called with null value, dumping backtrace:%{public}s", (uint8_t *)type, 0x16u);
    }

LABEL_81:
    free(v32);
    if (!v13) {
      goto LABEL_10;
    }
LABEL_126:
    os_log_type_t v11 = (char *)v13;
    goto LABEL_9;
  }
  nw_masque_options_add_extra_header(v10[5], a2, (uint64_t)v54);
  os_log_type_t v11 = v54;
  if (v54) {
LABEL_9:
  }
    free(v11);
LABEL_10:
}

void sub_183B9BFF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_proxy_hop_add_client_certificate_reference(void *a1, const void *a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    unint64_t v6 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v23 = "nw_proxy_hop_add_client_certificate_reference";
    unint64_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (!__nwlog_fault(v7, &type, &v20)) {
      goto LABEL_40;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v23 = "nw_proxy_hop_add_client_certificate_reference";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null hop", buf, 0xCu);
      }
    }
    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v23 = "nw_proxy_hop_add_client_certificate_reference";
          __int16 v24 = 2082;
          os_log_type_t v25 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_40:
        if (!v7) {
          goto LABEL_6;
        }
LABEL_41:
        free(v7);
        goto LABEL_6;
      }
      if (v14)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v23 = "nw_proxy_hop_add_client_certificate_reference";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v23 = "nw_proxy_hop_add_client_certificate_reference";
        _os_log_impl(&dword_1830D4000, v8, v18, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_39:

    goto LABEL_40;
  }
  if (a2)
  {
    Mutable = (__CFArray *)*((void *)v3 + 9);
    if (!Mutable)
    {
      Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
      v4[9] = Mutable;
    }
    CFArrayAppendValue(Mutable, a2);
    goto LABEL_6;
  }
  os_log_type_t v10 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v23 = "nw_proxy_hop_add_client_certificate_reference";
  unint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (!__nwlog_fault(v7, &type, &v20)) {
    goto LABEL_40;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v8 = __nwlog_obj();
    os_log_type_t v11 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v23 = "nw_proxy_hop_add_client_certificate_reference";
      _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null persistent_reference", buf, 0xCu);
    }
    goto LABEL_39;
  }
  if (!v20)
  {
    os_log_type_t v8 = __nwlog_obj();
    os_log_type_t v19 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v23 = "nw_proxy_hop_add_client_certificate_reference";
      _os_log_impl(&dword_1830D4000, v8, v19, "%{public}s called with null persistent_reference, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_39;
  }
  os_log_type_t v15 = (char *)__nw_create_backtrace_string();
  os_log_type_t v8 = __nwlog_obj();
  os_log_type_t v16 = type;
  BOOL v17 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v23 = "nw_proxy_hop_add_client_certificate_reference";
      _os_log_impl(&dword_1830D4000, v8, v16, "%{public}s called with null persistent_reference, no backtrace", buf, 0xCu);
    }
    goto LABEL_39;
  }
  if (v17)
  {
    *(_DWORD *)int buf = 136446466;
    os_log_type_t v23 = "nw_proxy_hop_add_client_certificate_reference";
    __int16 v24 = 2082;
    os_log_type_t v25 = v15;
    _os_log_impl(&dword_1830D4000, v8, v16, "%{public}s called with null persistent_reference, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v15);
  if (v7) {
    goto LABEL_41;
  }
LABEL_6:
}

void sub_183B9C4E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_proxy_hop_set_use_x25519(void *a1, int a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    if (a2) {
      char v5 = 0x80;
    }
    else {
      char v5 = 0;
    }
    *((unsigned char *)v3 + 80) = v5 & 0x80 | *((unsigned char *)v3 + 80) & 0x7F;
    goto LABEL_6;
  }
  unint64_t v6 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  BOOL v17 = "nw_proxy_hop_set_use_x25519";
  unint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v17 = "nw_proxy_hop_set_use_x25519";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null hop", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v17 = "nw_proxy_hop_set_use_x25519";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v12)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v17 = "nw_proxy_hop_set_use_x25519";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v17 = "nw_proxy_hop_set_use_x25519";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_23:
  if (v7) {
    free(v7);
  }
LABEL_6:
}

void nw_proxy_hop_set_trust_certs(void *a1, int a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    if (a2) {
      char v5 = 16;
    }
    else {
      char v5 = 0;
    }
    *((unsigned char *)v3 + 80) = *((unsigned char *)v3 + 80) & 0xEF | v5;
    goto LABEL_6;
  }
  unint64_t v6 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  BOOL v17 = "nw_proxy_hop_set_trust_certs";
  unint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v17 = "nw_proxy_hop_set_trust_certs";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null hop", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v17 = "nw_proxy_hop_set_trust_certs";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v12)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v17 = "nw_proxy_hop_set_trust_certs";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v17 = "nw_proxy_hop_set_trust_certs";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_23:
  if (v7) {
    free(v7);
  }
LABEL_6:
}

void nw_proxy_hop_set_enable_demux(void *a1, char a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    *((unsigned char *)v3 + 81) = *((unsigned char *)v3 + 81) & 0xFE | a2;
    goto LABEL_3;
  }
  char v5 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v16 = "nw_proxy_hop_set_enable_demux";
  unint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_proxy_hop_set_enable_demux";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null hop", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v16 = "nw_proxy_hop_set_enable_demux";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_proxy_hop_set_enable_demux";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      unint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_proxy_hop_set_enable_demux";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

void nw_proxy_hop_supports_udp_proxying_over_http2(void *a1, int a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    if (a2) {
      char v5 = 2;
    }
    else {
      char v5 = 0;
    }
    *((unsigned char *)v3 + 81) = *((unsigned char *)v3 + 81) & 0xFD | v5;
    goto LABEL_6;
  }
  unint64_t v6 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  __int16 v17 = "nw_proxy_hop_supports_udp_proxying_over_http2";
  unint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v17 = "nw_proxy_hop_supports_udp_proxying_over_http2";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null hop", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)int buf = 136446466;
          __int16 v17 = "nw_proxy_hop_supports_udp_proxying_over_http2";
          __int16 v18 = 2082;
          uint64_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v12)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v17 = "nw_proxy_hop_supports_udp_proxying_over_http2";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v17 = "nw_proxy_hop_supports_udp_proxying_over_http2";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_23:
  if (v7) {
    free(v7);
  }
LABEL_6:
}

NWConcrete_nw_proxy_config *nw_proxy_config_create_default_privacy_proxy(void *a1)
{
  id v1 = a1;
  BOOL v2 = networkd_settings_get_BOOL((const char *)nw_setting_disable_swift_tls_privacy_proxy);
  privacy_proxy_internal = nw_proxy_config_create_privacy_proxy_internal(v1, !v2);

  return privacy_proxy_internal;
}

void sub_183B9CFE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_proxy_config *nw_proxy_config_create_privacy_proxy_internal(void *a1, int a2)
{
  uint64_t v100 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    BOOL v73 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    long long v97 = "nw_proxy_config_create_privacy_proxy_internal";
    uint64_t v74 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v94 = 0;
    if (!__nwlog_fault(v74, &type, &v94)) {
      goto LABEL_219;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v75 = __nwlog_obj();
      os_log_type_t v76 = type;
      if (os_log_type_enabled(v75, type))
      {
        *(_DWORD *)int buf = 136446210;
        long long v97 = "nw_proxy_config_create_privacy_proxy_internal";
        _os_log_impl(&dword_1830D4000, v75, v76, "%{public}s called with null array", buf, 0xCu);
      }
    }
    else if (v94)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v75 = __nwlog_obj();
      os_log_type_t v80 = type;
      BOOL v81 = os_log_type_enabled(v75, type);
      if (backtrace_string)
      {
        if (v81)
        {
          *(_DWORD *)int buf = 136446466;
          long long v97 = "nw_proxy_config_create_privacy_proxy_internal";
          __int16 v98 = 2082;
          long long v99 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v75, v80, "%{public}s called with null array, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (!v74) {
          goto LABEL_221;
        }
        goto LABEL_220;
      }
      if (v81)
      {
        *(_DWORD *)int buf = 136446210;
        long long v97 = "nw_proxy_config_create_privacy_proxy_internal";
        _os_log_impl(&dword_1830D4000, v75, v80, "%{public}s called with null array, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v75 = __nwlog_obj();
      os_log_type_t v85 = type;
      if (os_log_type_enabled(v75, type))
      {
        *(_DWORD *)int buf = 136446210;
        long long v97 = "nw_proxy_config_create_privacy_proxy_internal";
        _os_log_impl(&dword_1830D4000, v75, v85, "%{public}s called with null array, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_218;
  }
  uint64_t v6 = *((void *)v3 + 2);
  uint64_t v5 = *((void *)v3 + 3);
  uint64_t v7 = v5 - v6;
  if (v5 == v6)
  {
    size_t v77 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    long long v97 = "nw_proxy_config_create_privacy_proxy_internal";
    uint64_t v74 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v94 = 0;
    if (!__nwlog_fault(v74, &type, &v94)) {
      goto LABEL_219;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v75 = __nwlog_obj();
      os_log_type_t v78 = type;
      if (os_log_type_enabled(v75, type))
      {
        *(_DWORD *)int buf = 136446210;
        long long v97 = "nw_proxy_config_create_privacy_proxy_internal";
        _os_log_impl(&dword_1830D4000, v75, v78, "%{public}s called with null (hop_count > 0)", buf, 0xCu);
      }
    }
    else if (v94)
    {
      long long v82 = (char *)__nw_create_backtrace_string();
      BOOL v75 = __nwlog_obj();
      os_log_type_t v83 = type;
      BOOL v84 = os_log_type_enabled(v75, type);
      if (v82)
      {
        if (v84)
        {
          *(_DWORD *)int buf = 136446466;
          long long v97 = "nw_proxy_config_create_privacy_proxy_internal";
          __int16 v98 = 2082;
          long long v99 = v82;
          _os_log_impl(&dword_1830D4000, v75, v83, "%{public}s called with null (hop_count > 0), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v82);
LABEL_219:
        if (!v74)
        {
LABEL_221:
          os_log_type_t v21 = 0;
          goto LABEL_185;
        }
LABEL_220:
        free(v74);
        goto LABEL_221;
      }
      if (v84)
      {
        *(_DWORD *)int buf = 136446210;
        long long v97 = "nw_proxy_config_create_privacy_proxy_internal";
        _os_log_impl(&dword_1830D4000, v75, v83, "%{public}s called with null (hop_count > 0), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v75 = __nwlog_obj();
      os_log_type_t v86 = type;
      if (os_log_type_enabled(v75, type))
      {
        *(_DWORD *)int buf = 136446210;
        long long v97 = "nw_proxy_config_create_privacy_proxy_internal";
        _os_log_impl(&dword_1830D4000, v75, v86, "%{public}s called with null (hop_count > 0), backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_218:

    goto LABEL_219;
  }
  os_log_type_t v8 = objc_alloc_init(NWConcrete_nw_protocol_stack);
  if (v7 >> 3 == 2)
  {
    uint64_t v9 = nw_array_get_object_at_index((uint64_t)v4, 0);
    uint64_t v11 = nw_array_get_object_at_index((uint64_t)v4, 1uLL);
    size_t v93 = (NWConcrete_nw_protocol_options *)v11;
    if (nw_protocol_options_is_masque(*(void **)(v9 + 40)))
    {
      BOOL is_masque = nw_protocol_options_is_masque(*(void **)(v11 + 40));
      os_log_type_t v13 = *(void **)(v11 + 40);
      if (is_masque)
      {
        size_t v92 = nw_protocol_options_copy(v13);
        nw_protocol_options_set_proxy_endpoint(v92, *(void **)(v11 + 24), 1);
        char v14 = nw_protocol_options_copy(*(void **)(v9 + 40));
        nw_protocol_options_set_proxy_endpoint(v14, *(void **)(v9 + 24), 0);
        nw_masque_options_set_forced_protocol(v14, 2);
        nw_masque_options_set_target_endpoint(v14, *(void *)(v11 + 24));
        protocol = v14;
        if (nw_protocol_copy_http3_definition_onceToken != -1) {
          dispatch_once(&nw_protocol_copy_http3_definition_onceToken, &__block_literal_global_13_73886);
        }
        options = nw_protocol_create_options((void *)nw_protocol_copy_http3_definition_http3_definition);
        os_log_type_t v16 = options;
        if ((*(unsigned char *)(v11 + 80) & 2) != 0)
        {
          nw_http3_set_0rtt_enabled(options, 1);
          nw_http3_set_idle_timeout(v16, 30);
          nw_http3_set_keepalive_mode(v16, 2);
          uint64_t v30 = v11 + 8;
          if (!uuid_is_null((const unsigned __int8 *)&v93->definition)) {
            nw_http3_set_resumable_session_agent(v16, v30);
          }
        }
        else
        {
          nw_http3_set_idle_timeout(options, 900);
          nw_http3_set_keepalive_mode(v16, 1);
        }
        if (nw_protocol_copy_http3_definition_onceToken != -1) {
          dispatch_once(&nw_protocol_copy_http3_definition_onceToken, &__block_literal_global_13_73886);
        }
        BOOL v31 = nw_protocol_create_options((void *)nw_protocol_copy_http3_definition_http3_definition);
        long long v90 = v31;
        if ((*(unsigned char *)(v9 + 80) & 2) != 0)
        {
          nw_http3_set_0rtt_enabled(v31, 1);
          nw_http3_set_idle_timeout(v90, 30);
          nw_http3_set_keepalive_mode(v90, 2);
          if (!uuid_is_null((const unsigned __int8 *)(v9 + 8))) {
            nw_http3_set_resumable_session_agent(v90, v9 + 8);
          }
        }
        else
        {
          nw_http3_set_idle_timeout(v31, 60);
          nw_http3_set_keepalive_mode(v90, 1);
        }
        if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
          dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_15_56153);
        }
        uint64_t v32 = nw_protocol_create_options((void *)nw_protocol_copy_quic_stream_definition::quic_definition);
        size_t v89 = v32;
        id v33 = nw_quic_stream_copy_shared_connection_options(v32);
        BOOL v34 = v33;
        char v35 = v93->log_id_str[32];
        if ((v35 & 4) != 0)
        {
          nw_quic_connection_set_enable_l4s(v33, 1);
          char v35 = v93->log_id_str[32];
        }
        if ((v35 & 8) != 0) {
          nw_quic_connection_set_enable_multipath(v34, 1);
        }
        nw_quic_connection_set_idle_timeout(v34, 0);
        nw_quic_connection_set_max_datagram_frame_size(v34, 0xFFFF);
        nw_quic_connection_set_max_udp_payload_size(v34, 1472);
        nw_quic_connection_set_datagram_variant_flow_id_enabled(v34, 1);
        if (nw_masque_options_get_version(v92) == 2)
        {
          nw_quic_connection_set_datagram_quarter_stream_id(v34, 1);
          nw_quic_connection_set_datagram_context_id(v34, 1);
        }
        nw_quic_connection_set_source_connection_id_length(v34, 8);
        nw_quic_connection_set_initial_packet_size(v34, 1304);
        BOOL v36 = *(void **)v93->log_id_str;
        if (v36)
        {
          id v37 = v36;
          nw_quic_connection_set_sec_protocol_options(v34, v37);

          uint64_t v32 = v89;
        }
        if (*(void *)&v93->log_id_str[8])
        {
          if (a2)
          {
            if ((v93->log_id_str[33] & 4) == 0)
            {
              nw_quic_connection_set_use_swift_tls(v34, 1);
              if (v93->log_id_str[32] < 0) {
                nw_quic_connection_set_use_x25519(v34, 1);
              }
            }
          }
          nw_quic_connection_set_server_raw_public_keys(v34, *(void *)&v93->log_id_str[8]);
        }
        uint64_t v38 = *(void *)&v93->log_id_str[16];
        if (v38) {
          nw_quic_connection_set_client_identity_reference(v34, v38, *(void *)&v93->log_id_str[24]);
        }
        if ((v93->log_id_str[32] & 0x10) != 0) {
          nw_quic_connection_set_override_trust_certs_for_tests(v34, 1);
        }
        if ((v93->log_id_str[33] & 4) != 0) {
          nw_quic_connection_set_client_identity_is_raw_public_Key(v34, 1);
        }
        nw_quic_connection_add_h3_alpn(v34, 1);
        nw_quic_connection_set_keepalive_count(v34, 3);
        if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
          dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_15_56153);
        }
        long long v88 = nw_protocol_create_options((void *)nw_protocol_copy_quic_stream_definition::quic_definition);
        id v39 = nw_quic_stream_copy_shared_connection_options(v88);
        BOOL v40 = v39;
        char v41 = *(unsigned char *)(v9 + 80);
        if ((v41 & 4) != 0)
        {
          nw_quic_connection_set_enable_l4s(v39, 1);
          char v41 = *(unsigned char *)(v9 + 80);
        }
        if ((v41 & 8) != 0) {
          nw_quic_connection_set_enable_multipath(v40, 1);
        }
        nw_quic_connection_set_idle_timeout(v40, 0);
        nw_quic_connection_set_max_datagram_frame_size(v40, 0xFFFF);
        nw_quic_connection_set_max_udp_payload_size(v40, 1472);
        nw_quic_connection_set_datagram_variant_flow_id_enabled(v40, 1);
        if (nw_masque_options_get_version(protocol) == 2)
        {
          nw_quic_connection_set_datagram_quarter_stream_id(v40, 1);
          nw_quic_connection_set_datagram_context_id(v40, 1);
        }
        nw_quic_connection_set_source_connection_id_length(v40, 8);
        nw_quic_connection_set_initial_packet_size(v40, 1350);
        nw_quic_connection_set_pmtud_for_non_transport(v40, 1);
        nw_quic_connection_set_migration_for_non_transport(v40, 1);
        BOOL v42 = *(void **)(v9 + 48);
        if (v42)
        {
          id v43 = v42;
          nw_quic_connection_set_sec_protocol_options(v40, v43);

          uint64_t v32 = v89;
        }
        if (*(void *)(v9 + 56))
        {
          if (a2)
          {
            if ((*(unsigned char *)(v9 + 81) & 4) == 0)
            {
              nw_quic_connection_set_use_swift_tls(v40, 1);
              if (*(char *)(v9 + 80) < 0) {
                nw_quic_connection_set_use_x25519(v40, 1);
              }
            }
          }
          nw_quic_connection_set_server_raw_public_keys(v40, *(void *)(v9 + 56));
        }
        uint64_t v44 = *(void *)(v9 + 64);
        if (v44) {
          nw_quic_connection_set_client_identity_reference(v40, v44, *(void *)(v9 + 72));
        }
        if ((*(unsigned char *)(v9 + 80) & 0x10) != 0) {
          nw_quic_connection_set_override_trust_certs_for_tests(v40, 1);
        }
        if ((*(unsigned char *)(v9 + 81) & 4) != 0) {
          nw_quic_connection_set_client_identity_is_raw_public_Key(v40, 1);
        }
        nw_quic_connection_add_h3_alpn(v40, 1);
        nw_quic_connection_set_keepalive_count(v40, 3);
        if (nw_protocol_demux_copy_definition::onceToken != -1) {
          dispatch_once(&nw_protocol_demux_copy_definition::onceToken, &__block_literal_global_8_26174);
        }
        if (nw_protocol_demux_copy_definition::definition)
        {
          os_log_type_t v45 = os_retain((void *)nw_protocol_demux_copy_definition::definition);
          size_t v87 = nw_protocol_create_options(v45);
          if (v45) {
            os_release(v45);
          }
          uint64_t v32 = v89;
        }
        else
        {
          size_t v87 = nw_protocol_create_options(0);
        }
        if (nw_protocol_setup_udp_definition(void)::onceToken[0] != -1) {
          dispatch_once(nw_protocol_setup_udp_definition(void)::onceToken, &__block_literal_global_45806);
        }
        __int16 v54 = nw_protocol_create_options((void *)g_udp_definition);
        nw_udp_options_set_use_quic_stats(v54, 1);
        nw_udp_options_set_no_metadata(v54, 1);
        nw_protocol_stack_append_application_protocol(v8, v92);
        nw_protocol_stack_append_application_protocol(v8, v16);
        nw_protocol_stack_append_application_protocol(v8, v32);
        nw_protocol_stack_append_application_protocol(v8, protocol);
        nw_protocol_stack_append_application_protocol(v8, v90);
        nw_protocol_stack_append_application_protocol(v8, v88);
        nw_protocol_stack_append_application_protocol(v8, v87);
        nw_protocol_stack_set_transport_protocol(&v8->super, &v54->super);
        id v55 = nw_protocol_options_copy_proxy_endpoint_for_stack(protocol);
        os_log_type_t v21 = nw_proxy_config_create_with_stack(v55, v8);

        if (nw_protocol_setup_udp_definition(void)::onceToken[0] != -1) {
          dispatch_once(nw_protocol_setup_udp_definition(void)::onceToken, &__block_literal_global_45806);
        }
        id v56 = (id)g_udp_definition;
        nw_proxy_config_set_alternate_protocol_stack(v21, 0, v56, 4u);

        if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
          dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_15_56153);
        }
        id v57 = (id)nw_protocol_copy_quic_stream_definition::quic_definition;
        nw_proxy_config_set_alternate_protocol_stack(v21, 0, v57, 3u);

        char v58 = v93->log_id_str[32];
        if (v58)
        {
          nw_proxy_config_set_alternate_protocol_stack(v21, 0, 0, 2u);
          char v58 = v93->log_id_str[32];
        }
        if ((v58 & 0x40) != 0)
        {
          BOOL v59 = objc_alloc_init(NWConcrete_nw_protocol_stack);
          uint64_t v60 = nw_masque_options_copy_listener_options(v92);
          nw_protocol_stack_append_application_protocol(v59, v60);

          nw_protocol_stack_append_application_protocol(v59, v16);
          nw_protocol_stack_append_application_protocol(v59, v89);
          nw_protocol_stack_append_application_protocol(v59, protocol);
          nw_protocol_stack_append_application_protocol(v59, v90);
          nw_protocol_stack_append_application_protocol(v59, v88);
          nw_protocol_stack_append_application_protocol(v59, v87);
          nw_protocol_stack_set_transport_protocol(&v59->super, &v54->super);
          if (nw_protocol_setup_udp_definition(void)::onceToken[0] != -1) {
            dispatch_once(nw_protocol_setup_udp_definition(void)::onceToken, &__block_literal_global_45806);
          }
          id v61 = (id)g_udp_definition;
          nw_proxy_config_set_listener_protocol_stack(v21, v59, v61, 4u);

          uint64_t v32 = v89;
        }
        nw_proxy_config_set_is_privacy_proxy(v21, 1, 0);
        nw_proxy_config_set_multipath_service(v21, 1);

LABEL_182:
LABEL_183:

        nw_proxy_config_set_type(v21, 3006);
        goto LABEL_184;
      }
      if (nw_protocol_options_is_oblivious_http(v13))
      {
        size_t v92 = nw_protocol_options_copy(*(void **)(v9 + 40));
        nw_protocol_options_set_proxy_endpoint(v92, *(void **)(v9 + 24), 0);
        protocol = nw_protocol_options_copy(*(void **)(v11 + 40));
        if (nw_protocol_copy_http3_definition_onceToken != -1) {
          dispatch_once(&nw_protocol_copy_http3_definition_onceToken, &__block_literal_global_13_73886);
        }
        BOOL v22 = nw_protocol_create_options((void *)nw_protocol_copy_http3_definition_http3_definition);
        os_log_type_t v16 = v22;
        if ((*(unsigned char *)(v9 + 80) & 2) != 0)
        {
          nw_http3_set_0rtt_enabled(v22, 1);
          nw_http3_set_idle_timeout(v16, 30);
          nw_http3_set_keepalive_mode(v16, 2);
          if (!uuid_is_null((const unsigned __int8 *)(v9 + 8))) {
            nw_http3_set_resumable_session_agent(v16, v9 + 8);
          }
        }
        else
        {
          nw_http3_set_idle_timeout(v22, 60);
          nw_http3_set_keepalive_mode(v16, 1);
        }
        if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
          dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_15_56153);
        }
        long long v90 = nw_protocol_create_options((void *)nw_protocol_copy_quic_stream_definition::quic_definition);
        BOOL v62 = (NWConcrete_nw_protocol_options *)nw_quic_stream_copy_shared_connection_options(v90);
        BOOL v63 = v62;
        char v64 = *(unsigned char *)(v9 + 80);
        if ((v64 & 4) != 0)
        {
          nw_quic_connection_set_enable_l4s(v62, 1);
          char v64 = *(unsigned char *)(v9 + 80);
        }
        if ((v64 & 8) != 0) {
          nw_quic_connection_set_enable_multipath(v63, 1);
        }
        nw_quic_connection_set_idle_timeout(v63, 0);
        nw_quic_connection_set_max_datagram_frame_size(v63, 0xFFFF);
        nw_quic_connection_set_datagram_variant_flow_id_enabled(v63, 1);
        if (nw_masque_options_get_version(v92) == 2)
        {
          nw_quic_connection_set_datagram_quarter_stream_id(v63, 1);
          nw_quic_connection_set_datagram_context_id(v63, 1);
        }
        nw_quic_connection_set_source_connection_id_length(v63, 8);
        nw_quic_connection_set_initial_packet_size(v63, 1350);
        BOOL v65 = *(void **)(v9 + 48);
        if (v65)
        {
          id v66 = v65;
          nw_quic_connection_set_sec_protocol_options(v63, v66);
        }
        if (*(void *)(v9 + 56))
        {
          if (a2)
          {
            if ((*(unsigned char *)(v9 + 81) & 4) == 0)
            {
              nw_quic_connection_set_use_swift_tls(v63, 1);
              if (*(char *)(v9 + 80) < 0) {
                nw_quic_connection_set_use_x25519(v63, 1);
              }
            }
          }
          nw_quic_connection_set_server_raw_public_keys(v63, *(void *)(v9 + 56));
        }
        else
        {
          uint64_t v67 = *(void *)(v9 + 64);
          if (v67)
          {
            nw_quic_connection_set_client_identity_reference(v63, v67, *(void *)(v9 + 72));
          }
          else if ((*(unsigned char *)(v9 + 80) & 0x10) != 0)
          {
            nw_quic_connection_set_override_trust_certs_for_tests(v63, 1);
          }
        }
        if ((*(unsigned char *)(v9 + 81) & 4) != 0) {
          nw_quic_connection_set_client_identity_is_raw_public_Key(v63, 1);
        }
        nw_quic_connection_add_h3_alpn(v63, 1);
        nw_quic_connection_set_keepalive_count(v63, 3);
        nw_protocol_stack_append_application_protocol(v8, protocol);
        nw_protocol_stack_append_application_protocol(v8, v92);
        nw_protocol_stack_append_application_protocol(v8, v16);
        nw_protocol_stack_set_transport_protocol(&v8->super, &v90->super);
        id v68 = nw_protocol_options_copy_proxy_endpoint_for_stack(v92);
        os_log_type_t v21 = nw_proxy_config_create_with_stack(v68, v8);

        nw_proxy_config_set_is_privacy_proxy(v21, 1, 0);
        uint64_t v69 = v63;
        if (nw_protocol_copy_http_messaging_definition_onceToken != -1) {
          dispatch_once(&nw_protocol_copy_http_messaging_definition_onceToken, &__block_literal_global_81);
        }
        id v70 = (id)nw_protocol_copy_http_messaging_definition_definition;
        nw_proxy_config_add_required_protocol(v21, v70);

        if (nw_protocol_copy_http_messaging_definition_onceToken != -1) {
          dispatch_once(&nw_protocol_copy_http_messaging_definition_onceToken, &__block_literal_global_81);
        }
        id v71 = (id)nw_protocol_copy_http_messaging_definition_definition;
        nw_proxy_config_add_protocol_to_remove(v21, v71);

        uint64_t v32 = v69;
        BOOL v34 = (void *)nw_protocol_boringssl_copy_definition();
        nw_proxy_config_add_protocol_to_remove(v21, v34);
        goto LABEL_182;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v19 = (id)gLogObj;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446210;
        long long v97 = "nw_proxy_config_create_privacy_proxy_internal";
        uint64_t v20 = "%{public}s Second hop must be MASQUE or OHTTP";
        goto LABEL_24;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v19 = (id)gLogObj;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446210;
        long long v97 = "nw_proxy_config_create_privacy_proxy_internal";
        uint64_t v20 = "%{public}s First hop must be MASQUE";
LABEL_24:
        _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_ERROR, v20, buf, 0xCu);
      }
    }

    goto LABEL_26;
  }
  if (v7 >> 3 == 1)
  {
    uint64_t v9 = nw_array_get_object_at_index((uint64_t)v4, 0);
    if (nw_protocol_options_is_masque(*(void **)(v9 + 40)))
    {
      size_t v93 = nw_protocol_options_copy(*(void **)(v9 + 40));
      nw_protocol_options_set_proxy_endpoint(v93, *(void **)(v9 + 24), 0);
      if (nw_protocol_copy_http3_definition_onceToken != -1) {
        dispatch_once(&nw_protocol_copy_http3_definition_onceToken, &__block_literal_global_13_73886);
      }
      os_log_type_t v10 = nw_protocol_create_options((void *)nw_protocol_copy_http3_definition_http3_definition);
      size_t v92 = v10;
      if ((*(unsigned char *)(v9 + 80) & 2) != 0)
      {
        nw_http3_set_0rtt_enabled(v10, 1);
        nw_http3_set_idle_timeout(v92, 30);
        nw_http3_set_keepalive_mode(v92, 2);
        if (!uuid_is_null((const unsigned __int8 *)(v9 + 8))) {
          nw_http3_set_resumable_session_agent(v92, v9 + 8);
        }
      }
      else
      {
        nw_http3_set_idle_timeout(v10, 60);
        nw_http3_set_keepalive_mode(v92, 1);
      }
      if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
        dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_15_56153);
      }
      protocol = nw_protocol_create_options((void *)nw_protocol_copy_quic_stream_definition::quic_definition);
      os_log_type_t v23 = (NWConcrete_nw_protocol_options *)nw_quic_stream_copy_shared_connection_options(protocol);
      os_log_type_t v16 = v23;
      char v24 = *(unsigned char *)(v9 + 80);
      if ((v24 & 4) != 0)
      {
        nw_quic_connection_set_enable_l4s(v23, 1);
        char v24 = *(unsigned char *)(v9 + 80);
      }
      if ((v24 & 8) != 0) {
        nw_quic_connection_set_enable_multipath(v16, 1);
      }
      nw_quic_connection_set_idle_timeout(v16, 0);
      nw_quic_connection_set_max_datagram_frame_size(v16, 0xFFFF);
      nw_quic_connection_set_datagram_variant_flow_id_enabled(v16, 1);
      if (nw_masque_options_get_version(v93) == 2)
      {
        nw_quic_connection_set_datagram_quarter_stream_id(v16, 1);
        nw_quic_connection_set_datagram_context_id(v16, 1);
      }
      nw_quic_connection_set_source_connection_id_length(v16, 8);
      nw_quic_connection_set_initial_packet_size(v16, 1350);
      os_log_type_t v25 = *(void **)(v9 + 48);
      if (v25)
      {
        id v26 = v25;
        nw_quic_connection_set_sec_protocol_options(v16, v26);
      }
      if (*(void *)(v9 + 56))
      {
        if (a2)
        {
          if ((*(unsigned char *)(v9 + 81) & 4) == 0)
          {
            nw_quic_connection_set_use_swift_tls(v16, 1);
            if (*(char *)(v9 + 80) < 0) {
              nw_quic_connection_set_use_x25519(v16, 1);
            }
          }
        }
        nw_quic_connection_set_server_raw_public_keys(v16, *(void *)(v9 + 56));
      }
      uint64_t v27 = *(void *)(v9 + 64);
      if (v27) {
        nw_quic_connection_set_client_identity_reference(v16, v27, *(void *)(v9 + 72));
      }
      if ((*(unsigned char *)(v9 + 81) & 4) != 0) {
        nw_quic_connection_set_client_identity_is_raw_public_Key(v16, 1);
      }
      if ((*(unsigned char *)(v9 + 80) & 0x10) != 0) {
        nw_quic_connection_set_override_trust_certs_for_tests(v16, 1);
      }
      nw_quic_connection_add_h3_alpn(v16, 1);
      nw_quic_connection_set_keepalive_count(v16, 3);
      nw_protocol_stack_append_application_protocol(v8, v93);
      nw_protocol_stack_append_application_protocol(v8, v92);
      if (*(unsigned char *)(v9 + 81))
      {
        nw_protocol_stack_append_application_protocol(v8, protocol);
        if (nw_protocol_demux_copy_definition::onceToken != -1) {
          dispatch_once(&nw_protocol_demux_copy_definition::onceToken, &__block_literal_global_8_26174);
        }
        if (nw_protocol_demux_copy_definition::definition)
        {
          os_log_type_t v28 = os_retain((void *)nw_protocol_demux_copy_definition::definition);
          os_log_type_t v29 = nw_protocol_create_options(v28);
          if (v28) {
            os_release(v28);
          }
        }
        else
        {
          os_log_type_t v29 = nw_protocol_create_options(0);
        }
        nw_protocol_stack_append_application_protocol(v8, v29);
        if (nw_protocol_setup_udp_definition(void)::onceToken[0] != -1) {
          dispatch_once(nw_protocol_setup_udp_definition(void)::onceToken, &__block_literal_global_45806);
        }
        os_log_type_t v46 = nw_protocol_create_options((void *)g_udp_definition);
        nw_udp_options_set_use_quic_stats(v46, 1);
        nw_udp_options_set_no_metadata(v46, 1);
        nw_protocol_stack_set_transport_protocol(&v8->super, &v46->super);
      }
      else
      {
        nw_protocol_stack_set_transport_protocol(&v8->super, &protocol->super);
      }
      id v47 = nw_protocol_options_copy_proxy_endpoint_for_stack(v93);
      os_log_type_t v21 = nw_proxy_config_create_with_stack(v47, v8);

      if (nw_protocol_setup_udp_definition(void)::onceToken[0] != -1) {
        dispatch_once(nw_protocol_setup_udp_definition(void)::onceToken, &__block_literal_global_45806);
      }
      id v48 = (id)g_udp_definition;
      nw_proxy_config_set_alternate_protocol_stack(v21, 0, v48, 4u);

      if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
        dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_15_56153);
      }
      id v49 = (id)nw_protocol_copy_quic_stream_definition::quic_definition;
      nw_proxy_config_set_alternate_protocol_stack(v21, 0, v49, 3u);

      char v50 = *(unsigned char *)(v9 + 80);
      if (v50)
      {
        nw_proxy_config_set_alternate_protocol_stack(v21, 0, 0, 2u);
        char v50 = *(unsigned char *)(v9 + 80);
      }
      if ((v50 & 0x40) != 0)
      {
        os_log_type_t v51 = objc_alloc_init(NWConcrete_nw_protocol_stack);
        char v52 = nw_masque_options_copy_listener_options(v93);
        nw_protocol_stack_append_application_protocol(v51, v52);

        nw_protocol_stack_append_application_protocol(v51, v92);
        nw_protocol_stack_set_transport_protocol(&v51->super, &protocol->super);
        if (nw_protocol_setup_udp_definition(void)::onceToken[0] != -1) {
          dispatch_once(nw_protocol_setup_udp_definition(void)::onceToken, &__block_literal_global_45806);
        }
        id v53 = (id)g_udp_definition;
        nw_proxy_config_set_listener_protocol_stack(v21, v51, v53, 4u);
      }
      nw_proxy_config_set_is_privacy_proxy(v21, 1, 0);
      nw_proxy_config_set_multipath_service(v21, 1);
      goto LABEL_183;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v18 = (id)gLogObj;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      long long v97 = "nw_proxy_config_create_privacy_proxy_internal";
      _os_log_impl(&dword_1830D4000, v18, OS_LOG_TYPE_ERROR, "%{public}s First hop must be MASQUE", buf, 0xCu);
    }
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v17 = (id)gLogObj;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      long long v97 = "nw_proxy_config_create_privacy_proxy_internal";
      _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_ERROR, "%{public}s No more than two hops are currently supported", buf, 0xCu);
    }
  }
LABEL_26:
  os_log_type_t v21 = 0;
LABEL_184:

LABEL_185:
  return v21;
}

void sub_183B9E824(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, _Unwind_Exception *exception_object, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void sub_183B9EA50(_Unwind_Exception *a1)
{
}

NWConcrete_nw_proxy_config *nw_proxy_config_create_boringssl_quic_privacy_proxy(void *a1)
{
  return nw_proxy_config_create_privacy_proxy_internal(a1, 0);
}

NWConcrete_nw_proxy_config *nw_proxy_config_create_swift_tls_quic_privacy_proxy(void *a1)
{
  return nw_proxy_config_create_privacy_proxy_internal(a1, 1);
}

uint64_t __Block_byref_object_copy__67787(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__67788(uint64_t a1)
{
}

uint64_t __33__nw_listener_inbox_socket_start__block_invoke_2(uint64_t a1)
{
  nw_fd_wrapper_close(*(void **)(a1 + 32));
  BOOL v2 = *(void **)(*(void *)(a1 + 40) + 8);

  return objc_msgSend(v2, "handleInboxCancelComplete:");
}

uint64_t ___ZL28nw_listener_inbox_accept_udpP24nw_listener_inbox_socketiPiPbP8sockaddrjP16nw_ip_ecn_flag_tPU22objcproto11OS_nw_array8NSObject_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  nw_endpoint_t v5 = nw_connection_copy_endpoint(v4);
  uint64_t v6 = nw_connection_copy_parameters(v4);
  nw_endpoint_t v7 = nw_parameters_copy_local_endpoint(v6);
  if (!v5) {
    goto LABEL_10;
  }
  os_log_type_t v8 = v5;
  int v9 = [v8 type];

  if (v9 != 1) {
    goto LABEL_10;
  }
  int v10 = nw_endpoint_address_endpoint_matches_address(v8, *(unsigned __int8 **)(a1 + 40), 0, 0);
  int v11 = v7 ? v10 : 0;
  if (v11 == 1
    && (BOOL v12 = v7, v13 = [v12 type], v12, v13 == 1)
    && nw_endpoint_address_endpoint_matches_address(v12, (unsigned __int8 *)(a1 + 56), 0, 0))
  {
    nw_connection_add_initial_inbound_data(v4, *(void **)(a1 + 32), **(_DWORD **)(a1 + 48));
    uint64_t v14 = 0;
  }
  else
  {
LABEL_10:
    uint64_t v14 = 1;
  }

  return v14;
}

void sub_183B9EE90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL28nw_listener_inbox_accept_udpP24nw_listener_inbox_socketiPiPbP8sockaddrjP16nw_ip_ecn_flag_tPU22objcproto11OS_nw_array8NSObject_block_invoke_95(uint64_t a1, void *a2, _OWORD *a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  nw_endpoint_t v5 = a2;
  if (nw_interface_shallow_compare(v5, *(void **)(a1 + 32)))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v6 = (id)gLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      nw_endpoint_t v7 = v5 + 104;
      int v8 = 136446978;
      int v9 = "nw_listener_inbox_accept_udp_block_invoke";
      if (!v5) {
        nw_endpoint_t v7 = 0;
      }
      __int16 v10 = 2080;
      int v11 = v7;
      __int16 v12 = 1040;
      int v13 = 16;
      __int16 v14 = 2096;
      os_log_type_t v15 = a3;
      _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_INFO, "%{public}s Found interface %s, using agent id %{uuid_t}.16P", (uint8_t *)&v8, 0x26u);
    }

    *(_OWORD *)*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = *a3;
  }
}

uint64_t nw_ip_is_broadcast(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  int v5 = *(unsigned __int8 *)(a1 + 1);
  if (v5 != 30)
  {
    if (v5 == 2)
    {
      uint64_t v6 = (int *)(a1 + 4);
      goto LABEL_4;
    }
LABEL_12:
    uint64_t v12 = 0;
    goto LABEL_20;
  }
  if (*(_DWORD *)(a1 + 8) || *(_DWORD *)(a1 + 12) || *(_DWORD *)(a1 + 16) != -65536) {
    goto LABEL_12;
  }
  uint64_t v6 = (int *)(a1 + 20);
LABEL_4:
  int v7 = *v6;
  if (*v6 == -1) {
    goto LABEL_19;
  }
  if (!v3) {
    goto LABEL_12;
  }
  int v8 = (char *)v3;
  int v9 = v8;
  __int16 v10 = *(_WORD *)(v8 + 85);
  if ((v10 & 0x80) != 0) {
    int v11 = *((_DWORD *)v8 + 18);
  }
  else {
    int v11 = 0;
  }

  int v13 = v9;
  if ((*(_WORD *)(v9 + 85) & 0x100) == 0)
  {

    uint64_t v12 = 0;
    goto LABEL_20;
  }
  int v14 = v13[19];

  if (v7 == v14 || (uint64_t v12 = 0, (v10 & 0x80) != 0) && (v14 & v11) == v7) {
LABEL_19:
  }
    uint64_t v12 = 1;
LABEL_20:

  return v12;
}

void __41__nw_listener_inbox_protocol_description__block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = *(void **)(v2 + 24);
  if (!v3)
  {
    uint64_t v4 = *(void *)(v2 + 88);
    if (v4) {
      int v5 = *(const char **)(v4 + 16);
    }
    else {
      int v5 = "(null)";
    }
    CFStringRef v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<protocol: %s>", v5);
    uint64_t v7 = *(void *)(a1 + 32);
    int v8 = *(void **)(v7 + 24);
    *(void *)(v7 + 24) = v6;

    id v3 = *(void **)(*(void *)(a1 + 32) + 24);
  }
  int v9 = (id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40);

  objc_storeStrong(v9, v3);
}

void nw_listen_protocol_disconnected(nw_listen_protocol *a1, nw_protocol *a2, int a3)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    CFStringRef v6 = a1->handle;
    if (v6)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (id)gLogObj;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)int buf = 136446722;
        os_log_type_t v28 = "nw_listen_protocol_disconnected";
        __int16 v29 = 2114;
        uint64_t v30 = v6;
        __int16 v31 = 1024;
        int v32 = a3;
        _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_INFO, "%{public}s Listener %{public}@ disconnected with error %d", buf, 0x1Cu);
      }

      ((void (*)(nw_protocol *, nw_listen_protocol *))a2->callbacks->remove_listen_handler)(a2, a1);
      if (a3) {
        posix_CFErrorRef error = nw_error_create_posix_error(a3);
      }
      else {
        posix_CFErrorRef error = 0;
      }
      [v6[1] handleInboxFailed:v6 error:posix_error];

LABEL_9:
      return;
    }
    int v13 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v28 = "nw_listen_protocol_disconnected";
    int v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (__nwlog_fault(v14, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v15 = __nwlog_obj();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v28 = "nw_listen_protocol_disconnected";
          _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s called with null inbox", buf, 0xCu);
        }
      }
      else if (v25)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v15 = __nwlog_obj();
        os_log_type_t v21 = type;
        BOOL v22 = os_log_type_enabled(v15, type);
        if (backtrace_string)
        {
          if (v22)
          {
            *(_DWORD *)int buf = 136446466;
            os_log_type_t v28 = "nw_listen_protocol_disconnected";
            __int16 v29 = 2082;
            uint64_t v30 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v15, v21, "%{public}s called with null inbox, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_45;
        }
        if (v22)
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v28 = "nw_listen_protocol_disconnected";
          _os_log_impl(&dword_1830D4000, v15, v21, "%{public}s called with null inbox, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v15 = __nwlog_obj();
        os_log_type_t v24 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v28 = "nw_listen_protocol_disconnected";
          _os_log_impl(&dword_1830D4000, v15, v24, "%{public}s called with null inbox, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_45:
    if (v14) {
      free(v14);
    }
    goto LABEL_9;
  }
  int v9 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v28 = "nw_listen_protocol_disconnected";
  __int16 v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v25 = 0;
  if (__nwlog_fault(v10, &type, &v25))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v28 = "nw_listen_protocol_disconnected";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null listener", buf, 0xCu);
      }
    }
    else if (v25)
    {
      __int16 v17 = (char *)__nw_create_backtrace_string();
      int v11 = __nwlog_obj();
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v11, type);
      if (v17)
      {
        if (v19)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v28 = "nw_listen_protocol_disconnected";
          __int16 v29 = 2082;
          uint64_t v30 = v17;
          _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s called with null listener, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v17);
        goto LABEL_40;
      }
      if (v19)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v28 = "nw_listen_protocol_disconnected";
        _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s called with null listener, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v11 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v28 = "nw_listen_protocol_disconnected";
        _os_log_impl(&dword_1830D4000, v11, v23, "%{public}s called with null listener, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_40:
  if (v10) {
    free(v10);
  }
}

void sub_183B9FDF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

char *nw_path_evaluator_copy_description_level(void *a1, int a2)
{
  out[7] = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  uint64_t v4 = v3;
  if (v3)
  {
    uint64_t v20 = 0;
    int v5 = (void *)*((void *)v3 + 2);
    if (v5)
    {
      if (a2 == 1)
      {
        CFStringRef v6 = v5;
        *(void *)os_log_type_t type = 0;
        BOOL v22 = type;
        uint64_t v23 = 0x2020000000;
        uint64_t v7 = v6 + 45;
        uint64_t v24 = 0;
        out[0] = MEMORY[0x1E4F143A8];
        out[1] = 3221225472;
        out[2] = __nw_endpoint_get_description_block_invoke;
        out[3] = &unk_1E524B978;
        int v8 = v6;
        out[4] = v8;
        out[5] = type;
        os_unfair_lock_lock(v7);
        ((void (*)(void *))out[2])(out);
        os_unfair_lock_unlock(v7);
        logging_description = (const char *)*((void *)v22 + 3);

        _Block_object_dispose(type, 8);
      }
      else
      {
        logging_description = nw_endpoint_get_logging_description(v5);
      }
      memset(out, 0, 37);
      uuid_unparse(v4 + 80, (char *)out);
      asprintf(&v20, "Evaluator %s to %s", (const char *)out, logging_description);
    }
    else
    {
      asprintf(&v20, "Default evaluator");
    }
    __int16 v10 = v20;
    goto LABEL_9;
  }
  os_log_type_t v12 = __nwlog_obj();
  LODWORD(out[0]) = 136446210;
  *(void *)((char *)out + 4) = "nw_path_evaluator_copy_description_level";
  int v13 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v20) = 0;
  if (__nwlog_fault(v13, type, &v20))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v14 = __nwlog_obj();
      os_log_type_t v15 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        LODWORD(out[0]) = 136446210;
        *(void *)((char *)out + 4) = "nw_path_evaluator_copy_description_level";
        _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s called with null evaluator", (uint8_t *)out, 0xCu);
      }
    }
    else if ((_BYTE)v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v14 = __nwlog_obj();
      os_log_type_t v17 = type[0];
      BOOL v18 = os_log_type_enabled(v14, type[0]);
      if (backtrace_string)
      {
        if (v18)
        {
          LODWORD(out[0]) = 136446466;
          *(void *)((char *)out + 4) = "nw_path_evaluator_copy_description_level";
          WORD2(out[1]) = 2082;
          *(void *)((char *)&out[1] + 6) = backtrace_string;
          _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null evaluator, dumping backtrace:%{public}s", (uint8_t *)out, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_26;
      }
      if (v18)
      {
        LODWORD(out[0]) = 136446210;
        *(void *)((char *)out + 4) = "nw_path_evaluator_copy_description_level";
        _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null evaluator, no backtrace", (uint8_t *)out, 0xCu);
      }
    }
    else
    {
      int v14 = __nwlog_obj();
      os_log_type_t v19 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        LODWORD(out[0]) = 136446210;
        *(void *)((char *)out + 4) = "nw_path_evaluator_copy_description_level";
        _os_log_impl(&dword_1830D4000, v14, v19, "%{public}s called with null evaluator, backtrace limit exceeded", (uint8_t *)out, 0xCu);
      }
    }
  }
LABEL_26:
  if (v13) {
    free(v13);
  }
  __int16 v10 = 0;
LABEL_9:

  return v10;
}

void sub_183BA0B70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

char *nw_path_evaluator_copy_description(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = nw_path_evaluator_copy_description_level(v1, 1);
    goto LABEL_3;
  }
  int v5 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v16 = "nw_path_evaluator_copy_description";
  CFStringRef v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_path_evaluator_copy_description";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null evaluator", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v16 = "nw_path_evaluator_copy_description";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null evaluator, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_path_evaluator_copy_description";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null evaluator, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_path_evaluator_copy_description";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null evaluator, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

void sub_183BA0E84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double ___ZL19nw_path_get_globalsPU24objcproto13OS_nw_context8NSObject_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 128) = 0u;
  *(void *)(a2 + 144) = 0;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  double result = NAN;
  *(void *)(a2 + 132) = -1;
  return result;
}

uint64_t __Block_byref_object_copy__68682(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__68683(uint64_t a1)
{
}

uint64_t ___ZL28nw_path_fallback_descriptionP18NWConcrete_nw_pathPcm_block_invoke(void *a1, int a2, xpc_object_t xstring)
{
  uint64_t v4 = *(char **)(*(void *)(a1[4] + 8) + 24);
  size_t v5 = *(void *)(*(void *)(a1[5] + 8) + 24);
  int v6 = *(unsigned __int8 *)(*(void *)(a1[6] + 8) + 24);
  string_ptr = xpc_string_get_string_ptr(xstring);
  os_log_type_t v8 = ", ";
  if (!v6) {
    os_log_type_t v8 = "";
  }
  int v9 = snprintf(v4, v5, "%s%s", v8, string_ptr);
  if (*(void *)(*(void *)(a1[5] + 8) + 24) <= (unint64_t)v9)
  {
    **(unsigned char **)(*(void *)(a1[4] + 8) + 24) = 0;
    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else if (v9 >= 1)
  {
    *(void *)(*(void *)(a1[4] + 8) + 24) += v9;
    *(void *)(*(void *)(a1[5] + 8) + 24) -= v9;
  }
  *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = 1;
  return 1;
}

uint64_t ___ZL28nw_path_fallback_descriptionP18NWConcrete_nw_pathPcm_block_invoke_2(void *a1, int a2, xpc_object_t xstring)
{
  uint64_t v4 = *(char **)(*(void *)(a1[4] + 8) + 24);
  size_t v5 = *(void *)(*(void *)(a1[5] + 8) + 24);
  int v6 = *(unsigned __int8 *)(*(void *)(a1[6] + 8) + 24);
  string_ptr = xpc_string_get_string_ptr(xstring);
  os_log_type_t v8 = ", ";
  if (!v6) {
    os_log_type_t v8 = "";
  }
  int v9 = snprintf(v4, v5, "%s%s", v8, string_ptr);
  if (*(void *)(*(void *)(a1[5] + 8) + 24) <= (unint64_t)v9)
  {
    **(unsigned char **)(*(void *)(a1[4] + 8) + 24) = 0;
    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else if (v9 >= 1)
  {
    *(void *)(*(void *)(a1[4] + 8) + 24) += v9;
    *(void *)(*(void *)(a1[5] + 8) + 24) -= v9;
  }
  *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = 1;
  return 1;
}

BOOL nw_path_has_unsatisfied_cellular_agent(void *a1, char a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  uint64_t v4 = v3;
  if (v3)
  {
    *(void *)int buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000;
    char v21 = 0;
    size_t v5 = (void *)*((void *)v3 + 28);
    if (v5)
    {
      applier[0] = MEMORY[0x1E4F143A8];
      applier[1] = 3221225472;
      applier[2] = __nw_path_has_unsatisfied_cellular_agent_block_invoke;
      applier[3] = &unk_1E52480F8;
      char v17 = a2;
      void applier[4] = buf;
      xpc_dictionary_apply(v5, applier);
      BOOL v6 = *(unsigned char *)(*(void *)&buf[8] + 24) != 0;
    }
    else
    {
      BOOL v6 = 0;
    }
    _Block_object_dispose(buf, 8);
    goto LABEL_6;
  }
  os_log_type_t v8 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_path_has_unsatisfied_cellular_agent";
  int v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (__nwlog_fault(v9, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_has_unsatisfied_cellular_agent";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_path_has_unsatisfied_cellular_agent";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v14)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_has_unsatisfied_cellular_agent";
        _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_has_unsatisfied_cellular_agent";
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_23:
  if (v9) {
    free(v9);
  }
  BOOL v6 = 0;
LABEL_6:

  return v6;
}

void sub_183BA14E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

BOOL ___ZL32nw_path_netagent_applies_to_pathP18NWConcrete_nw_pathPU24objcproto13OS_xpc_object8NSObjectb_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  bytes = xpc_uuid_get_bytes(v4);
  int v6 = uuid_compare(bytes, *(const unsigned __int8 **)(a1 + 40));
  if (!v6) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  }
  BOOL v7 = v6 != 0;

  return v7;
}

void sub_183BA1564(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL32nw_path_netagent_applies_to_pathP18NWConcrete_nw_pathPU24objcproto13OS_xpc_object8NSObjectb_block_invoke_2(uint64_t a1, size_t a2, xpc_object_t xstring)
{
  string_ptr = xpc_string_get_string_ptr(xstring);
  string = xpc_array_get_string(*(xpc_object_t *)(a1 + 32), a2);
  uint64_t result = 1;
  if (string_ptr && string)
  {
    uint64_t v8 = *(void *)(a1 + 48);
    if (!strncmp(string_ptr, (const char *)(v8 + 16), 0x20uLL))
    {
      int v9 = strncmp(string, (const char *)(v8 + 48), 0x20uLL);
      uint64_t result = 1;
      if (!v9)
      {
        *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
        return 0;
      }
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t ___ZL32nw_path_netagent_applies_to_pathP18NWConcrete_nw_pathPU24objcproto13OS_xpc_object8NSObjectb_block_invoke_3(uint64_t a1, size_t a2, xpc_object_t xstring)
{
  string_ptr = xpc_string_get_string_ptr(xstring);
  string = xpc_array_get_string(*(xpc_object_t *)(a1 + 32), a2);
  uint64_t result = 1;
  if (string_ptr && string)
  {
    uint64_t v8 = *(void *)(a1 + 48);
    if (!strncmp(string_ptr, (const char *)(v8 + 16), 0x20uLL))
    {
      int v9 = strncmp(string, (const char *)(v8 + 48), 0x20uLL);
      uint64_t result = 1;
      if (!v9)
      {
        *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
        return 0;
      }
    }
    else
    {
      return 1;
    }
  }
  return result;
}

void nw_path_release_globals(uint64_t a1, char a2)
{
  *(void *)&v36[5] = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    id v4 = *(os_unfair_lock_s **)(a1 + 40);
    if (v4)
    {
      _nw_hash_table_release(v4);
      *(void *)(a1 + 40) = 0;
    }
    size_t v5 = *(void **)(a1 + 32);
    *(void *)(a1 + 32) = 0;

    int v6 = *(void **)(a1 + 48);
    *(void *)(a1 + 48) = 0;

    BOOL v7 = *(void **)(a1 + 64);
    *(void *)(a1 + 64) = 0;

    uint64_t v8 = *(void **)(a1 + 72);
    *(void *)(a1 + 72) = 0;

    int v9 = *(void **)(a1 + 80);
    *(void *)(a1 + 80) = 0;

    os_log_type_t v10 = *(void **)(a1 + 88);
    *(void *)(a1 + 88) = 0;

    os_log_type_t v11 = *(void **)(a1 + 104);
    *(void *)(a1 + 104) = 0;

    if (*(void *)(a1 + 112))
    {
      NEFlowDirectorDestroy_delayInitStub(v12);
      *(void *)(a1 + 112) = 0;
    }
    if ((a2 & 1) == 0)
    {
      uint64_t v13 = *(void *)(a1 + 56);
      if (v13)
      {
        nw_queue_cancel_source(v13);
        *(void *)(a1 + 56) = 0;
      }
    }
    *(_DWORD *)(a1 + 120) = 0;
    *(_DWORD *)(a1 + 124) = 0;
    pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 120));
    int v14 = *(_DWORD *)(a1 + 132);
    if ((v14 & 0x80000000) == 0)
    {
      if ((*(unsigned char *)(a1 + 140) & 2) != 0)
      {
        if (guarded_close_np() && (a2 & 1) == 0)
        {
          int v15 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
          uint64_t v16 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v16);
          char v17 = (id)gLogObj;
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            int v18 = *(_DWORD *)(a1 + 132);
            *(_DWORD *)int buf = 136446722;
            BOOL v34 = "nw_path_close_fd";
            __int16 v35 = 1024;
            *(_DWORD *)BOOL v36 = v18;
            v36[2] = 1024;
            *(_DWORD *)&v36[3] = v15;
            _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_ERROR, "%{public}s Failed to close guarded necp fd %d %{darwin.errno}d", buf, 0x18u);
          }
        }
      }
      else
      {
        close(v14);
      }
      *(_DWORD *)(a1 + 132) = -1;
    }
    int v19 = *(_DWORD *)(a1 + 136);
    if ((v19 & 0x80000000) == 0)
    {
      if ((*(unsigned char *)(a1 + 140) & 4) != 0)
      {
        if (guarded_close_np() && (a2 & 1) == 0)
        {
          int v20 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
          uint64_t v21 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v21);
          uint64_t v22 = (id)gLogObj;
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          {
            int v23 = *(_DWORD *)(a1 + 136);
            *(_DWORD *)int buf = 136446722;
            BOOL v34 = "nw_path_close_fd";
            __int16 v35 = 1024;
            *(_DWORD *)BOOL v36 = v23;
            v36[2] = 1024;
            *(_DWORD *)&v36[3] = v20;
            _os_log_impl(&dword_1830D4000, v22, OS_LOG_TYPE_ERROR, "%{public}s Failed to close guarded necp observer fd %d %{darwin.errno}d", buf, 0x18u);
          }
        }
      }
      else
      {
        close(v19);
      }
      *(_DWORD *)(a1 + 136) = -1;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 120));
    uuid_clear((unsigned __int8 *)a1);

    return;
  }
  uint64_t v24 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  BOOL v34 = "nw_path_release_globals";
  char v25 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v31 = 0;
  if (__nwlog_fault(v25, &type, &v31))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v26 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v34 = "nw_path_release_globals";
        os_log_type_t v28 = "%{public}s called with null globals";
LABEL_42:
        _os_log_impl(&dword_1830D4000, v26, v27, v28, buf, 0xCu);
      }
    }
    else
    {
      if (v31)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        id v26 = __nwlog_obj();
        os_log_type_t v27 = type;
        BOOL v30 = os_log_type_enabled(v26, type);
        if (backtrace_string)
        {
          if (v30)
          {
            *(_DWORD *)int buf = 136446466;
            BOOL v34 = "nw_path_release_globals";
            __int16 v35 = 2082;
            *(void *)BOOL v36 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v26, v27, "%{public}s called with null globals, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_44;
        }
        if (!v30) {
          goto LABEL_43;
        }
        *(_DWORD *)int buf = 136446210;
        BOOL v34 = "nw_path_release_globals";
        os_log_type_t v28 = "%{public}s called with null globals, no backtrace";
        goto LABEL_42;
      }
      id v26 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v34 = "nw_path_release_globals";
        os_log_type_t v28 = "%{public}s called with null globals, backtrace limit exceeded";
        goto LABEL_42;
      }
    }
LABEL_43:
  }
LABEL_44:
  if (v25) {
    free(v25);
  }
}

const char *nw_path_status_get_description(unsigned int a1)
{
  if (a1 > 3) {
    return "unknown";
  }
  else {
    return off_1E5248570[a1];
  }
}

char *nw_path_flow_registration_copy_description(uint64_t a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  memset(out, 0, 37);
  uuid_unparse_upper((const unsigned __int8 *)(a1 + 32), out);
  uint64_t v2 = 0;
  asprintf(&v2, "%s", out);
  return v2;
}

uint64_t __nw_path_copy_for_flow_registration_block_invoke_3(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  size_t v5 = v4;
  uint64_t v6 = *(void *)(a1 + 32);
  if (*(void *)(v6 + 144) == *((void *)v4 + 4)
    && *(void *)(v6 + 152) == *((void *)v4 + 5)
    && (*((unsigned char *)v4 + 149) & 1) == 0)
  {
    nw_array_append(*(void *)(*(void *)(a1 + 40) + 72), *(void **)(a1 + 48));
    uint64_t v7 = 0;
  }
  else
  {
    uint64_t v7 = 1;
  }

  return v7;
}

void nw_path_prepare_fork()
{
  if (nw_context_copy_implicit_context::onceToken != -1) {
    dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
  }
  id v0 = (id)nw_context_copy_implicit_context::implicit_context;
  globals_for_path = (os_unfair_lock_s *)nw_context_get_globals_for_path(v0);

  os_unfair_lock_lock(globals_for_path + 31);

  os_unfair_lock_lock(globals_for_path + 30);
}

void sub_183BA1D48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_path_parent_has_forked()
{
  if (nw_context_copy_implicit_context::onceToken != -1) {
    dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
  }
  id v0 = (id)nw_context_copy_implicit_context::implicit_context;
  globals_for_path = (os_unfair_lock_s *)nw_context_get_globals_for_path(v0);

  os_unfair_lock_unlock(globals_for_path + 30);

  os_unfair_lock_unlock(globals_for_path + 31);
}

void sub_183BA1DD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL23nw_path_snapshot_agentsP18NWConcrete_nw_path_block_invoke(uint64_t a1, int a2, void *object)
{
  return 1;
}

uint64_t nw_path_create_bridged_flow_director(void *a1, unsigned char *a2)
{
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    uint64_t globals_for_path = nw_context_get_globals_for_path(v3);
    uint64_t v6 = (os_unfair_lock_s *)(globals_for_path + 124);
    os_unfair_lock_lock((os_unfair_lock_t)(globals_for_path + 124));
    id v7 = v4;
    if (globals_for_path)
    {
      if (*(void *)(globals_for_path + 112))
      {
        if (a2) {
          *a2 = 0;
        }
        uint64_t v9 = 1;
        goto LABEL_74;
      }
      gotLoadHelper_x8__NEFlowDirectorCreateBridge(v8);
      if (!*(void *)(v10 + 2072))
      {
LABEL_73:
        uint64_t v9 = 0;
LABEL_74:

        os_unfair_lock_unlock(v6);
        goto LABEL_75;
      }
      int v11 = socket(32, 2, 2);
      int v12 = v11;
      if ((v11 & 0x80000000) == 0)
      {
        unsigned int v71 = 0;
        *(void *)&v72[20] = 0;
        int v77 = 0;
        long long v75 = 0u;
        long long v76 = 0u;
        long long v73 = 0u;
        long long v74 = 0u;
        strcpy(v72, "com.apple.flow-divert");
        if (ioctl(v11, 0xC0644E03uLL, &v71))
        {
          int v13 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v14 = (id)gLogObj;
          *(_DWORD *)int buf = 136446466;
          uint64_t v67 = "nw_path_open_in_process_flow_divert_socket";
          LOWORD(v68) = 1024;
          *(_DWORD *)((char *)&v68 + 2) = v13;
          int v15 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          os_log_type_t v59 = OS_LOG_TYPE_DEFAULT;
          if (__nwlog_fault(v15, type, &v59))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v16 = (id)gLogObj;
              os_log_type_t v17 = type[0];
              if (os_log_type_enabled(v16, type[0]))
              {
                *(_DWORD *)int buf = 136446466;
                uint64_t v67 = "nw_path_open_in_process_flow_divert_socket";
                LOWORD(v68) = 1024;
                *(_DWORD *)((char *)&v68 + 2) = v13;
                _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s ioctl(CTLIOCGINFO) failed %{darwin.errno}d", buf, 0x12u);
              }
            }
            else if (v59)
            {
              backtrace_string = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v16 = (id)gLogObj;
              os_log_type_t v30 = type[0];
              BOOL v31 = os_log_type_enabled(v16, type[0]);
              if (backtrace_string)
              {
                if (v31)
                {
                  *(_DWORD *)int buf = 136446722;
                  uint64_t v67 = "nw_path_open_in_process_flow_divert_socket";
                  LOWORD(v68) = 1024;
                  *(_DWORD *)((char *)&v68 + 2) = v13;
                  HIWORD(v68) = 2082;
                  uint64_t v69 = backtrace_string;
                  _os_log_impl(&dword_1830D4000, v16, v30, "%{public}s ioctl(CTLIOCGINFO) failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
                }

                free(backtrace_string);
                if (!v15) {
                  goto LABEL_57;
                }
                goto LABEL_56;
              }
              if (v31)
              {
                *(_DWORD *)int buf = 136446466;
                uint64_t v67 = "nw_path_open_in_process_flow_divert_socket";
                LOWORD(v68) = 1024;
                *(_DWORD *)((char *)&v68 + 2) = v13;
                _os_log_impl(&dword_1830D4000, v16, v30, "%{public}s ioctl(CTLIOCGINFO) failed %{darwin.errno}d, no backtrace", buf, 0x12u);
              }
            }
            else
            {
              uint64_t v16 = __nwlog_obj();
              os_log_type_t v40 = type[0];
              if (os_log_type_enabled(v16, type[0]))
              {
                *(_DWORD *)int buf = 136446466;
                uint64_t v67 = "nw_path_open_in_process_flow_divert_socket";
                LOWORD(v68) = 1024;
                *(_DWORD *)((char *)&v68 + 2) = v13;
                _os_log_impl(&dword_1830D4000, v16, v40, "%{public}s ioctl(CTLIOCGINFO) failed %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
              }
            }
          }
          if (!v15)
          {
LABEL_57:
            close(v12);
            goto LABEL_73;
          }
LABEL_56:
          free(v15);
          goto LABEL_57;
        }
        uint64_t v69 = 0;
        uint64_t v68 = 0;
        int v70 = 0;
        *(_DWORD *)int buf = 139296;
        uint64_t v67 = (const char *)(v71 | 0xFFFFFFF00000000);
        if (!connect(v12, (const sockaddr *)buf, 0x20u))
        {
          Bridge_uint64_t delayInitStub = NEFlowDirectorCreateBridge_delayInitStub(v23);
          *(void *)(globals_for_path + 112) = Bridge_delayInitStub;
          if (Bridge_delayInitStub)
          {
            NEFlowDirectorStart_delayInitStub(v36);
            uint64_t v9 = 1;
            if (a2) {
              *a2 = 1;
            }
            goto LABEL_74;
          }
          close(v12);
          goto LABEL_73;
        }
        int v24 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v25 = (id)gLogObj;
        *(_DWORD *)os_log_type_t type = 136446466;
        id v61 = "nw_path_open_in_process_flow_divert_socket";
        __int16 v62 = 1024;
        int v63 = v24;
        id v26 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t v59 = OS_LOG_TYPE_ERROR;
        char v58 = 0;
        if (__nwlog_fault(v26, &v59, &v58))
        {
          if (v59 == OS_LOG_TYPE_FAULT)
          {
            os_log_type_t v27 = __nwlog_obj();
            os_log_type_t v28 = v59;
            if (os_log_type_enabled(v27, v59))
            {
              *(_DWORD *)os_log_type_t type = 136446466;
              id v61 = "nw_path_open_in_process_flow_divert_socket";
              __int16 v62 = 1024;
              int v63 = v24;
              _os_log_impl(&dword_1830D4000, v27, v28, "%{public}s connect failed on kernel control socket %{darwin.errno}d", (uint8_t *)type, 0x12u);
            }
          }
          else if (v58)
          {
            id v37 = (char *)__nw_create_backtrace_string();
            os_log_type_t v27 = __nwlog_obj();
            os_log_type_t v38 = v59;
            BOOL v39 = os_log_type_enabled(v27, v59);
            if (v37)
            {
              if (v39)
              {
                *(_DWORD *)os_log_type_t type = 136446722;
                id v61 = "nw_path_open_in_process_flow_divert_socket";
                __int16 v62 = 1024;
                int v63 = v24;
                __int16 v64 = 2082;
                BOOL v65 = v37;
                _os_log_impl(&dword_1830D4000, v27, v38, "%{public}s connect failed on kernel control socket %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)type, 0x1Cu);
              }

              free(v37);
              goto LABEL_70;
            }
            if (v39)
            {
              *(_DWORD *)os_log_type_t type = 136446466;
              id v61 = "nw_path_open_in_process_flow_divert_socket";
              __int16 v62 = 1024;
              int v63 = v24;
              _os_log_impl(&dword_1830D4000, v27, v38, "%{public}s connect failed on kernel control socket %{darwin.errno}d, no backtrace", (uint8_t *)type, 0x12u);
            }
          }
          else
          {
            os_log_type_t v27 = __nwlog_obj();
            os_log_type_t v42 = v59;
            if (os_log_type_enabled(v27, v59))
            {
              *(_DWORD *)os_log_type_t type = 136446466;
              id v61 = "nw_path_open_in_process_flow_divert_socket";
              __int16 v62 = 1024;
              int v63 = v24;
              _os_log_impl(&dword_1830D4000, v27, v42, "%{public}s connect failed on kernel control socket %{darwin.errno}d, backtrace limit exceeded", (uint8_t *)type, 0x12u);
            }
          }
        }
LABEL_70:
        if (v26) {
          free(v26);
        }
        close(v12);
        goto LABEL_73;
      }
      int v18 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v19 = (id)gLogObj;
      unsigned int v71 = 136446466;
      *(void *)__int16 v72 = "nw_path_open_in_process_flow_divert_socket";
      *(_WORD *)&v72[8] = 1024;
      *(_DWORD *)&v72[10] = v18;
      int v20 = (char *)_os_log_send_and_compose_impl();

      buf[0] = 16;
      type[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v20, buf, type)) {
        goto LABEL_61;
      }
      if (buf[0] == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v21 = (id)gLogObj;
        os_log_type_t v22 = buf[0];
        if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
        {
          unsigned int v71 = 136446466;
          *(void *)__int16 v72 = "nw_path_open_in_process_flow_divert_socket";
          *(_WORD *)&v72[8] = 1024;
          *(_DWORD *)&v72[10] = v18;
          _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s Cannot create kernel control socket %{darwin.errno}d", (uint8_t *)&v71, 0x12u);
        }
      }
      else if (type[0])
      {
        int v32 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v21 = (id)gLogObj;
        os_log_type_t v33 = buf[0];
        BOOL v34 = os_log_type_enabled(v21, (os_log_type_t)buf[0]);
        if (v32)
        {
          if (v34)
          {
            unsigned int v71 = 136446722;
            *(void *)__int16 v72 = "nw_path_open_in_process_flow_divert_socket";
            *(_WORD *)&v72[8] = 1024;
            *(_DWORD *)&v72[10] = v18;
            *(_WORD *)&v72[14] = 2082;
            *(void *)&v72[16] = v32;
            _os_log_impl(&dword_1830D4000, v21, v33, "%{public}s Cannot create kernel control socket %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)&v71, 0x1Cu);
          }

          free(v32);
          if (!v20) {
            goto LABEL_73;
          }
          goto LABEL_62;
        }
        if (v34)
        {
          unsigned int v71 = 136446466;
          *(void *)__int16 v72 = "nw_path_open_in_process_flow_divert_socket";
          *(_WORD *)&v72[8] = 1024;
          *(_DWORD *)&v72[10] = v18;
          _os_log_impl(&dword_1830D4000, v21, v33, "%{public}s Cannot create kernel control socket %{darwin.errno}d, no backtrace", (uint8_t *)&v71, 0x12u);
        }
      }
      else
      {
        uint64_t v21 = __nwlog_obj();
        os_log_type_t v41 = buf[0];
        if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
        {
          unsigned int v71 = 136446466;
          *(void *)__int16 v72 = "nw_path_open_in_process_flow_divert_socket";
          *(_WORD *)&v72[8] = 1024;
          *(_DWORD *)&v72[10] = v18;
          _os_log_impl(&dword_1830D4000, v21, v41, "%{public}s Cannot create kernel control socket %{darwin.errno}d, backtrace limit exceeded", (uint8_t *)&v71, 0x12u);
        }
      }
      goto LABEL_60;
    }
    id v48 = __nwlog_obj();
    unsigned int v71 = 136446210;
    *(void *)__int16 v72 = "nw_path_create_bridged_flow_director_locked";
    int v20 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v20, buf, type))
    {
      if (buf[0] == 17)
      {
        uint64_t v21 = __nwlog_obj();
        os_log_type_t v49 = buf[0];
        if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
        {
          unsigned int v71 = 136446210;
          *(void *)__int16 v72 = "nw_path_create_bridged_flow_director_locked";
          _os_log_impl(&dword_1830D4000, v21, v49, "%{public}s called with null globals", (uint8_t *)&v71, 0xCu);
        }
LABEL_60:

        goto LABEL_61;
      }
      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        uint64_t v21 = __nwlog_obj();
        os_log_type_t v57 = buf[0];
        if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
        {
          unsigned int v71 = 136446210;
          *(void *)__int16 v72 = "nw_path_create_bridged_flow_director_locked";
          _os_log_impl(&dword_1830D4000, v21, v57, "%{public}s called with null globals, backtrace limit exceeded", (uint8_t *)&v71, 0xCu);
        }
        goto LABEL_60;
      }
      id v53 = (char *)__nw_create_backtrace_string();
      uint64_t v21 = __nwlog_obj();
      os_log_type_t v54 = buf[0];
      BOOL v55 = os_log_type_enabled(v21, (os_log_type_t)buf[0]);
      if (!v53)
      {
        if (v55)
        {
          unsigned int v71 = 136446210;
          *(void *)__int16 v72 = "nw_path_create_bridged_flow_director_locked";
          _os_log_impl(&dword_1830D4000, v21, v54, "%{public}s called with null globals, no backtrace", (uint8_t *)&v71, 0xCu);
        }
        goto LABEL_60;
      }
      if (v55)
      {
        unsigned int v71 = 136446466;
        *(void *)__int16 v72 = "nw_path_create_bridged_flow_director_locked";
        *(_WORD *)&v72[8] = 2082;
        *(void *)&v72[10] = v53;
        _os_log_impl(&dword_1830D4000, v21, v54, "%{public}s called with null globals, dumping backtrace:%{public}s", (uint8_t *)&v71, 0x16u);
      }

      free(v53);
    }
LABEL_61:
    if (!v20) {
      goto LABEL_73;
    }
LABEL_62:
    free(v20);
    goto LABEL_73;
  }
  uint64_t v44 = __nwlog_obj();
  unsigned int v71 = 136446210;
  *(void *)__int16 v72 = "nw_path_create_bridged_flow_director";
  os_log_type_t v45 = (char *)_os_log_send_and_compose_impl();

  buf[0] = 16;
  type[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v45, buf, type))
  {
    if (buf[0] == 17)
    {
      os_log_type_t v46 = __nwlog_obj();
      os_log_type_t v47 = buf[0];
      if (os_log_type_enabled(v46, (os_log_type_t)buf[0]))
      {
        unsigned int v71 = 136446210;
        *(void *)__int16 v72 = "nw_path_create_bridged_flow_director";
        _os_log_impl(&dword_1830D4000, v46, v47, "%{public}s called with null context", (uint8_t *)&v71, 0xCu);
      }
    }
    else if (type[0])
    {
      char v50 = (char *)__nw_create_backtrace_string();
      os_log_type_t v46 = __nwlog_obj();
      os_log_type_t v51 = buf[0];
      BOOL v52 = os_log_type_enabled(v46, (os_log_type_t)buf[0]);
      if (v50)
      {
        if (v52)
        {
          unsigned int v71 = 136446466;
          *(void *)__int16 v72 = "nw_path_create_bridged_flow_director";
          *(_WORD *)&v72[8] = 2082;
          *(void *)&v72[10] = v50;
          _os_log_impl(&dword_1830D4000, v46, v51, "%{public}s called with null context, dumping backtrace:%{public}s", (uint8_t *)&v71, 0x16u);
        }

        free(v50);
        goto LABEL_105;
      }
      if (v52)
      {
        unsigned int v71 = 136446210;
        *(void *)__int16 v72 = "nw_path_create_bridged_flow_director";
        _os_log_impl(&dword_1830D4000, v46, v51, "%{public}s called with null context, no backtrace", (uint8_t *)&v71, 0xCu);
      }
    }
    else
    {
      os_log_type_t v46 = __nwlog_obj();
      os_log_type_t v56 = buf[0];
      if (os_log_type_enabled(v46, (os_log_type_t)buf[0]))
      {
        unsigned int v71 = 136446210;
        *(void *)__int16 v72 = "nw_path_create_bridged_flow_director";
        _os_log_impl(&dword_1830D4000, v46, v56, "%{public}s called with null context, backtrace limit exceeded", (uint8_t *)&v71, 0xCu);
      }
    }
  }
LABEL_105:
  if (v45) {
    free(v45);
  }
  uint64_t v9 = 0;
LABEL_75:

  return v9;
}

void sub_183BA2BB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL29nw_path_allowed_by_parametersP18NWConcrete_nw_pathb_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  int value = xpc_uint64_get_value(v4);
  if (*(_DWORD *)(a1 + 48) == value || *(_DWORD *)(a1 + 52) == value)
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
    if (!*(unsigned char *)(a1 + 56))
    {
LABEL_18:
      uint64_t v12 = 0;
      goto LABEL_19;
    }
    if (value <= 1001)
    {
      if (!value)
      {
        int v11 = "other";
        goto LABEL_17;
      }
      if (value == 1001)
      {
        int v11 = "wifi_infrastructure";
        goto LABEL_17;
      }
    }
    else
    {
      switch(value)
      {
        case 1002:
          int v11 = "wifi_awdl";
          goto LABEL_17;
        case 4001:
          int v11 = "coprocessor";
          goto LABEL_17;
        case 5001:
          int v11 = "companion";
LABEL_17:
          nw_path_set_reason(*(void **)(a1 + 32), 6, "Interface subtype '%s' is prohibited by parameters", v6, v7, v8, v9, v10, (char)v11);
          goto LABEL_18;
      }
    }
    int v11 = "unknown";
    goto LABEL_17;
  }
  uint64_t v12 = 1;
LABEL_19:

  return v12;
}

void sub_183BA2CD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL29nw_path_allowed_by_parametersP18NWConcrete_nw_pathb_block_invoke_3(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = nw_interface_create_from_dictionary(a3);
  if (v4
    && (nw_interface_shallow_compare(*(void **)(*(void *)(a1 + 32) + 96), v4)
     || nw_interface_shallow_compare(*(void **)(*(void *)(a1 + 32) + 104), v4)))
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
    if (*(unsigned char *)(a1 + 48)) {
      nw_path_set_reason(*(void **)(a1 + 32), 8, "Interface %s[%u] is prohibited by parameters", v5, v6, v7, v8, v9, (_BYTE)v4 + 104);
    }
    uint64_t v10 = 0;
  }
  else
  {
    uint64_t v10 = 1;
  }

  return v10;
}

void sub_183BA2D8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_path_is_roaming(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    if ((*((unsigned char *)v1 + 475) & 0x20) != 0)
    {
      BOOL v4 = 1;
    }
    else
    {
      *(void *)int buf = 0;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x2020000000;
      char v18 = 0;
      id v3 = (void *)*((void *)v1 + 28);
      if (v3)
      {
        applier[0] = MEMORY[0x1E4F143A8];
        applier[1] = 3221225472;
        applier[2] = __nw_path_is_roaming_block_invoke;
        applier[3] = &unk_1E5249BA8;
        void applier[4] = buf;
        xpc_dictionary_apply(v3, applier);
        BOOL v4 = *(unsigned char *)(*(void *)&buf[8] + 24) != 0;
      }
      else
      {
        BOOL v4 = 0;
      }
      _Block_object_dispose(buf, 8);
    }
    goto LABEL_8;
  }
  uint64_t v6 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_path_is_roaming";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v7, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_is_roaming";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_path_is_roaming";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_25;
      }
      if (v12)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_is_roaming";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_is_roaming";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_25:
  if (v7) {
    free(v7);
  }
  BOOL v4 = 0;
LABEL_8:

  return v4;
}

void sub_183BA30D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t ___ZL29nw_path_allowed_by_parametersP18NWConcrete_nw_pathb_block_invoke_4(uint64_t a1, uint64_t a2, void *a3)
{
  length[5] = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  memset(out, 0, 37);
  bytes = xpc_uuid_get_bytes(v4);
  uuid_unparse(bytes, out);
  uint64_t v6 = *(void **)(*(void *)(a1 + 32) + 224);
  if (v6)
  {
    uint64_t v7 = xpc_dictionary_get_value(v6, out);
    uint64_t v8 = v7;
    if (v7)
    {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
      if (!*(unsigned char *)(a1 + 48))
      {
LABEL_30:
        uint64_t v17 = 0;
        goto LABEL_31;
      }
      id v26 = 0;
      length[0] = 0;
      data = (const unsigned __int8 *)xpc_dictionary_get_data(v7, "data", length);
      if (data)
      {
        if (length[0] >= 0xD8)
        {
          uint64_t v10 = data;
          if (length[0] == *((unsigned int *)data + 53) + 216)
          {
            memset(length, 0, 37);
            uuid_unparse_upper(data, (char *)length);
            asprintf(&v26, "Network Agent [domain: %s, type: %s, description: %s, uuid: %s, flags: %x]", (const char *)v10 + 16, (const char *)v10 + 48, (const char *)v10 + 80, (const char *)length, *((_DWORD *)v10 + 52));
            uint64_t v16 = *(void **)(a1 + 32);
            if (v26)
            {
              nw_path_set_reason(v16, 10, "%s is prohibited by parameters", v11, v12, v13, v14, v15, (char)v26);
              if (v26) {
                free(v26);
              }
              goto LABEL_30;
            }
            goto LABEL_29;
          }
        }
      }
      __nwlog_obj();
      LODWORD(length[0]) = 136446210;
      *(size_t *)((char *)length + 4) = (size_t)"nw_network_agent_copy_full_description";
      id v25 = length;
      char v18 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v27 = 0;
      if (__nwlog_fault(v18, &type, &v27))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          uint64_t v19 = __nwlog_obj();
          os_log_type_t v20 = type;
          if (os_log_type_enabled(v19, type))
          {
            LODWORD(length[0]) = 136446210;
            *(size_t *)((char *)length + 4) = (size_t)"nw_network_agent_copy_full_description";
            uint64_t v21 = "%{public}s called with null agent";
LABEL_25:
            _os_log_impl(&dword_1830D4000, v19, v20, v21, (uint8_t *)length, 0xCu);
          }
        }
        else if (v27)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          uint64_t v19 = __nwlog_obj();
          os_log_type_t v20 = type;
          BOOL v23 = os_log_type_enabled(v19, type);
          if (backtrace_string)
          {
            if (v23)
            {
              LODWORD(length[0]) = 136446466;
              *(size_t *)((char *)length + 4) = (size_t)"nw_network_agent_copy_full_description";
              WORD2(length[1]) = 2082;
              *(size_t *)((char *)&length[1] + 6) = (size_t)backtrace_string;
              _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s called with null agent, dumping backtrace:%{public}s", (uint8_t *)length, 0x16u);
            }
            free(backtrace_string);
            goto LABEL_26;
          }
          if (v23)
          {
            LODWORD(length[0]) = 136446210;
            *(size_t *)((char *)length + 4) = (size_t)"nw_network_agent_copy_full_description";
            uint64_t v21 = "%{public}s called with null agent, no backtrace";
            goto LABEL_25;
          }
        }
        else
        {
          uint64_t v19 = __nwlog_obj();
          os_log_type_t v20 = type;
          if (os_log_type_enabled(v19, type))
          {
            LODWORD(length[0]) = 136446210;
            *(size_t *)((char *)length + 4) = (size_t)"nw_network_agent_copy_full_description";
            uint64_t v21 = "%{public}s called with null agent, backtrace limit exceeded";
            goto LABEL_25;
          }
        }
      }
LABEL_26:
      if (v18) {
        free(v18);
      }
      uint64_t v16 = *(void **)(a1 + 32);
LABEL_29:
      nw_path_set_reason(v16, 10, "Unknown network agent is prohibited by parameters", v11, v12, v13, v14, v15, (char)v25);
      goto LABEL_30;
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  uint64_t v17 = 1;
LABEL_31:

  return v17;
}

void sub_183BA3454(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL29nw_path_allowed_by_parametersP18NWConcrete_nw_pathb_block_invoke_5(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  memset(out, 0, 37);
  bytes = xpc_uuid_get_bytes(v4);
  uuid_unparse(bytes, out);
  uint64_t v11 = *(void **)(*(void *)(a1 + 32) + 224);
  if (!v11
    || (xpc_dictionary_get_value(v11, out),
        uint64_t v12 = objc_claimAutoreleasedReturnValue(),
        BOOL v13 = v12 == 0,
        v12,
        v13))
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
    if (*(unsigned char *)(a1 + 48)) {
      nw_path_set_reason(*(void **)(a1 + 32), 11, "Missing network agent uuid:%s required by parameters", v6, v7, v8, v9, v10, (char)out);
    }
    uint64_t v14 = 0;
  }
  else
  {
    uint64_t v14 = 1;
  }

  return v14;
}

void sub_183BA3564(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL29nw_path_allowed_by_parametersP18NWConcrete_nw_pathb_block_invoke_6(uint64_t a1, size_t a2, void *a3)
{
  id v5 = a3;
  string_ptr = xpc_string_get_string_ptr(v5);
  string = xpc_array_get_string(*(xpc_object_t *)(a1 + 32), a2);
  uint64_t v18 = 0;
  uint64_t v19 = &v18;
  uint64_t v20 = 0x2020000000;
  char v21 = 0;
  uint64_t v8 = *(void **)(a1 + 40);
  uint64_t v9 = (void *)v8[28];
  if (!v9) {
    goto LABEL_4;
  }
  applier[0] = MEMORY[0x1E4F143A8];
  applier[1] = 3221225472;
  applier[2] = ___ZL29nw_path_allowed_by_parametersP18NWConcrete_nw_pathb_block_invoke_7;
  applier[3] = &unk_1E5248348;
  uint64_t v15 = string_ptr;
  uint64_t v16 = string;
  uint64_t v14 = &v18;
  char v17 = *(unsigned char *)(a1 + 56);
  BOOL v13 = v8;
  xpc_dictionary_apply(v9, applier);

  if (*((unsigned char *)v19 + 24))
  {
    uint64_t v10 = 0;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 0;
  }
  else
  {
LABEL_4:
    uint64_t v10 = 1;
  }
  _Block_object_dispose(&v18, 8);

  return v10;
}

void sub_183BA3698(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Block_object_dispose((const void *)(v15 - 64), 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZL29nw_path_allowed_by_parametersP18NWConcrete_nw_pathb_block_invoke_8(uint64_t a1, size_t a2, void *a3)
{
  id v5 = a3;
  string_ptr = xpc_string_get_string_ptr(v5);
  string = xpc_array_get_string(*(xpc_object_t *)(a1 + 32), a2);
  uint64_t v17 = 0;
  uint64_t v18 = &v17;
  uint64_t v19 = 0x2020000000;
  char v20 = 0;
  BOOL v13 = *(void **)(*(void *)(a1 + 40) + 224);
  if (!v13) {
    goto LABEL_4;
  }
  applier[0] = MEMORY[0x1E4F143A8];
  applier[1] = 3221225472;
  applier[2] = ___ZL29nw_path_allowed_by_parametersP18NWConcrete_nw_pathb_block_invoke_9;
  applier[3] = &unk_1E5248398;
  void applier[5] = string_ptr;
  applier[6] = string;
  void applier[4] = &v17;
  xpc_dictionary_apply(v13, applier);
  if (*((unsigned char *)v18 + 24))
  {
    uint64_t v14 = 1;
  }
  else
  {
LABEL_4:
    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 0;
    if (*(unsigned char *)(a1 + 56)) {
      nw_path_set_reason(*(void **)(a1 + 40), 11, "Missing network agent domain:%s, type:%s required by parameters", v7, v8, v9, v10, v11, (char)string_ptr);
    }
    uint64_t v14 = 0;
  }
  _Block_object_dispose(&v17, 8);

  return v14;
}

void sub_183BA37EC(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v2 - 64), 8);

  _Unwind_Resume(a1);
}

uint64_t ___ZL29nw_path_allowed_by_parametersP18NWConcrete_nw_pathb_block_invoke_9(void *a1, int a2, xpc_object_t xdict)
{
  size_t length = 0;
  if (!xdict) {
    return 1;
  }
  data = (const char *)xpc_dictionary_get_data(xdict, "data", &length);
  if (!data) {
    return 1;
  }
  if (length < 0xD8) {
    return 1;
  }
  id v5 = data;
  if (length != *((unsigned int *)data + 53) + 216) {
    return 1;
  }
  uint64_t v6 = (const char *)a1[5];
  if (v6)
  {
    if (*v6 && strncmp(v6, v5 + 16, 0x20uLL)) {
      return 1;
    }
  }
  uint64_t v7 = (const char *)a1[6];
  if (v7)
  {
    if (*v7 && strncmp(v7, v5 + 48, 0x20uLL)) {
      return 1;
    }
  }
  uint64_t result = 0;
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = 1;
  return result;
}

uint64_t ___ZL29nw_path_allowed_by_parametersP18NWConcrete_nw_pathb_block_invoke_7(uint64_t a1, int a2, xpc_object_t xdict)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  length[0] = 0;
  if (!xdict) {
    return 1;
  }
  data = (const char *)xpc_dictionary_get_data(xdict, "data", length);
  if (!data) {
    return 1;
  }
  if (length[0] < 0xD8) {
    return 1;
  }
  id v5 = data;
  if (length[0] != *((unsigned int *)data + 53) + 216) {
    return 1;
  }
  uint64_t v6 = *(const char **)(a1 + 48);
  if (v6)
  {
    if (*v6 && strncmp(v6, v5 + 16, 0x20uLL)) {
      return 1;
    }
  }
  uint64_t v7 = *(const char **)(a1 + 56);
  if (v7)
  {
    if (*v7 && strncmp(v7, v5 + 48, 0x20uLL)) {
      return 1;
    }
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
  if (*(unsigned char *)(a1 + 64))
  {
    uint64_t v15 = 0;
    *(_OWORD *)size_t length = 0u;
    memset(v17, 0, sizeof(v17));
    uuid_unparse_upper((const unsigned __int8 *)v5, (char *)length);
    asprintf(&v15, "Network Agent [domain: %s, type: %s, description: %s, uuid: %s, flags: %x]", v5 + 16, v5 + 48, v5 + 80, (const char *)length, *((_DWORD *)v5 + 52));
    uint64_t v14 = *(void **)(a1 + 32);
    if (v15)
    {
      nw_path_set_reason(v14, 10, "%s is prohibited by parameters domain:%s, type:%s", v9, v10, v11, v12, v13, (char)v15);
      if (v15) {
        free(v15);
      }
    }
    else
    {
      nw_path_set_reason(v14, 10, "Unknown network agent is prohibited by parameters domain:%s, type:%s", v9, v10, v11, v12, v13, *(void *)(a1 + 48));
    }
  }
  return 0;
}

uint64_t __nw_path_is_roaming_block_invoke(uint64_t a1, int a2, xpc_object_t xdict)
{
  size_t length = 0;
  if (!xdict) {
    return 1;
  }
  data = (const char *)xpc_dictionary_get_data(xdict, "data", &length);
  if (!data) {
    return 1;
  }
  if (length < 0xD8) {
    return 1;
  }
  id v5 = data;
  uint64_t v6 = *((unsigned int *)data + 53);
  if (length != v6 + 216 || (data[208] & 2) == 0) {
    return 1;
  }
  int v8 = strncmp(data + 16, "Cellular", 0x20uLL);
  uint64_t result = 1;
  if (!v8 && v6 >= 4 && !v5[217] && v5[216] == 5)
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
    return 0;
  }
  return result;
}

void ___ZL36nw_path_is_ultra_constrained_allowedv_block_invoke()
{
  id v0 = (void *)nw_utilities_copy_local_entitlement_value("com.apple.private.network.ultraconstrained");
  id v1 = v0;
  if (v0)
  {
    xpc_object_t xBOOL = v0;
    Class Class = object_getClass(v0);
    id v1 = xBOOL;
    if (Class == (Class)MEMORY[0x1E4F14570])
    {
      BOOL value = xpc_BOOL_get_value(xBOOL);
      id v1 = xBOOL;
      if (value) {
        nw_path_is_ultra_constrained_allowed(void)::is_allowed = 1;
      }
    }
  }
}

void sub_183BA3BD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL49nw_path_copy_dictionary_for_agent_with_generationPU24objcproto13OS_nw_context8NSObjectPhjPU8__strongPU29objcproto18OS_nw_proxy_configS__block_invoke(uint64_t a1, const char *a2)
{
  uint64_t uint64 = xpc_dictionary_get_uint64(*(xpc_object_t *)(a1 + 32), a2);
  if ((unint64_t)nw_delta_nanos(uint64, *(void *)(a1 + 48)) >= 0x77359401) {
    xpc_array_set_string(*(xpc_object_t *)(a1 + 40), 0xFFFFFFFFFFFFFFFFLL, a2);
  }
  return 1;
}

uint64_t ___ZL49nw_path_copy_dictionary_for_agent_with_generationPU24objcproto13OS_nw_context8NSObjectPhjPU8__strongPU29objcproto18OS_nw_proxy_configS__block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  string_ptr = xpc_string_get_string_ptr(v4);
  if (string_ptr)
  {
    xpc_dictionary_set_value(*(xpc_object_t *)(a1 + 32), string_ptr, 0);
    xpc_dictionary_set_value(*(xpc_object_t *)(a1 + 40), string_ptr, 0);
    nw_dictionary_set_value(*(void *)(a1 + 48), string_ptr, 0);
  }

  return 1;
}

void sub_183BA3CB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_path_copy_interface_with_generation_block_invoke(uint64_t a1, const char *a2)
{
  uint64_t uint64 = xpc_dictionary_get_uint64(*(xpc_object_t *)(a1 + 32), a2);
  if ((unint64_t)nw_delta_nanos(uint64, *(void *)(a1 + 48)) >= 0x77359401) {
    xpc_array_set_string(*(xpc_object_t *)(a1 + 40), 0xFFFFFFFFFFFFFFFFLL, a2);
  }
  return 1;
}

uint64_t __nw_path_copy_interface_with_generation_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  string_ptr = xpc_string_get_string_ptr(v4);
  if (string_ptr)
  {
    nw_dictionary_set_value(*(void *)(a1 + 32), string_ptr, 0);
    xpc_dictionary_set_value(*(xpc_object_t *)(a1 + 40), string_ptr, 0);
  }

  return 1;
}

void sub_183BA3D7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_path_evaluator *nw_path_create_evaluator_for_group(void *a1, void *a2)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  id v4 = a1;
  id v5 = a2;
  if (v4)
  {
    uint64_t v6 = objc_alloc_init(NWConcrete_nw_path_evaluator);
    uint64_t v7 = v6;
    if (v6)
    {
      objc_storeStrong((id *)v6 + 3, a1);
      if (v5) {
        nw_parameters_t v8 = (nw_parameters_t)v5;
      }
      else {
        nw_parameters_t v8 = nw_parameters_create();
      }
      uint64_t v13 = (void *)*((void *)v7 + 1);
      *((void *)v7 + 1) = v8;

      if (nw_path_evaluator_evaluate(v7, 0))
      {
        uint64_t v14 = v7;
LABEL_44:

        goto LABEL_45;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v15 = (id)gLogObj;
      *(_DWORD *)int buf = 136446210;
      double v36 = "nw_path_create_evaluator_for_group";
      uint64_t v10 = (void *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v33 = 0;
      if (!__nwlog_fault((const char *)v10, &type, &v33))
      {
LABEL_41:
        if (!v10)
        {
LABEL_43:
          uint64_t v14 = 0;
          goto LABEL_44;
        }
LABEL_42:
        free(v10);
        goto LABEL_43;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v11 = (id)gLogObj;
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)int buf = 136446210;
          double v36 = "nw_path_create_evaluator_for_group";
          _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s nw_path_evaluator_evaluate failed", buf, 0xCu);
        }
LABEL_40:

        goto LABEL_41;
      }
      if (!v33)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v11 = (id)gLogObj;
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)int buf = 136446210;
          double v36 = "nw_path_create_evaluator_for_group";
          _os_log_impl(&dword_1830D4000, v11, v23, "%{public}s nw_path_evaluator_evaluate failed, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_40;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v11 = (id)gLogObj;
      os_log_type_t v20 = type;
      BOOL v21 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)int buf = 136446210;
          double v36 = "nw_path_create_evaluator_for_group";
          _os_log_impl(&dword_1830D4000, v11, v20, "%{public}s nw_path_evaluator_evaluate failed, no backtrace", buf, 0xCu);
        }
        goto LABEL_40;
      }
      if (v21)
      {
        *(_DWORD *)int buf = 136446466;
        double v36 = "nw_path_create_evaluator_for_group";
        __int16 v37 = 2082;
        os_log_type_t v38 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v11, v20, "%{public}s nw_path_evaluator_evaluate failed, dumping backtrace:%{public}s", buf, 0x16u);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v9 = (id)gLogObj;
      *(_DWORD *)int buf = 136446210;
      double v36 = "nw_path_create_evaluator_for_group";
      uint64_t v10 = (void *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v33 = 0;
      if (!__nwlog_fault((const char *)v10, &type, &v33)) {
        goto LABEL_41;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v11 = (id)gLogObj;
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)int buf = 136446210;
          double v36 = "nw_path_create_evaluator_for_group";
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed", buf, 0xCu);
        }
        goto LABEL_40;
      }
      if (!v33)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v11 = (id)gLogObj;
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)int buf = 136446210;
          double v36 = "nw_path_create_evaluator_for_group";
          _os_log_impl(&dword_1830D4000, v11, v22, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_40;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v11 = (id)gLogObj;
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)int buf = 136446210;
          double v36 = "nw_path_create_evaluator_for_group";
          _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, no backtrace", buf, 0xCu);
        }
        goto LABEL_40;
      }
      if (v19)
      {
        *(_DWORD *)int buf = 136446466;
        double v36 = "nw_path_create_evaluator_for_group";
        __int16 v37 = 2082;
        os_log_type_t v38 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
      }
    }

    free(backtrace_string);
    if (!v10) {
      goto LABEL_43;
    }
    goto LABEL_42;
  }
  id v25 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  double v36 = "nw_path_create_evaluator_for_group";
  id v26 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v33 = 0;
  if (__nwlog_fault(v26, &type, &v33))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v27 = __nwlog_obj();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)int buf = 136446210;
        double v36 = "nw_path_create_evaluator_for_group";
        _os_log_impl(&dword_1830D4000, v27, v28, "%{public}s called with null group_descriptor", buf, 0xCu);
      }
    }
    else if (v33)
    {
      __int16 v29 = (char *)__nw_create_backtrace_string();
      char v27 = __nwlog_obj();
      os_log_type_t v30 = type;
      BOOL v31 = os_log_type_enabled(v27, type);
      if (v29)
      {
        if (v31)
        {
          *(_DWORD *)int buf = 136446466;
          double v36 = "nw_path_create_evaluator_for_group";
          __int16 v37 = 2082;
          os_log_type_t v38 = v29;
          _os_log_impl(&dword_1830D4000, v27, v30, "%{public}s called with null group_descriptor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v29);
        goto LABEL_62;
      }
      if (v31)
      {
        *(_DWORD *)int buf = 136446210;
        double v36 = "nw_path_create_evaluator_for_group";
        _os_log_impl(&dword_1830D4000, v27, v30, "%{public}s called with null group_descriptor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      char v27 = __nwlog_obj();
      os_log_type_t v32 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)int buf = 136446210;
        double v36 = "nw_path_create_evaluator_for_group";
        _os_log_impl(&dword_1830D4000, v27, v32, "%{public}s called with null group_descriptor, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_62:
  if (v26) {
    free(v26);
  }
  uint64_t v14 = 0;
LABEL_45:

  return v14;
}

void sub_183BA458C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_path_evaluator *nw_path_create_evaluator_for_browse(void *a1, void *a2)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  id v4 = a1;
  id v5 = a2;
  if (!v4)
  {
    char v27 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    double v36 = "nw_path_create_evaluator_for_browse";
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (__nwlog_fault(v10, &type, &v33))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v11 = __nwlog_obj();
        os_log_type_t v28 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)int buf = 136446210;
          double v36 = "nw_path_create_evaluator_for_browse";
          _os_log_impl(&dword_1830D4000, v11, v28, "%{public}s called with null browse_descriptor", buf, 0xCu);
        }
LABEL_37:

        goto LABEL_38;
      }
      if (!v33)
      {
        uint64_t v11 = __nwlog_obj();
        os_log_type_t v32 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)int buf = 136446210;
          double v36 = "nw_path_create_evaluator_for_browse";
          _os_log_impl(&dword_1830D4000, v11, v32, "%{public}s called with null browse_descriptor, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_37;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v30 = type;
      BOOL v31 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v31)
        {
          *(_DWORD *)int buf = 136446210;
          double v36 = "nw_path_create_evaluator_for_browse";
          _os_log_impl(&dword_1830D4000, v11, v30, "%{public}s called with null browse_descriptor, no backtrace", buf, 0xCu);
        }
        goto LABEL_37;
      }
      if (v31)
      {
        *(_DWORD *)int buf = 136446466;
        double v36 = "nw_path_create_evaluator_for_browse";
        __int16 v37 = 2082;
        os_log_type_t v38 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v11, v30, "%{public}s called with null browse_descriptor, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
LABEL_38:
    if (!v10)
    {
LABEL_46:
      uint64_t v7 = 0;
      goto LABEL_47;
    }
LABEL_39:
    free(v10);
    goto LABEL_46;
  }
  uint64_t v6 = objc_alloc_init(NWConcrete_nw_path_evaluator);
  uint64_t v7 = v6;
  if (!v6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v9 = (id)gLogObj;
    *(_DWORD *)int buf = 136446210;
    double v36 = "nw_path_create_evaluator_for_browse";
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v10, &type, &v33)) {
      goto LABEL_38;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v11 = (id)gLogObj;
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)int buf = 136446210;
        double v36 = "nw_path_create_evaluator_for_browse";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed", buf, 0xCu);
      }
    }
    else if (v33)
    {
      os_log_type_t v18 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v11 = (id)gLogObj;
      os_log_type_t v19 = type;
      BOOL v20 = os_log_type_enabled(v11, type);
      if (v18)
      {
        if (v20)
        {
          *(_DWORD *)int buf = 136446466;
          double v36 = "nw_path_create_evaluator_for_browse";
          __int16 v37 = 2082;
          os_log_type_t v38 = v18;
          _os_log_impl(&dword_1830D4000, v11, v19, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v18);
        if (!v10) {
          goto LABEL_46;
        }
        goto LABEL_39;
      }
      if (v20)
      {
        *(_DWORD *)int buf = 136446210;
        double v36 = "nw_path_create_evaluator_for_browse";
        _os_log_impl(&dword_1830D4000, v11, v19, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v11 = (id)gLogObj;
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)int buf = 136446210;
        double v36 = "nw_path_create_evaluator_for_browse";
        _os_log_impl(&dword_1830D4000, v11, v24, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_37;
  }
  objc_storeStrong((id *)v6 + 4, a1);
  if (v5) {
    nw_parameters_t v8 = (nw_parameters_t)v5;
  }
  else {
    nw_parameters_t v8 = nw_parameters_create();
  }
  uint64_t v13 = (void *)*((void *)v7 + 1);
  *((void *)v7 + 1) = v8;

  if ((nw_path_evaluator_evaluate(v7, 0) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v14 = (id)gLogObj;
    *(_DWORD *)int buf = 136446210;
    double v36 = "nw_path_create_evaluator_for_browse";
    id v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (__nwlog_fault(v15, &type, &v33))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v16 = (id)gLogObj;
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)int buf = 136446210;
          double v36 = "nw_path_create_evaluator_for_browse";
          _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s nw_path_evaluator_evaluate failed", buf, 0xCu);
        }
      }
      else if (v33)
      {
        BOOL v21 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v16 = (id)gLogObj;
        os_log_type_t v22 = type;
        BOOL v23 = os_log_type_enabled(v16, type);
        if (v21)
        {
          if (v23)
          {
            *(_DWORD *)int buf = 136446466;
            double v36 = "nw_path_create_evaluator_for_browse";
            __int16 v37 = 2082;
            os_log_type_t v38 = v21;
            _os_log_impl(&dword_1830D4000, v16, v22, "%{public}s nw_path_evaluator_evaluate failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v21);
          if (!v15) {
            goto LABEL_45;
          }
          goto LABEL_44;
        }
        if (v23)
        {
          *(_DWORD *)int buf = 136446210;
          double v36 = "nw_path_create_evaluator_for_browse";
          _os_log_impl(&dword_1830D4000, v16, v22, "%{public}s nw_path_evaluator_evaluate failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v16 = (id)gLogObj;
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)int buf = 136446210;
          double v36 = "nw_path_create_evaluator_for_browse";
          _os_log_impl(&dword_1830D4000, v16, v25, "%{public}s nw_path_evaluator_evaluate failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    if (!v15)
    {
LABEL_45:

      goto LABEL_46;
    }
LABEL_44:
    free(v15);
    goto LABEL_45;
  }
LABEL_47:

  return v7;
}

void sub_183BA4DAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_path_evaluator *nw_path_create_evaluator_for_advertise(void *a1, void *a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  id v4 = a1;
  id v5 = a2;
  if (!v4)
  {
    os_log_type_t v19 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v28 = "nw_path_create_evaluator_for_advertise";
    id v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (__nwlog_fault(v9, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v10 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v28 = "nw_path_create_evaluator_for_advertise";
          _os_log_impl(&dword_1830D4000, v10, v20, "%{public}s called with null advertise_descriptor", buf, 0xCu);
        }
LABEL_26:

        goto LABEL_27;
      }
      if (!v25)
      {
        uint64_t v10 = __nwlog_obj();
        os_log_type_t v24 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v28 = "nw_path_create_evaluator_for_advertise";
          _os_log_impl(&dword_1830D4000, v10, v24, "%{public}s called with null advertise_descriptor, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_26;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v10 = __nwlog_obj();
      os_log_type_t v22 = type;
      BOOL v23 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v28 = "nw_path_create_evaluator_for_advertise";
          _os_log_impl(&dword_1830D4000, v10, v22, "%{public}s called with null advertise_descriptor, no backtrace", buf, 0xCu);
        }
        goto LABEL_26;
      }
      if (v23)
      {
        *(_DWORD *)int buf = 136446466;
        os_log_type_t v28 = "nw_path_create_evaluator_for_advertise";
        __int16 v29 = 2082;
        os_log_type_t v30 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v10, v22, "%{public}s called with null advertise_descriptor, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
LABEL_27:
    if (!v9)
    {
LABEL_29:
      uint64_t v6 = 0;
      goto LABEL_30;
    }
LABEL_28:
    free(v9);
    goto LABEL_29;
  }
  uint64_t v6 = objc_alloc_init(NWConcrete_nw_path_evaluator);
  if (!v6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v8 = (id)gLogObj;
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v28 = "nw_path_create_evaluator_for_advertise";
    id v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (!__nwlog_fault(v9, &type, &v25)) {
      goto LABEL_27;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v10 = (id)gLogObj;
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v28 = "nw_path_create_evaluator_for_advertise";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed", buf, 0xCu);
      }
    }
    else if (v25)
    {
      id v14 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v10 = (id)gLogObj;
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v10, type);
      if (v14)
      {
        if (v16)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v28 = "nw_path_create_evaluator_for_advertise";
          __int16 v29 = 2082;
          os_log_type_t v30 = v14;
          _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v14);
        if (!v9) {
          goto LABEL_29;
        }
        goto LABEL_28;
      }
      if (v16)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v28 = "nw_path_create_evaluator_for_advertise";
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v10 = (id)gLogObj;
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v28 = "nw_path_create_evaluator_for_advertise";
        _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_26;
  }
  if (v5) {
    nw_parameters_t v7 = (nw_parameters_t)v5;
  }
  else {
    nw_parameters_t v7 = nw_parameters_create();
  }
  os_log_type_t v12 = (void *)*((void *)v6 + 1);
  *((void *)v6 + 1) = v7;

  objc_storeStrong((id *)v6 + 5, a1);
  if ((nw_path_evaluator_evaluate(v6, 0) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v13 = (id)gLogObj;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v28 = "nw_path_create_evaluator_for_advertise";
      _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_ERROR, "%{public}s nw_path_evaluator_evaluate failed", buf, 0xCu);
    }

    goto LABEL_29;
  }
LABEL_30:

  return v6;
}

void sub_183BA53BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_path_evaluator *nw_path_create_evaluator_for_custom_ether(void *a1, __int16 a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v4 = a1;
  if (!v4)
  {
    os_log_type_t v17 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    id v26 = "nw_path_create_evaluator_for_custom_ether";
    id v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v9, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v10 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)int buf = 136446210;
          id v26 = "nw_path_create_evaluator_for_custom_ether";
          _os_log_impl(&dword_1830D4000, v10, v18, "%{public}s called with null parameters", buf, 0xCu);
        }
LABEL_23:

        goto LABEL_24;
      }
      if (!v23)
      {
        uint64_t v10 = __nwlog_obj();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)int buf = 136446210;
          id v26 = "nw_path_create_evaluator_for_custom_ether";
          _os_log_impl(&dword_1830D4000, v10, v22, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_23;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v10 = __nwlog_obj();
      os_log_type_t v20 = type;
      BOOL v21 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)int buf = 136446210;
          id v26 = "nw_path_create_evaluator_for_custom_ether";
          _os_log_impl(&dword_1830D4000, v10, v20, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
        goto LABEL_23;
      }
      if (v21)
      {
        *(_DWORD *)int buf = 136446466;
        id v26 = "nw_path_create_evaluator_for_custom_ether";
        __int16 v27 = 2082;
        os_log_type_t v28 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v10, v20, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
LABEL_24:
    if (!v9)
    {
LABEL_26:
      uint64_t v6 = 0;
      goto LABEL_27;
    }
LABEL_25:
    free(v9);
    goto LABEL_26;
  }
  id v5 = objc_alloc_init(NWConcrete_nw_path_evaluator);
  uint64_t v6 = v5;
  if (!v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v8 = (id)gLogObj;
    *(_DWORD *)int buf = 136446210;
    id v26 = "nw_path_create_evaluator_for_custom_ether";
    id v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v9, &type, &v23)) {
      goto LABEL_24;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v10 = (id)gLogObj;
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v26 = "nw_path_create_evaluator_for_custom_ether";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed", buf, 0xCu);
      }
    }
    else if (v23)
    {
      os_log_type_t v12 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v10 = (id)gLogObj;
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (v12)
      {
        if (v14)
        {
          *(_DWORD *)int buf = 136446466;
          id v26 = "nw_path_create_evaluator_for_custom_ether";
          __int16 v27 = 2082;
          os_log_type_t v28 = v12;
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v12);
        if (!v9) {
          goto LABEL_26;
        }
        goto LABEL_25;
      }
      if (v14)
      {
        *(_DWORD *)int buf = 136446210;
        id v26 = "nw_path_create_evaluator_for_custom_ether";
        _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v10 = (id)gLogObj;
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v26 = "nw_path_create_evaluator_for_custom_ether";
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_23;
  }
  objc_storeStrong((id *)v5 + 1, a1);
  *((_WORD *)v6 + 52) = a2;
  if ((nw_path_evaluator_evaluate(v6, 0) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    nw_parameters_t v7 = (id)gLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      id v26 = "nw_path_create_evaluator_for_custom_ether";
      _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_ERROR, "%{public}s nw_path_evaluator_evaluate failed", buf, 0xCu);
    }

    goto LABEL_26;
  }
LABEL_27:

  return v6;
}

void sub_183BA59A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_path_evaluator *nw_path_create_evaluator_for_all_custom_ether_interfaces(void *a1)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  id v2 = a1;
  if (!v2)
  {
    os_log_type_t v15 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v24 = "nw_path_create_evaluator_for_all_custom_ether_interfaces";
    nw_parameters_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v7, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v8 = __nwlog_obj();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v24 = "nw_path_create_evaluator_for_all_custom_ether_interfaces";
          _os_log_impl(&dword_1830D4000, v8, v16, "%{public}s called with null parameters", buf, 0xCu);
        }
LABEL_23:

        goto LABEL_24;
      }
      if (!v21)
      {
        id v8 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v24 = "nw_path_create_evaluator_for_all_custom_ether_interfaces";
          _os_log_impl(&dword_1830D4000, v8, v20, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_23;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v8 = __nwlog_obj();
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v24 = "nw_path_create_evaluator_for_all_custom_ether_interfaces";
          _os_log_impl(&dword_1830D4000, v8, v18, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
        goto LABEL_23;
      }
      if (v19)
      {
        *(_DWORD *)int buf = 136446466;
        os_log_type_t v24 = "nw_path_create_evaluator_for_all_custom_ether_interfaces";
        __int16 v25 = 2082;
        id v26 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v8, v18, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
LABEL_24:
    if (!v7) {
      goto LABEL_26;
    }
LABEL_25:
    free(v7);
    goto LABEL_26;
  }
  id v3 = objc_alloc_init(NWConcrete_nw_path_evaluator);
  id v4 = v3;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v24 = "nw_path_create_evaluator_for_all_custom_ether_interfaces";
    nw_parameters_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (!__nwlog_fault(v7, &type, &v21)) {
      goto LABEL_24;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v8 = (id)gLogObj;
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v24 = "nw_path_create_evaluator_for_all_custom_ether_interfaces";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed", buf, 0xCu);
      }
    }
    else if (v21)
    {
      uint64_t v10 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v8 = (id)gLogObj;
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (v10)
      {
        if (v12)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v24 = "nw_path_create_evaluator_for_all_custom_ether_interfaces";
          __int16 v25 = 2082;
          id v26 = v10;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v10);
        if (!v7) {
          goto LABEL_26;
        }
        goto LABEL_25;
      }
      if (v12)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v24 = "nw_path_create_evaluator_for_all_custom_ether_interfaces";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v8 = (id)gLogObj;
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v24 = "nw_path_create_evaluator_for_all_custom_ether_interfaces";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_23;
  }
  objc_storeStrong((id *)v3 + 1, a1);
  *((unsigned char *)v4 + 107) |= 0xAu;
  if (nw_path_evaluator_evaluate(v4, 0)) {
    goto LABEL_27;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v5 = (id)gLogObj;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v24 = "nw_path_create_evaluator_for_all_custom_ether_interfaces";
    _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_ERROR, "%{public}s nw_path_evaluator_evaluate failed", buf, 0xCu);
  }

LABEL_26:
  id v4 = 0;
LABEL_27:

  return v4;
}

void sub_183BA5F98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_path_evaluator *nw_path_create_evaluator_for_custom_ip(void *a1, char a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v4 = a1;
  if (!v4)
  {
    os_log_type_t v17 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    id v26 = "nw_path_create_evaluator_for_custom_ip";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v9, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v10 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)int buf = 136446210;
          id v26 = "nw_path_create_evaluator_for_custom_ip";
          _os_log_impl(&dword_1830D4000, v10, v18, "%{public}s called with null parameters", buf, 0xCu);
        }
LABEL_23:

        goto LABEL_24;
      }
      if (!v23)
      {
        uint64_t v10 = __nwlog_obj();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)int buf = 136446210;
          id v26 = "nw_path_create_evaluator_for_custom_ip";
          _os_log_impl(&dword_1830D4000, v10, v22, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_23;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v10 = __nwlog_obj();
      os_log_type_t v20 = type;
      BOOL v21 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)int buf = 136446210;
          id v26 = "nw_path_create_evaluator_for_custom_ip";
          _os_log_impl(&dword_1830D4000, v10, v20, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
        goto LABEL_23;
      }
      if (v21)
      {
        *(_DWORD *)int buf = 136446466;
        id v26 = "nw_path_create_evaluator_for_custom_ip";
        __int16 v27 = 2082;
        os_log_type_t v28 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v10, v20, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
LABEL_24:
    if (!v9)
    {
LABEL_26:
      id v6 = 0;
      goto LABEL_27;
    }
LABEL_25:
    free(v9);
    goto LABEL_26;
  }
  id v5 = objc_alloc_init(NWConcrete_nw_path_evaluator);
  id v6 = v5;
  if (!v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v8 = (id)gLogObj;
    *(_DWORD *)int buf = 136446210;
    id v26 = "nw_path_create_evaluator_for_custom_ip";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v9, &type, &v23)) {
      goto LABEL_24;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v10 = (id)gLogObj;
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v26 = "nw_path_create_evaluator_for_custom_ip";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed", buf, 0xCu);
      }
    }
    else if (v23)
    {
      BOOL v12 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v10 = (id)gLogObj;
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (v12)
      {
        if (v14)
        {
          *(_DWORD *)int buf = 136446466;
          id v26 = "nw_path_create_evaluator_for_custom_ip";
          __int16 v27 = 2082;
          os_log_type_t v28 = v12;
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v12);
        if (!v9) {
          goto LABEL_26;
        }
        goto LABEL_25;
      }
      if (v14)
      {
        *(_DWORD *)int buf = 136446210;
        id v26 = "nw_path_create_evaluator_for_custom_ip";
        _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v10 = (id)gLogObj;
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v26 = "nw_path_create_evaluator_for_custom_ip";
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_23;
  }
  objc_storeStrong((id *)v5 + 1, a1);
  *((unsigned char *)v6 + 106) = a2;
  if ((nw_path_evaluator_evaluate(v6, 0) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    nw_parameters_t v7 = (id)gLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      id v26 = "nw_path_create_evaluator_for_custom_ip";
      _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_ERROR, "%{public}s nw_path_evaluator_evaluate failed", buf, 0xCu);
    }

    goto LABEL_26;
  }
LABEL_27:

  return v6;
}

void sub_183BA6578(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_path_evaluator *nw_path_create_evaluator_for_interpose(void *a1)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  id v2 = a1;
  if (!v2)
  {
    os_log_type_t v15 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v24 = "nw_path_create_evaluator_for_interpose";
    nw_parameters_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v7, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v8 = __nwlog_obj();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v24 = "nw_path_create_evaluator_for_interpose";
          _os_log_impl(&dword_1830D4000, v8, v16, "%{public}s called with null parameters", buf, 0xCu);
        }
LABEL_23:

        goto LABEL_24;
      }
      if (!v21)
      {
        id v8 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v24 = "nw_path_create_evaluator_for_interpose";
          _os_log_impl(&dword_1830D4000, v8, v20, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_23;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v8 = __nwlog_obj();
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v24 = "nw_path_create_evaluator_for_interpose";
          _os_log_impl(&dword_1830D4000, v8, v18, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
        goto LABEL_23;
      }
      if (v19)
      {
        *(_DWORD *)int buf = 136446466;
        os_log_type_t v24 = "nw_path_create_evaluator_for_interpose";
        __int16 v25 = 2082;
        id v26 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v8, v18, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
LABEL_24:
    if (!v7)
    {
LABEL_26:
      id v4 = 0;
      goto LABEL_27;
    }
LABEL_25:
    free(v7);
    goto LABEL_26;
  }
  id v3 = objc_alloc_init(NWConcrete_nw_path_evaluator);
  id v4 = v3;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v24 = "nw_path_create_evaluator_for_interpose";
    nw_parameters_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (!__nwlog_fault(v7, &type, &v21)) {
      goto LABEL_24;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v8 = (id)gLogObj;
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v24 = "nw_path_create_evaluator_for_interpose";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed", buf, 0xCu);
      }
    }
    else if (v21)
    {
      uint64_t v10 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v8 = (id)gLogObj;
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (v10)
      {
        if (v12)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v24 = "nw_path_create_evaluator_for_interpose";
          __int16 v25 = 2082;
          id v26 = v10;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v10);
        if (!v7) {
          goto LABEL_26;
        }
        goto LABEL_25;
      }
      if (v12)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v24 = "nw_path_create_evaluator_for_interpose";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v8 = (id)gLogObj;
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v24 = "nw_path_create_evaluator_for_interpose";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_23;
  }
  objc_storeStrong((id *)v3 + 1, a1);
  *((unsigned char *)v4 + 107) |= 6u;
  if ((nw_path_evaluator_evaluate(v4, 0) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v5 = (id)gLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v24 = "nw_path_create_evaluator_for_interpose";
      _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_ERROR, "%{public}s nw_path_evaluator_evaluate failed", buf, 0xCu);
    }

    goto LABEL_26;
  }
LABEL_27:

  return v4;
}

void sub_183BA6B5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_path_evaluator *nw_path_create_evaluator_for_client_id(const unsigned __int8 *a1, void *a2)
{
  uint64_t v85 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  if (!v3)
  {
    os_log_type_t v54 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v81 = "nw_path_create_evaluator_for_client_id";
    BOOL v55 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v84) = 0;
    if (!__nwlog_fault(v55, type, &v84)) {
      goto LABEL_147;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v56 = __nwlog_obj();
      os_log_type_t v57 = type[0];
      if (os_log_type_enabled(v56, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v81 = "nw_path_create_evaluator_for_client_id";
        _os_log_impl(&dword_1830D4000, v56, v57, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if ((_BYTE)v84)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v56 = __nwlog_obj();
      os_log_type_t v61 = type[0];
      BOOL v62 = os_log_type_enabled(v56, type[0]);
      if (backtrace_string)
      {
        if (v62)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v81 = "nw_path_create_evaluator_for_client_id";
          __int16 v82 = 2082;
          v83[0] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v56, v61, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (!v55) {
          goto LABEL_149;
        }
        goto LABEL_148;
      }
      if (v62)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v81 = "nw_path_create_evaluator_for_client_id";
        _os_log_impl(&dword_1830D4000, v56, v61, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v56 = __nwlog_obj();
      os_log_type_t v66 = type[0];
      if (os_log_type_enabled(v56, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v81 = "nw_path_create_evaluator_for_client_id";
        _os_log_impl(&dword_1830D4000, v56, v66, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_146;
  }
  if (uuid_is_null(a1))
  {
    char v58 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v81 = "nw_path_create_evaluator_for_client_id";
    BOOL v55 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v84) = 0;
    if (!__nwlog_fault(v55, type, &v84)) {
      goto LABEL_147;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v56 = __nwlog_obj();
      os_log_type_t v59 = type[0];
      if (os_log_type_enabled(v56, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v81 = "nw_path_create_evaluator_for_client_id";
        _os_log_impl(&dword_1830D4000, v56, v59, "%{public}s called with null !uuid_is_null(client_id)", buf, 0xCu);
      }
    }
    else if ((_BYTE)v84)
    {
      int v63 = (char *)__nw_create_backtrace_string();
      os_log_type_t v56 = __nwlog_obj();
      os_log_type_t v64 = type[0];
      BOOL v65 = os_log_type_enabled(v56, type[0]);
      if (v63)
      {
        if (v65)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v81 = "nw_path_create_evaluator_for_client_id";
          __int16 v82 = 2082;
          v83[0] = v63;
          _os_log_impl(&dword_1830D4000, v56, v64, "%{public}s called with null !uuid_is_null(client_id), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v63);
LABEL_147:
        if (!v55)
        {
LABEL_149:
          os_log_type_t v18 = 0;
          goto LABEL_93;
        }
LABEL_148:
        free(v55);
        goto LABEL_149;
      }
      if (v65)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v81 = "nw_path_create_evaluator_for_client_id";
        _os_log_impl(&dword_1830D4000, v56, v64, "%{public}s called with null !uuid_is_null(client_id), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v56 = __nwlog_obj();
      os_log_type_t v67 = type[0];
      if (os_log_type_enabled(v56, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v81 = "nw_path_create_evaluator_for_client_id";
        _os_log_impl(&dword_1830D4000, v56, v67, "%{public}s called with null !uuid_is_null(client_id), backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_146:

    goto LABEL_147;
  }
  id v4 = objc_alloc_init(NWConcrete_nw_path_evaluator);
  if (!v4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v10 = (id)gLogObj;
    *(_DWORD *)int buf = 136446210;
    BOOL v81 = "nw_path_create_evaluator_for_client_id";
    os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v84) = 0;
    if (!__nwlog_fault(v11, type, &v84)) {
      goto LABEL_89;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v12 = (id)gLogObj;
      os_log_type_t v13 = type[0];
      if (os_log_type_enabled(v12, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v81 = "nw_path_create_evaluator_for_client_id";
        _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed", buf, 0xCu);
      }
    }
    else if ((_BYTE)v84)
    {
      char v21 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v12 = (id)gLogObj;
      os_log_type_t v22 = type[0];
      BOOL v23 = os_log_type_enabled(v12, type[0]);
      if (v21)
      {
        if (v23)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v81 = "nw_path_create_evaluator_for_client_id";
          __int16 v82 = 2082;
          v83[0] = v21;
          _os_log_impl(&dword_1830D4000, v12, v22, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        goto LABEL_34;
      }
      if (v23)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v81 = "nw_path_create_evaluator_for_client_id";
        _os_log_impl(&dword_1830D4000, v12, v22, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v12 = (id)gLogObj;
      os_log_type_t v30 = type[0];
      if (os_log_type_enabled(v12, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v81 = "nw_path_create_evaluator_for_client_id";
        _os_log_impl(&dword_1830D4000, v12, v30, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_89;
  }
  nw_parameters_t v5 = nw_parameters_create();
  id v6 = (void *)*((void *)v4 + 1);
  *((void *)v4 + 1) = v5;

  nw_parameters_set_context(*((void **)v4 + 1), v3);
  nw_path_shared_necp_fd(v3);
  long long v84 = *(_OWORD *)a1;
  if (!necp_client_action())
  {
    *((_OWORD *)v4 + 5) = v84;
    bzero(buf, 0x400uLL);
    int v14 = necp_client_action();
    if (v14 < 1)
    {
      int v26 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v27 = (id)gLogObj;
      *(_DWORD *)os_log_type_t type = 136446466;
      int v77 = "nw_path_create_evaluator_for_client_id";
      __int16 v78 = 1024;
      LODWORD(v79[0]) = v26;
      os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

      LOBYTE(v75) = 16;
      LOBYTE(obj) = 0;
      if (__nwlog_fault(v11, &v75, &obj))
      {
        if (v75 == 17)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v28 = (id)gLogObj;
          os_log_type_t v29 = v75;
          if (os_log_type_enabled(v28, (os_log_type_t)v75))
          {
            *(_DWORD *)os_log_type_t type = 136446466;
            int v77 = "nw_path_create_evaluator_for_client_id";
            __int16 v78 = 1024;
            LODWORD(v79[0]) = v26;
            _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s NECP_CLIENT_ACTION_COPY_PARAMETERS %{darwin.errno}d", (uint8_t *)type, 0x12u);
          }
        }
        else if ((_BYTE)obj)
        {
          uint64_t v39 = (char *)__nw_create_backtrace_string();
          os_log_type_t v28 = __nwlog_obj();
          os_log_type_t v40 = v75;
          BOOL v41 = os_log_type_enabled(v28, (os_log_type_t)v75);
          if (v39)
          {
            if (v41)
            {
              *(_DWORD *)os_log_type_t type = 136446722;
              int v77 = "nw_path_create_evaluator_for_client_id";
              __int16 v78 = 1024;
              LODWORD(v79[0]) = v26;
              WORD2(v79[0]) = 2082;
              *(void *)((char *)v79 + 6) = v39;
              _os_log_impl(&dword_1830D4000, v28, v40, "%{public}s NECP_CLIENT_ACTION_COPY_PARAMETERS %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)type, 0x1Cu);
            }

            free(v39);
            if (!v11) {
              goto LABEL_91;
            }
            goto LABEL_90;
          }
          if (v41)
          {
            *(_DWORD *)os_log_type_t type = 136446466;
            int v77 = "nw_path_create_evaluator_for_client_id";
            __int16 v78 = 1024;
            LODWORD(v79[0]) = v26;
            _os_log_impl(&dword_1830D4000, v28, v40, "%{public}s NECP_CLIENT_ACTION_COPY_PARAMETERS %{darwin.errno}d, no backtrace", (uint8_t *)type, 0x12u);
          }
        }
        else
        {
          os_log_type_t v28 = __nwlog_obj();
          os_log_type_t v50 = v75;
          if (os_log_type_enabled(v28, (os_log_type_t)v75))
          {
            *(_DWORD *)os_log_type_t type = 136446466;
            int v77 = "nw_path_create_evaluator_for_client_id";
            __int16 v78 = 1024;
            LODWORD(v79[0]) = v26;
            _os_log_impl(&dword_1830D4000, v28, v50, "%{public}s NECP_CLIENT_ACTION_COPY_PARAMETERS %{darwin.errno}d, backtrace limit exceeded", (uint8_t *)type, 0x12u);
          }
        }
      }
      goto LABEL_89;
    }
    nw_parameters_t v15 = nw_parameters_create();
    nw_parameters_t v16 = v15;
    if (v15)
    {
      obuint64_t j = 0;
      id v75 = 0;
      id v73 = 0;
      char v72 = 0;
      __int16 v71 = 0;
      __int16 v70 = 0;
      if (nw_path_parse_necp_parameters(v15, &v75, &obj, &v73, 0, &v72, &v71, (char *)&v70 + 1, &v70, (uint64_t)buf, v14))
      {
        nw_parameters_set_context(v16, v3);
        objc_storeStrong((id *)v4 + 3, obj);
        objc_storeStrong((id *)v4 + 4, v73);
        objc_storeStrong((id *)v4 + 2, v75);
        objc_storeStrong((id *)v4 + 1, v16);
        char v17 = *((unsigned char *)v4 + 107) & 0xF9 | (2 * v72);
        *((_WORD *)v4 + 52) = v71;
        *((unsigned char *)v4 + 106) = HIBYTE(v70);
        *((unsigned char *)v4 + 107) = v17 | (4 * v70);
        if (nw_path_evaluator_evaluate(v4, 0))
        {
          os_log_type_t v18 = v4;
LABEL_112:

          goto LABEL_113;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v46 = (id)gLogObj;
        if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)os_log_type_t type = 136446210;
          int v77 = "nw_path_create_evaluator_for_client_id";
          _os_log_impl(&dword_1830D4000, v46, OS_LOG_TYPE_ERROR, "%{public}s nw_path_evaluator_evaluate failed", (uint8_t *)type, 0xCu);
        }

LABEL_111:
        os_log_type_t v18 = 0;
        goto LABEL_112;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v35 = (id)gLogObj;
      *(_DWORD *)os_log_type_t type = 136446210;
      int v77 = "nw_path_create_evaluator_for_client_id";
      double v36 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t v69 = OS_LOG_TYPE_ERROR;
      char v68 = 0;
      if (__nwlog_fault(v36, &v69, &v68))
      {
        if (v69 == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v37 = (id)gLogObj;
          os_log_type_t v38 = v69;
          if (os_log_type_enabled(v37, v69))
          {
            *(_DWORD *)os_log_type_t type = 136446210;
            int v77 = "nw_path_create_evaluator_for_client_id";
            _os_log_impl(&dword_1830D4000, v37, v38, "%{public}s nw_path_parse_necp_parameters failed", (uint8_t *)type, 0xCu);
          }
        }
        else if (v68)
        {
          os_log_type_t v47 = (char *)__nw_create_backtrace_string();
          __int16 v37 = __nwlog_obj();
          os_log_type_t v48 = v69;
          BOOL v49 = os_log_type_enabled(v37, v69);
          if (v47)
          {
            if (v49)
            {
              *(_DWORD *)os_log_type_t type = 136446466;
              int v77 = "nw_path_create_evaluator_for_client_id";
              __int16 v78 = 2082;
              v79[0] = v47;
              _os_log_impl(&dword_1830D4000, v37, v48, "%{public}s nw_path_parse_necp_parameters failed, dumping backtrace:%{public}s", (uint8_t *)type, 0x16u);
            }

            free(v47);
            goto LABEL_109;
          }
          if (v49)
          {
            *(_DWORD *)os_log_type_t type = 136446210;
            int v77 = "nw_path_create_evaluator_for_client_id";
            _os_log_impl(&dword_1830D4000, v37, v48, "%{public}s nw_path_parse_necp_parameters failed, no backtrace", (uint8_t *)type, 0xCu);
          }
        }
        else
        {
          __int16 v37 = __nwlog_obj();
          os_log_type_t v53 = v69;
          if (os_log_type_enabled(v37, v69))
          {
            *(_DWORD *)os_log_type_t type = 136446210;
            int v77 = "nw_path_create_evaluator_for_client_id";
            _os_log_impl(&dword_1830D4000, v37, v53, "%{public}s nw_path_parse_necp_parameters failed, backtrace limit exceeded", (uint8_t *)type, 0xCu);
          }
        }
      }
LABEL_109:
      if (v36) {
        free(v36);
      }
      goto LABEL_111;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v31 = (id)gLogObj;
    *(_DWORD *)os_log_type_t type = 136446210;
    int v77 = "nw_path_create_evaluator_for_client_id";
    os_log_type_t v32 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v75) = 16;
    LOBYTE(obj) = 0;
    if (__nwlog_fault(v32, &v75, &obj))
    {
      if (v75 == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v33 = (id)gLogObj;
        os_log_type_t v34 = v75;
        if (os_log_type_enabled(v33, (os_log_type_t)v75))
        {
          *(_DWORD *)os_log_type_t type = 136446210;
          int v77 = "nw_path_create_evaluator_for_client_id";
          _os_log_impl(&dword_1830D4000, v33, v34, "%{public}s nw_parameters_create failed", (uint8_t *)type, 0xCu);
        }
      }
      else if ((_BYTE)obj)
      {
        id v43 = (char *)__nw_create_backtrace_string();
        char v33 = __nwlog_obj();
        os_log_type_t v44 = v75;
        BOOL v45 = os_log_type_enabled(v33, (os_log_type_t)v75);
        if (v43)
        {
          if (v45)
          {
            *(_DWORD *)os_log_type_t type = 136446466;
            int v77 = "nw_path_create_evaluator_for_client_id";
            __int16 v78 = 2082;
            v79[0] = v43;
            _os_log_impl(&dword_1830D4000, v33, v44, "%{public}s nw_parameters_create failed, dumping backtrace:%{public}s", (uint8_t *)type, 0x16u);
          }

          free(v43);
          if (!v32) {
            goto LABEL_105;
          }
          goto LABEL_104;
        }
        if (v45)
        {
          *(_DWORD *)os_log_type_t type = 136446210;
          int v77 = "nw_path_create_evaluator_for_client_id";
          _os_log_impl(&dword_1830D4000, v33, v44, "%{public}s nw_parameters_create failed, no backtrace", (uint8_t *)type, 0xCu);
        }
      }
      else
      {
        char v33 = __nwlog_obj();
        os_log_type_t v52 = v75;
        if (os_log_type_enabled(v33, (os_log_type_t)v75))
        {
          *(_DWORD *)os_log_type_t type = 136446210;
          int v77 = "nw_path_create_evaluator_for_client_id";
          _os_log_impl(&dword_1830D4000, v33, v52, "%{public}s nw_parameters_create failed, backtrace limit exceeded", (uint8_t *)type, 0xCu);
        }
      }
    }
    if (!v32)
    {
LABEL_105:
      os_log_type_t v18 = 0;
LABEL_113:

      goto LABEL_92;
    }
LABEL_104:
    free(v32);
    goto LABEL_105;
  }
  int v7 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v8 = (id)gLogObj;
  os_log_type_t v9 = v8;
  if (v7 == 2)
  {
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446466;
      BOOL v81 = "nw_path_create_evaluator_for_client_id";
      __int16 v82 = 1024;
      LODWORD(v83[0]) = 2;
      _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_ERROR, "%{public}s NECP_CLIENT_ACTION_CLAIM %{darwin.errno}d", buf, 0x12u);
    }

    goto LABEL_91;
  }
  *(_DWORD *)int buf = 136446466;
  BOOL v81 = "nw_path_create_evaluator_for_client_id";
  __int16 v82 = 1024;
  LODWORD(v83[0]) = v7;
  os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v75) = 0;
  if (__nwlog_fault(v11, type, &v75))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v19 = (id)gLogObj;
      os_log_type_t v20 = type[0];
      if (os_log_type_enabled(v19, type[0]))
      {
        *(_DWORD *)int buf = 136446466;
        BOOL v81 = "nw_path_create_evaluator_for_client_id";
        __int16 v82 = 1024;
        LODWORD(v83[0]) = v7;
        _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s NECP_CLIENT_ACTION_CLAIM %{darwin.errno}d", buf, 0x12u);
      }
LABEL_77:

      goto LABEL_89;
    }
    if (!(_BYTE)v75)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v19 = (id)gLogObj;
      os_log_type_t v42 = type[0];
      if (os_log_type_enabled(v19, type[0]))
      {
        *(_DWORD *)int buf = 136446466;
        BOOL v81 = "nw_path_create_evaluator_for_client_id";
        __int16 v82 = 1024;
        LODWORD(v83[0]) = v7;
        _os_log_impl(&dword_1830D4000, v19, v42, "%{public}s NECP_CLIENT_ACTION_CLAIM %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
      }
      goto LABEL_77;
    }
    char v21 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v19 = (id)gLogObj;
    os_log_type_t v24 = type[0];
    BOOL v25 = os_log_type_enabled(v19, type[0]);
    if (!v21)
    {
      if (v25)
      {
        *(_DWORD *)int buf = 136446466;
        BOOL v81 = "nw_path_create_evaluator_for_client_id";
        __int16 v82 = 1024;
        LODWORD(v83[0]) = v7;
        _os_log_impl(&dword_1830D4000, v19, v24, "%{public}s NECP_CLIENT_ACTION_CLAIM %{darwin.errno}d, no backtrace", buf, 0x12u);
      }
      goto LABEL_77;
    }
    if (v25)
    {
      *(_DWORD *)int buf = 136446722;
      BOOL v81 = "nw_path_create_evaluator_for_client_id";
      __int16 v82 = 1024;
      LODWORD(v83[0]) = v7;
      WORD2(v83[0]) = 2082;
      *(void *)((char *)v83 + 6) = v21;
      _os_log_impl(&dword_1830D4000, v19, v24, "%{public}s NECP_CLIENT_ACTION_CLAIM %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
    }

LABEL_34:
    free(v21);
    if (!v11) {
      goto LABEL_91;
    }
    goto LABEL_90;
  }
LABEL_89:
  if (v11) {
LABEL_90:
  }
    free(v11);
LABEL_91:
  os_log_type_t v18 = 0;
LABEL_92:

LABEL_93:
  return v18;
}

void sub_183BA7F2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_path_evaluator *nw_path_create_default_evaluator()
{
  return nw_path_create_evaluator_for_endpoint(0, 0);
}

void nw_path_libinfo_path_check(const char *a1, const char *a2)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
  if (sNWIsBetweenForkAndExec != 1 || (sNWParentAllowedDispatch & 1) == 0)
  {
    if (sNWDispatchAllowedNow)
    {
      int v4 = 1;
      if (!a1) {
        return;
      }
    }
    else if ((_dispatch_is_fork_of_multithreaded_parent() & 1) == 0 && (_dispatch_is_multithreaded() & 1) != 0 {
           || (getpid(), sandbox_check() == 1))
    }
    {
      int v4 = 1;
      sNWDispatchAllowedNow = 1;
      if (!a1) {
        return;
      }
    }
    else
    {
      int v4 = sNWDispatchAllowedNow;
      if (!a1) {
        return;
      }
    }
    if (v4)
    {
      if (a2) {
        nw_parameters_t v5 = a2;
      }
      else {
        nw_parameters_t v5 = "0";
      }
      *(_WORD *)int buf = 0;
      if (nw_utilities_port_for_string(v5, buf))
      {
        BOOL host_with_numeric_port = nw_endpoint_create_host_with_numeric_port(a1, bswap32(*(unsigned __int16 *)buf) >> 16);
        if (host_with_numeric_port)
        {
          legacy_tcp_socket = nw_parameters_create_legacy_tcp_socket(&__block_literal_global_98);
          evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint((void *)host_with_numeric_port, legacy_tcp_socket);
          os_log_type_t v9 = evaluator_for_endpoint;
          if (evaluator_for_endpoint)
          {
            id v10 = nw_parameters_copy_context(*((void **)evaluator_for_endpoint + 1));
            nw_path_watch_necp_changes(v10);
            os_unfair_lock_lock((os_unfair_lock_t)v9 + 24);
            if ((*((unsigned char *)v9 + 107) & 0x40) != 0 && (!v10 || v10[31] != 4))
            {
              if (__nwlog_path_log::onceToken != -1) {
                dispatch_once(&__nwlog_path_log::onceToken, &__block_literal_global_48_44893);
              }
              os_log_type_t v11 = (id)gpathLogObj;
              if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
              {
                logging_description = nw_endpoint_get_logging_description(*((void **)v9 + 2));
                uint64_t v13 = *((void *)v9 + 1);
                uint64_t v14 = *((void *)v9 + 6);
                *(_DWORD *)int buf = 136447490;
                int v26 = "nw_path_libinfo_path_check";
                __int16 v27 = 1042;
                *(_DWORD *)os_log_type_t v28 = 16;
                *(_WORD *)&v28[4] = 2098;
                *(void *)&v28[6] = (char *)v9 + 80;
                __int16 v29 = 2082;
                os_log_type_t v30 = logging_description;
                __int16 v31 = 2112;
                uint64_t v32 = v13;
                __int16 v33 = 2112;
                uint64_t v34 = v14;
                _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_DEFAULT, "%{public}s [%{public,uuid_t}.16P %{public}s %@]\n\tlibinfo check path: %@", buf, 0x3Au);
              }
            }
            os_unfair_lock_unlock((os_unfair_lock_t)v9 + 24);
          }
          goto LABEL_37;
        }
      }
      nw_parameters_t v15 = __nwlog_obj();
      *(_DWORD *)int buf = 136446210;
      int v26 = "nw_path_libinfo_path_check";
      nw_parameters_t v16 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v23 = 0;
      if (__nwlog_fault(v16, &type, &v23))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          char v17 = __nwlog_obj();
          os_log_type_t v18 = type;
          if (os_log_type_enabled(v17, type))
          {
            *(_DWORD *)int buf = 136446210;
            int v26 = "nw_path_libinfo_path_check";
            _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s called with null endpoint", buf, 0xCu);
          }
        }
        else if (v23)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          char v17 = __nwlog_obj();
          os_log_type_t v20 = type;
          BOOL v21 = os_log_type_enabled(v17, type);
          if (backtrace_string)
          {
            if (v21)
            {
              *(_DWORD *)int buf = 136446466;
              int v26 = "nw_path_libinfo_path_check";
              __int16 v27 = 2082;
              *(void *)os_log_type_t v28 = backtrace_string;
              _os_log_impl(&dword_1830D4000, v17, v20, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            if (!v16) {
              goto LABEL_36;
            }
            goto LABEL_35;
          }
          if (v21)
          {
            *(_DWORD *)int buf = 136446210;
            int v26 = "nw_path_libinfo_path_check";
            _os_log_impl(&dword_1830D4000, v17, v20, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          char v17 = __nwlog_obj();
          os_log_type_t v22 = type;
          if (os_log_type_enabled(v17, type))
          {
            *(_DWORD *)int buf = 136446210;
            int v26 = "nw_path_libinfo_path_check";
            _os_log_impl(&dword_1830D4000, v17, v22, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }
      if (!v16)
      {
LABEL_36:
        BOOL host_with_numeric_port = 0;
LABEL_37:

        return;
      }
LABEL_35:
      free(v16);
      goto LABEL_36;
    }
  }
}

void sub_183BA842C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL30nw_path_necp_check_for_updatesPU24objcproto13OS_nw_context8NSObjectPA16_hj_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  int v4 = a3;
  nw_parameters_t v5 = v4;
  if (v4)
  {
    id v6 = *(void **)(a1 + 40);
    if (*((void *)v4 + 10) == *v6 && *((void *)v4 + 11) == v6[1])
    {
      nw_path_necp_update_evaluator(v4, *(const unsigned __int8 **)(a1 + 48), *(int *)(a1 + 56), *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
    }
  }

  return 1;
}

void sub_183BA84F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL29nw_path_necp_update_evaluatorP28NWConcrete_nw_path_evaluatorPKhmb_block_invoke(uint64_t a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v2 = *(os_unfair_lock_s **)(a1 + 32);
  id v3 = v2 + 24;
  int v4 = v2;
  os_unfair_lock_lock(v3);
  char os_unfair_lock_opaque_high = HIBYTE(v4[26]._os_unfair_lock_opaque);
  os_unfair_lock_unlock(v3);

  if ((os_unfair_lock_opaque_high & 0x20) == 0)
  {
    if ((*(unsigned char *)(*(void *)(a1 + 32) + 107) & 0x40) != 0 && *(unsigned char *)(a1 + 56))
    {
      if (__nwlog_path_log::onceToken != -1) {
        dispatch_once(&__nwlog_path_log::onceToken, &__block_literal_global_48_44893);
      }
      id v6 = (id)gpathLogObj;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
      {
        uint64_t v7 = *(void *)(a1 + 32);
        logging_description = nw_endpoint_get_logging_description(*(void **)(v7 + 16));
        uint64_t v9 = *(void *)(a1 + 40);
        uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 8);
        int v11 = 136447490;
        BOOL v12 = "nw_path_necp_update_evaluator_block_invoke";
        __int16 v13 = 1042;
        int v14 = 16;
        __int16 v15 = 2098;
        uint64_t v16 = v7 + 80;
        __int16 v17 = 2082;
        os_log_type_t v18 = logging_description;
        __int16 v19 = 2112;
        uint64_t v20 = v10;
        __int16 v21 = 2112;
        uint64_t v22 = v9;
        _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_INFO, "%{public}s [%{public,uuid_t}.16P %{public}s %@]\n\tpath: %@", (uint8_t *)&v11, 0x3Au);
      }
    }
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
}

void sub_183BA868C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_path_flow_is_equal(void *a1, void *a2)
{
  id v3 = a1;
  int v4 = a2;
  nw_parameters_t v5 = v4;
  BOOL v6 = v3 == v4;
  if (v3 != v4 && v3 && v4) {
    BOOL v6 = ((*((unsigned char *)v4 + 185) ^ *((unsigned char *)v3 + 185)) & 3) == 0
  }
      && *((_DWORD *)v3 + 42) == *((_DWORD *)v4 + 42)
      && (v3[10] == v4[10] ? (BOOL v7 = v3[11] == v4[11]) : (BOOL v7 = 0),
          v7 ? (BOOL v8 = *((unsigned int *)v3 + 24) == (unint64_t)*((unsigned int *)v4 + 24)) : (BOOL v8 = 0),
          v8
       && (v3[16] == v4[16] ? (BOOL v9 = v3[17] == v4[17]) : (BOOL v9 = 0),
           v9
        && nw_interface_shallow_compare(v3[2], v4[2])
        && nw_endpoint_is_equal(v3[4], v5[4], 31)
        && nw_endpoint_is_equal(v3[5], v5[5], 31)
        && nw_buffer_is_equal((const char *)v3[1], *((unsigned int *)v3 + 40), (const char *)v5[1], *((unsigned int *)v5 + 40))&& (unsigned int v10 = *((unsigned __int8 *)v5 + 185) ^ *((unsigned __int8 *)v3 + 185), (v10 & 0xC) == 0)&& *((unsigned __int8 *)v3 + 184) == *((unsigned __int8 *)v5 + 184)))&& *(void **)((char *)v3 + 108) == *(void **)((char *)v5 + 108)&& *(void **)((char *)v3 + 116) == *(void **)((char *)v5 + 116)&& v10 < 0x10;

  return v6;
}

void sub_183BA87EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_buffer_is_equal(const char *__s1, size_t __n, const char *__s2, uint64_t a4)
{
  if (__n != a4) {
    return 0;
  }
  BOOL v5 = __s1 == __s2;
  BOOL result = __s1 == __s2;
  if (!v5 && __s1 && __s2) {
    return !__n || memcmp(__s1, __s2, __n) == 0;
  }
  return result;
}

xpc_object_t nw_path_copy_all_client_ids()
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (nw_context_copy_implicit_context::onceToken != -1) {
    dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
  }
  id v0 = (id)nw_context_copy_implicit_context::implicit_context;
  int v1 = nw_path_shared_necp_observer_fd(v0);

  if (v1 < 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v7 = (id)gLogObj;
    *(_DWORD *)int buf = 136446210;
    uint64_t v23 = "nw_path_copy_all_client_ids";
    int v4 = (char *)_os_log_send_and_compose_impl();

    v20[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if ((__nwlog_fault(v4, v20, &type) & 1) == 0) {
      goto LABEL_40;
    }
    if (v20[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v8 = (id)gLogObj;
      os_log_type_t v9 = v20[0];
      if (os_log_type_enabled(v8, v20[0]))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v23 = "nw_path_copy_all_client_ids";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s nw_path_shared_necp_observer_fd failed", buf, 0xCu);
      }
    }
    else if (type)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v8 = (id)gLogObj;
      os_log_type_t v13 = v20[0];
      BOOL v14 = os_log_type_enabled(v8, v20[0]);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v23 = "nw_path_copy_all_client_ids";
          __int16 v24 = 2082;
          *(void *)BOOL v25 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s nw_path_shared_necp_observer_fd failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        goto LABEL_26;
      }
      if (v14)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v23 = "nw_path_copy_all_client_ids";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s nw_path_shared_necp_observer_fd failed, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v8 = (id)gLogObj;
      os_log_type_t v17 = v20[0];
      if (os_log_type_enabled(v8, v20[0]))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v23 = "nw_path_copy_all_client_ids";
        _os_log_impl(&dword_1830D4000, v8, v17, "%{public}s nw_path_shared_necp_observer_fd failed, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_40:
    if (!v4) {
      return 0;
    }
LABEL_41:
    free(v4);
    return 0;
  }
  *(_DWORD *)uint64_t v20 = 0;
  if (necp_client_action())
  {
    int v2 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v3 = (id)gLogObj;
    *(_DWORD *)int buf = 136446466;
    uint64_t v23 = "nw_path_copy_all_client_ids";
    __int16 v24 = 1024;
    *(_DWORD *)BOOL v25 = v2;
    int v4 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (!__nwlog_fault(v4, &type, &v19)) {
      goto LABEL_40;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v5 = (id)gLogObj;
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446466;
        uint64_t v23 = "nw_path_copy_all_client_ids";
        __int16 v24 = 1024;
        *(_DWORD *)BOOL v25 = v2;
        _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s NECP_CLIENT_ACTION_COPY_LIST %{darwin.errno}d", buf, 0x12u);
      }
LABEL_36:

      goto LABEL_40;
    }
    if (!v19)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v5 = (id)gLogObj;
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446466;
        uint64_t v23 = "nw_path_copy_all_client_ids";
        __int16 v24 = 1024;
        *(_DWORD *)BOOL v25 = v2;
        _os_log_impl(&dword_1830D4000, v5, v16, "%{public}s NECP_CLIENT_ACTION_COPY_LIST %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
      }
      goto LABEL_36;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v5 = (id)gLogObj;
    os_log_type_t v11 = type;
    BOOL v12 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)int buf = 136446466;
        uint64_t v23 = "nw_path_copy_all_client_ids";
        __int16 v24 = 1024;
        *(_DWORD *)BOOL v25 = v2;
        _os_log_impl(&dword_1830D4000, v5, v11, "%{public}s NECP_CLIENT_ACTION_COPY_LIST %{darwin.errno}d, no backtrace", buf, 0x12u);
      }
      goto LABEL_36;
    }
    if (v12)
    {
      *(_DWORD *)int buf = 136446722;
      uint64_t v23 = "nw_path_copy_all_client_ids";
      __int16 v24 = 1024;
      *(_DWORD *)BOOL v25 = v2;
      *(_WORD *)&v25[4] = 2082;
      *(void *)&v25[6] = backtrace_string;
      _os_log_impl(&dword_1830D4000, v5, v11, "%{public}s NECP_CLIENT_ACTION_COPY_LIST %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
    }

LABEL_26:
    free(backtrace_string);
    if (!v4) {
      return 0;
    }
    goto LABEL_41;
  }
  return xpc_array_create(0, 0);
}

void sub_183BA953C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_path *nw_path_create_browse(void *a1, void *a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  id v4 = a1;
  id v5 = a2;
  os_log_type_t v6 = objc_alloc_init(NWConcrete_nw_path);
  id v7 = v6;
  if (!v6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v8 = (id)gLogObj;
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v28 = "nw_path_create_browse";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (!__nwlog_fault(v9, &type, &v25)) {
      goto LABEL_39;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unsigned int v10 = (id)gLogObj;
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v28 = "nw_path_create_browse";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path) alloc] init] failed", buf, 0xCu);
      }
      goto LABEL_38;
    }
    if (!v25)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unsigned int v10 = (id)gLogObj;
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v28 = "nw_path_create_browse";
        _os_log_impl(&dword_1830D4000, v10, v20, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path) alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_38;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v10 = (id)gLogObj;
    os_log_type_t v16 = type;
    BOOL v17 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v28 = "nw_path_create_browse";
        _os_log_impl(&dword_1830D4000, v10, v16, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path) alloc] init] failed, no backtrace", buf, 0xCu);
      }
      goto LABEL_38;
    }
    if (v17)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v28 = "nw_path_create_browse";
      __int16 v29 = 2082;
      os_log_type_t v30 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v10, v16, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path) alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_15;
  }
  if (!v5)
  {
    nw_parameters_t v12 = nw_parameters_create();
    parameters = v7->parameters;
    v7->parameters = (OS_nw_parameters *)v12;

    if (v7->parameters) {
      goto LABEL_10;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v18 = (id)gLogObj;
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v28 = "nw_path_create_browse";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (!__nwlog_fault(v9, &type, &v25))
    {
LABEL_39:
      if (!v9)
      {
LABEL_41:
        BOOL v14 = 0;
        goto LABEL_42;
      }
LABEL_40:
      free(v9);
      goto LABEL_41;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unsigned int v10 = (id)gLogObj;
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v28 = "nw_path_create_browse";
        _os_log_impl(&dword_1830D4000, v10, v19, "%{public}s nw_parameters_create failed", buf, 0xCu);
      }
LABEL_38:

      goto LABEL_39;
    }
    if (!v25)
    {
      unsigned int v10 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v28 = "nw_path_create_browse";
        _os_log_impl(&dword_1830D4000, v10, v23, "%{public}s nw_parameters_create failed, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_38;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    unsigned int v10 = __nwlog_obj();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v22)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v28 = "nw_path_create_browse";
        _os_log_impl(&dword_1830D4000, v10, v21, "%{public}s nw_parameters_create failed, no backtrace", buf, 0xCu);
      }
      goto LABEL_38;
    }
    if (v22)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v28 = "nw_path_create_browse";
      __int16 v29 = 2082;
      os_log_type_t v30 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v10, v21, "%{public}s nw_parameters_create failed, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_15:

    free(backtrace_string);
    if (!v9) {
      goto LABEL_41;
    }
    goto LABEL_40;
  }
  objc_storeStrong((id *)&v6->parameters, a2);
LABEL_10:
  objc_storeStrong((id *)&v7->browse_descriptor, a1);
  BOOL v14 = v7;
LABEL_42:

  return v14;
}

void sub_183BA9B14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_path_observer *nw_path_create_observer(void *a1, void *a2)
{
  *(void *)&v57[13] = *MEMORY[0x1E4F143B8];
  id v4 = a1;
  id v5 = a2;
  nw_allow_use_of_dispatch_internal();
  if (v5)
  {
    os_log_type_t v6 = objc_alloc_init(NWConcrete_nw_path_observer);
    if (v6)
    {
      int v7 = necp_open();
      if ((v7 & 0x80000000) == 0)
      {
        id v8 = _Block_copy(v5);
        os_log_type_t v9 = (void *)*((void *)v6 + 2);
        *((void *)v6 + 2) = v8;

        objc_storeStrong((id *)v6 + 1, a1);
        unsigned int v10 = nw_dictionary_create();
        os_log_type_t v11 = (void *)*((void *)v6 + 3);
        *((void *)v6 + 3) = v10;

        nw_parameters_t v12 = nw_fd_wrapper_create(v7);
        os_log_type_t v13 = (void *)*((void *)v6 + 4);
        *((void *)v6 + 4) = v12;

        BOOL v14 = (void *)*((void *)v6 + 4);
        if (v14)
        {
          nw_fd_wrapper_guard(v14);
          if (nw_context_copy_implicit_context::onceToken != -1) {
            dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
          }
          id v15 = (id)nw_context_copy_implicit_context::implicit_context;
          v50[0] = MEMORY[0x1E4F143A8];
          v50[1] = 3221225472;
          v50[2] = __nw_path_create_observer_block_invoke;
          v50[3] = &unk_1E524BAA8;
          os_log_type_t v16 = v6;
          os_log_type_t v51 = v16;
          *((void *)v16 + 5) = nw_queue_context_create_source(v15, v7, 1, 0, v50, 0);

          uint64_t v17 = *((void *)v16 + 5);
          if (v17)
          {
            nw_queue_activate_source(v17);
            id v18 = v16;
LABEL_65:

            goto LABEL_66;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v31 = (id)gLogObj;
          *(_DWORD *)int buf = 136446210;
          BOOL v55 = "nw_path_create_observer";
          uint64_t v32 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v52 = 0;
          if (__nwlog_fault(v32, &type, &v52))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              __int16 v33 = (id)gLogObj;
              os_log_type_t v34 = type;
              if (os_log_type_enabled(v33, type))
              {
                *(_DWORD *)int buf = 136446210;
                BOOL v55 = "nw_path_create_observer";
                _os_log_impl(&dword_1830D4000, v33, v34, "%{public}s nw_queue_context_create_source failed", buf, 0xCu);
              }
            }
            else if (v52)
            {
              backtrace_string = (char *)__nw_create_backtrace_string();
              __int16 v33 = __nwlog_obj();
              os_log_type_t v37 = type;
              BOOL v38 = os_log_type_enabled(v33, type);
              if (backtrace_string)
              {
                if (v38)
                {
                  *(_DWORD *)int buf = 136446466;
                  BOOL v55 = "nw_path_create_observer";
                  __int16 v56 = 2082;
                  *(void *)os_log_type_t v57 = backtrace_string;
                  _os_log_impl(&dword_1830D4000, v33, v37, "%{public}s nw_queue_context_create_source failed, dumping backtrace:%{public}s", buf, 0x16u);
                }

                free(backtrace_string);
                if (!v32) {
                  goto LABEL_64;
                }
                goto LABEL_63;
              }
              if (v38)
              {
                *(_DWORD *)int buf = 136446210;
                BOOL v55 = "nw_path_create_observer";
                _os_log_impl(&dword_1830D4000, v33, v37, "%{public}s nw_queue_context_create_source failed, no backtrace", buf, 0xCu);
              }
            }
            else
            {
              __int16 v33 = __nwlog_obj();
              os_log_type_t v40 = type;
              if (os_log_type_enabled(v33, type))
              {
                *(_DWORD *)int buf = 136446210;
                BOOL v55 = "nw_path_create_observer";
                _os_log_impl(&dword_1830D4000, v33, v40, "%{public}s nw_queue_context_create_source failed, backtrace limit exceeded", buf, 0xCu);
              }
            }
          }
          if (!v32)
          {
LABEL_64:
            id v18 = 0;
            goto LABEL_65;
          }
LABEL_63:
          free(v32);
          goto LABEL_64;
        }
LABEL_55:
        id v18 = 0;
LABEL_66:

        goto LABEL_67;
      }
      int v23 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v24 = (id)gLogObj;
      *(_DWORD *)int buf = 136446466;
      BOOL v55 = "nw_path_create_observer";
      __int16 v56 = 1024;
      *(_DWORD *)os_log_type_t v57 = v23;
      os_log_type_t v20 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v52 = 0;
      if (!__nwlog_fault(v20, &type, &v52)) {
        goto LABEL_53;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v21 = (id)gLogObj;
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v55 = "nw_path_create_observer";
          __int16 v56 = 1024;
          *(_DWORD *)os_log_type_t v57 = v23;
          _os_log_impl(&dword_1830D4000, v21, v25, "%{public}s necp_open(NECP_OPEN_FLAG_OBSERVER | NECP_OPEN_FLAG_PUSH_OBSERVER) %{darwin.errno}d", buf, 0x12u);
        }
LABEL_52:

LABEL_53:
        if (!v20) {
          goto LABEL_55;
        }
LABEL_54:
        free(v20);
        goto LABEL_55;
      }
      if (!v52)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v21 = (id)gLogObj;
        os_log_type_t v39 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v55 = "nw_path_create_observer";
          __int16 v56 = 1024;
          *(_DWORD *)os_log_type_t v57 = v23;
          _os_log_impl(&dword_1830D4000, v21, v39, "%{public}s necp_open(NECP_OPEN_FLAG_OBSERVER | NECP_OPEN_FLAG_PUSH_OBSERVER) %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
        }
        goto LABEL_52;
      }
      uint64_t v26 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v21 = (id)gLogObj;
      os_log_type_t v29 = type;
      BOOL v30 = os_log_type_enabled(v21, type);
      if (!v26)
      {
        if (v30)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v55 = "nw_path_create_observer";
          __int16 v56 = 1024;
          *(_DWORD *)os_log_type_t v57 = v23;
          _os_log_impl(&dword_1830D4000, v21, v29, "%{public}s necp_open(NECP_OPEN_FLAG_OBSERVER | NECP_OPEN_FLAG_PUSH_OBSERVER) %{darwin.errno}d, no backtrace", buf, 0x12u);
        }
        goto LABEL_52;
      }
      if (v30)
      {
        *(_DWORD *)int buf = 136446722;
        BOOL v55 = "nw_path_create_observer";
        __int16 v56 = 1024;
        *(_DWORD *)os_log_type_t v57 = v23;
        v57[2] = 2082;
        *(void *)&v57[3] = v26;
        _os_log_impl(&dword_1830D4000, v21, v29, "%{public}s necp_open(NECP_OPEN_FLAG_OBSERVER | NECP_OPEN_FLAG_PUSH_OBSERVER) %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v19 = (id)gLogObj;
      *(_DWORD *)int buf = 136446210;
      BOOL v55 = "nw_path_create_observer";
      os_log_type_t v20 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v52 = 0;
      if (!__nwlog_fault(v20, &type, &v52)) {
        goto LABEL_53;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v21 = (id)gLogObj;
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v55 = "nw_path_create_observer";
          _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_observer) alloc] init] failed", buf, 0xCu);
        }
        goto LABEL_52;
      }
      if (!v52)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v21 = (id)gLogObj;
        os_log_type_t v35 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v55 = "nw_path_create_observer";
          _os_log_impl(&dword_1830D4000, v21, v35, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_observer) alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_52;
      }
      uint64_t v26 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v21 = (id)gLogObj;
      os_log_type_t v27 = type;
      BOOL v28 = os_log_type_enabled(v21, type);
      if (!v26)
      {
        if (v28)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v55 = "nw_path_create_observer";
          _os_log_impl(&dword_1830D4000, v21, v27, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_observer) alloc] init] failed, no backtrace", buf, 0xCu);
        }
        goto LABEL_52;
      }
      if (v28)
      {
        *(_DWORD *)int buf = 136446466;
        BOOL v55 = "nw_path_create_observer";
        __int16 v56 = 2082;
        *(void *)os_log_type_t v57 = v26;
        _os_log_impl(&dword_1830D4000, v21, v27, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_observer) alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
      }
    }

    free(v26);
    if (!v20) {
      goto LABEL_55;
    }
    goto LABEL_54;
  }
  os_log_type_t v42 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  BOOL v55 = "nw_path_create_observer";
  id v43 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v52 = 0;
  if (__nwlog_fault(v43, &type, &v52))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v44 = __nwlog_obj();
      os_log_type_t v45 = type;
      if (os_log_type_enabled(v44, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v55 = "nw_path_create_observer";
        _os_log_impl(&dword_1830D4000, v44, v45, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v52)
    {
      os_log_type_t v46 = (char *)__nw_create_backtrace_string();
      os_log_type_t v44 = __nwlog_obj();
      os_log_type_t v47 = type;
      BOOL v48 = os_log_type_enabled(v44, type);
      if (v46)
      {
        if (v48)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v55 = "nw_path_create_observer";
          __int16 v56 = 2082;
          *(void *)os_log_type_t v57 = v46;
          _os_log_impl(&dword_1830D4000, v44, v47, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v46);
        goto LABEL_84;
      }
      if (v48)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v55 = "nw_path_create_observer";
        _os_log_impl(&dword_1830D4000, v44, v47, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v44 = __nwlog_obj();
      os_log_type_t v49 = type;
      if (os_log_type_enabled(v44, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v55 = "nw_path_create_observer";
        _os_log_impl(&dword_1830D4000, v44, v49, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_84:
  if (v43) {
    free(v43);
  }
  id v18 = 0;
LABEL_67:

  return v18;
}

void sub_183BAA6CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void __nw_path_create_observer_block_invoke(uint64_t a1)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  int v1 = (os_unfair_lock_s *)*(id *)(a1 + 32);
  int v2 = v1;
  if (!v1)
  {
    nw_parameters_t v12 = __nwlog_obj();
    *(_DWORD *)dispatch_block_t block = 136446210;
    *(void *)&block[4] = "nw_path_observer_update";
    os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v33) = 0;
    if (__nwlog_fault(v13, type, &v33))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        BOOL v14 = __nwlog_obj();
        os_log_type_t v15 = type[0];
        if (os_log_type_enabled(v14, type[0]))
        {
          *(_DWORD *)dispatch_block_t block = 136446210;
          *(void *)&block[4] = "nw_path_observer_update";
          _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s called with null observer", block, 0xCu);
        }
      }
      else if ((_BYTE)v33)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v14 = __nwlog_obj();
        os_log_type_t v17 = type[0];
        BOOL v18 = os_log_type_enabled(v14, type[0]);
        if (backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)dispatch_block_t block = 136446466;
            *(void *)&block[4] = "nw_path_observer_update";
            *(_WORD *)&block[12] = 2082;
            *(void *)&block[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null observer, dumping backtrace:%{public}s", block, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_31;
        }
        if (v18)
        {
          *(_DWORD *)dispatch_block_t block = 136446210;
          *(void *)&block[4] = "nw_path_observer_update";
          _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null observer, no backtrace", block, 0xCu);
        }
      }
      else
      {
        BOOL v14 = __nwlog_obj();
        os_log_type_t v21 = type[0];
        if (os_log_type_enabled(v14, type[0]))
        {
          *(_DWORD *)dispatch_block_t block = 136446210;
          *(void *)&block[4] = "nw_path_observer_update";
          _os_log_impl(&dword_1830D4000, v14, v21, "%{public}s called with null observer, backtrace limit exceeded", block, 0xCu);
        }
      }
    }
LABEL_31:
    if (v13) {
      free(v13);
    }
    goto LABEL_12;
  }
  long long v46 = 0uLL;
  v39[0] = 0;
  v39[1] = v39;
  v39[2] = 0x2020000000;
  v39[3] = &v46;
  uint64_t v33 = 0;
  os_log_type_t v34 = &v33;
  uint64_t v35 = 0x3032000000;
  double v36 = __Block_byref_object_copy__68682;
  os_log_type_t v37 = __Block_byref_object_dispose__68683;
  id v38 = 0;
  os_unfair_lock_lock(v1 + 12);
  id v3 = *(void **)&v2[8]._os_unfair_lock_opaque;
  *(void *)os_log_type_t type = MEMORY[0x1E4F143A8];
  uint64_t v27 = 3221225472;
  BOOL v28 = ___ZL23nw_path_observer_updateP27NWConcrete_nw_path_observer_block_invoke;
  os_log_type_t v29 = &unk_1E52483C0;
  id v4 = v2;
  BOOL v30 = v4;
  id v31 = &v33;
  uint64_t v32 = v39;
  int fd = nw_fd_wrapper_get_fd(v3, type);
  os_log_type_t v6 = (void (**)(void *, long long *, void))_Block_copy(*(const void **)&v4[4]._os_unfair_lock_opaque);
  int v7 = *(id *)&v4[2]._os_unfair_lock_opaque;
  os_unfair_lock_unlock(v2 + 12);
  if (v6) {
    int v8 = fd;
  }
  else {
    int v8 = 0;
  }
  if (v8 != 1) {
    goto LABEL_11;
  }
  if (!v7)
  {
    unsigned int v10 = v4;
    os_unfair_lock_lock(v2 + 12);
    BOOL v11 = *(void *)&v4[4]._os_unfair_lock_opaque == 0;
    os_unfair_lock_unlock(v2 + 12);

    if (!v11) {
      v6[2](v6, &v46, v34[5]);
    }
    goto LABEL_11;
  }
  uint64_t v22 = 0;
  int v23 = &v22;
  uint64_t v24 = 0x2020000000;
  os_log_type_t v25 = 0;
  os_log_type_t v9 = malloc_type_malloc(0x10uLL, 0xF2B69DE5uLL);
  if (v9)
  {
LABEL_8:
    os_log_type_t v25 = v9;
    *(_OWORD *)v23[3] = v46;
    *(void *)dispatch_block_t block = MEMORY[0x1E4F143A8];
    *(void *)&block[8] = 3221225472;
    *(void *)&block[16] = ___ZL23nw_path_observer_updateP27NWConcrete_nw_path_observer_block_invoke_444;
    BOOL v41 = &unk_1E52483E8;
    os_log_type_t v42 = v4;
    id v43 = v6;
    os_log_type_t v44 = &v22;
    os_log_type_t v45 = &v33;
    dispatch_async(v7, block);

    _Block_object_dispose(&v22, 8);
LABEL_11:

    _Block_object_dispose(&v33, 8);
    _Block_object_dispose(v39, 8);
LABEL_12:

    return;
  }
  id v19 = __nwlog_obj();
  os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
  *(_DWORD *)dispatch_block_t block = 136446466;
  *(void *)&block[4] = "strict_malloc";
  *(_WORD *)&block[12] = 2048;
  *(void *)&block[14] = 16;
  os_log_type_t v20 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v20))
  {
    free(v20);
    goto LABEL_8;
  }
  __break(1u);
}

void sub_183BAAC90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,id a30,char a31)
{
  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a31, 8);

  _Unwind_Resume(a1);
}

uint64_t ___ZL23nw_path_observer_updateP27NWConcrete_nw_path_observer_block_invoke(void *a1)
{
  uint64_t v89 = *MEMORY[0x1E4F143B8];
  memset(uu, 0, sizeof(uu));
  bzero(&v86, 0x604uLL);
  int v2 = necp_client_action();
  unsigned int v3 = v2;
  if (v2 < 4)
  {
    if (v2 < 0)
    {
      int v11 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v12 = (id)gLogObj;
      *(_DWORD *)uuid_string_t out = 136446466;
      *(void *)&out[4] = "nw_path_observer_update_block_invoke";
      *(_WORD *)&out[12] = 1024;
      *(_DWORD *)&out[14] = v11;
      int v8 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v80[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v8, type, v80)) {
        goto LABEL_78;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v9 = (id)gLogObj;
        os_log_type_t v13 = type[0];
        if (os_log_type_enabled(v9, type[0]))
        {
          *(_DWORD *)uuid_string_t out = 136446466;
          *(void *)&out[4] = "nw_path_observer_update_block_invoke";
          *(_WORD *)&out[12] = 1024;
          *(_DWORD *)&out[14] = v11;
          _os_log_impl(&dword_1830D4000, v9, v13, "%{public}s necp_client_action(NECP_CLIENT_ACTION_COPY_CLIENT_UPDATE) %{darwin.errno}d", (uint8_t *)out, 0x12u);
        }
        goto LABEL_77;
      }
      if (v80[0] == OS_LOG_TYPE_DEFAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v9 = (id)gLogObj;
        os_log_type_t v34 = type[0];
        if (os_log_type_enabled(v9, type[0]))
        {
          *(_DWORD *)uuid_string_t out = 136446466;
          *(void *)&out[4] = "nw_path_observer_update_block_invoke";
          *(_WORD *)&out[12] = 1024;
          *(_DWORD *)&out[14] = v11;
          _os_log_impl(&dword_1830D4000, v9, v34, "%{public}s necp_client_action(NECP_CLIENT_ACTION_COPY_CLIENT_UPDATE) %{darwin.errno}d, backtrace limit exceeded", (uint8_t *)out, 0x12u);
        }
        goto LABEL_77;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v9 = (id)gLogObj;
      os_log_type_t v24 = type[0];
      BOOL v25 = os_log_type_enabled(v9, type[0]);
      if (!backtrace_string)
      {
        if (v25)
        {
          *(_DWORD *)uuid_string_t out = 136446466;
          *(void *)&out[4] = "nw_path_observer_update_block_invoke";
          *(_WORD *)&out[12] = 1024;
          *(_DWORD *)&out[14] = v11;
          _os_log_impl(&dword_1830D4000, v9, v24, "%{public}s necp_client_action(NECP_CLIENT_ACTION_COPY_CLIENT_UPDATE) %{darwin.errno}d, no backtrace", (uint8_t *)out, 0x12u);
        }
        goto LABEL_77;
      }
      if (v25)
      {
        *(_DWORD *)uuid_string_t out = 136446722;
        *(void *)&out[4] = "nw_path_observer_update_block_invoke";
        *(_WORD *)&out[12] = 1024;
        *(_DWORD *)&out[14] = v11;
        *(_WORD *)&out[18] = 2082;
        *(void *)&out[20] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v9, v24, "%{public}s necp_client_action(NECP_CLIENT_ACTION_COPY_CLIENT_UPDATE) %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)out, 0x1Cu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v7 = (id)gLogObj;
      *(_DWORD *)uuid_string_t out = 136446466;
      *(void *)&out[4] = "nw_path_observer_update_block_invoke";
      *(_WORD *)&out[12] = 1024;
      *(_DWORD *)&out[14] = v3;
      int v8 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v80[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v8, type, v80)) {
        goto LABEL_78;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v9 = (id)gLogObj;
        os_log_type_t v10 = type[0];
        if (os_log_type_enabled(v9, type[0]))
        {
          *(_DWORD *)uuid_string_t out = 136446466;
          *(void *)&out[4] = "nw_path_observer_update_block_invoke";
          *(_WORD *)&out[12] = 1024;
          *(_DWORD *)&out[14] = v3;
          _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s Path observer result cannot hold update header (%d)", (uint8_t *)out, 0x12u);
        }
LABEL_77:

LABEL_78:
        if (!v8) {
          return 0;
        }
LABEL_79:
        free(v8);
        return 0;
      }
      if (v80[0] == OS_LOG_TYPE_DEFAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v9 = (id)gLogObj;
        os_log_type_t v26 = type[0];
        if (os_log_type_enabled(v9, type[0]))
        {
          *(_DWORD *)uuid_string_t out = 136446466;
          *(void *)&out[4] = "nw_path_observer_update_block_invoke";
          *(_WORD *)&out[12] = 1024;
          *(_DWORD *)&out[14] = v3;
          _os_log_impl(&dword_1830D4000, v9, v26, "%{public}s Path observer result cannot hold update header (%d), backtrace limit exceeded", (uint8_t *)out, 0x12u);
        }
        goto LABEL_77;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v9 = (id)gLogObj;
      os_log_type_t v15 = type[0];
      BOOL v16 = os_log_type_enabled(v9, type[0]);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)uuid_string_t out = 136446466;
          *(void *)&out[4] = "nw_path_observer_update_block_invoke";
          *(_WORD *)&out[12] = 1024;
          *(_DWORD *)&out[14] = v3;
          _os_log_impl(&dword_1830D4000, v9, v15, "%{public}s Path observer result cannot hold update header (%d), no backtrace", (uint8_t *)out, 0x12u);
        }
        goto LABEL_77;
      }
      if (v16)
      {
        *(_DWORD *)uuid_string_t out = 136446722;
        *(void *)&out[4] = "nw_path_observer_update_block_invoke";
        *(_WORD *)&out[12] = 1024;
        *(_DWORD *)&out[14] = v3;
        *(_WORD *)&out[18] = 2082;
        *(void *)&out[20] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v9, v15, "%{public}s Path observer result cannot hold update header (%d), dumping backtrace:%{public}s", (uint8_t *)out, 0x1Cu);
      }
    }

    free(backtrace_string);
    if (!v8) {
      return 0;
    }
    goto LABEL_79;
  }
  memset(out, 0, sizeof(out));
  uuid_unparse(uu, out);
  if (v86 != 3)
  {
    if (v86 != 2)
    {
      if (v86 == 1)
      {
        obuint64_t j = 0;
        *(void *)os_log_type_t v80 = 0;
        id v77 = 0;
        id v78 = 0;
        nw_parameters_t v4 = nw_parameters_create();
        nw_parameters_t v5 = v4;
        if (v4)
        {
          char v76 = 0;
          *(_WORD *)id v75 = 0;
          __int16 v74 = 0;
          if (nw_path_parse_necp_parameters(v4, (void **)v80, &obj, &v78, &v77, &v76, v75, (char *)&v74 + 1, &v74, (uint64_t)v87, v3 - 4))
          {
            if (v78) {
              browse = nw_path_create_browse(v78, v5);
            }
            else {
              browse = nw_path_create(*(void **)v80, v5);
            }
            char v52 = browse;
            if (browse)
            {
              objc_storeStrong((id *)&browse->group_descriptor, obj);
              objc_storeStrong((id *)&v52->advertise_descriptor, v77);
              char v53 = *((unsigned char *)v52 + 475) & 0xFC | v76;
              v52->custom_etheros_log_type_t type = *(_WORD *)v75;
              v52->custom_ip_protocol = HIBYTE(v74);
              *((unsigned char *)v52 + 475) = v53 | (2 * v74);
              *(_OWORD *)v52->client_id = *(_OWORD *)uu;
              nw_dictionary_set_value(*(void *)(a1[4] + 24), out, v52);
LABEL_149:

LABEL_150:
              return 0;
            }
            os_log_type_t v54 = __nwlog_obj();
            *(_DWORD *)os_log_type_t type = 136446210;
            __int16 v82 = "nw_path_observer_update_block_invoke";
            BOOL v55 = (char *)_os_log_send_and_compose_impl();

            os_log_type_t v73 = OS_LOG_TYPE_ERROR;
            char v72 = 0;
            if (__nwlog_fault(v55, &v73, &v72))
            {
              if (v73 == OS_LOG_TYPE_FAULT)
              {
                __int16 v56 = __nwlog_obj();
                os_log_type_t v57 = v73;
                if (os_log_type_enabled(v56, v73))
                {
                  *(_DWORD *)os_log_type_t type = 136446210;
                  __int16 v82 = "nw_path_observer_update_block_invoke";
                  _os_log_impl(&dword_1830D4000, v56, v57, "%{public}s nw_path_create failed", (uint8_t *)type, 0xCu);
                }
              }
              else if (v72)
              {
                BOOL v65 = (char *)__nw_create_backtrace_string();
                __int16 v56 = __nwlog_obj();
                os_log_type_t v66 = v73;
                BOOL v67 = os_log_type_enabled(v56, v73);
                if (v65)
                {
                  if (v67)
                  {
                    *(_DWORD *)os_log_type_t type = 136446466;
                    __int16 v82 = "nw_path_observer_update_block_invoke";
                    __int16 v83 = 2082;
                    long long v84 = v65;
                    _os_log_impl(&dword_1830D4000, v56, v66, "%{public}s nw_path_create failed, dumping backtrace:%{public}s", (uint8_t *)type, 0x16u);
                  }

                  free(v65);
                  goto LABEL_147;
                }
                if (v67)
                {
                  *(_DWORD *)os_log_type_t type = 136446210;
                  __int16 v82 = "nw_path_observer_update_block_invoke";
                  _os_log_impl(&dword_1830D4000, v56, v66, "%{public}s nw_path_create failed, no backtrace", (uint8_t *)type, 0xCu);
                }
              }
              else
              {
                __int16 v56 = __nwlog_obj();
                os_log_type_t v70 = v73;
                if (os_log_type_enabled(v56, v73))
                {
                  *(_DWORD *)os_log_type_t type = 136446210;
                  __int16 v82 = "nw_path_observer_update_block_invoke";
                  _os_log_impl(&dword_1830D4000, v56, v70, "%{public}s nw_path_create failed, backtrace limit exceeded", (uint8_t *)type, 0xCu);
                }
              }
            }
LABEL_147:
            if (v55) {
              free(v55);
            }
            goto LABEL_149;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v31 = (id)gLogObj;
          *(_DWORD *)os_log_type_t type = 136446210;
          __int16 v82 = "nw_path_observer_update_block_invoke";
          BOOL v28 = (void *)_os_log_send_and_compose_impl();

          os_log_type_t v73 = OS_LOG_TYPE_ERROR;
          char v72 = 0;
          if (!__nwlog_fault((const char *)v28, &v73, &v72))
          {
LABEL_124:
            if (v28) {
              free(v28);
            }
            goto LABEL_150;
          }
          if (v73 == OS_LOG_TYPE_FAULT)
          {
            uint64_t v32 = __nwlog_obj();
            os_log_type_t v33 = v73;
            if (os_log_type_enabled(v32, v73))
            {
              *(_DWORD *)os_log_type_t type = 136446210;
              __int16 v82 = "nw_path_observer_update_block_invoke";
              _os_log_impl(&dword_1830D4000, v32, v33, "%{public}s nw_path_parse_necp_parameters failed", (uint8_t *)type, 0xCu);
            }
LABEL_123:

            goto LABEL_124;
          }
          if (!v72)
          {
            uint64_t v32 = __nwlog_obj();
            os_log_type_t v64 = v73;
            if (os_log_type_enabled(v32, v73))
            {
              *(_DWORD *)os_log_type_t type = 136446210;
              __int16 v82 = "nw_path_observer_update_block_invoke";
              _os_log_impl(&dword_1830D4000, v32, v64, "%{public}s nw_path_parse_necp_parameters failed, backtrace limit exceeded", (uint8_t *)type, 0xCu);
            }
            goto LABEL_123;
          }
          uint64_t v47 = (char *)__nw_create_backtrace_string();
          uint64_t v32 = __nwlog_obj();
          os_log_type_t v50 = v73;
          BOOL v51 = os_log_type_enabled(v32, v73);
          if (!v47)
          {
            if (v51)
            {
              *(_DWORD *)os_log_type_t type = 136446210;
              __int16 v82 = "nw_path_observer_update_block_invoke";
              _os_log_impl(&dword_1830D4000, v32, v50, "%{public}s nw_path_parse_necp_parameters failed, no backtrace", (uint8_t *)type, 0xCu);
            }
            goto LABEL_123;
          }
          if (v51)
          {
            *(_DWORD *)os_log_type_t type = 136446466;
            __int16 v82 = "nw_path_observer_update_block_invoke";
            __int16 v83 = 2082;
            long long v84 = v47;
            _os_log_impl(&dword_1830D4000, v32, v50, "%{public}s nw_path_parse_necp_parameters failed, dumping backtrace:%{public}s", (uint8_t *)type, 0x16u);
          }

LABEL_85:
          free(v47);
          goto LABEL_124;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v27 = (id)gLogObj;
        *(_DWORD *)os_log_type_t type = 136446210;
        __int16 v82 = "nw_path_observer_update_block_invoke";
        BOOL v28 = (void *)_os_log_send_and_compose_impl();

        v75[0] = OS_LOG_TYPE_ERROR;
        char v76 = 0;
        if (!__nwlog_fault((const char *)v28, v75, &v76)) {
          goto LABEL_124;
        }
        if (v75[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v29 = (id)gLogObj;
          os_log_type_t v30 = v75[0];
          if (os_log_type_enabled(v29, v75[0]))
          {
            *(_DWORD *)os_log_type_t type = 136446210;
            __int16 v82 = "nw_path_observer_update_block_invoke";
            _os_log_impl(&dword_1830D4000, v29, v30, "%{public}s nw_parameters_create failed", (uint8_t *)type, 0xCu);
          }
        }
        else if (v76)
        {
          uint64_t v47 = (char *)__nw_create_backtrace_string();
          os_log_type_t v29 = __nwlog_obj();
          os_log_type_t v48 = v75[0];
          BOOL v49 = os_log_type_enabled(v29, v75[0]);
          if (v47)
          {
            if (v49)
            {
              *(_DWORD *)os_log_type_t type = 136446466;
              __int16 v82 = "nw_path_observer_update_block_invoke";
              __int16 v83 = 2082;
              long long v84 = v47;
              _os_log_impl(&dword_1830D4000, v29, v48, "%{public}s nw_parameters_create failed, dumping backtrace:%{public}s", (uint8_t *)type, 0x16u);
            }

            goto LABEL_85;
          }
          if (v49)
          {
            *(_DWORD *)os_log_type_t type = 136446210;
            __int16 v82 = "nw_path_observer_update_block_invoke";
            _os_log_impl(&dword_1830D4000, v29, v48, "%{public}s nw_parameters_create failed, no backtrace", (uint8_t *)type, 0xCu);
          }
        }
        else
        {
          os_log_type_t v29 = __nwlog_obj();
          os_log_type_t v63 = v75[0];
          if (os_log_type_enabled(v29, v75[0]))
          {
            *(_DWORD *)os_log_type_t type = 136446210;
            __int16 v82 = "nw_path_observer_update_block_invoke";
            _os_log_impl(&dword_1830D4000, v29, v63, "%{public}s nw_parameters_create failed, backtrace limit exceeded", (uint8_t *)type, 0xCu);
          }
        }

        goto LABEL_124;
      }
      return 0;
    }
    id v19 = (id *)nw_dictionary_copy_value(*(void *)(a1[4] + 24), (uint64_t)out);
    os_log_type_t v17 = v19;
    if (v19)
    {
      id v20 = v19[3];
      id v21 = v17[5];
      id v22 = v17[2];
      if (v21) {
        int v23 = nw_path_create_browse(v21, v22);
      }
      else {
        int v23 = nw_path_create(v20, v22);
      }
      uint64_t v35 = *(void *)(a1[5] + 8);
      double v36 = *(void **)(v35 + 40);
      *(void *)(v35 + 40) = v23;

      uint64_t v37 = *(void *)(*(void *)(a1[5] + 8) + 40);
      if (v37)
      {
        objc_storeStrong((id *)(v37 + 32), v17[4]);
        id v38 = a1 + 5;
        objc_storeStrong((id *)(*(void *)(*(void *)(a1[5] + 8) + 40) + 48), v17[6]);
        uint64_t v39 = *(void *)(*(void *)(a1[5] + 8) + 40);
        *(unsigned char *)(v39 + 475) = *(unsigned char *)(v39 + 475) & 0xFE | *((unsigned char *)v17 + 475) & 1;
        *(_WORD *)(*(void *)(*(void *)(*v38 + 8) + 40) + 384) = *((_WORD *)v17 + 192);
        *(unsigned char *)(*(void *)(*(void *)(*v38 + 8) + 40) + 386) = *((unsigned char *)v17 + 386);
        uint64_t v40 = *(void *)(*(void *)(a1[5] + 8) + 40);
        *(unsigned char *)(v40 + 475) = *(unsigned char *)(v40 + 475) & 0xFD | *((unsigned char *)v17 + 475) & 2;
        *(_OWORD *)(*(void *)(*(void *)(*v38 + 8) + 40) + 120) = *(_OWORD *)uu;
        if (nw_path_parse_necp_result(*(void **)(*(void *)(a1[5] + 8) + 40), (uint64_t)v87, v3 - 4))
        {
          nw_path_snapshot_path(*(NWConcrete_nw_path **)(*(void *)(a1[5] + 8) + 40));
          *(_OWORD *)*(void *)(*(void *)(a1[6] + 8) + 24) = *(_OWORD *)uu;
          uint64_t v18 = 1;
LABEL_139:

          goto LABEL_140;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v45 = (id)gLogObj;
        *(_DWORD *)os_log_type_t type = 136446210;
        __int16 v82 = "nw_path_observer_update_block_invoke";
        os_log_type_t v42 = (char *)_os_log_send_and_compose_impl();

        v80[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(obj) = 0;
        if (__nwlog_fault(v42, v80, &obj))
        {
          if (v80[0] == OS_LOG_TYPE_FAULT)
          {
            id v43 = __nwlog_obj();
            os_log_type_t v46 = v80[0];
            if (os_log_type_enabled(v43, v80[0]))
            {
              *(_DWORD *)os_log_type_t type = 136446210;
              __int16 v82 = "nw_path_observer_update_block_invoke";
              _os_log_impl(&dword_1830D4000, v43, v46, "%{public}s nw_path_parse_necp_result failed", (uint8_t *)type, 0xCu);
            }
LABEL_135:

            goto LABEL_136;
          }
          if (!(_BYTE)obj)
          {
            id v43 = __nwlog_obj();
            os_log_type_t v69 = v80[0];
            if (os_log_type_enabled(v43, v80[0]))
            {
              *(_DWORD *)os_log_type_t type = 136446210;
              __int16 v82 = "nw_path_observer_update_block_invoke";
              _os_log_impl(&dword_1830D4000, v43, v69, "%{public}s nw_path_parse_necp_result failed, backtrace limit exceeded", (uint8_t *)type, 0xCu);
            }
            goto LABEL_135;
          }
          char v58 = (char *)__nw_create_backtrace_string();
          id v43 = __nwlog_obj();
          os_log_type_t v61 = v80[0];
          BOOL v62 = os_log_type_enabled(v43, v80[0]);
          if (!v58)
          {
            if (v62)
            {
              *(_DWORD *)os_log_type_t type = 136446210;
              __int16 v82 = "nw_path_observer_update_block_invoke";
              _os_log_impl(&dword_1830D4000, v43, v61, "%{public}s nw_path_parse_necp_result failed, no backtrace", (uint8_t *)type, 0xCu);
            }
            goto LABEL_135;
          }
          if (v62)
          {
            *(_DWORD *)os_log_type_t type = 136446466;
            __int16 v82 = "nw_path_observer_update_block_invoke";
            __int16 v83 = 2082;
            long long v84 = v58;
            _os_log_impl(&dword_1830D4000, v43, v61, "%{public}s nw_path_parse_necp_result failed, dumping backtrace:%{public}s", (uint8_t *)type, 0x16u);
          }
          goto LABEL_103;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v41 = (id)gLogObj;
        *(_DWORD *)os_log_type_t type = 136446210;
        __int16 v82 = "nw_path_observer_update_block_invoke";
        os_log_type_t v42 = (char *)_os_log_send_and_compose_impl();

        v80[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(obj) = 0;
        if (__nwlog_fault(v42, v80, &obj))
        {
          if (v80[0] == OS_LOG_TYPE_FAULT)
          {
            id v43 = __nwlog_obj();
            os_log_type_t v44 = v80[0];
            if (os_log_type_enabled(v43, v80[0]))
            {
              *(_DWORD *)os_log_type_t type = 136446210;
              __int16 v82 = "nw_path_observer_update_block_invoke";
              _os_log_impl(&dword_1830D4000, v43, v44, "%{public}s nw_path_create failed", (uint8_t *)type, 0xCu);
            }
            goto LABEL_135;
          }
          if (!(_BYTE)obj)
          {
            id v43 = __nwlog_obj();
            os_log_type_t v68 = v80[0];
            if (os_log_type_enabled(v43, v80[0]))
            {
              *(_DWORD *)os_log_type_t type = 136446210;
              __int16 v82 = "nw_path_observer_update_block_invoke";
              _os_log_impl(&dword_1830D4000, v43, v68, "%{public}s nw_path_create failed, backtrace limit exceeded", (uint8_t *)type, 0xCu);
            }
            goto LABEL_135;
          }
          char v58 = (char *)__nw_create_backtrace_string();
          id v43 = __nwlog_obj();
          os_log_type_t v59 = v80[0];
          BOOL v60 = os_log_type_enabled(v43, v80[0]);
          if (!v58)
          {
            if (v60)
            {
              *(_DWORD *)os_log_type_t type = 136446210;
              __int16 v82 = "nw_path_observer_update_block_invoke";
              _os_log_impl(&dword_1830D4000, v43, v59, "%{public}s nw_path_create failed, no backtrace", (uint8_t *)type, 0xCu);
            }
            goto LABEL_135;
          }
          if (v60)
          {
            *(_DWORD *)os_log_type_t type = 136446466;
            __int16 v82 = "nw_path_observer_update_block_invoke";
            __int16 v83 = 2082;
            long long v84 = v58;
            _os_log_impl(&dword_1830D4000, v43, v59, "%{public}s nw_path_create failed, dumping backtrace:%{public}s", (uint8_t *)type, 0x16u);
          }
LABEL_103:

          free(v58);
        }
      }
LABEL_136:
      if (v42) {
        free(v42);
      }
      uint64_t v18 = 0;
      goto LABEL_139;
    }
    goto LABEL_30;
  }
  os_log_type_t v17 = (id *)nw_dictionary_copy_value(*(void *)(a1[4] + 24), (uint64_t)out);
  if (!v17)
  {
LABEL_30:
    uint64_t v18 = 0;
    goto LABEL_140;
  }
  nw_dictionary_set_value(*(void *)(a1[4] + 24), out, 0);
  *(_OWORD *)*(void *)(*(void *)(a1[6] + 8) + 24) = *(_OWORD *)uu;
  uint64_t v18 = 1;
LABEL_140:

  return v18;
}

void sub_183BAC108(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19, void *a20)
{
  _Unwind_Resume(a1);
}

void ___ZL23nw_path_observer_updateP27NWConcrete_nw_path_observer_block_invoke_444(void *a1)
{
  int v2 = (os_unfair_lock_s *)a1[4];
  unsigned int v3 = v2 + 12;
  nw_parameters_t v4 = v2;
  os_unfair_lock_lock(v3);
  uint64_t v5 = *(void *)&v4[4]._os_unfair_lock_opaque;
  os_unfair_lock_unlock(v3);

  if (v5) {
    (*(void (**)(void))(a1[5] + 16))();
  }
  os_log_type_t v6 = *(void **)(*(void *)(a1[6] + 8) + 24);
  if (v6)
  {
    free(v6);
    *(void *)(*(void *)(a1[6] + 8) + 24) = 0;
  }
}

void nw_path_observer_cancel(void *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  int v1 = a1;
  int v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 12);
    unsigned int v3 = *(void **)&v2[4]._os_unfair_lock_opaque;
    *(void *)&v2[4]._uint32_t os_unfair_lock_opaque = 0;

    nw_parameters_t v4 = *(void **)&v2[2]._os_unfair_lock_opaque;
    *(void *)&v2[2]._uint32_t os_unfair_lock_opaque = 0;

    nw_queue_cancel_source(*(void *)&v2[10]._os_unfair_lock_opaque);
    uint64_t v5 = *(void **)&v2[8]._os_unfair_lock_opaque;
    *(void *)&v2[8]._uint32_t os_unfair_lock_opaque = 0;
    *(void *)&v2[10]._uint32_t os_unfair_lock_opaque = 0;

    os_log_type_t v6 = *(void **)&v2[6]._os_unfair_lock_opaque;
    *(void *)&v2[6]._uint32_t os_unfair_lock_opaque = 0;

    os_unfair_lock_unlock(v2 + 12);
    goto LABEL_3;
  }
  id v7 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  uint64_t v18 = "nw_path_observer_cancel";
  int v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v18 = "nw_path_observer_cancel";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null observer", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v18 = "nw_path_observer_cancel";
          __int16 v19 = 2082;
          id v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null observer, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v13)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v18 = "nw_path_observer_cancel";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null observer, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v18 = "nw_path_observer_cancel";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null observer, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v8) {
    free(v8);
  }
LABEL_3:
}

void sub_183BAC4D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *nw_path_copy_all_local_paths(void *a1)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
  uint64_t globals_for_path = nw_context_get_globals_for_path(v1);
  unsigned int v3 = (os_unfair_lock_s *)(globals_for_path + 124);
  os_unfair_lock_lock((os_unfair_lock_t)(globals_for_path + 124));
  uint64_t v4 = *(void *)(globals_for_path + 32);
  if (v4)
  {
    uint64_t v5 = (void *)nw_dictionary_copy(v4);
    os_unfair_lock_unlock(v3);
    if (v5)
    {
      os_log_type_t v6 = nw_dictionary_create();
      id v7 = v6;
      if (v6)
      {
        v21[0] = MEMORY[0x1E4F143A8];
        v21[1] = 3221225472;
        v21[2] = __nw_path_copy_all_local_paths_block_invoke;
        v21[3] = &unk_1E5247FE0;
        int v8 = v6;
        id v22 = v8;
        nw_dictionary_apply((uint64_t)v5, (uint64_t)v21);
        os_log_type_t v9 = v8;

LABEL_26:
        goto LABEL_27;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v10 = (id)gLogObj;
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v26 = "nw_path_copy_all_local_paths";
      int v11 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v23 = 0;
      if (__nwlog_fault(v11, &type, &v23))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v12 = (id)gLogObj;
          os_log_type_t v13 = type;
          if (os_log_type_enabled(v12, type))
          {
            *(_DWORD *)int buf = 136446210;
            os_log_type_t v26 = "nw_path_copy_all_local_paths";
            _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s nw_dictionary_create failed", buf, 0xCu);
          }
        }
        else if (v23)
        {
          backtrace_string = __nw_create_backtrace_string();
          if (backtrace_string)
          {
            char v15 = (char *)backtrace_string;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v16 = (id)gLogObj;
            os_log_type_t v17 = type;
            if (os_log_type_enabled(v16, type))
            {
              *(_DWORD *)int buf = 136446466;
              os_log_type_t v26 = "nw_path_copy_all_local_paths";
              __int16 v27 = 2082;
              BOOL v28 = v15;
              _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s nw_dictionary_create failed, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v15);
            if (!v11) {
              goto LABEL_26;
            }
            goto LABEL_25;
          }
          os_log_type_t v12 = __nwlog_obj();
          os_log_type_t v19 = type;
          if (os_log_type_enabled(v12, type))
          {
            *(_DWORD *)int buf = 136446210;
            os_log_type_t v26 = "nw_path_copy_all_local_paths";
            _os_log_impl(&dword_1830D4000, v12, v19, "%{public}s nw_dictionary_create failed, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v12 = (id)gLogObj;
          os_log_type_t v18 = type;
          if (os_log_type_enabled(v12, type))
          {
            *(_DWORD *)int buf = 136446210;
            os_log_type_t v26 = "nw_path_copy_all_local_paths";
            _os_log_impl(&dword_1830D4000, v12, v18, "%{public}s nw_dictionary_create failed, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }
      if (!v11) {
        goto LABEL_26;
      }
LABEL_25:
      free(v11);
      goto LABEL_26;
    }
  }
  else
  {
    os_unfair_lock_unlock(v3);
  }
  id v7 = 0;
LABEL_27:

  return v7;
}

void sub_183BAC8E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_path_copy_all_local_paths_block_invoke(uint64_t a1, const char *a2, void *a3)
{
  uint64_t v5 = a3;
  os_log_type_t v6 = v5;
  if (v5)
  {
    os_unfair_lock_lock(v5 + 24);
    id v7 = *(void **)&v6[12]._os_unfair_lock_opaque;
    if (v7) {
      nw_dictionary_set_value(*(void *)(a1 + 32), a2, v7);
    }
    os_unfair_lock_unlock(v6 + 24);
  }

  return 1;
}

uint64_t nw_path_get_nexus_instance(void *a1, _OWORD *a2, _DWORD *a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a1;
  os_log_type_t v6 = v5;
  if (!v5)
  {
    id v10 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    id v22 = "nw_path_get_nexus_instance";
    int v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v11, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v12 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)int buf = 136446210;
          id v22 = "nw_path_get_nexus_instance";
          _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v12 = __nwlog_obj();
        os_log_type_t v15 = type;
        BOOL v16 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)int buf = 136446466;
            id v22 = "nw_path_get_nexus_instance";
            __int16 v23 = 2082;
            os_log_type_t v24 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_21;
        }
        if (v16)
        {
          *(_DWORD *)int buf = 136446210;
          id v22 = "nw_path_get_nexus_instance";
          _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v12 = __nwlog_obj();
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)int buf = 136446210;
          id v22 = "nw_path_get_nexus_instance";
          _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_21:
    if (v11) {
      free(v11);
    }
    goto LABEL_23;
  }
  uint64_t v7 = v5[9];
  if (!v7 || *(void *)(v7 + 24) == *(void *)(v7 + 16))
  {
LABEL_23:
    uint64_t nexus_instance = 0;
    goto LABEL_24;
  }
  int v8 = nw_array_get_object_at_index(v7, 0);
  uint64_t nexus_instance = nw_path_flow_get_nexus_instance(v8, a2, a3);

LABEL_24:
  return nexus_instance;
}

void sub_183BACC38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_path_flow_get_nexus_instance(void *a1, _OWORD *a2, _DWORD *a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a1;
  os_log_type_t v6 = v5;
  if (!v5)
  {
    id v10 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v21 = "nw_path_flow_get_nexus_instance";
    int v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v11, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v12 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v21 = "nw_path_flow_get_nexus_instance";
          _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null flow", buf, 0xCu);
        }
      }
      else if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v12 = __nwlog_obj();
        os_log_type_t v15 = type;
        BOOL v16 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)int buf = 136446466;
            uint64_t v21 = "nw_path_flow_get_nexus_instance";
            __int16 v22 = 2082;
            __int16 v23 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null flow, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_24;
        }
        if (v16)
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v21 = "nw_path_flow_get_nexus_instance";
          _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null flow, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v12 = __nwlog_obj();
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v21 = "nw_path_flow_get_nexus_instance";
          _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null flow, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_24:
    if (v11) {
      free(v11);
    }
    goto LABEL_5;
  }
  if (a3) {
    *a3 = *((_DWORD *)v5 + 42);
  }
  uint64_t v7 = v5 + 8;
  if (!uuid_is_null((const unsigned __int8 *)v5 + 128))
  {
    *a2 = *v7;
    uint64_t v8 = 1;
    goto LABEL_7;
  }
LABEL_5:
  uint64_t v8 = 0;
LABEL_7:

  return v8;
}

void sub_183BACF14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_path_get_nexus_key(void *a1, _DWORD *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  unsigned int v3 = a1;
  uint64_t v4 = v3;
  if (!v3)
  {
    uint64_t v8 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    id v20 = "nw_path_get_nexus_key";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v9, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)int buf = 136446210;
          id v20 = "nw_path_get_nexus_key";
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        id v10 = __nwlog_obj();
        os_log_type_t v13 = type;
        BOOL v14 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)int buf = 136446466;
            id v20 = "nw_path_get_nexus_key";
            __int16 v21 = 2082;
            __int16 v22 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_21;
        }
        if (v14)
        {
          *(_DWORD *)int buf = 136446210;
          id v20 = "nw_path_get_nexus_key";
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        id v10 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)int buf = 136446210;
          id v20 = "nw_path_get_nexus_key";
          _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_21:
    if (v9) {
      free(v9);
    }
    goto LABEL_23;
  }
  uint64_t v5 = v3[9];
  if (!v5 || *(void *)(v5 + 24) == *(void *)(v5 + 16))
  {
LABEL_23:
    uint64_t nexus_key = 0;
    goto LABEL_24;
  }
  os_log_type_t v6 = nw_array_get_object_at_index(v5, 0);
  uint64_t nexus_key = nw_path_flow_get_nexus_key(v6, a2);

LABEL_24:
  return nexus_key;
}

uint64_t nw_path_flow_get_nexus_key(void *a1, _DWORD *a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  uint64_t v4 = v3;
  if (v3)
  {
    if (a2)
    {
      uint64_t v5 = *((void *)v3 + 1);
      if (v5 && (int v6 = *((_DWORD *)v3 + 40)) != 0)
      {
        *a2 = v6;
      }
      else
      {
        uint64_t v5 = 0;
        *a2 = 0;
      }
      goto LABEL_7;
    }
    os_log_type_t v12 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v24 = "nw_path_flow_get_nexus_key";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v9, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v10 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v24 = "nw_path_flow_get_nexus_key";
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null length", buf, 0xCu);
        }
LABEL_39:

        goto LABEL_40;
      }
      if (!v21)
      {
        id v10 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v24 = "nw_path_flow_get_nexus_key";
          _os_log_impl(&dword_1830D4000, v10, v20, "%{public}s called with null length, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_39;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v10 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v24 = "nw_path_flow_get_nexus_key";
          _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s called with null length, no backtrace", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (v18)
      {
        *(_DWORD *)int buf = 136446466;
        uint64_t v24 = "nw_path_flow_get_nexus_key";
        __int16 v25 = 2082;
        os_log_type_t v26 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s called with null length, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_27;
    }
  }
  else
  {
    uint64_t v8 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v24 = "nw_path_flow_get_nexus_key";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v9, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v24 = "nw_path_flow_get_nexus_key";
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null flow", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (!v21)
      {
        id v10 = __nwlog_obj();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v24 = "nw_path_flow_get_nexus_key";
          _os_log_impl(&dword_1830D4000, v10, v19, "%{public}s called with null flow, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_39;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v10 = __nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v24 = "nw_path_flow_get_nexus_key";
          _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null flow, no backtrace", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (v16)
      {
        *(_DWORD *)int buf = 136446466;
        uint64_t v24 = "nw_path_flow_get_nexus_key";
        __int16 v25 = 2082;
        os_log_type_t v26 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null flow, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_27:

      free(backtrace_string);
    }
  }
LABEL_40:
  if (v9) {
    free(v9);
  }
  uint64_t v5 = 0;
LABEL_7:

  return v5;
}

uint64_t nw_path_get_nexus_flow_index(void *a1, _DWORD *a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  uint64_t v4 = v3;
  if (!v3)
  {
    uint64_t v8 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v25 = "nw_path_get_nexus_flow_index";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (!__nwlog_fault(v9, &type, &v22)) {
      goto LABEL_39;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v25 = "nw_path_get_nexus_flow_index";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null path", buf, 0xCu);
      }
      goto LABEL_38;
    }
    if (!v22)
    {
      id v10 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v25 = "nw_path_get_nexus_flow_index";
        _os_log_impl(&dword_1830D4000, v10, v19, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_38;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    id v10 = __nwlog_obj();
    os_log_type_t v15 = type;
    BOOL v16 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v25 = "nw_path_get_nexus_flow_index";
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
      goto LABEL_38;
    }
    if (v16)
    {
      *(_DWORD *)int buf = 136446466;
      __int16 v25 = "nw_path_get_nexus_flow_index";
      __int16 v26 = 2082;
      uint64_t v27 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_26;
  }
  if (!a2)
  {
    os_log_type_t v12 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v25 = "nw_path_get_nexus_flow_index";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (!__nwlog_fault(v9, &type, &v22)) {
      goto LABEL_39;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v10 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v25 = "nw_path_get_nexus_flow_index";
        _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null nexus_flow_index", buf, 0xCu);
      }
LABEL_38:

LABEL_39:
      if (v9) {
        free(v9);
      }
      goto LABEL_41;
    }
    if (!v22)
    {
      id v10 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v25 = "nw_path_get_nexus_flow_index";
        _os_log_impl(&dword_1830D4000, v10, v20, "%{public}s called with null nexus_flow_index, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_38;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    id v10 = __nwlog_obj();
    os_log_type_t v17 = type;
    BOOL v18 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v25 = "nw_path_get_nexus_flow_index";
        _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s called with null nexus_flow_index, no backtrace", buf, 0xCu);
      }
      goto LABEL_38;
    }
    if (v18)
    {
      *(_DWORD *)int buf = 136446466;
      __int16 v25 = "nw_path_get_nexus_flow_index";
      __int16 v26 = 2082;
      uint64_t v27 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s called with null nexus_flow_index, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_26:

    free(backtrace_string);
    goto LABEL_39;
  }
  uint64_t v5 = v3[9];
  if (!v5
    || *(void *)(v5 + 24) == *(void *)(v5 + 16)
    || (nw_array_get_object_at_index(v5, 0), (int v6 = (_DWORD *)objc_claimAutoreleasedReturnValue()) == 0))
  {
LABEL_41:
    uint64_t v7 = 0;
    goto LABEL_42;
  }
  *a2 = v6[41];

  uint64_t v7 = 1;
LABEL_42:

  return v7;
}

uint64_t nw_path_flow_registration_get_nexus_key(NWConcrete_nw_path *a1, NWConcrete_nw_path_flow_registration *a2, _DWORD *a3)
{
  id v4 = nw_path_copy_flow_for_registration(a1, a2);
  uint64_t v5 = v4;
  if (v4) {
    uint64_t nexus_key = nw_path_flow_get_nexus_key(v4, a3);
  }
  else {
    uint64_t nexus_key = 0;
  }

  return nexus_key;
}

uint64_t nw_path_flow_registration_get_protocol_level(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    id v5 = nw_path_copy_flow_for_registration(v3, v4);
    int v6 = v5;
    if (!v5) {
      goto LABEL_18;
    }
    uint64_t v7 = v5;
    uint64_t v8 = (void *)v7[3];
    if (v8
      && (*(void *)size_t length = 0, (data = xpc_dictionary_get_data(v8, "data", (size_t *)length)) != 0)
      && *(void *)length >= 0xD8uLL
      && *(void *)length == data[53] + 216)
    {
      int v10 = data[52];
      os_log_type_t v11 = (v10 & 0x13) == 1 ? 0 : data;
      os_log_type_t v12 = (v10 & 0xE080) != 0 ? v11 : 0;
    }
    else
    {
      os_log_type_t v12 = 0;
    }

    if (v12[53] >= 0xCCu)
    {
      unsigned int v13 = v12[54];
      if (v13 >= 5) {
        uint64_t v14 = 0;
      }
      else {
        uint64_t v14 = v13;
      }
    }
    else
    {
LABEL_18:
      uint64_t v14 = 0;
    }

    goto LABEL_20;
  }
  BOOL v16 = __nwlog_obj();
  *(_DWORD *)size_t length = 136446210;
  *(void *)&length[4] = "nw_path_flow_registration_get_protocol_level";
  os_log_type_t v17 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v24 = 0;
  if (__nwlog_fault(v17, &type, &v24))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)size_t length = 136446210;
        *(void *)&length[4] = "nw_path_flow_registration_get_protocol_level";
        _os_log_impl(&dword_1830D4000, v18, v19, "%{public}s called with null path", length, 0xCu);
      }
    }
    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v18 = __nwlog_obj();
      os_log_type_t v21 = type;
      BOOL v22 = os_log_type_enabled(v18, type);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)size_t length = 136446466;
          *(void *)&length[4] = "nw_path_flow_registration_get_protocol_level";
          __int16 v27 = 2082;
          uint64_t v28 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v18, v21, "%{public}s called with null path, dumping backtrace:%{public}s", length, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_37;
      }
      if (v22)
      {
        *(_DWORD *)size_t length = 136446210;
        *(void *)&length[4] = "nw_path_flow_registration_get_protocol_level";
        _os_log_impl(&dword_1830D4000, v18, v21, "%{public}s called with null path, no backtrace", length, 0xCu);
      }
    }
    else
    {
      BOOL v18 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)size_t length = 136446210;
        *(void *)&length[4] = "nw_path_flow_registration_get_protocol_level";
        _os_log_impl(&dword_1830D4000, v18, v23, "%{public}s called with null path, backtrace limit exceeded", length, 0xCu);
      }
    }
  }
LABEL_37:
  if (v17) {
    free(v17);
  }
  uint64_t v14 = 0;
LABEL_20:

  return v14;
}

BOOL nw_path_get_flow_registration_id(void *a1, _OWORD *a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    *a2 = *(_OWORD *)(v3 + 136);
    goto LABEL_3;
  }
  int v6 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v17 = "nw_path_get_flow_registration_id";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v17 = "nw_path_get_flow_registration_id";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v17 = "nw_path_get_flow_registration_id";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v17 = "nw_path_get_flow_registration_id";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v17 = "nw_path_get_flow_registration_id";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v7) {
    free(v7);
  }
LABEL_3:

  return v4 != 0;
}

BOOL nw_path_evaluator_get_client_id(void *a1, _OWORD *a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    *a2 = *((_OWORD *)v3 + 5);
    goto LABEL_3;
  }
  int v6 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v17 = "nw_path_evaluator_get_client_id";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v17 = "nw_path_evaluator_get_client_id";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null evaluator", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v17 = "nw_path_evaluator_get_client_id";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null evaluator, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v17 = "nw_path_evaluator_get_client_id";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null evaluator, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v17 = "nw_path_evaluator_get_client_id";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null evaluator, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v7) {
    free(v7);
  }
LABEL_3:

  return v4 != 0;
}

uint64_t nw_path_flow_registration_add_extra_interface_option(void *a1, void *a2)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (v3)
  {
    if (v4)
    {
      int v6 = (atomic_uchar *)v3[3];
      v34[0] = MEMORY[0x1E4F143A8];
      v34[1] = 3221225472;
      v34[2] = __nw_path_flow_registration_add_extra_interface_option_block_invoke;
      v34[3] = &unk_1E524AE18;
      id v7 = v4;
      id v35 = v7;
      if (nw_array_apply(v6, (uint64_t)v34))
      {
        uint64_t v8 = (id *)v7;
        os_log_type_t v9 = v8[3];

        if (nw_endpoint_get_address_family(v9) != 2)
        {
LABEL_11:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v15 = (id)gLogObj;
          if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)int buf = 136446978;
            uint64_t v39 = "nw_path_flow_registration_add_extra_interface_option";
            __int16 v40 = 2112;
            id v41 = v8;
            __int16 v42 = 1042;
            int v43 = 16;
            __int16 v44 = 2098;
            id v45 = v3 + 4;
            _os_log_impl(&dword_1830D4000, v15, OS_LOG_TYPE_INFO, "%{public}s Adding interface option_details %@ to flow %{public,uuid_t}.16P", buf, 0x26u);
          }

          uint64_t v16 = v3[3];
          if (!v16)
          {
            BOOL v17 = nw_array_create();
            __int16 v18 = (void *)v3[3];
            v3[3] = v17;

            uint64_t v16 = v3[3];
          }
          nw_array_append(v16, v8);
          uint64_t v12 = 1;
          goto LABEL_16;
        }
        int v10 = v8;
        id v11 = v10[7];

        if (v11)
        {

          goto LABEL_11;
        }
        os_log_type_t v13 = v10;
        id v14 = v13[8];

        if (v14) {
          goto LABEL_11;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v20 = (id)gLogObj;
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v39 = "nw_path_flow_registration_add_extra_interface_option";
          __int16 v40 = 2112;
          id v41 = v13;
          _os_log_impl(&dword_1830D4000, v20, OS_LOG_TYPE_DEFAULT, "%{public}s Wrong AF %@", buf, 0x16u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v9 = (id)gLogObj;
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v39 = "nw_path_flow_registration_add_extra_interface_option";
          __int16 v40 = 2112;
          id v41 = v7;
          _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_DEFAULT, "%{public}s Interface option details %@ already exists", buf, 0x16u);
        }
      }
      uint64_t v12 = 0;
LABEL_16:

      goto LABEL_17;
    }
    __int16 v25 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v39 = "nw_path_flow_registration_add_extra_interface_option";
    BOOL v22 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (__nwlog_fault(v22, &type, &v36))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v23 = __nwlog_obj();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v39 = "nw_path_flow_registration_add_extra_interface_option";
          _os_log_impl(&dword_1830D4000, v23, v26, "%{public}s called with null interface_option_details", buf, 0xCu);
        }
LABEL_52:

        goto LABEL_53;
      }
      if (!v36)
      {
        os_log_type_t v23 = __nwlog_obj();
        os_log_type_t v33 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v39 = "nw_path_flow_registration_add_extra_interface_option";
          _os_log_impl(&dword_1830D4000, v23, v33, "%{public}s called with null interface_option_details, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_52;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v23 = __nwlog_obj();
      os_log_type_t v30 = type;
      BOOL v31 = os_log_type_enabled(v23, type);
      if (!backtrace_string)
      {
        if (v31)
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v39 = "nw_path_flow_registration_add_extra_interface_option";
          _os_log_impl(&dword_1830D4000, v23, v30, "%{public}s called with null interface_option_details, no backtrace", buf, 0xCu);
        }
        goto LABEL_52;
      }
      if (v31)
      {
        *(_DWORD *)int buf = 136446466;
        uint64_t v39 = "nw_path_flow_registration_add_extra_interface_option";
        __int16 v40 = 2082;
        id v41 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v23, v30, "%{public}s called with null interface_option_details, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_40;
    }
  }
  else
  {
    os_log_type_t v21 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v39 = "nw_path_flow_registration_add_extra_interface_option";
    BOOL v22 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (__nwlog_fault(v22, &type, &v36))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v23 = __nwlog_obj();
        os_log_type_t v24 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v39 = "nw_path_flow_registration_add_extra_interface_option";
          _os_log_impl(&dword_1830D4000, v23, v24, "%{public}s called with null flow_registration", buf, 0xCu);
        }
        goto LABEL_52;
      }
      if (!v36)
      {
        os_log_type_t v23 = __nwlog_obj();
        os_log_type_t v32 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v39 = "nw_path_flow_registration_add_extra_interface_option";
          _os_log_impl(&dword_1830D4000, v23, v32, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_52;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v23 = __nwlog_obj();
      os_log_type_t v28 = type;
      BOOL v29 = os_log_type_enabled(v23, type);
      if (!backtrace_string)
      {
        if (v29)
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v39 = "nw_path_flow_registration_add_extra_interface_option";
          _os_log_impl(&dword_1830D4000, v23, v28, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
        }
        goto LABEL_52;
      }
      if (v29)
      {
        *(_DWORD *)int buf = 136446466;
        uint64_t v39 = "nw_path_flow_registration_add_extra_interface_option";
        __int16 v40 = 2082;
        id v41 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v23, v28, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_40:

      free(backtrace_string);
    }
  }
LABEL_53:
  if (v22) {
    free(v22);
  }
  uint64_t v12 = 0;
LABEL_17:

  return v12;
}

void sub_183BAEBE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_path_flow_registration_add_extra_interface_option_block_invoke(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "isEqual:") ^ 1;
}

void nw_path_flow_registration_remove_extra_interface_option(void *a1, void *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (!v3)
  {
    id v7 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v27 = "nw_path_flow_registration_remove_extra_interface_option";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v25 = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (!__nwlog_fault(v8, &v25, &v24)) {
      goto LABEL_39;
    }
    if (v25 == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v10 = v25;
      if (os_log_type_enabled(v9, v25))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v27 = "nw_path_flow_registration_remove_extra_interface_option";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null flow_registration", buf, 0xCu);
      }
    }
    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v14 = v25;
      BOOL v15 = os_log_type_enabled(v9, v25);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)int buf = 136446466;
          __int16 v27 = "nw_path_flow_registration_remove_extra_interface_option";
          __int16 v28 = 2082;
          BOOL v29 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_39:
        if (!v8) {
          goto LABEL_5;
        }
LABEL_40:
        free(v8);
        goto LABEL_5;
      }
      if (v15)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v27 = "nw_path_flow_registration_remove_extra_interface_option";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v19 = v25;
      if (os_log_type_enabled(v9, v25))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v27 = "nw_path_flow_registration_remove_extra_interface_option";
        _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_38:

    goto LABEL_39;
  }
  if (v4)
  {
    uint64_t v6 = v3[3];
    if (v6)
    {
      v21[0] = MEMORY[0x1E4F143A8];
      v21[1] = 3221225472;
      v21[2] = __nw_path_flow_registration_remove_extra_interface_option_block_invoke;
      v21[3] = &unk_1E5248008;
      id v22 = v4;
      os_log_type_t v23 = v3;
      nw_array_remove_objects(v6, (uint64_t)v21);
    }
    goto LABEL_5;
  }
  id v11 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  __int16 v27 = "nw_path_flow_registration_remove_extra_interface_option";
  uint64_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v25 = OS_LOG_TYPE_ERROR;
  char v24 = 0;
  if (!__nwlog_fault(v8, &v25, &v24)) {
    goto LABEL_39;
  }
  if (v25 == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v9 = __nwlog_obj();
    os_log_type_t v12 = v25;
    if (os_log_type_enabled(v9, v25))
    {
      *(_DWORD *)int buf = 136446210;
      __int16 v27 = "nw_path_flow_registration_remove_extra_interface_option";
      _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null details", buf, 0xCu);
    }
    goto LABEL_38;
  }
  if (!v24)
  {
    os_log_type_t v9 = __nwlog_obj();
    os_log_type_t v20 = v25;
    if (os_log_type_enabled(v9, v25))
    {
      *(_DWORD *)int buf = 136446210;
      __int16 v27 = "nw_path_flow_registration_remove_extra_interface_option";
      _os_log_impl(&dword_1830D4000, v9, v20, "%{public}s called with null details, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_38;
  }
  uint64_t v16 = (char *)__nw_create_backtrace_string();
  os_log_type_t v9 = __nwlog_obj();
  os_log_type_t v17 = v25;
  BOOL v18 = os_log_type_enabled(v9, v25);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)int buf = 136446210;
      __int16 v27 = "nw_path_flow_registration_remove_extra_interface_option";
      _os_log_impl(&dword_1830D4000, v9, v17, "%{public}s called with null details, no backtrace", buf, 0xCu);
    }
    goto LABEL_38;
  }
  if (v18)
  {
    *(_DWORD *)int buf = 136446466;
    __int16 v27 = "nw_path_flow_registration_remove_extra_interface_option";
    __int16 v28 = 2082;
    BOOL v29 = v16;
    _os_log_impl(&dword_1830D4000, v9, v17, "%{public}s called with null details, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v8) {
    goto LABEL_40;
  }
LABEL_5:
}

uint64_t __nw_path_flow_registration_remove_extra_interface_option_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  uint64_t v4 = [*(id *)(a1 + 32) isEqual:v3];
  if (v4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v5 = (id)gLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
    {
      uint64_t v6 = *(void *)(a1 + 40) + 32;
      int v8 = 136446978;
      os_log_type_t v9 = "nw_path_flow_registration_remove_extra_interface_option_block_invoke";
      __int16 v10 = 2112;
      id v11 = v3;
      __int16 v12 = 1042;
      int v13 = 16;
      __int16 v14 = 2098;
      uint64_t v15 = v6;
      _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_INFO, "%{public}s Removing %@ from %{public,uuid_t}.16P", (uint8_t *)&v8, 0x26u);
    }
  }
  return v4;
}

void sub_183BAF288(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_path_flow_registration_remove_all_interface_options(void *a1)
{
  *(void *)&v17[13] = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v2 = (id)gLogObj;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)int buf = 136446722;
      uint64_t v15 = "nw_path_flow_registration_remove_all_interface_options";
      __int16 v16 = 1042;
      *(_DWORD *)os_log_type_t v17 = 16;
      v17[2] = 2098;
      *(void *)&v17[3] = v1 + 4;
      _os_log_impl(&dword_1830D4000, v2, OS_LOG_TYPE_INFO, "%{public}s Removing all interface option_details from flow %{public,uuid_t}.16P", buf, 0x1Cu);
    }

    id v3 = (void *)v1[3];
    v1[3] = 0;

    goto LABEL_5;
  }
  uint64_t v4 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  uint64_t v15 = "nw_path_flow_registration_remove_all_interface_options";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v15 = "nw_path_flow_registration_remove_all_interface_options";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null flow_registration", buf, 0xCu);
      }
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v15 = "nw_path_flow_registration_remove_all_interface_options";
          __int16 v16 = 2082;
          *(void *)os_log_type_t v17 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v10)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v15 = "nw_path_flow_registration_remove_all_interface_options";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v15 = "nw_path_flow_registration_remove_all_interface_options";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_22:
  if (v5) {
    free(v5);
  }
LABEL_5:
}

void nw_path_flow_registration_override_traffic_class(void *a1, int a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  uint64_t v4 = v3;
  if (v3)
  {
    *((_DWORD *)v3 + 36) = a2;
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  __int16 v16 = "nw_path_flow_registration_override_traffic_class";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v16 = "nw_path_flow_registration_override_traffic_class";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null flow_registration", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          __int16 v16 = "nw_path_flow_registration_override_traffic_class";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v16 = "nw_path_flow_registration_override_traffic_class";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v16 = "nw_path_flow_registration_override_traffic_class";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

void nw_path_flow_registration_override_interface_types(void *a1, int a2, int a3, int a4, int a5, int a6)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  id v11 = a1;
  os_log_type_t v12 = v11;
  if (v11)
  {
    if (a2) {
      char v13 = 8;
    }
    else {
      char v13 = 0;
    }
    if (a4) {
      char v14 = 32;
    }
    else {
      char v14 = 0;
    }
    if (a5) {
      char v15 = 64;
    }
    else {
      char v15 = 0;
    }
    if (a3) {
      char v16 = 16;
    }
    else {
      char v16 = 0;
    }
    if (a6) {
      char v17 = 0x80;
    }
    else {
      char v17 = 0;
    }
    *((unsigned char *)v11 + 148) = (v16 | v13 | v14 | v15 | v17) & 0xF8 | *((unsigned char *)v11 + 148) & 7;
    goto LABEL_18;
  }
  BOOL v18 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  BOOL v29 = "nw_path_flow_registration_override_interface_types";
  uint64_t v19 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v26 = 0;
  if (__nwlog_fault(v19, &type, &v26))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v29 = "nw_path_flow_registration_override_interface_types";
        _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s called with null flow_registration", buf, 0xCu);
      }
    }
    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v20 = __nwlog_obj();
      os_log_type_t v23 = type;
      BOOL v24 = os_log_type_enabled(v20, type);
      if (backtrace_string)
      {
        if (v24)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v29 = "nw_path_flow_registration_override_interface_types";
          __int16 v30 = 2082;
          BOOL v31 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v20, v23, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_35;
      }
      if (v24)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v29 = "nw_path_flow_registration_override_interface_types";
        _os_log_impl(&dword_1830D4000, v20, v23, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v20 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v29 = "nw_path_flow_registration_override_interface_types";
        _os_log_impl(&dword_1830D4000, v20, v25, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_35:
  if (v19) {
    free(v19);
  }
LABEL_18:
}

void nw_path_flow_registration_override_evaluator(void *a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    objc_storeStrong(v3 + 17, a2);
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  char v16 = "nw_path_flow_registration_override_evaluator";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v16 = "nw_path_flow_registration_override_evaluator";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null flow_registration", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          char v16 = "nw_path_flow_registration_override_evaluator";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        char v16 = "nw_path_flow_registration_override_evaluator";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v16 = "nw_path_flow_registration_override_evaluator";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

void nw_path_override_local_endpoint(void *a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    objc_storeStrong(v3 + 10, a2);
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  char v16 = "nw_path_override_local_endpoint";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v16 = "nw_path_override_local_endpoint";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          char v16 = "nw_path_override_local_endpoint";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        char v16 = "nw_path_override_local_endpoint";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v16 = "nw_path_override_local_endpoint";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

void nw_path_override_interface(void *a1, void *a2, char a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = a2;
  if (v5)
  {
    objc_storeStrong(v5 + 11, a2);
    *((unsigned char *)v5 + 476) = *((unsigned char *)v5 + 476) & 0xFE | a3;
    goto LABEL_3;
  }
  os_log_type_t v7 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  BOOL v18 = "nw_path_override_interface";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v18 = "nw_path_override_interface";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v18 = "nw_path_override_interface";
          __int16 v19 = 2082;
          os_log_type_t v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v13)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v18 = "nw_path_override_interface";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v18 = "nw_path_override_interface";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v8) {
    free(v8);
  }
LABEL_3:
}

void nw_path_override_viable(void *a1, int a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    if (a2) {
      char v5 = 8;
    }
    else {
      char v5 = 0;
    }
    *((unsigned char *)v3 + 474) = *((unsigned char *)v3 + 474) & 0xF7 | v5;
    goto LABEL_6;
  }
  id v6 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  __int16 v17 = "nw_path_override_viable";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v17 = "nw_path_override_viable";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)int buf = 136446466;
          __int16 v17 = "nw_path_override_viable";
          __int16 v18 = 2082;
          __int16 v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v12)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v17 = "nw_path_override_viable";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v17 = "nw_path_override_viable";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_23:
  if (v7) {
    free(v7);
  }
LABEL_6:
}

id *nw_path_create_static(void *a1, void *a2, int a3, _OWORD *a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  id v17 = a1;
  id v18 = a2;
  id v40 = a9;
  id v41 = a10;
  id v42 = a11;
  uint64_t v39 = v17;
  __int16 v19 = v17;
  uint64_t v20 = v18;
  uint64_t v21 = nw_path_create(v19, v18);
  p_isa = (id *)&v21->super.isa;
  if (v21)
  {
    v21->status = a3;
    *(_OWORD *)v21->client_id = *a4;
    if (a5) {
      char v23 = 32;
    }
    else {
      char v23 = 0;
    }
    if (a6) {
      char v24 = 16;
    }
    else {
      char v24 = 0;
    }
    if (a7) {
      char v25 = 64;
    }
    else {
      char v25 = 0;
    }
    if (a8) {
      char v26 = 0x80;
    }
    else {
      char v26 = 0;
    }
    *((unsigned char *)v21 + 473) = (v24 | v23 | v25 | v26) & 0xF0 | *((unsigned char *)v21 + 473) & 0xF;
    objc_storeStrong((id *)&v21->direct, a9);
    objc_storeStrong(p_isa + 13, a10);
    objc_storeStrong(p_isa + 28, a11);
    __int16 v27 = p_isa;
    goto LABEL_22;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v28 = (id)gLogObj;
  *(_DWORD *)int buf = 136446210;
  uint64_t v46 = "nw_path_create_static";
  BOOL v29 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v43 = 0;
  if (!__nwlog_fault(v29, &type, &v43)) {
    goto LABEL_20;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v30 = (id)gLogObj;
    os_log_type_t v31 = type;
    if (os_log_type_enabled(v30, type))
    {
      *(_DWORD *)int buf = 136446210;
      uint64_t v46 = "nw_path_create_static";
      _os_log_impl(&dword_1830D4000, v30, v31, "%{public}s nw_path_create failed", buf, 0xCu);
    }
LABEL_19:

    goto LABEL_20;
  }
  if (!v43)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v30 = (id)gLogObj;
    os_log_type_t v37 = type;
    if (os_log_type_enabled(v30, type))
    {
      *(_DWORD *)int buf = 136446210;
      uint64_t v46 = "nw_path_create_static";
      _os_log_impl(&dword_1830D4000, v30, v37, "%{public}s nw_path_create failed, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_19;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v34 = (id)gLogObj;
  os_log_type_t v35 = type;
  BOOL v36 = os_log_type_enabled(v34, type);
  if (!backtrace_string)
  {
    if (v36)
    {
      *(_DWORD *)int buf = 136446210;
      uint64_t v46 = "nw_path_create_static";
      _os_log_impl(&dword_1830D4000, v34, v35, "%{public}s nw_path_create failed, no backtrace", buf, 0xCu);
    }

LABEL_20:
    if (!v29) {
      goto LABEL_22;
    }
LABEL_21:
    free(v29);
    goto LABEL_22;
  }
  if (v36)
  {
    *(_DWORD *)int buf = 136446466;
    uint64_t v46 = "nw_path_create_static";
    __int16 v47 = 2082;
    os_log_type_t v48 = backtrace_string;
    _os_log_impl(&dword_1830D4000, v34, v35, "%{public}s nw_path_create failed, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(backtrace_string);
  if (v29) {
    goto LABEL_21;
  }
LABEL_22:

  return p_isa;
}

void sub_183BB0A18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, void *a17)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_path *nw_path_create_from_tlv(void *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  char v5 = nw_path_create(a1, 0);
  id v6 = v5;
  if (!v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v8 = (id)gLogObj;
    *(_DWORD *)int buf = 136446210;
    char v25 = "nw_path_create_from_tlv";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (!__nwlog_fault(v9, &type, &v22)) {
      goto LABEL_37;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (id)gLogObj;
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v25 = "nw_path_create_from_tlv";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s nw_path_create failed", buf, 0xCu);
      }
      goto LABEL_36;
    }
    if (!v22)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (id)gLogObj;
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v25 = "nw_path_create_from_tlv";
        _os_log_impl(&dword_1830D4000, v10, v19, "%{public}s nw_path_create failed, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_36;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v10 = (id)gLogObj;
    os_log_type_t v15 = type;
    BOOL v16 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)int buf = 136446210;
        char v25 = "nw_path_create_from_tlv";
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s nw_path_create failed, no backtrace", buf, 0xCu);
      }
      goto LABEL_36;
    }
    if (v16)
    {
      *(_DWORD *)int buf = 136446466;
      char v25 = "nw_path_create_from_tlv";
      __int16 v26 = 2082;
      __int16 v27 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s nw_path_create failed, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_23;
  }
  if (!nw_path_parse_necp_result(v5, a2, a3))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v12 = (id)gLogObj;
    *(_DWORD *)int buf = 136446210;
    char v25 = "nw_path_create_from_tlv";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (!__nwlog_fault(v9, &type, &v22)) {
      goto LABEL_37;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (id)gLogObj;
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v25 = "nw_path_create_from_tlv";
        _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s nw_path_parse_necp_result failed", buf, 0xCu);
      }
LABEL_36:

LABEL_37:
      if (!v9)
      {
LABEL_39:
        os_log_type_t v7 = 0;
        goto LABEL_40;
      }
LABEL_38:
      free(v9);
      goto LABEL_39;
    }
    if (!v22)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (id)gLogObj;
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v25 = "nw_path_create_from_tlv";
        _os_log_impl(&dword_1830D4000, v10, v20, "%{public}s nw_path_parse_necp_result failed, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_36;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v10 = (id)gLogObj;
    os_log_type_t v17 = type;
    BOOL v18 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)int buf = 136446210;
        char v25 = "nw_path_create_from_tlv";
        _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s nw_path_parse_necp_result failed, no backtrace", buf, 0xCu);
      }
      goto LABEL_36;
    }
    if (v18)
    {
      *(_DWORD *)int buf = 136446466;
      char v25 = "nw_path_create_from_tlv";
      __int16 v26 = 2082;
      __int16 v27 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s nw_path_parse_necp_result failed, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_23:

    free(backtrace_string);
    if (!v9) {
      goto LABEL_39;
    }
    goto LABEL_38;
  }
  nw_path_snapshot_path(v6);
  os_log_type_t v7 = v6;
LABEL_40:

  return v7;
}

void sub_183BB0FFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_path_is_preferred(void *a1, void *a2, int a3)
{
  char v5 = a1;
  id v6 = a2;
  os_log_type_t v7 = v6;
  uint64_t v8 = 0;
  if (v5 && v5 != v6)
  {
    if (!v6) {
      goto LABEL_10;
    }
    int v9 = *((_DWORD *)v5 + 94);
    int v10 = *((_DWORD *)v6 + 94);
    if (v9 == v10) {
      goto LABEL_17;
    }
    if (v9 == 1 && v10 == 2) {
      goto LABEL_10;
    }
    if (v10 != 1 || v9 != 2)
    {
LABEL_17:
      if (a3 && !nw_interface_shallow_compare(v5[12], v6[12]))
      {
LABEL_10:
        uint64_t v8 = 1;
        goto LABEL_14;
      }
    }
    uint64_t v8 = 0;
  }
LABEL_14:

  return v8;
}

uint64_t __nw_path_evaluator_cancel_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t nw_path_get_custom_ethertype(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  int v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1[192];
    goto LABEL_3;
  }
  char v5 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  BOOL v16 = "nw_path_get_custom_ethertype";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v16 = "nw_path_get_custom_ethertype";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v16 = "nw_path_get_custom_ethertype";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v16 = "nw_path_get_custom_ethertype";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v16 = "nw_path_get_custom_ethertype";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_path_get_flow_divert_unit(void *a1)
{
  id v1 = a1;
  if (v1 && v1[66] == 4) {
    uint64_t v2 = v1[67];
  }
  else {
    uint64_t v2 = 0;
  }

  return v2;
}

uint64_t nw_path_get_flow_divert_aggregate_unit(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 352);
  }
  return result;
}

uint64_t nw_path_get_filter_unit(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 272);
  }
  return result;
}

uint64_t nw_path_get_interface_time_delta(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1[92];
    goto LABEL_3;
  }
  char v5 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  BOOL v16 = "nw_path_get_interface_time_delta";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v16 = "nw_path_get_interface_time_delta";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v16 = "nw_path_get_interface_time_delta";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v16 = "nw_path_get_interface_time_delta";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v16 = "nw_path_get_interface_time_delta";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_path_get_ipv6_network_signature(void *a1, void *a2, unsigned char *a3)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  char v5 = a1;
  id v6 = v5;
  if (!v5)
  {
    int v9 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v31 = "nw_path_get_ipv6_network_signature";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v31 = "nw_path_get_ipv6_network_signature";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null path", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v28)
    {
      BOOL v11 = __nwlog_obj();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v31 = "nw_path_get_ipv6_network_signature";
        _os_log_impl(&dword_1830D4000, v11, v24, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v11 = __nwlog_obj();
    os_log_type_t v18 = type;
    BOOL v19 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v19)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v31 = "nw_path_get_ipv6_network_signature";
        _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v19)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v31 = "nw_path_get_ipv6_network_signature";
      __int16 v32 = 2082;
      os_log_type_t v33 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_36;
  }
  if (!a2)
  {
    char v13 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v31 = "nw_path_get_ipv6_network_signature";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v11 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v31 = "nw_path_get_ipv6_network_signature";
        _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null signature", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v28)
    {
      BOOL v11 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v31 = "nw_path_get_ipv6_network_signature";
        _os_log_impl(&dword_1830D4000, v11, v25, "%{public}s called with null signature, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v11 = __nwlog_obj();
    os_log_type_t v20 = type;
    BOOL v21 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v31 = "nw_path_get_ipv6_network_signature";
        _os_log_impl(&dword_1830D4000, v11, v20, "%{public}s called with null signature, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v21)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v31 = "nw_path_get_ipv6_network_signature";
      __int16 v32 = 2082;
      os_log_type_t v33 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v11, v20, "%{public}s called with null signature, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_36;
  }
  if (!a3)
  {
    os_log_type_t v15 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v31 = "nw_path_get_ipv6_network_signature";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v31 = "nw_path_get_ipv6_network_signature";
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null signature_len", buf, 0xCu);
      }
LABEL_54:

LABEL_55:
      if (v10) {
        free(v10);
      }
      goto LABEL_57;
    }
    if (!v28)
    {
      BOOL v11 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v31 = "nw_path_get_ipv6_network_signature";
        _os_log_impl(&dword_1830D4000, v11, v26, "%{public}s called with null signature_len, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v11 = __nwlog_obj();
    os_log_type_t v22 = type;
    BOOL v23 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v31 = "nw_path_get_ipv6_network_signature";
        _os_log_impl(&dword_1830D4000, v11, v22, "%{public}s called with null signature_len, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v23)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v31 = "nw_path_get_ipv6_network_signature";
      __int16 v32 = 2082;
      os_log_type_t v33 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v11, v22, "%{public}s called with null signature_len, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_36:

    free(backtrace_string);
    goto LABEL_55;
  }
  if (!nw_path_network_is_satisfied_update_reason(v5, 0) || (direct = v6->direct) == 0)
  {
LABEL_57:
    uint64_t ipv6_network_signature = 0;
    goto LABEL_58;
  }
  uint64_t ipv6_network_signature = nw_interface_get_ipv6_network_signature(direct, a2, a3);
LABEL_58:

  return ipv6_network_signature;
}

void sub_183BB1D2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_path_flow_registration_fast_open_blocked(NWConcrete_nw_path *a1, NWConcrete_nw_path_flow_registration *a2)
{
  uint64_t v2 = (unsigned __int8 *)nw_path_copy_flow_for_registration(a1, a2);
  if (v2) {
    uint64_t v3 = (v2[185] >> 3) & 1;
  }
  else {
    uint64_t v3 = 0;
  }

  return v3;
}

uint64_t nw_path_link_quality_abort(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[474] >> 6) & 1;
    goto LABEL_3;
  }
  char v5 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v16 = "nw_path_link_quality_abort";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_path_link_quality_abort";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v16 = "nw_path_link_quality_abort";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_path_link_quality_abort";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_path_link_quality_abort";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_path_listener_is_interface_specific(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[475] >> 2) & 1;
    goto LABEL_3;
  }
  char v5 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v16 = "nw_path_listener_is_interface_specific";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_path_listener_is_interface_specific";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v16 = "nw_path_listener_is_interface_specific";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_path_listener_is_interface_specific";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_path_listener_is_interface_specific";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

size_t nw_path_signature_changed_from_previous(void *a1, void *a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  char v5 = v4;
  if (!v3)
  {
    os_log_type_t v8 = __nwlog_obj();
    *(_DWORD *)__s1 = 136446210;
    *(void *)&__s1[4] = "nw_path_signature_changed_from_previous";
    int v9 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(__s2[0]) = 0;
    if (!__nwlog_fault(v9, type, __s2)) {
      goto LABEL_43;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v11 = type[0];
      if (os_log_type_enabled(v10, type[0]))
      {
        *(_DWORD *)__s1 = 136446210;
        *(void *)&__s1[4] = "nw_path_signature_changed_from_previous";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null path", __s1, 0xCu);
      }
      goto LABEL_42;
    }
    if (!LOBYTE(__s2[0]))
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v19 = type[0];
      if (os_log_type_enabled(v10, type[0]))
      {
        *(_DWORD *)__s1 = 136446210;
        *(void *)&__s1[4] = "nw_path_signature_changed_from_previous";
        _os_log_impl(&dword_1830D4000, v10, v19, "%{public}s called with null path, backtrace limit exceeded", __s1, 0xCu);
      }
      goto LABEL_42;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v10 = __nwlog_obj();
    os_log_type_t v15 = type[0];
    BOOL v16 = os_log_type_enabled(v10, type[0]);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)__s1 = 136446210;
        *(void *)&__s1[4] = "nw_path_signature_changed_from_previous";
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null path, no backtrace", __s1, 0xCu);
      }
      goto LABEL_42;
    }
    if (v16)
    {
      *(_DWORD *)__s1 = 136446466;
      *(void *)&__s1[4] = "nw_path_signature_changed_from_previous";
      *(_WORD *)&__s1[12] = 2082;
      *(void *)&__s1[14] = backtrace_string;
      _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null path, dumping backtrace:%{public}s", __s1, 0x16u);
    }
    goto LABEL_30;
  }
  if (!v4)
  {
    os_log_type_t v12 = __nwlog_obj();
    *(_DWORD *)__s1 = 136446210;
    *(void *)&__s1[4] = "nw_path_signature_changed_from_previous";
    int v9 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(__s2[0]) = 0;
    if (!__nwlog_fault(v9, type, __s2)) {
      goto LABEL_43;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v13 = type[0];
      if (os_log_type_enabled(v10, type[0]))
      {
        *(_DWORD *)__s1 = 136446210;
        *(void *)&__s1[4] = "nw_path_signature_changed_from_previous";
        _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null previous_path", __s1, 0xCu);
      }
LABEL_42:

LABEL_43:
      if (v9) {
        free(v9);
      }
      goto LABEL_7;
    }
    if (!LOBYTE(__s2[0]))
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v20 = type[0];
      if (os_log_type_enabled(v10, type[0]))
      {
        *(_DWORD *)__s1 = 136446210;
        *(void *)&__s1[4] = "nw_path_signature_changed_from_previous";
        _os_log_impl(&dword_1830D4000, v10, v20, "%{public}s called with null previous_path, backtrace limit exceeded", __s1, 0xCu);
      }
      goto LABEL_42;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v10 = __nwlog_obj();
    os_log_type_t v17 = type[0];
    BOOL v18 = os_log_type_enabled(v10, type[0]);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)__s1 = 136446210;
        *(void *)&__s1[4] = "nw_path_signature_changed_from_previous";
        _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s called with null previous_path, no backtrace", __s1, 0xCu);
      }
      goto LABEL_42;
    }
    if (v18)
    {
      *(_DWORD *)__s1 = 136446466;
      *(void *)&__s1[4] = "nw_path_signature_changed_from_previous";
      *(_WORD *)&__s1[12] = 2082;
      *(void *)&__s1[14] = backtrace_string;
      _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s called with null previous_path, dumping backtrace:%{public}s", __s1, 0x16u);
    }
LABEL_30:

    free(backtrace_string);
    goto LABEL_43;
  }
  memset(__s1, 0, 20);
  *(void *)os_log_type_t type = 0;
  uint64_t v29 = 0;
  int v30 = 0;
  __int16 __n = 5140;
  __s2[0] = 0;
  __s2[1] = 0;
  int v27 = 0;
  unsigned __int8 v22 = 20;
  __n_2[0] = 0;
  __n_2[1] = 0;
  int v25 = 0;
  unsigned __int8 v21 = 20;
  nw_path_get_ipv4_network_signature(v4, __s1, (unsigned char *)&__n + 1);
  nw_path_get_ipv6_network_signature(v5, type, &__n);
  nw_path_get_ipv4_network_signature(v3, __s2, &v22);
  nw_path_get_ipv6_network_signature(v3, __n_2, &v21);
  if (HIBYTE(__n) != v22
    || (size_t v6 = __n, __n != v21)
    || HIBYTE(__n) && memcmp(__s1, __s2, HIBYTE(__n)))
  {
LABEL_7:
    size_t v6 = 1;
    goto LABEL_8;
  }
  if (v6) {
    size_t v6 = memcmp(type, __n_2, v6) != 0;
  }
LABEL_8:

  return v6;
}

void sub_183BB2824(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_path_get_connected_interface_index(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = v1[11];
    if (v3)
    {
      uint64_t v4 = *((unsigned int *)v3 + 2);
    }
    else
    {
      *(void *)int buf = 0;
      *(void *)&buf[8] = buf;
      int v19 = 0;
      *(void *)&buf[16] = 0x2020000000;
      char v5 = v1[9];
      v15[0] = MEMORY[0x1E4F143A8];
      v15[1] = 3221225472;
      void v15[2] = __nw_path_get_connected_interface_index_block_invoke;
      v15[3] = &unk_1E5248058;
      void v15[4] = buf;
      nw_array_apply(v5, (uint64_t)v15);
      uint64_t v4 = *(unsigned int *)(*(void *)&buf[8] + 24);
      _Block_object_dispose(buf, 8);
    }
    goto LABEL_5;
  }
  os_log_type_t v7 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_path_get_connected_interface_index";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v8, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_get_connected_interface_index";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_path_get_connected_interface_index";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v13)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_get_connected_interface_index";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_get_connected_interface_index";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_22:
  if (v8) {
    free(v8);
  }
  uint64_t v4 = 0;
LABEL_5:

  return v4;
}

uint64_t __nw_path_get_connected_interface_index_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  char v5 = v4;
  uint64_t v6 = *((void *)v4 + 2);
  if (v6 && (*((unsigned char *)v4 + 185) & 1) != 0)
  {
    uint64_t v7 = 0;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(_DWORD *)(v6 + 8);
  }
  else
  {
    uint64_t v7 = 1;
  }

  return v7;
}

uint64_t nw_path_get_alternate_path_state(void *a1, void *a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (!v3)
  {
    BOOL v13 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v24 = "nw_path_get_alternate_path_state";
    os_log_type_t v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v14, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v15 = __nwlog_obj();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v24 = "nw_path_get_alternate_path_state";
          _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s called with null connected_path", buf, 0xCu);
        }
      }
      else if (v21)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v15 = __nwlog_obj();
        os_log_type_t v18 = type;
        BOOL v19 = os_log_type_enabled(v15, type);
        if (backtrace_string)
        {
          if (v19)
          {
            *(_DWORD *)int buf = 136446466;
            os_log_type_t v24 = "nw_path_get_alternate_path_state";
            __int16 v25 = 2082;
            os_log_type_t v26 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v15, v18, "%{public}s called with null connected_path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_35;
        }
        if (v19)
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v24 = "nw_path_get_alternate_path_state";
          _os_log_impl(&dword_1830D4000, v15, v18, "%{public}s called with null connected_path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v15 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v24 = "nw_path_get_alternate_path_state";
          _os_log_impl(&dword_1830D4000, v15, v20, "%{public}s called with null connected_path, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_35:
    if (v14) {
      free(v14);
    }
    uint64_t v6 = 0;
    goto LABEL_9;
  }
  BOOL is_viable = nw_path_is_viable(v3);
  if (v4 && v4[94] == 1 && (v3[66] != 4 || !v3[67]))
  {
    if (is_viable && v3[94] != 2)
    {
      os_log_type_t v8 = nw_path_copy_connected_interface(v3);
      int v9 = v8;
      uint64_t v6 = 0;
      if (v3[66] != 6 && v8)
      {
        os_log_type_t v10 = v8;
        int v11 = *((_DWORD *)v10 + 24);

        if (v11 == 4)
        {
          uint64_t v6 = 0;

          goto LABEL_9;
        }
        int v12 = *((_DWORD *)v10 + 2);
        uint64_t v6 = v12 != nw_path_get_interface_index(v4);
      }

      goto LABEL_9;
    }
    uint64_t v6 = 1;
  }
  else
  {
    uint64_t v6 = v3[94] == 3 && !is_viable;
  }
LABEL_9:

  return v6;
}

void sub_183BB2F24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_path_get_scoped_interface_index(void *a1)
{
  id v1 = a1;
  if (v1 && ((int v2 = v1[66], v2 != 12) ? (v3 = v2 == 6) : (v3 = 1), v3)) {
    uint64_t v4 = v1[67];
  }
  else {
    uint64_t v4 = 0;
  }

  return v4;
}

char *nw_path_nat64_prefixes(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  int v2 = v1;
  if (v1)
  {
    BOOL v3 = v1 + 392;
    goto LABEL_3;
  }
  char v5 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v16 = "nw_path_nat64_prefixes";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_path_nat64_prefixes";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v16 = "nw_path_nat64_prefixes";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_path_nat64_prefixes";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_path_nat64_prefixes";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  BOOL v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_path_has_kernel_extension_filter(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  int v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[476] >> 3) & 1;
    goto LABEL_3;
  }
  char v5 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v16 = "nw_path_has_kernel_extension_filter";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_path_has_kernel_extension_filter";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v16 = "nw_path_has_kernel_extension_filter";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_path_has_kernel_extension_filter";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_path_has_kernel_extension_filter";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_path_has_custom_pf_rules(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  int v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[476] >> 4) & 1;
    goto LABEL_3;
  }
  char v5 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v16 = "nw_path_has_custom_pf_rules";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_path_has_custom_pf_rules";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v16 = "nw_path_has_custom_pf_rules";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_path_has_custom_pf_rules";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_path_has_custom_pf_rules";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_path_has_application_level_firewall(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  int v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[476] >> 5) & 1;
    goto LABEL_3;
  }
  char v5 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v16 = "nw_path_has_application_level_firewall";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_path_has_application_level_firewall";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v16 = "nw_path_has_application_level_firewall";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_path_has_application_level_firewall";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_path_has_application_level_firewall";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_path_has_parental_controls(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  int v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[476] >> 6) & 1;
    goto LABEL_3;
  }
  char v5 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v16 = "nw_path_has_parental_controls";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_path_has_parental_controls";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v16 = "nw_path_has_parental_controls";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_path_has_parental_controls";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_path_has_parental_controls";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_path_is_eligible_for_CrazyIvan46(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  int v2 = v1;
  if (!v1)
  {
    char v5 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v17 = "nw_path_is_eligible_for_CrazyIvan46";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v7 = __nwlog_obj();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)int buf = 136446210;
          __int16 v17 = "nw_path_is_eligible_for_CrazyIvan46";
          _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v7 = __nwlog_obj();
        os_log_type_t v10 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)int buf = 136446466;
            __int16 v17 = "nw_path_is_eligible_for_CrazyIvan46";
            __int16 v18 = 2082;
            uint64_t v19 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }
        if (v11)
        {
          *(_DWORD *)int buf = 136446210;
          __int16 v17 = "nw_path_is_eligible_for_CrazyIvan46";
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v7 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)int buf = 136446210;
          __int16 v17 = "nw_path_is_eligible_for_CrazyIvan46";
          _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_23:
    if (v6) {
      free(v6);
    }
    goto LABEL_25;
  }
  nw_path_update_dns(v1);
  if ((*((unsigned char *)v2 + 473) & 0xC0) != 0x80)
  {
LABEL_25:
    uint64_t v4 = 0;
    goto LABEL_26;
  }
  resolver_configs = v2->resolver_configs;
  if (!resolver_configs || resolver_configs[3].super.super.isa == resolver_configs[2].super.super.isa) {
    uint64_t v4 = *((unsigned char *)v2 + 474) & 1;
  }
  else {
    uint64_t v4 = 1;
  }
LABEL_26:

  return v4;
}

void sub_183BB3F64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_path_is_override_expensive(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  int v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[475] >> 3) & 1;
    goto LABEL_3;
  }
  char v5 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v16 = "nw_path_is_override_expensive";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_path_is_override_expensive";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v16 = "nw_path_is_override_expensive";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_path_is_override_expensive";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_path_is_override_expensive";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_path_is_override_constrained(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  int v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[475] >> 4) & 1;
    goto LABEL_3;
  }
  char v5 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v16 = "nw_path_is_override_constrained";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_path_is_override_constrained";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v16 = "nw_path_is_override_constrained";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_path_is_override_constrained";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_path_is_override_constrained";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_path_get_reason_description(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  int v2 = v1;
  if (v1)
  {
    uint64_t v3 = *((void *)v1 + 31);
    goto LABEL_3;
  }
  char v5 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v16 = "nw_path_get_reason_description";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_path_get_reason_description";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v16 = "nw_path_get_reason_description";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_path_get_reason_description";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_path_get_reason_description";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

NWConcrete_nw_interface *nw_path_copy_interface_from_cache(unsigned int a1)
{
  if (nw_context_copy_implicit_context::onceToken != -1) {
    dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
  }
  id v2 = (id)nw_context_copy_implicit_context::implicit_context;
  uint64_t v3 = nw_path_copy_interface_with_generation(v2, a1, 0);

  return v3;
}

void sub_183BB47B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_path_agent_action(NWConcrete_nw_path *a1, const unsigned __int8 *a2, int a3)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  char v5 = a1;
  if (!v5)
  {
    os_log_type_t v31 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v64 = "nw_path_agent_action";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v61 = 0;
    if (!__nwlog_fault(v7, &type, &v61)) {
      goto LABEL_30;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v32 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v64 = "nw_path_agent_action";
        _os_log_impl(&dword_1830D4000, v8, v32, "%{public}s called with null path", buf, 0xCu);
      }
      goto LABEL_29;
    }
    if (!v61)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v47 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v64 = "nw_path_agent_action";
        _os_log_impl(&dword_1830D4000, v8, v47, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_29;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v8 = __nwlog_obj();
    os_log_type_t v34 = type;
    BOOL v35 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v35)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v64 = "nw_path_agent_action";
        _os_log_impl(&dword_1830D4000, v8, v34, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
      goto LABEL_29;
    }
    if (v35)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v64 = "nw_path_agent_action";
      __int16 v65 = 2082;
      *(void *)os_log_type_t v66 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v8, v34, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_62;
  }
  if (uuid_is_null(a2))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v64 = "nw_path_agent_action";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v61 = 0;
    if (!__nwlog_fault(v7, &type, &v61)) {
      goto LABEL_30;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (id)gLogObj;
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v64 = "nw_path_agent_action";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null agent_uuid", buf, 0xCu);
      }
    }
    else if (v61)
    {
      __int16 v18 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (id)gLogObj;
      os_log_type_t v19 = type;
      BOOL v20 = os_log_type_enabled(v8, type);
      if (v18)
      {
        if (v20)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v64 = "nw_path_agent_action";
          __int16 v65 = 2082;
          *(void *)os_log_type_t v66 = v18;
          _os_log_impl(&dword_1830D4000, v8, v19, "%{public}s called with null agent_uuid, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v18);
        if (!v7) {
          goto LABEL_32;
        }
        goto LABEL_31;
      }
      if (v20)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v64 = "nw_path_agent_action";
        _os_log_impl(&dword_1830D4000, v8, v19, "%{public}s called with null agent_uuid, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (id)gLogObj;
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v64 = "nw_path_agent_action";
        _os_log_impl(&dword_1830D4000, v8, v21, "%{public}s called with null agent_uuid, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_29;
  }
  id v10 = nw_parameters_copy_context(v5->parameters);
  int v11 = nw_path_shared_necp_fd(v10);

  if (v11 < 0) {
    goto LABEL_32;
  }
  os_log_type_t v12 = (char *)malloc_type_calloc(1uLL, 0x15uLL, 0xEAFB8F1AuLL);
  char v13 = v12;
  if (v12)
  {
    *os_log_type_t v12 = a3;
    *(_DWORD *)(v12 + 1) = 16;
    if (a2)
    {
      *(_OWORD *)(v12 + 5) = *(_OWORD *)a2;
      goto LABEL_12;
    }
    id v42 = __nwlog_obj();
    *(_DWORD *)int buf = 136446722;
    os_log_type_t v64 = "nw_necp_append_tlv";
    __int16 v65 = 1024;
    int v43 = a3;
    *(_DWORD *)os_log_type_t v66 = a3;
    *(_WORD *)&v66[4] = 1024;
    *(_DWORD *)&v66[6] = 16;
    __int16 v44 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v61 = 0;
    if (__nwlog_fault(v44, &type, &v61))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v45 = __nwlog_obj();
        os_log_type_t v46 = type;
        if (os_log_type_enabled(v45, type))
        {
          *(_DWORD *)int buf = 136446722;
          os_log_type_t v64 = "nw_necp_append_tlv";
          __int16 v65 = 1024;
          *(_DWORD *)os_log_type_t v66 = v43;
          *(_WORD *)&v66[4] = 1024;
          *(_DWORD *)&v66[6] = 16;
          _os_log_impl(&dword_1830D4000, v45, v46, "%{public}s type=%u length=%u but value is NULL", buf, 0x18u);
        }
      }
      else if (v61)
      {
        BOOL v51 = (char *)__nw_create_backtrace_string();
        id v45 = __nwlog_obj();
        os_log_type_t v52 = type;
        BOOL v53 = os_log_type_enabled(v45, type);
        if (v51)
        {
          if (v53)
          {
            *(_DWORD *)int buf = 136446978;
            os_log_type_t v64 = "nw_necp_append_tlv";
            __int16 v65 = 1024;
            *(_DWORD *)os_log_type_t v66 = v43;
            *(_WORD *)&v66[4] = 1024;
            *(_DWORD *)&v66[6] = 16;
            *(_WORD *)&v66[10] = 2082;
            *(void *)&v66[12] = v51;
            _os_log_impl(&dword_1830D4000, v45, v52, "%{public}s type=%u length=%u but value is NULL, dumping backtrace:%{public}s", buf, 0x22u);
          }

          free(v51);
          goto LABEL_120;
        }
        if (v53)
        {
          *(_DWORD *)int buf = 136446722;
          os_log_type_t v64 = "nw_necp_append_tlv";
          __int16 v65 = 1024;
          *(_DWORD *)os_log_type_t v66 = v43;
          *(_WORD *)&v66[4] = 1024;
          *(_DWORD *)&v66[6] = 16;
          _os_log_impl(&dword_1830D4000, v45, v52, "%{public}s type=%u length=%u but value is NULL, no backtrace", buf, 0x18u);
        }
      }
      else
      {
        id v45 = __nwlog_obj();
        os_log_type_t v55 = type;
        if (os_log_type_enabled(v45, type))
        {
          *(_DWORD *)int buf = 136446722;
          os_log_type_t v64 = "nw_necp_append_tlv";
          __int16 v65 = 1024;
          *(_DWORD *)os_log_type_t v66 = v43;
          *(_WORD *)&v66[4] = 1024;
          *(_DWORD *)&v66[6] = 16;
          _os_log_impl(&dword_1830D4000, v45, v55, "%{public}s type=%u length=%u but value is NULL, backtrace limit exceeded", buf, 0x18u);
        }
      }
    }
LABEL_120:
    if (v44) {
      free(v44);
    }
LABEL_12:
    int v14 = necp_client_action();
    BOOL v15 = v14 == 0;
    if (!v14)
    {
LABEL_51:
      free(v13);
      goto LABEL_52;
    }
    int v16 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (v16 == 45 || v16 == 2)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v17 = (id)gLogObj;
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)int buf = 136446466;
        os_log_type_t v64 = "nw_path_agent_action";
        __int16 v65 = 1024;
        *(_DWORD *)os_log_type_t v66 = v16;
        _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_DEBUG, "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d", buf, 0x12u);
      }

      goto LABEL_51;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v22 = (id)gLogObj;
    *(_DWORD *)int buf = 136446466;
    os_log_type_t v64 = "nw_path_agent_action";
    __int16 v65 = 1024;
    *(_DWORD *)os_log_type_t v66 = v16;
    BOOL v23 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v61 = 0;
    if (__nwlog_fault(v23, &type, &v61))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v24 = __nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v64 = "nw_path_agent_action";
          __int16 v65 = 1024;
          *(_DWORD *)os_log_type_t v66 = v16;
          _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d", buf, 0x12u);
        }
      }
      else if (v61)
      {
        os_log_type_t v26 = (char *)__nw_create_backtrace_string();
        os_log_type_t v24 = __nwlog_obj();
        os_log_type_t v27 = type;
        BOOL v28 = os_log_type_enabled(v24, type);
        if (v26)
        {
          if (v28)
          {
            *(_DWORD *)int buf = 136446722;
            os_log_type_t v64 = "nw_path_agent_action";
            __int16 v65 = 1024;
            *(_DWORD *)os_log_type_t v66 = v16;
            *(_WORD *)&v66[4] = 2082;
            *(void *)&v66[6] = v26;
            _os_log_impl(&dword_1830D4000, v24, v27, "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v26);
          goto LABEL_49;
        }
        if (v28)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v64 = "nw_path_agent_action";
          __int16 v65 = 1024;
          *(_DWORD *)os_log_type_t v66 = v16;
          _os_log_impl(&dword_1830D4000, v24, v27, "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        os_log_type_t v24 = __nwlog_obj();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v64 = "nw_path_agent_action";
          __int16 v65 = 1024;
          *(_DWORD *)os_log_type_t v66 = v16;
          _os_log_impl(&dword_1830D4000, v24, v29, "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
        }
      }
    }
LABEL_49:
    if (v23) {
      free(v23);
    }
    goto LABEL_51;
  }
  BOOL v36 = __nwlog_obj();
  os_log_type_enabled(v36, OS_LOG_TYPE_ERROR);
  *(_DWORD *)int buf = 136446722;
  os_log_type_t v64 = "strict_calloc";
  __int16 v65 = 2048;
  *(void *)os_log_type_t v66 = 1;
  *(_WORD *)&v66[8] = 2048;
  *(void *)&v66[10] = 21;
  os_log_type_t v37 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v37);
  if (!result)
  {
    free(v37);
    id v38 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v64 = "nw_necp_append_tlv";
    uint64_t v39 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v61 = 0;
    if (__nwlog_fault(v39, &type, &v61))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v40 = __nwlog_obj();
        os_log_type_t v41 = type;
        if (os_log_type_enabled(v40, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v64 = "nw_necp_append_tlv";
          _os_log_impl(&dword_1830D4000, v40, v41, "%{public}s called with null tlv_start", buf, 0xCu);
        }
      }
      else if (v61)
      {
        os_log_type_t v48 = (char *)__nw_create_backtrace_string();
        id v40 = __nwlog_obj();
        os_log_type_t v49 = type;
        BOOL v50 = os_log_type_enabled(v40, type);
        if (v48)
        {
          if (v50)
          {
            *(_DWORD *)int buf = 136446466;
            os_log_type_t v64 = "nw_necp_append_tlv";
            __int16 v65 = 2082;
            *(void *)os_log_type_t v66 = v48;
            _os_log_impl(&dword_1830D4000, v40, v49, "%{public}s called with null tlv_start, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v48);
          goto LABEL_99;
        }
        if (v50)
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v64 = "nw_necp_append_tlv";
          _os_log_impl(&dword_1830D4000, v40, v49, "%{public}s called with null tlv_start, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        id v40 = __nwlog_obj();
        os_log_type_t v54 = type;
        if (os_log_type_enabled(v40, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v64 = "nw_necp_append_tlv";
          _os_log_impl(&dword_1830D4000, v40, v54, "%{public}s called with null tlv_start, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_99:
    if (v39) {
      free(v39);
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v56 = (id)gLogObj;
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v64 = "nw_path_agent_action";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v61 = 0;
    if (!__nwlog_fault(v7, &type, &v61))
    {
LABEL_30:
      if (v7) {
LABEL_31:
      }
        free(v7);
LABEL_32:
      BOOL v15 = 0;
LABEL_52:

      return v15;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (id)gLogObj;
      os_log_type_t v57 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v64 = "nw_path_agent_action";
        _os_log_impl(&dword_1830D4000, v8, v57, "%{public}s nw_path_create_necp_agent_action failed", buf, 0xCu);
      }
LABEL_29:

      goto LABEL_30;
    }
    if (!v61)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v60 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v64 = "nw_path_agent_action";
        _os_log_impl(&dword_1830D4000, v8, v60, "%{public}s nw_path_create_necp_agent_action failed, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_29;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v8 = __nwlog_obj();
    os_log_type_t v58 = type;
    BOOL v59 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v59)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v64 = "nw_path_agent_action";
        _os_log_impl(&dword_1830D4000, v8, v58, "%{public}s nw_path_create_necp_agent_action failed, no backtrace", buf, 0xCu);
      }
      goto LABEL_29;
    }
    if (v59)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v64 = "nw_path_agent_action";
      __int16 v65 = 2082;
      *(void *)os_log_type_t v66 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v8, v58, "%{public}s nw_path_create_necp_agent_action failed, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_62:

    free(backtrace_string);
    goto LABEL_30;
  }
  __break(1u);
  return result;
}

void sub_183BB57DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_path_assert_agent(NWConcrete_nw_path *a1, const unsigned __int8 *a2)
{
  return nw_path_agent_action(a1, a2, 131);
}

const char *nw_path_evaluator_get_error_string(unsigned int a1)
{
  if (a1 > 2) {
    return "unknown error";
  }
  else {
    return off_1E5248590[a1];
  }
}

BOOL nw_path_trigger_agent(NWConcrete_nw_path *a1, const unsigned __int8 *a2)
{
  return nw_path_agent_action(a1, a2, 130);
}

uint64_t __nw_path_trigger_inactive_cellular_agent_if_necessary_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  char v5 = v4;
  size_t length = 0;
  if (v4)
  {
    data = (const char *)xpc_dictionary_get_data(v4, "data", &length);
    if (data)
    {
      if (length >= 0xD8)
      {
        uint64_t v7 = data;
        if (length == *((unsigned int *)data + 53) + 216
          && (data[208] & 2) == 0
          && !strncmp(data + 16, "Cellular", 0x20uLL)
          && !strncmp(v7 + 48, "Internet", 0x20uLL))
        {
          nw_path_agent_action(*(NWConcrete_nw_path **)(a1 + 32), (const unsigned __int8 *)v7, 130);
          *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
        }
      }
    }
  }

  return 1;
}

void sub_183BB5914(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL ___ZL47nw_path_flow_registration_copy_parent_evaluatorP36NWConcrete_nw_path_flow_registration_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  if (v3) {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), *(id *)(a3 + 8));
  }
  return v3 == 0;
}

void nw_path_flow_registration_set_tfo_cache(void *a1, void *a2, uint64_t a3)
{
  *(void *)&v43[13] = *MEMORY[0x1E4F143B8];
  char v5 = a1;
  id v6 = a2;
  uint64_t v7 = v6;
  if (!v5)
  {
    BOOL v20 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v41 = "nw_path_flow_registration_set_tfo_cache";
    char v13 = (char *)_os_log_send_and_compose_impl();

    v37[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v13, v37, &type)) {
      goto LABEL_28;
    }
    if (v37[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v21 = __nwlog_obj();
      os_log_type_t v22 = v37[0];
      if (os_log_type_enabled(v21, v37[0]))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v41 = "nw_path_flow_registration_set_tfo_cache";
        _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s called with null path", buf, 0xCu);
      }
      goto LABEL_78;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      os_log_type_t v21 = __nwlog_obj();
      os_log_type_t v33 = v37[0];
      if (os_log_type_enabled(v21, v37[0]))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v41 = "nw_path_flow_registration_set_tfo_cache";
        _os_log_impl(&dword_1830D4000, v21, v33, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_78;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v21 = __nwlog_obj();
    os_log_type_t v27 = v37[0];
    BOOL v28 = os_log_type_enabled(v21, v37[0]);
    if (!backtrace_string)
    {
      if (v28)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v41 = "nw_path_flow_registration_set_tfo_cache";
        _os_log_impl(&dword_1830D4000, v21, v27, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
      goto LABEL_78;
    }
    if (v28)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v41 = "nw_path_flow_registration_set_tfo_cache";
      __int16 v42 = 2082;
      *(void *)int v43 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v21, v27, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_60;
  }
  if (!v6)
  {
    BOOL v23 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v41 = "nw_path_flow_registration_set_tfo_cache";
    char v13 = (char *)_os_log_send_and_compose_impl();

    v37[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v13, v37, &type)) {
      goto LABEL_28;
    }
    if (v37[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v21 = __nwlog_obj();
      os_log_type_t v24 = v37[0];
      if (os_log_type_enabled(v21, v37[0]))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v41 = "nw_path_flow_registration_set_tfo_cache";
        _os_log_impl(&dword_1830D4000, v21, v24, "%{public}s called with null flow_registration", buf, 0xCu);
      }
      goto LABEL_78;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      os_log_type_t v21 = __nwlog_obj();
      os_log_type_t v34 = v37[0];
      if (os_log_type_enabled(v21, v37[0]))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v41 = "nw_path_flow_registration_set_tfo_cache";
        _os_log_impl(&dword_1830D4000, v21, v34, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_78;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v21 = __nwlog_obj();
    os_log_type_t v29 = v37[0];
    BOOL v30 = os_log_type_enabled(v21, v37[0]);
    if (!backtrace_string)
    {
      if (v30)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v41 = "nw_path_flow_registration_set_tfo_cache";
        _os_log_impl(&dword_1830D4000, v21, v29, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
      }
      goto LABEL_78;
    }
    if (v30)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v41 = "nw_path_flow_registration_set_tfo_cache";
      __int16 v42 = 2082;
      *(void *)int v43 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v21, v29, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_60;
  }
  if (!a3)
  {
    os_log_type_t v25 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v41 = "nw_path_flow_registration_set_tfo_cache";
    char v13 = (char *)_os_log_send_and_compose_impl();

    v37[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v13, v37, &type)) {
      goto LABEL_28;
    }
    if (v37[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v21 = __nwlog_obj();
      os_log_type_t v26 = v37[0];
      if (os_log_type_enabled(v21, v37[0]))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v41 = "nw_path_flow_registration_set_tfo_cache";
        _os_log_impl(&dword_1830D4000, v21, v26, "%{public}s called with null tfo_cache_buffer", buf, 0xCu);
      }
LABEL_78:

LABEL_28:
      if (!v13) {
        goto LABEL_30;
      }
LABEL_29:
      free(v13);
      goto LABEL_30;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      os_log_type_t v21 = __nwlog_obj();
      os_log_type_t v35 = v37[0];
      if (os_log_type_enabled(v21, v37[0]))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v41 = "nw_path_flow_registration_set_tfo_cache";
        _os_log_impl(&dword_1830D4000, v21, v35, "%{public}s called with null tfo_cache_buffer, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_78;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v21 = __nwlog_obj();
    os_log_type_t v31 = v37[0];
    BOOL v32 = os_log_type_enabled(v21, v37[0]);
    if (!backtrace_string)
    {
      if (v32)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v41 = "nw_path_flow_registration_set_tfo_cache";
        _os_log_impl(&dword_1830D4000, v21, v31, "%{public}s called with null tfo_cache_buffer, no backtrace", buf, 0xCu);
      }
      goto LABEL_78;
    }
    if (v32)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v41 = "nw_path_flow_registration_set_tfo_cache";
      __int16 v42 = 2082;
      *(void *)int v43 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v21, v31, "%{public}s called with null tfo_cache_buffer, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_60:

    goto LABEL_20;
  }
  *(void *)os_log_type_t v37 = 0;
  id v8 = nw_parameters_copy_context(v5[2]);
  int v9 = nw_path_shared_necp_fd(v8);

  if (v9 < 0) {
    goto LABEL_30;
  }
  *(_WORD *)os_log_type_t v37 = 258;
  uint64_t v38 = a3;
  *(_DWORD *)&v37[4] = 18;
  if (!necp_client_action()) {
    goto LABEL_30;
  }
  int v10 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v11 = (id)gLogObj;
  os_log_type_t v12 = v11;
  if (v10 != 2)
  {
    *(_DWORD *)int buf = 136446466;
    os_log_type_t v41 = "nw_path_flow_registration_set_tfo_cache";
    __int16 v42 = 1024;
    *(_DWORD *)int v43 = v10;
    char v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (!__nwlog_fault(v13, &type, &v36)) {
      goto LABEL_28;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v14 = (id)gLogObj;
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)int buf = 136446466;
        os_log_type_t v41 = "nw_path_flow_registration_set_tfo_cache";
        __int16 v42 = 1024;
        *(_DWORD *)int v43 = v10;
        _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s necp update cache failed for tfo %{darwin.errno}d", buf, 0x12u);
      }
LABEL_27:

      goto LABEL_28;
    }
    if (!v36)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v14 = (id)gLogObj;
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)int buf = 136446466;
        os_log_type_t v41 = "nw_path_flow_registration_set_tfo_cache";
        __int16 v42 = 1024;
        *(_DWORD *)int v43 = v10;
        _os_log_impl(&dword_1830D4000, v14, v19, "%{public}s necp update cache failed for tfo %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
      }
      goto LABEL_27;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v14 = (id)gLogObj;
    os_log_type_t v17 = type;
    BOOL v18 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)int buf = 136446466;
        os_log_type_t v41 = "nw_path_flow_registration_set_tfo_cache";
        __int16 v42 = 1024;
        *(_DWORD *)int v43 = v10;
        _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s necp update cache failed for tfo %{darwin.errno}d, no backtrace", buf, 0x12u);
      }
      goto LABEL_27;
    }
    if (v18)
    {
      *(_DWORD *)int buf = 136446722;
      os_log_type_t v41 = "nw_path_flow_registration_set_tfo_cache";
      __int16 v42 = 1024;
      *(_DWORD *)int v43 = v10;
      v43[2] = 2082;
      *(void *)&v43[3] = backtrace_string;
      _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s necp update cache failed for tfo %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
    }

LABEL_20:
    free(backtrace_string);
    if (!v13) {
      goto LABEL_30;
    }
    goto LABEL_29;
  }
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)int buf = 136446466;
    os_log_type_t v41 = "nw_path_flow_registration_set_tfo_cache";
    __int16 v42 = 1024;
    *(_DWORD *)int v43 = 2;
    _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_ERROR, "%{public}s necp update cache failed for tfo %{darwin.errno}d", buf, 0x12u);
  }

LABEL_30:
}

void sub_183BB6368(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_path_flow_registration_set_specific_use_only(void *a1, char a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    *((unsigned char *)v3 + 149) = *((unsigned char *)v3 + 149) & 0xFE | a2;
    goto LABEL_3;
  }
  char v5 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  int v16 = "nw_path_flow_registration_set_specific_use_only";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_path_flow_registration_set_specific_use_only";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null flow_registration", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          int v16 = "nw_path_flow_registration_set_specific_use_only";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_path_flow_registration_set_specific_use_only";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_path_flow_registration_set_specific_use_only";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

BOOL nw_path_request_nexus(void *a1)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (v1)
  {
    nw_allow_use_of_dispatch_internal();
    id v2 = nw_parameters_copy_context(v1[2]);
    if ((nw_path_shared_necp_fd(v2) & 0x80000000) != 0)
    {
      BOOL v4 = 0;
    }
    else
    {
      int v3 = necp_client_action();
      BOOL v4 = v3 == 0;
      if (v3)
      {
        int v5 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v6 = (id)gLogObj;
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v22 = "nw_path_request_nexus";
          __int16 v23 = 1024;
          LODWORD(v24) = v5;
          _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_ERROR, "%{public}s NECP_CLIENT_ACTION_REQUEST_NEXUS_INSTANCE %{darwin.errno}d", buf, 0x12u);
        }
      }
      else
      {
        v16[0] = MEMORY[0x1E4F143A8];
        v16[1] = 3221225472;
        v16[2] = __nw_path_request_nexus_block_invoke;
        v16[3] = &unk_1E524B9A0;
        __int16 v17 = v2;
        BOOL v18 = v1;
        nw_queue_context_async_if_needed(v17, v16);

        id v6 = v17;
      }
    }
    goto LABEL_10;
  }
  os_log_type_t v8 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v22 = "nw_path_request_nexus";
  int v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v20 = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (__nwlog_fault(v9, &v20, &v19))
  {
    if (v20 == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v11 = v20;
      if (os_log_type_enabled(v10, v20))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v22 = "nw_path_request_nexus";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v13 = v20;
      BOOL v14 = os_log_type_enabled(v10, v20);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v22 = "nw_path_request_nexus";
          __int16 v23 = 2082;
          os_log_type_t v24 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_27;
      }
      if (v14)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v22 = "nw_path_request_nexus";
        _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v15 = v20;
      if (os_log_type_enabled(v10, v20))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v22 = "nw_path_request_nexus";
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_27:
  if (v9) {
    free(v9);
  }
  BOOL v4 = 0;
LABEL_10:

  return v4;
}

void sub_183BB6A10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void __nw_path_request_nexus_block_invoke(uint64_t a1)
{
}

BOOL nw_path_evaluator_request_nexus(void *a1)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (v1)
  {
    nw_allow_use_of_dispatch_internal();
    id v2 = nw_parameters_copy_context(*((void **)v1 + 1));
    if ((nw_path_shared_necp_fd(v2) & 0x80000000) != 0)
    {
      BOOL v4 = 0;
    }
    else
    {
      int v3 = necp_client_action();
      BOOL v4 = v3 == 0;
      if (v3)
      {
        int v5 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v6 = (id)gLogObj;
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v24 = "nw_path_evaluator_request_nexus";
          __int16 v25 = 1024;
          LODWORD(v26) = v5;
          _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_ERROR, "%{public}s NECP_CLIENT_ACTION_REQUEST_NEXUS_INSTANCE %{darwin.errno}d", buf, 0x12u);
        }
      }
      else
      {
        os_unfair_lock_lock((os_unfair_lock_t)v1 + 24);
        int v7 = *((_DWORD *)v1 + 25);
        os_unfair_lock_unlock((os_unfair_lock_t)v1 + 24);
        v17[0] = MEMORY[0x1E4F143A8];
        v17[1] = 3221225472;
        v17[2] = __nw_path_evaluator_request_nexus_block_invoke;
        v17[3] = &unk_1E524BA38;
        BOOL v18 = v2;
        id v19 = v1;
        int v20 = v7;
        nw_queue_context_async_if_needed(v18, v17);

        id v6 = v18;
      }
    }
    goto LABEL_10;
  }
  int v9 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v24 = "nw_path_evaluator_request_nexus";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v22 = OS_LOG_TYPE_ERROR;
  char v21 = 0;
  if (__nwlog_fault(v10, &v22, &v21))
  {
    if (v22 == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v12 = v22;
      if (os_log_type_enabled(v11, v22))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v24 = "nw_path_evaluator_request_nexus";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null evaluator", buf, 0xCu);
      }
    }
    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v14 = v22;
      BOOL v15 = os_log_type_enabled(v11, v22);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v24 = "nw_path_evaluator_request_nexus";
          __int16 v25 = 2082;
          os_log_type_t v26 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null evaluator, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_27;
      }
      if (v15)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v24 = "nw_path_evaluator_request_nexus";
        _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null evaluator, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v16 = v22;
      if (os_log_type_enabled(v11, v22))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v24 = "nw_path_evaluator_request_nexus";
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null evaluator, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_27:
  if (v10) {
    free(v10);
  }
  BOOL v4 = 0;
LABEL_10:

  return v4;
}

void sub_183BB6E58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void __nw_path_evaluator_request_nexus_block_invoke(uint64_t a1)
{
}

NWConcrete_nw_path_flow_registration *nw_path_evaluator_create_flow(void *a1, int a2, int a3, int a4, int a5, _OWORD *a6, _DWORD *a7)
{
  return nw_path_evaluator_create_flow_inner(a1, a2, a3, a4, a5, a6, 0, 0, a7);
}

NWConcrete_nw_path_flow_registration *nw_path_flow_registration_create_new_flow(void *a1, int a2, int a3, int a4, int a5, _OWORD *a6, void *a7, int a8)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  BOOL v15 = a1;
  id v16 = a7;
  if (v15)
  {
    __int16 v17 = nw_path_flow_registration_copy_parent_evaluator(v15);
    BOOL v18 = v17;
    if (v17)
    {
      flow_inner = nw_path_evaluator_create_flow_inner(v17, a2, a3, a4, a5, a6, v16, a8, 0);
      uint64_t subflow_registrations = (uint64_t)v15->subflow_registrations;
      if (!subflow_registrations)
      {
        BOOL v21 = nw_array_create();
        os_log_type_t v22 = v15->subflow_registrations;
        v15->uint64_t subflow_registrations = (OS_nw_array *)v21;

        uint64_t subflow_registrations = (uint64_t)v15->subflow_registrations;
      }
      nw_array_append(subflow_registrations, flow_inner);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v23 = (id)gLogObj;
      if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
      {
        os_log_type_t v24 = v15->subflow_registrations;
        *(_DWORD *)int buf = 136446722;
        id v45 = "nw_path_flow_registration_create_new_flow";
        __int16 v46 = 2112;
        os_log_type_t v47 = (char *)v24;
        __int16 v48 = 2112;
        os_log_type_t v49 = v15;
        _os_log_impl(&dword_1830D4000, v23, OS_LOG_TYPE_INFO, "%{public}s Added subflow registration %@ to %@", buf, 0x20u);
      }

LABEL_8:
      goto LABEL_9;
    }
    BOOL v30 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    id v45 = "nw_path_flow_registration_create_new_flow";
    os_log_type_t v31 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (__nwlog_fault(v31, &type, &v42))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v32 = __nwlog_obj();
        os_log_type_t v33 = type;
        if (os_log_type_enabled(v32, type))
        {
          *(_DWORD *)int buf = 136446210;
          id v45 = "nw_path_flow_registration_create_new_flow";
          _os_log_impl(&dword_1830D4000, v32, v33, "%{public}s called with null evaluator", buf, 0xCu);
        }
      }
      else if (v42)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v32 = __nwlog_obj();
        os_log_type_t v38 = type;
        BOOL v39 = os_log_type_enabled(v32, type);
        if (backtrace_string)
        {
          if (v39)
          {
            *(_DWORD *)int buf = 136446466;
            id v45 = "nw_path_flow_registration_create_new_flow";
            __int16 v46 = 2082;
            os_log_type_t v47 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v32, v38, "%{public}s called with null evaluator, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_45;
        }
        if (v39)
        {
          *(_DWORD *)int buf = 136446210;
          id v45 = "nw_path_flow_registration_create_new_flow";
          _os_log_impl(&dword_1830D4000, v32, v38, "%{public}s called with null evaluator, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        BOOL v32 = __nwlog_obj();
        os_log_type_t v41 = type;
        if (os_log_type_enabled(v32, type))
        {
          *(_DWORD *)int buf = 136446210;
          id v45 = "nw_path_flow_registration_create_new_flow";
          _os_log_impl(&dword_1830D4000, v32, v41, "%{public}s called with null evaluator, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_45:
    if (v31) {
      free(v31);
    }
    flow_inner = 0;
    goto LABEL_8;
  }
  os_log_type_t v26 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  id v45 = "nw_path_flow_registration_create_new_flow";
  uint64_t v27 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v42 = 0;
  if (__nwlog_fault(v27, &type, &v42))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v28 = __nwlog_obj();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v28, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v45 = "nw_path_flow_registration_create_new_flow";
        _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s called with null existing_flow_registration", buf, 0xCu);
      }
    }
    else if (v42)
    {
      os_log_type_t v34 = (char *)__nw_create_backtrace_string();
      BOOL v28 = __nwlog_obj();
      os_log_type_t v35 = type;
      BOOL v36 = os_log_type_enabled(v28, type);
      if (v34)
      {
        if (v36)
        {
          *(_DWORD *)int buf = 136446466;
          id v45 = "nw_path_flow_registration_create_new_flow";
          __int16 v46 = 2082;
          os_log_type_t v47 = v34;
          _os_log_impl(&dword_1830D4000, v28, v35, "%{public}s called with null existing_flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v34);
        goto LABEL_39;
      }
      if (v36)
      {
        *(_DWORD *)int buf = 136446210;
        id v45 = "nw_path_flow_registration_create_new_flow";
        _os_log_impl(&dword_1830D4000, v28, v35, "%{public}s called with null existing_flow_registration, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v28 = __nwlog_obj();
      os_log_type_t v40 = type;
      if (os_log_type_enabled(v28, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v45 = "nw_path_flow_registration_create_new_flow";
        _os_log_impl(&dword_1830D4000, v28, v40, "%{public}s called with null existing_flow_registration, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_39:
  if (v27) {
    free(v27);
  }
  flow_inner = 0;
LABEL_9:

  return flow_inner;
}

void sub_183BB748C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_path_flow_registration *nw_path_flow_registration_create_new_flow_from_evaluator(void *a1, void *a2)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  int v3 = a1;
  BOOL v4 = a2;
  int v5 = v4;
  if (v4)
  {
    os_unfair_lock_lock(v4 + 24);
    id v6 = *(id *)&v5[12]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(v5 + 24);
    if (v6)
    {
      long long type = 0uLL;
      nw_path_get_nexus_agent_uuid(v6, &type);
      int v7 = nw_path_evaluator_create_flow_inner(v5, 1, 1, 0, 0, &type, 0, 0, 0);
      if (v3)
      {
        uint64_t v8 = v3[2];
        if (!v8)
        {
          BOOL v9 = nw_array_create();
          os_log_type_t v10 = (void *)v3[2];
          v3[2] = v9;

          uint64_t v8 = v3[2];
        }
        nw_array_append(v8, v7);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v11 = (id)gLogObj;
        if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
        {
          os_log_type_t v12 = (char *)v3[2];
          *(_DWORD *)int buf = 136446722;
          BOOL v32 = "nw_path_flow_registration_create_new_flow_from_evaluator";
          __int16 v33 = 2112;
          os_log_type_t v34 = v12;
          __int16 v35 = 2112;
          BOOL v36 = v3;
          _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_INFO, "%{public}s Added subflow registration %@ to %@", buf, 0x20u);
        }
      }
LABEL_9:

      goto LABEL_10;
    }
    BOOL v18 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v32 = "nw_path_flow_registration_create_new_flow_from_evaluator";
    id v19 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(type) = 16;
    char v30 = 0;
    if (__nwlog_fault(v19, &type, &v30))
    {
      if (type == 17)
      {
        int v20 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v20, (os_log_type_t)type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v32 = "nw_path_flow_registration_create_new_flow_from_evaluator";
          _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (v30)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v20 = __nwlog_obj();
        os_log_type_t v26 = type;
        BOOL v27 = os_log_type_enabled(v20, (os_log_type_t)type);
        if (backtrace_string)
        {
          if (v27)
          {
            *(_DWORD *)int buf = 136446466;
            BOOL v32 = "nw_path_flow_registration_create_new_flow_from_evaluator";
            __int16 v33 = 2082;
            os_log_type_t v34 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v20, v26, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_46;
        }
        if (v27)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v32 = "nw_path_flow_registration_create_new_flow_from_evaluator";
          _os_log_impl(&dword_1830D4000, v20, v26, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        int v20 = __nwlog_obj();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v20, (os_log_type_t)type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v32 = "nw_path_flow_registration_create_new_flow_from_evaluator";
          _os_log_impl(&dword_1830D4000, v20, v29, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_46:
    if (v19) {
      free(v19);
    }
    int v7 = 0;
    goto LABEL_9;
  }
  os_log_type_t v14 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  BOOL v32 = "nw_path_flow_registration_create_new_flow_from_evaluator";
  BOOL v15 = (char *)_os_log_send_and_compose_impl();

  LOBYTE(type) = 16;
  char v30 = 0;
  if (__nwlog_fault(v15, &type, &v30))
  {
    if (type == 17)
    {
      id v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v16, (os_log_type_t)type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v32 = "nw_path_flow_registration_create_new_flow_from_evaluator";
        _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s called with null evaluator", buf, 0xCu);
      }
    }
    else if (v30)
    {
      os_log_type_t v22 = (char *)__nw_create_backtrace_string();
      id v16 = __nwlog_obj();
      os_log_type_t v23 = type;
      BOOL v24 = os_log_type_enabled(v16, (os_log_type_t)type);
      if (v22)
      {
        if (v24)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v32 = "nw_path_flow_registration_create_new_flow_from_evaluator";
          __int16 v33 = 2082;
          os_log_type_t v34 = v22;
          _os_log_impl(&dword_1830D4000, v16, v23, "%{public}s called with null evaluator, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v22);
        goto LABEL_40;
      }
      if (v24)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v32 = "nw_path_flow_registration_create_new_flow_from_evaluator";
        _os_log_impl(&dword_1830D4000, v16, v23, "%{public}s called with null evaluator, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v16 = __nwlog_obj();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v16, (os_log_type_t)type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v32 = "nw_path_flow_registration_create_new_flow_from_evaluator";
        _os_log_impl(&dword_1830D4000, v16, v28, "%{public}s called with null evaluator, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_40:
  if (v15) {
    free(v15);
  }
  int v7 = 0;
LABEL_10:

  return v7;
}

void sub_183BB7A80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_path_get_nexus_agent_uuid(void *a1, _OWORD *a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  int v3 = a1;
  BOOL v4 = v3;
  if (!v3)
  {
    uint64_t v8 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    id v19 = "nw_path_get_nexus_agent_uuid";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (__nwlog_fault(v9, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)int buf = 136446210;
          id v19 = "nw_path_get_nexus_agent_uuid";
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v10 = __nwlog_obj();
        os_log_type_t v13 = type;
        BOOL v14 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)int buf = 136446466;
            id v19 = "nw_path_get_nexus_agent_uuid";
            __int16 v20 = 2082;
            os_log_type_t v21 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }
        if (v14)
        {
          *(_DWORD *)int buf = 136446210;
          id v19 = "nw_path_get_nexus_agent_uuid";
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v10 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)int buf = 136446210;
          id v19 = "nw_path_get_nexus_agent_uuid";
          _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_23:
    if (v9) {
      free(v9);
    }
    goto LABEL_4;
  }
  if (nw_path_uses_nexus_internal(v3, 0))
  {
    nexus_agent = (const unsigned __int8 *)nw_path_get_nexus_agent(v4, 0);
    if (!uuid_is_null(nexus_agent))
    {
      *a2 = *(_OWORD *)nexus_agent;
      uint64_t v6 = 1;
      goto LABEL_5;
    }
  }
LABEL_4:
  uint64_t v6 = 0;
LABEL_5:

  return v6;
}

void sub_183BB7D74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_path_flow_registration_force_update(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    int v3 = nw_path_flow_registration_copy_parent_evaluator(v1);
    nw_path_evaluator_force_update(v3, v2);
    BOOL v4 = nw_path_flow_registration_copy_path(v2);

    goto LABEL_3;
  }
  uint64_t v6 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v17 = "nw_path_flow_registration_force_update";
  int v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v17 = "nw_path_flow_registration_force_update";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null flow_registration", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v17 = "nw_path_flow_registration_force_update";
          __int16 v18 = 2082;
          id v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v17 = "nw_path_flow_registration_force_update";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v17 = "nw_path_flow_registration_force_update";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v7) {
    free(v7);
  }
  BOOL v4 = 0;
LABEL_3:

  return v4;
}

void sub_183BB8040(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_path_flow_registration_copy_endpoint(void *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    int v3 = nw_path_flow_registration_copy_parent_evaluator(v1);
    BOOL v4 = v3;
    if (v3) {
      int v5 = (void *)*((void *)v3 + 2);
    }
    else {
      int v5 = 0;
    }
    id v6 = v5;

    goto LABEL_6;
  }
  uint64_t v8 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  id v19 = "nw_path_flow_registration_copy_endpoint";
  os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v19 = "nw_path_flow_registration_copy_endpoint";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null flow_registration", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)int buf = 136446466;
          id v19 = "nw_path_flow_registration_copy_endpoint";
          __int16 v20 = 2082;
          os_log_type_t v21 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v14)
      {
        *(_DWORD *)int buf = 136446210;
        id v19 = "nw_path_flow_registration_copy_endpoint";
        _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v19 = "nw_path_flow_registration_copy_endpoint";
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_23:
  if (v9) {
    free(v9);
  }
  id v6 = 0;
LABEL_6:

  return v6;
}

id nw_path_flow_registration_copy_parameters(void *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    int v3 = nw_path_flow_registration_copy_parent_evaluator(v1);
    BOOL v4 = v3;
    if (v3) {
      int v5 = (void *)*((void *)v3 + 1);
    }
    else {
      int v5 = 0;
    }
    id v6 = v5;

    goto LABEL_6;
  }
  uint64_t v8 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  id v19 = "nw_path_flow_registration_copy_parameters";
  os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v19 = "nw_path_flow_registration_copy_parameters";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null flow_registration", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)int buf = 136446466;
          id v19 = "nw_path_flow_registration_copy_parameters";
          __int16 v20 = 2082;
          os_log_type_t v21 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v14)
      {
        *(_DWORD *)int buf = 136446210;
        id v19 = "nw_path_flow_registration_copy_parameters";
        _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v19 = "nw_path_flow_registration_copy_parameters";
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_23:
  if (v9) {
    free(v9);
  }
  id v6 = 0;
LABEL_6:

  return v6;
}

BOOL nw_path_unassert_agent(NWConcrete_nw_path *a1, const unsigned __int8 *a2)
{
  return nw_path_agent_action(a1, a2, 132);
}

BOOL nw_path_add_group_members(void *a1, const unsigned __int8 *a2, void *a3)
{
  return nw_path_group_member_action(a1, a2, 133, a3);
}

BOOL nw_path_group_member_action(void *a1, const unsigned __int8 *a2, int a3, void *a4)
{
  uint64_t v122 = *MEMORY[0x1E4F143B8];
  int v7 = a1;
  id v8 = a4;
  os_log_type_t v9 = v8;
  if (!v7)
  {
    id v10 = v8;
    os_log_type_t v58 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v114 = "nw_path_group_member_action";
    BOOL v12 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v102[0]) = 0;
    if (__nwlog_fault(v12, type, v102))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v13 = __nwlog_obj();
        os_log_type_t v59 = type[0];
        if (os_log_type_enabled(v13, type[0]))
        {
          *(_DWORD *)int buf = 136446210;
          __int16 v114 = "nw_path_group_member_action";
          _os_log_impl(&dword_1830D4000, v13, v59, "%{public}s called with null path", buf, 0xCu);
        }
LABEL_34:

        goto LABEL_35;
      }
      if (!LOBYTE(v102[0]))
      {
        os_log_type_t v13 = __nwlog_obj();
        os_log_type_t v80 = type[0];
        if (os_log_type_enabled(v13, type[0]))
        {
          *(_DWORD *)int buf = 136446210;
          __int16 v114 = "nw_path_group_member_action";
          _os_log_impl(&dword_1830D4000, v13, v80, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_34;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v13 = __nwlog_obj();
      os_log_type_t v61 = type[0];
      BOOL v62 = os_log_type_enabled(v13, type[0]);
      if (!backtrace_string)
      {
        if (v62)
        {
          *(_DWORD *)int buf = 136446210;
          __int16 v114 = "nw_path_group_member_action";
          _os_log_impl(&dword_1830D4000, v13, v61, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
        goto LABEL_34;
      }
      if (v62)
      {
        *(_DWORD *)int buf = 136446466;
        __int16 v114 = "nw_path_group_member_action";
        __int16 v115 = 2082;
        *(void *)__int16 v116 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v13, v61, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
LABEL_35:
    if (!v12)
    {
LABEL_37:
      BOOL v32 = 0;
      os_log_type_t v9 = v10;
      goto LABEL_38;
    }
LABEL_36:
    free(v12);
    goto LABEL_37;
  }
  if (uuid_is_null(a2))
  {
    id v10 = v9;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v11 = (id)gLogObj;
    *(_DWORD *)int buf = 136446210;
    __int16 v114 = "nw_path_group_member_action";
    BOOL v12 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v102[0]) = 0;
    if (!__nwlog_fault(v12, type, v102)) {
      goto LABEL_35;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v13 = (id)gLogObj;
      os_log_type_t v14 = type[0];
      if (os_log_type_enabled(v13, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v114 = "nw_path_group_member_action";
        _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null agent_uuid", buf, 0xCu);
      }
    }
    else if (LOBYTE(v102[0]))
    {
      os_log_type_t v29 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v13 = (id)gLogObj;
      os_log_type_t v30 = type[0];
      BOOL v31 = os_log_type_enabled(v13, type[0]);
      if (v29)
      {
        if (v31)
        {
          *(_DWORD *)int buf = 136446466;
          __int16 v114 = "nw_path_group_member_action";
          __int16 v115 = 2082;
          *(void *)__int16 v116 = v29;
          _os_log_impl(&dword_1830D4000, v13, v30, "%{public}s called with null agent_uuid, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v29);
        if (!v12) {
          goto LABEL_37;
        }
        goto LABEL_36;
      }
      if (v31)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v114 = "nw_path_group_member_action";
        _os_log_impl(&dword_1830D4000, v13, v30, "%{public}s called with null agent_uuid, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v13 = (id)gLogObj;
      os_log_type_t v33 = type[0];
      if (os_log_type_enabled(v13, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v114 = "nw_path_group_member_action";
        _os_log_impl(&dword_1830D4000, v13, v33, "%{public}s called with null agent_uuid, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_34;
  }
  id v15 = nw_parameters_copy_context(v7[2]);
  int v16 = nw_path_shared_necp_fd(v15);

  if (v16 < 0)
  {
    BOOL v32 = 0;
LABEL_38:

    return v32;
  }
  size_t v93 = v9;
  os_log_type_t v17 = v9;
  uint64_t v107 = 0;
  long long v108 = &v107;
  uint64_t v109 = 0x2020000000;
  uint64_t v110 = 0;
  uint64_t v103 = 0;
  long long v104 = &v103;
  uint64_t v105 = 0x2020000000;
  __int16 v106 = 0;
  v102[0] = MEMORY[0x1E4F143A8];
  v102[1] = 3221225472;
  v102[2] = __nw_path_create_necp_agent_group_action_block_invoke;
  v102[3] = &unk_1E5248260;
  v102[4] = &v107;
  v102[5] = &v103;
  nw_array_apply(v17, (uint64_t)v102);
  uint64_t v18 = v108[3];
  int v19 = v18 + 18;
  if (v18 == -18)
  {
    os_log_type_t v63 = __nwlog_obj();
    os_log_type_enabled(v63, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int buf = 136446210;
    __int16 v114 = "strict_calloc";
    os_log_type_t v64 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v64);
    if (result) {
      goto LABEL_160;
    }
    free(v64);
  }
  __int16 v20 = malloc_type_calloc(1uLL, v18 + 18, 0xEAFB8F1AuLL);
  if (!v20)
  {
    __int16 v65 = __nwlog_obj();
    os_log_type_enabled(v65, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int buf = 136446722;
    __int16 v114 = "strict_calloc";
    __int16 v115 = 2048;
    *(void *)__int16 v116 = 1;
    *(_WORD *)&v116[8] = 2048;
    *(void *)&v116[10] = v18 + 18;
    os_log_type_t v66 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v66);
    if (result) {
      goto LABEL_160;
    }
    free(v66);
  }
  *(_OWORD *)__int16 v20 = *(_OWORD *)a2;
  v20[8] = *((_WORD *)v104 + 12);
  v101[0] = 0;
  v101[1] = v101;
  v101[2] = 0x2020000000;
  v101[3] = v20 + 9;
  *(void *)os_log_type_t type = MEMORY[0x1E4F143A8];
  uint64_t v95 = 3221225472;
  char v96 = __nw_path_create_necp_agent_group_action_block_invoke_2;
  long long v97 = &unk_1E5248288;
  __int16 v98 = v101;
  long long v99 = &v107;
  uint64_t v100 = v20;
  nw_array_apply(v17, (uint64_t)type);
  int64_t v21 = v18 + 23;
  if (v18 == -23)
  {
    uint64_t v67 = __nwlog_obj();
    os_log_type_enabled(v67, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int buf = 136446210;
    __int16 v114 = "strict_calloc";
    os_log_type_t v68 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v68);
    if (result) {
      goto LABEL_160;
    }
    free(v68);
    int64_t v21 = 0;
  }
  uint64_t v22 = (char *)malloc_type_calloc(1uLL, v21, 0xEAFB8F1AuLL);
  os_log_type_t v23 = v22;
  if (v22)
  {
    BOOL v24 = &v22[v21];
    if (v21 > 0)
    {
      if (v21 >= (unint64_t)(v18 + 18) + 5)
      {
        *uint64_t v22 = a3;
        *(_DWORD *)(v22 + 1) = v19;
        if (v18 != -18) {
          memcpy(v22 + 5, v20, (v18 + 18));
        }
      }
      else
      {
        char v91 = v17;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v25 = (id)gLogObj;
        *(_DWORD *)int buf = 136447490;
        __int16 v114 = "nw_necp_append_tlv";
        __int16 v115 = 2048;
        *(void *)__int16 v116 = v23;
        *(_WORD *)&v116[8] = 2048;
        *(void *)&v116[10] = (v18 + 18) + 5;
        __int16 v117 = 2048;
        long long v90 = v24;
        *(void *)uint64_t v118 = v24;
        *(_WORD *)&v118[8] = 1024;
        *(_DWORD *)unint64_t v119 = a3;
        *(_WORD *)&v119[4] = 1024;
        *(_DWORD *)&v119[6] = v18 + 18;
        os_log_type_t v26 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t v112 = OS_LOG_TYPE_ERROR;
        char v111 = 0;
        if (!__nwlog_fault(v26, &v112, &v111)) {
          goto LABEL_51;
        }
        if (v112 == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v27 = (id)gLogObj;
          os_log_type_t v28 = v112;
          if (os_log_type_enabled(v27, v112))
          {
            *(_DWORD *)int buf = 136447490;
            __int16 v114 = "nw_necp_append_tlv";
            __int16 v115 = 2048;
            *(void *)__int16 v116 = v23;
            *(_WORD *)&v116[8] = 2048;
            *(void *)&v116[10] = (v18 + 18) + 5;
            __int16 v117 = 2048;
            *(void *)uint64_t v118 = v90;
            *(_WORD *)&v118[8] = 1024;
            *(_DWORD *)unint64_t v119 = a3;
            *(_WORD *)&v119[4] = 1024;
            *(_DWORD *)&v119[6] = v18 + 18;
            _os_log_impl(&dword_1830D4000, v27, v28, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
          }
LABEL_50:

LABEL_51:
          os_log_type_t v17 = v91;
          if (!v26) {
            goto LABEL_53;
          }
          goto LABEL_52;
        }
        if (!v111)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v27 = (id)gLogObj;
          os_log_type_t v38 = v112;
          if (os_log_type_enabled(v27, v112))
          {
            *(_DWORD *)int buf = 136447490;
            __int16 v114 = "nw_necp_append_tlv";
            __int16 v115 = 2048;
            *(void *)__int16 v116 = v23;
            *(_WORD *)&v116[8] = 2048;
            *(void *)&v116[10] = (v18 + 18) + 5;
            __int16 v117 = 2048;
            *(void *)uint64_t v118 = v90;
            *(_WORD *)&v118[8] = 1024;
            *(_DWORD *)unint64_t v119 = a3;
            *(_WORD *)&v119[4] = 1024;
            *(_DWORD *)&v119[6] = v18 + 18;
            _os_log_impl(&dword_1830D4000, v27, v38, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
          }
          goto LABEL_50;
        }
        __int16 v35 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v27 = (id)gLogObj;
        os_log_type_t v36 = v112;
        BOOL v37 = os_log_type_enabled(v27, v112);
        if (!v35)
        {
          if (v37)
          {
            *(_DWORD *)int buf = 136447490;
            __int16 v114 = "nw_necp_append_tlv";
            __int16 v115 = 2048;
            *(void *)__int16 v116 = v23;
            *(_WORD *)&v116[8] = 2048;
            *(void *)&v116[10] = (v18 + 18) + 5;
            __int16 v117 = 2048;
            *(void *)uint64_t v118 = v90;
            *(_WORD *)&v118[8] = 1024;
            *(_DWORD *)unint64_t v119 = a3;
            *(_WORD *)&v119[4] = 1024;
            *(_DWORD *)&v119[6] = v18 + 18;
            _os_log_impl(&dword_1830D4000, v27, v36, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
          }
          goto LABEL_50;
        }
        if (v37)
        {
          *(_DWORD *)int buf = 136447746;
          __int16 v114 = "nw_necp_append_tlv";
          __int16 v115 = 2048;
          *(void *)__int16 v116 = v23;
          *(_WORD *)&v116[8] = 2048;
          *(void *)&v116[10] = (v18 + 18) + 5;
          __int16 v117 = 2048;
          *(void *)uint64_t v118 = v90;
          *(_WORD *)&v118[8] = 1024;
          *(_DWORD *)unint64_t v119 = a3;
          *(_WORD *)&v119[4] = 1024;
          *(_DWORD *)&v119[6] = v18 + 18;
          __int16 v120 = 2082;
          int v121 = v35;
          _os_log_impl(&dword_1830D4000, v27, v36, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
        }

        free(v35);
        os_log_type_t v17 = v91;
        if (v26) {
LABEL_52:
        }
          free(v26);
      }
LABEL_53:
      free(v20);
      _Block_object_dispose(v101, 8);
      _Block_object_dispose(&v103, 8);
      _Block_object_dispose(&v107, 8);

      if (v23)
      {
        int v39 = necp_client_action();
        BOOL v32 = v39 == 0;
        os_log_type_t v9 = v93;
        if (!v39)
        {
LABEL_99:
          free(v23);
          goto LABEL_38;
        }
        int v40 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        if (v40 == 45 || v40 == 2)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v41 = (id)gLogObj;
          if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)int buf = 136446466;
            __int16 v114 = "nw_path_group_member_action";
            __int16 v115 = 1024;
            *(_DWORD *)__int16 v116 = v40;
            _os_log_impl(&dword_1830D4000, v41, OS_LOG_TYPE_DEBUG, "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d", buf, 0x12u);
          }

LABEL_98:
          os_log_type_t v9 = v93;
          goto LABEL_99;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v49 = (id)gLogObj;
        *(_DWORD *)int buf = 136446466;
        __int16 v114 = "nw_path_group_member_action";
        __int16 v115 = 1024;
        *(_DWORD *)__int16 v116 = v40;
        uint64_t v50 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(v102[0]) = 0;
        if (__nwlog_fault(v50, type, v102))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            BOOL v51 = __nwlog_obj();
            os_log_type_t v52 = type[0];
            if (os_log_type_enabled(v51, type[0]))
            {
              *(_DWORD *)int buf = 136446466;
              __int16 v114 = "nw_path_group_member_action";
              __int16 v115 = 1024;
              *(_DWORD *)__int16 v116 = v40;
              _os_log_impl(&dword_1830D4000, v51, v52, "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d", buf, 0x12u);
            }
          }
          else if (LOBYTE(v102[0]))
          {
            os_log_type_t v54 = (char *)__nw_create_backtrace_string();
            BOOL v51 = __nwlog_obj();
            os_log_type_t v55 = type[0];
            BOOL v56 = os_log_type_enabled(v51, type[0]);
            if (v54)
            {
              if (v56)
              {
                *(_DWORD *)int buf = 136446722;
                __int16 v114 = "nw_path_group_member_action";
                __int16 v115 = 1024;
                *(_DWORD *)__int16 v116 = v40;
                *(_WORD *)&v116[4] = 2082;
                *(void *)&v116[6] = v54;
                _os_log_impl(&dword_1830D4000, v51, v55, "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
              }

              free(v54);
              goto LABEL_96;
            }
            if (v56)
            {
              *(_DWORD *)int buf = 136446466;
              __int16 v114 = "nw_path_group_member_action";
              __int16 v115 = 1024;
              *(_DWORD *)__int16 v116 = v40;
              _os_log_impl(&dword_1830D4000, v51, v55, "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d, no backtrace", buf, 0x12u);
            }
          }
          else
          {
            BOOL v51 = __nwlog_obj();
            os_log_type_t v57 = type[0];
            if (os_log_type_enabled(v51, type[0]))
            {
              *(_DWORD *)int buf = 136446466;
              __int16 v114 = "nw_path_group_member_action";
              __int16 v115 = 1024;
              *(_DWORD *)__int16 v116 = v40;
              _os_log_impl(&dword_1830D4000, v51, v57, "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
            }
          }
        }
LABEL_96:
        if (v50) {
          free(v50);
        }
        goto LABEL_98;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v42 = (id)gLogObj;
      *(_DWORD *)int buf = 136446210;
      __int16 v114 = "nw_path_group_member_action";
      int v43 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v102[0]) = 0;
      if (__nwlog_fault(v43, type, v102))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v44 = (id)gLogObj;
          os_log_type_t v45 = type[0];
          if (os_log_type_enabled(v44, type[0]))
          {
            *(_DWORD *)int buf = 136446210;
            __int16 v114 = "nw_path_group_member_action";
            _os_log_impl(&dword_1830D4000, v44, v45, "%{public}s nw_path_create_necp_agent_group_action failed", buf, 0xCu);
          }
        }
        else if (LOBYTE(v102[0]))
        {
          __int16 v46 = (char *)__nw_create_backtrace_string();
          __int16 v44 = __nwlog_obj();
          os_log_type_t v47 = type[0];
          BOOL v48 = os_log_type_enabled(v44, type[0]);
          if (v46)
          {
            if (v48)
            {
              *(_DWORD *)int buf = 136446466;
              __int16 v114 = "nw_path_group_member_action";
              __int16 v115 = 2082;
              *(void *)__int16 v116 = v46;
              _os_log_impl(&dword_1830D4000, v44, v47, "%{public}s nw_path_create_necp_agent_group_action failed, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v46);
            if (!v43) {
              goto LABEL_89;
            }
            goto LABEL_88;
          }
          if (v48)
          {
            *(_DWORD *)int buf = 136446210;
            __int16 v114 = "nw_path_group_member_action";
            _os_log_impl(&dword_1830D4000, v44, v47, "%{public}s nw_path_create_necp_agent_group_action failed, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __int16 v44 = __nwlog_obj();
          os_log_type_t v53 = type[0];
          if (os_log_type_enabled(v44, type[0]))
          {
            *(_DWORD *)int buf = 136446210;
            __int16 v114 = "nw_path_group_member_action";
            _os_log_impl(&dword_1830D4000, v44, v53, "%{public}s nw_path_create_necp_agent_group_action failed, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }
      if (!v43)
      {
LABEL_89:
        BOOL v32 = 0;
        os_log_type_t v9 = v93;
        goto LABEL_38;
      }
LABEL_88:
      free(v43);
      goto LABEL_89;
    }
    size_t v92 = v17;
    id v75 = __nwlog_obj();
    *(_DWORD *)int buf = 136447234;
    __int16 v114 = "nw_necp_append_tlv";
    __int16 v115 = 2048;
    *(void *)__int16 v116 = v23;
    *(_WORD *)&v116[8] = 2048;
    char v76 = v24;
    *(void *)&v116[10] = v24;
    __int16 v117 = 1024;
    *(_DWORD *)uint64_t v118 = a3;
    *(_WORD *)&v118[4] = 1024;
    *(_DWORD *)&v118[6] = v18 + 18;
    id v77 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v112 = OS_LOG_TYPE_ERROR;
    char v111 = 0;
    if (__nwlog_fault(v77, &v112, &v111))
    {
      if (v112 == OS_LOG_TYPE_FAULT)
      {
        id v78 = __nwlog_obj();
        os_log_type_t v79 = v112;
        if (os_log_type_enabled(v78, v112))
        {
          *(_DWORD *)int buf = 136447234;
          __int16 v114 = "nw_necp_append_tlv";
          __int16 v115 = 2048;
          *(void *)__int16 v116 = v23;
          *(_WORD *)&v116[8] = 2048;
          *(void *)&v116[10] = v76;
          __int16 v117 = 1024;
          *(_DWORD *)uint64_t v118 = a3;
          *(_WORD *)&v118[4] = 1024;
          *(_DWORD *)&v118[6] = v18 + 18;
          _os_log_impl(&dword_1830D4000, v78, v79, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u", buf, 0x2Cu);
        }
      }
      else
      {
        if (v111)
        {
          long long v84 = (char *)__nw_create_backtrace_string();
          uint64_t v85 = __nwlog_obj();
          os_log_type_t v86 = v112;
          BOOL v87 = os_log_type_enabled(v85, v112);
          if (v84)
          {
            if (v87)
            {
              *(_DWORD *)int buf = 136447490;
              __int16 v114 = "nw_necp_append_tlv";
              __int16 v115 = 2048;
              *(void *)__int16 v116 = v23;
              *(_WORD *)&v116[8] = 2048;
              *(void *)&v116[10] = v76;
              __int16 v117 = 1024;
              *(_DWORD *)uint64_t v118 = a3;
              *(_WORD *)&v118[4] = 1024;
              *(_DWORD *)&v118[6] = v19;
              *(_WORD *)unint64_t v119 = 2082;
              *(void *)&v119[2] = v84;
              _os_log_impl(&dword_1830D4000, v85, v86, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x36u);
            }

            free(v84);
          }
          else
          {
            if (v87)
            {
              *(_DWORD *)int buf = 136447234;
              __int16 v114 = "nw_necp_append_tlv";
              __int16 v115 = 2048;
              *(void *)__int16 v116 = v23;
              *(_WORD *)&v116[8] = 2048;
              *(void *)&v116[10] = v76;
              __int16 v117 = 1024;
              *(_DWORD *)uint64_t v118 = a3;
              *(_WORD *)&v118[4] = 1024;
              *(_DWORD *)&v118[6] = v19;
              _os_log_impl(&dword_1830D4000, v85, v86, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace", buf, 0x2Cu);
            }
          }
          goto LABEL_157;
        }
        id v78 = __nwlog_obj();
        os_log_type_t v89 = v112;
        if (os_log_type_enabled(v78, v112))
        {
          *(_DWORD *)int buf = 136447234;
          __int16 v114 = "nw_necp_append_tlv";
          __int16 v115 = 2048;
          *(void *)__int16 v116 = v23;
          *(_WORD *)&v116[8] = 2048;
          *(void *)&v116[10] = v76;
          __int16 v117 = 1024;
          *(_DWORD *)uint64_t v118 = a3;
          *(_WORD *)&v118[4] = 1024;
          *(_DWORD *)&v118[6] = v18 + 18;
          _os_log_impl(&dword_1830D4000, v78, v89, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded", buf, 0x2Cu);
        }
      }
    }
LABEL_157:
    if (v77) {
      free(v77);
    }
    os_log_type_t v17 = v92;
    goto LABEL_53;
  }
  os_log_type_t v69 = __nwlog_obj();
  os_log_type_enabled(v69, OS_LOG_TYPE_ERROR);
  *(_DWORD *)int buf = 136446722;
  __int16 v114 = "strict_calloc";
  __int16 v115 = 2048;
  *(void *)__int16 v116 = 1;
  *(_WORD *)&v116[8] = 2048;
  *(void *)&v116[10] = v21;
  os_log_type_t v70 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v70);
  if (!result)
  {
    free(v70);
    __int16 v71 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v114 = "nw_necp_append_tlv";
    char v72 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v112 = OS_LOG_TYPE_ERROR;
    char v111 = 0;
    if (__nwlog_fault(v72, &v112, &v111))
    {
      if (v112 == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v73 = __nwlog_obj();
        os_log_type_t v74 = v112;
        if (os_log_type_enabled(v73, v112))
        {
          *(_DWORD *)int buf = 136446210;
          __int16 v114 = "nw_necp_append_tlv";
          _os_log_impl(&dword_1830D4000, v73, v74, "%{public}s called with null tlv_start", buf, 0xCu);
        }
      }
      else if (v111)
      {
        BOOL v81 = (char *)__nw_create_backtrace_string();
        os_log_type_t v73 = __nwlog_obj();
        os_log_type_t v82 = v112;
        BOOL v83 = os_log_type_enabled(v73, v112);
        if (v81)
        {
          if (v83)
          {
            *(_DWORD *)int buf = 136446466;
            __int16 v114 = "nw_necp_append_tlv";
            __int16 v115 = 2082;
            *(void *)__int16 v116 = v81;
            _os_log_impl(&dword_1830D4000, v73, v82, "%{public}s called with null tlv_start, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v81);
          goto LABEL_152;
        }
        if (v83)
        {
          *(_DWORD *)int buf = 136446210;
          __int16 v114 = "nw_necp_append_tlv";
          _os_log_impl(&dword_1830D4000, v73, v82, "%{public}s called with null tlv_start, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v73 = __nwlog_obj();
        os_log_type_t v88 = v112;
        if (os_log_type_enabled(v73, v112))
        {
          *(_DWORD *)int buf = 136446210;
          __int16 v114 = "nw_necp_append_tlv";
          _os_log_impl(&dword_1830D4000, v73, v88, "%{public}s called with null tlv_start, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_152:
    if (v72) {
      free(v72);
    }
    goto LABEL_53;
  }
LABEL_160:
  __break(1u);
  return result;
}

void sub_183BB9E7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21)
{
  _Unwind_Resume(a1);
}

BOOL nw_path_remove_group_members(void *a1, const unsigned __int8 *a2, void *a3)
{
  return nw_path_group_member_action(a1, a2, 134, a3);
}

void nw_path_flow_registration_clear_stats_regions(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    *(_OWORD *)(v1 + 120) = 0u;
    *(_OWORD *)(v1 + 104) = 0u;
    *(_OWORD *)(v1 + 88) = 0u;
    goto LABEL_3;
  }
  int v3 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v14 = "nw_path_flow_registration_clear_stats_regions";
  BOOL v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v14 = "nw_path_flow_registration_clear_stats_regions";
        _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s called with null flow_registration", buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v5 = __nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v14 = "nw_path_flow_registration_clear_stats_regions";
          __int16 v15 = 2082;
          int v16 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v5, v8, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v9)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v14 = "nw_path_flow_registration_clear_stats_regions";
        _os_log_impl(&dword_1830D4000, v5, v8, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v5 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v14 = "nw_path_flow_registration_clear_stats_regions";
        _os_log_impl(&dword_1830D4000, v5, v10, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v4) {
    free(v4);
  }
LABEL_3:
}

void nw_path_flow_registration_set_partial_checksum_offload(void *a1, int a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  BOOL v4 = v3;
  if (v3)
  {
    if (a2) {
      char v5 = 2;
    }
    else {
      char v5 = 0;
    }
    *((unsigned char *)v3 + 148) = *((unsigned char *)v3 + 148) & 0xFD | v5;
    goto LABEL_6;
  }
  os_log_type_t v6 = __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  uint64_t v17 = "nw_path_flow_registration_set_partial_checksum_offload";
  int v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v17 = "nw_path_flow_registration_set_partial_checksum_offload";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null flow_registration", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v17 = "nw_path_flow_registration_set_partial_checksum_offload";
          __int16 v18 = 2082;
          int v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v12)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v17 = "nw_path_flow_registration_set_partial_checksum_offload";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v17 = "nw_path_flow_registration_set_partial_checksum_offload";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_23:
  if (v7) {
    free(v7);
  }
LABEL_6:
}

uint64_t nw_path_increment_agent_use_count(void *a1, const unsigned __int8 *a2, void *a3)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  char v5 = a1;
  long long v38 = 0uLL;
  uint64_t v39 = 0;
  *a3 = 0;
  if (!v5)
  {
    os_log_type_t v26 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v35 = "nw_path_increment_agent_use_count";
    int v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (!__nwlog_fault(v7, &type, &v32)) {
      goto LABEL_32;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v35 = "nw_path_increment_agent_use_count";
        _os_log_impl(&dword_1830D4000, v8, v27, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v32)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v29 = type;
      BOOL v30 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v30)
        {
          *(_DWORD *)int buf = 136446466;
          __int16 v35 = "nw_path_increment_agent_use_count";
          __int16 v36 = 2082;
          v37[0] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v29, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_32;
      }
      if (v30)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v35 = "nw_path_increment_agent_use_count";
        _os_log_impl(&dword_1830D4000, v8, v29, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v31 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v35 = "nw_path_increment_agent_use_count";
        _os_log_impl(&dword_1830D4000, v8, v31, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_31:

    goto LABEL_32;
  }
  if (uuid_is_null(a2))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    *(_DWORD *)int buf = 136446210;
    __int16 v35 = "nw_path_increment_agent_use_count";
    int v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (!__nwlog_fault(v7, &type, &v32)) {
      goto LABEL_32;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (id)gLogObj;
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v35 = "nw_path_increment_agent_use_count";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null agent_uuid", buf, 0xCu);
      }
    }
    else if (v32)
    {
      __int16 v15 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (id)gLogObj;
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v8, type);
      if (v15)
      {
        if (v17)
        {
          *(_DWORD *)int buf = 136446466;
          __int16 v35 = "nw_path_increment_agent_use_count";
          __int16 v36 = 2082;
          v37[0] = v15;
          _os_log_impl(&dword_1830D4000, v8, v16, "%{public}s called with null agent_uuid, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v15);
        if (!v7) {
          goto LABEL_34;
        }
        goto LABEL_33;
      }
      if (v17)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v35 = "nw_path_increment_agent_use_count";
        _os_log_impl(&dword_1830D4000, v8, v16, "%{public}s called with null agent_uuid, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (id)gLogObj;
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v35 = "nw_path_increment_agent_use_count";
        _os_log_impl(&dword_1830D4000, v8, v18, "%{public}s called with null agent_uuid, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_31;
  }
  id v10 = nw_parameters_copy_context(v5[2]);
  int v11 = nw_path_shared_necp_fd(v10);

  if (v11 < 0) {
    goto LABEL_34;
  }
  uint64_t v39 = 0;
  long long v38 = *(_OWORD *)a2;
  if (necp_client_action())
  {
    int v12 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v13 = (id)gLogObj;
    char v14 = v13;
    if (v12 == 2)
    {
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)int buf = 136446466;
        __int16 v35 = "nw_path_increment_agent_use_count";
        __int16 v36 = 1024;
        LODWORD(v37[0]) = 2;
        _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_DEBUG, "%{public}s NECP_CLIENT_ACTION_AGENT_USE %{darwin.errno}d", buf, 0x12u);
      }

      goto LABEL_34;
    }
    *(_DWORD *)int buf = 136446466;
    __int16 v35 = "nw_path_increment_agent_use_count";
    __int16 v36 = 1024;
    LODWORD(v37[0]) = v12;
    int v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (__nwlog_fault(v7, &type, &v32))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v8 = (id)gLogObj;
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)int buf = 136446466;
          __int16 v35 = "nw_path_increment_agent_use_count";
          __int16 v36 = 1024;
          LODWORD(v37[0]) = v12;
          _os_log_impl(&dword_1830D4000, v8, v20, "%{public}s NECP_CLIENT_ACTION_AGENT_USE %{darwin.errno}d", buf, 0x12u);
        }
      }
      else if (v32)
      {
        uint64_t v22 = (char *)__nw_create_backtrace_string();
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v23 = type;
        BOOL v24 = os_log_type_enabled(v8, type);
        if (v22)
        {
          if (v24)
          {
            *(_DWORD *)int buf = 136446722;
            __int16 v35 = "nw_path_increment_agent_use_count";
            __int16 v36 = 1024;
            LODWORD(v37[0]) = v12;
            WORD2(v37[0]) = 2082;
            *(void *)((char *)v37 + 6) = v22;
            _os_log_impl(&dword_1830D4000, v8, v23, "%{public}s NECP_CLIENT_ACTION_AGENT_USE %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v22);
          if (!v7) {
            goto LABEL_34;
          }
          goto LABEL_33;
        }
        if (v24)
        {
          *(_DWORD *)int buf = 136446466;
          __int16 v35 = "nw_path_increment_agent_use_count";
          __int16 v36 = 1024;
          LODWORD(v37[0]) = v12;
          _os_log_impl(&dword_1830D4000, v8, v23, "%{public}s NECP_CLIENT_ACTION_AGENT_USE %{darwin.errno}d, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)int buf = 136446466;
          __int16 v35 = "nw_path_increment_agent_use_count";
          __int16 v36 = 1024;
          LODWORD(v37[0]) = v12;
          _os_log_impl(&dword_1830D4000, v8, v25, "%{public}s NECP_CLIENT_ACTION_AGENT_USE %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
        }
      }
      goto LABEL_31;
    }
LABEL_32:
    if (v7) {
LABEL_33:
    }
      free(v7);
LABEL_34:
    uint64_t v19 = 0;
    goto LABEL_35;
  }
  *a3 = v39;
  uint64_t v19 = 1;
LABEL_35:

  return v19;
}

void sub_183BBACB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_path_copy_token_from_agent(void *a1, const unsigned __int8 *a2, void *a3)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  char v5 = a1;
  if (!v5)
  {
    os_log_type_t v28 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v45 = "nw_path_copy_token_from_agent";
    int v7 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v42 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v7, type, &v42)) {
      goto LABEL_32;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v29 = type[0];
      if (os_log_type_enabled(v8, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v45 = "nw_path_copy_token_from_agent";
        _os_log_impl(&dword_1830D4000, v8, v29, "%{public}s called with null path", buf, 0xCu);
      }
      goto LABEL_31;
    }
    if (v42 == OS_LOG_TYPE_DEFAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v39 = type[0];
      if (os_log_type_enabled(v8, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v45 = "nw_path_copy_token_from_agent";
        _os_log_impl(&dword_1830D4000, v8, v39, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_31;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v8 = __nwlog_obj();
    os_log_type_t v33 = type[0];
    BOOL v34 = os_log_type_enabled(v8, type[0]);
    if (!backtrace_string)
    {
      if (v34)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v45 = "nw_path_copy_token_from_agent";
        _os_log_impl(&dword_1830D4000, v8, v33, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
      goto LABEL_31;
    }
    if (v34)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v45 = "nw_path_copy_token_from_agent";
      __int16 v46 = 2082;
      *(void *)os_log_type_t v47 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v8, v33, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_71;
  }
  if (!a3)
  {
    BOOL v30 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v45 = "nw_path_copy_token_from_agent";
    int v7 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v42 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v7, type, &v42)) {
      goto LABEL_32;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v31 = type[0];
      if (os_log_type_enabled(v8, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v45 = "nw_path_copy_token_from_agent";
        _os_log_impl(&dword_1830D4000, v8, v31, "%{public}s called with null out_token_length", buf, 0xCu);
      }
LABEL_31:

      goto LABEL_32;
    }
    if (v42 == OS_LOG_TYPE_DEFAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v40 = type[0];
      if (os_log_type_enabled(v8, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v45 = "nw_path_copy_token_from_agent";
        _os_log_impl(&dword_1830D4000, v8, v40, "%{public}s called with null out_token_length, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_31;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v8 = __nwlog_obj();
    os_log_type_t v35 = type[0];
    BOOL v36 = os_log_type_enabled(v8, type[0]);
    if (!backtrace_string)
    {
      if (v36)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v45 = "nw_path_copy_token_from_agent";
        _os_log_impl(&dword_1830D4000, v8, v35, "%{public}s called with null out_token_length, no backtrace", buf, 0xCu);
      }
      goto LABEL_31;
    }
    if (v36)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v45 = "nw_path_copy_token_from_agent";
      __int16 v46 = 2082;
      *(void *)os_log_type_t v47 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v8, v35, "%{public}s called with null out_token_length, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_71:

    free(backtrace_string);
    goto LABEL_32;
  }
  if (uuid_is_null(a2))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v45 = "nw_path_copy_token_from_agent";
    int v7 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v42 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v7, type, &v42)) {
      goto LABEL_32;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (id)gLogObj;
      os_log_type_t v9 = type[0];
      if (os_log_type_enabled(v8, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v45 = "nw_path_copy_token_from_agent";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null agent_uuid", buf, 0xCu);
      }
    }
    else if (v42)
    {
      char v14 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (id)gLogObj;
      os_log_type_t v15 = type[0];
      BOOL v16 = os_log_type_enabled(v8, type[0]);
      if (v14)
      {
        if (v16)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v45 = "nw_path_copy_token_from_agent";
          __int16 v46 = 2082;
          *(void *)os_log_type_t v47 = v14;
          _os_log_impl(&dword_1830D4000, v8, v15, "%{public}s called with null agent_uuid, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v14);
        if (!v7) {
          goto LABEL_34;
        }
        goto LABEL_33;
      }
      if (v16)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v45 = "nw_path_copy_token_from_agent";
        _os_log_impl(&dword_1830D4000, v8, v15, "%{public}s called with null agent_uuid, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (id)gLogObj;
      os_log_type_t v17 = type[0];
      if (os_log_type_enabled(v8, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v45 = "nw_path_copy_token_from_agent";
        _os_log_impl(&dword_1830D4000, v8, v17, "%{public}s called with null agent_uuid, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_31;
  }
  *a3 = 0;
  id v10 = nw_parameters_copy_context(v5[2]);
  int v11 = nw_path_shared_necp_fd(v10);

  if (v11 < 0) {
    goto LABEL_34;
  }
  *(_OWORD *)os_log_type_t type = *(_OWORD *)a2;
  int v12 = malloc_type_calloc(1uLL, 0x1000uLL, 0xEAFB8F1AuLL);
  if (v12)
  {
LABEL_11:
    int v13 = necp_client_action();
    if (v13 > 0)
    {
      *a3 = v13;
LABEL_35:

      return (BOOL)v12;
    }
    if (v12) {
      free(v12);
    }
    int v18 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (v18 == 96 || v18 == 2)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v19 = (id)gLogObj;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446466;
        os_log_type_t v45 = "nw_path_copy_token_from_agent";
        __int16 v46 = 1024;
        *(_DWORD *)os_log_type_t v47 = v18;
        _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_ERROR, "%{public}s NECP_CLIENT_ACTION_ACQUIRE_AGENT_TOKEN %{darwin.errno}d", buf, 0x12u);
      }

      goto LABEL_34;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v21 = (id)gLogObj;
    *(_DWORD *)int buf = 136446466;
    os_log_type_t v45 = "nw_path_copy_token_from_agent";
    __int16 v46 = 1024;
    *(_DWORD *)os_log_type_t v47 = v18;
    int v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v42 = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (__nwlog_fault(v7, &v42, &v41))
    {
      if (v42 == OS_LOG_TYPE_FAULT)
      {
        uint64_t v22 = __nwlog_obj();
        os_log_type_t v23 = v42;
        if (os_log_type_enabled(v22, v42))
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v45 = "nw_path_copy_token_from_agent";
          __int16 v46 = 1024;
          *(_DWORD *)os_log_type_t v47 = v18;
          _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s NECP_CLIENT_ACTION_ACQUIRE_AGENT_TOKEN %{darwin.errno}d", buf, 0x12u);
        }
LABEL_51:

        goto LABEL_32;
      }
      if (!v41)
      {
        uint64_t v22 = __nwlog_obj();
        os_log_type_t v27 = v42;
        if (os_log_type_enabled(v22, v42))
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v45 = "nw_path_copy_token_from_agent";
          __int16 v46 = 1024;
          *(_DWORD *)os_log_type_t v47 = v18;
          _os_log_impl(&dword_1830D4000, v22, v27, "%{public}s NECP_CLIENT_ACTION_ACQUIRE_AGENT_TOKEN %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
        }
        goto LABEL_51;
      }
      BOOL v24 = (char *)__nw_create_backtrace_string();
      uint64_t v22 = __nwlog_obj();
      os_log_type_t v25 = v42;
      BOOL v26 = os_log_type_enabled(v22, v42);
      if (!v24)
      {
        if (v26)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v45 = "nw_path_copy_token_from_agent";
          __int16 v46 = 1024;
          *(_DWORD *)os_log_type_t v47 = v18;
          _os_log_impl(&dword_1830D4000, v22, v25, "%{public}s NECP_CLIENT_ACTION_ACQUIRE_AGENT_TOKEN %{darwin.errno}d, no backtrace", buf, 0x12u);
        }
        goto LABEL_51;
      }
      if (v26)
      {
        *(_DWORD *)int buf = 136446722;
        os_log_type_t v45 = "nw_path_copy_token_from_agent";
        __int16 v46 = 1024;
        *(_DWORD *)os_log_type_t v47 = v18;
        *(_WORD *)&v47[4] = 2082;
        *(void *)&v47[6] = v24;
        _os_log_impl(&dword_1830D4000, v22, v25, "%{public}s NECP_CLIENT_ACTION_ACQUIRE_AGENT_TOKEN %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }

      free(v24);
    }
LABEL_32:
    if (v7) {
LABEL_33:
    }
      free(v7);
LABEL_34:
    int v12 = 0;
    goto LABEL_35;
  }
  BOOL v37 = __nwlog_obj();
  os_log_type_enabled(v37, OS_LOG_TYPE_ERROR);
  *(_DWORD *)int buf = 136446722;
  os_log_type_t v45 = "strict_calloc";
  __int16 v46 = 2048;
  *(void *)os_log_type_t v47 = 1;
  *(_WORD *)&v47[8] = 2048;
  *(void *)&v47[10] = 4096;
  long long v38 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v38);
  if (!result)
  {
    free(v38);
    goto LABEL_11;
  }
  __break(1u);
  return result;
}

void sub_183BBB828(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_path_report_error_to_agent(void *a1, const unsigned __int8 *a2, int a3)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  char v5 = a1;
  if (!v5)
  {
    os_log_type_t v31 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v57 = "nw_path_report_error_to_agent";
    int v7 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v54 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v7, type, &v54)) {
      goto LABEL_28;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v32 = type[0];
      if (os_log_type_enabled(v8, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v57 = "nw_path_report_error_to_agent";
        _os_log_impl(&dword_1830D4000, v8, v32, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v54)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v34 = type[0];
      BOOL v35 = os_log_type_enabled(v8, type[0]);
      if (backtrace_string)
      {
        if (v35)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v57 = "nw_path_report_error_to_agent";
          __int16 v58 = 2082;
          *(void *)os_log_type_t v59 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v34, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        goto LABEL_61;
      }
      if (v35)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v57 = "nw_path_report_error_to_agent";
        _os_log_impl(&dword_1830D4000, v8, v34, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v42 = type[0];
      if (os_log_type_enabled(v8, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v57 = "nw_path_report_error_to_agent";
        _os_log_impl(&dword_1830D4000, v8, v42, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_27:

    goto LABEL_28;
  }
  if (uuid_is_null(a2))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v57 = "nw_path_report_error_to_agent";
    int v7 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v54 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v7, type, &v54)) {
      goto LABEL_28;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (id)gLogObj;
      os_log_type_t v9 = type[0];
      if (os_log_type_enabled(v8, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v57 = "nw_path_report_error_to_agent";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null agent_uuid", buf, 0xCu);
      }
    }
    else if (v54)
    {
      int v18 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (id)gLogObj;
      os_log_type_t v19 = type[0];
      BOOL v20 = os_log_type_enabled(v8, type[0]);
      if (v18)
      {
        if (v20)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v57 = "nw_path_report_error_to_agent";
          __int16 v58 = 2082;
          *(void *)os_log_type_t v59 = v18;
          _os_log_impl(&dword_1830D4000, v8, v19, "%{public}s called with null agent_uuid, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v18);
        if (!v7) {
          goto LABEL_30;
        }
        goto LABEL_29;
      }
      if (v20)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v57 = "nw_path_report_error_to_agent";
        _os_log_impl(&dword_1830D4000, v8, v19, "%{public}s called with null agent_uuid, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (id)gLogObj;
      os_log_type_t v21 = type[0];
      if (os_log_type_enabled(v8, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v57 = "nw_path_report_error_to_agent";
        _os_log_impl(&dword_1830D4000, v8, v21, "%{public}s called with null agent_uuid, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_27;
  }
  id v10 = nw_parameters_copy_context(v5[2]);
  int v11 = nw_path_shared_necp_fd(v10);

  if (v11 < 0) {
    goto LABEL_30;
  }
  *(_OWORD *)os_log_type_t type = *(_OWORD *)a2;
  int v12 = (char *)malloc_type_calloc(1uLL, 0x19uLL, 0xEAFB8F1AuLL);
  int v13 = v12;
  if (v12)
  {
    *int v12 = -121;
    *(_DWORD *)(v12 + 1) = 20;
    *(_OWORD *)(v12 + 5) = *(_OWORD *)type;
    *(_DWORD *)(v12 + 21) = a3;
    int v14 = necp_client_action();
    BOOL v15 = v14 == 0;
    if (!v14)
    {
LABEL_49:
      free(v13);
      goto LABEL_50;
    }
    int v16 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (v16 == 45 || v16 == 2)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v17 = (id)gLogObj;
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)int buf = 136446466;
        os_log_type_t v57 = "nw_path_report_error_to_agent";
        __int16 v58 = 1024;
        *(_DWORD *)os_log_type_t v59 = v16;
        _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_DEBUG, "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d", buf, 0x12u);
      }

      goto LABEL_49;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v22 = (id)gLogObj;
    *(_DWORD *)int buf = 136446466;
    os_log_type_t v57 = "nw_path_report_error_to_agent";
    __int16 v58 = 1024;
    *(_DWORD *)os_log_type_t v59 = v16;
    os_log_type_t v23 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v54 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v23, type, &v54))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        BOOL v24 = __nwlog_obj();
        os_log_type_t v25 = type[0];
        if (os_log_type_enabled(v24, type[0]))
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v57 = "nw_path_report_error_to_agent";
          __int16 v58 = 1024;
          *(_DWORD *)os_log_type_t v59 = v16;
          _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d", buf, 0x12u);
        }
      }
      else if (v54)
      {
        BOOL v26 = (char *)__nw_create_backtrace_string();
        BOOL v24 = __nwlog_obj();
        os_log_type_t v27 = type[0];
        BOOL v28 = os_log_type_enabled(v24, type[0]);
        if (v26)
        {
          if (v28)
          {
            *(_DWORD *)int buf = 136446722;
            os_log_type_t v57 = "nw_path_report_error_to_agent";
            __int16 v58 = 1024;
            *(_DWORD *)os_log_type_t v59 = v16;
            *(_WORD *)&v59[4] = 2082;
            *(void *)&v59[6] = v26;
            _os_log_impl(&dword_1830D4000, v24, v27, "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v26);
          goto LABEL_47;
        }
        if (v28)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v57 = "nw_path_report_error_to_agent";
          __int16 v58 = 1024;
          *(_DWORD *)os_log_type_t v59 = v16;
          _os_log_impl(&dword_1830D4000, v24, v27, "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        BOOL v24 = __nwlog_obj();
        os_log_type_t v29 = type[0];
        if (os_log_type_enabled(v24, type[0]))
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v57 = "nw_path_report_error_to_agent";
          __int16 v58 = 1024;
          *(_DWORD *)os_log_type_t v59 = v16;
          _os_log_impl(&dword_1830D4000, v24, v29, "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
        }
      }
    }
LABEL_47:
    if (v23) {
      free(v23);
    }
    goto LABEL_49;
  }
  BOOL v36 = __nwlog_obj();
  os_log_type_enabled(v36, OS_LOG_TYPE_ERROR);
  *(_DWORD *)int buf = 136446722;
  os_log_type_t v57 = "strict_calloc";
  __int16 v58 = 2048;
  *(void *)os_log_type_t v59 = 1;
  *(_WORD *)&v59[8] = 2048;
  *(void *)&v59[10] = 25;
  BOOL v37 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v37);
  if (!result)
  {
    free(v37);
    long long v38 = __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v57 = "nw_necp_append_tlv";
    os_log_type_t v39 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v54 = OS_LOG_TYPE_ERROR;
    char v53 = 0;
    if (__nwlog_fault(v39, &v54, &v53))
    {
      if (v54 == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v40 = __nwlog_obj();
        os_log_type_t v41 = v54;
        if (os_log_type_enabled(v40, v54))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v57 = "nw_necp_append_tlv";
          _os_log_impl(&dword_1830D4000, v40, v41, "%{public}s called with null tlv_start", buf, 0xCu);
        }
      }
      else if (v53)
      {
        int v43 = (char *)__nw_create_backtrace_string();
        os_log_type_t v40 = __nwlog_obj();
        os_log_type_t v44 = v54;
        BOOL v45 = os_log_type_enabled(v40, v54);
        if (v43)
        {
          if (v45)
          {
            *(_DWORD *)int buf = 136446466;
            os_log_type_t v57 = "nw_necp_append_tlv";
            __int16 v58 = 2082;
            *(void *)os_log_type_t v59 = v43;
            _os_log_impl(&dword_1830D4000, v40, v44, "%{public}s called with null tlv_start, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v43);
          goto LABEL_85;
        }
        if (v45)
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v57 = "nw_necp_append_tlv";
          _os_log_impl(&dword_1830D4000, v40, v44, "%{public}s called with null tlv_start, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v40 = __nwlog_obj();
        os_log_type_t v46 = v54;
        if (os_log_type_enabled(v40, v54))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v57 = "nw_necp_append_tlv";
          _os_log_impl(&dword_1830D4000, v40, v46, "%{public}s called with null tlv_start, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_85:
    if (v39) {
      free(v39);
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v47 = (id)gLogObj;
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v57 = "nw_path_report_error_to_agent";
    int v7 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v54 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v7, type, &v54))
    {
LABEL_28:
      if (v7) {
LABEL_29:
      }
        free(v7);
LABEL_30:
      BOOL v15 = 0;
LABEL_50:

      return v15;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v48 = (id)gLogObj;
      os_log_type_t v49 = type[0];
      if (os_log_type_enabled(v48, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v57 = "nw_path_report_error_to_agent";
        _os_log_impl(&dword_1830D4000, v48, v49, "%{public}s nw_path_create_necp_agent_error failed", buf, 0xCu);
      }
LABEL_102:

      goto LABEL_28;
    }
    if (v54 == OS_LOG_TYPE_DEFAULT)
    {
      uint64_t v48 = __nwlog_obj();
      os_log_type_t v52 = type[0];
      if (os_log_type_enabled(v48, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v57 = "nw_path_report_error_to_agent";
        _os_log_impl(&dword_1830D4000, v48, v52, "%{public}s nw_path_create_necp_agent_error failed, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_102;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v48 = __nwlog_obj();
    os_log_type_t v50 = type[0];
    BOOL v51 = os_log_type_enabled(v48, type[0]);
    if (!backtrace_string)
    {
      if (v51)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v57 = "nw_path_report_error_to_agent";
        _os_log_impl(&dword_1830D4000, v48, v50, "%{public}s nw_path_create_necp_agent_error failed, no backtrace", buf, 0xCu);
      }
      goto LABEL_102;
    }
    if (v51)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v57 = "nw_path_report_error_to_agent";
      __int16 v58 = 2082;
      *(void *)os_log_type_t v59 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v48, v50, "%{public}s nw_path_create_necp_agent_error failed, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_61:
    free(backtrace_string);
    goto LABEL_28;
  }
  __break(1u);
  return result;
}