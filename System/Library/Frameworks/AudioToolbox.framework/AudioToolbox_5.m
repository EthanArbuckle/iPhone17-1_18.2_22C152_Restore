void sub_1BB33FDDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

void BypassableIRProcessor::process(uint64_t a1, void *a2, float *const *a3, unsigned int a4, unsigned int a5, vDSP_Length a6, int a7, float a8)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 208))
  {
    uint64_t v8 = *(void *)(a1 + 160);
    if (a4 < (unint64_t)((*(void *)(a1 + 168) - v8) >> 3))
    {
      v9 = *(float **)(v8 + 8 * a4);
      float v10 = 3000.0;
      if (a7) {
        float v10 = -1.0;
      }
      v9[40] = v10;
      __p[0] = a2;
      IR::IRProcessor::processMultipleInputs((IR::IRProcessor *)v9, (const float **)__p, a3, 1u, a5, a6, a8, 0);
    }
  }
  else
  {
    if (getAUSMV2Log(void)::onceToken != -1) {
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
    }
    v11 = getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR))
    {
      std::string::basic_string[abi:ne180100]<0>(&v17, "BypassableIRProcessor");
      v12 = std::string::append(&v17, "::", 2uLL);
      long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
      v18.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v18.__r_.__value_.__l.__data_ = v13;
      v12->__r_.__value_.__l.__size_ = 0;
      v12->__r_.__value_.__r.__words[2] = 0;
      v12->__r_.__value_.__r.__words[0] = 0;
      v14 = std::string::append(&v18, "process", 7uLL);
      long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
      int64_t v20 = v14->__r_.__value_.__r.__words[2];
      *(_OWORD *)__p = v15;
      v14->__r_.__value_.__l.__size_ = 0;
      v14->__r_.__value_.__r.__words[2] = 0;
      v14->__r_.__value_.__r.__words[0] = 0;
      v16 = __p;
      if (v20 < 0) {
        v16 = (void **)__p[0];
      }
      *(_DWORD *)buf = 136315138;
      v22 = v16;
      _os_log_error_impl(&dword_1BB0CE000, v11, OS_LOG_TYPE_ERROR, "%s: Uninitialized", buf, 0xCu);
      if (SHIBYTE(v20) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v18.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v17.__r_.__value_.__l.__data_);
      }
    }
  }
}

void sub_1BB33FFDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t BypassableIRProcessor::initialize(uint64_t a1, uint64_t a2, uint64_t a3, int a4, CFTypeRef *a5)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  *(unsigned char *)(a1 + 208) = 0;
  CFTypeRef v7 = *a5;
  if (*a5)
  {
    CFRetain(*a5);
    CFTypeRef v30 = v7;
    IR::IRDataAttributes::IRDataAttributes((uint64_t)v31, v7, 128, 1, 0.0);
  }
  else
  {
    IR::IRDataAttributes::IRDataAttributes((uint64_t)v31, a1 + 8);
  }
  v9 = (CFTypeRef *)(a1 + 8);
  uint64_t v8 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = *(void *)v31;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)&v31[8];
  *(_OWORD *)(a1 + 32) = v32;
  *(_OWORD *)(a1 + 48) = v33;
  *(unsigned char *)(a1 + 64) = v34;
  float v10 = *(const void **)(a1 + 72);
  CFTypeRef v11 = cf;
  *(void *)(a1 + 72) = v35;
  *(void *)v31 = v8;
  CFTypeRef v35 = v10;
  *(_OWORD *)(a1 + 80) = v36;
  CFTypeRef v12 = *(CFTypeRef *)(a1 + 96);
  *(void *)(a1 + 96) = v11;
  long long v13 = v38[0];
  *(_OWORD *)(a1 + 113) = *(_OWORD *)((char *)v38 + 9);
  *(_OWORD *)(a1 + 104) = v13;
  v14 = *(const void **)(a1 + 136);
  *(_DWORD *)(a1 + 152) = v41;
  long long v15 = v39;
  uint64_t v16 = v40;
  CFTypeRef cf = v12;
  v39 = v14;
  *(void *)(a1 + 136) = v15;
  *(void *)(a1 + 144) = v16;
  if (v14)
  {
    CFRelease(v14);
    CFTypeRef v12 = cf;
  }
  if (v12) {
    CFRelease(v12);
  }
  if (v35) {
    CFRelease(v35);
  }
  if (*(void *)v31) {
    CFRelease(*(CFTypeRef *)v31);
  }
  if (v7) {
    CFRelease(v7);
  }
  if (a4) {
    *(_DWORD *)(a1 + 220) = a4;
  }
  if (CFURLResourceIsReachable(*(CFURLRef *)(a1 + 8), 0))
  {
    if (*(void *)(a1 + 168) != *(void *)(a1 + 160)) {
      operator new();
    }
    uint64_t result = 0;
    *(unsigned char *)(a1 + 208) = 1;
  }
  else
  {
    v19 = *(IR::IRProcessor ***)(a1 + 160);
    std::string v18 = *(IR::IRProcessor ***)(a1 + 168);
    while (v19 != v18)
      std::unique_ptr<IR::IRProcessor>::reset[abi:ne180100](v19++, 0);
    if (getAUSMV2Log(void)::onceToken != -1) {
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
    }
    int64_t v20 = getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR))
    {
      std::string::basic_string[abi:ne180100]<0>(&v28, "BypassableIRProcessor");
      v21 = std::string::append(&v28, "::", 2uLL);
      long long v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
      v29.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v29.__r_.__value_.__l.__data_ = v22;
      v21->__r_.__value_.__l.__size_ = 0;
      v21->__r_.__value_.__r.__words[2] = 0;
      v21->__r_.__value_.__r.__words[0] = 0;
      uint64_t v23 = std::string::append(&v29, "initialize", 0xAuLL);
      long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
      *(void *)&v31[16] = *((void *)&v23->__r_.__value_.__l + 2);
      *(_OWORD *)v31 = v24;
      v23->__r_.__value_.__l.__size_ = 0;
      v23->__r_.__value_.__r.__words[2] = 0;
      v23->__r_.__value_.__r.__words[0] = 0;
      if (v31[23] >= 0) {
        v25 = v31;
      }
      else {
        v25 = *(unsigned char **)v31;
      }
      CFStringRef v26 = CFCopyDescription(*v9);
      applesauce::CF::details::CFString_get_value<true>(v26, (uint64_t)v42);
      if (v26) {
        CFRelease(v26);
      }
      v27 = v42;
      if (v43 < 0) {
        v27 = *(uint8_t **)v42;
      }
      *(_DWORD *)buf = 136315394;
      v45 = v25;
      __int16 v46 = 2080;
      v47 = v27;
      _os_log_error_impl(&dword_1BB0CE000, v20, OS_LOG_TYPE_ERROR, "%s: Could not locate an IR file at %s", buf, 0x16u);
      if (v43 < 0) {
        operator delete(*(void **)v42);
      }
      if ((v31[23] & 0x80000000) != 0) {
        operator delete(*(void **)v31);
      }
      if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v29.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v28.__r_.__value_.__l.__data_);
      }
    }
    return 4294956445;
  }
  return result;
}

void sub_1BB3405B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t IR::IRDataAttributes::IRDataAttributes(uint64_t a1, CFTypeRef cf, int a3, char a4, float a5)
{
  if (cf) {
    CFRetain(cf);
  }
  CFURLRef v11 = (CFURLRef)cf;
  IR::IRDataAttributes::IRDataAttributes(a1, &v11, a3, a4, a5);
  if (cf) {
    CFRelease(cf);
  }
  return a1;
}

void sub_1BB340708(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::URLRef::~URLRef((const void **)va);
  _Unwind_Resume(a1);
}

void applesauce::CF::URLRef::~URLRef(const void **this)
{
  v1 = *this;
  if (v1) {
    CFRelease(v1);
  }
}

IR::IRProcessor *std::unique_ptr<IR::IRProcessor>::reset[abi:ne180100](IR::IRProcessor **a1, IR::IRProcessor *a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    IR::IRProcessor::~IRProcessor(result);
    JUMPOUT(0x1C185D370);
  }
  return result;
}

IR::IRProcessor *IR::IRProcessor::IRProcessor(IR::IRProcessor *this, const IR::IRDataAttributes *a2, int a3)
{
  IR::DataLoaderSource::DataLoaderSource((IR::DataLoaderSource *)&v6, a2);
  IR::IRProcessor::IRProcessor((uint64_t)this, (uint64_t)&v6, a3);
  v6 = &unk_1F14BD940;
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v11);
  }
  v6 = &unk_1F14BEDB0;
  if (cf) {
    CFRelease(cf);
  }
  if (v9) {
    CFRelease(v9);
  }
  if (v8) {
    CFRelease(v8);
  }
  if (v7) {
    CFRelease(v7);
  }
  return this;
}

void sub_1BB34087C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

IR::DataLoaderSource *IR::DataLoaderSource::DataLoaderSource(IR::DataLoaderSource *this, const IR::IRDataAttributes *a2)
{
  *(void *)this = &unk_1F14BEDB0;
  IR::IRDataAttributes::IRDataAttributes((uint64_t)this + 8, (uint64_t)a2);
  *((void *)this + 20) = 0;
  *((void *)this + 21) = 0;
  *((unsigned char *)this + 176) = 0;
  *((_DWORD *)this + 45) = -65536;
  *(void *)this = &unk_1F14BD940;
  IR::IRCoordinates::IRCoordinates((IR::DataLoaderSource *)((char *)this + 184));
  *((_WORD *)this + 110) = 0;
  *((void *)this + 28) = 0;
  *((void *)this + 29) = 0;
  return this;
}

void sub_1BB340924(_Unwind_Exception *a1)
{
  void *v1 = v2;
  IR::IRDataAttributes::~IRDataAttributes(v3);
  _Unwind_Resume(a1);
}

uint64_t IR::IRProcessor::IRProcessor(uint64_t a1, uint64_t a2, int a3)
{
  *(void *)a1 = &unk_1F14C3260;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  caulk::pooled_semaphore_mutex::pooled_semaphore_mutex((caulk::pooled_semaphore_mutex *)(a1 + 20));
  v6 = (char *)operator new(0x108uLL);
  *((void *)v6 + 1) = 0;
  *((void *)v6 + 2) = 0;
  *(void *)v6 = &unk_1F14BD908;
  *((void *)v6 + 4) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  long long v7 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v6 + 40) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v6 + 56) = v7;
  *(_OWORD *)(v6 + 72) = *(_OWORD *)(a2 + 48);
  v6[88] = *(unsigned char *)(a2 + 64);
  *((void *)v6 + 12) = *(void *)(a2 + 72);
  *(void *)(a2 + 72) = 0;
  *(_OWORD *)(v6 + 104) = *(_OWORD *)(a2 + 80);
  *((void *)v6 + 15) = *(void *)(a2 + 96);
  *(void *)(a2 + 96) = 0;
  *((_OWORD *)v6 + 8) = *(_OWORD *)(a2 + 104);
  *(_OWORD *)(v6 + 137) = *(_OWORD *)(a2 + 113);
  uint64_t v8 = *(void *)(a2 + 136);
  uint64_t v9 = *(void *)(a2 + 144);
  *(void *)(a2 + 136) = 0;
  *((void *)v6 + 20) = v8;
  *((void *)v6 + 21) = v9;
  *((_DWORD *)v6 + 44) = *(_DWORD *)(a2 + 152);
  *((void *)v6 + 25) = *(void *)(a2 + 176);
  *(_OWORD *)(v6 + 184) = *(_OWORD *)(a2 + 160);
  *((void *)v6 + 3) = &unk_1F14BD940;
  *(void *)(v6 + 238) = *(void *)(a2 + 214);
  long long v10 = *(_OWORD *)(a2 + 200);
  *((_OWORD *)v6 + 13) = *(_OWORD *)(a2 + 184);
  *((_OWORD *)v6 + 14) = v10;
  *(_OWORD *)(v6 + 248) = *(_OWORD *)(a2 + 224);
  *(void *)(a2 + 224) = 0;
  *(void *)(a2 + 232) = 0;
  *(void *)(a1 + 24) = v6 + 24;
  *(void *)(a1 + 32) = v6;
  *(unsigned char *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(unsigned char *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(void *)(a1 + 160) = 0x3F800000453B8000;
  *(unsigned char *)(a1 + 168) = 1;
  *(_DWORD *)(a1 + 172) = a3;
  *(unsigned char *)(a1 + 176) = 0;
  return a1;
}

void IR::DataLoaderSource::~DataLoaderSource(IR::DataLoaderSource *this)
{
  *(void *)this = &unk_1F14BD940;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 29);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  *(void *)this = &unk_1F14BEDB0;
  IR::IRDataAttributes::~IRDataAttributes((IR::DataLoaderSource *)((char *)this + 8));
}

{
  std::__shared_weak_count *v2;
  uint64_t vars8;

  *(void *)this = &unk_1F14BD940;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 29);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  *(void *)this = &unk_1F14BEDB0;
  IR::IRDataAttributes::~IRDataAttributes((IR::DataLoaderSource *)((char *)this + 8));

  JUMPOUT(0x1C185D370);
}

void IR::IRDataAttributes::~IRDataAttributes(IR::IRDataAttributes *this)
{
  uint64_t v2 = (const void *)*((void *)this + 16);
  if (v2) {
    CFRelease(v2);
  }
  v3 = (const void *)*((void *)this + 11);
  if (v3) {
    CFRelease(v3);
  }
  v4 = (const void *)*((void *)this + 8);
  if (v4) {
    CFRelease(v4);
  }
  if (*(void *)this) {
    CFRelease(*(CFTypeRef *)this);
  }
}

uint64_t std::__shared_ptr_emplace<IR::DataLoaderSource>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<IR::DataLoaderSource>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F14BD908;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1C185D370);
}

void std::__shared_ptr_emplace<IR::DataLoaderSource>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F14BD908;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void IR::IRProcessor::~IRProcessor(IR::IRProcessor *this)
{
  *(void *)this = &unk_1F14C3260;
  v5 = (void **)((char *)this + 136);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
  uint64_t v2 = (void *)*((void *)this + 14);
  if (v2)
  {
    *((void *)this + 15) = v2;
    operator delete(v2);
  }
  v5 = (void **)((char *)this + 88);
  std::vector<IR::FixedIntegerDelay>::__destroy_vector::operator()[abi:ne180100](&v5);
  v5 = (void **)((char *)this + 64);
  std::vector<IR::DelayLine>::__destroy_vector::operator()[abi:ne180100](&v5);
  uint64_t v3 = *((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  v4 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
}

void std::vector<IR::FixedIntegerDelay>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 7;
        std::__destroy_at[abi:ne180100]<IR::FixedIntegerDelay,0>(v4);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<IR::DelayLine>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        IR::DelayLine::~DelayLine((IR::DelayLine *)(v4 - 304));
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__destroy_at[abi:ne180100]<IR::FixedIntegerDelay,0>(void *a1)
{
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[1];
  if (v3)
  {
    a1[2] = v3;
    operator delete(v3);
  }
}

uint64_t IR::IRDataAttributes::IRDataAttributes(uint64_t a1, CFURLRef *a2, int a3, char a4, float a5)
{
  *(void *)a1 = 0;
  *(float *)(a1 + 8) = a5;
  *(_DWORD *)(a1 + 12) = a3;
  *(unsigned char *)(a1 + 16) = a4;
  *(unsigned char *)(a1 + 17) = 0;
  *(_DWORD *)(a1 + 20) = 2;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(_OWORD *)(a1 + 40) = xmmword_1BB879BE0;
  *(unsigned char *)(a1 + 56) = 1;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 92) = 0u;
  *(_DWORD *)(a1 + 108) = 200;
  *(unsigned char *)(a1 + 112) = 1;
  *(_DWORD *)(a1 + 116) = 0;
  *(unsigned char *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(_DWORD *)(a1 + 144) = 0;
  *(void *)(a1 + 136) = 0;
  if (*a2)
  {
    CFURLRef v6 = CFURLCopyAbsoluteURL(*a2);
    applesauce::CF::URLRef::URLRef((applesauce::CF::URLRef *)&v9, v6);
    long long v7 = *(const void **)a1;
    *(void *)a1 = v9;
    uint64_t v9 = v7;
    if (v7) {
      CFRelease(v7);
    }
  }
  return a1;
}

void sub_1BB340F28(_Unwind_Exception *a1)
{
  applesauce::CF::DictionaryRef::~DictionaryRef(v3);
  applesauce::CF::URLRef::~URLRef(v1 + 11);
  applesauce::CF::URLRef::~URLRef(v2);
  applesauce::CF::URLRef::~URLRef(v1);
  _Unwind_Resume(a1);
}

applesauce::CF::URLRef *applesauce::CF::URLRef::URLRef(applesauce::CF::URLRef *this, CFTypeRef cf)
{
  *(void *)this = cf;
  if (cf)
  {
    CFTypeID v3 = CFGetTypeID(cf);
    if (v3 != CFURLGetTypeID())
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
    }
  }
  return this;
}

{
  if (cf) {
    CFRetain(cf);
  }
  *(void *)this = cf;
  return this;
}

void sub_1BB340FE0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v2);
  if (*v1) {
    CFRelease(*v1);
  }
  _Unwind_Resume(a1);
}

void BypassableIRProcessor::BypassableIRProcessor(BypassableIRProcessor *this, const IR::IRDataAttributes *a2, unsigned int a3)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  *(void *)this = &unk_1F14BECB8;
  IR::IRDataAttributes::IRDataAttributes((uint64_t)this + 8, (uint64_t)a2);
  *((_OWORD *)this + 10) = 0u;
  *((_DWORD *)this + 53) = 0;
  *((_DWORD *)this + 54) = 0;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_WORD *)this + 104) = 0;
  *((_DWORD *)this + 55) = 512;
  if (!a3)
  {
    if (getAUSMV2Log(void)::onceToken != -1) {
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
    }
    v5 = getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR))
    {
      std::string::basic_string[abi:ne180100]<0>(&v28, "BypassableIRProcessor");
      uint64_t v23 = std::string::append(&v28, "::", 2uLL);
      long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
      v29.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v29.__r_.__value_.__l.__data_ = v24;
      v23->__r_.__value_.__l.__size_ = 0;
      v23->__r_.__value_.__r.__words[2] = 0;
      v23->__r_.__value_.__r.__words[0] = 0;
      v25 = std::string::append(&v29, "BypassableIRProcessor", 0x15uLL);
      long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
      int64_t v31 = v25->__r_.__value_.__r.__words[2];
      *(_OWORD *)__p = v26;
      v25->__r_.__value_.__l.__size_ = 0;
      v25->__r_.__value_.__r.__words[2] = 0;
      v25->__r_.__value_.__r.__words[0] = 0;
      v27 = __p;
      if (v31 < 0) {
        v27 = (void **)__p[0];
      }
      *(_DWORD *)buf = 136315138;
      long long v33 = v27;
      _os_log_error_impl(&dword_1BB0CE000, v5, OS_LOG_TYPE_ERROR, "%s: inNumIRProcessors cannot be zero when creating an instance of this class", buf, 0xCu);
      if (SHIBYTE(v31) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v29.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v28.__r_.__value_.__l.__data_);
      }
    }
  }
  long long v7 = (IR::IRProcessor **)*((void *)this + 20);
  CFURLRef v6 = (IR::IRProcessor **)*((void *)this + 21);
  unint64_t v8 = v6 - v7;
  if (a3 <= v8)
  {
    if (a3 < v8)
    {
      v19 = &v7[a3];
      while (v6 != v19)
        std::unique_ptr<IR::IRProcessor>::reset[abi:ne180100](--v6, 0);
      *((void *)this + 21) = v19;
    }
  }
  else
  {
    unint64_t v9 = a3 - v8;
    uint64_t v10 = *((void *)this + 22);
    if (v9 <= (v10 - (uint64_t)v6) >> 3)
    {
      bzero(*((void **)this + 21), 8 * v9);
      *((void *)this + 21) = &v6[v9];
    }
    else
    {
      uint64_t v11 = v10 - (void)v7;
      uint64_t v12 = v11 >> 2;
      if (v11 >> 2 <= (unint64_t)a3) {
        uint64_t v12 = a3;
      }
      if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v13 = v12;
      }
      if (v13 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      v14 = (char *)operator new(8 * v13);
      long long v15 = &v14[8 * v8];
      uint64_t v16 = &v14[8 * v13];
      bzero(v15, 8 * v9);
      std::string v17 = &v15[8 * v9];
      while (v6 != v7)
      {
        uint64_t v18 = (uint64_t)*--v6;
        char *v6 = 0;
        *((void *)v15 - 1) = v18;
        v15 -= 8;
      }
      long long v20 = *((_OWORD *)this + 10);
      *((void *)this + 20) = v15;
      *((void *)this + 21) = v17;
      *((void *)this + 22) = v16;
      v21 = (IR::IRProcessor **)*((void *)&v20 + 1);
      long long v22 = (IR::IRProcessor **)v20;
      while (v21 != v22)
        std::unique_ptr<IR::IRProcessor>::reset[abi:ne180100](--v21, 0);
      if (v22) {
        operator delete(v22);
      }
    }
  }
  std::vector<std::vector<float>>::resize((uint64_t *)this + 23, a3);
}

void sub_1BB341324(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a23);
  std::vector<std::unique_ptr<IR::IRProcessor>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a23);
  IR::IRDataAttributes::~IRDataAttributes(v23);
  _Unwind_Resume(a1);
}

void std::vector<std::unique_ptr<IR::IRProcessor>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  v1 = *a1;
  uint64_t v2 = (IR::IRProcessor **)**a1;
  if (v2)
  {
    v4 = (IR::IRProcessor **)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
        std::unique_ptr<IR::IRProcessor>::reset[abi:ne180100](--v4, 0);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t NoiseSuppression::Noise::VPv3::GetNoiseBins(NoiseSuppression::Noise::VPv3 *this)
{
  return (uint64_t)this + 304;
}

void NoiseSuppression::Noise::VPv3::Process(NoiseSuppression::Noise::VPv3 *this, const float *__A, float *a3, unsigned int a4)
{
  CFURLRef v6 = __A;
  int v8 = *((_DWORD *)this + 44);
  if (v8 == 2)
  {
LABEL_11:
    uint64_t v10 = (float *)*((void *)this + 23);
    uint64_t v11 = *((void *)this + 35);
    float v12 = 1.0 - *((float *)this + 21);
    float v13 = *((float *)this + 23);
    float v32 = v12 * (float)(1.0 - v13);
    float __B = v12 * v13;
    *(_DWORD *)uint64_t v11 = 0;
    vDSP_vsmul(v6, 1, &__B, (float *)(v11 + 4), 1, a4 - 1);
    vDSP_vsma(v6 + 1, 1, &__B, (const float *)v11, 1, (float *)v11, 1, a4 - 1);
    vDSP_vsma(v6, 1, &v32, (const float *)v11, 1, (float *)v11, 1, a4);
    vDSP_vsma(v10, 1, (const float *)this + 21, (const float *)v11, 1, v10, 1, a4);
    float v14 = *((float *)this + 4);
    LODWORD(v15) = *((_DWORD *)this + 5);
    if (v14 * 0.5 <= (double)v15) {
      float v16 = v14 * *((float *)this + 28);
    }
    else {
      float v16 = v14 * 0.2;
    }
    unsigned int v17 = *((_DWORD *)this + 22) + 1;
    *((_DWORD *)this + 22) = v17;
    if (v16 >= (float)v17)
    {
      vDSP_vmin(*((const float **)this + 26), 1, *((const float **)this + 23), 1, *((float **)this + 26), 1, (uint64_t)(*((void *)this + 27) - *((void *)this + 26)) >> 2);
      vDSP_vmin(*((const float **)this + 29), 1, *((const float **)this + 23), 1, *((float **)this + 29), 1, (uint64_t)(*((void *)this + 27) - *((void *)this + 26)) >> 2);
    }
    else
    {
      uint64_t v18 = (const float *)*((void *)this + 29);
      *((_DWORD *)this + 22) = 0;
      vDSP_vmin(v18, 1, *((const float **)this + 23), 1, *((float **)this + 26), 1, (uint64_t)(*((void *)this + 27) - *((void *)this + 26)) >> 2);
      std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)this + 232, *((char **)this + 23), *((void *)this + 24), (uint64_t)(*((void *)this + 24) - *((void *)this + 23)) >> 2);
    }
    vDSP_vma(*((const float **)this + 26), 1, *((const float **)this + 15), 1, *((const float **)this + 23), 1, *((float **)this + 35), 1, (uint64_t)(*((void *)this + 27) - *((void *)this + 26)) >> 2);
    if (!a4) {
      goto LABEL_33;
    }
    unint64_t v19 = 0;
    uint64_t v20 = *((void *)this + 32);
    uint64_t v21 = *((void *)this + 35);
    uint64_t v22 = *((void *)this + 26);
    uint64_t v23 = *((void *)this + 38);
    while (1)
    {
      float v24 = v6[v19];
      float v25 = *(float *)(v22 + 4 * v19);
      float v26 = v24 - (float)(v25 * *((float *)this + 27));
      if (*(float *)(v21 + 4 * v19) >= v26) {
        float v26 = *(float *)(v21 + 4 * v19);
      }
      unint64_t v27 = v19 >> 6;
      uint64_t v28 = 1 << v19;
      if (v26 <= 0.0) {
        uint64_t v29 = *(void *)(v23 + 8 * v27) | v28;
      }
      else {
        uint64_t v29 = *(void *)(v23 + 8 * v27) & ~v28;
      }
      float v30 = *((float *)this + 25);
      float v31 = *(float *)(v20 + 4 * v19);
      *(void *)(v23 + 8 * v27) = v29;
      if ((v29 & v28) != 0) {
        goto LABEL_27;
      }
      if (*(float *)(*((void *)this + 23) + 4 * v19) < (float)(v25 * *((float *)this + 26))) {
        break;
      }
LABEL_28:
      if (a3) {
        a3[v19] = v31;
      }
      if (a4 == ++v19) {
        goto LABEL_33;
      }
    }
    float v24 = (float)((float)(1.0 - v30) * v31) + (float)(v24 * v30);
LABEL_27:
    *(float *)(v20 + 4 * v19) = v24;
    float v31 = v24;
    goto LABEL_28;
  }
  if (v8 == 1)
  {
    *((_DWORD *)this + 44) = 2;
    memcpy(*((void **)this + 32), __A, 4 * a4);
    memcpy(*((void **)this + 26), v6, 4 * a4);
    int v8 = *((_DWORD *)this + 44);
LABEL_10:
    if (v8 != 2) {
      goto LABEL_33;
    }
    goto LABEL_11;
  }
  if (v8) {
    goto LABEL_10;
  }
  if (a4)
  {
    uint64_t v9 = 4 * a4;
    while (*v6 == 0.0)
    {
      ++v6;
      v9 -= 4;
      if (!v9) {
        goto LABEL_33;
      }
    }
    *((_DWORD *)this + 44) = 1;
  }
LABEL_33:
  ++*((_DWORD *)this + 5);
}

void NoiseSuppression::Noise::VPv3::Init(NoiseSuppression::Noise::VPv3 *this)
{
  float v2 = *((float *)this + 4);
  *((float *)this + 21) = expf(-1.0 / (float)(*((float *)this + 20) * v2));
  *((float *)this + 25) = 1.0 - expf(-1.0 / (float)(v2 * *((float *)this + 24)));
  std::vector<float>::resize((uint64_t)this + 184, *((unsigned int *)this + 3));
  unint64_t v3 = (uint64_t)(*((void *)this + 24) - *((void *)this + 23)) >> 2;
  int v32 = 0;
  std::vector<float>::assign((char **)this + 23, v3, &v32);
  std::vector<float>::resize((uint64_t)this + 208, *((unsigned int *)this + 3));
  unint64_t v4 = (uint64_t)(*((void *)this + 27) - *((void *)this + 26)) >> 2;
  int v32 = 0;
  std::vector<float>::assign((char **)this + 26, v4, &v32);
  std::vector<float>::resize((uint64_t)this + 232, *((unsigned int *)this + 3));
  unint64_t v5 = (uint64_t)(*((void *)this + 30) - *((void *)this + 29)) >> 2;
  int v32 = 0;
  std::vector<float>::assign((char **)this + 29, v5, &v32);
  std::vector<float>::resize((uint64_t)this + 256, *((unsigned int *)this + 3));
  std::vector<float>::assign((char **)this + 32, (uint64_t)(*((void *)this + 33) - *((void *)this + 32)) >> 2, &AUFTSpatialAC::kFTSpatialMinWindow_XY_size);
  std::vector<float>::resize((uint64_t)this + 280, *((unsigned int *)this + 3));
  unint64_t v6 = *((unsigned int *)this + 3);
  int v32 = 0;
  std::vector<float>::assign((char **)this + 35, v6, &v32);
  std::vector<BOOL>::resize((uint64_t)this + 304, *((unsigned int *)this + 3), 0);
  unint64_t v7 = *((unsigned int *)this + 3);
  LOBYTE(v32) = 0;
  std::vector<BOOL>::assign((uint64_t)this + 304, v7, &v32);
  std::vector<float>::resize((uint64_t)this + 120, *((unsigned int *)this + 37));
  unint64_t v8 = *((unsigned int *)this + 37);
  int v32 = 0;
  std::vector<float>::assign((char **)this + 15, v8, &v32);
  uint64_t v9 = (float *)*((void *)this + 15);
  vDSP_Length v10 = (uint64_t)(*((void *)this + 16) - (void)v9) >> 2;
  uint64_t v11 = (float *)*((void *)this + 19);
  uint64_t v12 = *((void *)this + 20);
  unint64_t v13 = ((v12 - (uint64_t)v11) >> 3) - 1;
  if ((v12 - (uint64_t)v11) >> 3 != 1)
  {
    unint64_t v14 = 0;
    LODWORD(v15) = 0;
    float v16 = (float)v10 / (float)(*(float *)(v12 - 8) - *v11);
    float v17 = *v11 * v16;
    do
    {
      uint64_t v18 = &v11[2 * v14];
      unint64_t v14 = (v14 + 1);
      unint64_t v19 = &v11[2 * v14];
      float v20 = v18[1];
      float v22 = *v19;
      float v21 = v19[1];
      float v23 = v16 * (float)((float)(*v18 + *v19) * 0.5);
      float v24 = (float)(v20 + v21) * 0.5;
      if (v17 < v23)
      {
        float v25 = v16 * *v18;
        uint64_t v15 = (int)v15;
        do
        {
          v9[v15++] = v20
                    + (float)((float)((float)((float)(v17 - v25) / (float)(v23 - v25))
                                    * (float)((float)(v17 - v25) / (float)(v23 - v25)))
                            * (float)(v24 - v20));
          float v17 = v17 + 1.0;
        }
        while (v17 < v23);
      }
      float v26 = v16 * v22;
      if (v17 < v26)
      {
        unsigned int v27 = *((_DWORD *)this + 37);
        float v28 = v23 - v26;
        float v29 = v21 - v24;
        uint64_t v30 = (int)v15;
        if (v15 <= v27) {
          LODWORD(v15) = *((_DWORD *)this + 37);
        }
        while (v27 > v30)
        {
          int v31 = v30 + 1;
          v9[v30] = v24
                  + (float)((float)(1.0 - (float)((float)((float)(v17 - v26) / v28) * (float)((float)(v17 - v26) / v28)))
                          * v29);
          float v17 = v17 + 1.0;
          ++v30;
          if (v17 >= v26)
          {
            LODWORD(v15) = v31;
            break;
          }
        }
      }
    }
    while (v13 > v14);
  }
  vDSP_vneg(v9, 1, v9, 1, v10);
  *((_DWORD *)this + 44) = 0;
  *((unsigned char *)this + 24) = 1;
}

void std::vector<BOOL>::assign(uint64_t a1, unint64_t a2, unsigned char *a3)
{
  *(void *)(a1 + 8) = 0;
  if (a2)
  {
    uint64_t v6 = *(void *)(a1 + 16);
    unint64_t v7 = v6 << 6;
    if (v6 << 6 >= a2)
    {
      *(void *)(a1 + 8) = a2;
    }
    else
    {
      unint64_t v14 = 0;
      long long v15 = 0uLL;
      if ((a2 & 0x8000000000000000) != 0) {
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v8 = v6 << 7;
      if (v8 <= ((a2 + 63) & 0xFFFFFFFFFFFFFFC0)) {
        unint64_t v8 = (a2 + 63) & 0xFFFFFFFFFFFFFFC0;
      }
      if (v7 <= 0x3FFFFFFFFFFFFFFELL) {
        unint64_t v9 = v8;
      }
      else {
        unint64_t v9 = 0x7FFFFFFFFFFFFFFFLL;
      }
      std::vector<BOOL>::reserve(&v14, v9);
      uint64_t v11 = v14;
      uint64_t v12 = *((void *)&v15 + 1);
      unint64_t v14 = *(char **)a1;
      vDSP_Length v10 = v14;
      long long v13 = *(_OWORD *)(a1 + 8);
      *(void *)a1 = v11;
      *(void *)(a1 + 8) = a2;
      *(void *)(a1 + 16) = v12;
      long long v15 = v13;
      if (v10) {
        operator delete(v10);
      }
    }
    if (*a3)
    {
      unint64_t v14 = *(char **)a1;
      LODWORD(v15) = 0;
      std::__fill_n[abi:ne180100]<true,std::vector<BOOL>>(&v14, a2);
    }
    else
    {
      unint64_t v14 = *(char **)a1;
      LODWORD(v15) = 0;
      std::__fill_n[abi:ne180100]<false,std::__bitset<1ul,8ul>>((uint64_t)&v14, a2);
    }
  }
}

void sub_1BB341B20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void NoiseSuppression::Noise::VPv3::~VPv3(NoiseSuppression::Noise::VPv3 *this)
{
  NoiseSuppression::Noise::VPv3::~VPv3(this);

  JUMPOUT(0x1C185D370);
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  uint64_t vars8;

  *(void *)this = &unk_1F14AE1C0;
  float v2 = (void *)*((void *)this + 38);
  if (v2) {
    operator delete(v2);
  }
  unint64_t v3 = (void *)*((void *)this + 35);
  if (v3)
  {
    *((void *)this + 36) = v3;
    operator delete(v3);
  }
  unint64_t v4 = (void *)*((void *)this + 32);
  if (v4)
  {
    *((void *)this + 33) = v4;
    operator delete(v4);
  }
  unint64_t v5 = (void *)*((void *)this + 29);
  if (v5)
  {
    *((void *)this + 30) = v5;
    operator delete(v5);
  }
  uint64_t v6 = (void *)*((void *)this + 26);
  if (v6)
  {
    *((void *)this + 27) = v6;
    operator delete(v6);
  }
  unint64_t v7 = (void *)*((void *)this + 23);
  if (v7)
  {
    *((void *)this + 24) = v7;
    operator delete(v7);
  }
  unint64_t v8 = (void *)*((void *)this + 19);
  if (v8)
  {
    *((void *)this + 20) = v8;
    operator delete(v8);
  }
  unint64_t v9 = (void *)*((void *)this + 15);
  if (v9)
  {
    *((void *)this + 16) = v9;
    operator delete(v9);
  }

  NoiseSuppression::Noise::NoiseEstimator::~NoiseEstimator(this);
}

uint64_t AUEchoGateV3::SetBypassEffect(uint64_t this, char a2)
{
  *(unsigned char *)(this + 528) = a2;
  return this;
}

uint64_t AUEchoGateV3::ShouldBypassEffect(AUEchoGateV3 *this)
{
  return *((unsigned __int8 *)this + 528);
}

uint64_t AUEchoGateV3::ChangeStreamFormat(AUEchoGateV3 *this, uint64_t a2, uint64_t a3, const AudioStreamBasicDescription *a4, const AudioStreamBasicDescription *a5)
{
  unsigned int v6 = a3;
  int v7 = a2;
  ausdk::AUBase::ChangeStreamFormat(this, a2, a3, a4, a5);
  uint64_t result = 0;
  if (v7 == 1 && v6 - 1 <= 2)
  {
    if (a5->mFormatID == 1718773105) {
      uint64_t result = 0;
    }
    else {
      uint64_t result = 4294967246;
    }
    *((unsigned char *)this + v6 + 588) = a5->mFormatID == 1718773105;
  }
  return result;
}

uint64_t AUEchoGateV3::ValidFormat(AUEchoGateV3 *this, const AudioStreamBasicDescription *a2, int a3, AudioStreamBasicDescription *a4)
{
  int v6 = (int)a2;
  uint64_t result = ausdk::ASBD::IsCommonFloat32((ausdk::ASBD *)a4, a2);
  if (result) {
    uint64_t result = (a4->mFormatFlags & 0x20) != 0 || a4->mChannelsPerFrame == 1;
  }
  if (v6 == 1)
  {
    if ((a3 - 1) <= 2 && result != 1 && a4->mFormatID == 1718773105)
    {
      BOOL v11 = 0;
      UInt32 mChannelsPerFrame = a4->mChannelsPerFrame;
      if (a4->mFramesPerPacket == 1
        && (UInt32 mBytesPerPacket = a4->mBytesPerPacket, mBytesPerFrame = a4->mBytesPerFrame,
                                                   mBytesPerFrame == mBytesPerPacket)
        && (UInt32 mBitsPerChannel = a4->mBitsPerChannel, mBitsPerChannel >> 3 <= mBytesPerFrame))
      {
        int v16 = 0;
        if (mChannelsPerFrame)
        {
          AudioFormatFlags mFormatFlags = a4->mFormatFlags;
          if ((mFormatFlags & 0x20) != 0
            || (BOOL v21 = mBytesPerPacket == mBytesPerPacket / mChannelsPerFrame * mChannelsPerFrame,
                mBytesPerPacket /= mChannelsPerFrame,
                v21))
          {
            int v18 = 8 * mBytesPerPacket;
            BOOL v19 = mBytesPerPacket == 8 && (a4->mFormatFlags & 0x1F84) == 0;
            if (mFormatFlags)
            {
              BOOL v20 = (a4->mFormatFlags & 0x1F84) == 0;
            }
            else
            {
              BOOL v19 = 0;
              BOOL v20 = 1;
            }
            BOOL v21 = v18 == mBitsPerChannel;
            BOOL v22 = v18 == mBitsPerChannel && v19;
            int v23 = !v21 || v20;
            BOOL v11 = (mFormatFlags & 2) == 0 && v22;
            if ((a4->mFormatFlags & 2) != 0) {
              int v16 = 1;
            }
            else {
              int v16 = v23;
            }
          }
          else
          {
            BOOL v11 = 0;
            int v16 = 0;
          }
        }
      }
      else
      {
        int v16 = 0;
      }
      LODWORD(result) = v11 & v16;
    }
    else
    {
      UInt32 mChannelsPerFrame = a4->mChannelsPerFrame;
    }
    if (mChannelsPerFrame == 1) {
      return result;
    }
    else {
      return 0;
    }
  }
  else if (v6 == 2)
  {
    AudioFormatID mFormatID = a4->mFormatID;
    UInt32 v10 = a4->mBytesPerFrame;
    UInt32 v9 = a4->mChannelsPerFrame;
    return v10 == 8 && mFormatID == 1718773105 && v9 == 1 || v10 == 4 && mFormatID == 1819304813 && v9 == 1;
  }
  return result;
}

uint64_t AUEchoGateV3::SupportedNumChannels(AUEchoGateV3 *this, const AUChannelInfo **a2)
{
  if (a2) {
    *a2 = (const AUChannelInfo *)&AUEchoGateV3::SupportedNumChannels(AUChannelInfo const**)::sSupportedChannelConfigs;
  }
  return 1;
}

BOOL AUEchoGateV3::StreamFormatWritable(AUEchoGateV3 *this)
{
  return *((unsigned char *)this + 17) == 0;
}

uint64_t AUEchoGateV3::SupportsTail(AUEchoGateV3 *this)
{
  return 1;
}

double AUEchoGateV3::GetTailTime(AUEchoGateV3 *this)
{
  return 0.0;
}

double AUEchoGateV3::GetLatency(AUEchoGateV3 *this)
{
  return 0.0;
}

uint64_t AUEchoGateV3::NewFactoryPresetSet(AUEchoGateV3 *this, const AUPreset *a2)
{
  if (a2->presetNumber) {
    return 4294956445;
  }
  Element = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUEchoGateV3 *)((char *)this + 32), 0);
  long long v7 = xmmword_1BB879BF0;
  long long v8 = xmmword_1BB879C00;
  long long v9 = xmmword_1BB879C10;
  long long v10 = xmmword_1BB879C20;
  long long v11 = xmmword_1BB879C30;
  *(void *)uint64_t v12 = 1086324736;
  uint64_t v5 = *((void *)this + 67);
  if (v5)
  {
    (*(void (**)(uint64_t, uint64_t, long long *))(*(void *)v5 + 32))(v5, 8, &v7);
    float v6 = *(float *)&v7;
  }
  else
  {
    float v6 = -90.0;
  }
  *((_DWORD *)this + 146) = 0;
  ausdk::AUElement::SetParameter(Element, 6u, v6, 0);
  ausdk::AUElement::SetParameter(Element, 7u, *((float *)&v8 + 3), 0);
  ausdk::AUElement::SetParameter(Element, 8u, *(float *)&v9, 0);
  ausdk::AUElement::SetParameter(Element, 9u, *((float *)&v7 + 1), 0);
  ausdk::AUElement::SetParameter(Element, 0xAu, *((float *)&v7 + 2), 0);
  ausdk::AUElement::SetParameter(Element, 0xCu, *((float *)&v7 + 3), 0);
  ausdk::AUElement::SetParameter(Element, 0xDu, *((float *)&v9 + 1), 0);
  ausdk::AUElement::SetParameter(Element, 0xFu, *((float *)&v9 + 3), 0);
  ausdk::AUElement::SetParameter(Element, 0x10u, *(float *)&v10, 0);
  ausdk::AUElement::SetParameter(Element, 0x12u, *((float *)&v10 + 1), 0);
  ausdk::AUElement::SetParameter(Element, 0x14u, *((float *)&v10 + 2), 0);
  ausdk::AUElement::SetParameter(Element, 0x15u, *((float *)&v10 + 3), 0);
  ausdk::AUElement::SetParameter(Element, 0x16u, *(float *)&v11, 0);
  ausdk::AUElement::SetParameter(Element, 0x17u, *((float *)&v11 + 1), 0);
  ausdk::AUElement::SetParameter(Element, 0x18u, *((float *)&v11 + 2), 0);
  ausdk::AUElement::SetParameter(Element, 0x19u, *((float *)&v11 + 3), 0);
  ausdk::AUElement::SetParameter(Element, 0x1Au, v12[0], 0);
  ausdk::AUElement::SetParameter(Element, 5u, v12[1], 0);
  ausdk::AUElement::SetParameter(Element, 0x1Eu, *(float *)&v8, 0);
  ausdk::AUElement::SetParameter(Element, 0x1Fu, *((float *)&v8 + 1), 0);
  ausdk::AUElement::SetParameter(Element, 0x20u, *((float *)&v8 + 2), 0);
  ausdk::AUBase::SetAFactoryPresetAsCurrent((char *)this, &sAUEchoGateV3Presets);
  return 0;
}

uint64_t AUEchoGateV3::GetPresets(AUEchoGateV3 *this, const __CFArray **a2)
{
  if (a2)
  {
    Mutable = CFArrayCreateMutable(0, 1, 0);
    CFArrayAppendValue(Mutable, &sAUEchoGateV3Presets);
    *a2 = Mutable;
  }
  return 0;
}

uint64_t AUEchoGateV3::GetParameterInfo(AUEchoGateV3 *this, int a2, unsigned int a3, AudioUnitParameterInfo *buffer)
{
  buffer->flags = 0x40000000;
  buffer->unitName = 0;
  uint64_t result = 4294956418;
  if (!a2 && a3 <= 0x2E)
  {
    CFStringRef v6 = off_1E623BEE0[a3];
    AudioUnitParameterUnit v7 = dword_1BB87CF68[a3];
    AudioUnitParameterValue v8 = flt_1BB87D024[a3];
    AudioUnitParameterValue v9 = flt_1BB87D0E0[a3];
    AudioUnitParameterValue v10 = flt_1BB87D19C[a3];
    int v11 = dword_1BB87D258[a3];
    buffer->cfNameString = v6;
    buffer->flags = 1207959552;
    CFStringGetCString(v6, buffer->name, 52, 0x8000100u);
    uint64_t result = 0;
    buffer->unit = v7;
    buffer->minValue = v8;
    buffer->maxValue = v9;
    buffer->defaultValue = v10;
    buffer->flags |= v11;
  }
  return result;
}

BOOL AUEchoGateV3::BusCountWritable(AUEchoGateV3 *this, int a2)
{
  return (a2 - 1) < 2;
}

uint64_t AUEchoGateV3::Render(AUEchoGateV3 *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  AudioUnitParameterValue v8 = (AUEchoGateV3 *)((char *)this + 80);
  uint64_t Element = ausdk::AUScope::SafeGetElement((AUEchoGateV3 *)((char *)this + 80), 0);
  uint64_t v10 = ausdk::AUScope::SafeGetElement((AUEchoGateV3 *)((char *)this + 128), 0);
  uint64_t v11 = ausdk::AUScope::GetElement(v8, 0);
  if (!v11 || !*(_DWORD *)(v11 + 172)) {
    return 4294956420;
  }
  uint64_t v12 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement(v8, 0);
  uint64_t result = ausdk::AUInputElement::PullInput(v12, a2, a3, 0, a4);
  if (!result)
  {
    BufferList = (AudioBufferList *)ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v10 + 144));
    ausdk::AUBufferList::CopyBufferContentsTo((void *)(Element + 144), BufferList);
    return 0;
  }
  return result;
}

void *ausdk::AUBufferList::CopyBufferContentsTo(void *this, AudioBufferList *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (!*(_DWORD *)this)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      v12[0] = 67109120;
      v12[1] = -1;
      _os_log_error_impl(&dword_1BB0CE000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "throwing %d", (uint8_t *)v12, 8u);
    }
    exception = (ausdk::AUException *)__cxa_allocate_exception(0x18uLL);
    ausdk::AUException::AUException(exception, -1);
  }
  UInt32 mNumberBuffers = a2->mNumberBuffers;
  if (a2->mNumberBuffers)
  {
    UInt32 v4 = 0;
    uint64_t v5 = this[1];
    uint64_t v6 = v5 + 56;
    p_mData = &a2->mBuffers[0].mData;
    do
    {
      if (v4 < *(_DWORD *)(v5 + 48)) {
        uint64_t v8 = 0;
      }
      else {
        uint64_t v8 = -1;
      }
      uint64_t v9 = v6 + 16 * v8;
      this = *p_mData;
      uint64_t v10 = *(void **)(v9 + 8);
      if (*p_mData != v10)
      {
        this = memmove(this, v10, *(unsigned int *)(v9 + 4));
        UInt32 mNumberBuffers = a2->mNumberBuffers;
      }
      *((_DWORD *)p_mData - 1) = *(_DWORD *)(v9 + 4);
      ++v4;
      uint64_t v6 = v9 + 16;
      p_mData += 2;
    }
    while (v4 < mNumberBuffers);
  }
  return this;
}

void sub_1BB342470(_Unwind_Exception *exception_object)
{
}

uint64_t AUEchoGateV3::ProcessMultipleBufferLists(AUEchoGateV3 *this, unsigned int *a2, unsigned int a3, unsigned int a4, const AudioBufferList **a5, unsigned int a6, AudioBufferList **a7)
{
  uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUEchoGateV3 *)((char *)this + 32), 0);
  vDSP_Length v11 = *((unsigned int *)this + 84);
  mData = (const float *)a5[2]->mBuffers[0].mData;
  if (*a7)
  {
    __C = (float *)(*a7)->mBuffers[0].mData;
  }
  else
  {
    __C = 0;
    *((unsigned char *)this + 793) = 0;
    *(unsigned char *)(*((void *)this + 67) + 56) = 0;
  }
  unint64_t v13 = 0;
  uint64_t v14 = 0;
  *(void *)&v54.UInt32 mBitsPerChannel = mData;
  v55 = &mData[v11];
  do
  {
    LOBYTE(v54.mSampleRate) = 0;
    long long v15 = (AudioBufferList *)a5[v13];
    uint64_t v16 = ausdk::AUScope::SafeGetElement((AUEchoGateV3 *)((char *)this + 80), v13);
    AudioDSP::Utility::DetectNonFinites(0, v15, (const AudioBufferList *)(v16 + 80), &v54, v17);
    if (LOBYTE(v54.mSampleRate))
    {
      if (v13 >= 5) {
        std::__throw_out_of_range[abi:ne180100]("bitset set argument out of range");
      }
      v14 |= 1 << v13;
    }
    ++v13;
  }
  while (v13 != 6);
  if ((v14 & 0x1F) != 0)
  {
    uint64_t v18 = _os_log_pack_size();
    uint64_t message = caulk::deferred_logger::create_message(*((caulk::deferred_logger **)this + 101), v18 + 88, 16);
    if (message)
    {
      BOOL v20 = (caulk::concurrent::message *)message;
      uint64_t v21 = _os_log_pack_fill();
      *(_DWORD *)uint64_t v21 = 134217984;
      *(void *)(v21 + 4) = v14;
      caulk::concurrent::messenger::enqueue(*(caulk::concurrent::messenger **)(*((void *)this + 101) + 16), v20);
    }
  }
  if ((*(uint64_t (**)(AUEchoGateV3 *))(*(void *)this + 576))(this))
  {
    if ((v14 & 0x1F) == 0 && !*((unsigned char *)this + 768))
    {
      if (*((unsigned char *)this + 590)) {
        (*(void (**)(void, UInt32 *, float *))(**((void **)this + 67) + 72))(*((void *)this + 67), &v54.mBitsPerChannel, __C);
      }
      ausdk::AUElement::SetParameter(Element, 0xBu, 1.0, 0);
      float Parameter = ausdk::AUElement::GetParameter(Element, 3u);
      int v23 = Element;
      unsigned int v24 = 2;
      goto LABEL_63;
    }
    goto LABEL_19;
  }
  if ((v14 & 0x1F) != 0)
  {
LABEL_19:
    if (__C) {
      vDSP_vclr(__C, 1, (*((_DWORD *)this + 193) << *((unsigned char *)this + 793)));
    }
    ausdk::AUElement::SetParameter(Element, 2u, 0.0, 0);
    ausdk::AUElement::SetParameter(Element, 0xBu, 0.0, 0);
    float Parameter = 0.0;
    int v23 = Element;
    unsigned int v24 = 1;
    goto LABEL_63;
  }
  int v25 = *((_DWORD *)this + 145);
  if (v25 != *((_DWORD *)this + 144))
  {
    AUEchoGateV3::ApplyParameters((uint64_t)this);
    *((_DWORD *)this + 144) = v25;
  }
  float v26 = ausdk::AUElement::GetParameter(Element, 0x11u);
  float v27 = ausdk::AUElement::GetParameter(Element, 0x13u);
  float v28 = a5[4];
  if (v28) {
    float v29 = v28->mBuffers[0].mData;
  }
  else {
    float v29 = 0;
  }
  uint64_t v30 = a5[5];
  if (v30) {
    int v31 = v30->mBuffers[0].mData;
  }
  else {
    int v31 = 0;
  }
  if (a4 < 7)
  {
    long long v33 = 0;
  }
  else
  {
    int v32 = a5[6];
    if (v32) {
      long long v33 = v32->mBuffers[0].mData;
    }
    else {
      long long v33 = 0;
    }
    uint64_t v34 = a5[7];
    if (v34)
    {
      CFTypeRef v35 = v34->mBuffers[0].mData;
      goto LABEL_38;
    }
  }
  CFTypeRef v35 = 0;
LABEL_38:
  int v36 = *((_DWORD *)this + 191);
  v50 = v33;
  uint64_t v48 = v35;
  if ((v36 - 1) >= 2)
  {
    if (v36) {
      goto LABEL_44;
    }
    if (!*((unsigned char *)this + 792))
    {
      vDSP_vclr(*((float **)this + 98), 1, *((unsigned int *)this + 194));
      *((unsigned char *)this + 792) = 1;
    }
  }
  else
  {
    v37 = (*a5)->mBuffers[0].mData;
    if (v37)
    {
      memcpy(*((void **)this + 98), v37, *((unsigned int *)this + 193));
      *(_DWORD *)(*((void *)this + 98) + 4 * *((unsigned int *)this + 193)) = 0;
LABEL_44:
      *((unsigned char *)this + 792) = 0;
    }
  }
  v38 = (const float *)a5[3]->mBuffers[0].mData;
  v39 = (const float *)a5[1]->mBuffers[0].mData;
  if (!*((_DWORD *)this + 149) && !*((_DWORD *)this + 150)) {
    goto LABEL_60;
  }
  vDSP_vmul(mData, 1, *((const float **)this + 86), 1, *((float **)this + 77), 1, v11);
  vDSP_vmul(&mData[v11], 1, *((const float **)this + 86), 1, (float *)(*((void *)this + 77) + 4 * v11), 1, v11);
  uint64_t v40 = *((void *)this + 77);
  unint64_t v41 = (*((void *)this + 78) - v40) >> 2;
  if (*((_DWORD *)this + 149))
  {
    if (v41 > v11)
    {
      *(_DWORD *)(v40 + 4 * v11) = 0;
      goto LABEL_51;
    }
LABEL_65:
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  }
  if (v41 <= v11) {
    goto LABEL_65;
  }
LABEL_51:
  if (*((_DWORD *)this + 181))
  {
    vDSP_vmul(v38, 1, *((const float **)this + 86), 1, *((float **)this + 80), 1, v11);
    vDSP_vmul(&v38[v11], 1, *((const float **)this + 86), 1, (float *)(*((void *)this + 80) + 4 * v11), 1, v11);
    vDSP_vmul(v39, 1, *((const float **)this + 86), 1, *((float **)this + 83), 1, v11);
    vDSP_vmul(&v39[v11], 1, *((const float **)this + 86), 1, (float *)(*((void *)this + 83) + 4 * v11), 1, v11);
    v38 = (const float *)*((void *)this + 80);
    unint64_t v42 = (uint64_t)(*((void *)this + 81) - (void)v38) >> 2;
    if (*((_DWORD *)this + 149))
    {
      if (v42 > v11)
      {
        v38[v11] = 0.0;
        v39 = (const float *)*((void *)this + 83);
        if (v11 < (uint64_t)(*((void *)this + 84) - (void)v39) >> 2)
        {
          float v43 = 0.0;
LABEL_59:
          v39[v11] = v43;
          goto LABEL_60;
        }
        goto LABEL_67;
      }
    }
    else if (v42 > v11)
    {
      v38[v11] = *(const float *)(v40 + 4 * v11);
      v39 = (const float *)*((void *)this + 83);
      if (v11 < (uint64_t)(*((void *)this + 84) - (void)v39) >> 2)
      {
        float v43 = *(float *)(v40 + 4 * v11);
        goto LABEL_59;
      }
LABEL_67:
      std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
    }
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  }
LABEL_60:
  v54.UInt32 mChannelsPerFrame = ausdk::AUElement::GetParameter(Element, 4u);
  (*(void (**)(void, uint64_t, UInt32 *))(**((void **)this + 67) + 32))(*((void *)this + 67), 1, &v54.mChannelsPerFrame);
  v54.UInt32 mBytesPerFrame = ausdk::AUElement::GetParameter(Element, 3u);
  (*(void (**)(void, uint64_t, UInt32 *))(**((void **)this + 67) + 32))(*((void *)this + 67), 6, &v54.mBytesPerFrame);
  v54.UInt32 mBytesPerPacket = ausdk::AUElement::GetParameter(Element, 0);
  (*(void (**)(void, uint64_t, UInt32 *))(**((void **)this + 67) + 32))(*((void *)this + 67), 4, &v54.mBytesPerPacket);
  v54.mFramesPerPacket = ausdk::AUElement::GetParameter(Element, 0xEu);
  (*(void (**)(void, uint64_t, UInt32 *))(**((void **)this + 67) + 32))(*((void *)this + 67), 9, &v54.mFramesPerPacket);
  *(float *)(*((void *)this + 67) + 1536) = ausdk::AUElement::GetParameter(Element, 0x23u);
  *(float *)(*((void *)this + 67) + 1544) = ausdk::AUElement::GetParameter(Element, 0x25u);
  float v44 = ausdk::AUElement::GetParameter(Element, 0x12u);
  v45 = (float *)*((void *)this + 67);
  v45[407] = v44;
  if (*((unsigned char *)this + 590))
  {
    uint64_t v46 = *((unsigned int *)this + 84);
    *(void *)&v54.mSampleRate = v38;
    *(void *)&v54.AudioFormatID mFormatID = &v38[v46];
    v53[0] = v39;
    v53[1] = &v39[v46];
    (*(void (**)(float *, void *, UInt32 *, AudioStreamBasicDescription *, void *, void *, void *, void *, float, float, void, float *))(*(void *)v45 + 24))(v45, v53, &v54.mBitsPerChannel, &v54, v29, v31, v50, v48, v26, v27, *((void *)this + 98), __C);
    v45 = (float *)*((void *)this + 67);
  }
  (*(void (**)(float *, uint64_t, AudioStreamBasicDescription *))(*(void *)v45 + 40))(v45, 5, &v54);
  ausdk::AUElement::SetParameter(Element, 1u, *(float *)&v54.mSampleRate, 0);
  (*(void (**)(void, uint64_t, UInt32 *))(**((void **)this + 67) + 40))(*((void *)this + 67), 6, &v54.mBytesPerFrame);
  ausdk::AUElement::SetParameter(Element, 2u, *(float *)&v54.mBytesPerFrame, 0);
  LODWORD(v53[0]) = 1065353216;
  (*(void (**)(void, uint64_t, void *))(**((void **)this + 67) + 40))(*((void *)this + 67), 7, v53);
  ausdk::AUElement::SetParameter(Element, 0xBu, *(float *)v53, 0);
  float v52 = 0.0;
  (*(void (**)(void, uint64_t, float *))(**((void **)this + 67) + 40))(*((void *)this + 67), 18, &v52);
  float Parameter = v52;
  int v23 = Element;
  unsigned int v24 = 42;
LABEL_63:
  ausdk::AUElement::SetParameter(v23, v24, Parameter, 0);
  return 0;
}

uint64_t AUEchoGateV3::ApplyParameters(uint64_t this)
{
  if (*(void *)(this + 536))
  {
    uint64_t v1 = this;
    uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::GetElement((ausdk::AUScope *)(this + 32), 0);
    v9[10] = 0;
    v9[0] = ausdk::AUElement::GetParameter(Element, 6u);
    v9[7] = ausdk::AUElement::GetParameter(Element, 7u);
    v9[8] = ausdk::AUElement::GetParameter(Element, 8u);
    v9[1] = ausdk::AUElement::GetParameter(Element, 9u);
    v9[2] = ausdk::AUElement::GetParameter(Element, 0xAu);
    v9[3] = ausdk::AUElement::GetParameter(Element, 0xCu);
    v9[4] = ausdk::AUElement::GetParameter(Element, 0x1Eu);
    v9[5] = ausdk::AUElement::GetParameter(Element, 0x1Fu);
    v9[6] = ausdk::AUElement::GetParameter(Element, 0x20u);
    v9[9] = ausdk::AUElement::GetParameter(Element, 0xDu);
    v9[11] = ausdk::AUElement::GetParameter(Element, 0xFu);
    v9[12] = ausdk::AUElement::GetParameter(Element, 0x10u);
    v9[13] = ausdk::AUElement::GetParameter(Element, 0x12u);
    v9[14] = ausdk::AUElement::GetParameter(Element, 0x14u);
    v9[15] = ausdk::AUElement::GetParameter(Element, 0x15u);
    v9[16] = ausdk::AUElement::GetParameter(Element, 0x16u);
    v9[17] = ausdk::AUElement::GetParameter(Element, 0x17u);
    v9[18] = ausdk::AUElement::GetParameter(Element, 0x18u);
    v9[19] = ausdk::AUElement::GetParameter(Element, 0x19u);
    v9[20] = ausdk::AUElement::GetParameter(Element, 0x1Au);
    v9[21] = ausdk::AUElement::GetParameter(Element, 5u);
    (*(void (**)(void, uint64_t, _DWORD *))(**(void **)(v1 + 536) + 32))(*(void *)(v1 + 536), 8, v9);
    *(unsigned char *)(*(void *)(v1 + 536) + 1492) = ausdk::AUElement::GetParameter(Element, 0x1Cu) != 0.0;
    *(float *)(*(void *)(v1 + 536) + 1480) = ausdk::AUElement::GetParameter(Element, 0x21u);
    *(float *)(*(void *)(v1 + 536) + 1484) = ausdk::AUElement::GetParameter(Element, 0x22u);
    *(float *)(*(void *)(v1 + 536) + 1488) = ausdk::AUElement::GetParameter(Element, 0x1Bu);
    *(_DWORD *)(*(void *)(v1 + 536) + 1532) = ausdk::AUElement::GetParameter(Element, 0x24u);
    float Parameter = ausdk::AUElement::GetParameter(Element, 0x26u);
    *(float *)(*(void *)(v1 + 536) + 1540) = __exp10f(Parameter * 0.05);
    float v4 = ausdk::AUElement::GetParameter(Element, 0x27u);
    *(float *)(*(void *)(v1 + 536) + 1548) = __exp10f(v4 * -0.05);
    *(float *)(*(void *)(v1 + 536) + 1560) = ausdk::AUElement::GetParameter(Element, 0x2Bu);
    *(float *)(*(void *)(v1 + 536) + 1564) = ausdk::AUElement::GetParameter(Element, 0x2Cu);
    *(float *)(*(void *)(v1 + 536) + 1568) = ausdk::AUElement::GetParameter(Element, 0x2Du);
    *(float *)(*(void *)(v1 + 536) + 1572) = ausdk::AUElement::GetParameter(Element, 0x2Eu);
    float v5 = ausdk::AUElement::GetParameter(Element, 0x28u);
    uint64_t v6 = *(float **)(v1 + 536);
    v6[388] = v5;
    (*(void (**)(float *, uint64_t, float *))(*(void *)v6 + 32))(v6, 16, v6 + 388);
    float v7 = ausdk::AUElement::GetParameter(Element, 0x29u);
    uint64_t v8 = *(float **)(v1 + 536);
    v8[389] = v7;
    return (*(uint64_t (**)(float *, uint64_t, float *))(*(void *)v8 + 32))(v8, 17, v8 + 389);
  }
  return this;
}

uint64_t AUEchoGateV3::CanScheduleParameters(AUEchoGateV3 *this)
{
  return 0;
}

uint64_t AUEchoGateV3::SetParameter(AUEchoGateV3 *this, unsigned int a2, unsigned int a3, unsigned int a4, float a5)
{
  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
  uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
  ausdk::AUElement::SetParameter(Element, a2, a5, 0);
  if (a2 > 0x2A || ((1 << a2) & 0x428000E4819) == 0) {
    ++*((_DWORD *)this + 145);
  }
  return 0;
}

uint64_t AUEchoGateV3::SetProperty(AUEchoGateV3 *this, int a2, int a3, unsigned int a4, _DWORD *__src, size_t __n)
{
  if (a3) {
    return 4294956417;
  }
  uint64_t result = 4294956417;
  if (a2 > 2199)
  {
    if (a2 > 2299)
    {
      if (a2 == 2300)
      {
        if (__n == 4)
        {
          uint64_t result = 0;
          *((unsigned char *)this + 768) = *__src != 0;
          return result;
        }
      }
      else
      {
        if (a2 != 2400) {
          return result;
        }
        if (__n == 4)
        {
          uint64_t result = 0;
          *((unsigned char *)this + 769) = *__src != 0;
          return result;
        }
      }
    }
    else if (a2 == 2200)
    {
      if (__n == 4)
      {
        uint64_t result = 0;
        *((_DWORD *)this + 191) = *__src;
        return result;
      }
    }
    else
    {
      if (a2 != 2210) {
        return result;
      }
      if (__n == 4 * (*((_DWORD *)this + 84) + 1))
      {
        if ((*((_DWORD *)this + 191) - 3) <= 1)
        {
          uint64_t result = *((void *)this + 98);
          if (!result) {
            return result;
          }
          memcpy((void *)result, __src, __n);
        }
        return 0;
      }
    }
    return 4294956445;
  }
  switch(a2)
  {
    case 2117:
      if (__n != 24) {
        return 4294956445;
      }
      int v8 = *((unsigned __int8 *)this + 568);
      uint64_t v9 = *((void *)__src + 2);
      *((_OWORD *)this + 34) = *(_OWORD *)__src;
      *((void *)this + 70) = v9;
      if (v8) {
        return 0;
      }
      uint64_t result = 0;
      *((unsigned char *)this + 568) = 1;
      return result;
    case 2118:
      uint64_t v12 = *((void *)this + 67);
      unsigned int v13 = *(_DWORD *)(v12 + 1472);
      if (v13 >= __n) {
        size_t v14 = __n;
      }
      else {
        size_t v14 = v13;
      }
      memcpy(*(void **)(v12 + 1448), __src, v14);
      uint64_t result = 0;
      *(_DWORD *)(*((void *)this + 67) + 1476) = v14 >> 2;
      return result;
    case 2119:
      if (*((unsigned char *)this + 17)) {
        goto LABEL_58;
      }
      if (__n < 4) {
        return 4294956445;
      }
      uint64_t result = 0;
      *((_DWORD *)this + 149) = *__src;
      return result;
    case 2120:
      if (*((unsigned char *)this + 17)) {
        goto LABEL_58;
      }
      if (__n < 4) {
        return 4294956445;
      }
      uint64_t result = 0;
      *((_DWORD *)this + 150) = *__src;
      return result;
    case 2121:
      if (*((unsigned char *)this + 17)) {
        goto LABEL_58;
      }
      if (__n < 4) {
        return 4294956445;
      }
      uint64_t result = 0;
      *((_DWORD *)this + 181) = *__src;
      return result;
    case 2122:
      if (*((unsigned char *)this + 17)) {
        goto LABEL_58;
      }
      if (__n < 4) {
        return 4294956445;
      }
      uint64_t result = 0;
      *((_DWORD *)this + 183) = *__src;
      return result;
    case 2123:
      if (__n < 4) {
        return 4294956445;
      }
      int v15 = *__src;
      *((_DWORD *)this + 182) = *__src;
      uint64_t v16 = *((void *)this + 67);
      if (!v16) {
        return 0;
      }
      uint64_t result = 0;
      *(_DWORD *)(v16 + 1496) = v15;
      return result;
    case 2124:
      return result;
    case 2125:
      if (__n != 8) {
        return 4294956445;
      }
      applesauce::CF::StringRef::from_get((applesauce::CF::StringRef *)&v21, *(CFTypeRef *)__src);
      float v17 = (const __CFString **)applesauce::CF::StringRef::operator->(&v21);
      applesauce::CF::convert_to<std::string,0>(*v17, (uint64_t)&v19);
      uint64_t v18 = (void **)((char *)this + 736);
      if (*((char *)this + 759) < 0) {
        operator delete(*v18);
      }
      *(_OWORD *)uint64_t v18 = v19;
      *((void *)this + 94) = v20;
      applesauce::CF::StringRef::~StringRef(&v21);
      return 0;
    case 2126:
      if (*((unsigned char *)this + 17)) {
        goto LABEL_58;
      }
      if (__n < 4) {
        return 4294956445;
      }
      uint64_t result = 0;
      *((_DWORD *)this + 178) = *__src;
      return result;
    case 2127:
      if (*((unsigned char *)this + 17)) {
        goto LABEL_58;
      }
      if (__n < 4) {
        return 4294956445;
      }
      uint64_t result = 0;
      *((_DWORD *)this + 179) = *__src;
      return result;
    case 2128:
      if (*((unsigned char *)this + 17)) {
        goto LABEL_58;
      }
      if (__n < 4) {
        return 4294956445;
      }
      uint64_t result = 0;
      *((_DWORD *)this + 180) = *__src;
      return result;
    case 2129:
      if (*((unsigned char *)this + 17))
      {
LABEL_58:
        uint64_t result = 4294956447;
      }
      else
      {
        if (__n < 4) {
          return 4294956445;
        }
        uint64_t result = 0;
        *((_DWORD *)this + 190) = *__src;
      }
      break;
    default:
      if (a2 != 21) {
        return result;
      }
      if (__n < 4) {
        return 4294956445;
      }
      int v10 = *__src;
      int v11 = *__src != 0;
      if (v11 != (*(unsigned int (**)(AUEchoGateV3 *))(*(void *)this + 576))(this)) {
        (*(void (**)(AUEchoGateV3 *, BOOL))(*(void *)this + 584))(this, v10 != 0);
      }
      return 0;
  }
  return result;
}

void sub_1BB343420(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  applesauce::CF::StringRef::~StringRef((const void **)va);
  _Unwind_Resume(a1);
}

applesauce::CF::StringRef *applesauce::CF::StringRef::from_get(applesauce::CF::StringRef *this, CFTypeRef cf)
{
  float v2 = this;
  if (cf)
  {
    CFRetain(cf);
    return applesauce::CF::StringRef::StringRef(v2, cf);
  }
  else
  {
    *(void *)this = 0;
  }
  return this;
}

uint64_t AUEchoGateV3::GetProperty(const void **this, int a2, int a3, unsigned int a4, _DWORD *__dst)
{
  if (a3) {
    return 4294956417;
  }
  uint64_t result = 4294956417;
  if (a2 > 2199)
  {
    if (a2 > 2299)
    {
      if (a2 == 2300)
      {
        uint64_t result = 0;
        int v8 = *((unsigned __int8 *)this + 768);
      }
      else
      {
        if (a2 != 3700) {
          return result;
        }
        uint64_t result = 0;
        int v8 = *((unsigned __int8 *)this + 376);
      }
    }
    else
    {
      if (a2 != 2200)
      {
        if (a2 == 2210)
        {
          memcpy(__dst, this[98], 4 * (*((_DWORD *)this + 84) + 1));
          return 0;
        }
        return result;
      }
      uint64_t result = 0;
      int v8 = *((_DWORD *)this + 191);
    }
LABEL_22:
    *__dst = v8;
    return result;
  }
  switch(a2)
  {
    case 21:
      int v8 = (*((uint64_t (**)(const void **))*this + 72))(this);
      uint64_t result = 0;
      goto LABEL_22;
    case 2117:
      uint64_t result = 0;
      if (*((unsigned char *)this + 568))
      {
        long long v9 = *((_OWORD *)this + 34);
        *((void *)__dst + 2) = this[70];
        *(_OWORD *)__dst = v9;
      }
      else
      {
        *(void *)__dst = 0;
        *((void *)__dst + 1) = 0;
        *((void *)__dst + 2) = 0;
      }
      break;
    case 2124:
      uint64_t result = (uint64_t)this[67];
      if (result)
      {
        (*(void (**)(uint64_t, uint64_t, _DWORD *))(*(void *)result + 40))(result, 7, __dst);
        return 0;
      }
      break;
  }
  return result;
}

uint64_t AUEchoGateV3::GetPropertyInfo(AUEchoGateV3 *this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  if (a3) {
    return 4294956417;
  }
  uint64_t result = 4294956417;
  if (a2 > 2199)
  {
    if (a2 <= 2299)
    {
      if (a2 != 2200)
      {
        if (a2 != 2210) {
          return result;
        }
        *a6 = 1;
        int v9 = 4 * *((_DWORD *)this + 194);
        goto LABEL_18;
      }
    }
    else if (a2 != 2300 && a2 != 2400)
    {
      if (a2 != 3700) {
        return result;
      }
LABEL_10:
      *a6 = 0;
      goto LABEL_17;
    }
LABEL_15:
    char v8 = 1;
LABEL_16:
    *a6 = v8;
LABEL_17:
    int v9 = 4;
LABEL_18:
    uint64_t result = 0;
    *a5 = v9;
    return result;
  }
  switch(a2)
  {
    case 2117:
      *a6 = 1;
      int v9 = 24;
      goto LABEL_18;
    case 2118:
      *a6 = 1;
      int v9 = *(_DWORD *)(*((void *)this + 67) + 1472);
      goto LABEL_18;
    case 2119:
    case 2120:
    case 2121:
    case 2122:
    case 2126:
    case 2127:
    case 2128:
      char v8 = *((unsigned char *)this + 17) ^ 1;
      goto LABEL_16;
    case 2123:
    case 2129:
      goto LABEL_15;
    case 2124:
      goto LABEL_10;
    case 2125:
      *a6 = *((unsigned char *)this + 17) ^ 1;
      int v9 = 9;
      goto LABEL_18;
    default:
      if (a2 == 21) {
        goto LABEL_15;
      }
      break;
  }
  return result;
}

uint64_t AUEchoGateV3::Reset(AUEchoGateV3 *this)
{
  float v2 = (float *)*((void *)this + 98);
  if (v2) {
    vDSP_vclr(v2, 1, *((unsigned int *)this + 194));
  }
  return 0;
}

uint64_t AUEchoGateV3::Cleanup(AUEchoGateV3 *this)
{
  float v2 = (void *)*((void *)this + 98);
  if (v2)
  {
    free(v2);
    *((void *)this + 98) = 0;
  }
  uint64_t result = *((void *)this + 67);
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  *((void *)this + 67) = 0;
  return result;
}

uint64_t AUEchoGateV3::Initialize(AUEchoGateV3 *this)
{
  uint64_t v80 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 21);
  if (v2) {
    LODWORD(v3) = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  else {
    uint64_t v3 = (*((void *)this + 19) - *((void *)this + 18)) >> 3;
  }
  uint64_t v4 = *((void *)this + 15);
  if (v4) {
    LODWORD(v5) = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  else {
    uint64_t v5 = (*((void *)this + 13) - *((void *)this + 12)) >> 3;
  }
  char v6 = 0;
  float v7 = (int32x2_t *)((char *)this + 596);
  unsigned int v8 = 2;
  do
  {
    char v9 = v6;
    double v10 = *(double *)(ausdk::AUScope::SafeGetElement((AUEchoGateV3 *)((char *)this + 80), v8 - 1) + 80);
    if (v10 != *(double *)(ausdk::AUScope::SafeGetElement((AUEchoGateV3 *)((char *)this + 80), v8) + 80)) {
      return 4294956428;
    }
    unsigned int v8 = 3;
    char v6 = 1;
  }
  while ((v9 & 1) == 0);
  if (v5 >= 6)
  {
    unsigned int v11 = 5;
    do
    {
      int v12 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUEchoGateV3 *)((char *)this + 80), v11 - 1) + 88);
      if (v12 != *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUEchoGateV3 *)((char *)this + 80), v11) + 88)) {
        return 4294956428;
      }
    }
    while (v5 != ++v11);
  }
  if (v3 >= 2)
  {
    unsigned int v13 = 1;
    do
    {
      double v14 = *(double *)(ausdk::AUScope::SafeGetElement((AUEchoGateV3 *)((char *)this + 128), v13 - 1) + 80);
      if (v14 != *(double *)(ausdk::AUScope::SafeGetElement((AUEchoGateV3 *)((char *)this + 128), v13) + 80)) {
        return 4294956428;
      }
    }
    while (v3 != ++v13);
  }
  *((unsigned char *)this + 793) = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUEchoGateV3 *)((char *)this + 128), 0) + 88) == 1718773105;
  double v15 = *(double *)(ausdk::AUScope::SafeGetElement((AUEchoGateV3 *)((char *)this + 80), 0) + 80);
  if (v15 != *(double *)(ausdk::AUScope::SafeGetElement((AUEchoGateV3 *)((char *)this + 128), 0) + 80)) {
    return 4294956428;
  }
  uint64_t Element = ausdk::AUScope::SafeGetElement((AUEchoGateV3 *)((char *)this + 128), 0);
  long long v18 = *(_OWORD *)(Element + 96);
  long long v63 = *(_OWORD *)(Element + 80);
  long long v64 = v18;
  uint64_t v65 = *(void *)(Element + 112);
  double v19 = *(double *)(ausdk::AUScope::SafeGetElement((AUEchoGateV3 *)((char *)this + 80), 0) + 80);
  *((double *)this + 100) = v19;
  unsigned int v20 = *((_DWORD *)this + 149);
  if (v19 * 0.5 < (double)v20) {
    return 4294956445;
  }
  unsigned int v21 = *((_DWORD *)this + 150);
  uint64_t result = 4294956445;
  if (v20 - 1 >= v21 && v19 * 0.5 >= (double)v21)
  {
    unint64_t v22 = *((unsigned int *)this + 84);
    int32x2_t v23 = vdup_n_s32(v22);
    float32x2_t v24 = vcvt_f32_u32((uint32x2_t)vmul_s32(v23, (int32x2_t)__PAIR64__(v21, v20)));
    uint32x2_t v25 = vcvt_u32_f32(vrndp_f32(vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(vadd_f32(v24, v24)), (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v19, 0)))));
    uint32x2_t v26 = vmin_u32((uint32x2_t)v23, v25);
    if (v26.i32[1]) {
      BOOL v27 = v22 > v25.i32[1];
    }
    else {
      BOOL v27 = 0;
    }
    int v28 = v27;
    *(uint32x2_t *)((char *)this + 604) = v26;
    if ((v22 <= v25.i32[0] || v26.i32[0] == 0) && v28 == 0) {
      goto LABEL_65;
    }
    *(_DWORD *)buf = 0;
    std::vector<float>::assign((char **)this + 77, (2 * v22), buf);
    *(_DWORD *)buf = 0;
    std::vector<float>::assign((char **)this + 80, (2 * v22), buf);
    *(_DWORD *)buf = 0;
    std::vector<float>::assign((char **)this + 83, (2 * v22), buf);
    *(_DWORD *)buf = 1065353216;
    std::vector<float>::assign((char **)this + 86, v22, buf);
    if (!*(void *)v7) {
      goto LABEL_65;
    }
    float32x2_t v31 = vcvt_f32_u32((uint32x2_t)vmul_s32(*v7, v23));
    uint64_t v60 = *((uint64_t *)this + 100);
    *(uint32x2_t *)((char *)this + 604) = vmin_u32((uint32x2_t)v23, vcvt_u32_f32(vrndp_f32(vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(vadd_f32(v31, v31)), (float64x2_t)vdupq_lane_s64(v60, 0))))));
    float v61 = 1.0;
    float __A = 1.0;
    float v32 = *((float *)this + 180);
    float v33 = *((float *)this + 178);
    vDSP_vfill(&__A, *((float **)this + 86), 1, v22);
    if ((float)*((unsigned int *)this + 149) >= (float)*((unsigned int *)this + 150)) {
      float v34 = (float)*((unsigned int *)this + 149);
    }
    else {
      float v34 = (float)*((unsigned int *)this + 150);
    }
    if (*((_DWORD *)this + 151) <= *((_DWORD *)this + 152)) {
      signed int v35 = *((_DWORD *)this + 152);
    }
    else {
      signed int v35 = *((_DWORD *)this + 151);
    }
    int v36 = (NSObject **)egt3Subsystem();
    if (v36)
    {
      v37 = *v36;
      if (!*v36)
      {
LABEL_53:
        float v42 = __exp10f(*((float *)this + 179) * -0.05);
        if (v33 >= v32)
        {
          float v44 = v42;
          float v45 = *(double *)&v60;
          float v46 = v45 / (float)((float)v22 + (float)v22);
          do
          {
            float v47 = (float)(v32 + v34) / v46;
            unsigned int v43 = vcvtms_u32_f32(v47);
            float v61 = v44 * v61;
            vDSP_vfill(&v61, (float *)(*((void *)this + 86) + 4 * v35), 1, v43 - v35);
            float v34 = floorf(v46 * (float)floorf(v47));
            float v33 = v33 - v32;
            signed int v35 = v43;
          }
          while (v33 >= v32);
        }
        else
        {
          unsigned int v43 = v35;
        }
        vDSP_vfill(&v61, (float *)(*((void *)this + 86) + 4 * v43), 1, v22 - v43);
        if (*((_DWORD *)this + 150) && v22)
        {
          uint64_t v48 = (float *)*((void *)this + 86);
          uint64_t v49 = (uint64_t)(*((void *)this + 87) - (void)v48) >> 2;
          do
          {
            if (!v49) {
              std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
            }
            float v50 = *v48;
            float v51 = v61;
            if (*v48 != 1.0)
            {
              float v51 = 1.0;
              if (v50 != v61) {
                float v51 = 1.0 - v50;
              }
            }
            *v48++ = v51;
            --v49;
            --v22;
          }
          while (v22);
        }
LABEL_65:
        int v52 = *((_DWORD *)this + 84);
        *((_DWORD *)this + 193) = v52;
        int v53 = v52 + 1;
        *((_DWORD *)this + 194) = v52 + 1;
        size_t v54 = 4 * (v52 + 1);
        v55 = malloc_type_malloc(v54, 0x2C8E6D5CuLL);
        v56 = v55;
        if (!v53 || v55)
        {
          bzero(v55, v54);
          *((void *)this + 98) = v56;
          uint64_t v57 = *((void *)this + 67);
          if (v57)
          {
            (*(void (**)(uint64_t))(*(void *)v57 + 8))(v57);
            *((void *)this + 67) = 0;
          }
          operator new();
        }
        exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
        v59 = std::bad_alloc::bad_alloc(exception);
      }
    }
    else
    {
      v37 = MEMORY[0x1E4F14500];
    }
    if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
    {
      v38 = (void *)((char *)this + 736);
      if (*((char *)this + 759) < 0) {
        v38 = (void *)*v38;
      }
      double v39 = *((float *)this + 178);
      double v40 = *((float *)this + 179);
      double v41 = *((float *)this + 180);
      *(_DWORD *)buf = 136316674;
      v67 = "AUEchoGateV3.cpp";
      __int16 v68 = 1024;
      int v69 = 402;
      __int16 v70 = 2080;
      v71 = v38;
      __int16 v72 = 2048;
      double v73 = v34;
      __int16 v74 = 2048;
      double v75 = v39;
      __int16 v76 = 2048;
      double v77 = v40;
      __int16 v78 = 2048;
      double v79 = v41;
      _os_log_impl(&dword_1BB0CE000, v37, OS_LOG_TYPE_INFO, "%25s:%-5d AUEchoGateV3: Gate [%s], Cutoff = %f, Transition band = %f @ %fdB/%fHz", buf, 0x44u);
    }
    goto LABEL_53;
  }
  return result;
}

void sub_1BB344180(_Unwind_Exception *a1)
{
  uint64_t v5 = *v3;
  if (*v3)
  {
    v1[182] = v5;
    operator delete(v5);
  }
  char v6 = (void *)v1[162];
  if (v6)
  {
    v1[163] = v6;
    operator delete(v6);
  }
  float v7 = (void *)v1[159];
  if (v7)
  {
    v1[160] = v7;
    operator delete(v7);
  }
  unsigned int v8 = (void *)v1[156];
  if (v8)
  {
    v1[157] = v8;
    operator delete(v8);
  }
  char v9 = *v2;
  if (*v2)
  {
    v1[154] = v9;
    operator delete(v9);
  }
  double v10 = (std::__shared_weak_count *)v1[32];
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  void *v1 = &unk_1F14B2540;
  MEMORY[0x1C185D370](v1, 0x10B3C40485114A4);
  _Unwind_Resume(a1);
}

uint64_t egt3Subsystem(void)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&egt3Subsystem(void)::onceflag, memory_order_acquire) != -1)
  {
    uint64_t v3 = &v1;
    uint64_t v2 = &v3;
    std::__call_once(&egt3Subsystem(void)::onceflag, &v2, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<egt3Subsystem(void)::$_0 &&>>);
  }
  return egt3Subsystem(void)::scope;
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<egt3Subsystem(void)::$_0 &&>>()
{
}

void AUEchoGateV3::~AUEchoGateV3(void **this)
{
  AUEchoGateV3::~AUEchoGateV3(this);

  JUMPOUT(0x1C185D370);
}

{
  std::__shared_weak_count *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  uint64_t vars8;

  *this = &unk_1F14AA3A0;
  AUEchoGateV3::Cleanup((AUEchoGateV3 *)this);
  uint64_t v2 = (std::__shared_weak_count *)this[102];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  if (*((char *)this + 759) < 0) {
    operator delete(this[92]);
  }
  uint64_t v3 = this[86];
  if (v3)
  {
    this[87] = v3;
    operator delete(v3);
  }
  uint64_t v4 = this[83];
  if (v4)
  {
    this[84] = v4;
    operator delete(v4);
  }
  uint64_t v5 = this[80];
  if (v5)
  {
    this[81] = v5;
    operator delete(v5);
  }
  char v6 = this[77];
  if (v6)
  {
    this[78] = v6;
    operator delete(v6);
  }

  ausdk::AUBase::~AUBase((ausdk::AUBase *)this);
}

uint64_t VoiceProcessorV3::RunUplinkEchoDSP(void **this, AudioTimeStamp *a2)
{
  uint64_t v3 = (VoiceProcessorV3 *)this;
  uint64_t v150 = *MEMORY[0x1E4F143B8];
  size_t v4 = *(unsigned int *)this[135];
  if (v4) {
    bzero(this[176], v4);
  }
  if (*((unsigned char *)v3 + 1404)) {
    VoiceProcessorV2::PostSRCMicClipDetection(v3);
  }
  if (!*((unsigned char *)v3 + 2083)) {
    VoiceProcessorV2::GetAbsoluteChIndexForEpmicAndApplyPreDigitalGain(v3);
  }
  int v5 = *((unsigned __int8 *)v3 + 15961);
  if (*((unsigned char *)v3 + 15961)
    && (VoiceProcessorV2::InjectionFilesReadSignal(v3, 7, *((_DWORD *)v3 + 127), *((AudioBufferList **)v3 + 134)),
        int v5 = *((unsigned __int8 *)v3 + 15961),
        *((unsigned char *)v3 + 15961))
    && (VoiceProcessorV2::InjectionFilesReadSignal(v3, 8, *((_DWORD *)v3 + 127), *((AudioBufferList **)v3 + 135)),
        int v5 = *((unsigned __int8 *)v3 + 15961),
        *((unsigned char *)v3 + 15961))
    && *((unsigned char *)v3 + 15960)
    || *((unsigned char *)v3 + 15963))
  {
    bzero(*(void **)(*((void *)v3 + 134) + 16), *(unsigned int *)(*((void *)v3 + 134) + 12));
    int v5 = *((unsigned __int8 *)v3 + 15961);
  }
  uint64_t v6 = *((unsigned int *)v3 + 127);
  if (v5 || *((unsigned char *)v3 + 15962))
  {
    this = (void **)VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 4u, v6, *((const AudioBufferList **)v3 + 134), a2);
    uint64_t v6 = *((unsigned int *)v3 + 127);
    float v7 = (const AudioBufferList *)*((void *)v3 + 135);
    if (*((unsigned char *)v3 + 15961)) {
      goto LABEL_19;
    }
  }
  else
  {
    float v7 = (const AudioBufferList *)*((void *)v3 + 135);
  }
  if (!*((unsigned char *)v3 + 15962))
  {
    unsigned int v8 = (const AudioBufferList *)*((void *)v3 + 177);
    goto LABEL_22;
  }
LABEL_19:
  this = (void **)VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 5u, v6, v7, a2);
  uint64_t v6 = *((unsigned int *)v3 + 127);
  unsigned int v8 = (const AudioBufferList *)*((void *)v3 + 177);
  if (*((unsigned char *)v3 + 15961))
  {
LABEL_23:
    this = (void **)VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x4Au, v6, v8, a2);
    goto LABEL_24;
  }
LABEL_22:
  if (*((unsigned char *)v3 + 15962)) {
    goto LABEL_23;
  }
LABEL_24:
  AudioUnitParameterValue outValue = 0.0;
  if (!*((unsigned char *)v3 + 2083)
    && !*((unsigned char *)v3 + 2085)
    && !*((unsigned char *)v3 + 472)
    && (*((void *)v3 + 583) || *((unsigned char *)v3 + 4672)))
  {
    AudioUnitRenderActionFlags v140 = 0;
    ioOutputBufferLists = (AudioBufferList *)1;
    long long v149 = 0uLL;
    long long v149 = *(_OWORD *)(*((void *)v3 + 134) + 8);
    MEMORY[0x1F4188790](this);
    int32x2_t v23 = (AudioBufferList *)((char *)&v133 - ((v22 + 15) & 0x3FFFFFFFF0));
    float32x2_t v24 = (_DWORD *)*((void *)v3 + 135);
    if (*v24)
    {
      unint64_t v25 = 0;
      uint64_t v26 = 2;
      BOOL v27 = v23;
      do
      {
        *(void *)&v27->UInt32 mNumberBuffers = 0;
        *(void *)&v27->mBuffers[0].mNumberChannels = 0;
        v27->mBuffers[0].mData = 0;
        v27->UInt32 mNumberBuffers = v21;
        v27->mBuffers[0] = *(AudioBuffer *)&v24[v26];
        ++v25;
        v26 += 4;
        ++v27;
      }
      while (v25 < *v24);
    }
    uint64_t v28 = *((void *)v3 + 583);
    if ((v28 & 2) != 0 && (*((unsigned char *)v3 + 4680) & 2) != 0)
    {
      uint64_t v20 = *((void *)v3 + 348);
      if (v20)
      {
        AudioUnitRenderActionFlags v140 = 512;
        AudioUnitProcess((AudioUnit)v20, &v140, a2, *((_DWORD *)v3 + 127), v23);
        if (*((unsigned char *)v3 + 15961) || *((unsigned char *)v3 + 15962)) {
          VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x4Bu, *((unsigned int *)v3 + 127), v23, a2);
        }
        uint64_t v20 = (uint64_t)CADeprecated::CABufferList::CopyDataFrom(*((void **)v3 + 138), v23);
        uint64_t v28 = *((void *)v3 + 583);
      }
    }
    if ((v28 & 4) != 0 && (*((unsigned char *)v3 + 4680) & 4) != 0)
    {
      uint64_t v20 = *((void *)v3 + 349);
      if (v20)
      {
        AudioUnitRenderActionFlags v140 = 512;
        AudioUnitProcess((AudioUnit)v20, &v140, a2, *((_DWORD *)v3 + 127), v23 + 1);
        if (*((unsigned char *)v3 + 15961) || *((unsigned char *)v3 + 15962)) {
          VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x4Cu, *((unsigned int *)v3 + 127), v23 + 1, a2);
        }
        uint64_t v20 = (uint64_t)CADeprecated::CABufferList::CopyDataFrom(*((void **)v3 + 139), v23 + 1);
        uint64_t v28 = *((void *)v3 + 583);
      }
    }
    if ((v28 & 8) != 0 && (*((unsigned char *)v3 + 4680) & 8) != 0)
    {
      uint64_t v20 = *((void *)v3 + 350);
      if (v20)
      {
        AudioUnitRenderActionFlags v140 = 512;
        float v29 = v23 + 2;
        AudioUnitProcess((AudioUnit)v20, &v140, a2, *((_DWORD *)v3 + 127), v29);
        if (*((unsigned char *)v3 + 15961) || *((unsigned char *)v3 + 15962)) {
          VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x4Du, *((unsigned int *)v3 + 127), v29, a2);
        }
        uint64_t v20 = (uint64_t)CADeprecated::CABufferList::CopyDataFrom(*((void **)v3 + 140), v29);
      }
    }
    *(void *)&ioActionFlags.mBuffers[0].mNumberChannels = 0;
    ioActionFlags.mBuffers[0].mData = 0;
    ioData.mBuffers[0].mData = 0;
    *(void *)&ioActionFlags.UInt32 mNumberBuffers = 1;
    *(void *)&ioData.UInt32 mNumberBuffers = 1;
    *(void *)&ioData.mBuffers[0].mNumberChannels = 0;
    uint64_t v30 = *((void *)v3 + 135);
    if (*(_DWORD *)v30 < 3u)
    {
      ioActionFlags.mBuffers[0] = *(AudioBuffer *)(v30 + 8);
      if (*(_DWORD *)v30 < 2u)
      {
        uint64_t v32 = 0;
        uint64_t v31 = 0;
      }
      else
      {
        uint64_t v31 = 0;
        ioData.mBuffers[0] = *(AudioBuffer *)(v30 + 24);
        uint64_t v32 = 1;
      }
    }
    else
    {
      ioActionFlags.mBuffers[0] = *(AudioBuffer *)(v30 + 24);
      ioData.mBuffers[0] = *(AudioBuffer *)(v30 + 40);
      uint64_t v31 = 1;
      uint64_t v32 = 2;
    }
    uint64_t v33 = *((void *)v3 + 583);
    if ((v33 & 0x20) != 0 && (*((unsigned char *)v3 + 4680) & 0x20) != 0)
    {
      uint64_t v20 = *((void *)v3 + 352);
      if (v20)
      {
        AudioUnitRenderActionFlags v140 = 512;
        *(void *)buf = &ioActionFlags;
        p_AudioBufferList ioActionFlags = &ioActionFlags;
        uint64_t v20 = AudioUnitProcessMultiple((AudioUnit)v20, &v140, a2, *((_DWORD *)v3 + 127), 1u, (const AudioBufferList **)buf, 1u, &p_ioActionFlags);
        if (*((unsigned char *)v3 + 15961) || *((unsigned char *)v3 + 15962)) {
          uint64_t v20 = VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x72u, *((unsigned int *)v3 + 127), &ioActionFlags, a2);
        }
        uint64_t v33 = *((void *)v3 + 583);
      }
    }
    if ((v33 & 0x80) != 0 && (*((unsigned char *)v3 + 4680) & 0x80) != 0)
    {
      uint64_t v20 = *((void *)v3 + 354);
      if (v20)
      {
        AudioUnitRenderActionFlags v140 = 512;
        uint64_t v20 = AudioUnitProcess((AudioUnit)v20, &v140, a2, *((_DWORD *)v3 + 127), &ioActionFlags);
        if (*((unsigned char *)v3 + 15961) || *((unsigned char *)v3 + 15962)) {
          uint64_t v20 = VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 6u, *((unsigned int *)v3 + 127), &ioActionFlags, a2);
        }
      }
    }
    if (*((unsigned char *)v3 + 4665) & 1) != 0 && (*((unsigned char *)v3 + 4681))
    {
      uint64_t v20 = *((void *)v3 + 355);
      if (v20)
      {
        AudioUnitRenderActionFlags v140 = 512;
        uint64_t v20 = AudioUnitProcess((AudioUnit)v20, &v140, a2, *((_DWORD *)v3 + 127), &ioData);
        if (*((unsigned char *)v3 + 15961) || *((unsigned char *)v3 + 15962)) {
          uint64_t v20 = VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 7u, *((unsigned int *)v3 + 127), &ioData, a2);
        }
      }
    }
    if ((*((unsigned char *)v3 + 4665) & 0x20) == 0 || (*((unsigned char *)v3 + 4681) & 0x20) == 0 || !*((void *)v3 + 360))
    {
      unsigned int v38 = 0;
      while (((*((_DWORD *)v3 + 116) >> v38) & 1) == 0)
      {
        if (++v38 == 32)
        {
          unsigned int v38 = 33;
          break;
        }
      }
      double v39 = (unsigned int *)*((void *)v3 + 135);
      if (v38 >= *v39)
      {
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        float v42 = CALog::LogObjIfEnabled(1, VPLogScope(void)::scope);
        if (v42)
        {
          unsigned int v43 = v42;
          if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
          {
            int v44 = **((_DWORD **)v3 + 135);
            *(_DWORD *)buf = 136315906;
            *(void *)&uint8_t buf[4] = "vpProcessUplink_v3.cpp";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 255;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v38;
            LOWORD(v146) = 1024;
            *(_DWORD *)((char *)&v146 + 2) = v44;
            _os_log_impl(&dword_1BB0CE000, v43, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> ERROR: mPrimaryEpMicIndex is %d, but epmic only has %d channels", buf, 0x1Eu);
          }
        }
        float v45 = (int *)*((void *)v3 + 1578);
        if (v45 && (*((unsigned char *)v3 + 15961) || *((unsigned char *)v3 + 15962)))
        {
          if (VPLogScope(void)::once != -1) {
            dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
          }
          CALegacyLog::log(v45, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v3/vpProcessUplink_v3.cpp", 255, "RunUplinkEchoDSP", "ERROR: mPrimaryEpMicIndex is %d, but epmic only has %d channels", v38, **((_DWORD **)v3 + 135));
        }
        double v40 = *(void **)(*((void *)v3 + 136) + 16);
        double v41 = (const void **)*((void *)v3 + 135);
      }
      else
      {
        double v40 = *(void **)(*((void *)v3 + 136) + 16);
        double v41 = (const void **)&v39[4 * v38];
      }
      float Parameter = memcpy(v40, v41[2], *((unsigned int *)v41 + 3));
      int v48 = 0;
LABEL_138:
      if ((*((unsigned char *)v3 + 4665) & 0x40) == 0 || (*((unsigned char *)v3 + 4681) & 0x40) == 0 || !*((void *)v3 + 361))
      {
        int v53 = 0;
        goto LABEL_148;
      }
      *(void *)buf = &ioData;
      *(void *)&buf[8] = &ioOutputBufferLists;
      MEMORY[0x1F4188790](Parameter);
      uint64_t v49 = *((void *)v3 + 420);
      *((void *)&v133 - 4) = *((void *)v3 + 136);
      *((void *)&v133 - 3) = v49;
      uint64_t v132 = *((void *)v3 + 425);
      AudioUnitRenderActionFlags v140 = 512;
      float v50 = 1.0;
      if (!*(unsigned char *)(*((void *)v3 + 176) + v32)) {
        float v50 = 0.0;
      }
      AudioUnitSetParameter(*((AudioUnit *)v3 + 361), 4u, 0, 0, v50, 0);
      AudioUnitSetParameter(*((AudioUnit *)v3 + 361), 5u, 0, 0, *((AudioUnitParameterValue *)v3 + 1094), 0);
      AudioUnitProcessMultiple(*((AudioUnit *)v3 + 361), &v140, a2, *((_DWORD *)v3 + 127), 2u, (const AudioBufferList **)buf, 3u, (AudioBufferList **)&v133 - 4);
      uint64_t v51 = *((unsigned int *)v3 + 127);
      if (*((unsigned char *)v3 + 15961) || *((unsigned char *)v3 + 15962))
      {
        VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0xDu, v51, *((const AudioBufferList **)v3 + 420), a2);
        uint64_t v51 = *((unsigned int *)v3 + 127);
        uint64_t v52 = *((void *)v3 + 136);
        if (*((unsigned char *)v3 + 15961)) {
          goto LABEL_230;
        }
      }
      else
      {
        uint64_t v52 = *((void *)v3 + 136);
      }
      if (!*((unsigned char *)v3 + 15962))
      {
LABEL_231:
        memcpy(ioData.mBuffers[0].mData, *(const void **)(v52 + 16), 4 * v51);
        AudioUnitGetParameter(*((AudioUnit *)v3 + 361), 3u, 0, 0, (AudioUnitParameterValue *)v3 + 1049);
        AudioUnitGetParameter(*((AudioUnit *)v3 + 361), 8u, 0, 0, (AudioUnitParameterValue *)v3 + 1053);
        AudioUnitGetParameter(*((AudioUnit *)v3 + 361), 0x21u, 0, 0, (AudioUnitParameterValue *)v3 + 1057);
        AudioUnitGetParameter(*((AudioUnit *)v3 + 361), 0x22u, 0, 0, (AudioUnitParameterValue *)v3 + 1061);
        AudioUnitGetParameter(*((AudioUnit *)v3 + 361), 0x25u, 0, 0, (AudioUnitParameterValue *)v3 + 1065);
        AudioUnitGetParameter(*((AudioUnit *)v3 + 361), 0x24u, 0, 0, (AudioUnitParameterValue *)v3 + 1069);
        int v53 = 1;
LABEL_148:
        size_t v54 = (float *)(*(void *)(*((void *)v3 + 511) + 16) + 4 * *((unsigned int *)v3 + 127));
        v137.realp = *(float **)(*((void *)v3 + 511) + 16);
        v137.imagp = v54;
        v55 = (VPTimeFreqConverter *)*((void *)v3 + 519);
        if (v55) {
          VPTimeFreqConverter::Analyze(v55, *((const float **)&v149 + 1), &v137);
        }
        if ((*((unsigned char *)v3 + 4665) & 0x20) != 0 && (*((unsigned char *)v3 + 4681) & 0x20) != 0 && *((void *)v3 + 360))
        {
          uint64_t v56 = *((unsigned int *)v3 + 127);
          uint64_t v57 = (float *)(*(void *)(*((void *)v3 + 429) + 16) + 4 * v56);
          v137.realp = *(float **)(*((void *)v3 + 429) + 16);
          v137.imagp = v57;
          v58 = (VPTimeFreqConverter *)*((void *)v3 + 513);
          if (v58)
          {
            VPTimeFreqConverter::Analyze(v58, (const float *)ioActionFlags.mBuffers[0].mData, &v137);
            uint64_t v56 = *((unsigned int *)v3 + 127);
          }
          v59 = (float *)(*(void *)(*((void *)v3 + 505) + 16) + 4 * v56);
          v137.realp = *(float **)(*((void *)v3 + 505) + 16);
          v137.imagp = v59;
          uint64_t v60 = (VPTimeFreqConverter *)*((void *)v3 + 517);
          if (v60) {
            VPTimeFreqConverter::Analyze(v60, *(const float **)(*((void *)v3 + 419) + 16), &v137);
          }
        }
        if ((*((unsigned char *)v3 + 4665) & 0x40) != 0 && (*((unsigned char *)v3 + 4681) & 0x40) != 0 && *((void *)v3 + 361))
        {
          uint64_t v61 = *((unsigned int *)v3 + 127);
          v62 = (float *)(*(void *)(*((void *)v3 + 506) + 16) + 4 * v61);
          v137.realp = *(float **)(*((void *)v3 + 506) + 16);
          v137.imagp = v62;
          long long v63 = (VPTimeFreqConverter *)*((void *)v3 + 514);
          if (v63)
          {
            VPTimeFreqConverter::Analyze(v63, (const float *)ioData.mBuffers[0].mData, &v137);
            uint64_t v61 = *((unsigned int *)v3 + 127);
          }
          long long v64 = (float *)(*(void *)(*((void *)v3 + 505) + 32) + 4 * v61);
          v137.realp = *(float **)(*((void *)v3 + 505) + 32);
          v137.imagp = v64;
          uint64_t v65 = (VPTimeFreqConverter *)*((void *)v3 + 518);
          if (v65) {
            VPTimeFreqConverter::Analyze(v65, *(const float **)(*((void *)v3 + 420) + 16), &v137);
          }
        }
        uint64_t v66 = *((void *)v3 + 583);
        if ((v66 & 0x40000000) == 0
          || (*((unsigned char *)v3 + 4683) & 0x40) == 0
          || (v67 = (OpaqueAudioComponentInstance *)*((void *)v3 + 377)) == 0)
        {
          int v74 = 0;
          if ((v66 & 0x80000000) == 0) {
            goto LABEL_191;
          }
          goto LABEL_178;
        }
        AudioUnitSetProperty(v67, 0x457u, 0, 0, (char *)v3 + 2316, 4u);
        if ((*((unsigned char *)v3 + 4667) & 0x80) != 0 && (*((unsigned char *)v3 + 4683) & 0x80) != 0)
        {
          __int16 v68 = (OpaqueAudioComponentInstance *)*((void *)v3 + 377);
          if (*((void *)v3 + 378))
          {
            float v69 = (float)*((unsigned int *)v3 + 684);
            goto LABEL_171;
          }
        }
        else
        {
          __int16 v68 = (OpaqueAudioComponentInstance *)*((void *)v3 + 377);
        }
        float v69 = 2.0;
LABEL_171:
        AudioUnitSetParameter(v68, 0x1Bu, 0, 0, v69, 0);
        if ((*((unsigned char *)v3 + 4665) & 0x20) != 0 && (*((unsigned char *)v3 + 4681) & 0x20) != 0 && *((void *)v3 + 360)) {
          AudioUnitSetParameter(*((AudioUnit *)v3 + 377), 0x3Fu, 0, 0, *((float *)v3 + 1056) * *((float *)v3 + 1057), 0);
        }
        uint64_t v70 = *((void *)v3 + 138) + 24;
        uint64_t v71 = *((void *)v3 + 139) + 24;
        unsigned int v72 = **((_DWORD **)v3 + 135);
        if (v72 < 3) {
          uint64_t v73 = 0;
        }
        else {
          uint64_t v73 = *((void *)v3 + 140) + 24;
        }
        *(void *)buf = *((void *)v3 + 138) + 24;
        *(void *)&buf[8] = v71;
        uint64_t v77 = *((void *)v3 + 134);
        *(void *)&buf[16] = v73;
        uint64_t v146 = v77;
        long long v147 = *(_OWORD *)((char *)v3 + 3352);
        if (v72 >= 3)
        {
          *(void *)buf = v71;
          *(void *)&buf[8] = v73;
          *(void *)&buf[16] = v70;
        }
        p_AudioBufferList ioActionFlags = 0;
        AudioUnitRenderActionFlags v140 = 512;
        AudioUnitSetParameter(*((AudioUnit *)v3 + 377), 0x2Cu, 0, 0, *((AudioUnitParameterValue *)v3 + 1092), 0);
        int v74 = 1;
        AudioUnitProcessMultiple(*((AudioUnit *)v3 + 377), &v140, a2, *((_DWORD *)v3 + 127), 6u, (const AudioBufferList **)buf, 1u, &p_ioActionFlags);
        if ((*((void *)v3 + 583) & 0x80000000) == 0) {
          goto LABEL_191;
        }
LABEL_178:
        if ((*((unsigned char *)v3 + 4683) & 0x80) != 0 && *((void *)v3 + 378))
        {
          memcpy(*(void **)(*((void *)v3 + 435) + 16 * *((unsigned int *)v3 + 1042) + 16), *(const void **)(*((void *)v3 + 429) + 16), 4 * (2 * *((_DWORD *)v3 + 127)));
          memcpy(*(void **)(*((void *)v3 + 435) + 16 * *((unsigned int *)v3 + 1043) + 16), *(const void **)(*((void *)v3 + 506) + 16), 4 * (2 * *((_DWORD *)v3 + 127)));
          if (*((float *)v3 + 1068) == 0.0 && *((float *)v3 + 1069) == 0.0) {
            AudioUnitParameterValue v75 = 0.0;
          }
          else {
            AudioUnitParameterValue v75 = 1.0;
          }
          AudioUnitSetParameter(*((AudioUnit *)v3 + 378), 0x20u, 0, 0, v75, 0);
          *(void *)buf = *((void *)v3 + 435);
          p_AudioBufferList ioActionFlags = (AudioBufferList *)*((void *)v3 + 430);
          AudioUnitRenderActionFlags v140 = 512;
          AudioUnitProcessMultiple(*((AudioUnit *)v3 + 378), &v140, a2, *((_DWORD *)v3 + 127), 1u, (const AudioBufferList **)buf, 1u, &p_ioActionFlags);
          UInt32 ioDataSize = 8 * *((_DWORD *)v3 + 127);
          AudioUnitGetProperty(*((AudioUnit *)v3 + 378), 0xE7Au, 0, 0, *(void **)(*((void *)v3 + 538) + 16), &ioDataSize);
          UInt32 ioDataSize = 8 * *((_DWORD *)v3 + 127);
          AudioUnitGetProperty(*((AudioUnit *)v3 + 378), 0xE79u, 0, 0, *(void **)(*((void *)v3 + 538) + 32), &ioDataSize);
          if (*((unsigned char *)v3 + 15961) || *((unsigned char *)v3 + 15962)) {
            VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0xAu, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 430), a2);
          }
          int v76 = 1;
LABEL_192:
          char v135 = 0;
          VoiceProcessorV2::SignalParamSwitchMix((AudioUnit *)v3, v76, v74, &v135, v47);
          VoiceProcessorV2::TimeAlignedReferenceAndOtherHandling(v3, v48, v53, v76, v135);
          memcpy(*(void **)(*((void *)v3 + 433) + 16), *(const void **)(*((void *)v3 + 505) + 16), *((unsigned int *)v3 + 1073));
          uint64_t v78 = *((void *)v3 + 583);
          if ((v78 & 0x20000000000000) != 0 && (*((unsigned char *)v3 + 4686) & 0x20) != 0 && *((void *)v3 + 400)) {
            BOOL v79 = 1;
          }
          else {
            BOOL v79 = (v78 & 0x80000000000000) != 0 && (*((unsigned char *)v3 + 4686) & 0x80) != 0 && *((void *)v3 + 402) != 0;
          }
          *(float *)&UInt32 ioDataSize = 0.0;
          AudioUnitParameterValue v134 = 0.0;
          AudioUnitGetParameter(*((AudioUnit *)v3 + 386), 0x1Du, 0, 0, (AudioUnitParameterValue *)&ioDataSize);
          BOOL v80 = *(float *)&ioDataSize < 1.0 && v79;
          if (v79)
          {
            *(_DWORD *)buf = 1065353216;
            if (*(float *)&ioDataSize < 1.0) {
              vDSP_vfill((const float *)buf, *(float **)(*((void *)v3 + 502) + 16), 1, *((unsigned int *)v3 + 127));
            }
            vDSP_vfill((const float *)buf, *(float **)(*((void *)v3 + 500) + 16), 1, *((unsigned int *)v3 + 127));
          }
          else if ((*((unsigned char *)v3 + 4668) & 0x80) == 0 || (*((unsigned char *)v3 + 4684) & 0x80) == 0 || !*((void *)v3 + 386))
          {
            char v81 = 0;
            goto LABEL_215;
          }
          if (*((unsigned char *)v3 + 15961) || *((unsigned char *)v3 + 15962)) {
            VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x61u, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 429), a2);
          }
          char v81 = 1;
LABEL_215:
          uint64_t v82 = *((void *)v3 + 583);
          if ((v82 & 0x10000000000) == 0
            || (*((unsigned char *)v3 + 4685) & 1) == 0
            || (v83 = (OpaqueAudioComponentInstance *)*((void *)v3 + 387)) == 0)
          {
LABEL_237:
            if ((v82 & 0x10000000000000) != 0 && (*((unsigned char *)v3 + 4686) & 0x10) != 0)
            {
              v88 = (OpaqueAudioComponentInstance *)*((void *)v3 + 399);
              if (v88)
              {
                uint64_t v89 = *((void *)v3 + 500);
                *(void *)buf = *((void *)v3 + 429);
                *(void *)&buf[8] = v89;
                p_AudioBufferList ioActionFlags = (AudioBufferList *)*((void *)v3 + 432);
                uint64_t v143 = v89;
                AudioUnitRenderActionFlags v140 = 512;
                AudioUnitProcessMultiple(v88, &v140, a2, *((_DWORD *)v3 + 127), 2u, (const AudioBufferList **)buf, 2u, &p_ioActionFlags);
                if (*((unsigned char *)v3 + 15961) || *((unsigned char *)v3 + 15962)) {
                  VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x62u, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 429), a2);
                }
                uint64_t v82 = *((void *)v3 + 583);
              }
            }
            if ((v82 & 0x20000000000000) != 0
              && (*((unsigned char *)v3 + 4686) & 0x20) != 0
              && (v90 = (OpaqueAudioComponentInstance *)*((void *)v3 + 400)) != 0)
            {
              uint64_t v91 = *((void *)v3 + 500);
              *(void *)buf = *((void *)v3 + 429);
              *(void *)&buf[8] = v91;
              uint64_t v92 = *((void *)v3 + 502);
              p_AudioBufferList ioActionFlags = (AudioBufferList *)*((void *)v3 + 430);
              uint64_t v143 = v92;
              AudioUnitRenderActionFlags v140 = 512;
              AudioUnitProcessMultiple(v90, &v140, a2, *((_DWORD *)v3 + 127), 2u, (const AudioBufferList **)buf, 2u, &p_ioActionFlags);
              if ((*((unsigned char *)v3 + 4670) & 0x10) != 0 && (*((unsigned char *)v3 + 4686) & 0x10) != 0 && *((void *)v3 + 399)) {
                vDSP_vmin(*(const float **)(*((void *)v3 + 502) + 16), 1, *(const float **)(*((void *)v3 + 501) + 16), 1, *(float **)(*((void *)v3 + 502) + 16), 1, *((unsigned int *)v3 + 127));
              }
              AudioUnitGetParameter(*((AudioUnit *)v3 + 400), 1u, 0, 0, &outValue);
              if ((*((unsigned char *)v3 + 4672) & 4) == 0 || (*((unsigned char *)v3 + 4688) & 4) == 0 || !*((void *)v3 + 413)) {
                goto LABEL_263;
              }
              v93 = (OpaqueAudioComponentInstance *)*((void *)v3 + 400);
              AudioUnitParameterID v94 = 2;
            }
            else
            {
              if ((v82 & 0x80000000000000) == 0
                || (*((unsigned char *)v3 + 4686) & 0x80) == 0
                || (v95 = (OpaqueAudioComponentInstance *)*((void *)v3 + 402)) == 0)
              {
                int v98 = 1;
                goto LABEL_268;
              }
              AudioUnitSetParameter(v95, 0x14u, 0, 0, *((AudioUnitParameterValue *)v3 + 4206), 0);
              uint64_t v96 = *((void *)v3 + 432);
              *(void *)buf = *((void *)v3 + 429);
              *(void *)&buf[8] = v96;
              *(void *)&buf[16] = *((void *)v3 + 500);
              uint64_t v97 = *((void *)v3 + 437);
              p_AudioBufferList ioActionFlags = (AudioBufferList *)*((void *)v3 + 430);
              uint64_t v143 = v97;
              uint64_t v144 = *((void *)v3 + 502);
              AudioUnitRenderActionFlags v140 = 512;
              AudioUnitProcessMultiple(*((AudioUnit *)v3 + 402), &v140, a2, *((_DWORD *)v3 + 127), 3u, (const AudioBufferList **)buf, 3u, &p_ioActionFlags);
              AudioUnitGetParameter(*((AudioUnit *)v3 + 402), 2u, 0, 0, &outValue);
              if ((*((unsigned char *)v3 + 4672) & 4) == 0 || (*((unsigned char *)v3 + 4688) & 4) == 0 || !*((void *)v3 + 413))
              {
LABEL_263:
                if (*((unsigned char *)v3 + 15961) || *((unsigned char *)v3 + 15962)) {
                  VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x27u, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 430), a2);
                }
                int v98 = 0;
LABEL_268:
                if ((*((unsigned char *)v3 + 4668) & 0x80) == 0) {
                  goto LABEL_292;
                }
                if ((*((unsigned char *)v3 + 4684) & 0x80) == 0
                  || (v99 = (OpaqueAudioComponentInstance *)*((void *)v3 + 386)) == 0)
                {
LABEL_286:
                  if ((*((unsigned char *)v3 + 4684) & 0x80) != 0 && *((void *)v3 + 386) && v80)
                  {
                    v107 = *(float **)(*((void *)v3 + 502) + 16);
                    vDSP_vmin(*(const float **)(*((void *)v3 + 500) + 16), 1, v107, 1, v107, 1, *((unsigned int *)v3 + 127));
                    v108 = *(const float **)(*((void *)v3 + 429) + 16);
                    v109 = *(float **)(*((void *)v3 + 430) + 16);
                    vDSP_vmul(v108, 1, v107, 1, v109, 1, *((unsigned int *)v3 + 127));
                    vDSP_vmul(&v108[*((unsigned int *)v3 + 127) + 1], 1, v107 + 1, 1, &v109[*((unsigned int *)v3 + 127) + 1], 1, (*((_DWORD *)v3 + 127) - 1));
                    v108[*((unsigned int *)v3 + 127)] = v108[*((unsigned int *)v3 + 127)]
                                                      * v107[*((_DWORD *)v3 + 127) - 1];
LABEL_299:
                    if (((v81 & 1) != 0
                       || (*((unsigned char *)v3 + 4668) & 0x80) != 0
                       && (*((unsigned char *)v3 + 4684) & 0x80) != 0
                       && *((void *)v3 + 386))
                      && (*((unsigned char *)v3 + 15961) || *((unsigned char *)v3 + 15962)))
                    {
                      VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x60u, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 430), a2);
                    }
                    if ((*((unsigned char *)v3 + 4671) & 0x20) != 0 && (*((unsigned char *)v3 + 4687) & 0x20) != 0)
                    {
                      v112 = (OpaqueAudioComponentInstance *)*((void *)v3 + 408);
                      if (v112)
                      {
                        AudioUnitSetParameter(v112, 0, 0, 0, *((AudioUnitParameterValue *)v3 + 3133), 0);
                        AudioUnitSetParameter(*((AudioUnit *)v3 + 408), 4u, 0, 0, *((AudioUnitParameterValue *)v3 + 1048), 0);
                        AudioUnitSetParameter(*((AudioUnit *)v3 + 408), 0x13u, 0, 0, *((AudioUnitParameterValue *)v3 + 1052), 0);
                        AudioUnitSetParameter(*((AudioUnit *)v3 + 408), 3u, 0, 0, outValue, 0);
                        uint64_t v113 = *((void *)v3 + 511);
                        *(void *)buf = *((void *)v3 + 419);
                        *(void *)&buf[8] = v113;
                        uint64_t v114 = *((void *)v3 + 433);
                        *(void *)&buf[16] = *((void *)v3 + 430);
                        uint64_t v146 = v114;
                        uint64_t v115 = *((void *)v3 + 502);
                        *(void *)&long long v147 = *((void *)v3 + 500);
                        *((void *)&v147 + 1) = v115;
                        p_AudioBufferList ioActionFlags = (AudioBufferList *)*((void *)v3 + 136);
                        AudioUnitRenderActionFlags v140 = 512;
                        AudioUnitProcessMultiple(*((AudioUnit *)v3 + 408), &v140, a2, *((_DWORD *)v3 + 127), 6u, (const AudioBufferList **)buf, 1u, &p_ioActionFlags);
                        AudioUnitParameterValue v133 = 0.0;
                        AudioUnitGetParameter(*((AudioUnit *)v3 + 408), 1u, 0, 0, &v133);
                        *((AudioUnitParameterValue *)v3 + 3134) = v133;
                        if ((*((unsigned char *)v3 + 4672) & 4) != 0
                          && (*((unsigned char *)v3 + 4688) & 4) != 0
                          && *((void *)v3 + 413))
                        {
                          AudioUnitGetParameter(*((AudioUnit *)v3 + 408), 2u, 0, 0, &outValue);
                          AudioUnitSetParameter(*((AudioUnit *)v3 + 413), 0x23u, 0, 0, outValue, 0);
                        }
                      }
                    }
                    goto LABEL_313;
                  }
LABEL_292:
                  if ((*((unsigned char *)v3 + 8900) & 0x80) != 0
                    && (*((unsigned char *)v3 + 8908) & 0x80) != 0
                    && *((void *)v3 + 477)
                    && !v79)
                  {
                    *(_DWORD *)buf = 1065353216;
                    unsigned int v111 = *((_DWORD *)v3 + 127);
                    vDSP_vfill((const float *)buf, *(float **)(*((void *)v3 + 502) + 16), 1, v111);
                    memcpy(*(void **)(*((void *)v3 + 430) + 16), *(const void **)(*((void *)v3 + 429) + 16), 8 * v111);
                  }
                  goto LABEL_299;
                }
                AudioUnitSetParameter(v99, 6u, 0, 0, *((AudioUnitParameterValue *)v3 + 1056), 0);
                AudioUnitSetParameter(*((AudioUnit *)v3 + 386), 7u, 0, 0, *((AudioUnitParameterValue *)v3 + 1060), 0);
                AudioUnitSetParameter(*((AudioUnit *)v3 + 386), 0xDu, 0, 0, *((AudioUnitParameterValue *)v3 + 1064), 0);
                uint64_t v100 = *((void *)v3 + 433);
                *(void *)buf = *((void *)v3 + 429);
                *(void *)&buf[8] = v100;
                uint64_t v101 = *((void *)v3 + 502);
                *(void *)&buf[16] = *((void *)v3 + 512);
                uint64_t v146 = v101;
                if (v80)
                {
                  v102 = (AudioBufferList **)((char *)v3 + 3456);
                  uint64_t v101 = *((void *)v3 + 500);
                }
                else
                {
                  uint64_t v146 = 0;
                  v102 = (AudioBufferList **)((char *)v3 + 3440);
                }
                p_AudioBufferList ioActionFlags = *v102;
                uint64_t v143 = v101;
                AudioUnitRenderActionFlags v140 = 512;
                AudioUnitProcessMultiple(*((AudioUnit *)v3 + 386), &v140, a2, *((_DWORD *)v3 + 127), 4u, (const AudioBufferList **)buf, 2u, &p_ioActionFlags);
                if ((v98 | !v80) == 1) {
                  AudioUnitGetParameter(*((AudioUnit *)v3 + 386), 0x20u, 0, 0, &outValue);
                }
                uint64_t v103 = *((unsigned int *)v3 + 127);
                uint64_t v104 = 3440;
                if (v80) {
                  uint64_t v104 = 3456;
                }
                if (*((unsigned char *)v3 + 15961) || *((unsigned char *)v3 + 15962))
                {
                  VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x24u, v103, *(const AudioBufferList **)((char *)v3 + v104), a2);
                  uint64_t v103 = *((unsigned int *)v3 + 127);
                  v105 = (const AudioBufferList *)*((void *)v3 + 500);
                  if (*((unsigned char *)v3 + 15961))
                  {
LABEL_284:
                    VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x4Fu, v103, v105, a2);
LABEL_285:
                    if ((*((unsigned char *)v3 + 4668) & 0x80) == 0) {
                      goto LABEL_292;
                    }
                    goto LABEL_286;
                  }
                }
                else
                {
                  v105 = (const AudioBufferList *)*((void *)v3 + 500);
                }
                if (!*((unsigned char *)v3 + 15962)) {
                  goto LABEL_285;
                }
                goto LABEL_284;
              }
              v93 = (OpaqueAudioComponentInstance *)*((void *)v3 + 402);
              AudioUnitParameterID v94 = 9;
            }
            AudioUnitGetParameter(v93, v94, 0, 0, &v134);
            AudioUnitSetParameter(*((AudioUnit *)v3 + 413), 0x12u, 0, 0, v134, 0);
            goto LABEL_263;
          }
          AudioUnitSetParameter(v83, 6u, 0, 0, *((AudioUnitParameterValue *)v3 + 1057), 0);
          AudioUnitSetParameter(*((AudioUnit *)v3 + 387), 7u, 0, 0, *((AudioUnitParameterValue *)v3 + 1061), 0);
          AudioUnitSetParameter(*((AudioUnit *)v3 + 387), 0xDu, 0, 0, *((AudioUnitParameterValue *)v3 + 1065), 0);
          memcpy(*(void **)(*((void *)v3 + 434) + 16), *(const void **)(*((void *)v3 + 505) + 32), *((unsigned int *)v3 + 1073));
          uint64_t v84 = *((void *)v3 + 434);
          *(void *)buf = *((void *)v3 + 506);
          *(void *)&buf[8] = v84;
          *(void *)&buf[16] = *((void *)v3 + 512);
          uint64_t v146 = 0;
          uint64_t v85 = *((void *)v3 + 501);
          p_AudioBufferList ioActionFlags = (AudioBufferList *)*((void *)v3 + 432);
          uint64_t v143 = v85;
          AudioUnitRenderActionFlags v140 = 512;
          AudioUnitProcessMultiple(*((AudioUnit *)v3 + 387), &v140, a2, *((_DWORD *)v3 + 127), 4u, (const AudioBufferList **)buf, 2u, &p_ioActionFlags);
          uint64_t v86 = *((unsigned int *)v3 + 127);
          if (*((unsigned char *)v3 + 15961) || *((unsigned char *)v3 + 15962))
          {
            VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x25u, v86, *((const AudioBufferList **)v3 + 432), a2);
            uint64_t v86 = *((unsigned int *)v3 + 127);
            v87 = (const AudioBufferList *)*((void *)v3 + 501);
            if (*((unsigned char *)v3 + 15961)) {
              goto LABEL_235;
            }
          }
          else
          {
            v87 = (const AudioBufferList *)*((void *)v3 + 501);
          }
          if (!*((unsigned char *)v3 + 15962))
          {
LABEL_236:
            uint64_t v82 = *((void *)v3 + 583);
            goto LABEL_237;
          }
LABEL_235:
          VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x50u, v86, v87, a2);
          goto LABEL_236;
        }
LABEL_191:
        int v76 = 0;
        goto LABEL_192;
      }
LABEL_230:
      VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x1Du, v51, (const AudioBufferList *)v52, a2);
      uint64_t v52 = *((void *)v3 + 136);
      LODWORD(v51) = *((_DWORD *)v3 + 127);
      goto LABEL_231;
    }
    *(void *)buf = &ioActionFlags;
    *(void *)&buf[8] = &ioOutputBufferLists;
    MEMORY[0x1F4188790](v20);
    uint64_t v34 = *((void *)v3 + 419);
    *((void *)&v133 - 4) = *((void *)v3 + 136);
    *((void *)&v133 - 3) = v34;
    uint64_t v132 = *((void *)v3 + 424);
    AudioUnitRenderActionFlags v140 = 512;
    float v35 = 1.0;
    if (!*(unsigned char *)(*((void *)v3 + 176) + v31)) {
      float v35 = 0.0;
    }
    AudioUnitSetParameter(*((AudioUnit *)v3 + 360), 4u, 0, 0, v35, 0);
    AudioUnitSetParameter(*((AudioUnit *)v3 + 360), 5u, 0, 0, *((AudioUnitParameterValue *)v3 + 1094), 0);
    AudioUnitProcessMultiple(*((AudioUnit *)v3 + 360), &v140, a2, *((_DWORD *)v3 + 127), 2u, (const AudioBufferList **)buf, 3u, (AudioBufferList **)&v133 - 4);
    uint64_t v36 = *((unsigned int *)v3 + 127);
    if (*((unsigned char *)v3 + 15961) || *((unsigned char *)v3 + 15962))
    {
      VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0xCu, v36, *((const AudioBufferList **)v3 + 419), a2);
      uint64_t v36 = *((unsigned int *)v3 + 127);
      uint64_t v37 = *((void *)v3 + 136);
      if (*((unsigned char *)v3 + 15961)) {
        goto LABEL_226;
      }
    }
    else
    {
      uint64_t v37 = *((void *)v3 + 136);
    }
    if (!*((unsigned char *)v3 + 15962))
    {
LABEL_227:
      memcpy(ioActionFlags.mBuffers[0].mData, *(const void **)(v37 + 16), 4 * v36);
      AudioUnitGetParameter(*((AudioUnit *)v3 + 360), 3u, 0, 0, (AudioUnitParameterValue *)v3 + 1048);
      AudioUnitGetParameter(*((AudioUnit *)v3 + 360), 8u, 0, 0, (AudioUnitParameterValue *)v3 + 1052);
      AudioUnitGetParameter(*((AudioUnit *)v3 + 360), 0x21u, 0, 0, (AudioUnitParameterValue *)v3 + 1056);
      AudioUnitGetParameter(*((AudioUnit *)v3 + 360), 0x22u, 0, 0, (AudioUnitParameterValue *)v3 + 1060);
      AudioUnitGetParameter(*((AudioUnit *)v3 + 360), 0x25u, 0, 0, (AudioUnitParameterValue *)v3 + 1064);
      float Parameter = (void *)AudioUnitGetParameter(*((AudioUnit *)v3 + 360), 0x24u, 0, 0, (AudioUnitParameterValue *)v3 + 1068);
      int v48 = 1;
      goto LABEL_138;
    }
LABEL_226:
    VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x1Cu, v36, (const AudioBufferList *)v37, a2);
    uint64_t v37 = *((void *)v3 + 136);
    LODWORD(v36) = *((_DWORD *)v3 + 127);
    goto LABEL_227;
  }
  unsigned int v9 = 0;
  while (((*((_DWORD *)v3 + 116) >> v9) & 1) == 0)
  {
    if (++v9 == 32)
    {
      unsigned int v9 = 33;
      break;
    }
  }
  double v10 = (unsigned int *)*((void *)v3 + 135);
  if (v9 >= *v10)
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    unsigned int v13 = (void *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
    {
      double v14 = (*v13 ? *v13 : MEMORY[0x1E4F14500]);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        int v15 = **((_DWORD **)v3 + 135);
        *(_DWORD *)buf = 136315906;
        *(void *)&uint8_t buf[4] = "vpProcessUplink_v3.cpp";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 49;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v9;
        LOWORD(v146) = 1024;
        *(_DWORD *)((char *)&v146 + 2) = v15;
        _os_log_impl(&dword_1BB0CE000, v14, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> ERROR: mPrimaryEpMicIndex is %d, but epmic only has %d channels", buf, 0x1Eu);
      }
    }
    uint64_t v16 = (int *)*((void *)v3 + 1578);
    if (v16 && (*((unsigned char *)v3 + 15961) || *((unsigned char *)v3 + 15962)))
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      CALegacyLog::log(v16, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v3/vpProcessUplink_v3.cpp", 49, "RunUplinkEchoDSP", "ERROR: mPrimaryEpMicIndex is %d, but epmic only has %d channels", v9, **((_DWORD **)v3 + 135));
    }
    unsigned int v11 = *(void **)(*((void *)v3 + 136) + 16);
    int v12 = (const void **)*((void *)v3 + 135);
  }
  else
  {
    unsigned int v11 = *(void **)(*((void *)v3 + 136) + 16);
    int v12 = (const void **)&v10[4 * v9];
  }
  memcpy(v11, v12[2], *((unsigned int *)v12 + 3));
  if (*((unsigned char *)v3 + 2085))
  {
    if ((*((unsigned char *)v3 + 4670) & 0x20) != 0 && (*((unsigned char *)v3 + 4686) & 0x20) != 0)
    {
      float v17 = (OpaqueAudioComponentInstance *)*((void *)v3 + 400);
      if (v17)
      {
        uint64_t v18 = *((void *)v3 + 500);
        *(void *)buf = *((void *)v3 + 136);
        *(void *)&buf[8] = v18;
        uint64_t v19 = *((void *)v3 + 502);
        ioOutputBufferLists = *(AudioBufferList **)buf;
        *(void *)&long long v149 = v19;
        ioActionFlags.UInt32 mNumberBuffers = 512;
        AudioUnitProcessMultiple(v17, &ioActionFlags.mNumberBuffers, a2, *((_DWORD *)v3 + 127), 2u, (const AudioBufferList **)buf, 2u, &ioOutputBufferLists);
        if (*((unsigned char *)v3 + 15961) || *((unsigned char *)v3 + 15962)) {
          VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x27u, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 136), a2);
        }
        if ((*((unsigned char *)v3 + 4672) & 4) != 0 && (*((unsigned char *)v3 + 4688) & 4) != 0 && *((void *)v3 + 413))
        {
          AudioUnitGetParameter(*((AudioUnit *)v3 + 400), 1u, 0, 0, &outValue);
          AudioUnitSetParameter(*((AudioUnit *)v3 + 413), 0x23u, 0, 0, outValue, 0);
        }
      }
    }
  }
LABEL_313:
  *(_DWORD *)buf = 0;
  unsigned int v116 = VoiceProcessorV2::LocalVoiceDuckingForMediaChatEnabled(v3);
  unsigned int v118 = v116;
  if (!*((unsigned char *)v3 + 2080))
  {
    if ((v116 & 1) == 0)
    {
LABEL_334:
      *((_DWORD *)v3 + 4126) = 0;
      goto LABEL_335;
    }
    VoiceProcessorV2::DetectVoiceActivity(v3, a2, v117);
LABEL_322:
    uint64_t v120 = *((void *)v3 + 583);
    if ((v120 & 0x4000000000000000) != 0
      && (*((unsigned char *)v3 + 4687) & 0x40) != 0
      && (v121 = (OpaqueAudioComponentInstance *)*((void *)v3 + 409)) != 0)
    {
      AudioUnitParameterID v122 = 1936748646;
    }
    else
    {
      if ((v120 & 0x2000000000000000) == 0
        || (*((unsigned char *)v3 + 4687) & 0x20) == 0
        || (v121 = (OpaqueAudioComponentInstance *)*((void *)v3 + 408)) == 0)
      {
        *(AudioUnitParameterValue *)buf = outValue;
        goto LABEL_332;
      }
      AudioUnitParameterID v122 = 2;
    }
    AudioUnitGetParameter(v121, v122, 0, 0, (AudioUnitParameterValue *)buf);
    goto LABEL_332;
  }
  if (*((void *)v3 + 2062)) {
    char v119 = 1;
  }
  else {
    char v119 = v116;
  }
  if (v119)
  {
    VoiceProcessorV2::DetectVoiceActivity(v3, a2, v117);
    if (v118) {
      goto LABEL_322;
    }
  }
LABEL_332:
  if (!*((unsigned char *)v3 + 2080)) {
    goto LABEL_334;
  }
  bzero(*(void **)(*((void *)v3 + 136) + 16), 4 * *((unsigned int *)v3 + 127));
  *(_DWORD *)buf = 0;
LABEL_335:
  if (*((unsigned char *)v3 + 15961) || *((unsigned char *)v3 + 15962)) {
    VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x2Au, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 136), a2);
  }
  if ((*((unsigned char *)v3 + 8897) & 0x80) != 0 && (*((unsigned char *)v3 + 8905) & 0x80) != 0)
  {
    v123 = (OpaqueAudioComponentInstance *)*((void *)v3 + 453);
    unsigned int v124 = v123 ? v118 : 0;
    if (v124 == 1) {
      AudioUnitSetParameter(v123, 0x12u, 0, 0, *(AudioUnitParameterValue *)buf, 0);
    }
  }
  uint64_t v125 = *((void *)v3 + 584);
  if (v125 & 1) != 0 && (*((unsigned char *)v3 + 4688))
  {
    v126 = (OpaqueAudioComponentInstance *)*((void *)v3 + 411);
    if (v126)
    {
      LODWORD(ioOutputBufferLists) = 512;
      AudioUnitProcess(v126, (AudioUnitRenderActionFlags *)&ioOutputBufferLists, a2, *((_DWORD *)v3 + 127), *((AudioBufferList **)v3 + 136));
      if (*((unsigned char *)v3 + 15961) || *((unsigned char *)v3 + 15962)) {
        VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x2Cu, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 136), a2);
      }
      uint64_t v125 = *((void *)v3 + 584);
    }
  }
  if ((v125 & 2) != 0 && (*((unsigned char *)v3 + 4688) & 2) != 0)
  {
    v127 = (OpaqueAudioComponentInstance *)*((void *)v3 + 412);
    if (v127)
    {
      LODWORD(ioOutputBufferLists) = 512;
      AudioUnitProcess(v127, (AudioUnitRenderActionFlags *)&ioOutputBufferLists, a2, *((_DWORD *)v3 + 127), *((AudioBufferList **)v3 + 136));
      uint64_t v125 = *((void *)v3 + 584);
    }
  }
  if ((v125 & 4) != 0
    && (*((unsigned char *)v3 + 4688) & 4) != 0
    && (v128 = (OpaqueAudioComponentInstance *)*((void *)v3 + 413)) != 0)
  {
    LODWORD(ioOutputBufferLists) = 512;
    AudioUnitProcess(v128, (AudioUnitRenderActionFlags *)&ioOutputBufferLists, a2, *((_DWORD *)v3 + 127), *((AudioBufferList **)v3 + 136));
    if (*((unsigned char *)v3 + 15961) || *((unsigned char *)v3 + 15962)) {
      VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x2Du, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 136), a2);
    }
    if ((*((unsigned char *)v3 + 4671) & 0x20) != 0 && (*((unsigned char *)v3 + 4687) & 0x20) != 0 && *((void *)v3 + 408))
    {
      ioActionFlags.UInt32 mNumberBuffers = 0;
      AudioUnitGetParameter(*((AudioUnit *)v3 + 413), 1u, 0, 0, (AudioUnitParameterValue *)&ioActionFlags.mNumberBuffers);
      AudioUnitSetParameter(*((AudioUnit *)v3 + 408), 0x11u, 0, 0, *(AudioUnitParameterValue *)&ioActionFlags.mNumberBuffers, 0);
    }
    ioActionFlags.UInt32 mNumberBuffers = 0;
    AudioUnitGetParameter(*((AudioUnit *)v3 + 413), 0x1Bu, 0, 0, (AudioUnitParameterValue *)&ioActionFlags.mNumberBuffers);
    UInt32 mNumberBuffers = ioActionFlags.mNumberBuffers;
    if (*((float *)v3 + 572) != *(float *)&ioActionFlags.mNumberBuffers)
    {
      if ((*((unsigned char *)v3 + 4671) & 0x20) != 0 && (*((unsigned char *)v3 + 4687) & 0x20) != 0)
      {
        v130 = (OpaqueAudioComponentInstance *)*((void *)v3 + 408);
        if (v130)
        {
          AudioUnitSetParameter(v130, 0x12u, 0, 0, *(AudioUnitParameterValue *)&ioActionFlags.mNumberBuffers, 0);
          UInt32 mNumberBuffers = ioActionFlags.mNumberBuffers;
        }
      }
      *((_DWORD *)v3 + 572) = mNumberBuffers;
    }
  }
  else if ((*((void *)v3 + 583) & 0x8000000000000000) != 0 {
         && ((*((void *)v3 + 585) & 0x8000000000000000) != 0 || *((unsigned char *)v3 + 472)))
  }
  {
    LODWORD(ioOutputBufferLists) = __exp10f(*((float *)v3 + 1093) / 20.0);
    vDSP_vsmul(*(const float **)(*((void *)v3 + 136) + 16), 1, (const float *)&ioOutputBufferLists, *(float **)(*((void *)v3 + 136) + 16), 1, *((unsigned int *)v3 + 127));
    if (*((unsigned char *)v3 + 15961) || *((unsigned char *)v3 + 15962)) {
      VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x2Bu, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 136), a2);
    }
  }
  return 0;
}

void *CADeprecated::CABufferList::CopyDataFrom(void *this, const AudioBufferList *a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a2->mNumberBuffers)
  {
    uint64_t v3 = (uint64_t)this;
    uint64_t v4 = 0;
    unint64_t v5 = 0;
    do
    {
      unsigned int v6 = *(_DWORD *)(v3 + 16);
      size_t mDataByteSize = a2->mBuffers[v4].mDataByteSize;
      if (v6) {
        BOOL v8 = mDataByteSize > v6;
      }
      else {
        BOOL v8 = 0;
      }
      if (v8)
      {
        if (os_log_type_enabled(0, OS_LOG_TYPE_ERROR))
        {
          int v11 = 136315394;
          int v12 = "CABufferList.h";
          __int16 v13 = 1024;
          int v14 = 120;
          _os_log_impl(&dword_1BB0CE000, 0, OS_LOG_TYPE_ERROR, "%25s:%-5d ASSERTION FAILURE [(mBufferCapacity == 0 || other.mBuffers[i].mDataByteSize <= mBufferCapacity) != 0 is false]: ", (uint8_t *)&v11, 0x12u);
        }
        __break(1u);
      }
      unsigned int v9 = *(void **)(v3 + v4 * 16 + 40);
      mData = a2->mBuffers[v4].mData;
      *(_DWORD *)(v3 + v4 * 16 + 36) = mDataByteSize;
      this = memcpy(v9, mData, mDataByteSize);
      ++v5;
      ++v4;
    }
    while (v5 < a2->mNumberBuffers);
  }
  return this;
}

uint64_t CALog::LogObjIfEnabled(int a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  int v3 = CALegacyLog::LogEnabled(a1, a2, 0);
  uint64_t result = 0;
  if (v3)
  {
    if (*(void *)a2) {
      return *(void *)a2;
    }
    else {
      return MEMORY[0x1E4F14500];
    }
  }
  return result;
}

uint64_t AUDspLibWithNewParameters::parameterConverters(AUDspLibWithNewParameters *this)
{
  return *((void *)this + 271);
}

uint64_t AUDspLib::algorithm(AUDspLib *this, unsigned int a2)
{
  return *((void *)this + 7 * a2 + 66);
}

void AUAmbienceLeveler::newDspLibAlgorithm(AUAmbienceLeveler *this)
{
}

void sub_1BB346444(_Unwind_Exception *a1)
{
  MEMORY[0x1C185D370](v1, 0x10E1C400E733140);
  _Unwind_Resume(a1);
}

uint64_t AUAmbienceLeveler::Version(AUAmbienceLeveler *this)
{
  return 33751040;
}

uint64_t AUDspLib::GetScopeExtended(AUDspLib *this, int a2)
{
  if (a2 == 4) {
    return (uint64_t)this + 1536;
  }
  else {
    return 0;
  }
}

uint64_t AUAmbienceLeveler::SupportedNumChannels(AUAmbienceLeveler *this, const AUChannelInfo **a2)
{
  if (a2) {
    *a2 = (const AUChannelInfo *)&AUAmbienceLeveler::SupportedNumChannels(AUChannelInfo const**)::sChannels;
  }
  return 1;
}

BOOL AUDspLib::StreamFormatWritable(AUDspLib *this)
{
  return *((unsigned char *)this + 17) == 0;
}

uint64_t AUDspLib::SupportsTail(AUDspLib *this)
{
  return 1;
}

uint64_t AUAmbienceLeveler::GetParameterInfo(AUAmbienceLeveler *this, unsigned int a2, uint64_t a3, AudioUnitParameterInfo *buffer)
{
  if (a3 == 100)
  {
    buffer->unit = kAudioUnitParameterUnit_Decibels;
    *(void *)&buffer->minValue = 0x41400000C1C00000;
    *(void *)&buffer->defaultValue = 0x4980800000000000;
    buffer->cfNameString = @"Gain";
    CFStringGetCString(@"Gain", buffer->name, 52, 0x8000100u);
    return 0;
  }
  else
  {
    return AUDspLibWithNewParameters::GetParameterInfo(this, a2, a3, buffer);
  }
}

uint64_t AUAmbienceLeveler::ProcessBufferLists(AUAmbienceLeveler *this, unsigned int *a2, const AudioBufferList *a3, AudioBufferList *a4, uint64_t a5)
{
  int v11 = a4;
  int v12 = a3;
  uint64_t v6 = (*(uint64_t (**)(AUAmbienceLeveler *, unsigned int *, uint64_t, uint64_t, const AudioBufferList **, uint64_t, AudioBufferList **))(*(void *)this + 184))(this, a2, a5, 1, &v12, 1, &v11);
  uint64_t v7 = *((void *)this + 66);
  if (v7)
  {
    float v8 = *(float *)(v7 + 872);
    uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AUAmbienceLeveler *)((char *)this + 32), 0);
    ausdk::AUElement::SetParameter(Element, 0x64u, v8, 0);
  }
  return v6;
}

uint64_t AUDspLib::CanScheduleParameters(AUDspLib *this)
{
  return 1;
}

uint64_t AUAmbienceLeveler::GetProperty(AUAmbienceLeveler *this, unsigned int a2, unsigned int a3, unsigned int a4, void *a5)
{
  __n128 v11 = MEMORY[0x1F4188790](this);
  int v12 = v9;
  uint64_t v13 = v5;
  switch(v6)
  {
    case 23777:
      uint64_t v14 = *(void *)(v5 + 528);
      if (!v14) {
        return 4294956429;
      }
      int v62 = 0;
      uint64_t v15 = (uint64_t)(*(void *)(v5 + 18856) - *(void *)(v5 + 18848)) >> 4;
      uint64_t v63 = *(void *)(v5 + 18848);
      uint64_t v64 = v15;
      uint64_t v16 = (uint64_t)(*(void *)(v5 + 18880) - *(void *)(v5 + 18872)) >> 4;
      uint64_t v65 = *(void *)(v5 + 18872);
      uint64_t v66 = v16;
      uint64_t v17 = (uint64_t)(*(void *)(v5 + 18904) - *(void *)(v5 + 18896)) >> 4;
      uint64_t v67 = *(void *)(v5 + 18896);
      uint64_t v68 = v17;
      (*(void (**)(uint64_t, unsigned char *, uint64_t, __n128))(*(void *)v14 + 184))(v14, v58, 6156, v11);
      DspLib::AmbienceLeveler::Algorithm::computeEQFilters(v14, v13 + 2376, 0x801uLL, (uint64_t)v59, 2049, (uint64_t)v60, 2049, v18, &v61, 0x801uLL, (const float *)(v13 + 10572), 0x801uLL, (uint64_t)&v62);
      if (v64)
      {
        unsigned int v19 = 0;
        uint64_t v20 = (_DWORD *)(v63 + 16 * v64);
        uint64_t v21 = v13 + 2200;
        uint64_t v22 = (_DWORD *)(v63 + 8);
        do
        {
          int32x2_t v23 = v22 - 2;
          unsigned int v24 = v19 + 1;
          *(_DWORD *)(v21 + 4 * v19) = *(v22 - 2);
          if (v22[1] == 1)
          {
            *(_DWORD *)(v21 + 4 * v24) = *(v22 - 1);
            unsigned int v24 = v19 + 3;
            *(_DWORD *)(v21 + 4 * (v19 + 2)) = *v22;
          }
          v22 += 4;
          unsigned int v19 = v24;
        }
        while (v23 + 4 != v20);
      }
      else
      {
        unsigned int v24 = 0;
      }
      if (v66)
      {
        float v47 = (_DWORD *)(v65 + 16 * v66);
        uint64_t v48 = v13 + 2200;
        uint64_t v49 = (_DWORD *)(v65 + 8);
        do
        {
          float v50 = v49 - 2;
          unsigned int v51 = v24 + 1;
          *(_DWORD *)(v48 + 4 * v24) = *(v49 - 2);
          if (v49[1] == 1)
          {
            *(_DWORD *)(v48 + 4 * v51) = *(v49 - 1);
            unsigned int v51 = v24 + 3;
            *(_DWORD *)(v48 + 4 * (v24 + 2)) = *v49;
          }
          v49 += 4;
          unsigned int v24 = v51;
        }
        while (v50 + 4 != v47);
      }
      else
      {
        unsigned int v51 = v24;
      }
      if (v68)
      {
        uint64_t v52 = (_DWORD *)(v67 + 16 * v68);
        uint64_t v53 = v13 + 2200;
        size_t v54 = (_DWORD *)(v67 + 8);
        do
        {
          v55 = v54 - 2;
          unsigned int v56 = v51 + 1;
          *(_DWORD *)(v53 + 4 * v51) = *(v54 - 2);
          if (v54[1] == 1)
          {
            *(_DWORD *)(v53 + 4 * v56) = *(v54 - 1);
            unsigned int v56 = v51 + 3;
            *(_DWORD *)(v53 + 4 * (v51 + 2)) = *v54;
          }
          v54 += 4;
          unsigned int v51 = v56;
        }
        while (v55 + 4 != v52);
      }
      else
      {
        unsigned int v56 = v51;
      }
      uint64_t v33 = (int *)(v13 + 2200);
      *(_DWORD *)(v13 + 2200 + 4 * v56) = v62;
      double v39 = (int *)(v13 + 2348);
      goto LABEL_50;
    case 23778:
      if (!*(void *)(v5 + 528)) {
        return 4294956429;
      }
      uint64_t v26 = (int *)&kFilterParametersFourCCs;
      BOOL v27 = (int *)&mStatisticsFourCCs;
      goto LABEL_24;
    case 23779:
      uint64_t v28 = *(void *)(v5 + 528);
      if (!v28) {
        return 4294956429;
      }
      float v29 = *(double *)(v28 + 760);
      *(float *)(v5 + 2348) = v29;
      unint64_t v30 = *(void *)(v28 + 752);
      float v31 = 0.0;
      float v32 = 0.0;
      if (v30 >= 2) {
        float v32 = *(double *)(v28 + 768) / (double)(v30 - 1);
      }
      uint64_t v33 = (int *)(v5 + 2348);
      *(float *)(v13 + 2352) = v32;
      float v34 = *(double *)(v28 + 800);
      *(float *)(v13 + 2356) = v34;
      unint64_t v35 = *(void *)(v28 + 792);
      if (v35 >= 2) {
        float v31 = *(double *)(v28 + 808) / (double)(v35 - 1);
      }
      *(float *)(v13 + 2360) = v31;
      float v36 = *(double *)(v28 + 840);
      *(float *)(v13 + 2364) = v36;
      unint64_t v37 = *(void *)(v28 + 832);
      float v38 = 0.0;
      if (v37 >= 2) {
        float v38 = *(double *)(v28 + 848) / (double)(v37 - 1);
      }
      *(float *)(v13 + 2368) = v38;
      *(float *)(v13 + 2372) = (float)v30;
      double v39 = (int *)(v13 + 2376);
LABEL_50:
      CFArrayRef CFArray = applesauce::CF::details::make_CFArrayRef<float,float *>(v33, v39);
      goto LABEL_51;
    case 23780:
      if (!*(void *)(v5 + 528)) {
        return 4294956429;
      }
      uint64_t v26 = (int *)&mStatisticsFourCCs;
      BOOL v27 = (int *)&AUAmbienceLeveler::SupportedNumChannels(AUChannelInfo const**)::sChannels;
LABEL_24:
      CFArrayRef CFArray = applesauce::CF::details::make_CFArrayRef<unsigned int,unsigned int const*>(v26, v27);
      goto LABEL_51;
    case 23781:
      if (!*(void *)(v5 + 528)) {
        return 4294956429;
      }
      std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)(v5 + 18768), (char *)(v5 + 10572), v5 + 18768, 0x801uLL);
      double v41 = (char *)(v13 + 18768);
      goto LABEL_32;
    case 23782:
      uint64_t v42 = *(void *)(v5 + 528);
      if (!v42) {
        return 4294956429;
      }
      (*(void (**)(uint64_t, unsigned char *, uint64_t, __n128))(*(void *)v42 + 184))(v42, v58, 6156, v11);
      unsigned int v43 = (char *)(v13 + 18792);
      int v44 = v59;
      uint64_t v45 = 8232;
      goto LABEL_31;
    case 23783:
      uint64_t v46 = *(void *)(v5 + 528);
      if (!v46) {
        return 4294956429;
      }
      (*(void (**)(uint64_t, unsigned char *, uint64_t, __n128))(*(void *)v46 + 184))(v46, v58, 6156, v11);
      unsigned int v43 = (char *)(v13 + 18816);
      int v44 = v60;
      uint64_t v45 = 16428;
LABEL_31:
      std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>(v43, v44, (uint64_t)&v58[v45], 0x801uLL);
      double v41 = v43;
LABEL_32:
      CFArrayRef CFArray = applesauce::CF::details::make_CFArrayRef<float>(v41);
LABEL_51:
      CFArrayRef v57 = CFArray;
      uint64_t result = 0;
      CFDictionaryRef *v12 = v57;
      return result;
    default:
      return AUDspLib::GetProperty((AUDspLib *)v5, v6, v7, v8, v9, v10);
  }
}

CFArrayRef applesauce::CF::details::make_CFArrayRef<unsigned int,unsigned int const*>(int *a1, int *a2)
{
  int v3 = a1;
  unsigned int v7 = 0;
  unsigned int v8 = 0;
  unint64_t v9 = 0;
  std::vector<applesauce::CF::NumberRef>::reserve((char **)&v7, a2 - a1);
  if (v3 != a2)
  {
    uint64_t v4 = v8;
    do
    {
      if ((unint64_t)v4 >= v9) {
        uint64_t v4 = (CFNumberRef *)std::vector<applesauce::CF::NumberRef>::__emplace_back_slow_path<unsigned int const&>((uint64_t *)&v7, v3);
      }
      else {
        std::construct_at[abi:ne180100]<applesauce::CF::NumberRef,unsigned int const&,applesauce::CF::NumberRef*>(v4++, *v3);
      }
      unsigned int v8 = v4;
      ++v3;
    }
    while (v3 != a2);
  }
  CFArrayRef v5 = applesauce::CF::details::make_CFArrayRef<applesauce::CF::NumberRef>(&v7);
  double v10 = (void **)&v7;
  std::vector<applesauce::CF::NumberRef>::__destroy_vector::operator()[abi:ne180100](&v10);
  return v5;
}

void sub_1BB346B54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<applesauce::CF::NumberRef>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

CFNumberRef *std::construct_at[abi:ne180100]<applesauce::CF::NumberRef,unsigned int const&,applesauce::CF::NumberRef*>(CFNumberRef *a1, int a2)
{
  int valuePtr = a2;
  CFNumberRef v3 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  *a1 = v3;
  if (!v3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1BB346C0C(_Unwind_Exception *exception_object)
{
  if (*v1) {
    CFRelease(*v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<applesauce::CF::NumberRef>::__emplace_back_slow_path<unsigned int const&>(uint64_t *a1, int *a2)
{
  CFNumberRef v3 = (void *)*a1;
  uint64_t v4 = (a1[1] - *a1) >> 3;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 61) {
    std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  uint64_t v8 = a1[2] - (void)v3;
  if (v8 >> 2 > v5) {
    unint64_t v5 = v8 >> 2;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v9 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v22 = a1 + 2;
  if (v9) {
    double v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<unsigned int,float>>>(v7, v9);
  }
  else {
    double v10 = 0;
  }
  unsigned int v19 = v10;
  v20.i64[0] = (uint64_t)&v10[8 * v4];
  v20.i64[1] = v20.i64[0];
  uint64_t v21 = &v10[8 * v9];
  std::construct_at[abi:ne180100]<applesauce::CF::NumberRef,unsigned int const&,applesauce::CF::NumberRef*>((CFNumberRef *)v20.i64[0], *a2);
  uint64_t v11 = v20.i64[0];
  uint64_t v12 = v20.i64[0] + 8;
  v20.i64[1] = v20.i64[0] + 8;
  uint64_t v14 = (void *)*a1;
  uint64_t v13 = (void *)a1[1];
  if (v13 == (void *)*a1)
  {
    int64x2_t v16 = vdupq_n_s64((unint64_t)v13);
  }
  else
  {
    do
    {
      uint64_t v15 = *--v13;
      *(void *)(v11 - 8) = v15;
      v11 -= 8;
      *uint64_t v13 = 0;
    }
    while (v13 != v14);
    int64x2_t v16 = *(int64x2_t *)a1;
    uint64_t v12 = v20.i64[1];
  }
  *a1 = v11;
  a1[1] = v12;
  int64x2_t v20 = v16;
  uint64_t v17 = (char *)a1[2];
  a1[2] = (uint64_t)v21;
  uint64_t v21 = v17;
  unsigned int v19 = (char *)v16.i64[0];
  std::__split_buffer<applesauce::CF::NumberRef>::~__split_buffer((uint64_t)&v19);
  return v12;
}

void sub_1BB346D48(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<applesauce::CF::NumberRef>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t AUAmbienceLeveler::GetPropertyInfo(AUAmbienceLeveler *this, int a2, unsigned int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  if ((a2 - 23777) > 6) {
    return AUDspLib::GetPropertyInfo(this, a2, a3, a4, a5, a6);
  }
  *a6 = 0;
  *a5 = 8;
  return 0;
}

uint64_t AUAmbienceLeveler::Initialize(AUAmbienceLeveler *this)
{
  int v2 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUAmbienceLeveler *)((char *)this + 80), 0) + 108);
  if (v2 != 2 && v2 != *((unsigned __int16 *)this + 900)) {
    return 4294956428;
  }
  uint64_t result = AUDspLib::Initialize(this);
  if (!result)
  {
    double v4 = (*(double (**)(void))(**((void **)this + 66) + 40))(*((void *)this + 66));
    unint64_t v5 = 0;
    double v6 = v4 * 0.000244140625;
    uint64x2_t v7 = (uint64x2_t)vdupq_n_s64(0x801uLL);
    do
    {
      uint64x2_t v8 = (uint64x2_t)vorrq_s8((int8x16_t)vdupq_n_s64(v5), (int8x16_t)xmmword_1BB872720);
      if (vmovn_s64((int64x2_t)vcgtq_u64(v7, v8)).u8[0])
      {
        float v9 = v6 * (double)v5;
        *((float *)this + v5 + 594) = v9;
      }
      if (vmovn_s64((int64x2_t)vcgtq_u64((uint64x2_t)vdupq_n_s64(0x801uLL), v8)).i32[1])
      {
        float v10 = v6 * (double)(v5 + 1);
        *((float *)this + v5 + 595) = v10;
      }
      v5 += 2;
    }
    while (v5 != 2050);
    DspLib::clear((float *)this + 2643, 0x801uLL);
    std::vector<DspLib::AmbienceLeveler::FilterParameters>::resize((char **)this + 2356, 5uLL);
    std::vector<DspLib::AmbienceLeveler::FilterParameters>::resize((char **)this + 2359, 4uLL);
    std::vector<DspLib::AmbienceLeveler::FilterParameters>::resize((char **)this + 2362, 5uLL);
    return 0;
  }
  return result;
}

void std::vector<DspLib::AmbienceLeveler::FilterParameters>::resize(char **a1, unint64_t a2)
{
  double v4 = *a1;
  unint64_t v5 = a1[1];
  unint64_t v6 = (v5 - *a1) >> 4;
  if (a2 <= v6)
  {
    if (a2 >= v6) {
      return;
    }
    int64x2_t v16 = &v4[16 * a2];
    goto LABEL_23;
  }
  uint64x2_t v7 = a1[2];
  if (a2 - v6 <= (v7 - v5) >> 4)
  {
    int64x2_t v16 = &v5[16 * (a2 - v6)];
    do
    {
      *(void *)unint64_t v5 = 1120403456;
      *((void *)v5 + 1) = 0x13F800000;
      v5 += 16;
    }
    while (v5 != v16);
LABEL_23:
    a1[1] = v16;
    return;
  }
  if (a2 >> 60) {
    std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v8 = v7 - v4;
  uint64_t v9 = v8 >> 3;
  if (v8 >> 3 <= a2) {
    uint64_t v9 = a2;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v10 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v10 = v9;
  }
  if (v10 >> 60) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  uint64_t v11 = (char *)operator new(16 * v10);
  uint64_t v12 = &v11[16 * v6];
  uint64_t v13 = &v11[16 * a2];
  uint64_t v14 = v12;
  do
  {
    *(void *)uint64_t v14 = 1120403456;
    *((void *)v14 + 1) = 0x13F800000;
    v14 += 16;
  }
  while (v14 != v13);
  uint64_t v15 = *a1;
  if (v5 != *a1)
  {
    do
    {
      *((_OWORD *)v12 - 1) = *((_OWORD *)v5 - 1);
      v12 -= 16;
      v5 -= 16;
    }
    while (v5 != v15);
    unint64_t v5 = *a1;
  }
  *a1 = v12;
  a1[1] = v13;
  a1[2] = &v11[16 * v10];
  if (v5)
  {
    operator delete(v5);
  }
}

void AUAmbienceLeveler::~AUAmbienceLeveler(AUAmbienceLeveler *this)
{
  AUAmbienceLeveler::~AUAmbienceLeveler(this);

  JUMPOUT(0x1C185D370);
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  uint64_t vars8;

  *(void *)this = &unk_1F14AA600;
  int v2 = (void *)*((void *)this + 2362);
  if (v2)
  {
    *((void *)this + 2363) = v2;
    operator delete(v2);
  }
  CFNumberRef v3 = (void *)*((void *)this + 2359);
  if (v3)
  {
    *((void *)this + 2360) = v3;
    operator delete(v3);
  }
  double v4 = (void *)*((void *)this + 2356);
  if (v4)
  {
    *((void *)this + 2357) = v4;
    operator delete(v4);
  }
  unint64_t v5 = (void *)*((void *)this + 2352);
  if (v5)
  {
    *((void *)this + 2353) = v5;
    operator delete(v5);
  }
  unint64_t v6 = (void *)*((void *)this + 2349);
  if (v6)
  {
    *((void *)this + 2350) = v6;
    operator delete(v6);
  }
  uint64x2_t v7 = (void *)*((void *)this + 2346);
  if (v7)
  {
    *((void *)this + 2347) = v7;
    operator delete(v7);
  }

  AUDspLib::~AUDspLib(this);
}

uint64_t AUResidualEchoSuppressorV5::SetBypassEffect(uint64_t this, char a2)
{
  *(unsigned char *)(this + 528) = a2;
  return this;
}

uint64_t AUResidualEchoSuppressorV5::ShouldBypassEffect(AUResidualEchoSuppressorV5 *this)
{
  return *((unsigned __int8 *)this + 528);
}

uint64_t AUResidualEchoSuppressorV5::ChangeStreamFormat(AUResidualEchoSuppressorV5 *this, uint64_t a2, uint64_t a3, const AudioStreamBasicDescription *a4, const AudioStreamBasicDescription *a5)
{
  unsigned int v6 = a3;
  int v7 = a2;
  ausdk::AUBase::ChangeStreamFormat(this, a2, a3, a4, a5);
  if (v7 == 2 && v6 <= 1)
  {
    AudioFormatID mFormatID = a5->mFormatID;
    unint64_t v10 = (BOOL *)this + v6 + 546;
    goto LABEL_8;
  }
  if (v7 == 1 && v6 <= 5 && ((1 << v6) & 0x27) != 0)
  {
    AudioFormatID mFormatID = a5->mFormatID;
    unint64_t v10 = (BOOL *)this + v6 + 540;
LABEL_8:
    *unint64_t v10 = mFormatID == 1718773105;
  }
  return 0;
}

BOOL AUResidualEchoSuppressorV5::ValidFormat(AUResidualEchoSuppressorV5 *this, const AudioStreamBasicDescription *a2, unsigned int a3, AudioStreamBasicDescription *a4)
{
  if (a4->mChannelsPerFrame != 1) {
    return 0;
  }
  int v6 = (int)a2;
  BOOL result = ausdk::ASBD::IsCommonFloat32((ausdk::ASBD *)a4, a2);
  if (v6 == 1)
  {
    char v14 = a4->mFormatID != 1718773105 || result;
    if ((v14 & 1) == 0)
    {
      BOOL result = 0;
      if (a3 <= 5 && ((1 << a3) & 0x27) != 0)
      {
        if (a4->mFramesPerPacket == 1)
        {
          BOOL v15 = 0;
          int v16 = 0;
          UInt32 mBytesPerPacket = a4->mBytesPerPacket;
          UInt32 mBytesPerFrame = a4->mBytesPerFrame;
          if (mBytesPerFrame == mBytesPerPacket)
          {
            AudioFormatFlags mFormatFlags = a4->mFormatFlags;
            UInt32 mBitsPerChannel = a4->mBitsPerChannel;
            UInt32 v21 = mBitsPerChannel >> 3;
            int v22 = 8 * mBytesPerPacket;
            BOOL v23 = mBytesPerPacket == 8 && (a4->mFormatFlags & 0x1F84) == 0;
            if (mFormatFlags)
            {
              BOOL v24 = (a4->mFormatFlags & 0x1F84) == 0;
            }
            else
            {
              BOOL v23 = 0;
              BOOL v24 = 1;
            }
            if (v22 == mBitsPerChannel)
            {
              int v25 = v24;
            }
            else
            {
              BOOL v23 = 0;
              int v25 = 1;
            }
            BOOL v15 = (mFormatFlags & 2) == 0 && v23;
            if ((a4->mFormatFlags & 2) != 0) {
              int v26 = 1;
            }
            else {
              int v26 = v25;
            }
            if (v21 <= mBytesPerFrame)
            {
              int v16 = v26;
            }
            else
            {
              BOOL v15 = 0;
              int v16 = 0;
            }
          }
        }
        else
        {
          BOOL v15 = 0;
          int v16 = 0;
        }
        return v15 & v16;
      }
    }
  }
  else if (v6 == 2 && a3 <= 1 && !result && a4->mFormatID == 1718773105)
  {
    BOOL v8 = 0;
    if (a4->mFramesPerPacket == 1 && (v9 = a4->mBytesPerPacket, UInt32 v10 = a4->mBytesPerFrame, v10 == v9))
    {
      UInt32 v11 = a4->mBitsPerChannel;
      BOOL v12 = 0;
      if (v11 >> 3 <= v10)
      {
        BOOL v8 = 0;
        AudioFormatFlags v13 = a4->mFormatFlags;
        BOOL v12 = 1;
        if (v13 & 2) == 0 && 8 * v9 == v11 && (v13)
        {
          BOOL v12 = (a4->mFormatFlags & 0x1F84) == 0;
          BOOL v8 = v9 == 8 && (a4->mFormatFlags & 0x1F84) == 0;
        }
      }
    }
    else
    {
      BOOL v12 = 0;
    }
    return v8 && v12;
  }
  return result;
}

uint64_t AUResidualEchoSuppressorV5::SupportedNumChannels(AUResidualEchoSuppressorV5 *this, const AUChannelInfo **a2)
{
  if (a2) {
    *a2 = (const AUChannelInfo *)&AUResidualEchoSuppressorV5::SupportedNumChannels(AUChannelInfo const**)::sSupportedChannelConfigs;
  }
  return 1;
}

BOOL AUResidualEchoSuppressorV5::StreamFormatWritable(AUResidualEchoSuppressorV5 *this)
{
  return *((unsigned char *)this + 17) == 0;
}

uint64_t AUResidualEchoSuppressorV5::SupportsTail(AUResidualEchoSuppressorV5 *this)
{
  return 1;
}

double AUResidualEchoSuppressorV5::GetTailTime(AUResidualEchoSuppressorV5 *this)
{
  return 0.0;
}

double AUResidualEchoSuppressorV5::GetLatency(AUResidualEchoSuppressorV5 *this)
{
  return 0.0;
}

uint64_t AUResidualEchoSuppressorV5::GetParameterValueStrings(AUResidualEchoSuppressorV5 *this, int a2, int a3, const __CFArray **a4)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (!a4) {
    return 0;
  }
  if (a2) {
    return 4294956430;
  }
  if (a3 == 48)
  {
    int v6 = &xmmword_1E623C088;
  }
  else
  {
    if (a3 != 43)
    {
      *(void *)&long long v9 = @"Parameter Name Unimplemented";
      CFIndex v7 = 1;
      goto LABEL_11;
    }
    int v6 = &xmmword_1E623C070;
  }
  long long v9 = *v6;
  uint64_t v10 = *((void *)v6 + 2);
  CFIndex v7 = 3;
LABEL_11:
  CFArrayRef v8 = CFArrayCreate(0, (const void **)&v9, v7, 0);
  uint64_t result = 0;
  *a4 = v8;
  return result;
}

uint64_t AUResidualEchoSuppressorV5::GetParameterInfo(AUResidualEchoSuppressorV5 *this, int a2, unsigned int a3, AudioUnitParameterInfo *buffer)
{
  buffer->unitName = 0;
  buffer->flags = 0x40000000;
  uint64_t result = 4294956418;
  if (!a2 && a3 <= 0x31)
  {
    CFStringRef v6 = off_1E623C0A0[a3];
    AudioUnitParameterUnit v7 = dword_1BB87D460[a3];
    AudioUnitParameterValue v8 = flt_1BB87D528[a3];
    AudioUnitParameterValue v9 = flt_1BB87D5F0[a3];
    AudioUnitParameterValue v10 = flt_1BB87D6B8[a3];
    int v11 = dword_1BB87D780[a3];
    buffer->cfNameString = v6;
    buffer->flags = 1207959552;
    CFStringGetCString(v6, buffer->name, 52, 0x8000100u);
    uint64_t result = 0;
    buffer->unit = v7;
    buffer->minValue = v8;
    buffer->maxValue = v9;
    buffer->defaultValue = v10;
    buffer->flags |= v11;
  }
  return result;
}

BOOL AUResidualEchoSuppressorV5::BusCountWritable(AUResidualEchoSuppressorV5 *this, int a2)
{
  return (a2 - 1) < 2;
}

uint64_t AUResidualEchoSuppressorV5::Render(AUResidualEchoSuppressorV5 *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  v45[6] = *MEMORY[0x1E4F143B8];
  if (*((_DWORD *)this + 84) != a4) {
    return 4294956422;
  }
  AudioUnitParameterValue v8 = (AUResidualEchoSuppressorV5 *)((char *)this + 80);
  uint64_t Element = ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 0);
  if (!Element || !*(_DWORD *)(Element + 172)) {
    return 4294956420;
  }
  uint64_t v10 = ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 128), 0);
  int v11 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement(v8, 0);
  uint64_t v12 = ausdk::AUInputElement::PullInput(v11, a2, a3, 0, a4);
  if (!v12)
  {
    uint64_t v13 = ausdk::AUScope::GetElement(v8, 1u);
    if (v13 && *(_DWORD *)(v13 + 172))
    {
      char v14 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement(v8, 1u);
      uint64_t v12 = ausdk::AUInputElement::PullInput(v14, a2, a3, 1, a4);
      uint64_t v15 = ausdk::AUScope::SafeGetElement(v8, 1u);
      uint64_t BufferList = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v15 + 144));
      if (v12) {
        return v12;
      }
    }
    else
    {
      uint64_t v17 = ausdk::AUScope::SafeGetElement(v8, 0);
      uint64_t BufferList = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v17 + 144));
    }
    uint64_t v18 = ausdk::AUScope::GetElement(v8, 2u);
    if (v18 && *(_DWORD *)(v18 + 172))
    {
      unsigned int v19 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement(v8, 2u);
      uint64_t v12 = ausdk::AUInputElement::PullInput(v19, a2, a3, 2, a4);
      uint64_t v20 = ausdk::AUScope::SafeGetElement(v8, 2u);
      uint64_t v21 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v20 + 144));
      if (v12) {
        return v12;
      }
    }
    else
    {
      uint64_t v22 = ausdk::AUScope::SafeGetElement(v8, 0);
      uint64_t v21 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v22 + 144));
    }
    uint64_t v23 = v21;
    uint64_t v24 = ausdk::AUScope::GetElement(v8, 3u);
    if (v24 && *(_DWORD *)(v24 + 172))
    {
      int v25 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement(v8, 3u);
      uint64_t v12 = ausdk::AUInputElement::PullInput(v25, a2, a3, 3, a4);
      uint64_t v26 = ausdk::AUScope::SafeGetElement(v8, 3u);
      uint64_t v27 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v26 + 144));
      if (v12) {
        return v12;
      }
    }
    else
    {
      uint64_t v28 = ausdk::AUScope::SafeGetElement(v8, 0);
      uint64_t v27 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v28 + 144));
    }
    uint64_t v29 = v27;
    uint64_t v30 = ausdk::AUScope::GetElement(v8, 4u);
    if (v30 && *(_DWORD *)(v30 + 172))
    {
      float v31 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement(v8, 4u);
      uint64_t v12 = ausdk::AUInputElement::PullInput(v31, a2, a3, 4, a4);
      uint64_t v32 = ausdk::AUScope::SafeGetElement(v8, 4u);
      uint64_t v33 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v32 + 144));
      if (v12) {
        return v12;
      }
    }
    else
    {
      uint64_t v34 = ausdk::AUScope::SafeGetElement(v8, 0);
      uint64_t v33 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v34 + 144));
    }
    uint64_t v35 = v33;
    uint64_t v36 = ausdk::AUScope::GetElement(v8, 5u);
    if (!v36 || !*(_DWORD *)(v36 + 172))
    {
      uint64_t v40 = ausdk::AUScope::SafeGetElement(v8, 0);
      uint64_t v39 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v40 + 144));
LABEL_33:
      uint64_t v41 = v39;
      uint64_t v42 = ausdk::AUScope::SafeGetElement(v8, 0);
      v45[0] = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v42 + 144));
      v45[1] = BufferList;
      v45[2] = v23;
      v45[3] = v29;
      v45[4] = v35;
      v45[5] = v41;
      uint64_t v44 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v10 + 144));
      return (*(uint64_t (**)(AUResidualEchoSuppressorV5 *, unsigned int *, uint64_t, uint64_t, void *, uint64_t, uint64_t *))(*(void *)this + 184))(this, a2, a4, 6, v45, 1, &v44);
    }
    unint64_t v37 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement(v8, 5u);
    uint64_t v12 = ausdk::AUInputElement::PullInput(v37, a2, a3, 5, a4);
    uint64_t v38 = ausdk::AUScope::SafeGetElement(v8, 5u);
    uint64_t v39 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v38 + 144));
    if (!v12) {
      goto LABEL_33;
    }
  }
  return v12;
}

uint64_t AUResidualEchoSuppressorV5::ProcessMultipleBufferLists(AUResidualEchoSuppressorV5 *this, unsigned int *a2, int a3, unsigned int a4, const AudioBufferList **a5, unsigned int a6, AudioBufferList **a7)
{
  uint64_t v206 = *MEMORY[0x1E4F143B8];
  if (*((_DWORD *)this + 84) != a3) {
    return 4294956422;
  }
  if ((*(unsigned int (**)(AUResidualEchoSuppressorV5 *, unsigned int *))(*(void *)this + 576))(this, a2))
  {
    unsigned int v10 = *((_DWORD *)this + 142);
    if (v10 >= 3)
    {
      int v11 = a7[2];
      unsigned int mDataByteSize = v11->mBuffers[0].mDataByteSize;
      if (mDataByteSize >= 4) {
        memset_pattern16(v11->mBuffers[0].mData, &unk_1BB873A60, mDataByteSize & 0xFFFFFFFC);
      }
      if (v10 >= 4) {
        vDSP_vclr((float *)a7[3]->mBuffers[0].mData, 1, *((unsigned int *)this + 138));
      }
    }
    if (*((unsigned __int8 *)this + 540) == *((unsigned __int8 *)this + 546))
    {
      memcpy((*a7)->mBuffers[0].mData, (*a5)->mBuffers[0].mData, (*a7)->mBuffers[0].mDataByteSize);
      if (*((_DWORD *)this + 142) >= 2u)
      {
        uint64_t v13 = a7[1];
        if (v13)
        {
          mData = v13->mBuffers[0].mData;
          if (mData) {
            memcpy(mData, a5[1]->mBuffers[0].mData, v13->mBuffers[0].mDataByteSize);
          }
        }
      }
    }
    else
    {
      bzero((*a7)->mBuffers[0].mData, (*a7)->mBuffers[0].mDataByteSize);
    }
    return 0;
  }
  int v16 = *((_DWORD *)this + 133);
  int v17 = *((_DWORD *)this + 134);
  v199 = a7;
  v200 = a5;
  if (v16 != v17)
  {
    uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    *(float *)&uint64_t v19 = ausdk::AUElement::GetParameter(Element, 1u);
    uint64_t v195 = v19;
    uint64_t v20 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    *(float *)&uint64_t v21 = ausdk::AUElement::GetParameter(v20, 2u);
    uint64_t v194 = v21;
    uint64_t v22 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    unsigned int Parameter = ausdk::AUElement::GetParameter(v22, 8u);
    uint64_t v24 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    unsigned int v25 = ausdk::AUElement::GetParameter(v24, 9u);
    uint64_t v26 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    float v27 = ausdk::AUElement::GetParameter(v26, 0xAu);
    uint64_t v28 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    float v29 = ausdk::AUElement::GetParameter(v28, 0xBu);
    uint64_t v30 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    float v31 = ausdk::AUElement::GetParameter(v30, 0xCu);
    uint64_t v32 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    LODWORD(v198) = ausdk::AUElement::GetParameter(v32, 0xDu);
    uint64_t v33 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    LODWORD(v197) = ausdk::AUElement::GetParameter(v33, 0xEu);
    uint64_t v34 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    LODWORD(v196) = ausdk::AUElement::GetParameter(v34, 0xFu);
    uint64_t v35 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    float v36 = ausdk::AUElement::GetParameter(v35, 0x10u);
    unint64_t v37 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    float v38 = ausdk::AUElement::GetParameter(v37, 0x11u);
    uint64_t v39 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    float v40 = ausdk::AUElement::GetParameter(v39, 0x12u);
    uint64_t v41 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    float v42 = ausdk::AUElement::GetParameter(v41, 0x13u);
    unsigned int v43 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    float v193 = ausdk::AUElement::GetParameter(v43, 0x14u);
    uint64_t v44 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    unsigned int v45 = ausdk::AUElement::GetParameter(v44, 0x15u);
    uint64_t v46 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    float v192 = ausdk::AUElement::GetParameter(v46, 0x16u);
    float v47 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    float v191 = ausdk::AUElement::GetParameter(v47, 0x17u);
    uint64_t v48 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    unsigned int v49 = ausdk::AUElement::GetParameter(v48, 0x18u);
    if (*((_DWORD *)this + 141) >= 4u) {
      unsigned int v50 = v49;
    }
    else {
      unsigned int v50 = 0;
    }
    unsigned int v51 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    unsigned int v52 = ausdk::AUElement::GetParameter(v51, 0x19u);
    uint64_t v53 = *((void *)this + 72);
    *(int32x2_t *)(v53 + 36) = vneg_s32(vabs_s32(vcvt_s32_f32((float32x2_t)__PAIR64__(v194, v195))));
    *(_DWORD *)(v53 + 44) = Parameter;
    size_t v54 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    LODWORD(v195) = ausdk::AUElement::GetParameter(v54, 0x1Au);
    v55 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    LODWORD(v194) = ausdk::AUElement::GetParameter(v55, 0x1Bu);
    unsigned int v56 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    float v190 = ausdk::AUElement::GetParameter(v56, 0x1Cu);
    CFArrayRef v57 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    int v58 = (int)ausdk::AUElement::GetParameter(v57, 0x1Eu);
    v59 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    int v60 = (int)ausdk::AUElement::GetParameter(v59, 0x1Du);
    float v61 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    float v189 = ausdk::AUElement::GetParameter(v61, 0x1Fu);
    float v62 = __exp10f(v27 / 10.0);
    float v63 = __exp10f(v29 / 10.0);
    float v64 = __exp10f(v31 / 10.0);
    float v65 = __exp10f(v36 / 10.0);
    float v66 = __exp10f(v38 / 10.0);
    float v67 = __exp10f(v40 / 10.0);
    float v68 = __exp10f(v42 / 10.0);
    float v69 = __exp10f(v193 / 10.0);
    uint64_t v70 = *((void *)this + 72);
    *(_DWORD *)(v70 + 496) = v25;
    *(float *)(v70 + 500) = v62;
    *(float *)(v70 + 504) = v63;
    *(float *)(v70 + 508) = v64;
    *(_DWORD *)(v70 + 556) = v198;
    *(_DWORD *)(v70 + 512) = v197;
    *(_DWORD *)(v70 + 516) = v196;
    *(float *)(v70 + 520) = v65;
    *(float *)(v70 + 524) = v66;
    *(float *)(v70 + 528) = v67;
    *(float *)(v70 + 532) = v68;
    *(float *)(v70 + 536) = v69;
    *(_DWORD *)(v70 + 540) = v45;
    *(float *)(v70 + 548) = v192;
    *(float *)(v70 + 552) = v191;
    *(_DWORD *)(v70 + 572) = v50;
    *(_DWORD *)(v70 + 576) = v52;
    unsigned int v71 = (float)*(int *)(v70 + 8);
    float v72 = (float)*(int *)(v70 + 12) * 0.5;
    float v73 = v72 / (float)v71;
    float v74 = fmaxf(*(float *)&v195, 300.0);
    if (v74 < v72) {
      float v72 = v74;
    }
    unsigned int v75 = vcvtms_u32_f32(v72 / v73);
    if (v75 < v71) {
      unsigned int v71 = v75;
    }
    *(_DWORD *)(v70 + 664) = v71;
    *(_DWORD *)(v70 + 668) = v194;
    *(float *)(v70 + 672) = v190;
    *(_DWORD *)uint64_t v70 = v60;
    if (v58 < 0) {
      int v76 = v58;
    }
    else {
      int v76 = -v58;
    }
    *(_DWORD *)(v70 + 32) = v76;
    float v77 = __exp10f((float)v76 * 0.1);
    *(float *)(v70 + 56) = v77;
    *(float *)(v70 + 60) = sqrtf(v77);
    uint64_t v78 = *((void *)this + 72);
    float v79 = v189;
    *(float *)(v78 + 48) = v189;
    *(float *)(v78 + 52) = __exp10f(v79 * 0.1);
    BOOL v80 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    *(float *)(*((void *)this + 72) + 688) = ausdk::AUElement::GetParameter(v80, 0x21u);
    char v81 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    float v82 = ausdk::AUElement::GetParameter(v81, 0x22u);
    uint64_t v83 = *((void *)this + 72);
    *(float *)(v83 + 680) = 1.0
                          - expf(-1.0 / (float)(v82 * (float)((float)*(int *)(v83 + 12) / (float)*(int *)(v83 + 8))));
    uint64_t v84 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    int v85 = (int)ausdk::AUElement::GetParameter(v84, 0x24u);
    if (*((_DWORD *)this + 141) < 5u) {
      int v85 = 0;
    }
    *(_DWORD *)(*((void *)this + 73) + 8) = v85;
    uint64_t v86 = (_DWORD *)*((void *)this + 72);
    if (!*v86) {
      v86[169] = 0;
    }
    v87 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    BOOL v89 = ausdk::AUElement::GetParameter(v87, 0x25u) != 0.0 && *((_DWORD *)this + 141) > 5u;
    *((unsigned char *)this + 616) = v89;
    v90 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    *((unsigned char *)this + 618) = ausdk::AUElement::GetParameter(v90, 0x26u) != 0.0;
    uint64_t v91 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    *((_DWORD *)this + 155) = (int)ausdk::AUElement::GetParameter(v91, 0x27u);
    uint64_t v92 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    *((float *)this + 156) = ausdk::AUElement::GetParameter(v92, 0x28u);
    v93 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    unsigned int v94 = ausdk::AUElement::GetParameter(v93, 0x2Bu);
    if (v94 >= 2) {
      unsigned int v94 = 2;
    }
    *((_DWORD *)this + 157) = v94;
    v95 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    *((_DWORD *)this + 140) = ausdk::AUElement::GetParameter(v95, 8u);
    uint64_t v96 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    *((unsigned char *)this + 640) = ausdk::AUElement::GetParameter(v96, 0x2Cu) != 0.0;
    uint64_t v97 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    *((float *)this + 161) = ausdk::AUElement::GetParameter(v97, 0x2Du);
    int v98 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    *((_DWORD *)this + 162) = (int)ausdk::AUElement::GetParameter(v98, 0x2Eu);
    v99 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    int v100 = (int)ausdk::AUElement::GetParameter(v99, 0x2Fu);
    *((_DWORD *)this + 163) = v100;
    if (*((unsigned char *)this + 616))
    {
      a5 = v200;
      if (v100 == 1) {
        *((_DWORD *)this + 162) = 0;
      }
    }
    else
    {
      int v100 = 0;
      *((unsigned char *)this + 617) = 0;
      *((void *)this + 81) = 0;
      a5 = v200;
    }
    if (*((_DWORD *)this + 157) == 2)
    {
      int v100 = 0;
      *((unsigned char *)this + 617) = 0;
      *((void *)this + 81) = 0;
    }
    *(_DWORD *)(*((void *)this + 76) + 68) = v100;
    uint64_t v101 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    float v102 = ausdk::AUElement::GetParameter(v101, 0x30u);
    *((_DWORD *)this + 173) = v102;
    *(_DWORD *)(*((void *)this + 72) + 228) = v102;
    *((_DWORD *)this + 134) = v16;
  }
  uint64_t v103 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
  int v104 = (int)ausdk::AUElement::GetParameter(v103, 6u);
  v105 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
  float v106 = ausdk::AUElement::GetParameter(v105, 7u);
  v107 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
  float v108 = ausdk::AUElement::GetParameter(v107, 0xDu);
  v109 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
  float v110 = ausdk::AUElement::GetParameter(v109, 0x29u);
  unsigned int v111 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
  float v112 = ausdk::AUElement::GetParameter(v111, 0x2Au);
  int v113 = *((unsigned __int8 *)this + 616);
  if (*((_DWORD *)this + 141) >= 6u) {
    int v114 = *((unsigned __int8 *)this + 616);
  }
  else {
    int v114 = 0;
  }
  *((unsigned char *)this + 617) = v114;
  if (v113 && *((unsigned char *)this + 618))
  {
    uint64_t v115 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    float v116 = ausdk::AUElement::GetParameter(v115, 0x27u);
    *((_DWORD *)this + 155) = (int)v116;
    if ((int)v116 != 1)
    {
LABEL_56:
      *((unsigned char *)this + 617) = 0;
      goto LABEL_57;
    }
    *((unsigned char *)this + 617) = 1;
  }
  else if (!v114)
  {
    goto LABEL_57;
  }
  if (*((_DWORD *)this + 162) == 1 && (float)(v112 - v110) < *((float *)this + 156)) {
    goto LABEL_56;
  }
LABEL_57:
  AudioUnitParameterValue v117 = (int *)*((void *)this + 72);
  v117[122] = v104;
  *((float *)v117 + 123) = v106;
  *((float *)v117 + 139) = v108;
  if (*((_DWORD *)this + 173))
  {
    unsigned int v118 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    float v119 = ausdk::AUElement::GetParameter(v118, 0x31u);
    float v120 = 0.0;
    if (v119 >= 0.0)
    {
      float v120 = 1.0;
      if (v119 <= 1.0) {
        float v120 = v119;
      }
    }
    *((float *)this + 174) = v120;
    AudioUnitParameterValue v117 = (int *)*((void *)this + 72);
    *((float *)v117 + 58) = v120;
  }
  uint64_t v121 = *((unsigned int *)this + 84);
  if (*v117 >= 3)
  {
    AudioUnitParameterID v122 = 0;
    v123 = 0;
    unsigned int v124 = 0;
    uint64_t v125 = 0;
    v127 = 0;
    v128 = 0;
    goto LABEL_73;
  }
  AudioUnitParameterID v122 = (float *)a5[1]->mBuffers[0].mData;
  v123 = &v122[v121];
  unsigned int v124 = (float *)a5[2]->mBuffers[0].mData;
  uint64_t v125 = &v124[v121];
  if (*((_DWORD *)this + 141) >= 6u && (v126 = a5[5]) != 0)
  {
    v127 = (float *)v126->mBuffers[0].mData;
    v128 = &v127[v121];
    if (*((unsigned char *)this + 616))
    {
      if (*((_DWORD *)this + 163) == 1) {
        *((_DWORD *)this + 162) = 0;
      }
      goto LABEL_71;
    }
  }
  else
  {
    v127 = 0;
    v128 = 0;
    *((unsigned char *)this + 616) = 0;
    *((_DWORD *)this + 157) = 0;
  }
  *((unsigned char *)this + 617) = 0;
  *((void *)this + 81) = 0;
LABEL_71:
  if (*((_DWORD *)this + 157) == 2)
  {
    *((unsigned char *)this + 617) = 0;
    *((void *)this + 81) = 0;
  }
LABEL_73:
  v129 = (float *)(*a5)->mBuffers[0].mData;
  v130 = &v129[v121];
  if (*((_DWORD *)this + 164))
  {
    v131 = v129;
    if (v121 != *((_DWORD *)this + 165))
    {
      v197 = v125;
      v198 = v123;
      LODWORD(__B.realp) = 1023504128;
      memcpy(*((void **)this + 83), v129, 4 * (2 * v121));
      v131 = (float *)*((void *)this + 83);
      v130 = &v131[v121];
      float *v130 = *v130 * 0.0316;
      uint64_t v132 = *((unsigned int *)this + 165);
      if (v132 < v121)
      {
        float v133 = *(float *)&__B.realp;
        if (*(float *)&__B.realp < 0.5) {
          float v133 = 0.5;
        }
        int v134 = v121 - v132;
        while (1)
        {
          v131[v132] = v133 * v131[v132];
          v130[v132] = v133 * v130[v132];
          float v133 = v133 * 0.5;
          if (v133 <= 0.0316) {
            break;
          }
          ++v132;
          if (!--v134) {
            goto LABEL_84;
          }
        }
        vDSP_Length v196 = (v121 - v132);
        char v135 = &v130[v132];
        vDSP_vsmul(&v131[v132], 1, (const float *)&__B, &v131[v132], 1, v196);
        vDSP_vsmul(v135, 1, (const float *)&__B, v135, 1, v196);
      }
LABEL_84:
      v123 = v198;
      uint64_t v125 = v197;
    }
  }
  else
  {
    v131 = v129;
  }
  unsigned int v136 = *((_DWORD *)this + 141);
  if (v136 < 4)
  {
    v138 = 0;
  }
  else
  {
    DSPSplitComplex v137 = v200[3];
    if (v137) {
      v138 = (const float *)v137->mBuffers[0].mData;
    }
    else {
      v138 = 0;
    }
    if (v136 >= 5)
    {
      v139 = v200[4];
      if (v139)
      {
        uint64_t v140 = (uint64_t)v139->mBuffers[0].mData;
        goto LABEL_94;
      }
    }
  }
  uint64_t v140 = 0;
LABEL_94:
  __B.realp = v122;
  __B.imagp = v123;
  v204[0] = v124;
  v204[1] = v125;
  v203.realp = v127;
  v203.imagp = v128;
  v141 = (int *)*((void *)this + 72);
  BOOL v144 = *v141 < 2 && v122 != 0 && v124 != 0;
  if (*v141 <= 1 && !v144)
  {
    unsigned __int8 v146 = 0;
    if (v122)
    {
LABEL_110:
      BOOL v147 = *((unsigned char *)this + 541) != 0;
      goto LABEL_113;
    }
  }
  else
  {
    unsigned __int8 v146 = *((unsigned char *)this + 541);
    if (v146) {
      unsigned __int8 v146 = *((unsigned char *)this + 542) != 0;
    }
    if (v122) {
      goto LABEL_110;
    }
  }
  BOOL v147 = 0;
LABEL_113:
  v148 = v199;
  if (v127) {
    BOOL v150 = v136 > 5 && *((unsigned char *)this + 545) != 0;
  }
  else {
    BOOL v150 = 0;
  }
  BOOL v152 = *((_DWORD *)this + 142) >= 2u
      && (v151 = v199[1]) != 0
      && v151->mBuffers[0].mData
      && *((unsigned char *)this + 547) != 0;
  char v153 = v146 ^ 1;
  if (*((unsigned char *)this + 540) && v131 && ((v146 ^ 1) & 1) == 0)
  {
    v202[0] = v131;
    v202[1] = v130;
    CResidualSuppressorV5::speex_preprocess_run_freq((uint64_t)v141, v202, &__B, v204, v138, *((float **)this + 73), v140, *((unsigned __int8 *)this + 617), &v203, *((void *)this + 74), *((float **)this + 75), *((void *)this + 76), *((unsigned char *)this + 640), *((_DWORD *)this + 157));
    if (!*((unsigned char *)this + 546)) {
      goto LABEL_164;
    }
    uint64_t v154 = *((void *)this + 72);
    v155 = *(const void **)(v154 + 344);
    v156 = *(const void **)(v154 + 352);
    v157 = (char *)(*v199)->mBuffers[0].mData;
    uint64_t v158 = *((unsigned int *)this + 84);
    v159 = &v157[4 * v158];
    memcpy(v157, v155, 4 * v158);
    memcpy(v159, v156, 4 * *((unsigned int *)this + 84));
    if (*((_DWORD *)this + 142) >= 3u) {
      memcpy(v199[2]->mBuffers[0].mData, *(const void **)(*((void *)this + 72) + 112), 4 * *(int *)(*((void *)this + 72) + 8));
    }
    if (!v152) {
      goto LABEL_164;
    }
    v160 = v199[1];
    v161 = (float *)v160->mBuffers[0].mData;
    char v162 = !v150;
    if (!*((unsigned char *)this + 617)) {
      char v162 = 1;
    }
    if ((v162 & 1) == 0)
    {
      v163 = v200[5];
LABEL_157:
      memcpy(v160->mBuffers[0].mData, v163->mBuffers[0].mData, v160->mBuffers[0].mDataByteSize);
      goto LABEL_164;
    }
    if (v147)
    {
      v163 = v200[1];
      goto LABEL_157;
    }
    float __A = 0.0;
    vDSP_vfill(&__A, v161, 1, (2 * *((_DWORD *)this + 84)));
LABEL_164:
    if (*((_DWORD *)this + 140) == 2)
    {
      v182 = v148[1];
      unsigned int v183 = v182->mBuffers[0].mDataByteSize;
      if (v183 >= 4) {
        memset_pattern16(v182->mBuffers[0].mData, &unk_1BB873A60, v183 & 0xFFFFFFFC);
      }
    }
    uint64_t v15 = 0;
    goto LABEL_168;
  }
  if (*((unsigned char *)this + 540)) {
    BOOL v164 = 1;
  }
  else {
    BOOL v164 = v129 == 0;
  }
  if (v164) {
    char v153 = 1;
  }
  if ((v153 & 1) == 0)
  {
    MEMORY[0x1F4188790](v141);
    v166 = (char *)&v188 - ((v165 + 15) & 0x7FFFFFFF0);
    uint64_t v168 = v167;
    memcpy(v166, v129, 4 * *((unsigned int *)this + 84));
    CResidualSuppressorV5::speex_preprocess_run(*((void *)this + 72), v166, (uint64_t)&__B, (uint64_t)v204, v168, *((void *)this + 73), v140, *((unsigned __int8 *)this + 617), &v203, *((void *)this + 74), *((float **)this + 75), *((void *)this + 76), *((unsigned char *)this + 640), *((_DWORD *)this + 157));
    if (*((unsigned char *)this + 546))
    {
      uint64_t v169 = *((void *)this + 72);
      v170 = *(const void **)(v169 + 344);
      v171 = *(const void **)(v169 + 352);
      v148 = v199;
      v172 = (char *)(*v199)->mBuffers[0].mData;
      uint64_t v173 = *((unsigned int *)this + 84);
      v174 = &v172[4 * v173];
      memcpy(v172, v170, 4 * v173);
      memcpy(v174, v171, 4 * *((unsigned int *)this + 84));
      if (*((_DWORD *)this + 142) >= 3u) {
        memcpy(v148[2]->mBuffers[0].mData, *(const void **)(*((void *)this + 72) + 112), 4 * *(int *)(*((void *)this + 72) + 8));
      }
      if (!v152) {
        goto LABEL_164;
      }
      v175 = v148[1];
      v176 = (float *)v175->mBuffers[0].mData;
      char v177 = !v150;
      if (!*((unsigned char *)this + 617)) {
        char v177 = 1;
      }
      if ((v177 & 1) == 0)
      {
        v178 = v200[5];
LABEL_160:
        memcpy(v175->mBuffers[0].mData, v178->mBuffers[0].mData, v175->mBuffers[0].mDataByteSize);
        goto LABEL_164;
      }
      if (v147)
      {
        v178 = v200[1];
        goto LABEL_160;
      }
      LODWORD(v202[0]) = 0;
      vDSP_Length v181 = (2 * *((_DWORD *)this + 84));
      v180 = v176;
    }
    else
    {
      v179 = v166;
      v148 = v199;
      memcpy((*v199)->mBuffers[0].mData, v179, 4 * *((unsigned int *)this + 84));
      if (!v152) {
        goto LABEL_164;
      }
      v180 = (float *)v148[1]->mBuffers[0].mData;
      LODWORD(v202[0]) = 0;
      vDSP_Length v181 = (2 * *((_DWORD *)this + 84));
    }
    vDSP_vfill((const float *)v202, v180, 1, v181);
    goto LABEL_164;
  }
  uint64_t v15 = 0xFFFFFFFFLL;
LABEL_168:
  if (*((_DWORD *)this + 142) >= 4u)
  {
    v184 = v148[3]->mBuffers[0].mData;
    if (v184) {
      memcpy(v184, *(const void **)(*((void *)this + 76) + 88), 4 * *((unsigned int *)this + 138));
    }
  }
  v185 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
  ausdk::AUElement::SetParameter(v185, 0x20u, *(float *)(*((void *)this + 72) + 224), 0);
  if (**((int **)this + 72) >= 1)
  {
    v186 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
    ausdk::AUElement::SetParameter(v186, 0x23u, *(float *)(*((void *)this + 72) + 676), 0);
  }
  return v15;
}

uint64_t AUResidualEchoSuppressorV5::CanScheduleParameters(AUResidualEchoSuppressorV5 *this)
{
  return 0;
}

uint64_t AUResidualEchoSuppressorV5::SetParameter(AUResidualEchoSuppressorV5 *this, unsigned int a2, unsigned int a3, unsigned int a4, float a5)
{
  if (a2 > 0x30) {
    goto LABEL_9;
  }
  if (((1 << a2) & 0x1E156FFFFDF27) == 0)
  {
    if (((1 << a2) & 0x182000000000) != 0)
    {
      if (!*((unsigned char *)this + 17)) {
        ++*((_DWORD *)this + 133);
      }
      uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
      goto LABEL_10;
    }
LABEL_9:
    Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
    uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
LABEL_10:
    ausdk::AUElement::SetParameter(Element, a2, a5, 0);
    return 0;
  }
  AudioUnitParameterValue v9 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
  ausdk::AUElement::SetParameter(v9, a2, a5, 0);
  ++*((_DWORD *)this + 133);
  return 0;
}

uint64_t AUResidualEchoSuppressorV5::SetProperty(AUResidualEchoSuppressorV5 *this, int a2, int a3, unsigned int a4, float *__src, unsigned int a6)
{
  if (a3) {
    return 4294956417;
  }
  uint64_t result = 4294956417;
  if (a2 > 8299)
  {
    if (a2 <= 8599)
    {
      if (a2 == 8300)
      {
        if (a6 == 4)
        {
          uint64_t result = 0;
          *((unsigned char *)this + 632) = *(_DWORD *)__src != 0;
          return result;
        }
      }
      else
      {
        if (a2 != 8500) {
          return result;
        }
        if (a6 == 4)
        {
          uint64_t result = 0;
          *((unsigned char *)this + 633) = *(_DWORD *)__src != 0;
          return result;
        }
      }
      return 4294956445;
    }
    if (a2 != 8600)
    {
      if (a2 != 8700) {
        return result;
      }
      if (*((unsigned char *)this + 17))
      {
        size_t v10 = 4 * (*((_DWORD *)this + 84) + 1);
        if (v10 > a6) {
          return 4294956445;
        }
        memcpy(*(void **)(*((void *)this + 76) + 88), __src, v10);
      }
      return 0;
    }
    if (a6 != 4) {
      return 4294956445;
    }
    uint64_t result = 0;
    float v14 = *__src;
    if (*__src < 0.0) {
      float v14 = 0.0;
    }
    *((float *)this + 159) = v14;
  }
  else
  {
    if (a2 <= 8009)
    {
      if (a2 != 21)
      {
        if (a2 != 8001) {
          return result;
        }
        if (*((unsigned char *)this + 17)) {
          return 4294956447;
        }
        if (a6 >= 4)
        {
          uint64_t result = 0;
          *((float *)this + 164) = *__src;
          return result;
        }
        return 4294956445;
      }
      if (a6 >= 4)
      {
        float v11 = *__src;
        int v12 = *(_DWORD *)__src != 0;
        if (v12 != (*(unsigned int (**)(AUResidualEchoSuppressorV5 *))(*(void *)this + 576))(this)) {
          (*(void (**)(AUResidualEchoSuppressorV5 *, BOOL))(*(void *)this + 584))(this, LODWORD(v11) != 0);
        }
        return 0;
      }
      return 4294956445;
    }
    if (a2 == 8010)
    {
      if (a6 == 4)
      {
        BOOL v13 = *(_DWORD *)__src != 0;
        *((unsigned char *)this + 700) = v13;
        if (*((unsigned char *)this + 17))
        {
          uint64_t result = 0;
          *(unsigned char *)(*((void *)this + 72) + 736) = v13;
          return result;
        }
        return 0;
      }
      return 4294956445;
    }
    if (a2 != 8020) {
      return result;
    }
    if (a6 != 4) {
      return 4294956445;
    }
    float v8 = *__src;
    uint64_t result = 4294956445;
    if (*__src <= 20.0 && v8 >= 0.0)
    {
      *((float *)this + 176) = v8;
      if (*((unsigned char *)this + 17))
      {
        float v9 = __exp10f(v8 * 0.1);
        uint64_t result = 0;
        *(float *)(*((void *)this + 72) + 740) = v9;
        return result;
      }
      return 0;
    }
  }
  return result;
}

uint64_t AUResidualEchoSuppressorV5::GetProperty(AUResidualEchoSuppressorV5 *this, int a2, int a3, unsigned int a4, _DWORD *__dst)
{
  if (a3) {
    return 4294956417;
  }
  uint64_t result = 4294956417;
  if (a2 <= 8099)
  {
    if (a2 <= 8000)
    {
      if (a2 == 21)
      {
        int v8 = (*(uint64_t (**)(AUResidualEchoSuppressorV5 *))(*(void *)this + 576))(this);
        uint64_t result = 0;
      }
      else
      {
        if (a2 != 3700) {
          return result;
        }
        uint64_t result = 0;
        int v8 = *((unsigned __int8 *)this + 376);
      }
      goto LABEL_32;
    }
    switch(a2)
    {
      case 8001:
        uint64_t result = 0;
        int v8 = *((_DWORD *)this + 164);
        break;
      case 8010:
        uint64_t result = 0;
        int v8 = *((unsigned __int8 *)this + 700);
        break;
      case 8020:
        uint64_t result = 0;
        int v9 = *((_DWORD *)this + 176);
        goto LABEL_30;
      default:
        return result;
    }
  }
  else
  {
    if (a2 <= 8499)
    {
      if (a2 != 8100)
      {
        if (a2 != 8200)
        {
          if (a2 != 8300) {
            return result;
          }
          uint64_t result = 0;
          int v8 = *((unsigned __int8 *)this + 632);
          goto LABEL_32;
        }
        if (*((unsigned char *)this + 17))
        {
          size_t v10 = *(const void **)(*((void *)this + 76) + 96);
          goto LABEL_24;
        }
        return 0;
      }
LABEL_17:
      if (*((unsigned char *)this + 17))
      {
        size_t v10 = *(const void **)(*((void *)this + 76) + 88);
LABEL_24:
        memcpy(__dst, v10, 4 * (*((_DWORD *)this + 84) + 1));
      }
      return 0;
    }
    if (a2 != 8500)
    {
      if (a2 != 8600)
      {
        if (a2 != 8700) {
          return result;
        }
        goto LABEL_17;
      }
      uint64_t result = 0;
      int v9 = *((_DWORD *)this + 159);
LABEL_30:
      *__dst = v9;
      return result;
    }
    uint64_t result = 0;
    int v8 = *((unsigned __int8 *)this + 633);
  }
LABEL_32:
  *__dst = v8;
  return result;
}

uint64_t AUResidualEchoSuppressorV5::GetPropertyInfo(AUResidualEchoSuppressorV5 *this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  if (a3) {
    return 4294956417;
  }
  uint64_t result = 4294956417;
  if (a2 <= 8099)
  {
    if (a2 <= 8000)
    {
      if (a2 != 21)
      {
        if (a2 != 3700) {
          return result;
        }
        *a6 = 0;
        goto LABEL_23;
      }
      goto LABEL_21;
    }
    if (a2 == 8001)
    {
      char v9 = *((unsigned char *)this + 17) ^ 1;
      goto LABEL_22;
    }
    if (a2 != 8010)
    {
      int v8 = 8020;
LABEL_12:
      if (a2 != v8) {
        return result;
      }
    }
  }
  else
  {
    if (a2 <= 8499)
    {
      if (a2 != 8100 && a2 != 8200)
      {
        int v8 = 8300;
        goto LABEL_12;
      }
      *a6 = 0;
LABEL_25:
      int v10 = 4 * *((_DWORD *)this + 84) + 4;
      goto LABEL_26;
    }
    if (a2 != 8500 && a2 != 8600)
    {
      if (a2 != 8700) {
        return result;
      }
      *a6 = 1;
      goto LABEL_25;
    }
  }
LABEL_21:
  char v9 = 1;
LABEL_22:
  *a6 = v9;
LABEL_23:
  int v10 = 4;
LABEL_26:
  uint64_t result = 0;
  *a5 = v10;
  return result;
}

uint64_t AUResidualEchoSuppressorV5::Reset(AUResidualEchoSuppressorV5 *this)
{
  return 0;
}

void AUResidualEchoSuppressorV5::Cleanup(AUResidualEchoSuppressorV5 *this)
{
  uint64_t v2 = *((void *)this + 72);
  if (v2)
  {
    CResidualSuppressorV3::speex_preprocess_state_res_destroy(v2);
    *((void *)this + 72) = 0;
  }
  CFNumberRef v3 = (void *)*((void *)this + 73);
  if (v3)
  {
    free(v3);
    *((void *)this + 73) = 0;
  }
  uint64_t v4 = *((void *)this + 74);
  if (v4)
  {
    CResidualSuppressorV3::speex_preprocess_state_res_destroy(v4);
    *((void *)this + 74) = 0;
  }
  unint64_t v5 = (void *)*((void *)this + 75);
  if (v5)
  {
    free(v5);
    *((void *)this + 75) = 0;
  }
  uint64_t v6 = *((void *)this + 76);
  if (v6)
  {
    if (*(void *)v6)
    {
      free(*(void **)v6);
      *(void *)uint64_t v6 = 0;
    }
    AudioUnitParameterUnit v7 = *(void **)(v6 + 16);
    if (v7)
    {
      free(v7);
      *(void *)(v6 + 16) = 0;
    }
    int v8 = *(void **)(v6 + 32);
    if (v8)
    {
      free(v8);
      *(void *)(v6 + 32) = 0;
    }
    char v9 = *(void **)(v6 + 48);
    if (v9)
    {
      free(v9);
      *(void *)(v6 + 48) = 0;
    }
    int v10 = *(void **)(v6 + 80);
    if (v10)
    {
      if (!*(void *)(v6 + 72)
        || (free(*(void **)(v6 + 72)), *(void *)(v6 + 72) = 0, (int v10 = *(void **)(v6 + 80)) != 0))
      {
        free(v10);
        *(void *)(v6 + 80) = 0;
      }
    }
    float v11 = *(void **)(v6 + 88);
    if (v11)
    {
      free(v11);
      *(void *)(v6 + 88) = 0;
    }
    int v12 = *(void **)(v6 + 96);
    if (v12) {
      free(v12);
    }
    free((void *)v6);
    *((void *)this + 76) = 0;
  }
}

uint64_t AUResidualEchoSuppressorV5::Initialize(AUResidualEchoSuppressorV5 *this)
{
  uint64_t v2 = *((void *)this + 15);
  if (v2) {
    LODWORD(v3) = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  else {
    uint64_t v3 = (*((void *)this + 13) - *((void *)this + 12)) >> 3;
  }
  *((_DWORD *)this + 141) = v3;
  uint64_t v4 = *((void *)this + 21);
  if (v4)
  {
    LODWORD(v5) = (*(uint64_t (**)(void))(*(void *)v4 + 24))(*((void *)this + 21));
    LODWORD(v3) = *((_DWORD *)this + 141);
  }
  else
  {
    uint64_t v5 = (*((void *)this + 19) - *((void *)this + 18)) >> 3;
  }
  *((_DWORD *)this + 142) = v5;
  unsigned int v6 = v5 - 5;
  if ((v3 - 7) < 0xFFFFFFFC || v6 < 0xFFFFFFFC) {
    return 4294956428;
  }
  unsigned int v9 = 1;
  do
  {
    uint64_t Element = ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), v9 - 1);
    if (*(double *)(Element + 80) != *(double *)(ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), v9)+ 80))return 4294956428; {
    ++v9;
    }
  }
  while (v9 < *((_DWORD *)this + 141));
  if (*((_DWORD *)this + 142) < 2u)
  {
LABEL_19:
    double v13 = *(double *)(ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 0) + 80);
    if (v13 != *(double *)(ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 128), 0) + 80)) {
      return 4294956428;
    }
    int v14 = *((_DWORD *)this + 84);
    *((_DWORD *)this + 138) = v14;
    *((_DWORD *)this + 139) = v14 + 1;
    *((unsigned char *)this + 540) = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 0)+ 88) == 1718773105;
    *((unsigned char *)this + 541) = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 1u)+ 88) == 1718773105;
    *((unsigned char *)this + 542) = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 2u)+ 88) == 1718773105;
    if (*((_DWORD *)this + 141) <= 3u)
    {
      *((unsigned char *)this + 543) = 0;
    }
    else
    {
      *((unsigned char *)this + 543) = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 3u)+ 88) == 1718773105;
      if (*((_DWORD *)this + 141) > 4u)
      {
        *((unsigned char *)this + 544) = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 4u)+ 88) == 1718773105;
        if (*((_DWORD *)this + 141) >= 6u)
        {
          BOOL v15 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 5u) + 88) == 1718773105;
          goto LABEL_27;
        }
LABEL_26:
        BOOL v15 = 1;
LABEL_27:
        *((unsigned char *)this + 545) = v15;
        *((unsigned char *)this + 546) = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 128), 0)+ 88) == 1718773105;
        if (*((_DWORD *)this + 142) <= 1u)
        {
          *((unsigned char *)this + 547) = 1;
        }
        else
        {
          *((unsigned char *)this + 547) = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 128), 1u)+ 88) == 1718773105;
          if (*((_DWORD *)this + 142) > 2u)
          {
            *((unsigned char *)this + 548) = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 128), 2u)+ 88) == 1718773105;
            BOOL v16 = *((_DWORD *)this + 142) >= 4u
               && *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 128), 3u) + 88) == 1718773105;
            goto LABEL_33;
          }
        }
        BOOL v16 = 0;
        *((unsigned char *)this + 548) = 0;
LABEL_33:
        *((unsigned char *)this + 549) = v16;
        uint64_t v17 = ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 0);
        uint64_t v18 = ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 1u);
        uint64_t v19 = ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 2u);
        double v21 = *(double *)(v17 + 80);
        uint64_t v20 = (const AudioStreamBasicDescription *)(v17 + 80);
        double v22 = v21;
        double v24 = *(double *)(v18 + 80);
        uint64_t v23 = (const AudioStreamBasicDescription *)(v18 + 80);
        v80[0] = 0;
        if (v22 == v24)
        {
          uint64_t v28 = (const AudioStreamBasicDescription *)v19;
          if (checkASBD(v20, v80))
          {
            unsigned int v25 = (FILE **)MEMORY[0x1E4F143C8];
            uint64_t v26 = (FILE *)*MEMORY[0x1E4F143C8];
            float v27 = "_vpio_res: check 2 failed!\n";
          }
          else if (checkASBD(v23, v80))
          {
            unsigned int v25 = (FILE **)MEMORY[0x1E4F143C8];
            uint64_t v26 = (FILE *)*MEMORY[0x1E4F143C8];
            float v27 = "_vpio_res: check 3 failed!\n";
          }
          else if (checkASBD(v28 + 2, v80))
          {
            unsigned int v25 = (FILE **)MEMORY[0x1E4F143C8];
            uint64_t v26 = (FILE *)*MEMORY[0x1E4F143C8];
            float v27 = "_vpio_res: check 4 failed!\n";
          }
          else
          {
            if (*((_DWORD *)this + 141) < 6u
              || (float v29 = (const AudioStreamBasicDescription *)ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 5u), !checkASBD(v29 + 2, v80)))
            {
              uint64_t v30 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              ausdk::AUElement::GetParameter(v30, 1u);
              float v31 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              ausdk::AUElement::GetParameter(v31, 2u);
              uint64_t v32 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              *((_DWORD *)this + 140) = ausdk::AUElement::GetParameter(v32, 8u);
              uint64_t v33 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              ausdk::AUElement::GetParameter(v33, 9u);
              uint64_t v34 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              float Parameter = ausdk::AUElement::GetParameter(v34, 0xAu);
              float v36 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              float v37 = ausdk::AUElement::GetParameter(v36, 0xBu);
              float v38 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              float v39 = ausdk::AUElement::GetParameter(v38, 0xCu);
              float v40 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              ausdk::AUElement::GetParameter(v40, 0xDu);
              uint64_t v41 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              ausdk::AUElement::GetParameter(v41, 0xEu);
              float v42 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              ausdk::AUElement::GetParameter(v42, 0xFu);
              unsigned int v43 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              float v44 = ausdk::AUElement::GetParameter(v43, 0x10u);
              unsigned int v45 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              *(float *)&int v79 = ausdk::AUElement::GetParameter(v45, 0x11u);
              uint64_t v46 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              float v78 = ausdk::AUElement::GetParameter(v46, 0x12u);
              float v47 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              float v77 = ausdk::AUElement::GetParameter(v47, 0x13u);
              uint64_t v48 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              float v76 = ausdk::AUElement::GetParameter(v48, 0x14u);
              unsigned int v49 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              ausdk::AUElement::GetParameter(v49, 0x15u);
              unsigned int v50 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              ausdk::AUElement::GetParameter(v50, 0x16u);
              unsigned int v51 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              ausdk::AUElement::GetParameter(v51, 0x17u);
              unsigned int v52 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              ausdk::AUElement::GetParameter(v52, 0x18u);
              uint64_t v53 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              ausdk::AUElement::GetParameter(v53, 0x19u);
              size_t v54 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              ausdk::AUElement::GetParameter(v54, 0x1Au);
              v55 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              ausdk::AUElement::GetParameter(v55, 0x1Bu);
              unsigned int v56 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              ausdk::AUElement::GetParameter(v56, 0x1Cu);
              CFArrayRef v57 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              BOOL v58 = ausdk::AUElement::GetParameter(v57, 0x25u) != 0.0;
              *((unsigned char *)this + 616) = v58;
              *((unsigned char *)this + 617) = v58;
              v59 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              *((unsigned char *)this + 618) = ausdk::AUElement::GetParameter(v59, 0x26u) != 0.0;
              int v60 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              *((_DWORD *)this + 155) = (int)ausdk::AUElement::GetParameter(v60, 0x27u);
              float v61 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              *((float *)this + 156) = ausdk::AUElement::GetParameter(v61, 0x28u);
              float v62 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              unsigned int v63 = ausdk::AUElement::GetParameter(v62, 0x2Bu);
              if (v63 >= 2) {
                unsigned int v63 = 2;
              }
              *((_DWORD *)this + 157) = v63;
              float v64 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              *((unsigned char *)this + 640) = ausdk::AUElement::GetParameter(v64, 0x2Cu) != 0.0;
              float v65 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              *((float *)this + 161) = ausdk::AUElement::GetParameter(v65, 0x2Du);
              float v66 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              *((_DWORD *)this + 162) = (int)ausdk::AUElement::GetParameter(v66, 0x2Eu);
              float v67 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              *((_DWORD *)this + 163) = (int)ausdk::AUElement::GetParameter(v67, 0x2Fu);
              float v68 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              *((_DWORD *)this + 173) = ausdk::AUElement::GetParameter(v68, 0x30u);
              float v69 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              float v70 = ausdk::AUElement::GetParameter(v69, 0x31u);
              float v71 = 0.0;
              if (v70 >= 0.0)
              {
                float v71 = 1.0;
                if (v70 <= 1.0) {
                  float v71 = v70;
                }
              }
              *((float *)this + 174) = v71;
              if (*((unsigned char *)this + 616))
              {
                if (*((_DWORD *)this + 163) == 1) {
                  *((_DWORD *)this + 162) = 0;
                }
              }
              else
              {
                *((unsigned char *)this + 617) = 0;
                *((void *)this + 81) = 0;
              }
              if (*((_DWORD *)this + 157) == 2)
              {
                *((unsigned char *)this + 617) = 0;
                *((void *)this + 81) = 0;
              }
              float v72 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              ausdk::AUElement::GetParameter(v72, 0x1Eu);
              float v73 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              ausdk::AUElement::GetParameter(v73, 0x1Du);
              float v74 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUResidualEchoSuppressorV5 *)((char *)this + 32), 0);
              ausdk::AUElement::GetParameter(v74, 0x1Fu);
              int mSampleRate = v20->mSampleRate;
              (*(void (**)(AUResidualEchoSuppressorV5 *))(*(void *)this + 64))(this);
              __exp10f(Parameter * 0.1);
              __exp10f(v37 * 0.1);
              __exp10f(v39 * 0.1);
              __exp10f(v44 * 0.1);
              __exp10f(*(float *)&v79 * 0.1);
              __exp10f(v78 * 0.1);
              __exp10f(v77 * 0.1);
              __exp10f(v76 * 0.1);
              CResidualSuppressorV3::speex_preprocess_state_res_init((CResidualSuppressorV3 *)*((unsigned int *)this + 84), mSampleRate);
            }
            unsigned int v25 = (FILE **)MEMORY[0x1E4F143C8];
            uint64_t v26 = (FILE *)*MEMORY[0x1E4F143C8];
            float v27 = "_vpio_res: check 6 failed!\n";
          }
        }
        else
        {
          unsigned int v25 = (FILE **)MEMORY[0x1E4F143C8];
          uint64_t v26 = (FILE *)*MEMORY[0x1E4F143C8];
          float v27 = "_vpio_res: check 1 failed!\n";
        }
        fwrite(v27, 0x1BuLL, 1uLL, v26);
        fflush(*v25);
        return 4294956428;
      }
    }
    *((unsigned char *)this + 544) = 0;
    goto LABEL_26;
  }
  unsigned int v11 = 1;
  while (1)
  {
    uint64_t v12 = ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 128), v11 - 1);
    if (*(double *)(v12 + 80) != *(double *)(ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 128), v11)+ 80))return 4294956428; {
    if (++v11 >= *((_DWORD *)this + 142))
    }
      goto LABEL_19;
  }
}

uint64_t checkASBD(const AudioStreamBasicDescription *a1, BOOL *a2)
{
  *a2 = 0;
  AudioFormatID mFormatID = a1->mFormatID;
  if (mFormatID != 1819304813 && mFormatID != 1718773105) {
    return 0xFFFFFFFFLL;
  }
  AudioFormatFlags mFormatFlags = a1->mFormatFlags;
  if ((mFormatFlags & 2) != 0 || a1->mChannelsPerFrame != 1) {
    return 0xFFFFFFFFLL;
  }
  if ((mFormatFlags & 1) == 0)
  {
    if (a1->mBytesPerFrame == 2)
    {
      uint64_t result = 0;
      *a2 = 1;
      return result;
    }
    return 0xFFFFFFFFLL;
  }
  return 0;
}

void AUResidualEchoSuppressorV5::~AUResidualEchoSuppressorV5(AUResidualEchoSuppressorV5 *this)
{
  AUResidualEchoSuppressorV5::~AUResidualEchoSuppressorV5(this);

  JUMPOUT(0x1C185D370);
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1F14AA8A0;
  AUResidualEchoSuppressorV5::Cleanup(this);
  uint64_t v2 = (void *)*((void *)this + 83);
  if (v2)
  {
    *((void *)this + 84) = v2;
    operator delete(v2);
  }

  ausdk::AUBase::~AUBase(this);
}

void SeparationBase::SeparationBase(SeparationBase *this, int a2, unsigned int a3, float a4, float a5, float a6, float a7, float a8, float a9, char a10, float a11, int a12, float a13, float a14, float a15, float a16, float a17, float a18, float a19)
{
  *(void *)this = &unk_1F14C53B8;
  *((float *)this + 2) = a4;
  *((float *)this + 3) = a5;
  *((float *)this + 4) = 1.0 - a5;
  *((float *)this + 5) = a6;
  *((float *)this + 6) = a7;
  *((float *)this + 7) = a8;
  *((float *)this + 8) = a9;
  *((float *)this + 9) = a11;
  *((_DWORD *)this + 10) = a12;
  *((_DWORD *)this + 11) = a2;
  *((_DWORD *)this + 12) = a3;
  *((_DWORD *)this + 13) = a2 * a2;
  *((void *)this + 7) = 5;
  *((_DWORD *)this + 16) = 0;
  *((float *)this + 17) = a16;
  *((float *)this + 18) = a15;
  *((float *)this + 19) = a13;
  *((float *)this + 20) = a14;
  *((unsigned char *)this + 92) = a10;
  *((void *)this + 12) = *(void *)&a17;
  *((float *)this + 26) = a19;
  *(_OWORD *)((char *)this + 108) = xmmword_1BB879C50;
  LODWORD(v103) = 1065353216;
  std::vector<float>::vector((void *)this + 16, a3, &v103);
  unint64_t v20 = *((unsigned int *)this + 12);
  LODWORD(v103) = 0;
  std::vector<float>::vector((void *)this + 19, v20, &v103);
  unint64_t v21 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 11));
  LODWORD(v103) = 0;
  std::vector<float>::vector((void *)this + 22, v21, &v103);
  unint64_t v22 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 11));
  LODWORD(v103) = 0;
  std::vector<float>::vector((void *)this + 25, v22, &v103);
  unint64_t v23 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 11));
  LODWORD(v103) = 0;
  std::vector<float>::vector((void *)this + 28, v23, &v103);
  unint64_t v24 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 11));
  LODWORD(v103) = 0;
  std::vector<float>::vector((void *)this + 31, v24, &v103);
  unint64_t v25 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 11));
  LODWORD(v103) = 0;
  std::vector<float>::vector((void *)this + 34, v25, &v103);
  unint64_t v26 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 11));
  LODWORD(v103) = 0;
  std::vector<float>::vector((void *)this + 37, v26, &v103);
  unint64_t v27 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 11));
  LODWORD(v103) = 0;
  std::vector<float>::vector((void *)this + 40, v27, &v103);
  unint64_t v28 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 11));
  LODWORD(v103) = 0;
  std::vector<float>::vector((void *)this + 43, v28, &v103);
  std::vector<DSPSplitComplex>::vector((void *)this + 46, *((unsigned int *)this + 11));
  std::vector<DSPSplitComplex>::vector((void *)this + 49, *((unsigned int *)this + 11));
  std::vector<DSPSplitComplex>::vector((void *)this + 52, *((unsigned int *)this + 11));
  std::vector<DSPSplitComplex>::vector((void *)this + 55, *((unsigned int *)this + 11));
  unint64_t v29 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 11));
  LODWORD(v103) = 0;
  std::vector<float>::vector((void *)this + 58, v29, &v103);
  unint64_t v30 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 11));
  LODWORD(v103) = 0;
  std::vector<float>::vector((void *)this + 61, v30, &v103);
  unint64_t v31 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 13));
  LODWORD(v103) = 0;
  std::vector<float>::vector((void *)this + 64, v31, &v103);
  unint64_t v32 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 13));
  LODWORD(v103) = 0;
  std::vector<float>::vector((void *)this + 67, v32, &v103);
  std::vector<DSPSplitComplex>::vector((void *)this + 70, *((unsigned int *)this + 13));
  unint64_t v33 = *((unsigned int *)this + 12);
  int v102 = 0;
  std::vector<float>::vector(&v103, v33, &v102);
  std::vector<std::vector<float>>::vector((void *)this + 73, 2uLL, (uint64_t)&v103);
  if (v103)
  {
    int v104 = v103;
    operator delete(v103);
  }
  unint64_t v34 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 11));
  LODWORD(v103) = 0;
  std::vector<float>::vector((void *)this + 76, v34, &v103);
  unint64_t v35 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 11));
  LODWORD(v103) = 0;
  std::vector<float>::vector((void *)this + 79, v35, &v103);
  unint64_t v36 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 11));
  LODWORD(v103) = 0;
  std::vector<float>::vector((void *)this + 82, v36, &v103);
  unint64_t v37 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 11));
  LODWORD(v103) = 0;
  std::vector<float>::vector((void *)this + 85, v37, &v103);
  unint64_t v38 = *((unsigned int *)this + 12);
  LODWORD(v103) = 0;
  std::vector<float>::vector((void *)this + 88, v38, &v103);
  unint64_t v39 = *((unsigned int *)this + 12);
  LODWORD(v103) = 0;
  std::vector<float>::vector((void *)this + 91, v39, &v103);
  std::vector<DSPSplitComplex>::vector((void *)this + 94, *((unsigned int *)this + 11));
  std::vector<DSPSplitComplex>::vector((void *)this + 97, *((unsigned int *)this + 11));
  *((void *)this + 100) = *((void *)this + 88);
  *((void *)this + 101) = *((void *)this + 91);
  unint64_t v40 = *((unsigned int *)this + 12);
  LODWORD(v103) = 0;
  std::vector<float>::vector((void *)this + 102, v40, &v103);
  unint64_t v41 = *((unsigned int *)this + 11);
  LODWORD(v103) = 0;
  std::vector<float>::vector((void *)this + 105, v41, &v103);
  unint64_t v42 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 13));
  LODWORD(v103) = 0;
  std::vector<float>::vector((void *)this + 108, v42, &v103);
  unint64_t v43 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 13));
  LODWORD(v103) = 0;
  std::vector<float>::vector((void *)this + 111, v43, &v103);
  unint64_t v44 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 13));
  LODWORD(v103) = 0;
  std::vector<float>::vector((void *)this + 114, v44, &v103);
  unint64_t v45 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 13));
  LODWORD(v103) = 0;
  std::vector<float>::vector((void *)this + 117, v45, &v103);
  unint64_t v46 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 13));
  LODWORD(v103) = 0;
  std::vector<float>::vector((void *)this + 120, v46, &v103);
  unint64_t v47 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 13));
  LODWORD(v103) = 0;
  std::vector<float>::vector((void *)this + 123, v47, &v103);
  std::vector<DSPSplitComplex>::vector((void *)this + 126, *((unsigned int *)this + 13));
  std::vector<DSPSplitComplex>::vector((void *)this + 129, *((unsigned int *)this + 13));
  std::vector<DSPSplitComplex>::vector((void *)this + 132, *((unsigned int *)this + 13));
  unint64_t v48 = *((unsigned int *)this + 11);
  std::vector<float>::vector(&v103, (*((_DWORD *)this + 12) * *((_DWORD *)this + 13)));
  std::vector<std::vector<float>>::vector((void *)this + 135, v48, (uint64_t)&v103);
  if (v103)
  {
    int v104 = v103;
    operator delete(v103);
  }
  unint64_t v49 = *((unsigned int *)this + 11);
  std::vector<float>::vector(&v103, (*((_DWORD *)this + 12) * *((_DWORD *)this + 13)));
  std::vector<std::vector<float>>::vector((void *)this + 138, v49, (uint64_t)&v103);
  if (v103)
  {
    int v104 = v103;
    operator delete(v103);
  }
  unint64_t v50 = *((unsigned int *)this + 11);
  std::vector<DSPSplitComplex>::vector(&v103, *((unsigned int *)this + 13));
  std::vector<std::vector<DSPSplitComplex>>::vector((void *)this + 141, v50, (uint64_t)&v103);
  if (v103)
  {
    int v104 = v103;
    operator delete(v103);
  }
  float v51 = *((float *)this + 2);
  uint64_t v53 = *((unsigned int *)this + 11);
  uint64_t v52 = *((unsigned int *)this + 12);
  double v54 = (double)v52 + -1.0;
  *((_DWORD *)this + 14) = ((float)(v51 * *((float *)this + 18)) / v54);
  double v55 = v51 / (v54 + v54);
  *(float *)&double v55 = v55;
  *(uint32x2_t *)((char *)this + 84) = vmin_u32(vcvt_u32_f32(vrnda_f32(vabs_f32(vdiv_f32(*(float32x2_t *)((char *)this + 76), (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v55, 0))))), (uint32x2_t)vdup_n_s32((int)v52 - 1));
  if (v53)
  {
    unsigned int v56 = 0;
    uint64_t v57 = *((void *)this + 22);
    uint64_t v58 = *((void *)this + 25);
    uint64_t v59 = *((void *)this + 28);
    uint64_t v60 = *((void *)this + 31);
    uint64_t v61 = *((void *)this + 34);
    uint64_t v62 = *((void *)this + 37);
    uint64_t v63 = *((void *)this + 40);
    uint64_t v64 = *((void *)this + 43);
    uint64_t v65 = *((void *)this + 76);
    float v66 = (void *)(*((void *)this + 97) + 8);
    float v67 = (void *)(*((void *)this + 46) + 8);
    uint64_t v68 = *((void *)this + 79);
    float v69 = (void *)(*((void *)this + 94) + 8);
    float v70 = (void *)(*((void *)this + 49) + 8);
    uint64_t v71 = *((void *)this + 82);
    float v72 = (void *)(*((void *)this + 55) + 8);
    float v73 = (void *)(*((void *)this + 52) + 8);
    uint64_t v74 = v53;
    uint64_t v75 = *((void *)this + 85);
    do
    {
      *(v67 - 1) = v57 + 4 * v56;
      void *v67 = v58 + 4 * v56;
      v67 += 2;
      *(v70 - 1) = v59 + 4 * v56;
      *float v70 = v60 + 4 * v56;
      v70 += 2;
      *(v73 - 1) = v61 + 4 * v56;
      *float v73 = v62 + 4 * v56;
      v73 += 2;
      *(v72 - 1) = v63 + 4 * v56;
      *float v72 = v64 + 4 * v56;
      v72 += 2;
      *(v69 - 1) = v65 + 4 * v56;
      *float v69 = v68 + 4 * v56;
      v69 += 2;
      *(v66 - 1) = v71 + 4 * v56;
      *float v66 = v75 + 4 * v56;
      v66 += 2;
      v56 += v52;
      --v74;
    }
    while (v74);
  }
  if (v52)
  {
    uint64_t v76 = 0;
    uint64_t v77 = *((void *)this + 102);
    do
    {
      *(float *)(v77 + 4 * v76) = (float)((float)((float)v52 + -1.0)
                                        + (float)((float)v52 + -1.0))
                                * (float)((float)((float)(*((float *)this + 7) * (float)v76)
                                                / (float)v52)
                                        + 1.0);
      ++v76;
    }
    while (v52 != v76);
  }
  if (v53)
  {
    uint64_t v78 = 0;
    uint64_t v79 = *((unsigned int *)this + 13);
    do
    {
      if (v79)
      {
        unsigned int v80 = 0;
        uint64_t v81 = *(void *)(*((void *)this + 135) + 24 * v78);
        uint64_t v82 = *(void *)(*((void *)this + 138) + 24 * v78);
        uint64_t v83 = (void *)(*(void *)(*((void *)this + 141) + 24 * v78) + 8);
        uint64_t v84 = v79;
        do
        {
          *(v83 - 1) = v81 + 4 * v80;
          void *v83 = v82 + 4 * v80;
          v83 += 2;
          v80 += v52;
          --v84;
        }
        while (v84);
      }
      ++v78;
    }
    while (v78 != v53);
  }
  SeparationBase::ResetiV(this);
  uint64_t v85 = *((unsigned int *)this + 13);
  if (v85)
  {
    unsigned int v86 = 0;
    int v87 = *((_DWORD *)this + 12);
    uint64_t v88 = *((void *)this + 108);
    uint64_t v89 = *((void *)this + 117);
    uint64_t v90 = *((void *)this + 111);
    uint64_t v91 = *((void *)this + 120);
    uint64_t v92 = *((void *)this + 114);
    uint64_t v93 = *((void *)this + 123);
    unsigned int v94 = (void *)(*((void *)this + 70) + 8);
    uint64_t v95 = *((void *)this + 64);
    uint64_t v96 = (void *)(*((void *)this + 126) + 8);
    uint64_t v97 = (void *)(*((void *)this + 132) + 8);
    int v98 = (void *)(*((void *)this + 129) + 8);
    uint64_t v99 = *((void *)this + 67);
    do
    {
      *(v96 - 1) = v88 + 4 * v86;
      *uint64_t v96 = v89 + 4 * v86;
      *(v98 - 1) = v90 + 4 * v86;
      *int v98 = v91 + 4 * v86;
      *(v97 - 1) = v92 + 4 * v86;
      *uint64_t v97 = v93 + 4 * v86;
      uint64_t v100 = v95 + 4 * v86;
      uint64_t v101 = v99 + 4 * v86;
      v86 += v87;
      *(v94 - 1) = v100;
      *unsigned int v94 = v101;
      v94 += 2;
      v96 += 2;
      v97 += 2;
      v98 += 2;
      --v85;
    }
    while (v85);
  }
  SeparationBase::ResetWA(this);
}

void sub_1BB34A634(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, void **a10, void **a11, void **a12, void **a13, void **a14, void **a15, void **a16, void **a17, void **a18, uint64_t a19, void **a20,void **a21,void **a22,void **a23,void **a24,void **a25,void **a26,void **a27,void **a28,void **a29,void **a30,void **a31,void **a32,void **a33,void **a34,void **a35)
{
  unint64_t v42 = *(void **)(v40 - 112);
  if (v42)
  {
    *(void *)(v40 - 104) = v42;
    operator delete(v42);
  }
  *(void *)(v40 - 112) = v36;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v40 - 112));
  *(void *)(v40 - 112) = v37;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v40 - 112));
  unint64_t v43 = *v39;
  if (*v39)
  {
    v35[133] = v43;
    operator delete(v43);
  }
  unint64_t v44 = *v38;
  if (*v38)
  {
    v35[130] = v44;
    operator delete(v44);
  }
  unint64_t v45 = *a9;
  if (*a9)
  {
    v35[127] = v45;
    operator delete(v45);
  }
  unint64_t v46 = *a10;
  if (*a10)
  {
    v35[124] = v46;
    operator delete(v46);
  }
  unint64_t v47 = *a11;
  if (*a11)
  {
    v35[121] = v47;
    operator delete(v47);
  }
  unint64_t v48 = *a12;
  if (*a12)
  {
    v35[118] = v48;
    operator delete(v48);
  }
  unint64_t v49 = *a13;
  if (*a13)
  {
    v35[115] = v49;
    operator delete(v49);
  }
  unint64_t v50 = *a14;
  if (*a14)
  {
    v35[112] = v50;
    operator delete(v50);
  }
  float v51 = *a15;
  if (*a15)
  {
    v35[109] = v51;
    operator delete(v51);
  }
  uint64_t v52 = *a16;
  if (*a16)
  {
    v35[106] = v52;
    operator delete(v52);
  }
  uint64_t v53 = *a27;
  if (*a27)
  {
    v35[103] = v53;
    operator delete(v53);
  }
  double v54 = *a28;
  if (*a28)
  {
    v35[98] = v54;
    operator delete(v54);
  }
  double v55 = *a29;
  if (*a29)
  {
    v35[95] = v55;
    operator delete(v55);
  }
  unsigned int v56 = *a17;
  if (*a17)
  {
    v35[92] = v56;
    operator delete(v56);
  }
  uint64_t v57 = *a18;
  if (*a18)
  {
    v35[89] = v57;
    operator delete(v57);
  }
  uint64_t v58 = *a30;
  if (*a30)
  {
    v35[86] = v58;
    operator delete(v58);
  }
  uint64_t v59 = *a31;
  if (*a31)
  {
    v35[83] = v59;
    operator delete(v59);
  }
  uint64_t v60 = *a32;
  if (*a32)
  {
    v35[80] = v60;
    operator delete(v60);
  }
  uint64_t v61 = *a33;
  if (*a33)
  {
    v35[77] = v61;
    operator delete(v61);
  }
  *(void *)(v40 - 112) = a19;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v40 - 112));
  uint64_t v62 = *a20;
  if (*a20)
  {
    v35[71] = v62;
    operator delete(v62);
  }
  uint64_t v63 = *a21;
  if (*a21)
  {
    v35[68] = v63;
    operator delete(v63);
  }
  uint64_t v64 = *a22;
  if (*a22)
  {
    v35[65] = v64;
    operator delete(v64);
  }
  uint64_t v65 = *a23;
  if (*a23)
  {
    v35[62] = v65;
    operator delete(v65);
  }
  float v66 = *a24;
  if (*a24)
  {
    v35[59] = v66;
    operator delete(v66);
  }
  float v67 = *a34;
  if (*a34)
  {
    v35[56] = v67;
    operator delete(v67);
  }
  uint64_t v68 = *a35;
  if (*a35)
  {
    v35[53] = v68;
    operator delete(v68);
  }
  float v69 = **(void ***)(v40 - 200);
  if (v69)
  {
    v35[50] = v69;
    operator delete(v69);
  }
  float v70 = **(void ***)(v40 - 192);
  if (v70)
  {
    v35[47] = v70;
    operator delete(v70);
  }
  uint64_t v71 = **(void ***)(v40 - 184);
  if (v71)
  {
    v35[44] = v71;
    operator delete(v71);
  }
  float v72 = **(void ***)(v40 - 176);
  if (v72)
  {
    v35[41] = v72;
    operator delete(v72);
  }
  float v73 = **(void ***)(v40 - 168);
  if (v73)
  {
    v35[38] = v73;
    operator delete(v73);
  }
  uint64_t v74 = **(void ***)(v40 - 160);
  if (v74)
  {
    v35[35] = v74;
    operator delete(v74);
  }
  uint64_t v75 = **(void ***)(v40 - 152);
  if (v75)
  {
    v35[32] = v75;
    operator delete(v75);
  }
  uint64_t v76 = **(void ***)(v40 - 144);
  if (v76)
  {
    v35[29] = v76;
    operator delete(v76);
  }
  uint64_t v77 = **(void ***)(v40 - 136);
  if (v77)
  {
    v35[26] = v77;
    operator delete(v77);
  }
  uint64_t v78 = **(void ***)(v40 - 128);
  if (v78)
  {
    v35[23] = v78;
    operator delete(v78);
  }
  uint64_t v79 = *a25;
  if (*a25)
  {
    v35[20] = v79;
    operator delete(v79);
  }
  unsigned int v80 = *a26;
  if (*a26)
  {
    v35[17] = v80;
    operator delete(v80);
  }
  _Unwind_Resume(a1);
}

void *std::vector<DSPSplitComplex>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<DSPSplitComplex>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v4 = (char *)a1[1];
    bzero(v4, 16 * a2);
    a1[1] = &v4[16 * a2];
  }
  return a1;
}

void sub_1BB34AB68(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<std::vector<DSPSplitComplex>>::vector(void *a1, unint64_t a2, uint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::vector<DSPSplitComplex>>::__vallocate[abi:ne180100](a1, a2);
    unsigned int v6 = (void *)a1[1];
    uint64_t v7 = 3 * a2;
    int v8 = &v6[3 * a2];
    uint64_t v9 = 8 * v7;
    do
    {
      void *v6 = 0;
      v6[1] = 0;
      v6[2] = 0;
      std::vector<DSPSplitComplex>::__init_with_size[abi:ne180100]<DSPSplitComplex*,DSPSplitComplex*>(v6, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 4);
      v6 += 3;
      v9 -= 24;
    }
    while (v9);
    a1[1] = v8;
  }
  return a1;
}

void sub_1BB34AC20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void SeparationBase::ResetiV(SeparationBase *this)
{
  *((_DWORD *)this + 15) = 0;
  *((_DWORD *)this + 16) = 0;
  if (*((_DWORD *)this + 11))
  {
    uint64_t v2 = 0;
    do
    {
      vDSP_vclr(*(float **)(*((void *)this + 135) + 24 * v2), 1, (*((_DWORD *)this + 12) * *((_DWORD *)this + 13)));
      vDSP_vclr(*(float **)(*((void *)this + 138) + 24 * v2), 1, (*((_DWORD *)this + 12) * *((_DWORD *)this + 13)));
      unsigned int v3 = *((_DWORD *)this + 11);
      unint64_t v4 = v2 + 1;
      if (v3)
      {
        for (unsigned int i = 0; i < v3; ++i)
        {
          if (*((unsigned char *)this + 92)) {
            float v6 = 1.0;
          }
          else {
            float v6 = (float)v4;
          }
          float v7 = (float)(1.0 / *((float *)this + 8)) * v6;
          float __A = v7;
          if (*((_DWORD *)this + 10) == 1) {
            float __A = (float)(1.0 / v7) * (float)(1.0 / v7);
          }
          vDSP_vfill(&__A, (float *)(*(void *)(*((void *)this + 135) + 24 * v2) + 4 * (i + i * v3) * *((_DWORD *)this + 12)), 1, *((unsigned int *)this + 12));
          unsigned int v3 = *((_DWORD *)this + 11);
        }
      }
      ++v2;
    }
    while (v4 < v3);
  }
}

void SeparationBase::ResetWA(SeparationBase *this)
{
  vDSP_vclr(*((float **)this + 111), 1, (*((_DWORD *)this + 12) * *((_DWORD *)this + 13)));
  vDSP_vclr(*((float **)this + 120), 1, (*((_DWORD *)this + 12) * *((_DWORD *)this + 13)));
  vDSP_vclr(*((float **)this + 114), 1, (*((_DWORD *)this + 12) * *((_DWORD *)this + 13)));
  vDSP_vclr(*((float **)this + 123), 1, (*((_DWORD *)this + 12) * *((_DWORD *)this + 13)));
  vDSP_vclr(*((float **)this + 108), 1, (*((_DWORD *)this + 12) * *((_DWORD *)this + 13)));
  vDSP_vclr(*((float **)this + 117), 1, (*((_DWORD *)this + 12) * *((_DWORD *)this + 13)));
  unsigned int v2 = *((_DWORD *)this + 11);
  if (v2)
  {
    for (unsigned int i = 0; i < v2; ++i)
    {
      vDSP_vfill((const float *)this + 27, (float *)(*((void *)this + 111) + 4 * (i + i * v2) * *((_DWORD *)this + 12)), 1, *((unsigned int *)this + 12));
      vDSP_vfill((const float *)this + 27, (float *)(*((void *)this + 114) + 4 * (i + i * *((_DWORD *)this + 11)) * *((_DWORD *)this + 12)), 1, *((unsigned int *)this + 12));
      vDSP_vfill((const float *)this + 27, (float *)(*((void *)this + 108) + 4 * (i + i * *((_DWORD *)this + 11)) * *((_DWORD *)this + 12)), 1, *((unsigned int *)this + 12));
      unsigned int v2 = *((_DWORD *)this + 11);
    }
  }
}

char *std::vector<std::vector<DSPSplitComplex>>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<AUPropertyItem>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

void *std::vector<DSPSplitComplex>::__init_with_size[abi:ne180100]<DSPSplitComplex*,DSPSplitComplex*>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    float v6 = result;
    uint64_t result = std::vector<DSPSplitComplex>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1BB34AF28(_Unwind_Exception *exception_object)
{
  unsigned int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<DSPSplitComplex>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >> 60) {
    std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float (ASAFeatures::*)(ASAFrontEndInputState const*)>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

void SeparationBase::Cleanup(SeparationBase *this)
{
  unsigned int v2 = (void *)*((void *)this + 16);
  uint64_t v3 = *((void *)this + 17) - (void)v2;
  if (v3 >= 1) {
    memset_pattern16(v2, &unk_1BB873A60, 4 * (((unint64_t)v3 >> 2) - ((unint64_t)v3 > 3)) + 4);
  }
  bzero(*((void **)this + 19), *((void *)this + 20) - *((void *)this + 19));
  bzero(*((void **)this + 22), *((void *)this + 23) - *((void *)this + 22));
  bzero(*((void **)this + 25), *((void *)this + 26) - *((void *)this + 25));
  bzero(*((void **)this + 28), *((void *)this + 29) - *((void *)this + 28));
  bzero(*((void **)this + 31), *((void *)this + 32) - *((void *)this + 31));
  bzero(*((void **)this + 34), *((void *)this + 35) - *((void *)this + 34));
  bzero(*((void **)this + 37), *((void *)this + 38) - *((void *)this + 37));
  bzero(*((void **)this + 40), *((void *)this + 41) - *((void *)this + 40));
  bzero(*((void **)this + 43), *((void *)this + 44) - *((void *)this + 43));
  bzero(*((void **)this + 58), *((void *)this + 59) - *((void *)this + 58));
  bzero(*((void **)this + 61), *((void *)this + 62) - *((void *)this + 61));
  vec::cleanup<float>((uint64_t *)this + 73);
  bzero(*((void **)this + 76), *((void *)this + 77) - *((void *)this + 76));
  bzero(*((void **)this + 79), *((void *)this + 80) - *((void *)this + 79));
  bzero(*((void **)this + 82), *((void *)this + 83) - *((void *)this + 82));
  bzero(*((void **)this + 85), *((void *)this + 86) - *((void *)this + 85));
  bzero(*((void **)this + 88), *((void *)this + 89) - *((void *)this + 88));
  bzero(*((void **)this + 91), *((void *)this + 92) - *((void *)this + 91));
  bzero(*((void **)this + 102), *((void *)this + 103) - *((void *)this + 102));
  bzero(*((void **)this + 105), *((void *)this + 106) - *((void *)this + 105));
  vec::cleanup<float>((uint64_t *)this + 135);
  vec::cleanup<float>((uint64_t *)this + 138);
  bzero(*((void **)this + 108), *((void *)this + 109) - *((void *)this + 108));
  bzero(*((void **)this + 111), *((void *)this + 112) - *((void *)this + 111));
  bzero(*((void **)this + 114), *((void *)this + 115) - *((void *)this + 114));
  bzero(*((void **)this + 117), *((void *)this + 118) - *((void *)this + 117));
  bzero(*((void **)this + 120), *((void *)this + 121) - *((void *)this + 120));
  bzero(*((void **)this + 123), *((void *)this + 124) - *((void *)this + 123));
  bzero(*((void **)this + 64), *((void *)this + 65) - *((void *)this + 64));
  bzero(*((void **)this + 67), *((void *)this + 68) - *((void *)this + 67));
  uint64_t v4 = *((unsigned int *)this + 12);
  if (v4)
  {
    uint64_t v5 = 0;
    uint64_t v6 = *((void *)this + 102);
    do
    {
      *(float *)(v6 + 4 * v5) = (float)((float)((float)v4 + -1.0) + (float)((float)v4 + -1.0))
                              * (float)((float)((float)(*((float *)this + 7) * (float)v5)
                                              / (float)v4)
                                      + 1.0);
      ++v5;
    }
    while (v4 != v5);
  }
  SeparationBase::ResetiV(this);

  SeparationBase::ResetWA(this);
}

void vec::cleanup<float>(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (a1[1] != *a1)
  {
    uint64_t v3 = 0;
    unsigned int v4 = 1;
    do
    {
      bzero(*(void **)(v1 + 24 * v3), *(void *)(v1 + 24 * v3 + 8) - *(void *)(v1 + 24 * v3));
      uint64_t v3 = v4;
      uint64_t v1 = *a1;
    }
    while (0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3) > v4++);
  }
}

{
  uint64_t v1;
  uint64_t v3;
  unsigned int v4;

  uint64_t v1 = *a1;
  if (a1[1] != *a1)
  {
    uint64_t v3 = 0;
    unsigned int v4 = 1;
    do
    {
      vec::cleanup<float>((uint64_t *)(v1 + 24 * v3));
      uint64_t v3 = v4;
      uint64_t v1 = *a1;
    }
    while (0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3) > v4++);
  }
}

void SeparationBase::ProcessBufferList(SeparationBase *this, const AudioBufferList *a2, AudioBufferList *a3)
{
  LODWORD(v6) = *((_DWORD *)this + 11);
  if (v6)
  {
    unint64_t v7 = 0;
    p_mData = &a2->mBuffers[0].mData;
    float v9 = 0.0;
    do
    {
      int v10 = (const float *)*p_mData;
      p_mData += 2;
      float v9 = cblas_sdsdot(2 * *((_DWORD *)this + 12) - 2, v9, v10, 1, v10, 1);
      ++v7;
      unint64_t v6 = *((unsigned int *)this + 11);
    }
    while (v7 < v6);
  }
  else
  {
    float v9 = 0.0;
  }
  if (v9 > *((float *)this + 30) && (LODWORD(v9) & 0x7FFFFFFFu) <= 0x7F7FFFFF)
  {
    if (v6)
    {
      uint64_t v18 = 0;
      unint64_t v19 = 0;
      unint64_t v20 = &a2->mBuffers[0].mData;
      do
      {
        memcpy(*(void **)(*((void *)this + 52) + v18 * 8), v20[v18], 4 * *((unsigned int *)this + 12));
        memcpy((void *)(*(void *)(*((void *)this + 52) + v18 * 8 + 8) + 4), (char *)v20[v18] + 4 * *((unsigned int *)this + 12), 4 * (*((_DWORD *)this + 12) - 2));
        ++v19;
        unint64_t v21 = *((unsigned int *)this + 11);
        v18 += 2;
      }
      while (v19 < v21);
      if (v21)
      {
        uint64_t v22 = 0;
        unint64_t v23 = 0;
        do
        {
          vDSP_zrvmul((const DSPSplitComplex *)(*((void *)this + 52) + v22), 1, *((const float **)this + 102), 1, (const DSPSplitComplex *)(*((void *)this + 55) + v22), 1, *((unsigned int *)this + 12));
          ++v23;
          v22 += 16;
        }
        while (v23 < *((unsigned int *)this + 11));
      }
    }
    unsigned int v24 = *((_DWORD *)this + 15);
    if (v24 >= *((_DWORD *)this + 14)) {
      *((_DWORD *)this + 16) = 1;
    }
    else {
      *((_DWORD *)this + 15) = v24 + 1;
    }
    SeparationBase::GenerateOutput((uint64_t)this, (void *)this + 55, (float ***)this + 46);
    if (*((_DWORD *)this + 11))
    {
      uint64_t v25 = 0;
      unint64_t v26 = 0;
      uint64_t v27 = *((unsigned int *)this + 21);
      vDSP_Length v28 = (*((_DWORD *)this + 22) - v27);
      do
      {
        LODWORD(__C.realp) = 0;
        LODWORD(v44.realp) = 0;
        vDSP_svesq((const float *)(*(void *)(*((void *)this + 46) + v25) + 4 * v27), 1, (float *)&__C, v28);
        vDSP_svesq((const float *)(*(void *)(*((void *)this + 46) + v25 + 8) + 4 * v27), 1, (float *)&v44, v28);
        float v29 = *((float *)this + 6);
        *(float *)(*((void *)this + 105) + 4 * v26++) = v29
                                                        + powf((float)(*(float *)&__C.realp + *(float *)&v44.realp)+ *((float *)this + 30), *((float *)this + 5));
        v25 += 16;
      }
      while (v26 < *((unsigned int *)this + 11));
    }
    (*(void (**)(SeparationBase *))(*(void *)this + 8))(this);
    if (*((_DWORD *)this + 16)) {
      (**(void (***)(SeparationBase *))this)(this);
    }
    SeparationBase::GenerateOutput((uint64_t)this, (void *)this + 52, (float ***)this + 49);
    unint64_t v30 = (float *)*((void *)this + 37);
    __C.realp = (float *)*((void *)this + 34);
    __C.imagp = v30;
    unint64_t v31 = (float *)*((void *)this + 31);
    v44.realp = (float *)*((void *)this + 28);
    v44.imagp = v31;
    vDSP_zvmags(&v44, 1, *((float **)this + 61), 1, (*((_DWORD *)this + 12) * *((_DWORD *)this + 11)));
    vDSP_zvmags(&__C, 1, *((float **)this + 58), 1, (*((_DWORD *)this + 12) * *((_DWORD *)this + 11)));
    vDSP_vsmul(*((const float **)this + 58), 1, (const float *)this + 17, *((float **)this + 58), 1, (*((_DWORD *)this + 12) * *((_DWORD *)this + 11)));
    uint64_t v32 = *((unsigned int *)this + 11);
    if (v32)
    {
      int v33 = 0;
      uint64_t v34 = 0;
      uint64_t v35 = *((unsigned int *)this + 12);
      do
      {
        if (v35)
        {
          uint64_t v36 = 0;
          uint64_t v37 = *((void *)this + 61);
          uint64_t v38 = *((void *)this + 58);
          do
          {
            if (*(float *)(v37 + 4 * (v33 + v36)) > *(float *)(v38 + 4 * (v33 + v36)))
            {
              unint64_t v39 = (void *)(*((void *)this + 52) + 16 * v34);
              uint64_t v40 = (void *)(*((void *)this + 49) + 16 * v34);
              *(_DWORD *)(*v40 + 4 * v36) = *(_DWORD *)(*v39 + 4 * v36);
              *(_DWORD *)(v40[1] + 4 * v36) = *(_DWORD *)(v39[1] + 4 * v36);
            }
            ++v36;
          }
          while (v35 != v36);
        }
        ++v34;
        v33 += v35;
      }
      while (v34 != v32);
      uint64_t v41 = 0;
      unint64_t v42 = 0;
      unint64_t v43 = &a3->mBuffers[0].mData;
      do
      {
        memcpy(v43[v41], *(const void **)(*((void *)this + 49) + v41 * 8), 4 * *((unsigned int *)this + 12));
        memcpy((char *)v43[v41] + 4 * *((unsigned int *)this + 12), (const void *)(*(void *)(*((void *)this + 49) + v41 * 8 + 8) + 4), 4 * (*((_DWORD *)this + 12) - 2));
        ++v42;
        v41 += 2;
      }
      while (v42 < *((unsigned int *)this + 11));
    }
  }
  else if (v6)
  {
    unint64_t v12 = 0;
    double v13 = &a2->mBuffers[0].mData;
    int v14 = &a3->mBuffers[0].mData;
    do
    {
      BOOL v16 = *v14;
      v14 += 2;
      BOOL v15 = v16;
      uint64_t v17 = *v13;
      v13 += 2;
      memcpy(v15, v17, 4 * (2 * *((_DWORD *)this + 12) - 2));
      ++v12;
    }
    while (v12 < *((unsigned int *)this + 11));
  }
}

void SeparationBase::GenerateOutput(uint64_t a1, void *a2, float ***a3)
{
  vDSP_vclr(**a3, 1, (*(_DWORD *)(a1 + 48) * *(_DWORD *)(a1 + 44)));
  vDSP_vclr((*a3)[1], 1, (*(_DWORD *)(a1 + 48) * *(_DWORD *)(a1 + 44)));
  LODWORD(v6) = *(_DWORD *)(a1 + 44);
  if (v6)
  {
    unint64_t v7 = 0;
    do
    {
      if (v6)
      {
        uint64_t v8 = 0;
        unint64_t v9 = 0;
        do
        {
          vDSP_zvma((const DSPSplitComplex *)(*(void *)(a1 + 1008) + 16 * (v9++ + v7 * v6)), 1, (const DSPSplitComplex *)(*a2 + v8), 1, (const DSPSplitComplex *)&(*a3)[2 * v7], 1, (const DSPSplitComplex *)&(*a3)[2 * v7], 1, *(unsigned int *)(a1 + 48));
          unint64_t v6 = *(unsigned int *)(a1 + 44);
          v8 += 16;
        }
        while (v9 < v6);
      }
      ++v7;
    }
    while (v7 < v6);
  }
}

void SeparationBase::rank1WInverseA(SeparationBase *this, unsigned int a2)
{
  vDSP_vclr(*((float **)this + 76), 1, (*((_DWORD *)this + 12) * *((_DWORD *)this + 11)));
  vDSP_vclr(*((float **)this + 79), 1, (*((_DWORD *)this + 12) * *((_DWORD *)this + 11)));
  LODWORD(v4) = *((_DWORD *)this + 11);
  if (v4)
  {
    unint64_t v5 = 0;
    do
    {
      if (v4)
      {
        uint64_t v6 = 0;
        unint64_t v7 = 0;
        do
        {
          vDSP_zvcma((const DSPSplitComplex *)(*((void *)this + 97) + v6), 1, (const DSPSplitComplex *)(*((void *)this + 132) + 16 * (v5 + v4 * v7++)), 1, (const DSPSplitComplex *)(*((void *)this + 94) + 16 * v5), 1, (const DSPSplitComplex *)(*((void *)this + 94) + 16 * v5), 1, *((unsigned int *)this + 12));
          unint64_t v4 = *((unsigned int *)this + 11);
          v6 += 16;
        }
        while (v7 < v4);
      }
      ++v5;
    }
    while (v5 < v4);
  }
  vDSP_vsadd(*(const float **)(*((void *)this + 94) + 16 * a2), 1, (const float *)this + 27, *((float **)this + 100), 1, *((unsigned int *)this + 12));
  memcpy(*((void **)this + 101), *(const void **)(*((void *)this + 94) + 16 * a2 + 8), 4 * *((unsigned int *)this + 12));
  uint64_t v8 = (float *)*((void *)this + 19);
  __A.realp = (float *)*((void *)this + 16);
  __A.imagp = v8;
  unint64_t v9 = (float **)*((void *)this + 73);
  int v10 = *v9;
  unsigned int v11 = v9[3];
  __C.realp = v10;
  __C.imagp = v11;
  vDSP_zvdiv((const DSPSplitComplex *)this + 50, 1, &__A, 1, &__C, 1, *((unsigned int *)this + 12));
  vDSP_zvneg(&__C, 1, &__C, 1, *((unsigned int *)this + 12));
  LODWORD(v12) = *((_DWORD *)this + 11);
  if (v12)
  {
    unsigned int v13 = 0;
    do
    {
      vDSP_zvmul((const DSPSplitComplex *)(*((void *)this + 132) + 16 * (a2 + v12 * v13)), 1, &__C, 1, (const DSPSplitComplex *)(*((void *)this + 70) + 16 * (a2 + v12 * v13)), 1, *((unsigned int *)this + 12), 1);
      ++v13;
      LODWORD(v12) = *((_DWORD *)this + 11);
    }
    while (v13 < v12);
    if (v12)
    {
      unsigned int v14 = 0;
      do
      {
        uint64_t v15 = 0;
        unint64_t v16 = 0;
        do
        {
          int v17 = v12 * v14;
          uint64_t v18 = (const DSPSplitComplex *)(*((void *)this + 132) + 16 * (v16 + v17));
          vDSP_zvma((const DSPSplitComplex *)(*((void *)this + 70) + 16 * (v17 + a2)), 1, (const DSPSplitComplex *)(*((void *)this + 94) + v15), 1, v18, 1, v18, 1, *((unsigned int *)this + 12));
          ++v16;
          unint64_t v12 = *((unsigned int *)this + 11);
          v15 += 16;
        }
        while (v16 < v12);
        ++v14;
      }
      while (v14 < v12);
    }
  }
}

void SeparationBase::minimumDistrotionPrinciple(SeparationBase *this)
{
  unint64_t v1 = *((unsigned int *)this + 11);
  if (v1)
  {
    for (unint64_t i = 0; i < v1; ++i)
    {
      if (v1)
      {
        for (unint64_t j = 0; j < v1; ++j)
        {
          vDSP_zvmul((const DSPSplitComplex *)(*((void *)this + 129) + 16 * (j + i * v1)), 1, (const DSPSplitComplex *)(*((void *)this + 132) + 16 * (i + i * v1)), 1, (const DSPSplitComplex *)(*((void *)this + 126) + 16 * (j + i * v1)), 1, *((unsigned int *)this + 12), 1);
          unint64_t v1 = *((unsigned int *)this + 11);
        }
      }
    }
  }
}

_DWORD *AUDspLib::gatherParametersForInstance(_DWORD *result, unsigned int a2, uint64_t a3)
{
  if (result[439])
  {
    uint64_t v5 = (uint64_t)result;
    unint64_t v6 = 0;
    unint64_t v7 = (ausdk::AUScope *)(result + 384);
    uint64_t v8 = (ausdk::AUScope *)(result + 8);
    do
    {
      if (*(_DWORD *)(v5 + 1588) == 1) {
        uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::GetElement(v7, a2);
      }
      else {
        uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(v8, 0);
      }
      float Parameter = ausdk::AUElement::GetParameter(Element, v6);
      uint64_t result = *(_DWORD **)(a3 + 24);
      if (result) {
        uint64_t result = (_DWORD *)std::function<void ()(unsigned int,unsigned int,float)>::operator()((uint64_t)result, *(_DWORD *)(*(void *)(v5 + 1688) + 4 * v6), v6, Parameter);
      }
      ++v6;
    }
    while (v6 < *(unsigned int *)(v5 + 1756));
  }
  return result;
}

uint64_t std::function<void ()(unsigned int,unsigned int,float)>::operator()(uint64_t a1, int a2, int a3, float a4)
{
  int v7 = a2;
  int v6 = a3;
  float v5 = a4;
  if (!a1) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, int *, int *, float *))(*(void *)a1 + 48))(a1, &v7, &v6, &v5);
}

uint64_t AUDspLib::setParametersOnInstance(AUDspLib *this, unsigned int a2)
{
  return (*(uint64_t (**)(void))(**((void **)this + 7 * a2 + 66) + 128))();
}

uint64_t AUDspLib::numStatus(AUDspLib *this)
{
  uint64_t result = *((void *)this + 66);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 176))(result);
  }
  return result;
}

uint64_t AUDspLib::deleteAlgorithms(AUDspLib *this)
{
  unsigned int v2 = (AUDspLib *)((char *)this + 1824);
  caulk::pooled_semaphore_mutex::_lock((AUDspLib *)((char *)this + 1824));
  for (uint64_t i = 0; i != 1008; i += 56)
  {
    unint64_t v4 = (char *)this + i;
    uint64_t v5 = *(void *)((char *)this + i + 528);
    if (v5)
    {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
      *((void *)v4 + 66) = 0;
    }
    *((void *)v4 + 71) = 0;
  }
  caulk::pooled_semaphore_mutex::_unlock(v2);
  return 0;
}

uint64_t AUDspLib::createAlgorithms(AUDspLib *this)
{
  unsigned int v2 = (AUDspLib *)((char *)this + 1824);
  caulk::pooled_semaphore_mutex::_lock((AUDspLib *)((char *)this + 1824));
  uint64_t v4 = *((unsigned int *)this + 397);
  uint64_t v5 = v4;
  if (v4 != 1)
  {
    if (v4 || (int v6 = (unsigned int *)*((void *)this + 268), v6 == *((unsigned int **)this + 269))) {
      uint64_t v5 = 0;
    }
    else {
      uint64_t v5 = *v6;
    }
  }
  unint64_t v7 = 0;
  uint64_t v8 = 528;
  if (!v4) {
    goto LABEL_9;
  }
LABEL_7:
  unint64_t v9 = (unsigned int *)*((void *)this + 268);
  if (v9 == *((unsigned int **)this + 269)) {
    unint64_t v10 = 0;
  }
  else {
    unint64_t v10 = *v9;
  }
  while (v7 < v10)
  {
    if (!*(void *)((char *)this + v8))
    {
      *(void *)((char *)this + v8) = (*(uint64_t (**)(AUDspLib *, uint64_t))(*(void *)this + 600))(this, v5);
      LODWORD(v4) = *((_DWORD *)this + 397);
    }
    ++v7;
    v8 += 56;
    if (v4) {
      goto LABEL_7;
    }
LABEL_9:
    unint64_t v10 = 1;
  }
  if (*((void *)this + 66))
  {
    AUDspLib::initializeDspLibAlgorithms((uint64_t)this, v3);
    unint64_t v11 = 0;
    for (uint64_t i = (_DWORD *)((char *)this + 572); ; i += 14)
    {
      if (*((_DWORD *)this + 397))
      {
        unsigned int v13 = (unsigned int *)*((void *)this + 268);
        unint64_t v14 = v13 == *((unsigned int **)this + 269) ? 0 : *v13;
      }
      else
      {
        unint64_t v14 = 1;
      }
      if (v11 >= v14) {
        break;
      }
      (*(void (**)(void, void))(**(void **)(i - 11) + 200))(*(void *)(i - 11), *((unsigned __int8 *)i - 36));
      if (*(void *)(i - 5) != *(void *)(i - 7))
      {
        (*(void (**)(AUDspLib *, unint64_t))(*(void *)this + 616))(this, v11);
        *uint64_t i = *(i - 1);
      }
      ++v11;
    }
  }
  *((unsigned char *)this + 1820) = 1;
  caulk::pooled_semaphore_mutex::_unlock(v2);
  return 0;
}

void sub_1BB34BE20(_Unwind_Exception *a1)
{
  caulk::pooled_semaphore_mutex::_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t AUDspLib::initializeDspLibAlgorithms(uint64_t this, __n128 a2)
{
  uint64_t v2 = this;
  unint64_t v3 = 0;
  for (uint64_t i = (void *)(this + 528); ; i += 7)
  {
    int v5 = *(_DWORD *)(v2 + 1588);
    if (v5)
    {
      int v6 = *(unsigned int **)(v2 + 2144);
      unint64_t v7 = v6 == *(unsigned int **)(v2 + 2152) ? 0 : *v6;
    }
    else
    {
      unint64_t v7 = 1;
    }
    if (v3 >= v7) {
      break;
    }
    uint64_t v8 = *i;
    if (*i)
    {
      if (v5)
      {
        if (v5 == 1)
        {
          a2.n128_u32[0] = *(_DWORD *)(v2 + 1812);
          a2.n128_f64[0] = (double)a2.n128_u64[0];
          this = (*(uint64_t (**)(void, uint64_t, __n128))(*(void *)v8 + 16))(*i, 6553601, a2);
        }
      }
      else
      {
        unint64_t v9 = *(int **)(v2 + 2144);
        if (v9 == *(int **)(v2 + 2152)) {
          int v10 = 0;
        }
        else {
          int v10 = *v9;
        }
        uint64_t v11 = DspLibFinalChannelLayout(*(unsigned int *)(v2 + 1800), *(unsigned int *)(v2 + 1804), v10);
        LODWORD(v12) = *(_DWORD *)(v2 + 1812);
        v13.n128_f64[0] = (double)v12;
        this = (*(uint64_t (**)(uint64_t, uint64_t, __n128))(*(void *)v8 + 16))(v8, v11, v13);
      }
    }
    ++v3;
  }
  return this;
}

uint64_t AUDspLib::Version(AUDspLib *this)
{
  return 0;
}

uint64_t AUDspLib::SetAudioChannelLayout(AUDspLib *this, unsigned int a2, unsigned int a3, const AudioChannelLayout *a4)
{
  AudioChannelLayoutTag mChannelLayoutTag = a4->mChannelLayoutTag;
  if ((a4->mChannelLayoutTag | 0x10000) == 0x10000) {
    return 4294956428;
  }
  if (*((_DWORD *)this + 450) != mChannelLayoutTag)
  {
    *((_DWORD *)this + 450) = mChannelLayoutTag;
    if (*((unsigned char *)this + 17))
    {
      if (*(_DWORD *)(ausdk::AUScope::SafeGetElement((AUDspLib *)((char *)this + 80), 0) + 108) != LOWORD(a4->mChannelLayoutTag)) {
        return 4294956428;
      }
      caulk::pooled_semaphore_mutex::_lock((AUDspLib *)((char *)this + 1824));
      AUDspLib::initializeDspLibAlgorithms((uint64_t)this, v7);
      caulk::pooled_semaphore_mutex::_unlock((AUDspLib *)((char *)this + 1824));
    }
  }
  return 0;
}

void sub_1BB34BFF0(_Unwind_Exception *a1)
{
  caulk::pooled_semaphore_mutex::_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t AUDspLib::SupportedNumChannels(AUDspLib *this, const AUChannelInfo **a2)
{
  if (a2) {
    *a2 = (const AUChannelInfo *)&AUDspLib::SupportedNumChannels(AUChannelInfo const**)::kSupportedNumChannels;
  }
  return 18;
}

uint64_t AUDspLib::GetTailTime(uint64_t this)
{
  if (!*(unsigned char *)(this + 2113))
  {
    uint64_t v1 = this;
    if (*(unsigned char *)(this + 1585))
    {
      uint64_t v2 = *(void *)(this + 528);
      if (v2) {
        double v3 = (*(double (**)(uint64_t, double))(*(void *)v2 + 72))(v2, 0.0);
      }
      else {
        double v3 = 0.0;
      }
      for (uint64_t i = 0; i != 952; i += 56)
      {
        uint64_t v5 = *(void *)(v1 + 584 + i);
        if (v5)
        {
          double v6 = (*(double (**)(uint64_t))(*(void *)v5 + 72))(v5);
          if (v3 < v6) {
            double v3 = v6;
          }
        }
      }
    }
    return ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v1 + 128), 0);
  }
  return this;
}

unsigned char *AUDspLib::GetLatency(unsigned char *this)
{
  if (!this[2113])
  {
    uint64_t v1 = (uint64_t)this;
    if (this[1585] && this[1820])
    {
      this[1820] = 0;
      caulk::pooled_semaphore_mutex::_lock((caulk::pooled_semaphore_mutex *)(this + 1824));
      unint64_t v2 = 0;
      for (uint64_t i = (_DWORD *)(v1 + 572); ; i += 14)
      {
        if (*(_DWORD *)(v1 + 1588))
        {
          uint64_t v4 = *(unsigned int **)(v1 + 2144);
          unint64_t v5 = v4 == *(unsigned int **)(v1 + 2152) ? 0 : *v4;
        }
        else
        {
          unint64_t v5 = 1;
        }
        if (v2 >= v5) {
          break;
        }
        int v6 = *(i - 1);
        if (v6 != *i)
        {
          *uint64_t i = v6;
          if (*(void *)(i - 11)) {
            (*(void (**)(uint64_t, unint64_t))(*(void *)v1 + 616))(v1, v2);
          }
        }
        ++v2;
      }
      uint64_t v7 = *(void *)(v1 + 528);
      if (v7) {
        double v8 = (*(double (**)(uint64_t))(*(void *)v7 + 64))(v7);
      }
      else {
        double v8 = 0.0;
      }
      for (uint64_t j = 0; j != 952; j += 56)
      {
        uint64_t v10 = *(void *)(v1 + 584 + j);
        if (v10)
        {
          double v11 = (*(double (**)(uint64_t))(*(void *)v10 + 64))(v10);
          if (v11 != v8 && v8 < v11) {
            double v8 = v11;
          }
        }
      }
      *(_DWORD *)(v1 + 1816) = v8;
      caulk::pooled_semaphore_mutex::_unlock((caulk::pooled_semaphore_mutex *)(v1 + 1824));
    }
    return (unsigned char *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v1 + 128), 0);
  }
  return this;
}

void sub_1BB34C2A4(_Unwind_Exception *a1)
{
  caulk::pooled_semaphore_mutex::_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t AUDspLib::NewFactoryPresetSet(AUDspLib *this, const AUPreset *a2)
{
  uint64_t v3 = *((unsigned int *)this + 444);
  if (v3)
  {
    uint64_t v4 = 0;
    SInt32 presetNumber = a2->presetNumber;
    int v6 = (int *)*((void *)this + 224);
    uint64_t v7 = v6;
    while (1)
    {
      int v8 = *v7;
      v7 += 4;
      if (presetNumber == v8) {
        break;
      }
      if (v3 == ++v4) {
        goto LABEL_5;
      }
    }
    unsigned int v10 = *((_DWORD *)this + 439);
    if (v10)
    {
      uint64_t v11 = 0;
      do
      {
        int v12 = *((_DWORD *)this + 397);
        if (v12)
        {
          if (v12 == 1)
          {
            for (unsigned int i = 0; ; ++i)
            {
              unint64_t v14 = (_DWORD *)*((void *)this + 268);
              unsigned int v15 = v14 == *((_DWORD **)this + 269) ? 0 : *v14;
              if (i >= v15) {
                break;
              }
              uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUDspLib *)((char *)this + 1536), i);
              ausdk::AUElement::SetParameter(Element, v11, *(float *)(*((void *)this + 221) + 4 * (v11 + *((_DWORD *)this + 439) * presetNumber)), 0);
            }
          }
        }
        else
        {
          (*(void (**)(AUDspLib *, uint64_t, void, void, void, float))(*(void *)this + 152))(this, v11, 0, 0, 0, *(float *)(*((void *)this + 221) + 4 * (v11 + v10 * presetNumber)));
        }
        uint64_t v11 = (v11 + 1);
        unsigned int v10 = *((_DWORD *)this + 439);
      }
      while (v11 < v10);
      int v6 = (int *)*((void *)this + 224);
    }
    ausdk::AUBase::SetAFactoryPresetAsCurrent((char *)this, (const AUPreset *)&v6[4 * v4]);
    return 0;
  }
  else
  {
LABEL_5:
    *((unsigned char *)this + 1820) = 1;
    return 4294956445;
  }
}

uint64_t AUDspLib::GetPresets(AUDspLib *this, const __CFArray **a2)
{
  if (a2)
  {
    Mutable = CFArrayCreateMutable(0, *((unsigned int *)this + 444), 0);
    if (*((_DWORD *)this + 444))
    {
      uint64_t v5 = 0;
      unint64_t v6 = 0;
      do
      {
        CFArrayAppendValue(Mutable, (const void *)(*((void *)this + 224) + v5));
        ++v6;
        v5 += 16;
      }
      while (v6 < *((unsigned int *)this + 444));
    }
    *a2 = Mutable;
  }
  return 0;
}

uint64_t AUDspLib::CopyClumpName(AUDspLib *this, unsigned int a2, unsigned int a3, unsigned int a4, const __CFString **a5)
{
  if (*((void *)this + 218) <= (unint64_t)a3) {
    return 4294956419;
  }
  uint64_t result = 0;
  *a5 = *(const __CFString **)(*((void *)this + 217) + 8 * a3);
  return result;
}

uint64_t AUDspLib::RestoreState(OpaqueAudioComponentInstance **this, const void *a2)
{
  float v12[4] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = ausdk::AUBase::RestoreState(this, a2);
  int v4 = *((_DWORD *)this + 397);
  if (v4 == 1)
  {
    for (unsigned int i = 0; ; unsigned int i = v9 + 1)
    {
      unsigned int v10 = i;
      uint64_t v7 = this[268];
      unsigned int v8 = v7 == this[269] ? 0 : *(_DWORD *)v7;
      if (i >= v8) {
        break;
      }
      v11[0] = &unk_1F14AB0B8;
      v11[1] = this;
      v11[2] = &v10;
      v11[3] = v11;
      (*((void (**)(OpaqueAudioComponentInstance **))*this + 78))(this);
      std::__function::__value_func<void ()(unsigned int,unsigned int,float)>::~__value_func[abi:ne180100](v11);
      unsigned int v9 = v10;
      ++LODWORD(this[7 * v10 + 71]);
    }
  }
  else if (!v4)
  {
    v12[0] = &unk_1F14AB070;
    v12[1] = this;
    v12[3] = v12;
    (*((void (**)(OpaqueAudioComponentInstance **, void, void *))*this + 78))(this, 0, v12);
    std::__function::__value_func<void ()(unsigned int,unsigned int,float)>::~__value_func[abi:ne180100](v12);
    ++*((_DWORD *)this + 142);
  }
  *((unsigned char *)this + 1820) = 1;
  return v3;
}

void sub_1BB34C680(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  std::__function::__value_func<void ()(unsigned int,unsigned int,float)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *std::__function::__value_func<void ()(unsigned int,unsigned int,float)>::~__value_func[abi:ne180100](void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

float std::__function::__func<AUDspLib::RestoreState(void const*)::$_1,std::allocator<AUDspLib::RestoreState(void const*)::$_1>,void ()(unsigned int,unsigned int,float)>::operator()(uint64_t a1, unsigned int *a2, uint64_t a3, float *a4)
{
  float result = *a4;
  *(float *)(*(void *)(*(void *)(a1 + 8) + 56 * **(unsigned int **)(a1 + 16) + 544) + 4 * *a2) = *a4;
  return result;
}

__n128 std::__function::__func<AUDspLib::RestoreState(void const*)::$_1,std::allocator<AUDspLib::RestoreState(void const*)::$_1>,void ()(unsigned int,unsigned int,float)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F14AB0B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<AUDspLib::RestoreState(void const*)::$_1,std::allocator<AUDspLib::RestoreState(void const*)::$_1>,void ()(unsigned int,unsigned int,float)>::__clone(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)unint64_t v2 = &unk_1F14AB0B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<AUDspLib::RestoreState(void const*)::$_1,std::allocator<AUDspLib::RestoreState(void const*)::$_1>,void ()(unsigned int,unsigned int,float)>::~__func()
{
}

float std::__function::__func<AUDspLib::RestoreState(void const*)::$_0,std::allocator<AUDspLib::RestoreState(void const*)::$_0>,void ()(unsigned int,unsigned int,float)>::operator()(uint64_t a1, unsigned int *a2, uint64_t a3, float *a4)
{
  float result = *a4;
  *(float *)(*(void *)(*(void *)(a1 + 8) + 544) + 4 * *a2) = *a4;
  return result;
}

uint64_t std::__function::__func<AUDspLib::RestoreState(void const*)::$_0,std::allocator<AUDspLib::RestoreState(void const*)::$_0>,void ()(unsigned int,unsigned int,float)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F14AB070;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<AUDspLib::RestoreState(void const*)::$_0,std::allocator<AUDspLib::RestoreState(void const*)::$_0>,void ()(unsigned int,unsigned int,float)>::__clone(uint64_t a1)
{
  float result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *float result = &unk_1F14AB070;
  result[1] = v3;
  return result;
}

void std::__function::__func<AUDspLib::RestoreState(void const*)::$_0,std::allocator<AUDspLib::RestoreState(void const*)::$_0>,void ()(unsigned int,unsigned int,float)>::~__func()
{
}

UInt8 *AUDspLib::SaveExtendedScopes(AUDspLib *this, __CFData *a2)
{
  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, 4u);

  return ausdk::AUScope::SaveState(Scope, a2);
}

uint64_t ausdk::AUBase::GetScope(ausdk::AUBase *this, unsigned int a2)
{
  if (a2 < 4) {
    return (uint64_t)this + 48 * a2 + 32;
  }
  uint64_t result = (*(uint64_t (**)(ausdk::AUBase *))(*(void *)this + 408))(this);
  if (!result)
  {
    exception = (ausdk::AUException *)__cxa_allocate_exception(0x18uLL);
    ausdk::AUException::AUException(exception, -10866);
  }
  return result;
}

void sub_1BB34C950(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t AUDspLib::SaveState(AUDspLib *this, ausdk **a2)
{
  ausdk::AUBase::SaveState(this, a2);
  if (a2)
  {
    CFTypeID v4 = CFGetTypeID(*a2);
    if (v4 == CFDictionaryGetTypeID())
    {
      uint64_t valuePtr = *((unsigned int *)this + 451);
      CFNumberRef v5 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
      CFDictionarySetValue(*a2, @"DefaultAudioChannelLayout", v5);
      CFRelease(v5);
    }
  }
  return 0;
}

uint64_t AUDspLib::GetParameterInfo(AUDspLib *this, int a2, unsigned int a3, AudioUnitParameterInfo *buffer)
{
  if ((a2 & 0xFFFFFFFB) != 0) {
    return 4294956418;
  }
  if (*((_DWORD *)this + 439) <= a3) {
    return 4294956418;
  }
  uint64_t v6 = *(unsigned int *)(*((void *)this + 211) + 4 * a3);
  if (v6 >= *((_DWORD *)this + 438)) {
    return 4294956418;
  }
  uint64_t v8 = a3;
  AudioUnitParameterValue v9 = *(float *)(*((void *)this + 205) + 4 * v6);
  int v10 = *(_DWORD *)(*((void *)this + 203) + 4 * v6);
  buffer->unit = *(_DWORD *)(*((void *)this + 201) + 4 * v6);
  buffer->minValue = v9;
  buffer->maxValue = *(AudioUnitParameterValue *)(*((void *)this + 207) + 4 * v6);
  buffer->defaultValue = *(AudioUnitParameterValue *)(*((void *)this + 213) + 4 * a3);
  CFStringRef v11 = *(const __CFString **)(*((void *)this + 199) + 8 * v6);
  buffer->cfNameString = v11;
  buffer->flags = (v10 - 1048576000) | 0x8000000;
  CFStringGetCString(v11, buffer->name, 52, 0x8000100u);
  uint64_t result = 0;
  if (*((void *)this + 216))
  {
    buffer->clumpID = *(_DWORD *)(*((void *)this + 215) + 4 * v8);
    buffer->flags |= 0x100000u;
  }
  return result;
}

uint64_t AUDspLib::Render(AUDspLib *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  uint64_t v8 = (AUDspLib *)((char *)this + 80);
  uint64_t Element = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement((AUDspLib *)((char *)this + 80), 0);
  uint64_t result = ausdk::AUInputElement::PullInput(Element, a2, a3, 0, a4);
  if (!result)
  {
    uint64_t v11 = ausdk::AUScope::SafeGetElement(v8, 0);
    uint64_t BufferList = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v11 + 144));
    uint64_t v13 = ausdk::AUScope::SafeGetElement((AUDspLib *)((char *)this + 128), 0);
    uint64_t v14 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v13 + 144));
    unsigned int v15 = *(uint64_t (**)(AUDspLib *, unsigned int *, uint64_t, uint64_t, uint64_t))(*(void *)this + 176);
    return v15(this, a2, BufferList, v14, a4);
  }
  return result;
}

uint64_t AUDspLib::ProcessMultipleBufferLists(AUDspLib *this, unsigned int *a2, uint64_t a3, unsigned int a4, const AudioBufferList **a5, unsigned int a6, const AudioBufferList **a7)
{
  uint64_t v95 = a7;
  uint64_t v104 = *MEMORY[0x1E4F143B8];
  if (*((_DWORD *)this + 452) < a3) {
    return 4294956422;
  }
  if (!*((unsigned char *)this + 1585)) {
    return 4294956429;
  }
  uint64_t result = SimpleMeters::ProcessInputBufferList((AUDspLib *)((char *)this + 1832), a3, *a5);
  if (!result)
  {
    uint64_t v90 = (AUDspLib *)((char *)this + 1832);
    v89[0] = a2;
    uint64_t v92 = a3;
    if (a5 != v95)
    {
      unint64_t v13 = 0;
      for (uint64_t i = 16; ; i += 16)
      {
        unsigned int v15 = (unsigned int *)*((void *)this + 268);
        unint64_t v16 = v15 == *((unsigned int **)this + 269) ? 0 : *v15;
        if (v13 >= v16) {
          break;
        }
        int v17 = *(const void **)((char *)&(*a5)->mNumberBuffers + i);
        uint64_t result = *(void *)((char *)&(*v95)->mNumberBuffers + i);
        if (v17 != (const void *)result) {
          uint64_t result = (uint64_t)memcpy((void *)result, v17, 4 * v92);
        }
        ++v13;
      }
    }
    uint64_t v18 = a4;
    if (a4)
    {
      unsigned int v19 = 0;
      unsigned int v20 = 1;
      do
      {
        uint64_t result = ausdk::AUScope::SafeGetElement((AUDspLib *)((char *)this + 80), v19);
        if (*(_DWORD *)(result + 108) > v20) {
          unsigned int v20 = *(_DWORD *)(result + 108);
        }
        ++v19;
      }
      while (a4 != v19);
    }
    else
    {
      unsigned int v20 = 1;
    }
    unsigned int v93 = a4;
    v89[1] = v89;
    MEMORY[0x1F4188790](result);
    uint64_t v22 = (float *const *)((char *)v89 - v21);
    uint64_t Element = ausdk::AUScope::SafeGetElement((AUDspLib *)((char *)this + 128), 0);
    int v24 = *(_DWORD *)(Element + 108);
    if (v24)
    {
      p_mData = &(*v95)->mBuffers[0].mData;
      unint64_t v26 = (float **)v22;
      uint64_t v27 = *(unsigned int *)(Element + 108);
      do
      {
        vDSP_Length v28 = (float *)*p_mData;
        p_mData += 2;
        *v26++ = v28;
        --v27;
      }
      while (v27);
    }
    uint64_t v29 = *((void *)this + 265);
    unint64_t v94 = v92;
    DspLibBuffer::initializeWithExternalChannels(v29, v22, v92, v24);
    if (v93 >= 2)
    {
      unint64_t v30 = &v22[v20];
      uint64_t v31 = 1;
      do
      {
        uint64_t v32 = ausdk::AUScope::SafeGetElement((AUDspLib *)((char *)this + 80), v31);
        int v33 = *(_DWORD *)(v32 + 108);
        if (v33)
        {
          uint64_t v34 = v31 * v20;
          uint64_t v35 = &a5[v31]->mBuffers[0].mData;
          uint64_t v36 = (float **)v30;
          uint64_t v37 = *(unsigned int *)(v32 + 108);
          do
          {
            uint64_t v38 = (float *)*v35;
            v35 += 2;
            *v36++ = v38;
            --v37;
          }
          while (v37);
        }
        else
        {
          uint64_t v34 = v31 * v20;
        }
        DspLibBuffer::initializeWithExternalChannels(*((void *)this + 265) + 88 * v31++, &v22[v34], v94, v33);
        v30 += v20;
      }
      while (v31 != v18);
    }
    int v102 = (char *)this + 1824;
    int v39 = caulk::pooled_semaphore_mutex::try_lock((AUDspLib *)((char *)this + 1824));
    char v103 = v39;
    if (*((unsigned char *)this + 2113)) {
      int v40 = 0;
    }
    else {
      int v40 = v39;
    }
    int v41 = v92;
    if (v40 == 1)
    {
      unint64_t v42 = 0;
      unint64_t v43 = (uint64_t *)((char *)this + 528);
      while (1)
      {
        int v44 = *((_DWORD *)this + 397);
        if (v44)
        {
          unint64_t v45 = (unsigned int *)*((void *)this + 268);
          unint64_t v46 = v45 == *((unsigned int **)this + 269) ? 0 : *v45;
        }
        else
        {
          unint64_t v46 = 1;
        }
        if (v42 >= v46) {
          break;
        }
        unint64_t v47 = (DspLib::AlgorithmBase **)&v43[7 * v42];
        if (*v47)
        {
          if (v43[7 * v42 + 3] != v43[7 * v42 + 2])
          {
            unint64_t v48 = &v43[7 * v42];
            int v50 = *((_DWORD *)v48 + 10);
            unint64_t v49 = v48 + 5;
            if (v50 != v49[1])
            {
              (*(void (**)(AUDspLib *, unint64_t))(*(void *)this + 616))(this, v42);
              v49[1] = *v49;
              int v44 = *((_DWORD *)this + 397);
            }
          }
          if (v44)
          {
            if (v44 == 1)
            {
              float v51 = *v47;
              uint64_t v52 = DspLibBuffer::channel(*((DspLibBuffer **)this + 265), v42);
              uint64_t cycle_count = vp::utility::CPU_Profiler::get_cycle_count(*((vp::utility::CPU_Profiler **)this + 265));
              (*(void (**)(DspLib::AlgorithmBase *, uint64_t, uint64_t))(*(void *)v51 + 168))(v51, v52, cycle_count);
            }
          }
          else
          {
            uint64_t v54 = DspLibBuffer::numChannels(*((DspLibBuffer **)this + 265));
            MEMORY[0x1F4188790](v54);
            uint64_t v57 = (char *)v89 - v56;
            if (v55 >= 0x200) {
              size_t v58 = 512;
            }
            else {
              size_t v58 = v55;
            }
            bzero((char *)v89 - v56, v58);
            for (unint64_t j = 0; ; ++j)
            {
              unsigned int v60 = DspLibBuffer::numChannels(*((DspLibBuffer **)this + 265));
              uint64_t v61 = (DspLibBuffer *)*((void *)this + 265);
              if (j >= v60) {
                break;
              }
              *(void *)&v57[8 * j] = DspLibBuffer::channel(v61, j);
            }
            unsigned int v62 = DspLibBuffer::numChannels(v61);
            uint64_t v63 = vp::utility::CPU_Profiler::get_cycle_count(*((vp::utility::CPU_Profiler **)this + 265));
            uint64_t v64 = v62;
            if (v93 == 2)
            {
              uint64_t v65 = DspLibBuffer::numChannels((DspLibBuffer *)(*((void *)this + 265) + 88));
              uint64_t v91 = v89;
              MEMORY[0x1F4188790](v65);
              uint64_t v68 = (char *)v89 - v67;
              if (v66 >= 0x200) {
                size_t v69 = 512;
              }
              else {
                size_t v69 = v66;
              }
              bzero((char *)v89 - v67, v69);
              for (unint64_t k = 0; ; ++k)
              {
                unsigned int v71 = DspLibBuffer::numChannels((DspLibBuffer *)(*((void *)this + 265) + 88));
                float v72 = (DspLibBuffer *)(*((void *)this + 265) + 88);
                if (k >= v71) {
                  break;
                }
                *(void *)&v68[8 * k] = DspLibBuffer::channel(v72, k);
              }
              unsigned int v74 = DspLibBuffer::numChannels(v72);
              uint64_t v75 = vp::utility::CPU_Profiler::get_cycle_count((vp::utility::CPU_Profiler *)(*((void *)this + 265)
                                                                                           + 88));
              uint64_t v76 = *v47;
              v101[0] = v57;
              v101[1] = v64;
              v101[2] = v63;
              v100[0] = v57;
              v100[1] = v64;
              v100[2] = v63;
              v98[0] = v68;
              v98[1] = v74;
              v98[2] = v75;
              char v99 = 1;
              (*(void (**)(DspLib::AlgorithmBase *, void *, void *, void *))(*(void *)v76 + 144))(v76, v101, v100, v98);
            }
            else
            {
              float v73 = *v47;
              v97[0] = v57;
              v97[1] = v62;
              v97[2] = v63;
              (*(void (**)(DspLib::AlgorithmBase *, void *))(*(void *)v73 + 152))(v73, v97);
            }
          }
          AUDspLib::enqueueStatusForInstance(this, v42, *v47, v94);
        }
        ++v42;
      }
      uint64_t v77 = *v43;
      int v41 = v92;
      if (v77)
      {
        if (DspLibBuffer::numChannels(*((DspLibBuffer **)this + 265))
          && vp::utility::CPU_Profiler::get_instruction_count(*((vp::utility::CPU_Profiler **)this + 265)))
        {
          uint64_t v78 = DspLibBuffer::numChannels(*((DspLibBuffer **)this + 265));
          MEMORY[0x1F4188790](v78);
          uint64_t v81 = (char *)v89 - v80;
          if (v79 >= 0x200) {
            size_t v82 = 512;
          }
          else {
            size_t v82 = v79;
          }
          bzero((char *)v89 - v80, v82);
          for (unint64_t m = 0; ; ++m)
          {
            unsigned int v84 = DspLibBuffer::numChannels(*((DspLibBuffer **)this + 265));
            uint64_t v85 = (DspLibBuffer *)*((void *)this + 265);
            if (m >= v84) {
              break;
            }
            *(void *)&v81[8 * m] = DspLibBuffer::channel(v85, m);
          }
          unsigned int v86 = DspLibBuffer::numChannels(v85);
          uint64_t v87 = vp::utility::CPU_Profiler::get_cycle_count(*((vp::utility::CPU_Profiler **)this + 265));
          v96[0] = v81;
          v96[1] = v86;
          v96[2] = v87;
          unsigned __int8 v88 = DspLib::maxMagnitude(v96) == 0.0;
          *(_DWORD *)v89[0] = *(_DWORD *)v89[0] & 0xFFFFFFEF | (16 * (v88 & 1));
          atomic_store(v88, (unsigned __int8 *)this + 1821);
        }
      }
    }
    SimpleMeters::ProcessOutputBufferList(v90, v41, *v95);
    std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v102);
    return 0;
  }
  return result;
}

void sub_1BB34D314(_Unwind_Exception *a1)
{
  std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100](v1 - 112);
  _Unwind_Resume(a1);
}

uint64_t SimpleMeters::ProcessInputBufferList(SimpleMeters *this, int a2, const AudioBufferList *a3)
{
  if (!*((_DWORD *)this + 12)) {
    return 0;
  }
  uint64_t v4 = *(void *)this;
  uint64_t v5 = *((void *)this + 1);
  if (a3->mNumberBuffers == (v5 - *(void *)this) >> 7)
  {
    if (v5 != v4)
    {
      uint64_t v7 = 0;
      unint64_t v8 = 0;
      p_mData = &a3->mBuffers[0].mData;
      do
      {
        int v10 = (const float *)*p_mData;
        p_mData += 2;
        PowerMeter::Process((unsigned __int8 *)(v4 + v7), v10, a2);
        ++v8;
        uint64_t v4 = *(void *)this;
        v7 += 128;
      }
      while (v8 < (uint64_t)(*((void *)this + 1) - *(void *)this) >> 7);
    }
    return 0;
  }
  return 4294967246;
}

void *AUDspLib::enqueueStatusForInstance(void *this, unsigned int a2, DspLib::AlgorithmBase *a3, unint64_t a4)
{
  if (a3)
  {
    uint64_t v4 = this;
    this = (void *)this[a2 + 246];
    if (this)
    {
      if (*((unsigned char *)v4 + 2112))
      {
        unint64_t v5 = this[7];
        unint64_t v6 = this[6] + a4;
        this[6] = v6;
        this[9] = a4;
        if (v6 + (a4 >> 1) >= v5)
        {
          this[8] = v6;
          this[6] = 0;
          return (void *)AUDspLibStatus::Queue::push((AUDspLibStatus::Queue *)this, a3);
        }
      }
      else
      {
        uint64_t v7 = &v4[7 * a2];
        if (*((unsigned char *)v7 + 576))
        {
          unint64_t v8 = v7 + 72;
          this = (void *)AUDspLibStatus::Queue::push((AUDspLibStatus::Queue *)this, a3);
          *unint64_t v8 = 0;
        }
      }
    }
  }
  return this;
}

uint64_t SimpleMeters::ProcessOutputBufferList(SimpleMeters *this, int a2, const AudioBufferList *a3)
{
  if (!*((_DWORD *)this + 13)) {
    return 0;
  }
  uint64_t v4 = *((void *)this + 3);
  uint64_t v5 = *((void *)this + 4);
  if (a3->mNumberBuffers == (v5 - v4) >> 7)
  {
    if (v5 != v4)
    {
      uint64_t v7 = 0;
      unint64_t v8 = 0;
      p_mData = &a3->mBuffers[0].mData;
      do
      {
        int v10 = (const float *)*p_mData;
        p_mData += 2;
        PowerMeter::Process((unsigned __int8 *)(v4 + v7), v10, a2);
        ++v8;
        uint64_t v4 = *((void *)this + 3);
        v7 += 128;
      }
      while (v8 < (*((void *)this + 4) - v4) >> 7);
    }
    return 0;
  }
  return 4294967246;
}

uint64_t AUDspLibStatus::Queue::push(AUDspLibStatus::Queue *this, DspLib::AlgorithmBase *a2)
{
  ++*((void *)this + 5);
  uint64_t v4 = (unsigned int *)((char *)this + 32);
  unsigned int v5 = atomic_load((unsigned int *)this + 8);
  unint64_t v6 = (uint64_t *)(*((void *)this + 1) + 24 * v5);
  uint64_t v7 = *v6;
  uint64_t v8 = (v6[1] - *v6) >> 2;
  long long v26 = 0u;
  long long v27 = 0u;
  (*(void (**)(void *__return_ptr, DspLib::AlgorithmBase *))(*(void *)a2 + 208))(v25, a2);
  int32x2_t v10 = (int32x2_t)v25[0];
  uint64_t v9 = v25[1];
  uint64_t v11 = v25[2];
  (*(void (**)(DspLib::AlgorithmBase *, uint64_t, uint64_t))(*(void *)a2 + 184))(a2, v7, v8);
  uint64_t v12 = *((void *)this + 5);
  uint64_t v14 = *((void *)this + 8);
  uint64_t v13 = *((void *)this + 9);
  uint64_t result = (*(uint64_t (**)(DspLib::AlgorithmBase *))(*(void *)a2 + 64))(a2);
  double v17 = *((double *)this + 10);
  uint64_t v18 = *((void *)this + 12);
  uint64_t v19 = 4;
  if ((unint64_t)(v18 + 1) < 4) {
    uint64_t v19 = v18 + 1;
  }
  unint64_t v20 = (v18 - v19 + 5) % 5uLL - (5 - v19) + 1;
  if (v20 != atomic_load_explicit((atomic_ullong *volatile)this + 20, memory_order_acquire))
  {
    float v21 = v16 / v17 * 1000.0;
    uint64_t v22 = (char *)this + 104 * v18 + 96;
    *((int32x2_t *)v22 + 9) = vrev64_s32(v10);
    *((void *)v22 + 10) = v9;
    *((void *)v22 + 11) = v14;
    *((void *)v22 + 12) = v12;
    *((void *)v22 + 13) = v13;
    long long v23 = v27;
    *((_OWORD *)v22 + 7) = v26;
    *((_OWORD *)v22 + 8) = v23;
    *((float *)v22 + 36) = v21;
    *(void *)(v22 + 148) = v11;
    *((void *)v22 + 20) = v7;
    *((void *)v22 + 21) = v8;
    atomic_store(v20, (unint64_t *)this + 12);
    unsigned int v24 = atomic_load(v4);
    atomic_store((v24 + 1) % (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)this + 2) - *((void *)this + 1)) >> 3)), v4);
  }
  return result;
}

uint64_t AUDspLib::ProcessBufferLists(AUDspLib *this, unsigned int *a2, const AudioBufferList *a3, AudioBufferList *a4, uint64_t a5)
{
  unint64_t v6 = a4;
  uint64_t v7 = a3;
  return (*(uint64_t (**)(AUDspLib *, unsigned int *, uint64_t, uint64_t, const AudioBufferList **, uint64_t, AudioBufferList **))(*(void *)this + 184))(this, a2, a5, 1, &v7, 1, &v6);
}

uint64_t AUDspLib::SetParameter(AUDspLib *this, unsigned int a2, unsigned int a3, unsigned int a4, float a5)
{
  if (a4 > 0x11) {
    return 4294956419;
  }
  if (*((_DWORD *)this + 439) > a2)
  {
    int v11 = *((_DWORD *)this + 397);
    if (!(v11 | a3))
    {
      *(float *)(*((void *)this + 68) + 4 * *(unsigned int *)(*((void *)this + 211) + 4 * a2)) = a5;
      ++*((_DWORD *)this + 142);
    }
    if (a3 == 4 && v11 == 1)
    {
      uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUDspLib *)((char *)this + 1536), a4);
      ausdk::AUElement::SetParameter(Element, a2, a5, 0);
      uint64_t v13 = (char *)this + 56 * a4;
      *(float *)(*((void *)v13 + 68) + 4 * *(unsigned int *)(*((void *)this + 211) + 4 * a2)) = a5;
      ++*((_DWORD *)v13 + 142);
    }
    goto LABEL_11;
  }
  if (a2 == 1937141612 || a2 == 1869769061)
  {
LABEL_11:
    *((unsigned char *)this + 1820) = 1;
    Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
    unsigned int v15 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
    ausdk::AUElement::SetParameter(v15, a2, a5, 0);
    return 0;
  }
  return 4294956418;
}

uint64_t AUDspLib::SetProperty(AUDspLib *this, int a2, int a3, unsigned int a4, int *a5, void *a6, int *a7)
{
  unsigned int v7 = a6;
  unsigned int v30 = 0;
  if (SimpleMeters::HandleSetProperty((AUDspLib *)((char *)this + 1832), a2, a3, a5, a6, (int *)&v30, a7)) {
    return v30;
  }
  if (a2 == 21 && !a3)
  {
    if (v7 < 4) {
      return 4294956445;
    }
    int v16 = *a5;
    if ((v16 != 0) != (*((unsigned char *)this + 2113) != 0))
    {
      if (!v16 && *((unsigned char *)this + 2113))
      {
        if (*((unsigned char *)this + 17)) {
          (*(void (**)(AUDspLib *, void, void))(*(void *)this + 72))(this, 0, 0);
        }
      }
      uint64_t result = 0;
      *((unsigned char *)this + 2113) = v16 != 0;
      return result;
    }
    return 0;
  }
  uint64_t result = 4294956417;
  if (a2 <= 6603)
  {
    if (a2 != 6601)
    {
      int v14 = 6602;
      goto LABEL_12;
    }
    int v17 = *((_DWORD *)this + 397);
    if ((!a3 || v17) && (a3 == 4 || v17 != 1))
    {
      if (a4 <= 0x11)
      {
        UInt8 buffer = 0;
        if (v7 != 8) {
          return 4294956445;
        }
        if (v17) {
          uint64_t v18 = a4;
        }
        else {
          uint64_t v18 = 0;
        }
        v33.location = 0;
        v33.length = 1;
        CFDataGetBytes(*(CFDataRef *)a5, v33, &buffer);
        int v19 = buffer;
        BOOL v20 = buffer != 0;
        *((unsigned char *)this + 2112) = buffer > 1u;
        float v21 = (char *)this + 56 * v18;
        v21[536] = v20;
        uint64_t v22 = (DspLib::AlgorithmBase *)(*(uint64_t (**)(AUDspLib *, uint64_t))(*(void *)this + 632))(this, v18);
        AUDspLib::allocateStatusQueueForInstance(this, v18, v22);
        long long v23 = (AUDspLib *)((char *)this + 1824);
        caulk::pooled_semaphore_mutex::_lock(v23);
        uint64_t v24 = *((void *)v21 + 66);
        if (v24) {
          (*(void (**)(uint64_t, BOOL))(*(void *)v24 + 200))(v24, v19 != 0);
        }
        caulk::pooled_semaphore_mutex::_unlock(v23);
        return 0;
      }
      return 4294956419;
    }
    return 4294956430;
  }
  if (a2 == 6626)
  {
    int v25 = *((_DWORD *)this + 397);
    if ((!a3 || v25) && (a3 == 4 || v25 != 1))
    {
      if (a4 <= 0x11)
      {
        uint64_t result = (uint64_t)CFDictionaryGetValue(*(CFDictionaryRef *)a5, @"DefaultAudioChannelLayout");
        if (!result) {
          return result;
        }
        CFNumberRef v26 = (const __CFNumber *)result;
        CFTypeID v27 = CFGetTypeID((CFTypeRef)result);
        if (v27 == CFNumberGetTypeID())
        {
          unint64_t v29 = 0;
          CFNumberGetValue(v26, kCFNumberSInt64Type, &v29);
          if (HIDWORD(v29)) {
            return 4294901760;
          }
          if (*((_DWORD *)this + 451) != v29)
          {
            *((_DWORD *)this + 451) = v29;
            if (*((_DWORD *)this + 450) == -65536)
            {
              caulk::pooled_semaphore_mutex::_lock((AUDspLib *)((char *)this + 1824));
              AUDspLib::initializeDspLibAlgorithms((uint64_t)this, v28);
              caulk::pooled_semaphore_mutex::_unlock((AUDspLib *)((char *)this + 1824));
            }
          }
        }
        return 0;
      }
      return 4294956419;
    }
    return 4294956430;
  }
  int v14 = 6604;
LABEL_12:
  if (a2 == v14)
  {
    if (*((unsigned char *)this + 1586))
    {
      if (*((unsigned char *)this + 1585)) {
        uint64_t result = 4294956447;
      }
      else {
        uint64_t result = 4294956430;
      }
      if (!a3 && !*((unsigned char *)this + 1585))
      {
        if (a2 == 6604)
        {
          if (v7 != 8) {
            return 4294956445;
          }
          CFDictionaryRef v15 = *(const __CFDictionary **)a5;
          return AUDspLib::setChannelSplitMode(this, v15);
        }
        else
        {
          if (v7 != 4) {
            return 4294956445;
          }
          uint64_t result = 0;
          *((_DWORD *)this + 397) = *a5;
        }
      }
    }
    else
    {
      return 4294956446;
    }
  }
  return result;
}

void sub_1BB34DC44(_Unwind_Exception *a1)
{
  caulk::pooled_semaphore_mutex::_unlock(v1);
  _Unwind_Resume(a1);
}

BOOL SimpleMeters::HandleSetProperty(SimpleMeters *this, int a2, int a3, int *a4, const void *a5, int *a6, int *a7)
{
  *a6 = 0;
  if (a2 == 3007)
  {
    if (a5 <= 3)
    {
      int v8 = -50;
LABEL_4:
      *a6 = v8;
      return a2 == 3007;
    }
    if (a3 == 2)
    {
      int v10 = *a4;
      int v11 = *((_DWORD *)this + 12);
    }
    else if (a3 == 1)
    {
      int v10 = *((_DWORD *)this + 13);
      int v11 = *a4;
    }
    else
    {
      if (a3)
      {
        int v8 = -10866;
        goto LABEL_4;
      }
      int v10 = *a4;
      int v11 = *a4;
    }
    if (v11 && !*((_DWORD *)this + 12))
    {
      uint64_t v12 = *((void *)this + 1);
      if (v12 == *(void *)this)
      {
        std::vector<PowerMeter>::resize((void **)this, *((unsigned int *)this + 21));
      }
      else
      {
        uint64_t v13 = *(void *)this + 52;
        do
        {
          *(void *)(v13 + 12) = 0;
          *(_WORD *)(v13 + 4) = 0;
          *(void *)(v13 + 36) = 0;
          *(void *)(v13 + 28) = 0;
          *(void *)(v13 + 52) = 0;
          *(void *)(v13 + 44) = 0;
          *(void *)(v13 + 68) = 0;
          uint64_t v14 = v13 + 76;
          *(void *)(v13 + 60) = 0;
          *(void *)(v13 - 4) = 0xFFFFFFFFLL;
          v13 += 128;
        }
        while (v14 != v12);
      }
      CFDictionaryRef v15 = *(double **)this;
      int v16 = (double *)*((void *)this + 1);
      if (*(double **)this != v16)
      {
        double v17 = *((double *)this + 7);
        if (v17 * 2.5 >= 2.22507386e-308) {
          double v18 = -2.76310211 / v17;
        }
        else {
          double v18 = -INFINITY;
        }
        double v19 = exp(v18);
        if (v18 >= -708.4) {
          double v20 = v19;
        }
        else {
          double v20 = 0.0;
        }
        if (v17 * 1.24 >= 2.22507386e-308) {
          double v21 = -5.57077039 / v17;
        }
        else {
          double v21 = -INFINITY;
        }
        double v22 = exp(v21);
        if (v21 < -708.4) {
          double v22 = 0.0;
        }
        do
        {
          v15[1] = v17;
          v15[2] = v20;
          v15[4] = v22;
          v15 += 16;
        }
        while (v15 != v16);
      }
    }
    if (v10 && !*((_DWORD *)this + 13))
    {
      uint64_t v24 = *((void *)this + 3);
      uint64_t v23 = *((void *)this + 4);
      if (v23 == v24)
      {
        std::vector<PowerMeter>::resize((void **)this + 3, *((unsigned int *)this + 31));
      }
      else
      {
        uint64_t v25 = v24 + 52;
        do
        {
          *(void *)(v25 + 12) = 0;
          *(_WORD *)(v25 + 4) = 0;
          *(void *)(v25 + 36) = 0;
          *(void *)(v25 + 28) = 0;
          *(void *)(v25 + 52) = 0;
          *(void *)(v25 + 44) = 0;
          *(void *)(v25 + 68) = 0;
          uint64_t v26 = v25 + 76;
          *(void *)(v25 + 60) = 0;
          *(void *)(v25 - 4) = 0xFFFFFFFFLL;
          v25 += 128;
        }
        while (v26 != v23);
      }
      CFTypeID v27 = (double *)*((void *)this + 3);
      __n128 v28 = (double *)*((void *)this + 4);
      if (v27 != v28)
      {
        double v29 = *((double *)this + 12);
        if (v29 * 2.5 >= 2.22507386e-308) {
          double v30 = -2.76310211 / v29;
        }
        else {
          double v30 = -INFINITY;
        }
        double v31 = exp(v30);
        if (v30 >= -708.4) {
          double v32 = v31;
        }
        else {
          double v32 = 0.0;
        }
        if (v29 * 1.24 >= 2.22507386e-308) {
          double v33 = -5.57077039 / v29;
        }
        else {
          double v33 = -INFINITY;
        }
        double v34 = exp(v33);
        if (v33 < -708.4) {
          double v34 = 0.0;
        }
        do
        {
          v27[1] = v29;
          v27[2] = v32;
          v27[4] = v34;
          v27 += 16;
        }
        while (v27 != v28);
      }
    }
    __dmb(0xBu);
    *((_DWORD *)this + 12) = v11;
    *((_DWORD *)this + 13) = v10;
  }
  return a2 == 3007;
}

uint64_t AUDspLib::setChannelSplitMode(AUDspLib *this, CFDictionaryRef theDict)
{
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"channelSplitMode");
  if (!Value) {
    return 4294956445;
  }
  CFNumberRef v4 = Value;
  CFTypeID v5 = CFGetTypeID(Value);
  if (v5 != CFNumberGetTypeID()) {
    return 4294956445;
  }
  unint64_t valuePtr = 0;
  if (!CFNumberGetValue(v4, kCFNumberSInt64Type, &valuePtr) || HIDWORD(valuePtr)) {
    return 4294956445;
  }
  uint64_t result = 0;
  *((_DWORD *)this + 397) = valuePtr;
  return result;
}

unsigned char *AUDspLib::allocateStatusQueueForInstance(unsigned char *this, int a2, DspLib::AlgorithmBase *a3)
{
  if (this[56 * a2 + 536])
  {
    uint64_t v3 = this;
    if (this[1585])
    {
      (*(void (**)(unsigned char *))(*(void *)this + 608))(this);
      ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v3 + 80), 0);
      operator new();
    }
  }
  return this;
}

void sub_1BB34E168(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(v11 + 96), memory_order_acquire);
  unint64_t v14 = *(void *)(v11 + 160);
  uint64_t v15 = v14 - explicit;
  BOOL v18 = v14 > explicit;
  uint64_t v16 = 5;
  if (!v18) {
    uint64_t v16 = 0;
  }
  if (v16 != v15)
  {
    unint64_t v17 = v16 + explicit;
    unint64_t v19 = v17 - 5;
    BOOL v18 = v17 > 5;
    if (v17 == 5) {
      unint64_t v17 = 0;
    }
    if (v18) {
      unint64_t v17 = v19;
    }
    atomic_store(v17, (unint64_t *)(v11 + 160));
  }
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  MEMORY[0x1C185D370](v11, 0x1020C406132200BLL);
  _Unwind_Resume(a1);
}

uint64_t std::default_delete<AUDspLibStatus::Queue>::operator()[abi:ne180100](uint64_t a1)
{
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(a1 + 96), memory_order_acquire);
  unint64_t v3 = *(void *)(a1 + 160);
  BOOL v7 = v3 >= explicit;
  unint64_t v4 = v3 - explicit;
  BOOL v8 = v3 == explicit;
  uint64_t v5 = 5;
  if (v8 || !v7) {
    uint64_t v5 = 0;
  }
  if (v5 != v4)
  {
    unint64_t v6 = v5 + explicit;
    BOOL v7 = v6 >= 5;
    unint64_t v9 = v6 - 5;
    BOOL v8 = v6 == 5;
    if (v6 == 5) {
      unint64_t v6 = 0;
    }
    if (!v8 && v7) {
      unint64_t v6 = v9;
    }
    atomic_store(v6, (unint64_t *)(a1 + 160));
  }
  uint64_t v11 = (void **)(a1 + 8);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v11);
  return MEMORY[0x1C185D370](a1, 0x1020C406132200BLL);
}

uint64_t std::vector<std::vector<float>>::emplace_back<std::vector<float>>(uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  BOOL v7 = *(void **)(result - 8);
  if ((unint64_t)v7 >= v6)
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - *a1) >> 3);
    unint64_t v10 = v9 + 1;
    if (v9 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v11 > v10) {
      unint64_t v10 = 2 * v11;
    }
    if (v11 >= 0x555555555555555) {
      unint64_t v12 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v12 = v10;
    }
    v16[4] = result;
    uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::__fs::filesystem::path>>(result, v12);
    unint64_t v14 = &v13[24 * v9];
    v16[0] = v13;
    v16[1] = v14;
    v16[3] = &v13[24 * v15];
    *((void *)v14 + 1) = 0;
    *((void *)v14 + 2) = 0;
    *(void *)unint64_t v14 = 0;
    *(_OWORD *)unint64_t v14 = *(_OWORD *)a2;
    *((void *)v14 + 2) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    v16[2] = v14 + 24;
    std::vector<std::vector<float>>::__swap_out_circular_buffer(a1, v16);
    BOOL v8 = (void *)a1[1];
    uint64_t result = std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)v16);
  }
  else
  {
    *BOOL v7 = 0;
    v7[1] = 0;
    v7[2] = 0;
    *(_OWORD *)BOOL v7 = *(_OWORD *)a2;
    v7[2] = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    BOOL v8 = v7 + 3;
    a1[1] = (uint64_t)(v7 + 3);
  }
  a1[1] = (uint64_t)v8;
  return result;
}

void sub_1BB34E39C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<PowerMeter>::resize(void **a1, unint64_t a2)
{
  unint64_t v5 = (char *)*a1;
  unint64_t v4 = (char *)a1[1];
  unint64_t v6 = (v4 - (unsigned char *)*a1) >> 7;
  if (a2 <= v6)
  {
    if (a2 < v6) {
      a1[1] = &v5[128 * a2];
    }
  }
  else
  {
    BOOL v7 = a1[2];
    if (a2 - v6 <= (v7 - v4) >> 7)
    {
      uint64_t v24 = &v4[128 * (a2 - v6)];
      do
      {
        char *v4 = 0;
        *(_OWORD *)(v4 + 8) = xmmword_1BB879C60;
        *(_OWORD *)(v4 + 24) = xmmword_1BB879C70;
        *((void *)v4 + 8) = 0;
        *((_WORD *)v4 + 28) = 0;
        *((void *)v4 + 10) = 0;
        *((void *)v4 + 11) = 0;
        *((void *)v4 + 12) = 0;
        *((void *)v4 + 13) = 0;
        *((void *)v4 + 14) = 0;
        *((void *)v4 + 15) = 0;
        *((void *)v4 + 5) = 0x3F90624DD2F1A9FCLL;
        *((void *)v4 + 6) = 0xFFFFFFFFLL;
        v4 += 128;
      }
      while (v4 != v24);
      a1[1] = v24;
    }
    else
    {
      if (a2 >> 57) {
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v8 = v7 - v5;
      unint64_t v9 = (v7 - v5) >> 6;
      if (v9 <= a2) {
        unint64_t v9 = a2;
      }
      if (v8 >= 0x7FFFFFFFFFFFFF80) {
        unint64_t v10 = 0x1FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v10 = v9;
      }
      if (v10 >> 57) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      unint64_t v11 = (char *)operator new(v10 << 7);
      unint64_t v12 = &v11[128 * v6];
      uint64_t v13 = &v11[128 * a2];
      unint64_t v14 = v12;
      do
      {
        char *v14 = 0;
        *(_OWORD *)(v14 + 8) = xmmword_1BB879C60;
        *(_OWORD *)(v14 + 24) = xmmword_1BB879C70;
        *((void *)v14 + 8) = 0;
        *((_WORD *)v14 + 28) = 0;
        *((void *)v14 + 10) = 0;
        *((void *)v14 + 11) = 0;
        *((void *)v14 + 12) = 0;
        *((void *)v14 + 13) = 0;
        *((void *)v14 + 14) = 0;
        *((void *)v14 + 15) = 0;
        *((void *)v14 + 5) = 0x3F90624DD2F1A9FCLL;
        *((void *)v14 + 6) = 0xFFFFFFFFLL;
        v14 += 128;
      }
      while (v14 != v13);
      uint64_t v15 = &v11[128 * v10];
      unint64_t v17 = (char *)*a1;
      uint64_t v16 = (char *)a1[1];
      if (v16 != *a1)
      {
        do
        {
          long long v18 = *((_OWORD *)v16 - 8);
          long long v19 = *((_OWORD *)v16 - 7);
          long long v20 = *((_OWORD *)v16 - 5);
          *((_OWORD *)v12 - 6) = *((_OWORD *)v16 - 6);
          *((_OWORD *)v12 - 5) = v20;
          *((_OWORD *)v12 - 8) = v18;
          *((_OWORD *)v12 - 7) = v19;
          long long v21 = *((_OWORD *)v16 - 4);
          long long v22 = *((_OWORD *)v16 - 3);
          long long v23 = *((_OWORD *)v16 - 1);
          *((_OWORD *)v12 - 2) = *((_OWORD *)v16 - 2);
          *((_OWORD *)v12 - 1) = v23;
          *((_OWORD *)v12 - 4) = v21;
          *((_OWORD *)v12 - 3) = v22;
          v12 -= 128;
          v16 -= 128;
        }
        while (v16 != v17);
        uint64_t v16 = (char *)*a1;
      }
      *a1 = v12;
      a1[1] = v13;
      a1[2] = v15;
      if (v16)
      {
        operator delete(v16);
      }
    }
  }
}

uint64_t AUDspLib::GetProperty(AUDspLib *this, int a2, unsigned int a3, unsigned int a4, CFDictionaryRef *a5, int *a6)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  unsigned int v22 = 0;
  if (SimpleMeters::HandleGetProperty((AUDspLib *)((char *)this + 1832), a2, a3, a5, &v22, a6)) {
    return v22;
  }
  if (a2 == 21 && !a3)
  {
    uint64_t result = 0;
    int v12 = *((unsigned __int8 *)this + 2113);
LABEL_6:
    *(_DWORD *)a5 = v12;
    return result;
  }
  if (a2 == 6610)
  {
    int v28 = 0;
    uint64_t v27 = 0;
    LODWORD(bytes) = (*(uint64_t (**)(AUDspLib *))(*(void *)this + 576))(this);
    strcpy((char *)&bytes + 4, "Nov 10 2024");
    strcpy((char *)v26, "03:50:19");
    v26[3] = *((_DWORD *)this + 397);
    CFDataRef v13 = CFDataCreate(0, (const UInt8 *)&bytes, 44);
    uint64_t result = 0;
    *a5 = v13;
    return result;
  }
  uint64_t result = 4294956417;
  switch(a2)
  {
    case 6600:
      return AUDspLib::getPropertyStatus(this, a3, a4, a5);
    case 6601:
      int v14 = *((_DWORD *)this + 397);
      if (a3 && !v14 || a3 != 4 && v14 == 1) {
        return 4294956430;
      }
      if (a4 > 0x11) {
        return 4294956419;
      }
      LOBYTE(bytes) = 0;
      if (v14) {
        unsigned int v15 = a4;
      }
      else {
        unsigned int v15 = 0;
      }
      caulk::pooled_semaphore_mutex::_lock((AUDspLib *)((char *)this + 1824));
      uint64_t v16 = *((void *)this + 7 * v15 + 66);
      if (v16) {
        LOBYTE(bytes) = (*(uint64_t (**)(uint64_t))(*(void *)v16 + 192))(v16);
      }
      *a5 = CFDataCreate(0, (const UInt8 *)&bytes, 1);
      caulk::pooled_semaphore_mutex::_unlock((AUDspLib *)((char *)this + 1824));
      return 0;
    case 6602:
    case 6604:
      if (*((unsigned char *)this + 1586)) {
        uint64_t result = 4294956430;
      }
      else {
        uint64_t result = 4294956446;
      }
      if (a3 || !*((unsigned char *)this + 1586)) {
        return result;
      }
      if (a2 == 6604)
      {
        AUDspLib::getChannelSplitMode(this, a5);
        return 0;
      }
      uint64_t result = 0;
      int v12 = *((_DWORD *)this + 397);
      goto LABEL_6;
    case 6603:
      return result;
    default:
      if (a2 != 6626)
      {
        if (a2 == 6650)
        {
          return AUDspLib::getPropertyDspLibAUParameters(this, a3, a4, a5);
        }
        return result;
      }
      int v17 = *((_DWORD *)this + 397);
      if (a3 && !v17 || a3 != 4 && v17 == 1) {
        return 4294956430;
      }
      if (a4 > 0x11) {
        return 4294956419;
      }
      int v18 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUDspLib *)((char *)this + 80), 0) + 108);
      if (v18 == 1)
      {
        uint64_t v19 = 6553601;
        goto LABEL_50;
      }
      if (v18 == 2)
      {
        uint64_t v19 = 6619138;
LABEL_50:
        *((_DWORD *)this + 450) = v19;
        goto LABEL_52;
      }
      uint64_t v19 = *((unsigned int *)this + 450);
LABEL_52:
      *(void *)&long long bytes = @"SelectedAudioChannelLayout";
      *((void *)&bytes + 1) = @"DefaultAudioChannelLayout";
      uint64_t valuePtr = v19;
      uint64_t v20 = *((unsigned int *)this + 451);
      values = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
      CFNumberRef v24 = CFNumberCreate(0, kCFNumberSInt64Type, &v20);
      *a5 = CFDictionaryCreate(0, (const void **)&bytes, (const void **)&values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      CFRelease(values);
      CFRelease(v24);
      return 0;
  }
}

void sub_1BB34E9A4(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t SimpleMeters::HandleGetProperty(SimpleMeters *this, int a2, unsigned int a3, _DWORD *a4, _DWORD *a5, int *a6)
{
  *a5 = 0;
  if (a2 == 3099)
  {
    if (a3 > 1 || (uint64_t v10 = *(void *)this, v11 = *((void *)this + 1), *(void *)this == v11))
    {
      int v12 = 0;
      CFDataRef v13 = 0;
      unint64_t v14 = 0;
    }
    else
    {
      int v12 = 0;
      CFDataRef v13 = 0;
      unint64_t v14 = 0;
      do
      {
        unint64_t Value = PowerMeter::GetValue((PowerMeter *)v10);
        unint64_t v17 = Value;
        unint64_t v18 = v16;
        if ((unint64_t)v13 >= v14)
        {
          uint64_t v19 = ((char *)v13 - (char *)v12) >> 4;
          unint64_t v20 = v19 + 1;
          if ((unint64_t)(v19 + 1) >> 60) {
            std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
          }
          if ((uint64_t)(v14 - (void)v12) >> 3 > v20) {
            unint64_t v20 = (uint64_t)(v14 - (void)v12) >> 3;
          }
          if (v14 - (unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v21 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v21 = v20;
          }
          if (v21) {
            unint64_t v21 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float (ASAFeatures::*)(ASAFrontEndInputState const*)>>(v21);
          }
          else {
            uint64_t v22 = 0;
          }
          long long v23 = (unint64_t *)(v21 + 16 * v19);
          *long long v23 = v17;
          v23[1] = v18;
          if (v13 == v12)
          {
            uint64_t v25 = (unint64_t *)(v21 + 16 * v19);
          }
          else
          {
            unint64_t v24 = v21 + 16 * v19;
            do
            {
              uint64_t v25 = (unint64_t *)(v24 - 16);
              *(_OWORD *)(v24 - 16) = *((_OWORD *)v13 - 1);
              v13 -= 2;
              v24 -= 16;
            }
            while (v13 != v12);
          }
          unint64_t v14 = v21 + 16 * v22;
          CFDataRef v13 = v23 + 2;
          if (v12) {
            operator delete(v12);
          }
          int v12 = v25;
        }
        else
        {
          *CFDataRef v13 = Value;
          v13[1] = v16;
          v13 += 2;
        }
        *(_WORD *)(v10 + 56) = 0;
        *(_DWORD *)(v10 + 52) = 0;
        v10 += 128;
      }
      while (v10 != v11);
    }
    if ((a3 & 0xFFFFFFFD) == 0)
    {
      uint64_t v26 = *((void *)this + 3);
      for (uint64_t i = *((void *)this + 4); v26 != i; v26 += 128)
      {
        unint64_t v28 = PowerMeter::GetValue((PowerMeter *)v26);
        unint64_t v30 = v28;
        unint64_t v31 = v29;
        if ((unint64_t)v13 >= v14)
        {
          uint64_t v32 = ((char *)v13 - (char *)v12) >> 4;
          unint64_t v33 = v32 + 1;
          if ((unint64_t)(v32 + 1) >> 60) {
            std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
          }
          if ((uint64_t)(v14 - (void)v12) >> 3 > v33) {
            unint64_t v33 = (uint64_t)(v14 - (void)v12) >> 3;
          }
          if (v14 - (unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v34 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v34 = v33;
          }
          if (v34) {
            unint64_t v34 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float (ASAFeatures::*)(ASAFrontEndInputState const*)>>(v34);
          }
          else {
            uint64_t v35 = 0;
          }
          uint64_t v36 = (unint64_t *)(v34 + 16 * v32);
          *uint64_t v36 = v30;
          v36[1] = v31;
          if (v13 == v12)
          {
            uint64_t v38 = (unint64_t *)(v34 + 16 * v32);
          }
          else
          {
            unint64_t v37 = v34 + 16 * v32;
            do
            {
              uint64_t v38 = (unint64_t *)(v37 - 16);
              *(_OWORD *)(v37 - 16) = *((_OWORD *)v13 - 1);
              v13 -= 2;
              v37 -= 16;
            }
            while (v13 != v12);
          }
          unint64_t v14 = v34 + 16 * v35;
          CFDataRef v13 = v36 + 2;
          if (v12) {
            operator delete(v12);
          }
          int v12 = v38;
        }
        else
        {
          *CFDataRef v13 = v28;
          v13[1] = v29;
          v13 += 2;
        }
        *(_WORD *)(v26 + 56) = 0;
        *(_DWORD *)(v26 + 52) = 0;
      }
    }
    memcpy(a4, v12, (char *)v13 - (char *)v12);
    if (v12) {
      operator delete(v12);
    }
    return 1;
  }
  uint64_t result = 0;
  if (a2 != 3007) {
    return result;
  }
  if (a3 == 2)
  {
    int v9 = *((_DWORD *)this + 13);
  }
  else if (a3 == 1)
  {
    int v9 = *((_DWORD *)this + 12);
  }
  else
  {
    if (a3)
    {
      *a5 = -10866;
      return 1;
    }
    int v9 = *((_DWORD *)this + 12);
    if (v9) {
      int v9 = *((_DWORD *)this + 13) != 0;
    }
  }
  *a4 = v9;
  return 1;
}

void sub_1BB34ECA8(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void AUDspLib::getChannelSplitMode(AUDspLib *this, const __CFDictionary **a2)
{
  CFNumberRef v3 = CFNumberCreate(0, kCFNumberIntType, (char *)this + 1588);
  Mutable = CFDictionaryCreateMutable(0, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionarySetValue(Mutable, @"channelSplitMode", v3);
  *a2 = CFDictionaryCreateCopy(0, Mutable);
  CFRelease(v3);

  CFRelease(Mutable);
}

uint64_t AUDspLib::getPropertyStatus(AUDspLib *this, int a2, unsigned int a3, CFDictionaryRef *a4)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  int v6 = *((_DWORD *)this + 397);
  if (a2 && !v6 || a2 != 4 && v6 == 1) {
    return 4294956430;
  }
  if (a3 > 0x11) {
    return 4294956419;
  }
  if (v6) {
    uint64_t v8 = a3;
  }
  else {
    uint64_t v8 = 0;
  }
  int v9 = (unint64_t *)*((void *)this + v8 + 246);
  if (!v9) {
    return 4294956417;
  }
  if (*((unsigned char *)this + 2112))
  {
    std::vector<float>::vector(&__p, *v9);
    *(_OWORD *)unint64_t v34 = 0u;
    long long v35 = 0u;
    memset(v36, 0, sizeof(v36));
    long long v37 = 0u;
    int v38 = 0;
    int v39 = (const UInt8 *)__p;
    uint64_t v40 = (v42 - (unsigned char *)__p) >> 2;
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    unint64_t v28 = v9;
    CFMutableArrayRef v33 = Mutable;
    uint64_t v29 = (uint64_t)(v9 + 12);
    while (1)
    {
      *(void *)&long long v44 = v34;
      if (!boost::lockfree::detail::compile_time_sized_ringbuffer<AUDspLibStatus::Status,4ul>::consume_one<boost::lockfree::detail::consume_via_copy<AUDspLibStatus::Status>>(v29, (uint64_t *)&v44))break; {
      CFDataRef v11 = CFDataCreate(0, v39, 4 * v40);
      }
      if (!v11)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Could not construct");
      }
      applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)&cf, v11);
      applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v44, "buffer");
      CFTypeRef v12 = cf;
      if (cf) {
        CFRetain(cf);
      }
      *((void *)&v44 + 1) = v12;
      applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned long &>((applesauce::CF::TypeRef *)&v45, "statusCounter", (uint64_t *)&v35 + 1);
      applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned long &>((applesauce::CF::TypeRef *)&v46, "audioBlockSize", (uint64_t *)v36);
      applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned long &>((applesauce::CF::TypeRef *)&v47, "numFramesForStatus", (uint64_t *)&v35);
      applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,float &>((applesauce::CF::TypeRef *)&v48, "percentCPUAverage", (int *)v34 + 1);
      applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,float &>((applesauce::CF::TypeRef *)&v49, "percentCPUPeak", (int *)v34);
      applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,float &>((applesauce::CF::TypeRef *)&v51, "megaCyclesPerSecondAverage", (int *)&v34[1]);
      applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,float &>((applesauce::CF::TypeRef *)&v52, "megaCyclesPerSecondPeak", (int *)((unint64_t)v34 | 0xC));
      applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,float &>((applesauce::CF::TypeRef *)&v53, "latencyInMilliseconds", (int *)&v37 + 2);
      applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,float &>((applesauce::CF::TypeRef *)&v54, "megaInstructionsPerSecondAverage", (int *)&v37 + 3);
      applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,float &>((applesauce::CF::TypeRef *)v55, "megaInstructionsPerSecondPeak", &v38);
      CFDataRef v13 = Mutable;
      unint64_t v31 = &v44;
      uint64_t v32 = 11;
      CFDictionaryRef CFDictionaryRef = applesauce::CF::details::make_CFDictionaryRef((uint64_t)&v31);
      uint64_t v15 = 0;
      uint64_t valuePtr = (uint64_t)CFDictionaryRef;
      do
      {
        unint64_t v16 = *(const void **)&v55[v15 + 8];
        if (v16) {
          CFRelease(v16);
        }
        unint64_t v17 = *(const void **)&v55[v15];
        if (v17) {
          CFRelease(v17);
        }
        v15 -= 16;
      }
      while (v15 != -176);
      if (cf) {
        CFRelease(cf);
      }
      CFMutableArrayRef Mutable = v13;
      CFArrayAppendValue(v13, CFDictionaryRef);
      if (CFDictionaryRef) {
        CFRelease(CFDictionaryRef);
      }
    }
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v44, "queueSize");
    uint64_t valuePtr = 4;
    *((void *)&v44 + 1) = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
    if (!*((void *)&v44 + 1))
    {
      uint64_t v26 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v26, "Could not construct");
    }
    applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned long &>((applesauce::CF::TypeRef *)&v45, "numAudioChannels", (uint64_t *)v28 + 11);
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v46, "audioSampleRate");
    uint64_t valuePtr = v28[10];
    *((void *)&v46 + 1) = CFNumberCreate(0, kCFNumberDoubleType, &valuePtr);
    if (!*((void *)&v46 + 1))
    {
      uint64_t v27 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v27, "Could not construct");
    }
    if (Mutable) {
      CFRetain(Mutable);
    }
    applesauce::CF::ArrayRef::ArrayRef((applesauce::CF::ArrayRef *)&valuePtr, Mutable);
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v47, "arrayOfDictionaries");
    uint64_t v18 = valuePtr;
    if (valuePtr) {
      CFRetain((CFTypeRef)valuePtr);
    }
    *((void *)&v47 + 1) = v18;
    unint64_t v31 = &v44;
    uint64_t v32 = 4;
    CFDictionaryRef v19 = applesauce::CF::details::make_CFDictionaryRef((uint64_t)&v31);
    for (uint64_t i = 0; i != -64; i -= 16)
    {
      unint64_t v21 = *(const void **)((char *)&v47 + i + 8);
      if (v21) {
        CFRelease(v21);
      }
      uint64_t v22 = *(const void **)((char *)&v47 + i);
      if (v22) {
        CFRelease(v22);
      }
    }
    if (valuePtr) {
      CFRelease((CFTypeRef)valuePtr);
    }
    if (Mutable) {
      CFRelease(Mutable);
    }
    if (__p)
    {
      unint64_t v42 = __p;
      operator delete(__p);
    }
    uint64_t result = 0;
    *a4 = v19;
  }
  else
  {
    unsigned int v23 = (*(uint64_t (**)(AUDspLib *))(*(void *)this + 608))(this);
    std::vector<float>::vector(v34, v23);
    long long v44 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v48 = 0u;
    int v49 = 0;
    int v50 = v34[0];
    int64_t v51 = ((char *)v34[1] - (char *)v34[0]) >> 2;
    do
    {
      uint64_t v24 = *((void *)this + v8 + 246) + 96;
      __p = &v44;
    }
    while (boost::lockfree::detail::compile_time_sized_ringbuffer<AUDspLibStatus::Status,4ul>::consume_one<boost::lockfree::detail::consume_via_copy<AUDspLibStatus::Status>>(v24, (uint64_t *)&__p));
    *((unsigned char *)this + 56 * v8 + 576) = 1;
    *a4 = CFDataCreate(0, (const UInt8 *)v34[0], (char *)v34[1] - (char *)v34[0]);
    if (v34[0])
    {
      v34[1] = v34[0];
      operator delete(v34[0]);
    }
    return 0;
  }
  return result;
}

void sub_1BB34F364(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,const void *a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *__p,uint64_t a46,uint64_t a47,char a48,int a49,__int16 a50,char a51,char a52,CFTypeRef a53,uint64_t a54,uint64_t a55,uint64_t a56,CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  applesauce::CF::TypeRef::~TypeRef(v57);
  while (v57 != (const void **)&a50)
  {
    v57 -= 2;
    applesauce::CF::TypeRefPair::~TypeRefPair((applesauce::CF::TypeRefPair *)v57);
  }
  applesauce::CF::ObjectRef<__CFArray *>::~ObjectRef(&a30);
  if (__p)
  {
    a46 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t AUDspLib::getPropertyDspLibAUParameters(AUDspLib *this, int a2, unsigned int a3, CFMutableDictionaryRef *a4)
{
  float v12[4] = *MEMORY[0x1E4F143B8];
  int v7 = *((_DWORD *)this + 397);
  if (a2 && !v7 || a2 != 4 && v7 == 1) {
    return 4294956430;
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (*((_DWORD *)this + 397)) {
    uint64_t v10 = a3;
  }
  else {
    uint64_t v10 = 0;
  }
  CFMutableDictionaryRef v11 = Mutable;
  v12[0] = &unk_1F14AB100;
  v12[1] = &v11;
  v12[3] = v12;
  (*(void (**)(AUDspLib *, uint64_t, void *))(*(void *)this + 624))(this, v10, v12);
  std::__function::__value_func<void ()(unsigned int,unsigned int,float)>::~__value_func[abi:ne180100](v12);
  uint64_t result = 0;
  *a4 = v11;
  return result;
}

void sub_1BB34F68C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(unsigned int,unsigned int,float)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void std::__function::__func<AUDspLib::getPropertyDspLibAUParameters(unsigned int,unsigned int,void *)::$_0,std::allocator<AUDspLib::getPropertyDspLibAUParameters(unsigned int,unsigned int,void *)::$_0>,void ()(unsigned int,unsigned int,float)>::operator()(uint64_t a1, uint64_t a2, unsigned int *a3, int *a4)
{
  uint64_t v5 = *a3;
  int valuePtr = *a4;
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%d", v5);
  CFNumberRef v8 = CFNumberCreate(v6, kCFNumberFloatType, &valuePtr);
  CFDictionaryAddValue(**(CFMutableDictionaryRef **)(a1 + 8), v7, v8);
  CFRelease(v7);
  CFRelease(v8);
}

uint64_t std::__function::__func<AUDspLib::getPropertyDspLibAUParameters(unsigned int,unsigned int,void *)::$_0,std::allocator<AUDspLib::getPropertyDspLibAUParameters(unsigned int,unsigned int,void *)::$_0>,void ()(unsigned int,unsigned int,float)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F14AB100;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<AUDspLib::getPropertyDspLibAUParameters(unsigned int,unsigned int,void *)::$_0,std::allocator<AUDspLib::getPropertyDspLibAUParameters(unsigned int,unsigned int,void *)::$_0>,void ()(unsigned int,unsigned int,float)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F14AB100;
  result[1] = v3;
  return result;
}

void std::__function::__func<AUDspLib::getPropertyDspLibAUParameters(unsigned int,unsigned int,void *)::$_0,std::allocator<AUDspLib::getPropertyDspLibAUParameters(unsigned int,unsigned int,void *)::$_0>,void ()(unsigned int,unsigned int,float)>::~__func()
{
}

BOOL boost::lockfree::detail::compile_time_sized_ringbuffer<AUDspLibStatus::Status,4ul>::consume_one<boost::lockfree::detail::consume_via_copy<AUDspLibStatus::Status>>(uint64_t a1, uint64_t *a2)
{
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)a1, memory_order_acquire);
  uint64_t v3 = *(void *)(a1 + 64);
  if (explicit != v3)
  {
    uint64_t v5 = a1 + 104 * v3;
    uint64_t v6 = *a2;
    CFStringRef v7 = *(void **)(*a2 + 88);
    CFNumberRef v8 = *(void **)(v5 + 160);
    *(void *)(*a2 + 96) = *(void *)(v5 + 168);
    DspLib::copy(v8, *(void *)(v5 + 168), v7);
    long long v9 = *(_OWORD *)(v5 + 88);
    *(_OWORD *)uint64_t v6 = *(_OWORD *)(v5 + 72);
    *(_OWORD *)(v6 + 16) = v9;
    *(void *)(v6 + 32) = *(void *)(v5 + 104);
    *(void *)(v6 + 40) = *(void *)(v5 + 112);
    *(void *)(v6 + 48) = *(void *)(v5 + 120);
    *(void *)(v6 + 72) = *(void *)(v5 + 144);
    *(_DWORD *)(v6 + 80) = *(_DWORD *)(v5 + 152);
    uint64_t v10 = 4;
    if ((unint64_t)(v3 + 1) < 4) {
      uint64_t v10 = v3 + 1;
    }
    atomic_store((v3 - v10 + 5) % 5uLL - (5 - v10) + 1, (unint64_t *)(a1 + 64));
  }
  return explicit != v3;
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned long &>(applesauce::CF::TypeRef *a1, char *a2, uint64_t *a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  uint64_t valuePtr = *a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
  *((void *)a1 + 1) = v5;
  if (!v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1BB34F940(_Unwind_Exception *a1)
{
  uint64_t v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,float &>(applesauce::CF::TypeRef *a1, char *a2, int *a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  int valuePtr = *a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((void *)a1 + 1) = v5;
  if (!v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1BB34FA14(_Unwind_Exception *a1)
{
  uint64_t v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

unint64_t PowerMeter::GetValue(PowerMeter *this)
{
  double v2 = *((double *)this + 14);
  if (v2 <= 0.000001)
  {
    uint64_t v4 = 3270508544;
  }
  else
  {
    *(float *)&unsigned int v3 = log10(fmax(v2, 2.22507386e-308)) * 20.0;
    uint64_t v4 = v3;
  }
  double v5 = *((double *)this + 15);
  if (v5 <= 0.000001)
  {
    unint64_t v7 = 0xC2F0000000000000;
  }
  else
  {
    *(float *)&unsigned int v6 = log10(fmax(v5, 2.22507386e-308)) * 20.0;
    unint64_t v7 = (unint64_t)v6 << 32;
  }
  return v7 | v4;
}

uint64_t AUDspLib::GetPropertyInfo(AUDspLib *this, int a2, unsigned int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  if (a2 == 3007)
  {
    BOOL v8 = 1;
    unsigned int v9 = 4;
LABEL_13:
    uint64_t result = 0;
    *a5 = v9;
    *a6 = v8;
    return result;
  }
  if (a2 == 3099)
  {
    if (a3 > 1) {
      uint64_t v7 = 0;
    }
    else {
      uint64_t v7 = (uint64_t)(*((void *)this + 230) - *((void *)this + 229)) >> 7;
    }
    if ((a3 & 0xFFFFFFFD) == 0) {
      v7 += (uint64_t)(*((void *)this + 233) - *((void *)this + 232)) >> 7;
    }
    BOOL v8 = 0;
    unsigned int v9 = 16 * v7;
    goto LABEL_13;
  }
  if (a2 != 21 || a3)
  {
    uint64_t result = 4294956417;
    switch(a2)
    {
      case 6600:
        if ((a3 & 0xFFFFFFFB) == 0) {
          goto LABEL_29;
        }
        return 4294956430;
      case 6601:
        goto LABEL_25;
      case 6602:
      case 6604:
        int v12 = *((unsigned __int8 *)this + 1586);
        if (v12) {
          uint64_t result = 4294956430;
        }
        else {
          uint64_t result = 4294956446;
        }
        if (a3 || !v12) {
          return result;
        }
        uint64_t result = 0;
        *a6 = 1;
        if (a2 == 6604) {
          unsigned int v11 = 8;
        }
        else {
          unsigned int v11 = 4;
        }
        break;
      case 6603:
      case 6605:
      case 6606:
      case 6607:
      case 6608:
      case 6609:
        return result;
      case 6610:
LABEL_29:
        uint64_t result = 0;
        *a6 = 0;
        goto LABEL_30;
      default:
        if (a2 != 6626 && a2 != 6650) {
          return result;
        }
LABEL_25:
        if ((a3 & 0xFFFFFFFB) != 0) {
          return 4294956430;
        }
        uint64_t result = 0;
        *a6 = 1;
LABEL_30:
        unsigned int v11 = 8;
        break;
    }
  }
  else
  {
    uint64_t result = 0;
    *a6 = 1;
    unsigned int v11 = 4;
  }
  *a5 = v11;
  return result;
}

uint64_t AUDspLib::Reset(AUDspLib *this)
{
  if (*((unsigned char *)this + 1585))
  {
    caulk::pooled_semaphore_mutex::_lock((AUDspLib *)((char *)this + 1824));
    for (uint64_t i = 0; i != 1008; i += 56)
    {
      uint64_t v3 = *(void *)((char *)this + i + 528);
      if (v3) {
        (*(void (**)(uint64_t))(*(void *)v3 + 136))(v3);
      }
    }
    caulk::pooled_semaphore_mutex::_unlock((AUDspLib *)((char *)this + 1824));
  }
  SimpleMeters::Reset((uint64_t)this + 1832);
  return 0;
}

void sub_1BB34FD0C(_Unwind_Exception *a1)
{
  caulk::pooled_semaphore_mutex::_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t SimpleMeters::Reset(uint64_t this)
{
  if (*(_DWORD *)(this + 48))
  {
    uint64_t v1 = *(void *)(this + 8);
    if (*(void *)this != v1)
    {
      uint64_t v2 = *(void *)this + 52;
      do
      {
        *(void *)(v2 + 12) = 0;
        *(_WORD *)(v2 + 4) = 0;
        *(void *)(v2 + 36) = 0;
        *(void *)(v2 + 28) = 0;
        *(void *)(v2 + 52) = 0;
        *(void *)(v2 + 44) = 0;
        *(void *)(v2 + 68) = 0;
        uint64_t v3 = v2 + 76;
        *(void *)(v2 + 60) = 0;
        *(void *)(v2 - 4) = 0xFFFFFFFFLL;
        v2 += 128;
      }
      while (v3 != v1);
    }
  }
  if (*(_DWORD *)(this + 52))
  {
    uint64_t v5 = *(void *)(this + 24);
    uint64_t v4 = *(void *)(this + 32);
    if (v5 != v4)
    {
      uint64_t v6 = v5 + 52;
      do
      {
        *(void *)(v6 + 12) = 0;
        *(_WORD *)(v6 + 4) = 0;
        *(void *)(v6 + 36) = 0;
        *(void *)(v6 + 28) = 0;
        *(void *)(v6 + 52) = 0;
        *(void *)(v6 + 44) = 0;
        *(void *)(v6 + 68) = 0;
        uint64_t v7 = v6 + 76;
        *(void *)(v6 + 60) = 0;
        *(void *)(v6 - 4) = 0xFFFFFFFFLL;
        v6 += 128;
      }
      while (v7 != v4);
    }
  }
  return this;
}

void AUDspLib::Cleanup(AUDspLib *this)
{
  (*(void (**)(AUDspLib *))(*(void *)this + 592))(this);
  *((unsigned char *)this + 1585) = 0;
  *((void *)this + 226) = 0;
  *((void *)this + 230) = *((void *)this + 229);
  *((void *)this + 233) = *((void *)this + 232);
  uint64_t v2 = *((void *)this + 266);
  uint64_t v3 = *((void *)this + 265);
  while (v2 != v3)
    DspLibBuffer::~DspLibBuffer((DspLibBuffer *)(v2 - 88));
  *((void *)this + 266) = v3;
  *((void *)this + 269) = *((void *)this + 268);
}

uint64_t AUDspLib::Initialize(AUDspLib *this)
{
  v48[4] = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)this + 1585)) {
    (*(void (**)(AUDspLib *))(*(void *)this + 64))(this);
  }
  *((unsigned char *)this + 1584) = 0;
  v45[0] = 0;
  AppBooleanunint64_t Value = CACFPreferencesGetAppBooleanValue(@"FactoryDiagsMode", @"com.apple.coreaudio", v45);
  if (v45[0]) {
    *((unsigned char *)this + 1584) = AppBooleanValue;
  }
  uint64_t v3 = *((void *)this + 21);
  if (v3) {
    LODWORD(v4) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  else {
    uint64_t v4 = (*((void *)this + 19) - *((void *)this + 18)) >> 3;
  }
  if (v4 > 1) {
    return 4294956428;
  }
  int v5 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUDspLib *)((char *)this + 80), 0) + 108);
  int v6 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUDspLib *)((char *)this + 128), 0) + 108);
  *(void *)long long v45 = 0;
  unsigned int v7 = (*(uint64_t (**)(AUDspLib *, BOOL *))(*(void *)this + 376))(this, v45);
  if (!v7) {
    return 4294956428;
  }
  uint64_t v8 = v7;
  for (uint64_t i = (__int16 *)(*(void *)v45 + 2); v5 != *(i - 1) || v6 != *i; i += 2)
  {
    if (!--v8) {
      return 4294956428;
    }
  }
  unsigned int v10 = 0;
  unsigned int v11 = (void **)((char *)this + 2144);
  *((void *)this + 269) = *((void *)this + 268);
  while (1)
  {
    uint64_t v12 = *((void *)this + 15);
    if (v12) {
      LODWORD(v13) = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 24))(v12);
    }
    else {
      uint64_t v13 = (*((void *)this + 13) - *((void *)this + 12)) >> 3;
    }
    if (v10 >= v13) {
      break;
    }
    uint64_t Element = ausdk::AUScope::SafeGetElement((AUDspLib *)((char *)this + 80), v10);
    uint64_t v15 = Element;
    unint64_t v16 = (char *)*((void *)this + 269);
    unint64_t v17 = *((void *)this + 270);
    if ((unint64_t)v16 >= v17)
    {
      CFDictionaryRef v19 = (char *)*v11;
      uint64_t v20 = (v16 - (unsigned char *)*v11) >> 2;
      unint64_t v21 = v20 + 1;
      if ((unint64_t)(v20 + 1) >> 62) {
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v22 = v17 - (void)v19;
      if (v22 >> 1 > v21) {
        unint64_t v21 = v22 >> 1;
      }
      if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v23 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v23 = v21;
      }
      if (v23)
      {
        uint64_t v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)this + 2160, v23);
        unint64_t v16 = (char *)*((void *)this + 269);
        CFDictionaryRef v19 = (char *)*((void *)this + 268);
      }
      else
      {
        uint64_t v24 = 0;
      }
      uint64_t v25 = &v24[4 * v20];
      *(_DWORD *)uint64_t v25 = *(_DWORD *)(v15 + 108);
      uint64_t v18 = v25 + 4;
      while (v16 != v19)
      {
        int v26 = *((_DWORD *)v16 - 1);
        v16 -= 4;
        *((_DWORD *)v25 - 1) = v26;
        v25 -= 4;
      }
      *((void *)this + 268) = v25;
      *((void *)this + 269) = v18;
      *((void *)this + 270) = &v24[4 * v23];
      if (v19) {
        operator delete(v19);
      }
    }
    else
    {
      *(_DWORD *)unint64_t v16 = *(_DWORD *)(Element + 108);
      uint64_t v18 = v16 + 4;
    }
    *((void *)this + 269) = v18;
    ++v10;
  }
  if (*(double *)(ausdk::AUScope::SafeGetElement((AUDspLib *)((char *)this + 128), 0) + 80) <= 0.0) {
    return 4294956428;
  }
  *((_DWORD *)this + 453) = vcvtad_u64_f64(*(double *)(ausdk::AUScope::SafeGetElement((AUDspLib *)((char *)this + 128), 0)+ 80));
  double v27 = *(double *)(ausdk::AUScope::SafeGetElement((AUDspLib *)((char *)this + 128), 0) + 80);
  if (v27 != *(double *)(ausdk::AUScope::SafeGetElement((AUDspLib *)((char *)this + 80), 0) + 80)) {
    return 4294956428;
  }
  *((_DWORD *)this + 452) = *((_DWORD *)this + 84);
  if (!*((_DWORD *)this + 397))
  {
    *(_DWORD *)long long v45 = 0;
    unsigned int v31 = 1;
LABEL_45:
    uint64_t v32 = 0;
    do
    {
      v48[0] = &unk_1F14AB028;
      v48[1] = this;
      v48[2] = v45;
      v48[3] = v48;
      (*(void (**)(AUDspLib *, uint64_t, void *))(*(void *)this + 624))(this, v32, v48);
      std::__function::__value_func<void ()(unsigned int,unsigned int,float)>::~__value_func[abi:ne180100](v48);
      uint64_t v32 = (*(_DWORD *)v45 + 1);
      *(_DWORD *)long long v45 = v32;
    }
    while (v32 < v31);
    uint64_t v29 = (unsigned int *)*((void *)this + 268);
    unint64_t v30 = (unsigned int *)*((void *)this + 269);
    goto LABEL_48;
  }
  uint64_t v29 = (unsigned int *)*((void *)this + 268);
  unint64_t v30 = (unsigned int *)*((void *)this + 269);
  if (v29 == v30) {
    goto LABEL_54;
  }
  unsigned int v31 = *v29;
  *(_DWORD *)long long v45 = 0;
  if (v31) {
    goto LABEL_45;
  }
LABEL_48:
  if (v29 != v30)
  {
    unsigned int v33 = *v29;
    if (v33 == 1)
    {
      int v34 = 6553601;
      goto LABEL_53;
    }
    if (v33 == 2)
    {
      int v34 = 6619138;
LABEL_53:
      *((_DWORD *)this + 450) = v34;
    }
  }
LABEL_54:
  (*(void (**)(AUDspLib *))(*(void *)this + 584))(this);
  uint64_t v35 = ausdk::AUScope::SafeGetElement((AUDspLib *)((char *)this + 80), 0);
  long long v36 = *(_OWORD *)(v35 + 96);
  *(_OWORD *)long long v45 = *(_OWORD *)(v35 + 80);
  long long v46 = v36;
  uint64_t v47 = *(void *)(v35 + 112);
  uint64_t v37 = ausdk::AUScope::SafeGetElement((AUDspLib *)((char *)this + 128), 0);
  long long v38 = *(_OWORD *)(v37 + 96);
  v43[0] = *(_OWORD *)(v37 + 80);
  v43[1] = v38;
  uint64_t v44 = *(void *)(v37 + 112);
  SimpleMeters::Initialize((AUDspLib *)((char *)this + 1832), (const CAStreamBasicDescription *)v45, (const CAStreamBasicDescription *)v43);
  uint64_t v39 = *((void *)this + 15);
  if (v39) {
    LODWORD(v40) = (*(uint64_t (**)(uint64_t))(*(void *)v39 + 24))(v39);
  }
  else {
    uint64_t v40 = (*((void *)this + 13) - *((void *)this + 12)) >> 3;
  }
  std::vector<DspLibBuffer>::resize((void *)this + 265, v40);
  uint64_t v41 = 0;
  *((unsigned char *)this + 1585) = 1;
  unint64_t v42 = (DspLib::AlgorithmBase **)((char *)this + 528);
  do
  {
    AUDspLib::allocateStatusQueueForInstance(this, v41, *v42);
    uint64_t result = 0;
    ++v41;
    v42 += 7;
  }
  while (v41 != 18);
  return result;
}

void sub_1BB350390(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  std::__function::__value_func<void ()(unsigned int,unsigned int,float)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void SimpleMeters::Initialize(SimpleMeters *this, const CAStreamBasicDescription *a2, const CAStreamBasicDescription *a3)
{
  long long v4 = *(_OWORD *)a2;
  long long v5 = *((_OWORD *)a2 + 1);
  *((void *)this + 11) = *((void *)a2 + 4);
  *(_OWORD *)((char *)this + 72) = v5;
  *(_OWORD *)((char *)this + 56) = v4;
  long long v6 = *(_OWORD *)a3;
  long long v7 = *((_OWORD *)a3 + 1);
  *((void *)this + 16) = *((void *)a3 + 4);
  *((_OWORD *)this + 6) = v6;
  *((_OWORD *)this + 7) = v7;
  if (*((_DWORD *)this + 12))
  {
    std::vector<PowerMeter>::resize((void **)this, *((unsigned int *)this + 21));
    uint64_t v8 = *(double **)this;
    unsigned int v9 = (double *)*((void *)this + 1);
    if (*(double **)this != v9)
    {
      double v10 = *((double *)this + 7);
      if (v10 * 2.5 >= 2.22507386e-308) {
        double v11 = -2.76310211 / v10;
      }
      else {
        double v11 = -INFINITY;
      }
      double v12 = exp(v11);
      if (v11 >= -708.4) {
        double v13 = v12;
      }
      else {
        double v13 = 0.0;
      }
      if (v10 * 1.24 >= 2.22507386e-308) {
        double v14 = -5.57077039 / v10;
      }
      else {
        double v14 = -INFINITY;
      }
      double v15 = exp(v14);
      if (v14 < -708.4) {
        double v15 = 0.0;
      }
      do
      {
        v8[1] = v10;
        v8[2] = v13;
        v8[4] = v15;
        v8 += 16;
      }
      while (v8 != v9);
    }
  }
  if (*((_DWORD *)this + 13))
  {
    std::vector<PowerMeter>::resize((void **)this + 3, *((unsigned int *)this + 31));
    unint64_t v16 = (double *)*((void *)this + 3);
    unint64_t v17 = (double *)*((void *)this + 4);
    if (v16 != v17)
    {
      double v18 = *((double *)this + 12);
      if (v18 * 2.5 >= 2.22507386e-308) {
        double v19 = -2.76310211 / v18;
      }
      else {
        double v19 = -INFINITY;
      }
      double v20 = exp(v19);
      if (v19 >= -708.4) {
        double v21 = v20;
      }
      else {
        double v21 = 0.0;
      }
      if (v18 * 1.24 >= 2.22507386e-308) {
        double v22 = -5.57077039 / v18;
      }
      else {
        double v22 = -INFINITY;
      }
      double v23 = exp(v22);
      if (v22 < -708.4) {
        double v23 = 0.0;
      }
      do
      {
        v16[1] = v18;
        v16[2] = v21;
        v16[4] = v23;
        v16 += 16;
      }
      while (v16 != v17);
    }
  }
}

void std::vector<DspLibBuffer>::resize(void *a1, unint64_t a2)
{
  uint64_t v4 = *a1;
  long long v5 = (DspLibBuffer *)a1[1];
  unint64_t v6 = 0x2E8BA2E8BA2E8BA3 * (((uint64_t)v5 - *a1) >> 3);
  unint64_t v7 = a2 - v6;
  if (a2 <= v6)
  {
    if (a2 < v6)
    {
      double v23 = (DspLibBuffer *)(v4 + 88 * a2);
      while (v5 != v23)
      {
        long long v5 = (DspLibBuffer *)((char *)v5 - 88);
        DspLibBuffer::~DspLibBuffer(v5);
      }
      a1[1] = v23;
    }
  }
  else
  {
    uint64_t v8 = a1[2];
    if (0x2E8BA2E8BA2E8BA3 * ((v8 - (uint64_t)v5) >> 3) >= v7)
    {
      uint64_t v24 = (char *)v5 + 88 * v7;
      uint64_t v25 = 88 * a2 - 8 * (((uint64_t)v5 - *a1) >> 3);
      do
      {
        DspLibBuffer::DspLibBuffer(v5);
        long long v5 = (DspLibBuffer *)((char *)v5 + 88);
        v25 -= 88;
      }
      while (v25);
      a1[1] = v24;
    }
    else
    {
      if (a2 > 0x2E8BA2E8BA2E8BALL) {
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v9 = 0x2E8BA2E8BA2E8BA3 * ((v8 - v4) >> 3);
      uint64_t v10 = 2 * v9;
      if (2 * v9 <= a2) {
        uint64_t v10 = a2;
      }
      if (v9 >= 0x1745D1745D1745DLL) {
        unint64_t v11 = 0x2E8BA2E8BA2E8BALL;
      }
      else {
        unint64_t v11 = v10;
      }
      unsigned int v31 = a1 + 2;
      if (v11 > 0x2E8BA2E8BA2E8BALL) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v12 = 88 * v11;
      double v13 = (char *)operator new(88 * v11);
      double v14 = (DspLibBuffer *)&v13[88 * v6];
      uint64_t v29 = v13;
      *(void *)unint64_t v30 = v14;
      *(void *)&v30[8] = v14;
      *(void *)&v30[16] = &v13[v12];
      uint64_t v15 = 88 * a2;
      unint64_t v16 = &v13[88 * a2];
      unint64_t v17 = v15 - 88 * v6;
      do
      {
        DspLibBuffer::DspLibBuffer(v14);
        double v14 = (DspLibBuffer *)((char *)v14 + 88);
        v17 -= 88;
      }
      while (v17);
      *(void *)&v30[8] = v16;
      uint64_t v19 = *a1;
      uint64_t v18 = a1[1];
      for (uint64_t i = 88; ; i -= 88)
      {
        uint64_t v21 = *(void *)v30 + i;
        if (v18 + i - 88 == v19) {
          break;
        }
        double v22 = (const DspLibBuffer *)(v18 + i - 176);
        DspLibBuffer::DspLibBuffer((DspLibBuffer *)(v21 - 176), v22);
      }
      uint64_t v26 = a1[2];
      long long v27 = *(_OWORD *)&v30[8];
      long long v28 = *(_OWORD *)a1;
      *a1 = v21 - 88;
      *(_OWORD *)unint64_t v30 = v28;
      *(_OWORD *)(a1 + 1) = v27;
      *(void *)&v30[16] = v26;
      uint64_t v29 = (char *)v28;
      std::__split_buffer<DspLibBuffer>::~__split_buffer((uint64_t)&v29);
    }
  }
}

uint64_t std::__split_buffer<DspLibBuffer>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 88;
    DspLibBuffer::~DspLibBuffer((DspLibBuffer *)(i - 88));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

float std::__function::__func<AUDspLib::Initialize(void)::$_0,std::allocator<AUDspLib::Initialize(void)::$_0>,void ()(unsigned int,unsigned int,float)>::operator()(uint64_t a1, unsigned int *a2, uint64_t a3, float *a4)
{
  float result = *a4;
  *(float *)(*(void *)(*(void *)(a1 + 8) + 56 * **(unsigned int **)(a1 + 16) + 544) + 4 * *a2) = *a4;
  return result;
}

__n128 std::__function::__func<AUDspLib::Initialize(void)::$_0,std::allocator<AUDspLib::Initialize(void)::$_0>,void ()(unsigned int,unsigned int,float)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F14AB028;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<AUDspLib::Initialize(void)::$_0,std::allocator<AUDspLib::Initialize(void)::$_0>,void ()(unsigned int,unsigned int,float)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F14AB028;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<AUDspLib::Initialize(void)::$_0,std::allocator<AUDspLib::Initialize(void)::$_0>,void ()(unsigned int,unsigned int,float)>::~__func()
{
}

void AUDspLib::CreateExtendedElements(AUDspLib *this)
{
  if (*((unsigned char *)this + 1586))
  {
    uint64_t v1 = (AUDspLib *)((char *)this + 1536);
    ausdk::AUScope::Initialize((AUDspLib *)((char *)this + 1536), this, 4, 18);
    uint64_t v2 = 0;
    do
    {
      CFStringRef v3 = CFStringCreateWithFormat(0, 0, @"channel %d", v2);
      uint64_t Element = ausdk::AUScope::GetElement(v1, v2);
      ausdk::Owned<__CFString const*>::operator=((const void **)(Element + 72), v3);
      CFRelease(v3);
      uint64_t v2 = (v2 + 1);
    }
    while (v2 != 18);
  }
}

uint64_t ausdk::AUScope::Initialize(ausdk::AUScope *this, ausdk::AUBase *a2, int a3, uint64_t a4)
{
  *(void *)this = a2;
  *((_DWORD *)this + 2) = a3;
  uint64_t v5 = *((void *)this + 5);
  if (!v5) {
    return ausdk::AUScope::SetNumberOfElements(this, a4);
  }
  *(void *)(v5 + 8) = a2;
  *(_DWORD *)(v5 + 16) = a3;
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 16))(v5, a4);
}

uint64_t AUDspLibWithNewParameters::gatherParametersForInstance(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = a1 + 2176;
  uint64_t v8 = (ausdk::AUScope *)(a1 + 1536);
  unint64_t v9 = (ausdk::AUScope *)(a1 + 32);
  while (1)
  {
    uint64_t result = DspLib::algorithmOffset(v7, *(_DWORD *)(a1 + 2192) + 1);
    if (v6 >= result) {
      break;
    }
    uint64_t v11 = DspLib::parameterAddress(v7, v6);
    unsigned int v13 = (***(uint64_t (****)(void, uint64_t, void))(a1 + 2168))(*(void *)(a1 + 2168), v11, v12);
    if (*(_DWORD *)(a1 + 1588) == 1) {
      uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::GetElement(v8, a2);
    }
    else {
      uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(v9, 0);
    }
    float Parameter = ausdk::AUElement::GetParameter(Element, v13);
    uint64_t v16 = *(void *)(a3 + 24);
    if (v16) {
      std::function<void ()(unsigned int,unsigned int,float)>::operator()(v16, v6, v13, Parameter);
    }
    uint64_t v6 = (v6 + 1);
  }
  return result;
}

void AUDspLibWithNewParameters::setParametersOnInstance(AUDspLibWithNewParameters *this, unsigned int a2)
{
  if (*((_DWORD *)this + 548) != -1)
  {
    uint64_t v3 = 0;
    unsigned int v4 = 0;
    uint64_t v5 = *((void *)this + 7 * a2 + 66);
    uint64_t v6 = (void *)((char *)this + 56 * a2 + 544);
    do
    {
      unsigned int v7 = v4;
      uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 256))(v5, v3);
      uint64_t v10 = *(void *)v8;
      unsigned int v12 = 0;
      uint64_t v13 = 0;
      __p = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__p, *(const void **)(v8 + 8), *(void *)(v8 + 16), (uint64_t)(*(void *)(v8 + 16) - *(void *)(v8 + 8)) >> 2);
      for (uint64_t i = 0; ; uint64_t i = (i + 1))
      {
        unsigned int v4 = v7 + i;
        if (i >= DspLib::groupOffset(v10, *(_DWORD *)(*(void *)(v10 + 8) + 8))) {
          break;
        }
        DspLib::AlgorithmParametersInstance::setValue((DspLib::AlgorithmParametersInstance *)&v10, i, *(float *)(*v6 + 4 * v4));
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t))(*(void *)v5 + 264))(v5, &v10, v3);
      if (__p)
      {
        unsigned int v12 = __p;
        operator delete(__p);
      }
      uint64_t v3 = (v3 + 1);
    }
    while (v3 < *((_DWORD *)this + 548) + 1);
  }
}

void sub_1BB350C10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t AUDspLibWithNewParameters::CopyClumpName(AUDspLibWithNewParameters *this, unsigned int a2, uint64_t a3, unsigned int a4, CFMutableStringRef *a5)
{
  unsigned int v8 = (*(uint64_t (**)(void, uint64_t))(**((void **)this + 271) + 24))(*((void *)this + 271), a3);
  if (*((_DWORD *)this + 548) + 1 <= v8
    || (!v8
      ? (unint64_t v9 = (const char ***)((char *)this + 2176))
      : (unint64_t v9 = (const char ***)(*((void *)this + 273) + 8 * (v8 - 1))),
        uint64_t v10 = *v9,
        CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80],
        CFStringRef v12 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], **v9, 0x8000100u),
        unsigned int v13 = (*(uint64_t (**)(void, uint64_t))(**((void **)this + 271) + 32))(*((void *)this + 271), a3), v14 = v10[1], v13 >= *((_DWORD *)v14 + 2)))
  {
    abort();
  }
  CFStringRef v15 = CFStringCreateWithCString(v11, *(const char **)(*(void *)v14 + 16 * v13), 0x8000100u);
  CFMutableStringRef Mutable = CFStringCreateMutable(v11, 0);
  CFStringAppend(Mutable, v12);
  CFStringAppend(Mutable, @", ");
  CFStringAppend(Mutable, v15);
  CFRelease(v12);
  CFRelease(v15);
  *a5 = Mutable;
  return 0;
}

uint64_t AUDspLibWithNewParameters::GetParameterInfo(AUDspLibWithNewParameters *this, unsigned int a2, uint64_t a3, AudioUnitParameterInfo *a4)
{
  uint64_t v7 = (*(uint64_t (**)(void, uint64_t))(**((void **)this + 271) + 8))(*((void *)this + 271), a3);
  unsigned int v9 = v8;
  uint64_t v16 = v7;
  unsigned int v17 = v8;
  if (!DspLib::isValid((uint64_t)this + 2176, (int *)&v16)) {
    return 4294956418;
  }
  uint64_t v10 = DspLib::SystemParametersDefinition::operator[]((uint64_t)this + 2176, v7, v9);
  uint64_t v11 = *(unsigned int *)(v10 + 8);
  if (v11 > 0x11) {
    AudioUnitParameterUnit v12 = kAudioUnitParameterUnit_Decibels;
  }
  else {
    AudioUnitParameterUnit v12 = dword_1BB87D848[v11];
  }
  a4->unit = v12;
  a4->flags = -1048576000;
  *(void *)&a4->minunint64_t Value = *(void *)(v10 + 16);
  a4->defaultunint64_t Value = *(AudioUnitParameterValue *)(v10 + 12);
  CFStringRef v14 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(const char **)v10, 0x8000100u);
  a4->cfNameString = v14;
  a4->flags |= 0x8000010u;
  CFStringGetCString(v14, a4->name, 52, 0x8000100u);
  UInt32 v15 = (*(uint64_t (**)(void, uint64_t))(**((void **)this + 271) + 16))(*((void *)this + 271), a3);
  uint64_t result = 0;
  a4->clumpID = v15;
  a4->flags |= 0x100000u;
  return result;
}

BOOL DspLib::isValid(uint64_t a1, int *a2)
{
  int v2 = *a2;
  if (*a2 >= (*(_DWORD *)(a1 + 16) + 1)) {
    return 0;
  }
  uint64_t v3 = (uint64_t *)(v2 ? *(void *)(a1 + 8) + 8 * (v2 - 1) : a1);
  uint64_t v4 = *v3;
  uint64_t v5 = a2[1];
  uint64_t v6 = *(void *)(v4 + 8);
  return v5 < *(_DWORD *)(v6 + 8)
      && a2[2] < *(_DWORD *)(*(void *)(*(void *)v6 + 16 * v5 + 8) + 8);
}

uint64_t AUDspLibWithNewParameters::SetParameter(AUDspLibWithNewParameters *this, uint64_t a2, unsigned int a3, unsigned int a4, float a5)
{
  if (a4 > 0x11) {
    return 4294956419;
  }
  uint64_t v23 = v8;
  uint64_t v24 = v7;
  uint64_t v25 = v5;
  uint64_t v26 = v6;
  unsigned int v13 = a2;
  if (a2 == 1869769061 || a2 == 1937141612) {
    goto LABEL_5;
  }
  uint64_t v17 = (*(uint64_t (**)(void, uint64_t))(**((void **)this + 271) + 8))(*((void *)this + 271), a2);
  *(void *)double v22 = v17;
  *(_DWORD *)&v22[8] = v18;
  if (DspLib::isValid((uint64_t)this + 2176, (int *)v22))
  {
    uint64_t v19 = *((void *)this + 66);
    if (v19)
    {
      int v20 = *((_DWORD *)this + 397);
      if (!(v20 | a3))
      {
        (*(void (**)(void, void, uint64_t, float))(*(void *)v19 + 280))(*((void *)this + 66), *(void *)&v22[4], v17, a5);
        int v20 = *((_DWORD *)this + 397);
      }
      if (a3 == 4 && v20 == 1)
      {
        uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUDspLibWithNewParameters *)((char *)this + 1536), a4);
        ausdk::AUElement::SetParameter(Element, v13, a5, 0);
        (*(void (**)(uint64_t, void, uint64_t, float))(*(void *)v19 + 280))(v19, *(void *)&v22[4], v17, a5);
      }
    }
LABEL_5:
    *((unsigned char *)this + 1820) = 1;
    Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
    uint64_t v16 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
    ausdk::AUElement::SetParameter(v16, v13, a5, 0);
    return 0;
  }
  return 4294956418;
}

uint64_t AUDspLib::AUDspLib(uint64_t a1, OpaqueAudioComponentInstance *a2, uint64_t a3, long long *a4, uint64_t a5, char a6)
{
  uint64_t v11 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 1, 1);
  uint64_t v12 = 0;
  *(void *)uint64_t v11 = &unk_1F14AAB00;
  do
  {
    uint64_t v13 = a1 + v12;
    *(void *)(v13 + 528) = 0;
    *(unsigned char *)(v13 + 536) = 0;
    *(_OWORD *)(v13 + 544) = 0uLL;
    *(_OWORD *)(v13 + 560) = 0uLL;
    v12 += 56;
    *(unsigned char *)(v13 + 576) = 0;
  }
  while (v12 != 1008);
  *(void *)(a1 + 1536) = 0;
  *(_DWORD *)(a1 + 1544) = 0;
  *(_OWORD *)(a1 + 1552) = 0u;
  *(_OWORD *)(a1 + 1568) = 0u;
  *(_WORD *)(a1 + 1584) = 0;
  *(unsigned char *)(a1 + 1586) = a6;
  *(_DWORD *)(a1 + 1588) = 0;
  long long v14 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)(a1 + 1592) = *(_OWORD *)a3;
  *(_OWORD *)(a1 + 1608) = v14;
  long long v15 = *(_OWORD *)(a3 + 32);
  long long v16 = *(_OWORD *)(a3 + 48);
  long long v17 = *(_OWORD *)(a3 + 80);
  *(_OWORD *)(a1 + 1656) = *(_OWORD *)(a3 + 64);
  *(_OWORD *)(a1 + 1672) = v17;
  *(_OWORD *)(a1 + 1624) = v15;
  *(_OWORD *)(a1 + 1640) = v16;
  long long v18 = *(_OWORD *)(a3 + 96);
  long long v19 = *(_OWORD *)(a3 + 112);
  long long v20 = *(_OWORD *)(a3 + 144);
  *(_OWORD *)(a1 + 1720) = *(_OWORD *)(a3 + 128);
  *(_OWORD *)(a1 + 1736) = v20;
  *(_OWORD *)(a1 + 1688) = v18;
  *(_OWORD *)(a1 + 1704) = v19;
  *(_DWORD *)(a1 + 1752) = *(void *)(a3 + 88);
  *(_DWORD *)(a1 + 1756) = *(void *)(a3 + 104);
  long long v21 = *a4;
  *(void *)(a1 + 1776) = *((void *)a4 + 2);
  *(_OWORD *)(a1 + 1760) = v21;
  *(void *)(a1 + 1784) = a5;
  *(void *)(a1 + 1792) = 0;
  *(void *)(a1 + 1800) = 0xFFFF0000FFFF0000;
  *(void *)(a1 + 1808) = 0;
  *(void *)(a1 + 1813) = 0;
  *(unsigned char *)(a1 + 1821) = 1;
  caulk::pooled_semaphore_mutex::pooled_semaphore_mutex((caulk::pooled_semaphore_mutex *)(a1 + 1824));
  *(_OWORD *)(a1 + 2098) = 0u;
  *(_OWORD *)(a1 + 2072) = 0u;
  *(_OWORD *)(a1 + 2088) = 0u;
  *(_OWORD *)(a1 + 2040) = 0u;
  *(_OWORD *)(a1 + 2056) = 0u;
  *(_OWORD *)(a1 + 2008) = 0u;
  *(_OWORD *)(a1 + 2024) = 0u;
  *(_OWORD *)(a1 + 1976) = 0u;
  *(_OWORD *)(a1 + 1992) = 0u;
  *(_OWORD *)(a1 + 1944) = 0u;
  *(_OWORD *)(a1 + 1960) = 0u;
  *(_OWORD *)(a1 + 1912) = 0u;
  *(_OWORD *)(a1 + 1928) = 0u;
  *(_OWORD *)(a1 + 1880) = 0u;
  *(_OWORD *)(a1 + 1896) = 0u;
  *(_OWORD *)(a1 + 1848) = 0u;
  *(_OWORD *)(a1 + 1864) = 0u;
  *(_OWORD *)(a1 + 1832) = 0u;
  *(_OWORD *)(a1 + 2136) = 0u;
  *(_OWORD *)(a1 + 2152) = 0u;
  *(_OWORD *)(a1 + 2120) = 0u;
  ausdk::AUBase::CreateElements(a1);
  LODWORD(v22) = *(_DWORD *)(a1 + 1756);
  if (v22)
  {
    unint64_t v23 = 0;
    do
    {
      float v24 = *(float *)(*(void *)(a1 + 1704) + 4 * v23);
      uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 32), 0);
      ausdk::AUElement::SetParameter(Element, v23++, v24, 0);
      unint64_t v22 = *(unsigned int *)(a1 + 1756);
    }
    while (v23 < v22);
  }
  if (*(unsigned char *)(a1 + 1586))
  {
    unsigned int v26 = 0;
    uint64_t v27 = 18;
    do
    {
      if (v22)
      {
        unint64_t v28 = 0;
        do
        {
          uint64_t v29 = (ausdk::AUElement *)ausdk::AUScope::GetElement((ausdk::AUScope *)(a1 + 1536), v26);
          ausdk::AUElement::SetParameter(v29, v28, *(float *)(*(void *)(a1 + 1704) + 4 * v28), 0);
          ++v28;
          unint64_t v22 = *(unsigned int *)(a1 + 1756);
        }
        while (v28 < v22);
      }
      ++v26;
    }
    while (v26 != 18);
  }
  else
  {
    uint64_t v27 = 1;
  }
  uint64_t v30 = 0;
  uint64_t v31 = 56 * v27;
  do
  {
    uint64_t v32 = (void **)(a1 + v30 + 544);
    std::vector<float>::resize((uint64_t)v32, *(unsigned int *)(a1 + 1752));
    uint64_t v33 = *(unsigned int *)(a1 + 1752);
    if ((uint64_t)(*(void *)(a1 + v30 + 552) - (void)*v32) >> 2 != v33) {
      goto LABEL_27;
    }
    if (v33) {
      DspLib::copy(*(void **)(a1 + 1672), *(void *)(a1 + 1680), *v32);
    }
    v30 += 56;
  }
  while (v31 != v30);
  uint64_t v34 = *(unsigned int *)(a1 + 1776);
  if (v34)
  {
    uint64_t v35 = (char *)malloc_type_malloc(16 * v34, 0x10600407B16006EuLL);
    *(void *)(a1 + 1792) = v35;
    if (v35) {
      goto LABEL_21;
    }
LABEL_27:
    (*(void (**)(uint64_t))(*(void *)a1 + 64))(a1);
    return a1;
  }
  uint64_t v35 = *(char **)(a1 + 1792);
  if (!v35) {
    goto LABEL_27;
  }
LABEL_21:
  uint64_t v36 = *(unsigned int *)(a1 + 1776);
  if (v36)
  {
    uint64_t v37 = 0;
    uint64_t v38 = *(void *)(a1 + 1760);
    uint64_t v39 = v35 + 8;
    do
    {
      *((_DWORD *)v39 - 2) = v37;
      void *v39 = *(void *)(v38 + 8 * v37);
      v39 += 2;
      ++v37;
    }
    while (v36 != v37);
  }
  return a1;
}

void sub_1BB351488(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  uint64_t v13 = *(void **)(v10 + 2144);
  if (v13)
  {
    *(void *)(v10 + 2152) = v13;
    operator delete(v13);
  }
  std::vector<DspLibBuffer>::__destroy_vector::operator()[abi:ne180100](&a10);
  uint64_t v14 = 0;
  uint64_t v15 = v10 + 2104;
  while (1)
  {
    uint64_t v16 = *(void *)(v15 + v14);
    *(void *)(v15 + v14) = 0;
    if (v16) {
      std::default_delete<AUDspLibStatus::Queue>::operator()[abi:ne180100](v16);
    }
    v14 -= 8;
    if (v14 == -144)
    {
      vp::vx::io::Direction_Pair<std::vector<std::tuple<unsigned int,vp::services::Audio_Issue_Detector_Node_ID>>>::~Direction_Pair(v11);
      a10 = (void **)(v10 + 1552);
      std::vector<std::unique_ptr<ausdk::AUElement>>::__destroy_vector::operator()[abi:ne180100](&a10);
      uint64_t v17 = 1008;
      while (1)
      {
        long long v18 = *(void **)(v10 + v17 + 488);
        if (v18)
        {
          *(void *)(v10 + v17 + 496) = v18;
          operator delete(v18);
        }
        v17 -= 56;
        if (!v17)
        {
          ausdk::AUBase::~AUBase((ausdk::AUBase *)v10);
          _Unwind_Resume(a1);
        }
      }
    }
  }
}

void std::vector<DspLibBuffer>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  int v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        DspLibBuffer::~DspLibBuffer((DspLibBuffer *)(v4 - 88));
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<std::unique_ptr<ausdk::AUElement>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  int v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = *--v4;
        uint64_t v6 = v7;
        void *v4 = 0;
        if (v7) {
          (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
        }
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void AUDspLib::~AUDspLib(AUDspLib *this)
{
  *(void *)this = &unk_1F14AAB00;
  AUDspLib::Cleanup(this);
  for (uint64_t i = 0; i != 1008; i += 56)
  {
    caulk::pooled_semaphore_mutex::_lock((AUDspLib *)((char *)this + 1824));
    *(void *)((char *)this + i + 552) = *(void *)((char *)this + i + 544);
    caulk::pooled_semaphore_mutex::_unlock((AUDspLib *)((char *)this + 1824));
  }
  uint64_t v3 = (void *)*((void *)this + 224);
  if (v3)
  {
    free(v3);
    *((void *)this + 224) = 0;
  }
  uint64_t v4 = (void *)*((void *)this + 268);
  if (v4)
  {
    *((void *)this + 269) = v4;
    operator delete(v4);
  }
  uint64_t v11 = (void **)((char *)this + 2120);
  std::vector<DspLibBuffer>::__destroy_vector::operator()[abi:ne180100](&v11);
  for (uint64_t j = 2104; j != 1960; j -= 8)
  {
    uint64_t v6 = *(void *)((char *)this + j);
    *(void *)((char *)this + j) = 0;
    if (v6) {
      std::default_delete<AUDspLibStatus::Queue>::operator()[abi:ne180100](v6);
    }
  }
  uint64_t v7 = (void *)*((void *)this + 232);
  if (v7)
  {
    *((void *)this + 233) = v7;
    operator delete(v7);
  }
  uint64_t v8 = (void *)*((void *)this + 229);
  if (v8)
  {
    *((void *)this + 230) = v8;
    operator delete(v8);
  }
  uint64_t v11 = (void **)((char *)this + 1552);
  std::vector<std::unique_ptr<ausdk::AUElement>>::__destroy_vector::operator()[abi:ne180100](&v11);
  uint64_t v9 = 1008;
  do
  {
    uint64_t v10 = *(void **)((char *)this + v9 + 488);
    if (v10)
    {
      *(void *)((char *)this + v9 + 496) = v10;
      operator delete(v10);
    }
    v9 -= 56;
  }
  while (v9);

  ausdk::AUBase::~AUBase(this);
}

uint64_t AUDspLib::loadDefaultAudioChannelLayout(AUDspLib *this, CFDictionaryRef theDict)
{
  uint64_t result = (uint64_t)CFDictionaryGetValue(theDict, @"DefaultAudioChannelLayout");
  if (result)
  {
    CFNumberRef v4 = (const __CFNumber *)result;
    CFTypeID v5 = CFGetTypeID((CFTypeRef)result);
    if (v5 == CFNumberGetTypeID())
    {
      unint64_t valuePtr = 0;
      CFNumberGetValue(v4, kCFNumberSInt64Type, &valuePtr);
      if (HIDWORD(valuePtr)) {
        return 4294956428;
      }
      if (*((_DWORD *)this + 450) == -65536)
      {
        uint64_t v6 = (int *)*((void *)this + 268);
        if (v6 == *((int **)this + 269)) {
          int v7 = 0;
        }
        else {
          int v7 = *v6;
        }
        if (v7 != (unsigned __int16)valuePtr) {
          return 4294956428;
        }
        if (*((_DWORD *)this + 451) != valuePtr)
        {
          *((_DWORD *)this + 451) = valuePtr;
          caulk::pooled_semaphore_mutex::_lock((AUDspLib *)((char *)this + 1824));
          AUDspLib::initializeDspLibAlgorithms((uint64_t)this, v8);
          caulk::pooled_semaphore_mutex::_unlock((AUDspLib *)((char *)this + 1824));
        }
      }
      else if (*((_DWORD *)this + 451) != valuePtr)
      {
        *((_DWORD *)this + 451) = valuePtr;
      }
    }
    return 0;
  }
  return result;
}

void sub_1BB35189C(_Unwind_Exception *a1)
{
  caulk::pooled_semaphore_mutex::_unlock(v1);
  _Unwind_Resume(a1);
}

__CFArray *AUDspLib::CFArrayOfStringsCreateWithCArrayOfStrings(const char **this, CFIndex capacity)
{
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v4 = capacity;
  CFMutableStringRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], capacity, MEMORY[0x1E4F1D510]);
  do
  {
    uint64_t v6 = *this++;
    CFStringRef v7 = CFStringCreateWithCString(v3, v6, 0x8000100u);
    CFArrayAppendValue(Mutable, v7);
    CFRelease(v7);
    --v4;
  }
  while (v4);
  return Mutable;
}

void *AUDspLibWithNewParameters::AUDspLibWithNewParameters(void *a1, OpaqueAudioComponentInstance *a2, uint64_t a3, long long *a4, uint64_t a5)
{
  v15[4] = *MEMORY[0x1E4F143B8];
  memset(v14, 0, sizeof(v14));
  long long v12 = 0uLL;
  int v13 = 0;
  AUDspLib::AUDspLib((uint64_t)a1, a2, (uint64_t)v14, &v12, a5, 0);
  *a1 = &unk_1F14AAD90;
  long long v8 = *a4;
  a1[274] = *((void *)a4 + 2);
  *((_OWORD *)a1 + 136) = v8;
  ausdk::AUBase::CreateElements((uint64_t)a1);
  a1[271] = a3;
  for (uint64_t i = 68; i != 194; i += 7)
  {
    unsigned int v10 = DspLib::algorithmOffset((uint64_t)(a1 + 272), *((_DWORD *)a1 + 548) + 1);
    std::vector<float>::resize((uint64_t)&a1[i], v10);
  }
  v15[0] = &unk_1F14AB148;
  v15[1] = a1;
  v15[3] = v15;
  DspLib::forAllParametersOf(a1 + 272, (uint64_t)v15);
  std::__function::__value_func<void ()(DspLib::SystemParameterAddress,DspLib::ParameterDefinition)>::~__value_func[abi:ne180100](v15);
  return a1;
}

void sub_1BB351A88(_Unwind_Exception *a1)
{
  std::__function::__value_func<void ()(DspLib::SystemParameterAddress,DspLib::ParameterDefinition)>::~__value_func[abi:ne180100]((void *)(v2 - 72));
  AUDspLib::~AUDspLib(v1);
  _Unwind_Resume(a1);
}

void *std::__function::__value_func<void ()(DspLib::SystemParameterAddress,DspLib::ParameterDefinition)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<AUDspLibWithNewParameters::registerParameters(void)::$_0,std::allocator<AUDspLibWithNewParameters::registerParameters(void)::$_0>,void ()(DspLib::SystemParameterAddress,DspLib::ParameterDefinition)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  float v3 = *(float *)(a3 + 12);
  uint64_t v4 = *(void *)(a1 + 8);
  unsigned int v5 = (***(uint64_t (****)(void, void, void))(v4 + 2168))(*(void *)(v4 + 2168), *(void *)a2, *(unsigned int *)(a2 + 8));
  uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v4 + 32), 0);
  ausdk::AUElement::SetParameter(Element, v5, v3, 0);
  if (*(unsigned char *)(v4 + 1586))
  {
    unsigned int v7 = 0;
    long long v8 = (ausdk::AUScope *)(v4 + 1536);
    do
    {
      uint64_t v9 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v8, v7);
      ausdk::AUElement::SetParameter(v9, v5, v3, 0);
      ++v7;
    }
    while (v7 != 18);
  }
}

uint64_t std::__function::__func<AUDspLibWithNewParameters::registerParameters(void)::$_0,std::allocator<AUDspLibWithNewParameters::registerParameters(void)::$_0>,void ()(DspLib::SystemParameterAddress,DspLib::ParameterDefinition)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F14AB148;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<AUDspLibWithNewParameters::registerParameters(void)::$_0,std::allocator<AUDspLibWithNewParameters::registerParameters(void)::$_0>,void ()(DspLib::SystemParameterAddress,DspLib::ParameterDefinition)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F14AB148;
  result[1] = v3;
  return result;
}

void std::__function::__func<AUDspLibWithNewParameters::registerParameters(void)::$_0,std::allocator<AUDspLibWithNewParameters::registerParameters(void)::$_0>,void ()(DspLib::SystemParameterAddress,DspLib::ParameterDefinition)>::~__func()
{
}

void dspLibMessenger(void *a1)
{
  *a1 = 0;
  a1[1] = 0;
  uint64_t v2 = (std::__shared_weak_count *)dspLibMessenger(void)::sMessengerCache;
  if (dspLibMessenger(void)::sMessengerCache)
  {
    uint64_t v2 = std::__shared_weak_count::lock((std::__shared_weak_count *)dspLibMessenger(void)::sMessengerCache);
    uint64_t v3 = v2;
    a1[1] = v2;
    if (v2)
    {
      uint64_t v4 = dspLibMessenger(void)::sMessengerCache;
      *a1 = dspLibMessenger(void)::sMessengerCache;
      uint64_t v5 = (uint64_t)v2;
      if (v4)
      {
LABEL_15:
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
        goto LABEL_16;
      }
    }
  }
  else
  {
    uint64_t v3 = 0;
  }
  uint64_t v6 = (long long *)caulk::concurrent::messenger::shared_high_priority((caulk::concurrent::messenger *)v2);
  std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:ne180100](&v10, v6);
  long long v7 = v6[2];
  *(_OWORD *)&v12[13] = *(long long *)((char *)v6 + 45);
  *(_OWORD *)long long v12 = v7;
  if (v11)
  {
    std::string::__assign_external(&v10, "DspLib messenger");
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(&v10, "DspLib messenger");
    char v11 = 1;
  }
  std::allocate_shared[abi:ne180100]<caulk::concurrent::messenger,std::allocator<caulk::concurrent::messenger>,caulk::concurrent::messenger::thread_strategy &,caulk::thread::attributes &,void>(v9, 1, (uint64_t)&v10);
  uint64_t v4 = v9[0];
  uint64_t v5 = v9[1];
  *a1 = v9[0];
  a1[1] = v5;
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  if (v11 && SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
  if (v5) {
    goto LABEL_15;
  }
LABEL_16:
  dspLibMessenger(void)::sMessengerCache = v4;
  long long v8 = (std::__shared_weak_count *)dspLibMessenger(void)::sMessengerCache;
  dspLibMessenger(void)::sMessengerCache = v5;
  if (v8) {
    std::__shared_weak_count::__release_weak(v8);
  }
}

void sub_1BB351DB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (a17 && a16 < 0) {
    operator delete(__p);
  }
  if (v17) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::allocate_shared[abi:ne180100]<caulk::concurrent::messenger,std::allocator<caulk::concurrent::messenger>,caulk::concurrent::messenger::thread_strategy &,caulk::thread::attributes &,void>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = operator new(0x28uLL);
  v6[1] = 0;
  v6[2] = 0;
  void *v6 = &unk_1F14BAA48;
  uint64_t result = MEMORY[0x1C185C230](v6 + 3, a2, a3);
  *a1 = result;
  a1[1] = (uint64_t)v6;
  return result;
}

void sub_1BB351E60(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<caulk::concurrent::messenger>::__on_zero_shared()
{
}

void std::__shared_ptr_emplace<caulk::concurrent::messenger>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F14BAA48;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1C185D370);
}

void std::__shared_ptr_emplace<caulk::concurrent::messenger>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F14BAA48;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void CrossFader::~CrossFader(CrossFader *this)
{
}

void VoiceProcessorV4::SetupECApplicator(VoiceProcessorV4 *this)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (ECApplicator **)*((void *)this + 2116);
  uint64_t v3 = (ECApplicator **)*((void *)this + 2115);
  while (v2 != v3)
    std::unique_ptr<ECApplicator>::reset[abi:ne180100](--v2);
  *((void *)this + 2116) = v3;
  operator new();
}

void sub_1BB3525D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  std::unique_ptr<ECApplicator>::reset[abi:ne180100]((ECApplicator **)va);
  _Unwind_Resume(a1);
}

ECApplicator *std::unique_ptr<ECApplicator>::reset[abi:ne180100](ECApplicator **a1)
{
  uint64_t result = *a1;
  *a1 = 0;
  if (result)
  {
    ECApplicator::~ECApplicator(result);
    JUMPOUT(0x1C185D370);
  }
  return result;
}

uint64_t std::__split_buffer<std::unique_ptr<ECApplicator>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    std::unique_ptr<ECApplicator>::reset[abi:ne180100]((ECApplicator **)(i - 8));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

__n128 VoiceProcessorV4::CorrectDownlinkTimeStamp@<Q0>(const AudioTimeStamp *a1@<X1>, uint64_t a2@<X8>)
{
  long long v3 = *(_OWORD *)&a1->mRateScalar;
  *(_OWORD *)a2 = *(_OWORD *)&a1->mSampleTime;
  *(_OWORD *)(a2 + 16) = v3;
  __n128 result = *(__n128 *)&a1->mSMPTETime.mSubframes;
  long long v5 = *(_OWORD *)&a1->mSMPTETime.mHours;
  *(__n128 *)(a2 + 32) = result;
  *(_OWORD *)(a2 + 48) = v5;
  return result;
}

void VoiceProcessorV4::ApplyCustomTelephonyDSPOverrides(VoiceProcessorV4 *this, CFDictionaryRef theDict, int a3)
{
  if (theDict && CFDictionaryGetCount(theDict))
  {
    if (a3)
    {
      if (CFDictionaryContainsKey(theDict, @"noise suppression"))
      {
        CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"noise suppression");
        if (Value)
        {
          CFNumberRef v7 = Value;
          CFRetain(Value);
          float valuePtr = 0.0;
          CFNumberGetValue(v7, kCFNumberFloat32Type, &valuePtr);
          CFRelease(v7);
          uint64_t v8 = *((void *)this + 583);
          *((void *)this + 584) |= 0x20uLL;
          *((void *)this + 583) = v8 & 0xFEBFFFFFFFFFFFFFLL | 0x40000000000000;
          AUPropAndParamHelper::AddItemToAUParamList((uint64_t)this + 5992, 0, valuePtr);
        }
      }
      if (CFDictionaryContainsKey(theDict, @"agc"))
      {
        CFNumberRef v9 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"agc");
        if (v9)
        {
          CFNumberRef v10 = v9;
          CFRetain(v9);
          float valuePtr = 0.0;
          CFNumberGetValue(v10, kCFNumberIntType, &valuePtr);
          CFRelease(v10);
          uint64_t v11 = *((void *)this + 584);
          unint64_t v12 = v11 & 0xFFFFFFFFFFFFFFFBLL;
          uint64_t v13 = v11 | 0x24;
          if (LODWORD(valuePtr) == 1) {
            unint64_t v14 = v13;
          }
          else {
            unint64_t v14 = v12;
          }
          *((void *)this + 584) = v14;
        }
      }
    }
    if (CFDictionaryContainsKey(theDict, @"gain"))
    {
      CFNumberRef v15 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"gain");
      if (v15)
      {
        CFNumberRef v16 = v15;
        CFRetain(v15);
        float valuePtr = 0.0;
        CFNumberGetValue(v16, kCFNumberFloat32Type, &valuePtr);
        CFRelease(v16);
        if (a3)
        {
          *(int8x16_t *)((char *)this + 4664) = vorrq_s8(*(int8x16_t *)((char *)this + 4664), (int8x16_t)xmmword_1BB879C80);
          uint64_t v17 = (char *)this + 7024;
          float v18 = valuePtr;
          int v19 = 1;
        }
        else
        {
          *((void *)this + 1112) |= 0x1800000000000000uLL;
          AUPropAndParamHelper::AddItemToAUParamList((uint64_t)this + 10920, 0, valuePtr);
          float v18 = valuePtr;
          uint64_t v17 = (char *)this + 10920;
          int v19 = 8;
        }
        AUPropAndParamHelper::AddItemToAUParamList((uint64_t)v17, v19, v18);
      }
    }
    if (CFDictionaryContainsKey(theDict, @"eq"))
    {
      CFArrayRef v20 = (const __CFArray *)CFDictionaryGetValue(theDict, @"eq");
      if (v20)
      {
        CFArrayRef v21 = v20;
        CFRetain(v20);
        unsigned int Count = CFArrayGetCount(v21);
        BOOL v23 = a3 == 0;
        if (a3) {
          float v24 = (char *)this + 6232;
        }
        else {
          float v24 = (char *)this + 9704;
        }
        uint64_t v25 = 8896;
        if (!v23) {
          uint64_t v25 = 4672;
        }
        uint64_t v26 = 33;
        if (v23) {
          uint64_t v26 = 0x1000000200000000;
        }
        *(void *)((char *)this + v25) |= v26;
        if (Count >= 0xA) {
          uint64_t v27 = 10;
        }
        else {
          uint64_t v27 = Count;
        }
        if (v27)
        {
          for (CFIndex i = 0; i != v27; ++i)
          {
            CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v21, i);
            if (ValueAtIndex)
            {
              CFDictionaryRef v30 = ValueAtIndex;
              CFRetain(ValueAtIndex);
              if (CFDictionaryContainsKey(v30, @"AUNBandEQ_FilterType")
                && CFDictionaryContainsKey(v30, @"AUNBandEQ_FilterFrequency"))
              {
                AUPropAndParamHelper::AddItemToAUParamList((uint64_t)v24, i + 1000, 0.0);
                CFNumberRef v31 = (const __CFNumber *)CFDictionaryGetValue(v30, @"AUNBandEQ_FilterType");
                if (v31)
                {
                  CFNumberRef v32 = v31;
                  CFRetain(v31);
                  float valuePtr = 0.0;
                  CFNumberGetValue(v32, kCFNumberIntType, &valuePtr);
                  CFRelease(v32);
                  AUPropAndParamHelper::AddItemToAUParamList((uint64_t)v24, i + 2000, (float)LODWORD(valuePtr));
                }
                CFNumberRef v33 = (const __CFNumber *)CFDictionaryGetValue(v30, @"AUNBandEQ_FilterFrequency");
                if (v33)
                {
                  CFNumberRef v34 = v33;
                  CFRetain(v33);
                  float valuePtr = 0.0;
                  CFNumberGetValue(v34, kCFNumberFloat32Type, &valuePtr);
                  CFRelease(v34);
                  AUPropAndParamHelper::AddItemToAUParamList((uint64_t)v24, i + 3000, valuePtr);
                }
              }
              if (CFDictionaryContainsKey(v30, @"AUNBandEQ_FilterGain"))
              {
                CFNumberRef v35 = (const __CFNumber *)CFDictionaryGetValue(v30, @"AUNBandEQ_FilterGain");
                if (v35)
                {
                  CFNumberRef v36 = v35;
                  CFRetain(v35);
                  float valuePtr = 0.0;
                  CFNumberGetValue(v36, kCFNumberFloat32Type, &valuePtr);
                  CFRelease(v36);
                  AUPropAndParamHelper::AddItemToAUParamList((uint64_t)v24, i + 4000, valuePtr);
                }
              }
              if (CFDictionaryContainsKey(v30, @"AUNBandEQ_FilterBandwidth"))
              {
                uint64_t v37 = CFDictionaryGetValue(v30, @"AUNBandEQ_FilterBandwidth");
                CFRetain(v37);
                float valuePtr = 0.0;
                CFNumberGetValue((CFNumberRef)v37, kCFNumberFloat32Type, &valuePtr);
                CFRelease(v37);
                AUPropAndParamHelper::AddItemToAUParamList((uint64_t)v24, i + 5000, valuePtr);
              }
              CFRelease(v30);
            }
          }
        }
        CFRelease(v21);
      }
    }
  }
}

void AUPropAndParamHelper::AddItemToAUParamList(uint64_t a1, int a2, float a3)
{
  uint64_t v6 = *(float **)a1;
  CFNumberRef v7 = *(float **)(a1 + 8);
  int64_t v9 = (char *)v7 - (char *)v6;
  unint64_t v10 = ((char *)v7 - (char *)v6) >> 3;
  if (v7 != v6)
  {
    int64_t v9 = 0;
    unsigned int v11 = 1;
    while (1)
    {
      if (LODWORD(v6[2 * v9]) == a2)
      {
        unint64_t v12 = &v6[2 * v9];
        float v14 = v12[1];
        uint64_t v13 = v12 + 1;
        if (v14 != a3) {
          break;
        }
      }
      int64_t v9 = v11;
      if (v10 <= v11++) {
        goto LABEL_8;
      }
    }
    LODWORD(v6[2 * v9]) = a2;
    *uint64_t v13 = a3;
  }
LABEL_8:
  if (v10 == v9)
  {
    unint64_t v16 = *(void *)(a1 + 16);
    if ((unint64_t)v7 >= v16)
    {
      unint64_t v18 = v10 + 1;
      if ((v10 + 1) >> 61) {
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v19 = v16 - (void)v6;
      if (v19 >> 2 > v18) {
        unint64_t v18 = v19 >> 2;
      }
      BOOL v20 = (unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8;
      unint64_t v21 = 0x1FFFFFFFFFFFFFFFLL;
      if (!v20) {
        unint64_t v21 = v18;
      }
      if (v21)
      {
        unint64_t v21 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v21);
        uint64_t v6 = *(float **)a1;
        CFNumberRef v7 = *(float **)(a1 + 8);
      }
      else
      {
        uint64_t v22 = 0;
      }
      unint64_t v23 = v21 + 8 * v10;
      unint64_t v24 = v21 + 8 * v22;
      *(_DWORD *)unint64_t v23 = a2;
      *(float *)(v23 + 4) = a3;
      uint64_t v17 = (float *)(v23 + 8);
      if (v7 != v6)
      {
        do
        {
          uint64_t v25 = *((void *)v7 - 1);
          v7 -= 2;
          *(void *)(v23 - 8) = v25;
          v23 -= 8;
        }
        while (v7 != v6);
        uint64_t v6 = *(float **)a1;
      }
      *(void *)a1 = v23;
      *(void *)(a1 + 8) = v17;
      *(void *)(a1 + 16) = v24;
      if (v6) {
        operator delete(v6);
      }
    }
    else
    {
      *(_DWORD *)CFNumberRef v7 = a2;
      v7[1] = a3;
      uint64_t v17 = v7 + 2;
    }
    *(void *)(a1 + 8) = v17;
  }
}

uint64_t VoiceProcessorV2::GetTelephonyVoiceIsolationUseCaseOverrideTuning4CC(VoiceProcessorV2 *this)
{
  return 0;
}

uint64_t VoiceProcessorV2::ShouldUsePowerEfficientSingleChannelVoiceIsolation(VoiceProcessorV2 *this)
{
  return 0;
}

BOOL VoiceProcessorV2::ShouldUseFullIOCycle(VoiceProcessorV2 *this)
{
  return *((_DWORD *)this + 19) != 1;
}

uint64_t VoiceProcessorV2::IsInGenericVoiceIsolationMode(VoiceProcessorV2 *this)
{
  return 0;
}

uint64_t VoiceProcessorV2::IsAutomaticChatFlavorEnabled(VoiceProcessorV2 *this)
{
  return 0;
}

uint64_t VoiceProcessorV2::GetRequestedChatFlavor(VoiceProcessorV2 *this)
{
  return 0;
}

uint64_t VoiceProcessorV2::SetChatFlavor(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (VPLogScope(void)::once != -1) {
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
  }
  uint64_t v2 = (void *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
  {
    long long v3 = (*v2 ? *v2 : MEMORY[0x1E4F14500]);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      int v6 = 136315394;
      CFNumberRef v7 = "VoiceProcessor_v2.h";
      __int16 v8 = 1024;
      int v9 = 2082;
      _os_log_impl(&dword_1BB0CE000, v3, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> Chat flavor not supported in this vp version", (uint8_t *)&v6, 0x12u);
    }
  }
  uint64_t v4 = *(int **)(a1 + 12624);
  if (v4 && (*(unsigned char *)(a1 + 15961) || *(unsigned char *)(a1 + 15962)))
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    CALegacyLog::log(v4, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/VoiceProcessor_v2.h", 2082, "SetChatFlavor", "Chat flavor not supported in this vp version");
  }
  return 0xFFFFFFFFLL;
}

uint64_t VoiceProcessorV2::ShouldApplyThirdPartyAppTuningOverride(VoiceProcessorV2 *this)
{
  return 0;
}

uint64_t VoiceProcessorV2::ShouldThirdPartyAppUseFaceTimeDSPAndTuning(VoiceProcessorV2 *this)
{
  return 0;
}

void VoiceProcessorV4::SetupDownlinkBasicAUChain(VoiceProcessorV4 *this)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 1112);
  if (*((unsigned char *)this + 2084))
  {
    uint64_t v3 = 671088640;
  }
  else
  {
    *((void *)this + 1112) = v2 | 0x100;
    BOOL v18 = 0;
    CFRetain(@"com.apple.coreaudio");
    AppBooleanCFNumberRef Value = CACFPreferencesGetAppBooleanValue(@"vp_use_vareq", @"com.apple.coreaudio", &v18);
    if (v18 && !AppBooleanValue) {
      *((void *)this + 1112) &= ~0x100uLL;
    }
    if (*((double *)this + 103) == *((double *)this + 41)) {
      BOOL v5 = 1;
    }
    else {
      BOOL v5 = (*(unsigned int (**)(VoiceProcessorV4 *))(*(void *)this + 232))(this)
    }
        && (long double v6 = *((double *)this + 103), v6 > 0.0)
        && (long double v7 = *((double *)this + 41), v7 > 0.0)
        && fmod(v7, v6) == 0.0;
    int v8 = (*(unsigned int (**)(VoiceProcessorV4 *))(*(void *)this + 112))(this) > 5 || v5;
    if (v8
      && *((_DWORD *)this + 208) == 1819304813
      && (*((_DWORD *)this + 209) & 1) != 0
      && *((_DWORD *)this + 84) == 1819304813
      && (*((_DWORD *)this + 85) & 1) != 0
      && (~*((_DWORD *)this + 112) & 5) == 0
      && (int v9 = (_DWORD *)*((void *)this + 292), v9 != *((_DWORD **)this + 293))
      && *v9 == 1886545251)
    {
      unsigned int v10 = (*(uint64_t (**)(VoiceProcessorV4 *))(*(void *)this + 112))(this);
      unint64_t v11 = *((void *)this + 1112);
      if (v10 >= 6)
      {
        *((void *)this + 1112) = v11 | 0x80000000000;
        *((unsigned char *)this + 481) = *((double *)this + 103) != *((double *)this + 41);
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        unint64_t v12 = CALog::LogObjIfEnabled(3, VPLogScope(void)::scope);
        if (v12)
        {
          uint64_t v13 = v12;
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            int v14 = *((unsigned __int8 *)this + 481);
            *(_DWORD *)buf = 136315650;
            BOOL v20 = "VoiceProcessor_v4.cpp";
            __int16 v21 = 1024;
            int v22 = 328;
            __int16 v23 = 1024;
            int v24 = v14;
            _os_log_impl(&dword_1BB0CE000, v13, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp> Should enable TweakaLeakIR sample rate converter: %d", buf, 0x18u);
          }
        }
        CFNumberRef v15 = (int *)*((void *)this + 1578);
        if (v15 && (*((unsigned char *)this + 15961) || *((unsigned char *)this + 15962)))
        {
          if (VPLogScope(void)::once != -1)
          {
            uint64_t v17 = (int *)*((void *)this + 1578);
            dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
            CFNumberRef v15 = v17;
          }
          CALegacyLog::log(v15, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v4/VoiceProcessor_v4.cpp", 328, "SetupDownlinkBasicAUChain", "Should enable TweakaLeakIR sample rate converter: %d", *((unsigned __int8 *)this + 481));
        }
        if (*((_DWORD *)this + 127) <= *((_DWORD *)this + 121)) {
          int v16 = *((_DWORD *)this + 121);
        }
        else {
          int v16 = *((_DWORD *)this + 127);
        }
        myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), v16, (AudioBufferList **)this + 2145);
        unint64_t v11 = *((void *)this + 1112);
      }
    }
    else
    {
      unint64_t v11 = *((void *)this + 1112) & 0xFFFFF7FFFFFFFFFFLL;
    }
    *((void *)this + 1112) = v11 | 0x208044;
    AUPropAndParamHelper::AddItemToAUParamList((uint64_t)this + 9416, 0, *((float *)this + 3135));
    uint64_t v2 = *((void *)this + 1112);
    uint64_t v3 = 0x3E8000000;
  }
  *((void *)this + 1112) = v2 | v3 & 0xFFFFFFFFFFFFLL | 0x1800000000000000;
}

uint64_t VoiceProcessorV4::SetupUplink_MS(uint64_t this, unsigned int a2)
{
  if (a2 != 1)
  {
    uint64_t v2 = *(void *)(this + 4664);
    *(void *)(this + 4664) = v2 | 0x40004101;
    if (a2)
    {
      *(void *)(this + 4664) = v2 | 0x40004107;
      if (a2 >= 3) {
        *(void *)(this + 4664) = v2 | 0x4000410F;
      }
    }
  }
  return this;
}

uint64_t VoiceProcessorV4::SetupUplink_BF_MS(uint64_t this, unsigned int a2, char a3)
{
  if (a2 < 2)
  {
    if (a2 && (a3 & 1) == 0)
    {
      uint64_t v4 = *(void *)(this + 4664) | 2;
      goto LABEL_8;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(this + 4664);
    *(void *)(this + 4664) = v3 | 0xC0004101;
    if ((a3 & 1) == 0)
    {
      *(void *)(this + 4664) = v3 | 0xC0004107;
      if (a2 != 2)
      {
        uint64_t v4 = v3 | 0xC000410FLL;
LABEL_8:
        *(void *)(this + 4664) = v4;
      }
    }
  }
  return this;
}

uint64_t VoiceProcessorV4::SetupUplink_MMNS(uint64_t this, unsigned int a2)
{
  if (a2 != 1)
  {
    unint64_t v2 = *(void *)(this + 4664) & 0xFEBFFBFFFFFFBEFFLL;
    *(void *)(this + 4664) = v2 | 0x100040000004100;
    if (a2)
    {
      *(void *)(this + 4664) = v2 | 0x100040000004106;
      if (a2 >= 3)
      {
        *(void *)(this + 4664) = v2 | 0x10004000000410ELL;
        if (a2 != 3) {
          *(void *)(this + 4664) = v2 | 0x10004030001C51ELL;
        }
      }
    }
  }
  return this;
}

void VoiceProcessorV4::SetupUplinkLiteAUChain(VoiceProcessorV4 *this)
{
  unint64_t v2 = (unint64_t *)((char *)this + 4664);
  long double v7 = (char *)this + 4664;
  int v8 = 0;
  std::__fill_n[abi:ne180100]<false,std::__bitset<2ul,72ul>>((uint64_t)&v7);
  uint64_t v3 = *((void *)this + 583);
  *((void *)this + 583) = v3 | 0x8000020000002080;
  uint64_t v4 = *((void *)this + 584);
  *((void *)this + 584) = v4 | 0x21;
  if (*((unsigned char *)this + 1676)) {
    *unint64_t v2 = v3 | 0xA000020000002080;
  }
  int v5 = *((_DWORD *)this + 571);
  if (v5 == 1 || v5 == -1) {
    *((void *)this + 584) = v4 | 0x25;
  }
}

void std::__fill_n[abi:ne180100]<false,std::__bitset<2ul,72ul>>(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 8);
  uint64_t v3 = *(void **)a1;
  if (!v2)
  {
    char v5 = 72;
    unint64_t v6 = 1;
LABEL_8:
    bzero(v3, 8 * v6);
    goto LABEL_9;
  }
  if ((64 - v2) >= 0x48uLL) {
    unint64_t v4 = 72;
  }
  else {
    unint64_t v4 = (64 - v2);
  }
  *v3++ &= ~((0xFFFFFFFFFFFFFFFFLL >> (64 - v2 - v4)) & (-1 << v2));
  char v5 = 72 - v4;
  *(void *)a1 = v3;
  unint64_t v6 = (72 - v4) >> 6;
  if (v4 <= 8) {
    goto LABEL_8;
  }
LABEL_9:
  if ((v5 & 0x3F) != 0)
  {
    long double v7 = &v3[v6];
    *(void *)a1 = v7;
    *v7 &= ~(0xFFFFFFFFFFFFFFFFLL >> -(v5 & 0x3F));
  }
}

void VoiceProcessorV4::SetupUplinkBasicAUChain(VoiceProcessorV4 *this)
{
  int v2 = (unint64_t *)((char *)this + 4664);
  long double v7 = (char *)this + 4664;
  int v8 = 0;
  std::__fill_n[abi:ne180100]<false,std::__bitset<2ul,72ul>>((uint64_t)&v7);
  uint64_t v3 = *((void *)this + 583);
  *((void *)this + 583) = v3 | 0x8040020000002080;
  uint64_t v4 = *((void *)this + 584);
  *((void *)this + 584) = v4 | 0x23;
  if (*((unsigned char *)this + 1676)) {
    *int v2 = v3 | 0xA040020000002080;
  }
  int v5 = *((_DWORD *)this + 571);
  if (v5 == 1 || v5 == -1) {
    *((void *)this + 584) = v4 | 0x27;
  }
}

uint64_t VoiceProcessorV4::Initialize(VoiceProcessorV4 *this)
{
  uint64_t v2 = VoiceProcessorV2::Initialize(this);
  if (!v2) {
    VoiceProcessorV4::InitializeV4Specifics(this);
  }
  return v2;
}

void VoiceProcessorV4::InitializeV4Specifics(VoiceProcessorV4 *this)
{
  uint64_t v2 = (VPTimeFreqConverter *)*((void *)this + 2113);
  if (v2)
  {
    VPTimeFreqConverter::~VPTimeFreqConverter(v2);
    MEMORY[0x1C185D370]();
  }
  uint64_t v3 = (VPTimeFreqConverter *)*((void *)this + 2114);
  if (v3)
  {
    VPTimeFreqConverter::~VPTimeFreqConverter(v3);
    MEMORY[0x1C185D370]();
  }
  VPTimeFreqConverter_Create();
}

uint64_t VoiceProcessorV2::SupportsSWB(VoiceProcessorV2 *this)
{
  return 0;
}

uint64_t VoiceProcessorV4::GetVersion(VoiceProcessorV4 *this)
{
  return 4;
}

void VoiceProcessorV4::~VoiceProcessorV4(VoiceProcessorV4 *this)
{
  VoiceProcessorV4::~VoiceProcessorV4(this);

  JUMPOUT(0x1C185D370);
}

{
  VPTimeFreqConverter *v2;
  VPTimeFreqConverter *v3;
  void **v4;
  uint64_t vars8;

  *(void *)this = &unk_1F14AB1B0;
  caulk::details::lifetime_guard_base<vp::vx::Telephony_Utility_Manager>::invalidate((uint64_t)this + 16696);
  uint64_t v2 = (VPTimeFreqConverter *)*((void *)this + 2113);
  if (v2)
  {
    VPTimeFreqConverter::~VPTimeFreqConverter(v2);
    MEMORY[0x1C185D370]();
    *((void *)this + 2113) = 0;
  }
  uint64_t v3 = (VPTimeFreqConverter *)*((void *)this + 2114);
  if (v3)
  {
    VPTimeFreqConverter::~VPTimeFreqConverter(v3);
    MEMORY[0x1C185D370]();
    *((void *)this + 2114) = 0;
  }
  myFreeABLDynamic((AudioBufferList **)this + 2145);
  CAUnregisterUIOrientation();
  CAUnregisterDeviceOrientation();
  if (VoiceProcessorV4::mNotifyTokenProx) {
    notify_cancel(VoiceProcessorV4::mNotifyTokenProx);
  }
  uint64_t v4 = (void **)((char *)this + 16920);
  std::vector<std::unique_ptr<ECApplicator>>::__destroy_vector::operator()[abi:ne180100](&v4);

  VoiceProcessorV3::~VoiceProcessorV3(this);
}

void std::vector<std::unique_ptr<ECApplicator>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (ECApplicator **)**a1;
  if (v2)
  {
    uint64_t v4 = (ECApplicator **)v1[1];
    int v5 = **a1;
    if (v4 != v2)
    {
      do
        std::unique_ptr<ECApplicator>::reset[abi:ne180100](--v4);
      while (v4 != v2);
      int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void VoiceProcessorV4::VoiceProcessorV4(VoiceProcessorV4 *this, const vp::Context *a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  VoiceProcessorV3::VoiceProcessorV3(this, a2);
}

void sub_1BB353B7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22,uint64_t a23)
{
  if (a16) {
    std::__shared_weak_count::__release_weak(a16);
  }
  if (a22) {
    std::__shared_weak_count::__release_weak(a22);
  }
  if (v24) {
    std::__shared_weak_count::__release_weak(v24);
  }
  a23 = (uint64_t)v23 + 16920;
  std::vector<std::unique_ptr<ECApplicator>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a23);
  VoiceProcessorV3::~VoiceProcessorV3(v23);
  _Unwind_Resume(a1);
}

void ___ZN16VoiceProcessorV4C2ERKN2vp7ContextE_block_invoke(uint64_t a1, unsigned int a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    int v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      unint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 32);
      if (v7)
      {
        atomic_store(a2, (unsigned int *)(v7 + 2308));
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        int v8 = (void *)VPLogScope(void)::scope;
        if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
        {
          int v9 = (*v8 ? *v8 : MEMORY[0x1E4F14500]);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136315650;
            uint64_t v13 = "VoiceProcessor_v2.cpp";
            __int16 v14 = 1024;
            int v15 = 891;
            __int16 v16 = 1024;
            unsigned int v17 = a2;
            _os_log_impl(&dword_1BB0CE000, v9, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> UI orientation is set to %d", buf, 0x18u);
          }
        }
        unsigned int v10 = *(int **)(v7 + 12624);
        if (v10 && (*(unsigned char *)(v7 + 15961) || *(unsigned char *)(v7 + 15962)))
        {
          if (VPLogScope(void)::once != -1)
          {
            unint64_t v11 = *(int **)(v7 + 12624);
            dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
            unsigned int v10 = v11;
          }
          CALegacyLog::log(v10, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/VoiceProcessor_v2.cpp", 891, "SetUIOrientation", "UI orientation is set to %d", a2);
        }
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v6);
    }
  }
}

void sub_1BB353DE0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void ___ZN16VoiceProcessorV4C2ERKN2vp7ContextE_block_invoke_5(uint64_t a1, unsigned int a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    int v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      unint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 32);
      if (v7)
      {
        atomic_store(a2, (unsigned int *)(v7 + 2320));
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        int v8 = (void *)VPLogScope(void)::scope;
        if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
        {
          int v9 = (*v8 ? *v8 : MEMORY[0x1E4F14500]);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136315650;
            uint64_t v13 = "VoiceProcessor_v2.cpp";
            __int16 v14 = 1024;
            int v15 = 882;
            __int16 v16 = 1024;
            unsigned int v17 = a2;
            _os_log_impl(&dword_1BB0CE000, v9, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> device orientation is set to %d", buf, 0x18u);
          }
        }
        unsigned int v10 = *(int **)(v7 + 12624);
        if (v10 && (*(unsigned char *)(v7 + 15961) || *(unsigned char *)(v7 + 15962)))
        {
          if (VPLogScope(void)::once != -1)
          {
            unint64_t v11 = *(int **)(v7 + 12624);
            dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
            unsigned int v10 = v11;
          }
          CALegacyLog::log(v10, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/VoiceProcessor_v2.cpp", 882, "SetDeviceOrientation", "device orientation is set to %d", a2);
        }
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v6);
    }
  }
}

void sub_1BB354000(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t ___ZN16VoiceProcessorV4C2ERKN2vp7ContextE_block_invoke_15()
{
  uint64_t state64 = 0;
  uint64_t result = notify_get_state(VoiceProcessorV4::mNotifyTokenProx, &state64);
  atomic_store(state64, VoiceProcessorV4::mIsOnEar);
  return result;
}

uint64_t ___ZN16VoiceProcessorV4C2ERKN2vp7ContextE_block_invoke_10()
{
  uint64_t state64 = 0;
  uint64_t result = notify_get_state(VoiceProcessorV4::mNotifyTokenProx, &state64);
  atomic_store(state64, VoiceProcessorV4::mIsOnEar);
  return result;
}

void __destroy_helper_block_e8_32c41_ZTSNSt3__18weak_ptrI16VoiceProcessorV2EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t __copy_helper_block_e8_32c41_ZTSNSt3__18weak_ptrI16VoiceProcessorV2EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void vp::v4::create(vp::v4 *this, const vp::Context *a2)
{
}

void sub_1BB354114(_Unwind_Exception *a1)
{
  MEMORY[0x1C185D370](v1, 0x10F3C40FF191A9CLL);
  _Unwind_Resume(a1);
}

BOOL AULevelDrivenSuppressor::ValidFormat(AULevelDrivenSuppressor *this, const AudioStreamBasicDescription *a2, int a3, AudioStreamBasicDescription *a4)
{
  if (a2 != 1)
  {
    if (a2 != 2 || a3) {
      goto LABEL_17;
    }
LABEL_12:
    if (a4->mBytesPerFrame != 8 || a4->mFormatID != 1718773105) {
      return 0;
    }
    return a4->mChannelsPerFrame == 1;
  }
  if (!a3) {
    goto LABEL_12;
  }
  if (a3 == 1)
  {
    if (a4->mBytesPerFrame != 4 || a4->mFormatID != 1819304813) {
      return 0;
    }
    return a4->mChannelsPerFrame == 1;
  }
LABEL_17:
  BOOL result = ausdk::ASBD::IsCommonFloat32((ausdk::ASBD *)a4, a2);
  if (!result) {
    return result;
  }
  if ((a4->mFormatFlags & 0x20) == 0) {
    return a4->mChannelsPerFrame == 1;
  }
  return 1;
}

uint64_t AULevelDrivenSuppressor::SupportedNumChannels(AULevelDrivenSuppressor *this, const AUChannelInfo **a2)
{
  if (a2) {
    *a2 = (const AUChannelInfo *)&AULevelDrivenSuppressor::SupportedNumChannels(AUChannelInfo const**)::sSupportedChannelConfigs;
  }
  return 1;
}

BOOL AULevelDrivenSuppressor::StreamFormatWritable(AULevelDrivenSuppressor *this)
{
  return *((unsigned char *)this + 17) == 0;
}

uint64_t AULevelDrivenSuppressor::SupportsTail(AULevelDrivenSuppressor *this)
{
  return 1;
}

double AULevelDrivenSuppressor::GetTailTime(AULevelDrivenSuppressor *this)
{
  return 0.0;
}

double AULevelDrivenSuppressor::GetLatency(AULevelDrivenSuppressor *this)
{
  return 0.0;
}

uint64_t AULevelDrivenSuppressor::RestoreState(OpaqueAudioComponentInstance **this, const void *a2)
{
  uint64_t result = ausdk::AUBase::RestoreState(this, a2);
  if (!result)
  {
    ++*((_DWORD *)this + 134);
    ++*((_DWORD *)this + 136);
  }
  return result;
}

uint64_t AULevelDrivenSuppressor::GetParameterInfo(AULevelDrivenSuppressor *this, int a2, unsigned int a3, AudioUnitParameterInfo *buffer)
{
  buffer->flags = 0x40000000;
  buffer->unitName = 0;
  uint64_t result = 4294956418;
  if (!a2 && a3 <= 4)
  {
    CFStringRef v6 = *(&off_1E623C290 + a3);
    AudioUnitParameterUnit v7 = dword_1BB87D894[a3];
    AudioUnitParameterValue v8 = flt_1BB87D8A8[a3];
    AudioUnitParameterValue v9 = flt_1BB87D8BC[a3];
    AudioUnitParameterValue v10 = flt_1BB87D8D0[a3];
    buffer->cfNameString = v6;
    buffer->flags = 1207959552;
    CFStringGetCString(v6, buffer->name, 52, 0x8000100u);
    uint64_t result = 0;
    buffer->unit = v7;
    buffer->minCFNumberRef Value = v8;
    buffer->maxCFNumberRef Value = v9;
    buffer->defaultCFNumberRef Value = v10;
    buffer->flags |= 0x80000000;
  }
  return result;
}

uint64_t AULevelDrivenSuppressor::GetParameterList(AULevelDrivenSuppressor *this, int a2, unsigned int *a3, unsigned int *a4)
{
  if (a2) {
    return 4294956430;
  }
  if (a3)
  {
    *(_OWORD *)a3 = xmmword_1BB8727D0;
    a3[4] = 4;
  }
  uint64_t result = 0;
  *a4 = 5;
  return result;
}

BOOL AULevelDrivenSuppressor::BusCountWritable(AULevelDrivenSuppressor *this, int a2)
{
  return (a2 - 1) < 2;
}

uint64_t AULevelDrivenSuppressor::Render(AULevelDrivenSuppressor *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  v19[2] = *MEMORY[0x1E4F143B8];
  if (*((_DWORD *)this + 84) != a4) {
    return 4294956422;
  }
  uint64_t Element = ausdk::AUScope::SafeGetElement((AULevelDrivenSuppressor *)((char *)this + 128), 0);
  uint64_t v9 = ausdk::AUScope::GetElement((AULevelDrivenSuppressor *)((char *)this + 80), 0);
  if (!v9 || !*(_DWORD *)(v9 + 172)) {
    return 4294956420;
  }
  AudioUnitParameterValue v10 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement((AULevelDrivenSuppressor *)((char *)this + 80), 0);
  uint64_t v11 = ausdk::AUInputElement::PullInput(v10, a2, a3, 0, a4);
  if (!v11)
  {
    uint64_t v12 = ausdk::AUScope::SafeGetElement((AULevelDrivenSuppressor *)((char *)this + 80), 0);
    uint64_t BufferList = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v12 + 144));
    uint64_t v14 = ausdk::AUScope::GetElement((AULevelDrivenSuppressor *)((char *)this + 80), 1u);
    if (v14)
    {
      if (*(_DWORD *)(v14 + 172))
      {
        int v15 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement((AULevelDrivenSuppressor *)((char *)this + 80), 1u);
        uint64_t v11 = ausdk::AUInputElement::PullInput(v15, a2, a3, 1, a4);
        uint64_t v16 = ausdk::AUScope::SafeGetElement((AULevelDrivenSuppressor *)((char *)this + 80), 1u);
        uint64_t v14 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v16 + 144));
        if (!v11) {
          goto LABEL_13;
        }
        return v11;
      }
      uint64_t v14 = 0;
    }
LABEL_13:
    v19[0] = BufferList;
    v19[1] = v14;
    uint64_t v18 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(Element + 144));
    return (*(uint64_t (**)(AULevelDrivenSuppressor *, unsigned int *, uint64_t, uint64_t, void *, uint64_t, uint64_t *))(*(void *)this + 184))(this, a2, a4, 2, v19, 1, &v18);
  }
  return v11;
}

uint64_t AULevelDrivenSuppressor::ProcessMultipleBufferLists(AULevelDrivenSuppressor *this, unsigned int *a2, int a3, unsigned int a4, const AudioBufferList **a5, unsigned int a6, AudioBufferList **a7)
{
  if (*((_DWORD *)this + 84) != a3) {
    return 4294956422;
  }
  int v11 = *((_DWORD *)this + 134);
  if (*((_DWORD *)this + 135) != v11)
  {
    AULevelDrivenSuppressor::InitializeInternals(this);
    *((_DWORD *)this + 135) = v11;
  }
  int v12 = *((_DWORD *)this + 136);
  if (*((_DWORD *)this + 137) != v12) {
    *((_DWORD *)this + 137) = v12;
  }
  mData = (const float *)(*a5)->mBuffers[0].mData;
  uint64_t v14 = (float *)(*a7)->mBuffers[0].mData;
  if (!*((unsigned char *)this + 557))
  {
    memcpy(*((void **)this + 88), (*a5)->mBuffers[0].mData, *((unsigned int *)this + 173));
    if (a4 >= 2)
    {
      if (*((_DWORD *)this + 141))
      {
        if (*((_DWORD *)this + 140) >= 2u)
        {
          uint64_t v19 = a5[1];
          if (v19)
          {
            memcpy(*((void **)this + 74), v19->mBuffers[0].mData, 4 * *((unsigned int *)this + 162));
            *(_DWORD *)(*((void *)this + 74) + 4 * *((unsigned int *)this + 162)) = 0;
          }
        }
      }
    }
    vDSP_Length v21 = *((unsigned int *)this + 162);
    int v22 = (float *)*((void *)this + 91);
    __A.realp = (float *)*((void *)this + 88);
    realp = __A.realp;
    __A.imagp = &__A.realp[v21];
    vDSP_zvmags(&__A, 1, v22, 1, v21);
    *int v22 = *realp * *realp;
    v22[v21] = realp[v21] * realp[v21];
    vDSP_vsmul(v22, 1, (const float *)this + 171, v22, 1, *((unsigned int *)this + 165));
    vDSP_Length v23 = *((unsigned int *)this + 165);
    LODWORD(__A.realp) = 0;
    if (v23)
    {
      vDSP_sve(v22, 1, (float *)&__A, v23);
      float v24 = (float)(*(float *)&__A.realp / (float)v23) + 1.0e-20;
    }
    else
    {
      float v24 = 1.0e-20;
    }
    float v25 = log10f(v24) * 10.0;
    *((float *)this + 172) = v25;
    float v26 = *((float *)this + 157) - v25;
    float v176 = v26;
    float __B = 0.0316;
    int v27 = *((_DWORD *)this + 141);
    if (v27 == 3)
    {
      unint64_t v28 = (void *)*((void *)this + 140);
      uint64_t v29 = (const void *)*((void *)this + 74);
    }
    else
    {
      if (v27 != 6)
      {
        float v176 = __exp10f(v26 * 0.1);
        uint64_t v96 = (float *)*((void *)this + 164);
        uint64_t v97 = (float *)*((void *)this + 167);
        int v98 = (float *)*((void *)this + 140);
        char v99 = (const float *)*((void *)this + 143);
        vDSP_vsmul(v22, 1, &v176, v96, 1, *((unsigned int *)this + 165));
        vDSP_vsmul(v99, 1, &__B, v97, 1, *((unsigned int *)this + 165));
        vDSP_vadd(v96, 1, v97, 1, v98, 1, *((unsigned int *)this + 165));
        switch(*((_DWORD *)this + 141))
        {
          case 1:
            uint64_t v100 = (const float *)*((void *)this + 74);
            goto LABEL_84;
          case 2:
            char v103 = (const float *)*((void *)this + 74);
            goto LABEL_86;
          case 4:
            uint64_t v100 = (const float *)*((void *)this + 71);
LABEL_84:
            vDSP_vmin(v98, 1, v100, 1, v98, 1, *((unsigned int *)this + 165));
            break;
          case 5:
            char v103 = (const float *)*((void *)this + 71);
LABEL_86:
            vDSP_vmax(v98, 1, v103, 1, v98, 1, *((unsigned int *)this + 165));
            break;
          default:
            break;
        }
LABEL_22:
        uint64_t v169 = mData;
        v170 = v14;
        if (*((unsigned char *)this + 532))
        {
          CFDictionaryRef v30 = (float *)*((void *)this + 88);
          uint64_t v31 = *((unsigned int *)this + 162);
          CFNumberRef v32 = (float *)*((void *)this + 164);
          CFNumberRef v33 = &v32[v31];
          __A.realp = v32;
          __A.imagp = v33;
          CFNumberRef v34 = (DSPComplex *)*((void *)this + 167);
          float v35 = 1.0e-20;
          *CFNumberRef v32 = logf((float)(*v30 * *v30) + 1.0e-20);
          vDSP_Length v36 = *((unsigned int *)this + 163);
          if (v36 >= 2)
          {
            vDSP_Length v37 = v36 - 1;
            uint64_t v38 = v32 + 1;
            uint64_t v39 = v30 + 1;
            do
            {
              float v173 = (float)((float)(v39[v31] * v39[v31]) + (float)(*v39 * *v39)) + 1.0e-20;
              *v38++ = logf(v173) * 0.5;
              ++v39;
              --v37;
            }
            while (v37);
          }
          float v173 = 0.0;
          vDSP_vfill(&v173, v33, 1, v36);
          MultiRadixRealFFT::RealOutOfPlaceInverseTransform((const vDSP_DFT_SetupStruct ***)this + 215, &__A, v34);
          vDSP_vmul((const float *)v34, 1, *((const float **)this + 217), 1, (float *)v34, 1, *((unsigned int *)this + 164));
          MultiRadixRealFFT::RealOutOfPlaceForwardTransform((AULevelDrivenSuppressor *)((char *)this + 1720), v34, &__A, 1.0);
          uint64_t v40 = (const float *)*((void *)this + 220);
          uint64_t v41 = *((unsigned int *)this + 162);
          if (v41)
          {
            unint64_t v42 = __A.realp;
            unint64_t v43 = (float *)*((void *)this + 220);
            do
            {
              float v44 = *v43 + 1.0e-20;
              float v45 = *v42++;
              *v43++ = (float)(v44 + expf(v45)) * 0.5;
              --v41;
            }
            while (v41);
          }
          vDSP_Length v46 = *((unsigned int *)this + 165);
          v40[(v46 - 1)] = 0.0;
          float __C = 0.0;
          if (v46)
          {
            vDSP_sve(v40, 1, &__C, v46);
            float v35 = (float)(__C / (float)v46) + 1.0e-20;
          }
          float v173 = log10f(v35) * 10.0;
          float __B = (float)(*((float *)this + 154) + 6.0) - v173;
          float __B = fminf(__exp10f(__B * 0.1), 1.0e10);
          vDSP_vsmul(v40, 1, &__B, *((float **)this + 223), 1, *((unsigned int *)this + 165));
        }
        else
        {
          float v176 = 0.0;
          vDSP_vfill(&v176, *((float **)this + 223), 1, *((unsigned int *)this + 165));
        }
        float v47 = 1.0 - *((float *)this + 266);
        *(float *)&__A.realp = v47 * 0.333;
        float __C = v47 * 0.667;
        uint64_t v48 = *((void *)this + 164);
        int v49 = (float *)*((void *)this + 167);
        int v50 = (const float *)*((void *)this + 91);
        int64_t v51 = (float *)*((void *)this + 152);
        uint64_t v52 = (float *)*((void *)this + 155);
        uint64_t v53 = (float *)*((void *)this + 158);
        v171 = (float *)*((void *)this + 161);
        vDSP_Length v54 = *((unsigned int *)this + 165);
        *(_DWORD *)uint64_t v48 = 0;
        vDSP_vsmul(v50, 1, (const float *)&__A, (float *)(v48 + 4), 1, (v54 - 1));
        vDSP_vsma(v50 + 1, 1, (const float *)&__A, (const float *)v48, 1, (float *)v48, 1, (v54 - 1));
        vDSP_vsma(v50, 1, &__C, (const float *)v48, 1, (float *)v48, 1, v54);
        vDSP_vsma(v51, 1, (const float *)this + 266, (const float *)v48, 1, v51, 1, v54);
        float v55 = *((float *)this + 166);
        float v56 = v55 * 0.2;
        float v57 = *((float *)this + 273);
        if (v57 >= (float)(v55 * 0.2))
        {
          float v56 = v55 * 0.5;
          if (v57 >= (float)(v55 * 0.5)) {
            float v56 = v55 + v55;
          }
        }
        if (v56 < (float)*((unsigned int *)this + 274) || *((unsigned char *)this + 1100))
        {
          *((_DWORD *)this + 274) = 0;
          vDSP_vmin(v53, 1, v51, 1, v52, 1, *((unsigned int *)this + 165));
          memcpy(v53, v51, *((unsigned int *)this + 174));
        }
        else
        {
          vDSP_vmin(v52, 1, v51, 1, v52, 1, *((unsigned int *)this + 165));
          vDSP_vmin(v53, 1, v51, 1, v53, 1, *((unsigned int *)this + 165));
        }
        float v176 = 1.0e-20;
        vDSP_vsadd(v51, 1, &v176, (float *)v48, 1, *((unsigned int *)this + 165));
        vDSP_vsadd(v52, 1, &v176, v49, 1, *((unsigned int *)this + 165));
        vDSP_vdiv(v49, 1, (const float *)v48, 1, v171, 1, *((unsigned int *)this + 165));
        vDSP_vmul(v52, 1, *((const float **)this + 183), 1, (float *)v48, 1, *((unsigned int *)this + 165));
        vDSP_vsub((const float *)v48, 1, v51, 1, *((float **)this + 186), 1, *((unsigned int *)this + 165));
        float v58 = *((float *)this + 273) + 1.0;
        if ((float)(*((float *)this + 166) * 30.0) < v58) {
          float v58 = *((float *)this + 166) * 30.0;
        }
        *((float *)this + 273) = v58;
        ++*((_DWORD *)this + 274);
        uint64_t v59 = (const float *)*((void *)this + 91);
        unsigned int v60 = (float *)*((void *)this + 167);
        uint64_t v61 = (const float *)*((void *)this + 140);
        unsigned int v62 = (float *)*((void *)this + 170);
        vDSP_vsmul(v59, 1, (const float *)this + 270, v62, 1, *((unsigned int *)this + 165));
        uint64_t v63 = (float *)*((void *)this + 149);
        vDSP_vsma(v63, 1, (const float *)this + 271, v62, 1, v62, 1, *((unsigned int *)this + 165));
        uint64_t v64 = (const float *)*((void *)this + 155);
        vDSP_vsmul(v64, 1, (const float *)this + 269, v60, 1, *((unsigned int *)this + 165));
        uint64_t v65 = (float *)*((void *)this + 189);
        vDSP_vsub(v60, 1, v59, 1, v65, 1, *((unsigned int *)this + 165));
        unint64_t v66 = (float *)*((void *)this + 192);
        vDSP_vmax(*((const float **)this + 186), 1, v65, 1, v66, 1, *((unsigned int *)this + 165));
        vDSP_Length v67 = *((unsigned int *)this + 165);
        if (v67)
        {
          uint64_t v68 = 0;
          uint64_t v69 = *((void *)this + 152);
          do
          {
            if (v66[v68] <= 0.0 && (float v70 = (char *)v59, !*((unsigned char *)this + 1101))
              || (float v70 = (char *)v62, *(float *)(v69 + v68 * 4) < (float)(*((float *)this + 272) * v64[v68])))
            {
              v63[v68] = *(float *)&v70[v68 * 4];
            }
            ++v68;
          }
          while (v67 != v68);
        }
        else
        {
          vDSP_Length v67 = 0;
        }
        vDSP_vmax(v63, 1, v61, 1, v63, 1, v67);
        unsigned int v71 = (float *)*((void *)this + 124);
        float v72 = (float *)*((void *)this + 127);
        float v73 = (const float *)*((void *)this + 94);
        unsigned int v74 = (const float *)*((void *)this + 149);
        uint64_t v75 = *((void *)this + 167);
        uint64_t v76 = (float *)*((void *)this + 170);
        uint64_t v77 = *((void *)this + 130);
        uint64_t v78 = (float *)*((void *)this + 164);
        vDSP_vmax(*((const float **)this + 91), 1, v74, 1, v78, 1, *((unsigned int *)this + 165));
        LODWORD(__A.realp) = 507307272;
        unint64_t v79 = (float *)*((void *)this + 170);
        vDSP_vsadd(v74, 1, (const float *)&__A, v79, 1, *((unsigned int *)this + 165));
        uint64_t v80 = (float *)*((void *)this + 167);
        vDSP_Length v81 = *((unsigned int *)this + 165);
        v172 = v76;
        if (v81)
        {
          size_t v82 = v79;
          uint64_t v83 = (const float *)*((void *)this + 167);
          uint64_t v84 = *((unsigned int *)this + 165);
          do
          {
            float v85 = *v82++;
            *v80++ = 1.0 / v85;
            --v84;
          }
          while (v84);
        }
        else
        {
          uint64_t v83 = (const float *)*((void *)this + 167);
          vDSP_Length v81 = 0;
        }
        unsigned int v86 = (float *)*((void *)this + 173);
        vDSP_vadd(v73, 1, v79, 1, v86, 1, v81);
        vDSP_vdiv(v86, 1, v73, 1, v86, 1, *((unsigned int *)this + 165));
        vDSP_vmul(v86, 1, v86, 1, v86, 1, *((unsigned int *)this + 165));
        LODWORD(__A.realp) = 1063507722;
        vDSP_vsmul(v86, 1, (const float *)&__A, v86, 1, *((unsigned int *)this + 165));
        LODWORD(__A.realp) = 1036831949;
        vDSP_vsadd(v86, 1, (const float *)&__A, v86, 1, *((unsigned int *)this + 165));
        vDSP_vmul(v78, 1, v83, 1, v71, 1, *((unsigned int *)this + 165));
        LODWORD(__A.realp) = -1082130432;
        vDSP_vsadd(v71, 1, (const float *)&__A, v71, 1, *((unsigned int *)this + 165));
        LODWORD(__A.realp) = 1120403456;
        float __C = 0.0;
        vDSP_vclip(v71, 1, &__C, (const float *)&__A, v72, 1, *((unsigned int *)this + 165));
        vDSP_vmin(v71, 1, v72, 1, v71, 1, *((unsigned int *)this + 165));
        vDSP_vmul(v72, 1, v86, 1, v72, 1, *((unsigned int *)this + 165));
        LODWORD(__A.realp) = -1082130432;
        vDSP_vsadd(v86, 1, (const float *)&__A, v86, 1, *((unsigned int *)this + 165));
        vDSP_vmul(v73, 1, v86, 1, v86, 1, *((unsigned int *)this + 165));
        vDSP_vmul(v83, 1, v86, 1, v86, 1, *((unsigned int *)this + 165));
        vDSP_vsub(v86, 1, v72, 1, v72, 1, *((unsigned int *)this + 165));
        LODWORD(__A.realp) = 1120403456;
        float __C = -1.0e20;
        vDSP_vclip(v72, 1, &__C, (const float *)&__A, v72, 1, *((unsigned int *)this + 165));
        vDSP_vsub(v72, 1, (const float *)v77, 1, (float *)v75, 1, *((unsigned int *)this + 165));
        LODWORD(__A.realp) = 0;
        vDSP_vfill((const float *)&__A, v172, 1, *((unsigned int *)this + 165));
        vDSP_vmax(v172, 1, (const float *)v75, 1, v172, 1, *((unsigned int *)this + 165));
        vDSP_vsub(v172, 1, (const float *)v75, 1, (float *)v75, 1, *((unsigned int *)this + 165));
        vDSP_vsmul((const float *)v75, 1, (const float *)this + 242, (float *)v75, 1, *((unsigned int *)this + 165));
        vDSP_vadd((const float *)v75, 1, v72, 1, (float *)v75, 1, *((unsigned int *)this + 165));
        vDSP_vsmul(v172, 1, (const float *)this + 243, v78, 1, 5uLL);
        vDSP_vadd(v78, 1, (const float *)v75, 1, (float *)v77, 1, 5uLL);
        vDSP_vsmul(v172 + 5, 1, (const float *)this + 244, v78 + 5, 1, (*((_DWORD *)this + 165) - 5));
        vDSP_vadd(v78 + 5, 1, (const float *)(v75 + 20), 1, (float *)(v77 + 20), 1, (*((_DWORD *)this + 165) - 5));
        vDSP_Length v87 = *((unsigned int *)this + 165);
        if (v87)
        {
          float v88 = 0.0;
          uint64_t v89 = *((unsigned int *)this + 165);
          do
          {
            float v90 = *(float *)v77;
            v77 += 4;
            float v91 = v90;
            if (v90 <= 3.0) {
              float v91 = -0.0;
            }
            float v88 = v88 + v91;
            --v89;
          }
          while (v89);
        }
        else
        {
          float v88 = 0.0;
        }
        *((float *)this + 138) = (float)((float)(1.0
                                               / (float)((float)(0.5 / (float)(v88 / (float)v87)) + 1.0))
                                       * 0.899)
                               + 0.1;
        if (*((unsigned char *)this + 532))
        {
          vDSP_vsub(*((const float **)this + 223), 1, *((const float **)this + 91), 1, *((float **)this + 109), 1, v87);
          LODWORD(__A.realp) = 0;
          vDSP_vthr(*((const float **)this + 109), 1, (const float *)&__A, *((float **)this + 109), 1, *((unsigned int *)this + 165));
          memcpy(*((void **)this + 112), *((const void **)this + 109), *((unsigned int *)this + 174));
          vDSP_vadd(*((const float **)this + 112), 1, *((const float **)this + 112), 1, *((float **)this + 112), 1, *((unsigned int *)this + 165));
          vDSP_vadd(*((const float **)this + 112), 1, (const float *)(*((void *)this + 109) + 4), 1, *((float **)this + 112), 1, *((unsigned int *)this + 162));
          vDSP_vadd((const float *)(*((void *)this + 112) + 4), 1, *((const float **)this + 109), 1, *((float **)this + 112), 1, *((unsigned int *)this + 162));
          float __C = 0.0079;
          vDSP_vsmul(*((const float **)this + 112), 1, &__C, *((float **)this + 112), 1, *((unsigned int *)this + 165));
          float __C = 0.1;
          vDSP_vsmul(*((const float **)this + 115), 1, &__C, *((float **)this + 170), 1, *((unsigned int *)this + 165));
          memcpy(*((void **)this + 115), *((const void **)this + 112), *((unsigned int *)this + 165));
          vDSP_vadd(*((const float **)this + 112), 1, *((const float **)this + 170), 1, *((float **)this + 112), 1, *((unsigned int *)this + 165));
        }
        else
        {
          LODWORD(__A.realp) = 0;
          vDSP_vfill((const float *)&__A, *((float **)this + 115), 1, v87);
        }
        int v92 = *((_DWORD *)this + 132);
        if (v92 == 1)
        {
          float v101 = *((float *)this + 172);
          float v102 = *((float *)this + 154);
          if (v101 > (float)(v102 + 6.0))
          {
            float v95 = 0.25119;
            goto LABEL_92;
          }
          float v95 = 0.1;
          if (v101 > v102 || v101 > (float)(v102 + -6.0))
          {
LABEL_92:
            uint64_t v104 = (const float *)*((void *)this + 127);
            v105 = (const float *)*((void *)this + 124);
            uint64_t v106 = *((void *)this + 130);
            v107 = (float *)*((void *)this + 97);
            float v108 = (float *)*((void *)this + 100);
            v109 = (float *)*((void *)this + 164);
            float v110 = (float *)*((void *)this + 167);
            unsigned int v111 = (float *)*((void *)this + 170);
            float v112 = (float *)*((void *)this + 173);
            LODWORD(__A.realp) = 1065353216;
            vDSP_vsadd(v104, 1, (const float *)&__A, v112, 1, *((unsigned int *)this + 165));
            vDSP_vdiv(v112, 1, v104, 1, v110, 1, *((unsigned int *)this + 165));
            vDSP_vsadd(v105, 1, (const float *)&__A, v109, 1, *((unsigned int *)this + 165));
            vDSP_vmul(v109, 1, v110, 1, v109, 1, *((unsigned int *)this + 165));
            vDSP_Length v113 = *((unsigned int *)this + 165);
            if (v113)
            {
              int v114 = v109;
              uint64_t v115 = v107;
              uint64_t v116 = *((unsigned int *)this + 165);
              do
              {
                float v117 = *v114;
                unsigned int v118 = vcvtms_s32_f32(v117 + v117);
                float v119 = 1.0;
                if ((v118 & 0x80000000) == 0)
                {
                  if (*((_DWORD *)this + 408) - 2 >= v118)
                  {
                    float v120 = -(float)(floorf(v117 + v117) - (float)(v117 * 2.0));
                    float v119 = (float)((float)(v120 * *((float *)this + v118 + 410))
                                 + (float)((float)(1.0 - v120) * *((float *)this + v118 + 409)))
                         / sqrtf(v117 + 0.0001);
                  }
                  else
                  {
                    float v119 = (float)(0.1296 / v117) + 1.0;
                  }
                }
                *v115++ = v119;
                ++v114;
                --v116;
              }
              while (v116);
            }
            else
            {
              vDSP_Length v113 = 0;
            }
            vDSP_vmul(v110, 1, v107, 1, v107, 1, v113);
            float __C = -1.0e20;
            vDSP_vclip(v107, 1, &__C, (const float *)&__A, v107, 1, *((unsigned int *)this + 165));
            uint64_t v121 = *((unsigned int *)this + 165);
            if (v121)
            {
              do
              {
                if (*v110 == 0.0) {
                  float v122 = 0.0;
                }
                else {
                  float v122 = *v107 / *v110;
                }
                *v111++ = v122;
                ++v107;
                ++v110;
                --v121;
              }
              while (v121);
              vDSP_Length v123 = *((unsigned int *)this + 165);
              unsigned int v124 = (float *)*((void *)this + 170);
              uint64_t v125 = v170;
              if (v123)
              {
                for (uint64_t i = 0; i != v123; ++i)
                  v124[i] = (float)((float)(1.0 / (float)((float)(0.5 / *(float *)(v106 + i * 4)) + 1.0)) * 0.899) + 0.1;
              }
              else
              {
                vDSP_Length v123 = 0;
              }
            }
            else
            {
              vDSP_Length v123 = 0;
              unsigned int v124 = (float *)*((void *)this + 170);
              uint64_t v125 = v170;
            }
            v127 = (float *)*((void *)this + 173);
            LODWORD(__A.realp) = *((_DWORD *)this + 138);
            vDSP_vsmul(v124, 1, (const float *)&__A, v127, 1, v123);
            vDSP_vneg(v109, 1, v109, 1, *((unsigned int *)this + 165));
            LODWORD(__A.realp) = 1065353216;
            vDSP_vsadd(v104, 1, (const float *)&__A, v124, 1, *((unsigned int *)this + 165));
            vDSP_Length v128 = *((unsigned int *)this + 165);
            if (v128)
            {
              v129 = v108;
              uint64_t v130 = *((unsigned int *)this + 165);
              do
              {
                float v131 = *v127++;
                float v132 = (float)(1.0 - v131) / v131;
                if (v131 == 0.0) {
                  float v133 = 1.0e20;
                }
                else {
                  float v133 = v132;
                }
                float v134 = *v124++;
                float v135 = v133 * v134;
                float v136 = *v109++;
                float v137 = (float)(v135 * expf(v136)) + 1.0;
                if (v137 == 0.0) {
                  float v138 = 1.0;
                }
                else {
                  float v138 = 1.0 / v137;
                }
                *v129++ = v138;
                --v130;
              }
              while (v130);
            }
            else
            {
              vDSP_Length v128 = 0;
            }
            float __C = 0.0;
            LODWORD(__A.realp) = 1065353216;
            vDSP_vclip(v108, 1, &__C, (const float *)&__A, v108, 1, v128);
            float v176 = 1.0;
            float __B = v95;
            v139 = (void *)*((void *)this + 97);
            uint64_t v140 = (float *)*((void *)this + 100);
            vDSP_vclip(v140, 1, &__B, &v176, v140, 1, *((unsigned int *)this + 165));
            v141 = (float *)*((void *)this + 100);
            LODWORD(__A.realp) = 1048576000;
            float __C = 0.5;
            v142 = (float *)*((void *)this + 167);
            uint64_t v143 = (float *)*((void *)this + 170);
            float *v142 = 0.0;
            *uint64_t v143 = 0.0;
            vDSP_vsmul(v141 + 1, 1, (const float *)&__A, v143 + 1, 1, (*((_DWORD *)this + 165) - 1));
            memcpy(v142, v143, 4 * *((unsigned int *)this + 165));
            vDSP_vadd(v142, 1, v143 + 1, 1, v142, 1, (*((_DWORD *)this + 165) - 1));
            vDSP_vsmul(v141, 1, &__C, v143, 1, *((unsigned int *)this + 165));
            vDSP_vadd(v142, 1, v143, 1, v142, 1, *((unsigned int *)this + 165));
            float *v142 = (float)(*v141 + v141[1]) * 0.5;
            uint64_t v144 = *((unsigned int *)this + 165);
            v142[(v144 - 1)] = (float)(v141[(v144 - 1)] + v141[(v144 - 2)])
                                           * 0.5;
            memcpy(v141, v142, 4 * v144);
            memcpy(v139, v140, 4 * *((unsigned int *)this + 165));
            LODWORD(__A.realp) = 0;
            if (*((unsigned char *)this + 532))
            {
              unsigned int v145 = *((_DWORD *)this + 165);
              if (v145)
              {
                unsigned __int8 v146 = (float *)*((void *)this + 112);
                BOOL v147 = (float *)*((void *)this + 91);
                v148 = (float *)*((void *)this + 118);
                uint64_t v149 = *((unsigned int *)this + 165);
                do
                {
                  float v150 = *v146++;
                  double v151 = v150;
                  float v152 = *v147++;
                  float v153 = v151 / (v152 + 1.0e-20);
                  if (v153 > 1.0) {
                    float v153 = 1.0;
                  }
                  *v148++ = sqrtf(v153);
                  --v149;
                }
                while (v149);
              }
              uint64_t v154 = v169;
            }
            else
            {
              vDSP_vfill((const float *)&__A, *((float **)this + 118), 1, *((unsigned int *)this + 165));
              unsigned int v145 = *((_DWORD *)this + 165);
              uint64_t v154 = v169;
              if (!*((unsigned char *)this + 532)) {
                goto LABEL_132;
              }
            }
            vDSP_vmax((const float *)v139, 1, *((const float **)this + 118), 1, (float *)v139, 1, v145);
            unsigned int v145 = *((_DWORD *)this + 165);
LABEL_132:
            v155 = (float *)*((void *)this + 94);
            v156 = (const float *)*((void *)this + 91);
            v157 = (float *)*((void *)this + 164);
            float __C = 0.8;
            float v173 = 0.2;
            vDSP_vmul((const float *)v139, 1, (const float *)v139, 1, v157, 1, v145);
            vDSP_vmul(v157, 1, v156, 1, v157, 1, *((unsigned int *)this + 165));
            vDSP_vsmul(v157, 1, &__C, v157, 1, *((unsigned int *)this + 165));
            vDSP_vsmul(v155, 1, &v173, v155, 1, *((unsigned int *)this + 165));
            vDSP_vadd(v155, 1, v157, 1, v155, 1, *((unsigned int *)this + 165));
            vDSP_vmul(v156, 1, (const float *)v139, 1, v157, 1, *((unsigned int *)this + 165));
            vDSP_vmul(v157, 1, (const float *)v139, 1, v157, 1, *((unsigned int *)this + 165));
            vDSP_Length v158 = *((unsigned int *)this + 165);
            LODWORD(__A.realp) = 0;
            if (v158)
            {
              vDSP_sve(v157, 1, (float *)&__A, v158);
              float v159 = (float)(*(float *)&__A.realp / (float)v158) + 1.0e-20;
            }
            else
            {
              float v159 = 1.0e-20;
            }
            float v160 = log10f(v159) * 10.0;
            *((float *)this + 277) = v160;
            float v161 = v160;
            if (!*((unsigned char *)this + 1100)) {
              float v161 = (float)(v160 * 0.8) + (float)(*((float *)this + 278) * 0.2);
            }
            *((float *)this + 278) = v161;
            float __C = 1.0;
            float v162 = *((float *)this + 156);
            if (v160 >= (float)(v162 + -10.0))
            {
              if (v161 >= (float)(v162 + -5.0))
              {
                if (v161 >= v162)
                {
LABEL_144:
                  vDSP_vsmul((const float *)v139, 1, &__C, (float *)v139, 1, *((unsigned int *)this + 165));
                  if (*((unsigned char *)this + 532)) {
                    vDSP_vmax((const float *)v139, 1, *((const float **)this + 118), 1, (float *)v139, 1, *((unsigned int *)this + 165));
                  }
                  BOOL v164 = (float *)*((void *)this + 103);
                  if (*((unsigned char *)this + 1100))
                  {
                    memcpy(*((void **)this + 103), v139, 4 * *((unsigned int *)this + 165));
                  }
                  else
                  {
                    float __C = 0.1;
                    vDSP_vsmul(v164, 1, &__C, v164, 1, *((unsigned int *)this + 165));
                    float __C = 0.9;
                    vDSP_vsmul((const float *)v139, 1, &__C, (float *)v139, 1, *((unsigned int *)this + 165));
                    vDSP_vadd((const float *)v139, 1, v164, 1, v164, 1, *((unsigned int *)this + 165));
                  }
                  float __B = 0.0;
                  vDSP_vclip(*((const float **)this + 97), 1, &__B, &v176, *((float **)this + 97), 1, *((unsigned int *)this + 165));
                  uint64_t v165 = (const float *)*((void *)this + 97);
                  vDSP_Length v166 = *((unsigned int *)this + 162);
                  uint64_t v167 = &v154[v166];
                  uint64_t v168 = &v125[v166];
                  vDSP_vmul(v154, 1, v165, 1, v125, 1, v166);
                  vDSP_vmul(v167 + 1, 1, v165 + 1, 1, v168 + 1, 1, (v166 - 1));
                  *uint64_t v168 = *v167 * v165[v166];
                  *((unsigned char *)this + 1100) = 0;
                  std::vector<float>::__assign_with_size[abi:ne180100]<std::__wrap_iter<float *>,std::__wrap_iter<float *>>((char *)this + 848, *((char **)this + 97), *((void *)this + 98), (uint64_t)(*((void *)this + 98) - *((void *)this + 97)) >> 2);
                  *((_DWORD *)this + 276) = *((_DWORD *)this + 277);
                  memcpy(*((void **)this + 143), *((const void **)this + 140), 4 * *((unsigned int *)this + 165));
                  unsigned int v17 = (void *)*((void *)this + 91);
                  uint64_t v16 = (void *)*((void *)this + 94);
                  size_t v15 = 4 * *((unsigned int *)this + 165);
                  goto LABEL_150;
                }
                float v163 = 0.0065;
              }
              else
              {
                float v163 = 0.0045;
              }
            }
            else
            {
              float v163 = 0.0025;
            }
            float __C = v163;
            goto LABEL_144;
          }
          if (v101 > (float)(v102 + -14.0))
          {
LABEL_88:
            float v95 = 0.031623;
            goto LABEL_92;
          }
        }
        else if (!v92)
        {
          float v93 = *((float *)this + 172);
          float v94 = *((float *)this + 154);
          if (v93 > (float)(v94 + 6.0))
          {
            float v95 = 0.50119;
            goto LABEL_92;
          }
          if (v93 > v94)
          {
            float v95 = 0.31623;
            goto LABEL_92;
          }
          if (v93 > (float)(v94 + -6.0))
          {
            float v95 = 0.1;
            goto LABEL_92;
          }
          if (v93 > (float)(v94 + -12.0)) {
            goto LABEL_88;
          }
          if (v93 > (float)(v94 + -20.0))
          {
            float v95 = 0.01;
            goto LABEL_92;
          }
        }
        float v95 = 0.0031623;
        goto LABEL_92;
      }
      unint64_t v28 = (void *)*((void *)this + 140);
      uint64_t v29 = (const void *)*((void *)this + 71);
    }
    memcpy(v28, v29, 4 * *((unsigned int *)this + 165));
    goto LABEL_22;
  }
  size_t v15 = *((unsigned int *)this + 173);
  uint64_t v16 = (*a7)->mBuffers[0].mData;
  unsigned int v17 = (*a5)->mBuffers[0].mData;
LABEL_150:
  memcpy(v16, v17, v15);
  return 0;
}

float AULevelDrivenSuppressor::InitializeInternals(AULevelDrivenSuppressor *this)
{
  uint64_t v2 = (AULevelDrivenSuppressor *)((char *)this + 32);
  uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::GetElement((AULevelDrivenSuppressor *)((char *)this + 32), 0);
  unsigned int Parameter = ausdk::AUElement::GetParameter(Element, 0);
  if (Parameter >= 2) {
    unsigned int Parameter = 2;
  }
  *((_DWORD *)this + 132) = Parameter;
  int v5 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v2, 0);
  float v6 = ausdk::AUElement::GetParameter(v5, 1u);
  *((float *)this + 154) = v6;
  int v7 = 0;
  if (v6 > 0.0 || (int v7 = -1024458752, v6 < -120.0))
  {
    *((_DWORD *)this + 154) = v7;
    float v6 = *(float *)&v7;
  }
  *((float *)this + 158) = __exp10f(v6 * 0.1);
  AudioUnitParameterValue v8 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v2, 0);
  float v9 = ausdk::AUElement::GetParameter(v8, 2u);
  *((float *)this + 155) = v9;
  int v10 = 0;
  if (v9 > 0.0 || (int v10 = -1018691584, v9 < -200.0))
  {
    *((_DWORD *)this + 155) = v10;
    float v9 = *(float *)&v10;
  }
  *((float *)this + 160) = __exp10f(v9 * 0.1);
  int v11 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v2, 0);
  float v12 = ausdk::AUElement::GetParameter(v11, 3u);
  *((float *)this + 156) = v12;
  int v13 = 0;
  if (v12 > 0.0 || (int v13 = -1024458752, v12 < -120.0)) {
    *((_DWORD *)this + 156) = v13;
  }
  uint64_t v14 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v2, 0);
  *((unsigned char *)this + 532) = ausdk::AUElement::GetParameter(v14, 4u) != 0;
  *((float *)this + 157) = *((float *)this + 154) + *((float *)this + 155);
  float result = *((float *)this + 158) * 0.25;
  *((float *)this + 159) = result;
  return result;
}

char *std::vector<float>::__assign_with_size[abi:ne180100]<std::__wrap_iter<float *>,std::__wrap_iter<float *>>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  int v7 = result;
  uint64_t v8 = *((void *)result + 2);
  float v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 2)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *int v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 62) {
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 1;
    if (v8 >> 1 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v11 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    float result = std::vector<unsigned int>::__vallocate[abi:ne180100](v7, v11);
    int v13 = (char *)v7[1];
    float v12 = (void **)(v7 + 1);
    float v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      uint64_t v18 = v9;
      uint64_t v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  float v12 = (void **)(result + 8);
  uint64_t v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 2;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  uint64_t v16 = &__src[4 * v15];
  if (v14 != v9)
  {
    float result = (char *)memmove(*(void **)result, __src, 4 * v15);
    float v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    uint64_t v18 = v9;
    uint64_t v19 = v16;
LABEL_18:
    float result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  NSObject *v12 = &v9[v17];
  return result;
}

uint64_t AULevelDrivenSuppressor::CanScheduleParameters(AULevelDrivenSuppressor *this)
{
  return 0;
}

uint64_t AULevelDrivenSuppressor::SetParameter(AULevelDrivenSuppressor *this, unsigned int a2, unsigned int a3, unsigned int a4, float a5)
{
  if (a3)
  {
    Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
    uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
    ausdk::AUElement::SetParameter(Element, a2, a5, 0);
  }
  else
  {
    unint64_t v11 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AULevelDrivenSuppressor *)((char *)this + 32), a4);
    ausdk::AUElement::SetParameter(v11, a2, a5, 0);
    if (a2 <= 4) {
      ++*((_DWORD *)this + 134);
    }
  }
  return 0;
}

uint64_t AULevelDrivenSuppressor::SetProperty(AULevelDrivenSuppressor *this, int a2, int a3, unsigned int a4, _DWORD *__src, size_t __n)
{
  if (a3) {
    return 4294956417;
  }
  uint64_t result = 4294956417;
  if (a2 > 8000)
  {
    if (a2 == 8001)
    {
      if (__n == 4 && *((_DWORD *)this + 141) <= 6u)
      {
        uint64_t result = 0;
        *((_DWORD *)this + 141) = *__src;
        return result;
      }
    }
    else
    {
      if (a2 != 8020) {
        return result;
      }
      if (!*((unsigned char *)this + 17)) {
        return 0;
      }
      if (__n == 4 * (*((_DWORD *)this + 84) + 1))
      {
        memcpy(*((void **)this + 71), __src, __n);
        return 0;
      }
    }
    return 4294956445;
  }
  if (a2 == 21)
  {
    *((unsigned char *)this + 557) = *__src != 0;
    uint64_t v8 = (FILE **)MEMORY[0x1E4F143D8];
    fprintf((FILE *)*MEMORY[0x1E4F143D8], "%4d %s %s \n", 584, "SetProperty", "03:50:05");
    fflush(*v8);
    return 0;
  }
  if (a2 == 3700)
  {
    uint64_t result = 4294956445;
    if (__n >= 4)
    {
      if (*(unsigned char *)__src) {
        return 0;
      }
      else {
        return 4294956445;
      }
    }
  }
  return result;
}

uint64_t AULevelDrivenSuppressor::GetProperty(AULevelDrivenSuppressor *this, int a2, int a3, unsigned int a4, float *__C)
{
  if (a3) {
    return 4294956417;
  }
  uint64_t result = 4294956417;
  if (a2 <= 8000)
  {
    if (a2 == 21)
    {
      uint64_t result = 0;
      int v7 = *((unsigned __int8 *)this + 557);
    }
    else
    {
      if (a2 != 3700) {
        return result;
      }
      uint64_t result = 0;
      int v7 = *((unsigned __int8 *)this + 376);
    }
    goto LABEL_13;
  }
  if (a2 == 8001)
  {
    uint64_t result = 0;
    int v7 = *((_DWORD *)this + 141);
LABEL_13:
    *(_DWORD *)float __C = v7;
    return result;
  }
  if (a2 == 8020)
  {
    if (*((unsigned char *)this + 17)) {
      memcpy(__C, *((const void **)this + 71), 4 * (*((_DWORD *)this + 84) + 1));
    }
    else {
      vDSP_vclr(__C, 1, (*((_DWORD *)this + 84) + 1));
    }
    return 0;
  }
  return result;
}

uint64_t AULevelDrivenSuppressor::GetPropertyInfo(AULevelDrivenSuppressor *this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  if (a3) {
    return 4294956417;
  }
  uint64_t result = 4294956417;
  if (a2 <= 8000)
  {
    if (a2 != 21)
    {
      if (a2 != 3700) {
        return result;
      }
      *a6 = 0;
      goto LABEL_13;
    }
    char v9 = 1;
LABEL_12:
    *a6 = v9;
LABEL_13:
    int v8 = 4;
    goto LABEL_14;
  }
  if (a2 == 8001)
  {
    char v9 = *((unsigned char *)this + 17) ^ 1;
    goto LABEL_12;
  }
  if (a2 != 8020) {
    return result;
  }
  *a6 = 1;
  int v8 = 4 * *((_DWORD *)this + 84) + 4;
LABEL_14:
  uint64_t result = 0;
  *a5 = v8;
  return result;
}

uint64_t AULevelDrivenSuppressor::Reset(AULevelDrivenSuppressor *this)
{
  *(_OWORD *)((char *)this + 536) = xmmword_1BB873AA0;
  if (*((unsigned char *)this + 17))
  {
    uint64_t v2 = (void *)*((void *)this + 74);
    uint64_t v3 = *((void *)this + 75) - (void)v2;
    if (v3 >= 1) {
      bzero(v2, 4 * (((unint64_t)v3 >> 2) - ((unint64_t)v3 > 3)) + 4);
    }
    uint64_t v4 = (void *)*((void *)this + 88);
    uint64_t v5 = *((void *)this + 89) - (void)v4;
    if (v5 >= 1) {
      bzero(v4, 4 * (((unint64_t)v5 >> 2) - ((unint64_t)v5 > 3)) + 4);
    }
    float v6 = (void *)*((void *)this + 91);
    uint64_t v7 = *((void *)this + 92) - (void)v6;
    if (v7 >= 1) {
      bzero(v6, 4 * (((unint64_t)v7 >> 2) - ((unint64_t)v7 > 3)) + 4);
    }
    int v8 = (void *)*((void *)this + 94);
    uint64_t v9 = *((void *)this + 95) - (void)v8;
    if (v9 >= 1) {
      bzero(v8, 4 * (((unint64_t)v9 >> 2) - ((unint64_t)v9 > 3)) + 4);
    }
    uint64_t v10 = (void *)*((void *)this + 97);
    uint64_t v11 = *((void *)this + 98) - (void)v10;
    if (v11 >= 1) {
      memset_pattern16(v10, &unk_1BB873A60, 4 * (((unint64_t)v11 >> 2) - ((unint64_t)v11 > 3)) + 4);
    }
    float v12 = (void *)*((void *)this + 100);
    uint64_t v13 = *((void *)this + 101) - (void)v12;
    if (v13 >= 1) {
      memset_pattern16(v12, &unk_1BB873A60, 4 * (((unint64_t)v13 >> 2) - ((unint64_t)v13 > 3)) + 4);
    }
    uint64_t v14 = (void *)*((void *)this + 103);
    uint64_t v15 = *((void *)this + 104) - (void)v14;
    if (v15 >= 1) {
      memset_pattern16(v14, &unk_1BB873A60, 4 * (((unint64_t)v15 >> 2) - ((unint64_t)v15 > 3)) + 4);
    }
    uint64_t v16 = (void *)*((void *)this + 106);
    uint64_t v17 = *((void *)this + 107) - (void)v16;
    if (v17 >= 1) {
      memset_pattern16(v16, &unk_1BB873A60, 4 * (((unint64_t)v17 >> 2) - ((unint64_t)v17 > 3)) + 4);
    }
    uint64_t v18 = (void *)*((void *)this + 124);
    uint64_t v19 = *((void *)this + 125) - (void)v18;
    if (v19 >= 1) {
      bzero(v18, 4 * (((unint64_t)v19 >> 2) - ((unint64_t)v19 > 3)) + 4);
    }
    BOOL v20 = (void *)*((void *)this + 127);
    uint64_t v21 = *((void *)this + 128) - (void)v20;
    if (v21 >= 1) {
      bzero(v20, 4 * (((unint64_t)v21 >> 2) - ((unint64_t)v21 > 3)) + 4);
    }
    int v22 = (void *)*((void *)this + 130);
    uint64_t v23 = *((void *)this + 131) - (void)v22;
    if (v23 >= 1) {
      bzero(v22, 4 * (((unint64_t)v23 >> 2) - ((unint64_t)v23 > 3)) + 4);
    }
    float v24 = (void *)*((void *)this + 140);
    uint64_t v25 = *((void *)this + 141) - (void)v24;
    if (v25 >= 1) {
      bzero(v24, 4 * (((unint64_t)v25 >> 2) - ((unint64_t)v25 > 3)) + 4);
    }
    float v26 = (void *)*((void *)this + 143);
    uint64_t v27 = *((void *)this + 144) - (void)v26;
    if (v27 >= 1) {
      bzero(v26, 4 * (((unint64_t)v27 >> 2) - ((unint64_t)v27 > 3)) + 4);
    }
    unint64_t v28 = (void *)*((void *)this + 146);
    uint64_t v29 = *((void *)this + 147) - (void)v28;
    if (v29 >= 1) {
      bzero(v28, 4 * (((unint64_t)v29 >> 2) - ((unint64_t)v29 > 3)) + 4);
    }
    CFDictionaryRef v30 = (void *)*((void *)this + 149);
    uint64_t v31 = *((void *)this + 150) - (void)v30;
    if (v31 >= 1) {
      bzero(v30, 4 * (((unint64_t)v31 >> 2) - ((unint64_t)v31 > 3)) + 4);
    }
    CFNumberRef v32 = (void *)*((void *)this + 152);
    uint64_t v33 = *((void *)this + 153) - (void)v32;
    if (v33 >= 1) {
      bzero(v32, 4 * (((unint64_t)v33 >> 2) - ((unint64_t)v33 > 3)) + 4);
    }
    CFNumberRef v34 = (void *)*((void *)this + 155);
    uint64_t v35 = *((void *)this + 156) - (void)v34;
    if (v35 >= 1) {
      bzero(v34, 4 * (((unint64_t)v35 >> 2) - ((unint64_t)v35 > 3)) + 4);
    }
    vDSP_Length v36 = (void *)*((void *)this + 158);
    uint64_t v37 = *((void *)this + 159) - (void)v36;
    if (v37 >= 1) {
      bzero(v36, 4 * (((unint64_t)v37 >> 2) - ((unint64_t)v37 > 3)) + 4);
    }
    uint64_t v38 = (void *)*((void *)this + 161);
    uint64_t v39 = *((void *)this + 162) - (void)v38;
    if (v39 >= 1) {
      bzero(v38, 4 * (((unint64_t)v39 >> 2) - ((unint64_t)v39 > 3)) + 4);
    }
    uint64_t v40 = (void *)*((void *)this + 186);
    uint64_t v41 = *((void *)this + 187) - (void)v40;
    if (v41 >= 1) {
      bzero(v40, 4 * (((unint64_t)v41 >> 2) - ((unint64_t)v41 > 3)) + 4);
    }
    unint64_t v42 = (void *)*((void *)this + 220);
    uint64_t v43 = *((void *)this + 221) - (void)v42;
    if (v43 >= 1) {
      bzero(v42, 4 * (((unint64_t)v43 >> 2) - ((unint64_t)v43 > 3)) + 4);
    }
    float v44 = (void *)*((void *)this + 112);
    uint64_t v45 = *((void *)this + 113) - (void)v44;
    if (v45 >= 1) {
      bzero(v44, 4 * (((unint64_t)v45 >> 2) - ((unint64_t)v45 > 3)) + 4);
    }
    vDSP_Length v46 = (void *)*((void *)this + 115);
    uint64_t v47 = *((void *)this + 116) - (void)v46;
    if (v47 >= 1) {
      bzero(v46, 4 * (((unint64_t)v47 >> 2) - ((unint64_t)v47 > 3)) + 4);
    }
    uint64_t v48 = (void *)*((void *)this + 118);
    uint64_t v49 = *((void *)this + 119) - (void)v48;
    if (v49 >= 1) {
      bzero(v48, 4 * (((unint64_t)v49 >> 2) - ((unint64_t)v49 > 3)) + 4);
    }
  }
  *(void *)((char *)this + 1092) = 0;
  *((unsigned char *)this + 1100) = 1;
  *((_DWORD *)this + 138) = 0;
  *((_DWORD *)this + 276) = 0;
  *((_DWORD *)this + 278) = 0;
  return 0;
}

uint64_t AULevelDrivenSuppressor::Initialize(AULevelDrivenSuppressor *this)
{
  uint64_t v2 = (AULevelDrivenSuppressor *)((char *)this + 80);
  uint64_t v3 = *((void *)this + 15);
  if (v3)
  {
    int v4 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 24))(v3);
    uint64_t v5 = *((void *)this + 15);
    *((_DWORD *)this + 140) = v4;
    if (v5) {
      LODWORD(v6) = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 24))(v5);
    }
    else {
      uint64_t v6 = (*((void *)this + 13) - *((void *)this + 12)) >> 3;
    }
  }
  else
  {
    uint64_t v6 = (*((void *)this + 13) - *((void *)this + 12)) >> 3;
    *((_DWORD *)this + 140) = v6;
  }
  if (v6 < 2)
  {
LABEL_10:
    if (*(_DWORD *)(ausdk::AUScope::SafeGetElement(v2, 0) + 108) == 1)
    {
      int v9 = *((_DWORD *)this + 84);
      *((_DWORD *)this + 162) = v9;
      *((_DWORD *)this + 163) = v9;
      *((_DWORD *)this + 164) = 2 * v9;
      *((_DWORD *)this + 165) = v9 + 1;
      float v10 = *(double *)(ausdk::AUScope::SafeGetElement(v2, 0) + 80);
      *((float *)this + 161) = v10;
      *((float *)this + 166) = v10 / (float)*((unsigned int *)this + 162);
      int32x2_t v11 = *(int32x2_t *)((char *)this + 656);
      *((float *)this + 170) = 1.0 / (float)v11.u32[0];
      *(int32x2_t *)((char *)this + 692) = vshl_n_s32(v11, 2uLL);
      std::vector<float>::resize((uint64_t)this + 1312, v11.u32[0]);
      std::vector<float>::resize((uint64_t)this + 1336, *((unsigned int *)this + 164));
      *((_DWORD *)this + 171) = 1065353216;
      CreateMagicalWindow(*((void *)this + 167), *((_DWORD *)this + 164));
      uint64_t v12 = *((void *)this + 84);
      if (v12) {
        MultiRadixFFT_Dispose(v12);
      }
      *((void *)this + 84) = 0;
      MultiRadixRealFFT_Create();
    }
  }
  else
  {
    unsigned int v7 = 1;
    while (1)
    {
      uint64_t Element = ausdk::AUScope::SafeGetElement(v2, v7 - 1);
      if (*(double *)(Element + 80) != *(double *)(ausdk::AUScope::SafeGetElement(v2, v7) + 80)) {
        break;
      }
      if (v6 == ++v7) {
        goto LABEL_10;
      }
    }
  }
  return 4294956428;
}

void ___ZL14AUlsupLogScopev_block_invoke()
{
}

void AULevelDrivenSuppressor::~AULevelDrivenSuppressor(AULevelDrivenSuppressor *this)
{
  AULevelDrivenSuppressor::~AULevelDrivenSuppressor(this);

  JUMPOUT(0x1C185D370);
}

{
  void (**v2)(AULevelDrivenSuppressor *);
  uint64_t v3;
  void *v4;
  void *v5;
  void *v6;
  std::__shared_weak_count *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  void *v43;
  void *v44;
  uint64_t vars8;

  uint64_t v2 = (void (**)(AULevelDrivenSuppressor *))&unk_1F14AB528;
  *(void *)this = &unk_1F14AB528;
  uint64_t v3 = *((void *)this + 84);
  if (v3)
  {
    MultiRadixFFT_Dispose(v3);
    uint64_t v2 = *(void (***)(AULevelDrivenSuppressor *))this;
  }
  v2[8](this);
  int v4 = (void *)*((void *)this + 223);
  if (v4)
  {
    *((void *)this + 224) = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)*((void *)this + 220);
  if (v5)
  {
    *((void *)this + 221) = v5;
    operator delete(v5);
  }
  uint64_t v6 = (void *)*((void *)this + 217);
  if (v6)
  {
    *((void *)this + 218) = v6;
    operator delete(v6);
  }
  unsigned int v7 = (std::__shared_weak_count *)*((void *)this + 216);
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  int v8 = (void *)*((void *)this + 201);
  if (v8)
  {
    *((void *)this + 202) = v8;
    operator delete(v8);
  }
  int v9 = (void *)*((void *)this + 198);
  if (v9)
  {
    *((void *)this + 199) = v9;
    operator delete(v9);
  }
  float v10 = (void *)*((void *)this + 195);
  if (v10)
  {
    *((void *)this + 196) = v10;
    operator delete(v10);
  }
  int32x2_t v11 = (void *)*((void *)this + 192);
  if (v11)
  {
    *((void *)this + 193) = v11;
    operator delete(v11);
  }
  uint64_t v12 = (void *)*((void *)this + 189);
  if (v12)
  {
    *((void *)this + 190) = v12;
    operator delete(v12);
  }
  uint64_t v13 = (void *)*((void *)this + 186);
  if (v13)
  {
    *((void *)this + 187) = v13;
    operator delete(v13);
  }
  uint64_t v14 = (void *)*((void *)this + 183);
  if (v14)
  {
    *((void *)this + 184) = v14;
    operator delete(v14);
  }
  uint64_t v15 = (void *)*((void *)this + 180);
  if (v15)
  {
    *((void *)this + 181) = v15;
    operator delete(v15);
  }
  uint64_t v16 = (void *)*((void *)this + 177);
  if (v16)
  {
    *((void *)this + 178) = v16;
    operator delete(v16);
  }
  uint64_t v17 = (void *)*((void *)this + 173);
  if (v17)
  {
    *((void *)this + 174) = v17;
    operator delete(v17);
  }
  uint64_t v18 = (void *)*((void *)this + 170);
  if (v18)
  {
    *((void *)this + 171) = v18;
    operator delete(v18);
  }
  uint64_t v19 = (void *)*((void *)this + 167);
  if (v19)
  {
    *((void *)this + 168) = v19;
    operator delete(v19);
  }
  BOOL v20 = (void *)*((void *)this + 164);
  if (v20)
  {
    *((void *)this + 165) = v20;
    operator delete(v20);
  }
  uint64_t v21 = (void *)*((void *)this + 161);
  if (v21)
  {
    *((void *)this + 162) = v21;
    operator delete(v21);
  }
  int v22 = (void *)*((void *)this + 158);
  if (v22)
  {
    *((void *)this + 159) = v22;
    operator delete(v22);
  }
  uint64_t v23 = (void *)*((void *)this + 155);
  if (v23)
  {
    *((void *)this + 156) = v23;
    operator delete(v23);
  }
  float v24 = (void *)*((void *)this + 152);
  if (v24)
  {
    *((void *)this + 153) = v24;
    operator delete(v24);
  }
  uint64_t v25 = (void *)*((void *)this + 149);
  if (v25)
  {
    *((void *)this + 150) = v25;
    operator delete(v25);
  }
  float v26 = (void *)*((void *)this + 146);
  if (v26)
  {
    *((void *)this + 147) = v26;
    operator delete(v26);
  }
  uint64_t v27 = (void *)*((void *)this + 143);
  if (v27)
  {
    *((void *)this + 144) = v27;
    operator delete(v27);
  }
  unint64_t v28 = (void *)*((void *)this + 140);
  if (v28)
  {
    *((void *)this + 141) = v28;
    operator delete(v28);
  }
  uint64_t v29 = (void *)*((void *)this + 130);
  if (v29)
  {
    *((void *)this + 131) = v29;
    operator delete(v29);
  }
  CFDictionaryRef v30 = (void *)*((void *)this + 127);
  if (v30)
  {
    *((void *)this + 128) = v30;
    operator delete(v30);
  }
  uint64_t v31 = (void *)*((void *)this + 124);
  if (v31)
  {
    *((void *)this + 125) = v31;
    operator delete(v31);
  }
  CFNumberRef v32 = (void *)*((void *)this + 118);
  if (v32)
  {
    *((void *)this + 119) = v32;
    operator delete(v32);
  }
  uint64_t v33 = (void *)*((void *)this + 115);
  if (v33)
  {
    *((void *)this + 116) = v33;
    operator delete(v33);
  }
  CFNumberRef v34 = (void *)*((void *)this + 112);
  if (v34)
  {
    *((void *)this + 113) = v34;
    operator delete(v34);
  }
  uint64_t v35 = (void *)*((void *)this + 109);
  if (v35)
  {
    *((void *)this + 110) = v35;
    operator delete(v35);
  }
  vDSP_Length v36 = (void *)*((void *)this + 106);
  if (v36)
  {
    *((void *)this + 107) = v36;
    operator delete(v36);
  }
  uint64_t v37 = (void *)*((void *)this + 103);
  if (v37)
  {
    *((void *)this + 104) = v37;
    operator delete(v37);
  }
  uint64_t v38 = (void *)*((void *)this + 100);
  if (v38)
  {
    *((void *)this + 101) = v38;
    operator delete(v38);
  }
  uint64_t v39 = (void *)*((void *)this + 97);
  if (v39)
  {
    *((void *)this + 98) = v39;
    operator delete(v39);
  }
  uint64_t v40 = (void *)*((void *)this + 94);
  if (v40)
  {
    *((void *)this + 95) = v40;
    operator delete(v40);
  }
  uint64_t v41 = (void *)*((void *)this + 91);
  if (v41)
  {
    *((void *)this + 92) = v41;
    operator delete(v41);
  }
  unint64_t v42 = (void *)*((void *)this + 88);
  if (v42)
  {
    *((void *)this + 89) = v42;
    operator delete(v42);
  }
  uint64_t v43 = (void *)*((void *)this + 74);
  if (v43)
  {
    *((void *)this + 75) = v43;
    operator delete(v43);
  }
  float v44 = (void *)*((void *)this + 71);
  if (v44)
  {
    *((void *)this + 72) = v44;
    operator delete(v44);
  }

  ausdk::AUBase::~AUBase(this);
}

AUProcessingBlockBase *VoiceProcessorV2::VPAUProcessingBlock::RemoveAUAtIndex(AUProcessingBlockBase *this, unsigned int a2)
{
  if (*(void *)(*((void *)this + 3) + 24 * a2 + 16))
  {
    uint64_t v2 = this;
    AUPBUnregisterAU();
    AUProcessingBlockBase::RemoveAUAtIndex(v2);
    return (AUProcessingBlockBase *)AUPBPropertiesChanged();
  }
  return this;
}

uint64_t AUProcessingBlock_AU::AUSetParameter(int a1, AudioUnit inUnit, AudioUnitParameterID inID, AudioUnitScope inScope, AudioUnitElement inElement, AudioUnitParameterValue a6)
{
  return AudioUnitSetParameter(inUnit, inID, inScope, inElement, a6, 0);
}

uint64_t AUProcessingBlock_AU::AUGetParameter(int a1, AudioUnit inUnit, AudioUnitParameterID inID, AudioUnitScope inScope, AudioUnitElement inElement, AudioUnitParameterValue *outValue)
{
  return AudioUnitGetParameter(inUnit, inID, inScope, inElement, outValue);
}

uint64_t AUProcessingBlock_AU::AUSetProperty(int a1, AudioUnit inUnit, AudioUnitPropertyID inID, AudioUnitScope inScope, AudioUnitElement inElement, void *inData, UInt32 inDataSize)
{
  return AudioUnitSetProperty(inUnit, inID, inScope, inElement, inData, inDataSize);
}

uint64_t AUProcessingBlock_AU::AUGetProperty(int a1, AudioUnit inUnit, AudioUnitPropertyID inID, AudioUnitScope inScope, AudioUnitElement inElement, void *outData, UInt32 *ioDataSize)
{
  return AudioUnitGetProperty(inUnit, inID, inScope, inElement, outData, ioDataSize);
}

uint64_t AUProcessingBlock_AU::AUGetPropertyInfo(int a1, AudioUnit inUnit, AudioUnitPropertyID inID, AudioUnitScope inScope, AudioUnitElement inElement, UInt32 *outDataSize, Boolean *outWritable)
{
  return AudioUnitGetPropertyInfo(inUnit, inID, inScope, inElement, outDataSize, outWritable);
}

OpaqueAudioComponent *VoiceProcessorV2::VPAUProcessingBlock::GetAvailableAUs(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = 0;
  inDesc.componentFlagsMasunint64_t k = 0;
  *(_OWORD *)&inDesc.OSType componentType = *(_OWORD *)"xaua";
  while (1)
  {
    Next = AudioComponentFindNext(v3, &inDesc);
    uint64_t v3 = Next;
    if (!Next) {
      break;
    }
    AudioComponentGetDescription(Next, &outDesc);
    OSType componentType = outDesc.componentType;
    OSType componentSubType = outDesc.componentSubType;
    OSType componentManufacturer = outDesc.componentManufacturer;
    int v9 = *(OSType **)(a2 + 8);
    unint64_t v8 = *(void *)(a2 + 16);
    if ((unint64_t)v9 >= v8)
    {
      int32x2_t v11 = *(OSType **)a2;
      unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v9 - *(void *)a2) >> 2);
      unint64_t v13 = v12 + 1;
      if (v12 + 1 > 0x1555555555555555) {
LABEL_82:
      }
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v8 - (void)v11) >> 2);
      if (2 * v14 > v13) {
        unint64_t v13 = 2 * v14;
      }
      if (v14 >= 0xAAAAAAAAAAAAAAALL) {
        unint64_t v15 = 0x1555555555555555;
      }
      else {
        unint64_t v15 = v13;
      }
      if (v15)
      {
        unint64_t v15 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<AudioClassDescription>>(v15);
        int32x2_t v11 = *(OSType **)a2;
        int v9 = *(OSType **)(a2 + 8);
      }
      else
      {
        uint64_t v16 = 0;
      }
      uint64_t v17 = (OSType *)(v15 + 12 * v12);
      *uint64_t v17 = componentType;
      v17[1] = componentSubType;
      v17[2] = componentManufacturer;
      uint64_t v18 = v17;
      if (v9 != v11)
      {
        do
        {
          uint64_t v19 = *(void *)(v9 - 3);
          v9 -= 3;
          OSType v20 = v9[2];
          *(void *)(v18 - 3) = v19;
          v18 -= 3;
          v18[2] = v20;
        }
        while (v9 != v11);
        int32x2_t v11 = *(OSType **)a2;
      }
      float v10 = v17 + 3;
      *(void *)a2 = v18;
      *(void *)(a2 + 8) = v17 + 3;
      *(void *)(a2 + 16) = v15 + 12 * v16;
      if (v11) {
        operator delete(v11);
      }
    }
    else
    {
      OSType *v9 = outDesc.componentType;
      v9[1] = componentSubType;
      float v10 = v9 + 3;
      uint64_t v9[2] = componentManufacturer;
    }
    *(void *)(a2 + 8) = v10;
  }
  *(void *)&inDesc.componentFlags = 0;
  *(void *)&inDesc.OSType componentSubType = 0;
  inDesc.OSType componentType = 1635083896;
  while (1)
  {
    uint64_t result = AudioComponentFindNext(v3, &inDesc);
    if (!result) {
      return result;
    }
    uint64_t v3 = result;
    AudioComponentGetDescription(result, &outDesc);
    OSType v22 = outDesc.componentSubType;
    if ((int)outDesc.componentSubType <= 1836280881)
    {
      if ((int)outDesc.componentSubType > 1684366706)
      {
        if ((int)outDesc.componentSubType > 1818583858)
        {
          if ((int)outDesc.componentSubType > 1835298865)
          {
            if (outDesc.componentSubType == 1835298866) {
              goto LABEL_64;
            }
            int v23 = 1835954996;
          }
          else
          {
            if (outDesc.componentSubType == 1818583859) {
              goto LABEL_64;
            }
            int v23 = 1835298419;
          }
        }
        else if ((int)outDesc.componentSubType > 1701278770)
        {
          if (outDesc.componentSubType == 1701278771) {
            goto LABEL_64;
          }
          int v23 = 1718186598;
        }
        else
        {
          if (outDesc.componentSubType == 1684366707) {
            goto LABEL_64;
          }
          int v23 = 1685677163;
        }
        goto LABEL_63;
      }
      if ((int)outDesc.componentSubType > 1651338853)
      {
        if ((int)outDesc.componentSubType > 1651866218)
        {
          if (outDesc.componentSubType == 1651866219) {
            goto LABEL_64;
          }
          int v23 = 1668179822;
        }
        else
        {
          if (outDesc.componentSubType == 1651338854) {
            goto LABEL_64;
          }
          int v23 = 1651402355;
        }
        goto LABEL_63;
      }
      if (outDesc.componentSubType != 1634165554 && outDesc.componentSubType != 1635284067)
      {
        int v23 = 1651323502;
        goto LABEL_63;
      }
      goto LABEL_64;
    }
    if ((int)outDesc.componentSubType > 1936089963)
    {
      if ((int)outDesc.componentSubType > 1953330035)
      {
        if ((int)outDesc.componentSubType > 1986159981)
        {
          if (outDesc.componentSubType == 1987211570) {
            goto LABEL_64;
          }
          int v23 = 1986159982;
        }
        else
        {
          if (outDesc.componentSubType == 1953330036) {
            goto LABEL_64;
          }
          int v23 = 1953790309;
        }
        goto LABEL_63;
      }
      if (outDesc.componentSubType - 1936748594 < 2 || outDesc.componentSubType == 1936089964) {
        goto LABEL_64;
      }
      int v23 = 1936745838;
LABEL_63:
      if (outDesc.componentSubType == v23) {
        goto LABEL_64;
      }
    }
    else
    {
      if ((int)outDesc.componentSubType <= 1868787314)
      {
        if ((int)outDesc.componentSubType > 1851942256)
        {
          if (outDesc.componentSubType == 1851942257) {
            goto LABEL_64;
          }
          int v23 = 1868787301;
        }
        else
        {
          if (outDesc.componentSubType == 1836280882) {
            goto LABEL_64;
          }
          int v23 = 1836282987;
        }
        goto LABEL_63;
      }
      if (outDesc.componentSubType - 1919251251 >= 2 && outDesc.componentSubType != 1868787315)
      {
        int v23 = 1869509428;
        goto LABEL_63;
      }
LABEL_64:
      OSType v24 = outDesc.componentType;
      OSType v25 = outDesc.componentManufacturer;
      uint64_t v27 = *(OSType **)(a2 + 8);
      unint64_t v26 = *(void *)(a2 + 16);
      if ((unint64_t)v27 >= v26)
      {
        uint64_t v29 = *(OSType **)a2;
        unint64_t v30 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v27 - *(void *)a2) >> 2);
        unint64_t v31 = v30 + 1;
        if (v30 + 1 > 0x1555555555555555) {
          goto LABEL_82;
        }
        unint64_t v32 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v26 - (void)v29) >> 2);
        if (2 * v32 > v31) {
          unint64_t v31 = 2 * v32;
        }
        if (v32 >= 0xAAAAAAAAAAAAAAALL) {
          unint64_t v33 = 0x1555555555555555;
        }
        else {
          unint64_t v33 = v31;
        }
        if (v33)
        {
          unint64_t v33 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<AudioClassDescription>>(v33);
          uint64_t v29 = *(OSType **)a2;
          uint64_t v27 = *(OSType **)(a2 + 8);
        }
        else
        {
          uint64_t v34 = 0;
        }
        uint64_t v35 = (OSType *)(v33 + 12 * v30);
        *uint64_t v35 = v24;
        v35[1] = v22;
        v35[2] = v25;
        vDSP_Length v36 = v35;
        if (v27 != v29)
        {
          do
          {
            uint64_t v37 = *(void *)(v27 - 3);
            v27 -= 3;
            OSType v38 = v27[2];
            *(void *)(v36 - 3) = v37;
            v36 -= 3;
            _OWORD v36[2] = v38;
          }
          while (v27 != v29);
          uint64_t v29 = *(OSType **)a2;
        }
        unint64_t v28 = v35 + 3;
        *(void *)a2 = v36;
        *(void *)(a2 + 8) = v35 + 3;
        *(void *)(a2 + 16) = v33 + 12 * v34;
        if (v29) {
          operator delete(v29);
        }
      }
      else
      {
        OSType *v27 = outDesc.componentType;
        v27[1] = v22;
        unint64_t v28 = v27 + 3;
        v27[2] = v25;
      }
      *(void *)(a2 + 8) = v28;
    }
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<AudioClassDescription>>(unint64_t a1)
{
  if (a1 >= 0x1555555555555556) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(12 * a1);
}

void VoiceProcessorV2::VPAUProcessingBlock::~VPAUProcessingBlock(VoiceProcessorV2::VPAUProcessingBlock *this)
{
  AUProcessingBlockBase::~AUProcessingBlockBase(this);

  JUMPOUT(0x1C185D370);
}

unint64_t VoiceProcessorV2::VPAUProcessingBlock::FindIndex(const AUPBUnit *this, const AUPBUnit *a2, uint64_t a3)
{
  uint64_t v3 = a2 - this;
  if (a2 == this) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v5 = 0;
  unint64_t result = 0;
  unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * (v3 >> 3);
  while (1)
  {
    unint64_t v8 = (_DWORD *)((char *)this + 24 * v5);
    if (*v8 == *(_DWORD *)a3
      && v8[1] == *(_DWORD *)(a3 + 4)
      && v8[2] == *(_DWORD *)(a3 + 8)
      && *((void *)this + 3 * v5 + 2) == *(void *)(a3 + 16))
    {
      break;
    }
    unint64_t v5 = (result + 1);
    unint64_t result = v5;
    if (v7 <= v5) {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

BOOL VoiceProcessorV2::AUIsInDownLinkProcessingChain(VoiceProcessorV2 *this, const AUPBUnit *a2)
{
  __dst[55] = *MEMORY[0x1E4F143B8];
  {
    int v23 = this;
    OSType v20 = a2;
    a2 = v20;
    int v22 = v21;
    this = v23;
    if (v22)
    {
      memcpy(__dst, "2qrv\b", 0x1B8uLL);
      std::multimap<unsigned int,unsigned int>::multimap[abi:ne180100](__dst, 55);
      __cxa_atexit((void (*)(void *))std::multimap<unsigned int,unsigned int>::~multimap[abi:ne180100], &VoiceProcessorV2::AUIsInDownLinkProcessingChain(AUPBUnit const&)::downlinkProcessingDB, &dword_1BB0CE000);
      this = v23;
      a2 = v20;
    }
  }
  uint64_t v2 = qword_1E9F7DF30;
  if (!qword_1E9F7DF30)
  {
LABEL_9:
    uint64_t v6 = *((void *)a2 + 2);
    return v6 == *((void *)this + 1559);
  }
  unsigned int v3 = *((_DWORD *)a2 + 1);
  int v4 = &qword_1E9F7DF30;
  while (1)
  {
    unsigned int v5 = *(_DWORD *)(v2 + 28);
    if (v3 >= v5) {
      break;
    }
    int v4 = (uint64_t *)v2;
LABEL_8:
    uint64_t v2 = *(void *)v2;
    if (!v2) {
      goto LABEL_9;
    }
  }
  if (v5 < v3)
  {
    v2 += 8;
    goto LABEL_8;
  }
  uint64_t v8 = *(void *)v2;
  int v9 = (uint64_t *)v2;
  if (*(void *)v2)
  {
    int v9 = (uint64_t *)v2;
    do
    {
      unsigned int v10 = *(_DWORD *)(v8 + 28);
      BOOL v11 = v10 >= v3;
      if (v10 >= v3) {
        unint64_t v12 = (uint64_t *)v8;
      }
      else {
        unint64_t v12 = (uint64_t *)(v8 + 8);
      }
      if (v11) {
        int v9 = (uint64_t *)v8;
      }
      uint64_t v8 = *v12;
    }
    while (*v12);
  }
  uint64_t v13 = *(void *)(v2 + 8);
  if (v13)
  {
    do
    {
      unsigned int v14 = *(_DWORD *)(v13 + 28);
      BOOL v15 = v3 >= v14;
      if (v3 >= v14) {
        uint64_t v16 = (uint64_t *)(v13 + 8);
      }
      else {
        uint64_t v16 = (uint64_t *)v13;
      }
      if (!v15) {
        int v4 = (uint64_t *)v13;
      }
      uint64_t v13 = *v16;
    }
    while (*v16);
  }
  uint64_t v6 = *((void *)a2 + 2);
  if (v9 == v4) {
    return v6 == *((void *)this + 1559);
  }
  while (v6 != *((void *)this + *((unsigned int *)v9 + 8) + 438))
  {
    uint64_t v17 = (uint64_t *)v9[1];
    if (v17)
    {
      do
      {
        uint64_t v18 = v17;
        uint64_t v17 = (uint64_t *)*v17;
      }
      while (v17);
    }
    else
    {
      do
      {
        uint64_t v18 = (uint64_t *)v9[2];
        BOOL v19 = *v18 == (void)v9;
        int v9 = v18;
      }
      while (!v19);
    }
    int v9 = v18;
    if (v18 == v4) {
      return v6 == *((void *)this + 1559);
    }
  }
  return 1;
}

void sub_1BB357DFC(_Unwind_Exception *a1)
{
}

uint64_t *std::multimap<unsigned int,unsigned int>::multimap[abi:ne180100](uint64_t *result, uint64_t a2)
{
  qword_1E9F7DF38 = 0;
  qword_1E9F7DF30 = 0;
  VoiceProcessorV2::AUIsInDownLinkProcessingChain(AUPBUnit const&)::downlinkProcessingDB = (uint64_t)&qword_1E9F7DF30;
  if (a2)
  {
    uint64_t v2 = result;
    unsigned int v3 = &result[a2];
    do
    {
      int v4 = (uint64_t *)operator new(0x28uLL);
      uint64_t v5 = *v2;
      *(uint64_t *)((char *)v4 + 28) = *v2;
      unint64_t v7 = &qword_1E9F7DF30;
      uint64_t v6 = qword_1E9F7DF30;
      if ((uint64_t *)VoiceProcessorV2::AUIsInDownLinkProcessingChain(AUPBUnit const&)::downlinkProcessingDB == &qword_1E9F7DF30) {
        goto LABEL_16;
      }
      uint64_t v8 = qword_1E9F7DF30;
      if (qword_1E9F7DF30)
      {
        do
        {
          unint64_t v7 = (uint64_t *)v8;
          uint64_t v8 = *(void *)(v8 + 8);
        }
        while (v8);
      }
      else
      {
        int v9 = &qword_1E9F7DF30;
        do
        {
          unint64_t v7 = (uint64_t *)v9[2];
          BOOL v10 = *v7 == (void)v9;
          int v9 = v7;
        }
        while (v10);
      }
      if (*((_DWORD *)v7 + 7) <= v5)
      {
LABEL_16:
        if (qword_1E9F7DF30) {
          BOOL v11 = v7;
        }
        else {
          BOOL v11 = &qword_1E9F7DF30;
        }
        if (qword_1E9F7DF30) {
          unint64_t v12 = (uint64_t **)(v7 + 1);
        }
        else {
          unint64_t v12 = (uint64_t **)&qword_1E9F7DF30;
        }
      }
      else if (qword_1E9F7DF30)
      {
        do
        {
          while (1)
          {
            BOOL v11 = (uint64_t *)v6;
            if (*(_DWORD *)(v6 + 28) <= v5) {
              break;
            }
            uint64_t v6 = *(void *)v6;
            unint64_t v12 = (uint64_t **)v11;
            if (!*v11) {
              goto LABEL_22;
            }
          }
          uint64_t v6 = *(void *)(v6 + 8);
        }
        while (v6);
        unint64_t v12 = (uint64_t **)(v11 + 1);
      }
      else
      {
        BOOL v11 = &qword_1E9F7DF30;
        unint64_t v12 = (uint64_t **)&qword_1E9F7DF30;
      }
LABEL_22:
      unint64_t result = std::__tree<std::__value_type<double,int>,std::__map_value_compare<double,std::__value_type<double,int>,std::less<double>,true>,std::allocator<std::__value_type<double,int>>>::__insert_node_at((uint64_t **)&VoiceProcessorV2::AUIsInDownLinkProcessingChain(AUPBUnit const&)::downlinkProcessingDB, (uint64_t)v11, v12, v4);
      ++v2;
    }
    while (v2 != v3);
  }
  return result;
}

void sub_1BB357F3C(_Unwind_Exception *a1)
{
}

uint64_t std::multimap<unsigned int,unsigned int>::~multimap[abi:ne180100](uint64_t a1)
{
  return a1;
}

void std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(a1[1]);
    operator delete(a1);
  }
}

void VoiceProcessorV2::PListCopyDictionaryForWrite(VoiceProcessorV2 *this, __CFDictionary **a2)
{
  key[32] = *(void **)MEMORY[0x1E4F143B8];
  *a2 = 0;
  CFArrayRef v3 = (const __CFArray *)*((void *)this + 1892);
  if (v3)
  {
    uint64_t v5 = (char *)this + 12908;
    int Count = CFArrayGetCount(v3);
    if (Count)
    {
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*((CFArrayRef *)this + 1892), (Count - 1));
      CFTypeRef v31 = 0;
      if (ValueAtIndex)
      {
        CFDictionaryRef v8 = ValueAtIndex;
        int valuePtr = 0;
        VPGetPropsPListStringForKey((applesauce::CF::StringRef *)key, 3);
        int v9 = key[0];
        CFTypeRef v31 = key[0];
        CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v8, key[0]);
        CFIndex v11 = CFArrayGetCount(Value);
        CFNumberRef v12 = (const __CFNumber *)CFArrayGetValueAtIndex(Value, v11 - 1);
        CFNumberGetValue(v12, kCFNumberIntType, &valuePtr);
        if (valuePtr == *((_DWORD *)this + 3128))
        {
          int v29 = 0;
          VPGetPropsPListStringForKey((applesauce::CF::StringRef *)key, 2);
          CFTypeRef v13 = key[0];
          CFTypeRef v31 = key[0];
          key[0] = v9;
          if (v9) {
            CFRelease(v9);
          }
          CFArrayRef v14 = (const __CFArray *)CFDictionaryGetValue(v8, v13);
          CFIndex v15 = CFArrayGetCount(v14);
          CFNumberRef v16 = (const __CFNumber *)CFArrayGetValueAtIndex(v14, v15 - 1);
          CFNumberGetValue(v16, kCFNumberIntType, &v29);
          if (v29 == *((_DWORD *)this + 3129))
          {
            int v28 = 0;
            VPGetPropsPListStringForKey((applesauce::CF::StringRef *)key, 17);
            int v9 = key[0];
            CFTypeRef v31 = key[0];
            key[0] = (void *)v13;
            if (v13) {
              CFRelease(v13);
            }
            CFArrayRef v17 = (const __CFArray *)CFDictionaryGetValue(v8, v9);
            CFIndex v18 = CFArrayGetCount(v17);
            CFNumberRef v19 = (const __CFNumber *)CFArrayGetValueAtIndex(v17, v18 - 1);
            CFNumberGetValue(v19, kCFNumberIntType, &v28);
            if (v28 != *((_DWORD *)this + 3130)) {
              goto LABEL_17;
            }
            snprintf((char *)key, 0x100uLL, "%s%d%02d%02d.%02d%02d%02d.%03u", "vp.", *((_DWORD *)this + 3226), *v5, *((char *)this + 12909), *((char *)this + 12910), *((char *)this + 12911), (int)*((double *)this + 1614), *((_DWORD *)this + 3230));
            VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&cf, 1);
            CFTypeRef v13 = cf;
            CFTypeRef v31 = cf;
            CFTypeRef cf = v9;
            if (v9) {
              CFRelease(v9);
            }
            CFArrayRef v20 = (const __CFArray *)CFDictionaryGetValue(v8, v13);
            CFIndex v21 = CFArrayGetCount(v20);
            CFStringRef v22 = (const __CFString *)CFArrayGetValueAtIndex(v20, v21 - 1);
            CFStringEncoding SystemEncoding = CFStringGetSystemEncoding();
            CStringPtr = CFStringGetCStringPtr(v22, SystemEncoding);
            size_t v25 = strlen(CStringPtr);
            if (!strncmp(CStringPtr, (const char *)key, v25))
            {
              *a2 = v8;
              CFRetain(v8);
LABEL_26:
              if (v13) {
                CFRelease(v13);
              }
              return;
            }
          }
          int v9 = (void *)v13;
        }
      }
      else
      {
        int v9 = 0;
      }
    }
    else
    {
      int v9 = 0;
      CFTypeRef v31 = 0;
    }
LABEL_17:
    *a2 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    VPGetPropsPListStringForKey((applesauce::CF::StringRef *)key, 3);
    WriteItemToDictionary(a2, (const void **)key, 1, 4uLL, (const char *)this + 12512);
    if (key[0]) {
      CFRelease(key[0]);
    }
    VPGetPropsPListStringForKey((applesauce::CF::StringRef *)key, 2);
    WriteItemToDictionary(a2, (const void **)key, 1, 4uLL, (const char *)this + 12516);
    if (key[0]) {
      CFRelease(key[0]);
    }
    VPGetPropsPListStringForKey((applesauce::CF::StringRef *)key, 17);
    WriteItemToDictionary(a2, (const void **)key, 1, 4uLL, (const char *)this + 12520);
    if (key[0]) {
      CFRelease(key[0]);
    }
    snprintf((char *)key, 0x100uLL, "%s%d%02d%02d.%02d%02d%02d.%03u", "vp.", *((_DWORD *)this + 3226), *v5, *((char *)this + 12909), *((char *)this + 12910), *((char *)this + 12911), (int)*((double *)this + 1614), *((_DWORD *)this + 3230));
    VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&cf, 1);
    size_t v26 = strlen((const char *)key);
    WriteItemToDictionary(a2, &cf, 0, v26 + 1, (const char *)key);
    if (cf) {
      CFRelease(cf);
    }
    CFArrayAppendValue(*((CFMutableArrayRef *)this + 1892), *a2);
    CFTypeRef v13 = v9;
    goto LABEL_26;
  }
}

void sub_1BB3583CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,char a21,int a22,__int16 a23,char a24,char a25)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void VoiceProcessorV2::PListWriteInitializeHwInputParameters(VoiceProcessorV2 *this)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (*((void *)this + 1892))
  {
    size_t v25 = 0;
    VoiceProcessorV2::PListCopyDictionaryForWrite(this, &v25);
    uint64_t v2 = v25;
    if (v25)
    {
      CFArrayRef v3 = (char *)this + 32;
      if (*((char *)this + 55) < 0) {
        CFArrayRef v3 = *(const char **)v3;
      }
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 0);
      size_t v4 = strlen(v3);
      WriteItemToDictionary(&v25, cf, 0, v4 + 1, v3);
      if (cf[0]) {
        CFRelease(cf[0]);
      }
      int v5 = *((unsigned __int8 *)this + 60);
      if (*((unsigned char *)this + 60)) {
        int v5 = *((_DWORD *)this + 14);
      }
      int valuePtr = v5;
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 64);
      WriteItemToDictionary(&v25, cf, 1, 4uLL, (const char *)&valuePtr);
      if (cf[0]) {
        CFRelease(cf[0]);
      }
      int v23 = *((_DWORD *)this + 16);
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 77);
      WriteItemToDictionary(&v25, cf, 1, 4uLL, (const char *)&v23);
      if (cf[0]) {
        CFRelease(cf[0]);
      }
      if (*((void *)this + 292) != *((void *)this + 293))
      {
        VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 6);
        WriteItemToDictionary(&v25, cf, 1, 4uLL, *((const char **)this + 292));
        if (cf[0]) {
          CFRelease(cf[0]);
        }
        if (*((void *)this + 293) - *((void *)this + 292) >= 5uLL)
        {
          unint64_t v6 = 1;
          uint64_t v7 = 4;
          do
          {
            VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&v21, 6);
            if (!v21)
            {
              exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
              std::runtime_error::runtime_error(exception, "Could not construct");
            }
            applesauce::CF::convert_to<std::string,0>((const __CFString *)v21, (uint64_t)cf);
            if ((SBYTE7(v19) & 0x80u) == 0) {
              CFDictionaryRef v8 = cf;
            }
            else {
              CFDictionaryRef v8 = (CFTypeRef *)cf[0];
            }
            applesauce::CF::make_StringRef(@"%s%lu", (applesauce::CF::StringRef *)&v22, v8, v6);
            if (SBYTE7(v19) < 0) {
              operator delete((void *)cf[0]);
            }
            if (v21) {
              CFRelease(v21);
            }
            WriteItemToDictionary(&v25, &v22, 1, 4uLL, (const char *)(*((void *)this + 292) + v7));
            if (v22) {
              CFRelease(v22);
            }
            ++v6;
            v7 += 4;
          }
          while (v6 < (uint64_t)(*((void *)this + 293) - *((void *)this + 292)) >> 2);
        }
      }
      if (*((void *)this + 295) != *((void *)this + 296))
      {
        VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 9);
        WriteItemToDictionary(&v25, cf, 1, 4uLL, *((const char **)this + 295));
        if (cf[0]) {
          CFRelease(cf[0]);
        }
        if (*((void *)this + 296) - *((void *)this + 295) >= 5uLL)
        {
          unint64_t v9 = 1;
          uint64_t v10 = 4;
          do
          {
            VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&v21, 9);
            if (!v21)
            {
              CFArrayRef v17 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
              std::runtime_error::runtime_error(v17, "Could not construct");
            }
            applesauce::CF::convert_to<std::string,0>((const __CFString *)v21, (uint64_t)cf);
            if ((SBYTE7(v19) & 0x80u) == 0) {
              CFIndex v11 = cf;
            }
            else {
              CFIndex v11 = (CFTypeRef *)cf[0];
            }
            applesauce::CF::make_StringRef(@"%s%lu", (applesauce::CF::StringRef *)&v22, v11, v9);
            if (SBYTE7(v19) < 0) {
              operator delete((void *)cf[0]);
            }
            if (v21) {
              CFRelease(v21);
            }
            WriteItemToDictionary(&v25, &v22, 1, 4uLL, (const char *)(*((void *)this + 295) + v10));
            if (v22) {
              CFRelease(v22);
            }
            ++v9;
            v10 += 4;
          }
          while (v9 < (uint64_t)(*((void *)this + 296) - *((void *)this + 295)) >> 2);
        }
      }
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 35);
      WriteItemToDictionary(&v25, cf, 1, 4uLL, (const char *)this + 2384);
      if (cf[0]) {
        CFRelease(cf[0]);
      }
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 41);
      WriteItemToDictionary(&v25, cf, 1, 4uLL, (const char *)this + 2388);
      if (cf[0]) {
        CFRelease(cf[0]);
      }
      long long v12 = *(_OWORD *)((char *)this + 600);
      *(_OWORD *)CFTypeRef cf = *(_OWORD *)((char *)this + 584);
      long long v19 = v12;
      uint64_t v20 = *((void *)this + 77);
      ASBDToText((const CAStreamBasicDescription *)cf, __s);
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 4);
      size_t v13 = strlen(__s);
      WriteItemToDictionary(&v25, cf, 0, v13 + 1, __s);
      if (cf[0]) {
        CFRelease(cf[0]);
      }
      long long v14 = *((_OWORD *)this + 40);
      *(_OWORD *)CFTypeRef cf = *((_OWORD *)this + 39);
      long long v19 = v14;
      uint64_t v20 = *((void *)this + 82);
      ASBDToText((const CAStreamBasicDescription *)cf, __s);
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 7);
      size_t v15 = strlen(__s);
      WriteItemToDictionary(&v25, cf, 0, v15 + 1, __s);
      if (cf[0]) {
        CFRelease(cf[0]);
      }
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 5);
      WriteItemToDictionary(&v25, cf, 1, 4uLL, (const char *)this + 492);
      if (cf[0]) {
        CFRelease(cf[0]);
      }
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 8);
      WriteItemToDictionary(&v25, cf, 1, 4uLL, (const char *)this + 496);
      if (cf[0]) {
        CFRelease(cf[0]);
      }
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 42);
      WriteItemToDictionary(&v25, cf, 1, 4uLL, (const char *)this + 1148);
      if (cf[0]) {
        CFRelease(cf[0]);
      }
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 43);
      WriteItemToDictionary(&v25, cf, 1, 4uLL, (const char *)this + 1152);
      if (cf[0]) {
        CFRelease(cf[0]);
      }
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 10);
      WriteItemToDictionary(&v25, cf, 1, 4uLL, (const char *)this + 1168);
      if (cf[0]) {
        CFRelease(cf[0]);
      }
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 11);
      WriteItemToDictionary(&v25, cf, 1, 4uLL, (const char *)this + 1164);
      if (cf[0]) {
        CFRelease(cf[0]);
      }
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 12);
      WriteItemToDictionary(&v25, cf, 1, 4uLL, (const char *)this + 1176);
      if (cf[0]) {
        CFRelease(cf[0]);
      }
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 13);
      WriteItemToDictionary(&v25, cf, 1, 4uLL, (const char *)this + 1172);
      if (cf[0]) {
        CFRelease(cf[0]);
      }
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 39);
      WriteItemToDictionary(&v25, cf, 2, 4uLL, (const char *)this + 1156);
      if (cf[0]) {
        CFRelease(cf[0]);
      }
      CFRelease(v2);
    }
  }
}

void sub_1BB358B04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, char a19, int a20,__int16 a21,char a22,char a23)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void VoiceProcessorV2::PListWriteInitializeOutputParameters(VoiceProcessorV2 *this)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (*((void *)this + 1892))
  {
    CFDictionaryRef v8 = 0;
    VoiceProcessorV2::PListCopyDictionaryForWrite(this, &v8);
    uint64_t v2 = v8;
    if (v8)
    {
      long long v3 = *(_OWORD *)((char *)this + 1000);
      *(_OWORD *)CFTypeRef cf = *(_OWORD *)((char *)this + 984);
      long long v6 = v3;
      uint64_t v7 = *((void *)this + 127);
      ASBDToText((const CAStreamBasicDescription *)cf, __s);
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 14);
      size_t v4 = strlen(__s);
      WriteItemToDictionary(&v8, cf, 0, v4 + 1, __s);
      if (cf[0]) {
        CFRelease(cf[0]);
      }
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 42);
      WriteItemToDictionary(&v8, cf, 1, 4uLL, (const char *)this + 1148);
      if (cf[0]) {
        CFRelease(cf[0]);
      }
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 43);
      WriteItemToDictionary(&v8, cf, 1, 4uLL, (const char *)this + 1152);
      if (cf[0]) {
        CFRelease(cf[0]);
      }
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 10);
      WriteItemToDictionary(&v8, cf, 1, 4uLL, (const char *)this + 1168);
      if (cf[0]) {
        CFRelease(cf[0]);
      }
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 11);
      WriteItemToDictionary(&v8, cf, 1, 4uLL, (const char *)this + 1164);
      if (cf[0]) {
        CFRelease(cf[0]);
      }
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 12);
      WriteItemToDictionary(&v8, cf, 1, 4uLL, (const char *)this + 1176);
      if (cf[0]) {
        CFRelease(cf[0]);
      }
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 13);
      WriteItemToDictionary(&v8, cf, 1, 4uLL, (const char *)this + 1172);
      if (cf[0]) {
        CFRelease(cf[0]);
      }
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 39);
      WriteItemToDictionary(&v8, cf, 2, 4uLL, (const char *)this + 1156);
      if (cf[0]) {
        CFRelease(cf[0]);
      }
      CFRelease(v2);
    }
  }
}

void sub_1BB358E48(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void VoiceProcessorV2::PListWriteInitializeDLPParameters(VoiceProcessorV2 *this)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (*((void *)this + 1892))
  {
    uint64_t v10 = 0;
    VoiceProcessorV2::PListCopyDictionaryForWrite(this, &v10);
    uint64_t v2 = v10;
    if (v10)
    {
      ASBDToText((VoiceProcessorV2 *)((char *)this + 328), __s);
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 18);
      size_t v3 = strlen(__s);
      WriteItemToDictionary(&v10, cf, 0, v3 + 1, __s);
      if (cf[0]) {
        CFRelease(cf[0]);
      }
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 19);
      WriteItemToDictionary(&v10, cf, 1, 4uLL, (const char *)this + 484);
      if (cf[0]) {
        CFRelease(cf[0]);
      }
      ASBDToText((VoiceProcessorV2 *)((char *)this + 208), __s);
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 20);
      size_t v4 = strlen(__s);
      WriteItemToDictionary(&v10, cf, 0, v4 + 1, __s);
      if (cf[0]) {
        CFRelease(cf[0]);
      }
      if (*((_DWORD *)this + 1129) == 1)
      {
        uint64_t v9 = *((void *)this + 77);
        long long v5 = *(_OWORD *)((char *)this + 600);
        *(_OWORD *)CFTypeRef cf = *(_OWORD *)((char *)this + 584);
        long long v8 = v5;
        ASBDToText((const CAStreamBasicDescription *)cf, __s);
        VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 4);
        size_t v6 = strlen(__s);
        WriteItemToDictionary(&v10, cf, 0, v6 + 1, __s);
        if (cf[0]) {
          CFRelease(cf[0]);
        }
        VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 5);
        WriteItemToDictionary(&v10, cf, 1, 4uLL, (const char *)this + 492);
        if (cf[0]) {
          CFRelease(cf[0]);
        }
      }
      CFRelease(v2);
    }
  }
}

void sub_1BB359078(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void VoiceProcessorV2::PListWriteInitializeSpkrTelParameters(VoiceProcessorV2 *this)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (*((void *)this + 1892))
  {
    long long v5 = 0;
    VoiceProcessorV2::PListCopyDictionaryForWrite(this, &v5);
    uint64_t v2 = v5;
    if (v5)
    {
      ASBDToText((VoiceProcessorV2 *)((char *)this + 1488), __s);
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&cf, 32);
      size_t v3 = strlen(__s);
      WriteItemToDictionary(&v5, &cf, 0, v3 + 1, __s);
      if (cf) {
        CFRelease(cf);
      }
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&cf, 33);
      WriteItemToDictionary(&v5, &cf, 1, 4uLL, (const char *)this + 1528);
      if (cf) {
        CFRelease(cf);
      }
      CFRelease(v2);
    }
  }
}

void sub_1BB3591B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void VoiceProcessorV2::PListWriteSetPropertyParameters(VoiceProcessorV2 *this, int a2)
{
  v24[2] = *MEMORY[0x1E4F143B8];
  if (*((void *)this + 1892))
  {
    CFTypeRef cf = 0;
    VoiceProcessorV2::PListCopyDictionaryForWrite(this, (__CFDictionary **)&cf);
    CFTypeRef v4 = cf;
    if (cf)
    {
      if (a2 > 1635085676)
      {
        if (a2 > 1868653666)
        {
          if (a2 <= 1937141090)
          {
            switch(a2)
            {
              case 1868653667:
                applesauce::CF::NumberRef::NumberRef<unsigned int,void>((CFNumberRef *)&v18, *((_DWORD *)this + 4157));
                applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[13],applesauce::CF::NumberRef>((applesauce::CF::TypeRef *)valuePtr, &v18);
                if (*((unsigned char *)this + 16624)) {
                  CFIndex v11 = (const void **)MEMORY[0x1E4F1CFD0];
                }
                else {
                  CFIndex v11 = (const void **)MEMORY[0x1E4F1CFC8];
                }
                CFArrayRef v17 = *v11;
                applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[22],applesauce::CF::BooleanRef>((applesauce::CF::TypeRef *)v24, &v17);
                long long v19 = valuePtr;
                uint64_t v20 = 2;
                CFDictionaryRef CFDictionaryRef = applesauce::CF::details::make_CFDictionaryRef((uint64_t)&v19);
                uint64_t v13 = 0;
                CFDictionaryRef v21 = CFDictionaryRef;
                do
                {
                  long long v14 = (const void *)v24[v13 + 1];
                  if (v14) {
                    CFRelease(v14);
                  }
                  size_t v15 = valuePtr[v13 + 2];
                  if (v15) {
                    CFRelease(v15);
                  }
                  v13 -= 2;
                }
                while (v13 != -4);
                applesauce::CF::BooleanRef::~BooleanRef(&v17);
                applesauce::CF::NumberRef::~NumberRef(&v18);
                valuePtr[0] = CFDictionaryRef;
                VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&v19, 75);
                WriteItemToDictionary((__CFDictionary **)&cf, (const void **)&v19, 4, 8uLL, (const char *)valuePtr);
                break;
              case 1936744803:
                LODWORD(v19) = *((unsigned __int8 *)this + 2245);
                VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 68);
                WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 1, 4uLL, (const char *)&v19);
                goto LABEL_68;
              case 1936746595:
                applesauce::CF::NumberRef::NumberRef<unsigned int,void>((CFNumberRef *)&v18, *((_DWORD *)this + 4114));
                applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[12],applesauce::CF::NumberRef>((applesauce::CF::TypeRef *)valuePtr, "SpatialMode", &v18);
                if (*((unsigned char *)this + 16460)) {
                  size_t v6 = (const void **)MEMORY[0x1E4F1CFD0];
                }
                else {
                  size_t v6 = (const void **)MEMORY[0x1E4F1CFC8];
                }
                CFArrayRef v17 = *v6;
                applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[13],applesauce::CF::BooleanRef>((applesauce::CF::TypeRef *)v24, "HeadTracking", &v17);
                long long v19 = valuePtr;
                uint64_t v20 = 2;
                CFDictionaryRef v7 = applesauce::CF::details::make_CFDictionaryRef((uint64_t)&v19);
                uint64_t v8 = 0;
                CFDictionaryRef v21 = v7;
                do
                {
                  uint64_t v9 = (const void *)v24[v8 + 1];
                  if (v9) {
                    CFRelease(v9);
                  }
                  uint64_t v10 = valuePtr[v8 + 2];
                  if (v10) {
                    CFRelease(v10);
                  }
                  v8 -= 2;
                }
                while (v8 != -4);
                applesauce::CF::BooleanRef::~BooleanRef(&v17);
                applesauce::CF::NumberRef::~NumberRef(&v18);
                valuePtr[0] = v7;
                VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&v19, 73);
                WriteItemToDictionary((__CFDictionary **)&cf, (const void **)&v19, 4, 8uLL, (const char *)valuePtr);
                break;
              default:
                goto LABEL_70;
            }
            applesauce::CF::StringRef::~StringRef((const void **)&v19);
            applesauce::CF::DictionaryRef::~DictionaryRef((const void **)&v21);
            goto LABEL_70;
          }
          switch(a2)
          {
            case 1937141091:
              unsigned int v16 = atomic_load((unsigned int *)this + 562);
              LODWORD(v19) = v16;
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 71);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 2, 4uLL, (const char *)&v19);
              applesauce::CF::StringRef::~StringRef(valuePtr);
              CFTypeRef v4 = cf;
              break;
            case 1953915762:
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 40);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 2, 4uLL, (const char *)this + 2200);
              goto LABEL_68;
            case 1953915764:
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 26);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 1, 4uLL, (const char *)this + 2196);
              goto LABEL_68;
          }
        }
        else if (a2 > 1768514914)
        {
          switch(a2)
          {
            case 1768514915:
              LODWORD(v19) = *((unsigned __int8 *)this + 16632);
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 76);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 1, 4uLL, (const char *)&v19);
              goto LABEL_68;
            case 1835361379:
              LODWORD(v19) = *((unsigned __int8 *)this + 2244);
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 67);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 1, 4uLL, (const char *)&v19);
              goto LABEL_68;
            case 1836082532:
              LODWORD(v19) = *((unsigned __int8 *)this + 2246);
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 74);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 1, 4uLL, (const char *)&v19);
              goto LABEL_68;
          }
        }
        else
        {
          switch(a2)
          {
            case 1635085677:
              LODWORD(v19) = *((unsigned __int8 *)this + 2268);
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 80);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 1, 4uLL, (const char *)&v19);
              goto LABEL_68;
            case 1718384242:
              LODWORD(v19) = *((_DWORD *)this + 4150);
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 69);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 1, 4uLL, (const char *)&v19);
              goto LABEL_68;
            case 1751933808:
              valuePtr[0] = *((const void **)this + 279);
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&v19, 65);
              WriteItemToDictionary((__CFDictionary **)&cf, (const void **)&v19, 4, 8uLL, (const char *)valuePtr);
              long long v5 = (const void **)&v19;
LABEL_69:
              applesauce::CF::StringRef::~StringRef(v5);
              break;
          }
        }
      }
      else
      {
        if (a2 > 32782)
        {
          switch(a2)
          {
            case 32783:
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 27);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 4, 8uLL, (const char *)this + 2208);
              goto LABEL_68;
            case 32784:
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 28);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 4, 8uLL, (const char *)this + 2216);
              goto LABEL_68;
            case 32785:
            case 32787:
            case 32789:
            case 32790:
            case 32791:
            case 32793:
            case 32795:
            case 32796:
              goto LABEL_70;
            case 32786:
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 31);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 1, 4uLL, (const char *)this + 2736);
              goto LABEL_68;
            case 32788:
              LODWORD(v19) = *((unsigned __int8 *)this + 2085);
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 34);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 1, 4uLL, (const char *)&v19);
              goto LABEL_68;
            case 32792:
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 44);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 1, 4uLL, (const char *)this + 1144);
              goto LABEL_68;
            case 32794:
              LODWORD(v19) = *((unsigned __int8 *)this + 2082);
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 61);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 1, 4uLL, (const char *)&v19);
              goto LABEL_68;
            case 32797:
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 66);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 2, 4uLL, (const char *)this + 2240);
              goto LABEL_68;
            case 32798:
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 62);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 4, 8uLL, (const char *)this + 2224);
              goto LABEL_68;
            default:
              if (a2 != 1634758259) {
                goto LABEL_70;
              }
              LODWORD(v19) = *((unsigned __int8 *)this + 16688);
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 79);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 1, 4uLL, (const char *)&v19);
              break;
          }
          goto LABEL_68;
        }
        switch(a2)
        {
          case 32769:
            VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 16);
            WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 1, 4uLL, (const char *)this + 2284);
            goto LABEL_68;
          case 32772:
            LODWORD(v19) = *((unsigned __int8 *)this + 2080);
            VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 60);
            WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 1, 4uLL, (const char *)&v19);
            goto LABEL_68;
          case 32773:
            LODWORD(v19) = *((unsigned __int8 *)this + 2083);
            VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 29);
            WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 1, 4uLL, (const char *)&v19);
LABEL_68:
            long long v5 = valuePtr;
            goto LABEL_69;
        }
      }
LABEL_70:
      CFRelease(v4);
    }
  }
}

void sub_1BB3599A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  applesauce::CF::StringRef::~StringRef((const void **)va);
  _Unwind_Resume(a1);
}

CFNumberRef *applesauce::CF::NumberRef::NumberRef<unsigned int,void>(CFNumberRef *a1, int a2)
{
  int valuePtr = a2;
  CFNumberRef v3 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  *a1 = v3;
  if (!v3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1BB359BB8(_Unwind_Exception *exception_object)
{
  if (*v1) {
    CFRelease(*v1);
  }
  _Unwind_Resume(exception_object);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[13],applesauce::CF::NumberRef>(applesauce::CF::TypeRef *a1, const void **a2)
{
  applesauce::CF::TypeRef::TypeRef(a1, "DuckingLevel");
  CFTypeRef v4 = *a2;
  if (v4) {
    CFRetain(v4);
  }
  *((void *)a1 + 1) = v4;
  return a1;
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[22],applesauce::CF::BooleanRef>(applesauce::CF::TypeRef *a1, const void **a2)
{
  applesauce::CF::TypeRef::TypeRef(a1, "EnableAdvancedDucking");
  CFTypeRef v4 = *a2;
  if (v4) {
    CFRetain(v4);
  }
  *((void *)a1 + 1) = v4;
  return a1;
}

void VoiceProcessorV2::PListWriteSetModeParameters(VoiceProcessorV2 *this)
{
  if (*((void *)this + 1892))
  {
    CFTypeRef v4 = 0;
    VoiceProcessorV2::PListCopyDictionaryForWrite(this, &v4);
    uint64_t v2 = v4;
    if (v4)
    {
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&cf, 22);
      WriteItemToDictionary(&v4, &cf, 1, 4uLL, (const char *)this + 76);
      if (cf) {
        CFRelease(cf);
      }
      CFRelease(v2);
    }
  }
}

void sub_1BB359CFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

void VoiceProcessorV2::PListWriteSetDeviceOrientationParameters(VoiceProcessorV2 *this, int a2)
{
  int valuePtr = a2;
  if (*((void *)this + 1892))
  {
    CFTypeRef v4 = 0;
    VoiceProcessorV2::PListCopyDictionaryForWrite(this, &v4);
    uint64_t v2 = v4;
    if (v4)
    {
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&cf, 38);
      WriteItemToDictionary(&v4, &cf, 1, 4uLL, (const char *)&valuePtr);
      if (cf) {
        CFRelease(cf);
      }
      CFRelease(v2);
    }
  }
}

void sub_1BB359D90(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::StringRef::~StringRef((const void **)va);
  _Unwind_Resume(a1);
}

void VoiceProcessorV2::PListWriteSetUIOrientationParameters(VoiceProcessorV2 *this, int a2)
{
  int valuePtr = a2;
  if (*((void *)this + 1892))
  {
    CFTypeRef v4 = 0;
    VoiceProcessorV2::PListCopyDictionaryForWrite(this, &v4);
    uint64_t v2 = v4;
    if (v4)
    {
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&cf, 54);
      WriteItemToDictionary(&v4, &cf, 1, 4uLL, (const char *)&valuePtr);
      if (cf) {
        CFRelease(cf);
      }
      CFRelease(v2);
    }
  }
}

void sub_1BB359E24(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::StringRef::~StringRef((const void **)va);
  _Unwind_Resume(a1);
}

void VoiceProcessorV2::PListWriteMicTrimGainParameters(VoiceProcessorV2 *a1, float **a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (*((void *)a1 + 1892))
  {
    if (*a2 != a2[1])
    {
      CFDictionaryRef v7 = 0;
      VoiceProcessorV2::PListCopyDictionaryForWrite(a1, &v7);
      CFNumberRef v3 = v7;
      if (v7)
      {
        snprintf(__str, 0x200uLL, "%f", **a2);
        CFTypeRef v4 = *a2;
        if ((unint64_t)((char *)a2[1] - (char *)*a2) >= 5)
        {
          unint64_t v5 = 1;
          do
          {
            snprintf(__source, 0x200uLL, ", %f", v4[v5]);
            strlcat(__str, __source, 0x200uLL);
            ++v5;
            CFTypeRef v4 = *a2;
          }
          while (v5 < a2[1] - *a2);
        }
        VPGetPropsPListStringForKey((applesauce::CF::StringRef *)__source, 24);
        size_t v6 = strlen(__str);
        WriteItemToDictionary(&v7, (const void **)__source, 0, v6 + 1, __str);
        if (*(void *)__source) {
          CFRelease(*(CFTypeRef *)__source);
        }
        CFRelease(v3);
      }
    }
  }
}

void sub_1BB359F84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void VoiceProcessorV2::PListWriteRefTrimGainParameters(VoiceProcessorV2 *a1, float **a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (*((void *)a1 + 1892))
  {
    if (*a2 != a2[1])
    {
      CFDictionaryRef v7 = 0;
      VoiceProcessorV2::PListCopyDictionaryForWrite(a1, &v7);
      CFNumberRef v3 = v7;
      if (v7)
      {
        snprintf(__str, 0x200uLL, "%f", **a2);
        CFTypeRef v4 = *a2;
        if ((unint64_t)((char *)a2[1] - (char *)*a2) >= 5)
        {
          unint64_t v5 = 1;
          do
          {
            snprintf(__source, 0x200uLL, ", %f", v4[v5]);
            strlcat(__str, __source, 0x200uLL);
            ++v5;
            CFTypeRef v4 = *a2;
          }
          while (v5 < a2[1] - *a2);
        }
        VPGetPropsPListStringForKey((applesauce::CF::StringRef *)__source, 25);
        size_t v6 = strlen(__str);
        WriteItemToDictionary(&v7, (const void **)__source, 0, v6 + 1, __str);
        if (*(void *)__source) {
          CFRelease(*(CFTypeRef *)__source);
        }
        CFRelease(v3);
      }
    }
  }
}

void sub_1BB35A0FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void VoiceProcessorV2::PListWriteSpeakerCalibrationParameters(VoiceProcessorV2 *this, const __CFArray *a2)
{
  CFArrayRef valuePtr = a2;
  if (a2)
  {
    CFTypeRef v4 = 0;
    VoiceProcessorV2::PListCopyDictionaryForWrite(this, &v4);
    uint64_t v2 = v4;
    if (v4)
    {
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&cf, 63);
      WriteItemToDictionary(&v4, &cf, 4, 8uLL, (const char *)&valuePtr);
      if (cf) {
        CFRelease(cf);
      }
      CFRelease(v2);
    }
  }
}

void sub_1BB35A1A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::StringRef::~StringRef((const void **)va);
  _Unwind_Resume(a1);
}

void VoiceProcessorV2::PListWriteSpkInputDataSrcParameters(VoiceProcessorV2 *this, unsigned int *a2, unsigned int a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    if (*((void *)this + 1892))
    {
      uint64_t v9 = 0;
      VoiceProcessorV2::PListCopyDictionaryForWrite(this, &v9);
      unint64_t v5 = v9;
      if (v9)
      {
        snprintf(__str, 0x200uLL, "%d", *a2);
        if (a3 >= 2)
        {
          uint64_t v6 = a3 - 1;
          CFDictionaryRef v7 = a2 + 1;
          do
          {
            snprintf(__source, 0x200uLL, ", %d", *v7);
            strlcat(__str, __source, 0x200uLL);
            ++v7;
            --v6;
          }
          while (v6);
        }
        VPGetPropsPListStringForKey((applesauce::CF::StringRef *)__source, 57);
        size_t v8 = strlen(__str);
        WriteItemToDictionary(&v9, (const void **)__source, 0, v8 + 1, __str);
        if (*(void *)__source) {
          CFRelease(*(CFTypeRef *)__source);
        }
        CFRelease(v5);
      }
    }
  }
}

void sub_1BB35A2EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void VoiceProcessorV2::PListWriteRefPhysicalDevSR(VoiceProcessorV2 *this, double *a2)
{
  if (*((void *)this + 1892))
  {
    unint64_t v5 = 0;
    VoiceProcessorV2::PListCopyDictionaryForWrite(this, &v5);
    CFNumberRef v3 = v5;
    if (v5)
    {
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&cf, 59);
      WriteItemToDictionary(&v5, &cf, 3, 8uLL, (const char *)a2);
      if (cf) {
        CFRelease(cf);
      }
      CFRelease(v3);
    }
  }
}

void sub_1BB35A398(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

const void **applesauce::CF::ObjectRef<__CFReadStream *>::~ObjectRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void std::vector<long long>::reserve(void **a1, unint64_t a2)
{
  CFTypeRef v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 3)
  {
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    uint64_t v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<unsigned int,float>>>(v3, a2);
    CFDictionaryRef v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    uint64_t v9 = &v6[8 * v8];
    uint64_t v10 = (char *)*a1;
    CFIndex v11 = (char *)a1[1];
    uint64_t v12 = v7;
    if (v11 != *a1)
    {
      uint64_t v12 = v7;
      do
      {
        uint64_t v13 = *((void *)v11 - 1);
        v11 -= 8;
        *((void *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

uint64_t SubbandDOA::Set(SubbandDOA *this, unsigned int a2, float a3, float a4)
{
  unsigned int v4 = *(_DWORD *)this + 1;
  if (v4 <= a2) {
    __assert_rtn("Set", "SubbandDOA.h", 49, "bandIdx < GetNumBands()");
  }
  if (a4 < -90.0 || a4 > 90.0) {
    __assert_rtn("Set", "SubbandDOA.h", 50, "elevation >= -90.0 && elevation <= 90.0");
  }
  uint64_t v7 = *((void *)this + 1);
  uint64_t v8 = *((void *)this + 2);
  uint64_t result = (uint64_t)this + 8;
  unint64_t v9 = (v8 - v7) >> 2;
  if (v9 <= a2 || (*(float *)(v7 + 4 * a2) = a3, unint64_t v10 = a2 + (unint64_t)v4, v9 <= v10)) {
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  }
  *(float *)(v7 + 4 * v10) = a4;
  return result;
}

uint64_t CmhBEAM::initialize(int32x2_t *this, int a2, __int32 a3, int a4)
{
  int32x2_t v8 = this[4];
  if (v8)
  {
    MEMORY[0x1C185D340](*(void *)&v8, 0x80C80B8603338);
    this[4] = 0;
  }
  int32x2_t v9 = this[5];
  if (v9)
  {
    MEMORY[0x1C185D340](*(void *)&v9, 0x80C80B8603338);
    this[5] = 0;
  }
  int32x2_t v10 = this[6];
  if (v10)
  {
    MEMORY[0x1C185D340](*(void *)&v10, 0x80C80B8603338);
    this[6] = 0;
  }
  int32x2_t v11 = this[10];
  if (v11)
  {
    MEMORY[0x1C185D340](*(void *)&v11, 0x1000C8052888210);
    this[10] = 0;
  }
  int32x2_t v12 = this[7];
  if (v12)
  {
    MEMORY[0x1C185D340](*(void *)&v12, 0x80C80B8603338);
    this[7] = 0;
  }
  int32x2_t v13 = this[8];
  if (v13)
  {
    MEMORY[0x1C185D340](*(void *)&v13, 0x80C80B8603338);
    this[8] = 0;
  }
  int32x2_t v14 = this[9];
  if (v14)
  {
    MEMORY[0x1C185D340](*(void *)&v14, 0x80C80B8603338);
    this[9] = 0;
  }
  if (this[15].i32[1])
  {
    if (this[7])
    {
      __int32 v15 = this->i32[0];
      if (this->i32[0] >= 1)
      {
        uint64_t v16 = 0;
        do
        {
          uint64_t v17 = *(void *)(*(void *)&this[7] + 8 * v16);
          if (v17)
          {
            MEMORY[0x1C185D340](v17, 0x1000C8052888210);
            __int32 v15 = this->i32[0];
          }
          ++v16;
        }
        while (v16 < v15);
      }
    }
    if (this[8])
    {
      int v18 = this[1].i32[0];
      if (v18 >= 1)
      {
        for (uint64_t i = 0; i < v18; ++i)
        {
          uint64_t v20 = *(void *)(*(void *)&this[8] + 8 * i);
          if (v20)
          {
            MEMORY[0x1C185D340](v20, 0x1000C8052888210);
            int v18 = this[1].i32[0];
          }
        }
      }
    }
    if (this[9])
    {
      int v21 = this->i32[1];
      if (v21 >= 1)
      {
        for (uint64_t j = 0; j < v21; ++j)
        {
          uint64_t v23 = *(void *)(*(void *)&this[9] + 8 * j);
          if (v23)
          {
            MEMORY[0x1C185D340](v23, 0x1000C8052888210);
            int v21 = this->i32[1];
          }
        }
      }
    }
  }
  int32x2_t v24 = this[7];
  if (v24)
  {
    MEMORY[0x1C185D340](*(void *)&v24, 0x80C80B8603338);
    this[7] = 0;
  }
  int32x2_t v25 = this[8];
  if (v25)
  {
    MEMORY[0x1C185D340](*(void *)&v25, 0x80C80B8603338);
    this[8] = 0;
  }
  if (this->i32[1] >= 1)
  {
    int32x2_t v26 = this[9];
    if (v26)
    {
      MEMORY[0x1C185D340](*(void *)&v26, 0x80C80B8603338);
      this[9] = 0;
    }
  }
  if ((a4 - 3) < 0xFFFFFFFE) {
    return 5;
  }
  if ((a3 - 46) < 0xFFFFFFDC) {
    return 6;
  }
  if (a2 > 23999)
  {
    if (a2 > 47999)
    {
      if (a2 != 48000)
      {
        if (a2 != 88200 && a2 != 96000) {
          goto LABEL_106;
        }
        unsigned int v30 = 1024;
        int v28 = 1;
        goto LABEL_64;
      }
LABEL_63:
      int v28 = 0;
      unsigned int v30 = 512;
LABEL_64:
      int v29 = 1;
      goto LABEL_66;
    }
    if (a2 != 24000 && a2 != 32000)
    {
      if (a2 != 44100) {
        goto LABEL_106;
      }
      goto LABEL_63;
    }
    goto LABEL_55;
  }
  if (a2 <= 11999)
  {
    if (a2 == 8000)
    {
      int v28 = 0;
      int v29 = 0;
      unsigned int v30 = 64;
      goto LABEL_66;
    }
    if (a2 != 11025)
    {
LABEL_106:
      this[13] = 0;
      return 1;
    }
LABEL_62:
    int v28 = 0;
    int v29 = 0;
    unsigned int v30 = 128;
    goto LABEL_66;
  }
  if (a2 == 12000 || a2 == 16000) {
    goto LABEL_62;
  }
  if (a2 != 22050) {
    goto LABEL_106;
  }
LABEL_55:
  int v28 = 0;
  int v29 = 0;
  unsigned int v30 = 256;
LABEL_66:
  this[13].i32[0] = a2;
  this[13].i32[1] = v30;
  unsigned int v31 = v30 >> 1;
  unsigned int v32 = 5 * v30;
  this[14].i32[1] = 0;
  this[16].i32[0] = 0;
  if (!v28 || !v29)
  {
    if (((v31 - 1) & 0x100) != 0)
    {
      if (0x100 % ((5 * v30) >> 3)) {
        return 2;
      }
      int v34 = 4;
      unsigned int v31 = v32 >> 3;
    }
    else
    {
      int v34 = 3;
    }
    this[14].i32[1] = v31;
    this[15].i32[1] = 0;
    this[16].i32[0] = v34;
    unsigned int v35 = 0x100 / v31;
    goto LABEL_79;
  }
  if ((v30 & 0x1C0) == 0)
  {
    int v33 = 3;
    goto LABEL_76;
  }
  if ((v32 & 0x7C0) != 0) {
    return 2;
  }
  int v33 = 4;
  unsigned int v31 = v32 >> 3;
LABEL_76:
  unsigned int v35 = 0;
  this[14].i32[1] = v31;
  this[15].i32[1] = v31 >> 8;
  this[16].i32[0] = v33;
LABEL_79:
  this[15].i32[0] = v35;
  this[18].i32[1] = a3;
  if (CmhBEAMprocOpt::initialize(this + 11, a4)) {
    return 4;
  }
  *this = (int32x2_t)2;
  this[1].i32[0] = a4;
  this[1].i32[1] = a2;
  this[2].i32[0] = 256;
  this[2].i32[1] = a3;
  this[3].i32[0] = 0;
  vDSP_Length v36 = operator new[](0x10uLL, MEMORY[0x1E4FBA2D0]);
  this[4] = (int32x2_t)v36;
  if (v36)
  {
    size_t v37 = a4 < 0 ? -1 : 8 * a4;
    OSType v38 = operator new[](v37, MEMORY[0x1E4FBA2D0]);
    this[5] = (int32x2_t)v38;
    if (v38)
    {
      uint64_t v39 = operator new[](0x800uLL, MEMORY[0x1E4FBA2D0]);
      this[10] = (int32x2_t)v39;
      if (v39)
      {
        uint64_t v40 = operator new[](0x10uLL, MEMORY[0x1E4FBA2D0]);
        this[7] = (int32x2_t)v40;
        if (v40)
        {
          *uint64_t v40 = 0;
          v40[1] = 0;
          uint64_t v41 = operator new[](v37, MEMORY[0x1E4FBA2D0]);
          this[8] = (int32x2_t)v41;
          if (v41)
          {
            bzero(v41, 8 * a4);
            if (!this[15].i32[1])
            {
LABEL_104:
              uint64_t result = 0;
              this[3].i32[1] = 0;
              return result;
            }
            uint64_t v42 = 0;
            uint64_t v43 = this[14].i32[1];
            if ((int)v43 < 0) {
              size_t v44 = -1;
            }
            else {
              size_t v44 = 4 * v43;
            }
            size_t v45 = 4 * (int)v43;
            vDSP_Length v46 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
            while (1)
            {
              *(void *)(*(void *)&this[7] + 8 * v42) = operator new[](v44, v46);
              uint64_t v47 = *(void **)(*(void *)&this[7] + 8 * v42);
              if (!v47) {
                break;
              }
              bzero(v47, v45);
              if (++v42 >= this->i32[0])
              {
                if (this[1].i32[0] < 1)
                {
LABEL_100:
                  if (this->i32[1] < 1) {
                    goto LABEL_104;
                  }
                  uint64_t v51 = 0;
                  uint64_t v52 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
                  while (1)
                  {
                    *(void *)(*(void *)&this[9] + 8 * v51) = operator new[](v44, v52);
                    uint64_t v53 = *(void **)(*(void *)&this[9] + 8 * v51);
                    if (!v53) {
                      break;
                    }
                    bzero(v53, v45);
                    if (++v51 >= this->i32[1]) {
                      goto LABEL_104;
                    }
                  }
                }
                else
                {
                  uint64_t v48 = 0;
                  uint64_t v49 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
                  while (1)
                  {
                    *(void *)(*(void *)&this[8] + 8 * v48) = operator new[](v44, v49);
                    int v50 = *(void **)(*(void *)&this[8] + 8 * v48);
                    if (!v50) {
                      break;
                    }
                    bzero(v50, v45);
                    if (++v48 >= this[1].i32[0]) {
                      goto LABEL_100;
                    }
                  }
                }
                return 4294967294;
              }
            }
          }
        }
      }
    }
  }
  return 4294967294;
}

uint64_t CmhBEAM::deinterleave(uint64_t this, float **a2, float **a3, int a4)
{
  if (a4 >= 1)
  {
    uint64_t v4 = *(int *)(this + 16);
    uint64_t v5 = *(unsigned int *)(this + 16);
    if (v4)
    {
      int v6 = v4 * a4;
      uint64_t v7 = (int *)*a2;
      int32x2_t v8 = *(_DWORD **)(this + 80);
      do
      {
        int v9 = *v7++;
        *v8++ = v9;
        --v6;
      }
      while (v6);
    }
    uint64_t v10 = 0;
    uint64_t v11 = 4 * v4;
    int32x2_t v12 = a3;
    uint64_t v13 = a4;
    do
    {
      *v12++ = (float *)((char *)*a2 + v10);
      v10 += v11;
      --v13;
    }
    while (v13);
    uint64_t v14 = 0;
    for (uint64_t i = 0; i != a4; ++i)
    {
      if ((int)v5 >= 1)
      {
        uint64_t v16 = a3[i];
        uint64_t v17 = (float *)(*(void *)(this + 80) + v14);
        uint64_t v18 = v5;
        do
        {
          *v16++ = *v17;
          v17 += a4;
          --v18;
        }
        while (v18);
      }
      v14 += 4;
    }
  }
  return this;
}

float CmhBEAM::interleave(CmhBEAM *this, float **a2, float **a3, int a4)
{
  if (a4 >= 1)
  {
    uint64_t v4 = 0;
    uint64_t v5 = 0;
    uint64_t v6 = *((unsigned int *)this + 4);
    do
    {
      if ((int)v6 >= 1)
      {
        uint64_t v7 = a2[v5];
        int32x2_t v8 = (float *)(*((void *)this + 10) + v4);
        uint64_t v9 = v6;
        do
        {
          float v10 = *v7++;
          float result = v10;
          *int32x2_t v8 = v10;
          v8 += a4;
          --v9;
        }
        while (v9);
      }
      ++v5;
      v4 += 4;
    }
    while (v5 != a4);
    if (v6)
    {
      int v12 = v6 * a4;
      uint64_t v13 = (float *)*((void *)this + 10);
      uint64_t v14 = *a3;
      do
      {
        float v15 = *v13++;
        float result = v15;
        *v14++ = v15;
        --v12;
      }
      while (v12);
    }
  }
  return result;
}

float CmhBEAM::setParameter(CmhBEAM *this, int a2, CmhBEAM2NOpt *a3, double a4, double a5)
{
  switch(a2)
  {
    case 2:
      float v5 = *(float *)a3;
      *((_DWORD *)this + 5) = *(_DWORD *)a3;
      *((_DWORD *)this + 37) = (int)(float)((float)((float)SLODWORD(v5) * 0.001) * 1000.0);
      int v6 = *((_DWORD *)this + 25);
      uint64_t v7 = (int32x2_t *)((char *)this + 88);
      CmhBEAMprocOpt::initialize(v7, v6);
      return *(float *)&a4;
    case 3:
      *(_DWORD *)(*((void *)this + 137) + 44) = *(_DWORD *)a3;
      return *(float *)&a4;
    case 4:
      float v8 = *(float *)a3;
      *((_DWORD *)this + 133) = *(_DWORD *)a3;
      goto LABEL_82;
    case 5:
      *((_DWORD *)this + 162) = *(_DWORD *)a3;
      return *(float *)&a4;
    case 6:
      if (*((_DWORD *)this + 287) + *((_DWORD *)this + 293) >= 1)
      {
        uint64_t v9 = 0;
        float v10 = *(float *)a3;
        uint64_t v11 = *((void *)this + 144);
        do
          *(float *)(v11 + 4 * v9++) = v10;
        while (v9 < *((int *)this + 287) + (uint64_t)*((int *)this + 293));
      }
      return *(float *)&a4;
    case 7:
      float v12 = *(float *)a3;
      uint64_t v13 = (char *)this + 1144;
      Cns::setMinGain((uint64_t)v13, v12);
      return *(float *)&a4;
    case 11:
      uint64_t v14 = (char *)this + 272;
      CmhBEAM2NOpt::setSpatialFilterReal((uint64_t)v14, (float *)a3);
      return *(float *)&a4;
    case 12:
      float v15 = (char *)this + 272;
      CmhBEAM2NOpt::setSpatialFilterImag((uint64_t)v15, (float *)a3);
      return *(float *)&a4;
    case 15:
      uint64_t v16 = (CmhBEAM *)((char *)this + 272);
      uint64_t v17 = a3;
      unsigned int v18 = 0;
      goto LABEL_25;
    case 16:
      long long v19 = (CmhBEAM *)((char *)this + 272);
      uint64_t v20 = a3;
      unsigned int v21 = 0;
      goto LABEL_29;
    case 17:
      uint64_t v16 = (CmhBEAM *)((char *)this + 272);
      uint64_t v17 = a3;
      unsigned int v18 = 1;
LABEL_25:
      CmhBEAM2NOpt::setModelSpatialFilterReal(v16, v17, v18);
      return *(float *)&a4;
    case 18:
      long long v19 = (CmhBEAM *)((char *)this + 272);
      uint64_t v20 = a3;
      unsigned int v21 = 1;
LABEL_29:
      CmhBEAM2NOpt::setModelSpatialFilterImag(v19, v20, v21);
      return *(float *)&a4;
    case 19:
      CFTypeRef v22 = (CmhBEAM *)((char *)this + 88);
      *(float *)&a4 = CmhBEAMprocOpt::setModelFreqCompVector(v22, a3);
      return *(float *)&a4;
    case 20:
      uint64_t v23 = (CmhBEAM *)((char *)this + 272);
      CmhBEAM2NOpt::setModelOmniEQVector(v23, a3);
      return *(float *)&a4;
    case 21:
      int32x2_t v24 = (CmhBEAM *)((char *)this + 272);
      int32x2_t v25 = a3;
      unsigned int v26 = 0;
      goto LABEL_41;
    case 22:
      uint64_t v27 = (CmhBEAM *)((char *)this + 272);
      int v28 = a3;
      unsigned int v29 = 0;
      goto LABEL_45;
    case 23:
      int32x2_t v24 = (CmhBEAM *)((char *)this + 272);
      int32x2_t v25 = a3;
      unsigned int v26 = 1;
LABEL_41:
      *(float *)&a4 = CmhBEAM2NOpt::setModelFreqCompVector(v24, v25, v26);
      return *(float *)&a4;
    case 24:
      uint64_t v27 = (CmhBEAM *)((char *)this + 272);
      int v28 = a3;
      unsigned int v29 = 1;
LABEL_45:
      CmhBEAM2NOpt::setModelOmniEQVector(v27, v28, v29);
      return *(float *)&a4;
    case 34:
      uint64_t v30 = *((unsigned int *)this + 70);
      if ((int)v30 >= 1)
      {
        LODWORD(a4) = *(_DWORD *)a3;
        unsigned int v31 = (_DWORD *)(*((void *)this + 85) + 64);
        do
        {
          *unsigned int v31 = LODWORD(a4);
          v31 += 34;
          --v30;
        }
        while (v30);
      }
      return *(float *)&a4;
    case 35:
      unsigned int v32 = (CmhBEAM *)((char *)this + 88);
      float v33 = *(float *)a3;
      CmhBEAMprocOpt::setWNG(v32, v33);
      return *(float *)&a4;
    case 36:
      int v34 = (CmhBEAM *)((char *)this + 88);
      CmhBEAMprocOpt::setModelFreqEQVector(v34, a3);
      return *(float *)&a4;
    case 37:
      unsigned int v35 = (CmhBEAM *)((char *)this + 272);
      vDSP_Length v36 = a3;
      unsigned int v37 = 0;
      goto LABEL_60;
    case 38:
      unsigned int v35 = (CmhBEAM *)((char *)this + 272);
      vDSP_Length v36 = a3;
      unsigned int v37 = 1;
LABEL_60:
      CmhBEAM2NOpt::setModelFreqEQVector(v35, v36, v37);
      return *(float *)&a4;
    case 39:
      float v38 = *(float *)a3;
      uint64_t v39 = *((void *)this + 85);
      *(_DWORD *)(v39 + 108) = *(_DWORD *)a3;
      if (*((int *)this + 70) >= 2) {
        *(float *)(v39 + 244) = v38;
      }
      return *(float *)&a4;
    case 42:
      LODWORD(a4) = *(_DWORD *)a3;
      uint64_t v40 = *((void *)this + 85);
      *(_DWORD *)(v40 + 112) = *(_DWORD *)a3;
      if (*((int *)this + 70) >= 2) {
        *(_DWORD *)(v40 + 248) = LODWORD(a4);
      }
      return *(float *)&a4;
    case 43:
      *((_DWORD *)this + 139) = *(_DWORD *)a3;
      return *(float *)&a4;
    case 44:
      LODWORD(a4) = *(_DWORD *)a3;
      *((_DWORD *)this + 140) = *(_DWORD *)a3;
      return *(float *)&a4;
    case 45:
      float v58 = *(float *)a3;
      if (*(_DWORD *)a3 <= 1u) {
        *((float *)this + 69) = v58;
      }
      *((float *)this + 23) = v58;
      return *(float *)&a4;
    case 46:
      uint64_t v41 = (char *)this + 272;
      CmhBEAM2NOpt::setABFVector((uint64_t)v41, (float *)a3);
      return *(float *)&a4;
    case 47:
      uint64_t v42 = (CmhBEAM *)((char *)this + 272);
      int v43 = 0;
      goto LABEL_74;
    case 48:
      uint64_t v42 = (CmhBEAM *)((char *)this + 272);
      int v43 = 1;
LABEL_74:
      *(float *)&a4 = CmhBEAM2NOpt::setABFVector(v42, v43, (float *)a3);
      return *(float *)&a4;
    case 51:
      *((_DWORD *)this + 52) = *(_DWORD *)a3;
      return *(float *)&a4;
    case 65:
      LODWORD(a4) = *(_DWORD *)a3;
      *((_DWORD *)this + 100) = (int)*(float *)a3;
      return *(float *)&a4;
    case 66:
      *((_DWORD *)this + 128) = *(_DWORD *)a3;
      return *(float *)&a4;
    case 67:
      LODWORD(a4) = *(_DWORD *)a3;
      size_t v44 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 193) = *(_DWORD *)a3;
      goto LABEL_133;
    case 68:
      *((_DWORD *)this + 133) = *(_DWORD *)a3;
      return *(float *)&a4;
    case 69:
      float v8 = *(float *)a3;
LABEL_82:
      *((float *)this + 134) = v8;
      return *(float *)&a4;
    case 70:
      float v45 = *(float *)a3;
      uint64_t v46 = *((void *)this + 144);
      int v47 = (*((_DWORD *)this + 293) + *((_DWORD *)this + 287) - 1) & ((*((_DWORD *)this + 293)
                                                                      + *((_DWORD *)this + 287)
                                                                      - 1) >> 31);
      goto LABEL_86;
    case 71:
      float v45 = *(float *)a3;
      uint64_t v46 = *((void *)this + 144);
      int v47 = *((_DWORD *)this + 293) + *((_DWORD *)this + 287) - 1;
      if (v47 >= 1) {
        int v47 = 1;
      }
LABEL_86:
      *(float *)(v46 + 4 * v47) = v45;
      return *(float *)&a4;
    case 72:
      float v48 = *(float *)a3;
      uint64_t v49 = (char *)this + 1144;
      int v50 = 0;
      goto LABEL_89;
    case 73:
      float v48 = *(float *)a3;
      uint64_t v49 = (char *)this + 1144;
      int v50 = 1;
LABEL_89:
      Cns::setMinGain((uint64_t)v49, v48, v50);
      return *(float *)&a4;
    case 74:
      float v51 = *(float *)a3;
      int v52 = *((_DWORD *)this + 70);
      if (v52 >= 1) {
        int v52 = 1;
      }
      goto LABEL_96;
    case 75:
      float v51 = *(float *)a3;
      int v52 = *((_DWORD *)this + 70);
      if (v52 >= 2) {
        int v52 = 2;
      }
LABEL_96:
      *(float *)(*((void *)this + 85) + 136 * v52 - 28) = v51;
      return *(float *)&a4;
    case 76:
      LODWORD(a4) = *(_DWORD *)a3;
      int v53 = *((_DWORD *)this + 70);
      if (v53 >= 1) {
        int v53 = 1;
      }
      goto LABEL_101;
    case 77:
      LODWORD(a4) = *(_DWORD *)a3;
      int v53 = *((_DWORD *)this + 70);
      if (v53 >= 2) {
        int v53 = 2;
      }
LABEL_101:
      *(_DWORD *)(*((void *)this + 85) + 136 * v53 - 24) = LODWORD(a4);
      return *(float *)&a4;
    case 78:
      *(float *)&a4 = (float)((float)*(int *)a3 / (float)*((int *)this + 71)) * (float)*((int *)this + 72);
      *((_DWORD *)this + 76) = *(_DWORD *)a3;
      int v54 = *((_DWORD *)this + 74) - 1;
      if (v54 >= (int)*(float *)&a4) {
        int v54 = (int)*(float *)&a4;
      }
      *((_DWORD *)this + 132) = v54;
      return *(float *)&a4;
    case 81:
      float v55 = *(float *)a3;
      *((_DWORD *)this + 102) = *(_DWORD *)a3;
      size_t v44 = (CmhBEAM *)((char *)this + 736);
      *((float *)this + 211) = v55;
      goto LABEL_133;
    case 82:
      float v62 = *(float *)a3;
      *(float *)&a4 = v62;
      *(float *)&a4 = CmhBEAM2NOpt::setParameter((CmhBEAM *)((char *)this + 272), 59, (CmhBEAM2NOpt *)&v62, a4, a5);
      return *(float *)&a4;
    case 83:
      LODWORD(a4) = *(_DWORD *)a3;
      size_t v44 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 194) = *(_DWORD *)a3;
      goto LABEL_133;
    case 84:
      LODWORD(a4) = *(_DWORD *)a3;
      size_t v44 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 195) = *(_DWORD *)a3;
      goto LABEL_133;
    case 85:
      LODWORD(a4) = *(_DWORD *)a3;
      size_t v44 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 196) = *(_DWORD *)a3;
      goto LABEL_133;
    case 86:
      LODWORD(a4) = *(_DWORD *)a3;
      size_t v44 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 197) = *(_DWORD *)a3;
      goto LABEL_133;
    case 87:
      LODWORD(a4) = *(_DWORD *)a3;
      size_t v44 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 198) = *(_DWORD *)a3;
      goto LABEL_133;
    case 88:
      LODWORD(a4) = *(_DWORD *)a3;
      size_t v44 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 199) = *(_DWORD *)a3;
      goto LABEL_133;
    case 89:
      LODWORD(a4) = *(_DWORD *)a3;
      size_t v44 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 200) = *(_DWORD *)a3;
      goto LABEL_133;
    case 90:
      LODWORD(a4) = *(_DWORD *)a3;
      size_t v44 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 201) = *(_DWORD *)a3;
      goto LABEL_133;
    case 91:
      LODWORD(a4) = *(_DWORD *)a3;
      size_t v44 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 202) = *(_DWORD *)a3;
      goto LABEL_133;
    case 92:
      LODWORD(a4) = *(_DWORD *)a3;
      size_t v44 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 203) = *(_DWORD *)a3;
      goto LABEL_133;
    case 93:
      LODWORD(a4) = *(_DWORD *)a3;
      size_t v44 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 204) = *(_DWORD *)a3;
      goto LABEL_133;
    case 94:
      LODWORD(a4) = *(_DWORD *)a3;
      size_t v44 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 205) = *(_DWORD *)a3;
      goto LABEL_133;
    case 95:
      LODWORD(a4) = *(_DWORD *)a3;
      size_t v44 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 206) = *(_DWORD *)a3;
      goto LABEL_133;
    case 96:
      LODWORD(a4) = *(_DWORD *)a3;
      size_t v44 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 207) = *(_DWORD *)a3;
      goto LABEL_133;
    case 97:
      LODWORD(a4) = *(_DWORD *)a3;
      size_t v44 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 208) = *(_DWORD *)a3;
      goto LABEL_133;
    case 98:
      LODWORD(a4) = *(_DWORD *)a3;
      size_t v44 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 209) = *(_DWORD *)a3;
      goto LABEL_133;
    case 99:
      LODWORD(a4) = *(_DWORD *)a3;
      size_t v44 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 210) = *(_DWORD *)a3;
LABEL_133:
      float v57 = v44;
      goto LABEL_134;
    case 100:
      uint64_t v56 = 0;
      do
      {
        LODWORD(a4) = *(_DWORD *)((char *)a3 + v56);
        *(_DWORD *)((char *)this + v56 + 772) = LODWORD(a4);
        v56 += 4;
      }
      while (v56 != 76);
      float v57 = (CmhBEAM *)((char *)this + 736);
LABEL_134:
      LODWORD(a4) = CmhMicCheck::init_check_mics(v57, a4, a5).u32[0];
      return *(float *)&a4;
    case 101:
      *((_DWORD *)this + 78) = *(_DWORD *)a3;
      goto LABEL_138;
    case 102:
LABEL_138:
      *((_DWORD *)this + 262) = *(_DWORD *)a3;
      break;
    case 103:
    case 106:
      LODWORD(a4) = *(_DWORD *)a3;
      *((_DWORD *)this + 163) = *(_DWORD *)a3;
      break;
    case 104:
      float v59 = *(float *)a3;
      *((_DWORD *)this + 103) = *(_DWORD *)a3;
      int v60 = (int)(float)((float)(v59 / (float)*((int *)this + 71)) * (float)*((int *)this + 72));
      if (*((_DWORD *)this + 74) - 1 < v60) {
        int v60 = *((_DWORD *)this + 74) - 1;
      }
      *(float *)&a4 = (float)v60;
      *((float *)this + 164) = (float)v60;
      break;
    case 105:
      LODWORD(a4) = *(_DWORD *)a3;
      *((_DWORD *)this + 165) = *(_DWORD *)a3;
      break;
    case 107:
      *((_DWORD *)this + 104) = *(_DWORD *)a3;
      break;
    default:
      return *(float *)&a4;
  }
  return *(float *)&a4;
}

uint64_t AUSubBandMultEchoCanceler::SetBypassEffect(uint64_t this, char a2)
{
  *(unsigned char *)(this + 528) = a2;
  return this;
}

uint64_t AUSubBandMultEchoCanceler::ShouldBypassEffect(AUSubBandMultEchoCanceler *this)
{
  return *((unsigned __int8 *)this + 528);
}

uint64_t AUSubBandMultEchoCanceler::ValidFormat(AUSubBandMultEchoCanceler *this, const AudioStreamBasicDescription *a2, int a3, AudioStreamBasicDescription *a4)
{
  uint64_t result = ausdk::ASBD::IsCommonFloat32((ausdk::ASBD *)a4, a2);
  if (result)
  {
    if ((a4->mFormatFlags & 0x20) != 0)
    {
      uint64_t result = 1;
      if (a3) {
        return result;
      }
      goto LABEL_5;
    }
    uint64_t result = a4->mChannelsPerFrame == 1;
  }
  if (a3) {
    return result;
  }
LABEL_5:
  if (a4->mChannelsPerFrame == 1) {
    return result;
  }
  else {
    return 0;
  }
}

uint64_t AUSubBandMultEchoCanceler::SupportedNumChannels(AUSubBandMultEchoCanceler *this, const AUChannelInfo **a2)
{
  if (a2) {
    *a2 = (const AUChannelInfo *)&AUSubBandMultEchoCanceler::SupportedNumChannels(AUChannelInfo const**)::sSupportedChannelConfigs;
  }
  return 1;
}

BOOL AUSubBandMultEchoCanceler::StreamFormatWritable(AUSubBandMultEchoCanceler *this)
{
  return *((unsigned char *)this + 17) == 0;
}

uint64_t AUSubBandMultEchoCanceler::SupportsTail(AUSubBandMultEchoCanceler *this)
{
  return 1;
}

double AUSubBandMultEchoCanceler::GetTailTime(AUSubBandMultEchoCanceler *this)
{
  return 0.0;
}

double AUSubBandMultEchoCanceler::GetLatency(AUSubBandMultEchoCanceler *this)
{
  return 0.0;
}

uint64_t AUSubBandMultEchoCanceler::RestoreState(OpaqueAudioComponentInstance **this, const void *a2)
{
  uint64_t result = ausdk::AUBase::RestoreState(this, a2);
  if (!result) {
    ++*((_DWORD *)this + 133);
  }
  return result;
}

uint64_t AUSubBandMultEchoCanceler::GetParameterInfo(AUSubBandMultEchoCanceler *this, int a2, unsigned int a3, AudioUnitParameterInfo *buffer)
{
  buffer->flags = 0x40000000;
  buffer->unitName = 0;
  uint64_t result = 4294956418;
  if (!a2 && a3 <= 0xC)
  {
    CFStringRef v6 = *(&off_1E623C2B8 + a3);
    AudioUnitParameterUnit v7 = dword_1BB87DAC0[a3];
    AudioUnitParameterValue v8 = flt_1BB87DAF4[a3];
    AudioUnitParameterValue v9 = flt_1BB87DB28[a3];
    AudioUnitParameterValue v10 = flt_1BB87DB5C[a3];
    int v11 = dword_1BB87DB90[a3];
    buffer->cfNameString = v6;
    buffer->flags = 1207959552;
    CFStringGetCString(v6, buffer->name, 52, 0x8000100u);
    uint64_t result = 0;
    buffer->unit = v7;
    buffer->minCFArrayRef Value = v8;
    buffer->maxCFArrayRef Value = v9;
    buffer->defaultCFArrayRef Value = v10;
    buffer->flags |= v11;
  }
  return result;
}

BOOL AUSubBandMultEchoCanceler::BusCountWritable(AUSubBandMultEchoCanceler *this, int a2)
{
  return (a2 - 1) < 2;
}

uint64_t AUSubBandMultEchoCanceler::Render(AUSubBandMultEchoCanceler *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  if (*((_DWORD *)this + 84) != a4) {
    return 4294956422;
  }
  AudioUnitParameterValue v8 = (AUSubBandMultEchoCanceler *)((char *)this + 80);
  uint64_t Element = ausdk::AUScope::SafeGetElement((AUSubBandMultEchoCanceler *)((char *)this + 80), 0);
  uint64_t v10 = ausdk::AUScope::SafeGetElement((AUSubBandMultEchoCanceler *)((char *)this + 128), 0);
  uint64_t v11 = ausdk::AUScope::GetElement(v8, 0);
  if (!v11 || !*(_DWORD *)(v11 + 172)) {
    return 4294956420;
  }
  float v12 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement(v8, 0);
  uint64_t result = ausdk::AUInputElement::PullInput(v12, a2, a3, 0, a4);
  if (!result)
  {
    uint64_t BufferList = (AudioBufferList *)ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v10 + 144));
    ausdk::AUBufferList::CopyBufferContentsTo((void *)(Element + 144), BufferList);
    return 0;
  }
  return result;
}

uint64_t AUSubBandMultEchoCanceler::ProcessMultipleBufferLists(AUSubBandMultEchoCanceler *this, unsigned int *a2, int a3, unsigned int a4, const AudioBufferList **a5, unsigned int a6, AudioBufferList **a7)
{
  if (*((_DWORD *)this + 84) != a3) {
    return 4294956422;
  }
  if (*((_DWORD *)this + 134) != *((_DWORD *)this + 133)) {
    AUSubBandMultEchoCanceler::InitializeEC((float32x2_t *)this);
  }
  mData = (int *)(*a5)->mBuffers[0].mData;
  if (mData) {
    BOOL v10 = a5[1]->mBuffers[0].mData == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (v10) {
    return 0xFFFFFFFFLL;
  }
  v142 = (float *)a7[1]->mBuffers[0].mData;
  uint64_t v143 = (float *)a7[2]->mBuffers[0].mData;
  uint64_t v144 = (float *)(*a7)->mBuffers[0].mData;
  if (*((_DWORD *)this + 928))
  {
    unint64_t v12 = 0;
    size_t v13 = 4 * *((_DWORD *)this + 137);
    uint64_t v14 = 16;
    do
    {
      memcpy(*(void **)(*((void *)this + 463) + 8 * v12++), *(const void **)((char *)&a5[1]->mNumberBuffers + v14), v13);
      v14 += 16;
    }
    while (v12 < *((unsigned int *)this + 928));
  }
  uint64_t v15 = *((void *)this + 463);
  uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUSubBandMultEchoCanceler *)((char *)this + 32), 0);
  float Parameter = ausdk::AUElement::GetParameter(Element, 0xAu);
  float v18 = *((float *)this + 905);
  if (v18 < *((float *)this + 906)) {
    *((float *)this + 905) = v18 + (float)(*((float *)this + 880) / 1000.0);
  }
  AUsubMAEC::dftBuffer::GetIndexSequence((_DWORD *)this + 170, 1);
  uint64_t v19 = *((unsigned int *)this + 874);
  uint64_t v20 = *((int *)this + 878);
  if ((int)v19 >= 1)
  {
    uint64_t v21 = 0;
    uint64_t v22 = ((*((_DWORD *)this + 879) - 1) * v20);
    int v23 = (*((_DWORD *)this + 879) - 1) * v20;
    do
    {
      if (v23 >= 1)
      {
        int32x2_t v24 = *(_DWORD **)(*((void *)this + 88) + 8 * v21);
        uint64_t v25 = v22;
        do
        {
          *int32x2_t v24 = v24[v20];
          ++v24;
          --v25;
        }
        while (v25);
      }
      if ((int)v20 >= 1)
      {
        unsigned int v26 = *(int **)(v15 + 8 * v21);
        uint64_t v27 = (_DWORD *)(*(void *)(*((void *)this + 88) + 8 * v21) + 4 * (int)v22);
        uint64_t v28 = v20;
        do
        {
          int v29 = *v26++;
          *v27++ = v29;
          --v28;
        }
        while (v28);
      }
      ++v21;
    }
    while (v21 != v19);
  }
  vDSP_svesq(**((const float ***)this + 88), 1, (float *)this + 930, (int)v20 * (int)v19);
  float v146 = 0.0;
  if (*((int *)this + 183) < 1)
  {
    float v34 = 0.0;
  }
  else
  {
    uint64_t v30 = 0;
    int v31 = *((_DWORD *)this + 182);
    int v32 = *((_DWORD *)this + 188);
    LODWORD(v148.realp) = 0;
    uint64_t v33 = v32 * v31;
    float v34 = 0.0;
    do
    {
      AUsubMAEC::dft::dftAnalysis((AUSubBandMultEchoCanceler *)((char *)this + 576), *(const float **)(*((void *)this + 88) + 8 * v30), (float *)(*(void *)(*((void *)this + 85) + 8 * v30) + 4 * v33), (float *)(*(void *)(*((void *)this + 86) + 8 * v30) + 4 * v33), (float *)&v148);
      float v34 = v34 + *(float *)&v148.realp;
      ++v30;
    }
    while (v30 < *((int *)this + 183));
  }
  if (*((int *)this + 925) > 1) {
    AUsubMAEC::dftBuffer::GetIndexSequence((_DWORD *)this + 170, 0);
  }
  float __A = 0.0;
  vDSP_vfill(&__A, *((float **)this + 87), 1, *((int *)this + 188));
  if (*((int *)this + 183) >= 1)
  {
    uint64_t v35 = 0;
    do
    {
      vDSP_Length v36 = *(float **)(*((void *)this + 86) + 8 * v35);
      v148.realp = *(float **)(*((void *)this + 85) + 8 * v35);
      v148.imagp = v36;
      vDSP_zvmags(&v148, 1, *((float **)this + 95), 1, *((int *)this + 184) * (uint64_t)*((int *)this + 188));
      if (*((int *)this + 184) >= 1)
      {
        uint64_t v37 = 0;
        uint64_t v38 = *((void *)this + 87);
        do
        {
          uint64_t v39 = *((void *)this + 95) + 4 * *((_DWORD *)this + 188) * *(_DWORD *)(*((void *)this + 89) + 4 * v37);
          vDSP_vadd((const float *)(v38 + 4), 1, (const float *)(v39 + 4), 1, (float *)(v38 + 4), 1, *((int *)this + 187));
          uint64_t v38 = *((void *)this + 87);
          *(float *)uint64_t v38 = *(float *)v39 + *(float *)v38;
          *(float *)(v38 + 4 * *((int *)this + 186)) = *(float *)(v39 + 4 * *((int *)this + 186))
                                                       + *(float *)(v38 + 4 * *((int *)this + 186));
          ++v37;
        }
        while (v37 < *((int *)this + 184));
      }
      if (*((int *)this + 185) >= 1)
      {
        uint64_t v40 = 0;
        uint64_t v41 = *((void *)this + 87);
        do
        {
          uint64_t v42 = *((void *)this + 95) + 4 * *((_DWORD *)this + 188) * *(_DWORD *)(*((void *)this + 90) + 4 * v40);
          vDSP_vadd((const float *)(v41 + 4), 1, (const float *)v42, 1, (float *)(v41 + 4), 1, *((int *)this + 187));
          uint64_t v41 = *((void *)this + 87);
          *(float *)uint64_t v41 = *(float *)(v42 + 4) + *(float *)v41;
          *(float *)(v41 + 4 * *((int *)this + 186)) = *(float *)(v42 + 4 * *((int *)this + 186) - 4)
                                                       + *(float *)(v41 + 4 * *((int *)this + 186));
          ++v40;
          uint64_t v43 = *((int *)this + 185);
        }
        while (v40 < v43);
        if ((int)v43 >= 1)
        {
          uint64_t v44 = 0;
          do
          {
            uint64_t v45 = *((void *)this + 95) + 4 * *((_DWORD *)this + 188) * *(_DWORD *)(*((void *)this + 90) + 4 * v44);
            vDSP_vadd((const float *)(v41 + 4), 1, (const float *)(v45 + 8), 1, (float *)(v41 + 4), 1, *((int *)this + 187));
            uint64_t v41 = *((void *)this + 87);
            *(float *)uint64_t v41 = *(float *)(v45 + 8) + *(float *)v41;
            *(float *)(v41 + 4 * *((int *)this + 186)) = *(float *)(v45 + 4 * *((int *)this + 186) - 8)
                                                         + *(float *)(v41 + 4 * *((int *)this + 186));
            ++v44;
          }
          while (v44 < *((int *)this + 185));
        }
      }
      ++v35;
    }
    while (v35 < *((int *)this + 183));
  }
  float __A = 1.0e-12;
  vDSP_vsadd(*((const float **)this + 87), 1, &__A, *((float **)this + 87), 1, *((int *)this + 877));
  uint64_t v46 = *((int *)this + 878);
  int v47 = (*((_DWORD *)this + 879) - 1) * v46;
  float v48 = (const float *)*((void *)this + 442);
  if (v47 >= 1)
  {
    uint64_t v49 = (_DWORD *)*((void *)this + 442);
    uint64_t v50 = ((*((_DWORD *)this + 879) - 1) * v46);
    do
    {
      *uint64_t v49 = v49[v46];
      ++v49;
      --v50;
    }
    while (v50);
  }
  if ((int)v46 >= 1)
  {
    float v51 = (float *)&v48[v47];
    uint64_t v46 = v46;
    do
    {
      int v52 = *mData++;
      *(_DWORD *)v51++ = v52;
      --v46;
    }
    while (v46);
  }
  AUsubMAEC::dft::dftAnalysis((AUSubBandMultEchoCanceler *)((char *)this + 576), v48, *((float **)this + 443), *((float **)this + 444), &v146);
  AUsubMAEC::myFilter::runFilter((AUSubBandMultEchoCanceler *)((char *)this + 768), (DSPSplitComplex *)((char *)this + 1000), (DSPSplitComplex *)((char *)this + 1016), *((float ***)this + 85), *((float ***)this + 86), *((int **)this + 89), *((int **)this + 90), *((unsigned __int8 *)this + 570));
  AUsubMAEC::myFilter::runFilter((AUSubBandMultEchoCanceler *)((char *)this + 840), (DSPSplitComplex *)this + 68, (DSPSplitComplex *)this + 69, *((float ***)this + 85), *((float ***)this + 86), *((int **)this + 89), *((int **)this + 90), *((unsigned __int8 *)this + 570));
  AUsubMAEC::myFilter::runFilter((AUSubBandMultEchoCanceler *)((char *)this + 912), (DSPSplitComplex *)((char *)this + 1176), (DSPSplitComplex *)((char *)this + 1192), *((float ***)this + 85), *((float ***)this + 86), *((int **)this + 89), *((int **)this + 90), 0);
  AUsubMAEC::Kalman::runKFFilter((AUSubBandMultEchoCanceler *)((char *)this + 2504), (AUSubBandMultEchoCanceler *)((char *)this + 680), *((DSPSplitComplex *)this + 79), *((DSPSplitComplex *)this + 80), 1, *((unsigned __int8 *)this + 570));
  v141 = (AUSubBandMultEchoCanceler *)((char *)this + 2504);
  *((_OWORD *)this + 174) = *(_OWORD *)((char *)this + 2504);
  AUsubMAEC::Kalman::runKFFilter((AUSubBandMultEchoCanceler *)((char *)this + 2784), (AUSubBandMultEchoCanceler *)((char *)this + 680), *(DSPSplitComplex *)((char *)this + 1352), *(DSPSplitComplex *)((char *)this + 1368), 0, *((unsigned __int8 *)this + 570));
  vDSP_zvsub((const DSPSplitComplex *)((char *)this + 3544), 1, (const DSPSplitComplex *)((char *)this + 1000), 1, (const DSPSplitComplex *)((char *)this + 1032), 1, *((int *)this + 264));
  int v53 = (_DWORD *)*((void *)this + 130);
  *int v53 = 0;
  v53[*((int *)this + 265)] = 0;
  vDSP_zvsub((const DSPSplitComplex *)((char *)this + 3544), 1, (const DSPSplitComplex *)this + 68, 1, (const DSPSplitComplex *)this + 70, 1, *((int *)this + 286));
  int v54 = (_DWORD *)*((void *)this + 141);
  *int v54 = 0;
  v54[*((int *)this + 287)] = 0;
  vDSP_zvsub((const DSPSplitComplex *)((char *)this + 3544), 1, (const DSPSplitComplex *)((char *)this + 1176), 1, (const DSPSplitComplex *)((char *)this + 1208), 1, *((int *)this + 308));
  float v55 = (_DWORD *)*((void *)this + 152);
  _DWORD *v55 = 0;
  v55[*((int *)this + 309)] = 0;
  vDSP_zvsub((const DSPSplitComplex *)((char *)this + 3544), 1, (const DSPSplitComplex *)this + 79, 1, (const DSPSplitComplex *)this + 81, 1, *((int *)this + 330));
  uint64_t v56 = (_DWORD *)*((void *)this + 163);
  _DWORD *v56 = 0;
  v56[*((int *)this + 331)] = 0;
  vDSP_zvsub((const DSPSplitComplex *)((char *)this + 3544), 1, (const DSPSplitComplex *)((char *)this + 1352), 1, (const DSPSplitComplex *)((char *)this + 1384), 1, *((int *)this + 352));
  float v57 = (_DWORD *)*((void *)this + 174);
  *float v57 = 0;
  v57[*((int *)this + 353)] = 0;
  DSPSplitComplex v148 = (DSPSplitComplex)*((_OWORD *)this + 81);
  vDSP_zvmags(&v148, 1, *((float **)this + 324), 1, *((int *)this + 641));
  float v58 = v146;
  *((float *)this + 375) = v34;
  *((float *)this + 376) = v58;
  AUsubMAEC::learnRate::updateTimeStatistics2((AUSubBandMultEchoCanceler *)((char *)this + 1424), *((const float **)this + 129), *((const float **)this + 130), *((const float **)this + 125), *((const float **)this + 126));
  *((float *)this + 429) = v34;
  *((float *)this + 430) = v58;
  AUsubMAEC::learnRate::updateTimeStatistics2((AUSubBandMultEchoCanceler *)((char *)this + 1640), *((const float **)this + 140), *((const float **)this + 141), *((const float **)this + 136), *((const float **)this + 137));
  *((float *)this + 483) = v34;
  *((float *)this + 484) = v58;
  AUsubMAEC::learnRate::updateTimeStatistics2((AUSubBandMultEchoCanceler *)((char *)this + 1856), *((const float **)this + 151), *((const float **)this + 152), *((const float **)this + 147), *((const float **)this + 148));
  *((float *)this + 537) = v34;
  *((float *)this + 538) = v58;
  AUsubMAEC::learnRate::updateTimeStatistics2((AUSubBandMultEchoCanceler *)((char *)this + 2072), *((const float **)this + 162), *((const float **)this + 163), *((const float **)this + 158), *((const float **)this + 159));
  *((float *)this + 591) = v34;
  *((float *)this + 592) = v58;
  AUsubMAEC::learnRate::updateTimeStatistics2((AUSubBandMultEchoCanceler *)((char *)this + 2288), *((const float **)this + 173), *((const float **)this + 174), *((const float **)this + 169), *((const float **)this + 170));
  float v59 = *((float *)this + 364);
  if (v59 >= *((float *)this + 472)) {
    float v59 = *((float *)this + 472);
  }
  if (v59 >= *((float *)this + 526)) {
    float v59 = *((float *)this + 526);
  }
  *((float *)this + 904) = v59;
  AUsubMAEC::learnRate::micEchoXcorrForDTD((AUSubBandMultEchoCanceler *)((char *)this + 1424), *(DSPSplitComplex *)((char *)this + 3544), *(DSPSplitComplex *)((char *)this + 1000));
  AUsubMAEC::learnRate::micEchoXcorrForDTD((AUSubBandMultEchoCanceler *)((char *)this + 1856), *(DSPSplitComplex *)((char *)this + 3544), *(DSPSplitComplex *)((char *)this + 1176));
  AUsubMAEC::learnRate::micEchoXcorrForDTD((AUSubBandMultEchoCanceler *)((char *)this + 2072), *(DSPSplitComplex *)((char *)this + 3544), *((DSPSplitComplex *)this + 79));
  *((_DWORD *)this + 362) = *((_DWORD *)this + 524);
  *((_DWORD *)this + 524) = *((_DWORD *)this + 470);
  AUsubMAEC::learnRate::getLeakage((AUSubBandMultEchoCanceler *)((char *)this + 1424), *((float **)this + 129), *((float **)this + 130), *((float **)this + 125), *((float **)this + 126));
  AUsubMAEC::learnRate::getLeakage((AUSubBandMultEchoCanceler *)((char *)this + 2072), *((float **)this + 162), *((float **)this + 163), *((float **)this + 158), *((float **)this + 159));
  *((_DWORD *)this + 931) = *((_DWORD *)this + 524);
  *((_DWORD *)this + 929) = *((unsigned __int8 *)this + 2220);
  vDSP_vdiv(*((const float **)this + 87), 1, *((const float **)this + 178), 1, *((float **)this + 178), 1, *((int *)this + 877));
  if (*((unsigned char *)this + 1884))
  {
    float v60 = 0.35;
  }
  else
  {
    if (*((float *)this + 905) >= *((float *)this + 906)) {
      float v61 = -15.0;
    }
    else {
      float v61 = -5.0;
    }
    if (*((float *)this + 904) >= v61) {
      float v60 = 0.01;
    }
    else {
      float v60 = 0.25;
    }
  }
  float v145 = v60;
  vDSP_svdiv(&v145, *((const float **)this + 87), 1, *((float **)this + 232), 1, *((int *)this + 877));
  AUsubMAEC::learnRate::adaptFilter((const float **)this + 178, *(DSPSplitComplex *)((char *)this + 1032), (AUSubBandMultEchoCanceler *)((char *)this + 680), (AUSubBandMultEchoCanceler *)((char *)this + 768));
  AUsubMAEC::learnRate::adaptFilter((const float **)this + 232, *(DSPSplitComplex *)((char *)this + 1208), (AUSubBandMultEchoCanceler *)((char *)this + 680), (AUSubBandMultEchoCanceler *)((char *)this + 912));
  float v62 = *((float *)this + 379);
  uint64_t v63 = *((void *)this + 88);
  float v64 = v146;
  float v65 = *((float *)this + 692);
  *((float *)this + 693) = v65;
  LODWORD(v148.realp) = 0;
  LODWORD(v66) = *((_DWORD *)this + 638);
  if ((int)v66 < 1)
  {
    float v68 = 0.0;
  }
  else
  {
    uint64_t v67 = 0;
    float v68 = 0.0;
    do
    {
      vDSP_measqv(*(const float **)(v63 + 8 * v67), 1, (float *)&v148, *((int *)this + 639));
      float v68 = v68 + *(float *)&v148.realp;
      ++v67;
      uint64_t v66 = *((int *)this + 638);
    }
    while (v67 < v66);
    float v65 = *((float *)this + 693);
  }
  float v69 = (float)(v68 * (float)(1.0 / (float)(int)v66)) + 1.0e-20;
  float v70 = log10f(v69) * 10.0;
  *((float *)this + 692) = v70;
  float v71 = *((float *)this + 685);
  if (v65 >= v71 || v70 >= v71)
  {
    float v72 = *((float *)this + 684);
    double v73 = (float)(v72 * *((float *)this + 650));
    double v74 = (float)((float)(1.0 - v72) * (float)(1.0 - *((float *)this + 653)));
    if (v62 >= v64) {
      float v75 = v64;
    }
    else {
      float v75 = v62;
    }
    float v76 = v73 + v74 * ((v75 + 1.0e-20) / (v34 + 1.0e-20));
    *((float *)this + 650) = v76;
  }
  uint64_t v77 = *((unsigned int *)this + 641);
  int v78 = *((_DWORD *)this + 660);
  if ((int)v77 < 1)
  {
    float v80 = 0.0;
  }
  else
  {
    uint64_t v79 = 0;
    float v80 = 0.0;
    do
    {
      if (v78 >= 1)
      {
        vDSP_Length v81 = (int *)*((void *)this + 331);
        uint64_t v82 = *((unsigned int *)this + 660);
        do
        {
          uint64_t v83 = *v81++;
          float v80 = v80 + *(float *)(*(void *)(*((void *)this + 317) + 8 * v79) + 4 * v83);
          --v82;
        }
        while (v82);
      }
      ++v79;
    }
    while (v79 != v77);
  }
  float v84 = (float)((float)(1.0 - *((float *)this + 684)) * (float)(v80 / (float)((float)(int)v77 * (float)v78)))
      + (float)(*((float *)this + 684) * *((float *)this + 689));
  *((float *)this + 689) = v84;
  float v85 = (v84 + 1.0e-20) / (*((float *)this + 650) + 1.0e-20);
  float v86 = log10f(v85) * 10.0;
  float v87 = *((float *)this + 690);
  float v88 = *((float *)this + 691);
  if (v87 < v88)
  {
    float v87 = v87 + *((float *)this + 646);
    *((float *)this + 690) = v87;
  }
  unsigned int v89 = Parameter;
  if (v86 <= *((float *)this + 686) || v87 <= v88)
  {
    if (v86 < *((float *)this + 687) && v87 > v88 && (int)v77 >= 1)
    {
      uint64_t v93 = 0;
      do
      {
        vDSP_vclr(*(float **)(*((void *)this + 317) + 8 * v93), 1, *((int *)this + 694) * (uint64_t)v78);
        vDSP_vclr(*(float **)(*((void *)this + 318) + 8 * v93), 1, *((int *)this + 694) * (uint64_t)*((int *)this + 660));
        int v78 = *((_DWORD *)this + 660);
        if (v78 >= 1)
        {
          uint64_t v94 = *(void *)(*((void *)this + 317) + 8 * v93);
          float v95 = (int *)*((void *)this + 331);
          uint64_t v96 = *((unsigned int *)this + 660);
          do
          {
            uint64_t v97 = *v95++;
            *(float *)(v94 + 4 * v97) = *((float *)this + 688) * *((float *)this + 650);
            --v96;
          }
          while (v96);
        }
        ++v93;
      }
      while (v93 < *((int *)this + 641));
    }
  }
  else if ((int)v77 >= 1)
  {
    uint64_t v98 = 0;
    do
    {
      vDSP_vclr(*(float **)(*((void *)this + 317) + 8 * v98), 1, *((int *)this + 694) * (uint64_t)*((int *)this + 660));
      vDSP_vclr(*(float **)(*((void *)this + 318) + 8 * v98), 1, *((int *)this + 694) * (uint64_t)*((int *)this + 660));
      int v99 = *((_DWORD *)this + 660);
      if (v99 >= 1)
      {
        uint64_t v100 = *(void *)(*((void *)this + 317) + 8 * v98);
        float v101 = (int *)*((void *)this + 331);
        uint64_t v102 = *((unsigned int *)this + 660);
        do
        {
          uint64_t v103 = *v101++;
          *(float *)(v100 + 4 * v103) = *((float *)this + 688) * *((float *)this + 650);
          --v102;
        }
        while (v102);
      }
      vDSP_vclr(*(float **)(*((void *)this + 315) + 8 * v98), 1, v99);
      vDSP_vclr(*(float **)(*((void *)this + 316) + 8 * v98++), 1, *((int *)this + 660));
    }
    while (v98 < *((int *)this + 641));
  }
  if (*((_DWORD *)this + 924) == v89)
  {
    *((_DWORD *)this + 924) = 0;
    v105 = (AUSubBandMultEchoCanceler *)((char *)this + 840);
    uint64_t v104 = (AUSubBandMultEchoCanceler *)((char *)this + 768);
    uint64_t v106 = (AUSubBandMultEchoCanceler *)((char *)this + 2504);
    if (!v89) {
      AUsubMAEC::Kalman::adaptKalmanFilter(v141, *((DSPSplitComplex *)this + 81), *((float **)this + 259));
    }
  }
  else
  {
    uint64_t v106 = (AUSubBandMultEchoCanceler *)((char *)this + 2504);
    AUsubMAEC::Kalman::adaptKalmanFilter(v141, *((DSPSplitComplex *)this + 81), *((float **)this + 259));
    ++*((_DWORD *)this + 924);
    v105 = (AUSubBandMultEchoCanceler *)((char *)this + 840);
    uint64_t v104 = (AUSubBandMultEchoCanceler *)((char *)this + 768);
  }
  *((void *)this + 383) = (char *)this + 984;
  AUsubMAEC::dualEC::dualECProcess((AUSubBandMultEchoCanceler *)((char *)this + 3064), v104, v105, 0, 0, (AUSubBandMultEchoCanceler *)((char *)this + 1424), (AUSubBandMultEchoCanceler *)((char *)this + 1640), (void **)this + 123, (const void **)this + 134, 0);
  *((void *)this + 410) = (char *)this + 1248;
  AUsubMAEC::dualEC::dualECProcess((AUSubBandMultEchoCanceler *)((char *)this + 3280), 0, 0, v106, (AUSubBandMultEchoCanceler *)((char *)this + 2784), (AUSubBandMultEchoCanceler *)((char *)this + 2072), (AUSubBandMultEchoCanceler *)((char *)this + 2288), (void **)this + 156, (const void **)this + 167, 1);
  v107 = (float **)*((void *)this + 383);
  float v108 = (float **)*((void *)this + 410);
  float v109 = *((float *)this + 486);
  float v110 = *((float *)this + 540);
  float v111 = log10(*((float *)this + 378) + 1.0e-15) * 10.0;
  float v112 = log10(v109 + 1.0e-15) * 10.0;
  float v113 = log10(v110 + 1.0e-15) * 10.0;
  size_t v114 = 4 * *((_DWORD *)this + 892) - 4;
  memmove((void *)(*((void *)this + 449) + 4), *((const void **)this + 449), v114);
  memmove((void *)(*((void *)this + 448) + 4), *((const void **)this + 448), v114);
  memmove((void *)(*((void *)this + 450) + 4), *((const void **)this + 450), v114);
  uint64_t v115 = (int *)*((void *)this + 448);
  *uint64_t v115 = (float)(v113 + -1.0) > v112;
  uint64_t v116 = (int *)*((void *)this + 449);
  *uint64_t v116 = (float)(v111 + -1.0) > v112;
  float v117 = (int *)*((void *)this + 450);
  *float v117 = (float)(v113 + -1.5) > v111;
  uint64_t v118 = *((unsigned int *)this + 892);
  if ((int)v118 < 1)
  {
    int v122 = 0;
    int v119 = 0;
    int v125 = 0;
    v126 = (AUSubBandMultEchoCanceler *)((char *)this + 32);
    v127 = v142;
    vDSP_Length v128 = v143;
  }
  else
  {
    int v119 = 0;
    uint64_t v120 = *((unsigned int *)this + 892);
    do
    {
      int v121 = *v115++;
      v119 += v121;
      --v120;
    }
    while (v120);
    int v122 = 0;
    uint64_t v123 = *((unsigned int *)this + 892);
    do
    {
      int v124 = *v116++;
      v122 += v124;
      --v123;
    }
    while (v123);
    int v125 = 0;
    v126 = (AUSubBandMultEchoCanceler *)((char *)this + 32);
    v127 = v142;
    vDSP_Length v128 = v143;
    do
    {
      int v129 = *v117++;
      v125 += v129;
      --v118;
    }
    while (v118);
  }
  int v130 = *((_DWORD *)this + 893);
  *((unsigned char *)this + 2100) = v119 > v130;
  *((unsigned char *)this + 1452) = v122 > v130;
  *((unsigned char *)this + 1884) = v119 > v130;
  if (v125 <= v130)
  {
    *((_DWORD *)this + 894) = 0;
    v107 = v108;
    BOOL v131 = v119 <= v130;
  }
  else
  {
    *((_DWORD *)this + 894) = 1;
    BOOL v131 = v122 <= v130;
  }
  if (!v131)
  {
    v107 = (float **)((char *)this + 1160);
    *((_DWORD *)this + 894) = 2;
  }
  *((void *)this + 445) = v107;
  AUsubMAEC::myAecCore::sigOLA((AUSubBandMultEchoCanceler *)((char *)this + 568), v107[2], v107[3], *((DSPComplex **)this + 454), *((float **)this + 458), v127);
  AUsubMAEC::myAecCore::sigOLA((AUSubBandMultEchoCanceler *)((char *)this + 568), *((float **)this + 443), *((float **)this + 444), *((DSPComplex **)this + 454), *((float **)this + 461), v128);
  AUsubMAEC::myAecCore::sigOLA((AUSubBandMultEchoCanceler *)((char *)this + 568), *(float **)(*((void *)this + 445) + 48), *(float **)(*((void *)this + 445) + 56), *((DSPComplex **)this + 454), *((float **)this + 455), v144);
  int v132 = *((_DWORD *)this + 182);
  int v133 = v132 + 1;
  unsigned int v134 = *((_DWORD *)this + 184);
  unsigned int v135 = ~v132 + (v133 >> 31) + (v133 & ~(v133 >> 31));
  if (v134 <= 1) {
    unsigned int v136 = 1;
  }
  else {
    unsigned int v136 = *((_DWORD *)this + 184);
  }
  signed int v137 = v133 + v134 + v134 * (v135 / v136 + (v133 >> 31));
  do
    v137 -= v134;
  while (v137 >= (int)v134);
  *((_DWORD *)this + 182) = v137;
  float v138 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v126, 0);
  ausdk::AUElement::SetParameter(v138, 8u, (float)*((int *)this + 929), 0);
  v139 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v126, 0);
  ausdk::AUElement::SetParameter(v139, 9u, *((float *)this + 930), 0);
  uint64_t v140 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v126, 0);
  ausdk::AUElement::SetParameter(v140, 7u, *((float *)this + 931), 0);
  return 0;
}

void AUSubBandMultEchoCanceler::InitializeEC(float32x2_t *this)
{
  uint64_t v2 = (ausdk::AUScope *)&this[4];
  this[68].i32[0] = *(double *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)&this[10], 0) + 80);
  uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::GetElement(v2, 0);
  this[69].i32[0] = ausdk::AUElement::GetParameter(Element, 2u);
  uint64_t v4 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v2, 0);
  this[67].i32[1] = ausdk::AUElement::GetParameter(v4, 0);
  float v5 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v2, 0);
  this[70].i32[0] = ausdk::AUElement::GetParameter(v5, 1u);
  CFStringRef v6 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v2, 0);
  this[68].i32[1] = ausdk::AUElement::GetParameter(v6, 3u);
  AudioUnitParameterUnit v7 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v2, 0);
  this[69].i8[4] = ausdk::AUElement::GetParameter(v7, 4u) != 0.0;
  AudioUnitParameterValue v8 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v2, 0);
  this[69].i8[5] = ausdk::AUElement::GetParameter(v8, 5u) != 0.0;
  AudioUnitParameterValue v9 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v2, 0);
  this[69].i8[6] = ausdk::AUElement::GetParameter(v9, 6u) != 0.0;
  BOOL v10 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v2, 0);
  this[464].i32[0] = ausdk::AUElement::GetParameter(v10, 0xBu);
  uint64_t v11 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v2, 0);
  float Parameter = ausdk::AUElement::GetParameter(v11, 0xCu);
  this[70].i32[1] = Parameter;
  if ((Parameter | 2) != 3) {
    this[70].i32[1] = 1;
  }
  unsigned int v13 = this[464].u32[0];
  if (v13 >= 3) {
    this[70].i32[0] = 1;
  }
  int v14 = this[68].i32[1];
  if (this[69].i32[0] < (2 * v14)) {
    this[69].i32[0] = 2 * v14;
  }
  this[463] = (float32x2_t)allocMatrix(v13, v14);
  int v15 = this[69].i32[0];
  int v16 = this[68].i32[1];
  int v17 = this[68].i32[0];
  __int32 v18 = this[464].i32[0];
  __int32 v19 = this[70].i32[0];
  __int16 v20 = this[69].i16[2];
  __int8 v21 = this[69].i8[6];
  __int32 v22 = this[70].i32[1];
  fwrite("Initializing EC", 0xFuLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
  this[71].i16[0] = v20;
  this[71].i8[2] = v21;
  this[78].i32[0] = v18;
  this[76].i32[1] = v19;
  this[74].i32[1] = v16;
  this[73].i32[0] = v15;
  this[73].i32[1] = v15 >> 1;
  this[74].i32[0] = (v15 >> 1) - 1;
  this[75].i32[0] = (v15 >> 1) + 1;
  this[80].i32[1] = (int)(float)(v15 / v16);
  this[80].i32[0] = v22;
  *(float *)v23.i32 = (float)v15;
  __asm { FMOV            V3.2S, #1.0 }
  _D3.f32[0] = (float)v16 + (float)v16;
  this[77] = vdiv_f32(_D3, (float32x2_t)vdup_lane_s32(v23, 0));
  this[76].i32[0] = v17;
  float v29 = (float)((float)v16 / (float)v17) * 1000.0;
  if (v17 < 1) {
    float v29 = 0.0;
  }
  this[75].f32[1] = v29;
  MultiRadixRealFFT_Create();
}

uint64_t AUSubBandMultEchoCanceler::CanScheduleParameters(AUSubBandMultEchoCanceler *this)
{
  return 0;
}

uint64_t AUSubBandMultEchoCanceler::SetParameter(AUSubBandMultEchoCanceler *this, unsigned int a2, unsigned int a3, unsigned int a4, float a5)
{
  BOOL v10 = (a2 == 2 || (a2 & 0xFFFFFFFD) == 1 || a2 - 11 < 2) && a3 == 0;
  if (!(a3 | a2) || v10)
  {
    if (*((unsigned char *)this + 17)) {
      ++*((_DWORD *)this + 133);
    }
    uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUSubBandMultEchoCanceler *)((char *)this + 32), 0);
  }
  else
  {
    Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
    uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
  }
  ausdk::AUElement::SetParameter(Element, a2, a5, 0);
  return 0;
}

uint64_t AUSubBandMultEchoCanceler::SetProperty(AUSubBandMultEchoCanceler *this, int a2, int a3, unsigned int a4, int *a5, unsigned int a6)
{
  uint64_t result = 4294956417;
  if (a2 == 21 && !a3)
  {
    if (a6 >= 4)
    {
      int v8 = *a5;
      int v9 = *a5 != 0;
      if (v9 != (*(unsigned int (**)(AUSubBandMultEchoCanceler *))(*(void *)this + 576))(this)) {
        (*(void (**)(AUSubBandMultEchoCanceler *, BOOL))(*(void *)this + 584))(this, v8 != 0);
      }
      return 0;
    }
    else
    {
      return 4294956445;
    }
  }
  return result;
}

uint64_t AUSubBandMultEchoCanceler::GetProperty(AUSubBandMultEchoCanceler *this, int a2, int a3, unsigned int a4, _DWORD *a5)
{
  if (a3) {
    return 4294956417;
  }
  if (a2 == 3700)
  {
    int v7 = *((unsigned __int8 *)this + 376);
    goto LABEL_7;
  }
  if (a2 == 21)
  {
    int v7 = (*(uint64_t (**)(AUSubBandMultEchoCanceler *))(*(void *)this + 576))(this);
LABEL_7:
    uint64_t result = 0;
    *a5 = v7;
    return result;
  }
  return 4294956417;
}

uint64_t AUSubBandMultEchoCanceler::GetPropertyInfo(AUSubBandMultEchoCanceler *this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  if (a3) {
    return 4294956417;
  }
  if (a2 == 21)
  {
    BOOL v7 = 1;
  }
  else
  {
    if (a2 != 3700) {
      return 4294956417;
    }
    BOOL v7 = 0;
  }
  uint64_t result = 0;
  *a6 = v7;
  *a5 = 4;
  return result;
}

uint64_t AUSubBandMultEchoCanceler::Reset(AUSubBandMultEchoCanceler *this)
{
  return 0;
}

void AUSubBandMultEchoCanceler::Cleanup(AUSubBandMultEchoCanceler *this)
{
}

uint64_t AUSubBandMultEchoCanceler::Initialize(float32x2_t *this)
{
  float32x2_t v2 = this[15];
  if (v2) {
    LODWORD(v3) = (*(uint64_t (**)(float32x2_t))(**(void **)&v2 + 24))(v2);
  }
  else {
    uint64_t v3 = (*(void *)&this[13] - *(void *)&this[12]) >> 3;
  }
  float32x2_t v4 = this[21];
  if (v4) {
    LODWORD(v5) = (*(uint64_t (**)(float32x2_t))(**(void **)&v4 + 24))(v4);
  }
  else {
    uint64_t v5 = (*(void *)&this[19] - *(void *)&this[18]) >> 3;
  }
  if (v3 < 2)
  {
LABEL_11:
    if (v5 < 2)
    {
LABEL_15:
      double v10 = *(double *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)&this[10], 0) + 80);
      if (v10 == *(double *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)&this[16], 0) + 80))
      {
        this[67].i32[0] = this[66].i32[1];
        AUSubBandMultEchoCanceler::InitializeEC(this);
      }
    }
    else
    {
      unsigned int v8 = 1;
      while (1)
      {
        double v9 = *(double *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)&this[16], v8 - 1) + 80);
        if (v9 != *(double *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)&this[16], v8) + 80)) {
          break;
        }
        if (v5 == ++v8) {
          goto LABEL_15;
        }
      }
    }
  }
  else
  {
    unsigned int v6 = 1;
    while (1)
    {
      double v7 = *(double *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)&this[10], v6 - 1) + 80);
      if (v7 != *(double *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)&this[10], v6) + 80)) {
        break;
      }
      if (v3 == ++v6) {
        goto LABEL_11;
      }
    }
  }
  return 4294956428;
}

void AUSubBandMultEchoCanceler::~AUSubBandMultEchoCanceler(AUSubBandMultEchoCanceler *this)
{
  AUSubBandMultEchoCanceler::~AUSubBandMultEchoCanceler(this);

  JUMPOUT(0x1C185D370);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1F14AB798;
  freeMatrix(*((_DWORD *)this + 928), (float ***)this + 463);
  AUsubMAEC::myAecCore::~myAecCore((AUSubBandMultEchoCanceler *)((char *)this + 568));

  ausdk::AUBase::~AUBase(this);
}

BOOL ChannelLayoutTagIsSupportedHOA(int a1)
{
  if (a1 == 7012356) {
    return 1;
  }
  if ((a1 & 0xFFFE0000 | 0x10000) != 0xBF0000 || (unsigned __int16)a1 - 65026 < 0xFFFF01FF) {
    return 0;
  }
  double v2 = sqrt((double)(unsigned __int16)a1);
  return vabdd_f64(v2, round(v2)) <= 0.000000999999997;
}

uint64_t GetHOAOrderForNumberOfChannels(unsigned int a1)
{
  unsigned int v1 = 0x40000000;
  do
  {
    unsigned int v2 = v1;
    v1 >>= 2;
  }
  while (v2 > a1);
  unsigned int v3 = 0;
  if (v2)
  {
    do
    {
      unsigned int v4 = v3 + v2;
      int v5 = 2 * v2;
      if (a1 < v3 + v2)
      {
        unsigned int v4 = 0;
        int v5 = 0;
      }
      a1 -= v4;
      unsigned int v3 = (v5 + v3) >> 1;
      BOOL v6 = v2 > 3;
      v2 >>= 2;
    }
    while (v6);
  }
  if (v3) {
    return v3 - 1;
  }
  else {
    return 0;
  }
}

uint64_t std::map<std::string,unsigned int>::map[abi:ne180100](uint64_t a1, long long *a2, uint64_t a3)
{
  *(void *)(a1 + 8) = 0;
  unsigned int v4 = (void *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  if (a3)
  {
    int v5 = a2;
    BOOL v6 = &a2[2 * a3];
    do
    {
      double v7 = *(void **)(a1 + 8);
      if (*(void **)a1 == v4)
      {
        double v9 = v4;
        if (!v7) {
          goto LABEL_15;
        }
      }
      else
      {
        unsigned int v8 = v4;
        if (v7)
        {
          do
          {
            double v9 = v7;
            double v7 = (void *)v7[1];
          }
          while (v7);
        }
        else
        {
          do
          {
            double v9 = (void *)v8[2];
            BOOL v10 = *v9 == (void)v8;
            unsigned int v8 = v9;
          }
          while (v10);
        }
        if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v9 + 4, (void **)v5) & 0x80) == 0)
        {
          uint64_t v11 = (char **)std::__tree<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::__map_value_compare<std::string,std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::less<void>,true>,std::allocator<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>>::__find_equal<std::string>(a1, &v18, (void **)v5);
          goto LABEL_12;
        }
        if (!*v4)
        {
LABEL_15:
          __int32 v18 = v4;
          uint64_t v11 = (char **)v4;
LABEL_16:
          unint64_t v12 = (char *)operator new(0x40uLL);
          unsigned int v13 = (std::string *)(v12 + 32);
          if (*((char *)v5 + 23) < 0)
          {
            std::string::__init_copy_ctor_external(v13, *(const std::string::value_type **)v5, *((void *)v5 + 1));
          }
          else
          {
            long long v14 = *v5;
            *((void *)v12 + 6) = *((void *)v5 + 2);
            *(_OWORD *)&v13->__r_.__value_.__l.__data_ = v14;
          }
          *((_DWORD *)v12 + 14) = *((_DWORD *)v5 + 6);
          int v15 = v18;
          *(void *)unint64_t v12 = 0;
          *((void *)v12 + 1) = 0;
          *((void *)v12 + 2) = v15;
          ausdk::AUElement *v11 = v12;
          uint64_t v16 = **(void **)a1;
          if (v16)
          {
            *(void *)a1 = v16;
            unint64_t v12 = *v11;
          }
          std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 8), (uint64_t *)v12);
          ++*(void *)(a1 + 16);
          goto LABEL_22;
        }
      }
      __int32 v18 = v9;
      uint64_t v11 = (char **)(v9 + 1);
LABEL_12:
      if (!*v11) {
        goto LABEL_16;
      }
LABEL_22:
      v5 += 2;
    }
    while (v5 != v6);
  }
  return a1;
}

void sub_1BB35DA00(_Unwind_Exception *a1)
{
  operator delete(v1);
  std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::destroy(*v2);
  _Unwind_Resume(a1);
}

uint64_t std::istringstream::basic_istringstream[abi:ne180100](uint64_t a1, const std::string *a2)
{
  uint64_t v4 = MEMORY[0x1E4FBA490] + 64;
  *(void *)(a1 + 120) = MEMORY[0x1E4FBA490] + 64;
  uint64_t v5 = *(void *)(MEMORY[0x1E4FBA410] + 16);
  uint64_t v6 = *(void *)(MEMORY[0x1E4FBA410] + 8);
  *(void *)a1 = v6;
  *(void *)(a1 + *(void *)(v6 - 24)) = v5;
  *(void *)(a1 + 8) = 0;
  double v7 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v7, (void *)(a1 + 16));
  uint64_t v8 = MEMORY[0x1E4FBA490] + 24;
  v7[1].__vftable = 0;
  v7[1].__fmtflags_ = -1;
  *(void *)a1 = v8;
  *(void *)(a1 + 120) = v4;
  std::streambuf::basic_streambuf();
  uint64_t v9 = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)(a1 + 80) = 0u;
  *(void *)(a1 + 16) = v9;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_DWORD *)(a1 + 112) = 8;
  std::string::operator=((std::string *)(a1 + 80), a2);
  *(void *)(a1 + 104) = 0;
  char v10 = *(unsigned char *)(a1 + 103);
  if (v10 < 0)
  {
    uint64_t v11 = *(void *)(a1 + 80);
    unint64_t v12 = *(void *)(a1 + 88);
  }
  else
  {
    uint64_t v11 = a1 + 80;
    unint64_t v12 = *(unsigned __int8 *)(a1 + 103);
  }
  int v13 = *(_DWORD *)(a1 + 112);
  if ((v13 & 8) != 0)
  {
    *(void *)(a1 + 104) = v11 + v12;
    *(void *)(a1 + 32) = v11;
    *(void *)(a1 + 40) = v11;
    *(void *)(a1 + 48) = v11 + v12;
  }
  if ((v13 & 0x10) != 0)
  {
    *(void *)(a1 + 104) = v11 + v12;
    std::string::size_type v14 = v10 < 0 ? (*(void *)(a1 + 96) & 0x7FFFFFFFFFFFFFFFLL) - 1 : 22;
    std::string::resize((std::string *)(a1 + 80), v14, 0);
    uint64_t v15 = *(char *)(a1 + 103) < 0 ? *(void *)(a1 + 88) : *(unsigned __int8 *)(a1 + 103);
    *(void *)(a1 + 56) = v11;
    *(void *)(a1 + 64) = v11;
    *(void *)(a1 + 72) = v11 + v15;
    if ((*(unsigned char *)(a1 + 112) & 3) != 0)
    {
      if (v12 >> 31)
      {
        uint64_t v16 = ((v12 - 0x80000000) * (unsigned __int128)0x200000005uLL) >> 64;
        unint64_t v17 = 0x7FFFFFFF * ((v16 + ((v12 - 0x80000000 - v16) >> 1)) >> 30);
        v11 += v17 + 0x7FFFFFFF;
        unint64_t v12 = v12 - v17 - 0x7FFFFFFF;
        *(void *)(a1 + 64) = v11;
      }
      if (v12) {
        *(void *)(a1 + 64) = v11 + v12;
      }
    }
  }
  return a1;
}

void sub_1BB35DCA0(_Unwind_Exception *a1)
{
  std::istream::~istream();
  MEMORY[0x1C185D210](v1);
  _Unwind_Resume(a1);
}

uint64_t std::istringstream::~istringstream(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA410];
  uint64_t v3 = *MEMORY[0x1E4FBA410];
  *(void *)a1 = *MEMORY[0x1E4FBA410];
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 16) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  std::streambuf::~streambuf();
  std::istream::~istream();
  MEMORY[0x1C185D210](a1 + 120);
  return a1;
}

void std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::destroy(char *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::destroy(*(void *)a1);
    std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::destroy(*((void *)a1 + 1));
    if (a1[55] < 0) {
      operator delete(*((void **)a1 + 4));
    }
    operator delete(a1);
  }
}

void GetStringFromAudioChannelLayoutTag(void *a1, int a2)
{
  unsigned __int16 v2 = a2;
  unsigned int v4 = a2 & 0xFFFF0000;
  if ((a2 & 0xFFFF0000) == 0x930000)
  {
    std::string::basic_string[abi:ne180100]<0>(&v21, "DiscreteInOrder");
    uint64_t v11 = std::string::append(&v21, " ", 1uLL);
    long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    v22.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v22.__r_.__value_.__l.__data_ = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&__p, v2);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
  }
  else if (v4 == 12517376)
  {
    int v13 = llroundf(sqrtf((float)(unsigned __int16)a2));
    if (v13) {
      BOOL v14 = v13 * v13 == (unsigned __int16)a2;
    }
    else {
      BOOL v14 = 0;
    }
    if (!v14) {
      goto LABEL_25;
    }
    std::string::basic_string[abi:ne180100]<0>(&v21, "HOA_ACN_N3D");
    uint64_t v16 = std::string::append(&v21, " ", 1uLL);
    long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v22.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v22.__r_.__value_.__l.__data_ = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&__p, v13 - 1);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
  }
  else
  {
    if (v4 != 12451840)
    {
      if (a2 <= 10027011)
      {
        if (a2 > 8126469)
        {
          if (a2 <= 9043972)
          {
            if (a2 > 8585218)
            {
              if (a2 <= 8781827)
              {
                switch(a2)
                {
                  case 8585219:
                    uint64_t v15 = "ITU_2_1";
                    goto LABEL_26;
                  case 8650756:
                    uint64_t v15 = "ITU_2_2";
                    goto LABEL_26;
                  case 8716291:
                    uint64_t v15 = "DVD_4";
                    goto LABEL_26;
                }
              }
              else if (a2 > 8912899)
              {
                if (a2 == 8912900)
                {
                  uint64_t v15 = "DVD_10";
                  goto LABEL_26;
                }
                if (a2 == 8978437)
                {
                  uint64_t v15 = "DVD_11";
                  goto LABEL_26;
                }
              }
              else
              {
                if (a2 == 8781828)
                {
                  uint64_t v15 = "DVD_5";
                  goto LABEL_26;
                }
                if (a2 == 8847365)
                {
                  uint64_t v15 = "DVD_6";
                  goto LABEL_26;
                }
              }
            }
            else if (a2 <= 8323079)
            {
              switch(a2)
              {
                case 8126470:
                  uint64_t v15 = "MPEG_5_1_D";
                  goto LABEL_26;
                case 8192007:
                  uint64_t v15 = "MPEG_6_1_A";
                  goto LABEL_26;
                case 8257544:
                  uint64_t v15 = "MPEG_7_1_A";
                  goto LABEL_26;
              }
            }
            else if (a2 > 8454151)
            {
              if (a2 == 8454152)
              {
                uint64_t v15 = "Emagic_Default_7_1";
                goto LABEL_26;
              }
              if (a2 == 8519688)
              {
                uint64_t v15 = "SMPTE_DTV";
                goto LABEL_26;
              }
            }
            else
            {
              if (a2 == 8323080)
              {
                uint64_t v15 = "MPEG_7_1_B";
                goto LABEL_26;
              }
              if (a2 == 8388616)
              {
                uint64_t v15 = "MPEG_7_1_C";
                goto LABEL_26;
              }
            }
          }
          else if (a2 <= 9502735)
          {
            if (a2 <= 9240581)
            {
              switch(a2)
              {
                case 9043973:
                  uint64_t v15 = "DVD_18";
                  goto LABEL_26;
                case 9109510:
                  uint64_t v15 = "AudioUnit_6_0";
                  goto LABEL_26;
                case 9175047:
                  uint64_t v15 = "AudioUnit_7_0";
                  goto LABEL_26;
              }
            }
            else if (a2 > 9371654)
            {
              if (a2 == 9371655)
              {
                uint64_t v15 = "AAC_7_0";
                goto LABEL_26;
              }
              if (a2 == 9437192)
              {
                uint64_t v15 = "AAC_Octagonal";
                goto LABEL_26;
              }
            }
            else
            {
              if (a2 == 9240582)
              {
                uint64_t v15 = "AAC_6_0";
                goto LABEL_26;
              }
              if (a2 == 9306119)
              {
                uint64_t v15 = "AAC_6_1";
                goto LABEL_26;
              }
            }
          }
          else if (a2 > 9764865)
          {
            if (a2 > 9895939)
            {
              if (a2 == 9895940)
              {
                uint64_t v15 = "AC3_3_1";
                goto LABEL_26;
              }
              if (a2 == 9961476)
              {
                uint64_t v15 = "AC3_3_0_1";
                goto LABEL_26;
              }
            }
            else
            {
              if (a2 == 9764866)
              {
                uint64_t v15 = "AC3_1_0_1";
                goto LABEL_26;
              }
              if (a2 == 9830403)
              {
                uint64_t v15 = "AC3_3_0";
                goto LABEL_26;
              }
            }
          }
          else if (a2 >= 9633792)
          {
            if (a2 == 9633792)
            {
              uint64_t v15 = "DiscreteInOrder";
              goto LABEL_26;
            }
            if (a2 == 9699335)
            {
              uint64_t v15 = "AudioUnit_7_0_Front";
              goto LABEL_26;
            }
          }
          else
          {
            if (a2 == 9502736)
            {
              uint64_t v15 = "TMH_10_2_std";
              goto LABEL_26;
            }
            if (a2 == 9568277)
            {
              uint64_t v15 = "TMH_10_2_full";
              goto LABEL_26;
            }
          }
        }
        else if (a2 <= 7143428)
        {
          if (a2 > 6684673)
          {
            if (a2 <= 6881281)
            {
              switch(a2)
              {
                case 6684674:
                  uint64_t v15 = "StereoHeadphones";
                  goto LABEL_26;
                case 6750210:
                  uint64_t v15 = "MatrixStereo";
                  goto LABEL_26;
                case 6815746:
                  uint64_t v15 = "MidSide";
                  goto LABEL_26;
              }
            }
            else if (a2 > 7012355)
            {
              if (a2 == 7012356)
              {
                uint64_t v15 = "Ambisonic_B_Format";
                goto LABEL_26;
              }
              if (a2 == 7077892)
              {
                uint64_t v15 = "Quadraphonic";
                goto LABEL_26;
              }
            }
            else
            {
              if (a2 == 6881282)
              {
                uint64_t v15 = "XY";
                goto LABEL_26;
              }
              if (a2 == 6946818)
              {
                uint64_t v15 = "Binaural";
                goto LABEL_26;
              }
            }
          }
          else if (a2 < 0)
          {
            if (a2 == -268435456)
            {
              uint64_t v15 = "BeginReserved";
              goto LABEL_26;
            }
            if (a2 == -65537)
            {
              uint64_t v15 = "EndReserved";
              goto LABEL_26;
            }
          }
          else if (a2 > 6553600)
          {
            if (a2 == 6553601)
            {
              uint64_t v15 = "Mono";
              goto LABEL_26;
            }
            if (a2 == 6619138)
            {
              uint64_t v15 = "Stereo";
              goto LABEL_26;
            }
          }
          else
          {
            if (!a2)
            {
              uint64_t v15 = "UseChannelDescriptions";
              goto LABEL_26;
            }
            if (a2 == 0x10000)
            {
              uint64_t v15 = "UseChannelBitmap";
              goto LABEL_26;
            }
          }
        }
        else if (a2 <= 7602179)
        {
          if (a2 <= 7340039)
          {
            switch(a2)
            {
              case 7143429:
                uint64_t v15 = "Pentagonal";
                goto LABEL_26;
              case 7208966:
                uint64_t v15 = "Hexagonal";
                goto LABEL_26;
              case 7274504:
                uint64_t v15 = "Octagonal";
                goto LABEL_26;
            }
          }
          else if (a2 > 7471106)
          {
            if (a2 == 7471107)
            {
              uint64_t v15 = "MPEG_3_0_B";
              goto LABEL_26;
            }
            if (a2 == 7536644)
            {
              uint64_t v15 = "MPEG_4_0_A";
              goto LABEL_26;
            }
          }
          else
          {
            if (a2 == 7340040)
            {
              uint64_t v15 = "Cube";
              goto LABEL_26;
            }
            if (a2 == 7405571)
            {
              uint64_t v15 = "MPEG_3_0_A";
              goto LABEL_26;
            }
          }
        }
        else if (a2 > 7864324)
        {
          if (a2 > 7995397)
          {
            if (a2 == 7995398)
            {
              uint64_t v15 = "MPEG_5_1_B";
              goto LABEL_26;
            }
            if (a2 == 8060934)
            {
              uint64_t v15 = "MPEG_5_1_C";
              goto LABEL_26;
            }
          }
          else
          {
            if (a2 == 7864325)
            {
              uint64_t v15 = "MPEG_5_0_D";
              goto LABEL_26;
            }
            if (a2 == 7929862)
            {
              uint64_t v15 = "MPEG_5_1_A";
              goto LABEL_26;
            }
          }
        }
        else if (a2 > 7733252)
        {
          if (a2 == 7733253)
          {
            uint64_t v15 = "MPEG_5_0_B";
            goto LABEL_26;
          }
          if (a2 == 7798789)
          {
            uint64_t v15 = "MPEG_5_0_C";
            goto LABEL_26;
          }
        }
        else
        {
          if (a2 == 7602180)
          {
            uint64_t v15 = "MPEG_4_0_B";
            goto LABEL_26;
          }
          if (a2 == 7667717)
          {
            uint64_t v15 = "MPEG_5_0_A";
            goto LABEL_26;
          }
        }
      }
      else if (a2 <= 11927558)
      {
        if (a2 <= 10944519)
        {
          if (a2 > 10485767)
          {
            if (a2 <= 10682375)
            {
              switch(a2)
              {
                case 10485768:
                  uint64_t v15 = "EAC3_7_1_A";
                  goto LABEL_26;
                case 10551304:
                  uint64_t v15 = "EAC3_7_1_B";
                  goto LABEL_26;
                case 10616840:
                  uint64_t v15 = "EAC3_7_1_C";
                  goto LABEL_26;
              }
            }
            else if (a2 > 10813447)
            {
              if (a2 == 10813448)
              {
                uint64_t v15 = "EAC3_7_1_F";
                goto LABEL_26;
              }
              if (a2 == 10878984)
              {
                uint64_t v15 = "EAC3_7_1_G";
                goto LABEL_26;
              }
            }
            else
            {
              if (a2 == 10682376)
              {
                uint64_t v15 = "EAC3_7_1_D";
                goto LABEL_26;
              }
              if (a2 == 10747912)
              {
                uint64_t v15 = "EAC3_7_1_E";
                goto LABEL_26;
              }
            }
          }
          else if (a2 <= 10223622)
          {
            switch(a2)
            {
              case 10027012:
                uint64_t v15 = "AC3_2_1_1";
                goto LABEL_26;
              case 10092549:
                uint64_t v15 = "AC3_3_1_1";
                goto LABEL_26;
              case 10158086:
                uint64_t v15 = "EAC_6_0_A";
                goto LABEL_26;
            }
          }
          else if (a2 > 10354694)
          {
            if (a2 == 10354695)
            {
              uint64_t v15 = "EAC3_6_1_B";
              goto LABEL_26;
            }
            if (a2 == 10420231)
            {
              uint64_t v15 = "EAC3_6_1_C";
              goto LABEL_26;
            }
          }
          else
          {
            if (a2 == 10223623)
            {
              uint64_t v15 = "EAC_7_0_A";
              goto LABEL_26;
            }
            if (a2 == 10289159)
            {
              uint64_t v15 = "EAC3_6_1_A";
              goto LABEL_26;
            }
          }
        }
        else if (a2 <= 11403270)
        {
          if (a2 <= 11141125)
          {
            switch(a2)
            {
              case 10944520:
                uint64_t v15 = "EAC3_7_1_H";
                goto LABEL_26;
              case 11010052:
                uint64_t v15 = "DTS_3_1";
                goto LABEL_26;
              case 11075589:
                uint64_t v15 = "DTS_4_1";
                goto LABEL_26;
            }
          }
          else if (a2 > 11272197)
          {
            if (a2 == 11272198)
            {
              uint64_t v15 = "DTS_6_0_C";
              goto LABEL_26;
            }
            if (a2 == 11337735)
            {
              uint64_t v15 = "DTS_6_1_A";
              goto LABEL_26;
            }
          }
          else
          {
            if (a2 == 11141126)
            {
              uint64_t v15 = "DTS_6_0_A";
              goto LABEL_26;
            }
            if (a2 == 11206662)
            {
              uint64_t v15 = "DTS_6_0_B";
              goto LABEL_26;
            }
          }
        }
        else if (a2 > 11665415)
        {
          if (a2 > 11796488)
          {
            if (a2 == 11796489)
            {
              uint64_t v15 = "DTS_8_1_A";
              goto LABEL_26;
            }
            if (a2 == 11862025)
            {
              uint64_t v15 = "DTS_8_1_B";
              goto LABEL_26;
            }
          }
          else
          {
            if (a2 == 11665416)
            {
              uint64_t v15 = "DTS_8_0_A";
              goto LABEL_26;
            }
            if (a2 == 11730952)
            {
              uint64_t v15 = "DTS_8_0_B";
              goto LABEL_26;
            }
          }
        }
        else if (a2 > 11534342)
        {
          if (a2 == 11534343)
          {
            uint64_t v15 = "DTS_7_0";
            goto LABEL_26;
          }
          if (a2 == 11599880)
          {
            uint64_t v15 = "DTS_7_1";
            goto LABEL_26;
          }
        }
        else
        {
          if (a2 == 11403271)
          {
            uint64_t v15 = "DTS_6_1_B";
            goto LABEL_26;
          }
          if (a2 == 11468807)
          {
            uint64_t v15 = "DTS_6_1_C";
            goto LABEL_26;
          }
        }
      }
      else if (a2 > 12910595)
      {
        if (a2 <= 13369367)
        {
          if (a2 <= 13107206)
          {
            switch(a2)
            {
              case 12910596:
                uint64_t v15 = "Logic_4_0_C";
                goto LABEL_26;
              case 12976134:
                uint64_t v15 = "Logic_6_0_B";
                goto LABEL_26;
              case 13041671:
                uint64_t v15 = "Logic_6_1_B";
                goto LABEL_26;
            }
          }
          else if (a2 > 13238283)
          {
            if (a2 == 13238284)
            {
              uint64_t v15 = "Logic_Atmos_7_1_4_B";
              goto LABEL_26;
            }
            if (a2 == 13303822)
            {
              uint64_t v15 = "Logic_Atmos_7_1_6";
              goto LABEL_26;
            }
          }
          else
          {
            if (a2 == 13107207)
            {
              uint64_t v15 = "Logic_6_1_D";
              goto LABEL_26;
            }
            if (a2 == 13172744)
            {
              uint64_t v15 = "Logic_7_1_B";
              goto LABEL_26;
            }
          }
        }
        else if (a2 > 13631499)
        {
          if (a2 > 13762571)
          {
            if (a2 == 13762572)
            {
              uint64_t v15 = "CICP_19";
              goto LABEL_26;
            }
            if (a2 == 13828110)
            {
              uint64_t v15 = "CICP_20";
              goto LABEL_26;
            }
          }
          else
          {
            if (a2 == 13631500)
            {
              uint64_t v15 = "CICP_17";
              goto LABEL_26;
            }
            if (a2 == 13697038)
            {
              uint64_t v15 = "CICP_18";
              goto LABEL_26;
            }
          }
        }
        else if (a2 > 13500427)
        {
          if (a2 == 13500428)
          {
            uint64_t v15 = "CICP_15";
            goto LABEL_26;
          }
          if (a2 == 13565962)
          {
            uint64_t v15 = "CICP_16";
            goto LABEL_26;
          }
        }
        else
        {
          if (a2 == 13369368)
          {
            uint64_t v15 = "CICP_13";
            goto LABEL_26;
          }
          if (a2 == 13434888)
          {
            uint64_t v15 = "CICP_14";
            goto LABEL_26;
          }
        }
      }
      else if (a2 <= 12386311)
      {
        if (a2 <= 12124163)
        {
          switch(a2)
          {
            case 11927559:
              uint64_t v15 = "DTS_6_1_D";
              goto LABEL_26;
            case 11993096:
              uint64_t v15 = "AAC_7_1_B";
              goto LABEL_26;
            case 12058632:
              uint64_t v15 = "AAC_7_1_C";
              goto LABEL_26;
          }
        }
        else if (a2 > 12255237)
        {
          if (a2 == 12255238)
          {
            uint64_t v15 = "WAVE_5_1_B";
            goto LABEL_26;
          }
          if (a2 == 12320775)
          {
            uint64_t v15 = "WAVE_6_1";
            goto LABEL_26;
          }
        }
        else
        {
          if (a2 == 12124164)
          {
            uint64_t v15 = "WAVE_4_0_B";
            goto LABEL_26;
          }
          if (a2 == 12189701)
          {
            uint64_t v15 = "WAVE_5_0_B";
            goto LABEL_26;
          }
        }
      }
      else if (a2 > 12648463)
      {
        if (a2 > 12779529)
        {
          if (a2 == 12779530)
          {
            uint64_t v15 = "Atmos_5_1_4";
            goto LABEL_26;
          }
          if (a2 == 12845066)
          {
            uint64_t v15 = "Atmos_7_1_2";
            goto LABEL_26;
          }
        }
        else
        {
          if (a2 == 12648464)
          {
            uint64_t v15 = "Atmos_9_1_6";
            goto LABEL_26;
          }
          if (a2 == 12713992)
          {
            uint64_t v15 = "Atmos_5_1_2";
            goto LABEL_26;
          }
        }
      }
      else if (a2 >= 12517376)
      {
        if (a2 == 12517376)
        {
          uint64_t v15 = "HOA_ACN_N3D";
          goto LABEL_26;
        }
        if (a2 == 12582924)
        {
          uint64_t v15 = "Atmos_7_1_4";
          goto LABEL_26;
        }
      }
      else
      {
        if (a2 == 12386312)
        {
          uint64_t v15 = "WAVE_7_1";
          goto LABEL_26;
        }
        if (a2 == 12451840)
        {
          uint64_t v15 = "HOA_ACN_SN3D";
          goto LABEL_26;
        }
      }
LABEL_25:
      uint64_t v15 = "Unknown";
LABEL_26:
      std::string::basic_string[abi:ne180100]<0>(a1, v15);
      return;
    }
    int v5 = llroundf(sqrtf((float)(unsigned __int16)a2));
    if (v5) {
      BOOL v6 = v5 * v5 == (unsigned __int16)a2;
    }
    else {
      BOOL v6 = 0;
    }
    if (!v6) {
      goto LABEL_25;
    }
    std::string::basic_string[abi:ne180100]<0>(&v21, "HOA_ACN_SN3D");
    double v7 = std::string::append(&v21, " ", 1uLL);
    long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
    v22.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v22.__r_.__value_.__l.__data_ = v8;
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    v7->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&__p, v5 - 1);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
  }
  __int32 v18 = std::string::append(&v22, (const std::string::value_type *)p_p, size);
  long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
  a1[2] = *((void *)&v18->__r_.__value_.__l + 2);
  *(_OWORD *)a1 = v19;
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v22.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v21.__r_.__value_.__l.__data_);
  }
}

void sub_1BB35F028(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void PrintAudioChannelLayout(std::string *a1, int *a2)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  GetStringFromAudioChannelLayoutTag(a1, *a2);
  if (*a2 == 0x10000)
  {
    unint64_t v24 = a2[1];
    uint64_t v40 = 6;
    long long v39 = v24;
    memset(&v32, 0, sizeof(v32));
    v33[0] = (void *)1;
    v33[1] = &v39;
    uint64_t v34 = 6;
    std::__vformat_to[abi:ne180100]<std::back_insert_iterator<std::string>,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>((uint64_t)&v32, "bitmap={:08X}", 13, (uint64_t *)v33);
    if ((v32.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v25 = &v32;
    }
    else {
      uint64_t v25 = (std::string *)v32.__r_.__value_.__r.__words[0];
    }
    if ((v32.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v32.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v32.__r_.__value_.__l.__size_;
    }
    std::string::append(a1, (const std::string::value_type *)v25, size);
    if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v32.__r_.__value_.__l.__data_);
    }
  }
  else if (!*a2 && a2[2])
  {
    unint64_t v4 = 0;
    int v5 = a2 + 7;
    do
    {
      std::to_string(&v30, v4);
      BOOL v6 = std::string::insert(&v30, 0, "\n", 1uLL);
      long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
      v31.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v7;
      v6->__r_.__value_.__l.__size_ = 0;
      v6->__r_.__value_.__r.__words[2] = 0;
      v6->__r_.__value_.__r.__words[0] = 0;
      long long v8 = std::string::append(&v31, ": ", 2uLL);
      long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
      v32.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v32.__r_.__value_.__l.__data_ = v9;
      v8->__r_.__value_.__l.__size_ = 0;
      v8->__r_.__value_.__r.__words[2] = 0;
      v8->__r_.__value_.__r.__words[0] = 0;
      int v10 = *(v5 - 4);
      std::string::basic_string[abi:ne180100]<0>(__p, "");
      if (v10 == 100)
      {
        if (SHIBYTE(v29) < 0)
        {
          __p[1] = (void *)14;
          uint64_t v11 = (char *)__p[0];
        }
        else
        {
          HIBYTE(v29) = 14;
          uint64_t v11 = (char *)__p;
        }
        strcpy(v11, "UseCoordinates");
      }
      else
      {
        inSpecifier[0] = v10;
        CFTypeRef outPropertyData = 0;
        UInt32 ioPropertyDataSize = 8;
        if (!AudioFormatGetProperty(0x63736E6Du, 0x14u, inSpecifier, &ioPropertyDataSize, &outPropertyData)
          && ioPropertyDataSize)
        {
          CFTypeRef v12 = outPropertyData;
          if (outPropertyData) {
            CFRetain(outPropertyData);
          }
          applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cf, v12);
          if (!cf)
          {
            exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(exception, "Could not construct");
          }
          applesauce::CF::convert_to<std::string,0>((const __CFString *)cf, (uint64_t)&v39);
          if (SHIBYTE(v29) < 0) {
            operator delete(__p[0]);
          }
          *(_OWORD *)std::string __p = v39;
          uint64_t v29 = v40;
          HIBYTE(v40) = 0;
          LOBYTE(v39) = 0;
          if (cf) {
            CFRelease(cf);
          }
          CFRelease(outPropertyData);
        }
      }
      if (v29 >= 0) {
        int v13 = __p;
      }
      else {
        int v13 = (void **)__p[0];
      }
      if (v29 >= 0) {
        std::string::size_type v14 = HIBYTE(v29);
      }
      else {
        std::string::size_type v14 = (std::string::size_type)__p[1];
      }
      uint64_t v15 = std::string::append(&v32, (const std::string::value_type *)v13, v14);
      long long v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
      uint64_t v34 = v15->__r_.__value_.__r.__words[2];
      *(_OWORD *)uint64_t v33 = v16;
      v15->__r_.__value_.__l.__size_ = 0;
      v15->__r_.__value_.__r.__words[2] = 0;
      v15->__r_.__value_.__r.__words[0] = 0;
      if (v34 >= 0) {
        long long v17 = v33;
      }
      else {
        long long v17 = (void **)v33[0];
      }
      if (v34 >= 0) {
        std::string::size_type v18 = HIBYTE(v34);
      }
      else {
        std::string::size_type v18 = (std::string::size_type)v33[1];
      }
      std::string::append(a1, (const std::string::value_type *)v17, v18);
      if (SHIBYTE(v34) < 0) {
        operator delete(v33[0]);
      }
      if (SHIBYTE(v29) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v32.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v31.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
      int v19 = *(v5 - 2);
      long long v39 = *(v5 - 3);
      int v20 = *(v5 - 1);
      LODWORD(v40) = v19;
      int v41 = v20;
      int v21 = *v5;
      uint64_t v43 = 304422;
      int v42 = v21;
      memset(&v32, 0, sizeof(v32));
      v33[0] = (void *)4;
      v33[1] = &v39;
      uint64_t v34 = 304422;
      std::__vformat_to[abi:ne180100]<std::back_insert_iterator<std::string>,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>((uint64_t)&v32, ", flags={:08X}, coords=[{:.1f}, {:.1f}, {:.1f}]", 47, (uint64_t *)v33);
      if ((v32.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string v22 = &v32;
      }
      else {
        std::string v22 = (std::string *)v32.__r_.__value_.__r.__words[0];
      }
      if ((v32.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v23 = HIBYTE(v32.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v23 = v32.__r_.__value_.__l.__size_;
      }
      std::string::append(a1, (const std::string::value_type *)v22, v23);
      if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v32.__r_.__value_.__l.__data_);
      }
      ++v4;
      v5 += 5;
    }
    while (v4 < a2[2]);
  }
}

void sub_1BB35F49C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,char a42)
{
  if (a33 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v42 + 23) < 0) {
    operator delete(*(void **)v42);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__vformat_to[abi:ne180100]<std::back_insert_iterator<std::string>,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(uint64_t a1, char *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  unint64_t v24 = v23;
  long long v25 = xmmword_1BB879CB0;
  unsigned int v26 = std::__format::__output_buffer<char>::__output_buffer[abi:ne180100]<std::__format::__format_buffer<std::back_insert_iterator<std::string>,char>>(char *,unsigned long,std::__format::__format_buffer<std::back_insert_iterator<std::string>,char> *)::{lambda(char *,unsigned long,void *)#1}::__invoke;
  uint64_t v27 = v23;
  uint64_t v28 = a1;
  uint64_t v4 = *a4;
  int v5 = &a2[a3];
  v18[0] = a2;
  v18[1] = &a2[a3];
  int v19 = 0;
  uint64_t v20 = 0;
  uint64_t v21 = v4;
  long long v14 = *(_OWORD *)a4;
  uint64_t v15 = a4[2];
  LOBYTE(v11.__locale_) = 0;
  char v12 = 0;
  int v13 = (uint64_t *)&v24;
  LOBYTE(v16.__locale_) = 0;
  char v17 = 0;
  if (!a3) {
    return ((uint64_t (*)(unsigned char *, void, unsigned char *))v26)(v24, *((void *)&v25 + 1), v27);
  }
  BOOL v6 = a2;
  long long v7 = "The format string terminates at a '{'";
  do
  {
    long long v8 = v13;
    while (1)
    {
      int v9 = *v6;
      if (v9 == 125)
      {
        if (++v6 == v5 || *v6 != 125)
        {
          long long v7 = "The format string contains an invalid escape sequence";
LABEL_18:
          std::__throw_format_error[abi:ne180100](v7);
        }
        goto LABEL_11;
      }
      if (v9 == 123)
      {
        if (++v6 == v5) {
          goto LABEL_18;
        }
        if (*v6 != 123) {
          break;
        }
      }
LABEL_11:
      std::string v22 = v8;
      std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100](&v22, *v6++);
      if (v6 == v5) {
        goto LABEL_14;
      }
    }
    int v13 = v8;
    BOOL v6 = std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(v6, v5, v18, &v13);
  }
  while (v6 != v5);
LABEL_14:
  if (v17) {
    std::locale::~locale(&v16);
  }
  return ((uint64_t (*)(unsigned char *, void, unsigned char *))v26)(v24, *((void *)&v25 + 1), v27);
}

void sub_1BB35F74C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
}

void std::__throw_format_error[abi:ne180100](const char *a1)
{
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::format_error::format_error[abi:ne180100](exception, a1);
}

void sub_1BB35F7D0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

char *std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char *a1, char *a2, char **a3, void **a4)
{
  v303[128] = *MEMORY[0x1E4F143B8];
  long long v7 = std::__format::__parse_arg_id[abi:ne180100]<char const*,std::basic_format_parse_context<char>>(a1, a2, (uint64_t)a3);
  if (v7 == a2) {
    goto LABEL_509;
  }
  int v9 = *v7;
  if (v9 != 125)
  {
    if (v9 == 58)
    {
      ++v7;
      goto LABEL_5;
    }
LABEL_509:
    std::__throw_format_error[abi:ne180100]("The argument index should end with a ':' or a '}'");
  }
LABEL_5:
  *a3 = v7;
  unint64_t v10 = (unint64_t)a4[1];
  if (v10 <= v8) {
LABEL_510:
  }
    std::__throw_format_error[abi:ne180100]("The argument index value is too large for the number of arguments supplied");
  if (v10 > 0xC)
  {
    uint64_t v11 = (uint64_t)&a4[2][4 * v8];
    uint64_t v13 = *(unsigned int *)(v11 + 4);
    int64_t v14 = *(void *)(v11 + 8);
    unsigned int v15 = *(_DWORD *)v11;
    unsigned int v16 = *(_DWORD *)v11 >> 8;
    LODWORD(v11) = *(unsigned __int8 *)(v11 + 16);
  }
  else
  {
    uint64_t v11 = ((unint64_t)a4[3] >> (5 * v8)) & 0x1F;
    uint64_t v12 = (uint64_t)&a4[2][2 * v8];
    uint64_t v13 = *(unsigned int *)(v12 + 4);
    int64_t v14 = *(void *)(v12 + 8);
    unsigned int v15 = *(_DWORD *)v12;
    unsigned int v16 = *(_DWORD *)v12 >> 8;
  }
  switch((int)v11)
  {
    case 1:
      v297 = 0;
      unint64_t v298 = 0x20FFFFFFFFLL;
      if (v9 != 58) {
        goto LABEL_210;
      }
      char v17 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>((uint64_t)&v297, a3, 55);
      std::string::size_type v18 = v17;
      if (BYTE1(v297) - 2 < 6)
      {
        *a3 = (char *)v17;
        unint64_t v19 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v297, a4);
        uint64_t v21 = std::__formatter::__format_integer[abi:ne180100]<unsigned int,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(v15, a4, v19, v20, 0);
        goto LABEL_98;
      }
      if (BYTE1(v297) > 1u) {
        std::__format_spec::__throw_invalid_type_format_error[abi:ne180100]("a BOOL");
      }
      std::__format_spec::__parser<char>::__validate[abi:ne180100]((uint64_t)&v297, "a BOOL");
      if ((v297 & 7) == 0) {
        LOBYTE(v297) = v297 & 0xF8 | 1;
      }
      *a3 = (char *)v18;
LABEL_210:
      unint64_t v132 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v297, a4);
      unint64_t v134 = v133;
      if ((v132 & 0x40) != 0)
      {
        std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>::locale[abi:ne180100]((std::locale *)&v301, (uint64_t)a4);
        float v138 = std::locale::use_facet((const std::locale *)&v301, MEMORY[0x1E4FBA2A0]);
        std::locale::~locale((std::locale *)&v301);
        v139 = v138->__vftable;
        if (v15) {
          ((void (*)(long long *__return_ptr, const std::locale::facet *))v139[2].~facet)(&v301, v138);
        }
        else {
          ((void (*)(long long *__return_ptr, const std::locale::facet *))v139[2].~facet_0)(&v301, v138);
        }
        if (SHIBYTE(v302) >= 0) {
          uint64_t v140 = (char *)&v301;
        }
        else {
          uint64_t v140 = (char *)v301;
        }
        if (SHIBYTE(v302) >= 0) {
          size_t v141 = HIBYTE(v302);
        }
        else {
          size_t v141 = *((void *)&v301 + 1);
        }
        float v72 = std::__formatter::__write_string_no_precision[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v140, v141, *a4, v132, v134);
        if (SHIBYTE(v302) < 0)
        {
          v142 = (void *)v301;
          goto LABEL_450;
        }
      }
      else
      {
        BOOL v135 = v15 == 0;
        if (v15) {
          size_t v136 = 4;
        }
        else {
          size_t v136 = 5;
        }
        float v72 = *a4;
        if (v135) {
          signed int v137 = "false";
        }
        else {
          signed int v137 = "true";
        }
        std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v137, v136, *a4, v132, v134, v136);
      }
      goto LABEL_451;
    case 2:
      *(void *)&long long v301 = 0;
      DWORD2(v301) = -1;
      BYTE12(v301) = 32;
      *(_WORD *)((char *)&v301 + 13) = 0;
      HIBYTE(v301) = 0;
      if (v9 != 58) {
        goto LABEL_49;
      }
      uint64_t v46 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>((uint64_t)&v301, a3, 55);
      int v47 = BYTE1(v301);
      if (BYTE1(v301) - 2 >= 6)
      {
        if (BYTE1(v301) > 0x13u || ((1 << SBYTE1(v301)) & 0x80401) == 0) {
          std::__format_spec::__throw_invalid_type_format_error[abi:ne180100]("a character");
        }
        std::__format_spec::__parser<char>::__validate[abi:ne180100]((uint64_t)&v301, "a character");
        if ((v301 & 7) == 0) {
          LOBYTE(v301) = v301 & 0xF8 | 1;
        }
      }
      *a3 = (char *)v46;
      if (v47 == 10 || !v47)
      {
LABEL_49:
        uint64_t v37 = *a4;
        unint64_t v48 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v301, a4);
        LOBYTE(v297) = v15;
        std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>((char *)&v297, 1uLL, v37, v48, v49, 1);
        goto LABEL_205;
      }
      unint64_t v85 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v301, a4);
      unint64_t v86 = v131;
      unsigned int v55 = v15;
      float v84 = a4;
      goto LABEL_202;
    case 3:
      *(void *)&long long v301 = 0;
      DWORD2(v301) = -1;
      BYTE12(v301) = 32;
      *(_WORD *)((char *)&v301 + 13) = 0;
      HIBYTE(v301) = 0;
      if (v9 == 58)
      {
        uint64_t v50 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>((uint64_t)&v301, a3, 55);
        std::__format_spec::__process_parsed_integer[abi:ne180100]<char>((uint64_t)&v301);
        *a3 = (char *)v50;
      }
      unint64_t v33 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v301, a4);
      unint64_t v35 = v51;
      int v52 = v15 | (v16 << 8);
      if ((v33 & 0xFF00) == 0xA00)
      {
        if ((v15 | (v16 << 8)) == (char)v15) {
          goto LABEL_26;
        }
LABEL_511:
        std::__throw_format_error[abi:ne180100]("Integral value outside the range of the char type");
      }
      if (v52 >= 0) {
        unsigned int v55 = v15 | (v16 << 8);
      }
      else {
        unsigned int v55 = -v52;
      }
      unsigned int v83 = v52 >> 31;
      float v84 = a4;
      unint64_t v85 = v33;
      unint64_t v86 = v35;
      goto LABEL_203;
    case 4:
      *(void *)&long long v301 = 0;
      DWORD2(v301) = -1;
      BYTE12(v301) = 32;
      *(_WORD *)((char *)&v301 + 13) = 0;
      HIBYTE(v301) = 0;
      if (v9 == 58)
      {
        std::string v32 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>((uint64_t)&v301, a3, 55);
        std::__format_spec::__process_parsed_integer[abi:ne180100]<char>((uint64_t)&v301);
        *a3 = (char *)v32;
      }
      unint64_t v33 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v301, a4);
      unint64_t v35 = v34;
      int64_t v36 = (v13 << 32) | ((unint64_t)v16 << 8) | v15;
      if ((v33 & 0xFF00) != 0xA00)
      {
        if (v36 >= 0) {
          unint64_t v61 = (v13 << 32) | ((unint64_t)v16 << 8) | v15;
        }
        else {
          unint64_t v61 = -v36;
        }
        unint64_t v44 = (unint64_t)v36 >> 63;
        uint64_t v77 = a4;
        unint64_t v78 = v33;
        unint64_t v79 = v35;
        goto LABEL_114;
      }
      if (v36 != (char)v36) {
        goto LABEL_511;
      }
LABEL_26:
      uint64_t v37 = *a4;
      LOBYTE(v297) = v15;
      std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>((char *)&v297, 1uLL, v37, v33, v35, 1);
LABEL_205:
      *a4 = v37;
LABEL_452:
      v256 = *a3;
      if (*a3 == a2 || *v256 != 125) {
        std::__throw_format_error[abi:ne180100]("The replacement field misses a terminating '}'");
      }
      return v256 + 1;
    case 5:
      *(void *)&long long v301 = 0;
      DWORD2(v301) = -1;
      BYTE12(v301) = 32;
      *(_WORD *)((char *)&v301 + 13) = 0;
      HIBYTE(v301) = 0;
      if (v9 == 58)
      {
        uint64_t v56 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>((uint64_t)&v301, a3, 55);
        std::__format_spec::__process_parsed_integer[abi:ne180100]<char>((uint64_t)&v301);
        *a3 = (char *)v56;
      }
      unint64_t v42 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v301, a4);
      unint64_t v44 = v57;
      unint64_t v58 = (v13 << 32) | ((unint64_t)v16 << 8) | v15;
      if ((v42 & 0xFF00) == 0xA00)
      {
        if (__PAIR128__(-1, -257) >= __PAIR128__((unint64_t)(v58 >= 0x80) + v14 - 1, v58 - 128)) {
          goto LABEL_511;
        }
LABEL_69:
        uint64_t v37 = *a4;
        LOBYTE(v297) = v15;
        std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>((char *)&v297, 1uLL, v37, v42, v44, 1);
        goto LABEL_205;
      }
      unint64_t v80 = (__PAIR128__(v14 ^ (unint64_t)(v14 >> 63), v58 ^ (v14 >> 63)) - __PAIR128__(v14 >> 63, v14 >> 63)) >> 64;
      uint64_t v45 = (v58 ^ (v14 >> 63)) - (v14 >> 63);
      unint64_t v82 = (unint64_t)v14 >> 63;
      vDSP_Length v81 = a4;
LABEL_112:
      float v87 = std::__formatter::__format_integer[abi:ne180100]<unsigned __int128,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(v45, v80, v81, v42, v44, v82);
      goto LABEL_204;
    case 6:
      *(void *)&long long v301 = 0;
      DWORD2(v301) = -1;
      BYTE12(v301) = 32;
      *(_WORD *)((char *)&v301 + 13) = 0;
      HIBYTE(v301) = 0;
      if (v9 == 58)
      {
        int v53 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>((uint64_t)&v301, a3, 55);
        std::__format_spec::__process_parsed_integer[abi:ne180100]<char>((uint64_t)&v301);
        *a3 = (char *)v53;
      }
      unint64_t v42 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v301, a4);
      unint64_t v44 = v54;
      unsigned int v55 = v15 | (v16 << 8);
      if ((v42 & 0xFF00) == 0xA00)
      {
        if (v55 >= 0x80) {
          goto LABEL_511;
        }
        goto LABEL_69;
      }
      float v84 = a4;
      unint64_t v85 = v42;
      unint64_t v86 = v44;
LABEL_202:
      LOBYTE(v83) = 0;
LABEL_203:
      float v87 = std::__formatter::__format_integer[abi:ne180100]<unsigned int,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(v55, v84, v85, v86, v83);
LABEL_204:
      uint64_t v37 = v87;
      goto LABEL_205;
    case 7:
      *(void *)&long long v301 = 0;
      DWORD2(v301) = -1;
      BYTE12(v301) = 32;
      *(_WORD *)((char *)&v301 + 13) = 0;
      HIBYTE(v301) = 0;
      if (v9 == 58)
      {
        float v59 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>((uint64_t)&v301, a3, 55);
        std::__format_spec::__process_parsed_integer[abi:ne180100]<char>((uint64_t)&v301);
        *a3 = (char *)v59;
      }
      unint64_t v42 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v301, a4);
      unint64_t v44 = v60;
      unint64_t v61 = (v13 << 32) | ((unint64_t)v16 << 8) | v15;
      if ((v42 & 0xFF00) != 0xA00)
      {
        uint64_t v77 = a4;
        unint64_t v78 = v42;
        unint64_t v79 = v44;
        LOBYTE(v44) = 0;
LABEL_114:
        float v87 = std::__formatter::__format_integer[abi:ne180100]<unsigned long long,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(v61, v77, v78, v79, v44);
        goto LABEL_204;
      }
      if (v61 >= 0x80) {
        goto LABEL_511;
      }
      goto LABEL_69;
    case 8:
      *(void *)&long long v301 = 0;
      DWORD2(v301) = -1;
      BYTE12(v301) = 32;
      *(_WORD *)((char *)&v301 + 13) = 0;
      HIBYTE(v301) = 0;
      if (v9 == 58)
      {
        int v41 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>((uint64_t)&v301, a3, 55);
        std::__format_spec::__process_parsed_integer[abi:ne180100]<char>((uint64_t)&v301);
        *a3 = (char *)v41;
      }
      unint64_t v42 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v301, a4);
      unint64_t v44 = v43;
      uint64_t v45 = (v13 << 32) | ((unint64_t)v16 << 8) | v15;
      if ((v42 & 0xFF00) == 0xA00)
      {
        if (__PAIR128__(v14, v45) >= 0x80) {
          goto LABEL_511;
        }
        goto LABEL_69;
      }
      unint64_t v80 = v14;
      vDSP_Length v81 = a4;
      LOBYTE(v82) = 0;
      goto LABEL_112;
    case 9:
      uint64_t v289 = 0;
      int v290 = -1;
      char v291 = 32;
      __int16 v292 = 0;
      char v293 = 0;
      if (v9 != 58) {
        goto LABEL_118;
      }
      uint64_t v38 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>((uint64_t)&v289, a3, 63);
      if (BYTE1(v289) - 13 < 6)
      {
        if (v290 != -1 || SWORD1(v289) <= -1) {
          int v40 = v290;
        }
        else {
          int v40 = 6;
        }
        int v290 = v40;
LABEL_117:
        *a3 = (char *)v38;
LABEL_118:
        unint64_t v89 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v289, a4);
        unint64_t v90 = v88;
        int v91 = v15 | (v16 << 8);
        if ((v91 & 0x7FFFFFFFu) < 0x7F800000)
        {
          if (v91 >= 0) {
            int v92 = v15 | (v16 << 8);
          }
          else {
            *(float *)&int v92 = -*(float *)&v91;
          }
          if (v88 == -1) {
            uint64_t v93 = 149;
          }
          else {
            uint64_t v93 = v88;
          }
          *(void *)&long long v301 = v93;
          if ((int)v93 < 150)
          {
            uint64_t v94 = (int)v93 + 45;
            *((void *)&v301 + 1) = v94;
            if ((v93 + 45) >= 0x101)
            {
              float v95 = operator new((int)v93 + 45);
              goto LABEL_130;
            }
          }
          else
          {
            LODWORD(v301) = 149;
            DWORD1(v301) = v93 - 149;
            uint64_t v94 = 194;
            *((void *)&v301 + 1) = 194;
            uint64_t v93 = 149;
          }
          float v95 = v303;
LABEL_130:
          char v96 = v89;
          int v97 = BYTE1(v89);
          v302 = v95;
          if (v91 < 0)
          {
            char v100 = 45;
          }
          else
          {
            int v98 = (v89 >> 3) & 3;
            if (v98 == 2)
            {
              char v100 = 43;
            }
            else
            {
              int v99 = (uint64_t *)v95;
              if (v98 != 3) {
                goto LABEL_137;
              }
              char v100 = 32;
            }
          }
          unsigned char *v95 = v100;
          int v99 = (uint64_t *)(v95 + 1);
LABEL_137:
          int64_t __len = v89;
          switch(BYTE1(v89))
          {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 0xA:
              goto LABEL_508;
            case 0xB:
              if ((v90 & 0x80000000) != 0) {
                int v143 = -1;
              }
              else {
                int v143 = v93;
              }
              std::__formatter::__format_buffer_hexadecimal_lower_case[abi:ne180100]<float,float>(&v297, v94, (uint64_t)v95, v143, (uint64_t)v99);
              goto LABEL_249;
            case 0xC:
              if ((v90 & 0x80000000) != 0) {
                int v146 = -1;
              }
              else {
                int v146 = v93;
              }
              std::__formatter::__format_buffer_hexadecimal_lower_case[abi:ne180100]<float,float>(&v297, v94, (uint64_t)v95, v146, (uint64_t)v99);
              uint64_t v144 = v297;
              BOOL v147 = (uint64_t *)__src;
              if (v297 != __src)
              {
                do
                {
                  int v148 = *(char *)v144;
                  if ((v148 - 97) < 6) {
                    LOBYTE(v148) = v148 - 32;
                  }
                  *(unsigned char *)uint64_t v144 = v148;
                  uint64_t v144 = (uint64_t *)((char *)v144 + 1);
                }
                while (v144 != v147);
                uint64_t v144 = v147;
              }
              char v145 = 80;
              goto LABEL_247;
            case 0xD:
              std::__formatter::__format_buffer_scientific_lower_case[abi:ne180100]<float,float>(&v297, v94, (uint64_t)v95, v93, (uint64_t)v99);
              goto LABEL_249;
            case 0xE:
              std::__formatter::__format_buffer_scientific_lower_case[abi:ne180100]<float,float>(&v297, v94, (uint64_t)v95, v93, (uint64_t)v99);
              uint64_t v144 = (uint64_t *)__src;
              goto LABEL_237;
            case 0xF:
            case 0x10:
              v297 = v99;
              float v101 = (char *)MEMORY[0x1C185D200](v99, &v95[v94], 2, v93, *(float *)&v92);
              __src = v101;
              *(void *)v300 = v101;
              if (v93) {
                int v102 = v93 + 1;
              }
              else {
                int v102 = 0;
              }
              uint64_t v103 = &v101[-v102];
              goto LABEL_142;
            case 0x11:
              goto LABEL_230;
            case 0x12:
              std::__formatter::__format_buffer_general_lower_case[abi:ne180100]<float,float>(&v297, (uint64_t)&v301, v93, (uint64_t)v99);
              uint64_t v144 = (uint64_t *)__src;
              if (__src != *(void **)v300)
              {
LABEL_237:
                char v145 = 69;
LABEL_247:
                *(unsigned char *)uint64_t v144 = v145;
              }
              goto LABEL_249;
            default:
              if ((v90 & 0x80000000) == 0)
              {
LABEL_230:
                std::__formatter::__format_buffer_general_lower_case[abi:ne180100]<float,float>(&v297, (uint64_t)&v301, v93, (uint64_t)v99);
                goto LABEL_249;
              }
              v297 = v99;
              uint64_t v260 = std::to_chars((std::__1 *)v99, &v95[v94], v95, *(float *)&v92);
              uint64_t v261 = v260;
              *(void *)v300 = v260;
              unint64_t v262 = v260 - (void)v99;
              v263 = (char *)v260;
              if (v260 - (uint64_t)v99 < 4) {
                goto LABEL_484;
              }
              if (v262 >= 6) {
                unint64_t v262 = 6;
              }
              uint64_t v264 = -(uint64_t)v262;
              break;
          }
          while (*(unsigned char *)(v260 + v264) != 101)
          {
            if (++v264 == -3)
            {
              v263 = (char *)v260;
              goto LABEL_484;
            }
          }
          v263 = (char *)(v260 + v264);
LABEL_484:
          __src = v263;
          v275 = (char *)memchr((char *)v99 + 1, 46, v263 - ((char *)v99 + 1));
          if (v275) {
            uint64_t v103 = v275;
          }
          else {
            uint64_t v103 = v263;
          }
          if (v103 == v263) {
            uint64_t v103 = (char *)v261;
          }
LABEL_142:
          unint64_t v298 = (unint64_t)v103;
LABEL_249:
          if ((v96 & 0x20) != 0)
          {
            uint64_t v149 = (unsigned char *)v298;
            float v150 = *(void **)v300;
            if (v298 == *(void *)v300)
            {
              *(unsigned char *)unint64_t v298 = 46;
              float v150 = v149 + 1;
              *(void *)v300 = v149 + 1;
              unint64_t v151 = (unint64_t)__src;
              if (__src != v149)
              {
                if ((char *)__src + 1 == v149)
                {
                  char v170 = *(unsigned char *)__src;
                  *(unsigned char *)__src = 46;
                  *uint64_t v149 = v170;
                }
                else
                {
                  memmove((char *)__src + 1, __src, v149 - (unsigned char *)__src);
                  *(unsigned char *)unint64_t v151 = 46;
                }
              }
              unint64_t v298 = v151;
              __src = (void *)(v151 + 1);
            }
            else
            {
              unint64_t v151 = v298;
            }
            if ((v97 - 17) <= 1)
            {
              if (v90 <= 1) {
                int v171 = 1;
              }
              else {
                int v171 = v90;
              }
              if ((v90 & 0x80000000) != 0) {
                int v171 = 6;
              }
              int v172 = v297 - v151;
              if (__src != v150) {
                int v172 = -1;
              }
              int v173 = v172 + v171;
              v174 = (char *)__src + ~v151;
              if ((uint64_t)v174 < v173) {
                DWORD1(v301) += v173 - v174;
              }
            }
          }
          if ((v96 & 0x40) == 0)
          {
            char v175 = v96;
            uint64_t v176 = *(void *)v300;
            char v177 = (char *)v302;
            uint64_t v178 = *(void *)v300 - (void)v302;
            size_t v179 = SDWORD1(v301);
            if (*(void *)v300 - (void)v302 + SDWORD1(v301) >= __len >> 32)
            {
              if (!DWORD1(v301) || (float v191 = (char *)__src, __src == *(void **)v300))
              {
                float v72 = *a4;
                std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(*a4, (char *)v302, *(void *)v300 - (void)v302);
                std::__format::__output_buffer<char>::__fill[abi:ne180100](v72, v179, 48);
              }
              else
              {
                float v72 = *a4;
                std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(*a4, (char *)v302, (unsigned char *)__src - (unsigned char *)v302);
                std::__format::__output_buffer<char>::__fill[abi:ne180100](v72, v179, 48);
                std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v72, v191, v176 - (void)v191);
              }
            }
            else
            {
              float v72 = *a4;
              if ((v175 & 7) == 4)
              {
                if (v302 != v297)
                {
                  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)*a4;
                  std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100]((uint64_t **)&__p, *(unsigned char *)v302);
                  ++v177;
                }
                unsigned __int8 v180 = __len & 0xF8 | 3;
                unsigned __int8 v181 = 48;
              }
              else
              {
                unsigned __int8 v180 = __len;
                unsigned __int8 v181 = BYTE4(v90);
              }
              unint64_t v200 = __len & 0xFFFFFFFFFFFFFF00 | v180;
              unint64_t v201 = v90 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)v181 << 32);
              if (v179) {
                std::__formatter::__write_using_trailing_zeros[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v177, v176, v72, v200, v201, v178, (char *)__src, v179);
              }
              else {
                std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v177, v176 - (void)v177, v72, v200, v201, v178);
              }
            }
            goto LABEL_399;
          }
          float v72 = *a4;
          std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>::locale[abi:ne180100](&v294, (uint64_t)a4);
          v182 = std::locale::use_facet(&v294, MEMORY[0x1E4FBA2A0]);
          ((void (*)(std::string *__return_ptr))v182->__vftable[1].__on_zero_shared)(&__p);
          unsigned int v183 = __src;
          v184 = v297;
          unint64_t v284 = v298;
          v285 = (char *)__src;
          if ((unint64_t)__src >= v298) {
            unsigned int v183 = (unsigned char *)v298;
          }
          int64_t v185 = v183 - (unsigned char *)v297;
          v286 = v182;
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          {
            std::string::size_type size = __p.__r_.__value_.__l.__size_;
            if (!__p.__r_.__value_.__l.__size_) {
              goto LABEL_361;
            }
            p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
            int64_t v188 = *__p.__r_.__value_.__l.__data_;
            if (v185 <= v188)
            {
              *__p.__r_.__value_.__l.__data_ = 0;
              __p.__r_.__value_.__l.__size_ = 0;
              goto LABEL_361;
            }
            char v282 = v96;
            std::string::value_type v190 = *__p.__r_.__value_.__l.__data_;
            std::string::size_type v187 = __p.__r_.__value_.__r.__words[0];
          }
          else
          {
            if (!*((unsigned char *)&__p.__r_.__value_.__s + 23)) {
              goto LABEL_361;
            }
            if (v185 <= __p.__r_.__value_.__s.__data_[0])
            {
              __p.__r_.__value_.__s.__data_[0] = 0;
              *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
              goto LABEL_361;
            }
            char v282 = v96;
            std::string::size_type size = __p.__r_.__value_.__l.__size_;
            std::string::size_type v187 = __p.__r_.__value_.__r.__words[0];
            int64_t v188 = __p.__r_.__value_.__s.__data_[0];
            p_p = &__p;
            std::string::value_type v190 = __p.__r_.__value_.__s.__data_[0];
          }
          memset(&v295, 0, sizeof(v295));
          float v192 = (char *)(v187 + size);
          float v193 = (char *)&__p + HIBYTE(__p.__r_.__value_.__r.__words[2]);
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            float v193 = v192;
          }
          uint64_t v194 = v185 - v188;
          if (v185 - v188 >= 1)
          {
            uint64_t v195 = v193 - 1;
            do
            {
              std::string::push_back(&v295, v190);
              if (p_p == (std::string *)v195)
              {
                std::string::value_type v190 = *v195;
                p_p = (std::string *)v195;
              }
              else
              {
                vDSP_Length v196 = &p_p->__r_.__value_.__s.__data_[1];
                v197 = &p_p->__r_.__value_.__s.__data_[1];
                do
                {
                  int v198 = *v197++;
                  std::string::value_type v190 = v198;
                  if (v198) {
                    BOOL v199 = 1;
                  }
                  else {
                    BOOL v199 = v196 == v195;
                  }
                  vDSP_Length v196 = v197;
                }
                while (!v199);
                p_p = (std::string *)(v197 - 1);
              }
              v194 -= v190;
            }
            while (v194 > 0);
          }
          std::string::push_back(&v295, v190 + v194);
          char v96 = v282;
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          std::string __p = v295;
LABEL_361:
          unint64_t v202 = HIDWORD(v90);
          uint64_t v283 = *(void *)v300;
          std::string::size_type v203 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            std::string::size_type v203 = __p.__r_.__value_.__l.__size_;
          }
          std::string::size_type v204 = *(void *)v300 - (void)v302 + SDWORD1(v301) + v203 - (v203 != 0);
          int v205 = v96 & 7;
          BOOL v206 = __OFSUB__(__len >> 32, v204);
          uint64_t v207 = (__len >> 32) - v204;
          if ((v207 < 0) ^ v206 | (v207 == 0))
          {
            size_t v211 = 0;
            size_t v210 = 0;
            unsigned __int8 v208 = v202;
          }
          else
          {
            if (v205 == 4) {
              unsigned __int8 v208 = 48;
            }
            else {
              unsigned __int8 v208 = v202;
            }
            if (v205 == 4) {
              uint64_t v209 = 3;
            }
            else {
              uint64_t v209 = v96 & 7;
            }
            size_t v210 = 0;
            size_t v211 = v207;
            switch(v209)
            {
              case 1:
                break;
              case 2:
                size_t v210 = (unint64_t)v207 >> 1;
                size_t v211 = v207 - ((unint64_t)v207 >> 1);
                break;
              default:
                size_t v211 = 0;
                size_t v210 = v207;
                break;
            }
          }
          size_t __lena = v211;
          if (v205 == 4 && v184 != v302)
          {
            v295.__r_.__value_.__r.__words[0] = (std::string::size_type)v72;
            std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100]((uint64_t **)&v295, *(unsigned char *)v302);
          }
          int v212 = v202 & 0xFFFFFF00 | v208;
          std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v72, v210, v212);
          if (v205 != 4 && v184 != v302)
          {
            v295.__r_.__value_.__r.__words[0] = (std::string::size_type)v72;
            std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100]((uint64_t **)&v295, *(unsigned char *)v302);
          }
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          {
            std::string::size_type v213 = __p.__r_.__value_.__l.__size_;
            if (__p.__r_.__value_.__l.__size_)
            {
              v215 = (std::string *)__p.__r_.__value_.__r.__words[0];
              v214 = (char *)(__p.__r_.__value_.__r.__words[0] + 1);
LABEL_384:
              v216 = (char *)v215 + v213;
              char v217 = ((uint64_t (*)(const std::locale::facet *))v286->__vftable[1].~facet_0)(v286);
              while (1)
              {
                v218 = v216 - 1;
                std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v72, (char *)v184, *(v216 - 1));
                if (v216 == v214) {
                  break;
                }
                v184 = (uint64_t *)((char *)v184 + *(v216 - 1));
                uint64_t v219 = *v72;
                uint64_t v220 = v72[2];
                v72[2] = v220 + 1;
                *(unsigned char *)(v219 + v220) = v217;
                --v216;
                if (v72[2] == v72[1])
                {
                  ((void (*)(void))v72[3])(*v72);
                  v72[2] = 0;
                  v216 = v218;
                }
              }
              goto LABEL_389;
            }
          }
          else
          {
            std::string::size_type v213 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            if (*((unsigned char *)&__p.__r_.__value_.__s + 23))
            {
              v214 = &__p.__r_.__value_.__s.__data_[1];
              v215 = &__p;
              goto LABEL_384;
            }
          }
          std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v72, (char *)v184, v185);
LABEL_389:
          v221 = (char *)v283;
          if (v284 == v283)
          {
            v221 = (char *)v284;
            v223 = v285;
          }
          else
          {
            char v222 = ((uint64_t (*)(const std::locale::facet *))v286->__vftable[1].~facet)(v286);
            v223 = v285;
            uint64_t v224 = *v72;
            uint64_t v225 = v72[2];
            v72[2] = v225 + 1;
            *(unsigned char *)(v224 + v225) = v222;
            if (v72[2] == v72[1])
            {
              ((void (*)(void))v72[3])(*v72);
              v72[2] = 0;
            }
            std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v72, (char *)(v284 + 1), (size_t)&v285[-v284 - 1]);
            std::__format::__output_buffer<char>::__fill[abi:ne180100](v72, SDWORD1(v301), 48);
          }
          if (v223 != v221) {
            std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v72, v223, v221 - v223);
          }
          std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v72, __lena, v212);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          std::locale::~locale(&v294);
LABEL_399:
          if (*((void *)&v301 + 1) < 0x101uLL) {
            goto LABEL_451;
          }
          goto LABEL_449;
        }
        v278 = *a4;
        LODWORD(v279) = v91 >> 31;
        uint64_t v280 = v89;
        unint64_t v281 = v90;
LABEL_506:
        uint64_t v21 = std::__formatter::__format_floating_point_non_finite[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>(v278, v280, v281, v279, 0);
LABEL_98:
        float v72 = v21;
        goto LABEL_451;
      }
      if (BYTE1(v289) <= 0xCu && ((1 << SBYTE1(v289)) & 0x1801) != 0) {
        goto LABEL_117;
      }
      goto LABEL_513;
    case 10:
      __p.__r_.__value_.__r.__words[0] = 0;
      __p.__r_.__value_.__l.__size_ = 0x20FFFFFFFFLL;
      if (v9 != 58) {
        goto LABEL_146;
      }
      float v62 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>((uint64_t)&__p, a3, 63);
      if (__p.__r_.__value_.__s.__data_[1] - 13 < 6)
      {
        if (LODWORD(__p.__r_.__value_.__r.__words[1]) != -1 || *(__int16 *)&__p.__r_.__value_.__s.__data_[2] <= -1) {
          int v64 = __p.__r_.__value_.__r.__words[1];
        }
        else {
          int v64 = 6;
        }
        LODWORD(__p.__r_.__value_.__r.__words[1]) = v64;
        goto LABEL_145;
      }
      if (__p.__r_.__value_.__s.__data_[1] <= 0xCu
        && ((1 << __p.__r_.__value_.__s.__data_[1]) & 0x1801) != 0)
      {
LABEL_145:
        *a3 = (char *)v62;
LABEL_146:
        unint64_t v105 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&__p, a4);
        unint64_t v106 = v104;
        int64_t v107 = v15 | ((unint64_t)v16 << 8) | (v13 << 32);
        if ((v107 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000)
        {
          if (v107 >= 0) {
            double v108 = *(double *)&v107;
          }
          else {
            double v108 = -*(double *)&v107;
          }
          if (v104 == -1) {
            uint64_t v109 = 1074;
          }
          else {
            uint64_t v109 = v104;
          }
          *(void *)&long long v301 = v109;
          if ((int)v109 < 1075)
          {
            size_t v110 = (int)v109 + 316;
            *((void *)&v301 + 1) = v110;
            if ((v109 + 316) < 0x401)
            {
              float v111 = v303;
LABEL_158:
              v302 = v111;
              if (v107 < 0)
              {
                char v112 = v105;
                char v115 = 45;
              }
              else
              {
                char v112 = v105;
                int v113 = (v105 >> 3) & 3;
                if (v113 == 2)
                {
                  char v115 = 43;
                }
                else
                {
                  size_t v114 = (uint64_t *)v111;
                  if (v113 != 3)
                  {
LABEL_165:
                    switch(BYTE1(v105))
                    {
                      case 1:
                      case 2:
                      case 3:
                      case 4:
                      case 5:
                      case 6:
                      case 7:
                      case 8:
                      case 9:
                      case 0xA:
                        goto LABEL_508;
                      case 0xB:
                        if ((v106 & 0x80000000) != 0) {
                          int v152 = -1;
                        }
                        else {
                          int v152 = v109;
                        }
                        std::__formatter::__format_buffer_hexadecimal_lower_case[abi:ne180100]<double,double>(&v297, v110, (uint64_t)v111, v152, (uint64_t)v114);
                        goto LABEL_281;
                      case 0xC:
                        if ((v106 & 0x80000000) != 0) {
                          int v154 = -1;
                        }
                        else {
                          int v154 = v109;
                        }
                        std::__formatter::__format_buffer_hexadecimal_lower_case[abi:ne180100]<double,double>(&v297, v110, (uint64_t)v111, v154, (uint64_t)v114);
                        v155 = v297;
                        v156 = (uint64_t *)__src;
                        if (v297 != __src)
                        {
                          do
                          {
                            int v157 = *(char *)v155;
                            if ((v157 - 97) < 6) {
                              LOBYTE(v157) = v157 - 32;
                            }
                            *(unsigned char *)v155 = v157;
                            v155 = (uint64_t *)((char *)v155 + 1);
                          }
                          while (v155 != v156);
                          v155 = v156;
                        }
                        *(unsigned char *)v155 = 80;
                        if ((v112 & 0x20) == 0) {
                          goto LABEL_414;
                        }
                        goto LABEL_282;
                      case 0xD:
                        std::__formatter::__format_buffer_scientific_lower_case[abi:ne180100]<double,double>(&v297, v110, (uint64_t)v111, v109, (uint64_t)v114);
                        goto LABEL_281;
                      case 0xE:
                        std::__formatter::__format_buffer_scientific_lower_case[abi:ne180100]<double,double>(&v297, v110, (uint64_t)v111, v109, (uint64_t)v114);
                        vDSP_Length v158 = __src;
                        goto LABEL_280;
                      case 0xF:
                      case 0x10:
                        v297 = v114;
                        uint64_t v116 = (char *)MEMORY[0x1C185D1A0](v114, &v111[v110], 2, v109, v108);
                        __src = v116;
                        *(void *)v300 = v116;
                        if (v109) {
                          int v117 = v109 + 1;
                        }
                        else {
                          int v117 = 0;
                        }
                        uint64_t v118 = &v116[-v117];
                        goto LABEL_170;
                      case 0x11:
                        goto LABEL_256;
                      case 0x12:
                        std::__formatter::__format_buffer_general_lower_case[abi:ne180100]<double,double>(&v297, (uint64_t)&v301, v109, (uint64_t)v114);
                        vDSP_Length v158 = __src;
                        if (__src != *(void **)v300) {
LABEL_280:
                        }
                          *vDSP_Length v158 = 69;
                        goto LABEL_281;
                      default:
                        if ((v106 & 0x80000000) != 0)
                        {
                          v297 = v114;
                          uint64_t v265 = std::to_chars((std::__1 *)v114, &v111[v110], v111, v108);
                          uint64_t v266 = v265;
                          *(void *)v300 = v265;
                          unint64_t v267 = v265 - (void)v114;
                          v268 = (char *)v265;
                          if (v265 - (uint64_t)v114 >= 4)
                          {
                            if (v267 >= 6) {
                              unint64_t v267 = 6;
                            }
                            uint64_t v269 = -(uint64_t)v267;
                            while (*(unsigned char *)(v265 + v269) != 101)
                            {
                              if (++v269 == -3)
                              {
                                v268 = (char *)v265;
                                goto LABEL_491;
                              }
                            }
                            v268 = (char *)(v265 + v269);
                          }
LABEL_491:
                          __src = v268;
                          v276 = (char *)memchr((char *)v114 + 1, 46, v268 - ((char *)v114 + 1));
                          if (v276) {
                            uint64_t v118 = v276;
                          }
                          else {
                            uint64_t v118 = v268;
                          }
                          if (v118 == v268) {
                            uint64_t v118 = (char *)v266;
                          }
LABEL_170:
                          unint64_t v298 = (unint64_t)v118;
                          if ((v112 & 0x20) != 0)
                          {
LABEL_282:
                            float v159 = (unsigned char *)v298;
                            float v160 = *(void **)v300;
                            if (v298 == *(void *)v300)
                            {
                              *(unsigned char *)unint64_t v298 = 46;
                              float v160 = v159 + 1;
                              *(void *)v300 = v159 + 1;
                              unint64_t v161 = (unint64_t)__src;
                              if (__src != v159)
                              {
                                if ((char *)__src + 1 == v159)
                                {
                                  char v226 = *(unsigned char *)__src;
                                  *(unsigned char *)__src = 46;
                                  unsigned char *v159 = v226;
                                }
                                else
                                {
                                  memmove((char *)__src + 1, __src, v159 - (unsigned char *)__src);
                                  *(unsigned char *)unint64_t v161 = 46;
                                }
                              }
                              unint64_t v298 = v161;
                              __src = (void *)(v161 + 1);
                            }
                            else
                            {
                              unint64_t v161 = v298;
                            }
                            if (BYTE1(v105) - 17 <= 1)
                            {
                              if (v106 <= 1) {
                                int v227 = 1;
                              }
                              else {
                                int v227 = v106;
                              }
                              if ((v106 & 0x80000000) != 0) {
                                int v227 = 6;
                              }
                              int v228 = v297 - v161;
                              if (__src != v160) {
                                int v228 = -1;
                              }
                              int v229 = v228 + v227;
                              v230 = (char *)__src + ~v161;
                              if ((uint64_t)v230 < v229) {
                                DWORD1(v301) += v229 - v230;
                              }
                            }
                          }
                        }
                        else
                        {
LABEL_256:
                          std::__formatter::__format_buffer_general_lower_case[abi:ne180100]<double,double>(&v297, (uint64_t)&v301, v109, (uint64_t)v114);
LABEL_281:
                          if ((v112 & 0x20) != 0) {
                            goto LABEL_282;
                          }
                        }
LABEL_414:
                        if ((v112 & 0x40) != 0) {
                          goto LABEL_447;
                        }
                        unsigned __int8 v231 = BYTE4(v106);
                        uint64_t v232 = *(void *)v300;
                        uint64_t v233 = v105;
                        v234 = (char *)v302;
                        uint64_t v235 = *(void *)v300 - (void)v302;
                        size_t v236 = SDWORD1(v301);
                        if (*(void *)v300 - (void)v302 + SDWORD1(v301) < v233 >> 32)
                        {
                          char v237 = v112;
                          uint64_t v238 = v233;
                          float v72 = *a4;
                          if ((v237 & 7) == 4)
                          {
                            if (v302 != v297)
                            {
                              v295.__r_.__value_.__r.__words[0] = (std::string::size_type)*a4;
                              std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100]((uint64_t **)&v295, *(unsigned char *)v302);
                              ++v234;
                            }
                            unsigned __int8 v239 = v238 & 0xF8 | 3;
                            unsigned __int8 v231 = 48;
                          }
                          else
                          {
                            unsigned __int8 v239 = v233;
                          }
                          unint64_t v241 = v238 & 0xFFFFFFFFFFFFFF00 | v239;
                          unint64_t v242 = v106 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)v231 << 32);
                          if (v236) {
                            std::__formatter::__write_using_trailing_zeros[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v234, v232, v72, v241, v242, v235, (char *)__src, v236);
                          }
                          else {
                            std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v234, v232 - (void)v234, v72, v241, v242, v235);
                          }
                          goto LABEL_448;
                        }
                        if (DWORD1(v301))
                        {
                          v240 = (char *)__src;
                          if (__src != *(void **)v300) {
                            goto LABEL_423;
                          }
                        }
                        goto LABEL_457;
                    }
                  }
                  char v115 = 32;
                }
              }
              *float v111 = v115;
              size_t v114 = (uint64_t *)(v111 + 1);
              goto LABEL_165;
            }
          }
          else
          {
            LODWORD(v301) = 1074;
            DWORD1(v301) = v109 - 1074;
            size_t v110 = 1390;
            *((void *)&v301 + 1) = 1390;
            uint64_t v109 = 1074;
          }
          float v111 = operator new(v110);
          goto LABEL_158;
        }
LABEL_504:
        v278 = *a4;
        unint64_t v279 = (unint64_t)v107 >> 63;
        uint64_t v280 = v105;
        unint64_t v281 = v106;
        goto LABEL_506;
      }
      goto LABEL_513;
    case 11:
      __p.__r_.__value_.__r.__words[0] = 0;
      __p.__r_.__value_.__l.__size_ = 0x20FFFFFFFFLL;
      if (v9 != 58) {
        goto LABEL_175;
      }
      float v65 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>((uint64_t)&__p, a3, 63);
      if (__p.__r_.__value_.__s.__data_[1] - 13 >= 6)
      {
        if (__p.__r_.__value_.__s.__data_[1] > 0xCu
          || ((1 << __p.__r_.__value_.__s.__data_[1]) & 0x1801) == 0)
        {
LABEL_513:
          std::__format_spec::__throw_invalid_type_format_error[abi:ne180100]("a floating-point");
        }
      }
      else
      {
        if (LODWORD(__p.__r_.__value_.__r.__words[1]) != -1 || *(__int16 *)&__p.__r_.__value_.__s.__data_[2] <= -1) {
          int v67 = __p.__r_.__value_.__r.__words[1];
        }
        else {
          int v67 = 6;
        }
        LODWORD(__p.__r_.__value_.__r.__words[1]) = v67;
      }
      *a3 = (char *)v65;
LABEL_175:
      unint64_t v105 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&__p, a4);
      unint64_t v106 = v119;
      int64_t v107 = v15 | ((unint64_t)v16 << 8) | (v13 << 32);
      if ((v107 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000) {
        goto LABEL_504;
      }
      if (v107 >= 0) {
        double v120 = *(double *)&v107;
      }
      else {
        double v120 = -*(double *)&v107;
      }
      if (v119 == -1) {
        uint64_t v121 = 1074;
      }
      else {
        uint64_t v121 = v119;
      }
      *(void *)&long long v301 = v121;
      if ((int)v121 < 1075)
      {
        size_t v122 = (int)v121 + 316;
        *((void *)&v301 + 1) = v122;
        if ((v121 + 316) < 0x401)
        {
          uint64_t v123 = v303;
LABEL_187:
          v302 = v123;
          if (v107 < 0)
          {
            char v124 = v105;
            char v127 = 45;
          }
          else
          {
            char v124 = v105;
            int v125 = (v105 >> 3) & 3;
            if (v125 == 2)
            {
              char v127 = 43;
            }
            else
            {
              v126 = (uint64_t *)v123;
              if (v125 != 3)
              {
LABEL_194:
                switch(BYTE1(v105))
                {
                  case 1:
                  case 2:
                  case 3:
                  case 4:
                  case 5:
                  case 6:
                  case 7:
                  case 8:
                  case 9:
                  case 0xA:
LABEL_508:
                    __break(1u);
                    goto LABEL_509;
                  case 0xB:
                    if ((v106 & 0x80000000) != 0) {
                      int v153 = -1;
                    }
                    else {
                      int v153 = v121;
                    }
                    std::__formatter::__format_buffer_hexadecimal_lower_case[abi:ne180100]<double,long double>(&v297, v122, (uint64_t)v123, v153, (uint64_t)v126);
                    goto LABEL_301;
                  case 0xC:
                    if ((v106 & 0x80000000) != 0) {
                      int v162 = -1;
                    }
                    else {
                      int v162 = v121;
                    }
                    std::__formatter::__format_buffer_hexadecimal_lower_case[abi:ne180100]<double,long double>(&v297, v122, (uint64_t)v123, v162, (uint64_t)v126);
                    float v163 = v297;
                    BOOL v164 = (uint64_t *)__src;
                    if (v297 != __src)
                    {
                      do
                      {
                        int v165 = *(char *)v163;
                        if ((v165 - 97) < 6) {
                          LOBYTE(v165) = v165 - 32;
                        }
                        *(unsigned char *)float v163 = v165;
                        float v163 = (uint64_t *)((char *)v163 + 1);
                      }
                      while (v163 != v164);
                      float v163 = v164;
                    }
                    *(unsigned char *)float v163 = 80;
                    if ((v124 & 0x20) == 0) {
                      goto LABEL_441;
                    }
                    goto LABEL_302;
                  case 0xD:
                    std::__formatter::__format_buffer_scientific_lower_case[abi:ne180100]<double,long double>(&v297, v122, (uint64_t)v123, v121, (uint64_t)v126);
                    goto LABEL_301;
                  case 0xE:
                    std::__formatter::__format_buffer_scientific_lower_case[abi:ne180100]<double,long double>(&v297, v122, (uint64_t)v123, v121, (uint64_t)v126);
                    vDSP_Length v166 = __src;
                    goto LABEL_300;
                  case 0xF:
                  case 0x10:
                    v297 = v126;
                    vDSP_Length v128 = (char *)MEMORY[0x1C185D1D0](v126, &v123[v122], 2, v121, v120);
                    __src = v128;
                    *(void *)v300 = v128;
                    if (v121) {
                      int v129 = v121 + 1;
                    }
                    else {
                      int v129 = 0;
                    }
                    int v130 = &v128[-v129];
                    goto LABEL_199;
                  case 0x11:
                    goto LABEL_262;
                  case 0x12:
                    std::__formatter::__format_buffer_general_lower_case[abi:ne180100]<double,long double>(&v297, (uint64_t)&v301, v121, (uint64_t)v126);
                    vDSP_Length v166 = __src;
                    if (__src != *(void **)v300) {
LABEL_300:
                    }
                      unsigned char *v166 = 69;
                    goto LABEL_301;
                  default:
                    if ((v106 & 0x80000000) != 0)
                    {
                      v297 = v126;
                      uint64_t v270 = std::to_chars((std::__1 *)v126, &v123[v122], v123, v120);
                      uint64_t v271 = v270;
                      *(void *)v300 = v270;
                      unint64_t v272 = v270 - (void)v126;
                      v273 = (char *)v270;
                      if (v270 - (uint64_t)v126 >= 4)
                      {
                        if (v272 >= 6) {
                          unint64_t v272 = 6;
                        }
                        uint64_t v274 = -(uint64_t)v272;
                        while (*(unsigned char *)(v270 + v274) != 101)
                        {
                          if (++v274 == -3)
                          {
                            v273 = (char *)v270;
                            goto LABEL_498;
                          }
                        }
                        v273 = (char *)(v270 + v274);
                      }
LABEL_498:
                      __src = v273;
                      v277 = (char *)memchr((char *)v126 + 1, 46, v273 - ((char *)v126 + 1));
                      if (v277) {
                        int v130 = v277;
                      }
                      else {
                        int v130 = v273;
                      }
                      if (v130 == v273) {
                        int v130 = (char *)v271;
                      }
LABEL_199:
                      unint64_t v298 = (unint64_t)v130;
                      if ((v124 & 0x20) != 0)
                      {
LABEL_302:
                        uint64_t v167 = (unsigned char *)v298;
                        uint64_t v168 = *(void **)v300;
                        if (v298 == *(void *)v300)
                        {
                          *(unsigned char *)unint64_t v298 = 46;
                          uint64_t v168 = v167 + 1;
                          *(void *)v300 = v167 + 1;
                          unint64_t v169 = (unint64_t)__src;
                          if (__src != v167)
                          {
                            if ((char *)__src + 1 == v167)
                            {
                              char v243 = *(unsigned char *)__src;
                              *(unsigned char *)__src = 46;
                              *uint64_t v167 = v243;
                            }
                            else
                            {
                              memmove((char *)__src + 1, __src, v167 - (unsigned char *)__src);
                              *(unsigned char *)unint64_t v169 = 46;
                            }
                          }
                          unint64_t v298 = v169;
                          __src = (void *)(v169 + 1);
                        }
                        else
                        {
                          unint64_t v169 = v298;
                        }
                        if (BYTE1(v105) - 17 <= 1)
                        {
                          if (v106 <= 1) {
                            int v244 = 1;
                          }
                          else {
                            int v244 = v106;
                          }
                          if ((v106 & 0x80000000) != 0) {
                            int v244 = 6;
                          }
                          int v245 = v297 - v169;
                          if (__src != v168) {
                            int v245 = -1;
                          }
                          int v246 = v245 + v244;
                          v247 = (char *)__src + ~v169;
                          if ((uint64_t)v247 < v246) {
                            DWORD1(v301) += v246 - v247;
                          }
                        }
                      }
                    }
                    else
                    {
LABEL_262:
                      std::__formatter::__format_buffer_general_lower_case[abi:ne180100]<double,long double>(&v297, (uint64_t)&v301, v121, (uint64_t)v126);
LABEL_301:
                      if ((v124 & 0x20) != 0) {
                        goto LABEL_302;
                      }
                    }
LABEL_441:
                    if ((v124 & 0x40) != 0)
                    {
LABEL_447:
                      float v72 = *a4;
                      std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>::locale[abi:ne180100]((std::locale *)&v295, (uint64_t)a4);
                      std::__formatter::__format_locale_specific_form[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,double,char>(v72, (uint64_t)&v301, (char **)&v297, (std::locale *)&v295, v105, v106);
                      std::locale::~locale((std::locale *)&v295);
                      goto LABEL_448;
                    }
                    unsigned __int8 v248 = BYTE4(v106);
                    uint64_t v232 = *(void *)v300;
                    uint64_t v249 = v105;
                    v250 = (char *)v302;
                    uint64_t v251 = *(void *)v300 - (void)v302;
                    size_t v236 = SDWORD1(v301);
                    if (*(void *)v300 - (void)v302 + SDWORD1(v301) < v249 >> 32)
                    {
                      char v252 = v124;
                      uint64_t v253 = v249;
                      float v72 = *a4;
                      if ((v252 & 7) == 4)
                      {
                        if (v302 != v297)
                        {
                          v295.__r_.__value_.__r.__words[0] = (std::string::size_type)*a4;
                          std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100]((uint64_t **)&v295, *(unsigned char *)v302);
                          ++v250;
                        }
                        uint64_t v254 = v253;
                        unsigned __int8 v255 = v253 & 0xF8 | 3;
                        unsigned __int8 v248 = 48;
                      }
                      else
                      {
                        uint64_t v254 = v249;
                        unsigned __int8 v255 = v249;
                      }
                      unint64_t v258 = v254 & 0xFFFFFFFFFFFFFF00 | v255;
                      unint64_t v259 = v106 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)v248 << 32);
                      if (v236) {
                        std::__formatter::__write_using_trailing_zeros[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v250, v232, v72, v258, v259, v251, (char *)__src, v236);
                      }
                      else {
                        std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v250, v232 - (void)v250, v72, v258, v259, v251);
                      }
LABEL_448:
                      if (*((void *)&v301 + 1) < 0x401uLL)
                      {
LABEL_451:
                        *a4 = v72;
                        goto LABEL_452;
                      }
LABEL_449:
                      v142 = v302;
LABEL_450:
                      operator delete(v142);
                      goto LABEL_451;
                    }
                    if (!DWORD1(v301) || (v240 = (char *)__src, __src == *(void **)v300))
                    {
LABEL_457:
                      float v72 = *a4;
                      std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(*a4, (char *)v302, *(void *)v300 - (void)v302);
                      std::__format::__output_buffer<char>::__fill[abi:ne180100](v72, v236, 48);
                      goto LABEL_448;
                    }
LABEL_423:
                    float v72 = *a4;
                    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(*a4, (char *)v302, (unsigned char *)__src - (unsigned char *)v302);
                    std::__format::__output_buffer<char>::__fill[abi:ne180100](v72, v236, 48);
                    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v72, v240, v232 - (void)v240);
                    goto LABEL_448;
                }
              }
              char v127 = 32;
            }
          }
          unsigned char *v123 = v127;
          v126 = (uint64_t *)(v123 + 1);
          goto LABEL_194;
        }
      }
      else
      {
        LODWORD(v301) = 1074;
        DWORD1(v301) = v121 - 1074;
        size_t v122 = 1390;
        *((void *)&v301 + 1) = 1390;
        uint64_t v121 = 1074;
      }
      uint64_t v123 = operator new(v122);
      goto LABEL_187;
    case 12:
      LODWORD(v301) = 1;
      *(void *)((char *)&v301 + 4) = 0xFFFFFFFF00000000;
      BYTE12(v301) = 32;
      *(_WORD *)((char *)&v301 + 13) = 0;
      HIBYTE(v301) = 0;
      if (v9 == 58) {
        *a3 = (char *)std::__formatter_string<char>::parse[abi:ne180100]<std::basic_format_parse_context<char>>((uint64_t)&v301, a3);
      }
      unint64_t v69 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v301, a4);
      unint64_t v70 = v68;
      float v71 = (char *)(v15 | ((unint64_t)v16 << 8) | (v13 << 32));
      if (SHIDWORD(v69) > 0 || (v68 & 0x80000000) == 0)
      {
        size_t v76 = strlen(v71);
        uint64_t v21 = std::__formatter::__write_string[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v71, v76, *a4, v69, v70);
        goto LABEL_98;
      }
      float v72 = *a4;
      char v73 = *v71;
      if (*v71)
      {
        double v74 = (unsigned __int8 *)(v71 + 1);
        do
        {
          v297 = v72;
          std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100](&v297, v73);
          int v75 = *v74++;
          char v73 = v75;
        }
        while (v75);
      }
      goto LABEL_451;
    case 13:
      LODWORD(v301) = 1;
      *(void *)((char *)&v301 + 4) = 0xFFFFFFFF00000000;
      BYTE12(v301) = 32;
      *(_WORD *)((char *)&v301 + 13) = 0;
      HIBYTE(v301) = 0;
      if (v9 == 58) {
        *a3 = (char *)std::__formatter_string<char>::parse[abi:ne180100]<std::basic_format_parse_context<char>>((uint64_t)&v301, a3);
      }
      uint64_t v29 = *a4;
      unint64_t v30 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v301, a4);
      uint64_t v28 = std::__formatter::__write_string[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>((char *)(v15 | ((unint64_t)v16 << 8) | (v13 << 32)), v14, v29, v30, v31);
      goto LABEL_100;
    case 14:
      v297 = 0;
      unint64_t v298 = 0x20FFFFFFFFLL;
      if (v9 == 58)
      {
        std::string v22 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>((uint64_t)&v297, a3, 36);
        if (BYTE1(v297) - 8 >= 2 && BYTE1(v297)) {
          std::__format_spec::__throw_invalid_type_format_error[abi:ne180100]("a pointer");
        }
        *a3 = (char *)v22;
      }
      unint64_t v24 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v297, a4);
      unint64_t v25 = v15 | ((unint64_t)v16 << 8) | (v13 << 32);
      uint64_t v26 = (unsigned __int16)v24 & 0xFF00;
      unint64_t v27 = v24 & 0xFFFFFFFFFFFF00DFLL;
      if (v26 == 2304) {
        uint64_t v28 = std::__formatter::__format_integer[abi:ne180100]<unsigned long,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(v25, a4, v27 | 0x720, v23, (char *)&v301, (uint64_t)&v302 + 3, "0X", 0x10u);
      }
      else {
        uint64_t v28 = std::__formatter::__format_integer[abi:ne180100]<unsigned long,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(v25, a4, v27 | 0x620, v23, (char *)&v301, (uint64_t)&v302 + 3, "0x", 0x10u);
      }
LABEL_100:
      *a4 = v28;
      goto LABEL_452;
    case 15:
      ((void (*)(char **, void **, unint64_t))v14)(a3, a4, v15 | ((unint64_t)v16 << 8) | (v13 << 32));
      goto LABEL_452;
    default:
      goto LABEL_510;
  }
}

void sub_1BB361820(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::locale a17, std::locale a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,std::locale a34,unint64_t a35,void *__p)
{
  if (a35 >= 0x401) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t **std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100](uint64_t **a1, char a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = **a1;
  uint64_t v5 = (*a1)[2];
  v3[2] = v5 + 1;
  *(unsigned char *)(v4 + v5) = a2;
  if (v3[2] == v3[1])
  {
    ((void (*)(uint64_t))v3[3])(*v3);
    v3[2] = 0;
  }
  return a1;
}

char *std::__format::__parse_arg_id[abi:ne180100]<char const*,std::basic_format_parse_context<char>>(char *result, char *a2, uint64_t a3)
{
  int v4 = *result;
  if (v4 == 125 || v4 == 58)
  {
    int v6 = *(_DWORD *)(a3 + 16);
    if (v6)
    {
      if (v6 == 1) {
        std::__throw_format_error[abi:ne180100]("Using automatic argument numbering in manual argument numbering mode");
      }
    }
    else
    {
      *(_DWORD *)(a3 + 16) = 2;
    }
    ++*(void *)(a3 + 24);
  }
  else if (v4 == 48)
  {
    int v5 = *(_DWORD *)(a3 + 16);
    if (v5)
    {
      if (v5 == 2) {
LABEL_13:
      }
        std::__throw_format_error[abi:ne180100]("Using manual argument numbering in automatic argument numbering mode");
    }
    else
    {
      *(_DWORD *)(a3 + 16) = 1;
    }
    ++result;
  }
  else
  {
    if ((v4 - 58) <= 0xF5u) {
      std::__throw_format_error[abi:ne180100]("The argument index starts with an invalid character");
    }
    uint64_t result = std::__format::__parse_number[abi:ne180100]<char const*>((unint64_t)result, a2);
    int v7 = *(_DWORD *)(a3 + 16);
    if (v7)
    {
      if (v7 == 2) {
        goto LABEL_13;
      }
    }
    else
    {
      *(_DWORD *)(a3 + 16) = 1;
    }
  }
  return result;
}

unint64_t std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char *a1, void *a2)
{
  *(void *)&v25[23] = *MEMORY[0x1E4F143B8];
  char v5 = *a1;
  uint64_t v6 = a1[1];
  __int16 v7 = *((_WORD *)a1 + 1);
  unint64_t v8 = *((unsigned int *)a1 + 1);
  if ((v7 & 0x4000) != 0)
  {
    uint64_t v9 = (int)v8;
    unint64_t v10 = a2[1];
    if (v10 <= (int)v8)
    {
      LOBYTE(v12) = 0;
    }
    else if (v10 > 0xC)
    {
      uint64_t v13 = a2[2] + 32 * (int)v8;
      uint64_t v2 = *(void *)v13;
      uint64_t v9 = *(void *)(v13 + 8);
      LOBYTE(v12) = *(unsigned char *)(v13 + 16);
      *(void *)uint64_t v21 = *(void *)(v13 + 17);
      *(void *)&v21[7] = *(void *)(v13 + 24);
    }
    else
    {
      uint64_t v11 = a2[2];
      uint64_t v12 = (a2[3] >> (5 * v8)) & 0x1FLL;
      uint64_t v2 = *(void *)(v11 + 16 * (int)v8);
      uint64_t v9 = *(void *)(v11 + 16 * (int)v8 + 8);
    }
    uint64_t v22 = v2;
    uint64_t v23 = v9;
    char v24 = v12;
    *(void *)unint64_t v25 = *(void *)v21;
    *(void *)&v25[7] = *(void *)&v21[7];
    unint64_t v8 = std::__visit_format_arg[abi:ne180100]<unsigned int std::__format_spec::__substitute_arg_id[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(std::basic_format_arg<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>)::{lambda(std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>)#1},std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((unsigned int *)&v22);
    __int16 v7 = *((_WORD *)a1 + 1);
  }
  int v14 = *((_DWORD *)a1 + 2);
  if (v7 < 0)
  {
    uint64_t v15 = v14;
    unint64_t v16 = a2[1];
    if (v16 <= v14)
    {
      LOBYTE(v18) = 0;
    }
    else if (v16 > 0xC)
    {
      uint64_t v19 = a2[2] + 32 * v14;
      uint64_t v2 = *(void *)v19;
      uint64_t v15 = *(void *)(v19 + 8);
      LOBYTE(v18) = *(unsigned char *)(v19 + 16);
      *(void *)uint64_t v21 = *(void *)(v19 + 17);
      *(void *)&v21[7] = *(void *)(v19 + 24);
    }
    else
    {
      uint64_t v17 = a2[2];
      uint64_t v18 = (a2[3] >> (5 * v14)) & 0x1FLL;
      uint64_t v2 = *(void *)(v17 + 16 * v14);
      uint64_t v15 = *(void *)(v17 + 16 * v14 + 8);
    }
    uint64_t v22 = v2;
    uint64_t v23 = v15;
    char v24 = v18;
    *(void *)unint64_t v25 = *(void *)v21;
    *(void *)&v25[7] = *(void *)&v21[7];
    std::__visit_format_arg[abi:ne180100]<unsigned int std::__format_spec::__substitute_arg_id[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(std::basic_format_arg<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>)::{lambda(std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>)#1},std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((unsigned int *)&v22);
  }
  return (v6 << 8) | (v8 << 32) | v5 & 0x7F;
}

void *std::__formatter::__format_integer[abi:ne180100]<unsigned long,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(unint64_t a1, void **a2, unint64_t a3, unint64_t a4, char *a5, uint64_t a6, unsigned char *a7, unsigned int a8)
{
  unint64_t v8 = a5;
  unsigned int v12 = (a3 >> 3) & 3;
  if (v12 == 2)
  {
    char v14 = 43;
    goto LABEL_5;
  }
  uint64_t v13 = a5;
  if (v12 == 3)
  {
    char v14 = 32;
LABEL_5:
    *a5 = v14;
    uint64_t v13 = a5 + 1;
  }
  if ((a3 & 0x20) != 0)
  {
    if (a7)
    {
      char v15 = *a7;
      if (*a7)
      {
        unint64_t v16 = a7 + 1;
        do
        {
          *v13++ = v15;
          int v17 = *v16++;
          char v15 = v17;
        }
        while (v17);
      }
    }
  }
  uint64_t v18 = std::__to_chars_integral[abi:ne180100]<unsigned long long>(v13, a6, a1, a8);
  if ((a3 & 0x40) == 0) {
    goto LABEL_38;
  }
  std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>::locale[abi:ne180100](&v43, (uint64_t)a2);
  uint64_t v19 = std::locale::use_facet(&v43, MEMORY[0x1E4FBA2A0]);
  int64_t v20 = v18 - v13;
  std::locale::~locale(&v43);
  ((void (*)(std::locale *__return_ptr, const std::locale::facet *))v19->__vftable[1].__on_zero_shared)(&v43, v19);
  if ((char)v45 < 0)
  {
    locale = (std::string::value_type *)v43.__locale_;
    uint64_t v22 = v44;
    if (v44 && v20 > *(char *)v43.__locale_)
    {
      uint64_t v23 = v43.__locale_;
      goto LABEL_19;
    }
    operator delete(v43.__locale_);
LABEL_38:
    unint64_t v35 = HIDWORD(a3);
    if ((a3 & 7) == 4)
    {
      std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(*a2, v8, v13 - v8);
      unsigned __int8 v36 = a3 & 0xF8 | 3;
      if (SHIDWORD(a3) >= (int)v13 - (int)v8) {
        int v37 = v13 - v8;
      }
      else {
        int v37 = HIDWORD(a3);
      }
      unint64_t v35 = (HIDWORD(a3) - v37);
      unsigned __int8 v38 = 48;
      unint64_t v8 = v13;
    }
    else
    {
      unsigned __int8 v38 = BYTE4(a4);
      unsigned __int8 v36 = a3;
    }
    unint64_t v34 = *a2;
    uint64_t v39 = a3 & 0xFFFFFF00 | (v35 << 32) | v36;
    unint64_t v40 = a4 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)v38 << 32);
    if ((a3 & 0xFF00) == 0x700) {
      std::__formatter::__write_transformed[abi:ne180100]<char *,char,char,char (*)(char),std::back_insert_iterator<std::__format::__output_buffer<char>>>(v8, v18, *a2, v39, v40);
    }
    else {
      std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v8, v18 - v8, *a2, v39, v40, v18 - v8);
    }
    return v34;
  }
  if (!v45 || v20 <= SLOBYTE(v43.__locale_)) {
    goto LABEL_38;
  }
  locale = (std::string::value_type *)&v43;
  uint64_t v23 = v43.__locale_;
  uint64_t v22 = v44;
LABEL_19:
  char v24 = *a2;
  memset(&__p, 0, sizeof(__p));
  unint64_t v25 = (char *)v23 + v22;
  if ((v45 & 0x80u) == 0) {
    unint64_t v25 = (char *)&v43 + v45;
  }
  std::string::value_type v26 = *locale;
  uint64_t v27 = v20 - *locale;
  if (v27 >= 1)
  {
    uint64_t v28 = v25 - 1;
    do
    {
      std::string::push_back(&__p, v26);
      if (locale == v28)
      {
        std::string::value_type v26 = *v28;
        locale = v28;
      }
      else
      {
        uint64_t v29 = locale + 1;
        unint64_t v30 = locale + 1;
        do
        {
          int v31 = *v30++;
          std::string::value_type v26 = v31;
          if (v31) {
            BOOL v32 = 1;
          }
          else {
            BOOL v32 = v29 == v28;
          }
          uint64_t v29 = v30;
        }
        while (!v32);
        locale = v30 - 1;
      }
      v27 -= v26;
    }
    while (v27 > 0);
  }
  std::string::push_back(&__p, v26 + v27);
  char v33 = ((uint64_t (*)(const std::locale::facet *))v19->__vftable[1].~facet_0)(v19);
  unint64_t v34 = std::__formatter::__write_using_decimal_separators[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,char *,char>(v24, v8, v13, (int)v18, (uint64_t *)&__p, v33, a3, a4);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if ((char)v45 < 0) {
    operator delete(v43.__locale_);
  }
  return v34;
}

void sub_1BB362054(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::locale a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15.__locale_);
  }
  _Unwind_Resume(exception_object);
}

char *std::__to_chars_integral[abi:ne180100]<unsigned long long>(char *a1, uint64_t a2, unint64_t a3, unsigned int a4)
{
  HIDWORD(v5) = a4;
  LODWORD(v5) = a4 - 2;
  int v4 = v5 >> 1;
  switch(v4)
  {
    case 4:
      if (a2 - (uint64_t)a1 > 19) {
        return std::__itoa::__traits_base<unsigned long long,void>::__convert[abi:ne180100](a1, a3);
      }
      unsigned int v6 = (1233 * (64 - __clz(a3 | 1))) >> 12;
      if (a2 - (uint64_t)a1 >= v6 - (std::__itoa::__pow10_64[v6] > a3) + 1) {
        return std::__itoa::__traits_base<unsigned long long,void>::__convert[abi:ne180100](a1, a3);
      }
      break;
    case 0:
      return (char *)std::__itoa::__integral<2u>::__to_chars[abi:ne180100]<unsigned long long>((uint64_t)a1, a2, a3);
    case 3:
      return (char *)std::__itoa::__integral<8u>::__to_chars[abi:ne180100]<unsigned long long>((uint64_t)a1, a2, a3);
    case 7:
      return (char *)std::__itoa::__integral<16u>::__to_chars[abi:ne180100]<unsigned long long>((uint64_t)a1, a2, a3);
    default:
      uint64_t v9 = a2 - (void)a1;
      uint64_t v16 = a2;
      int v10 = std::__to_chars_integral_width[abi:ne180100]<unsigned long long>(a3, a4);
      unint64_t v11 = a3;
      a2 = v16;
      if (v9 >= v10)
      {
        a2 = (uint64_t)&a1[v10];
        unsigned int v12 = (unsigned char *)(a2 - 1);
        do
        {
          *v12-- = a0123456789abcd[v11 % a4];
          BOOL v13 = v11 >= a4;
          v11 /= a4;
        }
        while (v13);
      }
      break;
  }
  return (char *)a2;
}

std::locale *std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>::locale[abi:ne180100](std::locale *this, uint64_t a2)
{
  uint64_t v3 = (std::locale *)(a2 + 32);
  if (!*(unsigned char *)(a2 + 40))
  {
    MEMORY[0x1C185D110](&v6);
    if (*(unsigned char *)(a2 + 40))
    {
      std::locale::operator=(v3, &v6);
    }
    else
    {
      std::locale::locale(v3, &v6);
      *(unsigned char *)(a2 + 40) = 1;
    }
    std::locale::~locale(&v6);
  }
  return std::locale::locale(this, v3);
}

void *std::__formatter::__write_using_decimal_separators[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,char *,char>(void *a1, char *__src, char *a3, int a4, uint64_t *a5, char a6, uint64_t a7, unint64_t a8)
{
  unsigned __int16 v8 = a7;
  unint64_t v11 = a3;
  unint64_t v14 = HIDWORD(a7);
  unint64_t v15 = HIDWORD(a8);
  size_t v16 = a3 - __src;
  LODWORD(v17) = *((unsigned __int8 *)a5 + 23);
  if ((v17 & 0x80u) != 0) {
    uint64_t v17 = a5[1];
  }
  int v18 = a4 - __src - 1 + v17;
  if ((a7 & 7) == 4)
  {
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(a1, __src, a3 - __src);
    if ((int)v14 > v18) {
      std::__format::__output_buffer<char>::__fill[abi:ne180100](a1, (int)v14 - v18, 48);
    }
    size_t v19 = 0;
  }
  else
  {
    if (SHIDWORD(a7) <= v18)
    {
      size_t v19 = 0;
    }
    else
    {
      size_t v19 = (a7 >> 32) - v18;
      size_t v20 = 0;
      switch(a7 & 7)
      {
        case 1:
          break;
        case 2:
          size_t v20 = v19 >> 1;
          v19 -= v19 >> 1;
          break;
        default:
          size_t v20 = (a7 >> 32) - v18;
          size_t v19 = 0;
          break;
      }
      std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a1, v20, SHIDWORD(a8));
    }
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(a1, __src, v16);
  }
  uint64_t v21 = *((unsigned __int8 *)a5 + 23);
  int v22 = (char)v21;
  uint64_t v23 = (char *)a5 + v21;
  if (v22 >= 0) {
    char v24 = v23;
  }
  else {
    char v24 = (char *)(*a5 + a5[1]);
  }
  if (v22 >= 0) {
    unint64_t v25 = a5;
  }
  else {
    unint64_t v25 = (uint64_t *)*a5;
  }
  std::string::value_type v26 = (char *)v25 + 1;
  uint64_t v27 = v8 & 0xFF00;
  while (1)
  {
    uint64_t v29 = v24 - 1;
    size_t v28 = *(v24 - 1);
    if (v27 == 1792)
    {
      unint64_t v30 = &v11[v28];
      std::__format::__output_buffer<char>::__transform[abi:ne180100]<char *,char (*)(char),char>((uint64_t)a1, v11, &v11[v28]);
      unint64_t v11 = v30;
    }
    else
    {
      std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(a1, v11, v28);
      v11 += *v29;
    }
    if (v24 == v26) {
      break;
    }
    uint64_t v31 = *a1;
    uint64_t v32 = a1[2];
    a1[2] = v32 + 1;
    *(unsigned char *)(v31 + v32) = a6;
    --v24;
    if (a1[2] == a1[1])
    {
      ((void (*)(void))a1[3])(*a1);
      a1[2] = 0;
      char v24 = v29;
    }
  }

  return std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a1, v19, v15);
}

void *std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(void *result, char *__src, size_t __len)
{
  size_t v3 = __len;
  unint64_t v5 = result;
  size_t v7 = result[1];
  uint64_t v6 = result[2];
  if (v6 + __len >= v7)
  {
    uint64_t result = (void *)((uint64_t (*)(void))result[3])(*result);
    uint64_t v6 = 0;
    v5[2] = 0;
    size_t v7 = v5[1];
  }
  if (v3 >= v7)
  {
    do
    {
      if (v5[1] >= v3) {
        size_t v8 = v3;
      }
      else {
        size_t v8 = v5[1];
      }
      if (v8) {
        memmove((void *)(*v5 + v6), __src, v8);
      }
      v5[2] = v8;
      __src += v8;
      v3 -= v8;
      uint64_t result = (void *)((uint64_t (*)(void, size_t, void))v5[3])(*v5, v8, v5[4]);
      uint64_t v6 = 0;
      v5[2] = 0;
    }
    while (v3);
  }
  else
  {
    if (v3)
    {
      uint64_t result = memmove((void *)(*v5 + v6), __src, v3);
      uint64_t v6 = v5[2];
    }
    v5[2] = v6 + v3;
  }
  return result;
}

void *std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(char *__src, size_t __len, void *a3, uint64_t a4, unint64_t a5, uint64_t a6)
{
  size_t v9 = (a4 >> 32) - a6;
  if (a4 >> 32 <= a6)
  {
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(a3, __src, __len);
  }
  else
  {
    unint64_t v10 = HIDWORD(a5);
    size_t v11 = 0;
    switch(a4 & 7)
    {
      case 1:
        break;
      case 2:
        size_t v11 = v9 >> 1;
        v9 -= v9 >> 1;
        break;
      default:
        size_t v11 = (a4 >> 32) - a6;
        size_t v9 = 0;
        break;
    }
    unsigned int v12 = std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a3, v11, SHIDWORD(a5));
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v12, __src, __len);
    std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a3, v9, v10);
  }
  return a3;
}

void *std::__formatter::__write_transformed[abi:ne180100]<char *,char,char,char (*)(char),std::back_insert_iterator<std::__format::__output_buffer<char>>>(char *a1, char *a2, void *a3, uint64_t a4, unint64_t a5)
{
  size_t v8 = (a4 >> 32) - (a2 - a1);
  if (a4 >> 32 <= a2 - a1)
  {
    std::__format::__output_buffer<char>::__transform[abi:ne180100]<char *,char (*)(char),char>((uint64_t)a3, a1, a2);
  }
  else
  {
    unint64_t v9 = HIDWORD(a5);
    size_t v10 = 0;
    switch(a4 & 7)
    {
      case 1:
        break;
      case 2:
        size_t v10 = v8 >> 1;
        v8 -= v8 >> 1;
        break;
      default:
        size_t v10 = v8;
        size_t v8 = 0;
        break;
    }
    size_t v11 = std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a3, v10, SHIDWORD(a5));
    std::__format::__output_buffer<char>::__transform[abi:ne180100]<char *,char (*)(char),char>((uint64_t)v11, a1, a2);
    std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a3, v8, v9);
  }
  return a3;
}

uint64_t std::__format::__output_buffer<char>::__transform[abi:ne180100]<char *,char (*)(char),char>(uint64_t result, char *a2, char *a3)
{
  int v4 = a2;
  uint64_t v5 = result;
  unint64_t v6 = a3 - a2;
  unint64_t v8 = *(void *)(result + 8);
  uint64_t v7 = *(void *)(result + 16);
  if (v7 + v6 >= v8)
  {
    uint64_t result = (*(uint64_t (**)(void))(result + 24))(*(void *)result);
    uint64_t v7 = 0;
    *(void *)(v5 + 16) = 0;
    unint64_t v8 = *(void *)(v5 + 8);
  }
  if (v6 >= v8)
  {
    do
    {
      uint64_t v13 = *(void *)v5;
      unint64_t v14 = *(void *)(v5 + 8);
      if (v14 >= v6) {
        unint64_t v14 = v6;
      }
      if (v14)
      {
        unint64_t v15 = (unsigned char *)(v13 + v7);
        unint64_t v16 = v14;
        uint64_t v17 = v4;
        do
        {
          int v19 = *v17++;
          char v18 = v19;
          char v20 = v19 - 32;
          if ((v19 - 97) < 6) {
            char v18 = v20;
          }
          *v15++ = v18;
          --v16;
        }
        while (v16);
        uint64_t v13 = *(void *)v5;
      }
      v4 += v14;
      *(void *)(v5 + 16) = v14;
      v6 -= v14;
      uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t, void))(v5 + 24))(v13, v14, *(void *)(v5 + 32));
      uint64_t v7 = 0;
      *(void *)(v5 + 16) = 0;
    }
    while (v6);
  }
  else
  {
    if (v4 != a3)
    {
      unint64_t v9 = (unsigned char *)(*(void *)v5 + v7);
      do
      {
        int v11 = *v4++;
        char v10 = v11;
        char v12 = v11 - 32;
        if ((v11 - 97) < 6) {
          char v10 = v12;
        }
        *v9++ = v10;
      }
      while (v4 != a3);
      uint64_t v7 = *(void *)(v5 + 16);
    }
    *(void *)(v5 + 16) = v7 + v6;
  }
  return result;
}

void *std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(void *a1, size_t __len, int a3)
{
  size_t v3 = __len;
  unsigned int v5 = __clz(~(_BYTE)a3) - 24;
  int __src = a3;
  if ((_BYTE)a3 == 0xFF) {
    size_t v6 = 8;
  }
  else {
    size_t v6 = v5;
  }
  if (v6)
  {
    if (__len)
    {
      do
      {
        std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(a1, (char *)&__src, v6);
        --v3;
      }
      while (v3);
    }
  }
  else
  {
    std::__format::__output_buffer<char>::__fill[abi:ne180100](a1, __len, (char)a3);
  }
  return a1;
}

void *std::__format::__output_buffer<char>::__fill[abi:ne180100](void *result, size_t __len, int __c)
{
  uint64_t v5 = (uint64_t)result;
  size_t v7 = result[1];
  uint64_t v6 = result[2];
  if (v6 + __len >= v7)
  {
    uint64_t result = (void *)((uint64_t (*)(void))result[3])(*result);
    uint64_t v6 = 0;
    *(void *)(v5 + 16) = 0;
    size_t v7 = *(void *)(v5 + 8);
  }
  if (v7 <= __len)
  {
    do
    {
      uint64_t v8 = *(void *)v5;
      if (*(void *)(v5 + 8) >= __len) {
        size_t v9 = __len;
      }
      else {
        size_t v9 = *(void *)(v5 + 8);
      }
      if (v9)
      {
        memset((void *)(v8 + v6), __c, v9);
        uint64_t v8 = *(void *)v5;
      }
      *(void *)(v5 + 16) = v9;
      __len -= v9;
      uint64_t result = (void *)(*(uint64_t (**)(uint64_t, size_t, void))(v5 + 24))(v8, v9, *(void *)(v5 + 32));
      uint64_t v6 = 0;
      *(void *)(v5 + 16) = 0;
    }
    while (__len);
  }
  else
  {
    if (__len)
    {
      uint64_t result = memset((void *)(*(void *)v5 + v6), __c, __len);
      uint64_t v6 = *(void *)(v5 + 16);
    }
    *(void *)(v5 + 16) = v6 + __len;
  }
  return result;
}

char *std::__itoa::__traits_base<unsigned long long,void>::__convert[abi:ne180100](char *a1, unint64_t a2)
{
  unint64_t v2 = a2;
  if (HIDWORD(a2))
  {
    if (a2 > 0x2540BE3FFLL)
    {
      unint64_t v4 = a2 / 0x2540BE400;
      a1 = std::__itoa::__base_10_u32[abi:ne180100](a1, a2 / 0x2540BE400);
      v2 -= 10000000000 * v4;
    }
    return (char *)std::__itoa::__append10[abi:ne180100]<unsigned long long>(a1, v2);
  }
  else
  {
    return std::__itoa::__base_10_u32[abi:ne180100](a1, a2);
  }
}

uint64_t std::__itoa::__integral<2u>::__to_chars[abi:ne180100]<unsigned long long>(uint64_t a1, uint64_t a2, unint64_t a3)
{
  int64_t v3 = 64 - __clz(a3 | 1);
  if (a2 - a1 < v3) {
    return a2;
  }
  uint64_t v4 = a1 + v3;
  if (a3 < 0x11)
  {
    unint64_t v6 = a3;
    uint64_t v5 = v4;
  }
  else
  {
    uint64_t v5 = a1 + v3;
    do
    {
      unint64_t v6 = a3 >> 4;
      *(_DWORD *)(v5 - 4) = std::__itoa::__base_2_lut[a3 & 0xF];
      v5 -= 4;
      BOOL v7 = a3 > 0x10F;
      a3 >>= 4;
    }
    while (v7);
  }
  uint64_t v8 = (unsigned char *)(v5 - 1);
  do
  {
    *v8-- = a01[v6 & 1];
    BOOL v7 = v6 > 1;
    v6 >>= 1;
  }
  while (v7);
  return v4;
}

uint64_t std::__itoa::__integral<8u>::__to_chars[abi:ne180100]<unsigned long long>(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v3 = (86 * (66 - __clz(a3 | 1))) >> 8;
  if (a2 - a1 < v3) {
    return a2;
  }
  uint64_t v4 = a1 + v3;
  if (a3 < 0x41)
  {
    unint64_t v6 = a3;
    uint64_t v5 = v4;
  }
  else
  {
    uint64_t v5 = a1 + v3;
    do
    {
      unint64_t v6 = a3 >> 6;
      *(_WORD *)(v5 - 2) = std::__itoa::__base_8_lut[a3 & 0x3F];
      v5 -= 2;
      a3 = v6;
    }
    while (v6 > 0x40);
  }
  BOOL v7 = (unsigned char *)(v5 - 1);
  do
  {
    *v7-- = a01234567[v6 & 7];
    BOOL v8 = v6 > 7;
    v6 >>= 3;
  }
  while (v8);
  return v4;
}

uint64_t std::__itoa::__integral<16u>::__to_chars[abi:ne180100]<unsigned long long>(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = 67 - __clz(a3 | 1);
  if (a2 - a1 < (uint64_t)(v3 >> 2)) {
    return a2;
  }
  uint64_t v4 = a1 + (v3 >> 2);
  if (a3 < 0x101)
  {
    unint64_t v6 = a3;
    uint64_t v5 = v4;
  }
  else
  {
    uint64_t v5 = a1 + (v3 >> 2);
    do
    {
      unint64_t v6 = a3 >> 8;
      *(_WORD *)(v5 - 2) = *(_WORD *)&std::__itoa::__base_16_lut[2 * a3];
      v5 -= 2;
      a3 = v6;
    }
    while (v6 > 0x100);
  }
  BOOL v7 = (unsigned char *)(v5 - 1);
  do
  {
    *v7-- = a0123456789abcd_0[v6 & 0xF];
    BOOL v8 = v6 > 0xF;
    v6 >>= 4;
  }
  while (v8);
  return v4;
}

uint64_t std::__to_chars_integral_width[abi:ne180100]<unsigned long long>(unint64_t a1, unsigned int a2)
{
  if (a2 > a1) {
    return 1;
  }
  int v3 = 0;
  unint64_t v4 = a2 * a2;
  unint64_t v5 = (v4 * v4);
  while (1)
  {
    if (a1 < v4) {
      return v3 | 2u;
    }
    if (a1 < v4 * a2) {
      return v3 | 3u;
    }
    if (a1 < v5) {
      break;
    }
    a1 /= v5;
    v3 += 4;
    if (a1 < a2) {
      return v3 | 1u;
    }
  }
  return (v3 + 4);
}

char *std::__itoa::__base_10_u32[abi:ne180100](_WORD *a1, unsigned int a2)
{
  if (a2 >= 0xF4240)
  {
    if (a2 >= 0x5F5E100)
    {
      unsigned int v7 = a2 / 0x5F5E100;
      if (a2 > 0x3B9AC9FF)
      {
        *a1 = std::__itoa::__digits_base_10[v7];
        a1[1] = std::__itoa::__digits_base_10[a2 % 0x5F5E100 / 0xF4240];
        a1[2] = std::__itoa::__digits_base_10[a2 % 0x5F5E100 % 0xF4240 / 0x2710uLL];
        unsigned __int16 v12 = a2 % 0x5F5E100 % 0xF4240 % 0x2710;
        a1[3] = std::__itoa::__digits_base_10[v12 / 0x64u];
        a1[4] = std::__itoa::__digits_base_10[v12 % 0x64u];
        uint64_t v2 = 10;
      }
      else
      {
        *(unsigned char *)a1 = v7 + 48;
        *(_WORD *)((char *)a1 + 1) = std::__itoa::__digits_base_10[a2 % 0x5F5E100 / 0xF4240];
        *(_WORD *)((char *)a1 + 3) = std::__itoa::__digits_base_10[a2 % 0x5F5E100 % 0xF4240 / 0x2710uLL];
        unsigned __int16 v8 = a2 % 0x5F5E100 % 0xF4240 % 0x2710;
        *(_WORD *)((char *)a1 + 5) = std::__itoa::__digits_base_10[v8 / 0x64u];
        *(_WORD *)((char *)a1 + 7) = std::__itoa::__digits_base_10[v8 % 0x64u];
        uint64_t v2 = 9;
      }
    }
    else
    {
      unsigned int v3 = a2 / 0xF4240;
      if (a2 > 0x98967F)
      {
        *a1 = std::__itoa::__digits_base_10[v3];
        a1[1] = std::__itoa::__digits_base_10[a2 % 0xF4240 / 0x2710uLL];
        unsigned __int16 v10 = a2 % 0xF4240 % 0x2710;
        a1[2] = std::__itoa::__digits_base_10[v10 / 0x64u];
        a1[3] = std::__itoa::__digits_base_10[v10 % 0x64u];
        uint64_t v2 = 8;
      }
      else
      {
        *(unsigned char *)a1 = v3 + 48;
        *(_WORD *)((char *)a1 + 1) = std::__itoa::__digits_base_10[a2 % 0xF4240 / 0x2710uLL];
        unsigned __int16 v4 = a2 % 0xF4240 % 0x2710;
        *(_WORD *)((char *)a1 + 3) = std::__itoa::__digits_base_10[v4 / 0x64u];
        *(_WORD *)((char *)a1 + 5) = std::__itoa::__digits_base_10[v4 % 0x64u];
        uint64_t v2 = 7;
      }
    }
  }
  else if (a2 >> 4 > 0x270)
  {
    unsigned int v5 = a2 / 0x2710;
    if (a2 >> 5 > 0xC34)
    {
      *a1 = std::__itoa::__digits_base_10[v5];
      unsigned __int16 v11 = a2 % 0x2710;
      a1[1] = std::__itoa::__digits_base_10[v11 / 0x64u];
      a1[2] = std::__itoa::__digits_base_10[v11 % 0x64u];
      uint64_t v2 = 6;
    }
    else
    {
      *(unsigned char *)a1 = v5 + 48;
      unsigned __int16 v6 = a2 % 0x2710;
      *(_WORD *)((char *)a1 + 1) = std::__itoa::__digits_base_10[v6 / 0x64u];
      *(_WORD *)((char *)a1 + 3) = std::__itoa::__digits_base_10[v6 % 0x64u];
      uint64_t v2 = 5;
    }
  }
  else if (a2 > 0x63)
  {
    unsigned int v9 = (unsigned __int16)a2 / 0x64u;
    if (a2 > 0x3E7)
    {
      *a1 = std::__itoa::__digits_base_10[v9];
      a1[1] = std::__itoa::__digits_base_10[(unsigned __int16)a2 % 0x64u];
      uint64_t v2 = 4;
    }
    else
    {
      *(unsigned char *)a1 = v9 + 48;
      *(_WORD *)((char *)a1 + 1) = std::__itoa::__digits_base_10[(unsigned __int16)a2 % 0x64u];
      uint64_t v2 = 3;
    }
  }
  else if (a2 > 9)
  {
    *a1 = std::__itoa::__digits_base_10[a2];
    uint64_t v2 = 2;
  }
  else
  {
    *(unsigned char *)a1 = a2 + 48;
    uint64_t v2 = 1;
  }
  return (char *)a1 + v2;
}

_WORD *std::__itoa::__append10[abi:ne180100]<unsigned long long>(_WORD *a1, unint64_t a2)
{
  *a1 = std::__itoa::__digits_base_10[(a2 / 0x5F5E100)];
  unsigned int v2 = a2 % 0x5F5E100;
  a1[1] = std::__itoa::__digits_base_10[v2 / 0xF4240uLL];
  v2 %= 0xF4240u;
  a1[2] = std::__itoa::__digits_base_10[v2 / 0x2710uLL];
  LOWORD(v2) = v2 % 0x2710;
  a1[3] = std::__itoa::__digits_base_10[(unsigned __int16)v2 / 0x64u];
  a1[4] = std::__itoa::__digits_base_10[(unsigned __int16)v2 % 0x64u];
  return a1 + 5;
}

unint64_t std::__visit_format_arg[abi:ne180100]<unsigned int std::__format_spec::__substitute_arg_id[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(std::basic_format_arg<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>)::{lambda(std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>)#1},std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(unsigned int *a1)
{
  switch(*((unsigned char *)a1 + 16))
  {
    case 1:
    case 2:
    case 5:
    case 8:
    case 9:
    case 0xA:
    case 0xB:
    case 0xC:
    case 0xD:
    case 0xE:
    case 0xF:
      std::__throw_format_error[abi:ne180100]("Replacement argument isn't a standard signed or unsigned integer type");
    case 3:
      unint64_t result = *a1;
      if ((result & 0x80000000) != 0) {
        goto LABEL_13;
      }
      return result;
    case 4:
      unint64_t result = *(void *)a1;
      if ((result & 0x8000000000000000) != 0) {
LABEL_13:
      }
        std::__throw_format_error[abi:ne180100]("An argument index may not have a negative value");
      if (result >> 31) {
        goto LABEL_12;
      }
      return result;
    case 6:
      unint64_t result = *a1;
      if ((result & 0x80000000) != 0) {
        goto LABEL_12;
      }
      return result;
    case 7:
      unint64_t result = *(void *)a1;
      if (result >> 31) {
LABEL_12:
      }
        std::__throw_format_error[abi:ne180100]("The value of the argument index exceeds its maximum value");
      return result;
    default:
      std::__throw_format_error[abi:ne180100]("The argument index value is too large for the number of arguments supplied");
  }
}

unsigned __int8 *std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>(uint64_t a1, char **a2, char a3)
{
  unsigned __int16 v4 = *a2;
  unsigned int v3 = (unsigned __int8 *)a2[1];
  if (*a2 == (char *)v3) {
    return (unsigned __int8 *)*a2;
  }
  v28[0] = (unsigned __int8 *)*a2;
  v28[1] = v3;
  if ((std::__unicode::__code_point_view<char>::__consume[abi:ne180100](v28) & 0x80000000) != 0) {
    std::__throw_format_error[abi:ne180100]("The format specifier contains malformed Unicode characters");
  }
  unsigned __int16 v8 = v28[0];
  if (v28[0] >= v3) {
    goto LABEL_8;
  }
  int v9 = (char)*v28[0];
  switch(v9)
  {
    case '<':
      char v10 = 1;
      goto LABEL_18;
    case '>':
      char v10 = 3;
LABEL_18:
      *(unsigned char *)a1 = *(unsigned char *)a1 & 0xF8 | v10;
      size_t v14 = v8 - (unsigned __int8 *)v4;
      if (v8 - (unsigned __int8 *)v4 == 1)
      {
        int v15 = *v4;
        if (v15 == 125 || v15 == 123) {
          std::__throw_format_error[abi:ne180100]("The fill option contains an invalid value");
        }
      }
      else if (v8 == (unsigned __int8 *)v4)
      {
LABEL_24:
        uint64_t v13 = v14 + 1;
        goto LABEL_25;
      }
      memmove((void *)(a1 + 12), v4, v14);
      goto LABEL_24;
    case '^':
      char v10 = 2;
      goto LABEL_18;
  }
LABEL_8:
  int v11 = *v4;
  switch(v11)
  {
    case '<':
      char v12 = 1;
      break;
    case '>':
      char v12 = 3;
      break;
    case '^':
      char v12 = 2;
      break;
    default:
      goto LABEL_26;
  }
  *(unsigned char *)a1 = *(unsigned char *)a1 & 0xF8 | v12;
  uint64_t v13 = 1;
LABEL_25:
  v4 += v13;
  if (v4 == (char *)v3) {
    return v3;
  }
LABEL_26:
  if ((a3 & 1) == 0) {
    goto LABEL_34;
  }
  int v16 = *v4;
  switch(v16)
  {
    case ' ':
      char v17 = *(unsigned char *)a1 | 0x18;
      goto LABEL_33;
    case '+':
      char v17 = *(unsigned char *)a1 & 0xE7 | 0x10;
LABEL_33:
      *(unsigned char *)a1 = v17;
      if (++v4 == (char *)v3) {
        return v3;
      }
      break;
    case '-':
      char v17 = *(unsigned char *)a1 & 0xE7 | 8;
      goto LABEL_33;
  }
LABEL_34:
  if ((a3 & 2) != 0 && *v4 == 35)
  {
    *(unsigned char *)a1 |= 0x20u;
    if (++v4 == (char *)v3) {
      return v3;
    }
  }
  if ((a3 & 4) == 0) {
    goto LABEL_42;
  }
  int v18 = *v4;
  if (v18 != 48) {
    goto LABEL_43;
  }
  if ((*(unsigned char *)a1 & 7) == 0) {
    *(unsigned char *)a1 = *(unsigned char *)a1 & 0xF8 | 4;
  }
  if (++v4 != (char *)v3)
  {
LABEL_42:
    int v18 = *v4;
LABEL_43:
    if (v18 == 123)
    {
      unsigned __int16 v4 = std::__format_spec::__parse_arg_id[abi:ne180100]<char const*,std::basic_format_parse_context<char>>(v4 + 1, (char *)v3, (uint64_t)a2);
      *(_WORD *)(a1 + 2) |= 0x4000u;
    }
    else
    {
      if (v18 == 48) {
        std::__throw_format_error[abi:ne180100]("The width option should not have a leading zero");
      }
      if ((v18 - 58) < 0xFFFFFFF6)
      {
LABEL_49:
        if ((a3 & 8) == 0 || *v4 != 46) {
          goto LABEL_89;
        }
        char v20 = (unsigned __int8 *)(v4 + 1);
        if (v4 + 1 == (char *)v3) {
          std::__throw_format_error[abi:ne180100]("End of input while parsing format specifier precision");
        }
        int v21 = *v20;
        if (v21 == 123)
        {
          unsigned __int16 v4 = std::__format_spec::__parse_arg_id[abi:ne180100]<char const*,std::basic_format_parse_context<char>>(v4 + 2, (char *)v3, (uint64_t)a2);
          *(_WORD *)(a1 + 2) |= 0x8000u;
          *(_DWORD *)(a1 + 8) = v22;
        }
        else
        {
          if ((v21 - 58) <= 0xFFFFFFF5) {
            std::__throw_format_error[abi:ne180100]("The precision option does not contain a value or an argument index");
          }
          unsigned __int16 v4 = std::__format::__parse_number[abi:ne180100]<char const*>((unint64_t)v20, (char *)v3);
          *(_DWORD *)(a1 + 8) = v23;
          *(_WORD *)(a1 + 2) &= ~0x8000u;
        }
        if (v3 != (unsigned __int8 *)v4)
        {
LABEL_89:
          if ((a3 & 0x10) == 0 || *v4 != 76 || (*(unsigned char *)a1 |= 0x40u, ++v4, v4 != (char *)v3))
          {
            int v24 = *v4;
            if (v24 <= 96)
            {
              int v26 = v24 - 65;
              char v25 = 12;
              switch(v26)
              {
                case 0:
                  goto LABEL_78;
                case 1:
                  char v25 = 3;
                  goto LABEL_78;
                case 4:
                  char v25 = 14;
                  goto LABEL_78;
                case 5:
                  char v25 = 16;
                  goto LABEL_78;
                case 6:
                  char v25 = 18;
LABEL_78:
                  *(unsigned char *)(a1 + 1) = v25;
                  ++v4;
                  break;
                default:
                  break;
              }
            }
            else
            {
              switch(*v4)
              {
                case 'a':
                  char v25 = 11;
                  goto LABEL_78;
                case 'b':
                  char v25 = 2;
                  goto LABEL_78;
                case 'c':
                  char v25 = 10;
                  goto LABEL_78;
                case 'd':
                  char v25 = 5;
                  goto LABEL_78;
                case 'e':
                  char v25 = 13;
                  goto LABEL_78;
                case 'f':
                  char v25 = 15;
                  goto LABEL_78;
                case 'g':
                  char v25 = 17;
                  goto LABEL_78;
                case 'o':
                  char v25 = 4;
                  goto LABEL_78;
                case 'p':
                  char v25 = 8;
                  goto LABEL_78;
                case 's':
                  char v25 = 1;
                  goto LABEL_78;
                case 'x':
                  char v25 = 6;
                  goto LABEL_78;
                default:
                  break;
              }
            }
            if (v4 != (char *)v3)
            {
              unsigned int v3 = (unsigned __int8 *)v4;
              if (*v4 != 125) {
                std::__throw_format_error[abi:ne180100]("The format specifier should consume the input or end with a '}'");
              }
            }
          }
        }
        return v3;
      }
      unsigned __int16 v4 = std::__format::__parse_number[abi:ne180100]<char const*>((unint64_t)v4, (char *)v3);
    }
    *(_DWORD *)(a1 + 4) = v19;
    if (v3 == (unsigned __int8 *)v4) {
      return v3;
    }
    goto LABEL_49;
  }
  return v3;
}

void std::__format_spec::__throw_invalid_type_format_error[abi:ne180100](const char *a1)
{
  std::string::basic_string[abi:ne180100]<0>(&v8, "The type option contains an invalid value for ");
  size_t v2 = strlen(a1);
  unsigned int v3 = std::string::append(&v8, a1, v2);
  long long v4 = *(_OWORD *)&v3->__r_.__value_.__l.__data_;
  v9.__r_.__value_.__r.__words[2] = v3->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v9.__r_.__value_.__l.__data_ = v4;
  v3->__r_.__value_.__l.__size_ = 0;
  v3->__r_.__value_.__r.__words[2] = 0;
  v3->__r_.__value_.__r.__words[0] = 0;
  unsigned int v5 = std::string::append(&v9, " formatting argument", 0x14uLL);
  long long v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
  int64_t v11 = v5->__r_.__value_.__r.__words[2];
  long long v10 = v6;
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if (v11 >= 0) {
    unsigned int v7 = (const char *)&v10;
  }
  else {
    unsigned int v7 = (const char *)v10;
  }
  std::__throw_format_error[abi:ne180100](v7);
}

void sub_1BB3636C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (*(char *)(v21 - 25) < 0) {
    operator delete(*(void **)(v21 - 48));
  }
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

char *std::__format_spec::__parse_arg_id[abi:ne180100]<char const*,std::basic_format_parse_context<char>>(char *a1, char *a2, uint64_t a3)
{
  if (a1 == a2) {
    std::__throw_format_error[abi:ne180100]("End of input while parsing an argument index");
  }
  long long v4 = std::__format::__parse_arg_id[abi:ne180100]<char const*,std::basic_format_parse_context<char>>(a1, a2, a3);
  if (v4 == a2 || *v4 != 125) {
    std::__throw_format_error[abi:ne180100]("The argument index is invalid");
  }
  return v4 + 1;
}

char *std::__format::__parse_number[abi:ne180100]<char const*>(unint64_t a1, char *a2)
{
  if ((uint64_t)&a2[-a1] <= 9) {
    size_t v2 = (unsigned __int8 *)a2;
  }
  else {
    size_t v2 = (unsigned __int8 *)(a1 + 9);
  }
  unsigned int v3 = (unsigned __int8 *)(a1 + 1);
  unsigned int v4 = *(char *)a1 - 48;
  if ((unsigned __int8 *)(a1 + 1) == v2)
  {
LABEL_8:
    if (v2 == (unsigned __int8 *)a2)
    {
      return a2;
    }
    else
    {
      uint64_t v6 = *v2;
      if ((v6 - 48) > 9)
      {
        return (char *)v2;
      }
      else if ((v6 + 10 * (unint64_t)v4 - 48) >> 31 {
             || (unsigned int v3 = (unsigned __int8 *)(a1 + 2), (char *)(a1 + 2) != a2) && *v3 - 48 <= 9)
      }
      {
        std::__throw_format_error[abi:ne180100]("The numeric value of the format specifier is too large");
      }
    }
  }
  else
  {
    a1 += (unint64_t)&v2[~a1];
    while (1)
    {
      int v5 = *v3;
      if ((v5 - 58) < 0xFFFFFFF6) {
        break;
      }
      unsigned int v4 = v5 + 10 * v4 - 48;
      if (++v3 == v2) {
        goto LABEL_8;
      }
    }
  }
  return (char *)v3;
}

uint64_t std::__unicode::__code_point_view<char>::__consume[abi:ne180100](unsigned __int8 **a1)
{
  uint64_t v1 = *a1;
  int v2 = **a1;
  unsigned int v3 = __clz(v2 ^ 0xFF) - 24;
  if (v2 == 255) {
    int v4 = 8;
  }
  else {
    int v4 = v3;
  }
  switch(v4)
  {
    case 0:
      *a1 = v1 + 1;
      uint64_t v5 = *v1;
      break;
    case 2:
      if (a1[1] - v1 < 2 || (v1[1] & 0xC0) != 0x80) {
        goto LABEL_35;
      }
      *a1 = v1 + 1;
      char v6 = *v1;
      *a1 = v1 + 2;
      unsigned int v7 = v1[1] & 0x3F | ((v6 & 0x1F) << 6);
      if (v7 >= 0x80) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = 2147549181;
      }
      break;
    case 3:
      if (a1[1] - v1 < 3) {
        goto LABEL_35;
      }
      uint64_t v8 = 1;
      do
        int v9 = v1[v8] & 0xC0;
      while (v9 == 128 && v8++ != 2);
      if (v9 != 128) {
        goto LABEL_35;
      }
      uint64_t v5 = 2147549181;
      *a1 = v1 + 1;
      int v11 = *v1 & 0xF;
      *a1 = v1 + 2;
      int v12 = (v11 << 12) | ((v1[1] & 0x3F) << 6);
      *a1 = v1 + 3;
      unsigned int v13 = v12 & 0xFFFFFFC0 | v1[2] & 0x3F;
      if (v13 >= 0x800)
      {
        if ((v12 & 0xF800) == 0xD800) {
          uint64_t v5 = 2147549181;
        }
        else {
          uint64_t v5 = v13;
        }
      }
      break;
    case 4:
      if (a1[1] - v1 < 4) {
        goto LABEL_35;
      }
      uint64_t v14 = 1;
      do
        int v15 = v1[v14] & 0xC0;
      while (v15 == 128 && v14++ != 3);
      if (v15 != 128) {
        goto LABEL_35;
      }
      uint64_t v5 = 2147549181;
      *a1 = v1 + 1;
      int v17 = *v1 & 7;
      *a1 = v1 + 2;
      int v18 = (v17 << 12) | ((v1[1] & 0x3F) << 6);
      *a1 = v1 + 3;
      unsigned int v19 = v18 & 0xFFFFFFC0 | v1[2] & 0x3F;
      *a1 = v1 + 4;
      unsigned int v20 = v1[3] & 0x3F | (v19 << 6);
      if (v20 >= 0x10000)
      {
        if (v20 >= 0x110000) {
          uint64_t v5 = 2147549181;
        }
        else {
          uint64_t v5 = v20;
        }
      }
      break;
    default:
LABEL_35:
      uint64_t v5 = 2147549181;
      *a1 = v1 + 1;
      break;
  }
  return v5;
}

unsigned __int8 *std::__formatter_string<char>::parse[abi:ne180100]<std::basic_format_parse_context<char>>(uint64_t a1, char **a2)
{
  unint64_t result = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>(a1, a2, 40);
  unsigned int v4 = *(unsigned __int8 *)(a1 + 1);
  if (v4 >= 2 && v4 != 19) {
    std::__throw_format_error[abi:ne180100]("The type option contains an invalid value for a string formatting argument");
  }
  return result;
}

void *std::__formatter::__write_string[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(char *__src, size_t a2, void *a3, uint64_t a4, unint64_t a5)
{
  if ((a5 & 0x80000000) != 0)
  {
    return std::__formatter::__write_string_no_precision[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(__src, a2, a3, a4, a5);
  }
  else
  {
    int v9 = std::__format_spec::__estimate_column_width[abi:ne180100]<char,char const*>((unsigned __int8 *)__src, a2, a5, 0);
    size_t v11 = v10 - (void)__src;
    return std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(__src, v11, a3, a4, a5, v9);
  }
}

void *std::__formatter::__write_string_no_precision[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(char *__src, size_t __len, void *a3, uint64_t a4, unint64_t a5)
{
  if (a4 <= 0)
  {
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(a3, __src, __len);
  }
  else
  {
    unint64_t v10 = std::__format_spec::__estimate_column_width[abi:ne180100]<char,char const*>((unsigned __int8 *)__src, __len, HIDWORD(a4), 1);
    std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(__src, __len, a3, a4, a5, v10);
  }
  return a3;
}

unint64_t std::__format_spec::__estimate_column_width[abi:ne180100]<char,char const*>(unsigned __int8 *a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t result = 0;
  if (a2)
  {
    unint64_t v6 = a3;
    if (a3)
    {
      if ((char)*a1 < 0)
      {
        int v9 = a1;
      }
      else
      {
        uint64_t v8 = 0;
        int v9 = &a1[a3 - 1];
        while (1)
        {
          if (a2 - 1 == v8) {
            return a2;
          }
          if (a3 - 1 == v8) {
            break;
          }
          int v10 = (char)a1[++v8];
          if (v10 < 0)
          {
            unint64_t v6 = a3 - v8 + 1;
            int v9 = &a1[v8 - 1];
            goto LABEL_10;
          }
        }
        if (((char)a1[a3] & 0x80000000) == 0) {
          return a3;
        }
        unint64_t v6 = 1;
      }
LABEL_10:
      int64_t v38 = v9 - a1;
      size_t v11 = &a1[a2];
      int v41 = v9;
      unint64_t v42 = &a1[a2];
      int v12 = std::__unicode::__code_point_view<char>::__consume[abi:ne180100](&v41);
      uint64_t v13 = v12 & 0x7FFFFFFF;
      int v43 = v12 & 0x7FFFFFFF;
      LOBYTE(v14) = std::__extended_grapheme_custer_property_boundary::__get_property[abi:ne180100](v12 & 0x7FFFFFFF);
      char v44 = v14;
      if (v9 != v11)
      {
        unint64_t v15 = 0;
        unint64_t v40 = v11;
        while (1)
        {
          int v16 = v41;
          if (v41 == v42)
          {
            uint64_t v20 = v13;
LABEL_53:
            LOBYTE(v14) = 15;
            char v44 = 15;
            goto LABEL_54;
          }
          int v17 = 0;
          int v18 = 1;
          char v19 = v14;
          uint64_t v20 = v13;
          while (2)
          {
            uint64_t v21 = a4;
            int v39 = v18;
            LOBYTE(v14) = v19;
            while (1)
            {
              do
              {
                while (1)
                {
                  do
                  {
                    int v22 = v17;
                    int v16 = v41;
                    if (v41 == v42)
                    {
                      a4 = v21;
                      size_t v11 = v40;
                      goto LABEL_53;
                    }
                    unsigned __int8 v23 = v14;
                    int v24 = std::__unicode::__code_point_view<char>::__consume[abi:ne180100](&v41);
                    uint64_t v20 = v24 & 0x7FFFFFFF;
                    int v43 = v24 & 0x7FFFFFFF;
                    unsigned int v14 = std::__extended_grapheme_custer_property_boundary::__get_property[abi:ne180100](v24 & 0x7FFFFFFF);
                    char v44 = v14;
                    int v17 = v22 | (v23 == 3);
                  }
                  while (!v23 && v14 == 5);
                  if (v23 <= 5u && ((1 << v23) & 0x23) != 0 || v14 <= 5 && ((1 << v14) & 0x23) != 0) {
                    goto LABEL_49;
                  }
                  if (v23 == 12 || v23 == 6) {
                    break;
                  }
                  if (v23 != 4 || v14 - 4 >= 9 || ((0x10Du >> (v14 - 4)) & 1) == 0) {
                    goto LABEL_29;
                  }
                }
              }
              while ((v14 - 11) < 2u);
LABEL_29:
              BOOL v25 = v23 == 11 || v23 == 7;
              if ((!v25 || v14 != 11) && (v14 > 0xD || ((1 << v14) & 0x2404) == 0) && v23 != 8)
              {
                BOOL v26 = v23 == 13 && v14 == 3;
                BOOL v27 = v26;
                if ((v27 & v22 & 1) == 0) {
                  break;
                }
              }
            }
            if (v23 != 9)
            {
LABEL_49:
              a4 = v21;
LABEL_50:
              size_t v11 = v40;
              break;
            }
            a4 = v21;
            if (v14 != 9) {
              goto LABEL_50;
            }
            int v18 = v39 ^ 1;
            char v19 = 9;
            size_t v11 = v40;
            if (v39) {
              continue;
            }
            break;
          }
LABEL_54:
          if ((v13 - 262142) < 0xFFFC1102) {
            goto LABEL_64;
          }
          unint64_t v28 = 108;
          uint64_t v29 = (unsigned int *)&std::__width_estimation_table::__entries;
          do
          {
            unint64_t v30 = v28 >> 1;
            uint64_t v31 = &v29[v28 >> 1];
            unsigned int v33 = *v31;
            uint64_t v32 = v31 + 1;
            v28 += ~(v28 >> 1);
            if (((v13 << 14) | 0x3FFFu) < v33) {
              unint64_t v28 = v30;
            }
            else {
              uint64_t v29 = v32;
            }
          }
          while (v28);
          if (v29 == (unsigned int *)&std::__width_estimation_table::__entries)
          {
LABEL_64:
            uint64_t v35 = 1;
          }
          else
          {
            BOOL v34 = (*(v29 - 1) & 0x3FFF) + (*(v29 - 1) >> 14) >= v13;
            uint64_t v35 = 1;
            if (v34) {
              uint64_t v35 = 2;
            }
          }
          unint64_t v36 = v15 + v35;
          if (a4 || v36 <= v6)
          {
            BOOL v37 = v16 == v11 || v36 > v6;
            uint64_t v13 = v20;
            unint64_t v15 = v36;
            if (!v37) {
              continue;
            }
          }
          return v38 + v15;
        }
      }
      unint64_t v15 = 0;
      return v38 + v15;
    }
  }
  return result;
}

uint64_t std::__extended_grapheme_custer_property_boundary::__get_property[abi:ne180100](unsigned int a1)
{
  unint64_t v1 = 1496;
  int v2 = (unsigned int *)&std::__extended_grapheme_custer_property_boundary::__entries;
  do
  {
    unint64_t v3 = v1 >> 1;
    unsigned int v4 = &v2[v1 >> 1];
    unsigned int v6 = *v4;
    uint64_t v5 = v4 + 1;
    v1 += ~(v1 >> 1);
    if (((a1 << 11) | 0x7FF) < v6) {
      unint64_t v1 = v3;
    }
    else {
      int v2 = v5;
    }
  }
  while (v1);
  uint64_t v7 = 16;
  if (v2 != (unsigned int *)&std::__extended_grapheme_custer_property_boundary::__entries)
  {
    unsigned int v8 = *(v2 - 1);
    unsigned int v9 = ((v8 >> 4) & 0x7F) + (v8 >> 11);
    unsigned int v10 = v8 & 0xF;
    if (v9 >= a1) {
      return v10;
    }
    else {
      return 16;
    }
  }
  return v7;
}

void *std::__formatter::__format_floating_point_non_finite[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>(void *a1, uint64_t a2, unint64_t a3, char a4, int a5)
{
  if (a4)
  {
    char v6 = 45;
  }
  else
  {
    int v7 = (a2 >> 3) & 3;
    if (v7 == 2)
    {
      char v6 = 43;
    }
    else
    {
      if (v7 != 3)
      {
        p_src = &__src;
        goto LABEL_8;
      }
      char v6 = 32;
    }
  }
  p_src = v15;
  char __src = v6;
LABEL_8:
  if (BYTE1(a2) <= 0x10u && ((1 << SBYTE1(a2)) & 0x15000) != 0)
  {
    uint64_t v9 = 6;
  }
  else
  {
    uint64_t v9 = 6;
    if (BYTE1(a2) != 18) {
      uint64_t v9 = 0;
    }
  }
  uint64_t v10 = 3;
  if (!a5) {
    uint64_t v10 = 0;
  }
  size_t v11 = &aInfnaninfnan[v9 + v10];
  *(_WORD *)p_src = *(_WORD *)v11;
  p_src[2] = v11[2];
  if ((a2 & 7) == 4) {
    unsigned __int8 v12 = a2 & 0xF8 | 3;
  }
  else {
    unsigned __int8 v12 = a2;
  }
  std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(&__src, p_src - &__src + 3, a1, a2 & 0xFFFFFFFFFFFFFF00 | v12, a3, p_src - &__src + 3);
  return a1;
}

void *std::__formatter::__format_locale_specific_form[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,double,char>(void *a1, uint64_t a2, char **a3, std::locale *this, uint64_t a5, unint64_t a6)
{
  size_t v11 = std::locale::use_facet(this, MEMORY[0x1E4FBA2A0]);
  ((void (*)(std::string *__return_ptr))v11->__vftable[1].__on_zero_shared)(&__p);
  unsigned __int8 v12 = a3[2];
  uint64_t v13 = *a3;
  if (v12 >= a3[1]) {
    unsigned __int8 v12 = a3[1];
  }
  int64_t __len = v12 - v13;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
    if (!__p.__r_.__value_.__l.__size_) {
      goto LABEL_29;
    }
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    int64_t v16 = *__p.__r_.__value_.__l.__data_;
    if (__len <= v16)
    {
      *__p.__r_.__value_.__l.__data_ = 0;
      __p.__r_.__value_.__l.__size_ = 0;
      goto LABEL_29;
    }
    std::string::value_type v18 = *__p.__r_.__value_.__l.__data_;
    std::string::size_type v15 = __p.__r_.__value_.__r.__words[0];
  }
  else
  {
    if (!*((unsigned char *)&__p.__r_.__value_.__s + 23)) {
      goto LABEL_29;
    }
    if (__len <= __p.__r_.__value_.__s.__data_[0])
    {
      __p.__r_.__value_.__s.__data_[0] = 0;
      *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
      goto LABEL_29;
    }
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
    std::string::size_type v15 = __p.__r_.__value_.__r.__words[0];
    int64_t v16 = __p.__r_.__value_.__s.__data_[0];
    p_p = &__p;
    std::string::value_type v18 = __p.__r_.__value_.__s.__data_[0];
  }
  memset(&v55, 0, sizeof(v55));
  char v19 = (char *)(v15 + size);
  uint64_t v20 = (char *)&__p + HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    uint64_t v20 = v19;
  }
  uint64_t v21 = __len - v16;
  if (__len - v16 >= 1)
  {
    int v22 = v20 - 1;
    do
    {
      std::string::push_back(&v55, v18);
      if (p_p == (std::string *)v22)
      {
        std::string::value_type v18 = *v22;
        p_p = (std::string *)v22;
      }
      else
      {
        unsigned __int8 v23 = &p_p->__r_.__value_.__s.__data_[1];
        int v24 = &p_p->__r_.__value_.__s.__data_[1];
        do
        {
          int v25 = *v24++;
          std::string::value_type v18 = v25;
          if (v25) {
            BOOL v26 = 1;
          }
          else {
            BOOL v26 = v23 == v22;
          }
          unsigned __int8 v23 = v24;
        }
        while (!v26);
        p_p = (std::string *)(v24 - 1);
      }
      v21 -= v18;
    }
    while (v21 > 0);
  }
  std::string::push_back(&v55, v18 + v21);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  std::string __p = v55;
LABEL_29:
  unint64_t v27 = HIDWORD(a6);
  unint64_t v28 = *(char **)(a2 + 16);
  std::string::size_type v29 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v29 = __p.__r_.__value_.__l.__size_;
  }
  int64_t v30 = a3[3] - v28 + *(int *)(a2 + 4) + v29 - (v29 != 0);
  int v31 = a5 & 7;
  size_t v32 = (a5 >> 32) - v30;
  if (a5 >> 32 <= v30)
  {
    size_t v36 = 0;
    size_t v35 = 0;
    unsigned __int8 v33 = v27;
  }
  else
  {
    if (v31 == 4) {
      unsigned __int8 v33 = 48;
    }
    else {
      unsigned __int8 v33 = v27;
    }
    if (v31 == 4) {
      uint64_t v34 = 3;
    }
    else {
      uint64_t v34 = a5 & 7;
    }
    size_t v35 = 0;
    size_t v36 = (a5 >> 32) - v30;
    switch(v34)
    {
      case 1:
        break;
      case 2:
        size_t v35 = v32 >> 1;
        size_t v36 = v32 - (v32 >> 1);
        break;
      default:
        size_t v36 = 0;
        size_t v35 = v32;
        break;
    }
  }
  size_t v53 = v36;
  if (v31 == 4 && v13 != v28)
  {
    v55.__r_.__value_.__r.__words[0] = (std::string::size_type)a1;
    std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100]((uint64_t **)&v55, *v28);
  }
  int v37 = v27 & 0xFFFFFF00 | v33;
  std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a1, v35, v37);
  if (v31 != 4)
  {
    int64_t v38 = *(char **)(a2 + 16);
    if (v13 != v38)
    {
      v55.__r_.__value_.__r.__words[0] = (std::string::size_type)a1;
      std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100]((uint64_t **)&v55, *v38);
    }
  }
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    std::string::size_type v39 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if (*((unsigned char *)&__p.__r_.__value_.__s + 23))
    {
      unint64_t v40 = &__p.__r_.__value_.__s.__data_[1];
      int v41 = &__p;
      goto LABEL_52;
    }
LABEL_56:
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(a1, v13, __len);
    goto LABEL_57;
  }
  std::string::size_type v39 = __p.__r_.__value_.__l.__size_;
  if (!__p.__r_.__value_.__l.__size_) {
    goto LABEL_56;
  }
  int v41 = (std::string *)__p.__r_.__value_.__r.__words[0];
  unint64_t v40 = (char *)(__p.__r_.__value_.__r.__words[0] + 1);
LABEL_52:
  unint64_t v42 = (char *)v41 + v39;
  char v43 = ((uint64_t (*)(const std::locale::facet *))v11->__vftable[1].~facet_0)(v11);
  while (1)
  {
    char v44 = v42 - 1;
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(a1, v13, *(v42 - 1));
    if (v42 == v40) {
      break;
    }
    v13 += *(v42 - 1);
    uint64_t v45 = *a1;
    uint64_t v46 = a1[2];
    a1[2] = v46 + 1;
    *(unsigned char *)(v45 + v46) = v43;
    --v42;
    if (a1[2] == a1[1])
    {
      ((void (*)(void))a1[3])(*a1);
      a1[2] = 0;
      unint64_t v42 = v44;
    }
  }
LABEL_57:
  int v47 = a3[1];
  if (v47 != a3[3])
  {
    char v48 = ((uint64_t (*)(const std::locale::facet *))v11->__vftable[1].~facet)(v11);
    uint64_t v49 = *a1;
    uint64_t v50 = a1[2];
    a1[2] = v50 + 1;
    *(unsigned char *)(v49 + v50) = v48;
    if (a1[2] == a1[1])
    {
      ((void (*)(void))a1[3])(*a1);
      a1[2] = 0;
    }
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(a1, a3[1] + 1, a3[2] - (a3[1] + 1));
    std::__format::__output_buffer<char>::__fill[abi:ne180100](a1, *(int *)(a2 + 4), 48);
    int v47 = a3[3];
  }
  unint64_t v51 = a3[2];
  if (v51 != v47) {
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(a1, v51, v47 - v51);
  }
  std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a1, v53, v37);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return a1;
}

void sub_1BB364530(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *std::__formatter::__write_using_trailing_zeros[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(char *a1, uint64_t a2, void *a3, uint64_t a4, unint64_t a5, uint64_t a6, char *a7, size_t a8)
{
  size_t v8 = (a4 >> 32) - (a6 + a8);
  size_t v14 = 0;
  switch(a4 & 7)
  {
    case 1:
      break;
    case 2:
      size_t v14 = v8 >> 1;
      v8 -= v8 >> 1;
      break;
    default:
      size_t v14 = (a4 >> 32) - (a6 + a8);
      size_t v8 = 0;
      break;
  }
  unint64_t v15 = HIDWORD(a5);
  int64_t v16 = std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a3, v14, SHIDWORD(a5));
  std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v16, a1, a7 - a1);
  std::__format::__output_buffer<char>::__fill[abi:ne180100](a3, a8, 48);
  std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(a3, a7, a2 - (void)a7);

  return std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a3, v8, v15);
}

unsigned char *std::__formatter::__format_buffer_general_lower_case[abi:ne180100]<double,long double>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_DWORD *)(a2 + 4) = 0;
  *a1 = a4;
  uint64_t v6 = MEMORY[0x1C185D1D0](a4, *(void *)(a2 + 16) + *(void *)(a2 + 8), 3, a3);
  a1[3] = v6;
  unint64_t result = (unsigned char *)(a4 + 1);
  if (a4 + 1 == v6)
  {
    a1[1] = v6;
    a1[2] = v6;
  }
  else
  {
    size_t v8 = v6 - (void)result;
    if (v6 - (uint64_t)result < 4)
    {
LABEL_8:
      a1[2] = v6;
      unint64_t result = memchr(result, 46, v8);
      if (result) {
        size_t v11 = result;
      }
      else {
        size_t v11 = (unsigned char *)v6;
      }
      a1[1] = v11;
    }
    else
    {
      uint64_t v9 = 6;
      if (v8 < 6) {
        uint64_t v9 = v6 - (void)result;
      }
      uint64_t v10 = -v9;
      while (*(unsigned char *)(v6 + v10) != 101)
      {
        if (++v10 == -3) {
          goto LABEL_8;
        }
      }
      uint64_t v12 = v6 + v10;
      if (*result == 46) {
        uint64_t v13 = a4 + 1;
      }
      else {
        uint64_t v13 = v6;
      }
      a1[1] = v13;
      a1[2] = v12;
    }
  }
  return result;
}

uint64_t std::__formatter::__format_buffer_hexadecimal_lower_case[abi:ne180100]<double,long double>(void *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  *a1 = a5;
  uint64_t v7 = a3 + a2;
  if (a4 == -1) {
    uint64_t result = std::to_chars();
  }
  else {
    uint64_t result = MEMORY[0x1C185D1D0](a5, v7, 4);
  }
  a1[3] = result;
  int v10 = *(unsigned __int8 *)(a5 + 1);
  uint64_t v9 = a5 + 1;
  if (v10 == 46)
  {
    uint64_t v11 = result - 2;
    uint64_t v12 = memchr((void *)(result - 6), 112, 4uLL);
    uint64_t result = v9;
    if (v12) {
      uint64_t v9 = (uint64_t)v12;
    }
    else {
      uint64_t v9 = v11;
    }
  }
  a1[1] = result;
  a1[2] = v9;
  return result;
}

uint64_t std::__formatter::__format_buffer_scientific_lower_case[abi:ne180100]<double,long double>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *a1 = a5;
  uint64_t result = MEMORY[0x1C185D1D0](a5, a3 + a2, 1);
  a1[3] = result;
  uint64_t v8 = a5 + 1;
  if (*(unsigned char *)(a5 + 1) == 46)
  {
    a1[1] = v8;
    uint64_t v9 = result - a5 - 2;
    uint64_t v8 = result;
    if (v9 >= 4)
    {
      uint64_t v10 = 6;
      if ((unint64_t)v9 < 6) {
        uint64_t v10 = result - a5 - 2;
      }
      uint64_t v11 = -v10;
      while (*(unsigned char *)(result + v11) != 101)
      {
        if (++v11 == -3)
        {
          uint64_t v8 = result;
          goto LABEL_11;
        }
      }
      uint64_t v8 = result + v11;
    }
  }
  else
  {
    a1[1] = result;
  }
LABEL_11:
  a1[2] = v8;
  return result;
}

unsigned char *std::__formatter::__format_buffer_general_lower_case[abi:ne180100]<double,double>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_DWORD *)(a2 + 4) = 0;
  *a1 = a4;
  uint64_t v6 = MEMORY[0x1C185D1A0](a4, *(void *)(a2 + 16) + *(void *)(a2 + 8), 3, a3);
  a1[3] = v6;
  uint64_t result = (unsigned char *)(a4 + 1);
  if (a4 + 1 == v6)
  {
    a1[1] = v6;
    a1[2] = v6;
  }
  else
  {
    size_t v8 = v6 - (void)result;
    if (v6 - (uint64_t)result < 4)
    {
LABEL_8:
      a1[2] = v6;
      uint64_t result = memchr(result, 46, v8);
      if (result) {
        uint64_t v11 = result;
      }
      else {
        uint64_t v11 = (unsigned char *)v6;
      }
      a1[1] = v11;
    }
    else
    {
      uint64_t v9 = 6;
      if (v8 < 6) {
        uint64_t v9 = v6 - (void)result;
      }
      uint64_t v10 = -v9;
      while (*(unsigned char *)(v6 + v10) != 101)
      {
        if (++v10 == -3) {
          goto LABEL_8;
        }
      }
      uint64_t v12 = v6 + v10;
      if (*result == 46) {
        uint64_t v13 = a4 + 1;
      }
      else {
        uint64_t v13 = v6;
      }
      a1[1] = v13;
      a1[2] = v12;
    }
  }
  return result;
}

uint64_t std::__formatter::__format_buffer_hexadecimal_lower_case[abi:ne180100]<double,double>(void *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  *a1 = a5;
  uint64_t v7 = a3 + a2;
  if (a4 == -1) {
    uint64_t result = std::to_chars();
  }
  else {
    uint64_t result = MEMORY[0x1C185D1A0](a5, v7, 4);
  }
  a1[3] = result;
  int v10 = *(unsigned __int8 *)(a5 + 1);
  uint64_t v9 = a5 + 1;
  if (v10 == 46)
  {
    uint64_t v11 = result - 2;
    uint64_t v12 = memchr((void *)(result - 6), 112, 4uLL);
    uint64_t result = v9;
    if (v12) {
      uint64_t v9 = (uint64_t)v12;
    }
    else {
      uint64_t v9 = v11;
    }
  }
  a1[1] = result;
  a1[2] = v9;
  return result;
}

uint64_t std::__formatter::__format_buffer_scientific_lower_case[abi:ne180100]<double,double>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *a1 = a5;
  uint64_t result = MEMORY[0x1C185D1A0](a5, a3 + a2, 1);
  a1[3] = result;
  uint64_t v8 = a5 + 1;
  if (*(unsigned char *)(a5 + 1) == 46)
  {
    a1[1] = v8;
    uint64_t v9 = result - a5 - 2;
    uint64_t v8 = result;
    if (v9 >= 4)
    {
      uint64_t v10 = 6;
      if ((unint64_t)v9 < 6) {
        uint64_t v10 = result - a5 - 2;
      }
      uint64_t v11 = -v10;
      while (*(unsigned char *)(result + v11) != 101)
      {
        if (++v11 == -3)
        {
          uint64_t v8 = result;
          goto LABEL_11;
        }
      }
      uint64_t v8 = result + v11;
    }
  }
  else
  {
    a1[1] = result;
  }
LABEL_11:
  a1[2] = v8;
  return result;
}

unsigned char *std::__formatter::__format_buffer_general_lower_case[abi:ne180100]<float,float>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_DWORD *)(a2 + 4) = 0;
  *a1 = a4;
  uint64_t v6 = MEMORY[0x1C185D200](a4, *(void *)(a2 + 16) + *(void *)(a2 + 8), 3, a3);
  a1[3] = v6;
  uint64_t result = (unsigned char *)(a4 + 1);
  if (a4 + 1 == v6)
  {
    a1[1] = v6;
    a1[2] = v6;
  }
  else
  {
    size_t v8 = v6 - (void)result;
    if (v6 - (uint64_t)result < 4)
    {
LABEL_8:
      a1[2] = v6;
      uint64_t result = memchr(result, 46, v8);
      if (result) {
        uint64_t v11 = result;
      }
      else {
        uint64_t v11 = (unsigned char *)v6;
      }
      a1[1] = v11;
    }
    else
    {
      uint64_t v9 = 6;
      if (v8 < 6) {
        uint64_t v9 = v6 - (void)result;
      }
      uint64_t v10 = -v9;
      while (*(unsigned char *)(v6 + v10) != 101)
      {
        if (++v10 == -3) {
          goto LABEL_8;
        }
      }
      uint64_t v12 = v6 + v10;
      if (*result == 46) {
        uint64_t v13 = a4 + 1;
      }
      else {
        uint64_t v13 = v6;
      }
      a1[1] = v13;
      a1[2] = v12;
    }
  }
  return result;
}

uint64_t std::__formatter::__format_buffer_hexadecimal_lower_case[abi:ne180100]<float,float>(void *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  *a1 = a5;
  uint64_t v7 = a3 + a2;
  if (a4 == -1) {
    uint64_t result = std::to_chars();
  }
  else {
    uint64_t result = MEMORY[0x1C185D200](a5, v7, 4);
  }
  a1[3] = result;
  int v10 = *(unsigned __int8 *)(a5 + 1);
  uint64_t v9 = a5 + 1;
  if (v10 == 46)
  {
    uint64_t v11 = result - 2;
    uint64_t v12 = memchr((void *)(result - 5), 112, 3uLL);
    uint64_t result = v9;
    if (v12) {
      uint64_t v9 = (uint64_t)v12;
    }
    else {
      uint64_t v9 = v11;
    }
  }
  a1[1] = result;
  a1[2] = v9;
  return result;
}

uint64_t std::__formatter::__format_buffer_scientific_lower_case[abi:ne180100]<float,float>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *a1 = a5;
  uint64_t result = MEMORY[0x1C185D200](a5, a3 + a2, 1);
  a1[3] = result;
  uint64_t v8 = a5 + 1;
  if (*(unsigned char *)(a5 + 1) == 46)
  {
    a1[1] = v8;
    uint64_t v9 = result - a5 - 2;
    uint64_t v8 = result;
    if (v9 >= 4)
    {
      uint64_t v10 = 6;
      if ((unint64_t)v9 < 6) {
        uint64_t v10 = result - a5 - 2;
      }
      uint64_t v11 = -v10;
      while (*(unsigned char *)(result + v11) != 101)
      {
        if (++v11 == -3)
        {
          uint64_t v8 = result;
          goto LABEL_11;
        }
      }
      uint64_t v8 = result + v11;
    }
  }
  else
  {
    a1[1] = result;
  }
LABEL_11:
  a1[2] = v8;
  return result;
}

uint64_t std::__format_spec::__process_parsed_integer[abi:ne180100]<char>(uint64_t result)
{
  int v1 = *(unsigned __int8 *)(result + 1);
  if ((v1 - 2) >= 6 && v1 != 0)
  {
    if (v1 != 10) {
      std::__format_spec::__throw_invalid_type_format_error[abi:ne180100]("an integer");
    }
    unint64_t v3 = (unsigned char *)result;
    uint64_t result = std::__format_spec::__parser<char>::__validate[abi:ne180100](result, "an integer");
    if ((*v3 & 7) == 0) {
      unsigned char *v3 = *v3 & 0xF8 | 1;
    }
  }
  return result;
}

void *std::__formatter::__format_integer[abi:ne180100]<unsigned __int128,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(unint64_t a1, unint64_t a2, void *a3, unint64_t a4, unint64_t a5, char a6)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  switch(BYTE1(a4))
  {
    case 1:
      __break(1u);
      JUMPOUT(0x1BB364E48);
    case 2:
      unint64_t v7 = a4 & 0xFFFFFFFFFFFF00FFLL | 0x200;
      uint64_t v8 = &v15;
      unsigned int v10 = 2;
      uint64_t v9 = "0b";
      goto LABEL_11;
    case 3:
      unint64_t v7 = a4 & 0xFFFFFFFFFFFF00FFLL | 0x300;
      uint64_t v8 = &v15;
      unsigned int v10 = 2;
      uint64_t v9 = "0B";
      goto LABEL_11;
    case 4:
      unint64_t v7 = a4 & 0xFFFFFFFFFFFF00FFLL | 0x400;
      uint64_t v8 = (uint64_t *)v14;
      if (a1 | a2) {
        uint64_t v9 = "0";
      }
      else {
        uint64_t v9 = 0;
      }
      unsigned int v10 = 8;
      goto LABEL_11;
    case 6:
      unint64_t v7 = a4 & 0xFFFFFFFFFFFF00FFLL | 0x600;
      uint64_t v8 = (uint64_t *)v12;
      unsigned int v10 = 16;
      uint64_t v9 = "0x";
      goto LABEL_11;
    case 7:
      unint64_t v7 = a4 & 0xFFFFFFFFFFFF00FFLL | 0x700;
      uint64_t v8 = (uint64_t *)v12;
      unsigned int v10 = 16;
      uint64_t v9 = "0X";
LABEL_11:
      uint64_t result = std::__formatter::__format_integer[abi:ne180100]<unsigned __int128,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a2, a3, v7, a5, a6, __src, (uint64_t)v8, v9, v10);
      break;
    default:
      uint64_t result = std::__formatter::__format_integer[abi:ne180100]<unsigned __int128,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a2, a3, a4, a5, a6, __src, (uint64_t)v13, 0, 0xAu);
      break;
  }
  return result;
}

void *std::__formatter::__format_integer[abi:ne180100]<unsigned __int128,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(unint64_t a1, unint64_t a2, void *a3, unint64_t a4, unint64_t a5, char a6, char *__src, uint64_t a8, unsigned char *a9, unsigned int a10)
{
  unsigned int v10 = (char *)a8;
  uint64_t v11 = __src;
  unint64_t v12 = a5;
  unint64_t v13 = a4;
  unint64_t v14 = a2;
  unint64_t v15 = a1;
  char v16 = a4;
  if (a6)
  {
    char v17 = 45;
LABEL_7:
    void *__src = v17;
    char v19 = __src + 1;
    goto LABEL_8;
  }
  int v18 = (a4 >> 3) & 3;
  if (v18 == 2)
  {
    char v17 = 43;
    goto LABEL_7;
  }
  char v19 = __src;
  if (v18 == 3)
  {
    char v17 = 32;
    goto LABEL_7;
  }
LABEL_8:
  if ((a4 & 0x20) != 0)
  {
    if (a9)
    {
      char v20 = *a9;
      if (*a9)
      {
        uint64_t v21 = a9 + 1;
        do
        {
          *v19++ = v20;
          int v22 = *v21++;
          char v20 = v22;
        }
        while (v22);
      }
    }
  }
  HIDWORD(v24) = a10;
  LODWORD(v24) = a10 - 2;
  int v23 = v24 >> 1;
  if (v23 != 4)
  {
    if (v23)
    {
      if (v23 == 3)
      {
        uint64_t v30 = std::__itoa::__integral<8u>::__to_chars[abi:ne180100]<unsigned __int128>((uint64_t)v19, a8, a1, a2);
      }
      else
      {
        if (v23 != 7)
        {
          uint64_t v62 = a8 - (void)v19;
          int v63 = std::__to_chars_integral_width[abi:ne180100]<unsigned __int128>(a1, a2, a10);
          if (v62 >= v63)
          {
            unsigned int v10 = &v19[v63];
            int v64 = v10 - 1;
            do
            {
              uint64_t v65 = __udivti3();
              BOOL v66 = __PAIR128__(v14, v15) >= a10;
              *v64-- = a0123456789abcd[v15 - v65 * a10];
              unint64_t v15 = v65;
              unint64_t v14 = v67;
            }
            while (v66);
          }
          goto LABEL_30;
        }
        uint64_t v30 = std::__itoa::__integral<16u>::__to_chars[abi:ne180100]<unsigned __int128>((uint64_t)v19, a8, a1, a2);
      }
    }
    else
    {
      uint64_t v30 = std::__itoa::__integral<2u>::__to_chars[abi:ne180100]<unsigned __int128>((uint64_t)v19, a8, a1, a2);
    }
LABEL_23:
    unsigned int v10 = (char *)v30;
    goto LABEL_30;
  }
  uint64_t v25 = a8 - (void)v19;
  if (!a2)
  {
    if (v25 <= 19)
    {
      unsigned int v29 = (1233 * (64 - __clz(a1 | 1))) >> 12;
      if (v25 < v29 - (std::__itoa::__pow10_64[v29] > a1) + 1) {
        goto LABEL_30;
      }
    }
    uint64_t v30 = (uint64_t)std::__itoa::__traits_base<unsigned long long,void>::__convert[abi:ne180100](v19, a1);
    goto LABEL_23;
  }
  if (v25 > 38
    || (unsigned int v26 = (1233 * (128 - __clz(a2))) >> 12,
        v25 >= v26 - (__PAIR128__(a2, a1) < std::__itoa::__pow10_128[v26]) + 1))
  {
    if (__PAIR128__(a2, a1) >= __PAIR128__(0x4B3B4CA85A86C47ALL, 0x98A224000000000))
    {
      *char v19 = __udivti3() | 0x30;
      unsigned int v31 = __udivti3();
      v19[1] = v31 / 0x5F5E100 + 48;
      *((_WORD *)v19 + 1) = std::__itoa::__digits_base_10[v31 % 0x5F5E100 / 0xF4240];
      unsigned int v32 = v31 % 0x5F5E100 % 0xF4240;
      *((_WORD *)v19 + 2) = std::__itoa::__digits_base_10[v32 / 0x2710uLL];
      LOWORD(v32) = v32 % 0x2710;
      *((_WORD *)v19 + 3) = std::__itoa::__digits_base_10[(unsigned __int16)v32 / 0x64u];
      *((_WORD *)v19 + 4) = std::__itoa::__digits_base_10[(unsigned __int16)v32 % 0x64u];
      unint64_t v33 = __udivti3();
      uint64_t v34 = v19 + 10;
    }
    else
    {
      unint64_t v27 = __udivti3();
      if (!HIDWORD(v27))
      {
        unint64_t v28 = std::__itoa::__base_10_u32[abi:ne180100](v19, v27);
LABEL_29:
        size_t v35 = v28;
        unint64_t v36 = __umodti3();
        *size_t v35 = v36 / 0x2540BE400 / 0x5F5E100 + 48;
        unsigned int v37 = v36 / 0x2540BE400 % 0x5F5E100;
        *(_WORD *)(v35 + 1) = std::__itoa::__digits_base_10[v37 / 0xF4240];
        v37 %= 0xF4240u;
        *(_WORD *)(v35 + 3) = std::__itoa::__digits_base_10[v37 / 0x2710uLL];
        LOWORD(v37) = v37 % 0x2710;
        *(_WORD *)(v35 + 5) = std::__itoa::__digits_base_10[(unsigned __int16)v37 / 0x64u];
        *(_WORD *)(v35 + 7) = std::__itoa::__digits_base_10[(unsigned __int16)v37 % 0x64u];
        unsigned int v10 = (char *)std::__itoa::__append10[abi:ne180100]<unsigned long long>(v35 + 9, v36 % 0x2540BE400);
        uint64_t v11 = __src;
        unint64_t v12 = a5;
        unint64_t v13 = a4;
        goto LABEL_30;
      }
      uint64_t v34 = v19;
      if (v27 > 0x2540BE3FFLL)
      {
        uint64_t v34 = std::__itoa::__base_10_u32[abi:ne180100](v19, v27 / 0x2540BE400);
        v27 %= 0x2540BE400uLL;
      }
      unint64_t v33 = v27;
    }
    unint64_t v28 = (char *)std::__itoa::__append10[abi:ne180100]<unsigned long long>(v34, v33);
    goto LABEL_29;
  }
LABEL_30:
  int64_t v38 = (void **)a3;
  if ((v16 & 0x40) == 0) {
    goto LABEL_57;
  }
  std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>::locale[abi:ne180100](&v73, (uint64_t)a3);
  std::string::size_type v39 = std::locale::use_facet(&v73, MEMORY[0x1E4FBA2A0]);
  int64_t v40 = v10 - v19;
  std::locale::~locale(&v73);
  ((void (*)(std::locale *__return_ptr, const std::locale::facet *))v39->__vftable[1].__on_zero_shared)(&v73, v39);
  if ((char)v75 < 0)
  {
    locale = (std::string::value_type *)v73.__locale_;
    uint64_t v42 = v74;
    if (v74 && v40 > *(char *)v73.__locale_)
    {
      char v43 = v73.__locale_;
      goto LABEL_38;
    }
    operator delete(v73.__locale_);
    int64_t v38 = (void **)a3;
LABEL_57:
    unint64_t v55 = HIDWORD(v13);
    if ((v16 & 7) == 4)
    {
      std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(*v38, v11, v19 - v11);
      unsigned __int8 v56 = v13 & 0xF8 | 3;
      if (SHIDWORD(v13) >= (int)v19 - (int)v11) {
        int v57 = v19 - v11;
      }
      else {
        int v57 = HIDWORD(v13);
      }
      unint64_t v55 = (HIDWORD(v13) - v57);
      unsigned __int8 v58 = 48;
      uint64_t v11 = v19;
    }
    else
    {
      unsigned __int8 v58 = BYTE4(v12);
      unsigned __int8 v56 = v13;
    }
    unint64_t v54 = *v38;
    uint64_t v59 = v13 & 0xFFFFFF00 | (v55 << 32) | v56;
    unint64_t v60 = v12 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)v58 << 32);
    if ((v13 & 0xFF00) == 0x700) {
      std::__formatter::__write_transformed[abi:ne180100]<char *,char,char,char (*)(char),std::back_insert_iterator<std::__format::__output_buffer<char>>>(v11, v10, *v38, v59, v60);
    }
    else {
      std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v11, v10 - v11, *v38, v59, v60, v10 - v11);
    }
    return v54;
  }
  if (!v75 || v40 <= SLOBYTE(v73.__locale_)) {
    goto LABEL_57;
  }
  locale = (std::string::value_type *)&v73;
  char v43 = v73.__locale_;
  uint64_t v42 = v74;
LABEL_38:
  char v44 = (void *)*a3;
  memset(&v72, 0, sizeof(v72));
  uint64_t v45 = (char *)v43 + v42;
  if ((v75 & 0x80u) == 0) {
    uint64_t v45 = (char *)&v73 + v75;
  }
  std::string::value_type v46 = *locale;
  uint64_t v47 = v40 - *locale;
  if (v47 >= 1)
  {
    char v48 = v45 - 1;
    do
    {
      std::string::push_back(&v72, v46);
      if (locale == v48)
      {
        std::string::value_type v46 = *v48;
        locale = v48;
      }
      else
      {
        uint64_t v49 = locale + 1;
        uint64_t v50 = locale + 1;
        do
        {
          int v51 = *v50++;
          std::string::value_type v46 = v51;
          if (v51) {
            BOOL v52 = 1;
          }
          else {
            BOOL v52 = v49 == v48;
          }
          uint64_t v49 = v50;
        }
        while (!v52);
        locale = v50 - 1;
      }
      v47 -= v46;
    }
    while (v47 > 0);
  }
  std::string::push_back(&v72, v46 + v47);
  char v53 = ((uint64_t (*)(const std::locale::facet *))v39->__vftable[1].~facet_0)(v39);
  unint64_t v54 = std::__formatter::__write_using_decimal_separators[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,char *,char>(v44, v11, v19, (int)v10, (uint64_t *)&v72, v53, v13, v12);
  if (SHIBYTE(v72.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v72.__r_.__value_.__l.__data_);
  }
  if ((char)v75 < 0) {
    operator delete(v73.__locale_);
  }
  return v54;
}

void sub_1BB365610(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,std::locale a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21.__locale_);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__itoa::__integral<2u>::__to_chars[abi:ne180100]<unsigned __int128>(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  unint64_t v4 = __clz(a3 | 1) | 0x40;
  unint64_t v5 = __clz(a4);
  if (a4) {
    unint64_t v4 = v5;
  }
  int64_t v6 = 128 - v4;
  if (a2 - a1 < v6) {
    return a2;
  }
  uint64_t v7 = a1 + v6;
  if (__PAIR128__(a4, a3) < 0x11)
  {
    unint64_t v9 = a3;
    unint64_t v12 = a4;
    uint64_t v8 = v7;
  }
  else
  {
    uint64_t v8 = a1 + v6;
    do
    {
      *((void *)&v10 + 1) = a4;
      *(void *)&long long v10 = a3;
      unint64_t v9 = v10 >> 4;
      BOOL v11 = a3 <= 0x10F;
      unint64_t v12 = a4 >> 4;
      *(_DWORD *)(v8 - 4) = std::__itoa::__base_2_lut[a3 & 0xF];
      v8 -= 4;
      a3 = v9;
      a4 >>= 4;
    }
    while (!v11);
  }
  unint64_t v13 = (unsigned char *)(v8 - 1);
  do
  {
    unint64_t v14 = v9 & 1;
    BOOL v11 = v9 <= 1;
    *((void *)&v15 + 1) = v12;
    *(void *)&long long v15 = v9;
    unint64_t v9 = v15 >> 1;
    v12 >>= 1;
    *v13-- = a01[v14];
  }
  while (!v11);
  return v7;
}

uint64_t std::__itoa::__integral<8u>::__to_chars[abi:ne180100]<unsigned __int128>(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  char v4 = __clz(a3 | 1) | 0x40;
  char v5 = __clz(a4);
  if (a4) {
    char v4 = v5;
  }
  uint64_t v6 = (-126 - v4) / 3u;
  if (a2 - a1 < v6) {
    return a2;
  }
  uint64_t v7 = a1 + v6;
  if (__PAIR128__(a4, a3) < 0x41)
  {
    unint64_t v9 = a3;
    uint64_t v8 = v7;
  }
  else
  {
    uint64_t v8 = a1 + v6;
    do
    {
      *((void *)&v10 + 1) = a4;
      *(void *)&long long v10 = a3;
      unint64_t v9 = v10 >> 6;
      a4 >>= 6;
      *(_WORD *)(v8 - 2) = std::__itoa::__base_8_lut[a3 & 0x3F];
      v8 -= 2;
      a3 = v9;
    }
    while (v9 > 0x40);
  }
  BOOL v11 = (unsigned char *)(v8 - 1);
  do
  {
    unint64_t v12 = v9 & 7;
    BOOL v13 = v9 <= 7;
    *((void *)&v14 + 1) = a4;
    *(void *)&long long v14 = v9;
    unint64_t v9 = v14 >> 3;
    a4 >>= 3;
    *v11-- = a01234567[v12];
  }
  while (!v13);
  return v7;
}

uint64_t std::__itoa::__integral<16u>::__to_chars[abi:ne180100]<unsigned __int128>(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  unint64_t v4 = __clz(a3 | 1) | 0x40;
  unint64_t v5 = __clz(a4);
  if (a4) {
    unint64_t v4 = v5;
  }
  unint64_t v6 = 131 - v4;
  if (a2 - a1 < (uint64_t)(v6 >> 2)) {
    return a2;
  }
  uint64_t v7 = a1 + (v6 >> 2);
  if (__PAIR128__(a4, a3) < 0x101)
  {
    unint64_t v9 = a3;
    uint64_t v8 = v7;
  }
  else
  {
    uint64_t v8 = a1 + (v6 >> 2);
    do
    {
      *((void *)&v10 + 1) = a4;
      *(void *)&long long v10 = a3;
      unint64_t v9 = v10 >> 8;
      a4 >>= 8;
      *(_WORD *)(v8 - 2) = *(_WORD *)&std::__itoa::__base_16_lut[2 * a3];
      v8 -= 2;
      a3 = v9;
    }
    while (v9 > 0x100);
  }
  BOOL v11 = (unsigned char *)(v8 - 1);
  do
  {
    unint64_t v12 = v9 & 0xF;
    BOOL v13 = v9 <= 0xF;
    *((void *)&v14 + 1) = a4;
    *(void *)&long long v14 = v9;
    unint64_t v9 = v14 >> 4;
    a4 >>= 4;
    *v11-- = a0123456789abcd_0[v12];
  }
  while (!v13);
  return v7;
}

uint64_t std::__to_chars_integral_width[abi:ne180100]<unsigned __int128>(uint64_t a1, unint64_t a2, unsigned int a3)
{
  if (__PAIR128__(a2, a1) < a3) {
    return 1;
  }
  int v5 = 0;
  unsigned int v6 = a3 * a3;
  unsigned int v7 = a3 * a3 * a3;
  while (1)
  {
    if (__PAIR128__(a2, a1) < v6) {
      return v5 | 2u;
    }
    if (__PAIR128__(a2, a1) < v7) {
      return v5 | 3u;
    }
    if (__PAIR128__(a2, a1) < v6 * v6) {
      break;
    }
    a1 = __udivti3();
    v5 += 4;
    if (__PAIR128__(a2, a1) < a3) {
      return v5 | 1u;
    }
  }
  return (v5 + 4);
}

uint64_t std::__format_spec::__parser<char>::__validate[abi:ne180100](uint64_t result, const char *a2)
{
  if ((*(unsigned char *)result & 0x18) != 0)
  {
    int v2 = "sign";
    goto LABEL_11;
  }
  if ((*(unsigned char *)result & 0x20) != 0)
  {
    int v2 = "alternate form";
    goto LABEL_11;
  }
  if ((*(unsigned char *)result & 7) == 4)
  {
    int v2 = "zero-padding";
    goto LABEL_11;
  }
  if (*(_DWORD *)(result + 8) != -1)
  {
    int v2 = "precision";
LABEL_11:
    std::__format_spec::__throw_invalid_option_format_error[abi:ne180100](a2, v2);
  }
  if (*(unsigned __int8 *)(result + 1) >= 0x20u) {
    std::__throw_format_error[abi:ne180100]("The type does not fit in the mask");
  }
  return result;
}

void std::__format_spec::__throw_invalid_option_format_error[abi:ne180100](const char *a1, const char *a2)
{
  std::string::basic_string[abi:ne180100]<0>(&v15, "The format specifier for ");
  size_t v4 = strlen(a1);
  int v5 = std::string::append(&v15, a1, v4);
  long long v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
  v16.__r_.__value_.__r.__words[2] = v5->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v16.__r_.__value_.__l.__data_ = v6;
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  unsigned int v7 = std::string::append(&v16, " does not allow the ", 0x14uLL);
  long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
  v17.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v17.__r_.__value_.__l.__data_ = v8;
  v7->__r_.__value_.__l.__size_ = 0;
  v7->__r_.__value_.__r.__words[2] = 0;
  v7->__r_.__value_.__r.__words[0] = 0;
  size_t v9 = strlen(a2);
  long long v10 = std::string::append(&v17, a2, v9);
  long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  v18.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v18.__r_.__value_.__l.__data_ = v11;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  unint64_t v12 = std::string::append(&v18, " option", 7uLL);
  long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  int64_t v20 = v12->__r_.__value_.__r.__words[2];
  long long v19 = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  if (v20 >= 0) {
    long long v14 = (const char *)&v19;
  }
  else {
    long long v14 = (const char *)v19;
  }
  std::__throw_format_error[abi:ne180100](v14);
}

void sub_1BB365AFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (*(char *)(v28 - 25) < 0) {
    operator delete(*(void **)(v28 - 48));
  }
  if (*(char *)(v28 - 57) < 0) {
    operator delete(*(void **)(v28 - 80));
  }
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

void *std::__formatter::__format_integer[abi:ne180100]<unsigned long long,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(unint64_t a1, void **a2, unint64_t a3, unint64_t a4, char a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  switch(BYTE1(a3))
  {
    case 1:
      __break(1u);
      JUMPOUT(0x1BB365CC4);
    case 2:
      unint64_t v6 = a3 & 0xFFFFFFFFFFFF00FFLL | 0x200;
      unsigned int v7 = &v13;
      unsigned int v9 = 2;
      long long v8 = "0b";
      goto LABEL_11;
    case 3:
      unint64_t v6 = a3 & 0xFFFFFFFFFFFF00FFLL | 0x300;
      unsigned int v7 = &v13;
      unsigned int v9 = 2;
      long long v8 = "0B";
      goto LABEL_11;
    case 4:
      unint64_t v6 = a3 & 0xFFFFFFFFFFFF00FFLL | 0x400;
      unsigned int v7 = (uint64_t *)&v12[3];
      if (a1) {
        long long v8 = "0";
      }
      else {
        long long v8 = 0;
      }
      unsigned int v9 = 8;
      goto LABEL_11;
    case 6:
      unint64_t v6 = a3 & 0xFFFFFFFFFFFF00FFLL | 0x600;
      unsigned int v7 = (uint64_t *)v11;
      unsigned int v9 = 16;
      long long v8 = "0x";
      goto LABEL_11;
    case 7:
      unint64_t v6 = a3 & 0xFFFFFFFFFFFF00FFLL | 0x700;
      unsigned int v7 = (uint64_t *)v11;
      unsigned int v9 = 16;
      long long v8 = "0X";
LABEL_11:
      uint64_t result = std::__formatter::__format_integer[abi:ne180100]<unsigned long long,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a2, v6, a4, a5, v10, (uint64_t)v7, v8, v9);
      break;
    default:
      uint64_t result = std::__formatter::__format_integer[abi:ne180100]<unsigned long long,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a2, a3, a4, a5, v10, (uint64_t)v12, 0, 0xAu);
      break;
  }
  return result;
}

void *std::__formatter::__format_integer[abi:ne180100]<unsigned long long,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(unint64_t a1, void **a2, unint64_t a3, unint64_t a4, char a5, char *a6, uint64_t a7, unsigned char *a8, unsigned int a9)
{
  unsigned int v9 = a6;
  char v13 = a3;
  if (a5)
  {
    char v14 = 45;
LABEL_7:
    *a6 = v14;
    std::string v16 = a6 + 1;
    goto LABEL_8;
  }
  int v15 = (a3 >> 3) & 3;
  if (v15 == 2)
  {
    char v14 = 43;
    goto LABEL_7;
  }
  std::string v16 = a6;
  if (v15 == 3)
  {
    char v14 = 32;
    goto LABEL_7;
  }
LABEL_8:
  if ((a3 & 0x20) != 0)
  {
    if (a8)
    {
      char v17 = *a8;
      if (*a8)
      {
        std::string v18 = a8 + 1;
        do
        {
          *v16++ = v17;
          int v19 = *v18++;
          char v17 = v19;
        }
        while (v19);
      }
    }
  }
  int64_t v20 = std::__to_chars_integral[abi:ne180100]<unsigned long long>(v16, a7, a1, a9);
  if ((v13 & 0x40) == 0) {
    goto LABEL_40;
  }
  std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>::locale[abi:ne180100](&v45, (uint64_t)a2);
  uint64_t v21 = std::locale::use_facet(&v45, MEMORY[0x1E4FBA2A0]);
  int64_t v22 = v20 - v16;
  std::locale::~locale(&v45);
  ((void (*)(std::locale *__return_ptr, const std::locale::facet *))v21->__vftable[1].__on_zero_shared)(&v45, v21);
  if ((char)v47 < 0)
  {
    locale = (std::string::value_type *)v45.__locale_;
    uint64_t v24 = v46;
    if (v46 && v22 > *(char *)v45.__locale_)
    {
      uint64_t v25 = v45.__locale_;
      goto LABEL_21;
    }
    operator delete(v45.__locale_);
LABEL_40:
    unint64_t v37 = HIDWORD(a3);
    if ((v13 & 7) == 4)
    {
      std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(*a2, v9, v16 - v9);
      unsigned __int8 v38 = a3 & 0xF8 | 3;
      if (SHIDWORD(a3) >= (int)v16 - (int)v9) {
        int v39 = v16 - v9;
      }
      else {
        int v39 = HIDWORD(a3);
      }
      unint64_t v37 = (HIDWORD(a3) - v39);
      unsigned __int8 v40 = 48;
      unsigned int v9 = v16;
    }
    else
    {
      unsigned __int8 v40 = BYTE4(a4);
      unsigned __int8 v38 = a3;
    }
    unint64_t v36 = *a2;
    uint64_t v41 = a3 & 0xFFFFFF00 | (v37 << 32) | v38;
    unint64_t v42 = a4 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)v40 << 32);
    if ((a3 & 0xFF00) == 0x700) {
      std::__formatter::__write_transformed[abi:ne180100]<char *,char,char,char (*)(char),std::back_insert_iterator<std::__format::__output_buffer<char>>>(v9, v20, *a2, v41, v42);
    }
    else {
      std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v9, v20 - v9, *a2, v41, v42, v20 - v9);
    }
    return v36;
  }
  if (!v47 || v22 <= SLOBYTE(v45.__locale_)) {
    goto LABEL_40;
  }
  locale = (std::string::value_type *)&v45;
  uint64_t v25 = v45.__locale_;
  uint64_t v24 = v46;
LABEL_21:
  unsigned int v26 = *a2;
  memset(&__p, 0, sizeof(__p));
  unint64_t v27 = (char *)v25 + v24;
  if ((v47 & 0x80u) == 0) {
    unint64_t v27 = (char *)&v45 + v47;
  }
  std::string::value_type v28 = *locale;
  uint64_t v29 = v22 - *locale;
  if (v29 >= 1)
  {
    uint64_t v30 = v27 - 1;
    do
    {
      std::string::push_back(&__p, v28);
      if (locale == v30)
      {
        std::string::value_type v28 = *v30;
        locale = v30;
      }
      else
      {
        unsigned int v31 = locale + 1;
        unsigned int v32 = locale + 1;
        do
        {
          int v33 = *v32++;
          std::string::value_type v28 = v33;
          if (v33) {
            BOOL v34 = 1;
          }
          else {
            BOOL v34 = v31 == v30;
          }
          unsigned int v31 = v32;
        }
        while (!v34);
        locale = v32 - 1;
      }
      v29 -= v28;
    }
    while (v29 > 0);
  }
  std::string::push_back(&__p, v28 + v29);
  char v35 = ((uint64_t (*)(const std::locale::facet *))v21->__vftable[1].~facet_0)(v21);
  unint64_t v36 = std::__formatter::__write_using_decimal_separators[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,char *,char>(v26, v9, v16, (int)v20, (uint64_t *)&__p, v35, a3, a4);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if ((char)v47 < 0) {
    operator delete(v45.__locale_);
  }
  return v36;
}

void sub_1BB366000(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::locale a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15.__locale_);
  }
  _Unwind_Resume(exception_object);
}

void *std::__formatter::__format_integer[abi:ne180100]<unsigned int,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(unsigned int a1, void **a2, unint64_t a3, unint64_t a4, char a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  switch(BYTE1(a3))
  {
    case 1:
      __break(1u);
      JUMPOUT(0x1BB366190);
    case 2:
      unint64_t v6 = a3 & 0xFFFFFFFFFFFF00FFLL | 0x200;
      unsigned int v7 = &v13;
      unsigned int v9 = 2;
      long long v8 = "0b";
      goto LABEL_11;
    case 3:
      unint64_t v6 = a3 & 0xFFFFFFFFFFFF00FFLL | 0x300;
      unsigned int v7 = &v13;
      unsigned int v9 = 2;
      long long v8 = "0B";
      goto LABEL_11;
    case 4:
      unint64_t v6 = a3 & 0xFFFFFFFFFFFF00FFLL | 0x400;
      unsigned int v7 = (uint64_t *)v12;
      if (a1) {
        long long v8 = "0";
      }
      else {
        long long v8 = 0;
      }
      unsigned int v9 = 8;
      goto LABEL_11;
    case 6:
      unint64_t v6 = a3 & 0xFFFFFFFFFFFF00FFLL | 0x600;
      unsigned int v7 = (uint64_t *)v11;
      unsigned int v9 = 16;
      long long v8 = "0x";
      goto LABEL_11;
    case 7:
      unint64_t v6 = a3 & 0xFFFFFFFFFFFF00FFLL | 0x700;
      unsigned int v7 = (uint64_t *)v11;
      unsigned int v9 = 16;
      long long v8 = "0X";
LABEL_11:
      uint64_t result = std::__formatter::__format_integer[abi:ne180100]<unsigned int,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a2, v6, a4, a5, __src, (uint64_t)v7, v8, v9);
      break;
    default:
      uint64_t result = std::__formatter::__format_integer[abi:ne180100]<unsigned int,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a2, a3, a4, a5, __src, (uint64_t)v11, 0, 0xAu);
      break;
  }
  return result;
}

void *std::__formatter::__format_integer[abi:ne180100]<unsigned int,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(unsigned int a1, void **a2, unint64_t a3, unint64_t a4, char a5, char *__src, uint64_t a7, unsigned char *a8, unsigned int a9)
{
  unsigned int v9 = (char *)a7;
  long long v10 = __src;
  unsigned int v14 = a1;
  char v15 = a3;
  if (a5)
  {
    char v16 = 45;
LABEL_7:
    void *__src = v16;
    std::string v18 = __src + 1;
    goto LABEL_8;
  }
  int v17 = (a3 >> 3) & 3;
  if (v17 == 2)
  {
    char v16 = 43;
    goto LABEL_7;
  }
  std::string v18 = __src;
  if (v17 == 3)
  {
    char v16 = 32;
    goto LABEL_7;
  }
LABEL_8:
  if ((a3 & 0x20) != 0)
  {
    if (a8)
    {
      char v19 = *a8;
      if (*a8)
      {
        int64_t v20 = a8 + 1;
        do
        {
          *v18++ = v19;
          int v21 = *v20++;
          char v19 = v21;
        }
        while (v21);
      }
    }
  }
  HIDWORD(v23) = a9;
  LODWORD(v23) = a9 - 2;
  int v22 = v23 >> 1;
  switch(v22)
  {
    case 4:
      if (a7 - (uint64_t)v18 > 9
        || (unsigned int v24 = (1233 * (32 - __clz(a1 | 1))) >> 12,
            a7 - (uint64_t)v18 >= (((__PAIR64__(v24, a1) - std::__itoa::__pow10_32[v24]) >> 32) + 1)))
      {
        uint64_t v25 = (uint64_t)std::__itoa::__base_10_u32[abi:ne180100](v18, a1);
LABEL_17:
        unsigned int v9 = (char *)v25;
      }
      break;
    case 0:
      uint64_t v25 = std::__itoa::__integral<2u>::__to_chars[abi:ne180100]<unsigned int>((uint64_t)v18, a7, a1);
      goto LABEL_17;
    case 3:
      uint64_t v25 = std::__itoa::__integral<8u>::__to_chars[abi:ne180100]<unsigned int>((uint64_t)v18, a7, a1);
      goto LABEL_17;
    case 7:
      uint64_t v25 = std::__itoa::__integral<16u>::__to_chars[abi:ne180100]<unsigned int>((uint64_t)v18, a7, a1);
      goto LABEL_17;
    default:
      uint64_t v49 = a7 - (void)v18;
      int v50 = std::__to_chars_integral_width[abi:ne180100]<unsigned int>(a1, a9);
      if (v49 >= v50)
      {
        unsigned int v9 = &v18[v50];
        int v51 = v9 - 1;
        do
        {
          *v51-- = a0123456789abcd[v14 - v14 / a9 * a9];
          BOOL v52 = v14 >= a9;
          v14 /= a9;
        }
        while (v52);
      }
      break;
  }
  if ((v15 & 0x40) == 0) {
    goto LABEL_45;
  }
  std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>::locale[abi:ne180100](&v54, (uint64_t)a2);
  unsigned int v26 = std::locale::use_facet(&v54, MEMORY[0x1E4FBA2A0]);
  int64_t v27 = v9 - v18;
  std::locale::~locale(&v54);
  ((void (*)(std::locale *__return_ptr, const std::locale::facet *))v26->__vftable[1].__on_zero_shared)(&v54, v26);
  if ((char)v56 < 0)
  {
    locale = (std::string::value_type *)v54.__locale_;
    uint64_t v29 = v55;
    if (v55 && v27 > *(char *)v54.__locale_)
    {
      uint64_t v30 = v54.__locale_;
      goto LABEL_26;
    }
    operator delete(v54.__locale_);
LABEL_45:
    unint64_t v42 = HIDWORD(a3);
    if ((v15 & 7) == 4)
    {
      std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(*a2, v10, v18 - v10);
      unsigned __int8 v43 = a3 & 0xF8 | 3;
      if (SHIDWORD(a3) >= (int)v18 - (int)v10) {
        int v44 = v18 - v10;
      }
      else {
        int v44 = HIDWORD(a3);
      }
      unint64_t v42 = (HIDWORD(a3) - v44);
      unsigned __int8 v45 = 48;
      long long v10 = v18;
    }
    else
    {
      unsigned __int8 v45 = BYTE4(a4);
      unsigned __int8 v43 = a3;
    }
    uint64_t v41 = *a2;
    uint64_t v46 = a3 & 0xFFFFFF00 | (v42 << 32) | v43;
    unint64_t v47 = a4 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)v45 << 32);
    if ((a3 & 0xFF00) == 0x700) {
      std::__formatter::__write_transformed[abi:ne180100]<char *,char,char,char (*)(char),std::back_insert_iterator<std::__format::__output_buffer<char>>>(v10, v9, *a2, v46, v47);
    }
    else {
      std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v10, v9 - v10, *a2, v46, v47, v9 - v10);
    }
    return v41;
  }
  if (!v56 || v27 <= SLOBYTE(v54.__locale_)) {
    goto LABEL_45;
  }
  locale = (std::string::value_type *)&v54;
  uint64_t v30 = v54.__locale_;
  uint64_t v29 = v55;
LABEL_26:
  unsigned int v31 = *a2;
  memset(&__p, 0, sizeof(__p));
  unsigned int v32 = (char *)v30 + v29;
  if ((v56 & 0x80u) == 0) {
    unsigned int v32 = (char *)&v54 + v56;
  }
  std::string::value_type v33 = *locale;
  uint64_t v34 = v27 - *locale;
  if (v34 >= 1)
  {
    char v35 = v32 - 1;
    do
    {
      std::string::push_back(&__p, v33);
      if (locale == v35)
      {
        std::string::value_type v33 = *v35;
        locale = v35;
      }
      else
      {
        unint64_t v36 = locale + 1;
        unint64_t v37 = locale + 1;
        do
        {
          int v38 = *v37++;
          std::string::value_type v33 = v38;
          if (v38) {
            BOOL v39 = 1;
          }
          else {
            BOOL v39 = v36 == v35;
          }
          unint64_t v36 = v37;
        }
        while (!v39);
        locale = v37 - 1;
      }
      v34 -= v33;
    }
    while (v34 > 0);
  }
  std::string::push_back(&__p, v33 + v34);
  char v40 = ((uint64_t (*)(const std::locale::facet *))v26->__vftable[1].~facet_0)(v26);
  uint64_t v41 = std::__formatter::__write_using_decimal_separators[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,char *,char>(v31, v10, v18, (int)v9, (uint64_t *)&__p, v40, a3, a4);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if ((char)v56 < 0) {
    operator delete(v54.__locale_);
  }
  return v41;
}

void sub_1BB3665CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::locale a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15.__locale_);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__itoa::__integral<2u>::__to_chars[abi:ne180100]<unsigned int>(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = 32 - __clz(a3 | 1);
  if (a2 - a1 < v3) {
    return a2;
  }
  uint64_t v4 = a1 + v3;
  if (a3 < 0x11)
  {
    unsigned int v6 = a3;
    uint64_t v5 = v4;
  }
  else
  {
    uint64_t v5 = a1 + v3;
    do
    {
      unsigned int v6 = a3 >> 4;
      *(_DWORD *)(v5 - 4) = std::__itoa::__base_2_lut[a3 & 0xF];
      v5 -= 4;
      BOOL v7 = a3 > 0x10F;
      a3 >>= 4;
    }
    while (v7);
  }
  long long v8 = (unsigned char *)(v5 - 1);
  do
  {
    *v8-- = a01[v6 & 1];
    BOOL v7 = v6 > 1;
    v6 >>= 1;
  }
  while (v7);
  return v4;
}

uint64_t std::__itoa::__integral<8u>::__to_chars[abi:ne180100]<unsigned int>(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = (86 * (34 - __clz(a3 | 1))) >> 8;
  if (a2 - a1 < v3) {
    return a2;
  }
  uint64_t v4 = a1 + v3;
  if (a3 < 0x41)
  {
    unsigned int v6 = a3;
    uint64_t v5 = v4;
  }
  else
  {
    uint64_t v5 = a1 + v3;
    do
    {
      unsigned int v6 = a3 >> 6;
      *(_WORD *)(v5 - 2) = std::__itoa::__base_8_lut[a3 & 0x3F];
      v5 -= 2;
      a3 = v6;
    }
    while (v6 > 0x40);
  }
  BOOL v7 = (unsigned char *)(v5 - 1);
  do
  {
    *v7-- = a01234567[v6 & 7];
    BOOL v8 = v6 > 7;
    v6 >>= 3;
  }
  while (v8);
  return v4;
}

uint64_t std::__itoa::__integral<16u>::__to_chars[abi:ne180100]<unsigned int>(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = (35 - __clz(a3 | 1)) >> 2;
  if (a2 - a1 < v3) {
    return a2;
  }
  uint64_t v4 = a1 + v3;
  if (a3 < 0x101)
  {
    unsigned int v6 = a3;
    uint64_t v5 = v4;
  }
  else
  {
    uint64_t v5 = a1 + v3;
    do
    {
      unsigned int v6 = a3 >> 8;
      *(_WORD *)(v5 - 2) = *(_WORD *)&std::__itoa::__base_16_lut[2 * a3];
      v5 -= 2;
      a3 = v6;
    }
    while (v6 > 0x100);
  }
  BOOL v7 = (unsigned char *)(v5 - 1);
  do
  {
    *v7-- = a0123456789abcd_0[v6 & 0xF];
    BOOL v8 = v6 > 0xF;
    v6 >>= 4;
  }
  while (v8);
  return v4;
}

uint64_t std::__to_chars_integral_width[abi:ne180100]<unsigned int>(unsigned int a1, unsigned int a2)
{
  if (a1 < a2) {
    return 1;
  }
  int v3 = 0;
  unsigned int v4 = a2 * a2;
  unsigned int v5 = v4 * v4;
  while (1)
  {
    if (a1 < v4) {
      return v3 | 2u;
    }
    if (a1 < a2 * a2 * a2) {
      return v3 | 3u;
    }
    if (a1 < v5) {
      break;
    }
    a1 /= v5;
    v3 += 4;
    if (a1 < a2) {
      return v3 | 1u;
    }
  }
  return (v3 + 4);
}

std::runtime_error *std::format_error::format_error[abi:ne180100](std::runtime_error *a1, const char *a2)
{
  uint64_t result = std::runtime_error::runtime_error(a1, a2);
  result->__vftable = (std::runtime_error_vtbl *)&unk_1F14BFF08;
  return result;
}

void std::format_error::~format_error(std::runtime_error *this)
{
  std::runtime_error::~runtime_error(this);

  JUMPOUT(0x1C185D370);
}

void std::__format::__output_buffer<char>::__output_buffer[abi:ne180100]<std::__format::__format_buffer<std::back_insert_iterator<std::string>,char>>(char *,unsigned long,std::__format::__format_buffer<std::back_insert_iterator<std::string>,char> *)::{lambda(char *,unsigned long,void *)#1}::__invoke(unint64_t a1, std::string::size_type __n_add, uint64_t a3)
{
  unsigned int v4 = (std::string::value_type *)a1;
  unint64_t v5 = *(void *)(a3 + 296);
  if (*(char *)(v5 + 23) < 0)
  {
    if (!__n_add) {
      return;
    }
    BOOL v7 = (std::string::value_type *)(a1 + __n_add);
    std::string::size_type v8 = *(void *)(v5 + 8);
    if (*(void *)v5 > a1 || *(void *)v5 + *(void *)(v5 + 8) + 1 <= a1)
    {
      std::string::size_type v6 = *(void *)(v5 + 8);
      std::string::size_type v10 = (*(void *)(v5 + 16) & 0x7FFFFFFFFFFFFFFFLL) - 1;
      if (v10 - v6 >= __n_add)
      {
        unint64_t v11 = *(void *)v5;
        goto LABEL_30;
      }
LABEL_15:
      std::string::__grow_by((std::string *)v5, v10, v6 + __n_add - v10, v6, v8, 0, __n_add);
      *(void *)(v5 + 8) = v6 + __n_add;
      unint64_t v11 = *(void *)v5;
      goto LABEL_33;
    }
  }
  else
  {
    if (!__n_add) {
      return;
    }
    std::string::size_type v6 = *(unsigned __int8 *)(v5 + 23);
    BOOL v7 = (std::string::value_type *)(a1 + __n_add);
    std::string::size_type v8 = v6;
    if (v5 > a1 || v5 + *(unsigned __int8 *)(v5 + 23) + 1 <= a1)
    {
      std::string::size_type v10 = 22;
      unint64_t v11 = *(void *)(a3 + 296);
      if (22 - v6 >= __n_add)
      {
LABEL_30:
        if (v6 == v8) {
          std::string::size_type v6 = v8;
        }
        else {
          memmove((void *)(v11 + v8 + __n_add), (const void *)(v11 + v8), v6 - v8);
        }
LABEL_33:
        std::string::size_type v18 = v6 + __n_add;
        if (*(char *)(v5 + 23) < 0) {
          *(void *)(v5 + 8) = v18;
        }
        else {
          *(unsigned char *)(v5 + 23) = v18 & 0x7F;
        }
        *(unsigned char *)(v11 + v18) = 0;
        char v19 = (unsigned char *)(v11 + v8);
        do
        {
          char v20 = *v4++;
          *v19++ = v20;
        }
        while (v4 != v7);
        return;
      }
      goto LABEL_15;
    }
  }
  memset(&v24, 0, sizeof(v24));
  do
    std::string::push_back(&v24, *v4++);
  while (v4 != v7);
  if ((v24.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v13 = &v24;
  }
  else {
    uint64_t v13 = (std::string *)v24.__r_.__value_.__r.__words[0];
  }
  if ((v24.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v24.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v24.__r_.__value_.__l.__size_;
  }
  if (*(char *)(v5 + 23) < 0)
  {
    std::string::size_type v15 = *(void *)(v5 + 8);
    std::string::size_type v16 = (*(void *)(v5 + 16) & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v16 - v15 >= __n_add)
    {
      unint64_t v17 = *(void *)v5;
      goto LABEL_40;
    }
LABEL_28:
    std::string::__grow_by((std::string *)v5, v16, v15 + __n_add - v16, v15, v8, 0, __n_add);
    *(void *)(v5 + 8) = v15 + __n_add;
    unint64_t v17 = *(void *)v5;
    goto LABEL_43;
  }
  std::string::size_type v15 = *(unsigned __int8 *)(v5 + 23);
  std::string::size_type v16 = 22;
  unint64_t v17 = v5;
  if (22 - v15 < __n_add) {
    goto LABEL_28;
  }
LABEL_40:
  if (v15 == v8) {
    std::string::size_type v15 = v8;
  }
  else {
    memmove((void *)(v17 + v8 + __n_add), (const void *)(v17 + v8), v15 - v8);
  }
LABEL_43:
  std::string::size_type v21 = v15 + __n_add;
  if (*(char *)(v5 + 23) < 0) {
    *(void *)(v5 + 8) = v21;
  }
  else {
    *(unsigned char *)(v5 + 23) = v21 & 0x7F;
  }
  *(unsigned char *)(v17 + v21) = 0;
  if (size)
  {
    int v22 = (std::string::value_type *)(v17 + v8);
    do
    {
      std::string::value_type v23 = v13->__r_.__value_.__s.__data_[0];
      uint64_t v13 = (std::string *)((char *)v13 + 1);
      *v22++ = v23;
      --size;
    }
    while (size);
  }
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v24.__r_.__value_.__l.__data_);
  }
}

void sub_1BB366B2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void GetChannelLayoutSphericalCoordinates(AudioChannelLayout *a1, float *a2)
{
  std::string __p = 0;
  std::string v72 = 0;
  unint64_t v73 = 0;
  unint64_t v68 = 0;
  unint64_t v69 = 0;
  unint64_t v70 = 0;
  uint64_t v65 = 0;
  BOOL v66 = 0;
  unint64_t v67 = 0;
  if (*(_DWORD *)a2 == 0x10000)
  {
    uint8x8_t v17 = (uint8x8_t)vcnt_s8((int8x8_t)*((unsigned int *)a2 + 1));
    v17.i16[0] = vaddlv_u8(v17);
    unsigned int v18 = v17.i32[0];
LABEL_24:
    LOBYTE(inSpecifier) = 0;
    std::vector<char>::vector(&outPropertyData, 0x20uLL, (const std::vector<char>::value_type *)&inSpecifier);
    std::vector<char>::pointer begin = outPropertyData.__begin_;
    *(void *)outPropertyData.__begin_ = 0;
    *((_DWORD *)begin + 2) = 0;
    if (v18 <= 1) {
      int v20 = 1;
    }
    else {
      int v20 = v18;
    }
    unint64_t v21 = (20 * v20 + 12);
    LOBYTE(inSpecifier) = 0;
    int end = (int)outPropertyData.__end_;
    if (v21 <= outPropertyData.__end_ - begin)
    {
      if (v21 < outPropertyData.__end_ - begin)
      {
        int end = begin + v21;
        outPropertyData.__end_ = &begin[v21];
      }
    }
    else
    {
      std::vector<char>::__append(&outPropertyData, v21 - (outPropertyData.__end_ - begin), (std::vector<char>::const_reference)&inSpecifier);
      std::vector<char>::pointer begin = outPropertyData.__begin_;
      int end = (int)outPropertyData.__end_;
    }
    *((_DWORD *)begin + 2) = v18;
    int v23 = *(_DWORD *)a2;
    UInt32 inSpecifier = end - begin;
    if (v23 == 0x10000) {
      AudioFormatPropertyID v24 = 1668116578;
    }
    else {
      AudioFormatPropertyID v24 = 1668116588;
    }
    if (v23 == 0x10000) {
      uint64_t v25 = a2 + 1;
    }
    else {
      uint64_t v25 = a2;
    }
    AudioFormatGetProperty(v24, 4u, v25, &inSpecifier, begin);
    unsigned int v26 = outPropertyData.__begin_;
    unint64_t v27 = *((unsigned int *)outPropertyData.__begin_ + 2);
    if (v27 > (outPropertyData.__end_ - outPropertyData.__begin_ - 12) / 0x14uLL) {
LABEL_89:
    }
      __assert_rtn("GetNumberChannelDescriptions", "CoreAudioBaseTypes.hpp", 2237, "GetAudioChannelLayout().mNumberChannelDescriptions <= (mStorage.size() - kHeaderSize) / sizeof(AudioChannelDescription)");
    unint64_t v28 = 0;
    while (v28 < v27)
    {
      uint64_t v29 = &v26[20 * v28 + 20];
      uint64_t v30 = v72;
      if ((unint64_t)v72 >= v73)
      {
        unsigned int v32 = __p;
        uint64_t v33 = ((char *)v72 - (unsigned char *)__p) >> 2;
        unint64_t v34 = v33 + 1;
        if ((unint64_t)(v33 + 1) >> 62) {
          goto LABEL_98;
        }
        uint64_t v35 = v73 - (void)__p;
        if ((uint64_t)(v73 - (void)__p) >> 1 > v34) {
          unint64_t v34 = v35 >> 1;
        }
        if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v36 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v36 = v34;
        }
        if (v36)
        {
          unint64_t v37 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)&v73, v36);
          unsigned int v32 = __p;
          uint64_t v30 = v72;
        }
        else
        {
          unint64_t v37 = 0;
        }
        int v38 = &v37[4 * v33];
        *(_DWORD *)int v38 = *(_DWORD *)v29;
        unsigned int v31 = v38 + 4;
        while (v30 != v32)
        {
          int v39 = *--v30;
          *((_DWORD *)v38 - 1) = v39;
          v38 -= 4;
        }
        std::string __p = v38;
        std::string v72 = v31;
        unint64_t v73 = (unint64_t)&v37[4 * v36];
        if (v32) {
          operator delete(v32);
        }
      }
      else
      {
        *std::string v72 = *(_DWORD *)v29;
        unsigned int v31 = v30 + 1;
      }
      std::string v72 = v31;
      char v40 = &outPropertyData.__begin_[20 * v28 + 24];
      uint64_t v41 = v69;
      if ((unint64_t)v69 >= v70)
      {
        unsigned __int8 v43 = v68;
        uint64_t v44 = ((char *)v69 - (unsigned char *)v68) >> 2;
        unint64_t v45 = v44 + 1;
        if ((unint64_t)(v44 + 1) >> 62) {
          goto LABEL_98;
        }
        uint64_t v46 = v70 - (void)v68;
        if ((uint64_t)(v70 - (void)v68) >> 1 > v45) {
          unint64_t v45 = v46 >> 1;
        }
        if ((unint64_t)v46 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v47 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v47 = v45;
        }
        if (v47)
        {
          char v48 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)&v70, v47);
          unsigned __int8 v43 = v68;
          uint64_t v41 = v69;
        }
        else
        {
          char v48 = 0;
        }
        uint64_t v49 = &v48[4 * v44];
        *(_DWORD *)uint64_t v49 = *(_DWORD *)v40;
        unint64_t v42 = v49 + 4;
        while (v41 != v43)
        {
          int v50 = *--v41;
          *((_DWORD *)v49 - 1) = v50;
          v49 -= 4;
        }
        unint64_t v68 = v49;
        unint64_t v69 = v42;
        unint64_t v70 = (unint64_t)&v48[4 * v47];
        if (v43) {
          operator delete(v43);
        }
      }
      else
      {
        *unint64_t v69 = *(_DWORD *)v40;
        unint64_t v42 = v41 + 1;
      }
      unint64_t v69 = v42;
      int v51 = &outPropertyData.__begin_[20 * v28 + 28];
      BOOL v52 = v66;
      if ((unint64_t)v66 >= v67)
      {
        std::locale v54 = v65;
        uint64_t v55 = ((char *)v66 - (unsigned char *)v65) >> 2;
        unint64_t v56 = v55 + 1;
        if ((unint64_t)(v55 + 1) >> 62) {
LABEL_98:
        }
          std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
        uint64_t v57 = v67 - (void)v65;
        if ((uint64_t)(v67 - (void)v65) >> 1 > v56) {
          unint64_t v56 = v57 >> 1;
        }
        if ((unint64_t)v57 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v58 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v58 = v56;
        }
        if (v58)
        {
          uint64_t v59 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)&v67, v58);
          std::locale v54 = v65;
          BOOL v52 = v66;
        }
        else
        {
          uint64_t v59 = 0;
        }
        unint64_t v60 = &v59[4 * v55];
        *(_DWORD *)unint64_t v60 = *(_DWORD *)v51;
        char v53 = v60 + 4;
        while (v52 != v54)
        {
          int v61 = *--v52;
          *((_DWORD *)v60 - 1) = v61;
          v60 -= 4;
        }
        uint64_t v65 = v60;
        BOOL v66 = v53;
        unint64_t v67 = (unint64_t)&v59[4 * v58];
        if (v54) {
          operator delete(v54);
        }
      }
      else
      {
        *BOOL v66 = *(_DWORD *)v51;
        char v53 = v52 + 1;
      }
      BOOL v66 = v53;
      ++v28;
      unsigned int v26 = outPropertyData.__begin_;
      unint64_t v27 = *((unsigned int *)outPropertyData.__begin_ + 2);
      if (v27 > (outPropertyData.__end_ - outPropertyData.__begin_ - 12) / 0x14uLL) {
        goto LABEL_89;
      }
    }
    outPropertyData.__end_ = v26;
    operator delete(v26);
    goto LABEL_91;
  }
  if (*(_DWORD *)a2)
  {
    unsigned int v18 = (unsigned __int16)*(_DWORD *)a2;
    goto LABEL_24;
  }
  unint64_t v4 = *((unsigned int *)a2 + 2);
  LODWORD(outPropertyData.__begin_) = 0;
  std::vector<float>::resize((uint64_t)&__p, v4, &outPropertyData);
  unint64_t v5 = *((unsigned int *)a2 + 2);
  LODWORD(outPropertyData.__begin_) = 0;
  std::vector<float>::resize((uint64_t)&v68, v5, &outPropertyData);
  unint64_t v6 = *((unsigned int *)a2 + 2);
  LODWORD(outPropertyData.__begin_) = 0;
  std::vector<float>::resize((uint64_t)&v65, v6, &outPropertyData);
  unint64_t v7 = *((unsigned int *)a2 + 2);
  if (v7)
  {
    unint64_t v8 = 0;
    unsigned int v9 = a2 + 7;
    do
    {
      if ((*(_DWORD *)(v9 - 3) & 3) == 1)
      {
        float v12 = *(v9 - 2);
        float v13 = *(v9 - 1);
        float v14 = *v9;
        std::string::size_type v15 = (float *)v65;
        *((float *)v65 + v8) = sqrtf((float)((float)(v13 * v13) + (float)(v12 * v12)) + (float)(*v9 * *v9));
        if (fabsf(v12) < 0.000001 && fabsf(v13) < 0.000001)
        {
          *((_DWORD *)__p + v8) = 0;
          if (v14 <= 0.0)
          {
            if (v14 < 0.0) {
              *((_DWORD *)v68 + v8) = -1028390912;
            }
            else {
              *((_DWORD *)v68 + v8) = 0;
            }
          }
          else
          {
            *((_DWORD *)v68 + v8) = 1119092736;
          }
          goto LABEL_17;
        }
        *((float *)__p + v8) = atan2f(v12, v13) * 57.296;
        float v10 = asinf(v14 / v15[v8]) * 57.296;
        unint64_t v11 = (float *)v68;
      }
      else
      {
        if ((*(_DWORD *)(v9 - 3) & 3) != 2)
        {
          UInt32 v16 = *((_DWORD *)v9 - 4);
          UInt32 ioPropertyDataSize = 20;
          UInt32 inSpecifier = v16;
          if (!AudioFormatGetProperty(0x6473636Cu, 4u, &inSpecifier, &ioPropertyDataSize, &outPropertyData))
          {
            *((_DWORD *)__p + v8) = outPropertyData.__end_;
            *((_DWORD *)v68 + v8) = HIDWORD(outPropertyData.__end_);
            *((_DWORD *)v65 + v8) = outPropertyData.__end_cap_.__value_;
          }
          unint64_t v7 = *((unsigned int *)a2 + 2);
          goto LABEL_17;
        }
        *((float *)__p + v8) = *(v9 - 2);
        *((float *)v68 + v8) = *(v9 - 1);
        float v10 = *v9;
        unint64_t v11 = (float *)v65;
      }
      v11[v8] = v10;
LABEL_17:
      v9 += 5;
      ++v8;
    }
    while (v8 < v7);
  }
LABEL_91:
  *(void *)&a1->AudioChannelLayoutTag mChannelLayoutTag = 0;
  *(void *)&a1->mNumberChannelDescriptions = 0;
  *(void *)&a1->mChannelDescriptions[0].mChannelFlags = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(a1, __p, (uint64_t)v72, ((char *)v72 - (unsigned char *)__p) >> 2);
  *(void *)&a1->mChannelDescriptions[0].mCoordinates[1] = 0;
  *(void *)&a1[1].AudioChannelLayoutTag mChannelLayoutTag = 0;
  *(void *)&a1[1].mNumberChannelDescriptions = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&a1->mChannelDescriptions[0].mCoordinates[1], v68, (uint64_t)v69, ((char *)v69 - (unsigned char *)v68) >> 2);
  *(void *)&a1[1].mChannelDescriptions[0].mChannelFlags = 0;
  *(void *)&a1[1].mChannelDescriptions[0].mCoordinates[1] = 0;
  *(void *)&a1[2].AudioChannelLayoutTag mChannelLayoutTag = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&a1[1].mChannelDescriptions[0].mChannelFlags, v65, (uint64_t)v66, ((char *)v66 - (unsigned char *)v65) >> 2);
  if (v65)
  {
    BOOL v66 = v65;
    operator delete(v65);
  }
  if (v68)
  {
    unint64_t v69 = v68;
    operator delete(v68);
  }
  if (__p)
  {
    std::string v72 = __p;
    operator delete(__p);
  }
}

void sub_1BB3671AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  if (a14) {
    operator delete(a14);
  }
  if (a17) {
    operator delete(a17);
  }
  if (a20) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

__n128 std::__memberwise_forward_assign[abi:ne180100]<std::tuple<std::vector<float> &,std::vector<float> &,std::vector<float> &>,std::tuple<std::vector<float>,std::vector<float>,std::vector<float>>,std::vector<float>,std::vector<float>,std::vector<float>,0ul,1ul,2ul>(void ***a1, uint64_t a2)
{
  unint64_t v4 = *a1;
  unint64_t v5 = **a1;
  if (v5)
  {
    v4[1] = v5;
    operator delete(v5);
    std::string::value_type *v4 = 0;
    v4[1] = 0;
    v4[2] = 0;
  }
  *(_OWORD *)unint64_t v4 = *(_OWORD *)a2;
  v4[2] = *(void **)(a2 + 16);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  unint64_t v6 = a1[1];
  unint64_t v7 = *v6;
  if (*v6)
  {
    v6[1] = v7;
    operator delete(v7);
    char *v6 = 0;
    v6[1] = 0;
    v6[2] = 0;
  }
  *(_OWORD *)unint64_t v6 = *(_OWORD *)(a2 + 24);
  v6[2] = *(void **)(a2 + 40);
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  unint64_t v8 = a1[2];
  unsigned int v9 = *v8;
  if (*v8)
  {
    v8[1] = v9;
    operator delete(v9);
    *unint64_t v8 = 0;
    v8[1] = 0;
    v8[2] = 0;
  }
  __n128 result = *(__n128 *)(a2 + 48);
  *(__n128 *)unint64_t v8 = result;
  v8[2] = *(void **)(a2 + 64);
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  return result;
}

void GetChannelLayoutSphericalCoordinates(AudioChannelLayout *a1)
{
  std::vector<char>::value_type __x = 0;
  std::vector<char>::vector(&__p, 0x20uLL, &__x);
  std::vector<char>::pointer begin = __p.__begin_;
  *((_DWORD *)__p.__begin_ + 1) = 0;
  *((_DWORD *)begin + 2) = 0;
  *(_DWORD *)std::vector<char>::pointer begin = 6619138;
  GetChannelLayoutSphericalCoordinates(a1, (float *)begin);
  if (__p.__begin_)
  {
    __p.__end_ = __p.__begin_;
    operator delete(__p.__begin_);
  }
}

void sub_1BB367384(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void GetChannelLayoutChannelLabels(const AudioChannelLayout *a1, int a2)
{
  std::vector<char>::value_type __x = 0;
  std::vector<char>::vector(&__p, 0x20uLL, &__x);
  std::vector<char>::pointer begin = (int *)__p.__begin_;
  *((_DWORD *)__p.__begin_ + 1) = 0;
  begin[2] = 0;
  *std::vector<char>::pointer begin = a2;
  GetChannelLayoutChannelLabels(a1, begin);
  if (__p.__begin_)
  {
    __p.__end_ = __p.__begin_;
    operator delete(__p.__begin_);
  }
}

void sub_1BB367404(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void GetChannelLayoutChannelLabels(const AudioChannelLayout *this, int *a2)
{
  if (*a2 == 0x10000)
  {
    uint8x8_t v5 = (uint8x8_t)vcnt_s8((int8x8_t)a2[1]);
    v5.i16[0] = vaddlv_u8(v5);
    unsigned int v4 = v5.i32[0];
  }
  else if (*a2)
  {
    unsigned int v4 = (unsigned __int16)*a2;
  }
  else
  {
    unsigned int v4 = a2[2];
  }
  uint64_t v6 = v4;
  LODWORD(__x.__begin_) = -1;
  std::vector<unsigned int>::vector((std::vector<unsigned int> *)this, v4, (const std::vector<unsigned int>::value_type *)&__x);
  if (*a2)
  {
    v21[0] = 0;
    std::vector<char>::vector(&__x, 0x20uLL, v21);
    std::vector<char>::pointer begin = __x.__begin_;
    *(void *)__x.__begin_ = 0;
    *((_DWORD *)begin + 2) = 0;
    if (v4 <= 1) {
      unsigned int v8 = 1;
    }
    else {
      unsigned int v8 = v4;
    }
    unsigned int v9 = (char *)(20 * v8 + 12);
    v21[0] = 0;
    int end = (int)__x.__end_;
    if (v9 <= (std::vector<char>::pointer)(__x.__end_ - begin))
    {
      if (v9 < (std::vector<char>::pointer)(__x.__end_ - begin))
      {
        int end = begin + v9;
        __x.__end_ = &v9[(void)begin];
      }
    }
    else
    {
      std::vector<char>::__append(&__x, (std::vector<char>::size_type)&v9[-(__x.__end_ - begin)], v21);
      std::vector<char>::pointer begin = __x.__begin_;
      int end = (int)__x.__end_;
    }
    *((_DWORD *)begin + 2) = v4;
    int v14 = *a2;
    *(_DWORD *)unint64_t v21 = end - begin;
    if (v14 == 0x10000) {
      AudioFormatPropertyID v15 = 1668116578;
    }
    else {
      AudioFormatPropertyID v15 = 1668116588;
    }
    if (v14 == 0x10000) {
      UInt32 v16 = a2 + 1;
    }
    else {
      UInt32 v16 = a2;
    }
    AudioFormatGetProperty(v15, 4u, v16, (UInt32 *)v21, begin);
    uint8x8_t v17 = __x.__begin_;
    if (v4)
    {
      std::vector<char>::pointer v18 = __x.__begin_ + 12;
      char v19 = *(_DWORD **)&this->mChannelLayoutTag;
      do
      {
        int v20 = *(_DWORD *)v18;
        v18 += 20;
        *v19++ = v20;
        --v6;
      }
      while (v6);
    }
    else if (!__x.__begin_)
    {
      return;
    }
    __x.__end_ = v17;
    operator delete(v17);
  }
  else if (v4)
  {
    unint64_t v11 = *(_DWORD **)&this->mChannelLayoutTag;
    float v12 = a2 + 3;
    do
    {
      int v13 = *v12;
      v12 += 5;
      *v11++ = v13;
      --v6;
    }
    while (v6);
  }
}

void sub_1BB36759C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  int v13 = *(void **)v11;
  if (*(void *)v11)
  {
    *(void *)(v11 + 8) = v13;
    operator delete(v13);
  }
  _Unwind_Resume(exception_object);
}

std::vector<unsigned int> *__cdecl std::vector<unsigned int>::vector(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n, const std::vector<unsigned int>::value_type *__x)
{
  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    std::vector<unsigned int>::__vallocate[abi:ne180100](this, __n);
    std::vector<unsigned int>::pointer end = this->__end_;
    unint64_t v7 = &end[__n];
    std::vector<unsigned int>::size_type v8 = 4 * __n;
    do
    {
      *end++ = *__x;
      v8 -= 4;
    }
    while (v8);
    this->__end_ = v7;
  }
  return this;
}

void sub_1BB36763C(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<unsigned int>::resize(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __sz, std::vector<unsigned int>::const_reference __x)
{
  std::vector<unsigned int>::pointer begin = this->__begin_;
  std::vector<unsigned int>::pointer end = this->__end_;
  std::vector<unsigned int>::size_type v7 = end - this->__begin_;
  if (__sz <= v7)
  {
    if (__sz < v7) {
      this->__end_ = &begin[__sz];
    }
  }
  else
  {
    p_end_cap = &this->__end_cap_;
    value = this->__end_cap_.__value_;
    if (__sz - v7 <= value - end)
    {
      AudioFormatPropertyID v24 = &end[__sz - v7];
      std::vector<unsigned int>::size_type v25 = 4 * __sz - 4 * v7;
      do
      {
        *end++ = *__x;
        v25 -= 4;
      }
      while (v25);
      this->__end_ = v24;
    }
    else
    {
      if (__sz >> 62) {
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v11 = (char *)value - (char *)begin;
      std::vector<unsigned int>::size_type v12 = ((char *)value - (char *)begin) >> 1;
      if (v12 <= __sz) {
        std::vector<unsigned int>::size_type v12 = __sz;
      }
      if (v11 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v13 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v13 = v12;
      }
      int v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)p_end_cap, v13);
      UInt32 v16 = (unsigned int *)&v14[4 * v7];
      uint8x8_t v17 = (unsigned int *)&v14[4 * __sz];
      std::vector<unsigned int>::size_type v18 = 4 * __sz - 4 * v7;
      char v19 = v16;
      do
      {
        *v19++ = *__x;
        v18 -= 4;
      }
      while (v18);
      int v20 = (unsigned int *)&v14[4 * v15];
      std::vector<unsigned int>::pointer v21 = this->__begin_;
      for (std::vector<unsigned int>::pointer i = this->__end_; i != v21; --i)
      {
        unsigned int v23 = *(i - 1);
        *--UInt32 v16 = v23;
      }
      this->__begin_ = v16;
      this->__end_ = v17;
      this->__end_cap_.__value_ = v20;
      if (v21)
      {
        operator delete(v21);
      }
    }
  }
}

void SpectralProfile::SetProfile(SpectralProfile *this, CFTypeRef cf)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (!cf)
  {
    exception = (CAXException *)__cxa_allocate_exception(0x110uLL);
    CAXException::CAXException(exception, "The CFDictionary object is invalid.", -1);
  }
  CFRetain(cf);
  unsigned int valuePtr = 0;
  value = 0;
  if (!CFDictionaryGetValueIfPresent((CFDictionaryRef)cf, @"SampleRate", (const void **)&value))
  {
    CFRelease(cf);
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(void *)&uint8_t buf[4] = "SpectralProfile.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 75;
      _os_log_impl(&dword_1BB0CE000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%25s:%-5d Sample rate is not present in the dictionary.\n", buf, 0x12u);
    }
    UInt32 v16 = (CAXException *)__cxa_allocate_exception(0x110uLL);
    CAXException::CAXException(v16, "Sample rate is not present in the dictionary.", -1);
  }
  if (CFNumberGetValue((CFNumberRef)value, kCFNumberIntType, &valuePtr))
  {
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO)) {
      goto LABEL_9;
    }
    *(_DWORD *)buf = 136315650;
    *(void *)&uint8_t buf[4] = "SpectralProfile.cpp";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 66;
    __int16 v23 = 1024;
    unsigned int v24 = valuePtr;
    uint8x8_t v5 = MEMORY[0x1E4F14500];
    uint64_t v6 = "%25s:%-5d Successfully retrieved sample rate (%iHz).\n";
    os_log_type_t v7 = OS_LOG_TYPE_INFO;
  }
  else
  {
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_9;
    }
    *(_DWORD *)buf = 136315650;
    *(void *)&uint8_t buf[4] = "SpectralProfile.cpp";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 68;
    __int16 v23 = 1024;
    unsigned int v24 = valuePtr;
    uint8x8_t v5 = MEMORY[0x1E4F14500];
    uint64_t v6 = "%25s:%-5d Sample rate retrieved ambiguously (%iHz).\n";
    os_log_type_t v7 = OS_LOG_TYPE_DEFAULT;
  }
  _os_log_impl(&dword_1BB0CE000, v5, v7, v6, buf, 0x18u);
LABEL_9:
  CFDataRef theData = 0;
  if (!CFDictionaryGetValueIfPresent((CFDictionaryRef)cf, @"NoiseProfile", (const void **)&theData))
  {
    CFRelease(cf);
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(void *)&uint8_t buf[4] = "SpectralProfile.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 97;
      _os_log_impl(&dword_1BB0CE000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%25s:%-5d Profile vector is not present in the dictionary.\n", buf, 0x12u);
    }
    uint8x8_t v17 = (CAXException *)__cxa_allocate_exception(0x110uLL);
    CAXException::CAXException(v17, "Profile vector is not present in the dictionary.", -1);
  }
  CFDataRef v8 = theData;
  unsigned int Length = CFDataGetLength(theData);
  unsigned int v10 = Length >> 2;
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315650;
    *(void *)&uint8_t buf[4] = "SpectralProfile.cpp";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 105;
    __int16 v23 = 1024;
    unsigned int v24 = Length >> 2;
    _os_log_impl(&dword_1BB0CE000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "%25s:%-5d Successfully retrieved profile vector (length %i).\n", buf, 0x18u);
  }
  int v18 = 0;
  std::vector<float>::vector(buf, v10, &v18);
  BytePtr = CFDataGetBytePtr(v8);
  if (Length >= 4)
  {
    std::vector<unsigned int>::size_type v12 = *(_DWORD **)buf;
    if (v10 <= 1) {
      uint64_t v13 = 1;
    }
    else {
      uint64_t v13 = v10;
    }
    do
    {
      unsigned int v14 = *(_DWORD *)BytePtr;
      BytePtr += 4;
      *v12++ = bswap32(v14);
      --v13;
    }
    while (v13);
  }
  CFRelease(cf);
  LODWORD(v2) = valuePtr;
  if (buf != (unsigned char *)this) {
    std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)this, *(char **)buf, *(uint64_t *)&buf[8], (uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 2);
  }
  *((double *)this + 3) = (double)v2;
  *((_DWORD *)this + 8) = 2 * v10;
  if (*(void *)buf)
  {
    *(void *)&buf[8] = *(void *)buf;
    operator delete(*(void **)buf);
  }
}

void sub_1BB367BD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  __cxa_free_exception(v14);
  _Unwind_Resume(a1);
}

void CAXException::CAXException(CAXException *this, const char *__s, int a3)
{
  *(void *)this = &unk_1F14C8AE0;
  *((_DWORD *)this + 66) = a3;
  if (__s)
  {
    size_t v5 = strlen(__s);
    uint64_t v6 = (char *)this + 8;
    if (v5 < 0x100)
    {
      strlcpy(v6, __s, 0x100uLL);
    }
    else
    {
      long long v7 = *(_OWORD *)__s;
      long long v8 = *((_OWORD *)__s + 1);
      long long v9 = *((_OWORD *)__s + 3);
      *(_OWORD *)((char *)this + 40) = *((_OWORD *)__s + 2);
      *(_OWORD *)((char *)this + 56) = v9;
      *(_OWORD *)uint64_t v6 = v7;
      *(_OWORD *)((char *)this + 24) = v8;
      long long v10 = *((_OWORD *)__s + 4);
      long long v11 = *((_OWORD *)__s + 5);
      long long v12 = *((_OWORD *)__s + 7);
      *(_OWORD *)((char *)this + 104) = *((_OWORD *)__s + 6);
      *(_OWORD *)((char *)this + 120) = v12;
      *(_OWORD *)((char *)this + 72) = v10;
      *(_OWORD *)((char *)this + 88) = v11;
      long long v13 = *((_OWORD *)__s + 8);
      long long v14 = *((_OWORD *)__s + 9);
      long long v15 = *((_OWORD *)__s + 11);
      *(_OWORD *)((char *)this + 168) = *((_OWORD *)__s + 10);
      *(_OWORD *)((char *)this + 184) = v15;
      *(_OWORD *)((char *)this + 136) = v13;
      *(_OWORD *)((char *)this + 152) = v14;
      long long v16 = *((_OWORD *)__s + 12);
      long long v17 = *((_OWORD *)__s + 13);
      long long v18 = *((_OWORD *)__s + 14);
      *(_OWORD *)((char *)this + 247) = *(_OWORD *)(__s + 239);
      *(_OWORD *)((char *)this + 216) = v17;
      *(_OWORD *)((char *)this + 232) = v18;
      *(_OWORD *)((char *)this + 200) = v16;
      *((unsigned char *)this + 263) = 0;
    }
  }
  else
  {
    *((unsigned char *)this + 8) = 0;
  }
}

void sub_1BB367CE0(_Unwind_Exception *a1)
{
  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void SpectralProfile::GetProfile(SpectralProfile *this, double a2, uint64_t a3, unsigned int a4, float a5, unsigned int a6)
{
  float v30 = a5;
  unint64_t v11 = a4;
  std::vector<float>::vector(__p, a4, &v30);
  long long v12 = *(float **)a3;
  uint64_t v13 = *(void *)(a3 + 8);
  if (v13 == *(void *)a3)
  {
LABEL_12:
    *(_OWORD *)this = *(_OWORD *)__p;
    *((void *)this + 2) = v29;
    return;
  }
  unint64_t v14 = (v13 - *(void *)a3) >> 2;
  double v15 = *(double *)(a3 + 24);
  if (v14 != v11 || v15 != a2)
  {
    if (a4)
    {
      uint64_t v17 = 0;
      float v18 = a2;
      float v19 = v18 / (float)a6;
      float v20 = v15;
      std::vector<unsigned int>::pointer v21 = (float *)__p[0];
      float v22 = (float)*(unsigned int *)(a3 + 32) / v20;
      do
      {
        float v23 = v19 * (float)v17;
        unsigned int v24 = vcvtms_u32_f32(v22 * v23);
        unint64_t v25 = v24 + 1;
        if (v14 <= v25)
        {
          float v27 = *(float *)(v13 - 4);
        }
        else
        {
          float v26 = -(float)(floorf(v22 * v23) - (float)(v23 * v22));
          float v27 = (float)((float)(1.0 - v26) * v12[v24]) + (float)(v12[v25] * v26);
        }
        v21[v17++] = v27;
      }
      while (v11 != v17);
    }
    goto LABEL_12;
  }
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(this, v12, v13, v11);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_1BB367E30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t VoiceProcessorV2::PreflightDownlink(atomic_uint *this, unsigned int ExpectedNumberOfOutputFrames, unsigned int *a3, unsigned int *a4)
{
  atomic_fetch_add(this + 621, 1u);
  if (this[620])
  {
    float v5 = flt_1BB8781B8[*((unsigned char *)this + 476) == 0];
    if (*((unsigned char *)this + 476)) {
      VoiceProcessorV2::LogIOError((uint64_t)this, v5, (float)this[3128], (float)this[3129], 0.0, "preflight downlink: tryer acquire failed", a3, a4);
    }
    else {
      VoiceProcessorV2::LogIOError((uint64_t)this, v5, (float)this[3128], (float)this[3129], 0.0, "preflight downlink: not ok to process?!", a3, a4);
    }
LABEL_5:
    CADeprecated::CAMutex::Lock((CADeprecated::CAMutex *)(this + 644));
    ++this[3128];
    CADeprecated::CAMutex::Unlock((CADeprecated::CAMutex *)(this + 644));
    uint64_t v6 = 1937006964;
    if (this[3128] == 1) {
      VoiceProcessorV2::LogNonTransientErrors((VoiceProcessorV2 *)this, 0);
    }
    goto LABEL_19;
  }
  if (!*((unsigned char *)this + 476))
  {
    VoiceProcessorV2::LogIOError((uint64_t)this, 32.005, (float)this[3128], (float)this[3129], 0.0, "preflight downlink: not ok to process?!", a3, a4);
    goto LABEL_5;
  }
  long long v9 = (CA::AudioSampleRateConverter **)*((void *)this + 47);
  if (v9) {
    ExpectedNumberOfOutputFrames = CA::AudioSampleRateConverter::GetExpectedNumberOfOutputFrames(*v9);
  }
  long long v10 = (CA::AudioSampleRateConverter **)*((void *)this + 48);
  if (!v10)
  {
    int v11 = ExpectedNumberOfOutputFrames / this[121] * this[121];
    goto LABEL_15;
  }
  int v11 = CA::AudioSampleRateConverter::GetExpectedNumberOfOutputFrames(*v10) / this[121] * this[121];
  if (!*((void *)this + 48))
  {
LABEL_15:
    unsigned int RequiredNumberOfInputFrames = v11;
    goto LABEL_16;
  }
  unsigned int RequiredNumberOfInputFrames = AudioSampleRateConverterGetRequiredNumberOfInputFrames();
LABEL_16:
  if (*((void *)this + 47)) {
    unsigned int RequiredNumberOfInputFrames = AudioSampleRateConverterGetRequiredNumberOfInputFrames();
  }
  uint64_t v6 = 0;
  *a3 = RequiredNumberOfInputFrames;
  *a4 = v11;
LABEL_19:
  atomic_fetch_add(this + 621, 0xFFFFFFFF);
  return v6;
}

void sub_1BB367FD0(_Unwind_Exception *a1)
{
  atomic_fetch_add((atomic_uint *volatile)(v1 + 2484), 0xFFFFFFFF);
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'AUSpatialMixerV2OutputElement::PropertyObserverIsInitialized(AUSpatialMixerV2OutputElement *this)
{
  return *((unsigned __int8 *)this + 16);
}

uint64_t non-virtual thunk to'AUSpatialMixerV2OutputElement::PropertyChanged(AUSpatialMixerV2OutputElement *this, int a2)
{
  if (a2 != 3220) {
    return 0;
  }
  AudioChannelLayoutTag v2 = atomic_load((unsigned int *)this + 30);
  if (*((unsigned char *)this + 17) || v2 > 0xFFFEFFFF) {
    return 0;
  }
  else {
    return AUSpatialMixerV2OutputElement::SetFullLayoutFromTag((AUSpatialMixerV2OutputElement *)((char *)this - 176), v2, 1);
  }
}

uint64_t AUSpatialMixerV2OutputElement::SetFullLayoutFromTag(AUSpatialMixerV2OutputElement *this, AudioChannelLayoutTag a2, int a3)
{
  std::vector<char>::value_type __x = 0;
  std::vector<char>::vector(&__p, 0x20uLL, &__x);
  std::vector<unsigned int>::pointer begin = (AudioChannelLayout *)__p.__begin_;
  *((_DWORD *)__p.__begin_ + 1) = 0;
  begin->mNumberChannelDescriptions = 0;
  begin->AudioChannelLayoutTag mChannelLayoutTag = a2;
  uint64_t v7 = AUSpatialMixerV2OutputElement::SetFullLayout(this, begin, a3);
  if (__p.__begin_)
  {
    __p.__end_ = __p.__begin_;
    operator delete(__p.__begin_);
  }
  return v7;
}

void sub_1BB36809C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t AUSpatialMixerV2OutputElement::SetFullLayout(AUSpatialMixerV2OutputElement *this, const AudioChannelLayout *a2, int a3)
{
  v41[2] = *MEMORY[0x1E4F143B8];
  AudioChannelLayoutTag mChannelLayoutTag = a2->mChannelLayoutTag;
  if ((a2->mChannelLayoutTag & 0xFFFEFFFF) != 0 && **((_DWORD **)this + 15) == mChannelLayoutTag)
  {
LABEL_43:
    uint64_t v11 = 0;
    goto LABEL_44;
  }
  if (mChannelLayoutTag == 0x10000)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2->mChannelBitmap);
    v9.i16[0] = vaddlv_u8(v9);
    UInt32 mNumberChannelDescriptions = v9.i32[0];
  }
  else if (mChannelLayoutTag)
  {
    UInt32 mNumberChannelDescriptions = (unsigned __int16)a2->mChannelLayoutTag;
  }
  else
  {
    UInt32 mNumberChannelDescriptions = a2->mNumberChannelDescriptions;
  }
  if (mNumberChannelDescriptions <= 1)
  {
    if (getAUSMV2Log(void)::onceToken != -1) {
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
    }
    uint64_t v10 = getAUSMV2Log(void)::gLog;
    if (!os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR))
    {
LABEL_14:
      uint64_t v11 = 4294956445;
      goto LABEL_46;
    }
    unint64_t v34 = (void *)((char *)this + 200);
    if (*((char *)this + 223) < 0) {
      unint64_t v34 = (void *)*v34;
    }
    GetStringFromAudioChannelLayoutTag(&__p, mChannelLayoutTag);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)buf = 136315906;
    *(void *)&uint8_t buf[4] = v34;
    __int16 v38 = 2080;
    int v39 = "SetFullLayout";
    __int16 v40 = 1024;
    LODWORD(v41[0]) = mNumberChannelDescriptions;
    WORD2(v41[0]) = 2080;
    *(void *)((char *)v41 + 6) = p_p;
    float v30 = "[%s|%s] Unsupported number of channels %u in audio channel layout %s: must be two or more";
    goto LABEL_79;
  }
  if (!*((unsigned char *)this + 192))
  {
    if (((*(uint64_t (**)(void))(**((void **)this + 23) + 608))(*((void *)this + 23)) & 1) == 0
      && *((_DWORD *)this + 27) != mNumberChannelDescriptions
      && (a3 & 1) == 0)
    {
      if (getAUSMV2Log(void)::onceToken != -1) {
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
      }
      uint64_t v10 = getAUSMV2Log(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR)) {
        goto LABEL_14;
      }
      unint64_t v28 = (void *)((char *)this + 200);
      if (*((char *)this + 223) < 0) {
        unint64_t v28 = (void *)*v28;
      }
      GetStringFromAudioChannelLayoutTag(&__p, mChannelLayoutTag);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v29 = &__p;
      }
      else {
        uint64_t v29 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)buf = 136315906;
      *(void *)&uint8_t buf[4] = v28;
      __int16 v38 = 2080;
      int v39 = "SetFullLayout";
      __int16 v40 = 1024;
      LODWORD(v41[0]) = mNumberChannelDescriptions;
      WORD2(v41[0]) = 2080;
      *(void *)((char *)v41 + 6) = v29;
      float v30 = "[%s|%s] Number of channels %u in requested audio channel layout %s is different than in the stream format.";
LABEL_79:
      uint64_t v33 = v10;
LABEL_80:
      _os_log_error_impl(&dword_1BB0CE000, v33, OS_LOG_TYPE_ERROR, v30, buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      goto LABEL_82;
    }
    goto LABEL_29;
  }
  if (*((_DWORD *)this + 27) == mNumberChannelDescriptions)
  {
LABEL_29:
    ausdk::AUIOElement::ForceSetAudioChannelLayout(this, a2);
    uint64_t v15 = *((void *)this + 23);
    unsigned __int8 v16 = atomic_load((unsigned __int8 *)(v15 + 8977));
    if (v16)
    {
      *(void *)buf = v15 + 3120;
      buf[8] = 1;
      std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)(v15 + 3120));
      for (unsigned int i = 0; ; ++i)
      {
        uint64_t v18 = *(void *)(v15 + 120);
        if (v18) {
          LODWORD(v19) = (*(uint64_t (**)(uint64_t))(*(void *)v18 + 24))(v18);
        }
        else {
          uint64_t v19 = (*(void *)(v15 + 104) - *(void *)(v15 + 96)) >> 3;
        }
        if (i >= v19) {
          break;
        }
        uint64_t Element = (unsigned __int8 *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v15 + 80), i);
        unsigned __int8 v21 = atomic_load(Element + 608);
        if ((v21 & 1) == 0)
        {
          unsigned __int8 v22 = atomic_load(Element + 609);
          if ((v22 & 1) == 0) {
            continue;
          }
        }
        AUSpatialMixerV2InputElement::InitializeChannelProcessors((AUSpatialMixerV2InputElement *)Element);
      }
      std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)buf);
      AUSpatialMixerV2::UpdateReverbIfNecessary(v15, -1, 0, 0);
    }
    char v23 = a3 ^ 1;
    if (*((unsigned char *)this + 193)) {
      char v23 = 1;
    }
    *((unsigned char *)this + 193) = v23;
    AUSpatialMixerV2::UpdateDiffuseProcessors(*((AUSpatialMixerV2 **)this + 23));
    goto LABEL_43;
  }
  if (getAUSMV2Log(void)::onceToken != -1) {
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
  }
  long long v12 = getAUSMV2Log(void)::gLog;
  if (a3)
  {
    uint64_t v11 = 0;
    if (!os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_44;
    }
    uint64_t v13 = (void *)((char *)this + 200);
    if (*((char *)this + 223) < 0) {
      uint64_t v13 = (void *)*v13;
    }
    GetStringFromAudioChannelLayoutTag(&__p, mChannelLayoutTag);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unint64_t v14 = &__p;
    }
    else {
      unint64_t v14 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)buf = 136315906;
    *(void *)&uint8_t buf[4] = v13;
    __int16 v38 = 2080;
    int v39 = "SetFullLayout";
    __int16 v40 = 1024;
    LODWORD(v41[0]) = mNumberChannelDescriptions;
    WORD2(v41[0]) = 2080;
    *(void *)((char *)v41 + 6) = v14;
    _os_log_impl(&dword_1BB0CE000, v12, OS_LOG_TYPE_DEFAULT, "[%s|%s] Number of channels %u in requested audio channel layout is different than in the stream format. Default audio channel layout tag %s from preset is ignored.", buf, 0x26u);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    goto LABEL_43;
  }
  if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR))
  {
    unsigned int v31 = (void *)((char *)this + 200);
    if (*((char *)this + 223) < 0) {
      unsigned int v31 = (void *)*v31;
    }
    GetStringFromAudioChannelLayoutTag(&__p, mChannelLayoutTag);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unsigned int v32 = &__p;
    }
    else {
      unsigned int v32 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)buf = 136315906;
    *(void *)&uint8_t buf[4] = v31;
    __int16 v38 = 2080;
    int v39 = "SetFullLayout";
    __int16 v40 = 1024;
    LODWORD(v41[0]) = mNumberChannelDescriptions;
    WORD2(v41[0]) = 2080;
    *(void *)((char *)v41 + 6) = v32;
    float v30 = "[%s|%s] Number of channels %u in requested audio channel layout %s is different than in the stream format.";
    uint64_t v33 = v12;
    goto LABEL_80;
  }
LABEL_82:
  uint64_t v11 = 4294956445;
LABEL_44:
  if (getAUSMV2Log(void)::onceToken != -1) {
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
  }
LABEL_46:
  unsigned int v24 = getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v25 = (void *)((char *)this + 200);
    if (*((char *)this + 223) < 0) {
      unint64_t v25 = (void *)*v25;
    }
    PrintAudioChannelLayout(&__p, *((int **)this + 15));
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      float v26 = &__p;
    }
    else {
      float v26 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)buf = 136315650;
    *(void *)&uint8_t buf[4] = v25;
    __int16 v38 = 2080;
    int v39 = "SetFullLayout";
    __int16 v40 = 2080;
    v41[0] = v26;
    _os_log_impl(&dword_1BB0CE000, v24, OS_LOG_TYPE_DEFAULT, "[%s|%s] Current output audio channel layout is %s", buf, 0x20u);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  return v11;
}

void sub_1BB3686AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
}

double ausdk::AUIOElement::ForceSetAudioChannelLayout(ausdk::AUIOElement *this, const AudioChannelLayout *a2)
{
  unint64_t v4 = 20 * a2->mNumberChannelDescriptions + 12;
  BOOL v5 = (v4 & 0x1C) == 0;
  unint64_t v6 = v4 >> 5;
  if (v5) {
    unint64_t v7 = v6;
  }
  else {
    unint64_t v7 = v6 + 1;
  }
  std::vector<AudioChannelLayout>::vector(__dst, v7);
  memcpy(__dst[0], a2, 20 * a2->mNumberChannelDescriptions + 12);
  long long v8 = (void *)*((void *)this + 15);
  if (v8)
  {
    *((void *)this + 16) = v8;
    operator delete(v8);
  }
  double result = *(double *)__dst;
  *(_OWORD *)((char *)this + 120) = *(_OWORD *)__dst;
  *((void *)this + 17) = v11;
  return result;
}

void *std::vector<AudioChannelLayout>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    if (a2 >> 59) {
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v4 = 32 * a2;
    BOOL v5 = (char *)operator new(32 * a2);
    *a1 = v5;
    a1[2] = &v5[32 * a2];
    bzero(v5, 32 * a2);
    a1[1] = &v5[v4];
  }
  return a1;
}

void sub_1BB3687D4(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t AUSpatialMixerV2OutputElement::PropertyObserverIsInitialized(AUSpatialMixerV2OutputElement *this)
{
  return *((unsigned __int8 *)this + 192);
}

uint64_t AUSpatialMixerV2OutputElement::PropertyChanged(AUSpatialMixerV2OutputElement *this, int a2)
{
  if (a2 != 3220) {
    return 0;
  }
  AudioChannelLayoutTag v2 = atomic_load((unsigned int *)this + 74);
  if (*((unsigned char *)this + 193) || v2 > 0xFFFEFFFF) {
    return 0;
  }
  else {
    return AUSpatialMixerV2OutputElement::SetFullLayoutFromTag(this, v2, 1);
  }
}

uint64_t AUSpatialMixerV2OutputElement::Cleanup(AUSpatialMixerV2OutputElement *this)
{
  *((unsigned char *)this + 192) = 0;
  return 0;
}

uint64_t AUSpatialMixerV2OutputElement::Reset(AUSpatialMixerV2OutputElement *this)
{
  return 0;
}

uint64_t AUSpatialMixerV2OutputElement::Initialize(AUSpatialMixerV2OutputElement *this, const AudioChannelLayout *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  int v3 = *((_DWORD *)this + 27);
  if (v3 == ausdk::AUChannelLayout::NumberChannels(*((ausdk::AUChannelLayout **)this + 15), a2))
  {
    uint64_t result = 0;
  }
  else
  {
    if (getAUSMV2Log(void)::onceToken != -1) {
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
    }
    BOOL v5 = getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR))
    {
      unint64_t v7 = (void *)((char *)this + 200);
      if (*((char *)this + 223) < 0) {
        unint64_t v7 = (void *)*v7;
      }
      int v8 = ausdk::AUChannelLayout::NumberChannels(*((ausdk::AUChannelLayout **)this + 15), v6);
      int v9 = *((_DWORD *)this + 27);
      int v10 = 136315906;
      uint64_t v11 = v7;
      __int16 v12 = 2080;
      uint64_t v13 = "Initialize";
      __int16 v14 = 1024;
      int v15 = v8;
      __int16 v16 = 1024;
      int v17 = v9;
      _os_log_error_impl(&dword_1BB0CE000, v5, OS_LOG_TYPE_ERROR, "[%s|%s] Number of channels in AudioChannelLayout = %u does not match number of channels in stream format = %u. Reverting to default layout.", (uint8_t *)&v10, 0x22u);
    }
    AUSpatialMixerV2OutputElement::ResetOutputChannelLayout(this);
    uint64_t result = 4294956428;
  }
  *((unsigned char *)this + 192) = 1;
  return result;
}

uint64_t ausdk::AUChannelLayout::NumberChannels(ausdk::AUChannelLayout *this, const AudioChannelLayout *a2)
{
  if (*(_DWORD *)this == 0x10000)
  {
    uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)*((unsigned int *)this + 1));
    v3.i16[0] = vaddlv_u8(v3);
    return v3.u32[0];
  }
  else if (*(_DWORD *)this)
  {
    return (unsigned __int16)*(_DWORD *)this;
  }
  else
  {
    return *((unsigned int *)this + 2);
  }
}

void AUSpatialMixerV2OutputElement::ResetOutputChannelLayout(AUSpatialMixerV2OutputElement *this)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  int v2 = *((_DWORD *)this + 27);
  int v3 = v2 - 1;
  if (v2 - 1) < 0x10 && ((0x89FFu >> v3)) {
    int v4 = dword_1BB886F4C[v3];
  }
  else {
    int v4 = v2 | 0x930000;
  }
  AUSpatialMixerV2OutputElement::SetFullLayoutFromTag(this, v4, 0);
  *((unsigned char *)this + 193) = 0;
  if (getAUSMV2Log(void)::onceToken != -1) {
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
  }
  BOOL v5 = getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v6 = (void *)((char *)this + 200);
    if (*((char *)this + 223) < 0) {
      unint64_t v6 = (void *)*v6;
    }
    GetStringFromAudioChannelLayoutTag(__p, v4);
    if (v9 >= 0) {
      unint64_t v7 = __p;
    }
    else {
      unint64_t v7 = (void **)__p[0];
    }
    *(_DWORD *)buf = 136315906;
    uint64_t v11 = v6;
    __int16 v12 = 2080;
    uint64_t v13 = "ResetOutputChannelLayout";
    __int16 v14 = 2080;
    int v15 = v7;
    __int16 v16 = 1024;
    int v17 = v2;
    _os_log_impl(&dword_1BB0CE000, v5, OS_LOG_TYPE_DEFAULT, "[%s|%s] Setting default audio channel layout tag = %s for %u channels", buf, 0x26u);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
  }
}

uint64_t ausdk::AUOutputElement::NeedsBufferSpace(ausdk::AUOutputElement *this)
{
  return 1;
}

uint64_t AUSpatialMixerV2OutputElement::SetStreamFormat(AUSpatialMixerV2OutputElement *this, const AudioChannelLayout *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  int16x8_t v4 = *(int16x8_t *)&a2->mChannelDescriptions[0].mChannelFlags;
  *(_OWORD *)buf = *(_OWORD *)&a2->mChannelLayoutTag;
  *(int16x8_t *)&buf[16] = v4;
  uint64_t v17 = *(void *)&a2[1].mChannelLayoutTag;
  CA::StreamDescription::AsString((CA::StreamDescription *)buf, (uint64_t)__p, v4);
  if (getAUSMV2Log(void)::onceToken != -1) {
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
  }
  BOOL v5 = getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v6 = (void *)((char *)this + 200);
    if (*((char *)this + 223) < 0) {
      unint64_t v6 = (void *)*v6;
    }
    unint64_t v7 = __p;
    if (v15 < 0) {
      unint64_t v7 = (void **)__p[0];
    }
    *(_DWORD *)buf = 136315650;
    *(void *)&uint8_t buf[4] = v6;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "SetStreamFormat";
    *(_WORD *)&buf[22] = 2080;
    *(void *)&unsigned char buf[24] = v7;
    _os_log_impl(&dword_1BB0CE000, v5, OS_LOG_TYPE_DEFAULT, "[%s|%s] Setting output stream format: %s", buf, 0x20u);
  }
  if (*(double *)&a2->mChannelLayoutTag <= 0.0)
  {
    uint64_t v12 = 4294967246;
  }
  else
  {
    ausdk::AUIOElement::SetStreamFormat(this, a2);
    (*(void (**)(AUSpatialMixerV2OutputElement *, void))(*(void *)this + 64))(this, 0);
    int v8 = *((_DWORD *)this + 27);
    if (v8 != ausdk::AUChannelLayout::NumberChannels(*((ausdk::AUChannelLayout **)this + 15), v9))
    {
      if (getAUSMV2Log(void)::onceToken != -1) {
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
      }
      int v10 = getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = (void *)((char *)this + 200);
        if (*((char *)this + 223) < 0) {
          uint64_t v11 = (void *)*v11;
        }
        *(_DWORD *)buf = 136315394;
        *(void *)&uint8_t buf[4] = v11;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = "SetStreamFormat";
        _os_log_impl(&dword_1BB0CE000, v10, OS_LOG_TYPE_DEFAULT, "[%s|%s] Number of channels in stream format changed", buf, 0x16u);
      }
      AUSpatialMixerV2OutputElement::ResetOutputChannelLayout(this);
      AUSpatialMixerV2::InitializeOutputConverter(*((AudioConverterRef **)this + 23));
    }
    uint64_t v12 = 0;
  }
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  return v12;
}

void sub_1BB368DA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ausdk::AUElement::GetNumberOfParameters(ausdk::AUElement *this)
{
  uint64_t v1 = 56;
  if (!*((unsigned char *)this + 40)) {
    uint64_t v1 = 24;
  }
  uint64_t v2 = 48;
  if (!*((unsigned char *)this + 40)) {
    uint64_t v2 = 16;
  }
  char v3 = 2;
  uint64_t v4 = *(void *)((char *)this + v1);
  if (!*((unsigned char *)this + 40)) {
    char v3 = 3;
  }
  return (v4 - *(void *)((char *)this + v2)) >> v3;
}

void AUSpatialMixerV2OutputElement::~AUSpatialMixerV2OutputElement(AUSpatialMixerV2OutputElement *this)
{
  AUSpatialMixerV2OutputElement::~AUSpatialMixerV2OutputElement(this);

  JUMPOUT(0x1C185D370);
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1F14AB9F8;
  *((void *)this + 22) = &unk_1F14ABAA0;
  *((void *)this + 28) = &unk_1F14BE008;
  std::__tree<std::__value_type<unsigned int,std::unique_ptr<AUSM::PropertyDescriptor>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::unique_ptr<AUSM::PropertyDescriptor>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::unique_ptr<AUSM::PropertyDescriptor>>>>::destroy(*((void **)this + 34));
  if (*((char *)this + 255) < 0) {
    operator delete(*((void **)this + 29));
  }
  if (*((char *)this + 223) < 0) {
    operator delete(*((void **)this + 25));
  }
  *(void *)this = &unk_1F14C81D8;
  if (*((void *)this + 19))
  {
    (*((void (**)(void))ausdk::BufferAllocator::instance(void)::global + 3))();
    *((void *)this + 19) = 0;
  }
  *((void *)this + 20) = 0;
  *((_DWORD *)this + 36) = 0;
  uint64_t v2 = (void *)*((void *)this + 15);
  if (v2)
  {
    *((void *)this + 16) = v2;
    operator delete(v2);
  }

  ausdk::AUElement::~AUElement((const void **)this);
}

void std::__tree<std::__value_type<unsigned int,std::unique_ptr<AUSM::PropertyDescriptor>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::unique_ptr<AUSM::PropertyDescriptor>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::unique_ptr<AUSM::PropertyDescriptor>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned int,std::unique_ptr<AUSM::PropertyDescriptor>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::unique_ptr<AUSM::PropertyDescriptor>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::unique_ptr<AUSM::PropertyDescriptor>>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned int,std::unique_ptr<AUSM::PropertyDescriptor>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::unique_ptr<AUSM::PropertyDescriptor>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::unique_ptr<AUSM::PropertyDescriptor>>>>::destroy(a1[1]);
    uint64_t v2 = a1[5];
    a1[5] = 0;
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    operator delete(a1);
  }
}

void ausdk::AUElement::~AUElement(const void **this)
{
  *this = &unk_1F14C87E0;
  ausdk::Owned<__CFString const*>::releaseRef(this[9]);
  uint64_t v2 = (void *)this[6];
  if (v2)
  {
    this[7] = v2;
    operator delete(v2);
  }
  char v3 = (void *)this[2];
  if (v3)
  {
    this[3] = v3;
    operator delete(v3);
  }
}

{
  uint64_t vars8;

  ausdk::AUElement::~AUElement(this);

  JUMPOUT(0x1C185D370);
}

ausdk::AUChannelLayout *ausdk::AUChannelLayout::AUChannelLayout(ausdk::AUChannelLayout *this, const ausdk::AUChannelLayout *a2)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  ausdk::AUChannelLayout::CopyStorage(this, a2);
  return this;
}

void sub_1BB369078(_Unwind_Exception *exception_object)
{
  char v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *ausdk::AUChannelLayout::CopyStorage(ausdk::AUChannelLayout *this, const ausdk::AUChannelLayout *a2)
{
  std::vector<AudioChannelLayout>::vector(&v7, (uint64_t)(*((void *)a2 + 1) - *(void *)a2) >> 5);
  uint64_t v4 = *(void **)this;
  if (*(void *)this)
  {
    *((void *)this + 1) = v4;
    operator delete(v4);
  }
  BOOL v5 = (void *)v7;
  *(_OWORD *)this = v7;
  *((void *)this + 2) = v8;
  return memcpy(v5, *(const void **)a2, *((void *)a2 + 1) - *(void *)a2);
}

void WindDetectorAndSuppressor::UpdateWindSuppressorCoreState(WindDetectorAndSuppressor *this)
{
  uint64_t v2 = (float32x2_t *)*((void *)this + 62);
  unint64_t v3 = *((void *)this + 63) - (void)v2;
  if (!v3) {
    goto LABEL_31;
  }
  float v4 = *((float *)this + 34);
  v2->f32[0] = v4;
  if (v3 <= 4) {
    goto LABEL_31;
  }
  v2->i32[1] = *((_DWORD *)this + 62);
  if (v3 <= 8) {
    goto LABEL_31;
  }
  v2[1].i32[0] = *((_DWORD *)this + 41);
  if (v3 <= 0xC) {
    goto LABEL_31;
  }
  v2[1].i32[1] = *((_DWORD *)this + 39);
  if (v3 <= 0x10) {
    goto LABEL_31;
  }
  v2[2].i32[0] = *((_DWORD *)this + 38);
  if (v3 <= 0x14) {
    goto LABEL_31;
  }
  v2[2].i32[1] = *((_DWORD *)this + 43);
  if (v3 <= 0x18
    || (v2[3].i32[0] = *((_DWORD *)this + 63), v3 <= 0x1C)
    || (v2[3].i32[1] = *((_DWORD *)this + 65), v3 <= 0x20)
    || (v2[4].i32[0] = *((_DWORD *)this + 64), v3 <= 0x24)
    || (v2[4].i32[1] = *((_DWORD *)this + 66), v3 <= 0x28)
    || (v2[5].i32[0] = *((_DWORD *)this + 33), v3 <= 0x2C)
    || (v2[5].i32[1] = *((_DWORD *)this + 67), v3 <= 0x30)
    || (v2[6].i32[0] = *((_DWORD *)this + 68), v3 <= 0x34))
  {
LABEL_31:
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  }
  v2[6].i32[1] = *((_DWORD *)this + 69);
  if (*((unsigned char *)this + 8))
  {
    if (!*((unsigned char *)this + 832)) {
      __assert_rtn("propagateParameterChanges", "WindSuppressorCore.cpp", 129, "mInitialized");
    }
    uint64_t v5 = *((void *)this + 80);
    unint64_t v6 = *((unsigned int *)this + 131);
    if (v6 > (*((void *)this + 81) - v5) >> 2) {
      __assert_rtn("propagateParameterChanges", "WindSuppressorCore.cpp", 130, "mRampedGainFloor.size() >= mCplxVectorSize");
    }
    long long v7 = (float32x2_t *)*((void *)this + 101);
    unint64_t v8 = 0x8E38E38E38E38E39 * ((uint64_t)(*((void *)this + 102) - (void)v7) >> 3);
    uint64_t v9 = *((unsigned int *)this + 133);
    if (v8 != v9) {
      __assert_rtn("propagateParameterChanges", "WindSuppressorCore.cpp", 131, "mWindTracker.size() == mNumInputChannels");
    }
    *((float *)this + 140) = __exp10f(v4 / 20.0);
    float v10 = *((double *)this + 69);
    float v18 = v10 / (float)*((unsigned int *)this + 132);
    *((float *)this + 143) = expf(-1.0 / (float)(v2[3].f32[0] * v18));
    *((float *)this + 144) = expf(-1.0 / (float)(v18 * v2[3].f32[1]));
    *((float *)this + 145) = expf(-1.0 / (float)(v18 * v2[4].f32[1]));
    *((float *)this + 146) = expf(-1.0 / (float)(v18 * v2[6].f32[1]));
    if (v9)
    {
      float v11 = v2[5].f32[0];
      unint64_t v12 = (unint64_t)(float)(v18 * v2[4].f32[0]);
      uint64x2_t v13 = vcvtq_u64_f64(vcvtq_f64_f32(vmul_n_f32(v2[3], v18)));
      float32x2_t v14 = vdiv_f32((float32x2_t)0xBF8000003F800000, vadd_f32(vcvt_f32_f64(vcvtq_f64_u64(v13)), (float32x2_t)vdup_n_s32(0x25800000u)));
      char v15 = v7 + 3;
      do
      {
        v15[-3].f32[0] = v11;
        v15[-3].f32[1] = v11 * 0.5;
        v15[1] = *(float32x2_t *)v13.i8;
        v15[2] = (float32x2_t)v12;
        unsigned char v15[3] = (float32x2_t)v13.u64[1];
        v15[-2] = (float32x2_t)0x3F80000000000000;
        *char v15 = v14;
        v15 += 9;
        --v8;
      }
      while (v8);
    }
    if (v6)
    {
      for (uint64_t i = 0; i != v6; ++i)
      {
        float v17 = (float)(2.0 / (float)(expf(-(float)(v2->f32[1] * (float)(int)i)) + 1.0)) + -1.0;
        *(float *)(v5 + 4 * i) = v17;
        if (*((float *)this + 140) >= v17) {
          float v17 = *((float *)this + 140);
        }
        *(float *)(v5 + 4 * i) = v17;
      }
    }
  }
}

void WindDetectorAndSuppressor::~WindDetectorAndSuppressor(WindDetectorAndSuppressor *this)
{
  WindSuppressorCore::~WindSuppressorCore((WindDetectorAndSuppressor *)((char *)this + 496));
  uint64_t v2 = (void *)*((void *)this + 59);
  if (v2)
  {
    *((void *)this + 60) = v2;
    operator delete(v2);
  }
  unint64_t v3 = (void *)*((void *)this + 56);
  if (v3)
  {
    *((void *)this + 57) = v3;
    operator delete(v3);
  }
  float v4 = (void *)*((void *)this + 53);
  if (v4)
  {
    *((void *)this + 54) = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)*((void *)this + 50);
  if (v5)
  {
    *((void *)this + 51) = v5;
    operator delete(v5);
  }
  unint64_t v6 = (void *)*((void *)this + 47);
  if (v6)
  {
    *((void *)this + 48) = v6;
    operator delete(v6);
  }
  long long v7 = (void *)*((void *)this + 44);
  if (v7)
  {
    *((void *)this + 45) = v7;
    operator delete(v7);
  }
  unint64_t v8 = (void *)*((void *)this + 41);
  if (v8)
  {
    *((void *)this + 42) = v8;
    operator delete(v8);
  }
  uint64_t v9 = (void *)*((void *)this + 38);
  if (v9)
  {
    *((void *)this + 39) = v9;
    operator delete(v9);
  }
  float v10 = (void *)*((void *)this + 35);
  if (v10)
  {
    *((void *)this + 36) = v10;
    operator delete(v10);
  }
}

float WindDetectorAndSuppressor::UpdateNonTrivialParameters(WindDetectorAndSuppressor *this, double a2, double a3, double a4)
{
  double v5 = *((double *)this + 2);
  unsigned int v6 = *((_DWORD *)this + 6);
  double v7 = v5 / (float)((float)v6 + (float)v6);
  *(float *)&a4 = (float)(v6 - 1);
  v8.i64[0] = *(void *)((char *)this + 140);
  v8.i64[1] = *((void *)this + 20);
  *(float *)&double v7 = v7;
  float32x4_t v9 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v7, 0);
  float32x4_t v10 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a4, 0);
  *(uint32x4_t *)((char *)this + 28) = vcvtq_u32_f32(vminnmq_f32(vmaxnmq_f32(vrndaq_f32(vdivq_f32(v8, v9)), (float32x4_t)0), v10));
  v8.f32[0] = fminf(fmaxf(roundf(*((float *)this + 42) / *(float *)&v7), 0.0), *(float *)&a4);
  *((_DWORD *)this + 11) = v8.f32[0];
  *((_DWORD *)this + 12) = v8.f32[0] + 1;
  *(uint32x2_t *)((char *)this + 52) = vcvt_u32_f32(vminnm_f32(vmaxnm_f32(vrnda_f32(vdiv_f32(*(float32x2_t *)((char *)this + 204), *(float32x2_t *)v9.f32)), 0), *(float32x2_t *)v10.f32));
  *((_DWORD *)this + 15) = fminf(fmaxf(roundf(*((float *)this + 53) / *(float *)&v7), 0.0), *(float *)&a4);
  float v11 = v5 / (double)v6;
  float v12 = exp(-1.0 / (float)(*((float *)this + 37) * v11));
  *((float *)this + 16) = v12;
  float v13 = exp(-1.0 / (float)(*((float *)this + 54) * v11));
  float v14 = floorf(*((float *)this + 44) * v11);
  *((float *)this + 17) = v13;
  *((float *)this + 18) = v14;
  *((float *)this + 20) = floorf(*((float *)this + 58) * v11);
  float result = __exp10(*((float *)this + 34) / 20.0);
  *((float *)this + 22) = result;
  return result;
}

void WindDetectorAndSuppressor::Reset(WindDetectorAndSuppressor *this)
{
  unint64_t v2 = *((unsigned int *)this + 6);
  int v19 = 0;
  std::vector<float>::assign((char **)this + 35, v2, &v19);
  unint64_t v3 = *((unsigned int *)this + 6);
  int v18 = 0;
  std::vector<float>::assign((char **)this + 38, v3, &v18);
  unint64_t v4 = (2 * *((_DWORD *)this + 6));
  int v17 = 0;
  std::vector<float>::assign((char **)this + 41, v4, &v17);
  *(void *)((char *)this + 100) = 0;
  *(void *)((char *)this + 92) = 0;
  *(void *)((char *)this + 108) = 0;
  *((_DWORD *)this + 19) = *((float *)this + 18);
  *((_DWORD *)this + 21) = *((float *)this + 20);
  *((unsigned char *)this + 116) = 0;
  WindDetectorAndSuppressor::ResetOutputPropertiesAndParams(this);
  if (*((unsigned char *)this + 8))
  {
    if (!*((unsigned char *)this + 832)) {
      __assert_rtn("reset", "WindSuppressorCore.cpp", 88, "mInitialized");
    }
    double v5 = (void *)*((void *)this + 98);
    uint64_t v6 = *((unsigned int *)this + 133);
    if (v6 + 1 != (uint64_t)(*((void *)this + 99) - (void)v5) >> 2) {
      __assert_rtn("reset", "WindSuppressorCore.cpp", 89, "mAggregateOmniMicWeight.size() == mNumInputChannels + 1");
    }
    unint64_t v7 = 0x8E38E38E38E38E39 * ((uint64_t)(*((void *)this + 102) - *((void *)this + 101)) >> 3);
    if (v7 != v6) {
      __assert_rtn("reset", "WindSuppressorCore.cpp", 90, "mWindTracker.size() == mNumInputChannels");
    }
    if (v7 != (uint64_t)(*((void *)this + 93) - *((void *)this + 92)) >> 2) {
      __assert_rtn("reset", "WindSuppressorCore.cpp", 91, "mGainApplicationCutoffIndex.size() == mNumInputChannels");
    }
    float32x4_t v8 = (void *)*((void *)this + 95);
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)this + 96) - (void)v8) >> 3) != v7) {
      __assert_rtn("reset", "WindSuppressorCore.cpp", 92, "mSmoothSuppressionGains.size() == mNumInputChannels");
    }
    if (*((_DWORD *)this + 131) != (uint64_t)(v8[1] - *v8) >> 2) {
      __assert_rtn("reset", "WindSuppressorCore.cpp", 93, "mSmoothSuppressionGains[0].size() == mCplxVectorSize");
    }
    if (!v6)
    {
      size_t v16 = 4;
      goto LABEL_14;
    }
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    unint64_t v11 = 0;
    do
    {
      *(_DWORD *)(*((void *)this + 92) + 4 * v11) = 0;
      uint64_t v12 = *((void *)this + 101) + v9;
      *(_DWORD *)(v12 + 16) = 0;
      *(void *)(v12 + 56) = 1;
      *(_DWORD *)(v12 + 64) = 0;
      std::vector<float>::assign((char **)(*((void *)this + 95) + v10), *((unsigned int *)this + 131), &WindSuppressorCore::kDefaultGains);
      ++v11;
      unint64_t v13 = *((unsigned int *)this + 133);
      v10 += 24;
      v9 += 72;
    }
    while (v11 < v13);
    BOOL v14 = __CFADD__(v13, 1);
    unsigned int v15 = v13 + 1;
    if (!v14)
    {
      double v5 = (void *)*((void *)this + 98);
      size_t v16 = 4 * v15;
LABEL_14:
      memset_pattern16(v5, &unk_1BB87C230, v16);
    }
  }
}

double WindDetectorAndSuppressor::ResetOutputPropertiesAndParams(WindDetectorAndSuppressor *this)
{
  unint64_t v2 = *((unsigned int *)this + 6);
  int v4 = 1065353216;
  std::vector<float>::assign((char **)this + 44, v2, &v4);
  std::vector<float>::assign((char **)this + 47, *((unsigned int *)this + 6), this);
  *((unsigned char *)this + 120) = 0;
  *(void *)((char *)this + 124) = 0x4320000000000000;
  *((void *)this + 23) = 0;
  *((void *)this + 24) = 0;
  *((_DWORD *)this + 50) = 0;
  double result = 0.0000305175853;
  *(void *)((char *)this + 236) = 0x3F0000003F000000;
  return result;
}

void WindDetectorAndSuppressor::GetPSD(uint64_t a1, float *a2, const float **a3)
{
  double v5 = &a2[*(unsigned int *)(a1 + 24)];
  __A.realp = a2;
  __A.imagp = v5;
  vDSP_zvmags(&__A, 1, *(float **)(a1 + 424), 1, *(unsigned int *)(a1 + 48));
  uint64_t v6 = *(float **)(a1 + 424);
  float *v6 = *__A.realp * *__A.realp;
  float __B = *(float *)(a1 + 64);
  float __D = 1.0 - __B;
  vDSP_vsmsma(*a3, 1, &__B, v6, 1, &__D, (float *)*a3, 1, *(unsigned int *)(a1 + 48));
}

void WindDetectorAndSuppressor::ProcessBufferLists(WindDetectorAndSuppressor *this, const AudioBufferList *a2, AudioBufferList *a3, AudioBufferList *a4, AudioBufferList *a5, double a6, double a7, double a8)
{
  if (!*((unsigned char *)this + 8)) {
    return;
  }
  WindDetectorAndSuppressor::UpdateNonTrivialParameters(this, a6, a7, a8);
  unint64_t v11 = (void *)((char *)this + 280);
  WindDetectorAndSuppressor::GetPSD((uint64_t)this, (float *)a2->mBuffers[0].mData, (const float **)this + 35);
  uint64_t v12 = (void *)((char *)this + 304);
  WindDetectorAndSuppressor::GetPSD((uint64_t)this, *(float **)&a2[1].mBuffers[0].mNumberChannels, (const float **)this + 38);
  uint64_t v13 = *((unsigned int *)this + 6);
  __B.realp = (float *)a2->mBuffers[0].mData;
  __B.imagp = &__B.realp[v13];
  BOOL v14 = (float *)(*(void *)&a2[1].mBuffers[0].mNumberChannels + 4 * v13);
  __A.realp = *(float **)&a2[1].mBuffers[0].mNumberChannels;
  __A.imagp = v14;
  __C.realp = (float *)*((void *)this + 59);
  __C.imagp = &__C.realp[v13];
  vDSP_zvcmul(&__A, 1, &__B, 1, &__C, 1, *((unsigned int *)this + 12));
  *__C.realp = *__B.realp * *__A.realp;
  *__C.imagp = *__B.imagp * *__A.imagp;
  v202[0] = *((float *)this + 16);
  float __D = 1.0 - v202[0];
  vDSP_vsmsma(*((const float **)this + 41), 1, v202, *((const float **)this + 59), 1, &__D, *((float **)this + 41), 1, *((unsigned int *)this + 12));
  vDSP_vsmsma((const float *)(*((void *)this + 41) + 4 * *((unsigned int *)this + 6)), 1, v202, (const float *)(*((void *)this + 59) + 4 * *((unsigned int *)this + 6)), 1, &__D, (float *)(*((void *)this + 41) + 4 * *((unsigned int *)this + 6)), 1, *((unsigned int *)this + 12));
  unsigned int v15 = (float *)(*((void *)this + 41) + 4 * *((unsigned int *)this + 6));
  __B.realp = (float *)*((void *)this + 41);
  __B.imagp = v15;
  size_t v16 = (void *)((char *)this + 424);
  vDSP_zvmags(&__B, 1, *((float **)this + 53), 1, *((unsigned int *)this + 12));
  **((float **)this + 53) = *__B.realp * *__B.realp;
  vDSP_vmsa(*((const float **)this + 35), 1, *((const float **)this + 38), 1, (const float *)this + 1, *((float **)this + 56), 1, *((unsigned int *)this + 12));
  vDSP_vdiv(*((const float **)this + 56), 1, *((const float **)this + 53), 1, *((float **)this + 44), 1, *((unsigned int *)this + 12));
  LODWORD(__B.realp) = 0;
  vDSP_meanv((const float *)(*((void *)this + 44) + 4 * *((unsigned int *)this + 7)), 1, (float *)&__B, (*((_DWORD *)this + 8) - *((_DWORD *)this + 7) + 1));
  float v17 = (float)(*((float *)this + 16) * *((float *)this + 23))
      + (1.0 - *((float *)this + 16)) * (float)(1.0 - *(float *)&__B.realp);
  *((float *)this + 23) = v17;
  unint64_t v18 = *((unsigned int *)this + 6);
  LODWORD(__B.realp) = 0;
  std::vector<float>::assign((char **)this + 53, v18, &__B);
  unsigned int v19 = *((_DWORD *)this + 13);
  unsigned int v20 = *((_DWORD *)this + 15);
  if (v19 <= v20)
  {
    float v21 = 1.0 - *((float *)this + 33);
    uint64_t v22 = *((void *)this + 44);
    uint64_t v23 = *((void *)this + 53);
    unsigned int v24 = *((_DWORD *)this + 13);
    do
    {
      if (*(float *)(v22 + 4 * v24) >= v21) {
        float v25 = 0.0;
      }
      else {
        float v25 = 1.0;
      }
      *(float *)(v23 + 4 * v24++) = v25;
    }
    while (v24 <= v20);
  }
  unsigned int v26 = *((_DWORD *)this + 14);
  float v27 = *((float *)this + 17);
  float v28 = *((float *)this + 24);
  float v29 = *((float *)this + 1);
  float v30 = 0.0;
  float v31 = 0.0;
  if (v19 <= v26)
  {
    unsigned int v32 = (float *)(*v16 + 4 * (int)v19);
    uint64_t v33 = (float *)(*v11 + 4 * (int)v19);
    unsigned int v34 = v19;
    do
    {
      float v35 = *v33++;
      float v36 = v35;
      float v37 = *v32++;
      float v31 = v31 + (float)(v36 * v37);
      ++v34;
    }
    while (v26 >= v34);
  }
  float v38 = log10f(v29 + v31);
  double v39 = (float)(v27 * v28);
  double v40 = 1.0 - v27;
  float v41 = v39 + v40 * (float)(v38 * 10.0);
  *((float *)this + 24) = v41;
  if (v19 <= v26)
  {
    unsigned __int8 v43 = (float *)(*v16 + 4 * (int)v19);
    uint64_t v44 = (float *)(*v12 + 4 * (int)v19);
    float v30 = 0.0;
    do
    {
      float v45 = *v44++;
      float v46 = v45;
      float v47 = *v43++;
      float v30 = v30 + (float)(v46 * v47);
      ++v19;
    }
    while (v26 >= v19);
  }
  float v42 = *((float *)this + 25);
  float v48 = (float)(v27 * v42) + v40 * (float)(log10f(v29 + v30) * 10.0);
  *((float *)this + 25) = v48;
  *((float *)this + 47) = v41 - v48;
  float v50 = 0.0;
  float v51 = 0.0;
  if (v26 <= v20)
  {
    BOOL v52 = (float *)(*v16 + 4 * (int)v26);
    char v53 = (float *)(*v11 + 4 * (int)v26);
    unsigned int v54 = v26;
    do
    {
      float v55 = *v53++;
      float v56 = v55;
      float v57 = *v52++;
      float v51 = v51 + (float)(v56 * v57);
      ++v54;
    }
    while (v20 >= v54);
  }
  float v49 = *((float *)this + 26);
  float v58 = (float)(v27 * v49) + v40 * (float)(log10f(v29 + v51) * 10.0);
  *((float *)this + 26) = v58;
  if (v26 <= v20)
  {
    unint64_t v60 = (float *)(*v16 + 4 * (int)v26);
    int v61 = (float *)(*v12 + 4 * (int)v26);
    float v50 = 0.0;
    do
    {
      float v62 = *v61++;
      float v63 = v62;
      float v64 = *v60++;
      float v50 = v50 + (float)(v63 * v64);
      ++v26;
    }
    while (v20 >= v26);
  }
  float v59 = *((float *)this + 27);
  float v65 = (float)(v27 * v59) + v40 * (float)(log10f(v29 + v50) * 10.0);
  *((float *)this + 27) = v65;
  *((float *)this + 48) = v58 - v65;
  unint64_t v66 = *((unsigned int *)this + 6);
  LODWORD(__B.realp) = 1065353216;
  std::vector<float>::assign((char **)this + 53, v66, &__B);
  unsigned int v67 = *((_DWORD *)this + 14);
  unsigned int v68 = *((_DWORD *)this + 15);
  float v69 = *((float *)this + 17);
  float v71 = *((float *)this + 1);
  float v72 = 0.0;
  float v73 = 0.0;
  if (v67 <= v68)
  {
    uint64_t v74 = (float *)(*v16 + 4 * (int)v67);
    unsigned __int8 v75 = (float *)(*v11 + 4 * (int)v67);
    unsigned int v76 = *((_DWORD *)this + 14);
    do
    {
      float v77 = *v75++;
      float v78 = v77;
      float v79 = *v74++;
      float v73 = v73 + (float)(v78 * v79);
      ++v76;
    }
    while (v68 >= v76);
  }
  double v80 = 1.0 - v69;
  float v70 = *((float *)this + 49);
  float v81 = (float)(v69 * v70) + v80 * (float)(log10f(v71 + v73) * 10.0);
  *((float *)this + 49) = v81;
  if (v67 <= v68)
  {
    unsigned int v83 = (float *)(*v16 + 4 * (int)v67);
    float v84 = (float *)(*v12 + 4 * (int)v67);
    float v72 = 0.0;
    do
    {
      float v85 = *v84++;
      float v86 = v85;
      float v87 = *v83++;
      float v72 = v72 + (float)(v86 * v87);
      ++v67;
    }
    while (v68 >= v67);
  }
  float v82 = *((float *)this + 50);
  float v88 = (float)(v69 * v82) + v80 * (float)(log10f(v71 + v72) * 10.0);
  *((float *)this + 50) = v88;
  int v89 = *((_DWORD *)this + 45);
  if (!v89)
  {
    *((_DWORD *)this + 46) = 0;
    float v93 = *((float *)this + 23);
    *((float *)this + 31) = v93;
    goto LABEL_44;
  }
  if (v89 == 1)
  {
    if (*((float *)this + 23) <= *((float *)this + 33) || (float v90 = *((float *)this + 56), v90 >= v81) && v90 >= v88)
    {
      unsigned int v91 = 0;
      goto LABEL_32;
    }
    unsigned int v91 = *((_DWORD *)this + 46);
    if (v91 > 4 || ((1 << v91) & 0x19) == 0) {
      goto LABEL_32;
    }
    float v189 = *((float *)this + 47);
    float v190 = *((float *)this + 55);
    if (fabsf(v189) >= v190 || fabsf(*((float *)this + 48)) >= v190)
    {
      float v194 = *((float *)this + 57);
      if (v194 > v81)
      {
        unsigned int v91 = 1;
        goto LABEL_32;
      }
      BOOL v191 = v194 <= v88;
      unsigned int v91 = 5;
      int v192 = 2;
    }
    else
    {
      BOOL v191 = v189 <= 0.0;
      unsigned int v91 = 4;
      int v192 = 3;
    }
    if (!v191) {
      unsigned int v91 = v192;
    }
LABEL_32:
    if (*((_DWORD *)this + 28) == v91) {
      int v92 = *((_DWORD *)this + 21) - 1;
    }
    else {
      int v92 = *((float *)this + 20);
    }
    *((_DWORD *)this + 21) = v92;
    if (!v92)
    {
      *((_DWORD *)this + 46) = v91;
      *((_DWORD *)this + 21) = *((float *)this + 20);
    }
    float v93 = *((float *)this + 23);
    *((float *)this + 31) = v93;
    uint64_t v94 = (_DWORD *)((char *)this + 124);
    *((_DWORD *)this + 28) = v91;
    if ((*((_DWORD *)this + 46) - 3) >= 2) {
      goto LABEL_43;
    }
    goto LABEL_44;
  }
  float v93 = *((float *)this + 23);
  *((float *)this + 31) = v93;
  uint64_t v94 = (_DWORD *)((char *)this + 124);
  if (v89 != 3)
  {
    if (v89 != 2 || (*((_DWORD *)this + 46) & 0xFFFFFFFE) == 2) {
      goto LABEL_44;
    }
    goto LABEL_43;
  }
  if (*((_DWORD *)this + 46))
  {
LABEL_43:
    *uint64_t v94 = 0;
    float v93 = 0.0;
  }
LABEL_44:
  float v95 = *((float *)this + 33);
  int v96 = v93 > v95;
  if (*((unsigned __int8 *)this + 116) == v96) {
    int v97 = *((_DWORD *)this + 19) - 1;
  }
  else {
    int v97 = *((float *)this + 18);
  }
  *((_DWORD *)this + 19) = v97;
  if (!v97)
  {
    *((unsigned char *)this + 120) = v96;
    *((_DWORD *)this + 19) = *((float *)this + 18);
  }
  *((unsigned char *)this + 116) = v96;
  if (*((unsigned char *)this + 244))
  {
    if (!*((unsigned char *)this + 8)) {
      __assert_rtn("GetGains", "WindDetectorAndSuppressor.cpp", 311, "mInitialized");
    }
    *((unsigned char *)this + 588) = *((unsigned char *)this + 120);
    *((float *)this + 141) = v93;
    if (!*((unsigned char *)this + 832)) {
      __assert_rtn("process", "WindSuppressorCore.cpp", 211, "mInitialized");
    }
    uint64_t v98 = (*((void *)this + 48) - *((void *)this + 47)) >> 2;
    unsigned int v99 = *((_DWORD *)this + 131);
    if (v99 >= v98) {
      vDSP_Length v100 = v98;
    }
    else {
      vDSP_Length v100 = v99;
    }
    *((_DWORD *)this + 134) = v100;
    float v101 = (const float *)*((void *)this + 35);
    if (v100 > (uint64_t)(*((void *)this + 36) - (void)v101) >> 2) {
      __assert_rtn("process", "WindSuppressorCore.cpp", 215, "psd1.size() >= mNumBinsToProcess");
    }
    int v102 = (const float *)*((void *)this + 38);
    if (v100 > (uint64_t)(*((void *)this + 39) - (void)v102) >> 2) {
      __assert_rtn("process", "WindSuppressorCore.cpp", 216, "psd2.size() >= mNumBinsToProcess");
    }
    if (v100 > (uint64_t)(*((void *)this + 45) - *((void *)this + 44)) >> 2) {
      __assert_rtn("process", "WindSuppressorCore.cpp", 217, "coherence.size() >= mNumBinsToProcess");
    }
    vDSP_vmax(v101, 1, v102, 1, *((float **)this + 86), 1, v100);
    if (!*((unsigned char *)this + 832)) {
      __assert_rtn("computeWindSuppressionGain", "WindSuppressorCore.cpp", 250, "mInitialized");
    }
    vDSP_Length v103 = *((unsigned int *)this + 134);
    if (v103 > (uint64_t)(*((void *)this + 87) - *((void *)this + 86)) >> 2) {
      __assert_rtn("computeWindSuppressionGain", "WindSuppressorCore.cpp", 251, "psd.size() >= mNumBinsToProcess");
    }
    unint64_t v104 = (const float *)*((void *)this + 44);
    if (v103 > (uint64_t)(*((void *)this + 45) - (void)v104) >> 2) {
      __assert_rtn("computeWindSuppressionGain", "WindSuppressorCore.cpp", 252, "coherence.size() >= mNumBinsToProcess");
    }
    unint64_t v105 = (float *)*((void *)this + 47);
    if (v103 > (uint64_t)(*((void *)this + 48) - (void)v105) >> 2) {
      __assert_rtn("computeWindSuppressionGain", "WindSuppressorCore.cpp", 253, "gain.size() >= mNumBinsToProcess");
    }
    uint64_t v106 = *((void *)this + 62);
    float v107 = *(float *)(v106 + 12);
    float __D = -*(float *)(v106 + 16);
    v202[0] = v107;
    vDSP_vsadd(v104, 1, &__D, v105, 1, v103);
    vDSP_vsmul(*((const float **)this + 47), 1, v202, *((float **)this + 47), 1, *((unsigned int *)this + 134));
    vvtanhf(*((float **)this + 47), *((const float **)this + 47), (const int *)this + 134);
    vDSP_vadd(*((const float **)this + 74), 1, *((const float **)this + 47), 1, *((float **)this + 47), 1, *((unsigned int *)this + 134));
    vDSP_vsmul(*((const float **)this + 47), 1, &WindSuppressorCore::kPoint5f, *((float **)this + 47), 1, *((unsigned int *)this + 134));
    WindUtility::EventTracker<float>::update(*((void *)this + 101), *((float *)this + 141));
    if ((*(_DWORD *)(*((void *)this + 101) + 64) - 3) >= 2)
    {
      uint64_t v109 = *((void *)this + 47);
      LODWORD(v108) = *((_DWORD *)this + 134);
      float v110 = 0.0;
    }
    else
    {
      uint64_t v108 = *((unsigned int *)this + 134);
      uint64_t v109 = *((void *)this + 47);
      float v110 = 0.0;
      if (v108)
      {
        uint64_t v111 = 0;
        while (*(float *)(v109 + 4 * v111) <= *(float *)(*((void *)this + 62) + 20))
        {
          if (v108 == ++v111) {
            goto LABEL_97;
          }
        }
        float v110 = (float)(int)v111;
      }
    }
LABEL_97:
    size_t v141 = (float *)*((void *)this + 92);
    uint64_t v142 = 576;
    if (v110 > *v141) {
      uint64_t v142 = 572;
    }
    float v143 = (float)(v110 * (float)(1.0 - *(float *)((char *)this + v142)))
         + (float)(*(float *)((char *)this + v142) * *v141);
    float *v141 = v143;
    vDSP_vfill(&WindSuppressorCore::computeWindSuppressionGain(std::vector<float> const&,std::vector<float> const&,std::vector<float>&,unsigned int)::one, (float *)(v109 + 4 * v143), 1, v108 - v143);
    vDSP_vmax(*((const float **)this + 80), 1, *((const float **)this + 47), 1, *((float **)this + 47), 1, *((unsigned int *)this + 134));
    if (!*((unsigned char *)this + 832)) {
      __assert_rtn("refineGainsBasedOnEnergy", "WindSuppressorCore.cpp", 314, "mInitialized");
    }
    vDSP_Length v144 = *((unsigned int *)this + 134);
    if (v144 > (uint64_t)(*((void *)this + 87) - *((void *)this + 86)) >> 2) {
      __assert_rtn("refineGainsBasedOnEnergy", "WindSuppressorCore.cpp", 315, "psd.size() >= mNumBinsToProcess");
    }
    char v145 = (const float *)*((void *)this + 47);
    if (v144 > (uint64_t)(*((void *)this + 48) - (void)v145) >> 2) {
      __assert_rtn("refineGainsBasedOnEnergy", "WindSuppressorCore.cpp", 316, "gain.size() >= mNumBinsToProcess");
    }
    int v146 = (float *)*((void *)this + 89);
    if (v144 > (uint64_t)(*((void *)this + 90) - (void)v146) >> 2) {
      __assert_rtn("createSmallerThanMask", "WindSuppressorCore.cpp", 447, "vecOut.size() >= numElements");
    }
    vDSP_vsub(v145, 1, *((const float **)this + 74), 1, v146, 1, *((unsigned int *)this + 134));
    LODWORD(__B.realp) = 1036831952;
    if (!*((unsigned char *)this + 832)) {
      __assert_rtn("createGreterThanMask", "WindSuppressorCore.cpp", 425, "mInitialized");
    }
    if (v144 > (uint64_t)(*((void *)this + 48) - *((void *)this + 47)) >> 2) {
      __assert_rtn("createGreterThanMask", "WindSuppressorCore.cpp", 426, "vecIn.size() >= numElements");
    }
    BOOL v147 = (const float *)*((void *)this + 89);
    if (v144 > (uint64_t)(*((void *)this + 90) - (void)v147) >> 2) {
      __assert_rtn("createGreterThanMask", "WindSuppressorCore.cpp", 427, "vecOut.size() >= numElements");
    }
    vDSP_vthrsc(v147, 1, (const float *)&__B, &WindSuppressorCore::kOnef, *((float **)this + 89), 1, v144);
    vDSP_vthr(*((const float **)this + 89), 1, &WindSuppressorCore::kZerof, *((float **)this + 89), 1, v144);
    LODWORD(__B.realp) = 0;
    vDSP_sve(*((const float **)this + 89), 1, (float *)&__B, *((unsigned int *)this + 134));
    vDSP_vmul(*((const float **)this + 86), 1, *((const float **)this + 89), 1, *((float **)this + 89), 1, *((unsigned int *)this + 134));
    LODWORD(__A.realp) = 0;
    vDSP_sve(*((const float **)this + 89), 1, (float *)&__A, *((unsigned int *)this + 134));
    BOOL v148 = *(float *)&__B.realp < 2.2204e-16 || *(float *)&__A.realp < 2.2204e-16;
    float v149 = *(float *)&__A.realp / *(float *)&__B.realp;
    if (v148) {
      float v149 = 1.0;
    }
    *(float *)&__A.realp = v149;
    vDSP_vsdiv(*((const float **)this + 89), 1, (const float *)&__A, *((float **)this + 89), 1, *((unsigned int *)this + 134));
    LODWORD(__C.realp) = 1065353216;
    vDSP_vsadd(*((const float **)this + 89), 1, &WindSuppressorCore::kEpsf, *((float **)this + 89), 1, *((unsigned int *)this + 134));
    vDSP_vdbcon(*((const float **)this + 89), 1, (const float *)&__C, *((float **)this + 89), 1, *((unsigned int *)this + 134), 0);
    float v150 = (float *)*((void *)this + 92);
    if (*v150 > 0.0)
    {
      uint64_t v151 = 0;
      uint64_t v152 = *((void *)this + 62);
      float v153 = *(float *)(v152 + 44);
      float v154 = *(float *)(v152 + 48);
      uint64_t v155 = *((void *)this + 89);
      uint64_t v156 = *((void *)this + 47);
      float v157 = vabds_f32(v153, v154);
      do
      {
        if (v157 >= 2.2204e-16)
        {
          float v159 = *(float *)(v155 + 4 * v151);
          float v158 = 1.0;
          if (v159 < v153) {
            goto LABEL_118;
          }
          if (v159 <= v154)
          {
            float v158 = (float)((float)((float)(1.0 - *(float *)(v156 + 4 * v151)) / (float)(v153 - v154))
                         * (float)(v159 - v153))
                 + 1.0;
            goto LABEL_118;
          }
        }
        float v158 = *(float *)(v156 + 4 * v151);
LABEL_118:
        *(float *)(v156 + 4 * v151++) = v158;
      }
      while (*v150 > (float)(int)v151);
    }
    if (!*((unsigned char *)this + 832)) {
      __assert_rtn("applyFrequencySmoothingWindow", "WindSuppressorCore.cpp", 366, "mInitialized");
    }
    vDSP_Length v160 = *((unsigned int *)this + 134);
    uint64_t v161 = *((void *)this + 47);
    if (v160 > (*((void *)this + 48) - v161) >> 2) {
      __assert_rtn("applyFrequencySmoothingWindow", "WindSuppressorCore.cpp", 367, "input.size() >= inputSize");
    }
    int v162 = (float *)*((void *)this + 83);
    vDSP_Length v163 = (uint64_t)(*((void *)this + 84) - (void)v162) >> 2;
    unsigned int v164 = *((_DWORD *)this + 135);
    if (v163 < v164 + v160) {
      __assert_rtn("applyFrequencySmoothingWindow", "WindSuppressorCore.cpp", 369, "mTmpVector1.size() >= inputSize + mFilterSize");
    }
    if (v164 <= 1) {
      vDSP_Length v165 = 0;
    }
    else {
      vDSP_Length v165 = (v164 >> 1) - 1;
    }
    vDSP_vfill((const float *)(v161 + 4 * (v160 - 1)), v162, 1, v163);
    vDSP_vfill(*((const float **)this + 47), *((float **)this + 83), 1, v165);
    if (v160) {
      memmove((void *)(*((void *)this + 83) + 4 * v165), *((const void **)this + 47), 4 * v160);
    }
    vDSP_conv(*((const float **)this + 83), 1, (const float *)(*((void *)this + 77) + 4 * *((unsigned int *)this + 135) - 4), -1, *((float **)this + 47), 1, v160, *((unsigned int *)this + 135));
    if (!*((unsigned char *)this + 832)) {
      __assert_rtn("smoothGainsInTime", "WindSuppressorCore.cpp", 401, "mInitialized");
    }
    vDSP_Length v166 = (const float *)*((void *)this + 47);
    vDSP_Length __N = *((unsigned int *)this + 134);
    if (__N > (uint64_t)(*((void *)this + 48) - (void)v166) >> 2) {
      __assert_rtn("smoothGainsInTime", "WindSuppressorCore.cpp", 402, "gain.size() >= mNumBinsToProcess");
    }
    uint64_t v168 = *((void *)this + 95);
    LODWORD(__A.realp) = *((_DWORD *)this + 145);
    *(float *)&__C.realp = 1.0 - *(float *)&__A.realp;
    vDSP_vsmsma(*(const float **)v168, 1, (const float *)&__A, v166, 1, (const float *)&__C, *(float **)v168, 1, __N);
    if (!*((unsigned char *)this + 832)) {
      __assert_rtn("generateHighPassCutoffIndex", "WindSuppressorCore.cpp", 483, "mInitialized");
    }
    vDSP_Length v169 = *((unsigned int *)this + 134);
    if (v169 > (uint64_t)(*(void *)(v168 + 8) - *(void *)v168) >> 2) {
      __assert_rtn("generateHighPassCutoffIndex", "WindSuppressorCore.cpp", 484, "gain.size() >= mNumBinsToProcess");
    }
    vDSP_vsub(*(const float **)v168, 1, *((const float **)this + 74), 1, *((float **)this + 83), 1, v169);
    vDSP_vthrsc(*((const float **)this + 83), 1, &WindSuppressorCore::generateHighPassCutoffIndex(std::vector<float> const&)::thr, &WindSuppressorCore::kOnef, *((float **)this + 83), 1, *((unsigned int *)this + 134));
    vDSP_vthr(*((const float **)this + 83), 1, &WindSuppressorCore::kZerof, *((float **)this + 83), 1, *((unsigned int *)this + 134));
    LODWORD(__B.realp) = 0;
    vDSP_sve(*((const float **)this + 83), 1, (float *)&__B, *((unsigned int *)this + 134));
    float v140 = *((double *)this + 69)
         / (float)((float)*((unsigned int *)this + 132) + (float)*((unsigned int *)this + 132))
         * *(float *)&__B.realp;
    *((float *)this + 142) = v140;
    uint64_t v170 = *((unsigned int *)this + 134);
    if (v170)
    {
      memmove(*((void **)this + 47), **((const void ***)this + 95), 4 * v170);
      float v140 = *((float *)this + 142);
    }
  }
  else
  {
    if (v93 > v95)
    {
      unint64_t v112 = *((unsigned int *)this + 9);
      unsigned int v113 = *((_DWORD *)this + 11);
      if (v112 <= v113)
      {
        uint64_t v114 = *((void *)this + 44);
        uint64_t v115 = *((void *)this + 47);
        unsigned int v116 = *((_DWORD *)this + 9);
        do
        {
          float v117 = *((float *)this + 22)
               + (float)(*(float *)this - *((float *)this + 22))
               * ((float)(tanhf(*((float *)this + 39) * (float)(*(float *)(v114 + 4 * v116) - *((float *)this + 38)))
                        + 1.0)
                * 0.5);
          *(float *)(v115 + 4 * v116++) = v117;
        }
        while (v116 <= v113);
      }
      uint64_t v119 = *((void *)this + 50);
      uint64_t v118 = *((void *)this + 51);
      unint64_t v120 = (v118 - v119) >> 2;
      unint64_t v121 = v120 >> 1;
      if (v120 >> 1 <= v112) {
        unint64_t v122 = v112;
      }
      else {
        unint64_t v122 = v120 >> 1;
      }
      unint64_t v123 = *((unsigned int *)this + 6);
      LODWORD(__B.realp) = 0;
      std::vector<float>::assign((char **)this + 53, v123, &__B);
      uint64_t v124 = *((unsigned int *)this + 11);
      unint64_t v125 = v124 - (v120 >> 1);
      if (v122 <= v125)
      {
        if (v120 <= 1) {
          uint64_t v126 = 1;
        }
        else {
          uint64_t v126 = (v118 - v119) >> 2;
        }
        uint64_t v127 = 4 * v122 - 4 * v121;
        do
        {
          if (v118 != v119)
          {
            uint64_t v128 = *((void *)this + 53);
            float v129 = *(float *)(v128 + 4 * v122);
            int v130 = (float *)(*((void *)this + 50) + 4 * v120 - 4 * v121);
            unint64_t v131 = (float *)(*((void *)this + 47) + v127);
            uint64_t v132 = v126;
            do
            {
              float v133 = *v131++;
              float v134 = v133;
              float v135 = *v130--;
              float v129 = v129 + (float)(v134 * v135);
              *(float *)(v128 + 4 * v122) = v129;
              --v132;
            }
            while (v132);
          }
          ++v122;
          v127 += 4;
        }
        while (v122 <= v125);
      }
      if (v121 <= v125)
      {
        uint64_t v136 = *((void *)this + 53);
        uint64_t v137 = *((void *)this + 47);
        do
        {
          *(_DWORD *)(v137 + 4 * v121) = *(_DWORD *)(v136 + 4 * v121);
          ++v121;
        }
        while (v121 <= v125);
      }
      unsigned int v138 = *((_DWORD *)this + 10);
      if (v138 <= v124)
      {
        uint64_t v139 = *((void *)this + 47);
        while (*(float *)(v139 + 4 * v138) <= *((float *)this + 43))
        {
          if (++v138 > v124) {
            goto LABEL_134;
          }
        }
        float v193 = *((double *)this + 2)
             / (float)((float)*((unsigned int *)this + 6) + (float)*((unsigned int *)this + 6))
             * (double)v138;
        *((float *)this + 32) = v193;
        while (v138 <= v124)
          *(_DWORD *)(v139 + 4 * v138++) = *(_DWORD *)this;
      }
      goto LABEL_134;
    }
    std::vector<float>::assign((char **)this + 47, *((unsigned int *)this + 6), this);
    float v140 = 160.0;
  }
  *((float *)this + 32) = v140;
LABEL_134:
  if (a3)
  {
    uint64_t v171 = 0;
    vDSP_Length v172 = *((unsigned int *)this + 6);
    char v173 = 1;
    do
    {
      char v174 = v173;
      mData = (const float *)a2->mBuffers[v171].mData;
      uint64_t v176 = (float *)a3->mBuffers[v171].mData;
      float v177 = mData[v172];
      vDSP_vmul(mData, 1, *((const float **)this + 47), 1, v176, 1, v172);
      vDSP_vmul(&mData[*((unsigned int *)this + 6)], 1, *((const float **)this + 47), 1, &v176[*((unsigned int *)this + 6)], 1, *((unsigned int *)this + 6));
      char v173 = 0;
      vDSP_Length v172 = *((unsigned int *)this + 6);
      v176[v172] = v177;
      uint64_t v171 = 1;
    }
    while ((v174 & 1) != 0);
  }
  float32x2_t v178 = (float32x2_t)0x3F0000003F000000;
  if ((*((_DWORD *)this + 46) - 3) <= 1)
  {
    float v195 = __exp10f(*((float *)this + 24) * 0.1);
    v179.f32[0] = __exp10f(*((float *)this + 25) * 0.1);
    v179.f32[1] = v195;
    float32x2_t v178 = vcvt_f32_f64(vmulq_n_f64(vcvtq_f64_f32(v179), 1.0 / (float)((float)(v195 + v179.f32[0]) + *((float *)this + 1))));
  }
  *(float32x2_t *)((char *)this + 236) = v178;
  unsigned __int8 v180 = (char *)this + 236;
  if (a4)
  {
    unsigned __int8 v181 = (const float *)a2->mBuffers[0].mData;
    v182 = *(const float **)&a2[1].mBuffers[0].mNumberChannels;
    unsigned int v183 = (float *)a4->mBuffers[0].mData;
    vDSP_Length v184 = (2 * *((_DWORD *)this + 6));
    if (*((unsigned char *)this + 244))
    {
      if (!*((unsigned char *)this + 832)) {
        __assert_rtn("updateAggregateOmni", "WindSuppressorCore.cpp", 232, "mInitialized");
      }
      unsigned __int8 v180 = (char *)*((void *)this + 98);
      if (*((void *)this + 99) - (void)v180 <= 7uLL) {
        __assert_rtn("updateAggregateOmni", "WindSuppressorCore.cpp", 233, "mAggregateOmniMicWeight.size() >= 2");
      }
      float v185 = (float)((float)(1.0 - *((float *)this + 146)) * v178.f32[0])
           + (float)(*((float *)this + 146) * *(float *)v180);
      *(float *)unsigned __int8 v180 = v185;
      *((float *)v180 + 1) = 1.0 - v185;
      v186 = (const float *)(v180 + 4);
    }
    else
    {
      v186 = (const float *)((char *)this + 240);
    }
    vDSP_vsmsma(v181, 1, (const float *)v180, v182, 1, v186, v183, 1, v184);
  }
  if (a5)
  {
    std::string::size_type v187 = (unsigned char *)*((void *)this + 47);
    int64_t v188 = (unsigned char *)*((void *)this + 48);
    if (v188 != v187) {
      memmove(a5->mBuffers[0].mData, v187, v188 - v187);
    }
  }
}

void ecutils::fcn_vector_init<float>(uint64_t *a1, unsigned int a2, unsigned int a3, float a4)
{
  float v7 = a4;
  unint64_t v5 = a2;
  std::vector<float>::vector(__p, a3, &v7);
  std::vector<std::vector<float>>::assign(a1, v5, (uint64_t)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_1BB36AE58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ecutils::fcn_vector_init<float>(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4, float a5)
{
  float v25 = a5;
  unint64_t v7 = a3;
  std::vector<float>::vector(__p, a4, &v25);
  std::vector<std::vector<float>>::vector(&v23, v7, (uint64_t)__p);
  unint64_t v8 = a2;
  uint64_t v9 = *(void ***)a1;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) >= a2)
  {
    unint64_t v15 = (*(void *)(a1 + 8) - (void)v9) / 24;
    if (v15 >= v8) {
      uint64_t v16 = v8;
    }
    else {
      uint64_t v16 = (*(void *)(a1 + 8) - (void)v9) / 24;
    }
    for (; v16; --v16)
    {
      if (v9 != (void **)&v23) {
        std::vector<std::vector<float>>::__assign_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>((uint64_t)v9, v23, v24, 0xAAAAAAAAAAAAAAABLL * ((v24 - v23) >> 3));
      }
      v9 += 3;
    }
    if (v8 <= v15)
    {
      unsigned int v20 = *(void ***)(a1 + 8);
      uint64_t v21 = *(void *)a1 + 24 * v8;
      while (v20 != (void **)v21)
      {
        v20 -= 3;
        unsigned int v26 = v20;
        std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v26);
      }
      *(void *)(a1 + 8) = v21;
    }
    else
    {
      float v17 = *(void **)(a1 + 8);
      unint64_t v18 = &v17[3 * (v8 - v15)];
      uint64_t v19 = 24 * v8 - 24 * v15;
      do
      {
        *float v17 = 0;
        v17[1] = 0;
        v17[2] = 0;
        std::vector<std::vector<float>>::__init_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(v17, v23, v24, 0xAAAAAAAAAAAAAAABLL * ((v24 - v23) >> 3));
        v17 += 3;
        v19 -= 24;
      }
      while (v19);
      *(void *)(a1 + 8) = v18;
    }
  }
  else
  {
    std::vector<std::vector<std::vector<float>>>::__vdeallocate((void ***)a1);
    unint64_t v10 = 0x5555555555555556 * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3);
    if (v10 <= a2) {
      unint64_t v10 = a2;
    }
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v10;
    }
    std::vector<std::vector<DSPSplitComplex>>::__vallocate[abi:ne180100]((void *)a1, v11);
    uint64_t v12 = *(void **)(a1 + 8);
    uint64_t v13 = &v12[3 * a2];
    uint64_t v14 = 24 * v8;
    do
    {
      void *v12 = 0;
      v12[1] = 0;
      _DWORD v12[2] = 0;
      std::vector<std::vector<float>>::__init_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(v12, v23, v24, 0xAAAAAAAAAAAAAAABLL * ((v24 - v23) >> 3));
      v12 += 3;
      v14 -= 24;
    }
    while (v14);
    *(void *)(a1 + 8) = v13;
  }
  unsigned int v26 = (void **)&v23;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v26);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_1BB36B09C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, char *a16)
{
  a16 = &a12;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a16);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void ecutils::fcn_vector_init<float>(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5, float a6)
{
  float v29 = a6;
  unint64_t v9 = a4;
  std::vector<float>::vector(__p, a5, &v29);
  std::vector<std::vector<float>>::vector(v26, v9, (uint64_t)__p);
  std::vector<std::vector<std::vector<float>>>::vector(&v27, a3, v26);
  unint64_t v10 = a2;
  unint64_t v11 = *(void ***)a1;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) >= v10)
  {
    unint64_t v18 = (*(void *)(a1 + 8) - (void)v11) / 24;
    if (v18 >= v10) {
      uint64_t v19 = v10;
    }
    else {
      uint64_t v19 = (*(void *)(a1 + 8) - (void)v11) / 24;
    }
    for (; v19; --v19)
    {
      if (v11 != (void **)&v27) {
        std::vector<std::vector<std::vector<float>>>::__assign_with_size[abi:ne180100]<std::vector<std::vector<float>>*,std::vector<std::vector<float>>*>((uint64_t)v11, v27, v28, 0xAAAAAAAAAAAAAAABLL * (v28 - v27));
      }
      v11 += 3;
    }
    if (v10 <= v18)
    {
      uint64_t v23 = *(void ***)(a1 + 8);
      uint64_t v24 = *(void *)a1 + 24 * v10;
      while (v23 != (void **)v24)
      {
        v23 -= 3;
        float v30 = v23;
        std::vector<std::vector<std::vector<DspLib::Biquad::Section>>>::__destroy_vector::operator()[abi:ne180100](&v30);
      }
      *(void *)(a1 + 8) = v24;
    }
    else
    {
      unsigned int v20 = *(void **)(a1 + 8);
      uint64_t v21 = &v20[3 * (v10 - v18)];
      uint64_t v22 = 24 * v10 - 24 * v18;
      do
      {
        *unsigned int v20 = 0;
        v20[1] = 0;
        v20[2] = 0;
        std::vector<std::vector<std::vector<float>>>::__init_with_size[abi:ne180100]<std::vector<std::vector<float>>*,std::vector<std::vector<float>>*>(v20, v27, v28, 0xAAAAAAAAAAAAAAABLL * (v28 - v27));
        v20 += 3;
        v22 -= 24;
      }
      while (v22);
      *(void *)(a1 + 8) = v21;
    }
  }
  else
  {
    std::vector<std::vector<std::vector<std::vector<float>>>>::__vdeallocate((void ***)a1);
    unint64_t v12 = 0x5555555555555556 * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3);
    if (v12 <= v10) {
      unint64_t v12 = v10;
    }
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) >= 0x555555555555555) {
      unint64_t v13 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v13 = v12;
    }
    std::vector<std::vector<DSPSplitComplex>>::__vallocate[abi:ne180100]((void *)a1, v13);
    uint64_t v14 = *(void **)(a1 + 8);
    uint64_t v15 = 3 * v10;
    uint64_t v16 = &v14[3 * v10];
    uint64_t v17 = 8 * v15;
    do
    {
      void *v14 = 0;
      v14[1] = 0;
      v14[2] = 0;
      std::vector<std::vector<std::vector<float>>>::__init_with_size[abi:ne180100]<std::vector<std::vector<float>>*,std::vector<std::vector<float>>*>(v14, v27, v28, 0xAAAAAAAAAAAAAAABLL * (v28 - v27));
      v14 += 3;
      v17 -= 24;
    }
    while (v17);
    *(void *)(a1 + 8) = v16;
  }
  float v30 = (void **)&v27;
  std::vector<std::vector<std::vector<DspLib::Biquad::Section>>>::__destroy_vector::operator()[abi:ne180100](&v30);
  float v30 = (void **)v26;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v30);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_1BB36B338(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char a16)
{
  *(void *)(v16 - 72) = &a16;
  std::vector<std::vector<std::vector<DspLib::Biquad::Section>>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v16 - 72));
  *(void *)(v16 - 72) = &a13;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v16 - 72));
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *std::vector<std::vector<std::vector<float>>>::vector(void *a1, unint64_t a2, uint64_t *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::vector<DSPSplitComplex>>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v6 = (void *)a1[1];
    uint64_t v7 = 3 * a2;
    unint64_t v8 = &v6[3 * a2];
    uint64_t v9 = 8 * v7;
    do
    {
      void *v6 = 0;
      v6[1] = 0;
      v6[2] = 0;
      std::vector<std::vector<float>>::__init_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(v6, *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 3));
      v6 += 3;
      v9 -= 24;
    }
    while (v9);
    a1[1] = v8;
  }
  return a1;
}

void sub_1BB36B444(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void std::vector<std::vector<std::vector<std::vector<float>>>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = (void **)**a1;
  if (v2)
  {
    int v4 = (void **)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        uint64_t v6 = v4;
        std::vector<std::vector<std::vector<DspLib::Biquad::Section>>>::__destroy_vector::operator()[abi:ne180100](&v6);
      }
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *std::vector<std::vector<std::vector<std::vector<float>>>>::__init_with_size[abi:ne180100]<std::vector<std::vector<std::vector<float>>>*,std::vector<std::vector<std::vector<float>>>*>(void *result, uint64_t **a2, uint64_t **a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    std::vector<std::vector<DSPSplitComplex>>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = (void *)v6[1];
    unint64_t v11 = v7;
    unint64_t v12 = v7;
    v9[0] = v6 + 2;
    v9[1] = &v11;
    uint64_t v9[2] = &v12;
    char v10 = 0;
    if (a2 == a3)
    {
      unint64_t v8 = v7;
    }
    else
    {
      unint64_t v8 = v7;
      do
      {
        *unint64_t v8 = 0;
        v8[1] = 0;
        v8[2] = 0;
        std::vector<std::vector<std::vector<float>>>::__init_with_size[abi:ne180100]<std::vector<std::vector<float>>*,std::vector<std::vector<float>>*>(v8, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * (a2[1] - *a2));
        unint64_t v8 = v12 + 3;
        v12 += 3;
        a2 += 3;
      }
      while (a2 != a3);
    }
    char v10 = 1;
    double result = (void *)std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<std::vector<float>>>>,std::vector<std::vector<std::vector<float>>>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v9);
    v6[1] = v8;
  }
  return result;
}

void sub_1BB36B5D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void *std::vector<std::vector<std::vector<float>>>::__init_with_size[abi:ne180100]<std::vector<std::vector<float>>*,std::vector<std::vector<float>>*>(void *result, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    std::vector<std::vector<DSPSplitComplex>>::__vallocate[abi:ne180100](result, a4);
    double result = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<std::vector<float>>>,std::vector<std::vector<float>>*,std::vector<std::vector<float>>*,std::vector<std::vector<float>>*>((uint64_t)(v6 + 2), a2, a3, (void *)v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1BB36B664(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  std::vector<std::vector<std::vector<DspLib::Biquad::Section>>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<std::vector<float>>>>,std::vector<std::vector<std::vector<float>>>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24))
  {
    unint64_t v3 = **(void ****)(a1 + 16);
    int v4 = **(void ****)(a1 + 8);
    while (v3 != v4)
    {
      v3 -= 3;
      unint64_t v5 = v3;
      std::vector<std::vector<std::vector<DspLib::Biquad::Section>>>::__destroy_vector::operator()[abi:ne180100](&v5);
    }
  }
  return a1;
}

void *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<std::vector<float>>>,std::vector<std::vector<float>>*,std::vector<std::vector<float>>*,std::vector<std::vector<float>>*>(uint64_t a1, uint64_t *a2, uint64_t *a3, void *a4)
{
  int v4 = a4;
  uint64_t v10 = a4;
  unint64_t v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  char v9 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      void *v4 = 0;
      v4[1] = 0;
      v4[2] = 0;
      std::vector<std::vector<float>>::__init_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(v4, *v6, v6[1], 0xAAAAAAAAAAAAAAABLL * ((v6[1] - *v6) >> 3));
      int v4 = v11 + 3;
      v11 += 3;
      v6 += 3;
    }
    while (v6 != a3);
  }
  char v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<float>>>,std::vector<std::vector<float>>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_1BB36B794(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<float>>>,std::vector<std::vector<float>>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24))
  {
    unint64_t v3 = **(void ****)(a1 + 16);
    int v4 = **(void ****)(a1 + 8);
    while (v3 != v4)
    {
      v3 -= 3;
      unint64_t v5 = v3;
      std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
    }
  }
  return a1;
}

void std::vector<std::vector<std::vector<std::vector<float>>>>::__vdeallocate(void ***a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    unint64_t v3 = a1[1];
    int v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        v3 -= 3;
        unint64_t v5 = v3;
        std::vector<std::vector<std::vector<DspLib::Biquad::Section>>>::__destroy_vector::operator()[abi:ne180100](&v5);
      }
      while (v3 != v1);
      int v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void std::vector<std::vector<std::vector<float>>>::__assign_with_size[abi:ne180100]<std::vector<std::vector<float>>*,std::vector<std::vector<float>>*>(uint64_t a1, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v8 = a1 + 16;
  char v9 = *(void ***)a1;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) < a4)
  {
    std::vector<std::vector<std::vector<float>>>::__vdeallocate((void ***)a1);
    if (a4 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0x5555555555555556 * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3);
    if (v10 <= a4) {
      unint64_t v10 = a4;
    }
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v10;
    }
    std::vector<std::vector<DSPSplitComplex>>::__vallocate[abi:ne180100]((void *)a1, v11);
    unint64_t v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<std::vector<float>>>,std::vector<std::vector<float>>*,std::vector<std::vector<float>>*,std::vector<std::vector<float>>*>(v8, a2, a3, *(void **)(a1 + 8));
    goto LABEL_11;
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 3) < a4)
  {
    unint64_t v13 = &a2[(uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 3];
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<std::vector<float>> *,std::vector<std::vector<float>> *,std::vector<std::vector<float>> *>(a2, v13, (uint64_t)v9);
    unint64_t v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<std::vector<float>>>,std::vector<std::vector<float>>*,std::vector<std::vector<float>>*,std::vector<std::vector<float>>*>(v8, v13, a3, *(void **)(a1 + 8));
LABEL_11:
    *(void *)(a1 + 8) = v12;
    return;
  }
  uint64_t v14 = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<std::vector<float>> *,std::vector<std::vector<float>> *,std::vector<std::vector<float>> *>(a2, a3, (uint64_t)v9);
  uint64_t v15 = *(void ***)(a1 + 8);
  while (v15 != (void **)v14)
  {
    v15 -= 3;
    uint64_t v16 = v15;
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v16);
  }
  *(void *)(a1 + 8) = v14;
}

void sub_1BB36B9E8(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1BB36B9F0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<std::vector<float>> *,std::vector<std::vector<float>> *,std::vector<std::vector<float>> *>(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    unint64_t v5 = a1;
    do
    {
      if (v5 != (uint64_t *)a3) {
        std::vector<std::vector<float>>::__assign_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(a3, *v5, v5[1], 0xAAAAAAAAAAAAAAABLL * ((v5[1] - *v5) >> 3));
      }
      v5 += 3;
      a3 += 24;
    }
    while (v5 != a2);
  }
  return a3;
}

void std::vector<std::vector<std::vector<float>>>::__vdeallocate(void ***a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    unint64_t v3 = a1[1];
    int v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        v3 -= 3;
        unint64_t v5 = v3;
        std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
      }
      while (v3 != v1);
      int v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void std::vector<std::vector<float>>::assign(uint64_t *a1, unint64_t a2, uint64_t a3)
{
  uint64_t v6 = (char *)*a1;
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 3) >= a2)
  {
    unint64_t v13 = (a1[1] - (uint64_t)v6) / 24;
    if (v13 >= a2) {
      uint64_t v14 = a2;
    }
    else {
      uint64_t v14 = (a1[1] - (uint64_t)v6) / 24;
    }
    for (; v14; --v14)
    {
      if (v6 != (char *)a3) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>(v6, *(char **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
      }
      v6 += 24;
    }
    if (a2 <= v13)
    {
      uint64_t v18 = a1[1];
      uint64_t v19 = *a1 + 24 * a2;
      if (v18 != v19)
      {
        uint64_t v20 = a1[1];
        do
        {
          uint64_t v22 = *(void **)(v20 - 24);
          v20 -= 24;
          uint64_t v21 = v22;
          if (v22)
          {
            *(void *)(v18 - 16) = v21;
            operator delete(v21);
          }
          uint64_t v18 = v20;
        }
        while (v20 != v19);
      }
      a1[1] = v19;
    }
    else
    {
      uint64_t v15 = (void *)a1[1];
      uint64_t v16 = &v15[3 * (a2 - v13)];
      uint64_t v17 = -24 * v13 + 24 * a2;
      do
      {
        *uint64_t v15 = 0;
        v15[1] = 0;
        v15[2] = 0;
        std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v15, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
        v15 += 3;
        v17 -= 24;
      }
      while (v17);
      a1[1] = (uint64_t)v16;
    }
  }
  else
  {
    std::vector<std::vector<float>>::__vdeallocate(a1);
    unint64_t v7 = 0x5555555555555556 * ((a1[2] - *a1) >> 3);
    if (v7 <= a2) {
      unint64_t v7 = a2;
    }
    if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 3) >= 0x555555555555555) {
      unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v8 = v7;
    }
    std::vector<std::__fs::filesystem::path>::__vallocate[abi:ne180100](a1, v8);
    char v9 = (void *)a1[1];
    uint64_t v10 = 3 * a2;
    unint64_t v11 = &v9[3 * a2];
    uint64_t v12 = 8 * v10;
    do
    {
      void *v9 = 0;
      v9[1] = 0;
      uint64_t v9[2] = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v9, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
      v9 += 3;
      v12 -= 24;
    }
    while (v12);
    a1[1] = (uint64_t)v11;
  }
}

void sub_1BB36BCA0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void std::vector<std::vector<unsigned int>>::resize(void *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<std::vector<unsigned int>>::__append((uint64_t)a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 24 * a2;
    if (v3 != v7)
    {
      uint64_t v8 = a1[1];
      do
      {
        uint64_t v10 = *(void **)(v8 - 24);
        v8 -= 24;
        char v9 = v10;
        if (v10)
        {
          *(void *)(v3 - 16) = v9;
          operator delete(v9);
        }
        uint64_t v3 = v8;
      }
      while (v8 != v7);
    }
    a1[1] = v7;
  }
}

void std::vector<std::vector<unsigned int>>::__append(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = a1 + 16;
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v6 = *(void *)(a1 + 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v5 - v6) >> 3) >= a2)
  {
    if (a2)
    {
      size_t v12 = 24 * ((24 * a2 - 24) / 0x18) + 24;
      bzero(*(void **)(a1 + 8), v12);
      v6 += v12;
    }
    *(void *)(a1 + 8) = v6;
  }
  else
  {
    unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * ((v6 - *(void *)a1) >> 3);
    unint64_t v8 = v7 + a2;
    if (v7 + a2 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *(void *)a1) >> 3);
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x555555555555555) {
      unint64_t v10 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v10 = v8;
    }
    uint64_t v18 = v4;
    if (v10) {
      unint64_t v10 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<AUPropertyItem>>(v10);
    }
    else {
      uint64_t v11 = 0;
    }
    unint64_t v14 = v10;
    uint64_t v15 = (char *)(v10 + 24 * v7);
    unint64_t v17 = v10 + 24 * v11;
    size_t v13 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v15, v13);
    uint64_t v16 = &v15[v13];
    std::vector<std::vector<unsigned int>>::__swap_out_circular_buffer((void *)a1, &v14);
    std::__split_buffer<std::vector<unsigned int>>::~__split_buffer((uint64_t)&v14);
  }
}

void *std::vector<std::vector<unsigned int>>::__swap_out_circular_buffer(void *result, void *a2)
{
  uint64_t v3 = (void *)*result;
  uint64_t v2 = (void *)result[1];
  uint64_t v4 = a2[1];
  while (v2 != v3)
  {
    *(void *)(v4 - 24) = 0;
    *(void *)(v4 - 16) = 0;
    v4 -= 24;
    *(void *)(v4 + 16) = 0;
    long long v5 = *(_OWORD *)(v2 - 3);
    v2 -= 3;
    *(_OWORD *)uint64_t v4 = v5;
    *(void *)(v4 + 16) = v2[2];
    *uint64_t v2 = 0;
    v2[1] = 0;
    v2[2] = 0;
  }
  a2[1] = v4;
  uint64_t v6 = (void *)*result;
  *double result = v4;
  a2[1] = v6;
  uint64_t v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<std::vector<unsigned int>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    uint64_t v4 = *(void **)(v2 - 24);
    *(void *)(a1 + 16) = v2 - 24;
    if (v4)
    {
      *(void *)(v2 - 16) = v4;
      operator delete(v4);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 24;
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t AUSpeechEnhancer::ValidFormat(AUSpeechEnhancer *this, const AudioStreamBasicDescription *a2, unsigned int a3, AudioStreamBasicDescription *a4)
{
  uint64_t result = ausdk::ASBD::IsCommonFloat32((ausdk::ASBD *)a4, a2);
  if (result)
  {
    if ((a4->mFormatFlags & 0x20) != 0) {
      return 1;
    }
    uint64_t result = a4->mChannelsPerFrame == 1;
  }
  if ((result & 1) == 0 && a4->mFormatID == 1718773105)
  {
    long long v6 = *(_OWORD *)&a4->mBytesPerPacket;
    v7[0] = *(_OWORD *)&a4->mSampleRate;
    v7[1] = v6;
    uint64_t v8 = *(void *)&a4->mBitsPerChannel;
    DWORD2(v7[0]) = 1819304813;
    int v9 = 0;
    LODWORD(result) = CAStreamBasicDescription::IdentifyCommonPCMFormat(v7, &v9, 0);
    if (v9 == 4) {
      return result;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t CAStreamBasicDescription::IdentifyCommonPCMFormat(_DWORD *a1, int *a2, BOOL *a3)
{
  if (a1[2] != 1819304813) {
    return 0;
  }
  if (a1[5] != 1) {
    return 0;
  }
  unsigned int v3 = a1[6];
  if (v3 != a1[4]) {
    return 0;
  }
  unsigned int v4 = a1[8];
  if (v3 < v4 >> 3) {
    return 0;
  }
  unsigned int v5 = a1[7];
  if (!v5) {
    return 0;
  }
  unsigned int v6 = a1[3];
  if ((v6 & 0x20) == 0)
  {
    BOOL v10 = v3 == v3 / v5 * v5;
    v3 /= v5;
    if (!v10) {
      return 0;
    }
  }
  int v7 = 0;
  if ((v6 & 2) == 0 && 8 * v3 == v4)
  {
    if (v6)
    {
      if ((v6 & 0x1F84) != 0) {
        return 0;
      }
      int v7 = 4 * (v3 == 8);
      if (v3 == 4) {
        int v7 = 1;
      }
    }
    else if ((v6 & 4) != 0)
    {
      int v9 = (v6 >> 7) & 0x3F;
      if (v9 == 24 && v3 == 4)
      {
        int v7 = 3;
      }
      else if (v9 || v3 != 4)
      {
        BOOL v10 = v3 == 2 && v9 == 0;
        if (v10) {
          int v7 = 2;
        }
        else {
          int v7 = 0;
        }
      }
      else
      {
        int v7 = 5;
      }
    }
    else
    {
      int v7 = 0;
    }
  }
  if (a3) {
    *a3 = (a1[3] & 0x20) == 0;
  }
  *a2 = v7;
  return 1;
}

uint64_t AUSpeechEnhancer::SupportedNumChannels(AUSpeechEnhancer *this, const AUChannelInfo **a2)
{
  if (a2) {
    *a2 = (const AUChannelInfo *)&AUSpeechEnhancer::SupportedNumChannels(AUChannelInfo const**)::sChannels;
  }
  return 1;
}

BOOL AUSpeechEnhancer::StreamFormatWritable(AUSpeechEnhancer *this)
{
  return *((unsigned char *)this + 17) == 0;
}

uint64_t AUSpeechEnhancer::SupportsTail(AUSpeechEnhancer *this)
{
  return 1;
}

double AUSpeechEnhancer::GetTailTime(AUSpeechEnhancer *this)
{
  return 0.0;
}

uint64_t AUSpeechEnhancer::GetLatency(uint64_t this)
{
  if (!*(unsigned char *)(this + 545)) {
    return ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(this + 128), 0);
  }
  return this;
}

uint64_t AUSpeechEnhancer::GetParameterValueStrings(AUSpeechEnhancer *this, int a2, int a3, const __CFArray **a4)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (a2) {
    return 4294956418;
  }
  if (!a4) {
    return 0;
  }
  if (a3 == 4)
  {
    unsigned int v6 = &xmmword_1E623C330;
    goto LABEL_10;
  }
  if (a3 == 3)
  {
    unsigned int v6 = &xmmword_1E623C320;
LABEL_10:
    long long v8 = *v6;
    CFArrayRef v7 = CFArrayCreate(0, (const void **)&v8, 2, 0);
    uint64_t result = 0;
    *a4 = v7;
    return result;
  }
  return 4294956418;
}

uint64_t AUSpeechEnhancer::RestoreState(OpaqueAudioComponentInstance **this, const void *a2)
{
  uint64_t result = ausdk::AUBase::RestoreState(this, a2);
  if (!result)
  {
    if (*((unsigned char *)this + 17)) {
      ++*((_DWORD *)this + 162);
    }
  }
  return result;
}

uint64_t AUSpeechEnhancer::GetParameterInfo(AUSpeechEnhancer *this, int a2, unsigned int a3, AudioUnitParameterInfo *buffer)
{
  if (a2) {
    return 4294956418;
  }
  uint64_t v5 = *((void *)this + 82);
  if (a3 >= (unint64_t)((*((void *)this + 83) - v5) >> 5)) {
    return 4294956418;
  }
  uint64_t v6 = v5 + 32 * a3;
  int v7 = *(_DWORD *)(v6 + 12);
  buffer->unit = *(_DWORD *)(v6 + 8);
  buffer->minCFArrayRef Value = *(AudioUnitParameterValue *)(v6 + 16);
  buffer->maxCFArrayRef Value = *(AudioUnitParameterValue *)(v6 + 20);
  buffer->defaultCFArrayRef Value = *(AudioUnitParameterValue *)(v6 + 24);
  int v8 = v7 + 1098907648;
  buffer->flags = v7 + 1098907648;
  signed int v9 = *(_DWORD *)(v6 + 28);
  if (v9 >= 1)
  {
    buffer->clumpID = v9;
    v8 |= 0x100000u;
  }
  CFStringRef v10 = *(const __CFString **)v6;
  buffer->cfNameString = *(CFStringRef *)v6;
  buffer->flags = v8 | 0x8000000;
  CFStringGetCString(v10, buffer->name, 52, 0x8000100u);
  return 0;
}

uint64_t AUSpeechEnhancer::GetParameterList(AUSpeechEnhancer *this, int a2, unsigned int *a3, unsigned int *a4)
{
  if (a2)
  {
    *a4 = 0;
    return 4294956430;
  }
  else
  {
    if (a3)
    {
      *((void *)a3 + 18) = 0x1B0000001ALL;
      *((_OWORD *)a3 + 6) = xmmword_1BB87DC28;
      *((_OWORD *)a3 + 7) = unk_1BB87DC38;
      *((_OWORD *)a3 + 8) = xmmword_1BB87DC48;
      *((_OWORD *)a3 + 2) = xmmword_1BB87DBE8;
      *((_OWORD *)a3 + 3) = unk_1BB87DBF8;
      *((_OWORD *)a3 + 4) = xmmword_1BB87DC08;
      *((_OWORD *)a3 + 5) = unk_1BB87DC18;
      *(_OWORD *)a3 = xmmword_1BB87DBC8;
      *((_OWORD *)a3 + 1) = unk_1BB87DBD8;
      *(_OWORD *)(a3 + 38) = xmmword_1BB879CC0;
      *(_OWORD *)(a3 + 42) = xmmword_1BB879CD0;
      *(_OWORD *)(a3 + 46) = xmmword_1BB879CE0;
      *(_OWORD *)(a3 + 50) = xmmword_1BB879CF0;
    }
    *a4 = 54;
    if (*((void *)this + 83) - *((void *)this + 82) != 1728) {
      __assert_rtn("GetParameterList", "AUSpeechEnhancer.cpp", 311, "outNumParameters == mParameterInfoTable.size()");
    }
    return 0;
  }
}

uint64_t AUSpeechEnhancer::Render(AUSpeechEnhancer *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  v15[1] = *MEMORY[0x1E4F143B8];
  unsigned int v13 = 0;
  int v8 = (AUSpeechEnhancer *)((char *)this + 80);
  uint64_t Element = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement((AUSpeechEnhancer *)((char *)this + 80), 0);
  uint64_t result = ausdk::AUInputElement::PullInput(Element, &v13, a3, 0, a4);
  if (!result)
  {
    uint64_t v11 = ausdk::AUScope::SafeGetElement(v8, 0);
    v15[0] = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v11 + 144));
    uint64_t v12 = ausdk::AUScope::SafeGetElement((AUSpeechEnhancer *)((char *)this + 128), 0);
    uint64_t BufferList = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v12 + 144));
    return (*(uint64_t (**)(AUSpeechEnhancer *, unsigned int *, uint64_t, uint64_t, void *, uint64_t, uint64_t *))(*(void *)this + 184))(this, a2, a4, 1, v15, 1, &BufferList);
  }
  return result;
}

uint64_t AUSpeechEnhancer::ProcessMultipleBufferLists(AUSpeechEnhancer *this, unsigned int *a2, int a3, unsigned int a4, const AudioBufferList **a5, unsigned int a6, AudioBufferList **a7)
{
  if (!a3) {
    return 4294956428;
  }
  if (*((_DWORD *)this + 135) != a3) {
    return 4294956422;
  }
  unint64_t v10 = (a3 << *((unsigned char *)this + 545));
  if (*((unsigned char *)this + 544))
  {
    unint64_t v11 = *((unsigned int *)this + 133);
    if (v11)
    {
      unint64_t v12 = 0;
      uint64_t v13 = 16;
      do
      {
        unint64_t v14 = *(const void **)((char *)&(*a5)->mNumberBuffers + v13);
        uint64_t v15 = *(void **)((char *)&(*a7)->mNumberBuffers + v13);
        if (v14 != v15 && v10 != 0)
        {
          memmove(v15, v14, 4 * v10);
          unint64_t v11 = *((unsigned int *)this + 133);
        }
        ++v12;
        v13 += 16;
      }
      while (v12 < v11);
    }
    return 0;
  }
  else
  {
    int v19 = *((_DWORD *)this + 162);
    if (v19 != *((_DWORD *)this + 163))
    {
      *((_DWORD *)this + 163) = v19;
      AUSpeechEnhancer::syncParametersWithCore(this);
    }
    uint64_t v20 = *((unsigned int *)this + 133);
    if (v20)
    {
      unint64_t v21 = 0;
      uint64_t v22 = 16 * v20;
      do
      {
        uint64_t v23 = (void **)(*((void *)this + 75) + v21);
        *uint64_t v23 = (*a5)->mBuffers[v21 / 0x10].mData;
        v23[1] = (void *)v10;
        v21 += 16;
      }
      while (v22 != v21);
    }
    uint64_t v24 = *((unsigned int *)this + 134);
    if (v24)
    {
      unint64_t v25 = 0;
      uint64_t v26 = 16 * v24;
      do
      {
        float v27 = (void **)(*((void *)this + 78) + v25);
        uint64_t *v27 = (*a7)->mBuffers[v25 / 0x10].mData;
        v27[1] = (void *)v10;
        v25 += 16;
      }
      while (v26 != v25);
    }
    SpeechEnhancerCore<float>::process(*((void **)this + 74), (float ***)this + 75, (uint64_t **)this + 78, *((unsigned int *)this + 135), *((unsigned __int8 *)this + 545));
    int updated = AUSpeechEnhancer::updateMeterDisplay(this, 1u, v28);
    int v31 = AUSpeechEnhancer::updateMeterDisplay(this, 0x20u, v30);
    int v33 = AUSpeechEnhancer::updateMeterDisplay(this, 0x16u, v32);
    int v35 = AUSpeechEnhancer::updateMeterDisplay(this, 9u, v34);
    int v37 = AUSpeechEnhancer::updateMeterDisplay(this, 0xFu, v36);
    int v39 = AUSpeechEnhancer::updateMeterDisplay(this, 0x10u, v38);
    int v41 = AUSpeechEnhancer::updateMeterDisplay(this, 0x1Au, v40);
    int v43 = AUSpeechEnhancer::updateMeterDisplay(this, 0x1Bu, v42);
    unsigned int v45 = AUSpeechEnhancer::updateMeterDisplay(this, 0x17u, v44);
    uint64_t v47 = **((void **)this + 74);
    if ((unint64_t)(*(void *)(*((void *)this + 74) + 8) - v47) <= 0x190) {
      __assert_rtn("getParameter", "SpeechEnhancerCore.h", 266, "index >= 0 && index < mParameterInfoTable.size()");
    }
    uint64_t v17 = v31 | updated | v33 | v35 | v37 | v39 | v41 | v43 | v45;
    v46.n128_u32[0] = *(_DWORD *)(v47 + 412);
    if (v46.n128_f32[0] > 0.5)
    {
      for (unsigned int i = 33; i != 49; ++i)
        uint64_t v17 = AUSpeechEnhancer::updateMeterDisplay(this, i, v46) | v17;
    }
  }
  return v17;
}

float AUSpeechEnhancer::syncParametersWithCore(AUSpeechEnhancer *this)
{
  if (*((void *)this + 83) != *((void *)this + 82))
  {
    unint64_t v2 = 0;
    do
    {
      unsigned int v3 = (uint64_t *)*((void *)this + 74);
      uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUSpeechEnhancer *)((char *)this + 32), 0);
      float Parameter = ausdk::AUElement::GetParameter(Element, v2);
      SpeechEnhancerCore<float>::setParameterLight(*v3, v3[1], v2++, Parameter);
    }
    while (v2 < (uint64_t)(*((void *)this + 83) - *((void *)this + 82)) >> 5);
  }
  uint64_t v6 = *((void *)this + 74);
  int v7 = *(float **)v6;
  unint64_t v8 = *(void *)(v6 + 8) - *(void *)v6;
  if (v8 <= 0x60) {
    goto LABEL_42;
  }
  float v9 = *(float *)(v6 + 108) / (float)*(unint64_t *)(v6 + 312);
  *(float *)(v6 + 76) = expf(-1.0 / (float)(v7[27] * v9));
  if (v8 <= 0x70) {
    goto LABEL_42;
  }
  *(float *)(v6 + 64) = expf(-1.0 / (float)(v9 * v7[31]));
  if (v8 <= 0x80) {
    goto LABEL_42;
  }
  *(float *)(v6 + 68) = expf(-1.0 / (float)(v9 * v7[35]));
  long double v10 = exp(v7[23] * 0.230258509);
  *(float *)&long double v10 = v10;
  *(_DWORD *)(v6 + 72) = LODWORD(v10);
  *(void *)(v6 + 32) = (unint64_t)(float)(v7[19] + 0.5);
  *(float *)&long double v10 = v7[15] + 0.5;
  *(void *)(v6 + 24) = (unint64_t)*(float *)&v10;
  SpeechEnhancerFilterBank<float>::createFilterBank(v6 + 1192, (unint64_t)*(float *)&v10, v10);
  std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)(v6 + 864), *(char **)(v6 + 1248), *(void *)(v6 + 1256), (uint64_t)(*(void *)(v6 + 1256) - *(void *)(v6 + 1248)) >> 2);
  if (*(void *)(v6 + 8) - *(void *)v6 <= 0x120uLL) {
    goto LABEL_42;
  }
  uint64_t v11 = *(void *)(v6 + 1224);
  unint64_t v12 = (*(void *)(v6 + 1232) - v11) >> 2;
  if (*(void *)(v6 + 1232) == v11)
  {
LABEL_14:
    unint64_t v13 = (*(void *)(v6 + 1232) - v11) >> 2;
  }
  else
  {
    unint64_t v13 = 0;
    uint64_t v14 = v12 <= 1 ? 1 : (*(void *)(v6 + 1232) - v11) >> 2;
    while (*(float *)(v11 + 4 * v13) <= *(float *)(*(void *)v6 + 300))
    {
      if (v14 == ++v13) {
        goto LABEL_14;
      }
    }
  }
  if (v12 >= v13) {
    unint64_t v12 = v13;
  }
  *(void *)(v6 + 1192) = v12;
  SpeechEnhancerFilterBank<float>::calculateBandImportance(v6 + 1192);
  vDSP_Length v15 = *(void *)(v6 + 1192);
  *(void *)(v6 + 40) = v15;
  uint64_t v16 = *(float **)v6;
  if (*(void *)(v6 + 8) - *(void *)v6 <= 0x330uLL) {
    goto LABEL_42;
  }
  *(float *)(v6 + 168) = v16[207];
  *(float *)(v6 + 172) = v16[199];
  *(float *)(v6 + 176) = v16[203];
  float __C = 0.0;
  vDSP_maxv(*(const float **)(v6 + 1296), 1, &__C, v15);
  float v17 = logf(1.0 - *(float *)(v6 + 200));
  vDSP_Length v18 = *(void *)(v6 + 40);
  if (v18)
  {
    uint64_t v19 = 0;
    uint64_t v20 = *(void *)(v6 + 1296);
    unint64_t v21 = *(const float **)(v6 + 696);
    float v22 = v17 / __C;
    do
    {
      v21[v19] = 1.0 - expf(v22 * *(float *)(v20 + 4 * v19));
      ++v19;
    }
    while (v18 != v19);
  }
  else
  {
    unint64_t v21 = *(const float **)(v6 + 696);
  }
  vDSP_vneg(v21, 1, *(float **)(v6 + 720), 1, v18);
  float __B = 1.0;
  vDSP_vsadd(*(const float **)(v6 + 720), 1, &__B, *(float **)(v6 + 744), 1, *(void *)(v6 + 40));
  float v41 = 2.0;
  vDSP_vsadd(*(const float **)(v6 + 720), 1, &v41, *(float **)(v6 + 720), 1, *(void *)(v6 + 40));
  int v40 = 1056964608;
  vDSP_vsmul(*(const float **)(v6 + 696), 1, (const float *)&v40, *(float **)(v6 + 768), 1, *(void *)(v6 + 40));
  vDSP_vmul(*(const float **)(v6 + 768), 1, *(const float **)(v6 + 864), 1, *(float **)(v6 + 768), 1, *(void *)(v6 + 40));
  if (*(void *)(v6 + 8) - *(void *)v6 <= 0x130uLL) {
    goto LABEL_42;
  }
  float v23 = exp(*(float *)(*(void *)v6 + 316) * 0.230258509);
  *(float *)(v6 + 80) = v23;
  *(float *)(v6 + 84) = 1.0 / v23;
  vDSP_vsmul(*(const float **)(v6 + 744), 1, (const float *)(v6 + 80), *(float **)(v6 + 792), 1, *(void *)(v6 + 40));
  float __C = 1.0;
  vDSP_svdiv(&__C, *(const float **)(v6 + 792), 1, *(float **)(v6 + 792), 1, *(void *)(v6 + 40));
  vDSP_vsmsa(*(const float **)(v6 + 744), 1, (const float *)(v6 + 80), (const float *)(v6 + 84), *(float **)(v6 + 816), 1, *(void *)(v6 + 40));
  vDSP_vadd(*(const float **)(v6 + 720), 1, *(const float **)(v6 + 816), 1, *(float **)(v6 + 816), 1, *(void *)(v6 + 40));
  vDSP_vdiv(*(const float **)(v6 + 816), 1, *(const float **)(v6 + 768), 1, *(float **)(v6 + 816), 1, *(void *)(v6 + 40));
  uint64_t v24 = *(float **)v6;
  unint64_t v25 = *(void *)(v6 + 8) - *(void *)v6;
  if (*(void *)(v6 + 24))
  {
    if (v25 > 0x1E0)
    {
      unint64_t v26 = *(void *)(v6 + 328);
      unint64_t v27 = vcvtas_u32_f32(v24[123] / (float)(*(float *)(v6 + 108) / (float)*(unint64_t *)(v6 + 320)));
      goto LABEL_27;
    }
LABEL_42:
    __assert_rtn("parameterValue", "SpeechEnhancerCore.h", 278, "index >= 0 && index < mParameterInfoTable.size()");
  }
  if (v25 <= 0x1E0) {
    goto LABEL_42;
  }
  uint64_t v28 = *(void *)(v6 + 1224);
  unint64_t v26 = (*(void *)(v6 + 1232) - v28) >> 2;
  if (*(void *)(v6 + 1232) == v28)
  {
    unint64_t v27 = *(void *)(v6 + 40);
LABEL_27:
    if (v26 >= v27) {
      unint64_t v26 = v27;
    }
    goto LABEL_40;
  }
  unint64_t v29 = 0;
  if (v26 <= 1) {
    uint64_t v30 = 1;
  }
  else {
    uint64_t v30 = (*(void *)(v6 + 1232) - v28) >> 2;
  }
  while (*(float *)(v28 + 4 * v29) <= v24[123])
  {
    if (v30 == ++v29)
    {
      unint64_t v29 = (*(void *)(v6 + 1232) - v28) >> 2;
      break;
    }
  }
  unint64_t v26 = *(void *)(v6 + 40);
  if (v29 < v26) {
    unint64_t v26 = v29;
  }
LABEL_40:
  *(void *)(v6 + 56) = v26;
  float v31 = exp(v24[83] * 0.230258509);
  *(float *)(v6 + 92) = v31;
  float v32 = exp(v24[115] * 0.230258509);
  *(float *)(v6 + 96) = v32;
  float v33 = exp(v24[87] * 0.230258509);
  *(float *)(v6 + 100) = v33;
  float v34 = exp(v24[119] * 0.230258509);
  *(float *)(v6 + 104) = v34;
  float result = v24[43];
  int v36 = *((_DWORD *)v24 + 47);
  int v37 = *((_DWORD *)v24 + 51);
  int v38 = *((_DWORD *)v24 + 55);
  int v39 = *((_DWORD *)v24 + 59);
  *(float *)(v6 + 1396) = result;
  *(_DWORD *)(v6 + 1400) = v36;
  *(_DWORD *)(v6 + 1404) = v37;
  *(_DWORD *)(v6 + 1408) = v38;
  *(_DWORD *)(v6 + 1412) = v39;
  *(unsigned char *)(v6 + 355) = 1;
  *(_WORD *)(v6 + 353) = 257;
  *(void *)(v6 + 344) = *(void *)(v6 + 48);
  return result;
}

void SpeechEnhancerCore<float>::process(void *a1, float ***a2, uint64_t **a3, unint64_t a4, uint64_t a5)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *a2;
  uint64_t v5 = a2[1];
  float v59 = a2;
  uint64_t v7 = ((char *)v5 - (char *)v6) >> 4;
  if (v7 != a1[42]) {
    __assert_rtn("process", "SpeechEnhancerCore.h", 288, "input.size() == mNumChannels");
  }
  unint64_t v8 = *a3;
  if (v7 != ((char *)a3[1] - (char *)*a3) >> 4) {
    __assert_rtn("process", "SpeechEnhancerCore.h", 289, "output.size() == mNumChannels");
  }
  if (a1[39] != a4) {
    __assert_rtn("process", "SpeechEnhancerCore.h", 290, "numFrames == mBlockSize");
  }
  unint64_t v10 = (unint64_t)v6[1];
  unint64_t v58 = a4;
  uint64_t v56 = a5;
  if (a5)
  {
    if (v10 >= 2 * a4)
    {
      if (v8[1] >= 2 * a4)
      {
        float v57 = &v55;
        MEMORY[0x1F4188790](a1);
        unint64_t v12 = (DSPSplitComplex *)(&v55 - 2 * v11);
        MEMORY[0x1F4188790](v13);
        uint64_t v16 = &v55 - 2 * v15;
        if (v15)
        {
          float v17 = *v59;
          uint64_t v18 = a1[39];
          uint64_t v19 = v16 + 1;
          p_imagp = &v12->imagp;
          unint64_t v21 = *v14;
          do
          {
            float v22 = *v17;
            v17 += 2;
            *(p_imagp - 1) = v22;
            *p_imagp = &v22[v18];
            p_imagp += 2;
            uint64_t v23 = *v21;
            v21 += 2;
            *(v19 - 1) = v23;
            *uint64_t v19 = v23 + 4 * v18;
            v19 += 2;
            --v15;
          }
          while (v15);
        }
        uint64_t v24 = v14;
        uint64_t v25 = SpeechEnhancerCore<float>::processCore((uint64_t)a1, v12);
        if (a1[42])
        {
          unint64_t v26 = (const float **)v25;
          unint64_t v27 = 0;
          uint64_t v28 = (float **)(v16 + 1);
          unint64_t v29 = &v12->imagp;
          do
          {
            uint64_t v30 = *v26;
            float v31 = *v29;
            float v32 = **v29;
            vDSP_Length v33 = a1[41] - 1;
            vDSP_vmul(*(v29 - 1), 1, *v26, 1, *(v28 - 1), 1, v33);
            float v34 = *v28;
            v28 += 2;
            vDSP_vmul(v31, 1, v30, 1, v34, 1, v33);
            *float v34 = v32 * v30[v33];
            ++v27;
            v29 += 2;
          }
          while (a1[42] > v27);
        }
        goto LABEL_22;
      }
LABEL_34:
      __assert_rtn("process", "SpeechEnhancerCore.h", 292, "isFrequencyDomain ? (output[0].size() >= 2 * numFrames) : (output[0].size() >= numFrames)");
    }
LABEL_33:
    __assert_rtn("process", "SpeechEnhancerCore.h", 291, "isFrequencyDomain ? (input[0].size() >= 2 * numFrames) : (input[0].size() >= numFrames)");
  }
  if (v10 < a4) {
    goto LABEL_33;
  }
  if (v8[1] < a4) {
    goto LABEL_34;
  }
  uint64_t v24 = a3;
  float v57 = &v55;
  MEMORY[0x1F4188790](a1);
  int v36 = (DSPSplitComplex *)(&v55 - 2 * v35);
  if (a1[42])
  {
    uint64_t v37 = 0;
    unint64_t v38 = 0;
    unint64_t v39 = 0;
    do
    {
      int v40 = *(float **)(a1[138] + v37);
      float v41 = &v36[v38 / 0x10];
      v41->realp = *(float **)(a1[135] + v37);
      v41->imagp = v40;
      VPTimeFreqConverter::Analyze(*(VPTimeFreqConverter **)(a1[186] + 8 * v39++), (*v59)[v38 / 8], &v36[v38 / 0x10]);
      v38 += 16;
      v37 += 24;
    }
    while (a1[42] > v39);
  }
  uint64_t v42 = SpeechEnhancerCore<float>::processCore((uint64_t)a1, v36);
  if (a1[42])
  {
    int v43 = (const float **)v42;
    unint64_t v44 = 0;
    unint64_t v45 = 0;
    do
    {
      __n128 v46 = *v43;
      uint64_t v47 = (const float **)&v36[v44 / 2].imagp;
      float v48 = **v47;
      vDSP_Length v49 = a1[41] - 1;
      vDSP_vmul(v36[v44 / 2].realp, 1, *v43, 1, v36[v44 / 2].realp, 1, v49);
      vDSP_vmul(*v47, 1, v46, 1, (float *)*v47, 1, v49);
      *(float *)char *v47 = v48 * v46[v49];
      VPTimeFreqConverter::Synthesize(*(VPTimeFreqConverter **)(a1[189] + 8 * v45++), &v36[v44 / 2], (float *)(*v24)[v44]);
      v44 += 2;
    }
    while (a1[42] > v45);
  }
LABEL_22:
  unint64_t v50 = v58;
  if (a1[1] == *a1) {
    __assert_rtn("parameterValue", "SpeechEnhancerCore.h", 278, "index >= 0 && index < mParameterInfoTable.size()");
  }
  if (*(float *)(*a1 + 12) > 0.5)
  {
    unint64_t v51 = a1[42];
    if (v51)
    {
      uint64_t v52 = 0;
      unint64_t v53 = 0;
      size_t v54 = 4 * (v58 << v56);
      do
      {
        if (v50)
        {
          memmove((void *)(*v24)[v52], (*v59)[v52], v54);
          unint64_t v51 = a1[42];
        }
        ++v53;
        v52 += 2;
      }
      while (v51 > v53);
    }
  }
  ++a1[6];
}

uint64_t AUSpeechEnhancer::updateMeterDisplay(AUSpeechEnhancer *this, unsigned int a2, __n128 a3)
{
  uint64_t v3 = **((void **)this + 74);
  if (a2 >= (unint64_t)((*(void *)(*((void *)this + 74) + 8) - v3) >> 4)) {
    __assert_rtn("getParameter", "SpeechEnhancerCore.h", 266, "index >= 0 && index < mParameterInfoTable.size()");
  }
  a3.n128_u32[0] = *(_DWORD *)(v3 + 16 * a2 + 12);
  unsigned int v4 = *(uint64_t (**)(__n128))(*(void *)this + 152);

  return v4(a3);
}

uint64_t SpeechEnhancerCore<float>::processCore(uint64_t a1, DSPSplitComplex *a2)
{
  unint64_t v2 = *(float **)a1;
  unint64_t v3 = *(void *)(a1 + 8) - *(void *)a1;
  if (v3 <= 0x10) {
    goto LABEL_163;
  }
  if (v2[7] <= 0.5)
  {
    if (v3 <= 0x350) {
      goto LABEL_163;
    }
    if (v2[211] >= v2[215]) {
      goto LABEL_21;
    }
    float v6 = exp((float)(*(float *)(a1 + 176) / (float)(*(float *)(a1 + 108) / (float)*(unint64_t *)(a1 + 312)))* 0.230258509);
    *(float *)&__B.realp = v6;
    vDSP_vsmul(*(const float **)(a1 + 936), 1, (const float *)&__B, *(float **)(a1 + 360), 1, *(void *)(a1 + 328));
    float v7 = *(float *)(a1 + 64);
    float v8 = *(float *)(a1 + 68);
    float __D = 1.0 - v7;
    __C[0] = v7;
    float v120 = 1.0 - v8;
    float v121 = v8;
    float v9 = (float)*(unint64_t *)(a1 + 48);
    float v10 = *(float *)(a1 + 108) / (float)*(unint64_t *)(a1 + 312);
    float v11 = *(float *)(a1 + 224);
    if ((float)(v9 / v10) < v11)
    {
      float v119 = 1.0 - expf((float)((float)(-3.0 / v11) * v9) / v10);
      vDSP_vsmul(*(const float **)(a1 + 648), 1, &v119, *(float **)(a1 + 648), 1, *(void *)(a1 + 328));
    }
    unint64_t v12 = *(float **)(a1 + 936);
    uint64_t v13 = *(const float **)(a1 + 648);
    if (v7 == v8)
    {
      vDSP_vsmsma(v12, 1, __C, v13, 1, &__D, v12, 1, *(void *)(a1 + 328));
    }
    else
    {
      vDSP_vsmsma(v12, 1, __C, v13, 1, &__D, *(float **)(a1 + 984), 1, *(void *)(a1 + 328));
      vDSP_vsmsma(*(const float **)(a1 + 936), 1, &v121, *(const float **)(a1 + 648), 1, &v120, *(float **)(a1 + 1008), 1, *(void *)(a1 + 328));
      uint64_t v14 = *(void *)(a1 + 328);
      if (v14)
      {
        uint64_t v15 = 0;
        uint64_t v16 = *(void *)(a1 + 648);
        uint64_t v17 = *(void *)(a1 + 936);
        do
        {
          if (*(float *)(v16 + 4 * v15) <= *(float *)(v17 + 4 * v15)) {
            uint64_t v18 = (void *)(a1 + 1008);
          }
          else {
            uint64_t v18 = (void *)(a1 + 984);
          }
          *(_DWORD *)(v17 + 4 * v15) = *(_DWORD *)(*v18 + 4 * v15);
          ++v15;
        }
        while (v14 != v15);
      }
    }
    float v19 = (float)*(unint64_t *)(a1 + 48) / (float)(*(float *)(a1 + 108) / (float)*(unint64_t *)(a1 + 312));
    if (v19 > *(float *)(a1 + 224))
    {
      if (*(void *)(a1 + 8) - *(void *)a1 <= 0x70uLL) {
        goto LABEL_163;
      }
      if (v19 > (float)(*(float *)(*(void *)a1 + 124) * 3.0)) {
        vDSP_vmin(*(const float **)(a1 + 936), 1, *(const float **)(a1 + 360), 1, *(float **)(a1 + 936), 1, *(void *)(a1 + 328));
      }
    }
    vDSP_vclip(*(const float **)(a1 + 936), 1, (const float *)(a1 + 160), (const float *)(a1 + 164), *(float **)(a1 + 936), 1, *(void *)(a1 + 328));
    unint64_t v2 = *(float **)a1;
    unint64_t v3 = *(void *)(a1 + 8) - *(void *)a1;
  }
  if (v3 <= 0x180) {
    goto LABEL_163;
  }
LABEL_21:
  if (v2[99] <= 0.5)
  {
    uint64_t v25 = *(float **)(a1 + 1032);
    vDSP_Length v26 = *(void *)(a1 + 312);
    DSPSplitComplex __B = *a2;
    vDSP_zvmags(&__B, 1, v25, 1, v26);
    (*(void (**)(void, void, void, void))(**(void **)(a1 + 1480) + 24))(*(void *)(a1 + 1480), *(void *)(a1 + 1032), *(void *)(a1 + 1056), *(unsigned int *)(a1 + 328));
    vDSP_vsub(*(const float **)(a1 + 1056), 1, *(const float **)(a1 + 1032), 1, *(float **)(a1 + 1032), 1, *(void *)(a1 + 328));
    vDSP_vthr(*(const float **)(a1 + 1032), 1, &AlgorithmUtils::kepsf, *(float **)(a1 + 1032), 1, *(void *)(a1 + 328));
    unint64_t v27 = *(_DWORD **)(a1 + 1032);
    _DWORD *v27 = 0;
    uint64_t v28 = *(void *)(a1 + 328);
    v27[v28 - 1] = 0;
    if (v28)
    {
      memmove(*(void **)(a1 + 360), v27, 4 * v28);
      vDSP_Length v29 = *(void *)(a1 + 328);
    }
    else
    {
      vDSP_Length v29 = 0;
    }
    LODWORD(__B.realp) = 0;
    vDSP_sve(*(const float **)(*(void *)(a1 + 1480) + 112), 1, (float *)&__B, v29);
    if (*(void *)(a1 + 8) - *(void *)a1 <= 0x20uLL) {
      goto LABEL_163;
    }
    vDSP_Length __N = *(void *)(a1 + 328);
    if ((float)(*(float *)&__B.realp / (float)__N) > *(float *)(*(void *)a1 + 44))
    {
      __C[0] = 1.0 - *(float *)(a1 + 76);
      vDSP_vsmsma(*(const float **)(a1 + 912), 1, (const float *)(a1 + 76), *(const float **)(a1 + 360), 1, __C, *(float **)(a1 + 912), 1, __N);
      vDSP_Length __N = *(void *)(a1 + 328);
    }
    vDSP_vsmul(*(const float **)(a1 + 912), 1, (const float *)(a1 + 72), *(float **)(a1 + 672), 1, __N);
    float v34 = *(const float **)(a1 + 672);
    p_B = (const float *)(a1 + 140);
    vDSP_Length v36 = *(void *)(a1 + 328);
    uint64_t v35 = (float *)v34;
  }
  else
  {
    uint64_t v20 = *(float **)(a1 + 1032);
    vDSP_Length v21 = *(void *)(a1 + 312);
    DSPSplitComplex __B = *a2;
    vDSP_zvmags(&__B, 1, v20, 1, v21);
    float v22 = *(_DWORD **)(a1 + 1032);
    *float v22 = 0;
    uint64_t v23 = *(void *)(a1 + 328);
    v22[v23 - 1] = 0;
    if (v23)
    {
      memmove(*(void **)(a1 + 360), v22, 4 * v23);
      vDSP_Length v24 = *(void *)(a1 + 328);
    }
    else
    {
      vDSP_Length v24 = 0;
    }
    vDSP_vsmul(*(const float **)(a1 + 360), 1, (const float *)(a1 + 72), *(float **)(a1 + 360), 1, v24);
    vDSP_sve(*(const float **)(a1 + 360), 1, (float *)(a1 + 136), *(void *)(a1 + 328));
    float v31 = *(float *)(a1 + 136);
    float v30 = *(float *)(a1 + 140);
    float v32 = exp(*(float *)(a1 + 196) * 0.230258509);
    if ((float)(v31 * v30) <= v32)
    {
      float v33 = *(float *)(a1 + 132);
    }
    else
    {
      float v33 = (float)(v31 * (float)(1.0 - *(float *)(a1 + 76))) + (float)(*(float *)(a1 + 76) * *(float *)(a1 + 132));
      *(float *)(a1 + 132) = v33;
    }
    *(float *)&__B.realp = (float)(v30 * v33) / 10000000.0;
    float v34 = *(const float **)(a1 + 960);
    uint64_t v35 = *(float **)(a1 + 672);
    vDSP_Length v36 = *(void *)(a1 + 328);
    p_B = (const float *)&__B;
  }
  vDSP_vsmul(v34, 1, p_B, v35, 1, v36);
  float v39 = SPLMeter<float,AWeight>::process<std::vector<float>>(a1 + 1448, *(const float **)(a1 + 672), *(void *)(a1 + 680));
  float v40 = SPLMeter<float,AWeight>::process<std::vector<float>>(a1 + 1448, *(const float **)(a1 + 936), *(void *)(a1 + 944));
  *(float *)(a1 + 148) = v40;
  *(float *)(a1 + 128) = v39 - v40;
  if (vabds_f32(v40, *(float *)(a1 + 152)) > *(float *)(a1 + 208)
    || vabds_f32(v39, *(float *)(a1 + 156)) > *(float *)(a1 + 204)
    || *(float *)(a1 + 140) != *(float *)(a1 + 144))
  {
    *(unsigned char *)(a1 + 353) = 1;
    *(void *)(a1 + 344) = *(void *)(a1 + 48);
    *(float *)(a1 + 152) = v40;
    *(float *)(a1 + 156) = v39;
    *(_DWORD *)(a1 + 144) = *(_DWORD *)(a1 + 140);
    goto LABEL_40;
  }
  float v46 = *(float *)(a1 + 108) / (float)*(unint64_t *)(a1 + 312);
  if ((float)((float)(unint64_t)(*(void *)(a1 + 48) - *(void *)(a1 + 344)) / v46) <= *(float *)(a1 + 212))
  {
    if (*(unsigned char *)(a1 + 353)) {
      goto LABEL_40;
    }
  }
  else
  {
    *(unsigned char *)(a1 + 353) = 0;
  }
  if (!*(unsigned char *)(a1 + 354))
  {
    float v49 = *(float *)(a1 + 112);
    goto LABEL_69;
  }
LABEL_40:
  if (*(void *)(a1 + 8) - *(void *)a1 <= 0x1A0uLL) {
    goto LABEL_163;
  }
  float v41 = *(float *)(*(void *)a1 + 428);
  if (*(unsigned char *)(a1 + 1436))
  {
    float v42 = *(float *)(a1 + 1396);
  }
  else
  {
    *(float *)(a1 + 1432) = v41;
    *(float *)(a1 + 1424) = v41;
    float v42 = *(float *)(a1 + 1396);
    *(float *)(a1 + 1428) = v42;
    *(_WORD *)(a1 + 1436) = 1;
  }
  if (v42 > v40)
  {
    *(float *)(a1 + 1432) = v41;
    *(unsigned char *)(a1 + 1437) = 0;
    goto LABEL_46;
  }
  if (!*(unsigned char *)(a1 + 1437)) {
    goto LABEL_50;
  }
  if (*(float *)(a1 + 1440) > v40)
  {
    *(unsigned char *)(a1 + 1437) = 0;
LABEL_50:
    uint64_t v44 = 1404;
    if (*(float *)(a1 + 1400) < v40) {
      uint64_t v44 = 1408;
    }
    float v43 = (float)(*(float *)(a1 + 1432) + (float)(*(float *)(a1 + v44) * (float)(v40 - *(float *)(a1 + 1428))))
        + (float)(v41 - *(float *)(a1 + 1424));
    *(float *)(a1 + 1432) = v43;
    if (v43 > *(float *)(a1 + 1412))
    {
      *(unsigned char *)(a1 + 1437) = 1;
      *(float *)(a1 + 1440) = v40;
    }
    goto LABEL_59;
  }
  float v45 = *(float *)(a1 + 1424);
  if (v45 <= v41)
  {
    float v43 = *(float *)(a1 + 1432);
  }
  else
  {
    float v43 = (float)(v41 - v45) + *(float *)(a1 + 1432);
    *(float *)(a1 + 1432) = v43;
    *(unsigned char *)(a1 + 1437) = 0;
  }
LABEL_59:
  float v47 = *(float *)(a1 + 1412);
  if (v43 > v47)
  {
    *(float *)(a1 + 1432) = v47;
    float v43 = v47;
    goto LABEL_63;
  }
  if (v43 >= v41) {
    goto LABEL_63;
  }
  *(float *)(a1 + 1432) = v41;
LABEL_46:
  float v43 = v41;
LABEL_63:
  *(float *)(a1 + 1424) = v41;
  *(float *)(a1 + 1428) = v40;
  float v48 = v43 - v41;
  if ((float)(v43 - v41) > *(float *)(a1 + 1392)) {
    float v48 = *(float *)(a1 + 1392);
  }
  if ((LODWORD(v48) & 0x7FFFFFFFu) >= 0x7F800000) {
    float v49 = 0.0;
  }
  else {
    float v49 = v48;
  }
  *(float *)(a1 + 1420) = v49;
  *(float *)(a1 + 112) = v49;
  float v46 = *(float *)(a1 + 108) / (float)*(unint64_t *)(a1 + 312);
LABEL_69:
  float v50 = *(float *)(a1 + 116);
  float v51 = *(float *)(a1 + 168) / v46;
  if ((float)(v49 - v50) <= v51)
  {
    char v52 = 0;
  }
  else
  {
    float v49 = v50 + v51;
    *(float *)(a1 + 112) = v50 + v51;
    char v52 = 1;
  }
  float v53 = exp(v49 * 0.230258509);
  *(float *)(a1 + 120) = v53;
  *(unsigned char *)(a1 + 354) = v52;
  *(float *)(a1 + 116) = v49;
  float v54 = exp(v49 * 0.115129255);
  *(float *)(a1 + 124) = v54;
  uint64_t v55 = (vDSP_Length *)(a1 + 328);
  vDSP_vsmul(*(const float **)(a1 + 672), 1, (const float *)(a1 + 120), *(float **)(a1 + 672), 1, *(void *)(a1 + 328));
  if (*(void *)(a1 + 48) % *(void *)(a1 + 240)) {
    goto LABEL_99;
  }
  float v56 = SPLMeter<float,AWeight>::process<std::vector<float>>(a1 + 1448, *(const float **)(a1 + 672), *(void *)(a1 + 680));
  vDSP_mmul(*(const float **)(a1 + 1344), 1, *(const float **)(a1 + 672), 1, *(float **)(a1 + 384), 1, *(void *)(a1 + 1192), 1uLL, *(void *)(a1 + 328));
  vDSP_mmul(*(const float **)(a1 + 1344), 1, *(const float **)(a1 + 936), 1, *(float **)(a1 + 408), 1, *(void *)(a1 + 1192), 1uLL, *(void *)(a1 + 328));
  float v57 = *(float **)a1;
  if (*(void *)(a1 + 8) - *(void *)a1 <= 0x1F0uLL) {
    goto LABEL_163;
  }
  unint64_t v58 = (float **)(a1 + 360);
  if (*(float *)(a1 + 148) < v57[127] || v57[71] > 0.5)
  {
    LODWORD(__B.realp) = 1065353216;
    vDSP_vfill((const float *)&__B, *(float **)(a1 + 360), 1, *(void *)(a1 + 328));
    vDSP_vfill((const float *)&__B, *(float **)(a1 + 888), 1, *(void *)(a1 + 328));
LABEL_77:
    unint64_t v59 = 0;
    goto LABEL_78;
  }
  if (!*(unsigned char *)(a1 + 353) && !*(unsigned char *)(a1 + 354) && !*(unsigned char *)(a1 + 355))
  {
    if (*v55) {
      memmove(*(void **)(a1 + 360), *(const void **)(a1 + 888), 4 * *v55);
    }
    goto LABEL_77;
  }
  uint64_t v111 = (unint64_t *)(a1 + 1192);
  LODWORD(__B.realp) = 0;
  uint64_t v86 = 40;
  if (*(void *)(a1 + 24) == 1) {
    uint64_t v86 = 328;
  }
  uint64_t v87 = 384;
  if (*(void *)(a1 + 24) == 1) {
    uint64_t v87 = 672;
  }
  BOOL v88 = 1;
  vDSP_sve(*(const float **)(a1 + v87), 1, (float *)&__B, *(void *)(a1 + v86));
  int v89 = (vDSP_Length *)(a1 + 40);
  vDSP_vma(*(const float **)(a1 + 408), 1, *(const float **)(a1 + 792), 1, *(const float **)(a1 + 384), 1, *(float **)(a1 + 432), 1, *(void *)(a1 + 40));
  vDSP_vsma(*(const float **)(a1 + 384), 1, (const float *)(a1 + 84), *(const float **)(a1 + 408), 1, *(float **)(a1 + 408), 1, *(void *)(a1 + 40));
  __C[0] = 0.0;
  vDSP_sve(*(const float **)(a1 + 432), 1, __C, *(void *)(a1 + 40));
  float __D = 1.0 / (float)(__C[0] + 2.2204e-16);
  vDSP_vsmul(*(const float **)(a1 + 432), 1, &__D, *(float **)(a1 + 432), 1, *(void *)(a1 + 40));
  vDSP_vsmul(*(const float **)(a1 + 408), 1, &__D, *(float **)(a1 + 408), 1, *(void *)(a1 + 40));
  vDSP_vmul(*(const float **)(a1 + 432), 1, *(const float **)(a1 + 408), 1, *(float **)(a1 + 456), 1, *(void *)(a1 + 40));
  vDSP_vsq(*(const float **)(a1 + 432), 1, *(float **)(a1 + 480), 1, *(void *)(a1 + 40));
  vDSP_vsq(*(const float **)(a1 + 408), 1, *(float **)(a1 + 408), 1, *(void *)(a1 + 40));
  float v90 = v56 - *(float *)(a1 + 148);
  float v91 = v90 * (float)(1.0 / (float)(log10f(*(float *)(a1 + 80) + 2.2204e-16) * 10.0));
  if (v91 < 0.0) {
    float v91 = 0.0;
  }
  if (v91 > 1.0) {
    float v91 = 1.0;
  }
  float v121 = v91;
  vDSP_vsmul(*(const float **)(a1 + 816), 1, &v121, *(float **)(a1 + 840), 1, *v89);
  vDSP_vneg(*(const float **)(a1 + 840), 1, *(float **)(a1 + 840), 1, *v89);
  float v119 = 0.0;
  float v120 = 0.0;
  vDSP_Length v92 = *v89;
  if (*v89)
  {
    float v93 = *(float **)(a1 + 408);
    if (*v93 <= 2.2204e-16 || (uint64_t v94 = *(float **)(a1 + 432), *v94 <= 2.2204e-16))
    {
      BOOL v88 = 0;
    }
    else
    {
      vDSP_Length v95 = 0;
      uint64_t v96 = 1;
      while (1)
      {
        if (v92 == v96)
        {
          vDSP_Length v97 = *v89;
          goto LABEL_137;
        }
        vDSP_Length v97 = v96;
        ++v95;
        if (v93[v96] <= 2.2204e-16) {
          break;
        }
        float v98 = v94[v96++];
        if (v98 <= 2.2204e-16) {
          goto LABEL_137;
        }
      }
      vDSP_Length v97 = v95;
LABEL_137:
      BOOL v88 = v92 <= v97;
    }
  }
  *(unsigned char *)(a1 + 352) = v88;
  unint64_t v59 = 0;
  if ((float)(*(float *)(a1 + 184) * *(float *)&__B.realp) < INFINITY)
  {
    unint64_t v112 = (const float *)(a1 + 100);
    unsigned int v113 = (const float *)(a1 + 92);
    float v99 = 0.0;
    float v100 = -1000000.0;
    do
    {
      if (v59 > *(void *)(a1 + 232)) {
        break;
      }
      float v120 = (float)(v99 + v100) * 0.5;
      vDSP_vsma(*(const float **)(a1 + 432), 1, &v120, *(const float **)(a1 + 840), 1, *(float **)(a1 + 504), 1, *(void *)(a1 + 40));
      vDSP_vmul(*(const float **)(a1 + 408), 1, *(const float **)(a1 + 504), 1, *(float **)(a1 + 528), 1, *(void *)(a1 + 40));
      vDSP_vma(*(const float **)(a1 + 456), 1, *(const float **)(a1 + 768), 1, *(const float **)(a1 + 528), 1, *(float **)(a1 + 528), 1, *(void *)(a1 + 40));
      vDSP_vmul(*(const float **)(a1 + 504), 1, *(const float **)(a1 + 456), 1, *(float **)(a1 + 576), 1, *(void *)(a1 + 40));
      vDSP_vmul(*(const float **)(a1 + 576), 1, *(const float **)(a1 + 720), 1, *(float **)(a1 + 576), 1, *(void *)(a1 + 40));
      vDSP_vmul(*(const float **)(a1 + 504), 1, *(const float **)(a1 + 480), 1, *(float **)(a1 + 552), 1, *(void *)(a1 + 40));
      vDSP_vmul(*(const float **)(a1 + 552), 1, *(const float **)(a1 + 744), 1, *(float **)(a1 + 552), 1, *(void *)(a1 + 40));
      vDSP_vmul(*(const float **)(a1 + 552), 1, *(const float **)(a1 + 528), 1, *(float **)(a1 + 504), 1, *(void *)(a1 + 40));
      float v118 = 4.0;
      vDSP_vsmul(*(const float **)(a1 + 504), 1, &v118, *(float **)(a1 + 504), 1, *(void *)(a1 + 40));
      vDSP_vsq(*(const float **)(a1 + 576), 1, *(float **)(a1 + 552), 1, *(void *)(a1 + 40));
      vDSP_vsub(*(const float **)(a1 + 504), 1, *(const float **)(a1 + 552), 1, *(float **)(a1 + 504), 1, *(void *)(a1 + 40));
      float v117 = 0.0;
      vDSP_vthr(*(const float **)(a1 + 504), 1, &v117, *(float **)(a1 + 504), 1, *(void *)(a1 + 40));
      int v116 = *(void *)(a1 + 40);
      vvsqrtf(*(float **)(a1 + 504), *(const float **)(a1 + 504), &v116);
      vDSP_vsub(*(const float **)(a1 + 576), 1, *(const float **)(a1 + 504), 1, *(float **)(a1 + 504), 1, *(void *)(a1 + 40));
      vDSP_vdiv(*(const float **)(a1 + 504), 1, *(const float **)(a1 + 528), 1, *(float **)(a1 + 504), 1, *(void *)(a1 + 40));
      float v115 = 2.0;
      vDSP_vsmul(*(const float **)(a1 + 504), 1, &v115, *(float **)(a1 + 504), 1, *(void *)(a1 + 40));
      vDSP_Length v101 = *(void *)(a1 + 40);
      if (!*(unsigned char *)(a1 + 352) && v101)
      {
        uint64_t v102 = 0;
        uint64_t v103 = *(void *)(a1 + 408);
        do
        {
          if (*(float *)(v103 + 4 * v102) <= 2.2204e-16 || *(float *)(*(void *)(a1 + 432) + 4 * v102) <= 2.2204e-16) {
            *(_DWORD *)(*(void *)(a1 + 504) + 4 * v102) = 1065353216;
          }
          ++v102;
        }
        while (v101 != v102);
      }
      vDSP_vthr(*(const float **)(a1 + 504), 1, &v117, *(float **)(a1 + 504), 1, v101);
      if (*(void *)(a1 + 24) == 1)
      {
        SpeechEnhancerFilterBank<float>::convertFilterBankToLinear(v111, *(float **)(a1 + 504), *(void *)(a1 + 360), *(void *)(a1 + 32));
        vDSP_vclip(*(const float **)(a1 + 360), 1, v113, v112, *(float **)(a1 + 360), 1, *(void *)(a1 + 56));
        vDSP_vclip((const float *)(*(void *)(a1 + 360) + 4 * *(void *)(a1 + 56)), 1, (const float *)(a1 + 96), (const float *)(a1 + 104), (float *)(*(void *)(a1 + 360) + 4 * *(void *)(a1 + 56)), 1, *(void *)(a1 + 328) - *(void *)(a1 + 56));
        unint64_t v104 = (const float **)(a1 + 360);
        unint64_t v105 = (const float **)(a1 + 672);
        uint64_t v106 = (vDSP_Length *)(a1 + 328);
      }
      else
      {
        vDSP_vclip(*(const float **)(a1 + 504), 1, v113, v112, *(float **)(a1 + 504), 1, *(void *)(a1 + 56));
        vDSP_vclip((const float *)(*(void *)(a1 + 504) + 4 * *(void *)(a1 + 56)), 1, (const float *)(a1 + 96), (const float *)(a1 + 104), (float *)(*(void *)(a1 + 504) + 4 * *(void *)(a1 + 56)), 1, *(void *)(a1 + 40) - *(void *)(a1 + 56));
        unint64_t v104 = (const float **)(a1 + 504);
        unint64_t v105 = (const float **)(a1 + 384);
        uint64_t v106 = (vDSP_Length *)(a1 + 40);
      }
      ++v59;
      vDSP_dotpr(*v104, 1, *v105, 1, &v119, *v106);
      float v107 = vabds_f32(v119, *(float *)&__B.realp);
      if (v119 <= *(float *)&__B.realp) {
        float v100 = v120;
      }
      else {
        float v99 = v120;
      }
    }
    while (v107 > (float)(*(float *)(a1 + 184) * *(float *)&__B.realp));
  }
  if (!*(void *)(a1 + 24)) {
    SpeechEnhancerFilterBank<float>::convertFilterBankToLinear(v111, *(float **)(a1 + 504), *(void *)(a1 + 360), *(void *)(a1 + 32));
  }
  vvsqrtf(*(float **)(a1 + 360), *(const float **)(a1 + 360), (const int *)(a1 + 328));
  unint64_t v58 = (float **)(a1 + 360);
  if (*(void *)(a1 + 8) - *(void *)a1 <= 0x1F0uLL) {
LABEL_163:
  }
    __assert_rtn("parameterValue", "SpeechEnhancerCore.h", 278, "index >= 0 && index < mParameterInfoTable.size()");
  float v108 = (float)(*(float *)(a1 + 148) - *(float *)(*(void *)a1 + 508)) * 0.25;
  if (v108 < 1.0)
  {
    vDSP_Length v109 = *v55;
    if (*v55)
    {
      float v110 = *(float **)(a1 + 360);
      do
      {
        *float v110 = powf(*v110, v108);
        ++v110;
        --v109;
      }
      while (v109);
    }
  }
LABEL_78:
  uint64_t v60 = *(const float **)(a1 + 360);
  vDSP_Length v61 = (uint64_t)(*(void *)(a1 + 368) - (void)v60) >> 2;
  LODWORD(__B.realp) = 0;
  vDSP_sve(v60, 1, (float *)&__B, v61);
  if ((unint64_t)((uint64_t)__B.realp & 0x7FFFFFFF) >= 0x7F800000)
  {
    LODWORD(__B.realp) = 1065353216;
    vDSP_vfill((const float *)&__B, *v58, 1, *v55);
  }
  *(unsigned char *)(a1 + 355) = 0;
  uint64_t v62 = *(void *)(a1 + 328);
  if (v62)
  {
    uint64_t v63 = 0;
    float v64 = *(float **)(a1 + 360);
    float v65 = *(float **)(a1 + 888);
    float v66 = (float)*(unint64_t *)(a1 + 240);
    float v67 = (float)*(unint64_t *)(a1 + 312);
    do
    {
      float v68 = v65[v63];
      float v69 = v64[v63] / v68;
      float v70 = exp((float)((float)(*(float *)(a1 + 172) * v66) / (float)(*(float *)(a1 + 108) / v67)) * 0.115129255);
      if (v69 > v70)
      {
        v64[v63] = v68 * v70;
        *(unsigned char *)(a1 + 355) = 1;
      }
      ++v63;
    }
    while (v62 != v63);
    memmove(v65, v64, 4 * v62);
    if (*v55)
    {
      memmove(*(void **)(a1 + 888), *(const void **)(a1 + 360), 4 * *v55);
      uint64_t v71 = *(void *)(a1 + 328);
      if (v71) {
        memmove(*(void **)(a1 + 600), *(const void **)(a1 + 360), 4 * v71);
      }
    }
  }
  float v72 = *(float **)a1;
  unint64_t v73 = *(void *)(a1 + 8) - *(void *)a1;
  if (v73 <= 0x160) {
    goto LABEL_163;
  }
  v72[91] = v56;
  if (v73 <= 0x170) {
    goto LABEL_163;
  }
  v72[95] = (float)v59;
  if (v73 <= 0x190) {
    goto LABEL_163;
  }
  if (v72[103] > 0.5)
  {
    vDSP_vclr((float *)(a1 + 1128), 1, 0x10uLL);
    uint64_t v74 = *(void *)(a1 + 328);
    if (v74)
    {
      uint64_t v75 = 0;
      unint64_t v76 = 0;
      uint64_t v77 = 0;
      uint64_t v78 = *(void *)(a1 + 624);
      do
      {
        uint64_t v79 = a1 + 4 * v77;
        if (*(float *)(v78 + 4 * v75) >= *(float *)(v79 + 248))
        {
          float v80 = *(float *)(v79 + 1128) / fmaxf((float)v76, 1.0);
          *(float *)(v79 + 1128) = v80;
          if (v77 + 33 >= (unint64_t)((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 4)) {
            goto LABEL_163;
          }
          *(float *)(*(void *)a1 + 16 * (v77 + 33) + 12) = v80;
          if (++v77 == 16) {
            break;
          }
          unint64_t v76 = 0;
        }
        *(float *)(a1 + 4 * v77 + 1128) = *(float *)(a1 + 4 * v77 + 1128)
                                        + (float)(log10f(*(float *)(*(void *)(a1 + 600) + 4 * v75) + 2.2204e-16) * 20.0);
        ++v76;
        ++v75;
      }
      while (v74 != v75);
    }
  }
LABEL_99:
  if (*(void *)(a1 + 8) - *(void *)a1 <= 0x110uLL) {
    goto LABEL_163;
  }
  if (*(float *)(*(void *)a1 + 284) <= 0.5)
  {
    vDSP_vsmul(*(const float **)(a1 + 600), 1, (const float *)(a1 + 124), *(float **)(a1 + 360), 1, *(void *)(a1 + 328));
    uint64_t v81 = *(void *)(a1 + 328);
    if (v81) {
      memmove(*(void **)(a1 + 1032), *(const void **)(a1 + 360), 4 * v81);
    }
  }
  else
  {
    LODWORD(__B.realp) = *(_DWORD *)(a1 + 124);
    vDSP_vfill((const float *)&__B, *(float **)(a1 + 1032), 1, *v55);
  }
  float v82 = *(float **)a1;
  unint64_t v83 = *(void *)(a1 + 8) - *(void *)a1;
  if (v83 <= 0x90) {
    goto LABEL_163;
  }
  v82[39] = *(float *)(a1 + 148);
  if (v83 <= 0xF0) {
    goto LABEL_163;
  }
  v82[63] = *(float *)(a1 + 128);
  if (v83 <= 0x200) {
    goto LABEL_163;
  }
  float v84 = 0.0;
  if (*(unsigned char *)(a1 + 353)) {
    float v84 = 1.0;
  }
  v82[131] = v84;
  v82[67] = *(float *)(a1 + 112);
  v82[111] = *(float *)(a1 + 112) + v82[107];
  return a1 + 1032;
}

float SPLMeter<float,AWeight>::process<std::vector<float>>(uint64_t a1, const float *__A, uint64_t a3)
{
  vDSP_Length v3 = (a3 - (uint64_t)__A) >> 2;
  unsigned int v4 = *(const float **)(a1 + 8);
  if (v3 != (uint64_t)(*(void *)(a1 + 16) - (void)v4) >> 2) {
    __assert_rtn("process", "SPLMeter.h", 98, "a.size() == mWeightCurve.size()");
  }
  float __C = 0.0;
  vDSP_dotpr(__A, 1, v4, 1, &__C, v3);
  return *(float *)a1 + (float)(log10f(fabsf(__C) + 0.00000011921) * 10.0);
}

float *SpeechEnhancerFilterBank<float>::convertFilterBankToLinear(unint64_t *a1, float *a2, uint64_t a3, uint64_t a4)
{
  float result = (float *)a1[4];
  unint64_t v9 = *a1;
  float v10 = (float *)a1[10];
  float v11 = (float *)a1[11];
  unint64_t v12 = v11 - v10;
  if (!a4) {
    return SpeechEnhancerFilterBank<float>::interp1(result, v9, a2, (uint64_t)v10, v12, a3, 0.0, 1.0);
  }
  float v13 = *result;
  unint64_t v14 = v9 - 2;
  if (v9 >= 2) {
    float v13 = (float)(v13 + result[1]) * 0.5;
  }
  if (*v10 <= v13)
  {
    unint64_t v16 = 0;
  }
  else
  {
    uint64_t v15 = 0;
    while (v14 != v15)
    {
      unint64_t v16 = v15 + 1;
      float v13 = (float)(result[v15 + 2] + result[v15 + 1]) * 0.5;
      ++v15;
      if (*v10 <= v13) {
        goto LABEL_12;
      }
    }
    float v13 = result[v9 - 1];
    unint64_t v16 = v9 - 1;
  }
LABEL_12:
  if (v11 == v10)
  {
    unint64_t v17 = 0;
  }
  else
  {
    unint64_t v17 = 0;
    while (v10[v17] < *result)
    {
      *(_DWORD *)(a3 + 4 * v17++) = 0;
      if (v12 == v17) {
        return result;
      }
    }
  }
  if (v17 >= v12)
  {
LABEL_26:
    unint64_t v19 = v12 - v17;
    if (v12 > v17)
    {
      uint64_t v20 = (_DWORD *)(a3 + 4 * v17);
      do
      {
        *v20++ = 1065353216;
        --v19;
      }
      while (v19);
    }
  }
  else
  {
    do
    {
      float v18 = v10[v17];
      if (v18 > v13)
      {
        if (v18 >= result[v9 - 1]) {
          goto LABEL_26;
        }
        do
        {
          float v13 = result[v9 - 1];
          if (v14 != v16) {
            float v13 = (float)(result[v16 + 2] + result[v16 + 1]) * 0.5;
          }
          ++v16;
        }
        while (v18 > v13);
      }
      *(float *)(a3 + 4 * v17++) = a2[v16];
    }
    while (v17 != v12);
  }
  return result;
}

float *SpeechEnhancerFilterBank<float>::interp1(float *result, uint64_t a2, float *a3, uint64_t a4, unint64_t a5, uint64_t a6, float a7, float a8)
{
  float v9 = *a3;
  float v8 = a3[1];
  float v11 = *result;
  float v10 = result[1];
  unint64_t v12 = 0;
  if (a5)
  {
    while (*(float *)(a4 + 4 * v12) < *result)
    {
      *(float *)(a6 + 4 * v12++) = a7;
      if (a5 == v12) {
        return result;
      }
    }
  }
  if (v12 >= a5)
  {
LABEL_19:
    unint64_t v22 = a5 - v12;
    if (a5 > v12)
    {
      uint64_t v23 = (float *)(a6 + 4 * v12);
      do
      {
        *v23++ = a8;
        --v22;
      }
      while (v22);
    }
  }
  else
  {
    uint64_t v13 = 0;
    uint64_t v14 = 1;
    float v15 = (float)(v8 - v9) / (float)(v10 - v11);
    do
    {
      float v16 = *(float *)(a4 + 4 * v12);
      float v17 = result[v14];
      if (v16 >= v17)
      {
        if (v16 <= v17 || v16 >= result[a2 - 1])
        {
          if (v16 == result[v13])
          {
            float v18 = a3[v13];
          }
          else
          {
            if (v16 != v17) {
              goto LABEL_19;
            }
            float v18 = a3[v14];
          }
        }
        else
        {
          do
          {
            float v19 = result[++v14];
            ++v13;
          }
          while (v16 > v19);
          float v20 = a3[v13];
          float v21 = result[v13];
          float v15 = (float)(a3[v14] - v20) / (float)(v19 - v21);
          float v18 = v20 + (float)(v15 * (float)(v16 - v21));
        }
      }
      else
      {
        float v18 = a3[v13] + (float)(v15 * (float)(v16 - result[v13]));
      }
      *(float *)(a6 + 4 * v12++) = v18;
    }
    while (v12 != a5);
  }
  return result;
}

uint64_t SpeechEnhancerCore<float>::setParameterLight(uint64_t result, uint64_t a2, unint64_t a3, float a4)
{
  if (a3 >= (a2 - result) >> 4) {
    __assert_rtn("setParameterLight", "SpeechEnhancerCore.h", 181, "index >= 0 && index < mParameterInfoTable.size()");
  }
  unsigned int v4 = (float *)(result + 16 * a3);
  if (v4[1] < a4) {
    a4 = v4[1];
  }
  if (a4 < *v4) {
    a4 = *v4;
  }
  v4[3] = a4;
  return result;
}

void SpeechEnhancerFilterBank<float>::createFilterBank(uint64_t a1, uint64_t a2, long double a3)
{
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v6 = (v4 - v5) >> 2;
  *(void *)a1 = v6;
  if (*(void *)(a1 + 16) != a2)
  {
    *(void *)(a1 + 16) = a2;
    float v8 = *(_DWORD **)(a1 + 152);
    uint64_t v9 = *(void *)(a1 + 160) - (void)v8;
    if (v9 >= 1) {
      bzero(*(void **)(a1 + 152), 4 * (((unint64_t)v9 >> 2) - ((unint64_t)v9 > 3)) + 4);
    }
    if (a2 == 1)
    {
      if (v4 != v5)
      {
        uint64_t v24 = 0;
        uint64_t v25 = *(void *)(a1 + 56);
        vDSP_Length v26 = *(float **)(a1 + 80);
        unint64_t v38 = *(float **)(a1 + 88);
        if ((unint64_t)(v38 - v26) <= 1) {
          uint64_t v27 = 1;
        }
        else {
          uint64_t v27 = v38 - v26;
        }
        uint64_t v36 = (v4 - v5) >> 2;
        unint64_t v37 = ((char *)v38 - (char *)v26) & 0xFFFFFFFFFFFFFFFCLL;
        do
        {
          *(float *)(v25 + 4 * v24) = *(float *)(a1 + 192)
                                    * (float)(*(float *)(a1 + 180)
                                            + (float)(*(float *)(a1 + 184) * *(float *)(v5 + 4 * v24)));
          *(_DWORD *)(a1 + 176) = 0;
          if (v38 != v26)
          {
            LODWORD(a3) = *(_DWORD *)(a1 + 188);
            double v28 = (double)*(unint64_t *)&a3;
            vDSP_Length v29 = v26;
            float v30 = v26;
            float v31 = v8;
            uint64_t v32 = v27;
            do
            {
              double v33 = (float)(*v30 - *(float *)(v5 + 4 * v24));
              a3 = 1.0 / pow(v33 * v33 / (*(float *)(v25 + 4 * v24) * *(float *)(v25 + 4 * v24)) + 1.0, v28);
              *(float *)&a3 = a3;
              *float v31 = LODWORD(a3);
              if (*(float *)(a1 + 176) < *(float *)&a3) {
                *(_DWORD *)(a1 + 176) = LODWORD(a3);
              }
              ++v31;
              ++v30;
              --v32;
            }
            while (v32);
            uint64_t v34 = 0;
            uint64_t v6 = v36;
            vDSP_Length v26 = v29;
            do
            {
              float v35 = *(float *)(a1 + 176);
              if (v35 != 0.0) {
                *(float *)&v8[v34] = *(float *)&v8[v34] / v35;
              }
              ++v34;
            }
            while (v27 != v34);
          }
          ++v24;
          float v8 = (_DWORD *)((char *)v8 + v37);
        }
        while (v24 != v6);
      }
    }
    else if (!a2 && v4 != v5)
    {
      uint64_t v10 = 0;
      uint64_t v11 = *(void *)(a1 + 56);
      uint64_t v13 = *(float **)(a1 + 80);
      unint64_t v12 = *(float **)(a1 + 88);
      unint64_t v14 = v12 - v13;
      if (v14 <= 1) {
        unint64_t v14 = 1;
      }
      do
      {
        float v15 = *(float *)(a1 + 180) + (float)(*(float *)(a1 + 184) * *(float *)(v5 + 4 * v10));
        *(float *)(v11 + 4 * v10) = v15;
        if (v12 != v13)
        {
          float v16 = *(float *)(v5 + 4 * v10);
          float v17 = v15 * 0.5;
          float v18 = v16 - (float)(v15 * 0.5);
          float v19 = v17 + v16;
          float v20 = v13;
          float v21 = v8;
          unint64_t v22 = v14;
          do
          {
            if (*v20 >= v18 && *v20 <= v19) {
              _DWORD *v21 = 1065353216;
            }
            ++v21;
            ++v20;
            --v22;
          }
          while (v22);
        }
        ++v10;
        float v8 = (_DWORD *)((char *)v8 + (((char *)v12 - (char *)v13) & 0xFFFFFFFFFFFFFFFCLL));
      }
      while (v10 != v6);
    }
  }

  SpeechEnhancerFilterBank<float>::calculateBandImportance(a1);
}

void SpeechEnhancerFilterBank<float>::calculateBandImportance(uint64_t a1)
{
  vDSP_mmul(*(const float **)(a1 + 152), 1, *(const float **)(a1 + 128), 1, *(float **)(a1 + 104), 1, *(void *)a1, 1uLL, (uint64_t)(*(void *)(a1 + 136) - *(void *)(a1 + 128)) >> 2);
  float __C = 0.0;
  vDSP_sve(*(const float **)(a1 + 104), 1, &__C, *(void *)a1);
  vDSP_vsdiv(*(const float **)(a1 + 104), 1, &__C, *(float **)(a1 + 104), 1, *(void *)a1);
}

uint64_t AUSpeechEnhancer::CanScheduleParameters(AUSpeechEnhancer *this)
{
  return 0;
}

uint64_t AUSpeechEnhancer::SetParameter(AUSpeechEnhancer *this, unsigned int a2, unsigned int a3, unsigned int a4, float a5)
{
  uint64_t v5 = *((void *)this + 82);
  if (a2 > (unint64_t)((*((void *)this + 83) - v5) >> 5)) {
    return 4294956418;
  }
  if ((*(unsigned char *)(v5 + 32 * a2 + 13) & 0x80) != 0)
  {
    if (a2 == 52)
    {
      float v15 = (uint64_t *)*((void *)this + 74);
      if (v15) {
        SpeechEnhancerCore<float>::setParameterLight(*v15, v15[1], 0x34uLL, a5);
      }
    }
    else if (a2 == 26)
    {
      unint64_t v12 = (uint64_t *)*((void *)this + 74);
      if (v12)
      {
        SpeechEnhancerCore<float>::setParameterLight(*v12, v12[1], 0x1AuLL, a5);
        uint64_t v13 = *((void *)this + 74);
        if (*(void *)(v13 + 8) - *(void *)v13 <= 0x1A0uLL) {
          __assert_rtn("parameterValue", "SpeechEnhancerCore.h", 278, "index >= 0 && index < mParameterInfoTable.size()");
        }
        float v14 = exp(*(float *)(*(void *)v13 + 428) * 0.230258509);
        *(float *)(v13 + 140) = v14;
      }
    }
  }
  else
  {
    ++*((_DWORD *)this + 162);
  }
  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
  uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
  ausdk::AUElement::SetParameter(Element, a2, a5, 0);
  return 0;
}

uint64_t AUSpeechEnhancer::SetProperty(AUSpeechEnhancer *this, int a2, int a3, unsigned int a4, unsigned int *__src, unsigned int a6)
{
  if (a3) {
    return 4294956417;
  }
  switch(a2)
  {
    case 1001:
      if (!*((unsigned char *)this + 17)) {
        goto LABEL_29;
      }
      if (!__src) {
        goto LABEL_28;
      }
      unint64_t v8 = a6 >> 2;
      uint64_t v9 = *((unsigned int *)this + 140);
      if (v8 != v9 + 1) {
        goto LABEL_28;
      }
      uint64_t result = 4294956445;
      if (v9)
      {
        double v10 = *((double *)this + 69);
        if (v10 > 0.0)
        {
          uint64_t v11 = (float *)*((void *)this + 71);
          if (!v11) {
            goto LABEL_28;
          }
          int v12 = *((_DWORD *)this + 135);
          if (*((_DWORD *)this + 132) == v10 && v12 == v9)
          {
            float v14 = &__src[v9 + 1];
            if (v14 != __src) {
              memmove(*(void **)(*((void *)this + 74) + 648), __src, (char *)v14 - (char *)__src);
            }
          }
          else
          {
            SpeechEnhancerCore<float>::resampleSpectrum(v11, v8, (float *)__src, *(float **)(*((void *)this + 74) + 624), (v12 + 1), *(float **)(*((void *)this + 74) + 648));
          }
          goto LABEL_21;
        }
      }
      break;
    case 1002:
      if (*((unsigned char *)this + 17))
      {
        if (!__src) {
          goto LABEL_28;
        }
        SpeechEnhancerCore<float>::setParameterLight(**((void **)this + 74), *(void *)(*((void *)this + 74) + 8), 1uLL, (float)*__src);
LABEL_21:
        uint64_t result = 0;
      }
      else
      {
LABEL_29:
        uint64_t result = 4294956429;
      }
      break;
    case 1003:
      if (!__src) {
        goto LABEL_28;
      }
      if (*((unsigned char *)this + 17)) {
        goto LABEL_27;
      }
      uint64_t result = 0;
      *((void *)this + 69) = *(void *)__src;
      break;
    case 1004:
      if (__src)
      {
        if (*((unsigned char *)this + 17))
        {
LABEL_27:
          uint64_t result = 4294956431;
        }
        else
        {
          uint64_t result = 0;
          *((_DWORD *)this + 140) = *__src;
        }
      }
      else
      {
LABEL_28:
        uint64_t result = 4294956445;
      }
      break;
    default:
      if (a2 != 21) {
        return 4294956417;
      }
      uint64_t result = 0;
      *((unsigned char *)this + 544) = *__src != 0;
      break;
  }
  return result;
}

float SpeechEnhancerCore<float>::resampleSpectrum(float *a1, unint64_t a2, float *a3, float *a4, unint64_t a5, float *a6)
{
  if (a2 <= 1) {
    __assert_rtn("resampleSpectrum", "SpeechEnhancerCore.h", 344, "DFTFrequenciesSizeIn > 1");
  }
  if (a5 <= 1) {
    __assert_rtn("resampleSpectrum", "SpeechEnhancerCore.h", 345, "DFTFrequenciesSizeOut > 1");
  }
  SpeechEnhancerFilterBank<float>::interp1(a1, a2, a3, (uint64_t)a4, a5, (uint64_t)a6, *a3, a3[a2 - 1]);
  float __B = (float)(a4[1] - *a4) / (float)(a1[1] - *a1);
  vDSP_vsmul(a6, 1, &__B, a6, 1, a5);
  return result;
}

uint64_t AUSpeechEnhancer::GetProperty(AUSpeechEnhancer *this, int a2, int a3, unsigned int a4, _DWORD *a5)
{
  if (a3) {
    return 4294956417;
  }
  if (a2 == 3700)
  {
    uint64_t v6 = (unsigned __int8 *)this + 376;
  }
  else
  {
    if (a2 != 21) {
      return 4294956417;
    }
    uint64_t v6 = (unsigned __int8 *)this + 544;
  }
  uint64_t result = 0;
  *a5 = *v6;
  return result;
}

uint64_t AUSpeechEnhancer::GetPropertyInfo(AUSpeechEnhancer *this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  if (a3) {
    return 4294956417;
  }
  uint64_t result = 4294956417;
  if (a2 <= 1002)
  {
    if (a2 != 21)
    {
      if (a2 != 1001) {
        return result;
      }
      *a6 = 1;
      int v8 = 4 * *((_DWORD *)this + 84) + 4;
LABEL_13:
      uint64_t result = 0;
      *a5 = v8;
      return result;
    }
LABEL_11:
    *a6 = 1;
    int v8 = 4;
    goto LABEL_13;
  }
  if (a2 == 1003)
  {
    *a6 = 1;
    int v8 = 8;
    goto LABEL_13;
  }
  if (a2 == 1004 || a2 == 3700) {
    goto LABEL_11;
  }
  return result;
}

uint64_t AUSpeechEnhancer::Reset(AUSpeechEnhancer *this)
{
  if (*((unsigned char *)this + 17))
  {
    uint64_t v1 = *((void *)this + 74);
    if (v1)
    {
      unint64_t v2 = *(void *)(v1 + 328);
      int v7 = 629145600;
      std::vector<float>::assign((char **)(v1 + 936), v2, &v7);
      *(unsigned char *)(v1 + 1436) = 0;
      *(_DWORD *)(v1 + 1420) = 0;
      SpeechEnhancerCore<float>::getAverageSpeechSpectrum(*(float **)(v1 + 624), *(void *)(v1 + 328), *(void *)(v1 + 960));
      float v3 = *(float *)(v1 + 188);
      float v4 = *(float *)(v1 + 192);
      *(float *)(v1 + 132) = v3;
      float __B = (float)(v3 / 10000000.0) / v4;
      vDSP_vsmul(*(const float **)(v1 + 960), 1, &__B, *(float **)(v1 + 912), 1, *(void *)(v1 + 328));
      *(void *)(v1 + 344) = 0;
      *(void *)(v1 + 48) = 0;
      *(_DWORD *)(v1 + 116) = 0;
      *(_WORD *)(v1 + 354) = 257;
      float __A = 1.0;
      vDSP_vfill(&__A, *(float **)(v1 + 888), 1, *(void *)(v1 + 328));
      operator new();
    }
  }
  return 0;
}

void sub_1BB36F244(_Unwind_Exception *a1)
{
  MEMORY[0x1C185D370](v1, 0x1091C4047E1822DLL);
  _Unwind_Resume(a1);
}

void SpeechEnhancerCore<float>::getAverageSpeechSpectrum(float *a1, unint64_t a2, uint64_t a3)
{
  if (a2 <= 1) {
    __assert_rtn("getAverageSpeechSpectrum", "SpeechEnhancerCore.h", 892, "DFTFrequenciesSize > 1");
  }
  uint64_t v6 = operator new(0x64uLL);
  v6[24] = 1182400512;
  *((_OWORD *)v6 + 2) = xmmword_1BB87DC80;
  *((_OWORD *)v6 + 3) = unk_1BB87DC90;
  *((_OWORD *)v6 + 4) = xmmword_1BB87DCA0;
  *((_OWORD *)v6 + 5) = unk_1BB87DCB0;
  *(_OWORD *)uint64_t v6 = xmmword_1BB87DC60;
  *((_OWORD *)v6 + 1) = unk_1BB87DC70;
  int v7 = (char *)operator new(0x64uLL);
  uint64_t v8 = 0;
  *((_DWORD *)v7 + 24) = 1109576909;
  *((_OWORD *)v7 + 2) = xmmword_1BB87DCE4;
  *((_OWORD *)v7 + 3) = unk_1BB87DCF4;
  *((_OWORD *)v7 + 4) = xmmword_1BB87DD04;
  *((_OWORD *)v7 + 5) = unk_1BB87DD14;
  *(_OWORD *)int v7 = xmmword_1BB87DCC4;
  *((_OWORD *)v7 + 1) = unk_1BB87DCD4;
  float v9 = a1[1] - *a1;
  do
  {
    float v10 = v9 / (float)(*(float *)&v6[v8] * 0.23156);
    float v11 = exp(*(float *)&v7[v8 * 4] * 0.230258509);
    *(float *)&v7[v8 * 4] = v10 * v11;
    ++v8;
  }
  while (v8 != 25);
  SpeechEnhancerFilterBank<float>::interp1((float *)v6, 25, (float *)v7, (uint64_t)a1, a2, a3, *(float *)v7, *((float *)v7 + 24));
  operator delete(v7);

  operator delete(v6);
}

void sub_1BB36F3F4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t AUSpeechEnhancer::Initialize(AUSpeechEnhancer *this)
{
  uint64_t Element = ausdk::AUScope::SafeGetElement((AUSpeechEnhancer *)((char *)this + 80), 0);
  int v3 = *(_DWORD *)(Element + 88);
  if (v3 != 1819304813 && v3 != 1718773105) {
    return 4294956428;
  }
  uint64_t v5 = Element;
  *((_DWORD *)this + 133) = *(_DWORD *)(Element + 108);
  uint64_t v6 = ausdk::AUScope::SafeGetElement((AUSpeechEnhancer *)((char *)this + 128), 0);
  int v7 = *(_DWORD *)(v6 + 88);
  if (v7 != 1819304813 && v7 != 1718773105) {
    return 4294956428;
  }
  uint64_t v9 = v6;
  int v10 = *(_DWORD *)(v6 + 108);
  *((_DWORD *)this + 134) = v10;
  uint64_t result = 4294956428;
  if ((v3 == 1718773105) == (v7 == 1718773105)
    && (v3 == 1819304813) == (v7 == 1819304813)
    && *((_DWORD *)this + 133) == v10
    && *(double *)(v5 + 80) == *(double *)(v9 + 80))
  {
    BOOL v13 = v3 == 1718773105 && v7 == 1718773105;
    *((unsigned char *)this + 545) = v13;
    *((_DWORD *)this + 132) = (unint64_t)(*(double *)(ausdk::AUScope::SafeGetElement((AUSpeechEnhancer *)((char *)this + 128), 0)+ 80)+ 0.5);
    int v14 = *((_DWORD *)this + 84);
    *((_DWORD *)this + 135) = v14;
    double v15 = *((double *)this + 69);
    if (v15 > 0.0)
    {
      int v16 = *((_DWORD *)this + 140);
      if (v16)
      {
        float v17 = v15;
        float v18 = v17 * 0.5;
        unint64_t v19 = (v16 + 1);
        std::vector<float>::vector(&v22, v19);
        float __A = 0.0;
        __B[0] = v18 / (float)(v19 - 1);
        vDSP_vramp(&__A, __B, (float *)v22, 1, v19);
        float v20 = (void *)*((void *)this + 71);
        if (v20)
        {
          *((void *)this + 72) = v20;
          operator delete(v20);
        }
        *(_OWORD *)((char *)this + 568) = v22;
        *((void *)this + 73) = v23;
        int v14 = *((_DWORD *)this + 135);
      }
    }
    if (v14) {
      operator new();
    }
    return 0;
  }
  return result;
}

void sub_1BB3701B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41)
{
  float v43 = *(void **)(v41 - 176);
  if (v43)
  {
    *(void *)(v41 - 168) = v43;
    operator delete(v43);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *std::unique_ptr<SpeechEnhancerCore<float>>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  *uint64_t result = a2;
  if (v2)
  {
    float v42 = (void **)(v2 + 1512);
    std::vector<std::unique_ptr<VPTimeFreqConverter>>::__destroy_vector::operator()[abi:ne180100](&v42);
    float v42 = (void **)(v2 + 1488);
    std::vector<std::unique_ptr<VPTimeFreqConverter>>::__destroy_vector::operator()[abi:ne180100](&v42);
    uint64_t v3 = *(void *)(v2 + 1480);
    *(void *)(v2 + 1480) = 0;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
    float v4 = *(void **)(v2 + 1456);
    if (v4)
    {
      *(void *)(v2 + 1464) = v4;
      operator delete(v4);
    }
    uint64_t v5 = *(void **)(v2 + 1344);
    if (v5)
    {
      *(void *)(v2 + 1352) = v5;
      operator delete(v5);
    }
    uint64_t v6 = *(void **)(v2 + 1320);
    if (v6)
    {
      *(void *)(v2 + 1328) = v6;
      operator delete(v6);
    }
    int v7 = *(void **)(v2 + 1296);
    if (v7)
    {
      *(void *)(v2 + 1304) = v7;
      operator delete(v7);
    }
    uint64_t v8 = *(void **)(v2 + 1272);
    if (v8)
    {
      *(void *)(v2 + 1280) = v8;
      operator delete(v8);
    }
    uint64_t v9 = *(void **)(v2 + 1248);
    if (v9)
    {
      *(void *)(v2 + 1256) = v9;
      operator delete(v9);
    }
    int v10 = *(void **)(v2 + 1224);
    if (v10)
    {
      *(void *)(v2 + 1232) = v10;
      operator delete(v10);
    }
    float v42 = (void **)(v2 + 1104);
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v42);
    float v42 = (void **)(v2 + 1080);
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v42);
    float v11 = *(void **)(v2 + 1056);
    if (v11)
    {
      *(void *)(v2 + 1064) = v11;
      operator delete(v11);
    }
    int v12 = *(void **)(v2 + 1032);
    if (v12)
    {
      *(void *)(v2 + 1040) = v12;
      operator delete(v12);
    }
    BOOL v13 = *(void **)(v2 + 1008);
    if (v13)
    {
      *(void *)(v2 + 1016) = v13;
      operator delete(v13);
    }
    int v14 = *(void **)(v2 + 984);
    if (v14)
    {
      *(void *)(v2 + 992) = v14;
      operator delete(v14);
    }
    double v15 = *(void **)(v2 + 960);
    if (v15)
    {
      *(void *)(v2 + 968) = v15;
      operator delete(v15);
    }
    int v16 = *(void **)(v2 + 936);
    if (v16)
    {
      *(void *)(v2 + 944) = v16;
      operator delete(v16);
    }
    float v17 = *(void **)(v2 + 912);
    if (v17)
    {
      *(void *)(v2 + 920) = v17;
      operator delete(v17);
    }
    float v18 = *(void **)(v2 + 888);
    if (v18)
    {
      *(void *)(v2 + 896) = v18;
      operator delete(v18);
    }
    unint64_t v19 = *(void **)(v2 + 864);
    if (v19)
    {
      *(void *)(v2 + 872) = v19;
      operator delete(v19);
    }
    float v20 = *(void **)(v2 + 840);
    if (v20)
    {
      *(void *)(v2 + 848) = v20;
      operator delete(v20);
    }
    float v21 = *(void **)(v2 + 816);
    if (v21)
    {
      *(void *)(v2 + 824) = v21;
      operator delete(v21);
    }
    long long v22 = *(void **)(v2 + 792);
    if (v22)
    {
      *(void *)(v2 + 800) = v22;
      operator delete(v22);
    }
    uint64_t v23 = *(void **)(v2 + 768);
    if (v23)
    {
      *(void *)(v2 + 776) = v23;
      operator delete(v23);
    }
    uint64_t v24 = *(void **)(v2 + 744);
    if (v24)
    {
      *(void *)(v2 + 752) = v24;
      operator delete(v24);
    }
    uint64_t v25 = *(void **)(v2 + 720);
    if (v25)
    {
      *(void *)(v2 + 728) = v25;
      operator delete(v25);
    }
    vDSP_Length v26 = *(void **)(v2 + 696);
    if (v26)
    {
      *(void *)(v2 + 704) = v26;
      operator delete(v26);
    }
    uint64_t v27 = *(void **)(v2 + 672);
    if (v27)
    {
      *(void *)(v2 + 680) = v27;
      operator delete(v27);
    }
    double v28 = *(void **)(v2 + 648);
    if (v28)
    {
      *(void *)(v2 + 656) = v28;
      operator delete(v28);
    }
    vDSP_Length v29 = *(void **)(v2 + 624);
    if (v29)
    {
      *(void *)(v2 + 632) = v29;
      operator delete(v29);
    }
    float v30 = *(void **)(v2 + 600);
    if (v30)
    {
      *(void *)(v2 + 608) = v30;
      operator delete(v30);
    }
    float v31 = *(void **)(v2 + 576);
    if (v31)
    {
      *(void *)(v2 + 584) = v31;
      operator delete(v31);
    }
    uint64_t v32 = *(void **)(v2 + 552);
    if (v32)
    {
      *(void *)(v2 + 560) = v32;
      operator delete(v32);
    }
    double v33 = *(void **)(v2 + 528);
    if (v33)
    {
      *(void *)(v2 + 536) = v33;
      operator delete(v33);
    }
    uint64_t v34 = *(void **)(v2 + 504);
    if (v34)
    {
      *(void *)(v2 + 512) = v34;
      operator delete(v34);
    }
    float v35 = *(void **)(v2 + 480);
    if (v35)
    {
      *(void *)(v2 + 488) = v35;
      operator delete(v35);
    }
    uint64_t v36 = *(void **)(v2 + 456);
    if (v36)
    {
      *(void *)(v2 + 464) = v36;
      operator delete(v36);
    }
    unint64_t v37 = *(void **)(v2 + 432);
    if (v37)
    {
      *(void *)(v2 + 440) = v37;
      operator delete(v37);
    }
    unint64_t v38 = *(void **)(v2 + 408);
    if (v38)
    {
      *(void *)(v2 + 416) = v38;
      operator delete(v38);
    }
    float v39 = *(void **)(v2 + 384);
    if (v39)
    {
      *(void *)(v2 + 392) = v39;
      operator delete(v39);
    }
    float v40 = *(void **)(v2 + 360);
    if (v40)
    {
      *(void *)(v2 + 368) = v40;
      operator delete(v40);
    }
    uint64_t v41 = *(void **)v2;
    if (*(void *)v2)
    {
      *(void *)(v2 + 8) = v41;
      operator delete(v41);
    }
    JUMPOUT(0x1C185D370);
  }
  return result;
}

void std::vector<std::span<float,18446744073709551615ul>>::resize(char **a1, unint64_t a2)
{
  uint64_t v3 = *a1;
  float v4 = a1[1];
  unint64_t v5 = (v4 - *a1) >> 4;
  if (a2 <= v5)
  {
    if (a2 >= v5) {
      return;
    }
    float v18 = &v3[16 * a2];
    goto LABEL_19;
  }
  unint64_t v6 = a2 - v5;
  int v7 = a1[2];
  if (a2 - v5 <= (v7 - v4) >> 4)
  {
    bzero(a1[1], 16 * v6);
    float v18 = &v4[16 * v6];
LABEL_19:
    a1[1] = v18;
    return;
  }
  if (a2 >> 60) {
    std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v8 = v7 - v3;
  uint64_t v9 = v8 >> 3;
  if (v8 >> 3 <= a2) {
    uint64_t v9 = a2;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v10 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v10 = v9;
  }
  float v11 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float (ASAFeatures::*)(ASAFrontEndInputState const*)>>(v10);
  int v12 = &v11[16 * v5];
  int v14 = &v11[16 * v13];
  bzero(v12, 16 * v6);
  double v15 = &v12[16 * v6];
  float v17 = *a1;
  int v16 = a1[1];
  if (v16 != *a1)
  {
    do
    {
      *((_OWORD *)v12 - 1) = *((_OWORD *)v16 - 1);
      v12 -= 16;
      v16 -= 16;
    }
    while (v16 != v17);
    int v16 = *a1;
  }
  *a1 = v12;
  a1[1] = v15;
  a1[2] = v14;
  if (v16)
  {
    operator delete(v16);
  }
}

void std::vector<std::unique_ptr<VPTimeFreqConverter>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (VPTimeFreqConverter **)**a1;
  if (v2)
  {
    float v4 = (VPTimeFreqConverter **)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
        std::unique_ptr<VPTimeFreqConverter>::reset[abi:ne180100](--v4, 0);
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *AWeight<float>::Generate(void *a1, unint64_t a2, float a3)
{
  uint64_t result = std::vector<float>::vector(a1, a2);
  if (a2)
  {
    uint64x2_t v7 = (uint64x2_t)vdupq_n_s64(a2 - 1);
    unint64_t v8 = (a2 + 3) & 0xFFFFFFFFFFFFFFFCLL;
    int64x2_t v9 = (int64x2_t)xmmword_1BB872EC0;
    int64x2_t v10 = (int64x2_t)xmmword_1BB872720;
    float v11 = (_DWORD *)(*result + 8);
    float32x4_t v12 = (float32x4_t)vdupq_n_s32(0x43D428CAu);
    float32x4_t v13 = (float32x4_t)vdupq_n_s32(0x4D0DCF73u);
    float32x4_t v14 = (float32x4_t)vdupq_n_s32(0x4D328586u);
    float32x4_t v15 = (float32x4_t)vdupq_n_s32(0x4635145Fu);
    float32x4_t v16 = (float32x4_t)vdupq_n_s32(0x4904EB8Bu);
    int64x2_t v17 = vdupq_n_s64(4uLL);
    do
    {
      v18.i64[0] = v9.i64[0] * v9.i64[0];
      v18.i64[1] = v9.i64[1] * v9.i64[1];
      *(int32x2_t *)v6.i8 = vmovn_s64((int64x2_t)vcgeq_u64(v7, (uint64x2_t)v10));
      v19.i64[0] = v10.i64[0] * v10.i64[0];
      v19.i64[1] = v10.i64[1] * v10.i64[1];
      float32x4_t v20 = vmulq_n_f32(vmulq_n_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vcvtq_f64_u64(v19)), vcvtq_f64_u64(v18)), a3 / (float)(2 * a2 - 2)), a3 / (float)(2 * a2 - 2));
      float32x4_t v21 = vmulq_f32(vdivq_f32(v20, vaddq_f32(v20, v12)), vdivq_f32(v14, vaddq_f32(v20, v13)));
      float32x4_t v22 = vmulq_f32(vdivq_f32(v20, vaddq_f32(v20, v15)), vmulq_f32(v21, v21));
      float32x4_t v23 = vmulq_f32(vdivq_f32(v20, vaddq_f32(v20, v16)), v22);
      if (vmovn_s32(v6).u8[0]) {
        *(v11 - 2) = v23.i32[0];
      }
      if (vmovn_s32(v6).i8[2]) {
        *(v11 - 1) = v23.i32[1];
      }
      int64x2_t v24 = (int64x2_t)vcgeq_u64(v7, (uint64x2_t)v9);
      if (vmovn_s32(vmovn_hight_s64(*(int32x2_t *)&v22, v24)).i32[1]) {
        _DWORD *v11 = v23.i32[2];
      }
      int32x4_t v6 = vmovn_hight_s64(*(int32x2_t *)v24.i8, v24);
      if (vmovn_s32(v6).i8[6]) {
        v11[1] = v23.i32[3];
      }
      int64x2_t v9 = vaddq_s64(v9, v17);
      int64x2_t v10 = vaddq_s64(v10, v17);
      v11 += 4;
      v8 -= 4;
    }
    while (v8);
  }
  return result;
}

void std::vector<std::unique_ptr<VPTimeFreqConverter>>::resize(long long *a1, unint64_t a2)
{
  uint64_t v3 = *(void **)a1;
  float v4 = (VPTimeFreqConverter **)*((void *)a1 + 1);
  unint64_t v5 = ((uint64_t)v4 - *(void *)a1) >> 3;
  if (a2 <= v5)
  {
    if (a2 < v5)
    {
      float32x4_t v21 = (VPTimeFreqConverter **)&v3[a2];
      while (v4 != v21)
        std::unique_ptr<VPTimeFreqConverter>::reset[abi:ne180100](--v4, 0);
      *((void *)a1 + 1) = v21;
    }
  }
  else
  {
    unint64_t v6 = a2 - v5;
    uint64_t v7 = *((void *)a1 + 2);
    if (a2 - v5 <= (v7 - (uint64_t)v4) >> 3)
    {
      bzero(*((void **)a1 + 1), 8 * v6);
      *((void *)a1 + 1) = &v4[v6];
    }
    else
    {
      if (a2 >> 61) {
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v25 = a1 + 1;
      uint64_t v8 = v7 - (void)v3;
      uint64_t v9 = v8 >> 2;
      if (v8 >> 2 <= a2) {
        uint64_t v9 = a2;
      }
      if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v10 = v9;
      }
      float v11 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v10);
      float32x4_t v13 = *(void **)a1;
      float32x4_t v12 = (void *)*((void *)a1 + 1);
      float32x4_t v14 = &v11[8 * v5];
      float32x4_t v16 = &v11[8 * v15];
      int64x2_t v24 = v16;
      bzero(v14, 8 * v6);
      int64x2_t v17 = &v14[8 * v6];
      *((void *)&v23 + 1) = v17;
      if (v12 != v13)
      {
        do
        {
          uint64_t v18 = *--v12;
          void *v12 = 0;
          *((void *)v14 - 1) = v18;
          v14 -= 8;
        }
        while (v12 != v13);
        int64x2_t v17 = (char *)*((void *)&v23 + 1);
        float32x4_t v16 = v24;
      }
      long long v19 = *a1;
      *(void *)a1 = v14;
      *((void *)a1 + 1) = v17;
      long long v23 = v19;
      float32x4_t v20 = (char *)*((void *)a1 + 2);
      *((void *)a1 + 2) = v16;
      int64x2_t v24 = v20;
      uint64_t v22 = v19;
      std::__split_buffer<std::unique_ptr<VPTimeFreqConverter>>::~__split_buffer((uint64_t)&v22);
    }
  }
}

void *SpeechEnhancerFilterBank<float>::~SpeechEnhancerFilterBank(void *a1)
{
  uint64_t v2 = (void *)a1[19];
  if (v2)
  {
    a1[20] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[16];
  if (v3)
  {
    a1[17] = v3;
    operator delete(v3);
  }
  float v4 = (void *)a1[13];
  if (v4)
  {
    a1[14] = v4;
    operator delete(v4);
  }
  unint64_t v5 = (void *)a1[10];
  if (v5)
  {
    a1[11] = v5;
    operator delete(v5);
  }
  unint64_t v6 = (void *)a1[7];
  if (v6)
  {
    a1[8] = v6;
    operator delete(v6);
  }
  uint64_t v7 = (void *)a1[4];
  if (v7)
  {
    a1[5] = v7;
    operator delete(v7);
  }
  return a1;
}

uint64_t std::__split_buffer<std::unique_ptr<VPTimeFreqConverter>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    std::unique_ptr<VPTimeFreqConverter>::reset[abi:ne180100]((VPTimeFreqConverter **)(i - 8), 0);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void AUSpeechEnhancer::~AUSpeechEnhancer(AUSpeechEnhancer *this)
{
  AUSpeechEnhancer::~AUSpeechEnhancer(this);

  JUMPOUT(0x1C185D370);
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  uint64_t vars8;

  *(void *)this = &unk_1F14ABAC0;
  uint64_t v2 = (void *)*((void *)this + 82);
  if (v2)
  {
    *((void *)this + 83) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 78);
  if (v3)
  {
    *((void *)this + 79) = v3;
    operator delete(v3);
  }
  float v4 = (void *)*((void *)this + 75);
  if (v4)
  {
    *((void *)this + 76) = v4;
    operator delete(v4);
  }
  std::unique_ptr<SpeechEnhancerCore<float>>::reset[abi:ne180100]((uint64_t *)this + 74, 0);
  unint64_t v5 = (void *)*((void *)this + 71);
  if (v5)
  {
    *((void *)this + 72) = v5;
    operator delete(v5);
  }

  ausdk::AUBase::~AUBase(this);
}

void spen::populateParameterInfoTable(void **a1)
{
  uint64_t v2 = a1[1];
  unint64_t v3 = (unint64_t)a1[2];
  if ((unint64_t)v2 >= v3)
  {
    uint64_t v5 = ((char *)v2 - (unsigned char *)*a1) >> 5;
    unint64_t v6 = v5 + 1;
    if ((unint64_t)(v5 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v7 = v3 - (void)*a1;
    if (v7 >> 4 > v6) {
      unint64_t v6 = v7 >> 4;
    }
    if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v8 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v8 = v6;
    }
    if (v8) {
      unint64_t v8 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v8);
    }
    else {
      uint64_t v9 = 0;
    }
    unint64_t v10 = (void *)(v8 + 32 * v5);
    unint64_t v11 = v8 + 32 * v9;
    *unint64_t v10 = @"Bypass Algorithm";
    v10[1] = 0x8000000000000002;
    v10[2] = 0x3F80000000000000;
    v10[3] = -3229614080;
    float v4 = v10 + 4;
    float32x4_t v13 = (char *)*a1;
    float32x4_t v12 = (char *)a1[1];
    if (v12 != *a1)
    {
      do
      {
        long long v14 = *((_OWORD *)v12 - 1);
        *((_OWORD *)v10 - 2) = *((_OWORD *)v12 - 2);
        *((_OWORD *)v10 - 1) = v14;
        v10 -= 4;
        v12 -= 32;
      }
      while (v12 != v13);
      float32x4_t v12 = (char *)*a1;
    }
    *a1 = v10;
    a1[1] = v4;
    a1[2] = (void *)v11;
    if (v12) {
      operator delete(v12);
    }
  }
  else
  {
    *uint64_t v2 = @"Bypass Algorithm";
    v2[1] = 0x8000000000000002;
    v2[2] = 0x3F80000000000000;
    v2[3] = -3229614080;
    float v4 = v2 + 4;
  }
  a1[1] = v4;
  unint64_t v15 = (unint64_t)a1[2];
  if ((unint64_t)v4 >= v15)
  {
    uint64_t v17 = ((char *)v4 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v17 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v18 = v15 - (void)*a1;
    uint64_t v19 = v18 >> 4;
    if (v18 >> 4 <= (unint64_t)(v17 + 1)) {
      uint64_t v19 = v17 + 1;
    }
    if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v20 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v20 = v19;
    }
    if (v20) {
      unint64_t v20 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v20);
    }
    else {
      uint64_t v21 = 0;
    }
    uint64_t v22 = (void *)(v20 + 32 * v17);
    unint64_t v23 = v20 + 32 * v21;
    *uint64_t v22 = @"Wind Flag";
    v22[1] = 0x800000000000;
    v22[2] = 0x3F80000000000000;
    v22[3] = 0xFFFFFFFF00000000;
    float32x4_t v16 = v22 + 4;
    uint64_t v25 = (char *)*a1;
    int64x2_t v24 = (char *)a1[1];
    if (v24 != *a1)
    {
      do
      {
        long long v26 = *((_OWORD *)v24 - 1);
        *((_OWORD *)v22 - 2) = *((_OWORD *)v24 - 2);
        *((_OWORD *)v22 - 1) = v26;
        v22 -= 4;
        v24 -= 32;
      }
      while (v24 != v25);
      int64x2_t v24 = (char *)*a1;
    }
    *a1 = v22;
    a1[1] = v16;
    a1[2] = (void *)v23;
    if (v24) {
      operator delete(v24);
    }
  }
  else
  {
    void *v4 = @"Wind Flag";
    v4[1] = 0x800000000000;
    v4[2] = 0x3F80000000000000;
    v4[3] = 0xFFFFFFFF00000000;
    float32x4_t v16 = v4 + 4;
  }
  a1[1] = v16;
  unint64_t v27 = (unint64_t)a1[2];
  if ((unint64_t)v16 >= v27)
  {
    uint64_t v29 = ((char *)v16 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v29 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v30 = v27 - (void)*a1;
    uint64_t v31 = v30 >> 4;
    if (v30 >> 4 <= (unint64_t)(v29 + 1)) {
      uint64_t v31 = v29 + 1;
    }
    if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v32 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v32 = v31;
    }
    if (v32) {
      unint64_t v32 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v32);
    }
    else {
      uint64_t v33 = 0;
    }
    uint64_t v34 = (void *)(v32 + 32 * v29);
    unint64_t v35 = v32 + 32 * v33;
    *uint64_t v34 = @"Downlink SPP Threshold";
    v34[1] = 0x8400000000000000;
    v34[2] = 0x3F80000000000000;
    v34[3] = -3241358131;
    double v28 = v34 + 4;
    unint64_t v37 = (char *)*a1;
    uint64_t v36 = (char *)a1[1];
    if (v36 != *a1)
    {
      do
      {
        long long v38 = *((_OWORD *)v36 - 1);
        *((_OWORD *)v34 - 2) = *((_OWORD *)v36 - 2);
        *((_OWORD *)v34 - 1) = v38;
        v34 -= 4;
        v36 -= 32;
      }
      while (v36 != v37);
      uint64_t v36 = (char *)*a1;
    }
    *a1 = v34;
    a1[1] = v28;
    a1[2] = (void *)v35;
    if (v36) {
      operator delete(v36);
    }
  }
  else
  {
    *float32x4_t v16 = @"Downlink SPP Threshold";
    v16[1] = 0x8400000000000000;
    v16[2] = 0x3F80000000000000;
    v16[3] = -3241358131;
    double v28 = v16 + 4;
  }
  a1[1] = v28;
  unint64_t v39 = (unint64_t)a1[2];
  if ((unint64_t)v28 >= v39)
  {
    uint64_t v41 = ((char *)v28 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v41 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v42 = v39 - (void)*a1;
    uint64_t v43 = v42 >> 4;
    if (v42 >> 4 <= (unint64_t)(v41 + 1)) {
      uint64_t v43 = v41 + 1;
    }
    if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v44 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v44 = v43;
    }
    if (v44) {
      unint64_t v44 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v44);
    }
    else {
      uint64_t v45 = 0;
    }
    float v46 = (void *)(v44 + 32 * v41);
    unint64_t v47 = v44 + 32 * v45;
    *float v46 = @"Filter Bank Type";
    v46[1] = 0x8400000000000001;
    v46[2] = 0x3F80000000000000;
    v46[3] = 0x100000000;
    float v40 = v46 + 4;
    float v49 = (char *)*a1;
    float v48 = (char *)a1[1];
    if (v48 != *a1)
    {
      do
      {
        long long v50 = *((_OWORD *)v48 - 1);
        *((_OWORD *)v46 - 2) = *((_OWORD *)v48 - 2);
        *((_OWORD *)v46 - 1) = v50;
        v46 -= 4;
        v48 -= 32;
      }
      while (v48 != v49);
      float v48 = (char *)*a1;
    }
    *a1 = v46;
    a1[1] = v40;
    a1[2] = (void *)v47;
    if (v48) {
      operator delete(v48);
    }
  }
  else
  {
    *double v28 = @"Filter Bank Type";
    v28[1] = 0x8400000000000001;
    v28[2] = 0x3F80000000000000;
    v28[3] = 0x100000000;
    float v40 = v28 + 4;
  }
  a1[1] = v40;
  unint64_t v51 = (unint64_t)a1[2];
  if ((unint64_t)v40 >= v51)
  {
    uint64_t v53 = ((char *)v40 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v53 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v54 = v51 - (void)*a1;
    uint64_t v55 = v54 >> 4;
    if (v54 >> 4 <= (unint64_t)(v53 + 1)) {
      uint64_t v55 = v53 + 1;
    }
    if ((unint64_t)v54 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v56 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v56 = v55;
    }
    if (v56) {
      unint64_t v56 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v56);
    }
    else {
      uint64_t v57 = 0;
    }
    unint64_t v58 = (void *)(v56 + 32 * v53);
    unint64_t v59 = v56 + 32 * v57;
    void *v58 = @"Interpolation Type";
    v58[1] = 0x8400000000000001;
    v58[2] = 0x3F80000000000000;
    v58[3] = 0x100000000;
    char v52 = v58 + 4;
    vDSP_Length v61 = (char *)*a1;
    uint64_t v60 = (char *)a1[1];
    if (v60 != *a1)
    {
      do
      {
        long long v62 = *((_OWORD *)v60 - 1);
        *((_OWORD *)v58 - 2) = *((_OWORD *)v60 - 2);
        *((_OWORD *)v58 - 1) = v62;
        v58 -= 4;
        v60 -= 32;
      }
      while (v60 != v61);
      uint64_t v60 = (char *)*a1;
    }
    *a1 = v58;
    a1[1] = v52;
    a1[2] = (void *)v59;
    if (v60) {
      operator delete(v60);
    }
  }
  else
  {
    *float v40 = @"Interpolation Type";
    v40[1] = 0x8400000000000001;
    v40[2] = 0x3F80000000000000;
    v40[3] = 0x100000000;
    char v52 = v40 + 4;
  }
  a1[1] = v52;
  unint64_t v63 = (unint64_t)a1[2];
  if ((unint64_t)v52 >= v63)
  {
    uint64_t v65 = ((char *)v52 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v65 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v66 = v63 - (void)*a1;
    uint64_t v67 = v66 >> 4;
    if (v66 >> 4 <= (unint64_t)(v65 + 1)) {
      uint64_t v67 = v65 + 1;
    }
    if ((unint64_t)v66 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v68 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v68 = v67;
    }
    if (v68) {
      unint64_t v68 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v68);
    }
    else {
      uint64_t v69 = 0;
    }
    float v70 = (void *)(v68 + 32 * v65);
    unint64_t v71 = v68 + 32 * v69;
    *float v70 = @"Loud Speaker Calibration";
    v70[1] = 0x800000000000000DLL;
    v70[2] = 0x43160000C2480000;
    v70[3] = 0x242B40000;
    float v64 = v70 + 4;
    unint64_t v73 = (char *)*a1;
    float v72 = (char *)a1[1];
    if (v72 != *a1)
    {
      do
      {
        long long v74 = *((_OWORD *)v72 - 1);
        *((_OWORD *)v70 - 2) = *((_OWORD *)v72 - 2);
        *((_OWORD *)v70 - 1) = v74;
        v70 -= 4;
        v72 -= 32;
      }
      while (v72 != v73);
      float v72 = (char *)*a1;
    }
    *a1 = v70;
    a1[1] = v64;
    a1[2] = (void *)v71;
    if (v72) {
      operator delete(v72);
    }
  }
  else
  {
    *char v52 = @"Loud Speaker Calibration";
    v52[1] = 0x800000000000000DLL;
    v52[2] = 0x43160000C2480000;
    v52[3] = 0x242B40000;
    float v64 = v52 + 4;
  }
  a1[1] = v64;
  unint64_t v75 = (unint64_t)a1[2];
  if ((unint64_t)v64 >= v75)
  {
    uint64_t v77 = ((char *)v64 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v77 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v78 = v75 - (void)*a1;
    uint64_t v79 = v78 >> 4;
    if (v78 >> 4 <= (unint64_t)(v77 + 1)) {
      uint64_t v79 = v77 + 1;
    }
    if ((unint64_t)v78 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v80 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v80 = v79;
    }
    if (v80) {
      unint64_t v80 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v80);
    }
    else {
      uint64_t v81 = 0;
    }
    float v82 = (void *)(v80 + 32 * v77);
    unint64_t v83 = v80 + 32 * v81;
    *float v82 = @"Signal Power Smoothing Time";
    v82[1] = 0x8000000000000004;
    v82[2] = 0x4120000000000000;
    v82[3] = 0x240A00000;
    unint64_t v76 = v82 + 4;
    float v85 = (char *)*a1;
    float v84 = (char *)a1[1];
    if (v84 != *a1)
    {
      do
      {
        long long v86 = *((_OWORD *)v84 - 1);
        *((_OWORD *)v82 - 2) = *((_OWORD *)v84 - 2);
        *((_OWORD *)v82 - 1) = v86;
        v82 -= 4;
        v84 -= 32;
      }
      while (v84 != v85);
      float v84 = (char *)*a1;
    }
    *a1 = v82;
    a1[1] = v76;
    a1[2] = (void *)v83;
    if (v84) {
      operator delete(v84);
    }
  }
  else
  {
    *float v64 = @"Signal Power Smoothing Time";
    v64[1] = 0x8000000000000004;
    v64[2] = 0x4120000000000000;
    v64[3] = 0x240A00000;
    unint64_t v76 = v64 + 4;
  }
  a1[1] = v76;
  unint64_t v87 = (unint64_t)a1[2];
  if ((unint64_t)v76 >= v87)
  {
    uint64_t v89 = ((char *)v76 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v89 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v90 = v87 - (void)*a1;
    uint64_t v91 = v90 >> 4;
    if (v90 >> 4 <= (unint64_t)(v89 + 1)) {
      uint64_t v91 = v89 + 1;
    }
    if ((unint64_t)v90 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v92 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v92 = v91;
    }
    if (v92) {
      unint64_t v92 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v92);
    }
    else {
      uint64_t v93 = 0;
    }
    uint64_t v94 = (void *)(v92 + 32 * v89);
    unint64_t v95 = v92 + 32 * v93;
    *uint64_t v94 = @"Noise Power Attack Time";
    v94[1] = 0x8000000000000004;
    v94[2] = 0x4120000000000000;
    v94[3] = 0x23FC00000;
    BOOL v88 = v94 + 4;
    vDSP_Length v97 = (char *)*a1;
    uint64_t v96 = (char *)a1[1];
    if (v96 != *a1)
    {
      do
      {
        long long v98 = *((_OWORD *)v96 - 1);
        *((_OWORD *)v94 - 2) = *((_OWORD *)v96 - 2);
        *((_OWORD *)v94 - 1) = v98;
        v94 -= 4;
        v96 -= 32;
      }
      while (v96 != v97);
      uint64_t v96 = (char *)*a1;
    }
    *a1 = v94;
    a1[1] = v88;
    a1[2] = (void *)v95;
    if (v96) {
      operator delete(v96);
    }
  }
  else
  {
    *unint64_t v76 = @"Noise Power Attack Time";
    v76[1] = 0x8000000000000004;
    v76[2] = 0x4120000000000000;
    v76[3] = 0x23FC00000;
    BOOL v88 = v76 + 4;
  }
  a1[1] = v88;
  unint64_t v99 = (unint64_t)a1[2];
  if ((unint64_t)v88 >= v99)
  {
    uint64_t v101 = ((char *)v88 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v101 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v102 = v99 - (void)*a1;
    uint64_t v103 = v102 >> 4;
    if (v102 >> 4 <= (unint64_t)(v101 + 1)) {
      uint64_t v103 = v101 + 1;
    }
    if ((unint64_t)v102 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v104 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v104 = v103;
    }
    if (v104) {
      unint64_t v104 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v104);
    }
    else {
      uint64_t v105 = 0;
    }
    uint64_t v106 = (void *)(v104 + 32 * v101);
    unint64_t v107 = v104 + 32 * v105;
    *uint64_t v106 = @"Noise Power Release Time";
    v106[1] = 0x8000000000000004;
    v106[2] = 0x4120000000000000;
    v106[3] = 0x23F000000;
    float v100 = v106 + 4;
    vDSP_Length v109 = (char *)*a1;
    float v108 = (char *)a1[1];
    if (v108 != *a1)
    {
      do
      {
        long long v110 = *((_OWORD *)v108 - 1);
        *((_OWORD *)v106 - 2) = *((_OWORD *)v108 - 2);
        *((_OWORD *)v106 - 1) = v110;
        v106 -= 4;
        v108 -= 32;
      }
      while (v108 != v109);
      float v108 = (char *)*a1;
    }
    *a1 = v106;
    a1[1] = v100;
    a1[2] = (void *)v107;
    if (v108) {
      operator delete(v108);
    }
  }
  else
  {
    void *v88 = @"Noise Power Release Time";
    v88[1] = 0x8000000000000004;
    v88[2] = 0x4120000000000000;
    v88[3] = 0x23F000000;
    float v100 = v88 + 4;
  }
  a1[1] = v100;
  unint64_t v111 = (unint64_t)a1[2];
  if ((unint64_t)v100 >= v111)
  {
    uint64_t v113 = ((char *)v100 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v113 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v114 = v111 - (void)*a1;
    uint64_t v115 = v114 >> 4;
    if (v114 >> 4 <= (unint64_t)(v113 + 1)) {
      uint64_t v115 = v113 + 1;
    }
    if ((unint64_t)v114 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v116 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v116 = v115;
    }
    if (v116) {
      unint64_t v116 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v116);
    }
    else {
      uint64_t v117 = 0;
    }
    float v118 = (void *)(v116 + 32 * v113);
    unint64_t v119 = v116 + 32 * v117;
    *float v118 = @"Environmental Noise Power (dBA)";
    v118[1] = 0x80000000000DLL;
    v118[2] = 0x43020000C0A00000;
    v118[3] = 0x241A00000;
    unint64_t v112 = v118 + 4;
    float v121 = (char *)*a1;
    float v120 = (char *)a1[1];
    if (v120 != *a1)
    {
      do
      {
        long long v122 = *((_OWORD *)v120 - 1);
        *((_OWORD *)v118 - 2) = *((_OWORD *)v120 - 2);
        *((_OWORD *)v118 - 1) = v122;
        v118 -= 4;
        v120 -= 32;
      }
      while (v120 != v121);
      float v120 = (char *)*a1;
    }
    *a1 = v118;
    a1[1] = v112;
    a1[2] = (void *)v119;
    if (v120) {
      operator delete(v120);
    }
  }
  else
  {
    *float v100 = @"Environmental Noise Power (dBA)";
    v100[1] = 0x80000000000DLL;
    v100[2] = 0x43020000C0A00000;
    void v100[3] = 0x241A00000;
    unint64_t v112 = v100 + 4;
  }
  a1[1] = v112;
  unint64_t v123 = (unint64_t)a1[2];
  if ((unint64_t)v112 >= v123)
  {
    uint64_t v125 = ((char *)v112 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v125 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v126 = v123 - (void)*a1;
    uint64_t v127 = v126 >> 4;
    if (v126 >> 4 <= (unint64_t)(v125 + 1)) {
      uint64_t v127 = v125 + 1;
    }
    if ((unint64_t)v126 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v128 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v128 = v127;
    }
    if (v128) {
      unint64_t v128 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v128);
    }
    else {
      uint64_t v129 = 0;
    }
    int v130 = (void *)(v128 + 32 * v125);
    unint64_t v131 = v128 + 32 * v129;
    void *v130 = @"Auto Volume Low Noise";
    v130[1] = 0x800000000000000DLL;
    v130[2] = 0x42F0000000000000;
    v130[3] = 0x342480000;
    uint64_t v124 = v130 + 4;
    float v133 = (char *)*a1;
    uint64_t v132 = (char *)a1[1];
    if (v132 != *a1)
    {
      do
      {
        long long v134 = *((_OWORD *)v132 - 1);
        *((_OWORD *)v130 - 2) = *((_OWORD *)v132 - 2);
        *((_OWORD *)v130 - 1) = v134;
        v130 -= 4;
        v132 -= 32;
      }
      while (v132 != v133);
      uint64_t v132 = (char *)*a1;
    }
    *a1 = v130;
    a1[1] = v124;
    a1[2] = (void *)v131;
    if (v132) {
      operator delete(v132);
    }
  }
  else
  {
    void *v112 = @"Auto Volume Low Noise";
    v112[1] = 0x800000000000000DLL;
    v112[2] = 0x42F0000000000000;
    v112[3] = 0x342480000;
    uint64_t v124 = v112 + 4;
  }
  a1[1] = v124;
  unint64_t v135 = (unint64_t)a1[2];
  if ((unint64_t)v124 >= v135)
  {
    uint64_t v137 = ((char *)v124 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v137 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v138 = v135 - (void)*a1;
    uint64_t v139 = v138 >> 4;
    if (v138 >> 4 <= (unint64_t)(v137 + 1)) {
      uint64_t v139 = v137 + 1;
    }
    if ((unint64_t)v138 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v140 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v140 = v139;
    }
    if (v140) {
      unint64_t v140 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v140);
    }
    else {
      uint64_t v141 = 0;
    }
    uint64_t v142 = (void *)(v140 + 32 * v137);
    unint64_t v143 = v140 + 32 * v141;
    void *v142 = @"Auto Volume High Noise";
    v142[1] = 0x800000000000000DLL;
    v142[2] = 0x42F0000000000000;
    v142[3] = 0x342C80000;
    uint64_t v136 = v142 + 4;
    char v145 = (char *)*a1;
    vDSP_Length v144 = (char *)a1[1];
    if (v144 != *a1)
    {
      do
      {
        long long v146 = *((_OWORD *)v144 - 1);
        *((_OWORD *)v142 - 2) = *((_OWORD *)v144 - 2);
        *((_OWORD *)v142 - 1) = v146;
        v142 -= 4;
        v144 -= 32;
      }
      while (v144 != v145);
      vDSP_Length v144 = (char *)*a1;
    }
    *a1 = v142;
    a1[1] = v136;
    a1[2] = (void *)v143;
    if (v144) {
      operator delete(v144);
    }
  }
  else
  {
    *uint64_t v124 = @"Auto Volume High Noise";
    v124[1] = 0x800000000000000DLL;
    v124[2] = 0x42F0000000000000;
    v124[3] = 0x342C80000;
    uint64_t v136 = v124 + 4;
  }
  a1[1] = v136;
  unint64_t v147 = (unint64_t)a1[2];
  if ((unint64_t)v136 >= v147)
  {
    uint64_t v149 = ((char *)v136 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v149 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v150 = v147 - (void)*a1;
    uint64_t v151 = v150 >> 4;
    if (v150 >> 4 <= (unint64_t)(v149 + 1)) {
      uint64_t v151 = v149 + 1;
    }
    if ((unint64_t)v150 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v152 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v152 = v151;
    }
    if (v152) {
      unint64_t v152 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v152);
    }
    else {
      uint64_t v153 = 0;
    }
    float v154 = (void *)(v152 + 32 * v149);
    unint64_t v155 = v152 + 32 * v153;
    *float v154 = @"Auto Volume Low Slope";
    v154[1] = 0x8000000000000000;
    v154[2] = 0x3F80000000000000;
    v154[3] = 0x33EA8F5C3;
    BOOL v148 = v154 + 4;
    float v157 = (char *)*a1;
    uint64_t v156 = (char *)a1[1];
    if (v156 != *a1)
    {
      do
      {
        long long v158 = *((_OWORD *)v156 - 1);
        *((_OWORD *)v154 - 2) = *((_OWORD *)v156 - 2);
        *((_OWORD *)v154 - 1) = v158;
        v154 -= 4;
        v156 -= 32;
      }
      while (v156 != v157);
      uint64_t v156 = (char *)*a1;
    }
    *a1 = v154;
    a1[1] = v148;
    a1[2] = (void *)v155;
    if (v156) {
      operator delete(v156);
    }
  }
  else
  {
    *uint64_t v136 = @"Auto Volume Low Slope";
    v136[1] = 0x8000000000000000;
    v136[2] = 0x3F80000000000000;
    v136[3] = 0x33EA8F5C3;
    BOOL v148 = v136 + 4;
  }
  a1[1] = v148;
  unint64_t v159 = (unint64_t)a1[2];
  if ((unint64_t)v148 >= v159)
  {
    uint64_t v161 = ((char *)v148 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v161 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v162 = v159 - (void)*a1;
    uint64_t v163 = v162 >> 4;
    if (v162 >> 4 <= (unint64_t)(v161 + 1)) {
      uint64_t v163 = v161 + 1;
    }
    if ((unint64_t)v162 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v164 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v164 = v163;
    }
    if (v164) {
      unint64_t v164 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v164);
    }
    else {
      uint64_t v165 = 0;
    }
    vDSP_Length v166 = (void *)(v164 + 32 * v161);
    unint64_t v167 = v164 + 32 * v165;
    void *v166 = @"Auto Volume High Slope";
    v166[1] = 0x8000000000000000;
    v166[2] = 0x3F80000000000000;
    v166[3] = 0x33F4CCCCDLL;
    vDSP_Length v160 = v166 + 4;
    vDSP_Length v169 = (char *)*a1;
    uint64_t v168 = (char *)a1[1];
    if (v168 != *a1)
    {
      do
      {
        long long v170 = *((_OWORD *)v168 - 1);
        *((_OWORD *)v166 - 2) = *((_OWORD *)v168 - 2);
        *((_OWORD *)v166 - 1) = v170;
        v166 -= 4;
        v168 -= 32;
      }
      while (v168 != v169);
      uint64_t v168 = (char *)*a1;
    }
    *a1 = v166;
    a1[1] = v160;
    a1[2] = (void *)v167;
    if (v168) {
      operator delete(v168);
    }
  }
  else
  {
    void *v148 = @"Auto Volume High Slope";
    v148[1] = 0x8000000000000000;
    v148[2] = 0x3F80000000000000;
    v148[3] = 0x33F4CCCCDLL;
    vDSP_Length v160 = v148 + 4;
  }
  a1[1] = v160;
  unint64_t v171 = (unint64_t)a1[2];
  if ((unint64_t)v160 >= v171)
  {
    uint64_t v173 = ((char *)v160 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v173 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v174 = v171 - (void)*a1;
    uint64_t v175 = v174 >> 4;
    if (v174 >> 4 <= (unint64_t)(v173 + 1)) {
      uint64_t v175 = v173 + 1;
    }
    if ((unint64_t)v174 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v176 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v176 = v175;
    }
    if (v176) {
      unint64_t v176 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v176);
    }
    else {
      uint64_t v177 = 0;
    }
    float32x2_t v178 = (void *)(v176 + 32 * v173);
    unint64_t v179 = v176 + 32 * v177;
    void *v178 = @"Total Volume Max Gain";
    v178[1] = 0x800000000000000DLL;
    v178[2] = 0x41700000C1200000;
    v178[3] = 0x300000000;
    vDSP_Length v172 = v178 + 4;
    unsigned __int8 v181 = (char *)*a1;
    unsigned __int8 v180 = (char *)a1[1];
    if (v180 != *a1)
    {
      do
      {
        long long v182 = *((_OWORD *)v180 - 1);
        *((_OWORD *)v178 - 2) = *((_OWORD *)v180 - 2);
        *((_OWORD *)v178 - 1) = v182;
        v178 -= 4;
        v180 -= 32;
      }
      while (v180 != v181);
      unsigned __int8 v180 = (char *)*a1;
    }
    *a1 = v178;
    a1[1] = v172;
    a1[2] = (void *)v179;
    if (v180) {
      operator delete(v180);
    }
  }
  else
  {
    void *v160 = @"Total Volume Max Gain";
    v160[1] = 0x800000000000000DLL;
    v160[2] = 0x41700000C1200000;
    v160[3] = 0x300000000;
    vDSP_Length v172 = v160 + 4;
  }
  a1[1] = v172;
  unint64_t v183 = (unint64_t)a1[2];
  if ((unint64_t)v172 >= v183)
  {
    uint64_t v185 = ((char *)v172 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v185 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v186 = v183 - (void)*a1;
    uint64_t v187 = v186 >> 4;
    if (v186 >> 4 <= (unint64_t)(v185 + 1)) {
      uint64_t v187 = v185 + 1;
    }
    if ((unint64_t)v186 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v188 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v188 = v187;
    }
    if (v188) {
      unint64_t v188 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v188);
    }
    else {
      uint64_t v189 = 0;
    }
    float v190 = (void *)(v188 + 32 * v185);
    unint64_t v191 = v188 + 32 * v189;
    *float v190 = @"Pre Auto Volume SNR (dBA)";
    v190[1] = 0x80000000000DLL;
    v190[2] = 0x42480000C2480000;
    v190[3] = 0x300000000;
    vDSP_Length v184 = v190 + 4;
    float v193 = (char *)*a1;
    int v192 = (char *)a1[1];
    if (v192 != *a1)
    {
      do
      {
        long long v194 = *((_OWORD *)v192 - 1);
        *((_OWORD *)v190 - 2) = *((_OWORD *)v192 - 2);
        *((_OWORD *)v190 - 1) = v194;
        v190 -= 4;
        v192 -= 32;
      }
      while (v192 != v193);
      int v192 = (char *)*a1;
    }
    *a1 = v190;
    a1[1] = v184;
    a1[2] = (void *)v191;
    if (v192) {
      operator delete(v192);
    }
  }
  else
  {
    void *v172 = @"Pre Auto Volume SNR (dBA)";
    v172[1] = 0x80000000000DLL;
    v172[2] = 0x42480000C2480000;
    v172[3] = 0x300000000;
    vDSP_Length v184 = v172 + 4;
  }
  a1[1] = v184;
  unint64_t v195 = (unint64_t)a1[2];
  if ((unint64_t)v184 >= v195)
  {
    uint64_t v197 = ((char *)v184 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v197 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v198 = v195 - (void)*a1;
    uint64_t v199 = v198 >> 4;
    if (v198 >> 4 <= (unint64_t)(v197 + 1)) {
      uint64_t v199 = v197 + 1;
    }
    if ((unint64_t)v198 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v200 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v200 = v199;
    }
    if (v200) {
      unint64_t v200 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v200);
    }
    else {
      uint64_t v201 = 0;
    }
    unint64_t v202 = (void *)(v200 + 32 * v197);
    unint64_t v203 = v200 + 32 * v201;
    *unint64_t v202 = @"Current Auto Volume Gain";
    v202[1] = 0x80000000000DLL;
    v202[2] = 0x41F00000C0A00000;
    float v202[3] = 0x300000000;
    vDSP_Length v196 = v202 + 4;
    int v205 = (char *)*a1;
    std::string::size_type v204 = (char *)a1[1];
    if (v204 != *a1)
    {
      do
      {
        long long v206 = *((_OWORD *)v204 - 1);
        *((_OWORD *)v202 - 2) = *((_OWORD *)v204 - 2);
        *((_OWORD *)v202 - 1) = v206;
        v202 -= 4;
        v204 -= 32;
      }
      while (v204 != v205);
      std::string::size_type v204 = (char *)*a1;
    }
    *a1 = v202;
    a1[1] = v196;
    a1[2] = (void *)v203;
    if (v204) {
      operator delete(v204);
    }
  }
  else
  {
    void *v184 = @"Current Auto Volume Gain";
    v184[1] = 0x80000000000DLL;
    v184[2] = 0x41F00000C0A00000;
    v184[3] = 0x300000000;
    vDSP_Length v196 = v184 + 4;
  }
  a1[1] = v196;
  unint64_t v207 = (unint64_t)a1[2];
  if ((unint64_t)v196 >= v207)
  {
    uint64_t v209 = ((char *)v196 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v209 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v210 = v207 - (void)*a1;
    uint64_t v211 = v210 >> 4;
    if (v210 >> 4 <= (unint64_t)(v209 + 1)) {
      uint64_t v211 = v209 + 1;
    }
    if ((unint64_t)v210 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v212 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v212 = v211;
    }
    if (v212) {
      unint64_t v212 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v212);
    }
    else {
      uint64_t v213 = 0;
    }
    v214 = (void *)(v212 + 32 * v209);
    unint64_t v215 = v212 + 32 * v213;
    void *v214 = @"Bypass Auto EQ";
    v214[1] = 0x8000000000000002;
    v214[2] = 0x3F80000000000000;
    v214[3] = 0x400000000;
    unsigned __int8 v208 = v214 + 4;
    char v217 = (char *)*a1;
    v216 = (char *)a1[1];
    if (v216 != *a1)
    {
      do
      {
        long long v218 = *((_OWORD *)v216 - 1);
        *((_OWORD *)v214 - 2) = *((_OWORD *)v216 - 2);
        *((_OWORD *)v214 - 1) = v218;
        v214 -= 4;
        v216 -= 32;
      }
      while (v216 != v217);
      v216 = (char *)*a1;
    }
    *a1 = v214;
    a1[1] = v208;
    a1[2] = (void *)v215;
    if (v216) {
      operator delete(v216);
    }
  }
  else
  {
    *vDSP_Length v196 = @"Bypass Auto EQ";
    v196[1] = 0x8000000000000002;
    v196[2] = 0x3F80000000000000;
    v196[3] = 0x400000000;
    unsigned __int8 v208 = v196 + 4;
  }
  a1[1] = v208;
  unint64_t v219 = (unint64_t)a1[2];
  if ((unint64_t)v208 >= v219)
  {
    uint64_t v221 = ((char *)v208 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v221 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v222 = v219 - (void)*a1;
    uint64_t v223 = v222 >> 4;
    if (v222 >> 4 <= (unint64_t)(v221 + 1)) {
      uint64_t v223 = v221 + 1;
    }
    if ((unint64_t)v222 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v224 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v224 = v223;
    }
    if (v224) {
      unint64_t v224 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v224);
    }
    else {
      uint64_t v225 = 0;
    }
    char v226 = (void *)(v224 + 32 * v221);
    unint64_t v227 = v224 + 32 * v225;
    *char v226 = @"EQ Bandwidth";
    v226[1] = 0x8000000000000008;
    v226[2] = 0x469C400042C80000;
    v226[3] = 0x445FA0000;
    uint64_t v220 = v226 + 4;
    int v229 = (char *)*a1;
    int v228 = (char *)a1[1];
    if (v228 != *a1)
    {
      do
      {
        long long v230 = *((_OWORD *)v228 - 1);
        *((_OWORD *)v226 - 2) = *((_OWORD *)v228 - 2);
        *((_OWORD *)v226 - 1) = v230;
        v226 -= 4;
        v228 -= 32;
      }
      while (v228 != v229);
      int v228 = (char *)*a1;
    }
    *a1 = v226;
    a1[1] = v220;
    a1[2] = (void *)v227;
    if (v228) {
      operator delete(v228);
    }
  }
  else
  {
    *unsigned __int8 v208 = @"EQ Bandwidth";
    v208[1] = 0x8000000000000008;
    v208[2] = 0x469C400042C80000;
    v208[3] = 0x445FA0000;
    uint64_t v220 = v208 + 4;
  }
  a1[1] = v220;
  unint64_t v231 = (unint64_t)a1[2];
  if ((unint64_t)v220 >= v231)
  {
    uint64_t v233 = ((char *)v220 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v233 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v234 = v231 - (void)*a1;
    uint64_t v235 = v234 >> 4;
    if (v234 >> 4 <= (unint64_t)(v233 + 1)) {
      uint64_t v235 = v233 + 1;
    }
    if ((unint64_t)v234 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v236 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v236 = v235;
    }
    if (v236) {
      unint64_t v236 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v236);
    }
    else {
      uint64_t v237 = 0;
    }
    uint64_t v238 = (void *)(v236 + 32 * v233);
    unint64_t v239 = v236 + 32 * v237;
    *uint64_t v238 = @"Regularization High SNR";
    v238[1] = 0x800000000000000DLL;
    v238[2] = 0x4248000040A00000;
    v238[3] = 0x441200000;
    uint64_t v232 = v238 + 4;
    unint64_t v241 = (char *)*a1;
    v240 = (char *)a1[1];
    if (v240 != *a1)
    {
      do
      {
        long long v242 = *((_OWORD *)v240 - 1);
        *((_OWORD *)v238 - 2) = *((_OWORD *)v240 - 2);
        *((_OWORD *)v238 - 1) = v242;
        v238 -= 4;
        v240 -= 32;
      }
      while (v240 != v241);
      v240 = (char *)*a1;
    }
    *a1 = v238;
    a1[1] = v232;
    a1[2] = (void *)v239;
    if (v240) {
      operator delete(v240);
    }
  }
  else
  {
    *uint64_t v220 = @"Regularization High SNR";
    v220[1] = 0x800000000000000DLL;
    v220[2] = 0x4248000040A00000;
    v220[3] = 0x441200000;
    uint64_t v232 = v220 + 4;
  }
  a1[1] = v232;
  unint64_t v243 = (unint64_t)a1[2];
  if ((unint64_t)v232 >= v243)
  {
    uint64_t v245 = ((char *)v232 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v245 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v246 = v243 - (void)*a1;
    uint64_t v247 = v246 >> 4;
    if (v246 >> 4 <= (unint64_t)(v245 + 1)) {
      uint64_t v247 = v245 + 1;
    }
    if ((unint64_t)v246 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v248 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v248 = v247;
    }
    if (v248) {
      unint64_t v248 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v248);
    }
    else {
      uint64_t v249 = 0;
    }
    v250 = (void *)(v248 + 32 * v245);
    unint64_t v251 = v248 + 32 * v249;
    void *v250 = @"EQ Min Gain (low freq)";
    v250[1] = 0x800000000000000DLL;
    v250[2] = 3248488448;
    v250[3] = 0x4C0A00000;
    int v244 = v250 + 4;
    uint64_t v253 = (char *)*a1;
    char v252 = (char *)a1[1];
    if (v252 != *a1)
    {
      do
      {
        long long v254 = *((_OWORD *)v252 - 1);
        *((_OWORD *)v250 - 2) = *((_OWORD *)v252 - 2);
        *((_OWORD *)v250 - 1) = v254;
        v250 -= 4;
        v252 -= 32;
      }
      while (v252 != v253);
      char v252 = (char *)*a1;
    }
    *a1 = v250;
    a1[1] = v244;
    a1[2] = (void *)v251;
    if (v252) {
      operator delete(v252);
    }
  }
  else
  {
    *uint64_t v232 = @"EQ Min Gain (low freq)";
    v232[1] = 0x800000000000000DLL;
    v232[2] = 3248488448;
    v232[3] = 0x4C0A00000;
    int v244 = v232 + 4;
  }
  a1[1] = v244;
  unint64_t v255 = (unint64_t)a1[2];
  if ((unint64_t)v244 >= v255)
  {
    uint64_t v257 = ((char *)v244 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v257 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v258 = v255 - (void)*a1;
    uint64_t v259 = v258 >> 4;
    if (v258 >> 4 <= (unint64_t)(v257 + 1)) {
      uint64_t v259 = v257 + 1;
    }
    if ((unint64_t)v258 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v260 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v260 = v259;
    }
    if (v260) {
      unint64_t v260 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v260);
    }
    else {
      uint64_t v261 = 0;
    }
    unint64_t v262 = (void *)(v260 + 32 * v257);
    unint64_t v263 = v260 + 32 * v261;
    *unint64_t v262 = @"EQ Max Gain (low freq)";
    v262[1] = 0x800000000000000DLL;
    v262[2] = 0x41A0000000000000;
    v262[3] = 0x441200000;
    v256 = v262 + 4;
    uint64_t v265 = (char *)*a1;
    uint64_t v264 = (char *)a1[1];
    if (v264 != *a1)
    {
      do
      {
        long long v266 = *((_OWORD *)v264 - 1);
        *((_OWORD *)v262 - 2) = *((_OWORD *)v264 - 2);
        *((_OWORD *)v262 - 1) = v266;
        v262 -= 4;
        v264 -= 32;
      }
      while (v264 != v265);
      uint64_t v264 = (char *)*a1;
    }
    *a1 = v262;
    a1[1] = v256;
    a1[2] = (void *)v263;
    if (v264) {
      operator delete(v264);
    }
  }
  else
  {
    *int v244 = @"EQ Max Gain (low freq)";
    v244[1] = 0x800000000000000DLL;
    v244[2] = 0x41A0000000000000;
    v244[3] = 0x441200000;
    v256 = v244 + 4;
  }
  a1[1] = v256;
  unint64_t v267 = (unint64_t)a1[2];
  if ((unint64_t)v256 >= v267)
  {
    uint64_t v269 = ((char *)v256 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v269 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v270 = v267 - (void)*a1;
    uint64_t v271 = v270 >> 4;
    if (v270 >> 4 <= (unint64_t)(v269 + 1)) {
      uint64_t v271 = v269 + 1;
    }
    if ((unint64_t)v270 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v272 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v272 = v271;
    }
    if (v272) {
      unint64_t v272 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v272);
    }
    else {
      uint64_t v273 = 0;
    }
    uint64_t v274 = (void *)(v272 + 32 * v269);
    unint64_t v275 = v272 + 32 * v273;
    *uint64_t v274 = @"Pre EQ Signal Power (dBA)";
    v274[1] = 0x80000000000DLL;
    v274[2] = 0x43020000C0A00000;
    v274[3] = 0x441A00000;
    v268 = v274 + 4;
    v277 = (char *)*a1;
    v276 = (char *)a1[1];
    if (v276 != *a1)
    {
      do
      {
        long long v278 = *((_OWORD *)v276 - 1);
        *((_OWORD *)v274 - 2) = *((_OWORD *)v276 - 2);
        *((_OWORD *)v274 - 1) = v278;
        v274 -= 4;
        v276 -= 32;
      }
      while (v276 != v277);
      v276 = (char *)*a1;
    }
    *a1 = v274;
    a1[1] = v268;
    a1[2] = (void *)v275;
    if (v276) {
      operator delete(v276);
    }
  }
  else
  {
    void *v256 = @"Pre EQ Signal Power (dBA)";
    v256[1] = 0x80000000000DLL;
    v256[2] = 0x43020000C0A00000;
    v256[3] = 0x441A00000;
    v268 = v256 + 4;
  }
  a1[1] = v268;
  unint64_t v279 = (unint64_t)a1[2];
  if ((unint64_t)v268 >= v279)
  {
    uint64_t v281 = ((char *)v268 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v281 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v282 = v279 - (void)*a1;
    uint64_t v283 = v282 >> 4;
    if (v282 >> 4 <= (unint64_t)(v281 + 1)) {
      uint64_t v283 = v281 + 1;
    }
    if ((unint64_t)v282 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v284 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v284 = v283;
    }
    if (v284) {
      unint64_t v284 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v284);
    }
    else {
      uint64_t v285 = 0;
    }
    v286 = (void *)(v284 + 32 * v281);
    unint64_t v287 = v284 + 32 * v285;
    void *v286 = @"Num Iterations to Converge EQ";
    v286[1] = 0x400800000000000;
    v286[2] = 0x4348000000000000;
    v286[3] = 0x400000000;
    uint64_t v280 = v286 + 4;
    uint64_t v289 = (char *)*a1;
    v288 = (char *)a1[1];
    if (v288 != *a1)
    {
      do
      {
        long long v290 = *((_OWORD *)v288 - 1);
        *((_OWORD *)v286 - 2) = *((_OWORD *)v288 - 2);
        *((_OWORD *)v286 - 1) = v290;
        v286 -= 4;
        v288 -= 32;
      }
      while (v288 != v289);
      v288 = (char *)*a1;
    }
    *a1 = v286;
    a1[1] = v280;
    a1[2] = (void *)v287;
    if (v288) {
      operator delete(v288);
    }
  }
  else
  {
    void *v268 = @"Num Iterations to Converge EQ";
    v268[1] = 0x400800000000000;
    v268[2] = 0x4348000000000000;
    v268[3] = 0x400000000;
    uint64_t v280 = v268 + 4;
  }
  a1[1] = v280;
  unint64_t v291 = (unint64_t)a1[2];
  if ((unint64_t)v280 >= v291)
  {
    uint64_t v293 = ((char *)v280 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v293 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v294 = v291 - (void)*a1;
    uint64_t v295 = v294 >> 4;
    if (v294 >> 4 <= (unint64_t)(v293 + 1)) {
      uint64_t v295 = v293 + 1;
    }
    if ((unint64_t)v294 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v296 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v296 = v295;
    }
    if (v296) {
      unint64_t v296 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v296);
    }
    else {
      uint64_t v297 = 0;
    }
    unint64_t v298 = (void *)(v296 + 32 * v293);
    unint64_t v299 = v296 + 32 * v297;
    *unint64_t v298 = @"Use Tabulated Speech PSD";
    v298[1] = 0x8400000000000002;
    v298[2] = 0x3F80000000000000;
    v298[3] = -3229614080;
    __int16 v292 = v298 + 4;
    long long v301 = (char *)*a1;
    v300 = (char *)a1[1];
    if (v300 != *a1)
    {
      do
      {
        long long v302 = *((_OWORD *)v300 - 1);
        *((_OWORD *)v298 - 2) = *((_OWORD *)v300 - 2);
        *((_OWORD *)v298 - 1) = v302;
        v298 -= 4;
        v300 -= 32;
      }
      while (v300 != v301);
      v300 = (char *)*a1;
    }
    *a1 = v298;
    a1[1] = v292;
    a1[2] = (void *)v299;
    if (v300) {
      operator delete(v300);
    }
  }
  else
  {
    *uint64_t v280 = @"Use Tabulated Speech PSD";
    v280[1] = 0x8400000000000002;
    v280[2] = 0x3F80000000000000;
    v280[3] = -3229614080;
    __int16 v292 = v280 + 4;
  }
  a1[1] = v292;
  unint64_t v303 = (unint64_t)a1[2];
  if ((unint64_t)v292 >= v303)
  {
    uint64_t v305 = ((char *)v292 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v305 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v306 = v303 - (void)*a1;
    uint64_t v307 = v306 >> 4;
    if (v306 >> 4 <= (unint64_t)(v305 + 1)) {
      uint64_t v307 = v305 + 1;
    }
    if ((unint64_t)v306 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v308 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v308 = v307;
    }
    if (v308) {
      unint64_t v308 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v308);
    }
    else {
      uint64_t v309 = 0;
    }
    v310 = (void *)(v308 + 32 * v305);
    unint64_t v311 = v308 + 32 * v309;
    void *v310 = @"Enable EQ Display (expert mode)";
    v310[1] = 0x8000000000000002;
    v310[2] = 0x3F80000000000000;
    v310[3] = 0x500000000;
    v304 = v310 + 4;
    v313 = (char *)*a1;
    v312 = (char *)a1[1];
    if (v312 != *a1)
    {
      do
      {
        long long v314 = *((_OWORD *)v312 - 1);
        *((_OWORD *)v310 - 2) = *((_OWORD *)v312 - 2);
        *((_OWORD *)v310 - 1) = v314;
        v310 -= 4;
        v312 -= 32;
      }
      while (v312 != v313);
      v312 = (char *)*a1;
    }
    *a1 = v310;
    a1[1] = v304;
    a1[2] = (void *)v311;
    if (v312) {
      operator delete(v312);
    }
  }
  else
  {
    *__int16 v292 = @"Enable EQ Display (expert mode)";
    v292[1] = 0x8000000000000002;
    v292[2] = 0x3F80000000000000;
    v292[3] = 0x500000000;
    v304 = v292 + 4;
  }
  a1[1] = v304;
  unint64_t v315 = (unint64_t)a1[2];
  if ((unint64_t)v304 >= v315)
  {
    uint64_t v317 = ((char *)v304 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v317 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v318 = v315 - (void)*a1;
    uint64_t v319 = v318 >> 4;
    if (v318 >> 4 <= (unint64_t)(v317 + 1)) {
      uint64_t v319 = v317 + 1;
    }
    if ((unint64_t)v318 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v320 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v320 = v319;
    }
    if (v320) {
      unint64_t v320 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v320);
    }
    else {
      uint64_t v321 = 0;
    }
    v322 = (void *)(v320 + 32 * v317);
    unint64_t v323 = v320 + 32 * v321;
    void *v322 = @"Current User Volume Gain";
    v322[1] = 0x40080000000000DLL;
    v322[2] = 0x41700000C1F00000;
    v322[3] = 0x300000000;
    v316 = v322 + 4;
    v325 = (char *)*a1;
    v324 = (char *)a1[1];
    if (v324 != *a1)
    {
      do
      {
        long long v326 = *((_OWORD *)v324 - 1);
        *((_OWORD *)v322 - 2) = *((_OWORD *)v324 - 2);
        *((_OWORD *)v322 - 1) = v326;
        v322 -= 4;
        v324 -= 32;
      }
      while (v324 != v325);
      v324 = (char *)*a1;
    }
    *a1 = v322;
    a1[1] = v316;
    a1[2] = (void *)v323;
    if (v324) {
      operator delete(v324);
    }
  }
  else
  {
    void *v304 = @"Current User Volume Gain";
    v304[1] = 0x40080000000000DLL;
    v304[2] = 0x41700000C1F00000;
    v304[3] = 0x300000000;
    v316 = v304 + 4;
  }
  a1[1] = v316;
  unint64_t v327 = (unint64_t)a1[2];
  if ((unint64_t)v316 >= v327)
  {
    uint64_t v329 = ((char *)v316 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v329 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v330 = v327 - (void)*a1;
    uint64_t v331 = v330 >> 4;
    if (v330 >> 4 <= (unint64_t)(v329 + 1)) {
      uint64_t v331 = v329 + 1;
    }
    if ((unint64_t)v330 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v332 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v332 = v331;
    }
    if (v332) {
      unint64_t v332 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v332);
    }
    else {
      uint64_t v333 = 0;
    }
    v334 = (void *)(v332 + 32 * v329);
    unint64_t v335 = v332 + 32 * v333;
    void *v334 = @"Current Total Volume Gain";
    v334[1] = 0x80000000000DLL;
    v334[2] = 0x41700000C1F00000;
    v334[3] = 0x300000000;
    v328 = v334 + 4;
    v337 = (char *)*a1;
    v336 = (char *)a1[1];
    if (v336 != *a1)
    {
      do
      {
        long long v338 = *((_OWORD *)v336 - 1);
        *((_OWORD *)v334 - 2) = *((_OWORD *)v336 - 2);
        *((_OWORD *)v334 - 1) = v338;
        v334 -= 4;
        v336 -= 32;
      }
      while (v336 != v337);
      v336 = (char *)*a1;
    }
    *a1 = v334;
    a1[1] = v328;
    a1[2] = (void *)v335;
    if (v336) {
      operator delete(v336);
    }
  }
  else
  {
    void *v316 = @"Current Total Volume Gain";
    v316[1] = 0x80000000000DLL;
    v316[2] = 0x41700000C1F00000;
    v316[3] = 0x300000000;
    v328 = v316 + 4;
  }
  a1[1] = v328;
  unint64_t v339 = (unint64_t)a1[2];
  if ((unint64_t)v328 >= v339)
  {
    uint64_t v341 = ((char *)v328 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v341 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v342 = v339 - (void)*a1;
    uint64_t v343 = v342 >> 4;
    if (v342 >> 4 <= (unint64_t)(v341 + 1)) {
      uint64_t v343 = v341 + 1;
    }
    if ((unint64_t)v342 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v344 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v344 = v343;
    }
    if (v344) {
      unint64_t v344 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v344);
    }
    else {
      uint64_t v345 = 0;
    }
    v346 = (void *)(v344 + 32 * v341);
    unint64_t v347 = v344 + 32 * v345;
    void *v346 = @"EQ Min Gain (high freq)";
    v346[1] = 0x800000000000000DLL;
    v346[2] = 3248488448;
    v346[3] = 0x4C0A00000;
    v340 = v346 + 4;
    v349 = (char *)*a1;
    v348 = (char *)a1[1];
    if (v348 != *a1)
    {
      do
      {
        long long v350 = *((_OWORD *)v348 - 1);
        *((_OWORD *)v346 - 2) = *((_OWORD *)v348 - 2);
        *((_OWORD *)v346 - 1) = v350;
        v346 -= 4;
        v348 -= 32;
      }
      while (v348 != v349);
      v348 = (char *)*a1;
    }
    *a1 = v346;
    a1[1] = v340;
    a1[2] = (void *)v347;
    if (v348) {
      operator delete(v348);
    }
  }
  else
  {
    void *v328 = @"EQ Min Gain (high freq)";
    v328[1] = 0x800000000000000DLL;
    v328[2] = 3248488448;
    v328[3] = 0x4C0A00000;
    v340 = v328 + 4;
  }
  a1[1] = v340;
  unint64_t v351 = (unint64_t)a1[2];
  if ((unint64_t)v340 >= v351)
  {
    uint64_t v353 = ((char *)v340 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v353 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v354 = v351 - (void)*a1;
    uint64_t v355 = v354 >> 4;
    if (v354 >> 4 <= (unint64_t)(v353 + 1)) {
      uint64_t v355 = v353 + 1;
    }
    if ((unint64_t)v354 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v356 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v356 = v355;
    }
    if (v356) {
      unint64_t v356 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v356);
    }
    else {
      uint64_t v357 = 0;
    }
    v358 = (void *)(v356 + 32 * v353);
    unint64_t v359 = v356 + 32 * v357;
    void *v358 = @"EQ Max Gain (high freq)";
    v358[1] = 0x800000000000000DLL;
    v358[2] = 0x41A0000000000000;
    v358[3] = 0x441200000;
    v352 = v358 + 4;
    v361 = (char *)*a1;
    v360 = (char *)a1[1];
    if (v360 != *a1)
    {
      do
      {
        long long v362 = *((_OWORD *)v360 - 1);
        *((_OWORD *)v358 - 2) = *((_OWORD *)v360 - 2);
        *((_OWORD *)v358 - 1) = v362;
        v358 -= 4;
        v360 -= 32;
      }
      while (v360 != v361);
      v360 = (char *)*a1;
    }
    *a1 = v358;
    a1[1] = v352;
    a1[2] = (void *)v359;
    if (v360) {
      operator delete(v360);
    }
  }
  else
  {
    void *v340 = @"EQ Max Gain (high freq)";
    v340[1] = 0x800000000000000DLL;
    v340[2] = 0x41A0000000000000;
    v340[3] = 0x441200000;
    v352 = v340 + 4;
  }
  a1[1] = v352;
  unint64_t v363 = (unint64_t)a1[2];
  if ((unint64_t)v352 >= v363)
  {
    uint64_t v365 = ((char *)v352 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v365 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v366 = v363 - (void)*a1;
    uint64_t v367 = v366 >> 4;
    if (v366 >> 4 <= (unint64_t)(v365 + 1)) {
      uint64_t v367 = v365 + 1;
    }
    if ((unint64_t)v366 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v368 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v368 = v367;
    }
    if (v368) {
      unint64_t v368 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v368);
    }
    else {
      uint64_t v369 = 0;
    }
    v370 = (void *)(v368 + 32 * v365);
    unint64_t v371 = v368 + 32 * v369;
    void *v370 = @"EQ Frequency Boundary";
    v370[1] = 0x8000000000000008;
    v370[2] = 0x469C400042C80000;
    v370[3] = 0x444480000;
    v364 = v370 + 4;
    v373 = (char *)*a1;
    v372 = (char *)a1[1];
    if (v372 != *a1)
    {
      do
      {
        long long v374 = *((_OWORD *)v372 - 1);
        *((_OWORD *)v370 - 2) = *((_OWORD *)v372 - 2);
        *((_OWORD *)v370 - 1) = v374;
        v370 -= 4;
        v372 -= 32;
      }
      while (v372 != v373);
      v372 = (char *)*a1;
    }
    *a1 = v370;
    a1[1] = v364;
    a1[2] = (void *)v371;
    if (v372) {
      operator delete(v372);
    }
  }
  else
  {
    void *v352 = @"EQ Frequency Boundary";
    v352[1] = 0x8000000000000008;
    v352[2] = 0x469C400042C80000;
    v352[3] = 0x444480000;
    v364 = v352 + 4;
  }
  a1[1] = v364;
  unint64_t v375 = (unint64_t)a1[2];
  if ((unint64_t)v364 >= v375)
  {
    uint64_t v377 = ((char *)v364 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v377 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v378 = v375 - (void)*a1;
    uint64_t v379 = v378 >> 4;
    if (v378 >> 4 <= (unint64_t)(v377 + 1)) {
      uint64_t v379 = v377 + 1;
    }
    if ((unint64_t)v378 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v380 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v380 = v379;
    }
    if (v380) {
      unint64_t v380 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v380);
    }
    else {
      uint64_t v381 = 0;
    }
    v382 = (void *)(v380 + 32 * v377);
    unint64_t v383 = v380 + 32 * v381;
    void *v382 = @"EQ Low Noise";
    v382[1] = 0x800000000000000DLL;
    v382[2] = 0x42F0000000000000;
    v382[3] = 0x4425C0000;
    v376 = v382 + 4;
    v385 = (char *)*a1;
    v384 = (char *)a1[1];
    if (v384 != *a1)
    {
      do
      {
        long long v386 = *((_OWORD *)v384 - 1);
        *((_OWORD *)v382 - 2) = *((_OWORD *)v384 - 2);
        *((_OWORD *)v382 - 1) = v386;
        v382 -= 4;
        v384 -= 32;
      }
      while (v384 != v385);
      v384 = (char *)*a1;
    }
    *a1 = v382;
    a1[1] = v376;
    a1[2] = (void *)v383;
    if (v384) {
      operator delete(v384);
    }
  }
  else
  {
    void *v364 = @"EQ Low Noise";
    v364[1] = 0x800000000000000DLL;
    v364[2] = 0x42F0000000000000;
    v364[3] = 0x4425C0000;
    v376 = v364 + 4;
  }
  a1[1] = v376;
  unint64_t v387 = (unint64_t)a1[2];
  if ((unint64_t)v376 >= v387)
  {
    uint64_t v389 = ((char *)v376 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v389 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v390 = v387 - (void)*a1;
    uint64_t v391 = v390 >> 4;
    if (v390 >> 4 <= (unint64_t)(v389 + 1)) {
      uint64_t v391 = v389 + 1;
    }
    if ((unint64_t)v390 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v392 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v392 = v391;
    }
    if (v392) {
      unint64_t v392 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v392);
    }
    else {
      uint64_t v393 = 0;
    }
    v394 = (void *)(v392 + 32 * v389);
    unint64_t v395 = v392 + 32 * v393;
    void *v394 = @"Change in Environment";
    v394[1] = 0x800000000000;
    v394[2] = 0x3F80000000000000;
    v394[3] = 0xFFFFFFFF00000000;
    v388 = v394 + 4;
    v397 = (char *)*a1;
    v396 = (char *)a1[1];
    if (v396 != *a1)
    {
      do
      {
        long long v398 = *((_OWORD *)v396 - 1);
        *((_OWORD *)v394 - 2) = *((_OWORD *)v396 - 2);
        *((_OWORD *)v394 - 1) = v398;
        v394 -= 4;
        v396 -= 32;
      }
      while (v396 != v397);
      v396 = (char *)*a1;
    }
    *a1 = v394;
    a1[1] = v388;
    a1[2] = (void *)v395;
    if (v396) {
      operator delete(v396);
    }
  }
  else
  {
    void *v376 = @"Change in Environment";
    v376[1] = 0x800000000000;
    v376[2] = 0x3F80000000000000;
    v376[3] = 0xFFFFFFFF00000000;
    v388 = v376 + 4;
  }
  a1[1] = v388;
  unint64_t v399 = (unint64_t)a1[2];
  if ((unint64_t)v388 >= v399)
  {
    uint64_t v401 = ((char *)v388 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v401 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v402 = v399 - (void)*a1;
    uint64_t v403 = v402 >> 4;
    if (v402 >> 4 <= (unint64_t)(v401 + 1)) {
      uint64_t v403 = v401 + 1;
    }
    if ((unint64_t)v402 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v404 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v404 = v403;
    }
    if (v404) {
      unint64_t v404 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v404);
    }
    else {
      uint64_t v405 = 0;
    }
    v406 = (void *)(v404 + 32 * v401);
    unint64_t v407 = v404 + 32 * v405;
    void *v406 = @"0.20 kHz";
    v406[1] = 0x40080000000000DLL;
    v406[2] = 0x41A00000C1A00000;
    v406[3] = 0x500000000;
    v400 = v406 + 4;
    v409 = (char *)*a1;
    v408 = (char *)a1[1];
    if (v408 != *a1)
    {
      do
      {
        long long v410 = *((_OWORD *)v408 - 1);
        *((_OWORD *)v406 - 2) = *((_OWORD *)v408 - 2);
        *((_OWORD *)v406 - 1) = v410;
        v406 -= 4;
        v408 -= 32;
      }
      while (v408 != v409);
      v408 = (char *)*a1;
    }
    *a1 = v406;
    a1[1] = v400;
    a1[2] = (void *)v407;
    if (v408) {
      operator delete(v408);
    }
  }
  else
  {
    void *v388 = @"0.20 kHz";
    v388[1] = 0x40080000000000DLL;
    v388[2] = 0x41A00000C1A00000;
    v388[3] = 0x500000000;
    v400 = v388 + 4;
  }
  a1[1] = v400;
  unint64_t v411 = (unint64_t)a1[2];
  if ((unint64_t)v400 >= v411)
  {
    uint64_t v413 = ((char *)v400 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v413 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v414 = v411 - (void)*a1;
    uint64_t v415 = v414 >> 4;
    if (v414 >> 4 <= (unint64_t)(v413 + 1)) {
      uint64_t v415 = v413 + 1;
    }
    if ((unint64_t)v414 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v416 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v416 = v415;
    }
    if (v416) {
      unint64_t v416 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v416);
    }
    else {
      uint64_t v417 = 0;
    }
    v418 = (void *)(v416 + 32 * v413);
    unint64_t v419 = v416 + 32 * v417;
    void *v418 = @"0.40 kHz";
    v418[1] = 0x40080000000000DLL;
    v418[2] = 0x41A00000C1A00000;
    v418[3] = 0x500000000;
    v412 = v418 + 4;
    v421 = (char *)*a1;
    v420 = (char *)a1[1];
    if (v420 != *a1)
    {
      do
      {
        long long v422 = *((_OWORD *)v420 - 1);
        *((_OWORD *)v418 - 2) = *((_OWORD *)v420 - 2);
        *((_OWORD *)v418 - 1) = v422;
        v418 -= 4;
        v420 -= 32;
      }
      while (v420 != v421);
      v420 = (char *)*a1;
    }
    *a1 = v418;
    a1[1] = v412;
    a1[2] = (void *)v419;
    if (v420) {
      operator delete(v420);
    }
  }
  else
  {
    void *v400 = @"0.40 kHz";
    v400[1] = 0x40080000000000DLL;
    v400[2] = 0x41A00000C1A00000;
    v400[3] = 0x500000000;
    v412 = v400 + 4;
  }
  a1[1] = v412;
  unint64_t v423 = (unint64_t)a1[2];
  if ((unint64_t)v412 >= v423)
  {
    uint64_t v425 = ((char *)v412 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v425 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v426 = v423 - (void)*a1;
    uint64_t v427 = v426 >> 4;
    if (v426 >> 4 <= (unint64_t)(v425 + 1)) {
      uint64_t v427 = v425 + 1;
    }
    if ((unint64_t)v426 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v428 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v428 = v427;
    }
    if (v428) {
      unint64_t v428 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v428);
    }
    else {
      uint64_t v429 = 0;
    }
    v430 = (void *)(v428 + 32 * v425);
    unint64_t v431 = v428 + 32 * v429;
    void *v430 = @"0.80 kHz";
    v430[1] = 0x40080000000000DLL;
    v430[2] = 0x41A00000C1A00000;
    v430[3] = 0x500000000;
    v424 = v430 + 4;
    v433 = (char *)*a1;
    v432 = (char *)a1[1];
    if (v432 != *a1)
    {
      do
      {
        long long v434 = *((_OWORD *)v432 - 1);
        *((_OWORD *)v430 - 2) = *((_OWORD *)v432 - 2);
        *((_OWORD *)v430 - 1) = v434;
        v430 -= 4;
        v432 -= 32;
      }
      while (v432 != v433);
      v432 = (char *)*a1;
    }
    *a1 = v430;
    a1[1] = v424;
    a1[2] = (void *)v431;
    if (v432) {
      operator delete(v432);
    }
  }
  else
  {
    void *v412 = @"0.80 kHz";
    v412[1] = 0x40080000000000DLL;
    v412[2] = 0x41A00000C1A00000;
    v412[3] = 0x500000000;
    v424 = v412 + 4;
  }
  a1[1] = v424;
  unint64_t v435 = (unint64_t)a1[2];
  if ((unint64_t)v424 >= v435)
  {
    uint64_t v437 = ((char *)v424 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v437 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v438 = v435 - (void)*a1;
    uint64_t v439 = v438 >> 4;
    if (v438 >> 4 <= (unint64_t)(v437 + 1)) {
      uint64_t v439 = v437 + 1;
    }
    if ((unint64_t)v438 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v440 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v440 = v439;
    }
    if (v440) {
      unint64_t v440 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v440);
    }
    else {
      uint64_t v441 = 0;
    }
    v442 = (void *)(v440 + 32 * v437);
    unint64_t v443 = v440 + 32 * v441;
    void *v442 = @"1.25 kHz";
    v442[1] = 0x40080000000000DLL;
    v442[2] = 0x41A00000C1A00000;
    v442[3] = 0x500000000;
    v436 = v442 + 4;
    v445 = (char *)*a1;
    v444 = (char *)a1[1];
    if (v444 != *a1)
    {
      do
      {
        long long v446 = *((_OWORD *)v444 - 1);
        *((_OWORD *)v442 - 2) = *((_OWORD *)v444 - 2);
        *((_OWORD *)v442 - 1) = v446;
        v442 -= 4;
        v444 -= 32;
      }
      while (v444 != v445);
      v444 = (char *)*a1;
    }
    *a1 = v442;
    a1[1] = v436;
    a1[2] = (void *)v443;
    if (v444) {
      operator delete(v444);
    }
  }
  else
  {
    void *v424 = @"1.25 kHz";
    v424[1] = 0x40080000000000DLL;
    v424[2] = 0x41A00000C1A00000;
    v424[3] = 0x500000000;
    v436 = v424 + 4;
  }
  a1[1] = v436;
  unint64_t v447 = (unint64_t)a1[2];
  if ((unint64_t)v436 >= v447)
  {
    uint64_t v449 = ((char *)v436 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v449 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v450 = v447 - (void)*a1;
    uint64_t v451 = v450 >> 4;
    if (v450 >> 4 <= (unint64_t)(v449 + 1)) {
      uint64_t v451 = v449 + 1;
    }
    if ((unint64_t)v450 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v452 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v452 = v451;
    }
    if (v452) {
      unint64_t v452 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v452);
    }
    else {
      uint64_t v453 = 0;
    }
    v454 = (void *)(v452 + 32 * v449);
    unint64_t v455 = v452 + 32 * v453;
    void *v454 = @"1.60 kHz";
    v454[1] = 0x40080000000000DLL;
    v454[2] = 0x41A00000C1A00000;
    v454[3] = 0x500000000;
    v448 = v454 + 4;
    v457 = (char *)*a1;
    v456 = (char *)a1[1];
    if (v456 != *a1)
    {
      do
      {
        long long v458 = *((_OWORD *)v456 - 1);
        *((_OWORD *)v454 - 2) = *((_OWORD *)v456 - 2);
        *((_OWORD *)v454 - 1) = v458;
        v454 -= 4;
        v456 -= 32;
      }
      while (v456 != v457);
      v456 = (char *)*a1;
    }
    *a1 = v454;
    a1[1] = v448;
    a1[2] = (void *)v455;
    if (v456) {
      operator delete(v456);
    }
  }
  else
  {
    void *v436 = @"1.60 kHz";
    v436[1] = 0x40080000000000DLL;
    v436[2] = 0x41A00000C1A00000;
    v436[3] = 0x500000000;
    v448 = v436 + 4;
  }
  a1[1] = v448;
  unint64_t v459 = (unint64_t)a1[2];
  if ((unint64_t)v448 >= v459)
  {
    uint64_t v461 = ((char *)v448 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v461 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v462 = v459 - (void)*a1;
    uint64_t v463 = v462 >> 4;
    if (v462 >> 4 <= (unint64_t)(v461 + 1)) {
      uint64_t v463 = v461 + 1;
    }
    if ((unint64_t)v462 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v464 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v464 = v463;
    }
    if (v464) {
      unint64_t v464 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v464);
    }
    else {
      uint64_t v465 = 0;
    }
    v466 = (void *)(v464 + 32 * v461);
    unint64_t v467 = v464 + 32 * v465;
    void *v466 = @"2.00 kHz";
    v466[1] = 0x40080000000000DLL;
    v466[2] = 0x41A00000C1A00000;
    v466[3] = 0x500000000;
    v460 = v466 + 4;
    v469 = (char *)*a1;
    v468 = (char *)a1[1];
    if (v468 != *a1)
    {
      do
      {
        long long v470 = *((_OWORD *)v468 - 1);
        *((_OWORD *)v466 - 2) = *((_OWORD *)v468 - 2);
        *((_OWORD *)v466 - 1) = v470;
        v466 -= 4;
        v468 -= 32;
      }
      while (v468 != v469);
      v468 = (char *)*a1;
    }
    *a1 = v466;
    a1[1] = v460;
    a1[2] = (void *)v467;
    if (v468) {
      operator delete(v468);
    }
  }
  else
  {
    void *v448 = @"2.00 kHz";
    v448[1] = 0x40080000000000DLL;
    v448[2] = 0x41A00000C1A00000;
    v448[3] = 0x500000000;
    v460 = v448 + 4;
  }
  a1[1] = v460;
  unint64_t v471 = (unint64_t)a1[2];
  if ((unint64_t)v460 >= v471)
  {
    uint64_t v473 = ((char *)v460 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v473 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v474 = v471 - (void)*a1;
    uint64_t v475 = v474 >> 4;
    if (v474 >> 4 <= (unint64_t)(v473 + 1)) {
      uint64_t v475 = v473 + 1;
    }
    if ((unint64_t)v474 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v476 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v476 = v475;
    }
    if (v476) {
      unint64_t v476 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v476);
    }
    else {
      uint64_t v477 = 0;
    }
    v478 = (void *)(v476 + 32 * v473);
    unint64_t v479 = v476 + 32 * v477;
    void *v478 = @"2.50 kHz";
    v478[1] = 0x40080000000000DLL;
    v478[2] = 0x41A00000C1A00000;
    v478[3] = 0x500000000;
    v472 = v478 + 4;
    v481 = (char *)*a1;
    v480 = (char *)a1[1];
    if (v480 != *a1)
    {
      do
      {
        long long v482 = *((_OWORD *)v480 - 1);
        *((_OWORD *)v478 - 2) = *((_OWORD *)v480 - 2);
        *((_OWORD *)v478 - 1) = v482;
        v478 -= 4;
        v480 -= 32;
      }
      while (v480 != v481);
      v480 = (char *)*a1;
    }
    *a1 = v478;
    a1[1] = v472;
    a1[2] = (void *)v479;
    if (v480) {
      operator delete(v480);
    }
  }
  else
  {
    void *v460 = @"2.50 kHz";
    v460[1] = 0x40080000000000DLL;
    v460[2] = 0x41A00000C1A00000;
    v460[3] = 0x500000000;
    v472 = v460 + 4;
  }
  a1[1] = v472;
  unint64_t v483 = (unint64_t)a1[2];
  if ((unint64_t)v472 >= v483)
  {
    uint64_t v485 = ((char *)v472 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v485 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v486 = v483 - (void)*a1;
    uint64_t v487 = v486 >> 4;
    if (v486 >> 4 <= (unint64_t)(v485 + 1)) {
      uint64_t v487 = v485 + 1;
    }
    if ((unint64_t)v486 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v488 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v488 = v487;
    }
    if (v488) {
      unint64_t v488 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v488);
    }
    else {
      uint64_t v489 = 0;
    }
    v490 = (void *)(v488 + 32 * v485);
    unint64_t v491 = v488 + 32 * v489;
    void *v490 = @"3.15 kHz";
    v490[1] = 0x40080000000000DLL;
    v490[2] = 0x41A00000C1A00000;
    v490[3] = 0x500000000;
    v484 = v490 + 4;
    v493 = (char *)*a1;
    v492 = (char *)a1[1];
    if (v492 != *a1)
    {
      do
      {
        long long v494 = *((_OWORD *)v492 - 1);
        *((_OWORD *)v490 - 2) = *((_OWORD *)v492 - 2);
        *((_OWORD *)v490 - 1) = v494;
        v490 -= 4;
        v492 -= 32;
      }
      while (v492 != v493);
      v492 = (char *)*a1;
    }
    *a1 = v490;
    a1[1] = v484;
    a1[2] = (void *)v491;
    if (v492) {
      operator delete(v492);
    }
  }
  else
  {
    void *v472 = @"3.15 kHz";
    v472[1] = 0x40080000000000DLL;
    v472[2] = 0x41A00000C1A00000;
    v472[3] = 0x500000000;
    v484 = v472 + 4;
  }
  a1[1] = v484;
  unint64_t v495 = (unint64_t)a1[2];
  if ((unint64_t)v484 >= v495)
  {
    uint64_t v497 = ((char *)v484 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v497 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v498 = v495 - (void)*a1;
    uint64_t v499 = v498 >> 4;
    if (v498 >> 4 <= (unint64_t)(v497 + 1)) {
      uint64_t v499 = v497 + 1;
    }
    if ((unint64_t)v498 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v500 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v500 = v499;
    }
    if (v500) {
      unint64_t v500 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v500);
    }
    else {
      uint64_t v501 = 0;
    }
    v502 = (void *)(v500 + 32 * v497);
    unint64_t v503 = v500 + 32 * v501;
    void *v502 = @"4.00 kHz";
    v502[1] = 0x40080000000000DLL;
    v502[2] = 0x41A00000C1A00000;
    v502[3] = 0x500000000;
    v496 = v502 + 4;
    v505 = (char *)*a1;
    v504 = (char *)a1[1];
    if (v504 != *a1)
    {
      do
      {
        long long v506 = *((_OWORD *)v504 - 1);
        *((_OWORD *)v502 - 2) = *((_OWORD *)v504 - 2);
        *((_OWORD *)v502 - 1) = v506;
        v502 -= 4;
        v504 -= 32;
      }
      while (v504 != v505);
      v504 = (char *)*a1;
    }
    *a1 = v502;
    a1[1] = v496;
    a1[2] = (void *)v503;
    if (v504) {
      operator delete(v504);
    }
  }
  else
  {
    void *v484 = @"4.00 kHz";
    v484[1] = 0x40080000000000DLL;
    v484[2] = 0x41A00000C1A00000;
    v484[3] = 0x500000000;
    v496 = v484 + 4;
  }
  a1[1] = v496;
  unint64_t v507 = (unint64_t)a1[2];
  if ((unint64_t)v496 >= v507)
  {
    uint64_t v509 = ((char *)v496 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v509 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v510 = v507 - (void)*a1;
    uint64_t v511 = v510 >> 4;
    if (v510 >> 4 <= (unint64_t)(v509 + 1)) {
      uint64_t v511 = v509 + 1;
    }
    if ((unint64_t)v510 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v512 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v512 = v511;
    }
    if (v512) {
      unint64_t v512 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v512);
    }
    else {
      uint64_t v513 = 0;
    }
    v514 = (void *)(v512 + 32 * v509);
    unint64_t v515 = v512 + 32 * v513;
    void *v514 = @"5.00 kHz";
    v514[1] = 0x40080000000000DLL;
    v514[2] = 0x41A00000C1A00000;
    v514[3] = 0x500000000;
    v508 = v514 + 4;
    v517 = (char *)*a1;
    v516 = (char *)a1[1];
    if (v516 != *a1)
    {
      do
      {
        long long v518 = *((_OWORD *)v516 - 1);
        *((_OWORD *)v514 - 2) = *((_OWORD *)v516 - 2);
        *((_OWORD *)v514 - 1) = v518;
        v514 -= 4;
        v516 -= 32;
      }
      while (v516 != v517);
      v516 = (char *)*a1;
    }
    *a1 = v514;
    a1[1] = v508;
    a1[2] = (void *)v515;
    if (v516) {
      operator delete(v516);
    }
  }
  else
  {
    void *v496 = @"5.00 kHz";
    v496[1] = 0x40080000000000DLL;
    v496[2] = 0x41A00000C1A00000;
    v496[3] = 0x500000000;
    v508 = v496 + 4;
  }
  a1[1] = v508;
  unint64_t v519 = (unint64_t)a1[2];
  if ((unint64_t)v508 >= v519)
  {
    uint64_t v521 = ((char *)v508 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v521 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v522 = v519 - (void)*a1;
    uint64_t v523 = v522 >> 4;
    if (v522 >> 4 <= (unint64_t)(v521 + 1)) {
      uint64_t v523 = v521 + 1;
    }
    if ((unint64_t)v522 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v524 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v524 = v523;
    }
    if (v524) {
      unint64_t v524 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v524);
    }
    else {
      uint64_t v525 = 0;
    }
    v526 = (void *)(v524 + 32 * v521);
    unint64_t v527 = v524 + 32 * v525;
    void *v526 = @"6.30 kHz";
    v526[1] = 0x40080000000000DLL;
    v526[2] = 0x41A00000C1A00000;
    v526[3] = 0x500000000;
    v520 = v526 + 4;
    v529 = (char *)*a1;
    v528 = (char *)a1[1];
    if (v528 != *a1)
    {
      do
      {
        long long v530 = *((_OWORD *)v528 - 1);
        *((_OWORD *)v526 - 2) = *((_OWORD *)v528 - 2);
        *((_OWORD *)v526 - 1) = v530;
        v526 -= 4;
        v528 -= 32;
      }
      while (v528 != v529);
      v528 = (char *)*a1;
    }
    *a1 = v526;
    a1[1] = v520;
    a1[2] = (void *)v527;
    if (v528) {
      operator delete(v528);
    }
  }
  else
  {
    void *v508 = @"6.30 kHz";
    v508[1] = 0x40080000000000DLL;
    v508[2] = 0x41A00000C1A00000;
    v508[3] = 0x500000000;
    v520 = v508 + 4;
  }
  a1[1] = v520;
  unint64_t v531 = (unint64_t)a1[2];
  if ((unint64_t)v520 >= v531)
  {
    uint64_t v533 = ((char *)v520 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v533 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v534 = v531 - (void)*a1;
    uint64_t v535 = v534 >> 4;
    if (v534 >> 4 <= (unint64_t)(v533 + 1)) {
      uint64_t v535 = v533 + 1;
    }
    if ((unint64_t)v534 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v536 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v536 = v535;
    }
    if (v536) {
      unint64_t v536 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v536);
    }
    else {
      uint64_t v537 = 0;
    }
    v538 = (void *)(v536 + 32 * v533);
    unint64_t v539 = v536 + 32 * v537;
    void *v538 = @"8.00 kHz";
    v538[1] = 0x40080000000000DLL;
    v538[2] = 0x41A00000C1A00000;
    v538[3] = 0x500000000;
    v532 = v538 + 4;
    v541 = (char *)*a1;
    v540 = (char *)a1[1];
    if (v540 != *a1)
    {
      do
      {
        long long v542 = *((_OWORD *)v540 - 1);
        *((_OWORD *)v538 - 2) = *((_OWORD *)v540 - 2);
        *((_OWORD *)v538 - 1) = v542;
        v538 -= 4;
        v540 -= 32;
      }
      while (v540 != v541);
      v540 = (char *)*a1;
    }
    *a1 = v538;
    a1[1] = v532;
    a1[2] = (void *)v539;
    if (v540) {
      operator delete(v540);
    }
  }
  else
  {
    void *v520 = @"8.00 kHz";
    v520[1] = 0x40080000000000DLL;
    v520[2] = 0x41A00000C1A00000;
    v520[3] = 0x500000000;
    v532 = v520 + 4;
  }
  a1[1] = v532;
  unint64_t v543 = (unint64_t)a1[2];
  if ((unint64_t)v532 >= v543)
  {
    uint64_t v545 = ((char *)v532 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v545 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v546 = v543 - (void)*a1;
    uint64_t v547 = v546 >> 4;
    if (v546 >> 4 <= (unint64_t)(v545 + 1)) {
      uint64_t v547 = v545 + 1;
    }
    if ((unint64_t)v546 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v548 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v548 = v547;
    }
    if (v548) {
      unint64_t v548 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v548);
    }
    else {
      uint64_t v549 = 0;
    }
    v550 = (void *)(v548 + 32 * v545);
    unint64_t v551 = v548 + 32 * v549;
    void *v550 = @"10.00 kHz";
    v550[1] = 0x40080000000000DLL;
    v550[2] = 0x41A00000C1A00000;
    v550[3] = 0x500000000;
    v544 = v550 + 4;
    v553 = (char *)*a1;
    v552 = (char *)a1[1];
    if (v552 != *a1)
    {
      do
      {
        long long v554 = *((_OWORD *)v552 - 1);
        *((_OWORD *)v550 - 2) = *((_OWORD *)v552 - 2);
        *((_OWORD *)v550 - 1) = v554;
        v550 -= 4;
        v552 -= 32;
      }
      while (v552 != v553);
      v552 = (char *)*a1;
    }
    *a1 = v550;
    a1[1] = v544;
    a1[2] = (void *)v551;
    if (v552) {
      operator delete(v552);
    }
  }
  else
  {
    void *v532 = @"10.00 kHz";
    v532[1] = 0x40080000000000DLL;
    v532[2] = 0x41A00000C1A00000;
    v532[3] = 0x500000000;
    v544 = v532 + 4;
  }
  a1[1] = v544;
  unint64_t v555 = (unint64_t)a1[2];
  if ((unint64_t)v544 >= v555)
  {
    uint64_t v557 = ((char *)v544 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v557 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v558 = v555 - (void)*a1;
    uint64_t v559 = v558 >> 4;
    if (v558 >> 4 <= (unint64_t)(v557 + 1)) {
      uint64_t v559 = v557 + 1;
    }
    if ((unint64_t)v558 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v560 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v560 = v559;
    }
    if (v560) {
      unint64_t v560 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v560);
    }
    else {
      uint64_t v561 = 0;
    }
    v562 = (void *)(v560 + 32 * v557);
    unint64_t v563 = v560 + 32 * v561;
    void *v562 = @"12.50 kHz";
    v562[1] = 0x40080000000000DLL;
    v562[2] = 0x41A00000C1A00000;
    v562[3] = 0x500000000;
    v556 = v562 + 4;
    v565 = (char *)*a1;
    v564 = (char *)a1[1];
    if (v564 != *a1)
    {
      do
      {
        long long v566 = *((_OWORD *)v564 - 1);
        *((_OWORD *)v562 - 2) = *((_OWORD *)v564 - 2);
        *((_OWORD *)v562 - 1) = v566;
        v562 -= 4;
        v564 -= 32;
      }
      while (v564 != v565);
      v564 = (char *)*a1;
    }
    *a1 = v562;
    a1[1] = v556;
    a1[2] = (void *)v563;
    if (v564) {
      operator delete(v564);
    }
  }
  else
  {
    void *v544 = @"12.50 kHz";
    v544[1] = 0x40080000000000DLL;
    v544[2] = 0x41A00000C1A00000;
    v544[3] = 0x500000000;
    v556 = v544 + 4;
  }
  a1[1] = v556;
  unint64_t v567 = (unint64_t)a1[2];
  if ((unint64_t)v556 >= v567)
  {
    uint64_t v569 = ((char *)v556 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v569 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v570 = v567 - (void)*a1;
    uint64_t v571 = v570 >> 4;
    if (v570 >> 4 <= (unint64_t)(v569 + 1)) {
      uint64_t v571 = v569 + 1;
    }
    if ((unint64_t)v570 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v572 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v572 = v571;
    }
    if (v572) {
      unint64_t v572 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v572);
    }
    else {
      uint64_t v573 = 0;
    }
    v574 = (void *)(v572 + 32 * v569);
    unint64_t v575 = v572 + 32 * v573;
    void *v574 = @"16.00 kHz";
    v574[1] = 0x40080000000000DLL;
    v574[2] = 0x41A00000C1A00000;
    v574[3] = 0x500000000;
    v568 = v574 + 4;
    v577 = (char *)*a1;
    v576 = (char *)a1[1];
    if (v576 != *a1)
    {
      do
      {
        long long v578 = *((_OWORD *)v576 - 1);
        *((_OWORD *)v574 - 2) = *((_OWORD *)v576 - 2);
        *((_OWORD *)v574 - 1) = v578;
        v574 -= 4;
        v576 -= 32;
      }
      while (v576 != v577);
      v576 = (char *)*a1;
    }
    *a1 = v574;
    a1[1] = v568;
    a1[2] = (void *)v575;
    if (v576) {
      operator delete(v576);
    }
  }
  else
  {
    void *v556 = @"16.00 kHz";
    v556[1] = 0x40080000000000DLL;
    v556[2] = 0x41A00000C1A00000;
    v556[3] = 0x500000000;
    v568 = v556 + 4;
  }
  a1[1] = v568;
  unint64_t v579 = (unint64_t)a1[2];
  if ((unint64_t)v568 >= v579)
  {
    uint64_t v581 = ((char *)v568 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v581 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v582 = v579 - (void)*a1;
    uint64_t v583 = v582 >> 4;
    if (v582 >> 4 <= (unint64_t)(v581 + 1)) {
      uint64_t v583 = v581 + 1;
    }
    if ((unint64_t)v582 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v584 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v584 = v583;
    }
    if (v584) {
      unint64_t v584 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v584);
    }
    else {
      uint64_t v585 = 0;
    }
    v586 = (void *)(v584 + 32 * v581);
    unint64_t v587 = v584 + 32 * v585;
    void *v586 = @"20.00 kHz";
    v586[1] = 0x40080000000000DLL;
    v586[2] = 0x41A00000C1A00000;
    v586[3] = 0x500000000;
    v580 = v586 + 4;
    v589 = (char *)*a1;
    v588 = (char *)a1[1];
    if (v588 != *a1)
    {
      do
      {
        long long v590 = *((_OWORD *)v588 - 1);
        *((_OWORD *)v586 - 2) = *((_OWORD *)v588 - 2);
        *((_OWORD *)v586 - 1) = v590;
        v586 -= 4;
        v588 -= 32;
      }
      while (v588 != v589);
      v588 = (char *)*a1;
    }
    *a1 = v586;
    a1[1] = v580;
    a1[2] = (void *)v587;
    if (v588) {
      operator delete(v588);
    }
  }
  else
  {
    void *v568 = @"20.00 kHz";
    v568[1] = 0x40080000000000DLL;
    v568[2] = 0x41A00000C1A00000;
    v568[3] = 0x500000000;
    v580 = v568 + 4;
  }
  a1[1] = v580;
  unint64_t v591 = (unint64_t)a1[2];
  if ((unint64_t)v580 >= v591)
  {
    uint64_t v593 = ((char *)v580 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v593 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v594 = v591 - (void)*a1;
    uint64_t v595 = v594 >> 4;
    if (v594 >> 4 <= (unint64_t)(v593 + 1)) {
      uint64_t v595 = v593 + 1;
    }
    if ((unint64_t)v594 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v596 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v596 = v595;
    }
    if (v596) {
      unint64_t v596 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v596);
    }
    else {
      uint64_t v597 = 0;
    }
    v598 = (void *)(v596 + 32 * v593);
    unint64_t v599 = v596 + 32 * v597;
    void *v598 = @"EQ Slew Rate (dB/s)";
    v598[1] = 0x8400000000000000;
    v598[2] = 0x4170000000000000;
    v598[3] = 0x440000000;
    v592 = v598 + 4;
    v601 = (char *)*a1;
    v600 = (char *)a1[1];
    if (v600 != *a1)
    {
      do
      {
        long long v602 = *((_OWORD *)v600 - 1);
        *((_OWORD *)v598 - 2) = *((_OWORD *)v600 - 2);
        *((_OWORD *)v598 - 1) = v602;
        v598 -= 4;
        v600 -= 32;
      }
      while (v600 != v601);
      v600 = (char *)*a1;
    }
    *a1 = v598;
    a1[1] = v592;
    a1[2] = (void *)v599;
    if (v600) {
      operator delete(v600);
    }
  }
  else
  {
    void *v580 = @"EQ Slew Rate (dB/s)";
    v580[1] = 0x8400000000000000;
    v580[2] = 0x4170000000000000;
    v580[3] = 0x440000000;
    v592 = v580 + 4;
  }
  a1[1] = v592;
  unint64_t v603 = (unint64_t)a1[2];
  if ((unint64_t)v592 >= v603)
  {
    uint64_t v605 = ((char *)v592 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v605 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v606 = v603 - (void)*a1;
    uint64_t v607 = v606 >> 4;
    if (v606 >> 4 <= (unint64_t)(v605 + 1)) {
      uint64_t v607 = v605 + 1;
    }
    if ((unint64_t)v606 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v608 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v608 = v607;
    }
    if (v608) {
      unint64_t v608 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v608);
    }
    else {
      uint64_t v609 = 0;
    }
    v610 = (void *)(v608 + 32 * v605);
    unint64_t v611 = v608 + 32 * v609;
    void *v610 = @"Noise Slew Rate (dB/s)";
    v610[1] = 0x8400000000000000;
    v610[2] = 0x4170000000000000;
    v610[3] = 0x240A00000;
    v604 = v610 + 4;
    v613 = (char *)*a1;
    v612 = (char *)a1[1];
    if (v612 != *a1)
    {
      do
      {
        long long v614 = *((_OWORD *)v612 - 1);
        *((_OWORD *)v610 - 2) = *((_OWORD *)v612 - 2);
        *((_OWORD *)v610 - 1) = v614;
        v610 -= 4;
        v612 -= 32;
      }
      while (v612 != v613);
      v612 = (char *)*a1;
    }
    *a1 = v610;
    a1[1] = v604;
    a1[2] = (void *)v611;
    if (v612) {
      operator delete(v612);
    }
  }
  else
  {
    void *v592 = @"Noise Slew Rate (dB/s)";
    v592[1] = 0x8400000000000000;
    v592[2] = 0x4170000000000000;
    v592[3] = 0x240A00000;
    v604 = v592 + 4;
  }
  a1[1] = v604;
  unint64_t v615 = (unint64_t)a1[2];
  if ((unint64_t)v604 >= v615)
  {
    uint64_t v617 = ((char *)v604 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v617 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v618 = v615 - (void)*a1;
    uint64_t v619 = v618 >> 4;
    if (v618 >> 4 <= (unint64_t)(v617 + 1)) {
      uint64_t v619 = v617 + 1;
    }
    if ((unint64_t)v618 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v620 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v620 = v619;
    }
    if (v620) {
      unint64_t v620 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v620);
    }
    else {
      uint64_t v621 = 0;
    }
    v622 = (void *)(v620 + 32 * v617);
    unint64_t v623 = v620 + 32 * v621;
    void *v622 = @"Auto Volume Slew Rate (dB/s)";
    v622[1] = 0x8400000000000000;
    v622[2] = 0x4170000000000000;
    v622[3] = 0x340400000;
    v616 = v622 + 4;
    v625 = (char *)*a1;
    v624 = (char *)a1[1];
    if (v624 != *a1)
    {
      do
      {
        long long v626 = *((_OWORD *)v624 - 1);
        *((_OWORD *)v622 - 2) = *((_OWORD *)v624 - 2);
        *((_OWORD *)v622 - 1) = v626;
        v622 -= 4;
        v624 -= 32;
      }
      while (v624 != v625);
      v624 = (char *)*a1;
    }
    *a1 = v622;
    a1[1] = v616;
    a1[2] = (void *)v623;
    if (v624) {
      operator delete(v624);
    }
  }
  else
  {
    void *v604 = @"Auto Volume Slew Rate (dB/s)";
    v604[1] = 0x8400000000000000;
    v604[2] = 0x4170000000000000;
    v604[3] = 0x340400000;
    v616 = v604 + 4;
  }
  a1[1] = v616;
  unint64_t v627 = (unint64_t)a1[2];
  if ((unint64_t)v616 >= v627)
  {
    uint64_t v629 = ((char *)v616 - (unsigned char *)*a1) >> 5;
    if ((unint64_t)(v629 + 1) >> 59) {
      goto LABEL_867;
    }
    uint64_t v630 = v627 - (void)*a1;
    uint64_t v631 = v630 >> 4;
    if (v630 >> 4 <= (unint64_t)(v629 + 1)) {
      uint64_t v631 = v629 + 1;
    }
    if ((unint64_t)v630 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v632 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v632 = v631;
    }
    if (v632) {
      unint64_t v632 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v632);
    }
    else {
      uint64_t v633 = 0;
    }
    v634 = (void *)(v632 + 32 * v629);
    unint64_t v635 = v632 + 32 * v633;
    void *v634 = @"Near-End Speech Presence";
    v634[1] = 0x400800000000000;
    v634[2] = 0x3F80000000000000;
    v634[3] = 0xFFFFFFFF00000000;
    v628 = v634 + 4;
    v637 = (char *)*a1;
    v636 = (char *)a1[1];
    if (v636 != *a1)
    {
      do
      {
        long long v638 = *((_OWORD *)v636 - 1);
        *((_OWORD *)v634 - 2) = *((_OWORD *)v636 - 2);
        *((_OWORD *)v634 - 1) = v638;
        v634 -= 4;
        v636 -= 32;
      }
      while (v636 != v637);
      v636 = (char *)*a1;
    }
    *a1 = v634;
    a1[1] = v628;
    a1[2] = (void *)v635;
    if (v636) {
      operator delete(v636);
    }
  }
  else
  {
    void *v616 = @"Near-End Speech Presence";
    v616[1] = 0x400800000000000;
    v616[2] = 0x3F80000000000000;
    v616[3] = 0xFFFFFFFF00000000;
    v628 = v616 + 4;
  }
  a1[1] = v628;
  unint64_t v639 = (unint64_t)a1[2];
  if ((unint64_t)v628 < v639)
  {
    void *v628 = @"Near-End SPP Threshold";
    v628[1] = 0x8400000000000000;
    v628[2] = 0x3F80000000000000;
    v628[3] = -3246391296;
    v640 = v628 + 4;
    goto LABEL_865;
  }
  uint64_t v641 = ((char *)v628 - (unsigned char *)*a1) >> 5;
  if ((unint64_t)(v641 + 1) >> 59) {
LABEL_867:
  }
    std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
  uint64_t v642 = v639 - (void)*a1;
  uint64_t v643 = v642 >> 4;
  if (v642 >> 4 <= (unint64_t)(v641 + 1)) {
    uint64_t v643 = v641 + 1;
  }
  if ((unint64_t)v642 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v644 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v644 = v643;
  }
  if (v644) {
    unint64_t v644 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v644);
  }
  else {
    uint64_t v645 = 0;
  }
  v646 = (void *)(v644 + 32 * v641);
  unint64_t v647 = v644 + 32 * v645;
  void *v646 = @"Near-End SPP Threshold";
  v646[1] = 0x8400000000000000;
  v646[2] = 0x3F80000000000000;
  v646[3] = -3246391296;
  v640 = v646 + 4;
  v649 = (char *)*a1;
  v648 = (char *)a1[1];
  if (v648 != *a1)
  {
    do
    {
      long long v650 = *((_OWORD *)v648 - 1);
      *((_OWORD *)v646 - 2) = *((_OWORD *)v648 - 2);
      *((_OWORD *)v646 - 1) = v650;
      v646 -= 4;
      v648 -= 32;
    }
    while (v648 != v649);
    v648 = (char *)*a1;
  }
  *a1 = v646;
  a1[1] = v640;
  a1[2] = (void *)v647;
  if (v648) {
    operator delete(v648);
  }
LABEL_865:
  a1[1] = v640;
  if ((char *)v640 - (unsigned char *)*a1 != 1728) {
    __assert_rtn("populateParameterInfoTable", "SpeechEnhancerParameters.h", 99, "paramInfo.size() == kAUSpeechEnhancerNumberOfParameters");
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(unint64_t a1)
{
  if (a1 >> 59) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(32 * a1);
}

void BassKoenig::newDspLibAlgorithm(BassKoenig *this)
{
}

void sub_1BB3744A0(_Unwind_Exception *a1)
{
  MEMORY[0x1C185D370](v1, 0x10E1C40F2567D98);
  _Unwind_Resume(a1);
}

uint64_t BassKoenig::Version(BassKoenig *this)
{
  return 197376;
}

uint64_t BassKoenig::SupportedNumChannels(BassKoenig *this, const AUChannelInfo **a2)
{
  if (a2) {
    *a2 = (const AUChannelInfo *)&BassKoenig::SupportedNumChannels(AUChannelInfo const**)::sChannels;
  }
  return 2;
}

uint64_t BassKoenig::ProcessBufferLists(BassKoenig *this, unsigned int *a2, const AudioBufferList *a3, AudioBufferList *a4, uint64_t a5)
{
  unsigned int v5 = a5;
  long long v14 = a4;
  unint64_t v15 = a3;
  uint64_t v8 = (*(uint64_t (**)(BassKoenig *, unsigned int *, uint64_t, uint64_t, const AudioBufferList **, uint64_t, AudioBufferList **))(*(void *)this + 184))(this, a2, a5, 1, &v15, 1, &v14);
  uint64_t v9 = v8;
  if (*((unsigned char *)this + 2113)) {
    BOOL v10 = 0;
  }
  else {
    BOOL v10 = v8 == 0;
  }
  if (v10)
  {
    mData = (float *)a4->mBuffers[0].mData;
    float32x4_t v12 = (_DWORD *)*((void *)this + 268);
    if (v12 != *((_DWORD **)this + 269) && *v12 == 2 && !*((_DWORD *)this + 397)) {
      DspLib::multiply((const float *)a4->mBuffers[0].mData, v5, *(float **)&a4[1].mBuffers[0].mNumberChannels, *((float *)this + 543));
    }
    DspLib::multiply(mData, v5, *((float *)this + 542));
  }
  return v9;
}

uint64_t BassKoenig::SetParameter(BassKoenig *this, unsigned int a2, unsigned int a3, unsigned int a4, float a5)
{
  if (a2 == 48)
  {
    *((float *)this + 543) = DspLib::dB2Amp(this, a5);
  }
  else if (a2 == 47)
  {
    *((float *)this + 542) = DspLib::dB2Amp(this, a5);
  }

  return AUDspLib::SetParameter(this, a2, a3, a4, a5);
}

void BassKoenig::~BassKoenig(BassKoenig *this)
{
  AUDspLib::~AUDspLib(this);

  JUMPOUT(0x1C185D370);
}

uint64_t AUBSS2::SetMaxFramesPerSlice(AUBSS2 *this, int a2)
{
  uint64_t result = ausdk::AUBase::SetMaxFramesPerSlice((uint64_t)this, a2);
  if (*((_DWORD *)this + 136) != a2) {
    *((_DWORD *)this + 136) = a2;
  }
  return result;
}

char *AUBSS2::GetScopeExtended(AUBSS2 *this, int a2)
{
  uint64_t v2 = (char *)this + 552;
  if (a2 != 4) {
    uint64_t v2 = 0;
  }
  if (a2) {
    return v2;
  }
  else {
    return (char *)this + 32;
  }
}

uint64_t AUBSS2::ChangeStreamFormat(AUBSS2 *this, uint64_t a2, uint64_t a3, const AudioStreamBasicDescription *a4, const AudioStreamBasicDescription *a5)
{
  if (a4->mSampleRate != a5->mSampleRate) {
    *((_DWORD *)this + 135) = a5->mSampleRate;
  }
  return 0;
}

uint64_t AUBSS2::ValidFormat(AUBSS2 *this, int a2, unsigned int a3, const AudioStreamBasicDescription *a4)
{
  if (a4->mBitsPerChannel == 64 && a4->mFormatID == 1718773105) {
    uint64_t result = (LOBYTE(a4->mFormatFlags) >> 5) & 1;
  }
  else {
    uint64_t result = 0;
  }
  if (a2 == 2 || a2 == 1)
  {
    if (a4->mChannelsPerFrame - 2 < 7) {
      return result;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t AUBSS2::SupportedNumChannels(AUBSS2 *this, const AUChannelInfo **a2)
{
  uint64_t v2 = 0;
  unint64_t v3 = &word_1E9F7DF4A;
  do
  {
    *(v3 - 1) = v2 + 2;
    __int16 *v3 = v2 + 2;
    v3 += 2;
    ++v2;
  }
  while (v2 != 7);
  if (a2) {
    *a2 = (const AUChannelInfo *)&AUBSS2::SupportedNumChannels(AUChannelInfo const**)::sSupportedChannelConfigs;
  }
  return 7;
}

BOOL AUBSS2::StreamFormatWritable(AUBSS2 *this)
{
  return *((unsigned char *)this + 17) == 0;
}

uint64_t AUBSS2::SupportsTail(AUBSS2 *this)
{
  return 1;
}

double AUBSS2::GetTailTime(AUBSS2 *this)
{
  return 0.0;
}

double AUBSS2::GetLatency(AUBSS2 *this)
{
  return 0.0;
}

uint64_t AUBSS2::GetParameterValueStrings(AUBSS2 *this, int a2, int a3, const __CFArray **a4)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  int v46 = a3;
  if (!a4)
  {
    if (AUBSS2LogScope(void)::once != -1) {
      dispatch_once(&AUBSS2LogScope(void)::once, &__block_literal_global_1774);
    }
    if (AUBSS2LogScope(void)::scope)
    {
      unsigned int v5 = *(NSObject **)AUBSS2LogScope(void)::scope;
      if (!*(void *)AUBSS2LogScope(void)::scope) {
        return 0;
      }
    }
    else
    {
      unsigned int v5 = MEMORY[0x1E4F14500];
    }
    BOOL v19 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v19) {
      return result;
    }
    *(_DWORD *)buf = 136315394;
    *(void *)&uint8_t buf[4] = "AUBSS2.cpp";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = 514;
    _os_log_impl(&dword_1BB0CE000, v5, OS_LOG_TYPE_DEFAULT, "%25s:%-5d ERROR: Failed accessing strings in GetParameterValueStrings.", buf, 0x12u);
    return 0;
  }
  if (a2) {
    return 4294956430;
  }
  uint64_t result = 0;
  if (a3 <= 9)
  {
    if (a3 != 2)
    {
      if (a3 != 7) {
        return result;
      }
      if (*((unsigned char *)this + 17))
      {
        CFIndex v8 = (*((_DWORD *)this + 150) + 1);
        MEMORY[0x1F4188790](0);
        unint64_t v11 = (const void **)((char *)&v45.__r_.__value_.__l.__data_ - v10);
        if (v9 >= 0x200) {
          size_t v12 = 512;
        }
        else {
          size_t v12 = v9;
        }
        bzero((char *)&v45 - v10, v12);
        char *v11 = @"Multiple Reference MDP";
        if (v8 > 1)
        {
          for (unint64_t i = 1; i != v8; ++i)
          {
            std::to_string(&v45, i);
            long long v14 = std::string::insert(&v45, 0, "Mic", 3uLL);
            long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
            *(void *)&buf[16] = *((void *)&v14->__r_.__value_.__l + 2);
            *(_OWORD *)buf = v15;
            v14->__r_.__value_.__l.__size_ = 0;
            v14->__r_.__value_.__r.__words[2] = 0;
            v14->__r_.__value_.__r.__words[0] = 0;
            if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v45.__r_.__value_.__l.__data_);
            }
            if (buf[23] >= 0) {
              float32x4_t v16 = buf;
            }
            else {
              float32x4_t v16 = *(const char **)buf;
            }
            v11[i] = CFStringCreateWithCString(0, v16, 0x8000100u);
            if ((buf[23] & 0x80000000) != 0) {
              operator delete(*(void **)buf);
            }
          }
          *a4 = CFArrayCreate(0, v11, v8, 0);
          CFIndex v17 = v8 - 1;
          uint64_t v18 = v11 + 1;
          do
          {
            CFRelease(*v18++);
            --v17;
          }
          while (v17);
          return 0;
        }
        goto LABEL_75;
      }
      uint64_t v34 = (char *)this + 624;
      if (std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::find<unsigned int>((void *)this + 78, 7u))
      {
        unint64_t v35 = (float *)std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)v34, 7u, &v46);
        CFIndex v8 = (float)(v35[10] + 1.0);
        MEMORY[0x1F4188790](v35);
        unint64_t v11 = (const void **)((char *)&v45.__r_.__value_.__l.__data_ - v37);
        if (v36 >= 0x200) {
          size_t v38 = 512;
        }
        else {
          size_t v38 = v36;
        }
        bzero((char *)&v45 - v37, v38);
        char *v11 = @"Multiple Reference MDP";
        if (v8 > 1)
        {
          for (unint64_t j = 1; j != v8; ++j)
          {
            std::to_string(&v45, j);
            float v40 = std::string::insert(&v45, 0, "Mic", 3uLL);
            long long v41 = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
            *(void *)&buf[16] = *((void *)&v40->__r_.__value_.__l + 2);
            *(_OWORD *)buf = v41;
            v40->__r_.__value_.__l.__size_ = 0;
            v40->__r_.__value_.__r.__words[2] = 0;
            v40->__r_.__value_.__r.__words[0] = 0;
            if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v45.__r_.__value_.__l.__data_);
            }
            if (buf[23] >= 0) {
              uint64_t v42 = buf;
            }
            else {
              uint64_t v42 = *(const char **)buf;
            }
            v11[j] = CFStringCreateWithCString(0, v42, 0x8000100u);
            if ((buf[23] & 0x80000000) != 0) {
              operator delete(*(void **)buf);
            }
          }
          *a4 = CFArrayCreate(0, v11, v8, 0);
          CFIndex v43 = v8 - 1;
          unint64_t v44 = v11 + 1;
          do
          {
            CFRelease(*v44++);
            --v43;
          }
          while (v43);
          return 0;
        }
        goto LABEL_75;
      }
      return 4294956418;
    }
    unint64_t v23 = (char *)this + 624;
    if (!std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::find<unsigned int>((void *)this + 78, 2u))return 4294956418; {
    if (*((float *)std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)v23, 2u, &v46)+ 10) != 1.0)__assert_rtn("GetParameterValueStrings", "AUBSS2.cpp", 590, "std::get<3>(param) == 1");
    }
    *(_OWORD *)buf = xmmword_1E623C608;
    CFArrayRef v22 = CFArrayCreate(0, (const void **)buf, 2, 0);
LABEL_39:
    CFArrayRef v24 = v22;
    uint64_t result = 0;
    *a4 = v24;
    return result;
  }
  if (a3 != 10)
  {
    if (a3 != 16) {
      return result;
    }
    unint64_t v20 = (char *)this + 624;
    if (!std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::find<unsigned int>((void *)this + 78, 0x10u))return 4294956418; {
    CFIndex v21 = (float)(*((float *)std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)v20, 0x10u, &v46)+ 10)+ 1.0);
    }
    *(_OWORD *)buf = xmmword_1E623C618;
    *(void *)&buf[16] = @"Others";
    CFArrayRef v22 = CFArrayCreate(0, (const void **)buf, v21, 0);
    goto LABEL_39;
  }
  uint64_t v25 = (char *)this + 624;
  if (!std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::find<unsigned int>((void *)this + 78, 0xAu))return 4294956418; {
  long long v26 = (float *)std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)v25, 0xAu, &v46);
  }
  CFIndex v8 = (float)(v26[10] + 1.0);
  MEMORY[0x1F4188790](v26);
  unint64_t v11 = (const void **)((char *)&v45.__r_.__value_.__l.__data_ - v28);
  if (v27 >= 0x200) {
    size_t v29 = 512;
  }
  else {
    size_t v29 = v27;
  }
  bzero((char *)&v45 - v28, v29);
  if (v8)
  {
    for (unint64_t k = 0; k != v8; ++k)
    {
      std::to_string(&v45, k);
      uint64_t v31 = std::string::insert(&v45, 0, "Speed ", 6uLL);
      long long v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
      *(void *)&buf[16] = *((void *)&v31->__r_.__value_.__l + 2);
      *(_OWORD *)buf = v32;
      v31->__r_.__value_.__l.__size_ = 0;
      v31->__r_.__value_.__r.__words[2] = 0;
      v31->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v45.__r_.__value_.__l.__data_);
      }
      if (buf[23] >= 0) {
        uint64_t v33 = buf;
      }
      else {
        uint64_t v33 = *(const char **)buf;
      }
      v11[k] = CFStringCreateWithCString(0, v33, 0x8000100u);
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
    }
    *a4 = CFArrayCreate(0, v11, v8, 0);
    do
    {
      CFRelease(*v11++);
      --v8;
    }
    while (v8);
    return 0;
  }
LABEL_75:
  *a4 = CFArrayCreate(0, v11, v8, 0);
  return 0;
}

void sub_1BB374E74(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 - 73) < 0) {
    operator delete(*(void **)(v1 - 96));
  }
  _Unwind_Resume(exception_object);
}

uint64_t *std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::find<unsigned int>(void *a1, unsigned int a2)
{
  unint64_t v2 = a1[1];
  if (!v2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (v2 <= a2) {
      unint64_t v4 = a2 % v2;
    }
  }
  else
  {
    unint64_t v4 = (v2 - 1) & a2;
  }
  unsigned int v5 = *(uint64_t ***)(*a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  for (uint64_t result = *v5; result; uint64_t result = (uint64_t *)*result)
  {
    unint64_t v7 = result[1];
    if (v7 == a2)
    {
      if (*((_DWORD *)result + 4) == a2) {
        return result;
      }
    }
    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= v2) {
          v7 %= v2;
        }
      }
      else
      {
        v7 &= v2 - 1;
      }
      if (v7 != v4) {
        return 0;
      }
    }
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    unint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  uint64_t v10 = operator new(0x38uLL);
  *uint64_t v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v10[4] = 0;
  v10[5] = 0;
  v10[3] = 0;
  *((_DWORD *)v10 + 12) = 0;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::__rehash<true>(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v18 = *(void *)a1;
  BOOL v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    *uint64_t v10 = *v19;
LABEL_38:
    *BOOL v19 = v10;
    goto LABEL_39;
  }
  *uint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }
    else
    {
      v20 &= v7 - 1;
    }
    BOOL v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1BB37517C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::__rehash<true>(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime <= *(void *)&v4)
  {
    if (prime >= *(void *)&v4) {
      return;
    }
    unint64_t v11 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v12 = (uint8x8_t)vcnt_s8(v4), v12.i16[0] = vaddlv_u8(v12), v12.u32[0] > 1uLL))
    {
      unint64_t v11 = std::__next_prime(v11);
    }
    else
    {
      uint64_t v13 = 1 << -(char)__clz(v11 - 1);
      if (v11 >= 2) {
        unint64_t v11 = v13;
      }
    }
    if (prime <= v11) {
      size_t prime = v11;
    }
    if (prime >= *(void *)&v4) {
      return;
    }
    if (!prime)
    {
      unint64_t v16 = *(void **)a1;
      *(void *)a1 = 0;
      if (v16) {
        operator delete(v16);
      }
      *(void *)(a1 + 8) = 0;
      return;
    }
  }
  if (prime >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  unsigned int v5 = operator new(8 * prime);
  unint64_t v6 = *(void **)a1;
  *(void *)a1 = v5;
  if (v6) {
    operator delete(v6);
  }
  uint64_t v7 = 0;
  *(void *)(a1 + 8) = prime;
  do
    *(void *)(*(void *)a1 + 8 * v7++) = 0;
  while (prime != v7);
  uint8x8_t v8 = *(void **)(a1 + 16);
  if (v8)
  {
    size_t v9 = v8[1];
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)prime);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      if (v9 >= prime) {
        v9 %= prime;
      }
    }
    else
    {
      v9 &= prime - 1;
    }
    *(void *)(*(void *)a1 + 8 * v9) = a1 + 16;
    BOOL v14 = (void *)*v8;
    if (*v8)
    {
      do
      {
        size_t v15 = v14[1];
        if (v10.u32[0] > 1uLL)
        {
          if (v15 >= prime) {
            v15 %= prime;
          }
        }
        else
        {
          v15 &= prime - 1;
        }
        if (v15 != v9)
        {
          if (!*(void *)(*(void *)a1 + 8 * v15))
          {
            *(void *)(*(void *)a1 + 8 * v15) = v8;
            goto LABEL_31;
          }
          *uint8x8_t v8 = *v14;
          void *v14 = **(void **)(*(void *)a1 + 8 * v15);
          **(void **)(*(void *)a1 + 8 * v15) = v14;
          BOOL v14 = v8;
        }
        size_t v15 = v9;
LABEL_31:
        uint8x8_t v8 = v14;
        BOOL v14 = (void *)*v14;
        size_t v9 = v15;
      }
      while (v14);
    }
  }
}

void ___ZL14AUBSS2LogScopev_block_invoke()
{
}

uint64_t AUBSS2::RestoreState(OpaqueAudioComponentInstance **this, const void *a2)
{
  uint64_t result = ausdk::AUBase::RestoreState(this, a2);
  if (!result) {
    ++*((_DWORD *)this + 132);
  }
  return result;
}

UInt8 *AUBSS2::SaveExtendedScopes(AUBSS2 *this, __CFData *a2)
{
  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, 4u);

  return ausdk::AUScope::SaveState(Scope, a2);
}

uint64_t AUBSS2::GetParameterInfo(AUBSS2 *this, int a2, unsigned int a3, AudioUnitParameterInfo *a4)
{
  unsigned int v23 = a3;
  a4->flags = 0;
  a4->unitName = 0;
  if (a2 || a3 > 0x11)
  {
    uint64_t result = 4294956418;
    if (a2 != 4 || a3 > 1) {
      return result;
    }
    size_t v15 = (void *)((char *)this + 664);
    if (std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::find<unsigned int>(v15, a3))
    {
      unint64_t v16 = std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)v15, a3, &v23);
      CFStringRef v17 = (const __CFString *)v16[3];
      AudioUnitParameterValue v18 = *((float *)v16 + 8);
      AudioUnitParameterUnit v19 = *((_DWORD *)v16 + 11);
      int v20 = *((_DWORD *)v16 + 12);
      AudioUnitParameterOptions v21 = a4->flags | 0x8000000;
      uint64_t v22 = *(void *)((char *)v16 + 36);
      a4->cfNameString = v17;
      a4->flags = v21;
      CFStringGetCString(v17, a4->name, 52, 0x8000100u);
      uint64_t result = 0;
      a4->defaultCFArrayRef Value = v18;
      *(void *)&a4->minCFArrayRef Value = v22;
      a4->unit = v19;
      a4->flags |= v20;
      return result;
    }
    return 4294956418;
  }
  if (!std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::find<unsigned int>((void *)this + 78, a3))return 4294956418; {
  uint64_t v7 = std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)this + 624, a3, &v23);
  }
  CFStringRef v8 = (const __CFString *)v7[3];
  AudioUnitParameterValue v9 = *((float *)v7 + 8);
  AudioUnitParameterUnit v10 = *((_DWORD *)v7 + 11);
  int v11 = *((_DWORD *)v7 + 12);
  AudioUnitParameterOptions v12 = a4->flags | 0x8000000;
  uint64_t v13 = *(void *)((char *)v7 + 36);
  a4->cfNameString = v8;
  a4->flags = v12;
  CFStringGetCString(v8, a4->name, 52, 0x8000100u);
  a4->defaultCFArrayRef Value = v9;
  *(void *)&a4->minCFArrayRef Value = v13;
  a4->unit = v10;
  a4->flags |= v11;
  if (a3 != 7 || !*((unsigned char *)this + 17)) {
    return 0;
  }
  uint64_t result = 0;
  a4->maxCFArrayRef Value = (float)*((unsigned int *)this + 150);
  return result;
}

uint64_t AUBSS2::SetBusCount(AUBSS2 *this, int a2, unsigned int a3)
{
  unsigned int v3 = a3 - 1;
  if (a2 == 1 && v3 <= 7)
  {
    int8x8_t v4 = (AUBSS2 *)((char *)this + 80);
LABEL_7:
    ausdk::AUScope::SetNumberOfElements(v4, a3);
    return 0;
  }
  uint64_t v5 = 4294956445;
  if (a2 == 2 && v3 <= 7)
  {
    int8x8_t v4 = (AUBSS2 *)((char *)this + 128);
    goto LABEL_7;
  }
  return v5;
}

BOOL AUBSS2::BusCountWritable(AUBSS2 *this, int a2)
{
  return (a2 - 1) < 2;
}

uint64_t AUBSS2::Render(AUBSS2 *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  v32[3] = *MEMORY[0x1E4F143B8];
  CFStringRef v8 = (AUBSS2 *)((char *)this + 80);
  uint64_t v9 = *((void *)this + 15);
  if (v9) {
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 24))(v9);
  }
  else {
    uint64_t v10 = (*((void *)this + 13) - *((void *)this + 12)) >> 3;
  }
  char v11 = 0;
  if (v10)
  {
    uint64_t v12 = 0;
    do
    {
      uint64_t Element = ausdk::AUScope::GetElement(v8, v12);
      if (Element && *(_DWORD *)(Element + 172))
      {
        BOOL v14 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement(v8, v12);
        uint64_t result = ausdk::AUInputElement::PullInput(v14, a2, a3, v12, a4);
        if (result) {
          return result;
        }
      }
      else
      {
        char v11 = 1;
      }
      uint64_t v12 = (v12 + 1);
    }
    while (v10 != v12);
  }
  uint64_t v16 = *((void *)this + 21);
  if (v16)
  {
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)v16 + 24))(v16);
    LODWORD(v17) = v16;
  }
  else
  {
    uint64_t v17 = (*((void *)this + 19) - *((void *)this + 18)) >> 3;
  }
  v32[2] = v32;
  uint64_t v18 = v17;
  MEMORY[0x1F4188790](v16);
  AudioUnitParameterOptions v21 = (char *)v32 - v20;
  if (v19 >= 0x200) {
    size_t v22 = 512;
  }
  else {
    size_t v22 = v19;
  }
  bzero((char *)v32 - v20, v22);
  if (v17)
  {
    uint64_t v24 = 0;
    do
    {
      uint64_t v25 = (ausdk::AUIOElement *)ausdk::AUScope::SafeGetElement((AUBSS2 *)((char *)this + 128), v24);
      uint64_t v23 = ausdk::AUIOElement::PrepareBuffer(v25, a4);
      *(void *)&v21[8 * v24++] = v23;
    }
    while (v18 != v24);
  }
  if (v11) {
    return 0;
  }
  v32[1] = v32;
  MEMORY[0x1F4188790](v23);
  uint64_t v28 = (char *)v32 - v27;
  if (v26 >= 0x200) {
    size_t v29 = 512;
  }
  else {
    size_t v29 = v26;
  }
  bzero((char *)v32 - v27, v29);
  if (v10)
  {
    uint64_t v30 = 0;
    do
    {
      uint64_t v31 = ausdk::AUScope::SafeGetElement(v8, v30);
      *(void *)&v28[8 * v30++] = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v31 + 144));
    }
    while (v10 != v30);
  }
  return (*(uint64_t (**)(AUBSS2 *, unsigned int *, uint64_t, uint64_t, char *, uint64_t, char *))(*(void *)this + 184))(this, a2, a4, v10, v28, v18, v21);
}

uint64_t ausdk::AUIOElement::PrepareBuffer(ausdk::AUIOElement *this, unsigned int a2)
{
  if (!*((unsigned char *)this + 168)) {
    ausdk::Throw((ausdk *)0xFFFFD59DLL);
  }
  unsigned int v3 = (const AudioStreamBasicDescription *)((char *)this + 80);
  int8x8_t v4 = (ausdk::AUIOElement *)((char *)this + 144);

  return ausdk::AUBufferList::PrepareBuffer(v4, v3, a2);
}

void ausdk::Throw(ausdk *this)
{
  int v1 = (int)this;
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    v3[0] = 67109120;
    v3[1] = v1;
    _os_log_error_impl(&dword_1BB0CE000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "throwing %d", (uint8_t *)v3, 8u);
  }
  exception = (ausdk::AUException *)__cxa_allocate_exception(0x18uLL);
  ausdk::AUException::AUException(exception, v1);
}

void sub_1BB3759F8(_Unwind_Exception *exception_object)
{
}

uint64_t AUBSS2::ProcessMultipleBufferLists(AUBSS2 *this, unsigned int *a2, int a3, unsigned int a4, const AudioBufferList **a5, unsigned int a6, AudioBufferList **a7, double a8)
{
  if (*((unsigned char *)this + 376) && *((_DWORD *)this + 84) != a3) {
    return 4294956422;
  }
  LOBYTE(v40.mSampleRate) = 0;
  int v12 = *((_DWORD *)this + 136);
  LODWORD(a8) = *((_DWORD *)this + 135);
  int v13 = *((_DWORD *)this + 150);
  *(double *)&v36.UInt32 mNumberBuffers = (double)*(unint64_t *)&a8;
  v36.mBuffers[0] = (AudioBuffer)xmmword_1BB8727B0;
  int v37 = 4;
  int v38 = v13;
  uint64_t v39 = 32;
  unint64_t v14 = a4;
  if (a4)
  {
    size_t v15 = (AudioDSP::Utility *)(2 * v12);
    uint64_t v16 = a4 - 1;
    uint64_t v17 = a5;
    while (1)
    {
      uint64_t v18 = (AudioBufferList *)*v17;
      if (!*v17) {
        return 4294956420;
      }
      if (v18->mNumberBuffers != *((_DWORD *)this + 150)) {
        return 4294956428;
      }
      AudioDSP::Utility::DetectNonFinites(v15, v18, &v36, &v40, (BOOL *)a5);
      BOOL v19 = LOBYTE(v40.mSampleRate) == 0;
      BOOL v21 = v16-- != 0;
      if (!LOBYTE(v40.mSampleRate))
      {
        ++v17;
        if (v21) {
          continue;
        }
      }
      goto LABEL_15;
    }
  }
  BOOL v19 = 1;
LABEL_15:
  uint64_t v23 = a6;
  if (a6)
  {
    uint64_t v24 = a6;
    uint64_t v25 = a7;
    while (*v25)
    {
      if ((*v25)->mNumberBuffers != *((_DWORD *)this + 150)) {
        return 4294956428;
      }
      ++v25;
      if (!--v24) {
        goto LABEL_20;
      }
    }
    return 4294956420;
  }
LABEL_20:
  if (*((_DWORD *)this + 134) || !v19 && *((unsigned char *)this + 608) || (uint64_t v31 = *((void *)this + 77)) == 0)
  {
    if (a6)
    {
      unint64_t v26 = 0;
      do
      {
        if (v26 >= v14)
        {
          uint64_t v27 = a7[v26];
          if (v27->mNumberBuffers)
          {
            uint64_t v28 = 0;
            unint64_t v29 = 0;
            do
            {
              bzero(v27->mBuffers[v28].mData, v27->mBuffers[v28].mDataByteSize);
              ++v29;
              uint64_t v27 = a7[v26];
              ++v28;
            }
            while (v29 < v27->mNumberBuffers);
          }
        }
        else
        {
          CopyBufferList(&a5[v26]->mNumberBuffers, a7[v26]);
        }
        ++v26;
      }
      while (v26 != v23);
    }
    return 0;
  }
  else
  {
    if (*((_DWORD *)this + 133) != *((_DWORD *)this + 132))
    {
      AUBSS2::UpdateState((uint64_t)this);
      *((_DWORD *)this + 133) = *((_DWORD *)this + 132);
      uint64_t v31 = *((void *)this + 77);
    }
    uint64_t v22 = (*(uint64_t (**)(uint64_t, void, void))(*(void *)v31 + 8))(v31, *a5, *a7);
    if (v22) {
      CopyBufferList(&(*a5)->mNumberBuffers, *a7);
    }
    if (a6 >= 2)
    {
      unint64_t v32 = 1;
      do
      {
        if (v32 >= v14)
        {
          uint64_t v33 = a7[v32];
          if (v33->mNumberBuffers)
          {
            uint64_t v34 = 0;
            unint64_t v35 = 0;
            do
            {
              bzero(v33->mBuffers[v34].mData, v33->mBuffers[v34].mDataByteSize);
              ++v35;
              uint64_t v33 = a7[v32];
              ++v34;
            }
            while (v35 < v33->mNumberBuffers);
          }
        }
        else
        {
          uint64_t v22 = (*(uint64_t (**)(void, const AudioBufferList *, AudioBufferList *))(**((void **)this + 77)
                                                                                              + 16))(*((void *)this + 77), a5[v32], a7[v32]);
          if (v22) {
            CopyBufferList(&a5[v32]->mNumberBuffers, a7[v32]);
          }
        }
        ++v32;
      }
      while (v32 != v23);
    }
  }
  return v22;
}

unsigned int *CopyBufferList(unsigned int *result, AudioBufferList *a2)
{
  unint64_t v2 = *result;
  if (v2 == a2->mNumberBuffers && v2 != 0)
  {
    uint64_t v5 = result;
    unint64_t v6 = 0;
    unint64_t v7 = 0;
    do
    {
      size_t v8 = v5[v6 / 4 + 3];
      if (v8 <= a2->mBuffers[v6 / 0x10].mDataByteSize)
      {
        uint64_t v9 = *(unsigned int **)&v5[v6 / 4 + 4];
        uint64_t result = (unsigned int *)a2->mBuffers[v6 / 0x10].mData;
        if (v9 != result)
        {
          uint64_t result = (unsigned int *)memcpy(result, v9, v8);
          unint64_t v2 = *v5;
        }
      }
      ++v7;
      v6 += 16;
    }
    while (v7 < v2);
  }
  return result;
}

uint64_t AUBSS2::UpdateState(uint64_t this)
{
  if (*(void *)(this + 616))
  {
    uint64_t v1 = this;
    uint64_t v2 = 0;
    unsigned int v3 = (ausdk::AUScope *)(this + 32);
    do
    {
      uint64_t v4 = *(void *)(v1 + 616);
      uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::GetElement(v3, 0);
      float Parameter = ausdk::AUElement::GetParameter(Element, v2);
      this = (*(uint64_t (**)(uint64_t, uint64_t, float))(*(void *)v4 + 24))(v4, v2, Parameter);
      uint64_t v2 = (v2 + 1);
    }
    while (v2 != 18);
    if (*(_DWORD *)(v1 + 600))
    {
      unint64_t v7 = 0;
      do
      {
        size_t v8 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v1 + 552), v7);
        this = ausdk::AUElement::HasParameterID(v8, 0);
        if (this)
        {
          this = ausdk::AUElement::HasParameterID(v8, 1u);
          if (this)
          {
            float v9 = ausdk::AUElement::GetParameter(v8, 0);
            float v10 = ausdk::AUElement::GetParameter(v8, 1u);
            this = (*(uint64_t (**)(void, unint64_t, float, float))(**(void **)(v1 + 616) + 32))(*(void *)(v1 + 616), v7, v9, v10);
          }
        }
        ++v7;
      }
      while (v7 < *(unsigned int *)(v1 + 600));
    }
  }
  return this;
}

uint64_t AUBSS2::ProcessBufferLists(AUBSS2 *this, unsigned int *a2, const AudioBufferList *a3, AudioBufferList *a4, uint64_t a5)
{
  v7[1] = *MEMORY[0x1E4F143B8];
  unint64_t v6 = a4;
  v7[0] = a3;
  return (*(uint64_t (**)(AUBSS2 *, unsigned int *, uint64_t, uint64_t, void *, uint64_t, AudioBufferList **))(*(void *)this + 184))(this, a2, a5, 1, v7, 1, &v6);
}

uint64_t AUBSS2::CanScheduleParameters(AUBSS2 *this)
{
  return 0;
}

uint64_t AUBSS2::SetParameter(AUBSS2 *this, unsigned int a2, int a3, unsigned int a4, float a5)
{
  if (a3 == 4)
  {
    uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AUBSS2 *)((char *)this + 552), a4);
    goto LABEL_5;
  }
  if (!a3)
  {
    uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUBSS2 *)((char *)this + 32), 0);
LABEL_5:
    ausdk::AUElement::SetParameter(Element, a2, a5, 0);
    uint64_t result = 0;
    ++*((_DWORD *)this + 132);
    return result;
  }
  return 4294956418;
}

uint64_t AUBSS2::SetProperty(AUBSS2 *this, int a2, int a3, unsigned int a4, const __CFNumber **a5, unsigned int a6)
{
  if (a3) {
    return 4294956417;
  }
  valuePtr[3] = v6;
  valuePtr[4] = v7;
  switch(a2)
  {
    case 4501:
      CFNumberRef v10 = *a5;
      valuePtr[0] = 0;
      CFNumberGetValue(v10, kCFNumberSInt64Type, valuePtr);
      if (LODWORD(valuePtr[0]) > 2)
      {
        return 4294956445;
      }
      else
      {
        uint64_t result = 0;
        *((_DWORD *)this + 151) = valuePtr[0];
      }
      break;
    case 3700:
      uint64_t result = 4294956445;
      if (a6 >= 4)
      {
        if (*(unsigned char *)a5) {
          return 0;
        }
        else {
          return 4294956445;
        }
      }
      break;
    case 21:
      uint64_t result = 0;
      *((_DWORD *)this + 134) = *(_DWORD *)a5;
      break;
    default:
      return 4294956417;
  }
  return result;
}

uint64_t AUBSS2::GetProperty(AUBSS2 *this, int a2, int a3, unsigned int a4, _DWORD *a5)
{
  if (a3) {
    return 4294956417;
  }
  switch(a2)
  {
    case 4501:
      uint64_t result = 0;
      int v7 = *((_DWORD *)this + 151);
      break;
    case 3700:
      uint64_t result = 0;
      int v7 = *((unsigned __int8 *)this + 376);
      break;
    case 21:
      uint64_t result = 0;
      int v7 = *((_DWORD *)this + 134);
      break;
    default:
      return 4294956417;
  }
  *a5 = v7;
  return result;
}

uint64_t AUBSS2::GetPropertyInfo(AUBSS2 *this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  if (a3 || a2 != 21 && a2 != 4501 && a2 != 3700) {
    return 4294956417;
  }
  uint64_t result = 0;
  *a6 = 1;
  *a5 = 4;
  return result;
}

uint64_t AUBSS2::Reset(AUBSS2 *this)
{
  if (*((void *)this + 77))
  {
    AUBSS2::UpdateState((uint64_t)this);
    (*(void (**)(void))(**((void **)this + 77) + 40))(*((void *)this + 77));
  }
  return 0;
}

uint64_t AUBSS2::Cleanup(AUBSS2 *this)
{
  uint64_t result = *((void *)this + 77);
  *((void *)this + 77) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 56))();
  }
  return result;
}

uint64_t AUBSS2::Initialize(AUBSS2 *this)
{
  uint64_t Element = ausdk::AUScope::SafeGetElement((AUBSS2 *)((char *)this + 80), 0);
  uint64_t v3 = ausdk::AUScope::SafeGetElement((AUBSS2 *)((char *)this + 128), 0);
  unsigned int v4 = *(_DWORD *)(Element + 108);
  if (v4 != *(_DWORD *)(v3 + 108)) {
    return 4294956421;
  }
  *((_DWORD *)this + 150) = v4;
  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, 4u);
  ausdk::AUScope::SetNumberOfElements(Scope, v4);
  ausdk::AUScope::SetNumberOfElements((AUBSS2 *)((char *)this + 32), 1u);
  int v6 = *((_DWORD *)this + 151);
  switch(v6)
  {
    case 2:
      operator new();
    case 1:
      if (*((_DWORD *)this + 150) <= 3u) {
        operator new();
      }
      return 4294956421;
    case 0:
      operator new();
  }
  int v7 = (unsigned int (***)(void, void, void, void, float))*((void *)this + 77);
  if (v7)
  {
    if ((**v7)(v7, *((unsigned int *)this + 84), (*((_DWORD *)this + 84) + 1), *((unsigned int *)this + 150), (float)*((unsigned int *)this + 135)))
    {
      return 4294956421;
    }
  }
  float v9 = *(uint64_t (**)(AUBSS2 *, void, void))(*(void *)this + 72);

  return v9(this, 0, 0);
}

void AU::BSS2::AUXIVARLS<float>::~AUXIVARLS(uint64_t a1)
{
  AU::BSS2::AUXIVARLS<float>::~AUXIVARLS(a1);

  JUMPOUT(0x1C185D370);
}

uint64_t AU::BSS2::AUXIVARLS<float>::~AUXIVARLS(uint64_t a1)
{
  *(void *)a1 = &unk_1F14AC2B0;
  std::unique_ptr<t3l::RTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 336), 0);
  std::unique_ptr<t3l::RTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 328), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 320), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 312), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 304), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 296), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 288), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 280), 0);
  uint64_t v5 = (void **)(a1 + 256);
  std::vector<std::unique_ptr<t3l::ZTensor3<float>>>::__destroy_vector::operator()[abi:ne180100](&v5);
  uint64_t v5 = (void **)(a1 + 232);
  std::vector<std::unique_ptr<t3l::ZTensor3<float>>>::__destroy_vector::operator()[abi:ne180100](&v5);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 224), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 216), 0);
  uint64_t v2 = *(void **)(a1 + 192);
  if (v2)
  {
    *(void *)(a1 + 200) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)(a1 + 168);
  if (v3)
  {
    *(void *)(a1 + 176) = v3;
    operator delete(v3);
  }
  return a1;
}

uint64_t *std::unique_ptr<t3l::RTensor3<float>>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  *uint64_t result = a2;
  if (v2)
  {
    uint64_t v5 = (void **)(v2 + 80);
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
    uint64_t v3 = *(void **)(v2 + 56);
    if (v3)
    {
      *(void *)(v2 + 64) = v3;
      operator delete(v3);
    }
    unsigned int v4 = *(void **)(v2 + 32);
    if (v4)
    {
      *(void *)(v2 + 40) = v4;
      operator delete(v4);
    }
    JUMPOUT(0x1C185D370);
  }
  return result;
}

uint64_t *std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  *uint64_t result = a2;
  if (v2)
  {
    uint64_t v5 = (void **)(v2 + 104);
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
    uint64_t v5 = (void **)(v2 + 80);
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
    uint64_t v3 = *(void **)(v2 + 56);
    if (v3)
    {
      *(void *)(v2 + 64) = v3;
      operator delete(v3);
    }
    unsigned int v4 = *(void **)(v2 + 32);
    if (v4)
    {
      *(void *)(v2 + 40) = v4;
      operator delete(v4);
    }
    JUMPOUT(0x1C185D370);
  }
  return result;
}

void std::vector<std::unique_ptr<t3l::ZTensor3<float>>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (uint64_t *)**a1;
  if (v2)
  {
    unsigned int v4 = (uint64_t *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
        std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100](--v4, 0);
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t AU::BSS2::AUXIVARLS<float>::Reset(uint64_t a1)
{
  if (*(void *)(a1 + 16))
  {
    unint64_t v2 = 0;
    do
    {
      t3l::tDSP_ztfilldiag<float>(*(void **)(*(void *)(a1 + 232) + 8 * v2), *(float *)(a1 + 88));
      t3l::tDSP_ztfilldiag<float>(*(void **)(*(void *)(a1 + 256) + 8 * v2), 1.0 / *(float *)(a1 + 88));
      *(_DWORD *)(*(void *)(a1 + 168) + 4 * v2++) = 1065353216;
    }
    while (*(void *)(a1 + 16) > v2);
  }
  uint64_t v3 = *(void **)(a1 + 216);
  unint64_t v4 = v3[1];
  if (v4 != v3[2]) {
    goto LABEL_25;
  }
  vDSP_Length v5 = v3[3];
  float __A = 1.0;
  if (v4)
  {
    unint64_t v6 = 0;
    unint64_t v7 = 1;
    unint64_t v8 = v4;
    do
    {
      if (v7)
      {
        uint64_t v9 = 0;
        for (unint64_t i = 0; i < v7; ++i)
        {
          char v11 = (float **)(*(void *)(*v3 + 8 * v6) + v9);
          vDSP_vclr(*v11, 1, v5);
          vDSP_vclr(v11[1], 1, v5);
          unint64_t v7 = v3[2];
          v9 += 16;
        }
        unint64_t v8 = v3[1];
      }
      ++v6;
    }
    while (v8 > v6);
    uint64_t v12 = 0;
    for (uint64_t j = 0; j != v4; ++j)
    {
      vDSP_vfill(&__A, *(float **)(*(void *)(*v3 + 8 * j) + v12), 1, v5);
      v12 += 16;
    }
  }
  unint64_t v14 = *(void **)(a1 + 224);
  unint64_t v15 = v14[1];
  if (v15 != v14[2]) {
LABEL_25:
  }
    __assert_rtn("tDSP_zmeye", "Tensor3Lib.h", 513, "N == X.cols");
  vDSP_Length v16 = v14[3];
  float v27 = 1.0;
  if (v15)
  {
    unint64_t v17 = 0;
    unint64_t v18 = 1;
    unint64_t v19 = v15;
    do
    {
      if (v18)
      {
        uint64_t v20 = 0;
        for (unint64_t k = 0; k < v18; ++k)
        {
          uint64_t v22 = (float **)(*(void *)(*v14 + 8 * v17) + v20);
          vDSP_vclr(*v22, 1, v16);
          vDSP_vclr(v22[1], 1, v16);
          unint64_t v18 = v14[2];
          v20 += 16;
        }
        unint64_t v19 = v14[1];
      }
      ++v17;
    }
    while (v19 > v17);
    uint64_t v23 = 0;
    for (uint64_t m = 0; m != v15; ++m)
    {
      vDSP_vfill(&v27, *(float **)(*(void *)(*v14 + 8 * m) + v23), 1, v16);
      v23 += 16;
    }
  }
  *(void *)(a1 + 160) = 1;
  *(void *)(a1 + 104) = 0;
  return 0;
}

void t3l::tDSP_ztfilldiag<float>(void *a1, float a2)
{
  float __A = a2;
  float v13 = 0.0;
  unint64_t v2 = a1[1];
  if (v2)
  {
    unint64_t v4 = 0;
    unint64_t v5 = a1[2];
    vDSP_Length v6 = a1[3];
    do
    {
      if (v5)
      {
        uint64_t v7 = 0;
        for (unint64_t i = 0; i < v5; ++i)
        {
          uint64_t v9 = (float **)(*(void *)(*a1 + 8 * v4) + v7);
          vDSP_vclr(*v9, 1, v6);
          vDSP_vclr(v9[1], 1, v6);
          unint64_t v5 = a1[2];
          v7 += 16;
        }
        unint64_t v2 = a1[1];
      }
      ++v4;
    }
    while (v2 > v4);
    if (v2)
    {
      uint64_t v10 = 0;
      unint64_t v11 = 0;
      vDSP_Length v12 = a1[3];
      do
      {
        vDSP_vfill(&__A, *(float **)(*(void *)(*a1 + 8 * v11) + v10), 1, v12);
        vDSP_vfill(&v13, *(float **)(*(void *)(*a1 + 8 * v11++) + v10 + 8), 1, v12);
        v10 += 16;
      }
      while (a1[1] > v11);
    }
  }
}

uint64_t AU::BSS2::AUXIVARLS<float>::UpdatePrior(uint64_t a1, unint64_t a2, float a3, float a4)
{
  uint64_t v4 = *(void *)(a1 + 168);
  if (a2 > (*(void *)(a1 + 176) - v4) >> 2) {
    __assert_rtn("UpdatePrior", "AUBSS2Algorithm+XIVARLS.h", 366, "index <= priors.size()");
  }
  if (a3 < 0.0) {
    a3 = 0.0;
  }
  float v5 = a3 + -0.5;
  BOOL v6 = a3 <= 1.0;
  float v7 = 0.5;
  if (v6) {
    float v7 = v5;
  }
  *(float *)(v4 + 4 * a2) = expf(v7 * a4);
  return 0;
}

uint64_t AU::BSS2::AUXIVARLS<float>::UpdateParam(uint64_t a1, int a2, float a3)
{
  if (!*(unsigned char *)(a1 + 8)) {
    return 1;
  }
  switch(a2)
  {
    case 0:
      uint64_t result = 0;
      *(unsigned char *)(a1 + 120) = a3 != 0.0;
      break;
    case 1:
      *(float *)(a1 + 68) = a3;
      float v5 = 0.0;
      if (a3 > 0.0)
      {
        float v6 = *(float *)(a1 + 36);
        if (v6 <= 0.0) {
          __assert_rtn("ComputeCoefFromTC", "Tensor3Lib.h", 30, "blockFs > 0");
        }
        float v5 = expf(-1.0 / (float)(v6 * a3));
      }
      uint64_t result = 0;
      *(float *)(a1 + 72) = v5;
      break;
    case 2:
      uint64_t result = 0;
      *(unsigned char *)(a1 + 132) = a3 != 0.0;
      break;
    case 3:
      float v7 = __exp10f(a3 / 20.0);
      uint64_t result = 0;
      *(float *)(a1 + 52) = v7;
      break;
    case 4:
      float v8 = __exp10f(a3 / 20.0);
      uint64_t result = 0;
      *(float *)(a1 + 56) = v8;
      break;
    case 5:
      float v9 = __exp10f(a3 / 20.0);
      uint64_t result = 0;
      *(float *)(a1 + 60) = v9;
      break;
    case 6:
      float v10 = __exp10f(a3 / 20.0);
      uint64_t result = 0;
      *(float *)(a1 + 64) = v10;
      break;
    case 7:
      uint64_t result = 0;
      *(void *)(a1 + 112) = (unint64_t)a3;
      break;
    case 8:
      uint64_t result = 0;
      *(float *)(a1 + 48) = a3;
      break;
    case 9:
      float v11 = __exp10f(a3 / 20.0);
      uint64_t result = 0;
      *(float *)(a1 + 124) = v11;
      break;
    case 10:
      uint64_t result = 0;
      *(void *)(a1 + 96) = (unint64_t)a3;
      break;
    case 11:
      float v12 = __exp10f(a3 / 20.0);
      uint64_t result = 0;
      *(float *)(a1 + 128) = v12;
      break;
    case 12:
      uint64_t result = 0;
      *(void *)(a1 + 80) = vcvtas_u32_f32((float)(*(float *)(a1 + 32) * a3) / (float)*(unint64_t *)(a1 + 40));
      break;
    case 13:
      float v13 = __exp10f(a3 / 20.0);
      uint64_t result = 0;
      *(float *)(a1 + 88) = v13;
      break;
    case 14:
      uint64_t result = 0;
      unint64_t v14 = *(void *)(a1 + 24) - 1;
      float v15 = *(float *)(a1 + 32) / ((double)*(unint64_t *)(a1 + 40) + (double)*(unint64_t *)(a1 + 40));
      unint64_t v16 = vcvtas_u32_f32(fabsf(a3 / v15));
      if (v16 < v14) {
        unint64_t v14 = v16;
      }
      *(void *)(a1 + 136) = v14;
      break;
    case 15:
      uint64_t result = 0;
      unint64_t v17 = *(void *)(a1 + 24) - 1;
      float v18 = *(float *)(a1 + 32) / ((double)*(unint64_t *)(a1 + 40) + (double)*(unint64_t *)(a1 + 40));
      unint64_t v19 = vcvtas_u32_f32(fabsf(a3 / v18));
      if (v19 < v17) {
        unint64_t v17 = v19;
      }
      *(void *)(a1 + 144) = v17;
      break;
    default:
      return 1;
  }
  return result;
}

uint64_t AU::BSS2::AUXIVARLS<float>::SideChain(uint64_t a1, uint64_t a2, uint64_t a3)
{
  t3l::tDSP_copy_freq_abl_to_ztensor<float>(a2, **(void **)(a1 + 288), *(void *)(*(void *)(a1 + 288) + 8), *(void *)(a1 + 40), *(void *)(a1 + 16));
  AU::BSS2::GenerateOutput<float>(*(void **)(a1 + 216), *(void **)(a1 + 224), *(void *)(a1 + 288), *(void **)(a1 + 296), *(void *)(a1 + 112));
  if (*(unsigned char *)(a1 + 133) || *(unsigned char *)(a1 + 132))
  {
    if (*(void *)(a1 + 16))
    {
      unint64_t v5 = 0;
      do
      {
        float v6 = *(const DSPSplitComplex **)(**(void **)(a1 + 288) + 8 * v5);
        float v7 = **(float ***)(**(void **)(a1 + 336) + 8 * v5);
        vDSP_Length v8 = *(void *)(a1 + 24);
        float __B = 2.2204e-16;
        vDSP_zvmags(v6, 1, v7, 1, v8);
        vDSP_vsadd(v7, 1, &__B, v7, 1, v8);
        ++v5;
        unint64_t v9 = *(void *)(a1 + 16);
      }
      while (v9 > v5);
      if (v9)
      {
        unint64_t v10 = 0;
        do
        {
          float v11 = *(const DSPSplitComplex **)(**(void **)(a1 + 296) + 8 * v10);
          float v12 = **(float ***)(**(void **)(a1 + 328) + 8 * v10);
          vDSP_Length v13 = *(void *)(a1 + 24);
          float v16 = 2.2204e-16;
          vDSP_zvmags(v11, 1, v12, 1, v13);
          vDSP_vsadd(v12, 1, &v16, v12, 1, v13);
          ++v10;
        }
        while (*(void *)(a1 + 16) > v10);
      }
    }
  }
  if (*(unsigned char *)(a1 + 133)) {
    AU::BSS2::FixWNG<float>(*(void **)(a1 + 296), *(void **)(a1 + 336), *(void **)(a1 + 328), *(void *)(a1 + 320), *(void *)(a1 + 112), *(float *)(a1 + 124));
  }
  if (*(unsigned char *)(a1 + 132)) {
    AU::BSS2::MixturePhase<float>(*(void **)(a1 + 288), *(void **)(a1 + 336), *(void **)(a1 + 296), *(void **)(a1 + 328), **(float *****)(a1 + 320), *(void *)(*(void *)(a1 + 320) + 24));
  }
  t3l::tDSP_copy_ztensor_to_freq_abl<float>(**(void **)(a1 + 296), a3, *(void *)(a1 + 40), *(void *)(a1 + 16));
  return 0;
}

float t3l::tDSP_copy_freq_abl_to_ztensor<float>(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5)
{
  if (a3 < a5) {
    __assert_rtn("tDSP_copy_freq_abl_to_ztensor", "Tensor3Lib.h", 218, "XInput.rows >= numBuffs");
  }
  if (a5)
  {
    for (unint64_t i = 0; i < a5; unint64_t i = (i + 1))
    {
      float v6 = *(uint64_t **)(a2 + 8 * i);
      if (a4)
      {
        uint64_t v7 = 0;
        uint64_t v8 = *(void *)(a1 + 16 * i + 16);
        uint64_t v10 = *v6;
        unint64_t v9 = (float *)v6[1];
        do
        {
          *(_DWORD *)(v10 + 4 * v7) = *(_DWORD *)(v8 + 4 * v7);
          v9[v7] = *(float *)(v8 + 4 * a4 + 4 * v7);
          ++v7;
        }
        while (a4 > v7);
      }
      else
      {
        unint64_t v9 = (float *)v6[1];
      }
      float result = *v9;
      *(float *)(*v6 + 4 * a4) = *v9;
      v9[a4] = 0.0;
      float *v9 = 0.0;
    }
  }
  return result;
}

void AU::BSS2::GenerateOutput<float>(void *a1, void *a2, uint64_t a3, void *a4, unint64_t a5)
{
  unint64_t v8 = *(void *)(a3 + 8);
  vDSP_Length v9 = *(void *)(a3 + 24);
  t3l::tDSP_zmzvmult<float>(a1, a3, a4);
  if (a5)
  {
    double v10 = (double)a5 + -1.0;
    if ((double)v8 + -1.0 < v10) {
      double v10 = (double)v8 + -1.0;
    }
    if (v8)
    {
      uint64_t v11 = 0;
      uint64_t v12 = 0;
      unint64_t v13 = (unint64_t)v10;
      do
      {
        vDSP_zvmul(*(const DSPSplitComplex **)(*a4 + 8 * v12), 1, (const DSPSplitComplex *)(*(void *)(*a2 + 8 * v13) + v11), 1, *(const DSPSplitComplex **)(*a4 + 8 * v12), 1, v9, 1);
        ++v12;
        v11 += 16;
      }
      while (v8 != v12);
    }
  }
  else if (v8)
  {
    uint64_t v14 = 0;
    for (uint64_t i = 0; i != v8; ++i)
    {
      vDSP_zvmul(*(const DSPSplitComplex **)(*a4 + 8 * i), 1, (const DSPSplitComplex *)(*(void *)(*a2 + 8 * i) + v14), 1, *(const DSPSplitComplex **)(*a4 + 8 * i), 1, v9, 1);
      v14 += 16;
    }
  }
}

void AU::BSS2::FixWNG<float>(void *a1, void *a2, void *a3, uint64_t a4, unint64_t a5, float a6)
{
  float __A = a6;
  vDSP_Length v6 = a2[3];
  float __B = 1.0;
  int v19 = v6;
  if (v6 != a1[3]) {
    __assert_rtn("FixWNG", "AUBSS2IVALib.h", 325, "Nf == YOutput.len");
  }
  if (v6 != a3[3]) {
    __assert_rtn("FixWNG", "AUBSS2IVALib.h", 326, "Nf == YMag2.len");
  }
  if (v6 != *(void *)(a4 + 24)) {
    __assert_rtn("FixWNG", "AUBSS2IVALib.h", 327, "Nf == temp1xNf.len");
  }
  unint64_t v10 = a1[1];
  if (a2[1] < v10) {
    __assert_rtn("FixWNG", "AUBSS2IVALib.h", 328, "XMag2.rows >= Nm");
  }
  if (a3[1] < v10) {
    __assert_rtn("FixWNG", "AUBSS2IVALib.h", 329, "YMag2.rows >= Nm");
  }
  if (!*(void *)(a4 + 8)) {
    __assert_rtn("FixWNG", "AUBSS2IVALib.h", 331, "temp1xNf.rows >= 1");
  }
  if (v10)
  {
    unint64_t v12 = 0;
    unint64_t v13 = ***(float ****)a4;
    double v14 = (double)a5 + -1.0;
    if ((double)v10 + -1.0 < v14) {
      double v14 = (double)v10 + -1.0;
    }
    unint64_t v15 = (unint64_t)v14;
    do
    {
      if (a5) {
        unint64_t v16 = v15;
      }
      else {
        unint64_t v16 = v12;
      }
      vDSP_vdiv(**(const float ***)(*a2 + 8 * v16), 1, **(const float ***)(*a3 + 8 * v16), 1, v13, 1, v6);
      vvsqrtf(v13, v13, &v19);
      vDSP_svdiv(&__A, v13, 1, v13, 1, v6);
      vDSP_vmin(v13, 1, &__B, 0, v13, 1, v6);
      vDSP_zrvmul(*(const DSPSplitComplex **)(*a1 + 8 * v12), 1, v13, 1, *(const DSPSplitComplex **)(*a1 + 8 * v12), 1, v6);
      unint64_t v17 = **(float ***)(*a3 + 8 * v12);
      vDSP_vmul(v17, 1, v13, 1, v17, 1, v6);
      ++v12;
    }
    while (v10 != v12);
  }
}

void AU::BSS2::MixturePhase<float>(void *a1, void *a2, void *a3, void *a4, float ***a5, vDSP_Length __N)
{
  uint64_t v6 = a1[3];
  int v15 = v6;
  if (v6 != a2[3]) {
    __assert_rtn("MixturePhase", "AUBSS2IVALib.h", 296, "Nf == XMag2.len");
  }
  if (v6 != a3[3]) {
    __assert_rtn("MixturePhase", "AUBSS2IVALib.h", 297, "Nf == YOutput.len");
  }
  if (v6 != a4[3]) {
    __assert_rtn("MixturePhase", "AUBSS2IVALib.h", 298, "Nf == YMag2.len");
  }
  if (v6 != __N) {
    __assert_rtn("MixturePhase", "AUBSS2IVALib.h", 299, "Nf == temp1xNf.len");
  }
  uint64_t v12 = a1[1];
  if (v12 != a2[1]) {
    __assert_rtn("MixturePhase", "AUBSS2IVALib.h", 300, "Nm == XMag2.rows");
  }
  if (v12 != a3[1]) {
    __assert_rtn("MixturePhase", "AUBSS2IVALib.h", 301, "Nm == YOutput.rows");
  }
  if (v12 != a4[1]) {
    __assert_rtn("MixturePhase", "AUBSS2IVALib.h", 302, "Nm == YMag2.rows");
  }
  if (v12)
  {
    uint64_t v13 = 0;
    double v14 = **a5;
    do
    {
      vDSP_vdiv(**(const float ***)(*a2 + 8 * v13), 1, **(const float ***)(*a4 + 8 * v13), 1, v14, 1, __N);
      vvsqrtf(v14, v14, &v15);
      vDSP_zrvmul(*(const DSPSplitComplex **)(*a1 + 8 * v13), 1, v14, 1, *(const DSPSplitComplex **)(*a3 + 8 * v13), 1, __N);
      ++v13;
    }
    while (v12 != v13);
  }
}

float t3l::tDSP_copy_ztensor_to_freq_abl<float>(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  if (a4)
  {
    for (uint64_t i = 0; i != a4; ++i)
    {
      uint64_t v5 = *(void *)(a2 + 16 * i + 16);
      uint64_t v6 = *(uint64_t **)(a1 + 8 * i);
      uint64_t v7 = *v6;
      if (a3)
      {
        uint64_t v8 = 0;
        uint64_t v9 = v6[1];
        do
        {
          *(_DWORD *)(v5 + 4 * v8) = *(_DWORD *)(v7 + 4 * v8);
          *(_DWORD *)(v5 + 4 * a3 + 4 * v8) = *(_DWORD *)(v9 + 4 * v8);
          ++v8;
        }
        while (a3 > v8);
      }
      float result = *(float *)(v7 + 4 * a3);
      *(float *)(v5 + 4 * a3) = result;
    }
  }
  return result;
}

void t3l::tDSP_zmzvmult<float>(void *a1, uint64_t a2, void *a3)
{
  vDSP_Length __N = a1[3];
  if (__N != *(void *)(a2 + 24) || __N != a3[3]) {
    __assert_rtn("tDSP_zmzvmult", "Tensor3Lib.h", 603, "A.len == b.len && (A.len == c.len)");
  }
  unint64_t v7 = a1[2];
  if (v7 != *(void *)(a2 + 8)) {
    __assert_rtn("tDSP_zmzvmult", "Tensor3Lib.h", 604, "A.cols == b.rows");
  }
  if (*(void *)(a2 + 16) != 1) {
    __assert_rtn("tDSP_zmzvmult", "Tensor3Lib.h", 605, "b.cols == 1");
  }
  if (a3[2] != 1) {
    __assert_rtn("tDSP_zmzvmult", "Tensor3Lib.h", 606, "c.cols == 1");
  }
  uint64_t v9 = a1[1];
  if (v9)
  {
    for (uint64_t i = 0; i != v9; ++i)
    {
      vDSP_zvmul(*(const DSPSplitComplex **)(*a1 + 8 * i), 1, **(const DSPSplitComplex ***)a2, 1, *(const DSPSplitComplex **)(*a3 + 8 * i), 1, __N, 1);
      if (v7 >= 2)
      {
        uint64_t v11 = 16;
        for (uint64_t j = 1; j != v7; ++j)
        {
          vDSP_zvma((const DSPSplitComplex *)(*(void *)(*a1 + 8 * i) + v11), 1, *(const DSPSplitComplex **)(*(void *)a2 + 8 * j), 1, *(const DSPSplitComplex **)(*a3 + 8 * i), 1, *(const DSPSplitComplex **)(*a3 + 8 * i), 1, __N);
          v11 += 16;
        }
      }
    }
  }
}

uint64_t AU::BSS2::AUXIVARLS<float>::Process(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!*(unsigned char *)(a1 + 8)) {
    return 1;
  }
  uint64_t v4 = a1;
  ++*(void *)(a1 + 160);
  t3l::tDSP_copy_freq_abl_to_ztensor<float>(a2, **(void **)(a1 + 288), *(void *)(*(void *)(a1 + 288) + 8), *(void *)(a1 + 40), *(void *)(a1 + 16));
  if (*(void *)(v4 + 16))
  {
    unint64_t v5 = 0;
    do
    {
      uint64_t v6 = *(const DSPSplitComplex **)(**(void **)(v4 + 288) + 8 * v5);
      unint64_t v7 = **(float ***)(**(void **)(v4 + 336) + 8 * v5);
      vDSP_Length v8 = *(void *)(v4 + 24);
      float __B = 2.2204e-16;
      vDSP_zvmags(v6, 1, v7, 1, v8);
      vDSP_vsadd(v7, 1, &__B, v7, 1, v8);
      ++v5;
    }
    while (*(void *)(v4 + 16) > v5);
  }
  if (*(unsigned char *)(v4 + 120) && AU::BSS2::AboveMinEnergyThreshold<float>(*(void **)(v4 + 336), *(float *)(v4 + 128)))
  {
    uint64_t v9 = *(void *)(v4 + 16);
    unint64_t v10 = *(void **)(v4 + 288);
    if (v9)
    {
      uint64_t v11 = (_DWORD ***)*v10;
      do
      {
        uint64_t v12 = *v11++;
        *float *v12 = (*v12)[1];
        *v12[1] = v12[1][1];
        --v9;
      }
      while (v9);
    }
    t3l::tDSP_zmzvmult<float>(*(void **)(v4 + 216), (uint64_t)v10, *(void **)(v4 + 296));
    if (*(void *)(v4 + 16))
    {
      uint64_t v13 = 0;
      unint64_t v14 = 0;
      do
      {
        int v15 = *(const DSPSplitComplex **)(**(void **)(v4 + 296) + 8 * v14);
        vDSP_zvmags(v15, 1, v15->realp, 1, *(void *)(v4 + 24));
        vDSP_sve((const float *)(**(void **)(**(void **)(v4 + 296) + 8 * v14) + 4 * *(void *)(v4 + 136)), 1, (float *)(*(void *)(v4 + 192) + v13), *(void *)(v4 + 144) - *(void *)(v4 + 136));
        uint64_t v16 = *(void *)(v4 + 192);
        double v17 = (float)(*(float *)(v4 + 48) * 0.5);
        long double v18 = log2((float)(*(float *)(v16 + 4 * v14) + *(float *)(v4 + 52)));
        float v19 = exp2(v18 * v17);
        *(float *)(v16 + 4 * v14) = v19;
        *(float *)(v16 + 4 * v14) = *(float *)(*(void *)(v4 + 168) + 4 * v14) * v19;
        ++v14;
        v13 += 4;
      }
      while (*(void *)(v4 + 16) > v14);
    }
    t3l::tDSP_ztvztvhmultupper<float>(*(void **)(v4 + 288), *(void **)(v4 + 288), *(void **)(v4 + 304));
    if (*(float *)(v4 + 56) > 0.0) {
      t3l::tDSP_zmsreg<float>(*(void **)(v4 + 304), (const float *)(v4 + 56));
    }
    unint64_t v20 = *(void *)(v4 + 16);
    if (v20)
    {
      for (unint64_t i = 0; i < v20; ++i)
      {
        AU::BSS2::UpdateVj<float>(*(void **)(v4 + 304), *(void **)(*(void *)(v4 + 232) + 8 * i), *(const float *****)(v4 + 296), 1, *(float *)(*(void *)(v4 + 192) + 4 * i), *(float *)(v4 + 72), *(float *)(v4 + 60));
        unint64_t v20 = *(void *)(v4 + 16);
      }
    }
    int v22 = *(unsigned __int8 *)(v4 + 152);
    uint64_t v87 = a3;
    uint64_t v91 = v4;
    if (*(unsigned char *)(v4 + 152))
    {
      if (v20)
      {
        for (unint64_t j = 0; j < v24; ++j)
        {
          t3l::tDSP_zminverselu<float>(*(void **)(*(void *)(v4 + 232) + 8 * j), *(void **)(*(void *)(v4 + 256) + 8 * j), *(void **)(v4 + 328), *(uint64_t **)(v4 + 304), *(uint64_t **)(v4 + 296), *(void *)(v4 + 320));
          unint64_t v24 = *(void *)(v4 + 16);
        }
        if (!v22)
        {
LABEL_56:
          t3l::tDSP_ztmov<float>(*(void **)(v4 + 216), *(void **)(v4 + 280));
          if (*(void *)(v4 + 16))
          {
            unint64_t v45 = 0;
            do
            {
              int v46 = *(void **)(*(void *)(v4 + 256) + 8 * v45);
              unint64_t v47 = *(void **)(v4 + 216);
              uint64_t v48 = *(void *)(v4 + 224);
              vDSP_Length v49 = v46[3];
              if (v49 != *(void *)(v48 + 24) || v49 != v47[3]) {
                __assert_rtn("tDSP_zmzmekmulth", "Tensor3Lib.h", 693, "A.len == B.len && A.len == C.len");
              }
              unint64_t v51 = v46[2];
              if (v51 <= v45) {
                __assert_rtn("tDSP_zmzmekmulth", "Tensor3Lib.h", 694, "BcolInd < A.cols");
              }
              uint64_t v52 = v46[1];
              if (v52)
              {
                for (uint64_t k = 0; k != v52; ++k)
                {
                  vDSP_zvmul(*(const DSPSplitComplex **)(*v46 + 8 * k), 1, (const DSPSplitComplex *)(**(void **)v48 + 16 * v45), 1, (const DSPSplitComplex *)(*(void *)(*v47 + 8 * v45) + 16 * k), 1, v49, 1);
                  if (v51 >= 2)
                  {
                    uint64_t v54 = 16;
                    for (uint64_t m = 1; m != v51; ++m)
                    {
                      unint64_t v56 = (const DSPSplitComplex *)(*(void *)(*v47 + 8 * v45) + 16 * k);
                      vDSP_zvma((const DSPSplitComplex *)(*(void *)(*v46 + 8 * k) + v54), 1, (const DSPSplitComplex *)(*(void *)(*(void *)v48 + 8 * m) + 16 * v45), 1, v56, 1, v56, 1, v49);
                      v54 += 16;
                    }
                  }
                  uint64_t v57 = *(float **)(*(void *)(*v47 + 8 * v45) + 16 * k + 8);
                  vDSP_vneg(v57, 1, v57, 1, v49);
                }
                uint64_t v4 = v91;
                unint64_t v47 = *(void **)(v91 + 216);
              }
              AU::BSS2::UpdateWScale<float>(v47, v45, *(void *)(*(void *)(v4 + 232) + 8 * v45), v47, *(const DSPSplitComplex ****)(v4 + 296), *(const DSPSplitComplex ****)(v4 + 320));
              unint64_t v58 = *(void **)(v4 + 280);
              unint64_t v59 = *(void **)(v4 + 216);
              uint64_t v60 = *(void **)(v4 + 224);
              long long v62 = *(const DSPSplitComplex ****)(v4 + 296);
              vDSP_Length v61 = *(void **)(v4 + 304);
              uint64_t v93 = *(const DSPSplitComplex ****)(v4 + 312);
              BOOL v88 = *(float *****)(v4 + 320);
              uint64_t v63 = v59[1];
              vDSP_Length v64 = v59[3];
              float __B = 1.0;
              if (v63)
              {
                uint64_t v65 = 0;
                for (uint64_t n = 0; n != v63; ++n)
                {
                  vDSP_zvsub((const DSPSplitComplex *)(*(void *)(*v59 + 8 * v45) + v65), 1, (const DSPSplitComplex *)(*(void *)(*v58 + 8 * v45) + v65), 1, (*v62)[n], 1, v64);
                  v65 += 16;
                }
              }
              uint64_t v90 = v63;
              vDSP_Length v67 = (vDSP_Length)v62[3];
              if (v67 != v60[3] || v67 != (void)v93[3]) {
                __assert_rtn("tDSP_zvtzmmult", "Tensor3Lib.h", 726, "a.len == B.len && a.len == c.len");
              }
              uint64_t v69 = v62[1];
              if (v69 != (const DSPSplitComplex **)v60[2]) {
                __assert_rtn("tDSP_zvtzmmult", "Tensor3Lib.h", 727, "arows == bcols");
              }
              if (v69 != v93[1]) {
                __assert_rtn("tDSP_zvtzmmult", "Tensor3Lib.h", 728, "a.rows == c.rows");
              }
              if (v62 == v93) {
                __assert_rtn("tDSP_zvtzmmult", "Tensor3Lib.h", 729, "&a != &c");
              }
              if (v69)
              {
                for (iunint64_t i = 0; ii != v69; iunint64_t i = (const DSPSplitComplex **)((char *)ii + 1))
                {
                  vDSP_zvmul(**v62, 1, (const DSPSplitComplex *)(*(void *)*v60 + 16 * (void)ii), 1, (*v93)[(void)ii], 1, v67, 1);
                  if (v69 != (const DSPSplitComplex **)1)
                  {
                    for (junint64_t j = 1; (const DSPSplitComplex **)jj != v69; ++jj)
                      vDSP_zvma((*v62)[jj], 1, (const DSPSplitComplex *)(*(void *)(*v60 + 8 * jj) + 16 * (void)ii), 1, (*v93)[(void)ii], 1, (*v93)[(void)ii], 1, v67);
                  }
                }
              }
              vDSP_vsadd((*v93)[v45]->realp, 1, &__B, ***v88, 1, v64);
              vDSP_svdiv(&__B, ***v88, 1, ***v88, 1, v64);
              if (v63)
              {
                uint64_t v72 = 0;
                uint64_t v4 = v91;
                do
                {
                  vDSP_zrvmul((*v93)[v72], 1, ***v88, 1, (*v93)[v72], 1, v64);
                  ++v72;
                }
                while (v63 != v72);
                AU::BSS2::vDSP_zmekzvhmultT<float>(v60, v45, v93, v61);
                uint64_t v73 = 0;
                do
                {
                  uint64_t v74 = 0;
                  uint64_t v75 = v90;
                  do
                  {
                    vDSP_zvsub((const DSPSplitComplex *)(*(void *)(*v60 + 8 * v73) + v74), 1, (const DSPSplitComplex *)(*(void *)(*v61 + 8 * v73) + v74), 1, (const DSPSplitComplex *)(*(void *)(*v60 + 8 * v73) + v74), 1, v64);
                    v74 += 16;
                    --v75;
                  }
                  while (v75);
                  ++v73;
                }
                while (v73 != v90);
              }
              else
              {
                AU::BSS2::vDSP_zmekzvhmultT<float>(v60, v45, v93, v61);
                uint64_t v4 = v91;
              }
              ++v45;
            }
            while (*(void *)(v4 + 16) > v45);
          }
          goto LABEL_98;
        }
        if (v24)
        {
          unint64_t v44 = 0;
          do
          {
            AU::BSS2::UpdateWProject<float>(*(void **)(v4 + 216), v44, *(void *)(*(void *)(v4 + 232) + 8 * v44), *(void **)(v4 + 328), *(void **)(v4 + 304), *(uint64_t **)(v4 + 296), *(const DSPSplitComplex ****)(v4 + 320), *(float *)(v4 + 64));
            AU::BSS2::UpdateWScale<float>(*(void **)(v4 + 216), v44, *(void *)(*(void *)(v4 + 232) + 8 * v44), *(void **)(v4 + 216), *(const DSPSplitComplex ****)(v4 + 296), *(const DSPSplitComplex ****)(v4 + 304));
            ++v44;
          }
          while (*(void *)(v4 + 16) > v44);
        }
      }
      t3l::tDSP_zminverselu<float>(*(void **)(v4 + 216), *(void **)(v4 + 224), *(void **)(v4 + 328), *(uint64_t **)(v4 + 304), *(uint64_t **)(v4 + 296), *(void *)(v4 + 320));
LABEL_98:
      AU::BSS2::GenerateOutput<float>(*(void **)(v4 + 216), *(void **)(v4 + 224), *(void *)(v4 + 288), *(void **)(v4 + 296), *(void *)(v4 + 112));
      if (*(void *)(v4 + 16))
      {
        unint64_t v76 = 0;
        do
        {
          uint64_t v77 = *(const DSPSplitComplex **)(**(void **)(v4 + 296) + 8 * v76);
          uint64_t v78 = **(float ***)(**(void **)(v4 + 328) + 8 * v76);
          vDSP_Length v79 = *(void *)(v4 + 24);
          float __B = 2.2204e-16;
          vDSP_zvmags(v77, 1, v78, 1, v79);
          vDSP_vsadd(v78, 1, &__B, v78, 1, v79);
          ++v76;
        }
        while (*(void *)(v4 + 16) > v76);
      }
      uint64_t v80 = v87;
      if (*(unsigned char *)(v4 + 133)) {
        AU::BSS2::FixWNG<float>(*(void **)(v4 + 296), *(void **)(v4 + 336), *(void **)(v4 + 328), *(void *)(v4 + 304), *(void *)(v4 + 112), *(float *)(v4 + 124));
      }
      if (*(unsigned char *)(v4 + 132)) {
        AU::BSS2::MixturePhase<float>(*(void **)(v4 + 288), *(void **)(v4 + 336), *(void **)(v4 + 296), *(void **)(v4 + 328), **(float *****)(v4 + 304), *(void *)(*(void *)(v4 + 304) + 24));
      }
      *(unsigned char *)(v4 + 152) = 0;
      if (*(void *)(v4 + 16))
      {
        unint64_t v81 = 0;
        vDSP_Length v82 = *(void *)(v4 + 24);
        unint64_t v83 = ****(float *****)(v4 + 304);
        do
        {
          float v84 = *(const float ***)(**(void **)(v4 + 296) + 8 * v81);
          vDSP_vadd(*v84, 1, v84[1], 1, v83, 1, v82);
          if (v82)
          {
            for (kuint64_t k = 0; kk != v82; ++kk)
              ;
          }
          ++v81;
          unint64_t v86 = *(void *)(v4 + 16);
        }
        while (v86 > v81);
        uint64_t v80 = v87;
      }
      else
      {
        unint64_t v86 = 0;
      }
      t3l::tDSP_copy_ztensor_to_freq_abl<float>(**(void **)(v4 + 296), v80, *(void *)(v4 + 40), v86);
      return 0;
    }
    if (v20)
    {
      uint64_t v26 = 0;
      do
      {
        float v27 = *(void **)(*(void *)(v4 + 256) + 8 * v26);
        float v28 = *(float *)(v4 + 72);
        uint64_t v30 = *(const DSPSplitComplex ****)(v4 + 296);
        unint64_t v29 = *(void **)(v4 + 304);
        uint64_t v31 = *(void *)(v4 + 288);
        uint64_t v32 = *(void *)(v4 + 320);
        vDSP_Length v33 = *(void *)(v31 + 24);
        uint64_t v34 = *(const DSPSplitComplex ***)(v31 + 8);
        float __A = (float)(1.0 - v28) / *(float *)(*(void *)(v4 + 192) + 4 * v26);
        float __B = v28 * v28;
        float v94 = __A * v28;
        float v95 = 1.0 / v28;
        if (v34 != (const DSPSplitComplex **)v27[1]) {
          __assert_rtn("tDSP_zvtzmzvmult", "Tensor3Lib.h", 776, "a.rows == B.rows");
        }
        if (v34 != (const DSPSplitComplex **)v27[2]) {
          __assert_rtn("tDSP_zvtzmzvmult", "Tensor3Lib.h", 777, "a.rows == B.cols");
        }
        if (*(void *)(v32 + 8) != 1) {
          __assert_rtn("tDSP_zvtzmzvmult", "Tensor3Lib.h", 778, "1 == c.rows");
        }
        if (*(void *)(v32 + 16) != 1) {
          __assert_rtn("tDSP_zvtzmzvmult", "Tensor3Lib.h", 779, "1 == c.cols");
        }
        if (v30[1] != v34) {
          __assert_rtn("tDSP_zvtzmzvmult", "Tensor3Lib.h", 780, "Ba.rows == a.rows");
        }
        if (v30[2] != (const DSPSplitComplex **)1) {
          __assert_rtn("tDSP_zvtzmzvmult", "Tensor3Lib.h", 781, "Ba.cols == 1");
        }
        if (v33 != v27[3] || (const DSPSplitComplex **)v33 != v30[3] || v33 != *(void *)(v32 + 24)) {
          __assert_rtn("tDSP_zvtzmzvmult", "Tensor3Lib.h", 782, "a.len == B.len && a.len == Ba.len && a.len == c.len");
        }
        unint64_t v92 = v34;
        t3l::tDSP_zmzvmult<float>(v27, v31, v30);
        vDSP_Length __N = *(void *)(v31 + 24);
        if ((const DSPSplitComplex **)__N != v30[3] || __N != *(void *)(v32 + 24)) {
          __assert_rtn("tDSP_zvhzvmult", "Tensor3Lib.h", 753, "a.len == b.len && a.len == c.len");
        }
        unint64_t v36 = *(void *)(v31 + 8);
        if ((const DSPSplitComplex **)v36 != v30[1]) {
          __assert_rtn("tDSP_zvhzvmult", "Tensor3Lib.h", 754, "a.rows == b.rows");
        }
        if (*(void *)(v31 + 16) != 1 || v30[2] != (const DSPSplitComplex **)1) {
          __assert_rtn("tDSP_zvhzvmult", "Tensor3Lib.h", 755, "a.cols == b.cols && a.cols == 1");
        }
        uint64_t v89 = v26;
        vDSP_zvmul(**(const DSPSplitComplex ***)v31, 1, **v30, 1, **(const DSPSplitComplex ***)v32, 1, __N, -1);
        if (v36 >= 2)
        {
          for (muint64_t m = 1; mm != v36; ++mm)
            vDSP_zvcma(*(const DSPSplitComplex **)(*(void *)v31 + 8 * mm), 1, (*v30)[mm], 1, **(const DSPSplitComplex ***)v32, 1, **(const DSPSplitComplex ***)v32, 1, __N);
        }
        vDSP_vsmul(***(const float ****)v32, 1, &v94, ***(float ****)v32, 1, v33);
        vDSP_vsadd(***(const float ****)v32, 1, &__B, ***(float ****)v32, 1, v33);
        vDSP_svdiv(&__A, ***(const float ****)v32, 1, ***(float ****)v32, 1, v33);
        vDSP_vneg(***(const float ****)v32, 1, ***(float ****)v32, 1, v33);
        t3l::tDSP_ztvztvhmultupper<float>(v30, v30, v29);
        int v38 = v92;
        if (v92)
        {
          uint64_t v39 = 0;
          for (nuint64_t n = 0; nn != v92; nuint64_t n = (const DSPSplitComplex **)((char *)nn + 1))
          {
            uint64_t v41 = v39;
            uint64_t v42 = v38;
            do
            {
              vDSP_zrvmul((const DSPSplitComplex *)(*(void *)(*v29 + 8 * (void)nn) + v41), 1, ***(const float ****)v32, 1, (const DSPSplitComplex *)(*(void *)(*v29 + 8 * (void)nn) + v41), 1, v33);
              CFIndex v43 = (const float **)(*(void *)(*v27 + 8 * (void)nn) + v41);
              vDSP_vsmul(*v43, 1, &v95, (float *)*v43, 1, v33);
              vDSP_vsmul(v43[1], 1, &v95, (float *)v43[1], 1, v33);
              vDSP_zvadd((const DSPSplitComplex *)(*(void *)(*v27 + 8 * (void)nn) + v41), 1, (const DSPSplitComplex *)(*(void *)(*v29 + 8 * (void)nn) + v41), 1, (const DSPSplitComplex *)(*(void *)(*v27 + 8 * (void)nn) + v41), 1, v33);
              v41 += 16;
              uint64_t v42 = (const DSPSplitComplex **)((char *)v42 - 1);
            }
            while (v42);
            int v38 = (const DSPSplitComplex **)((char *)v38 - 1);
            v39 += 16;
          }
        }
        t3l::tDSP_ztsymmetric<float>(v27);
        uint64_t v4 = v91;
        uint64_t v26 = v89 + 1;
      }
      while (*(void *)(v91 + 16) > (unint64_t)(v89 + 1));
    }
    goto LABEL_56;
  }
  AU::BSS2::GenerateOutput<float>(*(void **)(v4 + 216), *(void **)(v4 + 224), *(void *)(v4 + 288), *(void **)(v4 + 296), *(void *)(v4 + 112));
  return 0;
}

BOOL AU::BSS2::AboveMinEnergyThreshold<float>(void *a1, float a2)
{
  if (a1[1])
  {
    unint64_t v4 = 0;
    vDSP_Length v5 = a1[3];
    float v6 = 3.4028e38;
    do
    {
      float __C = 0.0;
      vDSP_sve(**(const float ***)(*a1 + 8 * v4), 1, &__C, v5);
      float v7 = sqrtf((float)(fabsf(__C) / (float)((float)v5 + 2.2204e-16)) + 2.2204e-16);
      if (v7 < v6) {
        float v6 = v7;
      }
      ++v4;
    }
    while (v4 < a1[1]);
  }
  else
  {
    float v6 = 3.4028e38;
  }
  return v6 >= a2;
}

void t3l::tDSP_ztvztvhmultupper<float>(void *a1, void *a2, void *a3)
{
  uint64_t v3 = a1[1];
  if (v3 != a2[1]) {
    __assert_rtn("tDSP_ztvztvhmultupper", "Tensor3Lib.h", 832, "a.rows == b.rows");
  }
  if (a1[2] != a2[2]) {
    __assert_rtn("tDSP_ztvztvhmultupper", "Tensor3Lib.h", 833, "a.cols == b.cols");
  }
  if (a3[1] != v3) {
    __assert_rtn("tDSP_ztvztvhmultupper", "Tensor3Lib.h", 834, "C.rows == a.rows");
  }
  if (a3[2] != v3) {
    __assert_rtn("tDSP_ztvztvhmultupper", "Tensor3Lib.h", 835, "C.cols == a.rows");
  }
  vDSP_Length v7 = a1[3];
  if (v7 != a3[3]) {
    __assert_rtn("tDSP_ztvztvhmultupper", "Tensor3Lib.h", 836, "a.len == C.len");
  }
  if (a2[3] != v7) {
    __assert_rtn("tDSP_ztvztvhmultupper", "Tensor3Lib.h", 837, "b.len == C.len");
  }
  if (v3)
  {
    uint64_t v8 = 0;
    for (uint64_t i = 0; i != v3; ++i)
    {
      uint64_t v10 = v8;
      uint64_t v11 = i;
      do
      {
        vDSP_zvmul(*(const DSPSplitComplex **)(*a2 + 8 * v11++), 1, *(const DSPSplitComplex **)(*a1 + 8 * i), 1, (const DSPSplitComplex *)(*(void *)(*a3 + 8 * i) + v10), 1, v7, -1);
        v10 += 16;
      }
      while (v3 != v11);
      v8 += 16;
    }
    uint64_t v12 = 0;
    uint64_t v13 = 8;
    do
    {
      vDSP_vclr(*(float **)(*(void *)(*a3 + 8 * v12++) + v13), 1, v7);
      v13 += 16;
    }
    while (v3 != v12);
  }
}

void t3l::tDSP_zmsreg<float>(void *a1, const float *__B)
{
  uint64_t v2 = a1[1];
  if (v2 != a1[2]) {
    __assert_rtn("tDSP_zmsreg", "Tensor3Lib.h", 880, "Nm == A.cols");
  }
  if (*__B < 0.0) {
    __assert_rtn("tDSP_zmsreg", "Tensor3Lib.h", 881, "reg >= 0");
  }
  if (v2)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    vDSP_Length v7 = a1[3];
    do
    {
      uint64_t v8 = *(float **)(*(void *)(*a1 + 8 * v6) + v5);
      vDSP_vsadd(v8, 1, __B, v8, 1, v7);
      ++v6;
      v5 += 16;
    }
    while (v2 != v6);
  }
}

void AU::BSS2::UpdateVj<float>(void *a1, void *a2, const float ****a3, char a4, float a5, float a6, float a7)
{
  float v24 = a7;
  if (a5 <= 0.0) {
    __assert_rtn("UpdateVj", "AUBSS2IVALib.h", 231, "rk > 0");
  }
  if (a6 < 0.0) {
    __assert_rtn("UpdateVj", "AUBSS2IVALib.h", 232, "covAlpha >= 0");
  }
  if (a7 < 0.0) {
    __assert_rtn("UpdateVj", "AUBSS2IVALib.h", 233, "weightedCovReg >= 0");
  }
  vDSP_Length v10 = a1[3];
  if (v10 != a2[3]) {
    __assert_rtn("UpdateVj", "AUBSS2IVALib.h", 234, "Nv == Vj.len");
  }
  if ((const float ***)v10 != a3[3]) {
    __assert_rtn("UpdateVj", "AUBSS2IVALib.h", 235, "Nv == temp1x1xNf.len");
  }
  if (!a3[1] || !a3[2]) {
    __assert_rtn("UpdateVj", "AUBSS2IVALib.h", 236, "temp1x1xNf.rows >= 1 && temp1x1xNf.cols >= 1");
  }
  unint64_t v12 = a1[1];
  if (a1[2] != v12) {
    __assert_rtn("UpdateVj", "AUBSS2IVALib.h", 237, "xxt.cols == Nm");
  }
  if (a2[1] != v12) {
    __assert_rtn("UpdateVj", "AUBSS2IVALib.h", 238, "Vj.rows == Nm");
  }
  if (a2[2] != v12) {
    __assert_rtn("UpdateVj", "AUBSS2IVALib.h", 239, "Vj.cols == Nm");
  }
  float __B = 1.0 / a5;
  float v23 = a6 / (float)(1.0 - a6);
  if (v12)
  {
    uint64_t v13 = 0;
    for (unint64_t i = 0; i != v12; ++i)
    {
      uint64_t v21 = v13;
      unint64_t v15 = i;
      do
      {
        uint64_t v16 = (const float **)(*(void *)(*a1 + 8 * i) + v13);
        double v17 = (float **)**a3;
        vDSP_vsmul(*v16, 1, &__B, *v17, 1, v10);
        vDSP_vsmul(v16[1], 1, &__B, v17[1], 1, v10);
        long double v18 = **a3;
        float v19 = (float **)(*(void *)(*a2 + 8 * i) + v13);
        vDSP_vavlin(*v18, 1, &v23, *v19, 1, v10);
        vDSP_vavlin(v18[1], 1, &v23, v19[1], 1, v10);
        ++v15;
        v13 += 16;
      }
      while (v15 < v12);
      uint64_t v13 = v21 + 16;
    }
  }
  if (a4) {
    t3l::tDSP_ztsymmetric<float>(a2);
  }
  if (a7 > 0.0) {
    t3l::tDSP_zmsreg<float>(a2, &v24);
  }
}

void *t3l::tDSP_zmeyef<float>(void *result, uint64_t a2)
{
  uint64_t v2 = result[1];
  if (v2 != result[2]) {
    __assert_rtn("tDSP_zmeyef", "Tensor3Lib.h", 527, "X.rows == X.cols");
  }
  if (v2)
  {
    for (uint64_t i = 0; i != v2; ++i)
    {
      uint64_t v4 = 0;
      uint64_t v5 = (uint64_t *)(*(void *)(*result + 8 * i) + 8);
      do
      {
        if (i == v4) {
          float v6 = 1.0;
        }
        else {
          float v6 = 0.0;
        }
        *(float *)(*(v5 - 1) + 4 * a2) = v6;
        uint64_t v7 = *v5;
        v5 += 2;
        *(_DWORD *)(v7 + 4 * a2) = 0;
        ++v4;
      }
      while (v2 != v4);
    }
  }
  return result;
}

void t3l::tDSP_ztsymmetric<float>(void *a1)
{
  uint64_t v1 = a1[1];
  if (v1 != a1[2]) {
    __assert_rtn("tDSP_ztsymmetric", "Tensor3Lib.h", 576, "A.rows == A.cols");
  }
  if (v1)
  {
    uint64_t v3 = 0;
    vDSP_Length v4 = a1[3];
    do
    {
      if (v3)
      {
        uint64_t v5 = 0;
        for (uint64_t i = 0; i != v3; ++i)
        {
          vDSP_zvconj((const DSPSplitComplex *)(*(void *)(*a1 + 8 * i) + 16 * v3), 1, (const DSPSplitComplex *)(*(void *)(*a1 + 8 * v3) + v5), 1, v4);
          v5 += 16;
        }
      }
      vDSP_vclr(*(float **)(*(void *)(*a1 + 8 * v3) + 16 * v3 + 8), 1, v4);
      ++v3;
    }
    while (v3 != v1);
  }
}

void t3l::tDSP_zminverselu<float>(void *a1, void *a2, void *a3, uint64_t *a4, uint64_t *a5, uint64_t a6)
{
  t3l::tDSP_ztmov<float>(a1, a4);
  int v22 = a3;
  float v24 = (const DSPSplitComplex ***)a6;
  t3l::tDSP_zmlu<float>(a4, a3, a5, (const DSPSplitComplex ***)a6);
  unint64_t v11 = a4[1];
  float v23 = a4;
  if (a4[2] < v11) {
    __assert_rtn("tDSP_zminverse_from_lu", "Tensor3Lib.h", 1117, "lu.cols >= n");
  }
  if (a5[1] < v11) {
    __assert_rtn("tDSP_zminverse_from_lu", "Tensor3Lib.h", 1118, "tempNx1xNf.rows >= n");
  }
  if (!*(void *)(a6 + 8)) {
    __assert_rtn("tDSP_zminverse_from_lu", "Tensor3Lib.h", 1119, "temp1x1xNf.rows >= 1");
  }
  if (a2[1] < v11) {
    __assert_rtn("tDSP_zminverse_from_lu", "Tensor3Lib.h", 1120, "inv.rows >= n");
  }
  if (a2[2] < v11) {
    __assert_rtn("tDSP_zminverse_from_lu", "Tensor3Lib.h", 1121, "inv.cols >= n");
  }
  vDSP_Length v12 = a4[3];
  if (v12 != a2[3] || v12 != a3[3] || v12 != a5[3] || v12 != *(void *)(a6 + 24)) {
    __assert_rtn("tDSP_zminverse_from_lu", "Tensor3Lib.h", 1126, "lu.len == inv.len && lu.len == pivotNx1xNf.len && lu.len == tempNx1xNf.len && lu.len == temp1x1xNf.len && lu.len == inv.len");
  }
  float __A = 1.0;
  if (v11)
  {
    for (uint64_t i = 0; i != v11; ++i)
    {
      unint64_t v14 = a5[1];
      if (v14)
      {
        unint64_t v15 = 0;
        unint64_t v16 = a5[2];
        vDSP_Length v17 = a5[3];
        do
        {
          if (v16)
          {
            uint64_t v18 = 0;
            for (unint64_t j = 0; j < v16; ++j)
            {
              unint64_t v20 = (float **)(*(void *)(*a5 + 8 * v15) + v18);
              vDSP_vclr(*v20, 1, v17);
              vDSP_vclr(v20[1], 1, v17);
              unint64_t v16 = a5[2];
              v18 += 16;
            }
            unint64_t v14 = a5[1];
          }
          ++v15;
        }
        while (v14 > v15);
      }
      vDSP_vfill(&__A, **(float ***)(*a5 + 8 * i), 1, v12);
      t3l::tDSP_zmsolvelu<float>(v23, v22, a5, v24);
      for (uint64_t k = 0; k != v11; ++k)
        vDSP_zvmov(*(const DSPSplitComplex **)(*a5 + 8 * k), 1, (const DSPSplitComplex *)(*(void *)(*a2 + 8 * k) + 16 * i), 1, v12);
    }
  }
}

void t3l::tDSP_ztmov<float>(void *a1, void *a2)
{
  uint64_t v2 = a1[1];
  if (v2 != a2[1]) {
    __assert_rtn("tDSP_ztmov", "Tensor3Lib.h", 355, "rows == lhs.rows");
  }
  uint64_t v5 = a1[2];
  if (v5 != a2[2]) {
    __assert_rtn("tDSP_ztmov", "Tensor3Lib.h", 356, "cols == lhs.cols");
  }
  vDSP_Length v6 = a1[3];
  if (v6 != a2[3]) {
    __assert_rtn("tDSP_ztmov", "Tensor3Lib.h", 357, "Nv == lhs.len");
  }
  if (v2)
  {
    for (uint64_t i = 0; i != v2; ++i)
    {
      if (v5)
      {
        uint64_t v8 = 0;
        uint64_t v9 = v5;
        do
        {
          vDSP_zvmov((const DSPSplitComplex *)(*(void *)(*a1 + 8 * i) + v8), 1, (const DSPSplitComplex *)(*(void *)(*a2 + 8 * i) + v8), 1, v6);
          v8 += 16;
          --v9;
        }
        while (v9);
      }
    }
  }
}

void AU::BSS2::UpdateWScale<float>(void *a1, unint64_t a2, uint64_t a3, void *a4, const DSPSplitComplex ***a5, const DSPSplitComplex ***a6)
{
  uint64_t v6 = a1[3];
  unint64_t v7 = a1[1];
  float __A = 1.0;
  int v29 = v6;
  vDSP_Length __N = (int)v6;
  if ((int)v6 != *(void *)(a3 + 24)) {
    __assert_rtn("UpdateWScale", "AUBSS2IVALib.h", 41, "Nf == Vj.len");
  }
  if ((int)v6 != a4[3]) {
    __assert_rtn("UpdateWScale", "AUBSS2IVALib.h", 42, "Nf == Wout.len");
  }
  if ((const DSPSplitComplex **)(int)v6 != a5[3]) {
    __assert_rtn("UpdateWScale", "AUBSS2IVALib.h", 43, "Nf == tempNx1xNf.len");
  }
  if ((const DSPSplitComplex **)(int)v6 != a6[3]) {
    __assert_rtn("UpdateWScale", "AUBSS2IVALib.h", 44, "Nf == temp1x1xNf.len");
  }
  if (v7 <= a2) {
    __assert_rtn("UpdateWScale", "AUBSS2IVALib.h", 46, "j < Nm");
  }
  if (*(void *)(a3 + 8) != v7) {
    __assert_rtn("UpdateWScale", "AUBSS2IVALib.h", 47, "Vj.rows == Nm");
  }
  if (*(void *)(a3 + 16) != v7) {
    __assert_rtn("UpdateWScale", "AUBSS2IVALib.h", 48, "Vj.cols == Nm");
  }
  if (a4[1] != v7) {
    __assert_rtn("UpdateWScale", "AUBSS2IVALib.h", 49, "Wout.rows == Nm");
  }
  if (a4[2] != v7) {
    __assert_rtn("UpdateWScale", "AUBSS2IVALib.h", 50, "Wout.cols == Nm");
  }
  if (a1[2] != v7) {
    __assert_rtn("UpdateWScale", "AUBSS2IVALib.h", 51, "Win.cols == Nm");
  }
  unint64_t v14 = 0;
  do
  {
    if (v14)
    {
      vDSP_zvconj((const DSPSplitComplex *)(**(void **)a3 + 16 * v14), 1, **a6, 1, __N);
      unint64_t v15 = *(const DSPSplitComplex **)(*a1 + 8 * a2);
      unint64_t v16 = **a6;
      vDSP_Length v17 = (*a5)[v14];
    }
    else
    {
      unint64_t v15 = *(const DSPSplitComplex **)(*a1 + 8 * a2);
      unint64_t v16 = **(const DSPSplitComplex ***)a3;
      vDSP_Length v17 = **a5;
    }
    vDSP_zvmul(v15, 1, v16, 1, v17, 1, __N, -1);
    if (v7 >= 2)
    {
      uint64_t v18 = 16;
      for (unint64_t i = 1; i != v7; ++i)
      {
        if (v14 <= i)
        {
          unint64_t v20 = (const DSPSplitComplex *)(*(void *)(*a1 + 8 * a2) + v18);
          uint64_t v21 = (const DSPSplitComplex *)(*(void *)(*(void *)a3 + 8 * v14) + v18);
        }
        else
        {
          vDSP_zvconj((const DSPSplitComplex *)(*(void *)(*(void *)a3 + 8 * i) + 16 * v14), 1, **a6, 1, __N);
          unint64_t v20 = (const DSPSplitComplex *)(*(void *)(*a1 + 8 * a2) + v18);
          uint64_t v21 = **a6;
        }
        vDSP_zvcma(v20, 1, v21, 1, (*a5)[v14], 1, (*a5)[v14], 1, __N);
        v18 += 16;
      }
    }
    ++v14;
  }
  while (v14 != v7);
  vDSP_zvmul(*(const DSPSplitComplex **)(*a1 + 8 * a2), 1, **a5, 1, **a6, 1, __N, 1);
  if (v7 >= 2)
  {
    uint64_t v22 = 1;
    uint64_t v23 = 16;
    do
    {
      vDSP_zvma((const DSPSplitComplex *)(*(void *)(*a1 + 8 * a2) + v23), 1, (*a5)[v22++], 1, **a6, 1, **a6, 1, __N);
      v23 += 16;
    }
    while (v7 != v22);
  }
  realp = (**a6)->realp;
  float v30 = 1.0e-16;
  vDSP_vabs(realp, 1, realp, 1, __N);
  vDSP_vsadd(realp, 1, &v30, realp, 1, __N);
  vvsqrtf((**a6)->realp, (**a6)->realp, &v29);
  vDSP_svdiv(&__A, (**a6)->realp, 1, (**a6)->realp, 1, v29);
  uint64_t v25 = 0;
  if (v7 <= 1) {
    uint64_t v26 = 1;
  }
  else {
    uint64_t v26 = v7;
  }
  do
  {
    vDSP_zrvmul((const DSPSplitComplex *)(*(void *)(*a1 + 8 * a2) + v25), 1, (**a6)->realp, 1, (const DSPSplitComplex *)(*(void *)(*a4 + 8 * a2) + v25), 1, v29);
    v25 += 16;
    --v26;
  }
  while (v26);
}

void AU::BSS2::UpdateWProject<float>(void *a1, uint64_t a2, uint64_t a3, void *a4, void *a5, uint64_t *a6, const DSPSplitComplex ***a7, float a8)
{
  float __B = a8;
  uint64_t v16 = a1[2];
  vDSP_Length v15 = a1[3];
  float __A = 1.0;
  t3l::tDSP_zmzmuppermult<float>(a1, a3, a5);
  if (a8 > 0.0) {
    t3l::tDSP_zmsreg<float>(a5, &__B);
  }
  uint64_t v26 = a5;
  float v27 = a4;
  float v28 = a7;
  t3l::tDSP_zmlu<float>(a5, a4, a6, a7);
  unint64_t v17 = a6[1];
  if (v17)
  {
    unint64_t v18 = 0;
    unint64_t v19 = a6[2];
    vDSP_Length v20 = a6[3];
    do
    {
      if (v19)
      {
        uint64_t v21 = 0;
        for (unint64_t i = 0; i < v19; ++i)
        {
          uint64_t v23 = (float **)(*(void *)(*a6 + 8 * v18) + v21);
          vDSP_vclr(*v23, 1, v20);
          vDSP_vclr(v23[1], 1, v20);
          unint64_t v19 = a6[2];
          v21 += 16;
        }
        unint64_t v17 = a6[1];
      }
      ++v18;
    }
    while (v17 > v18);
  }
  vDSP_vfill(&__A, **(float ***)(*a6 + 8 * a2), 1, v15);
  t3l::tDSP_zmsolvelu<float>(v26, v27, a6, v28);
  if (v16)
  {
    uint64_t v24 = 0;
    for (uint64_t j = 0; j != v16; ++j)
    {
      vDSP_zvconj(*(const DSPSplitComplex **)(*a6 + 8 * j), 1, (const DSPSplitComplex *)(*(void *)(*a1 + 8 * a2) + v24), 1, v15);
      v24 += 16;
    }
  }
}

void t3l::tDSP_zmzmuppermult<float>(void *a1, uint64_t a2, void *a3)
{
  unint64_t v3 = a1[2];
  if (v3 != *(void *)(a2 + 8) || a3[1] < v3) {
    __assert_rtn("tDSP_zmzmuppermult", "Tensor3Lib.h", 629, "A.cols == B.rows && C.rows >= A.cols");
  }
  vDSP_Length __N = a1[3];
  if (__N != *(void *)(a2 + 24) || __N != a3[3]) {
    __assert_rtn("tDSP_zmzmuppermult", "Tensor3Lib.h", 630, "A.len == B.len && (A.len == C.len)");
  }
  uint64_t v16 = a1[1];
  if (v16)
  {
    uint64_t v10 = 0;
    uint64_t v11 = *(void *)(a2 + 16);
    do
    {
      if (v11)
      {
        for (unint64_t i = 0; i != v11; ++i)
        {
          vDSP_zvmul(*(const DSPSplitComplex **)(*a1 + 8 * v10), 1, (const DSPSplitComplex *)(**(void **)a2 + 16 * i), 1, (const DSPSplitComplex *)(*(void *)(*a3 + 8 * v10) + 16 * i), 1, __N, 1);
          if (v3 >= 2)
          {
            uint64_t v13 = 16;
            for (unint64_t j = 1; j != v3; ++j)
            {
              vDSP_Length v15 = (const DSPSplitComplex *)(*(void *)(*a3 + 8 * v10) + 16 * i);
              if (j <= i) {
                vDSP_zvma((const DSPSplitComplex *)(*(void *)(*a1 + 8 * v10) + v13), 1, (const DSPSplitComplex *)(*(void *)(*(void *)a2 + 8 * j) + 16 * i), 1, v15, 1, v15, 1, __N);
              }
              else {
                vDSP_zvcma((const DSPSplitComplex *)(*(void *)(*(void *)a2 + 8 * i) + v13), 1, (const DSPSplitComplex *)(*(void *)(*a1 + 8 * v10) + v13), 1, v15, 1, v15, 1, __N);
              }
              v13 += 16;
            }
          }
        }
      }
      ++v10;
    }
    while (v10 != v16);
  }
}

void t3l::tDSP_zmlu<float>(uint64_t *a1, void *a2, void *a3, const DSPSplitComplex ***a4)
{
  uint64_t v4 = a1[2];
  vDSP_Length __N = a1[3];
  unint64_t v6 = a1[1];
  float __A = 1.0;
  float __B = 2.2204e-16;
  if (v4 != v6) {
    __assert_rtn("tDSP_zmlu", "Tensor3Lib.h", 923, "lu.cols == n");
  }
  unint64_t v7 = a3;
  if (a3[1] < v6) {
    __assert_rtn("tDSP_zmlu", "Tensor3Lib.h", 924, "tempNx1xNf.rows >= n");
  }
  if (!a4[1]) {
    __assert_rtn("tDSP_zmlu", "Tensor3Lib.h", 925, "temp1x1xNf.rows >= 1");
  }
  if (__N > a2[3] || __N > a3[3] || __N > (unint64_t)a4[3]) {
    __assert_rtn("tDSP_zmlu", "Tensor3Lib.h", 928, "Nv <= pivotNx1xNf.len && Nv <= tempNx1xNf.len && Nv <= temp1x1xNf.len");
  }
  if (v6 <= 1) {
    __assert_rtn("tDSP_zmlu", "Tensor3Lib.h", 929, "n > 1");
  }
  uint64_t v12 = 0;
  uint64_t v13 = *(float **)(*(void *)*a3 + 8);
  unint64_t v14 = **a4;
  realp = v14->realp;
  float __C = v14->imagp;
  do
  {
    vDSP_vclr(**(float ***)(*v7 + 8 * v12), 1, __N);
    uint64_t v16 = 0;
    unint64_t v17 = v6;
    do
    {
      vDSP_zvabs((const DSPSplitComplex *)(*(void *)(*a1 + 8 * v12) + v16), 1, *(float **)(*(void *)*v7 + 8), 1, __N);
      unint64_t v18 = **(float ***)(*v7 + 8 * v12);
      vDSP_vmax(v18, 1, *(const float **)(*(void *)*v7 + 8), 1, v18, 1, __N);
      v16 += 16;
      --v17;
    }
    while (v17);
    unint64_t v19 = **(float ***)(*v7 + 8 * v12);
    vDSP_vsadd(v19, 1, &__B, v19, 1, __N);
    vDSP_Length v20 = **(float ***)(*v7 + 8 * v12);
    vDSP_svdiv(&__A, v20, 1, v20, 1, __N);
    ++v12;
  }
  while (v12 != v6);
  uint64_t v21 = 0;
  uint64_t v48 = v7;
  uint64_t v22 = 1;
  unint64_t v51 = v6;
  uint64_t v52 = 16;
  do
  {
    vDSP_vclr(realp, 1, __N);
    float v54 = (float)(int)v21;
    vDSP_vfill(&v54, __C, 1, __N);
    uint64_t v23 = v21;
    do
    {
      while (1)
      {
        vDSP_zvabs((const DSPSplitComplex *)(*(void *)(*a1 + 8 * v23) + 16 * v21), 1, v13, 1, __N);
        vDSP_vmul(v13, 1, **(const float ***)(*v7 + 8 * v23), 1, v13, 1, __N);
        if (__N) {
          break;
        }
        ++v23;
        uint64_t v25 = __C;
        if (v23 == v6) {
          goto LABEL_32;
        }
      }
      uint64_t v24 = 0;
      uint64_t v25 = __C;
      do
      {
        float v26 = v13[v24];
        if (v26 > realp[v24])
        {
          realp[v24] = v26;
          __C[v24] = (float)(int)v23;
        }
        ++v24;
      }
      while (__N != v24);
      ++v23;
    }
    while (v23 != v6);
    uint64_t v27 = 0;
    uint64_t v28 = *a1;
    uint64_t v29 = *v7;
    do
    {
      unint64_t v30 = (unint64_t)__C[v27];
      if (v21 != v30)
      {
        uint64_t v31 = (uint64_t *)(*(void *)(v28 + 8 * v21) + 8);
        uint64_t v32 = (uint64_t *)(*(void *)(v28 + 8 * v30) + 8);
        unint64_t v33 = v6;
        do
        {
          uint64_t v34 = *(v32 - 1);
          uint64_t v35 = *(v31 - 1);
          int v36 = *(_DWORD *)(v34 + 4 * v27);
          *(_DWORD *)(v34 + 4 * v27) = *(_DWORD *)(v35 + 4 * v27);
          *(_DWORD *)(v35 + 4 * v27) = v36;
          uint64_t v38 = *v32;
          v32 += 2;
          uint64_t v37 = v38;
          uint64_t v39 = *v31;
          v31 += 2;
          int v40 = *(_DWORD *)(v37 + 4 * v27);
          *(_DWORD *)(v37 + 4 * v27) = *(_DWORD *)(v39 + 4 * v27);
          *(_DWORD *)(v39 + 4 * v27) = v40;
          --v33;
        }
        while (v33);
        *(_DWORD *)(**(void **)(v29 + 8 * v30) + 4 * v27) = *(_DWORD *)(**(void **)(v29 + 8 * v21) + 4 * v27);
      }
      ++v27;
    }
    while (v27 != __N);
LABEL_32:
    memcpy(**(void ***)(*a2 + 8 * v21), v25, 4 * __N);
    vDSP_zvabs((const DSPSplitComplex *)(*(void *)(*a1 + 8 * v21) + 16 * v21), 1, v13, 1, __N);
    if (__N)
    {
      uint64_t v41 = *(float **)(*(void *)(*a1 + 8 * v21) + 16 * v21);
      uint64_t v42 = v13;
      vDSP_Length v43 = __N;
      do
      {
        if (*v42 <= 0.0) {
          *uint64_t v41 = __B;
        }
        ++v41;
        ++v42;
        --v43;
      }
      while (v43);
    }
    uint64_t v44 = v22;
    uint64_t v50 = v21 + 1;
    if (v6 > v21 + 1)
    {
      do
      {
        unint64_t v45 = (const DSPSplitComplex *)(*(void *)(*a1 + 8 * v44) + 16 * v21);
        vDSP_zvdiv((const DSPSplitComplex *)(*(void *)(*a1 + 8 * v21) + 16 * v21), 1, v45, 1, v45, 1, __N);
        vDSP_zvneg((const DSPSplitComplex *)(*(void *)(*a1 + 8 * v44) + 16 * v21), 1, **a4, 1, __N);
        uint64_t v46 = v52;
        do
        {
          unint64_t v47 = (const DSPSplitComplex *)(*(void *)(*a1 + 8 * v44) + v46);
          vDSP_zvma(**a4, 1, (const DSPSplitComplex *)(*(void *)(*a1 + 8 * v21) + v46), 1, v47, 1, v47, 1, __N);
          --v6;
          v46 += 16;
        }
        while (v22 != v6);
        ++v44;
        unint64_t v6 = v51;
      }
      while (v44 != v51);
    }
    ++v22;
    v52 += 16;
    ++v21;
    unint64_t v7 = v48;
  }
  while (v50 != v6);
}

void t3l::tDSP_zmsolvelu<float>(void *a1, void *a2, uint64_t *a3, const DSPSplitComplex ***a4)
{
  unint64_t v4 = a1[1];
  if (v4 < a1[2]) {
    __assert_rtn("tDSP_zmsolvelu", "Tensor3Lib.h", 1041, "n >= lu.cols");
  }
  if (a3[1] < v4) {
    __assert_rtn("tDSP_zmsolvelu", "Tensor3Lib.h", 1042, "b.rows >= n");
  }
  if (!a4[1]) {
    __assert_rtn("tDSP_zmsolvelu", "Tensor3Lib.h", 1043, "temp1x1xNf.rows >= 1");
  }
  vDSP_Length __N = a1[3];
  BOOL v9 = __N > a2[3] || __N > a3[3];
  if (v9 || __N > (unint64_t)a4[3]) {
    __assert_rtn("tDSP_zmsolvelu", "Tensor3Lib.h", 1048, "Nv <= pivotNx1xNf.len && Nv <= b.len && Nv <= x.len && Nv <= temp1x1xNf.len");
  }
  if (v4)
  {
    unint64_t v11 = 0;
    unint64_t v12 = 0;
    uint64_t v13 = **a4;
    realp = v13->realp;
    imagp = v13->imagp;
    do
    {
      if (__N)
      {
        uint64_t v16 = 0;
        uint64_t v17 = **(void **)(*a2 + 8 * v11);
        uint64_t v18 = *a3;
        unint64_t v19 = *(uint64_t **)(*a3 + 8 * v11);
        uint64_t v20 = *v19;
        uint64_t v21 = v19[1];
        do
        {
          uint64_t v22 = *(uint64_t **)(v18 + 8 * (unint64_t)*(float *)(v17 + 4 * v16));
          uint64_t v24 = *v22;
          uint64_t v23 = v22[1];
          realp[v16] = *(float *)(v24 + 4 * v16);
          imagp[v16] = *(float *)(v23 + 4 * v16);
          *(_DWORD *)(v24 + 4 * v16) = *(_DWORD *)(v20 + 4 * v16);
          *(_DWORD *)(v23 + 4 * v16) = *(_DWORD *)(v21 + 4 * v16);
          ++v16;
        }
        while (__N != v16);
      }
      if (v12)
      {
        vDSP_zvneg(**a4, 1, **a4, 1, __N);
        unint64_t v33 = v12;
        unint64_t v25 = (unint64_t)((double)v12 + -1.0);
        if (v11 > v25)
        {
          uint64_t v26 = 16 * v25;
          do
          {
            vDSP_zvma((const DSPSplitComplex *)(*(void *)(*a1 + 8 * v11) + v26), 1, *(const DSPSplitComplex **)(*a3 + 8 * v25++), 1, **a4, 1, **a4, 1, __N);
            v26 += 16;
          }
          while (v11 != v25);
        }
        vDSP_zvneg(**a4, 1, **a4, 1, __N);
        unint64_t v27 = v11 + 1;
        unint64_t v12 = v33;
      }
      else
      {
        unint64_t v27 = v11 + 1;
        unint64_t v12 = v11 + 1;
      }
      vDSP_zvmov(**a4, 1, *(const DSPSplitComplex **)(*a3 + 8 * v11), 1, __N);
      unint64_t v11 = v27;
    }
    while (v27 != v4);
  }
  uint64_t v28 = (int)((double)v4 + -1.0);
  if ((v28 & 0x80000000) == 0)
  {
    uint64_t v29 = 16 * (int)((double)v4 + -1.0) + 16;
    do
    {
      vDSP_zvneg(*(const DSPSplitComplex **)(*a3 + 8 * v28), 1, **a4, 1, __N);
      unint64_t v30 = v28 + 1;
      for (uint64_t i = v29; v30 < v4; i += 16)
        vDSP_zvma((const DSPSplitComplex *)(*(void *)(*a1 + 8 * v28) + i), 1, *(const DSPSplitComplex **)(*a3 + 8 * v30++), 1, **a4, 1, **a4, 1, __N);
      vDSP_zvneg(**a4, 1, **a4, 1, __N);
      vDSP_zvdiv((const DSPSplitComplex *)(*(void *)(*a1 + 8 * v28) + 16 * v28), 1, **a4, 1, *(const DSPSplitComplex **)(*a3 + 8 * v28), 1, __N);
      v29 -= 16;
      BOOL v9 = v28-- <= 0;
    }
    while (!v9);
  }
}

void AU::BSS2::vDSP_zmekzvhmultT<float>(void *a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v4 = a1[1];
  if (v4)
  {
    uint64_t v9 = 0;
    vDSP_Length v10 = a1[3];
    do
    {
      uint64_t v11 = 0;
      for (uint64_t i = 0; i != v4; ++i)
      {
        vDSP_zvmul(*(const DSPSplitComplex **)(*a3 + 8 * i), 1, (const DSPSplitComplex *)(*(void *)(*a1 + 8 * v9) + 16 * a2), 1, (const DSPSplitComplex *)(*(void *)(*a4 + 8 * v9) + v11), 1, v10, 1);
        v11 += 16;
      }
      ++v9;
    }
    while (v9 != v4);
  }
}

uint64_t AU::BSS2::AUXIVARLS<float>::Initialize(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, float a5)
{
  if (a5 >= 0.0)
  {
    *(void *)(a1 + 40) = a2;
    *(void *)(a1 + 160) = 0;
    *(void *)(a1 + 16) = a4;
    float v9 = a5 / (float)a2;
    *(float *)(a1 + 32) = a5;
    *(float *)(a1 + 36) = v9;
    float v10 = *(float *)(a1 + 68);
    float v11 = 0.0;
    if (v10 > 0.0)
    {
      if (v9 <= 0.0) {
        __assert_rtn("ComputeCoefFromTC", "Tensor3Lib.h", 30, "blockFs > 0");
      }
      float v11 = expf(-1.0 / (float)(v9 * v10));
    }
    *(float *)(a1 + 72) = v11;
    *(float *)(a1 + 36) = v9;
    *(void *)(a1 + 24) = a3;
    LODWORD(v12) = 0;
    std::vector<float>::resize(a1 + 192, a4, &v12);
    t3l::tDSP_create_vec_tensors<float>(&v12, *(void *)(a1 + 16), *(void *)(a1 + 16), *(void *)(a1 + 16), *(void *)(a1 + 24), *(float *)(a1 + 88));
    std::vector<std::unique_ptr<t3l::ZTensor3<float>>>::__vdeallocate((uint64_t **)(a1 + 232));
    *(_OWORD *)(a1 + 232) = v12;
    *(void *)(a1 + 248) = v13;
    uint64_t v13 = 0;
    long long v12 = 0uLL;
    unint64_t v14 = (void **)&v12;
    std::vector<std::unique_ptr<t3l::ZTensor3<float>>>::__destroy_vector::operator()[abi:ne180100](&v14);
    t3l::tDSP_create_vec_tensors<float>(&v12, *(void *)(a1 + 16), *(void *)(a1 + 16), *(void *)(a1 + 16), *(void *)(a1 + 24), 1.0 / *(float *)(a1 + 88));
    std::vector<std::unique_ptr<t3l::ZTensor3<float>>>::__vdeallocate((uint64_t **)(a1 + 256));
    *(_OWORD *)(a1 + 256) = v12;
    *(void *)(a1 + 272) = v13;
    uint64_t v13 = 0;
    long long v12 = 0uLL;
    unint64_t v14 = (void **)&v12;
    std::vector<std::unique_ptr<t3l::ZTensor3<float>>>::__destroy_vector::operator()[abi:ne180100](&v14);
    operator new();
  }
  return 1;
}

void sub_1BB37AA08(_Unwind_Exception *a1)
{
  MEMORY[0x1C185D370](v1, 0x10A0C40CB468F57);
  _Unwind_Resume(a1);
}

void t3l::tDSP_create_vec_tensors<float>(void *a1, unint64_t a2, unint64_t a3, unint64_t a4, vDSP_Length a5, float a6)
{
  __A[0] = a6;
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  if (a2)
  {
    if (a2 >> 61) {
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v9 = 8 * a2;
    float v10 = (char *)operator new(8 * a2);
    bzero(v10, 8 * a2);
    *a1 = v10;
    a1[1] = &v10[v9];
    a1[2] = &v10[8 * a2];
    if (v9) {
      operator new();
    }
    uint64_t v11 = 0;
    if (a4 >= a3) {
      unint64_t v12 = a3;
    }
    else {
      unint64_t v12 = a4;
    }
    do
    {
      if (v12)
      {
        uint64_t v13 = 0;
        for (uint64_t i = 0; i != v12; ++i)
        {
          vDSP_vfill(__A, *(float **)(*(void *)(**(void **)&v10[8 * v11] + 8 * i) + v13), 1, a5);
          v13 += 16;
        }
      }
      ++v11;
    }
    while (v11 != a2);
  }
}

void sub_1BB37AC2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  std::vector<std::unique_ptr<t3l::ZTensor3<float>>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

void std::vector<std::unique_ptr<t3l::ZTensor3<float>>>::__vdeallocate(uint64_t **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    unint64_t v3 = a1[1];
    uint64_t v4 = *a1;
    if (v3 != v1)
    {
      do
        std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100](--v3, 0);
      while (v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t t3l::ZTensor3<float>::ZTensor3(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = a2;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  unint64_t v7 = (uint64_t *)(a1 + 80);
  *(void *)(a1 + 16) = a3;
  *(void *)(a1 + 24) = a4;
  uint64_t v8 = (uint64_t *)(a1 + 104);
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  if (a2)
  {
    if (a2 >> 61) {
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v9 = a2;
    float v10 = operator new(8 * a2);
    bzero(v10, 8 * a2);
    *(void *)(a1 + 32) = v10;
    *(void *)(a1 + 40) = &v10[v9];
    *(void *)(a1 + 48) = &v10[a2];
  }
  else
  {
    float v10 = 0;
  }
  unint64_t v11 = a2 * a3;
  if (a2 * a3)
  {
    if (v11 >> 60) {
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v12 = (char *)operator new(16 * v11);
    uint64_t v13 = 0;
    unint64_t v14 = &v12[16 * v11];
    do
    {
      vDSP_Length v15 = &v12[v13];
      *(void *)vDSP_Length v15 = 0;
      *((void *)v15 + 1) = 0;
      v13 += 16;
    }
    while (16 * a3 * a2 != v13);
    *(void *)(a1 + 56) = v12;
    *(void *)(a1 + 64) = v14;
    *(void *)(a1 + 72) = v14;
  }
  else
  {
    unint64_t v12 = 0;
  }
  *(void *)a1 = v10;
  *float v10 = v12;
  if (a2)
  {
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    do
    {
      *(void *)(*(void *)a1 + 8 * v17++) = **(void **)a1 + v16;
      v16 += 16 * a3;
    }
    while (a2 != v17);
  }
  std::vector<std::vector<float>>::resize(v7, a2 * a3);
  std::vector<std::vector<float>>::resize(v8, *(void *)(a1 + 16) * *(void *)(a1 + 8));
  uint64_t v18 = *(void *)(a1 + 80);
  if (*(void *)(a1 + 88) != v18)
  {
    uint64_t v19 = 0;
    unint64_t v20 = 0;
    do
    {
      std::vector<float>::resize(v18 + v19, *(void *)(a1 + 24));
      std::vector<float>::resize(*(void *)(a1 + 104) + v19, *(void *)(a1 + 24));
      ++v20;
      uint64_t v18 = *(void *)(a1 + 80);
      v19 += 24;
    }
    while (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 88) - v18) >> 3) > v20);
  }
  uint64_t v21 = *(void *)(a1 + 8);
  if (v21)
  {
    uint64_t v22 = 0;
    uint64_t v23 = 0;
    uint64_t v24 = *(void *)(a1 + 16);
    do
    {
      if (v24)
      {
        uint64_t v25 = 0;
        uint64_t v26 = v22;
        uint64_t v27 = v24;
        do
        {
          uint64_t v28 = *(void *)(*(void *)(a1 + 104) + v26);
          uint64_t v29 = (void *)(*(void *)(*(void *)a1 + 8 * v23) + v25);
          *uint64_t v29 = *(void *)(*(void *)(a1 + 80) + v26);
          v29[1] = v28;
          v25 += 16;
          v26 += 24;
          --v27;
        }
        while (v27);
      }
      ++v23;
      v22 += 24 * v24;
    }
    while (v23 != v21);
  }
  return a1;
}

void sub_1BB37AF10(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  uint64_t v5 = (void *)v2[7];
  if (v5)
  {
    v2[8] = v5;
    operator delete(v5);
  }
  unint64_t v6 = *v3;
  if (*v3)
  {
    v2[5] = v6;
    operator delete(v6);
  }
  _Unwind_Resume(a1);
}

uint64_t t3l::RTensor3<float>::RTensor3(uint64_t a1, unint64_t a2, uint64_t a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = 1;
  *(void *)(a1 + 24) = a3;
  *(_OWORD *)(a1 + 32) = 0u;
  uint64_t v5 = a1 + 56;
  *(_OWORD *)(a1 + 80) = 0u;
  unint64_t v6 = (uint64_t *)(a1 + 80);
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(void *)(a1 + 96) = 0;
  if (a2)
  {
    if (a2 >> 61) {
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v7 = 8 * a2;
    uint64_t v8 = (char *)operator new(8 * a2);
    bzero(v8, 8 * a2);
    *(void *)(a1 + 32) = v8;
    *(void *)(a1 + 40) = &v8[v7];
    *(void *)(a1 + 48) = &v8[8 * a2];
  }
  std::vector<void const*>::resize(v5, a2);
  uint64_t v9 = *(void **)(a1 + 32);
  *(void *)a1 = v9;
  void *v9 = *(void *)(a1 + 56);
  uint64_t v10 = *(void *)(a1 + 8);
  uint64_t v11 = *(void *)(a1 + 16);
  if (v10)
  {
    uint64_t v12 = 0;
    for (uint64_t i = 0; i != v10; ++i)
    {
      *(void *)(*(void *)a1 + 8 * i) = **(void **)a1 + v12;
      v12 += 8 * v11;
    }
  }
  std::vector<std::vector<float>>::resize(v6, v11 * v10);
  uint64_t v14 = *(void *)(a1 + 80);
  if (*(void *)(a1 + 88) != v14)
  {
    uint64_t v15 = 0;
    unint64_t v16 = 0;
    do
    {
      std::vector<float>::resize(v14 + v15, *(void *)(a1 + 24));
      ++v16;
      uint64_t v14 = *(void *)(a1 + 80);
      v15 += 24;
    }
    while (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 88) - v14) >> 3) > v16);
  }
  uint64_t v17 = *(void *)(a1 + 8);
  if (v17)
  {
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v20 = *(void *)(a1 + 16);
    do
    {
      if (v20)
      {
        uint64_t v21 = 0;
        uint64_t v22 = v18;
        do
        {
          *(void *)(*(void *)(*(void *)a1 + 8 * v19) + 8 * v21++) = *(void *)(*(void *)(a1 + 80) + v22);
          v22 += 24;
        }
        while (v20 != v21);
      }
      ++v19;
      v18 += 24 * v20;
    }
    while (v19 != v17);
  }
  return a1;
}

void sub_1BB37B10C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  unint64_t v6 = *v3;
  if (*v3)
  {
    *(void *)(v2 + 64) = v6;
    operator delete(v6);
  }
  uint64_t v7 = *v4;
  if (*v4)
  {
    *(void *)(v2 + 40) = v7;
    operator delete(v7);
  }
  _Unwind_Resume(a1);
}

void AU::BSS2::AUXIVACramer23<float>::~AUXIVACramer23(uint64_t a1)
{
  AU::BSS2::AUXIVACramer23<float>::~AUXIVACramer23(a1);

  JUMPOUT(0x1C185D370);
}

uint64_t AU::BSS2::AUXIVACramer23<float>::~AUXIVACramer23(uint64_t a1)
{
  *(void *)a1 = &unk_1F14AC260;
  std::unique_ptr<t3l::RTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 296), 0);
  std::unique_ptr<t3l::RTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 288), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 280), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 272), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 264), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 256), 0);
  uint64_t v5 = (void **)(a1 + 232);
  std::vector<std::unique_ptr<t3l::ZTensor3<float>>>::__destroy_vector::operator()[abi:ne180100](&v5);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 224), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 216), 0);
  uint64_t v2 = *(void **)(a1 + 192);
  if (v2)
  {
    *(void *)(a1 + 200) = v2;
    operator delete(v2);
  }
  unint64_t v3 = *(void **)(a1 + 168);
  if (v3)
  {
    *(void *)(a1 + 176) = v3;
    operator delete(v3);
  }
  return a1;
}

uint64_t AU::BSS2::AUXIVACramer23<float>::Reset(uint64_t a1)
{
  if (*(void *)(a1 + 16))
  {
    unint64_t v2 = 0;
    do
    {
      t3l::tDSP_ztfilldiag<float>(*(void **)(*(void *)(a1 + 232) + 8 * v2), *(float *)(a1 + 88));
      *(_DWORD *)(*(void *)(a1 + 168) + 4 * v2++) = 1065353216;
    }
    while (*(void *)(a1 + 16) > v2);
  }
  unint64_t v3 = *(void **)(a1 + 216);
  unint64_t v4 = v3[1];
  if (v4 != v3[2]) {
    __assert_rtn("tDSP_zmeye", "Tensor3Lib.h", 513, "N == X.cols");
  }
  vDSP_Length v5 = v3[3];
  float __A = 1.0;
  if (v4)
  {
    unint64_t v6 = 0;
    unint64_t v7 = 1;
    unint64_t v8 = v4;
    do
    {
      if (v7)
      {
        uint64_t v9 = 0;
        for (unint64_t i = 0; i < v7; ++i)
        {
          uint64_t v11 = (float **)(*(void *)(*v3 + 8 * v6) + v9);
          vDSP_vclr(*v11, 1, v5);
          vDSP_vclr(v11[1], 1, v5);
          unint64_t v7 = v3[2];
          v9 += 16;
        }
        unint64_t v8 = v3[1];
      }
      ++v6;
    }
    while (v8 > v6);
    uint64_t v12 = 0;
    for (uint64_t j = 0; j != v4; ++j)
    {
      vDSP_vfill(&__A, *(float **)(*(void *)(*v3 + 8 * j) + v12), 1, v5);
      v12 += 16;
    }
  }
  *(void *)(a1 + 160) = 1;
  *(void *)(a1 + 104) = 0;
  return 0;
}

uint64_t AU::BSS2::AUXIVACramer23<float>::UpdatePrior(uint64_t a1, unint64_t a2, float a3, float a4)
{
  uint64_t v4 = *(void *)(a1 + 168);
  if (a2 > (*(void *)(a1 + 176) - v4) >> 2) {
    __assert_rtn("UpdatePrior", "AUBSS2Algorithm+XIVACramer23.h", 343, "index <= priors.size()");
  }
  if (a3 < 0.0) {
    a3 = 0.0;
  }
  float v5 = a3 + -0.5;
  BOOL v6 = a3 <= 1.0;
  float v7 = 0.5;
  if (v6) {
    float v7 = v5;
  }
  *(float *)(v4 + 4 * a2) = expf(v7 * a4);
  return 0;
}

uint64_t AU::BSS2::AUXIVACramer23<float>::UpdateParam(uint64_t a1, int a2, float a3)
{
  if (!*(unsigned char *)(a1 + 8)) {
    return 1;
  }
  switch(a2)
  {
    case 0:
      uint64_t result = 0;
      *(unsigned char *)(a1 + 120) = a3 != 0.0;
      break;
    case 1:
      *(float *)(a1 + 68) = a3;
      float v5 = 0.0;
      if (a3 > 0.0)
      {
        float v6 = *(float *)(a1 + 36);
        if (v6 <= 0.0) {
          __assert_rtn("ComputeCoefFromTC", "Tensor3Lib.h", 30, "blockFs > 0");
        }
        float v5 = expf(-1.0 / (float)(v6 * a3));
      }
      uint64_t result = 0;
      *(float *)(a1 + 72) = v5;
      break;
    case 2:
      uint64_t result = 0;
      *(unsigned char *)(a1 + 136) = a3 != 0.0;
      break;
    case 3:
      float v7 = __exp10f(a3 / 20.0);
      uint64_t result = 0;
      *(float *)(a1 + 52) = v7;
      break;
    case 4:
      float v8 = __exp10f(a3 / 20.0);
      uint64_t result = 0;
      *(float *)(a1 + 56) = v8;
      break;
    case 5:
      float v9 = __exp10f(a3 / 20.0);
      uint64_t result = 0;
      *(float *)(a1 + 60) = v9;
      break;
    case 6:
      float v10 = __exp10f(a3 / 20.0);
      uint64_t result = 0;
      *(float *)(a1 + 64) = v10;
      break;
    case 7:
      uint64_t result = 0;
      *(void *)(a1 + 112) = (unint64_t)a3;
      break;
    case 8:
      uint64_t result = 0;
      *(float *)(a1 + 48) = a3;
      break;
    case 9:
      float v11 = __exp10f(a3 / 20.0);
      uint64_t result = 0;
      *(float *)(a1 + 124) = v11;
      break;
    case 10:
      uint64_t result = 0;
      *(void *)(a1 + 96) = (unint64_t)a3;
      break;
    case 11:
      float v12 = __exp10f(a3 / 20.0);
      uint64_t result = 0;
      *(float *)(a1 + 132) = v12;
      break;
    case 12:
      uint64_t result = 0;
      *(void *)(a1 + 80) = vcvtas_u32_f32((float)(*(float *)(a1 + 32) * a3) / (float)*(unint64_t *)(a1 + 40));
      break;
    case 13:
      float v13 = __exp10f(a3 / 20.0);
      uint64_t result = 0;
      *(float *)(a1 + 88) = v13;
      break;
    case 14:
      uint64_t result = 0;
      unint64_t v14 = *(void *)(a1 + 24) - 1;
      float v15 = *(float *)(a1 + 32) / ((double)*(unint64_t *)(a1 + 40) + (double)*(unint64_t *)(a1 + 40));
      unint64_t v16 = vcvtas_u32_f32(fabsf(a3 / v15));
      if (v16 < v14) {
        unint64_t v14 = v16;
      }
      *(void *)(a1 + 144) = v14;
      break;
    case 15:
      uint64_t result = 0;
      unint64_t v17 = *(void *)(a1 + 24) - 1;
      float v18 = *(float *)(a1 + 32) / ((double)*(unint64_t *)(a1 + 40) + (double)*(unint64_t *)(a1 + 40));
      unint64_t v19 = vcvtas_u32_f32(fabsf(a3 / v18));
      if (v19 < v17) {
        unint64_t v17 = v19;
      }
      *(void *)(a1 + 152) = v17;
      break;
    default:
      return 1;
  }
  return result;
}

uint64_t AU::BSS2::AUXIVACramer23<float>::SideChain(uint64_t a1, uint64_t a2, uint64_t a3)
{
  t3l::tDSP_copy_freq_abl_to_ztensor<float>(a2, **(void **)(a1 + 256), *(void *)(*(void *)(a1 + 256) + 8), *(void *)(a1 + 40), *(void *)(a1 + 16));
  AU::BSS2::GenerateOutput<float>(*(void **)(a1 + 216), *(void **)(a1 + 224), *(void *)(a1 + 256), *(void **)(a1 + 264), *(void *)(a1 + 112));
  if (*(unsigned char *)(a1 + 137) || *(unsigned char *)(a1 + 136))
  {
    if (*(void *)(a1 + 16))
    {
      unint64_t v5 = 0;
      do
      {
        float v6 = *(const DSPSplitComplex **)(**(void **)(a1 + 256) + 8 * v5);
        float v7 = **(float ***)(**(void **)(a1 + 296) + 8 * v5);
        vDSP_Length v8 = *(void *)(a1 + 24);
        float __B = 2.2204e-16;
        vDSP_zvmags(v6, 1, v7, 1, v8);
        vDSP_vsadd(v7, 1, &__B, v7, 1, v8);
        ++v5;
        unint64_t v9 = *(void *)(a1 + 16);
      }
      while (v9 > v5);
      if (v9)
      {
        unint64_t v10 = 0;
        do
        {
          float v11 = *(const DSPSplitComplex **)(**(void **)(a1 + 264) + 8 * v10);
          float v12 = **(float ***)(**(void **)(a1 + 288) + 8 * v10);
          vDSP_Length v13 = *(void *)(a1 + 24);
          float v16 = 2.2204e-16;
          vDSP_zvmags(v11, 1, v12, 1, v13);
          vDSP_vsadd(v12, 1, &v16, v12, 1, v13);
          ++v10;
        }
        while (*(void *)(a1 + 16) > v10);
      }
    }
  }
  if (*(unsigned char *)(a1 + 137)) {
    AU::BSS2::FixWNG<float>(*(void **)(a1 + 264), *(void **)(a1 + 296), *(void **)(a1 + 288), *(void *)(a1 + 272), *(void *)(a1 + 112), *(float *)(a1 + 124));
  }
  if (*(unsigned char *)(a1 + 136)) {
    AU::BSS2::MixturePhase<float>(*(void **)(a1 + 256), *(void **)(a1 + 296), *(void **)(a1 + 264), *(void **)(a1 + 288), **(float *****)(a1 + 272), *(void *)(*(void *)(a1 + 272) + 24));
  }
  t3l::tDSP_copy_ztensor_to_freq_abl<float>(**(void **)(a1 + 264), a3, *(void *)(a1 + 40), *(void *)(a1 + 16));
  return 0;
}

uint64_t AU::BSS2::AUXIVACramer23<float>::Process(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!*(unsigned char *)(a1 + 8)) {
    return 1;
  }
  ++*(void *)(a1 + 160);
  t3l::tDSP_copy_freq_abl_to_ztensor<float>(a2, **(void **)(a1 + 256), *(void *)(*(void *)(a1 + 256) + 8), *(void *)(a1 + 40), *(void *)(a1 + 16));
  if (*(void *)(a1 + 16))
  {
    unint64_t v5 = 0;
    do
    {
      float v6 = *(const DSPSplitComplex **)(**(void **)(a1 + 256) + 8 * v5);
      float v7 = **(float ***)(**(void **)(a1 + 296) + 8 * v5);
      vDSP_Length v8 = *(void *)(a1 + 24);
      float __B = 2.2204e-16;
      vDSP_zvmags(v6, 1, v7, 1, v8);
      vDSP_vsadd(v7, 1, &__B, v7, 1, v8);
      ++v5;
    }
    while (*(void *)(a1 + 16) > v5);
  }
  if (*(unsigned char *)(a1 + 120) && AU::BSS2::AboveMinEnergyThreshold<float>(*(void **)(a1 + 296), *(float *)(a1 + 132)))
  {
    uint64_t v9 = *(void *)(a1 + 16);
    unint64_t v10 = *(void **)(a1 + 256);
    if (v9)
    {
      float v11 = (void **)*v10;
      do
      {
        float v12 = *v11++;
        vDSP_Length v13 = (_DWORD *)v12[1];
        *(_DWORD *)void *v12 = *(_DWORD *)(*v12 + 4);
        *vDSP_Length v13 = v13[1];
        --v9;
      }
      while (v9);
    }
    t3l::tDSP_zmzvmult<float>(*(void **)(a1 + 216), (uint64_t)v10, *(void **)(a1 + 264));
    if (*(void *)(a1 + 16))
    {
      uint64_t v14 = 0;
      unint64_t v15 = 0;
      do
      {
        float v16 = *(const DSPSplitComplex **)(**(void **)(a1 + 264) + 8 * v15);
        vDSP_zvmags(v16, 1, v16->realp, 1, *(void *)(a1 + 24));
        vDSP_sve((const float *)(**(void **)(**(void **)(a1 + 264) + 8 * v15) + 4 * *(void *)(a1 + 144)), 1, (float *)(*(void *)(a1 + 192) + v14), *(void *)(a1 + 152) - *(void *)(a1 + 144));
        uint64_t v17 = *(void *)(a1 + 192);
        double v18 = (float)(*(float *)(a1 + 48) * 0.5);
        long double v19 = log2((float)(*(float *)(v17 + 4 * v15) + *(float *)(a1 + 52)));
        float v20 = exp2(v19 * v18);
        *(float *)(v17 + 4 * v15) = v20;
        *(float *)(v17 + 4 * v15) = *(float *)(*(void *)(a1 + 168) + 4 * v15) * v20;
        ++v15;
        v14 += 4;
      }
      while (*(void *)(a1 + 16) > v15);
    }
    t3l::tDSP_ztvztvhmultupper<float>(*(void **)(a1 + 256), *(void **)(a1 + 256), *(void **)(a1 + 272));
    if (*(float *)(a1 + 56) > 0.0) {
      t3l::tDSP_zmsreg<float>(*(void **)(a1 + 272), (const float *)(a1 + 56));
    }
    unint64_t v21 = *(void *)(a1 + 16);
    if (v21)
    {
      for (unint64_t i = 0; i < v21; ++i)
      {
        AU::BSS2::UpdateVj<float>(*(void **)(a1 + 272), *(void **)(*(void *)(a1 + 232) + 8 * i), *(const float *****)(a1 + 264), *(unsigned char *)(a1 + 128), *(float *)(*(void *)(a1 + 192) + 4 * i), *(float *)(a1 + 72), *(float *)(a1 + 60));
        unint64_t v21 = *(void *)(a1 + 16);
      }
    }
    uint64_t v23 = *(void *)(a1 + 96);
    if (v23)
    {
      unint64_t v24 = (*(void *)(a1 + 104) + 1) % (unint64_t)(v23 + 1);
      *(void *)(a1 + 104) = v24;
      if (*(void *)(a1 + 160) < *(void *)(a1 + 80) || v24) {
        goto LABEL_39;
      }
    }
    else
    {
      *(void *)(a1 + 104) = 0;
      if (*(void *)(a1 + 160) < *(void *)(a1 + 80))
      {
LABEL_39:
        AU::BSS2::GenerateOutput<float>(*(void **)(a1 + 216), *(void **)(a1 + 224), *(void *)(a1 + 256), *(void **)(a1 + 264), *(void *)(a1 + 112));
        if (*(void *)(a1 + 16))
        {
          unint64_t v39 = 0;
          do
          {
            int v40 = *(const DSPSplitComplex **)(**(void **)(a1 + 264) + 8 * v39);
            uint64_t v41 = **(float ***)(**(void **)(a1 + 288) + 8 * v39);
            vDSP_Length v42 = *(void *)(a1 + 24);
            float v49 = 2.2204e-16;
            vDSP_zvmags(v40, 1, v41, 1, v42);
            vDSP_vsadd(v41, 1, &v49, v41, 1, v42);
            ++v39;
          }
          while (*(void *)(a1 + 16) > v39);
        }
        if (*(unsigned char *)(a1 + 137)) {
          AU::BSS2::FixWNG<float>(*(void **)(a1 + 264), *(void **)(a1 + 296), *(void **)(a1 + 288), *(void *)(a1 + 272), *(void *)(a1 + 112), *(float *)(a1 + 124));
        }
        if (*(unsigned char *)(a1 + 136)) {
          AU::BSS2::MixturePhase<float>(*(void **)(a1 + 256), *(void **)(a1 + 296), *(void **)(a1 + 264), *(void **)(a1 + 288), **(float *****)(a1 + 272), *(void *)(*(void *)(a1 + 272) + 24));
        }
        if (*(void *)(a1 + 16))
        {
          unint64_t v43 = 0;
          vDSP_Length v44 = *(void *)(a1 + 24);
          unint64_t v45 = ****(float *****)(a1 + 272);
          do
          {
            uint64_t v46 = *(const float ***)(**(void **)(a1 + 264) + 8 * v43);
            vDSP_vadd(*v46, 1, v46[1], 1, v45, 1, v44);
            if (v44)
            {
              for (uint64_t j = 0; j != v44; ++j)
                ;
            }
            ++v43;
            unint64_t v25 = *(void *)(a1 + 16);
          }
          while (v25 > v43);
        }
        else
        {
          unint64_t v25 = 0;
        }
        goto LABEL_54;
      }
    }
    if (v21 == 2)
    {
      unint64_t v34 = 0;
      do
      {
        AU::BSS2::UpdateWProject23<float>(*(const DSPSplitComplex ****)(a1 + 216), v34, *(void *)(*(void *)(a1 + 232) + 8 * v34), *(const DSPSplitComplex ****)(a1 + 272), *(const DSPSplitComplex ****)(a1 + 264), *(float *)(a1 + 64));
        AU::BSS2::UpdateWScale<float>(*(void **)(a1 + 216), v34, *(void *)(*(void *)(a1 + 232) + 8 * v34), *(void **)(a1 + 216), *(const DSPSplitComplex ****)(a1 + 264), *(const DSPSplitComplex ****)(a1 + 272));
        ++v34;
      }
      while (*(void *)(a1 + 16) > v34);
      uint64_t v35 = *(const DSPSplitComplex ****)(a1 + 216);
      if (v35[1] != (const DSPSplitComplex **)2) {
        __assert_rtn("tDSP_inverse2x2", "Tensor3Lib.h", 1183, "MatIn.rows == 2");
      }
      int v36 = *(const DSPSplitComplex ****)(a1 + 264);
      uint64_t v37 = *(const DSPSplitComplex ****)(a1 + 224);
      vDSP_Length v38 = (vDSP_Length)v35[3];
      vDSP_zvmul(**v35 + 1, 1, (*v35)[1], 1, **v36, 1, v38, 1);
      vDSP_zvneg(**v36, 1, **v36, 1, v38);
      vDSP_zvma(**v35, 1, (*v35)[1] + 1, 1, **v36, 1, **v36, 1, v38);
      t3l::tDSP_zvreciprocal<float>((**v36)->realp, (**v36)->imagp, (**v36)->realp, (**v36)->imagp, v38);
      vDSP_zvmul(**v35, 1, **v36, 1, (*v37)[1] + 1, 1, v38, 1);
      vDSP_zvmul((*v35)[1] + 1, 1, **v36, 1, **v37, 1, v38, 1);
      vDSP_zvneg(**v36, 1, **v36, 1, v38);
      vDSP_zvmul((*v35)[1], 1, **v36, 1, (*v37)[1], 1, v38, 1);
      vDSP_zvmul(**v35 + 1, 1, **v36, 1, **v37 + 1, 1, v38, 1);
    }
    else
    {
      if (v21 != 3) {
        __assert_rtn("UpdateUmixing", "AUBSS2Algorithm+XIVACramer23.h", 205, "0");
      }
      unint64_t v27 = 0;
      do
      {
        AU::BSS2::UpdateWProject23<float>(*(const DSPSplitComplex ****)(a1 + 216), v27, *(void *)(*(void *)(a1 + 232) + 8 * v27), *(const DSPSplitComplex ****)(a1 + 272), *(const DSPSplitComplex ****)(a1 + 264), *(float *)(a1 + 64));
        AU::BSS2::UpdateWScale<float>(*(void **)(a1 + 216), v27, *(void *)(*(void *)(a1 + 232) + 8 * v27), *(void **)(a1 + 216), *(const DSPSplitComplex ****)(a1 + 264), *(const DSPSplitComplex ****)(a1 + 272));
        ++v27;
      }
      while (*(void *)(a1 + 16) > v27);
      uint64_t v28 = *(const DSPSplitComplex ****)(a1 + 216);
      if (v28[1] != (const DSPSplitComplex **)3) {
        __assert_rtn("tDSP_inverse3x3", "Tensor3Lib.h", 1244, "MIn.rows == 3");
      }
      uint64_t v29 = *(const DSPSplitComplex ****)(a1 + 224);
      unint64_t v30 = *(const DSPSplitComplex ****)(a1 + 264);
      vDSP_Length __N = (vDSP_Length)v28[3];
      vDSP_zvmul((*v28)[1] + 2, 1, (*v28)[2] + 1, 1, **v30, 1, __N, 1);
      vDSP_zvneg(**v30, 1, **v30, 1, __N);
      vDSP_zvma((*v28)[1] + 1, 1, (*v28)[2] + 2, 1, **v30, 1, **v29, 1, __N);
      vDSP_zvmul((*v28)[1], 1, (*v28)[2] + 2, 1, **v30, 1, __N, 1);
      vDSP_zvneg(**v30, 1, **v30, 1, __N);
      vDSP_zvma((*v28)[1] + 2, 1, (*v28)[2], 1, **v30, 1, (*v29)[1], 1, __N);
      vDSP_zvmul((*v28)[1] + 1, 1, (*v28)[2], 1, **v30, 1, __N, 1);
      vDSP_zvneg(**v30, 1, **v30, 1, __N);
      vDSP_zvma((*v28)[1], 1, (*v28)[2] + 1, 1, **v30, 1, (*v29)[2], 1, __N);
      vDSP_zvmul(**v28 + 1, 1, (*v28)[2] + 2, 1, **v30, 1, __N, 1);
      vDSP_zvneg(**v30, 1, **v30, 1, __N);
      vDSP_zvma(**v28 + 2, 1, (*v28)[2] + 1, 1, **v30, 1, **v29 + 1, 1, __N);
      vDSP_zvmul(**v28 + 2, 1, (*v28)[2], 1, **v30, 1, __N, 1);
      vDSP_zvneg(**v30, 1, **v30, 1, __N);
      vDSP_zvma(**v28, 1, (*v28)[2] + 2, 1, **v30, 1, (*v29)[1] + 1, 1, __N);
      vDSP_zvmul(**v28, 1, (*v28)[2] + 1, 1, **v30, 1, __N, 1);
      vDSP_zvneg(**v30, 1, **v30, 1, __N);
      vDSP_zvma(**v28 + 1, 1, (*v28)[2], 1, **v30, 1, (*v29)[2] + 1, 1, __N);
      vDSP_zvmul(**v28 + 2, 1, (*v28)[1] + 1, 1, **v30, 1, __N, 1);
      vDSP_zvneg(**v30, 1, **v30, 1, __N);
      vDSP_zvma(**v28 + 1, 1, (*v28)[1] + 2, 1, **v30, 1, **v29 + 2, 1, __N);
      vDSP_zvmul(**v28, 1, (*v28)[1] + 2, 1, **v30, 1, __N, 1);
      vDSP_zvneg(**v30, 1, **v30, 1, __N);
      vDSP_zvma(**v28 + 2, 1, (*v28)[1], 1, **v30, 1, (*v29)[1] + 2, 1, __N);
      vDSP_zvmul(**v28 + 1, 1, (*v28)[1], 1, **v30, 1, __N, 1);
      vDSP_zvneg(**v30, 1, **v30, 1, __N);
      vDSP_zvma(**v28, 1, (*v28)[1] + 1, 1, **v30, 1, (*v29)[2] + 2, 1, __N);
      vDSP_zvmul(**v28, 1, **v29, 1, **v30, 1, __N, 1);
      vDSP_zvma(**v28 + 1, 1, (*v29)[1], 1, **v30, 1, **v30, 1, __N);
      vDSP_zvma(**v28 + 2, 1, (*v29)[2], 1, **v30, 1, **v30, 1, __N);
      t3l::tDSP_zvreciprocal<float>((**v30)->realp, (**v30)->imagp, (**v30)->realp, (**v30)->imagp, __N);
      for (uint64_t k = 0; k != 3; ++k)
      {
        for (uint64_t m = 0; m != 3; ++m)
          vDSP_zvmul(&(*v29)[k][m], 1, **v30, 1, &(*v29)[k][m], 1, __N, 1);
      }
    }
    goto LABEL_39;
  }
  AU::BSS2::GenerateOutput<float>(*(void **)(a1 + 216), *(void **)(a1 + 224), *(void *)(a1 + 256), *(void **)(a1 + 264), *(void *)(a1 + 112));
  unint64_t v25 = *(void *)(a1 + 16);
LABEL_54:
  t3l::tDSP_copy_ztensor_to_freq_abl<float>(**(void **)(a1 + 264), a3, *(void *)(a1 + 40), v25);
  return 0;
}

void AU::BSS2::UpdateWProject23<float>(const DSPSplitComplex ***a1, unint64_t a2, uint64_t a3, const DSPSplitComplex ***a4, const DSPSplitComplex ***a5, float a6)
{
  float __B = a6;
  float v6 = a1[2];
  if (((unint64_t)v6 & 0xFFFFFFFFFFFFFFFELL) != 2) {
    __assert_rtn("UpdateWProject23", "AUBSS2IVALib.h", 111, "Nm == 2 || Nm == 3");
  }
  vDSP_Length v12 = (vDSP_Length)a1[3];
  t3l::tDSP_zmzmuppermult<float>(a1, a3, a4);
  float __A = 1.0;
  uint64_t v13 = 1;
  vDSP_zvmov(**a4, 1, **a5, 1, v12);
  uint64_t v14 = 1;
  do
    vDSP_zvadd(&(*a4)[v13++][v14++], 1, **a5, 1, **a5, 1, v12);
  while (v6 != (const DSPSplitComplex **)v13);
  vDSP_zvabs(**a5, 1, (**a5)->realp, 1, v12);
  vDSP_svdiv(&__A, (**a5)->realp, 1, (**a5)->realp, 1, v12);
  if (v6)
  {
    for (unint64_t i = 0; i != v6; unint64_t i = (const DSPSplitComplex **)((char *)i + 1))
    {
      uint64_t v16 = 0;
      uint64_t v17 = v6;
      do
      {
        vDSP_zrvmul(&(*a4)[(void)i][v16], 1, (**a5)->realp, 1, &(*a4)[(void)i][v16], 1, v12);
        ++v16;
        uint64_t v17 = (const DSPSplitComplex **)((char *)v17 - 1);
      }
      while (v17);
    }
  }
  if (a6 > 0.0) {
    t3l::tDSP_zmsreg<float>(a4, &__B);
  }
  if (v6)
  {
    if (v6 == (const DSPSplitComplex **)2)
    {
      if (a4[1] != (const DSPSplitComplex **)2) {
        __assert_rtn("tDSP_inversecolt2x2", "Tensor3Lib.h", 1381, "MIn.rows == 2");
      }
      if (a4[2] != (const DSPSplitComplex **)2) {
        __assert_rtn("tDSP_inversecolt2x2", "Tensor3Lib.h", 1382, "MIn.cols == MIn.rows");
      }
      if (a1[1] != (const DSPSplitComplex **)2) {
        __assert_rtn("tDSP_inversecolt2x2", "Tensor3Lib.h", 1383, "MOut.rows == MIn.rows");
      }
      if (a1[2] != (const DSPSplitComplex **)2) {
        __assert_rtn("tDSP_inversecolt2x2", "Tensor3Lib.h", 1384, "MOut.cols == MIn.rows");
      }
      vDSP_Length v23 = (vDSP_Length)a4[3];
      if ((const DSPSplitComplex **)v23 != a1[3]) {
        __assert_rtn("tDSP_inversecolt2x2", "Tensor3Lib.h", 1385, "MIn.len == MOut.len");
      }
      if (a2 >= 2) {
        __assert_rtn("tDSP_inversecolt2x2", "Tensor3Lib.h", 1386, "jSource < MIn.rows");
      }
      unint64_t v24 = *a4;
      if (a2)
      {
        vDSP_zvmov(*v24 + 1, 1, (*a1)[1], 1, (vDSP_Length)a4[3]);
        vDSP_zvneg((*a1)[1], 1, (*a1)[1], 1, v23);
        vDSP_zvmov(**a4, 1, (*a1)[1] + 1, 1, v23);
      }
      else
      {
        vDSP_zvmov(v24[1] + 1, 1, **a1, 1, (vDSP_Length)a4[3]);
        vDSP_zvmov((*a4)[1], 1, **a1 + 1, 1, v23);
        vDSP_zvneg(**a1 + 1, 1, **a1 + 1, 1, v23);
      }
    }
    else if (v6 == (const DSPSplitComplex **)3)
    {
      if (a4[1] != (const DSPSplitComplex **)3) {
        __assert_rtn("tDSP_inversecolt3x3", "Tensor3Lib.h", 1412, "MIn.rows == 3");
      }
      if (a4[2] != (const DSPSplitComplex **)3) {
        __assert_rtn("tDSP_inversecolt3x3", "Tensor3Lib.h", 1413, "MIn.cols == 3");
      }
      if (a2 >= 3) {
        __assert_rtn("tDSP_inversecolt3x3", "Tensor3Lib.h", 1414, "jSource < 3");
      }
      vDSP_Length __N = (vDSP_Length)a4[3];
      if ((const DSPSplitComplex **)__N != a1[3]) {
        __assert_rtn("tDSP_inversecolt3x3", "Tensor3Lib.h", 1415, "MIn.len == MOut.len");
      }
      if (a2 == 2)
      {
        vDSP_zvmul(**a4 + 2, 1, (*a4)[1] + 1, 1, **a5, 1, (vDSP_Length)a4[3], 1);
        vDSP_zvneg(**a5, 1, **a5, 1, __N);
        vDSP_zvma(**a4 + 1, 1, (*a4)[1] + 2, 1, **a5, 1, (*a1)[2], 1, __N);
        vDSP_zvmul(**a4, 1, (*a4)[1] + 2, 1, **a5, 1, __N, 1);
        vDSP_zvneg(**a5, 1, **a5, 1, __N);
        vDSP_zvma(**a4 + 2, 1, (*a4)[1], 1, **a5, 1, (*a1)[2] + 1, 1, __N);
        vDSP_zvmul(**a4 + 1, 1, (*a4)[1], 1, **a5, 1, __N, 1);
        vDSP_zvneg(**a5, 1, **a5, 1, __N);
        long double v19 = **a4;
        float v20 = (*a4)[1] + 1;
        unint64_t v21 = **a5;
        uint64_t v22 = (*a1)[2];
      }
      else if (a2 == 1)
      {
        vDSP_zvmul(**a4 + 1, 1, (*a4)[2] + 2, 1, **a5, 1, (vDSP_Length)a4[3], 1);
        vDSP_zvneg(**a5, 1, **a5, 1, __N);
        vDSP_zvma(**a4 + 2, 1, (*a4)[2] + 1, 1, **a5, 1, (*a1)[1], 1, __N);
        vDSP_zvmul(**a4 + 2, 1, (*a4)[2], 1, **a5, 1, __N, 1);
        vDSP_zvneg(**a5, 1, **a5, 1, __N);
        vDSP_zvma(**a4, 1, (*a4)[2] + 2, 1, **a5, 1, (*a1)[1] + 1, 1, __N);
        vDSP_zvmul(**a4, 1, (*a4)[2] + 1, 1, **a5, 1, __N, 1);
        vDSP_zvneg(**a5, 1, **a5, 1, __N);
        long double v19 = **a4 + 1;
        float v20 = (*a4)[2];
        unint64_t v21 = **a5;
        uint64_t v22 = (*a1)[1];
      }
      else
      {
        vDSP_zvmul((*a4)[1] + 2, 1, (*a4)[2] + 1, 1, **a5, 1, (vDSP_Length)a4[3], 1);
        vDSP_zvneg(**a5, 1, **a5, 1, __N);
        vDSP_zvma((*a4)[1] + 1, 1, (*a4)[2] + 2, 1, **a5, 1, **a1, 1, __N);
        vDSP_zvmul((*a4)[1], 1, (*a4)[2] + 2, 1, **a5, 1, __N, 1);
        vDSP_zvneg(**a5, 1, **a5, 1, __N);
        vDSP_zvma((*a4)[1] + 2, 1, (*a4)[2], 1, **a5, 1, **a1 + 1, 1, __N);
        vDSP_zvmul((*a4)[1] + 1, 1, (*a4)[2], 1, **a5, 1, __N, 1);
        vDSP_zvneg(**a5, 1, **a5, 1, __N);
        long double v19 = (*a4)[1];
        float v20 = (*a4)[2] + 1;
        unint64_t v21 = **a5;
        uint64_t v22 = **a1;
      }
      vDSP_zvma(v19, 1, v20, 1, v21, 1, v22 + 2, 1, __N);
    }
    uint64_t v25 = 0;
    do
    {
      uint64_t v26 = &(*a1)[a2][v25];
      vDSP_zvconj(v26, 1, v26, 1, v12);
      ++v25;
      float v6 = (const DSPSplitComplex **)((char *)v6 - 1);
    }
    while (v6);
  }
}

void t3l::tDSP_zvreciprocal<float>(float *a1, float *a2, float *a3, float *a4, vDSP_Length __N)
{
  __B.realp = a1;
  __B.imagp = a2;
  __C.realp = a3;
  __C.imagp = a4;
  int v6 = 0;
  int v7 = 1065353216;
  __A.realp = (float *)&v7;
  __A.imagp = (float *)&v6;
  vDSP_zvdiv(&__B, 1, &__A, 0, &__C, 1, __N);
}

uint64_t AU::BSS2::AUXIVACramer23<float>::Initialize(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, float a5)
{
  if (a5 >= 0.0)
  {
    *(void *)(a1 + 40) = a2;
    *(void *)(a1 + 160) = 0;
    *(void *)(a1 + 16) = a4;
    float v8 = a5 / (float)a2;
    *(float *)(a1 + 32) = a5;
    *(float *)(a1 + 36) = v8;
    float v9 = *(float *)(a1 + 68);
    float v10 = 0.0;
    if (v9 > 0.0)
    {
      if (v8 <= 0.0) {
        __assert_rtn("ComputeCoefFromTC", "Tensor3Lib.h", 30, "blockFs > 0");
      }
      float v10 = expf(-1.0 / (float)(v8 * v9));
    }
    *(float *)(a1 + 72) = v10;
    *(float *)(a1 + 36) = v8;
    *(void *)(a1 + 24) = a3;
    LODWORD(v12) = 0;
    std::vector<float>::resize(a1 + 192, a4, &v12);
    t3l::tDSP_create_vec_tensors<float>(&v12, *(void *)(a1 + 16), *(void *)(a1 + 16), *(void *)(a1 + 16), *(void *)(a1 + 24), *(float *)(a1 + 88));
    std::vector<std::unique_ptr<t3l::ZTensor3<float>>>::__vdeallocate((uint64_t **)(a1 + 232));
    *(_OWORD *)(a1 + 232) = v12;
    *(void *)(a1 + 248) = v13;
    uint64_t v13 = 0;
    long long v12 = 0uLL;
    uint64_t v14 = (void **)&v12;
    std::vector<std::unique_ptr<t3l::ZTensor3<float>>>::__destroy_vector::operator()[abi:ne180100](&v14);
    operator new();
  }
  return 1;
}

void sub_1BB37D3CC(_Unwind_Exception *a1)
{
  MEMORY[0x1C185D370](v1, 0x10A0C40CB468F57);
  _Unwind_Resume(a1);
}

void AU::BSS2::AUXIVALU<float>::~AUXIVALU(uint64_t a1)
{
  AU::BSS2::AUXIVALU<float>::~AUXIVALU(a1);

  JUMPOUT(0x1C185D370);
}

uint64_t AU::BSS2::AUXIVALU<float>::~AUXIVALU(uint64_t a1)
{
  *(void *)a1 = &unk_1F14AC210;
  std::unique_ptr<t3l::RTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 304), 0);
  std::unique_ptr<t3l::RTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 296), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 288), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 280), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 272), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 264), 0);
  unint64_t v5 = (void **)(a1 + 240);
  std::vector<std::unique_ptr<t3l::ZTensor3<float>>>::__destroy_vector::operator()[abi:ne180100](&v5);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 232), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 224), 0);
  unint64_t v2 = *(void **)(a1 + 200);
  if (v2)
  {
    *(void *)(a1 + 208) = v2;
    operator delete(v2);
  }
  unint64_t v3 = *(void **)(a1 + 176);
  if (v3)
  {
    *(void *)(a1 + 184) = v3;
    operator delete(v3);
  }
  return a1;
}

uint64_t AU::BSS2::AUXIVALU<float>::Reset(uint64_t a1)
{
  if (*(void *)(a1 + 16))
  {
    unint64_t v2 = 0;
    do
    {
      t3l::tDSP_ztfilldiag<float>(*(void **)(*(void *)(a1 + 240) + 8 * v2), *(float *)(a1 + 88));
      *(_DWORD *)(*(void *)(a1 + 176) + 4 * v2++) = 1065353216;
    }
    while (*(void *)(a1 + 16) > v2);
  }
  unint64_t v3 = *(void **)(a1 + 224);
  unint64_t v4 = v3[1];
  if (v4 != v3[2]) {
    __assert_rtn("tDSP_zmeye", "Tensor3Lib.h", 513, "N == X.cols");
  }
  vDSP_Length v5 = v3[3];
  float __A = 1.0;
  if (v4)
  {
    unint64_t v6 = 0;
    unint64_t v7 = 1;
    unint64_t v8 = v4;
    do
    {
      if (v7)
      {
        uint64_t v9 = 0;
        for (unint64_t i = 0; i < v7; ++i)
        {
          float v11 = (float **)(*(void *)(*v3 + 8 * v6) + v9);
          vDSP_vclr(*v11, 1, v5);
          vDSP_vclr(v11[1], 1, v5);
          unint64_t v7 = v3[2];
          v9 += 16;
        }
        unint64_t v8 = v3[1];
      }
      ++v6;
    }
    while (v8 > v6);
    uint64_t v12 = 0;
    for (uint64_t j = 0; j != v4; ++j)
    {
      vDSP_vfill(&__A, *(float **)(*(void *)(*v3 + 8 * j) + v12), 1, v5);
      v12 += 16;
    }
  }
  *(void *)(a1 + 168) = 1;
  *(void *)(a1 + 104) = 0;
  return 0;
}

uint64_t AU::BSS2::AUXIVALU<float>::UpdatePrior(uint64_t a1, unint64_t a2, float a3, float a4)
{
  uint64_t v4 = *(void *)(a1 + 176);
  if (a2 > (*(void *)(a1 + 184) - v4) >> 2) {
    __assert_rtn("UpdatePrior", "AUBSS2Algorithm+XIVALU.h", 358, "index <= priors.size()");
  }
  if (a3 < 0.0) {
    a3 = 0.0;
  }
  float v5 = a3 + -0.5;
  BOOL v6 = a3 <= 1.0;
  float v7 = 0.5;
  if (v6) {
    float v7 = v5;
  }
  *(float *)(v4 + 4 * a2) = expf(v7 * a4);
  return 0;
}

uint64_t AU::BSS2::AUXIVALU<float>::UpdateParam(uint64_t a1, int a2, float a3)
{
  if (!*(unsigned char *)(a1 + 8)) {
    return 1;
  }
  switch(a2)
  {
    case 0:
      uint64_t result = 0;
      *(unsigned char *)(a1 + 120) = a3 != 0.0;
      break;
    case 1:
      *(float *)(a1 + 68) = a3;
      float v5 = 0.0;
      if (a3 > 0.0)
      {
        float v6 = *(float *)(a1 + 36);
        if (v6 <= 0.0) {
          __assert_rtn("ComputeCoefFromTC", "Tensor3Lib.h", 30, "blockFs > 0");
        }
        float v5 = expf(-1.0 / (float)(v6 * a3));
      }
      uint64_t result = 0;
      *(float *)(a1 + 72) = v5;
      break;
    case 2:
      uint64_t result = 0;
      *(unsigned char *)(a1 + 132) = a3 != 0.0;
      break;
    case 3:
      float v7 = __exp10f(a3 / 20.0);
      uint64_t result = 0;
      *(float *)(a1 + 52) = v7;
      break;
    case 4:
      float v8 = __exp10f(a3 / 20.0);
      uint64_t result = 0;
      *(float *)(a1 + 56) = v8;
      break;
    case 5:
      float v9 = __exp10f(a3 / 20.0);
      uint64_t result = 0;
      *(float *)(a1 + 60) = v9;
      break;
    case 6:
      float v10 = __exp10f(a3 / 20.0);
      uint64_t result = 0;
      *(float *)(a1 + 64) = v10;
      break;
    case 7:
      uint64_t result = 0;
      *(void *)(a1 + 112) = (unint64_t)a3;
      break;
    case 8:
      uint64_t result = 0;
      *(float *)(a1 + 48) = a3;
      break;
    case 9:
      float v11 = __exp10f(a3 / 20.0);
      uint64_t result = 0;
      *(float *)(a1 + 124) = v11;
      break;
    case 10:
      uint64_t result = 0;
      *(void *)(a1 + 96) = (unint64_t)a3;
      break;
    case 11:
      float v12 = __exp10f(a3 / 20.0);
      uint64_t result = 0;
      *(float *)(a1 + 128) = v12;
      break;
    case 12:
      uint64_t result = 0;
      *(void *)(a1 + 80) = vcvtas_u32_f32((float)(*(float *)(a1 + 32) * a3) / (float)*(unint64_t *)(a1 + 40));
      break;
    case 13:
      float v13 = __exp10f(a3 / 20.0);
      uint64_t result = 0;
      *(float *)(a1 + 88) = v13;
      break;
    case 14:
      uint64_t result = 0;
      unint64_t v14 = *(void *)(a1 + 24) - 1;
      float v15 = *(float *)(a1 + 32) / ((double)*(unint64_t *)(a1 + 40) + (double)*(unint64_t *)(a1 + 40));
      unint64_t v16 = vcvtas_u32_f32(fabsf(a3 / v15));
      if (v16 < v14) {
        unint64_t v14 = v16;
      }
      *(void *)(a1 + 136) = v14;
      break;
    case 15:
      uint64_t result = 0;
      unint64_t v17 = *(void *)(a1 + 24) - 1;
      float v18 = *(float *)(a1 + 32) / ((double)*(unint64_t *)(a1 + 40) + (double)*(unint64_t *)(a1 + 40));
      unint64_t v19 = vcvtas_u32_f32(fabsf(a3 / v18));
      if (v19 < v17) {
        unint64_t v17 = v19;
      }
      *(void *)(a1 + 144) = v17;
      break;
    case 16:
      uint64_t result = 0;
      *(void *)(a1 + 152) = (unint64_t)a3;
      break;
    case 17:
      if (*(void *)(a1 + 160) <= *(void *)(a1 + 16))
      {
        uint64_t result = 0;
        *(void *)(a1 + 160) = (unint64_t)a3;
      }
      else
      {
        uint64_t result = 0;
      }
      break;
    default:
      return 1;
  }
  return result;
}

uint64_t AU::BSS2::AUXIVALU<float>::SideChain(uint64_t a1, uint64_t a2, uint64_t a3)
{
  t3l::tDSP_copy_freq_abl_to_ztensor<float>(a2, **(void **)(a1 + 264), *(void *)(*(void *)(a1 + 264) + 8), *(void *)(a1 + 40), *(void *)(a1 + 16));
  AU::BSS2::GenerateOutput<float>(*(void **)(a1 + 224), *(void **)(a1 + 232), *(void *)(a1 + 264), *(void **)(a1 + 272), *(void *)(a1 + 112));
  if (*(unsigned char *)(a1 + 133) || *(unsigned char *)(a1 + 132))
  {
    if (*(void *)(a1 + 16))
    {
      unint64_t v5 = 0;
      do
      {
        float v6 = *(const DSPSplitComplex **)(**(void **)(a1 + 264) + 8 * v5);
        float v7 = **(float ***)(**(void **)(a1 + 304) + 8 * v5);
        vDSP_Length v8 = *(void *)(a1 + 24);
        float __B = 2.2204e-16;
        vDSP_zvmags(v6, 1, v7, 1, v8);
        vDSP_vsadd(v7, 1, &__B, v7, 1, v8);
        ++v5;
        unint64_t v9 = *(void *)(a1 + 16);
      }
      while (v9 > v5);
      if (v9)
      {
        unint64_t v10 = 0;
        do
        {
          float v11 = *(const DSPSplitComplex **)(**(void **)(a1 + 272) + 8 * v10);
          float v12 = **(float ***)(**(void **)(a1 + 296) + 8 * v10);
          vDSP_Length v13 = *(void *)(a1 + 24);
          float v16 = 2.2204e-16;
          vDSP_zvmags(v11, 1, v12, 1, v13);
          vDSP_vsadd(v12, 1, &v16, v12, 1, v13);
          ++v10;
        }
        while (*(void *)(a1 + 16) > v10);
      }
    }
  }
  if (*(unsigned char *)(a1 + 133)) {
    AU::BSS2::FixWNG<float>(*(void **)(a1 + 272), *(void **)(a1 + 304), *(void **)(a1 + 296), *(void *)(a1 + 288), *(void *)(a1 + 112), *(float *)(a1 + 124));
  }
  if (*(unsigned char *)(a1 + 132)) {
    AU::BSS2::MixturePhase<float>(*(void **)(a1 + 264), *(void **)(a1 + 304), *(void **)(a1 + 272), *(void **)(a1 + 296), **(float *****)(a1 + 288), *(void *)(*(void *)(a1 + 288) + 24));
  }
  AU::BSS2::AUXIVALU<float>::Mixing(a1, *(uint64_t **)(a1 + 272), a3, *(void *)(a1 + 40), *(void *)(a1 + 16), *(void *)(a1 + 152), *(void *)(a1 + 160));
  return 0;
}

float AU::BSS2::AUXIVALU<float>::Mixing(uint64_t a1, uint64_t *a2, uint64_t a3, vDSP_Length __N, unint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a6 == 1)
  {
    if (*(void *)(a1 + 16))
    {
      unint64_t v13 = 0;
      unint64_t v14 = (float **)(a3 + 16);
      do
      {
        float v15 = *v14;
        v14 += 2;
        vDSP_vclr(v15, 1, 2 * __N);
        ++v13;
      }
      while (*(void *)(a1 + 16) > v13);
    }
    unint64_t v17 = (float *)(*(void *)(a3 + 16) + 4 * __N);
    v25.realp = *(float **)(a3 + 16);
    v25.imagp = v17;
    if (a5 != a7)
    {
      uint64_t v18 = 0;
      unsigned int v19 = 1;
      do
      {
        vDSP_zvadd(*(const DSPSplitComplex **)(*a2 + 8 * v18), 1, &v25, 1, &v25, 1, __N);
        uint64_t v18 = v19;
      }
      while (a5 - a7 > v19++);
    }
    unint64_t v21 = (float *)(*(void *)(a3 + 32) + 4 * __N);
    v25.realp = *(float **)(a3 + 32);
    v25.imagp = v21;
    unint64_t v22 = (a5 - a7);
    if (v22 < a5)
    {
      unsigned int v23 = a5 - a7 + 1;
      do
      {
        vDSP_zvadd(*(const DSPSplitComplex **)(*a2 + 8 * v22), 1, &v25, 1, &v25, 1, __N);
        unint64_t v22 = v23++;
      }
      while (v22 < a5);
    }
  }
  else
  {
    uint64_t v24 = *a2;
    return t3l::tDSP_copy_ztensor_to_freq_abl<float>(v24, a3, __N, a5);
  }
  return result;
}

uint64_t AU::BSS2::AUXIVALU<float>::Process(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!*(unsigned char *)(a1 + 8)) {
    return 1;
  }
  ++*(void *)(a1 + 168);
  t3l::tDSP_copy_freq_abl_to_ztensor<float>(a2, **(void **)(a1 + 264), *(void *)(*(void *)(a1 + 264) + 8), *(void *)(a1 + 40), *(void *)(a1 + 16));
  if (*(void *)(a1 + 16))
  {
    unint64_t v5 = 0;
    do
    {
      float v6 = *(const DSPSplitComplex **)(**(void **)(a1 + 264) + 8 * v5);
      float v7 = **(float ***)(**(void **)(a1 + 304) + 8 * v5);
      vDSP_Length v8 = *(void *)(a1 + 24);
      float __B = 2.2204e-16;
      vDSP_zvmags(v6, 1, v7, 1, v8);
      vDSP_vsadd(v7, 1, &__B, v7, 1, v8);
      ++v5;
    }
    while (*(void *)(a1 + 16) > v5);
  }
  if (*(unsigned char *)(a1 + 120) && AU::BSS2::AboveMinEnergyThreshold<float>(*(void **)(a1 + 304), *(float *)(a1 + 128)))
  {
    uint64_t v9 = *(void *)(a1 + 16);
    unint64_t v10 = *(void **)(a1 + 264);
    if (v9)
    {
      float v11 = (void **)*v10;
      do
      {
        float v12 = *v11++;
        unint64_t v13 = (_DWORD *)v12[1];
        *(_DWORD *)void *v12 = *(_DWORD *)(*v12 + 4);
        *unint64_t v13 = v13[1];
        --v9;
      }
      while (v9);
    }
    t3l::tDSP_zmzvmult<float>(*(void **)(a1 + 224), (uint64_t)v10, *(void **)(a1 + 272));
    if (*(void *)(a1 + 16))
    {
      uint64_t v14 = 0;
      unint64_t v15 = 0;
      do
      {
        float v16 = *(const DSPSplitComplex **)(**(void **)(a1 + 272) + 8 * v15);
        vDSP_zvmags(v16, 1, v16->realp, 1, *(void *)(a1 + 24));
        vDSP_sve((const float *)(**(void **)(**(void **)(a1 + 272) + 8 * v15) + 4 * *(void *)(a1 + 136)), 1, (float *)(*(void *)(a1 + 200) + v14), *(void *)(a1 + 144) - *(void *)(a1 + 136));
        uint64_t v17 = *(void *)(a1 + 200);
        double v18 = (float)(*(float *)(a1 + 48) * 0.5);
        long double v19 = log2((float)(*(float *)(v17 + 4 * v15) + *(float *)(a1 + 52)));
        float v20 = exp2(v19 * v18);
        *(float *)(v17 + 4 * v15) = v20;
        *(float *)(v17 + 4 * v15) = *(float *)(*(void *)(a1 + 176) + 4 * v15) * v20;
        ++v15;
        v14 += 4;
      }
      while (*(void *)(a1 + 16) > v15);
    }
    t3l::tDSP_ztvztvhmultupper<float>(*(void **)(a1 + 264), *(void **)(a1 + 264), *(void **)(a1 + 280));
    if (*(float *)(a1 + 56) > 0.0) {
      t3l::tDSP_zmsreg<float>(*(void **)(a1 + 280), (const float *)(a1 + 56));
    }
    unint64_t v21 = *(void *)(a1 + 16);
    if (v21)
    {
      for (unint64_t i = 0; i < v21; ++i)
      {
        AU::BSS2::UpdateVj<float>(*(void **)(a1 + 280), *(void **)(*(void *)(a1 + 240) + 8 * i), *(const float *****)(a1 + 272), 1, *(float *)(*(void *)(a1 + 200) + 4 * i), *(float *)(a1 + 72), *(float *)(a1 + 60));
        unint64_t v21 = *(void *)(a1 + 16);
      }
    }
    uint64_t v23 = *(void *)(a1 + 96);
    if (v23)
    {
      unint64_t v24 = (*(void *)(a1 + 104) + 1) % (unint64_t)(v23 + 1);
      *(void *)(a1 + 104) = v24;
      if (*(void *)(a1 + 168) < *(void *)(a1 + 80) || v24) {
        goto LABEL_29;
      }
    }
    else
    {
      *(void *)(a1 + 104) = 0;
      if (*(void *)(a1 + 168) < *(void *)(a1 + 80))
      {
LABEL_29:
        AU::BSS2::GenerateOutput<float>(*(void **)(a1 + 224), *(void **)(a1 + 232), *(void *)(a1 + 264), *(void **)(a1 + 272), *(void *)(a1 + 112));
        if (*(void *)(a1 + 16))
        {
          unint64_t v28 = 0;
          do
          {
            uint64_t v29 = *(const DSPSplitComplex **)(**(void **)(a1 + 272) + 8 * v28);
            unint64_t v30 = **(float ***)(**(void **)(a1 + 296) + 8 * v28);
            vDSP_Length v31 = *(void *)(a1 + 24);
            float v38 = 2.2204e-16;
            vDSP_zvmags(v29, 1, v30, 1, v31);
            vDSP_vsadd(v30, 1, &v38, v30, 1, v31);
            ++v28;
          }
          while (*(void *)(a1 + 16) > v28);
        }
        if (*(unsigned char *)(a1 + 133)) {
          AU::BSS2::FixWNG<float>(*(void **)(a1 + 272), *(void **)(a1 + 304), *(void **)(a1 + 296), *(void *)(a1 + 280), *(void *)(a1 + 112), *(float *)(a1 + 124));
        }
        if (*(unsigned char *)(a1 + 132)) {
          AU::BSS2::MixturePhase<float>(*(void **)(a1 + 264), *(void **)(a1 + 304), *(void **)(a1 + 272), *(void **)(a1 + 296), **(float *****)(a1 + 280), *(void *)(*(void *)(a1 + 280) + 24));
        }
        if (*(void *)(a1 + 16))
        {
          unint64_t v32 = 0;
          vDSP_Length v33 = *(void *)(a1 + 24);
          unint64_t v34 = ****(float *****)(a1 + 280);
          do
          {
            uint64_t v35 = *(const float ***)(**(void **)(a1 + 272) + 8 * v32);
            vDSP_vadd(*v35, 1, v35[1], 1, v34, 1, v33);
            if (v33)
            {
              for (uint64_t j = 0; j != v33; ++j)
                ;
            }
            ++v32;
            unint64_t v25 = *(void *)(a1 + 16);
          }
          while (v25 > v32);
        }
        else
        {
          unint64_t v25 = 0;
        }
        goto LABEL_44;
      }
    }
    if (v21)
    {
      unint64_t v27 = 0;
      do
      {
        AU::BSS2::UpdateWProject<float>(*(void **)(a1 + 224), v27, *(void *)(*(void *)(a1 + 240) + 8 * v27), *(void **)(a1 + 296), *(void **)(a1 + 280), *(uint64_t **)(a1 + 272), *(const DSPSplitComplex ****)(a1 + 288), *(float *)(a1 + 64));
        AU::BSS2::UpdateWScale<float>(*(void **)(a1 + 224), v27, *(void *)(*(void *)(a1 + 240) + 8 * v27), *(void **)(a1 + 224), *(const DSPSplitComplex ****)(a1 + 272), *(const DSPSplitComplex ****)(a1 + 280));
        ++v27;
      }
      while (*(void *)(a1 + 16) > v27);
    }
    t3l::tDSP_zminverselu<float>(*(void **)(a1 + 224), *(void **)(a1 + 232), *(void **)(a1 + 296), *(uint64_t **)(a1 + 280), *(uint64_t **)(a1 + 272), *(void *)(a1 + 288));
    goto LABEL_29;
  }
  AU::BSS2::GenerateOutput<float>(*(void **)(a1 + 224), *(void **)(a1 + 232), *(void *)(a1 + 264), *(void **)(a1 + 272), *(void *)(a1 + 112));
  unint64_t v25 = *(void *)(a1 + 16);
LABEL_44:
  AU::BSS2::AUXIVALU<float>::Mixing(a1, *(uint64_t **)(a1 + 272), a3, *(void *)(a1 + 40), v25, *(void *)(a1 + 152), *(void *)(a1 + 160));
  return 0;
}

uint64_t AU::BSS2::AUXIVALU<float>::Initialize(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, float a5)
{
  if (a5 >= 0.0)
  {
    *(void *)(a1 + 40) = a2;
    *(void *)(a1 + 168) = 0;
    *(void *)(a1 + 16) = a4;
    float v9 = a5 / (float)a2;
    *(float *)(a1 + 32) = a5;
    *(float *)(a1 + 36) = v9;
    float v10 = *(float *)(a1 + 68);
    float v11 = 0.0;
    if (v10 > 0.0)
    {
      if (v9 <= 0.0) {
        __assert_rtn("ComputeCoefFromTC", "Tensor3Lib.h", 30, "blockFs > 0");
      }
      float v11 = expf(-1.0 / (float)(v9 * v10));
    }
    *(float *)(a1 + 72) = v11;
    *(float *)(a1 + 36) = v9;
    *(void *)(a1 + 24) = a3;
    LODWORD(v12) = 0;
    std::vector<float>::resize(a1 + 200, a4, &v12);
    t3l::tDSP_create_vec_tensors<float>(&v12, *(void *)(a1 + 16), *(void *)(a1 + 16), *(void *)(a1 + 16), *(void *)(a1 + 24), *(float *)(a1 + 88));
    std::vector<std::unique_ptr<t3l::ZTensor3<float>>>::__vdeallocate((uint64_t **)(a1 + 240));
    *(_OWORD *)(a1 + 240) = v12;
    *(void *)(a1 + 256) = v13;
    uint64_t v13 = 0;
    long long v12 = 0uLL;
    uint64_t v14 = (void **)&v12;
    std::vector<std::unique_ptr<t3l::ZTensor3<float>>>::__destroy_vector::operator()[abi:ne180100](&v14);
    operator new();
  }
  return 1;
}

void sub_1BB37E6F8(_Unwind_Exception *a1)
{
  MEMORY[0x1C185D370](v1, 0x10A0C40CB468F57);
  _Unwind_Resume(a1);
}

void AUBSS2::CreateExtendedElements(AUBSS2 *this)
{
  unint64_t v2 = (AUBSS2 *)((char *)this + 552);
  ausdk::AUScope::Initialize((AUBSS2 *)((char *)this + 552), this, 4, 8);
  for (unsigned int i = 0; ; ++i)
  {
    uint64_t v4 = *((void *)this + 74);
    if (v4) {
      LODWORD(v5) = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 24))(v4);
    }
    else {
      uint64_t v5 = (*((void *)this + 72) - *((void *)this + 71)) >> 3;
    }
    if (i >= v5) {
      break;
    }
    std::to_string(&v16, i);
    float v6 = std::string::insert(&v16, 0, "Mic", 3uLL);
    long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    int64_t v18 = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v16.__r_.__value_.__l.__data_);
    }
    if (v18 >= 0) {
      vDSP_Length v8 = __p;
    }
    else {
      vDSP_Length v8 = (void **)__p[0];
    }
    CFStringRef v9 = CFStringCreateWithCString(0, (const char *)v8, 0x8000100u);
    uint64_t Element = ausdk::AUScope::SafeGetElement(v2, i);
    ausdk::Owned<__CFString const*>::operator=((const void **)(Element + 72), v9);
    uint64_t v11 = ausdk::AUScope::SafeGetElement(v2, i);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v11 + 40))(v11, 2);
    CFRelease(v9);
    if (SHIBYTE(v18) < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v12 = ausdk::AUScope::GetElement((AUBSS2 *)((char *)this + 32), 0);
  if (v12)
  {
    uint64_t v13 = v12;
    std::string::basic_string[abi:ne180100]<0>(__p, "Global");
    uint64_t v14 = v18 >= 0 ? (const char *)__p : (const char *)__p[0];
    CFStringRef v15 = CFStringCreateWithCString(0, v14, 0x8000100u);
    ausdk::Owned<__CFString const*>::operator=((const void **)(v13 + 72), v15);
    CFRelease(v15);
    if (SHIBYTE(v18) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_1BB37E940(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void AUBSS2::~AUBSS2(AUBSS2 *this)
{
  AUBSS2::~AUBSS2(this);

  JUMPOUT(0x1C185D370);
}

{
  uint64_t v2;
  uint64_t v3;
  void **v4;
  uint64_t vars8;

  *(void *)this = &unk_1F14ABFA0;
  unint64_t v2 = *((void *)this + 77);
  *((void *)this + 77) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 56))(v2);
  }
  std::__hash_table<vp::vx::io::Object_ID<vp::vx::io::Node>,std::hash<vp::vx::io::Object_ID<vp::vx::io::Node>>,std::equal_to<vp::vx::io::Object_ID<vp::vx::io::Node>>,std::allocator<vp::vx::io::Object_ID<vp::vx::io::Node>>>::~__hash_table((uint64_t)this + 664);
  std::__hash_table<vp::vx::io::Object_ID<vp::vx::io::Node>,std::hash<vp::vx::io::Object_ID<vp::vx::io::Node>>,std::equal_to<vp::vx::io::Object_ID<vp::vx::io::Node>>,std::allocator<vp::vx::io::Object_ID<vp::vx::io::Node>>>::~__hash_table((uint64_t)this + 624);
  unint64_t v3 = *((void *)this + 77);
  *((void *)this + 77) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 56))(v3);
  }
  uint64_t v4 = (void **)((char *)this + 568);
  std::vector<std::unique_ptr<ausdk::AUElement>>::__destroy_vector::operator()[abi:ne180100](&v4);

  ausdk::AUBase::~AUBase(this);
}

void std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::__assign_unique<std::pair<unsigned int const,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>> const*>(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  uint64_t v5 = a2;
  uint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    for (uint64_t i = 0; i != v7; ++i)
      *(void *)(*(void *)a1 + 8 * i) = 0;
    CFStringRef v9 = *(void **)(a1 + 16);
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = 0;
    if (v9) {
      BOOL v10 = a2 == a3;
    }
    else {
      BOOL v10 = 1;
    }
    if (!v10)
    {
      while (1)
      {
        unint64_t v12 = *v5;
        *((_DWORD *)v9 + 4) = v12;
        void v9[3] = *((void *)v5 + 1);
        *((_DWORD *)v9 + 8) = v5[4];
        *((_DWORD *)v9 + 9) = v5[5];
        *((_DWORD *)v9 + 10) = v5[6];
        *(void *)((char *)v9 + 44) = *(void *)(v5 + 7);
        uint64_t v11 = (void *)*v9;
        v9[1] = v12;
        unint64_t v13 = *(void *)(a1 + 8);
        if (v13)
        {
          uint8x8_t v14 = (uint8x8_t)vcnt_s8((int8x8_t)v13);
          v14.i16[0] = vaddlv_u8(v14);
          if (v14.u32[0] > 1uLL)
          {
            unint64_t v15 = v12;
            if (v13 <= v12) {
              unint64_t v15 = v12 % v13;
            }
          }
          else
          {
            unint64_t v15 = (v13 - 1) & v12;
          }
          std::string v16 = *(uint64_t ***)(*(void *)a1 + 8 * v15);
          if (v16)
          {
            for (uint64_t j = *v16; j; uint64_t j = (uint64_t *)*j)
            {
              unint64_t v18 = j[1];
              if (v18 == v12)
              {
                if (*((_DWORD *)j + 4) == v12) {
                  goto LABEL_49;
                }
              }
              else
              {
                if (v14.u32[0] > 1uLL)
                {
                  if (v18 >= v13) {
                    v18 %= v13;
                  }
                }
                else
                {
                  v18 &= v13 - 1;
                }
                if (v18 != v15) {
                  break;
                }
              }
            }
          }
        }
        float v19 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
        float v20 = *(float *)(a1 + 32);
        if (!v13 || (float)(v20 * (float)v13) < v19)
        {
          uint64_t v21 = 2 * v13;
          BOOL v22 = v13 < 3 || (v13 & (v13 - 1)) != 0;
          size_t v23 = v22 | v21;
          unint64_t v24 = vcvtps_u32_f32(v19 / v20);
          if (v23 <= v24) {
            size_t v25 = v24;
          }
          else {
            size_t v25 = v23;
          }
          std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::__rehash<true>(a1, v25);
          unint64_t v13 = *(void *)(a1 + 8);
          unint64_t v12 = v9[1];
        }
        uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v13);
        v26.i16[0] = vaddlv_u8(v26);
        if (v26.u32[0] > 1uLL)
        {
          if (v12 >= v13) {
            v12 %= v13;
          }
        }
        else
        {
          v12 &= v13 - 1;
        }
        unint64_t v27 = *(void **)(*(void *)a1 + 8 * v12);
        if (v27)
        {
          void *v9 = *v27;
        }
        else
        {
          void *v9 = *(void *)(a1 + 16);
          *(void *)(a1 + 16) = v9;
          *(void *)(*(void *)a1 + 8 * v12) = a1 + 16;
          if (!*v9) {
            goto LABEL_48;
          }
          unint64_t v28 = *(void *)(*v9 + 8);
          if (v26.u32[0] > 1uLL)
          {
            if (v28 >= v13) {
              v28 %= v13;
            }
          }
          else
          {
            v28 &= v13 - 1;
          }
          unint64_t v27 = (void *)(*(void *)a1 + 8 * v28);
        }
        void *v27 = v9;
LABEL_48:
        ++*(void *)(a1 + 24);
LABEL_49:
        v5 += 10;
        if (v11)
        {
          CFStringRef v9 = v11;
          if (v5 != a3) {
            continue;
          }
        }
        goto LABEL_51;
      }
    }
    uint64_t v11 = v9;
LABEL_51:
    if (v11)
    {
      do
      {
        uint64_t v29 = (void *)*v11;
        operator delete(v11);
        uint64_t v11 = v29;
      }
      while (v29);
    }
  }
  if (v5 != a3)
  {
    unint64_t v30 = (void *)(a1 + 16);
    unint64_t v31 = *(void *)(a1 + 8);
    do
    {
      unint64_t v32 = *v5;
      if (v31)
      {
        uint8x8_t v33 = (uint8x8_t)vcnt_s8((int8x8_t)v31);
        v33.i16[0] = vaddlv_u8(v33);
        if (v33.u32[0] > 1uLL)
        {
          unint64_t v3 = *v5;
          if (v31 <= v32) {
            unint64_t v3 = v32 % v31;
          }
        }
        else
        {
          unint64_t v3 = (v31 - 1) & v32;
        }
        unint64_t v34 = *(uint64_t ***)(*(void *)a1 + 8 * v3);
        if (v34)
        {
          for (uint64_t k = *v34; k; uint64_t k = (uint64_t *)*k)
          {
            unint64_t v36 = k[1];
            if (v36 == v32)
            {
              if (*((_DWORD *)k + 4) == v32) {
                goto LABEL_93;
              }
            }
            else
            {
              if (v33.u32[0] > 1uLL)
              {
                if (v36 >= v31) {
                  v36 %= v31;
                }
              }
              else
              {
                v36 &= v31 - 1;
              }
              if (v36 != v3) {
                break;
              }
            }
          }
        }
      }
      uint64_t v37 = operator new(0x38uLL);
      void *v37 = 0;
      v37[1] = v32;
      uint64_t v38 = *((void *)v5 + 4);
      long long v39 = *((_OWORD *)v5 + 1);
      *((_OWORD *)v37 + 1) = *(_OWORD *)v5;
      *((_OWORD *)v37 + 2) = v39;
      v37[6] = v38;
      float v40 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
      float v41 = *(float *)(a1 + 32);
      if (!v31 || (float)(v41 * (float)v31) < v40)
      {
        BOOL v42 = (v31 & (v31 - 1)) != 0;
        if (v31 < 3) {
          BOOL v42 = 1;
        }
        unint64_t v43 = v42 | (2 * v31);
        unint64_t v44 = vcvtps_u32_f32(v40 / v41);
        if (v43 <= v44) {
          size_t v45 = v44;
        }
        else {
          size_t v45 = v43;
        }
        std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::__rehash<true>(a1, v45);
        unint64_t v31 = *(void *)(a1 + 8);
        if ((v31 & (v31 - 1)) != 0)
        {
          if (v31 <= v32) {
            unint64_t v3 = v32 % v31;
          }
          else {
            unint64_t v3 = v32;
          }
        }
        else
        {
          unint64_t v3 = (v31 - 1) & v32;
        }
      }
      uint64_t v46 = *(void *)a1;
      unint64_t v47 = *(void **)(*(void *)a1 + 8 * v3);
      if (v47)
      {
        void *v37 = *v47;
      }
      else
      {
        void *v37 = *v30;
        *unint64_t v30 = v37;
        *(void *)(v46 + 8 * v3) = v30;
        if (!*v37) {
          goto LABEL_92;
        }
        unint64_t v48 = *(void *)(*v37 + 8);
        if ((v31 & (v31 - 1)) != 0)
        {
          if (v48 >= v31) {
            v48 %= v31;
          }
        }
        else
        {
          v48 &= v31 - 1;
        }
        unint64_t v47 = (void *)(*(void *)a1 + 8 * v48);
      }
      void *v47 = v37;
LABEL_92:
      ++*(void *)(a1 + 24);
LABEL_93:
      v5 += 10;
    }
    while (v5 != a3);
  }
}

void sub_1BB37EF04(void *a1)
{
  __cxa_begin_catch(a1);
  do
  {
    unint64_t v2 = (void *)*v1;
    operator delete(v1);
    uint64_t v1 = v2;
  }
  while (v2);
  __cxa_rethrow();
}

void sub_1BB37EF24(_Unwind_Exception *a1)
{
}

uint64_t AUReferenceSignalMixer::RemoveAudioChannelLayout(AUReferenceSignalMixer *this, int a2, int a3)
{
  if (!*((unsigned char *)this + 17))
  {
    if (a2 == 2)
    {
      if (a3) {
        return 4294956419;
      }
      if (*((unsigned char *)this + 600))
      {
        uint64_t v5 = (char *)this + 600;
        float v6 = (void *)*((void *)this + 72);
        if (!v6)
        {
          uint64_t v3 = 4294956430;
          goto LABEL_20;
        }
        *((void *)this + 73) = v6;
        uint64_t v3 = 4294956430;
        goto LABEL_15;
      }
    }
    else if (a2 == 1)
    {
      if (!a3)
      {
        if (!*((unsigned char *)this + 560)) {
          return 0;
        }
        uint64_t v5 = (char *)this + 560;
        float v6 = (void *)*((void *)this + 67);
        if (!v6)
        {
          uint64_t v3 = 0;
          goto LABEL_20;
        }
        uint64_t v3 = 0;
        *((void *)this + 68) = v6;
LABEL_15:
        operator delete(v6);
LABEL_20:
        unsigned char *v5 = 0;
        return v3;
      }
      return 4294956419;
    }
    return 4294956430;
  }
  return 4294956447;
}

uint64_t AUReferenceSignalMixer::SetAudioChannelLayout(AUReferenceSignalMixer *this, int a2, int a3, const AudioChannelLayout *a4)
{
  if (*((unsigned char *)this + 17)) {
    return 4294956447;
  }
  UInt32 mNumberChannelDescriptions = a4->mNumberChannelDescriptions;
  if (mNumberChannelDescriptions <= 1) {
    UInt32 mNumberChannelDescriptions = 1;
  }
  std::vector<char>::vector(&v18, 20 * mNumberChannelDescriptions + 12);
  memcpy(v18.__begin_, a4, 20 * a4->mNumberChannelDescriptions + 12);
  if (a2 != 2)
  {
    if (a2 != 1)
    {
      uint64_t v4 = 4294956430;
      goto LABEL_27;
    }
    if (!a3)
    {
      int v10 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUReferenceSignalMixer *)((char *)this + 80), 0) + 108);
      if (*(_DWORD *)v18.__begin_ == 0x10000)
      {
        uint8x8_t v14 = (uint8x8_t)vcnt_s8((int8x8_t)*((unsigned int *)v18.__begin_ + 1));
        v14.i16[0] = vaddlv_u8(v14);
        __int32 v11 = v14.i32[0];
      }
      else if (*(_DWORD *)v18.__begin_)
      {
        __int32 v11 = (unsigned __int16)*(_DWORD *)v18.__begin_;
      }
      else
      {
        __int32 v11 = *((_DWORD *)v18.__begin_ + 2);
      }
      if (v10 == v11)
      {
        unint64_t v15 = (char *)this + 536;
LABEL_25:
        std::optional<CA::ChannelLayout>::operator=[abi:ne180100]<CA::ChannelLayout const,void>((uint64_t)v15, &v18.__begin_);
        uint64_t v4 = 0;
        goto LABEL_27;
      }
      goto LABEL_26;
    }
LABEL_12:
    uint64_t v4 = 4294956419;
    goto LABEL_27;
  }
  if (a3) {
    goto LABEL_12;
  }
  int v12 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUReferenceSignalMixer *)((char *)this + 128), 0) + 108);
  if (*(_DWORD *)v18.__begin_ == 0x10000)
  {
    uint8x8_t v16 = (uint8x8_t)vcnt_s8((int8x8_t)*((unsigned int *)v18.__begin_ + 1));
    v16.i16[0] = vaddlv_u8(v16);
    __int32 v13 = v16.i32[0];
  }
  else if (*(_DWORD *)v18.__begin_)
  {
    __int32 v13 = (unsigned __int16)*(_DWORD *)v18.__begin_;
  }
  else
  {
    __int32 v13 = *((_DWORD *)v18.__begin_ + 2);
  }
  if (v12 == v13)
  {
    unint64_t v15 = (char *)this + 576;
    goto LABEL_25;
  }
LABEL_26:
  uint64_t v4 = 4294956445;
LABEL_27:
  if (v18.__begin_)
  {
    v18.__end_ = v18.__begin_;
    operator delete(v18.__begin_);
  }
  return v4;
}

void sub_1BB37F188(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::optional<CA::ChannelLayout>::operator=[abi:ne180100]<CA::ChannelLayout const,void>(uint64_t a1, char **a2)
{
  if (*(unsigned char *)(a1 + 24))
  {
    if ((char **)a1 != a2) {
      std::vector<char>::__assign_with_size[abi:ne180100]<char *,char *>((void *)a1, *a2, a2[1], a2[1] - *a2);
    }
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    std::vector<char>::__init_with_size[abi:ne180100]<char *,char *>((void *)a1, *a2, (uint64_t)a2[1], a2[1] - *a2);
    *(unsigned char *)(a1 + 24) = 1;
  }
  return a1;
}

void *std::vector<char>::__assign_with_size[abi:ne180100]<char *,char *>(void *result, char *__src, char *a3, unint64_t a4)
{
  uint64_t v7 = result;
  unint64_t v8 = result[2];
  CFStringRef v9 = (char *)*result;
  if (v8 - *result < a4)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      unint64_t v8 = 0;
      *uint64_t v7 = 0;
      v7[1] = 0;
      void v7[2] = 0;
    }
    if ((a4 & 0x8000000000000000) != 0) {
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = 2 * v8;
    if (2 * v8 <= a4) {
      uint64_t v10 = a4;
    }
    if (v8 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v11 = v10;
    }
    float result = std::vector<unsigned char>::__vallocate[abi:ne180100](v7, v11);
    CFStringRef v9 = (char *)v7[1];
    goto LABEL_17;
  }
  int v12 = (unsigned char *)result[1];
  size_t v13 = v12 - v9;
  if (v12 - v9 >= a4)
  {
LABEL_17:
    size_t v16 = a3 - __src;
    if (v16) {
      float result = memmove(v9, __src, v16);
    }
    unint64_t v15 = &v9[v16];
    goto LABEL_20;
  }
  uint8x8_t v14 = &__src[v13];
  if (v12 != v9)
  {
    float result = memmove((void *)*result, __src, v13);
    CFStringRef v9 = (char *)v7[1];
  }
  if (a3 != v14) {
    float result = memmove(v9, v14, a3 - v14);
  }
  unint64_t v15 = &v9[a3 - v14];
LABEL_20:
  v7[1] = v15;
  return result;
}

uint64_t AUReferenceSignalMixer::GetAudioChannelLayout(AUReferenceSignalMixer *this, int a2, int a3, AudioChannelLayout *__dst, BOOL *a5)
{
  *a5 = *((unsigned char *)this + 17) ^ 1;
  if (a2 != 2)
  {
    if (a2 != 1) {
      return 0;
    }
    if (!a3)
    {
      if (*((unsigned char *)this + 560))
      {
        float v6 = (unsigned char *)*((void *)this + 68);
        uint64_t v7 = (unsigned char *)*((void *)this + 67);
        if (__dst)
        {
          if (v6 != v7)
          {
            memcpy(__dst, v7, v6 - v7);
            float v6 = (unsigned char *)*((void *)this + 68);
            uint64_t v7 = (unsigned char *)*((void *)this + 67);
          }
        }
        return (v6 - v7);
      }
      return 0;
    }
    return 4294956419;
  }
  if (a3) {
    return 4294956419;
  }
  if (*((unsigned char *)this + 600))
  {
    float v6 = (unsigned char *)*((void *)this + 73);
    uint64_t v7 = (unsigned char *)*((void *)this + 72);
    if (__dst && v6 != v7)
    {
      memcpy(__dst, v7, v6 - v7);
      float v6 = (unsigned char *)*((void *)this + 73);
      uint64_t v7 = (unsigned char *)*((void *)this + 72);
    }
    return (v6 - v7);
  }
  return 0;
}

uint64_t AUReferenceSignalMixer::SupportedNumChannels(AUReferenceSignalMixer *this, const AUChannelInfo **a2)
{
  if (a2) {
    *a2 = (const AUChannelInfo *)&AUReferenceSignalMixer::SupportedNumChannels(AUChannelInfo const**)::sChannels;
  }
  return 1;
}

BOOL AUReferenceSignalMixer::StreamFormatWritable(AUReferenceSignalMixer *this, int a2, int a3)
{
  if (a3) {
    BOOL v3 = 1;
  }
  else {
    BOOL v3 = (a2 - 1) >= 2;
  }
  return !v3 && *((unsigned char *)this + 17) == 0;
}

uint64_t AUReferenceSignalMixer::SupportsTail(AUReferenceSignalMixer *this)
{
  return 1;
}

double ausdk::AUBase::GetTailTime(ausdk::AUBase *this)
{
  return 0.0;
}

uint64_t AUReferenceSignalMixer::GetParameterValueStrings(AUReferenceSignalMixer *this, int a2, int a3, const __CFArray **a4)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (a3) {
    return 4294956417;
  }
  if (a2) {
    return 4294956430;
  }
  v6[0] = xmmword_1E623C650;
  v6[1] = *(_OWORD *)&off_1E623C660;
  v6[2] = xmmword_1E623C670;
  uint64_t v7 = "Face down";
  v5[0] = v6;
  v5[1] = 7;
  if (a4) {
    *a4 = applesauce::CF::details::make_CFArrayRef<char const*>((uint64_t)v5);
  }
  return 0;
}

CFArrayRef applesauce::CF::details::make_CFArrayRef<char const*>(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 8);
  memset(v19, 0, sizeof(v19));
  unint64_t v20 = 0;
  std::vector<applesauce::CF::StringRef>::reserve(v19, v2);
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3)
  {
    uint64_t v4 = *(char ***)a1;
    uint64_t v5 = *(void *)a1 + 8 * v3;
    float v6 = *(CFStringRef **)&v19[2];
    do
    {
      if ((unint64_t)v6 >= v20)
      {
        uint64_t v7 = ((uint64_t)v6 - *(void *)v19) >> 3;
        if ((unint64_t)(v7 + 1) >> 61) {
          std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v8 = (uint64_t)(v20 - *(void *)v19) >> 2;
        if (v8 <= v7 + 1) {
          unint64_t v8 = v7 + 1;
        }
        if (v20 - *(void *)v19 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v9 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v9 = v8;
        }
        unint64_t v24 = &v20;
        if (v9) {
          unint64_t v9 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v9);
        }
        else {
          uint64_t v10 = 0;
        }
        uint64_t v21 = (void **)v9;
        v22.i64[0] = v9 + 8 * v7;
        v22.i64[1] = v22.i64[0];
        unint64_t v23 = v9 + 8 * v10;
        std::construct_at[abi:ne180100]<applesauce::CF::StringRef,char const* const&,applesauce::CF::StringRef*>((CFStringRef *)v22.i64[0], *v4);
        uint64_t v11 = v22.i64[0];
        float v6 = (CFStringRef *)(v22.i64[1] + 8);
        v22.i64[1] += 8;
        size_t v13 = *(void **)v19;
        int v12 = *(void **)&v19[2];
        if (*(void *)&v19[2] == *(void *)v19)
        {
          int64x2_t v15 = vdupq_n_s64(*(unint64_t *)&v19[2]);
        }
        else
        {
          do
          {
            uint64_t v14 = *--v12;
            *(void *)(v11 - 8) = v14;
            v11 -= 8;
            void *v12 = 0;
          }
          while (v12 != v13);
          int64x2_t v15 = *(int64x2_t *)v19;
          float v6 = (CFStringRef *)v22.i64[1];
        }
        *(void *)float v19 = v11;
        *(void *)&v19[2] = v6;
        int64x2_t v22 = v15;
        unint64_t v16 = v20;
        unint64_t v20 = v23;
        unint64_t v23 = v16;
        uint64_t v21 = (void **)v15.i64[0];
        std::__split_buffer<applesauce::CF::StringRef>::~__split_buffer((uint64_t)&v21);
      }
      else
      {
        std::construct_at[abi:ne180100]<applesauce::CF::StringRef,char const* const&,applesauce::CF::StringRef*>(v6++, *v4);
      }
      *(void *)&v19[2] = v6;
      ++v4;
    }
    while (v4 != (char **)v5);
  }
  CFArrayRef v17 = applesauce::CF::details::make_CFArrayRef<applesauce::CF::StringRef>((uint64_t **)v19);
  uint64_t v21 = (void **)v19;
  std::vector<applesauce::CF::StringRef>::__destroy_vector::operator()[abi:ne180100](&v21);
  return v17;
}

void sub_1BB37F654(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void **a13)
{
  a13 = (void **)&a9;
  std::vector<applesauce::CF::StringRef>::__destroy_vector::operator()[abi:ne180100](&a13);
  _Unwind_Resume(a1);
}

void *std::vector<applesauce::CF::StringRef>::reserve(void *result, unint64_t a2)
{
  if (a2 > (uint64_t)(result[2] - *result) >> 3)
  {
    if (a2 >> 61) {
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v2 = (char **)result;
    uint64_t v3 = result[1] - *result;
    int64x2_t v15 = result + 2;
    uint64_t v4 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(a2);
    uint64_t v7 = *v2;
    float v6 = v2[1];
    if (v6 == *v2)
    {
      int64x2_t v10 = vdupq_n_s64((unint64_t)v6);
      unint64_t v8 = &v4[v3 & 0xFFFFFFFFFFFFFFF8];
    }
    else
    {
      unint64_t v8 = &v4[v3 & 0xFFFFFFFFFFFFFFF8];
      do
      {
        uint64_t v9 = *((void *)v6 - 1);
        v6 -= 8;
        *((void *)v8 - 1) = v9;
        v8 -= 8;
        *(void *)float v6 = 0;
      }
      while (v6 != v7);
      int64x2_t v10 = *(int64x2_t *)v2;
    }
    *unint64_t v2 = v8;
    v2[1] = &v4[v3 & 0xFFFFFFFFFFFFFFF8];
    int64x2_t v13 = v10;
    uint64_t v11 = v2[2];
    v2[2] = &v4[8 * v5];
    uint64_t v14 = v11;
    uint64_t v12 = v10.i64[0];
    return (void *)std::__split_buffer<applesauce::CF::StringRef>::~__split_buffer((uint64_t)&v12);
  }
  return result;
}

CFArrayRef applesauce::CF::details::make_CFArrayRef<applesauce::CF::StringRef>(uint64_t **a1)
{
  std::vector<void const*>::vector(__p, a1[1] - *a1);
  unint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  if (*a1 != v3)
  {
    uint64_t v4 = __p[0];
    do
    {
      uint64_t v5 = *v2++;
      *v4++ = v5;
    }
    while (v2 != v3);
  }
  CFArrayRef CFArray = applesauce::CF::details::make_CFArrayRef<void const*>((uint64_t)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return CFArray;
}

void sub_1BB37F7D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

CFStringRef *std::construct_at[abi:ne180100]<applesauce::CF::StringRef,char const* const&,applesauce::CF::StringRef*>(CFStringRef *a1, char *__s)
{
  CFIndex v4 = strlen(__s);
  if (__s)
  {
    CFStringRef v5 = CFStringCreateWithBytes(0, (const UInt8 *)__s, v4, 0x8000100u, 0);
    *a1 = v5;
    if (!v5)
    {
      exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
    }
  }
  else
  {
    *a1 = 0;
  }
  return a1;
}

void sub_1BB37F88C(_Unwind_Exception *exception_object)
{
  if (*v1) {
    CFRelease(*v1);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<applesauce::CF::StringRef>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = (const void **)**a1;
  if (v2)
  {
    CFIndex v4 = (const void **)v1[1];
    CFStringRef v5 = **a1;
    if (v4 != v2)
    {
      do
        std::__destroy_at[abi:ne180100]<applesauce::CF::StringRef,0>(--v4);
      while (v4 != v2);
      CFStringRef v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::__split_buffer<applesauce::CF::StringRef>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    std::__destroy_at[abi:ne180100]<applesauce::CF::StringRef,0>((const void **)(i - 8));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

double AUReferenceSignalMixer::GetParameterInfo(AUReferenceSignalMixer *this, int a2, int a3, AudioUnitParameterInfo *buffer)
{
  if (!a3 && !a2)
  {
    buffer->unitName = 0;
    buffer->cfNameString = @"Orientation";
    buffer->flags = 0x8000000;
    CFStringGetCString(@"Orientation", buffer->name, 52, 0x8000100u);
    buffer->unit = kAudioUnitParameterUnit_Indexed;
    double result = 8192.0;
    *(void *)&buffer->minCFArrayRef Value = 0x40C0000000000000;
    AudioUnitParameterOptions v6 = buffer->flags | 0xC0002000;
    buffer->defaultCFArrayRef Value = 1.0;
    buffer->flags = v6;
  }
  return result;
}

uint64_t AUReferenceSignalMixer::GetParameterList(AUReferenceSignalMixer *this, int a2, unsigned int *a3, unsigned int *a4)
{
  if (a2) {
    return 4294956430;
  }
  if (a3) {
    *a3 = 0;
  }
  uint64_t result = 0;
  *a4 = 1;
  return result;
}

uint64_t AUReferenceSignalMixer::ProcessMultipleBufferLists(int8x8_t *this, unsigned int *a2, unsigned int a3, int a4, const AudioBufferList **a5, int a6, AudioBufferList **a7)
{
  if (a4 != 1 || a6 != 1 || (*a5)->mNumberBuffers != this[66].i32[1] || (*a7)->mNumberBuffers != this[71].i32[0]) {
    return 4294956428;
  }
  if (this[66].i8[0])
  {
    this[83] = (int8x8_t)&this[77];
  }
  else
  {
    __int32 v9 = this[76].i32[0];
    if (v9 != this[76].i32[1])
    {
      uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::GetElement((ausdk::AUScope *)&this[4], 0);
      float Parameter = ausdk::AUElement::GetParameter(Element, 0);
      int8x8_t v12 = this[79];
      if (v12)
      {
        unint64_t v13 = Parameter;
        uint8x8_t v14 = (uint8x8_t)vcnt_s8(v12);
        v14.i16[0] = vaddlv_u8(v14);
        if (v14.u32[0] > 1uLL)
        {
          unint64_t v15 = v13;
          if (*(void *)&v12 <= v13) {
            unint64_t v15 = v13 % *(void *)&v12;
          }
        }
        else
        {
          unint64_t v15 = (v12.i32[0] - 1) & v13;
        }
        unint64_t v16 = *(int8x8_t ***)(*(void *)&this[78] + 8 * v15);
        if (v16)
        {
          for (uint64_t i = *v16; i; uint64_t i = (int8x8_t *)*i)
          {
            unint64_t v18 = (unint64_t)i[1];
            if (v18 == v13)
            {
              if (i[2].i32[0] == v13)
              {
                this[83] = i[3];
                break;
              }
            }
            else
            {
              if (v14.u32[0] > 1uLL)
              {
                if (v18 >= *(void *)&v12) {
                  v18 %= *(void *)&v12;
                }
              }
              else
              {
                v18 &= *(void *)&v12 - 1;
              }
              if (v18 != v15) {
                break;
              }
            }
          }
        }
      }
      this[76].i32[1] = v9;
    }
  }
  float v19 = *(uint64_t (**)(void))(**(void **)&this[83] + 16);

  return v19();
}

uint64_t AUReferenceSignalMixer::CanScheduleParameters(AUReferenceSignalMixer *this)
{
  return 0;
}

uint64_t AUReferenceSignalMixer::SetParameter(AUReferenceSignalMixer *this, unsigned int a2, unsigned int a3, unsigned int a4, float a5)
{
  if (a2)
  {
    Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
    uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
    ausdk::AUElement::SetParameter(Element, a2, a5, 0);
    return 0;
  }
  if (a3) {
    return 4294956430;
  }
  if (!a4)
  {
    AUReferenceSignalMixer::SetParameter((uint64_t)this, a5);
    return 0;
  }
  return 4294956419;
}

void AUReferenceSignalMixer::SetParameter(uint64_t a1, float a2)
{
  CFIndex v4 = (ausdk::AUScope *)(a1 + 32);
  uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::GetElement((ausdk::AUScope *)(a1 + 32), 0);
  if (ausdk::AUElement::GetParameter(Element, 0) != a2)
  {
    AudioUnitParameterOptions v6 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v4, 0);
    ausdk::AUElement::SetParameter(v6, 0, a2, 0);
    ++*(_DWORD *)(a1 + 608);
  }
}

uint64_t AUReferenceSignalMixer::GetParameter(AUReferenceSignalMixer *this, unsigned int a2, unsigned int a3, unsigned int a4, float *a5)
{
  if (a2)
  {
    Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
    uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
    unsigned int v10 = a2;
LABEL_3:
    float Parameter = ausdk::AUElement::GetParameter(Element, v10);
    uint64_t result = 0;
    *a5 = Parameter;
    return result;
  }
  if (a3) {
    return 4294956430;
  }
  if (!a4)
  {
    uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUReferenceSignalMixer *)((char *)this + 32), 0);
    unsigned int v10 = 0;
    goto LABEL_3;
  }
  return 4294956419;
}

uint64_t AUReferenceSignalMixer::SetProperty(AUReferenceSignalMixer *this, int a2, int a3, int a4, CFTypeRef *a5)
{
  if (a2 != 1667655524)
  {
    if (a2 == 3700)
    {
      if (!a3)
      {
        if (!a4)
        {
          uint64_t result = 0;
          *((unsigned char *)this + 376) = a5 != 0;
          return result;
        }
        return 4294956419;
      }
    }
    else
    {
      if (a2 != 21) {
        return 4294956417;
      }
      if (!a3)
      {
        if (!a4)
        {
          uint64_t result = 0;
          *((unsigned char *)this + 528) = *(_DWORD *)a5 != 0;
          return result;
        }
        return 4294956419;
      }
    }
    return 4294956430;
  }
  if (a3) {
    return 4294956430;
  }
  if (a4) {
    return 4294956419;
  }
  if (*((unsigned char *)this + 17)) {
    return 4294956447;
  }
  CFTypeRef v7 = *a5;
  if (*a5)
  {
    CFRetain(*a5);
    CFTypeID v8 = CFGetTypeID(v7);
    if (v8 != CFDictionaryGetTypeID())
    {
      CFRelease(v7);
      CFTypeRef v7 = 0;
    }
  }
  uint64_t result = *((void *)this + 84);
  *((void *)this + 84) = v7;
  if (result)
  {
    CFRelease((CFTypeRef)result);
    return 0;
  }
  return result;
}

uint64_t AUReferenceSignalMixer::GetProperty(AUReferenceSignalMixer *this, int a2, int a3, int a4, _DWORD *a5)
{
  if (a2 != 1667655524)
  {
    if (a2 == 3700)
    {
      if (!a3)
      {
        if (!a4)
        {
          uint64_t result = 0;
          int v8 = *((unsigned __int8 *)this + 376);
          goto LABEL_18;
        }
        return 4294956419;
      }
    }
    else
    {
      if (a2 != 21) {
        return 4294956417;
      }
      if (!a3)
      {
        if (!a4)
        {
          uint64_t result = 0;
          int v8 = *((unsigned __int8 *)this + 528);
LABEL_18:
          *a5 = v8;
          return result;
        }
        return 4294956419;
      }
    }
    return 4294956430;
  }
  if (a3) {
    return 4294956430;
  }
  if (a4) {
    return 4294956419;
  }
  uint64_t v9 = *((void *)this + 84);
  if (v9) {
    CFRetain(*((CFTypeRef *)this + 84));
  }
  uint64_t result = 0;
  *(void *)a5 = v9;
  return result;
}

uint64_t AUReferenceSignalMixer::GetPropertyInfo(AUReferenceSignalMixer *this, int a2, int a3, int a4, unsigned int *a5, BOOL *a6)
{
  if (a2 == 1667655524)
  {
    if (!a3)
    {
      if (!a4)
      {
        uint64_t result = 0;
        *a5 = 8;
        *a6 = *((unsigned char *)this + 17) ^ 1;
        return result;
      }
      return 4294956419;
    }
    return 4294956430;
  }
  if (a2 == 3700)
  {
    if (!a3)
    {
      if (!a4)
      {
        uint64_t result = 0;
        char v8 = *((unsigned char *)this + 17) ^ 1;
        goto LABEL_16;
      }
      return 4294956419;
    }
    return 4294956430;
  }
  if (a2 != 21) {
    return 4294956417;
  }
  if (a3) {
    return 4294956430;
  }
  if (a4) {
    return 4294956419;
  }
  uint64_t result = 0;
  char v8 = 1;
LABEL_16:
  *a6 = v8;
  *a5 = 4;
  return result;
}

void AUReferenceSignalMixer::Cleanup(AUReferenceSignalMixer *this)
{
  if (*((void *)this + 81))
  {
    std::__hash_table<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::__unordered_map_hasher<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::hash<AU::ReferenceSignalMixer::Orientation>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,true>,std::__unordered_map_equal<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,std::hash<AU::ReferenceSignalMixer::Orientation>,true>,std::allocator<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>>>::__deallocate_node(*((void **)this + 80));
    *((void *)this + 80) = 0;
    uint64_t v2 = *((void *)this + 79);
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
        *(void *)(*((void *)this + 78) + 8 * i) = 0;
    }
    *((void *)this + 81) = 0;
  }
}

void std::__hash_table<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::__unordered_map_hasher<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::hash<AU::ReferenceSignalMixer::Orientation>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,true>,std::__unordered_map_equal<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,std::hash<AU::ReferenceSignalMixer::Orientation>,true>,std::allocator<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>>>::__deallocate_node(void *__p)
{
  if (__p)
  {
    uint64_t v1 = __p;
    do
    {
      uint64_t v2 = (void *)*v1;
      uint64_t v3 = (std::__shared_weak_count *)v1[4];
      if (v3) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v3);
      }
      operator delete(v1);
      uint64_t v1 = v2;
    }
    while (v2);
  }
}

uint64_t AUReferenceSignalMixer::Initialize(AUReferenceSignalMixer *this)
{
  uint64_t v384 = *MEMORY[0x1E4F143B8];
  {
    AU::ReferenceSignalMixer::getLog(void)::gLog = (uint64_t)os_log_create("com.apple.coreaudio", "AUReferenceSignalMixer");
  }
  uint64_t v1 = AU::ReferenceSignalMixer::getLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)AU::ReferenceSignalMixer::getLog(void)::gLog, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 134217984;
    *(void *)&uint8_t buf[4] = this;
    _os_log_impl(&dword_1BB0CE000, v1, OS_LOG_TYPE_INFO, "[%p] initialize", buf, 0xCu);
  }
  uint64_t v2 = (AUReferenceSignalMixer *)((char *)this + 80);
  *((_DWORD *)this + 133) = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUReferenceSignalMixer *)((char *)this + 80), 0)
                                      + 108);
  uint64_t v3 = (AUReferenceSignalMixer *)((char *)this + 128);
  *((_DWORD *)this + 142) = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUReferenceSignalMixer *)((char *)this + 128), 0)+ 108);
  CFDictionaryRef v4 = (const __CFDictionary *)*((void *)this + 84);
  if (!v4) {
    goto LABEL_747;
  }
  long long v376 = 0u;
  long long v377 = 0u;
  float v378 = 1.0;
  long long v374 = 0u;
  *(_OWORD *)std::string __p = 0u;
  float v375 = 1.0;
  CFStringRef v5 = CFStringCreateWithBytes(0, (const UInt8 *)"Configuration", 13, 0x8000100u, 0);
  *(void *)buf = v5;
  if (!v5)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  int v6 = CFDictionaryContainsKey(v4, v5);
  CFRelease(v5);
  if (!v6)
  {
    Log = AU::ReferenceSignalMixer::getLog(v7);
    if (os_log_type_enabled(Log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      *(void *)&uint8_t buf[4] = this;
      _os_log_error_impl(&dword_1BB0CE000, Log, OS_LOG_TYPE_ERROR, "[%p] AUReferenceSignal's property list has no \"Configurations\" key", buf, 0xCu);
    }
    uint64_t v327 = 4294956421;
    int v328 = 1;
    goto LABEL_746;
  }
  CFDictionaryRef v8 = (const __CFDictionary *)*((void *)this + 84);
  if (!v8)
  {
    v348 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v348, "Could not construct");
  }
  uint64_t v9 = applesauce::CF::details::at_key<char const(&)[14]>(v8, "Configuration");
  if (!v9) {
    goto LABEL_739;
  }
  CFTypeRef v10 = v9;
  CFRetain(v9);
  CFTypeID v11 = CFGetTypeID(v10);
  if (v11 != CFArrayGetTypeID())
  {
    CFRelease(v10);
LABEL_739:
    buf[0] = 0;
    buf[8] = 0;
    CFTypeRef v372 = 0;
    v325 = (AU::ReferenceSignalMixer *)std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)buf);
    long long v326 = AU::ReferenceSignalMixer::getLog(v325);
    if (!os_log_type_enabled(v326, OS_LOG_TYPE_ERROR))
    {
LABEL_740:
      uint64_t v327 = 4294956421;
      int v328 = 1;
      goto LABEL_744;
    }
    *(_DWORD *)buf = 134217984;
    *(void *)&uint8_t buf[4] = this;
    uint64_t v330 = "[%p] AUReferenceSignal's property list has invalid \"Configurations\" value";
    uint64_t v331 = v326;
    uint32_t v332 = 12;
LABEL_750:
    _os_log_error_impl(&dword_1BB0CE000, v331, OS_LOG_TYPE_ERROR, v330, buf, v332);
    goto LABEL_740;
  }
  *(void *)buf = v10;
  buf[8] = 1;
  CFRetain(v10);
  CFTypeRef v372 = v10;
  std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)buf);
  unint64_t v12 = 0;
  unsigned int v358 = 0;
  int v360 = 0;
  uint64_t v357 = (void *)((char *)this + 640);
  while (1)
  {
    if (CFArrayGetCount((CFArrayRef)v10) <= v12)
    {
      int v328 = 0;
      goto LABEL_743;
    }
    if (!v372)
    {
      v336 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v336, "Could not construct");
    }
    *(void *)buf = 0;
    applesauce::CF::at_or<applesauce::CF::DictionaryRef>(&v371, (CFArrayRef)v372, v12, buf);
    unint64_t v13 = *(AU::ReferenceSignalMixer **)buf;
    if (*(void *)buf) {
      CFRelease(*(CFTypeRef *)buf);
    }
    CFDictionaryRef v14 = (const __CFDictionary *)v371;
    if (!v371)
    {
      uint64_t v333 = AU::ReferenceSignalMixer::getLog(v13);
      if (!os_log_type_enabled(v333, OS_LOG_TYPE_ERROR)) {
        goto LABEL_740;
      }
      *(_DWORD *)buf = 134218240;
      *(void *)&uint8_t buf[4] = this;
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v360;
      uint64_t v330 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u] has invalid value";
      uint64_t v331 = v333;
      uint32_t v332 = 18;
      goto LABEL_750;
    }
    BOOL v15 = applesauce::CF::details::has_key<char const(&)[5]>((const __CFDictionary *)v371, "Name");
    if (!v15)
    {
      long long v302 = AU::ReferenceSignalMixer::getLog((AU::ReferenceSignalMixer *)v15);
      if (os_log_type_enabled(v302, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134218240;
        *(void *)&uint8_t buf[4] = this;
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v360;
        _os_log_error_impl(&dword_1BB0CE000, v302, OS_LOG_TYPE_ERROR, "[%p] AUReferenceSignal's property list \"Configurations\"[%u] has no \"Name\" key", buf, 0x12u);
      }
      int v29 = 1;
      unsigned int v358 = -10875;
      goto LABEL_283;
    }
    applesauce::CF::details::find_at_key_or_optional<applesauce::CF::StringRef,char const(&)[5]>(v14, "Name", buf);
    if (buf[8])
    {
      unint64_t v16 = *(const void **)buf;
      if (*(void *)buf) {
        CFRetain(*(CFTypeRef *)buf);
      }
      CFTypeRef v370 = v16;
    }
    else
    {
      CFTypeRef v370 = 0;
    }
    CFArrayRef v17 = (AU::ReferenceSignalMixer *)std::__optional_destruct_base<applesauce::CF::StringRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)buf);
    if (!v370)
    {
      unint64_t v303 = AU::ReferenceSignalMixer::getLog(v17);
      if (os_log_type_enabled(v303, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134218240;
        *(void *)&uint8_t buf[4] = this;
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v360;
        v310 = v303;
        unint64_t v311 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u] has invalid \"Name\" value";
        goto LABEL_712;
      }
      goto LABEL_689;
    }
    CFRetain(@"InputChannelCounts");
    CFTypeID v18 = CFGetTypeID(@"InputChannelCounts");
    if (v18 == CFStringGetTypeID())
    {
      BOOL v19 = applesauce::CF::details::has_key<applesauce::CF::StringRef>(v14, @"InputChannelCounts");
      CFRelease(@"InputChannelCounts");
      if (v19) {
        goto LABEL_27;
      }
    }
    else
    {
      CFRelease(@"InputChannelCounts");
      if (applesauce::CF::details::has_key<applesauce::CF::StringRef>(v14, 0))
      {
LABEL_27:
        CFRetain(@"InputChannelCounts");
        CFTypeID v20 = CFGetTypeID(@"InputChannelCounts");
        if (v20 == CFStringGetTypeID())
        {
          *(void *)buf = @"InputChannelCounts";
        }
        else
        {
          *(void *)buf = 0;
          CFRelease(@"InputChannelCounts");
        }
        cf[0] = 0;
        applesauce::CF::at_or<applesauce::CF::ArrayRef,applesauce::CF::StringRef>((const __CFDictionary **)&v379, v14, (const void **)buf, (const __CFDictionary **)cf);
        if (cf[0]) {
          CFRelease(cf[0]);
        }
        uint64_t v21 = *(AU::ReferenceSignalMixer **)buf;
        if (*(void *)buf) {
          CFRelease(*(CFTypeRef *)buf);
        }
        CFArrayRef begin = (const __CFArray *)v379.__begin_;
        if (v379.__begin_)
        {
          unint64_t v23 = 0;
          int v24 = 0;
          BOOL v25 = 0;
          while (1)
          {
            BOOL v26 = CFArrayGetCount(begin) <= v23;
            if (v26 || v25)
            {
              if (v26) {
                int v28 = 6;
              }
              else {
                int v28 = 7;
              }
              if (v25) {
                int v29 = 0;
              }
              else {
                int v29 = v28;
              }
              goto LABEL_46;
            }
            unint64_t v27 = applesauce::CF::details::at_as<unsigned int>(begin, v23);
            if ((v27 & 0xFF00000000) == 0) {
              break;
            }
            BOOL v25 = *(_DWORD *)(ausdk::AUScope::SafeGetElement(v2, 0) + 108) == v27;
            unint64_t v23 = ++v24;
          }
          {
            AU::ReferenceSignalMixer::getLog(void)::gLog = (uint64_t)os_log_create("com.apple.coreaudio", "AUReferenceSignalMixer");
          }
          uint64_t v168 = AU::ReferenceSignalMixer::getLog(void)::gLog;
          if (os_log_type_enabled((os_log_t)AU::ReferenceSignalMixer::getLog(void)::gLog, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 134218496;
            *(void *)&uint8_t buf[4] = this;
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v360;
            *(_WORD *)&unsigned char buf[18] = 1024;
            *(_DWORD *)&buf[20] = v24;
            _os_log_error_impl(&dword_1BB0CE000, v168, OS_LOG_TYPE_ERROR, "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"InputChannelCounts\"][%u] has invalid value", buf, 0x18u);
          }
          unsigned int v358 = -10875;
          int v29 = 1;
        }
        else
        {
          v304 = AU::ReferenceSignalMixer::getLog(v21);
          if (os_log_type_enabled(v304, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 134218240;
            *(void *)&uint8_t buf[4] = this;
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v360;
            _os_log_error_impl(&dword_1BB0CE000, v304, OS_LOG_TYPE_ERROR, "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"InputChannelCounts\"] has invalid value", buf, 0x12u);
          }
          unsigned int v358 = -10875;
          int v29 = 1;
        }
LABEL_46:
        if (v379.__begin_) {
          CFRelease(v379.__begin_);
        }
        if (v29) {
          goto LABEL_280;
        }
        CFDictionaryRef v14 = (const __CFDictionary *)v371;
        if (!v371)
        {
          v349 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(v349, "Could not construct");
        }
      }
    }
    CFRetain(@"InputChannelLayouts");
    CFTypeID v30 = CFGetTypeID(@"InputChannelLayouts");
    if (v30 == CFStringGetTypeID())
    {
      BOOL v31 = applesauce::CF::details::has_key<applesauce::CF::StringRef>(v14, @"InputChannelLayouts");
      CFRelease(@"InputChannelLayouts");
      if (!v31) {
        goto LABEL_134;
      }
    }
    else
    {
      CFRelease(@"InputChannelLayouts");
      if (!applesauce::CF::details::has_key<applesauce::CF::StringRef>(v14, 0)) {
        goto LABEL_134;
      }
    }
    uint64_t Element = ausdk::AUScope::SafeGetElement(v2, 0);
    AU::ReferenceSignalMixer::MakeDefaultChannelLayout(&v379, *(_DWORD *)(Element + 108));
    std::optional<CA::ChannelLayout>::value_or[abi:ne180100]<CA::ChannelLayout>((__n128 *)buf, (uint64_t)this + 536, (__n128 *)&v379);
    if (v379.__begin_)
    {
      v379.__end_ = v379.__begin_;
      operator delete(v379.__begin_);
    }
    CFRetain(@"InputChannelLayouts");
    CFTypeID v33 = CFGetTypeID(@"InputChannelLayouts");
    if (v33 == CFStringGetTypeID())
    {
      v379.__begin_ = (std::vector<char>::pointer)@"InputChannelLayouts";
    }
    else
    {
      v379.__begin_ = 0;
      CFRelease(@"InputChannelLayouts");
    }
    v366[0] = 0;
    applesauce::CF::at_or<applesauce::CF::ArrayRef,applesauce::CF::StringRef>((const __CFDictionary **)cf, v14, (const void **)&v379.__begin_, (const __CFDictionary **)v366);
    if (v366[0]) {
      CFRelease(v366[0]);
    }
    unint64_t v34 = (AU::ReferenceSignalMixer *)v379.__begin_;
    if (v379.__begin_) {
      CFRelease(v379.__begin_);
    }
    CFArrayRef v35 = (const __CFArray *)cf[0];
    if (!cf[0])
    {
      uint64_t v305 = AU::ReferenceSignalMixer::getLog(v34);
      if (os_log_type_enabled(v305, OS_LOG_TYPE_ERROR))
      {
        LODWORD(v379.__begin_) = 134218240;
        *(std::vector<char>::pointer *)((char *)&v379.__begin_ + 4) = (std::vector<char>::pointer)this;
        WORD2(v379.__end_) = 1024;
        *(_DWORD *)((char *)&v379.__end_ + 6) = v360;
        _os_log_error_impl(&dword_1BB0CE000, v305, OS_LOG_TYPE_ERROR, "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"InputChannelLayouts\"] has invalid value", (uint8_t *)&v379, 0x12u);
      }
      int v29 = 1;
      unsigned int v358 = -10875;
      goto LABEL_130;
    }
    unint64_t v36 = 0;
    int v37 = 0;
    LOBYTE(v38) = 0;
    while (1)
    {
      BOOL v39 = CFArrayGetCount(v35) <= v36 || v38;
      if (v39)
      {
        if (v38) {
          int v29 = 0;
        }
        else {
          int v29 = 6;
        }
LABEL_129:
        CFRelease(v35);
        goto LABEL_130;
      }
      v379.__begin_ = 0;
      applesauce::CF::at_or<applesauce::CF::DataRef>(v366, v35, v36, &v379);
      if (v379.__begin_) {
        CFRelease(v379.__begin_);
      }
      CFDataRef v40 = (const __CFData *)v366[0];
      if (!v366[0])
      {
        {
          AU::ReferenceSignalMixer::getLog(void)::gLog = (uint64_t)os_log_create("com.apple.coreaudio", "AUReferenceSignalMixer");
        }
        uint64_t v52 = AU::ReferenceSignalMixer::getLog(void)::gLog;
        if (!os_log_type_enabled((os_log_t)AU::ReferenceSignalMixer::getLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
          goto LABEL_110;
        }
        LODWORD(v379.__begin_) = 134218496;
        *(std::vector<char>::pointer *)((char *)&v379.__begin_ + 4) = (std::vector<char>::pointer)this;
        WORD2(v379.__end_) = 1024;
        *(_DWORD *)((char *)&v379.__end_ + 6) = v360;
        WORD1(v379.__end_cap_.__value_) = 1024;
        HIDWORD(v379.__end_cap_.__value_) = v37;
        uint64_t v53 = v52;
        float v54 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"InputChannelLayouts\"][%u] has invalid value";
        goto LABEL_112;
      }
      BytePtr = CFDataGetBytePtr((CFDataRef)v366[0]);
      unint64_t Length = CFDataGetLength(v40);
      if (Length <= 0x1F)
      {
        {
          AU::ReferenceSignalMixer::getLog(void)::gLog = (uint64_t)os_log_create("com.apple.coreaudio", "AUReferenceSignalMixer");
        }
        uint64_t v55 = AU::ReferenceSignalMixer::getLog(void)::gLog;
        if (!os_log_type_enabled((os_log_t)AU::ReferenceSignalMixer::getLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
          goto LABEL_110;
        }
        LODWORD(v379.__begin_) = 134218496;
        *(std::vector<char>::pointer *)((char *)&v379.__begin_ + 4) = (std::vector<char>::pointer)this;
        WORD2(v379.__end_) = 1024;
        *(_DWORD *)((char *)&v379.__end_ + 6) = v360;
        WORD1(v379.__end_cap_.__value_) = 1024;
        HIDWORD(v379.__end_cap_.__value_) = v37;
        uint64_t v53 = v55;
        float v54 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"InputChannelLayouts\"][%u] has insufficient byte size";
        goto LABEL_112;
      }
      unsigned int v43 = *((_DWORD *)BytePtr + 2);
      uint64_t v44 = 20 * (v43 - 1) + 32;
      if (v43 <= 1) {
        uint64_t v44 = 32;
      }
      if (Length == v44)
      {
        if (v43 <= 1) {
          unsigned int v43 = 1;
        }
        std::vector<char>::vector(&v379, 20 * v43 + 12);
        memcpy(v379.__begin_, BytePtr, 20 * *((unsigned int *)BytePtr + 2) + 12);
        int v45 = **(_DWORD **)buf;
        if (**(_DWORD **)buf == *(_DWORD *)v379.__begin_)
        {
          if (v45)
          {
            if (v45 == 0x10000)
            {
              BOOL v38 = *(_DWORD *)(*(void *)buf + 4) == *((_DWORD *)v379.__begin_ + 1);
LABEL_96:
              v379.__end_ = v379.__begin_;
              operator delete(v379.__begin_);
              int v51 = 1;
              goto LABEL_97;
            }
LABEL_95:
            BOOL v38 = 1;
            goto LABEL_96;
          }
          uint64_t v46 = *(unsigned int *)(*(void *)buf + 8);
          if (v46 == *((_DWORD *)v379.__begin_ + 2))
          {
            if (!v46) {
              goto LABEL_95;
            }
            std::vector<char>::pointer v47 = v379.__begin_ + 12;
            uint64_t v48 = *(void *)buf + 12;
            while (*(_DWORD *)v48 == *(_DWORD *)v47)
            {
              if (*(_DWORD *)v48 == 100)
              {
                BOOL v49 = *(void *)v48 == *(void *)v47 && *(void *)(v48 + 8) == *((void *)v47 + 1);
                if (!v49 || *(_DWORD *)(v48 + 16) != (unint64_t)*((unsigned int *)v47 + 4)) {
                  break;
                }
              }
              v47 += 20;
              v48 += 20;
              BOOL v38 = 1;
              if (!--v46) {
                goto LABEL_96;
              }
            }
          }
        }
        BOOL v38 = 0;
        goto LABEL_96;
      }
      {
        AU::ReferenceSignalMixer::getLog(void)::gLog = (uint64_t)os_log_create("com.apple.coreaudio", "AUReferenceSignalMixer");
      }
      uint64_t v56 = AU::ReferenceSignalMixer::getLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)AU::ReferenceSignalMixer::getLog(void)::gLog, OS_LOG_TYPE_ERROR))
      {
        LODWORD(v379.__begin_) = 134218496;
        *(std::vector<char>::pointer *)((char *)&v379.__begin_ + 4) = (std::vector<char>::pointer)this;
        WORD2(v379.__end_) = 1024;
        *(_DWORD *)((char *)&v379.__end_ + 6) = v360;
        WORD1(v379.__end_cap_.__value_) = 1024;
        HIDWORD(v379.__end_cap_.__value_) = v37;
        uint64_t v53 = v56;
        float v54 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"InputChannelLayouts\"][%u] has unexpected byte size";
LABEL_112:
        _os_log_error_impl(&dword_1BB0CE000, v53, OS_LOG_TYPE_ERROR, v54, (uint8_t *)&v379, 0x18u);
      }
LABEL_110:
      BOOL v38 = 0;
      int v51 = 0;
      unsigned int v358 = -10875;
LABEL_97:
      if (v366[0]) {
        CFRelease(v366[0]);
      }
      CFArrayRef v35 = (const __CFArray *)cf[0];
      if (!v51) {
        break;
      }
      unint64_t v36 = ++v37;
      if (!cf[0])
      {
        unint64_t v335 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v335, "Could not construct");
      }
    }
    if (v38) {
      int v57 = 0;
    }
    else {
      int v57 = 6;
    }
    if (v39) {
      int v29 = v57;
    }
    else {
      int v29 = 1;
    }
    if (cf[0]) {
      goto LABEL_129;
    }
LABEL_130:
    if (*(void *)buf)
    {
      *(void *)&buf[8] = *(void *)buf;
      operator delete(*(void **)buf);
    }
    if (v29) {
      goto LABEL_280;
    }
    CFDictionaryRef v14 = (const __CFDictionary *)v371;
    if (!v371)
    {
      long long v350 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v350, "Could not construct");
    }
LABEL_134:
    CFRetain(@"MinInputChannelCount");
    CFTypeID v58 = CFGetTypeID(@"MinInputChannelCount");
    if (v58 != CFStringGetTypeID())
    {
      CFRelease(@"MinInputChannelCount");
      if (!applesauce::CF::details::has_key<applesauce::CF::StringRef>(v14, 0)) {
        goto LABEL_146;
      }
LABEL_138:
      CFDictionaryRef v60 = (const __CFDictionary *)v371;
      if (!v371)
      {
        uint64_t v341 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v341, "Could not construct");
      }
      CFRetain(@"MinInputChannelCount");
      CFTypeID v61 = CFGetTypeID(@"MinInputChannelCount");
      if (v61 == CFStringGetTypeID())
      {
        *(void *)buf = @"MinInputChannelCount";
      }
      else
      {
        *(void *)buf = 0;
        CFRelease(@"MinInputChannelCount");
      }
      CFDictionaryRef v62 = applesauce::CF::DictionaryRef_proxy::at_as<unsigned int,applesauce::CF::StringRef>(v60, (const void **)buf);
      uint64_t v63 = *(AU::ReferenceSignalMixer **)buf;
      if (*(void *)buf) {
        CFRelease(*(CFTypeRef *)buf);
      }
      if (((unint64_t)v62 & 0xFF00000000) != 0)
      {
        if (*(_DWORD *)(ausdk::AUScope::SafeGetElement(v2, 0) + 108) >= v62) {
          goto LABEL_146;
        }
        goto LABEL_279;
      }
      uint64_t v309 = AU::ReferenceSignalMixer::getLog(v63);
      if (!os_log_type_enabled(v309, OS_LOG_TYPE_ERROR)) {
        goto LABEL_689;
      }
      *(_DWORD *)buf = 134218240;
      *(void *)&uint8_t buf[4] = this;
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v360;
      v310 = v309;
      unint64_t v311 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"MinInputChannelCount\"] has invalid value";
LABEL_712:
      _os_log_error_impl(&dword_1BB0CE000, v310, OS_LOG_TYPE_ERROR, v311, buf, 0x12u);
      goto LABEL_689;
    }
    BOOL v59 = applesauce::CF::details::has_key<applesauce::CF::StringRef>(v14, @"MinInputChannelCount");
    CFRelease(@"MinInputChannelCount");
    if (v59) {
      goto LABEL_138;
    }
LABEL_146:
    CFDictionaryRef v64 = (const __CFDictionary *)v371;
    if (!v371)
    {
      long long v338 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v338, "Could not construct");
    }
    CFRetain(@"MaxInputChannelCount");
    CFTypeID v65 = CFGetTypeID(@"MaxInputChannelCount");
    if (v65 != CFStringGetTypeID())
    {
      CFRelease(@"MaxInputChannelCount");
      if (!applesauce::CF::details::has_key<applesauce::CF::StringRef>(v64, 0)) {
        goto LABEL_158;
      }
LABEL_151:
      CFRetain(@"MaxInputChannelCount");
      CFTypeID v67 = CFGetTypeID(@"MaxInputChannelCount");
      if (v67 == CFStringGetTypeID())
      {
        *(void *)buf = @"MaxInputChannelCount";
      }
      else
      {
        *(void *)buf = 0;
        CFRelease(@"MaxInputChannelCount");
      }
      CFDictionaryRef v68 = applesauce::CF::DictionaryRef_proxy::at_as<unsigned int,applesauce::CF::StringRef>(v64, (const void **)buf);
      uint64_t v69 = *(AU::ReferenceSignalMixer **)buf;
      if (*(void *)buf) {
        CFRelease(*(CFTypeRef *)buf);
      }
      if (((unint64_t)v68 & 0xFF00000000) != 0)
      {
        if (*(_DWORD *)(ausdk::AUScope::SafeGetElement(v2, 0) + 108) <= v68) {
          goto LABEL_158;
        }
        goto LABEL_279;
      }
      v312 = AU::ReferenceSignalMixer::getLog(v69);
      if (!os_log_type_enabled(v312, OS_LOG_TYPE_ERROR)) {
        goto LABEL_689;
      }
      *(_DWORD *)buf = 134218240;
      *(void *)&uint8_t buf[4] = this;
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v360;
      v310 = v312;
      unint64_t v311 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"MaxInputChannelCount\"] has invalid value";
      goto LABEL_712;
    }
    BOOL v66 = applesauce::CF::details::has_key<applesauce::CF::StringRef>(v64, @"MaxInputChannelCount");
    CFRelease(@"MaxInputChannelCount");
    if (v66) {
      goto LABEL_151;
    }
LABEL_158:
    CFRetain(@"OutputChannelCounts");
    CFTypeID v70 = CFGetTypeID(@"OutputChannelCounts");
    if (v70 == CFStringGetTypeID())
    {
      BOOL v71 = applesauce::CF::details::has_key<applesauce::CF::StringRef>(v64, @"OutputChannelCounts");
      CFRelease(@"OutputChannelCounts");
      if (!v71) {
        goto LABEL_185;
      }
    }
    else
    {
      CFRelease(@"OutputChannelCounts");
      if (!applesauce::CF::details::has_key<applesauce::CF::StringRef>(v64, 0)) {
        goto LABEL_185;
      }
    }
    CFRetain(@"OutputChannelCounts");
    CFTypeID v72 = CFGetTypeID(@"OutputChannelCounts");
    if (v72 == CFStringGetTypeID())
    {
      *(void *)buf = @"OutputChannelCounts";
    }
    else
    {
      *(void *)buf = 0;
      CFRelease(@"OutputChannelCounts");
    }
    cf[0] = 0;
    applesauce::CF::at_or<applesauce::CF::ArrayRef,applesauce::CF::StringRef>((const __CFDictionary **)&v379, v64, (const void **)buf, (const __CFDictionary **)cf);
    if (cf[0]) {
      CFRelease(cf[0]);
    }
    uint64_t v73 = *(AU::ReferenceSignalMixer **)buf;
    if (*(void *)buf) {
      CFRelease(*(CFTypeRef *)buf);
    }
    CFArrayRef v74 = (const __CFArray *)v379.__begin_;
    if (v379.__begin_)
    {
      unint64_t v75 = 0;
      int v76 = 0;
      BOOL v77 = 0;
      while (1)
      {
        BOOL v78 = CFArrayGetCount(v74) <= v75;
        if (v78 || v77)
        {
          if (v78) {
            int v80 = 6;
          }
          else {
            int v80 = 13;
          }
          if (v77) {
            int v29 = 0;
          }
          else {
            int v29 = v80;
          }
          goto LABEL_181;
        }
        unint64_t v79 = applesauce::CF::details::at_as<unsigned int>(v74, v75);
        if ((v79 & 0xFF00000000) == 0) {
          break;
        }
        BOOL v77 = *(_DWORD *)(ausdk::AUScope::SafeGetElement(v3, 0) + 108) == v79;
        unint64_t v75 = ++v76;
      }
      {
        AU::ReferenceSignalMixer::getLog(void)::gLog = (uint64_t)os_log_create("com.apple.coreaudio", "AUReferenceSignalMixer");
      }
      uint64_t v191 = AU::ReferenceSignalMixer::getLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)AU::ReferenceSignalMixer::getLog(void)::gLog, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134218496;
        *(void *)&uint8_t buf[4] = this;
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v360;
        *(_WORD *)&unsigned char buf[18] = 1024;
        *(_DWORD *)&buf[20] = v76;
        uint64_t v306 = v191;
        uint64_t v307 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"OutputChannelCounts\"][%u] has invalid value";
        uint32_t v308 = 24;
        goto LABEL_697;
      }
    }
    else
    {
      v313 = AU::ReferenceSignalMixer::getLog(v73);
      if (os_log_type_enabled(v313, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134218240;
        *(void *)&uint8_t buf[4] = this;
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v360;
        uint64_t v306 = v313;
        uint64_t v307 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"OutputChannelCounts\"] has invalid value";
        uint32_t v308 = 18;
LABEL_697:
        _os_log_error_impl(&dword_1BB0CE000, v306, OS_LOG_TYPE_ERROR, v307, buf, v308);
      }
    }
    unsigned int v358 = -10875;
    int v29 = 1;
LABEL_181:
    if (v379.__begin_) {
      CFRelease(v379.__begin_);
    }
    if (v29) {
      goto LABEL_280;
    }
    CFDictionaryRef v64 = (const __CFDictionary *)v371;
    if (!v371)
    {
      unint64_t v351 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v351, "Could not construct");
    }
LABEL_185:
    CFRetain(@"OutputChannelLayouts");
    CFTypeID v81 = CFGetTypeID(@"OutputChannelLayouts");
    if (v81 == CFStringGetTypeID())
    {
      BOOL v82 = applesauce::CF::details::has_key<applesauce::CF::StringRef>(v64, @"OutputChannelLayouts");
      CFRelease(@"OutputChannelLayouts");
      if (!v82) {
        goto LABEL_257;
      }
    }
    else
    {
      CFRelease(@"OutputChannelLayouts");
      if (!applesauce::CF::details::has_key<applesauce::CF::StringRef>(v64, 0)) {
        goto LABEL_257;
      }
    }
    uint64_t v83 = ausdk::AUScope::SafeGetElement(v3, 0);
    AU::ReferenceSignalMixer::MakeDefaultChannelLayout(&v379, *(_DWORD *)(v83 + 108));
    std::optional<CA::ChannelLayout>::value_or[abi:ne180100]<CA::ChannelLayout>((__n128 *)buf, (uint64_t)this + 576, (__n128 *)&v379);
    if (v379.__begin_)
    {
      v379.__end_ = v379.__begin_;
      operator delete(v379.__begin_);
    }
    CFRetain(@"OutputChannelLayouts");
    CFTypeID v84 = CFGetTypeID(@"OutputChannelLayouts");
    if (v84 == CFStringGetTypeID())
    {
      v379.__begin_ = (std::vector<char>::pointer)@"OutputChannelLayouts";
    }
    else
    {
      v379.__begin_ = 0;
      CFRelease(@"OutputChannelLayouts");
    }
    v366[0] = 0;
    applesauce::CF::at_or<applesauce::CF::ArrayRef,applesauce::CF::StringRef>((const __CFDictionary **)cf, v64, (const void **)&v379.__begin_, (const __CFDictionary **)v366);
    if (v366[0]) {
      CFRelease(v366[0]);
    }
    float v85 = (AU::ReferenceSignalMixer *)v379.__begin_;
    if (v379.__begin_) {
      CFRelease(v379.__begin_);
    }
    CFArrayRef v86 = (const __CFArray *)cf[0];
    if (!cf[0])
    {
      long long v314 = AU::ReferenceSignalMixer::getLog(v85);
      if (os_log_type_enabled(v314, OS_LOG_TYPE_ERROR))
      {
        LODWORD(v379.__begin_) = 134218240;
        *(std::vector<char>::pointer *)((char *)&v379.__begin_ + 4) = (std::vector<char>::pointer)this;
        WORD2(v379.__end_) = 1024;
        *(_DWORD *)((char *)&v379.__end_ + 6) = v360;
        _os_log_error_impl(&dword_1BB0CE000, v314, OS_LOG_TYPE_ERROR, "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"OutputChannelLayouts\"] has invalid value", (uint8_t *)&v379, 0x12u);
      }
      int v29 = 1;
      unsigned int v358 = -10875;
      goto LABEL_254;
    }
    unint64_t v87 = 0;
    int v88 = 0;
    BOOL v89 = 0;
    while (2)
    {
      BOOL v90 = CFArrayGetCount(v86) <= v87 || v89;
      if (v90)
      {
        int v119 = 16;
        goto LABEL_246;
      }
      v379.__begin_ = 0;
      applesauce::CF::at_or<applesauce::CF::DataRef>(v366, v86, v87, &v379);
      uint64_t v91 = (AU::ReferenceSignalMixer *)v379.__begin_;
      if (v379.__begin_) {
        CFRelease(v379.__begin_);
      }
      CFDataRef v92 = (const __CFData *)v366[0];
      if (v366[0])
      {
        uint64_t v93 = CFDataGetBytePtr((CFDataRef)v366[0]);
        float v94 = (AU::ReferenceSignalMixer *)CFDataGetLength(v92);
        if ((unint64_t)v94 <= 0x1F)
        {
          uint64_t v115 = AU::ReferenceSignalMixer::getLog(v94);
          if (!os_log_type_enabled(v115, OS_LOG_TYPE_ERROR)) {
            goto LABEL_241;
          }
          LODWORD(v379.__begin_) = 134218496;
          *(std::vector<char>::pointer *)((char *)&v379.__begin_ + 4) = (std::vector<char>::pointer)this;
          WORD2(v379.__end_) = 1024;
          *(_DWORD *)((char *)&v379.__end_ + 6) = v360;
          WORD1(v379.__end_cap_.__value_) = 1024;
          HIDWORD(v379.__end_cap_.__value_) = v88;
          unint64_t v116 = v115;
          uint64_t v117 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"OutputChannelLayouts\"][%u] has insufficient byte size";
        }
        else
        {
          unsigned int v95 = *((_DWORD *)v93 + 2);
          uint64_t v96 = 20 * (v95 - 1) + 32;
          if (v95 <= 1) {
            uint64_t v96 = 32;
          }
          if (v94 == (AU::ReferenceSignalMixer *)v96)
          {
            if (v95 <= 1) {
              unsigned int v95 = 1;
            }
            std::vector<char>::vector(&v379, 20 * v95 + 12);
            memcpy(v379.__begin_, v93, 20 * *((unsigned int *)v93 + 2) + 12);
            int v97 = **(_DWORD **)buf;
            if (**(_DWORD **)buf == *(_DWORD *)v379.__begin_)
            {
              if (v97)
              {
                if (v97 == 0x10000)
                {
                  BOOL v89 = *(_DWORD *)(*(void *)buf + 4) == *((_DWORD *)v379.__begin_ + 1);
                  goto LABEL_231;
                }
LABEL_230:
                BOOL v89 = 1;
LABEL_231:
                v379.__end_ = v379.__begin_;
                operator delete(v379.__begin_);
LABEL_232:
                int v114 = 1;
LABEL_233:
                CFRelease(v92);
                if (v114)
                {
LABEL_234:
                  unint64_t v87 = ++v88;
                  continue;
                }
                int v119 = 1;
LABEL_246:
                if (v89) {
                  int v120 = 0;
                }
                else {
                  int v120 = 6;
                }
                goto LABEL_249;
              }
              uint64_t v98 = *(unsigned int *)(*(void *)buf + 8);
              if (v98 == *((_DWORD *)v379.__begin_ + 2))
              {
                if (!v98) {
                  goto LABEL_230;
                }
                uint64_t v99 = 0;
                uint64_t v100 = 20 * v98;
                std::vector<char>::pointer v101 = v379.__begin_ + 12;
                uint64_t v102 = *(void *)buf + 12;
                while (1)
                {
                  uint64_t v103 = (uint64_t *)(v102 + v99);
                  unint64_t v104 = &v101[v99];
                  int v105 = *(_DWORD *)(v102 + v99);
                  if (v105 != *(_DWORD *)&v101[v99]) {
                    break;
                  }
                  if (v105 == 100)
                  {
                    uint64_t v106 = *v103;
                    uint64_t v107 = v103[1];
                    uint64_t v108 = *(void *)v104;
                    uint64_t v109 = *((void *)v104 + 1);
                    uint64_t v110 = *((unsigned int *)v103 + 4);
                    uint64_t v111 = *((unsigned int *)v104 + 4);
                    BOOL v112 = v106 == v108 && v107 == v109;
                    if (!v112 || v110 != v111) {
                      break;
                    }
                  }
                  v99 += 20;
                  if (v100 == v99)
                  {
                    BOOL v89 = 1;
                    goto LABEL_236;
                  }
                }
                BOOL v89 = 0;
LABEL_236:
                v379.__end_ = v379.__begin_;
                operator delete(v379.__begin_);
                if (v92) {
                  goto LABEL_232;
                }
                goto LABEL_234;
              }
            }
            BOOL v89 = 0;
            goto LABEL_231;
          }
          float v118 = AU::ReferenceSignalMixer::getLog(v94);
          if (!os_log_type_enabled(v118, OS_LOG_TYPE_ERROR))
          {
LABEL_241:
            int v114 = 0;
            BOOL v89 = 0;
            unsigned int v358 = -10875;
            goto LABEL_233;
          }
          LODWORD(v379.__begin_) = 134218496;
          *(std::vector<char>::pointer *)((char *)&v379.__begin_ + 4) = (std::vector<char>::pointer)this;
          WORD2(v379.__end_) = 1024;
          *(_DWORD *)((char *)&v379.__end_ + 6) = v360;
          WORD1(v379.__end_cap_.__value_) = 1024;
          HIDWORD(v379.__end_cap_.__value_) = v88;
          unint64_t v116 = v118;
          uint64_t v117 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"OutputChannelLayouts\"][%u] has unexpected byte size";
        }
        _os_log_error_impl(&dword_1BB0CE000, v116, OS_LOG_TYPE_ERROR, v117, (uint8_t *)&v379, 0x18u);
        goto LABEL_241;
      }
      break;
    }
    v300 = AU::ReferenceSignalMixer::getLog(v91);
    if (os_log_type_enabled(v300, OS_LOG_TYPE_ERROR))
    {
      LODWORD(v379.__begin_) = 134218496;
      *(std::vector<char>::pointer *)((char *)&v379.__begin_ + 4) = (std::vector<char>::pointer)this;
      WORD2(v379.__end_) = 1024;
      *(_DWORD *)((char *)&v379.__end_ + 6) = v360;
      WORD1(v379.__end_cap_.__value_) = 1024;
      HIDWORD(v379.__end_cap_.__value_) = v88;
      _os_log_error_impl(&dword_1BB0CE000, v300, OS_LOG_TYPE_ERROR, "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"OutputChannelLayouts\"][%u] has invalid value", (uint8_t *)&v379, 0x18u);
    }
    int v120 = 6;
    int v119 = 1;
    unsigned int v358 = -10875;
LABEL_249:
    if (v90) {
      int v29 = v120;
    }
    else {
      int v29 = v119;
    }
    if (v86) {
      CFRelease(v86);
    }
LABEL_254:
    if (*(void *)buf)
    {
      *(void *)&buf[8] = *(void *)buf;
      operator delete(*(void **)buf);
    }
    if (v29) {
      goto LABEL_280;
    }
LABEL_257:
    CFRetain(@"MinOutputChannelCount");
    CFTypeID v121 = CFGetTypeID(@"MinOutputChannelCount");
    if (v121 != CFStringGetTypeID())
    {
      CFRelease(@"MinOutputChannelCount");
      if (!applesauce::CF::details::has_key<applesauce::CF::StringRef>(v64, 0)) {
        goto LABEL_268;
      }
LABEL_261:
      CFRetain(@"MinOutputChannelCount");
      CFTypeID v123 = CFGetTypeID(@"MinOutputChannelCount");
      if (v123 == CFStringGetTypeID())
      {
        *(void *)buf = @"MinOutputChannelCount";
      }
      else
      {
        *(void *)buf = 0;
        CFRelease(@"MinOutputChannelCount");
      }
      CFDictionaryRef v124 = applesauce::CF::DictionaryRef_proxy::at_as<unsigned int,applesauce::CF::StringRef>(v64, (const void **)buf);
      uint64_t v125 = *(AU::ReferenceSignalMixer **)buf;
      if (*(void *)buf) {
        CFRelease(*(CFTypeRef *)buf);
      }
      if (((unint64_t)v124 & 0xFF00000000) == 0)
      {
        v316 = AU::ReferenceSignalMixer::getLog(v125);
        if (os_log_type_enabled(v316, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 134218240;
          *(void *)&uint8_t buf[4] = this;
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v360;
          v310 = v316;
          unint64_t v311 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"MinOutputChannelCount\"] has invalid value";
          goto LABEL_712;
        }
        goto LABEL_689;
      }
      if (*(_DWORD *)(ausdk::AUScope::SafeGetElement(v3, 0) + 108) >= v124) {
        goto LABEL_268;
      }
LABEL_279:
      int v29 = 6;
      goto LABEL_280;
    }
    BOOL v122 = applesauce::CF::details::has_key<applesauce::CF::StringRef>(v64, @"MinOutputChannelCount");
    CFRelease(@"MinOutputChannelCount");
    if (v122) {
      goto LABEL_261;
    }
LABEL_268:
    CFRetain(@"MaxOutputChannelCount");
    CFTypeID v126 = CFGetTypeID(@"MaxOutputChannelCount");
    if (v126 != CFStringGetTypeID())
    {
      CFRelease(@"MaxOutputChannelCount");
      if (!applesauce::CF::details::has_key<applesauce::CF::StringRef>(v64, 0)) {
        goto LABEL_288;
      }
LABEL_272:
      CFRetain(@"MaxOutputChannelCount");
      CFTypeID v128 = CFGetTypeID(@"MaxOutputChannelCount");
      if (v128 == CFStringGetTypeID())
      {
        *(void *)buf = @"MaxOutputChannelCount";
      }
      else
      {
        *(void *)buf = 0;
        CFRelease(@"MaxOutputChannelCount");
      }
      CFDictionaryRef v129 = applesauce::CF::DictionaryRef_proxy::at_as<unsigned int,applesauce::CF::StringRef>(v64, (const void **)buf);
      int v130 = *(AU::ReferenceSignalMixer **)buf;
      if (*(void *)buf) {
        CFRelease(*(CFTypeRef *)buf);
      }
      if (((unint64_t)v129 & 0xFF00000000) == 0)
      {
        uint64_t v317 = AU::ReferenceSignalMixer::getLog(v130);
        if (!os_log_type_enabled(v317, OS_LOG_TYPE_ERROR)) {
          goto LABEL_689;
        }
        *(_DWORD *)buf = 134218240;
        *(void *)&uint8_t buf[4] = this;
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v360;
        v310 = v317;
        unint64_t v311 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"MaxOutputChannelCount\"] has invalid value";
        goto LABEL_712;
      }
      if (*(_DWORD *)(ausdk::AUScope::SafeGetElement(v3, 0) + 108) <= v129) {
        goto LABEL_288;
      }
      goto LABEL_279;
    }
    BOOL v127 = applesauce::CF::details::has_key<applesauce::CF::StringRef>(v64, @"MaxOutputChannelCount");
    CFRelease(@"MaxOutputChannelCount");
    if (v127) {
      goto LABEL_272;
    }
LABEL_288:
    BOOL v131 = applesauce::CF::details::has_key<char const(&)[6]>(v64, "Gains");
    if (!v131)
    {
      unint64_t v315 = AU::ReferenceSignalMixer::getLog((AU::ReferenceSignalMixer *)v131);
      if (os_log_type_enabled(v315, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134218240;
        *(void *)&uint8_t buf[4] = this;
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v360;
        v310 = v315;
        unint64_t v311 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u] has no \"Gains\" key";
        goto LABEL_712;
      }
LABEL_689:
      unsigned int v358 = -10875;
      int v29 = 1;
      goto LABEL_280;
    }
    uint64_t v132 = applesauce::CF::details::at_key<char const(&)[6]>(v64, "Gains");
    if (!v132) {
      goto LABEL_336;
    }
    CFTypeRef v133 = v132;
    CFRetain(v132);
    CFTypeID v134 = CFGetTypeID(v133);
    if (v134 != CFArrayGetTypeID())
    {
      CFRelease(v133);
LABEL_336:
      buf[0] = 0;
      buf[8] = 0;
      CFTypeRef v369 = 0;
      unint64_t v164 = (AU::ReferenceSignalMixer *)std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)buf);
      uint64_t v165 = AU::ReferenceSignalMixer::getLog(v164);
      if (os_log_type_enabled(v165, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134218240;
        *(void *)&uint8_t buf[4] = this;
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v360;
        _os_log_error_impl(&dword_1BB0CE000, v165, OS_LOG_TYPE_ERROR, "[%p] AUReferenceSignal's property list \"Configurations\"[%u] has invalid \"Gains\" value", buf, 0x12u);
      }
      int v29 = 1;
      unsigned int v358 = -10875;
      goto LABEL_280;
    }
    *(void *)buf = v133;
    buf[8] = 1;
    CFRetain(v133);
    CFTypeRef v369 = v133;
    std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)buf);
    unint64_t v135 = (char *)operator new(0x38uLL);
    *(_OWORD *)(v135 + 8) = 0u;
    *(void *)unint64_t v135 = &unk_1F14AC5A0;
    unint64_t v136 = *((unsigned int *)this + 133);
    unint64_t v137 = *((unsigned int *)this + 142);
    *((void *)v135 + 3) = &unk_1F14AC578;
    *((void *)v135 + 4) = 0;
    *(_OWORD *)(v135 + 40) = 0u;
    LODWORD(cf[0]) = 0;
    std::vector<float>::vector(buf, v136, cf);
    std::vector<std::vector<float>>::resize((uint64_t *)v135 + 4, v137, (uint64_t)buf);
    if (*(void *)buf)
    {
      *(void *)&buf[8] = *(void *)buf;
      operator delete(*(void **)buf);
    }
    unint64_t v138 = 0;
    unint64_t v139 = 0;
    *(void *)&long long v140 = v135 + 24;
    *((void *)&v140 + 1) = v135;
    long long v355 = v140;
    while (CFArrayGetCount((CFArrayRef)v133) > v138)
    {
      CFTypeRef v133 = v369;
      if (!v369)
      {
        unint64_t v339 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v339, "Could not construct");
      }
      *(void *)buf = 0;
      applesauce::CF::at_or<applesauce::CF::DictionaryRef>(&v379, (CFArrayRef)v369, v138, buf);
      if (*(void *)buf) {
        CFRelease(*(CFTypeRef *)buf);
      }
      if (!v379.__begin_)
      {
        long long v158 = AU::ReferenceSignalMixer::getLog(0);
        if (os_log_type_enabled(v158, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 134218496;
          *(void *)&uint8_t buf[4] = this;
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v360;
          *(_WORD *)&unsigned char buf[18] = 1024;
          *(_DWORD *)&buf[20] = v139;
          uint64_t v156 = v158;
          float v157 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"Gains\"][%u] has invalid value";
          goto LABEL_322;
        }
LABEL_316:
        char v154 = 0;
        unsigned int v358 = -10875;
        goto LABEL_317;
      }
      BOOL v141 = applesauce::CF::details::has_key<char const(&)[6]>((const __CFDictionary *)v379.__begin_, "Input");
      if (!v141)
      {
        unint64_t v159 = AU::ReferenceSignalMixer::getLog((AU::ReferenceSignalMixer *)v141);
        if (!os_log_type_enabled(v159, OS_LOG_TYPE_ERROR)) {
          goto LABEL_316;
        }
        *(_DWORD *)buf = 134218496;
        *(void *)&uint8_t buf[4] = this;
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v360;
        *(_WORD *)&unsigned char buf[18] = 1024;
        *(_DWORD *)&buf[20] = v139;
        uint64_t v156 = v159;
        float v157 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"Gains\"][%u] has no \"Input\" key";
        goto LABEL_322;
      }
      if (!v379.__begin_)
      {
        v340 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v340, "Could not construct");
      }
      uint64_t v142 = (uint64_t)applesauce::CF::details::at_key<char const(&)[6]>((const __CFDictionary *)v379.__begin_, "Input");
      if (!v142
        || (uint64_t v142 = applesauce::CF::convert_as<unsigned int,0>((const __CFNumber *)v142), (v142 & 0xFF00000000) == 0))
      {
        unint64_t v155 = AU::ReferenceSignalMixer::getLog((AU::ReferenceSignalMixer *)v142);
        if (os_log_type_enabled(v155, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 134218496;
          *(void *)&uint8_t buf[4] = this;
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v360;
          *(_WORD *)&unsigned char buf[18] = 1024;
          *(_DWORD *)&buf[20] = v139;
          uint64_t v156 = v155;
          float v157 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"Gains\"][%u][\"Input\"] has invalid value";
          goto LABEL_322;
        }
        goto LABEL_316;
      }
      CFDictionaryRef v143 = (const __CFDictionary *)v379.__begin_;
      if (!v379.__begin_)
      {
        uint64_t v343 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v343, "Could not construct");
      }
      unsigned int v144 = v142;
      CFStringRef v145 = CFStringCreateWithBytes(0, (const UInt8 *)"Output", 6, 0x8000100u, 0);
      *(void *)buf = v145;
      if (!v145)
      {
        uint64_t v342 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v342, "Could not construct");
      }
      int v146 = CFDictionaryContainsKey(v143, v145);
      CFRelease(v145);
      if (!v146)
      {
        vDSP_Length v160 = AU::ReferenceSignalMixer::getLog(v147);
        if (!os_log_type_enabled(v160, OS_LOG_TYPE_ERROR)) {
          goto LABEL_316;
        }
        *(_DWORD *)buf = 134218496;
        *(void *)&uint8_t buf[4] = this;
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v360;
        *(_WORD *)&unsigned char buf[18] = 1024;
        *(_DWORD *)&buf[20] = v139;
        uint64_t v156 = v160;
        float v157 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"Gains\"][%u] has no \"Output\" key";
        goto LABEL_322;
      }
      if (!v379.__begin_)
      {
        unint64_t v344 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v344, "Could not construct");
      }
      *(void *)buf = &v379;
      BOOL v148 = applesauce::CF::DictionaryRef_proxy::at_as<unsigned int,char const(&)[7]>((const __CFDictionary ***)buf, "Output");
      if (((unint64_t)v148 & 0xFF00000000) == 0)
      {
        uint64_t v161 = AU::ReferenceSignalMixer::getLog(v148);
        if (!os_log_type_enabled(v161, OS_LOG_TYPE_ERROR)) {
          goto LABEL_316;
        }
        *(_DWORD *)buf = 134218496;
        *(void *)&uint8_t buf[4] = this;
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v360;
        *(_WORD *)&unsigned char buf[18] = 1024;
        *(_DWORD *)&buf[20] = v139;
        uint64_t v156 = v161;
        float v157 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"Gains\"][%u][\"Output\"] has invalid value";
        goto LABEL_322;
      }
      unsigned int v149 = v148;
      if (!v379.__begin_)
      {
        uint64_t v345 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v345, "Could not construct");
      }
      BOOL v150 = applesauce::CF::details::has_key<char const(&)[5]>((const __CFDictionary *)v379.__begin_, "Gain");
      if (!v150)
      {
        uint64_t v162 = AU::ReferenceSignalMixer::getLog((AU::ReferenceSignalMixer *)v150);
        if (!os_log_type_enabled(v162, OS_LOG_TYPE_ERROR)) {
          goto LABEL_316;
        }
        *(_DWORD *)buf = 134218496;
        *(void *)&uint8_t buf[4] = this;
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v360;
        *(_WORD *)&unsigned char buf[18] = 1024;
        *(_DWORD *)&buf[20] = v139;
        uint64_t v156 = v162;
        float v157 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"Gains\"][%u] has no \"Gain\" key";
        goto LABEL_322;
      }
      if (!v379.__begin_)
      {
        v346 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v346, "Could not construct");
      }
      uint64_t v151 = applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[5]>((const __CFDictionary *)v379.__begin_, "Gain");
      if (((unint64_t)v151 & 0xFF00000000) == 0)
      {
        uint64_t v163 = AU::ReferenceSignalMixer::getLog(v151);
        if (!os_log_type_enabled(v163, OS_LOG_TYPE_ERROR)) {
          goto LABEL_316;
        }
        *(_DWORD *)buf = 134218496;
        *(void *)&uint8_t buf[4] = this;
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v360;
        *(_WORD *)&unsigned char buf[18] = 1024;
        *(_DWORD *)&buf[20] = v139;
        uint64_t v156 = v163;
        float v157 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"Gains\"][%u][\"Gain\"] has invalid value";
LABEL_322:
        _os_log_error_impl(&dword_1BB0CE000, v156, OS_LOG_TYPE_ERROR, v157, buf, 0x18u);
        goto LABEL_316;
      }
      uint64_t v152 = *((void *)v135 + 4);
      if (0xAAAAAAAAAAAAAAABLL * ((*((void *)v135 + 5) - v152) >> 3) <= v149) {
        std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
      }
      uint64_t v153 = (void *)(v152 + 24 * v149);
      if (v144 >= (unint64_t)((uint64_t)(v153[1] - *v153) >> 2)) {
        std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
      }
      *(_DWORD *)(*v153 + 4 * v144) = v151;
      char v154 = 1;
LABEL_317:
      if (v379.__begin_) {
        CFRelease(v379.__begin_);
      }
      if ((v154 & 1) == 0)
      {
        int v29 = 1;
        unint64_t v167 = (std::__shared_weak_count *)*((void *)&v355 + 1);
        goto LABEL_669;
      }
      unint64_t v138 = (v139 + 1);
      unint64_t v139 = v138;
    }
    if (v370) {
      CFHashCode v166 = CFHash(v370);
    }
    else {
      CFHashCode v166 = 0xD7C06285B9DE677ALL;
    }
    unint64_t v169 = *((void *)&v376 + 1);
    if (*((void *)&v376 + 1))
    {
      uint8x8_t v170 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v376 + 8));
      v170.i16[0] = vaddlv_u8(v170);
      unint64_t v171 = v170.u32[0];
      if (v170.u32[0] > 1uLL)
      {
        unint64_t v139 = v166;
        if (v166 >= *((void *)&v376 + 1)) {
          unint64_t v139 = v166 % *((void *)&v376 + 1);
        }
      }
      else
      {
        unint64_t v139 = (*((void *)&v376 + 1) - 1) & v166;
      }
      vDSP_Length v172 = *(uint64_t ***)(v376 + 8 * v139);
      if (v172)
      {
        for (uint64_t i = *v172; i; uint64_t i = (uint64_t *)*i)
        {
          unint64_t v174 = i[1];
          if (v174 == v166)
          {
            if (applesauce::CF::compare<applesauce::CF::StringRef,0,applesauce::CF::StringRef,0>((CFTypeRef *)i + 2, (const __CFString **)&v370) == kCFCompareEqualTo)goto LABEL_424; {
          }
            }
          else
          {
            if (v171 > 1)
            {
              if (v174 >= v169) {
                v174 %= v169;
              }
            }
            else
            {
              v174 &= v169 - 1;
            }
            if (v174 != v139) {
              break;
            }
          }
        }
      }
    }
    uint64_t v175 = operator new(0x28uLL);
    *(void *)buf = v175;
    *(void *)&buf[8] = &v377;
    void *v175 = 0;
    v175[1] = v166;
    CFTypeRef v176 = v370;
    if (v370) {
      CFRetain(v370);
    }
    v175[3] = 0;
    v175[4] = 0;
    v175[2] = v176;
    buf[16] = 1;
    float v177 = (float)(unint64_t)(*((void *)&v377 + 1) + 1);
    if (!v169 || (float)(v378 * (float)v169) < v177)
    {
      BOOL v178 = (v169 & (v169 - 1)) != 0;
      if (v169 < 3) {
        BOOL v178 = 1;
      }
      unint64_t v179 = v178 | (2 * v169);
      unint64_t v180 = vcvtps_u32_f32(v177 / v378);
      if (v179 <= v180) {
        int8x8_t prime = (int8x8_t)v180;
      }
      else {
        int8x8_t prime = (int8x8_t)v179;
      }
      if (*(void *)&prime == 1)
      {
        int8x8_t prime = (int8x8_t)2;
      }
      else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
      {
        int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      }
      unint64_t v169 = *((void *)&v376 + 1);
      if (*(void *)&prime <= *((void *)&v376 + 1))
      {
        if (*(void *)&prime < *((void *)&v376 + 1))
        {
          unint64_t v188 = vcvtps_u32_f32((float)*((unint64_t *)&v377 + 1) / v378);
          if (*((void *)&v376 + 1) < 3uLL
            || (uint8x8_t v189 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v376 + 8)),
                v189.i16[0] = vaddlv_u8(v189),
                v189.u32[0] > 1uLL))
          {
            unint64_t v188 = std::__next_prime(v188);
          }
          else
          {
            uint64_t v190 = 1 << -(char)__clz(v188 - 1);
            if (v188 >= 2) {
              unint64_t v188 = v190;
            }
          }
          if (*(void *)&prime <= v188) {
            int8x8_t prime = (int8x8_t)v188;
          }
          if (*(void *)&prime >= v169)
          {
            unint64_t v169 = *((void *)&v376 + 1);
          }
          else
          {
            if (prime) {
              goto LABEL_377;
            }
            long long v301 = (void *)v376;
            *(void *)&long long v376 = 0;
            if (v301) {
              operator delete(v301);
            }
            unint64_t v169 = 0;
            *((void *)&v376 + 1) = 0;
          }
        }
      }
      else
      {
LABEL_377:
        if (*(void *)&prime >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        long long v182 = operator new(8 * *(void *)&prime);
        unint64_t v183 = (void *)v376;
        *(void *)&long long v376 = v182;
        if (v183) {
          operator delete(v183);
        }
        uint64_t v184 = 0;
        *((int8x8_t *)&v376 + 1) = prime;
        do
          *(void *)(v376 + 8 * v184++) = 0;
        while (*(void *)&prime != v184);
        uint64_t v185 = (void **)v377;
        if ((void)v377)
        {
          unint64_t v186 = *(void *)(v377 + 8);
          uint8x8_t v187 = (uint8x8_t)vcnt_s8(prime);
          v187.i16[0] = vaddlv_u8(v187);
          if (v187.u32[0] > 1uLL)
          {
            if (v186 >= *(void *)&prime) {
              v186 %= *(void *)&prime;
            }
          }
          else
          {
            v186 &= *(void *)&prime - 1;
          }
          *(void *)(v376 + 8 * v186) = &v377;
          for (uint64_t j = *v185; j; v186 = v193)
          {
            unint64_t v193 = j[1];
            if (v187.u32[0] > 1uLL)
            {
              if (v193 >= *(void *)&prime) {
                v193 %= *(void *)&prime;
              }
            }
            else
            {
              v193 &= *(void *)&prime - 1;
            }
            if (v193 != v186)
            {
              if (!*(void *)(v376 + 8 * v193))
              {
                *(void *)(v376 + 8 * v193) = v185;
                goto LABEL_405;
              }
              ausdk::AUElement *v185 = (void *)*j;
              *uint64_t j = **(void **)(v376 + 8 * v193);
              **(void **)(v376 + 8 * v193) = j;
              uint64_t j = v185;
            }
            unint64_t v193 = v186;
LABEL_405:
            uint64_t v185 = (void **)j;
            uint64_t j = (void *)*j;
          }
        }
        unint64_t v169 = (unint64_t)prime;
      }
      if ((v169 & (v169 - 1)) != 0)
      {
        if (v166 >= v169) {
          unint64_t v139 = v166 % v169;
        }
        else {
          unint64_t v139 = v166;
        }
      }
      else
      {
        unint64_t v139 = (v169 - 1) & v166;
      }
    }
    long long v194 = *(void **)(v376 + 8 * v139);
    uint64_t i = *(uint64_t **)buf;
    if (v194)
    {
      **(void **)buf = *v194;
      goto LABEL_422;
    }
    **(void **)buf = v377;
    *(void *)&long long v377 = i;
    *(void *)(v376 + 8 * v139) = &v377;
    if (*i)
    {
      unint64_t v195 = *(void *)(*i + 8);
      if ((v169 & (v169 - 1)) != 0)
      {
        if (v195 >= v169) {
          v195 %= v169;
        }
      }
      else
      {
        v195 &= v169 - 1;
      }
      long long v194 = (void *)(v376 + 8 * v195);
LABEL_422:
      *long long v194 = i;
    }
    *(void *)buf = 0;
    ++*((void *)&v377 + 1);
    std::unique_ptr<std::__hash_node<std::__hash_value_type<applesauce::CF::StringRef,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<applesauce::CF::StringRef,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,void *>>>>::reset[abi:ne180100]((uint64_t)buf);
LABEL_424:
    vDSP_Length v196 = (std::__shared_weak_count *)i[4];
    *(_OWORD *)(i + 3) = v355;
    if (v196) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v196);
    }
    CFDictionaryRef v197 = (const __CFDictionary *)v371;
    if (!v371)
    {
      uint64_t v354 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v354, "Could not construct");
    }
    BOOL v198 = applesauce::CF::details::has_key<char const(&)[13]>((const __CFDictionary *)v371, "Orientations");
    if (!v198)
    {
      uint64_t v319 = AU::ReferenceSignalMixer::getLog((AU::ReferenceSignalMixer *)v198);
      if (os_log_type_enabled(v319, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134218240;
        *(void *)&uint8_t buf[4] = this;
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v360;
        _os_log_error_impl(&dword_1BB0CE000, v319, OS_LOG_TYPE_ERROR, "[%p] AUReferenceSignal's property list \"Configurations\"[%u] has no \"Orientations\" key", buf, 0x12u);
      }
      unsigned int v358 = -10875;
      int v29 = 1;
      goto LABEL_668;
    }
    CFArrayRef v199 = (const __CFArray *)applesauce::CF::details::at_key<char const(&)[13]>(v197, "Orientations");
    if (!v199) {
      goto LABEL_553;
    }
    CFArrayRef v200 = v199;
    CFRetain(v199);
    CFTypeID v201 = CFGetTypeID(v200);
    if (v201 != CFArrayGetTypeID())
    {
      CFRelease(v200);
LABEL_553:
      buf[0] = 0;
      buf[8] = 0;
      CFArrayRef theArray = 0;
      unint64_t v255 = (AU::ReferenceSignalMixer *)std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)buf);
      v256 = AU::ReferenceSignalMixer::getLog(v255);
      if (os_log_type_enabled(v256, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134218240;
        *(void *)&uint8_t buf[4] = this;
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v360;
        _os_log_error_impl(&dword_1BB0CE000, v256, OS_LOG_TYPE_ERROR, "[%p] AUReferenceSignal's property list \"Configurations\"[%u] has invalid \"Gains\" value", buf, 0x12u);
      }
      unsigned int v358 = -10875;
      int v29 = 1;
      goto LABEL_666;
    }
    *(void *)buf = v200;
    buf[8] = 1;
    CFRetain(v200);
    CFArrayRef theArray = v200;
    std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)buf);
    unint64_t v202 = 0;
    int v203 = 0;
    while (CFArrayGetCount(v200) > v202)
    {
      CFArrayRef v204 = theArray;
      if (!theArray)
      {
        v352 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v352, "Could not construct");
      }
      CFTypeID Count = CFArrayGetCount(theArray);
      if (Count <= v202 || (CFTypeID Count = (CFTypeID)CFArrayGetValueAtIndex(v204, v202)) == 0)
      {
        LOBYTE(v379.__begin_) = 0;
        LOBYTE(v380) = 0;
LABEL_557:
        uint64_t v257 = AU::ReferenceSignalMixer::getLog((AU::ReferenceSignalMixer *)Count);
        if (os_log_type_enabled(v257, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 134218496;
          *(void *)&uint8_t buf[4] = this;
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v360;
          *(_WORD *)&unsigned char buf[18] = 1024;
          *(_DWORD *)&buf[20] = v203;
          _os_log_error_impl(&dword_1BB0CE000, v257, OS_LOG_TYPE_ERROR, "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"Orientations\"][%u] has invalid value", buf, 0x18u);
        }
        goto LABEL_559;
      }
      CFTypeID Count = applesauce::CF::convert_as<std::string,0>((uint64_t)&v379, (const __CFString *)Count);
      int v206 = v380;
      if (!(_BYTE)v380) {
        goto LABEL_557;
      }
      uint64_t v207 = 0;
      if (SHIBYTE(v379.__end_cap_.__value_) >= 0) {
        std::vector<char>::pointer value_high = (std::vector<char>::pointer)HIBYTE(v379.__end_cap_.__value_);
      }
      else {
        std::vector<char>::pointer value_high = v379.__end_;
      }
      if (SHIBYTE(v379.__end_cap_.__value_) >= 0) {
        uint64_t v209 = &v379;
      }
      else {
        uint64_t v209 = v379.__begin_;
      }
      while (1)
      {
        unint64_t v210 = (unint64_t)&AU::ReferenceSignalMixer::gOrientationStringMap + v207;
        if (*(std::vector<char>::pointer *)((char *)&AU::ReferenceSignalMixer::gOrientationStringMap + v207 + 16) == value_high)
        {
          CFTypeID Count = memcmp(*(const void **)(v210 + 8), v209, (size_t)value_high);
          if (!Count) {
            break;
          }
        }
        v207 += 24;
        if (v207 == 168)
        {
          uint64_t v211 = AU::ReferenceSignalMixer::getLog((AU::ReferenceSignalMixer *)Count);
          if (os_log_type_enabled(v211, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 134218496;
            *(void *)&uint8_t buf[4] = this;
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v360;
            *(_WORD *)&unsigned char buf[18] = 1024;
            *(_DWORD *)&buf[20] = v203;
            _os_log_error_impl(&dword_1BB0CE000, v211, OS_LOG_TYPE_ERROR, "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"Orientations\"][%u] has unsupported value", buf, 0x18u);
          }
          int v212 = 0;
          unsigned int v358 = -10875;
          goto LABEL_537;
        }
      }
      unint64_t v213 = *(unsigned int *)v210;
      unint64_t v214 = (unint64_t)__p[1];
      if (__p[1])
      {
        uint8x8_t v215 = (uint8x8_t)vcnt_s8((int8x8_t)__p[1]);
        v215.i16[0] = vaddlv_u8(v215);
        if (v215.u32[0] > 1uLL)
        {
          unint64_t v210 = *(unsigned int *)v210;
          if (__p[1] <= (void *)v213) {
            unint64_t v210 = v213 % (unint64_t)__p[1];
          }
        }
        else
        {
          unint64_t v210 = (LODWORD(__p[1]) - 1) & v213;
        }
        v216 = (void **)*((void *)__p[0] + v210);
        if (v216)
        {
          char v217 = (char *)*v216;
          if (*v216)
          {
            do
            {
              unint64_t v218 = *((void *)v217 + 1);
              if (v218 == v213)
              {
                if (*((_DWORD *)v217 + 4) == v213) {
                  goto LABEL_520;
                }
              }
              else
              {
                if (v215.u32[0] > 1uLL)
                {
                  if ((void *)v218 >= __p[1]) {
                    v218 %= (unint64_t)__p[1];
                  }
                }
                else
                {
                  v218 &= (unint64_t)__p[1] - 1;
                }
                if (v218 != v210) {
                  break;
                }
              }
              char v217 = *(char **)v217;
            }
            while (v217);
          }
        }
      }
      char v217 = (char *)operator new(0x30uLL);
      *(void *)char v217 = 0;
      *((void *)v217 + 1) = v213;
      *((_DWORD *)v217 + 4) = v213;
      *((void *)v217 + 4) = 0;
      *((void *)v217 + 5) = 0;
      *((void *)v217 + 3) = 0;
      float v219 = (float)(unint64_t)(*((void *)&v374 + 1) + 1);
      if (v214 && (float)(v375 * (float)v214) >= v219)
      {
        unint64_t v213 = v210;
        goto LABEL_510;
      }
      BOOL v220 = (v214 & (v214 - 1)) != 0;
      if (v214 < 3) {
        BOOL v220 = 1;
      }
      unint64_t v221 = v220 | (2 * v214);
      unint64_t v222 = vcvtps_u32_f32(v219 / v375);
      if (v221 <= v222) {
        int8x8_t v223 = (int8x8_t)v222;
      }
      else {
        int8x8_t v223 = (int8x8_t)v221;
      }
      if (*(void *)&v223 == 1)
      {
        int8x8_t v223 = (int8x8_t)2;
      }
      else if ((*(void *)&v223 & (*(void *)&v223 - 1)) != 0)
      {
        int8x8_t v223 = (int8x8_t)std::__next_prime(*(void *)&v223);
        unint64_t v214 = (unint64_t)__p[1];
      }
      if (*(void *)&v223 <= v214)
      {
        if (*(void *)&v223 >= v214) {
          goto LABEL_506;
        }
        unint64_t v230 = vcvtps_u32_f32((float)*((unint64_t *)&v374 + 1) / v375);
        if (v214 < 3 || (uint8x8_t v231 = (uint8x8_t)vcnt_s8((int8x8_t)v214), v231.i16[0] = vaddlv_u8(v231), v231.u32[0] > 1uLL))
        {
          unint64_t v230 = std::__next_prime(v230);
        }
        else
        {
          uint64_t v232 = 1 << -(char)__clz(v230 - 1);
          if (v230 >= 2) {
            unint64_t v230 = v232;
          }
        }
        if (*(void *)&v223 <= v230) {
          int8x8_t v223 = (int8x8_t)v230;
        }
        if (*(void *)&v223 >= v214)
        {
          unint64_t v214 = (unint64_t)__p[1];
          goto LABEL_506;
        }
        if (!*(void *)&v223)
        {
          long long v254 = __p[0];
          __p[0] = 0;
          if (v254) {
            operator delete(v254);
          }
          unint64_t v214 = 0;
          __p[1] = 0;
          goto LABEL_506;
        }
      }
      if (*(void *)&v223 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      unint64_t v224 = operator new(8 * *(void *)&v223);
      uint64_t v225 = __p[0];
      __p[0] = v224;
      if (v225) {
        operator delete(v225);
      }
      uint64_t v226 = 0;
      __p[1] = (void *)v223;
      do
        *((void *)__p[0] + v226++) = 0;
      while (*(void *)&v223 != v226);
      unint64_t v227 = (void **)v374;
      if ((void)v374)
      {
        unint64_t v228 = *(void *)(v374 + 8);
        uint8x8_t v229 = (uint8x8_t)vcnt_s8(v223);
        v229.i16[0] = vaddlv_u8(v229);
        if (v229.u32[0] > 1uLL)
        {
          if (v228 >= *(void *)&v223) {
            v228 %= *(void *)&v223;
          }
        }
        else
        {
          v228 &= *(void *)&v223 - 1;
        }
        *((void *)__p[0] + v228) = &v374;
        for (uint64_t k = *v227; k; v228 = v234)
        {
          unint64_t v234 = k[1];
          if (v229.u32[0] > 1uLL)
          {
            if (v234 >= *(void *)&v223) {
              v234 %= *(void *)&v223;
            }
          }
          else
          {
            v234 &= *(void *)&v223 - 1;
          }
          if (v234 != v228)
          {
            if (!*((void *)__p[0] + v234))
            {
              *((void *)__p[0] + v234) = v227;
              goto LABEL_502;
            }
            *unint64_t v227 = (void *)*k;
            *uint64_t k = **((void **)__p[0] + v234);
            **((void **)__p[0] + v234) = k;
            uint64_t k = v227;
          }
          unint64_t v234 = v228;
LABEL_502:
          unint64_t v227 = (void **)k;
          uint64_t k = (void *)*k;
        }
      }
      unint64_t v214 = (unint64_t)v223;
LABEL_506:
      if ((v214 & (v214 - 1)) != 0)
      {
        if (v214 <= v213) {
          v213 %= v214;
        }
      }
      else
      {
        unint64_t v213 = (v214 - 1) & v213;
      }
LABEL_510:
      uint64_t v235 = __p[0];
      unint64_t v236 = (void *)*((void *)__p[0] + v213);
      if (v236)
      {
        *(void *)char v217 = *v236;
LABEL_518:
        *unint64_t v236 = v217;
        goto LABEL_519;
      }
      *(void *)char v217 = v374;
      *(void *)&long long v374 = v217;
      v235[v213] = &v374;
      if (*(void *)v217)
      {
        unint64_t v237 = *(void *)(*(void *)v217 + 8);
        if ((v214 & (v214 - 1)) != 0)
        {
          if (v237 >= v214) {
            v237 %= v214;
          }
        }
        else
        {
          v237 &= v214 - 1;
        }
        unint64_t v236 = (char *)__p[0] + 8 * v237;
        goto LABEL_518;
      }
LABEL_519:
      ++*((void *)&v374 + 1);
LABEL_520:
      unint64_t v238 = *((void *)v217 + 5);
      unint64_t v239 = *((void *)v217 + 4);
      if (v239 >= v238)
      {
        uint64_t v241 = *((void *)v217 + 3);
        uint64_t v242 = (uint64_t)(v239 - v241) >> 3;
        if ((unint64_t)(v242 + 1) >> 61) {
          std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v243 = v238 - v241;
        uint64_t v244 = v243 >> 2;
        if (v243 >> 2 <= (unint64_t)(v242 + 1)) {
          uint64_t v244 = v242 + 1;
        }
        if ((unint64_t)v243 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v245 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v245 = v244;
        }
        unint64_t v383 = v217 + 40;
        if (v245) {
          unint64_t v245 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v245);
        }
        else {
          uint64_t v246 = 0;
        }
        uint64_t v247 = (void *)(v245 + 8 * v242);
        unint64_t v248 = v245 + 8 * v246;
        unint64_t v382 = v248;
        std::construct_at[abi:ne180100]<applesauce::CF::StringRef,applesauce::CF::StringRef const&,applesauce::CF::StringRef*>(v247, &v370);
        v240 = v247 + 1;
        *(void *)&buf[16] = v247 + 1;
        v250 = (void *)*((void *)v217 + 3);
        uint64_t v249 = (void *)*((void *)v217 + 4);
        if (v249 == v250)
        {
          int64x2_t v252 = vdupq_n_s64((unint64_t)v249);
        }
        else
        {
          do
          {
            uint64_t v251 = *--v249;
            *--uint64_t v247 = v251;
            *uint64_t v249 = 0;
          }
          while (v249 != v250);
          int64x2_t v252 = *(int64x2_t *)(v217 + 24);
          v240 = *(void **)&buf[16];
          unint64_t v248 = v382;
        }
        *((void *)v217 + 3) = v247;
        *((void *)v217 + 4) = v240;
        *(int64x2_t *)&buf[8] = v252;
        unint64_t v253 = *((void *)v217 + 5);
        *((void *)v217 + 5) = v248;
        unint64_t v382 = v253;
        *(void *)buf = v252.i64[0];
        std::__split_buffer<applesauce::CF::StringRef>::~__split_buffer((uint64_t)buf);
        int v206 = v380;
      }
      else
      {
        std::construct_at[abi:ne180100]<applesauce::CF::StringRef,applesauce::CF::StringRef const&,applesauce::CF::StringRef*>(*((void **)v217 + 4), &v370);
        v240 = (void *)(v239 + 8);
      }
      *((void *)v217 + 4) = v240;
      int v212 = 1;
      if (v206)
      {
LABEL_537:
        if (SHIBYTE(v379.__end_cap_.__value_) < 0)
        {
          operator delete(v379.__begin_);
          if ((v212 & 1) == 0) {
            goto LABEL_560;
          }
          goto LABEL_541;
        }
      }
      if (!v212) {
        goto LABEL_560;
      }
LABEL_541:
      unint64_t v202 = (v203 + 1);
      CFArrayRef v200 = theArray;
      ++v203;
      if (!theArray)
      {
        uint64_t v353 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v353, "Could not construct");
      }
    }
    uint64_t v258 = v374;
    if (!(void)v374) {
      goto LABEL_665;
    }
    while (2)
    {
      *(_DWORD *)buf = *(_DWORD *)(v258 + 16);
      *(void *)&buf[16] = 0;
      unint64_t v382 = 0;
      *(void *)&buf[8] = 0;
      uint64_t v259 = (AU::ReferenceSignalMixer *)std::vector<applesauce::CF::StringRef>::__init_with_size[abi:ne180100]<applesauce::CF::StringRef*,applesauce::CF::StringRef*>(&buf[8], *(CFTypeRef **)(v258 + 24), *(CFTypeRef **)(v258 + 32), (uint64_t)(*(void *)(v258 + 32) - *(void *)(v258 + 24)) >> 3);
      unint64_t v356 = (uint64_t *)v258;
      unint64_t v260 = *(const __CFString ***)&buf[8];
      if (*(void *)&buf[16] - *(void *)&buf[8] == 8)
      {
        CFHashCode v261 = std::hash<applesauce::CF::StringRef>::operator()((uint64_t)&v377 + 8, *(CFTypeRef **)&buf[8]);
        unint64_t v262 = *((void *)&v376 + 1);
        if (!*((void *)&v376 + 1)) {
          goto LABEL_756;
        }
        unint64_t v263 = v261;
        uint8x8_t v264 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v376 + 8));
        v264.i16[0] = vaddlv_u8(v264);
        unint64_t v265 = v264.u32[0];
        if (v264.u32[0] > 1uLL)
        {
          CFHashCode v266 = v261;
          if (v261 >= *((void *)&v376 + 1)) {
            CFHashCode v266 = v261 % *((void *)&v376 + 1);
          }
        }
        else
        {
          CFHashCode v266 = (*((void *)&v376 + 1) - 1) & v261;
        }
        unint64_t v267 = *(CFTypeRef ***)(v376 + 8 * v266);
        if (!v267 || (v268 = *v267) == 0) {
LABEL_756:
        }
          std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
        while (2)
        {
          unint64_t v269 = (unint64_t)v268[1];
          if (v269 != v263)
          {
            if (v265 > 1)
            {
              if (v269 >= v262) {
                v269 %= v262;
              }
            }
            else
            {
              v269 &= v262 - 1;
            }
            if (v269 != v266) {
              goto LABEL_756;
            }
LABEL_578:
            v268 = (CFTypeRef *)*v268;
            if (!v268) {
              goto LABEL_756;
            }
            continue;
          }
          break;
        }
        if (applesauce::CF::compare<applesauce::CF::StringRef,0,applesauce::CF::StringRef,0>(v268 + 2, v260)) {
          goto LABEL_578;
        }
        unint64_t v270 = *(unsigned int *)buf;
        unint64_t v271 = *((void *)this + 79);
        if (v271)
        {
          uint8x8_t v272 = (uint8x8_t)vcnt_s8((int8x8_t)v271);
          v272.i16[0] = vaddlv_u8(v272);
          if (v272.u32[0] > 1uLL)
          {
            unint64_t v263 = *(unsigned int *)buf;
            if (v271 <= *(unsigned int *)buf) {
              unint64_t v263 = *(unsigned int *)buf % v271;
            }
          }
          else
          {
            unint64_t v263 = (v271 - 1) & *(_DWORD *)buf;
          }
          uint64_t v273 = *(uint64_t ***)(*((void *)this + 78) + 8 * v263);
          if (v273)
          {
            for (uint64_t m = *v273; m; uint64_t m = (uint64_t *)*m)
            {
              unint64_t v275 = m[1];
              if (v275 == *(unsigned int *)buf)
              {
                if (*((_DWORD *)m + 4) == *(_DWORD *)buf) {
                  goto LABEL_654;
                }
              }
              else
              {
                if (v272.u32[0] > 1uLL)
                {
                  if (v275 >= v271) {
                    v275 %= v271;
                  }
                }
                else
                {
                  v275 &= v271 - 1;
                }
                if (v275 != v263) {
                  break;
                }
              }
            }
          }
        }
        v276 = operator new(0x28uLL);
        void *v276 = 0;
        v276[1] = v270;
        *((_DWORD *)v276 + 4) = v270;
        v276[3] = v268[3];
        v277 = (atomic_ullong *)v268[4];
        v276[4] = v277;
        if (v277) {
          atomic_fetch_add_explicit(v277 + 1, 1uLL, memory_order_relaxed);
        }
        float v278 = (float)(unint64_t)(*((void *)this + 81) + 1);
        float v279 = *((float *)this + 164);
        if (!v271 || (float)(v279 * (float)v271) < v278)
        {
          BOOL v280 = (v271 & (v271 - 1)) != 0;
          if (v271 < 3) {
            BOOL v280 = 1;
          }
          unint64_t v281 = v280 | (2 * v271);
          unint64_t v282 = vcvtps_u32_f32(v278 / v279);
          if (v281 <= v282) {
            int8x8_t v283 = (int8x8_t)v282;
          }
          else {
            int8x8_t v283 = (int8x8_t)v281;
          }
          if (*(void *)&v283 == 1)
          {
            int8x8_t v283 = (int8x8_t)2;
          }
          else if ((*(void *)&v283 & (*(void *)&v283 - 1)) != 0)
          {
            int8x8_t v283 = (int8x8_t)std::__next_prime(*(void *)&v283);
          }
          unint64_t v271 = *((void *)this + 79);
          if (*(void *)&v283 <= v271)
          {
            if (*(void *)&v283 < v271)
            {
              unint64_t v290 = vcvtps_u32_f32((float)*((unint64_t *)this + 81) / *((float *)this + 164));
              if (v271 < 3
                || (uint8x8_t v291 = (uint8x8_t)vcnt_s8((int8x8_t)v271), v291.i16[0] = vaddlv_u8(v291), v291.u32[0] > 1uLL))
              {
                unint64_t v290 = std::__next_prime(v290);
              }
              else
              {
                uint64_t v292 = 1 << -(char)__clz(v290 - 1);
                if (v290 >= 2) {
                  unint64_t v290 = v292;
                }
              }
              if (*(void *)&v283 <= v290) {
                int8x8_t v283 = (int8x8_t)v290;
              }
              if (*(void *)&v283 >= v271)
              {
                unint64_t v271 = *((void *)this + 79);
              }
              else
              {
                if (v283) {
                  goto LABEL_610;
                }
                unint64_t v299 = (void *)*((void *)this + 78);
                *((void *)this + 78) = 0;
                if (v299) {
                  operator delete(v299);
                }
                unint64_t v271 = 0;
                *((void *)this + 79) = 0;
              }
            }
          }
          else
          {
LABEL_610:
            if (*(void *)&v283 >> 61) {
              std::__throw_bad_array_new_length[abi:ne180100]();
            }
            unint64_t v284 = operator new(8 * *(void *)&v283);
            uint64_t v285 = (void *)*((void *)this + 78);
            *((void *)this + 78) = v284;
            if (v285) {
              operator delete(v285);
            }
            uint64_t v286 = 0;
            *((int8x8_t *)this + 79) = v283;
            do
              *(void *)(*((void *)this + 78) + 8 * v286++) = 0;
            while (*(void *)&v283 != v286);
            unint64_t v287 = (void *)*v357;
            if (*v357)
            {
              unint64_t v288 = v287[1];
              uint8x8_t v289 = (uint8x8_t)vcnt_s8(v283);
              v289.i16[0] = vaddlv_u8(v289);
              if (v289.u32[0] > 1uLL)
              {
                if (v288 >= *(void *)&v283) {
                  v288 %= *(void *)&v283;
                }
              }
              else
              {
                v288 &= *(void *)&v283 - 1;
              }
              *(void *)(*((void *)this + 78) + 8 * v288) = v357;
              uint64_t v293 = (void *)*v287;
              if (*v287)
              {
                do
                {
                  unint64_t v294 = v293[1];
                  if (v289.u32[0] > 1uLL)
                  {
                    if (v294 >= *(void *)&v283) {
                      v294 %= *(void *)&v283;
                    }
                  }
                  else
                  {
                    v294 &= *(void *)&v283 - 1;
                  }
                  if (v294 != v288)
                  {
                    uint64_t v295 = *((void *)this + 78);
                    if (!*(void *)(v295 + 8 * v294))
                    {
                      *(void *)(v295 + 8 * v294) = v287;
                      goto LABEL_635;
                    }
                    *unint64_t v287 = *v293;
                    *uint64_t v293 = **(void **)(*((void *)this + 78) + 8 * v294);
                    **(void **)(*((void *)this + 78) + 8 * v294) = v293;
                    uint64_t v293 = v287;
                  }
                  unint64_t v294 = v288;
LABEL_635:
                  unint64_t v287 = v293;
                  uint64_t v293 = (void *)*v293;
                  unint64_t v288 = v294;
                }
                while (v293);
              }
            }
            unint64_t v271 = (unint64_t)v283;
          }
          if ((v271 & (v271 - 1)) != 0)
          {
            if (v271 <= v270) {
              unint64_t v263 = v270 % v271;
            }
            else {
              unint64_t v263 = v270;
            }
          }
          else
          {
            unint64_t v263 = (v271 - 1) & v270;
          }
        }
        uint64_t v296 = *((void *)this + 78);
        uint64_t v297 = *(void **)(v296 + 8 * v263);
        if (v297)
        {
          void *v276 = *v297;
          goto LABEL_652;
        }
        void *v276 = *v357;
        *uint64_t v357 = v276;
        *(void *)(v296 + 8 * v263) = v357;
        if (*v276)
        {
          unint64_t v298 = *(void *)(*v276 + 8);
          if ((v271 & (v271 - 1)) != 0)
          {
            if (v298 >= v271) {
              v298 %= v271;
            }
          }
          else
          {
            v298 &= v271 - 1;
          }
          uint64_t v297 = (void *)(*((void *)this + 78) + 8 * v298);
LABEL_652:
          void *v297 = v276;
        }
        ++*((void *)this + 81);
LABEL_654:
        v379.__begin_ = &buf[8];
        std::vector<applesauce::CF::StringRef>::__destroy_vector::operator()[abi:ne180100]((void ***)&v379);
        uint64_t v258 = *v356;
        if (*v356) {
          continue;
        }
LABEL_665:
        int v29 = 0;
      }
      else
      {
        uint64_t v318 = AU::ReferenceSignalMixer::getLog(v259);
        if (os_log_type_enabled(v318, OS_LOG_TYPE_ERROR))
        {
          AU::ReferenceSignalMixer::OrientationToString((uint64_t)cf, *(int *)buf);
          int v320 = v365;
          if (v365)
          {
            *(_OWORD *)uint64_t v366 = *(_OWORD *)cf;
            uint64_t v367 = v364;
            cf[1] = 0;
            uint64_t v364 = 0;
            cf[0] = 0;
          }
          else
          {
            std::string::basic_string[abi:ne180100]<0>(v366, "???");
          }
          int v321 = SHIBYTE(v367);
          v322 = (char *)v366[0];
          AU::ReferenceSignalMixer::Join(v361, *(const __CFString ***)&buf[8], *(const __CFString ***)&buf[16]);
          unint64_t v323 = (char *)v366;
          if (v321 < 0) {
            unint64_t v323 = v322;
          }
          v324 = v361;
          if (v362 < 0) {
            v324 = (void **)v361[0];
          }
          LODWORD(v379.__begin_) = 134218498;
          *(std::vector<char>::pointer *)((char *)&v379.__begin_ + 4) = (std::vector<char>::pointer)this;
          WORD2(v379.__end_) = 2080;
          *(std::vector<char>::pointer *)((char *)&v379.__end_ + 6) = v323;
          HIWORD(v379.__end_cap_.__value_) = 2080;
          unint64_t v380 = v324;
          _os_log_error_impl(&dword_1BB0CE000, v318, OS_LOG_TYPE_ERROR, "[%p] AUReferenceSignal's property list maps orientation \"%s\" to multiple configurations: %s", (uint8_t *)&v379, 0x20u);
          if (v362 < 0) {
            operator delete(v361[0]);
          }
          if (SHIBYTE(v367) < 0) {
            operator delete((void *)v366[0]);
          }
          if (v320 && SHIBYTE(v364) < 0) {
            operator delete((void *)cf[0]);
          }
        }
        v379.__begin_ = &buf[8];
        std::vector<applesauce::CF::StringRef>::__destroy_vector::operator()[abi:ne180100]((void ***)&v379);
LABEL_559:
        unsigned int v358 = -10875;
LABEL_560:
        int v29 = 1;
      }
      break;
    }
LABEL_666:
    if (theArray) {
      CFRelease(theArray);
    }
LABEL_668:
    unint64_t v167 = 0;
LABEL_669:
    if (v167) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v167);
    }
    if (v369) {
      CFRelease(v369);
    }
LABEL_280:
    if (v370) {
      CFRelease(v370);
    }
    CFDictionaryRef v14 = (const __CFDictionary *)v371;
    if (v371) {
LABEL_283:
    }
      CFRelease(v14);
    if (v29 && v29 != 6) {
      break;
    }
    unint64_t v12 = (v360 + 1);
    CFTypeRef v10 = v372;
    ++v360;
    if (!v372)
    {
      v337 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v337, "Could not construct");
    }
  }
  int v328 = v29;
LABEL_743:
  uint64_t v327 = v358;
LABEL_744:
  if (v372) {
    CFRelease(v372);
  }
LABEL_746:
  std::__hash_table<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::vector<applesauce::CF::StringRef>>,std::__unordered_map_hasher<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::vector<applesauce::CF::StringRef>>,std::hash<AU::ReferenceSignalMixer::Orientation>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,true>,std::__unordered_map_equal<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::vector<applesauce::CF::StringRef>>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,std::hash<AU::ReferenceSignalMixer::Orientation>,true>,std::allocator<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::vector<applesauce::CF::StringRef>>>>::~__hash_table((uint64_t)__p);
  std::__hash_table<std::__hash_value_type<applesauce::CF::StringRef,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::__unordered_map_hasher<applesauce::CF::StringRef,std::__hash_value_type<applesauce::CF::StringRef,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::hash<applesauce::CF::StringRef>,std::equal_to<applesauce::CF::StringRef>,true>,std::__unordered_map_equal<applesauce::CF::StringRef,std::__hash_value_type<applesauce::CF::StringRef,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::equal_to<applesauce::CF::StringRef>,std::hash<applesauce::CF::StringRef>,true>,std::allocator<std::__hash_value_type<applesauce::CF::StringRef,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>>>::~__hash_table((uint64_t)&v376);
  if (!v328)
  {
LABEL_747:
    uint64_t v327 = 0;
    *((void *)this + 83) = (char *)this + 616;
    ++*((_DWORD *)this + 152);
  }
  return v327;
}

void sub_1BB3838D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,void *__p,uint64_t a41,int a42,__int16 a43,char a44,char a45,const void *a46,const void *a47,const void *a48,const void *a49,const void *a50,__int16 a51)
{
  if (a45 < 0) {
    operator delete(__p);
  }
  if (v51)
  {
    if (a38 < 0) {
      operator delete(a33);
    }
  }
  *(void *)(v52 - 176) = a24;
  std::vector<applesauce::CF::StringRef>::__destroy_vector::operator()[abi:ne180100]((void ***)(v52 - 176));
  applesauce::CF::ArrayRef::~ArrayRef(&a46);
  applesauce::CF::ArrayRef::~ArrayRef(&a47);
  applesauce::CF::StringRef::~StringRef(&a48);
  applesauce::CF::DictionaryRef::~DictionaryRef(&a49);
  applesauce::CF::ArrayRef::~ArrayRef(&a50);
  std::__hash_table<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::vector<applesauce::CF::StringRef>>,std::__unordered_map_hasher<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::vector<applesauce::CF::StringRef>>,std::hash<AU::ReferenceSignalMixer::Orientation>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,true>,std::__unordered_map_equal<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::vector<applesauce::CF::StringRef>>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,std::hash<AU::ReferenceSignalMixer::Orientation>,true>,std::allocator<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::vector<applesauce::CF::StringRef>>>>::~__hash_table((uint64_t)&a51);
  std::__hash_table<std::__hash_value_type<applesauce::CF::StringRef,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::__unordered_map_hasher<applesauce::CF::StringRef,std::__hash_value_type<applesauce::CF::StringRef,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::hash<applesauce::CF::StringRef>,std::equal_to<applesauce::CF::StringRef>,true>,std::__unordered_map_equal<applesauce::CF::StringRef,std::__hash_value_type<applesauce::CF::StringRef,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::equal_to<applesauce::CF::StringRef>,std::hash<applesauce::CF::StringRef>,true>,std::allocator<std::__hash_value_type<applesauce::CF::StringRef,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>>>::~__hash_table(v52 - 224);
  _Unwind_Resume(a1);
}

uint64_t AU::ReferenceSignalMixer::getLog(AU::ReferenceSignalMixer *this)
{
  uint64_t v1 = &unk_1E9F7D000;
  {
    uint64_t v1 = (void *)&unk_1E9F7D000;
    if (v3)
    {
      AU::ReferenceSignalMixer::getLog(void)::gLog = (uint64_t)os_log_create("com.apple.coreaudio", "AUReferenceSignalMixer");
      uint64_t v1 = (void *)&unk_1E9F7D000;
    }
  }
  return v1[495];
}

uint64_t applesauce::CF::at_or<applesauce::CF::DictionaryRef>(void *a1, CFArrayRef theArray, unint64_t a3, void *a4)
{
  if (CFArrayGetCount(theArray) <= a3) {
    goto LABEL_6;
  }
  CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, a3);
  uint64_t v9 = ValueAtIndex;
  if (!ValueAtIndex) {
    goto LABEL_6;
  }
  CFRetain(ValueAtIndex);
  CFTypeID v10 = CFGetTypeID(v9);
  if (v10 != CFDictionaryGetTypeID())
  {
    CFRelease(v9);
LABEL_6:
    LOBYTE(v12) = 0;
    char v13 = 0;
    *a1 = *a4;
    *a4 = 0;
    return std::__optional_destruct_base<applesauce::CF::DictionaryRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v12);
  }
  unint64_t v12 = v9;
  char v13 = 1;
  CFRetain(v9);
  *a1 = v9;
  return std::__optional_destruct_base<applesauce::CF::DictionaryRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v12);
}

BOOL applesauce::CF::details::has_key<char const(&)[5]>(const __CFDictionary *a1, char *__s)
{
  CFIndex v4 = strlen(__s);
  CFStringRef v5 = CFStringCreateWithBytes(0, (const UInt8 *)__s, v4, 0x8000100u, 0);
  if (!v5)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  CFStringRef v6 = v5;
  int v7 = CFDictionaryContainsKey(a1, v5);
  CFRelease(v6);
  return v7 != 0;
}

void sub_1BB38401C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  __cxa_free_exception(v10);
  _Unwind_Resume(a1);
}

BOOL applesauce::CF::details::has_key<applesauce::CF::StringRef>(CFDictionaryRef theDict, const void *a2)
{
  BOOL result = 0;
  if (theDict)
  {
    if (a2) {
      return CFDictionaryContainsKey(theDict, a2) != 0;
    }
  }
  return result;
}

uint64_t applesauce::CF::at_or<applesauce::CF::ArrayRef,applesauce::CF::StringRef>(const __CFDictionary **a1, const __CFDictionary *a2, const void **a3, const __CFDictionary **a4)
{
  CFDictionaryRef v6 = applesauce::CF::details::at_key<applesauce::CF::StringRef>(a2, a3);
  if (!v6) {
    goto LABEL_5;
  }
  CFDictionaryRef v7 = v6;
  CFRetain(v6);
  CFTypeID v8 = CFGetTypeID(v7);
  if (v8 != CFArrayGetTypeID())
  {
    CFRelease(v7);
LABEL_5:
    LOBYTE(v10) = 0;
    char v11 = 0;
    *a1 = *a4;
    *a4 = 0;
    return std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v10);
  }
  CFDictionaryRef v10 = v7;
  char v11 = 1;
  CFRetain(v7);
  *a1 = v7;
  return std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v10);
}

std::vector<char> *AU::ReferenceSignalMixer::MakeDefaultChannelLayout(std::vector<char> *a1, int a2)
{
  if (a2 == 2)
  {
    std::vector<char>::value_type v7 = 0;
    BOOL result = std::vector<char>::vector(a1, 0x20uLL, &v7);
    CFArrayRef begin = result->__begin_;
    int v4 = 6619138;
  }
  else
  {
    if (a2 != 1)
    {
      int v5 = a2 | 0x930000;
      std::vector<char>::value_type v8 = 0;
      BOOL result = std::vector<char>::vector(a1, 0x20uLL, &v8);
      CFArrayRef begin = result->__begin_;
      *(_DWORD *)result->__begin_ = v5;
      goto LABEL_7;
    }
    std::vector<char>::value_type __x = 0;
    BOOL result = std::vector<char>::vector(a1, 0x20uLL, &__x);
    CFArrayRef begin = result->__begin_;
    int v4 = 6553601;
  }
  *CFArrayRef begin = v4;
LABEL_7:
  begin[1] = 0;
  begin[2] = 0;
  return result;
}

__n128 std::optional<CA::ChannelLayout>::value_or[abi:ne180100]<CA::ChannelLayout>(__n128 *a1, uint64_t a2, __n128 *a3)
{
  if (*(unsigned char *)(a2 + 24))
  {
    a1->n128_u64[0] = 0;
    a1->n128_u64[1] = 0;
    a1[1].n128_u64[0] = 0;
    std::vector<char>::__init_with_size[abi:ne180100]<char *,char *>(a1, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
  }
  else
  {
    __n128 result = *a3;
    *a1 = *a3;
    a1[1].n128_u64[0] = a3[1].n128_u64[0];
    a3->n128_u64[1] = 0;
    a3[1].n128_u64[0] = 0;
    a3->n128_u64[0] = 0;
  }
  return result;
}

uint64_t applesauce::CF::at_or<applesauce::CF::DataRef>(void *a1, CFArrayRef theArray, unint64_t a3, void *a4)
{
  if (CFArrayGetCount(theArray) <= a3) {
    goto LABEL_6;
  }
  CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, a3);
  uint64_t v9 = ValueAtIndex;
  if (!ValueAtIndex) {
    goto LABEL_6;
  }
  CFRetain(ValueAtIndex);
  CFTypeID v10 = CFGetTypeID(v9);
  if (v10 != CFDataGetTypeID())
  {
    CFRelease(v9);
LABEL_6:
    LOBYTE(v12) = 0;
    char v13 = 0;
    *a1 = *a4;
    *a4 = 0;
    return std::__optional_destruct_base<applesauce::CF::DataRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v12);
  }
  unint64_t v12 = v9;
  char v13 = 1;
  CFRetain(v9);
  *a1 = v9;
  return std::__optional_destruct_base<applesauce::CF::DataRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v12);
}

const __CFDictionary *applesauce::CF::DictionaryRef_proxy::at_as<unsigned int,applesauce::CF::StringRef>(const __CFDictionary *a1, const void **a2)
{
  CFDictionaryRef result = applesauce::CF::details::at_key<applesauce::CF::StringRef>(a1, a2);
  if (result)
  {
    return (const __CFDictionary *)applesauce::CF::convert_as<unsigned int,0>(result);
  }
  return result;
}

BOOL applesauce::CF::details::has_key<char const(&)[6]>(const __CFDictionary *a1, char *__s)
{
  CFIndex v4 = strlen(__s);
  CFStringRef v5 = CFStringCreateWithBytes(0, (const UInt8 *)__s, v4, 0x8000100u, 0);
  if (!v5)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  CFStringRef v6 = v5;
  int v7 = CFDictionaryContainsKey(a1, v5);
  CFRelease(v6);
  return v7 != 0;
}

void sub_1BB3843D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  __cxa_free_exception(v10);
  _Unwind_Resume(a1);
}

const __CFNumber *applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[5]>(const __CFDictionary *a1, char *a2)
{
  CFNumberRef result = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[5]>(a1, a2);
  if (result)
  {
    return (const __CFNumber *)applesauce::CF::convert_as<float,0>(result);
  }
  return result;
}

BOOL applesauce::CF::details::has_key<char const(&)[13]>(const __CFDictionary *a1, char *__s)
{
  CFIndex v4 = strlen(__s);
  CFStringRef v5 = CFStringCreateWithBytes(0, (const UInt8 *)__s, v4, 0x8000100u, 0);
  if (!v5)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  CFStringRef v6 = v5;
  int v7 = CFDictionaryContainsKey(a1, v5);
  CFRelease(v6);
  return v7 != 0;
}

void sub_1BB3844E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  __cxa_free_exception(v10);
  _Unwind_Resume(a1);
}

void *std::vector<applesauce::CF::StringRef>::__init_with_size[abi:ne180100]<applesauce::CF::StringRef*,applesauce::CF::StringRef*>(void *result, CFTypeRef *a2, CFTypeRef *a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >> 61) {
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    }
    CFStringRef v6 = result;
    CFNumberRef result = std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(a4);
    int v7 = result;
    void *v6 = result;
    v6[1] = result;
    v6[2] = &result[v8];
    while (a2 != a3)
    {
      CFTypeRef v9 = *a2;
      if (*a2) {
        CFNumberRef result = CFRetain(*a2);
      }
      *v7++ = v9;
      ++a2;
    }
    v6[1] = v7;
  }
  return result;
}

void sub_1BB3845A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

double AU::ReferenceSignalMixer::OrientationToString(uint64_t a1, int a2)
{
  uint64_t v3 = 0;
  while (1)
  {
    CFIndex v4 = (char *)&AU::ReferenceSignalMixer::gOrientationStringMap + v3;
    if (*(_DWORD *)((char *)&AU::ReferenceSignalMixer::gOrientationStringMap + v3) == a2) {
      break;
    }
    v3 += 24;
    if (v3 == 168)
    {
      *(unsigned char *)a1 = 0;
      *(unsigned char *)(a1 + 24) = 0;
      return result;
    }
  }
  size_t v5 = *((void *)v4 + 2);
  if (v5 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  CFStringRef v6 = (const void *)*((void *)v4 + 1);
  if (v5 >= 0x17)
  {
    uint64_t v8 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17) {
      uint64_t v8 = v5 | 7;
    }
    uint64_t v9 = v8 + 1;
    p_dst = (long long *)operator new(v8 + 1);
    *((void *)&__dst + 1) = v5;
    unint64_t v12 = v9 | 0x8000000000000000;
    *(void *)&long long __dst = p_dst;
  }
  else
  {
    HIBYTE(v12) = *((void *)v4 + 2);
    p_dst = &__dst;
    if (!v5) {
      goto LABEL_13;
    }
  }
  memmove(p_dst, v6, v5);
LABEL_13:
  *((unsigned char *)p_dst + v5) = 0;
  double result = *(double *)&__dst;
  *(_OWORD *)a1 = __dst;
  *(void *)(a1 + 16) = v12;
  *(unsigned char *)(a1 + 24) = 1;
  return result;
}

void AU::ReferenceSignalMixer::Join(void *a1, const __CFString **a2, const __CFString **a3)
{
  uint64_t v3 = a1;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2 == a3)
  {
    LOBYTE(v11) = 0;
    CFTypeID v10 = (char *)a1 + 23;
  }
  else
  {
    size_t v5 = a2;
    do
    {
      if (!*v5)
      {
        exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Could not construct");
      }
      applesauce::CF::convert_to<std::string,0>(*v5, (uint64_t)&v16);
      CFStringRef v6 = std::string::append(&v16, ", ", 2uLL);
      long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
      int64_t v18 = v6->__r_.__value_.__r.__words[2];
      *(_OWORD *)std::string __p = v7;
      v6->__r_.__value_.__l.__size_ = 0;
      v6->__r_.__value_.__r.__words[2] = 0;
      v6->__r_.__value_.__r.__words[0] = 0;
      if (v18 >= 0) {
        uint64_t v8 = __p;
      }
      else {
        uint64_t v8 = (void **)__p[0];
      }
      if (v18 >= 0) {
        std::string::size_type v9 = HIBYTE(v18);
      }
      else {
        std::string::size_type v9 = (std::string::size_type)__p[1];
      }
      std::string::append((std::string *)v3, (const std::string::value_type *)v8, v9);
      if (SHIBYTE(v18) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v16.__r_.__value_.__l.__data_);
      }
      ++v5;
    }
    while (v5 != a3);
    CFTypeID v10 = (char *)v3 + 23;
    int v11 = *((char *)v3 + 23);
    if (v11 < 0)
    {
      unint64_t v12 = (void *)*v3;
      uint64_t v13 = v3[1] - 1;
      v3[1] = v13;
      goto LABEL_19;
    }
  }
  uint64_t v13 = v11 - 1;
  *CFTypeID v10 = v13 & 0x7F;
  unint64_t v12 = v3;
LABEL_19:
  *((unsigned char *)v12 + v13) = 0;
  if (*((char *)v3 + 23) < 0)
  {
    uint64_t v14 = v3[1] - 1;
    v3[1] = v14;
    uint64_t v3 = (void *)*v3;
  }
  else
  {
    uint64_t v14 = *((unsigned __int8 *)v3 + 23) - 1;
    *CFTypeID v10 = v14 & 0x7F;
  }
  *((unsigned char *)v3 + v14) = 0;
}

void sub_1BB384840(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (*(char *)(v21 + 23) < 0) {
    operator delete(*(void **)v21);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__hash_table<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::vector<applesauce::CF::StringRef>>,std::__unordered_map_hasher<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::vector<applesauce::CF::StringRef>>,std::hash<AU::ReferenceSignalMixer::Orientation>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,true>,std::__unordered_map_equal<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::vector<applesauce::CF::StringRef>>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,std::hash<AU::ReferenceSignalMixer::Orientation>,true>,std::allocator<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::vector<applesauce::CF::StringRef>>>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(char **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = *(char **)v2;
      CFStringRef v6 = (void **)(v2 + 24);
      std::vector<applesauce::CF::StringRef>::__destroy_vector::operator()[abi:ne180100](&v6);
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  CFIndex v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

uint64_t std::__hash_table<std::__hash_value_type<applesauce::CF::StringRef,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::__unordered_map_hasher<applesauce::CF::StringRef,std::__hash_value_type<applesauce::CF::StringRef,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::hash<applesauce::CF::StringRef>,std::equal_to<applesauce::CF::StringRef>,true>,std::__unordered_map_equal<applesauce::CF::StringRef,std::__hash_value_type<applesauce::CF::StringRef,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::equal_to<applesauce::CF::StringRef>,std::hash<applesauce::CF::StringRef>,true>,std::allocator<std::__hash_value_type<applesauce::CF::StringRef,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<applesauce::CF::StringRef const,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  CFIndex v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void std::__destroy_at[abi:ne180100]<std::pair<applesauce::CF::StringRef const,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,0>(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  if (*(void *)a1) {
    CFRelease(*(CFTypeRef *)a1);
  }
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,void *>>>::operator()[abi:ne180100](char a1, void *__p)
{
  if (a1)
  {
    uint64_t v3 = (std::__shared_weak_count *)__p[4];
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::vector<applesauce::CF::StringRef>>,void *>>>::operator()[abi:ne180100](char a1, void **__p)
{
  if (a1)
  {
    uint64_t v3 = __p + 3;
    std::vector<applesauce::CF::StringRef>::__destroy_vector::operator()[abi:ne180100](&v3);
  }
  if (__p)
  {
    operator delete(__p);
  }
}

CFTypeID applesauce::CF::convert_as<std::string,0>(uint64_t a1, const __CFString *a2)
{
  CFTypeID TypeID = CFStringGetTypeID();
  CFTypeID result = CFGetTypeID(a2);
  if (TypeID == result)
  {
    CFTypeID result = (CFTypeID)applesauce::CF::details::CFString_get_value<false>((uint64_t)&v7, a2);
    *(_OWORD *)a1 = v7;
    *(void *)(a1 + 16) = v8;
    char v6 = 1;
  }
  else
  {
    char v6 = 0;
    *(unsigned char *)a1 = 0;
  }
  *(unsigned char *)(a1 + 24) = v6;
  return result;
}

void *applesauce::CF::details::CFString_get_value<false>(uint64_t a1, CFStringRef theString)
{
  CStringPtr = (char *)CFStringGetCStringPtr(theString, 0x8000100u);
  if (CStringPtr) {
    return std::string::basic_string[abi:ne180100]<0>((void *)a1, CStringPtr);
  }
  CFIndex Length = CFStringGetLength(theString);
  maxBufLeuint64_t n = 0;
  v9.locatiouint64_t n = 0;
  v9.length = Length;
  CFStringGetBytes(theString, v9, 0x8000100u, 0, 0, 0, 0, &maxBufLen);
  std::string::basic_string[abi:ne180100]((void *)a1, maxBufLen, 0);
  if (*(char *)(a1 + 23) >= 0) {
    long long v7 = (UInt8 *)a1;
  }
  else {
    long long v7 = *(UInt8 **)a1;
  }
  v10.locatiouint64_t n = 0;
  v10.length = Length;
  return (void *)CFStringGetBytes(theString, v10, 0x8000100u, 0, 0, v7, maxBufLen, &maxBufLen);
}

uint64_t std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v2 = *(const void **)a1;
    if (*(void *)a1) {
      CFRelease(v2);
    }
  }
  return a1;
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<applesauce::CF::StringRef,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<applesauce::CF::StringRef,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:ne180100]<std::pair<applesauce::CF::StringRef const,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,0>((uint64_t)v1 + 16);
    }
    operator delete(v1);
  }
}

void std::vector<std::vector<float>>::resize(uint64_t *a1, unint64_t a2, uint64_t a3)
{
  uint64_t v5 = *a1;
  char v6 = (void *)a1[1];
  unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v6 - *a1) >> 3);
  unint64_t v8 = a2 - v7;
  if (a2 <= v7)
  {
    if (a2 < v7)
    {
      uint64_t v21 = (void *)(v5 + 24 * a2);
      if (v6 != v21)
      {
        int64x2_t v22 = (void *)a1[1];
        do
        {
          int v24 = (void *)*(v22 - 3);
          v22 -= 3;
          unint64_t v23 = v24;
          if (v24)
          {
            *(v6 - 2) = v23;
            operator delete(v23);
          }
          char v6 = v22;
        }
        while (v22 != v21);
      }
      a1[1] = (uint64_t)v21;
    }
  }
  else
  {
    uint64_t v10 = (uint64_t)(a1 + 2);
    uint64_t v11 = a1[2];
    if (0xAAAAAAAAAAAAAAABLL * ((v11 - (uint64_t)v6) >> 3) >= v8)
    {
      BOOL v25 = &v6[3 * v8];
      uint64_t v26 = 24 * a2 - 24 * v7;
      do
      {
        void *v6 = 0;
        v6[1] = 0;
        v6[2] = 0;
        std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v6, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
        v6 += 3;
        v26 -= 24;
      }
      while (v26);
      a1[1] = (uint64_t)v25;
    }
    else
    {
      if (a2 > 0xAAAAAAAAAAAAAAALL) {
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      }
      CFTypeID v30 = a1 + 2;
      unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((v11 - v5) >> 3);
      uint64_t v13 = 2 * v12;
      if (2 * v12 <= a2) {
        uint64_t v13 = a2;
      }
      if (v12 >= 0x555555555555555) {
        unint64_t v14 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v14 = v13;
      }
      BOOL v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::__fs::filesystem::path>>(v10, v14);
      std::string v16 = &v15[24 * v7];
      v27[0] = v15;
      v27[1] = v16;
      int v28 = v16;
      int v29 = &v15[24 * v17];
      uint64_t v18 = 3 * a2;
      BOOL v19 = &v15[24 * a2];
      uint64_t v20 = 8 * v18 - 24 * v7;
      do
      {
        *(void *)std::string v16 = 0;
        *((void *)v16 + 1) = 0;
        *((void *)v16 + 2) = 0;
        std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v16, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
        v16 += 24;
        v20 -= 24;
      }
      while (v20);
      int v28 = v19;
      std::vector<std::vector<float>>::__swap_out_circular_buffer(a1, v27);
      std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)v27);
    }
  }
}

void sub_1BB384E18(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t AUReferenceSignalMixer::MatrixKernel::Mix(AUReferenceSignalMixer::MatrixKernel *this, const AudioBufferList *a2, AudioBufferList *a3, vDSP_Length __N)
{
  if (a3->mNumberBuffers)
  {
    unint64_t v7 = 0;
    vDSP_Length v8 = __N;
    do
    {
      mData = (float *)a3->mBuffers[v7].mData;
      if (!a2->mNumberBuffers) {
        goto LABEL_11;
      }
      unint64_t v10 = 0;
      char v11 = 0;
      uint64_t v12 = 16;
      do
      {
        uint64_t v13 = *(const float **)((char *)&a2->mNumberBuffers + v12);
        float __B = 0.0;
        float __B = *(float *)(*(void *)(*((void *)this + 1) + 24 * v7) + 4 * v10);
        if (__B != 0.0)
        {
          if (v11)
          {
            char v11 = 1;
            vDSP_vsma(v13, 1, &__B, mData, 1, mData, 1, v8);
          }
          else
          {
            char v11 = 1;
            vDSP_vsmul(v13, 1, &__B, mData, 1, v8);
          }
        }
        ++v10;
        v12 += 16;
      }
      while (v10 < a2->mNumberBuffers);
      if ((v11 & 1) == 0)
      {
LABEL_11:
        float __A = 0.0;
        vDSP_vfill(&__A, mData, 1, v8);
      }
      ++v7;
    }
    while (v7 < a3->mNumberBuffers);
  }
  return 0;
}

void AUReferenceSignalMixer::MatrixKernel::~MatrixKernel(AUReferenceSignalMixer::MatrixKernel *this)
{
  uint64_t v2 = (void **)((char *)this + 8);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v2);
  MEMORY[0x1C185D370](this, 0xA1C4030951706);
}

{
  void **v1;

  uint64_t v1 = (void **)((char *)this + 8);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v1);
}

void std::__shared_ptr_emplace<AUReferenceSignalMixer::MatrixKernel>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 32);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v1);
}

void std::__shared_ptr_emplace<AUReferenceSignalMixer::MatrixKernel>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F14AC5A0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1C185D370);
}

void std::__shared_ptr_emplace<AUReferenceSignalMixer::MatrixKernel>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F14AC5A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

const void *applesauce::CF::details::at_key<char const(&)[14]>(const __CFDictionary *a1, char *__s)
{
  CFIndex v5 = strlen(__s);
  CFStringRef v6 = CFStringCreateWithBytes(0, (const UInt8 *)__s, v5, 0x8000100u, 0);
  if (!v6)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  if (a1) {
    CFArrayRef Value = CFDictionaryGetValue(a1, v6);
  }
  CFRelease(v6);
  if (!a1) {
    return 0;
  }
  return Value;
}

void sub_1BB385170(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

void AUReferenceSignalMixer::~AUReferenceSignalMixer(AUReferenceSignalMixer *this)
{
  AUReferenceSignalMixer::~AUReferenceSignalMixer(this);

  JUMPOUT(0x1C185D370);
}

{
  NSObject *v2;
  const void *v3;
  void *v4;
  void *v5;
  int v6;
  AUReferenceSignalMixer *v7;
  uint64_t v8;

  vDSP_Length v8 = *MEMORY[0x1E4F143B8];
  *(void *)this = &unk_1F14AC300;
  {
    AU::ReferenceSignalMixer::getLog(void)::gLog = (uint64_t)os_log_create("com.apple.coreaudio", "AUReferenceSignalMixer");
  }
  uint64_t v2 = AU::ReferenceSignalMixer::getLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)AU::ReferenceSignalMixer::getLog(void)::gLog, OS_LOG_TYPE_INFO))
  {
    CFStringRef v6 = 134217984;
    unint64_t v7 = this;
    _os_log_impl(&dword_1BB0CE000, v2, OS_LOG_TYPE_INFO, "[%p] destroyed", (uint8_t *)&v6, 0xCu);
  }
  uint64_t v3 = (const void *)*((void *)this + 84);
  if (v3) {
    CFRelease(v3);
  }
  std::__hash_table<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::__unordered_map_hasher<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::hash<AU::ReferenceSignalMixer::Orientation>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,true>,std::__unordered_map_equal<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,std::hash<AU::ReferenceSignalMixer::Orientation>,true>,std::allocator<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>>>::~__hash_table((uint64_t)this + 624);
  if (*((unsigned char *)this + 600))
  {
    CFIndex v4 = (void *)*((void *)this + 72);
    if (v4)
    {
      *((void *)this + 73) = v4;
      operator delete(v4);
    }
  }
  if (*((unsigned char *)this + 560))
  {
    CFIndex v5 = (void *)*((void *)this + 67);
    if (v5)
    {
      *((void *)this + 68) = v5;
      operator delete(v5);
    }
  }
  ausdk::AUBase::~AUBase(this);
}

void sub_1BB38533C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  __clang_call_terminate(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::__unordered_map_hasher<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::hash<AU::ReferenceSignalMixer::Orientation>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,true>,std::__unordered_map_equal<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,std::hash<AU::ReferenceSignalMixer::Orientation>,true>,std::allocator<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::__unordered_map_hasher<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::hash<AU::ReferenceSignalMixer::Orientation>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,true>,std::__unordered_map_equal<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,std::hash<AU::ReferenceSignalMixer::Orientation>,true>,std::allocator<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>>>::__deallocate_node(*(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

uint64_t AUReferenceSignalMixer::BypassKernel::Mix(AUReferenceSignalMixer::BypassKernel *this, const AudioBufferList *a2, AudioBufferList *a3, unsigned int a4)
{
  if (a3->mNumberBuffers)
  {
    unint64_t v6 = 0;
    size_t v7 = 4 * a4;
    uint64_t v8 = 16;
    do
    {
      UInt32 v9 = a2->mNumberBuffers - 1;
      if (v9 >= v6) {
        UInt32 v9 = v6;
      }
      memcpy(*(void **)((char *)&a3->mNumberBuffers + v8), a2->mBuffers[v9].mData, v7);
      ++v6;
      v8 += 16;
    }
    while (v6 < a3->mNumberBuffers);
  }
  return 0;
}

void AUReferenceSignalMixer::BypassKernel::~BypassKernel(AUReferenceSignalMixer::BypassKernel *this)
{
}

void std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(uint64_t **a1, int *a2)
{
  CFIndex v4 = operator new(0xB8uLL);
  unsigned int v5 = *a2;
  v4[7] = *a2;
  long long v6 = *(_OWORD *)(a2 + 29);
  *((_OWORD *)v4 + 8) = *(_OWORD *)(a2 + 25);
  *((_OWORD *)v4 + 9) = v6;
  *((_OWORD *)v4 + 10) = *(_OWORD *)(a2 + 33);
  v4[44] = a2[37];
  long long v7 = *(_OWORD *)(a2 + 13);
  *((_OWORD *)v4 + 4) = *(_OWORD *)(a2 + 9);
  *((_OWORD *)v4 + 5) = v7;
  long long v8 = *(_OWORD *)(a2 + 21);
  *((_OWORD *)v4 + 6) = *(_OWORD *)(a2 + 17);
  *((_OWORD *)v4 + 7) = v8;
  long long v9 = *(_OWORD *)(a2 + 5);
  *((_OWORD *)v4 + 2) = *(_OWORD *)(a2 + 1);
  *((_OWORD *)v4 + 3) = v9;
  unint64_t v10 = a1 + 1;
  char v11 = a1[1];
  if (v11)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v12 = (uint64_t **)v11;
        unsigned int v13 = *((_DWORD *)v11 + 7);
        if (v5 >= v13) {
          break;
        }
        char v11 = *v12;
        unint64_t v10 = v12;
        if (!*v12) {
          goto LABEL_9;
        }
      }
      if (v13 >= v5) {
        break;
      }
      char v11 = v12[1];
      if (!v11)
      {
        unint64_t v10 = v12 + 1;
        goto LABEL_9;
      }
    }
    operator delete(v4);
  }
  else
  {
    uint64_t v12 = a1 + 1;
LABEL_9:
    std::__tree<std::__value_type<double,int>,std::__map_value_compare<double,std::__value_type<double,int>,std::less<double>,true>,std::allocator<std::__value_type<double,int>>>::__insert_node_at(a1, (uint64_t)v12, v10, (uint64_t *)v4);
  }
}

float32x4_t *RampGainMono(float32x4_t *result, float32x4_t *a2, int a3, float *a4, float a5, float32x4_t a6)
{
  a6.f32[0] = *a4;
  if (a3 >= 12)
  {
    float32x4_t v6 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a6.f32, 0);
    float32x4_t v7 = vaddq_f32(vmulq_n_f32((float32x4_t)xmmword_1BB879D50, a5), v6);
    v6.f32[0] = a5 * 4.0;
    a6 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 0);
    float32x4_t v8 = *result;
    float32x4_t v9 = result[1];
    result += 2;
    float32x4_t v10 = vmulq_f32(v7, v8);
    float32x4_t v11 = vaddq_f32(a6, v7);
    a3 -= 8;
    do
    {
      uint64_t v12 = a2;
      *a2++ = v10;
      float32x4_t v10 = vmulq_f32(v11, v9);
      float32x4_t v11 = vaddq_f32(a6, v11);
      float32x4_t v13 = *result++;
      float32x4_t v9 = v13;
      a3 -= 4;
    }
    while (a3 > 3);
    a6.i32[0] = vaddq_f32(a6, v11).u32[0];
    *a2 = v10;
    a2[1] = vmulq_f32(v11, v9);
    a2 = v12 + 3;
  }
  if (a3 >= 1)
  {
    unsigned int v14 = a3 + 1;
    do
    {
      float v15 = result->f32[0];
      CFTypeID result = (float32x4_t *)((char *)result + 4);
      a2->f32[0] = a6.f32[0] * v15;
      a2 = (float32x4_t *)((char *)a2 + 4);
      a6.f32[0] = a6.f32[0] + a5;
      --v14;
    }
    while (v14 > 1);
  }
  *a4 = a6.f32[0];
  return result;
}

NeuralNet *std::unique_ptr<NeuralNet>::reset[abi:ne180100](NeuralNet **a1, NeuralNet *a2)
{
  CFTypeID result = *a1;
  *a1 = a2;
  if (result)
  {
    NeuralNet::~NeuralNet(result);
    JUMPOUT(0x1C185D370);
  }
  return result;
}

uint64_t DictionaryBlobReader::ReadScalarFromDictionary<double>(NSObject ***a1, CFDictionaryRef theDict, const __CFString *key, uint64_t *a4)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, key);
  if (Value)
  {
    CFNumberGetValue(Value, kCFNumberFloat64Type, a4);
    float32x4_t v8 = *a1;
    if (*a1)
    {
      float32x4_t v9 = *v8;
      if (!*v8) {
        return 0;
      }
    }
    else
    {
      float32x4_t v9 = MEMORY[0x1E4F14500];
    }
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      CStringPtr = CFStringGetCStringPtr(key, 0x8000100u);
      uint64_t v14 = *a4;
      int v16 = 136315906;
      uint64_t v17 = "DictionaryBlobReader.hpp";
      __int16 v18 = 1024;
      int v19 = 71;
      __int16 v20 = 2080;
      uint64_t v21 = CStringPtr;
      __int16 v22 = 2048;
      uint64_t v23 = v14;
      _os_log_impl(&dword_1BB0CE000, v9, OS_LOG_TYPE_DEBUG, "%25s:%-5d Successfully retrieved %s (%g).", (uint8_t *)&v16, 0x26u);
    }
    return 0;
  }
  uint64_t v10 = 4294900555;
  float32x4_t v11 = *a1;
  if (*a1)
  {
    uint64_t v12 = *v11;
    if (!*v11) {
      return v10;
    }
  }
  else
  {
    uint64_t v12 = MEMORY[0x1E4F14500];
  }
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    int v16 = 136315650;
    uint64_t v17 = "DictionaryBlobReader.hpp";
    __int16 v18 = 1024;
    int v19 = 65;
    __int16 v20 = 2080;
    uint64_t v21 = CFStringGetCStringPtr(key, 0x8000100u);
    _os_log_impl(&dword_1BB0CE000, v12, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Failed to retrieve %s.", (uint8_t *)&v16, 0x1Cu);
  }
  return v10;
}

uint64_t DictionaryBlobReader::ReadScalarFromDictionary<unsigned int>(uint64_t **a1, CFDictionaryRef theDict, const __CFString *key, _DWORD *a4)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, key);
  if (Value)
  {
    CFNumberGetValue(Value, kCFNumberIntType, a4);
    float32x4_t v8 = *a1;
    if (*a1)
    {
      uint64_t v9 = *v8;
      if (!*v8) {
        return v9;
      }
    }
    else
    {
      uint64_t v9 = MEMORY[0x1E4F14500];
    }
    if (os_log_type_enabled((os_log_t)v9, OS_LOG_TYPE_DEBUG))
    {
      CStringPtr = CFStringGetCStringPtr(key, 0x8000100u);
      LODWORD(v13) = *a4;
      int v15 = 136315906;
      int v16 = "DictionaryBlobReader.hpp";
      __int16 v17 = 1024;
      int v18 = 71;
      __int16 v19 = 2080;
      __int16 v20 = CStringPtr;
      __int16 v21 = 2048;
      double v22 = (double)v13;
      _os_log_impl(&dword_1BB0CE000, (os_log_t)v9, OS_LOG_TYPE_DEBUG, "%25s:%-5d Successfully retrieved %s (%g).", (uint8_t *)&v15, 0x26u);
    }
    return 0;
  }
  else
  {
    uint64_t v9 = 4294900555;
    uint64_t v10 = (NSObject **)*a1;
    if (*a1)
    {
      float32x4_t v11 = *v10;
      if (!*v10) {
        return v9;
      }
    }
    else
    {
      float32x4_t v11 = MEMORY[0x1E4F14500];
    }
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      int v15 = 136315650;
      int v16 = "DictionaryBlobReader.hpp";
      __int16 v17 = 1024;
      int v18 = 65;
      __int16 v19 = 2080;
      __int16 v20 = CFStringGetCStringPtr(key, 0x8000100u);
      _os_log_impl(&dword_1BB0CE000, v11, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Failed to retrieve %s.", (uint8_t *)&v15, 0x1Cu);
    }
  }
  return v9;
}

uint64_t DictionaryBlobReader::ReadScalarFromDictionary<float>(uint64_t **a1, CFDictionaryRef theDict, const __CFString *key, CFNumberType a4, float *a5)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, key);
  if (Value)
  {
    CFNumberGetValue(Value, a4, a5);
    uint64_t v10 = *a1;
    if (*a1)
    {
      uint64_t v11 = *v10;
      if (!*v10) {
        return v11;
      }
    }
    else
    {
      uint64_t v11 = MEMORY[0x1E4F14500];
    }
    if (os_log_type_enabled((os_log_t)v11, OS_LOG_TYPE_DEBUG))
    {
      CStringPtr = CFStringGetCStringPtr(key, 0x8000100u);
      double v15 = *a5;
      int v17 = 136315906;
      int v18 = "DictionaryBlobReader.hpp";
      __int16 v19 = 1024;
      int v20 = 71;
      __int16 v21 = 2080;
      double v22 = CStringPtr;
      __int16 v23 = 2048;
      double v24 = v15;
      _os_log_impl(&dword_1BB0CE000, (os_log_t)v11, OS_LOG_TYPE_DEBUG, "%25s:%-5d Successfully retrieved %s (%g).", (uint8_t *)&v17, 0x26u);
    }
    return 0;
  }
  else
  {
    uint64_t v11 = 4294900555;
    uint64_t v12 = (NSObject **)*a1;
    if (*a1)
    {
      unint64_t v13 = *v12;
      if (!*v12) {
        return v11;
      }
    }
    else
    {
      unint64_t v13 = MEMORY[0x1E4F14500];
    }
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = 136315650;
      int v18 = "DictionaryBlobReader.hpp";
      __int16 v19 = 1024;
      int v20 = 65;
      __int16 v21 = 2080;
      double v22 = CFStringGetCStringPtr(key, 0x8000100u);
      _os_log_impl(&dword_1BB0CE000, v13, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Failed to retrieve %s.", (uint8_t *)&v17, 0x1Cu);
    }
  }
  return v11;
}

void NeuralNetRES::NeuralNetRES(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)(a1 + 56) = 0u;
  *(_DWORD *)(a1 + 36) = 629145600;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(void *)(a1 + 216) = a3;
  operator new();
}

void sub_1BB386968(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void **a11)
{
  __int16 v19 = *v17;
  if (*v17)
  {
    v11[25] = v19;
    operator delete(v19);
  }
  int v20 = *v16;
  if (*v16)
  {
    v11[22] = v20;
    operator delete(v20);
  }
  std::unique_ptr<NeuralNet>::reset[abi:ne180100](v14, 0);
  __int16 v21 = *v15;
  if (*v15)
  {
    v11[17] = v21;
    operator delete(v21);
  }
  double v22 = *v13;
  if (*v13)
  {
    v11[14] = v22;
    operator delete(v22);
  }
  __int16 v23 = *a11;
  if (*a11)
  {
    v11[11] = v23;
    operator delete(v23);
  }
  double v24 = *v12;
  if (*v12)
  {
    v11[8] = v24;
    operator delete(v24);
  }
  _Unwind_Resume(a1);
}

void NeuralNetRES::Cleanup(NeuralNetRES *this)
{
  (*(void (**)(void))(***((void ***)this + 19) + 48))(**((void **)this + 19));
  bzero(*((void **)this + 7), *((void *)this + 8) - *((void *)this + 7));
  bzero(*((void **)this + 10), *((void *)this + 11) - *((void *)this + 10));
  bzero(*((void **)this + 13), *((void *)this + 14) - *((void *)this + 13));
  bzero(*((void **)this + 16), *((void *)this + 17) - *((void *)this + 16));
  bzero(*((void **)this + 21), *((void *)this + 22) - *((void *)this + 21));
  uint64_t v2 = (void *)*((void *)this + 24);
  size_t v3 = *((void *)this + 25) - (void)v2;

  bzero(v2, v3);
}

void NeuralNetRES::ProcessBufferList(NeuralNetRES *this, const AudioBufferList *a2, const AudioBufferList *a3, AudioBufferList *a4, float a5, int a6, int a7, float a8)
{
  float v52 = a5;
  uint64_t mNumberBuffers = a2->mNumberBuffers;
  float v17 = *((float *)this + 7);
  float v18 = *((float *)this + 8);
  vDSP_vclr(*((float **)this + 7), 1, *((unsigned int *)this + 10));
  vDSP_vclr(*((float **)this + 13), 1, *((unsigned int *)this + 10));
  if (!mNumberBuffers) {
    goto LABEL_9;
  }
  unsigned int v19 = 0;
  float v20 = v17 * v17;
  p_mData = &a3->mBuffers[0].mData;
  double v22 = &a2->mBuffers[0].mData;
  do
  {
    if (!a7
      || (float)((float)(v20
                       * cblas_sdsdot(2 * *((_DWORD *)this + 2), 0.0, (const float *)*v22, 1, (const float *)*v22, 1))
               / (float)*((unsigned int *)this + 10)) >= a8)
    {
      __int16 v23 = (float *)*v22;
      uint64_t v24 = *((unsigned int *)this + 2);
      uint64_t v25 = (float *)((char *)*v22 + 4 * v24);
      uint64_t v26 = (float *)*p_mData;
      unint64_t v27 = (float *)((char *)*p_mData + 4 * v24);
      __A.realp = (float *)((char *)*v22 + 4);
      __A.imagp = v25 + 1;
      float v28 = *v23;
      uint64_t v29 = *((void *)this + 7);
      *(float *)uint64_t v29 = *(float *)v29 + (float)(v28 * v28);
      float v30 = *v26;
      v50.realp = v26 + 1;
      BOOL v31 = (float *)*((void *)this + 13);
      *BOOL v31 = *v31 + (float)(v30 * v30);
      *(float *)(v29 + 4 * v24) = *(float *)(v29 + 4 * v24) + (float)(*v25 * *v25);
      float v32 = *v27;
      v50.imagp = v27 + 1;
      ++v19;
      v31[v24] = v31[v24] + (float)(v32 * v32);
      vDSP_zvmgsa(&__A, 1, (const float *)(v29 + 4), 1, (float *)(v29 + 4), 1, (v24 - 1));
      vDSP_zvmgsa(&v50, 1, (const float *)(*((void *)this + 13) + 4), 1, (float *)(*((void *)this + 13) + 4), 1, (*((_DWORD *)this + 2) - 1));
    }
    p_mData += 2;
    v22 += 2;
    --mNumberBuffers;
  }
  while (mNumberBuffers);
  vDSP_Length v33 = *((unsigned int *)this + 10);
  if (v19)
  {
    *(float *)&__A.realp = v20 / (float)v19;
    *(float *)&v50.realp = (float)(v18 * v18) / (float)v19;
    vDSP_vsmul(*((const float **)this + 7), 1, (const float *)&__A, *((float **)this + 7), 1, v33);
    vDSP_vsmul(*((const float **)this + 13), 1, (const float *)&v50, *((float **)this + 13), 1, *((unsigned int *)this + 10));
LABEL_9:
    LODWORD(v33) = *((_DWORD *)this + 10);
  }
  if (*((float *)this + 5) > 0.0)
  {
    vDSP_vsmsma(*((const float **)this + 10), 1, (const float *)this + 5, *((const float **)this + 7), 1, (const float *)this + 6, *((float **)this + 10), 1, v33);
    vDSP_vsmsma(*((const float **)this + 16), 1, (const float *)this + 5, *((const float **)this + 13), 1, (const float *)this + 6, *((float **)this + 16), 1, *((unsigned int *)this + 10));
    LODWORD(v33) = *((_DWORD *)this + 10);
  }
  float __C = 0.0;
  vDSP_meanv(*((const float **)this + 13), 1, &__C, v33);
  if (__C <= *((float *)this + 9))
  {
    LODWORD(__A.realp) = 1065353216;
    vDSP_vfill((const float *)&__A, *((float **)this + 24), 1, *((unsigned int *)this + 10));
    if (a4->mNumberBuffers)
    {
      unint64_t v35 = 0;
      uint64_t v36 = 16;
      do
      {
        memcpy(*(void **)((char *)&a4->mNumberBuffers + v36), *(const void **)((char *)&a2->mNumberBuffers + v36), 4 * (2 * *((_DWORD *)this + 2)));
        ++v35;
        v36 += 16;
      }
      while (v35 < a4->mNumberBuffers);
    }
  }
  else
  {
    vDSP_vclr(*((float **)this + 21), 1, *((unsigned int *)this + 40));
    sparse_matrix_vector_product_dense_float(CblasNoTrans, 1.0, *((sparse_matrix_float *)this + 6), *((const float **)this + 7), 1, *((float **)this + 21), 1);
    sparse_matrix_vector_product_dense_float(CblasNoTrans, 1.0, *((sparse_matrix_float *)this + 6), *((const float **)this + 13), 1, (float *)(*((void *)this + 21) + 4 * *((unsigned int *)this + 11)), 1);
    if (*((float *)this + 5) > 0.0)
    {
      sparse_matrix_vector_product_dense_float(CblasNoTrans, 1.0, *((sparse_matrix_float *)this + 6), *((const float **)this + 10), 1, (float *)(*((void *)this + 21) + 4 * (2 * *((_DWORD *)this + 11))), 1);
      sparse_matrix_vector_product_dense_float(CblasNoTrans, 1.0, *((sparse_matrix_float *)this + 6), *((const float **)this + 16), 1, (float *)(*((void *)this + 21) + 4 * (3 * *((_DWORD *)this + 11))), 1);
    }
    vDSP_vthr(*((const float **)this + 21), 1, (const float *)this + 9, *((float **)this + 21), 1, *((unsigned int *)this + 40));
    int v48 = *((_DWORD *)this + 40);
    vvlogf(*((float **)this + 21), *((const float **)this + 21), &v48);
    unint64_t v34 = (const float **)(*(uint64_t (**)(void, char *))(***((void ***)this + 19) + 72))(**((void **)this + 19), (char *)this + 168);
    float v46 = 1.0;
    float __B = 0.0;
    vDSP_vclip(*v34, 1, &__B, &v46, *((float **)this + 24), 1, *((unsigned int *)this + 10));
    if (a6)
    {
      vDSP_vthr(*((const float **)this + 24), 1, &v52, *((float **)this + 24), 1, *((unsigned int *)this + 10));
    }
    else
    {
      *(float *)&__A.realp = 1.0 - a5;
      vDSP_vsmsa(*((const float **)this + 24), 1, (const float *)&__A, &v52, *((float **)this + 24), 1, *((unsigned int *)this + 10));
    }
    if (a4->mNumberBuffers)
    {
      unint64_t v37 = 0;
      uint64_t v38 = 16;
      do
      {
        BOOL v39 = *(float **)((char *)&a2->mNumberBuffers + v38);
        uint64_t v40 = *((unsigned int *)this + 2);
        float v41 = &v39[v40];
        BOOL v42 = *(float **)((char *)&a4->mNumberBuffers + v38);
        __A.realp = v39 + 1;
        __A.imagp = v41 + 1;
        unsigned int v43 = &v42[v40];
        float v44 = *v39;
        uint64_t v45 = *((void *)this + 24);
        *BOOL v42 = v44 * *(float *)v45;
        v50.realp = v42 + 1;
        *unsigned int v43 = *v41 * *(float *)(v45 + 4 * v40);
        v50.imagp = v43 + 1;
        vDSP_zrvmul(&__A, 1, (const float *)(v45 + 4), 1, &v50, 1, (v40 - 1));
        ++v37;
        v38 += 16;
      }
      while (v37 < a4->mNumberBuffers);
    }
  }
}

void std::vector<TimeStampedEvent<unsigned int>>::reserve(void **a1, unint64_t a2)
{
  if (0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3) < a2)
  {
    uint64_t v3 = ((unsigned char *)a1[1] - (unsigned char *)*a1) / 24;
    CFIndex v4 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<AUPropertyItem>>(a2);
    unsigned int v5 = &v4[24 * v3];
    float32x4_t v7 = &v4[24 * v6];
    uint64_t v9 = (char *)*a1;
    float32x4_t v8 = (char *)a1[1];
    uint64_t v10 = v5;
    if (v8 != *a1)
    {
      do
      {
        long long v11 = *(_OWORD *)(v8 - 24);
        *((void *)v10 - 1) = *((void *)v8 - 1);
        *(_OWORD *)(v10 - 24) = v11;
        v10 -= 24;
        v8 -= 24;
      }
      while (v8 != v9);
      float32x4_t v8 = (char *)*a1;
    }
    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

void std::default_delete<MRRingBuffer<AUEndpointVAD3_Decision>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (v1) {
    MEMORY[0x1C185D340](v1, 0x1000C8052888210);
  }

  JUMPOUT(0x1C185D370);
}

void MRRingBuffer<DataTimeStamp>::MRRingBuffer()
{
}

void std::default_delete<MRRingBuffer<DataTimeStamp>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (v1) {
    MEMORY[0x1C185D340](v1, 0x1000C80451B5BE8);
  }

  JUMPOUT(0x1C185D370);
}

double MRRingBuffer<DataTimeStamp>::GetSample(uint64_t a1, int a2)
{
  if (a2 < 0) {
    int v2 = *(_DWORD *)(a1 + 8) + ~((*(_DWORD *)(a1 + 8) - a2 + ~*(_DWORD *)(a1 + 12)) % *(_DWORD *)(a1 + 8));
  }
  else {
    int v2 = (*(_DWORD *)(a1 + 12) + a2) % *(_DWORD *)(a1 + 8);
  }
  return *(double *)(*(void *)a1 + 16 * v2);
}

void CircularDelay::Reset(CircularDelay *this)
{
  int v2 = (void *)*((void *)this + 2);
  uint64_t v3 = *((void *)this + 3) - (void)v2;
  if (v3 >= 1) {
    bzero(v2, 4 * (((unint64_t)v3 >> 2) - ((unint64_t)v3 > 3)) + 4);
  }
  *((void *)this + 5) = 0;
  uint64_t v4 = *((void *)this + 1);
  if ((int)v4 < 1) {
    uint64_t v5 = -v4;
  }
  else {
    uint64_t v5 = *(_DWORD *)this - (int)v4;
  }
  *((void *)this + 6) = v5;
}

uint64_t SpatialMetadata_SetData(uint64_t a1, _DWORD *a2, unsigned int a3)
{
  if (!a1) {
    return 1651664230;
  }
  if (!a2) {
    return 1650553447;
  }
  unint64_t v3 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 56) - *(void *)(a1 + 48)) >> 2);
  if (4 * ((uint64_t)(*(void *)(a1 + 56) - *(void *)(a1 + 48)) >> 2) + 64 > a3 || a2[1] != a3)
  {
    exceptiouint64_t n = __cxa_allocate_exception(4uLL);
    int v16 = 1650750330;
    goto LABEL_12;
  }
  uint64_t v4 = a2[3];
  if (v3 != v4)
  {
    exceptiouint64_t n = __cxa_allocate_exception(4uLL);
    int v16 = 1650682979;
LABEL_12:
    _DWORD *exception = v16;
  }
  uint64_t v5 = a2[4];
  uint64_t v6 = (long long *)((char *)a2 + a2[2]);
  long long v7 = *v6;
  long long v8 = v6[1];
  *(_OWORD *)(a1 + 28) = *(long long *)((char *)v6 + 28);
  *(_OWORD *)a1 = v7;
  *(_OWORD *)(a1 + 16) = v8;
  if (v4)
  {
    uint64_t v9 = 0;
    uint64_t v10 = (char *)a2 + v5;
    do
    {
      uint64_t v11 = *(void *)(a1 + 48) + v9;
      long long v12 = *(_OWORD *)&v10[v9];
      *(_DWORD *)(v11 + 16) = *(_DWORD *)&v10[v9 + 16];
      *(_OWORD *)uint64_t v11 = v12;
      v9 += 20;
      --v3;
    }
    while (v3);
  }
  return 0;
}

void sub_1BB3873DC(void *a1)
{
}

uint64_t SpatialMetadata_GetData(long long *a1, uint64_t a2, unsigned int *a3)
{
  if (!a1) {
    return 1651664230;
  }
  uint64_t v3 = 1650553447;
  if (a2 && a3)
  {
    unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)a1 + 7) - *((void *)a1 + 6)) >> 2);
    unsigned int v5 = 4 * ((uint64_t)(*((void *)a1 + 7) - *((void *)a1 + 6)) >> 2) + 64;
    if (v5 > *a3)
    {
      exceptiouint64_t n = __cxa_allocate_exception(4uLL);
      _DWORD *exception = 1650750330;
    }
    *a3 = v5;
    *(_DWORD *)a2 = 1;
    *(_DWORD *)(a2 + 4) = v5;
    *(_DWORD *)(a2 + 8) = 20;
    *(_DWORD *)(a2 + 12) = v4;
    *(_DWORD *)(a2 + 16) = 64;
    long long v6 = *a1;
    long long v7 = a1[1];
    *(_OWORD *)(a2 + 48) = *(long long *)((char *)a1 + 28);
    *(_OWORD *)(a2 + 36) = v7;
    *(_OWORD *)(a2 + 20) = v6;
    if (v4)
    {
      uint64_t v8 = 0;
      uint64_t v9 = 20 * v4;
      do
      {
        uint64_t v10 = a2 + 64 + v8;
        uint64_t v11 = (long long *)(*((void *)a1 + 6) + v8);
        long long v12 = *v11;
        *(_DWORD *)(v10 + 16) = *((_DWORD *)v11 + 4);
        *(_OWORD *)uint64_t v10 = v12;
        v8 += 20;
      }
      while (v9 != v8);
    }
    return 0;
  }
  return v3;
}

void sub_1BB387518(void *a1)
{
}

uint64_t SpatialMetadata_GetDataSize(uint64_t a1, _DWORD *a2)
{
  if (!a1) {
    return 1651664230;
  }
  if (!a2) {
    return 1650553447;
  }
  uint64_t result = 0;
  *a2 = ((*(_DWORD *)(a1 + 56) - *(_DWORD *)(a1 + 48)) & 0xFFFFFFFC) + 64;
  return result;
}

uint64_t SpatialMetadata_SetProperty(uint64_t a1, int a2, _anonymous_namespace_::SpatialMetadata *this, unsigned int *a4, int a5)
{
  if (!a1) {
    return 1651664230;
  }
  if (!a4) {
    return 1650553447;
  }
  uint64_t result = 1651536496;
  switch(a2)
  {
    case 0:
      uint64_t result = 0;
      *(_DWORD *)a1 = v8;
      return result;
    case 1:
      if (a5 != 4) {
        goto LABEL_30;
      }
      unsigned int v26 = *a4;
      uint64_t result = 0;
      *(_DWORD *)(a1 + 4) = v26;
      return result;
    case 2:
      if (a5 != 4) {
        goto LABEL_30;
      }
      unsigned int v21 = *a4;
      uint64_t result = 0;
      *(_DWORD *)(a1 + 8) = v21;
      return result;
    case 3:
      if (a5 != 4)
      {
LABEL_30:
        exceptiouint64_t n = __cxa_allocate_exception(4uLL);
        _DWORD *exception = 1651536762;
      }
      unsigned int v24 = *a4;
      uint64_t result = 0;
      *(_DWORD *)(a1 + 12) = v24;
      return result;
    case 4:
      uint64_t result = 0;
      *(float *)(a1 + 16) = v17;
      return result;
    case 5:
      uint64_t result = 0;
      *(float *)(a1 + 20) = v28;
      return result;
    case 6:
      uint64_t result = 0;
      *(float *)(a1 + 24) = v31;
      return result;
    case 7:
      uint64_t result = 0;
      *(float *)(a1 + 28) = v25;
      return result;
    case 8:
      uint64_t result = 0;
      *(float *)(a1 + 32) = v33;
      return result;
    case 9:
      uint64_t result = 0;
      *(float *)(a1 + 36) = v20;
      return result;
    case 10:
      uint64_t result = 0;
      char v19 = *ClientInfo & 0xFE | v32 & 1;
      goto LABEL_25;
    case 11:
      uint64_t result = 0;
      char v15 = 2 * (v13 & 1);
      char v16 = *ClientInfo & 0xFD;
      goto LABEL_10;
    case 12:
      uint64_t result = 0;
      char v15 = 4 * (v18 & 1);
      char v16 = *ClientInfo & 0xFB;
LABEL_10:
      char v19 = v16 | v15;
LABEL_25:
      unsigned char *ClientInfo = v19;
      break;
    case 13:
      uint64_t result = 0;
      *(float *)(v30 + 4) = v29;
      break;
    case 14:
      uint64_t result = 0;
      *(float *)(v12 + 8) = v11;
      break;
    case 15:
      uint64_t result = 0;
      *(float *)(v23 + 12) = v22;
      break;
    case 16:
      uint64_t result = 0;
      *(_DWORD *)(v10 + 16) = v9;
      break;
    case 17:
      uint64_t result = 0;
      *(unsigned char *)(a1 + 40) = *(unsigned char *)(a1 + 40) & 0xFE | v27 & 1;
      break;
    default:
      return result;
  }
  return result;
}

void sub_1BB387914(void *a1)
{
}

uint64_t anonymous namespace'::DataView::operator unsigned int<unsigned int>(unsigned int *a1, int a2)
{
  if (a2 != 4)
  {
    exceptiouint64_t n = __cxa_allocate_exception(4uLL);
    _DWORD *exception = 1651536762;
  }
  return *a1;
}

uint64_t anonymous namespace'::SpatialMetadata::getGlobalInfo(uint64_t this)
{
  if (this)
  {
    exceptiouint64_t n = __cxa_allocate_exception(4uLL);
    _DWORD *exception = 1650814061;
  }
  return this;
}

float anonymous namespace'::DataView::operator float<float>(uint64_t a1, int a2)
{
  if (a2 != 4)
  {
    exceptiouint64_t n = __cxa_allocate_exception(4uLL);
    _DWORD *exception = 1651536762;
  }
  return *(float *)a1;
}

uint64_t anonymous namespace'::SpatialMetadata::getClientInfo(_anonymous_namespace_::SpatialMetadata *this, uint64_t a2, unsigned int a3)
{
  if (0xCCCCCCCCCCCCCCCDLL * ((a2 - (uint64_t)this) >> 2) <= a3)
  {
    exceptiouint64_t n = __cxa_allocate_exception(4uLL);
    _DWORD *exception = 1650814061;
  }
  return (uint64_t)this + 20 * a3;
}

uint64_t SpatialMetadata_GetProperty(uint64_t a1, int a2, _anonymous_namespace_::SpatialMetadata *this, _DWORD *a4, _DWORD *a5)
{
  if (!a1) {
    return 1651664230;
  }
  uint64_t v6 = 1650553447;
  if (a4 && a5)
  {
    uint64_t v6 = 1651536496;
    uint64_t v8 = a1;
    switch(a2)
    {
      case 0:
        goto LABEL_7;
      case 1:
        if (*a5 < 4u) {
          goto LABEL_32;
        }
        uint64_t v6 = 0;
        *a5 = 4;
        int v10 = *(_DWORD *)(v8 + 4);
        goto LABEL_21;
      case 2:
        if (*a5 < 4u) {
          goto LABEL_32;
        }
        uint64_t v6 = 0;
        *a5 = 4;
        int v10 = *(_DWORD *)(v8 + 8);
        goto LABEL_21;
      case 3:
        if (*a5 <= 3u)
        {
LABEL_32:
          exceptiouint64_t n = __cxa_allocate_exception(4uLL);
          _DWORD *exception = 1651536762;
        }
        uint64_t v6 = 0;
        *a5 = 4;
        int v10 = *(_DWORD *)(v8 + 12);
LABEL_21:
        *a4 = v10;
        return v6;
      case 4:
        int v9 = (_DWORD *)(v8 + 16);
        goto LABEL_28;
      case 5:
        int v9 = (_DWORD *)(v8 + 20);
        goto LABEL_28;
      case 6:
        int v9 = (_DWORD *)(v8 + 24);
        goto LABEL_28;
      case 7:
        int v9 = (_DWORD *)(v8 + 28);
        goto LABEL_28;
      case 8:
        int v9 = (_DWORD *)(v8 + 32);
        goto LABEL_28;
      case 9:
        int v9 = (_DWORD *)(v8 + 36);
        goto LABEL_28;
      case 10:
        goto LABEL_29;
      case 11:
        goto LABEL_29;
      case 12:
        goto LABEL_29;
      case 13:
        goto LABEL_28;
      case 14:
        goto LABEL_28;
      case 15:
LABEL_28:
        goto LABEL_29;
      case 16:
LABEL_7:
        goto LABEL_29;
      case 17:
        int v13 = *(unsigned char *)(v8 + 40) & 1;
LABEL_29:
        uint64_t v6 = 0;
        break;
      default:
        return v6;
    }
  }
  return v6;
}

void sub_1BB387D44(void *a1)
{
}

_DWORD *anonymous namespace'::MutableDataView::operator=<unsigned int>(_DWORD *result, _DWORD *a2, _DWORD *a3)
{
  if (*a2 <= 3u)
  {
    exceptiouint64_t n = __cxa_allocate_exception(4uLL);
    _DWORD *exception = 1651536762;
  }
  *a2 = 4;
  *uint64_t result = *a3;
  return result;
}

uint64_t SpatialMetadata_Destroy(uint64_t a1)
{
  if (!a1) {
    return 1651664230;
  }
  int v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
  MEMORY[0x1C185D370](a1, 0x1020C40D5999051);
  return 0;
}

uint64_t SpatialMetadata_Create(uint64_t a1, int a2)
{
  if (a2) {
    operator new();
  }
  return 1650553447;
}

uint64_t AUBSS1::ValidFormat(AUBSS1 *this, const AudioStreamBasicDescription *a2, int a3, AudioStreamBasicDescription *a4)
{
  if ((a2 - 1) > 1) {
    return 0;
  }
  uint64_t v16 = v4;
  uint64_t v17 = v5;
  UInt32 mChannelsPerFrame = a4->mChannelsPerFrame;
  if (a2 == 1 && mChannelsPerFrame < 2) {
    return 0;
  }
  if (a2 == 2 && !a3 && mChannelsPerFrame < 2) {
    return 0;
  }
  BOOL v8 = mChannelsPerFrame > 1 && a3 == 1;
  BOOL v9 = v8 && a2 == 2;
  if (v9 || mChannelsPerFrame > 2) {
    return 0;
  }
  uint64_t result = ausdk::ASBD::IsCommonFloat32((ausdk::ASBD *)a4, a2);
  if (result)
  {
    if ((a4->mFormatFlags & 0x20) != 0) {
      return 1;
    }
    uint64_t result = mChannelsPerFrame == 1;
  }
  if ((result & 1) == 0 && a4->mFormatID == 1718773105)
  {
    long long v12 = *(_OWORD *)&a4->mBytesPerPacket;
    v13[0] = *(_OWORD *)&a4->mSampleRate;
    v13[1] = v12;
    uint64_t v14 = *(void *)&a4->mBitsPerChannel;
    DWORD2(v13[0]) = 1819304813;
    int v15 = 0;
    LODWORD(result) = CAStreamBasicDescription::IdentifyCommonPCMFormat(v13, &v15, 0);
    if (v15 == 4) {
      return result;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t AUBSS1::SupportedNumChannels(AUBSS1 *this, const AUChannelInfo **a2)
{
  if (a2) {
    *a2 = (const AUChannelInfo *)&AUBSS1::SupportedNumChannels(AUChannelInfo const**)::sSupportedChannelConfigs;
  }
  return 2;
}

BOOL AUBSS1::StreamFormatWritable(AUBSS1 *this)
{
  return *((unsigned char *)this + 17) == 0;
}

uint64_t AUBSS1::SupportsTail(AUBSS1 *this)
{
  return 1;
}

double AUBSS1::GetTailTime(AUBSS1 *this)
{
  return 0.0;
}

double AUBSS1::GetLatency(AUBSS1 *this)
{
  if (*((unsigned char *)this + 376))
  {
    double result = 0.0;
    if (*((unsigned char *)this + 528)) {
      return result;
    }
    double v3 = *(double *)(ausdk::AUScope::SafeGetElement((AUBSS1 *)((char *)this + 128), 0) + 80);
    LODWORD(v4) = *((_DWORD *)this + 84);
    double v5 = (double)v4;
  }
  else
  {
    double v3 = *(double *)(ausdk::AUScope::SafeGetElement((AUBSS1 *)((char *)this + 128), 0) + 80);
    if (v3 == 16000.0)
    {
      uint64_t v6 = 0x4078000000000000;
    }
    else if (v3 == 8000.0)
    {
      uint64_t v6 = 0x4068000000000000;
    }
    else if (v3 == 24000.0)
    {
      uint64_t v6 = 0x407E000000000000;
    }
    else
    {
      if (v3 != 48000.0)
      {
        double v5 = 384.0;
        if (v3 == 44100.0) {
          double v5 = 960.0;
        }
        return v5 / v3;
      }
      uint64_t v6 = 0x408E000000000000;
    }
    double v5 = *(double *)&v6;
  }
  return v5 / v3;
}

uint64_t AUBSS1::GetParameterValueStrings(AUBSS1 *this, int a2, int a3, const __CFArray **a4)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (a4)
  {
    if (a2) {
      return 4294956430;
    }
    if (a3 == 7)
    {
      *(_OWORD *)BOOL v9 = xmmword_1E623C730;
      CFArrayRef v7 = CFArrayCreate(0, (const void **)v9, 2, 0);
      uint64_t result = 0;
      *a4 = v7;
      return result;
    }
    return 0;
  }
  if (AUBSS1LogScope(void)::once != -1) {
    dispatch_once(&AUBSS1LogScope(void)::once, &__block_literal_global_2434);
  }
  if (AUBSS1LogScope(void)::scope)
  {
    double v5 = *(NSObject **)AUBSS1LogScope(void)::scope;
    if (!*(void *)AUBSS1LogScope(void)::scope) {
      return 0;
    }
  }
  else
  {
    double v5 = MEMORY[0x1E4F14500];
  }
  BOOL v8 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (!v8) {
    return result;
  }
  *(_DWORD *)BOOL v9 = 136315394;
  *(void *)&v9[4] = "AUBSS1.cpp";
  *(_WORD *)&v9[12] = 1024;
  *(_DWORD *)&v9[14] = 658;
  _os_log_impl(&dword_1BB0CE000, v5, OS_LOG_TYPE_DEFAULT, "%25s:%-5d ERROR: Failed accessing strings in GetParameterValueStrings.", v9, 0x12u);
  return 0;
}

void ___ZL14AUBSS1LogScopev_block_invoke()
{
}

uint64_t AUBSS1::RestoreState(OpaqueAudioComponentInstance **this, const void *a2)
{
  uint64_t result = ausdk::AUBase::RestoreState(this, a2);
  if (!result) {
    ++*((_DWORD *)this + 133);
  }
  return result;
}

uint64_t AUBSS1::GetParameterInfo(AUBSS1 *this, int a2, int a3, AudioUnitParameterInfo *buffer)
{
  if (a2) {
    return 4294956430;
  }
  buffer->flags = 0;
  buffer->unitName = 0;
  switch(a3)
  {
    case 0:
      CFStringRef v6 = @"Bypass BSS";
      goto LABEL_7;
    case 1:
      CFStringRef v6 = @"Run MDNS (Test only)";
LABEL_7:
      buffer->cfNameString = v6;
      buffer->flags = 0x8000000;
      CFStringGetCString(v6, buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_Boolean;
      *(void *)&buffer->minCFNumberRef Value = 0x3F80000000000000;
      buffer->defaultCFNumberRef Value = 0.0;
      goto LABEL_17;
    case 2:
      buffer->cfNameString = @"Scaling";
      buffer->flags = 0x8000000;
      CFStringGetCString(@"Scaling", buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_LinearGain;
      buffer->defaultCFNumberRef Value = 1.0;
      uint64_t v7 = 0x461C400000000000;
      goto LABEL_16;
    case 3:
      int v8 = 1073774592;
      CFStringRef v9 = @"+X Separation";
      goto LABEL_11;
    case 4:
      int v8 = 1073774592;
      CFStringRef v9 = @"-X Separation";
LABEL_11:
      buffer->cfNameString = v9;
      buffer->flags = 0x8000000;
      CFStringGetCString(v9, buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      buffer->defaultCFNumberRef Value = 0.0;
      uint64_t v10 = 0x41A0000000000000;
      goto LABEL_14;
    case 5:
      int v8 = 1073774592;
      buffer->cfNameString = @"Update Threshold";
      buffer->flags = 0x8000000;
      CFStringGetCString(@"Update Threshold", buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      buffer->defaultCFNumberRef Value = 0.0;
      uint64_t v10 = 0x4120000000000000;
      goto LABEL_14;
    case 6:
      int v8 = 1073774592;
      buffer->cfNameString = @"Noise SPL Estimate";
      buffer->flags = 0x8000000;
      CFStringGetCString(@"Noise SPL Estimate", buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      buffer->defaultCFNumberRef Value = 40.0;
      uint64_t v10 = 0x42C8000041A00000;
LABEL_14:
      *(void *)&buffer->minCFNumberRef Value = v10;
      goto LABEL_18;
    case 7:
      buffer->cfNameString = @"Separation Mode";
      buffer->flags = 0x8000000;
      CFStringGetCString(@"Separation Mode", buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_Indexed;
      buffer->defaultCFNumberRef Value = 0.0;
      uint64_t v7 = 0x3F80000000000000;
LABEL_16:
      *(void *)&buffer->minCFNumberRef Value = v7;
LABEL_17:
      int v8 = -1073741824;
LABEL_18:
      uint64_t result = 0;
      buffer->flags |= v8;
      break;
    default:
      uint64_t result = 4294956418;
      break;
  }
  return result;
}

uint64_t AUBSS1::GetParameterList(AUBSS1 *this, int a2, unsigned int *a3, unsigned int *a4)
{
  if (a2)
  {
    unsigned int v4 = 0;
    uint64_t result = 4294956418;
  }
  else
  {
    uint64_t result = 0;
    if (a3)
    {
      *(_OWORD *)a3 = xmmword_1BB8727D0;
      *((_OWORD *)a3 + 1) = xmmword_1BB879D60;
    }
    unsigned int v4 = 8;
  }
  *a4 = v4;
  return result;
}

uint64_t AUBSS1::SetBusCount(AUBSS1 *this, int a2, unsigned int a3)
{
  if (a2 == 1 && a3 <= 2)
  {
    double v3 = (AUBSS1 *)((char *)this + 80);
LABEL_7:
    ausdk::AUScope::SetNumberOfElements(v3, a3);
    return 0;
  }
  uint64_t v4 = 4294956445;
  if (a2 == 2 && a3 <= 2)
  {
    double v3 = (AUBSS1 *)((char *)this + 128);
    goto LABEL_7;
  }
  return v4;
}

uint64_t AUBSS1::BusCountWritable(AUBSS1 *this)
{
  return 1;
}

uint64_t AUBSS1::Render(AUBSS1 *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  long long v8 = *(_OWORD *)&a3->mSampleTime;
  long long v9 = *(_OWORD *)&a3->mRateScalar;
  long long v10 = *(_OWORD *)&a3->mSMPTETime.mHours;
  *((_OWORD *)this + 44) = *(_OWORD *)&a3->mSMPTETime.mSubframes;
  *((_OWORD *)this + 45) = v10;
  *((_OWORD *)this + 42) = v8;
  *((_OWORD *)this + 43) = v9;
  if (*((unsigned char *)this + 376) && *((_DWORD *)this + 84) != a4) {
    return 4294956422;
  }
  uint64_t Element = ausdk::AUScope::GetElement((AUBSS1 *)((char *)this + 80), 0);
  if (!Element || !*(_DWORD *)(Element + 172)) {
    return 4294956420;
  }
  unsigned int v18 = 0;
  long long v12 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement((AUBSS1 *)((char *)this + 80), 0);
  uint64_t result = ausdk::AUInputElement::PullInput(v12, &v18, a3, 0, a4);
  if (!result)
  {
    uint64_t v14 = ausdk::AUScope::SafeGetElement((AUBSS1 *)((char *)this + 80), 0);
    uint64_t BufferList = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v14 + 144));
    uint64_t v16 = ausdk::AUScope::SafeGetElement((AUBSS1 *)((char *)this + 128), 0);
    uint64_t v17 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v16 + 144));
    return (*(uint64_t (**)(AUBSS1 *, unsigned int *, uint64_t, uint64_t, uint64_t))(*(void *)this + 176))(this, a2, BufferList, v17, a4);
  }
  return result;
}

uint64_t AUBSS1::ProcessMultipleBufferLists(AUBSS1 *this, unsigned int *a2, unsigned int a3, unsigned int a4, const AudioBufferList **a5, int a6, AudioBufferList **a7)
{
  int v12 = *((unsigned __int8 *)this + 376);
  if (*((unsigned char *)this + 376) && *((_DWORD *)this + 84) != a3) {
    return 4294956422;
  }
  uint64_t result = 4294956449;
  if (a5)
  {
    if (a7)
    {
      uint64_t result = 4294956428;
      if (a4 <= 2 && a4 == a6)
      {
        int v14 = *((_DWORD *)this + 137);
        int v15 = *a5;
        if (v14 == (*a5)->mNumberBuffers && v14 == (*a7)->mNumberBuffers)
        {
          if (*((_DWORD *)this + 135) || *((unsigned char *)this + 544))
          {
            if (v14)
            {
              uint64_t v16 = 0;
              unint64_t v17 = 0;
              do
              {
                memcpy((*a7)->mBuffers[v16].mData, v15->mBuffers[v16].mData, (*a7)->mBuffers[v16].mDataByteSize);
                ++v17;
                int v15 = *a5;
                ++v16;
              }
              while (v17 < (*a5)->mNumberBuffers);
            }
            if (a4 == 2)
            {
              unsigned int v18 = a7[1];
              if (v18->mNumberBuffers)
              {
                uint64_t v19 = 0;
                unint64_t v20 = 0;
                do
                {
                  memcpy(v18->mBuffers[v19].mData, a5[1]->mBuffers[v19].mData, v18->mBuffers[v19].mDataByteSize);
                  uint64_t result = 0;
                  ++v20;
                  unsigned int v18 = a7[1];
                  ++v19;
                }
                while (v20 < v18->mNumberBuffers);
                return result;
              }
            }
            return 0;
          }
          if (*((_DWORD *)this + 134) != *((_DWORD *)this + 133))
          {
            AUBSS1::UpdateState(this);
            *((_DWORD *)this + 134) = *((_DWORD *)this + 133);
            int v12 = *((unsigned __int8 *)this + 376);
          }
          if (v12)
          {
            if (*((unsigned char *)this + 528)) {
              AUBSS1::CopyToInternalBuffers(this, a3, a5);
            }
            else {
              AUBSS1::TimeToFreqAndCopyToInternalBuffers(this, a5);
            }
            AUBSS1::ScaleProcessInverseScale(this);
            if (*((unsigned char *)this + 528)) {
              AUBSS1::CopyFromInternalBuffers(this, a3, a7);
            }
            else {
              AUBSS1::FreqToTimeAndCopyFromInternalBuffers((uint64_t)this, a7);
            }
            if (a4 != 2) {
              return 0;
            }
            if (*((_DWORD *)this + 137) == a5[1]->mNumberBuffers && a7[1]->mNumberBuffers == 1) {
              return AUBSS1::SideChainProcess(this, a3, a5, a7);
            }
            else {
              return 4294956428;
            }
          }
          else
          {
            unsigned int v21 = (BlockProcessor *)*((void *)this + 74);
            if (v21)
            {
              return BlockProcessor::Process(v21, a3, a5, a7);
            }
            else
            {
              return 4294956429;
            }
          }
        }
      }
    }
  }
  return result;
}

void AUBSS1::UpdateState(AUBSS1 *this)
{
  int v2 = (AUBSS1 *)((char *)this + 32);
  uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUBSS1 *)((char *)this + 32), 0);
  *((unsigned char *)this + 648) = ausdk::AUElement::GetParameter(Element, 1u) != 0.0;
  uint64_t v4 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v2, 0);
  *((_DWORD *)this + 163) = ausdk::AUElement::GetParameter(v4, 0);
  double v5 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v2, 0);
  *((float *)this + 164) = ausdk::AUElement::GetParameter(v5, 2u);
  if (*((void *)this + 73))
  {
    CFStringRef v6 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v2, 0);
    float Parameter = ausdk::AUElement::GetParameter(v6, 3u);
    (*(void (**)(void, void, float))(**((void **)this + 73) + 48))(*((void *)this + 73), 0, Parameter);
    long long v8 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v2, 0);
    float v9 = ausdk::AUElement::GetParameter(v8, 4u);
    (*(void (**)(void, uint64_t, float))(**((void **)this + 73) + 48))(*((void *)this + 73), 1, v9);
    long long v10 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v2, 0);
    float v11 = ausdk::AUElement::GetParameter(v10, 5u);
    (*(void (**)(void, uint64_t, float))(**((void **)this + 73) + 48))(*((void *)this + 73), 2, v11);
    int v12 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v2, 0);
    float v13 = ausdk::AUElement::GetParameter(v12, 6u);
    (*(void (**)(void, uint64_t, float))(**((void **)this + 73) + 48))(*((void *)this + 73), 3, v13);
    int v14 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v2, 0);
    v15.n128_f32[0] = ausdk::AUElement::GetParameter(v14, 7u);
    uint64_t v16 = *(void (**)(__n128))(**((void **)this + 73) + 48);
    v16(v15);
  }
}

float AUBSS1::TimeToFreqAndCopyToInternalBuffers(AUBSS1 *this, const AudioBufferList **a2)
{
  uint64_t v2 = (uint64_t)*a2;
  if ((*a2)->mNumberBuffers)
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    uint64_t v7 = *((void *)this + 75);
    uint64_t v8 = 16;
    do
    {
      float v9 = *(float ***)(v7 + v5);
      long long v10 = *v9;
      float v11 = v9[3];
      v17.realp = v10;
      v17.imagp = v11;
      VPTimeFreqConverter::Analyze(*(VPTimeFreqConverter **)(*((void *)this + 70) + 8 * v6), *(const float **)(v2 + v8), &v17);
      uint64_t v7 = *((void *)this + 75);
      int v12 = *(uint64_t **)(v7 + v5);
      uint64_t v13 = *v12;
      unint64_t v14 = (unint64_t)(v12[1] - *v12) >> 2;
      __n128 v15 = (float *)v12[3];
      float result = *v15;
      LODWORD(v14) = v14 - 1;
      *(float *)(v13 + 4 * v14) = *v15;
      v15[v14] = 0.0;
      *__n128 v15 = 0.0;
      ++v6;
      uint64_t v2 = (uint64_t)*a2;
      v5 += 24;
      v8 += 16;
    }
    while (v6 < (*a2)->mNumberBuffers);
  }
  return result;
}

float AUBSS1::CopyToInternalBuffers(AUBSS1 *this, unsigned int a2, const AudioBufferList **a3)
{
  uint64_t v3 = *((void *)this + 76);
  uint64_t v4 = *((void *)this + 75);
  if (v3 != v4)
  {
    uint64_t v7 = 0;
    unint64_t v8 = 0;
    size_t v9 = 4 * a2;
    uint64_t v10 = 2 * a2;
    uint64_t v11 = 16;
    uint64_t v12 = a2;
    do
    {
      if (a2)
      {
        uint64_t v13 = *(char **)((char *)&(*a3)->mNumberBuffers + v11);
        memmove(**(void ***)(v4 + v7), v13, v9);
        memmove(*(void **)(*(void *)(*((void *)this + 75) + v7) + 24), &v13[4 * v12], 4 * v10 - 4 * v12);
        uint64_t v4 = *((void *)this + 75);
        uint64_t v3 = *((void *)this + 76);
      }
      unint64_t v14 = *(void **)(v4 + v7);
      __n128 v15 = (float *)v14[3];
      float result = *v15;
      unsigned int v17 = *((_DWORD *)this + 138) - 1;
      *(float *)(*v14 + 4 * v17) = *v15;
      v15[v17] = 0.0;
      *__n128 v15 = 0.0;
      ++v8;
      v7 += 24;
      v11 += 16;
    }
    while (v8 < 0xAAAAAAAAAAAAAAABLL * ((v3 - v4) >> 3));
  }
  return result;
}

void AUBSS1::ScaleProcessInverseScale(AUBSS1 *this)
{
  uint64_t v2 = *((void *)this + 73);
  if (v2)
  {
    float v3 = *((float *)this + 164);
    float v14 = 1.0 / v3;
    float __B = v3;
    if (v3 != 1.0 && *((_DWORD *)this + 137))
    {
      uint64_t v4 = 0;
      unint64_t v5 = 0;
      do
      {
        unint64_t v6 = **(float ***)(*((void *)this + 75) + v4);
        vDSP_vsmul(v6, 1, &__B, v6, 1, *((unsigned int *)this + 138));
        uint64_t v7 = *(float **)(*(void *)(*((void *)this + 75) + v4) + 24);
        vDSP_vsmul(v7, 1, &__B, v7, 1, *((unsigned int *)this + 138));
        ++v5;
        v4 += 24;
      }
      while (v5 < *((unsigned int *)this + 137));
      uint64_t v2 = *((void *)this + 73);
    }
    (*(void (**)(uint64_t, char *, char *))(*(void *)v2 + 32))(v2, (char *)this + 600, (char *)this + 624);
    if (*((_DWORD *)this + 163)) {
      std::vector<std::vector<std::vector<float>>>::__assign_with_size[abi:ne180100]<std::vector<std::vector<float>>*,std::vector<std::vector<float>>*>((uint64_t)this + 624, *((uint64_t **)this + 75), *((uint64_t **)this + 76), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)this + 76) - *((void *)this + 75)) >> 3));
    }
    if (__B != 1.0 && *((_DWORD *)this + 137))
    {
      uint64_t v8 = 0;
      unint64_t v9 = 0;
      do
      {
        uint64_t v10 = **(float ***)(*((void *)this + 78) + v8);
        vDSP_vsmul(v10, 1, &v14, v10, 1, *((unsigned int *)this + 138));
        uint64_t v11 = *(float **)(*(void *)(*((void *)this + 78) + v8) + 24);
        vDSP_vsmul(v11, 1, &v14, v11, 1, *((unsigned int *)this + 138));
        ++v9;
        v8 += 24;
      }
      while (v9 < *((unsigned int *)this + 137));
    }
  }
  else
  {
    uint64_t v12 = (uint64_t *)*((void *)this + 75);
    uint64_t v13 = (uint64_t *)*((void *)this + 76);
    std::vector<std::vector<std::vector<float>>>::__assign_with_size[abi:ne180100]<std::vector<std::vector<float>>*,std::vector<std::vector<float>>*>((uint64_t)this + 624, v12, v13, 0xAAAAAAAAAAAAAAABLL * (v13 - v12));
  }
}

uint64_t AUBSS1::FreqToTimeAndCopyFromInternalBuffers(uint64_t this, AudioBufferList **a2)
{
  uint64_t v2 = (uint64_t)*a2;
  if ((*a2)->mNumberBuffers)
  {
    uint64_t v4 = this;
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    uint64_t v7 = 16;
    do
    {
      uint64_t v8 = *(void *)(*(void *)(v4 + 624) + v5);
      unint64_t v9 = *(float **)v8;
      int v10 = *(_DWORD *)(*(void *)v8 + 4 * (((*(void *)(v8 + 8) - *(void *)v8) >> 2) - 1));
      uint64_t v11 = *(float **)(v8 + 24);
      *(_DWORD *)uint64_t v11 = v10;
      v12.realp = v9;
      v12.imagp = v11;
      this = VPTimeFreqConverter::Synthesize(*(VPTimeFreqConverter **)(*(void *)(v4 + 560) + 8 * v6++), &v12, *(float **)(v2 + v7));
      uint64_t v2 = (uint64_t)*a2;
      v7 += 16;
      v5 += 24;
    }
    while (v6 < (*a2)->mNumberBuffers);
  }
  return this;
}

void *AUBSS1::CopyFromInternalBuffers(void *this, unsigned int a2, AudioBufferList **a3)
{
  uint64_t v3 = this[78];
  if (this[79] != v3)
  {
    uint64_t v5 = (uint64_t)this;
    uint64_t v6 = 0;
    unint64_t v7 = 0;
    uint64_t v8 = 16;
    uint64_t v9 = a2;
    do
    {
      uint64_t v10 = *(void *)(v3 + v6);
      uint64_t v11 = *(const void **)v10;
      uint64_t v12 = *(void *)(v10 + 8);
      uint64_t v13 = *(_DWORD **)(v10 + 24);
      *uint64_t v13 = *(_DWORD *)(*(void *)v10 + 4 * (*(_DWORD *)(v5 + 552) - 1));
      uint64_t v14 = *(void *)((char *)&(*a3)->mNumberBuffers + v8);
      if ((const void *)(v12 - 4) != v11)
      {
        this = memmove(*(void **)((char *)&(*a3)->mNumberBuffers + v8), v11, v12 - 4 - (void)v11);
        uint64_t v3 = *(void *)(v5 + 624);
        uint64_t v10 = *(void *)(v3 + v6);
        uint64_t v13 = *(_DWORD **)(v10 + 24);
      }
      uint64_t v15 = *(void *)(v10 + 32) - 4;
      if ((_DWORD *)v15 != v13)
      {
        this = memmove((void *)(v14 + 4 * v9), v13, v15 - (void)v13);
        uint64_t v3 = *(void *)(v5 + 624);
      }
      ++v7;
      v6 += 24;
      v8 += 16;
    }
    while (v7 < 0xAAAAAAAAAAAAAAABLL * ((*(void *)(v5 + 632) - v3) >> 3));
  }
  return this;
}

uint64_t AUBSS1::SideChainProcess(AUBSS1 *this, unsigned int a2, const AudioBufferList **a3, AudioBufferList **a4)
{
  uint64_t v6 = *((void *)this + 76);
  uint64_t v7 = *((void *)this + 75);
  if (v6 != v7)
  {
    uint64_t v8 = 0;
    unint64_t v9 = 0;
    uint64_t v10 = 16;
    do
    {
      if (a2)
      {
        uint64_t v11 = *(char **)((char *)&a3[1]->mNumberBuffers + v10);
        memmove(**(void ***)(v7 + v8), v11, 4 * a2);
        memmove(*(void **)(*(void *)(*((void *)this + 75) + v8) + 24), &v11[4 * a2], 8 * a2 - 4 * a2);
        uint64_t v7 = *((void *)this + 75);
        uint64_t v6 = *((void *)this + 76);
      }
      uint64_t v12 = *(void **)(v7 + v8);
      uint64_t v13 = (_DWORD *)v12[3];
      unsigned int v14 = *((_DWORD *)this + 138) - 1;
      *(_DWORD *)(*v12 + 4 * v14) = *v13;
      v13[v14] = 0;
      *uint64_t v13 = 0;
      ++v9;
      v8 += 24;
      v10 += 16;
    }
    while (v9 < 0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 3));
  }
  uint64_t v15 = *((void *)this + 73);
  if (v15) {
    uint64_t v16 = (*(uint64_t (**)(uint64_t, char *, char *))(*(void *)v15 + 40))(v15, (char *)this + 600, (char *)this + 624);
  }
  else {
    uint64_t v16 = 0;
  }
  uint64_t v17 = **((void **)this + 78);
  unsigned int v18 = *(const void **)v17;
  uint64_t v19 = *(void *)(v17 + 8);
  unint64_t v20 = *(_DWORD **)(v17 + 24);
  *unint64_t v20 = *(_DWORD *)(*(void *)v17 + 4 * (*((_DWORD *)this + 138) - 1));
  mData = (char *)a4[1]->mBuffers[0].mData;
  if ((const void *)(v19 - 4) != v18)
  {
    memmove(a4[1]->mBuffers[0].mData, v18, v19 - 4 - (void)v18);
    float v22 = (uint64_t *)*((void *)this + 78);
    uint64_t v17 = *v22;
    unint64_t v20 = *(_DWORD **)(*v22 + 24);
  }
  uint64_t v23 = *(void *)(v17 + 32) - 4;
  if ((_DWORD *)v23 != v20) {
    memmove(&mData[4 * a2], v20, v23 - (void)v20);
  }
  unsigned int v24 = a4[1];
  if (v24->mNumberBuffers == 2) {
    bzero(*(void **)&v24[1].mBuffers[0].mNumberChannels, *(&v24[1].mNumberBuffers + 1));
  }
  return v16;
}

uint64_t AUBSS1::ProcessBufferLists(AUBSS1 *this, unsigned int *a2, const AudioBufferList *a3, AudioBufferList *a4, uint64_t a5)
{
  v7[1] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = a4;
  v7[0] = a3;
  return (*(uint64_t (**)(AUBSS1 *, unsigned int *, uint64_t, uint64_t, void *, uint64_t, AudioBufferList **))(*(void *)this + 184))(this, a2, a5, 1, v7, 1, &v6);
}

uint64_t AUBSS1::CanScheduleParameters(AUBSS1 *this)
{
  return 0;
}

uint64_t AUBSS1::SetParameter(AUBSS1 *this, unsigned int a2, int a3, float a4)
{
  if (a3) {
    return 4294956418;
  }
  uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUBSS1 *)((char *)this + 32), 0);
  ausdk::AUElement::SetParameter(Element, a2, a4, 0);
  uint64_t result = 0;
  ++*((_DWORD *)this + 133);
  return result;
}

uint64_t AUBSS1::SetProperty(AUBSS1 *this, int a2, int a3, unsigned int a4, unsigned char *a5, unsigned int a6)
{
  if (a3) {
    return 4294956417;
  }
  if (a2 == 3700)
  {
    if (a6 >= 4)
    {
      uint64_t result = 0;
      *((unsigned char *)this + 376) = *a5;
    }
    else
    {
      return 4294956445;
    }
  }
  else
  {
    if (a2 != 21) {
      return 4294956417;
    }
    uint64_t result = 0;
    *((_DWORD *)this + 135) = *(_DWORD *)a5;
  }
  return result;
}

uint64_t AUBSS1::GetProperty(AUBSS1 *this, int a2, int a3, unsigned int a4, _DWORD *a5)
{
  if (a3) {
    return 4294956417;
  }
  if (a2 == 3700)
  {
    int v6 = *((unsigned __int8 *)this + 376);
  }
  else
  {
    if (a2 != 21) {
      return 4294956417;
    }
    int v6 = *((_DWORD *)this + 135);
  }
  uint64_t result = 0;
  *a5 = v6;
  return result;
}

uint64_t AUBSS1::GetPropertyInfo(AUBSS1 *this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  if (a3) {
    return 4294956417;
  }
  if (a2 == 21)
  {
    BOOL v7 = 1;
  }
  else
  {
    if (a2 != 3700) {
      return 4294956417;
    }
    BOOL v7 = 0;
  }
  uint64_t result = 0;
  *a6 = v7;
  *a5 = 4;
  return result;
}

double AUBSS1::Reset(BlockProcessor **this, AudioUnitScope a2, AudioUnitElement a3)
{
  AUBSS1::UpdateState((AUBSS1 *)this);
  int v6 = this[73];
  if (!v6 || !(*(unsigned int (**)(BlockProcessor *))(*(void *)v6 + 24))(v6))
  {
    uint64_t v8 = this[74];
    if (v8) {
      BlockProcessor::Reset(v8);
    }
    unint64_t v9 = this[83];
    if (!v9 || !AudioUnitReset(v9, a2, a3))
    {
      double result = 0.0;
      *((_OWORD *)this + 44) = 0u;
      *((_OWORD *)this + 45) = 0u;
      *((_OWORD *)this + 42) = 0u;
      *((_OWORD *)this + 43) = 0u;
    }
  }
  return result;
}

void AUBSS1::Cleanup(AUBSS1 *this)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (OpaqueAudioComponentInstance *)*((void *)this + 83);
  if (v2)
  {
    if (AudioUnitUninitialize(v2))
    {
      if (AUBSS1LogScope(void)::once != -1) {
        dispatch_once(&AUBSS1LogScope(void)::once, &__block_literal_global_2434);
      }
      if (AUBSS1LogScope(void)::scope)
      {
        uint64_t v3 = *(NSObject **)AUBSS1LogScope(void)::scope;
        if (!*(void *)AUBSS1LogScope(void)::scope) {
          return;
        }
      }
      else
      {
        uint64_t v3 = MEMORY[0x1E4F14500];
      }
      if (!os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
        return;
      }
      int v6 = 136315394;
      BOOL v7 = "AUBSS1.cpp";
      __int16 v8 = 1024;
      int v9 = 296;
      uint64_t v5 = "%25s:%-5d ERROR: Failed to uninitialized internal AU.";
LABEL_20:
      _os_log_impl(&dword_1BB0CE000, v3, OS_LOG_TYPE_ERROR, v5, (uint8_t *)&v6, 0x12u);
      return;
    }
    OSStatus v4 = AudioComponentInstanceDispose(*((AudioComponentInstance *)this + 83));
    *((void *)this + 83) = 0;
    if (!v4) {
      return;
    }
    if (AUBSS1LogScope(void)::once != -1) {
      dispatch_once(&AUBSS1LogScope(void)::once, &__block_literal_global_2434);
    }
    if (AUBSS1LogScope(void)::scope)
    {
      uint64_t v3 = *(NSObject **)AUBSS1LogScope(void)::scope;
      if (!*(void *)AUBSS1LogScope(void)::scope) {
        return;
      }
    }
    else
    {
      uint64_t v3 = MEMORY[0x1E4F14500];
    }
    if (!os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v6 = 136315394;
    BOOL v7 = "AUBSS1.cpp";
    __int16 v8 = 1024;
    int v9 = 304;
    uint64_t v5 = "%25s:%-5d ERROR: Failed to dispose of internal AU.";
    goto LABEL_20;
  }
}

uint64_t AUBSS1::Initialize(AUBSS1 *this)
{
  uint64_t Element = ausdk::AUScope::SafeGetElement((AUBSS1 *)((char *)this + 80), 0);
  uint64_t v3 = ausdk::AUScope::SafeGetElement((AUBSS1 *)((char *)this + 128), 0);
  int v4 = *(_DWORD *)(Element + 108);
  int v8 = *(_DWORD *)(v3 + 108);
  int v9 = v4;
  if (v4 == v8)
  {
    *((_DWORD *)this + 137) = v4;
    if (v4 == 2)
    {
      int v5 = *(_DWORD *)(Element + 88);
      if ((v5 == 1718773105) != (*(_DWORD *)(v3 + 88) != 1718773105))
      {
        *((unsigned char *)this + 528) = v5 == 1718773105;
        double v6 = *(double *)(Element + 80);
        if (v6 == *(double *)(v3 + 80))
        {
          *((_DWORD *)this + 184) = v6;
          operator new();
        }
      }
    }
  }
  return 4294956428;
}

void sub_1BB389D34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  _Unwind_Resume(exception_object);
}

void std::make_unique[abi:ne180100]<BlockProcessor,int,unsigned int *,int,unsigned int *,unsigned int &,int (&)(void *,unsigned int,AudioBufferList const**,AudioBufferList**),AUBSS1 *>()
{
}

void sub_1BB389E3C(_Unwind_Exception *a1)
{
  MEMORY[0x1C185D370](v1, 0x1080C40622722D2);
  _Unwind_Resume(a1);
}

uint64_t GetPreference<BOOL>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  char v4 = *((unsigned char *)a1 + 23);
  if (v4 >= 0) {
    int v5 = (const UInt8 *)a1;
  }
  else {
    int v5 = (const UInt8 *)*a1;
  }
  if (v5)
  {
    if (v4 >= 0) {
      CFIndex v6 = *((unsigned __int8 *)a1 + 23);
    }
    else {
      CFIndex v6 = a1[1];
    }
    CFStringRef v7 = CFStringCreateWithBytes(0, v5, v6, 0x8000100u, 0);
    __p[0] = (void *)v7;
    if (!v7)
    {
      exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
    }
  }
  else
  {
    CFStringRef v7 = 0;
    __p[0] = 0;
  }
  char v9 = *((unsigned char *)a2 + 23);
  if (v9 >= 0) {
    uint64_t v10 = (const UInt8 *)a2;
  }
  else {
    uint64_t v10 = (const UInt8 *)*a2;
  }
  if (v10)
  {
    if (v9 >= 0) {
      CFIndex v11 = *((unsigned __int8 *)a2 + 23);
    }
    else {
      CFIndex v11 = a2[1];
    }
    CFStringRef v12 = CFStringCreateWithBytes(0, v10, v11, 0x8000100u, 0);
    *(void *)buf = v12;
    if (!v12)
    {
      uint64_t v13 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v13, "Could not construct");
    }
  }
  else
  {
    CFStringRef v12 = 0;
    *(void *)buf = 0;
  }
  CFNumberRef v14 = (const __CFNumber *)CFPreferencesCopyAppValue(v12, v7);
  CFNumberRef v30 = v14;
  if (v12) {
    CFRelease(v12);
  }
  if (v7) {
    CFRelease(v7);
  }
  if (v14)
  {
    BOOL v15 = applesauce::CF::convert_to<BOOL,0>(v14);
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      int v16 = *((char *)a1 + 23);
      uint64_t v17 = (uint64_t *)*a1;
      int v18 = *((char *)a2 + 23);
      uint64_t v19 = (uint64_t *)*a2;
      if (v15) {
        unint64_t v20 = "true";
      }
      else {
        unint64_t v20 = "false";
      }
      std::string::basic_string[abi:ne180100]<0>(__p, v20);
      if (v18 >= 0) {
        unsigned int v21 = a2;
      }
      else {
        unsigned int v21 = v19;
      }
      if (v16 >= 0) {
        float v22 = a1;
      }
      else {
        float v22 = v17;
      }
      if (v29 >= 0) {
        uint64_t v23 = __p;
      }
      else {
        uint64_t v23 = (void **)__p[0];
      }
      *(_DWORD *)buf = 136316162;
      *(void *)&uint8_t buf[4] = "CFPrefHelper.h";
      __int16 v32 = 1024;
      int v33 = 124;
      __int16 v34 = 2080;
      unint64_t v35 = v22;
      __int16 v36 = 2080;
      unint64_t v37 = v21;
      __int16 v38 = 2080;
      BOOL v39 = v23;
      _os_log_impl(&dword_1BB0CE000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "%25s:%-5d Preference '%s %s' retrieved as %s", buf, 0x30u);
      if (v29 < 0) {
        operator delete(__p[0]);
      }
    }
    int v24 = 1;
    CFRelease(v14);
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG))
    {
      if (*((char *)a1 + 23) >= 0) {
        float v25 = a1;
      }
      else {
        float v25 = (uint64_t *)*a1;
      }
      if (*((char *)a2 + 23) >= 0) {
        unsigned int v26 = a2;
      }
      else {
        unsigned int v26 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 136315906;
      *(void *)&uint8_t buf[4] = "CFPrefHelper.h";
      __int16 v32 = 1024;
      int v33 = 133;
      __int16 v34 = 2080;
      unint64_t v35 = v25;
      __int16 v36 = 2080;
      unint64_t v37 = v26;
      _os_log_impl(&dword_1BB0CE000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG, "%25s:%-5d Preference: '%s %s' does not exist.", buf, 0x26u);
    }
    BOOL v15 = 0;
    int v24 = 0;
  }
  return v15 | (v24 << 8);
}

void sub_1BB38A1C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, long long buf, long long a14)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      if (*((char *)v15 + 23) >= 0) {
        int v16 = v15;
      }
      else {
        int v16 = (uint64_t *)*v15;
      }
      if (*((char *)v14 + 23) >= 0) {
        uint64_t v17 = v14;
      }
      else {
        uint64_t v17 = (uint64_t *)*v14;
      }
      LODWORD(buf) = 136315906;
      *(void *)((char *)&buf + 4) = "CFPrefHelper.h";
      WORD6(buf) = 1024;
      *(_DWORD *)((char *)&buf + 14) = 128;
      WORD1(a14) = 2080;
      *(void *)((char *)&a14 + 4) = v16;
      WORD6(a14) = 2080;
      *(void *)((char *)&a14 + 14) = v17;
      _os_log_impl(&dword_1BB0CE000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%25s:%-5d Failed to get Preference: '%s %s'. It exists, but is it the right type?", (uint8_t *)&buf, 0x26u);
    }
    __cxa_end_catch();
    if (!a12) {
      JUMPOUT(0x1BB38A184);
    }
    JUMPOUT(0x1BB38A0D8);
  }
  _Unwind_Resume(a1);
}

void sub_1BB38A2F4(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x1BB38A2D8);
  }
  JUMPOUT(0x1BB38A318);
}

void sub_1BB38A300(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  if (a2)
  {
    applesauce::CF::StringRef::~StringRef((const void **)va);
    JUMPOUT(0x1BB38A310);
  }
  JUMPOUT(0x1BB38A2D8);
}

void sub_1BB38A3C8()
{
}

void std::vector<std::vector<std::vector<float>>>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = *a1;
  char v4 = (void **)a1[1];
  unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v4 - *a1) >> 3);
  unint64_t v6 = a2 - v5;
  if (a2 <= v5)
  {
    if (a2 < v5)
    {
      BOOL v15 = (void **)(v3 + 24 * a2);
      while (v4 != v15)
      {
        v4 -= 3;
        v17[0] = v4;
        std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](v17);
      }
      a1[1] = (uint64_t)v15;
    }
  }
  else
  {
    uint64_t v7 = a1[2];
    if (0xAAAAAAAAAAAAAAABLL * ((v7 - (uint64_t)v4) >> 3) >= v6)
    {
      size_t v16 = 24 * ((24 * v6 - 24) / 0x18) + 24;
      bzero((void *)a1[1], v16);
      a1[1] = (uint64_t)v4 + v16;
    }
    else
    {
      if (a2 > 0xAAAAAAAAAAAAAAALL) {
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      }
      v17[4] = (void **)(a1 + 2);
      unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - v3) >> 3);
      uint64_t v9 = 2 * v8;
      if (2 * v8 <= a2) {
        uint64_t v9 = a2;
      }
      if (v8 >= 0x555555555555555) {
        unint64_t v10 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v10 = v9;
      }
      CFIndex v11 = (void **)std::__allocate_at_least[abi:ne180100]<std::allocator<AUPropertyItem>>(v10);
      CFStringRef v12 = &v11[3 * v5];
      v17[0] = v11;
      v17[1] = v12;
      v17[3] = &v11[3 * v13];
      size_t v14 = 24 * ((24 * v6 - 24) / 0x18) + 24;
      bzero(v12, v14);
      v17[2] = (void **)((char *)v12 + v14);
      std::vector<std::vector<unsigned int>>::__swap_out_circular_buffer(a1, v17);
      std::__split_buffer<std::vector<std::vector<float>>>::~__split_buffer((uint64_t)v17);
    }
  }
}

uint64_t std::__split_buffer<std::vector<std::vector<float>>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    char v4 = (void **)(i - 24);
    *(void *)(a1 + 16) = v4;
    unint64_t v6 = v4;
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v6);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t AUBSS1::BlockProcessClassFunc(AUBSS1 *this, void *a2, const AudioBufferList **a3, AudioBufferList **a4, AudioBufferList **a5)
{
  return 0;
}

uint64_t AU::BSS1::Handset<float>::UpdateParam(uint64_t a1, unsigned int a2, float a3)
{
  if (!*(unsigned char *)(a1 + 8)) {
    return 4294956429;
  }
  if (a2 < 3) {
    return 0;
  }
  if (a2 == 4) {
    goto LABEL_8;
  }
  if (a2 == 3)
  {
    *(float *)(a1 + 736) = a3;
LABEL_8:
    *(_DWORD *)(a1 + 44) = a3;
  }
  return 1;
}

uint64_t AU::BSS1::Handset<float>::SideChainProcess(uint64_t a1, const float ****a2, const float ****a3)
{
  unint64_t v6 = **(float ****)(a1 + 408);
  uint64_t v7 = *v6;
  unint64_t v8 = v6[3];
  uint64_t v9 = (float **)**a2;
  unint64_t v10 = *v9;
  CFIndex v11 = v9[3];
  CFStringRef v12 = *(float ***)(a1 + 128);
  uint64_t v13 = *v12;
  size_t v14 = v12[3];
  vDSP_Length v15 = *(unsigned int *)(a1 + 60);
  __A.realp = v7;
  __A.imagp = v8;
  __B.realp = v10;
  __B.imagp = v11;
  v44.realp = v13;
  v44.imagp = v14;
  vDSP_zvmul(&__A, 1, &__B, 1, &v44, 1, v15, 1);
  size_t v16 = *(float ***)(*(void *)(a1 + 408) + 24);
  uint64_t v17 = *v16;
  int v18 = v16[3];
  uint64_t v19 = (float **)(*a2)[3];
  unint64_t v20 = *v19;
  unsigned int v21 = v19[3];
  float v22 = *(float ***)(a1 + 152);
  uint64_t v23 = *v22;
  int v24 = v22[3];
  vDSP_Length v25 = *(unsigned int *)(a1 + 60);
  __A.realp = v17;
  __A.imagp = v18;
  __B.realp = v20;
  __B.imagp = v21;
  v44.realp = v23;
  v44.imagp = v24;
  vDSP_zvmul(&__A, 1, &__B, 1, &v44, 1, v25, 1);
  unsigned int v26 = *(float ***)(a1 + 128);
  char v27 = *v26;
  float v28 = v26[3];
  char v29 = *(float ***)(a1 + 152);
  CFNumberRef v30 = *v29;
  float v31 = v29[3];
  __int16 v32 = (float **)**a3;
  int v33 = *v32;
  __int16 v34 = v32[3];
  vDSP_Length v35 = *(unsigned int *)(a1 + 60);
  __A.realp = v27;
  __A.imagp = v28;
  __B.realp = v30;
  __B.imagp = v31;
  v44.realp = v33;
  v44.imagp = v34;
  vDSP_zvadd(&__A, 1, &__B, 1, &v44, 1, v35);
  vDSP_vneg(*(const float **)(a1 + 656), 1, **(float ***)(a1 + 128), 1, *(unsigned int *)(a1 + 60));
  vDSP_vsadd(**(const float ***)(a1 + 128), 1, (const float *)(a1 + 48), **(float ***)(a1 + 128), 1, *(unsigned int *)(a1 + 60));
  vDSP_vmul(*(const float **)(a1 + 656), 1, ***a2, 1, **(float ***)(a1 + 152), 1, *(unsigned int *)(a1 + 60));
  vDSP_vmul(*(const float **)(a1 + 656), 1, (**a2)[3], 1, *(float **)(*(void *)(a1 + 152) + 24), 1, *(unsigned int *)(a1 + 60));
  vDSP_vmul(**(const float ***)(a1 + 128), 1, ***a3, 1, (float *)***a3, 1, *(unsigned int *)(a1 + 60));
  vDSP_vmul(**(const float ***)(a1 + 128), 1, (**a3)[3], 1, (float *)(**a3)[3], 1, *(unsigned int *)(a1 + 60));
  __int16 v36 = (float **)**a3;
  unint64_t v37 = *v36;
  __int16 v38 = v36[3];
  BOOL v39 = *(float ***)(a1 + 152);
  uint64_t v40 = *v39;
  float v41 = v39[3];
  vDSP_Length v42 = *(unsigned int *)(a1 + 60);
  __A.realp = v37;
  __A.imagp = v38;
  __B.realp = v40;
  __B.imagp = v41;
  v44.realp = v37;
  v44.imagp = v38;
  vDSP_zvadd(&__A, 1, &__B, 1, &v44, 1, v42);
  return 0;
}

uint64_t AU::BSS1::Handset<float>::Update(uint64_t a1, uint64_t **a2, uint64_t a3)
{
  uint64_t v503 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(a1 + 8)) {
    return 4294956429;
  }
  char v4 = *a2;
  uint64_t v3 = a2[1];
  if ((char *)v3 - (char *)*a2 != 48) {
    return 4294956421;
  }
  unint64_t v6 = *(float ****)a3;
  unint64_t v5 = *(float ****)(a3 + 8);
  if ((float ***)((char *)v5 - *(void *)a3) != (float ***)48) {
    return 4294956421;
  }
  uint64_t v7 = a1;
  uint64_t v8 = *(unsigned int *)(a1 + 60);
  while (v4 != v3)
  {
    unint64_t v10 = (void *)*v4;
    uint64_t v9 = (void *)v4[1];
    if ((void *)((char *)v9 - *v4) != (void *)48) {
      return 4294956421;
    }
    while (v10 != v9)
    {
      if (v8 != (uint64_t)(v10[1] - *v10) >> 2) {
        return 4294956421;
      }
      v10 += 3;
    }
    v4 += 3;
  }
  while (v6 != v5)
  {
    uint64_t v13 = *v6;
    CFStringRef v12 = v6[1];
    if ((char *)v12 - (char *)*v6 != 48) {
      return 4294956421;
    }
    while (v13 != v12)
    {
      if (v8 != v13[1] - *v13) {
        return 4294956421;
      }
      v13 += 3;
    }
    v6 += 3;
  }
  uint64_t v497 = a2;
  uint64_t v14 = 0;
  DSPSplitComplex __B = (float *)(a1 + 56);
  char v15 = 1;
  do
  {
    char v16 = v15;
    uint64_t v17 = (float **)(*a2)[3 * v14];
    int v18 = *v17;
    uint64_t v19 = (void *)(v7 + 232);
    unint64_t v20 = *(float **)(*(void *)(v7 + 232) + 24 * v14);
    unsigned int v21 = v17[3];
    uint64_t v23 = (unsigned int *)(v7 + 60);
    vDSP_Length v22 = *(unsigned int *)(v7 + 60);
    __A.realp = v18;
    __A.imagp = v21;
    vDSP_zvabs(&__A, 1, v20, 1, v22);
    vDSP_vsadd(*(const float **)(*v19 + 24 * v14), 1, __B, *(float **)(*v19 + 24 * v14), 1, *v23);
    char v15 = 0;
    uint64_t v14 = 1;
    uint64_t v7 = a1;
    a2 = v497;
  }
  while ((v16 & 1) != 0);
  int v24 = *(const float ***)(a1 + 240);
  if (v24 == *(const float ***)(a1 + 232))
  {
    float v28 = 3.4028e38;
  }
  else
  {
    uint64_t v25 = 0;
    unint64_t v26 = 0;
    unsigned int v27 = *(_DWORD *)(a1 + 60);
    float v28 = 3.4028e38;
    int v24 = *(const float ***)(a1 + 232);
    do
    {
      LODWORD(__A.realp) = 0;
      char v29 = (const float ****)(v7 + 104);
      vDSP_vsq(v24[v25], 1, ***(float ****)(v7 + 104), 1, v27);
      vDSP_sve(***v29, 1, (float *)&__A, *(unsigned int *)(a1 + 60));
      unsigned int v27 = *(_DWORD *)(a1 + 60);
      float v30 = log10f(*(float *)&__A.realp / (float)v27) * 10.0;
      if (v30 < v28) {
        float v28 = v30;
      }
      ++v26;
      uint64_t v7 = a1;
      int v24 = *(const float ***)(a1 + 232);
      v25 += 3;
    }
    while (v26 < 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 240) - (void)v24) >> 3));
  }
  if ((*(unsigned char *)(v7 + 40) & 1) != 0 && v28 < *(float *)(v7 + 176))
  {
    if ((uint64_t **)a3 != v497) {
      std::vector<std::vector<std::vector<float>>>::__assign_with_size[abi:ne180100]<std::vector<std::vector<float>>*,std::vector<std::vector<float>>*>(a3, *v497, v497[1], 0xAAAAAAAAAAAAAAABLL * (v497[1] - *v497));
    }
    return 0;
  }
  vDSP_vdiv(v24[3], 1, *v24, 1, *(float **)(v7 + 208), 1, *(unsigned int *)(v7 + 60));
  unsigned int v31 = *(_DWORD *)(a1 + 200);
  if (v31)
  {
    __int16 v32 = *(float **)(a1 + 208);
    float v33 = 0.0;
    uint64_t v34 = *(unsigned int *)(a1 + 200);
    vDSP_Length v35 = (float ****)v497;
    do
    {
      float v36 = *v32++;
      if (v36 > *(float *)(a1 + 192)) {
        float v33 = v33 + 1.0;
      }
      --v34;
    }
    while (v34);
  }
  else
  {
    float v33 = 0.0;
    vDSP_Length v35 = (float ****)v497;
  }
  float v37 = (float)(*(float *)(a1 + 188) * *(float *)(a1 + 728)) + (1.0 - *(float *)(a1 + 188)) * (float)(v33 / (float)v31);
  *(float *)(a1 + 728) = v37;
  AU::BSS1::Handset<float>::ClearDCAndNyquist(*(unsigned int *)(a1 + 60), *(void *)(a1 + 432));
  v492 = (float ****)(a1 + 432);
  AU::BSS1::Handset<float>::GenerateOutput(a1, v35, (float ****)(a1 + 80), (float ****)(a1 + 432));
  uint64_t v38 = 0;
  uint64_t v39 = a1;
  unint64_t v495 = (float ****)(a1 + 104);
  char v40 = 1;
  do
  {
    unsigned int v42 = *(_DWORD *)(v39 + 60);
    uint64_t v41 = v39 + 60;
    char v43 = v40;
    DSPSplitComplex v44 = *(float ***)(*(void *)(v41 + 20) + 24 * v38);
    uint64_t v45 = *v44;
    float v46 = v44[3];
    std::vector<char>::pointer v47 = **(float ***)(*(void *)(v41 + 44) + 24);
    __A.realp = v45;
    __A.imagp = v46;
    vDSP_zvabs(&__A, 1, v47, 1, v42);
    vDSP_svesq((const float *)(**(void **)(*(void *)(a1 + 104) + 24) + 4 * *(unsigned int *)(a1 + 308)), 1, (float *)(*(void *)(a1 + 360) + 4 * v38), (*(_DWORD *)v41 + ~*(_DWORD *)(a1 + 308)));
    char v40 = 0;
    uint64_t v38 = 1;
    uint64_t v39 = a1;
  }
  while ((v43 & 1) != 0);
  int v48 = *(float **)(a1 + 360);
  float v49 = v48[1];
  float v50 = sqrtf(*v48 + *(float *)(a1 + 56));
  *int v48 = v50;
  *int v48 = v50 + *(float *)(a1 + 284);
  float v51 = sqrtf(v49 + *(float *)(a1 + 56));
  v48[1] = v51;
  v48[1] = v51 + *(float *)(a1 + 284);
  float v52 = *(float *)(a1 + 328) * *(float *)(a1 + 728);
  if (v52 < 1.0) {
    float v52 = 1.0;
  }
  v48[*(_DWORD *)(a1 + 520) != 0] = v52 * v48[*(_DWORD *)(a1 + 520) != 0];
  float v53 = *(float *)(a1 + 316);
  float v54 = (float **)**v497;
  uint64_t v55 = *v54;
  uint64_t v56 = v54[3];
  int v57 = **(float ****)(a1 + 104);
  CFTypeID v58 = *v57;
  BOOL v59 = v57[3];
  vDSP_Length v60 = *(unsigned int *)(a1 + 60);
  __A.realp = v55;
  __A.imagp = v56;
  v501.realp = v55;
  v501.imagp = v56;
  __C.realp = v58;
  __C.imagp = v59;
  vDSP_zvmul(&__A, 1, &v501, 1, &__C, 1, v60, -1);
  CFTypeID v61 = (float **)(*v497)[3];
  CFDictionaryRef v62 = *v61;
  uint64_t v63 = v61[3];
  CFDictionaryRef v64 = *(float ***)(*(void *)(a1 + 104) + 72);
  CFTypeID v65 = *v64;
  BOOL v66 = v64[3];
  vDSP_Length v67 = *(unsigned int *)(a1 + 60);
  __A.realp = v62;
  __A.imagp = v63;
  v501.realp = v62;
  v501.imagp = v63;
  __C.realp = v65;
  __C.imagp = v66;
  vDSP_zvmul(&__A, 1, &v501, 1, &__C, 1, v67, -1);
  CFDictionaryRef v68 = (float **)(*v497)[3];
  uint64_t v69 = *v68;
  CFTypeID v70 = v68[3];
  BOOL v71 = (float **)**v497;
  CFTypeID v72 = *v71;
  uint64_t v73 = v71[3];
  CFArrayRef v74 = *(float ***)(*(void *)(a1 + 104) + 24);
  unint64_t v75 = *v74;
  int v76 = v74[3];
  vDSP_Length v77 = *(unsigned int *)(a1 + 60);
  __A.realp = v69;
  __A.imagp = v70;
  v501.realp = v72;
  v501.imagp = v73;
  __C.realp = v75;
  __C.imagp = v76;
  vDSP_zvmul(&__A, 1, &v501, 1, &__C, 1, v77, -1);
  BOOL v78 = *(float ***)(*(void *)(a1 + 104) + 24);
  unint64_t v79 = *v78;
  int v80 = v78[3];
  CFTypeID v81 = *(float ***)(*(void *)(a1 + 104) + 48);
  BOOL v82 = *v81;
  uint64_t v83 = v81[3];
  vDSP_Length v84 = *(unsigned int *)(a1 + 60);
  __A.realp = v79;
  __A.imagp = v80;
  v501.realp = v82;
  v501.imagp = v83;
  vDSP_zvconj(&__A, 1, &v501, 1, v84);
  uint64_t v85 = a1;
  if (*(_DWORD *)(a1 + 36))
  {
    vDSP_vadd(***(const float ****)(a1 + 104), 1, *(const float **)(a1 + 384), 1, ***(float ****)(a1 + 104), 1, *(unsigned int *)(a1 + 60));
    vDSP_vadd(**(const float ***)(*(void *)(a1 + 104) + 72), 1, *(const float **)(a1 + 384), 1, **(float ***)(*(void *)(a1 + 104) + 72), 1, *(unsigned int *)(a1 + 60));
    uint64_t v85 = a1;
  }
  uint64_t v86 = 0;
  v493 = (float ***)(v85 + 128);
  char v87 = 1;
  do
  {
    uint64_t v88 = 0;
    char v89 = v87;
    LODWORD(__A.realp) = 0;
    *(float *)&__A.realp = (float)(1.0 - v53) / *(float *)(*(void *)(v85 + 360) + 4 * v86);
    do
    {
      uint64_t v90 = 0;
      char v91 = 1;
      do
      {
        char v92 = v91;
        uint64_t v93 = *(float **)(*(void *)(*(void *)(*(void *)(v85 + 456) + 24 * v86) + 24 * v88) + 24 * v90);
        vDSP_vsmul(v93, 1, (const float *)(a1 + 316), v93, 1, *(unsigned int *)(v85 + 60));
        vDSP_vsmul(*(const float **)(*(void *)(*(void *)(a1 + 104) + 24 * v88) + 24 * v90), 1, (const float *)&__A, **(float ***)(a1 + 128), 1, *(unsigned int *)(v85 + 60));
        vDSP_vadd(*(const float **)(*(void *)(*(void *)(*(void *)(v85 + 456) + 24 * v86) + 24 * v88) + 24 * v90), 1, **(const float ***)(a1 + 128), 1, *(float **)(*(void *)(*(void *)(*(void *)(v85 + 456) + 24 * v86) + 24 * v88) + 24 * v90), 1, *(unsigned int *)(v85 + 60));
        char v91 = 0;
        uint64_t v90 = 1;
        uint64_t v85 = a1;
      }
      while ((v92 & 1) != 0);
      ++v88;
    }
    while (v88 != 4);
    char v87 = 0;
    uint64_t v86 = 1;
  }
  while ((v89 & 1) != 0);
  unint64_t v94 = *(void *)(a1 + 320);
  float v95 = *(float *)(a1 + 64);
  float v96 = (float)*(unsigned int *)(a1 + 68);
  if ((float)((float)(*(float *)(a1 + 296) * v95) / v96) < (float)v94)
  {
    uint64_t v97 = 0;
    char v98 = 1;
    do
    {
      char v99 = v98;
      std::vector<char>::pointer v101 = *(float ***)(v85 + 128);
      uint64_t v100 = (float ***)(v85 + 128);
      uint64_t v102 = (float **)*v100[38];
      uint64_t v103 = *v102;
      unint64_t v104 = v102[3];
      int v105 = *(float ***)v100[41][3 * v97];
      uint64_t v106 = *v105;
      uint64_t v107 = v105[3];
      uint64_t v108 = *v101;
      uint64_t v109 = v101[3];
      vDSP_Length v110 = *((unsigned int *)v100 - 17);
      __A.realp = v103;
      __A.imagp = v104;
      v501.realp = v106;
      v501.imagp = v107;
      __C.realp = v108;
      __C.imagp = v109;
      vDSP_zvmul(&__A, 1, &v501, 1, &__C, 1, v110, 1);
      uint64_t v111 = (float **)v100[38][3];
      BOOL v112 = *v111;
      uint64_t v113 = v111[3];
      int v114 = (float **)*((void *)v100[41][3 * v97] + 6);
      uint64_t v115 = *v114;
      unint64_t v116 = v114[3];
      uint64_t v117 = *(float ***)(a1 + 152);
      float v118 = *v117;
      int v119 = v117[3];
      vDSP_Length v120 = *((unsigned int *)v100 - 17);
      __A.realp = v112;
      __A.imagp = v113;
      v501.realp = v115;
      v501.imagp = v116;
      __C.realp = v118;
      __C.imagp = v119;
      vDSP_zvmul(&__A, 1, &v501, 1, &__C, 1, v120, 1);
      CFTypeID v121 = (*v100)[3];
      BOOL v122 = **(float ***)(a1 + 152);
      CFTypeID v123 = *(float **)(*(void *)(a1 + 152) + 24);
      CFDictionaryRef v124 = (float ****)(a1 + 104);
      uint64_t v125 = **(float ****)(a1 + 104);
      CFTypeID v126 = *v125;
      BOOL v127 = v125[3];
      vDSP_Length v128 = *((unsigned int *)v100 - 17);
      __A.realp = **v100;
      __A.imagp = v121;
      v501.realp = v122;
      v501.imagp = v123;
      __C.realp = v126;
      __C.imagp = v127;
      vDSP_zvadd(&__A, 1, &v501, 1, &__C, 1, v128);
      CFDictionaryRef v129 = (float **)*v100[38];
      int v130 = *v129;
      BOOL v131 = v129[3];
      uint64_t v132 = (float **)*((void *)v100[41][3 * v97] + 3);
      CFTypeRef v133 = *v132;
      CFTypeID v134 = v132[3];
      unint64_t v135 = **v100;
      unint64_t v136 = (*v100)[3];
      vDSP_Length v137 = *((unsigned int *)v100 - 17);
      __A.realp = v130;
      __A.imagp = v131;
      v501.realp = v133;
      v501.imagp = v134;
      __C.realp = v135;
      __C.imagp = v136;
      vDSP_zvmul(&__A, 1, &v501, 1, &__C, 1, v137, 1);
      unint64_t v138 = (float **)v100[38][3];
      unint64_t v139 = *v138;
      long long v140 = v138[3];
      BOOL v141 = (float **)*((void *)v100[41][3 * v97] + 9);
      uint64_t v142 = *v141;
      CFDictionaryRef v143 = v141[3];
      unsigned int v144 = **(float ***)(a1 + 152);
      CFStringRef v145 = *(float **)(*(void *)(a1 + 152) + 24);
      vDSP_Length v146 = *((unsigned int *)v100 - 17);
      __A.realp = v139;
      __A.imagp = v140;
      v501.realp = v142;
      v501.imagp = v143;
      __C.realp = v144;
      __C.imagp = v145;
      vDSP_zvmul(&__A, 1, &v501, 1, &__C, 1, v146, 1);
      unint64_t v147 = (*v100)[3];
      BOOL v148 = **(float ***)(a1 + 152);
      unsigned int v149 = *(float **)(*(void *)(a1 + 152) + 24);
      BOOL v150 = *(float ***)(*(void *)(a1 + 104) + 24);
      uint64_t v151 = *v150;
      uint64_t v152 = v150[3];
      vDSP_Length v153 = *((unsigned int *)v100 - 17);
      __A.realp = **v100;
      __A.imagp = v147;
      v501.realp = v148;
      v501.imagp = v149;
      __C.realp = v151;
      __C.imagp = v152;
      vDSP_zvadd(&__A, 1, &v501, 1, &__C, 1, v153);
      char v154 = (float **)v100[38][6];
      unint64_t v155 = *v154;
      uint64_t v156 = v154[3];
      float v157 = *(float ***)v100[41][3 * v97];
      long long v158 = *v157;
      unint64_t v159 = v157[3];
      vDSP_Length v160 = **v100;
      uint64_t v161 = (*v100)[3];
      vDSP_Length v162 = *((unsigned int *)v100 - 17);
      __A.realp = v155;
      __A.imagp = v156;
      v501.realp = v158;
      v501.imagp = v159;
      __C.realp = v160;
      __C.imagp = v161;
      vDSP_zvmul(&__A, 1, &v501, 1, &__C, 1, v162, 1);
      uint64_t v163 = (float **)v100[38][9];
      unint64_t v164 = *v163;
      uint64_t v165 = v163[3];
      CFHashCode v166 = (float **)*((void *)v100[41][3 * v97] + 6);
      unint64_t v167 = *v166;
      uint64_t v168 = v166[3];
      unint64_t v169 = **(float ***)(a1 + 152);
      uint8x8_t v170 = *(float **)(*(void *)(a1 + 152) + 24);
      vDSP_Length v171 = *((unsigned int *)v100 - 17);
      __A.realp = v164;
      __A.imagp = v165;
      v501.realp = v167;
      v501.imagp = v168;
      __C.realp = v169;
      __C.imagp = v170;
      vDSP_zvmul(&__A, 1, &v501, 1, &__C, 1, v171, 1);
      vDSP_Length v172 = (*v100)[3];
      uint64_t v173 = **(float ***)(a1 + 152);
      unint64_t v174 = *(float **)(*(void *)(a1 + 152) + 24);
      uint64_t v175 = *(float ***)(*(void *)(a1 + 104) + 48);
      CFTypeRef v176 = *v175;
      float v177 = v175[3];
      vDSP_Length v178 = *((unsigned int *)v100 - 17);
      __A.realp = **v100;
      __A.imagp = v172;
      v501.realp = v173;
      v501.imagp = v174;
      __C.realp = v176;
      __C.imagp = v177;
      vDSP_zvadd(&__A, 1, &v501, 1, &__C, 1, v178);
      unint64_t v179 = (float **)v100[38][6];
      unint64_t v180 = *v179;
      unsigned __int8 v181 = v179[3];
      long long v182 = (float **)*((void *)v100[41][3 * v97] + 3);
      unint64_t v183 = *v182;
      uint64_t v184 = v182[3];
      uint64_t v185 = **v100;
      unint64_t v186 = (*v100)[3];
      vDSP_Length v187 = *((unsigned int *)v100 - 17);
      __A.realp = v180;
      __A.imagp = v181;
      v501.realp = v183;
      v501.imagp = v184;
      __C.realp = v185;
      __C.imagp = v186;
      vDSP_zvmul(&__A, 1, &v501, 1, &__C, 1, v187, 1);
      unint64_t v188 = (float **)v100[38][9];
      uint8x8_t v189 = *v188;
      uint64_t v190 = v188[3];
      uint64_t v191 = (float **)*((void *)v100[41][3 * v97] + 9);
      int v192 = *v191;
      unint64_t v193 = v191[3];
      long long v194 = **(float ***)(a1 + 152);
      unint64_t v195 = *(float **)(*(void *)(a1 + 152) + 24);
      vDSP_Length v196 = *((unsigned int *)v100 - 17);
      __A.realp = v189;
      __A.imagp = v190;
      v501.realp = v192;
      v501.imagp = v193;
      __C.realp = v194;
      __C.imagp = v195;
      vDSP_zvmul(&__A, 1, &v501, 1, &__C, 1, v196, 1);
      CFDictionaryRef v197 = (*v100)[3];
      BOOL v198 = **(float ***)(a1 + 152);
      CFArrayRef v199 = *(float **)(*(void *)(a1 + 152) + 24);
      CFArrayRef v200 = *(float ***)(*(void *)(a1 + 104) + 72);
      CFTypeID v201 = *v200;
      unint64_t v202 = v200[3];
      vDSP_Length v203 = *((unsigned int *)v100 - 17);
      __A.realp = **v100;
      __A.imagp = v197;
      v501.realp = v198;
      v501.imagp = v199;
      __C.realp = v201;
      __C.imagp = v202;
      vDSP_zvadd(&__A, 1, &v501, 1, &__C, 1, v203);
      AU::BSS1::Handset<float>::VectorizedDetInverseOf2x2(a1, v495, v493);
      vDSP_vswap(***v124, 1, *(*v124)[9], 1, *((unsigned int *)v100 - 17));
      vDSP_vswap((**v124)[3], 1, (*v124)[9][3], 1, *((unsigned int *)v100 - 17));
      vDSP_vneg(*(*v124)[3], 1, *(*v124)[3], 1, *((unsigned int *)v100 - 17));
      CFArrayRef v204 = *(float **)(*(void *)(*(void *)(a1 + 104) + 24) + 24);
      vDSP_vneg(v204, 1, v204, 1, *((unsigned int *)v100 - 17));
      vDSP_vneg(*(*v124)[6], 1, *(*v124)[6], 1, *((unsigned int *)v100 - 17));
      int v205 = *(float **)(*(void *)(*(void *)(a1 + 104) + 48) + 24);
      vDSP_vneg(v205, 1, v205, 1, *((unsigned int *)v100 - 17));
      for (uint64_t i = 0; i != 96; i += 24)
      {
        uint64_t v207 = *(float ***)(a1 + 128);
        unsigned __int8 v208 = *v207;
        uint64_t v209 = v207[3];
        unint64_t v210 = *(float ***)(*(void *)(a1 + 104) + i);
        uint64_t v211 = *v210;
        int v212 = v210[3];
        vDSP_Length v213 = *(unsigned int *)(a1 + 60);
        __A.realp = v208;
        __A.imagp = v209;
        v501.realp = v211;
        v501.imagp = v212;
        __C.realp = v211;
        __C.imagp = v212;
        vDSP_zvmul(&__A, 1, &v501, 1, &__C, 1, v213, 1);
      }
      uint64_t v85 = a1;
      if (!*(_DWORD *)(a1 + 32) || v97 == *(_DWORD *)(a1 + 520) || *(float *)(a1 + 728) >= *(float *)(a1 + 516))
      {
        unint64_t v214 = *v495;
        uint8x8_t v215 = (*v495)[3 * v97];
        v216 = *v215;
        char v217 = v215[1];
        if (v217 != v216)
        {
          memmove(*(*v492)[6 * v97], v216, (char *)v217 - (char *)v216);
          unint64_t v214 = *v495;
        }
        unint64_t v218 = v214[3 * (v97 | 2)];
        float v219 = *v218;
        BOOL v220 = v218[1];
        uint64_t v221 = (2 * v97) | 1;
        if (v220 != v219)
        {
          memmove(*(*v492)[3 * v221], v219, (char *)v220 - (char *)v219);
          unint64_t v214 = *v495;
        }
        vDSP_vneg(v214[3 * v97][3], 1, *(float **)(*(void *)(*(void *)(a1 + 432) + 48 * v97) + 24), 1, *(unsigned int *)(a1 + 60));
        vDSP_vneg(*(const float **)(*(void *)(*(void *)(a1 + 104) + 24 * (v97 | 2)) + 24), 1, *(float **)(*(void *)(*(void *)(a1 + 432) + 24 * v221) + 24), 1, *(unsigned int *)(a1 + 60));
        uint64_t v85 = a1;
      }
      char v98 = 0;
      uint64_t v97 = 1;
    }
    while ((v99 & 1) != 0);
    uint64_t v222 = 0;
    v490 = (float *)(v85 + 48);
    unint64_t v491 = (float *)(v85 + 288);
    char v223 = 1;
    do
    {
      uint64_t v224 = 0;
      char v494 = v223;
      uint64_t v225 = 2 * v222;
      char v226 = 1;
      uint64_t v227 = (2 * v222) | 1;
      do
      {
        uint64_t v229 = *(void *)(v85 + 104);
        unint64_t v228 = (void *)(v85 + 104);
        unint64_t v230 = *(float ***)(v228[41] + 48 * v222);
        char v231 = v226;
        uint64_t v232 = *v230;
        uint64_t v233 = v230[3];
        unint64_t v234 = *(float ***)(*(void *)(v228[44] + 24 * v222) + 48 * v224);
        uint64_t v235 = *v234;
        unint64_t v236 = v234[3];
        unint64_t v237 = *(float ***)(v229 + 48);
        unint64_t v238 = *v237;
        unint64_t v239 = v237[3];
        vDSP_Length v240 = *((unsigned int *)v228 - 11);
        __A.realp = v232;
        __A.imagp = v233;
        v501.realp = v235;
        v501.imagp = v236;
        __C.realp = v238;
        __C.imagp = v239;
        vDSP_zvmul(&__A, 1, &v501, 1, &__C, 1, v240, -1);
        uint64_t v241 = *(float ***)(*(void *)(a1 + 432) + 24 * v227);
        uint64_t v242 = *v241;
        uint64_t v243 = v241[3];
        uint64_t v244 = *(float ***)(*(void *)(v228[44] + 24 * v222) + 24 * ((2 * v224) | 1));
        unint64_t v245 = *v244;
        uint64_t v246 = v244[3];
        uint64_t v247 = *(float ***)(*v228 + 72);
        unint64_t v248 = *v247;
        uint64_t v249 = v247[3];
        vDSP_Length v250 = *((unsigned int *)v228 - 11);
        __A.realp = v242;
        __A.imagp = v243;
        v501.realp = v245;
        v501.imagp = v246;
        __C.realp = v248;
        __C.imagp = v249;
        vDSP_zvmul(&__A, 1, &v501, 1, &__C, 1, v250, -1);
        uint64_t v251 = *(float ***)(*v228 + 48);
        int64x2_t v252 = *v251;
        unint64_t v253 = v251[3];
        long long v254 = *(float ***)(*v228 + 72);
        unint64_t v255 = *v254;
        v256 = v254[3];
        uint64_t v257 = *(float ***)(*v228 + 24 * v224);
        uint64_t v258 = *v257;
        uint64_t v259 = v257[3];
        vDSP_Length v260 = *((unsigned int *)v228 - 11);
        __A.realp = v252;
        __A.imagp = v253;
        v501.realp = v255;
        v501.imagp = v256;
        __C.realp = v258;
        __C.imagp = v259;
        vDSP_zvadd(&__A, 1, &v501, 1, &__C, 1, v260);
        char v226 = 0;
        uint64_t v224 = 1;
        uint64_t v85 = a1;
      }
      while ((v231 & 1) != 0);
      vDSP_Length v261 = *(unsigned int *)(a1 + 60);
      unint64_t v262 = *(float ***)(*(void *)(a1 + 432) + 48 * v222);
      unint64_t v263 = *v262;
      uint8x8_t v264 = v262[3];
      unint64_t v265 = *(float ****)(a1 + 104);
      CFHashCode v266 = **v265;
      unint64_t v267 = (*v265)[3];
      v268 = v265[6];
      unint64_t v269 = *v268;
      unint64_t v270 = v268[3];
      __A.realp = v263;
      __A.imagp = v264;
      v501.realp = v266;
      v501.imagp = v267;
      __C.realp = v269;
      __C.imagp = v270;
      vDSP_zvmul(&__A, 1, &v501, 1, &__C, 1, v261, 1);
      uint64_t v271 = *(void *)(a1 + 104);
      uint8x8_t v272 = *(float ***)(*(void *)(a1 + 432) + 24 * v227);
      uint64_t v273 = *v272;
      uint64_t v274 = v272[3];
      unint64_t v275 = *(float ***)(v271 + 24);
      v276 = *v275;
      v277 = v275[3];
      float v278 = *(float ***)(v271 + 72);
      float v279 = *v278;
      BOOL v280 = v278[3];
      vDSP_Length v281 = *(unsigned int *)(a1 + 60);
      __A.realp = v273;
      __A.imagp = v274;
      v501.realp = v276;
      v501.imagp = v277;
      __C.realp = v279;
      __C.imagp = v280;
      vDSP_zvmul(&__A, 1, &v501, 1, &__C, 1, v281, 1);
      unint64_t v282 = *(float ***)(*(void *)(a1 + 104) + 48);
      int8x8_t v283 = *v282;
      unint64_t v284 = v282[3];
      uint64_t v285 = *(float ***)(*(void *)(a1 + 104) + 72);
      uint64_t v286 = *v285;
      unint64_t v287 = v285[3];
      unint64_t v288 = *(float ***)(a1 + 128);
      uint8x8_t v289 = *v288;
      unint64_t v290 = v288[3];
      vDSP_Length v291 = *(unsigned int *)(a1 + 60);
      __A.realp = v283;
      __A.imagp = v284;
      v501.realp = v286;
      v501.imagp = v287;
      __C.realp = v289;
      __C.imagp = v290;
      vDSP_zvadd(&__A, 1, &v501, 1, &__C, 1, v291);
      uint64_t v292 = *(float **)(*(void *)(a1 + 128) + 24);
      vDSP_Length v293 = *(unsigned int *)(a1 + 60);
      __A.realp = **(float ***)(a1 + 128);
      __A.imagp = v292;
      vDSP_zvabs(&__A, 1, __A.realp, 1, v293);
      vDSP_vsadd(**(const float ***)(a1 + 128), 1, __B, **(float ***)(a1 + 128), 1, *(unsigned int *)(a1 + 60));
      vDSP_Length v294 = *(unsigned int *)(a1 + 60);
      uint64_t v295 = **(float ***)(a1 + 128);
      uint64_t v296 = v295;
      vDSP_Length v297 = v294;
      if (v294)
      {
        do
        {
          *uint64_t v296 = sqrtf(*v296);
          ++v296;
          --v297;
        }
        while (v297);
      }
      vDSP_vsadd(v295, 1, v491, v295, 1, v294);
      vDSP_svdiv(v490, **(const float ***)(a1 + 128), 1, **(float ***)(a1 + 128), 1, *(unsigned int *)(a1 + 60));
      uint64_t v298 = 0;
      char v299 = 1;
      do
      {
        char v300 = v299;
        uint64_t v301 = 3 * (v298 | v225);
        vDSP_vmul(**(const float ***)(*(void *)(a1 + 432) + 24 * (v298 | v225)), 1, **(const float ***)(a1 + 128), 1, **(float ***)(*(void *)(a1 + 104) + 24 * (v298 | v225)), 1, *(unsigned int *)(a1 + 60));
        vDSP_vmul(*(const float **)(*(void *)(*(void *)(a1 + 432) + 8 * v301) + 24), 1, **(const float ***)(a1 + 128), 1, *(float **)(*(void *)(*(void *)(a1 + 104) + 8 * v301) + 24), 1, *(unsigned int *)(a1 + 60));
        char v299 = 0;
        uint64_t v298 = 1;
      }
      while ((v300 & 1) != 0);
      uint64_t v85 = a1;
      if (!*(_DWORD *)(a1 + 32) || v222 == *(_DWORD *)(a1 + 520) || *(float *)(a1 + 728) >= *(float *)(a1 + 516))
      {
        uint64_t v302 = 0;
        char v303 = 1;
        do
        {
          char v304 = v303;
          uint64_t v305 = v302 | v225;
          uint64_t v306 = (*v495)[3 * (v302 | v225)];
          uint64_t v307 = v306[1];
          if (v307 != *v306)
          {
            memmove(*(*v492)[3 * v305], *v306, (char *)v307 - (char *)*v306);
            uint64_t v306 = (*v495)[3 * v305];
          }
          uint32_t v308 = v306[3];
          uint64_t v309 = v306[4];
          if (v309 != v308) {
            memmove((*v492)[3 * v305][3], v308, (char *)v309 - (char *)v308);
          }
          char v303 = 0;
          uint64_t v302 = 1;
        }
        while ((v304 & 1) != 0);
      }
      char v223 = 0;
      uint64_t v222 = 1;
    }
    while ((v494 & 1) != 0);
    unint64_t v94 = *(void *)(a1 + 320);
    float v95 = *(float *)(a1 + 64);
    float v96 = (float)*(unsigned int *)(a1 + 68);
  }
  unint64_t v310 = v94 + 1;
  *(void *)(v85 + 320) = v310;
  float v311 = (float)(*(float *)(v85 + 300) * v95) / v96;
  if (v311 < (float)v310) {
    *(void *)(v85 + 320) = (unint64_t)v311;
  }
  v312 = (float ****)(v85 + 408);
  AU::BSS1::Handset<float>::ScaleMDP(v85, v492, (uint64_t *)(v85 + 408));
  uint64_t v314 = a1;
  if (*(_DWORD *)(a1 + 20))
  {
    unint64_t v315 = **v495;
    unint64_t v316 = v315[1] - *v315;
    LODWORD(__A.realp) = 0;
    std::vector<float>::assign((char **)v315, v316, &__A);
    for (uint64_t j = 0; j != 96; j += 24)
    {
      vDSP_Length v318 = *(unsigned int *)(a1 + 60);
      uint64_t v319 = *(float ***)(*(void *)(a1 + 408) + j);
      int v320 = *v319;
      int v321 = v319[3];
      v322 = *(float **)(*(void *)(*(void *)(a1 + 104) + j) + 24);
      __A.realp = v320;
      __A.imagp = v321;
      vDSP_zvabs(&__A, 1, v322, 1, v318);
      vDSP_vadd(***(const float ****)(a1 + 104), 1, *(const float **)(*(void *)(*(void *)(a1 + 104) + j) + 24), 1, ***(float ****)(a1 + 104), 1, *(unsigned int *)(a1 + 60));
    }
    uint64_t v314 = a1;
    uint64_t v323 = *(unsigned int *)(a1 + 60);
    if (v323)
    {
      uint64_t v324 = 0;
      v325 = *(uint64_t ***)(a1 + 104);
      long long v326 = *v325;
      uint64_t v327 = **v325;
      int v328 = *(void **)(a1 + 432);
      uint64_t v329 = 4 * v323;
      do
      {
        float v330 = *(float *)(v327 + v324);
        if (v330 < *(float *)(a1 + 480)) {
          goto LABEL_101;
        }
        uint64_t v331 = v326[3];
        uint64_t v332 = v325[3][3];
        float v333 = *(float *)(v331 + v324);
        float v334 = *(float *)(v332 + v324);
        float v335 = v333 >= v334 ? *(float *)(v331 + v324) : *(float *)(v332 + v324);
        float v336 = *(float *)(a1 + 484);
        if (v335 < v336
          || ((v337 = v325[9][3], float v338 = *(float *)(v337 + v324), v334 >= v338)
            ? (float v339 = *(float *)(v332 + v324))
            : (float v339 = *(float *)(v337 + v324)),
              v339 < v336
           || (v340 = v333 + v334, float v341 = *(float *)(a1 + 488), v340 < v341)
           || (float)(v338 + *(float *)(v325[6][3] + v324)) < v341
           || v330 > *(float *)(a1 + 492)))
        {
LABEL_101:
          uint64_t v342 = (void *)*v328;
          *(_DWORD *)(*(void *)*v328 + v324) = 1065353216;
          uint64_t v343 = (void *)v328[3];
          *(_DWORD *)(*v343 + v324) = 0;
          unint64_t v344 = (void *)v328[6];
          *(_DWORD *)(*v344 + v324) = 0;
          uint64_t v345 = (void *)v328[9];
          *(_DWORD *)(*v345 + v324) = 1065353216;
          *(_DWORD *)(v342[3] + v324) = 0;
          *(_DWORD *)(v343[3] + v324) = 0;
          *(_DWORD *)(v344[3] + v324) = 0;
          *(_DWORD *)(v345[3] + v324) = 0;
        }
        v324 += 4;
      }
      while (v329 != v324);
    }
  }
  if (*(_DWORD *)(v314 + 12))
  {
    LODWORD(v313) = *(_DWORD *)(v314 + 508);
    uint64_t v346 = *(unsigned int *)(v314 + 500);
    float v347 = (double)v313 - (double)v346;
    __A.realp = 0;
    vDSP_svemg((const float *)(**(void **)(v314 + 336) + 4 * v346), 1, (float *)&__A, (unint64_t)v347);
    vDSP_svemg((const float *)(*(void *)(*(void *)(a1 + 336) + 24) + 4 * *(unsigned int *)(a1 + 500)), 1, (float *)&__A.realp + 1, (unint64_t)v347);
    float v348 = *(float *)(a1 + 512);
    float v349 = log10f((float)(*(float *)&__A.realp / v347) + v348);
    float v350 = log10f(v348 + (float)(*((float *)&__A.realp + 1) / v347));
    vDSP_svemg((const float *)(*(void *)(*(void *)(a1 + 336) + 48) + 4 * *(unsigned int *)(a1 + 500)), 1, (float *)&__A, (unint64_t)v347);
    vDSP_svemg((const float *)(*(void *)(*(void *)(a1 + 336) + 72) + 4 * *(unsigned int *)(a1 + 500)), 1, (float *)&__A.realp + 1, (unint64_t)v347);
    uint64_t v314 = a1;
    float v351 = v350 * -20.0 + v349 * 20.0;
    float v352 = *(float *)(a1 + 512);
    double v353 = log10f((float)(*(float *)&__A.realp / v347) + v352);
    float v354 = log10f(v352 + (float)(*((float *)&__A.realp + 1) / v347)) * -20.0 + v353 * 20.0;
    long long v355 = *(float **)(a1 + 528);
    if (v354 > v351)
    {
      uint64_t v356 = 0;
      *long long v355 = v354;
      v355[1] = v351;
      char v357 = 1;
      *(_DWORD *)(a1 + 520) = 1;
      do
      {
        uint64_t v358 = 0;
        char v359 = v357;
        char v360 = 1;
        do
        {
          char v361 = v360;
          vDSP_vswap(*(float **)(*(void *)(*(void *)(a1 + 408) + 24 * v356) + 24 * v358), 1, *(float **)(*(void *)(*(void *)(a1 + 408) + 24 * (v356 | 2)) + 24 * v358), 1, *(unsigned int *)(a1 + 60));
          char v360 = 0;
          uint64_t v358 = 1;
        }
        while ((v361 & 1) != 0);
        char v357 = 0;
        uint64_t v356 = 1;
      }
      while ((v359 & 1) != 0);
      AU::BSS1::Handset<float>::ScaleMDP(a1, v312, (uint64_t *)v312);
      uint64_t v314 = a1;
    }
    else
    {
      *long long v355 = v351;
      v355[1] = v354;
      *(_DWORD *)(a1 + 520) = 0;
    }
  }
  AU::BSS1::Handset<float>::GenerateOutput(v314, (float ****)v497, (float ****)a3, v312);
  uint64_t v362 = 0;
  char v363 = 1;
  do
  {
    char v364 = v363;
    unsigned __int8 v365 = *(float ***)(*(void *)a3 + 24 * v362);
    uint64_t v366 = *v365;
    vDSP_Length v367 = *(unsigned int *)(a1 + 60);
    unint64_t v368 = v365[3];
    CFTypeRef v369 = *(float **)(*(void *)(a1 + 256) + 24 * v362);
    __A.realp = v366;
    __A.imagp = v368;
    vDSP_zvabs(&__A, 1, v369, 1, v367);
    CFTypeRef v370 = *(float **)(*(void *)(a1 + 256) + 24 * v362);
    vDSP_vsadd(v370, 1, __B, v370, 1, *(unsigned int *)(a1 + 60));
    char v363 = 0;
    uint64_t v362 = 1;
  }
  while ((v364 & 1) != 0);
  uint64_t v371 = a1;
  if (*(_DWORD *)(a1 + 44))
  {
    CFTypeRef v372 = (uint64_t *)a3;
    v373 = v497;
    if (*(uint64_t **)a3 != *v497)
    {
      std::vector<std::vector<float>>::__assign_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(*(void *)a3, **v497, (*v497)[1], 0xAAAAAAAAAAAAAAABLL * (((*v497)[1] - **v497) >> 3));
      uint64_t v371 = a1;
      CFTypeRef v372 = (uint64_t *)a3;
      v373 = v497;
    }
    uint64_t v374 = *(unsigned int *)(v371 + 60);
    if (!v374) {
      return 0;
    }
    uint64_t v375 = 0;
    uint64_t v376 = *(void *)(*(void *)(v371 + 256) + 24);
    uint64_t v377 = *(void *)(*(void *)(v371 + 232) + 24);
    uint64_t v378 = *v372;
    std::vector<char> v379 = *v373;
    uint64_t v380 = 4 * v374;
    do
    {
      float v381 = *(float *)(v376 + v375);
      float v382 = *(float *)(v377 + v375);
      if (v381 < v382)
      {
        unint64_t v383 = *(void **)(v378 + 24);
        *(float *)(*v383 + v375) = *(float *)(v371 + 832) * *(float *)(*v383 + v375);
        *(float *)(v383[3] + v375) = *(float *)(v371 + 832) * *(float *)(v383[3] + v375);
        float v381 = *(float *)(v376 + v375);
        float v382 = *(float *)(v377 + v375);
      }
      if (v381 > v382)
      {
        uint64_t v384 = (void *)v379[3];
        v385 = *(void **)(v378 + 24);
        *(_DWORD *)(*v385 + v375) = *(_DWORD *)(*v384 + v375);
        *(_DWORD *)(v385[3] + v375) = *(_DWORD *)(v384[3] + v375);
      }
      uint64_t result = 0;
      v375 += 4;
    }
    while (v380 != v375);
  }
  else
  {
    if (*(_DWORD *)(a1 + 28))
    {
      uint64_t v386 = 0;
      char v387 = 1;
      do
      {
        char v388 = v387;
        LODWORD(__A.realp) = 0;
        vDSP_svesq(*(const float **)(*(void *)(v371 + 256) + 24 * v386), 1, (float *)&__A, *(unsigned int *)(v371 + 60));
        char v387 = 0;
        uint64_t v371 = a1;
        uint64_t v389 = *(float **)(a1 + 624);
        v389[v386] = (float)((float)(1.0 - *(float *)(a1 + 652)) * *(float *)&__A.realp)
                   + (float)(*(float *)(a1 + 652) * v389[v386]);
        uint64_t v386 = 1;
      }
      while ((v388 & 1) != 0);
      uint64_t v390 = *(float ***)(a1 + 128);
      double v391 = (float)(*v389 / (float)(*(float *)(a1 + 56) + v389[1])) + -10.0;
      double v392 = v391 / 10.0;
      BOOL v393 = v391 < 0.0;
      double v394 = 0.0;
      if (!v393) {
        double v394 = v392;
      }
      if (v394 > 1.0) {
        double v394 = 1.0;
      }
      float v395 = v394;
      float v396 = (float)((float)(*(float *)(a1 + 564) - *(float *)(a1 + 568)) * v395) + 1.025;
      *(float *)&__A.realp = v396;
      float v397 = *(float *)(a1 + 556);
      vDSP_vdiv(*(const float **)(*(void *)(a1 + 256) + 24), 1, **(const float ***)(a1 + 256), 1, *v390, 1, *(unsigned int *)(a1 + 60));
      vDSP_Length v398 = *(unsigned int *)(a1 + 60);
      unint64_t v399 = **(float ***)(a1 + 128);
      if (v398)
      {
        unint64_t v400 = 0;
        float v401 = 1.0 - v397;
        do
        {
          if (v399[v400 / 4] < *(float *)(a1 + 180))
          {
            uint64_t v402 = *(void *)(a1 + 600);
            uint64_t v403 = *(void **)(a1 + 256);
            float v404 = (float)(v401 * *(float *)(*v403 + v400)) + (float)(*(float *)(a1 + 556) * *(float *)(v402 + v400));
            *(float *)(v402 + v400) = v404;
            *(float *)(*(void *)(a1 + 576) + v400) = (float)(v401 * (float)(v404 / *(float *)(v403[3] + v400)))
                                                     + (float)(*(float *)(a1 + 556)
                                                             * *(float *)(*(void *)(a1 + 576) + v400));
          }
          v400 += 4;
        }
        while (4 * v398 != v400);
      }
      vDSP_vmax(*(const float **)(a1 + 576), 1, (const float *)(a1 + 560), 0, v399, 1, v398);
      vDSP_vsmul(**(const float ***)(a1 + 128), 1, (const float *)&__A, **(float ***)(a1 + 128), 1, *(unsigned int *)(a1 + 60));
      uint64_t v405 = *(unsigned int *)(a1 + 60);
      uint64_t v371 = a1;
      if (v405)
      {
        unint64_t v406 = 0;
        v408 = *(uint64_t **)(a1 + 256);
        uint64_t v409 = v408[3];
        uint64_t v410 = **(void **)(a1 + 128);
        unint64_t v411 = *(float ****)a3;
        v412 = *(uint64_t **)(*(void *)a3 + 24);
        uint64_t v413 = *v412;
        uint64_t v414 = v412[3];
        uint64_t v415 = *(void **)(a1 + 232);
        uint64_t v416 = v415[3];
        uint64_t v417 = *v497;
        uint64_t v418 = *v408;
        int v419 = *(_DWORD *)(a1 + 16);
        uint64_t v420 = 4 * v405;
        do
        {
          float v421 = *(float *)(v409 + v406);
          float v422 = *(float *)(v410 + v406);
          *(float *)(v413 + v406) = v422 * *(float *)(v413 + v406);
          *(float *)(v414 + v406) = v422 * *(float *)(v414 + v406);
          float v423 = v421 * v422;
          if (v423 > *(float *)(v416 + v406))
          {
            v424 = (void *)v417[3];
            *(_DWORD *)(v413 + v406) = *(_DWORD *)(*v424 + v406);
            *(_DWORD *)(v414 + v406) = *(_DWORD *)(v424[3] + v406);
            float v423 = *(float *)(v416 + v406);
          }
          float v407 = v395 * 2.0 + 2.0;
          float v425 = *(float *)(v418 + v406) * v407;
          if (v423 > v425)
          {
            float v426 = v425 / v423;
            *(float *)(v413 + v406) = v426 * *(float *)(v413 + v406);
            *(float *)(v414 + v406) = v426 * *(float *)(v414 + v406);
          }
          if (v419)
          {
            float v427 = *(float *)(v418 + v406);
            float v428 = *(float *)(*v415 + v406);
            if (v427 <= (float)(*(float *)(a1 + 572) * v428))
            {
              float v434 = v428 * *(float *)(a1 + 720);
              if (v427 > v434)
              {
                float v435 = v434 / v427;
                v436 = *v411;
                (**v411)[v406 / 4] = v435 * (**v411)[v406 / 4];
                v436[3][v406 / 4] = v435 * v436[3][v406 / 4];
                uint64_t v437 = *v312;
                uint64_t v438 = **v312;
                (*v438)[v406 / 4] = v435 * (*v438)[v406 / 4];
                v438[3][v406 / 4] = v435 * v438[3][v406 / 4];
                uint64_t v439 = v437[3];
                (*v439)[v406 / 4] = v435 * (*v439)[v406 / 4];
                v439[3][v406 / 4] = v435 * v439[3][v406 / 4];
              }
            }
            else
            {
              uint64_t v429 = (void *)*v417;
              v430 = *v411;
              (**v411)[v406 / 4] = *(float *)(*(void *)*v417 + v406);
              v430[3][v406 / 4] = *(float *)(v429[3] + v406);
              unint64_t v431 = *v312;
              v432 = **v312;
              (*v432)[v406 / 4] = 1.0;
              v432[3][v406 / 4] = 0.0;
              v433 = v431[3];
              (*v433)[v406 / 4] = 0.0;
              v433[3][v406 / 4] = 0.0;
            }
            float v440 = *(float *)(v409 + v406);
            float v441 = *(float *)(v416 + v406);
            if (v440 <= (float)(*(float *)(a1 + 572) * v441))
            {
              float v446 = v441 * *(float *)(a1 + 724);
              if (v440 > v446)
              {
                float v447 = v446 / v440;
                *(float *)(v413 + v406) = v447 * *(float *)(v413 + v406);
                *(float *)(v414 + v406) = v447 * *(float *)(v414 + v406);
              }
            }
            else
            {
              v442 = (void *)v417[3];
              *(_DWORD *)(v413 + v406) = *(_DWORD *)(*v442 + v406);
              *(_DWORD *)(v414 + v406) = *(_DWORD *)(v442[3] + v406);
              unint64_t v443 = *v312;
              v444 = (*v312)[6];
              (*v444)[v406 / 4] = 0.0;
              v444[3][v406 / 4] = 0.0;
              v445 = v443[9];
              (*v445)[v406 / 4] = 1.0;
              v445[3][v406 / 4] = 0.0;
            }
          }
          v406 += 4;
        }
        while (v420 != v406);
      }
    }
    if (!*(_DWORD *)(v371 + 24)) {
      return 0;
    }
    v448 = (char **)(v371 + 680);
    unint64_t v449 = (uint64_t)(*(void *)(v371 + 688) - *(void *)(v371 + 680)) >> 2;
    LODWORD(__A.realp) = 0;
    std::vector<float>::assign((char **)(v371 + 680), v449, &__A);
    uint64_t v450 = a1;
    float v451 = *(float *)(a1 + 732) + 1.0;
    *(float *)(a1 + 732) = v451;
    float v452 = (float)*(unsigned int *)(a1 + 68);
    float v453 = (float)(*(float *)(v450 + 300) * *(float *)(v450 + 64)) / v452;
    if (v451 > v453) {
      *(float *)(a1 + 732) = v453;
    }
    uint64_t v454 = 0;
    uint64_t v455 = *(void *)(a1 + 768);
    v456 = *(float **)(a1 + 528);
    char v457 = 1;
    long long v458 = *(float **)(a1 + 792);
    do
    {
      char v459 = v457;
      float v460 = (float)(*(float *)(a1 + 820) * *(float *)(v455 + 4 * v454)) + (1.0 - *(float *)(a1 + 820)) * v456[v454];
      *(float *)(v455 + 4 * v454) = v460;
      float v461 = (float)(*(float *)(a1 + 820) * v458[v454])
           + (1.0 - *(float *)(a1 + 820)) * (float)((float)(v456[v454] * v456[v454]) - (float)(v460 * v460));
      v458[v454] = v461;
      uint64_t v454 = 1;
      char v457 = 0;
    }
    while ((v459 & 1) != 0);
    if (fabsf(v458[*(_DWORD *)(a1 + 520) == 1]) > *(float *)(a1 + 824)
      && (float)(fabsf(*v458) + fabsf(v458[1])) > *(float *)(a1 + 828))
    {
      *(_DWORD *)(a1 + 732) = 0;
    }
    if ((float)((float)(*(float *)(a1 + 732) * v452) / *(float *)(a1 + 64)) < *(float *)(a1 + 740))
    {
      unint64_t v462 = (uint64_t)(*(void *)(a1 + 688) - *(void *)(a1 + 680)) >> 2;
      LODWORD(__A.realp) = 1065353216;
      std::vector<float>::assign(v448, v462, &__A);
      uint64_t v450 = a1;
      v456 = *(float **)(a1 + 528);
    }
    float v463 = *v456;
    float v464 = v456[1];
    if (vabds_f32(*v456, v464) < *(float *)(v450 + 744)) {
      goto LABEL_172;
    }
    float v465 = v464 >= v463 ? *v456 : v456[1];
    if (v465 > *(float *)(v450 + 748) || v465 < *(float *)(v450 + 752)) {
      goto LABEL_172;
    }
    if (v463 < v464) {
      float v463 = v456[1];
    }
    if (v463 < *(float *)(v450 + 756) || v463 > *(float *)(v450 + 760))
    {
LABEL_172:
      unint64_t v466 = (uint64_t)(*(void *)(v450 + 688) - *(void *)(v450 + 680)) >> 2;
      LODWORD(__A.realp) = 1065353216;
      std::vector<float>::assign(v448, v466, &__A);
      uint64_t v450 = a1;
    }
    vDSP_Length v467 = *(unsigned int *)(v450 + 60);
    if (v467)
    {
      uint64_t v468 = 0;
      uint64_t v469 = *(void *)(v450 + 680);
      long long v470 = *(const float **)(v450 + 656);
      do
      {
        float v471 = *(float *)(v469 + v468 * 4);
        float v472 = v470[v468];
        if (v471 <= v472) {
          uint64_t v473 = 708;
        }
        else {
          uint64_t v473 = 716;
        }
        float v474 = (float)(v472 * *(float *)(v450 + v473)) + (1.0 - *(float *)(v450 + v473)) * v471;
        v470[v468++] = v474;
      }
      while (v467 != v468);
    }
    else
    {
      long long v470 = *(const float **)(v450 + 656);
    }
    uint64_t v475 = (const float ***)(v450 + 128);
    vDSP_vneg(v470, 1, **(float ***)(v450 + 128), 1, v467);
    vDSP_vsadd(**v475, 1, (const float *)(a1 + 48), (float *)**v475, 1, *(unsigned int *)(a1 + 60));
    uint64_t v476 = 0;
    char v477 = 1;
    uint64_t v478 = a1;
    do
    {
      char v479 = v477;
      v481 = *(float ***)(v478 + 152);
      v480 = (const float **)(v478 + 152);
      vDSP_vmul(v480[63], 1, *(const float **)(*v497)[3 * v476], 1, *v481, 1, *((unsigned int *)v480 - 23));
      vDSP_vmul(v480[63], 1, *(const float **)((*v497)[3 * v476] + 24), 1, *((float **)*v480 + 3), 1, *((unsigned int *)v480 - 23));
      long long v482 = **(float ***)(*(void *)a3 + 24 * v476);
      vDSP_vmul(**(const float ***)(a1 + 128), 1, v482, 1, v482, 1, *((unsigned int *)v480 - 23));
      unint64_t v483 = *(float **)(*(void *)(*(void *)a3 + 24 * v476) + 24);
      vDSP_vmul(**(const float ***)(a1 + 128), 1, v483, 1, v483, 1, *((unsigned int *)v480 - 23));
      v484 = *(float ***)(*(void *)a3 + 24 * v476);
      uint64_t v485 = *v484;
      uint64_t v486 = v484[3];
      uint64_t v487 = *(float **)*v480;
      unint64_t v488 = (float *)*((void *)*v480 + 3);
      vDSP_Length v489 = *((unsigned int *)v480 - 23);
      __A.realp = v485;
      __A.imagp = v486;
      v501.realp = v487;
      v501.imagp = v488;
      __C.realp = v485;
      __C.imagp = v486;
      vDSP_zvadd(&__A, 1, &v501, 1, &__C, 1, v489);
      char v477 = 0;
      uint64_t result = 0;
      uint64_t v476 = 1;
      uint64_t v478 = a1;
    }
    while ((v479 & 1) != 0);
  }
  return result;
}

void AU::BSS1::Handset<float>::ScaleMDP(uint64_t a1, float ****a2, uint64_t *a3)
{
  AU::BSS1::Handset<float>::VectorizedDetInverseOf2x2(a1, a2, (float ***)(a1 + 128));
  unint64_t v6 = **a2;
  uint64_t v7 = *v6;
  uint64_t v8 = v6[3];
  uint64_t v9 = (*a2)[9];
  unint64_t v10 = *v9;
  CFIndex v11 = v9[3];
  CFStringRef v12 = *(float ***)*a3;
  uint64_t v13 = *v12;
  uint64_t v14 = v12[3];
  vDSP_Length v15 = *(unsigned int *)(a1 + 60);
  __A.realp = v7;
  __A.imagp = v8;
  __B.realp = v10;
  __B.imagp = v11;
  v68.realp = v13;
  v68.imagp = v14;
  vDSP_zvmul(&__A, 1, &__B, 1, &v68, 1, v15, 1);
  char v16 = (*a2)[9];
  uint64_t v17 = *v16;
  int v18 = v16[3];
  uint64_t v19 = (*a2)[3];
  unint64_t v20 = *v19;
  unsigned int v21 = v19[3];
  vDSP_Length v22 = *(float ***)(*a3 + 24);
  uint64_t v23 = *v22;
  int v24 = v22[3];
  vDSP_Length v25 = *(unsigned int *)(a1 + 60);
  __A.realp = v17;
  __A.imagp = v18;
  __B.realp = v20;
  __B.imagp = v21;
  v68.realp = v23;
  v68.imagp = v24;
  vDSP_zvmul(&__A, 1, &__B, 1, &v68, 1, v25, 1);
  unint64_t v26 = **a2;
  unsigned int v27 = *v26;
  float v28 = v26[3];
  char v29 = (*a2)[6];
  float v30 = *v29;
  unsigned int v31 = v29[3];
  __int16 v32 = *(float ***)(*a3 + 48);
  float v33 = *v32;
  uint64_t v34 = v32[3];
  vDSP_Length v35 = *(unsigned int *)(a1 + 60);
  __A.realp = v27;
  __A.imagp = v28;
  __B.realp = v30;
  __B.imagp = v31;
  v68.realp = v33;
  v68.imagp = v34;
  vDSP_zvmul(&__A, 1, &__B, 1, &v68, 1, v35, 1);
  float v36 = *(float ***)*a3;
  float v37 = *v36;
  uint64_t v38 = v36[3];
  uint64_t v39 = *(float ***)(*a3 + 72);
  char v40 = *v39;
  uint64_t v41 = v39[3];
  vDSP_Length v42 = *(unsigned int *)(a1 + 60);
  __A.realp = v37;
  __A.imagp = v38;
  __B.realp = v40;
  __B.imagp = v41;
  vDSP_zvmov(&__A, 1, &__B, 1, v42);
  for (uint64_t i = 0; i != 96; i += 24)
  {
    DSPSplitComplex v44 = *(float ***)(a1 + 128);
    uint64_t v45 = *v44;
    float v46 = v44[3];
    std::vector<char>::pointer v47 = *(float ***)(*a3 + i);
    int v48 = *v47;
    float v49 = v47[3];
    vDSP_Length v50 = *(unsigned int *)(a1 + 60);
    __A.realp = v45;
    __A.imagp = v46;
    __B.realp = v48;
    __B.imagp = v49;
    v68.realp = v48;
    v68.imagp = v49;
    vDSP_zvmul(&__A, 1, &__B, 1, &v68, 1, v50, 1);
  }
  AU::BSS1::Handset<float>::ClearDCAndNyquist(*(unsigned int *)(a1 + 60), *a3);
  float v51 = *(float ***)*a3;
  float v52 = *v51;
  float v53 = v51[3];
  float v54 = **(float ***)(a1 + 336);
  vDSP_Length v55 = *(unsigned int *)(a1 + 60);
  __A.realp = v52;
  __A.imagp = v53;
  vDSP_zvabs(&__A, 1, v54, 1, v55);
  uint64_t v56 = *(float ***)(*a3 + 48);
  int v57 = *v56;
  CFTypeID v58 = v56[3];
  BOOL v59 = *(float **)(*(void *)(a1 + 336) + 24);
  vDSP_Length v60 = *(unsigned int *)(a1 + 60);
  __A.realp = v57;
  __A.imagp = v58;
  vDSP_zvabs(&__A, 1, v59, 1, v60);
  CFTypeID v61 = *(float ***)(*a3 + 24);
  CFDictionaryRef v62 = *v61;
  uint64_t v63 = v61[3];
  CFDictionaryRef v64 = *(float **)(*(void *)(a1 + 336) + 48);
  vDSP_Length v65 = *(unsigned int *)(a1 + 60);
  __A.realp = v62;
  __A.imagp = v63;
  vDSP_zvabs(&__A, 1, v64, 1, v65);
  uint64_t v66 = *(void *)(a1 + 336);
  uint64_t v67 = *(void *)(v66 + 8);
  if (v67 != *(void *)v66) {
    memmove(*(void **)(v66 + 72), *(const void **)v66, v67 - *(void *)v66);
  }
}

void AU::BSS1::Handset<float>::GenerateOutput(uint64_t a1, float ****a2, float ****a3, float ****a4)
{
  uint64_t v8 = **a4;
  uint64_t v9 = *v8;
  unint64_t v10 = v8[3];
  CFIndex v11 = **a2;
  CFStringRef v12 = *v11;
  uint64_t v13 = v11[3];
  uint64_t v14 = *(float ***)(a1 + 128);
  vDSP_Length v15 = *v14;
  char v16 = v14[3];
  vDSP_Length v17 = *(unsigned int *)(a1 + 60);
  __A.realp = v9;
  __A.imagp = v10;
  __B.realp = v12;
  __B.imagp = v13;
  v68.realp = v15;
  v68.imagp = v16;
  vDSP_zvmul(&__A, 1, &__B, 1, &v68, 1, v17, 1);
  int v18 = (*a4)[3];
  uint64_t v19 = *v18;
  unint64_t v20 = v18[3];
  unsigned int v21 = (*a2)[3];
  vDSP_Length v22 = *v21;
  uint64_t v23 = v21[3];
  int v24 = *(float ***)(a1 + 152);
  vDSP_Length v25 = *v24;
  unint64_t v26 = v24[3];
  vDSP_Length v27 = *(unsigned int *)(a1 + 60);
  __A.realp = v19;
  __A.imagp = v20;
  __B.realp = v22;
  __B.imagp = v23;
  v68.realp = v25;
  v68.imagp = v26;
  vDSP_zvmul(&__A, 1, &__B, 1, &v68, 1, v27, 1);
  float v28 = *(float ***)(a1 + 128);
  char v29 = *v28;
  float v30 = v28[3];
  unsigned int v31 = *(float ***)(a1 + 152);
  __int16 v32 = *v31;
  float v33 = v31[3];
  uint64_t v34 = **a3;
  vDSP_Length v35 = *v34;
  float v36 = v34[3];
  vDSP_Length v37 = *(unsigned int *)(a1 + 60);
  __A.realp = v29;
  __A.imagp = v30;
  __B.realp = v32;
  __B.imagp = v33;
  v68.realp = v35;
  v68.imagp = v36;
  vDSP_zvadd(&__A, 1, &__B, 1, &v68, 1, v37);
  uint64_t v38 = **a2;
  uint64_t v39 = *v38;
  char v40 = v38[3];
  uint64_t v41 = (*a4)[6];
  vDSP_Length v42 = *v41;
  char v43 = v41[3];
  DSPSplitComplex v44 = *(float ***)(a1 + 128);
  uint64_t v45 = *v44;
  float v46 = v44[3];
  vDSP_Length v47 = *(unsigned int *)(a1 + 60);
  __A.realp = v39;
  __A.imagp = v40;
  __B.realp = v42;
  __B.imagp = v43;
  v68.realp = v45;
  v68.imagp = v46;
  vDSP_zvmul(&__A, 1, &__B, 1, &v68, 1, v47, 1);
  int v48 = (*a2)[3];
  float v49 = *v48;
  vDSP_Length v50 = v48[3];
  float v51 = (*a4)[9];
  float v52 = *v51;
  float v53 = v51[3];
  float v54 = *(float ***)(a1 + 152);
  vDSP_Length v55 = *v54;
  uint64_t v56 = v54[3];
  vDSP_Length v57 = *(unsigned int *)(a1 + 60);
  __A.realp = v49;
  __A.imagp = v50;
  __B.realp = v52;
  __B.imagp = v53;
  v68.realp = v55;
  v68.imagp = v56;
  vDSP_zvmul(&__A, 1, &__B, 1, &v68, 1, v57, 1);
  CFTypeID v58 = *(float ***)(a1 + 128);
  BOOL v59 = *v58;
  vDSP_Length v60 = v58[3];
  CFTypeID v61 = *(float ***)(a1 + 152);
  CFDictionaryRef v62 = *v61;
  uint64_t v63 = v61[3];
  CFDictionaryRef v64 = (*a3)[3];
  vDSP_Length v65 = *v64;
  uint64_t v66 = v64[3];
  vDSP_Length v67 = *(unsigned int *)(a1 + 60);
  __A.realp = v59;
  __A.imagp = v60;
  __B.realp = v62;
  __B.imagp = v63;
  v68.realp = v65;
  v68.imagp = v66;
  vDSP_zvadd(&__A, 1, &__B, 1, &v68, 1, v67);
}

void AU::BSS1::Handset<float>::VectorizedDetInverseOf2x2(uint64_t a1, float ****a2, float ***a3)
{
  unint64_t v6 = **a2;
  uint64_t v7 = *v6;
  uint64_t v8 = v6[3];
  uint64_t v9 = (*a2)[9];
  unint64_t v10 = *v9;
  CFIndex v11 = v9[3];
  CFStringRef v12 = *(float ***)(a1 + 128);
  uint64_t v13 = *v12;
  uint64_t v14 = v12[3];
  vDSP_Length v15 = *(unsigned int *)(a1 + 60);
  __A.realp = v7;
  __A.imagp = v8;
  __B.realp = v10;
  __B.imagp = v11;
  v39.realp = v13;
  v39.imagp = v14;
  vDSP_zvmul(&__A, 1, &__B, 1, &v39, 1, v15, 1);
  char v16 = (*a2)[3];
  vDSP_Length v17 = *v16;
  int v18 = v16[3];
  uint64_t v19 = (*a2)[6];
  unint64_t v20 = *v19;
  unsigned int v21 = v19[3];
  vDSP_Length v22 = *(float ***)(a1 + 152);
  uint64_t v23 = *v22;
  int v24 = v22[3];
  vDSP_Length v25 = *(unsigned int *)(a1 + 60);
  __A.realp = v17;
  __A.imagp = v18;
  __B.realp = v20;
  __B.imagp = v21;
  v39.realp = v23;
  v39.imagp = v24;
  vDSP_zvmul(&__A, 1, &__B, 1, &v39, 1, v25, 1);
  unint64_t v26 = *(float ***)(a1 + 128);
  vDSP_Length v27 = *v26;
  float v28 = v26[3];
  char v29 = *(float ***)(a1 + 152);
  float v30 = *v29;
  unsigned int v31 = v29[3];
  vDSP_Length v32 = *(unsigned int *)(a1 + 60);
  __A.realp = v27;
  __A.imagp = v28;
  __B.realp = v30;
  __B.imagp = v31;
  v39.realp = v30;
  v39.imagp = v31;
  vDSP_zvsub(&__A, 1, &__B, 1, &v39, 1, v32);
  vDSP_vsadd(**(const float ***)(a1 + 152), 1, (const float *)(a1 + 56), **(float ***)(a1 + 152), 1, *(unsigned int *)(a1 + 60));
  float v33 = *(float ***)(a1 + 152);
  uint64_t v34 = *v33;
  vDSP_Length v35 = v33[3];
  float v36 = **a3;
  vDSP_Length v37 = (*a3)[3];
  vDSP_Length v38 = *(unsigned int *)(a1 + 60);
  __A.realp = (float *)(a1 + 48);
  __A.imagp = (float *)(a1 + 52);
  __B.realp = v34;
  __B.imagp = v35;
  v39.realp = v36;
  v39.imagp = v37;
  vDSP_zvdiv(&__B, 1, &__A, 0, &v39, 1, v38);
}

uint64_t AU::BSS1::Handset<float>::ClearDCAndNyquist(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(_DWORD ***)a2;
  uint64_t v3 = **(_DWORD ***)a2;
  _DWORD *v3 = 1065353216;
  uint64_t v4 = *(void *)(a2 + 24);
  unint64_t v5 = *(_DWORD **)v4;
  _DWORD *v5 = 0;
  uint64_t v6 = *(void *)(a2 + 48);
  uint64_t v7 = *(_DWORD **)v6;
  *uint64_t v7 = 0;
  uint64_t v8 = *(void *)(a2 + 72);
  uint64_t v9 = *(_DWORD **)v8;
  _DWORD *v9 = 1065353216;
  unint64_t v10 = v2[3];
  *unint64_t v10 = 0;
  CFIndex v11 = *(_DWORD **)(v4 + 24);
  _DWORD *v11 = 0;
  CFStringRef v12 = *(_DWORD **)(v6 + 24);
  _DWORD *v12 = 0;
  uint64_t v13 = *(_DWORD **)(v8 + 24);
  *uint64_t v13 = 0;
  int v14 = result - 1;
  v3[v14] = 1065353216;
  v5[v14] = 0;
  v7[v14] = 0;
  v9[v14] = 1065353216;
  v10[v14] = 0;
  v11[v14] = 0;
  v12[v14] = 0;
  v13[v14] = 0;
  return result;
}

float AU::BSS1::Handset<float>::Reset(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 8)) {
    return result;
  }
  LODWORD(v85[0]) = 0;
  std::vector<float>::resize(a1 + 528, 2uLL, v85);
  LODWORD(v85[0]) = 0;
  std::vector<float>::resize(a1 + 768, 2uLL, v85);
  LODWORD(v85[0]) = 0;
  std::vector<float>::resize(a1 + 792, 2uLL, v85);
  LODWORD(v85[0]) = 0;
  std::vector<float>::resize(a1 + 624, 2uLL, v85);
  unint64_t v2 = *(unsigned int *)(a1 + 60);
  LODWORD(v85[0]) = 0;
  std::vector<float>::resize(a1 + 656, v2, v85);
  unint64_t v3 = *(unsigned int *)(a1 + 60);
  LODWORD(v85[0]) = 0;
  std::vector<float>::resize(a1 + 680, v3, v85);
  unint64_t v4 = *(unsigned int *)(a1 + 60);
  LODWORD(v85[0]) = 1065353216;
  std::vector<float>::resize(a1 + 576, v4, v85);
  unint64_t v5 = *(unsigned int *)(a1 + 60);
  LODWORD(v85[0]) = 1065353216;
  std::vector<float>::resize(a1 + 208, v5, v85);
  unint64_t v6 = *(unsigned int *)(a1 + 60);
  float v7 = 0.01 / (double)(2 * v6 - 2);
  *(float *)uint64_t v85 = v7;
  std::vector<float>::resize(a1 + 600, v6, v85);
  std::vector<std::vector<std::vector<float>>>::resize((uint64_t *)(a1 + 80), 2uLL);
  uint64_t v8 = 0;
  char v9 = 1;
  do
  {
    char v10 = v9;
    uint64_t v11 = 3 * v8;
    std::vector<std::vector<float>>::resize((uint64_t *)(*(void *)(a1 + 80) + 24 * v8), 2uLL);
    uint64_t v12 = *(void *)(*(void *)(a1 + 80) + 8 * v11);
    unint64_t v13 = *(unsigned int *)(a1 + 60);
    LODWORD(v85[0]) = 0;
    std::vector<float>::resize(v12, v13, v85);
    uint64_t v14 = *(void *)(*(void *)(a1 + 80) + 8 * v11) + 24;
    unint64_t v15 = *(unsigned int *)(a1 + 60);
    LODWORD(v85[0]) = 0;
    std::vector<float>::resize(v14, v15, v85);
    char v9 = 0;
    uint64_t v8 = 1;
  }
  while ((v10 & 1) != 0);
  char v16 = (void ***)(a1 + 456);
  uint64_t v17 = *(void *)(a1 + 456);
  int v18 = *(void ***)(a1 + 464);
  uint64_t v19 = (char *)v18 - v17;
  unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v18 - v17) >> 3);
  if (v20 <= 1)
  {
    uint64_t v21 = *(void *)(a1 + 472);
    if (0xAAAAAAAAAAAAAAABLL * ((v21 - (uint64_t)v18) >> 3) < 2 - v20)
    {
      v85[4] = (void **)(a1 + 472);
      unint64_t v22 = 0xAAAAAAAAAAAAAAABLL * ((v21 - v17) >> 3);
      uint64_t v23 = 2 * v22;
      if (2 * v22 <= 2) {
        uint64_t v23 = 2;
      }
      if (v22 >= 0x555555555555555) {
        unint64_t v24 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v24 = v23;
      }
      vDSP_Length v25 = (void **)std::__allocate_at_least[abi:ne180100]<std::allocator<AUPropertyItem>>(v24);
      unint64_t v26 = &v25[3 * v20];
      v85[0] = v25;
      v85[1] = v26;
      v85[3] = &v25[3 * v27];
      size_t v28 = 24 * ((24 - (uint64_t)v19) / 0x18uLL) + 24;
      bzero(v26, v28);
      v85[2] = (void **)((char *)v26 + v28);
      std::vector<std::vector<unsigned int>>::__swap_out_circular_buffer((void *)(a1 + 456), v85);
      std::__split_buffer<std::vector<std::vector<std::vector<float>>>>::~__split_buffer((uint64_t)v85);
      char v29 = *(void ***)(a1 + 464);
      goto LABEL_17;
    }
    size_t v30 = 24 * ((24 - (uint64_t)v19) / 0x18uLL) + 24;
    bzero(*(void **)(a1 + 464), v30);
    char v29 = (void **)((char *)v18 + v30);
    goto LABEL_16;
  }
  if (v19 != (char *)48)
  {
    char v29 = (void **)(v17 + 48);
    while (v18 != v29)
    {
      v18 -= 3;
      v85[0] = v18;
      std::vector<std::vector<std::vector<DspLib::Biquad::Section>>>::__destroy_vector::operator()[abi:ne180100](v85);
    }
LABEL_16:
    *(void *)(a1 + 464) = v29;
    goto LABEL_17;
  }
  char v29 = *(void ***)(a1 + 464);
LABEL_17:
  unsigned int v31 = *v16;
  if (v29 != *v16)
  {
    unint64_t v32 = 0;
    do
    {
      std::vector<std::vector<std::vector<float>>>::resize((uint64_t *)&v31[3 * v32], 4uLL);
      for (uint64_t i = 0; i != 96; i += 24)
      {
        std::vector<std::vector<float>>::resize((uint64_t *)(*(void *)(*(void *)(a1 + 456) + 24 * v32) + i), 2uLL);
        uint64_t v34 = *(void *)(*(void *)(*(void *)(a1 + 456) + 24 * v32) + i);
        unint64_t v35 = *(unsigned int *)(a1 + 60);
        LODWORD(v85[0]) = 0;
        std::vector<float>::resize(v34, v35, v85);
        uint64_t v36 = *(void *)(*(void *)(*(void *)(a1 + 456) + 24 * v32) + i) + 24;
        unint64_t v37 = *(unsigned int *)(a1 + 60);
        LODWORD(v85[0]) = 0;
        std::vector<float>::resize(v36, v37, v85);
      }
      ++v32;
      unsigned int v31 = *(void ***)(a1 + 456);
    }
    while (v32 < 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 464) - (void)v31) >> 3));
  }
  uint64_t v38 = 0;
  char v39 = 1;
  do
  {
    char v40 = v39;
    uint64_t v41 = 3 * v38;
    std::vector<float>::assign(**(char ****)(*(void *)(a1 + 456) + 24 * v38), *(unsigned int *)(a1 + 60), (_DWORD *)(a1 + 292));
    std::vector<float>::assign(*(char ***)(*(void *)(*(void *)(a1 + 456) + 8 * v41) + 72), *(unsigned int *)(a1 + 60), (_DWORD *)(a1 + 292));
    char v39 = 0;
    uint64_t v38 = 1;
  }
  while ((v40 & 1) != 0);
  LODWORD(v85[0]) = 0;
  std::vector<float>::resize(a1 + 360, 2uLL, v85);
  std::vector<std::vector<float>>::resize((uint64_t *)(a1 + 336), 4uLL);
  uint64_t v42 = *(void *)(a1 + 336);
  if (*(void *)(a1 + 344) != v42)
  {
    uint64_t v43 = 0;
    unint64_t v44 = 0;
    do
    {
      unint64_t v45 = *(unsigned int *)(a1 + 60);
      LODWORD(v85[0]) = 0;
      std::vector<float>::resize(v42 + v43, v45, v85);
      ++v44;
      uint64_t v42 = *(void *)(a1 + 336);
      v43 += 24;
    }
    while (v44 < 0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 344) - v42) >> 3));
  }
  unint64_t v46 = *(unsigned int *)(a1 + 60);
  LODWORD(v85[0]) = 0;
  std::vector<float>::resize(a1 + 384, v46, v85);
  uint64_t v47 = *(unsigned int *)(a1 + 60);
  if (v47)
  {
    unint64_t v48 = 0;
    uint64_t v49 = *(void *)(a1 + 384);
    do
    {
      float v50 = *(float *)(a1 + 280) / ((double)v48 * 0.5 * (double)v48 + 1.0);
      *(float *)(v49 + 4 * v48++) = v50;
    }
    while (v47 != v48);
  }
  std::vector<std::vector<std::vector<float>>>::resize((uint64_t *)(a1 + 408), 4uLL);
  for (uint64_t j = 0; j != 4; ++j)
  {
    std::vector<std::vector<float>>::resize((uint64_t *)(*(void *)(a1 + 408) + 24 * j), 2uLL);
    uint64_t v52 = *(void *)(*(void *)(a1 + 408) + 24 * j);
    unint64_t v53 = *(unsigned int *)(a1 + 60);
    LODWORD(v85[0]) = 0;
    std::vector<float>::resize(v52, v53, v85);
    uint64_t v54 = *(void *)(*(void *)(a1 + 408) + 24 * j) + 24;
    unint64_t v55 = *(unsigned int *)(a1 + 60);
    LODWORD(v85[0]) = 0;
    std::vector<float>::resize(v54, v55, v85);
    uint64_t v56 = *(unsigned int *)(a1 + 60);
    if (v56)
    {
      uint64_t v57 = 0;
      uint64_t v58 = 4 * v56;
      do
      {
        if (j == 3 || !j) {
          *(_DWORD *)(**(void **)(*(void *)(a1 + 408) + 24 * j) + v57) = 1065353216;
        }
        v57 += 4;
      }
      while (v58 != v57);
    }
  }
  std::vector<std::vector<std::vector<float>>>::__assign_with_size[abi:ne180100]<std::vector<std::vector<float>>*,std::vector<std::vector<float>>*>(a1 + 432, *(uint64_t **)(a1 + 408), *(uint64_t **)(a1 + 416), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 416) - *(void *)(a1 + 408)) >> 3));
  std::vector<std::vector<std::vector<float>>>::resize((uint64_t *)(a1 + 104), 4uLL);
  for (uint64_t k = 0; k != 96; k += 24)
  {
    std::vector<std::vector<float>>::resize((uint64_t *)(*(void *)(a1 + 104) + k), 2uLL);
    uint64_t v60 = *(void *)(*(void *)(a1 + 104) + k);
    unint64_t v61 = *(unsigned int *)(a1 + 60);
    LODWORD(v85[0]) = 0;
    std::vector<float>::resize(v60, v61, v85);
    uint64_t v62 = *(void *)(*(void *)(a1 + 104) + k) + 24;
    unint64_t v63 = *(unsigned int *)(a1 + 60);
    LODWORD(v85[0]) = 0;
    std::vector<float>::resize(v62, v63, v85);
  }
  std::vector<std::vector<float>>::resize((uint64_t *)(a1 + 128), 2uLL);
  std::vector<std::vector<float>>::resize((uint64_t *)(a1 + 152), 2uLL);
  uint64_t v64 = 0;
  char v65 = 1;
  do
  {
    char v66 = v65;
    uint64_t v67 = 3 * v64;
    uint64_t v68 = *(void *)(a1 + 128) + 24 * v64;
    unint64_t v69 = *(unsigned int *)(a1 + 60);
    LODWORD(v85[0]) = 0;
    std::vector<float>::resize(v68, v69, v85);
    uint64_t v70 = *(void *)(a1 + 152) + 8 * v67;
    unint64_t v71 = *(unsigned int *)(a1 + 60);
    LODWORD(v85[0]) = 0;
    std::vector<float>::resize(v70, v71, v85);
    char v65 = 0;
    uint64_t v64 = 1;
  }
  while ((v66 & 1) != 0);
  std::vector<std::vector<float>>::resize((uint64_t *)(a1 + 232), 2uLL);
  std::vector<std::vector<float>>::resize((uint64_t *)(a1 + 256), 2uLL);
  uint64_t v72 = 0;
  char v73 = 1;
  do
  {
    char v74 = v73;
    uint64_t v75 = 3 * v72;
    uint64_t v76 = *(void *)(a1 + 232) + 24 * v72;
    unint64_t v77 = *(unsigned int *)(a1 + 60);
    LODWORD(v85[0]) = 0;
    std::vector<float>::resize(v76, v77, v85);
    uint64_t v78 = *(void *)(a1 + 232) + 8 * v75;
    unint64_t v79 = *(unsigned int *)(a1 + 60);
    LODWORD(v85[0]) = 0;
    std::vector<float>::resize(v78, v79, v85);
    uint64_t v80 = *(void *)(a1 + 256) + 8 * v75;
    unint64_t v81 = *(unsigned int *)(a1 + 60);
    LODWORD(v85[0]) = 0;
    std::vector<float>::resize(v80, v81, v85);
    uint64_t v82 = *(void *)(a1 + 256) + 8 * v75;
    unint64_t v83 = *(unsigned int *)(a1 + 60);
    LODWORD(v85[0]) = 0;
    std::vector<float>::resize(v82, v83, v85);
    char v73 = 0;
    uint64_t v72 = 1;
  }
  while ((v74 & 1) != 0);
  float result = (float)((float)(*(float *)(a1 + 740) * *(float *)(a1 + 64)) / (float)*(unsigned int *)(a1 + 68)) + 1.0;
  *(float *)(a1 + 732) = result;
  *(void *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 520) = 0;
  *(_DWORD *)(a1 + 728) = 0;
  *(_DWORD *)(a1 + 736) = 0;
  return result;
}

uint64_t std::__split_buffer<std::vector<std::vector<std::vector<float>>>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    unint64_t v4 = (void **)(i - 24);
    *(void *)(a1 + 16) = v4;
    unint64_t v6 = v4;
    std::vector<std::vector<std::vector<DspLib::Biquad::Section>>>::__destroy_vector::operator()[abi:ne180100](&v6);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t AU::BSS1::Handset<float>::Init(uint64_t a1, int a2, unsigned int a3, unsigned int a4, float a5)
{
  if (a5 < 0.0 || a2 != 2 || a3 < a4) {
    return 1;
  }
  *(_DWORD *)(a1 + 60) = a3;
  *(float *)(a1 + 64) = a5;
  *(_DWORD *)(a1 + 68) = a4;
  float v9 = a5 / (float)a4;
  *(float *)(a1 + 72) = v9;
  float v10 = a5 / ((double)a3 + -1.0 + (double)a3 + -1.0);
  unsigned int v11 = a3 - 1;
  unsigned int v12 = vcvtas_u32_f32(fabsf((float)*(unsigned int *)(a1 + 196) / v10));
  if (v12 >= a3 - 1) {
    unsigned int v12 = a3 - 1;
  }
  *(_DWORD *)(a1 + 200) = v12;
  unsigned int v13 = vcvtas_u32_f32(fabsf((float)*(unsigned int *)(a1 + 304) / v10));
  if (v13 >= v11) {
    unsigned int v13 = a3 - 1;
  }
  *(_DWORD *)(a1 + 308) = v13;
  unsigned int v14 = vcvtas_u32_f32(fabsf((float)*(unsigned int *)(a1 + 496) / v10));
  if (v14 >= v11) {
    unsigned int v14 = a3 - 1;
  }
  *(_DWORD *)(a1 + 500) = v14;
  unsigned int v15 = vcvtas_u32_f32(fabsf((float)*(unsigned int *)(a1 + 504) / v10));
  if (v15 < v11) {
    unsigned int v11 = v15;
  }
  *(_DWORD *)(a1 + 508) = v11;
  float v16 = 0.0;
  float v17 = 0.0;
  if (v9 > 0.0)
  {
    float v18 = *(float *)(a1 + 312);
    if (v18 > 0.0) {
      float v17 = exp(-1.0 / (float)(v9 * v18));
    }
  }
  *(float *)(a1 + 316) = v17;
  if (v9 > 0.0)
  {
    float v19 = *(float *)(a1 + 184);
    if (v19 > 0.0) {
      float v16 = exp(-1.0 / (float)(v9 * v19));
    }
  }
  *(float *)(a1 + 188) = v16;
  float v20 = 0.0;
  float v21 = 0.0;
  if (v9 > 0.0)
  {
    float v22 = *(float *)(a1 + 552);
    if (v22 > 0.0) {
      float v21 = exp(-1.0 / (float)(v9 * v22));
    }
  }
  *(float *)(a1 + 556) = v21;
  if (v9 > 0.0)
  {
    float v23 = *(float *)(a1 + 704);
    if (v23 > 0.0) {
      float v20 = exp(-1.0 / (float)(v9 * v23));
    }
  }
  *(float *)(a1 + 708) = v20;
  float v24 = 0.0;
  float v25 = 0.0;
  if (v9 > 0.0)
  {
    float v26 = *(float *)(a1 + 712);
    if (v26 > 0.0) {
      float v25 = exp(-1.0 / (float)(v9 * v26));
    }
  }
  *(float *)(a1 + 716) = v25;
  if (v9 > 0.0)
  {
    float v27 = *(float *)(a1 + 816);
    if (v27 > 0.0) {
      float v24 = exp(-1.0 / (float)(v9 * v27));
    }
  }
  *(float *)(a1 + 820) = v24;
  float v28 = 0.0;
  if (v9 > 0.0)
  {
    float v29 = *(float *)(a1 + 648);
    if (v29 > 0.0) {
      float v28 = exp(-1.0 / (float)(v9 * v29));
    }
  }
  *(float *)(a1 + 652) = v28;
  *(unsigned char *)(a1 + 8) = 1;
  (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
  return 0;
}

void AU::BSS1::Handset<float>::~Handset(uint64_t a1)
{
  AU::BSS1::Handset<float>::~Handset(a1);

  JUMPOUT(0x1C185D370);
}

uint64_t AU::BSS1::Handset<float>::~Handset(uint64_t a1)
{
  *(void *)a1 = &unk_1F14AC898;
  unint64_t v2 = *(void **)(a1 + 792);
  if (v2)
  {
    *(void *)(a1 + 800) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)(a1 + 768);
  if (v3)
  {
    *(void *)(a1 + 776) = v3;
    operator delete(v3);
  }
  unint64_t v4 = *(void **)(a1 + 680);
  if (v4)
  {
    *(void *)(a1 + 688) = v4;
    operator delete(v4);
  }
  unint64_t v5 = *(void **)(a1 + 656);
  if (v5)
  {
    *(void *)(a1 + 664) = v5;
    operator delete(v5);
  }
  unint64_t v6 = *(void **)(a1 + 624);
  if (v6)
  {
    *(void *)(a1 + 632) = v6;
    operator delete(v6);
  }
  float v7 = *(void **)(a1 + 600);
  if (v7)
  {
    *(void *)(a1 + 608) = v7;
    operator delete(v7);
  }
  uint64_t v8 = *(void **)(a1 + 576);
  if (v8)
  {
    *(void *)(a1 + 584) = v8;
    operator delete(v8);
  }
  float v9 = *(void **)(a1 + 528);
  if (v9)
  {
    *(void *)(a1 + 536) = v9;
    operator delete(v9);
  }
  unsigned int v14 = (void **)(a1 + 456);
  std::vector<std::vector<std::vector<std::vector<float>>>>::__destroy_vector::operator()[abi:ne180100](&v14);
  unsigned int v14 = (void **)(a1 + 432);
  std::vector<std::vector<std::vector<DspLib::Biquad::Section>>>::__destroy_vector::operator()[abi:ne180100](&v14);
  unsigned int v14 = (void **)(a1 + 408);
  std::vector<std::vector<std::vector<DspLib::Biquad::Section>>>::__destroy_vector::operator()[abi:ne180100](&v14);
  float v10 = *(void **)(a1 + 384);
  if (v10)
  {
    *(void *)(a1 + 392) = v10;
    operator delete(v10);
  }
  unsigned int v11 = *(void **)(a1 + 360);
  if (v11)
  {
    *(void *)(a1 + 368) = v11;
    operator delete(v11);
  }
  unsigned int v14 = (void **)(a1 + 336);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v14);
  unsigned int v14 = (void **)(a1 + 256);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v14);
  unsigned int v14 = (void **)(a1 + 232);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v14);
  unsigned int v12 = *(void **)(a1 + 208);
  if (v12)
  {
    *(void *)(a1 + 216) = v12;
    operator delete(v12);
  }
  unsigned int v14 = (void **)(a1 + 152);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v14);
  unsigned int v14 = (void **)(a1 + 128);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v14);
  unsigned int v14 = (void **)(a1 + 104);
  std::vector<std::vector<std::vector<DspLib::Biquad::Section>>>::__destroy_vector::operator()[abi:ne180100](&v14);
  unsigned int v14 = (void **)(a1 + 80);
  std::vector<std::vector<std::vector<DspLib::Biquad::Section>>>::__destroy_vector::operator()[abi:ne180100](&v14);
  return a1;
}

void AUBSS1::~AUBSS1(AUBSS1 *this)
{
  AUBSS1::~AUBSS1(this);

  JUMPOUT(0x1C185D370);
}

{
  uint64_t v2;
  void **v3;
  uint64_t vars8;

  *(void *)this = &unk_1F14AC628;
  AUBSS1::Cleanup(this);
  uint64_t v3 = (void **)((char *)this + 624);
  std::vector<std::vector<std::vector<DspLib::Biquad::Section>>>::__destroy_vector::operator()[abi:ne180100](&v3);
  uint64_t v3 = (void **)((char *)this + 600);
  std::vector<std::vector<std::vector<DspLib::Biquad::Section>>>::__destroy_vector::operator()[abi:ne180100](&v3);
  std::unique_ptr<BlockProcessor>::reset[abi:ne180100]((uint64_t *)this + 74, 0);
  unint64_t v2 = *((void *)this + 73);
  *((void *)this + 73) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = (void **)((char *)this + 560);
  std::vector<std::unique_ptr<VPTimeFreqConverter>>::__destroy_vector::operator()[abi:ne180100](&v3);

  ausdk::AUBase::~AUBase(this);
}

id getIntToNSStringScopeMap(void)
{
  v3[8] = *MEMORY[0x1E4F143B8];
  {
    v2[0] = &unk_1F14EBA60;
    v2[1] = &unk_1F14EBA78;
    v3[0] = @"Global";
    v3[1] = @"Input";
    v2[2] = &unk_1F14EBA90;
    v2[3] = &unk_1F14EBAA8;
    _DWORD v3[2] = @"Output";
    v3[3] = @"Group";
    v2[4] = &unk_1F14EBAC0;
    v2[5] = &unk_1F14EBAD8;
    v3[4] = @"Part";
    v3[5] = @"Note";
    v2[6] = &unk_1F14EBAF0;
    v2[7] = &unk_1F14EBB08;
    v3[6] = @"Layer";
    v3[7] = @"LayerItem";
    getIntToNSStringScopeMap(void)::intToNSStringMapScope = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v3 forKeys:v2 count:8];
  }
  v0 = (void *)getIntToNSStringScopeMap(void)::intToNSStringMapScope;

  return v0;
}

void sub_1BB38DE90(_Unwind_Exception *a1)
{
}

id createNSDescriptionFromDSPGraphBox(DSPGraph::Box *a1)
{
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  id v58 = [MEMORY[0x1E4F1CA60] dictionary];
  if ((*(uint64_t (**)(DSPGraph::Box *))(*(void *)a1 + 216))(a1))
  {
    uint64_t v2 = (*(uint64_t (**)(DSPGraph::Box *))(*(void *)a1 + 216))(a1);
    uint64_t v3 = createNSDescriptionFromAudioUnit(*(OpaqueAudioComponentInstance **)(v2 + 848));
    [v58 setObject:v3 forKey:@"AUState"];
  }
  BOOL v59 = [MEMORY[0x1E4F1CA60] dictionary];
  uint64_t v60 = getIntToNSStringScopeMap();
  unint64_t v62 = [v60 count];
  if (!v62) {
    goto LABEL_55;
  }
  for (unint64_t i = 0; i < v62; unint64_t i = (i + 1))
  {
    int v66 = 4;
    unsigned int v67 = 0;
    if ((*(unsigned int (**)(DSPGraph::Box *, uint64_t, unint64_t, void, unsigned int *, int *))(*(void *)a1 + 304))(a1, 11, i, 0, &v67, &v66))
    {
      continue;
    }
    uint64_t v64 = [MEMORY[0x1E4F1CA60] dictionary];
    if (!v67) {
      goto LABEL_53;
    }
    uint64_t v5 = 0;
    do
    {
      id v6 = [MEMORY[0x1E4F1CA60] dictionary];
      float v7 = [MEMORY[0x1E4F1CA60] dictionary];
      {
        qword_1E9F7FA98 = 0;
        qword_1E9F7FA90 = 0;
        getBoxGenericPropertyMap(void)::gMap = (uint64_t)&qword_1E9F7FA90;
      }
      if (getBoxGenericPropertyMap(void)::onceToken != -1) {
        dispatch_once(&getBoxGenericPropertyMap(void)::onceToken, &__block_literal_global_371);
      }
      uint64_t v8 = getBoxGenericPropertyMap(void)::gMap;
      if ((uint64_t *)getBoxGenericPropertyMap(void)::gMap != &qword_1E9F7FA90)
      {
        do
        {
          uint64_t v9 = *(unsigned int *)(v8 + 32);
          id v10 = *(id *)(v8 + 40);
          unsigned int v11 = (*(uint64_t (**)(DSPGraph::Box *, uint64_t, unint64_t, uint64_t))(*(void *)a1 + 296))(a1, v9, i, v5);
          if (v12)
          {
            std::vector<char>::vector(&v71, v11);
            LODWORD(__p) = LODWORD(v71.__end_) - LODWORD(v71.__begin_);
            if (!(*(unsigned int (**)(DSPGraph::Box *, uint64_t, unint64_t, uint64_t, void **))(*(void *)a1 + 304))(a1, v9, i, v5, &__p))
            {
              getValueTypeFunctionCastMap();
              int v68 = (int)__p;
              unsigned int v13 = std::map<unsigned int,SpatialCaptureParameterInfo>::at((uint64_t *)qword_1E9F7FA90, v9);
              uint64_t v14 = std::map<ValueType,std::function<objc_object * ()(void *,unsigned int *)>>::at(*((_DWORD *)v13 + 2));
              unsigned int v15 = std::function<objc_object * ()(void *,unsigned int *)>::operator()(*(void *)(v14 + 24), (uint64_t)v71.__begin_, (uint64_t)&v68);
              id v16 = (id)*std::map<unsigned int,SpatialCaptureParameterInfo>::at((uint64_t *)qword_1E9F7FA90, v9);
              [v7 setObject:v15 forKey:v16];
            }
            if (v71.__begin_)
            {
              v71.__end_ = v71.__begin_;
              operator delete(v71.__begin_);
            }
          }

          float v17 = *(uint64_t **)(v8 + 8);
          if (v17)
          {
            do
            {
              float v18 = v17;
              float v17 = (uint64_t *)*v17;
            }
            while (v17);
          }
          else
          {
            do
            {
              float v18 = *(uint64_t **)(v8 + 16);
              BOOL v19 = *v18 == v8;
              uint64_t v8 = (uint64_t)v18;
            }
            while (!v19);
          }
          uint64_t v8 = (uint64_t)v18;
        }
        while (v18 != &qword_1E9F7FA90);
      }
      [v6 setObject:v7 forKey:@"Generic"];

      id v20 = v6;
      float v21 = [MEMORY[0x1E4F1CA60] dictionary];
      unint64_t v22 = (*(uint64_t (**)(DSPGraph::Box *))(*(void *)a1 + 16))(a1);
      getBoxSpecificPropertyMap();
      float v23 = (void *)qword_1E9F7FAB8;
      if (!qword_1E9F7FAB8)
      {
LABEL_28:
        [v21 setObject:@"EitherNoPropertiesElseNeedsToBeAdded" forKey:@"BoxSpecificPropertiesUnavailable"];
        goto LABEL_29;
      }
      while (1)
      {
        unint64_t v24 = v23[4];
        if (v22 >= v24) {
          break;
        }
LABEL_27:
        float v23 = (void *)*v23;
        if (!v23) {
          goto LABEL_28;
        }
      }
      if (v24 < v22)
      {
        ++v23;
        goto LABEL_27;
      }
      getBoxSpecificPropertyMap();
      float v26 = (void *)qword_1E9F7FAB8;
      if (!qword_1E9F7FAB8) {
LABEL_73:
      }
        std::__throw_out_of_range[abi:ne180100]("map::at:  key not found");
      while (1)
      {
        while (1)
        {
          unint64_t v27 = v26[4];
          if (v22 >= v27) {
            break;
          }
          float v26 = (void *)*v26;
          if (!v26) {
            goto LABEL_73;
          }
        }
        if (v27 >= v22) {
          break;
        }
        float v26 = (void *)v26[1];
        if (!v26) {
          goto LABEL_73;
        }
      }
      float v28 = (uint64_t **)v26[5];
      float v29 = (uint64_t **)(v26 + 6);
      if (v28 != v26 + 6)
      {
        do
        {
          uint64_t v30 = *((unsigned int *)v28 + 8);
          unsigned int v31 = v28[5];
          unsigned int v32 = (*(uint64_t (**)(DSPGraph::Box *, uint64_t, unint64_t, uint64_t))(*(void *)a1 + 296))(a1, v30, i, v5);
          if (v33)
          {
            std::vector<char>::vector(&v71, v32);
            LODWORD(__p) = LODWORD(v71.__end_) - LODWORD(v71.__begin_);
            if (!(*(unsigned int (**)(DSPGraph::Box *, uint64_t, unint64_t, uint64_t, void **))(*(void *)a1 + 304))(a1, v30, i, v5, &__p))
            {
              getValueTypeFunctionCastMap();
              int v68 = (int)__p;
              uint64_t v34 = std::map<unsigned int,SpatialCaptureParameterInfo>::at(*v29, v30);
              uint64_t v35 = std::map<ValueType,std::function<objc_object * ()(void *,unsigned int *)>>::at(*((_DWORD *)v34 + 2));
              uint64_t v36 = std::function<objc_object * ()(void *,unsigned int *)>::operator()(*(void *)(v35 + 24), (uint64_t)v71.__begin_, (uint64_t)&v68);
              id v37 = (id)*std::map<unsigned int,SpatialCaptureParameterInfo>::at(*v29, v30);
              [v21 setObject:v36 forKey:v37];
            }
            if (v71.__begin_)
            {
              v71.__end_ = v71.__begin_;
              operator delete(v71.__begin_);
            }
          }

          uint64_t v38 = v28[1];
          if (v38)
          {
            do
            {
              char v39 = (uint64_t **)v38;
              uint64_t v38 = (uint64_t *)*v38;
            }
            while (v38);
          }
          else
          {
            do
            {
              char v39 = (uint64_t **)v28[2];
              BOOL v19 = *v39 == (uint64_t *)v28;
              float v28 = v39;
            }
            while (!v19);
          }
          float v28 = v39;
        }
        while (v39 != v29);
      }
LABEL_29:
      [v20 setObject:v21 forKey:@"SubTypeSpecific"];

      float v25 = objc_msgSend(NSString, "stringWithFormat:", @"Element: %u", v5);
      [v64 setObject:v20 forKey:v25];

      uint64_t v5 = (v5 + 1);
    }
    while (v5 < v67);
LABEL_53:
    char v40 = NSString;
    uint64_t v41 = [NSNumber numberWithUnsignedInt:i];
    uint64_t v42 = [v60 objectForKey:v41];
    uint64_t v43 = [v40 stringWithFormat:@"Scope : %@", v42];
    [v59 setObject:v64 forKey:v43];
  }
LABEL_55:

  [v58 setObject:v59 forKey:@"BoxProperties"];
  unint64_t v63 = [MEMORY[0x1E4F1CA60] dictionary];
  char v65 = getIntToNSStringScopeMap();
  unint64_t v61 = [v65 count];
  if (v61)
  {
    for (unint64_t j = 0; j < v61; unint64_t j = (j + 1))
    {
      unint64_t v45 = [MEMORY[0x1E4F1CA60] dictionary];
      (*(void (**)(void **__return_ptr, DSPGraph::Box *, unint64_t))(*(void *)a1 + 96))(&__p, a1, j);
      unint64_t v46 = (unsigned int *)__p;
      if (v70 != __p)
      {
        unint64_t v47 = 0;
        do
        {
          (*(void (**)(std::vector<char> *__return_ptr, DSPGraph::Box *, unint64_t, void))(*(void *)a1 + 104))(&v71, a1, j, v46[v47]);
          if (v73)
          {
            float v48 = (*(float (**)(DSPGraph::Box *, void, unint64_t, void))(*(void *)a1 + 88))(a1, *((unsigned int *)__p + v47), j, 0);
            id v49 = v72;
            float v51 = @"inf";
            if (v48 == INFINITY || (float v51 = @"-inf", v48 == -INFINITY))
            {
              [v45 setObject:v51 forKey:v49];
            }
            else
            {
              *(float *)&double v50 = v48;
              uint64_t v52 = objc_msgSend(NSNumber, "numberWithFloat:", @"-inf", v50);
              [v45 setObject:v52 forKey:v49];
            }
          }
          ++v47;
          unint64_t v46 = (unsigned int *)__p;
        }
        while (v47 < (v70 - (unsigned char *)__p) >> 2);
      }
      unint64_t v53 = NSString;
      uint64_t v54 = [NSNumber numberWithInt:j];
      unint64_t v55 = [v65 objectForKey:v54];
      uint64_t v56 = [v53 stringWithFormat:@"Scope: %@", v55];
      [v63 setObject:v45 forKey:v56];

      if (__p)
      {
        uint64_t v70 = __p;
        operator delete(__p);
      }
    }
  }

  [v58 setObject:v63 forKey:@"BoxParameters"];

  return v58;
}

void sub_1BB38E85C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,void *a21,uint64_t a22)
{
  _Unwind_Resume(a1);
}

uint64_t AULando::ValidFormat(AULando *this, const AudioStreamBasicDescription *a2, unsigned int a3, AudioStreamBasicDescription *a4)
{
  int v5 = (int)a2;
  if (ausdk::ASBD::IsCommonFloat32((ausdk::ASBD *)a4, a2)) {
    BOOL v6 = (a4->mFormatFlags & 0x20) != 0 || a4->mChannelsPerFrame == 1;
  }
  else {
    BOOL v6 = 0;
  }
  if (v5 == 2)
  {
    if (v6)
    {
      UInt32 mChannelsPerFrame = a4->mChannelsPerFrame;
      BOOL v6 = mChannelsPerFrame == 6 || mChannelsPerFrame == 8;
    }
  }
  else if (v5 == 1 && a4->mChannelsPerFrame != 2)
  {
    BOOL v6 = 0;
  }
  BOOL v9 = a4->mSampleRate >= 44100.0;
  if (a4->mSampleRate > 48000.0) {
    BOOL v9 = 0;
  }
  return v9 & v6;
}

uint64_t AULando::SupportedNumChannels(AULando *this, const AUChannelInfo **a2)
{
  if (a2) {
    *a2 = (const AUChannelInfo *)&AULando::SupportedNumChannels(AUChannelInfo const**)::sSupportedChannelConfigs;
  }
  return 2;
}

BOOL AULando::StreamFormatWritable(AULando *this)
{
  return *((unsigned char *)this + 17) == 0;
}

uint64_t AULando::SupportsTail(AULando *this)
{
  return 1;
}

double AULando::GetTailTime(AULando *this)
{
  double v1 = *(double *)(ausdk::AUScope::SafeGetElement((AULando *)((char *)this + 128), 0) + 80);
  double v2 = 69.0 / v1;
  BOOL v3 = v1 <= 8000.0;
  double result = 0.008625;
  if (!v3) {
    return v2;
  }
  return result;
}

double AULando::GetLatency(AULando *this)
{
  double v1 = *(double *)(ausdk::AUScope::SafeGetElement((AULando *)((char *)this + 128), 0) + 80);
  double v2 = 35.0 / v1;
  BOOL v3 = v1 <= 8000.0;
  double result = 0.004375;
  if (!v3) {
    return v2;
  }
  return result;
}

uint64_t AULando::NewFactoryPresetSet(AULando *this, const AUPreset *a2)
{
  uint64_t presetNumber = a2->presetNumber;
  if ((int)presetNumber > 1) {
    return 4294956445;
  }
  (*(void (**)(AULando *, void, void, void, void, float))(*(void *)this + 152))(this, 0, 0, 0, 0, 4.0);
  (*(void (**)(AULando *, uint64_t, void, void, void, double))(*(void *)this + 152))(this, 1, 0, 0, 0, 0.0);
  (*(void (**)(AULando *, uint64_t, void, void, void, float))(*(void *)this + 152))(this, 2, 0, 0, 0, (float)kAULandoPresetDefinitions[12 * (int)presetNumber + 2]);
  (*(void (**)(AULando *, uint64_t, void, void, void, float))(*(void *)this + 152))(this, 3, 0, 0, 0, -0.36);
  (*(void (**)(AULando *, uint64_t, void, void, void, float))(*(void *)this + 152))(this, 4, 0, 0, 0, 1.92);
  (*(void (**)(AULando *, uint64_t, void, void, void, float))(*(void *)this + 152))(this, 5, 0, 0, 0, 1.0);
  (*(void (**)(AULando *, uint64_t, void, void, void, float))(*(void *)this + 152))(this, 6, 0, 0, 0, 1.0);
  (*(void (**)(AULando *, uint64_t, void, void, void, float))(*(void *)this + 152))(this, 7, 0, 0, 0, 0.755);
  (*(void (**)(AULando *, uint64_t, void, void, void, float))(*(void *)this + 152))(this, 8, 0, 0, 0, 400.0);
  (*(void (**)(AULando *, uint64_t, void, void, void, float))(*(void *)this + 152))(this, 9, 0, 0, 0, 10000.0);
  (*(void (**)(AULando *, uint64_t, void, void, void, float))(*(void *)this + 152))(this, 10, 0, 0, 0, 1.0);
  (*(void (**)(AULando *, uint64_t, void, void, void, double))(*(void *)this + 152))(this, 11, 0, 0, 0, 0.0);
  ausdk::AUBase::SetAFactoryPresetAsCurrent((char *)this, (const AUPreset *)&kAULandoPresets + presetNumber);
  return 0;
}

uint64_t AULando::GetPresets(AULando *this, const __CFArray **a2)
{
  if (a2)
  {
    CFMutableStringRef Mutable = CFArrayCreateMutable(0, 2, 0);
    CFArrayAppendValue(Mutable, &kAULandoPresets);
    CFArrayAppendValue(Mutable, &unk_1E9F7C2F8);
    *a2 = Mutable;
  }
  return 0;
}

uint64_t AULando::GetParameterValueStrings(AULando *this, int a2, int a3, const __CFArray **a4)
{
  if (a3 | a2) {
    return 4294956418;
  }
  if (!a4) {
    return 0;
  }
  CFArrayRef v6 = CFArrayCreate(0, (const void **)kAULandoAlgoStrings, 5, 0);
  uint64_t result = 0;
  *a4 = v6;
  return result;
}

uint64_t AULando::RestoreState(AULando *this, const void *a2)
{
  unint64_t v4 = (AULando *)((char *)this + 32);
  uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::GetElement((AULando *)((char *)this + 32), 0);
  float Parameter = ausdk::AUElement::GetParameter(Element, 8u);
  float v7 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v4, 0);
  float v8 = ausdk::AUElement::GetParameter(v7, 9u);
  uint64_t v9 = ausdk::AUBase::RestoreState((OpaqueAudioComponentInstance **)this, a2);
  id v10 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v4, 0);
  float v11 = ausdk::AUElement::GetParameter(v10, 8u);
  char v12 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v4, 0);
  float v13 = ausdk::AUElement::GetParameter(v12, 9u);
  if (Parameter != v11 || v8 != v13) {
    AULando::Implementation::updateCrossover(*((Crossover2f ***)this + 68), v11, v13);
  }
  return v9;
}

void AULando::Implementation::updateCrossover(Crossover2f **this, double a2, double a3)
{
  unint64_t v4 = *this;
  if (v4)
  {
    Crossover2f::SetLowCrossover(v4, a2, 3);
    CFArrayRef v6 = *this;
    Crossover2f::SetHighCrossover(v6, a3, 1);
  }
}

uint64_t AULando::GetParameterInfo(AULando *this, int a2, AudioUnitParameterUnit a3, AudioUnitParameterInfo *buffer)
{
  if (a2) {
    return 4294956418;
  }
  buffer->flags = 0;
  buffer->unitName = 0;
  uint64_t v6 = 0x4080000000000000;
  AudioUnitParameterValue v7 = 4.0;
  AudioUnitParameterUnit v8 = kAudioUnitParameterUnit_Indexed;
  CFStringRef v9 = @"Algorithm";
  switch(a3)
  {
    case kAudioUnitParameterUnit_Generic:
      goto LABEL_17;
    case kAudioUnitParameterUnit_Indexed:
      uint64_t v6 = 0x3F80000000000000;
      AudioUnitParameterValue v7 = 0.0;
      AudioUnitParameterUnit v8 = kAudioUnitParameterUnit_Boolean;
      CFStringRef v9 = @"Phase Shift";
      goto LABEL_17;
    case kAudioUnitParameterUnit_Boolean:
      uint64_t v6 = 0x3F80000000000000;
      AudioUnitParameterValue v7 = 1.0;
      CFStringRef v9 = @"Downmix C";
      goto LABEL_13;
    case kAudioUnitParameterUnit_Percent:
      AudioUnitParameterUnit v8 = kAudioUnitParameterUnit_Generic;
      uint64_t v6 = 0x3F800000BF800000;
      CFStringRef v9 = @"Front-Back Bias";
      AudioUnitParameterValue v7 = -0.36;
      goto LABEL_17;
    case kAudioUnitParameterUnit_Seconds:
      AudioUnitParameterUnit v8 = kAudioUnitParameterUnit_Generic;
      CFStringRef v9 = @"Steering";
      AudioUnitParameterValue v7 = 1.92;
      goto LABEL_17;
    case kAudioUnitParameterUnit_SampleFrames:
      uint64_t v6 = 0x3F80000000000000;
      AudioUnitParameterValue v7 = 1.0;
      AudioUnitParameterUnit v8 = kAudioUnitParameterUnit_Boolean;
      CFStringRef v9 = @"Steering Moderator";
      goto LABEL_17;
    case kAudioUnitParameterUnit_Phase:
      uint64_t v6 = 0x3F80000000000000;
      AudioUnitParameterValue v7 = 1.0;
      AudioUnitParameterUnit v8 = kAudioUnitParameterUnit_Boolean;
      CFStringRef v9 = @"Smoothing";
      goto LABEL_17;
    case kAudioUnitParameterUnit_Rate:
      AudioUnitParameterUnit v8 = kAudioUnitParameterUnit_Generic;
      uint64_t v6 = 0x3F80000000000000;
      CFStringRef v9 = @"Decay";
      AudioUnitParameterValue v7 = 0.755;
      goto LABEL_17;
    case kAudioUnitParameterUnit_Hertz:
      uint64_t v6 = 0x4448000042200000;
      CFStringRef v9 = @"Low Crossover Frequency";
      AudioUnitParameterValue v7 = 400.0;
LABEL_13:
      AudioUnitParameterUnit v8 = a3;
      goto LABEL_17;
    case kAudioUnitParameterUnit_Cents:
      uint64_t v6 = 0x466A600044FA0000;
      AudioUnitParameterUnit v8 = kAudioUnitParameterUnit_Hertz;
      CFStringRef v9 = @"High Crossover Frequency";
      AudioUnitParameterValue v7 = 10000.0;
      goto LABEL_17;
    case kAudioUnitParameterUnit_RelativeSemiTones:
      uint64_t v6 = 0x3F80000000000000;
      AudioUnitParameterValue v7 = 1.0;
      AudioUnitParameterUnit v8 = kAudioUnitParameterUnit_Boolean;
      CFStringRef v9 = @"Inverted Rs Polarity";
      goto LABEL_17;
    case kAudioUnitParameterUnit_MIDINoteNumber:
      uint64_t v6 = 0x3F80000000000000;
      AudioUnitParameterValue v7 = 0.0;
      AudioUnitParameterUnit v8 = kAudioUnitParameterUnit_Boolean;
      CFStringRef v9 = @"Soft Bypass";
LABEL_17:
      buffer->cfNameString = v9;
      buffer->flags = 0x8000000;
      CFStringGetCString(v9, buffer->name, 52, 0x8000100u);
      uint64_t result = 0;
      buffer->unit = v8;
      *(void *)&buffer->minCFNumberRef Value = v6;
      buffer->defaultCFNumberRef Value = v7;
      buffer->flags |= 0xC0000000;
      break;
    default:
      uint64_t result = 4294956418;
      break;
  }
  return result;
}

uint64_t AULando::Render(AULando *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  AudioUnitParameterUnit v8 = (AULando *)((char *)this + 80);
  uint64_t Element = ausdk::AUScope::SafeGetElement((AULando *)((char *)this + 80), 0);
  uint64_t v10 = ausdk::AUScope::SafeGetElement((AULando *)((char *)this + 128), 0);
  unsigned int v15 = 0;
  float v11 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement(v8, 0);
  uint64_t result = ausdk::AUInputElement::PullInput(v11, &v15, a3, 0, a4);
  if (!result)
  {
    uint64_t BufferList = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(Element + 144));
    uint64_t v14 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v10 + 144));
    return (*(uint64_t (**)(AULando *, unsigned int *, uint64_t, uint64_t, uint64_t))(*(void *)this + 176))(this, a2, BufferList, v14, a4);
  }
  return result;
}

uint64_t AULando::ProcessMultipleBufferLists(AULando *this, unsigned int *a2, unsigned int a3, int a4, const AudioBufferList **a5, int a6, AudioBufferList **a7)
{
  if (a4 == 1 && a5 && (*a5 ? (v7 = a6 == 1) : (v7 = 0), v7 ? (BOOL v8 = a7 == 0) : (BOOL v8 = 1), !v8 && *a7)) {
    return (*(uint64_t (**)(AULando *, unsigned int *))(*(void *)this + 176))(this, a2);
  }
  else {
    return 4294956418;
  }
}

uint64_t AULando::ProcessBufferLists(AULando::Implementation **this, unsigned int *a2, const AudioBufferList *a3, AudioBufferList *a4, vDSP_Length a5)
{
  if (a3->mNumberBuffers != 2) {
    return 4294956428;
  }
  UInt32 mNumberBuffers = a4->mNumberBuffers;
  if (a4->mNumberBuffers != 8 && mNumberBuffers != 6) {
    return 4294956428;
  }
  int v10 = *((unsigned __int8 *)this + 528);
  uint64_t v43 = *(float **)&a3[1].mBuffers[0].mNumberChannels;
  mData = (float *)a3->mBuffers[0].mData;
  uint64_t v41 = *(float **)&a4[1].mBuffers[0].mNumberChannels;
  uint64_t v42 = (float *)a4->mBuffers[0].mData;
  float v11 = (float *)a4[2].mBuffers[0].mData;
  char v39 = *(float **)&a4[3].mBuffers[0].mNumberChannels;
  char v40 = *(float **)&a4[2].mNumberBuffers;
  char v12 = (ausdk::AUScope *)(this + 4);
  float v13 = *(float **)&a4[4].mNumberBuffers;
  uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::GetElement((ausdk::AUScope *)(this + 4), 0);
  unsigned int Parameter = ausdk::AUElement::GetParameter(Element, 0);
  if (v10) {
    unsigned int Parameter = 1;
  }
  int v38 = Parameter;
  vDSP_Length v16 = a5;
  vDSP_vclr(v11, 1, a5);
  float v17 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v12, 0);
  BOOL v37 = ausdk::AUElement::GetParameter(v17, 1u) != 0.0;
  float v18 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v12, 0);
  BOOL v19 = ausdk::AUElement::GetParameter(v18, 2u) != 0.0;
  id v20 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v12, 0);
  float v21 = ausdk::AUElement::GetParameter(v20, 3u);
  unint64_t v22 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v12, 0);
  float v23 = ausdk::AUElement::GetParameter(v22, 4u);
  unint64_t v24 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v12, 0);
  char v25 = ausdk::AUElement::GetParameter(v24, 5u) != 0.0;
  float v26 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v12, 0);
  float v27 = ausdk::AUElement::GetParameter(v26, 7u);
  float v28 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v12, 0);
  unsigned __int8 v29 = ausdk::AUElement::GetParameter(v28, 6u) != 0.0;
  uint64_t v30 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v12, 0);
  unsigned __int8 v31 = ausdk::AUElement::GetParameter(v30, 0xBu) == 1.0;
  uint64_t v32 = AULando::Implementation::algo(this[68], v38, a5, mData, v43, v42, v41, v40, v21, v23, v27, v39, v13, v37, v19, v25, v29, v31, v37);
  char v33 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v12, 0);
  if (ausdk::AUElement::GetParameter(v33, 0xAu) == 1.0) {
    vDSP_vneg(v13, 1, v13, 1, v16);
  }
  if (mNumberBuffers == 8)
  {
    uint64_t v34 = (float *)a4[4].mBuffers[0].mData;
    uint64_t v35 = *(float **)&a4[5].mBuffers[0].mNumberChannels;
    vDSP_vclr(v34, 1, v16);
    vDSP_vclr(v35, 1, v16);
  }
  return v32;
}

uint64_t AULando::Implementation::algo(AULando::Implementation *this, int a2, vDSP_Length a3, float *a4, float *a5, float *a6, float *a7, float *a8, float a9, float a10, float a11, float *a12, float *a13, BOOL a14, BOOL a15, char a16, unsigned __int8 a17, unsigned __int8 a18, int a19)
{
  id v49 = a6;
  v57[2] = *(float **)MEMORY[0x1E4F143B8];
  v57[0] = a4;
  v57[1] = a5;
  MEMORY[0x1F4188790](this);
  vDSP_Length v29 = v28;
  unint64_t v55 = (float *)((char *)&v47 - ((v27 + 15) & 0x7FFFFFFF0));
  uint64_t v56 = &v55[v28];
  MEMORY[0x1F4188790](v30);
  unint64_t v53 = (float *)((char *)&v47 - v32);
  uint64_t v54 = (const float *)((char *)&v47 + 4 * v31 - v32);
  MEMORY[0x1F4188790](v33);
  float v51 = (float *)((char *)&v47 - v35);
  uint64_t v52 = (float *)((char *)&v47 + 4 * v34 - v35);
  uint64_t v37 = Crossover2f::Process(*v36, v57, &v55, &v53, &v51, 2, a3, 1, v47);
  unint64_t v47 = (float *const *)&v47;
  float v48 = a8;
  int v38 = a13;
  char v39 = v52;
  switch(a2)
  {
    case 0:
      char v40 = v49;
      memcpy(v49, v51, 4 * v29);
      memcpy(a7, v39, 4 * v29);
      vDSP_vclr(v48, 1, v29);
      vDSP_vclr(a12, 1, v29);
      goto LABEL_11;
    case 1:
      char v40 = v49;
      AULando::Implementation::algoBypassAlignedLatency((IR::IRProcessor **)this, a3, v51, v52, v49, a7, v48, a12, a13);
      goto LABEL_14;
    case 2:
      char v40 = v49;
      AULando::LRLsRs::algoExtractLsRsPI(a3, v51, v52, v49, a7, a12, a13, a14, (IR::IRProcessor **)this + 1);
      goto LABEL_8;
    case 3:
      char v40 = v49;
      if (a15)
      {
        AULando::LRLsRs::algoUpmixPI(a3, (AULando::LRLsRs *)v51, v52, v49, a7, a12, a13, a14, (IR::IRProcessor **)this + 1, *(unsigned int *)v46, v46[4]);
LABEL_8:
        uint64_t v42 = v48;
LABEL_12:
        vDSP_vclr(v42, 1, v29);
      }
      else
      {
        LOBYTE(v45) = a14;
        AULando::LRCLsRs::algoUpmixPI(a3, (AULando::LRCLsRs *)v51, v52, v49, a7, v48, a12, a13, v45, (IR::IRProcessor **)this + 1, v47, SBYTE4(v47));
      }
LABEL_14:
      uint64_t v41 = 0;
LABEL_15:
      MEMORY[0x1F4188790](v37);
      uint64_t v43 = (float *)((char *)&v47 - ((4 * v29 + 15) & 0x7FFFFFFF0));
      vDSP_vadd(v55, 1, v53, 1, v43, 1, v29);
      IR::FixedIntegerDelay::process((AULando::Implementation *)((char *)this + 136), v43, v43, a3);
      vDSP_vadd(v40, 1, v43, 1, v40, 1, v29);
      vDSP_vadd(v56, 1, v54, 1, v43, 1, v29);
      IR::FixedIntegerDelay::process((AULando::Implementation *)((char *)this + 192), v43, v43, a3);
      vDSP_vadd(a7, 1, v43, 1, a7, 1, v29);
      return v41;
    case 4:
      int v38 = v48;
      char v40 = v49;
      AULando::LRCLsRs::algoUpmixPISteered((const float *)this + 104, a3, (AULando::LRCLsRs *)v51, v52, v49, a7, v48, a12, a9, a10, a11, a13, a14, a16, a17, a18, (uint64_t)this + 8);
      if (!a15) {
        goto LABEL_14;
      }
      float __B = 0.70711;
      vDSP_vsma(v38, 1, &__B, v40, 1, v40, 1, v29);
      vDSP_vsma(v38, 1, &__B, a7, 1, a7, 1, v29);
LABEL_11:
      uint64_t v42 = (float *)v38;
      goto LABEL_12;
    default:
      uint64_t v41 = 4294956418;
      char v40 = v49;
      goto LABEL_15;
  }
}

void AULando::Implementation::algoBypassAlignedLatency(IR::IRProcessor **this, vDSP_Length a2, const float *a3, float *a4, float *a5, float *a6, float *a7, float *a8, float *a9)
{
  v25[2] = *(float **)MEMORY[0x1E4F143B8];
  vDSP_Length v15 = a2;
  MEMORY[0x1F4188790](this);
  float v17 = (float *)((char *)&v24[-1] - v16);
  v25[0] = v18;
  v25[1] = (float *)((char *)&v24[-1] - v16);
  id v20 = *(IR::IRProcessor **)(v19 + 8);
  v24[0] = v21;
  IR::IRProcessor::processMultipleInputs(v20, (const float **)v24, v25, 1u, 2u, a2, 1.0, 0);
  v24[0] = a6;
  v24[1] = v17;
  unint64_t v22 = this[2];
  float v23 = a4;
  IR::IRProcessor::processMultipleInputs(v22, (const float **)&v23, v24, 1u, 2u, a2, 1.0, 0);
  vDSP_vclr(a7, 1, v15);
  vDSP_vclr(a8, 1, v15);
  vDSP_vclr(a9, 1, v15);
}

uint64_t AULando::CanScheduleParameters(AULando *this)
{
  return 0;
}

uint64_t AULando::SetParameter(AULando *this, unsigned int a2, unsigned int a3, unsigned int a4, float a5)
{
  uint64_t v8 = *((void *)this + 68);
  v12[0] = this;
  v12[1] = v8;
  unsigned int v13 = a2;
  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
  uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
  ausdk::AUElement::SetParameter(Element, a2, a5, 0);
  AULando::SetParameter(unsigned int,unsigned int,unsigned int,float,unsigned int)::OnExit::~OnExit((uint64_t)v12);
  return 0;
}

void sub_1BB38FD10(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  AULando::SetParameter(unsigned int,unsigned int,unsigned int,float,unsigned int)::OnExit::~OnExit((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t AULando::SetParameter(unsigned int,unsigned int,unsigned int,float,unsigned int)::OnExit::~OnExit(uint64_t a1)
{
  if ((*(_DWORD *)(a1 + 16) & 0xFFFFFFFE) == 8)
  {
    uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::GetElement((ausdk::AUScope *)(*(void *)a1 + 32), 0);
    float Parameter = ausdk::AUElement::GetParameter(Element, 8u);
    unint64_t v4 = (ausdk::AUElement *)ausdk::AUScope::GetElement((ausdk::AUScope *)(*(void *)a1 + 32), 0);
    float v5 = ausdk::AUElement::GetParameter(v4, 9u);
    AULando::Implementation::updateCrossover(*(Crossover2f ***)(a1 + 8), Parameter, v5);
  }
  return a1;
}

uint64_t AULando::SetProperty(AULando *this, int a2, int a3, unsigned int a4, _DWORD *a5, unsigned int a6)
{
  uint64_t result = 4294956417;
  if (a2 == 21 && !a3)
  {
    if (a6 >= 4)
    {
      int v8 = *a5 != 0;
      if (*((unsigned __int8 *)this + 528) == v8)
      {
        return 0;
      }
      else
      {
        if (*((unsigned char *)this + 17)) {
          (*(void (**)(AULando *, void, void))(*(void *)this + 72))(this, 0, 0);
        }
        uint64_t result = 0;
        *((unsigned char *)this + 528) = v8;
      }
    }
    else
    {
      return 4294956445;
    }
  }
  return result;
}

uint64_t AULando::GetProperty(AULando *this, int a2, int a3, unsigned int a4, _DWORD *a5)
{
  if (a3) {
    return 4294956417;
  }
  if (a2 == 3700)
  {
    uint64_t v6 = (unsigned __int8 *)this + 376;
  }
  else
  {
    if (a2 != 21) {
      return 4294956417;
    }
    uint64_t v6 = (unsigned __int8 *)this + 528;
  }
  uint64_t result = 0;
  *a5 = *v6;
  return result;
}

uint64_t AULando::GetPropertyInfo(AULando *this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  if (a3) {
    return 4294956417;
  }
  if (a2 == 21)
  {
    BOOL v7 = 1;
  }
  else
  {
    if (a2 != 3700) {
      return 4294956417;
    }
    BOOL v7 = 0;
  }
  uint64_t result = 0;
  *a6 = v7;
  *a5 = 4;
  return result;
}

uint64_t AULando::Reset(AULando *this)
{
  uint64_t v1 = *((void *)this + 68);
  if (*(void *)v1) {
    Crossover2f::Reset(*(ParametricFilters ***)v1);
  }
  double v2 = (_OWORD *)(v1 + 8);
  IR::IRProcessor::reset(*(IR::FFTFilter ***)(v1 + 8));
  IR::IRProcessor::reset(*(IR::FFTFilter ***)(v1 + 16));
  IR::FixedIntegerDelay::reset((IR::FixedIntegerDelay *)(v1 + 24));
  IR::FixedIntegerDelay::reset((IR::FixedIntegerDelay *)(v1 + 80));
  IR::FixedIntegerDelay::reset((IR::FixedIntegerDelay *)(v1 + 136));
  IR::FixedIntegerDelay::reset((IR::FixedIntegerDelay *)(v1 + 192));
  *(_OWORD *)(v1 + 248) = 0u;
  uint64_t v3 = v1 + 248;
  *(void *)(v3 + 156) = 0x3F80000000000000;
  v2[16] = 0u;
  v2[17] = 0u;
  v2[18] = 0u;
  v2[19] = 0u;
  v2[20] = 0u;
  v2[21] = 0u;
  v2[22] = 0u;
  v2[23] = 0u;
  *(_DWORD *)(v3 + 144) = 0;
  bzero((void *)(v3 + 800), 8 * *(_DWORD *)(v3 + 796) * *(_DWORD *)(v3 + 792));
  fb::ComplexMat::stabilize((_DWORD *)(v3 + 792), v4);
  bzero((void *)(v3 + 1008), 8 * *(_DWORD *)(v3 + 1004) * *(_DWORD *)(v3 + 1000));
  bzero((void *)(v3 + 1840), 8 * *(_DWORD *)(v3 + 1836) * *(_DWORD *)(v3 + 1832));
  fb::ComplexMat::stabilize((_DWORD *)(v3 + 1832), v5);
  bzero((void *)(v3 + 2048), 8 * *(_DWORD *)(v3 + 2044) * *(_DWORD *)(v3 + 2040));
  return 0;
}

uint64_t AULando::Cleanup(AULando *this)
{
  uint64_t v1 = *((void *)this + 68);
  uint64_t v2 = *(void *)v1;
  *(void *)uint64_t v1 = 0;
  if (v2) {
    std::default_delete<Crossover2f>::operator()[abi:ne180100](v2);
  }
  IR::IRProcessor::uninitialize(*(IR::IRProcessor **)(v1 + 8));
  uint64_t v3 = *(IR::IRProcessor **)(v1 + 16);

  return IR::IRProcessor::uninitialize(v3);
}

void std::default_delete<Crossover2f>::operator()[abi:ne180100](uint64_t a1)
{
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  std::unique_ptr<ParametricFilters>::reset[abi:ne180100]((void ***)(a1 + 24), 0);
  std::unique_ptr<ParametricFilters>::reset[abi:ne180100]((void ***)(a1 + 16), 0);
  std::unique_ptr<ParametricFilters>::reset[abi:ne180100]((void ***)(a1 + 8), 0);
  std::unique_ptr<ParametricFilters>::reset[abi:ne180100]((void ***)a1, 0);

  JUMPOUT(0x1C185D370);
}

void **std::unique_ptr<ParametricFilters>::reset[abi:ne180100](void ***a1, void **a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    ParametricFilters::~ParametricFilters(result);
    JUMPOUT(0x1C185D370);
  }
  return result;
}

void ParametricFilters::~ParametricFilters(void **this)
{
  if (*((char *)this + 191) < 0) {
    operator delete(this[21]);
  }
  uint64_t v2 = this[17];
  this[17] = 0;
  if (v2) {
    ((void (*)(void))this[18])();
  }
  uint64_t v3 = this[15];
  this[15] = 0;
  if (v3) {
    ((void (*)(void))this[16])();
  }
  float v5 = this + 11;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
  float v5 = this + 8;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
  float v4 = this[5];
  if (v4)
  {
    this[6] = v4;
    operator delete(v4);
  }
  float v5 = this + 2;
  std::vector<BiquadStage>::__destroy_vector::operator()[abi:ne180100](&v5);
}

void std::vector<BiquadStage>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    float v4 = (void **)v1[1];
    float v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        if (*((char *)v4 - 1) < 0) {
          operator delete(*(v4 - 3));
        }
        v4 -= 9;
      }
      while (v4 != v2);
      float v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t AULando::Initialize(AULando *this)
{
  uint64_t v2 = *((void *)this + 15);
  if (v2) {
    LODWORD(v3) = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  else {
    uint64_t v3 = (*((void *)this + 13) - *((void *)this + 12)) >> 3;
  }
  if (v3 == 1)
  {
    uint64_t v4 = *((void *)this + 21);
    if (v4) {
      LODWORD(v5) = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 24))(v4);
    }
    else {
      uint64_t v5 = (*((void *)this + 19) - *((void *)this + 18)) >> 3;
    }
    if (v5 == 1 && *(_DWORD *)(ausdk::AUScope::SafeGetElement((AULando *)((char *)this + 80), 0) + 108) == 2)
    {
      int v6 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AULando *)((char *)this + 128), 0) + 108);
      if (v6 == 8 || v6 == 6)
      {
        double v7 = *(double *)(ausdk::AUScope::SafeGetElement((AULando *)((char *)this + 128), 0) + 80);
        if (*((double *)this + 67) != v7)
        {
          *((double *)this + 67) = v7;
          (*(void (**)(AULando *, uint64_t, void, void))(*(void *)this + 432))(this, 12, 0, 0);
        }
        (*(void (**)(AULando *, void, void))(*(void *)this + 72))(this, 0, 0);
        ausdk::AUScope::SafeGetElement((AULando *)((char *)this + 128), 0);
        uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::GetElement((AULando *)((char *)this + 32), 0);
        ausdk::AUElement::GetParameter(Element, 8u);
        int v10 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AULando *)((char *)this + 32), 0);
        ausdk::AUElement::GetParameter(v10, 9u);
        operator new();
      }
    }
  }
  return 4294956428;
}

void sub_1BB3904A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  MEMORY[0x1C185D370](v15, 0x1032C409EFFA567);
  _Unwind_Resume(a1);
}

uint64_t IR::HilbertFIR::initialize(IR::IRProcessor **this, double a2, unsigned int a3)
{
  v8[1] = *MEMORY[0x1E4F143B8];
  float v5 = a2;
  uint64_t result = IR::IRProcessor::initialize(*this, v5, a3, 0, 0, 0, 0);
  if (!result)
  {
    v8[0] = 0;
    if (a2 == 48000.0)
    {
      double v7 = (const float *const *)&off_1E623C760;
    }
    else
    {
      if (a2 != 44100.0) {
        return result;
      }
      double v7 = (const float *const *)&off_1E623C770;
    }
    return IR::IRProcessor::setIRCoeffs(*this, v7, (const float *)v8, 2, 70);
  }
  return result;
}

void AULando::~AULando(AULando *this)
{
  AULando::~AULando(this);

  JUMPOUT(0x1C185D370);
}

{
  uint64_t *v2;
  uint64_t vars8;

  *(void *)this = &unk_1F14AC8E0;
  uint64_t v2 = (uint64_t *)*((void *)this + 68);
  *((void *)this + 68) = 0;
  if (v2) {
    std::default_delete<AULando::Implementation>::operator()[abi:ne180100](v2);
  }

  ausdk::AUBase::~AUBase(this);
}

void std::default_delete<AULando::Implementation>::operator()[abi:ne180100](uint64_t *a1)
{
  AULando::Tools::~Tools((AULando::Tools *)(a1 + 1));
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2) {
    std::default_delete<Crossover2f>::operator()[abi:ne180100](v2);
  }

  JUMPOUT(0x1C185D370);
}

void AULando::Tools::~Tools(AULando::Tools *this)
{
  uint64_t v2 = (void *)*((void *)this + 27);
  if (v2)
  {
    *((void *)this + 28) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 24);
  if (v3)
  {
    *((void *)this + 25) = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 20);
  if (v4)
  {
    *((void *)this + 21) = v4;
    operator delete(v4);
  }
  float v5 = (void *)*((void *)this + 17);
  if (v5)
  {
    *((void *)this + 18) = v5;
    operator delete(v5);
  }
  int v6 = (void *)*((void *)this + 13);
  if (v6)
  {
    *((void *)this + 14) = v6;
    operator delete(v6);
  }
  double v7 = (void *)*((void *)this + 10);
  if (v7)
  {
    *((void *)this + 11) = v7;
    operator delete(v7);
  }
  int v8 = (void *)*((void *)this + 6);
  if (v8)
  {
    *((void *)this + 7) = v8;
    operator delete(v8);
  }
  CFStringRef v9 = (void *)*((void *)this + 3);
  if (v9)
  {
    *((void *)this + 4) = v9;
    operator delete(v9);
  }
  std::unique_ptr<IR::IRProcessor>::reset[abi:ne180100]((IR::IRProcessor **)this + 1, 0);
  std::unique_ptr<IR::IRProcessor>::reset[abi:ne180100]((IR::IRProcessor **)this, 0);
}

void IR::HilbertFIR::HilbertFIR(IR::HilbertFIR *this)
{
  *(void *)this = 0;
  operator new();
}

void sub_1BB3907D0(_Unwind_Exception *a1)
{
  MEMORY[0x1C185D370](v2, 0x10A1C40AF302FDBLL);
  std::unique_ptr<IR::IRProcessor>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void IR::FixedIntegerDelay::~FixedIntegerDelay(IR::FixedIntegerDelay *this)
{
  uint64_t v2 = (void *)*((void *)this + 4);
  if (v2)
  {
    *((void *)this + 5) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 1);
  if (v3)
  {
    *((void *)this + 2) = v3;
    operator delete(v3);
  }
}

IR::IRProcessor *IR::IRProcessor::IRProcessor(IR::IRProcessor *this, int a2, float a3, int a4, int a5, char a6, int a7)
{
  CFURLRef v14 = CFURLCreateWithString(0, &stru_1F14C9790, 0);
  CFURLRef v50 = v14;
  if (!v14)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  CFURLRef v15 = v14;
  IR::IRDataAttributes::IRDataAttributes((uint64_t)&cf, &v50, a5, a6, 0.0);
  CFRelease(v15);
  CFTypeRef v16 = cf;
  if (cf) {
    CFRetain(cf);
  }
  CFTypeRef v25 = v16;
  long long v26 = v39;
  long long v27 = v40;
  long long v28 = v41;
  char v29 = v42;
  CFTypeRef v17 = v43;
  if (v43) {
    CFRetain(v43);
  }
  CFTypeRef v30 = v17;
  long long v31 = v44;
  CFTypeRef v18 = v45;
  if (v45) {
    CFRetain(v45);
  }
  CFTypeRef v32 = v18;
  *(_OWORD *)uint64_t v33 = v46[0];
  *(_OWORD *)&v33[9] = *(_OWORD *)((char *)v46 + 9);
  CFTypeRef v19 = v47;
  if (v47)
  {
    CFRetain(v47);
    CFTypeRef v20 = v47;
  }
  else
  {
    CFTypeRef v20 = 0;
  }
  uint64_t v34 = v48;
  int v35 = v49;
  HIDWORD(v36) = 0;
  LOBYTE(v37) = 0;
  HIDWORD(v37) = -65536;
  if (v20) {
    CFRelease(v20);
  }
  if (v45) {
    CFRelease(v45);
  }
  if (v43) {
    CFRelease(v43);
  }
  if (cf) {
    CFRelease(cf);
  }
  LODWORD(v36) = a2;
  DWORD1(v36) = a3;
  DWORD2(v36) = a4;
  *(void *)this = &unk_1F14C3260;
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
  caulk::pooled_semaphore_mutex::pooled_semaphore_mutex((IR::IRProcessor *)((char *)this + 20));
  float v21 = (char *)operator new(0xD0uLL);
  *((void *)v21 + 1) = 0;
  *((void *)v21 + 2) = 0;
  *(_OWORD *)(v21 + 40) = v26;
  *(void *)float v21 = &unk_1F14BEE38;
  *((void *)v21 + 4) = v25;
  *(_OWORD *)(v21 + 56) = v27;
  *(_OWORD *)(v21 + 72) = v28;
  v21[88] = v29;
  *((void *)v21 + 12) = v30;
  *(_OWORD *)(v21 + 104) = v31;
  *((void *)v21 + 15) = v32;
  *((_OWORD *)v21 + 8) = *(_OWORD *)v33;
  *(_OWORD *)(v21 + 137) = *(_OWORD *)&v33[9];
  *((void *)v21 + 20) = v19;
  *((void *)v21 + 21) = v34;
  *((_DWORD *)v21 + 44) = v35;
  *(_OWORD *)(v21 + 184) = v36;
  *((void *)v21 + 25) = v37;
  *((void *)v21 + 3) = &unk_1F14BED28;
  *(void *)&long long v22 = v21 + 24;
  *((void *)&v22 + 1) = v21;
  *(_OWORD *)((char *)this + 24) = v22;
  *((unsigned char *)this + 40) = 0;
  *((void *)this + 6) = 0;
  *((unsigned char *)this + 56) = 0;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((void *)this + 20) = 0x3F800000453B8000;
  *((unsigned char *)this + 168) = 1;
  *((_DWORD *)this + 43) = a7;
  *((unsigned char *)this + 176) = 0;
  return this;
}

void sub_1BB390BAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  __cxa_free_exception(v10);
  _Unwind_Resume(a1);
}

uint64_t IR::Source::getCoefficients(uint64_t a1)
{
  if (((*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1) & 1) == 0) {
    __assert_rtn("getCoefficients", "IRSource.h", 86, "providesCoefficients()");
  }
  return 4294956433;
}

uint64_t IR::Source::needToUpdateCoeffs(IR::Source *this)
{
  return 0;
}

uint64_t IR::Source::canInterpolateInDimension()
{
  return 0;
}

uint64_t IR::Source::getModelingDelay(IR::Source *this)
{
  return *((unsigned int *)this + 43);
}

uint64_t IR::Source::getLatency(IR::Source *this)
{
  if (*((unsigned char *)this + 24)) {
    return 0;
  }
  else {
    return *((unsigned int *)this + 5);
  }
}

uint64_t IR::Source::getIRLength(IR::Source *this)
{
  return *((unsigned int *)this + 40);
}

void IR::Source::getUserData(void *a1@<X8>)
{
  *a1 = 0;
}

uint64_t IR::DynamicCoefficients::coefficientsCanChange(IR::DynamicCoefficients *this)
{
  return 1;
}

uint64_t IR::DynamicCoefficients::providesCoefficients(IR::DynamicCoefficients *this)
{
  return 0;
}

uint64_t IR::DynamicCoefficients::type(IR::DynamicCoefficients *this)
{
  return 1;
}

void IR::DynamicCoefficients::~DynamicCoefficients(IR::DynamicCoefficients *this)
{
  *(void *)this = &unk_1F14BEDB0;
  IR::IRDataAttributes::~IRDataAttributes((IR::DynamicCoefficients *)((char *)this + 8));

  JUMPOUT(0x1C185D370);
}

{
  *(void *)this = &unk_1F14BEDB0;
  IR::IRDataAttributes::~IRDataAttributes((IR::DynamicCoefficients *)((char *)this + 8));
}

uint64_t std::__shared_ptr_emplace<IR::DynamicCoefficients>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<IR::DynamicCoefficients>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F14BEE38;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1C185D370);
}

void std::__shared_ptr_emplace<IR::DynamicCoefficients>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F14BEE38;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void clsp::AdaptiveDisplacementController::setLogs(void *a1, uint64_t *a2)
{
  uint64_t v5 = *a2;
  uint64_t v4 = a2[1];
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  int v6 = (std::__shared_weak_count *)a1[45];
  a1[44] = v5;
  a1[45] = v4;
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  uint64_t v8 = *a2;
  uint64_t v7 = a2[1];
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  CFStringRef v9 = (std::__shared_weak_count *)a1[37];
  a1[36] = v8;
  a1[37] = v7;
  if (v9)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }
}

double clsp::DisplacementControllerBase::getAttenuationMax(clsp::DisplacementControllerBase *this)
{
  return 0.0;
}

double clsp::DisplacementControllerBase::getflvMax(clsp::DisplacementControllerBase *this)
{
  return 0.0;
}

uint64_t clsp::AdaptiveDisplacementController::zapBadValues(uint64_t this)
{
  float32x2_t v1 = *(float32x2_t *)(this + 92);
  float64x2_t v2 = vcvtq_f64_f32(vabs_f32(v1));
  float64x2_t v3 = (float64x2_t)vdupq_n_s64(0x3CD203AF9EE75616uLL);
  float64x2_t v4 = (float64x2_t)vdupq_n_s64(0x430C6BF526340000uLL);
  *(int8x8_t *)(this + 92) = vand_s8((int8x8_t)v1, (int8x8_t)vmovn_s64((int64x2_t)vandq_s8((int8x16_t)vcgtq_f64(v2, v3), (int8x16_t)vcgtq_f64(v4, v2))));
  float v5 = *(float *)(this + 192);
  double v6 = fabsf(v5);
  if (v6 >= 1.0e15 || v6 <= 1.0e-15) {
    float v5 = 0.0;
  }
  *(float *)(this + 192) = v5;
  float32x2_t v8 = *(float32x2_t *)(this + 112);
  float64x2_t v9 = vcvtq_f64_f32(vabs_f32(v8));
  *(int8x8_t *)(this + 112) = vand_s8((int8x8_t)v8, (int8x8_t)vmovn_s64((int64x2_t)vandq_s8((int8x16_t)vcgtq_f64(v9, v3), (int8x16_t)vcgtq_f64(v4, v9))));
  float v10 = *(float *)(this + 232);
  double v11 = fabsf(v10);
  if (v11 >= 1.0e15 || v11 <= 1.0e-15) {
    float v10 = 0.0;
  }
  *(float *)(this + 232) = v10;
  float v13 = *(float *)(this + 252);
  double v14 = fabsf(v13);
  if (v14 >= 1.0e15 || v14 <= 1.0e-15) {
    float v13 = 0.0;
  }
  *(float *)(this + 252) = v13;
  float32x4_t v16 = *(float32x4_t *)(this + 324);
  float32x4_t v17 = vabsq_f32(v16);
  float64x2_t v18 = vcvt_hight_f64_f32(v17);
  float64x2_t v19 = vcvtq_f64_f32(*(float32x2_t *)v17.f32);
  *(int8x16_t *)(this + 324) = vandq_s8((int8x16_t)v16, (int8x16_t)vuzp1q_s32((int32x4_t)vandq_s8((int8x16_t)vcgtq_f64(v19, v3), (int8x16_t)vcgtq_f64(v4, v19)), (int32x4_t)vandq_s8((int8x16_t)vcgtq_f64(v18, v3), (int8x16_t)vcgtq_f64(v4, v18))));
  float v20 = *(float *)(this + 76);
  double v21 = fabsf(v20);
  if (v21 >= 1.0e15 || v21 <= 1.0e-15) {
    float v20 = 0.0;
  }
  if (v20 < *(float *)(this + 68)) {
    float v20 = *(float *)(this + 68);
  }
  *(float *)(this + 76) = v20;
  return this;
}

float clsp::AdaptiveDisplacementController::reset(clsp::AdaptiveDisplacementController *this)
{
  *(void *)((char *)this + 332) = 0;
  *(void *)((char *)this + 324) = 0;
  *(void *)((char *)this + 92) = 0;
  *((_DWORD *)this + 48) = 0;
  *((void *)this + 14) = 0;
  *((_DWORD *)this + 58) = 0;
  *((_DWORD *)this + 63) = 0;
  float result = (*(double (**)(clsp::AdaptiveDisplacementController *))(*(void *)this + 56))(this);
  *((float *)this + 19) = result;
  return result;
}

float clsp::AdaptiveDisplacementController::getNormAttenFactor(clsp::AdaptiveDisplacementController *this)
{
  return *((float *)this + 19) * *((float *)this + 18);
}

float clsp::AdaptiveDisplacementController::analyzeDisp(clsp::AdaptiveDisplacementController *this, float a2, float a3)
{
  float v5 = (double *)*((void *)this + 18);
  uint64_t v6 = *(void *)v5;
  double v107 = v5[6];
  double v7 = *(double *)(*(void *)v5 + 16) * v5[5] - **(double **)v5 * v107 - *(double *)(*(void *)v5 + 8) * v5[7];
  uint64_t v8 = *(void *)(*(void *)v5 + 120);
  uint64_t v9 = ((*(void *)(*(void *)v5 + 128) - v8) >> 3) - 1;
  double v10 = *(double *)(v8 + 8 * v9);
  if ((int)v9 >= 1)
  {
    unint64_t v11 = ((*(void *)(*(void *)v5 + 128) - v8) >> 3) - 1 + 1;
    do
      double v10 = *(double *)(v8 + 8 * (v11-- - 2)) + v7 * v10;
    while (v11 > 1);
  }
  char v12 = *(double **)(v6 + 48);
  uint64_t v13 = *(void *)(v6 + 56);
  unint64_t v14 = (v13 - (uint64_t)v12) >> 3;
  double v15 = v12[v14 - 1];
  if ((int)v14 - 1 >= 1)
  {
    unint64_t v16 = (v14 - 1) + 1;
    do
      double v15 = v12[(v16-- - 2)] + v7 * v15;
    while (v16 > 1);
  }
  float v17 = *((float *)v5 + 4);
  double v18 = v5[3];
  double v104 = v5[4];
  double v19 = *(double *)(v6 + 32);
  std::string __p = 0;
  vDSP_Length v110 = 0;
  uint64_t v111 = 0;
  std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>(&__p, v12, v13, v14);
  uint64_t v20 = *(void *)(v6 + 56) - *(void *)(v6 + 48);
  uint64_t v21 = (v20 >> 3) - 1;
  double v22 = *((double *)__p + v21) * (double)(unint64_t)v21;
  if ((int)v21 > 1)
  {
    unint64_t v23 = (unint64_t)v20 >> 3;
    unint64_t v24 = (v20 >> 3) - 1 + 1;
    int v25 = v23 - 2;
    do
      double v22 = v7 * v22 + (double)v25-- * *((double *)__p + (v24-- - 2));
    while (v24 > 2);
  }
  float v26 = v17 * a2;
  vDSP_Length v110 = __p;
  operator delete(__p);
  uint64_t v27 = *(void *)(v6 + 72);
  uint64_t v28 = ((*(void *)(v6 + 80) - v27) >> 3) - 1;
  double v29 = *(double *)(v27 + 8 * v28);
  if ((int)v28 < 2)
  {
    double v31 = v104;
  }
  else
  {
    unint64_t v30 = ((*(void *)(v6 + 80) - v27) >> 3) - 1 + 1;
    double v31 = v104;
    do
      double v29 = *(double *)(v27 + 8 * (v30-- - 2)) + v7 * v29;
    while (v30 > 2);
  }
  double v32 = v18 * (v7 - v107);
  uint64_t v33 = *(void *)(v6 + 96);
  uint64_t v34 = ((*(void *)(v6 + 104) - v33) >> 3) - 1;
  double v35 = *(double *)(v33 + 8 * v34);
  if ((int)v34 > 1)
  {
    unint64_t v36 = ((*(void *)(v6 + 104) - v33) >> 3) - 1 + 1;
    do
      double v35 = *(double *)(v33 + 8 * (v36-- - 2)) + v32 * v35;
    while (v36 > 2);
  }
  double v37 = (v26 + v31 * v15 * v18 - v10 * v32) / (v19 + v15 * v18 + v22 * v32);
  v5[4] = v37;
  v5[5] = v7 * -(v7 * v29) + v10 * v37 + -(v32 * v35) * v32;
  v5[6] = v7;
  v5[7] = v107;
  float v38 = v7;
  float v39 = -v38;
  if (v38 >= 0.0) {
    float v39 = v7;
  }
  float v40 = *((float *)this + 48);
  uint64_t v41 = 180;
  if (v40 < v39) {
    uint64_t v41 = 176;
  }
  float v42 = v40 + (float)(*(float *)((char *)this + v41) * (float)(v39 - v40));
  *((float *)this + 48) = v42;
  if (*((float *)this + 17) >= v42) {
    float v43 = *((float *)this + 17);
  }
  else {
    float v43 = v42;
  }
  long long v44 = (double *)*((void *)this + 19);
  uint64_t v45 = *(void *)v44;
  double v46 = v44[6];
  double v47 = *(double *)(*(void *)v44 + 16) * v44[5]
      - **(double **)v44 * v46
      - *(double *)(*(void *)v44 + 8) * v44[7];
  uint64_t v48 = *(void *)(*(void *)v44 + 120);
  uint64_t v49 = ((*(void *)(*(void *)v44 + 128) - v48) >> 3) - 1;
  double v50 = *(double *)(v48 + 8 * v49);
  if ((int)v49 >= 1)
  {
    unint64_t v51 = ((*(void *)(*(void *)v44 + 128) - v48) >> 3) - 1 + 1;
    do
      double v50 = *(double *)(v48 + 8 * (v51-- - 2)) + v47 * v50;
    while (v51 > 1);
  }
  uint64_t v52 = *(double **)(v45 + 48);
  uint64_t v53 = *(void *)(v45 + 56);
  unint64_t v54 = (v53 - (uint64_t)v52) >> 3;
  double v55 = v52[v54 - 1];
  float v108 = v43;
  float v101 = v42;
  float v102 = v38;
  if ((int)v54 - 1 >= 1)
  {
    unint64_t v56 = (v54 - 1) + 1;
    do
      double v55 = v52[(v56-- - 2)] + v47 * v55;
    while (v56 > 1);
  }
  float v57 = *((float *)v44 + 4);
  double v58 = v44[3];
  double v103 = v44[4];
  double v59 = *(double *)(v45 + 32);
  std::string __p = 0;
  vDSP_Length v110 = 0;
  uint64_t v111 = 0;
  std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>(&__p, v52, v53, v54);
  uint64_t v60 = *(void *)(v45 + 56) - *(void *)(v45 + 48);
  uint64_t v61 = (v60 >> 3) - 1;
  double v62 = *((double *)__p + v61) * (double)(unint64_t)v61;
  if ((int)v61 > 1)
  {
    unint64_t v63 = (unint64_t)v60 >> 3;
    unint64_t v64 = (v60 >> 3) - 1 + 1;
    int v65 = v63 - 2;
    do
      double v62 = v47 * v62 + (double)v65-- * *((double *)__p + (v64-- - 2));
    while (v64 > 2);
  }
  float v66 = v57 * a3;
  double v105 = v46;
  double v67 = v47 - v46;
  vDSP_Length v110 = __p;
  operator delete(__p);
  uint64_t v68 = *(void *)(v45 + 72);
  uint64_t v69 = ((*(void *)(v45 + 80) - v68) >> 3) - 1;
  double v70 = *(double *)(v68 + 8 * v69);
  if ((int)v69 < 2)
  {
    double v72 = v103;
  }
  else
  {
    unint64_t v71 = ((*(void *)(v45 + 80) - v68) >> 3) - 1 + 1;
    double v72 = v103;
    do
      double v70 = *(double *)(v68 + 8 * (v71-- - 2)) + v47 * v70;
    while (v71 > 2);
  }
  double v73 = v66;
  double v74 = v58 * v67;
  uint64_t v75 = *(void *)(v45 + 96);
  uint64_t v76 = ((*(void *)(v45 + 104) - v75) >> 3) - 1;
  double v77 = *(double *)(v75 + 8 * v76);
  if ((int)v76 < 2)
  {
    float v79 = v108;
    double v80 = v105;
  }
  else
  {
    unint64_t v78 = ((*(void *)(v45 + 104) - v75) >> 3) - 1 + 1;
    float v79 = v108;
    double v80 = v105;
    do
      double v77 = *(double *)(v75 + 8 * (v78-- - 2)) + v74 * v77;
    while (v78 > 2);
  }
  double v81 = (v73 + v72 * v55 * v58 - v50 * v74) / (v59 + v55 * v58 + v62 * v74);
  v44[4] = v81;
  v44[5] = v47 * -(v47 * v70) + v50 * v81 + -(v74 * v77) * v74;
  v44[6] = v47;
  v44[7] = v80;
  float v82 = v47;
  float v83 = -v82;
  if (v82 >= 0.0) {
    float v83 = v47;
  }
  float v84 = *((float *)this + 58);
  uint64_t v85 = 220;
  if (v84 < v83) {
    uint64_t v85 = 216;
  }
  float v86 = v84 + (float)(*(float *)((char *)this + v85) * (float)(v83 - v84));
  *((float *)this + 58) = v86;
  float v87 = *((float *)this + 17);
  if (v87 < v86) {
    float v87 = v86;
  }
  float v88 = *((float *)this + 63)
      + (float)(*((float *)this + 62) * (float)((float)(*((float *)this + 18) * v87) - *((float *)this + 63)));
  *((float *)this + 63) = v88;
  *((float *)this + 19) = v79 * v88;
  char v89 = (clsp::CLSP_Log **)*((void *)this + 44);
  uint64_t v90 = *v89;
  if (*v89)
  {
    *(float *)&std::string __p = a3;
    clsp::CLSP_Log::LogCLSPData(v90, (const float *)&__p, 1);
    char v89 = (clsp::CLSP_Log **)*((void *)this + 44);
  }
  char v91 = v89[2];
  if (v91)
  {
    *(float *)&std::string __p = v102;
    clsp::CLSP_Log::LogCLSPData(v91, (const float *)&__p, 1);
    char v89 = (clsp::CLSP_Log **)*((void *)this + 44);
    char v92 = v89[2];
    if (v92)
    {
      *(float *)&std::string __p = v101;
      clsp::CLSP_Log::LogCLSPData(v92, (const float *)&__p, 1);
      char v89 = (clsp::CLSP_Log **)*((void *)this + 44);
      uint64_t v93 = v89[2];
      if (v93)
      {
        *(float *)&std::string __p = v79;
        clsp::CLSP_Log::LogCLSPData(v93, (const float *)&__p, 1);
        char v89 = (clsp::CLSP_Log **)*((void *)this + 44);
        unint64_t v94 = v89[2];
        if (v94)
        {
          *(float *)&std::string __p = v88;
          clsp::CLSP_Log::LogCLSPData(v94, (const float *)&__p, 1);
          char v89 = (clsp::CLSP_Log **)*((void *)this + 44);
        }
      }
    }
  }
  float v95 = *v89;
  if (*v89)
  {
    *(float *)&std::string __p = v47;
    clsp::CLSP_Log::LogCLSPData(v95, (const float *)&__p, 1);
    float v96 = (clsp::CLSP_Log *)**((void **)this + 44);
    if (v96)
    {
      *(float *)&std::string __p = v86;
      clsp::CLSP_Log::LogCLSPData(v96, (const float *)&__p, 1);
      uint64_t v97 = (clsp::CLSP_Log *)**((void **)this + 44);
      if (v97)
      {
        LODWORD(__p) = *((_DWORD *)this + 19);
        clsp::CLSP_Log::LogCLSPData(v97, (const float *)&__p, 1);
        char v98 = (clsp::CLSP_Log *)**((void **)this + 44);
        if (v98)
        {
          char v99 = (float *)(*(uint64_t (**)(clsp::AdaptiveDisplacementController *))(*(void *)this + 128))(this);
          *(float *)&std::string __p = log10f(v99[21]* (float)((float)((float)((float)(1.0 - v99[12]) + v99[13])* (float)((float)(v99[14] + v99[15]) + v99[16]))/ (float)((float)(v99[12] + 1.0) + v99[13])))* 20.0;
          clsp::CLSP_Log::LogCLSPData(v98, (const float *)&__p, 1);
        }
      }
    }
  }
  return *((float *)this + 19);
}

void *std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    float result = std::vector<std::tuple<unsigned int,float>>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      float result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1BB391730(_Unwind_Exception *exception_object)
{
  float64x2_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void clsp::AdaptiveDisplacementController::processSample(clsp::AdaptiveDisplacementController *this, float a2, float a3)
{
  if (*((unsigned char *)this + 64))
  {
    float v5 = *((float *)this + 19) * *((float *)this + 86);
    if (v5 >= *((float *)this + 70)) {
      float v5 = *((float *)this + 70);
    }
    float v6 = (float)(*((float *)this + 64) + (float)(*((float *)this + 65) * v5))
       + (float)(*((float *)this + 66) * (float)(v5 * v5));
    float v7 = (float)(*((float *)this + 67) + (float)(*((float *)this + 68) * v5))
       + (float)(*((float *)this + 69) * (float)(v5 * v5));
    *((float *)this + 76) = v6;
    *((float *)this + 77) = v7;
    size_t v8 = *(clsp::CLSP_Log **)(*((void *)this + 36) + 16);
    if (v8)
    {
      float __src = v6;
      clsp::CLSP_Log::LogCLSPData(v8, &__src, 1);
      uint64_t v9 = *(clsp::CLSP_Log **)(*((void *)this + 36) + 16);
      if (v9)
      {
        float v14 = v7;
        clsp::CLSP_Log::LogCLSPData(v9, &v14, 1);
      }
    }
    float v10 = *((float *)this + 81);
    float v11 = *((float *)this + 83);
    float v12 = (float)((float)((float)((float)(*((float *)this + 79) * v10) + (float)(a3 * *((float *)this + 78)))
                        + (float)(*((float *)this + 82) * *((float *)this + 80)))
                - (float)(v11 * *((float *)this + 76)))
        - (float)(*((float *)this + 84) * *((float *)this + 77));
    *((float *)this + 81) = a3;
    *((float *)this + 82) = v10;
    *((float *)this + 83) = v12;
    *((float *)this + 84) = v11;
  }
}

uint64_t clsp::AdaptiveDisplacementController::calcCoeffsSyncDisp(clsp::AdaptiveDisplacementController *this, double a2, double a3, double a4, double a5, double a6, double a7)
{
  float v7 = (double *)*((void *)this + 15);
  if (!v7) {
    __assert_rtn("calcCoeffsSyncDisp", "CLSPBlocksAdaptive.cpp", 318, "mr_dispModel");
  }
  double v13 = 1.0 / a2;
  double v14 = -(1.0 / a2 * a3);
  long double v15 = exp(v14 / (a4 + a4)) * -2.0;
  long double v16 = v15 * cos(v13 * a3 * sqrt(1.0 / (a4 * -4.0 * a4) + 1.0));
  long double v17 = exp(v14 / a4);
  float v18 = (v17 + v16 + 1.0) * (a7 * 1000.0 * v7[1] / (*v7 * v7[4]));
  float v19 = v16;
  *(float *)&long double v17 = v17;
  *((float *)this + 20) = v19;
  *((_DWORD *)this + 21) = LODWORD(v17);
  *((float *)this + 22) = v18;
  LODWORD(v17) = *((_DWORD *)this + 25);
  float v20 = *((float *)this + 26);
  uint64_t v21 = *((void *)this + 10);
  *((_DWORD *)this + 78) = 1065353216;
  *((_DWORD *)this + 79) = LODWORD(v17);
  *((float *)this + 80) = v20;
  *((void *)this + 38) = v21;
  *(float *)&long double v17 = 1.0 / (1.0 - *(float *)&v17 + v20);
  *((_DWORD *)this + 85) = LODWORD(v17);

  return clsp::LFSNFeedbackCoeffCalc::calcCoeffs((clsp::AdaptiveDisplacementController *)((char *)this + 256), a2, a3, a4, a5, 1.0, a6);
}

float clsp::AdaptiveDisplacementController::calcCoeffs(clsp::AdaptiveDisplacementController *this, double a2, double a3)
{
  float64x2_t v4 = (double *)*((void *)this + 15);
  if (!v4) {
    __assert_rtn("calcCoeffs", "CLSPBlocksAdaptive.cpp", 287, "mr_dispModel");
  }
  float v7 = clsp::DisplacementModelSealed::calcCoeffsFLV(v4, (float *)this + 25, a2, a3);
  size_t v8 = (double *)*((void *)this + 15);
  double v9 = (*(double (**)(clsp::AdaptiveDisplacementController *, float))(*(void *)this + 72))(this, v7);
  double v10 = (*(double (**)(clsp::AdaptiveDisplacementController *))(*(void *)this + 40))(this);
  float v11 = clsp::DisplacementModelSealed::calcCoeffsPTP(v8, (float *)this + 20, a2, v9, v10, a3);
  float v12 = (double *)*((void *)this + 15);
  double v13 = (*(double (**)(clsp::AdaptiveDisplacementController *, float))(*(void *)this + 72))(this, v11);
  double v14 = (*(double (**)(clsp::AdaptiveDisplacementController *))(*(void *)this + 40))(this);
  double v15 = (*(double (**)(clsp::AdaptiveDisplacementController *))(*(void *)this + 56))(this);
  clsp::LFSN::calcCoeffs((uint64_t)this + 256, v12, a2, *((double *)this + 10), *((float *)this + 25), *((float *)this + 26), v13, v14, v15, a3);
  clsp::AttackRelease<float,double>::calcCoeffs((uint64_t)this + 160, a2);
  clsp::AttackRelease<float,double>::calcCoeffs((uint64_t)this + 200, a2);
  double v16 = *((double *)this + 7);
  *((double *)this + 30) = v16;
  double v17 = v16 * a2;
  double v18 = 0.0;
  if (v17 >= 0.00001) {
    double v18 = exp(-4.60517019 / v17);
  }
  float v19 = 1.0 - v18;
  *((float *)this + 62) = v19;
  double v20 = *((double *)this + 3);
  float v21 = v20;
  float result = 1.0 / v20;
  *((float *)this + 17) = v21;
  *((float *)this + 18) = result;
  return result;
}

float clsp::DisplacementModelSealed::calcCoeffsFLV(double *a1, float *a2, double a3, double a4)
{
  double v5 = a1[4];
  double v7 = a1[1];
  double v6 = a1[2];
  double v8 = *a1;
  double v9 = sqrt(v5 * v6) / (a1[3] + v7 * v7 / *a1);
  double v10 = sqrt(v5 / v6);
  double v11 = 1.0 / a3;
  double v12 = -(1.0 / a3 * v10);
  long double v13 = exp(v12 / (v9 + v9)) * -2.0;
  long double v14 = v13 * cos(v11 * v10 * sqrt(1.0 / (v9 * -4.0 * v9) + 1.0));
  long double v15 = exp(v12 / v9);
  float v16 = (v15 + v14 + 1.0) * (a4 * 1000.0 * v7 / (v8 * v5));
  float v17 = v14;
  float result = v15;
  *a2 = v17;
  a2[1] = result;
  a2[2] = v16;
  return result;
}

float clsp::DisplacementModelSealed::calcCoeffsPTP(double *a1, float *a2, double a3, double a4, double a5, double a6)
{
  double v10 = a1[4];
  double v11 = sqrt(v10 / a1[2]) / sqrt(a5);
  double v12 = 1.0 / a3;
  double v13 = -(1.0 / a3 * v11);
  long double v14 = exp(v13 / (a4 + a4)) * -2.0;
  long double v15 = v14 * cos(v12 * v11 * sqrt(1.0 / (a4 * -4.0 * a4) + 1.0));
  long double v16 = exp(v13 / a4);
  float v17 = (v16 + v15 + 1.0) * (a6 * 1000.0 * a1[1] / (*a1 * v10));
  float v18 = v15;
  float result = v16;
  *a2 = v18;
  a2[1] = result;
  a2[2] = v17;
  return result;
}

float clsp::LFSN::calcCoeffs(uint64_t a1, double *a2, double a3, double a4, float a5, float a6, double a7, double a8, double a9, double a10)
{
  *(_DWORD *)(a1 + 56) = 1065353216;
  *(float *)(a1 + 60) = a5;
  *(float *)(a1 + 64) = a6;
  *(double *)(a1 + 48) = a4;
  double v12 = a5;
  double v13 = 1.0;
  *(float *)&double v12 = 1.0 / (1.0 - v12 + a6);
  *(_DWORD *)(a1 + 84) = LODWORD(v12);
  double v14 = a2[4];
  double v15 = a2[1];
  double v16 = a2[2];
  double v17 = sqrt(v14 / v16);
  double v18 = sqrt(v14 * v16) / (a2[3] + v15 * v15 / *a2);
  double v19 = a10 * 1000.0 * v15;
  if (v18 >= 1.0) {
    double v13 = v18;
  }
  clsp::LFSNFeedbackCoeffCalc::calcCoeffs((clsp::LFSNFeedbackCoeffCalc *)a1, a3, v17, a7, a8, a9, v19 * v13 / (*a2 * v14));
  float result = v17;
  *(float *)(a1 + 92) = result;
  *(_DWORD *)(a1 + 88) = 1065353216;
  return result;
}

float clsp::AttackRelease<float,double>::calcCoeffs(uint64_t a1, double a2)
{
  *(double *)(a1 + 24) = a2;
  double v4 = *(double *)(a1 + 8) * a2;
  double v5 = 0.0;
  double v6 = 0.0;
  if (v4 >= 0.00001) {
    double v6 = exp(-4.60517019 / v4);
  }
  float v7 = 1.0 - v6;
  *(float *)(a1 + 20) = v7;
  double v8 = *(double *)a1 * a2;
  if (v8 >= 0.00001) {
    double v5 = exp(-4.60517019 / v8);
  }
  float result = 1.0 - v5;
  *(float *)(a1 + 16) = result;
  return result;
}

float clsp::AdaptiveDisplacementController::getAttenuationFactor(clsp::AdaptiveDisplacementController *this)
{
  return *((float *)this + 19);
}

uint64_t clsp::AdaptiveDisplacementController::setAttenuationFactor(uint64_t this, float a2)
{
  *(float *)(this + 76) = a2;
  return this;
}

uint64_t clsp::AdaptiveDisplacementController::getDispEnabled(clsp::AdaptiveDisplacementController *this)
{
  return *((unsigned __int8 *)this + 64);
}

uint64_t clsp::AdaptiveDisplacementController::setDispEnabled(uint64_t this, char a2)
{
  *(unsigned char *)(this + 64) = a2;
  return this;
}

uint64_t clsp::AdaptiveDisplacementController::getLFSN(clsp::AdaptiveDisplacementController *this)
{
  return (uint64_t)this + 256;
}

double clsp::AdaptiveDisplacementController::getFlvSmoothingTime(clsp::AdaptiveDisplacementController *this)
{
  return *((double *)this + 7);
}

uint64_t clsp::AdaptiveDisplacementController::setFlvSmoothingTime(uint64_t this, double a2)
{
  *(double *)(this + 56) = a2;
  return this;
}

double clsp::AdaptiveDisplacementController::getPeakDecayTime(clsp::AdaptiveDisplacementController *this)
{
  return *((double *)this + 6);
}

double *clsp::AdaptiveDisplacementController::setPeakDecayTime(double *this, double a2)
{
  this[6] = a2;
  this[21] = a2;
  this[26] = a2;
  return this;
}

double clsp::AdaptiveDisplacementController::getPeakAttackTime(clsp::AdaptiveDisplacementController *this)
{
  return *((double *)this + 5);
}

double *clsp::AdaptiveDisplacementController::setPeakAttackTime(double *this, double a2)
{
  this[5] = a2;
  this[20] = a2;
  this[25] = a2;
  return this;
}

double clsp::AdaptiveDisplacementController::getQ_d(clsp::AdaptiveDisplacementController *this)
{
  return *((double *)this + 4);
}

uint64_t clsp::AdaptiveDisplacementController::setQ_d(uint64_t this, double a2)
{
  *(double *)(this + 32) = a2;
  return this;
}

double clsp::AdaptiveDisplacementController::getX_lim(clsp::AdaptiveDisplacementController *this)
{
  return *((double *)this + 3);
}

uint64_t clsp::AdaptiveDisplacementController::setX_lim(uint64_t this, double a2)
{
  *(double *)(this + 24) = a2;
  return this;
}

double clsp::AdaptiveDisplacementController::getG_bw(clsp::AdaptiveDisplacementController *this)
{
  return *((double *)this + 2);
}

uint64_t clsp::AdaptiveDisplacementController::setG_bw(uint64_t this, double a2)
{
  *(double *)(this + 16) = a2;
  return this;
}

void clsp::AdaptiveDisplacementController::logCoeffs(uint64_t a1, uint64_t a2)
{
  double v4 = *(clsp::CLSP_Log **)a2;
  if (!*(void *)a2) {
    goto LABEL_10;
  }
  float v5 = *(double *)(a1 + 16);
  float __src = v5;
  clsp::CLSP_Log::LogCLSPData(v4, &__src, 1);
  double v6 = *(clsp::CLSP_Log **)a2;
  if (!*(void *)a2) {
    goto LABEL_10;
  }
  float v7 = *(double *)(a1 + 24);
  float __src = v7;
  clsp::CLSP_Log::LogCLSPData(v6, &__src, 1);
  double v8 = *(clsp::CLSP_Log **)a2;
  if (!*(void *)a2) {
    goto LABEL_10;
  }
  float v9 = *(double *)(a1 + 32);
  float __src = v9;
  clsp::CLSP_Log::LogCLSPData(v8, &__src, 1);
  double v10 = *(clsp::CLSP_Log **)a2;
  if (!*(void *)a2) {
    goto LABEL_10;
  }
  float v11 = *(double *)(a1 + 40);
  float __src = v11;
  clsp::CLSP_Log::LogCLSPData(v10, &__src, 1);
  double v12 = *(clsp::CLSP_Log **)a2;
  if (!*(void *)a2) {
    goto LABEL_10;
  }
  float v13 = *(double *)(a1 + 48);
  float __src = v13;
  clsp::CLSP_Log::LogCLSPData(v12, &__src, 1);
  double v14 = *(clsp::CLSP_Log **)a2;
  if (!*(void *)a2) {
    goto LABEL_10;
  }
  float v15 = *(double *)(a1 + 56);
  float __src = v15;
  clsp::CLSP_Log::LogCLSPData(v14, &__src, 1);
  double v16 = *(clsp::CLSP_Log **)a2;
  if (*(void *)a2
    && (float __src = *(float *)(a1 + 68), clsp::CLSP_Log::LogCLSPData(v16, &__src, 1),
                                     (double v17 = *(clsp::CLSP_Log **)a2) != 0))
  {
    float __src = *(float *)(a1 + 72);
    clsp::CLSP_Log::LogCLSPData(v17, &__src, 1);
    double v18 = *(clsp::CLSP_Log **)a2;
  }
  else
  {
LABEL_10:
    double v18 = 0;
  }
  double v19 = (float *)(a1 + 80);
  double v20 = *(atomic_ullong **)(a2 + 8);
  v37[0] = v18;
  v37[1] = (clsp::CLSP_Log *)v20;
  if (v20)
  {
    atomic_fetch_add_explicit(v20 + 1, 1uLL, memory_order_relaxed);
    clsp::IIRTwoPole<float>::logCoeffs(v19, v37);
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v20);
  }
  else
  {
    clsp::IIRTwoPole<float>::logCoeffs(v19, v37);
  }
  float v21 = (float *)(a1 + 100);
  double v22 = *(atomic_ullong **)(a2 + 8);
  v36[0] = *(clsp::CLSP_Log **)a2;
  v36[1] = (clsp::CLSP_Log *)v22;
  if (v22)
  {
    atomic_fetch_add_explicit(v22 + 1, 1uLL, memory_order_relaxed);
    clsp::IIRTwoPole<float>::logCoeffs(v21, v36);
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v22);
  }
  else
  {
    clsp::IIRTwoPole<float>::logCoeffs(v21, v36);
  }
  uint64_t v23 = a1 + 160;
  unint64_t v24 = *(atomic_ullong **)(a2 + 8);
  v35[0] = *(clsp::CLSP_Log **)a2;
  v35[1] = (clsp::CLSP_Log *)v24;
  if (v24)
  {
    atomic_fetch_add_explicit(v24 + 1, 1uLL, memory_order_relaxed);
    clsp::AttackRelease<float,double>::logCoeffs(v23, v35);
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v24);
  }
  else
  {
    clsp::AttackRelease<float,double>::logCoeffs(v23, v35);
  }
  uint64_t v25 = a1 + 200;
  float v26 = *(atomic_ullong **)(a2 + 8);
  v34[0] = *(clsp::CLSP_Log **)a2;
  v34[1] = (clsp::CLSP_Log *)v26;
  if (v26)
  {
    atomic_fetch_add_explicit(v26 + 1, 1uLL, memory_order_relaxed);
    clsp::AttackRelease<float,double>::logCoeffs(v25, v34);
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v26);
  }
  else
  {
    clsp::AttackRelease<float,double>::logCoeffs(v25, v34);
  }
  uint64_t v27 = a1 + 240;
  uint64_t v28 = *(atomic_ullong **)(a2 + 8);
  v33[0] = *(clsp::CLSP_Log **)a2;
  v33[1] = (clsp::CLSP_Log *)v28;
  if (v28)
  {
    atomic_fetch_add_explicit(v28 + 1, 1uLL, memory_order_relaxed);
    clsp::ExponentialSmoother<float,double>::logCoeffs(v27, v33);
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v28);
  }
  else
  {
    clsp::ExponentialSmoother<float,double>::logCoeffs(v27, v33);
  }
  double v29 = (float *)(a1 + 256);
  unint64_t v30 = *(clsp::CLSP_Log **)a2;
  double v31 = *(std::__shared_weak_count **)(a2 + 8);
  v32[0] = v30;
  v32[1] = v31;
  if (v31)
  {
    atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
    clsp::LFSN::logCoeffs(v29, (uint64_t)v32);
    std::__shared_weak_count::__release_shared[abi:ne180100](v31);
  }
  else
  {
    clsp::LFSN::logCoeffs(v29, (uint64_t)v32);
  }
}

void clsp::IIRTwoPole<float>::logCoeffs(float *a1, clsp::CLSP_Log **a2)
{
  float64x2_t v3 = *a2;
  if (*a2)
  {
    float __src = *a1;
    clsp::CLSP_Log::LogCLSPData(v3, &__src, 1);
    float v5 = *a2;
    if (*a2)
    {
      float v8 = a1[1];
      clsp::CLSP_Log::LogCLSPData(v5, &v8, 1);
      double v6 = *a2;
      if (*a2)
      {
        float v9 = a1[2];
        clsp::CLSP_Log::LogCLSPData(v6, &v9, 1);
      }
    }
  }
}

float clsp::AttackRelease<float,double>::logCoeffs(uint64_t a1, clsp::CLSP_Log **a2)
{
  float64x2_t v3 = *a2;
  if (*a2)
  {
    float v5 = *(double *)a1;
    float __src = v5;
    clsp::CLSP_Log::LogCLSPData(v3, &__src, 1);
    float v7 = *a2;
    if (*a2)
    {
      float v8 = *(double *)(a1 + 8);
      float __src = v8;
      clsp::CLSP_Log::LogCLSPData(v7, &__src, 1);
      float v9 = *a2;
      if (*a2)
      {
        float __src = *(float *)(a1 + 16);
        clsp::CLSP_Log::LogCLSPData(v9, &__src, 1);
        double v10 = *a2;
        if (*a2)
        {
          float __src = *(float *)(a1 + 20);
          clsp::CLSP_Log::LogCLSPData(v10, &__src, 1);
          float v11 = *a2;
          if (*a2)
          {
            float v12 = *(double *)(a1 + 24);
            float __src = v12;
            clsp::CLSP_Log::LogCLSPData(v11, &__src, 1);
          }
        }
      }
    }
  }
  return result;
}

void clsp::ExponentialSmoother<float,double>::logCoeffs(uint64_t a1, clsp::CLSP_Log **a2)
{
  float64x2_t v3 = *a2;
  if (*a2)
  {
    float v5 = *(double *)a1;
    float __src = v5;
    clsp::CLSP_Log::LogCLSPData(v3, &__src, 1);
    double v6 = *a2;
    if (*a2)
    {
      float v8 = *(float *)(a1 + 8);
      clsp::CLSP_Log::LogCLSPData(v6, &v8, 1);
    }
  }
}

void clsp::LFSN::logCoeffs(float *a1, uint64_t a2)
{
  float v5 = *(clsp::CLSP_Log **)a2;
  double v4 = *(std::__shared_weak_count **)(a2 + 8);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v5)
  {
    float __src = *a1;
    clsp::CLSP_Log::LogCLSPData(v5, &__src, 1);
    float __src = a1[1];
    clsp::CLSP_Log::LogCLSPData(v5, &__src, 1);
    float __src = a1[2];
    clsp::CLSP_Log::LogCLSPData(v5, &__src, 1);
    float __src = a1[3];
    clsp::CLSP_Log::LogCLSPData(v5, &__src, 1);
    float __src = a1[4];
    clsp::CLSP_Log::LogCLSPData(v5, &__src, 1);
    float __src = a1[5];
    clsp::CLSP_Log::LogCLSPData(v5, &__src, 1);
    float __src = a1[6];
    clsp::CLSP_Log::LogCLSPData(v5, &__src, 1);
  }
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  float v7 = *(clsp::CLSP_Log **)a2;
  double v6 = *(std::__shared_weak_count **)(a2 + 8);
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v7)
  {
    float __src = a1[12];
    clsp::CLSP_Log::LogCLSPData(v7, &__src, 1);
    float __src = a1[13];
    clsp::CLSP_Log::LogCLSPData(v7, &__src, 1);
    float __src = a1[14];
    clsp::CLSP_Log::LogCLSPData(v7, &__src, 1);
    float __src = a1[15];
    clsp::CLSP_Log::LogCLSPData(v7, &__src, 1);
    float __src = a1[16];
    clsp::CLSP_Log::LogCLSPData(v7, &__src, 1);
  }
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  float v8 = *(clsp::CLSP_Log **)a2;
  if (*(void *)a2)
  {
    float __src = a1[21];
    clsp::CLSP_Log::LogCLSPData(v8, &__src, 1);
  }
}

void *clsp::AdaptiveDisplacementController::dump(uint64_t a1, void *a2)
{
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"g_bw = ", 7);
  double v4 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)"\nx_liuint64_t m = ", 9);
  float v5 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"\nQ_d = ", 7);
  double v6 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)"\npeakAttackTime = ", 18);
  float v7 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)"\npeakDecayTime = ", 17);
  float v8 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)"\nflvSmoothingTime = ", 20);
  float v9 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)"\nmc_x_liuint64_t m = ", 12);
  double v10 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)"\ninvxliuint64_t m = ", 11);
  float v11 = (void *)std::ostream::operator<<();
  float v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)"\n\nptp:\n", 7);
  clsp::IIRTwoPole<float>::dump(a1 + 80, v12);
  float v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)"\nflv:\n", 6);
  clsp::IIRTwoPole<float>::dump(a1 + 100, v13);
  double v14 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)"\nptpAtkRel:\n", 12);
  clsp::AttackRelease<float,double>::dump(a1 + 160, v14);
  float v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)"\nflvTime:\n", 10);
  clsp::AttackRelease<float,double>::dump(a1 + 200, v15);
  double v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)"\nflvSmoother:\n", 14);
  clsp::ExponentialSmoother<float,double>::dump(a1 + 240, v16);
  double v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)"\nlfsn:\n", 7);
  clsp::LFSN::dump(a1 + 256, v17);
  char v19 = 10;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)&v19, 1);
  return a2;
}

void *clsp::IIRTwoPole<float>::dump(uint64_t a1, void *a2)
{
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"a1 = ", 5);
  float64x2_t v3 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)"\na2 = ", 6);
  double v4 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)"\nb0 = ", 6);
  float v5 = (void *)std::ostream::operator<<();
  char v7 = 10;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)&v7, 1);
  return a2;
}

void *clsp::AttackRelease<float,double>::dump(uint64_t a1, void *a2)
{
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"attackTime = ", 13);
  float64x2_t v3 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)"\nreleaseTime = ", 15);
  double v4 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)"\na1_atuint64_t k = ", 10);
  float v5 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"\na1_rel = ", 10);
  double v6 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)"\nsampleRate = ", 14);
  char v7 = (void *)std::ostream::operator<<();
  char v9 = 10;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)&v9, 1);
  return a2;
}

void *clsp::ExponentialSmoother<float,double>::dump(uint64_t a1, void *a2)
{
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"decayTime = ", 12);
  float64x2_t v3 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)"\na1 = ", 6);
  std::ostream::operator<<();
  return a2;
}

void *clsp::LFSN::dump(uint64_t a1, void *a2)
{
  float64x2_t v3 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"fcc:\n", 5);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)"ca10 = ", 7);
  double v4 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)"\nca11 = ", 8);
  float v5 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"\nca12 = ", 8);
  double v6 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)"\nca20 = ", 8);
  char v7 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)"\nca21 = ", 8);
  float v8 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)"\nca22 = ", 8);
  char v9 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)"\nxUpperLimit = ", 15);
  double v10 = (void *)std::ostream::operator<<();
  char v18 = 10;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)&v18, 1);
  float v11 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)"\nlfsn:\n", 7);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)"a1 = ", 5);
  float v12 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)"\na2 = ", 6);
  float v13 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)"\nb0 = ", 6);
  double v14 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)"\nb1 = ", 6);
  float v15 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)"\nb2 = ", 6);
  double v16 = (void *)std::ostream::operator<<();
  char v19 = 10;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)&v19, 1);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)"\ncsigma = ", 10);
  std::ostream::operator<<();
  return a2;
}

void clsp::AdaptiveDisplacementController::~AdaptiveDisplacementController(clsp::AdaptiveDisplacementController *this)
{
  clsp::AdaptiveDisplacementController::~AdaptiveDisplacementController(this);

  JUMPOUT(0x1C185D370);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  uint64_t v5;
  std::__shared_weak_count *v6;

  *(void *)this = &unk_1F14ACB30;
  float64x2_t v2 = (std::__shared_weak_count *)*((void *)this + 45);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  float64x2_t v3 = (std::__shared_weak_count *)*((void *)this + 37);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  double v4 = *((void *)this + 19);
  *((void *)this + 19) = 0;
  if (v4) {
    std::default_delete<clsp::SpeakerModelNonlinear>::operator()[abi:ne180100](v4);
  }
  float v5 = *((void *)this + 18);
  *((void *)this + 18) = 0;
  if (v5) {
    std::default_delete<clsp::SpeakerModelNonlinear>::operator()[abi:ne180100](v5);
  }
  double v6 = (std::__shared_weak_count *)*((void *)this + 17);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
}

void std::default_delete<clsp::SpeakerModelNonlinear>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }

  JUMPOUT(0x1C185D370);
}

void *std::vector<double>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::tuple<unsigned int,float>>::__vallocate[abi:ne180100](a1, a2);
    double v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_1BB392CC8(_Unwind_Exception *exception_object)
{
  float64x2_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void AUSM::SoundStage::~SoundStage(AUSM::SoundStage *this)
{
  float64x2_t v2 = (void *)*((void *)this + 44);
  if (v2)
  {
    *((void *)this + 45) = v2;
    operator delete(v2);
  }
  float64x2_t v3 = (void *)*((void *)this + 40);
  if (v3)
  {
    *((void *)this + 41) = v3;
    operator delete(v3);
  }
  double v4 = (void *)*((void *)this + 37);
  if (v4)
  {
    *((void *)this + 38) = v4;
    operator delete(v4);
  }
  float v5 = (void *)*((void *)this + 34);
  if (v5)
  {
    *((void *)this + 35) = v5;
    operator delete(v5);
  }
  double v6 = (void *)*((void *)this + 31);
  if (v6)
  {
    *((void *)this + 32) = v6;
    operator delete(v6);
  }
  char v7 = (void *)*((void *)this + 28);
  if (v7)
  {
    *((void *)this + 29) = v7;
    operator delete(v7);
  }
  if (*((char *)this + 223) < 0) {
    operator delete(*((void **)this + 25));
  }
  float v11 = (void **)((char *)this + 168);
  std::vector<AUSM::SoundStage::SoundStageParameters>::__destroy_vector::operator()[abi:ne180100](&v11);
  float v11 = (void **)((char *)this + 136);
  std::vector<std::list<int>>::__destroy_vector::operator()[abi:ne180100](&v11);
  float v8 = (void *)*((void *)this + 14);
  if (v8)
  {
    *((void *)this + 15) = v8;
    operator delete(v8);
  }
  char v9 = (void *)*((void *)this + 11);
  if (v9)
  {
    *((void *)this + 12) = v9;
    operator delete(v9);
  }
  double v10 = (void *)*((void *)this + 8);
  if (v10)
  {
    *((void *)this + 9) = v10;
    operator delete(v10);
  }
  CDelaunayTriangles3D::~CDelaunayTriangles3D((AUSM::SoundStage *)((char *)this + 16));
}

void std::vector<AUSM::SoundStage::SoundStageParameters>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  float64x2_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    float v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 192;
        std::__destroy_at[abi:ne180100]<AUSM::SoundStage::SoundStageParameters,0>(v4);
      }
      while ((void *)v4 != v2);
      float v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<std::list<int>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  float64x2_t v2 = (uint64_t *)**a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t *)v1[1];
    float v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        double v6 = v4 - 3;
        if (*(v4 - 1))
        {
          uint64_t v8 = *(v4 - 3);
          char v7 = (uint64_t *)*(v4 - 2);
          uint64_t v9 = *v7;
          *(void *)(v9 + 8) = *(void *)(v8 + 8);
          **(void **)(v8 + 8) = v9;
          *(v4 - 1) = 0;
          if (v7 != v6)
          {
            do
            {
              double v10 = (uint64_t *)v7[1];
              operator delete(v7);
              char v7 = v10;
            }
            while (v10 != v6);
          }
        }
        uint64_t v4 = v6;
      }
      while (v6 != v2);
      float v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__destroy_at[abi:ne180100]<AUSM::SoundStage::SoundStageParameters,0>(uint64_t a1)
{
  float64x2_t v2 = *(void **)(a1 + 144);
  if (v2)
  {
    *(void *)(a1 + 152) = v2;
    operator delete(v2);
  }
  float64x2_t v3 = *(void **)(a1 + 80);
  if (v3)
  {
    *(void *)(a1 + 88) = v3;
    operator delete(v3);
  }
  uint64_t v4 = *(void **)(a1 + 56);
  if (v4)
  {
    *(void *)(a1 + 64) = v4;
    operator delete(v4);
  }
  float v5 = *(void **)(a1 + 32);
  if (v5)
  {
    *(void *)(a1 + 40) = v5;
    operator delete(v5);
  }
  if (*(char *)(a1 + 23) < 0)
  {
    double v6 = *(void **)a1;
    operator delete(v6);
  }
}

void AUSM::GlobalGeometry::update(float32x4_t *this, unsigned int a2, int a3)
{
  unsigned __int8 v6 = atomic_load(&this[67].u8[12]);
  if ((v6 & 1) != 0 || a3)
  {
    _X24 = 0;
    _X25 = 0;
    atomic_store(0, &this[67].u8[12]);
    __dmb(0xBu);
    __asm { CASPAL          X24, X25, X24, X25, [X8] }
    float v14 = *((float *)&_X24 + 1);
    float v15 = this[37].f32[0];
    if (v15 != *(float *)&_X24)
    {
      float v16 = 0.0;
      if (*(float *)&_X24 >= 0.0) {
        float v15 = *(float *)&_X24;
      }
      else {
        float v15 = 0.0;
      }
      this[37].f32[0] = v15;
      if (v15 >= 0.001)
      {
        float v17 = this[37].f32[1];
        if ((float)(v17 - v15) >= 0.001)
        {
          float v18 = log10f(this[37].f32[2]);
          float v16 = v18 / log10f(v17 / v15);
        }
      }
      this[37].f32[3] = v16;
    }
    if (this[37].f32[1] != *((float *)&_X24 + 1))
    {
      float v19 = 0.0;
      if (*((float *)&_X24 + 1) < 0.0) {
        float v14 = 0.0;
      }
      this[37].f32[1] = v14;
      if (v15 >= 0.001 && (float)(v14 - v15) >= 0.001)
      {
        float v20 = log10f(this[37].f32[2]);
        float v19 = v20 / log10f(v14 / v15);
      }
      this[37].f32[3] = v19;
    }
    float v21 = __exp10f(0.0 * -0.05);
    if (this[37].f32[2] != v21)
    {
      if (v21 < 0.000001) {
        float v21 = 0.000001;
      }
      this[37].f32[2] = v21;
      float v22 = this[37].f32[0];
      float v23 = 0.0;
      if (v22 >= 0.001)
      {
        float v24 = this[37].f32[1];
        if ((float)(v24 - v22) >= 0.001)
        {
          float v25 = log10f(v21);
          float v23 = v25 / log10f(v24 / v22);
        }
      }
      this[37].f32[3] = v23;
    }
    unsigned int v26 = atomic_load((unsigned int *)(this[29].i64[1] + 2528));
    this[36].i32[3] = v26;
    atomic_store(1u, &this[67].u8[8]);
  }
  if (!*(unsigned char *)(this[29].i64[1] + 2608))
  {
    unsigned int v27 = atomic_load((unsigned int *)&this[26]);
    if (v27 != this[25].i32[3])
    {
      if (this[26].f32[2] == 0.0)
      {
        unsigned int v28 = atomic_load((unsigned int *)&this[26]);
        atomic_store(v28, &this[25].u32[2]);
      }
      if (AUSM::SoundStage::incrementSoundStageVerticesAndGains((AUSM::SoundStage *)this, a2))
      {
        atomic_store(1u, &this[67].u8[8]);
        ++this[68].i32[3];
      }
    }
  }
  unsigned __int8 v29 = atomic_load(&this[67].u8[8]);
  if ((v29 & 1) != 0 || a3)
  {
    _X0 = 0;
    _X1 = 0;
    atomic_store(0, &this[67].u8[8]);
    __dmb(0xBu);
    __asm { CASPAL          X0, X1, X0, X1, [X8] }
    float32x4_t v33 = (float32x4_t)vdupq_lane_s32(_X0, 1);
    v33.i32[1] = _X0.i32[0];
    v33.i32[2] = vnegq_f32((float32x4_t)*(unint64_t *)&_X0).i32[2];
    float32x4_t v34 = vmulq_f32(v33, v33);
    float v35 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v34, 2), vaddq_f32(v34, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v34.f32, 1))).f32[0]);
    if (v35 <= 0.0001)
    {
      v38.i64[0] = 0;
      v38.i32[2] = 0;
      float v39 = 1.0;
    }
    else
    {
      float32x4_t v36 = vmulq_f32(v33, (float32x4_t)xmmword_1BB879DF0);
      float v37 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v36, 2), vaddq_f32(v36, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 1))).f32[0];
      if ((float)((float)(v37 / v35) + 1.0) >= 0.0001)
      {
        int32x4_t v40 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v33, (int32x4_t)v33), (int8x16_t)v33, 0xCuLL), (float32x4_t)xmmword_1BB879E10), (float32x4_t)xmmword_1BB873F80, v33);
        float32x4_t v38 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v40, v40), (int8x16_t)v40, 0xCuLL);
        float v39 = v37 + v35;
      }
      else
      {
        float32x4_t v38 = (float32x4_t)xmmword_1BB879E00;
        float v39 = 0.0;
      }
    }
    v38.f32[3] = v39;
    int8x16_t v41 = (int8x16_t)vmulq_f32(v38, v38);
    float32x2_t v42 = vadd_f32(*(float32x2_t *)v41.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v41, v41, 8uLL));
    if (vaddv_f32(v42) == 0.0)
    {
      float32x4_t v43 = (float32x4_t)xmmword_1BB875840;
    }
    else
    {
      unsigned __int32 v44 = vadd_f32(v42, (float32x2_t)vdup_lane_s32((int32x2_t)v42, 1)).u32[0];
      float32x2_t v45 = vrsqrte_f32((float32x2_t)v44);
      float32x2_t v46 = vmul_f32(v45, vrsqrts_f32((float32x2_t)v44, vmul_f32(v45, v45)));
      float32x4_t v43 = vmulq_n_f32(v38, vmul_f32(v46, vrsqrts_f32((float32x2_t)v44, vmul_f32(v46, v46))).f32[0]);
    }
    this[31] = v43;
    this[32].f32[0] = v35;
    if (!*(unsigned char *)(this[29].i64[1] + 2608))
    {
      unsigned int v47 = atomic_load(&this[25].u32[2]);
      if (v47 || this[25].i32[3]) {
        float v35 = (float)(1.0 - this[27].f32[1]) + (float)(this[27].f32[1] * this[32].f32[0]);
      }
      else {
        float v35 = this[32].f32[0];
      }
    }
    this[32].f32[1] = v35;
    this[32].f32[2] = AUSM::DistanceGain::calculateDistanceGain((AUSM::DistanceGain *)&this[36].i32[1], v35);
    ++this[68].i32[0];
  }
  unsigned __int8 v48 = atomic_load(&this[67].u8[10]);
  if ((v48 & 1) != 0 || a3)
  {
    _X0 = 0;
    _X1 = 0;
    atomic_store(0, &this[67].u8[10]);
    __dmb(0xBu);
    __asm { CASPAL          X0, X1, X0, X1, [X8] }
    int32x4_t v52 = vdupq_lane_s32(_X0, 1);
    v52.i32[1] = _X0.i32[0];
    v52.i32[2] = vnegq_f32((float32x4_t)*(unint64_t *)&_X0).i32[2];
    this[33] = (float32x4_t)v52;
    float v53 = COERCE_FLOAT(atomic_load((unsigned int *)(this[29].i64[1] + 168)));
    if (v53 >= 0.0)
    {
      float32x4_t v54 = this[33];
      float32x4_t v55 = vmulq_f32(v54, v54);
      float v56 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v55, 2), vaddq_f32(v55, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v55.f32, 1))).f32[0]);
      if (v56 > 0.0 && (float)(v53 / v56) < 1.0) {
        this[33] = vmulq_n_f32(v54, v53 / v56);
      }
    }
    ++this[68].i32[1];
  }
  unsigned __int8 v57 = atomic_load(&this[67].u8[9]);
  if ((v57 & 1) != 0 || a3)
  {
    _X0 = 0;
    atomic_store(0, &this[67].u8[9]);
    __dmb(0xBu);
    _X3 = 0;
    __asm
    {
      CASPAL          X2, X3, X0, X1, [X8]
      CASPAL          X0, X1, X0, X1, [X8]
    }
    int32x4_t v62 = (int32x4_t)vnegq_f32((float32x4_t)_X0);
    int8x16_t v63 = (int8x16_t)vtrn2q_s32((int32x4_t)_X0, vtrn1q_s32((int32x4_t)_X0, v62));
    float32x4_t v64 = vmlaq_n_f32(vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)_X0, (int8x16_t)v62, 8uLL), _X2, 1), (float32x4_t)vextq_s8(v63, v63, 8uLL), _X2.f32[0]);
    float32x4_t v65 = (float32x4_t)vrev64q_s32((int32x4_t)_X0);
    v65.i32[0] = v62.i32[1];
    v65.i32[3] = v62.i32[2];
    float32x4_t v66 = vaddq_f32(vmlaq_laneq_f32(vmulq_laneq_f32((float32x4_t)_X0, (float32x4_t)(unint64_t)_X2, 3), v65, (float32x4_t)(unint64_t)_X2, 2), v64);
    int8x16_t v67 = (int8x16_t)vmulq_f32(v66, v66);
    float32x2_t v68 = vadd_f32(*(float32x2_t *)v67.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v67, v67, 8uLL));
    if (vaddv_f32(v68) == 0.0)
    {
      float32x4_t v69 = (float32x4_t)xmmword_1BB875840;
    }
    else
    {
      unsigned __int32 v70 = vadd_f32(v68, (float32x2_t)vdup_lane_s32((int32x2_t)v68, 1)).u32[0];
      float32x2_t v71 = vrsqrte_f32((float32x2_t)v70);
      float32x2_t v72 = vmul_f32(v71, vrsqrts_f32((float32x2_t)v70, vmul_f32(v71, v71)));
      float32x4_t v69 = vmulq_n_f32(v66, vmul_f32(v72, vrsqrts_f32((float32x2_t)v70, vmul_f32(v72, v72))).f32[0]);
    }
    float32x4_t v73 = vmulq_f32(v69, (float32x4_t)xmmword_1BB879E20);
    int8x16_t v74 = (int8x16_t)vmulq_f32(v69, v69);
    *(float32x2_t *)v74.i8 = vadd_f32(*(float32x2_t *)v74.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v74, v74, 8uLL));
    v74.i32[0] = vadd_f32(*(float32x2_t *)v74.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v74.i8, 1)).u32[0];
    float32x2_t v75 = vrecpe_f32((float32x2_t)v74.u32[0]);
    float32x2_t v76 = vmul_f32(v75, vrecps_f32((float32x2_t)v74.u32[0], v75));
    this[34] = vmulq_n_f32(v73, vmul_f32(v76, vrecps_f32((float32x2_t)v74.u32[0], v76)).f32[0]);
    ++this[68].i32[2];
  }
  unsigned __int8 v77 = atomic_load(&this[67].u8[11]);
  if ((v77 & 1) != 0 || a3)
  {
    atomic_store(0, &this[67].u8[11]);
    __dmb(0xBu);
    unsigned int v78 = atomic_load((unsigned int *)(this[29].i64[1] + 96));
    if (v78 - 5 <= 0xFFFFFFFB)
    {
      unsigned int v78 = this[35].u32[3];
      int v79 = v78 == 3 ? 4 : 2;
      if (this[36].i8[0]) {
        unsigned int v78 = v79;
      }
    }
    if (v78 == 4)
    {
      unsigned int v78 = 3;
    }
    else
    {
      if (v78 != 2)
      {
        int v82 = 0;
        int v81 = 0;
        goto LABEL_74;
      }
      unsigned int v78 = 1;
    }
    unsigned __int8 v80 = atomic_load((unsigned __int8 *)(this[29].i64[1] + 2572));
    int v81 = v80 & 1;
    int v82 = 1;
LABEL_74:
    if (v78 != this[35].i32[3] || this[36].u8[0] != v82 || this[36].u8[1] != v81)
    {
      this[36].i8[0] = v82;
      this[36].i8[1] = v81;
      this[35].i32[3] = v78;
      ++this[69].i32[0];
    }
  }
  unsigned __int8 v83 = atomic_load(&this[67].u8[13]);
  if ((v83 & 1) != 0 || a3)
  {
    atomic_store(0, &this[67].u8[13]);
    __dmb(0xBu);
    if (AUSM::SoundStage::incrementSoundStageVerticesAndGains((AUSM::SoundStage *)&this[38], 1u)) {
      this[69].i8[4] = 1;
    }
    else {
      atomic_store(1u, &this[67].u8[13]);
    }
    float v84 = COERCE_FLOAT(atomic_load((unsigned int *)(this[29].i64[1] + 1336)));
    this[35].f32[1] = __exp10f(v84 / 20.0);
    float v85 = COERCE_FLOAT(atomic_load((unsigned int *)(this[29].i64[1] + 1340)));
    this[35].f32[2] = __exp10f(v85 / 20.0);
    ++this[68].i32[3];
  }
}

void AUSM::GlobalGeometry::getTuningParameters(AUSM::GlobalGeometry *this, uint64_t a2)
{
  uint64_t v3 = a2 + 608;
  AUSM::SoundStage::getSoundStageParametersDictionary((AUSM::SoundStage *)&cf, a2 + 608, 3);
  CFTypeRef v4 = cf;
  if (cf)
  {
    LODWORD(v6) = 1;
  }
  else
  {
    AUSM::SoundStage::getSoundStageParametersDictionary((AUSM::SoundStage *)&v6, v3, 4);
    CFTypeRef v4 = v6;
    CFTypeRef v5 = cf;
    CFTypeRef v6 = cf;
    CFTypeRef cf = v4;
    if (v6)
    {
      CFRelease(v5);
      CFTypeRef v4 = cf;
    }
    LODWORD(v6) = 0;
  }
  std::pair<applesauce::CF::ArrayRef,AUSM::GlobalGeometry::DataType>::pair[abi:ne180100]<applesauce::CF::ArrayRef&,AUSM::GlobalGeometry::DataType,0>((uint64_t)this, v4, &v6);
  if (cf) {
    CFRelease(cf);
  }
}

void sub_1BB393720(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::ArrayRef::~ArrayRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::pair<applesauce::CF::ArrayRef,AUSM::GlobalGeometry::DataType>::pair[abi:ne180100]<applesauce::CF::ArrayRef&,AUSM::GlobalGeometry::DataType,0>(uint64_t a1, CFTypeRef cf, _DWORD *a3)
{
  if (cf) {
    CFRetain(cf);
  }
  *(void *)a1 = cf;
  *(_DWORD *)(a1 + 8) = *a3;
  return a1;
}

void VoiceProcessorV2::SetupUplinkBasicAUChainForHwHasVP(VoiceProcessorV2 *this)
{
  CFTypeRef v5 = (char *)this + 4664;
  int v6 = 0;
  std::__fill_n[abi:ne180100]<false,std::__bitset<2ul,72ul>>((uint64_t)&v5);
  *((void *)this + 583) |= 0x8000000000000000;
  uint64_t v2 = *((void *)this + 584);
  *((void *)this + 584) = v2 | 0x20;
  if (*((unsigned char *)this + 16688) && !*((unsigned char *)this + 2246))
  {
    uint64_t v4 = v2 | 0xA0;
    goto LABEL_9;
  }
  ChatFlavor = (VoiceProcessorV2 *)VoiceProcessorV2::GetChatFlavor(this);
  if (ChatFlavor == 2 && (*((unsigned char *)this + 16608) & 4) != 0)
  {
    *((void *)this + 583) |= 0x1000000000000000uLL;
    if (*((unsigned char *)this + 2246))
    {
      if (VoiceProcessorV2::IsDeviceSupportingAdvancedChatFlavors(ChatFlavor))
      {
        uint64_t v4 = *((void *)this + 584) | 8;
LABEL_9:
        *((void *)this + 584) = v4;
      }
    }
  }
}

void VoiceProcessorV2::SetupUplinkDNNVADGraph(VoiceProcessorV2 *this)
{
  v57[20] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (char *)this + 15961;
  if ((_os_feature_enabled_impl() & 1) != 0 || *((unsigned char *)this + 2244) || v2[663])
  {
    *((void *)this + 583) &= ~0x4000000000000000uLL;
    uint64_t v3 = (char *)this + 8;
    uint64_t v4 = (char *)this + 8;
    if (*((char *)this + 31) < 0) {
      uint64_t v4 = *(char **)v3;
    }
    __p[0].__pn_.__r_.__value_.__r.__words[0] = (std::string::size_type)v4;
    std::__fs::filesystem::path::path[abi:ne180100]<char const*,void>(&v55.__pn_, &__p[0].__pn_.__r_.__value_.__l.__data_);
    std::__fs::filesystem::path::append[abi:ne180100]<char [8]>(&v55.__pn_, "Generic");
    VoiceProcessorV2::GetVersionNameForTuning(&__p[0].__pn_, (uint64_t)this);
    std::__fs::filesystem::path::append[abi:ne180100]<std::string>(&v55.__pn_, (uint64_t)__p);
    if (SHIBYTE(__p[0].__pn_.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__pn_.__r_.__value_.__l.__data_);
    }
    if (std::__fs::filesystem::path::__filename(&v55).__size_) {
      std::string::push_back(&v55.__pn_, 47);
    }
    std::string::append[abi:ne180100]<char const*,0>(&v55.__pn_, "nnvad.dspg", "");
    std::__fs::filesystem::__status(&v55, 0);
    if (v53 && v53 != 255)
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      double v10 = (void *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(4, VPLogScope(void)::scope, 0))
      {
        float v11 = (*v10 ? *v10 : MEMORY[0x1E4F14500]);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
        {
          float v12 = &v55;
          if ((v55.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            float v12 = (std::__fs::filesystem::path *)v55.__pn_.__r_.__value_.__r.__words[0];
          }
          LODWORD(__p[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
          *(std::string::size_type *)((char *)__p[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
          WORD2(__p[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
          *(_DWORD *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 51;
          WORD1(__p[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
          *(std::string::size_type *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v12;
          _os_log_impl(&dword_1BB0CE000, v11, OS_LOG_TYPE_INFO, "%25s:%-5d  <vp> loading DNN VAD graph \"%s\"", (uint8_t *)__p, 0x1Cu);
        }
      }
      float v13 = (int *)*((void *)this + 1578);
      if (v13 && (*v2 || v2[1]))
      {
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        float v14 = &v55;
        if ((v55.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          float v14 = (std::__fs::filesystem::path *)v55.__pn_.__r_.__value_.__r.__words[0];
        }
        CALegacyLog::log(v13, 4, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 51, "SetupUplinkDNNVADGraph", "loading DNN VAD graph \"%s\"", (const char *)v14);
      }
      std::ifstream::basic_ifstream((uint64_t *)__p);
      std::string::__init_with_sentinel[abi:ne180100]<std::istreambuf_iterator<char>,std::istreambuf_iterator<char>>(&__replacement.__pn_, *(void **)((char *)&__p[1].__pn_.__r_.__value_.__r.__words[2]+ *(void *)(__p[0].__pn_.__r_.__value_.__r.__words[0] - 24)));
      if ((__replacement.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_replacement = &__replacement;
      }
      else {
        p_replacement = (std::__fs::filesystem::path *)__replacement.__pn_.__r_.__value_.__r.__words[0];
      }
      if (p_replacement)
      {
        if ((__replacement.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          CFIndex size = HIBYTE(__replacement.__pn_.__r_.__value_.__r.__words[2]);
        }
        else {
          CFIndex size = __replacement.__pn_.__r_.__value_.__l.__size_;
        }
        CFStringRef v17 = CFStringCreateWithBytes(0, (const UInt8 *)p_replacement, size, 0x8000100u, 0);
        if (!v17)
        {
          exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "Could not construct");
        }
      }
      else
      {
        CFStringRef v17 = 0;
      }
      float v19 = (const void *)*((void *)this + 2065);
      *((void *)this + 2065) = v17;
      if (v19) {
        CFRelease(v19);
      }
      if (SHIBYTE(__replacement.__pn_.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__replacement.__pn_.__r_.__value_.__l.__data_);
      }
      __p[0].__pn_.__r_.__value_.__r.__words[0] = *MEMORY[0x1E4FBA3F8];
      *(std::string::size_type *)((char *)__p[0].__pn_.__r_.__value_.__r.__words
                                + *(void *)(__p[0].__pn_.__r_.__value_.__r.__words[0] - 24)) = *(void *)(MEMORY[0x1E4FBA3F8] + 24);
      MEMORY[0x1C185CC40](&__p[0].__pn_.__r_.__value_.__r.__words[2]);
      std::istream::~istream();
      MEMORY[0x1C185D210](v57);
    }
    else
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      CFTypeRef v5 = (void *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
      {
        int v6 = (*v5 ? *v5 : MEMORY[0x1E4F14500]);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        {
          char v7 = &v55;
          if ((v55.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            char v7 = (std::__fs::filesystem::path *)v55.__pn_.__r_.__value_.__r.__words[0];
          }
          LODWORD(__p[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
          *(std::string::size_type *)((char *)__p[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
          WORD2(__p[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
          *(_DWORD *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 56;
          WORD1(__p[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
          *(std::string::size_type *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v7;
          _os_log_impl(&dword_1BB0CE000, v6, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> file \"%s\" does not exist", (uint8_t *)__p, 0x1Cu);
        }
      }
      uint64_t v8 = (int *)*((void *)this + 1578);
      if (v8 && (*v2 || v2[1]))
      {
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        uint64_t v9 = &v55;
        if ((v55.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          uint64_t v9 = (std::__fs::filesystem::path *)v55.__pn_.__r_.__value_.__r.__words[0];
        }
        CALegacyLog::log(v8, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 56, "SetupUplinkDNNVADGraph", "file \"%s\" does not exist", (const char *)v9);
      }
    }
    if (SHIBYTE(v55.__pn_.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v55.__pn_.__r_.__value_.__l.__data_);
    }
    VoiceProcessorV2::GetDNNVADAUStripFilePath(&v55.__pn_, (uint64_t)this);
    std::__fs::filesystem::path::filename[abi:ne180100](&v55, (uint64_t)__p);
    memset(&__replacement, 0, sizeof(__replacement));
    float v20 = std::__fs::filesystem::path::replace_extension(__p, &__replacement);
    if (SHIBYTE(v20->__pn_.__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::__init_copy_ctor_external(&v52, v20->__pn_.__r_.__value_.__l.__data_, v20->__pn_.__r_.__value_.__l.__size_);
    }
    else
    {
      long long v21 = *(_OWORD *)&v20->__pn_.__r_.__value_.__l.__data_;
      v52.__r_.__value_.__r.__words[2] = v20->__pn_.__r_.__value_.__r.__words[2];
      *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v21;
    }
    if (SHIBYTE(__replacement.__pn_.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__replacement.__pn_.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(__p[0].__pn_.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__pn_.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v55.__pn_.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v55.__pn_.__r_.__value_.__l.__data_);
    }
    if ((v52.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      float v22 = &v52;
    }
    else {
      float v22 = (std::string *)v52.__r_.__value_.__r.__words[0];
    }
    if (v22)
    {
      if ((v52.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        CFIndex v23 = HIBYTE(v52.__r_.__value_.__r.__words[2]);
      }
      else {
        CFIndex v23 = v52.__r_.__value_.__l.__size_;
      }
      CFStringRef v24 = CFStringCreateWithBytes(0, (const UInt8 *)v22, v23, 0x8000100u, 0);
      if (!v24)
      {
        float v25 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v25, "Could not construct");
      }
    }
    else
    {
      CFStringRef v24 = 0;
    }
    unsigned int v26 = (const void *)*((void *)this + 2066);
    *((void *)this + 2066) = v24;
    if (v26) {
      CFRelease(v26);
    }
    if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v52.__r_.__value_.__l.__data_);
    }
    VoiceProcessorV2::GetDNNVADAUStripFilePath(&v55.__pn_, (uint64_t)this);
    std::__fs::filesystem::__status(&v55, 0);
    if (v52.__r_.__value_.__s.__data_[0] && v52.__r_.__value_.__s.__data_[0] != 255)
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      double v32 = (void *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(4, VPLogScope(void)::scope, 0))
      {
        float32x4_t v33 = (*v32 ? *v32 : MEMORY[0x1E4F14500]);
        if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
        {
          float32x4_t v34 = &v55;
          if ((v55.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            float32x4_t v34 = (std::__fs::filesystem::path *)v55.__pn_.__r_.__value_.__r.__words[0];
          }
          LODWORD(__p[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
          *(std::string::size_type *)((char *)__p[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
          WORD2(__p[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
          *(_DWORD *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 74;
          WORD1(__p[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
          *(std::string::size_type *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v34;
          _os_log_impl(&dword_1BB0CE000, v33, OS_LOG_TYPE_INFO, "%25s:%-5d  <vp> loading DNN VAD AU strip \"%s\"", (uint8_t *)__p, 0x1Cu);
        }
      }
      float v35 = (int *)*((void *)this + 1578);
      if (v35 && (*v2 || v2[1]))
      {
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        float32x4_t v36 = &v55;
        if ((v55.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          float32x4_t v36 = (std::__fs::filesystem::path *)v55.__pn_.__r_.__value_.__r.__words[0];
        }
        CALegacyLog::log(v35, 4, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 74, "SetupUplinkDNNVADGraph", "loading DNN VAD AU strip \"%s\"", (const char *)v36);
      }
      if (SHIBYTE(v55.__pn_.__r_.__value_.__r.__words[2]) < 0) {
        std::string::__init_copy_ctor_external(&__p[0].__pn_, v55.__pn_.__r_.__value_.__l.__data_, v55.__pn_.__r_.__value_.__l.__size_);
      }
      else {
        __p[0] = v55;
      }
      applesauce::CF::make_DataRef((const char *)__p, (CFDataRef *)&__replacement);
      if (SHIBYTE(__p[0].__pn_.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p[0].__pn_.__r_.__value_.__l.__data_);
      }
      applesauce::CF::make_DictionaryRef((CFDataRef *)&__replacement, (applesauce::CF::DictionaryRef *)__p);
      float v37 = (const void *)*((void *)this + 2067);
      *((void *)this + 2067) = __p[0].__pn_.__r_.__value_.__r.__words[0];
      __p[0].__pn_.__r_.__value_.__r.__words[0] = (std::string::size_type)v37;
      if (v37) {
        CFRelease(v37);
      }
      if (__replacement.__pn_.__r_.__value_.__r.__words[0]) {
        CFRelease(__replacement.__pn_.__r_.__value_.__l.__data_);
      }
    }
    else
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      unsigned int v27 = (void *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
      {
        unsigned int v28 = (*v27 ? *v27 : MEMORY[0x1E4F14500]);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        {
          unsigned __int8 v29 = &v55;
          if ((v55.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            unsigned __int8 v29 = (std::__fs::filesystem::path *)v55.__pn_.__r_.__value_.__r.__words[0];
          }
          LODWORD(__p[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
          *(std::string::size_type *)((char *)__p[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
          WORD2(__p[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
          *(_DWORD *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 79;
          WORD1(__p[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
          *(std::string::size_type *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v29;
          _os_log_impl(&dword_1BB0CE000, v28, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> file \"%s\" does not exist", (uint8_t *)__p, 0x1Cu);
        }
      }
      unint64_t v30 = (int *)*((void *)this + 1578);
      if (v30 && (*v2 || v2[1]))
      {
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        double v31 = &v55;
        if ((v55.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          double v31 = (std::__fs::filesystem::path *)v55.__pn_.__r_.__value_.__r.__words[0];
        }
        CALegacyLog::log(v30, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 79, "SetupUplinkDNNVADGraph", "file \"%s\" does not exist", (const char *)v31);
      }
    }
    if (SHIBYTE(v55.__pn_.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v55.__pn_.__r_.__value_.__l.__data_);
    }
    if (*((char *)this + 31) < 0) {
      uint64_t v3 = *(char **)v3;
    }
    __p[0].__pn_.__r_.__value_.__r.__words[0] = (std::string::size_type)v3;
    std::__fs::filesystem::path::path[abi:ne180100]<char const*,void>(&v55.__pn_, &__p[0].__pn_.__r_.__value_.__l.__data_);
    std::__fs::filesystem::path::append[abi:ne180100]<char [8]>(&v55.__pn_, "Generic");
    VoiceProcessorV2::GetVersionNameForTuning(&__p[0].__pn_, (uint64_t)this);
    std::__fs::filesystem::path::append[abi:ne180100]<std::string>(&v55.__pn_, (uint64_t)__p);
    if (SHIBYTE(__p[0].__pn_.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__pn_.__r_.__value_.__l.__data_);
    }
    if (std::__fs::filesystem::path::__filename(&v55).__size_) {
      std::string::push_back(&v55.__pn_, 47);
    }
    std::string::append[abi:ne180100]<char const*,0>(&v55.__pn_, "nnvad.propstrip", "");
    std::__fs::filesystem::__status(&v55, 0);
    if (__replacement.__pn_.__r_.__value_.__s.__data_[0]
      && __replacement.__pn_.__r_.__value_.__s.__data_[0] != 255)
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      float32x4_t v43 = (void *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(4, VPLogScope(void)::scope, 0))
      {
        unsigned __int32 v44 = (*v43 ? *v43 : MEMORY[0x1E4F14500]);
        if (os_log_type_enabled(v44, OS_LOG_TYPE_INFO))
        {
          float32x2_t v45 = &v55;
          if ((v55.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            float32x2_t v45 = (std::__fs::filesystem::path *)v55.__pn_.__r_.__value_.__r.__words[0];
          }
          LODWORD(__p[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
          *(std::string::size_type *)((char *)__p[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
          WORD2(__p[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
          *(_DWORD *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 89;
          WORD1(__p[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
          *(std::string::size_type *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v45;
          _os_log_impl(&dword_1BB0CE000, v44, OS_LOG_TYPE_INFO, "%25s:%-5d  <vp> loading DNN VAD property strip \"%s\"", (uint8_t *)__p, 0x1Cu);
        }
      }
      float32x2_t v46 = (int *)*((void *)this + 1578);
      if (v46 && (*v2 || v2[1]))
      {
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        unsigned int v47 = &v55;
        if ((v55.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          unsigned int v47 = (std::__fs::filesystem::path *)v55.__pn_.__r_.__value_.__r.__words[0];
        }
        CALegacyLog::log(v46, 4, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 89, "SetupUplinkDNNVADGraph", "loading DNN VAD property strip \"%s\"", (const char *)v47);
      }
      if (SHIBYTE(v55.__pn_.__r_.__value_.__r.__words[2]) < 0) {
        std::string::__init_copy_ctor_external(&__p[0].__pn_, v55.__pn_.__r_.__value_.__l.__data_, v55.__pn_.__r_.__value_.__l.__size_);
      }
      else {
        __p[0] = v55;
      }
      applesauce::CF::make_DataRef((const char *)__p, (CFDataRef *)&__replacement);
      if (SHIBYTE(__p[0].__pn_.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p[0].__pn_.__r_.__value_.__l.__data_);
      }
      applesauce::CF::make_DictionaryRef((CFDataRef *)&__replacement, (applesauce::CF::DictionaryRef *)__p);
      unsigned __int8 v48 = (const void *)*((void *)this + 2068);
      *((void *)this + 2068) = __p[0].__pn_.__r_.__value_.__r.__words[0];
      __p[0].__pn_.__r_.__value_.__r.__words[0] = (std::string::size_type)v48;
      if (v48) {
        CFRelease(v48);
      }
      if (__replacement.__pn_.__r_.__value_.__r.__words[0]) {
        CFRelease(__replacement.__pn_.__r_.__value_.__l.__data_);
      }
    }
    else
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      float32x4_t v38 = (void *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
      {
        float v39 = (*v38 ? *v38 : MEMORY[0x1E4F14500]);
        if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
        {
          int32x4_t v40 = &v55;
          if ((v55.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            int32x4_t v40 = (std::__fs::filesystem::path *)v55.__pn_.__r_.__value_.__r.__words[0];
          }
          LODWORD(__p[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
          *(std::string::size_type *)((char *)__p[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
          WORD2(__p[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
          *(_DWORD *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 94;
          WORD1(__p[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
          *(std::string::size_type *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v40;
          _os_log_impl(&dword_1BB0CE000, v39, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> file \"%s\" does not exist", (uint8_t *)__p, 0x1Cu);
        }
      }
      int8x16_t v41 = (int *)*((void *)this + 1578);
      if (v41 && (*v2 || v2[1]))
      {
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        float32x2_t v42 = &v55;
        if ((v55.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          float32x2_t v42 = (std::__fs::filesystem::path *)v55.__pn_.__r_.__value_.__r.__words[0];
        }
        CALegacyLog::log(v41, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 94, "SetupUplinkDNNVADGraph", "file \"%s\" does not exist", (const char *)v42);
      }
    }
    if (SHIBYTE(v55.__pn_.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v55.__pn_.__r_.__value_.__l.__data_);
    }
    if (*((void *)this + 2065) && *((void *)this + 2066) && *((void *)this + 2067) && *((void *)this + 2068))
    {
      *((void *)this + 583) |= 0x4000000000000000uLL;
    }
    else
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      uint64_t v49 = (void *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
      {
        double v50 = (*v49 ? *v49 : MEMORY[0x1E4F14500]);
        if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
        {
          LODWORD(__p[0].__pn_.__r_.__value_.__l.__data_) = 136315394;
          *(std::string::size_type *)((char *)__p[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
          WORD2(__p[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
          *(_DWORD *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 107;
          _os_log_impl(&dword_1BB0CE000, v50, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> Not able to enable DNNVAD", (uint8_t *)__p, 0x12u);
        }
      }
      unint64_t v51 = (int *)*((void *)this + 1578);
      if (v51 && (*v2 || v2[1]))
      {
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        CALegacyLog::log(v51, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 107, "SetupUplinkDNNVADGraph", "Not able to enable DNNVAD");
      }
    }
  }
}

#error "1BB3952DC: call analysis failed (funcsize=163)"

void std::string::__init_with_sentinel[abi:ne180100]<std::istreambuf_iterator<char>,std::istreambuf_iterator<char>>(std::string *this, void *a2)
{
  *(_OWORD *)&this->__r_.__value_.__l.__data_ = 0uLL;
  this->__r_.__value_.__r.__words[2] = 0;
  while (a2 && (a2[3] != a2[4] || (*(unsigned int (**)(void *))(*a2 + 72))(a2) != -1))
  {
    uint64_t v4 = (std::string::value_type *)a2[3];
    if (v4 == (std::string::value_type *)a2[4]) {
      std::string::value_type v5 = (*(uint64_t (**)(void *))(*a2 + 72))(a2);
    }
    else {
      std::string::value_type v5 = *v4;
    }
    std::string::push_back(this, v5);
    uint64_t v6 = a2[3];
    if (v6 == a2[4]) {
      (*(void (**)(void *))(*a2 + 80))(a2);
    }
    else {
      a2[3] = v6 + 1;
    }
  }
}

void sub_1BB395560(void *a1)
{
  __cxa_begin_catch(a1);
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  __cxa_rethrow();
}

void sub_1BB39557C(_Unwind_Exception *a1)
{
}

void *std::ifstream::~ifstream(void *a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA3F8];
  uint64_t v3 = *MEMORY[0x1E4FBA3F8];
  *a1 = *MEMORY[0x1E4FBA3F8];
  *(void *)((char *)a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  MEMORY[0x1C185CC40](a1 + 2);
  std::istream::~istream();
  MEMORY[0x1C185D210](a1 + 53);
  return a1;
}

void VoiceProcessorV2::SetupUplinkGMCoexMitigationGraph(VoiceProcessorV2 *this)
{
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = (_DWORD *)*((void *)this + 295);
  if (v1 != *((_DWORD **)this + 296) && *v1 == 1886216809 && _os_feature_enabled_impl())
  {
    *((void *)this + 583) &= ~0x40uLL;
    uint64_t v3 = (char *)this + 8;
    uint64_t v4 = (char *)this + 8;
    if (*((char *)this + 31) < 0) {
      uint64_t v4 = *(char **)v3;
    }
    *(void *)double v58 = v4;
    std::__fs::filesystem::path::path[abi:ne180100]<char const*,void>(&v57, (char **)v58);
    VoiceProcessorV2::GetHardwareModelNameForTuning(&__replacement.__pn_, (uint64_t)this, 0);
    std::__fs::filesystem::path __p = __replacement;
    memset(&__replacement, 0, sizeof(__replacement));
    std::__fs::filesystem::operator/[abi:ne180100](&__p, (uint64_t)&v57, (std::__fs::filesystem::path *)v58);
    if (SHIBYTE(__p.__pn_.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__pn_.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(__replacement.__pn_.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__replacement.__pn_.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v57.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v57.__r_.__value_.__l.__data_);
    }
    VoiceProcessorV2::GetVersionNameForTuning(&v57, (uint64_t)this);
    std::__fs::filesystem::path::append[abi:ne180100]<std::string>((std::string *)v58, (uint64_t)&v57);
    if (SHIBYTE(v57.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v57.__r_.__value_.__l.__data_);
    }
    if (std::__fs::filesystem::path::__filename((const std::__fs::filesystem::path *)v58).__size_) {
      std::string::push_back((std::string *)v58, 47);
    }
    std::string::append[abi:ne180100]<char const*,0>((std::string *)v58, "vp-gm-coexkill.dspg", "");
    std::string::value_type v5 = (char *)this + 15961;
    *(_OWORD *)uint64_t v60 = *(_OWORD *)v58;
    *(void *)&v60[16] = *(void *)&v58[16];
    v60[24] = 1;
    std::__fs::filesystem::__status((const std::__fs::filesystem::path *)v60, 0);
    if (v53 && v53 != 255)
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      float v11 = (void *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(4, VPLogScope(void)::scope, 0))
      {
        float v12 = (*v11 ? *v11 : MEMORY[0x1E4F14500]);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
        {
          if (!v60[24]) {
            std::__throw_bad_optional_access[abi:ne180100]();
          }
          float v13 = v60;
          if (v60[23] < 0) {
            float v13 = *(unsigned char **)v60;
          }
          *(_DWORD *)double v58 = 136315650;
          *(void *)&v58[4] = "vpSetupUplinkDSPChain.cpp";
          *(_WORD *)&v58[12] = 1024;
          *(_DWORD *)&v58[14] = 136;
          *(_WORD *)&v58[18] = 2080;
          *(void *)&v58[20] = v13;
          _os_log_impl(&dword_1BB0CE000, v12, OS_LOG_TYPE_INFO, "%25s:%-5d  <vp> loading GM Coex Mitigation graph \"%s\"", v58, 0x1Cu);
        }
      }
      float v14 = (int *)*((void *)this + 1578);
      if (v14 && (*v5 || *((unsigned char *)this + 15962)))
      {
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        if (!v60[24]) {
          std::__throw_bad_optional_access[abi:ne180100]();
        }
        float v15 = v60;
        if (v60[23] < 0) {
          float v15 = *(const char **)v60;
        }
        CALegacyLog::log(v14, 4, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 136, "SetupUplinkGMCoexMitigationGraph", "loading GM Coex Mitigation graph \"%s\"", v15);
      }
      if (!v60[24]) {
        std::__throw_bad_optional_access[abi:ne180100]();
      }
      std::ifstream::basic_ifstream((uint64_t *)v58);
      std::string::__init_with_sentinel[abi:ne180100]<std::istreambuf_iterator<char>,std::istreambuf_iterator<char>>(&v57, *(void **)&v58[*(void *)(*(void *)v58 - 24) + 40]);
      if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        float v16 = &v57;
      }
      else {
        float v16 = (std::string *)v57.__r_.__value_.__r.__words[0];
      }
      if (v16)
      {
        if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          CFIndex size = HIBYTE(v57.__r_.__value_.__r.__words[2]);
        }
        else {
          CFIndex size = v57.__r_.__value_.__l.__size_;
        }
        CFStringRef v18 = CFStringCreateWithBytes(0, (const UInt8 *)v16, size, 0x8000100u, 0);
        if (!v18)
        {
          exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "Could not construct");
        }
      }
      else
      {
        CFStringRef v18 = 0;
      }
      float v20 = (const void *)*((void *)this + 2098);
      *((void *)this + 2098) = v18;
      if (v20) {
        CFRelease(v20);
      }
      if (SHIBYTE(v57.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v57.__r_.__value_.__l.__data_);
      }
      *(void *)double v58 = *MEMORY[0x1E4FBA3F8];
      *(void *)&v58[*(void *)(*(void *)v58 - 24)] = *(void *)(MEMORY[0x1E4FBA3F8] + 24);
      MEMORY[0x1C185CC40](&v58[16]);
      std::istream::~istream();
      MEMORY[0x1C185D210](&v59);
    }
    else
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      uint64_t v6 = (void *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
      {
        char v7 = (*v6 ? *v6 : MEMORY[0x1E4F14500]);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v8 = v60;
          if (v60[23] < 0) {
            uint64_t v8 = *(unsigned char **)v60;
          }
          *(_DWORD *)double v58 = 136315650;
          *(void *)&v58[4] = "vpSetupUplinkDSPChain.cpp";
          *(_WORD *)&v58[12] = 1024;
          *(_DWORD *)&v58[14] = 143;
          *(_WORD *)&v58[18] = 2080;
          *(void *)&v58[20] = v8;
          _os_log_impl(&dword_1BB0CE000, v7, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp> %s file does not exist", v58, 0x1Cu);
        }
      }
      uint64_t v9 = (int *)*((void *)this + 1578);
      if (v9 && (*v5 || *((unsigned char *)this + 15962)))
      {
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        double v10 = v60;
        if (v60[23] < 0) {
          double v10 = *(const char **)v60;
        }
        CALegacyLog::log(v9, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 143, "SetupUplinkGMCoexMitigationGraph", "%s file does not exist", v10);
      }
    }
    if (v60[24] && (v60[23] & 0x80000000) != 0) {
      operator delete(*(void **)v60);
    }
    VoiceProcessorV2::GetGMCoexMitigationAUStripFilePath((VoiceProcessorV2 *)v58, (uint64_t)this);
    if (v58[24])
    {
      std::__fs::filesystem::path::filename[abi:ne180100]((const std::__fs::filesystem::path *)v58, (uint64_t)&__p);
      memset(&__replacement, 0, sizeof(__replacement));
      long long v21 = std::__fs::filesystem::path::replace_extension(&__p, &__replacement);
      if (SHIBYTE(v21->__pn_.__r_.__value_.__r.__words[2]) < 0)
      {
        std::string::__init_copy_ctor_external(&v57, v21->__pn_.__r_.__value_.__l.__data_, v21->__pn_.__r_.__value_.__l.__size_);
      }
      else
      {
        long long v22 = *(_OWORD *)&v21->__pn_.__r_.__value_.__l.__data_;
        v57.__r_.__value_.__r.__words[2] = v21->__pn_.__r_.__value_.__r.__words[2];
        *(_OWORD *)&v57.__r_.__value_.__l.__data_ = v22;
      }
      *(std::string *)uint64_t v60 = v57;
      memset(&v57, 0, sizeof(v57));
      v60[24] = 1;
      if (SHIBYTE(__replacement.__pn_.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__replacement.__pn_.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(__p.__pn_.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__pn_.__r_.__value_.__l.__data_);
      }
      if (v58[24] && (v58[23] & 0x80000000) != 0) {
        operator delete(*(void **)v58);
      }
    }
    else
    {
      v60[0] = 0;
      v60[24] = 0;
    }
    if (v60[24])
    {
      if (v60[23] >= 0) {
        CFIndex v23 = v60;
      }
      else {
        CFIndex v23 = *(const UInt8 **)v60;
      }
      if (v23)
      {
        if (v60[23] >= 0) {
          CFIndex v24 = v60[23];
        }
        else {
          CFIndex v24 = *(void *)&v60[8];
        }
        CFStringRef v25 = CFStringCreateWithBytes(0, v23, v24, 0x8000100u, 0);
        if (!v25)
        {
          unsigned int v26 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(v26, "Could not construct");
        }
      }
      else
      {
        CFStringRef v25 = 0;
      }
      unsigned int v27 = (const void *)*((void *)this + 2099);
      *((void *)this + 2099) = v25;
      if (v27) {
        CFRelease(v27);
      }
      if (v60[24] && (v60[23] & 0x80000000) != 0) {
        operator delete(*(void **)v60);
      }
    }
    VoiceProcessorV2::GetGMCoexMitigationAUStripFilePath((VoiceProcessorV2 *)v58, (uint64_t)this);
    if (v58[24])
    {
      std::__fs::filesystem::__status((const std::__fs::filesystem::path *)v58, 0);
      if (v54 && v54 != 255)
      {
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        float32x4_t v33 = (void *)VPLogScope(void)::scope;
        if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(4, VPLogScope(void)::scope, 0))
        {
          float32x4_t v34 = (*v33 ? *v33 : MEMORY[0x1E4F14500]);
          if (os_log_type_enabled(v34, OS_LOG_TYPE_INFO))
          {
            float v35 = v58;
            if (v58[23] < 0) {
              float v35 = *(unsigned char **)v58;
            }
            *(_DWORD *)uint64_t v60 = 136315650;
            *(void *)&v60[4] = "vpSetupUplinkDSPChain.cpp";
            *(_WORD *)&v60[12] = 1024;
            *(_DWORD *)&v60[14] = 169;
            *(_WORD *)&v60[18] = 2080;
            *(void *)&v60[20] = v35;
            _os_log_impl(&dword_1BB0CE000, v34, OS_LOG_TYPE_INFO, "%25s:%-5d  <vp> loading GM Coex Mitigation AU strip \"%s\"", v60, 0x1Cu);
          }
        }
        float32x4_t v36 = (int *)*((void *)this + 1578);
        if (v36 && (*v5 || *((unsigned char *)this + 15962)))
        {
          if (VPLogScope(void)::once != -1) {
            dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
          }
          float v37 = v58;
          if (v58[23] < 0) {
            float v37 = *(const char **)v58;
          }
          CALegacyLog::log(v36, 4, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 169, "SetupUplinkGMCoexMitigationGraph", "loading GM Coex Mitigation AU strip \"%s\"", v37);
        }
        if ((v58[23] & 0x80000000) != 0)
        {
          std::string::__init_copy_ctor_external((std::string *)v60, *(const std::string::value_type **)v58, *(std::string::size_type *)&v58[8]);
        }
        else
        {
          *(_OWORD *)uint64_t v60 = *(_OWORD *)v58;
          *(void *)&v60[16] = *(void *)&v58[16];
        }
        applesauce::CF::make_DataRef(v60, (CFDataRef *)&v57);
        if ((v60[23] & 0x80000000) != 0) {
          operator delete(*(void **)v60);
        }
        applesauce::CF::make_DictionaryRef((CFDataRef *)&v57, (applesauce::CF::DictionaryRef *)v60);
        float32x4_t v38 = (const void *)*((void *)this + 2100);
        *((void *)this + 2100) = *(void *)v60;
        *(void *)uint64_t v60 = v38;
        if (v38) {
          CFRelease(v38);
        }
        if (v57.__r_.__value_.__r.__words[0]) {
          CFRelease(v57.__r_.__value_.__l.__data_);
        }
      }
      else
      {
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        unsigned int v28 = (void *)VPLogScope(void)::scope;
        if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
        {
          unsigned __int8 v29 = (*v28 ? *v28 : MEMORY[0x1E4F14500]);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
          {
            unint64_t v30 = v58;
            if (v58[23] < 0) {
              unint64_t v30 = *(unsigned char **)v58;
            }
            *(_DWORD *)uint64_t v60 = 136315650;
            *(void *)&v60[4] = "vpSetupUplinkDSPChain.cpp";
            *(_WORD *)&v60[12] = 1024;
            *(_DWORD *)&v60[14] = 176;
            *(_WORD *)&v60[18] = 2080;
            *(void *)&v60[20] = v30;
            _os_log_impl(&dword_1BB0CE000, v29, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp> %s file does not exist", v60, 0x1Cu);
          }
        }
        double v31 = (int *)*((void *)this + 1578);
        if (v31 && (*v5 || *((unsigned char *)this + 15962)))
        {
          if (VPLogScope(void)::once != -1) {
            dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
          }
          double v32 = v58;
          if (v58[23] < 0) {
            double v32 = *(const char **)v58;
          }
          CALegacyLog::log(v31, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 176, "SetupUplinkGMCoexMitigationGraph", "%s file does not exist", v32);
        }
      }
      if (v58[24] && (v58[23] & 0x80000000) != 0) {
        operator delete(*(void **)v58);
      }
    }
    if (*((char *)this + 31) < 0) {
      uint64_t v3 = *(char **)v3;
    }
    *(void *)uint64_t v60 = v3;
    std::__fs::filesystem::path::path[abi:ne180100]<char const*,void>(&v57, (char **)v60);
    VoiceProcessorV2::GetHardwareModelNameForTuning(&__replacement.__pn_, (uint64_t)this, 0);
    std::__fs::filesystem::path __p = __replacement;
    memset(&__replacement, 0, sizeof(__replacement));
    std::__fs::filesystem::operator/[abi:ne180100](&__p, (uint64_t)&v57, (std::__fs::filesystem::path *)v60);
    if (SHIBYTE(__p.__pn_.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__pn_.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(__replacement.__pn_.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__replacement.__pn_.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v57.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v57.__r_.__value_.__l.__data_);
    }
    VoiceProcessorV2::GetVersionNameForTuning(&v57, (uint64_t)this);
    std::__fs::filesystem::path::append[abi:ne180100]<std::string>((std::string *)v60, (uint64_t)&v57);
    if (SHIBYTE(v57.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v57.__r_.__value_.__l.__data_);
    }
    if (std::__fs::filesystem::path::__filename((const std::__fs::filesystem::path *)v60).__size_) {
      std::string::push_back((std::string *)v60, 47);
    }
    std::string::append[abi:ne180100]<char const*,0>((std::string *)v60, "vp-gm-coexkill.propstrip", "");
    *(_OWORD *)double v58 = *(_OWORD *)v60;
    *(void *)&v58[16] = *(void *)&v60[16];
    v58[24] = 1;
    std::__fs::filesystem::__status((const std::__fs::filesystem::path *)v58, 0);
    if (v60[0] && v60[0] != 255)
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      unsigned __int32 v44 = (void *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(4, VPLogScope(void)::scope, 0))
      {
        float32x2_t v45 = (*v44 ? *v44 : MEMORY[0x1E4F14500]);
        if (os_log_type_enabled(v45, OS_LOG_TYPE_INFO))
        {
          float32x2_t v46 = v58;
          if (v58[23] < 0) {
            float32x2_t v46 = *(unsigned char **)v58;
          }
          *(_DWORD *)uint64_t v60 = 136315650;
          *(void *)&v60[4] = "vpSetupUplinkDSPChain.cpp";
          *(_WORD *)&v60[12] = 1024;
          *(_DWORD *)&v60[14] = 190;
          *(_WORD *)&v60[18] = 2080;
          *(void *)&v60[20] = v46;
          _os_log_impl(&dword_1BB0CE000, v45, OS_LOG_TYPE_INFO, "%25s:%-5d  <vp> loading GM Coex Mitigation property strip \"%s\"", v60, 0x1Cu);
        }
      }
      unsigned int v47 = (int *)*((void *)this + 1578);
      if (v47 && (*v5 || *((unsigned char *)this + 15962)))
      {
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        unsigned __int8 v48 = v58;
        if (v58[23] < 0) {
          unsigned __int8 v48 = *(const char **)v58;
        }
        CALegacyLog::log(v47, 4, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 190, "SetupUplinkGMCoexMitigationGraph", "loading GM Coex Mitigation property strip \"%s\"", v48);
      }
      if ((v58[23] & 0x80000000) != 0)
      {
        std::string::__init_copy_ctor_external((std::string *)v60, *(const std::string::value_type **)v58, *(std::string::size_type *)&v58[8]);
      }
      else
      {
        *(_OWORD *)uint64_t v60 = *(_OWORD *)v58;
        *(void *)&v60[16] = *(void *)&v58[16];
      }
      applesauce::CF::make_DataRef(v60, (CFDataRef *)&v57);
      if ((v60[23] & 0x80000000) != 0) {
        operator delete(*(void **)v60);
      }
      applesauce::CF::make_DictionaryRef((CFDataRef *)&v57, (applesauce::CF::DictionaryRef *)v60);
      uint64_t v49 = (const void *)*((void *)this + 2101);
      *((void *)this + 2101) = *(void *)v60;
      *(void *)uint64_t v60 = v49;
      if (v49) {
        CFRelease(v49);
      }
      if (v57.__r_.__value_.__r.__words[0]) {
        CFRelease(v57.__r_.__value_.__l.__data_);
      }
    }
    else
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      float v39 = (void *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
      {
        int32x4_t v40 = (*v39 ? *v39 : MEMORY[0x1E4F14500]);
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
        {
          int8x16_t v41 = v58;
          if (v58[23] < 0) {
            int8x16_t v41 = *(unsigned char **)v58;
          }
          *(_DWORD *)uint64_t v60 = 136315650;
          *(void *)&v60[4] = "vpSetupUplinkDSPChain.cpp";
          *(_WORD *)&v60[12] = 1024;
          *(_DWORD *)&v60[14] = 197;
          *(_WORD *)&v60[18] = 2080;
          *(void *)&v60[20] = v41;
          _os_log_impl(&dword_1BB0CE000, v40, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp> %s file does not exist", v60, 0x1Cu);
        }
      }
      float32x2_t v42 = (int *)*((void *)this + 1578);
      if (v42 && (*v5 || *((unsigned char *)this + 15962)))
      {
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        float32x4_t v43 = v58;
        if (v58[23] < 0) {
          float32x4_t v43 = *(const char **)v58;
        }
        CALegacyLog::log(v42, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 197, "SetupUplinkGMCoexMitigationGraph", "%s file does not exist", v43);
      }
    }
    if (v58[24] && (v58[23] & 0x80000000) != 0) {
      operator delete(*(void **)v58);
    }
    if (*((void *)this + 2098) && *((void *)this + 2099) && *((void *)this + 2100) && *((void *)this + 2101))
    {
      *((void *)this + 583) |= 0x40uLL;
    }
    else
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      double v50 = (void *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
      {
        unint64_t v51 = (*v50 ? *v50 : MEMORY[0x1E4F14500]);
        if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)double v58 = 136315394;
          *(void *)&v58[4] = "vpSetupUplinkDSPChain.cpp";
          *(_WORD *)&v58[12] = 1024;
          *(_DWORD *)&v58[14] = 214;
          _os_log_impl(&dword_1BB0CE000, v51, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp> Not able to enable GM Coex Mitigation graph", v58, 0x12u);
        }
      }
      std::string v52 = (int *)*((void *)this + 1578);
      if (v52 && (*v5 || v5[1]))
      {
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        CALegacyLog::log(v52, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 214, "SetupUplinkGMCoexMitigationGraph", "Not able to enable GM Coex Mitigation graph");
      }
    }
  }
}

#error "1BB3972B4: call analysis failed (funcsize=157)"

void VoiceProcessorV2::SetupReferenceSignalMixer(VoiceProcessorV2 *this)
{
  v22[4] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (char *)this + 15961;
  uint64_t v3 = (char *)this + 2000;
  std::__optional_destruct_base<vp::utility::Audio_Buffer_Mixer,false>::reset[abi:ne180100]((uint64_t)this + 2000);
  unsigned int v4 = *((_DWORD *)this + 153);
  if (v4)
  {
    unsigned int v5 = *((_DWORD *)this + 123);
    if (v5)
    {
      if (**((_DWORD **)this + 292) == 1886613611)
      {
        if (*((unsigned char *)this + 2244) || *((unsigned char *)this + 2245))
        {
          int v6 = *((_DWORD *)this + 18);
          if ((v6 - 22) < 8 || (v6 - 34) <= 2)
          {
            vp::utility::Audio_Buffer_Mixer::Audio_Buffer_Mixer((vp::utility::Audio_Buffer_Mixer *)buf, v4, *((_DWORD *)this + 153), v5);
            std::optional<vp::utility::Audio_Buffer_Mixer>::operator=[abi:ne180100]<vp::utility::Audio_Buffer_Mixer,void>((uint64_t)v3, (uint64_t)buf);
            CFStringRef v17 = (void **)v22;
            std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v17);
            CFStringRef v17 = (void **)((char *)v21 + 2);
            std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v17);
            (*(void (**)(VoiceProcessorV2 *, char *, char *))(*(void *)this + 472))(this, v3, (char *)this + 2072);
          }
        }
        else if ((*((_DWORD *)this + 18) - 26) <= 3)
        {
          vp::utility::Audio_Buffer_Mixer::Audio_Buffer_Mixer((vp::utility::Audio_Buffer_Mixer *)buf, v4, *((_DWORD *)this + 153), v5);
          unsigned int v13 = 0;
          char v14 = 1;
          do
          {
            char v15 = v14;
            vp::utility::Audio_Buffer_Mixer::set_gain((vp::utility::Audio_Buffer_Mixer *)buf, v13, 0, 1.0);
            char v14 = 0;
            unsigned int v13 = 1;
          }
          while ((v15 & 1) != 0);
          if (*((_DWORD *)this + 153) >= 2u)
          {
            unsigned int v16 = 1;
            do
            {
              vp::utility::Audio_Buffer_Mixer::set_gain((vp::utility::Audio_Buffer_Mixer *)buf, v16, v16, 1.0);
              ++v16;
            }
            while (v16 < *((_DWORD *)this + 153));
          }
          std::optional<vp::utility::Audio_Buffer_Mixer>::operator=[abi:ne180100]<vp::utility::Audio_Buffer_Mixer,void>((uint64_t)v3, (uint64_t)buf);
          vp::utility::Audio_Buffer_Mixer::~Audio_Buffer_Mixer((vp::utility::Audio_Buffer_Mixer *)buf);
        }
      }
      else if (*((_DWORD *)this + 596) == 1781740087 && v4 >= 6)
      {
        vp::utility::Audio_Buffer_Mixer::Audio_Buffer_Mixer((vp::utility::Audio_Buffer_Mixer *)buf, v4, *((_DWORD *)this + 153), v5);
        vp::utility::Audio_Buffer_Mixer::set_gain((vp::utility::Audio_Buffer_Mixer *)buf, 0, 0, 1.0);
        vp::utility::Audio_Buffer_Mixer::set_gain((vp::utility::Audio_Buffer_Mixer *)buf, 2u, 0, 1.0);
        vp::utility::Audio_Buffer_Mixer::set_gain((vp::utility::Audio_Buffer_Mixer *)buf, 3u, 0, 1.0);
        vp::utility::Audio_Buffer_Mixer::set_gain((vp::utility::Audio_Buffer_Mixer *)buf, 5u, 0, 1.0);
        vp::utility::Audio_Buffer_Mixer::set_gain((vp::utility::Audio_Buffer_Mixer *)buf, 0, 1u, 1.0);
        vp::utility::Audio_Buffer_Mixer::set_gain((vp::utility::Audio_Buffer_Mixer *)buf, 2u, 1u, 1.0);
        vp::utility::Audio_Buffer_Mixer::set_gain((vp::utility::Audio_Buffer_Mixer *)buf, 3u, 1u, -1.0);
        vp::utility::Audio_Buffer_Mixer::set_gain((vp::utility::Audio_Buffer_Mixer *)buf, 5u, 1u, -1.0);
        std::optional<vp::utility::Audio_Buffer_Mixer>::operator=[abi:ne180100]<vp::utility::Audio_Buffer_Mixer,void>((uint64_t)v3, (uint64_t)buf);
        CFStringRef v17 = (void **)v22;
        std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v17);
        CFStringRef v17 = (void **)((char *)v21 + 2);
        std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v17);
      }
    }
    else
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      double v10 = (void *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
      {
        float v11 = (*v10 ? *v10 : MEMORY[0x1E4F14500]);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          float v19 = "vpSetupUplinkDSPChain.cpp";
          __int16 v20 = 1024;
          v21[0] = 244;
          _os_log_impl(&dword_1BB0CE000, v11, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> skip reference mixer setup because reference block size is 0", buf, 0x12u);
        }
      }
      float v12 = (int *)*((void *)this + 1578);
      if (v12 && (*v2 || v2[1]))
      {
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        CALegacyLog::log(v12, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 244, "SetupReferenceSignalMixer", "skip reference mixer setup because reference block size is 0");
      }
    }
  }
  else
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    char v7 = (void *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
    {
      uint64_t v8 = (*v7 ? *v7 : MEMORY[0x1E4F14500]);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        float v19 = "vpSetupUplinkDSPChain.cpp";
        __int16 v20 = 1024;
        v21[0] = 237;
        _os_log_impl(&dword_1BB0CE000, v8, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> skip reference mixer setup because reference channel count is 0", buf, 0x12u);
      }
    }
    uint64_t v9 = (int *)*((void *)this + 1578);
    if (v9 && (*v2 || v2[1]))
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      CALegacyLog::log(v9, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 237, "SetupReferenceSignalMixer", "skip reference mixer setup because reference channel count is 0");
    }
  }
}

#error "1BB397AD0: call analysis failed (funcsize=153)"

void std::__optional_destruct_base<vp::utility::Audio_Buffer_Mixer,false>::reset[abi:ne180100](uint64_t a1)
{
  if (*(unsigned char *)(a1 + 64))
  {
    uint64_t v2 = (void **)(a1 + 40);
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v2);
    uint64_t v2 = (void **)(a1 + 16);
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v2);
    *(unsigned char *)(a1 + 64) = 0;
  }
}

uint64_t std::optional<vp::utility::Audio_Buffer_Mixer>::operator=[abi:ne180100]<vp::utility::Audio_Buffer_Mixer,void>(uint64_t a1, uint64_t a2)
{
  int v4 = *(unsigned __int8 *)(a1 + 64);
  int v5 = *(_DWORD *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(_DWORD *)(a1 + 8) = v5;
  int v6 = (uint64_t *)(a1 + 16);
  char v7 = (void *)(a2 + 16);
  uint64_t v8 = (void *)(a2 + 40);
  if (v4)
  {
    std::vector<std::vector<float>>::__vdeallocate(v6);
    *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
    *(void *)(a1 + 32) = *(void *)(a2 + 32);
    *char v7 = 0;
    v7[1] = 0;
    void v7[2] = 0;
    std::vector<std::vector<float>>::__vdeallocate((uint64_t *)(a1 + 40));
    *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *uint64_t v8 = 0;
    v8[1] = 0;
    void v8[2] = 0;
  }
  else
  {
    uint64_t *v6 = 0;
    v6[1] = 0;
    v6[2] = 0;
    *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
    *(void *)(a1 + 32) = *(void *)(a2 + 32);
    *char v7 = 0;
    *(void *)(a2 + 24) = 0;
    *(void *)(a2 + 32) = 0;
    *(void *)(a1 + 40) = 0;
    *(void *)(a1 + 48) = 0;
    *(void *)(a1 + 56) = 0;
    *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *uint64_t v8 = 0;
    *(void *)(a2 + 48) = 0;
    *(void *)(a2 + 56) = 0;
    *(unsigned char *)(a1 + 64) = 1;
  }
  return a1;
}

void vp::utility::Audio_Buffer_Mixer::~Audio_Buffer_Mixer(vp::utility::Audio_Buffer_Mixer *this)
{
  uint64_t v2 = (void **)((char *)this + 40);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v2);
  uint64_t v2 = (void **)((char *)this + 16);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v2);
}

void VoiceProcessorV2::SetupReferenceSignalMixer(void)::$_0::operator()(uint64_t a1)
{
  uint64_t v2 = a1 + 2000;
  std::__optional_destruct_base<vp::utility::Audio_Buffer_Mixer,false>::reset[abi:ne180100](a1 + 2000);
  vp::utility::Audio_Buffer_Mixer::Audio_Buffer_Mixer((vp::utility::Audio_Buffer_Mixer *)&v6, *(_DWORD *)(a1 + 612), *(_DWORD *)(a1 + 612), *(_DWORD *)(a1 + 492));
  unsigned int v3 = v6;
  if (v7 < v6) {
    unsigned int v3 = v7;
  }
  if (v3)
  {
    for (unsigned int i = 0; i < v5; ++i)
    {
      vp::utility::Audio_Buffer_Mixer::set_gain((vp::utility::Audio_Buffer_Mixer *)&v6, i, i, 1.0);
      unsigned int v5 = v6;
      if (v7 < v6) {
        unsigned int v5 = v7;
      }
    }
  }
  std::optional<vp::utility::Audio_Buffer_Mixer>::operator=[abi:ne180100]<vp::utility::Audio_Buffer_Mixer,void>(v2, (uint64_t)&v6);
  double v10 = (void **)&v9;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v10);
  double v10 = (void **)&v8;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v10);
}

void sub_1BB397E98(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  vp::utility::Audio_Buffer_Mixer::~Audio_Buffer_Mixer((vp::utility::Audio_Buffer_Mixer *)va);
  _Unwind_Resume(a1);
}

void VoiceProcessorV2::UpdateReferenceSignalMixerGains(uint64_t a1, vp::utility::Audio_Buffer_Mixer *this, uint64_t a3)
{
  if (**(_DWORD **)(a1 + 2336) == 1886613611)
  {
    if (*(_WORD *)(a1 + 2244))
    {
      unsigned int v5 = *(_DWORD *)(a1 + 72);
      if (v5 <= 0x24)
      {
        if (((1 << v5) & 0x3FC00000) != 0)
        {
          int v6 = *(_DWORD *)(a1 + 2304);
          unsigned int v7 = v6 - 1;
          int v8 = *(unsigned __int8 *)(a3 + 4);
          int v9 = *(_DWORD *)a3;
          vp::utility::Audio_Buffer_Mixer::reset_gains(this);
          unsigned int v10 = *(_DWORD *)this;
          unsigned int v11 = *((_DWORD *)this + 1);
          if (*(_DWORD *)this < 8u || v11 <= 1)
          {
            if (v11 < v10) {
              unsigned int v10 = *((_DWORD *)this + 1);
            }
            if (v10)
            {
              for (unsigned int i = 0; i < v22; ++i)
              {
                vp::utility::Audio_Buffer_Mixer::set_gain(this, i, i, 1.0);
                unsigned int v22 = *(_DWORD *)this;
                if (*((_DWORD *)this + 1) < *(_DWORD *)this) {
                  unsigned int v22 = *((_DWORD *)this + 1);
                }
              }
            }
          }
          else
          {
            if (v8) {
              int v12 = v9;
            }
            else {
              int v12 = 1;
            }
            if (v7 < 4) {
              int v12 = v6;
            }
            unsigned int v13 = v12 - 1;
            vp::utility::Audio_Buffer_Mixer::set_gain(this, 2u, 0, 1.0);
            vp::utility::Audio_Buffer_Mixer::set_gain(this, 3u, 0, 1.0);
            BOOL v14 = v13 >= 2;
            if (v13 >= 2) {
              unsigned int v15 = 0;
            }
            else {
              unsigned int v15 = 6;
            }
            if (v13 >= 2) {
              unsigned int v16 = 1;
            }
            else {
              unsigned int v16 = 7;
            }
            if (v14) {
              unsigned int v17 = 6;
            }
            else {
              unsigned int v17 = 0;
            }
            if (v14) {
              unsigned int v18 = 7;
            }
            else {
              unsigned int v18 = 1;
            }
            vp::utility::Audio_Buffer_Mixer::set_gain(this, v15, 0, 1.0);
            vp::utility::Audio_Buffer_Mixer::set_gain(this, v16, 0, 1.0);
            vp::utility::Audio_Buffer_Mixer::set_gain(this, v17, 1u, 1.0);
            vp::utility::Audio_Buffer_Mixer::set_gain(this, v18, 1u, 1.0);
            vp::utility::Audio_Buffer_Mixer::set_gain(this, 4u, 1u, 1.0);
            vp::utility::Audio_Buffer_Mixer::set_gain(this, 5u, 1u, 1.0);
          }
          if (v7 <= 3)
          {
            *(_DWORD *)a3 = v6;
            *(unsigned char *)(a3 + 4) = 1;
          }
        }
        else if (((1 << v5) & 0x1C00000100) != 0)
        {
          vp::utility::Audio_Buffer_Mixer::reset_gains(this);
          unsigned int v19 = *(_DWORD *)this;
          unsigned int v20 = *((_DWORD *)this + 1);
          if (*(_DWORD *)this < 4u || v20 <= 1)
          {
            if (v20 < v19) {
              unsigned int v19 = *((_DWORD *)this + 1);
            }
            if (v19)
            {
              for (unsigned int j = 0; j < v24; ++j)
              {
                vp::utility::Audio_Buffer_Mixer::set_gain(this, j, j, 1.0);
                unsigned int v24 = *(_DWORD *)this;
                if (*((_DWORD *)this + 1) < *(_DWORD *)this) {
                  unsigned int v24 = *((_DWORD *)this + 1);
                }
              }
            }
          }
          else
          {
            vp::utility::Audio_Buffer_Mixer::set_gain(this, 0, 0, 0.5);
            vp::utility::Audio_Buffer_Mixer::set_gain(this, 1u, 0, 0.5);
            vp::utility::Audio_Buffer_Mixer::set_gain(this, 2u, 1u, 0.5);
            vp::utility::Audio_Buffer_Mixer::set_gain(this, 3u, 1u, 0.5);
          }
        }
      }
    }
  }
}

void VoiceProcessorV2::SetupUplinkEchoProcessingGraph(VoiceProcessorV2 *this)
{
  v96[2] = *MEMORY[0x1E4F143B8];
  *((void *)this + 583) &= ~0x10000000uLL;
  uint64_t v2 = (const void *)*((void *)this + 2069);
  *((void *)this + 2069) = 0;
  if (v2) {
    CFRelease(v2);
  }
  unsigned int v3 = (const void *)*((void *)this + 2070);
  *((void *)this + 2070) = 0;
  if (v3) {
    CFRelease(v3);
  }
  int v4 = (const void *)*((void *)this + 2071);
  *((void *)this + 2071) = 0;
  if (v4) {
    CFRelease(v4);
  }
  unsigned int v5 = (const void *)*((void *)this + 2072);
  *((void *)this + 2072) = 0;
  if (v5) {
    CFRelease(v5);
  }
  if (*((unsigned char *)this + 60))
  {
    int v6 = (void *)((char *)this + 8);
    if (*((char *)this + 31) < 0) {
      int v6 = (void *)*v6;
    }
    buf[0].__pn_.__r_.__value_.__r.__words[0] = (std::string::size_type)v6;
    std::__fs::filesystem::path::path[abi:ne180100]<char const*,void>(&v91, &buf[0].__pn_.__r_.__value_.__l.__data_);
    if (!*((unsigned char *)this + 60)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    std::to_string(&v89, *((_DWORD *)this + 14));
    unsigned int v7 = std::string::insert(&v89, 0, "AID", 3uLL);
    std::string::size_type v8 = v7->__r_.__value_.__r.__words[0];
    v93.__pn_.__r_.__value_.__r.__words[0] = v7->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v93.__pn_.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v7->__r_.__value_.__r.__words[1] + 7);
    char v9 = HIBYTE(v7->__r_.__value_.__r.__words[2]);
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    v7->__r_.__value_.__r.__words[0] = 0;
    *(std::string::size_type *)((char *)&v90.__pn_.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v93.__pn_.__r_.__value_.__r.__words + 7);
    v90.__pn_.__r_.__value_.__r.__words[0] = v8;
    v90.__pn_.__r_.__value_.__l.__size_ = v93.__pn_.__r_.__value_.__r.__words[0];
    *((unsigned char *)&v90.__pn_.__r_.__value_.__s + 23) = v9;
    v93.__pn_.__r_.__value_.__r.__words[0] = 0;
    *(std::string::size_type *)((char *)v93.__pn_.__r_.__value_.__r.__words + 7) = 0;
    std::__fs::filesystem::operator/[abi:ne180100](&v90, (uint64_t)&v91, (std::__fs::filesystem::path *)&v92);
    VoiceProcessorV2::GetVersionNameForTuning(&v87.__pn_, (uint64_t)this);
    puint64_t n = v87.__pn_;
    memset(&v87, 0, sizeof(v87));
    std::__fs::filesystem::operator/[abi:ne180100]((std::__fs::filesystem::path *)&pn, (uint64_t)&v92, buf);
    memset(&__p, 0, sizeof(__p));
    std::string::append[abi:ne180100]<char const*,0>(&__p, "echo_processing.dspg", "");
    std::__fs::filesystem::operator/[abi:ne180100]((std::__fs::filesystem::path *)&__p, (uint64_t)buf, &v85);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(buf[0].__pn_.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf[0].__pn_.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(pn.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(pn.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v92.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v92.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v90.__pn_.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v90.__pn_.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v89.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v89.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v91.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    std::__fs::filesystem::path::path[abi:ne180100]<char [16],void>(&v85.__pn_, "emptyAcousticID");
  }
  unsigned int v10 = (char *)this + 15961;
  std::__fs::filesystem::__status(&v85, 0);
  if (v83 && v83 != 255)
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    unsigned int v16 = (void *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(4, VPLogScope(void)::scope, 0))
    {
      unsigned int v17 = (*v16 ? *v16 : MEMORY[0x1E4F14500]);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
      {
        unsigned int v18 = &v85;
        if ((v85.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          unsigned int v18 = (std::__fs::filesystem::path *)v85.__pn_.__r_.__value_.__r.__words[0];
        }
        LODWORD(buf[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)buf[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
        WORD2(buf[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&buf[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 515;
        WORD1(buf[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
        *(std::string::size_type *)((char *)&buf[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v18;
        _os_log_impl(&dword_1BB0CE000, v17, OS_LOG_TYPE_INFO, "%25s:%-5d  <vp> loading echo processing graph \"%s\"", (uint8_t *)buf, 0x1Cu);
      }
    }
    unsigned int v19 = (int *)*((void *)this + 1578);
    if (v19 && (*v10 || *((unsigned char *)this + 15962)))
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      unsigned int v20 = &v85;
      if ((v85.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        unsigned int v20 = (std::__fs::filesystem::path *)v85.__pn_.__r_.__value_.__r.__words[0];
      }
      CALegacyLog::log(v19, 4, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 515, "SetupUplinkEchoProcessingGraph", "loading echo processing graph \"%s\"", (const char *)v20);
    }
    std::ifstream::basic_ifstream((uint64_t *)buf);
    std::string::__init_with_sentinel[abi:ne180100]<std::istreambuf_iterator<char>,std::istreambuf_iterator<char>>(&v92, *(void **)((char *)&buf[1].__pn_.__r_.__value_.__r.__words[2]+ *(void *)(buf[0].__pn_.__r_.__value_.__r.__words[0] - 24)));
    if ((v92.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      long long v21 = &v92;
    }
    else {
      long long v21 = (std::string *)v92.__r_.__value_.__r.__words[0];
    }
    if (v21)
    {
      if ((v92.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        CFIndex size = HIBYTE(v92.__r_.__value_.__r.__words[2]);
      }
      else {
        CFIndex size = v92.__r_.__value_.__l.__size_;
      }
      CFStringRef v23 = CFStringCreateWithBytes(0, (const UInt8 *)v21, size, 0x8000100u, 0);
      if (!v23)
      {
        exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Could not construct");
      }
    }
    else
    {
      CFStringRef v23 = 0;
    }
    CFStringRef v25 = (const void *)*((void *)this + 2069);
    *((void *)this + 2069) = v23;
    if (v25) {
      CFRelease(v25);
    }
    std::__fs::filesystem::path::filename[abi:ne180100](&v85, (uint64_t)&v90);
    memset(&v89, 0, sizeof(v89));
    unsigned int v26 = std::__fs::filesystem::path::replace_extension(&v90, (const std::__fs::filesystem::path *)&v89);
    if (SHIBYTE(v26->__pn_.__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::__init_copy_ctor_external(&v91, v26->__pn_.__r_.__value_.__l.__data_, v26->__pn_.__r_.__value_.__l.__size_);
    }
    else
    {
      long long v27 = *(_OWORD *)&v26->__pn_.__r_.__value_.__l.__data_;
      v91.__r_.__value_.__r.__words[2] = v26->__pn_.__r_.__value_.__r.__words[2];
      *(_OWORD *)&v91.__r_.__value_.__l.__data_ = v27;
    }
    if (SHIBYTE(v89.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v89.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v90.__pn_.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v90.__pn_.__r_.__value_.__l.__data_);
    }
    if ((v91.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unsigned int v28 = &v91;
    }
    else {
      unsigned int v28 = (std::string *)v91.__r_.__value_.__r.__words[0];
    }
    if (v28)
    {
      if ((v91.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        CFIndex v29 = HIBYTE(v91.__r_.__value_.__r.__words[2]);
      }
      else {
        CFIndex v29 = v91.__r_.__value_.__l.__size_;
      }
      CFStringRef v30 = CFStringCreateWithBytes(0, (const UInt8 *)v28, v29, 0x8000100u, 0);
      if (!v30)
      {
        double v31 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v31, "Could not construct");
      }
    }
    else
    {
      CFStringRef v30 = 0;
    }
    double v32 = (const void *)*((void *)this + 2070);
    *((void *)this + 2070) = v30;
    if (v32) {
      CFRelease(v32);
    }
    if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v91.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v92.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v92.__r_.__value_.__l.__data_);
    }
    buf[0].__pn_.__r_.__value_.__r.__words[0] = *MEMORY[0x1E4FBA3F8];
    *(std::string::size_type *)((char *)buf[0].__pn_.__r_.__value_.__r.__words
                              + *(void *)(buf[0].__pn_.__r_.__value_.__r.__words[0] - 24)) = *(void *)(MEMORY[0x1E4FBA3F8] + 24);
    MEMORY[0x1C185CC40](&buf[0].__pn_.__r_.__value_.__r.__words[2]);
    std::istream::~istream();
    MEMORY[0x1C185D210](&v95);
  }
  else
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    unsigned int v11 = (void *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
    {
      int v12 = (*v11 ? *v11 : MEMORY[0x1E4F14500]);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        unsigned int v13 = &v85;
        if ((v85.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          unsigned int v13 = (std::__fs::filesystem::path *)v85.__pn_.__r_.__value_.__r.__words[0];
        }
        LODWORD(buf[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)buf[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
        WORD2(buf[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&buf[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 526;
        WORD1(buf[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
        *(std::string::size_type *)((char *)&buf[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v13;
        _os_log_impl(&dword_1BB0CE000, v12, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> file \"%s\" does not exist", (uint8_t *)buf, 0x1Cu);
      }
    }
    BOOL v14 = (int *)*((void *)this + 1578);
    if (v14 && (*v10 || *((unsigned char *)this + 15962)))
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      unsigned int v15 = &v85;
      if ((v85.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        unsigned int v15 = (std::__fs::filesystem::path *)v85.__pn_.__r_.__value_.__r.__words[0];
      }
      CALegacyLog::log(v14, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 526, "SetupUplinkEchoProcessingGraph", "file \"%s\" does not exist", (const char *)v15);
    }
  }
  if (SHIBYTE(v85.__pn_.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v85.__pn_.__r_.__value_.__l.__data_);
  }
  if (*((unsigned char *)this + 60))
  {
    double v33 = *((double *)this + 103);
    if (v33 == 16000.0) {
      float32x4_t v34 = "16";
    }
    else {
      float32x4_t v34 = "24";
    }
    if (v33 == 8000.0) {
      float v35 = "08";
    }
    else {
      float v35 = (char *)v34;
    }
    std::string::basic_string[abi:ne180100]<0>(&v91, v35);
    float32x4_t v36 = std::string::insert(&v91, 0, "echo_processing_", 0x10uLL);
    long long v37 = *(_OWORD *)&v36->__r_.__value_.__l.__data_;
    v92.__r_.__value_.__r.__words[2] = v36->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v92.__r_.__value_.__l.__data_ = v37;
    v36->__r_.__value_.__l.__size_ = 0;
    v36->__r_.__value_.__r.__words[2] = 0;
    v36->__r_.__value_.__r.__words[0] = 0;
    float32x4_t v38 = std::string::append(&v92, "kHz.austrip", 0xBuLL);
    long long v39 = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
    buf[0].__pn_.__r_.__value_.__r.__words[2] = v38->__r_.__value_.__r.__words[2];
    *(_OWORD *)&buf[0].__pn_.__r_.__value_.__l.__data_ = v39;
    v38->__r_.__value_.__l.__size_ = 0;
    v38->__r_.__value_.__r.__words[2] = 0;
    v38->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v92.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v92.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v91.__r_.__value_.__l.__data_);
    }
    int32x4_t v40 = (void *)((char *)this + 8);
    if (*((char *)this + 31) < 0) {
      int32x4_t v40 = (void *)*v40;
    }
    v92.__r_.__value_.__r.__words[0] = (std::string::size_type)v40;
    std::__fs::filesystem::path::path[abi:ne180100]<char const*,void>(&v90.__pn_, &v92.__r_.__value_.__l.__data_);
    if (!*((unsigned char *)this + 60)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    std::to_string(&pn, *((_DWORD *)this + 14));
    int8x16_t v41 = std::string::insert(&pn, 0, "AID", 3uLL);
    std::string::size_type v42 = v41->__r_.__value_.__r.__words[0];
    v96[0] = v41->__r_.__value_.__l.__size_;
    *(void *)((char *)v96 + 7) = *(std::string::size_type *)((char *)&v41->__r_.__value_.__r.__words[1] + 7);
    char v43 = HIBYTE(v41->__r_.__value_.__r.__words[2]);
    v41->__r_.__value_.__l.__size_ = 0;
    v41->__r_.__value_.__r.__words[2] = 0;
    v41->__r_.__value_.__r.__words[0] = 0;
    *(std::string::size_type *)((char *)&v89.__r_.__value_.__r.__words[1] + 7) = *(void *)((char *)v96 + 7);
    v89.__r_.__value_.__r.__words[0] = v42;
    v89.__r_.__value_.__l.__size_ = v96[0];
    *((unsigned char *)&v89.__r_.__value_.__s + 23) = v43;
    v96[0] = 0;
    *(void *)((char *)v96 + 7) = 0;
    std::__fs::filesystem::operator/[abi:ne180100]((std::__fs::filesystem::path *)&v89, (uint64_t)&v90, (std::__fs::filesystem::path *)&v91);
    VoiceProcessorV2::GetVersionNameForTuning(&__p, (uint64_t)this);
    v87.__pn_ = __p;
    memset(&__p, 0, sizeof(__p));
    std::__fs::filesystem::operator/[abi:ne180100](&v87, (uint64_t)&v91, (std::__fs::filesystem::path *)&v92);
    std::__fs::filesystem::path::path[abi:ne180100]<std::string,void>(&v85.__pn_, (char *)buf);
    std::__fs::filesystem::operator/[abi:ne180100](&v85, (uint64_t)&v92, &v93);
    if (SHIBYTE(v85.__pn_.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v85.__pn_.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v92.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v92.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v87.__pn_.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v87.__pn_.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v91.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v89.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v89.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(pn.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(pn.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v90.__pn_.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v90.__pn_.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(buf[0].__pn_.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf[0].__pn_.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    std::__fs::filesystem::path::path[abi:ne180100]<char [16],void>(&v93.__pn_, "emptyAcousticID");
  }
  std::__fs::filesystem::__status(&v93, 0);
  if (v84 && v84 != 255)
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    uint64_t v49 = (void *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(4, VPLogScope(void)::scope, 0))
    {
      double v50 = (*v49 ? *v49 : MEMORY[0x1E4F14500]);
      if (os_log_type_enabled(v50, OS_LOG_TYPE_INFO))
      {
        unint64_t v51 = &v93;
        if ((v93.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          unint64_t v51 = (std::__fs::filesystem::path *)v93.__pn_.__r_.__value_.__r.__words[0];
        }
        LODWORD(buf[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)buf[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
        WORD2(buf[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&buf[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 544;
        WORD1(buf[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
        *(std::string::size_type *)((char *)&buf[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v51;
        _os_log_impl(&dword_1BB0CE000, v50, OS_LOG_TYPE_INFO, "%25s:%-5d  <vp> loading echo processing AU strip \"%s\"", (uint8_t *)buf, 0x1Cu);
      }
    }
    std::string v52 = (int *)*((void *)this + 1578);
    if (v52 && (*v10 || *((unsigned char *)this + 15962)))
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      unsigned __int8 v53 = &v93;
      if ((v93.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        unsigned __int8 v53 = (std::__fs::filesystem::path *)v93.__pn_.__r_.__value_.__r.__words[0];
      }
      CALegacyLog::log(v52, 4, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 544, "SetupUplinkEchoProcessingGraph", "loading echo processing AU strip \"%s\"", (const char *)v53);
    }
    if (SHIBYTE(v93.__pn_.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&buf[0].__pn_, v93.__pn_.__r_.__value_.__l.__data_, v93.__pn_.__r_.__value_.__l.__size_);
    }
    else {
      buf[0] = v93;
    }
    applesauce::CF::make_DataRef((const char *)buf, (CFDataRef *)&v92);
    if (SHIBYTE(buf[0].__pn_.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf[0].__pn_.__r_.__value_.__l.__data_);
    }
    applesauce::CF::make_DictionaryRef((CFDataRef *)&v92, (applesauce::CF::DictionaryRef *)buf);
    unsigned __int8 v54 = (const void *)*((void *)this + 2071);
    *((void *)this + 2071) = buf[0].__pn_.__r_.__value_.__r.__words[0];
    buf[0].__pn_.__r_.__value_.__r.__words[0] = (std::string::size_type)v54;
    if (v54) {
      CFRelease(v54);
    }
    if (v92.__r_.__value_.__r.__words[0]) {
      CFRelease(v92.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    unsigned __int32 v44 = (void *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
    {
      float32x2_t v45 = (*v44 ? *v44 : MEMORY[0x1E4F14500]);
      if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
      {
        float32x2_t v46 = &v93;
        if ((v93.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          float32x2_t v46 = (std::__fs::filesystem::path *)v93.__pn_.__r_.__value_.__r.__words[0];
        }
        LODWORD(buf[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)buf[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
        WORD2(buf[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&buf[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 552;
        WORD1(buf[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
        *(std::string::size_type *)((char *)&buf[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v46;
        _os_log_impl(&dword_1BB0CE000, v45, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> file \"%s\" does not exist", (uint8_t *)buf, 0x1Cu);
      }
    }
    unsigned int v47 = (int *)*((void *)this + 1578);
    if (v47 && (*v10 || *((unsigned char *)this + 15962)))
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      unsigned __int8 v48 = &v93;
      if ((v93.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        unsigned __int8 v48 = (std::__fs::filesystem::path *)v93.__pn_.__r_.__value_.__r.__words[0];
      }
      CALegacyLog::log(v47, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 552, "SetupUplinkEchoProcessingGraph", "file \"%s\" does not exist", (const char *)v48);
    }
  }
  if (SHIBYTE(v93.__pn_.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v93.__pn_.__r_.__value_.__l.__data_);
  }
  if (*((unsigned char *)this + 60))
  {
    double v55 = *((double *)this + 103);
    if (v55 == 16000.0) {
      float v56 = "16";
    }
    else {
      float v56 = "24";
    }
    if (v55 == 8000.0) {
      std::string v57 = "08";
    }
    else {
      std::string v57 = (char *)v56;
    }
    std::string::basic_string[abi:ne180100]<0>(&v91, v57);
    double v58 = std::string::insert(&v91, 0, "echo_processing_", 0x10uLL);
    long long v59 = *(_OWORD *)&v58->__r_.__value_.__l.__data_;
    v92.__r_.__value_.__r.__words[2] = v58->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v92.__r_.__value_.__l.__data_ = v59;
    v58->__r_.__value_.__l.__size_ = 0;
    v58->__r_.__value_.__r.__words[2] = 0;
    v58->__r_.__value_.__r.__words[0] = 0;
    uint64_t v60 = std::string::append(&v92, "kHz.propstrip", 0xDuLL);
    long long v61 = *(_OWORD *)&v60->__r_.__value_.__l.__data_;
    buf[0].__pn_.__r_.__value_.__r.__words[2] = v60->__r_.__value_.__r.__words[2];
    *(_OWORD *)&buf[0].__pn_.__r_.__value_.__l.__data_ = v61;
    v60->__r_.__value_.__l.__size_ = 0;
    v60->__r_.__value_.__r.__words[2] = 0;
    v60->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v92.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v92.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v91.__r_.__value_.__l.__data_);
    }
    int32x4_t v62 = (void *)((char *)this + 8);
    if (*((char *)this + 31) < 0) {
      int32x4_t v62 = (void *)*v62;
    }
    v92.__r_.__value_.__r.__words[0] = (std::string::size_type)v62;
    std::__fs::filesystem::path::path[abi:ne180100]<char const*,void>(&v90.__pn_, &v92.__r_.__value_.__l.__data_);
    if (!*((unsigned char *)this + 60)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    std::to_string(&pn, *((_DWORD *)this + 14));
    int8x16_t v63 = std::string::insert(&pn, 0, "AID", 3uLL);
    std::string::size_type v64 = v63->__r_.__value_.__r.__words[0];
    v96[0] = v63->__r_.__value_.__l.__size_;
    *(void *)((char *)v96 + 7) = *(std::string::size_type *)((char *)&v63->__r_.__value_.__r.__words[1] + 7);
    char v65 = HIBYTE(v63->__r_.__value_.__r.__words[2]);
    v63->__r_.__value_.__l.__size_ = 0;
    v63->__r_.__value_.__r.__words[2] = 0;
    v63->__r_.__value_.__r.__words[0] = 0;
    *(std::string::size_type *)((char *)&v89.__r_.__value_.__r.__words[1] + 7) = *(void *)((char *)v96 + 7);
    v89.__r_.__value_.__r.__words[0] = v64;
    v89.__r_.__value_.__l.__size_ = v96[0];
    *((unsigned char *)&v89.__r_.__value_.__s + 23) = v65;
    v96[0] = 0;
    *(void *)((char *)v96 + 7) = 0;
    std::__fs::filesystem::operator/[abi:ne180100]((std::__fs::filesystem::path *)&v89, (uint64_t)&v90, (std::__fs::filesystem::path *)&v91);
    VoiceProcessorV2::GetVersionNameForTuning(&__p, (uint64_t)this);
    v87.__pn_ = __p;
    memset(&__p, 0, sizeof(__p));
    std::__fs::filesystem::operator/[abi:ne180100](&v87, (uint64_t)&v91, (std::__fs::filesystem::path *)&v92);
    std::__fs::filesystem::path::path[abi:ne180100]<std::string,void>(&v85.__pn_, (char *)buf);
    std::__fs::filesystem::operator/[abi:ne180100](&v85, (uint64_t)&v92, &v93);
    if (SHIBYTE(v85.__pn_.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v85.__pn_.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v92.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v92.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v87.__pn_.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v87.__pn_.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v91.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v89.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v89.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(pn.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(pn.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v90.__pn_.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v90.__pn_.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(buf[0].__pn_.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf[0].__pn_.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    std::__fs::filesystem::path::path[abi:ne180100]<char [16],void>(&v93.__pn_, "emptyAcousticID");
  }
  std::__fs::filesystem::__status(&v93, 0);
  if (v92.__r_.__value_.__s.__data_[0] && v92.__r_.__value_.__s.__data_[0] != 255)
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    float32x2_t v71 = (void *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(4, VPLogScope(void)::scope, 0))
    {
      float32x2_t v72 = (*v71 ? *v71 : MEMORY[0x1E4F14500]);
      if (os_log_type_enabled(v72, OS_LOG_TYPE_INFO))
      {
        float32x4_t v73 = &v93;
        if ((v93.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          float32x4_t v73 = (std::__fs::filesystem::path *)v93.__pn_.__r_.__value_.__r.__words[0];
        }
        LODWORD(buf[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)buf[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
        WORD2(buf[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&buf[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 570;
        WORD1(buf[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
        *(std::string::size_type *)((char *)&buf[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v73;
        _os_log_impl(&dword_1BB0CE000, v72, OS_LOG_TYPE_INFO, "%25s:%-5d  <vp> loading echo processing property strip \"%s\"", (uint8_t *)buf, 0x1Cu);
      }
    }
    int8x16_t v74 = (int *)*((void *)this + 1578);
    if (v74 && (*v10 || *((unsigned char *)this + 15962)))
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      float32x2_t v75 = &v93;
      if ((v93.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        float32x2_t v75 = (std::__fs::filesystem::path *)v93.__pn_.__r_.__value_.__r.__words[0];
      }
      CALegacyLog::log(v74, 4, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 570, "SetupUplinkEchoProcessingGraph", "loading echo processing property strip \"%s\"", (const char *)v75);
    }
    if (SHIBYTE(v93.__pn_.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&buf[0].__pn_, v93.__pn_.__r_.__value_.__l.__data_, v93.__pn_.__r_.__value_.__l.__size_);
    }
    else {
      buf[0] = v93;
    }
    applesauce::CF::make_DataRef((const char *)buf, (CFDataRef *)&v91);
    if (SHIBYTE(buf[0].__pn_.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf[0].__pn_.__r_.__value_.__l.__data_);
    }
    applesauce::CF::make_DictionaryRef((CFDataRef *)&v91, (applesauce::CF::DictionaryRef *)buf);
    float32x2_t v76 = (const void *)*((void *)this + 2072);
    *((void *)this + 2072) = buf[0].__pn_.__r_.__value_.__r.__words[0];
    buf[0].__pn_.__r_.__value_.__r.__words[0] = (std::string::size_type)v76;
    if (v76) {
      CFRelease(v76);
    }
    LODWORD(v89.__r_.__value_.__l.__data_) = 1953850480;
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[3],int>((applesauce::CF::TypeRef *)buf, "ID", (int *)&v89);
    unsigned __int8 v77 = (void *)((char *)this + 8);
    if (*((char *)this + 31) < 0) {
      unsigned __int8 v77 = (void *)*v77;
    }
    v90.__pn_.__r_.__value_.__r.__words[0] = (std::string::size_type)v77;
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[9],char const*>((applesauce::CF::TypeRef *)&buf[0].__pn_.__r_.__value_.__r.__words[2], "cfobject", &v90.__pn_.__r_.__value_.__l.__data_);
    v92.__r_.__value_.__r.__words[0] = (std::string::size_type)buf;
    v92.__r_.__value_.__l.__size_ = 2;
    CFDictionaryRef CFDictionaryRef = applesauce::CF::details::make_CFDictionaryRef((uint64_t)&v92);
    int v79 = (const void *)*((void *)this + 2073);
    *((void *)this + 2073) = CFDictionaryRef;
    if (v79) {
      CFRelease(v79);
    }
    for (uint64_t i = 0; i != -4; i -= 2)
    {
      int v81 = *(std::string::pointer *)((char *)&buf[1].__pn_.__r_.__value_.__l.__data_ + i * 8);
      if (v81) {
        CFRelease(v81);
      }
      int v82 = (const void *)buf[0].__pn_.__r_.__value_.__r.__words[i + 2];
      if (v82) {
        CFRelease(v82);
      }
    }
    if (v91.__r_.__value_.__r.__words[0]) {
      CFRelease(v91.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    float32x4_t v66 = (void *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
    {
      int8x16_t v67 = (*v66 ? *v66 : MEMORY[0x1E4F14500]);
      if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
      {
        float32x2_t v68 = &v93;
        if ((v93.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          float32x2_t v68 = (std::__fs::filesystem::path *)v93.__pn_.__r_.__value_.__r.__words[0];
        }
        LODWORD(buf[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)buf[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
        WORD2(buf[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&buf[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 579;
        WORD1(buf[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
        *(std::string::size_type *)((char *)&buf[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v68;
        _os_log_impl(&dword_1BB0CE000, v67, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> file \"%s\" does not exist", (uint8_t *)buf, 0x1Cu);
      }
    }
    float32x4_t v69 = (int *)*((void *)this + 1578);
    if (v69 && (*v10 || *((unsigned char *)this + 15962)))
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      unsigned __int32 v70 = &v93;
      if ((v93.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        unsigned __int32 v70 = (std::__fs::filesystem::path *)v93.__pn_.__r_.__value_.__r.__words[0];
      }
      CALegacyLog::log(v69, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 579, "SetupUplinkEchoProcessingGraph", "file \"%s\" does not exist", (const char *)v70);
    }
  }
  if (SHIBYTE(v93.__pn_.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v93.__pn_.__r_.__value_.__l.__data_);
  }
  if (*((void *)this + 2069) && *((void *)this + 2070) && *((void *)this + 2071))
  {
    if (*((void *)this + 2072)) {
      *((void *)this + 583) |= 0x10000000uLL;
    }
  }
}

#error "1BB399E84: call analysis failed (funcsize=165)"

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[3],int>(applesauce::CF::TypeRef *a1, char *a2, int *a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  int valuePtr = *a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  *((void *)a1 + 1) = v5;
  if (!v5)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1BB39A0AC(_Unwind_Exception *a1)
{
  unsigned int v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[9],char const*>(applesauce::CF::TypeRef *a1, char *a2, char **a3)
{
  CFNumberRef v5 = applesauce::CF::TypeRef::TypeRef(a1, a2);
  applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)((char *)v5 + 8), *a3);
  return a1;
}

void sub_1BB39A120(_Unwind_Exception *a1)
{
  applesauce::CF::TypeRef::~TypeRef(v1);
  _Unwind_Resume(a1);
}

void VoiceProcessorV2::SetupUplinkAirPodsOffloadGraph(VoiceProcessorV2 *this)
{
  v59[20] = *MEMORY[0x1E4F143B8];
  *((void *)this + 584) &= ~0x80uLL;
  uint64_t v2 = (char *)this + 8;
  unsigned int v3 = (char *)this + 8;
  if (*((char *)this + 31) < 0) {
    unsigned int v3 = *(char **)v2;
  }
  __p[0].__pn_.__r_.__value_.__r.__words[0] = (std::string::size_type)v3;
  std::__fs::filesystem::path::path[abi:ne180100]<char const*,void>(&v57.__pn_, &__p[0].__pn_.__r_.__value_.__l.__data_);
  std::__fs::filesystem::path::append[abi:ne180100]<char [8]>(&v57.__pn_, "Generic");
  VoiceProcessorV2::GetVersionNameForTuning(&__p[0].__pn_, (uint64_t)this);
  std::__fs::filesystem::path::append[abi:ne180100]<std::string>(&v57.__pn_, (uint64_t)__p);
  if (SHIBYTE(__p[0].__pn_.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p[0].__pn_.__r_.__value_.__l.__data_);
  }
  if (std::__fs::filesystem::path::__filename(&v57).__size_) {
    std::string::push_back(&v57.__pn_, 47);
  }
  std::string::append[abi:ne180100]<char const*,0>(&v57.__pn_, "uplink_echo_airpods_offload.dspg", "");
  int v4 = (char *)this + 15961;
  std::__fs::filesystem::__status(&v57, 0);
  if (v55 && v55 != 255)
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    unsigned int v10 = (void *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(4, VPLogScope(void)::scope, 0))
    {
      unsigned int v11 = (*v10 ? *v10 : MEMORY[0x1E4F14500]);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      {
        int v12 = &v57;
        if ((v57.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          int v12 = (std::__fs::filesystem::path *)v57.__pn_.__r_.__value_.__r.__words[0];
        }
        LODWORD(__p[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)__p[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
        WORD2(__p[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 605;
        WORD1(__p[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
        *(std::string::size_type *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v12;
        _os_log_impl(&dword_1BB0CE000, v11, OS_LOG_TYPE_INFO, "%25s:%-5d  <vp> loading offload AirPods DSP graph \"%s\"", (uint8_t *)__p, 0x1Cu);
      }
    }
    unsigned int v13 = (int *)*((void *)this + 1578);
    if (v13 && (*v4 || *((unsigned char *)this + 15962)))
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      BOOL v14 = &v57;
      if ((v57.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        BOOL v14 = (std::__fs::filesystem::path *)v57.__pn_.__r_.__value_.__r.__words[0];
      }
      CALegacyLog::log(v13, 4, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 605, "SetupUplinkAirPodsOffloadGraph", "loading offload AirPods DSP graph \"%s\"", (const char *)v14);
    }
    std::ifstream::basic_ifstream((uint64_t *)__p);
    std::string::__init_with_sentinel[abi:ne180100]<std::istreambuf_iterator<char>,std::istreambuf_iterator<char>>(&__replacement.__pn_, *(void **)((char *)&__p[1].__pn_.__r_.__value_.__r.__words[2]+ *(void *)(__p[0].__pn_.__r_.__value_.__r.__words[0] - 24)));
    if ((__replacement.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_replacement = &__replacement;
    }
    else {
      p_replacement = (std::__fs::filesystem::path *)__replacement.__pn_.__r_.__value_.__r.__words[0];
    }
    if (p_replacement)
    {
      if ((__replacement.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        CFIndex size = HIBYTE(__replacement.__pn_.__r_.__value_.__r.__words[2]);
      }
      else {
        CFIndex size = __replacement.__pn_.__r_.__value_.__l.__size_;
      }
      CFStringRef v17 = CFStringCreateWithBytes(0, (const UInt8 *)p_replacement, size, 0x8000100u, 0);
      if (!v17)
      {
        exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Could not construct");
      }
    }
    else
    {
      CFStringRef v17 = 0;
    }
    unsigned int v19 = (const void *)*((void *)this + 2093);
    *((void *)this + 2093) = v17;
    if (v19) {
      CFRelease(v19);
    }
    if (SHIBYTE(__replacement.__pn_.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__replacement.__pn_.__r_.__value_.__l.__data_);
    }
    __p[0].__pn_.__r_.__value_.__r.__words[0] = *MEMORY[0x1E4FBA3F8];
    *(std::string::size_type *)((char *)__p[0].__pn_.__r_.__value_.__r.__words
                              + *(void *)(__p[0].__pn_.__r_.__value_.__r.__words[0] - 24)) = *(void *)(MEMORY[0x1E4FBA3F8] + 24);
    MEMORY[0x1C185CC40](&__p[0].__pn_.__r_.__value_.__r.__words[2]);
    std::istream::~istream();
    MEMORY[0x1C185D210](v59);
  }
  else
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    CFNumberRef v5 = (void *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
    {
      int v6 = (*v5 ? *v5 : MEMORY[0x1E4F14500]);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        unsigned int v7 = &v57;
        if ((v57.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          unsigned int v7 = (std::__fs::filesystem::path *)v57.__pn_.__r_.__value_.__r.__words[0];
        }
        LODWORD(__p[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)__p[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
        WORD2(__p[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 610;
        WORD1(__p[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
        *(std::string::size_type *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v7;
        _os_log_impl(&dword_1BB0CE000, v6, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> file \"%s\" does not exist", (uint8_t *)__p, 0x1Cu);
      }
    }
    std::string::size_type v8 = (int *)*((void *)this + 1578);
    if (v8 && (*v4 || *((unsigned char *)this + 15962)))
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      char v9 = &v57;
      if ((v57.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        char v9 = (std::__fs::filesystem::path *)v57.__pn_.__r_.__value_.__r.__words[0];
      }
      CALegacyLog::log(v8, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 610, "SetupUplinkAirPodsOffloadGraph", "file \"%s\" does not exist", (const char *)v9);
    }
  }
  if (SHIBYTE(v57.__pn_.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v57.__pn_.__r_.__value_.__l.__data_);
  }
  VoiceProcessorV2::GetAirPodsOffloadAUStripFilePath(&v57.__pn_, (char *)this);
  std::__fs::filesystem::path::filename[abi:ne180100](&v57, (uint64_t)__p);
  memset(&__replacement, 0, sizeof(__replacement));
  unsigned int v20 = std::__fs::filesystem::path::replace_extension(__p, &__replacement);
  if (SHIBYTE(v20->__pn_.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::__init_copy_ctor_external(&v54, v20->__pn_.__r_.__value_.__l.__data_, v20->__pn_.__r_.__value_.__l.__size_);
  }
  else
  {
    long long v21 = *(_OWORD *)&v20->__pn_.__r_.__value_.__l.__data_;
    v54.__r_.__value_.__r.__words[2] = v20->__pn_.__r_.__value_.__r.__words[2];
    *(_OWORD *)&v54.__r_.__value_.__l.__data_ = v21;
  }
  if (SHIBYTE(__replacement.__pn_.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__replacement.__pn_.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__p[0].__pn_.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p[0].__pn_.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v57.__pn_.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v57.__pn_.__r_.__value_.__l.__data_);
  }
  if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unsigned int v22 = &v54;
  }
  else {
    unsigned int v22 = (std::string *)v54.__r_.__value_.__r.__words[0];
  }
  if (v22)
  {
    if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      CFIndex v23 = HIBYTE(v54.__r_.__value_.__r.__words[2]);
    }
    else {
      CFIndex v23 = v54.__r_.__value_.__l.__size_;
    }
    CFStringRef v24 = CFStringCreateWithBytes(0, (const UInt8 *)v22, v23, 0x8000100u, 0);
    if (!v24)
    {
      CFStringRef v25 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v25, "Could not construct");
    }
  }
  else
  {
    CFStringRef v24 = 0;
  }
  unsigned int v26 = (const void *)*((void *)this + 2094);
  *((void *)this + 2094) = v24;
  if (v26) {
    CFRelease(v26);
  }
  if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v54.__r_.__value_.__l.__data_);
  }
  VoiceProcessorV2::GetAirPodsOffloadAUStripFilePath(&v57.__pn_, (char *)this);
  std::__fs::filesystem::__status(&v57, 0);
  if (v54.__r_.__value_.__s.__data_[0] && v54.__r_.__value_.__s.__data_[0] != 255)
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    double v32 = (void *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(4, VPLogScope(void)::scope, 0))
    {
      double v33 = (*v32 ? *v32 : MEMORY[0x1E4F14500]);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
      {
        float32x4_t v34 = &v57;
        if ((v57.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          float32x4_t v34 = (std::__fs::filesystem::path *)v57.__pn_.__r_.__value_.__r.__words[0];
        }
        LODWORD(__p[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)__p[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
        WORD2(__p[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 628;
        WORD1(__p[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
        *(std::string::size_type *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v34;
        _os_log_impl(&dword_1BB0CE000, v33, OS_LOG_TYPE_INFO, "%25s:%-5d  <vp> loading offload AirPods DSP AU strip \"%s\"", (uint8_t *)__p, 0x1Cu);
      }
    }
    float v35 = (int *)*((void *)this + 1578);
    if (v35 && (*v4 || *((unsigned char *)this + 15962)))
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      float32x4_t v36 = &v57;
      if ((v57.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        float32x4_t v36 = (std::__fs::filesystem::path *)v57.__pn_.__r_.__value_.__r.__words[0];
      }
      CALegacyLog::log(v35, 4, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 628, "SetupUplinkAirPodsOffloadGraph", "loading offload AirPods DSP AU strip \"%s\"", (const char *)v36);
    }
    if (SHIBYTE(v57.__pn_.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&__p[0].__pn_, v57.__pn_.__r_.__value_.__l.__data_, v57.__pn_.__r_.__value_.__l.__size_);
    }
    else {
      __p[0] = v57;
    }
    applesauce::CF::make_DataRef((const char *)__p, (CFDataRef *)&__replacement);
    if (SHIBYTE(__p[0].__pn_.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__pn_.__r_.__value_.__l.__data_);
    }
    applesauce::CF::make_DictionaryRef((CFDataRef *)&__replacement, (applesauce::CF::DictionaryRef *)__p);
    long long v37 = (const void *)*((void *)this + 2095);
    *((void *)this + 2095) = __p[0].__pn_.__r_.__value_.__r.__words[0];
    __p[0].__pn_.__r_.__value_.__r.__words[0] = (std::string::size_type)v37;
    if (v37) {
      CFRelease(v37);
    }
    if (__replacement.__pn_.__r_.__value_.__r.__words[0]) {
      CFRelease(__replacement.__pn_.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    long long v27 = (void *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
    {
      unsigned int v28 = (*v27 ? *v27 : MEMORY[0x1E4F14500]);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        CFIndex v29 = &v57;
        if ((v57.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          CFIndex v29 = (std::__fs::filesystem::path *)v57.__pn_.__r_.__value_.__r.__words[0];
        }
        LODWORD(__p[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)__p[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
        WORD2(__p[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 633;
        WORD1(__p[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
        *(std::string::size_type *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v29;
        _os_log_impl(&dword_1BB0CE000, v28, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> file \"%s\" does not exist", (uint8_t *)__p, 0x1Cu);
      }
    }
    CFStringRef v30 = (int *)*((void *)this + 1578);
    if (v30 && (*v4 || *((unsigned char *)this + 15962)))
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      double v31 = &v57;
      if ((v57.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        double v31 = (std::__fs::filesystem::path *)v57.__pn_.__r_.__value_.__r.__words[0];
      }
      CALegacyLog::log(v30, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 633, "SetupUplinkAirPodsOffloadGraph", "file \"%s\" does not exist", (const char *)v31);
    }
  }
  if (SHIBYTE(v57.__pn_.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v57.__pn_.__r_.__value_.__l.__data_);
  }
  if (*((char *)this + 31) < 0) {
    uint64_t v2 = *(char **)v2;
  }
  __p[0].__pn_.__r_.__value_.__r.__words[0] = (std::string::size_type)v2;
  std::__fs::filesystem::path::path[abi:ne180100]<char const*,void>(&v57.__pn_, &__p[0].__pn_.__r_.__value_.__l.__data_);
  if (*((_DWORD *)this + 18) == 34)
  {
    VoiceProcessorV2::GetHardwareModelNameForTuning(&__p[0].__pn_, (uint64_t)this, 0);
    std::__fs::filesystem::path::append[abi:ne180100]<std::string>(&v57.__pn_, (uint64_t)__p);
    if (SHIBYTE(__p[0].__pn_.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__pn_.__r_.__value_.__l.__data_);
    }
    VoiceProcessorV2::GetVersionNameForTuning(&__p[0].__pn_, (uint64_t)this);
    std::__fs::filesystem::path::append[abi:ne180100]<std::string>(&v57.__pn_, (uint64_t)__p);
    if (SHIBYTE(__p[0].__pn_.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__pn_.__r_.__value_.__l.__data_);
    }
    float32x4_t v38 = "uplink_echo_airpods_offload_espresso.propstrip";
    long long v39 = "";
    if (std::__fs::filesystem::path::__filename(&v57).__size_) {
LABEL_150:
    }
      std::string::push_back(&v57.__pn_, 47);
  }
  else
  {
    std::__fs::filesystem::path::append[abi:ne180100]<char [8]>(&v57.__pn_, "Generic");
    VoiceProcessorV2::GetVersionNameForTuning(&__p[0].__pn_, (uint64_t)this);
    std::__fs::filesystem::path::append[abi:ne180100]<std::string>(&v57.__pn_, (uint64_t)__p);
    if (SHIBYTE(__p[0].__pn_.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__pn_.__r_.__value_.__l.__data_);
    }
    float32x4_t v38 = "uplink_echo_airpods_offload.propstrip";
    long long v39 = "";
    if (std::__fs::filesystem::path::__filename(&v57).__size_) {
      goto LABEL_150;
    }
  }
  std::string::append[abi:ne180100]<char const*,0>(&v57.__pn_, v38, v39);
  std::__fs::filesystem::__status(&v57, 0);
  if (__replacement.__pn_.__r_.__value_.__s.__data_[0]
    && __replacement.__pn_.__r_.__value_.__s.__data_[0] != 255)
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    float32x2_t v45 = (void *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(4, VPLogScope(void)::scope, 0))
    {
      float32x2_t v46 = (*v45 ? *v45 : MEMORY[0x1E4F14500]);
      if (os_log_type_enabled(v46, OS_LOG_TYPE_INFO))
      {
        unsigned int v47 = &v57;
        if ((v57.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          unsigned int v47 = (std::__fs::filesystem::path *)v57.__pn_.__r_.__value_.__r.__words[0];
        }
        LODWORD(__p[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)__p[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
        WORD2(__p[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 643;
        WORD1(__p[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
        *(std::string::size_type *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v47;
        _os_log_impl(&dword_1BB0CE000, v46, OS_LOG_TYPE_INFO, "%25s:%-5d  <vp> loading offload AirPods DSP property strip \"%s\"", (uint8_t *)__p, 0x1Cu);
      }
    }
    unsigned __int8 v48 = (int *)*((void *)this + 1578);
    if (v48 && (*v4 || *((unsigned char *)this + 15962)))
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      uint64_t v49 = &v57;
      if ((v57.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v49 = (std::__fs::filesystem::path *)v57.__pn_.__r_.__value_.__r.__words[0];
      }
      CALegacyLog::log(v48, 4, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 643, "SetupUplinkAirPodsOffloadGraph", "loading offload AirPods DSP property strip \"%s\"", (const char *)v49);
    }
    if (SHIBYTE(v57.__pn_.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&__p[0].__pn_, v57.__pn_.__r_.__value_.__l.__data_, v57.__pn_.__r_.__value_.__l.__size_);
    }
    else {
      __p[0] = v57;
    }
    applesauce::CF::make_DataRef((const char *)__p, (CFDataRef *)&__replacement);
    if (SHIBYTE(__p[0].__pn_.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__pn_.__r_.__value_.__l.__data_);
    }
    applesauce::CF::make_DictionaryRef((CFDataRef *)&__replacement, (applesauce::CF::DictionaryRef *)__p);
    double v50 = (const void *)*((void *)this + 2096);
    *((void *)this + 2096) = __p[0].__pn_.__r_.__value_.__r.__words[0];
    __p[0].__pn_.__r_.__value_.__r.__words[0] = (std::string::size_type)v50;
    if (v50) {
      CFRelease(v50);
    }
    if (__replacement.__pn_.__r_.__value_.__r.__words[0]) {
      CFRelease(__replacement.__pn_.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    int32x4_t v40 = (void *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
    {
      int8x16_t v41 = (*v40 ? *v40 : MEMORY[0x1E4F14500]);
      if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
      {
        std::string::size_type v42 = &v57;
        if ((v57.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type v42 = (std::__fs::filesystem::path *)v57.__pn_.__r_.__value_.__r.__words[0];
        }
        LODWORD(__p[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)__p[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
        WORD2(__p[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 648;
        WORD1(__p[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
        *(std::string::size_type *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v42;
        _os_log_impl(&dword_1BB0CE000, v41, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> file \"%s\" does not exist", (uint8_t *)__p, 0x1Cu);
      }
    }
    char v43 = (int *)*((void *)this + 1578);
    if (v43 && (*v4 || *((unsigned char *)this + 15962)))
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      unsigned __int32 v44 = &v57;
      if ((v57.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        unsigned __int32 v44 = (std::__fs::filesystem::path *)v57.__pn_.__r_.__value_.__r.__words[0];
      }
      CALegacyLog::log(v43, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 648, "SetupUplinkAirPodsOffloadGraph", "file \"%s\" does not exist", (const char *)v44);
    }
  }
  if (SHIBYTE(v57.__pn_.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v57.__pn_.__r_.__value_.__l.__data_);
  }
  if (*((void *)this + 2093) && *((void *)this + 2094) && *((void *)this + 2095) && *((void *)this + 2096))
  {
    *((void *)this + 584) |= 0x80uLL;
  }
  else
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    unint64_t v51 = (void *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
    {
      std::string v52 = (*v51 ? *v51 : MEMORY[0x1E4F14500]);
      if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
      {
        LODWORD(__p[0].__pn_.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)__p[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
        WORD2(__p[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 661;
        _os_log_impl(&dword_1BB0CE000, v52, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> Not able to enable offload AirPods DSP graph", (uint8_t *)__p, 0x12u);
      }
    }
    unsigned __int8 v53 = (int *)*((void *)this + 1578);
    if (v53 && (*v4 || v4[1]))
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      CALegacyLog::log(v53, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 661, "SetupUplinkAirPodsOffloadGraph", "Not able to enable offload AirPods DSP graph");
    }
  }
}

#error "1BB39BC30: call analysis failed (funcsize=164)"

void clsp::DisplacementController::setLogs(void *a1, uint64_t *a2)
{
  uint64_t v5 = *a2;
  uint64_t v4 = a2[1];
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  int v6 = (std::__shared_weak_count *)a1[41];
  a1[40] = v5;
  a1[41] = v4;
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  uint64_t v8 = *a2;
  uint64_t v7 = a2[1];
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  char v9 = (std::__shared_weak_count *)a1[33];
  a1[32] = v8;
  a1[33] = v7;
  if (v9)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }
}

uint64_t clsp::DisplacementController::zapBadValues(uint64_t this)
{
  float32x2_t v1 = *(float32x2_t *)(this + 92);
  float64x2_t v2 = vcvtq_f64_f32(vabs_f32(v1));
  float64x2_t v3 = (float64x2_t)vdupq_n_s64(0x3CD203AF9EE75616uLL);
  float64x2_t v4 = (float64x2_t)vdupq_n_s64(0x430C6BF526340000uLL);
  *(int8x8_t *)(this + 92) = vand_s8((int8x8_t)v1, (int8x8_t)vmovn_s64((int64x2_t)vandq_s8((int8x16_t)vcgtq_f64(v2, v3), (int8x16_t)vcgtq_f64(v4, v2))));
  float v5 = *(float *)(this + 160);
  double v6 = fabsf(v5);
  if (v6 >= 1.0e15 || v6 <= 1.0e-15) {
    float v5 = 0.0;
  }
  *(float *)(this + 160) = v5;
  float32x2_t v8 = *(float32x2_t *)(this + 112);
  float64x2_t v9 = vcvtq_f64_f32(vabs_f32(v8));
  *(int8x8_t *)(this + 112) = vand_s8((int8x8_t)v8, (int8x8_t)vmovn_s64((int64x2_t)vandq_s8((int8x16_t)vcgtq_f64(v9, v3), (int8x16_t)vcgtq_f64(v4, v9))));
  float v10 = *(float *)(this + 200);
  double v11 = fabsf(v10);
  if (v11 >= 1.0e15 || v11 <= 1.0e-15) {
    float v10 = 0.0;
  }
  *(float *)(this + 200) = v10;
  float v13 = *(float *)(this + 220);
  double v14 = fabsf(v13);
  if (v14 >= 1.0e15 || v14 <= 1.0e-15) {
    float v13 = 0.0;
  }
  *(float *)(this + 220) = v13;
  float32x4_t v16 = *(float32x4_t *)(this + 292);
  float32x4_t v17 = vabsq_f32(v16);
  float64x2_t v18 = vcvt_hight_f64_f32(v17);
  float64x2_t v19 = vcvtq_f64_f32(*(float32x2_t *)v17.f32);
  *(int8x16_t *)(this + 292) = vandq_s8((int8x16_t)v16, (int8x16_t)vuzp1q_s32((int32x4_t)vandq_s8((int8x16_t)vcgtq_f64(v19, v3), (int8x16_t)vcgtq_f64(v4, v19)), (int32x4_t)vandq_s8((int8x16_t)vcgtq_f64(v18, v3), (int8x16_t)vcgtq_f64(v4, v18))));
  float v20 = *(float *)(this + 76);
  double v21 = fabsf(v20);
  if (v21 >= 1.0e15 || v21 <= 1.0e-15) {
    float v20 = 0.0;
  }
  if (v20 < *(float *)(this + 68)) {
    float v20 = *(float *)(this + 68);
  }
  *(float *)(this + 76) = v20;
  return this;
}

float clsp::DisplacementController::reset(clsp::DisplacementController *this)
{
  *(void *)((char *)this + 300) = 0;
  *(void *)((char *)this + 292) = 0;
  *(void *)((char *)this + 92) = 0;
  *((_DWORD *)this + 40) = 0;
  *((void *)this + 14) = 0;
  *((_DWORD *)this + 50) = 0;
  *((_DWORD *)this + 55) = 0;
  float result = (*(double (**)(clsp::DisplacementController *))(*(void *)this + 56))(this);
  *((float *)this + 19) = result;
  return result;
}

float clsp::DisplacementController::getNormAttenFactor(clsp::DisplacementController *this)
{
  return *((float *)this + 19) * *((float *)this + 18);
}

float clsp::DisplacementController::analyzeDisp(clsp::DisplacementController *this, float a2, float a3)
{
  float v4 = *((float *)this + 21);
  float v5 = *((float *)this + 23);
  float v6 = (float)(a2 * *((float *)this + 22)) - (float)(v5 * *((float *)this + 20));
  float v7 = *((float *)this + 24);
  float v8 = *((float *)this + 25);
  float v9 = v6 - (float)(v7 * v4);
  *((float *)this + 23) = v9;
  *((float *)this + 24) = v5;
  float v10 = -(float)(v6 + (float)((float)-v7 * v4));
  if (v9 >= 0.0) {
    float v10 = v9;
  }
  float v11 = *((float *)this + 40);
  uint64_t v12 = 148;
  if (v11 < v10) {
    uint64_t v12 = 144;
  }
  float v13 = v11 + (float)(*(float *)((char *)this + v12) * (float)(v10 - v11));
  *((float *)this + 40) = v13;
  float v14 = *((float *)this + 17);
  float v15 = *((float *)this + 18);
  float v16 = *((float *)this + 26);
  float v17 = *((float *)this + 28);
  float v18 = *((float *)this + 29);
  float v19 = (float)(a3 * *((float *)this + 27)) - (float)(v17 * v8);
  float v20 = v19 - (float)(v18 * v16);
  *((float *)this + 28) = v20;
  *((float *)this + 29) = v17;
  if (v14 >= v13) {
    float v21 = v14;
  }
  else {
    float v21 = v13;
  }
  float v22 = -(float)(v19 + (float)((float)-v18 * v16));
  if (v20 >= 0.0) {
    float v22 = v20;
  }
  float v23 = *((float *)this + 50);
  uint64_t v24 = 188;
  if (v23 < v22) {
    uint64_t v24 = 184;
  }
  float v25 = *(float *)((char *)this + v24);
  float v26 = v22 - v23;
  float v27 = v23 + (float)(v25 * v26);
  *((float *)this + 50) = v27;
  if (v14 < v27) {
    float v14 = v23 + (float)(v25 * v26);
  }
  float v28 = *((float *)this + 55) + (float)(*((float *)this + 54) * (float)((float)(v15 * v14) - *((float *)this + 55)));
  *((float *)this + 55) = v28;
  *((float *)this + 19) = v21 * v28;
  CFIndex v29 = (clsp::CLSP_Log **)*((void *)this + 40);
  CFStringRef v30 = *v29;
  if (*v29)
  {
    float __src = a3;
    clsp::CLSP_Log::LogCLSPData(v30, &__src, 1);
    CFIndex v29 = (clsp::CLSP_Log **)*((void *)this + 40);
  }
  double v31 = v29[2];
  if (v31)
  {
    float __src = v9;
    clsp::CLSP_Log::LogCLSPData(v31, &__src, 1);
    CFIndex v29 = (clsp::CLSP_Log **)*((void *)this + 40);
    double v32 = v29[2];
    if (v32)
    {
      float __src = v13;
      clsp::CLSP_Log::LogCLSPData(v32, &__src, 1);
      CFIndex v29 = (clsp::CLSP_Log **)*((void *)this + 40);
      double v33 = v29[2];
      if (v33)
      {
        float __src = v21;
        clsp::CLSP_Log::LogCLSPData(v33, &__src, 1);
        CFIndex v29 = (clsp::CLSP_Log **)*((void *)this + 40);
        float32x4_t v34 = v29[2];
        if (v34)
        {
          float __src = v28;
          clsp::CLSP_Log::LogCLSPData(v34, &__src, 1);
          CFIndex v29 = (clsp::CLSP_Log **)*((void *)this + 40);
        }
      }
    }
  }
  float v35 = *v29;
  if (*v29)
  {
    float __src = v20;
    clsp::CLSP_Log::LogCLSPData(v35, &__src, 1);
    float32x4_t v36 = (clsp::CLSP_Log *)**((void **)this + 40);
    if (v36)
    {
      float __src = v27;
      clsp::CLSP_Log::LogCLSPData(v36, &__src, 1);
      long long v37 = (clsp::CLSP_Log *)**((void **)this + 40);
      if (v37)
      {
        float __src = *((float *)this + 19);
        clsp::CLSP_Log::LogCLSPData(v37, &__src, 1);
        float32x4_t v38 = (clsp::CLSP_Log *)**((void **)this + 40);
        if (v38)
        {
          long long v39 = (float *)(*(uint64_t (**)(clsp::DisplacementController *))(*(void *)this + 128))(this);
          float __src = log10f(v39[21]* (float)((float)((float)((float)(1.0 - v39[12]) + v39[13])* (float)((float)(v39[14] + v39[15]) + v39[16]))/ (float)((float)(v39[12] + 1.0) + v39[13])))* 20.0;
          clsp::CLSP_Log::LogCLSPData(v38, &__src, 1);
        }
      }
    }
  }
  return *((float *)this + 19);
}

void clsp::DisplacementController::processSample(clsp::DisplacementController *this, float a2, float a3)
{
  if (*((unsigned char *)this + 64))
  {
    float v5 = *((float *)this + 19);
    if (v5 >= *((float *)this + 62)) {
      float v5 = *((float *)this + 62);
    }
    float v6 = *((float *)this + 56) + (float)(*((float *)this + 57) * v5);
    float v7 = *((float *)this + 58);
    float v8 = *((float *)this + 59) + (float)(*((float *)this + 60) * v5);
    float v9 = v5 * v5;
    float v10 = v8 + (float)(*((float *)this + 61) * v9);
    *((float *)this + 68) = v6 + (float)(v7 * v9);
    *((float *)this + 69) = v10;
    float v11 = *(clsp::CLSP_Log **)(*((void *)this + 32) + 16);
    if (v11)
    {
      float __src = v6 + (float)(v7 * v9);
      clsp::CLSP_Log::LogCLSPData(v11, &__src, 1);
      uint64_t v12 = *(clsp::CLSP_Log **)(*((void *)this + 32) + 16);
      if (v12)
      {
        float v17 = v10;
        clsp::CLSP_Log::LogCLSPData(v12, &v17, 1);
      }
    }
    float v13 = *((float *)this + 73);
    float v14 = *((float *)this + 75);
    float v15 = (float)((float)((float)((float)(*((float *)this + 71) * v13) + (float)(a3 * *((float *)this + 70)))
                        + (float)(*((float *)this + 74) * *((float *)this + 72)))
                - (float)(v14 * *((float *)this + 68)))
        - (float)(*((float *)this + 76) * *((float *)this + 69));
    *((float *)this + 73) = a3;
    *((float *)this + 74) = v13;
    *((float *)this + 75) = v15;
    *((float *)this + 76) = v14;
  }
}

uint64_t clsp::DisplacementController::calcCoeffsSyncDisp(clsp::DisplacementController *this, double a2, double a3, double a4, double a5, double a6, double a7)
{
  clsp::DisplacementModelSealed::calcCoeffs(*((double **)this + 15), (float *)this + 20, a2, a4, a3, a7);
  float v13 = *((float *)this + 25);
  float v14 = *((float *)this + 26);
  uint64_t v15 = *((void *)this + 10);
  *((_DWORD *)this + 70) = 1065353216;
  *((float *)this + 71) = v13;
  *((float *)this + 72) = v14;
  *((void *)this + 34) = v15;
  float v16 = 1.0 / (1.0 - v13 + v14);
  *((float *)this + 77) = v16;

  return clsp::LFSNFeedbackCoeffCalc::calcCoeffs((clsp::DisplacementController *)((char *)this + 224), a2, a3, a4, a5, 1.0, a6);
}

float clsp::DisplacementModelSealed::calcCoeffs(double *a1, float *a2, double a3, double a4, double a5, double a6)
{
  double v11 = 1.0 / a3;
  double v12 = -(1.0 / a3 * a5);
  long double v13 = exp(v12 / (a4 + a4)) * -2.0;
  long double v14 = v13 * cos(v11 * a5 * sqrt(1.0 / (a4 * -4.0 * a4) + 1.0));
  long double v15 = exp(v12 / a4);
  float v16 = (v15 + v14 + 1.0) * (a6 * 1000.0 * a1[1] / (*a1 * a1[4]));
  float v17 = v14;
  float result = v15;
  *a2 = v17;
  a2[1] = result;
  a2[2] = v16;
  return result;
}

float clsp::DisplacementController::calcCoeffs(clsp::DisplacementController *this, double a2, double a3)
{
  float v6 = clsp::DisplacementModelSealed::calcCoeffsFLV(*((double **)this + 15), (float *)this + 25, a2, a3);
  float v7 = (double *)*((void *)this + 15);
  double v8 = (*(double (**)(clsp::DisplacementController *, float))(*(void *)this + 72))(this, v6);
  double v9 = (*(double (**)(clsp::DisplacementController *))(*(void *)this + 40))(this);
  float v10 = clsp::DisplacementModelSealed::calcCoeffs(v7, (float *)this + 20, a2, v8, sqrt(v7[4] / v7[2]) / sqrt(v9), a3);
  double v11 = (double *)*((void *)this + 15);
  double v12 = (*(double (**)(clsp::DisplacementController *, float))(*(void *)this + 72))(this, v10);
  double v13 = (*(double (**)(clsp::DisplacementController *))(*(void *)this + 40))(this);
  double v14 = (*(double (**)(clsp::DisplacementController *))(*(void *)this + 56))(this);
  clsp::LFSN::calcCoeffs((uint64_t)this + 224, v11, a2, *((double *)this + 10), *((float *)this + 25), *((float *)this + 26), v12, v13, v14, a3);
  clsp::AttackRelease<float,double>::calcCoeffs((uint64_t)this + 128, a2);
  clsp::AttackRelease<float,double>::calcCoeffs((uint64_t)this + 168, a2);
  double v15 = *((double *)this + 7);
  *((double *)this + 26) = v15;
  double v16 = v15 * a2;
  double v17 = 0.0;
  if (v16 >= 0.00001) {
    double v17 = exp(-4.60517019 / v16);
  }
  float v18 = 1.0 - v17;
  *((float *)this + 54) = v18;
  double v19 = *((double *)this + 3);
  float v20 = v19;
  float result = 1.0 / v19;
  *((float *)this + 17) = v20;
  *((float *)this + 18) = result;
  return result;
}

float clsp::DisplacementController::getAttenuationFactor(clsp::DisplacementController *this)
{
  return *((float *)this + 19);
}

uint64_t clsp::DisplacementController::setAttenuationFactor(uint64_t this, float a2)
{
  *(float *)(this + 76) = a2;
  return this;
}

uint64_t clsp::DisplacementController::getDispEnabled(clsp::DisplacementController *this)
{
  return *((unsigned __int8 *)this + 64);
}

uint64_t clsp::DisplacementController::setDispEnabled(uint64_t this, char a2)
{
  *(unsigned char *)(this + 64) = a2;
  return this;
}

uint64_t clsp::DisplacementController::getLFSN(clsp::DisplacementController *this)
{
  return (uint64_t)this + 224;
}

double clsp::DisplacementController::getFlvSmoothingTime(clsp::DisplacementController *this)
{
  return *((double *)this + 7);
}

uint64_t clsp::DisplacementController::setFlvSmoothingTime(uint64_t this, double a2)
{
  *(double *)(this + 56) = a2;
  return this;
}

double clsp::DisplacementController::getPeakDecayTime(clsp::DisplacementController *this)
{
  return *((double *)this + 6);
}

double *clsp::DisplacementController::setPeakDecayTime(double *this, double a2)
{
  this[6] = a2;
  this[17] = a2;
  this[22] = a2;
  return this;
}

double clsp::DisplacementController::getPeakAttackTime(clsp::DisplacementController *this)
{
  return *((double *)this + 5);
}

double *clsp::DisplacementController::setPeakAttackTime(double *this, double a2)
{
  this[5] = a2;
  this[16] = a2;
  this[21] = a2;
  return this;
}

double clsp::DisplacementController::getQ_d(clsp::DisplacementController *this)
{
  return *((double *)this + 4);
}

uint64_t clsp::DisplacementController::setQ_d(uint64_t this, double a2)
{
  *(double *)(this + 32) = a2;
  return this;
}

double clsp::DisplacementController::getX_lim(clsp::DisplacementController *this)
{
  return *((double *)this + 3);
}

uint64_t clsp::DisplacementController::setX_lim(uint64_t this, double a2)
{
  *(double *)(this + 24) = a2;
  return this;
}

double clsp::DisplacementController::getG_bw(clsp::DisplacementController *this)
{
  return *((double *)this + 2);
}

uint64_t clsp::DisplacementController::setG_bw(uint64_t this, double a2)
{
  *(double *)(this + 16) = a2;
  return this;
}

void clsp::DisplacementController::logCoeffs(uint64_t a1, uint64_t a2)
{
  float v4 = *(clsp::CLSP_Log **)a2;
  if (!*(void *)a2) {
    goto LABEL_10;
  }
  float v5 = *(double *)(a1 + 16);
  float __src = v5;
  clsp::CLSP_Log::LogCLSPData(v4, &__src, 1);
  float v6 = *(clsp::CLSP_Log **)a2;
  if (!*(void *)a2) {
    goto LABEL_10;
  }
  float v7 = *(double *)(a1 + 24);
  float __src = v7;
  clsp::CLSP_Log::LogCLSPData(v6, &__src, 1);
  double v8 = *(clsp::CLSP_Log **)a2;
  if (!*(void *)a2) {
    goto LABEL_10;
  }
  float v9 = *(double *)(a1 + 32);
  float __src = v9;
  clsp::CLSP_Log::LogCLSPData(v8, &__src, 1);
  float v10 = *(clsp::CLSP_Log **)a2;
  if (!*(void *)a2) {
    goto LABEL_10;
  }
  float v11 = *(double *)(a1 + 40);
  float __src = v11;
  clsp::CLSP_Log::LogCLSPData(v10, &__src, 1);
  double v12 = *(clsp::CLSP_Log **)a2;
  if (!*(void *)a2) {
    goto LABEL_10;
  }
  float v13 = *(double *)(a1 + 48);
  float __src = v13;
  clsp::CLSP_Log::LogCLSPData(v12, &__src, 1);
  double v14 = *(clsp::CLSP_Log **)a2;
  if (!*(void *)a2) {
    goto LABEL_10;
  }
  float v15 = *(double *)(a1 + 56);
  float __src = v15;
  clsp::CLSP_Log::LogCLSPData(v14, &__src, 1);
  double v16 = *(clsp::CLSP_Log **)a2;
  if (*(void *)a2
    && (float __src = *(float *)(a1 + 68), clsp::CLSP_Log::LogCLSPData(v16, &__src, 1),
                                     (double v17 = *(clsp::CLSP_Log **)a2) != 0))
  {
    float __src = *(float *)(a1 + 72);
    clsp::CLSP_Log::LogCLSPData(v17, &__src, 1);
    float v18 = *(clsp::CLSP_Log **)a2;
  }
  else
  {
LABEL_10:
    float v18 = 0;
  }
  double v19 = (float *)(a1 + 80);
  float v20 = *(atomic_ullong **)(a2 + 8);
  v37[0] = v18;
  v37[1] = (clsp::CLSP_Log *)v20;
  if (v20)
  {
    atomic_fetch_add_explicit(v20 + 1, 1uLL, memory_order_relaxed);
    clsp::IIRTwoPole<float>::logCoeffs(v19, v37);
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v20);
  }
  else
  {
    clsp::IIRTwoPole<float>::logCoeffs(v19, v37);
  }
  float v21 = (float *)(a1 + 100);
  float v22 = *(atomic_ullong **)(a2 + 8);
  v36[0] = *(clsp::CLSP_Log **)a2;
  v36[1] = (clsp::CLSP_Log *)v22;
  if (v22)
  {
    atomic_fetch_add_explicit(v22 + 1, 1uLL, memory_order_relaxed);
    clsp::IIRTwoPole<float>::logCoeffs(v21, v36);
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v22);
  }
  else
  {
    clsp::IIRTwoPole<float>::logCoeffs(v21, v36);
  }
  uint64_t v23 = a1 + 128;
  uint64_t v24 = *(atomic_ullong **)(a2 + 8);
  v35[0] = *(clsp::CLSP_Log **)a2;
  v35[1] = (clsp::CLSP_Log *)v24;
  if (v24)
  {
    atomic_fetch_add_explicit(v24 + 1, 1uLL, memory_order_relaxed);
    clsp::AttackRelease<float,double>::logCoeffs(v23, v35);
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v24);
  }
  else
  {
    clsp::AttackRelease<float,double>::logCoeffs(v23, v35);
  }
  uint64_t v25 = a1 + 168;
  float v26 = *(atomic_ullong **)(a2 + 8);
  v34[0] = *(clsp::CLSP_Log **)a2;
  v34[1] = (clsp::CLSP_Log *)v26;
  if (v26)
  {
    atomic_fetch_add_explicit(v26 + 1, 1uLL, memory_order_relaxed);
    clsp::AttackRelease<float,double>::logCoeffs(v25, v34);
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v26);
  }
  else
  {
    clsp::AttackRelease<float,double>::logCoeffs(v25, v34);
  }
  uint64_t v27 = a1 + 208;
  float v28 = *(atomic_ullong **)(a2 + 8);
  v33[0] = *(clsp::CLSP_Log **)a2;
  v33[1] = (clsp::CLSP_Log *)v28;
  if (v28)
  {
    atomic_fetch_add_explicit(v28 + 1, 1uLL, memory_order_relaxed);
    clsp::ExponentialSmoother<float,double>::logCoeffs(v27, v33);
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v28);
  }
  else
  {
    clsp::ExponentialSmoother<float,double>::logCoeffs(v27, v33);
  }
  CFIndex v29 = (float *)(a1 + 224);
  CFStringRef v30 = *(clsp::CLSP_Log **)a2;
  double v31 = *(std::__shared_weak_count **)(a2 + 8);
  v32[0] = v30;
  v32[1] = v31;
  if (v31)
  {
    atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
    clsp::LFSN::logCoeffs(v29, (uint64_t)v32);
    std::__shared_weak_count::__release_shared[abi:ne180100](v31);
  }
  else
  {
    clsp::LFSN::logCoeffs(v29, (uint64_t)v32);
  }
}

void *clsp::DisplacementController::dump(uint64_t a1, void *a2)
{
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"g_bw = ", 7);
  float v4 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)"\nx_liuint64_t m = ", 9);
  float v5 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"\nQ_d = ", 7);
  float v6 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)"\npeakAttackTime = ", 18);
  float v7 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)"\npeakDecayTime = ", 17);
  double v8 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)"\nflvSmoothingTime = ", 20);
  float v9 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)"\nmc_x_liuint64_t m = ", 12);
  float v10 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)"\ninvxliuint64_t m = ", 11);
  float v11 = (void *)std::ostream::operator<<();
  double v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)"\n\nptp:\n", 7);
  clsp::IIRTwoPole<float>::dump(a1 + 80, v12);
  float v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)"\nflv:\n", 6);
  clsp::IIRTwoPole<float>::dump(a1 + 100, v13);
  double v14 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)"\nptpAtkRel:\n", 12);
  clsp::AttackRelease<float,double>::dump(a1 + 128, v14);
  float v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)"\nflvTime:\n", 10);
  clsp::AttackRelease<float,double>::dump(a1 + 168, v15);
  double v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)"\nflvSmoother:\n", 14);
  clsp::ExponentialSmoother<float,double>::dump(a1 + 208, v16);
  double v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)"\nlfsn:\n", 7);
  clsp::LFSN::dump(a1 + 224, v17);
  return a2;
}

void clsp::DisplacementController::~DisplacementController(clsp::DisplacementController *this)
{
  clsp::DisplacementController::~DisplacementController(this);

  JUMPOUT(0x1C185D370);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;

  *(void *)this = &unk_1F14BE680;
  float64x2_t v2 = (std::__shared_weak_count *)*((void *)this + 41);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  float64x2_t v3 = (std::__shared_weak_count *)*((void *)this + 33);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
}

uint64_t clsp::LFSNFeedbackCoeffCalc::calcCoeffs(clsp::LFSNFeedbackCoeffCalc *this, double a2, double a3, double a4, double a5, double a6, double a7)
{
  uint64_t v9 = 0;
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (a7 <= a6) {
    a7 = a6;
  }
  double v24 = a7 * 1.5;
  uint64_t v36 = 0;
  memset(__A, 0, sizeof(__A));
  uint64_t v34 = 0;
  memset(v33, 0, sizeof(v33));
  uint64_t v32 = 0;
  memset(v31, 0, sizeof(v31));
  int v30 = 0;
  uint64_t v29 = 0;
  memset(v28, 0, 12);
  double v26 = 1.0 / sqrt(a5) * a3;
  double v27 = (a7 * 1.5 - a6) / 9.0;
  double v10 = 1.0 / a2;
  double v25 = -(1.0 / a2);
  double v11 = a4 + a4;
  double v13 = sqrt(1.0 / (a4 * -4.0 * a4) + 1.0);
  do
  {
    float v14 = a6 + (double)(int)v9 * v27;
    *((float *)__A + v9) = v14;
    double v15 = v26 * sqrt(v14 / a6);
    double v16 = v15 * v25;
    long double v17 = exp(v15 * v25 / v11) * -2.0;
    long double v18 = cos(v13 * (v10 * v15)) * v17;
    long double v19 = exp(v16 / a4);
    float v20 = v18;
    *((float *)v33 + v9) = v20;
    *(float *)&long double v19 = v19;
    *((_DWORD *)v31 + v9++) = LODWORD(v19);
  }
  while (v9 != 10);
  clsp::polyfit<10ul,2ul>((const float *)__A, (const float *)v33, (float *)&v29);
  uint64_t result = clsp::polyfit<10ul,2ul>((const float *)__A, (const float *)v31, (float *)v28);
  *(_DWORD *)this = v30;
  v22.i64[0] = v29;
  v22.i64[1] = *(void *)((char *)v28 + 4);
  *(int32x4_t *)((char *)this + 4) = vrev64q_s32(v22);
  float v23 = v24;
  *((_DWORD *)this + 5) = v28[0];
  *((float *)this + 6) = v23;
  return result;
}

uint64_t clsp::polyfit<10ul,2ul>(const float *__A, const float *a2, float *a3)
{
  uint64_t v6 = 0;
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  uint64_t v52 = 0;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v45 = 0u;
  do
  {
    float v7 = (_DWORD *)((char *)&v45 + v6);
    *float v7 = 1065353216;
    v7[10] = 1065353216;
    v7[20] = 1065353216;
    v6 += 4;
  }
  while (v6 != 40);
  for (uint64_t i = 0; i != -80; i -= 40)
    vDSP_vmul(__A, 1, (const float *)((char *)&v50 + i), 1, (float *)((char *)&v47 + i + 8), 1, 0xAuLL);
  int v44 = 0;
  memset(v43, 0, sizeof(v43));
  long long v39 = v49;
  long long v40 = v50;
  long long v41 = v51;
  uint64_t v42 = v52;
  long long __a = v45;
  long long v36 = v46;
  long long v37 = v47;
  long long v38 = v48;
  __tau[2] = 0.0;
  *(void *)__tau = 0;
  __work[2] = 0.0;
  *(void *)__woruint64_t k = 0;
  uint64_t v9 = 3;
  __lworuint64_t k = 3;
  __CLPK_integer __info = 0;
  __uint64_t n = 3;
  __CLPK_integer __lda = 10;
  p_a = &__a;
  sgeqrf_(&__lda, &__n, (__CLPK_real *)&__a, &__lda, __tau, __work, &__lwork, &__info);
  uint64_t v11 = 0;
  double v12 = v43;
  do
  {
    double v13 = (int *)p_a;
    float v14 = v12;
    uint64_t v15 = v9;
    do
    {
      int v16 = *v13;
      v13 += 10;
      _DWORD *v14 = v16;
      v14 += 3;
      --v15;
    }
    while (v15);
    ++v11;
    --v9;
    ++v12;
    p_a = (long long *)((char *)p_a + 44);
  }
  while (v11 != 3);
  long long v29 = v39;
  long long v30 = v40;
  long long v31 = v41;
  uint64_t v32 = v42;
  *(_OWORD *)__Aa = __a;
  long long v26 = v36;
  long long v27 = v37;
  long long v28 = v38;
  sorgqr_(&__lda, &__n, &__n, __Aa, &__lda, __tau, __work, &__lwork, &__info);
  cblas_sgemv(CblasColMajor, CblasTrans, __lda, __n, 1.0, __Aa, __lda, a2, 1, 0.0, a3, 1);
  int v24 = 0;
  *(void *)__ipiv = 0;
  __CLPK_integer __nrhs = 1;
  return sgesv_(&__n, &__nrhs, (__CLPK_real *)v43, &__n, __ipiv, a3, &__n, &__info);
}

void *allocMatrix(int a1, int a2)
{
  size_t v4 = 8 * a1;
  float v5 = malloc_type_malloc(v4, 0x2C8E6D5CuLL);
  uint64_t v6 = v5;
  if (a1 && !v5) {
    goto LABEL_9;
  }
  bzero(v5, v4);
  if (a1 >= 1)
  {
    size_t v7 = 4 * a2;
    uint64_t v8 = a1;
    for (uint64_t i = v6; ; ++i)
    {
      double v10 = malloc_type_malloc(v7, 0x2C8E6D5CuLL);
      uint64_t v11 = v10;
      if (v7)
      {
        if (!v10) {
          break;
        }
      }
      bzero(v10, v7);
      *uint64_t i = v11;
      if (!--v8) {
        return v6;
      }
    }
LABEL_9:
    exceptiouint64_t n = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    float v14 = std::bad_alloc::bad_alloc(exception);
  }
  return v6;
}

void freeMatrix(int a1, float ***a2)
{
  float64x2_t v2 = (void **)*a2;
  if (*a2)
  {
    if (a1 < 1) {
      goto LABEL_8;
    }
    uint64_t v4 = a1;
    do
    {
      if (*v2)
      {
        free(*v2);
        *float64x2_t v2 = 0;
      }
      ++v2;
      --v4;
    }
    while (v4);
    float64x2_t v2 = (void **)*a2;
    if (*a2)
    {
LABEL_8:
      free(v2);
      *a2 = 0;
    }
  }
}

void ASAFrontEnd::createLifterResponse(ASAFrontEnd *this, float *a2, int32x2_t a3, double a4)
{
  if (a2)
  {
    uint64_t v5 = 0;
    uint64x2_t v24 = (uint64x2_t)vdupq_n_s64((unint64_t)a2 - 1);
    uint64x2_t v6 = (uint64x2_t)xmmword_1BB872720;
    double v7 = 3.14159265 / (float)((float)a2 + -1.0);
    *(float *)&double v7 = v7;
    float v22 = *(float *)&v7;
    int64x2_t v23 = vdupq_n_s64(2uLL);
    *(float *)&a4 = 1.0 / (float)a2;
    *(float *)&double v7 = 1.0 - *(float *)&a4;
    float32x2_t v8 = (float32x2_t)vdup_lane_s32(a3, 0);
    float32x2_t v9 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v7, 0);
    uint64_t v10 = (a2 + 1) & 0x1FFFFFFFELL;
    float32x2_t v11 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a4, 0);
    __asm
    {
      FMOV            V12.2S, #-1.0
      FMOV            V13.2S, #1.0
    }
    do
    {
      int32x2_t v27 = vmovn_s64((int64x2_t)vcgeq_u64(v24, v6));
      int64x2_t v28 = (int64x2_t)v6;
      v18.i32[0] = v5;
      v18.i32[1] = v5 + 1;
      float32x2_t v19 = vmul_n_f32(vcvt_f32_u32(v18), v22);
      float v25 = v19.f32[0];
      float v26 = sinf(v19.f32[1]);
      v20.f32[0] = sinf(v25);
      v20.f32[1] = v26;
      float32x2_t v21 = vmla_f32(v11, v9, vmla_f32(_D13, vmla_f32(_D12, (float32x2_t)0x4000000040000000, v20), v8));
      if (v27.i8[0]) {
        *((_DWORD *)this + v5) = v21.i32[0];
      }
      if (v27.i8[4]) {
        *((_DWORD *)this + v5 + 1) = v21.i32[1];
      }
      v5 += 2;
      uint64x2_t v6 = (uint64x2_t)vaddq_s64(v28, v23);
    }
    while (v10 != v5);
  }
}

void VADGenUtils::ComputeProjectionComponent<double>(const double *a1, double *a2, vDSP_Length a3, vDSP_Length a4)
{
  vDSP_Length v4 = a3 * a3;
  if ((a3 * a3) >> 61) {
    goto LABEL_16;
  }
  float32x2_t v9 = (double *)malloc_type_malloc(8 * v4, 0x2C8E6D5CuLL);
  uint64_t v10 = v9;
  if (a3)
  {
    if (!v9) {
      goto LABEL_16;
    }
  }
  bzero(v9, 8 * v4);
  vDSP_Length v11 = a4 * a3;
  if ((a4 * a3) >> 61) {
    goto LABEL_16;
  }
  double v12 = (double *)malloc_type_malloc(8 * v11, 0x2C8E6D5CuLL);
  double v13 = v12;
  if (v11)
  {
    if (!v12) {
      goto LABEL_16;
    }
  }
  bzero(v12, 8 * v11);
  vDSP_mtransD(a1, 1, v13, 1, a4, a3);
  vDSP_mmulD(a1, 1, v13, 1, v10, 1, a3, a3, a4);
  __CLPK_integer __lda = a3;
  __CLPK_integer __info = 0;
  if ((a3 & 0x80000000) != 0) {
    goto LABEL_16;
  }
  float v14 = (__CLPK_integer *)malloc_type_malloc(4 * a3, 0x2C8E6D5CuLL);
  uint64_t v15 = v14;
  if (a3)
  {
    if (!v14) {
      goto LABEL_16;
    }
  }
  bzero(v14, 4 * a3);
  __lworuint64_t k = 2 * v4;
  if (((v4 << 33) & 0x8000000000000000) != 0
    || (v16 = (__CLPK_doublereal *)malloc_type_malloc((16 * v4) & 0x7FFFFFFFFLL, 0x2C8E6D5CuLL), long double v17 = v16, v4 << 33)
    && !v16)
  {
LABEL_16:
    exceptiouint64_t n = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    float32x2_t v19 = std::bad_alloc::bad_alloc(exception);
  }
  bzero(v16, (16 * v4) & 0x7FFFFFFFFLL);
  dgetrf_(&__lda, &__lda, v10, &__lda, v15, &__info);
  dgetri_(&__lda, v10, &__lda, v15, v17, &__lwork, &__info);
  free(v17);
  free(v15);
  vDSP_mmulD(v13, 1, v10, 1, a2, 1, a4, a3, a3);
  free(v13);

  free(v10);
}

void *ASAFrontEnd::genericComputeMagnitudeSpectrum(ASAFrontEnd *this, const float *__B, float *__C, vDSP_Length __N, unsigned int a5, void **a6, void **a7, float *a8)
{
  unsigned int v11 = __N;
  vDSP_Length v13 = __N;
  vDSP_vmul((const float *)this, 1, __B, 1, __C, 1, __N);
  uint64_t v14 = v11;
  uint64_t v15 = &__C[v14];
  bzero(&__C[v14], v14 * 4);
  v17.realp = __C;
  v17.imagp = v15;
  MultiRadixFFT_CplxInPlaceTransform(*a6, &v17.realp, 1);
  vDSP_zvabs(&v17, 1, __C, 1, v13);
  return memcpy(a7, __C, 4 * a5);
}

uint64_t Crossover2f::Crossover2f(uint64_t a1, long long *a2, double a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_DWORD *)(a1 + 32) = 2;
  *(double *)(a1 + 40) = a3;
  uint64_t v5 = (_OWORD *)(a1 + 48);
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 48), *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v6 = *a2;
    *(void *)(a1 + 64) = *((void *)a2 + 2);
    _OWORD *v5 = v6;
  }
  if (getScottyLog(void)::onceToken != -1) {
    dispatch_once(&getScottyLog(void)::onceToken, &__block_literal_global_33998);
  }
  double v7 = getScottyLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getScottyLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
  {
    float32x2_t v8 = v5;
    if (*(char *)(a1 + 71) < 0) {
      float32x2_t v8 = *(_OWORD **)v5;
    }
    int __p = 136315394;
    __p_4 = v8;
    __int16 __p_12 = 2080;
    __p_14 = "Crossover2f";
    _os_log_impl(&dword_1BB0CE000, v7, OS_LOG_TYPE_DEFAULT, "[%s|%s] Constructing", (uint8_t *)&__p, 0x16u);
  }
  if (a3 > 0.0) {
    operator new();
  }
  if (getScottyLog(void)::onceToken != -1) {
    dispatch_once(&getScottyLog(void)::onceToken, &__block_literal_global_33998);
  }
  float32x2_t v9 = getScottyLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getScottyLog(void)::gLog, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(a1 + 71) < 0) {
      uint64_t v5 = *(_OWORD **)v5;
    }
    int __p = 136315394;
    __p_4 = v5;
    __int16 __p_12 = 2080;
    __p_14 = "Crossover2f";
    _os_log_error_impl(&dword_1BB0CE000, v9, OS_LOG_TYPE_ERROR, "[%s|%s] Invalid number of channels and/or sample rate", (uint8_t *)&__p, 0x16u);
  }
  return a1;
}

void sub_1BB39DA84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  MEMORY[0x1C185D370](v19, 0x10B2C40677E12FCLL);
  if (*(char *)(v14 + 71) < 0) {
    operator delete(*v15);
  }
  std::unique_ptr<ParametricFilters>::reset[abi:ne180100](v18, 0);
  std::unique_ptr<ParametricFilters>::reset[abi:ne180100](v17, 0);
  std::unique_ptr<ParametricFilters>::reset[abi:ne180100](v16, 0);
  std::unique_ptr<ParametricFilters>::reset[abi:ne180100]((void ***)v14, 0);
  _Unwind_Resume(a1);
}

void Crossover2f::CalculateCrossoverCoeffs(int a1, double **a2, double **a3, double a4, double a5)
{
  v97[1] = *MEMORY[0x1E4F143B8];
  if (a4 <= 0.0)
  {
    if (getScottyLog(void)::onceToken != -1) {
      dispatch_once(&getScottyLog(void)::onceToken, &__block_literal_global_33998);
    }
    uint64_t v10 = getScottyLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getScottyLog(void)::gLog, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float v96 = 136315138;
      *(void *)&v96[4] = "CalculateCrossoverCoeffs";
      _os_log_error_impl(&dword_1BB0CE000, v10, OS_LOG_TYPE_ERROR, "%s: Invalid sample rate and/or order", v96, 0xCu);
    }
  }
  else
  {
    a2[1] = *a2;
    a3[1] = *a3;
    switch(a1)
    {
      case 1:
        uint64_t v9 = 1;
        goto LABEL_11;
      case 2:
        uint64_t v11 = 0x100000001;
        goto LABEL_13;
      case 3:
        uint64_t v11 = 0x300000001;
LABEL_13:
        v97[0] = v11;
        _Q0 = xmmword_1BB879E30;
        goto LABEL_14;
      case 4:
        uint64_t v9 = 0x200000002;
LABEL_11:
        v97[0] = v9;
        __asm { FMOV            V0.2D, #1.0 }
LABEL_14:
        *(_OWORD *)float v96 = _Q0;
        break;
      default:
        if (getScottyLog(void)::onceToken != -1) {
          dispatch_once(&getScottyLog(void)::onceToken, &__block_literal_global_33998);
        }
        float32x2_t v76 = getScottyLog(void)::gLog;
        if (os_log_type_enabled((os_log_t)getScottyLog(void)::gLog, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)float v96 = 136315138;
          *(void *)&v96[4] = "CalculateCrossoverCoeffs";
          _os_log_error_impl(&dword_1BB0CE000, v76, OS_LOG_TYPE_ERROR, "%s: Invalid or unhandled filter order", v96, 0xCu);
        }
        v97[0] = 0;
        break;
    }
    uint64_t v17 = 0;
    double v18 = a5 / (a4 * 0.5) * 3.14159265;
    double v19 = v18 * 2.0 + 4.0 + v18 * v18;
    double v20 = (v18 + v18) * v18 + -8.0;
    double v21 = v18 * -2.0 + 4.0 + v18 * v18;
    double v22 = sqrt((v21 + v19 + v20) * (v21 + v19 + v20) * 0.0625);
    double v84 = (v22 + v22) / v19;
    double v85 = v22 / v19;
    double v82 = v21 / v19;
    double v83 = v20 / v19;
    double v23 = 1.0 / v18 * 2.0 + 1.0;
    double v24 = 1.0 / v18 * 4.0;
    double v25 = v23 + v24 * (1.0 / v18);
    double v26 = 1.0 / v18 * -8.0 * (1.0 / v18) + 2.0;
    double v27 = 1.0 / v18 * -2.0 + 1.0;
    double v28 = v27 + v24 * (1.0 / v18);
    double v29 = sqrt((v28 + v25 - v26) * (v28 + v25 - v26) * 0.00390625);
    double v81 = v29 * 4.0 / v25;
    double v79 = v26 / v25;
    double v80 = v29 * -8.0 / v25;
    double __x = v18 * 0.5;
    double v78 = v28 / v25;
    double v30 = v18 + 2.0;
    double v31 = v18 + -2.0;
    double v89 = v31 / v30;
    double v90 = sqrt((v30 + v31) * (v30 + v31) * 0.25) / v30;
    double v32 = sqrt((v23 - v27) * (v23 - v27) * 0.0625);
    double v87 = v32 * -2.0 / v23;
    double v88 = (v32 + v32) / v23;
    char v33 = 1;
    double v86 = v27 / v23;
    do
    {
      char v34 = v33;
      double v35 = 0.0;
      double v36 = v87;
      double v37 = v88;
      double v93 = 0.0;
      double v92 = v86;
      double v38 = v89;
      double v39 = v90;
      double v40 = v90;
      double v41 = 0.0;
      double v42 = 0.0;
      switch(*((_DWORD *)v97 + v17))
      {
        case 0:
          break;
        case 1:
          goto LABEL_19;
        case 2:
          long double v43 = tan(__x);
          long double v44 = 1.0 / v43;
          double v40 = 1.0 / (1.0 / v43 * 1.41421356 + 1.0 + v44 * v44);
          double v39 = v40 + v40;
          double v38 = (1.0 - v44 * v44 + 1.0 - v44 * v44) * v40;
          double v42 = (1.0 / v43 * -1.41421356 + 1.0 + v44 * v44) * v40;
          double v37 = 1.0 / (v43 * 1.41421356 + 1.0 + v43 * v43);
          double v36 = v37 * -2.0;
          double v92 = (v43 * v43 + -1.0 + v43 * v43 + -1.0) * v37;
          double v93 = (v43 * -1.41421356 + 1.0 + v43 * v43) * v37;
          double v35 = v37;
          double v41 = v40;
          goto LABEL_19;
        case 3:
          double v36 = v80;
          double v35 = v81;
          double v37 = v81;
          double v92 = v79;
          double v93 = v78;
          double v39 = v84;
          double v41 = v85;
          double v40 = v85;
          double v42 = v82;
          double v38 = v83;
LABEL_19:
          double v91 = v36;
          double v45 = *(double *)&v96[8 * v17];
          long long v47 = a2[1];
          unint64_t v46 = (unint64_t)a2[2];
          if ((unint64_t)v47 >= v46)
          {
            long long v49 = *a2;
            unint64_t v50 = 0xCCCCCCCCCCCCCCCDLL * (v47 - *a2);
            unint64_t v51 = v50 + 1;
            if (v50 + 1 > 0x666666666666666) {
              std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v52 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v46 - (void)v49) >> 3);
            if (2 * v52 > v51) {
              unint64_t v51 = 2 * v52;
            }
            if (v52 >= 0x333333333333333) {
              unint64_t v53 = 0x666666666666666;
            }
            else {
              unint64_t v53 = v51;
            }
            if (v53)
            {
              unint64_t v53 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<BiquadCoefficients>>(v53);
              long long v49 = *a2;
              long long v47 = a2[1];
            }
            else
            {
              uint64_t v54 = 0;
            }
            float v56 = (double *)(v53 + 40 * v50);
            double *v56 = v38;
            v56[1] = v42;
            v56[2] = v40;
            v56[3] = v39;
            v56[4] = v41;
            std::__fs::filesystem::path v57 = v56;
            if (v47 != v49)
            {
              do
              {
                long long v58 = *(_OWORD *)(v47 - 5);
                long long v59 = *(_OWORD *)(v47 - 3);
                *(v57 - 1) = *(v47 - 1);
                *(_OWORD *)(v57 - 3) = v59;
                *(_OWORD *)(v57 - 5) = v58;
                v57 -= 5;
                v47 -= 5;
              }
              while (v47 != v49);
              long long v49 = *a2;
            }
            long long v48 = v56 + 5;
            *a2 = v57;
            a2[1] = v56 + 5;
            a2[2] = (double *)(v53 + 40 * v54);
            if (v49) {
              operator delete(v49);
            }
          }
          else
          {
            double *v47 = v38;
            v47[1] = v42;
            v47[2] = v40;
            v47[3] = v39;
            long long v48 = v47 + 5;
            v47[4] = v41;
          }
          double v60 = v37 * v45;
          double v61 = v91 * v45;
          double v62 = v35 * v45;
          a2[1] = v48;
          std::string::size_type v64 = a3[1];
          unint64_t v63 = (unint64_t)a3[2];
          if ((unint64_t)v64 >= v63)
          {
            float32x4_t v66 = *a3;
            unint64_t v67 = 0xCCCCCCCCCCCCCCCDLL * (v64 - *a3);
            unint64_t v68 = v67 + 1;
            if (v67 + 1 > 0x666666666666666) {
              std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v69 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v63 - (void)v66) >> 3);
            if (2 * v69 > v68) {
              unint64_t v68 = 2 * v69;
            }
            if (v69 >= 0x333333333333333) {
              unint64_t v70 = 0x666666666666666;
            }
            else {
              unint64_t v70 = v68;
            }
            if (v70)
            {
              unint64_t v70 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<BiquadCoefficients>>(v70);
              float32x4_t v66 = *a3;
              std::string::size_type v64 = a3[1];
            }
            else
            {
              uint64_t v71 = 0;
            }
            float32x2_t v72 = (double *)(v70 + 40 * v67);
            *float32x2_t v72 = v92;
            v72[1] = v93;
            v72[2] = v60;
            v72[3] = v61;
            v72[4] = v62;
            float32x4_t v73 = v72;
            if (v64 != v66)
            {
              do
              {
                long long v74 = *(_OWORD *)(v64 - 5);
                long long v75 = *(_OWORD *)(v64 - 3);
                *(v73 - 1) = *(v64 - 1);
                *(_OWORD *)(v73 - 3) = v75;
                *(_OWORD *)(v73 - 5) = v74;
                v73 -= 5;
                v64 -= 5;
              }
              while (v64 != v66);
              float32x4_t v66 = *a3;
            }
            char v65 = v72 + 5;
            *a3 = v73;
            a3[1] = v72 + 5;
            a3[2] = (double *)(v70 + 40 * v71);
            if (v66) {
              operator delete(v66);
            }
          }
          else
          {
            *std::string::size_type v64 = v92;
            v64[1] = v93;
            v64[2] = v60;
            v64[3] = v61;
            char v65 = v64 + 5;
            v64[4] = v62;
          }
          a3[1] = v65;
          break;
        default:
          if (getScottyLog(void)::onceToken != -1) {
            dispatch_once(&getScottyLog(void)::onceToken, &__block_literal_global_33998);
          }
          unsigned __int8 v55 = getScottyLog(void)::gLog;
          if (os_log_type_enabled((os_log_t)getScottyLog(void)::gLog, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315138;
            uint64_t v95 = "CalculateCrossoverCoeffs";
            _os_log_error_impl(&dword_1BB0CE000, v55, OS_LOG_TYPE_ERROR, "%s: Invalid or unhandled filter type", buf, 0xCu);
          }
          break;
      }
      char v33 = 0;
      uint64_t v17 = 1;
    }
    while ((v34 & 1) != 0);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<BiquadCoefficients>>(unint64_t a1)
{
  if (a1 >= 0x666666666666667) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(40 * a1);
}

BOOL Crossover2f::IsLowCrossoverEnabled(Crossover2f *this)
{
  float64x2_t v2 = (ParametricFilters *)*((void *)this + 1);
  return v2
      && *(void *)this
      && ParametricFilters::isEnabled(v2)
      && ParametricFilters::isEnabled(*(ParametricFilters **)this);
}

BOOL Crossover2f::IsHighCrossoverEnabled(Crossover2f *this)
{
  float64x2_t v2 = (ParametricFilters *)*((void *)this + 3);
  return v2
      && *((void *)this + 2)
      && ParametricFilters::isEnabled(v2)
      && ParametricFilters::isEnabled(*((ParametricFilters **)this + 2));
}

void Crossover2f::SetLowCrossover(Crossover2f *this, double a2, int a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (getScottyLog(void)::onceToken != -1) {
    dispatch_once(&getScottyLog(void)::onceToken, &__block_literal_global_33998);
  }
  long long v6 = getScottyLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getScottyLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
  {
    double v7 = (void *)((char *)this + 48);
    if (*((char *)this + 71) < 0) {
      double v7 = (void *)*v7;
    }
    *(_DWORD *)buf = 136315906;
    *(void *)&uint8_t buf[4] = v7;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "SetLowCrossover";
    *(_WORD *)&buf[22] = 2048;
    double v17 = a2;
    __int16 v18 = 1024;
    int v19 = a3;
    _os_log_impl(&dword_1BB0CE000, v6, OS_LOG_TYPE_DEFAULT, "[%s|%s] Setting low crossover, inFC = %f, inOrder = %u", buf, 0x26u);
  }
  memset(buf, 0, sizeof(buf));
  memset(__p, 0, sizeof(__p));
  if (a2 > 0.0 && a3)
  {
    Crossover2f::CalculateCrossoverCoeffs(a3, (double **)buf, (double **)__p, *((double *)this + 5), a2);
    uint64_t v8 = *((void *)this + 1);
    if (v8)
    {
      uint64_t v11 = 0;
      uint64_t v12 = 0;
      uint64_t v13 = 0;
      ParametricFilters::setParametricFilters(v8, __p, &v11);
      uint64_t v15 = (void **)&v11;
      std::vector<std::__fs::filesystem::path>::__destroy_vector::operator()[abi:ne180100](&v15);
    }
    double v9 = *(double *)this;
    if (*(void *)this)
    {
      uint64_t v11 = 0;
      uint64_t v12 = 0;
      uint64_t v13 = 0;
      ParametricFilters::setParametricFilters(*(uint64_t *)&v9, buf, &v11);
      uint64_t v15 = (void **)&v11;
      std::vector<std::__fs::filesystem::path>::__destroy_vector::operator()[abi:ne180100](&v15);
    }
  }
  else
  {
    uint64_t v10 = (ParametricFilters *)*((void *)this + 1);
    if (v10) {
      ParametricFilters::clear(v10);
    }
    if (*(void *)this) {
      ParametricFilters::clear(*(ParametricFilters **)this);
    }
  }
  if (__p[0]) {
    operator delete(__p[0]);
  }
  if (*(void *)buf) {
    operator delete(*(void **)buf);
  }
}

void sub_1BB39E528(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  if (__p) {
    operator delete(__p);
  }
  if (a17) {
    operator delete(a17);
  }
  _Unwind_Resume(a1);
}

void Crossover2f::SetHighCrossover(Crossover2f *this, double a2, int a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (getScottyLog(void)::onceToken != -1) {
    dispatch_once(&getScottyLog(void)::onceToken, &__block_literal_global_33998);
  }
  long long v6 = getScottyLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getScottyLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
  {
    double v7 = (void *)((char *)this + 48);
    if (*((char *)this + 71) < 0) {
      double v7 = (void *)*v7;
    }
    *(_DWORD *)buf = 136315906;
    *(void *)&uint8_t buf[4] = v7;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "SetHighCrossover";
    *(_WORD *)&buf[22] = 2048;
    double v18 = a2;
    __int16 v19 = 1024;
    int v20 = a3;
    _os_log_impl(&dword_1BB0CE000, v6, OS_LOG_TYPE_DEFAULT, "[%s|%s] Setting high crossover, inFC = %f, inOrder = %u", buf, 0x26u);
  }
  memset(buf, 0, sizeof(buf));
  memset(__p, 0, sizeof(__p));
  if (a2 > 0.0 && a3)
  {
    Crossover2f::CalculateCrossoverCoeffs(a3, (double **)buf, (double **)__p, *((double *)this + 5), a2);
    uint64_t v8 = *((void *)this + 3);
    if (v8)
    {
      uint64_t v12 = 0;
      uint64_t v13 = 0;
      uint64_t v14 = 0;
      ParametricFilters::setParametricFilters(v8, __p, &v12);
      int v16 = (void **)&v12;
      std::vector<std::__fs::filesystem::path>::__destroy_vector::operator()[abi:ne180100](&v16);
    }
    uint64_t v9 = *((void *)this + 2);
    if (v9)
    {
      uint64_t v12 = 0;
      uint64_t v13 = 0;
      uint64_t v14 = 0;
      ParametricFilters::setParametricFilters(v9, buf, &v12);
      int v16 = (void **)&v12;
      std::vector<std::__fs::filesystem::path>::__destroy_vector::operator()[abi:ne180100](&v16);
    }
  }
  else
  {
    uint64_t v10 = (ParametricFilters *)*((void *)this + 2);
    if (v10) {
      ParametricFilters::clear(v10);
    }
    uint64_t v11 = (ParametricFilters *)*((void *)this + 3);
    if (v11) {
      ParametricFilters::clear(v11);
    }
  }
  if (__p[0]) {
    operator delete(__p[0]);
  }
  if (*(void *)buf) {
    operator delete(*(void **)buf);
  }
}

void sub_1BB39E740(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  if (__p) {
    operator delete(__p);
  }
  if (a17) {
    operator delete(a17);
  }
  _Unwind_Resume(a1);
}

uint64_t Crossover2f::Process(uint64_t this, float *const *a2, float **a3, float **a4, float **a5, int a6, vDSP_Length a7, int a8, float *const *a9)
{
  if (*(_DWORD *)(this + 32) != a6) {
    return this;
  }
  uint64_t v15 = (Crossover2f *)this;
  if (Crossover2f::IsLowCrossoverEnabled((Crossover2f *)this))
  {
    uint64_t v16 = *((void *)v15 + 1);
    if (v16) {
      ParametricFilters::process(v16, a2, a5, a7, 0);
    }
    if (!a8)
    {
      this = Crossover2f::IsHighCrossoverEnabled(v15);
      double v17 = a5;
      if ((this & 1) == 0) {
        return this;
      }
      goto LABEL_14;
    }
    double v17 = a5;
    if (*(void *)v15)
    {
      ParametricFilters::process(*(void *)v15, a2, a3, a7, 0);
      double v17 = a5;
    }
  }
  else
  {
    double v17 = a2;
  }
  this = Crossover2f::IsHighCrossoverEnabled(v15);
  if ((this & 1) == 0) {
    return this;
  }
  if (a8)
  {
    uint64_t v18 = *((void *)v15 + 3);
    if (v18) {
      ParametricFilters::process(v18, v17, a4, a7, 0);
    }
  }
LABEL_14:
  this = *((void *)v15 + 2);
  if (this)
  {
    return ParametricFilters::process(this, v17, a5, a7, 0);
  }
  return this;
}

ParametricFilters *Crossover2f::Reset(ParametricFilters **this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (getScottyLog(void)::onceToken != -1) {
    dispatch_once(&getScottyLog(void)::onceToken, &__block_literal_global_33998);
  }
  float64x2_t v2 = getScottyLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getScottyLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
  {
    float64x2_t v3 = this + 6;
    if (*((char *)this + 71) < 0) {
      float64x2_t v3 = (void *)*v3;
    }
    int v7 = 136315394;
    uint64_t v8 = v3;
    __int16 v9 = 2080;
    uint64_t v10 = "Reset";
    _os_log_impl(&dword_1BB0CE000, v2, OS_LOG_TYPE_DEFAULT, "[%s|%s] Resetting Crossover2f", (uint8_t *)&v7, 0x16u);
  }
  if (*this) {
    ParametricFilters::reset(*this);
  }
  vDSP_Length v4 = this[1];
  if (v4) {
    ParametricFilters::reset(v4);
  }
  uint64_t v5 = this[2];
  if (v5) {
    ParametricFilters::reset(v5);
  }
  uint64_t result = this[3];
  if (result) {
    return (ParametricFilters *)ParametricFilters::reset(result);
  }
  return result;
}

uint64_t AUNeuralNet::ValidFormat(AUNeuralNet *this, int a2, int a3, const AudioStreamBasicDescription *a4)
{
  if (a2 != 2)
  {
    if (a2 == 1 && !a3)
    {
      AudioFormatID mFormatID = a4->mFormatID;
      AudioFormatFlags mFormatFlags = a4->mFormatFlags;
      if (mFormatID == 1718773105)
      {
        int v24 = (mFormatFlags >> 5) & 1;
        if (a4->mBitsPerChannel != 64) {
          int v24 = 0;
        }
        if (mFormatFlags) {
          AudioFormatFlags v6 = v24;
        }
        else {
          AudioFormatFlags v6 = 0;
        }
      }
      else
      {
        AudioFormatFlags v6 = a4->mFormatFlags & 1;
        if (mFormatID != 1819304813) {
          AudioFormatFlags v6 = 0;
        }
      }
      BOOL v25 = a4->mChannelsPerFrame >= 0x11;
      goto LABEL_60;
    }
    return 0;
  }
  if (a3 == 1)
  {
    UInt32 mChannelsPerFrame = a4->mChannelsPerFrame;
    UInt32 mBitsPerChannel = a4->mBitsPerChannel;
    UInt32 mBytesPerPacket = a4->mBytesPerPacket;
    UInt32 mBytesPerFrame = a4->mBytesPerFrame;
    BOOL v14 = a4->mFormatID == 1819304813 && a4->mFramesPerPacket == 1;
    BOOL v17 = !v14 || mBytesPerFrame != mBytesPerPacket || mBitsPerChannel >> 3 > mBytesPerFrame || mChannelsPerFrame == 0;
    if (!v17
      && ((AudioFormatFlags v18 = a4->mFormatFlags, (v18 & 0x20) != 0)
       || (BOOL v14 = mBytesPerPacket == mBytesPerPacket / mChannelsPerFrame * mChannelsPerFrame,
           mBytesPerPacket /= mChannelsPerFrame,
           v14)))
    {
      int v19 = 8 * mBytesPerPacket;
      BOOL v20 = mBytesPerPacket == 4 && (a4->mFormatFlags & 0x1F84) == 0;
      if (v18)
      {
        BOOL v21 = (a4->mFormatFlags & 0x1F84) == 0;
      }
      else
      {
        BOOL v20 = 0;
        BOOL v21 = 1;
      }
      if (v19 == mBitsPerChannel)
      {
        int v22 = v21;
      }
      else
      {
        BOOL v20 = 0;
        int v22 = 1;
      }
      if ((v18 & 2) != 0)
      {
        BOOL v20 = 0;
        int v23 = 1;
      }
      else
      {
        int v23 = v22;
      }
    }
    else
    {
      BOOL v20 = 0;
      int v23 = 0;
    }
    BOOL v14 = mBitsPerChannel == 32;
    AudioFormatFlags v6 = v20 & v23;
    if (!v14) {
      AudioFormatFlags v6 = 0;
    }
  }
  else
  {
    if (a3) {
      return 0;
    }
    AudioFormatID v8 = a4->mFormatID;
    AudioFormatFlags v7 = a4->mFormatFlags;
    if (v8 == 1718773105)
    {
      int v26 = (v7 >> 5) & 1;
      if (a4->mBitsPerChannel != 64) {
        int v26 = 0;
      }
      if (v7) {
        AudioFormatFlags v6 = v26;
      }
      else {
        AudioFormatFlags v6 = 0;
      }
    }
    else
    {
      AudioFormatFlags v6 = a4->mFormatFlags & 1;
      if (v8 != 1819304813) {
        AudioFormatFlags v6 = 0;
      }
    }
    UInt32 mChannelsPerFrame = a4->mChannelsPerFrame;
  }
  BOOL v25 = mChannelsPerFrame >= 0x25;
LABEL_60:
  if (v25) {
    return 0;
  }
  else {
    return v6;
  }
}

uint64_t AUNeuralNet::SupportedNumChannels(AUNeuralNet *this, const AUChannelInfo **a2)
{
  uint64_t v2 = 0;
  float64x2_t v3 = &word_1E9F7DFAA;
  do
  {
    vDSP_Length v4 = v3;
    for (uint64_t i = 1; i != 37; ++i)
    {
      *(v4 - 1) = v2 + 1;
      __int16 *v4 = i;
      v4 += 2;
    }
    ++v2;
    v3 += 72;
  }
  while (v2 != 16);
  if (a2) {
    *a2 = (const AUChannelInfo *)&AUNeuralNet::SupportedNumChannels(AUChannelInfo const**)::sSupportedChannelConfigs;
  }
  return 576;
}

BOOL AUNeuralNet::StreamFormatWritable(AUNeuralNet *this, int a2)
{
  return (a2 - 1) <= 1 && *((unsigned char *)this + 17) == 0;
}

uint64_t AUNeuralNet::SupportsTail(AUNeuralNet *this)
{
  return 1;
}

double AUNeuralNet::GetTailTime(AUNeuralNet *this)
{
  return 0.0;
}

double AUNeuralNet::GetLatency(AUNeuralNet *this)
{
  uint64_t v1 = *((void *)this + 100);
  unsigned int v2 = *(unsigned __int8 *)(v1 + 96);
  if (*(unsigned char *)(v1 + 96)) {
    unsigned int v2 = *(_DWORD *)(v1 + 16);
  }
  if (*((unsigned char *)this + 1244))
  {
    if (*((_DWORD *)this + 312) == 2) {
      float64x2_t v3 = (_DWORD *)(*((void *)this + 158) + 92);
    }
    else {
      float64x2_t v3 = (_DWORD *)(v1 + 20);
    }
    v2 += *v3;
  }
  return (double)v2 / *(double *)v1;
}

uint64_t AUNeuralNet::GetParameterValueStrings(AUNeuralNet *this, int a2, int a3, const __CFArray **a4)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (!a4) {
    return 0;
  }
  if (a2) {
    return 4294956430;
  }
  if (a3 == 17)
  {
    *(_OWORD *)values = xmmword_1E623C7B8;
    *(void *)&long long v16 = @"LowDelay";
    CFArrayRef v10 = CFArrayCreate(0, (const void **)values, 3, 0);
  }
  else if (a3 == 6)
  {
    *(_OWORD *)values = xmmword_1E623C780;
    long long v16 = *(_OWORD *)algn_1E623C790;
    long long v17 = xmmword_1E623C7A0;
    uint64_t v18 = 0;
    for (uint64_t i = 1; i != 7; ++i)
    {
      std::to_string(&v12, i - 1);
      AudioFormatFlags v7 = std::string::insert(&v12, 0, "Model_", 6uLL);
      long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
      int64_t v14 = v7->__r_.__value_.__r.__words[2];
      *(_OWORD *)int __p = v8;
      v7->__r_.__value_.__l.__size_ = 0;
      v7->__r_.__value_.__r.__words[2] = 0;
      v7->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v12.__r_.__value_.__l.__data_);
      }
      if (v14 >= 0) {
        __int16 v9 = __p;
      }
      else {
        __int16 v9 = (void **)__p[0];
      }
      values[i] = (void *)CFStringCreateWithCString(0, (const char *)v9, 0x8000100u);
      if (SHIBYTE(v14) < 0) {
        operator delete(__p[0]);
      }
    }
    CFArrayRef v10 = CFArrayCreate(0, (const void **)values, 7, 0);
  }
  else
  {
    values[0] = @"Parameter Name Unimplemented";
    CFArrayRef v10 = CFArrayCreate(0, (const void **)values, 1, 0);
  }
  CFArrayRef v11 = v10;
  uint64_t result = 0;
  *a4 = v11;
  return result;
}

void sub_1BB39EDD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t AUNeuralNet::GetParameterInfo(AUNeuralNet *this, int a2, unsigned int a3, AudioUnitParameterInfo *buffer)
{
  buffer->AudioUnitParameterOptions flags = 0;
  buffer->unitName = 0;
  if (a2) {
    return 4294956430;
  }
  if (a3 > 0x1A) {
    return 4294956418;
  }
  CFStringRef v6 = (const __CFString *)*((void *)&off_1E623C810 + a3);
  UInt32 v7 = dword_1BB87EC0C[a3];
  AudioUnitParameterUnit v8 = dword_1BB87EC78[a3];
  AudioUnitParameterValue v9 = flt_1BB87ECE4[a3];
  AudioUnitParameterValue v10 = flt_1BB87ED50[a3];
  AudioUnitParameterValue v11 = flt_1BB87EDBC[a3];
  int v12 = dword_1BB87EE28[a3];
  buffer->cfNameString = v6;
  buffer->AudioUnitParameterOptions flags = 0x8000000;
  CFStringGetCString(v6, buffer->name, 52, 0x8000100u);
  uint64_t result = 0;
  buffer->clumpID = v7;
  AudioUnitParameterOptions flags = buffer->flags;
  buffer->unit = v8;
  buffer->minCFNumberRef Value = v9;
  buffer->maxCFNumberRef Value = v10;
  buffer->defaultCFNumberRef Value = v11;
  buffer->AudioUnitParameterOptions flags = flags | v12;
  return result;
}

uint64_t AUNeuralNet::GetParameterList(AUNeuralNet *this, int a2, unsigned int *a3, unsigned int *a4)
{
  if (a2) {
    return 4294956430;
  }
  if (a3)
  {
    *(_OWORD *)a3 = xmmword_1BB8727D0;
    *((_OWORD *)a3 + 1) = xmmword_1BB879D60;
    *((_OWORD *)a3 + 2) = xmmword_1BB879E40;
    *((_OWORD *)a3 + 3) = xmmword_1BB879E50;
    *((_OWORD *)a3 + 4) = xmmword_1BB879E60;
    *((_OWORD *)a3 + 5) = xmmword_1BB879E70;
    *((void *)a3 + 12) = 0x1900000018;
    a3[26] = 26;
  }
  uint64_t result = 0;
  *a4 = 27;
  return result;
}

uint64_t AUNeuralNet::SetBusCount(AUNeuralNet *this, int a2, unsigned int a3)
{
  if (a2 == 1 && a3 == 1)
  {
    float64x2_t v3 = (AUNeuralNet *)((char *)this + 80);
    unsigned int v4 = 1;
LABEL_7:
    ausdk::AUScope::SetNumberOfElements(v3, v4);
    return 0;
  }
  uint64_t v5 = 4294956445;
  if (a2 == 2 && a3 - 1 <= 1)
  {
    float64x2_t v3 = (AUNeuralNet *)((char *)this + 128);
    unsigned int v4 = a3;
    goto LABEL_7;
  }
  return v5;
}

BOOL AUNeuralNet::BusCountWritable(AUNeuralNet *this, int a2)
{
  return a2 == 2 && *((unsigned char *)this + 17) == 0;
}

uint64_t AUNeuralNet::Render(AUNeuralNet *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  v15[1] = *MEMORY[0x1E4F143B8];
  AudioUnitParameterUnit v8 = (AUNeuralNet *)((char *)this + 80);
  uint64_t Element = ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 80), 0);
  uint64_t v10 = ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 128), 0);
  unsigned int v13 = 0;
  AudioUnitParameterValue v11 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement(v8, 0);
  uint64_t result = ausdk::AUInputElement::PullInput(v11, &v13, a3, 0, a4);
  if (!result)
  {
    v15[0] = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(Element + 144));
    uint64_t BufferList = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v10 + 144));
    return (*(uint64_t (**)(AUNeuralNet *, unsigned int *, uint64_t, uint64_t, void *, uint64_t, uint64_t *))(*(void *)this + 184))(this, a2, a4, 1, v15, 1, &BufferList);
  }
  return result;
}

uint64_t AUNeuralNet::ProcessMultipleBufferLists(AUNeuralNet *this, unsigned int *a2, int a3, unsigned int a4, const AudioBufferList **a5, unsigned int a6, AudioBufferList **a7)
{
  LODWORD(v10) = a3;
  uint64_t v224 = *MEMORY[0x1E4F143B8];
  int v12 = (char *)*((void *)this + 85);
  if (*((char **)this + 86) == v12) {
    goto LABEL_32;
  }
  unsigned int v13 = (AUNeuralNet *)((char *)this + 32);
  uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUNeuralNet *)((char *)this + 32), 0);
  float Parameter = ausdk::AUElement::GetParameter(Element, 1u);
  float v16 = 1.0;
  float v17 = 1.0;
  if (Parameter != 0.0) {
    float v17 = __exp10f(Parameter / 20.0);
  }
  *((float *)this + 137) = v17;
  uint64_t v18 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUNeuralNet *)((char *)this + 32), 0);
  float v19 = ausdk::AUElement::GetParameter(v18, 2u);
  if (v19 != 0.0) {
    float v16 = __exp10f(v19 / 20.0);
  }
  *((float *)this + 138) = v16;
  BOOL v20 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUNeuralNet *)((char *)this + 32), 0);
  unsigned int v7 = ausdk::AUElement::GetParameter(v20, 5u);
  if (!*(unsigned char *)(*((void *)this + 100) + 104 * v7 + 96))
  {
    if (getAUNeuralNetLog(void)::onceToken == -1) {
      goto LABEL_9;
    }
    goto LABEL_242;
  }
  *((_DWORD *)this + 141) = v7;
  while (1)
  {
    int v22 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v13, 0);
    unsigned int v23 = ausdk::AUElement::GetParameter(v22, 6u);
    *((_DWORD *)this + 142) = v23;
    if (v23)
    {
      unsigned int v24 = v23 - 1;
      if (!*(unsigned char *)(*((void *)this + 100) + 104 * v24 + 96))
      {
        *((unsigned char *)this + 672) = 0;
        if (getAUNeuralNetLog(void)::onceToken != -1) {
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
        }
        BOOL v25 = getAUNeuralNetLog(void)::gLog;
        if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
        {
          int v138 = *((_DWORD *)this + 142) - 1;
          int v139 = *((_DWORD *)this + 206);
          *(_DWORD *)&v222[21] = 134218496;
          *(void *)&v222[25] = this;
          *(_WORD *)&v222[33] = 1024;
          *(_DWORD *)&v222[35] = v138;
          *(_WORD *)&v222[39] = 1024;
          int v223 = v139;
          _os_log_error_impl(&dword_1BB0CE000, v25, OS_LOG_TYPE_ERROR, "[%p] Tried to select a model indexed at (%u), but only (%u) models are available. A new model will not be selected and AUNeuralNet will run as if bypassed (until a new model is selected).", &v222[21], 0x18u);
        }
        goto LABEL_19;
      }
      *((_DWORD *)this + 141) = v24;
    }
    *((unsigned char *)this + 672) = 1;
LABEL_19:
    int v26 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v13, 0);
    float v27 = ausdk::AUElement::GetParameter(v26, 7u);
    float v28 = 1.0;
    if (v27 != 0.0) {
      float v28 = __exp10f(v27 / 20.0);
    }
    *((float *)this + 143) = v28;
    double v29 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v13, 0);
    *((unsigned char *)this + 592) = ausdk::AUElement::GetParameter(v29, 0xCu) != 0.0;
    double v30 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v13, 0);
    *((unsigned char *)this + 593) = ausdk::AUElement::GetParameter(v30, 0xDu) != 0.0;
    if (!*((unsigned char *)this + 592))
    {
      unint64_t v31 = *(unsigned int *)(*((void *)this + 100) + 28);
      *(_DWORD *)&v222[21] = 0;
      std::vector<float>::assign((char **)this + 107, v31, &v222[21]);
    }
    double v32 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v13, 0);
    *((unsigned char *)this + 600) = ausdk::AUElement::GetParameter(v32, 0x15u) != 0.0;
    char v33 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v13, 0);
    *((unsigned char *)this + 601) = ausdk::AUElement::GetParameter(v33, 0x16u) != 0.0;
    char v34 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v13, 0);
    float v35 = ausdk::AUElement::GetParameter(v34, 8u);
    float v36 = 1.0;
    if (v35 != 0.0) {
      float v36 = __exp10f(v35 / 20.0);
    }
    *((float *)this + 144) = v36;
    double v37 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v13, 0);
    float v38 = ausdk::AUElement::GetParameter(v37, 9u);
    float v39 = 1.0;
    if (v38 != 0.0) {
      float v39 = __exp10f(v38 / 20.0);
    }
    *((float *)this + 145) = v39;
    double v40 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v13, 0);
    float v41 = ausdk::AUElement::GetParameter(v40, 0xAu);
    float v42 = 1.0;
    if (v41 != 0.0) {
      float v42 = __exp10f(v41 / 20.0);
    }
    *((float *)this + 146) = v42;
    long double v43 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v13, 0);
    float v44 = ausdk::AUElement::GetParameter(v43, 0xBu);
    float v45 = 1.0;
    if (v44 != 0.0) {
      float v45 = __exp10f(v44 / 20.0);
    }
    *((float *)this + 147) = v45;
    unint64_t v46 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v13, 0);
    *((float *)this + 153) = ausdk::AUElement::GetParameter(v46, 0x19u);
    long long v47 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v13, 0);
    *((float *)this + 154) = ausdk::AUElement::GetParameter(v47, 0x1Au);
    *((void *)this + 86) = v12;
LABEL_32:
    int v48 = *((_DWORD *)this + 245);
    int CurrentLatencyInSamples = AUNeuralNet::GetCurrentLatencyInSamples(this);
    *((_DWORD *)this + 245) = CurrentLatencyInSamples;
    if (v48 != CurrentLatencyInSamples)
    {
      unint64_t v50 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUNeuralNet *)((char *)this + 32), 0);
      ausdk::AUElement::SetParameter(v50, 0xEu, (float)*((unsigned int *)this + 245), 0);
    }
    unint64_t v51 = *a5;
    if (!*a5)
    {
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      long long v58 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)&v222[21] = 134217984;
        *(void *)&v222[25] = this;
        _os_log_error_impl(&dword_1BB0CE000, v58, OS_LOG_TYPE_ERROR, "[%p] input not connected", &v222[21], 0xCu);
      }
      return 4294956420;
    }
    unsigned int v13 = (AUNeuralNet *)((char *)this + 80);
    uint64_t v52 = ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 80), 0);
    int v53 = *(_DWORD *)(v52 + 108);
    if ((*(_DWORD *)(v52 + 92) & 0x20) != 0) {
      int v54 = *(_DWORD *)(v52 + 108);
    }
    else {
      int v54 = 1;
    }
    if ((*(_DWORD *)(v52 + 92) & 0x20) != 0) {
      int v53 = 1;
    }
    if (v51->mNumberBuffers != v54 || v51->mBuffers[0].mNumberChannels != v53)
    {
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      float v56 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)&v222[21] = 134217984;
        *(void *)&v222[25] = this;
        std::__fs::filesystem::path v57 = "[%p] input format not supported";
        goto LABEL_111;
      }
      return 4294956428;
    }
    v222[0] = 0;
    double v60 = (AudioBufferList *)*a5;
    uint64_t v61 = ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 80), 0);
    AudioDSP::Utility::DetectNonFinites(0, v60, (const AudioBufferList *)(v61 + 80), (const AudioStreamBasicDescription *)v222, v62);
    int v218 = v10;
    if (!v222[0]) {
      goto LABEL_71;
    }
    unint64_t v63 = *a5;
    int v12 = (char *)this + 1376;
    unint64_t BufferList = ausdk::AUBufferList::GetBufferList((AUNeuralNet *)((char *)this + 1376));
    if (v63->mNumberBuffers == *(_DWORD *)BufferList) {
      break;
    }
    _os_assert_log();
    _os_crash();
    __break(1u);
LABEL_242:
    dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
LABEL_9:
    BOOL v21 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
    {
      int v137 = *((_DWORD *)this + 206);
      *(_DWORD *)&v222[21] = 134218496;
      *(void *)&v222[25] = this;
      *(_WORD *)&v222[33] = 1024;
      *(_DWORD *)&v222[35] = v7;
      *(_WORD *)&v222[39] = 1024;
      int v223 = v137;
      _os_log_error_impl(&dword_1BB0CE000, v21, OS_LOG_TYPE_ERROR, "[%p] Tried to select a model indexed at (%u), but only (%u) models are available. A new model will not be selected and the previous selection will be used.", &v222[21], 0x18u);
    }
  }
  if (v63->mNumberBuffers)
  {
    uint64_t v10 = 0;
    unint64_t v65 = 0;
    while (1)
    {
      size_t v66 = *(unsigned int *)(BufferList + v10 + 12);
      if (v66 != *(UInt32 *)((char *)&v63->mBuffers[0].mDataByteSize + v10)) {
        break;
      }
      memcpy(*(void **)(BufferList + v10 + 16), *(const void **)((char *)&v63->mBuffers[0].mData + v10), v66);
      ++v65;
      v10 += 16;
      if (v65 >= *(unsigned int *)BufferList) {
        goto LABEL_59;
      }
    }
    _os_assert_log();
    _os_crash();
    __break(1u);
LABEL_162:
    uint64_t v145 = (*(uint64_t (**)(void, OutputBlockBuffer *))(*(void *)*v208 + 72))(*v208, v210);
    uint64_t v146 = *(void *)(v145 + 8);
    if (v146 != *(void *)v145) {
      memmove(*((void **)this + 110), *(const void **)v145, v146 - *(void *)v145);
    }
    vDSP_vsdiv(*((const float **)this + 110), 1, __B, *((float **)this + 110), 1, (uint64_t)(*((void *)this + 111) - *((void *)this + 110)) >> 2);
    goto LABEL_165;
  }
LABEL_59:
  unint64_t v67 = (const AudioBufferList *)ausdk::AUBufferList::GetBufferList((AUNeuralNet *)((char *)this + 1376));
  LODWORD(v10) = v218;
  *a5 = v67;
  uint64_t mNumberBuffers = v67->mNumberBuffers;
  if (mNumberBuffers)
  {
    uint64_t v69 = 0;
    unsigned int v70 = 0;
    do
    {
      uint64_t v71 = (char *)v67 + 16 * v69;
      unint64_t v72 = *((unsigned int *)v71 + 3);
      if (v72 >= 4)
      {
        unint64_t v73 = v72 >> 2;
        long long v74 = (float *)*((void *)v71 + 2);
        do
        {
          if (fabsf(*v74) == INFINITY)
          {
            *long long v74 = 0.0;
            ++v70;
          }
          ++v74;
          --v73;
        }
        while (v73);
      }
      ++v69;
    }
    while (v69 != mNumberBuffers);
  }
  else
  {
    unsigned int v70 = 0;
  }
  uint64_t v75 = _os_log_pack_size();
  uint64_t message = caulk::deferred_logger::create_message(*((caulk::deferred_logger **)this + 66), v75 + 88, 16);
  if (message)
  {
    unsigned __int8 v77 = (caulk::concurrent::message *)message;
    uint64_t v78 = _os_log_pack_fill();
    *(_DWORD *)uint64_t v78 = 134217984;
    *(void *)(v78 + 4) = v70;
    LODWORD(v10) = v218;
    caulk::concurrent::messenger::enqueue(*(caulk::concurrent::messenger **)(*((void *)this + 66) + 16), v77);
  }
LABEL_71:
  unint64_t v79 = 0;
  *(_OWORD *)&v222[5] = 0uLL;
  char v80 = 1;
  do
  {
    char v81 = v80;
    if (v79 >= a6) {
      double v82 = 0;
    }
    else {
      double v82 = a7[v79];
    }
    char v80 = 0;
    *(void *)&v222[8 * v79 + 5] = v82;
    unint64_t v79 = 1;
  }
  while ((v81 & 1) != 0);
  double v83 = *(_DWORD **)&v222[5];
  if (*(void *)&v222[5])
  {
    uint64_t v84 = ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 128), 0);
    int v85 = *(_DWORD *)(v84 + 108);
    if ((*(_DWORD *)(v84 + 92) & 0x20) != 0) {
      int v86 = *(_DWORD *)(v84 + 108);
    }
    else {
      int v86 = 1;
    }
    if ((*(_DWORD *)(v84 + 92) & 0x20) != 0) {
      int v85 = 1;
    }
    if (*v83 != v86 || v83[2] != v85)
    {
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      float v56 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)&v222[21] = 134217984;
        *(void *)&v222[25] = this;
        std::__fs::filesystem::path v57 = "[%p] processed output format not supported";
        goto LABEL_111;
      }
      return 4294956428;
    }
  }
  double v88 = *(_DWORD **)&v222[13];
  if (*(void *)&v222[13] && **(_DWORD **)&v222[13] != *((_DWORD *)this + 165))
  {
    if (getAUNeuralNetLog(void)::onceToken != -1) {
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
    }
    float v56 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)&v222[21] = 134217984;
      *(void *)&v222[25] = this;
      std::__fs::filesystem::path v57 = "[%p] gain vector format not supported";
LABEL_111:
      _os_log_error_impl(&dword_1BB0CE000, v56, OS_LOG_TYPE_ERROR, v57, &v222[21], 0xCu);
    }
    return 4294956428;
  }
  else
  {
    int v89 = *((_DWORD *)this + 167);
    BOOL v90 = v89 == 0;
    *((unsigned char *)this + 1245) = 0;
    float v219 = v88;
    BOOL v220 = a7;
    if (!*((unsigned char *)this + 1244) || v89)
    {
      if (*((unsigned char *)this + 664))
      {
        double v92 = *a5;
        double v93 = *a7;
        unsigned int v94 = *((_DWORD *)this + 141);
        uint64_t v95 = *((void *)this + 100);
        *((unsigned char *)this + 1245) = v89 == 0;
        if (!v89 && *((unsigned char *)this + 672) && (uint64_t v124 = v95 + 104 * v94, *(unsigned char *)(v124 + 96)))
        {
          v216 = v93;
          LODWORD(v12) = *((_DWORD *)this + 136);
          unint64_t v125 = (*(uint64_t (**)(void))(**(void **)(v95 + 64) + 24))(*(void *)(v95 + 64));
          if (*((_DWORD *)this + 136) == v10)
          {
            unint64_t v126 = 0;
            uint64_t v213 = v95 + 104 * v94;
            float __B = (float *)((char *)this + 548);
            unsigned __int8 v208 = (void *)(v124 + 64);
            unint64_t v210 = (AUNeuralNet *)((char *)this + 832);
            p_mData = (const void **)&v92->mBuffers[0].mData;
            unint64_t BufferList = v125 / *(unsigned int *)(*((void *)this + 100) + 8);
            while (v126 < *(unsigned int *)(ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 80), 0) + 108))
            {
              vDSP_Length v128 = (char *)*p_mData;
              uint64_t v129 = *((unsigned int *)this + 136);
              int v130 = 2 * v126 * BufferList;
              uint64_t v131 = *((void *)this + 104);
              uint64_t v132 = (void *)(v131 + 4 * v130);
              if (v12 == BufferList)
              {
                if (2 * v129)
                {
                  memmove((void *)(v131 + 4 * v130), v128, 4 * (2 * v129));
                  LODWORD(v129) = *((_DWORD *)this + 136);
                  uint64_t v131 = *((void *)this + 104);
                }
                CFTypeRef v133 = (_DWORD *)(v131 + 4 * (v129 + v130));
              }
              else
              {
                CFTypeRef v133 = (_DWORD *)(v131 + 4 * ((int)BufferList + 2 * (int)v126 * (int)BufferList));
                CFTypeID v134 = &v128[4 * v129];
                if (v129 && (memmove(v132, v128, 4 * v129), uint64_t v135 = *((unsigned int *)this + 136), v135))
                {
                  memmove(v133, v134, 4 * v135);
                  uint64_t v136 = *((unsigned int *)this + 136);
                }
                else
                {
                  uint64_t v136 = 0;
                }
                *((_DWORD *)v132 + v136) = *(_DWORD *)v134;
                v133[v136] = 0;
              }
              *CFTypeRef v133 = 0;
              ++v126;
              p_mData += 2;
              a7 = v220;
            }
            *(_DWORD *)&v222[21] = 0;
            vDSP_measqv(*((const float **)this + 104), 1, (float *)&v222[21], (2 * *((_DWORD *)this + 136)));
            float v141 = *((float *)this + 156);
            float v142 = *((float *)this + 139);
            *((float *)this + 139) = (float)((float)(1.0 - v141)
                                           * (float)(log10f(*(float *)&v222[21] + 2.2204e-16) * 10.0))
                                   + (float)(v141 * v142);
            unsigned int v13 = (AUNeuralNet *)((char *)this + 32);
            CFDictionaryRef v143 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUNeuralNet *)((char *)this + 32), 0);
            ausdk::AUElement::SetParameter(v143, 3u, *((float *)this + 139), 0);
            BOOL v144 = *(float *)&v222[21] < *((float *)this + 138);
            vDSP_vsmul(*((const float **)this + 104), 1, __B, *((float **)this + 104), 1, (uint64_t)(*((void *)this + 105) - *((void *)this + 104)) >> 2);
            AUNeuralNet::ApplyEmbedding((uint64_t)this, v213);
            if (!v144) {
              goto LABEL_162;
            }
            *(_DWORD *)&v222[1] = 0;
            vDSP_vfill((const float *)&v222[1], *((float **)this + 110), 1, (uint64_t)(*((void *)this + 111) - *((void *)this + 110)) >> 2);
LABEL_165:
            vDSP_measqv(*((const float **)this + 110), 1, (float *)&v222[21], (uint64_t)(*((void *)this + 111) - *((void *)this + 110)) >> 2);
            float v147 = *((float *)this + 156);
            float v148 = *((float *)this + 140);
            *((float *)this + 140) = (float)((float)(1.0 - v147)
                                           * (float)(log10f(*(float *)&v222[21] + 2.2204e-16) * 10.0))
                                   + (float)(v147 * v148);
            unsigned int v149 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v13, 0);
            ausdk::AUElement::SetParameter(v149, 4u, *((float *)this + 140), 0);
            if (*((_DWORD *)this + 165))
            {
              unint64_t v150 = 0;
              uint64_t v151 = &v216->mBuffers[0].mData;
              do
              {
                uint64_t v152 = *v151;
                uint64_t v153 = *((unsigned int *)this + 136);
                char v154 = (char *)*v151 + 4 * v153;
                int v155 = v150 * BufferList;
                uint64_t v156 = *((void *)this + 110);
                if (v12 == BufferList)
                {
                  unsigned int v157 = 2 * v153;
                  int v158 = 0;
                  if (v157) {
                    memmove(v152, (const void *)(v156 + 8 * v155), 4 * v157);
                  }
                }
                else
                {
                  if (v153
                    && (memmove(v152, (const void *)(v156 + 8 * v155), 4 * v153),
                        uint64_t v159 = *((unsigned int *)this + 136),
                        v159))
                  {
                    memmove(v154, (const void *)(v156 + 4 * ((int)BufferList + 2 * v155)), 4 * v159);
                    uint64_t v160 = *((unsigned int *)this + 136);
                  }
                  else
                  {
                    uint64_t v160 = 0;
                  }
                  int v158 = *(_DWORD *)(v156 + 8 * v155 + 4 * v160);
                }
                LODWORD(v10) = v218;
                *char v154 = v158;
                ++v150;
                v151 += 2;
              }
              while (v150 < *((unsigned int *)this + 165));
            }
            goto LABEL_176;
          }
          if (getAUNeuralNetLog(void)::onceToken != -1) {
            dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
          }
          long long v140 = getAUNeuralNetLog(void)::gLog;
          if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
          {
            int v206 = *(_DWORD *)(v95 + 104 * v94 + 20);
            *(_DWORD *)&v222[21] = 134218496;
            *(void *)&v222[25] = this;
            *(_WORD *)&v222[33] = 1024;
            *(_DWORD *)&v222[35] = v206;
            *(_WORD *)&v222[39] = 1024;
            int v223 = v10;
            _os_log_error_impl(&dword_1BB0CE000, v140, OS_LOG_TYPE_ERROR, "[%p] NeuralNet expects input block size %u, and we received %d.", &v222[21], 0x18u);
          }
          uint64_t v59 = 4294956422;
LABEL_177:
          BOOL v90 = 1;
        }
        else
        {
          if (*((_DWORD *)this + 165))
          {
            unint64_t v96 = 0;
            uint64_t v97 = (const void **)&v92->mBuffers[0].mData;
            char v98 = &v93->mBuffers[0].mData;
            do
            {
              char v99 = (float *)*v98;
              if (v96 >= *((unsigned int *)this + 164))
              {
                *(_DWORD *)&v222[21] = 0;
                vDSP_vfill((const float *)&v222[21], v99, 1, (2 * v10));
              }
              else if (2 * v10)
              {
                memmove(*v98, *v97, 4 * (2 * v10));
              }
              ++v96;
              v97 += 2;
              v98 += 2;
            }
            while (v96 < *((unsigned int *)this + 165));
          }
          uint64_t v59 = 0;
        }
      }
      else
      {
        uint64_t v59 = AUNeuralNet::ProcessFuncCore(this, v10, a5, a7);
      }
    }
    else
    {
      int v91 = *((_DWORD *)this + 312);
      if (v91 != 2)
      {
        if (v91 == 1)
        {
          uint64_t v59 = BlockProcessor::Process(*((BlockProcessor **)this + 157), v10, a5, a7);
          goto LABEL_177;
        }
LABEL_176:
        uint64_t v59 = 0;
        goto LABEL_177;
      }
      float v101 = (uint64_t *)*((void *)this + 158);
      *((unsigned char *)v101 + 96) = 0;
      int v102 = *((_DWORD *)v101 + 22);
      if (v102 == v10)
      {
        if (v10)
        {
          int v103 = 0;
          uint64_t v104 = *((unsigned int *)v101 + 3);
          uint64_t v211 = (unsigned int *)(v101 + 3);
          uint64_t v207 = (unsigned int *)(v101 + 6);
          unsigned int v105 = v10;
          unsigned int v209 = *((_DWORD *)v101 + 3);
          do
          {
            int v106 = *((_DWORD *)v101 + 4);
            unint64_t v107 = *((unsigned int *)v101 + 2);
            unsigned int v212 = v105;
            if (*((_DWORD *)v101 + 3) - v106 >= v105) {
              unsigned int v108 = v105;
            }
            else {
              unsigned int v108 = *((_DWORD *)v101 + 3) - v106;
            }
            int v217 = v103;
            unsigned int __Ba = v108;
            if (v107)
            {
              unsigned int v109 = v108;
              unint64_t v110 = 0;
              uint64_t v111 = (4 * v103);
              uint64_t v112 = (4 * v106);
              size_t v113 = 4 * v109;
              do
              {
                int v114 = *(_DWORD **)(*v101 + 8 * v110);
                if (*v114)
                {
                  unint64_t v115 = 0;
                  unint64_t v116 = a5[v110];
                  uint64_t v117 = 4;
                  do
                  {
                    memcpy((void *)(*(void *)&v114[v117] + v112), (const void *)(*(void *)((char *)&v116->mNumberBuffers + v117 * 4) + v111), v113);
                    ++v115;
                    v117 += 4;
                  }
                  while (v115 < *v114);
                  unint64_t v107 = *((unsigned int *)v101 + 2);
                  a7 = v220;
                }
                ++v110;
              }
              while (v110 < v107);
              int v106 = *((_DWORD *)v101 + 4);
              LODWORD(v10) = v218;
              int v103 = v217;
              uint64_t v104 = v209;
              unsigned int v108 = __Ba;
            }
            *((_DWORD *)v101 + 4) = v106 + v108;
            if (v106 + v108 == v104)
            {
              uint64_t v118 = *v101;
              uint64_t v119 = v101[6];
              vDSP_Length v120 = (AudioBufferList **)v101[3];
              *((_DWORD *)v101 + 16) = 0;
              uint64_t v59 = ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))v101[9])(v101[10], v104, v118, v119);
              int v121 = *((_DWORD *)v101 + 23) - *((_DWORD *)v101 + 10);
              int v122 = v121 & ~(v121 >> 31);
              OutputBlockBuffer::Read(v211, v122, 0, a7);
              unsigned int v123 = v108 - v122;
              OutputBlockBuffer::Read(v207, v108 - v122, v122, a7);
              unsigned int v108 = __Ba;
              OutputBlockBuffer::Read(v207, v104 - v123, 0, v120);
              *((_DWORD *)v101 + 4) = 0;
              *((_DWORD *)v101 + 10) = 0;
              *((unsigned char *)v101 + 96) = 1;
              int v103 = v217;
              if (v59) {
                goto LABEL_135;
              }
            }
            else
            {
              OutputBlockBuffer::Read(v211, v108, v103, a7);
            }
            v103 += v108;
            unsigned int v105 = v212 - v108;
          }
          while (v212 != v108);
          uint64_t v59 = 0;
LABEL_135:
          float v101 = (uint64_t *)*((void *)this + 158);
          int v102 = *((_DWORD *)v101 + 22);
        }
        else
        {
          int v102 = 0;
          uint64_t v59 = 0;
        }
      }
      else
      {
        uint64_t v59 = 4294956428;
      }
      BOOL v90 = (v102 + *((_DWORD *)v101 + 4)) >= *((_DWORD *)v101 + 3);
    }
    v222[1] = 0;
    uint64_t v161 = *a7;
    uint64_t v162 = ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 128), 0);
    AudioDSP::Utility::DetectNonFinites(0, v161, (const AudioBufferList *)(v162 + 80), (const AudioStreamBasicDescription *)&v222[1], v163);
    if (v222[1])
    {
      uint64_t v164 = _os_log_pack_size();
      uint64_t v165 = caulk::deferred_logger::create_message(*((caulk::deferred_logger **)this + 66), v164 + 88, 16);
      if (v165)
      {
        CFHashCode v166 = (caulk::concurrent::message *)v165;
        uint64_t v167 = _os_log_pack_fill();
        double v168 = *((float *)this + 139);
        *(_DWORD *)uint64_t v167 = 134217984;
        *(double *)(v167 + 4) = v168;
        caulk::concurrent::messenger::enqueue(*(caulk::concurrent::messenger **)(*((void *)this + 66) + 16), v166);
      }
      for (uint64_t i = 0; i != 624; i += 104)
      {
        uint64_t v170 = *((void *)this + 100) + i;
        if (*(unsigned char *)(v170 + 96)) {
          (*(void (**)(void))(**(void **)(v170 + 64) + 48))(*(void *)(v170 + 64));
        }
      }
      vDSP_Length v171 = *a7;
      if ((*a7)->mNumberBuffers)
      {
        uint64_t v172 = 0;
        unint64_t v173 = 0;
        do
        {
          memcpy(v171->mBuffers[v172].mData, **((const void ***)this + 132), v171->mBuffers[v172].mDataByteSize);
          ++v173;
          vDSP_Length v171 = *a7;
          ++v172;
        }
        while (v173 < (*a7)->mNumberBuffers);
      }
      *((_DWORD *)this + 140) = *((_DWORD *)this + 139);
      *((_DWORD *)this + 152) = *((_DWORD *)this + 151);
      LODWORD(v10) = v218;
    }
    unint64_t v174 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUNeuralNet *)((char *)this + 32), 0);
    float v175 = 0.0;
    if (*((unsigned char *)this + 1245)) {
      float v175 = 1.0;
    }
    ausdk::AUElement::SetParameter(v174, 0x10u, v175, 0);
    CFTypeRef v176 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUNeuralNet *)((char *)this + 32), 0);
    ausdk::AUElement::SetParameter(v176, 0xFu, (float)v90, 0);
    if (*((_DWORD *)this + 167) || !*((unsigned char *)this + 672) || *((_DWORD *)this + 136) != v10 || v222[1])
    {
      *(_DWORD *)&v222[21] = 1065353216;
      vDSP_vfill((const float *)&v222[21], *((float **)this + 113), 1, (uint64_t)(*((void *)this + 114) - *((void *)this + 113)) >> 2);
      vDSP_vfill((const float *)&v222[21], *((float **)this + 116), 1, (uint64_t)(*((void *)this + 117) - *((void *)this + 116)) >> 2);
      vDSP_vfill((const float *)&v222[21], *((float **)this + 119), 1, (uint64_t)(*((void *)this + 120) - *((void *)this + 119)) >> 2);
      if (v219 && *v219)
      {
        unint64_t v177 = 0;
        vDSP_Length v178 = (float **)(v219 + 4);
        do
        {
          vDSP_vfill((const float *)&v222[21], *v178, 1, (unint64_t)*((unsigned int *)v178 - 1) >> 2);
          ++v177;
          v178 += 2;
        }
        while (v177 < *v219);
      }
    }
    else
    {
      float v179 = AUNeuralNet::ComputeGainMask(this, v10, *a5, *a7);
      unsigned int v180 = *((_DWORD *)this + 328);
      if (v180 >= *((_DWORD *)this + 165)) {
        unint64_t v181 = 0;
      }
      else {
        unint64_t v181 = v180;
      }
      if (*((_DWORD *)this + 318))
      {
        float v182 = v179;
        vDSP_vclip((const float *)(*((void *)this + 113) + 4 * ((*((_DWORD *)this + 136) + 1) * v181)), 1, &AUNeuralNet::ProcessMultipleBufferLists(unsigned int &,unsigned int,unsigned int,AudioBufferList const**,unsigned int,AudioBufferList**)::kZero, &AUNeuralNet::ProcessMultipleBufferLists(unsigned int &,unsigned int,unsigned int,AudioBufferList const**,unsigned int,AudioBufferList**)::kOne, *((float **)this + 119), 1, (*((_DWORD *)this + 136) + 1));
        switch(*((_DWORD *)this + 318))
        {
          case 1:
            vDSP_meanv(*((const float **)this + 119), 1, (float *)this + 149, (*((_DWORD *)this + 136) + 1));
            goto LABEL_227;
          case 2:
            uint64_t v193 = *((void *)this + 165);
            if (v181 >= (*((void *)this + 166) - v193) >> 2) {
              std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
            }
            float v194 = *(float *)(v193 + 4 * v181)
                 / (float)((float)(v182 + 2.2204e-16)
                         + (float)((float)*((unsigned int *)this + 136) * *((float *)this + 327)));
            goto LABEL_219;
          case 3:
            unint64_t v183 = (const float *)*((void *)this + 160);
            vDSP_Length v184 = (uint64_t)(*((void *)this + 161) - (void)v183) >> 2;
            if (v184 == *((_DWORD *)this + 136) + 1)
            {
              vDSP_dotpr(*((const float **)this + 119), 1, v183, 1, (float *)this + 149, v184);
              *((float *)this + 149) = *((float *)this + 326) * *((float *)this + 149);
            }
            else
            {
              *((_DWORD *)this + 149) = 0;
            }
            goto LABEL_227;
          case 4:
            *(_DWORD *)&v222[21] = 0;
            uint64_t v185 = (const float *)*((void *)this + 160);
            vDSP_Length v186 = (uint64_t)(*((void *)this + 161) - (void)v185) >> 2;
            float v187 = 0.0;
            if (v186 == *((_DWORD *)this + 136) + 1)
            {
              vDSP_dotpr(*((const float **)this + 119), 1, v185, 1, (float *)&v222[21], v186);
              float v187 = *((float *)this + 326) * *(float *)&v222[21];
            }
            float v188 = (float)((float)(1.0 - *((float *)this + 339)) * v187)
                 + (float)(*((float *)this + 339) * *((float *)this + 338));
            *((float *)this + 338) = v188;
            float v189 = *((float *)this + 340);
            int v190 = v188 > v189;
            int v191 = *((_DWORD *)this + 341);
            if (*(void *)((char *)this + 1364))
            {
              if (*((_DWORD *)this + 336) == v190)
              {
                int v192 = *((_DWORD *)this + 337);
                if (!v192) {
                  goto LABEL_223;
                }
                int v191 = v192 - 1;
              }
              else if (v188 <= v189)
              {
                int v191 = *((_DWORD *)this + 342);
              }
              *((_DWORD *)this + 337) = v191;
              if (v191)
              {
LABEL_226:
                *((_DWORD *)this + 336) = v190;
                goto LABEL_227;
              }
LABEL_223:
              BOOL v195 = v188 <= v189;
              float v196 = 0.0;
              if (!v195) {
                float v196 = 1.0;
              }
              *((float *)this + 149) = v196;
              goto LABEL_226;
            }
            BOOL v195 = v188 <= v189;
            float v194 = 0.0;
            if (!v195) {
              float v194 = 1.0;
            }
LABEL_219:
            *((float *)this + 149) = v194;
LABEL_227:
            float v197 = *((float *)this + 149);
            float v198 = 0.0;
            if (v197 >= 0.0)
            {
              float v198 = 1.0;
              if (v197 <= 1.0) {
                float v198 = *((float *)this + 149);
              }
            }
            *((float *)this + 149) = v198;
            CFArrayRef v199 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUNeuralNet *)((char *)this + 32), 0);
            ausdk::AUElement::SetParameter(v199, 0x13u, *((float *)this + 149), 0);
            break;
          default:
            goto LABEL_227;
        }
      }
      memcpy(*((void **)this + 119), *((const void **)this + 113), *((void *)this + 114) - *((void *)this + 113));
      CFArrayRef v200 = (float *)*((void *)this + 113);
      *(_DWORD *)&v222[21] = (*((void *)this + 114) - (void)v200) >> 2;
      vvpowsf(v200, (const float *)this + 153, v200, (const int *)&v222[21]);
      vvpowsf(*((float **)this + 119), (const float *)this + 154, *((const float **)this + 119), (const int *)&v222[21]);
      vDSP_vclip(*((const float **)this + 113), 1, (const float *)this + 144, (const float *)this + 145, *((float **)this + 113), 1, (uint64_t)(*((void *)this + 114) - *((void *)this + 113)) >> 2);
      vDSP_vclip(*((const float **)this + 119), 1, (const float *)this + 146, (const float *)this + 147, *((float **)this + 119), 1, (uint64_t)(*((void *)this + 120) - *((void *)this + 119)) >> 2);
      if (*((_DWORD *)this + 165))
      {
        unsigned int v201 = 0;
        do
        {
          memcpy((void *)(*((void *)this + 116) + 4 * *((_DWORD *)this + 136) * v201), (const void *)(*((void *)this + 113) + 4 * (v201 + *((_DWORD *)this + 136) * v201)), 4 * *((unsigned int *)this + 136));
          ++v201;
          unsigned int v202 = *((_DWORD *)this + 165);
        }
        while (v201 < v202);
        if (v202)
        {
          unint64_t v203 = 0;
          CFArrayRef v204 = (void **)(v219 + 4);
          do
          {
            if (v219)
            {
              int v205 = *((_DWORD *)this + 136);
              if (v205)
              {
                memmove(*v204, (const void *)(*((void *)this + 116) + 4 * (v205 * v203)), 4 * (v205 * v203 + v205) - 4 * (v205 * v203));
                unsigned int v202 = *((_DWORD *)this + 165);
              }
            }
            ++v203;
            v204 += 2;
          }
          while (v203 < v202);
        }
      }
    }
  }
  return v59;
}

uint64_t AUNeuralNet::GetCurrentLatencyInSamples(AUNeuralNet *this)
{
  if ((!*((_DWORD *)this + 167) || *((unsigned char *)this + 1372)) && (uint64_t v2 = *((void *)this + 100), *(unsigned char *)(v2 + 96))) {
    uint64_t result = *(unsigned int *)(v2 + 16);
  }
  else {
    uint64_t result = 0;
  }
  if (*((unsigned char *)this + 1244))
  {
    if (*((_DWORD *)this + 312) == 2) {
      unsigned int v4 = (_DWORD *)(*((void *)this + 158) + 92);
    }
    else {
      unsigned int v4 = (_DWORD *)(*((void *)this + 100) + 20);
    }
    return (*v4 + result);
  }
  return result;
}

uint64_t AUNeuralNet::ProcessFuncCore(AUNeuralNet *this, unsigned int a2, const AudioBufferList **a3, AudioBufferList **a4)
{
  uint64_t v121 = *MEMORY[0x1E4F143B8];
  unsigned int v7 = (AUNeuralNet *)((char *)this + 80);
  int v8 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 80), 0) + 92);
  int v9 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 128), 0) + 92);
  char v109 = v8;
  if ((v8 & 0x20) != 0)
  {
    unsigned int v10 = 1;
    if ((v9 & 0x20) != 0) {
      goto LABEL_3;
    }
LABEL_5:
    unsigned int v11 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 128), 0) + 108);
    goto LABEL_6;
  }
  unsigned int v10 = *(_DWORD *)(ausdk::AUScope::SafeGetElement(v7, 0) + 108);
  if ((v9 & 0x20) == 0) {
    goto LABEL_5;
  }
LABEL_3:
  unsigned int v11 = 1;
LABEL_6:
  uint64_t v12 = (uint64_t)*a3;
  uint64_t v13 = (uint64_t)*a4;
  unsigned int v14 = *((_DWORD *)this + 141);
  uint64_t v15 = *((void *)this + 100);
  int v16 = *((_DWORD *)this + 167);
  *((unsigned char *)this + 1245) = v16 == 0;
  uint64_t v107 = v13;
  uint64_t v108 = v12;
  if (v16 || !*((unsigned char *)this + 672) || !*(unsigned char *)(v15 + 104 * v14 + 96))
  {
    if (!*((_DWORD *)this + 165)) {
      return 0;
    }
    unint64_t v17 = 0;
    vDSP_Stride v18 = v11;
    uint64_t v19 = 4 * v10;
    uint64_t v20 = 4 * v11;
    vDSP_Stride __IA = v10;
    while (1)
    {
      if ((v9 & 0x20) != 0) {
        BOOL v21 = *(float **)(v13 + 16 * v17 + 16);
      }
      else {
        BOOL v21 = (float *)(*(void *)(v13 + 16) + 4 * v17);
      }
      if (v17 >= *((unsigned int *)this + 164))
      {
        vDSP_vclr(v21, v18, a2);
      }
      else
      {
        if ((v109 & 0x20) != 0) {
          int v22 = *(const float **)(v108 + 16 * v17 + 16);
        }
        else {
          int v22 = (const float *)(*(void *)(v108 + 16) + 4 * v17);
        }
        if (!*((unsigned char *)this + 1372)) {
          goto LABEL_22;
        }
        unsigned int v23 = *(char **)(*((void *)this + 132) + 24 * v17);
        memmove(v23, &v23[4 * *((unsigned int *)this + 136)], 4 * *((unsigned int *)this + 244));
        unsigned int v24 = (const float **)(*((void *)this + 132) + 24 * v17);
        if (a2)
        {
          int v25 = *((_DWORD *)this + 244);
          int v26 = *v24;
          uint64_t v27 = a2;
          do
          {
            v26[v25++] = *v22;
            int v22 = (const float *)((char *)v22 + v19);
            --v27;
          }
          while (v27);
          int v22 = v26;
          uint64_t v13 = v107;
LABEL_22:
          if (v22 == v21)
          {
            float v28 = v21;
            for (unsigned int i = a2; i; --i)
            {
              float *v21 = *v28;
              float v28 = (float *)((char *)v28 + v19);
              BOOL v21 = (float *)((char *)v21 + v20);
            }
            goto LABEL_28;
          }
LABEL_27:
          vDSP_vclr(v21, v18, a2);
          vDSP_vadd(v22, __IA, v21, v18, v21, v18, a2);
          goto LABEL_28;
        }
        int v22 = *v24;
        uint64_t v13 = v107;
        if (*v24 != v21) {
          goto LABEL_27;
        }
      }
LABEL_28:
      if (++v17 >= *((unsigned int *)this + 165)) {
        return 0;
      }
    }
  }
  uint64_t v31 = v15 + 104 * v14;
  int v33 = *(_DWORD *)(v31 + 20);
  double v32 = (unsigned int *)(v31 + 20);
  if (v33 == a2)
  {
    unint64_t v34 = 0;
    unsigned int v105 = v11;
    vDSP_Length __N = v15 + 104 * v14;
    uint64_t v35 = 4 * v10;
    while (v34 < *(unsigned int *)(ausdk::AUScope::SafeGetElement(v7, 0) + 108))
    {
      if ((v109 & 0x20) != 0) {
        float v36 = *(_DWORD **)(v108 + 16 * v34 + 16);
      }
      else {
        float v36 = (_DWORD *)(*(void *)(v108 + 16) + 4 * v34);
      }
      if (a2)
      {
        uint64_t v37 = *((void *)this + 104);
        unsigned int v38 = *v32 * v34;
        uint64_t v39 = a2;
        do
        {
          *(_DWORD *)(v37 + 4 * v38++) = *v36;
          float v36 = (_DWORD *)((char *)v36 + v35);
          --v39;
        }
        while (v39);
      }
      ++v34;
    }
    char v110 = v9;
    if (*((_DWORD *)this + 164))
    {
      uint64_t v41 = 0;
      unint64_t v42 = 0;
      if (*((unsigned char *)this + 1244)) {
        long double v43 = (unsigned int *)((char *)this + 976);
      }
      else {
        long double v43 = (unsigned int *)(v15 + 104 * v14 + 16);
      }
      uint64_t v44 = *v43;
      do
      {
        memmove(*(void **)(*((void *)this + 132) + v41), (const void *)(*(void *)(*((void *)this + 132) + v41) + 4 * *v32), 4 * v44);
        memcpy((void *)(*(void *)(*((void *)this + 132) + v41) + 4 * v44), (const void *)(*((void *)this + 104) + 4 * *v32 * v42++), 4 * *v32);
        v41 += 24;
      }
      while (v42 < *((unsigned int *)this + 164));
    }
    float __C = 0.0;
    vDSP_measqv(**((const float ***)this + 132), 1, &__C, *((unsigned int *)this + 136));
    float v45 = *((float *)this + 156);
    float v46 = *((float *)this + 139);
    *((float *)this + 139) = (float)((float)(1.0 - v45) * (float)(log10f(__C + 2.2204e-16) * 10.0)) + (float)(v45 * v46);
    uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUNeuralNet *)((char *)this + 32), 0);
    ausdk::AUElement::SetParameter(Element, 3u, *((float *)this + 139), 0);
    uint64_t v114 = 0;
    if (*((_DWORD *)this + 164))
    {
      uint64_t v48 = 0;
      unint64_t v49 = 0;
      do
      {
        vDSP_measqv(*(const float **)(*((void *)this + 132) + v48), 1, (float *)&v114, *((unsigned int *)this + 136));
        unint64_t v50 = *((unsigned int *)this + 164);
        float v51 = *((float *)&v114 + 1) + (float)(*(float *)&v114 / (float)v50);
        *((float *)&v114 + 1) = v51;
        ++v49;
        v48 += 24;
      }
      while (v49 < v50);
    }
    else
    {
      float v51 = 0.0;
    }
    if (!*((unsigned char *)this + 652)) {
      float v51 = (float)((float)(1.0 - *((float *)this + 156)) * v51)
    }
          + (float)(*((float *)this + 156) * *((float *)this + 151));
    *((float *)this + 151) = v51;
    uint64_t v52 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUNeuralNet *)((char *)this + 32), 0);
    ausdk::AUElement::SetParameter(v52, 0x17u, *((float *)this + 151), 0);
    float __C = 0.0;
    vDSP_measqv(*((const float **)this + 104), 1, &__C, (uint64_t)(*((void *)this + 105) - *((void *)this + 104)) >> 2);
    float v53 = __C;
    float v54 = *((float *)this + 138);
    vDSP_vsmul(*((const float **)this + 104), 1, (const float *)this + 137, *((float **)this + 104), 1, (uint64_t)(*((void *)this + 105) - *((void *)this + 104)) >> 2);
    AUNeuralNet::ApplyEmbedding((uint64_t)this, __N);
    if (*((unsigned char *)this + 600))
    {
      AUNeuralNet::ProcessAUNNModel((uint64_t)this, __N);
      HIDWORD(v114) = 0;
      vDSP_measqv(*((const float **)this + 110), 1, (float *)&v114 + 1, (uint64_t)(*((void *)this + 111) - *((void *)this + 110)) >> 2);
      if (*((unsigned char *)this + 652))
      {
        float v55 = *((float *)&v114 + 1);
        *((unsigned char *)this + 652) = 0;
      }
      else
      {
        float v55 = (float)((float)(1.0 - *((float *)this + 156)) * *((float *)&v114 + 1))
            + (float)(*((float *)this + 156) * *((float *)this + 152));
      }
      *((float *)this + 152) = v55;
      float v56 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUNeuralNet *)((char *)this + 32), 0);
      ausdk::AUElement::SetParameter(v56, 0x18u, *((float *)this + 152), 0);
      float v57 = *((float *)this + 157);
      float v58 = 0.0;
      if (v57 != 0.0)
      {
        float v59 = **((double **)this + 100);
        float v58 = expf(-1.0 / (float)((float)(v57 * v59) / (float)a2));
      }
      float v60 = 1.0 - v58;
      if (*((unsigned char *)this + 601))
      {
        *((_DWORD *)this + 160) = 0;
        unsigned int v61 = *((_DWORD *)this + 159);
        if (!v61) {
          *(void *)((char *)this + 644) = 1065353216;
        }
        if (v61 >= *((_DWORD *)this + 158))
        {
          unsigned int v77 = *((_DWORD *)this + 164);
          unsigned int v78 = *((_DWORD *)this + 165);
          if (v77 >= v78) {
            int v79 = *((_DWORD *)this + 165);
          }
          else {
            int v79 = *((_DWORD *)this + 164);
          }
          if (v79)
          {
            uint64_t v80 = 0;
            unint64_t v81 = 0;
            do
            {
              uint64_t v82 = *v32;
              if (v82)
              {
                memmove((void *)(*((void *)this + 110) + 4 * (v82 * v81)), *(const void **)(*((void *)this + 132) + v80), 4 * v82);
                unsigned int v77 = *((_DWORD *)this + 164);
                unsigned int v78 = *((_DWORD *)this + 165);
              }
              ++v81;
              if (v77 >= v78) {
                unint64_t v83 = v78;
              }
              else {
                unint64_t v83 = v77;
              }
              v80 += 24;
            }
            while (v81 < v83);
          }
        }
        else
        {
          float v62 = (float)(v60 * *((float *)this + 162)) + (float)(v58 * *((float *)this + 161));
          *((float *)this + 161) = v62;
          float __D = 1.0 - v62;
          unsigned int v63 = *((_DWORD *)this + 164);
          if (v63 >= *((_DWORD *)this + 165)) {
            unsigned int v63 = *((_DWORD *)this + 165);
          }
          if (v63)
          {
            uint64_t v64 = 0;
            unint64_t v65 = 0;
            do
            {
              size_t v66 = (float *)(*((void *)this + 110) + 4 * *v32 * v65);
              vDSP_vsmsma(v66, 1, (const float *)this + 161, *(const float **)(*((void *)this + 132) + v64), 1, &__D, v66, 1, *v32);
              ++v65;
              LODWORD(v67) = *((_DWORD *)this + 164);
              unsigned int v68 = *((_DWORD *)this + 165);
              if (v67 >= v68) {
                unint64_t v67 = v68;
              }
              else {
                unint64_t v67 = v67;
              }
              v64 += 24;
            }
            while (v65 < v67);
            unsigned int v61 = *((_DWORD *)this + 159);
          }
          *((_DWORD *)this + 159) = v61 + 1;
        }
      }
      else
      {
        *((_DWORD *)this + 159) = 0;
        unsigned int v69 = *((_DWORD *)this + 160);
        if (!v69) {
          *(void *)((char *)this + 644) = 0x3F80000000000000;
        }
        if (v69 < *((_DWORD *)this + 158))
        {
          float v70 = (float)(v60 * *((float *)this + 162)) + (float)(v58 * *((float *)this + 161));
          *((float *)this + 161) = v70;
          float __D = 1.0 - v70;
          unsigned int v71 = *((_DWORD *)this + 164);
          if (v71 >= *((_DWORD *)this + 165)) {
            unsigned int v71 = *((_DWORD *)this + 165);
          }
          if (v71)
          {
            uint64_t v72 = 0;
            unint64_t v73 = 0;
            do
            {
              long long v74 = (float *)(*((void *)this + 110) + 4 * *v32 * v73);
              vDSP_vsmsma(v74, 1, (const float *)this + 161, *(const float **)(*((void *)this + 132) + v72), 1, &__D, v74, 1, *v32);
              ++v73;
              LODWORD(v75) = *((_DWORD *)this + 164);
              unsigned int v76 = *((_DWORD *)this + 165);
              if (v75 >= v76) {
                unint64_t v75 = v76;
              }
              else {
                unint64_t v75 = v75;
              }
              v72 += 24;
            }
            while (v73 < v75);
            unsigned int v69 = *((_DWORD *)this + 160);
          }
          *((_DWORD *)this + 160) = v69 + 1;
        }
      }
    }
    else
    {
      if (v53 >= v54) {
        AUNeuralNet::ProcessAUNNModel((uint64_t)this, __N);
      }
      else {
        vDSP_vclr(*((float **)this + 110), 1, (uint64_t)(*((void *)this + 111) - *((void *)this + 110)) >> 2);
      }
      HIDWORD(v114) = 0;
      vDSP_measqv(*((const float **)this + 110), 1, (float *)&v114 + 1, (uint64_t)(*((void *)this + 111) - *((void *)this + 110)) >> 2);
      if (*((unsigned char *)this + 652))
      {
        float v84 = *((float *)&v114 + 1);
        *((unsigned char *)this + 652) = 0;
      }
      else
      {
        float v84 = (float)((float)(1.0 - *((float *)this + 156)) * *((float *)&v114 + 1))
            + (float)(*((float *)this + 156) * *((float *)this + 152));
      }
      *((float *)this + 152) = v84;
      int v85 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUNeuralNet *)((char *)this + 32), 0);
      ausdk::AUElement::SetParameter(v85, 0x18u, *((float *)this + 152), 0);
    }
    unsigned int v86 = *v32;
    unsigned int v87 = *((_DWORD *)this + 136);
    if (*v32 >= v87) {
      unsigned int v88 = *((_DWORD *)this + 136);
    }
    else {
      unsigned int v88 = *v32;
    }
    BOOL v89 = v87 >= v86;
    unsigned int v90 = v87 - v86;
    if (!v89) {
      unsigned int v90 = 0;
    }
    memcpy((void *)(*((void *)this + 135) + 4 * v90), *((const void **)this + 110), 4 * v88);
    vDSP_measqv(*((const float **)this + 135), 1, &__C, *((unsigned int *)this + 136));
    float v91 = *((float *)this + 156);
    float v92 = *((float *)this + 140);
    *((float *)this + 140) = (float)((float)(1.0 - v91) * (float)(log10f(__C + 2.2204e-16) * 10.0)) + (float)(v91 * v92);
    double v93 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUNeuralNet *)((char *)this + 32), 0);
    ausdk::AUElement::SetParameter(v93, 4u, *((float *)this + 140), 0);
    uint64_t v94 = *v32;
    unsigned int v95 = *((_DWORD *)this + 136);
    if (v95 > v94) {
      memcpy(*((void **)this + 135), (const void *)(*((void *)this + 135) + 4 * v94), 4 * (v95 - v94));
    }
    uint64_t v96 = *((unsigned int *)this + 165);
    if (v96)
    {
      unsigned int v97 = 0;
      uint64_t v98 = 0;
      unsigned int v99 = *v32;
      do
      {
        if ((v110 & 0x20) != 0) {
          uint64_t v100 = *(_DWORD **)(v107 + 16 * v98 + 16);
        }
        else {
          uint64_t v100 = (_DWORD *)(*(void *)(v107 + 16) + 4 * v98);
        }
        if (a2)
        {
          uint64_t v101 = *((void *)this + 110);
          unsigned int v102 = v97;
          uint64_t v103 = a2;
          do
          {
            *uint64_t v100 = *(_DWORD *)(v101 + 4 * v102++);
            v100 += v105;
            --v103;
          }
          while (v103);
        }
        ++v98;
        v97 += v99;
      }
      while (v98 != v96);
    }
    return 0;
  }
  if (getAUNeuralNetLog(void)::onceToken != -1) {
    dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
  }
  double v40 = getAUNeuralNetLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
  {
    unsigned int v104 = *v32;
    float __C = 3.8522e-34;
    unint64_t v116 = this;
    __int16 v117 = 1024;
    unsigned int v118 = v104;
    __int16 v119 = 1024;
    unsigned int v120 = a2;
    _os_log_error_impl(&dword_1BB0CE000, v40, OS_LOG_TYPE_ERROR, "[%p] NeuralNet expects input block size %u, and we received %d.", (uint8_t *)&__C, 0x18u);
  }
  return 4294956422;
}

float AUNeuralNet::ComputeGainMask(AUNeuralNet *this, unsigned int a2, const AudioBufferList *a3, const AudioBufferList *a4)
{
  float __C = 0.0;
  if (*((unsigned char *)this + 664))
  {
    mData = (const float *)a3->mBuffers[0].mData;
    vDSP_svesq(mData, 1, &__C, (2 * *((_DWORD *)this + 136)));
    int v8 = *((_DWORD *)this + 136);
    if (2 * v8)
    {
      memmove(*((void **)this + 138), mData, 4 * (2 * v8));
      int v8 = *((_DWORD *)this + 136);
    }
    int v9 = (float *)*((void *)this + 138);
    unsigned int v10 = &v9[v8];
    LODWORD(__B.realp) = 629145600;
    float v11 = *v9;
    float v12 = *v10;
    __A.realp = v9 + 1;
    __A.imagp = v10 + 1;
    vDSP_zvabs(&__A, 1, v9 + 1, 1, (v8 - 1));
    float *v9 = fabsf(v11);
    *unsigned int v10 = fabsf(v12);
    vDSP_vthr(v9, 1, (const float *)&__B, v9, 1, (v8 + 1));
    if (*((_DWORD *)this + 165))
    {
      uint64_t v13 = 0;
      unint64_t v14 = 0;
      p_mData = &a4->mBuffers[0].mData;
      do
      {
        int v16 = (char *)*p_mData;
        p_mData += 2;
        vDSP_svesq((const float *)v16, 1, (float *)(*((void *)this + 165) + v13), (2 * *((_DWORD *)this + 136)));
        uint64_t v17 = *((unsigned int *)this + 136);
        vDSP_Stride v18 = (float *)*((void *)this + 141);
        uint64_t v19 = (float *)&v16[4 * v17];
        float v20 = *(float *)v16;
        float v21 = *v19;
        __A.realp = (float *)(v16 + 4);
        __A.imagp = v19 + 1;
        vDSP_zvabs(&__A, 1, v18 + 1, 1, (v17 - 1));
        *vDSP_Stride v18 = fabsf(v20);
        v18[v17] = fabsf(v21);
        vDSP_vdiv(*((const float **)this + 138), 1, *((const float **)this + 141), 1, (float *)(*((void *)this + 113) + 4 * ((*((_DWORD *)this + 136) + 1) * v14++)), 1, (*((_DWORD *)this + 136) + 1));
        v13 += 4;
      }
      while (v14 < *((unsigned int *)this + 165));
    }
    return __C;
  }
  int v23 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 80), 0) + 92);
  int v24 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 128), 0) + 92);
  if ((v23 & 0x20) != 0)
  {
    uint64_t v25 = 1;
    if ((v24 & 0x20) != 0)
    {
LABEL_10:
      uint64_t v26 = 1;
      if (a2) {
        goto LABEL_11;
      }
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t v25 = *(unsigned int *)(ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 80), 0) + 108);
    if ((v24 & 0x20) != 0) {
      goto LABEL_10;
    }
  }
  uint64_t v26 = *(unsigned int *)(ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 128), 0) + 108);
  if (a2)
  {
LABEL_11:
    uint64_t v27 = 0;
    float v28 = a3->mBuffers[0].mData;
    double v29 = (char *)*((void *)this + 126);
    do
    {
      *(_DWORD *)&v29[v27] = *v28;
      v27 += 4;
      v28 += v25;
    }
    while (4 * a2 != v27);
    goto LABEL_17;
  }
LABEL_16:
  double v29 = (char *)*((void *)this + 126);
LABEL_17:
  memcpy((void *)(*((void *)this + 123) + 4 * *((unsigned int *)this + 244)), v29, 4 * *((unsigned int *)this + 136));
  uint64_t v30 = *((unsigned int *)this + 136);
  __A.realp = (float *)*((void *)this + 138);
  __A.imagp = &__A.realp[v30];
  uint64_t v31 = __A.realp + 1;
  __B.realp = __A.realp + 1;
  __B.imagp = __A.imagp + 1;
  double v32 = (VPTimeFreqConverter *)*((void *)this + 144);
  if (v32)
  {
    VPTimeFreqConverter::Analyze(v32, *((const float **)this + 123), &__A);
    LODWORD(v30) = *((_DWORD *)this + 136);
  }
  vDSP_zvabs(&__B, 1, v31, 1, (v30 - 1));
  realp = __A.realp;
  *__A.realp = fabsf(*__A.realp);
  *__A.imagp = fabsf(*__A.imagp);
  vDSP_vthr(realp, 1, &AUNeuralNet::eps, realp, 1, (*((_DWORD *)this + 136) + 1));
  if (*((_DWORD *)this + 165))
  {
    unint64_t v34 = 0;
    uint64_t v35 = 4 * v26;
    do
    {
      if ((v24 & 0x20) != 0) {
        float v36 = (float *)a4->mBuffers[v34].mData;
      }
      else {
        float v36 = (float *)((char *)a4->mBuffers[0].mData + 4 * v34);
      }
      uint64_t v37 = (const float *)*((void *)this + 129);
      unsigned int v38 = (float *)v37;
      uint64_t v39 = a2;
      if (a2)
      {
        do
        {
          *v38++ = *v36;
          float v36 = (float *)((char *)v36 + v35);
          --v39;
        }
        while (v39);
      }
      vDSP_svesq(v37, 1, (float *)(*((void *)this + 165) + 4 * v34), *((unsigned int *)this + 136));
      uint64_t v40 = *((unsigned int *)this + 136);
      v46.realp = (float *)*((void *)this + 141);
      v46.imagp = &v46.realp[v40];
      uint64_t v41 = v46.realp + 1;
      v45.realp = v46.realp + 1;
      v45.imagp = v46.imagp + 1;
      unint64_t v42 = *(VPTimeFreqConverter **)(*((void *)this + 145) + 8 * v34);
      if (v42)
      {
        VPTimeFreqConverter::Analyze(v42, *((const float **)this + 129), &v46);
        uint64_t v41 = v45.realp;
        LODWORD(v40) = *((_DWORD *)this + 136);
      }
      vDSP_zvabs(&v45, 1, v41, 1, (v40 - 1));
      long double v43 = v46.realp;
      *v46.realp = fabsf(*v46.realp);
      *v46.imagp = fabsf(*v46.imagp);
      vDSP_vdiv(__A.realp, 1, v43, 1, (float *)(*((void *)this + 113) + 4 * ((*((_DWORD *)this + 136) + 1) * v34++)), 1, (*((_DWORD *)this + 136) + 1));
    }
    while (v34 < *((unsigned int *)this + 165));
  }
  vDSP_svesq(*((const float **)this + 123), 1, &__C, *((unsigned int *)this + 136));
  memmove(*((void **)this + 123), (const void *)(*((void *)this + 123) + 4 * *((unsigned int *)this + 136)), 4 * *((unsigned int *)this + 244));
  return __C;
}

uint64_t AUNeuralNet::ApplyEmbedding(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = a1 + 1240;
  int v4 = caulk::pooled_semaphore_mutex::try_lock((caulk::pooled_semaphore_mutex *)(a1 + 1240));
  char v13 = v4;
  if (v4)
  {
    if (*(unsigned char *)(a1 + 592))
    {
      int v5 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 64) + 56))(*(void *)(a2 + 64), a1 + 856);
    }
    else
    {
      if (!*(unsigned char *)(a1 + 593)) {
        return std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v12);
      }
      int v5 = (*(uint64_t (**)(void, double))(**(void **)(a2 + 64) + 64))(*(void *)(a2 + 64), 0.0);
    }
    int v6 = v5;
    if (v5)
    {
      uint64_t v7 = _os_log_pack_size();
      uint64_t message = caulk::deferred_logger::create_message(*(caulk::deferred_logger **)(a1 + 528), v7 + 88, 16);
      if (message)
      {
        int v9 = (caulk::concurrent::message *)message;
        unsigned int v10 = (_DWORD *)_os_log_pack_fill();
        *unsigned int v10 = 67109120;
        v10[1] = v6;
        caulk::concurrent::messenger::enqueue(*(caulk::concurrent::messenger **)(*(void *)(a1 + 528) + 16), v9);
      }
    }
  }
  return std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v12);
}

void sub_1BB3A1808(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void AUNeuralNet::ProcessAUNNModel(uint64_t a1, uint64_t a2)
{
  int v4 = (const void **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 64) + 72))(*(void *)(a2 + 64), a1 + 832);
  int v5 = *(_DWORD *)(a1 + 660);
  if (v5 * *(_DWORD *)(a2 + 20)) {
    memmove(*(void **)(a1 + 880), *v4, 4 * (v5 * *(_DWORD *)(a2 + 20)));
  }
  vDSP_vsdiv(*(const float **)(a1 + 880), 1, (const float *)(a1 + 548), *(float **)(a1 + 880), 1, (uint64_t)(*(void *)(a1 + 888) - *(void *)(a1 + 880)) >> 2);
  float v6 = *(float *)(a1 + 572);
  float __D = 1.0 - v6;
  if (*(_DWORD *)(a1 + 660) == 1 && v6 > __exp10f(-5.0))
  {
    vDSP_vsmsma(**(const float ***)(a1 + 1056), 1, (const float *)(a1 + 572), *(const float **)(a1 + 880), 1, &__D, *(float **)(a1 + 880), 1, (uint64_t)(*(void *)(a1 + 888) - *(void *)(a1 + 880)) >> 2);
  }
  else if (*(_DWORD *)(a2 + 24) >= 2u && *(_DWORD *)(a2 + 8) == 1 && *(_DWORD *)(a2 + 12) == 1)
  {
    float v7 = *(float *)(a1 + 572);
    if (v7 > __exp10f(-5.0))
    {
      if (*(_DWORD *)(a1 + 656))
      {
        uint64_t v8 = 0;
        unint64_t v9 = 0;
        do
        {
          unsigned int v10 = (float *)(*(void *)(a1 + 880) + 4 * (*(_DWORD *)(a2 + 20) * v9));
          vDSP_vsmsma(*(const float **)(*(void *)(a1 + 1056) + v8), 1, (const float *)(a1 + 572), v10, 1, &__D, v10, 1, *(unsigned int *)(a2 + 20));
          ++v9;
          v8 += 24;
        }
        while (v9 < *(unsigned int *)(a1 + 656));
      }
    }
  }
}

os_log_t ___Z17getAUNeuralNetLogv_block_invoke()
{
  os_log_t result = os_log_create("com.apple.coreaudio", "AUNeuralNet");
  getAUNeuralNetLog(void)::gLog = (uint64_t)result;
  return result;
}

uint64_t AUNeuralNet::CanScheduleParameters(AUNeuralNet *this)
{
  return 0;
}

uint64_t AUNeuralNet::SetParameter(AUNeuralNet *this, uint64_t a2, int a3, unsigned int a4, float a5)
{
  if (a3) {
    return 4294956418;
  }
  uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUNeuralNet *)((char *)this + 32), 0);
  ausdk::AUElement::SetParameter(Element, a2, a5, 0);
  (*(void (**)(AUNeuralNet *, void, uint64_t, char *))(*(void *)this + 256))(this, 0, a2, (char *)this + 696);
  if (a2 == 20)
  {
    uint64_t v11 = *((void *)this + 107);
    if (*(_DWORD *)(*((void *)this + 100) + 104 * *((unsigned int *)this + 141) + 28) > a4
      && (*((void *)this + 108) - v11) >> 2 > (unint64_t)a4)
    {
      uint64_t result = 0;
      *(float *)(v11 + 4 * a4) = a5;
    }
    else
    {
      return 4294956419;
    }
  }
  else if (a2 == 5 || (*((_DWORD *)this + 198) & 0x8000) == 0)
  {
    uint64_t result = 0;
    ++*((void *)this + 85);
  }
  else
  {
    return 0;
  }
  return result;
}

uint64_t AUNeuralNet::SetProperty(AUNeuralNet *this, int a2, int a3, unsigned int a4, char *__src, size_t __n)
{
  uint64_t v91 = *MEMORY[0x1E4F143B8];
  if (a3) {
    return 4294956417;
  }
  unsigned int v8 = __n;
  uint64_t v6 = 4294956417;
  if (a2 <= 3999)
  {
    switch(a2)
    {
      case 3694:
        if (__n != 4) {
          return 4294956445;
        }
        uint64_t v6 = 0;
        *((_DWORD *)this + 328) = *(_DWORD *)__src;
        return v6;
      case 3695:
        if (*((unsigned char *)this + 17)) {
          return 4294956447;
        }
        if (__n != 4) {
          return 4294956445;
        }
        if (*(_DWORD *)__src < 5u)
        {
          uint64_t v6 = 0;
          *((_DWORD *)this + 318) = *(_DWORD *)__src;
          return v6;
        }
        if (getAUNeuralNetLog(void)::onceToken != -1) {
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
        }
        uint64_t v17 = getAUNeuralNetLog(void)::gLog;
        if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
        {
          LODWORD(__N_4[0]) = 134217984;
          *(void *)((char *)__N_4 + 4) = this;
          vDSP_Stride v18 = "[%p] Bad Property Value for Speech Mask selection";
          goto LABEL_159;
        }
        return 4294956445;
      case 3696:
        if (*((unsigned char *)this + 17)) {
          return 4294956447;
        }
        uint64_t v19 = *((unsigned int *)this + 84);
        if (__n != 4 * (v19 + 1)) {
          return 4294956445;
        }
        std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)this + 1280, __src, (uint64_t)&__src[4 * v19 + 4], (4 * v19 + 4) >> 2);
        return 0;
      case 3697:
        if (*((unsigned char *)this + 17)) {
          return 4294956447;
        }
        if (!__src || __n != 8)
        {
          if (getAUNeuralNetLog(void)::onceToken != -1) {
            dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
          }
          uint64_t v17 = getAUNeuralNetLog(void)::gLog;
          if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
          {
            LODWORD(__N_4[0]) = 134217984;
            *(void *)((char *)__N_4 + 4) = this;
            vDSP_Stride v18 = "[%p] The NeuralNetPlist passed to SetProperty is not CFDictionaryRef type or it's null.";
            goto LABEL_159;
          }
          return 4294956445;
        }
        applesauce::CF::DictionaryRef::from_get((applesauce::CF::DictionaryRef *)__N_4, *(CFTypeRef *)__src);
        uint64_t v20 = *((void *)this + 149);
        *((void *)this + 149) = *(void *)&__N_4[0];
        *(void *)&__N_4[0] = v20;
        applesauce::CF::DictionaryRef::~DictionaryRef((const void **)__N_4);
        for (uint64_t i = 0; i != 624; i += 104)
        {
          uint64_t v22 = *((void *)this + 100) + i;
          if (*(unsigned char *)(v22 + 96))
          {
            NeuralNet::~NeuralNet((NeuralNet *)(v22 + 64));
            *(unsigned char *)(v22 + 96) = 0;
            char v88 = 0;
            LOBYTE(v87[0]) = 0;
            memset(__N_4, 0, sizeof(__N_4));
            uint64_t v23 = *((void *)this + 100) + i;
            *(_OWORD *)uint64_t v23 = 0u;
            *(_OWORD *)(v23 + 16) = 0u;
            int v24 = (void **)(v23 + 32);
            if (*(char *)(v23 + 55) < 0) {
              operator delete(*v24);
            }
            long long v25 = __N_4[2];
            *(void *)(v23 + 48) = *(void *)&__N_4[3];
            *(_OWORD *)int v24 = v25;
            BYTE7(__N_4[3]) = 0;
            LOBYTE(__N_4[2]) = 0;
            uint64_t v26 = *(void *)(v23 + 56);
            *(void *)(v23 + 56) = *((void *)&__N_4[3] + 1);
            *((void *)&__N_4[3] + 1) = v26;
            std::__optional_storage_base<NeuralNet,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<NeuralNet,false>>((NeuralNet *)(v23 + 64), v87);
            if (v88) {
              NeuralNet::~NeuralNet((NeuralNet *)v87);
            }
            if (*((void *)&__N_4[3] + 1)) {
              CFRelease(*((CFTypeRef *)&__N_4[3] + 1));
            }
            if (SBYTE7(__N_4[3]) < 0) {
              operator delete(*(void **)&__N_4[2]);
            }
          }
        }
        uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUNeuralNet *)((char *)this + 32), 0);
        ausdk::AUElement::SetParameter(Element, 0, 0.0, 0);
        uint64_t v28 = 0;
        uint64_t v29 = 56;
        *((_DWORD *)this + 206) = 0;
        break;
      case 3698:
        goto LABEL_176;
      case 3699:
        return v6;
      case 3700:
        uint64_t v6 = 4294956445;
        if (__n >= 4)
        {
          if (*__src) {
            return 0;
          }
          else {
            return 4294956445;
          }
        }
        return v6;
      default:
        if (a2 == 21)
        {
          if (__n < 4) {
            return 4294956445;
          }
          uint64_t v6 = 0;
          *((_DWORD *)this + 167) = *(_DWORD *)__src;
          return v6;
        }
        if (a2 != 3670) {
          return v6;
        }
        uint64_t v12 = (void *)*((void *)this + 107);
        if (*((void *)this + 108) - (void)v12 == __n)
        {
          memcpy(v12, __src, __n);
          return 0;
        }
        if (getAUNeuralNetLog(void)::onceToken != -1) {
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
        }
        uint64_t v58 = getAUNeuralNetLog(void)::gLog;
        if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
        {
          uint64_t v59 = *((void *)this + 108) - *((void *)this + 107);
          LODWORD(__N_4[0]) = 134218496;
          *(void *)((char *)__N_4 + 4) = this;
          WORD6(__N_4[0]) = 2048;
          *(void *)((char *)__N_4 + 14) = v8;
          WORD3(__N_4[1]) = 2048;
          *((void *)&__N_4[1] + 1) = v59;
          vDSP_Stride v18 = "[%p] Input size of EmbeddingVector  (%lu) is not equal to the the expected size  (%lu).";
          goto LABEL_154;
        }
        return 4294956445;
    }
    while (1)
    {
      std::to_string(&buf, v28);
      uint64_t v30 = std::string::insert(&buf, 0, "Model_", 6uLL);
      long long v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
      *(void *)&__N_4[1] = *((void *)&v30->__r_.__value_.__l + 2);
      __N_4[0] = v31;
      v30->__r_.__value_.__l.__size_ = 0;
      v30->__r_.__value_.__r.__words[2] = 0;
      v30->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
      if ((SBYTE7(__N_4[1]) & 0x80u) == 0) {
        double v32 = (const char *)__N_4;
      }
      else {
        double v32 = *(const char **)&__N_4[0];
      }
      CFStringRef v33 = CFStringCreateWithCString(0, v32, 0x8000100u);
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      unint64_t v34 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      {
        if ((SBYTE7(__N_4[1]) & 0x80u) == 0) {
          uint64_t v35 = __N_4;
        }
        else {
          uint64_t v35 = *(_OWORD **)&__N_4[0];
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 134218242;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)this;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v35;
        _os_log_impl(&dword_1BB0CE000, v34, OS_LOG_TYPE_INFO, "[%p] Searching plist for model named (%s)...", (uint8_t *)&buf, 0x16u);
      }
      int v36 = CFDictionaryContainsKey(*((CFDictionaryRef *)this + 149), v33);
      if (v36)
      {
        if (getAUNeuralNetLog(void)::onceToken != -1) {
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
        }
        uint64_t v37 = getAUNeuralNetLog(void)::gLog;
        if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
        {
          if ((SBYTE7(__N_4[1]) & 0x80u) == 0) {
            unsigned int v38 = __N_4;
          }
          else {
            unsigned int v38 = *(_OWORD **)&__N_4[0];
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 134218242;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)this;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v38;
          _os_log_impl(&dword_1BB0CE000, v37, OS_LOG_TYPE_INFO, "[%p] Found model named (%s)...", (uint8_t *)&buf, 0x16u);
        }
        CFNumberRef Value = CFDictionaryGetValue(*((CFDictionaryRef *)this + 149), v33);
        uint64_t v40 = Value;
        if (Value) {
          CFRetain(Value);
        }
        applesauce::CF::DictionaryRef::DictionaryRef((applesauce::CF::DictionaryRef *)&buf, v40);
        uint64_t v41 = *((void *)this + 100);
        unint64_t v42 = *(const void **)(v41 + v29);
        *(void *)(v41 + v29) = buf.__r_.__value_.__r.__words[0];
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v42;
        if (v42) {
          CFRelease(v42);
        }
        CFRelease(v33);
        int v43 = v28 + 1;
      }
      else
      {
        if (getAUNeuralNetLog(void)::onceToken != -1) {
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
        }
        uint64_t v44 = getAUNeuralNetLog(void)::gLog;
        if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
        {
          if ((SBYTE7(__N_4[1]) & 0x80u) == 0) {
            DSPSplitComplex v45 = __N_4;
          }
          else {
            DSPSplitComplex v45 = *(_OWORD **)&__N_4[0];
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 134218242;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)this;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v45;
          _os_log_impl(&dword_1BB0CE000, v44, OS_LOG_TYPE_INFO, "[%p] Did not find model named (%s)...", (uint8_t *)&buf, 0x16u);
        }
        CFRelease(v33);
        if (v28) {
          goto LABEL_110;
        }
        if (getAUNeuralNetLog(void)::onceToken != -1) {
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
        }
        long long v47 = getAUNeuralNetLog(void)::gLog;
        if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 134217984;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)this;
          _os_log_impl(&dword_1BB0CE000, v47, OS_LOG_TYPE_INFO, "[%p] Assuming 1 un-named model exists in the plist", (uint8_t *)&buf, 0xCu);
        }
        applesauce::CF::DictionaryRef::from_get((applesauce::CF::DictionaryRef *)&buf, *(CFTypeRef *)__src);
        uint64_t v48 = *((void *)this + 100);
        std::string::size_type v49 = *(void *)(v48 + 56);
        *(void *)(v48 + 56) = buf.__r_.__value_.__r.__words[0];
        buf.__r_.__value_.__r.__words[0] = v49;
        applesauce::CF::DictionaryRef::~DictionaryRef((const void **)&buf.__r_.__value_.__l.__data_);
        int v43 = 1;
      }
      *((_DWORD *)this + 206) = v43;
LABEL_110:
      if (SBYTE7(__N_4[1]) < 0) {
        operator delete(*(void **)&__N_4[0]);
      }
      if (v36)
      {
        v29 += 104;
        if (v28++ != 5) {
          continue;
        }
      }
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      uint64_t v62 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      {
        int v63 = *((_DWORD *)this + 206);
        LODWORD(__N_4[0]) = 134218240;
        *(void *)((char *)__N_4 + 4) = this;
        WORD6(__N_4[0]) = 1024;
        *(_DWORD *)((char *)__N_4 + 14) = v63;
        uint64_t v64 = "[%p] Finished finding models. Found (%u) models";
        goto LABEL_165;
      }
      return 0;
    }
  }
  if (a2 <= 103669)
  {
    if (a2 <= 4001)
    {
      if (a2 == 4000)
      {
        if (!*((unsigned char *)this + 17))
        {
          if (__n == 4)
          {
            uint64_t v6 = 0;
            *((unsigned char *)this + 1372) = *(_DWORD *)__src != 0;
            return v6;
          }
          return 4294956445;
        }
      }
      else if (!*((unsigned char *)this + 17))
      {
        if (__n == 4)
        {
          uint64_t v6 = 0;
          *((_DWORD *)this + 157) = *(_DWORD *)__src;
          return v6;
        }
        return 4294956445;
      }
      return 4294956447;
    }
    if (a2 == 4002)
    {
      if (!*((unsigned char *)this + 17))
      {
        if (__n == 4)
        {
          uint64_t v6 = 0;
          int v55 = *(_DWORD *)__src;
          *((_DWORD *)this + 158) = *(_DWORD *)__src;
          *((_DWORD *)this + 159) = v55;
          *((_DWORD *)this + 160) = v55;
          *((unsigned char *)this + 652) = 1;
          return v6;
        }
        return 4294956445;
      }
      return 4294956447;
    }
    if (a2 != 40000) {
      return v6;
    }
    if (*((unsigned char *)this + 17)) {
      return 4294956447;
    }
    if (__n != 8) {
      return 4294956445;
    }
    if (__src)
    {
      applesauce::CF::StringRef::from_get((applesauce::CF::StringRef *)__N_4, *(CFTypeRef *)__src);
      uint64_t v13 = *((void *)this + 148);
      *((void *)this + 148) = *(void *)&__N_4[0];
      *(void *)&__N_4[0] = v13;
      applesauce::CF::StringRef::~StringRef((const void **)__N_4);
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      unint64_t v14 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      {
        applesauce::CF::convert_to<std::string,0>(*((const __CFString **)this + 148), (uint64_t)__N_4);
        uint64_t v15 = (SBYTE7(__N_4[1]) & 0x80u) == 0 ? __N_4 : *(_OWORD **)&__N_4[0];
        LODWORD(buf.__r_.__value_.__l.__data_) = 134218242;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)this;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v15;
        _os_log_impl(&dword_1BB0CE000, v14, OS_LOG_TYPE_INFO, "[%p] ModelNetPathBase is overriden to %s", (uint8_t *)&buf, 0x16u);
        if (SBYTE7(__N_4[1]) < 0) {
          operator delete(*(void **)&__N_4[0]);
        }
      }
      return 0;
    }
    uint64_t v73 = *((void *)this + 148);
    *((void *)this + 148) = 0;
    *(void *)&__N_4[0] = v73;
    applesauce::CF::StringRef::~StringRef((const void **)__N_4);
    if (getAUNeuralNetLog(void)::onceToken != -1) {
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
    }
    uint64_t v74 = getAUNeuralNetLog(void)::gLog;
    if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO)) {
      return 0;
    }
    LODWORD(__N_4[0]) = 134217984;
    *(void *)((char *)__N_4 + 4) = this;
    uint64_t v64 = "[%p] ModelNetPathBaseOverride is set to null and thus removed";
    unint64_t v65 = v74;
    uint32_t v66 = 12;
    goto LABEL_198;
  }
  if (a2 > 103799)
  {
    if (a2 != 103800)
    {
      if (a2 != 103801) {
        return v6;
      }
      if (__n != 4) {
        return 4294956445;
      }
      int v16 = *(_DWORD *)__src;
      if (!*((unsigned char *)this + 1401)) {
        *((unsigned char *)this + 1401) = 1;
      }
      uint64_t v6 = 0;
      *((unsigned char *)this + 1400) = v16 != 0;
      return v6;
    }
    if (__src && __n == 8)
    {
      if (*((unsigned char *)this + 17)) {
        return 4294956447;
      }
      uint64_t v56 = *((void *)this + 100);
      if (*((void *)this + 101) != v56 && *(void *)(v56 + 56))
      {
        applesauce::CF::DictionaryRef::from_get((applesauce::CF::DictionaryRef *)__N_4, *(CFTypeRef *)__src);
        uint64_t v57 = *((void *)this + 150);
        *((void *)this + 150) = *(void *)&__N_4[0];
        *(void *)&__N_4[0] = v57;
        applesauce::CF::DictionaryRef::~DictionaryRef((const void **)__N_4);
        return 0;
      }
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      unsigned int v69 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
      {
        LODWORD(__N_4[0]) = 134217984;
        *(void *)((char *)__N_4 + 4) = this;
        _os_log_error_impl(&dword_1BB0CE000, v69, OS_LOG_TYPE_ERROR, "[%p] No model found in plist. Cannot set NeuralNetBNNSData_CF before NeuralNetPlist", (uint8_t *)__N_4, 0xCu);
      }
LABEL_176:
      if (*((unsigned char *)this + 17)) {
        return 4294956447;
      }
      if (v8 != 4) {
        return 4294956445;
      }
      int v70 = *(_DWORD *)__src;
      if (*(_DWORD *)__src <= 2u)
      {
        uint64_t v6 = 0;
        *((_DWORD *)this + 312) = v70;
        return v6;
      }
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      uint64_t v71 = getAUNeuralNetLog(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
        return 4294956445;
      }
      LODWORD(__N_4[0]) = 134218240;
      *(void *)((char *)__N_4 + 4) = this;
      WORD6(__N_4[0]) = 1024;
      *(_DWORD *)((char *)__N_4 + 14) = v70;
      vDSP_Stride v18 = "[%p] Received invalid block processor type value %u";
      float v60 = v71;
      uint32_t v61 = 18;
    }
    else
    {
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      uint64_t v17 = getAUNeuralNetLog(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
        return 4294956445;
      }
      LODWORD(__N_4[0]) = 134217984;
      *(void *)((char *)__N_4 + 4) = this;
      vDSP_Stride v18 = "[%p] The NeuralNetBNNSData_CF passed to SetProperty is not CFDictionaryRef type or it's null.";
LABEL_159:
      float v60 = v17;
      uint32_t v61 = 12;
    }
LABEL_160:
    _os_log_error_impl(&dword_1BB0CE000, v60, OS_LOG_TYPE_ERROR, v18, (uint8_t *)__N_4, v61);
    return 4294956445;
  }
  if (a2 != 103670)
  {
    if (a2 != 103696) {
      return v6;
    }
    if (*((unsigned char *)this + 17)) {
      return 4294956447;
    }
    if (__n != 8) {
      return 4294956445;
    }
    CFDictionaryRef v11 = *(const __CFDictionary **)__src;
    unsigned int __N = 0;
    if (AUNeuralNetLogScope(void)::once != -1) {
      dispatch_once(&AUNeuralNetLogScope(void)::once, &__block_literal_global_3112);
    }
    buf.__r_.__value_.__r.__words[0] = AUNeuralNetLogScope(void)::scope;
    DictionaryBlobReader::ReadScalarFromDictionary<unsigned int>((uint64_t **)&buf, v11, @"Size", &__N);
    if (!__N) {
      return 4294956445;
    }
    LODWORD(__N_4[0]) = 1065353216;
    std::vector<float>::assign((char **)this + 160, __N, __N_4);
    if (DictionaryBlobReader::ReadVectorFromDictionary((NSObject ***)&buf, v11, @"Mask", (char **)this + 160))
    {
      LODWORD(__N_4[0]) = 1065353216;
      vDSP_vfill((const float *)__N_4, *((float **)this + 160), 1, __N);
      *((float *)this + 326) = 1.0 / (float)__N;
    }
    else
    {
      vDSP_sve(*((const float **)this + 160), 1, (float *)this + 326, (uint64_t)(*((void *)this + 161) - *((void *)this + 160)) >> 2);
      float v75 = 1.0 / (*((float *)this + 326) + 1.0e-20);
      *((float *)this + 326) = v75;
    }
    if (getAUNeuralNetLog(void)::onceToken != -1) {
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
    }
    unsigned int v76 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      LODWORD(__N_4[0]) = 134218240;
      *(void *)((char *)__N_4 + 4) = this;
      WORD6(__N_4[0]) = 1024;
      *(_DWORD *)((char *)__N_4 + 14) = __N;
      _os_log_impl(&dword_1BB0CE000, v76, OS_LOG_TYPE_INFO, "[%p] Weighting for Speech Probability mask has %d elements", (uint8_t *)__N_4, 0x12u);
    }
    if (!DictionaryBlobReader::ReadScalarFromDictionary<float>((uint64_t **)&buf, v11, @"SmoothingFactor", kCFNumberFloatType, (float *)this + 339))
    {
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      unsigned int v77 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      {
        double v78 = *((float *)this + 339);
        LODWORD(__N_4[0]) = 134218240;
        *(void *)((char *)__N_4 + 4) = this;
        WORD6(__N_4[0]) = 2048;
        *(double *)((char *)__N_4 + 14) = v78;
        _os_log_impl(&dword_1BB0CE000, v77, OS_LOG_TYPE_INFO, "[%p] Successfully retrieved SmoothingFactor (%f).", (uint8_t *)__N_4, 0x16u);
      }
    }
    if (!DictionaryBlobReader::ReadScalarFromDictionary<float>((uint64_t **)&buf, v11, @"ProbabilityThreshold", kCFNumberFloatType, (float *)this + 340))
    {
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      int v79 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      {
        double v80 = *((float *)this + 340);
        LODWORD(__N_4[0]) = 134218240;
        *(void *)((char *)__N_4 + 4) = this;
        WORD6(__N_4[0]) = 2048;
        *(double *)((char *)__N_4 + 14) = v80;
        _os_log_impl(&dword_1BB0CE000, v79, OS_LOG_TYPE_INFO, "[%p] Successfully retrieved ProbabilityThreshold (%f).", (uint8_t *)__N_4, 0x16u);
      }
    }
    if (!DictionaryBlobReader::ReadScalarFromDictionary<unsigned int>((uint64_t **)&buf, v11, @"HangoverOnSetFrames", (_DWORD *)this + 341))
    {
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      unint64_t v81 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      {
        int v82 = *((_DWORD *)this + 341);
        LODWORD(__N_4[0]) = 134218240;
        *(void *)((char *)__N_4 + 4) = this;
        WORD6(__N_4[0]) = 1024;
        *(_DWORD *)((char *)__N_4 + 14) = v82;
        _os_log_impl(&dword_1BB0CE000, v81, OS_LOG_TYPE_INFO, "[%p] Successfully retrieved HangoverOnSetFrames (%u).", (uint8_t *)__N_4, 0x12u);
      }
    }
    if (DictionaryBlobReader::ReadScalarFromDictionary<unsigned int>((uint64_t **)&buf, v11, @"HangoverOffSetFrames", (_DWORD *)this + 342))return 0; {
    if (getAUNeuralNetLog(void)::onceToken != -1)
    }
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
    uint64_t v62 = getAUNeuralNetLog(void)::gLog;
    if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO)) {
      return 0;
    }
    int v83 = *((_DWORD *)this + 342);
    LODWORD(__N_4[0]) = 134218240;
    *(void *)((char *)__N_4 + 4) = this;
    WORD6(__N_4[0]) = 1024;
    *(_DWORD *)((char *)__N_4 + 14) = v83;
    uint64_t v64 = "[%p] Successfully retrieved HangoverOffSetFrames (%u).";
LABEL_165:
    unint64_t v65 = v62;
    uint32_t v66 = 18;
LABEL_198:
    _os_log_impl(&dword_1BB0CE000, v65, OS_LOG_TYPE_INFO, v64, (uint8_t *)__N_4, v66);
    return 0;
  }
  if (__n != 8)
  {
    if (getAUNeuralNetLog(void)::onceToken != -1) {
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
    }
    uint64_t v58 = getAUNeuralNetLog(void)::gLog;
    if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      return 4294956445;
    }
    LODWORD(__N_4[0]) = 134218496;
    *(void *)((char *)__N_4 + 4) = this;
    WORD6(__N_4[0]) = 2048;
    *(void *)((char *)__N_4 + 14) = v8;
    WORD3(__N_4[1]) = 2048;
    *((void *)&__N_4[1] + 1) = 8;
    vDSP_Stride v18 = "[%p] Input size of EmbeddingVector_CF is not expected size (%lu) != (%lu)";
LABEL_154:
    float v60 = v58;
    uint32_t v61 = 32;
    goto LABEL_160;
  }
  applesauce::CF::ArrayRef::from_get((applesauce::CF::ArrayRef *)__N_4, *(CFTypeRef *)__src);
  unint64_t v50 = (const __CFArray **)applesauce::CF::ArrayRef::operator->(__N_4);
  applesauce::CF::convert_as<std::vector<float>,0>((uint64_t)&buf, *v50);
  applesauce::CF::ArrayRef::~ArrayRef((const void **)__N_4);
  if (!v90) {
    return 4294956445;
  }
  if (*((unsigned char *)this + 17))
  {
    int64_t v51 = buf.__r_.__value_.__l.__size_ - buf.__r_.__value_.__r.__words[0];
    if (*((void *)this + 108) - *((void *)this + 107) == buf.__r_.__value_.__l.__size_
                                                            - buf.__r_.__value_.__r.__words[0])
    {
      caulk::pooled_semaphore_mutex::_lock((AUNeuralNet *)((char *)this + 1240));
      uint64_t v52 = (void *)((char *)this + 856);
      float v53 = (void *)*((void *)this + 107);
      if (v53)
      {
        *((void *)this + 108) = v53;
        operator delete(v53);
        *uint64_t v52 = 0;
        *((void *)this + 108) = 0;
        *((void *)this + 109) = 0;
      }
      *(_OWORD *)uint64_t v52 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
      *((void *)this + 109) = *((void *)&buf.__r_.__value_.__l + 2);
      memset(&buf, 0, sizeof(buf));
      caulk::pooled_semaphore_mutex::_unlock((AUNeuralNet *)((char *)this + 1240));
      float v54 = 0;
      uint64_t v6 = 0;
      goto LABEL_191;
    }
    if (getAUNeuralNetLog(void)::onceToken != -1) {
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
    }
    uint64_t v72 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
    {
      uint64_t v84 = (uint64_t)(*((void *)this + 108) - *((void *)this + 107)) >> 2;
      LODWORD(__N_4[0]) = 134219008;
      *(void *)((char *)__N_4 + 4) = this;
      WORD6(__N_4[0]) = 2048;
      *(void *)((char *)__N_4 + 14) = 8;
      WORD3(__N_4[1]) = 2048;
      *((void *)&__N_4[1] + 1) = 8;
      LOWORD(__N_4[2]) = 2048;
      *(void *)((char *)&__N_4[2] + 2) = v84;
      WORD5(__N_4[2]) = 2048;
      *(void *)((char *)&__N_4[2] + 12) = v51 >> 2;
      _os_log_error_impl(&dword_1BB0CE000, v72, OS_LOG_TYPE_ERROR, "[%p] Input size of EmbeddingVector (%lu) is not equal to the the expected size  (%lu) or (%lu) is not equal to (%lu).", (uint8_t *)__N_4, 0x34u);
    }
    uint64_t v68 = 4294956445;
LABEL_190:
    float v54 = (void *)buf.__r_.__value_.__r.__words[0];
    uint64_t v6 = v68;
LABEL_191:
    if (v54) {
      operator delete(v54);
    }
    return v6;
  }
  if (getAUNeuralNetLog(void)::onceToken != -1) {
    dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
  }
  unint64_t v67 = getAUNeuralNetLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
  {
    LODWORD(__N_4[0]) = 134217984;
    *(void *)((char *)__N_4 + 4) = this;
    _os_log_impl(&dword_1BB0CE000, v67, OS_LOG_TYPE_INFO, "[%p] AU not initialized: Cache embedding vector", (uint8_t *)__N_4, 0xCu);
  }
  std::optional<std::vector<float>>::operator=[abi:ne180100]<std::vector<float>,void>((uint64_t)this + 1208, (uint64_t)&buf);
  uint64_t v68 = 0;
  uint64_t v6 = 0;
  if (v90) {
    goto LABEL_190;
  }
  return v6;
}

void sub_1BB3A2E88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
}

applesauce::CF::ArrayRef *applesauce::CF::ArrayRef::from_get(applesauce::CF::ArrayRef *this, CFTypeRef cf)
{
  uint64_t v2 = this;
  if (cf)
  {
    CFRetain(cf);
    return applesauce::CF::ArrayRef::ArrayRef(v2, cf);
  }
  else
  {
    *(void *)this = 0;
  }
  return this;
}

void *applesauce::CF::ArrayRef::operator->(void *result)
{
  if (!*result)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  return result;
}

void sub_1BB3A2FE0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void applesauce::CF::convert_as<std::vector<float>,0>(uint64_t a1, const __CFArray *a2)
{
  if (a2 && (CFTypeID TypeID = CFArrayGetTypeID(), TypeID == CFGetTypeID(a2)))
  {
    int Count = CFArrayGetCount(a2);
    int __p = 0;
    uint64_t v23 = 0;
    int v24 = 0;
    std::vector<float>::reserve(&__p, Count);
    if (Count <= 0)
    {
      uint64_t v12 = v23;
LABEL_26:
      float v21 = v24;
      *(void *)a1 = __p;
      *(void *)(a1 + 8) = v12;
      *(void *)(a1 + 16) = v21;
      *(unsigned char *)(a1 + 24) = 1;
    }
    else
    {
      CFIndex v6 = 0;
      uint64_t v7 = Count;
      while (1)
      {
        CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(a2, v6);
        uint64_t v9 = applesauce::CF::convert_as<float,0>(ValueAtIndex);
        if ((v9 & 0xFF00000000) == 0) {
          break;
        }
        int v10 = v9;
        CFDictionaryRef v11 = v23;
        if (v23 >= v24)
        {
          uint64_t v13 = (char *)__p;
          uint64_t v14 = (v23 - (unsigned char *)__p) >> 2;
          unint64_t v15 = v14 + 1;
          if ((unint64_t)(v14 + 1) >> 62) {
            std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v16 = v24 - (unsigned char *)__p;
          if ((v24 - (unsigned char *)__p) >> 1 > v15) {
            unint64_t v15 = v16 >> 1;
          }
          if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v17 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v17 = v15;
          }
          if (v17)
          {
            vDSP_Stride v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)&v24, v17);
            uint64_t v13 = (char *)__p;
            CFDictionaryRef v11 = v23;
          }
          else
          {
            vDSP_Stride v18 = 0;
          }
          uint64_t v19 = &v18[4 * v14];
          *(_DWORD *)uint64_t v19 = v10;
          uint64_t v12 = v19 + 4;
          while (v11 != v13)
          {
            int v20 = *((_DWORD *)v11 - 1);
            v11 -= 4;
            *((_DWORD *)v19 - 1) = v20;
            v19 -= 4;
          }
          int __p = v19;
          uint64_t v23 = v12;
          int v24 = &v18[4 * v17];
          if (v13) {
            operator delete(v13);
          }
        }
        else
        {
          *(_DWORD *)uint64_t v23 = v9;
          uint64_t v12 = v11 + 4;
        }
        uint64_t v23 = v12;
        if (++v6 == v7) {
          goto LABEL_26;
        }
      }
      *(unsigned char *)a1 = 0;
      *(unsigned char *)(a1 + 24) = 0;
      if (__p)
      {
        uint64_t v23 = (char *)__p;
        operator delete(__p);
      }
    }
  }
  else
  {
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 24) = 0;
  }
}

uint64_t std::optional<std::vector<float>>::operator=[abi:ne180100]<std::vector<float>,void>(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 24))
  {
    int v4 = *(void **)a1;
    if (*(void *)a1)
    {
      *(void *)(a1 + 8) = v4;
      operator delete(v4);
      *(void *)a1 = 0;
      *(void *)(a1 + 8) = 0;
      *(void *)(a1 + 16) = 0;
    }
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(void *)(a1 + 16) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(void *)(a1 + 16) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    *(unsigned char *)(a1 + 24) = 1;
  }
  return a1;
}

applesauce::CF::DictionaryRef *applesauce::CF::DictionaryRef::from_get(applesauce::CF::DictionaryRef *this, CFTypeRef cf)
{
  uint64_t v2 = this;
  if (cf)
  {
    CFRetain(cf);
    return applesauce::CF::DictionaryRef::DictionaryRef(v2, cf);
  }
  else
  {
    *(void *)this = 0;
  }
  return this;
}

__n128 std::__optional_storage_base<NeuralNet,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<NeuralNet,false>>(NeuralNet *this, uint64_t *a2)
{
  if (*((unsigned __int8 *)this + 32) == *((unsigned __int8 *)a2 + 32))
  {
    if (*((unsigned char *)this + 32))
    {
      uint64_t v4 = *a2;
      *a2 = 0;
      uint64_t v5 = *(void *)this;
      *(void *)this = v4;
      if (v5) {
        (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
      }
      __n128 result = *(__n128 *)(a2 + 1);
      *(__n128 *)((char *)this + 8) = result;
      uint64_t v7 = *((void *)this + 3);
      *((void *)this + 3) = a2[3];
      a2[3] = v7;
    }
  }
  else if (*((unsigned char *)this + 32))
  {
    NeuralNet::~NeuralNet(this);
    *((unsigned char *)this + 32) = 0;
  }
  else
  {
    uint64_t v8 = *a2;
    *a2 = 0;
    *(void *)this = v8;
    __n128 result = *(__n128 *)(a2 + 1);
    *(__n128 *)((char *)this + 8) = result;
    *((void *)this + 3) = a2[3];
    a2[3] = 0;
    *((unsigned char *)this + 32) = 1;
  }
  return result;
}

void ___ZL19AUNeuralNetLogScopev_block_invoke()
{
}

uint64_t AUNeuralNet::GetProperty(AUNeuralNet *this, int a2, int a3, unsigned int a4, CFArrayRef *__dst)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if (a3) {
    return 4294956417;
  }
  uint64_t result = 4294956417;
  if (a2 > 39999)
  {
    if (a2 <= 103798)
    {
      if (a2 == 40000)
      {
        int v10 = (const void *)*((void *)this + 148);
        if (!v10) {
          goto LABEL_42;
        }
        goto LABEL_41;
      }
      if (a2 == 103670)
      {
        CFArrayRef CFArray = applesauce::CF::details::make_CFArrayRef<float>((void *)this + 107);
        uint64_t result = 0;
        *long long __dst = CFArray;
        return result;
      }
      if (a2 != 103699) {
        return result;
      }
      if (*((_DWORD *)this + 165) <= a4)
      {
        if (getAUNeuralNetLog(void)::onceToken != -1) {
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
        }
        int v24 = getAUNeuralNetLog(void)::gLog;
        if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
          return 4294956419;
        }
        goto LABEL_56;
      }
      int v11 = *((_DWORD *)this + 136) + 1;
      int v12 = v11 * a4;
      int v13 = v11 + v11 * a4;
      uint64_t v14 = *((void *)this + 113);
    }
    else if (a2 > 103800)
    {
      if (a2 == 103801)
      {
        int v9 = *((unsigned __int8 *)this + 1401);
        if (*((unsigned char *)this + 1401)) {
          int v9 = *((unsigned __int8 *)this + 1400);
        }
        uint64_t result = 0;
        goto LABEL_52;
      }
      if (a2 != 1036999) {
        return result;
      }
      if (*((_DWORD *)this + 165) <= a4)
      {
        if (getAUNeuralNetLog(void)::onceToken != -1) {
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
        }
        int v24 = getAUNeuralNetLog(void)::gLog;
        if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
          return 4294956419;
        }
        goto LABEL_60;
      }
      int v18 = *((_DWORD *)this + 136);
      int v12 = v18 * a4;
      int v13 = v18 * a4 + v18;
      uint64_t v14 = *((void *)this + 116);
    }
    else
    {
      if (a2 != 103799)
      {
        int v10 = (const void *)*((void *)this + 150);
        if (!v10) {
          goto LABEL_42;
        }
LABEL_41:
        CFRetain(v10);
        goto LABEL_42;
      }
      if (*((_DWORD *)this + 165) <= a4)
      {
        if (getAUNeuralNetLog(void)::onceToken != -1) {
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
        }
        int v24 = getAUNeuralNetLog(void)::gLog;
        if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
          return 4294956419;
        }
        goto LABEL_76;
      }
      int v22 = *((_DWORD *)this + 136) + 1;
      int v12 = v22 * a4;
      int v13 = v22 + v22 * a4;
      uint64_t v14 = *((void *)this + 119);
    }
    *(void *)uint64_t v29 = 0;
    *long long __dst = applesauce::CF::details::make_CFArrayRef<float,float *>((int *)(v14 + 4 * v12), (int *)(v14 + 4 * v13));
    applesauce::CF::ArrayRef::~ArrayRef((const void **)v29);
    return 0;
  }
  if (a2 <= 3698)
  {
    if (a2 == 21)
    {
      uint64_t result = 0;
      int v9 = *((_DWORD *)this + 167);
      goto LABEL_52;
    }
    if (a2 == 3670)
    {
      uint64_t v16 = (const void *)*((void *)this + 107);
      size_t v17 = *((void *)this + 108) - (void)v16;
      goto LABEL_47;
    }
    if (a2 != 3697) {
      return result;
    }
    int v10 = (const void *)*((void *)this + 149);
    if (v10) {
      goto LABEL_41;
    }
LABEL_42:
    uint64_t result = 0;
    *long long __dst = (CFArrayRef)v10;
    return result;
  }
  if (a2 > 3798)
  {
    if (a2 != 3799)
    {
      if (a2 != 36999) {
        return result;
      }
      if (*((_DWORD *)this + 165) > a4)
      {
        uint64_t v15 = *((unsigned int *)this + 136);
        uint64_t v16 = (const void *)(*((void *)this + 116) + 4 * (int)(v15 * a4));
        size_t v17 = 4 * v15;
LABEL_47:
        memcpy(__dst, v16, v17);
        return 0;
      }
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      int v24 = getAUNeuralNetLog(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
        return 4294956419;
      }
LABEL_60:
      int v27 = *((_DWORD *)this + 165);
      *(_DWORD *)uint64_t v29 = 134218496;
      *(void *)&v29[4] = this;
      __int16 v30 = 1024;
      unsigned int v31 = a4;
      __int16 v32 = 1024;
      int v33 = v27;
      uint64_t v26 = "[%p] Tried to select a VP mask indexed at (%u), but only (%u) masks are available";
      goto LABEL_77;
    }
    if (*((_DWORD *)this + 165) > a4)
    {
      unsigned int v19 = *((_DWORD *)this + 136) + 1;
      int v20 = v19 * a4;
      uint64_t v21 = *((void *)this + 119);
      goto LABEL_46;
    }
    if (getAUNeuralNetLog(void)::onceToken != -1) {
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
    }
    int v24 = getAUNeuralNetLog(void)::gLog;
    if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      return 4294956419;
    }
LABEL_76:
    int v28 = *((_DWORD *)this + 165);
    *(_DWORD *)uint64_t v29 = 134218496;
    *(void *)&v29[4] = this;
    __int16 v30 = 1024;
    unsigned int v31 = a4;
    __int16 v32 = 1024;
    int v33 = v28;
    uint64_t v26 = "[%p] Tried to select a postmask indexed at (%u), but only (%u) masks are available";
    goto LABEL_77;
  }
  if (a2 == 3699)
  {
    if (*((_DWORD *)this + 165) > a4)
    {
      unsigned int v19 = *((_DWORD *)this + 136) + 1;
      int v20 = v19 * a4;
      uint64_t v21 = *((void *)this + 113);
LABEL_46:
      uint64_t v16 = (const void *)(v21 + 4 * v20);
      size_t v17 = 4 * v19;
      goto LABEL_47;
    }
    if (getAUNeuralNetLog(void)::onceToken != -1) {
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
    }
    int v24 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
    {
LABEL_56:
      int v25 = *((_DWORD *)this + 165);
      *(_DWORD *)uint64_t v29 = 134218496;
      *(void *)&v29[4] = this;
      __int16 v30 = 1024;
      unsigned int v31 = a4;
      __int16 v32 = 1024;
      int v33 = v25;
      uint64_t v26 = "[%p] Tried to select a mask indexed at (%u), but only (%u) masks are available";
LABEL_77:
      _os_log_error_impl(&dword_1BB0CE000, v24, OS_LOG_TYPE_ERROR, v26, v29, 0x18u);
    }
    return 4294956419;
  }
  if (a2 == 3700)
  {
    uint64_t result = 0;
    int v9 = *((unsigned __int8 *)this + 376);
LABEL_52:
    *(_DWORD *)long long __dst = v9;
  }
  return result;
}

void sub_1BB3A39B8(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1BB3A39C8(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x1BB3A39C4);
  }
  JUMPOUT(0x1BB3A39BCLL);
}

uint64_t AUNeuralNet::GetPropertyInfo(AUNeuralNet *this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  if (a3) {
    return 4294956417;
  }
  uint64_t result = 4294956417;
  if (a2 <= 3999)
  {
    if (a2 > 3693)
    {
      switch(a2)
      {
        case 3694:
        case 3698:
        case 3700:
          goto LABEL_27;
        case 3695:
          goto LABEL_28;
        case 3696:
          *a6 = *((unsigned char *)this + 17) ^ 1;
          int v9 = *((_DWORD *)this + 84);
          goto LABEL_32;
        case 3697:
          goto LABEL_22;
        case 3699:
          goto LABEL_31;
        default:
          if (a2 != 3799) {
            return result;
          }
LABEL_31:
          *a6 = 0;
          int v9 = *((_DWORD *)this + 136);
LABEL_32:
          int v13 = 4 * v9 + 4;
          break;
      }
      goto LABEL_38;
    }
    if (a2 != 21)
    {
      if (a2 != 3670) {
        return result;
      }
      *a6 = 0;
      int v11 = *(_DWORD *)(*((void *)this + 100) + 28);
      goto LABEL_37;
    }
LABEL_27:
    char v12 = 1;
LABEL_29:
    *a6 = v12;
    int v13 = 4;
LABEL_38:
    uint64_t result = 0;
    *a5 = v13;
    return result;
  }
  if (a2 > 103695)
  {
    if (a2 <= 103799)
    {
      if (a2 != 103696)
      {
        if (a2 == 103699)
        {
LABEL_21:
          *a6 = 0;
LABEL_35:
          int v13 = 8;
          goto LABEL_38;
        }
        int v8 = 103799;
LABEL_20:
        if (a2 != v8) {
          return result;
        }
        goto LABEL_21;
      }
      char v10 = *((unsigned char *)this + 17) ^ 1;
LABEL_34:
      *a6 = v10;
      goto LABEL_35;
    }
    if (a2 != 103800)
    {
      if (a2 != 103801)
      {
        int v8 = 1036999;
        goto LABEL_20;
      }
      goto LABEL_27;
    }
LABEL_22:
    char v10 = 1;
    goto LABEL_34;
  }
  if (a2 <= 4001)
  {
    if (a2 == 4000)
    {
LABEL_28:
      char v12 = *((unsigned char *)this + 17) ^ 1;
      goto LABEL_29;
    }
    goto LABEL_27;
  }
  switch(a2)
  {
    case 4002:
      goto LABEL_27;
    case 36999:
      *a6 = 0;
      int v11 = *((_DWORD *)this + 136);
LABEL_37:
      int v13 = 4 * v11;
      goto LABEL_38;
    case 40000:
      goto LABEL_22;
  }
  return result;
}

uint64_t AUNeuralNet::Reset(AUNeuralNet *this)
{
  uint64_t v2 = (BlockProcessor *)*((void *)this + 157);
  if (v2) {
    BlockProcessor::Reset(v2);
  }
  uint64_t v3 = *((void *)this + 158);
  if (v3)
  {
    *(_DWORD *)(v3 + 16) = 0;
    *(_DWORD *)(v3 + 40) = 0;
    if (*(void *)(v3 + 24))
    {
      unint64_t v4 = *(unsigned int *)(v3 + 32);
      if (v4)
      {
        unint64_t v5 = 0;
        size_t v6 = (4 * *(_DWORD *)(v3 + 36));
        do
        {
          uint64_t v7 = *(_DWORD **)(*(void *)(v3 + 24) + 8 * v5);
          if (*v7)
          {
            unint64_t v8 = 0;
            uint64_t v9 = 4;
            do
            {
              bzero(*(void **)&v7[v9], v6);
              ++v8;
              v9 += 4;
            }
            while (v8 < *v7);
            unint64_t v4 = *(unsigned int *)(v3 + 32);
          }
          ++v5;
        }
        while (v5 < v4);
      }
    }
  }
  for (uint64_t i = 0; i != 624; i += 104)
  {
    uint64_t v11 = *((void *)this + 100) + i;
    if (*(unsigned char *)(v11 + 96)) {
      (*(void (**)(void))(**(void **)(v11 + 64) + 48))(*(void *)(v11 + 64));
    }
  }
  vDSP_vclr(*((float **)this + 104), 1, (uint64_t)(*((void *)this + 105) - *((void *)this + 104)) >> 2);
  if (*((unsigned char *)this + 592)) {
    vDSP_vclr(*((float **)this + 107), 1, (uint64_t)(*((void *)this + 108) - *((void *)this + 107)) >> 2);
  }
  vDSP_vclr(*((float **)this + 110), 1, (uint64_t)(*((void *)this + 111) - *((void *)this + 110)) >> 2);
  vDSP_vclr(*((float **)this + 113), 1, (uint64_t)(*((void *)this + 114) - *((void *)this + 113)) >> 2);
  vDSP_vclr(*((float **)this + 116), 1, (uint64_t)(*((void *)this + 117) - *((void *)this + 116)) >> 2);
  vDSP_vclr(*((float **)this + 119), 1, (uint64_t)(*((void *)this + 120) - *((void *)this + 119)) >> 2);
  vDSP_vclr(*((float **)this + 123), 1, (uint64_t)(*((void *)this + 124) - *((void *)this + 123)) >> 2);
  vDSP_vclr(*((float **)this + 126), 1, (uint64_t)(*((void *)this + 127) - *((void *)this + 126)) >> 2);
  vDSP_vclr(*((float **)this + 129), 1, (uint64_t)(*((void *)this + 130) - *((void *)this + 129)) >> 2);
  uint64_t v12 = *((void *)this + 132);
  if (*((void *)this + 133) != v12)
  {
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    do
    {
      vDSP_vclr(*(float **)(v12 + v13), 1, (uint64_t)(*(void *)(v12 + v13 + 8) - *(void *)(v12 + v13)) >> 2);
      ++v14;
      uint64_t v12 = *((void *)this + 132);
      v13 += 24;
    }
    while (0xAAAAAAAAAAAAAAABLL * ((*((void *)this + 133) - v12) >> 3) > v14);
  }
  vDSP_vclr(*((float **)this + 135), 1, (uint64_t)(*((void *)this + 136) - *((void *)this + 135)) >> 2);
  vDSP_vclr(*((float **)this + 138), 1, (uint64_t)(*((void *)this + 139) - *((void *)this + 138)) >> 2);
  vDSP_vclr(*((float **)this + 141), 1, (uint64_t)(*((void *)this + 142) - *((void *)this + 141)) >> 2);
  int v15 = *((_DWORD *)this + 158);
  *((_DWORD *)this + 159) = v15;
  *((_DWORD *)this + 160) = v15;
  *((unsigned char *)this + 652) = 1;
  return 0;
}

char *AUNeuralNet::Cleanup(AUNeuralNet *this)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (getAUNeuralNetLog(void)::onceToken != -1) {
    dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
  }
  uint64_t v2 = getAUNeuralNetLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 134217984;
    uint64_t v7 = this;
    _os_log_impl(&dword_1BB0CE000, v2, OS_LOG_TYPE_DEFAULT, "[%p] cleanup", (uint8_t *)&v6, 0xCu);
  }
  for (uint64_t i = 0; i != 624; i += 104)
  {
    uint64_t v4 = *((void *)this + 100) + i;
    if (*(unsigned char *)(v4 + 96)) {
      (*(void (**)(void))(**(void **)(v4 + 64) + 48))(*(void *)(v4 + 64));
    }
  }
  return AUNeuralNet::InitMaskRelatedVariables(this);
}

char *AUNeuralNet::InitMaskRelatedVariables(AUNeuralNet *this)
{
  unint64_t v2 = (*((_DWORD *)this + 165) + *((_DWORD *)this + 165) * *((_DWORD *)this + 136));
  LODWORD(__p[0]) = 0;
  std::vector<float>::assign((char **)this + 113, v2, __p);
  unint64_t v3 = (*((_DWORD *)this + 165) * *((_DWORD *)this + 136));
  LODWORD(__p[0]) = 0;
  std::vector<float>::assign((char **)this + 116, v3, __p);
  unint64_t v4 = (*((_DWORD *)this + 165) + *((_DWORD *)this + 165) * *((_DWORD *)this + 136));
  LODWORD(__p[0]) = 0;
  std::vector<float>::assign((char **)this + 119, v4, __p);
  uint64_t v5 = *((void *)this + 100);
  int v6 = *(unsigned __int8 *)(v5 + 96);
  if (*(unsigned char *)(v5 + 96)) {
    int v6 = *(_DWORD *)(v5 + 16);
  }
  if (*((unsigned char *)this + 1244))
  {
    if (*((_DWORD *)this + 312) == 2) {
      uint64_t v7 = (_DWORD *)(*((void *)this + 158) + 92);
    }
    else {
      uint64_t v7 = (_DWORD *)(v5 + 20);
    }
    int v9 = *v7 + v6;
    *((_DWORD *)this + 244) = v9;
    *((_DWORD *)this + 245) = AUNeuralNet::GetCurrentLatencyInSamples(this);
    unsigned int v10 = *(_DWORD *)(v5 + 20);
    if (*((_DWORD *)this + 136) > v10) {
      unsigned int v10 = *((_DWORD *)this + 136);
    }
    unsigned int v8 = v10 + v9;
  }
  else
  {
    *((_DWORD *)this + 244) = v6;
    *((_DWORD *)this + 245) = AUNeuralNet::GetCurrentLatencyInSamples(this);
    unsigned int v8 = *(_DWORD *)(v5 + 16) + *(_DWORD *)(v5 + 20);
  }
  if (!*((unsigned char *)this + 664))
  {
    unint64_t v11 = *((unsigned int *)this + 164);
    int v22 = 0;
    std::vector<float>::vector(__p, v8, &v22);
    std::vector<std::vector<float>>::assign((uint64_t *)this + 132, v11, (uint64_t)__p);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    unint64_t v12 = (*((_DWORD *)this + 244) + *((_DWORD *)this + 136));
    LODWORD(__p[0]) = 0;
    std::vector<float>::assign((char **)this + 123, v12, __p);
    unint64_t v13 = *((unsigned int *)this + 136);
    LODWORD(__p[0]) = 0;
    std::vector<float>::assign((char **)this + 126, v13, __p);
    unint64_t v14 = *((unsigned int *)this + 136);
    LODWORD(__p[0]) = 0;
    std::vector<float>::assign((char **)this + 129, v14, __p);
    unint64_t v15 = *((unsigned int *)this + 136);
    LODWORD(__p[0]) = 0;
    std::vector<float>::assign((char **)this + 135, v15, __p);
    uint64_t v16 = (VPTimeFreqConverter *)*((void *)this + 144);
    if (v16)
    {
      VPTimeFreqConverter::~VPTimeFreqConverter(v16);
      MEMORY[0x1C185D370]();
    }
    VPTimeFreqConverter_Create();
  }
  unint64_t v17 = (2 * *((_DWORD *)this + 136));
  LODWORD(__p[0]) = 0;
  std::vector<float>::assign((char **)this + 138, v17, __p);
  unint64_t v18 = (2 * *((_DWORD *)this + 136));
  LODWORD(__p[0]) = 0;
  std::vector<float>::assign((char **)this + 141, v18, __p);
  if (*((unsigned char *)this + 592))
  {
    unint64_t v19 = *(unsigned int *)(*((void *)this + 100) + 28);
    LODWORD(__p[0]) = 0;
    std::vector<float>::assign((char **)this + 107, v19, __p);
  }
  unint64_t v20 = *((unsigned int *)this + 164);
  LODWORD(__p[0]) = 0;
  return std::vector<float>::assign((char **)this + 165, v20, __p);
}

void sub_1BB3A42E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t AUNeuralNet::Initialize(AUNeuralNet *this)
{
  uint64_t v265 = *MEMORY[0x1E4F143B8];
  *((_DWORD *)this + 136) = *((_DWORD *)this + 84);
  if (getAUNeuralNetLog(void)::onceToken != -1) {
    dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
  }
  unint64_t v2 = getAUNeuralNetLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEBUG))
  {
    AudioFormatFlags v31 = *((_DWORD *)this + 136);
    LODWORD(v264.mSampleRate) = 134218240;
    *(void *)((char *)&v264.mSampleRate + 4) = this;
    LOWORD(v264.mFormatFlags) = 1024;
    *(AudioFormatFlags *)((char *)&v264.mFormatFlags + 2) = v31;
    _os_log_debug_impl(&dword_1BB0CE000, v2, OS_LOG_TYPE_DEBUG, "[%p] AU block size %u", (uint8_t *)&v264, 0x12u);
    if (getAUNeuralNetLog(void)::onceToken != -1) {
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
    }
  }
  unint64_t v3 = getAUNeuralNetLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(v264.mSampleRate) = 134217984;
    *(void *)((char *)&v264.mSampleRate + 4) = this;
    _os_log_debug_impl(&dword_1BB0CE000, v3, OS_LOG_TYPE_DEBUG, "[%p] check input format before initialization", (uint8_t *)&v264, 0xCu);
  }
  uint64_t Element = ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 80), 0);
  long long v5 = *(_OWORD *)(Element + 96);
  *(_OWORD *)&v251.Float64 mSampleRate = *(_OWORD *)(Element + 80);
  *(_OWORD *)&v251.UInt32 mBytesPerPacket = v5;
  *(void *)&v251.UInt32 mBitsPerChannel = *(void *)(Element + 112);
  AudioFormatFlags v6 = HIDWORD(v5);
  *((_DWORD *)this + 164) = HIDWORD(v5);
  if (getAUNeuralNetLog(void)::onceToken != -1) {
    dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
  }
  uint64_t v7 = getAUNeuralNetLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEBUG))
  {
    AudioStreamBasicDescription v264 = v251;
    CA::StreamDescription::AsString((CA::StreamDescription *)&v264, (uint64_t)&buf, *(int16x8_t *)&v251.mBytesPerPacket);
    __int16 v32 = (buf.mFramesPerPacket & 0x80000000) == 0 ? &buf : *(AudioStreamBasicDescription **)&buf.mSampleRate;
    *(_DWORD *)vDSP_Length v260 = 134218242;
    *(void *)&v260[4] = this;
    __int16 v261 = 2080;
    std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v262 = (std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep)v32;
    _os_log_debug_impl(&dword_1BB0CE000, v7, OS_LOG_TYPE_DEBUG, "[%p] input format: %s", v260, 0x16u);
    if (SHIBYTE(buf.mFramesPerPacket) < 0) {
      operator delete(*(void **)&buf.mSampleRate);
    }
  }
  if (v251.mFormatID != 1819304813)
  {
    if (v251.mFormatID == 1718773105
      && (v251.mFormatFlags & 1) != 0
      && v251.mBitsPerChannel == 64
      && (v251.mFormatFlags & 0x20) != 0)
    {
      goto LABEL_14;
    }
LABEL_21:
    if (getAUNeuralNetLog(void)::onceToken != -1) {
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
    }
    uint64_t v13 = getAUNeuralNetLog(void)::gLog;
    if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      return 4294956421;
    }
    LODWORD(v264.mSampleRate) = 134217984;
    *(void *)((char *)&v264.mSampleRate + 4) = this;
    int v9 = "[%p] input format is not valid";
    goto LABEL_89;
  }
  if ((v251.mFormatFlags & 1) == 0) {
    goto LABEL_21;
  }
LABEL_14:
  if (*((_DWORD *)this + 164) >= 0x11u)
  {
    if (getAUNeuralNetLog(void)::onceToken != -1) {
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
    }
    uint64_t v8 = getAUNeuralNetLog(void)::gLog;
    if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      return 4294956421;
    }
    LODWORD(v264.mSampleRate) = 134218496;
    *(void *)((char *)&v264.mSampleRate + 4) = this;
    LOWORD(v264.mFormatFlags) = 1024;
    *(AudioFormatFlags *)((char *)&v264.mFormatFlags + 2) = v6;
    HIWORD(v264.mBytesPerPacket) = 1024;
    v264.mFramesPerPacket = 16;
    int v9 = "[%p] input format has %d channels, which is more than the max number of (%d)";
LABEL_19:
    unsigned int v10 = (uint8_t *)&v264;
    unint64_t v11 = v8;
    uint32_t v12 = 24;
    goto LABEL_91;
  }
  if (getAUNeuralNetLog(void)::onceToken != -1) {
    dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
  }
  uint64_t v16 = getAUNeuralNetLog(void)::gLog;
  uint64_t v246 = (_DWORD *)((char *)this + 656);
  if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(v264.mSampleRate) = 134217984;
    *(void *)((char *)&v264.mSampleRate + 4) = this;
    _os_log_debug_impl(&dword_1BB0CE000, v16, OS_LOG_TYPE_DEBUG, "[%p] check output format before initialization", (uint8_t *)&v264, 0xCu);
  }
  unsigned int v17 = 0;
  unint64_t v248 = (AudioFormatFlags *)((char *)this + 660);
  while (1)
  {
    uint64_t v18 = *((void *)this + 21);
    if (v18) {
      LODWORD(v19) = (*(uint64_t (**)(uint64_t))(*(void *)v18 + 24))(v18);
    }
    else {
      uint64_t v19 = (*((void *)this + 19) - *((void *)this + 18)) >> 3;
    }
    if (v17 >= v19) {
      break;
    }
    if (v17 != 1)
    {
      if (v17) {
        goto LABEL_63;
      }
      uint64_t v20 = ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 128), 0);
      double v21 = *(double *)(v20 + 80);
      AudioFormatID v23 = *(_DWORD *)(v20 + 88);
      int v22 = *(_DWORD *)(v20 + 92);
      uint64_t v249 = *(uint64_t **)(v20 + 96);
      AudioFormatFlags v24 = *(_DWORD *)(v20 + 108);
      UInt32 v250 = *(_DWORD *)(v20 + 104);
      uint64_t v247 = *(void *)(v20 + 112);
      *unint64_t v248 = v24;
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      int v25 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEBUG))
      {
        AudioStreamBasicDescription v264 = v251;
        CA::StreamDescription::AsString((CA::StreamDescription *)&v264, (uint64_t)v260, *(int16x8_t *)&v251.mBytesPerPacket);
        __int16 v30 = v260;
        if (v263 < 0) {
          __int16 v30 = *(unsigned char **)v260;
        }
        LODWORD(buf.mSampleRate) = 134218498;
        *(void *)((char *)&buf.mSampleRate + 4) = this;
        LOWORD(buf.mFormatFlags) = 1024;
        *(AudioFormatFlags *)((char *)&buf.mFormatFlags + 2) = 0;
        HIWORD(buf.mBytesPerPacket) = 2080;
        *(void *)&buf.mFramesPerPacket = v30;
        _os_log_debug_impl(&dword_1BB0CE000, v25, OS_LOG_TYPE_DEBUG, "[%p] output format for bus %u: %s", (uint8_t *)&buf, 0x1Cu);
        if (v263 < 0) {
          operator delete(*(void **)v260);
        }
      }
      if (v23 == 1819304813)
      {
        if ((v22 & 1) == 0) {
          goto LABEL_335;
        }
      }
      else if (v23 != 1718773105 || (v22 & 1) == 0 || v247 != 64 || (v22 & 0x20) == 0)
      {
LABEL_335:
        if (getAUNeuralNetLog(void)::onceToken != -1) {
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
        }
        uint64_t v13 = getAUNeuralNetLog(void)::gLog;
        if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
          return 4294956421;
        }
        LODWORD(v264.mSampleRate) = 134217984;
        *(void *)((char *)&v264.mSampleRate + 4) = this;
        int v9 = "[%p] output format is not valid";
LABEL_89:
        unsigned int v10 = (uint8_t *)&v264;
        goto LABEL_90;
      }
      if (*v248 >= 0x25)
      {
        if (getAUNeuralNetLog(void)::onceToken != -1) {
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
        }
        uint64_t v8 = getAUNeuralNetLog(void)::gLog;
        if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
          return 4294956421;
        }
        LODWORD(v264.mSampleRate) = 134218496;
        *(void *)((char *)&v264.mSampleRate + 4) = this;
        LOWORD(v264.mFormatFlags) = 1024;
        *(AudioFormatFlags *)((char *)&v264.mFormatFlags + 2) = v24;
        HIWORD(v264.mBytesPerPacket) = 1024;
        v264.mFramesPerPacket = 36;
        int v9 = "[%p] output format has %d channels, which is more than the max number of (%d)";
        goto LABEL_19;
      }
      AudioStreamBasicDescription v264 = v251;
      if ((v251.mFormatFlags & 0x20) != 0)
      {
        UInt32 mChannelsPerFrame = 1;
      }
      else
      {
        UInt32 mChannelsPerFrame = v264.mChannelsPerFrame;
        if (!v264.mChannelsPerFrame)
        {
          UInt32 v27 = (v264.mBitsPerChannel + 7) >> 3;
LABEL_55:
          unsigned int v28 = 1;
          v264.UInt32 mBytesPerFrame = v27;
          v264.UInt32 mChannelsPerFrame = 1;
          v264.UInt32 mBytesPerPacket = v27;
          v264.mFramesPerPacket = 1;
          v264.AudioFormatFlags mFormatFlags = v251.mFormatFlags | 0x20;
          buf.Float64 mSampleRate = v21;
          buf.AudioFormatID mFormatID = v23;
          *(void *)&buf.UInt32 mBytesPerPacket = v249;
          buf.UInt32 mBytesPerFrame = v250;
          *(void *)&buf.UInt32 mBitsPerChannel = v247;
          if ((v22 & 0x20) != 0 || (unsigned int v28 = v24) != 0) {
            UInt32 v29 = buf.mBytesPerFrame / v28;
          }
          else {
            UInt32 v29 = (v247 + 7) >> 3;
          }
          buf.UInt32 mChannelsPerFrame = 1;
          buf.mFramesPerPacket = 1;
          buf.UInt32 mBytesPerFrame = v29;
          buf.UInt32 mBytesPerPacket = v29;
          buf.AudioFormatFlags mFormatFlags = v22 | 0x20;
          if (v264.mSampleRate != v21
            || v264.mFormatID != v23
            || v27 != v29
            || v264.mBitsPerChannel != v247
            || !CA::Implementation::EquivalentFormatFlags((CA::Implementation *)&v264, &buf, 0, 0))
          {
            if (getAUNeuralNetLog(void)::onceToken != -1) {
              dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
            }
            uint64_t v13 = getAUNeuralNetLog(void)::gLog;
            if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
              return 4294956421;
            }
            *(_DWORD *)vDSP_Length v260 = 134217984;
            *(void *)&v260[4] = this;
            int v9 = "[%p] I/O formats are not compatible.";
            unsigned int v10 = v260;
LABEL_90:
            unint64_t v11 = v13;
            uint32_t v12 = 12;
LABEL_91:
            _os_log_error_impl(&dword_1BB0CE000, v11, OS_LOG_TYPE_ERROR, v9, v10, v12);
            return 4294956421;
          }
          goto LABEL_63;
        }
      }
      UInt32 v27 = v264.mBytesPerFrame / mChannelsPerFrame;
      goto LABEL_55;
    }
    if (*(_DWORD *)(ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 128), 1u) + 108) >= 0x25u)
    {
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      uint64_t v8 = getAUNeuralNetLog(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
        return 4294956421;
      }
      AudioFormatFlags v150 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 128), 1u) + 108);
      LODWORD(v264.mSampleRate) = 134218496;
      *(void *)((char *)&v264.mSampleRate + 4) = this;
      LOWORD(v264.mFormatFlags) = 1024;
      *(AudioFormatFlags *)((char *)&v264.mFormatFlags + 2) = v150;
      HIWORD(v264.mBytesPerPacket) = 1024;
      v264.mFramesPerPacket = 36;
      int v9 = "[%p] output GainVector format has %d channels, which is more than the max number of (%d)";
      goto LABEL_19;
    }
LABEL_63:
    ++v17;
  }
  if (getAUNeuralNetLog(void)::onceToken != -1) {
    dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
  }
  int v33 = getAUNeuralNetLog(void)::gLog;
  uint64_t v34 = &unk_1BB871000;
  if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
  {
    LODWORD(v264.mSampleRate) = 134217984;
    *(void *)((char *)&v264.mSampleRate + 4) = this;
    _os_log_impl(&dword_1BB0CE000, v33, OS_LOG_TYPE_INFO, "[%p] will try to initialize", (uint8_t *)&v264, 0xCu);
  }
  ausdk::AUBufferList::Allocate((AUNeuralNet *)((char *)this + 1376), &v251, *((_DWORD *)this + 136));
  ausdk::AUBufferList::PrepareBuffer((AUNeuralNet *)((char *)this + 1376), &v251, *((_DWORD *)this + 136));
  uint64_t v35 = (_DWORD *)ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 80), 0);
  if (v35[22] == 1718773105)
  {
    LOBYTE(v37) = 0;
    unsigned int v38 = v35[23];
    if ((v38 & 1) != 0 && v35[28] == 64) {
      int v37 = (v38 >> 5) & 1;
    }
  }
  else
  {
    LOBYTE(v37) = 0;
  }
  *((unsigned char *)this + 664) = v37;
  if (!*((_DWORD *)this + 206))
  {
LABEL_339:
    *((_DWORD *)this + 141) = 0;
    if (getAUNeuralNetLog(void)::onceToken != -1) {
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
    }
    long long v140 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      LODWORD(v264.mSampleRate) = 134218240;
      *(void *)((char *)&v264.mSampleRate + 4) = this;
      LOWORD(v264.mFormatFlags) = 1024;
      *(AudioFormatFlags *)((char *)&v264.mFormatFlags + 2) = 0;
      _os_log_impl(&dword_1BB0CE000, v140, OS_LOG_TYPE_INFO, "[%p] Defaulting to NeuralNet model (%u) for processing.", (uint8_t *)&v264, 0x12u);
    }
    if (!*(unsigned char *)(*((void *)this + 100) + 96))
    {
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      uint64_t v151 = getAUNeuralNetLog(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO)) {
        goto LABEL_457;
      }
      LODWORD(v264.mSampleRate) = v34[192];
      *(void *)((char *)&v264.mSampleRate + 4) = this;
      _os_log_impl(&dword_1BB0CE000, v151, OS_LOG_TYPE_INFO, "[%p] No NeuralNets were loaded from plist.", (uint8_t *)&v264, 0xCu);
      goto LABEL_455;
    }
    float v141 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUNeuralNet *)((char *)this + 32), 0);
    ausdk::AUElement::SetParameter(v141, 0, 1.0, 0);
    if (getAUNeuralNetLog(void)::onceToken != -1) {
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
    }
    float v142 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      LODWORD(v264.mSampleRate) = v34[192];
      *(void *)((char *)&v264.mSampleRate + 4) = this;
      _os_log_impl(&dword_1BB0CE000, v142, OS_LOG_TYPE_INFO, "[%p] Successfully loaded NeuralNet plist.", (uint8_t *)&v264, 0xCu);
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
    }
    CFDictionaryRef v143 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v228 = (*(uint64_t (**)(void))(**(void **)(*((void *)this + 100) + 64) + 24))(*(void *)(*((void *)this + 100) + 64));
      LODWORD(v264.mSampleRate) = 134218240;
      *(void *)((char *)&v264.mSampleRate + 4) = this;
      LOWORD(v264.mFormatFlags) = 2048;
      *(void *)((char *)&v264.mFormatFlags + 2) = v228;
      _os_log_debug_impl(&dword_1BB0CE000, v143, OS_LOG_TYPE_DEBUG, "[%p] mNeuralNet input size: %lu", (uint8_t *)&v264, 0x16u);
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
    }
    BOOL v144 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v229 = (*(uint64_t (**)(void))(**(void **)(*((void *)this + 100) + 64) + 32))(*(void *)(*((void *)this + 100) + 64));
      LODWORD(v264.mSampleRate) = 134218240;
      *(void *)((char *)&v264.mSampleRate + 4) = this;
      LOWORD(v264.mFormatFlags) = 2048;
      *(void *)((char *)&v264.mFormatFlags + 2) = v229;
      _os_log_debug_impl(&dword_1BB0CE000, v144, OS_LOG_TYPE_DEBUG, "[%p] mNeuralNet output size: %lu", (uint8_t *)&v264, 0x16u);
    }
    int v145 = *((_DWORD *)this + 136);
    uint64_t v146 = *((void *)this + 100);
    AudioFormatID mFormatID = v251.mFormatID;
    if (v145 == *(_DWORD *)(v146 + 20))
    {
      if (v251.mFormatID != 1718773105)
      {
LABEL_377:
        *((unsigned char *)this + 1244) = 0;
        if (*((void *)this + 157)) {
          std::unique_ptr<BlockProcessor>::reset[abi:ne180100]((uint64_t *)this + 157, 0);
        }
        uint64_t v152 = *((void *)this + 158);
        if (v152)
        {
          *((void *)this + 158) = 0;
          std::default_delete<BlockProcessorLowDelay>::operator()[abi:ne180100](v152);
        }
LABEL_447:
        float v189 = *((float *)this + 155);
        float v190 = 0.0;
        if (v189 != 0.0)
        {
          float v191 = **((double **)this + 100);
          float v190 = expf((float)((float)-(float)*((unsigned int *)this + 136) / v191) / v189);
        }
        *((float *)this + 156) = v190;
        if (mFormatID == 1718773105)
        {
          uint64_t v192 = *((void *)this + 100);
          if ((~v251.mFormatFlags & 0x21) == 0 && v251.mBitsPerChannel == 64)
          {
            unint64_t v193 = (*(int (**)(void))(**(void **)(v192 + 64) + 24))(*(void *)(v192 + 64));
            LODWORD(v264.mSampleRate) = 0;
            std::vector<float>::assign((char **)this + 104, v193, &v264);
            LODWORD(v264.mSampleRate) = 0;
            std::vector<float>::assign((char **)this + 110, v193, &v264);
            goto LABEL_455;
          }
        }
        else
        {
          uint64_t v192 = *((void *)this + 100);
        }
        unint64_t v194 = (*(_DWORD *)(v192 + 20) * *((_DWORD *)this + 164));
        LODWORD(v264.mSampleRate) = 0;
        std::vector<float>::assign((char **)this + 104, v194, &v264);
        unint64_t v195 = (*(_DWORD *)(*((void *)this + 100) + 20) * *((_DWORD *)this + 165));
        LODWORD(v264.mSampleRate) = 0;
        std::vector<float>::assign((char **)this + 110, v195, &v264);
LABEL_455:
        if (getAUNeuralNetLog(void)::onceToken != -1) {
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
        }
LABEL_457:
        float v196 = getAUNeuralNetLog(void)::gLog;
        if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
        {
          LODWORD(v264.mSampleRate) = v34[192];
          *(void *)((char *)&v264.mSampleRate + 4) = this;
          _os_log_impl(&dword_1BB0CE000, v196, OS_LOG_TYPE_INFO, "[%p] initialize mask related variables", (uint8_t *)&v264, 0xCu);
        }
        AUNeuralNet::InitMaskRelatedVariables(this);
        if (*((unsigned char *)this + 1232))
        {
          float v197 = (void **)((char *)this + 1208);
          if (!*((unsigned char *)this + 592)) {
            goto LABEL_467;
          }
          if (*((void *)this + 108) - *((void *)this + 107) != *((void *)this + 152) - *((void *)this + 151))
          {
            if (getAUNeuralNetLog(void)::onceToken != -1) {
              dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
            }
            uint64_t v225 = getAUNeuralNetLog(void)::gLog;
            if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
              return 4294956421;
            }
            uint64_t v226 = (uint64_t)(*((void *)this + 108) - *((void *)this + 107)) >> 2;
            uint64_t v227 = (uint64_t)(*((void *)this + 152) - *((void *)this + 151)) >> 2;
            LODWORD(v264.mSampleRate) = 134218496;
            *(void *)((char *)&v264.mSampleRate + 4) = this;
            LOWORD(v264.mFormatFlags) = 2048;
            *(void *)((char *)&v264.mFormatFlags + 2) = v226;
            HIWORD(v264.mFramesPerPacket) = 2048;
            *(void *)&v264.UInt32 mBytesPerFrame = v227;
            int v9 = "[%p] cached embedding has mismatch size: %lu != %lu";
            unsigned int v10 = (uint8_t *)&v264;
            unint64_t v11 = v225;
            uint32_t v12 = 32;
            goto LABEL_91;
          }
          if (getAUNeuralNetLog(void)::onceToken != -1) {
            dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
          }
          float v198 = getAUNeuralNetLog(void)::gLog;
          if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
          {
            LODWORD(v264.mSampleRate) = v34[192];
            *(void *)((char *)&v264.mSampleRate + 4) = this;
            _os_log_impl(&dword_1BB0CE000, v198, OS_LOG_TYPE_INFO, "[%p] loading cached embedding", (uint8_t *)&v264, 0xCu);
          }
          std::vector<float>::__move_assign((uint64_t)this + 856, (__n128 *)((char *)this + 1208));
          if (*((unsigned char *)this + 1232))
          {
LABEL_467:
            CFArrayRef v199 = *v197;
            if (*v197)
            {
              *((void *)this + 152) = v199;
              operator delete(v199);
            }
            *((unsigned char *)this + 1232) = 0;
          }
        }
        CFArrayRef v200 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUNeuralNet *)((char *)this + 32), 0);
        float v201 = 0.0;
        if (*(unsigned char *)(*((void *)this + 100) + 96)) {
          float v201 = 1.0;
        }
        ausdk::AUElement::SetParameter(v200, 0, v201, 0);
        *((_DWORD *)this + 245) = AUNeuralNet::GetCurrentLatencyInSamples(this);
        unsigned int v202 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUNeuralNet *)((char *)this + 32), 0);
        ausdk::AUElement::SetParameter(v202, 0xEu, (float)*((unsigned int *)this + 245), 0);
        if (getAUNeuralNetLog(void)::onceToken != -1) {
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
        }
        unint64_t v203 = getAUNeuralNetLog(void)::gLog;
        if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v204 = *((void *)this + 100);
          int v205 = (void *)(v204 + 32);
          if (*(char *)(v204 + 55) < 0) {
            int v205 = (void *)*v205;
          }
          int v206 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUNeuralNet *)((char *)this + 32), 0);
          float Parameter = ausdk::AUElement::GetParameter(v206, 0xEu);
          LODWORD(v264.mSampleRate) = 134218498;
          *(void *)((char *)&v264.mSampleRate + 4) = this;
          LOWORD(v264.mFormatFlags) = 2080;
          *(void *)((char *)&v264.mFormatFlags + 2) = v205;
          HIWORD(v264.mFramesPerPacket) = 2048;
          *(double *)&v264.UInt32 mBytesPerFrame = Parameter;
          _os_log_impl(&dword_1BB0CE000, v203, OS_LOG_TYPE_DEFAULT, "[%p] Latency for model: %s is %f", (uint8_t *)&v264, 0x20u);
        }
        unsigned __int8 v208 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUNeuralNet *)((char *)this + 32), 0);
        ausdk::AUElement::SetParameter(v208, 0x12u, (float)*(unsigned int *)(*((void *)this + 100) + 20), 0);
        if (getAUNeuralNetLog(void)::onceToken != -1) {
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
        }
        unsigned int v209 = getAUNeuralNetLog(void)::gLog;
        if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v210 = *((void *)this + 100);
          uint64_t v211 = (void *)(v210 + 32);
          if (*(char *)(v210 + 55) < 0) {
            uint64_t v211 = (void *)*v211;
          }
          unsigned int v212 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUNeuralNet *)((char *)this + 32), 0);
          float v213 = ausdk::AUElement::GetParameter(v212, 0x12u);
          LODWORD(v264.mSampleRate) = 134218498;
          *(void *)((char *)&v264.mSampleRate + 4) = this;
          LOWORD(v264.mFormatFlags) = 2080;
          *(void *)((char *)&v264.mFormatFlags + 2) = v211;
          HIWORD(v264.mFramesPerPacket) = 2048;
          *(double *)&v264.UInt32 mBytesPerFrame = v213;
          _os_log_impl(&dword_1BB0CE000, v209, OS_LOG_TYPE_DEFAULT, "[%p] Block size for model: %s is %f", (uint8_t *)&v264, 0x20u);
        }
        if (!*((_DWORD *)this + 167)
          && *((unsigned char *)this + 672)
          && *(unsigned char *)(*((void *)this + 100) + 104 * *((unsigned int *)this + 141) + 96))
        {
          if (getAUNeuralNetLog(void)::onceToken != -1) {
            dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
          }
          uint64_t v222 = getAUNeuralNetLog(void)::gLog;
          if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_491;
          }
          uint64_t v223 = *((void *)this + 100) + 104 * *((unsigned int *)this + 141);
          uint64_t v224 = (void *)(v223 + 32);
          if (*(char *)(v223 + 55) < 0) {
            uint64_t v224 = (void *)*v224;
          }
          LODWORD(v264.mSampleRate) = 134218242;
          *(void *)((char *)&v264.mSampleRate + 4) = this;
          LOWORD(v264.mFormatFlags) = 2080;
          *(void *)((char *)&v264.mFormatFlags + 2) = v224;
          int v218 = "[%p] Model with TaskID (%s) will be called";
          float v219 = v222;
          uint32_t v220 = 22;
        }
        else
        {
          if (getAUNeuralNetLog(void)::onceToken != -1) {
            dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
          }
          uint64_t v214 = getAUNeuralNetLog(void)::gLog;
          if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_491;
          }
          AudioFormatFlags v215 = *((_DWORD *)this + 167);
          UInt32 v216 = *((unsigned char *)this + 672) == 0;
          BOOL v217 = *(unsigned char *)(*((void *)this + 100) + 104 * *((unsigned int *)this + 141) + 96) == 0;
          LODWORD(v264.mSampleRate) = 134218752;
          *(void *)((char *)&v264.mSampleRate + 4) = this;
          LOWORD(v264.mFormatFlags) = 1024;
          *(AudioFormatFlags *)((char *)&v264.mFormatFlags + 2) = v215;
          HIWORD(v264.mBytesPerPacket) = 1024;
          v264.mFramesPerPacket = v216;
          LOWORD(v264.mBytesPerFrame) = 1024;
          *(UInt32 *)((char *)&v264.mBytesPerFrame + 2) = v217;
          int v218 = "[%p] Model bypassed: mBypass (%u) || !mSelectedValidModel (%d) || !selectedNeuralNet.model (%d)";
          float v219 = v214;
          uint32_t v220 = 30;
        }
        _os_log_impl(&dword_1BB0CE000, v219, OS_LOG_TYPE_DEFAULT, v218, (uint8_t *)&v264, v220);
        if (getAUNeuralNetLog(void)::onceToken != -1) {
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
        }
LABEL_491:
        uint64_t v221 = getAUNeuralNetLog(void)::gLog;
        uint64_t v14 = 0;
        if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(v264.mSampleRate) = v34[192];
          *(void *)((char *)&v264.mSampleRate + 4) = this;
          _os_log_impl(&dword_1BB0CE000, v221, OS_LOG_TYPE_DEFAULT, "[%p] did initialize", (uint8_t *)&v264, 0xCu);
          return 0;
        }
        return v14;
      }
      AudioFormatFlags mFormatFlags = v251.mFormatFlags;
      UInt32 mBitsPerChannel = v251.mBitsPerChannel;
    }
    else if (v251.mFormatID != 1718773105 {
           || (AudioFormatFlags mFormatFlags = v251.mFormatFlags, (~v251.mFormatFlags & 0x21) != 0)
    }
           || (UInt32 mBitsPerChannel = v251.mBitsPerChannel, v251.mBitsPerChannel != 64))
    {
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      uint64_t v153 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      {
        AudioFormatFlags v154 = *((_DWORD *)this + 136);
        UInt32 v155 = *(_DWORD *)(*((void *)this + 100) + 20);
        LODWORD(v264.mSampleRate) = 134218496;
        *(void *)((char *)&v264.mSampleRate + 4) = this;
        LOWORD(v264.mFormatFlags) = 1024;
        *(AudioFormatFlags *)((char *)&v264.mFormatFlags + 2) = v154;
        HIWORD(v264.mBytesPerPacket) = 1024;
        v264.mFramesPerPacket = v155;
        _os_log_impl(&dword_1BB0CE000, v153, OS_LOG_TYPE_INFO, "[%p] AU's block size (%d) not matching the NeuralNet's block size (%u). Will use a reblocker", (uint8_t *)&v264, 0x18u);
      }
      int v156 = *((_DWORD *)this + 312);
      if (*((_DWORD *)this + 136) > *(_DWORD *)(*((void *)this + 100) + 20) && v156 == 2)
      {
        *((_DWORD *)this + 312) = 1;
        if (getAUNeuralNetLog(void)::onceToken != -1) {
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
        }
        unsigned int v157 = getAUNeuralNetLog(void)::gLog;
        if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
        {
          AudioFormatFlags v158 = *((_DWORD *)this + 136);
          UInt32 v159 = *(_DWORD *)(*((void *)this + 100) + 20);
          LODWORD(v264.mSampleRate) = 134218496;
          *(void *)((char *)&v264.mSampleRate + 4) = this;
          LOWORD(v264.mFormatFlags) = 1024;
          *(AudioFormatFlags *)((char *)&v264.mFormatFlags + 2) = v158;
          HIWORD(v264.mBytesPerPacket) = 1024;
          v264.mFramesPerPacket = v159;
          _os_log_impl(&dword_1BB0CE000, v157, OS_LOG_TYPE_INFO, "[%p] Low Delay block processor not supported for process block size (%d) > NN block size (%d)", (uint8_t *)&v264, 0x18u);
        }
      }
      else
      {
        if (v156 == 2)
        {
          LODWORD(v253) = 1;
          *(void *)&buf.Float64 mSampleRate = (char *)this + 656;
          LODWORD(theDict) = 1;
          *(void *)vDSP_Length v260 = (char *)this + 660;
          long long v254 = this;
          std::make_unique[abi:ne180100]<BlockProcessorLowDelay,int,unsigned int *,int,unsigned int *,unsigned int &,unsigned int &,int (&)(void *,unsigned int,AudioBufferList const**,AudioBufferList**),AUNeuralNet *>();
        }
        if (v156 == 1)
        {
          LODWORD(v253) = 1;
          *(void *)&buf.Float64 mSampleRate = (char *)this + 656;
          LODWORD(theDict) = 1;
          *(void *)vDSP_Length v260 = (char *)this + 660;
          long long v254 = this;
          std::make_unique[abi:ne180100]<BlockProcessor,int,unsigned int *,int,unsigned int *,unsigned int &,int (&)(void *,unsigned int,AudioBufferList const**,AudioBufferList**),AUNeuralNet *>();
        }
      }
      float v188 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUNeuralNet *)((char *)this + 32), 0);
      ausdk::AUElement::SetParameter(v188, 0x11u, (float)*((unsigned int *)this + 312), 0);
      goto LABEL_447;
    }
    if ((~mFormatFlags & 0x21) == 0
      && mBitsPerChannel == 64
      && v145 + 1 > (int)((*(uint64_t (**)(void))(**(void **)(v146 + 64) + 24))(*(void *)(v146 + 64))
                        / (unint64_t)*(unsigned int *)(*((void *)this + 100) + 8)
                        + 1))
    {
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      uint64_t v13 = getAUNeuralNetLog(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
        return 4294956421;
      }
      LODWORD(v264.mSampleRate) = v34[192];
      *(void *)((char *)&v264.mSampleRate + 4) = this;
      int v9 = "[%p] Truncate of freq domain data not allowed (except nyquist)";
      goto LABEL_89;
    }
    goto LABEL_377;
  }
  uint64_t v39 = 0;
  unint64_t v40 = 0;
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v244 = (AUNeuralNet *)((char *)this + 32);
  uint64_t v241 = (const void *)*MEMORY[0x1E4F1CFC8];
  uint64_t v242 = (const void *)*MEMORY[0x1E4F1CFD0];
  *(void *)&long long v36 = 134218754;
  long long v240 = v36;
  while (1)
  {
    uint64_t v41 = *((void *)this + 100);
    unint64_t v245 = v40;
    if (*(unsigned char *)(v41 + v39 + 96) || !*(void *)(v41 + v39 + 56)) {
      goto LABEL_180;
    }
    if (getAUNeuralNetLog(void)::onceToken != -1) {
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
    }
    unint64_t v42 = v34;
    int v43 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      LODWORD(v264.mSampleRate) = 134218240;
      *(void *)((char *)&v264.mSampleRate + 4) = this;
      LOWORD(v264.mFormatFlags) = 1024;
      *(AudioFormatFlags *)((char *)&v264.mFormatFlags + 2) = v40;
      _os_log_impl(&dword_1BB0CE000, v43, OS_LOG_TYPE_INFO, "[%p] Creating NeuralNet model (%d)", (uint8_t *)&v264, 0x12u);
    }
    uint64_t v44 = *((void *)this + 100);
    DSPSplitComplex v45 = *(AUNeuralNet **)(v44 + v39 + 56);
    if (v45)
    {
      CFRetain(*(CFTypeRef *)(v44 + v39 + 56));
      long long v254 = v45;
      CFRetain(v45);
      Float64 v253 = *(double *)&v45;
      CFRetain(v45);
    }
    else
    {
      Float64 v253 = 0.0;
      long long v254 = 0;
    }
    CFDictionaryRef theDict = v45;
    if (AUNeuralNetLogScope(void)::once != -1) {
      dispatch_once(&AUNeuralNetLogScope(void)::once, &__block_literal_global_3112);
    }
    uint64_t v249 = (uint64_t *)AUNeuralNetLogScope(void)::scope;
    unsigned int v256 = 0;
    if (DictionaryBlobReader::ReadScalarFromDictionary<unsigned int>(&v249, theDict, @"NumberOfInputChannels", &v256))
    {
      exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      caulk::make_string((caulk *)"Failed to retrieve number of input channels. err = %d", (uint64_t)&buf, 4294900555);
      std::runtime_error::runtime_error(exception, (const std::string *)&buf);
    }
    *(_DWORD *)vDSP_Length v260 = 0;
    int v46 = DictionaryBlobReader::ReadScalarFromDictionary<unsigned int>(&v249, theDict, @"DynamicBatchSize", v260);
    AudioFormatFlags v255 = 0;
    int v47 = DictionaryBlobReader::ReadScalarFromDictionary<unsigned int>(&v249, theDict, @"BatchSize", &v255);
    MutableCopy = CFDictionaryCreateMutableCopy(allocator, 0, theDict);
    if (v46)
    {
      if (v47)
      {
        if (getAUNeuralNetLog(void)::onceToken != -1) {
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
        }
        std::string::size_type v49 = getAUNeuralNetLog(void)::gLog;
        if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
        {
          LODWORD(buf.mSampleRate) = 134217984;
          *(void *)((char *)&buf.mSampleRate + 4) = this;
          _os_log_impl(&dword_1BB0CE000, v49, OS_LOG_TYPE_INFO, "[%p] Failed to retrieve batch size, default to 1.", (uint8_t *)&buf, 0xCu);
        }
        int v50 = 1;
        AudioFormatFlags v255 = 1;
      }
      else
      {
        if (getAUNeuralNetLog(void)::onceToken != -1) {
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
        }
        float v54 = getAUNeuralNetLog(void)::gLog;
        BOOL v55 = os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO);
        int v50 = v255;
        if (v55)
        {
          LODWORD(buf.mSampleRate) = 134218240;
          *(void *)((char *)&buf.mSampleRate + 4) = this;
          LOWORD(buf.mFormatFlags) = 1024;
          *(AudioFormatFlags *)((char *)&buf.mFormatFlags + 2) = v255;
          _os_log_impl(&dword_1BB0CE000, v54, OS_LOG_TYPE_INFO, "[%p] Successfully retrieved batch size (%u).", (uint8_t *)&buf, 0x12u);
          int v50 = v255;
        }
      }
      int v257 = v50;
      CFNumberRef v53 = CFNumberCreate(0, kCFNumberIntType, &v257);
      *(void *)&buf.Float64 mSampleRate = v53;
      if (!v53)
      {
        int v137 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v137, "Could not construct");
      }
LABEL_129:
      CFDictionarySetValue(MutableCopy, @"BatchSize", v53);
      CFRelease(v53);
      goto LABEL_130;
    }
    if (v47)
    {
      if (*v246 == *v246 / v256 * v256) {
        int v51 = *v246 / v256;
      }
      else {
        int v51 = 1;
      }
      AudioFormatFlags v255 = v51;
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      uint64_t v52 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      {
        LODWORD(buf.mSampleRate) = 134218240;
        *(void *)((char *)&buf.mSampleRate + 4) = this;
        LOWORD(buf.mFormatFlags) = 1024;
        *(AudioFormatFlags *)((char *)&buf.mFormatFlags + 2) = v255;
        _os_log_impl(&dword_1BB0CE000, v52, OS_LOG_TYPE_INFO, "[%p] Failed to retrieve batch size, set to be (%u).", (uint8_t *)&buf, 0x12u);
      }
      AudioFormatFlags valuePtr = v255;
      CFNumberRef v53 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
      *(void *)&buf.Float64 mSampleRate = v53;
      if (!v53)
      {
        int v139 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v139, "Could not construct");
      }
      goto LABEL_129;
    }
    if (getAUNeuralNetLog(void)::onceToken != -1) {
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
    }
    uint64_t v131 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      LODWORD(buf.mSampleRate) = 134218240;
      *(void *)((char *)&buf.mSampleRate + 4) = this;
      LOWORD(buf.mFormatFlags) = 1024;
      *(AudioFormatFlags *)((char *)&buf.mFormatFlags + 2) = v255;
      _os_log_impl(&dword_1BB0CE000, v131, OS_LOG_TYPE_INFO, "[%p] Successfully retrieved batch size (%u).", (uint8_t *)&buf, 0x12u);
    }
LABEL_130:
    if (v45) {
      CFRelease(v45);
    }
    if (*((void *)this + 148))
    {
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      uint64_t v56 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      {
        CFStringRef v57 = (const __CFString *)*((void *)this + 148);
        if (!v57)
        {
          int v138 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(v138, "Could not construct");
        }
        applesauce::CF::convert_to<std::string,0>(v57, (uint64_t)&buf);
        Float64 mSampleRate = COERCE_DOUBLE(&buf);
        if ((buf.mFramesPerPacket & 0x80000000) != 0) {
          Float64 mSampleRate = buf.mSampleRate;
        }
        *(_DWORD *)vDSP_Length v260 = 134218242;
        *(void *)&v260[4] = this;
        __int16 v261 = 2080;
        std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v262 = *(void *)&mSampleRate;
        _os_log_impl(&dword_1BB0CE000, v56, OS_LOG_TYPE_INFO, "[%p] override 'ModelNetPathBaseOverride' to \"%s\"", v260, 0x16u);
        if (SHIBYTE(buf.mFramesPerPacket) < 0) {
          operator delete(*(void **)&buf.mSampleRate);
        }
      }
      CFDictionarySetValue(MutableCopy, @"ModelNetPathBase", *((const void **)this + 148));
    }
    if (*((void *)this + 150))
    {
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      uint64_t v59 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      {
        LODWORD(buf.mSampleRate) = 134217984;
        *(void *)((char *)&buf.mSampleRate + 4) = this;
        _os_log_impl(&dword_1BB0CE000, v59, OS_LOG_TYPE_INFO, "[%p] set 'mModelNetBNNSData'", (uint8_t *)&buf, 0xCu);
      }
      CFDictionarySetValue(MutableCopy, @"bnnsdict", *((const void **)this + 150));
    }
    if (*((unsigned char *)this + 1401))
    {
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      float v60 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      {
        if (!*((unsigned char *)this + 1401)) {
          std::__throw_bad_optional_access[abi:ne180100]();
        }
        uint32_t v61 = "true";
        if (!*((unsigned char *)this + 1400)) {
          uint32_t v61 = "false";
        }
        LODWORD(buf.mSampleRate) = 134218242;
        *(void *)((char *)&buf.mSampleRate + 4) = this;
        LOWORD(buf.mFormatFlags) = 2080;
        *(void *)((char *)&buf.mFormatFlags + 2) = v61;
        _os_log_impl(&dword_1BB0CE000, v60, OS_LOG_TYPE_INFO, "[%p] set 'mEnableImplementationCache' to %s", (uint8_t *)&buf, 0x16u);
      }
      if (!*((unsigned char *)this + 1401)) {
        std::__throw_bad_optional_access[abi:ne180100]();
      }
      if (*((unsigned char *)this + 1400)) {
        uint64_t v62 = v242;
      }
      else {
        uint64_t v62 = v241;
      }
      CFDictionarySetValue(MutableCopy, @"CacheImplementation", v62);
    }
    applesauce::CF::DictionaryRef::DictionaryRef((applesauce::CF::DictionaryRef *)&buf, MutableCopy);
    Float64 v63 = buf.mSampleRate;
    Float64 v253 = buf.mSampleRate;
    *(void *)&buf.Float64 mSampleRate = v45;
    if (v45) {
      CFRelease(v45);
    }
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(MutableCopy, @"BatchSize");
    CFNumberRef v65 = Value;
    if (Value) {
      CFRetain(Value);
    }
    *(void *)&buf.Float64 mSampleRate = v65;
    *(_DWORD *)(v44 + v39 + 24) = applesauce::CF::convert_to<unsigned int,0>(v65);
    if (v65) {
      CFRelease(v65);
    }
    v66.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
    if (AUNeuralNetLogScope(void)::once != -1) {
      dispatch_once(&AUNeuralNetLogScope(void)::once, &__block_literal_global_3112);
    }
    NeuralNet::NeuralNet((uint64_t)&buf, *(uint64_t **)&v63, (uint64_t *)AUNeuralNetLogScope(void)::scope);
    v67.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
    if (getAUNeuralNetLog(void)::onceToken != -1) {
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
    }
    uint64_t v68 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)vDSP_Length v260 = 134218240;
      *(void *)&v260[4] = this;
      __int16 v261 = 2048;
      std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v262 = (v67.__d_.__rep_ - v66.__d_.__rep_) / 1000000;
      _os_log_impl(&dword_1BB0CE000, v68, OS_LOG_TYPE_INFO, "[%p] created NeuralNet instance in %lld milliseconds", v260, 0x16u);
    }
    *(_OWORD *)&v264.AudioFormatID mFormatID = *(_OWORD *)&buf.mFormatID;
    v264.Float64 mSampleRate = buf.mSampleRate;
    *(void *)&v264.UInt32 mBytesPerFrame = *(void *)&buf.mBytesPerFrame;
    buf.Float64 mSampleRate = 0.0;
    *(void *)&buf.UInt32 mBytesPerFrame = 0;
    LOBYTE(v264.mBitsPerChannel) = 1;
    NeuralNet::~NeuralNet((NeuralNet *)&buf);
    if (v63 != 0.0) {
      CFRelease(*(CFTypeRef *)&v63);
    }
    uint64_t v34 = v42;
    if (v45) {
      CFRelease(v45);
    }
    std::__optional_storage_base<NeuralNet,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<NeuralNet,false>>((NeuralNet *)(*((void *)this + 100) + v39 + 64), (uint64_t *)&v264);
    if (LOBYTE(v264.mBitsPerChannel)) {
      NeuralNet::~NeuralNet((NeuralNet *)&v264);
    }
    uint64_t v41 = *((void *)this + 100);
    if (!*(unsigned char *)(v41 + v39 + 96)) {
      return 4294956421;
    }
LABEL_180:
    if (AUNeuralNetLogScope(void)::once != -1) {
      dispatch_once(&AUNeuralNetLogScope(void)::once, &__block_literal_global_3112);
    }
    *(void *)&buf.Float64 mSampleRate = AUNeuralNetLogScope(void)::scope;
    if (getAUNeuralNetLog(void)::onceToken != -1) {
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
    }
    unsigned int v69 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      LODWORD(v264.mSampleRate) = 134217984;
      *(void *)((char *)&v264.mSampleRate + 4) = this;
      _os_log_impl(&dword_1BB0CE000, v69, OS_LOG_TYPE_INFO, "[%p] Loading embedding mode from plist.", (uint8_t *)&v264, 0xCu);
    }
    LODWORD(v254) = 0;
    uint64_t v70 = v41 + v39;
    if (!DictionaryBlobReader::ReadScalarFromDictionary<unsigned int>((uint64_t **)&buf, *(CFDictionaryRef *)(v41 + v39 + 56), @"EmbeddingMode", &v254))
    {
      *((unsigned char *)this + 592) = v254 != 0;
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      uint64_t v72 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      {
        if (*((unsigned char *)this + 592)) {
          double v73 = 1.0;
        }
        else {
          double v73 = 0.0;
        }
        LODWORD(v264.mSampleRate) = 134218240;
        *(void *)((char *)&v264.mSampleRate + 4) = this;
        LOWORD(v264.mFormatFlags) = 2048;
        *(double *)((char *)&v264.mFormatFlags + 2) = v73;
        _os_log_impl(&dword_1BB0CE000, v72, OS_LOG_TYPE_INFO, "[%p] Successfully retrieved embedding mode (%g).", (uint8_t *)&v264, 0x16u);
      }
      uint64_t v74 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v244, 0);
      if (*((unsigned char *)this + 592)) {
        float v75 = 1.0;
      }
      else {
        float v75 = 0.0;
      }
      ausdk::AUElement::SetParameter(v74, 0xCu, v75, 0);
      goto LABEL_202;
    }
    if (getAUNeuralNetLog(void)::onceToken != -1) {
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
    }
    uint64_t v71 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      LODWORD(v264.mSampleRate) = 134217984;
      *(void *)((char *)&v264.mSampleRate + 4) = this;
      _os_log_impl(&dword_1BB0CE000, v71, OS_LOG_TYPE_INFO, "[%p] Failed to retrieve embedding mode", (uint8_t *)&v264, 0xCu);
LABEL_202:
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
    }
    unsigned int v76 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      LODWORD(v264.mSampleRate) = 134217984;
      *(void *)((char *)&v264.mSampleRate + 4) = this;
      _os_log_impl(&dword_1BB0CE000, v76, OS_LOG_TYPE_INFO, "[%p] Loading default embedding mode from plist.", (uint8_t *)&v264, 0xCu);
    }
    LODWORD(v253) = 0;
    if (DictionaryBlobReader::ReadScalarFromDictionary<unsigned int>((uint64_t **)&buf, *(CFDictionaryRef *)(v70 + 56), @"DefaultEmbeddingMode", &v253))
    {
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      unsigned int v77 = getAUNeuralNetLog(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      {
        if (!*((unsigned char *)this + 592)) {
          goto LABEL_235;
        }
        goto LABEL_226;
      }
      LODWORD(v264.mSampleRate) = 134217984;
      *(void *)((char *)&v264.mSampleRate + 4) = this;
      _os_log_impl(&dword_1BB0CE000, v77, OS_LOG_TYPE_INFO, "[%p] Failed to retrieve default embedding mode", (uint8_t *)&v264, 0xCu);
    }
    else
    {
      *((unsigned char *)this + 593) = LODWORD(v253) != 0;
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      double v78 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      {
        if (*((unsigned char *)this + 593)) {
          double v79 = 1.0;
        }
        else {
          double v79 = 0.0;
        }
        LODWORD(v264.mSampleRate) = 134218240;
        *(void *)((char *)&v264.mSampleRate + 4) = this;
        LOWORD(v264.mFormatFlags) = 2048;
        *(double *)((char *)&v264.mFormatFlags + 2) = v79;
        _os_log_impl(&dword_1BB0CE000, v78, OS_LOG_TYPE_INFO, "[%p] Successfully default retrieved embedding mode (%g).", (uint8_t *)&v264, 0x16u);
      }
      double v80 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v244, 0);
      float v81 = *((unsigned char *)this + 593) ? 1.0 : 0.0;
      ausdk::AUElement::SetParameter(v80, 0xDu, v81, 0);
    }
    uint64_t v82 = getAUNeuralNetLog(void)::onceToken;
    if (!*((unsigned char *)this + 592)) {
      goto LABEL_233;
    }
    if (getAUNeuralNetLog(void)::onceToken != -1) {
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
    }
LABEL_226:
    int v83 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      LODWORD(v264.mSampleRate) = 134217984;
      *(void *)((char *)&v264.mSampleRate + 4) = this;
      _os_log_impl(&dword_1BB0CE000, v83, OS_LOG_TYPE_INFO, "[%p] Loading embedding size from plist.", (uint8_t *)&v264, 0xCu);
    }
    if (DictionaryBlobReader::ReadScalarFromDictionary<unsigned int>((uint64_t **)&buf, *(CFDictionaryRef *)(v70 + 56), @"EmbeddingSize", (_DWORD *)(v41 + v39 + 28)))
    {
      unint64_t v239 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      caulk::make_string((caulk *)"Failed to retrieve embedding size. err = %d", (uint64_t)&v264, 4294900555);
      std::runtime_error::runtime_error(v239, (const std::string *)&v264);
    }
    if (getAUNeuralNetLog(void)::onceToken != -1) {
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
    }
    uint64_t v84 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      LODWORD(v85) = *(_DWORD *)(v41 + v39 + 28);
      LODWORD(v264.mSampleRate) = 134218240;
      *(void *)((char *)&v264.mSampleRate + 4) = this;
      LOWORD(v264.mFormatFlags) = 2048;
      *(double *)((char *)&v264.mFormatFlags + 2) = (double)v85;
      _os_log_impl(&dword_1BB0CE000, v84, OS_LOG_TYPE_INFO, "[%p] Successfully retrieved embedding size (%g).", (uint8_t *)&v264, 0x16u);
      uint64_t v82 = getAUNeuralNetLog(void)::onceToken;
LABEL_233:
      if (v82 != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
    }
LABEL_235:
    unsigned int v86 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      LODWORD(v264.mSampleRate) = 134217984;
      *(void *)((char *)&v264.mSampleRate + 4) = this;
      _os_log_impl(&dword_1BB0CE000, v86, OS_LOG_TYPE_INFO, "[%p] Loading sample rate from plist.", (uint8_t *)&v264, 0xCu);
    }
    if (DictionaryBlobReader::ReadScalarFromDictionary<double>((NSObject ***)&buf, *(CFDictionaryRef *)(v70 + 56), @"SampleRate", (uint64_t *)(v41 + v39)))
    {
      unint64_t v234 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      caulk::make_string((caulk *)"Failed to retrieve sample rate. err = %d", (uint64_t)&v264, 4294900555);
      std::runtime_error::runtime_error(v234, (const std::string *)&v264);
    }
    if (getAUNeuralNetLog(void)::onceToken != -1) {
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
    }
    unsigned int v87 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      uint64_t v88 = *(void *)(v41 + v39);
      LODWORD(v264.mSampleRate) = 134218240;
      *(void *)((char *)&v264.mSampleRate + 4) = this;
      LOWORD(v264.mFormatFlags) = 2048;
      *(void *)((char *)&v264.mFormatFlags + 2) = v88;
      _os_log_impl(&dword_1BB0CE000, v87, OS_LOG_TYPE_INFO, "[%p] Successfully retrieved sample rate (%g Hz).", (uint8_t *)&v264, 0x16u);
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
    }
    BOOL v89 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      LODWORD(v264.mSampleRate) = 134217984;
      *(void *)((char *)&v264.mSampleRate + 4) = this;
      _os_log_impl(&dword_1BB0CE000, v89, OS_LOG_TYPE_INFO, "[%p] Loading number of input channels from plist.", (uint8_t *)&v264, 0xCu);
    }
    if (DictionaryBlobReader::ReadScalarFromDictionary<unsigned int>((uint64_t **)&buf, *(CFDictionaryRef *)(v70 + 56), @"NumberOfInputChannels", (_DWORD *)(v41 + v39 + 8)))
    {
      unint64_t v236 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      caulk::make_string((caulk *)"Failed to retrieve number of input channels. err = %d", (uint64_t)&v264, 4294900555);
      std::runtime_error::runtime_error(v236, (const std::string *)&v264);
    }
    if (getAUNeuralNetLog(void)::onceToken != -1) {
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
    }
    char v90 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      AudioFormatFlags v91 = *(_DWORD *)(v41 + v39 + 8);
      LODWORD(v264.mSampleRate) = 134218240;
      *(void *)((char *)&v264.mSampleRate + 4) = this;
      LOWORD(v264.mFormatFlags) = 1024;
      *(AudioFormatFlags *)((char *)&v264.mFormatFlags + 2) = v91;
      _os_log_impl(&dword_1BB0CE000, v90, OS_LOG_TYPE_INFO, "[%p] Successfully retrieved number of input channels (%u).", (uint8_t *)&v264, 0x12u);
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
    }
    float v92 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      LODWORD(v264.mSampleRate) = 134217984;
      *(void *)((char *)&v264.mSampleRate + 4) = this;
      _os_log_impl(&dword_1BB0CE000, v92, OS_LOG_TYPE_INFO, "[%p] Loading number of output channels from plist.", (uint8_t *)&v264, 0xCu);
    }
    if (DictionaryBlobReader::ReadScalarFromDictionary<unsigned int>((uint64_t **)&buf, *(CFDictionaryRef *)(v70 + 56), @"NumberOfOutputChannels", (_DWORD *)(v41 + v39 + 12)))
    {
      unint64_t v237 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      caulk::make_string((caulk *)"Failed to retrieve number of output channels. err = %d", (uint64_t)&v264, 4294900555);
      std::runtime_error::runtime_error(v237, (const std::string *)&v264);
    }
    if (getAUNeuralNetLog(void)::onceToken != -1) {
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
    }
    double v93 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      AudioFormatFlags v94 = *(_DWORD *)(v41 + v39 + 12);
      LODWORD(v264.mSampleRate) = 134218240;
      *(void *)((char *)&v264.mSampleRate + 4) = this;
      LOWORD(v264.mFormatFlags) = 1024;
      *(AudioFormatFlags *)((char *)&v264.mFormatFlags + 2) = v94;
      _os_log_impl(&dword_1BB0CE000, v93, OS_LOG_TYPE_INFO, "[%p] Successfully retrieved number of output channels (%u).", (uint8_t *)&v264, 0x12u);
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
    }
    unsigned int v95 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      LODWORD(v264.mSampleRate) = 134217984;
      *(void *)((char *)&v264.mSampleRate + 4) = this;
      _os_log_impl(&dword_1BB0CE000, v95, OS_LOG_TYPE_INFO, "[%p] Loading lookahead size from plist.", (uint8_t *)&v264, 0xCu);
    }
    if (DictionaryBlobReader::ReadScalarFromDictionary<unsigned int>((uint64_t **)&buf, *(CFDictionaryRef *)(v70 + 56), @"LookaheadSize", (_DWORD *)(v41 + v39 + 16)))
    {
      unint64_t v238 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      caulk::make_string((caulk *)"Failed to retrieve lookahead size. err = %d", (uint64_t)&v264, 4294900555);
      std::runtime_error::runtime_error(v238, (const std::string *)&v264);
    }
    if (getAUNeuralNetLog(void)::onceToken != -1) {
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
    }
    uint64_t v96 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      AudioFormatFlags v97 = *(_DWORD *)(v41 + v39 + 16);
      LODWORD(v264.mSampleRate) = 134218240;
      *(void *)((char *)&v264.mSampleRate + 4) = this;
      LOWORD(v264.mFormatFlags) = 1024;
      *(AudioFormatFlags *)((char *)&v264.mFormatFlags + 2) = v97;
      _os_log_impl(&dword_1BB0CE000, v96, OS_LOG_TYPE_INFO, "[%p] Successfully retrieved lookahead size (%u).", (uint8_t *)&v264, 0x12u);
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
    }
    uint64_t v98 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      LODWORD(v264.mSampleRate) = 134217984;
      *(void *)((char *)&v264.mSampleRate + 4) = this;
      _os_log_impl(&dword_1BB0CE000, v98, OS_LOG_TYPE_INFO, "[%p] Loading block size from plist.", (uint8_t *)&v264, 0xCu);
    }
    if (DictionaryBlobReader::ReadScalarFromDictionary<unsigned int>((uint64_t **)&buf, *(CFDictionaryRef *)(v70 + 56), @"BlockSize", (_DWORD *)(v41 + v39 + 20)))
    {
      uint64_t v233 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      caulk::make_string((caulk *)"Failed to retrieve block size. err = %d", (uint64_t)&v264, 4294900555);
      std::runtime_error::runtime_error(v233, (const std::string *)&v264);
    }
    if (getAUNeuralNetLog(void)::onceToken != -1) {
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
    }
    unsigned int v99 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      AudioFormatFlags v100 = *(_DWORD *)(v41 + v39 + 20);
      LODWORD(v264.mSampleRate) = 134218240;
      *(void *)((char *)&v264.mSampleRate + 4) = this;
      LOWORD(v264.mFormatFlags) = 1024;
      *(AudioFormatFlags *)((char *)&v264.mFormatFlags + 2) = v100;
      _os_log_impl(&dword_1BB0CE000, v99, OS_LOG_TYPE_INFO, "[%p] Successfully retrieved block size (%u).", (uint8_t *)&v264, 0x12u);
    }
    if (!*(_DWORD *)(v41 + v39 + 24))
    {
      uint64_t v235 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      caulk::make_string((caulk *)"Failed to retrieve block size. err = %d batchCFIndex size = %u", (uint64_t)&v264, 4294900553, *(unsigned int *)(v41 + v39 + 24), v240);
      std::runtime_error::runtime_error(v235, (const std::string *)&v264);
    }
    if (getAUNeuralNetLog(void)::onceToken != -1) {
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
    }
    uint64_t v101 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      LODWORD(v264.mSampleRate) = 134217984;
      *(void *)((char *)&v264.mSampleRate + 4) = this;
      _os_log_impl(&dword_1BB0CE000, v101, OS_LOG_TYPE_INFO, "[%p] Loading task ID.", (uint8_t *)&v264, 0xCu);
    }
    CFStringRef v102 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(v70 + 56), @"TaskID");
    CFStringRef v103 = v102;
    if (v102)
    {
      CFRetain(v102);
      *(void *)vDSP_Length v260 = v103;
      applesauce::CF::convert_to<std::string,0>(v103, (uint64_t)&v264);
      unsigned int v104 = (void **)(v41 + v39 + 32);
      if (*(char *)(v41 + v39 + 55) < 0) {
        operator delete(*v104);
      }
      long long v105 = *(_OWORD *)&v264.mSampleRate;
      *(void *)(v41 + v39 + 48) = *(void *)&v264.mBytesPerPacket;
      *(_OWORD *)unsigned int v104 = v105;
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      uint64_t v106 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      {
        LODWORD(v264.mSampleRate) = 134217984;
        *(void *)((char *)&v264.mSampleRate + 4) = this;
        uint64_t v107 = v106;
        uint64_t v108 = "[%p] TaskID read from the plist.";
        goto LABEL_293;
      }
    }
    else
    {
      *(void *)vDSP_Length v260 = 0;
      uint64_t v109 = v41 + v39;
      char v110 = (void *)(v41 + v39 + 32);
      if (*(char *)(v41 + v39 + 55) < 0)
      {
        *(void *)(v109 + 40) = 3;
        char v110 = (void *)*v110;
      }
      else
      {
        *(unsigned char *)(v109 + 55) = 3;
      }
      *(_DWORD *)char v110 = 4271950;
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      uint64_t v111 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      {
        LODWORD(v264.mSampleRate) = 134217984;
        *(void *)((char *)&v264.mSampleRate + 4) = this;
        uint64_t v107 = v111;
        uint64_t v108 = "[%p] TaskID not available in the plist.";
LABEL_293:
        _os_log_impl(&dword_1BB0CE000, v107, OS_LOG_TYPE_INFO, v108, (uint8_t *)&v264, 0xCu);
        if (getAUNeuralNetLog(void)::onceToken != -1) {
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
        }
      }
    }
    uint64_t v112 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      size_t v113 = (void *)(v41 + v39 + 32);
      if (*(char *)(v41 + v39 + 55) < 0) {
        size_t v113 = (void *)*v113;
      }
      LODWORD(v264.mSampleRate) = 134218242;
      *(void *)((char *)&v264.mSampleRate + 4) = this;
      LOWORD(v264.mFormatFlags) = 2080;
      *(void *)((char *)&v264.mFormatFlags + 2) = v113;
      _os_log_impl(&dword_1BB0CE000, v112, OS_LOG_TYPE_INFO, "[%p] TaskID set to (%s).", (uint8_t *)&v264, 0x16u);
    }
    if (v103) {
      CFRelease(v103);
    }
    BOOL v114 = *((unsigned char *)this + 664) == 0;
    uint64_t v115 = *((void *)this + 100);
    uint64_t v116 = v115 + v39;
    unint64_t v117 = (*(uint64_t (**)(void))(**(void **)(v115 + v39 + 64) + 24))(*(void *)(v115 + v39 + 64));
    int v118 = *(_DWORD *)(v115 + v39 + 8);
    uint64_t v119 = v115 + v39;
    if (!v114)
    {
      if (v117 > (2 * (v118 + v118 * *(_DWORD *)(v119 + 20)) * *(_DWORD *)(v119 + 24)))
      {
        if (getAUNeuralNetLog(void)::onceToken != -1) {
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
        }
        uint64_t v160 = getAUNeuralNetLog(void)::gLog;
        if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
          goto LABEL_443;
        }
        uint64_t v161 = (*(uint64_t (**)(void))(**(void **)(v116 + 64) + 24))(*(void *)(v116 + 64));
        UInt32 v162 = *(_DWORD *)(v116 + 8);
        UInt32 v163 = *(_DWORD *)(v119 + 24);
        int v164 = *(_DWORD *)(v119 + 20) + 1;
        LODWORD(v264.mSampleRate) = 134219008;
        *(void *)((char *)&v264.mSampleRate + 4) = this;
        LOWORD(v264.mFormatFlags) = 2048;
        *(void *)((char *)&v264.mFormatFlags + 2) = v161;
        HIWORD(v264.mFramesPerPacket) = 1024;
        v264.UInt32 mBytesPerFrame = v162;
        LOWORD(v264.mChannelsPerFrame) = 1024;
        *(UInt32 *)((char *)&v264.mChannelsPerFrame + 2) = v164;
        HIWORD(v264.mBitsPerChannel) = 1024;
        v264.mReserved = v163;
        uint64_t v165 = "[%p] NeuralNet input size (%zu) exceeds freq domain format size: input channels (%u) num bins (%u) batch size (%u).";
        goto LABEL_431;
      }
      unint64_t v120 = (*(uint64_t (**)(void))(**(void **)(v116 + 64) + 32))(*(void *)(v116 + 64));
      uint64_t v121 = v115 + v39;
      int v122 = *(_DWORD *)(v115 + v39 + 12);
      int v123 = *(_DWORD *)(v119 + 24);
      if (v120 <= (2 * (v122 + v122 * *(_DWORD *)(v119 + 20)) * v123))
      {
        Float64 v124 = v251.mSampleRate;
        if (v251.mSampleRate == *(double *)(v115 + v39))
        {
          if (*(_DWORD *)(v116 + 8) * v123 == 2 * *v246)
          {
            if (v123 * v122 == 2 * *v248)
            {
              if (getAUNeuralNetLog(void)::onceToken != -1) {
                dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
              }
              unint64_t v125 = v245;
              unint64_t v126 = getAUNeuralNetLog(void)::gLog;
              if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEBUG)) {
                goto LABEL_328;
              }
              goto LABEL_319;
            }
            if (getAUNeuralNetLog(void)::onceToken != -1) {
              dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
            }
            uint64_t v167 = getAUNeuralNetLog(void)::gLog;
            if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
            {
LABEL_443:
              float v187 = getAUNeuralNetLog(void)::gLog;
              uint64_t v14 = 4294956421;
              if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
              {
                LODWORD(v264.mSampleRate) = 134218240;
                *(void *)((char *)&v264.mSampleRate + 4) = this;
                LOWORD(v264.mFormatFlags) = 1024;
                *(AudioFormatFlags *)((char *)&v264.mFormatFlags + 2) = -10875;
                _os_log_error_impl(&dword_1BB0CE000, v187, OS_LOG_TYPE_ERROR, "[%p] Could not create NeuralNet model using the plist, exception (%d)", (uint8_t *)&v264, 0x12u);
              }
              return v14;
            }
            goto LABEL_507;
          }
          if (getAUNeuralNetLog(void)::onceToken != -1) {
            dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
          }
          uint64_t v167 = getAUNeuralNetLog(void)::gLog;
          if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
            goto LABEL_443;
          }
LABEL_409:
          AudioFormatFlags v168 = *(_DWORD *)(v116 + 8);
          UInt32 v169 = *(_DWORD *)(v119 + 24);
          UInt32 v170 = *((_DWORD *)this + 164);
          LODWORD(v264.mSampleRate) = 134218752;
          *(void *)((char *)&v264.mSampleRate + 4) = this;
          LOWORD(v264.mFormatFlags) = 1024;
          *(AudioFormatFlags *)((char *)&v264.mFormatFlags + 2) = v168;
          HIWORD(v264.mBytesPerPacket) = 1024;
          v264.mFramesPerPacket = v169;
          LOWORD(v264.mBytesPerFrame) = 1024;
          *(UInt32 *)((char *)&v264.mBytesPerFrame + 2) = v170;
          uint64_t v165 = "[%p] NeuralNet's number of input channels (%u) times batch size (%u) not matching AU's number of input channels (%u).";
LABEL_508:
          vDSP_Length v184 = v167;
          uint32_t v185 = 30;
LABEL_509:
          _os_log_error_impl(&dword_1BB0CE000, v184, OS_LOG_TYPE_ERROR, v165, (uint8_t *)&v264, v185);
          if (getAUNeuralNetLog(void)::onceToken != -1) {
            dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
          }
          goto LABEL_443;
        }
        if (getAUNeuralNetLog(void)::onceToken != -1) {
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
        }
        uint64_t v166 = getAUNeuralNetLog(void)::gLog;
        if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
          goto LABEL_443;
        }
LABEL_435:
        uint64_t v186 = *(void *)(v115 + v39);
        LODWORD(v264.mSampleRate) = 134218496;
        *(void *)((char *)&v264.mSampleRate + 4) = this;
        LOWORD(v264.mFormatFlags) = 2048;
        *(Float64 *)((char *)&v264.mFormatFlags + 2) = v124;
        HIWORD(v264.mFramesPerPacket) = 2048;
        *(void *)&v264.UInt32 mBytesPerFrame = v186;
        uint64_t v165 = "[%p] Current input sample rate (%g Hz) not matching NeuralNet sample rate (%g).";
        vDSP_Length v184 = v166;
        uint32_t v185 = 32;
        goto LABEL_509;
      }
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      uint64_t v160 = getAUNeuralNetLog(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
        goto LABEL_443;
      }
      goto LABEL_430;
    }
    if (v117 != *(_DWORD *)(v119 + 20) * v118 * *(_DWORD *)(v119 + 24))
    {
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      uint64_t v160 = getAUNeuralNetLog(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
        goto LABEL_443;
      }
      uint64_t v176 = (*(uint64_t (**)(void))(**(void **)(v116 + 64) + 24))(*(void *)(v116 + 64));
      UInt32 v177 = *(_DWORD *)(v116 + 8);
      UInt32 v178 = *(_DWORD *)(v119 + 20);
      UInt32 v179 = *(_DWORD *)(v119 + 24);
      LODWORD(v264.mSampleRate) = 134219008;
      *(void *)((char *)&v264.mSampleRate + 4) = this;
      LOWORD(v264.mFormatFlags) = 2048;
      *(void *)((char *)&v264.mFormatFlags + 2) = v176;
      HIWORD(v264.mFramesPerPacket) = 1024;
      v264.UInt32 mBytesPerFrame = v177;
      LOWORD(v264.mChannelsPerFrame) = 1024;
      *(UInt32 *)((char *)&v264.mChannelsPerFrame + 2) = v178;
      HIWORD(v264.mBitsPerChannel) = 1024;
      v264.mReserved = v179;
      uint64_t v165 = "[%p] NeuralNet input size (%zu) not matching configured number of input channels (%u) times block size (%u)"
             " times batch size (%u).";
      goto LABEL_431;
    }
    uint64_t v127 = (*(uint64_t (**)(void))(**(void **)(v116 + 64) + 32))(*(void *)(v116 + 64));
    uint64_t v121 = v115 + v39;
    int v128 = *(_DWORD *)(v119 + 24);
    int v129 = v128 * *(_DWORD *)(v115 + v39 + 12);
    if (v127 != v129 * *(_DWORD *)(v119 + 20))
    {
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      uint64_t v160 = getAUNeuralNetLog(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
        goto LABEL_443;
      }
LABEL_430:
      uint64_t v180 = (*(uint64_t (**)(void))(**(void **)(v116 + 64) + 32))(*(void *)(v116 + 64));
      UInt32 v181 = *(_DWORD *)(v121 + 12);
      UInt32 v182 = *(_DWORD *)(v119 + 20);
      UInt32 v183 = *(_DWORD *)(v119 + 24);
      LODWORD(v264.mSampleRate) = 134219008;
      *(void *)((char *)&v264.mSampleRate + 4) = this;
      LOWORD(v264.mFormatFlags) = 2048;
      *(void *)((char *)&v264.mFormatFlags + 2) = v180;
      HIWORD(v264.mFramesPerPacket) = 1024;
      v264.UInt32 mBytesPerFrame = v181;
      LOWORD(v264.mChannelsPerFrame) = 1024;
      *(UInt32 *)((char *)&v264.mChannelsPerFrame + 2) = v182;
      HIWORD(v264.mBitsPerChannel) = 1024;
      v264.mReserved = v183;
      uint64_t v165 = "[%p] NeuralNet output size (%zu) not matching configured number of output channels (%u) times block size (%"
             "u) times batch size (%u).";
LABEL_431:
      vDSP_Length v184 = v160;
      uint32_t v185 = 40;
      goto LABEL_509;
    }
    Float64 v124 = v251.mSampleRate;
    if (v251.mSampleRate != *(double *)(v115 + v39))
    {
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      uint64_t v166 = getAUNeuralNetLog(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
        goto LABEL_443;
      }
      goto LABEL_435;
    }
    if (*v246 != *(_DWORD *)(v116 + 8) * v128)
    {
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      uint64_t v167 = getAUNeuralNetLog(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
        goto LABEL_443;
      }
      goto LABEL_409;
    }
    if (*v248 != v129)
    {
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      uint64_t v167 = getAUNeuralNetLog(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
        goto LABEL_443;
      }
LABEL_507:
      AudioFormatFlags v230 = *(_DWORD *)(v115 + v39 + 12);
      UInt32 v231 = *(_DWORD *)(v115 + v39 + 24);
      UInt32 v232 = *((_DWORD *)this + 165);
      LODWORD(v264.mSampleRate) = 134218752;
      *(void *)((char *)&v264.mSampleRate + 4) = this;
      LOWORD(v264.mFormatFlags) = 1024;
      *(AudioFormatFlags *)((char *)&v264.mFormatFlags + 2) = v230;
      HIWORD(v264.mBytesPerPacket) = 1024;
      v264.mFramesPerPacket = v231;
      LOWORD(v264.mBytesPerFrame) = 1024;
      *(UInt32 *)((char *)&v264.mBytesPerFrame + 2) = v232;
      uint64_t v165 = "[%p] NeuralNet's number of output channels (%u) times batch size (%u) not matching AU's number of output channels (%u).";
      goto LABEL_508;
    }
    if (getAUNeuralNetLog(void)::onceToken != -1) {
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
    }
    unint64_t v125 = v245;
    unint64_t v126 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEBUG))
    {
LABEL_328:
      AudioFormatFlags v132 = *(_DWORD *)(v116 + 8);
      UInt32 v133 = *(_DWORD *)(v121 + 12);
      UInt32 v134 = *(_DWORD *)(v119 + 20);
      UInt32 v135 = *(_DWORD *)(v119 + 24);
      LODWORD(v264.mSampleRate) = 134219008;
      *(void *)((char *)&v264.mSampleRate + 4) = this;
      LOWORD(v264.mFormatFlags) = 1024;
      *(AudioFormatFlags *)((char *)&v264.mFormatFlags + 2) = v132;
      HIWORD(v264.mBytesPerPacket) = 1024;
      v264.mFramesPerPacket = v133;
      LOWORD(v264.mBytesPerFrame) = 1024;
      *(UInt32 *)((char *)&v264.mBytesPerFrame + 2) = v134;
      HIWORD(v264.mChannelsPerFrame) = 1024;
      v264.UInt32 mBitsPerChannel = v135;
      _os_log_debug_impl(&dword_1BB0CE000, v126, OS_LOG_TYPE_DEBUG, "[%p] NeuralNet is initialized with %u input channels, %u output channels, block size %u, and batch size %u.", (uint8_t *)&v264, 0x24u);
    }
LABEL_319:
    if (!v39) {
      goto LABEL_322;
    }
    uint64_t v130 = *((void *)this + 100);
    if (*(_DWORD *)(v130 + 20) != *(_DWORD *)(v130 + v39 + 20)) {
      break;
    }
    if (*(_DWORD *)(v130 + 16) != *(_DWORD *)(v130 + v39 + 16))
    {
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      uint64_t v171 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
      {
        uint64_t v174 = *((void *)this + 100);
        AudioFormatFlags v175 = *(_DWORD *)(v174 + 16);
        LODWORD(v174) = *(_DWORD *)(v174 + 104 * v245 + 16);
        LODWORD(v264.mSampleRate) = 134218752;
        *(void *)((char *)&v264.mSampleRate + 4) = this;
        LOWORD(v264.mFormatFlags) = 1024;
        *(AudioFormatFlags *)((char *)&v264.mFormatFlags + 2) = v175;
        HIWORD(v264.mBytesPerPacket) = 1024;
        v264.mFramesPerPacket = v245;
        LOWORD(v264.mBytesPerFrame) = 1024;
        *(UInt32 *)((char *)&v264.mBytesPerFrame + 2) = v174;
        int v9 = "[%p] NeuralNet0 lookaheadSize (%u) and NeuralNet%u lookaheadSize (%u) do not match";
        goto LABEL_422;
      }
      return 4294956421;
    }
LABEL_322:
    unint64_t v40 = v125 + 1;
    v39 += 104;
    if (v40 >= *((unsigned int *)this + 206)) {
      goto LABEL_339;
    }
  }
  if (getAUNeuralNetLog(void)::onceToken != -1) {
    dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
  }
  uint64_t v171 = getAUNeuralNetLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
  {
    uint64_t v172 = *((void *)this + 100);
    AudioFormatFlags v173 = *(_DWORD *)(v172 + 20);
    LODWORD(v172) = *(_DWORD *)(v172 + 104 * v245 + 20);
    LODWORD(v264.mSampleRate) = 134218752;
    *(void *)((char *)&v264.mSampleRate + 4) = this;
    LOWORD(v264.mFormatFlags) = 1024;
    *(AudioFormatFlags *)((char *)&v264.mFormatFlags + 2) = v173;
    HIWORD(v264.mBytesPerPacket) = 1024;
    v264.mFramesPerPacket = v245;
    LOWORD(v264.mBytesPerFrame) = 1024;
    *(UInt32 *)((char *)&v264.mBytesPerFrame + 2) = v172;
    int v9 = "[%p] NeuralNet0 blockSize (%u) and NeuralNet(%u) blockSize (%u) do not match";
LABEL_422:
    unsigned int v10 = (uint8_t *)&v264;
    unint64_t v11 = v171;
    uint32_t v12 = 30;
    goto LABEL_91;
  }
  return 4294956421;
}

void sub_1BB3A82C8(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1BB3A8338(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,long long a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,long long a30)
{
  if (a2)
  {
    if (*(char *)(v33 - 169) < 0) {
      operator delete(*(void **)(v33 - 192));
    }
    if (v32) {
      __cxa_free_exception(v31);
    }
    long long v36 = __cxa_begin_catch(a1);
    if (a2 == 3)
    {
      int v37 = v36;
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      unsigned int v38 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
      {
        uint64_t v40 = (*(uint64_t (**)(void *))(*(void *)v37 + 16))(v37);
        *(_DWORD *)(v33 - 192) = a21;
        uint64_t v41 = v33 - 224;
        *(void *)(v41 + 36) = v30;
        *(_WORD *)(v33 - 180) = 2080;
        *(void *)(v41 + 46) = v40;
        _os_log_error_impl(&dword_1BB0CE000, v38, OS_LOG_TYPE_ERROR, "[%p] Could not load metadata using the plist, exception (%s)", (uint8_t *)(v33 - 192), 0x16u);
      }
    }
    else
    {
      if (getAUNeuralNetLog(void)::onceToken != -1) {
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
      }
      uint64_t v39 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)(v33 - 192) = a30;
        *(void *)(v33 - 188) = v30;
        _os_log_error_impl(&dword_1BB0CE000, v39, OS_LOG_TYPE_ERROR, "[%p] Could not load metadata using the plist, unknown exception.", (uint8_t *)(v33 - 192), 0xCu);
      }
    }
    __cxa_end_catch();
    JUMPOUT(0x1BB3A44B0);
  }
  _Unwind_Resume(a1);
}

void sub_1BB3A8364(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    JUMPOUT(0x1BB3A8370);
  }
  _Unwind_Resume(a1);
}

void sub_1BB3A8374(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    JUMPOUT(0x1BB3A8380);
  }
  _Unwind_Resume(a1);
}

void std::make_unique[abi:ne180100]<BlockProcessor,int,unsigned int *,int,unsigned int *,unsigned int &,int (&)(void *,unsigned int,AudioBufferList const**,AudioBufferList**),AUNeuralNet *>()
{
}

void sub_1BB3A8568(_Unwind_Exception *a1)
{
  MEMORY[0x1C185D370](v1, 0x1080C40622722D2);
  _Unwind_Resume(a1);
}

void std::make_unique[abi:ne180100]<BlockProcessorLowDelay,int,unsigned int *,int,unsigned int *,unsigned int &,unsigned int &,int (&)(void *,unsigned int,AudioBufferList const**,AudioBufferList**),AUNeuralNet *>()
{
}

void sub_1BB3A86A0(_Unwind_Exception *a1)
{
  BlockBuffer::~BlockBuffer(v2);
  BlockBuffer::~BlockBuffer(v1);
  MEMORY[0x1C185D370](v1, 0x1080C40367E4524);
  _Unwind_Resume(a1);
}

void std::default_delete<BlockProcessorLowDelay>::operator()[abi:ne180100](uint64_t a1)
{
  BlockBuffer::~BlockBuffer((BlockBuffer *)(a1 + 48));
  BlockBuffer::~BlockBuffer((BlockBuffer *)(a1 + 24));
  BlockBuffer::~BlockBuffer((BlockBuffer *)a1);

  JUMPOUT(0x1C185D370);
}

void AUNeuralNet::~AUNeuralNet(AUNeuralNet *this)
{
  AUNeuralNet::~AUNeuralNet(this);

  JUMPOUT(0x1C185D370);
}

{
  VPTimeFreqConverter *v2;
  NSObject *v3;
  uint64_t v4;
  unint64_t v5;
  VPTimeFreqConverter *v6;
  NSObject *v7;
  NSObject *v8;
  void *v9;
  void *v10;
  uint64_t v11;
  void *v12;
  const void *v13;
  const void *v14;
  const void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  std::__shared_weak_count *v29;
  unsigned char buf[12];
  __int16 v31;
  int v32;
  uint64_t v33;

  uint64_t v33 = *MEMORY[0x1E4F143B8];
  *(void *)this = &unk_1F14ACC48;
  unint64_t v2 = (VPTimeFreqConverter *)*((void *)this + 144);
  if (v2)
  {
    VPTimeFreqConverter::~VPTimeFreqConverter(v2);
    MEMORY[0x1C185D370]();
    *((void *)this + 144) = 0;
    if (getAUNeuralNetLog(void)::onceToken != -1) {
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
    }
    unint64_t v3 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)AudioStreamBasicDescription buf = 134217984;
      *(void *)&uint8_t buf[4] = this;
      _os_log_impl(&dword_1BB0CE000, v3, OS_LOG_TYPE_DEFAULT, "[%p] disposed mTimeFreqConverterInputDelayed", buf, 0xCu);
    }
  }
  unint64_t v4 = *((void *)this + 145);
  if (*((void *)this + 146) != v4)
  {
    long long v5 = 0;
    do
    {
      AudioFormatFlags v6 = *(VPTimeFreqConverter **)(v4 + 8 * v5);
      if (v6)
      {
        VPTimeFreqConverter::~VPTimeFreqConverter(v6);
        MEMORY[0x1C185D370]();
        *(void *)(*((void *)this + 145) + 8 * v5) = 0;
        if (getAUNeuralNetLog(void)::onceToken != -1) {
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
        }
        uint64_t v7 = getAUNeuralNetLog(void)::gLog;
        if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)AudioStreamBasicDescription buf = 134218240;
          *(void *)&uint8_t buf[4] = this;
          AudioFormatFlags v31 = 1024;
          int v32 = v5;
          _os_log_impl(&dword_1BB0CE000, v7, OS_LOG_TYPE_DEFAULT, "[%p] disposed mTimeFreqConvertersOutput[%d]", buf, 0x12u);
        }
      }
      ++v5;
      unint64_t v4 = *((void *)this + 145);
    }
    while (v5 < (*((void *)this + 146) - v4) >> 3);
  }
  if (getAUNeuralNetLog(void)::onceToken != -1) {
    dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_94);
  }
  uint64_t v8 = getAUNeuralNetLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)AudioStreamBasicDescription buf = 134217984;
    *(void *)&uint8_t buf[4] = this;
    _os_log_impl(&dword_1BB0CE000, v8, OS_LOG_TYPE_DEFAULT, "[%p] destructed", buf, 0xCu);
  }
  if (*((void *)this + 173))
  {
    (*((void (**)(void))ausdk::BufferAllocator::instance(void)::global + 3))();
    *((void *)this + 173) = 0;
  }
  *((void *)this + 174) = 0;
  *((_DWORD *)this + 344) = 0;
  int v9 = (void *)*((void *)this + 165);
  if (v9)
  {
    *((void *)this + 166) = v9;
    operator delete(v9);
  }
  unsigned int v10 = (void *)*((void *)this + 160);
  if (v10)
  {
    *((void *)this + 161) = v10;
    operator delete(v10);
  }
  unint64_t v11 = *((void *)this + 158);
  *((void *)this + 158) = 0;
  if (v11) {
    std::default_delete<BlockProcessorLowDelay>::operator()[abi:ne180100](v11);
  }
  std::unique_ptr<BlockProcessor>::reset[abi:ne180100]((uint64_t *)this + 157, 0);
  if (*((unsigned char *)this + 1232))
  {
    uint32_t v12 = (void *)*((void *)this + 151);
    if (v12)
    {
      *((void *)this + 152) = v12;
      operator delete(v12);
    }
  }
  uint64_t v13 = (const void *)*((void *)this + 150);
  if (v13) {
    CFRelease(v13);
  }
  uint64_t v14 = (const void *)*((void *)this + 149);
  if (v14) {
    CFRelease(v14);
  }
  unint64_t v15 = (const void *)*((void *)this + 148);
  if (v15) {
    CFRelease(v15);
  }
  uint64_t v16 = (void *)*((void *)this + 145);
  if (v16)
  {
    *((void *)this + 146) = v16;
    operator delete(v16);
  }
  unsigned int v17 = (void *)*((void *)this + 141);
  if (v17)
  {
    *((void *)this + 142) = v17;
    operator delete(v17);
  }
  uint64_t v18 = (void *)*((void *)this + 138);
  if (v18)
  {
    *((void *)this + 139) = v18;
    operator delete(v18);
  }
  uint64_t v19 = (void *)*((void *)this + 135);
  if (v19)
  {
    *((void *)this + 136) = v19;
    operator delete(v19);
  }
  *(void *)AudioStreamBasicDescription buf = (char *)this + 1056;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
  uint64_t v20 = (void *)*((void *)this + 129);
  if (v20)
  {
    *((void *)this + 130) = v20;
    operator delete(v20);
  }
  double v21 = (void *)*((void *)this + 126);
  if (v21)
  {
    *((void *)this + 127) = v21;
    operator delete(v21);
  }
  int v22 = (void *)*((void *)this + 123);
  if (v22)
  {
    *((void *)this + 124) = v22;
    operator delete(v22);
  }
  AudioFormatID v23 = (void *)*((void *)this + 119);
  if (v23)
  {
    *((void *)this + 120) = v23;
    operator delete(v23);
  }
  AudioFormatFlags v24 = (void *)*((void *)this + 116);
  if (v24)
  {
    *((void *)this + 117) = v24;
    operator delete(v24);
  }
  int v25 = (void *)*((void *)this + 113);
  if (v25)
  {
    *((void *)this + 114) = v25;
    operator delete(v25);
  }
  uint64_t v26 = (void *)*((void *)this + 110);
  if (v26)
  {
    *((void *)this + 111) = v26;
    operator delete(v26);
  }
  UInt32 v27 = (void *)*((void *)this + 107);
  if (v27)
  {
    *((void *)this + 108) = v27;
    operator delete(v27);
  }
  unsigned int v28 = (void *)*((void *)this + 104);
  if (v28)
  {
    *((void *)this + 105) = v28;
    operator delete(v28);
  }
  *(void *)AudioStreamBasicDescription buf = (char *)this + 800;
  std::vector<AUNeuralNet::NeuralNetWrapper>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
  UInt32 v29 = (std::__shared_weak_count *)*((void *)this + 67);
  if (v29) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v29);
  }
  ausdk::AUBase::~AUBase(this);
}

void sub_1BB3A8BB4(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

void std::vector<AUNeuralNet::NeuralNetWrapper>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = (char *)**a1;
  if (v2)
  {
    unint64_t v4 = (char *)v1[1];
    long long v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        if (*(v4 - 8)) {
          NeuralNet::~NeuralNet((NeuralNet *)(v4 - 40));
        }
        AudioFormatFlags v6 = (const void *)*((void *)v4 - 6);
        if (v6) {
          CFRelease(v6);
        }
        if (*(v4 - 49) < 0) {
          operator delete(*((void **)v4 - 9));
        }
        v4 -= 104;
      }
      while (v4 != v2);
      long long v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

BOOL applesauce::CF::details::has_key<__CFString const*>(const __CFDictionary *a1, const void *a2)
{
  return a2 && CFDictionaryContainsKey(a1, a2) != 0;
}

void CLiteMatrix::CLiteMatrix(CLiteMatrix *this, uint64_t a2, uint64_t a3)
{
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *(void *)this = a2;
  *((void *)this + 1) = a3;
  int v3 = 0;
  std::vector<float>::assign((char **)this + 2, 2 * a2 * a3, &v3);
}

void sub_1BB3A8D10(_Unwind_Exception *exception_object)
{
  unint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 24) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

VBAP *std::unique_ptr<VBAP>::reset[abi:ne180100](VBAP **a1, VBAP *a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    VBAP::~VBAP(result);
    JUMPOUT(0x1C185D370);
  }
  return result;
}

uint64_t AUSpatialMixerV2DynamicXTCFilter::updateSpeakerLocations(uint64_t this)
{
  if (*(void *)(this + 784))
  {
    if (*(void *)(this + 920) != *(void *)(this + 912)) {
      return this;
    }
    float v1 = 20.0;
  }
  else
  {
    float v1 = *(float *)(this + 44);
  }
  uint64_t v2 = *(unsigned int *)(this + 20);
  if (v2)
  {
    uint64_t v3 = 0;
    float v4 = -v1;
    float v5 = floorf((float)v2 * 0.5);
    uint64_t v6 = *(void *)(this + 864);
    float v7 = v1 * 0.5;
    uint64_t v8 = *(void *)(this + 888);
    do
    {
      float v9 = (float)((float)(v5 - (float)v3) * v4) * 0.5;
      if (v9 >= 0.0 && (v2 & 1) == 0) {
        float v11 = v7;
      }
      else {
        float v11 = -0.0;
      }
      *(float *)(v6 + 4 * v3) = v9 + v11;
      *(_DWORD *)(v8 + 4 * v3++) = 0;
    }
    while (v2 != v3);
  }
  return this;
}

void std::make_unique[abi:ne180100]<VBAP,std::vector<float> &,std::vector<float> &>()
{
}

void sub_1BB3A8F08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  *(void *)(v19 - 40) = v18;
  std::vector<std::list<int>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v19 - 40));
  if (__p) {
    operator delete(__p);
  }
  if (a16) {
    operator delete(a16);
  }
  double v21 = *(void **)(v19 - 64);
  if (v21)
  {
    *(void *)(v19 - 56) = v21;
    operator delete(v21);
  }
  MEMORY[0x1C185D370](v17, 0x10B0C40F5E5D8C6);
  _Unwind_Resume(a1);
}

vDSP_biquad_Setup AUSpatialMixerV2DynamicXTCFilter::setLR8Crossover(AUSpatialMixerV2DynamicXTCFilter *this, float a2)
{
  uint64_t v4 = 0;
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  do
  {
    float v5 = (void *)((char *)&v42 + v4);
    void *v5 = 0;
    v5[1] = 0;
    v5[3] = 0;
    v5[4] = 0;
    v4 += 40;
    void v5[2] = 0x3FF0000000000000;
  }
  while (v4 != 80);
  double v6 = a2;
  if (a2 <= 0.0)
  {
    double v42 = 0.0;
    double v43 = 0.0;
    double v44 = 1.0;
    double v45 = 0.0;
    double v46 = 0.0;
    double v47 = 0.0;
    double v50 = 0.0;
    double v51 = 0.0;
    double v15 = 1.0;
    double v48 = 0.0;
  }
  else
  {
    __double2 v7 = __sincos_stret(fmin(v6, 3.11017673));
    double v8 = __exp10(0.0);
    double v9 = 0.5 - v7.__cosval * 0.5;
    double v10 = 1.0 / (v7.__sinval * 0.923879533 + 1.0);
    double v11 = v10 * v8;
    double v42 = v7.__cosval * -2.0 * v10;
    double v43 = v10 - v7.__sinval * 0.923879533 * v10;
    double v45 = (v9 + v9) * v11;
    double v46 = v9 * v11;
    double v44 = v9 * v11;
    double v12 = __exp10(0.0);
    double v13 = 1.0 / (v7.__sinval * 0.382683434 + 1.0);
    double v14 = v13 * v12;
    double v47 = v7.__cosval * -2.0 * v13;
    double v48 = v13 - v7.__sinval * 0.382683434 * v13;
    double v15 = v9 * (v13 * v12);
    double v50 = (v9 + v9) * v14;
    double v51 = v15;
  }
  uint64_t v16 = 0;
  double v49 = v15;
  uint64_t v17 = v41;
  do
  {
    uint64_t v18 = &v42 + 5 * (v16 & 1);
    long long v19 = *(_OWORD *)v18;
    *(_OWORD *)((char *)v17 - 24) = *((_OWORD *)v18 + 1);
    *((double *)v17 - 1) = v18[4];
    *uint64_t v17 = v19;
    uint64_t v17 = (_OWORD *)((char *)v17 + 40);
    ++v16;
  }
  while (v16 != 4);
  vDSP_biquad_Setup Setup = vDSP_biquad_CreateSetup(__Coefficients, 4uLL);
  if (a2 <= 0.0)
  {
    double v42 = 0.0;
    double v43 = 0.0;
    double v44 = 1.0;
    double v45 = 0.0;
    double v47 = 0.0;
    double v48 = 0.0;
    double v50 = 0.0;
    double v51 = 0.0;
    double v29 = 1.0;
    double v46 = 0.0;
  }
  else
  {
    __double2 v21 = __sincos_stret(fmin(v6, 3.11017673));
    double v22 = __exp10(0.0);
    double v23 = v21.__cosval * 0.5 + 0.5;
    double v24 = 1.0 / (v21.__sinval * 0.923879533 + 1.0);
    double v25 = v24 * v22;
    double v42 = v21.__cosval * -2.0 * v24;
    double v43 = v24 - v21.__sinval * 0.923879533 * v24;
    double v45 = v23 * -2.0 * v25;
    double v46 = v23 * v25;
    double v44 = v23 * v25;
    double v26 = __exp10(0.0);
    double v27 = 1.0 / (v21.__sinval * 0.382683434 + 1.0);
    double v28 = v27 * v26;
    double v47 = v21.__cosval * -2.0 * v27;
    double v48 = v27 - v21.__sinval * 0.382683434 * v27;
    double v29 = v23 * (v27 * v26);
    double v50 = v23 * -2.0 * v28;
    double v51 = v29;
  }
  uint64_t v30 = 0;
  double v49 = v29;
  AudioFormatFlags v31 = v41;
  do
  {
    int v32 = &v42 + 5 * (v30 & 1);
    long long v33 = *(_OWORD *)v32;
    *(_OWORD *)((char *)v31 - 24) = *((_OWORD *)v32 + 1);
    *((double *)v31 - 1) = v32[4];
    *AudioFormatFlags v31 = v33;
    AudioFormatFlags v31 = (_OWORD *)((char *)v31 + 40);
    ++v30;
  }
  while (v30 != 4);
  vDSP_biquad_Setup result = vDSP_biquad_CreateSetup(__Coefficients, 4uLL);
  uint64_t v35 = *((void *)this + 120);
  *((void *)this + 120) = Setup;
  long long v36 = (uint64_t (*)(uint64_t))*((void *)this + 121);
  uint64_t v37 = MEMORY[0x1E4F16850];
  *((void *)this + 121) = MEMORY[0x1E4F16850];
  uint64_t v38 = *((void *)this + 118);
  *((void *)this + 118) = result;
  uint64_t v39 = (uint64_t (*)(uint64_t))*((void *)this + 119);
  *((void *)this + 119) = v37;
  if (v38) {
    vDSP_biquad_Setup result = (vDSP_biquad_Setup)v39(v38);
  }
  if (v35) {
    return (vDSP_biquad_Setup)v36(v35);
  }
  return result;
}

void sub_1BB3A92B8(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void MoorePenrose::~MoorePenrose(MoorePenrose *this)
{
  uint64_t v2 = (void *)*((void *)this + 65);
  if (v2)
  {
    *((void *)this + 66) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 60);
  if (v3)
  {
    *((void *)this + 61) = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 55);
  if (v4)
  {
    *((void *)this + 56) = v4;
    operator delete(v4);
  }
  float v5 = (void *)*((void *)this + 52);
  if (v5)
  {
    *((void *)this + 53) = v5;
    operator delete(v5);
  }
  double v6 = (void *)*((void *)this + 49);
  if (v6)
  {
    *((void *)this + 50) = v6;
    operator delete(v6);
  }
  __double2 v7 = (void *)*((void *)this + 46);
  if (v7)
  {
    *((void *)this + 47) = v7;
    operator delete(v7);
  }
  double v8 = (void *)*((void *)this + 43);
  if (v8)
  {
    *((void *)this + 44) = v8;
    operator delete(v8);
  }
  double v9 = (void *)*((void *)this + 40);
  if (v9)
  {
    *((void *)this + 41) = v9;
    operator delete(v9);
  }
  double v10 = (void *)*((void *)this + 37);
  if (v10)
  {
    *((void *)this + 38) = v10;
    operator delete(v10);
  }
  double v11 = (void *)*((void *)this + 32);
  if (v11)
  {
    *((void *)this + 33) = v11;
    operator delete(v11);
  }
  double v12 = (void *)*((void *)this + 27);
  if (v12)
  {
    *((void *)this + 28) = v12;
    operator delete(v12);
  }
  double v13 = (void *)*((void *)this + 22);
  if (v13)
  {
    *((void *)this + 23) = v13;
    operator delete(v13);
  }
  double v14 = (void *)*((void *)this + 17);
  if (v14)
  {
    *((void *)this + 18) = v14;
    operator delete(v14);
  }
  double v15 = (void *)*((void *)this + 12);
  if (v15)
  {
    *((void *)this + 13) = v15;
    operator delete(v15);
  }
  uint64_t v16 = (void *)*((void *)this + 7);
  if (v16)
  {
    *((void *)this + 8) = v16;
    operator delete(v16);
  }
  uint64_t v17 = (void *)*((void *)this + 2);
  if (v17)
  {
    *((void *)this + 3) = v17;
    operator delete(v17);
  }
}

void std::vector<IR::IRCoordinateTree>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  float v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    float v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = (uint64_t)v4 - 24;
      do
      {
        uint64_t v9 = v6;
        std::vector<IR::IRCoordinateTree>::__destroy_vector::operator()[abi:ne180100](&v9);
        __double2 v7 = *(void **)(v6 - 24);
        if (v7)
        {
          *(void *)(v6 - 16) = v7;
          operator delete(v7);
        }
        double v8 = (void *)(v6 - 32);
        v6 -= 56;
      }
      while (v8 != v2);
      float v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::vector<std::vector<float>>::push_back[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  __double2 v7 = *(void **)(result - 8);
  if ((unint64_t)v7 >= v6)
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - *a1) >> 3);
    unint64_t v10 = v9 + 1;
    if (v9 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v11 > v10) {
      unint64_t v10 = 2 * v11;
    }
    if (v11 >= 0x555555555555555) {
      unint64_t v12 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v12 = v10;
    }
    v16[4] = result;
    double v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::__fs::filesystem::path>>(result, v12);
    double v14 = &v13[24 * v9];
    v16[0] = v13;
    v16[1] = v14;
    v16[3] = &v13[24 * v15];
    *((void *)v14 + 1) = 0;
    *((void *)v14 + 2) = 0;
    *(void *)double v14 = 0;
    *(_OWORD *)double v14 = *(_OWORD *)a2;
    *((void *)v14 + 2) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    v16[2] = v14 + 24;
    std::vector<std::vector<float>>::__swap_out_circular_buffer(a1, v16);
    double v8 = (void *)a1[1];
    uint64_t result = std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)v16);
  }
  else
  {
    *__double2 v7 = 0;
    v7[1] = 0;
    void v7[2] = 0;
    *(_OWORD *)__double2 v7 = *(_OWORD *)a2;
    void v7[2] = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    double v8 = v7 + 3;
    a1[1] = (uint64_t)(v7 + 3);
  }
  a1[1] = (uint64_t)v8;
  return result;
}

void sub_1BB3A95EC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void AUSpatialMixerV2DynamicXTCFilter::updateFilters(AUSpatialMixerV2DynamicXTCFilter *this)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (*((_DWORD *)this + 5) < 2u)
  {
    if (getAUSMV2Log(void)::onceToken != -1) {
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
    }
    unint64_t v6 = getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR))
    {
      std::string::basic_string[abi:ne180100]<0>(&v12, "AUSpatialMixerV2DynamicXTCFilter");
      __double2 v7 = std::string::append(&v12, "::", 2uLL);
      long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
      v13.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v13.__r_.__value_.__l.__data_ = v8;
      v7->__r_.__value_.__l.__size_ = 0;
      v7->__r_.__value_.__r.__words[2] = 0;
      v7->__r_.__value_.__r.__words[0] = 0;
      unint64_t v9 = std::string::append(&v13, "updateFilters", 0xDuLL);
      long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
      int64_t v15 = v9->__r_.__value_.__r.__words[2];
      long long v14 = v10;
      v9->__r_.__value_.__l.__size_ = 0;
      v9->__r_.__value_.__r.__words[2] = 0;
      v9->__r_.__value_.__r.__words[0] = 0;
      unint64_t v11 = &v14;
      if (v15 < 0) {
        unint64_t v11 = (long long *)v14;
      }
      int buf = 136315138;
      *(void *)buf_4 = v11;
      _os_log_error_impl(&dword_1BB0CE000, v6, OS_LOG_TYPE_ERROR, "%s: Filters can not be generated if the number of drivers is < 2", (uint8_t *)&buf, 0xCu);
      if (SHIBYTE(v15) < 0) {
        operator delete((void *)v14);
      }
      if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v13.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v12.__r_.__value_.__l.__data_);
      }
    }
  }
  else if (*((float *)this + 1) != 0.0 || !*((void *)this + 103))
  {
    std::vector<std::vector<float>>::resize((uint64_t *)this + 100, 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)this + 106) - *((void *)this + 105)) >> 3));
    if (*((void *)this + 106) != *((void *)this + 105))
    {
      uint64_t v2 = 0;
      unint64_t v3 = (*((_DWORD *)this + 5) * *((_DWORD *)this + 13));
      unsigned int v4 = 1;
      do
      {
        std::vector<float>::resize(*((void *)this + 100) + 24 * v2, v3);
        uint64_t v2 = v4;
      }
      while (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)this + 106) - *((void *)this + 105)) >> 3) > v4++);
    }
    AUSpatialMixerV2DynamicXTCFilter::updateSpeakerLocations((uint64_t)this);
    AUSpatialMixerV2DynamicXTCFilter::createDynamicFilters(this);
  }
}

void sub_1BB3A9C14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (a40 < 0) {
    operator delete(__p);
  }
  if (a34 < 0) {
    operator delete(a29);
  }
  double v42 = *(std::__shared_weak_count **)(v40 - 136);
  if (v42) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v42);
  }
  applesauce::CF::URLRef::~URLRef((const void **)(v40 - 120));
  _Unwind_Resume(a1);
}

void AUSpatialMixerV2DynamicXTCFilter::createDynamicFilters(AUSpatialMixerV2DynamicXTCFilter *this)
{
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  int v2 = *((_DWORD *)this + 5);
  std::vector<float>::vector(__p, 0x100uLL);
  std::vector<std::vector<float>>::vector(v63, (2 * v2), (uint64_t)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  IR::IRData::getFilterLength(*((IR::IRData **)this + 96));
  IR::IRCoordinates::IRCoordinates((IR::IRCoordinates *)__p);
  std::vector<float>::vector(v47, 2uLL);
  std::vector<float>::vector(&v64, 0x100uLL);
  std::vector<std::vector<float>>::vector(&v68, 2uLL, (uint64_t)&v64);
  if (v64.realp)
  {
    v64.imagp = v64.realp;
    operator delete(v64.realp);
  }
  if (*((_DWORD *)this + 5))
  {
    if (!*((void *)this + 98)) {
      IR::IRCoordinates::set();
    }
    IR::IRCoordinates::set();
    IR::IRCoordinates::set();
    IR::IRData::getInterpolatedTimeDomainCoeffs<std::vector<float>>();
  }
  v64.realp = (float *)&v68;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v64);
  if (v47[0])
  {
    v47[1] = v47[0];
    operator delete(v47[0]);
  }
  LODWORD(v3) = *((_DWORD *)this + 13);
  long double v4 = log2((double)v3);
  fftsetup = vDSP_create_fftsetup((unint64_t)v4, 0);
  uint64_t v62 = fftsetup;
  unint64_t v5 = *((unsigned int *)this + 13);
  int v7 = *((_DWORD *)this + 3);
  int v6 = *((_DWORD *)this + 4);
  std::vector<float>::vector(__p, 0x100uLL);
  std::vector<std::vector<float>>::vector(v61, 2uLL, (uint64_t)__p);
  v40[3] = v5 >> 1;
  unint64_t v8 = (v5 >> 1) + 1;
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  int v9 = *((_DWORD *)this + 5);
  unint64_t v10 = (2 * v8);
  std::vector<float>::vector(__p, v10);
  std::vector<std::vector<float>>::vector(v60, (2 * v9), (uint64_t)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  std::vector<float>::vector(__p, (2 * v8));
  std::vector<std::vector<float>>::vector(v59, 2uLL, (uint64_t)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  unint64_t v11 = *((unsigned int *)this + 5);
  std::vector<float>::vector(__p, (2 * v8));
  std::vector<std::vector<float>>::vector(v58, v11, (uint64_t)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  std::vector<float>::vector(__p, (2 * v8));
  std::vector<std::vector<float>>::vector(v57, 2uLL, (uint64_t)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  std::vector<float>::vector(__p, v8);
  std::vector<std::vector<float>>::vector(v56, 0xB4uLL, (uint64_t)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  std::string v12 = std::vector<float>::vector(v55, (2 * v8));
  v40[1] = v40;
  MEMORY[0x1F4188790](v12);
  long long v14 = (const DSPSplitComplex *)&v40[-2 * v13];
  MEMORY[0x1F4188790](v15);
  v40[4] = &v40[-2 * v17];
  if ((v17 & 0x7FFFFFFF) != 0)
  {
    int v18 = v7;
    int v19 = v6;
    uint64_t v20 = 0;
    unint64_t v21 = 0;
    double v22 = (DSPSplitComplex *)v14;
    do
    {
      double v23 = *(float **)(v60[0] + v20);
      v22->realp = v23;
      v22->imagp = &v23[v8];
      AUSpatialMixerV2DynamicXTCFilter::getFFT(*(const DSPComplex **)(v63[0] + v20), v22, (DSPSplitComplex *)*((unsigned int *)this + 13), &v62, v16);
      ++v21;
      LODWORD(v17) = *((_DWORD *)this + 5);
      v20 += 24;
      ++v22;
    }
    while (v21 < (2 * v17));
    int v6 = v19;
    int v7 = v18;
  }
  memset(v54, 0, sizeof(v54));
  vDSP_Length v42 = v8;
  if (v17 == 2 && !AUSpatialMixerV2DynamicXTCFilter::readAUXTCFilter((uint64_t)this, v54))
  {
    int v45 = v7;
    int v46 = v6;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    *(_OWORD *)int __p = 0u;
    long long v49 = 0u;
    memset(v47, 0, sizeof(v47));
    do
    {
      std::vector<float>::resize((uint64_t)&__p[v25], v10);
      std::vector<float>::resize((uint64_t)&v47[v25], v10);
      double v26 = __p[v25];
      double v27 = (float **)((char *)&v68.realp + v24);
      vDSP_Length v28 = (vDSP_Length)v26 + 4 * v42;
      void *v27 = v26;
      v27[1] = v28;
      AUSpatialMixerV2DynamicXTCFilter::getFFT(*(const DSPComplex **)(v54[0] + v25 * 8), (DSPSplitComplex *)((char *)&v68 + v24), (DSPSplitComplex *)*((unsigned int *)this + 13), &v62, v29);
      uint64_t v30 = v47[v25];
      AudioFormatFlags v31 = (float **)((char *)&v64.realp + v24);
      vDSP_Length v32 = (vDSP_Length)v30 + 4 * v42;
      *AudioFormatFlags v31 = v30;
      v31[1] = v32;
      v25 += 3;
      v24 += 16;
    }
    while (v25 != 12);
    uint64_t v44 = (2 * v8);
    vDSP_Length v33 = v42;
    vDSP_zvmul(v14, 1, &v68, 1, &v64, 1, v42, 1);
    vDSP_zvma(v14 + 2, 1, &v70, 1, &v64, 1, &v64, 1, v33);
    vDSP_zvmul(v14 + 1, 1, &v68, 1, &v65, 1, v33, 1);
    double v43 = v14 + 3;
    vDSP_zvma(v14 + 3, 1, &v70, 1, &v65, 1, &v65, 1, v33);
    vDSP_zvmul(v14, 1, &v69, 1, &v66, 1, v33, 1);
    vDSP_zvma(v14 + 2, 1, &v71, 1, &v66, 1, &v66, 1, v33);
    vDSP_zvmul(v14 + 1, 1, &v69, 1, &v67, 1, v33, 1);
    vDSP_zvma(v43, 1, &v71, 1, &v67, 1, &v67, 1, v33);
    uint64_t v34 = 0;
    uint64_t v35 = v44;
    do
    {
      if (v35) {
        memmove(*(void **)(v60[0] + v34 * 8), v47[v34], 4 * v35);
      }
      v34 += 3;
    }
    while (v34 != 12);
    uint64_t v36 = 0;
    *((unsigned char *)this + 57) = 1;
    do
    {
      uint64_t v37 = v47[v36 + 9];
      if (v37)
      {
        v47[v36 + 10] = v37;
        operator delete(v37);
      }
      v36 -= 3;
    }
    while (v36 != -12);
    for (uint64_t i = 0; i != -12; i -= 3)
    {
      uint64_t v39 = *(void **)((char *)&v52 + i * 8 + 8);
      if (v39)
      {
        v54[i - 2] = (uint64_t)v39;
        operator delete(v39);
      }
    }
  }
  else
  {
    *((unsigned char *)this + 57) = 0;
  }
  AUSpatialMixerV2DynamicXTCFilter::getTargetFIR((uint64_t)this);
}

void sub_1BB3AAF58(_Unwind_Exception *a1)
{
  unint64_t v3 = *(void **)(v1 + 680);
  if (v3)
  {
    *(void *)(v1 + 688) = v3;
    operator delete(v3);
  }
  long double v4 = *(void **)(v1 + 176);
  if (v4)
  {
    *(void *)(v1 + 184) = v4;
    operator delete(v4);
  }
  unint64_t v5 = *(void **)(v1 + 272);
  if (v5)
  {
    *(void *)(v1 + 280) = v5;
    operator delete(v5);
  }
  *(void *)(v1 + 256) = v1 + 352;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v1 + 256));
  int v6 = *(void **)(v1 + 376);
  if (v6)
  {
    *(void *)(v1 + 384) = v6;
    operator delete(v6);
  }
  *(void *)(v1 + 256) = v1 + 400;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v1 + 256));
  *(void *)(v1 + 256) = v1 + 424;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v1 + 256));
  *(void *)(v1 + 256) = v1 + 448;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v1 + 256));
  *(void *)(v1 + 256) = v1 + 472;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v1 + 256));
  *(void *)(v1 + 256) = v1 + 496;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v1 + 256));
  *(void *)(v1 + 256) = v1 + 520;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v1 + 256));
  *(void *)(v1 + 664) = v1 + 552;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v1 + 664));
  _Unwind_Resume(a1);
}

float AUSpatialMixerV2DynamicXTCFilter::getFFT(const DSPComplex *this, DSPSplitComplex *__Z, DSPSplitComplex *a3, OpaqueFFTSetup **a4, OpaqueFFTSetup **a5)
{
  int v6 = (int)a3;
  if ((int)a3 >= 0) {
    int v8 = (int)a3;
  }
  else {
    int v8 = a3 + 1;
  }
  int v9 = v8 >> 1;
  vDSP_ctoz(this, 2, __Z, 1, (uint64_t)v8 >> 1);
  unint64_t v10 = *a4;
  long double v11 = log2((double)v6);
  vDSP_fft_zrip(v10, __Z, 1, (unint64_t)v11, 1);
  imagp = __Z->imagp;
  float result = *imagp;
  __Z->realp[v9] = *imagp;
  imagp[v9] = 0.0;
  float *imagp = 0.0;
  return result;
}

uint64_t AUSpatialMixerV2DynamicXTCFilter::readAUXTCFilter(uint64_t a1, uint64_t *a2)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  if (*(char *)(a1 + 1007) >= 0) {
    size_t v4 = *(unsigned __int8 *)(a1 + 1007);
  }
  else {
    size_t v4 = *(void *)(a1 + 992);
  }
  unint64_t v5 = v57;
  std::string::basic_string[abi:ne180100]((uint64_t)v57, v4 + 16);
  if ((v58 & 0x80u) != 0) {
    unint64_t v5 = (void **)v57[0];
  }
  if (v4)
  {
    if (*(char *)(a1 + 1007) >= 0) {
      int v6 = (const void *)(a1 + 984);
    }
    else {
      int v6 = *(const void **)(a1 + 984);
    }
    memmove(v5, v6, v4);
  }
  strcpy((char *)v5 + v4, "AUXTC_Tuning.wav");
  if ((v58 & 0x80u) == 0) {
    int v7 = (const UInt8 *)v57;
  }
  else {
    int v7 = (const UInt8 *)v57[0];
  }
  if ((v58 & 0x80u) == 0) {
    CFIndex v8 = v58;
  }
  else {
    CFIndex v8 = (CFIndex)v57[1];
  }
  CFURLRef v9 = CFURLCreateWithBytes(0, v7, v8, 0, 0);
  CFURLRef v10 = v9;
  CFURLRef v56 = v9;
  if (!v9)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  if (!CFURLGetFileSystemRepresentation(v9, 1u, v64, 1024))
  {
    uint64_t v18 = 0;
LABEL_77:
    CFRelease(v10);
    goto LABEL_78;
  }
  *(_DWORD *)uint64_t v59 = 0;
  std::vector<float>::vector(&v47, 0x100uLL, v59);
  std::vector<std::vector<float>>::resize(a2, 4uLL, (uint64_t)&v47);
  if (v47)
  {
    double v48 = v47;
    operator delete(v47);
  }
  unsigned int v55 = 0;
  long double v11 = fopen((const char *)v64, "rb");
  float v54 = v11;
  if (!v11 || !fread(&v47, 0x24uLL, 1uLL, v11))
  {
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG))
    {
LABEL_41:
      long long v14 = v54;
      fclose(v54);
      goto LABEL_42;
    }
    *(_DWORD *)uint64_t v59 = 136315394;
    *(void *)&v59[4] = "WaveFileReader";
    *(_WORD *)&v59[12] = 2080;
    *(void *)&v59[14] = v64;
    uint64_t v16 = MEMORY[0x1E4F14500];
    uint64_t v17 = "%s: Invalid wave file path: %s";
LABEL_82:
    _os_log_debug_impl(&dword_1BB0CE000, v16, OS_LOG_TYPE_DEBUG, v17, v59, 0x16u);
    goto LABEL_41;
  }
  if (v47 != 1179011410
    || v48 != (FILE *)0x20746D6645564157
    || v49 > 0x28
    || ((1 << v49) & 0x10000050000) == 0
    || (v50 | 2) != 3
    || (unsigned int v12 = v53, v53 != 16) && v53 != 24 && (v53 != 32 || v50 != 3))
  {
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG)) {
      goto LABEL_41;
    }
    *(_DWORD *)uint64_t v59 = 136315394;
    *(void *)&v59[4] = "WaveFileReader";
    *(_WORD *)&v59[12] = 2080;
    *(void *)&v59[14] = v64;
    uint64_t v16 = MEMORY[0x1E4F14500];
    uint64_t v17 = "%s: Invalid format: %s";
    goto LABEL_82;
  }
  int v13 = 0;
  v46.__r_.__value_.__s.__data_[0] = 0;
  long long v14 = v54;
  do
  {
    if (!fread(&v46, 1uLL, 1uLL, v14)) {
      break;
    }
    HIDWORD(v15) = v46.__r_.__value_.__s.__data_[0];
    LODWORD(v15) = v13;
    int v13 = v15 >> 8;
  }
  while (v13 != 1635017060);
  *(_DWORD *)uint64_t v59 = 0;
  if (fread(v59, 4uLL, 1uLL, v14)) {
    unsigned int v55 = 8 * *(_DWORD *)v59 / v12 / v51;
  }
LABEL_42:
  unsigned int v19 = v55;
  if (!v55)
  {
    if (getAUSMV2Log(void)::onceToken != -1) {
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
    }
    uint64_t v30 = getAUSMV2Log(void)::gLog;
    if (!os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_76;
    }
    std::string::basic_string[abi:ne180100]<0>(&v45, "AUSpatialMixerV2DynamicXTCFilter");
    AudioFormatFlags v31 = std::string::append(&v45, "::", 2uLL);
    long long v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
    v46.__r_.__value_.__r.__words[2] = v31->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v46.__r_.__value_.__l.__data_ = v32;
    v31->__r_.__value_.__l.__size_ = 0;
    v31->__r_.__value_.__r.__words[2] = 0;
    v31->__r_.__value_.__r.__words[0] = 0;
    vDSP_Length v33 = std::string::append(&v46, "readAUXTCFilter", 0xFuLL);
    long long v34 = *(_OWORD *)&v33->__r_.__value_.__l.__data_;
    *(void *)&v59[16] = *((void *)&v33->__r_.__value_.__l + 2);
    *(_OWORD *)uint64_t v59 = v34;
    v33->__r_.__value_.__l.__size_ = 0;
    v33->__r_.__value_.__r.__words[2] = 0;
    v33->__r_.__value_.__r.__words[0] = 0;
    uint64_t v35 = v59;
    if (v59[23] < 0) {
      uint64_t v35 = *(unsigned char **)v59;
    }
    int v60 = 136315394;
    uint32_t v61 = v35;
    __int16 v62 = 2080;
    Float64 v63 = v64;
    _os_log_impl(&dword_1BB0CE000, v30, OS_LOG_TYPE_DEFAULT, "%s: WARNING: AUXTC file not found at %s; will proceed without it",
      (uint8_t *)&v60,
      0x16u);
    goto LABEL_67;
  }
  if (getAUSMV2Log(void)::onceToken != -1) {
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
  }
  uint64_t v20 = getAUSMV2Log(void)::gLog;
  BOOL v21 = os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEFAULT);
  if (v21)
  {
    std::string::basic_string[abi:ne180100]<0>(&v45, "AUSpatialMixerV2DynamicXTCFilter");
    double v22 = std::string::append(&v45, "::", 2uLL);
    long long v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
    v46.__r_.__value_.__r.__words[2] = v22->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v46.__r_.__value_.__l.__data_ = v23;
    v22->__r_.__value_.__l.__size_ = 0;
    v22->__r_.__value_.__r.__words[2] = 0;
    v22->__r_.__value_.__r.__words[0] = 0;
    uint64_t v24 = std::string::append(&v46, "readAUXTCFilter", 0xFuLL);
    long long v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
    *(void *)&v59[16] = *((void *)&v24->__r_.__value_.__l + 2);
    *(_OWORD *)uint64_t v59 = v25;
    v24->__r_.__value_.__l.__size_ = 0;
    v24->__r_.__value_.__r.__words[2] = 0;
    v24->__r_.__value_.__r.__words[0] = 0;
    double v26 = v59;
    if (v59[23] < 0) {
      double v26 = *(unsigned char **)v59;
    }
    int v60 = 136315394;
    uint32_t v61 = v26;
    __int16 v62 = 2080;
    Float64 v63 = v64;
    _os_log_impl(&dword_1BB0CE000, v20, OS_LOG_TYPE_DEFAULT, "%s: AUXTC file found: %s", (uint8_t *)&v60, 0x16u);
    if ((v59[23] & 0x80000000) != 0) {
      operator delete(*(void **)v59);
    }
    if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v46.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v45.__r_.__value_.__l.__data_);
    }
  }
  if (v51 != 4 || v52 != 48000 || v19 >= 0x101)
  {
    if (getAUSMV2Log(void)::onceToken != -1) {
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
    }
    uint64_t v36 = getAUSMV2Log(void)::gLog;
    if (!os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR)) {
      goto LABEL_76;
    }
    std::string::basic_string[abi:ne180100]<0>(&v45, "AUSpatialMixerV2DynamicXTCFilter");
    uint64_t v38 = std::string::append(&v45, "::", 2uLL);
    long long v39 = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
    v46.__r_.__value_.__r.__words[2] = v38->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v46.__r_.__value_.__l.__data_ = v39;
    v38->__r_.__value_.__l.__size_ = 0;
    v38->__r_.__value_.__r.__words[2] = 0;
    v38->__r_.__value_.__r.__words[0] = 0;
    uint64_t v40 = std::string::append(&v46, "readAUXTCFilter", 0xFuLL);
    long long v41 = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
    *(void *)&v59[16] = *((void *)&v40->__r_.__value_.__l + 2);
    *(_OWORD *)uint64_t v59 = v41;
    v40->__r_.__value_.__l.__size_ = 0;
    v40->__r_.__value_.__r.__words[2] = 0;
    v40->__r_.__value_.__r.__words[0] = 0;
    vDSP_Length v42 = v59;
    if (v59[23] < 0) {
      vDSP_Length v42 = *(unsigned char **)v59;
    }
    int v60 = 136315394;
    uint32_t v61 = v42;
    __int16 v62 = 2080;
    Float64 v63 = v64;
    _os_log_error_impl(&dword_1BB0CE000, v36, OS_LOG_TYPE_ERROR, "%s: WARNING: AUXTC file found at %s but is invalid; will proceed without it",
      (uint8_t *)&v60,
      0x16u);
LABEL_67:
    if ((v59[23] & 0x80000000) != 0) {
      operator delete(*(void **)v59);
    }
    if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v46.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v45.__r_.__value_.__l.__data_);
    }
LABEL_76:
    fclose(v14);
    uint64_t v18 = 4294956425;
    goto LABEL_77;
  }
  MEMORY[0x1F4188790](v21);
  uint64_t v27 = 0;
  unint64_t v28 = 0;
  memset(v44, 0, 32);
  uint64_t v29 = *a2;
  do
  {
    *(_DWORD *)uint64_t v59 = 0;
    std::vector<float>::assign((char **)(v29 + v27), 0x100uLL, v59);
    uint64_t v29 = *a2;
    v44[v28++] = *(float **)(*a2 + v27);
    v27 += 24;
  }
  while (v28 < v51);
  WaveFileReader::read(&v47, v44, v51, v55);
  CFURLRef v10 = v56;
  fclose(v54);
  uint64_t v18 = 0;
  if (v10) {
    goto LABEL_77;
  }
LABEL_78:
  if ((char)v58 < 0) {
    operator delete(v57[0]);
  }
  return v18;
}

void sub_1BB3ABAA8(_Unwind_Exception *a1)
{
  if (*(char *)(v1 + 55) < 0) {
    operator delete(*(void **)(v1 + 32));
  }
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*(void **)(v1 + 8));
  }
  fclose(*(FILE **)(v1 + 96));
  applesauce::CF::URLRef::~URLRef((const void **)(v1 + 112));
  if (*(char *)(v1 + 143) < 0) {
    operator delete(*(void **)(v1 + 120));
  }
  _Unwind_Resume(a1);
}

void AUSpatialMixerV2DynamicXTCFilter::getTargetFIR(uint64_t a1)
{
  int NumFiltersPerSpatialPoint = IR::IRData::getNumFiltersPerSpatialPoint(*(IR::IRData **)(a1 + 768));
  IR::IRCoordinates::IRCoordinates((IR::IRCoordinates *)v3);
  std::vector<float>::vector(&__p, NumFiltersPerSpatialPoint);
  IR::IRCoordinates::set();
  IR::IRCoordinates::set();
  IR::IRCoordinates::set();
  IR::IRData::getInterpolatedTimeDomainCoeffs<std::vector<float>>();
}

void sub_1BB3ABDC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void AUSpatialMixerV2DynamicXTCFilter::frequencySmooth(AUSpatialMixerV2DynamicXTCFilter *this, float *a2, float *a3, float a4, float a5)
{
  unsigned int v7 = a3;
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  int v36 = (int)a3;
  vDSP_Length v10 = a3;
  MEMORY[0x1F4188790](this);
  unsigned int v12 = (float *)((char *)&v31 - v11);
  float __B = 1.0;
  vDSP_vdbcon(v13, 1, &__B, v13, 1, v10, 1u);
  float v35 = a5 / 100.0;
  if ((float)(a5 / 100.0) != 1.0) {
    vDSP_vsmul((const float *)this, 1, &v35, (float *)this, 1, v10);
  }
  if (v7)
  {
    unint64_t v16 = 0;
    float32x2_t v17 = (float32x2_t)vdup_n_s32(0x473B8000u);
    int64x2_t v18 = vdupq_n_s64(2uLL);
    long long v31 = xmmword_1BB872720;
    int64x2_t v32 = v18;
    do
    {
      *(float *)v14.i32 = (float)(int)v7 + (float)(int)v7;
      *(float *)v15.i32 = (float)((float)((float)v16 + 0.5) / *(float *)v14.i32) * 48000.0;
      if (*(float *)v15.i32 <= a4)
      {
        unint64_t v19 = 0;
        if (v7 <= 1) {
          uint64_t v20 = 1;
        }
        else {
          uint64_t v20 = v7;
        }
        uint64x2_t v21 = (uint64x2_t)vdupq_n_s64(v20 - 1);
        float v22 = (float)((float)(*(float *)v15.i32 / 3.0) / 3.1416)
            * (float)((float)((float)(*(float *)v15.i32 / 3.0) / 3.1416)
                    + (float)((float)(*(float *)v15.i32 / 3.0) / 3.1416));
        float32x2_t v23 = (float32x2_t)vdup_lane_s32(v14, 0);
        float32x2_t v24 = (float32x2_t)vdup_lane_s32(v15, 0);
        uint64_t v25 = (4 * v20 + 4) & 0x7FFFFFFF8;
        int64x2_t v26 = (int64x2_t)v31;
        int32x2_t v27 = (int32x2_t)0x100000000;
        do
        {
          int32x2_t v28 = vmovn_s64((int64x2_t)vcgeq_u64(v21, (uint64x2_t)v26));
          float32x2_t v29 = vsub_f32(vmul_f32(vdiv_f32(vadd_f32(vcvt_f32_u32((uint32x2_t)v27), (float32x2_t)0x3F0000003F000000), v23), v17), v24);
          if (v28.i8[0]) {
            v12[v19 / 4] = (float)((float)-v29.f32[0] * v29.f32[0]) / v22;
          }
          if (v28.i8[4]) {
            v12[v19 / 4 + 1] = vmuls_lane_f32(-v29.f32[1], v29, 1) / v22;
          }
          int64x2_t v26 = vaddq_s64(v26, v18);
          int32x2_t v27 = vadd_s32(v27, (int32x2_t)0x200000002);
          v19 += 8;
        }
        while (v25 != v19);
        vvexpf(v12, v12, &v36);
        float __C = 0.0;
        vDSP_sve(v12, 1, &__C, v36);
        vDSP_vsdiv(v12, 1, &__C, v12, 1, v36);
        vDSP_vmul(v12, 1, (const float *)this, 1, v12, 1, v36);
        vDSP_sve(v12, 1, &__C, v36);
        float v30 = __exp10f(__C / 20.0);
        int64x2_t v18 = v32;
        a2[v16] = v30;
        unsigned int v7 = v36;
      }
      else
      {
        a2[v16] = 1.0;
      }
      ++v16;
    }
    while (v16 < v7);
  }
  a2[v7] = a2[v7 - 1];
}

void AUSpatialMixerV2DynamicXTCFilter::applyCrossover(AUSpatialMixerV2DynamicXTCFilter *this)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  if (*((_DWORD *)this + 5) < 2u)
  {
    if (getAUSMV2Log(void)::onceToken != -1) {
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
    }
    uint64_t v25 = getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR))
    {
      int64x2_t v26 = (std::string *)std::string::basic_string[abi:ne180100]<0>(v33, "AUSpatialMixerV2DynamicXTCFilter");
      int32x2_t v27 = std::string::append(v26, "::", 2uLL);
      long long v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
      v35.__r_.__value_.__r.__words[2] = v27->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v35.__r_.__value_.__l.__data_ = v28;
      v27->__r_.__value_.__l.__size_ = 0;
      v27->__r_.__value_.__r.__words[2] = 0;
      v27->__r_.__value_.__r.__words[0] = 0;
      float32x2_t v29 = std::string::append(&v35, "applyCrossover", 0xEuLL);
      long long v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
      int64_t v37 = v29->__r_.__value_.__r.__words[2];
      long long v36 = v30;
      v29->__r_.__value_.__l.__size_ = 0;
      v29->__r_.__value_.__r.__words[2] = 0;
      v29->__r_.__value_.__r.__words[0] = 0;
      long long v31 = &v36;
      if (v37 < 0) {
        long long v31 = (long long *)v36;
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v31;
      _os_log_error_impl(&dword_1BB0CE000, v25, OS_LOG_TYPE_ERROR, "%s: Crossover can not be applied if the number of drivers is < 2", (uint8_t *)&buf, 0xCu);
      if (SHIBYTE(v37) < 0) {
        operator delete((void *)v36);
      }
      if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v35.__r_.__value_.__l.__data_);
      }
      if (v34 < 0) {
        operator delete(v33[0]);
      }
    }
  }
  else
  {
    float __B = __exp10f(*((float *)this + 8) / 20.0);
    MEMORY[0x1F4188790](v2);
    size_t v4 = (float *)((char *)&v33[-1] - ((v3 + 15) & 0x7FFFFFFF0));
    unint64_t v5 = *((unsigned int *)this + 13);
    LODWORD(v35.__r_.__value_.__l.__data_) = 0;
    std::vector<float>::vector(&v36, v5, &v35);
    std::vector<float>::vector(&v35, *((unsigned int *)this + 13));
    LODWORD(buf) = 0;
    std::vector<float>::vector(v33, 0xAuLL, &buf);
    HIDWORD(v32) = 0;
    std::vector<float>::vector(&buf, 0xAuLL, (_DWORD *)&v32 + 1);
    uint64_t v6 = *((void *)this + 105);
    if (*((void *)this + 106) != v6)
    {
      uint64_t v7 = 0;
      unsigned int v8 = 0;
      do
      {
        CFURLRef v9 = *(float **)(v6 + 24 * v7);
        double v10 = v9[1] * 0.0174532925;
        __double2 v11 = __sincos_stret(*v9 * 0.0174532925);
        __double2 v12 = __sincos_stret(v10);
        *(float *)&unsigned int v13 = v11.__cosval * v12.__cosval;
        *(float *)&unsigned int v14 = v11.__cosval * v12.__sinval;
        unint64_t v40 = __PAIR64__(v14, v13);
        float sinval = v11.__sinval;
        float v41 = sinval;
        VBAP::calculateVBAPGains(*((VBAP **)this + 122), (float32x2_t *)&v40, v4);
        LODWORD(v16) = *((_DWORD *)this + 5);
        if (v16)
        {
          unint64_t v17 = 0;
          do
          {
            vDSP_Length v18 = *((unsigned int *)this + 13);
            unint64_t v19 = (float *)(*(void *)(*((void *)this + 100) + 24 * v7) + 4 * (v18 * v17));
            vDSP_biquad(*((const vDSP_biquad_SetupStruct **)this + 120), (float *)buf, v19, 1, v19, 1, v18);
            BOOL v20 = v17;
            if (*((void *)this + 98))
            {
              if (*((void *)this + 115) == *((void *)this + 114)) {
                BOOL v20 = v17 & 1;
              }
              else {
                BOOL v20 = *(float *)(*((void *)this + 108) + 4 * v17) >= 0.0;
              }
            }
            vDSP_Length v21 = *((unsigned int *)this + 13);
            float v22 = (const float *)v36;
            *(float *)(v36 + (v21 & 0xFFFFFFFC)) = v4[v20];
            vDSP_biquad(*((const vDSP_biquad_SetupStruct **)this + 118), (float *)v33[0], v22, 1, (float *)v35.__r_.__value_.__l.__data_, 1, v21);
            vDSP_Length v23 = *((unsigned int *)this + 13);
            float32x2_t v24 = (float *)(*(void *)(*((void *)this + 100) + 24 * v7) + 4 * (v23 * v17));
            vDSP_vadd((const float *)v35.__r_.__value_.__l.__data_, 1, v24, 1, v24, 1, v23);
            vDSP_vclr((float *)v33[0], 1, 0xAuLL);
            vDSP_vclr((float *)buf, 1, 0xAuLL);
            ++v17;
            unint64_t v16 = *((unsigned int *)this + 5);
          }
          while (v17 < v16);
        }
        vDSP_vsmul(*(const float **)(*((void *)this + 100) + 24 * v7), 1, &__B, *(float **)(*((void *)this + 100) + 24 * v7), 1, (*((_DWORD *)this + 13) * v16));
        uint64_t v6 = *((void *)this + 105);
        uint64_t v7 = ++v8;
      }
      while (0xAAAAAAAAAAAAAAABLL * ((*((void *)this + 106) - v6) >> 3) > v8);
    }
    if ((void)buf)
    {
      *((void *)&buf + 1) = buf;
      operator delete((void *)buf);
    }
    if (v33[0])
    {
      v33[1] = v33[0];
      operator delete(v33[0]);
    }
    if (v35.__r_.__value_.__r.__words[0])
    {
      v35.__r_.__value_.__l.__size_ = v35.__r_.__value_.__r.__words[0];
      operator delete(v35.__r_.__value_.__l.__data_);
    }
    if ((void)v36)
    {
      *((void *)&v36 + 1) = v36;
      operator delete((void *)v36);
    }
  }
}

void sub_1BB3AC52C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 - 201) < 0) {
    operator delete(*(void **)(v1 - 224));
  }
  if (*(char *)(v1 - 225) < 0) {
    operator delete(*(void **)(v1 - 248));
  }
  _Unwind_Resume(exception_object);
}

void AUSpatialMixerV2DynamicXTCFilter::analyticalInverseStereo(AUSpatialMixerV2DynamicXTCFilter *this, DSPSplitComplex *a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = this;
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  float v4 = *((float *)this + 1);
  float v5 = -*((float *)&a2->realp + 1);
  float v6 = -*(float *)&a2->imagp;
  float v7 = *((float *)this + 2);
  float v8 = *((float *)this + 3);
  float v9 = -*((float *)&a2->imagp + 1);
  float v29 = *(float *)this;
  float v30 = -*(float *)&a2->realp;
  float v10 = std::operator*[abi:ne180100]<float>(*(float *)this, v30, v8, v9);
  float v12 = v11;
  float v13 = v10 - std::operator*[abi:ne180100]<float>(v7, v6, v4, v5);
  float v15 = v12 - v14;
  if (v13 == 0.0 && v15 == 0.0)
  {
    float v16 = 0.0;
    float v17 = 1.0;
  }
  else
  {
    float v17 = std::operator/[abi:ne180100]<float>(1.0, 0.0, v13, v15);
  }
  float32x2_t v26 = (float32x2_t)__PAIR64__(LODWORD(v16), LODWORD(v17));
  float v27 = v16;
  float v28 = v17;
  v31[0] = std::operator*[abi:ne180100]<float>(v17, v16, v8, v9);
  v31[1] = v18;
  float32x2_t v19 = vneg_f32(v26);
  _OWORD v31[2] = std::operator*[abi:ne180100]<float>(v19.f32[0], v19.f32[1], v7, v6);
  v31[3] = v20;
  v31[4] = std::operator*[abi:ne180100]<float>(v19.f32[0], v19.f32[1], v4, v5);
  v31[5] = v21;
  float v22 = std::operator*[abi:ne180100]<float>(v28, v27, v29, v30);
  uint64_t v23 = 0;
  *(float *)&v31[6] = v22;
  v31[7] = v24;
  do
  {
    int v25 = v31[v23 + 1];
    *(_DWORD *)uint64_t v3 = v31[v23];
    uint64_t v3 = (AUSpatialMixerV2DynamicXTCFilter *)((char *)v3 + 4);
    LODWORD(v2->realp) = v25;
    uint64_t v2 = (DSPSplitComplex *)((char *)v2 + 4);
    v23 += 2;
  }
  while (v23 != 8);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[17],float>(applesauce::CF::TypeRef *a1, char *a2, int *a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  int valuePtr = *a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((void *)a1 + 1) = v5;
  if (!v5)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1BB3AC7E8(_Unwind_Exception *a1)
{
  uint64_t v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[15],float &>(applesauce::CF::TypeRef *a1, char *a2, int *a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  int valuePtr = *a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((void *)a1 + 1) = v5;
  if (!v5)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1BB3AC8BC(_Unwind_Exception *a1)
{
  uint64_t v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[18],float &>(applesauce::CF::TypeRef *a1, char *a2, int *a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  int valuePtr = *a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((void *)a1 + 1) = v5;
  if (!v5)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1BB3AC990(_Unwind_Exception *a1)
{
  uint64_t v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[12],float &>(applesauce::CF::TypeRef *a1, char *a2, int *a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  int valuePtr = *a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((void *)a1 + 1) = v5;
  if (!v5)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1BB3ACA64(_Unwind_Exception *a1)
{
  uint64_t v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

void AUSpatialMixerV2DynamicXTCFilter::updateParamDictionary(uint64_t a1, const void *a2)
{
  v109[2] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(const void **)(a1 + 936);
  *(void *)(a1 + 936) = a2;
  if (a2) {
    CFRetain(a2);
  }
  if (v3) {
    CFRelease(v3);
  }
  *(_DWORD *)(a1 + 4) = 0;
  CFDictionaryRef v4 = *(const __CFDictionary **)(a1 + 936);
  if (!v4) {
    return;
  }
  if (applesauce::CF::details::has_key<char const(&)[25]>(v4, "CounteractRotationShader"))
  {
    CFDictionaryRef v5 = *(const __CFDictionary **)(a1 + 936);
    if (!v5) {
      goto LABEL_155;
    }
    int v6 = *(unsigned __int8 *)(a1 + 56);
    if (v6 != applesauce::CF::details::find_at_key_or_optional<BOOL,char const(&)[25]>(v5, "CounteractRotationShader"))
    {
      CFDictionaryRef v7 = *(const __CFDictionary **)(a1 + 936);
      if (!v7) {
        goto LABEL_155;
      }
      *(unsigned char *)(a1 + 56) = applesauce::CF::details::find_at_key_or_optional<BOOL,char const(&)[25]>(v7, "CounteractRotationShader");
      *(_DWORD *)(a1 + 4) = 1065353216;
    }
  }
  CFDictionaryRef v8 = *(const __CFDictionary **)(a1 + 936);
  if (!v8) {
    goto LABEL_155;
  }
  if (!applesauce::CF::details::has_key<char const(&)[12]>(v8, "SpeakerSpan")) {
    goto LABEL_21;
  }
  CFDictionaryRef v9 = *(const __CFDictionary **)(a1 + 936);
  if (!v9)
  {
LABEL_155:
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
    goto LABEL_170;
  }
  CFNumberRef v10 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[12]>(v9, "SpeakerSpan");
  if (v10) {
    LODWORD(v10) = applesauce::CF::convert_as<float,0>(v10);
  }
  if (*(float *)(a1 + 44) != *(float *)&v10)
  {
    *(_DWORD *)(a1 + 44) = v10;
    if (*(void *)(a1 + 784))
    {
      uint64_t v11 = *(void *)(a1 + 976);
      float v85 = *(float *)&v10;
      float v12 = (float32x2_t *)operator new(8uLL);
      float32x2_t *v12 = vmul_n_f32((float32x2_t)0x3F000000BF000000, v85);
      v97.__r_.__value_.__l.__size_ = (std::string::size_type)&v12[1];
      v97.__r_.__value_.__r.__words[2] = (std::string::size_type)&v12[1];
      v97.__r_.__value_.__r.__words[0] = (std::string::size_type)v12;
      float v13 = operator new(8uLL);
      v92.__r_.__value_.__l.__size_ = (std::string::size_type)(v13 + 1);
      v92.__r_.__value_.__r.__words[2] = (std::string::size_type)(v13 + 1);
      *float v13 = 0;
      v92.__r_.__value_.__r.__words[0] = (std::string::size_type)v13;
      VBAP::changeSpeakerLocations(v11, (uint64_t *)&v97, (uint64_t *)&v92);
      operator delete(v13);
      operator delete(v12);
    }
    else
    {
      AUSpatialMixerV2DynamicXTCFilter::updateSpeakerLocations(a1);
      VBAP::changeSpeakerLocations(*(void *)(a1 + 976), (uint64_t *)(a1 + 864), (uint64_t *)(a1 + 888));
    }
    *(_DWORD *)(a1 + 4) = 1065353216;
  }
LABEL_21:
  CFDictionaryRef v14 = *(const __CFDictionary **)(a1 + 936);
  if (!v14) {
    goto LABEL_169;
  }
  if (applesauce::CF::details::has_key<char const(&)[15]>(v14, "Regularization"))
  {
    CFDictionaryRef v15 = *(const __CFDictionary **)(a1 + 936);
    if (!v15) {
      goto LABEL_169;
    }
    float v16 = *(float *)(a1 + 40);
    if (v16 != COERCE_FLOAT(applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[15]>(v15, "Regularization")))
    {
      CFDictionaryRef v17 = *(const __CFDictionary **)(a1 + 936);
      if (!v17) {
        goto LABEL_169;
      }
      *(_DWORD *)(a1 + 40) = applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[15]>(v17, "Regularization");
      *(_DWORD *)(a1 + 4) = 1065353216;
    }
  }
  CFDictionaryRef v18 = *(const __CFDictionary **)(a1 + 936);
  if (!v18) {
    goto LABEL_169;
  }
  CFStringRef v19 = CFStringCreateWithBytes(0, (const UInt8 *)"Constraint", 10, 0x8000100u, 0);
  v97.__r_.__value_.__r.__words[0] = (std::string::size_type)v19;
  if (!v19) {
    goto LABEL_146;
  }
  CFStringRef v20 = v19;
  int v21 = CFDictionaryContainsKey(v18, v19);
  CFRelease(v20);
  if (v21)
  {
    CFDictionaryRef v22 = *(const __CFDictionary **)(a1 + 936);
    if (!v22) {
      goto LABEL_169;
    }
    float v23 = *(float *)(a1 + 36);
    if (v23 != COERCE_FLOAT(applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[11]>(v22)))
    {
      CFDictionaryRef v24 = *(const __CFDictionary **)(a1 + 936);
      if (!v24) {
        goto LABEL_169;
      }
      *(_DWORD *)(a1 + 36) = applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[11]>(v24);
      *(_DWORD *)(a1 + 4) = 1065353216;
    }
  }
  CFDictionaryRef v25 = *(const __CFDictionary **)(a1 + 936);
  if (!v25)
  {
LABEL_169:
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
LABEL_170:
  }
  CFStringRef v26 = CFStringCreateWithBytes(0, (const UInt8 *)"PostTimbralFrequency", 20, 0x8000100u, 0);
  v97.__r_.__value_.__r.__words[0] = (std::string::size_type)v26;
  if (!v26)
  {
LABEL_146:
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
    goto LABEL_170;
  }
  CFStringRef v27 = v26;
  int v28 = CFDictionaryContainsKey(v25, v26);
  CFRelease(v27);
  if (v28)
  {
    CFDictionaryRef v29 = *(const __CFDictionary **)(a1 + 936);
    if (!v29) {
      goto LABEL_169;
    }
    float v30 = *(float *)(a1 + 24);
    if (v30 != COERCE_FLOAT(applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[21]>(v29)))
    {
      CFDictionaryRef v31 = *(const __CFDictionary **)(a1 + 936);
      if (!v31) {
        goto LABEL_169;
      }
      *(_DWORD *)(a1 + 24) = applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[21]>(v31);
      *(_DWORD *)(a1 + 4) = 1065353216;
    }
  }
  uint64_t v32 = *(void *)(a1 + 936);
  if (!v32) {
    goto LABEL_169;
  }
  if (applesauce::CF::details::has_key<char const(&)[17]>(v32, "PostTimbralBlend"))
  {
    CFDictionaryRef v33 = *(const __CFDictionary **)(a1 + 936);
    if (!v33) {
      goto LABEL_169;
    }
    float v34 = *(float *)(a1 + 28);
    if (v34 != COERCE_FLOAT(applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[17]>(v33, "PostTimbralBlend")))
    {
      CFDictionaryRef v35 = *(const __CFDictionary **)(a1 + 936);
      if (!v35) {
        goto LABEL_169;
      }
      *(_DWORD *)(a1 + 28) = applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[17]>(v35, "PostTimbralBlend");
      *(_DWORD *)(a1 + 4) = 1065353216;
    }
  }
  uint64_t v36 = *(void *)(a1 + 936);
  if (!v36) {
    goto LABEL_169;
  }
  if (applesauce::CF::details::has_key<char const(&)[9]>(v36, "PostGain"))
  {
    CFDictionaryRef v37 = *(const __CFDictionary **)(a1 + 936);
    if (!v37) {
      goto LABEL_169;
    }
    float v38 = *(float *)(a1 + 32);
    if (v38 != COERCE_FLOAT(applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[9]>(v37)))
    {
      CFDictionaryRef v39 = *(const __CFDictionary **)(a1 + 936);
      if (!v39) {
        goto LABEL_169;
      }
      *(_DWORD *)(a1 + 32) = applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[9]>(v39);
      *(_DWORD *)(a1 + 4) = 1065353216;
    }
  }
  CFDictionaryRef v40 = *(const __CFDictionary **)(a1 + 936);
  if (!v40) {
    goto LABEL_169;
  }
  if (applesauce::CF::details::has_key<char const(&)[10]>(v40, "Crossover"))
  {
    CFDictionaryRef v41 = *(const __CFDictionary **)(a1 + 936);
    if (!v41) {
      goto LABEL_169;
    }
    float v42 = *(float *)(a1 + 48);
    if (v42 != COERCE_FLOAT(applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[10]>(v41)))
    {
      CFDictionaryRef v43 = *(const __CFDictionary **)(a1 + 936);
      if (!v43) {
        goto LABEL_169;
      }
      float v44 = COERCE_FLOAT(applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[10]>(v43));
      *(float *)(a1 + 48) = v44;
      float v45 = (float)((float)(v44 + v44) / *(float *)(a1 + 8)) * 3.14159265;
      AUSpatialMixerV2DynamicXTCFilter::setLR8Crossover((AUSpatialMixerV2DynamicXTCFilter *)a1, v45);
      *(_DWORD *)(a1 + 4) = 1065353216;
    }
  }
  CFDictionaryRef v46 = *(const __CFDictionary **)(a1 + 936);
  if (!v46) {
    goto LABEL_169;
  }
  if (applesauce::CF::details::has_key<char const(&)[13]>(v46, "FilterLength"))
  {
    CFDictionaryRef v47 = *(const __CFDictionary **)(a1 + 936);
    if (!v47) {
      goto LABEL_169;
    }
    int v48 = *(_DWORD *)(a1 + 52);
    if (v48 != applesauce::CF::DictionaryRef_proxy::at_as<unsigned int,char const(&)[13]>(v47))
    {
      CFDictionaryRef v49 = *(const __CFDictionary **)(a1 + 936);
      if (v49)
      {
        unsigned int v50 = applesauce::CF::DictionaryRef_proxy::at_as<unsigned int,char const(&)[13]>(v49);
        if (v50 >= 0x100) {
          int v51 = 256;
        }
        else {
          int v51 = v50;
        }
        *(_DWORD *)(a1 + 52) = v51;
        *(_DWORD *)(a1 + 4) = 1065353216;
        goto LABEL_68;
      }
      goto LABEL_169;
    }
  }
LABEL_68:
  CFDictionaryRef v52 = *(const __CFDictionary **)(a1 + 936);
  if (!v52) {
    goto LABEL_169;
  }
  if (!applesauce::CF::details::has_key<char const(&)[12]>(v52, "SaveXTCFile")) {
    return;
  }
  CFDictionaryRef v53 = *(const __CFDictionary **)(a1 + 936);
  if (!v53) {
    goto LABEL_169;
  }
  if (applesauce::CF::details::find_at_key_or_optional<BOOL,char const(&)[12]>(v53, "SaveXTCFile")
    && *(void *)(a1 + 808) != *(void *)(a1 + 800))
  {
    float v54 = (void *)(a1 + 1008);
    if (*(char *)(a1 + 1031) < 0)
    {
      CFURLRef v56 = *(const UInt8 **)(a1 + 1008);
      CFIndex v55 = *(void *)(a1 + 1016);
    }
    else
    {
      CFIndex v55 = *(unsigned __int8 *)(a1 + 1031);
      CFURLRef v56 = (const UInt8 *)(a1 + 1008);
    }
    CFURLRef v86 = CFURLCreateWithBytes(0, v56, v55, 0, 0);
    if (!v86)
    {
      double v80 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v80, "Could not construct");
    }
    *(float *)&buf.__r_.__value_.__l.__data_ = (float)*(unsigned int *)(a1 + 52) / 192000.0;
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[17],float>((applesauce::CF::TypeRef *)&v97, "XTCModelingDelay", (int *)&buf);
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[15],float &>((applesauce::CF::TypeRef *)&v97.__r_.__value_.__r.__words[2], "XTCSpeakerSpan", (int *)(a1 + 44));
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[18],float &>((applesauce::CF::TypeRef *)&v98, "XTCRegularization", (int *)(a1 + 40));
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v99, "XTCConstraint");
    LODWORD(valuePtr.__r_.__value_.__l.__data_) = *(_DWORD *)(a1 + 36);
    if (!CFNumberCreate(0, kCFNumberFloatType, &valuePtr))
    {
      float v81 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v81, "Could not construct");
    }
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v101, "XTCPostTimbralFrequency");
    LODWORD(valuePtr.__r_.__value_.__l.__data_) = *(_DWORD *)(a1 + 24);
    if (!CFNumberCreate(0, kCFNumberFloatType, &valuePtr))
    {
      uint64_t v82 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v82, "Could not construct");
    }
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v103, "XTCPostTimbralBlend");
    LODWORD(valuePtr.__r_.__value_.__l.__data_) = *(_DWORD *)(a1 + 28);
    if (!CFNumberCreate(0, kCFNumberFloatType, &valuePtr))
    {
      int v83 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v83, "Could not construct");
    }
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[12],float &>((applesauce::CF::TypeRef *)&v105, "XTCPostGain", (int *)(a1 + 32));
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v106, "XTCCrossover");
    LODWORD(valuePtr.__r_.__value_.__l.__data_) = *(_DWORD *)(a1 + 48);
    if (!CFNumberCreate(0, kCFNumberFloatType, &valuePtr))
    {
      uint64_t v84 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v84, "Could not construct");
    }
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)v108, "CounteractRotationShader");
    if (*(unsigned char *)(a1 + 56)) {
      CFStringRef v57 = (void *)MEMORY[0x1E4F1CFD0];
    }
    else {
      CFStringRef v57 = (void *)MEMORY[0x1E4F1CFC8];
    }
    v109[0] = *v57;
    v92.__r_.__value_.__r.__words[0] = (std::string::size_type)&v97;
    v92.__r_.__value_.__l.__size_ = 9;
    uint64_t v58 = 0;
    CFTypeRef CFDictionaryRef = applesauce::CF::details::make_CFDictionaryRef((uint64_t)&v92);
    do
    {
      uint64_t v59 = (const void *)v109[v58];
      if (v59) {
        CFRelease(v59);
      }
      int v60 = *(const void **)&v108[v58 * 8];
      if (v60) {
        CFRelease(v60);
      }
      v58 -= 2;
    }
    while (v58 != -18);
    std::string::basic_string[abi:ne180100]<0>(&v97, "Generated Using the AUSM - Virtual Surround Tuning Tool");
    if (*(unsigned char *)(a1 + 57)) {
      std::string::append(&v97, " - Magic Unicorn", 0x10uLL);
    }
    if (*(void *)(a1 + 784)) {
      std::string::append(&v97, " - Measured Device Reference", 0x1CuLL);
    }
    if (2 * *(_DWORD *)(a1 + 52) != (uint64_t)(*(void *)(*(void *)(a1 + 800) + 8) - **(void **)(a1 + 800)) >> 2)
    {
      if (getAUSMV2Log(void)::onceToken != -1) {
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
      }
      uint32_t v61 = getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR))
      {
        std::string::basic_string[abi:ne180100]<0>(&buf, "AUSpatialMixerV2DynamicXTCFilter");
        uint64_t v74 = std::string::append(&buf, "::", 2uLL);
        long long v75 = *(_OWORD *)&v74->__r_.__value_.__l.__data_;
        valuePtr.__r_.__value_.__r.__words[2] = v74->__r_.__value_.__r.__words[2];
        *(_OWORD *)&valuePtr.__r_.__value_.__l.__data_ = v75;
        v74->__r_.__value_.__l.__size_ = 0;
        v74->__r_.__value_.__r.__words[2] = 0;
        v74->__r_.__value_.__r.__words[0] = 0;
        unsigned int v76 = std::string::append(&valuePtr, "writeIRFile", 0xBuLL);
        long long v77 = *(_OWORD *)&v76->__r_.__value_.__l.__data_;
        v92.__r_.__value_.__r.__words[2] = v76->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v92.__r_.__value_.__l.__data_ = v77;
        v76->__r_.__value_.__l.__size_ = 0;
        v76->__r_.__value_.__r.__words[2] = 0;
        v76->__r_.__value_.__r.__words[0] = 0;
        double v78 = &v92;
        if ((v92.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          double v78 = (std::string *)v92.__r_.__value_.__r.__words[0];
        }
        LODWORD(v94) = 136315138;
        *(void *)((char *)&v94 + 4) = v78;
        _os_log_error_impl(&dword_1BB0CE000, v61, OS_LOG_TYPE_ERROR, "%s: Filter matrix size inconsistent with user-defined filter length; IR file may not render",
          (uint8_t *)&v94,
          0xCu);
        if (SHIBYTE(v92.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v92.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(valuePtr.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(valuePtr.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
      }
    }
    __int16 v62 = operator new(8uLL);
    v92.__r_.__value_.__r.__words[0] = (std::string::size_type)v62;
    void *v62 = 1;
    v92.__r_.__value_.__l.__size_ = (std::string::size_type)(v62 + 1);
    v92.__r_.__value_.__r.__words[2] = (std::string::size_type)(v62 + 1);
    memset(&valuePtr, 0, sizeof(valuePtr));
    Float64 v63 = operator new(8uLL);
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v63;
    *Float64 v63 = 0x43B4000000000000;
    buf.__r_.__value_.__l.__size_ = (std::string::size_type)(v63 + 1);
    buf.__r_.__value_.__r.__words[2] = (std::string::size_type)(v63 + 1);
    DSPSplitComplex v64 = operator new(8uLL);
    *(void *)&long long v94 = v64;
    *DSPSplitComplex v64 = 0x100000001;
    *((void *)&v94 + 1) = v64 + 1;
    unsigned int v95 = v64 + 1;
    uint64_t v65 = operator new(8uLL);
    BOOL v89 = v65 + 1;
    char v90 = v65 + 1;
    *uint64_t v65 = 0;
    cf[1] = 0;
    int __p = v65;
    IR::IRData::getTriangulationData((uint64_t *)cf, *(IR::IRData **)(a1 + 768));
    int v66 = IR::IRDataLoader::writeIRFile();
    if (cf[0]) {
      CFRelease(cf[0]);
    }
    if (__p)
    {
      BOOL v89 = __p;
      operator delete(__p);
    }
    if ((void)v94)
    {
      *((void *)&v94 + 1) = v94;
      operator delete((void *)v94);
    }
    if (buf.__r_.__value_.__r.__words[0])
    {
      buf.__r_.__value_.__l.__size_ = buf.__r_.__value_.__r.__words[0];
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&valuePtr;
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&buf);
    if (v92.__r_.__value_.__r.__words[0])
    {
      v92.__r_.__value_.__l.__size_ = v92.__r_.__value_.__r.__words[0];
      operator delete(v92.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v97.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v97.__r_.__value_.__l.__data_);
    }
    if (CFDictionaryRef) {
      CFRelease(CFDictionaryRef);
    }
    CFRelease(v86);
    if (getAUSMV2Log(void)::onceToken != -1) {
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
    }
    DSPSplitComplex v67 = getAUSMV2Log(void)::gLog;
    if (v66)
    {
      if (!os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR)) {
        return;
      }
      std::string::basic_string[abi:ne180100]<0>(&valuePtr, "AUSpatialMixerV2DynamicXTCFilter");
      std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("::", &valuePtr, &v92);
      std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("updateParamDictionary", &v92, &v97);
      if ((v97.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        DSPSplitComplex v68 = &v97;
      }
      else {
        DSPSplitComplex v68 = (std::string *)v97.__r_.__value_.__r.__words[0];
      }
      if (*(char *)(a1 + 1031) < 0) {
        float v54 = (void *)*v54;
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v68;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v54;
      _os_log_error_impl(&dword_1BB0CE000, v67, OS_LOG_TYPE_ERROR, "%s: Error: Virtual Surround Tool XTCIR file could not be written to: %s", (uint8_t *)&buf, 0x16u);
    }
    else
    {
      if (!os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      std::string::basic_string[abi:ne180100]<0>(&valuePtr, "AUSpatialMixerV2DynamicXTCFilter");
      DSPSplitComplex v69 = std::string::append(&valuePtr, "::", 2uLL);
      long long v70 = *(_OWORD *)&v69->__r_.__value_.__l.__data_;
      v92.__r_.__value_.__r.__words[2] = v69->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v92.__r_.__value_.__l.__data_ = v70;
      v69->__r_.__value_.__l.__size_ = 0;
      v69->__r_.__value_.__r.__words[2] = 0;
      v69->__r_.__value_.__r.__words[0] = 0;
      DSPSplitComplex v71 = std::string::append(&v92, "updateParamDictionary", 0x15uLL);
      long long v72 = *(_OWORD *)&v71->__r_.__value_.__l.__data_;
      v97.__r_.__value_.__r.__words[2] = v71->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v97.__r_.__value_.__l.__data_ = v72;
      v71->__r_.__value_.__l.__size_ = 0;
      v71->__r_.__value_.__r.__words[2] = 0;
      v71->__r_.__value_.__r.__words[0] = 0;
      double v73 = &v97;
      if ((v97.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        double v73 = (std::string *)v97.__r_.__value_.__r.__words[0];
      }
      if (*(char *)(a1 + 1031) < 0) {
        float v54 = (void *)*v54;
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v73;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v54;
      _os_log_impl(&dword_1BB0CE000, v67, OS_LOG_TYPE_DEFAULT, "%s: Virtual Surround Tool XTCIR file written to: %s", (uint8_t *)&buf, 0x16u);
    }
    if (SHIBYTE(v97.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v97.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v92.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v92.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(valuePtr.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(valuePtr.__r_.__value_.__l.__data_);
    }
  }
}

void sub_1BB3ADA74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, CFTypeRef a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a35 < 0) {
    operator delete(__p);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  _Unwind_Resume(a1);
}

BOOL applesauce::CF::details::has_key<char const(&)[25]>(const __CFDictionary *a1, char *__s)
{
  CFIndex v4 = strlen(__s);
  CFStringRef v5 = CFStringCreateWithBytes(0, (const UInt8 *)__s, v4, 0x8000100u, 0);
  if (!v5)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  CFStringRef v6 = v5;
  int v7 = CFDictionaryContainsKey(a1, v5);
  CFRelease(v6);
  return v7 != 0;
}

void sub_1BB3ADE64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  __cxa_free_exception(v10);
  _Unwind_Resume(a1);
}

uint64_t applesauce::CF::details::find_at_key_or_optional<BOOL,char const(&)[25]>(const __CFDictionary *a1, char *a2)
{
  CFBooleanRef v2 = (const __CFBoolean *)applesauce::CF::details::at_key<char const(&)[25]>(a1, a2);
  if (v2)
  {
    LOWORD(v2) = applesauce::CF::convert_as<BOOL,0>(v2);
    int v3 = BYTE1(v2);
  }
  else
  {
    int v3 = 0;
  }
  return v2 | (v3 << 8);
}

BOOL applesauce::CF::details::has_key<char const(&)[12]>(const __CFDictionary *a1, char *__s)
{
  CFIndex v4 = strlen(__s);
  CFStringRef v5 = CFStringCreateWithBytes(0, (const UInt8 *)__s, v4, 0x8000100u, 0);
  if (!v5)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  CFStringRef v6 = v5;
  int v7 = CFDictionaryContainsKey(a1, v5);
  CFRelease(v6);
  return v7 != 0;
}

void sub_1BB3ADF74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  __cxa_free_exception(v10);
  _Unwind_Resume(a1);
}

BOOL applesauce::CF::details::has_key<char const(&)[15]>(const __CFDictionary *a1, char *__s)
{
  CFIndex v4 = strlen(__s);
  CFStringRef v5 = CFStringCreateWithBytes(0, (const UInt8 *)__s, v4, 0x8000100u, 0);
  if (!v5)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  CFStringRef v6 = v5;
  int v7 = CFDictionaryContainsKey(a1, v5);
  CFRelease(v6);
  return v7 != 0;
}

void sub_1BB3AE050(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  __cxa_free_exception(v10);
  _Unwind_Resume(a1);
}

const __CFNumber *applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[15]>(const __CFDictionary *a1, char *a2)
{
  CFNumberRef result = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[15]>(a1, a2);
  if (result)
  {
    return (const __CFNumber *)applesauce::CF::convert_as<float,0>(result);
  }
  return result;
}

const __CFNumber *applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[11]>(const __CFDictionary *a1)
{
  CFNumberRef result = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[11]>(a1, "Constraint");
  if (result)
  {
    return (const __CFNumber *)applesauce::CF::convert_as<float,0>(result);
  }
  return result;
}

const __CFNumber *applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[21]>(const __CFDictionary *a1)
{
  CFNumberRef result = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[21]>(a1, "PostTimbralFrequency");
  if (result)
  {
    return (const __CFNumber *)applesauce::CF::convert_as<float,0>(result);
  }
  return result;
}

BOOL applesauce::CF::details::has_key<char const(&)[17]>(BOOL a1, char *__s)
{
  CFIndex v4 = strlen(__s);
  CFStringRef v5 = CFStringCreateWithBytes(0, (const UInt8 *)__s, v4, 0x8000100u, 0);
  if (!v5)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  CFStringRef v6 = v5;
  if (a1) {
    a1 = CFDictionaryContainsKey((CFDictionaryRef)a1, v5) != 0;
  }
  CFRelease(v6);
  return a1;
}

void sub_1BB3AE1DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  __cxa_free_exception(v10);
  _Unwind_Resume(a1);
}

const __CFNumber *applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[17]>(const __CFDictionary *a1, char *a2)
{
  CFNumberRef result = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[17]>(a1, a2);
  if (result)
  {
    return (const __CFNumber *)applesauce::CF::convert_as<float,0>(result);
  }
  return result;
}

BOOL applesauce::CF::details::has_key<char const(&)[9]>(BOOL a1, char *__s)
{
  CFIndex v4 = strlen(__s);
  CFStringRef v5 = CFStringCreateWithBytes(0, (const UInt8 *)__s, v4, 0x8000100u, 0);
  if (!v5)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  CFStringRef v6 = v5;
  if (a1) {
    a1 = CFDictionaryContainsKey((CFDictionaryRef)a1, v5) != 0;
  }
  CFRelease(v6);
  return a1;
}

void sub_1BB3AE2F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  __cxa_free_exception(v10);
  _Unwind_Resume(a1);
}

const __CFNumber *applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[9]>(const __CFDictionary *a1)
{
  CFNumberRef result = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[9]>(a1, "PostGain");
  if (result)
  {
    return (const __CFNumber *)applesauce::CF::convert_as<float,0>(result);
  }
  return result;
}

BOOL applesauce::CF::details::has_key<char const(&)[10]>(const __CFDictionary *a1, char *__s)
{
  CFIndex v4 = strlen(__s);
  CFStringRef v5 = CFStringCreateWithBytes(0, (const UInt8 *)__s, v4, 0x8000100u, 0);
  if (!v5)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  CFStringRef v6 = v5;
  int v7 = CFDictionaryContainsKey(a1, v5);
  CFRelease(v6);
  return v7 != 0;
}

void sub_1BB3AE408(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  __cxa_free_exception(v10);
  _Unwind_Resume(a1);
}

const __CFNumber *applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[10]>(const __CFDictionary *a1)
{
  CFNumberRef result = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[10]>(a1, "Crossover");
  if (result)
  {
    return (const __CFNumber *)applesauce::CF::convert_as<float,0>(result);
  }
  return result;
}

const __CFNumber *applesauce::CF::DictionaryRef_proxy::at_as<unsigned int,char const(&)[13]>(const __CFDictionary *a1)
{
  CFNumberRef result = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[13]>(a1, "FilterLength");
  if (result)
  {
    return (const __CFNumber *)applesauce::CF::convert_as<unsigned int,0>(result);
  }
  return result;
}

uint64_t applesauce::CF::details::find_at_key_or_optional<BOOL,char const(&)[12]>(const __CFDictionary *a1, char *a2)
{
  CFBooleanRef v2 = (const __CFBoolean *)applesauce::CF::details::at_key<char const(&)[12]>(a1, a2);
  if (v2)
  {
    LOWORD(v2) = applesauce::CF::convert_as<BOOL,0>(v2);
    int v3 = BYTE1(v2);
  }
  else
  {
    int v3 = 0;
  }
  return v2 | (v3 << 8);
}

const void *applesauce::CF::details::at_key<char const(&)[12]>(const __CFDictionary *a1, char *__s)
{
  CFIndex v5 = strlen(__s);
  CFStringRef v6 = CFStringCreateWithBytes(0, (const UInt8 *)__s, v5, 0x8000100u, 0);
  if (!v6)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  if (a1) {
    CFNumberRef Value = CFDictionaryGetValue(a1, v6);
  }
  CFRelease(v6);
  if (!a1) {
    return 0;
  }
  return Value;
}

void sub_1BB3AE5A8(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

const void *applesauce::CF::details::at_key<char const(&)[10]>(const __CFDictionary *a1, char *__s)
{
  CFIndex v5 = strlen(__s);
  CFStringRef v6 = CFStringCreateWithBytes(0, (const UInt8 *)__s, v5, 0x8000100u, 0);
  if (!v6)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  if (a1) {
    CFNumberRef Value = CFDictionaryGetValue(a1, v6);
  }
  CFRelease(v6);
  if (!a1) {
    return 0;
  }
  return Value;
}

void sub_1BB3AE6B4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

const void *applesauce::CF::details::at_key<char const(&)[9]>(const __CFDictionary *a1, char *__s)
{
  CFIndex v5 = strlen(__s);
  CFStringRef v6 = CFStringCreateWithBytes(0, (const UInt8 *)__s, v5, 0x8000100u, 0);
  if (!v6)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  if (a1) {
    CFNumberRef Value = CFDictionaryGetValue(a1, v6);
  }
  CFRelease(v6);
  if (!a1) {
    return 0;
  }
  return Value;
}

void sub_1BB3AE7C0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

const void *applesauce::CF::details::at_key<char const(&)[17]>(const __CFDictionary *a1, char *__s)
{
  CFIndex v5 = strlen(__s);
  CFStringRef v6 = CFStringCreateWithBytes(0, (const UInt8 *)__s, v5, 0x8000100u, 0);
  if (!v6)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  if (a1) {
    CFNumberRef Value = CFDictionaryGetValue(a1, v6);
  }
  CFRelease(v6);
  if (!a1) {
    return 0;
  }
  return Value;
}

void sub_1BB3AE8CC(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

const void *applesauce::CF::details::at_key<char const(&)[21]>(const __CFDictionary *a1, char *__s)
{
  CFIndex v5 = strlen(__s);
  CFStringRef v6 = CFStringCreateWithBytes(0, (const UInt8 *)__s, v5, 0x8000100u, 0);
  if (!v6)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  if (a1) {
    CFNumberRef Value = CFDictionaryGetValue(a1, v6);
  }
  CFRelease(v6);
  if (!a1) {
    return 0;
  }
  return Value;
}

void sub_1BB3AE9D8(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

const void *applesauce::CF::details::at_key<char const(&)[11]>(const __CFDictionary *a1, char *__s)
{
  CFIndex v5 = strlen(__s);
  CFStringRef v6 = CFStringCreateWithBytes(0, (const UInt8 *)__s, v5, 0x8000100u, 0);
  if (!v6)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  if (a1) {
    CFNumberRef Value = CFDictionaryGetValue(a1, v6);
  }
  CFRelease(v6);
  if (!a1) {
    return 0;
  }
  return Value;
}

void sub_1BB3AEAE4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

const void *applesauce::CF::details::at_key<char const(&)[15]>(const __CFDictionary *a1, char *__s)
{
  CFIndex v5 = strlen(__s);
  CFStringRef v6 = CFStringCreateWithBytes(0, (const UInt8 *)__s, v5, 0x8000100u, 0);
  if (!v6)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  if (a1) {
    CFNumberRef Value = CFDictionaryGetValue(a1, v6);
  }
  CFRelease(v6);
  if (!a1) {
    return 0;
  }
  return Value;
}

void sub_1BB3AEBF0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

void AUSM::printFloatVector(uint64_t a1, char **a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  std::string::reserve((std::string *)a1, 2 * (a2[1] - *a2) - ((a2[1] - *a2) >> 2));
  CFIndex v4 = *a2;
  if (*a2 == a2[1])
  {
    CFIndex v5 = *a2;
  }
  else
  {
    v14[0] = *(_DWORD *)v4;
    uint64_t v16 = 0;
    uint64_t v17 = 201;
    uint64_t v15 = 3;
    __p[1] = 0;
    uint64_t v10 = 0;
    __p[0] = 0;
    uint64_t v11 = 2;
    float v12 = v14;
    uint64_t v13 = 201;
    std::__vformat_to[abi:ne180100]<std::back_insert_iterator<std::string>,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>((uint64_t)__p, "{:.{}f}", 7, &v11);
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    *(_OWORD *)a1 = *(_OWORD *)__p;
    *(void *)(a1 + 16) = v10;
    CFIndex v4 = *a2;
    CFIndex v5 = a2[1];
  }
  if (((v5 - v4) & 0x3FFFFFFF8) != 0)
  {
    unint64_t v6 = 1;
    do
    {
      v14[0] = *(_DWORD *)&v4[4 * v6];
      uint64_t v16 = 0;
      uint64_t v17 = 201;
      uint64_t v15 = 3;
      __p[1] = 0;
      uint64_t v10 = 0;
      __p[0] = 0;
      uint64_t v11 = 2;
      float v12 = v14;
      uint64_t v13 = 201;
      std::__vformat_to[abi:ne180100]<std::back_insert_iterator<std::string>,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>((uint64_t)__p, ", {:.{}f}", 9, &v11);
      if (v10 >= 0) {
        int v7 = __p;
      }
      else {
        int v7 = (void **)__p[0];
      }
      if (v10 >= 0) {
        std::string::size_type v8 = HIBYTE(v10);
      }
      else {
        std::string::size_type v8 = (std::string::size_type)__p[1];
      }
      std::string::append((std::string *)a1, (const std::string::value_type *)v7, v8);
      if (SHIBYTE(v10) < 0) {
        operator delete(__p[0]);
      }
      ++v6;
      CFIndex v4 = *a2;
    }
    while (v6 < ((unint64_t)(a2[1] - *a2) >> 2));
  }
}

void sub_1BB3AEDEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v14 + 23) < 0) {
    operator delete(*(void **)v14);
  }
  _Unwind_Resume(exception_object);
}

void lmsfilt_v5::preemphasisFilter(lmsfilt_v5 *this, const float *a2, float *a3, float *a4, float *a5, unsigned __int8 *a6, const BOOL *a7)
{
  if ((int)a5 >= 1)
  {
    uint64_t v12 = 0;
    vDSP_Length v13 = (int)a2;
    uint64_t v14 = 4 * (int)a2;
    uint64_t v15 = a5;
    do
    {
      if (*a6++)
      {
        lmsfilt_v3::preemphasisFilter((lmsfilt_v5 *)((char *)this + v12), a2, a3, (float *)((char *)a4 + v12), a5);
      }
      else
      {
        vDSP_vclr((float *)((char *)a4 + v12), 1, v13);
        *a3 = 0.0;
      }
      ++a3;
      v12 += v14;
      --v15;
    }
    while (v15);
  }
}

float lmsfilt_v5::deemphasisFilterDuo(lmsfilt_v5 *this, float *a2, float *a3, float *a4, float *a5, float *a6, float *a7, float *a8)
{
  *a4 = *a2 + (float)(*a3 * 0.9);
  *a7 = *a5 + (float)(*a6 * 0.9);
  if ((int)this >= 2)
  {
    uint64_t v8 = this - 1;
    CFDictionaryRef v9 = a2 + 1;
    uint64_t v10 = a5 + 1;
    uint64_t v11 = a4 + 1;
    uint64_t v12 = a7 + 1;
    do
    {
      float v13 = *v9++;
      float *v11 = v13 + (float)(*(v11 - 1) * 0.9);
      ++v11;
      float v14 = *v10++;
      float *v12 = v14 + (float)(*(v12 - 1) * 0.9);
      ++v12;
      --v8;
    }
    while (v8);
  }
  *a3 = a4[(int)this - 1];
  float result = a7[(int)this - 1];
  *a6 = result;
  return result;
}

void lmsfilt_v5::initLmsFilter(int a1, int a2, int a3, uint64_t a4, float ***a5, int a6)
{
  int v10 = *(_DWORD *)(a4 + 16);
  float __A = 0.0;
  int v11 = *(_DWORD *)(a4 + 44);
  uint64_t v12 = (float **)malloc_type_malloc(0x80uLL, 0x2C8E6D5CuLL);
  if (!v12) {
    goto LABEL_42;
  }
  *((_OWORD *)v12 + 6) = 0u;
  *((_OWORD *)v12 + 7) = 0u;
  *((_OWORD *)v12 + 4) = 0u;
  *((_OWORD *)v12 + 5) = 0u;
  *((_OWORD *)v12 + 2) = 0u;
  *((_OWORD *)v12 + 3) = 0u;
  *(_OWORD *)uint64_t v12 = 0u;
  *((_OWORD *)v12 + 1) = 0u;
  *a5 = v12;
  int v13 = v11 * v10;
  *((_DWORD *)v12 + 8) = v11;
  *((_DWORD *)v12 + 9) = v11 * v10;
  int v14 = v11 * v10 * a6;
  *((_DWORD *)v12 + 22) = v14;
  *((_DWORD *)v12 + 23) = a6;
  int v15 = 4 * v14;
  int v16 = 4 * v14;
  uint64_t v17 = (float *)malloc_type_malloc(4 * v14, 0x2C8E6D5CuLL);
  if (4 * v14 && v17 == 0) {
    goto LABEL_42;
  }
  CFStringRef v19 = v17;
  bzero(v17, v15);
  **a5 = v19;
  CFStringRef v20 = (float *)malloc_type_malloc(v15, 0x2C8E6D5CuLL);
  if (v16 && v20 == 0) {
    goto LABEL_42;
  }
  CFDictionaryRef v22 = v20;
  bzero(v20, v15);
  (*a5)[1] = v22;
  float v23 = (float *)malloc_type_malloc(v15, 0x2C8E6D5CuLL);
  if (v16 && v23 == 0) {
    goto LABEL_42;
  }
  CFDictionaryRef v25 = v23;
  bzero(v23, v15);
  (*a5)[2] = v25;
  CFStringRef v26 = (float *)malloc_type_malloc(v15, 0x2C8E6D5CuLL);
  if (v16 && v26 == 0) {
    goto LABEL_42;
  }
  int v28 = v26;
  bzero(v26, v15);
  (*a5)[3] = v28;
  CFDictionaryRef v29 = (float *)malloc_type_malloc(v15, 0x2C8E6D5CuLL);
  if (v16 && v29 == 0) {
    goto LABEL_42;
  }
  CFDictionaryRef v31 = v29;
  bzero(v29, v15);
  (*a5)[6] = v31;
  vDSP_vfill(&__A, **a5, 1, v14);
  vDSP_vfill(&__A, (*a5)[1], 1, v14);
  vDSP_vfill(&__A, (*a5)[2], 1, v14);
  vDSP_vfill(&__A, (*a5)[3], 1, v14);
  vDSP_vfill(&__A, (*a5)[6], 1, v14);
  uint64_t v32 = *a5;
  *((float *)v32 + 10) = (float)(1.0 - *(float *)(a4 + 92)) + (float)(1.0 - *(float *)(a4 + 92));
  *((_DWORD *)v32 + 11) = 1;
  v32[7] = 0;
  *((_DWORD *)v32 + 16) = 0;
  *((_DWORD *)v32 + 17) = a1;
  *((_DWORD *)v32 + 18) = 0;
  *((_DWORD *)v32 + 19) = v11 - 1;
  int v33 = a3 / v10;
  if (a3 / v10 >= v11) {
    int v33 = v11;
  }
  int v34 = (a3 - a2) / v10;
  *((_DWORD *)v32 + 20) = v34;
  *((_DWORD *)v32 + 21) = v33;
  if (v33 - v34 <= 1)
  {
    if (v11 == 4) {
      int v35 = -1;
    }
    else {
      int v35 = 0;
    }
    if (v11 > 4) {
      int v35 = -2;
    }
    *((_DWORD *)v32 + 20) = v33 + v35;
  }
  if (*(unsigned char *)(a4 + 178))
  {
    uint64_t v36 = (float *)malloc_type_malloc(4 * v13, 0x2C8E6D5CuLL);
    CFDictionaryRef v37 = v36;
    if (!v13 || v36)
    {
      bzero(v36, 4 * v13);
      (*a5)[12] = v37;
      float v38 = (float *)malloc_type_malloc(4 * v13, 0x2C8E6D5CuLL);
      CFDictionaryRef v39 = v38;
      if (!v13 || v38)
      {
        bzero(v38, 4 * v13);
        (*a5)[13] = v39;
        CFDictionaryRef v40 = (float *)malloc_type_malloc(4 * v13, 0x2C8E6D5CuLL);
        CFDictionaryRef v41 = v40;
        if (!v13 || v40)
        {
          bzero(v40, 4 * v13);
          (*a5)[14] = v41;
          uint64_t v42 = *(int *)(a4 + 128);
          CFDictionaryRef v43 = (float *)malloc_type_malloc(4 * v42, 0x2C8E6D5CuLL);
          float v44 = v43;
          if (!v42 || v43)
          {
            bzero(v43, 4 * v42);
            (*a5)[15] = v44;
            return;
          }
        }
      }
    }
LABEL_42:
    exceptiouint64_t n = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    CFDictionaryRef v46 = std::bad_alloc::bad_alloc(exception);
  }
}

void lmsfilt_v5::removeLmsFilter(uint64_t *a1)
{
  if (a1)
  {
    uint64_t v2 = *a1;
    if (*a1)
    {
      if (*(void *)v2)
      {
        free(*(void **)v2);
        *(void *)uint64_t v2 = 0;
        uint64_t v2 = *a1;
      }
      int v3 = *(void **)(v2 + 8);
      if (v3)
      {
        free(v3);
        *(void *)(v2 + 8) = 0;
        uint64_t v2 = *a1;
      }
      CFIndex v4 = *(void **)(v2 + 16);
      if (v4)
      {
        free(v4);
        *(void *)(v2 + 16) = 0;
        uint64_t v2 = *a1;
      }
      CFIndex v5 = *(void **)(v2 + 24);
      if (v5)
      {
        free(v5);
        *(void *)(v2 + 24) = 0;
        uint64_t v2 = *a1;
      }
      unint64_t v6 = *(void **)(v2 + 48);
      if (v6)
      {
        free(v6);
        *(void *)(v2 + 48) = 0;
        uint64_t v2 = *a1;
      }
      int v7 = *(void **)(v2 + 96);
      if (v7)
      {
        free(v7);
        *(void *)(v2 + 96) = 0;
        uint64_t v2 = *a1;
      }
      uint64_t v8 = *(void **)(v2 + 104);
      if (v8)
      {
        free(v8);
        *(void *)(v2 + 104) = 0;
        uint64_t v2 = *a1;
      }
      CFDictionaryRef v9 = *(void **)(v2 + 112);
      if (v9)
      {
        free(v9);
        *(void *)(v2 + 112) = 0;
        uint64_t v2 = *a1;
      }
      int v10 = *(void **)(v2 + 120);
      if (!v10 || (free(v10), *(void *)(v2 + 120) = 0, (uint64_t v2 = *a1) != 0))
      {
        free((void *)v2);
        *a1 = 0;
      }
    }
  }
}

void lmsfilt_v5::runLmsFilter_v5(DSPSplitComplex *this, DSPSplitComplex *a2, DSPSplitComplex *a3, uint64_t a4, uint64_t a5, uint64_t a6, float *a7, float *a8, float *a9, float *a10, int *a11, unsigned __int8 *a12, float **a13, _DWORD *a14, char a15, uint64_t a16, const BOOL *a17, DSPSplitComplex *a18, const unsigned int *a19, BOOL a20)
{
  int v25 = HIDWORD(a9);
  vDSP_Length v26 = (int)a3;
  vDSP_vclr(a2->realp, 1, (int)a3);
  vDSP_vclr(a2->imagp, 1, v26);
  vDSP_vclr(*a13, 1, v26);
  CFDictionaryRef v40 = (int *)a13;
  vDSP_vclr(a13[1], 1, v26);
  CFStringRef v27 = (float *)a10;
  if ((int)a10 >= 2)
  {
    *(void *)uint64_t v42 = a5;
    uint64_t v43 = a6;
    float v44 = a2;
    uint64_t v28 = 0;
    uint64_t v29 = 0;
    uint64_t v30 = 0;
    uint64_t v31 = a4;
    while (1)
    {
      int v32 = *a12++;
      imagp = this->imagp;
      int v34 = &this->realp[v28];
      int v35 = &imagp[v28];
      CFDictionaryRef v49 = v27;
      if (v32)
      {
        v51.realp = &this->realp[v28];
        v51.imagp = &imagp[v28];
        LODWORD(v39) = v25;
        lmsfilt_v3::runLmsFilter_v3(&v51, a3, v31 + v29, *(void *)v42 + v29, v43 + v30 * 4, &a7[v30], a8, (float *)a9, v39, v40, v42[0], v42[1]);
        vDSP_vadd(v34, 1, v44->realp, 1, v44->realp, 1, v26);
        vDSP_vadd(v35, 1, v44->imagp, 1, v44->imagp, 1, v26);
        uint64_t v36 = a14;
        if (!a15 || *a14) {
          goto LABEL_9;
        }
        vDSP_vadd(v34, 1, *(const float **)v40, 1, *(float **)v40, 1, v26);
        vDSP_vadd(v35, 1, *((const float **)v40 + 1), 1, *((float **)v40 + 1), 1, v26);
      }
      else
      {
        vDSP_vclr(v34, 1, v26);
        vDSP_vclr(v35, 1, v26);
      }
      uint64_t v36 = a14;
LABEL_9:
      a14 = v36 + 1;
      v30 += SHIDWORD(a10);
      v29 += 4 * (int)a11;
      v28 += v26;
      CFStringRef v27 = (float *)((char *)v49 - 1);
      int v25 = HIDWORD(a9);
      if (v49 == (float *)1) {
        return;
      }
    }
  }
  LODWORD(v39) = HIDWORD(a9);
  lmsfilt_v3::runLmsFilter_v3(this, a3, a4, a5, a6, a7, a8, (float *)a9, v39, (int *)a13, v41[0], v41[1]);
  memcpy(a2->realp, this->realp, 4 * v26);
  CFDictionaryRef v37 = a2->imagp;
  float v38 = this->imagp;

  memcpy(v37, v38, 4 * v26);
}

void lmsfilt_v5::resetLmsFilter(uint64_t *a1, uint64_t a2)
{
  if (a2)
  {
    vDSP_Length v3 = *(unsigned int *)(a2 + 36);
    if ((int)v3 >= 1)
    {
      vDSP_Length v5 = *(int *)(a2 + 92);
      int v6 = *(_DWORD *)(a2 + 32);
      float __A = 0.0;
      vDSP_vfill(&__A, *(float **)a2, 1, (int)v5 * (uint64_t)(int)v3);
      vDSP_vfill(&__A, *(float **)(a2 + 8), 1, (int)v5 * (uint64_t)(int)v3);
      vDSP_vfill(&__A, *(float **)(a2 + 16), 1, (int)v5 * (uint64_t)(int)v3);
      vDSP_vfill(&__A, *(float **)(a2 + 24), 1, (int)v5 * (uint64_t)(int)v3);
      vDSP_vfill(&__A, *(float **)(a2 + 48), 1, (int)v5 * (uint64_t)(int)v3);
      uint64_t v7 = *a1;
      *(float *)(a2 + 40) = (float)(1.0 - *(float *)(*a1 + 92)) + (float)(1.0 - *(float *)(*a1 + 92));
      *(_DWORD *)(a2 + 44) = 1;
      *(void *)(a2 + 56) = 0;
      *(_DWORD *)(a2 + 64) = 0;
      *(_DWORD *)(a2 + 72) = 0;
      *(_DWORD *)(a2 + 76) = v6 - 1;
      int v8 = *(_DWORD *)(a2 + 84);
      if (v8 > v6)
      {
        *(_DWORD *)(a2 + 84) = v6;
        int v8 = v6;
      }
      if (v8 - *(_DWORD *)(a2 + 80) <= 1)
      {
        if (v6 == 4) {
          int v9 = -1;
        }
        else {
          int v9 = 0;
        }
        if (v6 > 4) {
          int v9 = -2;
        }
        *(_DWORD *)(a2 + 80) = v8 + v9;
      }
      if (*(unsigned char *)(v7 + 178))
      {
        vDSP_vfill(&__A, *(float **)(a2 + 96), 1, v3);
        vDSP_vfill(&__A, *(float **)(a2 + 104), 1, v3);
        vDSP_vfill(&__A, *(float **)(a2 + 112), 1, v3);
        vDSP_vfill(&__A, *(float **)(a2 + 120), 1, v5);
      }
    }
  }
}

__CFString *AUToneMeisterParameterImporter::importParameters(DspLib::ToneMeister::Algorithm **this, NSDictionary *a2, unsigned char *a3, BOOL *a4)
{
  uint64_t v359 = *MEMORY[0x1E4F143B8];
  vDSP_Length v5 = a2;
  *a3 = 1;
  unint64_t v310 = v5;
  uint64_t v6 = [(NSDictionary *)v310 objectForKeyedSubscript:@"Filters"];
  *a3 = 1;
  uint64_t v331 = (DspLib::ToneMeister::Parameters *)v6;
  if (v6)
  {
    uint64_t v7 = [(NSDictionary *)v310 objectForKeyedSubscript:@"Global"];
    int v8 = v7;
    *a3 = 1;
    if (v7)
    {
      int v9 = [v7 objectForKeyedSubscript:@"Channels"];
      if (v9)
      {
        long long v355 = 0u;
        long long v356 = 0u;
        long long v353 = 0u;
        long long v354 = 0u;
        id v10 = v9;
        uint64_t v11 = [v10 countByEnumeratingWithState:&v353 objects:v358 count:16];
        if (v11)
        {
          uint64_t v12 = *(void *)v354;
          int v13 = &stru_1F14C9790;
          while (2)
          {
            for (uint64_t i = 0; i != v11; ++i)
            {
              if (*(void *)v354 != v12) {
                objc_enumerationMutation(v10);
              }
              int v15 = [*(id *)(*((void *)&v353 + 1) + 8 * i) substringFromIndex:2];
              uint64_t v16 = [v15 integerValue];

              uint64_t v17 = *((unsigned int *)this + 2);
              if (v16 > v17)
              {
                *a3 = 0;
                objc_msgSend(NSString, "stringWithFormat:", @"attempting to assign a global parameter to channel %ld but AU was created with only %u channels\n", v16, v17);
                int v13 = (__CFString *)objc_claimAutoreleasedReturnValue();
                goto LABEL_18;
              }
            }
            uint64_t v11 = [v10 countByEnumeratingWithState:&v353 objects:v358 count:16];
            if (v11) {
              continue;
            }
            break;
          }
        }
        else
        {
          int v13 = &stru_1F14C9790;
        }
LABEL_18:
      }
      else
      {
        *a3 = 0;
        int v13 = [NSString stringWithFormat:@"could not find key :%@", @"Channels"];
      }
    }
    else
    {
      int v13 = &stru_1F14C9790;
    }

    if (*a3)
    {
      long long v346 = 0u;
      long long v347 = 0u;
      long long v344 = 0u;
      long long v345 = 0u;
      obuint64_t j = v331;
      uint64_t v18 = [(DspLib::ToneMeister::Parameters *)obj countByEnumeratingWithState:&v344 objects:&v353 count:16];
      uint64_t v19 = 0;
      if (!v18) {
        goto LABEL_149;
      }
      uint64_t v329 = *(void *)v345;
      while (1)
      {
        float v336 = 0;
        uint64_t v323 = (v19 + v18);
        v325 = (DspLib::ToneMeister::Parameters *)v18;
        do
        {
          unsigned int v333 = v19;
          if (*(void *)v345 != v329) {
            objc_enumerationMutation(obj);
          }
          CFStringRef v20 = *(void **)(*((void *)&v344 + 1) + 8 * (void)v336);
          int v21 = [v20 objectForKeyedSubscript:@"Type"];
          *a3 = 1;
          CFDictionaryRef v22 = AUToneMeisterParameterImporter::filterTypeStrings(v21);
          char v23 = [v22 containsObject:v21];

          CFDictionaryRef v24 = &stru_1F14C9790;
          if ((v23 & 1) == 0)
          {
            *a3 = 0;
            CFDictionaryRef v24 = [NSString stringWithFormat:@"Unknown filter type: %@\n", v21];
          }

          if (!*a3)
          {
            uint64_t v19 = v333;
            int v13 = v24;
            goto LABEL_149;
          }
          int v25 = v20;
          vDSP_Length v26 = AUToneMeisterParameterImporter::filterTypeStrings(v25);
          CFStringRef v27 = [(AUToneMeisterParameterImporter *)v25 objectForKeyedSubscript:@"Type"];
          uint64_t v28 = (DspLib::ToneMeister::Parameters *)[v26 indexOfObject:v27];

          *a3 = 1;
          int v13 = &stru_1F14C9790;
          if (DspLib::ToneMeister::Parameters::filterTypeHasFrequency(v28))
          {
            if (v28 == (DspLib::ToneMeister::Parameters *)2)
            {
              uint64_t v29 = [(AUToneMeisterParameterImporter *)v25 objectForKeyedSubscript:@"Frequency"];
              *a3 = 1;
              if ([v29 count] == 2)
              {
                float v44 = [v29 objectAtIndex:0];
                [v44 floatValue];
                float v46 = v45;

                CFDictionaryRef v47 = [v29 objectAtIndex:1];
                [v47 floatValue];
                float v49 = v48;

                if (v46 >= 20.0)
                {
                  DSPSplitComplex v51 = @"Frequency 0 of %f greater than maximum (%f)\n";
                  double v50 = 20000.0;
                  if (v46 <= 20000.0)
                  {
                    if (v49 >= -30.0)
                    {
                      float v46 = v49;
                      DSPSplitComplex v51 = @"Frequency 1 of %f greater than maximum (%f)\n";
                      double v50 = 20000.0;
                      if (v49 <= 20000.0) {
                        goto LABEL_62;
                      }
                    }
                    else
                    {
                      double v50 = -30.0;
                      float v46 = v49;
                      DSPSplitComplex v51 = @"Frequency 1 of %f less than minimum (%f)\n";
                    }
                  }
                }
                else
                {
                  double v50 = 20.0;
                  DSPSplitComplex v51 = @"Frequency 0 of %f less than minimum (%f)\n";
                }
                *a3 = 0;
                uint64_t v59 = objc_msgSend(NSString, "stringWithFormat:", v51, v46, *(void *)&v50);
              }
              else
              {
                *a3 = 0;
                uint64_t v59 = objc_msgSend(NSString, "stringWithFormat:", @"Frequency array has %lu elements but should have 2\n", objc_msgSend(v29, "count"));
              }
              int v13 = (__CFString *)v59;
            }
            else if (v28)
            {
              CFDictionaryRef v52 = [(AUToneMeisterParameterImporter *)v25 objectForKeyedSubscript:@"Frequency"];
              uint64_t v29 = v52;
              *a3 = 1;
              if (v52)
              {
                [v52 floatValue];
                if (v53 >= 20.0)
                {
                  [v29 floatValue];
                  if (v61 <= 20000.0) {
                    goto LABEL_62;
                  }
                  *a3 = 0;
                  float v54 = NSString;
                  [v29 floatValue];
                  CFStringRef v57 = @"Frequency of %f greater than maximum (%f)\n";
                  double v56 = 20000.0;
                }
                else
                {
                  *a3 = 0;
                  float v54 = NSString;
                  [v29 floatValue];
                  double v56 = 20.0;
                  CFStringRef v57 = @"Frequency of %f less than minimum (%f)\n";
                }
                uint64_t v60 = objc_msgSend(v54, "stringWithFormat:", v57, v55, *(void *)&v56);
              }
              else
              {
                *a3 = 0;
                uint64_t v60 = [NSString stringWithFormat:@"missing key: %@\n", @"Frequency"];
              }
              int v13 = (__CFString *)v60;
            }
            else
            {
              uint64_t v29 = [(AUToneMeisterParameterImporter *)v25 objectForKeyedSubscript:@"Frequency"];
              *a3 = 1;
              if ([v29 count] != 4)
              {
                *a3 = 0;
                uint64_t v58 = [NSString stringWithFormat:@"Frequency array has %lu elements, should have 4\n", objc_msgSend(v29, "count")];
                goto LABEL_61;
              }
              uint64_t v30 = [v29 objectAtIndex:0];
              [v30 floatValue];
              float v32 = v31;

              int v33 = [v29 objectAtIndex:1];
              [v33 floatValue];
              float v35 = v34;

              uint64_t v36 = [v29 objectAtIndex:2];
              [v36 floatValue];
              float v38 = v37;

              CFDictionaryRef v39 = [v29 objectAtIndex:3];
              [v39 floatValue];
              float v41 = v40;

              if (v32 < 20.0)
              {
                double v42 = 20.0;
                uint64_t v43 = @"Frequency 0 of %f less than minimum (%f)\n";
                goto LABEL_60;
              }
              uint64_t v43 = @"Frequency 0 of %f greater than maximum (%f)\n";
              double v42 = 20000.0;
              if (v32 > 20000.0) {
                goto LABEL_60;
              }
              if (v35 < -30.0)
              {
                float v32 = v35;
                uint64_t v43 = @"Frequency 1 of %f less than minimum (%f)\n";
                goto LABEL_54;
              }
              float v32 = v35;
              uint64_t v43 = @"Frequency 1 of %f greater than maximum (%f)\n";
              double v42 = 20000.0;
              if (v35 > 20000.0) {
                goto LABEL_60;
              }
              if (v38 < -30.0)
              {
                float v32 = v38;
                uint64_t v43 = @"Frequency 2 of %f less than minimum (%f)\n";
LABEL_54:
                double v42 = -30.0;
                goto LABEL_60;
              }
              float v32 = v38;
              uint64_t v43 = @"Frequency 2 of %f greater than maximum (%f)\n";
              double v42 = 20000.0;
              if (v38 > 20000.0) {
                goto LABEL_60;
              }
              if (v41 < -180.0)
              {
                float v32 = v41;
                uint64_t v43 = @"Frequency 3 of %f less than minimum (%f)\n";
                double v42 = -180.0;
                goto LABEL_60;
              }
              float v32 = v41;
              uint64_t v43 = @"Frequency 3 of %f greater than maximum (%f)\n";
              double v42 = 20000.0;
              if (v41 > 20000.0)
              {
LABEL_60:
                *a3 = 0;
                uint64_t v58 = objc_msgSend(NSString, "stringWithFormat:", v43, v32, *(void *)&v42);
LABEL_61:
                int v13 = (__CFString *)v58;
              }
            }
LABEL_62:

            if (*a3)
            {

              int v13 = &stru_1F14C9790;
            }
          }

          if (!*a3) {
            goto LABEL_145;
          }
          __int16 v62 = v25;
          Float64 v63 = AUToneMeisterParameterImporter::filterTypeStrings(v62);
          DSPSplitComplex v64 = [(AUToneMeisterParameterImporter *)v62 objectForKeyedSubscript:@"Type"];
          uint64_t v65 = (DspLib::ToneMeister::Parameters *)[v63 indexOfObject:v64];

          int v66 = DspLib::ToneMeister::Parameters::categoryOfFilterType(v65);
          *a3 = 1;
          DSPSplitComplex v67 = &stru_1F14C9790;
          if (DspLib::ToneMeister::Parameters::filterTypeHasGain(v65))
          {
            if (v66 == 4)
            {
              DSPSplitComplex v68 = [(AUToneMeisterParameterImporter *)v62 objectForKeyedSubscript:@"GainRange"];
              if (v68) {
                goto LABEL_70;
              }
              DSPSplitComplex v69 = @"GainRange";
            }
            else
            {
              DSPSplitComplex v68 = [(AUToneMeisterParameterImporter *)v62 objectForKeyedSubscript:@"Gain"];
              if (v68)
              {
LABEL_70:
                [v68 floatValue];
                if (v70 < -30.0)
                {
                  *a3 = 0;
                  DSPSplitComplex v71 = NSString;
                  [v68 floatValue];
                  double v73 = -30.0;
                  uint64_t v74 = @"Gain of %f less than minimum (%f)\n";
                  goto LABEL_74;
                }
                [v68 floatValue];
                if (v75 > 30.0)
                {
                  *a3 = 0;
                  DSPSplitComplex v71 = NSString;
                  [v68 floatValue];
                  double v73 = 30.0;
                  uint64_t v74 = @"Gain of %f greater than maximum (%f)\n";
LABEL_74:
                  objc_msgSend(v71, "stringWithFormat:", v74, v72, *(void *)&v73);
                  DSPSplitComplex v67 = (__CFString *)objc_claimAutoreleasedReturnValue();
                }

                goto LABEL_78;
              }
              DSPSplitComplex v69 = @"Gain";
            }
            *a3 = 0;
            DSPSplitComplex v67 = [NSString stringWithFormat:@"missing key: %@\n", v69];
          }
LABEL_78:

          if (!*a3)
          {
            uint64_t v19 = v333;
            int v13 = v67;
            goto LABEL_149;
          }
          unsigned int v76 = v62;
          long long v77 = AUToneMeisterParameterImporter::filterTypeStrings(v76);
          double v78 = [(AUToneMeisterParameterImporter *)v76 objectForKeyedSubscript:@"Type"];
          double v79 = (DspLib::ToneMeister::Parameters *)[v77 indexOfObject:v78];

          *a3 = 1;
          double v80 = &stru_1F14C9790;
          if (DspLib::ToneMeister::Parameters::filterTypeHasOrder(v79))
          {
            float v81 = [(AUToneMeisterParameterImporter *)v76 objectForKeyedSubscript:@"Order"];
            uint64_t v82 = v81;
            if (v81)
            {
              [v81 floatValue];
              if (v83 < -30.0)
              {
                *a3 = 0;
                uint64_t v84 = NSString;
                [v82 floatValue];
                double v86 = -30.0;
                unsigned int v87 = @"Order of %f less than minimum (%f)\n";
                goto LABEL_86;
              }
              [v82 floatValue];
              if (v89 > 20000.0)
              {
                *a3 = 0;
                uint64_t v84 = NSString;
                [v82 floatValue];
                unsigned int v87 = @"Order of %f greater than maximum (%f)\n";
                double v86 = 20000.0;
LABEL_86:
                uint64_t v88 = objc_msgSend(v84, "stringWithFormat:", v87, v85, *(void *)&v86);
LABEL_87:
                double v80 = (__CFString *)v88;
              }

              goto LABEL_89;
            }
            *a3 = 0;
            uint64_t v88 = [NSString stringWithFormat:@"missing key: %@\n", @"Order"];
            goto LABEL_87;
          }
LABEL_89:

          if (!*a3) {
            goto LABEL_146;
          }
          char v90 = v76;
          AudioFormatFlags v91 = AUToneMeisterParameterImporter::filterTypeStrings(v90);
          std::string v92 = [(AUToneMeisterParameterImporter *)v90 objectForKeyedSubscript:@"Type"];
          double v93 = (DspLib::ToneMeister::Parameters *)[v91 indexOfObject:v92];

          *a3 = 1;
          int v13 = &stru_1F14C9790;
          if (DspLib::ToneMeister::Parameters::filterTypeHasQuality(v93))
          {
            long long v94 = [(AUToneMeisterParameterImporter *)v90 objectForKeyedSubscript:@"Quality"];
            unsigned int v95 = v94;
            if (v94)
            {
              [v94 floatValue];
              if (v96 >= -30.0
                || (std::string v97 = (DspLib *)[v95 floatValue], DspLib::isEqual(v97, v98, -30.0, 1.0e-20)))
              {
                [v95 floatValue];
                if (v99 > 20000.0)
                {
                  AudioFormatFlags v100 = (DspLib *)[v95 floatValue];
                  if (!DspLib::isEqual(v100, v101, 20000.0, 1.0e-20))
                  {
                    CFStringRef v102 = NSString;
                    [v95 floatValue];
                    double v104 = 20000.0;
                    goto LABEL_99;
                  }
                }
LABEL_101:

                goto LABEL_102;
              }
              CFStringRef v102 = NSString;
              [v95 floatValue];
              double v104 = -30.0;
LABEL_99:
              uint64_t v105 = objc_msgSend(v102, "stringWithFormat:", @"Quality of %f clamped to %f.", v103, *(void *)&v104);
            }
            else
            {
              *a3 = 0;
              uint64_t v105 = [NSString stringWithFormat:@"missing key: %@\n", @"Quality"];
            }
            int v13 = (__CFString *)v105;
            goto LABEL_101;
          }
LABEL_102:

          if (!*a3) {
            goto LABEL_145;
          }
          uint64_t v106 = [(AUToneMeisterParameterImporter *)v90 objectForKeyedSubscript:@"Channels"];
          uint64_t v107 = v106;
          *a3 = 1;
          if (v106)
          {
            long long v350 = 0u;
            long long v351 = 0u;
            long long v348 = 0u;
            long long v349 = 0u;
            id v108 = v106;
            uint64_t v109 = [v108 countByEnumeratingWithState:&v348 objects:v358 count:16];
            if (v109)
            {
              uint64_t v110 = *(void *)v349;
              while (2)
              {
                for (uint64_t j = 0; j != v109; ++j)
                {
                  if (*(void *)v349 != v110) {
                    objc_enumerationMutation(v108);
                  }
                  uint64_t v112 = [*(id *)(*((void *)&v348 + 1) + 8 * j) substringFromIndex:2];
                  uint64_t v113 = [v112 integerValue];

                  if (!v113)
                  {
                    *a3 = 0;
                    double v80 = @"channel number = 0, but channel enumeration starts with channel 1";
                    goto LABEL_118;
                  }
                  uint64_t v114 = *((unsigned int *)this + 2);
                  if (v113 > v114)
                  {
                    *a3 = 0;
                    double v80 = [NSString stringWithFormat:@"attempting to assing a filter to channel: %ld, but only %d channels are available", v113, v114];
                    goto LABEL_118;
                  }
                }
                uint64_t v109 = [v108 countByEnumeratingWithState:&v348 objects:v358 count:16];
                double v80 = &stru_1F14C9790;
                if (v109) {
                  continue;
                }
                break;
              }
            }
            else
            {
              double v80 = &stru_1F14C9790;
            }
LABEL_118:
          }
          else
          {
            *a3 = 0;
            double v80 = [NSString stringWithFormat:@"missing key %@", @"Channels"];
          }

          if (!*a3)
          {
LABEL_146:
            uint64_t v19 = v333;
            int v13 = v80;
            goto LABEL_149;
          }
          uint64_t v115 = v90;
          uint64_t v116 = AUToneMeisterParameterImporter::filterTypeStrings(v115);
          unint64_t v117 = [(AUToneMeisterParameterImporter *)v115 objectForKeyedSubscript:@"Type"];
          int v118 = (DspLib::ToneMeister::Parameters *)[v116 indexOfObject:v117];

          int v119 = DspLib::ToneMeister::Parameters::categoryOfFilterType(v118);
          *a3 = 1;
          int v13 = &stru_1F14C9790;
          if (v119 == 4)
          {
            v357[0] = @"attackTime";
            v357[1] = @"releaseTime";
            v357[2] = @"enableAttackRelease";
            v357[3] = @"Threshold";
            v357[4] = @"Ratio";
            unint64_t v120 = [MEMORY[0x1E4F1C978] arrayWithObjects:v357 count:5];
            long long v350 = 0u;
            long long v351 = 0u;
            long long v348 = 0u;
            long long v349 = 0u;
            id v121 = v120;
            uint64_t v122 = [v121 countByEnumeratingWithState:&v348 objects:v358 count:16];
            if (v122)
            {
              uint64_t v123 = *(void *)v349;
              while (2)
              {
                for (uint64_t k = 0; k != v122; ++k)
                {
                  if (*(void *)v349 != v123) {
                    objc_enumerationMutation(v121);
                  }
                  uint64_t v125 = *(void *)(*((void *)&v348 + 1) + 8 * k);
                  unint64_t v126 = [(AUToneMeisterParameterImporter *)v115 objectForKeyedSubscript:v125];
                  BOOL v127 = v126 == 0;

                  if (v127)
                  {
                    *a3 = 0;
                    int v13 = [NSString stringWithFormat:@"Error dynamic EQ: missing key '%@' ", v125];
                    goto LABEL_131;
                  }
                }
                uint64_t v122 = [v121 countByEnumeratingWithState:&v348 objects:v358 count:16];
                if (v122) {
                  continue;
                }
                break;
              }
              int v13 = &stru_1F14C9790;
            }
LABEL_131:
          }
          if (!*a3)
          {
LABEL_145:
            uint64_t v19 = v333;
            goto LABEL_149;
          }
          LODWORD(v19) = v333 + 1;
          float v336 = (DspLib::ToneMeister::Parameters *)((char *)v336 + 1);
        }
        while (v336 != v325);
        uint64_t v18 = [(DspLib::ToneMeister::Parameters *)obj countByEnumeratingWithState:&v344 objects:&v353 count:16];
        uint64_t v19 = v323;
        if (!v18)
        {
LABEL_149:
          uint64_t v128 = v19;

          if (*a3)
          {
            uint64_t v309 = &stru_1F14C9790;
          }
          else
          {
            int v129 = @"nil message";
            if (v13) {
              int v129 = v13;
            }
            uint64_t v309 = [NSString stringWithFormat:@"Error for filter %d: %@", v128, v129];
          }

          goto LABEL_155;
        }
      }
    }
    uint64_t v309 = v13;
  }
  else
  {
    *a3 = 0;
    uint64_t v309 = [NSString stringWithFormat:@"Missing key: %@\n", @"Filters"];
  }
LABEL_155:

  if (!*a3)
  {
    UInt32 v133 = v309;
    UInt32 v134 = v133;
    goto LABEL_274;
  }
  uint64_t v130 = 0;
  unsigned int v131 = 1023;
  do
  {
    if (DspLib::ToneMeister::Algorithm::filterIsEnabled(*this, v130)) {
      v131 &= ~(1 << DspLib::ToneMeister::Algorithm::filterGroup(*this, v130));
    }
    uint64_t v130 = (DspLib::ToneMeister::Parameters *)((char *)v130 + 1);
  }
  while (v130 != (DspLib::ToneMeister::Parameters *)50);
  int v132 = 0;
  while (((v131 >> v132) & 1) == 0)
  {
    if (++v132 == 10) {
      goto LABEL_186;
    }
  }
  float v311 = objc_msgSend(NSNumber, "numberWithInt:");
  if (!v311)
  {
LABEL_186:
    uint64_t v153 = 0;
    *a3 = 0;
    UInt32 v134 = @"Error: No group available for filter import. Please free up one group.";
    goto LABEL_273;
  }
  unint64_t v313 = [MEMORY[0x1E4F1CA48] array];
  UInt32 v135 = 0;
  do
  {
    if (!DspLib::ToneMeister::Algorithm::filterIsEnabled(*this, v135))
    {
      uint64_t v136 = [NSNumber numberWithInteger:v135];
      [v313 addObject:v136];
    }
    UInt32 v135 = (DspLib::ToneMeister::Parameters *)((char *)v135 + 1);
  }
  while (v135 != (DspLib::ToneMeister::Parameters *)50);
  if (![v313 count])
  {
    *a3 = 0;
    UInt32 v134 = @"Error: Not a single filter is available for import. Please free up filters.";
    goto LABEL_272;
  }
  id v308 = [(NSDictionary *)v310 objectForKeyedSubscript:@"Global"];
  int v137 = [v308 objectForKeyedSubscript:@"InputGain"];
  int v138 = v137;
  if (v137)
  {
    [v137 floatValue];
    if (v139 != (*(float (**)(DspLib::ToneMeister::Algorithm *, uint64_t))(*(void *)*this + 96))(*this, 4))
    {
      [v138 floatValue];
      (*(void (**)(DspLib::ToneMeister::Algorithm *, uint64_t))(*(void *)*this + 112))(*this, 4);
    }
  }

  id v337 = v308;
  long long v140 = [v337 objectForKeyedSubscript:@"Channels"];
  id v334 = v140;
  if (v140)
  {
    long long v355 = 0u;
    long long v356 = 0u;
    long long v353 = 0u;
    long long v354 = 0u;
    id v141 = v140;
    unsigned int v142 = 0;
    uint64_t v143 = [v141 countByEnumeratingWithState:&v353 objects:v358 count:16];
    if (v143)
    {
      uint64_t v144 = *(void *)v354;
      do
      {
        for (uint64_t m = 0; m != v143; ++m)
        {
          if (*(void *)v354 != v144) {
            objc_enumerationMutation(v141);
          }
          uint64_t v146 = *(void **)(*((void *)&v353 + 1) + 8 * m);
          float v147 = [v141 objectForKeyedSubscript:v146];
          float v148 = [v146 substringFromIndex:2];
          char v149 = [v148 integerValue];

          AudioFormatFlags v150 = [v147 objectForKeyedSubscript:@"Mute"];
          int v151 = [v150 BOOLValue];

          if (v151) {
            int v152 = 1 << (v149 - 1);
          }
          else {
            int v152 = 0;
          }

          v142 |= v152;
        }
        uint64_t v143 = [v141 countByEnumeratingWithState:&v353 objects:v358 count:16];
      }
      while (v143);
    }
  }
  else
  {
    unsigned int v142 = 0;
  }
  (*(void (**)(DspLib::ToneMeister::Algorithm *, uint64_t, float))(*(void *)*this + 112))(*this, 12, (float)v142);

  id v307 = v337;
  AudioFormatFlags v154 = [v307 objectForKeyedSubscript:@"Channels"];
  float v338 = v154;
  if (v154)
  {
    long long v355 = 0u;
    long long v356 = 0u;
    long long v353 = 0u;
    long long v354 = 0u;
    id v155 = v154;
    unsigned int v156 = 0;
    uint64_t v157 = [v155 countByEnumeratingWithState:&v353 objects:v358 count:16];
    if (v157)
    {
      uint64_t v158 = *(void *)v354;
      do
      {
        for (uint64_t n = 0; n != v157; ++n)
        {
          if (*(void *)v354 != v158) {
            objc_enumerationMutation(v155);
          }
          uint64_t v160 = *(void **)(*((void *)&v353 + 1) + 8 * n);
          uint64_t v161 = [v155 objectForKeyedSubscript:v160];
          UInt32 v162 = [v160 substringFromIndex:2];
          char v163 = [v162 integerValue];

          int v164 = [v161 objectForKeyedSubscript:@"PhaseFlip"];
          int v165 = [v164 BOOLValue];

          if (v165) {
            int v166 = 1 << (v163 - 1);
          }
          else {
            int v166 = 0;
          }

          v156 |= v166;
        }
        uint64_t v157 = [v155 countByEnumeratingWithState:&v353 objects:v358 count:16];
      }
      while (v157);
    }
  }
  else
  {
    unsigned int v156 = 0;
  }
  (*(void (**)(DspLib::ToneMeister::Algorithm *, uint64_t, float))(*(void *)*this + 112))(*this, 10, (float)v156);

  [(NSDictionary *)v310 objectForKeyedSubscript:@"Filters"];
  long long v342 = 0u;
  long long v343 = 0u;
  long long v340 = 0u;
  long long v341 = 0u;
  id v312 = (id)objc_claimAutoreleasedReturnValue();
  uint64_t v167 = [v312 countByEnumeratingWithState:&v340 objects:v352 count:16];
  if (!v167)
  {
    uint64_t v315 = 0;
    goto LABEL_269;
  }
  unsigned int v318 = 0;
  uint64_t v314 = *(void *)v341;
  uint64_t v315 = 0;
  do
  {
    uint64_t v324 = 0;
    uint64_t v316 = v167;
    do
    {
      if (*(void *)v341 != v314) {
        objc_enumerationMutation(v312);
      }
      AudioFormatFlags v168 = *(void **)(*((void *)&v340 + 1) + 8 * v324);
      UInt32 v169 = [v168 objectForKeyedSubscript:@"Active"];
      int v170 = [v169 BOOLValue];

      if (!v170)
      {
        uint64_t v315 = (v315 + 1);
        goto LABEL_265;
      }
      uint64_t v171 = [v313 objectAtIndexedSubscript:v318];
      unsigned int v321 = [v171 integerValue];

      uint64_t v172 = [v168 objectForKeyedSubscript:@"Active"];
      int v173 = [v172 BOOLValue];

      AudioFormatFlags v175 = AUToneMeisterParameterImporter::filterTypeStrings(v174);
      uint64_t v176 = [v168 objectForKeyedSubscript:@"Type"];
      unsigned int v320 = [v175 indexOfObject:v176];

      int v317 = DspLib::ToneMeister::Parameters::categoryOfFilterType((DspLib::ToneMeister::Parameters *)v320);
      uint64_t v319 = [v168 objectForKeyedSubscript:@"automation"];
      LODWORD(v175) = [v311 intValue];
      unsigned int v177 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v321, 9);
      (*(void (**)(DspLib::ToneMeister::Algorithm *, void, float))(*(void *)*this + 112))(*this, v177, (float)(int)v175);
      unsigned int v178 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v321, 0);
      if (v173) {
        v179.n128_f32[0] = 3.0;
      }
      else {
        v179.n128_f32[0] = 1.0;
      }
      (*(void (**)(DspLib::ToneMeister::Algorithm *, void, __n128))(*(void *)*this + 112))(*this, v178, v179);
      unsigned int v180 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v321, 1);
      (*(void (**)(DspLib::ToneMeister::Algorithm *, void, float))(*(void *)*this + 112))(*this, v180, (float)v320);
      v322 = v168;
      UInt32 v181 = AUToneMeisterParameterImporter::filterTypeStrings(v322);
      UInt32 v182 = [(AUToneMeisterParameterImporter *)v322 objectForKeyedSubscript:@"Type"];
      uint64_t v332 = (DspLib::ToneMeister::Parameters *)[v181 indexOfObject:v182];

      int v330 = DspLib::ToneMeister::Parameters::categoryOfFilterType(v332);
      UInt32 v183 = [(AUToneMeisterParameterImporter *)v322 objectForKeyedSubscript:@"Channels"];
      long long v355 = 0u;
      long long v356 = 0u;
      long long v353 = 0u;
      long long v354 = 0u;
      id v335 = v183;
      uint64_t v184 = [v335 countByEnumeratingWithState:&v353 objects:v358 count:16];
      if (v184)
      {
        unsigned int v185 = 0;
        unsigned int v186 = 0;
        id obja = *(id *)v354;
        do
        {
          for (iuint64_t i = 0; ii != v184; ++ii)
          {
            if (*(id *)v354 != obja) {
              objc_enumerationMutation(v335);
            }
            float v188 = *(void **)(*((void *)&v353 + 1) + 8 * ii);
            float v339 = [v335 objectForKeyedSubscript:v188];
            float v189 = [v188 substringFromIndex:2];
            char v190 = [v189 integerValue];

            float v191 = (id *)&kDspLibToneMeisterPlistKey_LowPass;
            if (v330 != 5) {
              float v191 = (id *)&kDspLibToneMeisterPlistKey_Filter;
            }
            uint64_t v192 = (id *)&kDspLibToneMeisterPlistKey_PhaseCompensate;
            if (v330 == 5) {
              uint64_t v192 = (id *)&kDspLibToneMeisterPlistKey_HighPass;
            }
            if (v330 == 4)
            {
              float v191 = (id *)&kDspLibToneMeisterPlistKey_Filter;
              uint64_t v192 = (id *)&kDspLibToneMeisterPlistKey_SideChain;
            }
            if (v332 == (DspLib::ToneMeister::Parameters *)10)
            {
              float v191 = (id *)&kDspLibToneMeisterPlistKey_ChannelA;
              unint64_t v193 = (id *)&kDspLibToneMeisterPlistKey_ChannelB;
            }
            else
            {
              unint64_t v193 = v192;
            }
            id v194 = *v191;
            id v195 = *v193;
            float v196 = [v339 objectForKeyedSubscript:v194];
            int v197 = [v196 BOOLValue];

            int v198 = 1 << (v190 - 1);
            if (v197) {
              int v199 = 1 << (v190 - 1);
            }
            else {
              int v199 = 0;
            }
            CFArrayRef v200 = [v339 objectForKeyedSubscript:v195];
            int v201 = [v200 BOOLValue];

            if (v201) {
              int v202 = v198;
            }
            else {
              int v202 = 0;
            }

            v185 |= v199;
            v186 |= v202;
          }
          uint64_t v184 = [v335 countByEnumeratingWithState:&v353 objects:v358 count:16];
        }
        while (v184);
        float v203 = (float)v185;
        float v204 = (float)v186;
      }
      else
      {
        float v203 = 0.0;
        float v204 = 0.0;
      }

      unsigned int v205 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v321, 7);
      (*(void (**)(DspLib::ToneMeister::Algorithm *, void, float))(*(void *)*this + 112))(*this, v205, v203);
      unsigned int v206 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v321, 8);
      (*(void (**)(DspLib::ToneMeister::Algorithm *, void, float))(*(void *)*this + 112))(*this, v206, v204);

      if (DspLib::ToneMeister::Parameters::filterTypeHasQuality((DspLib::ToneMeister::Parameters *)v320))
      {
        uint64_t v207 = [(AUToneMeisterParameterImporter *)v322 objectForKeyedSubscript:@"Quality"];
        [v207 floatValue];
        float v209 = v208;
        unsigned int v210 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v321, 4);
        (*(void (**)(DspLib::ToneMeister::Algorithm *, void, float))(*(void *)*this + 112))(*this, v210, v209);
      }
      HasGaiuint64_t n = DspLib::ToneMeister::Parameters::filterTypeHasGain((DspLib::ToneMeister::Parameters *)v320);
      if (v317 == 4) {
        int v212 = HasGain;
      }
      else {
        int v212 = 1;
      }
      if (v212 == 1)
      {
        float v213 = [(AUToneMeisterParameterImporter *)v322 objectForKeyedSubscript:@"Gain"];
        [v213 floatValue];
        float v215 = v214;
        unsigned int v216 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v321, 2);
        (*(void (**)(DspLib::ToneMeister::Algorithm *, void, float))(*(void *)*this + 112))(*this, v216, v215);
      }
      if (DspLib::ToneMeister::Parameters::filterTypeHasOrder((DspLib::ToneMeister::Parameters *)v320))
      {
        BOOL v217 = [(AUToneMeisterParameterImporter *)v322 objectForKeyedSubscript:@"Order"];
        [v217 floatValue];
        float v219 = v218;
        unsigned int v220 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v321, 5);
        (*(void (**)(DspLib::ToneMeister::Algorithm *, void, float))(*(void *)*this + 112))(*this, v220, v219);
      }
      if (DspLib::ToneMeister::Parameters::filterTypeHasFrequency((DspLib::ToneMeister::Parameters *)v320))
      {
        uint64_t v221 = v322;
        uint64_t v222 = AUToneMeisterParameterImporter::filterTypeStrings(v221);
        uint64_t v223 = [(AUToneMeisterParameterImporter *)v221 objectForKeyedSubscript:@"Type"];
        uint64_t v224 = [v222 indexOfObject:v223];

        if (v224 == 2)
        {
          uint64_t v225 = [(AUToneMeisterParameterImporter *)v221 objectForKeyedSubscript:@"Frequency"];
          uint64_t v242 = [v225 objectAtIndexedSubscript:0];
          [v242 floatValue];
          float v244 = v243;
          unsigned int v245 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v321, 3);
          (*(void (**)(DspLib::ToneMeister::Algorithm *, void, float))(*(void *)*this + 112))(*this, v245, v244);

          unint64_t v238 = [v225 objectAtIndexedSubscript:1];
          [v238 floatValue];
          float v247 = v246;
          unsigned int v248 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v321, 4);
          (*(void (**)(DspLib::ToneMeister::Algorithm *, void, float))(*(void *)*this + 112))(*this, v248, v247);
LABEL_250:
        }
        else
        {
          if (!v224)
          {
            uint64_t v225 = [(AUToneMeisterParameterImporter *)v221 objectForKeyedSubscript:@"Frequency"];
            uint64_t v226 = [v225 objectAtIndexedSubscript:0];
            [v226 floatValue];
            float v228 = v227;
            unsigned int v229 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v321, 3);
            (*(void (**)(DspLib::ToneMeister::Algorithm *, void, float))(*(void *)*this + 112))(*this, v229, v228);

            AudioFormatFlags v230 = [v225 objectAtIndexedSubscript:1];
            [v230 floatValue];
            float v232 = v231;
            unsigned int v233 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v321, 4);
            (*(void (**)(DspLib::ToneMeister::Algorithm *, void, float))(*(void *)*this + 112))(*this, v233, v232);

            unint64_t v234 = [v225 objectAtIndexedSubscript:2];
            [v234 floatValue];
            float v236 = v235;
            unsigned int v237 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v321, 5);
            (*(void (**)(DspLib::ToneMeister::Algorithm *, void, float))(*(void *)*this + 112))(*this, v237, v236);

            unint64_t v238 = [v225 objectAtIndexedSubscript:3];
            [v238 floatValue];
            float v240 = v239;
            unsigned int v241 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v321, 6);
            (*(void (**)(DspLib::ToneMeister::Algorithm *, void, float))(*(void *)*this + 112))(*this, v241, v240);
            goto LABEL_250;
          }
          uint64_t v225 = [(AUToneMeisterParameterImporter *)v221 objectForKeyedSubscript:@"Frequency"];
          [v225 floatValue];
          float v250 = v249;
          unsigned int v251 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v321, 3);
          (*(void (**)(DspLib::ToneMeister::Algorithm *, void, float))(*(void *)*this + 112))(*this, v251, v250);
        }
      }
      if (v320 == 10)
      {
        int64x2_t v252 = [(AUToneMeisterParameterImporter *)v322 objectForKeyedSubscript:@"Phase"];
        [v252 floatValue];
        float v254 = v253;
        unsigned int v255 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v321, 6);
        (*(void (**)(DspLib::ToneMeister::Algorithm *, void, float))(*(void *)*this + 112))(*this, v255, v254);
      }
      if ([v319 count])
      {
        id v256 = v319;
        int v257 = [v256 objectForKeyedSubscript:@"state"];
        uint64_t v258 = 0;
        while (1)
        {
          uint64_t v259 = [NSString stringWithCString:_ZGRN6DspLib11ToneMeister10ParametersL26kAutomatedFilterStateNamesE__3326[v258] encoding:4];
          char v260 = [v257 isEqualToString:v259];

          if (v260) {
            break;
          }
          if (++v258 == 3) {
            goto LABEL_261;
          }
        }
        AUToneMeisterParameterImporter::setValueForAutomationParameter((AUToneMeisterParameterImporter *)this, (float)v258, 1u, v321);
        __int16 v261 = [v256 objectForKeyedSubscript:@"setPointBGain"];
        [v261 floatValue];
        AUToneMeisterParameterImporter::setValueForAutomationParameter((AUToneMeisterParameterImporter *)this, v262, 4u, v321);

        char v263 = [v256 objectForKeyedSubscript:@"setPointBFrequency"];
        [v263 floatValue];
        AUToneMeisterParameterImporter::setValueForAutomationParameter((AUToneMeisterParameterImporter *)this, v264, 5u, v321);

        uint64_t v265 = [v256 objectForKeyedSubscript:@"systemVolumeSetPointA"];
        [v265 floatValue];
        AUToneMeisterParameterImporter::setValueForAutomationParameter((AUToneMeisterParameterImporter *)this, v266, 2u, v321);

        unint64_t v267 = [v256 objectForKeyedSubscript:@"systemVolumeSetPointB"];
        [v267 floatValue];
        AUToneMeisterParameterImporter::setValueForAutomationParameter((AUToneMeisterParameterImporter *)this, v268, 3u, v321);

        unint64_t v269 = [v256 objectForKeyedSubscript:@"systemVolumeSetPointM"];
        [v269 floatValue];
        AUToneMeisterParameterImporter::setValueForAutomationParameter((AUToneMeisterParameterImporter *)this, v270, 7u, v321);

        uint64_t v271 = [v256 objectForKeyedSubscript:@"systemVolumeSetPointM_enable"];
        [v271 floatValue];
        AUToneMeisterParameterImporter::setValueForAutomationParameter((AUToneMeisterParameterImporter *)this, v272, 6u, v321);

        uint64_t v273 = [v256 objectForKeyedSubscript:@"systemVolumeSetPointM_gain"];
        [v273 floatValue];
        AUToneMeisterParameterImporter::setValueForAutomationParameter((AUToneMeisterParameterImporter *)this, v274, 8u, v321);

        unint64_t v275 = [v256 objectForKeyedSubscript:@"systemVolumeSetPointM_frequency"];
        [v275 floatValue];
        AUToneMeisterParameterImporter::setValueForAutomationParameter((AUToneMeisterParameterImporter *)this, v276, 9u, v321);

LABEL_261:
      }
      if (v317 == 4)
      {
        v277 = v322;
        float v278 = [(AUToneMeisterParameterImporter *)v277 objectForKeyedSubscript:@"attackTime"];
        float v279 = [(AUToneMeisterParameterImporter *)v277 objectForKeyedSubscript:@"releaseTime"];
        BOOL v280 = [(AUToneMeisterParameterImporter *)v277 objectForKeyedSubscript:@"enableAttackRelease"];
        vDSP_Length v281 = [(AUToneMeisterParameterImporter *)v277 objectForKeyedSubscript:@"Threshold"];
        unint64_t v282 = [(AUToneMeisterParameterImporter *)v277 objectForKeyedSubscript:@"Ratio"];
        int8x8_t v283 = [(AUToneMeisterParameterImporter *)v277 objectForKeyedSubscript:@"GainRange"];
        unsigned int v284 = DspLib::ToneMeister::Algorithm::dynamicFilterIndex(*this, v321);
        [v278 floatValue];
        float v286 = v285;
        unsigned int v287 = DspLib::ToneMeister::Parameters::dynamicFilterParameter((DspLib::ToneMeister::Parameters *)v284, 0);
        (*(void (**)(DspLib::ToneMeister::Algorithm *, void, float))(*(void *)*this + 112))(*this, v287, v286);
        [v279 floatValue];
        float v289 = v288;
        unsigned int v290 = DspLib::ToneMeister::Parameters::dynamicFilterParameter((DspLib::ToneMeister::Parameters *)v284, 1);
        (*(void (**)(DspLib::ToneMeister::Algorithm *, void, float))(*(void *)*this + 112))(*this, v290, v289);
        [v280 floatValue];
        float v292 = v291;
        unsigned int v293 = DspLib::ToneMeister::Parameters::dynamicFilterParameter((DspLib::ToneMeister::Parameters *)v284, 2);
        (*(void (**)(DspLib::ToneMeister::Algorithm *, void, float))(*(void *)*this + 112))(*this, v293, v292);
        [v281 floatValue];
        float v295 = v294;
        unsigned int v296 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v321, 6);
        (*(void (**)(DspLib::ToneMeister::Algorithm *, void, float))(*(void *)*this + 112))(*this, v296, v295);
        [v282 floatValue];
        float v298 = v297;
        unsigned int v299 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v321, 5);
        (*(void (**)(DspLib::ToneMeister::Algorithm *, void, float))(*(void *)*this + 112))(*this, v299, v298);
        [v283 floatValue];
        float v301 = v300;
        unsigned int v302 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v321, 2);
        (*(void (**)(DspLib::ToneMeister::Algorithm *, void, float))(*(void *)*this + 112))(*this, v302, v301);
      }
      ++v318;
LABEL_265:
      ++v324;
    }
    while (v324 != v316);
    uint64_t v167 = [v312 countByEnumeratingWithState:&v340 objects:v352 count:16];
  }
  while (v167);
LABEL_269:

  char v303 = objc_msgSend(NSString, "stringWithFormat:", @"Successfully imported %lu filters and assigned them to group %d. ", objc_msgSend(v312, "count"), objc_msgSend(v311, "intValue"));

  if (v315)
  {
    char v304 = objc_msgSend(NSString, "stringWithFormat:", @"%d filters were not imported.\n", v315);
    uint64_t v305 = [v303 stringByAppendingString:v304];

    char v303 = (void *)v305;
  }
  uint64_t v309 = v303;

  UInt32 v134 = v309;
LABEL_272:

  uint64_t v153 = v311;
LABEL_273:

  UInt32 v133 = v309;
LABEL_274:

  return v134;
}

void sub_1BB3B1D9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,void *a32)
{
  _Unwind_Resume(a1);
}

id AUToneMeisterParameterImporter::filterTypeStrings(AUToneMeisterParameterImporter *this)
{
  uint64_t v1 = [MEMORY[0x1E4F1CA48] array];
  for (uint64_t i = 0; i != 22; ++i)
  {
    vDSP_Length v3 = [NSString stringWithUTF8String:_ZGRN6DspLib11ToneMeister10ParametersL16kFilterTypeNamesE__3330[i]];
    [v1 addObject:v3];
  }

  return v1;
}

void sub_1BB3B24D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t AUToneMeisterParameterImporter::setValueForAutomationParameter(AUToneMeisterParameterImporter *this, float a2, unsigned int a3, unsigned int a4)
{
  uint64_t v19 = 0;
  uint64_t v8 = a4;
  uint64_t v9 = (*(uint64_t (**)(void))(**(void **)this + 120))(*(void *)this);
  if (DspLib::ToneMeister::Parameters::findAutomationForFilter(v8, v9, (unint64_t *)&v19, v10))
  {
    uint64_t v11 = v19;
    uint64_t v12 = a3;
  }
  else
  {
    int v13 = 0;
    while (1)
    {
      uint64_t v14 = (*(uint64_t (**)(void))(**(void **)this + 120))();
      if (!vcvtas_u32_f32(*(float *)(v14 + 4 * DspLib::ToneMeister::Parameters::automationParameterForSlot(v13, 1)))) {
        break;
      }
      int v13 = (DspLib::ToneMeister::Parameters *)((char *)v13 + 1);
      if (v13 == (DspLib::ToneMeister::Parameters *)10)
      {
        int v13 = 0;
        while (1)
        {
          uint64_t v15 = (*(uint64_t (**)(void))(**(void **)this + 120))();
          uint64_t result = DspLib::ToneMeister::Parameters::automationParameterForSlot(v13, 1);
          if (vcvtas_u32_f32(*(float *)(v15 + 4 * result)) == 1) {
            break;
          }
          int v13 = (DspLib::ToneMeister::Parameters *)((char *)v13 + 1);
          if (v13 == (DspLib::ToneMeister::Parameters *)10) {
            return result;
          }
        }
        break;
      }
    }
    unsigned int v17 = DspLib::ToneMeister::Parameters::automationParameterForSlot(v13, 0);
    (*(void (**)(void, void, float))(**(void **)this + 112))(*(void *)this, v17, (float)a4);
    uint64_t v12 = a3;
    uint64_t v11 = v13;
  }
  unsigned int v18 = DspLib::ToneMeister::Parameters::automationParameterForSlot(v11, v12);
  return (*(uint64_t (**)(void, void, float))(**(void **)this + 112))(*(void *)this, v18, a2);
}

uint64_t VoiceProcessorV2::SaveFilesWriteSignal(uint64_t this, unsigned int a2, uint64_t a3, const AudioBufferList *a4, AudioTimeStamp *a5)
{
  if (!*(_DWORD *)(this + 12640)) {
    return this;
  }
  uint64_t v9 = this;
  unint64_t v10 = a2;
  this = VoiceProcessorV2::QuerySaveFileAtIndexthroughFileSavingKey((VoiceProcessorV2 *)this, a2);
  if (!this) {
    return this;
  }
  this = VoiceProcessorV2::SignalIsInFrequencyDomain((VoiceProcessorV2 *)v9, v10);
  if (this)
  {
    uint64_t v35 = 0;
    long long v33 = 0u;
    long long v34 = 0u;
    this = VoiceProcessorV2::GetSignalSaveFileFormatForIndex((uint64_t)&v33, (VoiceProcessorV2 *)v9, v10, 0.0, v11);
    UInt32 mNumberBuffers = HIDWORD(v34);
    if (HIDWORD(v34) != (uint64_t)(*(void *)(*(void *)(v9 + 14016) + 24 * v10 + 8)
                                 - *(void *)(*(void *)(v9 + 14016) + 24 * v10)) >> 3)
      return this;
    unint64_t v13 = v9 + 8 * v10;
    uint64_t v14 = *(UInt32 **)(v13 + 14040);
    if (!v14 || *(_DWORD *)(v9 + 508) < a3) {
      return this;
    }
    float v31 = a5;
    uint64_t v15 = (const AudioBufferList **)(v13 + 14040);
    UInt32 v16 = *v14;
    if (a4->mNumberBuffers < HIDWORD(v34)) {
      UInt32 mNumberBuffers = a4->mNumberBuffers;
    }
    if (v16 < mNumberBuffers) {
      UInt32 mNumberBuffers = v16;
    }
    if (mNumberBuffers)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8 * mNumberBuffers;
      uint64_t v19 = 16;
      do
      {
        v32.int realp = *(float **)((char *)&a4->mNumberBuffers + v19);
        v32.imagp = &v32.realp[a3];
        this = VPTimeFreqConverter::Synthesize(*(VPTimeFreqConverter **)(*(void *)(*(void *)(v9 + 14016) + 24 * v10) + v17), &v32, *(float **)((char *)&(*v15)->mNumberBuffers + v19));
        v17 += 8;
        v19 += 16;
      }
      while (v18 != v17);
    }
    unint64_t v20 = v9 + 8 * v10;
    if (!*(void *)(v20 + 12944)) {
      return this;
    }
    this = vp::Audio_Capture::write_async((vp::Audio_Capture *)(v20 + 12944), *v15, v31, a3, &v32);
    int realp = (int)v32.realp;
    int v22 = BYTE4(v32.realp);
  }
  else
  {
    unint64_t v23 = v9 + 8 * v10;
    if (!*(void *)(v23 + 12944)) {
      return this;
    }
    this = vp::Audio_Capture::write_async((vp::Audio_Capture *)(v23 + 12944), a4, a5, a3, &v33);
    int realp = v33;
    int v22 = BYTE4(v33);
  }
  BOOL v24 = v22 == 0;
  BOOL v25 = v22 != 0;
  if (!v24) {
    int realp = 0;
  }
  if (!v25)
  {
    uint64_t v26 = 0;
    CFStringRef v27 = "badsavefile";
    uint64_t v28 = kVPSaveFileIndexToCodeArray_v2;
    while (1)
    {
      int v29 = *v28;
      v28 += 4;
      if (v29 == a2) {
        break;
      }
      if (++v26 == 134) {
        goto LABEL_27;
      }
    }
    CFStringRef v27 = *(const char **)&kVPSaveFileIndexToCodeArray_v2[4 * v26 + 2];
LABEL_27:
    if (a2 > 3) {
      float v30 = 21.003;
    }
    else {
      float v30 = flt_1BB87C0C0[v10];
    }
    return VoiceProcessorV2::LogIOError(v9, v30, (float)*(unsigned int *)(v9 + 12512), (float)*(unsigned int *)(v9 + 12516), 0.0, "err-%d writing %s", realp, v27);
  }
  return this;
}

BOOL VoiceProcessorV2::QuerySaveFileAtIndexthroughFileSavingKey(VoiceProcessorV2 *this, unint64_t a2)
{
  char v2 = a2 - 68;
  if (a2 - 68 <= 0x2D)
  {
    if (((1 << v2) & 0x181801F) != 0)
    {
LABEL_12:
      BOOL v6 = *((_DWORD *)this + 3160) == 0;
      return !v6;
    }
    if (((1 << v2) & 0x380000000000) != 0)
    {
LABEL_4:
      unsigned int v3 = *((_DWORD *)this + 3160);
      return v3 > 0x10 || (v3 & 0xFFFFFFFC) == 4;
    }
  }
  if (a2 > 0x3D) {
    goto LABEL_4;
  }
  if (((1 << a2) & 0x201E020000000003) != 0) {
    goto LABEL_12;
  }
  if (((1 << a2) & 0x40000000010) == 0)
  {
    if (a2 != 47) {
      goto LABEL_4;
    }
    unsigned int v9 = *((_DWORD *)this + 3160);
    if (v9 <= 0xD && v9 - 3 > 4) {
      return 0;
    }
    BOOL v6 = *((void *)this + 249) == 0;
    return !v6;
  }
  unsigned int v7 = *((_DWORD *)this + 3160);
  return v7 > 0xA || v7 - 2 < 6;
}

BOOL VoiceProcessorV2::SignalIsInFrequencyDomain(VoiceProcessorV2 *this, unint64_t a2)
{
  BOOL result = 1;
  if (a2 - 93 > 0x28 || ((1 << (a2 - 93)) & 0x1FC0001FDBDLL) == 0)
  {
    if (a2 <= 0x27)
    {
      if (((1 << a2) & 0x700FFC0C00) != 0) {
        return result;
      }
      if (a2 == 39 && !*((unsigned char *)this + 2083)) {
        return *((unsigned char *)this + 2085) == 0;
      }
    }
    return 0;
  }
  return result;
}

uint64_t VoiceProcessorV2::GetSignalSaveFileFormatForIndex(uint64_t this, VoiceProcessorV2 *a2, uint64_t a3, double a4, double a5)
{
  uint64_t v5 = this;
  switch(a3)
  {
    case 0:
      BOOL v6 = (char *)a2 + 584;
      uint64_t v7 = *((void *)a2 + 77);
      goto LABEL_3;
    case 1:
      long long v18 = *((_OWORD *)a2 + 40);
      *(_OWORD *)this = *((_OWORD *)a2 + 39);
      *(_OWORD *)(this + 16) = v18;
      uint64_t v12 = *((void *)a2 + 82);
      goto LABEL_39;
    case 2:
      long long v19 = *((_OWORD *)a2 + 45);
      *(_OWORD *)this = *((_OWORD *)a2 + 44);
      *(_OWORD *)(this + 16) = v19;
      uint64_t v12 = *((void *)a2 + 92);
      goto LABEL_39;
    case 3:
      BOOL v6 = (char *)a2 + 744;
      uint64_t v7 = *((void *)a2 + 97);
      goto LABEL_3;
    case 4:
      long long v20 = *((_OWORD *)a2 + 50);
      *(_OWORD *)this = *((_OWORD *)a2 + 49);
      *(_OWORD *)(this + 16) = v20;
      uint64_t v12 = *((void *)a2 + 102);
      goto LABEL_39;
    case 5:
    case 74:
      BOOL v6 = (char *)a2 + 824;
      uint64_t v7 = *((void *)a2 + 107);
      goto LABEL_3;
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 75:
    case 76:
    case 77:
    case 78:
    case 99:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 114:
    case 124:
      double v9 = *((double *)a2 + 103);
      goto LABEL_5;
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 79:
    case 80:
    case 81:
    case 82:
    case 93:
    case 94:
    case 95:
    case 96:
    case 97:
    case 98:
    case 110:
    case 122:
    case 127:
    case 128:
    case 129:
    case 130:
    case 133:
      BOOL v6 = (char *)a2 + 904;
      uint64_t v7 = *((void *)a2 + 117);
      goto LABEL_3;
    case 47:
    case 48:
      long long v16 = *((_OWORD *)a2 + 60);
      *(_OWORD *)this = *((_OWORD *)a2 + 59);
      *(_OWORD *)(this + 16) = v16;
      uint64_t v12 = *((void *)a2 + 122);
      goto LABEL_39;
    case 49:
      BOOL v6 = (char *)a2 + 984;
      uint64_t v7 = *((void *)a2 + 127);
      goto LABEL_3;
    case 50:
    case 57:
    case 60:
    case 65:
    case 68:
    case 84:
    case 115:
    case 117:
    case 119:
    case 125:
      BOOL v6 = (char *)a2 + 328;
      uint64_t v7 = *((void *)a2 + 45);
LABEL_3:
      *(void *)(this + 32) = v7;
      long long v8 = *((_OWORD *)v6 + 1);
      *(_OWORD *)this = *(_OWORD *)v6;
      *(_OWORD *)(this + 16) = v8;
      return this;
    case 51:
      long long v21 = *((_OWORD *)a2 + 14);
      *(_OWORD *)this = *((_OWORD *)a2 + 13);
      *(_OWORD *)(this + 16) = v21;
      uint64_t v12 = *((void *)a2 + 30);
      goto LABEL_39;
    case 53:
      uint64_t v13 = *((void *)a2 + 41);
      if (*((unsigned char *)a2 + 2244)) {
        unsigned int v14 = *((_DWORD *)a2 + 89);
      }
      else {
        unsigned int v14 = 1;
      }
      this = VoiceProcessorV2::GetDynamicsDSPChannelCount(a2);
      goto LABEL_22;
    case 54:
    case 85:
    case 86:
    case 87:
    case 88:
    case 116:
    case 123:
      long long v11 = *((_OWORD *)a2 + 19);
      *(_OWORD *)this = *((_OWORD *)a2 + 18);
      *(_OWORD *)(this + 16) = v11;
      uint64_t v12 = *((void *)a2 + 40);
      goto LABEL_39;
    case 55:
    case 89:
    case 118:
    case 120:
    case 121:
      uint64_t v13 = *((void *)a2 + 41);
      if (*((unsigned char *)a2 + 2244)) {
        unsigned int v14 = *((_DWORD *)a2 + 89);
      }
      else {
        unsigned int v14 = 1;
      }
      this = VoiceProcessorV2::GetFarEndVoiceMixChannelCount(a2);
LABEL_22:
      if (v14 <= this) {
        unsigned int v15 = this;
      }
      else {
        unsigned int v15 = v14;
      }
      *(void *)uint64_t v5 = v13;
      goto LABEL_26;
    case 56:
    case 64:
      uint64_t v17 = *((void *)a2 + 41);
      this = VoiceProcessorV2::GetDynamicsDSPChannelCount(a2);
      *(void *)uint64_t v5 = v17;
      *(_OWORD *)(v5 + 8) = xmmword_1BB8727B0;
      *(_DWORD *)(v5 + 24) = 4;
      *(_DWORD *)(v5 + 28) = this;
      goto LABEL_27;
    case 58:
    case 59:
    case 66:
    case 67:
    case 126:
      unsigned int v15 = *((_DWORD *)a2 + 1075);
      if (v15 <= 1) {
        unsigned int v15 = 1;
      }
      *(void *)this = *((void *)a2 + 41);
LABEL_26:
      *(_OWORD *)(v5 + 8) = xmmword_1BB8727B0;
      *(_DWORD *)(v5 + 24) = 4;
      *(_DWORD *)(v5 + 28) = v15;
LABEL_27:
      *(void *)(v5 + 32) = 32;
      return this;
    case 61:
    case 62:
    case 63:
    case 111:
    case 112:
    case 113:
      double v9 = *((double *)a2 + 41);
      goto LABEL_5;
    case 69:
      long long v22 = *((_OWORD *)a2 + 94);
      *(_OWORD *)this = *((_OWORD *)a2 + 93);
      *(_OWORD *)(this + 16) = v22;
      uint64_t v12 = *((void *)a2 + 190);
LABEL_39:
      *(void *)(this + 32) = v12;
      return this;
    case 83:
      int v23 = *((_DWORD *)a2 + 85);
      unsigned int v24 = *((_DWORD *)a2 + 89);
      uint64_t v25 = *((void *)a2 + 45);
      if (v24 >= 2) {
        int v26 = 2;
      }
      else {
        int v26 = *((_DWORD *)a2 + 89);
      }
      if ((v23 & 0x20) != 0)
      {
        unsigned int v24 = 1;
      }
      else if (!v24)
      {
        unsigned int v27 = (v25 + 7) >> 3;
        goto LABEL_51;
      }
      unsigned int v27 = *((_DWORD *)a2 + 88) / v24;
LABEL_51:
      if ((v23 & 0x20) != 0) {
        int v28 = 1;
      }
      else {
        int v28 = v26;
      }
      int v29 = v27 * v28;
      *(void *)this = *((void *)a2 + 41);
      *(_DWORD *)(this + 8) = *((_DWORD *)a2 + 84);
      *(_DWORD *)(this + 12) = v23;
      *(_DWORD *)(this + 16) = v29;
      *(_DWORD *)(this + 20) = 1;
      *(_DWORD *)(this + 24) = v29;
      *(_DWORD *)(this + 28) = v26;
      *(void *)(this + 32) = v25;
      return this;
    case 90:
      LODWORD(a5) = *((_DWORD *)a2 + 127);
      double v9 = (*((double *)a2 + 103) + *((double *)a2 + 103)) / (double)*(unint64_t *)&a5;
LABEL_5:
      *(double *)this = v9;
      *(_OWORD *)(this + 8) = xmmword_1BB8727B0;
      long long v10 = xmmword_1BB8727C0;
      goto LABEL_6;
    case 105:
    case 106:
    case 107:
    case 108:
      *(void *)this = *((void *)a2 + 103);
      *(_OWORD *)(this + 8) = xmmword_1BB8727B0;
      long long v10 = xmmword_1BB879E80;
      goto LABEL_6;
    case 109:
      *(void *)this = *((void *)a2 + 103);
      *(_OWORD *)(this + 8) = xmmword_1BB8727B0;
      long long v10 = xmmword_1BB879EA0;
      goto LABEL_6;
    case 131:
    case 132:
      *(void *)this = *((void *)a2 + 103);
      *(_OWORD *)(this + 8) = xmmword_1BB8727B0;
      long long v10 = xmmword_1BB879E90;
LABEL_6:
      *(_OWORD *)(this + 24) = v10;
      return this;
    default:
      *(void *)(this + 32) = 0;
      *(_OWORD *)this = 0u;
      *(_OWORD *)(this + 16) = 0u;
      return this;
  }
}

CFMutableDictionaryRef VoiceProcessorV2::SaveFilesPrepare(VoiceProcessorV2 *this)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  char v2 = (char *)this + 15180;
  *((void *)this + 1613) = CATimeUtilities::GetCurrentGregorianDate(this);
  *((void *)this + 1614) = v4;
  *((_DWORD *)this + 3160) = 0;
  *(_OWORD *)((char *)this + 12920) = 0u;
  *(_DWORD *)((char *)this + 12935) = 0;
  if (queryBuildType(void)::once != -1) {
    dispatch_once(&queryBuildType(void)::once, &__block_literal_global_99);
  }
  if (gIsInternal || gIsCarrier)
  {
    if (v2[1060])
    {
      *((_DWORD *)this + 3160) = *((_DWORD *)this + 3161);
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      uint64_t v5 = (void *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
      {
        BOOL v6 = (*v5 ? *v5 : MEMORY[0x1E4F14500]);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
        {
          gid_t v7 = *((_DWORD *)this + 3160);
          buf.st_dev = 136315650;
          *(void *)&buf.st_mode = "vpDebug_FileSaving.cpp";
          WORD2(buf.st_ino) = 1024;
          *(_DWORD *)((char *)&buf.st_ino + 6) = 605;
          HIWORD(buf.st_uid) = 1024;
          buf.st_gid = v7;
          _os_log_impl(&dword_1BB0CE000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> Simulator override file saving level: %d", (uint8_t *)&buf, 0x18u);
        }
      }
      long long v8 = (int *)*((void *)this + 1578);
      if (v8 && (v2[781] || v2[782]))
      {
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        CALegacyLog::log(v8, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_FileSaving.cpp", 605, "SaveFilesPrepare", "Simulator override file saving level: %d", *((_DWORD *)this + 3160));
      }
    }
    else
    {
      std::__fs::filesystem::path::path[abi:ne180100]<char [16],void>((std::string *)&buf, "/usr/local/lib/");
      unint64_t v10 = vp::utility::CASuperBowl((vp::utility *)&buf, v9);
      if (SHIBYTE(buf.st_gid) < 0) {
        operator delete(*(void **)&buf.st_dev);
      }
      if ((v10 & 0xFF00000000) != 0)
      {
        *((_DWORD *)this + 3160) = v10;
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        long long v11 = (void *)VPLogScope(void)::scope;
        if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
        {
          uint64_t v12 = (*v11 ? *v11 : MEMORY[0x1E4F14500]);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
          {
            gid_t v13 = *((_DWORD *)this + 3160);
            buf.st_dev = 136315650;
            *(void *)&buf.st_mode = "vpDebug_FileSaving.cpp";
            WORD2(buf.st_ino) = 1024;
            *(_DWORD *)((char *)&buf.st_ino + 6) = 599;
            HIWORD(buf.st_uid) = 1024;
            buf.st_gid = v13;
            _os_log_impl(&dword_1BB0CE000, v12, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> magic file exists, enabling file saving level %d", (uint8_t *)&buf, 0x18u);
          }
        }
        unsigned int v14 = (int *)*((void *)this + 1578);
        if (v14 && (v2[781] || v2[782]))
        {
          if (VPLogScope(void)::once != -1) {
            dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
          }
          CALegacyLog::log(v14, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_FileSaving.cpp", 599, "SaveFilesPrepare", "magic file exists, enabling file saving level %d", *((_DWORD *)this + 3160));
        }
      }
    }
    if (*((_DWORD *)this + 3160))
    {
LABEL_57:
      CFRetain(@"com.apple.coreaudio");
      CFStringRef v19 = (const __CFString *)CFPreferencesCopyAppValue(@"vp_save_files_dir", @"com.apple.coreaudio");
      CFStringRef v20 = v19;
      if (v19)
      {
        CFStringGetCString(v19, (char *)this + 12648, 256, 0x600u);
        CFRelease(v20);
      }
      else
      {
        long long v21 = (char *)this + 16248;
        if (v2[1091] < 0) {
          long long v21 = *(const char **)v21;
        }
        size_t v22 = strlen(v21);
        strlcpy((char *)this + 12648, v21, v22 + 1);
      }
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      int v23 = (void *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
      {
        unsigned int v24 = (*v23 ? *v23 : MEMORY[0x1E4F14500]);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
        {
          buf.st_dev = 136315650;
          *(void *)&buf.st_mode = "vpDebug_FileSaving.cpp";
          WORD2(buf.st_ino) = 1024;
          *(_DWORD *)((char *)&buf.st_ino + 6) = 495;
          HIWORD(buf.st_uid) = 2080;
          *(void *)&buf.st_gid = (char *)this + 12648;
          _os_log_impl(&dword_1BB0CE000, v24, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> audio recordings available in %s", (uint8_t *)&buf, 0x1Cu);
        }
      }
      uint64_t v25 = (int *)*((void *)this + 1578);
      if (v25 && (v2[781] || v2[782]))
      {
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        CALegacyLog::log(v25, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_FileSaving.cpp", 495, "SetSaveFilesDirectory", "audio recordings available in %s", (const char *)this + 12648);
      }
      int v26 = (int **)((char *)this + 12624);
      if (stat((const char *)this + 12648, &buf) == -1 && mkpath_np((const char *)this + 12648, 0x1FFu))
      {
        *((_DWORD *)this + 3160) = 0;
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        unsigned int v27 = (void *)VPLogScope(void)::scope;
        if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
        {
          int v28 = (*v27 ? *v27 : MEMORY[0x1E4F14500]);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long v33 = 136315650;
            long long v34 = "vpDebug_FileSaving.cpp";
            __int16 v35 = 1024;
            int v36 = 506;
            __int16 v37 = 2080;
            float v38 = (char *)this + 12648;
            _os_log_impl(&dword_1BB0CE000, v28, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> file saving turned OFF! recording directory %s cannot be created", v33, 0x1Cu);
          }
        }
        int v29 = *v26;
        if (*v26 && (v2[781] || v2[782]))
        {
          if (VPLogScope(void)::once != -1)
          {
            DSPSplitComplex v32 = *v26;
            dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
            int v29 = v32;
          }
          CALegacyLog::log(v29, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_FileSaving.cpp", 506, "SetSaveFilesDirectory", "file saving turned OFF! recording directory %s cannot be created", (const char *)this + 12648);
        }
      }
      VPGetSaveFileNameForIndex((std::string *)&buf, (char *)this + 12648, 91, 1, (uint64_t)this + 12904);
      operator new();
    }
    if (PlatformUtilities_iOS::IsTelephonyCaptureAllowed())
    {
      *((_DWORD *)this + 3160) = 1;
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      unsigned int v15 = (void *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
      {
        long long v16 = (*v15 ? *v15 : MEMORY[0x1E4F14500]);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          gid_t v17 = *((_DWORD *)this + 3160);
          buf.st_dev = 136315650;
          *(void *)&buf.st_mode = "vpDebug_FileSaving.cpp";
          WORD2(buf.st_ino) = 1024;
          *(_DWORD *)((char *)&buf.st_ino + 6) = 615;
          HIWORD(buf.st_uid) = 1024;
          buf.st_gid = v17;
          _os_log_impl(&dword_1BB0CE000, v16, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> master default exists, enabling file saving level %d", (uint8_t *)&buf, 0x18u);
        }
      }
      long long v18 = (int *)*((void *)this + 1578);
      if (v18 && (v2[781] || v2[782]))
      {
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        CALegacyLog::log(v18, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_FileSaving.cpp", 615, "SaveFilesPrepare", "master default exists, enabling file saving level %d", *((_DWORD *)this + 3160));
      }
    }
  }
  if (*((_DWORD *)this + 3160)) {
    goto LABEL_57;
  }
  v33[0] = 0;
  VoiceProcessorV2::ReadDefaultsOverride(@"vp_save_timestamps", 0, (BOOL *)v33, 0, v3);
  if (v33[0])
  {
    if (*((_DWORD *)this + 3160))
    {
      VPGetSaveFileNameForIndex((std::string *)&buf, (char *)this + 12648, 92, 1, (uint64_t)this + 12904);
      operator new();
    }
    operator new();
  }
  bzero((char *)this + 14040, 0x430uLL);
  CFAllocatorRef v30 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  *((void *)this + 1892) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  *((_DWORD *)this + 3780) = 0;
  CFMutableDictionaryRef result = CFDictionaryCreateMutable(v30, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  *((void *)this + 1891) = result;
  *((_DWORD *)this + 3790) = 0;
  *((void *)this + 1894) = 0;
  *((void *)this + 1896) = 0;
  *((_DWORD *)this + 3794) = 0;
  *char v2 = 0;
  *((void *)this + 1898) = 0;
  *((_DWORD *)this + 3798) = 0;
  v2[16] = 0;
  return result;
}

void sub_1BB3B3974(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  MEMORY[0x1C185D370](v20, 0x1020C40D5A9D86FLL);
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

std::string *VPGetSaveFileNameForIndex(std::string *a1, char *a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  long long v18 = a2;
  long long v21 = 0u;
  long long v22 = 0u;
  *(_OWORD *)__str = 0u;
  long long v20 = 0u;
  snprintf(__str, 0x40uLL, "%d%02d%02d.%02d%02d%02d", *(_DWORD *)a5, *(char *)(a5 + 4), *(char *)(a5 + 5), *(char *)(a5 + 6), *(char *)(a5 + 7), (int)*(double *)(a5 + 8));
  std::__fs::filesystem::path::path[abi:ne180100]<char const*,void>(a1, &v18);
  std::__fs::filesystem::path::append[abi:ne180100]<char [8]>(a1, "vp.");
  long long v8 = (char *)&v18 + 7;
  while (*++v8)
    ;
  std::string::append[abi:ne180100]<char const*,0>(a1, __str, v8);
  std::string::append(a1, ".xxx.", 5uLL);
  uint64_t v10 = 0;
  long long v11 = "badsavefile";
  uint64_t v12 = kVPSaveFileIndexToCodeArray_v2;
  while (1)
  {
    int v13 = *v12;
    v12 += 4;
    if (v13 == a3) {
      break;
    }
    if (++v10 == 134) {
      goto LABEL_8;
    }
  }
  long long v11 = *(const char **)&kVPSaveFileIndexToCodeArray_v2[4 * v10 + 2];
LABEL_8:
  size_t v14 = strlen(v11);
  std::string::append(a1, v11, v14);
  std::string::append(a1, ".", 1uLL);
  unsigned int v15 = VPGetSaveFileNameForIndex(char const*,unsigned long long,vpSaveFileType,CATimeUtilities::GregorianDate const&)::kFileNameExtention[a4];
  size_t v16 = strlen(v15);
  return std::string::append(a1, v15, v16);
}

void sub_1BB3B3B54(_Unwind_Exception *exception_object)
{
}

void *CADeprecated::CAAutoDelete<CALegacyLog>::set(void *result, uint64_t a2)
{
  uint64_t v2 = *result;
  if (*result != a2)
  {
    uint64_t v4 = result;
    if (v2)
    {
      uint64_t v5 = *(FILE **)(v2 + 8);
      if (v5)
      {
        fclose(v5);
        *(void *)(v2 + 8) = 0;
      }
      CFMutableDictionaryRef result = (void *)MEMORY[0x1C185D370](v2, 0x1020C40D5A9D86FLL);
    }
    void *v4 = a2;
  }
  return result;
}

void VoiceProcessorV2::SaveFilesInitialize(VoiceProcessorV2 *this)
{
  uint64_t v2 = (char *)*((void *)this + 1753);
  unsigned int v3 = (char *)*((void *)this + 1752);
  if (v2 != v3)
  {
    do
    {
      v2 -= 24;
      *(void *)&long long v31 = v2;
      std::vector<std::unique_ptr<VPTimeFreqConverter>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v31);
    }
    while (v2 != v3);
    uint64_t v2 = (char *)*((void *)this + 1752);
  }
  *((void *)this + 1753) = v3;
  uint64_t v4 = (char *)(v3 - v2);
  unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * ((v3 - v2) >> 3);
  if (v5 > 0x85)
  {
    if (v4 != (char *)3216)
    {
      CFStringRef v19 = v2 + 3216;
      while (v3 != v19)
      {
        v3 -= 24;
        *(void *)&long long v31 = v3;
        std::vector<std::unique_ptr<VPTimeFreqConverter>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v31);
      }
      *((void *)this + 1753) = v19;
    }
    goto LABEL_27;
  }
  uint64_t v6 = *((void *)this + 1754);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - (uint64_t)v3) >> 3) >= 134 - v5)
  {
    bzero(v3, 24 * ((3192 - (uint64_t)v4) / 0x18uLL) + 24);
    *((void *)this + 1753) = &v3[24 * ((3192 - (uint64_t)v4) / 0x18uLL) + 24];
    goto LABEL_27;
  }
  unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * ((v6 - (uint64_t)v2) >> 3);
  unint64_t v8 = 0x5555555555555556 * ((v6 - (uint64_t)v2) >> 3);
  if (v8 <= 0x86) {
    unint64_t v8 = 134;
  }
  if (v7 >= 0x555555555555555) {
    unint64_t v9 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v9 = v8;
  }
  if (v9 > 0xAAAAAAAAAAAAAAALL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  uint64_t v10 = 3 * v9;
  long long v11 = (char *)operator new(24 * v9);
  uint64_t v12 = &v11[8 * ((v3 - v2) >> 3)];
  int v13 = &v11[8 * v10];
  size_t v14 = 24 * ((3192 - (uint64_t)v4) / 0x18uLL) + 24;
  bzero(v12, v14);
  unsigned int v15 = &v12[v14];
  if (v3 == v2)
  {
    *((void *)this + 1752) = v12;
    *((void *)this + 1753) = v15;
    *((void *)this + 1754) = v13;
    if (!v3) {
      goto LABEL_27;
    }
  }
  else
  {
    do
    {
      size_t v16 = v12;
      *((void *)v12 - 1) = 0;
      long long v17 = *(_OWORD *)(v3 - 24);
      v3 -= 24;
      *(_OWORD *)(v12 - 24) = v17;
      v12 -= 24;
      *((void *)v16 - 1) = *((void *)v3 + 2);
      *(void *)unsigned int v3 = 0;
      *((void *)v3 + 1) = 0;
      *((void *)v3 + 2) = 0;
    }
    while (v3 != v2);
    long long v18 = (char *)*((void *)this + 1752);
    unsigned int v3 = (char *)*((void *)this + 1753);
    *((void *)this + 1752) = v12;
    *((void *)this + 1753) = v15;
    *((void *)this + 1754) = v13;
    if (v3 != v18)
    {
      do
      {
        v3 -= 24;
        *(void *)&long long v31 = v3;
        std::vector<std::unique_ptr<VPTimeFreqConverter>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v31);
      }
      while (v3 != v18);
      unsigned int v3 = v18;
    }
    if (!v3) {
      goto LABEL_27;
    }
  }
  operator delete(v3);
LABEL_27:
  uint64_t v20 = 0;
  for (unint64_t i = 0; i != 134; ++i)
  {
    if (VoiceProcessorV2::SignalIsInFrequencyDomain(this, i))
    {
      uint64_t v33 = 0;
      long long v31 = 0u;
      long long v32 = 0u;
      VoiceProcessorV2::GetSignalSaveFileFormatForIndex((uint64_t)&v31, this, i, 0.0, v22);
      std::vector<std::unique_ptr<VPTimeFreqConverter>>::resize((long long *)(*((void *)this + 1752) + v20), HIDWORD(v32));
    }
    v20 += 24;
  }
  if (*((_DWORD *)this + 3160))
  {
    if (*((unsigned char *)this + 476))
    {
      VoiceProcessorV2::CreateSignalSaveFiles(this, 1);
      if (*((_DWORD *)this + 3160))
      {
        if (*((void *)this + 1894)) {
          goto LABEL_49;
        }
        size_t v23 = 4 * *((unsigned int *)this + 3786) * (unint64_t)*((unsigned int *)this + 3787);
        unsigned int v24 = malloc_type_malloc(v23, 0x2C8E6D5CuLL);
        if (v24) {
          BOOL v25 = 1;
        }
        else {
          BOOL v25 = v23 == 0;
        }
        if (!v25)
        {
LABEL_46:
          exceptiouint64_t n = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
          CFAllocatorRef v30 = std::bad_alloc::bad_alloc(exception);
        }
        int v26 = v24;
        bzero(v24, v23);
        *((void *)this + 1894) = v26;
        if (*((_DWORD *)this + 3160))
        {
LABEL_49:
          if (!*((void *)this + 1896))
          {
            unsigned int v27 = malloc_type_malloc(0x30D40uLL, 0x2C8E6D5CuLL);
            if (!v27) {
              goto LABEL_46;
            }
            int v28 = v27;
            bzero(v27, 0x30D40uLL);
            *((void *)this + 1896) = v28;
          }
        }
      }
    }
  }
}

void VoiceProcessorV2::CreateSignalSaveFiles(VoiceProcessorV2 *this, int a2)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (char *)this + 12908;
  if (a2 == 1)
  {
    if (!*((unsigned char *)this + 12936)) {
      goto LABEL_15;
    }
    unsigned int v5 = *((_DWORD *)this + 3231) + 1;
    *((_DWORD *)this + 3231) = v5;
    *((unsigned char *)this + 12936) = 0;
    unsigned int v6 = *((_DWORD *)this + 3230);
    if (v6 >= v5)
    {
      if (v5 < v6) {
        *((_DWORD *)this + 3231) = v6;
      }
      goto LABEL_15;
    }
  }
  else if (a2 == 3)
  {
    if (!*((unsigned char *)this + 12938)) {
      goto LABEL_15;
    }
    unsigned int v5 = *((_DWORD *)this + 3233) + 1;
    *((_DWORD *)this + 3233) = v5;
    *((unsigned char *)this + 12938) = 0;
    unsigned int v8 = *((_DWORD *)this + 3230);
    if (v8 >= v5)
    {
      if (v5 < v8) {
        *((_DWORD *)this + 3233) = v8;
      }
      goto LABEL_15;
    }
  }
  else
  {
    if (a2 != 2 || !*((unsigned char *)this + 12937)) {
      goto LABEL_15;
    }
    unsigned int v5 = *((_DWORD *)this + 3232) + 1;
    *((_DWORD *)this + 3232) = v5;
    *((unsigned char *)this + 12937) = 0;
    unsigned int v7 = *((_DWORD *)this + 3230);
    if (v7 >= v5)
    {
      if (v5 < v7) {
        *((_DWORD *)this + 3232) = v7;
      }
      goto LABEL_15;
    }
  }
  *((_DWORD *)this + 3230) = v5;
LABEL_15:
  memset(__str, 0, sizeof(__str));
  snprintf((char *)__str, 0x40uLL, "%d%02d%02d.%02d%02d%02d.%03u", *((_DWORD *)this + 3226), *v4, *((char *)this + 12909), *((char *)this + 12910), *((char *)this + 12911), (int)*((double *)this + 1614), *((_DWORD *)this + 3230));
  memset(&v43, 0, sizeof(v43));
  std::__fs::filesystem::path::path[abi:ne180100]<char [12],void>(&v42, (char *)this + 12648);
  std::__fs::filesystem::path::append[abi:ne180100]<char [8]>(&v42, "vp.");
  unint64_t v9 = (char *)&v45.mBuffers[0].mData + 7;
  while (*++v9)
    ;
  std::string::append[abi:ne180100]<char const*,0>(&v42, (char *)__str, v9);
  std::string::append(&v42, ".", 1uLL);
  for (unint64_t i = 0; i != 134; ++i)
  {
    if (i - 91 < 2 || (i & 0xFE) == 0x48 || i == 41 || i == 52 || (i & 0xFE) == 0x46) {
      continue;
    }
    if (a2 == 1)
    {
      if (i == 69 || (VoiceProcessorV2::SaveFileAtIndexIsDLPSignalFile((VoiceProcessorV2 *)i) & 1) != 0) {
        continue;
      }
      goto LABEL_37;
    }
    if (a2 != 2)
    {
      if (a2 == 3 && i != 69) {
        continue;
      }
      goto LABEL_37;
    }
    if (i == 69) {
      continue;
    }
    int v12 = *((_DWORD *)this + 1129);
    if (v12 == 1)
    {
      char IsDLPSignalFile = VoiceProcessorV2::SaveFileAtIndexIsDLPSignalFile((VoiceProcessorV2 *)i);
      if (i) {
        goto LABEL_36;
      }
    }
    else if (!v12)
    {
      char IsDLPSignalFile = VoiceProcessorV2::SaveFileAtIndexIsDLPSignalFile((VoiceProcessorV2 *)i);
LABEL_36:
      if ((IsDLPSignalFile & 1) == 0) {
        continue;
      }
    }
LABEL_37:
    if (*((_DWORD *)this + 3160) && VoiceProcessorV2::QuerySaveFileAtIndexthroughFileSavingKey(this, i))
    {
      VoiceProcessorV2::GetSignalSaveFileFormatForIndex((uint64_t)&buf, this, i, v14, v15);
      *(_OWORD *)&v41.Float64 mSampleRate = *(_OWORD *)&buf.mSampleTime;
      *(_OWORD *)&v41.UInt32 mBytesPerPacket = *(_OWORD *)&buf.mRateScalar;
      *(void *)&v41.UInt32 mBitsPerChannel = *(void *)&buf.mSMPTETime.mSubframes;
      std::string::operator=(&v43, &v42);
      if (a2 == 1)
      {
        p_AudioTimeStamp buf = &v45;
        CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)&v45, **((_DWORD **)this + 295));
      }
      else
      {
        p_AudioTimeStamp buf = (AudioBufferList *)&buf;
        CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)&buf, **((_DWORD **)this + 292));
      }
      size_t v17 = strlen((const char *)p_buf);
      std::string::append(&v43, (const std::string::value_type *)p_buf, v17);
      std::string::append(&v43, ".", 1uLL);
      uint64_t v18 = 0;
      CFStringRef v19 = kVPSaveFileIndexToCodeArray_v2;
      while (1)
      {
        int v20 = *v19;
        v19 += 4;
        if (i == v20) {
          break;
        }
        if (++v18 == 134)
        {
          long long v21 = "badsavefile";
          goto LABEL_47;
        }
      }
      long long v21 = *(const char **)&kVPSaveFileIndexToCodeArray_v2[4 * v18 + 2];
LABEL_47:
      size_t v22 = strlen(v21);
      std::string::append(&v43, v21, v22);
      if (i == 69) {
        size_t v23 = ".caf";
      }
      else {
        size_t v23 = ".wav";
      }
      std::string::append(&v43, v23, 4uLL);
      vp::Audio_File::Audio_File(&buf);
      unsigned int v24 = (uint64_t *)((char *)this + 8 * i + 12944);
      vp::Audio_Capture::operator=(v24, (uint64_t *)&buf);
      vp::Audio_Capture::~Audio_Capture((vp::Audio_Capture *)&buf);
      if (v41.mChannelsPerFrame)
      {
        unsigned int v25 = *((_DWORD *)this + 3160) - 8;
        if (v25 > 0xB) {
          int v26 = 0;
        }
        else {
          int v26 = dword_1BB87EE94[v25];
        }
        vp::Audio_Capture::create((const std::__fs::filesystem::path *)&v43, (uint64_t)&v41, v26, (uint64_t *)&buf);
        vp::Audio_Capture::operator=(v24, (uint64_t *)&buf);
        vp::Audio_Capture::~Audio_Capture((vp::Audio_Capture *)&buf);
        if (*v24)
        {
          if (VPLogScope(void)::once != -1) {
            dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
          }
          long long v32 = (void *)VPLogScope(void)::scope;
          if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
          {
            uint64_t v33 = (*v32 ? *v32 : MEMORY[0x1E4F14500]);
            if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
            {
              long long v34 = &v43;
              if ((v43.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                long long v34 = (std::string *)v43.__r_.__value_.__r.__words[0];
              }
              LODWORD(buf.mSampleTime) = 136315650;
              *(void *)((char *)&buf.mSampleTime + 4) = "vpDebug_FileSaving.cpp";
              WORD2(buf.mHostTime) = 1024;
              *(_DWORD *)((char *)&buf.mHostTime + 6) = 1301;
              WORD1(buf.mRateScalar) = 2080;
              *(void *)((char *)&buf.mRateScalar + 4) = v34;
              _os_log_impl(&dword_1BB0CE000, v33, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> created \"%s\" audio capture", (uint8_t *)&buf, 0x1Cu);
            }
          }
          __int16 v35 = (int *)*((void *)this + 1578);
          if (v35 && (v4[3053] || v4[3054]))
          {
            if (VPLogScope(void)::once != -1) {
              dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
            }
            CALegacyLog::log(v35, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_FileSaving.cpp", 1301, "CreateSignalSaveFiles", "created \"%s\" audio capture");
          }
        }
        else
        {
          if (VPLogScope(void)::once != -1) {
            dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
          }
          int v36 = (void *)VPLogScope(void)::scope;
          if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
          {
            __int16 v37 = (*v36 ? *v36 : MEMORY[0x1E4F14500]);
            if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
            {
              float v38 = &v43;
              if ((v43.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                float v38 = (std::string *)v43.__r_.__value_.__r.__words[0];
              }
              LODWORD(buf.mSampleTime) = 136315650;
              *(void *)((char *)&buf.mSampleTime + 4) = "vpDebug_FileSaving.cpp";
              WORD2(buf.mHostTime) = 1024;
              *(_DWORD *)((char *)&buf.mHostTime + 6) = 1305;
              WORD1(buf.mRateScalar) = 2080;
              *(void *)((char *)&buf.mRateScalar + 4) = v38;
              _os_log_impl(&dword_1BB0CE000, v37, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> failed to create \"%s\" audio capture", (uint8_t *)&buf, 0x1Cu);
            }
          }
          CFDictionaryRef v39 = (int *)*((void *)this + 1578);
          if (v39 && (v4[3053] || v4[3054]))
          {
            if (VPLogScope(void)::once != -1) {
              dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
            }
            CALegacyLog::log(v39, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_FileSaving.cpp", 1305, "CreateSignalSaveFiles", "failed to create \"%s\" audio capture");
          }
        }
        if (VoiceProcessorV2::SignalIsInFrequencyDomain(this, i))
        {
          if (v41.mChannelsPerFrame == (uint64_t)(*(void *)(*((void *)this + 1752) + 24 * i + 8)
                                                - *(void *)(*((void *)this + 1752) + 24 * i)) >> 3
            && v41.mChannelsPerFrame)
          {
            operator new();
          }
          myAllocABLDynamic(&v41, *((_DWORD *)this + 127), (AudioBufferList **)this + i + 1755);
        }
        if (i == 90)
        {
          int v40 = 0x40000000;
          *(void *)&v45.UInt32 mNumberBuffers = 1;
          *(void *)&v45.mBuffers[0].mNumberChannels = 0x400000001;
          v45.mBuffers[0].mData = &v40;
          memset(&buf, 0, 56);
          buf.mFlags = 1;
          if (v4[3053] || v4[3054]) {
            VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)this, 0x5Au, 1, &v45, &buf);
          }
        }
      }
      else
      {
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        unsigned int v27 = (void *)VPLogScope(void)::scope;
        if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
        {
          int v28 = (*v27 ? *v27 : MEMORY[0x1E4F14500]);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
          {
            int v29 = &v43;
            if ((v43.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              int v29 = (std::string *)v43.__r_.__value_.__r.__words[0];
            }
            LODWORD(buf.mSampleTime) = 136315906;
            *(void *)((char *)&buf.mSampleTime + 4) = "vpDebug_FileSaving.cpp";
            WORD2(buf.mHostTime) = 1024;
            *(_DWORD *)((char *)&buf.mHostTime + 6) = 1269;
            WORD1(buf.mRateScalar) = 2080;
            *(void *)((char *)&buf.mRateScalar + 4) = v29;
            WORD2(buf.mWordClockTime) = 1024;
            *(_DWORD *)((char *)&buf.mWordClockTime + 6) = v41.mChannelsPerFrame;
            _os_log_impl(&dword_1BB0CE000, v28, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> Skipping file capture for %s due to unsupported format, theFileFormat.mChannelsPerFrame=%u", (uint8_t *)&buf, 0x22u);
          }
        }
        CFAllocatorRef v30 = (int *)*((void *)this + 1578);
        if (v30 && (v4[3053] || v4[3054]))
        {
          if (VPLogScope(void)::once != -1) {
            dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
          }
          long long v31 = &v43;
          if ((v43.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            long long v31 = (std::string *)v43.__r_.__value_.__r.__words[0];
          }
          CALegacyLog::log(v30, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_FileSaving.cpp", 1269, "CreateSignalSaveFiles", "Skipping file capture for %s due to unsupported format, theFileFormat.mChannelsPerFrame=%u", (const char *)v31, v41.mChannelsPerFrame);
        }
      }
    }
  }
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v42.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v43.__r_.__value_.__l.__data_);
  }
}

void sub_1BB3B48A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (a34 < 0) {
    operator delete(__p);
  }
  if (a40 < 0) {
    operator delete(a35);
  }
  _Unwind_Resume(exception_object);
}

uint64_t VoiceProcessorV2::SaveFileAtIndexIsDLPSignalFile(VoiceProcessorV2 *this)
{
  uint64_t v1 = (char *)this - 50;
  uint64_t result = 1;
  switch((unint64_t)v1)
  {
    case 0uLL:
    case 1uLL:
    case 3uLL:
    case 4uLL:
    case 5uLL:
    case 6uLL:
    case 7uLL:
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xBuLL:
    case 0xCuLL:
    case 0xDuLL:
    case 0xEuLL:
    case 0xFuLL:
    case 0x10uLL:
    case 0x11uLL:
    case 0x12uLL:
    case 0x21uLL:
    case 0x22uLL:
    case 0x23uLL:
    case 0x24uLL:
    case 0x25uLL:
    case 0x26uLL:
    case 0x27uLL:
    case 0x3DuLL:
    case 0x3EuLL:
    case 0x3FuLL:
    case 0x41uLL:
    case 0x42uLL:
    case 0x43uLL:
    case 0x44uLL:
    case 0x45uLL:
    case 0x46uLL:
    case 0x47uLL:
    case 0x49uLL:
    case 0x4BuLL:
    case 0x4CuLL:
      return result;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

void VoiceProcessorV2::SaveFilesInitializeDLP(VoiceProcessorV2 *this)
{
  if (*((_DWORD *)this + 3160))
  {
    if (*((unsigned char *)this + 477))
    {
      VoiceProcessorV2::CreateSignalSaveFiles(this, 2);
      if (*((_DWORD *)this + 3160))
      {
        if (!*((void *)this + 1898))
        {
          uint64_t v2 = malloc_type_malloc(0x30D40uLL, 0x2C8E6D5CuLL);
          if (!v2)
          {
            exceptiouint64_t n = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
            unsigned int v5 = std::bad_alloc::bad_alloc(exception);
          }
          unsigned int v3 = v2;
          bzero(v2, 0x30D40uLL);
          *((void *)this + 1898) = v3;
        }
      }
    }
  }
}

void VoiceProcessorV2::SaveFilesCleanup(VoiceProcessorV2 *this)
{
  uint64_t v86 = *MEMORY[0x1E4F143B8];
  int v2 = *((_DWORD *)this + 3160);
  if (v2)
  {
    unsigned int v3 = (char *)this + 15180;
    if (*((void *)this + 1892))
    {
      VPGetSaveFileNameForIndex(&__p, (char *)this + 12648, 71, 3, (uint64_t)this + 12904);
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      uint64_t v4 = (void *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
      {
        unsigned int v5 = (*v4 ? *v4 : MEMORY[0x1E4F14500]);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
        {
          p_p = &__p;
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)AudioTimeStamp buf = 136315650;
          *(void *)&uint8_t buf[4] = "vpDebug_FileSaving.cpp";
          __int16 v82 = 1024;
          int v83 = 782;
          __int16 v84 = 2080;
          float v85 = p_p;
          _os_log_impl(&dword_1BB0CE000, v5, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> writing properties plist file: %s ...", buf, 0x1Cu);
        }
      }
      unsigned int v7 = (int *)*((void *)this + 1578);
      if (v7 && (*((unsigned char *)this + 15961) || *((unsigned char *)this + 15962)))
      {
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        unsigned int v8 = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          unsigned int v8 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        CALegacyLog::log(v7, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_FileSaving.cpp", 782, "SaveFilesCleanup", "writing properties plist file: %s ...", (const char *)v8);
      }
      *(void *)AudioTimeStamp buf = *((void *)this + 1892);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        unint64_t v9 = &__p;
      }
      else {
        unint64_t v9 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      WritePropertyListToFile((CFPropertyListRef *)buf, (const char *)v9);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      CFRelease(*((CFTypeRef *)this + 1892));
      *((void *)this + 1892) = 0;
      int v2 = *((_DWORD *)this + 3160);
    }
    uint64_t v10 = (const void *)*((void *)this + 1891);
    if (v10)
    {
      if (v2)
      {
        long long v11 = (void *)((char *)this + 15128);
        unint64_t v12 = *((unsigned int *)this + 3780);
        if (v12)
        {
          uint64_t v13 = 0;
          for (unint64_t i = 0; i < v12; ++i)
          {
            if (*v11)
            {
              double v15 = (double *)(*((void *)this + 1889) + v13);
              int v16 = *(_DWORD *)v15;
              snprintf(buf, 0x100uLL, "%f, %f, %llu", v15[1], v15[2], *((void *)v15 + 3));
              switch(v16)
              {
                case 0:
                  VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&__p, 48);
                  size_t v17 = strlen(buf);
                  WriteItemToDictionary((__CFDictionary **)this + 1891, (const void **)&__p.__r_.__value_.__l.__data_, 0, v17 + 1, buf);
                  uint64_t v18 = (const void *)__p.__r_.__value_.__r.__words[0];
                  if (__p.__r_.__value_.__r.__words[0]) {
                    goto LABEL_41;
                  }
                  break;
                case 1:
                  VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&__p, 49);
                  size_t v19 = strlen(buf);
                  WriteItemToDictionary((__CFDictionary **)this + 1891, (const void **)&__p.__r_.__value_.__l.__data_, 0, v19 + 1, buf);
                  uint64_t v18 = (const void *)__p.__r_.__value_.__r.__words[0];
                  if (__p.__r_.__value_.__r.__words[0]) {
                    goto LABEL_41;
                  }
                  break;
                case 2:
                  VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&__p, 50);
                  size_t v20 = strlen(buf);
                  WriteItemToDictionary((__CFDictionary **)this + 1891, (const void **)&__p.__r_.__value_.__l.__data_, 0, v20 + 1, buf);
                  uint64_t v18 = (const void *)__p.__r_.__value_.__r.__words[0];
                  if (__p.__r_.__value_.__r.__words[0]) {
                    goto LABEL_41;
                  }
                  break;
                case 3:
                  VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&__p, 52);
                  size_t v21 = strlen(buf);
                  WriteItemToDictionary((__CFDictionary **)this + 1891, (const void **)&__p.__r_.__value_.__l.__data_, 0, v21 + 1, buf);
                  uint64_t v18 = (const void *)__p.__r_.__value_.__r.__words[0];
                  if (__p.__r_.__value_.__r.__words[0]) {
LABEL_41:
                  }
                    CFRelease(v18);
                  break;
                default:
                  break;
              }
              unint64_t v12 = *((unsigned int *)this + 3780);
            }
            v13 += 32;
          }
        }
        VPGetSaveFileNameForIndex(&__p, (char *)this + 12648, 70, 3, (uint64_t)this + 12904);
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        size_t v22 = (void *)VPLogScope(void)::scope;
        if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
        {
          size_t v23 = (*v22 ? *v22 : MEMORY[0x1E4F14500]);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
          {
            unsigned int v24 = &__p;
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              unsigned int v24 = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            *(_DWORD *)AudioTimeStamp buf = 136315650;
            *(void *)&uint8_t buf[4] = "vpDebug_FileSaving.cpp";
            __int16 v82 = 1024;
            int v83 = 798;
            __int16 v84 = 2080;
            float v85 = v24;
            _os_log_impl(&dword_1BB0CE000, v23, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> writing time stamps plist file: %s ...", buf, 0x1Cu);
          }
        }
        unsigned int v25 = (int *)*((void *)this + 1578);
        if (v25 && (*((unsigned char *)this + 15961) || *((unsigned char *)this + 15962)))
        {
          if (VPLogScope(void)::once != -1) {
            dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
          }
          int v26 = &__p;
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            int v26 = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          CALegacyLog::log(v25, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_FileSaving.cpp", 798, "SaveFilesCleanup", "writing time stamps plist file: %s ...", (const char *)v26);
        }
        *(void *)AudioTimeStamp buf = *v11;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          unsigned int v27 = &__p;
        }
        else {
          unsigned int v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        WritePropertyListToFile((CFPropertyListRef *)buf, (const char *)v27);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        uint64_t v10 = (const void *)*v11;
      }
      CFRelease(v10);
      *((void *)this + 1891) = 0;
      int v2 = *((_DWORD *)this + 3160);
    }
    if (v2)
    {
      if (!*((void *)this + 1894)) {
        goto LABEL_249;
      }
      VPGetSaveFileNameForIndex(&__p, (char *)this + 12648, 72, 1, (uint64_t)this + 12904);
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      int v28 = (void *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
      {
        int v29 = (*v28 ? *v28 : MEMORY[0x1E4F14500]);
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
        {
          CFAllocatorRef v30 = &__p;
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            CFAllocatorRef v30 = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)AudioTimeStamp buf = 136315650;
          *(void *)&uint8_t buf[4] = "vpDebug_FileSaving.cpp";
          __int16 v82 = 1024;
          int v83 = 809;
          __int16 v84 = 2080;
          float v85 = v30;
          _os_log_impl(&dword_1BB0CE000, v29, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> writing error log file: %s  ... ", buf, 0x1Cu);
        }
      }
      long long v31 = (int *)*((void *)this + 1578);
      if (v31 && (*((unsigned char *)this + 15961) || *((unsigned char *)this + 15962)))
      {
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        long long v32 = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          long long v32 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        CALegacyLog::log(v31, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_FileSaving.cpp", 809, "SaveFilesCleanup", "writing error log file: %s  ... ", (const char *)v32);
      }
      uint64_t v33 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &__p
          : (std::string *)__p.__r_.__value_.__r.__words[0];
      long long v34 = fopen((const char *)v33, "wt");
      if (v34)
      {
        if (*((_DWORD *)this + 3790))
        {
          unint64_t v35 = 0;
          do
          {
            if ((v35 & 3) == 0) {
              fputc(10, v34);
            }
            fprintf(v34, "%.4f\t", *(float *)(*((void *)this + 1894) + 4 * v35++));
          }
          while (v35 < *((unsigned int *)this + 3790));
        }
        else
        {
          fwrite("no errors occurred on the I/O thread.\n", 0x26uLL, 1uLL, v34);
        }
        fputc(10, v34);
        fflush(v34);
        fclose(v34);
      }
      else
      {
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        int v36 = (void *)VPLogScope(void)::scope;
        if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
        {
          __int16 v37 = (*v36 ? *v36 : MEMORY[0x1E4F14500]);
          if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
          {
            float v38 = &__p;
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              float v38 = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            *(_DWORD *)AudioTimeStamp buf = 136315650;
            *(void *)&uint8_t buf[4] = "vpDebug_FileSaving.cpp";
            __int16 v82 = 1024;
            int v83 = 821;
            __int16 v84 = 2080;
            float v85 = v38;
            _os_log_impl(&dword_1BB0CE000, v37, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> couldn't open file to write: %s  ... ", buf, 0x1Cu);
          }
        }
        CFDictionaryRef v39 = (int *)*((void *)this + 1578);
        if (v39 && (*((unsigned char *)this + 15961) || *((unsigned char *)this + 15962)))
        {
          if (VPLogScope(void)::once != -1) {
            dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
          }
          int v40 = &__p;
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            int v40 = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          CALegacyLog::log(v39, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_FileSaving.cpp", 821, "SaveFilesCleanup", "couldn't open file to write: %s  ... ", (const char *)v40);
        }
      }
      free(*((void **)this + 1894));
      *((void *)this + 1894) = 0;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (*((_DWORD *)this + 3160))
      {
LABEL_249:
        if (!*((void *)this + 1896)) {
          goto LABEL_250;
        }
        VPGetSaveFileNameForIndex(&__p, (char *)this + 12648, 41, 3, (uint64_t)this + 12904);
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        AudioStreamBasicDescription v41 = (void *)VPLogScope(void)::scope;
        if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
        {
          std::string v42 = (*v41 ? *v41 : MEMORY[0x1E4F14500]);
          if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
          {
            std::string v43 = &__p;
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              std::string v43 = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            *(_DWORD *)AudioTimeStamp buf = 136315650;
            *(void *)&uint8_t buf[4] = "vpDebug_FileSaving.cpp";
            __int16 v82 = 1024;
            int v83 = 872;
            __int16 v84 = 2080;
            float v85 = v43;
            _os_log_impl(&dword_1BB0CE000, v42, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> writing gating control data file: %s ... ", buf, 0x1Cu);
          }
        }
        float v44 = (int *)*((void *)this + 1578);
        if (v44 && (*((unsigned char *)this + 15961) || *((unsigned char *)this + 15962)))
        {
          if (VPLogScope(void)::once != -1) {
            dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
          }
          AudioBufferList v45 = &__p;
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            AudioBufferList v45 = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          CALegacyLog::log(v44, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_FileSaving.cpp", 872, "SaveFilesCleanup", "writing gating control data file: %s ... ", (const char *)v45);
        }
        float v46 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? &__p
            : (std::string *)__p.__r_.__value_.__r.__words[0];
        uint64_t v47 = fopen((const char *)v46, "wt");
        if (v47)
        {
          uint64_t v48 = *((void *)this + 1896);
          if (v48)
          {
            if (*v3)
            {
              uint64_t v49 = *((unsigned int *)this + 3794);
              if (v49 != 200000) {
                fwrite((const void *)(v48 + v49), 1uLL, (200000 - v49), v47);
              }
            }
            size_t v50 = *((unsigned int *)this + 3794);
            if (v50) {
              fwrite(*((const void **)this + 1896), 1uLL, v50, v47);
            }
          }
          fputc(10, v47);
          fflush(v47);
          fclose(v47);
        }
        else
        {
          if (VPLogScope(void)::once != -1) {
            dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
          }
          DSPSplitComplex v51 = (void *)VPLogScope(void)::scope;
          if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
          {
            CFDictionaryRef v52 = (*v51 ? *v51 : MEMORY[0x1E4F14500]);
            if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
            {
              float v53 = &__p;
              if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                float v53 = (std::string *)__p.__r_.__value_.__r.__words[0];
              }
              *(_DWORD *)AudioTimeStamp buf = 136315650;
              *(void *)&uint8_t buf[4] = "vpDebug_FileSaving.cpp";
              __int16 v82 = 1024;
              int v83 = 892;
              __int16 v84 = 2080;
              float v85 = v53;
              _os_log_impl(&dword_1BB0CE000, v52, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> couldn't open file to write: %s  ... ", buf, 0x1Cu);
            }
          }
          float v54 = (int *)*((void *)this + 1578);
          if (v54 && (*((unsigned char *)this + 15961) || *((unsigned char *)this + 15962)))
          {
            if (VPLogScope(void)::once != -1) {
              dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
            }
            float v55 = &__p;
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              float v55 = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            CALegacyLog::log(v54, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_FileSaving.cpp", 892, "SaveFilesCleanup", "couldn't open file to write: %s  ... ", (const char *)v55);
          }
        }
        free(*((void **)this + 1896));
        *((void *)this + 1896) = 0;
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (*((_DWORD *)this + 3160))
        {
LABEL_250:
          if (*((void *)this + 1898))
          {
            VPGetSaveFileNameForIndex(&__p, (char *)this + 12648, 52, 3, (uint64_t)this + 12904);
            if (VPLogScope(void)::once != -1) {
              dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
            }
            double v56 = (void *)VPLogScope(void)::scope;
            if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
            {
              CFStringRef v57 = (*v56 ? *v56 : MEMORY[0x1E4F14500]);
              if (os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v58 = &__p;
                if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                  uint64_t v58 = (std::string *)__p.__r_.__value_.__r.__words[0];
                }
                *(_DWORD *)AudioTimeStamp buf = 136315650;
                *(void *)&uint8_t buf[4] = "vpDebug_FileSaving.cpp";
                __int16 v82 = 1024;
                int v83 = 903;
                __int16 v84 = 2080;
                float v85 = v58;
                _os_log_impl(&dword_1BB0CE000, v57, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> writing dlp control data file: %s ... ", buf, 0x1Cu);
              }
            }
            uint64_t v59 = (int *)*((void *)this + 1578);
            if (v59 && (*((unsigned char *)this + 15961) || *((unsigned char *)this + 15962)))
            {
              if (VPLogScope(void)::once != -1) {
                dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
              }
              uint64_t v60 = &__p;
              if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                uint64_t v60 = (std::string *)__p.__r_.__value_.__r.__words[0];
              }
              CALegacyLog::log(v59, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_FileSaving.cpp", 903, "SaveFilesCleanup", "writing dlp control data file: %s ... ", (const char *)v60);
            }
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              float v61 = &__p;
            }
            else {
              float v61 = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            __int16 v62 = fopen((const char *)v61, "wt");
            if (v62)
            {
              uint64_t v63 = *((void *)this + 1898);
              if (v63)
              {
                if (*((unsigned char *)this + 15196))
                {
                  uint64_t v64 = *((unsigned int *)this + 3798);
                  if (v64 != 200000) {
                    fwrite((const void *)(v63 + v64), 1uLL, (200000 - v64), v62);
                  }
                }
                size_t v65 = *((unsigned int *)this + 3798);
                if (v65) {
                  fwrite(*((const void **)this + 1898), 1uLL, v65, v62);
                }
              }
              fputc(10, v62);
              fflush(v62);
              fclose(v62);
            }
            else
            {
              if (VPLogScope(void)::once != -1) {
                dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
              }
              int v66 = (void *)VPLogScope(void)::scope;
              if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
              {
                DSPSplitComplex v67 = (*v66 ? *v66 : MEMORY[0x1E4F14500]);
                if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
                {
                  DSPSplitComplex v68 = &__p;
                  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                    DSPSplitComplex v68 = (std::string *)__p.__r_.__value_.__r.__words[0];
                  }
                  *(_DWORD *)AudioTimeStamp buf = 136315650;
                  *(void *)&uint8_t buf[4] = "vpDebug_FileSaving.cpp";
                  __int16 v82 = 1024;
                  int v83 = 923;
                  __int16 v84 = 2080;
                  float v85 = v68;
                  _os_log_impl(&dword_1BB0CE000, v67, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> couldn't open file to write: %s  ... ", buf, 0x1Cu);
                }
              }
              DSPSplitComplex v69 = (int *)*((void *)this + 1578);
              if (v69 && (*((unsigned char *)this + 15961) || *((unsigned char *)this + 15962)))
              {
                if (VPLogScope(void)::once != -1) {
                  dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
                }
                float v70 = &__p;
                if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                  float v70 = (std::string *)__p.__r_.__value_.__r.__words[0];
                }
                CALegacyLog::log(v69, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_FileSaving.cpp", 923, "SaveFilesCleanup", "couldn't open file to write: %s  ... ", (const char *)v70);
              }
            }
            free(*((void **)this + 1898));
            *((void *)this + 1898) = 0;
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__p.__r_.__value_.__l.__data_);
            }
          }
        }
      }
    }
  }
  uint64_t v71 = *((void *)this + 1753);
  uint64_t v72 = *((void *)this + 1752);
  while (v71 != v72)
  {
    v71 -= 24;
    *(void *)AudioTimeStamp buf = v71;
    std::vector<std::unique_ptr<VPTimeFreqConverter>>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
  }
  uint64_t v73 = 0;
  *((void *)this + 1753) = v72;
  uint64_t v74 = (char *)this + 14040;
  do
  {
    if (*(void *)&v74[v73])
    {
      myFreeABLDynamic((AudioBufferList **)&v74[v73]);
      *(void *)&v74[v73] = 0;
    }
    v73 += 8;
  }
  while (v73 != 1072);
  float v75 = (const void *)*((void *)this + 1892);
  if (v75)
  {
    CFRelease(v75);
    *((void *)this + 1892) = 0;
  }
  unsigned int v76 = (const void *)*((void *)this + 1891);
  if (v76)
  {
    CFRelease(v76);
    *((void *)this + 1891) = 0;
  }
  long long v77 = (void *)*((void *)this + 1894);
  if (v77)
  {
    free(v77);
    *((void *)this + 1894) = 0;
  }
  double v78 = (void *)*((void *)this + 1896);
  if (v78)
  {
    free(v78);
    *((void *)this + 1896) = 0;
  }
  double v79 = (void *)*((void *)this + 1898);
  if (v79)
  {
    free(v79);
    *((void *)this + 1898) = 0;
  }
}

void sub_1BB3B5C00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<VoiceProcessorV2::RereadSaveFilesDefaults(void)::$_1 &&>>(uint64_t **a1, double a2, double a3)
{
  uint64_t v3 = **a1;
  std::chrono::duration<long long, std::ratio<1, 1000000>>::rep v4 = *(void *)v3;
  unsigned int v5 = (unsigned char *)(*(void *)v3 + 12552);
  if (*(unsigned char *)(*(void *)v3 + 1688)
    && (*(unsigned char *)(*(void *)v3 + 15961) || *(unsigned char *)(*(void *)v3 + 15962)))
  {
    LODWORD(a3) = *(_DWORD *)(v4 + 492);
    VoiceProcessorV2::WriteTSOverload(*(void *)v3, *(double *)(v4 + 1696) - (double)*(unint64_t *)&a3, *(double *)(v4 + 1696) - (double)*(unint64_t *)&a3, 0);
  }
  if (*(unsigned char *)(v4 + 1689) && (v5[3409] || v5[3410]))
  {
    LODWORD(a3) = *(_DWORD *)(v4 + 496);
    VoiceProcessorV2::WriteTSOverload(v4, *(double *)(v4 + 1704) - (double)*(unint64_t *)&a3, *(double *)(v4 + 1704) - (double)*(unint64_t *)&a3, 1);
  }
  if (*v5 && (v5[3409] || v5[3410]))
  {
    LODWORD(a3) = *(_DWORD *)(v4 + 484);
    VoiceProcessorV2::WriteTSOverload(v4, *(double *)(v4 + 12544) - (double)*(unint64_t *)&a3, *(double *)(v4 + 12544) - (double)*(unint64_t *)&a3, 2);
  }
  if (v5[16] && (v5[3409] || v5[3410]))
  {
    LODWORD(a3) = *(_DWORD *)(v4 + 1528);
    VoiceProcessorV2::WriteTSOverload(v4, *(double *)(v4 + 12560) - (double)*(unint64_t *)&a3, *(double *)(v4 + 12560) - (double)*(unint64_t *)&a3, 3);
  }
  VoiceProcessorV2::SaveFilesCleanup((VoiceProcessorV2 *)v4);
  v5[3410] = **(unsigned char **)(v3 + 8);
}

std::chrono::duration<long long, std::ratio<1, 1000000>>::rep VoiceProcessorV2::WriteTSOverload(std::chrono::duration<long long, std::ratio<1, 1000000>>::rep this, double a2, double a3, int a4)
{
  if (*(_DWORD *)(this + 12640))
  {
    std::chrono::duration<long long, std::ratio<1, 1000000>>::rep v4 = this;
    if (!(*(_DWORD *)(this + 15120) >> 13))
    {
      this = std::chrono::system_clock::now().__d_.__rep_;
      uint64_t v8 = *(void *)(v4 + 15112) + 32 * *(unsigned int *)(v4 + 15120);
      *(_DWORD *)uint64_t v8 = a4;
      *(double *)(v8 + 8) = a2;
      *(double *)(v8 + 16) = a3;
      *(void *)(v8 + 24) = this / 1000000;
      ++*(_DWORD *)(v4 + 15120);
    }
  }
  return this;
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<VoiceProcessorV2::RereadSaveFilesDefaults(void)::$_0 &&>>(uint64_t **a1)
{
  uint64_t v1 = **a1;
  int v2 = *(VoiceProcessorV2 **)v1;
  uint64_t v3 = (unsigned __int8 *)(*(void *)v1 + 15961);
  VoiceProcessorV2::SaveFilesPrepare(*(VoiceProcessorV2 **)v1);
  VoiceProcessorV2::SaveFilesInitialize(v2);
  VoiceProcessorV2::SaveFilesInitializeDLP(v2);
  if (*((_DWORD *)v2 + 3160) && *((unsigned char *)v2 + 478)) {
    VoiceProcessorV2::CreateSignalSaveFiles(v2, 3);
  }
  int v4 = **(unsigned __int8 **)(v1 + 8);
  v3[1] = v4;
  int v5 = *v3;
  if (!(v5 | v4))
  {
LABEL_7:
    if (!v4) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  VoiceProcessorV2::PListWriteInitializeHwInputParameters(v2);
  int v5 = *v3;
  if (!*v3)
  {
    int v4 = v3[1];
    goto LABEL_7;
  }
LABEL_8:
  VoiceProcessorV2::PListWriteInitializeDLPParameters(v2);
  int v5 = *v3;
LABEL_9:
  if (v5 || v3[1])
  {
    VoiceProcessorV2::PListWriteInitializeOutputParameters(v2);
    if (*v3 || v3[1])
    {
      VoiceProcessorV2::PListWriteInitializeSpkrTelParameters(v2);
      if (*v3 || v3[1])
      {
        VoiceProcessorV2::PListWriteSetModeParameters(v2);
      }
    }
  }
}

uint64_t VoiceProcessorV2::WriteControlDataToFile(uint64_t this, char *a2, unsigned int a3, unsigned int a4)
{
  if (*(_DWORD *)(this + 12640))
  {
    uint64_t v7 = this;
    this = VoiceProcessorV2::QuerySaveFileAtIndexthroughFileSavingKey((VoiceProcessorV2 *)this, a4);
    if (this)
    {
      uint64_t v8 = (unsigned char *)(v7 + 15180);
      if (a4 == 52)
      {
        unint64_t v9 = (void **)(v7 + 15184);
        uint64_t v10 = (_DWORD *)(v7 + 15192);
        uint64_t v8 = (unsigned char *)(v7 + 15196);
      }
      else
      {
        if (a4 != 41) {
          return this;
        }
        unint64_t v9 = (void **)(v7 + 15168);
        uint64_t v10 = (_DWORD *)(v7 + 15176);
      }
      long long v11 = (char *)*v9;
      if (*v9)
      {
        uint64_t v12 = *v10;
        if (v12 < 0x30D41)
        {
          unsigned int v13 = 200000 - v12;
          if (200000 - (int)v12 >= a3) {
            size_t v14 = a3;
          }
          else {
            size_t v14 = v13;
          }
          if (a3 >= v13) {
            size_t v15 = a3 - v13;
          }
          else {
            size_t v15 = 0;
          }
          if (v14)
          {
            this = (uint64_t)memcpy(&v11[v12], a2, v14);
            *v10 += v14;
          }
          if (v13 < a3)
          {
            this = (uint64_t)memcpy(v11, &a2[v14], v15);
            *uint64_t v10 = v15;
            *uint64_t v8 = 1;
          }
        }
      }
    }
  }
  return this;
}

uint64_t VoiceProcessorV2::EchoGateV3ReadWriteControlDataCallback(uint64_t this, char *a2, void *a3, int a4)
{
  if (!a4) {
    return VoiceProcessorV2::WriteControlDataToFile(this, a2, a3, 0x29u);
  }
  return this;
}

void WaveFileReader::read(FILE **this, float *const *a2, unsigned int a3, unsigned int a4)
{
  LODWORD(v4) = a3;
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (this[5] && (unsigned int v7 = *((_DWORD *)this + 12)) != 0)
  {
    if (*((unsigned __int16 *)this + 11) == a3)
    {
      if (v7 >= a4) {
        vDSP_Length v8 = a4;
      }
      else {
        vDSP_Length v8 = v7;
      }
      MEMORY[0x1F4188790](this);
      uint64_t v10 = (__int16 *)&v26[-v9];
      size_t v12 = fread(&v26[-v9], v11, (v8 * v4), this[5]);
      if (*((_WORD *)this + 10) == 3) {
        goto LABEL_23;
      }
      MEMORY[0x1F4188790](v12);
      size_t v14 = (float *)&v26[-((v13 + 15) & 0x7FFFFFFF0)];
      int v15 = *((unsigned __int16 *)this + 17);
      switch(v15)
      {
        case 16:
          vDSP_vflt16(v10, 1, v14, 1, (v8 * v4));
          goto LABEL_22;
        case 24:
          vDSP_vflt24((const vDSP_int24 *)v10, 1, v14, 1, (v8 * v4));
          goto LABEL_22;
        case 32:
          vDSP_vflt32((const int *)v10, 1, v14, 1, (v8 * v4));
LABEL_22:
          float __B = (float)(1 << (*((_WORD *)this + 17) - 1));
          vDSP_vsdiv(v14, 1, &__B, (float *)v10, 1, (v8 * v4));
LABEL_23:
          if (v4)
          {
            uint64_t v22 = v4;
            do
            {
              size_t v23 = *a2++;
              vDSP_mmov((const float *)v10, v23, 1uLL, v8, v4, 1uLL);
              v10 += 2;
              --v22;
            }
            while (v22);
          }
          return;
      }
      if (v4)
      {
        size_t v24 = 4 * v8;
        uint64_t v4 = v4;
        do
        {
          unsigned int v25 = *a2++;
          bzero(v25, v24);
          --v4;
        }
        while (v4);
      }
    }
    else if (a3)
    {
      size_t v19 = 4 * a4;
      uint64_t v20 = a3;
      do
      {
        size_t v21 = *a2++;
        bzero(v21, v19);
        --v20;
      }
      while (v20);
    }
  }
  else if (a3)
  {
    size_t v16 = 4 * a4;
    uint64_t v17 = a3;
    do
    {
      uint64_t v18 = *a2++;
      bzero(v18, v16);
      --v17;
    }
    while (v17);
  }
}

uint64_t VoiceProcessorV2::LogIOError(uint64_t this, float a2, float a3, float a4, float a5, const char *a6, ...)
{
  va_start(va, a6);
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (!*(_DWORD *)(this + 12640)) {
    return vsnprintf(__str, 0x100uLL, a6, va);
  }
  uint64_t v6 = *(void *)(this + 15152);
  if (v6)
  {
    uint64_t v7 = *(unsigned int *)(this + 15160);
    if (v7 < (*(_DWORD *)(this + 15144) - 1) * *(_DWORD *)(this + 15148))
    {
      *(float *)(v6 + 4 * v7) = a2;
      *(float *)(v6 + 4 * (v7 + 1)) = a3;
      *(float *)(v6 + 4 * (v7 + 2)) = a4;
      *(_DWORD *)(this + 15160) = v7 + 4;
      *(float *)(v6 + 4 * (v7 + 3)) = a5;
    }
  }
  return this;
}

char *std::vector<std::pair<unsigned int,float>>::__init_with_size[abi:ne180100]<std::pair<unsigned int,float>*,std::pair<unsigned int,float>*>(char *result, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = std::vector<std::pair<unsigned int,float>>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = (void *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      uint64_t v8 = *a2++;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_1BB3B6410(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void CAX4CCString::CAX4CCString(CAX4CCString *this, unsigned int a2)
{
  unsigned int v4 = bswap32(a2);
  *(_DWORD *)((char *)this + 1) = v4;
  uint64_t v5 = MEMORY[0x1E4F14390];
  if ((v4 & 0x80) != 0)
  {
    if (!__maskrune((char)v4, 0x40000uLL)) {
      goto LABEL_17;
    }
  }
  else if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v4 + 60) & 0x40000) == 0)
  {
    goto LABEL_17;
  }
  unsigned int v6 = *((char *)this + 2);
  if ((v6 & 0x80000000) != 0)
  {
    if (!__maskrune(v6, 0x40000uLL)) {
      goto LABEL_17;
    }
  }
  else if ((*(_DWORD *)(v5 + 4 * v6 + 60) & 0x40000) == 0)
  {
    goto LABEL_17;
  }
  unsigned int v7 = *((char *)this + 3);
  if ((v7 & 0x80000000) != 0)
  {
    if (!__maskrune(v7, 0x40000uLL)) {
      goto LABEL_17;
    }
LABEL_13:
    unsigned int v8 = *((char *)this + 4);
    if ((v8 & 0x80000000) != 0)
    {
      if (!__maskrune(v8, 0x40000uLL)) {
        goto LABEL_17;
      }
    }
    else if ((*(_DWORD *)(v5 + 4 * v8 + 60) & 0x40000) == 0)
    {
      goto LABEL_17;
    }
    *(_WORD *)((char *)this + 5) = 39;
    *(unsigned char *)this = 39;
    return;
  }
  if ((*(_DWORD *)(v5 + 4 * v7 + 60) & 0x40000) != 0) {
    goto LABEL_13;
  }
LABEL_17:
  if (a2 + 199999 > 0x61A7E) {
    snprintf((char *)this, 0x10uLL, "0x%x");
  }
  else {
    snprintf((char *)this, 0x10uLL, "%d");
  }
}

char *std::vector<std::pair<unsigned int,float>>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void VoiceProcessorV2::LogNonTransientErrors(VoiceProcessorV2 *this, int a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (char *)this + 15961;
  if (a2)
  {
    uint64_t v4 = (const char *)*((void *)this + 2005);
    for (unint64_t i = (uint64_t *)*((void *)this + 2006); v4 != (const char *)i; v4 += 24)
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      unsigned int v6 = (void *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
      {
        unsigned int v7 = (*v6 ? *v6 : MEMORY[0x1E4F14500]);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        {
          unsigned int v8 = v4;
          if (v4[23] < 0) {
            unsigned int v8 = *(const char **)v4;
          }
          *(_DWORD *)AudioTimeStamp buf = 136315650;
          *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 97;
          *(_WORD *)&unsigned char buf[18] = 2080;
          *(void *)&buf[20] = v8;
          _os_log_impl(&dword_1BB0CE000, v7, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> %s\n", buf, 0x1Cu);
        }
      }
      uint64_t v9 = (int *)*((void *)this + 1578);
      if (v9 && (*v3 || v3[1]))
      {
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        uint64_t v10 = v4;
        if (v4[23] < 0) {
          uint64_t v10 = *(const char **)v4;
        }
        CALegacyLog::log(v9, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 97, "LogNonTransientErrors", "%s\n", v10);
      }
    }
    uint64_t v18 = (long long *)*((void *)this + 2011);
    for (j = (long long *)*((void *)this + 2012); v18 != j; uint64_t v18 = (long long *)&v21[1])
    {
      *(_OWORD *)&buf[8] = 0uLL;
      int v26 = v18;
      *(void *)AudioTimeStamp buf = &buf[8];
      uint64_t v20 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t **)buf, (void **)v18, &v26);
      size_t v21 = (const std::string *)((char *)v18 + 24);
      std::string::operator=((std::string *)(v20 + 7), v21);
      AudioStatisticsHelperSendMessage(*((uint64_t **)this + 270), *((_DWORD *)this + 542), (const UInt8 **)buf, 6);
      std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(*(void **)&buf[8]);
    }
  }
  else
  {
    size_t v11 = (const char *)*((void *)this + 2008);
    for (uint64_t k = (uint64_t *)*((void *)this + 2009); v11 != (const char *)k; v11 += 24)
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      uint64_t v13 = (void *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
      {
        size_t v14 = (*v13 ? *v13 : MEMORY[0x1E4F14500]);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          int v15 = v11;
          if (v11[23] < 0) {
            int v15 = *(const char **)v11;
          }
          *(_DWORD *)AudioTimeStamp buf = 136315650;
          *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 112;
          *(_WORD *)&unsigned char buf[18] = 2080;
          *(void *)&buf[20] = v15;
          _os_log_impl(&dword_1BB0CE000, v14, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> %s\n", buf, 0x1Cu);
        }
      }
      size_t v16 = (int *)*((void *)this + 1578);
      if (v16 && (*v3 || v3[1]))
      {
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        uint64_t v17 = v11;
        if (v11[23] < 0) {
          uint64_t v17 = *(const char **)v11;
        }
        CALegacyLog::log(v16, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 112, "LogNonTransientErrors", "%s\n", v17);
      }
    }
    uint64_t v22 = (long long *)*((void *)this + 2014);
    for (m = (long long *)*((void *)this + 2015); v22 != m; uint64_t v22 = (long long *)&v25[1])
    {
      *(void *)&buf[8] = 0;
      *(void *)&buf[16] = 0;
      int v26 = v22;
      *(void *)AudioTimeStamp buf = &buf[8];
      size_t v24 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t **)buf, (void **)v22, &v26);
      unsigned int v25 = (const std::string *)((char *)v22 + 24);
      std::string::operator=((std::string *)(v24 + 7), v25);
      AudioStatisticsHelperSendMessage(*((uint64_t **)this + 270), *((_DWORD *)this + 542), (const UInt8 **)buf, 6);
      std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(*(void **)&buf[8]);
    }
  }
}

void sub_1BB3B69FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
}

uint64_t *std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t **a1, void **a2, long long **a3)
{
  uint64_t v5 = (uint64_t **)std::__tree<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::__map_value_compare<std::string,std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::less<void>,true>,std::allocator<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>>::__find_equal<std::string>((uint64_t)a1, &v14, a2);
  unsigned int v6 = *v5;
  if (!*v5)
  {
    unsigned int v7 = v5;
    unsigned int v6 = (uint64_t *)operator new(0x50uLL);
    v12[0] = v6;
    v12[1] = a1 + 1;
    char v13 = 0;
    unsigned int v8 = (std::string *)(v6 + 4);
    uint64_t v9 = *a3;
    if (*((char *)*a3 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v8, *(const std::string::value_type **)v9, *((void *)v9 + 1));
    }
    else
    {
      long long v10 = *v9;
      v6[6] = *((void *)v9 + 2);
      *(_OWORD *)&v8->__r_.__value_.__l.__data_ = v10;
    }
    v6[7] = 0;
    v6[8] = 0;
    v6[9] = 0;
    char v13 = 1;
    std::__tree<std::__value_type<double,int>,std::__map_value_compare<double,std::__value_type<double,int>,std::less<double>,true>,std::allocator<std::__value_type<double,int>>>::__insert_node_at(a1, v14, v7, v6);
    v12[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::reset[abi:ne180100]((uint64_t)v12);
  }
  return v6;
}

void sub_1BB3B6AE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(*a1);
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(a1[1]);
    std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::string>,0>((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::string>,0>((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }
}

void VoiceProcessorV2::LogVPParams(VoiceProcessorV2 *this)
{
  uint64_t v164 = *MEMORY[0x1E4F143B8];
  if (VPLogScope(void)::once != -1) {
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
  }
  id v155 = (char *)this + 15961;
  int v2 = (void *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    uint64_t v3 = (*v2 ? *v2 : MEMORY[0x1E4F14500]);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)AudioTimeStamp buf = 136315394;
      *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 127;
      _os_log_impl(&dword_1BB0CE000, v3, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp> ____________logparams:begin___________", buf, 0x12u);
    }
  }
  uint64_t v4 = (int *)*((void *)this + 1578);
  if (v4 && (*v155 || *((unsigned char *)this + 15962)))
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    CALegacyLog::log(v4, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 127, "LogVPParams", "____________logparams:begin___________");
  }
  if (VPLogScope(void)::once != -1) {
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
  }
  uint64_t v5 = (void *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    unsigned int v6 = (*v5 ? *v5 : MEMORY[0x1E4F14500]);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v7 = (void *)((char *)this + 32);
      if (*((char *)this + 55) < 0) {
        unsigned int v7 = (void *)*v7;
      }
      *(_DWORD *)AudioTimeStamp buf = 136315650;
      *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 128;
      *(_WORD *)&unsigned char buf[18] = 2080;
      *(void *)&buf[20] = v7;
      _os_log_impl(&dword_1BB0CE000, v6, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     PRODUCT: %s", buf, 0x1Cu);
    }
  }
  unsigned int v8 = (int *)*((void *)this + 1578);
  if (v8 && (*v155 || *((unsigned char *)this + 15962)))
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    uint64_t v9 = (char *)this + 32;
    if (*((char *)this + 55) < 0) {
      uint64_t v9 = *(const char **)v9;
    }
    CALegacyLog::log(v8, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 128, "LogVPParams", "    PRODUCT: %s", v9);
  }
  if (VPLogScope(void)::once != -1) {
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
  }
  long long v10 = (void *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    size_t v11 = (*v10 ? *v10 : MEMORY[0x1E4F14500]);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = (uint64_t)(*((void *)this + 293) - *((void *)this + 292)) >> 2;
      uint64_t v13 = (uint64_t)(*((void *)this + 296) - *((void *)this + 295)) >> 2;
      *(_DWORD *)AudioTimeStamp buf = 136315906;
      *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 130;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&buf[20] = v12;
      *(_WORD *)&unsigned char buf[28] = 2048;
      *(void *)&buf[30] = v13;
      _os_log_impl(&dword_1BB0CE000, v11, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     Num Ref Ports = %lu, Num Mic Ports = %lu ", buf, 0x26u);
    }
  }
  uint64_t v14 = (int *)*((void *)this + 1578);
  if (v14 && (*v155 || *((unsigned char *)this + 15962)))
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    CALegacyLog::log(v14, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 130, "LogVPParams", "    Num Ref Ports = %lu, Num Mic Ports = %lu ", (uint64_t)(*((void *)this + 293) - *((void *)this + 292)) >> 2, (uint64_t)(*((void *)this + 296) - *((void *)this + 295)) >> 2);
  }
  if (*((void *)this + 293) != *((void *)this + 292))
  {
    unint64_t v15 = 0;
    uint64_t v16 = MEMORY[0x1E4F14500];
    do
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      uint64_t v17 = (void *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
      {
        uint64_t v18 = (*v17 ? *v17 : v16);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          CAX4CCString::CAX4CCString((CAX4CCString *)v159, *(_DWORD *)(*((void *)this + 292) + 4 * v15));
          *(_DWORD *)AudioTimeStamp buf = 136315906;
          *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 134;
          *(_WORD *)&unsigned char buf[18] = 2048;
          *(void *)&buf[20] = v15;
          *(_WORD *)&unsigned char buf[28] = 2080;
          *(void *)&buf[30] = v159;
          _os_log_impl(&dword_1BB0CE000, v18, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>       : Ref Port #%lu=%s", buf, 0x26u);
        }
      }
      size_t v19 = (int *)*((void *)this + 1578);
      if (v19 && (*v155 || *((unsigned char *)this + 15962)))
      {
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        uint64_t v20 = VPLogScope(void)::scope;
        CAX4CCString::CAX4CCString((CAX4CCString *)buf, *(_DWORD *)(*((void *)this + 292) + 4 * v15));
        CALegacyLog::log(v19, 3, v20, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 134, "LogVPParams", "      : Ref Port #%lu=%s", v15, buf);
      }
      ++v15;
    }
    while (v15 < (uint64_t)(*((void *)this + 293) - *((void *)this + 292)) >> 2);
  }
  if (*((void *)this + 296) != *((void *)this + 295))
  {
    unint64_t v21 = 0;
    uint64_t v22 = MEMORY[0x1E4F14500];
    do
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      size_t v23 = (void *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
      {
        size_t v24 = (*v23 ? *v23 : v22);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          CAX4CCString::CAX4CCString((CAX4CCString *)v159, *(_DWORD *)(*((void *)this + 295) + 4 * v21));
          *(_DWORD *)AudioTimeStamp buf = 136315906;
          *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 138;
          *(_WORD *)&unsigned char buf[18] = 2048;
          *(void *)&buf[20] = v21;
          *(_WORD *)&unsigned char buf[28] = 2080;
          *(void *)&buf[30] = v159;
          _os_log_impl(&dword_1BB0CE000, v24, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>       : Mic Port #%lu=%s", buf, 0x26u);
        }
      }
      unsigned int v25 = (int *)*((void *)this + 1578);
      if (v25 && (*v155 || *((unsigned char *)this + 15962)))
      {
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        uint64_t v26 = VPLogScope(void)::scope;
        CAX4CCString::CAX4CCString((CAX4CCString *)buf, *(_DWORD *)(*((void *)this + 295) + 4 * v21));
        CALegacyLog::log(v25, 3, v26, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 138, "LogVPParams", "      : Mic Port #%lu=%s", v21, buf);
      }
      ++v21;
    }
    while (v21 < (uint64_t)(*((void *)this + 296) - *((void *)this + 295)) >> 2);
  }
  int v27 = *((unsigned __int8 *)this + 60);
  if (VPLogScope(void)::once != -1) {
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
  }
  uint64_t v28 = (void *)VPLogScope(void)::scope;
  if (v27)
  {
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
    {
      int v29 = (*v28 ? *v28 : MEMORY[0x1E4F14500]);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        if (!*((unsigned char *)this + 60)) {
          std::__throw_bad_optional_access[abi:ne180100]();
        }
        int v30 = *((_DWORD *)this + 14);
        *(_DWORD *)AudioTimeStamp buf = 136315650;
        *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 189;
        *(_WORD *)&unsigned char buf[18] = 1024;
        *(_DWORD *)&buf[20] = v30;
        _os_log_impl(&dword_1BB0CE000, v29, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     Acoustic ID: %d", buf, 0x18u);
      }
    }
    long long v31 = (int *)*((void *)this + 1578);
    if (v31 && (*v155 || *((unsigned char *)this + 15962)))
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      if (!*((unsigned char *)this + 60)) {
        std::__throw_bad_optional_access[abi:ne180100]();
      }
      CALegacyLog::log(v31, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 189, "LogVPParams", "    Acoustic ID: %d", *((_DWORD *)this + 14));
    }
  }
  else
  {
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
    {
      long long v32 = (*v28 ? *v28 : MEMORY[0x1E4F14500]);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)AudioTimeStamp buf = 136315394;
        *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 193;
        _os_log_impl(&dword_1BB0CE000, v32, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     This product does not have a valid Acoustic ID", buf, 0x12u);
      }
    }
    uint64_t v33 = (int *)*((void *)this + 1578);
    if (v33 && (*v155 || *((unsigned char *)this + 15962)))
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      CALegacyLog::log(v33, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 193, "LogVPParams", "    This product does not have a valid Acoustic ID");
    }
  }
  if (VPLogScope(void)::once != -1) {
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
  }
  long long v34 = (void *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    unint64_t v35 = (*v34 ? *v34 : MEMORY[0x1E4F14500]);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      CAFormatter::CAFormatter((CAFormatter *)v159, (const AudioStreamBasicDescription *)((char *)this + 584));
      *(_DWORD *)AudioTimeStamp buf = 136315650;
      *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 196;
      *(_WORD *)&unsigned char buf[18] = 2080;
      *(void *)&buf[20] = *(void *)v159;
      _os_log_impl(&dword_1BB0CE000, v35, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     HW Format REF: %s", buf, 0x1Cu);
      if (*(void *)v159) {
        free(*(void **)v159);
      }
    }
  }
  int v36 = (int *)*((void *)this + 1578);
  if (v36 && (*v155 || *((unsigned char *)this + 15962)))
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    uint64_t v37 = VPLogScope(void)::scope;
    CAFormatter::CAFormatter((CAFormatter *)buf, (const AudioStreamBasicDescription *)((char *)this + 584));
    CALegacyLog::log(v36, 3, v37, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 196, "LogVPParams", "    HW Format REF: %s", *(const char **)buf);
    if (*(void *)buf) {
      free(*(void **)buf);
    }
  }
  if (VPLogScope(void)::once != -1) {
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
  }
  float v38 = (void *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    CFDictionaryRef v39 = (*v38 ? *v38 : MEMORY[0x1E4F14500]);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
    {
      CAFormatter::CAFormatter((CAFormatter *)v159, (const AudioStreamBasicDescription *)((char *)this + 624));
      *(_DWORD *)AudioTimeStamp buf = 136315650;
      *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 197;
      *(_WORD *)&unsigned char buf[18] = 2080;
      *(void *)&buf[20] = *(void *)v159;
      _os_log_impl(&dword_1BB0CE000, v39, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     HW Format MIC: %s", buf, 0x1Cu);
      if (*(void *)v159) {
        free(*(void **)v159);
      }
    }
  }
  int v40 = (int *)*((void *)this + 1578);
  if (v40 && (*v155 || *((unsigned char *)this + 15962)))
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    uint64_t v41 = VPLogScope(void)::scope;
    CAFormatter::CAFormatter((CAFormatter *)buf, (const AudioStreamBasicDescription *)((char *)this + 624));
    CALegacyLog::log(v40, 3, v41, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 197, "LogVPParams", "    HW Format MIC: %s", *(const char **)buf);
    if (*(void *)buf) {
      free(*(void **)buf);
    }
  }
  if (VPLogScope(void)::once != -1) {
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
  }
  std::string v42 = (void *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    std::string v43 = (*v42 ? *v42 : MEMORY[0x1E4F14500]);
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
    {
      int v44 = *((_DWORD *)this + 123);
      *(_DWORD *)AudioTimeStamp buf = 136315650;
      *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 198;
      *(_WORD *)&unsigned char buf[18] = 1024;
      *(_DWORD *)&buf[20] = v44;
      _os_log_impl(&dword_1BB0CE000, v43, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     HW Block Size REF: %d", buf, 0x18u);
    }
  }
  AudioBufferList v45 = (int *)*((void *)this + 1578);
  if (v45 && (*v155 || *((unsigned char *)this + 15962)))
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    CALegacyLog::log(v45, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 198, "LogVPParams", "    HW Block Size REF: %d", *((_DWORD *)this + 123));
  }
  if (VPLogScope(void)::once != -1) {
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
  }
  float v46 = (void *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    uint64_t v47 = (*v46 ? *v46 : MEMORY[0x1E4F14500]);
    if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
    {
      int v48 = *((_DWORD *)this + 124);
      *(_DWORD *)AudioTimeStamp buf = 136315650;
      *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 199;
      *(_WORD *)&unsigned char buf[18] = 1024;
      *(_DWORD *)&buf[20] = v48;
      _os_log_impl(&dword_1BB0CE000, v47, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     HW Block Size MIC: %d", buf, 0x18u);
    }
  }
  uint64_t v49 = (int *)*((void *)this + 1578);
  if (v49 && (*v155 || *((unsigned char *)this + 15962)))
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    CALegacyLog::log(v49, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 199, "LogVPParams", "    HW Block Size MIC: %d", *((_DWORD *)this + 124));
  }
  if (VPLogScope(void)::once != -1) {
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
  }
  size_t v50 = (void *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    DSPSplitComplex v51 = (*v50 ? *v50 : MEMORY[0x1E4F14500]);
    if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
    {
      CFDictionaryRef v52 = "internal";
      int v53 = *((_DWORD *)this + 286);
      float v54 = "enabled";
      if (!*((_DWORD *)this + 1129)) {
        CFDictionaryRef v52 = "external";
      }
      *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 201;
      *(_DWORD *)AudioTimeStamp buf = 136315906;
      *(_WORD *)&unsigned char buf[18] = 2080;
      *(void *)&buf[20] = v52;
      if (!v53) {
        float v54 = "n/a";
      }
      *(_WORD *)&unsigned char buf[28] = 2080;
      *(void *)&buf[30] = v54;
      _os_log_impl(&dword_1BB0CE000, v51, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     REF Signal: %s, Hw tap stream: %s", buf, 0x26u);
    }
  }
  float v55 = (int *)*((void *)this + 1578);
  if (v55 && (*v155 || *((unsigned char *)this + 15962)))
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    double v56 = "internal";
    if (!*((_DWORD *)this + 1129)) {
      double v56 = "external";
    }
    if (*((_DWORD *)this + 286)) {
      CFStringRef v57 = "enabled";
    }
    else {
      CFStringRef v57 = "n/a";
    }
    CALegacyLog::log(v55, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 201, "LogVPParams", "    REF Signal: %s, Hw tap stream: %s", v56, v57);
  }
  if (VPLogScope(void)::once != -1) {
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
  }
  uint64_t v58 = (void *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    uint64_t v59 = (*v58 ? *v58 : MEMORY[0x1E4F14500]);
    if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
    {
      int16x8_t v60 = *((int16x8_t *)this + 35);
      *(_OWORD *)AudioTimeStamp buf = *((_OWORD *)this + 34);
      *(int16x8_t *)&buf[16] = v60;
      *(void *)&unsigned char buf[32] = *((void *)this + 72);
      CA::StreamDescription::AsString((CA::StreamDescription *)buf, (uint64_t)__p, v60);
      float v61 = v157 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)UInt32 v159 = 136315650;
      *(void *)&v159[4] = "vpDebug_Logging.cpp";
      __int16 v160 = 1024;
      int v161 = 202;
      __int16 v162 = 2080;
      char v163 = v61;
      _os_log_impl(&dword_1BB0CE000, v59, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     HW Format EXT REF: %s", v159, 0x1Cu);
      if (v157 < 0) {
        operator delete(__p[0]);
      }
    }
  }
  __int16 v62 = (int *)*((void *)this + 1578);
  if (v62 && (*v155 || *((unsigned char *)this + 15962)))
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    uint64_t v63 = VPLogScope(void)::scope;
    int16x8_t v64 = *((int16x8_t *)this + 35);
    *(_OWORD *)AudioTimeStamp buf = *((_OWORD *)this + 34);
    *(int16x8_t *)&buf[16] = v64;
    *(void *)&unsigned char buf[32] = *((void *)this + 72);
    CA::StreamDescription::AsString((CA::StreamDescription *)buf, (uint64_t)v159, v64);
    if (SBYTE3(v163) >= 0) {
      size_t v65 = v159;
    }
    else {
      size_t v65 = *(const char **)v159;
    }
    CALegacyLog::log(v62, 3, v63, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 202, "LogVPParams", "    HW Format EXT REF: %s", v65);
    if (SBYTE3(v163) < 0) {
      operator delete(*(void **)v159);
    }
  }
  if (*((void *)this + 263) != *((void *)this + 262))
  {
    unint64_t v66 = 0;
    unsigned int v67 = 1;
    uint64_t v68 = MEMORY[0x1E4F14500];
    do
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      DSPSplitComplex v69 = (void *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
      {
        float v70 = (*v69 ? *v69 : v68);
        if (os_log_type_enabled(v70, OS_LOG_TYPE_DEBUG))
        {
          double v71 = *(float *)(*((void *)this + 262) + 4 * v66);
          *(_DWORD *)AudioTimeStamp buf = 136315906;
          *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 209;
          *(_WORD *)&unsigned char buf[18] = 1024;
          *(_DWORD *)&buf[20] = v67 - 1;
          *(_WORD *)&uint8_t buf[24] = 2048;
          *(double *)&buf[26] = v71;
          _os_log_impl(&dword_1BB0CE000, v70, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp>     HW Trim Gain MIC(ch-%d): %f dB", buf, 0x22u);
        }
      }
      uint64_t v72 = (int *)*((void *)this + 1578);
      if (v72 && (*v155 || *((unsigned char *)this + 15962)))
      {
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        CALegacyLog::log(v72, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 209, "LogVPParams", "    HW Trim Gain MIC(ch-%d): %f dB", v67 - 1, *(float *)(*((void *)this + 262) + 4 * v66));
      }
      unint64_t v66 = v67++;
    }
    while (v66 < (uint64_t)(*((void *)this + 263) - *((void *)this + 262)) >> 2);
  }
  if (*((void *)this + 267) != *((void *)this + 266))
  {
    unint64_t v73 = 0;
    unsigned int v74 = 1;
    uint64_t v75 = MEMORY[0x1E4F14500];
    do
    {
      if (VPLogScope(void)::once != -1) {
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
      }
      unsigned int v76 = (void *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
      {
        long long v77 = (*v76 ? *v76 : v75);
        if (os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG))
        {
          double v78 = *(float *)(*((void *)this + 266) + 4 * v73);
          *(_DWORD *)AudioTimeStamp buf = 136315906;
          *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 213;
          *(_WORD *)&unsigned char buf[18] = 1024;
          *(_DWORD *)&buf[20] = v74 - 1;
          *(_WORD *)&uint8_t buf[24] = 2048;
          *(double *)&buf[26] = v78;
          _os_log_impl(&dword_1BB0CE000, v77, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp>     HW Trim Gain REF(ch-%d): %f dB", buf, 0x22u);
        }
      }
      double v79 = (int *)*((void *)this + 1578);
      if (v79 && (*v155 || *((unsigned char *)this + 15962)))
      {
        if (VPLogScope(void)::once != -1) {
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
        }
        CALegacyLog::log(v79, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 213, "LogVPParams", "    HW Trim Gain REF(ch-%d): %f dB", v74 - 1, *(float *)(*((void *)this + 266) + 4 * v73));
      }
      unint64_t v73 = v74++;
    }
    while (v73 < (uint64_t)(*((void *)this + 267) - *((void *)this + 266)) >> 2);
  }
  if (VPLogScope(void)::once != -1) {
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
  }
  double v80 = (void *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    float v81 = (*v80 ? *v80 : MEMORY[0x1E4F14500]);
    if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
    {
      CAFormatter::CAFormatter((CAFormatter *)v159, (const AudioStreamBasicDescription *)((char *)this + 984));
      *(_DWORD *)AudioTimeStamp buf = 136315650;
      *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 215;
      *(_WORD *)&unsigned char buf[18] = 2080;
      *(void *)&buf[20] = *(void *)v159;
      _os_log_impl(&dword_1BB0CE000, v81, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     VP Output Format: %s", buf, 0x1Cu);
      if (*(void *)v159) {
        free(*(void **)v159);
      }
    }
  }
  __int16 v82 = (int *)*((void *)this + 1578);
  if (v82 && (*v155 || *((unsigned char *)this + 15962)))
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    uint64_t v83 = VPLogScope(void)::scope;
    CAFormatter::CAFormatter((CAFormatter *)buf, (const AudioStreamBasicDescription *)((char *)this + 984));
    CALegacyLog::log(v82, 3, v83, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 215, "LogVPParams", "    VP Output Format: %s", *(const char **)buf);
    if (*(void *)buf) {
      free(*(void **)buf);
    }
  }
  if (VPLogScope(void)::once != -1) {
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
  }
  __int16 v84 = (void *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    float v85 = (*v84 ? *v84 : MEMORY[0x1E4F14500]);
    if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT))
    {
      int v86 = *((_DWORD *)this + 100);
      int v87 = *((_DWORD *)this + 101);
      *(_DWORD *)AudioTimeStamp buf = 136315906;
      *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 217;
      *(_WORD *)&unsigned char buf[18] = 1024;
      *(_DWORD *)&buf[20] = v86;
      *(_WORD *)&uint8_t buf[24] = 1024;
      *(_DWORD *)&buf[26] = v87;
      _os_log_impl(&dword_1BB0CE000, v85, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     REF Channel BitMap: %x, OUT Channel BitMap: %x", buf, 0x1Eu);
    }
  }
  uint64_t v88 = (int *)*((void *)this + 1578);
  if (v88 && (*v155 || *((unsigned char *)this + 15962)))
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    CALegacyLog::log(v88, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 217, "LogVPParams", "    REF Channel BitMap: %x, OUT Channel BitMap: %x", *((_DWORD *)this + 100), *((_DWORD *)this + 101));
  }
  if (VPLogScope(void)::once != -1) {
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
  }
  float v89 = (void *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    char v90 = (*v89 ? *v89 : MEMORY[0x1E4F14500]);
    if (os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v91 = *((void *)this + 54);
      int v92 = *((_DWORD *)this + 106);
      *(_DWORD *)AudioTimeStamp buf = 136315906;
      *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 219;
      *(_WORD *)&unsigned char buf[18] = 2080;
      *(void *)&buf[20] = v91;
      *(_WORD *)&unsigned char buf[28] = 1024;
      *(_DWORD *)&buf[30] = v92;
      _os_log_impl(&dword_1BB0CE000, v90, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     HW MIC Channels: %s, BitMap: %x", buf, 0x22u);
    }
  }
  double v93 = (int *)*((void *)this + 1578);
  if (v93 && (*v155 || *((unsigned char *)this + 15962)))
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    CALegacyLog::log(v93, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 219, "LogVPParams", "    HW MIC Channels: %s, BitMap: %x", *((const char **)this + 54), *((_DWORD *)this + 106));
  }
  if (VPLogScope(void)::once != -1) {
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
  }
  long long v94 = (void *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    unsigned int v95 = (*v94 ? *v94 : MEMORY[0x1E4F14500]);
    if (os_log_type_enabled(v95, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v96 = *((void *)this + 57);
      int v97 = *((_DWORD *)this + 112);
      *(_DWORD *)AudioTimeStamp buf = 136315906;
      *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 221;
      *(_WORD *)&unsigned char buf[18] = 2080;
      *(void *)&buf[20] = v96;
      *(_WORD *)&unsigned char buf[28] = 1024;
      *(_DWORD *)&buf[30] = v97;
      _os_log_impl(&dword_1BB0CE000, v95, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     EP MIC Channels: %s, BitMap: %x", buf, 0x22u);
    }
  }
  float v98 = (int *)*((void *)this + 1578);
  if (v98 && (*v155 || *((unsigned char *)this + 15962)))
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    CALegacyLog::log(v98, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 221, "LogVPParams", "    EP MIC Channels: %s, BitMap: %x", *((const char **)this + 57), *((_DWORD *)this + 112));
  }
  if (VPLogScope(void)::once != -1) {
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
  }
  float v99 = (void *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    AudioFormatFlags v100 = (*v99 ? *v99 : MEMORY[0x1E4F14500]);
    if (os_log_type_enabled(v100, OS_LOG_TYPE_DEFAULT))
    {
      int v101 = 0;
      while (((*((_DWORD *)this + 116) >> v101) & 1) == 0)
      {
        if (++v101 == 32)
        {
          int v101 = 33;
          break;
        }
      }
      *(_DWORD *)AudioTimeStamp buf = 136315650;
      *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 223;
      *(_WORD *)&unsigned char buf[18] = 1024;
      *(_DWORD *)&buf[20] = v101;
      _os_log_impl(&dword_1BB0CE000, v100, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     Primary epmic index: %d", buf, 0x18u);
    }
  }
  CFStringRef v102 = (int *)*((void *)this + 1578);
  if (v102 && (*v155 || *((unsigned char *)this + 15962)))
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    int v103 = 0;
    while (((*((_DWORD *)this + 116) >> v103) & 1) == 0)
    {
      if (++v103 == 32)
      {
        int v103 = 33;
        break;
      }
    }
    CALegacyLog::log(v102, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 223, "LogVPParams", "    Primary epmic index: %d", v103);
  }
  if (VPLogScope(void)::once != -1) {
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
  }
  double v104 = (void *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    uint64_t v105 = (*v104 ? *v104 : MEMORY[0x1E4F14500]);
    if (os_log_type_enabled(v105, OS_LOG_TYPE_DEFAULT))
    {
      int v106 = *((_DWORD *)this + 1114);
      *(_DWORD *)AudioTimeStamp buf = 136315650;
      *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 225;
      *(_WORD *)&unsigned char buf[18] = 1024;
      *(_DWORD *)&buf[20] = v106;
      _os_log_impl(&dword_1BB0CE000, v105, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     SRC Quality: 0x%x (0:min, 0x20:low, 0x40:med, 0x60:hig, 0x7f:max)", buf, 0x18u);
    }
  }
  uint64_t v107 = (int *)*((void *)this + 1578);
  if (v107 && (*v155 || *((unsigned char *)this + 15962)))
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    CALegacyLog::log(v107, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 225, "LogVPParams", "    SRC Quality: 0x%x (0:min, 0x20:low, 0x40:med, 0x60:hig, 0x7f:max)", *((_DWORD *)this + 1114));
  }
  if (VPLogScope(void)::once != -1) {
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
  }
  id v108 = (void *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    uint64_t v109 = (*v108 ? *v108 : MEMORY[0x1E4F14500]);
    if (os_log_type_enabled(v109, OS_LOG_TYPE_DEFAULT))
    {
      double v110 = *((float *)this + 1113);
      *(_DWORD *)AudioTimeStamp buf = 136315650;
      *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 226;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(double *)&buf[20] = v110;
      _os_log_impl(&dword_1BB0CE000, v109, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     Hw real-world correction: %f samples", buf, 0x1Cu);
    }
  }
  uint64_t v111 = (int *)*((void *)this + 1578);
  if (v111 && (*v155 || *((unsigned char *)this + 15962)))
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    CALegacyLog::log(v111, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 226, "LogVPParams", "    Hw real-world correction: %f samples", *((float *)this + 1113));
  }
  if (VPLogScope(void)::once != -1) {
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
  }
  uint64_t v112 = (void *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    uint64_t v113 = (*v112 ? *v112 : MEMORY[0x1E4F14500]);
    if (os_log_type_enabled(v113, OS_LOG_TYPE_DEFAULT))
    {
      double v114 = *((float *)this + 1094);
      *(_DWORD *)AudioTimeStamp buf = 136315650;
      *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 227;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(double *)&buf[20] = v114;
      _os_log_impl(&dword_1BB0CE000, v113, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     Ref-Mic Delay: %f msec", buf, 0x1Cu);
    }
  }
  uint64_t v115 = (int *)*((void *)this + 1578);
  if (v115 && (*v155 || *((unsigned char *)this + 15962)))
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    CALegacyLog::log(v115, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 227, "LogVPParams", "    Ref-Mic Delay: %f msec", *((float *)this + 1094));
  }
  if (VPLogScope(void)::once != -1) {
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
  }
  uint64_t v116 = (void *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    unint64_t v117 = (*v116 ? *v116 : MEMORY[0x1E4F14500]);
    if (os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT))
    {
      double v118 = *((float *)this + 1092);
      *(_DWORD *)AudioTimeStamp buf = 136315650;
      *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 228;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(double *)&buf[20] = v118;
      _os_log_impl(&dword_1BB0CE000, v117, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     Pre-echo-processing Digital Input Gain: %f dB", buf, 0x1Cu);
    }
  }
  int v119 = (int *)*((void *)this + 1578);
  if (v119 && (*v155 || *((unsigned char *)this + 15962)))
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    CALegacyLog::log(v119, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 228, "LogVPParams", "    Pre-echo-processing Digital Input Gain: %f dB", *((float *)this + 1092));
  }
  if (VPLogScope(void)::once != -1) {
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
  }
  unint64_t v120 = (void *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    id v121 = (*v120 ? *v120 : MEMORY[0x1E4F14500]);
    if (os_log_type_enabled(v121, OS_LOG_TYPE_DEFAULT))
    {
      double v122 = *((float *)this + 1093);
      *(_DWORD *)AudioTimeStamp buf = 136315650;
      *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 229;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(double *)&buf[20] = v122;
      _os_log_impl(&dword_1BB0CE000, v121, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     Post-echo-processing Digital Input Gain: %f dB", buf, 0x1Cu);
    }
  }
  uint64_t v123 = (int *)*((void *)this + 1578);
  if (v123 && (*v155 || *((unsigned char *)this + 15962)))
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    CALegacyLog::log(v123, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 229, "LogVPParams", "    Post-echo-processing Digital Input Gain: %f dB", *((float *)this + 1093));
  }
  if (VPLogScope(void)::once != -1) {
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
  }
  Float64 v124 = (void *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    uint64_t v125 = (*v124 ? *v124 : MEMORY[0x1E4F14500]);
    if (os_log_type_enabled(v125, OS_LOG_TYPE_DEFAULT))
    {
      double v126 = *((float *)this + 1115);
      *(_DWORD *)AudioTimeStamp buf = 136315650;
      *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 233;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(double *)&buf[20] = v126;
      _os_log_impl(&dword_1BB0CE000, v125, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     Downlink Mix Gain: %f dB", buf, 0x1Cu);
    }
  }
  BOOL v127 = (int *)*((void *)this + 1578);
  if (v127 && (*v155 || *((unsigned char *)this + 15962)))
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    CALegacyLog::log(v127, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 233, "LogVPParams", "    Downlink Mix Gain: %f dB", *((float *)this + 1115));
  }
  if (VPLogScope(void)::once != -1) {
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
  }
  uint64_t v128 = (void *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    int v129 = (*v128 ? *v128 : MEMORY[0x1E4F14500]);
    if (os_log_type_enabled(v129, OS_LOG_TYPE_DEFAULT))
    {
      double v130 = *((float *)this + 1131);
      *(_DWORD *)AudioTimeStamp buf = 136315650;
      *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 234;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(double *)&buf[20] = v130;
      _os_log_impl(&dword_1BB0CE000, v129, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     Downlink Final Gain Chn 0: %f dB", buf, 0x1Cu);
    }
  }
  unsigned int v131 = (int *)*((void *)this + 1578);
  if (v131 && (*v155 || *((unsigned char *)this + 15962)))
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    CALegacyLog::log(v131, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 234, "LogVPParams", "    Downlink Final Gain Chn 0: %f dB", *((float *)this + 1131));
  }
  if (VPLogScope(void)::once != -1) {
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
  }
  int v132 = (void *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    UInt32 v133 = (*v132 ? *v132 : MEMORY[0x1E4F14500]);
    if (os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT))
    {
      double v134 = *((float *)this + 1132);
      *(_DWORD *)AudioTimeStamp buf = 136315650;
      *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 235;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(double *)&buf[20] = v134;
      _os_log_impl(&dword_1BB0CE000, v133, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     Downlink Final Gain Chn 1: %f dB", buf, 0x1Cu);
    }
  }
  UInt32 v135 = (int *)*((void *)this + 1578);
  if (v135 && (*v155 || *((unsigned char *)this + 15962)))
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    CALegacyLog::log(v135, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 235, "LogVPParams", "    Downlink Final Gain Chn 1: %f dB", *((float *)this + 1132));
  }
  if (VPLogScope(void)::once != -1) {
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
  }
  uint64_t v136 = (void *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    int v137 = (*v136 ? *v136 : MEMORY[0x1E4F14500]);
    if (os_log_type_enabled(v137, OS_LOG_TYPE_DEFAULT))
    {
      CAFormatter::CAFormatter((CAFormatter *)v159, (VoiceProcessorV2 *)((char *)this + 208));
      *(_DWORD *)AudioTimeStamp buf = 136315650;
      *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 236;
      *(_WORD *)&unsigned char buf[18] = 2080;
      *(void *)&buf[20] = *(void *)v159;
      _os_log_impl(&dword_1BB0CE000, v137, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     DL Format FEV: %s", buf, 0x1Cu);
      if (*(void *)v159) {
        free(*(void **)v159);
      }
    }
  }
  int v138 = (int *)*((void *)this + 1578);
  if (v138 && (*v155 || *((unsigned char *)this + 15962)))
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    uint64_t v139 = VPLogScope(void)::scope;
    CAFormatter::CAFormatter((CAFormatter *)buf, (VoiceProcessorV2 *)((char *)this + 208));
    CALegacyLog::log(v138, 3, v139, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 236, "LogVPParams", "    DL Format FEV: %s", *(const char **)buf);
    if (*(void *)buf) {
      free(*(void **)buf);
    }
  }
  if (VPLogScope(void)::once != -1) {
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
  }
  long long v140 = (void *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    id v141 = (*v140 ? *v140 : MEMORY[0x1E4F14500]);
    if (os_log_type_enabled(v141, OS_LOG_TYPE_DEFAULT))
    {
      CAFormatter::CAFormatter((CAFormatter *)v159, (VoiceProcessorV2 *)((char *)this + 288));
      *(_DWORD *)AudioTimeStamp buf = 136315650;
      *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 237;
      *(_WORD *)&unsigned char buf[18] = 2080;
      *(void *)&buf[20] = *(void *)v159;
      _os_log_impl(&dword_1BB0CE000, v141, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     DL Format FEV Process: %s", buf, 0x1Cu);
      if (*(void *)v159) {
        free(*(void **)v159);
      }
    }
  }
  unsigned int v142 = (int *)*((void *)this + 1578);
  if (v142 && (*v155 || *((unsigned char *)this + 15962)))
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    uint64_t v143 = VPLogScope(void)::scope;
    CAFormatter::CAFormatter((CAFormatter *)buf, (VoiceProcessorV2 *)((char *)this + 288));
    CALegacyLog::log(v142, 3, v143, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 237, "LogVPParams", "    DL Format FEV Process: %s", *(const char **)buf);
    if (*(void *)buf) {
      free(*(void **)buf);
    }
  }
  if (VPLogScope(void)::once != -1) {
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
  }
  uint64_t v144 = (void *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    int v145 = (*v144 ? *v144 : MEMORY[0x1E4F14500]);
    if (os_log_type_enabled(v145, OS_LOG_TYPE_DEFAULT))
    {
      CAFormatter::CAFormatter((CAFormatter *)v159, (VoiceProcessorV2 *)((char *)this + 328));
      *(_DWORD *)AudioTimeStamp buf = 136315650;
      *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 238;
      *(_WORD *)&unsigned char buf[18] = 2080;
      *(void *)&buf[20] = *(void *)v159;
      _os_log_impl(&dword_1BB0CE000, v145, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     DL Format MIX: %s", buf, 0x1Cu);
      if (*(void *)v159) {
        free(*(void **)v159);
      }
    }
  }
  uint64_t v146 = (int *)*((void *)this + 1578);
  if (v146 && (*v155 || *((unsigned char *)this + 15962)))
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    uint64_t v147 = VPLogScope(void)::scope;
    CAFormatter::CAFormatter((CAFormatter *)buf, (VoiceProcessorV2 *)((char *)this + 328));
    CALegacyLog::log(v146, 3, v147, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 238, "LogVPParams", "    DL Format MIX: %s", *(const char **)buf);
    if (*(void *)buf) {
      free(*(void **)buf);
    }
  }
  if (VPLogScope(void)::once != -1) {
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
  }
  float v148 = (void *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    char v149 = (*v148 ? *v148 : MEMORY[0x1E4F14500]);
    if (os_log_type_enabled(v149, OS_LOG_TYPE_DEFAULT))
    {
      int v150 = *((_DWORD *)this + 121);
      *(_DWORD *)AudioTimeStamp buf = 136315650;
      *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 239;
      *(_WORD *)&unsigned char buf[18] = 1024;
      *(_DWORD *)&buf[20] = v150;
      _os_log_impl(&dword_1BB0CE000, v149, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     DL Block Size MIX: %d", buf, 0x18u);
    }
  }
  int v151 = (int *)*((void *)this + 1578);
  if (v151 && (*v155 || *((unsigned char *)this + 15962)))
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    CALegacyLog::log(v151, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 239, "LogVPParams", "    DL Block Size MIX: %d", *((_DWORD *)this + 121));
  }
  if (VPLogScope(void)::once != -1) {
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
  }
  int v152 = (void *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    uint64_t v153 = (*v152 ? *v152 : MEMORY[0x1E4F14500]);
    if (os_log_type_enabled(v153, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)AudioTimeStamp buf = 136315394;
      *(void *)&uint8_t buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 241;
      _os_log_impl(&dword_1BB0CE000, v153, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp> ____________logparams:end___________", buf, 0x12u);
    }
  }
  AudioFormatFlags v154 = (int *)*((void *)this + 1578);
  if (v154 && (*v155 || v155[1]))
  {
    if (VPLogScope(void)::once != -1) {
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_30733);
    }
    CALegacyLog::log(v154, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 241, "LogVPParams", "____________logparams:end___________");
  }
}

void sub_1BB3B9B14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a17) {
    free(a17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t non-virtual thunk to'AUSpatialMixerV2::PropertyObserverIsInitialized(AUSpatialMixerV2 *this)
{
  unsigned __int8 v1 = atomic_load((unsigned __int8 *)this + 8449);
  return v1 & 1;
}

uint64_t non-virtual thunk to'AUSpatialMixerV2::PropertyChanged(AUSpatialMixerV2 *this, uint64_t a2)
{
  return AUSpatialMixerV2::PropertyChanged((AUSpatialMixerV2 *)((char *)this - 528), a2);
}

uint64_t AUSpatialMixerV2::PropertyChanged(AUSpatialMixerV2 *this, uint64_t a2)
{
  LOBYTE(v4) = 0;
  uint64_t v202 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = (unsigned __int8 *)this + 4928;
  if ((int)a2 > 3199)
  {
    if ((int)a2 <= 4599)
    {
      uint64_t v6 = 0;
      switch((int)a2)
      {
        case 3200:
        case 3201:
          unsigned __int8 v52 = atomic_load((unsigned __int8 *)this + 8977);
          if (v52) {
            goto LABEL_100;
          }
          return 0;
        case 3202:
        case 3203:
          AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(buf, (uint64_t)this + 3680);
          atomic_store(*(void *)buf != 0, v5 + 981);
          unsigned __int8 v49 = atomic_load(v5 + 4049);
          if ((v49 & 1) == 0) {
            goto LABEL_112;
          }
          size_t v50 = *(const void **)buf;
          if (*(void *)buf)
          {
            AUSpatialMixerV2::RefreshXTCTuningParameters(this);
            applesauce::CF::URLRef::URLRef((applesauce::CF::URLRef *)&v170, v50);
            LOBYTE(v50) = AUSpatialMixerV2::InitializeDynamicXTC((uint64_t)this, (CFURLRef *)&v170);
            applesauce::CF::URLRef::~URLRef(&v170);
          }
          AUSM::IRManager::updateXTCIRAttributes((AUSpatialMixerV2 *)((char *)this + 6176));
          if ((v50 & 1) == 0 && (unsigned int v51 = atomic_load((unsigned int *)this + 862), v51 == 2))
          {
            AUSpatialMixerV2::UpdateCounteractRotationShader(this);
            uint64_t v6 = AUSpatialMixerV2::PropagateGlobalPropertyChangeToInputElements(this, a2);
            LOBYTE(v4) = 1;
            AUSpatialMixerV2::UpdateReverbIfNecessary((uint64_t)this, -1, 1, 0);
          }
          else
          {
LABEL_112:
            LOBYTE(v4) = 0;
            uint64_t v6 = 0;
          }
          if (*(void *)buf) {
            CFRelease(*(CFTypeRef *)buf);
          }
          goto LABEL_259;
        case 3206:
        case 3207:
        case 3259:
        case 3260:
          int v7 = a2 & 0xFFFFFFFE;
          if ((a2 & 0xFFFFFFFE) == 0xC86) {
            unsigned int v8 = (char *)this + 4040;
          }
          else {
            unsigned int v8 = (char *)this + 4112;
          }
          if (v7 == 3206) {
            uint64_t v9 = (char *)this + 3896;
          }
          else {
            uint64_t v9 = (char *)this + 3968;
          }
          if (v7 == 3206) {
            long long v10 = (char *)this + 3752;
          }
          else {
            long long v10 = (char *)this + 3824;
          }
          AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(&v169, (uint64_t)v10);
          AudioFormatFlags v168 = 0;
          AUSM::AppleSauceCFWithMutex<__CFURL const*>::store((uint64_t)v8, &v168);
          CFTypeRef v12 = v169;
          if (v169
            && (IR::IRDataLoader::instance(v11),
                CFRetain(v12),
                v167[1] = v12,
                int v13 = IR::IRDataLoader::getAudioChannelLayoutTag(),
                BOOL v14 = ChannelLayoutTagIsSupportedHOA(v13),
                CFRelease(v12),
                v14))
          {
            if (getAUSMV2Log(void)::onceToken != -1) {
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
            }
            unint64_t v15 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v16 = (void *)((char *)this + 3368);
              if (*((char *)this + 3391) < 0) {
                uint64_t v16 = (void *)*v16;
              }
              *(_DWORD *)AudioTimeStamp buf = 136315394;
              *(void *)&uint8_t buf[4] = v16;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = "PropertyChanged";
              _os_log_impl(&dword_1BB0CE000, v15, OS_LOG_TYPE_DEFAULT, "[%s|%s] Early reflections IR is HOA: updating late reverb to use same IR file", buf, 0x16u);
            }

            CFRetain(v12);
            v167[0] = v12;
            AUSM::AppleSauceCFWithMutex<__CFURL const*>::store((uint64_t)v9, v167);
            CFRelease(v12);
          }
          else
          {
            AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(&v166, (uint64_t)v9);
            uint64_t v33 = v166;
            if (v166)
            {
              IR::IRDataLoader::instance(v32);
              CFRetain(v33);
              v165[1] = v33;
              int AudioChannelLayoutTag = IR::IRDataLoader::getAudioChannelLayoutTag();
              BOOL IsSupportedHOA = ChannelLayoutTagIsSupportedHOA(AudioChannelLayoutTag);
              CFRelease(v33);
              if (IsSupportedHOA)
              {
                if (getAUSMV2Log(void)::onceToken != -1) {
                  dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
                }
                int v36 = (id)getAUSMV2Log(void)::gLog;
                if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v37 = (void *)((char *)this + 3368);
                  if (*((char *)this + 3391) < 0) {
                    uint64_t v37 = (void *)*v37;
                  }
                  *(_DWORD *)AudioTimeStamp buf = 136315394;
                  *(void *)&uint8_t buf[4] = v37;
                  *(_WORD *)&unsigned char buf[12] = 2080;
                  *(void *)&buf[14] = "PropertyChanged";
                  _os_log_impl(&dword_1BB0CE000, v36, OS_LOG_TYPE_DEFAULT, "[%s|%s] Clearing late reverb HOA IR", buf, 0x16u);
                }

                v165[0] = 0;
                AUSM::AppleSauceCFWithMutex<__CFURL const*>::store((uint64_t)v9, v165);
                applesauce::CF::URLRef::~URLRef(v165);
              }
              CFRelease(v33);
            }
          }
          if (v7 == 3206
            || (std::mutex::lock((std::mutex *)((char *)this + 7736)),
                int v38 = v5[1768],
                std::mutex::unlock((std::mutex *)((char *)this + 7736)),
                !v38))
          {
            AUSpatialMixerV2::UpdateReverbIfNecessary((uint64_t)this, -1, 1, 0);
          }
          if (v12) {
            CFRelease(v12);
          }
          goto LABEL_257;
        case 3208:
        case 3209:
        case 3261:
        case 3262:
          int v20 = a2 & 0xFFFFFFFE;
          if ((a2 & 0xFFFFFFFE) == 0xC88) {
            unint64_t v21 = (char *)this + 4040;
          }
          else {
            unint64_t v21 = (char *)this + 4112;
          }
          if (v20 == 3208) {
            uint64_t v22 = (char *)this + 3752;
          }
          else {
            uint64_t v22 = (char *)this + 3824;
          }
          if (v20 == 3208) {
            size_t v23 = (char *)this + 3896;
          }
          else {
            size_t v23 = (char *)this + 3968;
          }
          AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(&v169, (uint64_t)v23);
          uint64_t v164 = 0;
          AUSM::AppleSauceCFWithMutex<__CFURL const*>::store((uint64_t)v21, &v164);
          CFTypeRef v25 = v169;
          if (v169
            && (IR::IRDataLoader::instance(v24),
                CFRetain(v25),
                v163[1] = v25,
                int v26 = IR::IRDataLoader::getAudioChannelLayoutTag(),
                BOOL v27 = ChannelLayoutTagIsSupportedHOA(v26),
                CFRelease(v25),
                v27))
          {
            if (getAUSMV2Log(void)::onceToken != -1) {
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
            }
            uint64_t v28 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
            {
              int v29 = (void *)((char *)this + 3368);
              if (*((char *)this + 3391) < 0) {
                int v29 = (void *)*v29;
              }
              *(_DWORD *)AudioTimeStamp buf = 136315394;
              *(void *)&uint8_t buf[4] = v29;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = "PropertyChanged";
              _os_log_impl(&dword_1BB0CE000, v28, OS_LOG_TYPE_DEFAULT, "[%s|%s] Late IR is HOA: updating early reflections to use same IR file", buf, 0x16u);
            }

            CFRetain(v25);
            v163[0] = v25;
            AUSM::AppleSauceCFWithMutex<__CFURL const*>::store((uint64_t)v22, v163);
            CFRelease(v25);
          }
          else
          {
            AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(&v166, (uint64_t)v22);
            int v40 = v166;
            if (v166)
            {
              IR::IRDataLoader::instance(v39);
              CFRetain(v40);
              v162[1] = v40;
              int v41 = IR::IRDataLoader::getAudioChannelLayoutTag();
              BOOL v42 = ChannelLayoutTagIsSupportedHOA(v41);
              CFRelease(v40);
              if (v42)
              {
                if (getAUSMV2Log(void)::onceToken != -1) {
                  dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
                }
                std::string v43 = (id)getAUSMV2Log(void)::gLog;
                if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
                {
                  int v44 = (void *)((char *)this + 3368);
                  if (*((char *)this + 3391) < 0) {
                    int v44 = (void *)*v44;
                  }
                  *(_DWORD *)AudioTimeStamp buf = 136315394;
                  *(void *)&uint8_t buf[4] = v44;
                  *(_WORD *)&unsigned char buf[12] = 2080;
                  *(void *)&buf[14] = "PropertyChanged";
                  _os_log_impl(&dword_1BB0CE000, v43, OS_LOG_TYPE_DEFAULT, "[%s|%s] Clearing early reflections HOA IR", buf, 0x16u);
                }

                v162[0] = 0;
                AUSM::AppleSauceCFWithMutex<__CFURL const*>::store((uint64_t)v22, v162);
                applesauce::CF::URLRef::~URLRef(v162);
              }
              CFRelease(v40);
            }
          }
          if (v20 == 3208
            || (std::mutex::lock((std::mutex *)((char *)this + 7736)),
                int v45 = v5[1768],
                std::mutex::unlock((std::mutex *)((char *)this + 7736)),
                !v45))
          {
            AUSpatialMixerV2::UpdateReverbIfNecessary((uint64_t)this, -1, 1, 0);
          }
          if (v25) {
            CFRelease(v25);
          }
          goto LABEL_257;
        case 3223:
        case 3265:
          uint64_t v6 = 0;
          int v53 = (unsigned __int8 *)this + 8893;
          goto LABEL_250;
        case 3231:
          unsigned __int8 v76 = atomic_load((unsigned __int8 *)this + 8977);
          if (v76) {
            return 4294956447;
          }
          caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)this + 3072);
          AUSM::TuningManager::ResetReservedGlobalAPACPropertyList((AUSpatialMixerV2 *)((char *)this + 6000));
          uint64_t v6 = AUSM::Metadata::ingestImmersiveRendererData(*((void *)this + 68));
          caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock((uint64_t)this + 3072);
LABEL_140:
          LOBYTE(v4) = 0;
          break;
        case 3233:
          goto LABEL_106;
        case 3234:
          unsigned __int8 v65 = atomic_load((unsigned __int8 *)this + 4936);
          if (v65 & 1) == 0 || (unsigned __int8 v66 = atomic_load((unsigned __int8 *)this + 4937), (v66)) {
            AudioDSP::Core::HeadTracker::UnregisterUserChoiceListener((AUSpatialMixerV2 *)((char *)this + 8944));
          }
          else {
            AudioDSP::Core::HeadTracker::RegisterUserChoiceListener((AUSpatialMixerV2 *)((char *)this + 8944));
          }
          goto LABEL_257;
        case 3235:
          CFStringRef v102 = (unsigned __int8 *)this + 8889;
          goto LABEL_201;
        case 3237:
          _X20 = 0;
          _X21 = 0;
          __asm { CASPAL          X20, X21, X20, X21, [X8] }
          float v70 = (AUSpatialMixerV2 *)((char *)this + 32);
          uint64_t Element = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUSpatialMixerV2 *)((char *)this + 32), 0);
          ausdk::AUElement::SetParameter(Element, 0x24u, *(float *)&_X20, 0);
          uint64_t v72 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v70, 0);
          ausdk::AUElement::SetParameter(v72, 0x25u, *((float *)&_X20 + 1), 0);
          unint64_t v73 = (ausdk::AUElement *)ausdk::AUScope::GetElement(v70, 0);
          ausdk::AUElement::SetParameter(v73, 0x26u, 0.0, 0);
          goto LABEL_125;
        case 3238:
LABEL_125:
          uint64_t v6 = 0;
          int v53 = v5 + 3962;
          goto LABEL_250;
        case 3239:
          if (*((void *)this + 771))
          {
            unsigned __int8 v74 = atomic_load((unsigned __int8 *)this + 8977);
            if (v74)
            {
              uint64_t v75 = *((void *)this + 771);
              AUSM::AppleSauceCFWithMutex<__CFDictionary const*>::load(&v181, (uint64_t)this + 5048);
              AUSM::RoomCongruence::Processor::process((uint64_t)buf, v75, &v181);
              applesauce::CF::DictionaryRef::~DictionaryRef(&v181);
              if (v201)
              {
                if (v200)
                {
                  v179[0] = 0;
                  char v180 = 0;
                  if (v197)
                  {
                    IR::IRDataAttributes::IRDataAttributes((uint64_t)v179, (uint64_t)buf);
                    char v180 = 1;
                  }
                  AUSM::IRManager::setRoomCongruenceAttributes((uint64_t)this + 6176, (uint64_t)v179);
                  if (v180) {
                    IR::IRDataAttributes::~IRDataAttributes((IR::IRDataAttributes *)v179);
                  }
                  if (!v201) {
                    std::__throw_bad_optional_access[abi:ne180100]();
                  }
                  AUSM::Properties::setProperty((AUSpatialMixerV2 *)((char *)this + 3360), 3248, &v198, 8, 0);
                  if (!v201) {
                    std::__throw_bad_optional_access[abi:ne180100]();
                  }
                  if (v199)
                  {
                    applesauce::CF::DictionaryRef::DictionaryRef((applesauce::CF::DictionaryRef *)&v178, v199);
                    AUSM::AppleSauceCFWithMutex<__CFDictionary const*>::store((uint64_t)this + 5264, &v178);
                    applesauce::CF::DictionaryRef::~DictionaryRef(&v178);
                  }
                }
                else
                {
                  v176[0] = 0;
                  char v177 = 0;
                  AUSM::IRManager::setRoomCongruenceAttributes((uint64_t)this + 6176, (uint64_t)v176);
                  if (v177) {
                    IR::IRDataAttributes::~IRDataAttributes((IR::IRDataAttributes *)v176);
                  }
                  AUSM::Properties::setProperty((AUSpatialMixerV2 *)((char *)this + 3360), 3248, 0, 8, 0);
                  AUSM::Properties::setProperty((AUSpatialMixerV2 *)((char *)this + 3360), 3249, 0, 8, 0);
                }
                AUSpatialMixerV2::UpdateReverbIfNecessary((uint64_t)this, -1, 0, 0);
                if (v201) {
                  AUSM::RoomCongruence::ProcessingResult::~ProcessingResult((AUSM::RoomCongruence::ProcessingResult *)buf);
                }
              }
            }
          }
          goto LABEL_257;
        case 3240:
          if (*((unsigned char *)this + 5968)) {
            goto LABEL_257;
          }
          LOBYTE(v4) = 0;
          uint64_t v6 = 0;
          unsigned int v64 = atomic_load((unsigned int *)this + 1461);
          atomic_store(v64, (unsigned int *)this + 2056);
          goto LABEL_259;
        case 3241:
          if (*((unsigned char *)this + 5968)) {
            goto LABEL_257;
          }
          LOBYTE(v4) = 0;
          uint64_t v6 = 0;
          float v81 = COERCE_FLOAT(atomic_load((unsigned int *)this + 1462));
          float v82 = 5.0;
          if (v81 <= 5.0) {
            float v82 = v81;
          }
          if (v81 >= 0.001) {
            float v83 = v82;
          }
          else {
            float v83 = 0.001;
          }
          *((float *)this + 2057) = v83;
          goto LABEL_259;
        case 3243:
          atomic_load((unsigned __int8 *)this + 4937);
          AudioDSP::Core::HeadTracker::SetCanAccessHALAPIs((AUSpatialMixerV2 *)((char *)this + 8944));
          goto LABEL_257;
        case 3246:
        case 3247:
          UInt32 v159 = 0;
          AUSM::AppleSauceCFWithMutex<__CFURL const*>::store((uint64_t)this + 3752, &v159);
          uint64_t v158 = 0;
          AUSM::AppleSauceCFWithMutex<__CFURL const*>::store((uint64_t)this + 3896, &v158);
          int v30 = this;
          int v31 = 0;
          goto LABEL_103;
        case 3248:
          unsigned __int8 v84 = atomic_load((unsigned __int8 *)this + 8977);
          if (v84)
          {
            caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)this + 3088);
            AUSM::AppleSauceCFWithMutex<__CFDictionary const*>::load(&v169, (uint64_t)this + 5192);
            float v85 = (ParametricFilters *)*((void *)this + 1123);
            if (v85)
            {
              if (v169)
              {
                applesauce::CF::DictionaryRef::DictionaryRef((applesauce::CF::DictionaryRef *)&v157, v169);
                memset(buf, 0, sizeof(buf));
                ParametricFilters::setParametricFilters((uint64_t)v85, (CFDictionaryRef *)&v157, (uint64_t)buf);
                applesauce::CF::DictionaryRef::~DictionaryRef(&v157);
              }
              else
              {
                ParametricFilters::clear(v85);
              }
            }
            int v152 = (ParametricFilters *)*((void *)this + 1124);
            if (v152)
            {
              if (v169)
              {
                applesauce::CF::DictionaryRef::DictionaryRef((applesauce::CF::DictionaryRef *)&v156, v169);
                memset(buf, 0, sizeof(buf));
                ParametricFilters::setParametricFilters((uint64_t)v152, (CFDictionaryRef *)&v156, (uint64_t)buf);
                applesauce::CF::DictionaryRef::~DictionaryRef(&v156);
              }
              else
              {
                ParametricFilters::clear(v152);
              }
            }
            applesauce::CF::DictionaryRef::~DictionaryRef(&v169);
            caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock((uint64_t)this + 3088);
          }
          goto LABEL_257;
        case 3249:
          AUSM::AppleSauceCFWithMutex<__CFDictionary const*>::load(&v169, (uint64_t)this + 5264);
          unsigned __int8 v86 = atomic_load(v5 + 4049);
          if (v86)
          {
            *(void *)AudioTimeStamp buf = (char *)this + 3120;
            buf[8] = 1;
            std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)((char *)this + 3120));
            for (unsigned int i = 0; ; ++i)
            {
              uint64_t v88 = *((void *)this + 15);
              if (v88) {
                LODWORD(v89) = (*(uint64_t (**)(uint64_t))(*(void *)v88 + 24))(v88);
              }
              else {
                uint64_t v89 = (*((void *)this + 13) - *((void *)this + 12)) >> 3;
              }
              if (i >= v89) {
                break;
              }
              unsigned int v90 = atomic_load((unsigned int *)this + 2252);
              if ((v90 & 0x80000000) == 0)
              {
                unsigned int v91 = atomic_load((unsigned int *)this + 2252);
                CFTypeRef v92 = v169;
                if (v169) {
                  CFRetain(v169);
                }
                id v155 = v92;
                IR::SharedIRBuses::setParametricFiltersCoeffs((uint64_t)this + 2104, i + v91, &v155);
                if (v92) {
                  CFRelease(v92);
                }
              }
              unsigned int v93 = atomic_load((unsigned int *)this + 2253);
              if ((v93 & 0x80000000) == 0)
              {
                unsigned int v94 = atomic_load((unsigned int *)this + 2253);
                CFTypeRef v95 = v169;
                if (v169) {
                  CFRetain(v169);
                }
                AudioFormatFlags v154 = v95;
                IR::SharedIRBuses::setParametricFiltersCoeffs((uint64_t)this + 2104, i + v94, &v154);
                if (v95) {
                  CFRelease(v95);
                }
              }
            }
            std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)buf);
          }
          goto LABEL_233;
        case 3252:
          unsigned __int8 v96 = atomic_load((unsigned __int8 *)this + 8977);
          if (v96)
          {
            *(void *)AudioTimeStamp buf = (char *)this + 3120;
            buf[8] = 1;
            std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)((char *)this + 3120));
            unsigned __int8 v97 = atomic_load((unsigned __int8 *)this + 2552);
            if (v97 & 1) != 0 || (unsigned __int8 v98 = atomic_load((unsigned __int8 *)this + 2553), (v98))
            {
              unsigned __int8 v99 = atomic_load((unsigned __int8 *)this + 2552);
              char v100 = v99 & 1;
              unsigned __int8 v101 = atomic_load((unsigned __int8 *)this + 2553);
              AUSpatialMixerV2::UpdateAutoModeReverb(this, v100, v101 & 1, -1);
            }
            std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)buf);
          }
          goto LABEL_257;
        case 3254:
          if (!*((void *)this + 771)) {
            goto LABEL_257;
          }
          unsigned __int8 v104 = atomic_load((unsigned __int8 *)this + 8977);
          if ((v104 & 1) == 0) {
            goto LABEL_257;
          }
          uint64_t v105 = (float *)*((void *)this + 771);
          AUSM::AppleSauceCFWithMutex<__CFDictionary const*>::load(&v175, (uint64_t)this + 5408);
          AUSM::RoomCongruence::Processor::setTuningParameters(v105, &v175);
          applesauce::CF::DictionaryRef::~DictionaryRef(&v175);
          AUSM::AppleSauceCFWithMutex<__CFDictionary const*>::load(buf, (uint64_t)this + 5048);
          uint64_t v6 = *(void *)buf;
          applesauce::CF::DictionaryRef::~DictionaryRef((const void **)buf);
          if (!v6) {
            goto LABEL_140;
          }
          (*(void (**)(AUSpatialMixerV2 *, uint64_t))(*(void *)this + 592))(this, 3239);
          goto LABEL_257;
        case 3263:
        case 3264:
          int v161 = 0;
          AUSM::AppleSauceCFWithMutex<__CFURL const*>::store((uint64_t)this + 3824, &v161);
          __int16 v160 = 0;
          AUSM::AppleSauceCFWithMutex<__CFURL const*>::store((uint64_t)this + 3968, &v160);
          std::mutex::lock((std::mutex *)((char *)this + 7736));
          int v4 = v5[1768];
          std::mutex::unlock((std::mutex *)((char *)this + 7736));
          if (v4) {
            goto LABEL_257;
          }
          AUSpatialMixerV2::UpdateReverbIfNecessary((uint64_t)this, -1, 0, 0);
          goto LABEL_258;
        case 3266:
          if ((AUSM::IRManager::hasRoomCongruenceAttributes((AUSpatialMixerV2 *)((char *)this + 6176)) & 1) == 0) {
            goto LABEL_123;
          }
          goto LABEL_257;
        case 3267:
          goto LABEL_54;
        case 3279:
          AUSM::AppleSauceCFWithMutex<__CFDictionary const*>::load(&v169, (uint64_t)this + 5480);
          int v103 = (CFDictionaryRef *)applesauce::CF::DictionaryRef::operator->(&v169);
          applesauce::CF::details::find_at_key_or_optional<applesauce::CF::DictionaryRef,__CFString const*&>(buf, *v103, (const void *)kOptionalFeatureConvolutionOptimizationParameters);
          if (buf[8])
          {
            applesauce::CF::DictionaryRef::DictionaryRef((applesauce::CF::DictionaryRef *)&v166, *(CFTypeRef *)buf);
            (*(void (**)(AUSpatialMixerV2 *, uint64_t, void, void, const void **, uint64_t))(*(void *)this + 96))(this, 3252, 0, 0, &v166, 8);
            applesauce::CF::DictionaryRef::~DictionaryRef(&v166);
          }
          std::__optional_destruct_base<applesauce::CF::DictionaryRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)buf);
LABEL_233:
          applesauce::CF::DictionaryRef::~DictionaryRef(&v169);
          goto LABEL_257;
        case 3280:
          long long v77 = (__float2 *)((char *)this + 2948);
          float v78 = COERCE_FLOAT(atomic_load((unsigned int *)this + 1473));
          float v79 = 1.0;
          if (v78 <= 1.0) {
            float v79 = v78;
          }
          float v80 = 0.0;
          if (v78 >= 0.0) {
            float v80 = v79;
          }
          *((float *)this + 742) = v80;
          MidSideRotation::calculateCoefficients(v77);
          goto LABEL_257;
        default:
          goto LABEL_259;
      }
      goto LABEL_259;
    }
    if ((int)a2 <= 5681)
    {
      if (a2 != 4600)
      {
        uint64_t v6 = 0;
        if (a2 != 5681) {
          goto LABEL_259;
        }
        AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(buf, (uint64_t)this + 4784);
        int DynamicProcessorPreset = AUSpatialMixerV2::LoadDynamicProcessorPreset(this, 1667658347, (CFURLRef *)buf);
LABEL_189:
        LODWORD(v6) = DynamicProcessorPreset;
        applesauce::CF::URLRef::~URLRef((const void **)buf);
        LOBYTE(v4) = 0;
        if (*((unsigned char *)this + 17)) {
          uint64_t v6 = v6;
        }
        else {
          uint64_t v6 = 0;
        }
LABEL_259:
        if ((v4 & 1) == 0 && !v6) {
          return AUSpatialMixerV2::PropagateGlobalPropertyChangeToInputElements(this, a2);
        }
        return v6;
      }
      goto LABEL_116;
    }
    if (a2 == 5682)
    {
      AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(buf, (uint64_t)this + 4856);
      int DynamicProcessorPreset = AUSpatialMixerV2::LoadDynamicProcessorPreset(this, 1818521197, (CFURLRef *)buf);
      goto LABEL_189;
    }
    uint64_t v6 = 0;
    if (a2 != 5687) {
      goto LABEL_259;
    }
    unsigned __int8 v46 = atomic_load((unsigned __int8 *)this + 8978);
    if (v46)
    {
      uint64_t v6 = AUSpatialMixerV2::PropagateGlobalPropertyChangeToInputElements(this, 5687);
      uint64_t v47 = *((void *)this + 51);
      uint64_t v48 = *((void *)this + 52);
      while (v47 != v48)
      {
        if (*(_DWORD *)v47 == 3116) {
          (*(void (**)(void, void, uint64_t, void, void))(v47 + 8))(*(void *)(v47 + 16), *((void *)this + 1), 3116, 0, 0);
        }
        v47 += 24;
      }
      AUSpatialMixerV2::ReloadFactoryPresetIfNecessary(this);
      unsigned int v143 = atomic_load((unsigned int *)this + 862);
      if (v143 == 1) {
        AUSpatialMixerV2::UpdateReverbIfNecessary((uint64_t)this, -1, 1, 1);
      }
      return v6;
    }
LABEL_257:
    LOBYTE(v4) = 0;
LABEL_258:
    uint64_t v6 = 0;
    goto LABEL_259;
  }
  if ((int)a2 > 3012)
  {
    uint64_t v6 = 0;
    switch((int)a2)
    {
      case 3100:
        unsigned int v17 = atomic_load((unsigned int *)this + 862);
        if (v17 == 2)
        {
          unsigned __int8 v18 = atomic_load((unsigned __int8 *)this + 8977);
          if (v18) {
            AUSpatialMixerV2::UpdateCounteractRotationShader(this);
          }
        }
        (*(void (**)(AUSpatialMixerV2 *, uint64_t))(*(void *)this + 592))(this, 3113);
        goto LABEL_54;
      case 3101:
        atomic_store(1u, (unsigned __int8 *)this + 8891);
        unsigned __int8 v119 = atomic_load((unsigned __int8 *)this + 8977);
        if (v119)
        {
          unsigned int v120 = atomic_load((unsigned int *)this + 862);
          if (v120 == 2)
          {
            unsigned __int8 v121 = atomic_load((unsigned __int8 *)this + 2552);
            if (v121)
            {
              *(void *)AudioTimeStamp buf = (char *)this + 3120;
              buf[8] = 1;
              std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)((char *)this + 3120));
              AUSpatialMixerV2::UpdateAutoModeReverb(this, 1, 0, -1);
              std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)buf);
            }
          }
        }
        return 0;
      case 3102:
        _X0 = 0;
        atomic_store(1u, v5 + 3961);
        _X1 = 0;
        __asm { CASPAL          X0, X1, X0, X1, [X21]; this }
        float v125 = AUSM::auCoordQuaternionToEuler(_X0, (float32x4_t)(unint64_t)_X0);
        float v127 = v126;
        float v129 = v128;
        double v130 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUSpatialMixerV2 *)((char *)this + 32), 0);
        ausdk::AUElement::SetParameter(v130, 0x13u, v125, 0);
        unsigned int v131 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUSpatialMixerV2 *)((char *)this + 32), 0);
        ausdk::AUElement::SetParameter(v131, 0x14u, v127, 0);
        int v132 = (ausdk::AUElement *)ausdk::AUScope::GetElement((AUSpatialMixerV2 *)((char *)this + 32), 0);
        ausdk::AUElement::SetParameter(v132, 0x15u, v129, 0);
        if ((*((unsigned char *)this + 5936) & 4) != 0)
        {
          _X22 = 0;
          _X23 = 0;
          __asm { CASPAL          X22, X23, X22, X23, [X21] }
          if (getAUSMV2Log(void)::onceToken != -1) {
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
          }
          uint64_t v136 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v136, OS_LOG_TYPE_DEFAULT))
          {
            int v137 = (void *)((char *)this + 3368);
            if (*((char *)this + 3391) < 0) {
              int v137 = (void *)*v137;
            }
            *(_DWORD *)AudioTimeStamp buf = 136317186;
            *(void *)&uint8_t buf[4] = v137;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = "PropertyChanged";
            *(_WORD *)&buf[22] = 2048;
            double v184 = v125;
            __int16 v185 = 2048;
            double v186 = v127;
            __int16 v187 = 2048;
            double v188 = v129;
            __int16 v189 = 2048;
            double v190 = *(float *)&_X22;
            __int16 v191 = 2048;
            double v192 = *((float *)&_X22 + 1);
            __int16 v193 = 2048;
            double v194 = 0.0;
            __int16 v195 = 2048;
            double v196 = 0.0;
            _os_log_impl(&dword_1BB0CE000, v136, OS_LOG_TYPE_DEFAULT, "[%s|%s] AUSMHeadOrientation: Y: %.2f, P: %.2f, R: %.2f, Quat: (%.4f, %.4f, %.4f, %.4f)", buf, 0x5Cu);
          }
        }
        goto LABEL_202;
      case 3103:
      case 3104:
      case 3105:
      case 3106:
      case 3108:
      case 3109:
      case 3110:
      case 3112:
        goto LABEL_259;
      case 3107:
        unsigned __int8 v114 = atomic_load((unsigned __int8 *)this + 8977);
        if ((v114 & 1) == 0) {
          goto LABEL_257;
        }
        unsigned __int8 v115 = atomic_load((unsigned __int8 *)this + 3444);
        if (v115) {
          uint64_t v116 = (void (*)(uint64_t, void *))MEMORY[0x1E4F147E8];
        }
        else {
          uint64_t v116 = (void (*)(uint64_t, void *))MEMORY[0x1E4F14768];
        }
        unint64_t v117 = (void *)*((void *)this + 327);
        uint64_t v118 = applesauce::dispatch::v1::queue::get(v117);
        v171[0] = MEMORY[0x1E4F143A8];
        v171[1] = 3221225472;
        v171[2] = ___ZN16AUSpatialMixerV215PropertyChangedEj_block_invoke;
        v171[3] = &__block_descriptor_40_e5_v8__0l;
        v171[4] = this;
        v116(v118, v171);

        return 0;
      case 3111:
LABEL_106:
        unsigned __int8 v54 = atomic_load((unsigned __int8 *)this + 8977);
        if ((v54 & 1) == 0) {
          goto LABEL_257;
        }
        unsigned __int8 v55 = atomic_load(v5);
        if (v55)
        {
          AudioDSP::Core::HeadTracker::Initialize();
          if (atomic_load((unsigned int *)this + 1233))
          {
            atomic_load((unsigned int *)this + 1233);
            AudioDSP::Core::HeadTracker::ConnectRM();
            return 0;
          }
          AudioDSP::Core::HeadTracker::DisconnectRM((AUSpatialMixerV2 *)((char *)this + 8944));
          uint64_t v148 = *((void *)this + 436);
          do
          {
            _X2 = 0;
            _X5 = *((void *)this + 437);
            __asm { CASPAL          X4, X5, X2, X3, [X8] }
            _ZF = _X4 == v148;
            uint64_t v148 = _X4;
          }
          while (!_ZF);
        }
        else
        {
          AudioDSP::Core::HeadTracker::DisconnectRM((AUSpatialMixerV2 *)((char *)this + 8944));
          uint64_t v56 = *((void *)this + 436);
          do
          {
            _X2 = 0;
            _X5 = *((void *)this + 437);
            __asm { CASPAL          X4, X5, X2, X3, [X8] }
            _ZF = _X4 == v56;
            uint64_t v56 = _X4;
          }
          while (!_ZF);
        }
        uint64_t v6 = 0;
        int v53 = v5 + 3961;
        goto LABEL_250;
      case 3113:
        unsigned __int8 v138 = atomic_load((unsigned __int8 *)this + 8977);
        if ((v138 & 1) == 0) {
          return 0;
        }
        BOOL CanUsePersonalizedHRTF = AUSpatialMixerV2::CanUsePersonalizedHRTF(this);
        if (CanUsePersonalizedHRTF)
        {
          unsigned int v140 = atomic_load((unsigned int *)this + 1235);
          unsigned int v141 = v140 - 1;
          IR::IRDataLoader::instance((IR::IRDataLoader *)CanUsePersonalizedHRTF);
          if (v141 > 1)
          {
            std::operator+<char>();
            IR::IRDataLoader::removeFromPersonalizedHRTFCallbackPool();
            if ((v172[23] & 0x80000000) == 0) {
              goto LABEL_266;
            }
            unsigned int v142 = (void **)v172;
          }
          else
          {
            std::operator+<char>();
            v182[0] = &unk_1F14AD380;
            v182[1] = this;
            v182[3] = v182;
            IR::IRDataLoader::addToPersonalizedHRTFCallbackPool();
            std::__function::__value_func<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>::~__value_func[abi:ne180100](v182);
            if ((v173[23] & 0x80000000) == 0) {
              goto LABEL_266;
            }
            unsigned int v142 = (void **)v173;
          }
        }
        else
        {
          if (getAUSMV2Log(void)::onceToken != -1) {
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
          }
          int v145 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v145, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v146 = (void *)((char *)this + 3368);
            if (*((char *)this + 3391) < 0) {
              uint64_t v146 = (void *)*v146;
            }
            *(_DWORD *)AudioTimeStamp buf = 136315394;
            *(void *)&uint8_t buf[4] = v146;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = "PropertyChanged";
            _os_log_impl(&dword_1BB0CE000, v145, OS_LOG_TYPE_DEFAULT, "[%s|%s] Configuration does not support personalized HRTF.", buf, 0x16u);
          }

          IR::IRDataLoader::instance(v147);
          std::operator+<char>();
          IR::IRDataLoader::removeFromPersonalizedHRTFCallbackPool();
          if ((v174[23] & 0x80000000) == 0)
          {
LABEL_266:
            AUSM::IRManager::updateHRIRAttributes((AUSpatialMixerV2 *)((char *)this + 6176));
            (*(void (**)(AUSpatialMixerV2 *, uint64_t))(*(void *)this + 592))(this, 5687);
            return 0;
          }
          unsigned int v142 = (void **)v174;
        }
        operator delete(*v142);
        goto LABEL_266;
      case 3114:
        unsigned __int8 v111 = atomic_load((unsigned __int8 *)this + 8977);
        if (v111)
        {
          if (atomic_load((unsigned int *)this + 1235))
          {
            uint64_t v113 = (IR::IRDataLoader *)IR::IRDataLoader::instance(this);
            if ((IR::IRDataLoader::hasFailedToFetchPersonalizedHRTF(v113) & 1) == 0)
            {
LABEL_100:
              AUSM::IRManager::updateHRIRAttributes((AUSpatialMixerV2 *)((char *)this + 6176));
              (*(void (**)(AUSpatialMixerV2 *, uint64_t))(*(void *)this + 592))(this, 5687);
            }
          }
        }
        return 0;
      case 3115:
        if ((*((unsigned char *)this + 5936) & 8) != 0)
        {
          _X22 = 0;
          _X23 = 0;
          __asm { CASPAL          X22, X23, X22, X23, [X8] }
          if (getAUSMV2Log(void)::onceToken != -1) {
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
          }
          uint64_t v109 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v109, OS_LOG_TYPE_DEFAULT))
          {
            double v110 = (void *)((char *)this + 3368);
            if (*((char *)this + 3391) < 0) {
              double v110 = (void *)*v110;
            }
            *(_DWORD *)AudioTimeStamp buf = 136316162;
            *(void *)&uint8_t buf[4] = v110;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = "PropertyChanged";
            *(_WORD *)&buf[22] = 2048;
            double v184 = *(float *)&_X22;
            __int16 v185 = 2048;
            double v186 = *((float *)&_X22 + 1);
            __int16 v187 = 2048;
            double v188 = 0.0;
            _os_log_impl(&dword_1BB0CE000, v109, OS_LOG_TYPE_DEFAULT, "[%s|%s] AUSM_PRESENTATION_POS: X (left-right): %.4f, Y (back-front): %.4f, Z (down-up): %.4f", buf, 0x34u);
          }
        }
        CFStringRef v102 = v5 + 3960;
LABEL_201:
        atomic_store(1u, v102);
LABEL_202:
        AUSpatialMixerV2::UpdateStereoBusRotationParameters(this);
        return 0;
      default:
        if (a2 == 3013) {
          goto LABEL_116;
        }
        goto LABEL_259;
    }
  }
  if (a2 == 10)
  {
LABEL_123:
    AUSpatialMixerV2::UpdateReverbRoomType(this);
    goto LABEL_257;
  }
  if (a2 == 1005)
  {
LABEL_54:
    int v30 = this;
    int v31 = 1;
LABEL_103:
    AUSpatialMixerV2::UpdateReverbIfNecessary((uint64_t)v30, -1, v31, 0);
    goto LABEL_257;
  }
  uint64_t v6 = 0;
  if (a2 != 3010) {
    goto LABEL_259;
  }
LABEL_116:
  uint64_t v6 = 0;
  int v53 = (unsigned __int8 *)this + 8892;
LABEL_250:
  atomic_store(1u, v53);
  return v6;
}

void sub_1BB3BB350(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *__p,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,__int16 a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (a66) {
    IR::IRDataAttributes::~IRDataAttributes((IR::IRDataAttributes *)&a47);
  }
  if (LOBYTE(STACK[0x358])) {
    AUSM::RoomCongruence::ProcessingResult::~ProcessingResult((AUSM::RoomCongruence::ProcessingResult *)&STACK[0x2A0]);
  }
  _Unwind_Resume(a1);
}

void AUSpatialMixerV2::UpdateStereoBusRotationParameters(AUSpatialMixerV2 *this)
{
  _X0 = 0;
  _X1 = 0;
  __asm { CASPAL          X0, X1, X0, X1, [X8] }
  float32x4_t v9 = (float32x4_t)vdupq_lane_s32(_X0, 1);
  v9.i32[1] = _X0.i32[0];
  v9.i32[2] = vnegq_f32((float32x4_t)*(unint64_t *)&_X0).i32[2];
  float32x4_t v10 = vmulq_f32(v9, v9);
  float v11 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2), vaddq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1))).f32[0]);
  if (v11 <= 0.0001)
  {
    v14.i64[0] = 0;
    v14.i32[2] = 0;
    float v15 = 1.0;
  }
  else
  {
    float32x4_t v12 = vmulq_f32(v9, (float32x4_t)xmmword_1BB879DF0);
    float v13 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))).f32[0];
    if ((float)((float)(v13 / v11) + 1.0) >= 0.0001)
    {
      int32x4_t v16 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v9, (int32x4_t)v9), (int8x16_t)v9, 0xCuLL), (float32x4_t)xmmword_1BB879E10), (float32x4_t)xmmword_1BB873F80, v9);
      float32x4_t v14 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v16, v16), (int8x16_t)v16, 0xCuLL);
      float v15 = v13 + v11;
    }
    else
    {
      float32x4_t v14 = (float32x4_t)xmmword_1BB879E00;
      float v15 = 0.0;
    }
  }
  v14.f32[3] = v15;
  int8x16_t v17 = (int8x16_t)vmulq_f32(v14, v14);
  float32x2_t v18 = vadd_f32(*(float32x2_t *)v17.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v17, v17, 8uLL));
  float32x4_t v19 = (float32x4_t)xmmword_1BB875840;
  float32x4_t v20 = (float32x4_t)xmmword_1BB875840;
  if (vaddv_f32(v18) != 0.0)
  {
    unsigned __int32 v21 = vadd_f32(v18, (float32x2_t)vdup_lane_s32((int32x2_t)v18, 1)).u32[0];
    float32x2_t v22 = vrsqrte_f32((float32x2_t)v21);
    float32x2_t v23 = vmul_f32(v22, vrsqrts_f32((float32x2_t)v21, vmul_f32(v22, v22)));
    float32x4_t v20 = vmulq_n_f32(v14, vmul_f32(v23, vrsqrts_f32((float32x2_t)v21, vmul_f32(v23, v23))).f32[0]);
  }
  _X0 = 0;
  _X3 = 0;
  __asm
  {
    CASPAL          X2, X3, X0, X1, [X9]
    CASPAL          X0, X1, X0, X1, [X9]
  }
  int32x4_t v28 = (int32x4_t)vnegq_f32((float32x4_t)_X0);
  int8x16_t v29 = (int8x16_t)vtrn2q_s32((int32x4_t)_X0, vtrn1q_s32((int32x4_t)_X0, v28));
  float32x4_t v30 = vmlaq_n_f32(vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)_X0, (int8x16_t)v28, 8uLL), _X2, 1), (float32x4_t)vextq_s8(v29, v29, 8uLL), _X2.f32[0]);
  float32x4_t v31 = (float32x4_t)vrev64q_s32((int32x4_t)_X0);
  v31.i32[0] = v28.i32[1];
  v31.i32[3] = v28.i32[2];
  float32x4_t v32 = vaddq_f32(vmlaq_laneq_f32(vmulq_laneq_f32((float32x4_t)_X0, (float32x4_t)(unint64_t)_X2, 3), v31, (float32x4_t)(unint64_t)_X2, 2), v30);
  int8x16_t v33 = (int8x16_t)vmulq_f32(v32, v32);
  float32x2_t v34 = vadd_f32(*(float32x2_t *)v33.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v33, v33, 8uLL));
  if (vaddv_f32(v34) != 0.0)
  {
    unsigned __int32 v35 = vadd_f32(v34, (float32x2_t)vdup_lane_s32((int32x2_t)v34, 1)).u32[0];
    float32x2_t v36 = vrsqrte_f32((float32x2_t)v35);
    float32x2_t v37 = vmul_f32(v36, vrsqrts_f32((float32x2_t)v35, vmul_f32(v36, v36)));
    float32x4_t v19 = vmulq_n_f32(v32, vmul_f32(v37, vrsqrts_f32((float32x2_t)v35, vmul_f32(v37, v37))).f32[0]);
  }
  float32x4_t v38 = vmulq_f32(v19, (float32x4_t)xmmword_1BB879E20);
  int8x16_t v39 = (int8x16_t)vmulq_f32(v19, v19);
  *(float32x2_t *)v39.i8 = vadd_f32(*(float32x2_t *)v39.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v39, v39, 8uLL));
  v39.i32[0] = vadd_f32(*(float32x2_t *)v39.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v39.i8, 1)).u32[0];
  float32x2_t v40 = vrecpe_f32((float32x2_t)v39.u32[0]);
  float32x2_t v41 = vmul_f32(v40, vrecps_f32((float32x2_t)v39.u32[0], v40));
  float32x4_t v42 = vmulq_n_f32(v38, vmul_f32(v41, vrecps_f32((float32x2_t)v39.u32[0], v41)).f32[0]);
  int32x4_t v43 = (int32x4_t)vnegq_f32(v20);
  int8x16_t v44 = (int8x16_t)vtrn2q_s32((int32x4_t)v20, vtrn1q_s32((int32x4_t)v20, v43));
  float32x4_t v45 = vmlaq_n_f32(vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)v20, (int8x16_t)v43, 8uLL), *(float32x2_t *)v42.f32, 1), (float32x4_t)vextq_s8(v44, v44, 8uLL), v42.f32[0]);
  float32x4_t v46 = (float32x4_t)vrev64q_s32((int32x4_t)v20);
  v46.i32[0] = v43.i32[1];
  v46.i32[3] = v43.i32[2];
  float32x4_t v47 = vaddq_f32(v45, vmlaq_laneq_f32(vmulq_laneq_f32(v20, v42, 3), v46, v42, 2));
  int8x16_t v48 = (int8x16_t)vmulq_f32(v47, v47);
  float32x2_t v49 = vadd_f32(*(float32x2_t *)v48.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v48, v48, 8uLL));
  float v50 = vaddv_f32(v49);
  float v51 = 0.0;
  if (sqrtf(v50) >= 0.0001)
  {
    if (v50 == 0.0)
    {
      _Q1 = (float32x4_t)xmmword_1BB875840;
    }
    else
    {
      unsigned __int32 v53 = vadd_f32(v49, (float32x2_t)vdup_lane_s32((int32x2_t)v49, 1)).u32[0];
      float32x2_t v54 = vrsqrte_f32((float32x2_t)v53);
      float32x2_t v55 = vmul_f32(v54, vrsqrts_f32((float32x2_t)v53, vmul_f32(v54, v54)));
      _Q1 = vmulq_n_f32(v47, vmul_f32(v55, vrsqrts_f32((float32x2_t)v53, vmul_f32(v55, v55))).f32[0]);
    }
    _S2 = _Q1.i32[2];
    _S3 = _Q1.i32[1];
    __asm
    {
      FMLA            S0, S2, V1.S[3]
      FMLA            S2, S3, V1.S[1]
    }
    float v51 = atan2f(_S0 + _S0, (float)(_S2 * -2.0) + 1.0) * 57.296;
  }
  uint64_t v60 = *((void *)this + 372);
  if (v60)
  {
    *(float *)(v60 + 8) = v51;
  }
  else
  {
    *((float *)this + 741) = v51;
    float v61 = *((float *)this + 742);
    float v62 = sinf(v51 * 0.017453);
    float v63 = asinf(v62);
    *(__float2 *)((char *)this + 2956) = __sincosf_stret((float)((float)(v61 * -0.5) * v63) + 0.7854);
  }
}

float AUSM::auCoordQuaternionToEuler(AUSM *this, float32x4_t a2)
{
  int8x16_t v2 = (int8x16_t)vmulq_f32(a2, a2);
  float32x2_t v3 = vadd_f32(*(float32x2_t *)v2.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v2, v2, 8uLL));
  float v4 = vaddv_f32(v3);
  if (sqrtf(v4) < 0.0001) {
    return 0.0;
  }
  if (v4 == 0.0)
  {
    float32x4_t v6 = (float32x4_t)xmmword_1BB875840;
  }
  else
  {
    unsigned __int32 v7 = vadd_f32(v3, (float32x2_t)vdup_lane_s32((int32x2_t)v3, 1)).u32[0];
    float32x2_t v8 = vrsqrte_f32((float32x2_t)v7);
    float32x2_t v9 = vmul_f32(v8, vrsqrts_f32((float32x2_t)v7, vmul_f32(v8, v8)));
    float32x4_t v6 = vmulq_n_f32(a2, vmul_f32(v9, vrsqrts_f32((float32x2_t)v7, vmul_f32(v9, v9))).f32[0]);
  }
  _S9 = v6.i32[2];
  _S10 = v6.i32[1];
  _Q2 = v6;
  __int32 v41 = v6.i32[3];
  __asm
  {
    FMLA            S0, S9, V2.S[3]
    FMLA            S1, S10, V2.S[1]
  }
  float v5 = atan2f(_S0 + _S0, (float)(_S1 * -2.0) + 1.0) * 57.296;
  _V1.S[3] = v41;
  __asm { FMLA            S0, S10, V1.S[3] }
  *(float *)v21.i32 = _S0 + _S0;
  int8x16_t v39 = v21;
  if (fabsf(*(float *)v21.i32) >= nexttowardf(1.0, 0.0))
  {
    v22.i32[0] = 1119092736;
    v23.i64[0] = 0x8000000080000000;
    v23.i64[1] = 0x8000000080000000;
    v22.i32[0] = vbslq_s8(v23, v22, v39).u32[0];
  }
  else
  {
    *(float *)v22.i32 = asinf(*(float *)v39.i32) * 57.296;
  }
  float v40 = *(float *)v22.i32;
  __float2 v24 = __sincosf_stret((float)(v5 * 0.017453) * 0.5);
  __float2 v25 = __sincosf_stret((float)(v40 * 0.017453) * 0.5);
  v26.f32[0] = -(float)((float)(v24.__sinval * v25.__sinval) - (float)((float)(v24.__cosval * v25.__cosval) * 0.0));
  v26.f32[1] = (float)(v24.__sinval * (float)(v25.__cosval * 0.0)) + (float)(v25.__sinval * v24.__cosval);
  v26.f32[2] = (float)(v24.__cosval * (float)(v25.__sinval * -0.0)) + (float)(v25.__cosval * v24.__sinval);
  v26.f32[3] = (float)(v24.__cosval * v25.__cosval) + (float)((float)(v24.__sinval * v25.__sinval) * 0.0);
  int8x16_t v27 = (int8x16_t)vmulq_f32(v26, v26);
  *(float32x2_t *)v27.i8 = vadd_f32(*(float32x2_t *)v27.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v27, v27, 8uLL));
  v27.i32[0] = vadd_f32(*(float32x2_t *)v27.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v27.i8, 1)).u32[0];
  float32x2_t v28 = vrecpe_f32((float32x2_t)v27.u32[0]);
  float32x2_t v29 = vmul_f32(v28, vrecps_f32((float32x2_t)v27.u32[0], v28));
  float32x4_t v30 = vmulq_n_f32(vmulq_f32(v26, (float32x4_t)xmmword_1BB879E20), vmul_f32(v29, vrecps_f32((float32x2_t)v27.u32[0], v29)).f32[0]);
  int32x4_t v31 = (int32x4_t)vnegq_f32(a2);
  int8x16_t v32 = (int8x16_t)vtrn2q_s32((int32x4_t)a2, vtrn1q_s32((int32x4_t)a2, v31));
  float32x4_t v33 = vmlaq_n_f32(vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)a2, (int8x16_t)v31, 8uLL), *(float32x2_t *)v30.f32, 1), (float32x4_t)vextq_s8(v32, v32, 8uLL), v30.f32[0]);
  float32x4_t v34 = (float32x4_t)vrev64q_s32((int32x4_t)a2);
  v34.i32[0] = v31.i32[1];
  v34.i32[3] = v31.i32[2];
  float32x4_t v35 = vaddq_f32(v33, vmlaq_laneq_f32(vmulq_laneq_f32(a2, v30, 3), v34, v30, 2));
  float v36 = atan2f(v35.f32[0], v35.f32[3]);
  remainderf((float)(v36 + v36) * 57.296, 360.0);
  return v5;
}

void AUSM::AppleSauceCFWithMutex<__CFDictionary const*>::load(void *a1, uint64_t a2)
{
  float v4 = (std::mutex *)(a2 + 8);
  std::mutex::lock((std::mutex *)(a2 + 8));
  float v5 = *(const void **)a2;
  if (v5) {
    CFRetain(v5);
  }
  *a1 = v5;

  std::mutex::unlock(v4);
}

void AUSM::AppleSauceCFWithMutex<__CFDictionary const*>::store(uint64_t a1, const void **a2)
{
  float v4 = (std::mutex *)(a1 + 8);
  std::mutex::lock((std::mutex *)(a1 + 8));
  float v5 = *(const void **)a1;
  float32x4_t v6 = *a2;
  *(void *)a1 = *a2;
  if (v6) {
    CFRetain(v6);
  }
  if (v5) {
    CFRelease(v5);
  }

  std::mutex::unlock(v4);
}

uint64_t AUSpatialMixerV2::UpdateReverbIfNecessary(uint64_t this, int a2, int a3, int a4)
{
  uint64_t v105 = *MEMORY[0x1E4F143B8];
  unsigned __int8 v4 = atomic_load((unsigned __int8 *)(this + 8977));
  if ((v4 & 1) == 0) {
    return this;
  }
  uint64_t v5 = this;
  uint64_t v88 = (unsigned __int8 *)(this + 8893);
  uint64_t v91 = this + 3120;
  char v92 = 1;
  std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)(this + 3120));
  unsigned int v6 = 0;
  int v7 = 0;
  int v90 = 0;
  int v8 = 0;
  int v9 = 0;
  while (1)
  {
    uint64_t v10 = *(void *)(v5 + 120);
    float v11 = (IR::IRDataLoader *)(v10
                             ? (*(uint64_t (**)(uint64_t))(*(void *)v10 + 24))(v10)
                             : (*(void *)(v5 + 104) - *(void *)(v5 + 96)) >> 3);
    if (v6 >= v11) {
      break;
    }
    uint64_t Element = (unsigned int *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v5 + 80), v6);
    BOOL MustProcessInternalReverb = AUSpatialMixerV2InputElement::MustProcessInternalReverb((AUSpatialMixerV2InputElement *)Element);
    BOOL MustProcessPostProcReverb = AUSpatialMixerV2InputElement::MustProcessPostProcReverb((AUSpatialMixerV2InputElement *)Element);
    unsigned int v15 = atomic_load(Element + 186);
    if (v15 - 7 <= 2
      && AUSpatialMixerV2InputElement::MustProcessInternalReverb((AUSpatialMixerV2InputElement *)Element))
    {
      int v7 = 1;
    }
    else
    {
      unsigned int v16 = atomic_load(Element + 186);
      BOOL v17 = v16 == 6 && AUSpatialMixerV2InputElement::MustProcessInternalReverb((AUSpatialMixerV2InputElement *)Element);
      v90 |= v17;
    }
    v9 |= MustProcessInternalReverb;
    v8 |= MustProcessPostProcReverb;
    ++v6;
  }
  unsigned int v18 = a2;
  if (a2 == -1)
  {
    float v11 = *(IR::IRDataLoader **)(v5 + 120);
    if (v11)
    {
      float v11 = (IR::IRDataLoader *)(*(uint64_t (**)(IR::IRDataLoader *))(*(void *)v11 + 24))(v11);
      LODWORD(v19) = v11;
      unsigned int v18 = 0;
    }
    else
    {
      unsigned int v18 = 0;
      uint64_t v19 = (*(void *)(v5 + 104) - *(void *)(v5 + 96)) >> 3;
    }
  }
  else
  {
    LODWORD(v19) = a2 + 1;
  }
  unsigned __int8 v20 = atomic_load((unsigned __int8 *)(v5 + 2552));
  if (!(((v20 & 1) == 0) | v7 & 1))
  {
    if (getAUSMV2Log(void)::onceToken != -1) {
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
    }
    int8x16_t v21 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      float v80 = (void *)(v5 + 3368);
      if (*(char *)(v5 + 3391) < 0) {
        float v80 = (void *)*v80;
      }
      *(_DWORD *)unsigned __int8 v97 = 136315394;
      *(void *)&v97[4] = v80;
      *(_WORD *)&v97[12] = 2080;
      *(void *)&v97[14] = "UpdateReverbIfNecessary";
      _os_log_debug_impl(&dword_1BB0CE000, v21, OS_LOG_TYPE_DEBUG, "[%s|%s] Resetting auto mode reverb", v97, 0x16u);
    }

    int8x16_t v22 = *(ParametricFilters **)(v5 + 8992);
    if (v22) {
      ParametricFilters::reset(v22);
    }
    if (v18 != v19)
    {
      unsigned int v23 = v18;
      do
      {
        uint64_t v24 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v5 + 80), v23);
        AUSpatialMixerV2InputElement::ResetReverbProcessors(v24, 1);
        ++v23;
      }
      while (v19 != v23);
    }
    caulk::pooled_semaphore_mutex::_lock((caulk::pooled_semaphore_mutex *)(v5 + 2400));
    IR::SharedIRBuses::reset((IR::SharedIRBuses *)(v5 + 2104));
    float v11 = (IR::IRDataLoader *)caulk::pooled_semaphore_mutex::_unlock((caulk::pooled_semaphore_mutex *)(v5 + 2400));
  }
  unsigned __int8 v25 = atomic_load((unsigned __int8 *)(v5 + 2553));
  if (!(((v25 & 1) == 0) | v8 & 1))
  {
    if (getAUSMV2Log(void)::onceToken != -1) {
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
    }
    float32x4_t v26 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
    {
      float v81 = (void *)(v5 + 3368);
      if (*(char *)(v5 + 3391) < 0) {
        float v81 = (void *)*v81;
      }
      *(_DWORD *)unsigned __int8 v97 = 136315394;
      *(void *)&v97[4] = v81;
      *(_WORD *)&v97[12] = 2080;
      *(void *)&v97[14] = "UpdateReverbIfNecessary";
      _os_log_debug_impl(&dword_1BB0CE000, v26, OS_LOG_TYPE_DEBUG, "[%s|%s] Resetting post-processing reverb", v97, 0x16u);
    }

    AUSpatialMixerV2::ResetReverbFilters(v5);
    for (; v19 != v18; ++v18)
    {
      uint64_t v27 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v5 + 80), v18);
      AUSpatialMixerV2InputElement::ResetReverbProcessors(v27, 0);
    }
    caulk::pooled_semaphore_mutex::_lock((caulk::pooled_semaphore_mutex *)(v5 + 2400));
    IR::SharedIRBuses::reset((IR::SharedIRBuses *)(v5 + 2104));
    float v11 = (IR::IRDataLoader *)caulk::pooled_semaphore_mutex::_unlock((caulk::pooled_semaphore_mutex *)(v5 + 2400));
  }
  if (((v7 | v8) & 1) == 0)
  {
    if (a4) {
      float v11 = (IR::IRDataLoader *)AUSpatialMixerV2::ReconfigureSharedBuffers((AUSpatialMixerV2 *)v5, 0, 0);
    }
    float32x4_t v30 = *(IR::FixedIntegerDelay **)(v5 + 2376);
    int32x4_t v31 = *(IR::FixedIntegerDelay **)(v5 + 2384);
    while (v30 != v31)
    {
      IR::FixedIntegerDelay::reset(v30);
      float32x4_t v30 = (IR::FixedIntegerDelay *)((char *)v30 + 56);
    }
    int v32 = 0;
    int v33 = 0;
    goto LABEL_71;
  }
  uint64_t v28 = *(void *)(v5 + 120);
  if (v28) {
    LODWORD(v29) = (*(uint64_t (**)(uint64_t))(*(void *)v28 + 24))(v28);
  }
  else {
    uint64_t v29 = (*(void *)(v5 + 104) - *(void *)(v5 + 96)) >> 3;
  }
  if ((v7 & v8 & 1) == 0)
  {
    float32x4_t v34 = (unsigned int *)(v5 + 9000);
    if (v7)
    {
      atomic_store(v29, v34);
      atomic_store(0, (unsigned int *)(v5 + 9004));
      float32x4_t v35 = (unsigned int *)(v5 + 9008);
    }
    else
    {
      if (v8)
      {
        atomic_store(v29, v34);
        atomic_store(0xFFFFFFFF, (unsigned int *)(v5 + 9004));
        atomic_store(0, (unsigned int *)(v5 + 9008));
LABEL_55:
        atomic_store(0xFFFFFFFF, (unsigned int *)(v5 + 9012));
        goto LABEL_56;
      }
      atomic_store(0, v34);
      atomic_store(0xFFFFFFFF, (unsigned int *)(v5 + 9004));
      float32x4_t v35 = (unsigned int *)(v5 + 9008);
    }
    atomic_store(0xFFFFFFFF, v35);
    goto LABEL_55;
  }
  atomic_store(3 * v29, (unsigned int *)(v5 + 9000));
  atomic_store(0, (unsigned int *)(v5 + 9004));
  atomic_store(v29, (unsigned int *)(v5 + 9008));
  atomic_store(2 * v29, (unsigned int *)(v5 + 9012));
LABEL_56:
  int v36 = atomic_load((unsigned int *)(v5 + 9000));
  unsigned __int8 v37 = atomic_load((unsigned __int8 *)(v5 + 2348));
  if (v37)
  {
    IR::SharedIRBuses::setNumInputChannels(v5 + 2104, v36);
  }
  else
  {
    if (getAUSMV2Log(void)::onceToken != -1) {
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
    }
    float32x4_t v38 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
    {
      unsigned __int8 v84 = (void *)(v5 + 3368);
      if (*(char *)(v5 + 3391) < 0) {
        unsigned __int8 v84 = (void *)*v84;
      }
      *(_DWORD *)unsigned __int8 v97 = 136315394;
      *(void *)&v97[4] = v84;
      *(_WORD *)&v97[12] = 2080;
      *(void *)&v97[14] = "UpdateReverbIfNecessary";
      _os_log_debug_impl(&dword_1BB0CE000, v38, OS_LOG_TYPE_DEBUG, "[%s|%s] Initializing auto mode reverb", v97, 0x16u);
    }

    caulk::pooled_semaphore_mutex::_lock((caulk::pooled_semaphore_mutex *)(v5 + 2400));
    double v39 = *(double *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v5 + 128), 0) + 80);
    unint64_t v40 = *(unsigned int *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v5 + 128), 0) + 108);
    int v41 = *(_DWORD *)(v5 + 336);
    CFTypeRef v95 = (IR::IRData *)(v5 + 2252);
    LOBYTE(v96) = 1;
    caulk::pooled_semaphore_mutex::_lock((caulk::pooled_semaphore_mutex *)(v5 + 2252));
    float v42 = v39;
    atomic_store(0, (unsigned __int8 *)(v5 + 2248));
    atomic_store(0, (unsigned __int8 *)(v5 + 2249));
    atomic_store(0, (unsigned __int8 *)(v5 + 2250));
    *(float *)(v5 + 2356) = v42;
    *(_DWORD *)(v5 + 2344) = v36;
    *(_DWORD *)(v5 + 2360) = v41;
    *(_DWORD *)(v5 + 2372) = 1 << -(char)__clz(vcvtas_u32_f32(v42 * 0.0053333) - 1);
    if (v41)
    {
      *(_DWORD *)(v5 + 2352) = v40;
      uint64_t v43 = *(void *)(v5 + 2280);
      uint64_t v44 = *(void *)(v5 + 2272);
      std::vector<std::vector<float>>::resize((uint64_t *)(v5 + 2272), v40);
      std::vector<std::vector<float>>::resize((uint64_t *)(v5 + 2296), v40);
      unsigned int v45 = -1431655765 * ((v43 - v44) >> 3);
      if (v40 > v45)
      {
        uint64_t v46 = 24 * (int)v45;
        do
        {
          std::vector<float>::vector(v97, *(unsigned int *)(v5 + 2360));
          uint64_t v47 = *(void *)(v5 + 2272) + v46;
          int8x16_t v48 = *(void **)v47;
          if (*(void *)v47)
          {
            *(void *)(v47 + 8) = v48;
            operator delete(v48);
            *(void *)uint64_t v47 = 0;
            *(void *)(v47 + 8) = 0;
            *(void *)(v47 + 16) = 0;
          }
          *(_OWORD *)uint64_t v47 = *(_OWORD *)v97;
          *(void *)(v47 + 16) = *(void *)&v97[16];
          std::vector<float>::vector(v97, *(unsigned int *)(v5 + 2360));
          uint64_t v49 = *(void *)(v5 + 2296) + v46;
          float v50 = *(void **)v49;
          if (*(void *)v49)
          {
            *(void *)(v49 + 8) = v50;
            operator delete(v50);
            *(void *)uint64_t v49 = 0;
            *(void *)(v49 + 8) = 0;
            *(void *)(v49 + 16) = 0;
          }
          *(_OWORD *)uint64_t v49 = *(_OWORD *)v97;
          *(void *)(v49 + 16) = *(void *)&v97[16];
          ++v45;
          v46 += 24;
        }
        while (v40 > v45);
      }
    }
    unint64_t v51 = *(unsigned int *)(v5 + 2344);
    *(void *)unsigned __int8 v97 = 0;
    *(void *)&v97[8] = 0;
    std::vector<std::shared_ptr<IR::SharedIRBuses::IRBus>>::resize((char **)(v5 + 2104), v51, v97);
    unint64_t v52 = *(unsigned int *)(v5 + 2344);
    *(void *)unsigned __int8 v97 = 0;
    *(void *)&v97[8] = 0;
    std::vector<std::shared_ptr<IR::SharedIRBuses::IRBus>>::resize((char **)(v5 + 2152), v52, v97);
    unint64_t v53 = *(unsigned int *)(v5 + 2344);
    *(void *)unsigned __int8 v97 = 0;
    *(void *)&v97[8] = 0;
    std::vector<std::shared_ptr<IR::SharedIRBuses::IRBus>>::resize((char **)(v5 + 2200), v53, v97);
    unint64_t v54 = *(unsigned int *)(v5 + 2344);
    *(_DWORD *)unsigned __int8 v97 = 0;
    std::vector<float>::resize(v5 + 2128, v54, v97);
    unint64_t v55 = *(unsigned int *)(v5 + 2344);
    *(_DWORD *)unsigned __int8 v97 = 0;
    std::vector<float>::resize(v5 + 2176, v55, v97);
    unint64_t v56 = *(unsigned int *)(v5 + 2344);
    *(_DWORD *)unsigned __int8 v97 = 0;
    std::vector<float>::resize(v5 + 2224, v56, v97);
    *(void *)unsigned __int8 v97 = 0;
    *(void *)&v97[8] = 0;
    std::vector<std::shared_ptr<IR::SharedIRBuses::IRBus>>::resize((char **)(v5 + 2320), 4uLL, v97);
    *(unsigned char *)(v5 + 2349) = 1;
    atomic_store(1u, (unsigned __int8 *)(v5 + 2348));
    std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v95);
    caulk::pooled_semaphore_mutex::_unlock((caulk::pooled_semaphore_mutex *)(v5 + 2400));
  }
  AUSpatialMixerV2::UpdateAutoModeReverb((AUSpatialMixerV2 *)v5, v7 & 1, v8 & 1, a2);
  int v32 = v7;
  int v33 = v8;
LABEL_71:
  atomic_store(v7 & 1, (unsigned __int8 *)(v5 + 2552));
  atomic_store(v8 & 1, (unsigned __int8 *)(v5 + 2553));
  if (a3)
  {
    int v57 = atomic_load((unsigned __int8 *)(v5 + 2552));
    int v58 = atomic_load((unsigned __int8 *)(v5 + 2553));
    if (v57 & v58)
    {
      unsigned int ReverbModelingDelay = AUSM::IRManager::getReverbModelingDelay(v5 + 6176, 0);
      float v11 = (IR::IRDataLoader *)AUSM::IRManager::getReverbModelingDelay(v5 + 6176, 1);
      if (v11 < ReverbModelingDelay) {
        unsigned int ReverbModelingDelay = v11;
      }
    }
    else if ((v58 | v57))
    {
      float v11 = (IR::IRDataLoader *)AUSM::IRManager::getReverbModelingDelay(v5 + 6176, (v58 & 1) == 0);
      unsigned int ReverbModelingDelay = v11;
    }
    else
    {
      unsigned int ReverbModelingDelay = 0;
    }
    uint64_t v60 = (IR::IRDataLoader *)IR::IRDataLoader::instance(v11);
    std::mutex::lock((std::mutex *)(v5 + 7736));
    IR::IRDataAttributes::IRDataAttributes((uint64_t)v97, v5 + 6240);
    std::mutex::unlock((std::mutex *)(v5 + 7736));
    IR::IRDataLoader::getLoadedIR((uint64_t *)&v95, v60, (const IR::IRDataAttributes *)v97);
    if (cf) {
      CFRelease(cf);
    }
    if (v103) {
      CFRelease(v103);
    }
    if (v102) {
      CFRelease(v102);
    }
    if (*(void *)v97) {
      CFRelease(*(CFTypeRef *)v97);
    }
    if (v95)
    {
      if ((v57 | v58)) {
        int v61 = ReverbModelingDelay - IR::IRData::getModelingDelay(v95);
      }
      else {
        int v61 = 0;
      }
      unsigned int v64 = atomic_load((unsigned int *)(*(void *)(v5 + 6176) + 88));
      if (v64 == 1) {
        unsigned int v65 = atomic_load((unsigned int *)(v5 + 6212));
      }
      else {
        unsigned int v65 = 0;
      }
      if (*(_DWORD *)(v5 + 12152) != v61 || *(_DWORD *)(v5 + 12156) != v65)
      {
        AUSpatialMixerV2::AlignmentDelay::reset((AUSpatialMixerV2::AlignmentDelay *)(v5 + 12104));
        if (getAUSMV2Log(void)::onceToken != -1) {
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
        }
        unsigned int v66 = v65 + (v61 & ~(v61 >> 31));
        unsigned int v67 = -v61 & (v61 >> 31);
        uint64_t v68 = (id)getAUSMV2Log(void)::gLog;
        if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
        {
          DSPSplitComplex v69 = (void *)(v5 + 3368);
          if (*(char *)(v5 + 3391) < 0) {
            DSPSplitComplex v69 = (void *)*v69;
          }
          *(_DWORD *)unsigned __int8 v97 = 136315906;
          *(void *)&v97[4] = v69;
          *(_WORD *)&v97[12] = 2080;
          *(void *)&v97[14] = "UpdateAlignmentDelayLines";
          *(_WORD *)&v97[22] = 1024;
          unsigned int v98 = v65 + (v61 & ~(v61 >> 31));
          __int16 v99 = 1024;
          *(_DWORD *)std::string __p = -v61 & (v61 >> 31);
          _os_log_impl(&dword_1BB0CE000, v68, OS_LOG_TYPE_DEFAULT, "[%s|%s] Alignment delay: Direct path = %u samples, Reverb path = %u samples", v97, 0x22u);
        }

        uint64_t v93 = v5 + 12164;
        char v94 = 1;
        caulk::pooled_semaphore_mutex::_lock((caulk::pooled_semaphore_mutex *)(v5 + 12164));
        *(_DWORD *)(v5 + 12152) = v61;
        *(_DWORD *)(v5 + 12156) = v65;
        if (v66)
        {
          unint64_t v70 = *(unsigned int *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v5 + 128), 0) + 108);
          IR::FixedIntegerDelay::FixedIntegerDelay((IR::FixedIntegerDelay *)v97, v66, 1);
          std::vector<IR::FixedIntegerDelay>::resize((uint64_t *)(v5 + 12104), v70, (IR::FixedIntegerDelay *)v97);
          if (*(void *)&__p[2])
          {
            uint64_t v101 = *(void *)&__p[2];
            operator delete(*(void **)&__p[2]);
          }
          if (*(void *)&v97[8])
          {
            *(void *)&v97[16] = *(void *)&v97[8];
            operator delete(*(void **)&v97[8]);
          }
          atomic_store(1u, v88 + 3267);
        }
        if (v67)
        {
          unint64_t v71 = *(unsigned int *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v5 + 128), 0) + 108);
          IR::FixedIntegerDelay::FixedIntegerDelay((IR::FixedIntegerDelay *)v97, v67, 1);
          std::vector<IR::FixedIntegerDelay>::resize((uint64_t *)(v5 + 12128), v71, (IR::FixedIntegerDelay *)v97);
          if (*(void *)&__p[2])
          {
            uint64_t v101 = *(void *)&__p[2];
            operator delete(*(void **)&__p[2]);
          }
          if (*(void *)&v97[8])
          {
            *(void *)&v97[16] = *(void *)&v97[8];
            operator delete(*(void **)&v97[8]);
          }
          atomic_store(1u, v88 + 3268);
        }
        std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v93);
      }
    }
    else
    {
      if (getAUSMV2Log(void)::onceToken != -1) {
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
      }
      float v62 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
      {
        float v63 = (void *)(v5 + 3368);
        if (*(char *)(v5 + 3391) < 0) {
          float v63 = (void *)*v63;
        }
        *(_DWORD *)unsigned __int8 v97 = 136315394;
        *(void *)&v97[4] = v63;
        *(_WORD *)&v97[12] = 2080;
        *(void *)&v97[14] = "UpdateAlignmentDelayLines";
        _os_log_impl(&dword_1BB0CE000, v62, OS_LOG_TYPE_DEFAULT, "[%s|%s] Could not find active HRTF in cache. Alignment delay remains unchanged.", v97, 0x16u);
      }
    }
    if (v96) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v96);
    }
  }
  unsigned __int8 v72 = atomic_load((unsigned __int8 *)(v5 + 680));
  if (!(((v72 & 1) == 0) | v9 & 1))
  {
    if (getAUSMV2Log(void)::onceToken != -1) {
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
    }
    unint64_t v73 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG))
    {
      float v82 = (void *)(v5 + 3368);
      if (*(char *)(v5 + 3391) < 0) {
        float v82 = (void *)*v82;
      }
      *(_DWORD *)unsigned __int8 v97 = 136315394;
      *(void *)&v97[4] = v82;
      *(_WORD *)&v97[12] = 2080;
      *(void *)&v97[14] = "UpdateReverbIfNecessary";
      _os_log_debug_impl(&dword_1BB0CE000, v73, OS_LOG_TYPE_DEBUG, "[%s|%s] Resetting FDN", v97, 0x16u);
    }

    caulk::pooled_semaphore_mutex::_lock((caulk::pooled_semaphore_mutex *)(v5 + 1968));
    FeedbackDelayNetwork<float>::Reset((_OWORD *)(v5 + 688));
    caulk::pooled_semaphore_mutex::_unlock((caulk::pooled_semaphore_mutex *)(v5 + 1968));
  }
  atomic_store(v9 & 1, (unsigned __int8 *)(v5 + 680));
  unsigned __int8 v74 = atomic_load((unsigned __int8 *)(v5 + 2096));
  if (((v74 & 1) == 0) | v90 & 1)
  {
    unsigned __int8 v75 = atomic_load((unsigned __int8 *)(v5 + 2096));
    if ((((v75 & 1) == 0) & v90) == 1)
    {
      if (getAUSMV2Log(void)::onceToken != -1) {
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
      }
      unsigned __int8 v76 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v76, OS_LOG_TYPE_DEBUG))
      {
        float v85 = (void *)(v5 + 3368);
        if (*(char *)(v5 + 3391) < 0) {
          float v85 = (void *)*v85;
        }
        *(_DWORD *)unsigned __int8 v97 = 136315394;
        *(void *)&v97[4] = v85;
        *(_WORD *)&v97[12] = 2080;
        *(void *)&v97[14] = "UpdateReverbIfNecessary";
        _os_log_debug_impl(&dword_1BB0CE000, v76, OS_LOG_TYPE_DEBUG, "[%s|%s] Updating HRTFHQ reverb", v97, 0x16u);
      }

      *(void *)unsigned __int8 v97 = v5 + 2032;
      *(void *)&v97[8] = v5 + 3088;
      std::lock[abi:ne180100]<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>(v5 + 2032, v5 + 3088);
      atomic_load((unsigned int *)(v5 + 3432));
      operator new();
    }
  }
  else
  {
    if (getAUSMV2Log(void)::onceToken != -1) {
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
    }
    long long v77 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG))
    {
      float v83 = (void *)(v5 + 3368);
      if (*(char *)(v5 + 3391) < 0) {
        float v83 = (void *)*v83;
      }
      *(_DWORD *)unsigned __int8 v97 = 136315394;
      *(void *)&v97[4] = v83;
      *(_WORD *)&v97[12] = 2080;
      *(void *)&v97[14] = "UpdateReverbIfNecessary";
      _os_log_debug_impl(&dword_1BB0CE000, v77, OS_LOG_TYPE_DEBUG, "[%s|%s] Resetting HRTFHQ reverb", v97, 0x16u);
    }

    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock(v5 + 2032);
    IR::IRProcessor::reset(*(IR::FFTFilter ***)(v5 + 2024));
    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(v5 + 2032);
  }
  int v78 = v90;
  atomic_store(v90 & 1, (unsigned __int8 *)(v5 + 2096));
  if (((v32 | v78 | v9 | v33) & 1) == 0)
  {
    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock(v5 + 3088);
    uint64_t v79 = *(void *)(v5 + 2672);
    if (v79) {
      (*(void (**)(uint64_t))(*(void *)v79 + 24))(v79);
    }
    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(v5 + 3088);
  }
  atomic_store(1u, v88);
  return std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&v91);
}

void sub_1BB3BCE50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, caulk::pooled_semaphore_mutex *a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, char a17, uint64_t a18, char a19, std::__shared_weak_count *a20,char a21)
{
  if (a20) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a20);
  }
  std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&a15);
  _Unwind_Resume(a1);
}

void AUSM::RoomCongruence::ProcessingResult::~ProcessingResult(AUSM::RoomCongruence::ProcessingResult *this)
{
  int8x16_t v2 = (const void *)*((void *)this + 21);
  if (v2) {
    CFRelease(v2);
  }
  float32x2_t v3 = (const void *)*((void *)this + 20);
  if (v3) {
    CFRelease(v3);
  }
  if (*((unsigned char *)this + 152)) {
    IR::IRDataAttributes::~IRDataAttributes(this);
  }
}

BOOL AUSpatialMixerV2::CanUsePersonalizedHRTF(AUSpatialMixerV2 *this)
{
  unsigned int v1 = atomic_load((unsigned int *)this + 862);
  if (v1 == 1)
  {
    float v13 = (char *)this + 3120;
    char v14 = 1;
    std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)((char *)this + 3120));
    uint64_t v3 = *((void *)this + 15);
    if (v3)
    {
      LODWORD(v4) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 24))(v3);
      if (v4) {
        goto LABEL_4;
      }
    }
    else
    {
      uint64_t v4 = (*((void *)this + 13) - *((void *)this + 12)) >> 3;
      if (v4)
      {
LABEL_4:
        unsigned int v5 = 0;
        unsigned int v6 = (AUSpatialMixerV2 *)((char *)this + 80);
        BOOL v7 = 1;
        do
        {
          uint64_t Element = ausdk::AUScope::SafeGetElement(v6, v5);
          unsigned int v9 = atomic_load((unsigned int *)(Element + 744));
          if (v9 == 7)
          {
            unsigned int v10 = atomic_load((unsigned int *)(*(void *)(Element + 1304) + 80));
            if (v10 != 1 && (v10 || *(_DWORD *)(*(void *)(Element + 1296) + 108) <= 1u))
            {
              unsigned int v11 = atomic_load((unsigned int *)(*(void *)(Element + 1304) + 72));
              if (v11 != 5) {
                break;
              }
            }
          }
          BOOL v7 = ++v5 < v4;
        }
        while (v4 != v5);
        goto LABEL_15;
      }
    }
    BOOL v7 = 0;
LABEL_15:
    std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&v13);
    return v7;
  }
  return 0;
}

void sub_1BB3BD16C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *std::__function::__value_func<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>::~__value_func[abi:ne180100](void *a1)
{
  int8x16_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void ___ZN16AUSpatialMixerV215PropertyChangedEj_block_invoke(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 32);
  if (getAUSMV2Log(void)::onceToken != -1) {
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
  }
  int8x16_t v2 = (id)getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    unsigned int v10 = (void *)(v1 + 3368);
    if (*(char *)(v1 + 3391) < 0) {
      unsigned int v10 = (void *)*v10;
    }
    *(_DWORD *)AudioTimeStamp buf = 136315394;
    char v14 = v10;
    __int16 v15 = 2080;
    unsigned int v16 = "PropertyChanged_block_invoke";
    _os_log_debug_impl(&dword_1BB0CE000, v2, OS_LOG_TYPE_DEBUG, "[%s|%s] dispatched update for dynamic XTC filter generation #:", buf, 0x16u);
  }

  unsigned __int8 v3 = atomic_load((unsigned __int8 *)(v1 + 2632));
  if (v3)
  {
    if (getAUSMV2Log(void)::onceToken != -1) {
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
    }
    unsigned int v9 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      unsigned int v11 = (void *)(v1 + 3368);
      if (*(char *)(v1 + 3391) < 0) {
        unsigned int v11 = (void *)*v11;
      }
      *(_DWORD *)AudioTimeStamp buf = 136315394;
      char v14 = v11;
      __int16 v15 = 2080;
      unsigned int v16 = "PropertyChanged_block_invoke";
      _os_log_debug_impl(&dword_1BB0CE000, v9, OS_LOG_TYPE_DEBUG, "[%s|%s] update dropped", buf, 0x16u);
    }
  }
  else if (*(void *)(v1 + 8936))
  {
    uint64_t v4 = *(const void **)(v1 + 3024);
    unsigned int v5 = *(const void **)(v1 + 3016);
    *(void *)(v1 + 3024) = v5;
    if (v5) {
      CFRetain(v5);
    }
    if (v4) {
      CFRelease(v4);
    }
    uint64_t v6 = *(void *)(v1 + 8936);
    BOOL v7 = *(const void **)(v1 + 3016);
    if (v7) {
      CFRetain(*(CFTypeRef *)(v1 + 3016));
    }
    AUSpatialMixerV2DynamicXTCFilter::updateParamDictionary(v6, v7);
    if (v7) {
      CFRelease(v7);
    }
    if (getAUSMV2Log(void)::onceToken != -1) {
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
    }
    int v8 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      float32x4_t v12 = (void *)(v1 + 3368);
      if (*(char *)(v1 + 3391) < 0) {
        float32x4_t v12 = (void *)*v12;
      }
      *(_DWORD *)AudioTimeStamp buf = 136315394;
      char v14 = v12;
      __int16 v15 = 2080;
      unsigned int v16 = "PropertyChanged_block_invoke";
      _os_log_debug_impl(&dword_1BB0CE000, v8, OS_LOG_TYPE_DEBUG, "[%s|%s] updating dynamic XTC filters", buf, 0x16u);
    }

    AUSpatialMixerV2DynamicXTCFilter::updateFilters(*(AUSpatialMixerV2DynamicXTCFilter **)(v1 + 8936));
    AUSpatialMixerV2::PropagateGlobalPropertyChangeToInputElements((AUSpatialMixerV2 *)v1, 3202);
  }
}

void sub_1BB3BD4C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t AUSpatialMixerV2::UpdateReverbRoomType(AUSpatialMixerV2 *this)
{
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)this + 8977);
  if (v2)
  {
    unsigned __int8 v3 = atomic_load((unsigned __int8 *)this + 2552);
    if (v3 & 1) != 0 || (unsigned __int8 v4 = atomic_load((unsigned __int8 *)this + 2553), (v4))
    {
      unsigned __int8 v5 = atomic_load((unsigned __int8 *)this + 2552);
      char v6 = v5 & 1;
      unsigned __int8 v7 = atomic_load((unsigned __int8 *)this + 2553);
      AUSpatialMixerV2::UpdateAutoModeReverb(this, v6, v7 & 1, -1);
    }
    unsigned __int8 v8 = atomic_load((unsigned __int8 *)this + 2096);
    if (v8)
    {
      unsigned int v16 = (char *)this + 2032;
      uint64_t v17 = (char *)this + 3088;
      std::lock[abi:ne180100]<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>((uint64_t)this + 2032, (uint64_t)this + 3088);
      atomic_load((unsigned int *)this + 858);
      operator new();
    }
  }
  AUSpatialMixerV2::UpdateReverbIfNecessary((uint64_t)this, -1, *((unsigned char *)this + 17) == 0, 0);
  v15[0] = (char *)this + 1968;
  v15[1] = (char *)this + 3088;
  while (1)
  {
    unsigned int v16 = (char *)this + 1968;
    LOBYTE(v17) = 1;
    caulk::pooled_semaphore_mutex::_lock((AUSpatialMixerV2 *)((char *)this + 1968));
    if (caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::try_lock((uint64_t)this + 3088))
    {
      unsigned int v16 = 0;
      LOBYTE(v17) = 0;
      std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v16);
      goto LABEL_13;
    }
    std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v16);
    sched_yield();
    unsigned int v16 = (char *)this + 3088;
    LOBYTE(v17) = 1;
    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)this + 3088);
    if (caulk::pooled_semaphore_mutex::try_lock((AUSpatialMixerV2 *)((char *)this + 1968))) {
      break;
    }
    std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v16);
    sched_yield();
  }
  unsigned int v16 = 0;
  LOBYTE(v17) = 0;
  std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v16);
LABEL_13:
  double v9 = *(double *)(ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0) + 80);
  unsigned int v10 = atomic_load((unsigned int *)this + 858);
  atomic_store(1u, (unsigned __int8 *)this + 1952);
  unsigned int v11 = atomic_load((unsigned int *)this + 858);
  unsigned int v12 = 33 * v10;
  switch(v11)
  {
    case 0u:
      FeedbackDelayNetwork<float>::SetDelayTime((uint64_t)this + 688, v12, 0.002, 0.014, v9);
      FeedbackDelayNetwork<float>::SetDecayTime((uint64_t)this + 688, 0.3, 0.08);
      uint64_t v13 = 0x3FD3333333333333;
      goto LABEL_31;
    case 1u:
      FeedbackDelayNetwork<float>::SetDelayTime((uint64_t)this + 688, v12, 0.005, 0.045, v9);
      FeedbackDelayNetwork<float>::SetDecayTime((uint64_t)this + 688, 0.85, 0.3);
      uint64_t v13 = 0x3FEB333333333333;
      goto LABEL_31;
    case 2u:
      FeedbackDelayNetwork<float>::SetDelayTime((uint64_t)this + 688, v12, 0.01, 0.07, v9);
      FeedbackDelayNetwork<float>::SetDecayTime((uint64_t)this + 688, 1.0, 0.6);
      goto LABEL_25;
    case 3u:
      FeedbackDelayNetwork<float>::SetDelayTime((uint64_t)this + 688, v12, 0.01, 0.07, v9);
      FeedbackDelayNetwork<float>::SetDecayTime((uint64_t)this + 688, 2.1, 1.1);
      goto LABEL_28;
    case 4u:
      FeedbackDelayNetwork<float>::SetDelayTime((uint64_t)this + 688, v12, 0.018, 0.1, v9);
      FeedbackDelayNetwork<float>::SetDecayTime((uint64_t)this + 688, 2.9, 2.0);
      goto LABEL_30;
    case 5u:
      FeedbackDelayNetwork<float>::SetDelayTime((uint64_t)this + 688, v12, 0.005, 0.045, v9);
      FeedbackDelayNetwork<float>::SetDecayTime((uint64_t)this + 688, 7.0, 2.5);
      uint64_t v13 = 0x401C000000000000;
      goto LABEL_31;
    case 6u:
      FeedbackDelayNetwork<float>::SetDelayTime((uint64_t)this + 688, v12, 0.01, 0.028, v9);
      FeedbackDelayNetwork<float>::SetDecayTime((uint64_t)this + 688, 1.2, 0.37);
      uint64_t v13 = 0x3FF3333333333333;
      goto LABEL_31;
    case 7u:
      FeedbackDelayNetwork<float>::SetDelayTime((uint64_t)this + 688, v12, 0.01, 0.028, v9);
      FeedbackDelayNetwork<float>::SetDecayTime((uint64_t)this + 688, 2.0, 0.67);
      uint64_t v13 = 0x4000000000000000;
      goto LABEL_31;
    case 8u:
      FeedbackDelayNetwork<float>::SetDelayTime((uint64_t)this + 688, v12, 0.03, 0.2, v9);
      FeedbackDelayNetwork<float>::SetDecayTime((uint64_t)this + 688, 9.0, 3.0);
      uint64_t v13 = 0x4022000000000000;
      goto LABEL_31;
    case 9u:
      FeedbackDelayNetwork<float>::SetDelayTime((uint64_t)this + 688, v12, 0.0065, 0.08, v9);
      FeedbackDelayNetwork<float>::SetDecayTime((uint64_t)this + 688, 1.0, 0.6);
LABEL_25:
      uint64_t v13 = 0x3FF0000000000000;
      goto LABEL_31;
    case 0xAu:
      FeedbackDelayNetwork<float>::SetDelayTime((uint64_t)this + 688, v12, 0.006, 0.04, v9);
      FeedbackDelayNetwork<float>::SetDecayTime((uint64_t)this + 688, 2.1, 1.1);
      goto LABEL_28;
    case 0xBu:
      FeedbackDelayNetwork<float>::SetDelayTime((uint64_t)this + 688, v12, 0.008, 0.055, v9);
      FeedbackDelayNetwork<float>::SetDecayTime((uint64_t)this + 688, 2.1, 1.1);
LABEL_28:
      uint64_t v13 = 0x4000CCCCCCCCCCCDLL;
      goto LABEL_31;
    case 0xCu:
      FeedbackDelayNetwork<float>::SetDelayTime((uint64_t)this + 688, v12, 0.006, 0.04, v9);
      FeedbackDelayNetwork<float>::SetDecayTime((uint64_t)this + 688, 2.9, 2.0);
LABEL_30:
      uint64_t v13 = 0x4007333333333333;
LABEL_31:
      *((void *)this + 245) = v13;
      break;
    default:
      atomic_store(0, (unsigned __int8 *)this + 1952);
      break;
  }
  FeedbackDelayNetwork<float>::Reset((_OWORD *)this + 43);
  atomic_store((v9 * (*((double *)this + 245) + *((double *)this + 245))), (unsigned int *)this + 505);
  return std::scoped_lock<caulk::pooled_semaphore_mutex,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~scoped_lock[abi:ne180100]((uint64_t)v15);
}

void sub_1BB3BDA98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  MEMORY[0x1C185D370](v3, 0x10A1C40AF302FDBLL);
  std::scoped_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~scoped_lock[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void AUSpatialMixerV2::UpdateCounteractRotationShader(AUSpatialMixerV2 *this)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  IR::getPresetDataAttributes();
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)this + 3520);
  BOOL v22 = (v2 & 1) == 0;
  float v3 = *(double *)(ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0) + 80);
  float v21 = v3;
  AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(&cf, (uint64_t)this + 3680);
  unsigned __int8 v4 = (IR::IRDataLoader *)cf;
  if (cf)
  {
    CFTypeRef v5 = v20;
    CFTypeRef v20 = cf;
    unsigned __int8 v4 = (IR::IRDataLoader *)CFRetain(cf);
    if (v5) {
      CFRelease(v5);
    }
  }
  char v6 = (unsigned __int8 *)this + 5932;
  if (!v20
    || (v7 = IR::IRDataLoader::instance(v4), unsigned __int8 v8 = (IR::IRDataLoader *)MEMORY[0x1C185BCE0](v7, &v20), !v8))
  {
    unsigned __int8 v13 = atomic_load(v6);
    if (v13) {
      goto LABEL_28;
    }
    int BooleanFromDictionary = 1;
    goto LABEL_18;
  }
  double v9 = (IR::IRDataLoader *)IR::IRDataLoader::instance(v8);
  IR::IRDataLoader::getUserData((uint64_t *)&v18, v9, (const IR::IRDataAttributes *)&v20);
  CFTypeRef v10 = v18;
  if (v18) {
    CFRetain(v18);
  }
  CFTypeRef v17 = v10;
  std::string::basic_string[abi:ne180100]<0>(buf, "CounteractRotationShader");
  int BooleanFromDictionary = IR::IRData::getBooleanFromDictionary();
  if (SHIBYTE(v29) < 0) {
    operator delete(*(void **)buf);
  }
  if (v17) {
    CFRelease(v17);
  }
  if (v18) {
    CFRelease(v18);
  }
  unsigned __int8 v12 = atomic_load(v6);
  if (BooleanFromDictionary != (v12 & 1))
  {
LABEL_18:
    if (getAUSMV2Log(void)::onceToken != -1) {
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
    }
    char v14 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v15 = (void *)((char *)this + 3368);
      if (*((char *)this + 3391) < 0) {
        __int16 v15 = (void *)*v15;
      }
      *(_DWORD *)AudioTimeStamp buf = 136315650;
      *(void *)&uint8_t buf[4] = v15;
      __int16 v27 = 2080;
      uint64_t v28 = "UpdateCounteractRotationShader";
      if (BooleanFromDictionary) {
        unsigned int v16 = "true";
      }
      else {
        unsigned int v16 = "false";
      }
      __int16 v29 = 2080;
      float32x4_t v30 = v16;
      _os_log_impl(&dword_1BB0CE000, v14, OS_LOG_TYPE_DEFAULT, "[%s|%s] Setting CounteractRotationShader = %s", buf, 0x20u);
    }

    atomic_store(BooleanFromDictionary, v6);
    atomic_store(1u, (unsigned __int8 *)this + 8891);
  }
LABEL_28:
  if (cf) {
    CFRelease(cf);
  }
  if (v25) {
    CFRelease(v25);
  }
  if (v24) {
    CFRelease(v24);
  }
  if (v23) {
    CFRelease(v23);
  }
  if (v20) {
    CFRelease(v20);
  }
}

void sub_1BB3BDDC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void AUSpatialMixerV2::UpdateAutoModeReverb(AUSpatialMixerV2 *this, char a2, char a3, int a4)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  unsigned __int8 v4 = atomic_load((unsigned __int8 *)this + 8977);
  if (v4)
  {
    unsigned __int8 v6 = atomic_load((unsigned __int8 *)this + 2348);
    if ((v6 & 1) == 0)
    {
      if (getAUSMV2Log(void)::onceToken != -1) {
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
      }
      uint64_t v7 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        unsigned __int8 v8 = (void *)((char *)this + 3368);
        if (*((char *)this + 3391) < 0) {
          unsigned __int8 v8 = (void *)*v8;
        }
        *(_DWORD *)AudioTimeStamp buf = 136315394;
        *(void *)&uint8_t buf[4] = v8;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = "UpdateAutoModeReverb";
        _os_log_debug_impl(&dword_1BB0CE000, v7, OS_LOG_TYPE_DEBUG, "[%s|%s] auto mode reverb not initialized", buf, 0x16u);
      }
      goto LABEL_30;
    }
    unsigned __int8 v12 = atomic_load((unsigned __int8 *)this + 3520);
    if ((v12 & 1) != 0
      && ((unsigned int v13 = atomic_load((unsigned int *)this + 862), v13 == 1)
       || (unsigned int v14 = atomic_load((unsigned int *)this + 862), v14 == 2)
       && (*((unsigned char *)this + 5908) || (unsigned __int8 v15 = atomic_load((unsigned __int8 *)this + 5909), (v15 & 1) != 0))))
    {
      unint64_t v19 = *(unsigned int *)(ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0) + 108);
      if (0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)this + 298) - *((void *)this + 297)) >> 3) != v19)
      {
        __int16 v27 = (char *)this + 2400;
        char v28 = 1;
        caulk::pooled_semaphore_mutex::_lock((AUSpatialMixerV2 *)((char *)this + 2400));
        IR::FixedIntegerDelay::FixedIntegerDelay((IR::FixedIntegerDelay *)buf, 0x80u, 1);
        std::vector<IR::FixedIntegerDelay>::resize((uint64_t *)this + 297, v19, (IR::FixedIntegerDelay *)buf);
        if (__p)
        {
          uint64_t v31 = __p;
          operator delete(__p);
        }
        if (*(void *)&buf[8])
        {
          *(void *)&buf[16] = *(void *)&buf[8];
          operator delete(*(void **)&buf[8]);
        }
        CFTypeRef v18 = &v27;
        goto LABEL_25;
      }
    }
    else if (*((void *)this + 298) != *((void *)this + 297))
    {
      *(void *)AudioTimeStamp buf = (char *)this + 2400;
      buf[8] = 1;
      caulk::pooled_semaphore_mutex::_lock((AUSpatialMixerV2 *)((char *)this + 2400));
      unsigned int v16 = (void *)*((void *)this + 298);
      CFTypeRef v17 = (void *)*((void *)this + 297);
      while (v16 != v17)
      {
        v16 -= 7;
        std::__destroy_at[abi:ne180100]<IR::FixedIntegerDelay,0>(v16);
      }
      *((void *)this + 298) = v17;
      CFTypeRef v18 = (char **)buf;
LABEL_25:
      std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)v18);
    }
    unsigned __int8 v20 = atomic_load((unsigned __int8 *)this + 3444);
    if (v20) {
      float v21 = (void (*)(uint64_t, void *))MEMORY[0x1E4F147E8];
    }
    else {
      float v21 = (void (*)(uint64_t, void *))MEMORY[0x1E4F14768];
    }
    uint64_t v7 = *((void *)this + 327);
    uint64_t v22 = applesauce::dispatch::v1::queue::get(v7);
    v23[0] = MEMORY[0x1E4F143A8];
    v23[1] = 3221225472;
    v23[2] = ___ZN16AUSpatialMixerV220UpdateAutoModeReverbEbbi_block_invoke;
    v23[3] = &__block_descriptor_46_e5_v8__0l;
    v23[4] = this;
    int v24 = a4;
    char v25 = a2;
    char v26 = a3;
    v21(v22, v23);
LABEL_30:
  }
}

void sub_1BB3BE148(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  IR::FixedIntegerDelay::~FixedIntegerDelay((IR::FixedIntegerDelay *)va1);
  std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t AUSpatialMixerV2::PropagateGlobalPropertyChangeToInputElements(AUSpatialMixerV2 *this, uint64_t a2)
{
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)this + 8977);
  if ((v2 & 1) == 0) {
    return 0;
  }
  unsigned __int8 v12 = (char *)this + 3120;
  char v13 = 1;
  std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)((char *)this + 3120));
  uint64_t v3 = 0;
  for (unsigned int i = 0; ; ++i)
  {
    uint64_t v7 = *((void *)this + 15);
    if (v7) {
      LODWORD(v8) = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 24))(v7);
    }
    else {
      uint64_t v8 = (*((void *)this + 13) - *((void *)this + 12)) >> 3;
    }
    if (i >= v8) {
      break;
    }
    uint64_t Element = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), i);
    unsigned int v10 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)Element + 136))(Element, a2);
    if (v10) {
      uint64_t v3 = v10;
    }
    else {
      uint64_t v3 = v3;
    }
  }
  std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&v12);
  return v3;
}

void sub_1BB3BE27C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void AUSpatialMixerV2::ReloadFactoryPresetIfNecessary(AUSpatialMixerV2 *this)
{
  v48[1] = *MEMORY[0x1E4F143B8];
  if (!ausdk::AUBase::DispatchGetProperty(this, 36, 0, 0, &v38))
  {
    unsigned int v2 = v38;
    CFRelease(*((CFTypeRef *)&v38 + 1));
    if (v2 == -1 || !*((_DWORD *)this + 2232))
    {
      if (getAUSMV2Log(void)::onceToken != -1) {
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
      }
      unsigned __int8 v4 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
      {
        CFTypeRef v23 = (void *)((char *)this + 3368);
        if (*((char *)this + 3391) < 0) {
          CFTypeRef v23 = (void *)*v23;
        }
        *(_DWORD *)AudioTimeStamp buf = 136315394;
        unint64_t v40 = v23;
        __int16 v41 = 2080;
        *(void *)float v42 = "ReloadFactoryPresetIfNecessary";
        _os_log_debug_impl(&dword_1BB0CE000, v4, OS_LOG_TYPE_DEBUG, "[%s|%s] No headphone factory preset was set.", buf, 0x16u);
      }
    }
    else
    {
      int v37 = 0;
      if ((*(unsigned int (**)(AUSpatialMixerV2 *, uint64_t, void, void, int *))(*(void *)this + 88))(this, 3116, 0, 0, &v37))
      {
        if (getAUSMV2Log(void)::onceToken != -1) {
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
        }
        uint64_t v3 = (id)getAUSMV2Log(void)::gLog;
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        {
          int v24 = (void *)((char *)this + 3368);
          if (*((char *)this + 3391) < 0) {
            int v24 = (void *)*v24;
          }
          *(_DWORD *)AudioTimeStamp buf = 136315394;
          unint64_t v40 = v24;
          __int16 v41 = 2080;
          *(void *)float v42 = "ReloadFactoryPresetIfNecessary";
          _os_log_error_impl(&dword_1BB0CE000, v3, OS_LOG_TYPE_ERROR, "[%s|%s] Could not get personalized HRTF status.", buf, 0x16u);
        }
      }
      else
      {
        CFTypeRef v5 = (int *)((char *)this + 8928);
        if (v37) {
          int v6 = 2;
        }
        else {
          int v6 = 1;
        }
        if (*v5 == v6)
        {
          if (getAUSMV2Log(void)::onceToken != -1) {
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
          }
          uint64_t v7 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
          {
            char v25 = (void *)((char *)this + 3368);
            if (*((char *)this + 3391) < 0) {
              char v25 = (void *)*v25;
            }
            int v26 = *v5;
            *(_DWORD *)AudioTimeStamp buf = 136315906;
            unint64_t v40 = v25;
            __int16 v41 = 2080;
            *(void *)float v42 = "ReloadFactoryPresetIfNecessary";
            *(_WORD *)&uint8_t v42[8] = 1024;
            unsigned int v43 = v2;
            __int16 v44 = 1024;
            int v45 = v26;
            _os_log_debug_impl(&dword_1BB0CE000, v7, OS_LOG_TYPE_DEBUG, "[%s|%s] FactoryPreset %u of subtype = %u is already loaded.", buf, 0x22u);
          }
        }
        else
        {
          AUSM::FactoryPreset::load((AUSM::FactoryPreset *)buf, (int *)this + 2232, v2, v37 != 0);
          if (*(void *)&v42[2])
          {
            uint64_t v8 = (CFDictionaryRef *)applesauce::CF::DictionaryRef::operator->(&v42[2]);
            applesauce::CF::details::find_at_key_or_optional<applesauce::CF::ArrayRef,__CFString const*&>(&v35, *v8, (const void *)AUSM::kFactoryPresetChannelOverridesKey);
            double v9 = (CFDictionaryRef *)applesauce::CF::DictionaryRef::operator->(&v42[2]);
            applesauce::CF::details::find_at_key_or_optional<applesauce::CF::ArrayRef,__CFString const*&>(&v33, *v9, (const void *)AUSM::kFactoryPresetGlobalPropertiesKey);
            unsigned int v10 = objc_opt_new();
            if (v36)
            {
              id v11 = v35;
              applesauce::dispatch::v1::queue::get(v35);
              objc_claimAutoreleasedReturnValue();
              [v10 setObject:v11 forKeyedSubscript:AUSM::kFactoryPresetChannelOverridesKey];
            }
            if (v34)
            {
              applesauce::CF::ArrayRef::ArrayRef((applesauce::CF::ArrayRef *)&v32, v33);
              unsigned __int8 v12 = (const __CFArray **)applesauce::CF::ArrayRef::operator->(&v32);
              if (applesauce::CF::ArrayRef_proxy::get_size(*v12))
              {
                char v13 = (const __CFArray **)applesauce::CF::ArrayRef::operator->(&v32);
                applesauce::CF::details::at_to<applesauce::CF::DictionaryRef>(*v13, 0, (applesauce::CF::DictionaryRef *)&v31);
                unsigned int v14 = (void *)[v31 mutableCopy];
                unsigned __int8 v15 = [&unk_1F14EBB20 stringValue];
                v48[0] = v15;
                unsigned int v16 = [MEMORY[0x1E4F1C978] arrayWithObjects:v48 count:1];

                long long v29 = 0u;
                long long v30 = 0u;
                long long v27 = 0u;
                long long v28 = 0u;
                CFTypeRef v17 = objc_msgSend(v14, "allKeys", 0);
                uint64_t v18 = [v17 countByEnumeratingWithState:&v27 objects:v47 count:16];
                if (v18)
                {
                  uint64_t v19 = *(void *)v28;
                  do
                  {
                    for (uint64_t i = 0; i != v18; ++i)
                    {
                      if (*(void *)v28 != v19) {
                        objc_enumerationMutation(v17);
                      }
                      uint64_t v21 = *(void *)(*((void *)&v27 + 1) + 8 * i);
                      if (([v16 containsObject:v21] & 1) == 0) {
                        [v14 removeObjectForKey:v21];
                      }
                    }
                    uint64_t v18 = [v17 countByEnumeratingWithState:&v27 objects:v47 count:16];
                  }
                  while (v18);
                }

                uint64_t v46 = v14;
                uint64_t v22 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v46 count:1];
                [v10 setObject:v22 forKeyedSubscript:AUSM::kFactoryPresetGlobalPropertiesKey];

                applesauce::CF::DictionaryRef::~DictionaryRef((const void **)&v31);
              }
              applesauce::CF::ArrayRef::~ArrayRef(&v32);
            }
            (*(void (**)(AUSpatialMixerV2 *, void *))(*(void *)this + 288))(this, v10);
            ausdk::AUBase::SetAFactoryPresetAsCurrent((char *)this, (const AUPreset *)buf);

            std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v33);
            std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v35);
            if (*(void *)&v42[2]) {
              CFRelease(*(CFTypeRef *)&v42[2]);
            }
          }
        }
      }
    }
  }
}

void sub_1BB3BE828(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, const void *a18, const void *a19, char a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  applesauce::CF::DictionaryRef::~DictionaryRef(&a18);
  applesauce::CF::ArrayRef::~ArrayRef(&a19);

  std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&a20);
  std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&a22);
  std::pair<AUPreset,applesauce::CF::DictionaryRef>::~pair((uint64_t)&a27);
  _Unwind_Resume(a1);
}

void AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(void *a1, uint64_t a2)
{
  unsigned __int8 v4 = (std::mutex *)(a2 + 8);
  std::mutex::lock((std::mutex *)(a2 + 8));
  CFTypeRef v5 = *(const void **)a2;
  if (v5) {
    CFRetain(v5);
  }
  *a1 = v5;

  std::mutex::unlock(v4);
}

void AUSpatialMixerV2::RefreshXTCTuningParameters(AUSpatialMixerV2 *this)
{
  uint64_t v107 = *MEMORY[0x1E4F143B8];
  CFTypeRef v81 = 0;
  FilterCFIndex Length = 0;
  AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(&cf, (uint64_t)this + 3680);
  CFTypeRef v3 = cf;
  if (cf)
  {
    CFRetain(cf);
    CFTypeRef v78 = v3;
    unsigned __int8 v4 = atomic_load((unsigned __int8 *)this + 3520);
    IR::IRDataAttributes::IRDataAttributes((uint64_t)v83, v3, 128, (v4 & 1) == 0, 48000.0);
    CFRelease(v3);
    uint64_t v6 = IR::IRDataLoader::instance(v5);
    uint64_t v7 = (IR::IRDataLoader *)MEMORY[0x1C185BCE0](v6, v83);
    if (v7)
    {
      uint64_t v8 = (IR::IRDataLoader *)IR::IRDataLoader::instance(v7);
      IR::IRDataLoader::getUserData((uint64_t *)&v102, v8, (const IR::IRDataAttributes *)v83);
      double v9 = (CFTypeRef *)v81;
      CFTypeRef v81 = v102;
      CFTypeRef v102 = v9;
      if (v9) {
        CFRelease(v9);
      }
      unsigned int v10 = (IR::IRDataLoader *)IR::IRDataLoader::instance((IR::IRDataLoader *)v9);
      FilterCFIndex Length = IR::IRDataLoader::getFilterLength(v10, (const IR::IRDataAttributes *)v83);
    }
    if (v97[0]) {
      CFRelease(v97[0]);
    }
    if (v92) {
      CFRelease(v92);
    }
    if (v89) {
      CFRelease(v89);
    }
    if (v83[0]) {
      CFRelease(v83[0]);
    }
  }
  else if (*((unsigned char *)this + 5908))
  {
    IR::IRDataLoader::instance(v2);
    IR::IRDataLoader::getUserData();
    id v11 = (void *)v81;
    CFTypeRef v81 = v83[0];
    v83[0] = v11;
    if (v11) {
      CFRelease(v11);
    }
    IR::IRDataLoader::instance((IR::IRDataLoader *)v11);
    FilterCFIndex Length = IR::IRDataLoader::getFilterLength();
  }
  uint64_t v12 = *((void *)this + 1117);
  if (v12)
  {
    int v13 = *(unsigned __int8 *)(v12 + 57);
    BOOL v14 = *(void *)(v12 + 784) != 0;
  }
  else
  {
    BOOL v14 = 0;
    int v13 = 0;
  }
  if (v81)
  {
    v83[0] = &v81;
    v76[0] = @"XTCSpeakerSpan";
    CFDictionaryRef v15 = applesauce::CF::DictionaryRef_proxy::at_as<float,__CFString const*>((const __CFDictionary ***)v83, v76);
    if (((unint64_t)v15 & 0xFF00000000) != 0)
    {
      LODWORD(v102) = v15;
    }
    else
    {
      CFDictionaryRef v25 = (const __CFDictionary *)*((void *)this + 377);
      if (v25)
      {
        LODWORD(v83[0]) = 1101004800;
        float v26 = applesauce::CF::at_or<float,char const(&)[12]>(v25, (uint64_t)v83);
      }
      else
      {
        float v26 = 20.0;
      }
      *(float *)&CFTypeRef v102 = v26;
    }
    if (!v81)
    {
      exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
    }
    v83[0] = &v81;
    v76[0] = @"XTCRegularization";
    CFDictionaryRef v27 = applesauce::CF::DictionaryRef_proxy::at_as<float,__CFString const*>((const __CFDictionary ***)v83, v76);
    if (((unint64_t)v27 & 0xFF00000000) != 0)
    {
      HIDWORD(v102) = v27;
    }
    else
    {
      CFDictionaryRef v28 = (const __CFDictionary *)*((void *)this + 377);
      if (v28)
      {
        LODWORD(v83[0]) = 1086324736;
        float v29 = applesauce::CF::at_or<float,char const(&)[15]>(v28, (uint64_t)v83);
      }
      else
      {
        float v29 = 6.0;
      }
      *((float *)&v102 + 1) = v29;
    }
    if (!v81)
    {
      uint64_t v60 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v60, "Could not construct");
    }
    v83[0] = &v81;
    v76[0] = @"XTCConstraint";
    CFDictionaryRef v30 = applesauce::CF::DictionaryRef_proxy::at_as<float,__CFString const*>((const __CFDictionary ***)v83, v76);
    if (((unint64_t)v30 & 0xFF00000000) != 0)
    {
      LODWORD(v103) = v30;
      float v31 = *(float *)&v30;
    }
    else
    {
      CFDictionaryRef v32 = (const __CFDictionary *)*((void *)this + 377);
      if (v32)
      {
        LODWORD(v83[0]) = 1107296256;
        float v31 = applesauce::CF::at_or<float,char const(&)[11]>(v32, "Constraint", (uint64_t)v83);
      }
      else
      {
        float v31 = 32.0;
      }
      *(float *)&uint64_t v103 = v31;
    }
    if (!v81)
    {
      int v61 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v61, "Could not construct");
    }
    v83[0] = &v81;
    v76[0] = @"XTCPostTimbralFrequency";
    CFDictionaryRef v33 = applesauce::CF::DictionaryRef_proxy::at_as<float,__CFString const*>((const __CFDictionary ***)v83, v76);
    if (((unint64_t)v33 & 0xFF00000000) != 0)
    {
      HIDWORD(v103) = v33;
      float v34 = *(float *)&v33;
    }
    else
    {
      CFDictionaryRef v35 = (const __CFDictionary *)*((void *)this + 377);
      if (v35)
      {
        LODWORD(v83[0]) = 1186693120;
        float v34 = applesauce::CF::at_or<float,char const(&)[21]>(v35, (uint64_t)v83);
      }
      else
      {
        float v34 = 24000.0;
      }
      *((float *)&v103 + 1) = v34;
    }
    if (!v81)
    {
      float v62 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v62, "Could not construct");
    }
    v83[0] = &v81;
    v76[0] = @"XTCPostTimbralBlend";
    CFDictionaryRef v36 = applesauce::CF::DictionaryRef_proxy::at_as<float,__CFString const*>((const __CFDictionary ***)v83, v76);
    if (((unint64_t)v36 & 0xFF00000000) != 0)
    {
      float v104 = *(float *)&v36;
      float v37 = *(float *)&v36;
    }
    else
    {
      CFDictionaryRef v38 = (const __CFDictionary *)*((void *)this + 377);
      if (v38)
      {
        LODWORD(v83[0]) = 1120403456;
        float v37 = applesauce::CF::at_or<float,char const(&)[17]>(v38, "PostTimbralBlend", (uint64_t)v83);
      }
      else
      {
        float v37 = 100.0;
      }
      float v104 = v37;
    }
    if (!v81)
    {
      float v63 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v63, "Could not construct");
    }
    v83[0] = &v81;
    v76[0] = @"XTCCrossover";
    CFDictionaryRef v39 = applesauce::CF::DictionaryRef_proxy::at_as<float,__CFString const*>((const __CFDictionary ***)v83, v76);
    if (((unint64_t)v39 & 0xFF00000000) != 0)
    {
      float v105 = *(float *)&v39;
      float v40 = *(float *)&v39;
    }
    else
    {
      CFDictionaryRef v41 = (const __CFDictionary *)*((void *)this + 377);
      if (v41)
      {
        LODWORD(v83[0]) = 1175232512;
        float v40 = applesauce::CF::at_or<float,char const(&)[10]>(v41, (uint64_t)v83);
      }
      else
      {
        float v40 = *(float *)"";
      }
      float v105 = v40;
    }
    if (!v81)
    {
      unsigned int v64 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v64, "Could not construct");
    }
    v83[0] = &v81;
    v76[0] = @"XTCPostGain";
    CFDictionaryRef v42 = applesauce::CF::DictionaryRef_proxy::at_as<float,__CFString const*>((const __CFDictionary ***)v83, v76);
    if (((unint64_t)v42 & 0xFF00000000) != 0)
    {
      float v106 = *(float *)&v42;
      float v43 = *(float *)&v42;
    }
    else
    {
      CFDictionaryRef v44 = (const __CFDictionary *)*((void *)this + 377);
      if (v44)
      {
        LODWORD(v83[0]) = 0;
        float v43 = applesauce::CF::at_or<float,char const(&)[9]>(v44, (uint64_t)v83);
      }
      else
      {
        float v43 = 0.0;
      }
      float v106 = v43;
    }
    if (!v81)
    {
      unsigned int v65 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v65, "Could not construct");
    }
    if (applesauce::CF::details::has_key<__CFString const*>((const __CFDictionary *)v81, @"CounteractRotationShader"))
    {
      CFTypeRef v45 = v81;
      if (v81) {
        CFRetain(v81);
      }
      CFTypeRef v77 = v45;
      std::string::basic_string[abi:ne180100]<0>(v83, "CounteractRotationShader");
      int BooleanFromDictionary = IR::IRData::getBooleanFromDictionary();
      if ((v84[7] & 0x80000000) != 0) {
        operator delete((void *)v83[0]);
      }
      if (v77) {
        CFRelease(v77);
      }
    }
    else
    {
      CFDictionaryRef v47 = (const __CFDictionary *)*((void *)this + 377);
      if (v47)
      {
        unsigned int v48 = (unsigned __int16)applesauce::CF::details::find_at_key_or_optional<BOOL,char const(&)[25]>(v47, "CounteractRotationShader");
        if (v48 <= 0x100) {
          LOBYTE(v48) = 0;
        }
        int BooleanFromDictionary = v48 != 0;
      }
      else
      {
        int BooleanFromDictionary = 0;
      }
    }
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[12],float &>((applesauce::CF::TypeRef *)v83, "SpeakerSpan", (int *)&v102);
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[15],float &>((applesauce::CF::TypeRef *)v84, "Regularization", (int *)&v102 + 1);
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v85, "Constraint");
    float valuePtr = v31;
    if (!CFNumberCreate(0, kCFNumberFloatType, &valuePtr))
    {
      unsigned int v66 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v66, "Could not construct");
    }
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v87, "PostTimbralFrequency");
    float valuePtr = v34;
    if (!CFNumberCreate(0, kCFNumberFloatType, &valuePtr))
    {
      unsigned int v67 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v67, "Could not construct");
    }
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v89, "PostTimbralBlend");
    float valuePtr = v37;
    if (!CFNumberCreate(0, kCFNumberFloatType, &valuePtr))
    {
      uint64_t v68 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v68, "Could not construct");
    }
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v91, "Crossover");
    float valuePtr = v40;
    CFNumberRef v92 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
    if (!v92)
    {
      DSPSplitComplex v69 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v69, "Could not construct");
    }
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v93, "PostGain");
    float valuePtr = v43;
    if (!CFNumberCreate(0, kCFNumberFloatType, &valuePtr))
    {
      unint64_t v70 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v70, "Could not construct");
    }
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v95, "CounteractRotationShader");
    uint64_t v49 = *MEMORY[0x1E4F1CFD0];
    uint64_t v50 = *MEMORY[0x1E4F1CFC8];
    if (BooleanFromDictionary) {
      uint64_t v51 = *MEMORY[0x1E4F1CFD0];
    }
    else {
      uint64_t v51 = *MEMORY[0x1E4F1CFC8];
    }
    uint64_t v96 = v51;
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[13],int &>((applesauce::CF::TypeRef *)v97, &FilterLength);
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v98, "MagicUnicorn");
    if (v13) {
      uint64_t v52 = v49;
    }
    else {
      uint64_t v52 = v50;
    }
    uint64_t v99 = v52;
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)v100, "ReferenceData");
    if (v14) {
      uint64_t v53 = v49;
    }
    else {
      uint64_t v53 = v50;
    }
    uint64_t v101 = v53;
    v76[0] = v83;
    v76[1] = (const void *)11;
    CFDictionaryRef CFDictionaryRef = applesauce::CF::details::make_CFDictionaryRef((uint64_t)v76);
    unint64_t v55 = (const void *)*((void *)this + 377);
    *((void *)this + 377) = CFDictionaryRef;
    if (v55) {
      CFRelease(v55);
    }
    for (uint64_t i = 0; i != -176; i -= 16)
    {
      int v57 = *(const void **)((char *)&v101 + i);
      if (v57) {
        CFRelease(v57);
      }
      int v58 = *(const void **)&v100[i];
      if (v58) {
        CFRelease(v58);
      }
    }
  }
  else
  {
    LODWORD(v76[0]) = 1101004800;
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[12],float>((applesauce::CF::TypeRef *)v83, (int *)v76);
    float valuePtr = 6.0;
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[15],float>((applesauce::CF::TypeRef *)v84, (int *)&valuePtr);
    int v75 = 1107296256;
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[11],float>((applesauce::CF::TypeRef *)&v85, &v75);
    int v74 = 1186693120;
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[21],float>((applesauce::CF::TypeRef *)&v87, &v74);
    int v73 = 1120403456;
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[17],float>((applesauce::CF::TypeRef *)&v89, "PostTimbralBlend", &v73);
    int v72 = 1175232512;
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[10],float>((applesauce::CF::TypeRef *)&v91, &v72);
    int v71 = 0;
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[9],float>((applesauce::CF::TypeRef *)&v93, &v71);
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v95, "CounteractRotationShader");
    uint64_t v16 = *MEMORY[0x1E4F1CFC8];
    uint64_t v96 = *MEMORY[0x1E4F1CFC8];
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[13],int &>((applesauce::CF::TypeRef *)v97, &FilterLength);
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v98, "MagicUnicorn");
    uint64_t v17 = *MEMORY[0x1E4F1CFD0];
    if (v13) {
      uint64_t v18 = *MEMORY[0x1E4F1CFD0];
    }
    else {
      uint64_t v18 = v16;
    }
    uint64_t v99 = v18;
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)v100, "ReferenceData");
    if (v14) {
      uint64_t v19 = v17;
    }
    else {
      uint64_t v19 = v16;
    }
    uint64_t v101 = v19;
    CFTypeRef v102 = v83;
    uint64_t v103 = 11;
    CFDictionaryRef v20 = applesauce::CF::details::make_CFDictionaryRef((uint64_t)&v102);
    uint64_t v21 = (const void *)*((void *)this + 377);
    *((void *)this + 377) = v20;
    if (v21) {
      CFRelease(v21);
    }
    for (uint64_t j = 0; j != -176; j -= 16)
    {
      CFTypeRef v23 = *(const void **)((char *)&v101 + j);
      if (v23) {
        CFRelease(v23);
      }
      int v24 = *(const void **)&v100[j];
      if (v24) {
        CFRelease(v24);
      }
    }
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v81) {
    CFRelease(v81);
  }
}

void sub_1BB3BF54C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, int a15, __int16 a16, char a17, char a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,char a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,CFTypeRef cf)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

BOOL AUSpatialMixerV2::InitializeDynamicXTC(uint64_t a1, CFURLRef *a2)
{
  CFStringRef v4 = CFURLGetString(*a2);
  v51.length = CFStringGetLength(v4);
  v51.locatiouint64_t n = 0;
  int v5 = CFStringFindWithOptions(v4, @"Tuning_Mode_HRTFXTC_Reference_Data", v51, 1uLL, &result);
  if (v5)
  {
    CFURLRef v6 = *a2;
    if (*a2) {
      CFRetain(*a2);
    }
    CFURLRef v36 = v6;
    IR::IRDataAttributes::IRDataAttributes((uint64_t)&cf, v6, 128, 1, 48000.0);
    if (v6) {
      CFRelease(v6);
    }
    uint64_t v7 = *(const void **)(a1 + 3024);
    if (v7)
    {
      uint64_t v8 = *(const void **)(a1 + 3016);
      *(void *)(a1 + 3016) = v7;
      CFRetain(v7);
      if (v8) {
        CFRelease(v8);
      }
    }
    unsigned __int8 v9 = atomic_load((unsigned __int8 *)(a1 + 3444));
    unsigned int v10 = *(void **)(a1 + 2616);
    applesauce::dispatch::v1::queue::get(v10);
    objc_claimAutoreleasedReturnValue();
    if (v9) {
      id v11 = (void (*)(void *, void *))MEMORY[0x1E4F147E8];
    }
    else {
      id v11 = (void (*)(void *, void *))MEMORY[0x1E4F14768];
    }
    v22[0] = MEMORY[0x1E4F143A8];
    v22[1] = 3321888768;
    v22[2] = ___ZN16AUSpatialMixerV220InitializeDynamicXTCEN10applesauce2CF6URLRefE_block_invoke_163;
    v22[3] = &__block_descriptor_200_ea8_40c27_ZTSN2IR16IRDataAttributesE192c28_ZTSN10applesauce2CF6URLRefE_e5_v8__0l;
    v22[4] = a1;
    CFTypeRef v12 = cf;
    if (cf) {
      CFRetain(cf);
    }
    CFTypeRef v23 = v12;
    long long v24 = v38;
    long long v25 = v39;
    long long v26 = v40;
    char v27 = v41;
    CFTypeRef v13 = v42;
    if (v42) {
      CFRetain(v42);
    }
    CFTypeRef v28 = v13;
    long long v29 = v43;
    CFTypeRef v14 = v44;
    if (v44) {
      CFRetain(v44);
    }
    CFTypeRef v30 = v14;
    v31[0] = v45[0];
    *(_OWORD *)((char *)v31 + 9) = *(_OWORD *)((char *)v45 + 9);
    CFTypeRef v15 = v46;
    if (v46) {
      CFRetain(v46);
    }
    CFTypeRef v32 = v15;
    uint64_t v33 = v47;
    int v34 = v48;
    CFURLRef v16 = *a2;
    if (v16) {
      CFRetain(v16);
    }
    CFTypeRef v35 = v16;
    v11(v10, v22);

    if (v35) {
      CFRelease(v35);
    }
    if (v32) {
      CFRelease(v32);
    }
    if (v30) {
      CFRelease(v30);
    }
    if (v28) {
      CFRelease(v28);
    }
    if (v23) {
      CFRelease(v23);
    }
    if (v46) {
      CFRelease(v46);
    }
    if (v44) {
      CFRelease(v44);
    }
    if (v42) {
      CFRelease(v42);
    }
    if (cf) {
      CFRelease(cf);
    }
  }
  else
  {
    unsigned __int8 v17 = atomic_load((unsigned __int8 *)(a1 + 3444));
    if (v17) {
      uint64_t v18 = (void (*)(uint64_t, void *))MEMORY[0x1E4F147E8];
    }
    else {
      uint64_t v18 = (void (*)(uint64_t, void *))MEMORY[0x1E4F14768];
    }
    uint64_t v19 = *(void **)(a1 + 2616);
    uint64_t v20 = applesauce::dispatch::v1::queue::get(v19);
    v49[0] = MEMORY[0x1E4F143A8];
    v49[1] = 3221225472;
    v49[2] = ___ZN16AUSpatialMixerV220InitializeDynamicXTCEN10applesauce2CF6URLRefE_block_invoke;
    v49[3] = &__block_descriptor_40_e5_v8__0l;
    v49[4] = a1;
    v18(v20, v49);
  }
  return v5 != 0;
}

void sub_1BB3BFBA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,const void *a34)
{
}

void AUSM::AppleSauceCFWithMutex<__CFURL const*>::store(uint64_t a1, const void **a2)
{
  CFStringRef v4 = (std::mutex *)(a1 + 8);
  std::mutex::lock((std::mutex *)(a1 + 8));
  int v5 = *(const void **)a1;
  CFURLRef v6 = *a2;
  *(void *)a1 = *a2;
  if (v6) {
    CFRetain(v6);
  }
  if (v5) {
    CFRelease(v5);
  }

  std::mutex::unlock(v4);
}

pthread_t caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock(uint64_t a1)
{
  pthread_t result = pthread_self();
  unint64_t v3 = (unint64_t)result;
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)a1, memory_order_acquire);
  if (result)
  {
    if (explicit) {
      BOOL v5 = result == (pthread_t)explicit;
    }
    else {
      BOOL v5 = 0;
    }
    if (!v5) {
      goto LABEL_9;
    }
  }
  else if (explicit)
  {
LABEL_9:
    pthread_t result = (pthread_t)caulk::pooled_semaphore_mutex::_lock((caulk::pooled_semaphore_mutex *)(a1 + 12));
    atomic_store(v3, (unint64_t *)a1);
    int v6 = 1;
    goto LABEL_10;
  }
  int v6 = *(_DWORD *)(a1 + 8) + 1;
LABEL_10:
  *(_DWORD *)(a1 + 8) = v6;
  return result;
}

uint64_t caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(uint64_t a1)
{
  uint64_t result = (uint64_t)pthread_self();
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)a1, memory_order_acquire);
  if (result)
  {
    if (explicit) {
      BOOL v4 = result == explicit;
    }
    else {
      BOOL v4 = 0;
    }
    if (!v4) {
      goto LABEL_11;
    }
  }
  else if (explicit)
  {
LABEL_11:
    _os_assert_log();
    _os_crash();
    __break(1u);
LABEL_12:
    atomic_store(0, (unint64_t *)a1);
    return caulk::pooled_semaphore_mutex::_unlock((caulk::pooled_semaphore_mutex *)(a1 + 12));
  }
  int v5 = *(_DWORD *)(a1 + 8);
  if (v5 <= 0)
  {
    _os_assert_log();
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  int v6 = v5 - 1;
  *(_DWORD *)(a1 + 8) = v6;
  if (!v6) {
    goto LABEL_12;
  }
  return result;
}

uint64_t AUSpatialMixerV2::LoadDynamicProcessorPreset(AUSpatialMixerV2 *this, int a2, CFURLRef *a3)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (!*a3) {
    return 0;
  }
  int v5 = (uint64_t *)*((void *)this + 416);
  int v6 = (uint64_t *)*((void *)this + 417);
  if (v5 != v6)
  {
    while (*(_DWORD *)(*v5 + 120) != a2)
    {
      if (++v5 == v6) {
        goto LABEL_17;
      }
    }
  }
  if (v5 == v6)
  {
LABEL_17:
    if (getAUSMV2Log(void)::onceToken != -1) {
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
    }
    CFTypeRef v13 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v22 = (void *)((char *)this + 3368);
      if (*((char *)this + 3391) < 0) {
        uint64_t v22 = (void *)*v22;
      }
      CFTypeRef v23 = "????";
      if (a2 == 1818521197) {
        CFTypeRef v23 = "ldnm";
      }
      *(_DWORD *)int v34 = 136315906;
      *(void *)&v34[4] = v22;
      *(void *)&v34[14] = "FindDynamicProcessor";
      *(_WORD *)&v34[12] = 2080;
      if (a2 == 1667658347) {
        long long v24 = "cfrk";
      }
      else {
        long long v24 = v23;
      }
      *(_WORD *)&v34[22] = 2080;
      *(void *)&v34[24] = v24;
      __int16 v35 = 1024;
      int v36 = a2;
      _os_log_debug_impl(&dword_1BB0CE000, v13, OS_LOG_TYPE_DEBUG, "[%s|%s] can't find dynamics processor %s (%u).", v34, 0x26u);
    }

    return 4294967246;
  }
  uint64_t v7 = *v5;
  if (!*v5) {
    return 4294967246;
  }
  CFStringRef v8 = CFURLCopyFileSystemPath(*a3, kCFURLPOSIXPathStyle);
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&string, v8);
  CFStringRef v9 = string;
  if (!string)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  MaximumSizeOfFileSystemRepresentatiouint64_t n = CFStringGetMaximumSizeOfFileSystemRepresentation(string);
  std::vector<char>::vector((std::vector<char> *)v34, MaximumSizeOfFileSystemRepresentation);
  FileSystemRepresentatiouint64_t n = CFStringGetFileSystemRepresentation(v9, *(char **)v34, *(void *)&v34[8] - *(void *)v34);
  if (FileSystemRepresentation) {
    std::string::basic_string[abi:ne180100]<0>(&__p, *(char **)v34);
  }
  if (*(void *)v34)
  {
    *(void *)&v34[8] = *(void *)v34;
    operator delete(*(void **)v34);
  }
  if (FileSystemRepresentation)
  {
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::__init_copy_ctor_external(&v29, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
      goto LABEL_25;
    }
  }
  else
  {
    memset(&__p, 0, sizeof(__p));
  }
  std::string v29 = __p;
LABEL_25:
  AUSM::loadAUPreset(&cf, (const char *)&v29);
  if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v29.__r_.__value_.__l.__data_);
  }
  CFTypeRef v15 = cf;
  if (!cf)
  {
    if (getAUSMV2Log(void)::onceToken != -1) {
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
    }
    uint64_t v21 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      long long v25 = (void *)(v7 + 72);
      if (*(char *)(v7 + 95) < 0) {
        long long v25 = (void *)*v25;
      }
      *(_DWORD *)int v34 = 136315394;
      *(void *)&v34[4] = "loadPreset";
      *(_WORD *)&v34[12] = 2080;
      *(void *)&v34[14] = v25;
      _os_log_error_impl(&dword_1BB0CE000, v21, OS_LOG_TYPE_ERROR, "%s: null dictionary ref for %s", v34, 0x16u);
    }

    uint64_t v12 = 4294967246;
    goto LABEL_54;
  }
  CFRetain(cf);
  int v16 = *((_DWORD *)this + 84);
  int v17 = *(unsigned __int8 *)(v7 + 124);
  if (*(unsigned char *)(v7 + 124))
  {
    uint64_t v12 = AUSM::AUFXWrapper::uninitialize((OpaqueAudioComponentInstance **)v7);
    if (v12)
    {
      if (getAUSMV2Log(void)::onceToken != -1) {
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
      }
      uint64_t v18 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        char v27 = (void *)(v7 + 72);
        if (*(char *)(v7 + 95) < 0) {
          char v27 = (void *)*v27;
        }
        *(_DWORD *)int v34 = 136315650;
        *(void *)&v34[4] = "loadPreset";
        *(_WORD *)&v34[12] = 1024;
        *(_DWORD *)&v34[14] = v12;
        *(_WORD *)&v34[18] = 2080;
        *(void *)&v34[20] = v27;
        _os_log_error_impl(&dword_1BB0CE000, v18, OS_LOG_TYPE_ERROR, "%s: error %d uninitalizing %s", v34, 0x1Cu);
      }
      goto LABEL_52;
    }
  }
  CFTypeRef inData = v15;
  if (!*(void *)v7)
  {
    uint64_t v12 = 4294900552;
    goto LABEL_49;
  }
  uint64_t v12 = AudioUnitSetProperty(*(AudioUnit *)v7, 0, 0, 0, &inData, 8u);
  if (v12)
  {
LABEL_49:
    if (getAUSMV2Log(void)::onceToken != -1) {
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
    }
    uint64_t v18 = (id)getAUSMV2Log(void)::gLog;
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      goto LABEL_52;
    }
    long long v26 = (void *)(v7 + 72);
    if (*(char *)(v7 + 95) < 0) {
      long long v26 = (void *)*v26;
    }
    *(_DWORD *)int v34 = 136315650;
    *(void *)&v34[4] = "loadPreset";
    *(_WORD *)&v34[12] = 1024;
    *(_DWORD *)&v34[14] = v12;
    *(_WORD *)&v34[18] = 2080;
    *(void *)&v34[20] = v26;
    uint64_t v20 = "%s: error %d setting preset on %s";
    goto LABEL_75;
  }
  if (!v17 || (uint64_t v12 = AUSM::AUFXWrapper::initialize((AUSM::AUFXWrapper *)v7, v16), !v12))
  {
    uint64_t v12 = 0;
    goto LABEL_53;
  }
  if (getAUSMV2Log(void)::onceToken != -1) {
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
  }
  uint64_t v18 = (id)getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    uint64_t v19 = (void *)(v7 + 72);
    if (*(char *)(v7 + 95) < 0) {
      uint64_t v19 = (void *)*v19;
    }
    *(_DWORD *)int v34 = 136315650;
    *(void *)&v34[4] = "loadPreset";
    *(_WORD *)&v34[12] = 1024;
    *(_DWORD *)&v34[14] = v12;
    *(_WORD *)&v34[18] = 2080;
    *(void *)&v34[20] = v19;
    uint64_t v20 = "%s: error %d initalizing %s; processing disabled";
LABEL_75:
    _os_log_error_impl(&dword_1BB0CE000, v18, OS_LOG_TYPE_ERROR, v20, v34, 0x1Cu);
  }
LABEL_52:

LABEL_53:
  CFRelease(v15);
LABEL_54:
  if (cf) {
    CFRelease(cf);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (string) {
    CFRelease(string);
  }
  return v12;
}

void sub_1BB3C0334(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,const void *a25,uint64_t a26,uint64_t a27,uint64_t a28)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  applesauce::CF::StringRef::~StringRef(&a25);
  _Unwind_Resume(a1);
}

void *applesauce::CF::DictionaryRef::operator->(void *result)
{
  if (!*result)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  return result;
}

void sub_1BB3C0430(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void applesauce::CF::details::find_at_key_or_optional<applesauce::CF::DictionaryRef,__CFString const*&>(unsigned char *a1, CFDictionaryRef theDict, const void *a3)
{
  BOOL v4 = applesauce::CF::details::at_key<__CFString const*&>(theDict, a3);
  if (!v4) {
    goto LABEL_5;
  }
  int v5 = v4;
  CFRetain(v4);
  CFTypeID v6 = CFGetTypeID(v5);
  if (v6 != CFDictionaryGetTypeID())
  {
    CFRelease(v5);
LABEL_5:
    char v7 = 0;
    *a1 = 0;
    goto LABEL_6;
  }
  *(void *)a1 = v5;
  char v7 = 1;
LABEL_6:
  a1[8] = v7;
}

const void *applesauce::CF::details::at_key<__CFString const*&>(CFDictionaryRef theDict, const void *a2)
{
  uint64_t result = 0;
  if (theDict)
  {
    if (a2) {
      return CFDictionaryGetValue(theDict, a2);
    }
  }
  return result;
}

uint64_t AUSM::AUFXWrapper::uninitialize(OpaqueAudioComponentInstance **this)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unsigned int v2 = *this;
  if (!v2) {
    return 4294900552;
  }
  uint64_t v3 = AudioUnitUninitialize(v2);
  *((unsigned char *)this + 124) = 0;
  if (v3)
  {
    if (getAUSMV2Log(void)::onceToken != -1) {
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
    }
    BOOL v4 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      CFTypeID v6 = this + 9;
      if (*((char *)this + 95) < 0) {
        CFTypeID v6 = (void *)*v6;
      }
      int v7 = 136315650;
      CFStringRef v8 = "uninitialize";
      __int16 v9 = 1024;
      int v10 = v3;
      __int16 v11 = 2080;
      uint64_t v12 = v6;
      _os_log_error_impl(&dword_1BB0CE000, v4, OS_LOG_TYPE_ERROR, "%s: error %d uninitializing %s", (uint8_t *)&v7, 0x1Cu);
    }
  }
  return v3;
}

uint64_t AUSM::AUFXWrapper::initialize(AUSM::AUFXWrapper *this, int a2)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  uint64_t Property = 4294900552;
  BOOL v4 = *(OpaqueAudioComponentInstance **)this;
  if (v4)
  {
    int inData = a2;
    uint64_t v6 = AudioUnitSetProperty(v4, 0xEu, 0, 0, &inData, 4u);
    if (v6)
    {
      if (getAUSMV2Log(void)::onceToken != -1) {
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
      }
      int v7 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        int v17 = (void *)((char *)this + 72);
        if (*((char *)this + 95) < 0) {
          int v17 = (void *)*v17;
        }
        int outData = 136315906;
        CFTypeRef v32 = "initialize";
        __int16 v33 = 1024;
        *(_DWORD *)int v34 = v6;
        *(_WORD *)&v34[4] = 1024;
        *(_DWORD *)&v34[6] = inData;
        LOWORD(v35[0]) = 2080;
        *(void *)((char *)v35 + 2) = v17;
        _os_log_error_impl(&dword_1BB0CE000, v7, OS_LOG_TYPE_ERROR, "%s: error %d setting the maximum frames per slice = %u for %s", (uint8_t *)&outData, 0x22u);
      }
LABEL_11:

      *((unsigned char *)this + 124) = 0;
      return v6;
    }
    uint64_t v6 = AudioUnitInitialize(*(AudioUnit *)this);
    if (v6)
    {
      if (getAUSMV2Log(void)::onceToken != -1) {
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
      }
      int v7 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        uint64_t v18 = (void *)((char *)this + 72);
        if (*((char *)this + 95) < 0) {
          uint64_t v18 = (void *)*v18;
        }
        int outData = 136315394;
        CFTypeRef v32 = "initialize";
        __int16 v33 = 2080;
        *(void *)int v34 = v18;
        _os_log_error_impl(&dword_1BB0CE000, v7, OS_LOG_TYPE_ERROR, "%s: error initializing %s", (uint8_t *)&outData, 0x16u);
      }
      goto LABEL_11;
    }
    if (*((_DWORD *)this + 32) != 2)
    {
LABEL_39:
      if (getAUSMV2Log(void)::onceToken != -1) {
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
      }
      uint64_t v21 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
      {
        uint64_t v22 = (void *)((char *)this + 72);
        if (*((char *)this + 95) < 0) {
          uint64_t v22 = (void *)*v22;
        }
        int outData = 136315394;
        CFTypeRef v32 = "initialize";
        __int16 v33 = 2080;
        *(void *)int v34 = v22;
        _os_log_impl(&dword_1BB0CE000, v21, OS_LOG_TYPE_INFO, "%s: initialized %s", (uint8_t *)&outData, 0x16u);
      }

      uint64_t v6 = 0;
      *((unsigned char *)this + 124) = 1;
      return v6;
    }
    UInt32 ioDataSize = 40;
    if (!*(void *)this
      || (uint64_t Property = AudioUnitGetProperty(*(AudioUnit *)this, 8u, 1u, 0, &outData, &ioDataSize), Property)
      || ioDataSize != 40)
    {
      if (getAUSMV2Log(void)::onceToken != -1) {
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
      }
      int v16 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        CFTypeRef v23 = (void *)((char *)this + 72);
        if (*((char *)this + 95) < 0) {
          CFTypeRef v23 = (void *)*v23;
        }
        *(_DWORD *)double __x = 136315650;
        *(void *)&__x[4] = "initialize";
        __int16 v27 = 1024;
        int v28 = Property;
        __int16 v29 = 2080;
        CFTypeRef v30 = v23;
        _os_log_error_impl(&dword_1BB0CE000, v16, OS_LOG_TYPE_ERROR, "%s: error %d getting input stream format of %s", __x, 0x1Cu);
      }

      *((unsigned char *)this + 124) = 0;
      return Property;
    }
    char v9 = v33;
    unsigned int v11 = v35[0];
    unint64_t v10 = v35[1];
    *((_DWORD *)this + 53) = v35[1];
    std::vector<float>::resize((uint64_t)this + 136, (v10 * a2));
    uint64_t v12 = (_DWORD *)*((void *)this + 20);
    uint64_t v13 = *((void *)this + 21);
    unint64_t v14 = (16 * v10) | 8;
    __x[0] = 0;
    unint64_t v15 = v13 - (void)v12;
    if (v14 <= v15)
    {
      if (v14 < v15) {
        *((void *)this + 21) = (char *)v12 + v14;
      }
    }
    else
    {
      std::vector<char>::__append((std::vector<char> *)((char *)this + 160), v14 - v15, __x);
      uint64_t v12 = (_DWORD *)*((void *)this + 20);
    }
    _DWORD *v12 = v10;
    *(void *)double __x = 0;
    std::vector<float *>::assign((char **)this + 23, v10, __x);
    if (!v11) {
      goto LABEL_35;
    }
    if ((v9 & 0x20) != 0)
    {
      unsigned int v19 = 1;
    }
    else
    {
      unsigned int v19 = v10;
      if (!v10)
      {
LABEL_35:
        int v20 = 0;
LABEL_38:
        AUSM::ABLBuffer::setupBufferList((AUSM::AUFXWrapper *)((char *)this + 136), v10, (v9 & 0x20) == 0, a2, v20);
        goto LABEL_39;
      }
    }
    int v20 = v11 / v19;
    goto LABEL_38;
  }
  return Property;
}

char *std::vector<float *>::assign(char **a1, unint64_t a2, void *a3)
{
  uint64_t v6 = (uint64_t)a1[2];
  uint64_t result = *a1;
  if (a2 <= (v6 - (uint64_t)result) >> 3)
  {
    unint64_t v13 = (a1[1] - result) >> 3;
    if (v13 >= a2) {
      uint64_t v14 = a2;
    }
    else {
      uint64_t v14 = (a1[1] - result) >> 3;
    }
    for (; v14; --v14)
    {
      *(void *)uint64_t result = *a3;
      result += 8;
    }
    if (a2 <= v13)
    {
      a1[1] = &(*a1)[8 * a2];
    }
    else
    {
      unint64_t v15 = a1[1];
      int v16 = &v15[8 * (a2 - v13)];
      uint64_t v17 = 8 * a2 - 8 * v13;
      do
      {
        *(void *)unint64_t v15 = *a3;
        v15 += 8;
        v17 -= 8;
      }
      while (v17);
      a1[1] = v16;
    }
  }
  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      uint64_t v6 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    uint64_t v8 = v6 >> 2;
    if (v6 >> 2 <= a2) {
      uint64_t v8 = a2;
    }
    if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v9 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v9 = v8;
    }
    uint64_t result = std::vector<std::tuple<unsigned int,float>>::__vallocate[abi:ne180100](a1, v9);
    unint64_t v10 = a1[1];
    unsigned int v11 = &v10[8 * a2];
    uint64_t v12 = 8 * a2;
    do
    {
      *(void *)unint64_t v10 = *a3;
      v10 += 8;
      v12 -= 8;
    }
    while (v12);
    a1[1] = v11;
  }
  return result;
}

unsigned int *AUSM::ABLBuffer::setupBufferList(AUSM::ABLBuffer *this, unsigned int a2, int a3, int a4, int a5)
{
  *((_DWORD *)this + 18) = a5;
  int v7 = a5 * a4;
  if (a3)
  {
    uint64_t result = (unsigned int *)*((void *)this + 3);
    *uint64_t result = 1;
    *((void *)result + 2) = *(void *)this;
    result[2] = a2;
    result[3] = v7;
  }
  else
  {
    if (*((_DWORD *)this + 19) >= a2) {
      unsigned int v9 = a2;
    }
    else {
      unsigned int v9 = *((_DWORD *)this + 19);
    }
    uint64_t result = (unsigned int *)*((void *)this + 3);
    *uint64_t result = v9;
    if (v9)
    {
      unsigned int v10 = 0;
      unint64_t v11 = 0;
      uint64_t v12 = *(void *)this;
      uint64_t v13 = 16 * v9;
      do
      {
        uint64_t v14 = (int *)&result[v11 / 4];
        *((void *)v14 + 2) = v12 + v10;
        v14[2] = 1;
        v14[3] = v7;
        v11 += 16;
        v10 += v7;
      }
      while (v13 != v11);
    }
  }
  int64_t v15 = *((void *)this + 7) - *((void *)this + 6);
  if (v15 >= 1)
  {
    bzero(*((void **)this + 6), v15);
    uint64_t result = (unsigned int *)*((void *)this + 3);
  }
  if (a5 == 4 && result[2] == 1)
  {
    int v16 = *result;
    uint64_t v17 = *((void *)this + 6);
    if (*result >= ((unint64_t)(*((void *)this + 7) - v17) >> 3)) {
      int v16 = (unint64_t)(*((void *)this + 7) - v17) >> 3;
    }
    if (v16)
    {
      unint64_t v18 = 0;
      uint64_t v19 = 4;
      do
      {
        *(void *)(v17 + 8 * v18++) = *(void *)&result[v19];
        uint64_t result = (unsigned int *)*((void *)this + 3);
        LODWORD(v20) = *result;
        uint64_t v17 = *((void *)this + 6);
        unint64_t v21 = (unint64_t)(*((void *)this + 7) - v17) >> 3;
        if (*result >= v21) {
          unint64_t v20 = v21;
        }
        else {
          unint64_t v20 = v20;
        }
        v19 += 4;
      }
      while (v18 < v20);
    }
  }
  return result;
}

void ___ZN16AUSpatialMixerV220InitializeDynamicXTCEN10applesauce2CF6URLRefE_block_invoke(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 32);
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)(v1 + 2632));
  if (v2)
  {
    if (getAUSMV2Log(void)::onceToken != -1) {
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
    }
    uint64_t v3 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      BOOL v4 = (void *)(v1 + 3368);
      if (*(char *)(v1 + 3391) < 0) {
        BOOL v4 = (void *)*v4;
      }
      int v5 = 136315394;
      uint64_t v6 = v4;
      __int16 v7 = 2080;
      uint64_t v8 = "InitializeDynamicXTC_block_invoke";
      _os_log_debug_impl(&dword_1BB0CE000, v3, OS_LOG_TYPE_DEBUG, "[%s|%s] update dropped", (uint8_t *)&v5, 0x16u);
    }
  }
  else
  {
    std::unique_ptr<AUSpatialMixerV2DynamicXTCFilter>::reset[abi:ne180100]((uint64_t *)(v1 + 8936), 0);
  }
}

void ___ZN16AUSpatialMixerV220InitializeDynamicXTCEN10applesauce2CF6URLRefE_block_invoke_163(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 32);
  if (getAUSMV2Log(void)::onceToken != -1) {
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
  }
  unsigned __int8 v2 = (id)getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v6 = (void *)(v1 + 3368);
    if (*(char *)(v1 + 3391) < 0) {
      uint64_t v6 = (void *)*v6;
    }
    buf[0] = 136315394;
    *(void *)&buf[1] = v6;
    __int16 v8 = 2080;
    uint64_t v9 = "InitializeDynamicXTC_block_invoke";
    _os_log_debug_impl(&dword_1BB0CE000, v2, OS_LOG_TYPE_DEBUG, "[%s|%s] dispatched update for dynamic XTC filter generation:", (uint8_t *)buf, 0x16u);
  }

  unsigned __int8 v3 = atomic_load((unsigned __int8 *)(v1 + 2632));
  if ((v3 & 1) == 0)
  {
    atomic_load((unsigned __int8 *)(v1 + 3520));
    ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v1 + 128), 0);
    operator new();
  }
  if (getAUSMV2Log(void)::onceToken != -1) {
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
  }
  BOOL v4 = (id)getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    int v5 = (void *)(v1 + 3368);
    if (*(char *)(v1 + 3391) < 0) {
      int v5 = (void *)*v5;
    }
    buf[0] = 136315394;
    *(void *)&buf[1] = v5;
    __int16 v8 = 2080;
    uint64_t v9 = "InitializeDynamicXTC_block_invoke";
    _os_log_debug_impl(&dword_1BB0CE000, v4, OS_LOG_TYPE_DEBUG, "[%s|%s] update dropped", (uint8_t *)buf, 0x16u);
  }
}

void sub_1BB3C2100(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, const void *a13, MoorePenrose *a14, void **a15, VBAP **a16, void **a17, void **a18, CFTypeRef a19, void **a20,void **a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,CFTypeRef cf,void *__p,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,CFTypeRef a32,uint64_t a33,uint64_t a34,uint64_t a35,CFTypeRef a36,CFTypeRef a37,uint64_t a38,uint64_t a39,CFTypeRef a40,CFTypeRef a41,void *a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,CFTypeRef a49,uint64_t a50,uint64_t a51,CFTypeRef a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,CFTypeRef a57)
{
  if (cf) {
    CFRelease(cf);
  }
  if (a40) {
    CFRelease(a40);
  }
  uint64_t v59 = *(const void **)(v57 - 160);
  if (v59) {
    CFRelease(v59);
  }
  if (a37) {
    CFRelease(a37);
  }
  if (a57) {
    CFRelease(a57);
  }
  if (a52) {
    CFRelease(a52);
  }
  if (a49) {
    CFRelease(a49);
  }
  if (a41) {
    CFRelease(a41);
  }
  CFRelease(a19);
  if (*(char *)(a23 + 1031) < 0) {
    operator delete(*a18);
  }
  if (*(char *)(a23 + 1007) < 0) {
    operator delete(*a21);
  }
  std::unique_ptr<VBAP>::reset[abi:ne180100](a16, 0);
  uint64_t v60 = *(void *)(a23 + 960);
  *(void *)(a23 + 960) = 0;
  if (v60) {
    (*(void (**)(void))(a23 + 968))();
  }
  uint64_t v61 = *(void *)(a23 + 944);
  *(void *)(a23 + 944) = 0;
  if (v61) {
    (*(void (**)(void))(a23 + 952))();
  }
  float v62 = *(const void **)(a23 + 936);
  if (v62) {
    CFRelease(v62);
  }
  float v63 = *a17;
  if (*a17)
  {
    *(void *)(a23 + 920) = v63;
    operator delete(v63);
  }
  unsigned int v64 = *a20;
  if (*a20)
  {
    *(void *)(a23 + 896) = v64;
    operator delete(v64);
  }
  unsigned int v65 = *a15;
  if (*a15)
  {
    *(void *)(a23 + 872) = v65;
    operator delete(v65);
  }
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a37);
  unsigned int v66 = *(std::__shared_weak_count **)(a23 + 832);
  if (v66) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v66);
  }
  a37 = a13;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a37);
  unsigned int v67 = *(std::__shared_weak_count **)(a23 + 792);
  if (v67) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v67);
  }
  uint64_t v68 = *(std::__shared_weak_count **)(a23 + 776);
  if (v68) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v68);
  }
  DSPSplitComplex v69 = *(void **)(a23 + 744);
  if (v69)
  {
    *(void *)(a23 + 752) = v69;
    operator delete(v69);
  }
  unint64_t v70 = *(void **)(a23 + 704);
  if (v70)
  {
    *(void *)(a23 + 712) = v70;
    operator delete(v70);
  }
  int v71 = *(void **)(a23 + 664);
  if (v71)
  {
    *(void *)(a23 + 672) = v71;
    operator delete(v71);
  }
  int v72 = *(void **)(a23 + 624);
  if (v72)
  {
    *(void *)(a23 + 632) = v72;
    operator delete(v72);
  }
  MoorePenrose::~MoorePenrose(a14);
  MEMORY[0x1C185D370](a23, 0x10F2C40D46768E9);
  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_40c27_ZTSN2IR16IRDataAttributesE192c28_ZTSN10applesauce2CF6URLRefE(uint64_t a1)
{
  unsigned __int8 v2 = *(const void **)(a1 + 192);
  if (v2) {
    CFRelease(v2);
  }

  IR::IRDataAttributes::~IRDataAttributes((IR::IRDataAttributes *)(a1 + 40));
}

uint64_t __copy_helper_block_ea8_40c27_ZTSN2IR16IRDataAttributesE192c28_ZTSN10applesauce2CF6URLRefE(uint64_t a1, uint64_t a2)
{
  uint64_t result = IR::IRDataAttributes::IRDataAttributes(a1 + 40, a2 + 40);
  int v5 = *(const void **)(a2 + 192);
  if (v5) {
    uint64_t result = (uint64_t)CFRetain(v5);
  }
  *(void *)(a1 + 192) = v5;
  return result;
}

uint64_t *std::unique_ptr<AUSpatialMixerV2DynamicXTCFilter>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  *uint64_t result = a2;
  if (v2)
  {
    if (*(char *)(v2 + 1031) < 0) {
      operator delete(*(void **)(v2 + 1008));
    }
    if (*(char *)(v2 + 1007) < 0) {
      operator delete(*(void **)(v2 + 984));
    }
    std::unique_ptr<VBAP>::reset[abi:ne180100]((VBAP **)(v2 + 976), 0);
    uint64_t v3 = *(void *)(v2 + 960);
    *(void *)(v2 + 960) = 0;
    if (v3) {
      (*(void (**)(void))(v2 + 968))();
    }
    uint64_t v4 = *(void *)(v2 + 944);
    *(void *)(v2 + 944) = 0;
    if (v4) {
      (*(void (**)(void))(v2 + 952))();
    }
    int v5 = *(const void **)(v2 + 936);
    if (v5) {
      CFRelease(v5);
    }
    uint64_t v6 = *(void **)(v2 + 912);
    if (v6)
    {
      *(void *)(v2 + 920) = v6;
      operator delete(v6);
    }
    __int16 v7 = *(void **)(v2 + 888);
    if (v7)
    {
      *(void *)(v2 + 896) = v7;
      operator delete(v7);
    }
    __int16 v8 = *(void **)(v2 + 864);
    if (v8)
    {
      *(void *)(v2 + 872) = v8;
      operator delete(v8);
    }
    int v16 = (void **)(v2 + 840);
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v16);
    uint64_t v9 = *(std::__shared_weak_count **)(v2 + 832);
    if (v9) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v9);
    }
    int v16 = (void **)(v2 + 800);
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v16);
    uint64_t v10 = *(std::__shared_weak_count **)(v2 + 792);
    if (v10) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v10);
    }
    unint64_t v11 = *(std::__shared_weak_count **)(v2 + 776);
    if (v11) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v11);
    }
    uint64_t v12 = *(void **)(v2 + 744);
    if (v12)
    {
      *(void *)(v2 + 752) = v12;
      operator delete(v12);
    }
    uint64_t v13 = *(void **)(v2 + 704);
    if (v13)
    {
      *(void *)(v2 + 712) = v13;
      operator delete(v13);
    }
    uint64_t v14 = *(void **)(v2 + 664);
    if (v14)
    {
      *(void *)(v2 + 672) = v14;
      operator delete(v14);
    }
    int64_t v15 = *(void **)(v2 + 624);
    if (v15)
    {
      *(void *)(v2 + 632) = v15;
      operator delete(v15);
    }
    MoorePenrose::~MoorePenrose((MoorePenrose *)(v2 + 64));
    JUMPOUT(0x1C185D370);
  }
  return result;
}

float applesauce::CF::at_or<float,char const(&)[12]>(const __CFDictionary *a1, uint64_t a2)
{
  CFNumberRef v3 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[12]>(a1, "SpeakerSpan");
  if (!v3) {
    return *(float *)a2;
  }
  uint64_t v4 = applesauce::CF::convert_as<float,0>(v3);
  float result = *(float *)&v4;
  if ((v4 & 0xFF00000000) == 0) {
    return *(float *)a2;
  }
  return result;
}

float applesauce::CF::at_or<float,char const(&)[15]>(const __CFDictionary *a1, uint64_t a2)
{
  CFNumberRef v3 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[15]>(a1, "Regularization");
  if (!v3) {
    return *(float *)a2;
  }
  uint64_t v4 = applesauce::CF::convert_as<float,0>(v3);
  float result = *(float *)&v4;
  if ((v4 & 0xFF00000000) == 0) {
    return *(float *)a2;
  }
  return result;
}

float applesauce::CF::at_or<float,char const(&)[11]>(const __CFDictionary *a1, char *a2, uint64_t a3)
{
  CFNumberRef v4 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[11]>(a1, a2);
  if (!v4) {
    return *(float *)a3;
  }
  uint64_t v5 = applesauce::CF::convert_as<float,0>(v4);
  float result = *(float *)&v5;
  if ((v5 & 0xFF00000000) == 0) {
    return *(float *)a3;
  }
  return result;
}

float applesauce::CF::at_or<float,char const(&)[21]>(const __CFDictionary *a1, uint64_t a2)
{
  CFNumberRef v3 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[21]>(a1, "PostTimbralFrequency");
  if (!v3) {
    return *(float *)a2;
  }
  uint64_t v4 = applesauce::CF::convert_as<float,0>(v3);
  float result = *(float *)&v4;
  if ((v4 & 0xFF00000000) == 0) {
    return *(float *)a2;
  }
  return result;
}

float applesauce::CF::at_or<float,char const(&)[17]>(const __CFDictionary *a1, char *a2, uint64_t a3)
{
  CFNumberRef v4 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[17]>(a1, a2);
  if (!v4) {
    return *(float *)a3;
  }
  uint64_t v5 = applesauce::CF::convert_as<float,0>(v4);
  float result = *(float *)&v5;
  if ((v5 & 0xFF00000000) == 0) {
    return *(float *)a3;
  }
  return result;
}

float applesauce::CF::at_or<float,char const(&)[10]>(const __CFDictionary *a1, uint64_t a2)
{
  CFNumberRef v3 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[10]>(a1, "Crossover");
  if (!v3) {
    return *(float *)a2;
  }
  uint64_t v4 = applesauce::CF::convert_as<float,0>(v3);
  float result = *(float *)&v4;
  if ((v4 & 0xFF00000000) == 0) {
    return *(float *)a2;
  }
  return result;
}

float applesauce::CF::at_or<float,char const(&)[9]>(const __CFDictionary *a1, uint64_t a2)
{
  CFNumberRef v3 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[9]>(a1, "PostGain");
  if (!v3) {
    return *(float *)a2;
  }
  uint64_t v4 = applesauce::CF::convert_as<float,0>(v3);
  float result = *(float *)&v4;
  if ((v4 & 0xFF00000000) == 0) {
    return *(float *)a2;
  }
  return result;
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[13],int &>(applesauce::CF::TypeRef *a1, int *a2)
{
  applesauce::CF::TypeRef::TypeRef(a1, "FilterLength");
  int valuePtr = *a2;
  CFNumberRef v4 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  *((void *)a1 + 1) = v4;
  if (!v4)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1BB3C2AE4(_Unwind_Exception *a1)
{
  CFNumberRef v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[12],float>(applesauce::CF::TypeRef *a1, int *a2)
{
  applesauce::CF::TypeRef::TypeRef(a1, "SpeakerSpan");
  int valuePtr = *a2;
  CFNumberRef v4 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((void *)a1 + 1) = v4;
  if (!v4)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1BB3C2BC0(_Unwind_Exception *a1)
{
  CFNumberRef v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[15],float>(applesauce::CF::TypeRef *a1, int *a2)
{
  applesauce::CF::TypeRef::TypeRef(a1, "Regularization");
  int valuePtr = *a2;
  CFNumberRef v4 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((void *)a1 + 1) = v4;
  if (!v4)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1BB3C2C9C(_Unwind_Exception *a1)
{
  CFNumberRef v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[11],float>(applesauce::CF::TypeRef *a1, int *a2)
{
  applesauce::CF::TypeRef::TypeRef(a1, "Constraint");
  int valuePtr = *a2;
  CFNumberRef v4 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((void *)a1 + 1) = v4;
  if (!v4)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1BB3C2D78(_Unwind_Exception *a1)
{
  CFNumberRef v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[21],float>(applesauce::CF::TypeRef *a1, int *a2)
{
  applesauce::CF::TypeRef::TypeRef(a1, "PostTimbralFrequency");
  int valuePtr = *a2;
  CFNumberRef v4 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((void *)a1 + 1) = v4;
  if (!v4)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1BB3C2E54(_Unwind_Exception *a1)
{
  CFNumberRef v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[10],float>(applesauce::CF::TypeRef *a1, int *a2)
{
  applesauce::CF::TypeRef::TypeRef(a1, "Crossover");
  int valuePtr = *a2;
  CFNumberRef v4 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((void *)a1 + 1) = v4;
  if (!v4)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1BB3C2F30(_Unwind_Exception *a1)
{
  CFNumberRef v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[9],float>(applesauce::CF::TypeRef *a1, int *a2)
{
  applesauce::CF::TypeRef::TypeRef(a1, "PostGain");
  int valuePtr = *a2;
  CFNumberRef v4 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((void *)a1 + 1) = v4;
  if (!v4)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1BB3C300C(_Unwind_Exception *a1)
{
  CFNumberRef v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

void applesauce::CF::details::find_at_key_or_optional<applesauce::CF::ArrayRef,__CFString const*&>(unsigned char *a1, CFDictionaryRef theDict, const void *a3)
{
  CFNumberRef v4 = applesauce::CF::details::at_key<__CFString const*&>(theDict, a3);
  if (!v4) {
    goto LABEL_5;
  }
  uint64_t v5 = v4;
  CFRetain(v4);
  CFTypeID v6 = CFGetTypeID(v5);
  if (v6 != CFArrayGetTypeID())
  {
    CFRelease(v5);
LABEL_5:
    char v7 = 0;
    *a1 = 0;
    goto LABEL_6;
  }
  *(void *)a1 = v5;
  char v7 = 1;
LABEL_6:
  a1[8] = v7;
}

const __CFArray *applesauce::CF::ArrayRef_proxy::get_size(const __CFArray *this)
{
  if (this) {
    return (const __CFArray *)CFArrayGetCount(this);
  }
  return this;
}

uint64_t std::pair<AUPreset,applesauce::CF::DictionaryRef>::~pair(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 16);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void std::vector<IR::FixedIntegerDelay>::resize(uint64_t *a1, unint64_t a2, IR::FixedIntegerDelay *a3)
{
  uint64_t v5 = *a1;
  CFTypeID v6 = (IR::FixedIntegerDelay *)a1[1];
  unint64_t v7 = 0x6DB6DB6DB6DB6DB7 * (((uint64_t)v6 - *a1) >> 3);
  unint64_t v8 = a2 - v7;
  if (a2 <= v7)
  {
    if (a2 < v7)
    {
      unint64_t v20 = (IR::FixedIntegerDelay *)(v5 + 56 * a2);
      while (v6 != v20)
      {
        CFTypeID v6 = (IR::FixedIntegerDelay *)((char *)v6 - 56);
        std::__destroy_at[abi:ne180100]<IR::FixedIntegerDelay,0>(v6);
      }
      a1[1] = (uint64_t)v20;
    }
  }
  else
  {
    uint64_t v10 = a1[2];
    if (0x6DB6DB6DB6DB6DB7 * ((v10 - (uint64_t)v6) >> 3) >= v8)
    {
      unint64_t v21 = (void *)((char *)v6 + 56 * v8);
      uint64_t v22 = 56 * a2 - 8 * (((uint64_t)v6 - *a1) >> 3);
      do
      {
        IR::FixedIntegerDelay::FixedIntegerDelay(v6, a3);
        CFTypeID v6 = (IR::FixedIntegerDelay *)((char *)v6 + 56);
        v22 -= 56;
      }
      while (v22);
      a1[1] = (uint64_t)v21;
    }
    else
    {
      if (a2 > 0x492492492492492) {
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      }
      long long v26 = a1 + 2;
      unint64_t v11 = 0x6DB6DB6DB6DB6DB7 * ((v10 - v5) >> 3);
      uint64_t v12 = 2 * v11;
      if (2 * v11 <= a2) {
        uint64_t v12 = a2;
      }
      if (v11 >= 0x249249249249249) {
        unint64_t v13 = 0x492492492492492;
      }
      else {
        unint64_t v13 = v12;
      }
      uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IR::FixedIntegerDelay>>(v13);
      int64_t v15 = (IR::FixedIntegerDelay *)&v14[56 * v7];
      v23[0] = v14;
      v23[1] = v15;
      long long v24 = v15;
      long long v25 = &v14[56 * v16];
      uint64_t v17 = 56 * a2;
      unint64_t v18 = (IR::FixedIntegerDelay *)&v14[56 * a2];
      unint64_t v19 = v17 - 56 * v7;
      do
      {
        IR::FixedIntegerDelay::FixedIntegerDelay(v15, a3);
        int64_t v15 = (IR::FixedIntegerDelay *)((char *)v15 + 56);
        v19 -= 56;
      }
      while (v19);
      long long v24 = v18;
      std::vector<IR::FixedIntegerDelay>::__swap_out_circular_buffer(a1, v23);
      std::__split_buffer<IR::FixedIntegerDelay>::~__split_buffer((uint64_t)v23);
    }
  }
}

void sub_1BB3C3300(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  *(void *)(v12 + 8) = v13;
  _Unwind_Resume(exception_object);
}

void ___ZN16AUSpatialMixerV220UpdateAutoModeReverbEbbi_block_invoke(uint64_t a1)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 32);
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)(v1 + 2632));
  if (v2)
  {
    if (getAUSMV2Log(void)::onceToken != -1) {
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
    }
    uint64_t v12 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      unint64_t v20 = (void *)(v1 + 3368);
      if (*(char *)(v1 + 3391) < 0) {
        unint64_t v20 = (void *)*v20;
      }
      *(_DWORD *)AudioTimeStamp buf = 136315394;
      *(void *)&uint8_t buf[4] = v20;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "UpdateAutoModeReverb_block_invoke";
      _os_log_debug_impl(&dword_1BB0CE000, v12, OS_LOG_TYPE_DEBUG, "[%s|%s] update dropped", buf, 0x16u);
    }

    return;
  }
  int v4 = *(_DWORD *)(a1 + 40);
  if (getAUSMV2Log(void)::onceToken != -1) {
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
  }
  uint64_t v5 = (id)getAUSMV2Log(void)::gLog;
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG);
  if (v4 < 0)
  {
    if (!v6) {
      goto LABEL_14;
    }
    float v31 = (void *)(v1 + 3368);
    if (*(char *)(v1 + 3391) < 0) {
      float v31 = (void *)*v31;
    }
    *(_DWORD *)AudioTimeStamp buf = 136315394;
    *(void *)&uint8_t buf[4] = v31;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "UpdateAutoModeReverb_block_invoke";
    uint64_t v9 = "[%s|%s] dispatching update for all InputElements";
    uint64_t v10 = v5;
    uint32_t v11 = 22;
  }
  else
  {
    if (!v6) {
      goto LABEL_14;
    }
    unint64_t v7 = (void *)(v1 + 3368);
    if (*(char *)(v1 + 3391) < 0) {
      unint64_t v7 = (void *)*v7;
    }
    int v8 = *(_DWORD *)(a1 + 40);
    *(_DWORD *)AudioTimeStamp buf = 136315650;
    *(void *)&uint8_t buf[4] = v7;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "UpdateAutoModeReverb_block_invoke";
    *(_WORD *)&buf[22] = 1024;
    LODWORD(v49) = v8;
    uint64_t v9 = "[%s|%s] dispatching update for InputElement #%d:";
    uint64_t v10 = v5;
    uint32_t v11 = 28;
  }
  _os_log_debug_impl(&dword_1BB0CE000, v10, OS_LOG_TYPE_DEBUG, v9, buf, v11);
LABEL_14:

  int v13 = *(_DWORD *)(a1 + 40);
  unsigned __int8 v14 = atomic_load((unsigned __int8 *)(v1 + 2632));
  if (v14) {
    return;
  }
  if (*(unsigned char *)(a1 + 44))
  {
    BOOL v15 = *(unsigned char *)(a1 + 45) == 0;
    int updated = AUSpatialMixerV2::UpdateAutoModeReverbBus(v1, 1, v13);
    int v17 = updated;
    if (v15)
    {
      if (!updated) {
        goto LABEL_63;
      }
      goto LABEL_22;
    }
  }
  else
  {
    if (!*(unsigned char *)(a1 + 45))
    {
LABEL_63:
      AUSpatialMixerV2::ReconfigureSharedBuffers((AUSpatialMixerV2 *)v1, 0, 0);
      return;
    }
    int v17 = 0;
  }
  if (((AUSpatialMixerV2::UpdateAutoModeReverbBus(v1, 0, v13) | v17) & 1) == 0) {
    goto LABEL_63;
  }
LABEL_22:
  unsigned int v18 = atomic_load((unsigned int *)(v1 + 9012));
  unsigned int v39 = v18;
  if ((v18 & 0x80000000) != 0) {
    goto LABEL_63;
  }
  std::mutex::lock((std::mutex *)(v1 + 7736));
  IR::IRDataAttributes::IRDataAttributes((uint64_t)buf, v1 + 6872);
  std::mutex::unlock((std::mutex *)(v1 + 7736));
  if (*(void *)buf)
  {
    std::mutex::lock((std::mutex *)(v1 + 7736));
    IR::IRDataAttributes::IRDataAttributes((uint64_t)&v43, v1 + 7208);
    std::mutex::unlock((std::mutex *)(v1 + 7736));
    BOOL v19 = v43 != 0;
    if (cf) {
      CFRelease(cf);
    }
    if (v46) {
      CFRelease(v46);
    }
    if (v45) {
      CFRelease(v45);
    }
    if (v43) {
      CFRelease(v43);
    }
  }
  else
  {
    BOOL v19 = 0;
  }
  if (v56) {
    CFRelease(v56);
  }
  if (v54) {
    CFRelease(v54);
  }
  if (v52) {
    CFRelease(v52);
  }
  if (*(void *)buf) {
    CFRelease(*(CFTypeRef *)buf);
  }
  if (!v19) {
    goto LABEL_63;
  }
  AUSM::AppleSauceCFWithMutex<__CFDictionary const*>::load(&v42, v1 + 5264);
  CFTypeRef v43 = (CFTypeRef)(v1 + 3120);
  char v44 = 1;
  std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)(v1 + 3120));
  uint64_t v21 = *(void *)(v1 + 120);
  if (v21) {
    LODWORD(v22) = (*(uint64_t (**)(uint64_t))(*(void *)v21 + 24))(v21);
  }
  else {
    uint64_t v22 = (*(void *)(v1 + 104) - *(void *)(v1 + 96)) >> 3;
  }
  if ((int)v22 <= v13)
  {
    if (getAUSMV2Log(void)::onceToken != -1) {
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
    }
    CFTypeRef v30 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      uint64_t v36 = (void *)(v1 + 3368);
      if (*(char *)(v1 + 3391) < 0) {
        uint64_t v36 = (void *)*v36;
      }
      *(_DWORD *)AudioTimeStamp buf = 136315906;
      *(void *)&uint8_t buf[4] = v36;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "UpdateAutoModeReverbBlock";
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v49) = v13;
      WORD2(v49) = 1024;
      *(_DWORD *)((char *)&v49 + 6) = v22;
      _os_log_error_impl(&dword_1BB0CE000, v30, OS_LOG_TYPE_ERROR, "[%s|%s] update called for input #%d, number of inputs = %u", buf, 0x22u);
    }
  }
  else
  {
    int v23 = v13 + 1;
    if (v13 == -1) {
      int v24 = 0;
    }
    else {
      int v24 = v13;
    }
    if (v13 == -1) {
      int v23 = v22;
    }
    int v38 = v23;
    std::mutex::lock((std::mutex *)(v1 + 7736));
    int v37 = v13;
    IR::IRDataAttributes::IRDataAttributes((uint64_t)buf, v1 + 7544);
    std::mutex::unlock((std::mutex *)(v1 + 7736));
    long long v25 = (char *)operator new(0xB0uLL);
    *((void *)v25 + 1) = 0;
    *((void *)v25 + 2) = 0;
    *(void *)long long v25 = &unk_1F14AD2A8;
    *((void *)v25 + 3) = *(void *)buf;
    long long v26 = v49;
    *((_OWORD *)v25 + 2) = *(_OWORD *)&buf[8];
    *((_OWORD *)v25 + 3) = v26;
    *((_OWORD *)v25 + 4) = v50;
    v25[80] = v51;
    CFTypeRef v27 = v54;
    *((void *)v25 + 11) = v52;
    *(void *)AudioTimeStamp buf = 0;
    CFTypeRef v52 = 0;
    *((_OWORD *)v25 + 6) = v53;
    *((void *)v25 + 14) = v27;
    CFTypeRef v54 = 0;
    long long v28 = v55[0];
    *(_OWORD *)(v25 + 129) = *(_OWORD *)((char *)v55 + 9);
    *(_OWORD *)(v25 + 120) = v28;
    *((_DWORD *)v25 + 42) = v58;
    uint64_t v29 = v57;
    *((void *)v25 + 19) = v56;
    *((void *)v25 + 20) = v29;
    if (v24 != v38)
    {
      CFTypeRef v32 = v42;
      do
      {
        v41[0] = (uint64_t)(v25 + 24);
        v41[1] = (uint64_t)v25;
        atomic_fetch_add_explicit((atomic_ullong *volatile)v25 + 1, 1uLL, memory_order_relaxed);
        if (v32) {
          CFRetain(v32);
        }
        CFTypeRef v40 = v32;
        int v33 = IR::SharedIRBuses::reconfigure(v1 + 2104, v39 + v24, v41, &v40);
        if (v32) {
          CFRelease(v32);
        }
        std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v25);
        if (v33)
        {
          if (getAUSMV2Log(void)::onceToken != -1) {
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
          }
          int v34 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
          {
            uint64_t v35 = v1 + 3368;
            if (*(char *)(v1 + 3391) < 0) {
              uint64_t v35 = *(void *)(v1 + 3368);
            }
            *(_DWORD *)AudioTimeStamp buf = 136315906;
            *(void *)&uint8_t buf[4] = v35;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = "UpdateAutoModeReverbBlock";
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v49) = v24;
            WORD2(v49) = 1024;
            *(_DWORD *)((char *)&v49 + 6) = v33;
            _os_log_error_impl(&dword_1BB0CE000, v34, OS_LOG_TYPE_ERROR, "[%s|%s] Could not reconfigure auto mode combined late reverb for input #%u: error %d", buf, 0x22u);
          }
        }
        ++v24;
      }
      while (v38 != v24);
    }
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v25);
    int v13 = v37;
  }
  std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&v43);
  if (v42) {
    CFRelease(v42);
  }
  if ((int)v22 > v13) {
    goto LABEL_63;
  }
}

void sub_1BB3C3A14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, const void *a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
}

uint64_t AUSpatialMixerV2::UpdateAutoModeReverbBus(uint64_t a1, int a2, int a3)
{
  uint64_t v187 = *MEMORY[0x1E4F143B8];
  BOOL v6 = (char *)(a1 + 6207);
  if (getAUSMV2Log(void)::onceToken != -1) {
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
  }
  unint64_t v7 = getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEBUG))
  {
    unsigned int v64 = (void *)(a1 + 6184);
    if (*v6 < 0) {
      unsigned int v64 = (void *)*v64;
    }
    unsigned int v65 = "scene";
    *(_DWORD *)cf1 = 136315650;
    *(void *)&cf1[4] = v64;
    *(_WORD *)&cf1[12] = 2080;
    *(void *)&cf1[14] = "updateReverbAttributes";
    if (!a2) {
      unsigned int v65 = "post-processing";
    }
    *(_WORD *)&cf1[22] = 2080;
    *(void *)&long long v152 = v65;
    _os_log_debug_impl(&dword_1BB0CE000, v7, OS_LOG_TYPE_DEBUG, "[%s|%s] Updating attributes for %s reverb", cf1, 0x20u);
  }
  int v146 = a2;
  AUSM::IRManager::ReverbBusConfig::ReverbBusConfig((AUSM::IRManager::ReverbBusConfig *)cf1);
  int v8 = (uint64_t *)(a1 + 6176);
  int v145 = a3;
  uint64_t v144 = v6;
  if (!a2 && v6[489])
  {
    std::mutex::lock((std::mutex *)(a1 + 7736));
    if (!v6[489] || (IR::IRDataAttributes::operator=((uint64_t)cf1, a1 + 6544), !v6[489])) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    IR::IRDataAttributes::operator=((uint64_t)&cf2, a1 + 6544);
    std::mutex::unlock((std::mutex *)(a1 + 7736));
    goto LABEL_49;
  }
  uint64_t v9 = 72;
  if (!a2) {
    uint64_t v9 = 76;
  }
  atomic_load((unsigned int *)(*(void *)(a1 + 6176) + v9));
  IR::getPresetDataAttributes();
  *(_DWORD *)&v177[8] = *(_DWORD *)(a1 + 6208);
  unsigned int v10 = atomic_load((unsigned int *)(*(void *)(a1 + 6176) + 96));
  *(_DWORD *)&v178[20] = v10;
  IR::IRDataAttributes::operator=((uint64_t)cf1, (uint64_t)v177);
  IR::IRDataAttributes::operator=((uint64_t)&cf2, (uint64_t)v177);
  unsigned int v11 = atomic_load((unsigned int *)(*(void *)(a1 + 6176) + 88));
  unsigned __int8 v12 = atomic_load((unsigned __int8 *)(*(void *)(a1 + 6176) + 160));
  if (v12)
  {
    if (v11 == 1
      || v11 == 2 && (*(unsigned char *)(*v8 + 2548) || (unsigned __int8 v13 = atomic_load((unsigned __int8 *)(*v8 + 2549)), (v13 & 1) != 0)))
    {
      cf1[16] = 0;
    }
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v182) {
    CFRelease(v182);
  }
  if (v180) {
    CFRelease(v180);
  }
  if (*(void *)v177) {
    CFRelease(*(CFTypeRef *)v177);
  }
  uint64_t v14 = *v8;
  if (a2)
  {
    AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(v177, v14 + 680);
    BOOL v15 = *(const void **)v177;
    if (!*(void *)v177)
    {
      uint64_t v16 = *v8 + 392;
LABEL_35:
      AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(&v150, v16);
      CFTypeRef v20 = v150;
      if (v150)
      {
        uint64_t v21 = *(const void **)cf1;
        *(void *)cf1 = v150;
        CFRetain(v150);
        if (v21) {
          CFRelease(v21);
        }
        CFRelease(v20);
      }
      if (a2) {
        uint64_t v22 = *v8 + 536;
      }
      else {
        uint64_t v22 = *v8 + 608;
      }
      AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(&v150, v22);
      CFTypeRef v23 = v150;
      if (v150)
      {
        CFTypeRef v24 = cf2;
        CFTypeRef cf2 = v150;
        CFRetain(v150);
        if (v24) {
          CFRelease(v24);
        }
        if (!v20)
        {
          long long v25 = *(const void **)cf1;
          *(void *)cf1 = 0;
          if (v25) {
            CFRelease(v25);
          }
        }
        CFRelease(v23);
      }
      else if (v20)
      {
        int v17 = (void *)cf2;
        CFTypeRef cf2 = 0;
        if (v17) {
          CFRelease(v17);
        }
      }
      goto LABEL_49;
    }
  }
  else
  {
    AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(v177, v14 + 752);
    BOOL v15 = *(const void **)v177;
    if (!*(void *)v177)
    {
      uint64_t v16 = *v8 + 464;
      goto LABEL_35;
    }
  }
  unsigned int v18 = *(const void **)cf1;
  *(void *)cf1 = v15;
  CFRetain(v15);
  if (v18) {
    CFRelease(v18);
  }
  CFTypeRef v19 = cf2;
  CFTypeRef cf2 = v15;
  CFRetain(v15);
  if (v19) {
    CFRelease(v19);
  }
  CFRelease(v15);
LABEL_49:
  if (*(void *)cf1)
  {
    long long v26 = (IR::IRDataLoader *)IR::IRDataLoader::instance((IR::IRDataLoader *)v17);
    Originalint AudioChannelLayoutTag = IR::IRDataLoader::getOriginalAudioChannelLayoutTag(v26, (const IR::IRDataAttributes *)cf1);
    BOOL IsSupportedHOA = ChannelLayoutTagIsSupportedHOA(OriginalAudioChannelLayoutTag);
  }
  else
  {
    BOOL IsSupportedHOA = 0;
  }
  v162[12] = IsSupportedHOA;
  if (cf2)
  {
    uint64_t v29 = (IR::IRDataLoader *)IR::IRDataLoader::instance((IR::IRDataLoader *)IsSupportedHOA);
    int v30 = IR::IRDataLoader::getOriginalAudioChannelLayoutTag(v29, (const IR::IRDataAttributes *)&cf2);
    float v31 = (IR::IRDataLoader *)ChannelLayoutTagIsSupportedHOA(v30);
  }
  else
  {
    float v31 = 0;
  }
  v176[12] = (_BYTE)v31;
  if (!*(void *)cf1) {
    goto LABEL_76;
  }
  CFTypeRef v32 = (IR::IRDataLoader *)IR::IRDataLoader::instance(v31);
  IR::IRDataLoader::getIRDataTypes((uint64_t *)v177, v32, (const IR::IRDataAttributes *)cf1);
  int v33 = *(_DWORD **)v177;
  float v31 = *(IR::IRDataLoader **)&v177[8];
  if (*(void *)&v177[8] != *(void *)v177)
  {
    int v34 = *(_DWORD **)v177;
    while (*v34 != 3)
    {
      if (++v34 == *(_DWORD **)&v177[8])
      {
        int v34 = *(_DWORD **)&v177[8];
        break;
      }
    }
    if (v34 != *(_DWORD **)&v177[8]) {
      LODWORD(v153) = 3;
    }
    while (*v33 != 2)
    {
      if (++v33 == *(_DWORD **)&v177[8])
      {
        int v33 = *(_DWORD **)&v177[8];
        break;
      }
    }
    if (v33 == *(_DWORD **)&v177[8]) {
      goto LABEL_73;
    }
    if (v153 != 3) {
      LODWORD(v153) = 2;
    }
    if (*(void *)cf1 && cf2)
    {
      if (!CFEqual(*(CFTypeRef *)cf1, cf2))
      {
LABEL_73:
        float v31 = *(IR::IRDataLoader **)v177;
        goto LABEL_74;
      }
    }
    else if (*(void *)cf1 | (unint64_t)cf2)
    {
      goto LABEL_73;
    }
    int v169 = 2;
    goto LABEL_73;
  }
LABEL_74:
  if (v31)
  {
    *(void *)&v177[8] = v31;
    operator delete(v31);
  }
LABEL_76:
  if (cf2 && v169 != 2)
  {
    uint64_t v35 = (IR::IRDataLoader *)IR::IRDataLoader::instance(v31);
    IR::IRDataLoader::getIRDataTypes((uint64_t *)v177, v35, (const IR::IRDataAttributes *)&cf2);
    float v31 = *(IR::IRDataLoader **)v177;
    if (*(void *)&v177[8] != *(void *)v177)
    {
      uint64_t v36 = *(_DWORD **)v177;
      while (*v36 != 2)
      {
        if (++v36 == *(_DWORD **)&v177[8])
        {
          uint64_t v36 = *(_DWORD **)&v177[8];
          break;
        }
      }
      if (v36 != *(_DWORD **)&v177[8]) {
        int v169 = 2;
      }
    }
    if (*(void *)v177)
    {
      *(void *)&v177[8] = *(void *)v177;
      operator delete(*(void **)v177);
    }
  }
  CFTypeRef v150 = 0;
  if (!*(void *)cf1)
  {
    CFDictionaryRef v39 = 0;
    FilterCFIndex Length = 0;
    int v42 = 0;
    goto LABEL_105;
  }
  int v37 = (IR::IRDataLoader *)IR::IRDataLoader::instance(v31);
  UserData = (IR::IRDataLoader *)IR::IRDataLoader::getUserData((uint64_t *)v177, v37, (const IR::IRDataAttributes *)cf1);
  CFDictionaryRef v39 = *(const __CFDictionary **)v177;
  CFTypeRef v150 = *(CFTypeRef *)v177;
  if (*(void *)v177)
  {
    *(_DWORD *)char v177 = 0;
    *(_DWORD *)__int16 v162 = applesauce::CF::at_or<unsigned int,char const(&)[14]>(v39, "ModelingDelay", (unsigned int *)v177);
    *(void *)char v177 = @"DiffuseFieldPowerRMS";
    LODWORD(v149) = 1065353216;
    *(_DWORD *)&v162[4] = applesauce::CF::at_or<float,__CFString const*>(v39, (const void **)v177, (uint64_t)&v149);
    *(void *)char v177 = @"CriticalDistance";
    LODWORD(v149) = 1065353216;
    *(_DWORD *)&v162[8] = applesauce::CF::at_or<float,__CFString const*>(v39, (const void **)v177, (uint64_t)&v149);
    if (v153 == 3) {
      goto LABEL_94;
    }
    UserData = applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[15]>(v39, "EarlyLateSplit");
    if (((unint64_t)UserData & 0xFF00000000) != 0)
    {
      float v40 = *(float *)&UserData;
LABEL_97:
      FilterCFIndex Length = llroundf(*(float *)(a1 + 6208) * v40);
      goto LABEL_98;
    }
  }
  else
  {
    *(_DWORD *)__int16 v162 = 0;
    __asm { FMOV            V0.2S, #1.0 }
    *(void *)&v162[4] = _D0;
    if (v153 == 3) {
      goto LABEL_94;
    }
  }
  if (v162[12])
  {
    float v40 = 0.05;
    goto LABEL_97;
  }
LABEL_94:
  int v48 = (IR::IRDataLoader *)IR::IRDataLoader::instance(UserData);
  FilterCFIndex Length = IR::IRDataLoader::getFilterLength(v48, (const IR::IRDataAttributes *)cf1);
LABEL_98:
  if (cf2)
  {
    if (FilterLength >= 0x64) {
      int v42 = 100;
    }
    else {
      int v42 = FilterLength;
    }
    *(void *)&long long v152 = 0;
    *((void *)&v152 + 1) = __PAIR64__(v42, FilterLength);
  }
  else
  {
    int v42 = 0;
  }
  *(_DWORD *)&cf1[12] = 128;
LABEL_105:
  if (getAUSMV2Log(void)::onceToken != -1) {
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
  }
  long long v49 = getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEBUG))
  {
    unsigned int v66 = (void *)(a1 + 6184);
    if (*v144 < 0) {
      unsigned int v66 = (void *)*v66;
    }
    *(_DWORD *)char v177 = 136315650;
    *(void *)&v177[4] = v66;
    *(_WORD *)&v177[12] = 2080;
    *(void *)&v177[14] = "configureIRWindowsAndUserDataParameters";
    *(_WORD *)&v177[22] = 1024;
    *(_DWORD *)unsigned int v178 = FilterLength;
    _os_log_debug_impl(&dword_1BB0CE000, v49, OS_LOG_TYPE_DEBUG, "[%s|%s] Early length = %u", v177, 0x1Cu);
  }
  if (cf2)
  {
    long long v50 = *(IR::IRDataLoader **)cf1;
    if (!*(void *)cf1
      || (long long v50 = (IR::IRDataLoader *)CFEqual(*(CFTypeRef *)cf1, cf2), !v50)
      || v153 != v169)
    {
      char v51 = (IR::IRDataLoader *)IR::IRDataLoader::instance(v50);
      IR::IRDataLoader::getUserData((uint64_t *)v177, v51, (const IR::IRDataAttributes *)&cf2);
      CFDictionaryRef v52 = *(const __CFDictionary **)v177;
      CFTypeRef v150 = *(CFTypeRef *)v177;
      *(void *)char v177 = v39;
      if (v39) {
        CFRelease(v39);
      }
      CFDictionaryRef v39 = v52;
    }
    if (v39)
    {
      *(_DWORD *)char v177 = 0;
      *(_DWORD *)uint64_t v176 = applesauce::CF::at_or<unsigned int,char const(&)[14]>(v39, "ModelingDelay", (unsigned int *)v177);
      CFDictionaryRef v39 = (const __CFDictionary *)v150;
      if (!v150)
      {
        exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Could not construct");
      }
      *(void *)char v177 = @"DiffuseFieldPowerRMS";
      LODWORD(v149) = 1065353216;
      *(_DWORD *)&v176[4] = applesauce::CF::at_or<float,__CFString const*>((const __CFDictionary *)v150, (const void **)v177, (uint64_t)&v149);
      *(void *)char v177 = @"CriticalDistance";
      LODWORD(v149) = 1065353216;
      *(_DWORD *)&v176[8] = applesauce::CF::at_or<float,__CFString const*>(v39, (const void **)v177, (uint64_t)&v149);
    }
    else
    {
      *(_DWORD *)uint64_t v176 = 0;
      *(void *)&v176[4] = 0x3F8000003F800000;
    }
    uint64_t v168 = 0;
    int v167 = v42;
    unsigned int v166 = FilterLength - v42;
    int v164 = 128;
  }
  int v53 = v146;
  if (v39) {
    CFRelease(v39);
  }
  uint64_t v54 = *v8;
  if (v162[12] | v176[12])
  {
    CFTypeRef v150 = 0;
    unsigned int v55 = atomic_load((unsigned int *)(v54 + 88));
    switch(v55)
    {
      case 1u:
        AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(&v149, *v8 + 248);
        if (v149)
        {
          CFTypeRef v62 = v150;
          CFTypeRef v150 = v149;
          CFRetain(v149);
          if (v62) {
            CFRelease(v62);
          }
        }
        else
        {
          IR::getPresetDataAttributes();
          CFTypeRef v68 = v150;
          CFTypeRef v150 = *(CFTypeRef *)v177;
          *(void *)char v177 = v68;
          if (cf) {
            CFRelease(cf);
          }
          if (v182) {
            CFRelease(v182);
          }
          if (v180) {
            CFRelease(v180);
          }
          if (*(void *)v177) {
            CFRelease(*(CFTypeRef *)v177);
          }
        }
        unsigned int v61 = atomic_load((unsigned int *)(*v8 + 2552));
        if (v149) {
          CFRelease(v149);
        }
        break;
      case 2u:
        AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(&v149, *v8 + 320);
        CFTypeRef v59 = v149;
        if (v149)
        {
          CFTypeRef v60 = v150;
          CFTypeRef v150 = v149;
          CFRetain(v149);
          if (v60) {
            CFRelease(v60);
          }
          CFRelease(v59);
        }
        else
        {
          if (!*(unsigned char *)(*v8 + 2548))
          {
            int v58 = 6619138;
            CFTypeRef v139 = v150;
            CFTypeRef v150 = 0;
            if (v139) {
              CFRelease(v139);
            }
            goto LABEL_132;
          }
          IR::getPresetDataAttributes();
          CFTypeRef v67 = v150;
          CFTypeRef v150 = *(CFTypeRef *)v177;
          *(void *)char v177 = v67;
          if (cf) {
            CFRelease(cf);
          }
          if (v182) {
            CFRelease(v182);
          }
          if (v180) {
            CFRelease(v180);
          }
          if (*(void *)v177) {
            CFRelease(*(CFTypeRef *)v177);
          }
        }
        int v58 = 0;
LABEL_132:
        unsigned int v61 = 0;
        goto LABEL_174;
      case 3u:
        CFTypeRef v56 = (IR::IRDataLoader *)v150;
        CFTypeRef v150 = 0;
        uint64_t v57 = (IR::IRDataLoader *)IR::IRDataLoader::instance(v56);
        int v58 = IR::IRDataLoader::registerCustomLayoutIfNecessary(v57, *(const AudioChannelLayout **)(a1 + 6216));
        goto LABEL_132;
      default:
        if (getAUSMV2Log(void)::onceToken != -1) {
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
        }
        float v63 = getAUSMV2Log(void)::gLog;
        if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR))
        {
          unsigned int v140 = (void *)(a1 + 6184);
          if (*v144 < 0) {
            unsigned int v140 = (void *)*v140;
          }
          unsigned int v141 = atomic_load((unsigned int *)(*v8 + 88));
          *(_DWORD *)char v177 = 136315650;
          *(void *)&v177[4] = v140;
          *(_WORD *)&v177[12] = 2080;
          *(void *)&v177[14] = "configureHOADecoder";
          *(_WORD *)&v177[22] = 1024;
          *(_DWORD *)unsigned int v178 = v141;
          _os_log_error_impl(&dword_1BB0CE000, v63, OS_LOG_TYPE_ERROR, "[%s|%s] Unknown output type %d", v177, 0x1Cu);
        }
        unsigned int v61 = 0;
        break;
    }
    int v58 = 0;
LABEL_174:
    char v69 = 0;
    uint64_t v70 = 0;
    *(void *)char v177 = cf1;
    *(void *)&v177[8] = &cf2;
    do
    {
      char v71 = v69;
      uint64_t v72 = *(void *)&v177[8 * v70];
      if (*(unsigned char *)(v72 + 164))
      {
        int v73 = *(const void **)(v72 + 88);
        CFTypeRef v74 = v150;
        *(void *)(v72 + 88) = v150;
        if (v74) {
          CFRetain(v74);
        }
        if (v73) {
          CFRelease(v73);
        }
        *(_DWORD *)(v72 + 100) = v58;
        *(_DWORD *)(v72 + 104) = v61;
        unsigned __int8 v75 = atomic_load((unsigned __int8 *)(*v8 + 1577));
        *(unsigned char *)(v72 + 112) = (v75 & 1) == 0;
      }
      char v69 = 1;
      uint64_t v70 = 1;
    }
    while ((v71 & 1) == 0);
    if (v150) {
      CFRelease(v150);
    }
    uint64_t v54 = *v8;
    int v53 = v146;
  }
  AUSM::AppleSauceCFWithMutex<__CFDictionary const*>::load(v177, v54 + 1976);
  CFDictionaryRef v76 = *(const __CFDictionary **)v177;
  if (*(void *)v177)
  {
    float v77 = 0.0;
    if (applesauce::CF::details::has_key<char const(&)[20]>(*(const __CFDictionary **)v177, "AbsoluteThresholdDb"))
    {
      float v78 = applesauce::CF::details::find_at_key<float,char const(&)[20]>(v76, "AbsoluteThresholdDb");
      float v77 = __exp10f(v78 / 20.0);
    }
    float v79 = 0.0;
    if (applesauce::CF::details::has_key<char const(&)[20]>(v76, "RelativeThresholdDb"))
    {
      float v80 = applesauce::CF::details::find_at_key<float,char const(&)[20]>(v76, "RelativeThresholdDb");
      float v79 = __exp10f(v80 / 20.0);
    }
    LODWORD(v150) = 0;
    float v81 = applesauce::CF::at_or<float,char const(&)[19]>(v76, "MaximumFrequencyHz", (uint64_t)&v150);
    unsigned int v82 = vcvtps_u32_f32((float)((float)(v81 + v81) / *(float *)(a1 + 6208)) * 128.0);
    if (v82 >= 0x80) {
      unsigned int v82 = 128;
    }
  }
  else
  {
    unsigned int v82 = 0;
    float v79 = 0.0;
    float v77 = 0.0;
  }
  unint64_t v160 = __PAIR64__(LODWORD(v79), LODWORD(v77));
  unsigned int v161 = v82;
  float v173 = v77;
  float v174 = v79;
  unsigned int v175 = v82;
  if (v76) {
    CFRelease(v76);
  }
  uint64_t v83 = *v8;
  uint64_t v84 = 2568;
  if (v53) {
    uint64_t v84 = 2564;
  }
  uint64_t v85 = 2556;
  if (!v53) {
    uint64_t v85 = 2560;
  }
  if (*(void *)cf1)
  {
    float v86 = *(float *)&v162[4];
    atomic_store(*(unsigned int *)&v162[4], (unsigned int *)(v83 + v84));
    atomic_store(*(unsigned int *)&v162[8], (unsigned int *)(v83 + v85));
    if (cf2)
    {
      if (*(float *)&v176[4] != v86)
      {
        if (getAUSMV2Log(void)::onceToken != -1) {
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
        }
        uint64_t v87 = getAUSMV2Log(void)::gLog;
        if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v88 = (void *)(a1 + 6184);
          if (*v144 < 0) {
            uint64_t v88 = (void *)*v88;
          }
          CFTypeRef v89 = "scene";
          if (!v53) {
            CFTypeRef v89 = "post-processing";
          }
          *(_DWORD *)char v177 = 136316162;
          *(void *)&v177[4] = v88;
          *(_WORD *)&v177[12] = 2080;
          *(void *)&v177[14] = "updateReverbAttributes";
          *(_WORD *)&v177[22] = 2080;
          *(void *)unsigned int v178 = v89;
          *(_WORD *)&v178[8] = 2048;
          *(double *)&v178[10] = *(float *)&v162[4];
          *(_WORD *)&v178[18] = 2048;
          *(double *)&v178[20] = *(float *)&v176[4];
          _os_log_impl(&dword_1BB0CE000, v87, OS_LOG_TYPE_DEFAULT, "[%s|%s] Mismatch in diffuse field power for %s reverb; early = %.1f, late = %.1f",
            v177,
            0x34u);
        }
      }
      if (*(float *)&v162[8] != *(float *)&v176[8])
      {
        if (getAUSMV2Log(void)::onceToken != -1) {
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
        }
        int v90 = getAUSMV2Log(void)::gLog;
        if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v91 = (void *)(a1 + 6184);
          if (*v144 < 0) {
            uint64_t v91 = (void *)*v91;
          }
          CFNumberRef v92 = "scene";
          if (!v53) {
            CFNumberRef v92 = "post-processing";
          }
          *(_DWORD *)char v177 = 136316162;
          *(void *)&v177[4] = v91;
          *(_WORD *)&v177[12] = 2080;
          *(void *)&v177[14] = "updateReverbAttributes";
          *(_WORD *)&v177[22] = 2080;
          *(void *)unsigned int v178 = v92;
          *(_WORD *)&v178[8] = 2048;
          *(double *)&v178[10] = *(float *)&v162[8];
          *(_WORD *)&v178[18] = 2048;
          *(double *)&v178[20] = *(float *)&v176[8];
          _os_log_impl(&dword_1BB0CE000, v90, OS_LOG_TYPE_DEFAULT, "[%s|%s] Mismatch in critical distance for %s reverb; early = %.1f, late = %.1f",
            v177,
            0x34u);
        }
      }
    }
  }
  else if (cf2)
  {
    atomic_store(*(unsigned int *)&v176[4], (unsigned int *)(v83 + v84));
    atomic_store(*(unsigned int *)&v176[8], (unsigned int *)(v83 + v85));
  }
  unsigned __int8 v93 = atomic_load((unsigned __int8 *)(*(void *)(a1 + 6176) + 1578));
  cf1[17] = v93 & 1;
  unsigned __int8 v94 = atomic_load((unsigned __int8 *)(*(void *)(a1 + 6176) + 1578));
  char v165 = v94 & 1;
  std::mutex::lock((std::mutex *)(a1 + 7736));
  if (v53)
  {
    uint64_t v95 = IR::IRDataAttributes::operator=(a1 + 6704, (uint64_t)cf1);
    *(void *)(a1 + 6856) = *(void *)v162;
    *(void *)(v95 + 157) = *(void *)&v162[5];
    IR::IRDataAttributes::operator=(a1 + 6872, (uint64_t)&cf2);
    uint64_t v96 = 7024;
  }
  else
  {
    uint64_t v97 = IR::IRDataAttributes::operator=(a1 + 7040, (uint64_t)cf1);
    *(void *)(a1 + 7192) = *(void *)v162;
    *(void *)(v97 + 157) = *(void *)&v162[5];
    IR::IRDataAttributes::operator=(a1 + 7208, (uint64_t)&cf2);
    uint64_t v96 = 7360;
  }
  uint64_t v98 = (void *)(a1 + v96);
  *uint64_t v98 = *(void *)v176;
  *(void *)((char *)v98 + 5) = *(void *)&v176[5];
  AUSM::IRManager::updateCombinedReverbAttributes(void)::$_0::operator()((uint64_t)v177, (char *)(a1 + 6176), a1 + 6704, a1 + 7040);
  uint64_t v99 = *(void *)(a1 + 7376);
  *(void *)(a1 + 7376) = *(void *)v177;
  *(unsigned char *)(a1 + 7432) = v179;
  char v100 = *(const void **)(a1 + 7440);
  CFTypeRef v101 = v182;
  *(void *)(a1 + 7440) = v180;
  *(_OWORD *)(a1 + 7384) = *(_OWORD *)&v177[8];
  *(_OWORD *)(a1 + 7400) = *(_OWORD *)v178;
  *(_OWORD *)(a1 + 7416) = *(_OWORD *)&v178[16];
  *(void *)char v177 = v99;
  CFTypeRef v180 = v100;
  *(_OWORD *)(a1 + 7448) = v181;
  CFTypeRef v102 = *(CFTypeRef *)(a1 + 7464);
  *(void *)(a1 + 7464) = v101;
  long long v103 = v183[0];
  *(_OWORD *)(a1 + 7481) = *(_OWORD *)((char *)v183 + 9);
  *(_OWORD *)(a1 + 7472) = v103;
  float v104 = *(const void **)(a1 + 7504);
  uint64_t v105 = v185;
  *(void *)(a1 + 7504) = cf;
  CFTypeRef v182 = v102;
  CFTypeRef cf = v104;
  *(_DWORD *)(a1 + 7520) = v186;
  *(void *)(a1 + 7512) = v105;
  if (v104)
  {
    CFRelease(v104);
    CFTypeRef v102 = v182;
  }
  if (v102) {
    CFRelease(v102);
  }
  if (v180) {
    CFRelease(v180);
  }
  if (*(void *)v177) {
    CFRelease(*(CFTypeRef *)v177);
  }
  AUSM::IRManager::updateCombinedReverbAttributes(void)::$_0::operator()((uint64_t)v177, (char *)(a1 + 6176), a1 + 6872, a1 + 7208);
  uint64_t v106 = *(void *)(a1 + 7544);
  *(void *)(a1 + 7544) = *(void *)v177;
  *(unsigned char *)(a1 + 7600) = v179;
  uint64_t v107 = *(const void **)(a1 + 7608);
  CFTypeRef v108 = v182;
  *(void *)(a1 + 7608) = v180;
  *(_OWORD *)(a1 + 7552) = *(_OWORD *)&v177[8];
  *(_OWORD *)(a1 + 7568) = *(_OWORD *)v178;
  *(_OWORD *)(a1 + 7584) = *(_OWORD *)&v178[16];
  *(void *)char v177 = v106;
  CFTypeRef v180 = v107;
  *(_OWORD *)(a1 + 7616) = v181;
  CFTypeRef v109 = *(CFTypeRef *)(a1 + 7632);
  *(void *)(a1 + 7632) = v108;
  long long v110 = v183[0];
  *(_OWORD *)(a1 + 7649) = *(_OWORD *)((char *)v183 + 9);
  *(_OWORD *)(a1 + 7640) = v110;
  unsigned __int8 v111 = *(const void **)(a1 + 7672);
  uint64_t v112 = v185;
  *(void *)(a1 + 7672) = cf;
  CFTypeRef v182 = v109;
  CFTypeRef cf = v111;
  *(_DWORD *)(a1 + 7688) = v186;
  *(void *)(a1 + 7680) = v112;
  if (v111)
  {
    CFRelease(v111);
    CFTypeRef v109 = v182;
  }
  if (v109) {
    CFRelease(v109);
  }
  if (v180) {
    CFRelease(v180);
  }
  if (*(void *)v177) {
    CFRelease(*(CFTypeRef *)v177);
  }
  std::mutex::unlock((std::mutex *)(a1 + 7736));
  if (v172) {
    CFRelease(v172);
  }
  if (v171) {
    CFRelease(v171);
  }
  if (v170) {
    CFRelease(v170);
  }
  if (cf2) {
    CFRelease(cf2);
  }
  if (v159) {
    CFRelease(v159);
  }
  if (v157) {
    CFRelease(v157);
  }
  if (v155) {
    CFRelease(v155);
  }
  if (*(void *)cf1) {
    CFRelease(*(CFTypeRef *)cf1);
  }
  *(void *)char v177 = a1 + 3120;
  v177[8] = 1;
  std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)(a1 + 3120));
  uint64_t v113 = *(void *)(a1 + 120);
  if (v113) {
    LODWORD(v114) = (*(uint64_t (**)(uint64_t))(*(void *)v113 + 24))(v113);
  }
  else {
    uint64_t v114 = (*(void *)(a1 + 104) - *(void *)(a1 + 96)) >> 3;
  }
  if ((int)v114 <= v145)
  {
    if (getAUSMV2Log(void)::onceToken != -1) {
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
    }
    uint64_t v123 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v123, OS_LOG_TYPE_ERROR))
    {
      unsigned __int8 v138 = (void *)(a1 + 3368);
      if (*(char *)(a1 + 3391) < 0) {
        unsigned __int8 v138 = (void *)*v138;
      }
      *(_DWORD *)cf1 = 136315906;
      *(void *)&cf1[4] = v138;
      *(_WORD *)&cf1[12] = 2080;
      *(void *)&cf1[14] = "UpdateAutoModeReverbBus";
      *(_WORD *)&cf1[22] = 1024;
      LODWORD(v152) = v145;
      WORD2(v152) = 1024;
      *(_DWORD *)((char *)&v152 + 6) = v114;
      _os_log_error_impl(&dword_1BB0CE000, v123, OS_LOG_TYPE_ERROR, "[%s|%s] update called for input #%d, number of inputs = %u", cf1, 0x22u);
    }

    goto LABEL_285;
  }
  if (v145 == -1) {
    unsigned int v115 = 0;
  }
  else {
    unsigned int v115 = v145;
  }
  if (v145 == -1) {
    int v116 = v114;
  }
  else {
    int v116 = v145 + 1;
  }
  if (getAUSMV2Log(void)::onceToken != -1) {
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
  }
  unint64_t v117 = (id)getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v118 = (void *)(a1 + 3368);
    if (*(char *)(a1 + 3391) < 0) {
      uint64_t v118 = (void *)*v118;
    }
    *(_DWORD *)cf1 = 136315650;
    *(void *)&cf1[4] = v118;
    *(_WORD *)&cf1[12] = 2080;
    *(void *)&cf1[14] = "UpdateAutoModeReverbBus";
    *(_WORD *)&cf1[22] = 1024;
    LODWORD(v152) = v145;
    _os_log_impl(&dword_1BB0CE000, v117, OS_LOG_TYPE_DEFAULT, "[%s|%s] updating early room for input %d", cf1, 0x1Cu);
  }

  if (v115 != v116)
  {
    if (v146) {
      uint64_t v119 = 5688;
    }
    else {
      uint64_t v119 = 5689;
    }
    unsigned int v120 = v115;
    do
    {
      uint64_t Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), v120);
      (*(void (**)(uint64_t, uint64_t))(*(void *)Element + 136))(Element, v119);
      ++v120;
    }
    while (v116 != v120);
  }
  if (v146)
  {
    if (v146 != 1) {
      goto LABEL_285;
    }
    uint64_t v122 = 9004;
  }
  else
  {
    uint64_t v122 = 9008;
  }
  unsigned int v125 = atomic_load((unsigned int *)(a1 + v122));
  if ((v125 & 0x80000000) == 0)
  {
    if (getAUSMV2Log(void)::onceToken != -1) {
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
    }
    float v126 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v126, OS_LOG_TYPE_DEFAULT))
    {
      float v127 = (void *)(a1 + 3368);
      if (*(char *)(a1 + 3391) < 0) {
        float v127 = (void *)*v127;
      }
      *(_DWORD *)cf1 = 136315394;
      *(void *)&cf1[4] = v127;
      *(_WORD *)&cf1[12] = 2080;
      *(void *)&cf1[14] = "UpdateAutoModeReverbBus";
      _os_log_impl(&dword_1BB0CE000, v126, OS_LOG_TYPE_DEFAULT, "[%s|%s] updating late reverb", cf1, 0x16u);
    }

    AUSM::IRManager::getLateReverbAttributes((uint64_t)cf1, a1 + 6176, v146);
    float v128 = (char *)operator new(0xB0uLL);
    *((void *)v128 + 3) = *(void *)cf1;
    *(void *)float v128 = &unk_1F14AD2A8;
    *((void *)v128 + 1) = 0;
    v128[80] = v154;
    *((void *)v128 + 11) = v155;
    CFTypeRef v129 = v159;
    *((void *)v128 + 14) = v157;
    *((void *)v128 + 2) = 0;
    long long v130 = v152;
    *((_OWORD *)v128 + 2) = *(_OWORD *)&cf1[8];
    *((_OWORD *)v128 + 3) = v130;
    *((_OWORD *)v128 + 4) = v153;
    *(void *)cf1 = 0;
    CFTypeRef v155 = 0;
    *((_OWORD *)v128 + 6) = v156;
    CFTypeRef v157 = 0;
    long long v131 = v158[0];
    *(_OWORD *)(v128 + 129) = *(_OWORD *)((char *)v158 + 9);
    *(_OWORD *)(v128 + 120) = v131;
    *((_DWORD *)v128 + 42) = v161;
    unint64_t v132 = v160;
    *((void *)v128 + 19) = v129;
    *((void *)v128 + 20) = v132;
    if (v115 == v116)
    {
LABEL_295:
      std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v128);
      uint64_t v124 = 1;
      goto LABEL_296;
    }
    double v134 = "scene";
    if (!v146) {
      double v134 = "post-processing";
    }
    unsigned int v143 = v134;
    while (1)
    {
      v148[0] = (uint64_t)(v128 + 24);
      v148[1] = (uint64_t)v128;
      atomic_fetch_add_explicit((atomic_ullong *volatile)v128 + 1, 1uLL, memory_order_relaxed);
      if (v146) {
        CFTypeRef v147 = 0;
      }
      else {
        AUSM::AppleSauceCFWithMutex<__CFDictionary const*>::load(&v147, a1 + 5264);
      }
      int v135 = IR::SharedIRBuses::reconfigure(a1 + 2104, v125 + v115, v148, &v147);
      if (v146)
      {
        if (v147) {
          goto LABEL_307;
        }
      }
      else if (v147)
      {
LABEL_307:
        CFRelease(v147);
      }
      std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v128);
      if (v135)
      {
        if (getAUSMV2Log(void)::onceToken != -1) {
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
        }
        uint64_t v136 = (id)getAUSMV2Log(void)::gLog;
        if (os_log_type_enabled(v136, OS_LOG_TYPE_ERROR))
        {
          uint64_t v137 = a1 + 3368;
          if (*(char *)(a1 + 3391) < 0) {
            uint64_t v137 = *(void *)(a1 + 3368);
          }
          *(_DWORD *)cf1 = 136316162;
          *(void *)&cf1[4] = v137;
          *(_WORD *)&cf1[12] = 2080;
          *(void *)&cf1[14] = "UpdateAutoModeReverbBus";
          *(_WORD *)&cf1[22] = 2080;
          *(void *)&long long v152 = v143;
          WORD4(v152) = 1024;
          *(_DWORD *)((char *)&v152 + 10) = v115;
          HIWORD(v152) = 1024;
          LODWORD(v153) = v135;
          _os_log_error_impl(&dword_1BB0CE000, v136, OS_LOG_TYPE_ERROR, "[%s|%s] Could not reconfigure auto mode %s late reverb for input #%u: error %d", cf1, 0x2Cu);
        }
      }
      if (v116 == ++v115) {
        goto LABEL_295;
      }
    }
  }
LABEL_285:
  uint64_t v124 = 0;
LABEL_296:
  std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)v177);
  return v124;
}

void sub_1BB3C5220(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t AUSpatialMixerV2::ReconfigureSharedBuffers(AUSpatialMixerV2 *this, int a2, char a3)
{
  int v4 = this;
  uint64_t v85 = *MEMORY[0x1E4F143B8];
  unsigned int v5 = *((_DWORD *)this + 84);
  uint64_t v57 = (char *)this + 3120;
  char v58 = 1;
  std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)((char *)this + 3120));
  unsigned __int8 v6 = atomic_load((unsigned __int8 *)v4 + 3522);
  CFTypeRef v43 = v4;
  if ((v6 & 1) == 0) {
    goto LABEL_23;
  }
  uint64_t v7 = *((void *)v4 + 15);
  if (v7)
  {
    LODWORD(v8) = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 24))(v7);
    if (v8) {
      goto LABEL_4;
    }
LABEL_23:
    unsigned int v14 = 0;
    uint64_t v39 = 0;
    uint64_t v40 = 0;
    unsigned int v38 = 0;
    unsigned int v13 = 0;
    unsigned int v12 = 0;
    *(void *)int v42 = 0;
    unsigned int v9 = 0;
    v45[0] = 0;
    goto LABEL_34;
  }
  uint64_t v8 = (*((void *)v4 + 13) - *((void *)v4 + 12)) >> 3;
  if (!v8) {
    goto LABEL_23;
  }
LABEL_4:
  char v41 = a3;
  unsigned int v9 = 0;
  unsigned int v10 = v4;
  unsigned int v11 = 0;
  unsigned int v12 = 0;
  unsigned int v13 = 0;
  unsigned int v14 = 0;
  *(_OWORD *)CFTypeRef v45 = 0u;
  long long v46 = 0u;
  BOOL v15 = (AUSpatialMixerV2 *)((char *)v10 + 80);
  long long v47 = 0u;
  *(_OWORD *)v48[0].i8 = 0u;
  do
  {
    uint64_t Element = ausdk::AUScope::SafeGetElement(v15, v11);
    uint64_t v17 = Element + 648;
    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock(Element + 648);
    unsigned int v18 = *(uint64_t **)(Element + 248);
    if (v18 == *(uint64_t **)(Element + 256))
    {
      memset(buf, 0, sizeof(buf));
      LODWORD(v60) = 0;
    }
    else
    {
      uint64_t v19 = *v18;
      *(void *)unsigned int v55 = *v18 + 472;
      v55[8] = 1;
      caulk::pooled_semaphore_mutex::_lock(*(caulk::pooled_semaphore_mutex **)v55);
      uint64_t v20 = *(void *)(v19 + 176);
      if (v20)
      {
        (*(void (**)(uint8_t *__return_ptr))(*(void *)v20 + 288))(buf);
      }
      else
      {
        memset(buf, 0, sizeof(buf));
        LODWORD(v60) = 0;
      }
      std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)v55);
    }
    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(v17);
    uint32x2_t v21 = *(uint32x2_t *)&buf[4];
    if (*(_DWORD *)&buf[16] > v9) {
      unsigned int v9 = *(_DWORD *)&buf[16];
    }
    uint64_t v22 = ausdk::AUScope::SafeGetElement(v15, v11);
    AUSpatialMixerV2InputElement::GetHeadTrackedEarlyReflectionsFilterParams((int *)v55, v22, 1);
    uint32x2_t v23 = *(uint32x2_t *)&v55[4];
    if (v56 > v12) {
      unsigned int v12 = v56;
    }
    uint64_t v24 = ausdk::AUScope::SafeGetElement(v15, v11);
    AUSpatialMixerV2InputElement::GetHeadTrackedEarlyReflectionsFilterParams(&v52, v24, 0);
    uint32x2_t v25 = v53;
    if (v54 > v14) {
      unsigned int v14 = v54;
    }
    uint64_t v26 = ausdk::AUScope::SafeGetElement(v15, v11);
    AUSpatialMixerV2InputElement::GetHeadTrackedEarlyReflectionsFilterParams(&v49, v26, 2);
    *((void *)&v27 + 1) = *(void *)&v45[2];
    *(uint32x2_t *)&long long v27 = vmax_u32(v21, *(uint32x2_t *)v45);
    *(_OWORD *)CFTypeRef v45 = v27;
    *((void *)&v27 + 1) = *((void *)&v46 + 1);
    *(uint32x2_t *)&long long v27 = vmax_u32(v23, *(uint32x2_t *)&v46);
    long long v46 = v27;
    *((void *)&v28 + 1) = *((void *)&v47 + 1);
    *((uint32x2_t *)&v29 + 1) = v48[1];
    *(uint32x2_t *)&long long v28 = vmax_u32(v25, *(uint32x2_t *)&v47);
    long long v47 = v28;
    *(uint32x2_t *)&long long v29 = vmax_u32(v50, v48[0]);
    *(_OWORD *)v48[0].i8 = v29;
    if (v51 > v13) {
      unsigned int v13 = v51;
    }
    ++v11;
  }
  while (v8 != v11);
  if (v45[0])
  {
    v42[1] = v45[1] + vcvtps_u32_f32((float)v5 / (float)v45[0]) - 1;
  }
  else
  {
    v42[1] = v45[1];
    v45[0] = 0;
  }
  int v4 = v43;
  a3 = v41;
  if (v46)
  {
    v42[0] = v46;
    HIDWORD(v40) = DWORD1(v46) + vcvtps_u32_f32((float)v5 / (float)v46) - 1;
  }
  else
  {
    HIDWORD(v40) = DWORD1(v46);
    v42[0] = 0;
  }
  if (v28)
  {
    LODWORD(v40) = v28;
    HIDWORD(v39) = DWORD1(v28) + vcvtps_u32_f32((float)v5 / (float)v28) - 1;
  }
  else
  {
    HIDWORD(v39) = DWORD1(v28);
    LODWORD(v40) = 0;
  }
  if (v29)
  {
    LODWORD(v39) = v29;
    unsigned int v38 = DWORD1(v29) + vcvtps_u32_f32((float)v5 / (float)v29) - 1;
  }
  else
  {
    unsigned int v38 = DWORD1(v29);
    LODWORD(v39) = 0;
  }
LABEL_34:
  *(void *)unsigned int v55 = (char *)v4 + 3104;
  v55[8] = 1;
  caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)v4 + 3104);
  if ((a3 & 1) != 0
    || (int v30 = (IR::ComplexDataCircBuffer *)(*((void *)v4 + 341) + 776),
        v45[0] != IR::ComplexDataCircBuffer::getFFTPartitionLength(v30))
    || v42[1] != IR::ComplexDataCircBuffer::getNumFFTBuffers(v30)
    || v9 != IR::ComplexDataCircBuffer::getNumOutputChannels(v30)
    || (float v31 = (IR::ComplexDataCircBuffer *)(*((void *)v4 + 341) + 784),
        v42[0] != IR::ComplexDataCircBuffer::getFFTPartitionLength(v31))
    || HIDWORD(v40) != IR::ComplexDataCircBuffer::getNumFFTBuffers(v31)
    || v12 != IR::ComplexDataCircBuffer::getNumOutputChannels(v31)
    || (CFTypeRef v32 = (IR::ComplexDataCircBuffer *)(*((void *)v4 + 341) + 792),
        v40 != IR::ComplexDataCircBuffer::getFFTPartitionLength(v32))
    || HIDWORD(v39) != IR::ComplexDataCircBuffer::getNumFFTBuffers(v32)
    || v14 != IR::ComplexDataCircBuffer::getNumOutputChannels(v32)
    || (int v33 = (IR::ComplexDataCircBuffer *)(*((void *)v4 + 341) + 800),
        v39 != IR::ComplexDataCircBuffer::getFFTPartitionLength(v33))
    || v38 != IR::ComplexDataCircBuffer::getNumFFTBuffers(v33)
    || v13 != IR::ComplexDataCircBuffer::getNumOutputChannels(v33))
  {
    if (getAUSMV2Log(void)::onceToken != -1) {
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_8539);
    }
    int v34 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v35 = (void *)((char *)v4 + 3368);
      if (*((char *)v4 + 3391) < 0) {
        uint64_t v35 = (void *)*v35;
      }
      uint64_t v36 = "false";
      *(_DWORD *)AudioTimeStamp buf = 136318722;
      *(void *)&uint8_t buf[4] = v35;
      *(void *)&buf[14] = "ReconfigureSharedBuffers";
      *(_WORD *)&unsigned char buf[12] = 2080;
      if (a2) {
        uint64_t v36 = "true";
      }
      *(_WORD *)&buf[22] = 2080;
      CFTypeRef v60 = v36;
      __int16 v61 = 1024;
      unsigned int v62 = v9;
      __int16 v63 = 1024;
      unsigned int v64 = v42[1];
      __int16 v65 = 1024;
      unsigned int v66 = v45[0];
      __int16 v67 = 1024;
      unsigned int v68 = v12;
      __int16 v69 = 1024;
      int v70 = HIDWORD(v40);
      __int16 v71 = 1024;
      unsigned int v72 = v42[0];
      __int16 v73 = 1024;
      unsigned int v74 = v14;
      __int16 v75 = 1024;
      int v76 = HIDWORD(v39);
      __int16 v77 = 1024;
      int v78 = v40;
      __int16 v79 = 1024;
      unsigned int v80 = v13;
      __int16 v81 = 1024;
      unsigned int v82 = v38;
      __int16 v83 = 1024;
      int v84 = v39;
      _os_log_impl(&dword_1BB0CE000, v34, OS_LOG_TYPE_DEFAULT, "[%s|%s] Reinitializing shared buffers. immediateUpdate = %s, fftParams {.numOutputs, .numFFTSubFilters, .partitionLength}: hrtfParams = {%u, %u, %u}, sceneBusParams = {%u, %u, %u}, postProcBusParams = {%u, %u, %u}, combinedBusParams = {%u, %u, %u}", buf, 0x68u);
    }

    operator new();
  }
  std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)v55);
  return std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&v57);
}

void sub_1BB3C6054(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
}

AUSM::SharedBuffers *AUSM::SharedBuffers::SharedBuffers(AUSM::SharedBuffers *this)
{
  for (uint64_t i = 0; i != 128; i += 32)
  {
    CFNumberRef v3 = (char *)this + i;
    *(void *)CFNumberRef v3 = 0;
    *((void *)v3 + 1) = 0;
    *((void *)v3 + 2) = 0;
    v3[24] = 1;
  }
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  __x[0] = 0;
  std::vector<char>::vector((std::vector<char> *)((char *)this + 272), 8uLL, __x);
  **((_DWORD **)this + 34) = 0;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *((unsigned char *)this + 376) = 1;
  *(void *)((char *)this + 380) = 0;
  *(_OWORD *)((char *)this + 408) = 0u;
  *(_OWORD *)((char *)this + 424) = 0u;
  *(_OWORD *)((char *)this + 392) = 0u;
  *((unsigned char *)this + 440) = 1;
  *(void *)((char *)this + 444) = 0;
  *((void *)this + 58) = 0;
  *((void *)this + 59) = 0;
  *((void *)this + 57) = 0;
  *(_OWORD *)((char *)this + 504) = 0u;
  *(_OWORD *)((char *)this + 520) = 0u;
  *(_OWORD *)((char *)this + 488) = 0u;
  *((unsigned char *)this + 536) = 1;
  *(void *)((char *)this + 540) = 0;
  *((void *)this + 71) = 0;
  *((void *)this + 69) = 0;
  *((void *)this + 70) = 0;
  *(_OWORD *)((char *)this + 584) = 0u;
  *(_OWORD *)((char *)this + 600) = 0u;
  *(_OWORD *)((char *)this + 616) = 0u;
  *((unsigned char *)this + 632) = 1;
  *(void *)((char *)this + 636) = 0;
  *((void *)this + 83) = 0;
  *((void *)this + 81) = 0;
  *((void *)this + 82) = 0;
  *(_OWORD *)((char *)this + 680) = 0u;
  *(_OWORD *)((char *)this + 696) = 0u;
  *(_OWORD *)((char *)this + 712) = 0u;
  *((unsigned char *)this + 728) = 1;
  *(void *)((char *)this + 732) = 0;
  *((void *)this + 94) = 0;
  *((void *)this + 93) = 0;
  *((void *)this + 95) = 0;
  IR::ComplexDataCircBuffer::ComplexDataCircBuffer((AUSM::SharedBuffers *)((char *)this + 776));
  IR::ComplexDataCircBuffer::ComplexDataCircBuffer((AUSM::SharedBuffers *)((char *)this + 784));
  IR::ComplexDataCircBuffer::ComplexDataCircBuffer((AUSM::SharedBuffers *)((char *)this + 792));
  IR::ComplexDataCircBuffer::ComplexDataCircBuffer((AUSM::SharedBuffers *)((char *)this + 800));
  *((void *)this + 103) = 0;
  *(_OWORD *)((char *)this + 808) = 0u;
  return this;
}

void sub_1BB3C6288(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _Unwind_Exception *exception_object, AUSM::ABLBuffer *a10, uint64_t a11, uint64_t a12)
{
  IR::ComplexDataCircBuffer::~ComplexDataCircBuffer(v13);
  IR::ComplexDataCircBuffer::~ComplexDataCircBuffer(v20);
  IR::ComplexDataCircBuffer::~ComplexDataCircBuffer(v19);
  AUSM::OutputBuffers::~OutputBuffers(v18);
  AUSM::OutputBuffers::~OutputBuffers(v17);
  AUSM::OutputBuffers::~OutputBuffers(v16);
  AUSM::OutputBuffers::~OutputBuffers(v15);
  vp::vx::io::Direction_Pair<std::vector<std::tuple<unsigned int,vp::services::Audio_Issue_Detector_Node_ID>>>::~Direction_Pair(v14);
  AUSM::ABLBuffer::~ABLBuffer(a10);
  std::vector<DspLib::PeakPowerGuard::AdmittanceFilterCoeffSet::FIRfilter>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  uint32x2_t v21 = *(void **)(v12 + 200);
  if (v21)
  {
    *(void *)(v12 + 208) = v21;
    operator delete(v21);
  }
  uint64_t v22 = 0;
  while (1)
  {
    uint32x2_t v23 = *(void **)(v12 + v22 + 176);
    if (v23)
    {
      *(void *)(v12 + v22 + 184) = v23;
      operator delete(v23);
    }
    v22 -= 24;
    if (v22 == -72)
    {
      uint64_t v24 = 0;
      while (1)
      {
        uint32x2_t v25 = *(void **)(v12 + v24 + 96);
        if (v25)
        {
          *(void *)(v12 + v24 + 104) = v25;
          operator delete(v25);
        }
        v24 -= 32;
        if (v24 == -128) {
          _Unwind_Resume(a1);
        }
      }
    }
  }
}

void sub_1BB3C6358()
{
  unsigned __int8 v2 = *v1;
  if (*v1)
  {
    *(void *)(v0 + 256) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x1BB3C62ECLL);
}

uint64_t *std::unique_ptr<AUSM::SharedBuffers>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  *float result = a2;
  if (v2)
  {
    CFNumberRef v3 = *(void **)(v2 + 808);
    if (v3)
    {
      *(void *)(v2 + 816) = v3;
      operator delete(v3);
    }
    IR::ComplexDataCircBuffer::~ComplexDataCircBuffer((IR::ComplexDataCircBuffer *)(v2 + 800));
    IR::ComplexDataCircBuffer::~ComplexDataCircBuffer((IR::ComplexDataCircBuffer *)(v2 + 792));
    IR::ComplexDataCircBuffer::~ComplexDataCircBuffer((IR::ComplexDataCircBuffer *)(v2 + 784));
    IR::ComplexDataCircBuffer::~ComplexDataCircBuffer((IR::ComplexDataCircBuffer *)(v2 + 776));
    int v4 = *(void **)(v2 + 744);
    if (v4)
    {
      *(void *)(v2 + 752) = v4;
      operator delete(v4);
    }
    unsigned int v5 = *(void **)(v2 + 704);
    if (v5)
    {
      *(void *)(v2 + 712) = v5;
      operator delete(v5);
    }
    unsigned __int8 v6 = *(void **)(v2 + 680);
    if (v6)
    {
      *(void *)(v2 + 688) = v6;
      operator delete(v6);
    }
    uint64_t v7 = *(void **)(v2 + 648);
    if (v7)
    {
      *(void *)(v2 + 656) = v7;
      operator delete(v7);
    }
    uint64_t v8 = *(void **)(v2 + 608);
    if (v8)
    {
      *(void *)(v2 + 616) = v8;
      operator delete(v8);
    }
    unsigned int v9 = *(void **)(v2 + 584);
    if (v9)
    {
      *(void *)(v2 + 592) = v9;
      operator delete(v9);
    }
    unsigned int v10 = *(void **)(v2 + 552);
    if (v10)
    {
      *(void *)(v2 + 560) = v10;
      operator delete(v10);
    }
    unsigned int v11 = *(void **)(v2 + 512);
    if (v11)
    {
      *(void *)(v2 + 520) = v11;
      operator delete(v11);
    }
    uint64_t v12 = *(void **)(v2 + 488);
    if (v12)
    {
      *(void *)(v2 + 496) = v12;
      operator delete(v12);
    }
    unsigned int v13 = *(void **)(v2 + 456);
    if (v13)
    {
      *(void *)(v2 + 464) = v13;
      operator delete(v13);
    }
    uint64_t v14 = *(void **)(v2 + 416);
    if (v14)
    {
      *(void *)(v2 + 424) = v14;
      operator delete(v14);
    }
    BOOL v15 = *(void **)(v2 + 392);
    if (v15)
    {
      *(void *)(v2 + 400) = v15;
      operator delete(v15);
    }
    uint64_t v16 = *(void **)(v2 + 352);
    if (v16)
    {
      *(void *)(v2 + 360) = v16;
      operator delete(v16);
    }
    uint64_t v17 = *(void **)(v2 + 328);
    if (v17)
    {
      *(void *)(v2 + 336) = v17;
      operator delete(v17);
    }
    unsigned int v18 = *(void **)(v2 + 296);
    if (v18)
    {
      *(void *)(v2 + 304) = v18;
      operator delete(v18);
    }
    uint64_t v19 = *(void **)(v2 + 272);
    if (v19)
    {
      *(void *)(v2 + 280) = v19;
      operator delete(v19);
    }
    uint64_t v20 = *(void **)(v2 + 248);
    if (v20)
    {
      *(void *)(v2 + 256) = v20;
      operator delete(v20);
    }
    uint64_t v26 = (void **)(v2 + 224);
    std::vector<DspLib::PeakPowerGuard::AdmittanceFilterCoeffSet::FIRfilter>::__destroy_vector::operator()[abi:ne180100](&v26);
    uint32x2_t v21 = *(void **)(v2 + 200);
    if (v21)
    {
      *(void *)(v2 + 208) = v21;
      operator delete(v21);
    }
    uint64_t v22 = 0;
    while (1)
    {
      uint32x2_t v23 = *(void **)(v2 + v22 + 176);
      if (v23)
      {
        *(void *)(v2 + v22 + 184) = v23;
        operator delete(v23);
      }
      v22 -= 24;
      if (v22 == -72)
      {
        uint64_t v24 = 0;
        while (1)
        {
          uint32x2_t v25 = *(void **)(v2 + v24 + 96);
          if (v25)
          {
            *(void *)(v2 + v24 + 104) = v25;
            operator delete(v25);
          }
          v24 -= 32;
          if (v24 == -128)
          {
            JUMPOUT(0x1C185D370);
          }
        }
      }
    }
  }
  return result;
}