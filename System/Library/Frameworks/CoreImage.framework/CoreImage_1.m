void CI::f4_sr_f3(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  void *v11;
  double (*v12)(uint64_t, __n128);
  uint64_t v13;
  uint64_t v14;
  long long v15;

  v11 = *(void **)(a1 + 48);
  v12 = *(double (**)(uint64_t, __n128))(a1 + 24);
  v13 = v11[1];
  v14 = v11[4];
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC((CI *)(a3 + 16 * v11[7]), a2);
  }
  *(double *)&v15 = v12(a4 + 80 * v13, *((__n128 *)a2 + 4 * v14));
  *(_OWORD *)(a3 + 16 * a7) = v15;
}

__n64 cikernel::_CIBoxBlur5Min(cikernel *this, SamplerObj *a2)
{
  DC = (CI *)CI::getDC(this);
  float32x2_t v4 = *(float32x2_t *)DC;
  v5 = (float32x2_t *)CI::getDC(DC);
  *(float *)&double v6 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *v5, 1), *((float *)this + 4), COERCE_FLOAT(*v5));
  LODWORD(v7) = *((_DWORD *)this + 7);
  v8.i32[0] = *((_DWORD *)this + 9);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *v5, 1), *(float *)&v7, COERCE_FLOAT(*v5));
  *(float *)&double v10 = *((float *)this + 6) + *(float *)&v6;
  *(float *)v11.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  *((float *)&v10 + 1) = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)&long long v13 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v10, v11, v6, v7, v9, v8, v12);
  long long v87 = v13;
  *(float32x2_t *)&long long v13 = vadd_f32(v4, (float32x2_t)0x3FC00000BFC00000);
  *(float *)&double v14 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)&v13, 1), *((float *)this + 4), *(float *)&v13);
  LODWORD(v15) = *((_DWORD *)this + 7);
  v16.i32[0] = *((_DWORD *)this + 9);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)&v13, 1), *(float *)&v15, *(float *)&v13);
  *(float *)&long long v13 = *((float *)this + 6) + *(float *)&v14;
  *(float *)v18.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  *((float *)&v13 + 1) = *(float *)v16.i32 + *(float *)v17.i32;
  double v20 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v13, v18, v14, v15, v17, v16, v19);
  *(float32x2_t *)&v21.f64[0] = vadd_f32(v4, (float32x2_t)0x3FC0000000000000);
  *(float *)&double v22 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)&v21.f64[0], 1), *((float *)this + 4), *(float *)v21.f64);
  LODWORD(v23) = *((_DWORD *)this + 6);
  v24.i32[0] = *((_DWORD *)this + 7);
  v25.i32[0] = *((_DWORD *)this + 9);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)&v21.f64[0], 1), *(float *)v24.i32, *(float *)v21.f64);
  HIDWORD(v21.f64[0]) = 0;
  float v27 = *(float *)&v20 * 0.16 + 0.0;
  *(float *)&double v20 = *(float *)&v23 + *(float *)&v22;
  *(float *)v21.f64 = *(float *)v25.i32 + *(float *)v26.i32;
  *((float *)&v20 + 1) = *(float *)v25.i32 + *(float *)v26.i32;
  double v28 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v20, v21, v23, v22, v24, v26, v25);
  __asm { FMOV            V1.2S, #1.5 }
  float32x2_t v34 = vadd_f32(v4, _D1);
  *(float *)&double v35 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v34, 1), *((float *)this + 4), v34.f32[0]);
  LODWORD(v36) = *((_DWORD *)this + 6);
  v37.i32[0] = *((_DWORD *)this + 7);
  v38.i32[0] = *((_DWORD *)this + 9);
  *(float *)v39.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v34, 1), *(float *)v37.i32, v34.f32[0]);
  v40.f64[0] = v27;
  float v41 = v27 + *(float *)&v28 * 0.08;
  *(float *)&double v28 = *(float *)&v36 + *(float *)&v35;
  *(float *)v40.f64 = *(float *)v38.i32 + *(float *)v39.i32;
  *((float *)&v28 + 1) = *(float *)v38.i32 + *(float *)v39.i32;
  double v42 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v28, v40, v36, v35, v37, v39, v38);
  float32x2_t v43 = vadd_f32(v4, (float32x2_t)3217031168);
  *(float *)&double v44 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v43, 1), *((float *)this + 4), v43.f32[0]);
  LODWORD(v45) = *((_DWORD *)this + 6);
  v46.i32[0] = *((_DWORD *)this + 7);
  v47.i32[0] = *((_DWORD *)this + 9);
  *(float *)v48.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v43, 1), *(float *)v46.i32, v43.f32[0]);
  v49.f64[0] = v41;
  float v50 = v41 + *(float *)&v42 * 0.16;
  *(float *)&double v42 = *(float *)&v45 + *(float *)&v44;
  *(float *)v49.f64 = *(float *)v47.i32 + *(float *)v48.i32;
  *((float *)&v42 + 1) = *(float *)v47.i32 + *(float *)v48.i32;
  double v51 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v42, v49, v45, v44, v46, v48, v47);
  *(float *)&double v51 = v50 + *(float *)&v51 * 0.08;
  v52.f64[1] = *((float64_t *)&v87 + 1);
  HIDWORD(v53) = 1067743969;
  *(float32x2_t *)&v52.f64[0] = vadd_f32(v4, (float32x2_t)1069547520);
  *(float *)&double v54 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)&v52.f64[0], 1), *((float *)this + 4), *(float *)v52.f64);
  LODWORD(v53) = *((_DWORD *)this + 6);
  v55.i32[0] = *((_DWORD *)this + 7);
  v56.i32[0] = *((_DWORD *)this + 9);
  *(float *)v57.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)&v52.f64[0], 1), *(float *)v55.i32, *(float *)v52.f64);
  float v58 = *(float *)&v51 + *(float *)&v87 * 0.04;
  *(float *)&double v51 = *(float *)&v53 + *(float *)&v54;
  *(float *)v52.f64 = *(float *)v56.i32 + *(float *)v57.i32;
  *((float *)&v51 + 1) = *(float *)v56.i32 + *(float *)v57.i32;
  double v59 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v51, v52, v53, v54, v55, v57, v56);
  __asm { FMOV            V1.2S, #-1.5 }
  float32x2_t v61 = vadd_f32(v4, _D1);
  *(float *)&double v62 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v61, 1), *((float *)this + 4), v61.f32[0]);
  LODWORD(v63) = *((_DWORD *)this + 6);
  v64.i32[0] = *((_DWORD *)this + 7);
  v65.i32[0] = *((_DWORD *)this + 9);
  *(float *)v66.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v61, 1), *(float *)v64.i32, v61.f32[0]);
  v67.f64[0] = v58;
  float v68 = v58 + *(float *)&v59 * 0.08;
  *(float *)&double v59 = *(float *)&v63 + *(float *)&v62;
  *(float *)v67.f64 = *(float *)v65.i32 + *(float *)v66.i32;
  *((float *)&v59 + 1) = *(float *)v65.i32 + *(float *)v66.i32;
  double v69 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v59, v67, v63, v62, v64, v66, v65);
  float32x2_t v70 = vadd_f32(v4, (float32x2_t)0xBFC0000000000000);
  *(float *)&double v71 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v70, 1), *((float *)this + 4), v70.f32[0]);
  LODWORD(v72) = *((_DWORD *)this + 6);
  v73.i32[0] = *((_DWORD *)this + 7);
  v74.i32[0] = *((_DWORD *)this + 9);
  *(float *)v75.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v70, 1), *(float *)v73.i32, v70.f32[0]);
  v76.f64[0] = v68;
  float v77 = v68 + *(float *)&v69 * 0.16;
  *(float *)&double v69 = *(float *)&v72 + *(float *)&v71;
  *(float *)v76.f64 = *(float *)v74.i32 + *(float *)v75.i32;
  *((float *)&v69 + 1) = *(float *)v74.i32 + *(float *)v75.i32;
  double v78 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v69, v76, v72, v71, v73, v75, v74);
  *(float32x2_t *)&v79.f64[0] = vadd_f32(v4, (float32x2_t)0xBFC000003FC00000);
  *(float *)&double v80 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)&v79.f64[0], 1), *((float *)this + 4), *(float *)v79.f64);
  LODWORD(v81) = *((_DWORD *)this + 6);
  v82.i32[0] = *((_DWORD *)this + 7);
  v83.i32[0] = *((_DWORD *)this + 9);
  *(float *)v84.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)&v79.f64[0], 1), *(float *)v82.i32, *(float *)v79.f64);
  v4.f32[0] = v77 + *(float *)&v78 * 0.08;
  *(float *)&double v78 = *(float *)&v81 + *(float *)&v80;
  *(float *)v79.f64 = *(float *)v83.i32 + *(float *)v84.i32;
  *((float *)&v78 + 1) = *(float *)v83.i32 + *(float *)v84.i32;
  double v85 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v78, v79, v81, v80, v82, v84, v83);
  *(float *)&double v85 = v4.f32[0] + *(float *)&v85 * 0.16;
  result.n64_f32[0] = fminf(*(float *)&v85, *(float *)&v87);
  result.n64_u32[1] = 0;
  return result;
}

double cikernel::_displaceFromImage(cikernel *this, SamplerObj *a2, SamplerObj *a3, float a4)
{
  v6.f64[0] = *(float64_t *)CI::getDC(this);
  int8x16_t v38 = (int8x16_t)v6;
  float32x2_t v7 = vadd_f32(*(float32x2_t *)&v6.f64[0], (float32x2_t)1065353216);
  *(float *)&double v8 = vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 5), v7, 1), *((float *)a2 + 4), v7.f32[0]);
  LODWORD(v9) = *((_DWORD *)a2 + 7);
  v10.i32[0] = *((_DWORD *)a2 + 9);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 8), v7, 1), *(float *)&v9, v7.f32[0]);
  v7.f32[0] = *((float *)a2 + 6) + *(float *)&v8;
  *(float *)v6.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  v7.f32[1] = *(float *)v10.i32 + *(float *)v11.i32;
  double v36 = CI::BitmapSampler::read(*((uint64x2_t **)a2 + 1), *(double *)&v7, v6, v8, v9, v11, v10, v12);
  float64x2_t v13 = (float64x2_t)v38;
  float32x2_t v14 = vadd_f32(*(float32x2_t *)v38.i8, (float32x2_t)0xBF80000000000000);
  *(float *)&double v15 = vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 5), v14, 1), *((float *)a2 + 4), v14.f32[0]);
  LODWORD(v16) = *((_DWORD *)a2 + 7);
  v17.i32[0] = *((_DWORD *)a2 + 9);
  *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 8), v14, 1), *(float *)&v16, v14.f32[0]);
  v14.f32[0] = *((float *)a2 + 6) + *(float *)&v15;
  *(float *)v13.f64 = *(float *)v17.i32 + *(float *)v18.i32;
  v14.f32[1] = *(float *)v17.i32 + *(float *)v18.i32;
  double v35 = CI::BitmapSampler::read(*((uint64x2_t **)a2 + 1), *(double *)&v14, v13, v15, v16, v18, v17, v19);
  LODWORD(v20) = *((_DWORD *)a2 + 7);
  *(float *)&double v21 = *((float *)a2 + 6)
                 + vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 5), *(float32x2_t *)v38.i8, 1), *((float *)a2 + 4), *(float *)v38.i32);
  LODWORD(v22) = *((_DWORD *)a2 + 9);
  *(float *)v23.f64 = *(float *)&v22
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 8), *(float32x2_t *)v38.i8, 1), *(float *)&v20, *(float *)v38.i32);
  HIDWORD(v21) = LODWORD(v23.f64[0]);
  double v30 = CI::BitmapSampler::read(*((uint64x2_t **)a2 + 1), v21, v23, v20, v22, v38, v24, v25);
  HIDWORD(v32) = HIDWORD(v36);
  *(void *)&v28.f64[1] = v38.i64[1];
  *(float32x2_t *)&v28.f64[0] = vadd_f32(*(float32x2_t *)v38.i8, vmul_n_f32((float32x2_t)vzip1_s32((int32x2_t)vsub_f32(*(float32x2_t *)&v36, *(float32x2_t *)&v30), (int32x2_t)vsub_f32(*(float32x2_t *)&v35, *(float32x2_t *)&v30)), a4));
  LODWORD(v29) = *((_DWORD *)this + 7);
  *(float *)&double v30 = *((float *)this + 6)
                 + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)&v28.f64[0], 1), *((float *)this + 4), *(float *)v28.f64);
  v31.i32[0] = *((_DWORD *)this + 9);
  *(float *)&double v32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)&v28.f64[0], 1), *(float *)&v29, *(float *)v28.f64);
  v33 = (uint64x2_t *)*((void *)this + 1);

  *((float *)&v30 + 1) = *(float *)v31.i32 + *(float *)&v32;
  *(float *)v28.f64 = *(float *)v31.i32 + *(float *)&v32;
  return CI::BitmapSampler::read(v33, v30, v28, v32, v29, v31, v26, v27);
}

double cikernel::_disolve(float32x4_t a1, float32x4_t a2, float a3)
{
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(a2, 1.0 - a3), a1, a3).u64[0];
  return result;
}

double cikernel::_fadeDissolve(float32x4_t a1, float a2)
{
  *(void *)&double result = vmulq_n_f32(a1, a2).u64[0];
  return result;
}

double cikernel::_thresholdRed(float a1, float a2)
{
  BOOL v2 = a1 < a2;
  int32x2_t v3 = 0;
  if (!v2) {
    *(float *)v3.i32 = 1.0;
  }
  *(void *)&double result = vdupq_lane_s32(v3, 0).u64[0];
  return result;
}

double cikernel::_linearMappingNoSecondaryImage(float a1, float a2)
{
  float v2 = a1 + -0.5 + a1 + -0.5;
  double v3 = sqrt((1.0 - fmaxf(v2, 0.0)) * a2);
  *(float *)&double v3 = v3;
  *(void *)&double result = vdupq_lane_s32(*(int32x2_t *)&v3, 0).u64[0];
  return result;
}

double cikernel::_linearMapping(float a1, float a2, float a3)
{
  float v3 = a1 + -0.5 + a1 + -0.5;
  double v4 = sqrt((1.0 - a2) * (1.0 - fmaxf(v3, 0.0)) * a3);
  *(float *)&double v4 = v4;
  *(void *)&double result = vdupq_lane_s32(*(int32x2_t *)&v4, 0).u64[0];
  return result;
}

CIImage *resample(CIImage *a1, CGRect a2)
{
  double height = a2.size.height;
  double width = a2.size.width;
  double v4 = a1;
  v22[1] = *MEMORY[0x1E4F143B8];
  [(CIImage *)a1 extent];
  if (vabdd_f64(v5, width) >= 0.0001 || ([(CIImage *)v4 extent], vabdd_f64(v6, height) >= 0.0001))
  {
    [(CIImage *)v4 extent];
    if (v7 >= width || ([(CIImage *)v4 extent], v8 >= height))
    {
      memset(&v20, 0, sizeof(v20));
      [(CIImage *)v4 extent];
      CGFloat v16 = width / v15;
      [(CIImage *)v4 extent];
      CGAffineTransformMakeScale(&v20, v16, height / v17);
      CGAffineTransform v19 = v20;
      float32x2_t v14 = [(CIImage *)v4 imageByApplyingTransform:&v19];
    }
    else
    {
      [(CIImage *)v4 extent];
      double v10 = width / v9;
      [(CIImage *)v4 extent];
      int8x16_t v12 = +[CIVector vectorWithX:v10 Y:height / v11];
      float64x2_t v13 = [(CIImage *)v4 imageByClampingToExtent];
      double v21 = @"inputScale";
      v22[0] = v12;
      float32x2_t v14 = -[CIImage imageByApplyingFilter:withInputParameters:](v13, "imageByApplyingFilter:withInputParameters:", @"CISoftCubicUpsample", [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v22 forKeys:&v21 count:1]);
    }
    return -[CIImage imageByCroppingToRect:](v14, "imageByCroppingToRect:", 0.0, 0.0, width, height);
  }
  return v4;
}

CIImage *conditionallyFilteredMaxThreshold(CIImage *a1, CIImage *a2, CIImage *a3, float a4)
{
  v26[4] = *MEMORY[0x1E4F143B8];
  double v8 = +[CIKernel kernelWithInternalRepresentation:&CI::_DEconditionalFilter];
  [(CIImage *)a1 extent];
  CGFloat v10 = v9;
  CGFloat v12 = v11;
  CGFloat v14 = v13;
  CGFloat v16 = v15;
  [(CIImage *)a2 extent];
  v29.origin.double x = v17;
  v29.origin.double y = v18;
  v29.size.double width = v19;
  v29.size.double height = v20;
  v27.origin.double x = v10;
  v27.origin.double y = v12;
  v27.size.double width = v14;
  v27.size.double height = v16;
  CGRect v28 = CGRectUnion(v27, v29);
  double x = v28.origin.x;
  double y = v28.origin.y;
  double width = v28.size.width;
  double height = v28.size.height;
  v26[0] = a1;
  v26[1] = a2;
  v26[2] = a3;
  *(float *)&v28.origin.double x = a4;
  v26[3] = [NSNumber numberWithFloat:v28.origin.x];
  return -[CIColorKernel applyWithExtent:arguments:](v8, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v26 count:4], x, y, width, height);
}

float cikernel::_CElumaToR(float32x4_t a1)
{
  float32x4_t v1 = vmulq_f32(a1, (float32x4_t)xmmword_193950AB0);
  LODWORD(result) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1, 2), vaddq_f32(v1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v1.f32, 1))).u32[0];
  return result;
}

double cikernel::_DEcomputeInversionMask(float32x4_t a1, double a2, float a3, float a4, double a5, float32x4_t a6)
{
  a6.i32[0] = 1.0;
  if ((float)(fmaxf(fmaxf(a1.f32[0], a1.f32[1]), a1.f32[2]) / fminf(fminf(a1.f32[0], a1.f32[1]), a1.f32[2])) <= a3)
  {
    float32x4_t v6 = vmulq_f32(a1, (float32x4_t)xmmword_193950AB0);
    a6 = vaddq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1));
    BOOL v7 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), a6).f32[0] <= (float)((float)(*((float *)&a2 + 1)
                                                                                               + *(float *)&a2)
                                                                                       * 0.5);
    a6.i32[0] = 1.0;
    if (v7)
    {
      if ((float)(*((float *)&a2 + 1) - *(float *)&a2) >= a4) {
        a6.f32[0] = 0.0;
      }
      else {
        a6.f32[0] = 1.0;
      }
    }
  }
  *(void *)&double result = vdupq_lane_s32(*(int32x2_t *)a6.f32, 0).u64[0];
  return result;
}

void ___ZL11reduceImageP7CIImageiP8CIKernel_block_invoke(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4)
{
  memset(&v9, 0, sizeof(v9));
  CGAffineTransformMakeScale(&v9, 2.0, 2.0);
  CGAffineTransform v8 = v9;
  v10.origin.double x = a1;
  v10.origin.double y = a2;
  v10.size.double width = a3;
  v10.size.double height = a4;
  CGRect v11 = CGRectApplyAffineTransform(v10, &v8);
  CGRectIntegral(v11);
}

double cikernel::_DEmax4(uint64_t a1, double a2)
{
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)&v4.f64[0] = vadd_f32(*DC, *DC);
  float64x2_t v40 = v4;
  float32x2_t v5 = vadd_f32(*(float32x2_t *)&v4.f64[0], (float32x2_t)0xBF000000BF000000);
  *(float *)&double v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v5, 1), *(float *)(a1 + 16), v5.f32[0]);
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *(float *)(a1 + 24) + *(float *)&v6;
  *(float *)v4.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v11.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v5, v4, v6, v7, v9, v8, v10);
  float32x4_t v38 = v11;
  float64x2_t v12 = v40;
  *(float32x2_t *)v11.f32 = vadd_f32(*(float32x2_t *)&v40.f64[0], (float32x2_t)0xBF0000003F000000);
  *(float *)&double v13 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v11.f32, 1), *(float *)(a1 + 16), v11.f32[0]);
  LODWORD(v14) = *(_DWORD *)(a1 + 28);
  v15.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v11.f32, 1), *(float *)&v14, v11.f32[0]);
  v11.f32[0] = *(float *)(a1 + 24) + *(float *)&v13;
  *(float *)v12.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v11.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  *(double *)v18.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v11.i64, v12, v13, v14, v16, v15, v17);
  float32x4_t v36 = v18;
  float64x2_t v19 = v40;
  *(float32x2_t *)v18.f32 = vadd_f32(*(float32x2_t *)&v40.f64[0], (float32x2_t)0x3F000000BF000000);
  *(float *)&double v20 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v18.f32, 1), *(float *)(a1 + 16), v18.f32[0]);
  LODWORD(v21) = *(_DWORD *)(a1 + 28);
  v22.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v23.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v18.f32, 1), *(float *)&v21, v18.f32[0]);
  v18.f32[0] = *(float *)(a1 + 24) + *(float *)&v20;
  *(float *)v19.f64 = *(float *)v22.i32 + *(float *)v23.i32;
  v18.f32[1] = *(float *)v22.i32 + *(float *)v23.i32;
  *(double *)v25.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v18.i64, v19, v20, v21, v23, v22, v24);
  float32x4_t v37 = v25;
  float64x2_t v26 = v40;
  *(float32x2_t *)v25.f32 = vadd_f32(*(float32x2_t *)&v40.f64[0], (float32x2_t)0x3F0000003F000000);
  *(float *)&double v27 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v25.f32, 1), *(float *)(a1 + 16), v25.f32[0]);
  LODWORD(v28) = *(_DWORD *)(a1 + 28);
  v29.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v30.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v25.f32, 1), *(float *)&v28, v25.f32[0]);
  v25.f32[0] = *(float *)(a1 + 24) + *(float *)&v27;
  *(float *)v26.f64 = *(float *)v29.i32 + *(float *)v30.i32;
  v25.f32[1] = *(float *)v29.i32 + *(float *)v30.i32;
  *(double *)v32.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v25.i64, v26, v27, v28, v30, v29, v31);
  if (*(float *)v40.f64 + 0.5 >= *(float *)&a2)
  {
    float32x4_t v33 = v37;
    float32x4_t v34 = v38;
  }
  else
  {
    float32x4_t v33 = vmaxnmq_f32(v37, v32);
    float32x4_t v34 = vmaxnmq_f32(v38, v36);
  }
  if (*((float *)v40.f64 + 1) + 0.5 < *((float *)&a2 + 1)) {
    v34.i64[0] = vmaxnmq_f32(v34, v33).u64[0];
  }
  return *(double *)v34.i64;
}

double cikernel::_DEcreateForegroundMask(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  float v4 = fminf(a1.f32[0], fminf(a1.f32[1], a1.f32[2]));
  float32x4_t v5 = vmulq_f32(a2, (float32x4_t)vdupq_n_s32(0x3EAAAAAAu));
  int32x4_t v6 = (int32x4_t)vmulq_f32(a1, (float32x4_t)xmmword_193952AD0);
  int32x4_t v7 = (int32x4_t)vmulq_f32(a1, (float32x4_t)xmmword_193952AE0);
  int32x4_t v8 = (int32x4_t)vmulq_f32(a3, (float32x4_t)xmmword_193952AD0);
  int32x4_t v9 = (int32x4_t)vmulq_f32(a3, (float32x4_t)xmmword_193952AE0);
  *(float32x2_t *)v9.i8 = vsub_f32((float32x2_t)vzip1_s32((int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v6, 2), vadd_f32(*(float32x2_t *)v6.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v6.i8, 1))), (int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v7, 2), vadd_f32(*(float32x2_t *)v7.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v7.i8, 1)))), (float32x2_t)vzip1_s32((int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v8, 2), vadd_f32(*(float32x2_t *)v8.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v8.i8, 1))), (int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v9, 2),
                                                        vadd_f32(*(float32x2_t *)v9.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v9.i8, 1)))));
  LODWORD(v10) = vmulq_f32(a4, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1)))).u32[0];
  a4.f32[0] = fmaxf(a1.f32[0], fmaxf(a1.f32[1], a1.f32[2])) / v4;
  BOOL v12 = sqrtf(vaddv_f32(vmul_f32(*(float32x2_t *)v9.i8, *(float32x2_t *)v9.i8))) > a4.f32[3]
     || a4.f32[0] > a4.f32[1]
     || v4 < v10;
  int8x16_t v13 = (int8x16_t)vmulq_f32(a1, (float32x4_t)0);
  if (v12) {
    unsigned int v14 = -1;
  }
  else {
    unsigned int v14 = 0;
  }
  *(void *)&double result = vbslq_s8((int8x16_t)vdupq_n_s32(v14), v13, (int8x16_t)a1).u64[0];
  return result;
}

void CI::f4_s_s_s_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  float v10 = *(double (**)(__n128, __n128, __n128, __n128))(a1 + 24);
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  int v13 = *(_DWORD *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  int v15 = *(_DWORD *)(v9 + 64);
  uint64_t v16 = *(void *)(v9 + 56);
  int v17 = *(_DWORD *)(v9 + 88);
  uint64_t v18 = *(void *)(v9 + 80);
  if (*(unsigned char *)(a1 + 64))
  {
    int8x16_t v24 = *(double (**)(__n128, __n128, __n128, __n128))(a1 + 24);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 104)), a2);
    float v10 = v24;
  }
  float64x2_t v19 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5) {
    float64x2_t v19 = (__n128 *)((char *)a2 + 64 * v18);
  }
  double v20 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5) {
    double v20 = (__n128 *)((char *)a2 + 64 * v16);
  }
  double v21 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    double v21 = (__n128 *)((char *)a2 + 64 * v14);
  }
  int8x16_t v22 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    int8x16_t v22 = (__n128 *)((char *)a2 + 64 * v12);
  }
  *(double *)&long long v23 = v10(*v22, *v21, *v20, *v19);
  *(_OWORD *)(a3 + 16 * a7) = v23;
}

CIImage *normalizedBlur(CIImage *a1, float a2)
{
  v12[1] = *MEMORY[0x1E4F143B8];
  float v4 = +[CIKernel kernelWithInternalRepresentation:&CI::_DEnormalizeAlpha];
  float32x4_t v5 = [(CIImage *)a1 imageByApplyingGaussianBlurWithSigma:a2];
  [(CIImage *)v5 extent];
  v12[0] = v5;
  float v10 = -[CIColorKernel applyWithExtent:arguments:](v4, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v12 count:1], v6, v7, v8, v9);
  [(CIImage *)a1 extent];
  return -[CIImage imageByCroppingToRect:](v10, "imageByCroppingToRect:");
}

double cikernel::_DEnormalizeAlpha(float32x4_t a1, double a2)
{
  float v2 = (float)(a1.f32[3] + -0.001) / 0.099;
  float v3 = 1.0;
  if (v2 <= 1.0) {
    float v3 = (float)(a1.f32[3] + -0.001) / 0.099;
  }
  BOOL v4 = v2 < 0.0;
  float v5 = 0.0;
  if (!v4) {
    float v5 = v3;
  }
  *(float *)&a2 = fmaxf(a1.f32[3], 0.0001);
  *(void *)&double result = vdivq_f32(vmulq_n_f32(a1, (float)(v5 * v5) * (float)((float)(v5 * -2.0) + 3.0)), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a2, 0)).u64[0];
  return result;
}

double cikernel::_DEWash(float32x4_t a1, float32x4_t a2)
{
  *(void *)&double result = vdivq_f32(a1, vaddq_f32(a2, (float32x4_t)vdupq_n_s32(0x358637BDu))).u64[0];
  return result;
}

float cikernel::_DE_compinv(float32x4_t a1)
{
  __asm { FMOV            V1.4S, #1.0 }
  float32x4_t v6 = vmulq_f32(vsubq_f32(_Q1, a1), (float32x4_t)vdupq_n_s32(0x3EAAAAABu));
  LODWORD(result) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), vaddq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1))).u32[0];
  return result;
}

double cikernel::_DEconditionalFilter(int8x16_t a1, int8x16_t a2, float32x4_t a3, float32x4_t a4)
{
  *(void *)&double result = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(a3, a4), 0), a1, a2).u64[0];
  return result;
}

void CI::f4_s_s_s_f(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = a1[6];
  float v10 = (double (*)(void *, __n128, __n128, __n128, float))a1[3];
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  int v13 = *(_DWORD *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  int v15 = *(_DWORD *)(v9 + 64);
  uint64_t v16 = *(void *)(v9 + 56);
  uint64_t v17 = *(void *)(v9 + 80);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 104)), a2);
  }
  uint64_t v18 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5) {
    uint64_t v18 = (__n128 *)((char *)a2 + 64 * v16);
  }
  float64x2_t v19 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    float64x2_t v19 = (__n128 *)((char *)a2 + 64 * v14);
  }
  double v20 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    double v20 = (__n128 *)((char *)a2 + 64 * v12);
  }
  *(double *)&long long v21 = v10(a1, *v20, *v19, *v18, *((float *)a2 + 16 * v17));
  *(_OWORD *)(a3 + 16 * a7) = v21;
}

float cikernel::_DE_sub(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2 = vmulq_f32(a1, (float32x4_t)xmmword_193950AB0);
  float32x4_t v3 = vmulq_f32(a2, (float32x4_t)xmmword_193950AB0);
  LODWORD(result) = vsubq_f32(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v2, 2), vaddq_f32(v2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v2.f32, 1)))).u32[0];
  return result;
}

double cikernel::_DE_scaleAdd(float32x4_t a1, float _S1, float _S2)
{
  float32x4_t v3 = vmulq_f32(a1, (float32x4_t)xmmword_193950AB0);
  _Q3 = (int32x4_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1)));
  float32x4_t v5 = vmulq_f32(a1, (float32x4_t)xmmword_193952AD0);
  float32x4_t v6 = vmulq_f32(a1, (float32x4_t)xmmword_193952AE0);
  __asm { FMLS            S3, S2, V1.S[0] }
  float32x4_t v11 = (float32x4_t)vzip1q_s32(_Q3, (int32x4_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))));
  v11.i32[2] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), vaddq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1))).u32[0];
  float32x4_t v12 = vmulq_f32(v11, (float32x4_t)xmmword_193952AF0);
  v12.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))).u32[0];
  float32x4_t v13 = vmulq_f32(v11, (float32x4_t)xmmword_193952B00);
  float32x4_t v14 = vmulq_f32(v11, (float32x4_t)xmmword_193952B10);
  v12.i32[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2), vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1))).u32[0];
  v12.i64[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).u32[0];
  float32x4_t v15 = vmaxnmq_f32(v12, (float32x4_t)0);
  v15.i32[3] = 0;
  float32x4_t v16 = (float32x4_t)vdupq_laneq_s32((int32x4_t)a1, 3);
  v16.i32[3] = 0;
  *(void *)&double result = vminnmq_f32(v15, v16).u64[0];
  return result;
}

double cikernel::_CEcomp_minmax(__n128 a1)
{
  *(float *)&double v1 = fminf(fminf(a1.n128_f32[0], a1.n128_f32[1]), a1.n128_f32[2]);
  HIDWORD(v1) = fmaxf(fmaxf(a1.n128_f32[0], a1.n128_f32[1]), a1.n128_f32[2]);
  return v1;
}

void ___ZL14reduceImageBy2P7CIImageP8CIKerneli_block_invoke(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4)
{
  CGAffineTransformMakeScale(&v8, 2.0, 2.0);
  v9.origin.double x = a1;
  v9.origin.double y = a2;
  v9.size.double width = a3;
  v9.size.double height = a4;
  CGRect v10 = CGRectApplyAffineTransform(v9, &v8);
  CGRectIntegral(v10);
}

__n64 cikernel::_DEminmax4(uint64_t a1, double a2)
{
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)&v4.f64[0] = vadd_f32(*DC, *DC);
  float64x2_t v48 = v4;
  float32x2_t v5 = vadd_f32(*(float32x2_t *)&v4.f64[0], (float32x2_t)0xBF000000BF000000);
  *(float *)&double v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v5, 1), *(float *)(a1 + 16), v5.f32[0]);
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *(float *)(a1 + 24) + *(float *)&v6;
  *(float *)v4.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  double v46 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v5, v4, v6, v7, v9, v8, v10);
  float64x2_t v11 = v48;
  float32x2_t v12 = vadd_f32(*(float32x2_t *)&v48.f64[0], (float32x2_t)0xBF0000003F000000);
  *(float *)&double v13 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v12, 1), *(float *)(a1 + 16), v12.f32[0]);
  LODWORD(v14) = *(_DWORD *)(a1 + 28);
  v15.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v12, 1), *(float *)&v14, v12.f32[0]);
  v12.f32[0] = *(float *)(a1 + 24) + *(float *)&v13;
  *(float *)v11.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v12.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  double v45 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v12, v11, v13, v14, v16, v15, v17);
  float64x2_t v18 = v48;
  float32x2_t v19 = vadd_f32(*(float32x2_t *)&v48.f64[0], (float32x2_t)0x3F000000BF000000);
  *(float *)&double v20 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v19, 1), *(float *)(a1 + 16), v19.f32[0]);
  LODWORD(v21) = *(_DWORD *)(a1 + 28);
  v22.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v23.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v19, 1), *(float *)&v21, v19.f32[0]);
  v19.f32[0] = *(float *)(a1 + 24) + *(float *)&v20;
  *(float *)v18.f64 = *(float *)v22.i32 + *(float *)v23.i32;
  v19.f32[1] = *(float *)v22.i32 + *(float *)v23.i32;
  double v44 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v19, v18, v20, v21, v23, v22, v24);
  float64x2_t v25 = v48;
  float32x2_t v26 = vadd_f32(*(float32x2_t *)&v48.f64[0], (float32x2_t)0x3F0000003F000000);
  *(float *)&double v27 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v26, 1), *(float *)(a1 + 16), v26.f32[0]);
  LODWORD(v28) = *(_DWORD *)(a1 + 28);
  v29.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v30.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v26, 1), *(float *)&v28, v26.f32[0]);
  v26.f32[0] = *(float *)(a1 + 24) + *(float *)&v27;
  *(float *)v25.f64 = *(float *)v29.i32 + *(float *)v30.i32;
  v26.f32[1] = *(float *)v29.i32 + *(float *)v30.i32;
  double v32 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v26, v25, v27, v28, v30, v29, v31);
  float v33 = *((float *)&v46 + 1);
  float v34 = *((float *)&v44 + 1);
  float v35 = fminf(*(float *)&v44, *(float *)&v32);
  float v36 = fminf(*(float *)&v46, *(float *)&v45);
  float v37 = fmaxf(*((float *)&v46 + 1), *((float *)&v45 + 1));
  float v38 = fmaxf(*((float *)&v44 + 1), *((float *)&v32 + 1));
  if (*(float *)v48.f64 + 0.5 < *(float *)&a2)
  {
    float v33 = v37;
  }
  else
  {
    float v35 = *(float *)&v44;
    float v36 = *(float *)&v46;
  }
  if (*(float *)v48.f64 + 0.5 < *(float *)&a2) {
    float v34 = v38;
  }
  double v39 = *((float *)v48.f64 + 1) + 0.5;
  float v40 = fminf(v36, v35);
  BOOL v41 = v39 < *((float *)&a2 + 1);
  if (v39 >= *((float *)&a2 + 1)) {
    result.n64_f32[0] = v36;
  }
  else {
    result.n64_f32[0] = v40;
  }
  float v43 = fmaxf(v33, v34);
  if (v41) {
    float v33 = v43;
  }
  result.n64_f32[1] = v33;
  return result;
}

double cikernel::_CEstretch(float32x4_t a1, float32x4_t a2, float a3)
{
  float32x4_t v3 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.f32, 0);
  int32x2_t v4 = (int32x2_t)vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.f32, 1), a2).u64[0];
  *(float *)v4.i32 = fmaxf(*(float *)v4.i32, 0.00001);
  float32x4_t v5 = vdivq_f32(vsubq_f32(a1, v3), (float32x4_t)vdupq_lane_s32(v4, 0));
  v5.i32[3] = 0;
  float32x4_t v6 = vmaxnmq_f32(v5, (float32x4_t)0);
  v6.i32[3] = 0;
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - a3), vminnmq_f32(v6, (float32x4_t)xmmword_1939508C0), a3).u64[0];
  return result;
}

void sub_19374B270(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__4(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 48);
  long long v3 = *(_OWORD *)(a2 + 64);
  *(__n128 *)(a1 + 48) = result;
  *(_OWORD *)(a1 + 64) = v3;
  return result;
}

float32x2_t cikernel::_droste(CI *a1, float32x2_t a2, double a3, float a4, double a5, double a6)
{
  float32x2_t v14 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  float32_t v15 = *(float *)&a5 + atan2f(v14.f32[1], v14.f32[0]);
  v8.f32[0] = logf(vaddv_f32(vmul_f32(v14, v14))) * 0.5;
  v8.f32[1] = v15;
  float v9 = vaddv_f32(vmul_f32((float32x2_t)vrev64_s32(*(int32x2_t *)&a3), v8));
  LODWORD(a3) = expf(vmlas_n_f32(vmuls_lane_f32(-v15, *(float32x2_t *)&a3, 1), v8.f32[0], *(float *)&a3));
  __float2 v10 = __sincosf_stret(v9);
  float32x2_t v19 = vmul_lane_f32(vmul_n_f32((float32x2_t)__PAIR64__(LODWORD(v10.__sinval), LODWORD(v10.__cosval)), *(float *)&a3), *(float32x2_t *)&a5, 1);
  float v11 = fmaxf(fabsf(v19.f32[0]) / *(float *)&a6, fabsf(v19.f32[1]) / *((float *)&a6 + 1));
  float v12 = logf(v11);
  return vadd_f32(a2, vmul_n_f32(v19, expf(v12 - (float)(a4 * floorf(v12 / a4))) / v11));
}

void CI::f2_f2_f2_f_f2_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  __float2 v10 = *(double (**)(double, double, float, double, double))(a1 + 24);
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  int v13 = *(_DWORD *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  uint64_t v15 = *(void *)(v9 + 56);
  int v16 = *(_DWORD *)(v9 + 88);
  uint64_t v17 = *(void *)(v9 + 80);
  int v18 = *(_DWORD *)(v9 + 112);
  uint64_t v19 = *(void *)(v9 + 104);
  if (*(unsigned char *)(a1 + 64))
  {
    float64x2_t v25 = *(double (**)(double, double, float, double, double))(a1 + 24);
    int v24 = *(_DWORD *)(v9 + 112);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 128)), a2);
    int v18 = v24;
    __float2 v10 = v25;
  }
  double v20 = (double *)(a3 + 16 * v19);
  if (v18 != 5) {
    double v20 = (double *)((char *)a2 + 64 * v19);
  }
  double v21 = (double *)(a3 + 16 * v17);
  if (v16 != 5) {
    double v21 = (double *)((char *)a2 + 64 * v17);
  }
  int8x16_t v22 = (double *)(a3 + 16 * v14);
  if (v13 != 5) {
    int8x16_t v22 = (double *)((char *)a2 + 64 * v14);
  }
  int8x16_t v23 = (double *)(a3 + 16 * v12);
  if (v11 != 5) {
    int8x16_t v23 = (double *)((char *)a2 + 64 * v12);
  }
  *(double *)(a3 + 16 * a7) = v10(*v23, *v22, *((float *)a2 + 16 * v15), *v21, *v20);
}

__n64 cikernel::_drr_noise(cikernel *this, float a2, float a3)
{
  float32x2_t v4 = vrndm_f32(*(float32x2_t *)CI::getDC(this));
  float v5 = v4.f32[0] * 0.764705882 + 65.3529412;
  v4.f32[0] = v4.f32[1] * 0.578947368 + 409.315789;
  float v6 = (float)(v4.f32[0] + (float)(v4.f32[0] * v5)) + floor((float)(v4.f32[0] + (float)(v4.f32[0] * v5)) / 37.0) * -37.0;
  v4.f32[0] = (float)(v5 + (float)(v4.f32[0] * v6)) + floor((float)(v5 + (float)(v4.f32[0] * v6)) / 37.0) * -37.0;
  v4.f32[0] = (float)(v5 * v4.f32[0]) + floor((float)(v5 * v4.f32[0]) / 37.0) * -37.0;
  result.n64_f32[0] = ((float)(v4.f32[0] / 37.0) + -0.5) * a2;
  result.n64_u32[1] = 0;
  return result;
}

void CI::f4_f_f(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  __float2 v10 = (void *)a1[6];
  int v11 = (double (*)(void *, float, float))a1[3];
  uint64_t v12 = v10[1];
  uint64_t v13 = v10[4];
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * v10[7]), a2);
  }
  *(double *)&long long v14 = v11(a1, *((float *)a2 + 16 * v12), *((float *)a2 + 16 * v13));
  *(_OWORD *)(a3 + 16 * a7) = v14;
}

double cikernel::_drr_cdintersect(CI *a1, float32x4_t a2, float32x2_t a3, float a4, float a5)
{
  float32x2_t v6 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a3);
  BOOL v7 = vaddv_f32(vmul_f32(v6, v6)) > (float)(a5 * a4);
  float v8 = 0.0;
  if (!v7) {
    float v8 = 1.0;
  }
  *(void *)&double result = vmulq_n_f32(a2, v8).u64[0];
  return result;
}

double cikernel::_drr_cdmeasure(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2 = vdivq_f32(vabdq_f32(a1, a2), vmaxnmq_f32(vaddq_f32(a1, a2), (float32x4_t)vdupq_n_s32(0x38D1B717u)));
  __asm { FMOV            V1.4S, #1.0 }
  *(void *)&double result = vsubq_f32(_Q1, v2).u64[0];
  return result;
}

double cikernel::_drr_spec(float32x4_t a1, __n128 a2, double a3, float a4, float a5)
{
  *(float *)&a3 = fminf(1.25 * *(float *)&a3, 1.0);
  if (*(float *)&a3 <= a5)
  {
    unint64_t v9 = a1.i64[0];
  }
  else
  {
    float v5 = fminf((float)((float)((float)(a2.n128_f32[2] + vaddv_f32((float32x2_t)a2.n128_u64[0]))- fminf(fminf(a2.n128_f32[0], a2.n128_f32[1]), a2.n128_f32[2]))* 0.5)* a4, 1.0)/ 0.6;
    if (v5 <= 1.0) {
      float v6 = v5;
    }
    else {
      float v6 = 1.0;
    }
    BOOL v7 = v5 < 0.0;
    float v8 = 0.0;
    if (!v7) {
      float v8 = v6;
    }
    unint64_t v9 = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - *(float *)&a3), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a3, 0), (float)(v8 * v8) * (float)((float)(v8 * -2.0) + 3.0)).u64[0];
  }
  return *(double *)&v9;
}

void CI::f4_s_s_s_f_f_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  __float2 v10 = *(double (**)(__n128, __n128, __n128, float, float, float))(a1 + 24);
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  int v13 = *(_DWORD *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  int v15 = *(_DWORD *)(v9 + 64);
  uint64_t v16 = *(void *)(v9 + 56);
  uint64_t v17 = *(void *)(v9 + 80);
  uint64_t v18 = *(void *)(v9 + 104);
  uint64_t v19 = *(void *)(v9 + 128);
  if (*(unsigned char *)(a1 + 64))
  {
    int v24 = *(_DWORD *)(v9 + 64);
    int v25 = *(_DWORD *)(v9 + 40);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 152)), a2);
    int v15 = v24;
    int v13 = v25;
  }
  double v20 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5) {
    double v20 = (__n128 *)((char *)a2 + 64 * v16);
  }
  double v21 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    double v21 = (__n128 *)((char *)a2 + 64 * v14);
  }
  int8x16_t v22 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    int8x16_t v22 = (__n128 *)((char *)a2 + 64 * v12);
  }
  *(double *)&long long v23 = v10(*v22, *v21, *v20, *((float *)a2 + 16 * v17), *((float *)a2 + 16 * v18), *((float *)a2 + 16 * v19));
  *(_OWORD *)(a3 + 16 * a7) = v23;
}

double cikernel::_drr_spec_debug(float32x4_t a1, __n128 a2, double a3, float a4, float a5, float a6)
{
  *(float *)&a3 = fminf(1.25 * *(float *)&a3, 1.0);
  if (*(float *)&a3 <= a5)
  {
    int8x16_t v10 = (int8x16_t)a1;
  }
  else
  {
    float v6 = fminf((float)((float)((float)(a2.n128_f32[2] + vaddv_f32((float32x2_t)a2.n128_u64[0]))- fminf(fminf(a2.n128_f32[0], a2.n128_f32[1]), a2.n128_f32[2]))* 0.5)* a4, 1.0)/ 0.6;
    if (v6 <= 1.0) {
      float v7 = v6;
    }
    else {
      float v7 = 1.0;
    }
    BOOL v8 = v6 < 0.0;
    float v9 = 0.0;
    if (!v8) {
      float v9 = v7;
    }
    int8x16_t v10 = (int8x16_t)vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - *(float *)&a3), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a3, 0), (float)(v9 * v9) * (float)((float)(v9 * -2.0) + 3.0));
  }
  int32x4_t v11 = (int32x4_t)v10;
  v11.i32[3] = a1.i32[3];
  if (a6 >= 1.0)
  {
    if (a6 >= 2.0)
    {
      if (a6 < 3.0)
      {
        int32x4_t v12 = (int32x4_t)vextq_s8(v10, v10, 8uLL);
        *(float32x2_t *)v12.i8 = vmul_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v10.i8, *(int32x2_t *)v12.i8), 0);
        v11.i64[0] = vtrn2q_s32(vzip1q_s32(v11, v12), v11).u64[0];
      }
    }
    else
    {
      v11.i32[1] = vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(v10, v10, 4uLL), 0).u32[0];
    }
  }
  return *(double *)v11.i64;
}

double cikernel::_drr_repair(int8x16_t a1, float32x4_t a2, float a3, float32x4_t a4, float a5, float a6, float a7, float a8, float a9)
{
  double v18 = (a7 + a7) * a5;
  *(float *)&double v18 = v18;
  float32x4_t v19 = vaddq_f32(a4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v18, 0));
  a4.f32[0] = a7 * a5;
  float32x4_t v20 = vaddq_f32(a2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a4.f32, 0));
  float32x2_t v21 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)a1.i8, 0);
  float32x2_t v22 = (float32x2_t)vext_s8(*(int8x8_t *)a1.i8, (int8x8_t)*(_OWORD *)&vextq_s8(a1, a1, 8uLL), 4uLL);
  float v23 = fmaxf(vaddv_f32(vdiv_f32(vmaxnm_f32(vsub_f32(v21, v22), 0), vmaxnm_f32(vadd_f32(v21, v22), (float32x2_t)vdup_n_s32(0x38D1B717u))))* 0.5, 0.25);
  float v24 = (float)(v23 + -0.1) + (float)(v23 + -0.1);
  if (v24 <= 1.0) {
    float v25 = (float)(v23 + -0.1) + (float)(v23 + -0.1);
  }
  else {
    float v25 = 1.0;
  }
  BOOL v26 = v24 < 0.0;
  int32x2_t v27 = 0;
  if (v26) {
    *(float *)v17.i32 = 0.0;
  }
  else {
    *(float *)v17.i32 = v25;
  }
  *(float *)v17.i32 = (float)(*(float *)v17.i32 * *(float *)v17.i32) * (float)((float)(*(float *)v17.i32 * -2.0) + 3.0);
  float32x4_t v28 = vmlaq_n_f32(vmulq_n_f32(vmulq_n_f32(v19, a6 + a6), 1.0 - *(float *)v17.i32), (float32x4_t)vdupq_lane_s32(v17, 0), (float)(a6 * 0.5) * fminf(v20.f32[2], v20.f32[1]));
  float32x4_t v29 = vmulq_f32(v28, (float32x4_t)xmmword_193950AB0);
  float32x4_t v30 = vmulq_f32(v19, (float32x4_t)xmmword_193950AB0);
  float32x4_t v31 = vmulq_n_f32(vmulq_n_f32(v19, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v29, 2), vaddq_f32(v29, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v29.f32, 1))).f32[0]), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v30, 2), vaddq_f32(v30, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 1))).f32[0]);
  float32x4_t v32 = vmulq_f32(v19, (float32x4_t)vdupq_n_s32(0x3D75C28Fu));
  v32.i32[3] = 0;
  float32x4_t v33 = vmlaq_n_f32(vmulq_n_f32(v28, 1.0 - a9), v31, a9);
  v33.i32[3] = 0;
  float32x4_t v34 = vmulq_f32((float32x4_t)a1, (float32x4_t)xmmword_193950AB0);
  float32x4_t v35 = vmaxnmq_f32(v32, v33);
  float v36 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v34, 2), vaddq_f32(v34, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v34.f32, 1))).f32[0];
  float v37 = a8 + 0.01;
  float v38 = (float)(v36 - v37) / (float)(1.01 - v37);
  if (v38 <= 1.0) {
    float v39 = v38;
  }
  else {
    float v39 = 1.0;
  }
  if (v38 >= 0.0) {
    *(float *)v27.i32 = v39;
  }
  *(float *)v27.i32 = (float)(*(float *)v27.i32 * *(float *)v27.i32) * (float)((float)(*(float *)v27.i32 * -2.0) + 3.0);
  float32x4_t v40 = vmlaq_n_f32(vmulq_n_f32(v35, 1.0 - *(float *)v27.i32), (float32x4_t)vdupq_lane_s32(v27, 0), v36);
  float v41 = (1.0 - *(float *)v27.i32) * a3;
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(a2, 1.0 - a3), vmlaq_n_f32(vmulq_n_f32((float32x4_t)a1, 1.0 - v41), v40, v41), a3).u64[0];
  return result;
}

void CI::f4_s_s_s_s_s_f_f_f_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  int8x16_t v10 = *(double (**)(__n128, __n128, __n128, __n128, __n128, float, float, float, double))(a1 + 24);
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  int v13 = *(_DWORD *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  int v15 = *(_DWORD *)(v9 + 64);
  uint64_t v16 = *(void *)(v9 + 56);
  int v17 = *(_DWORD *)(v9 + 88);
  uint64_t v18 = *(void *)(v9 + 80);
  int v19 = *(_DWORD *)(v9 + 112);
  uint64_t v20 = *(void *)(v9 + 104);
  uint64_t v21 = *(void *)(v9 + 128);
  uint64_t v22 = *(void *)(v9 + 152);
  uint64_t v23 = *(void *)(v9 + 176);
  uint64_t v24 = *(void *)(v9 + 200);
  if (*(unsigned char *)(a1 + 64))
  {
    float v37 = *(double (**)(__n128, __n128, __n128, __n128, __n128, float, float, float, double))(a1 + 24);
    uint64_t v38 = *(void *)(v9 + 200);
    uint64_t v35 = *(void *)(v9 + 128);
    uint64_t v36 = *(void *)(v9 + 32);
    uint64_t v39 = *(void *)(v9 + 152);
    int v33 = *(_DWORD *)(v9 + 112);
    int v34 = *(_DWORD *)(v9 + 88);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 224)), a2);
    int v19 = v33;
    int v17 = v34;
    uint64_t v21 = v35;
    uint64_t v14 = v36;
    uint64_t v24 = v38;
    uint64_t v22 = v39;
    int8x16_t v10 = v37;
  }
  float v25 = (__n128 *)(a3 + 16 * v20);
  if (v19 != 5) {
    float v25 = (__n128 *)((char *)a2 + 64 * v20);
  }
  BOOL v26 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5) {
    BOOL v26 = (__n128 *)((char *)a2 + 64 * v18);
  }
  int32x2_t v27 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5) {
    int32x2_t v27 = (__n128 *)((char *)a2 + 64 * v16);
  }
  float32x4_t v28 = (__n128 *)(a3 + 16 * v14);
  float32x4_t v29 = (__n128 *)((char *)a2 + 64 * v14);
  if (v13 != 5) {
    float32x4_t v28 = v29;
  }
  float32x4_t v30 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    float32x4_t v30 = (__n128 *)((char *)a2 + 64 * v12);
  }
  LODWORD(v32) = *((_DWORD *)a2 + 16 * v24);
  *(double *)&long long v31 = v10(*v30, *v28, *v27, *v26, *v25, *((float *)a2 + 16 * v21), *((float *)a2 + 16 * v22), *((float *)a2 + 16 * v23), v32);
  *(_OWORD *)(a3 + 16 * a7) = v31;
}

double cikernel::_drr_recovery(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float a5)
{
  float32x4_t v5 = vmulq_f32(a2, (float32x4_t)vdupq_n_s32(0x3EAAAAABu));
  LODWORD(v6) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))).u32[0];
  float v7 = (float)(fminf(fminf(a1.f32[0], a1.f32[1]), a1.f32[2]) + -0.6) / 0.35;
  if (v7 <= 1.0) {
    float v8 = v7;
  }
  else {
    float v8 = 1.0;
  }
  BOOL v9 = v7 < 0.0;
  float v10 = 0.0;
  if (!v9) {
    float v10 = v8;
  }
  float v11 = (float)((float)(v10 * v10) * (float)((float)(v10 * -2.0) + 3.0)) * a5;
  float32x4_t v12 = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - v11), vdivq_f32(vmulq_f32(a3, vmlaq_n_f32(a2, (float32x4_t)0, v6)), a4), v11);
  float32x4_t v13 = a1;
  v13.i32[3] = 0;
  v12.i32[3] = 0;
  *(void *)&double result = vminnmq_f32(v13, v12).u64[0];
  return result;
}

void CI::f4_s_s_s_s_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  float v10 = *(double (**)(__n128, __n128, __n128, __n128, float))(a1 + 24);
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  int v13 = *(_DWORD *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  int v15 = *(_DWORD *)(v9 + 64);
  uint64_t v16 = *(void *)(v9 + 56);
  int v17 = *(_DWORD *)(v9 + 88);
  uint64_t v18 = *(void *)(v9 + 80);
  uint64_t v19 = *(void *)(v9 + 104);
  if (*(unsigned char *)(a1 + 64))
  {
    int v25 = *(_DWORD *)(v9 + 88);
    int v26 = *(_DWORD *)(v9 + 64);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 128)), a2);
    int v17 = v25;
    int v15 = v26;
  }
  uint64_t v20 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5) {
    uint64_t v20 = (__n128 *)((char *)a2 + 64 * v18);
  }
  uint64_t v21 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5) {
    uint64_t v21 = (__n128 *)((char *)a2 + 64 * v16);
  }
  uint64_t v22 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    uint64_t v22 = (__n128 *)((char *)a2 + 64 * v14);
  }
  uint64_t v23 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    uint64_t v23 = (__n128 *)((char *)a2 + 64 * v12);
  }
  *(double *)&long long v24 = v10(*v23, *v22, *v21, *v20, *((float *)a2 + 16 * v19));
  *(_OWORD *)(a3 + 16 * a7) = v24;
}

void OUTLINED_FUNCTION_1_3(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x20u);
}

double OUTLINED_FUNCTION_3(float a1)
{
  return a1;
}

void OUTLINED_FUNCTION_8(uint64_t a1@<X8>)
{
  *(void *)(v1 - 8) = a1;
}

double OUTLINED_FUNCTION_9@<D0>(uint64_t a1@<X8>, float a2@<S0>)
{
  *(void *)(v2 - 8) = a1;
  return (float)(a2 * 100.0);
}

double OUTLINED_FUNCTION_11@<D0>(uint64_t a1@<X8>, float a2@<S0>)
{
  *(void *)(v2 - 8) = a1;
  return a2;
}

void OUTLINED_FUNCTION_12(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x18u);
}

void OUTLINED_FUNCTION_13(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x1Cu);
}

void sub_19375283C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  int v13 = va_arg(va1, void (*)(uint64_t *));
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  v13((uint64_t *)va);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1937531F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,void (*a25)(char *))
{
}

void OUTLINED_FUNCTION_3_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0x16u);
}

uint64_t OUTLINED_FUNCTION_6_0@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)(a2 + 4) = a3;
  *(_WORD *)(a2 + 12) = 2112;
  *(void *)(a2 + 14) = result;
  return result;
}

void OUTLINED_FUNCTION_8_0(uint64_t a1@<X8>)
{
  *(void *)(v1 - 8) = a1;
}

uint64_t OUTLINED_FUNCTION_9_0@<X0>(uint64_t result@<X0>, int a2@<W8>)
{
  *(void *)(result + 4) = v3;
  *(_WORD *)(result + 12) = 1024;
  *(_DWORD *)(result + 14) = a2;
  *(_WORD *)(result + 18) = 1024;
  *(_DWORD *)(result + 20) = v2;
  return result;
}

void OUTLINED_FUNCTION_10(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0x20u);
}

void OUTLINED_FUNCTION_12_0(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x12u);
}

double cikernel::_drr_extract_iris(float a1, float a2, float a3, float a4, float a5, float a6)
{
  BOOL v6 = a2 < a5;
  int32x2_t v7 = 0;
  if (v6) {
    float v8 = 1.0;
  }
  else {
    float v8 = 0.0;
  }
  if (a3 >= a6) {
    float v9 = 0.0;
  }
  else {
    float v9 = 1.0;
  }
  if (a1 >= a4) {
    *(float *)v7.i32 = v8;
  }
  *(float *)v7.i32 = *(float *)v7.i32 * v9;
  *(void *)&double result = vdupq_lane_s32(v7, 0).u64[0];
  return result;
}

double cikernel::_drr_extract_skin(float a1, float a2)
{
  float v2 = a2 + 0.05;
  float v3 = (float)(a1 - a2) / (float)(v2 - a2);
  if (v3 <= 1.0) {
    float v4 = v3;
  }
  else {
    float v4 = 1.0;
  }
  BOOL v5 = v3 < 0.0;
  int32x2_t v6 = 0;
  if (!v5) {
    *(float *)v6.i32 = v4;
  }
  *(float *)v6.i32 = 1.0
                   - (float)((float)(*(float *)v6.i32 * *(float *)v6.i32)
                           * (float)((float)(*(float *)v6.i32 * -2.0) + 3.0));
  *(void *)&double result = vdupq_lane_s32(v6, 0).u64[0];
  return result;
}

double cikernel::_drr_boost(float32x4_t a1, float a2)
{
  *(void *)&double result = vmulq_n_f32(a1, a2).u64[0];
  return result;
}

double cikernel::_rer_glint(float32x4_t a1, float32x4_t a2, float a3)
{
  float v3 = (float)(fminf(fminf(a1.f32[0], a1.f32[1]), a1.f32[2]) - a3) / (float)(1.0 - a3);
  if (v3 <= 1.0) {
    float v4 = v3;
  }
  else {
    float v4 = 1.0;
  }
  BOOL v5 = v3 < 0.0;
  float v6 = 0.0;
  if (!v5) {
    float v6 = v4;
  }
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(a2, 1.0 - (float)((float)(v6 * v6) * (float)((float)(v6 * -2.0) + 3.0))), a1, (float)(v6 * v6) * (float)((float)(v6 * -2.0) + 3.0)).u64[0];
  return result;
}

double cikernel::_drr_threshold(float32x4_t a1, float a2, float a3)
{
  BOOL v3 = a2 < a3;
  float v4 = 1.0;
  if (v3) {
    float v4 = 0.0;
  }
  *(void *)&double result = vmulq_n_f32(a1, v4).u64[0];
  return result;
}

void sub_193757A34(_Unwind_Exception *a1)
{
}

void sub_193757AB0(_Unwind_Exception *a1)
{
}

id updatedTuningFromSetup(NSDictionary *a1, NSDictionary *a2, NSString *a3, NSString *a4, NSString *a5)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  id result = [(NSDictionary *)a2 objectForKey:a3];
  if (result)
  {
    id result = (id)[result objectForKey:a5];
    if (result)
    {
      float v9 = result;
      id v10 = (id)[(NSDictionary *)a1 mutableCopy];
      long long v21 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      int v11 = (void *)[v9 allKeys];
      id result = (id)[v11 countByEnumeratingWithState:&v21 objects:v29 count:16];
      if (result)
      {
        id v12 = result;
        char v13 = 0;
        uint64_t v14 = *(void *)v22;
        do
        {
          for (i = 0; i != v12; i = (char *)i + 1)
          {
            if (*(void *)v22 != v14) {
              objc_enumerationMutation(v11);
            }
            uint64_t v16 = *(void **)(*((void *)&v21 + 1) + 8 * i);
            uint64_t v17 = (uint64_t)v16;
            if (![v10 objectForKey:v16])
            {
              uint64_t v17 = (uint64_t)v16;
              if ((unint64_t)[v16 length] >= 3)
              {
                uint64_t v18 = objc_msgSend((id)objc_msgSend(v16, "substringToIndex:", 1), "uppercaseString");
                uint64_t v19 = [v16 substringFromIndex:1];
                uint64_t v17 = [NSString stringWithFormat:@"%@%@%@", a4, v18, v19];
              }
            }
            if ([v10 objectForKey:v17])
            {
              objc_msgSend(v10, "setValue:forKey:", objc_msgSend(v9, "objectForKey:", v16), v17);
              char v13 = 1;
            }
            else if (CI_LOG_DUALRED())
            {
              uint64_t v20 = ci_logger_api();
              if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446466;
                int v26 = "updatedTuningFromSetup";
                __int16 v27 = 2112;
                float32x4_t v28 = v16;
                _os_log_error_impl(&dword_193671000, v20, OS_LOG_TYPE_ERROR, "%{public}s Unknown tuning key encountered: %@\n", buf, 0x16u);
              }
            }
          }
          id v12 = (id)[v11 countByEnumeratingWithState:&v21 objects:v29 count:16];
        }
        while (v12);
        if (v13) {
          return v10;
        }
        else {
          return 0;
        }
      }
    }
  }
  return result;
}

double expandFromCenter(double a1, double a2, double a3, double a4, double a5, double a6)
{
  float v6 = a5 - a3;
  float v7 = a6 - a4;
  CGRect v10 = CGRectInset(*(CGRect *)&a1, (float)(v6 * -0.5), (float)(v7 * -0.5));
  double v8 = floor(COERCE_DOUBLE(CGRectIntegral(v10)) * 0.5);
  return v8 + v8;
}

CIVector *orientedPupilFromLandmarks(void *a1, void *a2, uint64_t a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if ([a2 requestRevision] == 3 && objc_msgSend(a2, "leftPupil") && objc_msgSend(a2, "rightPupil"))
  {
    if (a3) {
      float v6 = (void *)[a2 rightPupil];
    }
    else {
      float v6 = (void *)[a2 leftPupil];
    }
  }
  else if (a3)
  {
    float v6 = (void *)[a2 rightEye];
  }
  else
  {
    float v6 = (void *)[a2 leftEye];
  }
  id v7 = CIVNLandmarkInOrientedImage(v6, a1);
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  uint64_t v8 = [v7 countByEnumeratingWithState:&v18 objects:v22 count:16];
  if (v8)
  {
    uint64_t v9 = v8;
    uint64_t v10 = *(void *)v19;
    double v11 = 0.0;
    double v12 = 0.0;
    do
    {
      for (uint64_t i = 0; i != v9; ++i)
      {
        if (*(void *)v19 != v10) {
          objc_enumerationMutation(v7);
        }
        uint64_t v14 = *(void **)(*((void *)&v18 + 1) + 8 * i);
        [v14 X];
        double v12 = v12 + v15;
        [v14 Y];
        double v11 = v11 + v16;
      }
      uint64_t v9 = [v7 countByEnumeratingWithState:&v18 objects:v22 count:16];
    }
    while (v9);
  }
  else
  {
    double v11 = 0.0;
    double v12 = 0.0;
  }
  return +[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", v12 / (double)(unint64_t)[v7 count], v11 / (double)(unint64_t)objc_msgSend(v7, "count"));
}

uint64_t semanticPupils(void *a1, void *a2, uint64_t a3, void *a4, void *a5, uint64_t a6, uint64_t a7)
{
  v31[3] = *MEMORY[0x1E4F143B8];
  char v13 = +[CIKernel kernelWithInternalRepresentation:&CI::_resp_previs];
  [a4 extent];
  v31[0] = a4;
  v31[1] = a6;
  v31[2] = &unk_1EE4AB650;
  long long v18 = -[CIColorKernel applyWithExtent:arguments:](v13, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v31 count:3], v14, v15, v16, v17);
  [a5 extent];
  v30[0] = a5;
  v30[1] = a7;
  v30[2] = &unk_1EE4AB650;
  uint64_t v23 = -[CIColorKernel applyWithExtent:arguments:](v13, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v30 count:3], v19, v20, v21, v22);
  long long v24 = (void *)[a2 faceSegments];
  double v25 = segmentationCentroidInImage(v24, v18, a1);
  double v27 = v26;
  v29[0] = +[CIVector vectorWithCGPoint:segmentationCentroidInImage(v24, v23, a1)];
  v29[1] = +[CIVector vectorWithCGPoint:](CIVector, "vectorWithCGPoint:", v25, v27);
  return [MEMORY[0x1E4F1C978] arrayWithObjects:v29 count:2];
}

uint64_t semanticPupilsForFaceObservation(void *a1, void *a2, uint64_t a3)
{
  BOOL v5 = probabilitiesForSegment((void *)[a2 faceSegments], 480, a3);
  float v6 = (void *)[v5 objectAtIndexedSubscript:0];
  id v7 = (void *)[v5 objectAtIndexedSubscript:1];
  uint64_t v8 = [v5 objectAtIndexedSubscript:2];
  uint64_t v10 = [v5 objectAtIndexedSubscript:3];

  return semanticPupils(a1, a2, v9, v6, v7, v8, v10);
}

void *axesForEyePointsV2(void *result)
{
  v17[2] = *MEMORY[0x1E4F143B8];
  if (result)
  {
    uint64_t v1 = result;
    if ((unint64_t)[result count] >= 8)
    {
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 4), "X");
      double v3 = v2;
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 0), "X");
      double v5 = (v3 - v4) * 0.5;
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 4), "Y");
      double v7 = v6;
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 0), "Y");
      uint64_t v9 = +[CIVector vectorWithX:v5 Y:(v7 - v8) * 0.5];
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 2), "X");
      double v11 = v10;
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 6), "X");
      double v13 = (v11 - v12) * 0.5;
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 2), "Y");
      double v15 = v14;
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 6), "Y");
      v17[0] = v9;
      v17[1] = [+[CIVector vectorWithX:v13 Y:(v15 - v16) * 0.5] _orthonormalizeTo:v9];
      return (void *)[MEMORY[0x1E4F1C978] arrayWithObjects:v17 count:2];
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void *axesForEyePointsV3(void *result)
{
  v25[2] = *MEMORY[0x1E4F143B8];
  if (result)
  {
    uint64_t v1 = result;
    if ((unint64_t)[result count] >= 6)
    {
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 3), "X");
      double v3 = v2;
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 0), "X");
      double v5 = (v3 - v4) * 0.5;
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 3), "Y");
      double v7 = v6;
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 0), "Y");
      uint64_t v9 = +[CIVector vectorWithX:v5 Y:(v7 - v8) * 0.5];
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 1), "X");
      double v11 = v10;
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 2), "X");
      double v13 = v11 + v12;
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 4), "X");
      double v15 = v14;
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 5), "X");
      double v17 = ((v15 + v16) * -0.5 + v13 * 0.5) * 0.5;
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 1), "Y");
      double v19 = v18;
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 2), "Y");
      double v21 = v19 + v20;
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 4), "Y");
      double v23 = v22;
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 5), "Y");
      v25[0] = v9;
      v25[1] = [+[CIVector vectorWithX:v17 Y:((v23 + v24) * -0.5 + v21 * 0.5) * 0.5] _orthonormalizeTo:v9];
      return (void *)[MEMORY[0x1E4F1C978] arrayWithObjects:v25 count:2];
    }
    else
    {
      return 0;
    }
  }
  return result;
}

float areaForAxes(void *a1, void *a2)
{
  [a1 _norm];
  float v4 = v3;
  [a2 _norm];
  return v4 * 3.14159265 * v5;
}

void repairROIforEyePoints(void *a1, void *a2, float *a3)
{
  v22.origin.CGFloat x = CIVNBoundingRect(a1);
  CGRect v23 = CGRectIntegral(v22);
  CGFloat x = v23.origin.x;
  CGFloat y = v23.origin.y;
  CGFloat width = v23.size.width;
  CGFloat height = v23.size.height;
  double v9 = *a3;
  objc_msgSend((id)objc_msgSend(a2, "objectAtIndexedSubscript:", 0), "X");
  double v11 = fabs(v10 * v9);
  double v12 = a3[1];
  objc_msgSend((id)objc_msgSend(a2, "objectAtIndexedSubscript:", 1), "X");
  float v14 = v11 + fabs(v13 * v12);
  double v15 = *a3;
  objc_msgSend((id)objc_msgSend(a2, "objectAtIndexedSubscript:", 0), "Y");
  double v17 = fabs(v16 * v15);
  double v18 = a3[1];
  objc_msgSend((id)objc_msgSend(a2, "objectAtIndexedSubscript:", 1), "Y");
  float v20 = v17 + fabs(v19 * v18);
  if (CI_LOG_DUALRED())
  {
    double v21 = ci_logger_api();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      repairROIforEyePoints_cold_1(v21, v14, v20);
    }
  }
  v24.origin.CGFloat x = x;
  v24.origin.CGFloat y = y;
  v24.size.CGFloat width = width;
  v24.size.CGFloat height = height;
  CGRect v25 = CGRectInset(v24, (float)-v14, (float)-v20);
  v25.origin.CGFloat x = floor(v25.origin.x * 0.5);
  v25.origin.CGFloat x = v25.origin.x + v25.origin.x;
  v25.origin.CGFloat y = floor(v25.origin.y * 0.5);
  v25.origin.CGFloat y = v25.origin.y + v25.origin.y;
  v25.size.CGFloat width = floor(v25.size.width * 0.5);
  v25.size.CGFloat width = v25.size.width + v25.size.width;
  v25.size.CGFloat height = floor(v25.size.height * 0.5);
  v25.size.CGFloat height = v25.size.height + v25.size.height;
  CGRectIntegral(v25);
}

uint64_t focusStatsForRegion(double a1, double a2, double a3, double a4, uint64_t a5, void *a6, void *a7)
{
  v41[1] = *MEMORY[0x1E4F143B8];
  uint64_t v32 = 0;
  int v33 = &v32;
  uint64_t v34 = 0x4012000000;
  uint64_t v35 = __Block_byref_object_copy__5;
  uint64_t v36 = __Block_byref_object_dispose__5;
  float v37 = "";
  uint64_t v40 = *MEMORY[0x1E4F24D20];
  v41[0] = MEMORY[0x1E4F1CC08];
  CFDictionaryRef v13 = (const __CFDictionary *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v41 forKeys:&v40 count:1];
  CVPixelBufferRef pixelBufferOut = 0;
  float v14 = ceil(a1 / 6.0) * 6.0;
  float v15 = floor((a1 + a3) / 6.0) * 6.0;
  double v16 = ceil(a2 * 0.5);
  float v17 = v16 + v16;
  double v18 = floor((a2 + a4) * 0.5);
  *(float *)&double v18 = v18 + v18;
  float v19 = v15 - v14;
  float v20 = *(float *)&v18 - v17;
  if (CVPixelBufferCreate(0, (unint64_t)(float)(v15 - v14), (unint64_t)(float)(*(float *)&v18 - v17), 0x4C303038u, v13, &pixelBufferOut))
  {
    if (CI_LOG_DUALRED())
    {
      double v21 = ci_logger_api();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        focusStatsForRegion_cold_1(v21);
      }
    }
  }
  else
  {
    uint64_t v38 = *MEMORY[0x1E4F24C18];
    uint64_t v39 = *MEMORY[0x1E4F24C40];
    CFDictionaryRef v22 = (const __CFDictionary *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v39 forKeys:&v38 count:1];
    CVBufferSetAttachments(pixelBufferOut, v22, kCVAttachmentMode_ShouldPropagate);
    CGRect v23 = objc_msgSend(a7, "imageByCroppingToRect:", v14, v17, v19, v20);
    CGAffineTransformMakeTranslation(&v30, -v14, -v17);
    uint64_t v24 = objc_msgSend((id)objc_msgSend(v23, "imageByApplyingTransform:", &v30), "imageByApplyingFilter:", @"CILinearToSRGBToneCurve");
    size_t Width = CVPixelBufferGetWidth(pixelBufferOut);
    size_t Height = CVPixelBufferGetHeight(pixelBufferOut);
    objc_msgSend(a6, "render:toCVPixelBuffer:bounds:colorSpace:", v24, pixelBufferOut, 0, 0.0, 0.0, (double)Width, (double)Height);
    v29[0] = MEMORY[0x1E4F143A8];
    v29[1] = 3221225472;
    void v29[2] = __focusStatsForRegion_block_invoke;
    v29[3] = &unk_1E57717F8;
    v29[4] = &v32;
    PixelBufferApplyPlaneReadOnlyBlock(pixelBufferOut, (uint64_t)v29);
    if (pixelBufferOut) {
      CFRelease(pixelBufferOut);
    }
  }
  uint64_t v27 = v33[6];
  _Block_object_dispose(&v32, 8);
  return v27;
}

void sub_193759610(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
}

__n128 __Block_byref_object_copy__5(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  return result;
}

void __focusStatsForRegion_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, int a6)
{
  uint64_t v75 = *MEMORY[0x1E4F143B8];
  if (!a3)
  {
    uint64_t v8 = 0;
    float v9 = 0.0;
    if (a4 >= 3 && a5 >= 3)
    {
      bzero(v74, 0x800uLL);
      bzero(v73, 0x400uLL);
      if ((int)a5 > 4)
      {
        uint64_t v13 = a2 + 2 * a6 + 1;
        int v14 = 2;
        do
        {
          a2 += a6;
          if ((int)a4 >= 5)
          {
            float v15 = (unsigned __int8 *)(a2 + 1);
            double v16 = (unsigned __int8 *)v13;
            int v17 = a4 - 4;
            do
            {
              double v18 = v15;
              unint64_t v19 = *v15;
              unsigned int v20 = *(v15 - 1);
              unsigned int v22 = *++v15;
              unsigned int v21 = v22;
              unsigned int v23 = v18[-a6];
              unsigned int v25 = *v16++;
              unsigned int v24 = v25;
              ++v73[v19];
              if (v19 <= 0xF0 && v20 <= 0xF0 && v21 <= 0xF0 && v23 <= 0xF0 && v24 <= 0xF0)
              {
                int v26 = ((v20 + v21 + v23 + v24 + 2) >> 2) - v19 + 256;
                ++v74[v26];
              }
              --v17;
            }
            while (v17);
          }
          v13 += a6;
        }
        while (v14++ != a5 - 3);
      }
      uint64_t v28 = 0;
      int32x4_t v29 = (int32x4_t)xmmword_19394C9F0;
      int32x4_t v30 = 0uLL;
      v31.i64[0] = 0x400000004;
      v31.i64[1] = 0x400000004;
      int64x2_t v32 = 0uLL;
      int64x2_t v33 = 0uLL;
      do
      {
        int32x4_t v34 = *(int32x4_t *)&v74[v28];
        int32x4_t v30 = vaddq_s32(v34, v30);
        uint32x4_t v35 = (uint32x4_t)vmulq_s32(v34, v29);
        int64x2_t v33 = (int64x2_t)vaddw_high_u32((uint64x2_t)v33, v35);
        int64x2_t v32 = (int64x2_t)vaddw_u32((uint64x2_t)v32, *(uint32x2_t *)v35.i8);
        int32x4_t v29 = vaddq_s32(v29, v31);
        v28 += 4;
      }
      while (v28 != 512);
      uint64_t v36 = 0;
      int v37 = vaddvq_s32(v30);
      float64x2_t v38 = (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)vaddvq_s64(vaddq_s64(v32, v33)) / (double)v37), 0);
      int32x4_t v39 = (int32x4_t)xmmword_19394C9F0;
      double v40 = 0.0;
      v41.i64[0] = 0x400000004;
      v41.i64[1] = 0x400000004;
      do
      {
        v42.i64[0] = v39.i32[0];
        v42.i64[1] = v39.i32[1];
        float64x2_t v43 = vcvtq_f64_s64(v42);
        v42.i64[0] = v39.i32[2];
        v42.i64[1] = v39.i32[3];
        float64x2_t v44 = vsubq_f64(vcvtq_f64_s64(v42), v38);
        float64x2_t v45 = vsubq_f64(v43, v38);
        long long v46 = *(_OWORD *)&v74[v36];
        v42.i64[0] = v46;
        v42.i64[1] = DWORD1(v46);
        float64x2_t v47 = vcvtq_f64_u64((uint64x2_t)v42);
        v42.i64[0] = DWORD2(v46);
        v42.i64[1] = HIDWORD(v46);
        float64x2_t v48 = vmulq_f64(vmulq_f64(v44, v44), vcvtq_f64_u64((uint64x2_t)v42));
        float64x2_t v49 = vmulq_f64(vmulq_f64(v45, v45), v47);
        double v40 = v40 + v49.f64[0] + v49.f64[1] + v48.f64[0] + v48.f64[1];
        int32x4_t v39 = vaddq_s32(v39, v41);
        v36 += 4;
      }
      while (v36 != 512);
      uint64_t v50 = 0;
      int64x2_t v51 = 0uLL;
      int8x16_t v52 = (int8x16_t)vdupq_n_s64(1uLL);
      int64x2_t v53 = 0uLL;
      do
      {
        int32x4_t v54 = vtstq_s32(*(int32x4_t *)&v74[v50], *(int32x4_t *)&v74[v50]);
        v55.i64[0] = v54.u32[0];
        v55.i64[1] = v54.u32[1];
        int64x2_t v56 = (int64x2_t)vandq_s8(v55, v52);
        v55.i64[0] = v54.u32[2];
        v55.i64[1] = v54.u32[3];
        int64x2_t v53 = vaddq_s64(v53, (int64x2_t)vandq_s8(v55, v52));
        int64x2_t v51 = vaddq_s64(v51, v56);
        v50 += 4;
      }
      while (v50 != 512);
      int64x2_t v57 = vaddq_s64(v51, v53);
      double v58 = v40 / (double)v37;
      if (v37 <= 0) {
        double v58 = 0.0;
      }
      double v59 = (double)((uint64_t)(((a4 << 32) - 0x300000000) * (a5 + 4294967293u)) >> 32);
      uint64_t v60 = (uint64_t)(v59 * 0.05);
      if (v60 < 1)
      {
        int v64 = 2;
      }
      else
      {
        unint64_t v61 = 0;
        for (uint64_t i = 0; i < v60; i += v73[v61++])
        {
          int v63 = v61 + 1;
          if (v61 > 0xFE) {
            break;
          }
        }
        int v64 = 2 - v63;
      }
      uint64_t v65 = vaddvq_s64(v57);
      uint64_t v66 = (uint64_t)(v59 * 0.05);
      if (v66 < 1)
      {
        int v69 = 255;
      }
      else
      {
        uint64_t v67 = 0;
        int v68 = 255;
        do
        {
          int v69 = v68 - 1;
          if (!v68) {
            break;
          }
          v67 += v73[v68--];
        }
        while (v67 < v66);
      }
      float v70 = (double)(v69 + v64) / 255.0;
      double v71 = v70;
      float v9 = 0.0;
      if (v71 > 0.00001) {
        float v9 = v58 / v71;
      }
      uint64_t v8 = v65;
    }
    uint64_t v72 = *(void *)(*(void *)(a1 + 32) + 8);
    *(void *)(v72 + 48) = LODWORD(v9);
    *(void *)(v72 + 56) = v8;
  }
}

uint64_t dumpfilepathWithTag(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v6 = objc_alloc_init(MEMORY[0x1E4F28C10]);
  [v6 setDateFormat:@"YYYY_MM_dd__HH_mm_ss_SSS"];
  uint64_t v7 = [v6 stringFromDate:a3];
  uint64_t v8 = (void *)[NSString stringWithFormat:@"%@__IMG__%@__redeye%@", @"/var/mobile/Media/DCIM/", v7, a1];

  return [v8 stringByAppendingString:a2];
}

uint64_t dump(void *a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v6 = [MEMORY[0x1E4F1CB10] fileURLWithPath:dumpfilepathWithTag(a2, @".tiff", a4)];
  uint64_t v7 = [a1 colorSpace];
  uint64_t v8 = MEMORY[0x1E4F1CC08];

  return [a3 writeTIFFRepresentationOfImage:a1 toURL:v6 format:264 colorSpace:v7 options:v8 error:0];
}

uint64_t dump420f(__CVBuffer *a1, uint64_t a2, uint64_t a3)
{
  CVPixelBufferLockBaseAddress(a1, 1uLL);
  id v6 = objc_alloc_init(MEMORY[0x1E4F1CA58]);
  if (CVPixelBufferGetPlaneCount(a1))
  {
    size_t v7 = 0;
    do
    {
      BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(a1, v7);
      size_t HeightOfPlane = CVPixelBufferGetHeightOfPlane(a1, v7);
      objc_msgSend(v6, "appendBytes:length:", BaseAddressOfPlane, CVPixelBufferGetBytesPerRowOfPlane(a1, v7++) * HeightOfPlane);
    }
    while (CVPixelBufferGetPlaneCount(a1) > v7);
  }
  [v6 writeToFile:dumpfilepathWithTag(a2, @".420f", a3), 1 atomically];

  return CVPixelBufferUnlockBaseAddress(a1, 1uLL);
}

uint64_t dumpLinearPNG(uint64_t a1, uint64_t a2)
{
  v8[1] = *MEMORY[0x1E4F143B8];
  size_t v7 = @"working_color_space";
  v8[0] = [MEMORY[0x1E4F1CA98] null];
  id v4 = +[CIContext _cachedContext:options:](CIContext, "_cachedContext:options:", @"DualReEye_dumpLinearPNG", [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v8 forKeys:&v7 count:1]);
  {
    dumpLinearPNG::cs = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC88]);
  }
  uint64_t v5 = [MEMORY[0x1E4F1CB10] fileURLWithPath:a2];
  return [v4 writePNGRepresentationOfImage:a1 toURL:v5 format:264 colorSpace:dumpLinearPNG::cs options:MEMORY[0x1E4F1CC08] error:0];
}

void sub_193759D8C(_Unwind_Exception *a1)
{
}

double cikernel::_resp_previs(float a1, double a2, float a3)
{
  BOOL v3 = *(float *)&a2 <= a3;
  LODWORD(a2) = 1.0;
  if (!v3) {
    *(float *)&a2 = 0.0;
  }
  *(float *)&a2 = *(float *)&a2 * a1;
  *(void *)&double result = vdupq_lane_s32(*(int32x2_t *)&a2, 0).u64[0];
  return result;
}

uint64_t CIGLIsUsable()
{
  if (getGLWrapperSymbols_once != -1) {
    dispatch_once(&getGLWrapperSymbols_once, &__block_literal_global_22);
  }

  return wrapGLIsUsable();
}

uint64_t GetMacroContext@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  if (getGLWrapperSymbols_once != -1) {
    dispatch_once(&getGLWrapperSymbols_once, &__block_literal_global_22);
  }

  return wrapGetMacroContext(a1, a2);
}

uint64_t CIEAGLContextGetAPI(void *a1)
{
  if (getGLWrapperSymbols_once != -1) {
    dispatch_once(&getGLWrapperSymbols_once, &__block_literal_global_22);
  }

  return wrapGetContextAPI(a1);
}

uint64_t CIGLGetFormatInfo(int a1, int a2)
{
  if (getGLWrapperSymbols_once != -1) {
    dispatch_once(&getGLWrapperSymbols_once, &__block_literal_global_22);
  }
  return wrapGetFormatInfo(a1, a2);
}

void *CIEAGLContextCreate(int a1, void *a2)
{
  if (getGLWrapperSymbols_once != -1) {
    dispatch_once(&getGLWrapperSymbols_once, &__block_literal_global_22);
  }

  return wrapEAGLContextCreate(a1, a2);
}

void *CIEAGLContextSetParameter(void *a1, uint64_t a2, int a3)
{
  if (getGLWrapperSymbols_once != -1) {
    dispatch_once(&getGLWrapperSymbols_once, &__block_literal_global_22);
  }

  return wrapEAGLContextSetParameter(a1, a2, a3);
}

void *CIEAGLContextSetBackgroundEnabled(void *a1, int a2)
{
  if (getGLWrapperSymbols_once != -1) {
    dispatch_once(&getGLWrapperSymbols_once, &__block_literal_global_22);
  }

  return wrapEAGLContextSetBackgroundEnabled(a1, a2);
}

void *CIEAGLContextRetain(void *a1)
{
  if (getGLWrapperSymbols_once != -1) {
    dispatch_once(&getGLWrapperSymbols_once, &__block_literal_global_22);
  }

  return wrapEAGLContextRetain(a1);
}

void CIEAGLContextRelease(void *a1)
{
  if (getGLWrapperSymbols_once != -1) {
    dispatch_once(&getGLWrapperSymbols_once, &__block_literal_global_22);
  }

  wrapEAGLContextRelease(a1);
}

uint64_t CIEAGLContextTexImageIOSurface(void *a1, GLenum a2, uint64_t a3, uint64_t a4, GLint a5, signed int a6, signed int a7, __IOSurface *a8, unsigned int a9)
{
  if (getGLWrapperSymbols_once != -1) {
    dispatch_once(&getGLWrapperSymbols_once, &__block_literal_global_22);
  }

  return wrapEAGLContextTexImageIOSurface(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

uint64_t is_gpu_A9_or_higher()
{
  if (getGLWrapperSymbols_once != -1) {
    dispatch_once(&getGLWrapperSymbols_once, &__block_literal_global_22);
  }

  return wrapIsA9_or_higher();
}

void cikernel::_jointBilateral(uint64_t a1, uint64_t a2, int8x16_t a3)
{
  DC = (CI *)CI::getDC((CI *)a1);
  float32x2_t v6 = *(float32x2_t *)DC;
  size_t v7 = (float32x2_t *)CI::getDC(DC);
  *(float *)v8.f64 = *(float *)(a1 + 24)
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *v7, 1), *(float *)(a1 + 16), COERCE_FLOAT(*v7));
  *((float *)v8.f64 + 1) = *(float *)(a1 + 36)
                         + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *v7, 1), *(float *)(a1 + 28), COERCE_FLOAT(*v7));
  float64x2_t v59 = v8;
  float v9 = (float32x2_t *)CI::getDC((CI *)v7);
  float v10 = *(float *)(a2 + 16);
  float v11 = *(float *)(a2 + 20);
  v12.i32[0] = *(_DWORD *)(a2 + 24);
  v13.i32[0] = *(_DWORD *)(a2 + 28);
  *(float *)v14.f64 = *(float *)v12.i32 + vmlas_n_f32(vmuls_lane_f32(v11, *v9, 1), v10, COERCE_FLOAT(*v9));
  LODWORD(v15) = *(_DWORD *)(a2 + 32);
  v16.i32[0] = *(_DWORD *)(a2 + 36);
  *((float *)v14.f64 + 1) = *(float *)v16.i32
                          + vmlas_n_f32(vmuls_lane_f32(*(float *)&v15, *v9, 1), *(float *)v13.i32, COERCE_FLOAT(*v9));
  float64x2_t v58 = v14;
  __asm { FMOV            V0.2S, #1.0 }
  float32x2_t v22 = vadd_f32(v6, _D0);
  v23.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v22, 1), *(float *)(a1 + 16), v22.f32[0]);
  v23.f32[1] = *(float *)(a1 + 36)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v22, 1), *(float *)(a1 + 28), v22.f32[0]);
  float32x2_t v24 = vsub_f32(v23, *(float32x2_t *)&v59.f64[0]);
  *(float *)v25.f64 = *(float *)v12.i32 + vmlas_n_f32(vmuls_lane_f32(v11, v22, 1), v10, v22.f32[0]);
  *(float *)&double v26 = vmlas_n_f32(vmuls_lane_f32(*(float *)&v15, v22, 1), *(float *)v13.i32, v22.f32[0]);
  *((float *)v25.f64 + 1) = *(float *)v16.i32 + *(float *)&v26;
  float32x2_t v27 = vsub_f32(*(float32x2_t *)&v25.f64[0], *(float32x2_t *)&v14.f64[0]);
  CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v59.f64[0], v25, v26, v15, v12, v13, v16);
  *(double *)v34.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v58.f64[0], v28, v29, v30, v31, v32, v33);
  float32x4_t v57 = v34;
  float32x2_t v35 = (float32x2_t)vextq_s8(a3, a3, 8uLL).u64[0];
  float32x4_t v36 = 0uLL;
  int v37 = -2;
  *(void *)&long long v38 = 0;
  float32x2_t v56 = v35;
  do
  {
    for (int i = -2; i != 3; ++i)
    {
      long long v62 = v38;
      float32x4_t v63 = v36;
      v40.f32[0] = (float)v37;
      v40.f32[1] = (float)i;
      float32x2_t v41 = vmul_f32(v35, v40);
      float v42 = expf(-(float)((float)((float)(v40.f32[1] * v40.f32[1]) + (float)((float)v37 * (float)v37))
                        * *(float *)&a3.i32[1]));
      *(double *)v48.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v59.f64[0], vmul_f32(v24, v41))), v59, v43, v44, v45, v46, v47);
      float32x4_t v61 = v48;
      float v54 = vsubq_f32((float32x4_t)vdupq_lane_s32(COERCE_INT32X2_T(CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v58.f64[0], vmul_f32(v27, v41))), v58, v49, v50, v51, v52, v53)), 1), v57).f32[0];
      float v55 = expf(*(float *)a3.i32 * (float)((float)-v54 * v54));
      float32x2_t v35 = v56;
      long long v38 = v62;
      *(float *)&long long v38 = *(float *)&v62 + (float)(v55 * v42);
      float32x4_t v36 = vaddq_f32(v63, vmulq_n_f32(v61, v42 * v55));
    }
    ++v37;
  }
  while (v37 != 3);
}

void cikernel::_jointBilateralRG(uint64_t a1, int8x16_t a2)
{
  DC = (CI *)CI::getDC((CI *)a1);
  float32x2_t v4 = *(float32x2_t *)DC;
  uint64_t v5 = (float32x2_t *)CI::getDC(DC);
  float v6 = *(float *)(a1 + 16);
  float v7 = *(float *)(a1 + 20);
  v8.i32[0] = *(_DWORD *)(a1 + 24);
  v9.i32[0] = *(_DWORD *)(a1 + 28);
  v10.i32[0] = *(_DWORD *)(a1 + 32);
  float v11 = *(float *)(a1 + 36);
  *(float *)v12.f64 = *(float *)v8.i32 + vmlas_n_f32(vmuls_lane_f32(v7, *v5, 1), v6, COERCE_FLOAT(*v5));
  *((float *)v12.f64 + 1) = v11
                          + vmlas_n_f32(vmuls_lane_f32(*(float *)v10.i32, *v5, 1), *(float *)v9.i32, COERCE_FLOAT(*v5));
  __asm { FMOV            V3.2S, #1.0 }
  float32x2_t v18 = vadd_f32(v4, _D3);
  *(float *)v19.f64 = *(float *)v8.i32 + vmlas_n_f32(vmuls_lane_f32(v7, v18, 1), v6, v18.f32[0]);
  *(float *)&double v20 = v11 + vmlas_n_f32(vmuls_lane_f32(*(float *)v10.i32, v18, 1), *(float *)v9.i32, v18.f32[0]);
  HIDWORD(v19.f64[0]) = LODWORD(v20);
  float32x2_t v21 = vsub_f32(*(float32x2_t *)&v19.f64[0], *(float32x2_t *)&v12.f64[0]);
  float64x2_t v39 = v12;
  *(double *)v22.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v12.f64[0], v19, v20, *(double *)&v18, v8, v9, v10);
  float32x4_t v40 = v22;
  float32x2_t v23 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  float32x2_t v24 = 0;
  int v25 = -2;
  *(void *)&long long v26 = 0;
  float32x2_t v38 = v23;
  do
  {
    for (int i = -2; i != 3; ++i)
    {
      long long v43 = v26;
      v28.f32[0] = (float)v25;
      v28.f32[1] = (float)i;
      float32x2_t v29 = vmul_f32(v23, v28);
      float v30 = expf(-(float)((float)((float)(v28.f32[1] * v28.f32[1]) + (float)((float)v25 * (float)v25))
                        * *(float *)&a2.i32[1]));
      *(double *)v36.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v39.f64[0], vmul_f32(v21, v29))), v39, v31, v32, v33, v34, v35);
      float32x2_t v42 = (float32x2_t)vextq_s8(v36, v36, 8uLL).u64[0];
      *(float *)v36.i32 = vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.i8, 1), v40).f32[0];
      float v37 = expf(*(float *)a2.i32 * (float)((float)-*(float *)v36.i32 * *(float *)v36.i32));
      float32x2_t v23 = v38;
      long long v26 = v43;
      *(float *)&long long v26 = *(float *)&v43 + (float)(v37 * v30);
      float32x2_t v24 = vadd_f32(v24, vmul_n_f32(v42, v30 * v37));
    }
    ++v25;
  }
  while (v25 != 3);
}

double cikernel::_guideCombine(float a1, float a2)
{
  return COERCE_DOUBLE(__PAIR64__(LODWORD(a2), LODWORD(a1)));
}

double cikernel::_guideCombine4(int32x4_t a1, int32x4_t a2)
{
  *(void *)&double result = vzip1q_s32(a1, a2).u64[0];
  return result;
}

__n64 cikernel::_guideMono(float32x4_t a1)
{
  float32x4_t v1 = vmulq_f32(a1, (float32x4_t)vdupq_n_s32(0x3EAAA64Cu));
  float v2 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1, 2), vaddq_f32(v1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v1.f32, 1))).f32[0];
  if (v2 <= 1.0) {
    float v3 = v2;
  }
  else {
    float v3 = 1.0;
  }
  BOOL v4 = v2 < 0.0;
  result.n64_u32[0] = 0;
  if (!v4) {
    result.n64_f32[0] = v3;
  }
  result.n64_u32[1] = 0;
  return result;
}

double cikernel::_edgeWork(float32x4_t a1, float32x4_t a2)
{
  float v2 = 1000.0 * vsubq_f32(a1, a2).f32[0];
  float v3 = 1.0;
  if (v2 <= 1.0) {
    float v3 = v2;
  }
  BOOL v4 = v2 < 0.0;
  int32x2_t v5 = 0;
  if (!v4) {
    *(float *)v5.i32 = v3;
  }
  *(void *)&double result = vdupq_lane_s32(v5, 0).u64[0];
  return result;
}

double cikernel::_edgeWorkContrast(float32x4_t a1, float a2)
{
  v2.i64[0] = 0xBF000000BF000000;
  v2.i64[1] = 0xBF000000BF000000;
  float32x4_t v3 = vmulq_n_f32(vaddq_f32(a1, v2), a2);
  v4.i64[0] = 0x3F0000003F000000;
  v4.i64[1] = 0x3F0000003F000000;
  float32x4_t v5 = vmaxnmq_f32(vaddq_f32(v3, v4), (float32x4_t)0);
  __asm { FMOV            V1.4S, #1.0 }
  *(void *)&double result = vminnmq_f32(v5, _Q1).u64[0];
  return result;
}

double cikernel::_edges(cikernel *this, SamplerObj *a2, float a3)
{
  float32x2_t v4 = *(float32x2_t *)CI::getDC(this);
  float32x2_t v5 = vadd_f32(v4, (float32x2_t)0xBF80000000000000);
  *(float *)&double v6 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v5, 1), *((float *)this + 4), v5.f32[0]);
  LODWORD(v7) = *((_DWORD *)this + 7);
  v8.i32[0] = *((_DWORD *)this + 9);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *((float *)this + 6) + *(float *)&v6;
  *(float *)v10.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v5, v10, v6, v7, v9, v8, v11);
  float32x4_t v42 = v12;
  *(float32x2_t *)v12.f32 = vadd_f32(v4, (float32x2_t)0xBF8000003F800000);
  *(float *)&double v13 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v12.f32, 1), *((float *)this + 4), v12.f32[0]);
  LODWORD(v14) = *((_DWORD *)this + 7);
  v15.i32[0] = *((_DWORD *)this + 9);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v12.f32, 1), *(float *)&v14, v12.f32[0]);
  v12.f32[0] = *((float *)this + 6) + *(float *)&v13;
  *(float *)v17.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v12.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v12.i64, v17, v13, v14, v16, v15, v18);
  float32x4_t v41 = v19;
  *(float32x2_t *)v19.f32 = vadd_f32(v4, (float32x2_t)1065353216);
  *(float *)&double v20 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v19.f32, 1), *((float *)this + 4), v19.f32[0]);
  LODWORD(v21) = *((_DWORD *)this + 7);
  v22.i32[0] = *((_DWORD *)this + 9);
  *(float *)v23.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v19.f32, 1), *(float *)&v21, v19.f32[0]);
  v19.f32[0] = *((float *)this + 6) + *(float *)&v20;
  *(float *)v24.f64 = *(float *)v22.i32 + *(float *)v23.i32;
  v19.f32[1] = *(float *)v22.i32 + *(float *)v23.i32;
  *(double *)v26.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v19.i64, v24, v20, v21, v23, v22, v25);
  float32x4_t v40 = v26;
  DC = (float32x2_t *)CI::getDC(v27);
  *(float *)&double v29 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *DC, 1), *((float *)this + 4), COERCE_FLOAT(*DC));
  LODWORD(v30) = *((_DWORD *)this + 7);
  v31.i32[0] = *((_DWORD *)this + 9);
  *(float *)v32.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *DC, 1), *(float *)&v30, COERCE_FLOAT(*DC));
  *(float *)&double v33 = *((float *)this + 6) + *(float *)&v29;
  *(float *)v34.f64 = *(float *)v31.i32 + *(float *)v32.i32;
  *((float *)&v33 + 1) = *(float *)v31.i32 + *(float *)v32.i32;
  *(double *)v36.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v33, v34, v29, v30, v32, v31, v35);
  float32x4_t v37 = vsubq_f32(v36, v41);
  float32x4_t v38 = vsubq_f32(v42, v40);
  *(void *)&double result = vmulq_n_f32(vaddq_f32(vmulq_f32(v38, v38), vmulq_f32(v37, v37)), a3).u64[0];
  return result;
}

double cikernel::_gabor(cikernel *this, SamplerObj *a2)
{
  float32x2_t v3 = *(float32x2_t *)CI::getDC(this);
  float32x2_t v4 = vadd_f32(v3, (float32x2_t)0x40000000BF800000);
  *(float *)&double v5 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v4, 1), *((float *)this + 4), v4.f32[0]);
  LODWORD(v6) = *((_DWORD *)this + 7);
  v7.i32[0] = *((_DWORD *)this + 9);
  *(float *)v8.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v4, 1), *(float *)&v6, v4.f32[0]);
  v4.f32[0] = *((float *)this + 6) + *(float *)&v5;
  *(float *)v9.f64 = *(float *)v7.i32 + *(float *)v8.i32;
  v4.f32[1] = *(float *)v7.i32 + *(float *)v8.i32;
  *(double *)v11.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v4, v9, v5, v6, v8, v7, v10);
  float32x4_t v188 = v11;
  *(float32x2_t *)v11.f32 = vadd_f32(v3, (float32x2_t)0x40400000BF800000);
  *(float *)&double v12 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v11.f32, 1), *((float *)this + 4), v11.f32[0]);
  LODWORD(v13) = *((_DWORD *)this + 7);
  v14.i32[0] = *((_DWORD *)this + 9);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v11.f32, 1), *(float *)&v13, v11.f32[0]);
  v11.f32[0] = *((float *)this + 6) + *(float *)&v12;
  *(float *)v16.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v11.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)v18.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v11.i64, v16, v12, v13, v15, v14, v17);
  float32x4_t v187 = v18;
  *(float32x2_t *)v18.f32 = vadd_f32(v3, (float32x2_t)0x400000003F800000);
  *(float *)&double v19 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v18.f32, 1), *((float *)this + 4), v18.f32[0]);
  LODWORD(v20) = *((_DWORD *)this + 7);
  v21.i32[0] = *((_DWORD *)this + 9);
  *(float *)v22.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v18.f32, 1), *(float *)&v20, v18.f32[0]);
  v18.f32[0] = *((float *)this + 6) + *(float *)&v19;
  *(float *)v23.f64 = *(float *)v21.i32 + *(float *)v22.i32;
  v18.f32[1] = *(float *)v21.i32 + *(float *)v22.i32;
  *(double *)v25.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v18.i64, v23, v19, v20, v22, v21, v24);
  float32x4_t v186 = v25;
  *(float32x2_t *)v25.f32 = vadd_f32(v3, (float32x2_t)0x3F800000C0000000);
  *(float *)&double v26 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v25.f32, 1), *((float *)this + 4), v25.f32[0]);
  LODWORD(v27) = *((_DWORD *)this + 7);
  v28.i32[0] = *((_DWORD *)this + 9);
  *(float *)v29.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v25.f32, 1), *(float *)&v27, v25.f32[0]);
  v25.f32[0] = *((float *)this + 6) + *(float *)&v26;
  *(float *)v30.f64 = *(float *)v28.i32 + *(float *)v29.i32;
  v25.f32[1] = *(float *)v28.i32 + *(float *)v29.i32;
  *(double *)v32.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v25.i64, v30, v26, v27, v29, v28, v31);
  float32x4_t v185 = v32;
  *(float32x2_t *)v32.f32 = vadd_f32(v3, (float32x2_t)0x3F800000BF800000);
  *(float *)&double v33 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v32.f32, 1), *((float *)this + 4), v32.f32[0]);
  LODWORD(v34) = *((_DWORD *)this + 7);
  v35.i32[0] = *((_DWORD *)this + 9);
  *(float *)v36.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v32.f32, 1), *(float *)&v34, v32.f32[0]);
  v32.f32[0] = *((float *)this + 6) + *(float *)&v33;
  *(float *)v37.f64 = *(float *)v35.i32 + *(float *)v36.i32;
  v32.f32[1] = *(float *)v35.i32 + *(float *)v36.i32;
  *(double *)v39.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v32.i64, v37, v33, v34, v36, v35, v38);
  float32x4_t v184 = v39;
  *(float32x2_t *)v39.f32 = vadd_f32(v3, (float32x2_t)0x3F80000000000000);
  *(float *)&double v40 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v39.f32, 1), *((float *)this + 4), v39.f32[0]);
  LODWORD(v41) = *((_DWORD *)this + 7);
  v42.i32[0] = *((_DWORD *)this + 9);
  *(float *)v43.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v39.f32, 1), *(float *)&v41, v39.f32[0]);
  v39.f32[0] = *((float *)this + 6) + *(float *)&v40;
  *(float *)v44.f64 = *(float *)v42.i32 + *(float *)v43.i32;
  v39.f32[1] = *(float *)v42.i32 + *(float *)v43.i32;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v39.i64, v44, v40, v41, v43, v42, v45);
  float32x4_t v183 = _Q0;
  __asm { FMOV            V0.2S, #1.0 }
  *(float32x2_t *)_Q0.f32 = vadd_f32(v3, *(float32x2_t *)_Q0.f32);
  *(float *)&double v51 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)_Q0.f32, 1), *((float *)this + 4), _Q0.f32[0]);
  LODWORD(v52) = *((_DWORD *)this + 7);
  v53.i32[0] = *((_DWORD *)this + 9);
  *(float *)v54.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)_Q0.f32, 1), *(float *)&v52, _Q0.f32[0]);
  _Q0.f32[0] = *((float *)this + 6) + *(float *)&v51;
  *(float *)v55.f64 = *(float *)v53.i32 + *(float *)v54.i32;
  _Q0.f32[1] = *(float *)v53.i32 + *(float *)v54.i32;
  *(double *)v57.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)_Q0.i64, v55, v51, v52, v54, v53, v56);
  float32x4_t v182 = v57;
  *(float32x2_t *)v57.f32 = vadd_f32(v3, (float32x2_t)0x3F80000040000000);
  *(float *)&double v58 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v57.f32, 1), *((float *)this + 4), v57.f32[0]);
  LODWORD(v59) = *((_DWORD *)this + 7);
  v60.i32[0] = *((_DWORD *)this + 9);
  *(float *)v61.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v57.f32, 1), *(float *)&v59, v57.f32[0]);
  v57.f32[0] = *((float *)this + 6) + *(float *)&v58;
  *(float *)v62.f64 = *(float *)v60.i32 + *(float *)v61.i32;
  v57.f32[1] = *(float *)v60.i32 + *(float *)v61.i32;
  *(double *)v64.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v57.i64, v62, v58, v59, v61, v60, v63);
  float32x4_t v181 = v64;
  *(float32x2_t *)v64.f32 = vadd_f32(v3, (float32x2_t)3221225472);
  *(float *)&double v65 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v64.f32, 1), *((float *)this + 4), v64.f32[0]);
  LODWORD(v66) = *((_DWORD *)this + 7);
  v67.i32[0] = *((_DWORD *)this + 9);
  *(float *)v68.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v64.f32, 1), *(float *)&v66, v64.f32[0]);
  v64.f32[0] = *((float *)this + 6) + *(float *)&v65;
  *(float *)v69.f64 = *(float *)v67.i32 + *(float *)v68.i32;
  v64.f32[1] = *(float *)v67.i32 + *(float *)v68.i32;
  *(double *)v71.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v64.i64, v69, v65, v66, v68, v67, v70);
  float32x4_t v180 = v71;
  *(float32x2_t *)v71.f32 = vadd_f32(v3, (float32x2_t)3212836864);
  *(float *)&double v72 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v71.f32, 1), *((float *)this + 4), v71.f32[0]);
  LODWORD(v73) = *((_DWORD *)this + 7);
  v74.i32[0] = *((_DWORD *)this + 9);
  *(float *)v75.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v71.f32, 1), *(float *)&v73, v71.f32[0]);
  v71.f32[0] = *((float *)this + 6) + *(float *)&v72;
  *(float *)v76.f64 = *(float *)v74.i32 + *(float *)v75.i32;
  v71.f32[1] = *(float *)v74.i32 + *(float *)v75.i32;
  *(double *)v78.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v71.i64, v76, v72, v73, v75, v74, v77);
  float32x4_t v179 = v78;
  *(float32x2_t *)v78.f32 = vadd_f32(v3, (float32x2_t)1065353216);
  *(float *)&double v79 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v78.f32, 1), *((float *)this + 4), v78.f32[0]);
  LODWORD(v80) = *((_DWORD *)this + 7);
  v81.i32[0] = *((_DWORD *)this + 9);
  *(float *)v82.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v78.f32, 1), *(float *)&v80, v78.f32[0]);
  v78.f32[0] = *((float *)this + 6) + *(float *)&v79;
  *(float *)v83.f64 = *(float *)v81.i32 + *(float *)v82.i32;
  v78.f32[1] = *(float *)v81.i32 + *(float *)v82.i32;
  *(double *)v85.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v78.i64, v83, v79, v80, v82, v81, v84);
  float32x4_t v178 = v85;
  *(float32x2_t *)v85.f32 = vadd_f32(v3, (float32x2_t)0x40000000);
  *(float *)&double v86 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v85.f32, 1), *((float *)this + 4), v85.f32[0]);
  LODWORD(v87) = *((_DWORD *)this + 7);
  v88.i32[0] = *((_DWORD *)this + 9);
  *(float *)v89.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v85.f32, 1), *(float *)&v87, v85.f32[0]);
  v85.f32[0] = *((float *)this + 6) + *(float *)&v86;
  *(float *)v90.f64 = *(float *)v88.i32 + *(float *)v89.i32;
  v85.f32[1] = *(float *)v88.i32 + *(float *)v89.i32;
  *(double *)v92.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v85.i64, v90, v86, v87, v89, v88, v91);
  float32x4_t v177 = v92;
  *(float32x2_t *)v92.f32 = vadd_f32(v3, (float32x2_t)0xBF800000C0000000);
  *(float *)&double v93 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v92.f32, 1), *((float *)this + 4), v92.f32[0]);
  LODWORD(v94) = *((_DWORD *)this + 7);
  v95.i32[0] = *((_DWORD *)this + 9);
  *(float *)v96.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v92.f32, 1), *(float *)&v94, v92.f32[0]);
  v92.f32[0] = *((float *)this + 6) + *(float *)&v93;
  *(float *)v97.f64 = *(float *)v95.i32 + *(float *)v96.i32;
  v92.f32[1] = *(float *)v95.i32 + *(float *)v96.i32;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v92.i64, v97, v93, v94, v96, v95, v98);
  float32x4_t v176 = _Q0;
  __asm { FMOV            V0.2S, #-1.0 }
  *(float32x2_t *)_Q0.f32 = vadd_f32(v3, *(float32x2_t *)_Q0.f32);
  *(float *)&double v100 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)_Q0.f32, 1), *((float *)this + 4), _Q0.f32[0]);
  LODWORD(v101) = *((_DWORD *)this + 7);
  v102.i32[0] = *((_DWORD *)this + 9);
  *(float *)v103.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)_Q0.f32, 1), *(float *)&v101, _Q0.f32[0]);
  _Q0.f32[0] = *((float *)this + 6) + *(float *)&v100;
  *(float *)v104.f64 = *(float *)v102.i32 + *(float *)v103.i32;
  _Q0.f32[1] = *(float *)v102.i32 + *(float *)v103.i32;
  *(double *)v106.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)_Q0.i64, v104, v100, v101, v103, v102, v105);
  float32x4_t v175 = v106;
  *(float32x2_t *)v106.f32 = vadd_f32(v3, (float32x2_t)0xBF80000000000000);
  *(float *)&double v107 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v106.f32, 1), *((float *)this + 4), v106.f32[0]);
  LODWORD(v108) = *((_DWORD *)this + 7);
  v109.i32[0] = *((_DWORD *)this + 9);
  *(float *)v110.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v106.f32, 1), *(float *)&v108, v106.f32[0]);
  v106.f32[0] = *((float *)this + 6) + *(float *)&v107;
  *(float *)v111.f64 = *(float *)v109.i32 + *(float *)v110.i32;
  v106.f32[1] = *(float *)v109.i32 + *(float *)v110.i32;
  *(double *)v113.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v106.i64, v111, v107, v108, v110, v109, v112);
  float32x4_t v174 = v113;
  *(float32x2_t *)v113.f32 = vadd_f32(v3, (float32x2_t)0xBF8000003F800000);
  *(float *)&double v114 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v113.f32, 1), *((float *)this + 4), v113.f32[0]);
  LODWORD(v115) = *((_DWORD *)this + 7);
  v116.i32[0] = *((_DWORD *)this + 9);
  *(float *)v117.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v113.f32, 1), *(float *)&v115, v113.f32[0]);
  v113.f32[0] = *((float *)this + 6) + *(float *)&v114;
  *(float *)v118.f64 = *(float *)v116.i32 + *(float *)v117.i32;
  v113.f32[1] = *(float *)v116.i32 + *(float *)v117.i32;
  *(double *)v120.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v113.i64, v118, v114, v115, v117, v116, v119);
  float32x4_t v173 = v120;
  *(float32x2_t *)v120.f32 = vadd_f32(v3, (float32x2_t)0xBF80000040000000);
  *(float *)&double v121 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v120.f32, 1), *((float *)this + 4), v120.f32[0]);
  LODWORD(v122) = *((_DWORD *)this + 7);
  v123.i32[0] = *((_DWORD *)this + 9);
  *(float *)v124.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v120.f32, 1), *(float *)&v122, v120.f32[0]);
  v120.f32[0] = *((float *)this + 6) + *(float *)&v121;
  *(float *)v125.f64 = *(float *)v123.i32 + *(float *)v124.i32;
  v120.f32[1] = *(float *)v123.i32 + *(float *)v124.i32;
  *(double *)v127.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v120.i64, v125, v121, v122, v124, v123, v126);
  float32x4_t v172 = v127;
  *(float32x2_t *)v127.f32 = vadd_f32(v3, (float32x2_t)0xC0000000BF800000);
  *(float *)&double v128 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v127.f32, 1), *((float *)this + 4), v127.f32[0]);
  LODWORD(v129) = *((_DWORD *)this + 7);
  v130.i32[0] = *((_DWORD *)this + 9);
  *(float *)v131.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v127.f32, 1), *(float *)&v129, v127.f32[0]);
  v127.f32[0] = *((float *)this + 6) + *(float *)&v128;
  *(float *)v132.f64 = *(float *)v130.i32 + *(float *)v131.i32;
  v127.f32[1] = *(float *)v130.i32 + *(float *)v131.i32;
  *(double *)v134.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v127.i64, v132, v128, v129, v131, v130, v133);
  float32x4_t v171 = v134;
  *(float32x2_t *)v134.f32 = vadd_f32(v3, (float32x2_t)0xC0400000BF800000);
  *(float *)&double v135 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v134.f32, 1), *((float *)this + 4), v134.f32[0]);
  LODWORD(v136) = *((_DWORD *)this + 7);
  v137.i32[0] = *((_DWORD *)this + 9);
  *(float *)v138.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v134.f32, 1), *(float *)&v136, v134.f32[0]);
  v134.f32[0] = *((float *)this + 6) + *(float *)&v135;
  *(float *)v139.f64 = *(float *)v137.i32 + *(float *)v138.i32;
  v134.f32[1] = *(float *)v137.i32 + *(float *)v138.i32;
  *(double *)v141.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v134.i64, v139, v135, v136, v138, v137, v140);
  float32x4_t v170 = v141;
  *(float32x2_t *)v141.f32 = vadd_f32(v3, (float32x2_t)0xC00000003F800000);
  *(float *)&double v142 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v141.f32, 1), *((float *)this + 4), v141.f32[0]);
  LODWORD(v143) = *((_DWORD *)this + 7);
  v144.i32[0] = *((_DWORD *)this + 9);
  *(float *)v145.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v141.f32, 1), *(float *)&v143, v141.f32[0]);
  v141.f32[0] = *((float *)this + 6) + *(float *)&v142;
  *(float *)v146.f64 = *(float *)v144.i32 + *(float *)v145.i32;
  v141.f32[1] = *(float *)v144.i32 + *(float *)v145.i32;
  *(double *)v148.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v141.i64, v146, v142, v143, v145, v144, v147);
  float32x4_t v149 = vsubq_f32(v188, v148);
  float32x4_t v150 = vsubq_f32(v186, v171);
  float32x4_t v151 = vsubq_f32(v185, v172);
  float32x4_t v152 = vsubq_f32(v184, v173);
  float32x4_t v153 = vsubq_f32(v182, v175);
  float32x4_t v154 = vsubq_f32(v181, v176);
  float32x4_t v155 = (float32x4_t)vdupq_n_s32(0x3F0B7176u);
  float32x4_t v156 = (float32x4_t)vdupq_n_s32(0x3E34A234u);
  float32x4_t v157 = (float32x4_t)vdupq_n_s32(0x3C1374BCu);
  float32x4_t v158 = (float32x4_t)vdupq_n_s32(0x3D3645A2u);
  float32x4_t v159 = (float32x4_t)vdupq_n_s32(0x3C9374BCu);
  float32x4_t v160 = vaddq_f32(vmulq_f32(vsubq_f32(v154, v151), v159), vsubq_f32(vaddq_f32(vsubq_f32(vmulq_f32(vsubq_f32(v153, v152), v156), vmulq_f32(vsubq_f32(v179, v178), v155)), vmulq_f32(vsubq_f32(v150, v149), v157)), vmulq_f32(vsubq_f32(v180, v177), v158)));
  float32x4_t v161 = vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vmulq_f32(vsubq_f32(v183, v174), v155), vmulq_f32(vaddq_f32(v153, v152), v156)), vmulq_f32(vaddq_f32(v154, v151), v157)), vmulq_f32(vsubq_f32(v187, v170), v158)), vmulq_f32(vaddq_f32(v150, v149), v159));
  v163.i64[1] = 0x3F80000000000000;
  v152.i64[1] = 0x3F80000000000000;
  v152.i64[0] = __PAIR64__(v161.u32[0], v160.u32[0]);
  float32x4_t v162 = vaddq_f32(vmulq_f32(v161, v161), vmulq_f32(v160, v160));
  v163.i64[0] = __PAIR64__(v161.u32[1], v160.u32[1]);
  int8x16_t v164 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v162.f32, 1), v162), 0), (int8x16_t)v163, (int8x16_t)v152);
  if (v162.f32[1] <= v162.f32[0]) {
    v163.f32[0] = v162.f32[0];
  }
  else {
    v163.f32[0] = v162.f32[1];
  }
  v165.i64[1] = v164.i64[1];
  v165.i64[0] = __PAIR64__(v161.u32[2], v160.u32[2]);
  int8x16_t v166 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v162, 2), v163), 0), v165, v164);
  if (v162.f32[2] > v163.f32[0]) {
    v163.f32[0] = v162.f32[2];
  }
  int8x16_t v167 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v162, 3), v163), 0);
  v168.i64[1] = v166.i64[1];
  v168.i64[0] = __PAIR64__(v161.u32[3], v160.u32[3]);
  *(void *)&double result = vbslq_s8(v167, v168, v166).u64[0];
  return result;
}

double cikernel::_sobel(cikernel *this, SamplerObj *a2)
{
  float32x2_t v3 = *(float32x2_t *)CI::getDC(this);
  float32x2_t v4 = vadd_f32(v3, (float32x2_t)0x3F800000BF800000);
  *(float *)&double v5 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v4, 1), *((float *)this + 4), v4.f32[0]);
  LODWORD(v6) = *((_DWORD *)this + 7);
  v7.i32[0] = *((_DWORD *)this + 9);
  *(float *)v8.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v4, 1), *(float *)&v6, v4.f32[0]);
  v4.f32[0] = *((float *)this + 6) + *(float *)&v5;
  *(float *)v9.f64 = *(float *)v7.i32 + *(float *)v8.i32;
  v4.f32[1] = *(float *)v7.i32 + *(float *)v8.i32;
  *(double *)v11.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v4, v9, v5, v6, v8, v7, v10);
  float32x4_t v82 = v11;
  *(float32x2_t *)v11.f32 = vadd_f32(v3, (float32x2_t)0x3F80000000000000);
  *(float *)&double v12 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v11.f32, 1), *((float *)this + 4), v11.f32[0]);
  LODWORD(v13) = *((_DWORD *)this + 7);
  v14.i32[0] = *((_DWORD *)this + 9);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v11.f32, 1), *(float *)&v13, v11.f32[0]);
  v11.f32[0] = *((float *)this + 6) + *(float *)&v12;
  *(float *)v16.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v11.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v11.i64, v16, v12, v13, v15, v14, v17);
  float32x4_t v81 = _Q0;
  __asm { FMOV            V0.2S, #1.0 }
  *(float32x2_t *)_Q0.f32 = vadd_f32(v3, *(float32x2_t *)_Q0.f32);
  *(float *)&double v23 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)_Q0.f32, 1), *((float *)this + 4), _Q0.f32[0]);
  LODWORD(v24) = *((_DWORD *)this + 7);
  v25.i32[0] = *((_DWORD *)this + 9);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)_Q0.f32, 1), *(float *)&v24, _Q0.f32[0]);
  _Q0.f32[0] = *((float *)this + 6) + *(float *)&v23;
  *(float *)v27.f64 = *(float *)v25.i32 + *(float *)v26.i32;
  _Q0.f32[1] = *(float *)v25.i32 + *(float *)v26.i32;
  *(double *)v29.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)_Q0.i64, v27, v23, v24, v26, v25, v28);
  float32x4_t v80 = v29;
  *(float32x2_t *)v29.f32 = vadd_f32(v3, (float32x2_t)3212836864);
  *(float *)&double v30 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v29.f32, 1), *((float *)this + 4), v29.f32[0]);
  LODWORD(v31) = *((_DWORD *)this + 7);
  v32.i32[0] = *((_DWORD *)this + 9);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v29.f32, 1), *(float *)&v31, v29.f32[0]);
  v29.f32[0] = *((float *)this + 6) + *(float *)&v30;
  *(float *)v34.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v29.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)v36.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v29.i64, v34, v30, v31, v33, v32, v35);
  float32x4_t v79 = v36;
  *(float32x2_t *)v36.f32 = vadd_f32(v3, (float32x2_t)1065353216);
  *(float *)&double v37 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v36.f32, 1), *((float *)this + 4), v36.f32[0]);
  LODWORD(v38) = *((_DWORD *)this + 7);
  v39.i32[0] = *((_DWORD *)this + 9);
  *(float *)v40.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v36.f32, 1), *(float *)&v38, v36.f32[0]);
  v36.f32[0] = *((float *)this + 6) + *(float *)&v37;
  *(float *)v41.f64 = *(float *)v39.i32 + *(float *)v40.i32;
  v36.f32[1] = *(float *)v39.i32 + *(float *)v40.i32;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v36.i64, v41, v37, v38, v40, v39, v42);
  float32x4_t v78 = _Q0;
  __asm { FMOV            V0.2S, #-1.0 }
  *(float32x2_t *)_Q0.f32 = vadd_f32(v3, *(float32x2_t *)_Q0.f32);
  *(float *)&double v44 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)_Q0.f32, 1), *((float *)this + 4), _Q0.f32[0]);
  LODWORD(v45) = *((_DWORD *)this + 7);
  v46.i32[0] = *((_DWORD *)this + 9);
  *(float *)v47.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)_Q0.f32, 1), *(float *)&v45, _Q0.f32[0]);
  _Q0.f32[0] = *((float *)this + 6) + *(float *)&v44;
  *(float *)v48.f64 = *(float *)v46.i32 + *(float *)v47.i32;
  _Q0.f32[1] = *(float *)v46.i32 + *(float *)v47.i32;
  *(double *)v50.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)_Q0.i64, v48, v44, v45, v47, v46, v49);
  float32x4_t v77 = v50;
  *(float32x2_t *)v50.f32 = vadd_f32(v3, (float32x2_t)0xBF80000000000000);
  *(float *)&double v51 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v50.f32, 1), *((float *)this + 4), v50.f32[0]);
  LODWORD(v52) = *((_DWORD *)this + 7);
  v53.i32[0] = *((_DWORD *)this + 9);
  *(float *)v54.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v50.f32, 1), *(float *)&v52, v50.f32[0]);
  v50.f32[0] = *((float *)this + 6) + *(float *)&v51;
  *(float *)v55.f64 = *(float *)v53.i32 + *(float *)v54.i32;
  v50.f32[1] = *(float *)v53.i32 + *(float *)v54.i32;
  *(double *)v57.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v50.i64, v55, v51, v52, v54, v53, v56);
  float32x4_t v76 = v57;
  *(float32x2_t *)v57.f32 = vadd_f32(v3, (float32x2_t)0xBF8000003F800000);
  *(float *)&double v58 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v57.f32, 1), *((float *)this + 4), v57.f32[0]);
  LODWORD(v59) = *((_DWORD *)this + 7);
  v60.i32[0] = *((_DWORD *)this + 9);
  *(float *)v61.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v57.f32, 1), *(float *)&v59, v57.f32[0]);
  v57.f32[0] = *((float *)this + 6) + *(float *)&v58;
  *(float *)v62.f64 = *(float *)v60.i32 + *(float *)v61.i32;
  v57.f32[1] = *(float *)v60.i32 + *(float *)v61.i32;
  *(double *)v64.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v57.i64, v62, v58, v59, v61, v60, v63);
  float32x4_t v65 = vsubq_f32(vaddq_f32(vaddq_f32(v80, vaddq_f32(v78, v78)), v64), vaddq_f32(vaddq_f32(v82, vaddq_f32(v79, v79)), v77));
  float32x4_t v66 = vsubq_f32(vaddq_f32(vaddq_f32(v82, vaddq_f32(v81, v81)), v80), vaddq_f32(vaddq_f32(v77, vaddq_f32(v76, v76)), v64));
  v69.i64[1] = 0x3F80000000000000;
  v67.i64[1] = 0x3F80000000000000;
  v67.i64[0] = __PAIR64__(v66.u32[0], v65.u32[0]);
  float32x4_t v68 = vaddq_f32(vmulq_f32(v66, v66), vmulq_f32(v65, v65));
  v69.i64[0] = __PAIR64__(v66.u32[1], v65.u32[1]);
  int8x16_t v70 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v68.f32, 1), v68), 0), (int8x16_t)v69, v67);
  if (v68.f32[1] <= v68.f32[0]) {
    v69.f32[0] = v68.f32[0];
  }
  else {
    v69.f32[0] = v68.f32[1];
  }
  v71.i64[1] = v70.i64[1];
  v71.i64[0] = __PAIR64__(v66.u32[2], v65.u32[2]);
  int8x16_t v72 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v68, 2), v69), 0), v71, v70);
  if (v68.f32[2] > v69.f32[0]) {
    v69.f32[0] = v68.f32[2];
  }
  int8x16_t v73 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v68, 3), v69), 0);
  v74.i64[1] = v72.i64[1];
  v74.i64[0] = __PAIR64__(v66.u32[3], v65.u32[3]);
  *(void *)&double result = vbslq_s8(v73, v74, v72).u64[0];
  return result;
}

void cikernel::_sobel_m(cikernel *this, SamplerObj *a2)
{
  float32x2_t v3 = *(float32x2_t *)CI::getDC(this);
  float32x2_t v4 = vadd_f32(v3, (float32x2_t)0x3F800000BF800000);
  *(float *)&double v5 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v4, 1), *((float *)this + 4), v4.f32[0]);
  LODWORD(v6) = *((_DWORD *)this + 7);
  v7.i32[0] = *((_DWORD *)this + 9);
  *(float *)v8.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v4, 1), *(float *)&v6, v4.f32[0]);
  v4.f32[0] = *((float *)this + 6) + *(float *)&v5;
  *(float *)v9.f64 = *(float *)v7.i32 + *(float *)v8.i32;
  v4.f32[1] = *(float *)v7.i32 + *(float *)v8.i32;
  CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v4, v9, v5, v6, v8, v7, v10);
  float32x2_t v11 = vadd_f32(v3, (float32x2_t)0x3F80000000000000);
  *(float *)&double v12 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v11, 1), *((float *)this + 4), v11.f32[0]);
  LODWORD(v13) = *((_DWORD *)this + 7);
  v14.i32[0] = *((_DWORD *)this + 9);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v11, 1), *(float *)&v13, v11.f32[0]);
  v11.f32[0] = *((float *)this + 6) + *(float *)&v12;
  *(float *)v16.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v11.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v11, v16, v12, v13, v15, v14, v17);
  __asm { FMOV            V0.2S, #1.0 }
  float32x2_t v23 = vadd_f32(v3, _D0);
  *(float *)&double v24 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v23, 1), *((float *)this + 4), v23.f32[0]);
  LODWORD(v25) = *((_DWORD *)this + 7);
  v26.i32[0] = *((_DWORD *)this + 9);
  *(float *)v27.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v23, 1), *(float *)&v25, v23.f32[0]);
  v23.f32[0] = *((float *)this + 6) + *(float *)&v24;
  *(float *)v28.f64 = *(float *)v26.i32 + *(float *)v27.i32;
  v23.f32[1] = *(float *)v26.i32 + *(float *)v27.i32;
  CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v23, v28, v24, v25, v27, v26, v29);
  float32x2_t v30 = vadd_f32(v3, (float32x2_t)3212836864);
  *(float *)&double v31 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v30, 1), *((float *)this + 4), v30.f32[0]);
  LODWORD(v32) = *((_DWORD *)this + 7);
  v33.i32[0] = *((_DWORD *)this + 9);
  *(float *)v34.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v30, 1), *(float *)&v32, v30.f32[0]);
  v30.f32[0] = *((float *)this + 6) + *(float *)&v31;
  *(float *)v35.f64 = *(float *)v33.i32 + *(float *)v34.i32;
  v30.f32[1] = *(float *)v33.i32 + *(float *)v34.i32;
  CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v30, v35, v31, v32, v34, v33, v36);
  float32x2_t v37 = vadd_f32(v3, (float32x2_t)1065353216);
  *(float *)&double v38 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v37, 1), *((float *)this + 4), v37.f32[0]);
  LODWORD(v39) = *((_DWORD *)this + 7);
  v40.i32[0] = *((_DWORD *)this + 9);
  *(float *)v41.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v37, 1), *(float *)&v39, v37.f32[0]);
  v37.f32[0] = *((float *)this + 6) + *(float *)&v38;
  *(float *)v42.f64 = *(float *)v40.i32 + *(float *)v41.i32;
  v37.f32[1] = *(float *)v40.i32 + *(float *)v41.i32;
  CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v37, v42, v38, v39, v41, v40, v43);
  __asm { FMOV            V0.2S, #-1.0 }
  float32x2_t v45 = vadd_f32(v3, _D0);
  *(float *)&double v46 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v45, 1), *((float *)this + 4), v45.f32[0]);
  LODWORD(v47) = *((_DWORD *)this + 7);
  v48.i32[0] = *((_DWORD *)this + 9);
  *(float *)v49.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v45, 1), *(float *)&v47, v45.f32[0]);
  v45.f32[0] = *((float *)this + 6) + *(float *)&v46;
  *(float *)v50.f64 = *(float *)v48.i32 + *(float *)v49.i32;
  v45.f32[1] = *(float *)v48.i32 + *(float *)v49.i32;
  CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v45, v50, v46, v47, v49, v48, v51);
  float32x2_t v52 = vadd_f32(v3, (float32x2_t)0xBF80000000000000);
  *(float *)&double v53 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v52, 1), *((float *)this + 4), v52.f32[0]);
  LODWORD(v54) = *((_DWORD *)this + 7);
  v55.i32[0] = *((_DWORD *)this + 9);
  *(float *)v56.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v52, 1), *(float *)&v54, v52.f32[0]);
  v52.f32[0] = *((float *)this + 6) + *(float *)&v53;
  *(float *)v57.f64 = *(float *)v55.i32 + *(float *)v56.i32;
  v52.f32[1] = *(float *)v55.i32 + *(float *)v56.i32;
  CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v52, v57, v53, v54, v56, v55, v58);
  float32x2_t v59 = vadd_f32(v3, (float32x2_t)0xBF8000003F800000);
  *(float *)&double v60 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v59, 1), *((float *)this + 4), v59.f32[0]);
  LODWORD(v61) = *((_DWORD *)this + 7);
  v62.i32[0] = *((_DWORD *)this + 9);
  *(float *)v63.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v59, 1), *(float *)&v61, v59.f32[0]);
  v59.f32[0] = *((float *)this + 6) + *(float *)&v60;
  *(float *)v64.f64 = *(float *)v62.i32 + *(float *)v63.i32;
  v59.f32[1] = *(float *)v62.i32 + *(float *)v63.i32;
  CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v59, v64, v60, v61, v63, v62, v65);
}

void cikernel::_maxGradOnly(cikernel *this, SamplerObj *a2)
{
  DC = (CI *)CI::getDC(this);
  float32x2_t v4 = *(float32x2_t *)DC;
  double v5 = (float32x2_t *)CI::getDC(DC);
  *(float *)&double v6 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *v5, 1), *((float *)this + 4), COERCE_FLOAT(*v5));
  LODWORD(v7) = *((_DWORD *)this + 7);
  v8.i32[0] = *((_DWORD *)this + 9);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *v5, 1), *(float *)&v7, COERCE_FLOAT(*v5));
  *(float *)&double v10 = *((float *)this + 6) + *(float *)&v6;
  *(float *)v11.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  *((float *)&v10 + 1) = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v10, v11, v6, v7, v9, v8, v12);
  if (*(float *)&v13.i32[2] >= 0.0001)
  {
    int32x2_t v17 = (int32x2_t)vmul_f32(*(float32x2_t *)v13.i8, *(float32x2_t *)v13.i8);
    *(void *)&double v18 = vadd_f32((float32x2_t)v17, (float32x2_t)vdup_lane_s32(v17, 1)).u32[0];
    *(float32x2_t *)&v14.f64[0] = vrsqrte_f32((float32x2_t)LODWORD(v18));
    int8x16_t v19 = v13;
    float32x2_t v20 = vmul_f32(*(float32x2_t *)&v14.f64[0], *(float32x2_t *)&v14.f64[0]);
    float32x2_t v21 = vmul_n_f32(*(float32x2_t *)v13.i8, vmul_f32(*(float32x2_t *)&v14.f64[0], vrsqrts_f32((float32x2_t)LODWORD(v18), v20)).f32[0]);
    float32x2_t v22 = vadd_f32(v4, v21);
    v20.f32[0] = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v22, 1), *((float *)this + 4), v22.f32[0]);
    LODWORD(v18) = *((_DWORD *)this + 7);
    v15.i32[0] = *((_DWORD *)this + 9);
    *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v22, 1), *(float *)&v18, v22.f32[0]);
    v22.f32[0] = *((float *)this + 6) + v20.f32[0];
    *(float *)v14.f64 = *(float *)v15.i32 + *(float *)v19.i32;
    v22.f32[1] = *(float *)v15.i32 + *(float *)v19.i32;
    CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v22, v14, *(double *)&v20, v18, v19, v15, v16);
    float32x2_t v23 = vsub_f32(v4, v21);
    *(float *)&double v24 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v23, 1), *((float *)this + 4), v23.f32[0]);
    LODWORD(v25) = *((_DWORD *)this + 7);
    v26.i32[0] = *((_DWORD *)this + 9);
    *(float *)v27.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v23, 1), *(float *)&v25, v23.f32[0]);
    v23.f32[0] = *((float *)this + 6) + *(float *)&v24;
    *(float *)v28.f64 = *(float *)v26.i32 + *(float *)v27.i32;
    v23.f32[1] = *(float *)v26.i32 + *(float *)v27.i32;
    CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v23, v28, v24, v25, v27, v26, v29);
  }
}

double cikernel::_cannyThreshold(int32x4_t a1, float32x4_t a2, float32x4_t a3)
{
  a2.f32[0] = a2.f32[0] * a2.f32[0];
  float32x4_t v3 = (float32x4_t)vdupq_laneq_s32(a1, 2);
  a3.f32[0] = a3.f32[0] * a3.f32[0];
  *(void *)&double result = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vcgeq_f32(v3, a2)), 0), vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vcgeq_f32(v3, a3)), 0), (int8x16_t)xmmword_19394C7E0, (int8x16_t)xmmword_193953040), (int8x16_t)xmmword_19394C820).u64[0];
  return result;
}

void cikernel::_cannyHysteresis(cikernel *this, SamplerObj *a2)
{
  DC = (float32x2_t *)CI::getDC(this);
  *(float *)&double v4 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *DC, 1), *((float *)this + 4), COERCE_FLOAT(*DC));
  LODWORD(v5) = *((_DWORD *)this + 7);
  v6.i32[0] = *((_DWORD *)this + 9);
  *(float *)v7.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *DC, 1), *(float *)&v5, COERCE_FLOAT(*DC));
  *(float *)&double v8 = *((float *)this + 6) + *(float *)&v4;
  *(float *)v9.f64 = *(float *)v6.i32 + *(float *)v7.i32;
  *((float *)&v8 + 1) = *(float *)v6.i32 + *(float *)v7.i32;
  double v12 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v8, v9, v4, v5, v7, v6, v10);
  v13.f64[0] = 0.9;
  if (*(float *)&v12 < 0.9 && *(float *)&v12 > 0.4)
  {
    float64x2_t v82 = v13;
    float32x2_t v14 = *(float32x2_t *)CI::getDC(v11);
    float32x2_t v15 = vadd_f32(v14, (float32x2_t)1065353216);
    *(float *)&double v16 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v15, 1), *((float *)this + 4), v15.f32[0]);
    LODWORD(v17) = *((_DWORD *)this + 7);
    v18.i32[0] = *((_DWORD *)this + 9);
    *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v15, 1), *(float *)&v17, v15.f32[0]);
    v15.f32[0] = *((float *)this + 6) + *(float *)&v16;
    *(float *)v20.f64 = *(float *)v18.i32 + *(float *)v19.i32;
    v15.f32[1] = *(float *)v18.i32 + *(float *)v19.i32;
    double v22 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v15, v20, v16, v17, v19, v18, v21);
    float64x2_t v28 = v82;
    if (*(float *)&v22 < v82.f64[0])
    {
      float32x2_t v29 = vadd_f32(v14, (float32x2_t)3212836864);
      *(float *)&double v23 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v29, 1), *((float *)this + 4), v29.f32[0]);
      LODWORD(v24) = *((_DWORD *)this + 7);
      v26.i32[0] = *((_DWORD *)this + 9);
      *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v29, 1), *(float *)&v24, v29.f32[0]);
      v29.f32[0] = *((float *)this + 6) + *(float *)&v23;
      *(float *)v28.f64 = *(float *)v26.i32 + *(float *)v25.i32;
      v29.f32[1] = *(float *)v26.i32 + *(float *)v25.i32;
      double v30 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v29, v28, v23, v24, v25, v26, v27);
      float64x2_t v36 = v82;
      if (*(float *)&v30 < v82.f64[0])
      {
        float32x2_t v37 = vadd_f32(v14, (float32x2_t)0x3F80000000000000);
        *(float *)&double v31 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v37, 1), *((float *)this + 4), v37.f32[0]);
        LODWORD(v32) = *((_DWORD *)this + 7);
        v34.i32[0] = *((_DWORD *)this + 9);
        *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v37, 1), *(float *)&v32, v37.f32[0]);
        v37.f32[0] = *((float *)this + 6) + *(float *)&v31;
        *(float *)v36.f64 = *(float *)v34.i32 + *(float *)v33.i32;
        v37.f32[1] = *(float *)v34.i32 + *(float *)v33.i32;
        double v38 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v37, v36, v31, v32, v33, v34, v35);
        float64x2_t v44 = v82;
        if (*(float *)&v38 < v82.f64[0])
        {
          float32x2_t v45 = vadd_f32(v14, (float32x2_t)0xBF80000000000000);
          *(float *)&double v39 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v45, 1), *((float *)this + 4), v45.f32[0]);
          LODWORD(v40) = *((_DWORD *)this + 7);
          v42.i32[0] = *((_DWORD *)this + 9);
          *(float *)v41.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v45, 1), *(float *)&v40, v45.f32[0]);
          v45.f32[0] = *((float *)this + 6) + *(float *)&v39;
          *(float *)v44.f64 = *(float *)v42.i32 + *(float *)v41.i32;
          v45.f32[1] = *(float *)v42.i32 + *(float *)v41.i32;
          double v46 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v45, v44, v39, v40, v41, v42, v43);
          float64x2_t v52 = v82;
          if (*(float *)&v46 < v82.f64[0])
          {
            __asm { FMOV            V0.2S, #-1.0 }
            *(float32x2_t *)v49.i8 = vadd_f32(v14, *(float32x2_t *)&_D0);
            LODWORD(v47) = *((_DWORD *)this + 7);
            *(float *)&_D0 = *((float *)this + 6)
                           + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v49.i8, 1), *((float *)this + 4), *(float *)v49.i32);
            LODWORD(v48) = *((_DWORD *)this + 9);
            int8x16_t v81 = v49;
            *(float *)v52.f64 = *(float *)&v48
                              + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v49.i8, 1), *(float *)&v47, *(float *)v49.i32);
            HIDWORD(_D0) = LODWORD(v52.f64[0]);
            double v58 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), _D0, v52, v47, v48, v49, v50, v51);
            float64x2_t v64 = v82;
            if (*(float *)&v58 < v82.f64[0])
            {
              *(float32x2_t *)v61.i8 = vadd_f32(v14, (float32x2_t)0xBF8000003F800000);
              LODWORD(v59) = *((_DWORD *)this + 7);
              *(float *)&double v65 = *((float *)this + 6)
                             + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v61.i8, 1), *((float *)this + 4), *(float *)v61.i32);
              LODWORD(v60) = *((_DWORD *)this + 9);
              int8x16_t v80 = v61;
              *(float *)v64.f64 = *(float *)&v60
                                + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v61.i8, 1), *(float *)&v59, *(float *)v61.i32);
              HIDWORD(v65) = LODWORD(v64.f64[0]);
              double v66 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v65, v64, v59, v60, v61, v62, v63);
              float64x2_t v71 = v82;
              if (*(float *)&v66 < v82.f64[0])
              {
                LODWORD(v68) = *((_DWORD *)this + 7);
                *(float *)&double v72 = *((float *)this + 6)
                               + (float)((float)(*(float *)&v81.i32[1] * *((float *)this + 5))
                                       + (float)(*(float *)v81.i32 * *((float *)this + 4)));
                LODWORD(v67) = *((_DWORD *)this + 8);
                v69.i32[0] = *((_DWORD *)this + 9);
                *(float *)v71.f64 = *(float *)v69.i32
                                  + (float)((float)(*(float *)&v81.i32[1] * *(float *)&v67)
                                          + (float)(*(float *)v81.i32 * *(float *)&v68));
                *((float *)&v72 + 1) = *(float *)v71.f64;
                double v73 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v72, v71, v67, v68, v69, v81, v70);
                HIDWORD(v78) = HIDWORD(v82.f64[0]);
                if (*(float *)&v73 < v82.f64[0])
                {
                  LODWORD(v75) = *((_DWORD *)this + 7);
                  *(float *)&double v79 = *((float *)this + 6)
                                 + (float)((float)(*(float *)&v80.i32[1] * *((float *)this + 5))
                                         + (float)(*(float *)v80.i32 * *((float *)this + 4)));
                  LODWORD(v78) = *((_DWORD *)this + 8);
                  v76.i32[0] = *((_DWORD *)this + 9);
                  *(float *)v74.f64 = *(float *)v76.i32
                                    + (float)((float)(*(float *)&v80.i32[1] * *(float *)&v78)
                                            + (float)(*(float *)v80.i32 * *(float *)&v75));
                  *((float *)&v79 + 1) = *(float *)v74.f64;
                  CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v79, v74, v78, v75, v76, v80, v77);
                }
              }
            }
          }
        }
      }
    }
  }
}

float64_t cikernel::_cannyFinal(float64x2_t a1, float64x2_t a2)
{
  a1.f64[0] = *(float *)a1.f64;
  a2.f64[0] = 0.9;
  __asm { FMOV            V2.4S, #1.0 }
  *(void *)&a1.f64[0] = vbslq_s8((int8x16_t)vdupq_lane_s64(vmvnq_s8((int8x16_t)vcgeq_f64(a1, a2)).i64[0], 0), (int8x16_t)xmmword_19394C7E0, _Q2).u64[0];
  return a1.f64[0];
}

uint64_t CI_IOSURFACE_INTERMEDIATES()
{
  {
    CI_IOSURFACE_INTERMEDIATES::v = get_BOOL("CI_IOSURFACE_INTERMEDIATES", 1);
  }
  return CI_IOSURFACE_INTERMEDIATES::v;
}

void sub_19375D7AC(_Unwind_Exception *a1)
{
}

uint64_t CI_LOSSLESS_COMPRESSED_INTERMEDIATES()
{
  {
    CI_LOSSLESS_COMPRESSED_INTERMEDIATES::v = get_BOOL("CI_LOSSLESS_COMPRESSED_INTERMEDIATES", 1);
  }
  return CI_LOSSLESS_COMPRESSED_INTERMEDIATES::v;
}

void sub_19375D82C(_Unwind_Exception *a1)
{
}

uint64_t CI_LOSSY_COMPRESSED_INTERMEDIATES()
{
  {
    CI_LOSSY_COMPRESSED_INTERMEDIATES::v = get_BOOL("CI_LOSSY_COMPRESSED_INTERMEDIATES", 1);
  }
  return CI_LOSSY_COMPRESSED_INTERMEDIATES::v;
}

void sub_19375D8AC(_Unwind_Exception *a1)
{
}

uint64_t CI_LOG_FILE()
{
  if (CI_LOG_FILE::didCheck != -1) {
    dispatch_once(&CI_LOG_FILE::didCheck, &__block_literal_global_24);
  }
  return CI_LOG_FILE::fp;
}

uint64_t memstream_write(char *a1, const char *__src, int a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (a3 < 1)
  {
    uint64_t v5 = 0;
  }
  else
  {
    uint64_t v5 = 0;
    while (__src[v5] && __src[v5] != 10)
    {
      if (a3 == ++v5)
      {
        uint64_t v5 = a3;
        break;
      }
    }
  }
  int v7 = __src[v5];
  if (v7 == 10 || v7 == 0)
  {
    if (v5)
    {
      float64x2_t v9 = ci_logger_general();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        int v10 = *(_DWORD *)a1;
        int v16 = 68158466;
        int v17 = v10;
        __int16 v18 = 2080;
        int8x16_t v19 = a1 + 4;
        __int16 v20 = 1040;
        int v21 = v5;
        __int16 v22 = 2080;
        double v23 = __src;
        _os_log_impl(&dword_193671000, v9, OS_LOG_TYPE_DEFAULT, "%.*s%.*s", (uint8_t *)&v16, 0x22u);
      }
    }
    *(_DWORD *)a1 = 0;
    return (v5 + 1);
  }
  else
  {
    uint64_t v12 = *(int *)a1;
    if ((int)v12 + (int)v5 < 1025)
    {
      memcpy(&a1[v12 + 4], __src, v5);
      *(_DWORD *)a1 += v5;
    }
    else
    {
      if (v12)
      {
        float64x2_t v13 = ci_logger_general();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          int v14 = *(_DWORD *)a1;
          int v16 = 68157954;
          int v17 = v14;
          __int16 v18 = 2080;
          int8x16_t v19 = a1 + 4;
          _os_log_impl(&dword_193671000, v13, OS_LOG_TYPE_DEFAULT, "%.*s...", (uint8_t *)&v16, 0x12u);
        }
      }
      if (v5)
      {
        float32x2_t v15 = ci_logger_general();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          int v16 = 68157954;
          int v17 = v5;
          __int16 v18 = 2080;
          int8x16_t v19 = __src;
          _os_log_impl(&dword_193671000, v15, OS_LOG_TYPE_DEFAULT, "...%.*s...", (uint8_t *)&v16, 0x12u);
        }
      }
      *(_DWORD *)a1 = 0;
    }
  }
  return v5;
}

char *CI_TEMP_DIR()
{
  if (CI_DOCS_DIR::onceToken != -1) {
    dispatch_once(&CI_DOCS_DIR::onceToken, &__block_literal_global_155);
  }
  double result = &CI_DOCS_DIR::directory;
  if (!CI_DOCS_DIR::directory)
  {
    if (CI_TEMP_DIR::onceToken != -1) {
      dispatch_once(&CI_TEMP_DIR::onceToken, &__block_literal_global_158);
    }
    return (char *)&CI_TEMP_DIR::temporaryDirectory;
  }
  return result;
}

char *CI_PRINT_TIME_has_string(const char *a1)
{
  string = get_string("CI_PRINT_TIME");
  if (!a1 || !string) {
    return 0;
  }

  return strstr(string, a1);
}

BOOL CI_PRINT_TIME_context(int a1, char *__s2)
{
  if (CI_PRINT_TIME_context::didCheck != -1) {
    dispatch_once(&CI_PRINT_TIME_context::didCheck, &__block_literal_global_26);
  }
  if (CI_PRINT_TIME_context::equal)
  {
    if (CI_PRINT_TIME_context::name) {
      return strcmp(&CI_PRINT_TIME_context::name, __s2) == 0;
    }
    else {
      return CI_PRINT_TIME_context::v == a1;
    }
  }
  else if (CI_PRINT_TIME_context::nequal)
  {
    if (CI_PRINT_TIME_context::name) {
      BOOL v5 = strcmp(&CI_PRINT_TIME_context::name, __s2) == 0;
    }
    else {
      BOOL v5 = CI_PRINT_TIME_context::v == a1;
    }
    return !v5;
  }
  else
  {
    return 1;
  }
}

uint64_t CI_PRINT_TREE_frame()
{
  if (CI_PRINT_TREE_frame::didCheck != -1) {
    dispatch_once(&CI_PRINT_TREE_frame::didCheck, &__block_literal_global_58_0);
  }
  return CI_PRINT_TREE_frame::v;
}

uint64_t CI_PRINT_TREE_dump_rois()
{
  {
    CI_PRINT_TREE_dump_rois::v = CI_PRINT_TREE_has_string("dump-rois") != 0;
  }
  return CI_PRINT_TREE_dump_rois::v;
}

void sub_19375E0C8(_Unwind_Exception *a1)
{
}

uint64_t CI_PRINT_TREE_dump_inputs()
{
  {
    CI_PRINT_TREE_dump_inputs::v = CI_PRINT_TREE_has_string("dump-inputs") != 0;
  }
  return CI_PRINT_TREE_dump_inputs::v;
}

void sub_19375E14C(_Unwind_Exception *a1)
{
}

uint64_t CI_PRINT_TREE_dump_raw_intermediates()
{
  {
    CI_PRINT_TREE_dump_raw_intermediates::v = CI_PRINT_TREE_has_string("dump-raw-intermediates") != 0;
  }
  return CI_PRINT_TREE_dump_raw_intermediates::v;
}

void sub_19375E1D0(_Unwind_Exception *a1)
{
}

uint64_t CI_PRINT_TREE_dump_bmtl_intermediates()
{
  {
    CI_PRINT_TREE_dump_bmtl_intermediates::v = CI_PRINT_TREE_has_string("dump-bmtl-intermediates") != 0;
  }
  return CI_PRINT_TREE_dump_bmtl_intermediates::v;
}

void sub_19375E254(_Unwind_Exception *a1)
{
}

BOOL CI_PRINT_TREE_context(int a1, char *__s2)
{
  if (CI_PRINT_TREE_context::didCheck != -1) {
    dispatch_once(&CI_PRINT_TREE_context::didCheck, &__block_literal_global_56_0);
  }
  if (CI_PRINT_TREE_context::equal)
  {
    if (CI_PRINT_TREE_context::name) {
      return strcmp(&CI_PRINT_TREE_context::name, __s2) == 0;
    }
    else {
      return CI_PRINT_TREE_context::v == a1;
    }
  }
  else if (CI_PRINT_TREE_context::nequal)
  {
    if (CI_PRINT_TREE_context::name) {
      BOOL v5 = strcmp(&CI_PRINT_TREE_context::name, __s2) == 0;
    }
    else {
      BOOL v5 = CI_PRINT_TREE_context::v == a1;
    }
    return !v5;
  }
  else
  {
    return 1;
  }
}

BOOL CI_PRINT_PROGRAM_context(int a1, char *__s2)
{
  if (CI_PRINT_PROGRAM_context::didCheck != -1) {
    dispatch_once(&CI_PRINT_PROGRAM_context::didCheck, &__block_literal_global_70);
  }
  if (CI_PRINT_PROGRAM_context::equal)
  {
    if (CI_PRINT_PROGRAM_context::name) {
      return strcmp(&CI_PRINT_PROGRAM_context::name, __s2) == 0;
    }
    else {
      return CI_PRINT_PROGRAM_context::v == a1;
    }
  }
  else if (CI_PRINT_PROGRAM_context::nequal)
  {
    if (CI_PRINT_PROGRAM_context::name) {
      BOOL v5 = strcmp(&CI_PRINT_PROGRAM_context::name, __s2) == 0;
    }
    else {
      BOOL v5 = CI_PRINT_PROGRAM_context::v == a1;
    }
    return !v5;
  }
  else
  {
    return 1;
  }
}

uint64_t CI_MAX_CPU_RENDER_SIZE()
{
  {
    CI_MAX_CPU_RENDER_SIZE::v = get_int("CI_MAX_CPU_RENDER_SIZE", 512);
  }
  return CI_MAX_CPU_RENDER_SIZE::v;
}

void sub_19375E7F0(_Unwind_Exception *a1)
{
}

uint64_t CI_FORCE_IS_BACKGROUND()
{
  {
    CI_FORCE_IS_BACKGROUND::v = get_Y_or_N("CI_FORCE_IS_BACKGROUND");
  }
  return CI_FORCE_IS_BACKGROUND::v;
}

void sub_19375E86C(_Unwind_Exception *a1)
{
}

uint64_t CI_FORCE_GPU_PRIORITY()
{
  if (CI_FORCE_GPU_PRIORITY::didCheck != -1) {
    dispatch_once(&CI_FORCE_GPU_PRIORITY::didCheck, &__block_literal_global_76);
  }
  return CI_FORCE_GPU_PRIORITY::v;
}

uint64_t CI_INPUT_CACHE_SIZE()
{
  {
    CI_INPUT_CACHE_SIZE::v = get_int("CI_INPUT_CACHE_SIZE", 4);
  }
  return CI_INPUT_CACHE_SIZE::v;
}

void sub_19375E9F0(_Unwind_Exception *a1)
{
}

uint64_t CI_INTERMEDIATE_CACHE_SIZE()
{
  {
    CI_INTERMEDIATE_CACHE_SIZE::v = get_ulong("CI_INTERMEDIATE_CACHE_SIZE", 256);
  }
  return CI_INTERMEDIATE_CACHE_SIZE::v;
}

void sub_19375EA70(_Unwind_Exception *a1)
{
}

uint64_t CI_INTERMEDIATE_SRGB_TEXTURES()
{
  {
    CI_INTERMEDIATE_SRGB_TEXTURES::v = get_BOOL("CI_INTERMEDIATE_SRGB_TEXTURES", 1);
  }
  return CI_INTERMEDIATE_SRGB_TEXTURES::v;
}

void sub_19375EAF0(_Unwind_Exception *a1)
{
}

uint64_t CI_RECYCLE_OPENGL_TEXTURES()
{
  {
    CI_RECYCLE_OPENGL_TEXTURES::v = get_BOOL("CI_RECYCLE_OPENGL_TEXTURES", 1);
  }
  return CI_RECYCLE_OPENGL_TEXTURES::v;
}

void sub_19375EB70(_Unwind_Exception *a1)
{
}

uint64_t CI_USE_INFLIGHT_INTERMEDIATES()
{
  {
    CI_USE_INFLIGHT_INTERMEDIATES::v = get_BOOL("CI_USE_INFLIGHT_INTERMEDIATES", 1);
  }
  return CI_USE_INFLIGHT_INTERMEDIATES::v;
}

void sub_19375EBF0(_Unwind_Exception *a1)
{
}

uint64_t CI_DISABLE_LOADING_ARCHIVES()
{
  return get_BOOL("CI_DISABLE_LOADING_ARCHIVES", 0);
}

void *CI_DISABLE_LOADING_ARCHIVES_BY_NAME()
{
  if (CI_DISABLE_LOADING_ARCHIVES_BY_NAME::didCheck != -1) {
    dispatch_once(&CI_DISABLE_LOADING_ARCHIVES_BY_NAME::didCheck, &__block_literal_global_103);
  }
  if (CI_DISABLE_LOADING_ARCHIVES_BY_NAME::is_set) {
    return &CI_DISABLE_LOADING_ARCHIVES_BY_NAME::archives_name;
  }
  else {
    return 0;
  }
}

uint64_t CI_LOG_AIR_ARCHIVE_MISS()
{
  {
    CI_LOG_AIR_ARCHIVE_MISS::v = get_BOOL("CI_LOG_AIR_ARCHIVE_MISS", 0);
  }
  return CI_LOG_AIR_ARCHIVE_MISS::v;
}

void sub_19375ED18(_Unwind_Exception *a1)
{
}

uint64_t CI_LOG_AIR_ARCHIVE_ACTIVITY()
{
  {
    CI_LOG_AIR_ARCHIVE_ACTIVITY::v = get_BOOL("CI_LOG_AIR_ARCHIVE_ACTIVITY", 0);
  }
  return CI_LOG_AIR_ARCHIVE_ACTIVITY::v;
}

void sub_19375ED98(_Unwind_Exception *a1)
{
}

uint64_t CI_LOG_METAL_FUNCTION_HASH()
{
  {
    CI_LOG_METAL_FUNCTION_HASH::v = get_BOOL("CI_LOG_METAL_FUNCTION_HASH", 0);
  }
  return CI_LOG_METAL_FUNCTION_HASH::v;
}

void sub_19375EE18(_Unwind_Exception *a1)
{
}

uint64_t CI_SKIP_PREWARMING_SDOF_RENDERING()
{
  {
    CI_SKIP_PREWARMING_SDOF_RENDERING::v = get_BOOL("CI_SKIP_PREWARMING_SDOF_RENDERING", 0);
  }
  return CI_SKIP_PREWARMING_SDOF_RENDERING::v;
}

void sub_19375EE98(_Unwind_Exception *a1)
{
}

void *CI_HARVESTING_SPECIFIC_LIBRARY_LIST()
{
  if (CI_HARVESTING_SPECIFIC_LIBRARY_LIST::didCheck != -1) {
    dispatch_once(&CI_HARVESTING_SPECIFIC_LIBRARY_LIST::didCheck, &__block_literal_global_113);
  }
  if (CI_HARVESTING_SPECIFIC_LIBRARY_LIST::is_set) {
    return &CI_HARVESTING_SPECIFIC_LIBRARY_LIST::archives_name;
  }
  else {
    return 0;
  }
}

void *CI_HARVEST_PROCESS_NAME_LIST()
{
  if (CI_HARVEST_PROCESS_NAME_LIST::didCheck != -1) {
    dispatch_once(&CI_HARVEST_PROCESS_NAME_LIST::didCheck, &__block_literal_global_116);
  }
  if (CI_HARVEST_PROCESS_NAME_LIST::is_set) {
    return &CI_HARVEST_PROCESS_NAME_LIST::archives_name;
  }
  else {
    return 0;
  }
}

uint64_t CI_HARVEST_SPECIALIZED_MTL_FUNCTIONS()
{
  {
    CI_HARVEST_SPECIALIZED_MTL_FUNCTIONS::v = get_BOOL("CI_HARVEST_SPECIALIZED_MTL_FUNCTIONS", 1);
  }
  return CI_HARVEST_SPECIALIZED_MTL_FUNCTIONS::v;
}

void sub_19375F048(_Unwind_Exception *a1)
{
}

double CI_BIN_ARCHIVE_SERIALIZATION_DELAY()
{
  {
    if (v1)
    {
      CI_BIN_ARCHIVE_SERIALIZATION_DELAY::v = get_double(v1, v2);
    }
  }
  return *(double *)&CI_BIN_ARCHIVE_SERIALIZATION_DELAY::v;
}

void sub_19375F0BC(_Unwind_Exception *a1)
{
}

double get_double(const char *a1, double a2)
{
  double v2 = getenv("CI_BIN_ARCHIVE_SERIALIZATION_DELAY");
  if (v2)
  {
    return strtod(v2, 0);
  }
  else
  {
    if (userDefaults(void)::didCheck != -1) {
      dispatch_once(&userDefaults(void)::didCheck, &__block_literal_global_193);
    }
    double v4 = objc_msgSend((id)userDefaults(void)::defaults, "objectForKey:", objc_msgSend(NSString, "stringWithUTF8String:", "CI_BIN_ARCHIVE_SERIALIZATION_DELAY"));
    objc_opt_class();
    if (objc_opt_isKindOfClass() & 1) != 0 || (objc_opt_class(), (objc_opt_isKindOfClass()))
    {
      [v4 doubleValue];
    }
    else
    {
      return 10.0;
    }
  }
  return result;
}

uint64_t CI_BIN_ARCHIVE_SERIALIZATION_METHOD()
{
  {
    CI_BIN_ARCHIVE_SERIALIZATION_METHOD::v = get_int("CI_BIN_ARCHIVE_SERIALIZATION_METHOD", 2);
  }
  return CI_BIN_ARCHIVE_SERIALIZATION_METHOD::v;
}

void sub_19375F234(_Unwind_Exception *a1)
{
}

void *CI_HARVEST_BIN_ARCHIVE_ABSOLUTE_PATH()
{
  if (CI_HARVEST_BIN_ARCHIVE_ABSOLUTE_PATH::didCheck != -1) {
    dispatch_once(&CI_HARVEST_BIN_ARCHIVE_ABSOLUTE_PATH::didCheck, &__block_literal_global_123);
  }
  if (CI_HARVEST_BIN_ARCHIVE_ABSOLUTE_PATH::is_set) {
    return &CI_HARVEST_BIN_ARCHIVE_ABSOLUTE_PATH::harvesting_path;
  }
  else {
    return 0;
  }
}

void *CI_HARVEST_BIN_ARCHIVE_FOLDER_NAME()
{
  if (CI_HARVEST_BIN_ARCHIVE_FOLDER_NAME::didCheck != -1) {
    dispatch_once(&CI_HARVEST_BIN_ARCHIVE_FOLDER_NAME::didCheck, &__block_literal_global_126);
  }
  if (CI_HARVEST_BIN_ARCHIVE_FOLDER_NAME::is_set) {
    return &CI_HARVEST_BIN_ARCHIVE_FOLDER_NAME::harvesting_dir;
  }
  else {
    return 0;
  }
}

uint64_t CI_ADD_PROCESS_NAME_TO_BIN_ARCHIVE()
{
  {
    CI_ADD_PROCESS_NAME_TO_BIN_ARCHIVE::v = get_BOOL("CI_ADD_PROCESS_NAME_TO_BIN_ARCHIVE", 1);
  }
  return CI_ADD_PROCESS_NAME_TO_BIN_ARCHIVE::v;
}

void sub_19375F3E4(_Unwind_Exception *a1)
{
}

uint64_t CI_PREVENT_HARVEST_DUPLICATE_ENTRIES()
{
  {
    CI_PREVENT_HARVEST_DUPLICATE_ENTRIES::v = get_BOOL("CI_PREVENT_HARVEST_DUPLICATE_ENTRIES", 0);
  }
  return CI_PREVENT_HARVEST_DUPLICATE_ENTRIES::v;
}

void sub_19375F464(_Unwind_Exception *a1)
{
}

uint64_t CI_USE_MTL_DAG_FOR_CIKL_SRC()
{
  {
    CI_USE_MTL_DAG_FOR_CIKL_SRC::v = get_BOOL("CI_USE_MTL_DAG_FOR_CIKL_SRC", 1);
  }
  return CI_USE_MTL_DAG_FOR_CIKL_SRC::v;
}

void sub_19375F4E4(_Unwind_Exception *a1)
{
}

uint64_t CI_ENABLE_METAL_CONVERT()
{
  {
    CI_ENABLE_METAL_CONVERT::v = get_BOOL("CI_ENABLE_METAL_CONVERT", 0);
  }
  return CI_ENABLE_METAL_CONVERT::v;
}

void sub_19375F564(_Unwind_Exception *a1)
{
}

uint64_t CI_ENABLE_METAL_BLIT()
{
  {
    CI_ENABLE_METAL_BLIT::v = get_BOOL("CI_ENABLE_METAL_BLIT", 1);
  }
  return CI_ENABLE_METAL_BLIT::v;
}

void sub_19375F5E4(_Unwind_Exception *a1)
{
}

uint64_t CI_ENABLE_MPS()
{
  {
    CI_ENABLE_MPS::v = get_BOOL("CI_ENABLE_MPS", 1);
  }
  return CI_ENABLE_MPS::v;
}

void sub_19375F664(_Unwind_Exception *a1)
{
}

uint64_t CI_AUTOTEST_ROI()
{
  {
    CI_AUTOTEST_ROI::v = get_BOOL("CI_AUTOTEST_ROI", 0);
  }
  return CI_AUTOTEST_ROI::v;
}

void sub_19375F6E4(_Unwind_Exception *a1)
{
}

uint64_t CI_EDIT_RED_EYE_VERSION()
{
  {
    CI_EDIT_RED_EYE_VERSION::v = get_int("CI_EDIT_RED_EYE_VERSION", 3);
  }
  if (CI_EDIT_RED_EYE_VERSION::v <= 1) {
    return 1;
  }
  else {
    return CI_EDIT_RED_EYE_VERSION::v;
  }
}

void sub_19375F76C(_Unwind_Exception *a1)
{
}

uint64_t CI_DISABLE_MERGING_PRE_GENERAL()
{
  {
    CI_DISABLE_MERGING_PRE_GENERAL::v = get_BOOL("CI_DISABLE_MERGING_PRE_GENERAL", 0);
  }
  return CI_DISABLE_MERGING_PRE_GENERAL::v;
}

void sub_19375F7EC(_Unwind_Exception *a1)
{
}

uint64_t CI_DISABLE_MERGING_POST_GENERAL()
{
  {
    CI_DISABLE_MERGING_POST_GENERAL::v = get_BOOL("CI_DISABLE_MERGING_POST_GENERAL", 0);
  }
  return CI_DISABLE_MERGING_POST_GENERAL::v;
}

void sub_19375F86C(_Unwind_Exception *a1)
{
}

uint64_t CI_LOG_TEXTURE_CACHE()
{
  {
    CI_LOG_TEXTURE_CACHE::v = get_BOOL("CI_LOG_TEXTURE_CACHE", 0);
  }
  return CI_LOG_TEXTURE_CACHE::v;
}

void sub_19375F8EC(_Unwind_Exception *a1)
{
}

uint64_t CI_TRACE_PEAK_SURFACE_CACHE()
{
  {
    CI_TRACE_PEAK_SURFACE_CACHE::v = get_BOOL("CI_TRACE_PEAK_SURFACE_CACHE", 0);
  }
  return CI_TRACE_PEAK_SURFACE_CACHE::v;
}

void sub_19375F96C(_Unwind_Exception *a1)
{
}

uint64_t CI_LOG_IMAGE_PROVIDER()
{
  {
    CI_LOG_IMAGE_PROVIDER::v = get_BOOL("CI_LOG_IMAGE_PROVIDER", 0);
  }
  return CI_LOG_IMAGE_PROVIDER::v;
}

void sub_19375F9EC(_Unwind_Exception *a1)
{
}

uint64_t CI_NAME_SURFACES()
{
  {
    CI_NAME_SURFACES::v = get_BOOL("CI_NAME_SURFACES", 1);
  }
  return CI_NAME_SURFACES::v;
}

void sub_19375FA6C(_Unwind_Exception *a1)
{
}

uint64_t CI_DISABLE_CRUFT_COMPATABILITY()
{
  {
    CI_DISABLE_CRUFT_COMPATABILITY::v = get_BOOL("CI_DISABLE_CRUFT_COMPATABILITY", 0);
  }
  return CI_DISABLE_CRUFT_COMPATABILITY::v;
}

void sub_19375FBF8(_Unwind_Exception *a1)
{
}

uint64_t CI_MAX_CL_COMPLEXITY()
{
  {
    CI_MAX_CL_COMPLEXITY::v = get_int("CI_MAX_CL_COMPLEXITY", 45);
  }
  return CI_MAX_CL_COMPLEXITY::v;
}

void sub_19375FC78(_Unwind_Exception *a1)
{
}

uint64_t CI_DISABLE_WORKAROUND()
{
  {
    CI_DISABLE_WORKAROUND::v = get_int("CI_DISABLE_WORKAROUND", 0);
  }
  return CI_DISABLE_WORKAROUND::v;
}

void sub_19375FCF8(_Unwind_Exception *a1)
{
}

uint64_t CI_FLIP_IMAGE_PROCESSOR()
{
  {
    CI_FLIP_IMAGE_PROCESSOR::v = get_BOOL("CI_FLIP_IMAGE_PROCESSOR", 1);
  }
  return CI_FLIP_IMAGE_PROCESSOR::v;
}

void sub_19375FD78(_Unwind_Exception *a1)
{
}

uint64_t CI_GRAPHVIZ_INTERNAL()
{
  {
    CI_GRAPHVIZ_INTERNAL::v = get_BOOL("CI_GRAPHVIZ_INTERNAL", 0);
  }
  return CI_GRAPHVIZ_INTERNAL::v;
}

void sub_19375FDF8(_Unwind_Exception *a1)
{
}

uint64_t FOSL_DUMP_GRAPH()
{
  {
    FOSL_DUMP_GRAPH::v = get_BOOL("FOSL_DUMP_GRAPH", 0);
  }
  return FOSL_DUMP_GRAPH::v;
}

void sub_19375FE78(_Unwind_Exception *a1)
{
}

uint64_t FOSL_PRINT_GRAPH()
{
  {
    FOSL_PRINT_GRAPH::v = get_BOOL("FOSL_PRINT_GRAPH", 0);
  }
  return FOSL_PRINT_GRAPH::v;
}

void sub_19375FEF8(_Unwind_Exception *a1)
{
}

uint64_t FOSL_PRINT_KERNEL_AST()
{
  {
    FOSL_PRINT_KERNEL_AST::v = get_BOOL("FOSL_PRINT_KERNEL_AST", 0);
  }
  return FOSL_PRINT_KERNEL_AST::v;
}

void sub_19375FF78(_Unwind_Exception *a1)
{
}

uint64_t CI_DISABLE_REDEYE_SEARCH()
{
  {
    CI_DISABLE_REDEYE_SEARCH::v = get_int("CI_DISABLE_REDEYE_SEARCH", 0);
  }
  return CI_DISABLE_REDEYE_SEARCH::v;
}

void sub_19375FFF8(_Unwind_Exception *a1)
{
}

uint64_t CI_LOG_DUALRED()
{
  {
    CI_LOG_DUALRED::v = get_int("CI_LOG_DUALRED", 0);
  }
  unsigned int valuePtr = 0;
  CFNumberRef v0 = (const __CFNumber *)CFPreferencesCopyAppValue(@"CI_LOG_DUALRED", @"com.apple.coremedia");
  if (!v0) {
    return CI_LOG_DUALRED::v;
  }
  CFNumberRef v1 = v0;
  CFTypeID v2 = CFGetTypeID(v0);
  if (v2 == CFNumberGetTypeID())
  {
    CFNumberGetValue(v1, kCFNumberIntType, &valuePtr);
  }
  else
  {
    CFTypeID v4 = CFGetTypeID(v1);
    if (v4 == CFStringGetTypeID()) {
      unsigned int valuePtr = CFStringGetIntValue((CFStringRef)v1);
    }
  }
  CFRelease(v1);
  uint64_t result = CI_LOG_DUALRED::v;
  if (valuePtr)
  {
    if (!CI_LOG_DUALRED::v)
    {
      CI_LOG_DUALRED::v = valuePtr;
      return valuePtr;
    }
  }
  return result;
}

void sub_193760118(_Unwind_Exception *a1)
{
}

__n128 cikernel::_facebalance(float32x4_t a1, float32x2_t a2)
{
  unsigned __int32 v12 = a1.u32[3];
  int8x16_t v11 = (int8x16_t)vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_1939507A0, a1, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_193950790, *(float32x2_t *)a1.f32, 1), vmulq_n_f32((float32x4_t)xmmword_193950780, a1.f32[0])));
  _S0 = v11.i32[1];
  __asm { FMLA            S1, S0, V2.S[1] }
  float v9 = fminf(_S1 * 4.0, 1.0);
  result.n128_f32[0] = pow(v9, 0.2);
  result.n128_u64[0] = (unint64_t)vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(v11, v11, 4uLL), vmul_n_f32(vmul_n_f32(a2, result.n128_f32[0]), 1.0 - (float)(v9 * v9)));
  result.n128_u64[0] = vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_193950800, (float32x2_t)result.n128_u64[0], 1), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.i8, 0), vmulq_n_f32((float32x4_t)xmmword_1939507F0, result.n128_f32[0]))).u64[0];
  result.n128_u32[3] = v12;
  return result;
}

void sub_193761698(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_193762230(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  a68(&a66);
  _Block_object_dispose(&a72, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__6(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__6(uint64_t a1)
{
}

Class ___ZL25getVNFaceObservationClassv_block_invoke(uint64_t a1)
{
  VisionLibrary();
  Class result = objc_getClass("VNFaceObservation");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    ___ZL25getVNFaceObservationClassv_block_invoke_cold_1();
  }
  getVNFaceObservationClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

uint64_t VisionLibrary(void)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  v2[0] = 0;
  if (!VisionLibraryCore(char **)::frameworkLibrary)
  {
    v2[1] = (void *)MEMORY[0x1E4F143A8];
    v2[2] = (void *)3221225472;
    v2[3] = ___ZL17VisionLibraryCorePPc_block_invoke;
    v2[4] = &__block_descriptor_40_e5_v8__0l;
    v2[5] = v2;
    long long v3 = xmmword_1E5771818;
    uint64_t v4 = 0;
    VisionLibraryCore(char **)::frameworkLibrarCGFloat y = _sl_dlopen();
  }
  uint64_t v0 = VisionLibraryCore(char **)::frameworkLibrary;
  if (!VisionLibraryCore(char **)::frameworkLibrary) {
    VisionLibrary(v2);
  }
  if (v2[0]) {
    free(v2[0]);
  }
  return v0;
}

{
  uint64_t v0;
  void *v2[6];
  long long v3;
  uint64_t v4;
  uint64_t v5;

  uint64_t v5 = *MEMORY[0x1E4F143B8];
  v2[0] = 0;
  if (!VisionLibraryCore(char **)::frameworkLibrary)
  {
    v2[1] = (void *)MEMORY[0x1E4F143A8];
    v2[2] = (void *)3221225472;
    v2[3] = ___ZL17VisionLibraryCorePPc_block_invoke_0;
    v2[4] = &__block_descriptor_40_e5_v8__0l;
    v2[5] = v2;
    long long v3 = xmmword_1E5772B00;
    uint64_t v4 = 0;
    VisionLibraryCore(char **)::frameworkLibrarCGFloat y = _sl_dlopen();
  }
  uint64_t v0 = VisionLibraryCore(char **)::frameworkLibrary;
  if (!VisionLibraryCore(char **)::frameworkLibrary) {
    VisionLibrary(v2);
  }
  if (v2[0]) {
    free(v2[0]);
  }
  return v0;
}

uint64_t ___ZL17VisionLibraryCorePPc_block_invoke()
{
  uint64_t result = _sl_dlopen();
  VisionLibraryCore(char **)::frameworkLibrarCGFloat y = result;
  return result;
}

Class ___ZL42getVNTrackLegacyFaceCoreObjectRequestClassv_block_invoke(uint64_t a1)
{
  VisionLibrary();
  Class result = objc_getClass("VNTrackLegacyFaceCoreObjectRequest");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    ___ZL42getVNTrackLegacyFaceCoreObjectRequestClassv_block_invoke_cold_1();
  }
  getVNTrackLegacyFaceCoreObjectRequestClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                          + 40);
  return result;
}

Class ___ZL37getVNDetectFaceRectanglesRequestClassv_block_invoke(uint64_t a1)
{
  VisionLibrary();
  Class result = objc_getClass("VNDetectFaceRectanglesRequest");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    ___ZL37getVNDetectFaceRectanglesRequestClassv_block_invoke_cold_1();
  }
  getVNDetectFaceRectanglesRequestClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

void *___ZL34getVNImageOptionCIContextSymbolLocv_block_invoke(uint64_t a1)
{
  CFTypeID v2 = (void *)VisionLibrary();
  Class result = dlsym(v2, "VNImageOptionCIContext");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getVNImageOptionCIContextSymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

Class ___ZL29getVNImageRequestHandlerClassv_block_invoke(uint64_t a1)
{
  VisionLibrary();
  Class result = objc_getClass("VNImageRequestHandler");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    ___ZL29getVNImageRequestHandlerClassv_block_invoke_cold_1();
  }
  getVNImageRequestHandlerClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

void *___ZL50getVNFaceLegacyFaceCoreFeature_SmileScoreSymbolLocv_block_invoke(uint64_t a1)
{
  CFTypeID v2 = (void *)VisionLibrary();
  Class result = dlsym(v2, "VNFaceLegacyFaceCoreFeature_SmileScore");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getVNFaceLegacyFaceCoreFeature_SmileScoreSymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                            + 24);
  return result;
}

void *___ZL58getVNFaceLegacyFaceCoreFeature_LeftEyeClosedScoreSymbolLocv_block_invoke(uint64_t a1)
{
  CFTypeID v2 = (void *)VisionLibrary();
  Class result = dlsym(v2, "VNFaceLegacyFaceCoreFeature_LeftEyeClosedScore");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getVNFaceLegacyFaceCoreFeature_LeftEyeClosedScoreSymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32)
                                                                                                + 8)
                                                                                    + 24);
  return result;
}

void *___ZL59getVNFaceLegacyFaceCoreFeature_RightEyeClosedScoreSymbolLocv_block_invoke(uint64_t a1)
{
  CFTypeID v2 = (void *)VisionLibrary();
  Class result = dlsym(v2, "VNFaceLegacyFaceCoreFeature_RightEyeClosedScore");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getVNFaceLegacyFaceCoreFeature_RightEyeClosedScoreSymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32)
                                                                                                 + 8)
                                                                                     + 24);
  return result;
}

void sub_19376478C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__7(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 48);
  long long v3 = *(_OWORD *)(a2 + 64);
  *(__n128 *)(a1 + 48) = result;
  *(_OWORD *)(a1 + 64) = v3;
  return result;
}

double addPoints(CIVector *a1, CIVector *a2, CGRect a3, float a4, float a5)
{
  CGFloat height = a3.size.height;
  CGFloat width = a3.size.width;
  double y = a3.origin.y;
  double x = a3.origin.x;
  uint64_t v11 = 0;
  double v12 = a4;
  double v24 = a5;
  double v13 = 1.0;
  do
  {
    [(CIVector *)a1 valueAtIndex:v11];
    double v15 = v14;
    [(CIVector *)a2 valueAtIndex:v11];
    double v17 = v15 * v12;
    if (fabs(v17 + v13) > 0.001)
    {
      CGFloat v18 = x;
      CGFloat v19 = y;
      CGFloat v20 = width;
      CGFloat v21 = height;
      double v22 = v16 * v24;
      if (fabs(v16 * v24 + 1.0) <= 0.001)
      {
        CGFloat height = v21;
        CGFloat width = v20;
        double y = v19;
        double x = v18;
      }
      else
      {
        v25.origin.double x = v18;
        v25.origin.double y = v19;
        v25.size.CGFloat width = v20;
        v25.size.CGFloat height = v21;
        if (CGRectIsNull(v25))
        {
          double x = v17 + -0.5;
          double y = v22 + -0.5;
          CGFloat width = 1.0;
          CGFloat height = 1.0;
        }
        else
        {
          v28.size.CGFloat width = 1.0;
          v28.size.CGFloat height = 1.0;
          v26.origin.double x = v18;
          v26.origin.double y = v19;
          v26.size.CGFloat width = v20;
          v26.size.CGFloat height = v21;
          v28.origin.double x = v17 + -0.5;
          v28.origin.double y = v22 + -0.5;
          CGRect v27 = CGRectUnion(v26, v28);
          double x = v27.origin.x;
          double y = v27.origin.y;
          CGFloat width = v27.size.width;
          CGFloat height = v27.size.height;
        }
      }
      double v13 = 1.0;
    }
    ++v11;
  }
  while (v11 != 4);
  return x;
}

void sub_193764F98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__n64 cikernel::_CIFaceMaskApply(uint64_t a1, uint64_t a2, float32x4_t a3, float64x2_t a4, float32x4_t a5, float32x4_t a6, int8x16_t a7, int8x16_t a8, int8x16_t a9)
{
  int32x2_t v111 = *(int32x2_t *)a9.i8;
  float32x2_t v9 = *(float32x2_t *)a8.i8;
  float v103 = *(float *)a7.i32;
  float32x4_t v106 = a5;
  float32x4_t v107 = a6;
  float32x4_t v100 = (float32x4_t)a4;
  a5.i32[0] = *(_DWORD *)(a2 + 28);
  *(float *)&double v12 = *(float *)(a2 + 24)
                 + (float)((float)(*(float *)(a2 + 20) * 0.5) + (float)(*(float *)(a2 + 16) * 0.5));
  a6.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)a4.f64 = a6.f32[0] + (float)((float)(*(float *)(a2 + 32) * 0.5) + (float)(a5.f32[0] * 0.5));
  *((float *)&v12 + 1) = *(float *)a4.f64;
  *(double *)v13.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v12, a4, *(double *)a5.i64, *(double *)a6.i64, a7, a8, a9);
  float32x4_t v110 = v13;
  LODWORD(v14) = *(_DWORD *)(a2 + 28);
  v15.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v16.i32 = *(float *)(a2 + 32) * 0.5;
  *(float *)&double v17 = *(float *)v16.i32 + (float)(*(float *)&v14 * 1.5);
  v13.f32[0] = *(float *)(a2 + 24) + (float)((float)(*(float *)(a2 + 20) * 0.5) + (float)(*(float *)(a2 + 16) * 1.5));
  *(float *)v18.f64 = *(float *)v15.i32 + *(float *)&v17;
  v13.f32[1] = *(float *)v15.i32 + *(float *)&v17;
  *(double *)v20.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v13.i64, v18, v17, v14, v16, v15, v19);
  float32x4_t v108 = v20;
  LODWORD(v21) = *(_DWORD *)(a2 + 28);
  v22.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v23.i32 = *(float *)(a2 + 32) * 0.5;
  *(float *)&double v24 = *(float *)v23.i32 + (float)(*(float *)&v21 * 2.5);
  v20.f32[0] = *(float *)(a2 + 24) + (float)((float)(*(float *)(a2 + 20) * 0.5) + (float)(*(float *)(a2 + 16) * 2.5));
  *(float *)v25.f64 = *(float *)v22.i32 + *(float *)&v24;
  v20.f32[1] = *(float *)v22.i32 + *(float *)&v24;
  *(double *)&long long v27 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v20.i64, v25, v24, v21, v23, v22, v26);
  long long v105 = v27;
  LODWORD(v28) = *(_DWORD *)(a2 + 28);
  v29.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v30.i32 = *(float *)(a2 + 32) * 0.5;
  *(float *)&double v31 = *(float *)v30.i32 + (float)(*(float *)&v28 * 3.5);
  *(float *)&long long v27 = *(float *)(a2 + 24)
                 + (float)((float)(*(float *)(a2 + 20) * 0.5) + (float)(*(float *)(a2 + 16) * 3.5));
  *(float *)v32.f64 = *(float *)v29.i32 + *(float *)&v31;
  *((float *)&v27 + 1) = *(float *)v29.i32 + *(float *)&v31;
  *(double *)v34.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)&v27, v32, v31, v28, v30, v29, v33);
  float32x4_t v102 = v34;
  LODWORD(v35) = 4.5;
  LODWORD(v36) = *(_DWORD *)(a2 + 28);
  v34.f32[0] = *(float *)(a2 + 24) + (float)((float)(*(float *)(a2 + 20) * 0.5) + (float)(*(float *)(a2 + 16) * 4.5));
  v37.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v38.f64 = *(float *)v37.i32 + (float)((float)(*(float *)(a2 + 32) * 0.5) + (float)(*(float *)&v36 * 4.5));
  v34.f32[1] = *(float *)v38.f64;
  double v41 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v34.i64, v38, v35, v36, v37, v39, v40);
  float v109 = *(float *)&v41;
  DC = (float32x2_t *)CI::getDC(v42);
  int32x2_t v44 = (int32x2_t)vmul_f32(v9, *DC);
  float32x4_t v99 = vsubq_f32((float32x4_t)vdupq_lane_s32(v44, 0), a3);
  float32x4_t v101 = vmulq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(v44, 1), v100), v103);
  float32x4_t v104 = vsqrtq_f32(vaddq_f32(vmulq_f32(v99, v99), vmulq_f32(v101, v101)));
  float32x2_t v45 = (float32x2_t *)CI::getDC((CI *)DC);
  *(float *)&double v46 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *v45, 1), *(float *)(a1 + 16), COERCE_FLOAT(*v45));
  LODWORD(v47) = *(_DWORD *)(a1 + 28);
  v48.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v49.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *v45, 1), *(float *)&v47, COERCE_FLOAT(*v45));
  *(float *)&double v50 = *(float *)(a1 + 24) + *(float *)&v46;
  *(float *)v51.f64 = *(float *)v48.i32 + *(float *)v49.i32;
  *((float *)&v50 + 1) = *(float *)v48.i32 + *(float *)v49.i32;
  *(double *)v53.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v50, v51, v46, v47, v49, v48, v52);
  float32x4_t v54 = vaddq_f32(vmulq_f32(v106, v99), vmulq_f32(v107, v101));
  float32x4_t v55 = vdivq_f32(vabdq_f32(vmulq_f32(v106, v101), vmulq_f32(v107, v99)), vaddq_f32(vabsq_f32(v54), (float32x4_t)vdupq_n_s32(0x2EDBE6FFu)));
  BOOL v56 = v106.f32[0] != 0.0 || v107.f32[0] != 0.0;
  if (v54.f32[0] < 0.0) {
    BOOL v56 = 0;
  }
  if (v55.f32[0] >= 1.5574) {
    BOOL v56 = 0;
  }
  BOOL v57 = v106.f32[1] != 0.0 || v107.f32[1] != 0.0;
  if (v54.f32[1] < 0.0) {
    BOOL v57 = 0;
  }
  if (v55.f32[1] >= 1.5574) {
    BOOL v57 = 0;
  }
  BOOL v58 = v106.f32[2] != 0.0 || v107.f32[2] != 0.0;
  if (v54.f32[2] < 0.0) {
    BOOL v58 = 0;
  }
  if (v55.f32[2] >= 1.5574) {
    BOOL v58 = 0;
  }
  BOOL v59 = v106.f32[3] != 0.0 || v107.f32[3] != 0.0;
  if (v54.f32[3] < 0.0) {
    BOOL v59 = 0;
  }
  if (v55.f32[3] >= 1.5574) {
    BOOL v59 = 0;
  }
  _S2 = v104.i32[1];
  double v61 = 0.0;
  _V16.D[1] = *((void *)&v105 + 1);
  _S5 = DWORD1(v105);
  __asm { FMLA            S3, S2, V16.S[1] }
  double v69 = _S3;
  if (_NF != _VF) {
    double v69 = 0.0;
  }
  _S3 = v104.i32[2];
  __asm { FMLA            S5, S3, V16.S[2] }
  double v72 = _S5;
  if (_NF != _VF) {
    double v72 = 0.0;
  }
  _S5 = v104.i32[3];
  __asm { FMLA            S6, S5, V16.S[3] }
  double v75 = _S6;
  if (_NF != _VF) {
    double v75 = 0.0;
  }
  float32x4_t v76 = vaddq_f32(v108, vmulq_f32(v110, v104));
  double v77 = vmlas_n_f32((float)-*(float *)&v105 * v102.f32[0], *(float *)&v105, v104.f32[0]);
  if ((vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vcgeq_f32(v104, v102))).u8[0] & 1) == 0) {
    double v61 = v77;
  }
  float v78 = v61 + v76.f32[0];
  float v79 = v69 + v76.f32[1];
  float v80 = v72 + v76.f32[2];
  float32x4_t v81 = vmaxnmq_f32((float32x4_t)vdupq_lane_s32(v111, 0), vaddq_f32(vmulq_f32(v55, (float32x4_t)vdupq_n_s32(0x3F8872B0u)), vmulq_f32(v55, vmulq_f32(v55, (float32x4_t)vdupq_n_s32(0xBE8D4FDF)))));
  double v82 = vmuls_lane_f32(*(float *)&v111.i32[1], v81, 3);
  double v83 = vmuls_lane_f32(*(float *)&v111.i32[1], v81, 2);
  double v84 = vmuls_lane_f32(*(float *)&v111.i32[1], *(float32x2_t *)v81.f32, 1);
  double v85 = vmuls_lane_f32(v81.f32[0], (float32x2_t)v111, 1);
  float v86 = v75 + v76.f32[3];
  if (v78 <= 0.0 || !v56) {
    double v85 = 1.0;
  }
  float v87 = v85 * v78;
  if (v79 > 0.0 && v57) {
    double v88 = v84;
  }
  else {
    double v88 = 1.0;
  }
  float v89 = v88 * v79;
  if (v80 > 0.0 && v58) {
    double v90 = v83;
  }
  else {
    double v90 = 1.0;
  }
  float v91 = v90 * v80;
  if (v86 > 0.0 && v59) {
    double v92 = v82;
  }
  else {
    double v92 = 1.0;
  }
  float v93 = vmulq_f32(v53, v53).f32[0];
  float v94 = v92 * v86;
  float v95 = v93 + fminf(fminf(v87, v89), fminf(v91, v94));
  float v96 = fmaxf(v109, v93);
  if (v95 <= v96) {
    float v96 = v95;
  }
  if (v95 < 0.0) {
    float v96 = 0.0;
  }
  result.n64_f32[0] = sqrtf(v96);
  result.n64_u32[1] = 0;
  return result;
}

void CI::f4_sr_f4_f4_f4_f4_f_sr_f2_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = *(void *)(a1 + 48);
  uint64_t v11 = *(double (**)(uint64_t, uint64_t, __n128, __n128, __n128, __n128, float, double, double))(a1 + 24);
  uint64_t v12 = *(void *)(v10 + 8);
  int v13 = *(_DWORD *)(v10 + 40);
  uint64_t v14 = *(void *)(v10 + 32);
  int v15 = *(_DWORD *)(v10 + 64);
  uint64_t v16 = *(void *)(v10 + 56);
  int v17 = *(_DWORD *)(v10 + 88);
  uint64_t v18 = *(void *)(v10 + 80);
  int v19 = *(_DWORD *)(v10 + 112);
  uint64_t v20 = *(void *)(v10 + 104);
  uint64_t v21 = *(void *)(v10 + 128);
  uint64_t v22 = *(void *)(v10 + 152);
  int v23 = *(_DWORD *)(v10 + 184);
  uint64_t v24 = *(void *)(v10 + 176);
  int v25 = *(_DWORD *)(v10 + 208);
  uint64_t v26 = *(void *)(v10 + 200);
  if (*(unsigned char *)(a1 + 64))
  {
    int8x16_t v39 = *(double (**)(uint64_t, uint64_t, __n128, __n128, __n128, __n128, float, double, double))(a1 + 24);
    uint64_t v40 = *(void *)(v10 + 56);
    uint64_t v42 = *(void *)(v10 + 152);
    uint64_t v43 = *(void *)(v10 + 8);
    int v41 = *(_DWORD *)(v10 + 40);
    uint64_t v38 = *(void *)(v10 + 80);
    int v36 = *(_DWORD *)(v10 + 184);
    int v37 = *(_DWORD *)(v10 + 112);
    int v35 = *(_DWORD *)(v10 + 208);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 224)), a2);
    int v25 = v35;
    int v23 = v36;
    int v19 = v37;
    uint64_t v18 = v38;
    uint64_t v11 = v39;
    uint64_t v16 = v40;
    uint64_t v22 = v42;
    uint64_t v12 = v43;
    int v13 = v41;
  }
  long long v27 = (double *)(a3 + 16 * v26);
  if (v25 != 5) {
    long long v27 = (double *)((char *)a2 + 64 * v26);
  }
  double v28 = (double *)(a3 + 16 * v24);
  if (v23 != 5) {
    double v28 = (double *)((char *)a2 + 64 * v24);
  }
  int8x16_t v29 = (__n128 *)(a3 + 16 * v20);
  if (v19 != 5) {
    int8x16_t v29 = (__n128 *)((char *)a2 + 64 * v20);
  }
  int8x16_t v30 = (__n128 *)(a3 + 16 * v18);
  double v31 = (__n128 *)((char *)a2 + 64 * v18);
  if (v17 != 5) {
    int8x16_t v30 = v31;
  }
  float64x2_t v32 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5) {
    float64x2_t v32 = (__n128 *)((char *)a2 + 64 * v16);
  }
  int8x16_t v33 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    int8x16_t v33 = (__n128 *)((char *)a2 + 64 * v14);
  }
  *(double *)&long long v34 = v11(a4 + 80 * v12, a4 + 80 * v22, *v33, *v32, *v30, *v29, *((float *)a2 + 16 * v21), *v28, *v27);
  *(_OWORD *)(a3 + 16 * a7) = v34;
}

void cikernel::_faceMaskCalculator(uint64_t a1, int8x16_t a2, float64x2_t a3, double a4, double a5, int8x16_t a6, int8x16_t a7, int8x16_t a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16, double a17, float a18, float a19, float a20,float a21)
{
  float32x4_t v43 = (float32x4_t)a3;
  if (a18 > 0.0)
  {
    LODWORD(a4) = *(_DWORD *)(a1 + 28);
    *(float *)&double v28 = *(float *)(a1 + 24)
                   + vmlas_n_f32(*(float *)(a1 + 20) * *(float *)a3.f64, *(float *)(a1 + 16), *(float *)a2.i32);
    LODWORD(a5) = *(_DWORD *)(a1 + 36);
    *(float *)a3.f64 = *(float *)&a5
                     + vmlas_n_f32(*(float *)(a1 + 32) * *(float *)a3.f64, *(float *)&a4, *(float *)a2.i32);
    HIDWORD(v28) = LODWORD(a3.f64[0]);
    CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v28, a3, a4, a5, (int8x16_t)v43, a2, a8);
  }
  if (a19 > 0.0)
  {
    v29.i32[0] = *(_DWORD *)(a1 + 16);
    LODWORD(a3.f64[0]) = *(_DWORD *)(a1 + 20);
    LODWORD(v30) = *(_DWORD *)(a1 + 24);
    HIDWORD(a3.f64[0]) = *(_DWORD *)(a1 + 32);
    v29.i32[1] = *(_DWORD *)(a1 + 28);
    *(float32x2_t *)&a3.f64[0] = vmla_lane_f32(vmul_lane_f32(*(float32x2_t *)&a3.f64[0], *(float32x2_t *)v43.f32, 1), v29, *(float32x2_t *)a2.i8, 1);
    HIDWORD(v30) = *(_DWORD *)(a1 + 36);
    CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v30, *(float32x2_t *)&a3.f64[0])), a3, v30, *(double *)a2.i64, a6, a7, a8);
  }
  if (a20 > 0.0)
  {
    v31.i32[0] = *(_DWORD *)(a1 + 16);
    LODWORD(a3.f64[0]) = *(_DWORD *)(a1 + 20);
    LODWORD(v32) = *(_DWORD *)(a1 + 24);
    HIDWORD(a3.f64[0]) = *(_DWORD *)(a1 + 32);
    v31.i32[1] = *(_DWORD *)(a1 + 28);
    *(float32x2_t *)&a3.f64[0] = vmla_laneq_f32(vmul_laneq_f32(*(float32x2_t *)&a3.f64[0], v43, 2), v31, (float32x4_t)a2, 2);
    HIDWORD(v32) = *(_DWORD *)(a1 + 36);
    CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v32, *(float32x2_t *)&a3.f64[0])), a3, v32, *(double *)a2.i64, a6, a7, a8);
  }
  if (a21 > 0.0)
  {
    v33.i32[0] = *(_DWORD *)(a1 + 16);
    LODWORD(a3.f64[0]) = *(_DWORD *)(a1 + 20);
    LODWORD(v34) = *(_DWORD *)(a1 + 24);
    HIDWORD(a3.f64[0]) = *(_DWORD *)(a1 + 32);
    v33.i32[1] = *(_DWORD *)(a1 + 28);
    *(float32x2_t *)&a3.f64[0] = vmla_laneq_f32(vmul_laneq_f32(*(float32x2_t *)&a3.f64[0], v43, 3), v33, (float32x4_t)a2, 3);
    HIDWORD(v34) = *(_DWORD *)(a1 + 36);
    CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v34, *(float32x2_t *)&a3.f64[0])), a3, v34, *(double *)a2.i64, a6, a7, a8);
  }
  if (a18 > 0.0)
  {
    LODWORD(a4) = *(_DWORD *)(a1 + 28);
    *(float *)&double v35 = *(float *)(a1 + 24)
                   + vmlas_n_f32(*(float *)(a1 + 20) * *(float *)a7.i32, *(float *)(a1 + 16), *(float *)a6.i32);
    LODWORD(a5) = *(_DWORD *)(a1 + 36);
    *(float *)a3.f64 = *(float *)&a5
                     + vmlas_n_f32(*(float *)(a1 + 32) * *(float *)a7.i32, *(float *)&a4, *(float *)a6.i32);
    HIDWORD(v35) = LODWORD(a3.f64[0]);
    CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v35, a3, a4, a5, a7, a6, a8);
  }
  if (a19 > 0.0)
  {
    v36.i32[0] = *(_DWORD *)(a1 + 16);
    LODWORD(a3.f64[0]) = *(_DWORD *)(a1 + 20);
    LODWORD(v37) = *(_DWORD *)(a1 + 24);
    HIDWORD(a3.f64[0]) = *(_DWORD *)(a1 + 32);
    v36.i32[1] = *(_DWORD *)(a1 + 28);
    *(float32x2_t *)&a3.f64[0] = vmla_lane_f32(vmul_lane_f32(*(float32x2_t *)&a3.f64[0], *(float32x2_t *)a7.i8, 1), v36, *(float32x2_t *)a6.i8, 1);
    HIDWORD(v37) = *(_DWORD *)(a1 + 36);
    CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v37, *(float32x2_t *)&a3.f64[0])), a3, v37, *(double *)a6.i64, a6, a7, a8);
  }
  if (a20 > 0.0)
  {
    v38.i32[0] = *(_DWORD *)(a1 + 16);
    LODWORD(a3.f64[0]) = *(_DWORD *)(a1 + 20);
    LODWORD(v39) = *(_DWORD *)(a1 + 24);
    HIDWORD(a3.f64[0]) = *(_DWORD *)(a1 + 32);
    v38.i32[1] = *(_DWORD *)(a1 + 28);
    *(float32x2_t *)&a3.f64[0] = vmla_laneq_f32(vmul_laneq_f32(*(float32x2_t *)&a3.f64[0], (float32x4_t)a7, 2), v38, (float32x4_t)a6, 2);
    HIDWORD(v39) = *(_DWORD *)(a1 + 36);
    CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v39, *(float32x2_t *)&a3.f64[0])), a3, v39, *(double *)a6.i64, a6, a7, a8);
  }
  if (a21 > 0.0)
  {
    v40.i32[0] = *(_DWORD *)(a1 + 16);
    LODWORD(a3.f64[0]) = *(_DWORD *)(a1 + 20);
    LODWORD(v41) = *(_DWORD *)(a1 + 24);
    HIDWORD(a3.f64[0]) = *(_DWORD *)(a1 + 32);
    v40.i32[1] = *(_DWORD *)(a1 + 28);
    *(float32x2_t *)&a3.f64[0] = vmla_laneq_f32(vmul_laneq_f32(*(float32x2_t *)&a3.f64[0], (float32x4_t)a7, 3), v40, (float32x4_t)a6, 3);
    HIDWORD(v41) = *(_DWORD *)(a1 + 36);
    CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v41, *(float32x2_t *)&a3.f64[0])), a3, v41, *(double *)a6.i64, a6, a7, a8);
  }
  CI::getDC((CI *)a1);
  cikernel::_computeFaceMaskParams();
}

void cikernel::_computeFaceMaskParams()
{
  __asm { FMOV            V19.4S, #1.0 }
}

uint64_t imageByApplyingOrientationInverse(void *a1, uint64_t a2)
{
  if ((a2 - 5) <= 3) {
    a2 = dword_1939532A0[(int)a2 - 5];
  }
  if (a1) {
    [a1 imageTransformForOrientation:a2];
  }
  else {
    memset(v4, 0, sizeof(v4));
  }
  return [a1 imageByApplyingTransform:v4];
}

double segmentationCentroidInImage(void *a1, void *a2, void *a3)
{
  v24[1] = *MEMORY[0x1E4F143B8];
  int v23 = @"inputExtent";
  v24[0] = +[CIVector vectorWithCGRect:](CIVector, "vectorWithCGRect:");
  uint64_t v6 = objc_msgSend(a2, "imageByApplyingFilter:withInputParameters:", @"CIAreaRedCentroid", objc_msgSend(MEMORY[0x1E4F1C9E8], "dictionaryWithObjects:forKeys:count:", v24, &v23, 1));
  uint64_t v21 = @"working_color_space";
  uint64_t v22 = [MEMORY[0x1E4F1CA98] null];
  id v7 = +[CIContext _cachedContext:options:](CIContext, "_cachedContext:options:", @"CIFaceUtils-segmentationCentroid", [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v22 forKeys:&v21 count:1]);
  {
    id v18 = v7;
    id v7 = v18;
    if (v19)
    {
      segmentationCentroidInImage::cs = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC88]);
      id v7 = v18;
    }
  }
  objc_msgSend(v7, "render:toBitmap:rowBytes:bounds:format:colorSpace:", v6, &v20, 32, 2312, segmentationCentroidInImage::cs, 0.0, 0.0, 1.0, 1.0);
  double v8 = v20;
  if (a3)
  {
    [a1 boundingBox];
    CIVNRectInOrientedImage(a3, v9, v10, v11, v12);
    CGRect v26 = CGRectIntegral(v25);
    double x = v26.origin.x;
    double width = v26.size.width;
    [a2 extent];
    double v16 = v15;
    [a2 extent];
    return x + v8 / v16 * width;
  }
  return v8;
}

void sub_193766C38(_Unwind_Exception *a1)
{
}

double constellationRectInSegmentationRect(void *a1, void *a2, void *a3, unint64_t a4)
{
  [a3 boundingBox];
  CIVNRectInOrientedImage(a1, v7, v8, v9, v10);
  CGRect v26 = CGRectIntegral(v25);
  double x = v26.origin.x;
  double y = v26.origin.y;
  double width = v26.size.width;
  double height = v26.size.height;
  id v15 = CIVNLandmarkInOrientedImage(a2, a1);
  v27.origin.double x = CIVNBoundingRect(v15);
  CGRect v28 = CGRectIntegral(v27);
  double v16 = (float)a4;
  double v17 = v16 / width;
  double v18 = v16 / height;
  double v19 = v17 * (v28.origin.x - x);
  double v20 = v18 * (v28.origin.y - y);
  double v21 = v17 * v28.size.width;
  double v22 = v18 * v28.size.height;

  *(void *)&double result = (unint64_t)CGRectIntegral(*(CGRect *)&v19);
  return result;
}

void *probabilitiesForSegment(void *a1, uint64_t a2, uint64_t a3)
{
  v14[1] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (void *)[MEMORY[0x1E4F1CA48] array];
  uint64_t v7 = 0;
  uint64_t v12 = 0;
  do
  {
    if (((1 << v7) & a2) != 0)
    {
      [a1 boundingBox];
      CGFloat v8 = (__CVBuffer *)objc_msgSend(a1, "createProbabilityImageOfFaceSegment:region:normalize:error:", 1 << v7, 1, &v12);
      CGFloat v9 = +[CIImage imageWithCVPixelBuffer:v8];
      CVPixelBufferRelease(v8);
      if (a3)
      {
        CGFloat v10 = (void *)imageByApplyingOrientationInverse(v9, a3);
        int v13 = @"Orientation";
        v14[0] = [NSNumber numberWithInt:a3];
        CGFloat v9 = (CIImage *)objc_msgSend(v10, "imageBySettingProperties:", objc_msgSend(MEMORY[0x1E4F1C9E8], "dictionaryWithObjects:forKeys:count:", v14, &v13, 1));
      }
      double result = 0;
      if (v12 || !v9) {
        return result;
      }
      [v6 addObject:v9];
    }
    ++v7;
  }
  while (v7 != 15);
  return v6;
}

CVPixelBufferRef convertToFullFloatPixelBuffer(void *a1, double a2, double a3, double a4, double a5)
{
  int v8 = [a1 format];
  int v9 = [a1 format];
  if (v8 == 2309)
  {
    if (v9 != 2309) {
      convertToFullFloatPixelBuffer_cold_1();
    }
    [a1 region];
    int v11 = (int)-v10;
    [a1 region];
    int v13 = (int)-v12;
    size_t v14 = [a1 bytesPerRow];
    id v15 = (char *)([a1 baseAddress] + v14 * v13 + 4 * v11);
    return createPixelBuffer((unint64_t)a4, (unint64_t)a5, v14, v15);
  }
  else
  {
    if (v9 != 2053) {
      return 0;
    }
    if ([a1 format] != 2053) {
      convertToFullFloatPixelBuffer_cold_2();
    }
    uint64_t v17 = [a1 baseAddress];
    [a1 region];
    vImagePixelCount v19 = (unint64_t)v18;
    [a1 region];
    vImagePixelCount v21 = (unint64_t)v20;
    size_t v22 = [a1 bytesPerRow];
    [a1 region];
    int v24 = (int)-v23;
    [a1 region];
    CGRect v26 = (void *)(v17 + v22 * (int)-v25 + 2 * v24);
    CGRect v27 = malloc_type_malloc(4 * (unint64_t)a4 * (unint64_t)a5, 0x100004052888210uLL);
    src.data = v26;
    src.double height = v21;
    src.double width = v19;
    src.rowBytes = v22;
    v29.data = v27;
    v29.double height = (unint64_t)a5;
    v29.double width = (unint64_t)a4;
    v29.rowBytes = 4 * (unint64_t)a4;
    vImageConvert_Planar16FtoPlanarF(&src, &v29, 0);
    CVPixelBufferRef PixelBuffer = createPixelBuffer((unint64_t)a4, (unint64_t)a5, 4 * (unint64_t)a4, (char *)v27);
    free(v27);
    return PixelBuffer;
  }
}

CVPixelBufferRef createPixelBuffer(size_t a1, size_t a2, size_t a3, char *a4)
{
  v19[2] = *MEMORY[0x1E4F143B8];
  v19[0] = MEMORY[0x1E4F1CC08];
  uint64_t v8 = *MEMORY[0x1E4F24D70];
  v18[0] = *MEMORY[0x1E4F24D20];
  v18[1] = v8;
  v19[1] = [NSNumber numberWithUnsignedInt:1278226534];
  CVPixelBufferRef pixelBuffer = 0;
  CVReturn v9 = CVPixelBufferCreate(0, a1, a2, 0x4C303066u, (CFDictionaryRef)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v19 forKeys:v18 count:2], &pixelBuffer);
  CVPixelBufferRef result = 0;
  if (!v9)
  {
    if (!a4) {
      goto LABEL_14;
    }
    if (CVPixelBufferLockBaseAddress(pixelBuffer, 0)) {
      goto LABEL_17;
    }
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(pixelBuffer);
    size_t BytesPerRow = CVPixelBufferGetBytesPerRow(pixelBuffer);
    if (BytesPerRow == a3)
    {
      memcpy(BaseAddress, a4, a3 * a2);
    }
    else if (BytesPerRow >= a3)
    {
      NSLog(&cfstr_CanTWorkWithAn.isa);
      CVPixelBufferRelease(pixelBuffer);
      CVPixelBufferRef pixelBuffer = 0;
    }
    else
    {
      size_t v13 = CVPixelBufferGetBytesPerRow(pixelBuffer);
      if (a2)
      {
        size_t v14 = v13;
        size_t v15 = 0;
        unsigned int v16 = 1;
        do
        {
          memcpy(&BaseAddress[v15 * v14], &a4[v15 * a3], v14);
          size_t v15 = v16++;
        }
        while (v15 < a2);
      }
    }
    if (CVPixelBufferUnlockBaseAddress(pixelBuffer, 0))
    {
LABEL_17:
      CVPixelBufferRelease(pixelBuffer);
      CVPixelBufferRef pixelBuffer = 0;
    }
    else
    {
LABEL_14:
      if (pixelBuffer && CVPixelBufferGetPixelFormatType(pixelBuffer) == 1278226534) {
        return pixelBuffer;
      }
    }
    createPixelBuffer_cold_1();
  }
  return result;
}

void sub_19376B074(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a71, 8);
  _Unwind_Resume(a1);
}

void appendAttrStr(NSMutableAttributedString *a1, NSString *a2)
{
  id v4 = objc_alloc(MEMORY[0x1E4F28B18]);
  id v5 = (id)[v4 initWithString:a2 attributes:MEMORY[0x1E4F1CC08]];
  [(NSMutableAttributedString *)a1 appendAttributedString:v5];
}

void appendAttrStrCode(NSMutableAttributedString *a1, NSString *a2)
{
  id v4 = (id)[objc_alloc(MEMORY[0x1E4F28B18]) initWithMarkdownString:v3 options:0 baseURL:0 error:0];
  [(NSMutableAttributedString *)a1 appendAttributedString:v4];
}

void *iiGetter(void *a1)
{
  outValue = 0;
  object_getInstanceVariable(a1, "inputImage", &outValue);
  return outValue;
}

Ivar iiSetter(void *a1, uint64_t a2, void *a3)
{
  outValue = 0;
  object_getInstanceVariable(a1, "inputImage", &outValue);
  id v5 = outValue;
  id v6 = a3;
  return object_setInstanceVariable(a1, "inputImage", a3);
}

uint64_t objGetter(void *a1, SEL aSelector)
{
  uint64_t v3 = NSStringFromSelector(aSelector);
  if ([(NSString *)v3 isEqualToString:@"parameterB"])
  {
    id v4 = @"inputB";
  }
  else if ([(NSString *)v3 isEqualToString:@"parameterC"])
  {
    id v4 = @"inputC";
  }
  else if ([(NSString *)v3 isEqualToString:@"underColorRemoval"])
  {
    id v4 = @"inputUCR";
  }
  else if ([(NSString *)v3 isEqualToString:@"grayComponentReplacement"])
  {
    id v4 = @"inputGCR";
  }
  else if ([(NSString *)v3 isEqualToString:@"textureImage"])
  {
    id v4 = @"inputTexture";
  }
  else
  {
    id v4 = (__CFString *)objc_msgSend(@"input", "stringByAppendingString:", -[NSString stringByReplacingCharactersInRange:withString:](v3, "stringByReplacingCharactersInRange:withString:", 0, 1, -[NSString uppercaseString](-[NSString substringWithRange:](v3, "substringWithRange:", 0, 1), "uppercaseString")));
  }

  return [a1 valueForKey:v4];
}

float floatGetter(void *a1, SEL aSelector)
{
  uint64_t v3 = NSStringFromSelector(aSelector);
  if ([(NSString *)v3 isEqualToString:@"parameterB"])
  {
    id v4 = @"inputB";
  }
  else if ([(NSString *)v3 isEqualToString:@"parameterC"])
  {
    id v4 = @"inputC";
  }
  else if ([(NSString *)v3 isEqualToString:@"underColorRemoval"])
  {
    id v4 = @"inputUCR";
  }
  else if ([(NSString *)v3 isEqualToString:@"grayComponentReplacement"])
  {
    id v4 = @"inputGCR";
  }
  else if ([(NSString *)v3 isEqualToString:@"textureImage"])
  {
    id v4 = @"inputTexture";
  }
  else
  {
    id v4 = (__CFString *)objc_msgSend(@"input", "stringByAppendingString:", -[NSString stringByReplacingCharactersInRange:withString:](v3, "stringByReplacingCharactersInRange:withString:", 0, 1, -[NSString uppercaseString](-[NSString substringWithRange:](v3, "substringWithRange:", 0, 1), "uppercaseString")));
  }
  uint64_t v5 = [a1 valueForKey:v4];
  if (!v5) {
    return NAN;
  }
  id v6 = (void *)v5;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    return NAN;
  }

  [v6 floatValue];
  return result;
}

uint64_t BOOLGetter(void *a1, SEL aSelector)
{
  uint64_t v3 = NSStringFromSelector(aSelector);
  if ([(NSString *)v3 isEqualToString:@"parameterB"])
  {
    id v4 = @"inputB";
  }
  else if ([(NSString *)v3 isEqualToString:@"parameterC"])
  {
    id v4 = @"inputC";
  }
  else if ([(NSString *)v3 isEqualToString:@"underColorRemoval"])
  {
    id v4 = @"inputUCR";
  }
  else if ([(NSString *)v3 isEqualToString:@"grayComponentReplacement"])
  {
    id v4 = @"inputGCR";
  }
  else if ([(NSString *)v3 isEqualToString:@"textureImage"])
  {
    id v4 = @"inputTexture";
  }
  else
  {
    id v4 = (__CFString *)objc_msgSend(@"input", "stringByAppendingString:", -[NSString stringByReplacingCharactersInRange:withString:](v3, "stringByReplacingCharactersInRange:withString:", 0, 1, -[NSString uppercaseString](-[NSString substringWithRange:](v3, "substringWithRange:", 0, 1), "uppercaseString")));
  }
  uint64_t v5 = [a1 valueForKey:v4];
  if (!v5) {
    return 0;
  }
  id v6 = (void *)v5;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    return 0;
  }

  return [v6 BOOLValue];
}

uint64_t BOOLSetter(void *a1, const char *a2)
{
  uint64_t v4 = objc_msgSend(NSNumber, "numberWithBool:");
  uint64_t v5 = keyForSetter(a2);

  return [a1 setValue:v4 forKey:v5];
}

double rectGetter(void *a1, SEL aSelector)
{
  uint64_t v3 = NSStringFromSelector(aSelector);
  if ([(NSString *)v3 isEqualToString:@"parameterB"])
  {
    uint64_t v4 = @"inputB";
  }
  else if ([(NSString *)v3 isEqualToString:@"parameterC"])
  {
    uint64_t v4 = @"inputC";
  }
  else if ([(NSString *)v3 isEqualToString:@"underColorRemoval"])
  {
    uint64_t v4 = @"inputUCR";
  }
  else if ([(NSString *)v3 isEqualToString:@"grayComponentReplacement"])
  {
    uint64_t v4 = @"inputGCR";
  }
  else if ([(NSString *)v3 isEqualToString:@"textureImage"])
  {
    uint64_t v4 = @"inputTexture";
  }
  else
  {
    uint64_t v4 = (__CFString *)objc_msgSend(@"input", "stringByAppendingString:", -[NSString stringByReplacingCharactersInRange:withString:](v3, "stringByReplacingCharactersInRange:withString:", 0, 1, -[NSString uppercaseString](-[NSString substringWithRange:](v3, "substringWithRange:", 0, 1), "uppercaseString")));
  }
  uint64_t v5 = [a1 valueForKey:v4];
  if (!v5) {
    return *MEMORY[0x1E4F1DB20];
  }
  id v6 = (void *)v5;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    return *MEMORY[0x1E4F1DB20];
  }
  [v6 CGRectValue];
  return result;
}

uint64_t rectSetter(void *a1, const char *a2)
{
  uint64_t v4 = +[CIVector vectorWithCGRect:](CIVector, "vectorWithCGRect:");
  uint64_t v5 = keyForSetter(a2);

  return [a1 setValue:v4 forKey:v5];
}

uint64_t transformGetter@<X0>(SEL aSelector@<X1>, void *a2@<X0>, uint64_t a3@<X8>)
{
  uint64_t v5 = NSStringFromSelector(aSelector);
  if ([(NSString *)v5 isEqualToString:@"parameterB"])
  {
    id v6 = @"inputB";
  }
  else if ([(NSString *)v5 isEqualToString:@"parameterC"])
  {
    id v6 = @"inputC";
  }
  else if ([(NSString *)v5 isEqualToString:@"underColorRemoval"])
  {
    id v6 = @"inputUCR";
  }
  else if ([(NSString *)v5 isEqualToString:@"grayComponentReplacement"])
  {
    id v6 = @"inputGCR";
  }
  else if ([(NSString *)v5 isEqualToString:@"textureImage"])
  {
    id v6 = @"inputTexture";
  }
  else
  {
    id v6 = (__CFString *)objc_msgSend(@"input", "stringByAppendingString:", -[NSString stringByReplacingCharactersInRange:withString:](v5, "stringByReplacingCharactersInRange:withString:", 0, 1, -[NSString uppercaseString](-[NSString substringWithRange:](v5, "substringWithRange:", 0, 1), "uppercaseString")));
  }
  uint64_t result = [a2 valueForKey:v6];
  uint64_t v8 = MEMORY[0x1E4F1DAB8];
  long long v9 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
  *(_OWORD *)a3 = *MEMORY[0x1E4F1DAB8];
  *(_OWORD *)(a3 + 16) = v9;
  *(_OWORD *)(a3 + 32) = *(_OWORD *)(v8 + 32);
  if (result)
  {
    double v10 = (void *)result;
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      int v11 = (const char *)[v10 objCType];
      if (!strcmp(v11, "{CGAffineTransform=dddddd}") || (uint64_t result = strcmp(v11, "{?=dddddd}"), !result))
      {
        return [v10 getValue:a3 size:48];
      }
    }
    else
    {
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        uint64_t result = [v10 transformStruct];
        *(_OWORD *)a3 = 0u;
        *(_OWORD *)(a3 + 16) = 0u;
        *(_OWORD *)(a3 + 32) = 0u;
      }
      else
      {
        objc_opt_class();
        uint64_t result = objc_opt_isKindOfClass();
        if (result)
        {
          uint64_t result = [v10 count];
          if (result == 6)
          {
            objc_msgSend((id)objc_msgSend(v10, "objectAtIndex:", 0), "doubleValue");
            *(void *)a3 = v12;
            objc_msgSend((id)objc_msgSend(v10, "objectAtIndex:", 1), "doubleValue");
            *(void *)(a3 + 8) = v13;
            objc_msgSend((id)objc_msgSend(v10, "objectAtIndex:", 2), "doubleValue");
            *(void *)(a3 + 16) = v14;
            objc_msgSend((id)objc_msgSend(v10, "objectAtIndex:", 3), "doubleValue");
            *(void *)(a3 + 24) = v15;
            objc_msgSend((id)objc_msgSend(v10, "objectAtIndex:", 4), "doubleValue");
            *(void *)(a3 + 32) = v16;
            uint64_t result = objc_msgSend((id)objc_msgSend(v10, "objectAtIndex:", 5), "doubleValue");
            *(void *)(a3 + 40) = v17;
          }
        }
      }
    }
  }
  return result;
}

uint64_t transformSetter(void *a1, const char *a2, uint64_t a3)
{
  uint64_t v5 = [MEMORY[0x1E4F29238] valueWithBytes:a3 objCType:"{CGAffineTransform=dddddd}"];
  id v6 = keyForSetter(a2);

  return [a1 setValue:v5 forKey:v6];
}

uint64_t intGetter(void *a1, SEL aSelector)
{
  uint64_t v3 = NSStringFromSelector(aSelector);
  if ([(NSString *)v3 isEqualToString:@"parameterB"])
  {
    uint64_t v4 = @"inputB";
  }
  else if ([(NSString *)v3 isEqualToString:@"parameterC"])
  {
    uint64_t v4 = @"inputC";
  }
  else if ([(NSString *)v3 isEqualToString:@"underColorRemoval"])
  {
    uint64_t v4 = @"inputUCR";
  }
  else if ([(NSString *)v3 isEqualToString:@"grayComponentReplacement"])
  {
    uint64_t v4 = @"inputGCR";
  }
  else if ([(NSString *)v3 isEqualToString:@"textureImage"])
  {
    uint64_t v4 = @"inputTexture";
  }
  else
  {
    uint64_t v4 = (__CFString *)objc_msgSend(@"input", "stringByAppendingString:", -[NSString stringByReplacingCharactersInRange:withString:](v3, "stringByReplacingCharactersInRange:withString:", 0, 1, -[NSString uppercaseString](-[NSString substringWithRange:](v3, "substringWithRange:", 0, 1), "uppercaseString")));
  }
  uint64_t v5 = [a1 valueForKey:v4];
  if (!v5) {
    return 0;
  }
  id v6 = (void *)v5;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    return 0;
  }

  return [v6 integerValue];
}

uint64_t intSetter(void *a1, const char *a2)
{
  uint64_t v4 = objc_msgSend(NSNumber, "numberWithInteger:");
  uint64_t v5 = keyForSetter(a2);

  return [a1 setValue:v4 forKey:v5];
}

uint64_t uintGetter(void *a1, SEL aSelector)
{
  uint64_t v3 = NSStringFromSelector(aSelector);
  if ([(NSString *)v3 isEqualToString:@"parameterB"])
  {
    uint64_t v4 = @"inputB";
  }
  else if ([(NSString *)v3 isEqualToString:@"parameterC"])
  {
    uint64_t v4 = @"inputC";
  }
  else if ([(NSString *)v3 isEqualToString:@"underColorRemoval"])
  {
    uint64_t v4 = @"inputUCR";
  }
  else if ([(NSString *)v3 isEqualToString:@"grayComponentReplacement"])
  {
    uint64_t v4 = @"inputGCR";
  }
  else if ([(NSString *)v3 isEqualToString:@"textureImage"])
  {
    uint64_t v4 = @"inputTexture";
  }
  else
  {
    uint64_t v4 = (__CFString *)objc_msgSend(@"input", "stringByAppendingString:", -[NSString stringByReplacingCharactersInRange:withString:](v3, "stringByReplacingCharactersInRange:withString:", 0, 1, -[NSString uppercaseString](-[NSString substringWithRange:](v3, "substringWithRange:", 0, 1), "uppercaseString")));
  }
  uint64_t v5 = [a1 valueForKey:v4];
  if (!v5) {
    return 0;
  }
  id v6 = (void *)v5;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    return 0;
  }

  return [v6 unsignedIntegerValue];
}

uint64_t uintSetter(void *a1, const char *a2)
{
  uint64_t v4 = objc_msgSend(NSNumber, "numberWithUnsignedInteger:");
  uint64_t v5 = keyForSetter(a2);

  return [a1 setValue:v4 forKey:v5];
}

void sub_19379A96C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_19379AA8C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_19379AEAC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_19379B114(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_19379B31C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_19379B430(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_19379B548(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_19379B8E0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_19379B9E0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

const char *__enableFilterInterposing_block_invoke()
{
  uint64_t result = getenv("CI_ENABLE_FILTER_INTERPOSING");
  if (result)
  {
    uint64_t result = (const char *)atoi(result);
    enableFilterInterposing_enableFilterposing = result != 0;
  }
  return result;
}

uint64_t bundleForCIFilter(void)
{
  {
    bundleForCIFilter(void)::b = (uint64_t)(id)[MEMORY[0x1E4F28B50] bundleForClass:objc_opt_class()];
  }
  return bundleForCIFilter(void)::b;
}

void sub_19379C434(_Unwind_Exception *a1)
{
}

uint64_t classIsBuiltinFilter(objc_class *a1)
{
  uint64_t result = [(objc_class *)a1 isSubclassOfClass:objc_opt_class()];
  if (result)
  {
    uint64_t v3 = [MEMORY[0x1E4F28B50] bundleForClass:a1];
    return v3 == bundleForCIFilter();
  }
  return result;
}

void __Block_byref_object_copy__8(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__8(uint64_t a1)
{
}

uint64_t classIsSystemFilter(objc_class *a1)
{
  uint64_t result = [(objc_class *)a1 isSubclassOfClass:objc_opt_class()];
  if (result)
  {
    uint64_t v3 = NSStringFromClass(a1);
    return classNameIsSystemFilter(v3);
  }
  return result;
}

double cikernel::_flashColor(CI *a1, float32x4_t a2, float32x4_t a3, float32x2_t a4, float32x4_t a5, __n128 a6, float32x4_t a7, double a8)
{
  float32x2_t v8 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a4);
  int32x2_t v10 = (int32x2_t)vmul_f32(v8, v8);
  int32x2_t v11 = (int32x2_t)vadd_f32((float32x2_t)v10, (float32x2_t)vdup_lane_s32(v10, 1));
  float v12 = 1.0 - vmuls_lane_f32(sqrtf(vaddv_f32((float32x2_t)v10)), a7, 2);
  if (v12 <= 1.0) {
    float v13 = v12;
  }
  else {
    float v13 = 1.0;
  }
  _NF = v12 < 0.0;
  float v15 = 0.0;
  if (_NF) {
    float v13 = 0.0;
  }
  float v16 = a6.n128_f32[3];
  if (a6.n128_f32[0] <= a6.n128_f32[3]) {
    float v16 = a6.n128_f32[0];
  }
  if (a6.n128_f32[0] >= 0.0) {
    float v15 = v16;
  }
  *(float *)v9.i32 = vmlas_n_f32(*((float *)&a8 + 1), v15, *(float *)&a8);
  float32x4_t v17 = vmaxnmq_f32(vmulq_n_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(v9, 0), vdivq_f32(vmulq_lane_f32(a5, *(float32x2_t *)a7.f32, 1), (float32x4_t)vdupq_lane_s32(v11, 0))), v13), (float32x4_t)0);
  __asm { FMOV            V3.4S, #1.0 }
  *(void *)&double result = vmlaq_laneq_f32(vmulq_n_f32(vminnmq_f32(vmaxnmq_f32(vaddq_f32(a2, vminnmq_f32(v17, _Q3)), (float32x4_t)0), _Q3), 1.0 - a7.f32[3]), a3, a7, 3).u64[0];
  return result;
}

void CI::f4_s_s_f2_clr_s_f4_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  int32x2_t v10 = *(double (**)(__n128, __n128, double, __n128, __n128, __n128, double))(a1 + 24);
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  int v13 = *(_DWORD *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  int v15 = *(_DWORD *)(v9 + 64);
  uint64_t v16 = *(void *)(v9 + 56);
  uint64_t v17 = *(void *)(v9 + 80);
  int v18 = *(_DWORD *)(v9 + 112);
  uint64_t v19 = *(void *)(v9 + 104);
  int v20 = *(_DWORD *)(v9 + 136);
  uint64_t v21 = *(void *)(v9 + 128);
  int v22 = *(_DWORD *)(v9 + 160);
  uint64_t v23 = *(void *)(v9 + 152);
  if (*(unsigned char *)(a1 + 64))
  {
    double v34 = *(double (**)(__n128, __n128, double, __n128, __n128, __n128, double))(a1 + 24);
    int v32 = *(_DWORD *)(v9 + 16);
    int v33 = *(_DWORD *)(v9 + 112);
    int v35 = *(_DWORD *)(v9 + 64);
    int v36 = *(_DWORD *)(v9 + 40);
    int v31 = *(_DWORD *)(v9 + 160);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 176)), a2);
    int v22 = v31;
    int v11 = v32;
    int v18 = v33;
    int v15 = v35;
    int v13 = v36;
    int32x2_t v10 = v34;
  }
  int v24 = (double *)(a3 + 16 * v23);
  if (v22 != 5) {
    int v24 = (double *)((char *)a2 + 64 * v23);
  }
  double v25 = (__n128 *)(a3 + 16 * v21);
  if (v20 != 5) {
    double v25 = (__n128 *)((char *)a2 + 64 * v21);
  }
  CGRect v26 = (__n128 *)(a3 + 16 * v19);
  if (v18 != 5) {
    CGRect v26 = (__n128 *)((char *)a2 + 64 * v19);
  }
  CGRect v27 = (double *)(a3 + 16 * v16);
  if (v15 != 5) {
    CGRect v27 = (double *)((char *)a2 + 64 * v16);
  }
  CGRect v28 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    CGRect v28 = (__n128 *)((char *)a2 + 64 * v14);
  }
  vImage_Buffer v29 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    vImage_Buffer v29 = (__n128 *)((char *)a2 + 64 * v12);
  }
  *(double *)&long long v30 = v10(*v29, *v28, *v27, *((__n128 *)a2 + 4 * v17), *v26, *v25, *v24);
  *(_OWORD *)(a3 + 16 * a7) = v30;
}

float32x2_t cikernel::_flashGeom(CI *a1, float32x2_t a2)
{
  float32x2_t v2 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  int32x2_t v3 = (int32x2_t)vmul_f32(v2, v2);
  *(float *)v3.i32 = sqrtf(vaddv_f32((float32x2_t)v3));
  return vadd_f32(vdiv_f32(vmul_f32(v2, (float32x2_t)vdup_n_s32(0x42C80000u)), (float32x2_t)vdup_lane_s32(v3, 0)), (float32x2_t)0x4300000043000000);
}

void CI::f2_f2(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  int v11 = (double (*)(void *, double))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 32)), a2);
  }
  uint64_t v14 = (double *)(a3 + 16 * v13);
  if (v12 != 5) {
    uint64_t v14 = (double *)((char *)a2 + 64 * v13);
  }
  *(double *)(a3 + 16 * a7) = v11(a1, *v14);
}

__n64 cikernel::_disparityRefinementPreprocessing(float32x4_t a1, float32x4_t a2, float32x4_t a3, __n128 a4, double a5)
{
  float v18 = a1.f32[0];
  LODWORD(v17) = vsubq_f32(a1, a3).u32[0];
  float v5 = powf(fmaxf(fabsf(v17), 0.0001), a4.n128_f32[1]);
  float v6 = expf((float)-v5 / a4.n128_f32[2]) * a4.n128_f32[0];
  if (v6 <= *(float *)&a5) {
    float v7 = v6;
  }
  else {
    float v7 = *(float *)&a5;
  }
  if (v6 >= a4.n128_f32[3]) {
    _S0 = v7;
  }
  else {
    _S0 = a4.n128_f32[3];
  }
  _S3 = v17;
  __asm { FMLS            S1, S0, V3.S[0] }
  if (vmovn_s32(vcgtq_f32(a2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a5, 1))).u8[0]) {
    result.n64_f32[0] = _S1;
  }
  else {
    result.n64_f32[0] = v18;
  }
  result.n64_u32[1] = 0;
  return result;
}

void CI::f4_s_s_s_f4_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  uint64_t v10 = *(double (**)(__n128, __n128, __n128, __n128, __n128))(a1 + 24);
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  int v13 = *(_DWORD *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  int v15 = *(_DWORD *)(v9 + 64);
  uint64_t v16 = *(void *)(v9 + 56);
  int v17 = *(_DWORD *)(v9 + 88);
  uint64_t v18 = *(void *)(v9 + 80);
  int v19 = *(_DWORD *)(v9 + 112);
  uint64_t v20 = *(void *)(v9 + 104);
  if (*(unsigned char *)(a1 + 64))
  {
    int v28 = *(_DWORD *)(v9 + 88);
    int v29 = *(_DWORD *)(v9 + 40);
    int v27 = *(_DWORD *)(v9 + 64);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 128)), a2);
    int v15 = v27;
    int v17 = v28;
    int v13 = v29;
  }
  uint64_t v21 = (__n128 *)(a3 + 16 * v20);
  if (v19 != 5) {
    uint64_t v21 = (__n128 *)((char *)a2 + 64 * v20);
  }
  int v22 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5) {
    int v22 = (__n128 *)((char *)a2 + 64 * v18);
  }
  uint64_t v23 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5) {
    uint64_t v23 = (__n128 *)((char *)a2 + 64 * v16);
  }
  int v24 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    int v24 = (__n128 *)((char *)a2 + 64 * v14);
  }
  double v25 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    double v25 = (__n128 *)((char *)a2 + 64 * v12);
  }
  *(double *)&long long v26 = v10(*v25, *v24, *v23, *v22, *v21);
  *(_OWORD *)(a3 + 16 * a7) = v26;
}

__n64 cikernel::_disparityRefinementPreprocessingPow2(float32x4_t a1, float32x4_t a2, float32x4_t a3, __n128 a4, double a5)
{
  float v16 = a4.n128_f32[3];
  float v19 = a1.f32[0];
  LODWORD(v18) = vsubq_f32(a1, a3).u32[0];
  float v5 = fmaxf(fabsf(v18), 0.0001);
  float v6 = expf((float)-(float)(v5 * v5) / a4.n128_f32[2]) * a4.n128_f32[0];
  if (v6 <= *(float *)&a5) {
    float v7 = v6;
  }
  else {
    float v7 = *(float *)&a5;
  }
  if (v6 >= v16) {
    _S0 = v7;
  }
  else {
    _S0 = v16;
  }
  _S3 = v18;
  __asm { FMLS            S1, S0, V3.S[0] }
  if (vmovn_s32(vcgtq_f32(a2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a5, 1))).u8[0]) {
    result.n64_f32[0] = _S1;
  }
  else {
    result.n64_f32[0] = v19;
  }
  result.n64_u32[1] = 0;
  return result;
}

double cikernel::_fusionDelta(float32x4_t a1, int8x16_t a2, int8x16_t a3, float a4, float32x4_t a5)
{
  float v5 = vmlas_n_f32(*(float *)&a2.i32[1], a1.f32[0], *(float *)a2.i32);
  if (v5 <= 1.0) {
    float v6 = v5;
  }
  else {
    float v6 = 1.0;
  }
  BOOL v7 = v5 < 0.0;
  a5.i64[0] = 0;
  if (v7) {
    float v6 = 0.0;
  }
  float v8 = vmlas_n_f32(*(float *)&a3.i32[1], a1.f32[0], *(float *)a3.i32);
  if (v8 <= 1.0) {
    a1.f32[0] = v8;
  }
  else {
    a1.f32[0] = 1.0;
  }
  if (v8 < 0.0) {
    a1.f32[0] = 0.0;
  }
  a1.f32[0] = v6 - a1.f32[0];
  a1.f32[0] = a1.f32[0]
            * (float)(fabsf(COERCE_FLOAT(vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)vcgtq_f32(a1, a5), 0), a2, a3).i32[2]))
                    * a4);
  a1.i64[0] = vdupq_lane_s32(*(int32x2_t *)a1.f32, 0).u64[0];
  return *(double *)a1.i64;
}

void CI::f4_s_f3_f3_f(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  int v11 = (double (*)(void *, __n128, __n128, __n128, float))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  uint64_t v14 = *(void *)(v10 + 32);
  uint64_t v15 = *(void *)(v10 + 56);
  uint64_t v16 = *(void *)(v10 + 80);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 104)), a2);
  }
  int v17 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    int v17 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v18 = v11(a1, *v17, *((__n128 *)a2 + 4 * v14), *((__n128 *)a2 + 4 * v15), *((float *)a2 + 16 * v16));
  *(_OWORD *)(a3 + 16 * a7) = v18;
}

double cikernel::_fusionTwoImages(float32x4_t a1, float32x4_t a2, int8x16_t a3, int8x16_t a4, float a5, float a6, float32x4_t a7)
{
  float v7 = vmlas_n_f32(*(float *)&a3.i32[1], a2.f32[0], *(float *)a3.i32);
  if (v7 <= 1.0) {
    float v8 = v7;
  }
  else {
    float v8 = 1.0;
  }
  BOOL v9 = v7 < 0.0;
  a7.i64[0] = 0;
  if (v9) {
    float v8 = 0.0;
  }
  float v10 = vmlas_n_f32(*(float *)&a4.i32[1], a2.f32[0], *(float *)a4.i32);
  if (v10 <= 1.0) {
    float v11 = v10;
  }
  else {
    float v11 = 1.0;
  }
  if (v10 >= 0.0) {
    float v12 = v11;
  }
  else {
    float v12 = 0.0;
  }
  float32x4_t v13 = vsubq_f32(a1, a2);
  v13.f32[0] = (float)(1.0 - (float)(fmaxf(v13.f32[0], 0.0) * a5)) * (float)(v8 - v12);
  v13.f32[0] = v13.f32[0]
             * (float)(fabsf(COERCE_FLOAT(vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)vcgtq_f32(v13, a7), 0), a3, a4).i32[2]))
                     * a6);
  *(void *)&double result = vdupq_lane_s32(*(int32x2_t *)v13.f32, 0).u64[0];
  return result;
}

void CI::f4_s_s_f3_f3_f_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  float v10 = *(double (**)(__n128, __n128, __n128, __n128, float, float))(a1 + 24);
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  int v13 = *(_DWORD *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  uint64_t v15 = *(void *)(v9 + 56);
  uint64_t v16 = *(void *)(v9 + 80);
  uint64_t v17 = *(void *)(v9 + 104);
  uint64_t v18 = *(void *)(v9 + 128);
  if (*(unsigned char *)(a1 + 64))
  {
    int v22 = *(_DWORD *)(v9 + 40);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 152)), a2);
    int v13 = v22;
  }
  float v19 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    float v19 = (__n128 *)((char *)a2 + 64 * v14);
  }
  uint64_t v20 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    uint64_t v20 = (__n128 *)((char *)a2 + 64 * v12);
  }
  *(double *)&long long v21 = v10(*v20, *v19, *((__n128 *)a2 + 4 * v15), *((__n128 *)a2 + 4 * v16), *((float *)a2 + 16 * v17), *((float *)a2 + 16 * v18));
  *(_OWORD *)(a3 + 16 * a7) = v21;
}

double sizeForStringWithAttributes(CFStringRef str, CFDictionaryRef attributes)
{
  CFAttributedStringRef v2 = CFAttributedStringCreate(0, str, attributes);
  int32x2_t v3 = CTFramesetterCreateWithAttributedString(v2);
  v6.length = CFAttributedStringGetLength(v2);
  v7.double width = 1.79769313e308;
  v6.location = 0;
  v7.double height = 1.79769313e308;
  *(void *)&double v4 = *(_OWORD *)&CTFramesetterSuggestFrameSizeWithConstraints(v3, v6, 0, v7, 0);
  CFRelease(v3);
  CFRelease(v2);
  return v4;
}

CGColorRef CGColorCreateWithHex(unint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  {
    CGColorCreateWithHex(unsigned long)::cs = (uint64_t)CGColorSpaceCreateDeviceRGB();
  }
  v2.i64[0] = 255;
  v2.i64[1] = 255;
  float64x2_t v3 = vcvtq_f64_u64((uint64x2_t)vandq_s8((int8x16_t)vshlq_u64((uint64x2_t)vdupq_n_s64(a1), (uint64x2_t)xmmword_193953460), v2));
  v4.i64[0] = a1 >> 8;
  v4.i64[1] = a1;
  uint64x2_t v5 = (uint64x2_t)vandq_s8(v4, v2);
  float64x2_t v6 = (float64x2_t)vdupq_n_s64(0x406FE00000000000uLL);
  v8[0] = vdivq_f64(v3, v6);
  v8[1] = vdivq_f64(vcvtq_f64_u64(v5), v6);
  return CGColorCreate((CGColorSpaceRef)CGColorCreateWithHex(unsigned long)::cs, (const CGFloat *)v8);
}

void sub_1937A1A40(_Unwind_Exception *a1)
{
}

void CGContextDrawAttributedString(CGContext *a1, CFAttributedStringRef attrString, CGRect a3)
{
  CGFloat height = a3.size.height;
  CGFloat width = a3.size.width;
  CGFloat y = a3.origin.y;
  CGFloat x = a3.origin.x;
  uint64_t v9 = CTFramesetterCreateWithAttributedString(attrString);
  CFIndex Length = CFAttributedStringGetLength(attrString);
  v15.origin.CGFloat x = x;
  v15.origin.CGFloat y = y;
  v15.size.CGFloat width = width;
  v15.size.CGFloat height = height;
  int v11 = CGPathCreateWithRect(v15, 0);
  v14.location = 0;
  v14.length = Length;
  Frame = CTFramesetterCreateFrame(v9, v14, v11, 0);
  CTFrameDraw(Frame, a1);
  CFRelease(v9);
  CFRelease(Frame);

  CFRelease(v11);
}

void patternCallback(void *a1, CGContextRef c)
{
  CGContextSetGrayFillColor(c, 1.0, 1.0);
  v8.origin.CGFloat x = 0.0;
  v8.origin.CGFloat y = 0.0;
  v8.size.CGFloat width = 8.0;
  v8.size.CGFloat height = 8.0;
  CGContextFillRect(c, v8);
  v9.origin.CGFloat x = 8.0;
  v9.origin.CGFloat y = 8.0;
  v9.size.CGFloat width = 8.0;
  v9.size.CGFloat height = 8.0;
  CGContextFillRect(c, v9);
  CGContextSetGrayFillColor(c, 0.8, 1.0);
  v10.origin.CGFloat x = 8.0;
  v10.origin.CGFloat y = 0.0;
  v10.size.CGFloat width = 8.0;
  v10.size.CGFloat height = 8.0;
  CGContextFillRect(c, v10);
  uint64_t v3 = 0;
  double v4 = 8.0;
  double v5 = 8.0;
  double v6 = 8.0;

  CGContextFillRect(c, *(CGRect *)&v3);
}

CGFloat CGCubicSplineGetControlPoints(CGPoint a1, CGPoint a2, CGPoint a3, CGPoint a4, CGPoint *a5, CGPoint *a6)
{
  double y = a4.y;
  double v38 = a2.y;
  double x = a4.x;
  double v9 = a3.y;
  double v10 = a3.x;
  double v11 = a2.y;
  CGFloat v12 = a2.x - a1.x;
  double v13 = a2.x;
  double v40 = a2.x;
  CGFloat v14 = a2.y - a1.y;
  long double v15 = hypot(a2.x - a1.x, a2.y - a1.y);
  double v39 = v10;
  double v35 = v12 / v15;
  double v36 = v14 / v15;
  double v16 = hypot(v10 - v13, v9 - v11);
  double v17 = (v10 - v13) / v16;
  long double v18 = x - v10;
  double v19 = (v9 - v11) / v16;
  long double v20 = hypot(v18, y - v9);
  double v21 = v18 / v20;
  double v22 = (y - v9) / v20;
  double v23 = fabs(v17);
  double v24 = fabs(v21);
  if (v23 >= v24) {
    double v25 = v21;
  }
  else {
    double v25 = (v10 - v13) / v16;
  }
  if (v23 >= v24) {
    long double v26 = v22;
  }
  else {
    long double v26 = v19;
  }
  double v27 = fabs(v35);
  if (v27 >= v23) {
    long double v28 = v17;
  }
  else {
    long double v28 = v35;
  }
  if (v27 >= v23) {
    long double v29 = v19;
  }
  else {
    long double v29 = v36;
  }
  double v30 = fmin(v16 / 3.0, vabdd_f64(v38, v9));
  long double v31 = hypot(v25, v26);
  a6->double x = v39 - v30 * (v25 / v31);
  a6->double y = v9 - v30 * (v26 / v31);
  long double v32 = hypot(v28, v29);
  CGFloat v33 = v40 + v30 * (v28 / v32);
  CGFloat result = v38 + v30 * (v29 / v32);
  a5->double x = v33;
  a5->double y = result;
  return result;
}

void sub_1937A3078(_Unwind_Exception *a1)
{
}

CIImage *blurImage(CIImage *a1, double a2, double a3)
{
  v162[2] = *MEMORY[0x1E4F143B8];
  int v6 = dyld_program_sdk_at_least();
  if (!a1) {
    return a1;
  }
  int v7 = v6;
  double v8 = fmin(a2, 10000.0);
  double v9 = fmin(a3, 10000.0);
  int8x16_t v137 = 0;
  double v136 = 0;
  double v10 = v9 * v9;
  double v11 = v8 * v8;
  double v113 = v9;
  double v114 = v8;
  double v120 = 1.0;
  double v115 = a1;
  if (fmax(v8, v9) < 3.0)
  {
    double v116 = v9 * v9;
    double v124 = 1.0;
    goto LABEL_97;
  }
  double v120 = 1.0;
  float64x2_t v121 = (float64x2_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  float64x2_t v122 = (float64x2_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
  double v124 = 1.0;
LABEL_5:
  double v117 = v10;
  double v10 = (v10 + -9.9225) * 0.0625;
  while (1)
  {
    double v12 = (v11 + -9.9225) * 0.0625;
    if (v12 >= 0.358099622)
    {
      if (v7)
      {
        [(CIImage *)a1 extent];
        CGFloat x = v163.origin.x;
        CGFloat y = v163.origin.y;
        CGFloat width = v163.size.width;
        CGFloat height = v163.size.height;
        if (CGRectIsInfinite(v163))
        {
          *(float64x2_t *)&v133.var0 = v122;
          *(float64x2_t *)&v133.var2 = v121;
        }
        else
        {
          v167.origin.CGFloat x = x;
          v167.origin.CGFloat y = y;
          v167.size.CGFloat width = width;
          v167.size.CGFloat height = height;
          if (CGRectIsNull(v167))
          {
            *(int64x2_t *)&v133.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
            v133.var2 = 0.0;
            v133.var3 = 0.0;
          }
          else
          {
            v133.var0 = x;
            v133.var1 = y;
            v133.var2 = width;
            v133.var3 = height;
          }
        }
        Rectangle::inset(&v133, -7.0, -0.0, (uint64_t)&v134);
        if (fabs(v134.var0) == INFINITY || fabs(v134.var1) == INFINITY)
        {
          *(int64x2_t *)&v135.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
          v135.var2 = 0.0;
          v135.var3 = 0.0;
        }
        else if (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_f64(*(float64x2_t *)&v134.var0, v122), (int32x4_t)vceqq_f64(*(float64x2_t *)&v134.var2, v121))))))
        {
          v135.var0 = v134.var0 * 0.25;
          v135.var1 = v134.var1;
          v135.var2 = 0.25 * v134.var2;
          v135.var3 = v134.var3;
        }
        else
        {
          *(float64x2_t *)&v135.var0 = v122;
          *(float64x2_t *)&v135.var2 = v121;
        }
        Rectangle::integralize(&v135, 0.0001, (uint64_t)&v156);
        double v26 = *((double *)&v156 + 1);
        double v25 = *(double *)&v156;
        double v28 = *((double *)&v157 + 1);
        double v27 = *(double *)&v157;
        if (*(double *)&v156 == -8.98846567e307
          && *((double *)&v156 + 1) == -8.98846567e307
          && *(double *)&v157 == 1.79769313e308
          && *((double *)&v157 + 1) == 1.79769313e308)
        {
          double v25 = *MEMORY[0x1E4F1DB10];
          double v26 = *(double *)(MEMORY[0x1E4F1DB10] + 8);
          double v27 = *(double *)(MEMORY[0x1E4F1DB10] + 16);
          double v28 = *(double *)(MEMORY[0x1E4F1DB10] + 24);
        }
      }
      else
      {
        [(CIImage *)a1 extent];
        CGFloat v18 = v17;
        CGFloat v20 = v19;
        CGFloat v22 = v21;
        CGFloat v24 = v23;
        CGAffineTransformMakeScale(&v132, 0.25, 1.0);
        v164.origin.CGFloat x = v18;
        v164.origin.CGFloat y = v20;
        v164.size.CGFloat width = v22;
        v164.size.CGFloat height = v24;
        CGRect v165 = CGRectApplyAffineTransform(v164, &v132);
        CGRect v166 = CGRectInset(v165, -4.0, 0.0);
        double v25 = v166.origin.x;
        double v26 = v166.origin.y;
        double v27 = v166.size.width;
        double v28 = v166.size.height;
      }
      long double v29 = +[CIKernel kernelWithInternalRepresentation:&CI::_gaussianReduce4];
      v162[0] = a1;
      v162[1] = +[CIVector vectorWithX:4.0 Y:1.0 Z:1.0 W:0.0];
      a1 = -[CIKernel applyWithExtent:roiCallback:arguments:](v29, "applyWithExtent:roiCallback:arguments:", &__block_literal_global_33, [MEMORY[0x1E4F1C978] arrayWithObjects:v162 count:2], v25, v26, v27, v28);
      double v124 = v124 * 4.0;
      double v11 = v12;
      goto LABEL_25;
    }
    if (v10 < 0.358099622) {
      break;
    }
LABEL_25:
    if (v10 >= 0.358099622)
    {
      if (v7)
      {
        [(CIImage *)a1 extent];
        CGFloat v30 = v168.origin.x;
        CGFloat v31 = v168.origin.y;
        CGFloat v32 = v168.size.width;
        CGFloat v33 = v168.size.height;
        if (CGRectIsInfinite(v168))
        {
          *(float64x2_t *)&v133.var0 = v122;
          *(float64x2_t *)&v133.var2 = v121;
        }
        else
        {
          v172.origin.CGFloat x = v30;
          v172.origin.CGFloat y = v31;
          v172.size.CGFloat width = v32;
          v172.size.CGFloat height = v33;
          if (CGRectIsNull(v172))
          {
            *(int64x2_t *)&v133.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
            v133.var2 = 0.0;
            v133.var3 = 0.0;
          }
          else
          {
            v133.var0 = v30;
            v133.var1 = v31;
            v133.var2 = v32;
            v133.var3 = v33;
          }
        }
        Rectangle::inset(&v133, -0.0, -7.0, (uint64_t)&v134);
        if (fabs(v134.var0) == INFINITY || fabs(v134.var1) == INFINITY)
        {
          *(int64x2_t *)&v135.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
          v135.var2 = 0.0;
          v135.var3 = 0.0;
        }
        else if (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_f64(*(float64x2_t *)&v134.var0, v122), (int32x4_t)vceqq_f64(*(float64x2_t *)&v134.var2, v121))))))
        {
          v135.var0 = v134.var0;
          v135.var1 = v134.var1 * 0.25;
          v135.var2 = v134.var2;
          v135.var3 = vmuld_lane_f64(0.25, *(float64x2_t *)&v134.var2, 1);
        }
        else
        {
          *(float64x2_t *)&v135.var0 = v122;
          *(float64x2_t *)&v135.var2 = v121;
        }
        Rectangle::integralize(&v135, 0.0001, (uint64_t)&v156);
        double v43 = *((double *)&v156 + 1);
        double v42 = *(double *)&v156;
        double v45 = *((double *)&v157 + 1);
        double v44 = *(double *)&v157;
        if (*(double *)&v156 == -8.98846567e307
          && *((double *)&v156 + 1) == -8.98846567e307
          && *(double *)&v157 == 1.79769313e308
          && *((double *)&v157 + 1) == 1.79769313e308)
        {
          double v42 = *MEMORY[0x1E4F1DB10];
          double v43 = *(double *)(MEMORY[0x1E4F1DB10] + 8);
          double v44 = *(double *)(MEMORY[0x1E4F1DB10] + 16);
          double v45 = *(double *)(MEMORY[0x1E4F1DB10] + 24);
        }
      }
      else
      {
        [(CIImage *)a1 extent];
        CGFloat v35 = v34;
        CGFloat v37 = v36;
        CGFloat v39 = v38;
        CGFloat v41 = v40;
        CGAffineTransformMakeScale(&v131, 1.0, 0.25);
        v169.origin.CGFloat x = v35;
        v169.origin.CGFloat y = v37;
        v169.size.CGFloat width = v39;
        v169.size.CGFloat height = v41;
        CGRect v170 = CGRectApplyAffineTransform(v169, &v131);
        CGRect v171 = CGRectInset(v170, 0.0, -4.0);
        double v42 = v171.origin.x;
        double v43 = v171.origin.y;
        double v44 = v171.size.width;
        double v45 = v171.size.height;
      }
      double v46 = +[CIKernel kernelWithInternalRepresentation:&CI::_gaussianReduce4];
      v161[0] = a1;
      v161[1] = +[CIVector vectorWithX:1.0 Y:4.0 Z:0.0 W:1.0];
      a1 = -[CIKernel applyWithExtent:roiCallback:arguments:](v46, "applyWithExtent:roiCallback:arguments:", &__block_literal_global_80, [MEMORY[0x1E4F1C978] arrayWithObjects:v161 count:2], v42, v43, v44, v45);
      double v120 = v120 * 4.0;
      goto LABEL_5;
    }
  }
  double v47 = 0.25;
  float64x2_t v118 = (float64x2_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  float64x2_t v119 = (float64x2_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
  int64x2_t v123 = vdupq_n_s64(0x7FF0000000000000uLL);
  double v48 = v117;
  while (2)
  {
    double v116 = v48;
    double v48 = (v48 + -3.0625) * v47;
LABEL_50:
    double v49 = (v11 + -3.0625) * 0.25;
    if (v49 >= 0.358099622)
    {
      if (v7)
      {
        [(CIImage *)a1 extent];
        CGFloat v50 = v173.origin.x;
        CGFloat v51 = v173.origin.y;
        CGFloat v52 = v173.size.width;
        CGFloat v53 = v173.size.height;
        if (CGRectIsInfinite(v173))
        {
          *(float64x2_t *)&v133.var0 = v119;
          *(float64x2_t *)&v133.var2 = v118;
        }
        else
        {
          v177.origin.CGFloat x = v50;
          v177.origin.CGFloat y = v51;
          v177.size.CGFloat width = v52;
          v177.size.CGFloat height = v53;
          if (CGRectIsNull(v177))
          {
            *(int64x2_t *)&v133.var0 = v123;
            v133.var2 = 0.0;
            v133.var3 = 0.0;
          }
          else
          {
            v133.var0 = v50;
            v133.var1 = v51;
            v133.var2 = v52;
            v133.var3 = v53;
          }
        }
        Rectangle::inset(&v133, -4.0, -0.0, (uint64_t)&v134);
        if (fabs(v134.var0) == INFINITY || fabs(v134.var1) == INFINITY)
        {
          *(int64x2_t *)&v135.var0 = v123;
          v135.var2 = 0.0;
          v135.var3 = 0.0;
        }
        else if (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_f64(*(float64x2_t *)&v134.var0, v119), (int32x4_t)vceqq_f64(*(float64x2_t *)&v134.var2, v118))))))
        {
          v135.var0 = v134.var0 * 0.5;
          v135.var1 = v134.var1;
          v135.var2 = 0.5 * v134.var2;
          v135.var3 = v134.var3;
        }
        else
        {
          *(float64x2_t *)&v135.var0 = v119;
          *(float64x2_t *)&v135.var2 = v118;
        }
        Rectangle::integralize(&v135, 0.0001, (uint64_t)&v156);
        double v63 = *((double *)&v156 + 1);
        double v62 = *(double *)&v156;
        double v65 = *((double *)&v157 + 1);
        double v64 = *(double *)&v157;
        if (*(double *)&v156 == -8.98846567e307
          && *((double *)&v156 + 1) == -8.98846567e307
          && *(double *)&v157 == 1.79769313e308
          && *((double *)&v157 + 1) == 1.79769313e308)
        {
          double v62 = *MEMORY[0x1E4F1DB10];
          double v63 = *(double *)(MEMORY[0x1E4F1DB10] + 8);
          double v64 = *(double *)(MEMORY[0x1E4F1DB10] + 16);
          double v65 = *(double *)(MEMORY[0x1E4F1DB10] + 24);
        }
      }
      else
      {
        [(CIImage *)a1 extent];
        CGFloat v55 = v54;
        CGFloat v57 = v56;
        CGFloat v59 = v58;
        CGFloat v61 = v60;
        CGAffineTransformMakeScale(&v130, 0.5, 1.0);
        v174.origin.CGFloat x = v55;
        v174.origin.CGFloat y = v57;
        v174.size.CGFloat width = v59;
        v174.size.CGFloat height = v61;
        CGRect v175 = CGRectApplyAffineTransform(v174, &v130);
        CGRect v176 = CGRectInset(v175, -3.0, 0.0);
        double v62 = v176.origin.x;
        double v63 = v176.origin.y;
        double v64 = v176.size.width;
        double v65 = v176.size.height;
      }
      double v66 = +[CIKernel kernelWithInternalRepresentation:&CI::_gaussianReduce2];
      v160[0] = a1;
      v160[1] = +[CIVector vectorWithX:2.0 Y:1.0 Z:1.0 W:0.0];
      a1 = -[CIKernel applyWithExtent:roiCallback:arguments:](v66, "applyWithExtent:roiCallback:arguments:", &__block_literal_global_82, [MEMORY[0x1E4F1C978] arrayWithObjects:v160 count:2], v62, v63, v64, v65);
      double v124 = v124 + v124;
      double v11 = v49;
LABEL_69:
      if (v48 >= 0.358099622)
      {
        if (v7)
        {
          [(CIImage *)a1 extent];
          CGFloat v67 = v178.origin.x;
          CGFloat v68 = v178.origin.y;
          CGFloat v69 = v178.size.width;
          CGFloat v70 = v178.size.height;
          if (CGRectIsInfinite(v178))
          {
            *(float64x2_t *)&v133.var0 = v119;
            *(float64x2_t *)&v133.var2 = v118;
          }
          else
          {
            v182.origin.CGFloat x = v67;
            v182.origin.CGFloat y = v68;
            v182.size.CGFloat width = v69;
            v182.size.CGFloat height = v70;
            if (CGRectIsNull(v182))
            {
              *(int64x2_t *)&v133.var0 = v123;
              v133.var2 = 0.0;
              v133.var3 = 0.0;
            }
            else
            {
              v133.var0 = v67;
              v133.var1 = v68;
              v133.var2 = v69;
              v133.var3 = v70;
            }
          }
          Rectangle::inset(&v133, -0.0, -4.0, (uint64_t)&v134);
          if (fabs(v134.var0) == INFINITY || fabs(v134.var1) == INFINITY)
          {
            *(int64x2_t *)&v135.var0 = v123;
            v135.var2 = 0.0;
            v135.var3 = 0.0;
          }
          else if (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_f64(*(float64x2_t *)&v134.var0, v119), (int32x4_t)vceqq_f64(*(float64x2_t *)&v134.var2, v118))))))
          {
            v135.var0 = v134.var0;
            v135.var1 = v134.var1 * 0.5;
            v135.var2 = v134.var2;
            v135.var3 = vmuld_lane_f64(0.5, *(float64x2_t *)&v134.var2, 1);
          }
          else
          {
            *(float64x2_t *)&v135.var0 = v119;
            *(float64x2_t *)&v135.var2 = v118;
          }
          Rectangle::integralize(&v135, 0.0001, (uint64_t)&v156);
          double v80 = *((double *)&v156 + 1);
          double v79 = *(double *)&v156;
          double v82 = *((double *)&v157 + 1);
          double v81 = *(double *)&v157;
          if (*(double *)&v156 == -8.98846567e307
            && *((double *)&v156 + 1) == -8.98846567e307
            && *(double *)&v157 == 1.79769313e308
            && *((double *)&v157 + 1) == 1.79769313e308)
          {
            double v79 = *MEMORY[0x1E4F1DB10];
            double v80 = *(double *)(MEMORY[0x1E4F1DB10] + 8);
            double v81 = *(double *)(MEMORY[0x1E4F1DB10] + 16);
            double v82 = *(double *)(MEMORY[0x1E4F1DB10] + 24);
          }
        }
        else
        {
          [(CIImage *)a1 extent];
          CGFloat v72 = v71;
          CGFloat v74 = v73;
          CGFloat v76 = v75;
          CGFloat v78 = v77;
          CGAffineTransformMakeScale(&v129, 1.0, 0.5);
          v179.origin.CGFloat x = v72;
          v179.origin.CGFloat y = v74;
          v179.size.CGFloat width = v76;
          v179.size.CGFloat height = v78;
          CGRect v180 = CGRectApplyAffineTransform(v179, &v129);
          CGRect v181 = CGRectInset(v180, 0.0, -3.0);
          double v79 = v181.origin.x;
          double v80 = v181.origin.y;
          double v81 = v181.size.width;
          double v82 = v181.size.height;
        }
        double v83 = +[CIKernel kernelWithInternalRepresentation:&CI::_gaussianReduce2];
        v159[0] = a1;
        v159[1] = +[CIVector vectorWithX:1.0 Y:2.0 Z:0.0 W:1.0];
        a1 = -[CIKernel applyWithExtent:roiCallback:arguments:](v83, "applyWithExtent:roiCallback:arguments:", &__block_literal_global_84_0, [MEMORY[0x1E4F1C978] arrayWithObjects:v159 count:2], v79, v80, v81, v82);
        double v120 = v120 + v120;
        double v47 = 0.25;
        continue;
      }
      goto LABEL_50;
    }
    break;
  }
  if (v48 >= 0.358099622) {
    goto LABEL_69;
  }
  if (v124 > 1.0) {
    double v11 = v11 + -0.358098622;
  }
  if (v120 > 1.0) {
    double v116 = v116 + -0.358098622;
  }
LABEL_97:
  if (v11 <= 0.000001
    || ((int v84 = vcvtpd_s64_f64(v11 / 11.1111111),
         double v158 = 0.0,
         long long v156 = 0u,
         long long v157 = 0u,
         (int v85 = narrowBlurParameters(v11 / (double)v84, (double *)&v156, &v137, &v136, v124 > 1.0)) != 0)
      ? (BOOL v86 = a1 == 0)
      : (BOOL v86 = 1),
        v86))
  {
    uint64_t v98 = 0;
  }
  else
  {
    float v95 = +[CIVector vectorWithX:*(double *)&v156 Y:0.0 Z:*((double *)&v156 + 1) W:0.0];
    float v96 = +[CIVector vectorWithX:*(double *)&v157 Y:0.0 Z:*((double *)&v157 + 1) W:0.0];
    float64x2_t v97 = +[CIVector vectorWithX:v158 Y:0.0 Z:0.0 W:0.0];
    uint64_t v98 = 0;
    float32x4_t v99 = 0;
    switch(v85)
    {
      case 1:
        float32x4_t v99 = +[CIKernel kernelWithInternalRepresentation:&CI::_gaussianBlur3];
        v148[0] = a1;
        v148[1] = v95;
        uint64_t v100 = [MEMORY[0x1E4F1C978] arrayWithObjects:v148 count:2];
        goto LABEL_120;
      case 2:
        float32x4_t v99 = +[CIKernel kernelWithInternalRepresentation:&CI::_gaussianBlur5];
        v149[0] = a1;
        v149[1] = +[CIVector vectorWithX:1.0 Y:0.0];
        v149[2] = v137;
        uint64_t v100 = [MEMORY[0x1E4F1C978] arrayWithObjects:v149 count:3];
        goto LABEL_120;
      case 3:
        float32x4_t v99 = +[CIKernel kernelWithInternalRepresentation:&CI::_gaussianBlur7];
        v150[0] = a1;
        v150[1] = v95;
        v150[2] = v137;
        uint64_t v100 = [MEMORY[0x1E4F1C978] arrayWithObjects:v150 count:3];
        goto LABEL_120;
      case 4:
        float32x4_t v99 = +[CIKernel kernelWithInternalRepresentation:&CI::_gaussianBlur9];
        v151[0] = a1;
        v151[1] = +[CIVector vectorWithX:1.0 Y:0.0];
        v151[2] = v137;
        uint64_t v100 = [MEMORY[0x1E4F1C978] arrayWithObjects:v151 count:3];
        goto LABEL_120;
      case 5:
        float32x4_t v99 = +[CIKernel kernelWithInternalRepresentation:&CI::_gaussianBlur11];
        v152[0] = a1;
        v152[1] = v95;
        v152[2] = v96;
        v152[3] = v137;
        uint64_t v100 = [MEMORY[0x1E4F1C978] arrayWithObjects:v152 count:4];
        goto LABEL_120;
      case 6:
        float32x4_t v99 = +[CIKernel kernelWithInternalRepresentation:&CI::_gaussianBlur13];
        v153[0] = a1;
        v153[1] = +[CIVector vectorWithX:1.0 Y:0.0];
        v153[2] = v137;
        v153[3] = v136;
        uint64_t v100 = [MEMORY[0x1E4F1C978] arrayWithObjects:v153 count:4];
        goto LABEL_120;
      case 7:
        float32x4_t v99 = +[CIKernel kernelWithInternalRepresentation:&CI::_gaussianBlur15];
        v154[0] = a1;
        v154[1] = v95;
        v154[2] = v96;
        v154[3] = v137;
        uint64_t v100 = [MEMORY[0x1E4F1C978] arrayWithObjects:v154 count:4];
        goto LABEL_120;
      case 9:
        float32x4_t v101 = v97;
        float32x4_t v99 = +[CIKernel kernelWithInternalRepresentation:&CI::_gaussianBlur19];
        v155[0] = a1;
        v155[1] = v95;
        v155[2] = v96;
        v155[3] = v101;
        v155[4] = v137;
        v155[5] = v136;
        uint64_t v100 = [MEMORY[0x1E4F1C978] arrayWithObjects:v155 count:6];
LABEL_120:
        uint64_t v98 = v100;
        break;
      default:
        break;
    }
    if (v84 >= 1)
    {
      uint64_t v102 = MEMORY[0x1E4F143A8];
      do
      {
        [(CIImage *)a1 extent];
        CGRect v184 = CGRectInset(v183, (double)-v85, 0.0);
        v127[0] = v102;
        v127[1] = 3221225472;
        v127[2] = ___ZL9blurImageP7CIImagedd_block_invoke_5;
        v127[3] = &__block_descriptor_36_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
        int v128 = v85;
        a1 = -[CIKernel applyWithExtent:roiCallback:arguments:](v99, "applyWithExtent:roiCallback:arguments:", v127, v98, v184.origin.x, v184.origin.y, v184.size.width, v184.size.height);
        --v84;
      }
      while (v84);
    }
  }
  if (v116 > 0.000001)
  {
    int v87 = vcvtpd_s64_f64(v116 / 11.1111111);
    double v158 = 0.0;
    long long v156 = 0u;
    long long v157 = 0u;
    int v88 = narrowBlurParameters(v116 / (double)v87, (double *)&v156, &v137, &v136, v120 > 1.0);
    if (v88 && a1 != 0)
    {
      double v90 = +[CIVector vectorWithX:0.0 Y:*(double *)&v156 Z:0.0 W:*((double *)&v156 + 1)];
      float v91 = +[CIVector vectorWithX:0.0 Y:*(double *)&v157 Z:0.0 W:*((double *)&v157 + 1)];
      double v92 = +[CIVector vectorWithX:0.0 Y:v158 Z:0.0 W:0.0];
      float v93 = 0;
      switch(v88)
      {
        case 1:
          float v93 = +[CIKernel kernelWithInternalRepresentation:&CI::_gaussianBlur3];
          v140[0] = a1;
          v140[1] = v90;
          uint64_t v94 = [MEMORY[0x1E4F1C978] arrayWithObjects:v140 count:2];
          goto LABEL_132;
        case 2:
          float v93 = +[CIKernel kernelWithInternalRepresentation:&CI::_gaussianBlur5];
          v141[0] = a1;
          v141[1] = +[CIVector vectorWithX:0.0 Y:1.0];
          v141[2] = v137;
          uint64_t v94 = [MEMORY[0x1E4F1C978] arrayWithObjects:v141 count:3];
          goto LABEL_132;
        case 3:
          float v93 = +[CIKernel kernelWithInternalRepresentation:&CI::_gaussianBlur7];
          v142[0] = a1;
          v142[1] = v90;
          v142[2] = v137;
          uint64_t v94 = [MEMORY[0x1E4F1C978] arrayWithObjects:v142 count:3];
          goto LABEL_132;
        case 4:
          float v93 = +[CIKernel kernelWithInternalRepresentation:&CI::_gaussianBlur9];
          v143[0] = a1;
          v143[1] = +[CIVector vectorWithX:0.0 Y:1.0];
          v143[2] = v137;
          uint64_t v94 = [MEMORY[0x1E4F1C978] arrayWithObjects:v143 count:3];
          goto LABEL_132;
        case 5:
          float v93 = +[CIKernel kernelWithInternalRepresentation:&CI::_gaussianBlur11];
          v144[0] = a1;
          v144[1] = v90;
          v144[2] = v91;
          v144[3] = v137;
          uint64_t v94 = [MEMORY[0x1E4F1C978] arrayWithObjects:v144 count:4];
          goto LABEL_132;
        case 6:
          float v93 = +[CIKernel kernelWithInternalRepresentation:&CI::_gaussianBlur13];
          v145[0] = a1;
          v145[1] = +[CIVector vectorWithX:0.0 Y:1.0];
          v145[2] = v137;
          v145[3] = v136;
          uint64_t v94 = [MEMORY[0x1E4F1C978] arrayWithObjects:v145 count:4];
          goto LABEL_132;
        case 7:
          float v93 = +[CIKernel kernelWithInternalRepresentation:&CI::_gaussianBlur15];
          v146[0] = a1;
          v146[1] = v90;
          v146[2] = v91;
          v146[3] = v137;
          uint64_t v94 = [MEMORY[0x1E4F1C978] arrayWithObjects:v146 count:4];
          goto LABEL_132;
        case 9:
          float v103 = v92;
          float v93 = +[CIKernel kernelWithInternalRepresentation:&CI::_gaussianBlur19];
          v147[0] = a1;
          v147[1] = v90;
          v147[2] = v91;
          v147[3] = v103;
          v147[4] = v137;
          v147[5] = v136;
          uint64_t v94 = [MEMORY[0x1E4F1C978] arrayWithObjects:v147 count:6];
LABEL_132:
          uint64_t v98 = v94;
          break;
        default:
          break;
      }
      if (v87 >= 1)
      {
        uint64_t v104 = MEMORY[0x1E4F143A8];
        do
        {
          [(CIImage *)a1 extent];
          CGRect v186 = CGRectInset(v185, 0.0, (double)-v88);
          v125[0] = v104;
          v125[1] = 3221225472;
          v125[2] = ___ZL9blurImageP7CIImagedd_block_invoke_6;
          v125[3] = &__block_descriptor_36_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
          int v126 = v88;
          a1 = -[CIKernel applyWithExtent:roiCallback:arguments:](v93, "applyWithExtent:roiCallback:arguments:", v125, v98, v186.origin.x, v186.origin.y, v186.size.width, v186.size.height);
          --v87;
        }
        while (v87);
      }
    }
  }
  if (v124 > 1.0 || v120 > 1.0)
  {
    int8x16_t v138 = @"inputScale";
    float64x2_t v139 = +[CIVector vectorWithX:v124 Y:v120];
    a1 = -[CIImage imageByApplyingFilter:withInputParameters:](a1, "imageByApplyingFilter:withInputParameters:", @"CISoftCubicUpsample", [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v139 forKeys:&v138 count:1]);
  }
  [(CIImage *)v115 extent];
  CGFloat v105 = v187.origin.x;
  CGFloat v106 = v187.origin.y;
  CGFloat v107 = v187.size.width;
  CGFloat v108 = v187.size.height;
  if (CGRectIsInfinite(v187))
  {
    *(int64x2_t *)&v134.var0 = vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    *(int64x2_t *)&v134.var2 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  }
  else
  {
    v188.origin.CGFloat x = v105;
    v188.origin.CGFloat y = v106;
    v188.size.CGFloat width = v107;
    v188.size.CGFloat height = v108;
    if (CGRectIsNull(v188))
    {
      *(int64x2_t *)&v134.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
      v134.var2 = 0.0;
      v134.var3 = 0.0;
    }
    else
    {
      v134.var0 = v105;
      v134.var1 = v106;
      v134.var2 = v107;
      v134.var3 = v108;
    }
  }
  Rectangle::inset(&v134, v114 * -3.0, v113 * -3.0, (uint64_t)&v135);
  Rectangle::integralize(&v135, 0.0001, (uint64_t)&v156);
  if (v7)
  {
    if (*(double *)&v156 != -8.98846567e307)
    {
      double v111 = *((double *)&v157 + 1);
      double v109 = *((double *)&v156 + 1);
      double v110 = *(double *)&v157;
      return -[CIImage imageByCroppingToRect:](a1, "imageByCroppingToRect:", *(double *)&v156, v109, v110, v111);
    }
    double v109 = *((double *)&v156 + 1);
    double v111 = *((double *)&v157 + 1);
    double v110 = *(double *)&v157;
    if (*((double *)&v156 + 1) != -8.98846567e307
      || *(double *)&v157 != 1.79769313e308
      || *((double *)&v157 + 1) != 1.79769313e308)
    {
      return -[CIImage imageByCroppingToRect:](a1, "imageByCroppingToRect:", *(double *)&v156, v109, v110, v111);
    }
  }
  return a1;
}

double ___ZL9blurImageP7CIImagedd_block_invoke(double a1, CGFloat a2, double a3, CGFloat a4)
{
  double v7 = a1;
  if (!CGRectIsEmpty(*(CGRect *)&a1))
  {
    v9.origin.CGFloat x = v7 * 4.0 + -7.0;
    v9.size.CGFloat width = a3 * 4.0 + 14.0;
    v9.origin.CGFloat y = a2;
    v9.size.CGFloat height = a4;
    *(void *)&double v7 = (unint64_t)CGRectIntegral(v9);
  }
  return v7;
}

double ___ZL9blurImageP7CIImagedd_block_invoke_2(double a1, double a2, CGFloat a3, double a4)
{
  double v7 = a1;
  if (!CGRectIsEmpty(*(CGRect *)&a1))
  {
    v9.origin.CGFloat y = a2 * 4.0 + -7.0;
    v9.size.CGFloat height = a4 * 4.0 + 14.0;
    v9.origin.CGFloat x = v7;
    v9.size.CGFloat width = a3;
    *(void *)&double v7 = (unint64_t)CGRectIntegral(v9);
  }
  return v7;
}

double ___ZL9blurImageP7CIImagedd_block_invoke_3(double a1, CGFloat a2, double a3, CGFloat a4)
{
  double v7 = a1;
  if (!CGRectIsEmpty(*(CGRect *)&a1))
  {
    v9.origin.CGFloat x = v7 * 2.0 + -4.0;
    v9.size.CGFloat width = a3 * 2.0 + 8.0;
    v9.origin.CGFloat y = a2;
    v9.size.CGFloat height = a4;
    *(void *)&double v7 = (unint64_t)CGRectIntegral(v9);
  }
  return v7;
}

double ___ZL9blurImageP7CIImagedd_block_invoke_4(double a1, double a2, CGFloat a3, double a4)
{
  double v7 = a1;
  if (!CGRectIsEmpty(*(CGRect *)&a1))
  {
    v9.origin.CGFloat y = a2 * 2.0 + -4.0;
    v9.size.CGFloat height = a4 * 2.0 + 8.0;
    v9.origin.CGFloat x = v7;
    v9.size.CGFloat width = a3;
    *(void *)&double v7 = (unint64_t)CGRectIntegral(v9);
  }
  return v7;
}

uint64_t narrowBlurParameters(double a1, double *a2, CIVector **a3, CIVector **a4, char a5)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  long long v42 = 0u;
  *(_OWORD *)double v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v39 = 0u;
  *a4 = 0;
  *a3 = 0;
  double v8 = sqrt(a1);
  if (a5)
  {
    if (v8 >= 0.570644)
    {
      uint64_t v13 = 0;
      float64x2_t v35 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(v8 * 2.50662827), 0);
      float64x2_t v36 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(v8 * (v8 + v8)), 0);
      int32x2_t v14 = (int32x2_t)0x100000000;
      double v9 = 0.00300000003;
      do
      {
        int32x2_t v15 = vadd_s32(v14, (int32x2_t)0x800000008);
        v16.i64[0] = v15.i32[0];
        v16.i64[1] = v15.i32[1];
        float64x2_t v17 = vcvtq_f64_s64(v16);
        __CGFloat x = vdivq_f64(vmulq_f64(vnegq_f64(v17), v17), v36);
        long double v38 = exp(__x.f64[1]);
        v18.f64[0] = exp(__x.f64[0]);
        v18.f64[1] = v38;
        *(long long *)((char *)&v39 + v13) = (__int128)vdivq_f64(v18, v35);
        int32x2_t v14 = vadd_s32(v14, (int32x2_t)0x200000002);
        v13 += 16;
      }
      while (v13 != 80);
    }
    else
    {
      v43[0] = fmax(v8 * 0.14 + a1 * 0.33 + -0.036442, 0.0);
      v43[1] = v43[0] * -2.0 + 1.0;
      double v9 = 0.00300000003;
    }
  }
  else
  {
    uint64_t v10 = 0;
    double v9 = 0.00150000001;
    do
    {
      double v11 = fabs((double)((int)v10 - 9));
      double v12 = erf((0.5 - v11) * 0.707106781 / v8);
      *((long double *)&v39 + v10++) = (v12 - erf((-0.5 - v11) * 0.707106781 / v8)) * 0.5;
    }
    while (v10 != 10);
  }
  uint64_t v19 = 0;
  double v20 = 0.0;
  while (1)
  {
    double v21 = v20 + *((double *)&v39 + v19);
    if (v21 >= v9) {
      break;
    }
    *((void *)&v39 + v19++) = 0;
    double v20 = v21;
    if (v19 == 10)
    {
      LODWORD(v19) = -1;
      goto LABEL_15;
    }
  }
  *((double *)&v39 + v19) = v20 + *((double *)&v39 + v19);
  if (v19 == 9) {
    return 0;
  }
LABEL_15:
  if (dyld_program_sdk_at_least())
  {
    switch(v19)
    {
      case 3:
        *a3 = +[CIVector vectorWithX:v43[1] Y:v43[0] Z:*((double *)&v42 + 1) W:*(double *)&v42];
        *a4 = +[CIVector vectorWithX:*((double *)&v41 + 1) Y:*(double *)&v41 Z:*((double *)&v40 + 1) W:0.0];
        return 6;
      case 5:
        *a3 = +[CIVector vectorWithX:v43[1] Y:v43[0] Z:*((double *)&v42 + 1) W:*(double *)&v42];
        return 4;
      case 7:
        *a3 = +[CIVector vectorWithX:v43[1] Y:v43[0] Z:*((double *)&v42 + 1)];
        return 2;
    }
  }
  double v23 = v43[1] * 0.5 + v43[0];
  double v24 = *((double *)&v41 + 1) + *(double *)&v41;
  double v25 = *((double *)&v40 + 1) + *(double *)&v40;
  double v26 = *((double *)&v39 + 1) + *(double *)&v39;
  double v27 = *(double *)&v42 / (*((double *)&v42 + 1) + *(double *)&v42) + 2.0;
  if (*((double *)&v42 + 1) + *(double *)&v42 >= 0.00001)
  {
    double v28 = *((double *)&v42 + 1) + *(double *)&v42;
  }
  else
  {
    double v27 = 0.0;
    double v28 = 0.0;
  }
  if (v24 >= 0.00001) {
    double v29 = *(double *)&v41 / (*((double *)&v41 + 1) + *(double *)&v41) + 4.0;
  }
  else {
    double v29 = 0.0;
  }
  if (v24 >= 0.00001) {
    double v30 = *((double *)&v41 + 1) + *(double *)&v41;
  }
  else {
    double v30 = 0.0;
  }
  if (v25 >= 0.00001) {
    double v31 = *((double *)&v40 + 1) + *(double *)&v40;
  }
  else {
    double v31 = 0.0;
  }
  if (v25 >= 0.00001) {
    double v32 = *(double *)&v40 / (*((double *)&v40 + 1) + *(double *)&v40) + 6.0;
  }
  else {
    double v32 = 0.0;
  }
  if (v26 >= 0.00001) {
    double v33 = *((double *)&v39 + 1) + *(double *)&v39;
  }
  else {
    double v33 = 0.0;
  }
  if (v26 >= 0.00001) {
    double v34 = *(double *)&v39 / (*((double *)&v39 + 1) + *(double *)&v39) + 8.0;
  }
  else {
    double v34 = 0.0;
  }
  *a2 = v43[0] / v23;
  a2[1] = v27;
  a2[2] = v29;
  a2[3] = v32;
  a2[4] = v34;
  *a3 = +[CIVector vectorWithX:Y:Z:W:](CIVector, "vectorWithX:Y:Z:W:", v23, v28, v30, v31, *(_OWORD *)&v35);
  *a4 = +[CIVector vectorWithX:v33 Y:0.0 Z:0.0 W:0.0];
  if (v33 > 0.0) {
    return 9;
  }
  if (v31 > 0.0) {
    return 7;
  }
  if (v30 > 0.0) {
    return 5;
  }
  if (v28 <= 0.0) {
    return 1;
  }
  return 3;
}

double ___ZL9blurImageP7CIImagedd_block_invoke_5(uint64_t a1, double a2, CGFloat a3, double a4, CGFloat a5)
{
  double v8 = a2;
  int v9 = *(_DWORD *)(a1 + 32);
  if (!CGRectIsEmpty(*(CGRect *)&a2))
  {
    v11.origin.CGFloat x = v8 - (double)v9;
    v11.size.CGFloat width = a4 + (double)v9 * 2.0;
    v11.origin.CGFloat y = a3;
    v11.size.CGFloat height = a5;
    *(void *)&double v8 = (unint64_t)CGRectIntegral(v11);
  }
  return v8;
}

double ___ZL9blurImageP7CIImagedd_block_invoke_6(uint64_t a1, double a2, double a3, CGFloat a4, double a5)
{
  double v8 = a2;
  int v9 = *(_DWORD *)(a1 + 32);
  if (!CGRectIsEmpty(*(CGRect *)&a2))
  {
    v11.origin.CGFloat y = a3 - (double)v9;
    v11.size.CGFloat height = a5 + (double)v9 * 2.0;
    v11.origin.CGFloat x = v8;
    v11.size.CGFloat width = a4;
    *(void *)&double v8 = (unint64_t)CGRectIntegral(v11);
  }
  return v8;
}

double cikernel::_gaussianReduce4(uint64_t a1, int8x16_t a2)
{
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  float64x2_t v4 = (float64x2_t)a2;
  *(float32x2_t *)v5.i8 = vmul_f32(*(float32x2_t *)a2.i8, *DC);
  float32x2_t v86 = *(float32x2_t *)v5.i8;
  LODWORD(v6) = *(_DWORD *)(a1 + 28);
  *(float *)&double v7 = *(float *)(a1 + 24)
                + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v5.i8, 1), *(float *)(a1 + 16), *(float *)v5.i32);
  LODWORD(v8) = *(_DWORD *)(a1 + 36);
  *(float *)v4.f64 = *(float *)&v8
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v5.i8, 1), *(float *)&v6, *(float *)v5.i32);
  HIDWORD(v7) = LODWORD(v4.f64[0]);
  *(double *)v11.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v7, v4, v6, v8, v5, v9, v10);
  float32x2_t v12 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  *(float32x2_t *)a2.i8 = v12;
  float32x2_t v13 = vmul_f32(v12, (float32x2_t)vdup_n_s32(0x3FF9A00Bu));
  float32x2_t v14 = vsub_f32(v86, v13);
  *(float *)&double v15 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v14, 1), *(float *)(a1 + 16), v14.f32[0]);
  v12.i32[0] = *(_DWORD *)(a1 + 24);
  v16.i32[0] = *(_DWORD *)(a1 + 28);
  v17.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v14, 1), *(float *)v16.i32, v14.f32[0]);
  float32x4_t v19 = (float32x4_t)vdupq_n_s32(0x3E7F158Eu);
  float32x4_t v80 = vmulq_f32(v11, v19);
  v11.f32[0] = v12.f32[0] + *(float *)&v15;
  v19.f32[0] = *(float *)v17.i32 + *(float *)v18.i32;
  v11.f32[1] = *(float *)v17.i32 + *(float *)v18.i32;
  *(double *)v20.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v11.i64, (float64x2_t)v19, *(double *)&v12, v15, v16, v18, v17);
  float32x4_t v77 = v20;
  *(float32x2_t *)v20.f32 = vadd_f32(v13, v86);
  *(float *)&double v21 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v20.f32, 1), *(float *)(a1 + 16), v20.f32[0]);
  LODWORD(v22) = *(_DWORD *)(a1 + 28);
  v23.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v24.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v20.f32, 1), *(float *)&v22, v20.f32[0]);
  v20.f32[0] = *(float *)(a1 + 24) + *(float *)&v21;
  *(float *)v25.f64 = *(float *)v23.i32 + *(float *)v24.i32;
  v20.f32[1] = *(float *)v23.i32 + *(float *)v24.i32;
  *(double *)v27.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v20.i64, v25, v21, v22, v24, v23, v26);
  HIDWORD(v28) = a2.i32[1];
  float32x2_t v29 = vmul_f32(*(float32x2_t *)a2.i8, (float32x2_t)vdup_n_s32(0x4079B00Du));
  float32x2_t v30 = vsub_f32(v86, v29);
  *(float *)&double v31 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v30, 1), *(float *)(a1 + 16), v30.f32[0]);
  LODWORD(v28) = *(_DWORD *)(a1 + 24);
  v32.i32[0] = *(_DWORD *)(a1 + 28);
  v33.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v34.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v30, 1), *(float *)v32.i32, v30.f32[0]);
  float64x2_t v35 = (float64x2_t)v80;
  float32x4_t v81 = vaddq_f32(v80, vmulq_f32(vaddq_f32(v77, v27), (float32x4_t)vdupq_n_s32(0x3E51EA47u)));
  v27.f32[0] = *(float *)&v28 + *(float *)&v31;
  *(float *)v35.f64 = *(float *)v33.i32 + *(float *)v34.i32;
  v27.f32[1] = *(float *)v33.i32 + *(float *)v34.i32;
  *(double *)v36.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v27.i64, v35, v28, v31, v32, v34, v33);
  float32x4_t v78 = v36;
  *(float32x2_t *)v36.f32 = vadd_f32(v29, v86);
  *(float *)&double v37 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v36.f32, 1), *(float *)(a1 + 16), v36.f32[0]);
  LODWORD(v38) = *(_DWORD *)(a1 + 28);
  v39.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v40.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v36.f32, 1), *(float *)&v38, v36.f32[0]);
  v36.f32[0] = *(float *)(a1 + 24) + *(float *)&v37;
  *(float *)v41.f64 = *(float *)v39.i32 + *(float *)v40.i32;
  v36.f32[1] = *(float *)v39.i32 + *(float *)v40.i32;
  *(double *)v43.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v36.i64, v41, v37, v38, v40, v39, v42);
  HIDWORD(v44) = a2.i32[1];
  float32x2_t v45 = vmul_f32(*(float32x2_t *)a2.i8, (float32x2_t)vdup_n_s32(0x40BB7805u));
  float32x2_t v46 = vsub_f32(v86, v45);
  *(float *)&double v47 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v46, 1), *(float *)(a1 + 16), v46.f32[0]);
  LODWORD(v44) = *(_DWORD *)(a1 + 24);
  v48.i32[0] = *(_DWORD *)(a1 + 28);
  v49.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v50.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v46, 1), *(float *)v48.i32, v46.f32[0]);
  float64x2_t v51 = (float64x2_t)v81;
  float32x4_t v82 = vaddq_f32(v81, vmulq_f32(vaddq_f32(v78, v43), (float32x4_t)vdupq_n_s32(0x3DE9F147u)));
  v43.f32[0] = *(float *)&v44 + *(float *)&v47;
  *(float *)v51.f64 = *(float *)v49.i32 + *(float *)v50.i32;
  v43.f32[1] = *(float *)v49.i32 + *(float *)v50.i32;
  *(double *)v52.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v43.i64, v51, v44, v47, v48, v50, v49);
  float32x4_t v79 = v52;
  *(float32x2_t *)v52.f32 = vadd_f32(v45, v86);
  *(float *)&double v53 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v52.f32, 1), *(float *)(a1 + 16), v52.f32[0]);
  LODWORD(v54) = *(_DWORD *)(a1 + 28);
  v55.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v56.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v52.f32, 1), *(float *)&v54, v52.f32[0]);
  v52.f32[0] = *(float *)(a1 + 24) + *(float *)&v53;
  *(float *)v57.f64 = *(float *)v55.i32 + *(float *)v56.i32;
  v52.f32[1] = *(float *)v55.i32 + *(float *)v56.i32;
  *(double *)v59.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v52.i64, v57, v53, v54, v56, v55, v58);
  HIDWORD(v60) = a2.i32[1];
  float32x2_t v61 = vmul_f32(*(float32x2_t *)a2.i8, (float32x2_t)vdup_n_s32(0x40FBCDB9u));
  float32x2_t v62 = vsub_f32(v86, v61);
  *(float *)&double v63 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v62, 1), *(float *)(a1 + 16), v62.f32[0]);
  LODWORD(v60) = *(_DWORD *)(a1 + 24);
  v64.i32[0] = *(_DWORD *)(a1 + 28);
  v65.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v66.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v62, 1), *(float *)v64.i32, v62.f32[0]);
  float64x2_t v67 = (float64x2_t)v82;
  float32x4_t v85 = vaddq_f32(v82, vmulq_f32(vaddq_f32(v79, v59), (float32x4_t)vdupq_n_s32(0x3D31953Au)));
  v59.f32[0] = *(float *)&v60 + *(float *)&v63;
  *(float *)v67.f64 = *(float *)v65.i32 + *(float *)v66.i32;
  v59.f32[1] = *(float *)v65.i32 + *(float *)v66.i32;
  *(double *)v68.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v59.i64, v67, v60, v63, v64, v66, v65);
  float32x4_t v83 = v68;
  *(float32x2_t *)v68.f32 = vadd_f32(v61, v86);
  *(float *)&double v69 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v68.f32, 1), *(float *)(a1 + 16), v68.f32[0]);
  LODWORD(v70) = *(_DWORD *)(a1 + 28);
  v71.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v72.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v68.f32, 1), *(float *)&v70, v68.f32[0]);
  v68.f32[0] = *(float *)(a1 + 24) + *(float *)&v69;
  *(float *)v73.f64 = *(float *)v71.i32 + *(float *)v72.i32;
  v68.f32[1] = *(float *)v71.i32 + *(float *)v72.i32;
  *(double *)v75.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v68.i64, v73, v69, v70, v72, v71, v74);
  *(void *)&double result = vaddq_f32(v85, vmulq_f32(vaddq_f32(v83, v75), (float32x4_t)vdupq_n_s32(0x3C52D001u))).u64[0];
  return result;
}

double cikernel::_gaussianReduce2(uint64_t a1, float64x2_t a2)
{
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  float64x2_t v4 = a2;
  *(float32x2_t *)v5.i8 = vmul_f32(*(float32x2_t *)&a2.f64[0], *DC);
  int8x16_t v47 = v5;
  float32x2_t v6 = (float32x2_t)vextq_s8((int8x16_t)v4, (int8x16_t)v4, 8uLL).u64[0];
  float32x2_t v7 = vmul_f32(v6, (float32x2_t)vdup_n_s32(0x406FB10Au));
  *(float32x2_t *)&v4.f64[0] = vsub_f32(*(float32x2_t *)v5.i8, v7);
  *(float *)&double v8 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v4.f64[0], 1), *(float *)(a1 + 16), *(float *)v4.f64);
  v5.i32[0] = *(_DWORD *)(a1 + 24);
  v9.i32[0] = *(_DWORD *)(a1 + 28);
  v10.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v4.f64[0], 1), *(float *)v9.i32, *(float *)v4.f64);
  *(int32x2_t *)&v4.f64[0] = vdup_n_s32(0x3FEC5190u);
  float32x2_t v12 = vmul_f32(v6, *(float32x2_t *)&v4.f64[0]);
  v6.f32[0] = *(float *)v5.i32 + *(float *)&v8;
  *(float *)v4.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  v6.f32[1] = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v6, v4, *(double *)v5.i64, v8, v9, v11, v10);
  float32x4_t v46 = v13;
  *(float32x2_t *)v13.f32 = vsub_f32(*(float32x2_t *)v47.i8, v12);
  *(float *)&double v14 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v13.f32, 1), *(float *)(a1 + 16), v13.f32[0]);
  LODWORD(v15) = *(_DWORD *)(a1 + 28);
  v16.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v13.f32, 1), *(float *)&v15, v13.f32[0]);
  v13.f32[0] = *(float *)(a1 + 24) + *(float *)&v14;
  *(float *)v18.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v13.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v20.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v13.i64, v18, v14, v15, v17, v16, v19);
  float32x4_t v44 = v20;
  LODWORD(v21) = *(_DWORD *)(a1 + 28);
  v20.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v47.i8, 1), *(float *)(a1 + 16), *(float *)v47.i32);
  LODWORD(v22) = *(_DWORD *)(a1 + 36);
  *(float *)v23.f64 = *(float *)&v22
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v47.i8, 1), *(float *)&v21, *(float *)v47.i32);
  v20.i32[1] = LODWORD(v23.f64[0]);
  *(double *)v26.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v20.i64, v23, v21, v22, v47, v24, v25);
  float32x4_t v43 = v26;
  *(float32x2_t *)v26.f32 = vadd_f32(v12, *(float32x2_t *)v47.i8);
  *(float *)&double v27 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v26.f32, 1), *(float *)(a1 + 16), v26.f32[0]);
  LODWORD(v28) = *(_DWORD *)(a1 + 28);
  v29.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v30.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v26.f32, 1), *(float *)&v28, v26.f32[0]);
  v26.f32[0] = *(float *)(a1 + 24) + *(float *)&v27;
  *(float *)v31.f64 = *(float *)v29.i32 + *(float *)v30.i32;
  v26.f32[1] = *(float *)v29.i32 + *(float *)v30.i32;
  *(double *)v33.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v26.i64, v31, v27, v28, v30, v29, v32);
  float32x2_t v34 = vadd_f32(v7, *(float32x2_t *)v47.i8);
  *(float *)&double v35 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v34, 1), *(float *)(a1 + 16), v34.f32[0]);
  LODWORD(v36) = *(_DWORD *)(a1 + 24);
  v37.i32[0] = *(_DWORD *)(a1 + 28);
  v38.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v39.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v34, 1), *(float *)v37.i32, v34.f32[0]);
  float64x2_t v40 = (float64x2_t)v44;
  float32x4_t v48 = vaddq_f32(v44, v33);
  v33.f32[0] = *(float *)&v36 + *(float *)&v35;
  *(float *)v40.f64 = *(float *)v38.i32 + *(float *)v39.i32;
  v33.f32[1] = *(float *)v38.i32 + *(float *)v39.i32;
  *(double *)v41.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v33.i64, v40, v36, v35, v37, v39, v38);
  *(void *)&double result = vaddq_f32(vaddq_f32(vmulq_f32(v43, (float32x4_t)vdupq_n_s32(0x3EDD5539u)), vmulq_f32(v48, (float32x4_t)vdupq_n_s32(0x3E766429u))), vmulq_f32(vaddq_f32(v46, v41), (float32x4_t)vdupq_n_s32(0x3D311A78u))).u64[0];
  return result;
}

double cikernel::_gaussianBlur19(uint64_t a1, int8x16_t a2, int8x16_t a3, float32x2_t a4, float32x4_t a5, float a6)
{
  float32x2_t v8 = *(float32x2_t *)CI::getDC((CI *)a1);
  float32x2_t v9 = vsub_f32(v8, a4);
  *(float *)&double v10 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v9, 1), *(float *)(a1 + 16), v9.f32[0]);
  LODWORD(v11) = *(_DWORD *)(a1 + 28);
  v12.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v13.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v9, 1), *(float *)&v11, v9.f32[0]);
  v9.f32[0] = *(float *)(a1 + 24) + *(float *)&v10;
  *(float *)v14.f64 = *(float *)v12.i32 + *(float *)v13.i32;
  v9.f32[1] = *(float *)v12.i32 + *(float *)v13.i32;
  *(double *)v16.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v9, v14, v10, v11, v13, v12, v15);
  float32x4_t v89 = v16;
  float32x2_t v85 = (float32x2_t)vextq_s8(a3, a3, 8uLL).u64[0];
  *(float32x2_t *)v16.f32 = vsub_f32(v8, v85);
  *(float *)&double v17 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v16.f32, 1), *(float *)(a1 + 16), v16.f32[0]);
  LODWORD(v18) = *(_DWORD *)(a1 + 28);
  v19.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v20.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v16.f32, 1), *(float *)&v18, v16.f32[0]);
  v16.f32[0] = *(float *)(a1 + 24) + *(float *)&v17;
  *(float *)v21.f64 = *(float *)v19.i32 + *(float *)v20.i32;
  v16.f32[1] = *(float *)v19.i32 + *(float *)v20.i32;
  *(double *)v23.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v16.i64, v21, v17, v18, v20, v19, v22);
  float32x4_t v88 = v23;
  *(float32x2_t *)v23.f32 = vsub_f32(v8, *(float32x2_t *)a3.i8);
  *(float *)&double v24 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v23.f32, 1), *(float *)(a1 + 16), v23.f32[0]);
  LODWORD(v25) = *(_DWORD *)(a1 + 28);
  v26.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v27.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v23.f32, 1), *(float *)&v25, v23.f32[0]);
  v23.f32[0] = *(float *)(a1 + 24) + *(float *)&v24;
  *(float *)v28.f64 = *(float *)v26.i32 + *(float *)v27.i32;
  v23.f32[1] = *(float *)v26.i32 + *(float *)v27.i32;
  *(double *)v30.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v23.i64, v28, v24, v25, v27, v26, v29);
  float32x4_t v87 = v30;
  float32x2_t v81 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  *(float32x2_t *)v30.f32 = vsub_f32(v8, v81);
  *(float *)&double v31 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v30.f32, 1), *(float *)(a1 + 16), v30.f32[0]);
  LODWORD(v32) = *(_DWORD *)(a1 + 28);
  v33.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v34.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v30.f32, 1), *(float *)&v32, v30.f32[0]);
  v30.f32[0] = *(float *)(a1 + 24) + *(float *)&v31;
  *(float *)v35.f64 = *(float *)v33.i32 + *(float *)v34.i32;
  v30.f32[1] = *(float *)v33.i32 + *(float *)v34.i32;
  *(double *)v37.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v30.i64, v35, v31, v32, v34, v33, v36);
  float32x4_t v84 = v37;
  *(float32x2_t *)v37.f32 = vsub_f32(v8, *(float32x2_t *)a2.i8);
  *(float *)&double v38 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v37.f32, 1), *(float *)(a1 + 16), v37.f32[0]);
  LODWORD(v39) = *(_DWORD *)(a1 + 28);
  v40.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v41.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v37.f32, 1), *(float *)&v39, v37.f32[0]);
  v37.f32[0] = *(float *)(a1 + 24) + *(float *)&v38;
  *(float *)v42.f64 = *(float *)v40.i32 + *(float *)v41.i32;
  v37.f32[1] = *(float *)v40.i32 + *(float *)v41.i32;
  *(double *)v44.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v37.i64, v42, v38, v39, v41, v40, v43);
  float32x4_t v83 = v44;
  *(float32x2_t *)v44.f32 = vadd_f32(*(float32x2_t *)a2.i8, v8);
  *(float *)&double v45 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v44.f32, 1), *(float *)(a1 + 16), v44.f32[0]);
  LODWORD(v46) = *(_DWORD *)(a1 + 28);
  v47.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v48.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v44.f32, 1), *(float *)&v46, v44.f32[0]);
  v44.f32[0] = *(float *)(a1 + 24) + *(float *)&v45;
  *(float *)v49.f64 = *(float *)v47.i32 + *(float *)v48.i32;
  v44.f32[1] = *(float *)v47.i32 + *(float *)v48.i32;
  *(double *)v51.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v44.i64, v49, v45, v46, v48, v47, v50);
  float32x4_t v93 = v51;
  *(float32x2_t *)v51.f32 = vadd_f32(v81, v8);
  *(float *)&double v52 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v51.f32, 1), *(float *)(a1 + 16), v51.f32[0]);
  LODWORD(v53) = *(_DWORD *)(a1 + 28);
  v54.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v55.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v51.f32, 1), *(float *)&v53, v51.f32[0]);
  v51.f32[0] = *(float *)(a1 + 24) + *(float *)&v52;
  *(float *)v56.f64 = *(float *)v54.i32 + *(float *)v55.i32;
  v51.f32[1] = *(float *)v54.i32 + *(float *)v55.i32;
  *(double *)v58.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v51.i64, v56, v52, v53, v55, v54, v57);
  float32x4_t v82 = v58;
  *(float32x2_t *)v58.f32 = vadd_f32(*(float32x2_t *)a3.i8, v8);
  *(float *)&double v59 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v58.f32, 1), *(float *)(a1 + 16), v58.f32[0]);
  LODWORD(v60) = *(_DWORD *)(a1 + 28);
  v61.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v62.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v58.f32, 1), *(float *)&v60, v58.f32[0]);
  v58.f32[0] = *(float *)(a1 + 24) + *(float *)&v59;
  *(float *)v63.f64 = *(float *)v61.i32 + *(float *)v62.i32;
  v58.f32[1] = *(float *)v61.i32 + *(float *)v62.i32;
  *(double *)v65.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v58.i64, v63, v59, v60, v62, v61, v64);
  float32x4_t v95 = v65;
  *(float32x2_t *)v65.f32 = vadd_f32(v85, v8);
  *(float *)&double v66 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v65.f32, 1), *(float *)(a1 + 16), v65.f32[0]);
  LODWORD(v67) = *(_DWORD *)(a1 + 28);
  v68.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v69.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v65.f32, 1), *(float *)&v67, v65.f32[0]);
  v65.f32[0] = *(float *)(a1 + 24) + *(float *)&v66;
  *(float *)v70.f64 = *(float *)v68.i32 + *(float *)v69.i32;
  v65.f32[1] = *(float *)v68.i32 + *(float *)v69.i32;
  *(double *)v72.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v65.i64, v70, v66, v67, v69, v68, v71);
  float32x4_t v86 = v72;
  *(float32x2_t *)v72.f32 = vadd_f32(a4, v8);
  *(float *)&double v73 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v72.f32, 1), *(float *)(a1 + 16), v72.f32[0]);
  LODWORD(v74) = *(_DWORD *)(a1 + 28);
  v75.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v76.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v72.f32, 1), *(float *)&v74, v72.f32[0]);
  v72.f32[0] = *(float *)(a1 + 24) + *(float *)&v73;
  *(float *)v77.f64 = *(float *)v75.i32 + *(float *)v76.i32;
  v72.f32[1] = *(float *)v75.i32 + *(float *)v76.i32;
  *(double *)v79.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v72.i64, v77, v73, v74, v76, v75, v78);
  *(void *)&double result = vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vmulq_n_f32(vaddq_f32(v83, v93), a5.f32[0]), vmulq_lane_f32(vaddq_f32(v84, v82), *(float32x2_t *)a5.f32, 1)), vmulq_laneq_f32(vaddq_f32(v87, v95), a5, 2)), vmulq_laneq_f32(vaddq_f32(v88, v86), a5, 3)), vmulq_n_f32(vaddq_f32(v89, v79), a6)).u64[0];
  return result;
}

void CI::f4_sr_f4_f4_f2_f4_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = *(void *)(a1 + 48);
  double v11 = *(double (**)(uint64_t, __n128, __n128, double, __n128, double))(a1 + 24);
  uint64_t v12 = *(void *)(v10 + 8);
  int v13 = *(_DWORD *)(v10 + 40);
  uint64_t v14 = *(void *)(v10 + 32);
  int v15 = *(_DWORD *)(v10 + 64);
  uint64_t v16 = *(void *)(v10 + 56);
  int v17 = *(_DWORD *)(v10 + 88);
  uint64_t v18 = *(void *)(v10 + 80);
  int v19 = *(_DWORD *)(v10 + 112);
  uint64_t v20 = *(void *)(v10 + 104);
  int v21 = *(_DWORD *)(v10 + 136);
  uint64_t v22 = *(void *)(v10 + 128);
  if (*(unsigned char *)(a1 + 64))
  {
    uint64_t v32 = *(void *)(v10 + 56);
    int8x16_t v33 = *(double (**)(uint64_t, __n128, __n128, double, __n128, double))(a1 + 24);
    uint64_t v31 = *(void *)(v10 + 8);
    uint64_t v29 = *(void *)(v10 + 32);
    int v30 = *(_DWORD *)(v10 + 112);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 152)), a2);
    int v19 = v30;
    uint64_t v12 = v31;
    uint64_t v16 = v32;
    uint64_t v14 = v29;
    double v11 = v33;
  }
  float32x4_t v23 = (double *)(a3 + 16 * v22);
  if (v21 != 5) {
    float32x4_t v23 = (double *)((char *)a2 + 64 * v22);
  }
  double v24 = (__n128 *)(a3 + 16 * v20);
  if (v19 != 5) {
    double v24 = (__n128 *)((char *)a2 + 64 * v20);
  }
  double v25 = (double *)(a3 + 16 * v18);
  if (v17 != 5) {
    double v25 = (double *)((char *)a2 + 64 * v18);
  }
  int8x16_t v26 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5) {
    int8x16_t v26 = (__n128 *)((char *)a2 + 64 * v16);
  }
  int8x16_t v27 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    int8x16_t v27 = (__n128 *)((char *)a2 + 64 * v14);
  }
  *(double *)&long long v28 = v11(a4 + 80 * v12, *v27, *v26, *v25, *v24, *v23);
  *(_OWORD *)(a3 + 16 * a7) = v28;
}

double cikernel::_gaussianBlur15(uint64_t a1, int8x16_t a2, int8x16_t a3, float32x4_t a4)
{
  float32x2_t v5 = *(float32x2_t *)CI::getDC((CI *)a1);
  float32x2_t v69 = (float32x2_t)vextq_s8(a3, a3, 8uLL).u64[0];
  float32x2_t v6 = vsub_f32(v5, v69);
  *(float *)&double v7 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v6, 1), *(float *)(a1 + 16), v6.f32[0]);
  LODWORD(v8) = *(_DWORD *)(a1 + 28);
  v9.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v10.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v6, 1), *(float *)&v8, v6.f32[0]);
  v6.f32[0] = *(float *)(a1 + 24) + *(float *)&v7;
  *(float *)v11.f64 = *(float *)v9.i32 + *(float *)v10.i32;
  v6.f32[1] = *(float *)v9.i32 + *(float *)v10.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v6, v11, v7, v8, v10, v9, v12);
  float32x4_t v70 = v13;
  *(float32x2_t *)v13.f32 = vsub_f32(v5, *(float32x2_t *)a3.i8);
  *(float *)&double v14 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v13.f32, 1), *(float *)(a1 + 16), v13.f32[0]);
  LODWORD(v15) = *(_DWORD *)(a1 + 28);
  v16.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v13.f32, 1), *(float *)&v15, v13.f32[0]);
  v13.f32[0] = *(float *)(a1 + 24) + *(float *)&v14;
  *(float *)v18.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v13.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v20.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v13.i64, v18, v14, v15, v17, v16, v19);
  float32x4_t v68 = v20;
  float32x2_t v64 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  *(float32x2_t *)v20.f32 = vsub_f32(v5, v64);
  *(float *)&double v21 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v20.f32, 1), *(float *)(a1 + 16), v20.f32[0]);
  LODWORD(v22) = *(_DWORD *)(a1 + 28);
  v23.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v24.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v20.f32, 1), *(float *)&v22, v20.f32[0]);
  v20.f32[0] = *(float *)(a1 + 24) + *(float *)&v21;
  *(float *)v25.f64 = *(float *)v23.i32 + *(float *)v24.i32;
  v20.f32[1] = *(float *)v23.i32 + *(float *)v24.i32;
  *(double *)v27.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v20.i64, v25, v21, v22, v24, v23, v26);
  float32x4_t v67 = v27;
  *(float32x2_t *)v27.f32 = vsub_f32(v5, *(float32x2_t *)a2.i8);
  *(float *)&double v28 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v27.f32, 1), *(float *)(a1 + 16), v27.f32[0]);
  LODWORD(v29) = *(_DWORD *)(a1 + 28);
  v30.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v31.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v27.f32, 1), *(float *)&v29, v27.f32[0]);
  v27.f32[0] = *(float *)(a1 + 24) + *(float *)&v28;
  *(float *)v32.f64 = *(float *)v30.i32 + *(float *)v31.i32;
  v27.f32[1] = *(float *)v30.i32 + *(float *)v31.i32;
  *(double *)v34.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v27.i64, v32, v28, v29, v31, v30, v33);
  float32x4_t v66 = v34;
  *(float32x2_t *)v34.f32 = vadd_f32(*(float32x2_t *)a2.i8, v5);
  *(float *)&double v35 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v34.f32, 1), *(float *)(a1 + 16), v34.f32[0]);
  LODWORD(v36) = *(_DWORD *)(a1 + 28);
  v37.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v38.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v34.f32, 1), *(float *)&v36, v34.f32[0]);
  v34.f32[0] = *(float *)(a1 + 24) + *(float *)&v35;
  *(float *)v39.f64 = *(float *)v37.i32 + *(float *)v38.i32;
  v34.f32[1] = *(float *)v37.i32 + *(float *)v38.i32;
  *(double *)v41.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v34.i64, v39, v35, v36, v38, v37, v40);
  float32x4_t v73 = v41;
  *(float32x2_t *)v41.f32 = vadd_f32(v64, v5);
  *(float *)&double v42 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v41.f32, 1), *(float *)(a1 + 16), v41.f32[0]);
  LODWORD(v43) = *(_DWORD *)(a1 + 28);
  v44.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v45.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v41.f32, 1), *(float *)&v43, v41.f32[0]);
  v41.f32[0] = *(float *)(a1 + 24) + *(float *)&v42;
  *(float *)v46.f64 = *(float *)v44.i32 + *(float *)v45.i32;
  v41.f32[1] = *(float *)v44.i32 + *(float *)v45.i32;
  *(double *)v48.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v41.i64, v46, v42, v43, v45, v44, v47);
  float32x4_t v65 = v48;
  *(float32x2_t *)v48.f32 = vadd_f32(*(float32x2_t *)a3.i8, v5);
  *(float *)&double v49 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v48.f32, 1), *(float *)(a1 + 16), v48.f32[0]);
  LODWORD(v50) = *(_DWORD *)(a1 + 28);
  v51.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v52.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v48.f32, 1), *(float *)&v50, v48.f32[0]);
  v48.f32[0] = *(float *)(a1 + 24) + *(float *)&v49;
  *(float *)v53.f64 = *(float *)v51.i32 + *(float *)v52.i32;
  v48.f32[1] = *(float *)v51.i32 + *(float *)v52.i32;
  *(double *)v55.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v48.i64, v53, v49, v50, v52, v51, v54);
  float32x4_t v75 = v55;
  *(float32x2_t *)v55.f32 = vadd_f32(v69, v5);
  *(float *)&double v56 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v55.f32, 1), *(float *)(a1 + 16), v55.f32[0]);
  LODWORD(v57) = *(_DWORD *)(a1 + 28);
  v58.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v59.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v55.f32, 1), *(float *)&v57, v55.f32[0]);
  v55.f32[0] = *(float *)(a1 + 24) + *(float *)&v56;
  *(float *)v60.f64 = *(float *)v58.i32 + *(float *)v59.i32;
  v55.f32[1] = *(float *)v58.i32 + *(float *)v59.i32;
  *(double *)v62.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v55.i64, v60, v56, v57, v59, v58, v61);
  *(void *)&double result = vaddq_f32(vaddq_f32(vaddq_f32(vmulq_n_f32(vaddq_f32(v66, v73), a4.f32[0]), vmulq_lane_f32(vaddq_f32(v67, v65), *(float32x2_t *)a4.f32, 1)), vmulq_laneq_f32(vaddq_f32(v68, v75), a4, 2)), vmulq_laneq_f32(vaddq_f32(v70, v62), a4, 3)).u64[0];
  return result;
}

double cikernel::_gaussianBlur13(uint64_t a1, float32x2_t a2, float32x4_t a3, float32x4_t a4)
{
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)v7.f64 = *(float *)(a1 + 24)
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  *((float *)v7.f64 + 1) = *(float *)(a1 + 36)
                         + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)(a1 + 28), COERCE_FLOAT(*DC));
  float64x2_t v123 = v7;
  float32x2_t v8 = vadd_f32(a2, *(float32x2_t *)CI::getDC((CI *)DC));
  *(float *)&double v9 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v8, 1), *(float *)(a1 + 16), v8.f32[0]);
  LODWORD(v10) = *(_DWORD *)(a1 + 28);
  v11.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v12.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v8, 1), *(float *)&v10, v8.f32[0]);
  v8.f32[0] = *(float *)(a1 + 24) + *(float *)&v9;
  v8.f32[1] = *(float *)v11.i32 + *(float *)v12.i32;
  float32x2_t v13 = vsub_f32(v8, *(float32x2_t *)&v123.f64[0]);
  __asm { FMOV            V0.2S, #6.0 }
  float32x2_t v19 = vmul_f32(v13, _D0);
  *(double *)v21.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v123.f64[0], v19)), v123, v9, v10, v12, v11, v20);
  float32x4_t v109 = vaddq_f32(vmulq_laneq_f32(v21, a4, 2), (float32x4_t)0);
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v123.f64[0], v19)), (float64x2_t)0, v22, v23, v24, v25, v26);
  float64x2_t v28 = (float64x2_t)v109;
  float32x4_t v110 = vaddq_f32(v109, vmulq_laneq_f32(_Q0, a4, 2));
  __asm { FMOV            V0.2S, #5.0 }
  float32x2_t v29 = vmul_f32(v13, *(float32x2_t *)_Q0.f32);
  *(double *)v35.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v123.f64[0], v29)), v28, v30, v31, v32, v33, v34);
  float64x2_t v36 = (float64x2_t)v110;
  float32x4_t v111 = vaddq_f32(v110, vmulq_lane_f32(v35, *(float32x2_t *)a4.f32, 1));
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v123.f64[0], v29)), v36, v37, v38, v39, v40, v41);
  float64x2_t v43 = (float64x2_t)v111;
  float32x4_t v112 = vaddq_f32(v111, vmulq_lane_f32(_Q0, *(float32x2_t *)a4.f32, 1));
  __asm { FMOV            V0.2S, #4.0 }
  float32x2_t v44 = vmul_f32(v13, *(float32x2_t *)_Q0.f32);
  *(double *)v50.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v123.f64[0], v44)), v43, v45, v46, v47, v48, v49);
  float64x2_t v51 = (float64x2_t)v112;
  float32x4_t v113 = vaddq_f32(v112, vmulq_n_f32(v50, a4.f32[0]));
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v123.f64[0], v44)), v51, v52, v53, v54, v55, v56);
  float32x4_t v115 = vaddq_f32(v113, vmulq_n_f32(_Q0, a4.f32[0]));
  __asm { FMOV            V0.2S, #3.0 }
  float32x2_t v58 = vmul_f32(v13, *(float32x2_t *)_Q0.f32);
  *(double *)v64.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v123.f64[0], v58)), (float64x2_t)v113, v59, v60, v61, v62, v63);
  float64x2_t v65 = (float64x2_t)v115;
  float32x4_t v116 = vaddq_f32(v115, vmulq_laneq_f32(v64, a3, 3));
  *(double *)v71.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v123.f64[0], v58)), v65, v66, v67, v68, v69, v70);
  float64x2_t v72 = (float64x2_t)v116;
  float32x4_t v117 = vaddq_f32(v116, vmulq_laneq_f32(v71, a3, 3));
  float32x2_t v73 = vadd_f32(v13, v13);
  *(double *)v79.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v123.f64[0], v73)), v72, v74, v75, v76, v77, v78);
  float64x2_t v80 = (float64x2_t)v117;
  float32x4_t v118 = vaddq_f32(v117, vmulq_laneq_f32(v79, a3, 2));
  *(double *)v86.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v123.f64[0], v73)), v80, v81, v82, v83, v84, v85);
  float64x2_t v87 = (float64x2_t)v118;
  float32x4_t v119 = vaddq_f32(v118, vmulq_laneq_f32(v86, a3, 2));
  *(double *)v93.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v123.f64[0], v13)), v87, v88, v89, v90, v91, v92);
  float64x2_t v94 = (float64x2_t)v119;
  float32x4_t v120 = vaddq_f32(v119, vmulq_lane_f32(v93, *(float32x2_t *)a3.f32, 1));
  *(double *)v100.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v123.f64[0], v13)), v94, v95, v96, v97, v98, v99);
  float64x2_t v101 = (float64x2_t)v120;
  float32x4_t v121 = vaddq_f32(v120, vmulq_lane_f32(v100, *(float32x2_t *)a3.f32, 1));
  *(double *)v107.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v123.f64[0], v101, v102, v103, v104, v105, v106);
  *(void *)&double result = vaddq_f32(v121, vmulq_n_f32(v107, a3.f32[0])).u64[0];
  return result;
}

void CI::f4_sr_f2_f4_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = *(void *)(a1 + 48);
  int8x16_t v11 = *(double (**)(uint64_t, double, __n128, __n128))(a1 + 24);
  uint64_t v12 = *(void *)(v10 + 8);
  int v13 = *(_DWORD *)(v10 + 40);
  uint64_t v14 = *(void *)(v10 + 32);
  int v15 = *(_DWORD *)(v10 + 64);
  uint64_t v16 = *(void *)(v10 + 56);
  int v17 = *(_DWORD *)(v10 + 88);
  uint64_t v18 = *(void *)(v10 + 80);
  if (*(unsigned char *)(a1 + 64))
  {
    int v23 = *(_DWORD *)(v10 + 64);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 104)), a2);
    int v15 = v23;
  }
  float32x2_t v19 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5) {
    float32x2_t v19 = (__n128 *)((char *)a2 + 64 * v18);
  }
  int8x16_t v20 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5) {
    int8x16_t v20 = (__n128 *)((char *)a2 + 64 * v16);
  }
  float32x4_t v21 = (double *)(a3 + 16 * v14);
  if (v13 != 5) {
    float32x4_t v21 = (double *)((char *)a2 + 64 * v14);
  }
  *(double *)&long long v22 = v11(a4 + 80 * v12, *v21, *v20, *v19);
  *(_OWORD *)(a3 + 16 * a7) = v22;
}

double cikernel::_gaussianBlur11(uint64_t a1, int8x16_t a2, float32x2_t a3, float32x4_t a4)
{
  float32x2_t v5 = *(float32x2_t *)CI::getDC((CI *)a1);
  float32x2_t v6 = vsub_f32(v5, a3);
  *(float *)&double v7 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v6, 1), *(float *)(a1 + 16), v6.f32[0]);
  LODWORD(v8) = *(_DWORD *)(a1 + 28);
  v9.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v10.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v6, 1), *(float *)&v8, v6.f32[0]);
  v6.f32[0] = *(float *)(a1 + 24) + *(float *)&v7;
  *(float *)v11.f64 = *(float *)v9.i32 + *(float *)v10.i32;
  v6.f32[1] = *(float *)v9.i32 + *(float *)v10.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v6, v11, v7, v8, v10, v9, v12);
  float32x4_t v54 = v13;
  float32x2_t v50 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  *(float32x2_t *)v13.f32 = vsub_f32(v5, v50);
  *(float *)&double v14 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v13.f32, 1), *(float *)(a1 + 16), v13.f32[0]);
  LODWORD(v15) = *(_DWORD *)(a1 + 28);
  v16.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v13.f32, 1), *(float *)&v15, v13.f32[0]);
  v13.f32[0] = *(float *)(a1 + 24) + *(float *)&v14;
  *(float *)v18.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v13.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v20.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v13.i64, v18, v14, v15, v17, v16, v19);
  float32x4_t v53 = v20;
  *(float32x2_t *)v20.f32 = vsub_f32(v5, *(float32x2_t *)a2.i8);
  *(float *)&double v21 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v20.f32, 1), *(float *)(a1 + 16), v20.f32[0]);
  LODWORD(v22) = *(_DWORD *)(a1 + 28);
  v23.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v24.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v20.f32, 1), *(float *)&v22, v20.f32[0]);
  v20.f32[0] = *(float *)(a1 + 24) + *(float *)&v21;
  *(float *)v25.f64 = *(float *)v23.i32 + *(float *)v24.i32;
  v20.f32[1] = *(float *)v23.i32 + *(float *)v24.i32;
  *(double *)v27.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v20.i64, v25, v21, v22, v24, v23, v26);
  float32x4_t v52 = v27;
  *(float32x2_t *)v27.f32 = vadd_f32(*(float32x2_t *)a2.i8, v5);
  *(float *)&double v28 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v27.f32, 1), *(float *)(a1 + 16), v27.f32[0]);
  LODWORD(v29) = *(_DWORD *)(a1 + 28);
  v30.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v31.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v27.f32, 1), *(float *)&v29, v27.f32[0]);
  v27.f32[0] = *(float *)(a1 + 24) + *(float *)&v28;
  *(float *)v32.f64 = *(float *)v30.i32 + *(float *)v31.i32;
  v27.f32[1] = *(float *)v30.i32 + *(float *)v31.i32;
  *(double *)v34.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v27.i64, v32, v28, v29, v31, v30, v33);
  float32x4_t v58 = v34;
  *(float32x2_t *)v34.f32 = vadd_f32(v50, v5);
  *(float *)&double v35 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v34.f32, 1), *(float *)(a1 + 16), v34.f32[0]);
  LODWORD(v36) = *(_DWORD *)(a1 + 28);
  v37.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v38.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v34.f32, 1), *(float *)&v36, v34.f32[0]);
  v34.f32[0] = *(float *)(a1 + 24) + *(float *)&v35;
  *(float *)v39.f64 = *(float *)v37.i32 + *(float *)v38.i32;
  v34.f32[1] = *(float *)v37.i32 + *(float *)v38.i32;
  *(double *)v41.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v34.i64, v39, v35, v36, v38, v37, v40);
  float32x4_t v51 = v41;
  *(float32x2_t *)v41.f32 = vadd_f32(a3, v5);
  *(float *)&double v42 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v41.f32, 1), *(float *)(a1 + 16), v41.f32[0]);
  LODWORD(v43) = *(_DWORD *)(a1 + 28);
  v44.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v45.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v41.f32, 1), *(float *)&v43, v41.f32[0]);
  v41.f32[0] = *(float *)(a1 + 24) + *(float *)&v42;
  *(float *)v46.f64 = *(float *)v44.i32 + *(float *)v45.i32;
  v41.f32[1] = *(float *)v44.i32 + *(float *)v45.i32;
  *(double *)v48.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v41.i64, v46, v42, v43, v45, v44, v47);
  *(void *)&double result = vaddq_f32(vaddq_f32(vmulq_n_f32(vaddq_f32(v52, v58), a4.f32[0]), vmulq_lane_f32(vaddq_f32(v53, v51), *(float32x2_t *)a4.f32, 1)), vmulq_laneq_f32(vaddq_f32(v54, v48), a4, 2)).u64[0];
  return result;
}

double cikernel::_gaussianBlur9(uint64_t a1, float32x2_t a2, float32x4_t a3)
{
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)v6.i32 = *(float *)(a1 + 24)
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  *(float *)&v6.i32[1] = *(float *)(a1 + 36)
                       + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)(a1 + 28), COERCE_FLOAT(*DC));
  int8x16_t v87 = v6;
  float32x2_t v7 = vadd_f32(a2, *(float32x2_t *)CI::getDC((CI *)DC));
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  float v9 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v7, 1), *(float *)(a1 + 28), v7.f32[0]);
  v7.f32[0] = *(float *)(a1 + 24)
            + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v7, 1), *(float *)(a1 + 16), v7.f32[0]);
  v7.f32[1] = *(float *)v8.i32 + v9;
  float32x2_t v10 = vsub_f32(v7, *(float32x2_t *)v87.i8);
  v11.f64[0] = a3.f32[3];
  v7.f32[0] = 0.5 - (a3.f32[1] + a3.f32[0] * 0.5 + a3.f32[2] + a3.f32[3]);
  float v78 = v7.f32[0];
  __asm { FMOV            V0.2S, #4.0 }
  float32x2_t v17 = vmul_f32(v10, _D0);
  *(double *)v19.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vsub_f32(*(float32x2_t *)v87.i8, v17)), v11, 0.5, *(double *)a3.i64, v87, v8, v18);
  float32x4_t v77 = vaddq_f32(vmulq_n_f32(v19, v78), (float32x4_t)0);
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)v87.i8, v17)), (float64x2_t)0, v20, v21, v22, v23, v24);
  float32x4_t v79 = vaddq_f32(v77, vmulq_n_f32(_Q0, v78));
  __asm { FMOV            V0.2S, #3.0 }
  float32x2_t v26 = vmul_f32(v10, *(float32x2_t *)_Q0.f32);
  *(double *)v32.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vsub_f32(*(float32x2_t *)v87.i8, v26)), (float64x2_t)v77, v27, v28, v29, v30, v31);
  float64x2_t v33 = (float64x2_t)v79;
  float32x4_t v80 = vaddq_f32(v79, vmulq_laneq_f32(v32, a3, 3));
  *(double *)v39.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)v87.i8, v26)), v33, v34, v35, v36, v37, v38);
  float64x2_t v40 = (float64x2_t)v80;
  float32x4_t v81 = vaddq_f32(v80, vmulq_laneq_f32(v39, a3, 3));
  float32x2_t v41 = vadd_f32(v10, v10);
  *(double *)v47.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vsub_f32(*(float32x2_t *)v87.i8, v41)), v40, v42, v43, v44, v45, v46);
  float64x2_t v48 = (float64x2_t)v81;
  float32x4_t v82 = vaddq_f32(v81, vmulq_laneq_f32(v47, a3, 2));
  *(double *)v54.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)v87.i8, v41)), v48, v49, v50, v51, v52, v53);
  float64x2_t v55 = (float64x2_t)v82;
  float32x4_t v83 = vaddq_f32(v82, vmulq_laneq_f32(v54, a3, 2));
  *(double *)v61.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vsub_f32(*(float32x2_t *)v87.i8, v10)), v55, v56, v57, v58, v59, v60);
  float64x2_t v62 = (float64x2_t)v83;
  float32x4_t v84 = vaddq_f32(v83, vmulq_lane_f32(v61, *(float32x2_t *)a3.f32, 1));
  *(double *)v68.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)v87.i8, v10)), v62, v63, v64, v65, v66, v67);
  float64x2_t v69 = (float64x2_t)v84;
  float32x4_t v85 = vaddq_f32(v84, vmulq_lane_f32(v68, *(float32x2_t *)a3.f32, 1));
  *(double *)v75.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v87.i64, v69, v70, v71, v72, v73, v74);
  *(void *)&double result = vaddq_f32(v85, vmulq_n_f32(v75, a3.f32[0])).u64[0];
  return result;
}

void CI::f4_sr_f2_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = *(void *)(a1 + 48);
  int8x16_t v12 = *(double (**)(uint64_t, double, __n128))(a1 + 24);
  uint64_t v13 = *(void *)(v11 + 8);
  int v14 = *(_DWORD *)(v11 + 40);
  uint64_t v15 = *(void *)(v11 + 32);
  int v16 = *(_DWORD *)(v11 + 64);
  uint64_t v17 = *(void *)(v11 + 56);
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC((CI *)(a3 + 16 * *(void *)(v11 + 80)), a2);
  }
  int8x16_t v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5) {
    int8x16_t v18 = (__n128 *)((char *)a2 + 64 * v17);
  }
  float32x4_t v19 = (double *)(a3 + 16 * v15);
  if (v14 != 5) {
    float32x4_t v19 = (double *)((char *)a2 + 64 * v15);
  }
  *(double *)&long long v20 = v12(a4 + 80 * v13, *v19, *v18);
  *(_OWORD *)(a3 + 16 * a7) = v20;
}

double cikernel::_gaussianBlur7(uint64_t a1, int8x16_t a2, double a3)
{
  float32x2_t v4 = *(float32x2_t *)CI::getDC((CI *)a1);
  float32x2_t v36 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  float32x2_t v5 = vsub_f32(v4, v36);
  *(float *)&double v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v5, 1), *(float *)(a1 + 16), v5.f32[0]);
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *(float *)(a1 + 24) + *(float *)&v6;
  *(float *)v10.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v5, v10, v6, v7, v9, v8, v11);
  float32x4_t v37 = v12;
  *(float32x2_t *)v12.f32 = vsub_f32(v4, *(float32x2_t *)a2.i8);
  *(float *)&double v13 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v12.f32, 1), *(float *)(a1 + 16), v12.f32[0]);
  LODWORD(v14) = *(_DWORD *)(a1 + 28);
  v15.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v12.f32, 1), *(float *)&v14, v12.f32[0]);
  v12.f32[0] = *(float *)(a1 + 24) + *(float *)&v13;
  *(float *)v17.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v12.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v12.i64, v17, v13, v14, v16, v15, v18);
  float32x4_t v35 = v19;
  *(float32x2_t *)v19.f32 = vadd_f32(*(float32x2_t *)a2.i8, v4);
  *(float *)&double v20 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v19.f32, 1), *(float *)(a1 + 16), v19.f32[0]);
  LODWORD(v21) = *(_DWORD *)(a1 + 28);
  v22.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v23.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v19.f32, 1), *(float *)&v21, v19.f32[0]);
  v19.f32[0] = *(float *)(a1 + 24) + *(float *)&v20;
  *(float *)v24.f64 = *(float *)v22.i32 + *(float *)v23.i32;
  v19.f32[1] = *(float *)v22.i32 + *(float *)v23.i32;
  *(double *)v26.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v19.i64, v24, v20, v21, v23, v22, v25);
  float32x4_t v40 = v26;
  *(float32x2_t *)v26.f32 = vadd_f32(v36, v4);
  *(float *)&double v27 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v26.f32, 1), *(float *)(a1 + 16), v26.f32[0]);
  LODWORD(v28) = *(_DWORD *)(a1 + 28);
  v29.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v30.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v26.f32, 1), *(float *)&v28, v26.f32[0]);
  v26.f32[0] = *(float *)(a1 + 24) + *(float *)&v27;
  *(float *)v31.f64 = *(float *)v29.i32 + *(float *)v30.i32;
  v26.f32[1] = *(float *)v29.i32 + *(float *)v30.i32;
  *(double *)v33.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v26.i64, v31, v27, v28, v30, v29, v32);
  *(void *)&double result = vaddq_f32(vmulq_n_f32(vaddq_f32(v35, v40), *(float *)&a3), vmulq_lane_f32(vaddq_f32(v37, v33), *(float32x2_t *)&a3, 1)).u64[0];
  return result;
}

double cikernel::_gaussianBlur5(uint64_t a1, float32x2_t a2, float32x4_t a3)
{
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)v6.f64 = *(float *)(a1 + 24)
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  *((float *)v6.f64 + 1) = *(float *)(a1 + 36)
                         + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)(a1 + 28), COERCE_FLOAT(*DC));
  float64x2_t v48 = v6;
  float32x2_t v7 = vadd_f32(a2, *(float32x2_t *)CI::getDC((CI *)DC));
  *(float *)&double v8 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v7, 1), *(float *)(a1 + 16), v7.f32[0]);
  LODWORD(v9) = *(_DWORD *)(a1 + 28);
  v10.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v7, 1), *(float *)&v9, v7.f32[0]);
  v7.f32[0] = *(float *)(a1 + 24) + *(float *)&v8;
  v7.f32[1] = *(float *)v10.i32 + *(float *)v11.i32;
  float32x2_t v12 = vsub_f32(v7, *(float32x2_t *)&v48.f64[0]);
  float32x2_t v13 = vadd_f32(v12, v12);
  *(double *)v15.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v48.f64[0], v13)), v48, v8, v9, v11, v10, v14);
  float32x4_t v44 = vaddq_f32(vmulq_laneq_f32(v15, a3, 2), (float32x4_t)0);
  *(double *)v21.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v48.f64[0], v13)), (float64x2_t)0, v16, v17, v18, v19, v20);
  float64x2_t v22 = (float64x2_t)v44;
  float32x4_t v45 = vaddq_f32(v44, vmulq_laneq_f32(v21, a3, 2));
  *(double *)v28.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v48.f64[0], v12)), v22, v23, v24, v25, v26, v27);
  float64x2_t v29 = (float64x2_t)v45;
  float32x4_t v46 = vaddq_f32(v45, vmulq_lane_f32(v28, *(float32x2_t *)a3.f32, 1));
  *(double *)v35.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v48.f64[0], v12)), v29, v30, v31, v32, v33, v34);
  float64x2_t v36 = (float64x2_t)v46;
  float32x4_t v47 = vaddq_f32(v46, vmulq_lane_f32(v35, *(float32x2_t *)a3.f32, 1));
  *(double *)v42.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v48.f64[0], v36, v37, v38, v39, v40, v41);
  *(void *)&double result = vaddq_f32(v47, vmulq_n_f32(v42, a3.f32[0])).u64[0];
  return result;
}

double cikernel::_gaussianBlur3(uint64_t a1, float32x2_t a2)
{
  float32x2_t v3 = *(float32x2_t *)CI::getDC((CI *)a1);
  float32x2_t v4 = vsub_f32(v3, a2);
  *(float *)&double v5 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v4, 1), *(float *)(a1 + 16), v4.f32[0]);
  LODWORD(v6) = *(_DWORD *)(a1 + 28);
  v7.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v8.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v4, 1), *(float *)&v6, v4.f32[0]);
  v4.f32[0] = *(float *)(a1 + 24) + *(float *)&v5;
  *(float *)v9.f64 = *(float *)v7.i32 + *(float *)v8.i32;
  v4.f32[1] = *(float *)v7.i32 + *(float *)v8.i32;
  *(double *)v11.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v4, v9, v5, v6, v8, v7, v10);
  float32x4_t v21 = v11;
  *(float32x2_t *)v11.f32 = vadd_f32(a2, v3);
  *(float *)&double v12 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v11.f32, 1), *(float *)(a1 + 16), v11.f32[0]);
  LODWORD(v13) = *(_DWORD *)(a1 + 28);
  v14.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v11.f32, 1), *(float *)&v13, v11.f32[0]);
  v11.f32[0] = *(float *)(a1 + 24) + *(float *)&v12;
  *(float *)v16.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v11.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)v18.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v11.i64, v16, v12, v13, v15, v14, v17);
  v19.i64[0] = 0x3F0000003F000000;
  v19.i64[1] = 0x3F0000003F000000;
  *(void *)&double result = vmulq_f32(vaddq_f32(v21, v18), v19).u64[0];
  return result;
}

void sub_1937A8924(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

double cikernel::_glassDistort(uint64_t a1, uint64_t a2, float32x2_t a3, float32x2_t a4, float32x2_t a5, float32x2_t a6, float32x2_t a7, float a8)
{
  float32x2_t v15 = *(float32x2_t *)CI::getDC((CI *)a1);
  float32x2_t v16 = vmul_f32(a3, v15);
  float32x2_t v17 = vadd_f32(a4, v16);
  float32x2_t v18 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
  HIDWORD(v19) = 1056964608;
  *(float32x2_t *)&v20.f64[0] = vadd_f32(vmul_f32(a7, vminnm_f32(vsub_f32(v17, vrndm_f32(v17)), v18)), (float32x2_t)0x3F0000003F000000);
  float32x2_t v21 = vadd_f32(a5, v16);
  *(float32x2_t *)v22.i8 = vrndm_f32(v21);
  *(float32x2_t *)v23.i8 = vadd_f32(vmul_f32(a7, vminnm_f32(vsub_f32(v21, *(float32x2_t *)v22.i8), v18)), (float32x2_t)0x3F0000003F000000);
  int8x16_t v48 = v23;
  float32x2_t v24 = vadd_f32(a6, v16);
  *(float32x2_t *)v23.i8 = vrndm_f32(v24);
  *(float32x2_t *)v25.i8 = vadd_f32(vmul_f32(a7, vminnm_f32(vsub_f32(v24, *(float32x2_t *)v23.i8), v18)), (float32x2_t)0x3F0000003F000000);
  int8x16_t v50 = v25;
  LODWORD(v19) = *(_DWORD *)(a2 + 28);
  *(float *)v25.i32 = *(float *)(a2 + 24)
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *(float32x2_t *)&v20.f64[0], 1), *(float *)(a2 + 16), *(float *)v20.f64);
  v23.i32[0] = *(_DWORD *)(a2 + 36);
  v18.f32[0] = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *(float32x2_t *)&v20.f64[0], 1), *(float *)&v19, *(float *)v20.f64);
  *(float *)v20.f64 = *(float *)v23.i32 + v18.f32[0];
  *(float *)&v25.i32[1] = *(float *)v23.i32 + v18.f32[0];
  double v49 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v25.i64, v20, *(double *)&v18, v19, v23, v22, v26);
  HIDWORD(v27) = v48.i32[1];
  LODWORD(v27) = *(_DWORD *)(a2 + 28);
  v28.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)&double v29 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *(float32x2_t *)v48.i8, 1), *(float *)&v27, *(float *)v48.i32);
  *(float *)&double v30 = *(float *)(a2 + 24)
                 + vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *(float32x2_t *)v48.i8, 1), *(float *)(a2 + 16), *(float *)v48.i32);
  *(float *)v31.f64 = *(float *)v28.i32 + *(float *)&v29;
  *((float *)&v30 + 1) = *(float *)v28.i32 + *(float *)&v29;
  v48.i64[0] = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v30, v31, v27, v29, v28, v48, v32);
  HIDWORD(v33) = v50.i32[1];
  LODWORD(v33) = *(_DWORD *)(a2 + 28);
  v34.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)&double v35 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *(float32x2_t *)v50.i8, 1), *(float *)&v33, *(float *)v50.i32);
  *(float *)&double v36 = *(float *)(a2 + 24)
                 + vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *(float32x2_t *)v50.i8, 1), *(float *)(a2 + 16), *(float *)v50.i32);
  *(float *)v37.f64 = *(float *)v34.i32 + *(float *)&v35;
  *((float *)&v36 + 1) = *(float *)v34.i32 + *(float *)&v35;
  double v43 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v36, v37, v33, v35, v34, v50, v38);
  HIDWORD(v45) = HIDWORD(v49);
  v41.f64[1] = v52;
  *(float32x2_t *)&v41.f64[0] = vadd_f32(v15, vmul_n_f32((float32x2_t)vzip1_s32((int32x2_t)vsub_f32(*(float32x2_t *)v48.i8, *(float32x2_t *)&v49), (int32x2_t)vsub_f32(*(float32x2_t *)&v43, *(float32x2_t *)&v49)), a8));
  LODWORD(v42) = *(_DWORD *)(a1 + 28);
  *(float *)&double v43 = *(float *)(a1 + 24)
                 + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v41.f64[0], 1), *(float *)(a1 + 16), *(float *)v41.f64);
  v44.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)&double v45 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v41.f64[0], 1), *(float *)&v42, *(float *)v41.f64);
  float32x4_t v46 = *(uint64x2_t **)(a1 + 8);

  *((float *)&v43 + 1) = *(float *)v44.i32 + *(float *)&v45;
  *(float *)v41.f64 = *(float *)v44.i32 + *(float *)&v45;
  return CI::BitmapSampler::read(v46, v43, v41, v45, v42, v44, v39, v40);
}

void CI::f4_sr_sr_f2_f2_f2_f2_f2_f(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = *(void *)(a1 + 48);
  float32x4_t v11 = *(double (**)(uint64_t, uint64_t, double, double, double, double, double, float))(a1 + 24);
  uint64_t v12 = *(void *)(v10 + 8);
  uint64_t v13 = *(void *)(v10 + 32);
  int v14 = *(_DWORD *)(v10 + 64);
  float32x2_t v15 = *(const vec2 **)(v10 + 56);
  int v16 = *(_DWORD *)(v10 + 88);
  uint64_t v17 = *(void *)(v10 + 80);
  int v18 = *(_DWORD *)(v10 + 112);
  uint64_t v19 = *(void *)(v10 + 104);
  int v20 = *(_DWORD *)(v10 + 136);
  uint64_t v21 = *(void *)(v10 + 128);
  int v22 = *(_DWORD *)(v10 + 160);
  uint64_t v23 = *(void *)(v10 + 152);
  uint64_t v24 = *(void *)(v10 + 176);
  if (*(unsigned char *)(a1 + 64))
  {
    double v36 = *(const vec2 **)(v10 + 56);
    float64x2_t v37 = *(double (**)(uint64_t, uint64_t, double, double, double, double, double, float))(a1 + 24);
    uint64_t v33 = *(void *)(v10 + 8);
    uint64_t v34 = *(void *)(v10 + 80);
    uint64_t v35 = *(void *)(v10 + 176);
    int v31 = *(_DWORD *)(v10 + 160);
    int v32 = *(_DWORD *)(v10 + 136);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 200)), v15);
    int v22 = v31;
    int v20 = v32;
    uint64_t v17 = v34;
    uint64_t v24 = v35;
    float32x2_t v15 = v36;
    float32x4_t v11 = v37;
    uint64_t v12 = v33;
  }
  int8x16_t v25 = (double *)(a3 + 16 * v23);
  if (v22 != 5) {
    int8x16_t v25 = (double *)(a2 + (v23 << 6));
  }
  int8x16_t v26 = (double *)(a3 + 16 * v21);
  if (v20 != 5) {
    int8x16_t v26 = (double *)(a2 + (v21 << 6));
  }
  double v27 = (double *)(a3 + 16 * v19);
  if (v18 != 5) {
    double v27 = (double *)(a2 + (v19 << 6));
  }
  int8x16_t v28 = (double *)(a3 + 16 * v17);
  if (v16 != 5) {
    int8x16_t v28 = (double *)(a2 + (v17 << 6));
  }
  double v29 = (double *)(a3 + 16 * (void)v15);
  if (v14 != 5) {
    double v29 = (double *)(a2 + ((void)v15 << 6));
  }
  *(double *)&long long v30 = v11(a4 + 80 * v12, a4 + 80 * v13, *v29, *v28, *v27, *v26, *v25, *(float *)(a2 + (v24 << 6)));
  *(_OWORD *)(a3 + 16 * a7) = v30;
}

double cikernel::_radialGradient(CI *a1, __n128 a2, float32x4_t a3, float32x4_t a4)
{
  DC = (float32x2_t *)CI::getDC(a1);
  _V2.S[2] = a2.n128_u32[2];
  _D0 = vsub_f32((float32x2_t)a2.n128_u64[0], *DC);
  _D0.f32[0] = sqrtf(vaddv_f32(vmul_f32(_D0, _D0)));
  __asm { FMLA            S1, S0, V2.S[2] }
  if (_S1 <= 1.0) {
    float v12 = _S1;
  }
  else {
    float v12 = 1.0;
  }
  _NF = _S1 < 0.0;
  float v13 = 0.0;
  if (!_NF) {
    float v13 = v12;
  }
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(a3, 1.0 - v13), a4, v13).u64[0];
  return result;
}

void CI::f4_f4_clr_clr(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  float32x4_t v11 = (double (*)(void *, __n128, __n128, __n128))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  uint64_t v14 = *(void *)(v10 + 32);
  uint64_t v15 = *(void *)(v10 + 56);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 80)), a2);
  }
  int v16 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    int v16 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v17 = v11(a1, *v16, *((__n128 *)a2 + 4 * v14), *((__n128 *)a2 + 4 * v15));
  *(_OWORD *)(a3 + 16 * a7) = v17;
}

double cikernel::_linearGradient(CI *a1, float32x2_t a2, float32x2_t a3, float32x4_t a4, float32x4_t a5, float a6)
{
  float v6 = vaddv_f32(vmul_f32(vsub_f32(a3, a2), vsub_f32(*(float32x2_t *)CI::getDC(a1), a2))) * a6;
  if (v6 <= 1.0) {
    float v7 = v6;
  }
  else {
    float v7 = 1.0;
  }
  if (v6 < 0.0) {
    float v7 = 0.0;
  }
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(a4, 1.0 - v7), a5, v7).u64[0];
  return result;
}

void CI::f4_f2_f2_clr_clr_f(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = a1[6];
  uint64_t v10 = (double (*)(void *, double, double, __n128, __n128, float))a1[3];
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  int v13 = *(_DWORD *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  uint64_t v15 = *(void *)(v9 + 56);
  uint64_t v16 = *(void *)(v9 + 80);
  uint64_t v17 = *(void *)(v9 + 104);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 128)), a2);
  }
  int v18 = (double *)(a3 + 16 * v14);
  if (v13 != 5) {
    int v18 = (double *)((char *)a2 + 64 * v14);
  }
  uint64_t v19 = (double *)(a3 + 16 * v12);
  if (v11 != 5) {
    uint64_t v19 = (double *)((char *)a2 + 64 * v12);
  }
  *(double *)&long long v20 = v10(a1, *v19, *v18, *((__n128 *)a2 + 4 * v15), *((__n128 *)a2 + 4 * v16), *((float *)a2 + 16 * v17));
  *(_OWORD *)(a3 + 16 * a7) = v20;
}

double cikernel::_smoothLinearGradient(CI *a1, float32x2_t a2, float32x2_t a3, float32x4_t a4, float32x4_t a5, float a6)
{
  float v6 = vaddv_f32(vmul_f32(vsub_f32(a3, a2), vsub_f32(*(float32x2_t *)CI::getDC(a1), a2))) * a6;
  if (v6 <= 1.0) {
    float v7 = v6;
  }
  else {
    float v7 = 1.0;
  }
  BOOL v8 = v6 < 0.0;
  float v9 = 0.0;
  if (!v8) {
    float v9 = v7;
  }
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(a4, 1.0 - (float)((float)(v9 * v9) * (float)((float)(v9 * -2.0) + 3.0))), a5, (float)(v9 * v9) * (float)((float)(v9 * -2.0) + 3.0)).u64[0];
  return result;
}

double cikernel::_gaussianGradient(CI *a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  float32x2_t v4 = vsub_f32(*(float32x2_t *)a2.f32, *(float32x2_t *)CI::getDC(a1));
  double v5 = fminf(vmuls_lane_f32(sqrtf(vaddv_f32(vmul_f32(v4, v4))), a2, 2), 1.0);
  float v6 = (v5 * -2.0 + 3.0) * v5 * v5;
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(a3, 1.0 - v6), a4, v6).u64[0];
  return result;
}

void CI::f4_f3_clr_clr(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = (void *)a1[6];
  int v11 = (double (*)(void *, __n128, __n128, __n128))a1[3];
  uint64_t v12 = v10[1];
  uint64_t v13 = v10[4];
  uint64_t v14 = v10[7];
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * v10[10]), a2);
  }
  *(double *)&long long v15 = v11(a1, *((__n128 *)a2 + 4 * v12), *((__n128 *)a2 + 4 * v13), *((__n128 *)a2 + 4 * v14));
  *(_OWORD *)(a3 + 16 * a7) = v15;
}

double cikernel::_hsvwheel(CI *a1, float32x4_t a2)
{
  DC = (float32x2_t *)CI::getDC(a1);
  float32x4_t v3 = a2;
  float32x2_t v4 = vsub_f32(*DC, (float32x2_t)vdup_lane_s32(*(int32x2_t *)a2.f32, 1));
  if (v4.f32[0] == 0.0)
  {
    double v5 = -1.5;
    if (v4.f32[1] > 0.0) {
      double v5 = 1.5;
    }
  }
  else
  {
    float32x2_t v30 = v4;
    float v6 = atan2f(v4.f32[1], v4.f32[0]);
    float32x2_t v4 = v30;
    float32x4_t v3 = a2;
    double v5 = v6 * 3.0 / 3.1415926;
  }
  float v7 = sqrtf(vaddv_f32(vmul_f32(v4, v4)));
  float v8 = v5;
  float v9 = vmuls_lane_f32(v7, v3, 2);
  if (v9 <= 1.0) {
    float v10 = v9;
  }
  else {
    float v10 = 1.0;
  }
  if (v9 < 0.0) {
    float v10 = 0.0;
  }
  v11.f32[0] = v8;
  v11.f32[1] = v8 + -2.0;
  v11.i64[1] = COERCE_UNSIGNED_INT(v8 + 2.0);
  __asm { FMOV            V16.4S, #3.0 }
  float32x4_t v17 = vabdq_f32(_Q16, vabsq_f32(v11));
  __asm { FMOV            V17.4S, #-1.0 }
  float32x4_t v19 = vmaxnmq_f32(vaddq_f32(v17, _Q17), (float32x4_t)0);
  __asm { FMOV            V17.4S, #1.0 }
  float32x4_t v21 = vminnmq_f32(v19, _Q17);
  float32x4_t v22 = vminnmq_f32(vmaxnmq_f32(v21, (float32x4_t)0), _Q17);
  v23.i64[0] = 0xC0000000C0000000;
  v23.i64[1] = 0xC0000000C0000000;
  float32x4_t v24 = vmulq_n_f32(v21, 1.0 - v3.f32[3]);
  v21.f32[0] = 1.0 - v10;
  float32x4_t v25 = vmulq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 0), vmlaq_laneq_f32(v24, vmulq_f32(vmulq_f32(v22, v22), vmlaq_f32(_Q16, v23, v22)), v3, 3), v10), v3.f32[0]);
  v25.i32[3] = 1.0;
  float v26 = v3.f32[1] - v7;
  if (v26 <= 1.0) {
    float v27 = v26;
  }
  else {
    float v27 = 1.0;
  }
  if (v26 >= 0.0) {
    float v28 = v27;
  }
  else {
    float v28 = 0.0;
  }
  *(void *)&double result = vmulq_n_f32(v25, v28).u64[0];
  return result;
}

void CI::f4_f4(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  float32x4_t v11 = (double (*)(void *, __n128))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 32)), a2);
  }
  uint64_t v14 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    uint64_t v14 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v15 = v11(a1, *v14);
  *(_OWORD *)(a3 + 16 * a7) = v15;
}

double cikernel::_hsvwheeldithered(CI *a1, float32x4_t a2, float a3)
{
  DC = (float32x2_t *)CI::getDC(a1);
  float32x4_t v5 = a2;
  float32x2_t v6 = vsub_f32(*DC, (float32x2_t)vdup_lane_s32(*(int32x2_t *)a2.f32, 1));
  if (v6.f32[0] == 0.0)
  {
    double v7 = -1.5;
    if (v6.f32[1] > 0.0) {
      double v7 = 1.5;
    }
  }
  else
  {
    float32x2_t v34 = v6;
    float v8 = atan2f(v6.f32[1], v6.f32[0]);
    float32x2_t v6 = v34;
    float32x4_t v5 = a2;
    double v7 = v8 * 3.0 / 3.1415926;
  }
  int32x2_t v9 = (int32x2_t)vmul_f32(v6, v6);
  float v10 = sqrtf(vaddv_f32((float32x2_t)v9));
  float v11 = v5.f32[1];
  float v12 = v7;
  float v13 = vmuls_lane_f32(v10, v5, 2);
  float v14 = 1.0;
  if (v13 <= 1.0) {
    float v14 = v13;
  }
  if (v13 >= 0.0) {
    float v15 = v14;
  }
  else {
    float v15 = 0.0;
  }
  v16.i32[3] = 0;
  v16.f32[0] = v12;
  v16.f32[1] = v12 + -2.0;
  v16.f32[2] = v12 + 2.0;
  __asm
  {
    FMOV            V3.4S, #3.0
    FMOV            V4.4S, #-1.0
  }
  float32x4_t v23 = vmaxnmq_f32(vaddq_f32(vabdq_f32(_Q3, vabsq_f32(v16)), _Q4), (float32x4_t)0);
  __asm { FMOV            V4.4S, #1.0 }
  float32x4_t v25 = vminnmq_f32(v23, _Q4);
  float32x4_t v26 = vminnmq_f32(vmaxnmq_f32(v25, (float32x4_t)0), _Q4);
  v16.i64[0] = 0xC0000000C0000000;
  v16.i64[1] = 0xC0000000C0000000;
  *(float *)v9.i32 = 1.0 - v15;
  float32x4_t v36 = vmulq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v9, 0), vmlaq_laneq_f32(vmulq_n_f32(v25, 1.0 - v5.f32[3]), vmulq_f32(vmulq_f32(v26, v26), vmlaq_f32(_Q3, v16, v26)), v5, 3), v15), v5.f32[0]);
  float32x2_t v27 = vrndm_f32(*(float32x2_t *)CI::getDC((CI *)DC));
  float v28 = (v27.f32[0] * 13.0 + 1111.0) / 17.0;
  v27.f32[0] = (v27.f32[1] * 11.0 + 7777.0) / 19.0;
  v27.f32[0] = v28
             + (float)(v27.f32[0]
                     * (float)((float)(v27.f32[0] + (float)(v27.f32[0] * v28))
                             + (float)(floorf((float)(v27.f32[0] + (float)(v27.f32[0] * v28)) / 37.0) * -37.0)));
  v27.f32[0] = (float)(v27.f32[0] + (float)(floorf(v27.f32[0] / 37.0) * -37.0)) * v28;
  v27.f32[0] = (float)(v27.f32[0] + (float)(floorf(v27.f32[0] / 37.0) * -37.0)) * v28;
  double v29 = ((float)((float)(v27.f32[0] + (float)(floorf(v27.f32[0] / 37.0) * -37.0)) / 37.0) + -0.5) * a3;
  *(float *)&double v29 = v29;
  float32x4_t v31 = vaddq_f32(v36, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v29, 0));
  float v30 = 1.0;
  v31.i32[3] = 1.0;
  if ((float)(v11 - v10) <= 1.0) {
    float v30 = v11 - v10;
  }
  if ((float)(v11 - v10) >= 0.0) {
    float v32 = v30;
  }
  else {
    float v32 = 0.0;
  }
  *(void *)&double result = vmulq_n_f32(v31, v32).u64[0];
  return result;
}

void CI::f4_f4_f(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  float v11 = (double (*)(void *, __n128, float))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  uint64_t v14 = *(void *)(v10 + 32);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 56)), a2);
  }
  float v15 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    float v15 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v16 = v11(a1, *v15, *((float *)a2 + 16 * v14));
  *(_OWORD *)(a3 + 16 * a7) = v16;
}

id CIGVGraphCreate()
{
  if (CIGVGraphCreate_onceToken != -1) {
    dispatch_once(&CIGVGraphCreate_onceToken, &__block_literal_global_35);
  }
  if (!CIGVGraphCreate_gvClass) {
    return 0;
  }
  uint64_t v0 = (objc_class *)MEMORY[0x1E4F64CC8];

  return objc_alloc_init(v0);
}

void __CIGVGraphCreate_block_invoke()
{
  CIGVGraphCreate_gvClass = (uint64_t)NSClassFromString(&cfstr_Gvgraph.isa);
  if (!CIGVGraphCreate_gvClass) {
    NSLog(&cfstr_Graphvisualize.isa);
  }
}

uint64_t CIGVGraphAddNode(void *a1, const char *a2)
{
  return [a1 addNode:a2];
}

uint64_t CIGVGraphAddEdge(void *a1, const char *a2, uint64_t a3)
{
  return [a1 addEdgeFrom:a2 to:a3];
}

uint64_t CIGVGraphRender(void *a1, const char *a2)
{
  return [a1 render:a2];
}

CIGVNode *CIGVNodeCreate()
{
  return objc_alloc_init(CIGVNode);
}

uint64_t CIGVNodeCreateForNode(uint64_t a1, double a2, double a3, double a4, double a5)
{
  uint64_t v10 = [CIGVNode alloc];

  return (uint64_t)-[CIGVNode initWithCINode:extent:](v10, "initWithCINode:extent:", a1, a2, a3, a4, a5);
}

uint64_t CIGVNodeSetShape(void *a1, const char *a2)
{
  return [a1 setShape:a2];
}

uint64_t CIGVNodeSetColor(void *a1, const char *a2)
{
  return [a1 setColor:a2];
}

uint64_t CIGVNodeSetTitle(void *a1, const char *a2)
{
  return [a1 setTitle:a2];
}

uint64_t CIGVNodeSetLabel(void *a1, const char *a2)
{
  return [a1 setLabel:a2];
}

uint64_t CIGVNodeAddImage(void *a1, const char *a2)
{
  return [a1 addImage:a2];
}

PDFRenderer *CIGVRendererCreatePDFRenderer()
{
  return objc_alloc_init(PDFRenderer);
}

PNGRenderer *CIGVRendererCreatePNGRenderer()
{
  return objc_alloc_init(PNGRenderer);
}

uint64_t CIGVRendererSetOutputFileURL(void *a1, uint64_t a2)
{
  if (a2) {
    uint64_t v3 = objc_msgSend(MEMORY[0x1E4F1CB10], "fileURLWithPath:", objc_msgSend(NSString, "stringWithUTF8String:", a2));
  }
  else {
    uint64_t v3 = 0;
  }

  return [a1 setFileURL:v3];
}

uint64_t CIGVRendererSetOutputFileTitle(void *a1, uint64_t a2)
{
  uint64_t v3 = [NSString stringWithUTF8String:a2];

  return [a1 setFileTitle:v3];
}

void CIGVDumpToFile(void *a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  if (a2 >= 3) {
    CIGVDumpToFile_cold_1();
  }
  id v7 = objc_alloc_init(*off_1E5771DC8[a2]);
  if (v7)
  {
    float v8 = v7;
    int32x2_t v9 = objc_msgSend(NSString, "stringWithFormat:", @"%s/%s", a3, a4);
    objc_msgSend(v8, "setFileTitle:", objc_msgSend(NSString, "stringWithUTF8String:", "CI Render Graph"));
    uint64_t v10 = [v9 UTF8String];
    if (v10) {
      uint64_t v10 = objc_msgSend(MEMORY[0x1E4F1CB10], "fileURLWithPath:", objc_msgSend(NSString, "stringWithUTF8String:", v10));
    }
    [v8 setFileURL:v10];
    [a1 render:v8];
    [v8 flushRender];
    CFRelease(v8);
  }
}

double cikernel::_boxFilter3(cikernel *this, SamplerObj *a2)
{
  float32x2_t v3 = *(float32x2_t *)CI::getDC(this);
  float32x2_t v4 = vadd_f32(v3, (float32x2_t)0x3F000000BF000000);
  *(float *)&double v5 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v4, 1), *((float *)this + 4), v4.f32[0]);
  LODWORD(v6) = *((_DWORD *)this + 7);
  v7.i32[0] = *((_DWORD *)this + 9);
  *(float *)v8.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v4, 1), *(float *)&v6, v4.f32[0]);
  v4.f32[0] = *((float *)this + 6) + *(float *)&v5;
  *(float *)v9.f64 = *(float *)v7.i32 + *(float *)v8.i32;
  v4.f32[1] = *(float *)v7.i32 + *(float *)v8.i32;
  *(double *)v11.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v4, v9, v5, v6, v8, v7, v10);
  float32x2_t v12 = vadd_f32(v3, (float32x2_t)0x3F0000003F800000);
  *(float *)&double v13 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v12, 1), *((float *)this + 4), v12.f32[0]);
  LODWORD(v14) = *((_DWORD *)this + 6);
  v15.i32[0] = *((_DWORD *)this + 7);
  v16.i32[0] = *((_DWORD *)this + 9);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v12, 1), *(float *)v15.i32, v12.f32[0]);
  float32x4_t v18 = (float32x4_t)vdupq_n_s32(0x3EE38E39u);
  float32x4_t v40 = vmulq_f32(v11, v18);
  v11.f32[0] = *(float *)&v14 + *(float *)&v13;
  v18.f32[0] = *(float *)v16.i32 + *(float *)v17.i32;
  v11.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v11.i64, (float64x2_t)v18, v14, v13, v15, v17, v16);
  float32x2_t v20 = vadd_f32(v3, (float32x2_t)0xBF800000BF000000);
  *(float *)&double v21 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v20, 1), *((float *)this + 4), v20.f32[0]);
  LODWORD(v22) = *((_DWORD *)this + 6);
  v23.i32[0] = *((_DWORD *)this + 7);
  v24.i32[0] = *((_DWORD *)this + 9);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v20, 1), *(float *)v23.i32, v20.f32[0]);
  float32x4_t v26 = (float32x4_t)vdupq_n_s32(0x3E638E39u);
  float32x4_t v37 = v26;
  float32x4_t v39 = vmulq_f32(v19, v26);
  v19.f32[0] = *(float *)&v22 + *(float *)&v21;
  v26.f32[0] = *(float *)v24.i32 + *(float *)v25.i32;
  v19.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
  *(double *)v27.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v19.i64, (float64x2_t)v26, v22, v21, v23, v25, v24);
  float32x2_t v28 = vadd_f32(v3, (float32x2_t)0xBF8000003F800000);
  *(float *)&double v29 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v28, 1), *((float *)this + 4), v28.f32[0]);
  LODWORD(v30) = *((_DWORD *)this + 6);
  v31.i32[0] = *((_DWORD *)this + 7);
  v32.i32[0] = *((_DWORD *)this + 9);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v28, 1), *(float *)v31.i32, v28.f32[0]);
  float64x2_t v34 = (float64x2_t)v37;
  float32x4_t v38 = vmulq_f32(v27, v37);
  v27.f32[0] = *(float *)&v30 + *(float *)&v29;
  *(float *)v34.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v27.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)v35.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v27.i64, v34, v30, v29, v31, v33, v32);
  *(void *)&double result = vaddq_f32(vaddq_f32(vaddq_f32(v40, v39), v38), vmulq_f32(v35, (float32x4_t)vdupq_n_s32(0x3DE38E39u))).u64[0];
  return result;
}

double cikernel::_multiplyImages(float32x4_t a1, float32x4_t a2)
{
  *(void *)&double result = vmulq_f32(a1, a2).u64[0];
  return result;
}

double cikernel::_subtractImages(float32x4_t a1, float32x4_t a2)
{
  *(void *)&double result = vsubq_f32(a1, a2).u64[0];
  return result;
}

double cikernel::_computeAB(int8x16_t a1, int8x16_t a2, int8x16_t a3, double a4, double a5)
{
  *(float *)&a4 = *(float *)a1.i32 + *(float *)&a5;
  float v28 = *(float *)a1.i32 + *(float *)&a5;
  int32x4_t v5 = (int32x4_t)vextq_s8(a2, a2, 8uLL);
  *(float32x2_t *)v5.i8 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)a2.i8, *(int32x2_t *)v5.i8), (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a5, 0));
  float32x4_t v26 = (float32x4_t)vextq_s8((int8x16_t)vzip1q_s32((int32x4_t)a2, v5), a2, 4uLL);
  int8x8_t v6 = *(int8x8_t *)a1.i8;
  int32x4_t v7 = (int32x4_t)vextq_s8(a1, a1, 8uLL);
  *(float32x2_t *)v7.i8 = vdiv_f32((float32x2_t)vext_s8(v6, *(int8x8_t *)v7.i8, 4uLL), (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a4, 0));
  float32x2_t v29 = *(float32x2_t *)v7.i8;
  *(double *)_Q0.i64 = vec2::get_xxy((vec2 *)&v29, v7);
  _Q5 = a1;
  _Q0.i64[0] = vsubq_f32(v26, vmulq_f32((float32x4_t)vzip2q_s32((int32x4_t)vextq_s8(a1, a1, 0xCuLL), (int32x4_t)a1), _Q0)).u64[0];
  _S1 = vsub_f32((float32x2_t)vext_s8(*(int8x8_t *)a3.i8, (int8x8_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), 4uLL), vmul_n_f32(v29, *(float *)a3.i32)).u32[0];
  _S2 = _Q0.i32[1];
  _S3 = _Q0.f32[1] / _Q0.f32[0];
  __asm
  {
    FMLS            S4, S2, V3.S[0]
    FMLS            S2, S1, V3.S[0]
  }
  _S2 = _S2 / _S4;
  __asm { FMLS            S1, S2, V0.S[1] }
  _Q0.f32[0] = _S1 / _Q0.f32[0];
  __asm
  {
    FMLS            S1, S0, V5.S[1]
    FMLS            S1, S2, V5.S[2]
  }
  *(float *)&double v23 = _S1 / v28;
  HIDWORD(v23) = _Q0.i32[0];
  return v23;
}

double cikernel::_finalResult(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2 = vmulq_f32(a1, a2);
  *(void *)&double result = vdupq_lane_s32((int32x2_t)*(_OWORD *)&vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)a1, 3), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v2, 2), vaddq_f32(v2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v2.f32, 1)))), 0).u64[0];
  return result;
}

double cikernel::_swizzleXXX1(int32x2_t a1)
{
  *(void *)&double result = vdupq_lane_s32(a1, 0).u64[0];
  return result;
}

float cikernel::_swizzleYYZ1(double a1)
{
  return *((float *)&a1 + 1);
}

double cikernel::_swizzleYZZ1(int8x16_t a1)
{
  *(void *)&double result = vzip2q_s32((int32x4_t)vextq_s8(a1, a1, 0xCuLL), (int32x4_t)a1).u64[0];
  return result;
}

__n128 cikernel::_dotscreen(CI *a1, float32x4_t a2, float32x4_t a3, int8x16_t a4)
{
  float32x2_t v4 = vsub_f32(*(float32x2_t *)CI::getDC(a1), *(float32x2_t *)a3.f32);
  int32x2_t v5 = (int32x2_t)vmul_f32(*(float32x2_t *)a4.i8, v4);
  int32x2_t v6 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v4);
  float32x2_t v7 = vadd_f32(*(float32x2_t *)a3.f32, vadd_f32((float32x2_t)vzip1_s32(v5, v6), (float32x2_t)vzip2_s32(v5, v6)));
  float32x2_t v8 = vmul_f32(vminnm_f32(vsub_f32(v7, vrndm_f32(v7)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)), (float32x2_t)vdup_n_s32(0x40C90FDBu));
  a4.i32[1] = v8.i32[1];
  float v9 = sinf(v8.f32[0]);
  result.n128_f32[0] = sinf(*(float *)&a4.i32[1]);
  float32x4_t v10 = vmulq_f32(a2, (float32x4_t)xmmword_193950A90);
  result.n128_f32[0] = (float)(v9 + result.n128_f32[0]) * 0.25 * (-1.0 / a3.f32[2] + 0.995) + 0.5;
  result.n128_f32[0] = vmuls_lane_f32(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2), vaddq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1))).f32[0]- result.n128_f32[0], a3, 2)+ 0.5;
  float v12 = 1.0;
  if (result.n128_f32[0] <= 1.0) {
    float v12 = result.n128_f32[0];
  }
  BOOL v13 = result.n128_f32[0] < 0.0;
  int32x2_t v14 = 0;
  if (!v13) {
    *(float *)v14.i32 = v12;
  }
  *(float *)v14.i32 = vmuls_lane_f32(*(float *)v14.i32, a2, 3);
  result.n128_u64[0] = vdupq_lane_s32(v14, 0).u64[0];
  result.n128_u32[3] = a2.u32[3];
  return result;
}

void CI::f4_s_f3_f4(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  float32x4_t v11 = (double (*)(void *, __n128, __n128, __n128))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  uint64_t v14 = *(void *)(v10 + 32);
  int v15 = *(_DWORD *)(v10 + 64);
  uint64_t v16 = *(void *)(v10 + 56);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 80)), a2);
  }
  int8x16_t v17 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5) {
    int8x16_t v17 = (__n128 *)((char *)a2 + 64 * v16);
  }
  float32x4_t v18 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    float32x4_t v18 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v19 = v11(a1, *v18, *((__n128 *)a2 + 4 * v14), *v17);
  *(_OWORD *)(a3 + 16 * a7) = v19;
}

double cikernel::_hatchedscreen(CI *a1, float32x4_t a2, float32x4_t a3, int8x16_t a4)
{
  float32x2_t v4 = vsub_f32(*(float32x2_t *)CI::getDC(a1), *(float32x2_t *)a3.f32);
  int32x2_t v5 = (int32x2_t)vmul_f32(*(float32x2_t *)a4.i8, v4);
  int32x2_t v6 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v4);
  float32x2_t v7 = vadd_f32(*(float32x2_t *)a3.f32, vadd_f32((float32x2_t)vzip1_s32(v5, v6), (float32x2_t)vzip2_s32(v5, v6)));
  float32x2_t v8 = vminnm_f32(vsub_f32(v7, vrndm_f32(v7)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu));
  __asm { FMOV            V1.2S, #1.0 }
  float32x2_t v14 = vminnm_f32(vsub_f32(_D1, v8), v8);
  float32x2_t v15 = vadd_f32(v14, v14);
  _D1.f32[0] = v15.f32[1] * 0.5 + 0.5;
  v15.f32[0] = fminf(v15.f32[0], _D1.f32[0]);
  float32x4_t v16 = vmulq_f32(a2, (float32x4_t)xmmword_193950A90);
  float v17 = vmuls_lane_f32(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 2), vaddq_f32(v16, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v16.f32, 1))).f32[0]- v15.f32[0], a3, 2)+ 0.5;
  float v18 = 1.0;
  if (v17 <= 1.0) {
    float v18 = v17;
  }
  _NF = v17 < 0.0;
  int32x2_t v19 = 0;
  if (!_NF) {
    *(float *)v19.i32 = v18;
  }
  *(float *)v19.i32 = vmuls_lane_f32(*(float *)v19.i32, a2, 3);
  *(void *)&double result = vdupq_lane_s32(v19, 0).u64[0];
  return result;
}

double cikernel::_linescreen(CI *a1, float32x4_t a2, float32x4_t a3, int8x16_t a4)
{
  float32x2_t v4 = vsub_f32(*(float32x2_t *)CI::getDC(a1), *(float32x2_t *)a3.f32);
  int32x2_t v5 = (int32x2_t)vmul_f32(*(float32x2_t *)a4.i8, v4);
  int32x2_t v6 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v4);
  float32x2_t v7 = vadd_f32(*(float32x2_t *)a3.f32, vadd_f32((float32x2_t)vzip1_s32(v5, v6), (float32x2_t)vzip2_s32(v5, v6)));
  v7.f32[0] = vminnm_f32(vsub_f32(v7, vrndm_f32(v7)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)).f32[0];
  float v8 = 1.0;
  v7.f32[0] = fminf(1.0 - v7.f32[0], v7.f32[0]);
  float32x4_t v9 = vmulq_f32(a2, (float32x4_t)xmmword_193950A90);
  float v10 = vmuls_lane_f32(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2), vaddq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1))).f32[0]- (float)(v7.f32[0] + v7.f32[0]), a3, 2)+ 0.5;
  if (v10 <= 1.0) {
    float v8 = v10;
  }
  BOOL v11 = v10 < 0.0;
  int32x2_t v12 = 0;
  if (!v11) {
    *(float *)v12.i32 = v8;
  }
  *(float *)v12.i32 = vmuls_lane_f32(*(float *)v12.i32, a2, 3);
  *(void *)&double result = vdupq_lane_s32(v12, 0).u64[0];
  return result;
}

__n128 cikernel::_circularscreen(CI *a1, float32x4_t a2, float32x4_t a3)
{
  result.n128_u64[0] = (unint64_t)vsub_f32(*(float32x2_t *)CI::getDC(a1), *(float32x2_t *)a3.f32);
  result.n128_f32[0] = vmuls_lane_f32(sqrtf(vaddv_f32(vmul_f32((float32x2_t)result.n128_u64[0], (float32x2_t)result.n128_u64[0]))), a3, 2);
  result.n128_f32[0] = result.n128_f32[0] - floorf(result.n128_f32[0]);
  float v3 = 1.0;
  float32x4_t v4 = vmulq_f32(a2, (float32x4_t)xmmword_193950A90);
  result.n128_f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).f32[0]+ fminf(1.0 - result.n128_f32[0], result.n128_f32[0]) * -2.0;
  result.n128_f32[0] = vmuls_lane_f32(result.n128_f32[0], a3, 3) + 0.5;
  if (result.n128_f32[0] <= 1.0) {
    float v3 = result.n128_f32[0];
  }
  BOOL v6 = result.n128_f32[0] < 0.0;
  int32x2_t v7 = 0;
  if (!v6) {
    *(float *)v7.i32 = v3;
  }
  result.n128_u64[0] = vmulq_laneq_f32((float32x4_t)vdupq_lane_s32(v7, 0), a2, 3).u64[0];
  result.n128_u32[3] = a2.u32[3];
  return result;
}

float32x4_t cikernel::_highlightsAndShadows2(int32x4_t a1, float32x4_t a2, int32x4_t a3)
{
  float32x4_t v3 = (float32x4_t)a1;
  v3.i32[3] = 0;
  float32x4_t v62 = v3;
  float32x4_t v58 = vmaxnmq_f32(v3, (float32x4_t)0);
  float32x4_t v4 = vmulq_f32(v58, (float32x4_t)xmmword_1939538A0);
  long double v5 = pow(fminf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).f32[0]/ fmaxf(vaddq_f32((float32x4_t)vdupq_laneq_s32(a1, 2), vaddq_f32((float32x4_t)a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a1.i8, 1))).f32[0], 0.001), 1.0), 1.0 - *(float *)a3.i32)* *(float *)a3.i32;
  float v6 = v5;
  *(float *)&long double v5 = -v6;
  simd_float4 v7 = (simd_float4)vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v5, 0), a2);
  v7.i32[3] = 0;
  float32x4_t v8 = vaddq_f32((float32x4_t)vdupq_laneq_s32(a3, 2), vmulq_n_f32((float32x4_t)_simd_pow_f4((simd_float4)xmmword_1939538B0, v7), 1.0 - *(float *)&a3.i32[2]));
  float v56 = v8.f32[0];
  float v61 = fmaxf(fmaxf(fmaxf(a2.f32[0], a2.f32[1]), a2.f32[2]), 0.0);
  float v65 = sqrtf(v61);
  float v9 = (float)(*(float *)a3.i32 + -0.5) + (float)(*(float *)a3.i32 + -0.5);
  if (v9 <= 1.0) {
    float v10 = (float)(*(float *)a3.i32 + -0.5) + (float)(*(float *)a3.i32 + -0.5);
  }
  else {
    float v10 = 1.0;
  }
  if (v9 >= 0.0) {
    float v11 = v10;
  }
  else {
    float v11 = 0.0;
  }
  float v12 = (float)((float)(v11 * v11) * (float)((float)(v11 * -2.0) + 3.0)) * 0.5 + 0.5;
  float32x4_t v63 = vminnmq_f32(v62, (float32x4_t)0);
  float v55 = v12;
  simd_float4 v13 = (simd_float4)vmulq_n_f32(v58, v12);
  v13.i32[3] = 0;
  simd_float4 v14 = (simd_float4)v8;
  v14.i32[3] = 0;
  float32x4_t v15 = vmulq_n_f32((float32x4_t)_simd_pow_f4(v13, v14), v6 + 1.0);
  float32x4_t v59 = vaddq_f32(v15, v15);
  float32x4_t v54 = vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_1939538E0, (float32x4_t)a1, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_1939538D0, *(float32x2_t *)a1.i8, 1), vmulq_n_f32((float32x4_t)xmmword_1939538C0, *(float *)a1.i32)));
  float v16 = powf(fmaxf(v54.f32[0], 0.0) * v55, v56);
  float32x4_t v17 = vmlaq_f32(vmulq_f32(v59, (float32x4_t)vdupq_n_s32(0x3F266666u)), (float32x4_t)vdupq_n_s32(0x3EB33333u), vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_193953910, v54, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_193953900, *(float32x2_t *)v54.f32, 1), vmulq_n_f32((float32x4_t)xmmword_1939538F0, v16 + v16))));
  float v18 = v6 + 0.1;
  float v19 = sqrtf(v65) / v18;
  if (v19 <= 1.0) {
    float v20 = v19;
  }
  else {
    float v20 = 1.0;
  }
  if (v19 >= 0.0) {
    float v21 = v20;
  }
  else {
    float v21 = 0.0;
  }
  float32x4_t v60 = vmlaq_n_f32(vmulq_n_f32(vmlaq_n_f32(vmulq_n_f32((float32x4_t)a1, 1.0 - (float)((float)(v21 * v21) * (float)((float)(v21 * -2.0) + 3.0))), v17, (float)(v21 * v21) * (float)((float)(v21 * -2.0) + 3.0)), 1.0 - v65), (float32x4_t)a1, v65);
  v22.i64[0] = 0x8000000080000000;
  v22.i64[1] = 0x8000000080000000;
  __asm { FMOV            V1.4S, #1.0 }
  float32x4_t v57 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32((float32x4_t)a1), (int8x16_t)vcgtzq_f32((float32x4_t)a1)), vorrq_s8(vandq_s8((int8x16_t)a1, v22), _Q1), (int8x16_t)0);
  _Q1.i32[1] = a3.i32[1];
  simd_float4 v28 = (simd_float4)vmulq_laneq_f32(vabsq_f32((float32x4_t)a1), (float32x4_t)a3, 3);
  *(float *)_Q1.i32 = 2.0 - *(float *)&a3.i32[1];
  v28.i32[3] = 0;
  simd_float4 v29 = (simd_float4)vdupq_lane_s32(*(int32x2_t *)_Q1.i8, 0);
  v29.i32[3] = 0;
  float32x4_t v30 = vmulq_f32(v57, (float32x4_t)_simd_pow_f4(v28, v29));
  float32x4_t v31 = vmulq_f32(v30, (float32x4_t)xmmword_193950AB0);
  double v32 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v31, 2), vaddq_f32(v31, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v31.f32, 1))).f32[0];
  float v33 = v32 * -2.6 + v32 * -2.6 * v32 + 0.98;
  float v34 = v32 * -6.25 + v32 * -6.25 * v32 + 0.5965;
  float v35 = fmaxf(fmaxf(v33, v34), 1.0);
  float v36 = *(float *)&a3.i32[1] + 0.3;
  v37.i32[1] = 1071225241;
  float v38 = (1.0 - fminf(v36, 1.0)) * 0.4 + 1.0;
  *(float *)v37.i32 = (float)(1.0 - v38) * 0.25;
  float v39 = (1.0 - *(float *)&a3.i32[1]) * fminf(v35, v61 * 30.0);
  float32x4_t v40 = vmlaq_n_f32(vmulq_n_f32(v30, 1.0 - v39), vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v37, 0), v30, v38), v39);
  float v41 = (float)(v65 + -0.2) / 0.6;
  if (v41 <= 1.0) {
    float v42 = (float)(v65 + -0.2) / 0.6;
  }
  else {
    float v42 = 1.0;
  }
  if (v41 >= 0.0) {
    float v43 = v42;
  }
  else {
    float v43 = 0.0;
  }
  float32x4_t v44 = vmlaq_n_f32(vmulq_n_f32((float32x4_t)a1, 1.0 - (float)((float)(v43 * v43) * (float)((float)(v43 * -2.0) + 3.0))), v40, (float)(v43 * v43) * (float)((float)(v43 * -2.0) + 3.0));
  float v45 = fminf(v65, 1.0);
  float32x4_t v46 = vmlaq_n_f32(vmulq_n_f32(v60, 1.0 - v45), vmlaq_n_f32(vmulq_n_f32((float32x4_t)a1, 1.0 - v61), v44, v61), v45);
  float32x4_t v47 = vmulq_f32(v46, (float32x4_t)xmmword_193950AB0);
  *(double *)v47.i64 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v47, 2), vaddq_f32(v47, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v47.f32, 1))).f32[0];
  float v48 = *(double *)v47.i64 * -2.6 + *(double *)v47.i64 * -2.6 * *(double *)v47.i64 + 0.98;
  v47.f32[0] = *(double *)v47.i64 * -6.25 + *(double *)v47.i64 * -6.25 * *(double *)v47.i64 + 0.5965;
  v47.f32[0] = fmaxf(fmaxf(v48, v47.f32[0]), 1.0);
  double v49 = 1.0 - *(float *)&a3.i32[2];
  float v50 = v49 * (fabsf(v6) * 0.1);
  float v51 = v50 + 1.0;
  *(float *)&double v49 = (float)(1.0 - v51) * 0.5;
  v47.f32[0] = fminf(v47.f32[0], v61 * 30.0);
  float32x4_t v52 = vmlaq_n_f32(vmulq_n_f32(v46, 1.0 - v47.f32[0]), vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v49, 0), v46, v51), v47.f32[0]);
  v52.i32[3] = 0;
  float32x4_t result = vmaxnmq_f32(v52, (float32x4_t)0);
  result.i64[0] = vaddq_f32(v63, result).u64[0];
  result.i32[3] = a1.i32[3];
  return result;
}

void CI::f4_s_s_f4(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  float v11 = (double (*)(void *, __n128, __n128, __n128))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  int v14 = *(_DWORD *)(v10 + 40);
  uint64_t v15 = *(void *)(v10 + 32);
  int v16 = *(_DWORD *)(v10 + 64);
  uint64_t v17 = *(void *)(v10 + 56);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 80)), a2);
  }
  float v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5) {
    float v18 = (__n128 *)((char *)a2 + 64 * v17);
  }
  float v19 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5) {
    float v19 = (__n128 *)((char *)a2 + 64 * v15);
  }
  float v20 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    float v20 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v21 = v11(a1, *v20, *v19, *v18);
  *(_OWORD *)(a3 + 16 * a7) = v21;
}

float32x4_t cikernel::_highlightsAndShadows_noblur2(float32x4_t a1, int32x4_t a2)
{
  float32x4_t v2 = a1;
  v2.i32[3] = 0;
  float32x4_t v67 = v2;
  float32x4_t v63 = vmaxnmq_f32(v2, (float32x4_t)0);
  float32x4_t v3 = vmulq_f32(v63, (float32x4_t)xmmword_1939538A0);
  float v4 = a1.f32[1];
  float v5 = a1.f32[2];
  long double v6 = pow(fminf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))).f32[0]/ fmaxf(a1.f32[2] + vaddv_f32(*(float32x2_t *)a1.f32), 0.001), 1.0), 1.0 - *(float *)a2.i32)* *(float *)a2.i32;
  float v7 = v6;
  *(float *)&long double v6 = -v7;
  simd_float4 v8 = (simd_float4)vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v6, 0), a1);
  v8.i32[3] = 0;
  float32x4_t v9 = vaddq_f32((float32x4_t)vdupq_laneq_s32(a2, 2), vmulq_n_f32((float32x4_t)_simd_pow_f4((simd_float4)xmmword_1939538B0, v8), 1.0 - *(float *)&a2.i32[2]));
  float v61 = v9.f32[0];
  float v66 = fmaxf(fmaxf(fmaxf(a1.f32[0], v4), v5), 0.0);
  float v69 = sqrtf(v66);
  float v10 = (float)(*(float *)a2.i32 + -0.5) + (float)(*(float *)a2.i32 + -0.5);
  float v11 = 1.0;
  if (v10 <= 1.0) {
    float v11 = (float)(*(float *)a2.i32 + -0.5) + (float)(*(float *)a2.i32 + -0.5);
  }
  if (v10 >= 0.0) {
    float v12 = v11;
  }
  else {
    float v12 = 0.0;
  }
  float v13 = (float)((float)(v12 * v12) * (float)((float)(v12 * -2.0) + 3.0)) * 0.5 + 0.5;
  float32x4_t v68 = vminnmq_f32(v67, (float32x4_t)0);
  float v60 = v13;
  simd_float4 v14 = (simd_float4)vmulq_n_f32(v63, v13);
  v14.i32[3] = 0;
  simd_float4 v15 = (simd_float4)v9;
  v15.i32[3] = 0;
  float32x4_t v16 = vmulq_n_f32((float32x4_t)_simd_pow_f4(v14, v15), v7 + 1.0);
  float32x4_t v64 = vaddq_f32(v16, v16);
  float32x4_t v17 = vmulq_laneq_f32((float32x4_t)xmmword_1939538E0, a1, 2);
  int8x16_t v18 = (int8x16_t)vaddq_f32(v17, vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_1939538D0, *(float32x2_t *)a1.f32, 1), vmulq_n_f32((float32x4_t)xmmword_1939538C0, a1.f32[0])));
  float32x4_t v59 = (float32x4_t)v18;
  v16.i64[0] = 0x8000000080000000;
  v16.i64[1] = 0x8000000080000000;
  v17.i32[0] = 1.0;
  LODWORD(v19) = vbslq_s8((int8x16_t)v16, (int8x16_t)v17, v18).u32[0];
  if (*(float *)v18.i32 == 0.0) {
    float v19 = 0.0;
  }
  float v20 = v19;
  float v21 = powf(fabsf(*(float *)v18.i32) * v60, v61);
  float32x4_t v22 = vmlaq_f32(vmulq_f32(v64, (float32x4_t)vdupq_n_s32(0x3F266666u)), (float32x4_t)vdupq_n_s32(0x3EB33333u), vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_193953910, v59, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_193953900, *(float32x2_t *)v59.f32, 1), vmulq_n_f32((float32x4_t)xmmword_1939538F0, (float)(v20 * v21) + (float)(v20 * v21)))));
  float v23 = v7 + 0.1;
  float v24 = sqrtf(v69) / v23;
  if (v24 <= 1.0) {
    float v25 = v24;
  }
  else {
    float v25 = 1.0;
  }
  if (v24 >= 0.0) {
    float v26 = v25;
  }
  else {
    float v26 = 0.0;
  }
  float32x4_t v65 = vmlaq_n_f32(vmulq_n_f32(vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - (float)((float)(v26 * v26) * (float)((float)(v26 * -2.0) + 3.0))), v22, (float)(v26 * v26) * (float)((float)(v26 * -2.0) + 3.0)), 1.0 - v69), a1, v69);
  v27.i64[0] = 0x8000000080000000;
  v27.i64[1] = 0x8000000080000000;
  __asm { FMOV            V1.4S, #1.0 }
  float32x4_t v62 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a1), (int8x16_t)vcgtzq_f32(a1)), vorrq_s8(vandq_s8((int8x16_t)a1, v27), _Q1), (int8x16_t)0);
  _Q1.i32[1] = a2.i32[1];
  simd_float4 v33 = (simd_float4)vmulq_laneq_f32(vabsq_f32(a1), (float32x4_t)a2, 3);
  *(float *)_Q1.i32 = 2.0 - *(float *)&a2.i32[1];
  v33.i32[3] = 0;
  simd_float4 v34 = (simd_float4)vdupq_lane_s32(*(int32x2_t *)_Q1.i8, 0);
  v34.i32[3] = 0;
  float32x4_t v35 = vmulq_f32(v62, (float32x4_t)_simd_pow_f4(v33, v34));
  float32x4_t v36 = vmulq_f32(v35, (float32x4_t)xmmword_193950AB0);
  double v37 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v36, 2), vaddq_f32(v36, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 1))).f32[0];
  float v38 = v37 * -2.6 + v37 * -2.6 * v37 + 0.98;
  float v39 = v37 * -6.25 + v37 * -6.25 * v37 + 0.5965;
  float v40 = fmaxf(fmaxf(v38, v39), 1.0);
  float v41 = *(float *)&a2.i32[1] + 0.3;
  v42.i32[1] = 1071225241;
  float v43 = (1.0 - fminf(v41, 1.0)) * 0.4 + 1.0;
  *(float *)v42.i32 = (float)(1.0 - v43) * 0.25;
  float v44 = (1.0 - *(float *)&a2.i32[1]) * fminf(v40, v66 * 30.0);
  float32x4_t v45 = vmlaq_n_f32(vmulq_n_f32(v35, 1.0 - v44), vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v42, 0), v35, v43), v44);
  float v46 = (float)(v69 + -0.2) / 0.6;
  if (v46 <= 1.0) {
    float v47 = (float)(v69 + -0.2) / 0.6;
  }
  else {
    float v47 = 1.0;
  }
  if (v46 >= 0.0) {
    float v48 = v47;
  }
  else {
    float v48 = 0.0;
  }
  float32x4_t v49 = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - v66), vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - (float)((float)(v48 * v48) * (float)((float)(v48 * -2.0) + 3.0))), v45, (float)(v48 * v48) * (float)((float)(v48 * -2.0) + 3.0)), v66);
  float v50 = fminf(v69, 1.0);
  float32x4_t v51 = vmlaq_n_f32(vmulq_n_f32(v65, 1.0 - v50), v49, v50);
  float32x4_t v52 = vmulq_f32(v51, (float32x4_t)xmmword_193950AB0);
  *(double *)v52.i64 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 2), vaddq_f32(v52, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v52.f32, 1))).f32[0];
  float v53 = *(double *)v52.i64 * -2.6 + *(double *)v52.i64 * -2.6 * *(double *)v52.i64 + 0.98;
  v52.f32[0] = *(double *)v52.i64 * -6.25 + *(double *)v52.i64 * -6.25 * *(double *)v52.i64 + 0.5965;
  v52.f32[0] = fmaxf(fmaxf(v53, v52.f32[0]), 1.0);
  double v54 = 1.0 - *(float *)&a2.i32[2];
  float v55 = v54 * (fabsf(v7) * 0.1);
  float v56 = v55 + 1.0;
  *(float *)&double v54 = (float)(1.0 - v56) * 0.5;
  v52.f32[0] = fminf(v52.f32[0], v66 * 30.0);
  float32x4_t v57 = vmlaq_n_f32(vmulq_n_f32(v51, 1.0 - v52.f32[0]), vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v54, 0), v51, v56), v52.f32[0]);
  v57.i32[3] = 0;
  float32x4_t result = vmaxnmq_f32(v57, (float32x4_t)0);
  result.i64[0] = vaddq_f32(v68, result).u64[0];
  result.i32[3] = a1.i32[3];
  return result;
}

float32x4_t cikernel::_highlightsAndShadows1(int32x4_t a1, float32x4_t a2, int32x4_t a3)
{
  float32x4_t v3 = (float32x4_t)a1;
  v3.i32[3] = 0;
  float32x4_t v4 = vmulq_f32(vmaxnmq_f32(v3, (float32x4_t)0), (float32x4_t)xmmword_1939538A0);
  long double v5 = pow(fminf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).f32[0]/ fmaxf(vaddq_f32((float32x4_t)vdupq_laneq_s32(a1, 2), vaddq_f32((float32x4_t)a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a1.i8, 1))).f32[0], 0.001), 1.0), 1.0 - *(float *)a3.i32)* *(float *)a3.i32;
  float v6 = v5;
  *(float *)&long double v5 = -v6;
  simd_float4 v7 = (simd_float4)vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v5, 0), a2);
  v7.i32[3] = 0;
  float32x4_t v8 = vaddq_f32((float32x4_t)vdupq_laneq_s32(a3, 2), vmulq_n_f32((float32x4_t)_simd_pow_f4((simd_float4)xmmword_1939538B0, v7), 1.0 - *(float *)&a3.i32[2]));
  float v61 = v8.f32[0];
  float v66 = fmaxf(fmaxf(fmaxf(a2.f32[0], a2.f32[1]), a2.f32[2]), 0.0);
  float v67 = sqrtf(v66);
  float v9 = (float)(*(float *)a3.i32 + -0.5) + (float)(*(float *)a3.i32 + -0.5);
  float v10 = 1.0;
  if (v9 <= 1.0) {
    float v10 = (float)(*(float *)a3.i32 + -0.5) + (float)(*(float *)a3.i32 + -0.5);
  }
  if (v9 >= 0.0) {
    float v11 = v10;
  }
  else {
    float v11 = 0.0;
  }
  float v12 = (float)((float)(v11 * v11) * (float)((float)(v11 * -2.0) + 3.0)) * 0.5 + 0.5;
  float v62 = v12;
  v13.i64[0] = 0x8000000080000000;
  v13.i64[1] = 0x8000000080000000;
  __asm { FMOV            V1.4S, #1.0 }
  float32x4_t v69 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32((float32x4_t)a1), (int8x16_t)vcgtzq_f32((float32x4_t)a1)), vorrq_s8(vandq_s8((int8x16_t)a1, v13), _Q1), (int8x16_t)0);
  float32x4_t v63 = vabsq_f32((float32x4_t)a1);
  simd_float4 v19 = (simd_float4)vmulq_n_f32(v63, v12);
  v19.i32[3] = 0;
  simd_float4 v20 = (simd_float4)v8;
  v20.i32[3] = 0;
  float32x4_t v21 = vmulq_f32(v69, (float32x4_t)_simd_pow_f4(v19, v20));
  float32x4_t v64 = vaddq_f32(v21, v21);
  float32x4_t v22 = vmulq_laneq_f32((float32x4_t)xmmword_1939538E0, (float32x4_t)a1, 2);
  int8x16_t v23 = (int8x16_t)vaddq_f32(v22, vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_1939538D0, *(float32x2_t *)a1.i8, 1), vmulq_n_f32((float32x4_t)xmmword_1939538C0, *(float *)a1.i32)));
  float32x4_t v60 = (float32x4_t)v23;
  v21.i64[0] = 0x8000000080000000;
  v21.i64[1] = 0x8000000080000000;
  v22.i32[0] = 1.0;
  LODWORD(v24) = vbslq_s8((int8x16_t)v21, (int8x16_t)v22, v23).u32[0];
  if (*(float *)v23.i32 == 0.0) {
    float v24 = 0.0;
  }
  float v25 = v24;
  float v26 = powf(fabsf(*(float *)v23.i32) * v62, v61);
  float32x4_t v27 = vmlaq_f32(vmulq_f32(v64, (float32x4_t)vdupq_n_s32(0x3F266666u)), (float32x4_t)vdupq_n_s32(0x3EB33333u), vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_193953910, v60, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_193953900, *(float32x2_t *)v60.f32, 1), vmulq_n_f32((float32x4_t)xmmword_1939538F0, (float)(v25 * v26) + (float)(v25 * v26)))));
  float v28 = v6 + 0.1;
  float v29 = sqrtf(v67) / v28;
  if (v29 <= 1.0) {
    float v30 = v29;
  }
  else {
    float v30 = 1.0;
  }
  if (v29 >= 0.0) {
    float v31 = v30;
  }
  else {
    float v31 = 0.0;
  }
  float v32 = sqrtf((float)(v31 * v31) * (float)((float)(v31 * -2.0) + 3.0));
  float32x4_t v65 = vmlaq_n_f32(vmulq_n_f32(vmlaq_n_f32(vmulq_n_f32((float32x4_t)a1, 1.0 - v32), v27, v32), 1.0 - v67), (float32x4_t)a1, v67);
  v33.i32[1] = a3.i32[1];
  simd_float4 v34 = (simd_float4)vmulq_laneq_f32(v63, (float32x4_t)a3, 3);
  *(float *)v33.i32 = 2.0 - *(float *)&a3.i32[1];
  v34.i32[3] = 0;
  simd_float4 v35 = (simd_float4)vdupq_lane_s32(v33, 0);
  v35.i32[3] = 0;
  float32x4_t v36 = vmulq_f32(v69, (float32x4_t)_simd_pow_f4(v34, v35));
  float32x4_t v37 = vmulq_f32(v36, (float32x4_t)xmmword_193950AB0);
  double v38 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v37, 2), vaddq_f32(v37, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.f32, 1))).f32[0];
  float v39 = v38 * -2.6 + v38 * -2.6 * v38 + 0.98;
  float v40 = v38 * -6.25 + v38 * -6.25 * v38 + 0.5965;
  float v41 = fmaxf(fmaxf(v39, v40), 1.0);
  float v42 = *(float *)&a3.i32[1] + 0.3;
  v43.i32[1] = 1071225241;
  float v44 = (1.0 - fminf(v42, 1.0)) * 0.4 + 1.0;
  *(float *)v43.i32 = (float)(1.0 - v44) * 0.25;
  float v45 = (1.0 - *(float *)&a3.i32[1]) * fminf(v41, v66 * 30.0);
  float32x4_t v46 = vmlaq_n_f32(vmulq_n_f32(v36, 1.0 - v45), vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v43, 0), v36, v44), v45);
  float v47 = (float)(v67 + -0.2) / 0.6;
  if (v47 <= 1.0) {
    float v48 = (float)(v67 + -0.2) / 0.6;
  }
  else {
    float v48 = 1.0;
  }
  if (v47 >= 0.0) {
    float v49 = v48;
  }
  else {
    float v49 = 0.0;
  }
  float32x4_t v50 = vmlaq_n_f32(vmulq_n_f32((float32x4_t)a1, 1.0 - v66), vmlaq_n_f32(vmulq_n_f32((float32x4_t)a1, 1.0 - (float)((float)(v49 * v49) * (float)((float)(v49 * -2.0) + 3.0))), v46, (float)(v49 * v49) * (float)((float)(v49 * -2.0) + 3.0)), v66);
  float v51 = fminf(v67, 1.0);
  float32x4_t v52 = vmlaq_n_f32(vmulq_n_f32(v65, 1.0 - v51), v50, v51);
  float32x4_t result = vmulq_f32(v52, (float32x4_t)xmmword_193950AB0);
  *(double *)result.i64 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)result, 2), vaddq_f32(result, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)result.f32, 1))).f32[0];
  float v53 = *(double *)result.i64 * -2.6 + *(double *)result.i64 * -2.6 * *(double *)result.i64 + 0.98;
  result.f32[0] = *(double *)result.i64 * -6.25 + *(double *)result.i64 * -6.25 * *(double *)result.i64 + 0.5965;
  result.f32[0] = fmaxf(fmaxf(v53, result.f32[0]), 1.0);
  double v54 = 1.0 - *(float *)&a3.i32[2];
  float v55 = v54 * (fabsf(v6) * 0.1);
  float v56 = v55 + 1.0;
  *(float *)&double v54 = (float)(1.0 - v56) * 0.5;
  float32x4_t v57 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v54, 0), v52, v56);
  float v58 = fminf(result.f32[0], v66 * 30.0);
  result.i64[0] = vmlaq_n_f32(vmulq_n_f32(v52, 1.0 - v58), v57, v58).u64[0];
  result.i32[3] = a1.i32[3];
  return result;
}

float32x4_t cikernel::_highlightsAndShadows_noblur1(float32x4_t a1, int32x4_t a2)
{
  float32x4_t v2 = a1;
  v2.i32[3] = 0;
  float32x4_t v3 = vmulq_f32(vmaxnmq_f32(v2, (float32x4_t)0), (float32x4_t)xmmword_1939538A0);
  float v4 = a1.f32[1];
  float v5 = a1.f32[2];
  long double v6 = pow(fminf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))).f32[0]/ fmaxf(a1.f32[2] + vaddv_f32(*(float32x2_t *)a1.f32), 0.001), 1.0), 1.0 - *(float *)a2.i32)* *(float *)a2.i32;
  float v7 = v6;
  *(float *)&long double v6 = -v7;
  simd_float4 v8 = (simd_float4)vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v6, 0), a1);
  v8.i32[3] = 0;
  float32x4_t v9 = vaddq_f32((float32x4_t)vdupq_laneq_s32(a2, 2), vmulq_n_f32((float32x4_t)_simd_pow_f4((simd_float4)xmmword_1939538B0, v8), 1.0 - *(float *)&a2.i32[2]));
  float v62 = v9.f32[0];
  float v67 = fmaxf(fmaxf(fmaxf(a1.f32[0], v4), v5), 0.0);
  float v68 = sqrtf(v67);
  float v10 = (float)(*(float *)a2.i32 + -0.5) + (float)(*(float *)a2.i32 + -0.5);
  float v11 = 1.0;
  if (v10 <= 1.0) {
    float v11 = (float)(*(float *)a2.i32 + -0.5) + (float)(*(float *)a2.i32 + -0.5);
  }
  if (v10 >= 0.0) {
    float v12 = v11;
  }
  else {
    float v12 = 0.0;
  }
  float v13 = (float)((float)(v12 * v12) * (float)((float)(v12 * -2.0) + 3.0)) * 0.5 + 0.5;
  v14.i64[0] = 0x8000000080000000;
  v14.i64[1] = 0x8000000080000000;
  __asm { FMOV            V1.4S, #1.0 }
  float32x4_t v69 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a1), (int8x16_t)vcgtzq_f32(a1)), vorrq_s8(vandq_s8((int8x16_t)a1, v14), _Q1), (int8x16_t)0);
  float v63 = v13;
  float32x4_t v64 = vabsq_f32(a1);
  simd_float4 v20 = (simd_float4)vmulq_n_f32(v64, v13);
  v20.i32[3] = 0;
  simd_float4 v21 = (simd_float4)v9;
  v21.i32[3] = 0;
  float32x4_t v22 = vmulq_f32(v69, (float32x4_t)_simd_pow_f4(v20, v21));
  float32x4_t v65 = vaddq_f32(v22, v22);
  float32x4_t v23 = vmulq_laneq_f32((float32x4_t)xmmword_1939538E0, a1, 2);
  int8x16_t v24 = (int8x16_t)vaddq_f32(v23, vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_1939538D0, *(float32x2_t *)a1.f32, 1), vmulq_n_f32((float32x4_t)xmmword_1939538C0, a1.f32[0])));
  float32x4_t v61 = (float32x4_t)v24;
  v22.i64[0] = 0x8000000080000000;
  v22.i64[1] = 0x8000000080000000;
  v23.i32[0] = 1.0;
  LODWORD(v25) = vbslq_s8((int8x16_t)v22, (int8x16_t)v23, v24).u32[0];
  if (*(float *)v24.i32 == 0.0) {
    float v25 = 0.0;
  }
  float v26 = v25;
  float v27 = powf(fabsf(*(float *)v24.i32) * v63, v62);
  float32x4_t v28 = vmlaq_f32(vmulq_f32(v65, (float32x4_t)vdupq_n_s32(0x3F266666u)), (float32x4_t)vdupq_n_s32(0x3EB33333u), vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_193953910, v61, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_193953900, *(float32x2_t *)v61.f32, 1), vmulq_n_f32((float32x4_t)xmmword_1939538F0, (float)(v26 * v27) + (float)(v26 * v27)))));
  float v29 = v7 + 0.1;
  float v30 = sqrtf(v68) / v29;
  if (v30 <= 1.0) {
    float v31 = v30;
  }
  else {
    float v31 = 1.0;
  }
  if (v30 >= 0.0) {
    float v32 = v31;
  }
  else {
    float v32 = 0.0;
  }
  float v33 = sqrtf((float)(v32 * v32) * (float)((float)(v32 * -2.0) + 3.0));
  float32x4_t v66 = vmlaq_n_f32(vmulq_n_f32(vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - v33), v28, v33), 1.0 - v68), a1, v68);
  v34.i32[1] = a2.i32[1];
  simd_float4 v35 = (simd_float4)vmulq_laneq_f32(v64, (float32x4_t)a2, 3);
  *(float *)v34.i32 = 2.0 - *(float *)&a2.i32[1];
  v35.i32[3] = 0;
  simd_float4 v36 = (simd_float4)vdupq_lane_s32(v34, 0);
  v36.i32[3] = 0;
  float32x4_t v37 = vmulq_f32(v69, (float32x4_t)_simd_pow_f4(v35, v36));
  float32x4_t v38 = vmulq_f32(v37, (float32x4_t)xmmword_193950AB0);
  double v39 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v38, 2), vaddq_f32(v38, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v38.f32, 1))).f32[0];
  float v40 = v39 * -2.6 + v39 * -2.6 * v39 + 0.98;
  float v41 = v39 * -6.25 + v39 * -6.25 * v39 + 0.5965;
  float v42 = fmaxf(fmaxf(v40, v41), 1.0);
  float v43 = *(float *)&a2.i32[1] + 0.3;
  v44.i32[1] = 1071225241;
  float v45 = (1.0 - fminf(v43, 1.0)) * 0.4 + 1.0;
  *(float *)v44.i32 = (float)(1.0 - v45) * 0.25;
  float v46 = (1.0 - *(float *)&a2.i32[1]) * fminf(v42, v67 * 30.0);
  float32x4_t v47 = vmlaq_n_f32(vmulq_n_f32(v37, 1.0 - v46), vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v44, 0), v37, v45), v46);
  float v48 = (float)(v68 + -0.2) / 0.6;
  if (v48 <= 1.0) {
    float v49 = (float)(v68 + -0.2) / 0.6;
  }
  else {
    float v49 = 1.0;
  }
  if (v48 >= 0.0) {
    float v50 = v49;
  }
  else {
    float v50 = 0.0;
  }
  float32x4_t v51 = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - v67), vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - (float)((float)(v50 * v50) * (float)((float)(v50 * -2.0) + 3.0))), v47, (float)(v50 * v50) * (float)((float)(v50 * -2.0) + 3.0)), v67);
  float v52 = fminf(v68, 1.0);
  float32x4_t v53 = vmlaq_n_f32(vmulq_n_f32(v66, 1.0 - v52), v51, v52);
  float32x4_t result = vmulq_f32(v53, (float32x4_t)xmmword_193950AB0);
  *(double *)result.i64 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)result, 2), vaddq_f32(result, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)result.f32, 1))).f32[0];
  float v54 = *(double *)result.i64 * -2.6 + *(double *)result.i64 * -2.6 * *(double *)result.i64 + 0.98;
  result.f32[0] = *(double *)result.i64 * -6.25 + *(double *)result.i64 * -6.25 * *(double *)result.i64 + 0.5965;
  result.f32[0] = fmaxf(fmaxf(v54, result.f32[0]), 1.0);
  double v55 = 1.0 - *(float *)&a2.i32[2];
  float v56 = v55 * (fabsf(v7) * 0.1);
  float v57 = v56 + 1.0;
  *(float *)&double v55 = (float)(1.0 - v57) * 0.5;
  float32x4_t v58 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v55, 0), v53, v57);
  float v59 = fminf(result.f32[0], v67 * 30.0);
  result.i64[0] = vmlaq_n_f32(vmulq_n_f32(v53, 1.0 - v59), v58, v59).u64[0];
  result.i32[3] = a1.i32[3];
  return result;
}

float32x4_t cikernel::_highlightsAndShadows0(int32x4_t a1, float32x4_t a2, int32x4_t a3)
{
  float32x4_t v3 = (float32x4_t)a1;
  v3.i32[3] = 0;
  float32x4_t v53 = v3;
  float32x4_t v4 = vmulq_f32(vmaxnmq_f32(v3, (float32x4_t)0), (float32x4_t)xmmword_1939538A0);
  float v5 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).f32[0];
  float v6 = fmaxf(vaddq_f32((float32x4_t)vdupq_laneq_s32(a1, 2), vaddq_f32((float32x4_t)a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a1.i8, 1))).f32[0], 0.001);
  float v7 = v5 / v6;
  if ((float)(v5 / v6) <= 1.0) {
    float v8 = v5 / v6;
  }
  else {
    float v8 = 1.0;
  }
  if (v7 >= 0.0) {
    float v9 = v8;
  }
  else {
    float v9 = 0.0;
  }
  float v10 = powf(v9, fmaxf(1.0 - *(float *)a3.i32, 0.0));
  float v11 = v10 * *(float *)a3.i32;
  float32x4_t v12 = vmaxnmq_f32(v53, (float32x4_t)xmmword_1939508B0);
  v12.i32[3] = 0;
  float32x4_t v13 = vminnmq_f32(v12, (float32x4_t)xmmword_19394CBC0);
  float v14 = (float)(v13.f32[2] + vaddv_f32(*(float32x2_t *)v13.f32)) * 0.33333;
  float v15 = 1.0 / (1.0 - v14);
  float v16 = -(v13.f32[2] - v13.f32[1] * 2.0);
  v13.f32[0] = fmaxf(fminf(v13.f32[0] - v13.f32[1], v16), 0.0)
             * 4.0
             * (1.0 - fmaxf((float)(v13.f32[0] - v14) * v15, (float)(v14 - v13.f32[0]) * (float)(1.0 / v14)))
             * (float)(1.0 / v14);
  *(double *)v13.i64 = fminf(v13.f32[0], 1.0) * 0.7 + 0.15;
  v13.f32[0] = *(double *)v13.i64;
  int32x2_t v54 = *(int32x2_t *)v13.f32;
  *(float *)v17.i32 = -(float)(*(float *)a3.i32 * v10);
  simd_float4 v18 = (simd_float4)vsubq_f32((float32x4_t)vdupq_lane_s32(v17, 0), a2);
  v18.i32[3] = 0;
  simd_float4 v19 = _simd_pow_f4((simd_float4)xmmword_1939538B0, v18);
  simd_float4 v20 = (simd_float4)vaddq_f32((float32x4_t)vdupq_laneq_s32(a3, 2), vmulq_n_f32(vmlaq_n_f32(vmulq_n_f32((float32x4_t)v19, 1.0 - *(float *)v54.i32), (float32x4_t)vdupq_lane_s32(v54, 0), fminf(v19.f32[0], fminf(v19.f32[1], v19.f32[2]))), 1.0 - *(float *)&a3.i32[2]));
  v19.i64[0] = 0x8000000080000000;
  v19.i64[1] = 0x8000000080000000;
  __asm { FMOV            V2.4S, #1.0 }
  float32x4_t v52 = vabsq_f32((float32x4_t)a1);
  float32x4_t v55 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32((float32x4_t)a1), (int8x16_t)vcgtzq_f32((float32x4_t)a1)), vorrq_s8(vandq_s8((int8x16_t)a1, (int8x16_t)v19), _Q2), (int8x16_t)0);
  v19.i64[0] = 0x3F0000003F000000;
  v19.i64[1] = 0x3F0000003F000000;
  simd_float4 v26 = (simd_float4)vmulq_f32(v52, (float32x4_t)v19);
  v26.i32[3] = 0;
  v20.i32[3] = 0;
  float32x4_t v27 = vmulq_f32(v55, (float32x4_t)_simd_pow_f4(v26, v20));
  float32x4_t v28 = vaddq_f32(v27, v27);
  float v51 = sqrtf(fmaxf(fmaxf(fmaxf(a2.f32[0], a2.f32[1]), a2.f32[2]), 0.0));
  float v29 = v11 * 0.5 * v11 + 0.1;
  float v30 = v51 / v29;
  if (v30 <= 1.0) {
    float v31 = v30;
  }
  else {
    float v31 = 1.0;
  }
  if (v30 >= 0.0) {
    float v32 = v31;
  }
  else {
    float v32 = 0.0;
  }
  float v33 = sqrtf((float)(v32 * v32) * (float)((float)(v32 * -2.0) + 3.0));
  float v34 = (1.0 - v33) * v33;
  float32x4_t v57 = vmlaq_n_f32(vmulq_n_f32(v28, 1.0 - v34), (float32x4_t)a1, v34);
  v35.i32[1] = a3.i32[1];
  simd_float4 v36 = (simd_float4)vmulq_laneq_f32(v52, (float32x4_t)a3, 3);
  *(float *)v35.i32 = 2.0 - *(float *)&a3.i32[1];
  v36.i32[3] = 0;
  simd_float4 v37 = (simd_float4)vdupq_lane_s32(v35, 0);
  v37.i32[3] = 0;
  float32x4_t v38 = vmulq_f32(v55, (float32x4_t)_simd_pow_f4(v36, v37));
  float v39 = (float)(v51 + -0.2) / 0.6;
  if (v39 <= 1.0) {
    float v40 = (float)(v51 + -0.2) / 0.6;
  }
  else {
    float v40 = 1.0;
  }
  if (v39 >= 0.0) {
    float v41 = v40;
  }
  else {
    float v41 = 0.0;
  }
  float v42 = 1.0 - (float)((float)(v41 * v41) * (float)((float)(v41 * -2.0) + 3.0));
  float32x4_t v43 = vmlaq_n_f32(vmulq_n_f32(v57, 1.0 - v51), vmlaq_n_f32(vmulq_n_f32(v38, 1.0 - v42), (float32x4_t)a1, v42), v51);
  float32x4_t result = vmulq_f32(v43, (float32x4_t)xmmword_193950AB0);
  *(double *)result.i64 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)result, 2), vaddq_f32(result, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)result.f32, 1))).f32[0];
  float v44 = *(double *)result.i64 * -2.6 + *(double *)result.i64 * -2.6 * *(double *)result.i64 + 0.98;
  result.f32[0] = *(double *)result.i64 * -6.25 + *(double *)result.i64 * -6.25 * *(double *)result.i64 + 0.5965;
  result.f32[0] = fmaxf(fmaxf(v44, result.f32[0]), 1.0);
  v45.i32[1] = 1068079513;
  float v46 = fabsf(v11) * 0.05 + 1.0;
  *(float *)v45.i32 = (float)(1.0 - v46) * 0.5;
  float32x4_t v47 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v45, 0), v43, v46);
  float v48 = v51 * 30.0 * v51;
  float v49 = fminf(result.f32[0], v48);
  result.i64[0] = vmlaq_n_f32(vmulq_n_f32(v43, 1.0 - v49), v47, v49).u64[0];
  result.i32[3] = a1.i32[3];
  return result;
}

float32x4_t cikernel::_highlightsAndShadows_noblur0(float32x4_t a1, int32x4_t a2)
{
  float32x4_t v2 = a1;
  v2.i32[3] = 0;
  float32x4_t v51 = v2;
  float32x4_t v3 = vmulq_f32(vmaxnmq_f32(v2, (float32x4_t)0), (float32x4_t)xmmword_1939538A0);
  float v4 = a1.f32[1];
  float v5 = a1.f32[2];
  float v6 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))).f32[0]/ fmaxf(a1.f32[2] + vaddv_f32(*(float32x2_t *)a1.f32), 0.001);
  if (v6 <= 1.0) {
    float v7 = v6;
  }
  else {
    float v7 = 1.0;
  }
  if (v6 >= 0.0) {
    float v8 = v7;
  }
  else {
    float v8 = 0.0;
  }
  float v9 = powf(v8, fmaxf(1.0 - *(float *)a2.i32, 0.0));
  float v10 = v9 * *(float *)a2.i32;
  float32x4_t v11 = vmaxnmq_f32(v51, (float32x4_t)xmmword_1939508B0);
  v11.i32[3] = 0;
  float32x4_t v12 = vminnmq_f32(v11, (float32x4_t)xmmword_19394CBC0);
  float v13 = (float)(v12.f32[2] + vaddv_f32(*(float32x2_t *)v12.f32)) * 0.33333;
  float v14 = 1.0 / (1.0 - v13);
  float v15 = -(v12.f32[2] - v12.f32[1] * 2.0);
  v12.f32[0] = fmaxf(fminf(v12.f32[0] - v12.f32[1], v15), 0.0)
             * 4.0
             * (1.0 - fmaxf((float)(v12.f32[0] - v13) * v14, (float)(v13 - v12.f32[0]) * (float)(1.0 / v13)))
             * (float)(1.0 / v13);
  *(double *)v12.i64 = fminf(v12.f32[0], 1.0) * 0.7 + 0.15;
  v12.f32[0] = *(double *)v12.i64;
  int32x2_t v52 = *(int32x2_t *)v12.f32;
  *(float *)v16.i32 = -(float)(*(float *)a2.i32 * v9);
  simd_float4 v17 = (simd_float4)vsubq_f32((float32x4_t)vdupq_lane_s32(v16, 0), a1);
  v17.i32[3] = 0;
  simd_float4 v18 = _simd_pow_f4((simd_float4)xmmword_1939538B0, v17);
  simd_float4 v19 = (simd_float4)vaddq_f32((float32x4_t)vdupq_laneq_s32(a2, 2), vmulq_n_f32(vmlaq_n_f32(vmulq_n_f32((float32x4_t)v18, 1.0 - *(float *)v52.i32), (float32x4_t)vdupq_lane_s32(v52, 0), fminf(v18.f32[0], fminf(v18.f32[1], v18.f32[2]))), 1.0 - *(float *)&a2.i32[2]));
  v18.i64[0] = 0x8000000080000000;
  v18.i64[1] = 0x8000000080000000;
  __asm { FMOV            V2.4S, #1.0 }
  float32x4_t v50 = vabsq_f32(a1);
  float32x4_t v53 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a1), (int8x16_t)vcgtzq_f32(a1)), vorrq_s8(vandq_s8((int8x16_t)a1, (int8x16_t)v18), _Q2), (int8x16_t)0);
  v18.i64[0] = 0x3F0000003F000000;
  v18.i64[1] = 0x3F0000003F000000;
  simd_float4 v25 = (simd_float4)vmulq_f32(v50, (float32x4_t)v18);
  v25.i32[3] = 0;
  v19.i32[3] = 0;
  float32x4_t v26 = vmulq_f32(v53, (float32x4_t)_simd_pow_f4(v25, v19));
  float32x4_t v27 = vaddq_f32(v26, v26);
  float v48 = sqrtf(fmaxf(fmaxf(fmaxf(a1.f32[0], v4), v5), 0.0));
  float v28 = v10 * 0.5 * v10 + 0.1;
  float v29 = v48 / v28;
  if (v29 <= 1.0) {
    float v30 = v29;
  }
  else {
    float v30 = 1.0;
  }
  if (v29 >= 0.0) {
    float v31 = v30;
  }
  else {
    float v31 = 0.0;
  }
  double v32 = sqrtf((float)(v31 * v31) * (float)((float)(v31 * -2.0) + 3.0));
  *(float *)&double v32 = (1.0 - v32) * v32;
  float32x4_t v49 = vmlaq_n_f32(vmulq_n_f32(v27, 1.0 - *(float *)&v32), a1, *(float *)&v32);
  HIDWORD(v32) = a2.i32[1];
  simd_float4 v33 = (simd_float4)vmulq_laneq_f32(v50, (float32x4_t)a2, 3);
  *(float *)&double v32 = 2.0 - *(float *)&a2.i32[1];
  v33.i32[3] = 0;
  simd_float4 v34 = (simd_float4)vdupq_lane_s32(*(int32x2_t *)&v32, 0);
  v34.i32[3] = 0;
  float32x4_t v35 = vmulq_f32(v53, (float32x4_t)_simd_pow_f4(v33, v34));
  float v36 = (float)(v48 + -0.2) / 0.6;
  if (v36 <= 1.0) {
    float v37 = (float)(v48 + -0.2) / 0.6;
  }
  else {
    float v37 = 1.0;
  }
  if (v36 >= 0.0) {
    float v38 = v37;
  }
  else {
    float v38 = 0.0;
  }
  float v39 = 1.0 - (float)((float)(v38 * v38) * (float)((float)(v38 * -2.0) + 3.0));
  float32x4_t v40 = vmlaq_n_f32(vmulq_n_f32(v49, 1.0 - v48), vmlaq_n_f32(vmulq_n_f32(v35, 1.0 - v39), a1, v39), v48);
  float32x4_t result = vmulq_f32(v40, (float32x4_t)xmmword_193950AB0);
  *(double *)result.i64 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)result, 2), vaddq_f32(result, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)result.f32, 1))).f32[0];
  float v41 = *(double *)result.i64 * -2.6 + *(double *)result.i64 * -2.6 * *(double *)result.i64 + 0.98;
  result.f32[0] = *(double *)result.i64 * -6.25 + *(double *)result.i64 * -6.25 * *(double *)result.i64 + 0.5965;
  result.f32[0] = fmaxf(fmaxf(v41, result.f32[0]), 1.0);
  v42.i32[1] = 1068079513;
  float v43 = fabsf(v10) * 0.05 + 1.0;
  *(float *)v42.i32 = (float)(1.0 - v43) * 0.5;
  float32x4_t v44 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v42, 0), v40, v43);
  float v45 = v48 * 30.0 * v48;
  float v46 = fminf(result.f32[0], v45);
  result.i64[0] = vmlaq_n_f32(vmulq_n_f32(v40, 1.0 - v46), v44, v46).u64[0];
  result.i32[3] = a1.i32[3];
  return result;
}

float32x4_t cikernel::_shadows_noblur(float32x4_t a1, int32x4_t a2)
{
  float32x4_t v2 = a1;
  v2.i32[3] = 0;
  float32x4_t v40 = v2;
  float32x4_t v3 = vmulq_f32(vmaxnmq_f32(v2, (float32x4_t)0), (float32x4_t)xmmword_1939538A0);
  float v4 = a1.f32[1];
  float v5 = a1.f32[2];
  float v6 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))).f32[0]/ fmaxf(a1.f32[2] + vaddv_f32(*(float32x2_t *)a1.f32), 0.001);
  if (v6 <= 1.0) {
    float v7 = v6;
  }
  else {
    float v7 = 1.0;
  }
  if (v6 >= 0.0) {
    float v8 = v7;
  }
  else {
    float v8 = 0.0;
  }
  float v9 = powf(v8, fmaxf(1.0 - *(float *)a2.i32, 0.0));
  float v10 = v9 * *(float *)a2.i32;
  float32x4_t v11 = vmaxnmq_f32(v40, (float32x4_t)xmmword_1939508B0);
  v11.i32[3] = 0;
  float32x4_t v12 = vminnmq_f32(v11, (float32x4_t)xmmword_19394CBC0);
  float v13 = (float)(v12.f32[2] + vaddv_f32(*(float32x2_t *)v12.f32)) * 0.33333;
  float v14 = 1.0 / (1.0 - v13);
  float v15 = -(v12.f32[2] - v12.f32[1] * 2.0);
  v12.f32[0] = fmaxf(fminf(v12.f32[0] - v12.f32[1], v15), 0.0)
             * 4.0
             * (1.0 - fmaxf((float)(v12.f32[0] - v13) * v14, (float)(v13 - v12.f32[0]) * (float)(1.0 / v13)))
             * (float)(1.0 / v13);
  *(double *)v12.i64 = fminf(v12.f32[0], 1.0) * 0.7 + 0.15;
  v12.f32[0] = *(double *)v12.i64;
  int32x2_t v41 = *(int32x2_t *)v12.f32;
  *(float *)v16.i32 = -(float)(*(float *)a2.i32 * v9);
  simd_float4 v17 = (simd_float4)vsubq_f32((float32x4_t)vdupq_lane_s32(v16, 0), a1);
  v17.i32[3] = 0;
  simd_float4 v18 = _simd_pow_f4((simd_float4)xmmword_1939538B0, v17);
  simd_float4 v19 = (simd_float4)vaddq_f32((float32x4_t)vdupq_laneq_s32(a2, 2), vmulq_n_f32(vmlaq_n_f32(vmulq_n_f32((float32x4_t)v18, 1.0 - *(float *)v41.i32), (float32x4_t)vdupq_lane_s32(v41, 0), fminf(v18.f32[0], fminf(v18.f32[1], v18.f32[2]))), 1.0 - *(float *)&a2.i32[2]));
  v18.i64[0] = 0x8000000080000000;
  v18.i64[1] = 0x8000000080000000;
  __asm { FMOV            V2.4S, #1.0 }
  float32x4_t v43 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a1), (int8x16_t)vcgtzq_f32(a1)), vorrq_s8(vandq_s8((int8x16_t)a1, (int8x16_t)v18), (int8x16_t)_Q2), (int8x16_t)0);
  _Q2.i64[0] = 0x3F0000003F000000;
  _Q2.i64[1] = 0x3F0000003F000000;
  simd_float4 v25 = (simd_float4)vmulq_f32(vabsq_f32(a1), _Q2);
  v25.i32[3] = 0;
  v19.i32[3] = 0;
  float32x4_t result = vmulq_f32(v43, (float32x4_t)_simd_pow_f4(v25, v19));
  float32x4_t v26 = vaddq_f32(result, result);
  result.f32[0] = sqrtf(fmaxf(fmaxf(fmaxf(a1.f32[0], v4), v5), 0.0));
  float v28 = v10 * 0.5 * v10 + 0.1;
  float v29 = result.f32[0] / v28;
  if (v29 <= 1.0) {
    float v30 = v29;
  }
  else {
    float v30 = 1.0;
  }
  if (v29 >= 0.0) {
    float v31 = v30;
  }
  else {
    float v31 = 0.0;
  }
  float v32 = sqrtf((float)(v31 * v31) * (float)((float)(v31 * -2.0) + 3.0));
  float v33 = (1.0 - v32) * v32;
  float32x4_t v34 = vmlaq_n_f32(vmulq_n_f32(vmlaq_n_f32(vmulq_n_f32(v26, 1.0 - v33), a1, v33), 1.0 - result.f32[0]), a1, result.f32[0]);
  float32x4_t v35 = vmulq_f32(v34, (float32x4_t)xmmword_193950AB0);
  *(double *)v35.i64 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v35, 2), vaddq_f32(v35, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v35.f32, 1))).f32[0];
  float v36 = *(double *)v35.i64 * -2.6 + *(double *)v35.i64 * -2.6 * *(double *)v35.i64 + 0.98;
  v35.f32[0] = *(double *)v35.i64 * -6.25 + *(double *)v35.i64 * -6.25 * *(double *)v35.i64 + 0.5965;
  v35.f32[0] = fmaxf(fmaxf(v36, v35.f32[0]), 1.0);
  v37.i32[1] = 1068079513;
  float v38 = fabsf(v10) * 0.05 + 1.0;
  *(float *)v37.i32 = (float)(1.0 - v38) * 0.5;
  float v39 = result.f32[0] * 30.0 * result.f32[0];
  v35.f32[0] = fminf(v35.f32[0], v39);
  result.i64[0] = vmlaq_n_f32(vmulq_n_f32(v34, 1.0 - v35.f32[0]), vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v37, 0), v34, v38), v35.f32[0]).u64[0];
  result.i32[3] = a1.i32[3];
  return result;
}

double cikernel::_histogram_display(uint64_t a1, float a2, double a3)
{
  int32x2_t v34 = *(int32x2_t *)CI::getDC((CI *)a1);
  *(float *)&double v4 = floorf(*(float *)v34.i32) + 0.5;
  v5.i32[0] = *(_DWORD *)(a1 + 28);
  *(float *)&double v6 = *(float *)(a1 + 24)
                + (float)((float)(*(float *)(a1 + 20) * 0.5) + (float)(*(float *)&v4 * *(float *)(a1 + 16)));
  LODWORD(v7) = *(_DWORD *)(a1 + 32);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.f64 = *(float *)v8.i32
                   + (float)((float)(*(float *)&v7 * 0.5) + (float)(*(float *)&v4 * *(float *)v5.i32));
  *((float *)&v6 + 1) = *(float *)v9.f64;
  *(double *)v11.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v6, v9, v4, v7, v5, v8, v10);
  __asm { FMOV            V1.4S, #1.0 }
  float32x4_t v17 = (float32x4_t)vbicq_s8((int8x16_t)_Q1, (int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32(v34, 1), vmulq_n_f32(v11, a2)));
  *(double *)_Q1.i64 = v17.f32[1] + v17.f32[1] + v17.f32[0] * 4.0;
  *(double *)v17.i64 = *(double *)_Q1.i64 + v17.f32[2];
  v17.f32[0] = *(double *)v17.i64;
  _Q1.i32[0] = 4.0;
  float32x4_t v18 = (float32x4_t)xmmword_193953A00;
  v18.i32[0] = 6.0;
  v19.i32[0] = 2.0;
  int8x16_t v20 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_f32(v17, v18), 0), (int8x16_t)xmmword_193953A20, vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_f32(v17, _Q1), 0), (int8x16_t)xmmword_193953A10, (int8x16_t)xmmword_193953A00));
  float32x4_t v21 = (float32x4_t)xmmword_193953A30;
  v21.i32[0] = 3.0;
  float32x4_t v22 = (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_f32(v17, v21), 0);
  int8x16_t v23 = vbslq_s8((int8x16_t)v22, (int8x16_t)xmmword_193953A40, vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_f32(v17, v19), 0), (int8x16_t)xmmword_193953A30, v20));
  v22.i32[0] = 1.0;
  float32x4_t v24 = (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_f32(v17, v22), 0);
  int8x16_t v25 = vbslq_s8((int8x16_t)v24, (int8x16_t)xmmword_193953A50, v23);
  v24.i32[0] = 5.0;
  float32x4_t v26 = (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_f32(v17, v24), 0);
  v27.f64[1] = 0.00781250183;
  int8x16_t v28 = vbslq_s8((int8x16_t)v26, (int8x16_t)xmmword_193953A60, v25);
  v26.i32[0] = 7.0;
  float64x2_t v29 = (float64x2_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_f32(v17, v26), 0);
  v26.i64[1] = 0x3F8000003E99999ALL;
  float32x4_t v30 = (float32x4_t)vbslq_s8((int8x16_t)v29, (int8x16_t)xmmword_193953A70, v28);
  v29.f64[0] = *(float *)v34.i32;
  *(double *)v26.i64 = *(float *)&a3 + 0.5;
  float32x4_t v31 = (float32x4_t)vdupq_n_s32(0x3ECCCCCDu);
  float32x4_t v32 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s64(vcgtq_f64((float64x2_t)v26, v29).i64[0], 0), (int8x16_t)vmulq_f32(v30, v31), (int8x16_t)v30);
  v27.f64[0] = *((float *)&a3 + 1) + 0.5;
  *(void *)&double result = vbslq_s8((int8x16_t)vdupq_lane_s64(vmvnq_s8((int8x16_t)vcgeq_f64(v29, v27)).i64[0], 0), (int8x16_t)v32, (int8x16_t)vaddq_f32(vmulq_f32(v32, (float32x4_t)vdupq_n_s32(0x3F19999Au)), v31)).u64[0];
  return result;
}

void CI::f4_sr_f_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = *(void *)(a1 + 48);
  float32x4_t v12 = *(double (**)(uint64_t, float, double))(a1 + 24);
  uint64_t v13 = *(void *)(v11 + 8);
  uint64_t v14 = *(void *)(v11 + 32);
  int v15 = *(_DWORD *)(v11 + 64);
  uint64_t v16 = *(void *)(v11 + 56);
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC((CI *)(a3 + 16 * *(void *)(v11 + 80)), a2);
  }
  float32x4_t v17 = (double *)(a3 + 16 * v16);
  if (v15 != 5) {
    float32x4_t v17 = (double *)((char *)a2 + 64 * v16);
  }
  *(double *)&long long v18 = v12(a4 + 80 * v13, *((float *)a2 + 16 * v14), *v17);
  *(_OWORD *)(a3 + 16 * a7) = v18;
}

double unionPointWithRect(double a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5)
{
  CGFloat v5 = *(float *)&a1;
  v8.origin.CGFloat y = *((float *)&a1 + 1);
  v8.size.CGFloat width = 0.0;
  v8.size.CGFloat height = 0.0;
  v7.origin.CGFloat x = a2;
  v7.origin.CGFloat y = a3;
  v7.size.CGFloat width = a4;
  v7.size.CGFloat height = a5;
  v8.origin.CGFloat x = v5;
  *(void *)&double result = (unint64_t)CGRectUnion(v7, v8);
  return result;
}

float32x2_t cikernel::_holeDistortion(CI *a1, float32x2_t a2, float a3)
{
  DC = (float32x2_t *)CI::getDC(a1);
  float32x2_t v5 = vsub_f32(*DC, a2);
  int32x2_t v6 = (int32x2_t)vmul_f32(v5, v5);
  if (vaddv_f32((float32x2_t)v6) > a3) {
    return vsub_f32(*(float32x2_t *)CI::getDC((CI *)DC), vdiv_f32(vmul_n_f32(v5, a3), (float32x2_t)vdup_lane_s32((int32x2_t)vadd_f32((float32x2_t)v6, (float32x2_t)vdup_lane_s32(v6, 1)), 0)));
  }
  return a2;
}

double cikernel::_holeAntialias(CI *a1, float32x4_t a2, float32x2_t a3, float a4)
{
  float32x2_t v5 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a3);
  float v6 = sqrtf(vaddv_f32(vmul_f32(v5, v5))) - a4;
  float v7 = 1.0;
  if (v6 <= 1.0) {
    float v7 = v6;
  }
  BOOL v8 = v6 < 0.0;
  float v9 = 0.0;
  if (!v8) {
    float v9 = v7;
  }
  *(void *)&double result = vmulq_n_f32(a2, v9).u64[0];
  return result;
}

void CI::f4_s_f2_f(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  uint64_t v11 = (double (*)(void *, __n128, double, float))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  int v14 = *(_DWORD *)(v10 + 40);
  uint64_t v15 = *(void *)(v10 + 32);
  uint64_t v16 = *(void *)(v10 + 56);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 80)), a2);
  }
  float32x4_t v17 = (double *)(a3 + 16 * v15);
  if (v14 != 5) {
    float32x4_t v17 = (double *)((char *)a2 + 64 * v15);
  }
  long long v18 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    long long v18 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v19 = v11(a1, *v18, *v17, *((float *)a2 + 16 * v16));
  *(_OWORD *)(a3 + 16 * a7) = v19;
}

void sub_1937B214C(_Unwind_Exception *a1)
{
}

void sub_1937B21E8(_Unwind_Exception *a1)
{
}

void sub_1937B2284(_Unwind_Exception *a1)
{
}

void sub_1937B2320(_Unwind_Exception *a1)
{
}

void sub_1937B23BC(_Unwind_Exception *a1)
{
}

void sub_1937B2458(_Unwind_Exception *a1)
{
}

void sub_1937B24F4(_Unwind_Exception *a1)
{
}

void sub_1937B2590(_Unwind_Exception *a1)
{
}

void sub_1937B262C(_Unwind_Exception *a1)
{
}

void sub_1937B26C8(_Unwind_Exception *a1)
{
}

BOOL orientationTransform@<W0>(CGRect a1@<0:D0, 8:D1, 16:D2, 24:D3>, int a2@<W0>, _OWORD *a3@<X8>)
{
  CGFloat height = a1.size.height;
  CGFloat width = a1.size.width;
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  BOOL result = CGRectIsInfinite(a1);
  if (result)
  {
    uint64_t v8 = MEMORY[0x1E4F1DAB8];
    long long v9 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
    *a3 = *MEMORY[0x1E4F1DAB8];
    a3[1] = v9;
    a3[2] = *(_OWORD *)(v8 + 32);
  }
  else
  {
    v13[0] = 0x3FF0000000000000;
    v13[1] = 0;
    v13[2] = 0;
    v13[3] = 0x3FF0000000000000;
    v13[4] = 0;
    v13[5] = 0;
    v13[6] = 0xBFF0000000000000;
    v13[7] = 0;
    v13[8] = 0;
    v13[9] = 0x3FF0000000000000;
    *(CGFloat *)&v13[10] = width;
    long long v14 = xmmword_193953160;
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    unint64_t v17 = 0xBFF0000000000000;
    CGFloat v18 = width;
    CGFloat v19 = height;
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    uint64_t v20 = 0x3FF0000000000000;
    long long v23 = xmmword_193951E50;
    CGFloat v24 = height;
    long long v25 = xmmword_193953160;
    long long v26 = xmmword_193951E50;
    CGFloat v27 = height;
    CGFloat v28 = width;
    long long v29 = xmmword_193953160;
    uint64_t v31 = 0;
    uint64_t v32 = 0;
    uint64_t v30 = 0x3FF0000000000000;
    CGFloat v33 = width;
    long long v34 = xmmword_193953170;
    long long v36 = 0u;
    long long v37 = 0u;
    uint64_t v35 = 0x3FF0000000000000;
    uint64_t v38 = 0x3FF0000000000000;
    long long v39 = xmmword_193951E50;
    CGFloat v40 = height;
    uint64_t v41 = 0;
    if ((a2 - 9) >= 0xFFFFFFF8) {
      int v10 = a2 - 1;
    }
    else {
      int v10 = 0;
    }
    uint64_t v11 = &v13[6 * v10];
    long long v12 = v11[2];
    a3[1] = v11[1];
    a3[2] = v12;
    *a3 = *v11;
  }
  return result;
}

void sub_1937B2FFC(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C402EC69A6DLL);
  _Unwind_Resume(a1);
}

BOOL iosurface_creatable_from_cgblock(BOOL result)
{
  if (result)
  {
    CGImageBlockGetRect();
    double v2 = v1;
    unint64_t v4 = llround(v3);
    unint64_t BytesPerRow = CGImageBlockGetBytesPerRow();
    unint64_t v7 = 0;
    unint64_t v8 = 0;
    unint64_t v9 = 0;
    iosurface_limits((uint64_t)&v7);
    return v4 <= v7 && llround(v2) <= v8 && BytesPerRow <= v9;
  }
  return result;
}

const void *IOSurfaceWrapPointerOk(const void *result)
{
  if (result)
  {
    unint64_t v1 = (unint64_t)result;
    size_t v2 = malloc_size(result);
    int v3 = getpagesize();
    if (v2 <= 32 * v3) {
      return 0;
    }
    else {
      return (const void *)(v1 % v3 == 0);
    }
  }
  return result;
}

void SetSurfaceDeallocBlock(void *a1, uint64_t a2)
{
  if (a1)
  {
    int v3 = [[BlockDeallocator alloc] initWithBlock:a2];
    objc_setAssociatedObject(a1, SetSurfaceDeallocBlock, v3, (void *)1);
  }
}

CFDictionaryRef imageSourceCopyAuxiliaryDataInfo(CGImageSource *a1, size_t a2, const __CFString *a3)
{
  if (!a3) {
    return 0;
  }
  CFDictionaryRef v3 = CGImageSourceCopyAuxiliaryDataInfoAtIndex(a1, a2, a3);
  CFDictionaryRef v4 = v3;
  if (v3 && !CFDictionaryGetCount(v3))
  {
    CFRelease(v4);
    return 0;
  }
  return v4;
}

void SetSurfaceBackingObject(__IOSurface *a1, id value)
{
  if (a1) {
    objc_setAssociatedObject(a1, SetSurfaceBackingObject, value, (void *)1);
  }
}

void sub_1937B61F8(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E3C40651AB672);
  _Unwind_Resume(a1);
}

void CI::SampleModeImage::append_and_unref()
{
}

void sub_1937B627C(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C40191B4CE2);
  _Unwind_Resume(a1);
}

void sub_1937B69A0(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E3C40651AB672);
  _Unwind_Resume(a1);
}

void sub_1937B741C(_Unwind_Exception *a1)
{
  *(void *)(v3 - 176) = v2;
  std::vector<std::vector<IRect>>::__destroy_vector::operator()[abi:nn180100]((void ***)(v3 - 176));
  MEMORY[0x1997023B0](v1, 0x10E1C40DB69F48ELL);
  _Unwind_Resume(a1);
}

void sub_1937B79CC(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C40DBE5A1EELL);
  _Unwind_Resume(a1);
}

void sub_1937B7A90(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C40DBE5A1EELL);
  _Unwind_Resume(a1);
}

void sub_1937B7B14(_Unwind_Exception *a1)
{
}

CIImage *_noiseImage(char a1)
{
  v16[4] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (void *)[MEMORY[0x1E4F1CA58] dataWithLength:0x40000];
  uint64_t v3 = (unsigned char *)[v2 mutableBytes];
  srandom(0x2Au);
  unsigned int v4 = -4;
  do
  {
    char v5 = random();
    char v6 = random();
    char v7 = random();
    *uint64_t v3 = random();
    v3[1] = v7;
    v3[2] = v6;
    v3[3] = v5;
    v3 += 4;
    v4 += 4;
  }
  while (v4 < 0x3FFFC);
  if (a1)
  {
    v15[0] = @"CIImageColorSpace";
    v16[0] = [MEMORY[0x1E4F1CA98] null];
    v16[1] = MEMORY[0x1E4F1CC38];
    v15[1] = @"CIImageClampToEdge";
    v15[2] = @"CIImageNearestSampling";
    v15[3] = @"kCIImageCacheHint";
    v16[2] = MEMORY[0x1E4F1CC38];
    v16[3] = MEMORY[0x1E4F1CC38];
    unint64_t v8 = (void *)MEMORY[0x1E4F1C9E8];
    unint64_t v9 = v16;
    int v10 = v15;
    uint64_t v11 = 4;
  }
  else
  {
    v13[0] = @"CIImageColorSpace";
    v14[0] = [MEMORY[0x1E4F1CA98] null];
    v14[1] = MEMORY[0x1E4F1CC38];
    v13[1] = @"CIImageClampToEdge";
    v13[2] = @"kCIImageCacheHint";
    void v14[2] = MEMORY[0x1E4F1CC38];
    unint64_t v8 = (void *)MEMORY[0x1E4F1C9E8];
    unint64_t v9 = v14;
    int v10 = v13;
    uint64_t v11 = 3;
  }
  return -[CIImage initWithBitmapData:bytesPerRow:size:format:options:]([CIImage alloc], "initWithBitmapData:bytesPerRow:size:format:options:", v2, 1024, 266, [v8 dictionaryWithObjects:v9 forKeys:v10 count:v11], 256.0, 256.0);
}

void sub_1937B7D40(_Unwind_Exception *a1)
{
}

id hdrRawImage(CIRAWFilter *a1, NSDictionary *a2, double a3)
{
  LODWORD(a3) = 1.0;
  [(CIRAWFilter *)a1 setExtendedDynamicRangeAmount:a3];
  id result = [(CIRAWFilter *)a1 outputImage];
  if (result)
  {
    char v5 = result;
    char v6 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC50]);
    uint64_t v7 = [v5 imageByTaggingWithColorSpace:v6];
    CGColorSpaceRelease(v6);
    return (id)v7;
  }
  return result;
}

void sub_1937B87FC(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C40191B4CE2);
  _Unwind_Resume(a1);
}

void sub_1937B8994(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C40191B4CE2);
  _Unwind_Resume(a1);
}

void sub_1937B8AAC(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C40824C6A2FLL);
  _Unwind_Resume(a1);
}

void sub_1937B8DD8(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C40D5412EDCLL);
  _Unwind_Resume(a1);
}

void sub_1937B8FA8(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C40D5412EDCLL);
  _Unwind_Resume(a1);
}

void sub_1937B90FC(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C40D5412EDCLL);
  _Unwind_Resume(a1);
}

void sub_1937B920C(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C40D5412EDCLL);
  _Unwind_Resume(a1);
}

void sub_1937B92E8(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C401239EDCBLL);
  _Unwind_Resume(a1);
}

void sub_1937B94B0(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C40112EC1AALL);
  _Unwind_Resume(a1);
}

CIImage *implRenderToIntermediate(CIImage *a1, Trilean a2)
{
  [(CIImage *)a1 extent];
  if (!CGRectIsEmpty(v5))
  {
    [(CIImage *)a1 _internalRepresentation];
    operator new();
  }

  return +[CIImage emptyImage];
}

void sub_1937B95A4(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C4076E08ABBLL);
  _Unwind_Resume(a1);
}

void sub_1937B9788(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C4074FE08B2);
  _Unwind_Resume(a1);
}

void sub_1937B988C(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C4074FE08B2);
  _Unwind_Resume(a1);
}

void sub_1937B9954(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C40191B4CE2);
  _Unwind_Resume(a1);
}

void sub_1937B9A1C(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C40191B4CE2);
  _Unwind_Resume(a1);
}

void sub_1937B9F38(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C409BFD4FA3);
  _Unwind_Resume(a1);
}

uint64_t CI::Image::print_graph(CI::Image *this, __sFILE *a2)
{
  v33[128] = *MEMORY[0x1E4F143B8];
  memset(v5, 0, sizeof(v5));
  int v6 = 1065353216;
  if (CI::print_graph_recursive<CI::Image,CI::ImageIndex,CI::Image::ImageStats>(__sFILE *,CI::Image const*,int,std::unordered_map<CI::ImageIndex,CI::Image::ImageStats> const&)::onceToken != -1)
  {
    dispatch_once(&CI::print_graph_recursive<CI::Image,CI::ImageIndex,CI::Image::ImageStats>(__sFILE *,CI::Image const*,int,std::unordered_map<CI::ImageIndex,CI::Image::ImageStats> const&)::onceToken, &__block_literal_global_867);
    if (this) {
      goto LABEL_3;
    }
LABEL_5:
    fprintf(a2, "%.*sNULL\n", 2, CI::print_graph_recursive<CI::Image,CI::ImageIndex,CI::Image::ImageStats>(__sFILE *,CI::Image const*,int,std::unordered_map<CI::ImageIndex,CI::Image::ImageStats> const&)::indent_str);
    return std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table((uint64_t)v5);
  }
  if (!this) {
    goto LABEL_5;
  }
LABEL_3:
  uint64_t v18 = 0;
  CGFloat v19 = &v18;
  uint64_t v20 = 0x5812000000;
  uint64_t v21 = __Block_byref_object_copy__9;
  memset(v23, 0, sizeof(v23));
  uint64_t v22 = __Block_byref_object_dispose__9;
  uint64_t v24 = 0;
  int v25 = 1065353216;
  uint64_t v10 = 0;
  uint64_t v11 = (float *)&v10;
  uint64_t v12 = 0x5812000000;
  uint64_t v13 = __Block_byref_object_copy__869;
  memset(v15, 0, sizeof(v15));
  long long v14 = __Block_byref_object_dispose__870;
  uint64_t v16 = 0;
  int v17 = 1065353216;
  std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::__rehash<true>((uint64_t)&v23[8], 0x80uLL);
  std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::__rehash<true>((uint64_t)(v11 + 12), vcvtps_u32_f32(128.0 / v11[20]));
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3221225472;
  v9[2] = ___ZN2CIL21print_graph_recursiveINS_5ImageENS_10ImageIndexENS1_10ImageStatsEEEvP7__sFILEPKT_iRKNSt3__113unordered_mapIT0_T1_NS9_4hashISB_EENS9_8equal_toISB_EENS9_9allocatorINS9_4pairIKSB_SC_EEEEEE_block_invoke_871;
  v9[3] = &unk_1E57720A0;
  v9[4] = &v18;
  v9[5] = &v10;
  uint64_t v27 = MEMORY[0x1E4F143A8];
  uint64_t v28 = 3221225472;
  uint64_t v29 = (uint64_t)___ZNK2CI5Image27traverse_preorder_stoppableEU13block_pointerFbPKS0_S2_iiE_block_invoke;
  uint64_t v30 = (void *(*)(uint64_t, uint64_t))&unk_1E57720F0;
  uint64_t v31 = (uint64_t (*)())v9;
  CI::GraphObject::traverse_preorder_stoppable((uint64_t)this, 0, 0, 0, (uint64_t)&v27);
  std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::clear(v19 + 6);
  uint64_t v27 = 0;
  uint64_t v28 = (uint64_t)&v27;
  uint64_t v29 = 0x43012000000;
  uint64_t v30 = __Block_byref_object_copy__873;
  uint64_t v31 = __Block_byref_object_dispose__874;
  uint64_t v32 = "";
  bzero(v33, 0x400uLL);
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  v7[2] = ___ZN2CIL21print_graph_recursiveINS_5ImageENS_10ImageIndexENS1_10ImageStatsEEEvP7__sFILEPKT_iRKNSt3__113unordered_mapIT0_T1_NS9_4hashISB_EENS9_8equal_toISB_EENS9_9allocatorINS9_4pairIKSB_SC_EEEEEE_block_invoke_876;
  v7[3] = &unk_1E57720C8;
  int v8 = 1;
  v7[4] = &v27;
  v7[5] = &v18;
  v7[6] = &v10;
  v7[7] = a2;
  v7[8] = v5;
  v26[0] = MEMORY[0x1E4F143A8];
  v26[1] = 3221225472;
  v26[2] = ___ZNK2CI5Image27traverse_preorder_stoppableEU13block_pointerFbPKS0_S2_iiE_block_invoke;
  v26[3] = &unk_1E57720F0;
  v26[4] = v7;
  CI::GraphObject::traverse_preorder_stoppable((uint64_t)this, 0, 0, 0, (uint64_t)v26);
  _Block_object_dispose(&v27, 8);
  _Block_object_dispose(&v10, 8);
  std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table((uint64_t)&v15[8]);
  _Block_object_dispose(&v18, 8);
  std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table((uint64_t)&v23[8]);
  return std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table((uint64_t)v5);
}

void sub_1937BA550(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,char a60)
{
  _Block_object_dispose(&a60, 8);
  _Block_object_dispose(&a33, 8);
  std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table(v61);
  _Block_object_dispose(&a44, 8);
  std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table(v60);
  std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void sub_1937BC34C(_Unwind_Exception *a1)
{
}

void sub_1937BC42C(_Unwind_Exception *a1)
{
}

uint64_t dictionaryDeepCopy(void *a1, uint64_t a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (![a1 count]) {
    return MEMORY[0x1E4F1CC08];
  }
  id v4 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  id v5 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  int v6 = (void *)[a1 allKeys];
  uint64_t v7 = [v6 countByEnumeratingWithState:&v18 objects:v22 count:16];
  if (!v7) {
    goto LABEL_16;
  }
  uint64_t v8 = v7;
  uint64_t v9 = *(void *)v19;
  do
  {
    for (uint64_t i = 0; i != v8; ++i)
    {
      if (*(void *)v19 != v9) {
        objc_enumerationMutation(v6);
      }
      uint64_t v11 = *(void *)(*((void *)&v18 + 1) + 8 * i);
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a2 + 16))(a2, v11))
      {
        [v4 addObject:v11];
        uint64_t v12 = (void *)[a1 valueForKey:v11];
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          uint64_t v13 = dictionaryDeepCopy(v12, a2);
          long long v14 = v5;
        }
        else
        {
          if (objc_opt_respondsToSelector())
          {
            uint64_t v15 = (void *)[v12 copy];
            [v5 addObject:v15];

            continue;
          }
          long long v14 = v5;
          uint64_t v13 = (uint64_t)v12;
        }
        [v14 addObject:v13];
      }
    }
    uint64_t v8 = [v6 countByEnumeratingWithState:&v18 objects:v22 count:16];
  }
  while (v8);
LABEL_16:
  uint64_t v16 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v5 forKeys:v4];

  return v16;
}

uint64_t ___ZL35dictionaryDeepCopyExceptOrientationP12NSDictionary_block_invoke(uint64_t a1, void *a2)
{
  return [a2 isEqual:@"Orientation"] ^ 1;
}

uint64_t ___ZL18dictionaryDeepCopyP12NSDictionary_block_invoke()
{
  return 1;
}

CFTypeRef copyMetadataValue(const CGImageMetadata *a1, CFStringRef path)
{
  uint64_t v2 = CGImageMetadataCopyTagWithPath(a1, 0, path);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = v2;
  CFTypeRef v4 = CGImageMetadataTagCopyValue(v2);
  CFRelease(v3);
  if (v4)
  {
    CFTypeID TypeID = CFStringGetTypeID();
    if (TypeID == CFGetTypeID(v4))
    {
      CFAutorelease(v4);
      return v4;
    }
    CFRelease(v4);
    return 0;
  }
  return v4;
}

float32x4_t cikernel::_flexMap(float32x4_t a1, float32x4_t a2, simd_float4 a3, float32x4_t a4, float32x4_t a5, float a6, float32x4_t a7, float32x4_t a8)
{
  float32x4_t v18 = vsubq_f32(a5, a4);
  float32x4_t v8 = vabsq_f32(a2);
  v8.i32[3] = 0;
  simd_float4 v9 = (simd_float4)vmaxnmq_f32(v8, (float32x4_t)xmmword_193953B10);
  v10.i64[0] = 0x8000000080000000;
  v10.i64[1] = 0x8000000080000000;
  __asm { FMOV            V4.4S, #1.0 }
  v9.i32[3] = 0;
  a3.i32[3] = 0;
  simd_float4 v16 = (simd_float4)vmulq_n_f32(vaddq_f32(a4, vmulq_f32(v18, vmulq_f32((float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a2), (int8x16_t)vcgtzq_f32(a2)), vorrq_s8(vandq_s8((int8x16_t)a2, v10), _Q4), (int8x16_t)0), (float32x4_t)_simd_pow_f4(v9, a3)))), a6);
  v16.i32[3] = 0;
  float32x4_t result = (float32x4_t)_simd_exp2_f4(v16);
  result.i64[0] = vsubq_f32(vmulq_f32(vaddq_f32(a1, a7), result), a8).u64[0];
  result.i32[3] = a1.i32[3];
  return result;
}

void CI::f4_s_s_f3_f3_f3_f_f3_f3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  int8x16_t v10 = *(double (**)(__n128, __n128, __n128, __n128, __n128, float, __n128, __n128))(a1 + 24);
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  int v13 = *(_DWORD *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  uint64_t v15 = *(void *)(v9 + 56);
  uint64_t v16 = *(void *)(v9 + 80);
  uint64_t v17 = *(void *)(v9 + 104);
  uint64_t v18 = *(void *)(v9 + 128);
  uint64_t v19 = *(void *)(v9 + 152);
  long long v20 = *(const vec2 **)(v9 + 176);
  if (*(unsigned char *)(a1 + 64))
  {
    uint64_t v24 = *(const vec2 **)(v9 + 176);
    uint64_t v25 = *(void *)(v9 + 104);
    int v26 = *(_DWORD *)(v9 + 40);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 200)), v20);
    long long v20 = v24;
    uint64_t v17 = v25;
    int v13 = v26;
  }
  long long v21 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    long long v21 = (__n128 *)(a2 + (v14 << 6));
  }
  uint64_t v22 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    uint64_t v22 = (__n128 *)(a2 + (v12 << 6));
  }
  *(double *)&long long v23 = v10(*v22, *v21, *(__n128 *)(a2 + (v15 << 6)), *(__n128 *)(a2 + (v16 << 6)), *(__n128 *)(a2 + (v17 << 6)), *(float *)(a2 + (v18 << 6)), *(__n128 *)(a2 + (v19 << 6)), *(__n128 *)(a2 + ((void)v20 << 6)));
  *(_OWORD *)(a3 + 16 * a7) = v23;
}

__n128 cikernel::_gainMap(float32x4_t a1, simd_float4 a2, float a3)
{
  result.n128_f32[0] = (a3 + -1.0) * _simd_pow_f4(a2, (simd_float4)vdupq_n_s64(0x400CCCCD400CCCCDuLL)).f32[0] + 1.0;
  result.n128_u64[0] = vmulq_n_f32(a1, result.n128_f32[0]).u64[0];
  result.n128_u32[3] = a1.u32[3];
  return result;
}

void CI::GLTextureImage::~GLTextureImage(CI::GLTextureImage *this)
{
  CI::TextureImage::~TextureImage(this);

  JUMPOUT(0x1997023B0);
}

uint64_t CI::TextureImage::type(CI::TextureImage *this)
{
  return 25;
}

uint64_t CI::TextureImage::child_count(CI::TextureImage *this)
{
  return 0;
}

uint64_t CI::TextureImage::child(CI::TextureImage *this)
{
  return 0;
}

uint64_t CI::TextureImage::shape_for_graphviz(CI::TextureImage *this)
{
  return 0;
}

uint64_t CI::TextureImage::color_for_graphviz(CI::TextureImage *this)
{
  return 11;
}

_DWORD *CI::TextureImage::extent(_DWORD *this)
{
  if (!this[39]) {
    return (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(void *)this + 96))(this);
  }
  return this;
}

double CI::TextureImage::extent_unclamped(CI::TextureImage *this)
{
  return 0.0;
}

uint64_t CI::TextureImage::max_dimension(CI::TextureImage *this)
{
  unsigned int v1 = *((_DWORD *)this + 36);
  unsigned int v2 = *((_DWORD *)this + 37);
  if ((int)v1 <= (int)v2) {
    return v2;
  }
  else {
    return v1;
  }
}

uint64_t CI::Image::tileable(CI::Image *this)
{
  return 0;
}

BOOL CI::TextureImage::alpha_one(CI::TextureImage *this)
{
  return *((_DWORD *)this + 38) == 1;
}

uint64_t CI::Image::is_warp(CI::Image *this)
{
  return 0;
}

uint64_t CI::Image::output_format(CI::Image *this)
{
  return 0;
}

uint64_t CI::Image::print_for_graphviz(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 160))();
}

uint64_t CI::TextureImage::properties(CI::TextureImage *this)
{
  return *((void *)this + 17);
}

uint64_t CI::Image::avdepthdata(CI::Image *this)
{
  return 0;
}

uint64_t CI::Image::avmatte(CI::Image *this)
{
  return 0;
}

uint64_t CI::Image::ssmatte(CI::Image *this)
{
  return 0;
}

double CI::TextureImage::headroom(CI::TextureImage *this)
{
  return 0.0;
}

uint64_t CI::TextureImage::colorspace(CI::TextureImage *this)
{
  return 0;
}

uint64_t CI::Image::url(CI::Image *this)
{
  return *((void *)this + 6);
}

uint64_t CI::Image::user_info(CI::Image *this)
{
  return *((void *)this + 7);
}

uint64_t CI::Image::base_obj(CI::Image *this)
{
  return *((void *)this + 8);
}

uint64_t CI::GLTextureImage::format(CI::GLTextureImage *this)
{
  return 0;
}

uint64_t CI::TextureImage::alpha_mode(CI::TextureImage *this)
{
  return *((unsigned int *)this + 38);
}

uint64_t CI::TextureImage::texture_id(CI::TextureImage *this)
{
  return *((unsigned int *)this + 28);
}

uint64_t CI::GLTextureImage::texture_ref(CI::GLTextureImage *this)
{
  return 0;
}

uint64_t non-virtual thunk to'CI::TextureImage::type(CI::TextureImage *this)
{
  return 25;
}

void non-virtual thunk to'CI::GLTextureImage::~GLTextureImage(CI::GLTextureImage *this)
{
}

{
  uint64_t vars8;

  CI::TextureImage::~TextureImage((CI::GLTextureImage *)((char *)this - 104));

  JUMPOUT(0x1997023B0);
}

__n128 *CI::MetalTextureImage::MetalTextureImage(__n128 *a1, unint64_t a2, uint64_t a3, unsigned __int32 a4, unsigned __int32 a5, const void *a6, unsigned __int32 a7, unsigned __int32 a8)
{
  long long v12 = a2;
  uint64_t v9 = CI::TextureImage::TextureImage(a1, &v12, a3, a4, a5, a6, a7, a8);
  long long v12 = 0uLL;
  v9->n128_u64[0] = (unint64_t)&unk_1EE45CA68;
  v9[6].n128_u64[1] = (unint64_t)&unk_1EE45CBD8;
  int8x16_t v10 = (const void *)off_1EE45CBC0((CI::TextureImage *)v9);
  if (v10) {
    CFRetain(v10);
  }
  return a1;
}

void sub_1937BCBA8(_Unwind_Exception *a1)
{
  CI::TextureImage::~TextureImage(v1);
  _Unwind_Resume(a1);
}

uint64_t CI::InstanceCounted<(CI::Type)2>::type()
{
  return 2;
}

void *CI::InstanceCounted<(CI::Type)2>::~InstanceCounted(void *result)
{
  *__n128 result = &unk_1EE45ACB0;
  atomic_fetch_add(dword_1EB466E78, 0xFFFFFFFF);
  return result;
}

void CI::InstanceCounted<(CI::Type)2>::~InstanceCounted(void *a1)
{
  *a1 = &unk_1EE45ACB0;
  atomic_fetch_add(dword_1EB466E78, 0xFFFFFFFF);
  JUMPOUT(0x1997023B0);
}

uint64_t CI::InstanceCounted<(CI::Type)6>::type()
{
  return 6;
}

void *CI::InstanceCounted<(CI::Type)6>::~InstanceCounted(void *result)
{
  *__n128 result = &unk_1EE45B188;
  atomic_fetch_add(&dword_1EB466E78[4], 0xFFFFFFFF);
  return result;
}

void CI::InstanceCounted<(CI::Type)6>::~InstanceCounted(void *a1)
{
  *a1 = &unk_1EE45B188;
  atomic_fetch_add(&dword_1EB466E78[4], 0xFFFFFFFF);
  JUMPOUT(0x1997023B0);
}

uint64_t CI::InstanceCounted<(CI::Type)7>::type()
{
  return 7;
}

void *CI::InstanceCounted<(CI::Type)7>::~InstanceCounted(void *result)
{
  *__n128 result = &unk_1EE45B200;
  atomic_fetch_add(&dword_1EB466E78[5], 0xFFFFFFFF);
  return result;
}

void CI::InstanceCounted<(CI::Type)7>::~InstanceCounted(void *a1)
{
  *a1 = &unk_1EE45B200;
  atomic_fetch_add(&dword_1EB466E78[5], 0xFFFFFFFF);
  JUMPOUT(0x1997023B0);
}

CI::PremultiplyImage *CI::PremultiplyImage::PremultiplyImage(CI::PremultiplyImage *this, CI::Image *a2, int a3)
{
  int v6 = CI::ImageWithChild::ImageWithChild(this, a2);
  *((void *)v6 + 14) = &unk_1EE45AAD0;
  atomic_fetch_add(&dword_1EB466E78[14], 1u);
  *(void *)int v6 = &unk_1EE45C258;
  *((void *)v6 + 14) = &unk_1EE45C3B0;
  *((_DWORD *)v6 + 30) = a3;
  *((void *)this + 10) = CI::PremultiplyImage::makeDigest(*((void *)a2 + 10), a3);
  *((void *)this + 11) = CI::PremultiplyImage::makeDigest(*((void *)a2 + 11), a3);
  *((unsigned char *)this + 97) = 0;
  return this;
}

void sub_1937BCE14(_Unwind_Exception *a1)
{
  *((void *)v1 + 14) = v2;
  atomic_fetch_add(v3, 0xFFFFFFFF);
  CI::ImageWithChild::~ImageWithChild(v1);
  _Unwind_Resume(a1);
}

unint64_t CI::PremultiplyImage::makeDigest(uint64_t a1, int a2)
{
  XXH64_reset(v5, 0);
  LODWORD(__src) = 16;
  XXH64_update((uint64_t)v5, (char *)&__src, 4uLL);
  __vImage_Buffer src = a1;
  XXH64_update((uint64_t)v5, (char *)&__src, 8uLL);
  LODWORD(__src) = a2;
  XXH64_update((uint64_t)v5, (char *)&__src, 4uLL);
  return XXH64_digest((uint64_t)v5);
}

uint64_t CI::InstanceCounted<(CI::Type)16>::type()
{
  return 16;
}

void *CI::InstanceCounted<(CI::Type)16>::~InstanceCounted(void *result)
{
  *__n128 result = &unk_1EE45AAD0;
  atomic_fetch_add(&dword_1EB466E78[14], 0xFFFFFFFF);
  return result;
}

void CI::InstanceCounted<(CI::Type)16>::~InstanceCounted(void *a1)
{
  *a1 = &unk_1EE45AAD0;
  atomic_fetch_add(&dword_1EB466E78[14], 0xFFFFFFFF);
  JUMPOUT(0x1997023B0);
}

uint64_t CI::InstanceCounted<(CI::Type)8>::type()
{
  return 8;
}

void *CI::InstanceCounted<(CI::Type)8>::~InstanceCounted(void *result)
{
  *__n128 result = &unk_1EE45B2A0;
  atomic_fetch_add(&dword_1EB466E78[6], 0xFFFFFFFF);
  return result;
}

void CI::InstanceCounted<(CI::Type)8>::~InstanceCounted(void *a1)
{
  *a1 = &unk_1EE45B2A0;
  atomic_fetch_add(&dword_1EB466E78[6], 0xFFFFFFFF);
  JUMPOUT(0x1997023B0);
}

uint64_t CI::InstanceCounted<(CI::Type)23>::type()
{
  return 23;
}

void *CI::InstanceCounted<(CI::Type)23>::~InstanceCounted(void *result)
{
  *__n128 result = &unk_1EE45ABE8;
  atomic_fetch_add(&dword_1EB466E78[21], 0xFFFFFFFF);
  return result;
}

void CI::InstanceCounted<(CI::Type)23>::~InstanceCounted(void *a1)
{
  *a1 = &unk_1EE45ABE8;
  atomic_fetch_add(&dword_1EB466E78[21], 0xFFFFFFFF);
  JUMPOUT(0x1997023B0);
}

CI::GammaImage *CI::GammaImage::GammaImage(CI::GammaImage *this, CI::Image *a2, double a3)
{
  int v6 = CI::ImageWithChild::ImageWithChild(this, a2);
  *((void *)v6 + 14) = &unk_1EE45A9E0;
  atomic_fetch_add(&dword_1EB466E78[8], 1u);
  *(void *)int v6 = &unk_1EE457628;
  *((void *)v6 + 14) = &unk_1EE457780;
  *((double *)v6 + 15) = a3;
  *((void *)this + 10) = CI::GammaImage::makeDigest(*((void *)a2 + 10), a3);
  *((void *)this + 11) = CI::GammaImage::makeDigest(*((void *)a2 + 11), a3);
  *((unsigned char *)this + 97) = 0;
  return this;
}

void sub_1937BD10C(_Unwind_Exception *a1)
{
  *((void *)v1 + 14) = v2;
  atomic_fetch_add(v3, 0xFFFFFFFF);
  CI::ImageWithChild::~ImageWithChild(v1);
  _Unwind_Resume(a1);
}

unint64_t CI::GammaImage::makeDigest(uint64_t a1, double a2)
{
  XXH64_reset(v5, 0);
  LODWORD(__src) = 10;
  XXH64_update((uint64_t)v5, (char *)&__src, 4uLL);
  __vImage_Buffer src = *(double *)&a1;
  XXH64_update((uint64_t)v5, (char *)&__src, 8uLL);
  __vImage_Buffer src = a2;
  XXH64_update((uint64_t)v5, (char *)&__src, 8uLL);
  return XXH64_digest((uint64_t)v5);
}

uint64_t CI::InstanceCounted<(CI::Type)10>::type()
{
  return 10;
}

void *CI::InstanceCounted<(CI::Type)10>::~InstanceCounted(void *result)
{
  *__n128 result = &unk_1EE45A9E0;
  atomic_fetch_add(&dword_1EB466E78[8], 0xFFFFFFFF);
  return result;
}

void CI::InstanceCounted<(CI::Type)10>::~InstanceCounted(void *a1)
{
  *a1 = &unk_1EE45A9E0;
  atomic_fetch_add(&dword_1EB466E78[8], 0xFFFFFFFF);
  JUMPOUT(0x1997023B0);
}

CI::TagColorSpaceImage *CI::TagColorSpaceImage::TagColorSpaceImage(CI::TagColorSpaceImage *this, CI::Image *a2, CGColorSpace *a3)
{
  int v6 = CI::ImageWithChild::ImageWithChild(this, a2);
  *((void *)v6 + 14) = &unk_1EE45AC10;
  atomic_fetch_add(&dword_1EB466E78[22], 1u);
  *(void *)int v6 = &unk_1EE45CF70;
  *((void *)v6 + 14) = &unk_1EE45D0C8;
  *((void *)this + 15) = CGColorSpaceRetain(a3);
  XXH64_reset(v8, 0);
  LODWORD(__src) = (*(uint64_t (**)(CI::TagColorSpaceImage *))(*(void *)this + 16))(this);
  XXH64_update((uint64_t)v8, (char *)&__src, 4uLL);
  __vImage_Buffer src = *((void *)a2 + 10);
  XXH64_update((uint64_t)v8, (char *)&__src, 8uLL);
  CI::XXHashHelper::add((CI::XXHashHelper *)v8, a3);
  *((void *)this + 10) = XXH64_digest((uint64_t)v8);
  return this;
}

void sub_1937BD370(_Unwind_Exception *a1)
{
  *((void *)v1 + 14) = v2;
  atomic_fetch_add((atomic_uint *volatile)(v3 + 96), 0xFFFFFFFF);
  CI::ImageWithChild::~ImageWithChild(v1);
  _Unwind_Resume(a1);
}

uint64_t CI::InstanceCounted<(CI::Type)24>::type()
{
  return 24;
}

void *CI::InstanceCounted<(CI::Type)24>::~InstanceCounted(void *result)
{
  *__n128 result = &unk_1EE45AC10;
  atomic_fetch_add(&dword_1EB466E78[22], 0xFFFFFFFF);
  return result;
}

void CI::InstanceCounted<(CI::Type)24>::~InstanceCounted(void *a1)
{
  *a1 = &unk_1EE45AC10;
  atomic_fetch_add(&dword_1EB466E78[22], 0xFFFFFFFF);
  JUMPOUT(0x1997023B0);
}

size_t CI::XXHashHelper::add(CI::XXHashHelper *this, CFDataRef theData)
{
  if (theData)
  {
    BytePtr = (char *)CFDataGetBytePtr(theData);
    size_t result = CFDataGetLength(theData);
    if (BytePtr && result)
    {
      return XXH64_update((uint64_t)this, BytePtr, result);
    }
  }
  else
  {
    __vImage_Buffer src = 0;
    return XXH64_update((uint64_t)this, (char *)&__src, 4uLL);
  }
  return result;
}

CI::NoopImage *CI::NoopImage::NoopImage(CI::NoopImage *this, CI::Image *a2, Trilean a3, int a4)
{
  float32x4_t v8 = CI::ImageWithChild::ImageWithChild(this, a2);
  *((void *)v8 + 14) = &unk_1EE45AAA8;
  atomic_fetch_add(&dword_1EB466E78[13], 1u);
  *(void *)float32x4_t v8 = &unk_1EE45F768;
  *((void *)v8 + 14) = &unk_1EE45F8C0;
  *((Trilean *)v8 + 120) = a3;
  *((unsigned char *)v8 + 121) = a4;
  *((void *)this + 10) = CI::NoopImage::makeDigest(*((void *)a2 + 10), a3.var0, a4);
  *((void *)this + 11) = CI::NoopImage::makeDigest(*((void *)a2 + 11), a3.var0, a4);
  *((unsigned char *)this + 97) = 0;
  return this;
}

void sub_1937BD5A0(_Unwind_Exception *a1)
{
  *((void *)v1 + 14) = v2;
  atomic_fetch_add(v3, 0xFFFFFFFF);
  CI::ImageWithChild::~ImageWithChild(v1);
  _Unwind_Resume(a1);
}

unint64_t CI::NoopImage::makeDigest(uint64_t a1, unsigned __int8 a2, int a3)
{
  XXH64_reset(v7, 0);
  LODWORD(__src) = 15;
  XXH64_update((uint64_t)v7, (char *)&__src, 4uLL);
  __vImage_Buffer src = a1;
  XXH64_update((uint64_t)v7, (char *)&__src, 8uLL);
  LODWORD(__src) = a3;
  XXH64_update((uint64_t)v7, (char *)&__src, 4uLL);
  if (a2 == 255)
  {
    LODWORD(__src) = 0;
    goto LABEL_5;
  }
  if (a2 == 1)
  {
    LODWORD(__src) = 1;
LABEL_5:
    XXH64_update((uint64_t)v7, (char *)&__src, 4uLL);
  }
  return XXH64_digest((uint64_t)v7);
}

uint64_t CI::InstanceCounted<(CI::Type)15>::type()
{
  return 15;
}

void *CI::InstanceCounted<(CI::Type)15>::~InstanceCounted(void *result)
{
  *size_t result = &unk_1EE45AAA8;
  atomic_fetch_add(&dword_1EB466E78[13], 0xFFFFFFFF);
  return result;
}

void CI::InstanceCounted<(CI::Type)15>::~InstanceCounted(void *a1)
{
  *a1 = &unk_1EE45AAA8;
  atomic_fetch_add(&dword_1EB466E78[13], 0xFFFFFFFF);
  JUMPOUT(0x1997023B0);
}

CI::SetPropsImage *CI::SetPropsImage::SetPropsImage(CI::SetPropsImage *this, CI::Image *a2, const __CFDictionary *a3)
{
  int v6 = CI::ImageWithChild::ImageWithChild(this, a2);
  *((void *)v6 + 14) = &unk_1EE45AB98;
  atomic_fetch_add(&dword_1EB466E78[19], 1u);
  *(void *)int v6 = &unk_1EE4597A0;
  *((void *)v6 + 14) = &unk_1EE4598F8;
  if (a3) {
    CFTypeRef v7 = CFRetain(a3);
  }
  else {
    CFTypeRef v7 = 0;
  }
  *((void *)this + 15) = v7;
  *((void *)this + 10) = CI::SetPropsImage::makeDigest(*((void *)a2 + 10));
  *((void *)this + 11) = CI::SetPropsImage::makeDigest(*((void *)a2 + 11));
  return this;
}

void sub_1937BD7DC(_Unwind_Exception *a1)
{
  *((void *)v1 + 14) = v2;
  atomic_fetch_add((atomic_uint *volatile)(v3 + 84), 0xFFFFFFFF);
  CI::ImageWithChild::~ImageWithChild(v1);
  _Unwind_Resume(a1);
}

unint64_t CI::SetPropsImage::makeDigest(uint64_t a1)
{
  XXH64_reset(v3, 0);
  LODWORD(__src) = 21;
  XXH64_update((uint64_t)v3, (char *)&__src, 4uLL);
  __vImage_Buffer src = a1;
  XXH64_update((uint64_t)v3, (char *)&__src, 8uLL);
  return XXH64_digest((uint64_t)v3);
}

uint64_t CI::InstanceCounted<(CI::Type)21>::type()
{
  return 21;
}

void *CI::InstanceCounted<(CI::Type)21>::~InstanceCounted(void *result)
{
  *size_t result = &unk_1EE45AB98;
  atomic_fetch_add(&dword_1EB466E78[19], 0xFFFFFFFF);
  return result;
}

void CI::InstanceCounted<(CI::Type)21>::~InstanceCounted(void *a1)
{
  *a1 = &unk_1EE45AB98;
  atomic_fetch_add(&dword_1EB466E78[19], 0xFFFFFFFF);
  JUMPOUT(0x1997023B0);
}

uint64_t CI::SampleModeImage::SampleModeImage(uint64_t a1, uint64_t *a2, int a3)
{
  int v6 = CI::ImageWithChild::ImageWithChild((CI::ImageWithChild *)a1, (CI::Image *)a2);
  *((void *)v6 + 14) = &unk_1EE45AB70;
  atomic_fetch_add(&dword_1EB466E78[18], 1u);
  *(void *)int v6 = &unk_1EE45B5F0;
  *((void *)v6 + 14) = &unk_1EE45B748;
  *((_DWORD *)v6 + 30) = a3;
  *(void *)(a1 + 80) = CI::SampleModeImage::makeDigest(a2[10], a3);
  *(void *)(a1 + 88) = CI::SampleModeImage::makeDigest(a2[11], a3);
  *(unsigned char *)(a1 + 97) = 0;
  return a1;
}

void sub_1937BD9C0(_Unwind_Exception *a1)
{
  *((void *)v1 + 14) = v2;
  atomic_fetch_add(v3, 0xFFFFFFFF);
  CI::ImageWithChild::~ImageWithChild(v1);
  _Unwind_Resume(a1);
}

unint64_t CI::SampleModeImage::makeDigest(uint64_t a1, int a2)
{
  XXH64_reset(v5, 0);
  LODWORD(__src) = 20;
  XXH64_update((uint64_t)v5, (char *)&__src, 4uLL);
  __vImage_Buffer src = a1;
  XXH64_update((uint64_t)v5, (char *)&__src, 8uLL);
  LODWORD(__src) = a2;
  XXH64_update((uint64_t)v5, (char *)&__src, 4uLL);
  return XXH64_digest((uint64_t)v5);
}

uint64_t CI::InstanceCounted<(CI::Type)20>::type()
{
  return 20;
}

void *CI::InstanceCounted<(CI::Type)20>::~InstanceCounted(void *result)
{
  *size_t result = &unk_1EE45AB70;
  atomic_fetch_add(&dword_1EB466E78[18], 0xFFFFFFFF);
  return result;
}

void CI::InstanceCounted<(CI::Type)20>::~InstanceCounted(void *a1)
{
  *a1 = &unk_1EE45AB70;
  atomic_fetch_add(&dword_1EB466E78[18], 0xFFFFFFFF);
  JUMPOUT(0x1997023B0);
}

void *___ZN2CIL21print_graph_recursiveINS_5ImageENS_10ImageIndexENS1_10ImageStatsEEEvP7__sFILEPKT_iRKNSt3__113unordered_mapIT0_T1_NS9_4hashISB_EENS9_8equal_toISB_EENS9_9allocatorINS9_4pairIKSB_SC_EEEEEE_block_invoke()
{
  size_t result = memset(CI::print_graph_recursive<CI::Image,CI::ImageIndex,CI::Image::ImageStats>(__sFILE *,CI::Image const*,int,std::unordered_map<CI::ImageIndex,CI::Image::ImageStats> const&)::indent_str, 32, sizeof(CI::print_graph_recursive<CI::Image,CI::ImageIndex,CI::Image::ImageStats>(__sFILE *,CI::Image const*,int,std::unordered_map<CI::ImageIndex,CI::Image::ImageStats> const&)::indent_str));
  byte_1E93333C0 = 0;
  return result;
}

uint64_t __Block_byref_object_copy__9(uint64_t a1, uint64_t a2)
{
  return std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::__hash_table(a1 + 48, (uint64_t *)(a2 + 48));
}

uint64_t __Block_byref_object_dispose__9(uint64_t a1)
{
  return std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table(a1 + 48);
}

uint64_t __Block_byref_object_copy__869(uint64_t a1, uint64_t a2)
{
  return std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::__hash_table(a1 + 48, (uint64_t *)(a2 + 48));
}

uint64_t __Block_byref_object_dispose__870(uint64_t a1)
{
  return std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table(a1 + 48);
}

BOOL ___ZN2CIL21print_graph_recursiveINS_5ImageENS_10ImageIndexENS1_10ImageStatsEEEvP7__sFILEPKT_iRKNSt3__113unordered_mapIT0_T1_NS9_4hashISB_EENS9_8equal_toISB_EENS9_9allocatorINS9_4pairIKSB_SC_EEEEEE_block_invoke_871(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = a2;
  uint64_t v3 = std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::find<CI::Image const*>((void *)(*(void *)(*(void *)(a1 + 32) + 8) + 48), &v7);
  if (v3)
  {
    uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8);
    uint64_t v6 = *(void *)(v4 + 72);
    std::__hash_table<std::__hash_value_type<CI::Image const*,unsigned long>,std::__unordered_map_hasher<CI::Image const*,std::__hash_value_type<CI::Image const*,unsigned long>,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,true>,std::__unordered_map_equal<CI::Image const*,std::__hash_value_type<CI::Image const*,unsigned long>,std::equal_to<CI::Image const*>,std::hash<CI::Image const*>,true>,std::allocator<std::__hash_value_type<CI::Image const*,unsigned long>>>::__emplace_unique_key_args<CI::Image const*,CI::Image const*&,unsigned long>(v4 + 48, &v7, &v7, &v6);
  }
  else
  {
    std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::__emplace_unique_key_args<CI::Image const*,CI::Image const* const&>(*(void *)(*(void *)(a1 + 32) + 8) + 48, &v7, &v7);
  }
  return v3 != 0;
}

void *__Block_byref_object_copy__873(uint64_t a1, uint64_t a2)
{
  return memcpy((void *)(a1 + 48), (const void *)(a2 + 48), 0x400uLL);
}

BOOL ___ZN2CIL21print_graph_recursiveINS_5ImageENS_10ImageIndexENS1_10ImageStatsEEEvP7__sFILEPKT_iRKNSt3__113unordered_mapIT0_T1_NS9_4hashISB_EENS9_8equal_toISB_EENS9_9allocatorINS9_4pairIKSB_SC_EEEEEE_block_invoke_876(uint64_t a1, unsigned int *a2, uint64_t a3, int a4, int a5)
{
  int v26 = a2;
  fprintf(*(FILE **)(a1 + 56), "%.*s", 2 * *(_DWORD *)(a1 + 72), CI::print_graph_recursive<CI::Image,CI::ImageIndex,CI::Image::ImageStats>(__sFILE *,CI::Image const*,int,std::unordered_map<CI::ImageIndex,CI::Image::ImageStats> const&)::indent_str);
  if (a4 <= 0x3FF) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + a4 + 48) = (*(uint64_t (**)(unsigned int *))(*(void *)a2 + 40))(a2);
  }
  if (a4 >= 1)
  {
    unint64_t v9 = 0;
    do
    {
      if (v9 <= 0x3FF
        && (int v10 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + v9 + 48),
            BOOL v11 = v10 != 0,
            int v12 = v10 - 1,
            v12 != 0 && v11))
      {
        unint64_t v13 = v9 + 1;
        uint64_t v14 = *(FILE **)(a1 + 56);
        if (v9 + 1 == a4 && v12 == a5)
        {
          fwrite("", 6uLL, 1uLL, v14);
          *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + v9 + 48) = 0;
        }
        else
        {
          if (v13 == a4)
          {
            uint64_t v15 = "";
            size_t v16 = 6;
          }
          else
          {
            uint64_t v15 = " ";
            size_t v16 = 4;
          }
          fwrite(v15, v16, 1uLL, v14);
        }
      }
      else
      {
        fwrite("  ", 2uLL, 1uLL, *(FILE **)(a1 + 56));
        unint64_t v13 = v9 + 1;
      }
      unint64_t v9 = v13;
    }
    while (v13 != a4);
  }
  uint64_t v17 = std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::find<CI::Image const*>((void *)(*(void *)(*(void *)(a1 + 40) + 8) + 48), &v26);
  if (v17)
  {
    uint64_t v18 = *(FILE **)(a1 + 56);
    uint64_t v19 = *(void *)(*(void *)(a1 + 48) + 8) + 48;
    uint64_t v27 = &v26;
    long long v20 = std::__hash_table<std::__hash_value_type<CI::Image const*,unsigned long>,std::__unordered_map_hasher<CI::Image const*,std::__hash_value_type<CI::Image const*,unsigned long>,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,true>,std::__unordered_map_equal<CI::Image const*,std::__hash_value_type<CI::Image const*,unsigned long>,std::equal_to<CI::Image const*>,std::hash<CI::Image const*>,true>,std::allocator<std::__hash_value_type<CI::Image const*,unsigned long>>>::__emplace_unique_key_args<CI::Image const*,std::piecewise_construct_t const&,std::tuple<CI::Image const* const&>,std::tuple<>>(v19, &v26, (uint64_t)&std::piecewise_construct, &v27);
    fprintf(v18, "<%ld>\n", v20[3]);
  }
  else
  {
    long long v21 = std::__hash_table<std::__hash_value_type<CI::ImageIndex,CI::Image::ImageStats>,std::__unordered_map_hasher<CI::ImageIndex,std::__hash_value_type<CI::ImageIndex,CI::Image::ImageStats>,std::hash<CI::ImageIndex>,std::equal_to<CI::ImageIndex>,true>,std::__unordered_map_equal<CI::ImageIndex,std::__hash_value_type<CI::ImageIndex,CI::Image::ImageStats>,std::equal_to<CI::ImageIndex>,std::hash<CI::ImageIndex>,true>,std::allocator<std::__hash_value_type<CI::ImageIndex,CI::Image::ImageStats>>>::find<CI::ImageIndex>(*(void **)(a1 + 64), v26 + 25);
    if (v21) {
      (*(void (**)(unsigned int *, void, uint64_t))(*(void *)v26 + 152))(v26, *(void *)(a1 + 56), (uint64_t)v21 + 20);
    }
    else {
      (*(void (**)(unsigned int *, void, unsigned int ***))(*(void *)v26 + 152))(v26, *(void *)(a1 + 56), &v27);
    }
    if (std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::find<CI::Image const*>((void *)(*(void *)(*(void *)(a1 + 48) + 8) + 48), &v26))
    {
      uint64_t v22 = *(FILE **)(a1 + 56);
      uint64_t v23 = *(void *)(*(void *)(a1 + 48) + 8) + 48;
      uint64_t v27 = &v26;
      uint64_t v24 = std::__hash_table<std::__hash_value_type<CI::Image const*,unsigned long>,std::__unordered_map_hasher<CI::Image const*,std::__hash_value_type<CI::Image const*,unsigned long>,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,true>,std::__unordered_map_equal<CI::Image const*,std::__hash_value_type<CI::Image const*,unsigned long>,std::equal_to<CI::Image const*>,std::hash<CI::Image const*>,true>,std::allocator<std::__hash_value_type<CI::Image const*,unsigned long>>>::__emplace_unique_key_args<CI::Image const*,std::piecewise_construct_t const&,std::tuple<CI::Image const* const&>,std::tuple<>>(v23, &v26, (uint64_t)&std::piecewise_construct, &v27);
      fprintf(v22, " <%ld>", v24[3]);
    }
    fputc(10, *(FILE **)(a1 + 56));
    std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::__emplace_unique_key_args<CI::Image const*,CI::Image const* const&>(*(void *)(*(void *)(a1 + 40) + 8) + 48, &v26, &v26);
  }
  return v17 != 0;
}

uint64_t std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::__hash_table(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a2 = 0;
  *(void *)size_t result = v2;
  *(void *)(result + 8) = a2[1];
  a2[1] = 0;
  uint64_t v5 = a2[2];
  uint64_t v3 = a2 + 2;
  uint64_t v4 = v5;
  *(void *)(result + 16) = v5;
  uint64_t v6 = v3[1];
  *(void *)(result + 24) = v6;
  *(_DWORD *)(result + 32) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    unint64_t v7 = *(void *)(v4 + 8);
    unint64_t v8 = *(void *)(result + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        v7 %= v8;
      }
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(void *)(v2 + 8 * v7) = result + 16;
    *uint64_t v3 = 0;
    v3[1] = 0;
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<CI::Image const*,unsigned long>,std::__unordered_map_hasher<CI::Image const*,std::__hash_value_type<CI::Image const*,unsigned long>,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,true>,std::__unordered_map_equal<CI::Image const*,std::__hash_value_type<CI::Image const*,unsigned long>,std::equal_to<CI::Image const*>,std::hash<CI::Image const*>,true>,std::allocator<std::__hash_value_type<CI::Image const*,unsigned long>>>::__emplace_unique_key_args<CI::Image const*,CI::Image const*&,unsigned long>(uint64_t a1, void *a2, void *a3, uint64_t *a4)
{
  unint64_t v8 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v9 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v8 >> 47) ^ v8);
  unint64_t v10 = 0x9DDFEA08EB382D69 * (v9 ^ (v9 >> 47));
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = 0x9DDFEA08EB382D69 * (v9 ^ (v9 >> 47));
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
    }
    else
    {
      unint64_t v4 = v10 & (v11 - 1);
    }
    unint64_t v13 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v13)
    {
      for (uint64_t i = *v13; i; uint64_t i = (void *)*i)
      {
        unint64_t v15 = i[1];
        if (v15 == v10)
        {
          if (i[2] == *a2) {
            return i;
          }
        }
        else
        {
          if (v12.u32[0] > 1uLL)
          {
            if (v15 >= v11) {
              v15 %= v11;
            }
          }
          else
          {
            v15 &= v11 - 1;
          }
          if (v15 != v4) {
            break;
          }
        }
      }
    }
  }
  uint64_t i = operator new(0x20uLL);
  void *i = 0;
  i[1] = v10;
  uint64_t v16 = *a4;
  i[2] = *a3;
  i[3] = v16;
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    BOOL v19 = 1;
    if (v11 >= 3) {
      BOOL v19 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v11);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::__rehash<true>(a1, v22);
    unint64_t v11 = *(void *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
      else {
        unint64_t v4 = v10;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v10;
    }
  }
  uint64_t v23 = *(void *)a1;
  uint64_t v24 = *(void **)(*(void *)a1 + 8 * v4);
  if (v24)
  {
    void *i = *v24;
LABEL_38:
    *uint64_t v24 = i;
    goto LABEL_39;
  }
  void *i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v23 + 8 * v4) = a1 + 16;
  if (*i)
  {
    unint64_t v25 = *(void *)(*i + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v25 >= v11) {
        v25 %= v11;
      }
    }
    else
    {
      v25 &= v11 - 1;
    }
    uint64_t v24 = (void *)(*(void *)a1 + 8 * v25);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_1937BE1A4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::__emplace_unique_key_args<CI::Image const*,CI::Image const* const&>(uint64_t a1, void *a2, void *a3)
{
  unint64_t v6 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v7 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v6 >> 47) ^ v6);
  unint64_t v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
    }
    else
    {
      unint64_t v3 = v8 & (v9 - 1);
    }
    unint64_t v11 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v11)
    {
      for (uint64_t i = *v11; i; uint64_t i = (void *)*i)
      {
        unint64_t v13 = i[1];
        if (v13 == v8)
        {
          if (i[2] == *a2) {
            return i;
          }
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9) {
              v13 %= v9;
            }
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v3) {
            break;
          }
        }
      }
    }
  }
  uint64_t i = operator new(0x18uLL);
  void *i = 0;
  i[1] = v8;
  i[2] = *a3;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v9 || (float)(v15 * (float)v9) < v14)
  {
    BOOL v16 = 1;
    if (v9 >= 3) {
      BOOL v16 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v9);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t v19 = v18;
    }
    else {
      size_t v19 = v17;
    }
    std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::__rehash<true>(a1, v19);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }
  uint64_t v20 = *(void *)a1;
  unint64_t v21 = *(void **)(*(void *)a1 + 8 * v3);
  if (v21)
  {
    void *i = *v21;
LABEL_38:
    *unint64_t v21 = i;
    goto LABEL_39;
  }
  void *i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v20 + 8 * v3) = a1 + 16;
  if (*i)
  {
    unint64_t v22 = *(void *)(*i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v22 >= v9) {
        v22 %= v9;
      }
    }
    else
    {
      v22 &= v9 - 1;
    }
    unint64_t v21 = (void *)(*(void *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_1937BE3F8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::clear(void *result)
{
  if (result[3])
  {
    unsigned int v1 = result;
    size_t result = (void *)result[2];
    if (result)
    {
      do
      {
        uint64_t v2 = (void *)*result;
        operator delete(result);
        size_t result = v2;
      }
      while (v2);
    }
    v1[2] = 0;
    uint64_t v3 = v1[1];
    if (v3)
    {
      for (uint64_t i = 0; i != v3; ++i)
        *(void *)(*v1 + 8 * i) = 0;
    }
    v1[3] = 0;
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<CI::Image const*,unsigned long>,std::__unordered_map_hasher<CI::Image const*,std::__hash_value_type<CI::Image const*,unsigned long>,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,true>,std::__unordered_map_equal<CI::Image const*,std::__hash_value_type<CI::Image const*,unsigned long>,std::equal_to<CI::Image const*>,std::hash<CI::Image const*>,true>,std::allocator<std::__hash_value_type<CI::Image const*,unsigned long>>>::__emplace_unique_key_args<CI::Image const*,std::piecewise_construct_t const&,std::tuple<CI::Image const* const&>,std::tuple<>>(uint64_t a1, void *a2, uint64_t a3, void **a4)
{
  unint64_t v7 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v8 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v7 >> 47) ^ v7);
  unint64_t v9 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v4 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
    }
    else
    {
      unint64_t v4 = v9 & (v10 - 1);
    }
    uint8x8_t v12 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v12)
    {
      for (uint64_t i = *v12; i; uint64_t i = (void *)*i)
      {
        unint64_t v14 = i[1];
        if (v14 == v9)
        {
          if (i[2] == *a2) {
            return i;
          }
        }
        else
        {
          if (v11.u32[0] > 1uLL)
          {
            if (v14 >= v10) {
              v14 %= v10;
            }
          }
          else
          {
            v14 &= v10 - 1;
          }
          if (v14 != v4) {
            break;
          }
        }
      }
    }
  }
  uint64_t i = operator new(0x20uLL);
  void *i = 0;
  i[1] = v9;
  i[2] = **a4;
  i[3] = 0;
  float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v16 = *(float *)(a1 + 32);
  if (!v10 || (float)(v16 * (float)v10) < v15)
  {
    BOOL v17 = 1;
    if (v10 >= 3) {
      BOOL v17 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v10);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t v20 = v19;
    }
    else {
      size_t v20 = v18;
    }
    std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::__rehash<true>(a1, v20);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
      else {
        unint64_t v4 = v9;
      }
    }
    else
    {
      unint64_t v4 = (v10 - 1) & v9;
    }
  }
  uint64_t v21 = *(void *)a1;
  unint64_t v22 = *(void **)(*(void *)a1 + 8 * v4);
  if (v22)
  {
    void *i = *v22;
LABEL_38:
    *unint64_t v22 = i;
    goto LABEL_39;
  }
  void *i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v21 + 8 * v4) = a1 + 16;
  if (*i)
  {
    unint64_t v23 = *(void *)(*i + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v23 >= v10) {
        v23 %= v10;
      }
    }
    else
    {
      v23 &= v10 - 1;
    }
    unint64_t v22 = (void *)(*(void *)a1 + 8 * v23);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_1937BE6B8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<std::__hash_value_type<CI::ImageIndex,CI::Image::ImageStats>,std::__unordered_map_hasher<CI::ImageIndex,std::__hash_value_type<CI::ImageIndex,CI::Image::ImageStats>,std::hash<CI::ImageIndex>,std::equal_to<CI::ImageIndex>,true>,std::__unordered_map_equal<CI::ImageIndex,std::__hash_value_type<CI::ImageIndex,CI::Image::ImageStats>,std::equal_to<CI::ImageIndex>,std::hash<CI::ImageIndex>,true>,std::allocator<std::__hash_value_type<CI::ImageIndex,CI::Image::ImageStats>>>::find<CI::ImageIndex>(void *a1, unsigned int *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = *a2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = *a2;
    if (*(void *)&v2 <= v3) {
      unint64_t v5 = v3 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v5 = (v2.i32[0] - 1) & v3;
  }
  unint64_t v6 = *(uint64_t ***)(*a1 + 8 * v5);
  if (!v6) {
    return 0;
  }
  for (size_t result = *v6; result; size_t result = (uint64_t *)*result)
  {
    unint64_t v8 = result[1];
    if (v8 == v3)
    {
      if (*((_DWORD *)result + 4) == v3) {
        return result;
      }
    }
    else
    {
      if (v4.u32[0] > 1uLL)
      {
        if (v8 >= *(void *)&v2) {
          v8 %= *(void *)&v2;
        }
      }
      else
      {
        v8 &= *(void *)&v2 - 1;
      }
      if (v8 != v5) {
        return 0;
      }
    }
  }
  return result;
}

int8x16_t cikernel::_RGBtoLAB(float32x4_t a1)
{
  unsigned __int32 v11 = a1.u32[3];
  float32x4_t v1 = vmulq_f32(a1, (float32x4_t)xmmword_193953B20);
  float32x4_t v2 = vmulq_f32(a1, (float32x4_t)xmmword_193953B30);
  v3.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1, 2), vaddq_f32(v1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v1.f32, 1))).u32[0];
  float32x4_t v4 = vmulq_f32(a1, (float32x4_t)xmmword_193953B40);
  v3.i32[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v2, 2), vaddq_f32(v2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v2.f32, 1))).u32[0];
  v3.i64[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).u32[0];
  float32x4_t v5 = vmaxnmq_f32(v3, (float32x4_t)0);
  int8x16_t v9 = (int8x16_t)vaddq_f32(vmulq_f32(v5, (float32x4_t)vdupq_n_s32(0x40F92F1Bu)), (float32x4_t)vdupq_n_s32(0x3E0D3DCBu));
  float32x4_t v10 = vaddq_f32(v5, (float32x4_t)vdupq_n_s32(0xBC1118C2));
  v5.i32[3] = 0;
  simd_float4 v6 = _simd_pow_f4((simd_float4)v5, (simd_float4)xmmword_193953B50);
  int8x16_t v7 = (int8x16_t)vcltzq_f32(v10);
  int8x16_t result = vbslq_s8(v7, v9, (int8x16_t)v6);
  *(double *)v7.i64 = *(float *)&result.i32[1] * 116.0 + -16.0;
  *(float *)v7.i32 = *(double *)v7.i64;
  *(float32x2_t *)result.i8 = vmul_f32(vsub_f32(*(float32x2_t *)result.i8, (float32x2_t)vext_s8(*(int8x8_t *)result.i8, (int8x8_t)*(_OWORD *)&vextq_s8(result, result, 8uLL), 4uLL)), (float32x2_t)0x4348000043FA0000);
  result.i64[0] = vextq_s8(vextq_s8(v7, v7, 4uLL), result, 0xCuLL).u64[0];
  result.i32[3] = v11;
  return result;
}

double cikernel::_LABtoRGB(__n128 a1, float32x4_t a2)
{
  float32_t v2 = (a1.n128_f32[0] + 16.0) / 116.0;
  a2.f32[0] = a1.n128_f32[1] / 500.0 + v2;
  float32_t v3 = v2 + a1.n128_f32[2] / -200.0;
  a2.f32[1] = v2;
  a2.f32[2] = v3;
  float32x4_t v4 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_f32(vaddq_f32(a2, (float32x4_t)vdupq_n_s32(0xBE53DCB1))), (int8x16_t)vmulq_f32(vaddq_f32(a2, (float32x4_t)vdupq_n_s32(0xBE0D3DCB)), (float32x4_t)vdupq_n_s32(0x3E038027u)), (int8x16_t)vmulq_f32(a2, vmulq_f32(a2, a2)));
  float32x4_t v5 = vmulq_f32(v4, (float32x4_t)xmmword_193953B60);
  float32x4_t v6 = vmulq_f32(v4, (float32x4_t)xmmword_193953B70);
  *(void *)&double result = vzip1q_s32((int32x4_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))), (int32x4_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), vaddq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1)))).u64[0];
  return result;
}

CI::ImageAccumulator::Content *CI::ImageAccumulator::Content::Content(CI::ImageAccumulator::Content *this, CGRect a2, CGColorSpace *a3, int a4)
{
  v15[1] = *MEMORY[0x1E4F143B8];
  CGFloat width = (__CVBuffer *)a2.size.width;
  CGFloat height = (__CVBuffer *)a2.size.height;
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  uint64_t v8 = CI::PixelFormatType_from_format(a4);
  Surface = CreateSurface(width, height, (void *)0x20, v8, 1);
  *((void *)this + 1) = Surface;
  if (a3)
  {
    unint64_t v14 = @"CIImageColorSpace";
    v15[0] = a3;
    uint64_t v10 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v15 forKeys:&v14 count:1];
    unsigned __int32 v11 = (__IOSurface *)*((void *)this + 1);
  }
  else
  {
    unsigned __int32 v11 = Surface;
    uint64_t v10 = 0;
  }
  uint8x8_t v12 = [+[CIImage imageWithIOSurface:v11 options:v10] _internalRepresentation];
  if (v12) {
    uint8x8_t v12 = (void *)CI::Object::ref((uint64_t)v12);
  }
  *(void *)this = v12;
  return this;
}

void CI::ImageAccumulator::ImageAccumulator(CI::ImageAccumulator *this, CGRect a2, CGColorSpace *a3, int a4, CIContext *a5, CIBlendKernel *a6)
{
  double height = a2.size.height;
  double width = a2.size.width;
  double y = a2.origin.y;
  double x = a2.origin.x;
  *(CGRect *)this = a2;
  *((void *)this + 4) = a3;
  *((_DWORD *)this + 10) = a4;
  *((void *)this + 6) = a5;
  *((void *)this + 7) = a6;
  *((unsigned char *)this + 96) = 0;
  CGColorSpaceRetain(a3);
  id v11 = *((id *)this + 6);
  id v12 = *((id *)this + 7);
  *((void *)this + 11) = +[CIImage clearImage:](CIImage, "clearImage:", x, y, width, height);
  operator new();
}

void sub_1937BEC6C(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x20C40A4A59CD2);
  _Unwind_Resume(a1);
}

void CI::ImageAccumulator::~ImageAccumulator(CI::ImageAccumulator *this)
{
  dispatch_sync(*((dispatch_queue_t *)this + 17), &__block_literal_global_39);
  CGColorSpaceRelease(*((CGColorSpaceRef *)this + 4));

  float32_t v2 = (CI::Object **)*((void *)this + 8);
  if (v2)
  {
    CI::ImageAccumulator::Content::~Content(v2);
    MEMORY[0x1997023B0]();
  }
  float32_t v3 = (CI::Object **)*((void *)this + 9);
  if (v3)
  {
    CI::ImageAccumulator::Content::~Content(v3);
    MEMORY[0x1997023B0]();
  }

  dispatch_release(*((dispatch_object_t *)this + 17));
}

__n128 CI::ImageAccumulator::sync_content(CI::ImageAccumulator *this)
{
  float32_t v2 = (void *)*((void *)this + 10);
  float32_t v3 = (void *)*((void *)this + 8);
  if (v2 == v3) {
    float32_t v3 = (void *)*((void *)this + 9);
  }
  objc_msgSend(*((id *)this + 6), "render:toIOSurface:bounds:colorSpace:", +[CIImage imageWithInternalRepresentation:](CIImage, "imageWithInternalRepresentation:", *v2), v3[1], *((void *)this + 4), *((double *)this + 13), *((double *)this + 14), *((double *)this + 15), *((double *)this + 16));
  __n128 result = *(__n128 *)MEMORY[0x1E4F1DB20];
  long long v5 = *(_OWORD *)(MEMORY[0x1E4F1DB20] + 16);
  *(_OWORD *)((char *)this + 104) = *MEMORY[0x1E4F1DB20];
  *(_OWORD *)((char *)this + 120) = v5;
  return result;
}

uint64_t CI::ImageAccumulator::get(CI::ImageAccumulator *this, char a2)
{
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x3052000000;
  uint64_t v10 = __Block_byref_object_copy__10;
  id v11 = __Block_byref_object_dispose__10;
  uint64_t v12 = 0;
  float32_t v2 = *((void *)this + 17);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN2CI16ImageAccumulator3getEb_block_invoke;
  block[3] = &unk_1E5772130;
  block[4] = &v7;
  block[5] = this;
  char v6 = a2;
  dispatch_sync(v2, block);
  uint64_t v3 = v8[5];
  _Block_object_dispose(&v7, 8);
  return v3;
}

void __Block_byref_object_copy__10(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__10(uint64_t a1)
{
}

CIImage *___ZN2CI16ImageAccumulator3getEb_block_invoke(CIImage *result)
{
  uint64_t v1 = result;
  priv = result[2]._priv;
  if (*((unsigned char *)priv + 96))
  {
    *(void *)(*((void *)result[2].super.isa + 1) + 40) = priv[11];
  }
  else
  {
    __n128 result = +[CIImage imageWithInternalRepresentation:*(void *)priv[10]];
    *(void *)(*((void *)v1[2].super.isa + 1) + 40) = result;
    *((_DWORD *)priv + 25) = 1;
  }
  return result;
}

void CI::ImageAccumulator::set(CI::ImageAccumulator *this, CIImage *a2)
{
  v6[0] = 0;
  v6[1] = v6;
  v6[2] = 0x3052000000;
  v6[3] = __Block_byref_object_copy__10;
  v6[4] = __Block_byref_object_dispose__10;
  uint64_t v7 = 0;
  uint64_t v7 = a2;
  float32x4_t v4 = *((void *)this + 17);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN2CI16ImageAccumulator3setEP7CIImage_block_invoke;
  block[3] = &unk_1E5772158;
  block[5] = v6;
  void block[6] = this;
  block[4] = a2;
  dispatch_async(v4, block);
  _Block_object_dispose(v6, 8);
}

void ___ZN2CI16ImageAccumulator3setEP7CIImage_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  if (*(_DWORD *)(v2 + 100) == 1)
  {
    if (!CGRectIsNull(*(CGRect *)(v2 + 104)) && !*(unsigned char *)(v2 + 96)) {
      CI::ImageAccumulator::sync_content((CI::ImageAccumulator *)v2);
    }
    uint64_t v3 = *(void *)(v2 + 64);
    if (*(void *)(v2 + 80) == v3) {
      uint64_t v3 = *(void *)(v2 + 72);
    }
    *(void *)(v2 + 80) = v3;
  }
  float32x4_t v4 = [[CIRenderDestination alloc] initWithIOSurface:*(void *)(*(void *)(v2 + 80) + 8)];
  [(CIRenderDestination *)v4 setColorSpace:*(void *)(v2 + 32)];
  [(CIRenderDestination *)v4 setBlendKernel:*(void *)(v2 + 56)];
  long long v5 = *(void **)(v2 + 48);
  char v6 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
  [v6 extent];
  double v8 = v7;
  double v10 = v9;
  double v12 = v11;
  double v14 = v13;
  [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) extent];
  objc_msgSend((id)objc_msgSend(v5, "startTaskToRender:fromRect:toDestination:atPoint:error:", v6, v4, 0, v8, v10, v12, v14, v15, v16), "waitUntilCompletedAndReturnError:", 0);

  *(unsigned char *)(v2 + 96) = 0;
  CGFloat v17 = *(double *)(v2 + 104);
  CGFloat v18 = *(double *)(v2 + 112);
  CGFloat v19 = *(double *)(v2 + 120);
  CGFloat v20 = *(double *)(v2 + 128);
  [*(id *)(a1 + 32) extent];
  v28.origin.double x = v21;
  v28.origin.double y = v22;
  v28.size.double width = v23;
  v28.size.double height = v24;
  v27.origin.double x = v17;
  v27.origin.double y = v18;
  v27.size.double width = v19;
  v27.size.double height = v20;
  *(CGRect *)(v2 + 104) = CGRectUnion(v27, v28);
  *(_DWORD *)(v2 + 100) = 2;
  unint64_t v25 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
}

__n128 ___ZN2CI16ImageAccumulator5clearEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  *(unsigned char *)(v1 + 96) = 1;
  __n128 result = *(__n128 *)v1;
  long long v3 = *(_OWORD *)(v1 + 16);
  *(_OWORD *)(v1 + 104) = *(_OWORD *)v1;
  *(_OWORD *)(v1 + 120) = v3;
  return result;
}

void sub_1937BF82C(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10A0C407373CF74);
  _Unwind_Resume(a1);
}

double cikernel::_clearer(cikernel *this)
{
  return 0.0;
}

void CI::ImageAccumulator::Content::~Content(CI::Object **this)
{
  uint64_t v2 = *this;
  if (v2) {
    CI::Object::unref(v2);
  }
  long long v3 = this[1];
  if (v3) {
    CFRelease(v3);
  }
}

uint64_t CGAffineTransformFromObject(uint64_t result, uint64_t a2)
{
  if (!result)
  {
    uint64_t v5 = MEMORY[0x1E4F1DAB8];
    long long v6 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
    *(_OWORD *)a2 = *MEMORY[0x1E4F1DAB8];
    *(_OWORD *)(a2 + 16) = v6;
    long long v7 = *(_OWORD *)(v5 + 32);
LABEL_11:
    *(_OWORD *)(a2 + 32) = v7;
    return result;
  }
  long long v3 = (void *)result;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    float32x4_t v4 = (const char *)[v3 objCType];
    if (!strcmp(v4, "{CGAffineTransform=dddddd}") || (__n128 result = strcmp(v4, "{?=dddddd}"), !result))
    {
      return [v3 getValue:a2 size:48];
    }
    return result;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    __n128 result = [v3 transformStruct];
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    long long v7 = 0u;
    goto LABEL_11;
  }
  objc_opt_class();
  __n128 result = objc_opt_isKindOfClass();
  if (result)
  {
    __n128 result = [v3 count];
    if (result == 6)
    {
      objc_msgSend((id)objc_msgSend(v3, "objectAtIndex:", 0), "doubleValue");
      *(void *)a2 = v8;
      objc_msgSend((id)objc_msgSend(v3, "objectAtIndex:", 1), "doubleValue");
      *(void *)(a2 + 8) = v9;
      objc_msgSend((id)objc_msgSend(v3, "objectAtIndex:", 2), "doubleValue");
      *(void *)(a2 + 16) = v10;
      objc_msgSend((id)objc_msgSend(v3, "objectAtIndex:", 3), "doubleValue");
      *(void *)(a2 + 24) = v11;
      objc_msgSend((id)objc_msgSend(v3, "objectAtIndex:", 4), "doubleValue");
      *(void *)(a2 + 32) = v12;
      __n128 result = objc_msgSend((id)objc_msgSend(v3, "objectAtIndex:", 5), "doubleValue");
      *(void *)(a2 + 40) = v13;
    }
  }
  return result;
}

void sub_1937C38BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void *__gethorizonDetectionFFTAnglesSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)VisionLibrary();
  __n128 result = dlsym(v2, "horizonDetectionFFTAngles");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  gethorizonDetectionFFTAnglesSymbolLoc_ptr = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t VisionLibrary()
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  v2[0] = 0;
  if (!VisionLibraryCore_frameworkLibrary)
  {
    v2[1] = (void *)MEMORY[0x1E4F143A8];
    v2[2] = (void *)3221225472;
    v2[3] = __VisionLibraryCore_block_invoke;
    v2[4] = &__block_descriptor_40_e5_v8__0l;
    v2[5] = v2;
    long long v3 = xmmword_1E57721E8;
    uint64_t v4 = 0;
    VisionLibraryCore_frameworkLibrardouble y = _sl_dlopen();
  }
  uint64_t v0 = VisionLibraryCore_frameworkLibrary;
  if (!VisionLibraryCore_frameworkLibrary) {
    VisionLibrary_cold_1(v2);
  }
  if (v2[0]) {
    free(v2[0]);
  }
  return v0;
}

uint64_t __VisionLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  VisionLibraryCore_frameworkLibrardouble y = result;
  return result;
}

void *__gethorizonDetectionFFTSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)VisionLibrary();
  uint64_t result = dlsym(v2, "horizonDetectionFFT");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  gethorizonDetectionFFTSymbolLoc_ptr = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void sub_1937C4394(_Unwind_Exception *a1)
{
}

void sub_1937C4EA4(_Unwind_Exception *a1)
{
}

void sub_1937C5070(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10F1C4010D716A0);
  _Unwind_Resume(a1);
}

void sub_1937C586C(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10F1C401DCD3065);
  _Unwind_Resume(a1);
}

uint64_t CI::ProcessorImage::format_is_supported(int a1, int a2)
{
  if (a2)
  {
    HIDWORD(v4) = a1 - 274;
    LODWORD(v4) = a1 - 274;
    unsigned int v3 = v4 >> 8;
    if (v3 < 8 && ((0xBFu >> v3) & 1) != 0) {
      return 1;
    }
  }
  uint64_t result = 1;
  if (a1 > 2052)
  {
    if ((a1 - 2053) <= 3 && a1 != 2055) {
      return result;
    }
    unsigned int v6 = a1 - 2309;
    if (v6 <= 3 && v6 != 2) {
      return result;
    }
    return 0;
  }
  if (((a1 - 261) > 5 || ((1 << (a1 - 5)) & 0x23) == 0) && (a1 - 784) >= 2) {
    return 0;
  }
  return result;
}

void sub_1937C5D20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _ZZZ136__CIImage_CIImageProcessor__imageWithExtent_processorDescription_argumentDigest_inputFormat_outputFormat_options_roiCallback_processor__EUb_EN13SignpostTimerD1Ev((TimerBase *)va);
  _Unwind_Resume(a1);
}

void _ZZZ136__CIImage_CIImageProcessor__imageWithExtent_processorDescription_argumentDigest_inputFormat_outputFormat_options_roiCallback_processor__EUb_EN13SignpostTimerD1Ev(TimerBase *a1)
{
  uint64_t v2 = ci_signpost_log_render();
  os_signpost_id_t v3 = *((void *)a1 + 1);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    unint64_t v4 = v2;
    if (os_signpost_enabled(v2))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_signpost_emit_with_name_impl(&dword_193671000, v4, OS_SIGNPOST_INTERVAL_END, v3, "processor_process", "", v5, 2u);
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_1937C5DD8(_Unwind_Exception *a1)
{
  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

void post_process(void *a1, void *a2, uint64_t a3)
{
  if ([a2 metalCommandBufferRequested])
  {
    unsigned int v6 = (void *)[a2 metalCommandBuffer];
    size_t v7 = [a1 count];
    if (v7)
    {
      uint64_t v8 = malloc_type_calloc(8uLL, v7, 0xC0D8C2C5uLL);
      uint64_t v9 = malloc_type_calloc(8uLL, v7, 0xA96C46DDuLL);
      uint64_t v10 = 0;
      unsigned int v11 = 1;
      do
      {
        v8[v10] = objc_msgSend((id)objc_msgSend(a1, "objectAtIndexedSubscript:", v10), "surface");
        v9[v10] = objc_msgSend((id)objc_msgSend(a1, "objectAtIndexedSubscript:", v10), "metalTexture");
        uint64_t v10 = v11;
        BOOL v12 = v7 > v11++;
      }
      while (v12);
    }
    else
    {
      uint64_t v9 = 0;
      uint64_t v8 = 0;
    }
    uint64_t v13 = (const void *)[a2 surface];
    double v14 = (const void *)[a2 metalTexture];
    if (v7)
    {
      uint64_t v15 = 0;
      unsigned int v16 = 1;
      do
      {
        RetainSurfaceFromCache((CFTypeRef)v8[v15]);
        CGFloat v17 = (const void *)v9[v15];
        if (v17) {
          CFRetain(v17);
        }
        uint64_t v15 = v16;
        BOOL v12 = v7 > v16++;
      }
      while (v12);
    }
    RetainSurfaceFromCache(v13);
    CFRetain(v14);
    v18[0] = MEMORY[0x1E4F143A8];
    v18[1] = 3221225472;
    void v18[2] = ___ZL12post_processP7NSArrayIP21CIImageProcessorInputEP22CIImageProcessorOutputPN2CI7ContextE_block_invoke;
    v18[3] = &unk_1E57722C8;
    v18[6] = v8;
    v18[7] = v9;
    v18[8] = v13;
    v18[4] = v14;
    v18[5] = v7;
    CIMetalCommandBufferAddCompletionHandler(v6, (uint64_t)v18);
    if ((*(unsigned int (**)(uint64_t))(*(void *)a3 + 16))(a3) != 77)
    {
      CIMetalCommandBufferCommit(v6);
      CIMetalCommandBufferWaitUntilScheduled(v6);
    }
  }
}

void _ZZZ136__CIImage_CIImageProcessor__imageWithExtent_processorDescription_argumentDigest_inputFormat_outputFormat_options_roiCallback_processor__EUb_EN13SignpostTimerD1E_0v(TimerBase *a1)
{
  uint64_t v2 = ci_signpost_log_render();
  os_signpost_id_t v3 = *((void *)a1 + 1);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    unint64_t v4 = v2;
    if (os_signpost_enabled(v2))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_signpost_emit_with_name_impl(&dword_193671000, v4, OS_SIGNPOST_INTERVAL_END, v3, "processor_postprocess", "", v5, 2u);
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_1937C6060(_Unwind_Exception *a1)
{
  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

void digestAdd(CI::XXHashHelper *a1, objc_object *a2, BOOL *a3)
{
  unint64_t v4 = a2;
  uint64_t v70 = *MEMORY[0x1E4F143B8];
  ClassCFStringRef Name = object_getClassName(a2);
  if ((objc_object *)objc_opt_class() == v4)
  {
LABEL_21:
    *(void *)buf = ClassName;
    goto LABEL_91;
  }
  while (1)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      uint64_t v10 = "null";
      goto LABEL_90;
    }
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      unsigned int v11 = (char *)[(objc_object *)v4 objCType];
      NSUInteger alignp = 0;
      NSUInteger sizep = 0;
      NSGetSizeAndAlignment(v11, &sizep, &alignp);
      if (v11 && (NSUInteger v12 = sizep) != 0)
      {
        if (strchr(v11, 94) || strchr(v11, 42))
        {
          uint64_t v13 = ci_logger_performance();
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "digestAdd";
            __int16 v68 = 2082;
            float32x4_t v69 = v11;
            double v14 = "%{public}s failed for NSValue object because its encoding %{public}s contains a pointer.";
LABEL_83:
            float32x4_t v50 = v13;
            uint32_t v51 = 22;
            goto LABEL_84;
          }
        }
        else
        {
          if (!strchr(v11, 64))
          {
            int32x2_t v54 = (char *)malloc_type_calloc(v12, 1uLL, 0x14F602B1uLL);
            [(objc_object *)v4 getValue:v54 size:sizep];
            *(void *)buf = v11;
            XXH64_update((uint64_t)a1, buf, 8uLL);
            if (v54 && sizep) {
              XXH64_update((uint64_t)a1, v54, sizep);
            }
            free(v54);
            return;
          }
          uint64_t v13 = ci_logger_performance();
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "digestAdd";
            __int16 v68 = 2082;
            float32x4_t v69 = v11;
            double v14 = "%{public}s failed for NSValue object because its encoding %{public}s contains an object.";
            goto LABEL_83;
          }
        }
      }
      else
      {
        float v48 = ci_logger_performance();
        if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "digestAdd";
          double v14 = "%{public}s failed for NSValue object because it has no type encoding information.";
LABEL_80:
          float32x4_t v50 = v48;
          uint32_t v51 = 12;
LABEL_84:
          _os_log_impl(&dword_193671000, v50, OS_LOG_TYPE_DEFAULT, v14, buf, v51);
          goto LABEL_85;
        }
      }
      goto LABEL_85;
    }
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      [(objc_object *)v4 red];
      *(void *)buf = v15;
      XXH64_update((uint64_t)a1, buf, 8uLL);
      [(objc_object *)v4 green];
      *(void *)buf = v16;
      XXH64_update((uint64_t)a1, buf, 8uLL);
      [(objc_object *)v4 blue];
      *(void *)buf = v17;
      XXH64_update((uint64_t)a1, buf, 8uLL);
      [(objc_object *)v4 alpha];
      *(void *)buf = v18;
      goto LABEL_91;
    }
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      uint64_t v19 = [(objc_object *)v4 count];
      if (v19)
      {
        unint64_t v20 = v19;
        uint64_t v21 = 0;
        unsigned int v22 = 1;
        do
        {
          [(objc_object *)v4 valueAtIndex:v21];
          *(void *)buf = v23;
          XXH64_update((uint64_t)a1, buf, 8uLL);
          uint64_t v21 = v22;
        }
        while (v20 > v22++);
        return;
      }
      uint64_t v10 = "emptyCIVector";
LABEL_90:
      *(void *)buf = v10;
      goto LABEL_91;
    }
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      uint64_t v25 = [(objc_object *)v4 _internalRepresentation];
      if (!v25)
      {
        uint64_t v10 = "emptyCIImage";
        goto LABEL_90;
      }
      *(_DWORD *)buf = *(_DWORD *)(v25 + 100);
LABEL_71:
      float v46 = a1;
      size_t v47 = 4;
      goto LABEL_92;
    }
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      uint64_t v26 = [(objc_object *)v4 length];
      if (!v26 || (size_t v27 = v26, (v28 = (char *)[(objc_object *)v4 bytes]) == 0))
      {
        uint64_t v10 = "emptyNSData";
        goto LABEL_90;
      }
LABEL_41:
      XXH64_update((uint64_t)a1, v28, v27);
      return;
    }
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      uint64_t v29 = [(objc_object *)v4 lengthOfBytesUsingEncoding:4];
      if (!v29 || (size_t v27 = v29, (v28 = (char *)[(objc_object *)v4 UTF8String]) == 0))
      {
        uint64_t v10 = "emptyNSString";
        goto LABEL_90;
      }
      goto LABEL_41;
    }
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      uint64_t v30 = [(objc_object *)v4 count];
      if (v30)
      {
        uint64_t v31 = v30;
        for (uint64_t i = 0; i != v31; ++i)
          digestAdd(a1, (objc_object *)[(objc_object *)v4 objectAtIndex:i], a3);
        return;
      }
      uint64_t v10 = "emptyNSArray";
      goto LABEL_90;
    }
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      break;
    }
    CFTypeID v7 = CFGetTypeID(v4);
    if (v7 == CGColorSpaceGetTypeID())
    {
      CFStringRef Name = CGColorSpaceGetName((CGColorSpaceRef)v4);
      if (Name)
      {
        CI::XXHashHelper::add(a1, Name);
        return;
      }
      CFDataRef v52 = CGColorSpaceCopyICCData((CGColorSpaceRef)v4);
      if (v52)
      {
        CFDataRef v53 = v52;
        CI::XXHashHelper::add(a1, v52);
        CFRelease(v53);
        return;
      }
      goto LABEL_85;
    }
    CFTypeID v8 = CFGetTypeID(v4);
    if (v8 == CGImageGetTypeID())
    {
      int Identifier = CGImageGetIdentifier();
      if (!Identifier) {
        return;
      }
      *(_DWORD *)buf = Identifier;
      goto LABEL_71;
    }
    if ([(objc_object *)v4 conformsToProtocol:&unk_1EE4D26A8])
    {
      *(void *)buf = [(objc_object *)v4 uniqueIdentifier];
LABEL_91:
      float v46 = a1;
      size_t v47 = 8;
LABEL_92:
      XXH64_update((uint64_t)v46, buf, v47);
      return;
    }
    NSClassFromString(&cfstr_Mlmodel.isa);
    if ((objc_opt_isKindOfClass() & 1) == 0)
    {
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        SEL v9 = NSSelectorFromString(&cfstr_Ciimageprocess_9.isa);
        if (objc_opt_respondsToSelector())
        {
          unint64_t v4 = (objc_object *)[(objc_object *)v4 performSelector:v9];
          if (v4) {
            goto LABEL_20;
          }
        }
        uint64_t v13 = ci_logger_performance();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_82;
        }
      }
      else
      {
        uint64_t v13 = ci_logger_performance();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
LABEL_82:
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "digestAdd";
          __int16 v68 = 2082;
          float32x4_t v69 = (void *)ClassName;
          double v14 = "%{public}s failed for %{public}s object.";
          goto LABEL_83;
        }
      }
LABEL_85:
      *a3 = 1;
      return;
    }
    unint64_t v4 = (objc_object *)[(objc_object *)v4 valueForKeyPath:@"configuration.rootModelURL.absoluteString"];
    if (!v4)
    {
      float v48 = ci_logger_performance();
      if (!os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_85;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "digestAdd";
      double v14 = "%{public}s failed forMLModel object because it doesnt have a root URL.";
      goto LABEL_80;
    }
LABEL_20:
    ClassCFStringRef Name = object_getClassName(v4);
    if ((objc_object *)objc_opt_class() == v4) {
      goto LABEL_21;
    }
  }
  if (![(objc_object *)v4 count])
  {
    uint64_t v10 = "emptyNSDictionary";
    goto LABEL_90;
  }
  CGFloat v33 = (void *)[(objc_object *)v4 allKeys];
  long long v59 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  uint64_t v34 = [v33 countByEnumeratingWithState:&v59 objects:v66 count:16];
  if (v34)
  {
    uint64_t v35 = v34;
    uint64_t v36 = *(void *)v60;
LABEL_51:
    uint64_t v37 = 0;
    while (1)
    {
      if (*(void *)v60 != v36) {
        objc_enumerationMutation(v33);
      }
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0) {
        goto LABEL_85;
      }
      if (v35 == ++v37)
      {
        uint64_t v35 = [v33 countByEnumeratingWithState:&v59 objects:v66 count:16];
        if (v35) {
          goto LABEL_51;
        }
        break;
      }
    }
  }
  uint64_t v38 = (void *)[v33 sortedArrayUsingSelector:sel_compare_];
  long long v55 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  uint64_t v39 = [v38 countByEnumeratingWithState:&v55 objects:v65 count:16];
  if (v39)
  {
    uint64_t v40 = v39;
    uint64_t v41 = *(void *)v56;
    do
    {
      for (uint64_t j = 0; j != v40; ++j)
      {
        if (*(void *)v56 != v41) {
          objc_enumerationMutation(v38);
        }
        float32x4_t v43 = *(objc_object **)(*((void *)&v55 + 1) + 8 * j);
        digestAdd(a1, v43, a3);
        digestAdd(a1, (objc_object *)[(objc_object *)v4 objectForKey:v43], a3);
      }
      uint64_t v40 = [v38 countByEnumeratingWithState:&v55 objects:v65 count:16];
    }
    while (v40);
  }
}

void sub_1937C73DC(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10A0C401BD4BA38);
  _Unwind_Resume(a1);
}

void sub_1937C75E4(_Unwind_Exception *exception_object)
{
  os_signpost_id_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1937C81B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char *__p,uint64_t a32,uint64_t a33,char a34)
{
  _ZZZ65__CIImageProcessorKernel_applyWithExtent_inputs_arguments_error__EUb0_EN13SignpostTimerD1E_0v((TimerBase *)(v34 - 208));
  __p = &a34;
  std::vector<std::vector<IRect>>::__destroy_vector::operator()[abi:nn180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

void _ZZZ65__CIImageProcessorKernel_applyWithExtent_inputs_arguments_error__EUb0_EN13SignpostTimerD1Ev(TimerBase *a1)
{
  uint64_t v2 = ci_signpost_log_render();
  os_signpost_id_t v3 = *((void *)a1 + 1);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    unint64_t v4 = v2;
    if (os_signpost_enabled(v2))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_signpost_emit_with_name_impl(&dword_193671000, v4, OS_SIGNPOST_INTERVAL_END, v3, "processor_process", "", v5, 2u);
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_1937C82C4(_Unwind_Exception *a1)
{
  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

void _ZZZ65__CIImageProcessorKernel_applyWithExtent_inputs_arguments_error__EUb0_EN13SignpostTimerD1E_0v(TimerBase *a1)
{
  uint64_t v2 = ci_signpost_log_render();
  os_signpost_id_t v3 = *((void *)a1 + 1);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    unint64_t v4 = v2;
    if (os_signpost_enabled(v2))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_signpost_emit_with_name_impl(&dword_193671000, v4, OS_SIGNPOST_INTERVAL_END, v3, "processor_postprocess", "", v5, 2u);
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_1937C8364(_Unwind_Exception *a1)
{
  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

void ___ZL12post_processP7NSArrayIP21CIImageProcessorInputEP22CIImageProcessorOutputPN2CI7ContextE_block_invoke(void *a1)
{
  if (a1[5])
  {
    uint64_t v2 = 0;
    unsigned int v3 = 1;
    do
    {
      ReturnSurfaceToCache(*(void *)(a1[6] + 8 * v2));
      unint64_t v4 = *(const void **)(a1[7] + 8 * v2);
      if (v4) {
        CFRelease(v4);
      }
      uint64_t v2 = v3;
    }
    while (a1[5] > (unint64_t)v3++);
  }
  unsigned int v6 = (void *)a1[6];
  if (v6) {
    free(v6);
  }
  CFTypeID v7 = (void *)a1[7];
  if (v7) {
    free(v7);
  }
  ReturnSurfaceToCache(a1[8]);
  CFTypeID v8 = (const void *)a1[4];

  CFRelease(v8);
}

void sub_1937C97F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,uint64_t a39,void *__p,uint64_t a41)
{
  *(void *)(v41 - 176) = v41 - 144;
  std::vector<std::vector<IRect>>::__destroy_vector::operator()[abi:nn180100]((void ***)(v41 - 176));
  _Unwind_Resume(a1);
}

void CI::Tileable::TileRectGridMakeEqualSizedTilesWithImageSize(unint64_t this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  unint64_t v9 = this + a3 - 1;
  unint64_t v10 = v9 / this;
  std::vector<std::vector<CGRect>>::vector(a5, v9 / this);
  if (v9 >= this)
  {
    uint64_t v11 = 0;
    unint64_t v12 = a2 + a4 - 1;
    if (v12 / a2 <= 1) {
      uint64_t v13 = 1;
    }
    else {
      uint64_t v13 = v12 / a2;
    }
    uint64_t v20 = v13;
    if (v10 <= 1) {
      unint64_t v10 = 1;
    }
    do
    {
      std::vector<std::vector<CGRect>>::vector(&v21, v12 / a2);
      uint64_t v14 = *a5;
      uint64_t v15 = *a5 + 24 * v11;
      uint64_t v16 = *(void **)v15;
      if (*(void *)v15)
      {
        *(void *)(v14 + 24 * v11 + 8) = v16;
        operator delete(v16);
        *(void *)uint64_t v15 = 0;
        *(void *)(v15 + 8) = 0;
        *(void *)(v15 + 16) = 0;
      }
      *(_OWORD *)uint64_t v15 = v21;
      *(void *)(v14 + 24 * v11 + 16) = v22;
      if (v12 >= a2)
      {
        int v17 = 0;
        uint64_t v18 = (unint64_t *)(*(void *)(*a5 + 24 * v11) + 8);
        uint64_t v19 = v20;
        do
        {
          *((_DWORD *)v18 - 2) = v11 * this;
          *((_DWORD *)v18 - 1) = v17;
          v17 += a2;
          *uint64_t v18 = this;
          v18[1] = a2;
          v18 += 3;
          --v19;
        }
        while (v19);
      }
      ++v11;
    }
    while (v11 != v10);
  }
}

void sub_1937C9A44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::vector<std::vector<IRect>>::__destroy_vector::operator()[abi:nn180100]((void ***)va);
  _Unwind_Resume(a1);
}

void CI::Tileable::TileRectGridMakeFromWidthAndHeightArrays(uint64_t *a1@<X0>, int **a2@<X1>, uint64_t *a3@<X8>)
{
  std::vector<std::vector<CGRect>>::vector(a3, (a1[1] - *a1) >> 3);
  if (a1[1] != *a1)
  {
    unint64_t v6 = 0;
    int v7 = 0;
    unint64_t v9 = *a2;
    CFTypeID v8 = a2[1];
    do
    {
      std::vector<std::vector<CGRect>>::vector(&v21, ((char *)v8 - (char *)v9) >> 3);
      uint64_t v10 = *a3;
      uint64_t v11 = *a3 + 24 * v6;
      unint64_t v12 = *(void **)v11;
      if (*(void *)v11)
      {
        *(void *)(v10 + 24 * v6 + 8) = v12;
        operator delete(v12);
        *(void *)uint64_t v11 = 0;
        *(void *)(v11 + 8) = 0;
        *(void *)(v11 + 16) = 0;
      }
      *(_OWORD *)uint64_t v11 = v21;
      *(void *)(v10 + 24 * v6 + 16) = v22;
      unint64_t v9 = *a2;
      CFTypeID v8 = a2[1];
      uint64_t v13 = *a1;
      if (v8 != *a2)
      {
        int v14 = 0;
        unint64_t v15 = ((char *)v8 - (char *)*a2) >> 3;
        if (v15 <= 1) {
          unint64_t v15 = 1;
        }
        uint64_t v16 = (void *)(*(void *)(*a3 + 24 * v6) + 8);
        int v17 = *a2;
        do
        {
          uint64_t v18 = *(void *)(v13 + 8 * v6);
          uint64_t v19 = *(void *)v17;
          *((_DWORD *)v16 - 2) = v7;
          *((_DWORD *)v16 - 1) = v14;
          *uint64_t v16 = v18;
          v16[1] = v19;
          v16 += 3;
          int v20 = *v17;
          v17 += 2;
          v14 += v20;
          --v15;
        }
        while (v15);
      }
      v7 += *(void *)(v13 + 8 * v6++);
    }
    while (v6 < (a1[1] - v13) >> 3);
  }
}

void sub_1937C9B8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

uint64_t getContentDigestFromOptions(NSDictionary *a1, NSString *a2)
{
  id v2 = [(NSDictionary *)a1 objectForKey:a2];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    if ((unint64_t)[v2 length] >= 0x10)
    {
      XXH64_reset(v10, 0);
      uint64_t v3 = [v2 bytes];
      uint64_t v4 = [v2 length];
      if (!v3) {
        return XXH64_digest((uint64_t)v10);
      }
      size_t v5 = v4;
      if (!v4) {
        return XXH64_digest((uint64_t)v10);
      }
      p_vImage_Buffer src = (char *)v3;
LABEL_15:
      XXH64_update((uint64_t)v10, p_src, v5);
      return XXH64_digest((uint64_t)v10);
    }
    CFTypeID v8 = ci_logger_api();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      getContentDigestFromOptions();
    }
    return 0;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      if ((unint64_t)[v2 length] >= 0x10)
      {
        XXH64_reset(v10, 0);
        __vImage_Buffer src = [v2 UTF8String];
        p_vImage_Buffer src = (char *)&__src;
        size_t v5 = 8;
        goto LABEL_15;
      }
      unint64_t v9 = ci_logger_api();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        getContentDigestFromOptions();
      }
    }
    return 0;
  }

  return [v2 unsignedLongLongValue];
}

void sub_1937C9D64(void *a1)
{
  objc_begin_catch(a1);
  objc_end_catch();
}

void ___ZL18max_safe_tile_sizev_block_invoke()
{
  id v2 = MTLCreateSystemDefaultDevice();
  unint64_t v0 = [v2 maxTextureWidth2D];
  if (v0 >= [v2 maxTextureHeight2D]) {
    uint64_t v1 = [v2 maxTextureHeight2D];
  }
  else {
    uint64_t v1 = [v2 maxTextureWidth2D];
  }
  max_safe_tile_size(void)::max_size = v1;
}

void std::vector<std::vector<IRect>>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<std::vector<IRect>>::__clear[abi:nn180100](a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void *std::vector<std::vector<IRect>>::__init_with_size[abi:nn180100]<std::vector<IRect>*,std::vector<IRect>*>(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    std::vector<CI::SWRendererFunctionInputNode>::__vallocate[abi:nn180100](result, a4);
    return std::vector<std::vector<IRect>>::__construct_at_end<std::vector<IRect>*,std::vector<IRect>*>(v6, a2, a3);
  }
  return result;
}

void *std::vector<std::vector<IRect>>::__construct_at_end<std::vector<IRect>*,std::vector<IRect>*>(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result;
  uint64_t v4 = result[1];
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t result = std::vector<IRect>::vector((void *)(v4 + v7), a2 + v7);
      v7 += 24;
    }
    while (a2 + v7 != a3);
    v4 += v7;
  }
  v3[1] = v4;
  return result;
}

void sub_1937C9F00(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void *std::vector<IRect>::vector(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *(const void **)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  int64_t v5 = v3 - *(void *)a2;
  if (v3 != *(void *)a2)
  {
    std::vector<CI::SWRendererFunctionInputNode>::__vallocate[abi:nn180100](a1, 0xAAAAAAAAAAAAAAABLL * (v5 >> 3));
    unint64_t v6 = (char *)a1[1];
    memmove(v6, v4, v5);
    a1[1] = &v6[v5];
  }
  return a1;
}

CIImage *applyColorMatrix(CIImage *a1, double *a2, double *a3, double *a4, double *a5)
{
  int64_t v5 = a1;
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    [(CIImage *)a1 extent];
    if (!CGRectIsEmpty(v27))
    {
      long long v12 = *(_OWORD *)a2;
      uint64_t v13 = *((void *)a2 + 2);
      uint64_t v14 = 0;
      long long v15 = *(_OWORD *)a3;
      uint64_t v16 = *((void *)a3 + 2);
      uint64_t v17 = 0;
      long long v18 = *(_OWORD *)a4;
      uint64_t v19 = *((void *)a4 + 2);
      uint64_t v20 = 0;
      long long v21 = xmmword_193954318;
      long long v22 = unk_193954328;
      long long v23 = *(_OWORD *)a5;
      uint64_t v24 = *((void *)a5 + 2);
      uint64_t v25 = 0;
      if (!CI::ColorMatrixImage::is_identity((CI::ColorMatrixImage *)&v12, v10))
      {
        [(CIImage *)v5 _internalRepresentation];
        operator new();
      }
      return v5;
    }
  }
  return v5;
}

void sub_1937CB08C(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C40112EC1AALL);
  _Unwind_Resume(a1);
}

__n64 cikernel::_yccCombiner(double a1, float a2)
{
  result.n64_f32[1] = a2;
  return result;
}

float addPixel<float>(float *a1, float *a2)
{
  if (a2)
  {
    float v2 = a1[1];
    *a1 = *a2 + *a1;
    a1[1] = a2[1] + v2;
    float v3 = a1[3];
    a1[2] = a2[2] + a1[2];
    float result = a2[3] + v3;
    a1[3] = result;
  }
  return result;
}

BOOL ClipSegmentToHalfplane(float a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float *a9, float *a10, float *a11, float *a12)
{
  float v12 = (float)((float)(a2 - a6) * a8) + (float)((float)(a1 - a5) * a7);
  float v13 = (float)((float)(a4 - a6) * a8) + (float)((float)(a3 - a5) * a7);
  BOOL v14 = v13 > 0.0 || v12 > 0.0;
  if (v14)
  {
    if (v12 <= 0.0 || v13 <= 0.0)
    {
      if (v12 <= 0.0)
      {
        float v16 = v13 / (float)(v13 - v12);
        a1 = a3 + (float)((float)(a1 - a3) * v16);
        a2 = a4 + (float)((float)(a2 - a4) * v16);
      }
      else
      {
        float v15 = v12 / (float)(v12 - v13);
        a3 = a1 + (float)((float)(a3 - a1) * v15);
        a4 = a2 + (float)((float)(a4 - a2) * v15);
      }
    }
    *a9 = a1;
    *a10 = a2;
    *a11 = a3;
    *a12 = a4;
  }
  return v14;
}

float32x2_t cikernel::_kaleida(CI *a1, float32x4_t a2, int8x16_t a3, int8x16_t a4)
{
  float v4 = a2.f32[2];
  float32x2_t v5 = vsub_f32(*(float32x2_t *)CI::getDC(a1), *(float32x2_t *)a2.f32);
  float v6 = vaddv_f32(vmul_f32(*(float32x2_t *)a3.i8, v5));
  float v7 = fabsf(vaddv_f32(vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v5)));
  float v8 = floor(vmuls_lane_f32(atan2f(v7, v6), a2, 3) + 0.5) * (float)-v4;
  float v9 = 3.1416 - v8;
  if (v8 <= 1.5708) {
    float v9 = v8;
  }
  if (v9 < -1.5708) {
    float v9 = -3.1416 - v9;
  }
  float v10 = v9 * (float)(v9 * v9);
  float v11 = v9
      + v10 / -6.0
      + (float)(v9 * (float)(v9 * v10)) / 120.0
      + (float)(v9 * (float)(v9 * (float)(v9 * (float)(v9 * v10)))) / -5040.0
      + (float)(v9 * (float)(v9 * (float)(v9 * (float)(v9 * (float)(v9 * (float)(v9 * v10)))))) / 362880.0;
  float v12 = fabsf(v8);
  BOOL v13 = v12 <= 1.5708;
  if (v12 > 1.5708) {
    float v12 = 3.1416 - v12;
  }
  float v14 = ((((float)(v12 * v12) * 0.0000248015873 + -0.00138888889) * (float)(v12 * v12) + 0.0416666667)
       * (float)(v12 * v12)
       + -0.5)
      * (float)(v12 * v12)
      + 1.0;
  if (!v13) {
    float v14 = -v14;
  }
  v15.f32[0] = (float)(v6 * v14) - (float)(v7 * v11);
  v15.i32[1] = fabsf((float)(v7 * v14) + (float)(v6 * v11));
  int32x2_t v16 = (int32x2_t)vmul_f32(*(float32x2_t *)a4.i8, v15);
  int32x2_t v17 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v15);
  return vadd_f32(*(float32x2_t *)a2.f32, vadd_f32((float32x2_t)vzip1_s32(v16, v17), (float32x2_t)vzip2_s32(v16, v17)));
}

void CI::f2_f4_f4_f4(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  float v11 = (double (*)(void *, __n128, __n128, __n128))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  int v14 = *(_DWORD *)(v10 + 40);
  uint64_t v15 = *(void *)(v10 + 32);
  int v16 = *(_DWORD *)(v10 + 64);
  uint64_t v17 = *(void *)(v10 + 56);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 80)), a2);
  }
  long long v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5) {
    long long v18 = (__n128 *)((char *)a2 + 64 * v17);
  }
  uint64_t v19 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5) {
    uint64_t v19 = (__n128 *)((char *)a2 + 64 * v15);
  }
  uint64_t v20 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    uint64_t v20 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)(a3 + 16 * a7) = v11(a1, *v20, *v19, *v18);
}

BOOL CIKernelReflection::reflect(CIKernelReflection *this, uint64_t a2, uint64_t a3, NSError **a4)
{
  uint64_t v198 = *MEMORY[0x1E4F143B8];
  KernelByIddouble x = fosl_filter_kernelpool_getKernelByIdx(a2, a3);
  if (!KernelByIdx)
  {
    CIKernelError(a4, 4u, &cfstr_NoValidKernels.isa);
    int v12 = ci_logger_compile();
    BOOL result = os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    goto LABEL_10;
  }
  uint64_t v7 = KernelByIdx;
  this->var2 = (char *)fosl_filter_kernelpool_getKernelName(KernelByIdx);
  PrintedKernel = (char *)fosl_filter_kernelpool_getPrintedKernel(v7);
  this->var3 = PrintedKernel;
  if (this->var2) {
    BOOL v9 = PrintedKernel == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (v9)
  {
    CIKernelError(a4, 4u, &cfstr_NoValidKernels.isa);
    uint64_t v10 = ci_logger_compile();
    BOOL result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
LABEL_10:
    CIKernelReflection::reflect();
    return 0;
  }
  if (FOSL_PRINT_KERNEL_AST()) {
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "Printed AST of kernel %s:\n%s\n", this->var2, this->var3);
  }
  unsigned int KernelKind = fosl_filter_kernelpool_getKernelKind(v7);
  if (KernelKind <= 2) {
    this->var0 = dword_193954400[KernelKind];
  }
  int KernelReturnType = fosl_filter_kernelpool_getKernelReturnType(v7);
  switch(KernelReturnType)
  {
    case 1:
      int v16 = 1;
      goto LABEL_22;
    case 3:
      int v16 = 2;
      goto LABEL_22;
    case 19:
      int v16 = 3;
LABEL_22:
      this->var1 = v16;
      break;
  }
  unsigned int NumKernelParameters = fosl_filter_kernelpool_getNumKernelParameters(v7);
  p_var5 = &this->var5;
  std::vector<CI::KernelArgumentType>::reserve((void **)&this->var5.var0, NumKernelParameters);
  p_var6 = &this->var6;
  std::vector<std::string>::reserve((std::vector<std::string> *)&this->var6, NumKernelParameters);
  if (NumKernelParameters)
  {
    v192 = a4;
    uint64_t v20 = 0;
    char v193 = 0;
    p_var2 = &this->var5.var2;
    while (2)
    {
      ParamCFStringRef Name = (char *)fosl_filter_kernelpool_getParamName(v7, v20);
      std::string::basic_string[abi:nn180100]<0>(&__p, ParamName);
      var1 = (char *)this->var6.var1;
      var0 = (char *)this->var6.var2.var0;
      if (var1 >= var0)
      {
        unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * ((var1 - (char *)p_var6->var0) >> 3);
        unint64_t v26 = v25 + 1;
        if (v25 + 1 > 0xAAAAAAAAAAAAAAALL) {
          abort();
        }
        unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((var0 - (char *)p_var6->var0) >> 3);
        if (2 * v27 > v26) {
          unint64_t v26 = 2 * v27;
        }
        if (v27 >= 0x555555555555555) {
          unint64_t v28 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v28 = v26;
        }
        __s.__end_cap_.__value_ = (std::allocator<std::string> *)&this->var6.var2;
        if (v28) {
          uint64_t v29 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SWRendererFunctionInputNode>>((uint64_t)&this->var6.var2, v28);
        }
        else {
          uint64_t v29 = 0;
        }
        uint64_t v30 = &v29[24 * v25];
        long long v31 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
        *((void *)v30 + 2) = *((void *)&__p.__r_.__value_.__l + 2);
        *(_OWORD *)uint64_t v30 = v31;
        memset(&__p, 0, sizeof(__p));
        CGFloat v33 = (char *)this->var6.var0;
        uint64_t v32 = (char *)this->var6.var1;
        if (v32 == v33)
        {
          int64x2_t v36 = vdupq_n_s64((unint64_t)v32);
          uint64_t v34 = &v29[24 * v25];
        }
        else
        {
          uint64_t v34 = &v29[24 * v25];
          do
          {
            long long v35 = *(_OWORD *)(v32 - 24);
            *((void *)v34 - 1) = *((void *)v32 - 1);
            *(_OWORD *)(v34 - 24) = v35;
            v34 -= 24;
            *((void *)v32 - 2) = 0;
            *((void *)v32 - 1) = 0;
            *((void *)v32 - 3) = 0;
            v32 -= 24;
          }
          while (v32 != v33);
          int64x2_t v36 = *(int64x2_t *)&p_var6->var0;
        }
        uint64_t v37 = v30 + 24;
        this->var6.var0 = v34;
        this->var6.var1 = v30 + 24;
        *(int64x2_t *)&__s.__begin_ = v36;
        uint64_t v38 = (std::string *)this->var6.var2.var0;
        this->var6.var2.var0 = &v29[24 * v28];
        __s.__end_cap_.__value_ = v38;
        __s.__first_ = (std::__split_buffer<std::string>::pointer)v36.i64[0];
        std::__split_buffer<std::string>::~__split_buffer(&__s);
        int v39 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
        this->var6.var1 = v37;
        if (v39 < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }
      else
      {
        long long v24 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
        *((void *)var1 + 2) = *((void *)&__p.__r_.__value_.__l + 2);
        *(_OWORD *)var1 = v24;
        this->var6.var1 = var1 + 24;
      }
      switch(fosl_filter_kernelpool_getParamType(v7, v20))
      {
        case 0u:
          uint64_t v41 = this->var5.var1;
          uint64_t v40 = this->var5.var2.var0;
          if (v41 < v40)
          {
            int v42 = 5;
            goto LABEL_90;
          }
          int8x16_t v73 = p_var5->var0;
          uint64_t v97 = v41 - p_var5->var0;
          unint64_t v98 = v97 + 1;
          if ((unint64_t)(v97 + 1) >> 62) {
            abort();
          }
          uint64_t v99 = (char *)v40 - (char *)v73;
          if (v99 >> 1 > v98) {
            unint64_t v98 = v99 >> 1;
          }
          if ((unint64_t)v99 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v77 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v77 = v98;
          }
          if (v77)
          {
            float v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
            int8x16_t v73 = this->var5.var0;
            uint64_t v41 = this->var5.var1;
          }
          else
          {
            float v78 = 0;
          }
          float32x4_t v151 = (int *)&v78[4 * v97];
          *float32x4_t v151 = 5;
          int8x16_t v72 = v151 + 1;
          while (v41 != v73)
          {
            int v159 = *--v41;
            *--float32x4_t v151 = v159;
          }
          goto LABEL_365;
        case 1u:
          uint64_t v41 = this->var5.var1;
          uint32_t v51 = this->var5.var2.var0;
          if (v41 < v51)
          {
            int v42 = 6;
            goto LABEL_90;
          }
          int8x16_t v73 = p_var5->var0;
          uint64_t v94 = v41 - p_var5->var0;
          unint64_t v95 = v94 + 1;
          if ((unint64_t)(v94 + 1) >> 62) {
            abort();
          }
          uint64_t v96 = (char *)v51 - (char *)v73;
          if (v96 >> 1 > v95) {
            unint64_t v95 = v96 >> 1;
          }
          if ((unint64_t)v96 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v77 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v77 = v95;
          }
          if (v77)
          {
            float v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
            int8x16_t v73 = this->var5.var0;
            uint64_t v41 = this->var5.var1;
          }
          else
          {
            float v78 = 0;
          }
          float32x4_t v151 = (int *)&v78[4 * v94];
          *float32x4_t v151 = 6;
          int8x16_t v72 = v151 + 1;
          while (v41 != v73)
          {
            int v158 = *--v41;
            *--float32x4_t v151 = v158;
          }
          goto LABEL_365;
        case 2u:
          uint64_t v41 = this->var5.var1;
          int32x2_t v54 = this->var5.var2.var0;
          if (v41 < v54)
          {
            int v42 = 7;
            goto LABEL_90;
          }
          int8x16_t v73 = p_var5->var0;
          uint64_t v106 = v41 - p_var5->var0;
          unint64_t v107 = v106 + 1;
          if ((unint64_t)(v106 + 1) >> 62) {
            abort();
          }
          uint64_t v108 = (char *)v54 - (char *)v73;
          if (v108 >> 1 > v107) {
            unint64_t v107 = v108 >> 1;
          }
          if ((unint64_t)v108 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v77 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v77 = v107;
          }
          if (v77)
          {
            float v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
            int8x16_t v73 = this->var5.var0;
            uint64_t v41 = this->var5.var1;
          }
          else
          {
            float v78 = 0;
          }
          float32x4_t v151 = (int *)&v78[4 * v106];
          *float32x4_t v151 = 7;
          int8x16_t v72 = v151 + 1;
          while (v41 != v73)
          {
            int v162 = *--v41;
            *--float32x4_t v151 = v162;
          }
          goto LABEL_365;
        case 3u:
          uint64_t v41 = this->var5.var1;
          CFDataRef v52 = this->var5.var2.var0;
          if (v41 < v52)
          {
            int v42 = 8;
            goto LABEL_90;
          }
          int8x16_t v73 = p_var5->var0;
          uint64_t v100 = v41 - p_var5->var0;
          unint64_t v101 = v100 + 1;
          if ((unint64_t)(v100 + 1) >> 62) {
            abort();
          }
          uint64_t v102 = (char *)v52 - (char *)v73;
          if (v102 >> 1 > v101) {
            unint64_t v101 = v102 >> 1;
          }
          if ((unint64_t)v102 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v77 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v77 = v101;
          }
          if (v77)
          {
            float v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
            int8x16_t v73 = this->var5.var0;
            uint64_t v41 = this->var5.var1;
          }
          else
          {
            float v78 = 0;
          }
          float32x4_t v151 = (int *)&v78[4 * v100];
          *float32x4_t v151 = 8;
          int8x16_t v72 = v151 + 1;
          while (v41 != v73)
          {
            int v160 = *--v41;
            *--float32x4_t v151 = v160;
          }
          goto LABEL_365;
        case 4u:
          uint64_t v41 = this->var5.var1;
          long long v58 = this->var5.var2.var0;
          if (v41 < v58)
          {
            int v42 = 27;
            goto LABEL_90;
          }
          int8x16_t v73 = p_var5->var0;
          uint64_t v118 = v41 - p_var5->var0;
          unint64_t v119 = v118 + 1;
          if ((unint64_t)(v118 + 1) >> 62) {
            abort();
          }
          uint64_t v120 = (char *)v58 - (char *)v73;
          if (v120 >> 1 > v119) {
            unint64_t v119 = v120 >> 1;
          }
          if ((unint64_t)v120 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v77 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v77 = v119;
          }
          if (v77)
          {
            float v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
            int8x16_t v73 = this->var5.var0;
            uint64_t v41 = this->var5.var1;
          }
          else
          {
            float v78 = 0;
          }
          float32x4_t v151 = (int *)&v78[4 * v118];
          *float32x4_t v151 = 27;
          int8x16_t v72 = v151 + 1;
          while (v41 != v73)
          {
            int v166 = *--v41;
            *--float32x4_t v151 = v166;
          }
          goto LABEL_365;
        case 5u:
          uint64_t v41 = this->var5.var1;
          float32x4_t v50 = this->var5.var2.var0;
          if (v41 < v50)
          {
            int v42 = 10;
            goto LABEL_90;
          }
          int8x16_t v73 = p_var5->var0;
          uint64_t v91 = v41 - p_var5->var0;
          unint64_t v92 = v91 + 1;
          if ((unint64_t)(v91 + 1) >> 62) {
            abort();
          }
          uint64_t v93 = (char *)v50 - (char *)v73;
          if (v93 >> 1 > v92) {
            unint64_t v92 = v93 >> 1;
          }
          if ((unint64_t)v93 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v77 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v77 = v92;
          }
          if (v77)
          {
            float v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
            int8x16_t v73 = this->var5.var0;
            uint64_t v41 = this->var5.var1;
          }
          else
          {
            float v78 = 0;
          }
          float32x4_t v151 = (int *)&v78[4 * v91];
          *float32x4_t v151 = 10;
          int8x16_t v72 = v151 + 1;
          while (v41 != v73)
          {
            int v157 = *--v41;
            *--float32x4_t v151 = v157;
          }
          goto LABEL_365;
        case 6u:
          uint64_t v41 = this->var5.var1;
          long long v57 = this->var5.var2.var0;
          if (v41 < v57)
          {
            int v42 = 11;
            goto LABEL_90;
          }
          int8x16_t v73 = p_var5->var0;
          uint64_t v115 = v41 - p_var5->var0;
          unint64_t v116 = v115 + 1;
          if ((unint64_t)(v115 + 1) >> 62) {
            abort();
          }
          uint64_t v117 = (char *)v57 - (char *)v73;
          if (v117 >> 1 > v116) {
            unint64_t v116 = v117 >> 1;
          }
          if ((unint64_t)v117 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v77 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v77 = v116;
          }
          if (v77)
          {
            float v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
            int8x16_t v73 = this->var5.var0;
            uint64_t v41 = this->var5.var1;
          }
          else
          {
            float v78 = 0;
          }
          float32x4_t v151 = (int *)&v78[4 * v115];
          *float32x4_t v151 = 11;
          int8x16_t v72 = v151 + 1;
          while (v41 != v73)
          {
            int v165 = *--v41;
            *--float32x4_t v151 = v165;
          }
          goto LABEL_365;
        case 7u:
          uint64_t v41 = this->var5.var1;
          float v67 = this->var5.var2.var0;
          if (v41 < v67)
          {
            int v42 = 19;
            goto LABEL_90;
          }
          int8x16_t v73 = p_var5->var0;
          uint64_t v139 = v41 - p_var5->var0;
          unint64_t v140 = v139 + 1;
          if ((unint64_t)(v139 + 1) >> 62) {
            abort();
          }
          uint64_t v141 = (char *)v67 - (char *)v73;
          if (v141 >> 1 > v140) {
            unint64_t v140 = v141 >> 1;
          }
          if ((unint64_t)v141 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v77 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v77 = v140;
          }
          if (v77)
          {
            float v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
            int8x16_t v73 = this->var5.var0;
            uint64_t v41 = this->var5.var1;
          }
          else
          {
            float v78 = 0;
          }
          float32x4_t v151 = (int *)&v78[4 * v139];
          *float32x4_t v151 = 19;
          int8x16_t v72 = v151 + 1;
          while (v41 != v73)
          {
            int v173 = *--v41;
            *--float32x4_t v151 = v173;
          }
          goto LABEL_365;
        case 8u:
          uint64_t v41 = this->var5.var1;
          CFDataRef v53 = this->var5.var2.var0;
          if (v41 < v53)
          {
            int v42 = 4;
            goto LABEL_90;
          }
          int8x16_t v73 = p_var5->var0;
          uint64_t v103 = v41 - p_var5->var0;
          unint64_t v104 = v103 + 1;
          if ((unint64_t)(v103 + 1) >> 62) {
            abort();
          }
          uint64_t v105 = (char *)v53 - (char *)v73;
          if (v105 >> 1 > v104) {
            unint64_t v104 = v105 >> 1;
          }
          if ((unint64_t)v105 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v77 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v77 = v104;
          }
          if (v77)
          {
            float v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
            int8x16_t v73 = this->var5.var0;
            uint64_t v41 = this->var5.var1;
          }
          else
          {
            float v78 = 0;
          }
          float32x4_t v151 = (int *)&v78[4 * v103];
          *float32x4_t v151 = 4;
          int8x16_t v72 = v151 + 1;
          while (v41 != v73)
          {
            int v161 = *--v41;
            *--float32x4_t v151 = v161;
          }
          goto LABEL_365;
        case 9u:
          float32x4_t v64 = this->var5.var1;
          float v63 = this->var5.var2.var0;
          if (v64 < v63)
          {
            int v65 = 1;
            goto LABEL_87;
          }
          CGAffineTransform v130 = p_var5->var0;
          uint64_t v131 = v64 - p_var5->var0;
          unint64_t v132 = v131 + 1;
          if ((unint64_t)(v131 + 1) >> 62) {
            abort();
          }
          uint64_t v133 = (char *)v63 - (char *)v130;
          if (v133 >> 1 > v132) {
            unint64_t v132 = v133 >> 1;
          }
          if ((unint64_t)v133 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v134 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v134 = v132;
          }
          if (v134)
          {
            Rectangle v135 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v134);
            CGAffineTransform v130 = this->var5.var0;
            float32x4_t v64 = this->var5.var1;
          }
          else
          {
            Rectangle v135 = 0;
          }
          CGRect v170 = (int *)&v135[4 * v131];
          *CGRect v170 = 1;
          uint64_t v70 = v170 + 1;
          while (v64 != v130)
          {
            int v171 = *--v64;
            *--CGRect v170 = v171;
          }
          goto LABEL_357;
        case 0xAu:
          this->var13 = 1;
          float32x4_t v64 = this->var5.var1;
          float32x4_t v69 = this->var5.var2.var0;
          if (v64 >= v69)
          {
            CGAffineTransform v130 = p_var5->var0;
            uint64_t v145 = v64 - p_var5->var0;
            unint64_t v146 = v145 + 1;
            if ((unint64_t)(v145 + 1) >> 62) {
              abort();
            }
            uint64_t v147 = (char *)v69 - (char *)v130;
            if (v147 >> 1 > v146) {
              unint64_t v146 = v147 >> 1;
            }
            if ((unint64_t)v147 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v134 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v134 = v146;
            }
            if (v134)
            {
              Rectangle v135 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v134);
              CGAffineTransform v130 = this->var5.var0;
              float32x4_t v64 = this->var5.var1;
            }
            else
            {
              Rectangle v135 = 0;
            }
            CGRect v170 = (int *)&v135[4 * v145];
            *CGRect v170 = 2;
            uint64_t v70 = v170 + 1;
            while (v64 != v130)
            {
              int v175 = *--v64;
              *--CGRect v170 = v175;
            }
LABEL_357:
            this->var5.var0 = v170;
            this->var5.var1 = v70;
            this->var5.var2.var0 = (int *)&v135[4 * v134];
            if (v130) {
              operator delete(v130);
            }
          }
          else
          {
            int v65 = 2;
LABEL_87:
            *float32x4_t v64 = v65;
            uint64_t v70 = v64 + 1;
          }
          this->var5.var1 = v70;
          goto LABEL_360;
        case 0xCu:
          uint64_t v41 = this->var5.var1;
          long long v55 = this->var5.var2.var0;
          if (v41 < v55)
          {
            int v42 = 9;
            goto LABEL_90;
          }
          int8x16_t v73 = p_var5->var0;
          uint64_t v109 = v41 - p_var5->var0;
          unint64_t v110 = v109 + 1;
          if ((unint64_t)(v109 + 1) >> 62) {
            abort();
          }
          uint64_t v111 = (char *)v55 - (char *)v73;
          if (v111 >> 1 > v110) {
            unint64_t v110 = v111 >> 1;
          }
          if ((unint64_t)v111 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v77 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v77 = v110;
          }
          if (v77)
          {
            float v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
            int8x16_t v73 = this->var5.var0;
            uint64_t v41 = this->var5.var1;
          }
          else
          {
            float v78 = 0;
          }
          float32x4_t v151 = (int *)&v78[4 * v109];
          *float32x4_t v151 = 9;
          int8x16_t v72 = v151 + 1;
          while (v41 != v73)
          {
            int v163 = *--v41;
            *--float32x4_t v151 = v163;
          }
          goto LABEL_365;
        case 0x10u:
          uint64_t v41 = this->var5.var1;
          float32x4_t v66 = this->var5.var2.var0;
          if (v41 < v66)
          {
            int v42 = 12;
            goto LABEL_90;
          }
          int8x16_t v73 = p_var5->var0;
          uint64_t v136 = v41 - p_var5->var0;
          unint64_t v137 = v136 + 1;
          if ((unint64_t)(v136 + 1) >> 62) {
            abort();
          }
          uint64_t v138 = (char *)v66 - (char *)v73;
          if (v138 >> 1 > v137) {
            unint64_t v137 = v138 >> 1;
          }
          if ((unint64_t)v138 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v77 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v77 = v137;
          }
          if (v77)
          {
            float v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
            int8x16_t v73 = this->var5.var0;
            uint64_t v41 = this->var5.var1;
          }
          else
          {
            float v78 = 0;
          }
          float32x4_t v151 = (int *)&v78[4 * v136];
          *float32x4_t v151 = 12;
          int8x16_t v72 = v151 + 1;
          while (v41 != v73)
          {
            int v172 = *--v41;
            *--float32x4_t v151 = v172;
          }
          goto LABEL_365;
        case 0x11u:
          uint64_t v41 = this->var5.var1;
          long long v56 = this->var5.var2.var0;
          if (v41 < v56)
          {
            int v42 = 13;
            goto LABEL_90;
          }
          int8x16_t v73 = p_var5->var0;
          uint64_t v112 = v41 - p_var5->var0;
          unint64_t v113 = v112 + 1;
          if ((unint64_t)(v112 + 1) >> 62) {
            abort();
          }
          uint64_t v114 = (char *)v56 - (char *)v73;
          if (v114 >> 1 > v113) {
            unint64_t v113 = v114 >> 1;
          }
          if ((unint64_t)v114 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v77 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v77 = v113;
          }
          if (v77)
          {
            float v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
            int8x16_t v73 = this->var5.var0;
            uint64_t v41 = this->var5.var1;
          }
          else
          {
            float v78 = 0;
          }
          float32x4_t v151 = (int *)&v78[4 * v112];
          *float32x4_t v151 = 13;
          int8x16_t v72 = v151 + 1;
          while (v41 != v73)
          {
            int v164 = *--v41;
            *--float32x4_t v151 = v164;
          }
          goto LABEL_365;
        case 0x12u:
          uint64_t v41 = this->var5.var1;
          double v71 = this->var5.var2.var0;
          if (v41 < v71)
          {
            int v42 = 14;
            goto LABEL_90;
          }
          int8x16_t v73 = p_var5->var0;
          uint64_t v148 = v41 - p_var5->var0;
          unint64_t v149 = v148 + 1;
          if ((unint64_t)(v148 + 1) >> 62) {
            abort();
          }
          uint64_t v150 = (char *)v71 - (char *)v73;
          if (v150 >> 1 > v149) {
            unint64_t v149 = v150 >> 1;
          }
          if ((unint64_t)v150 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v77 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v77 = v149;
          }
          if (v77)
          {
            float v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
            int8x16_t v73 = this->var5.var0;
            uint64_t v41 = this->var5.var1;
          }
          else
          {
            float v78 = 0;
          }
          float32x4_t v151 = (int *)&v78[4 * v148];
          *float32x4_t v151 = 14;
          int8x16_t v72 = v151 + 1;
          while (v41 != v73)
          {
            int v176 = *--v41;
            *--float32x4_t v151 = v176;
          }
          goto LABEL_365;
        case 0x13u:
          uint64_t v41 = this->var5.var1;
          __int16 v68 = this->var5.var2.var0;
          if (v41 < v68)
          {
            int v42 = 15;
            goto LABEL_90;
          }
          int8x16_t v73 = p_var5->var0;
          uint64_t v142 = v41 - p_var5->var0;
          unint64_t v143 = v142 + 1;
          if ((unint64_t)(v142 + 1) >> 62) {
            abort();
          }
          uint64_t v144 = (char *)v68 - (char *)v73;
          if (v144 >> 1 > v143) {
            unint64_t v143 = v144 >> 1;
          }
          if ((unint64_t)v144 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v77 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v77 = v143;
          }
          if (v77)
          {
            float v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
            int8x16_t v73 = this->var5.var0;
            uint64_t v41 = this->var5.var1;
          }
          else
          {
            float v78 = 0;
          }
          float32x4_t v151 = (int *)&v78[4 * v142];
          *float32x4_t v151 = 15;
          int8x16_t v72 = v151 + 1;
          while (v41 != v73)
          {
            int v174 = *--v41;
            *--float32x4_t v151 = v174;
          }
          goto LABEL_365;
        case 0x14u:
          uint64_t v41 = this->var5.var1;
          float32x4_t v43 = this->var5.var2.var0;
          if (v41 < v43)
          {
            int v42 = 16;
            goto LABEL_90;
          }
          int8x16_t v73 = p_var5->var0;
          uint64_t v74 = v41 - p_var5->var0;
          unint64_t v75 = v74 + 1;
          if ((unint64_t)(v74 + 1) >> 62) {
            abort();
          }
          uint64_t v76 = (char *)v43 - (char *)v73;
          if (v76 >> 1 > v75) {
            unint64_t v75 = v76 >> 1;
          }
          if ((unint64_t)v76 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v77 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v77 = v75;
          }
          if (v77)
          {
            float v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
            int8x16_t v73 = this->var5.var0;
            uint64_t v41 = this->var5.var1;
          }
          else
          {
            float v78 = 0;
          }
          float32x4_t v151 = (int *)&v78[4 * v74];
          *float32x4_t v151 = 16;
          int8x16_t v72 = v151 + 1;
          while (v41 != v73)
          {
            int v152 = *--v41;
            *--float32x4_t v151 = v152;
          }
          goto LABEL_365;
        case 0x15u:
          uint64_t v41 = this->var5.var1;
          long long v59 = this->var5.var2.var0;
          if (v41 < v59)
          {
            int v42 = 17;
            goto LABEL_90;
          }
          int8x16_t v73 = p_var5->var0;
          uint64_t v121 = v41 - p_var5->var0;
          unint64_t v122 = v121 + 1;
          if ((unint64_t)(v121 + 1) >> 62) {
            abort();
          }
          uint64_t v123 = (char *)v59 - (char *)v73;
          if (v123 >> 1 > v122) {
            unint64_t v122 = v123 >> 1;
          }
          if ((unint64_t)v123 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v77 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v77 = v122;
          }
          if (v77)
          {
            float v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
            int8x16_t v73 = this->var5.var0;
            uint64_t v41 = this->var5.var1;
          }
          else
          {
            float v78 = 0;
          }
          float32x4_t v151 = (int *)&v78[4 * v121];
          *float32x4_t v151 = 17;
          int8x16_t v72 = v151 + 1;
          while (v41 != v73)
          {
            int v167 = *--v41;
            *--float32x4_t v151 = v167;
          }
          goto LABEL_365;
        case 0x16u:
          uint64_t v41 = this->var5.var1;
          float32x4_t v44 = this->var5.var2.var0;
          if (v41 >= v44)
          {
            int8x16_t v73 = p_var5->var0;
            uint64_t v79 = v41 - p_var5->var0;
            unint64_t v80 = v79 + 1;
            if ((unint64_t)(v79 + 1) >> 62) {
              abort();
            }
            uint64_t v81 = (char *)v44 - (char *)v73;
            if (v81 >> 1 > v80) {
              unint64_t v80 = v81 >> 1;
            }
            if ((unint64_t)v81 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v77 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v77 = v80;
            }
            if (v77)
            {
              float v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
              int8x16_t v73 = this->var5.var0;
              uint64_t v41 = this->var5.var1;
            }
            else
            {
              float v78 = 0;
            }
            float32x4_t v151 = (int *)&v78[4 * v79];
            *float32x4_t v151 = 18;
            int8x16_t v72 = v151 + 1;
            while (v41 != v73)
            {
              int v153 = *--v41;
              *--float32x4_t v151 = v153;
            }
LABEL_365:
            this->var5.var0 = v151;
            this->var5.var1 = v72;
            this->var5.var2.var0 = (int *)&v78[4 * v77];
            if (v73) {
              operator delete(v73);
            }
          }
          else
          {
            int v42 = 18;
LABEL_90:
            *uint64_t v41 = v42;
            int8x16_t v72 = v41 + 1;
          }
          this->var5.var1 = v72;
          goto LABEL_368;
        case 0x18u:
          long long v61 = this->var5.var1;
          long long v60 = this->var5.var2.var0;
          if (v61 >= v60)
          {
            double v124 = p_var5->var0;
            uint64_t v125 = v61 - p_var5->var0;
            unint64_t v126 = v125 + 1;
            if ((unint64_t)(v125 + 1) >> 62) {
              abort();
            }
            uint64_t v127 = (char *)v60 - (char *)v124;
            if (v127 >> 1 > v126) {
              unint64_t v126 = v127 >> 1;
            }
            if ((unint64_t)v127 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v128 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v128 = v126;
            }
            if (v128)
            {
              CGAffineTransform v129 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v128);
              double v124 = this->var5.var0;
              long long v61 = this->var5.var1;
            }
            else
            {
              CGAffineTransform v129 = 0;
            }
            CGRect v168 = (int *)&v129[4 * v125];
            *CGRect v168 = 4;
            long long v62 = v168 + 1;
            while (v61 != v124)
            {
              int v169 = *--v61;
              *--CGRect v168 = v169;
            }
            this->var5.var0 = v168;
            this->var5.var1 = v62;
            this->var5.var2.var0 = (int *)&v129[4 * v128];
            if (v124) {
              operator delete(v124);
            }
          }
          else
          {
            *long long v61 = 4;
            long long v62 = v61 + 1;
          }
          this->var5.var1 = v62;
          this->var8 |= 0x10u;
          goto LABEL_368;
        case 0x19u:
          float v46 = this->var5.var1;
          float v48 = this->var5.var2.var0;
          if (v46 < v48)
          {
            int v47 = 1;
            goto LABEL_54;
          }
          float32x4_t v82 = p_var5->var0;
          uint64_t v88 = v46 - p_var5->var0;
          unint64_t v89 = v88 + 1;
          if ((unint64_t)(v88 + 1) >> 62) {
            abort();
          }
          uint64_t v90 = (char *)v48 - (char *)v82;
          if (v90 >> 1 > v89) {
            unint64_t v89 = v90 >> 1;
          }
          if ((unint64_t)v90 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v86 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v86 = v89;
          }
          if (v86)
          {
            int8x16_t v87 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v86);
            float32x4_t v82 = this->var5.var0;
            float v46 = this->var5.var1;
          }
          else
          {
            int8x16_t v87 = 0;
          }
          float32x4_t v154 = (int *)&v87[4 * v88];
          *float32x4_t v154 = 1;
          float32x4_t v49 = v154 + 1;
          while (v46 != v82)
          {
            int v156 = *--v46;
            *--float32x4_t v154 = v156;
          }
          goto LABEL_283;
        case 0x1Au:
          this->var13 = 1;
          float v46 = this->var5.var1;
          float v45 = this->var5.var2.var0;
          if (v46 >= v45)
          {
            float32x4_t v82 = p_var5->var0;
            uint64_t v83 = v46 - p_var5->var0;
            unint64_t v84 = v83 + 1;
            if ((unint64_t)(v83 + 1) >> 62) {
              abort();
            }
            uint64_t v85 = (char *)v45 - (char *)v82;
            if (v85 >> 1 > v84) {
              unint64_t v84 = v85 >> 1;
            }
            if ((unint64_t)v85 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v86 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v86 = v84;
            }
            if (v86)
            {
              int8x16_t v87 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v86);
              float32x4_t v82 = this->var5.var0;
              float v46 = this->var5.var1;
            }
            else
            {
              int8x16_t v87 = 0;
            }
            float32x4_t v154 = (int *)&v87[4 * v83];
            *float32x4_t v154 = 2;
            float32x4_t v49 = v154 + 1;
            while (v46 != v82)
            {
              int v155 = *--v46;
              *--float32x4_t v154 = v155;
            }
LABEL_283:
            this->var5.var0 = v154;
            this->var5.var1 = v49;
            this->var5.var2.var0 = (int *)&v87[4 * v86];
            if (v82) {
              operator delete(v82);
            }
          }
          else
          {
            int v47 = 2;
LABEL_54:
            *float v46 = v47;
            float32x4_t v49 = v46 + 1;
          }
          this->var5.var1 = v49;
          this->var8 |= 0x10u;
LABEL_360:
          char v193 = 1;
LABEL_368:
          uint64_t v20 = (v20 + 1);
          if (v20 == NumKernelParameters) {
            goto LABEL_371;
          }
          continue;
        default:
          CIKernelError(v192, 4u, &cfstr_KernelSHasAnUn.isa, this->var2, ParamName);
          v191 = ci_logger_compile();
          BOOL result = os_log_type_enabled(v191, OS_LOG_TYPE_ERROR);
          if (!result) {
            return result;
          }
          CIKernelReflection::reflect();
          return 0;
      }
    }
  }
  char v193 = 0;
LABEL_371:
  if (fosl_filter_kernelpool_isPositionInvariant(v7)) {
    this->var8 |= 1u;
  }
  if ((v193 & 1) != 0 && fosl_filter_kernelpool_preservesAlpha(v7)) {
    this->var8 |= 2u;
  }
  if (fosl_filter_kernelpool_getNumKernelAttributes(v7))
  {
    uint64_t v177 = 0;
    while (1)
    {
      AttributeKeyword = (const char *)fosl_filter_kernelpool_getAttributeKeyword(v7, v177);
      CGRect v179 = fosl_filter_kernelpool_hasAttributeParameters(v7, v177)
           ? (char *)fosl_filter_kernelpool_getAttributeParameters(v7, v177)
           : 0;
      if (!strcmp(AttributeKeyword, "outputFormat") && v179) {
        break;
      }
LABEL_414:
      uint64_t v177 = (v177 + 1);
      if (v177 >= fosl_filter_kernelpool_getNumKernelAttributes(v7)) {
        return 1;
      }
    }
    std::string::basic_string[abi:nn180100]<0>(&__s, v179);
    if (SHIBYTE(__s.__end_) < 0)
    {
      std::__split_buffer<std::string>::pointer begin = __s.__begin_;
      if ((uint64_t)__s.__begin_ >= 11)
      {
        first = (char *)__s.__first_;
LABEL_388:
        CGRect v182 = (char *)begin + (void)first;
        CGRect v183 = first;
        do
        {
          CGRect v184 = (char *)memchr(v183, 107, (size_t)&begin[-1].__r_.__value_.__r.__words[2]);
          if (!v184) {
            break;
          }
          if (*(void *)v184 == 0x616D726F4649436BLL && v184[8] == 116)
          {
            if (v184 != v182 && v184 == first)
            {
              std::string::basic_string(&__p, (const std::string *)&__s, 9uLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v196);
              std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
              if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                std::string::size_type size = __p.__r_.__value_.__l.__size_;
              }
              if (size)
              {
                uint64_t v187 = 0;
                while (1)
                {
                  int v188 = dword_1939543B8[v187];
                  v189 = CI::name_for_format(v188);
                  if (v189)
                  {
                    if (!std::string::compare(&__p, v189)) {
                      break;
                    }
                  }
                  if (++v187 == 6) {
                    goto LABEL_407;
                  }
                }
                this->var9 = v188;
              }
LABEL_407:
              if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__p.__r_.__value_.__l.__data_);
              }
            }
            break;
          }
          CGRect v183 = v184 + 1;
          std::__split_buffer<std::string>::pointer begin = (std::__split_buffer<std::string>::pointer)(v182 - v183);
        }
        while (v182 - v183 >= 9);
      }
    }
    else
    {
      std::__split_buffer<std::string>::pointer begin = (std::__split_buffer<std::string>::pointer)HIBYTE(__s.__end_);
      if (HIBYTE(__s.__end_) >= 0xBu)
      {
        first = (char *)&__s;
        goto LABEL_388;
      }
    }
    if (!this->var9)
    {
      v190 = ci_logger_api();
      if (os_log_type_enabled(v190, OS_LOG_TYPE_INFO))
      {
        LODWORD(__p.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v179;
        _os_log_impl(&dword_193671000, v190, OS_LOG_TYPE_INFO, "%{public}s is not an known pixel format name. Will use working format instead.", (uint8_t *)&__p, 0xCu);
      }
    }
    if (SHIBYTE(__s.__end_) < 0) {
      operator delete(__s.__first_);
    }
    goto LABEL_414;
  }
  return 1;
}

void sub_1937CE0F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *CIKernelError(void *result, unsigned int a2, NSString *a3, ...)
{
  va_start(va, a3);
  v6[1] = *MEMORY[0x1E4F143B8];
  if (result)
  {
    float v4 = result;
    float32x2_t v5 = @"CINonLocalizedDescriptionKey";
    v6[0] = (id)[[NSString alloc] initWithFormat:a3 arguments:va];
    BOOL result = objc_msgSend(MEMORY[0x1E4F28C58], "errorWithDomain:code:userInfo:", @"CIKernel", a2, objc_msgSend(MEMORY[0x1E4F1C9E8], "dictionaryWithObjects:forKeys:count:", v6, &v5, 1));
    *float v4 = result;
  }
  return result;
}

void std::vector<CI::KernelArgumentType>::reserve(void **a1, unint64_t a2)
{
  float v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 2)
  {
    if (a2 >> 62) {
      abort();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    float v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>(v3, a2);
    uint64_t v7 = &v6[v5 & 0xFFFFFFFFFFFFFFFCLL];
    BOOL v9 = &v6[4 * v8];
    uint64_t v10 = (char *)*a1;
    float v11 = (char *)a1[1];
    int v12 = v7;
    if (v11 != *a1)
    {
      int v12 = v7;
      do
      {
        int v13 = *((_DWORD *)v11 - 1);
        v11 -= 4;
        *((_DWORD *)v12 - 1) = v13;
        v12 -= 4;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void std::vector<std::string>::reserve(std::vector<std::string> *this, std::vector<std::string>::size_type __n)
{
  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  if (0xAAAAAAAAAAAAAAABLL * (((char *)value - (char *)this->__begin_) >> 3) < __n)
  {
    if (__n >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    int64_t v5 = this->__end_ - this->__begin_;
    v14.__end_cap_.__value_ = (std::allocator<std::string> *)p_end_cap;
    float v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SWRendererFunctionInputNode>>((uint64_t)p_end_cap, __n);
    std::vector<std::string>::pointer begin = this->__begin_;
    end = this->__end_;
    if (end == this->__begin_)
    {
      int64x2_t v12 = vdupq_n_s64((unint64_t)end);
      uint64_t v10 = (std::string *)&v6[24 * v5];
    }
    else
    {
      uint64_t v10 = (std::string *)&v6[24 * v5];
      do
      {
        long long v11 = *(_OWORD *)&end[-1].__r_.__value_.__l.__data_;
        v10[-1].__r_.__value_.__r.__words[2] = end[-1].__r_.__value_.__r.__words[2];
        *(_OWORD *)&v10[-1].__r_.__value_.__l.__data_ = v11;
        --v10;
        end[-1].__r_.__value_.__l.__size_ = 0;
        end[-1].__r_.__value_.__r.__words[2] = 0;
        end[-1].__r_.__value_.__r.__words[0] = 0;
        --end;
      }
      while (end != begin);
      int64x2_t v12 = *(int64x2_t *)&this->__begin_;
    }
    this->__begin_ = v10;
    this->__end_ = (std::vector<std::string>::pointer)&v6[24 * v5];
    *(int64x2_t *)&v14.__begin_ = v12;
    int v13 = this->__end_cap_.__value_;
    this->__end_cap_.__value_ = (std::string *)&v6[24 * v7];
    v14.__end_cap_.__value_ = v13;
    v14.__first_ = (std::__split_buffer<std::string>::pointer)v12.i64[0];
    std::__split_buffer<std::string>::~__split_buffer(&v14);
  }
}

void std::vector<CI::KernelArgumentType>::push_back[abi:nn180100](uint64_t a1, _DWORD *a2)
{
  uint64_t v4 = a1 + 16;
  unint64_t v5 = *(void *)(a1 + 16);
  float v6 = *(_DWORD **)(a1 + 8);
  if ((unint64_t)v6 >= v5)
  {
    uint64_t v8 = *(_DWORD **)a1;
    uint64_t v9 = ((uint64_t)v6 - *(void *)a1) >> 2;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 62) {
      abort();
    }
    uint64_t v11 = v5 - (void)v8;
    if (v11 >> 1 > v10) {
      unint64_t v10 = v11 >> 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      int v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>(v4, v12);
      uint64_t v8 = *(_DWORD **)a1;
      float v6 = *(_DWORD **)(a1 + 8);
    }
    else
    {
      int v13 = 0;
    }
    std::__split_buffer<std::string> v14 = &v13[4 * v9];
    uint64_t v15 = &v13[4 * v12];
    *(_DWORD *)std::__split_buffer<std::string> v14 = *a2;
    uint64_t v7 = v14 + 4;
    while (v6 != v8)
    {
      int v16 = *--v6;
      *((_DWORD *)v14 - 1) = v16;
      v14 -= 4;
    }
    *(void *)a1 = v14;
    *(void *)(a1 + 8) = v7;
    *(void *)(a1 + 16) = v15;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    *float v6 = *a2;
    uint64_t v7 = v6 + 1;
  }
  *(void *)(a1 + 8) = v7;
}

uint64_t CIKernelReflection::reflect(CIKernelReflection *this, CIKernelLibrary *a2, char *a3, NSError **a4)
{
  uint64_t v427 = *MEMORY[0x1E4F143B8];
  this->var7 = a2;
  p_var7 = &this->var7;
  this->var2 = a3;
  p_var2 = &this->var2;
  this->var4 = (char *)[(NSString *)[(CIKernelLibrary *)a2 mtl_source] UTF8String];
  v403 = (std::string **)p_var2;
  uint64_t v8 = objc_msgSend(*p_var7, "functionWithName:", objc_msgSend(NSString, "stringWithUTF8String:", *p_var2));
  if (!v8)
  {
    uint64_t v12 = [*p_var7 functionCount];
    int v13 = "";
    if (!v12) {
      int v13 = "Check if Metal library is linked with -cikernel option.";
    }
    CIKernelError(a4, 1u, &cfstr_FunctionDoesNo.isa, v13);
    std::__split_buffer<std::string> v14 = ci_logger_api();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      CIKernelReflection::reflect();
    }
    uint64_t v15 = ci_logger_api();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG)) {
      CIKernelReflection::reflect(p_var7, v15);
    }
    return 0;
  }
  uint64_t v9 = v8;
  v402 = a4;
  uint64_t v10 = objc_msgSend((id)objc_msgSend(v8, "returnType"), "dataType");
  int v11 = 0;
  if (v10 <= 5)
  {
    if (v10)
    {
      if (v10 != 4) {
        goto LABEL_837;
      }
      int v11 = 1;
    }
  }
  else
  {
    switch(v10)
    {
      case 6:
        int v11 = 2;
        break;
      case 19:
        int v11 = 3;
        break;
      case 61:
        break;
      default:
LABEL_837:
        CIKernelError(a4, 2u, &cfstr_FunctionDoesNo_0.isa);
        v393 = ci_logger_api();
        if (os_log_type_enabled(v393, OS_LOG_TYPE_ERROR)) {
          CIKernelReflection::reflect();
        }
        return 0;
    }
  }
  this->unsigned int var1 = v11;
  this->var12 = [v9 functionType] == 5;
  std::string __p = 0;
  v423 = 0;
  v424 = 0;
  v419 = 0;
  v420 = 0;
  v421 = 0;
  v416 = 0;
  v417 = 0;
  v418 = 0;
  uint64_t v16 = objc_msgSend((id)objc_msgSend(v9, "arguments"), "count");
  if (v16)
  {
    uint64_t v17 = 0;
    long long v18 = &v424;
    do
    {
      uint64_t v19 = objc_msgSend((id)objc_msgSend(v9, "arguments"), "objectAtIndexedSubscript:", v17);
      uint64_t v20 = [v19 type];
      if (this->var12 && objc_msgSend((id)objc_msgSend(v19, "dataTypeDescription"), "dataType") == 1)
      {
        long long v21 = (void *)[v19 dataTypeDescription];
        if ((objc_msgSend((id)objc_msgSend(v21, "typeName"), "isEqualToString:", @"coreimage::priv::destination") & 1) == 0
          && (objc_msgSend((id)objc_msgSend(v21, "typeName"), "isEqualToString:", @"coreimage::priv::destination_h") & 1) == 0&& (objc_msgSend((id)objc_msgSend(v21, "typeName"), "isEqualToString:", @"coreimage::priv::Destination") & 1) == 0&& (objc_msgSend((id)objc_msgSend(v21, "typeName"), "isEqualToString:", @"coreimage::priv::Destination_h") & 1) == 0&& (objc_msgSend((id)objc_msgSend(v21, "typeName"), "isEqualToString:", @"coreimage::group::destination") & 1) == 0&& (objc_msgSend((id)objc_msgSend(v21, "typeName"), "isEqualToString:", @"coreimage::group::destination_h") & 1) == 0&& (objc_msgSend((id)objc_msgSend(v21, "typeName"), "isEqualToString:",
                @"coreimage::group::Destination") & 1) == 0
          && !objc_msgSend((id)objc_msgSend(v21, "typeName"), "isEqualToString:", @"coreimage::group::Destination_h"))
        {
          uint64_t v103 = (void *)[v21 members];
          long long v414 = 0u;
          long long v415 = 0u;
          long long v412 = 0u;
          long long v413 = 0u;
          obuint64_t j = v103;
          uint64_t v104 = [v103 countByEnumeratingWithState:&v412 objects:v425 count:16];
          if (v104)
          {
            uint64_t v105 = 0;
            uint64_t v106 = *(void *)v413;
            uint64_t v400 = v16;
            v401 = v9;
            uint64_t v404 = (uint64_t)v18;
            do
            {
              for (uint64_t i = 0; i != v104; ++i)
              {
                if (*(void *)v413 != v106) {
                  objc_enumerationMutation(obj);
                }
                uint64_t v108 = *(void **)(*((void *)&v412 + 1) + 8 * i);
                uint64_t v109 = [v108 dataType];
                uint64_t v110 = v109;
                uint64_t v111 = v423;
                if (v423 >= v424)
                {
                  unint64_t v113 = (char *)__p;
                  uint64_t v114 = (v423 - (unsigned char *)__p) >> 3;
                  unint64_t v115 = v114 + 1;
                  if ((unint64_t)(v114 + 1) >> 61) {
                    abort();
                  }
                  uint64_t v116 = v424 - (unsigned char *)__p;
                  if ((v424 - (unsigned char *)__p) >> 2 > v115) {
                    unint64_t v115 = v116 >> 2;
                  }
                  if ((unint64_t)v116 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v117 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v117 = v115;
                  }
                  if (v117)
                  {
                    uint64_t v118 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v404, v117);
                    unint64_t v113 = (char *)__p;
                    uint64_t v111 = v423;
                  }
                  else
                  {
                    uint64_t v118 = 0;
                  }
                  unint64_t v119 = (uint64_t *)&v118[8 * v114];
                  *unint64_t v119 = v110;
                  uint64_t v112 = (char *)(v119 + 1);
                  while (v111 != v113)
                  {
                    uint64_t v120 = *((void *)v111 - 1);
                    v111 -= 8;
                    *--unint64_t v119 = v120;
                  }
                  std::string __p = v119;
                  v423 = v112;
                  v424 = &v118[8 * v117];
                  if (v113) {
                    operator delete(v113);
                  }
                }
                else
                {
                  *(void *)v423 = v109;
                  uint64_t v112 = v111 + 8;
                }
                v423 = v112;
                uint64_t v121 = [v108 dataType];
                uint64_t v122 = v121;
                uint64_t v123 = v417;
                if (v417 >= v418)
                {
                  uint64_t v125 = (char *)v416;
                  uint64_t v126 = (v417 - (unsigned char *)v416) >> 3;
                  unint64_t v127 = v126 + 1;
                  if ((unint64_t)(v126 + 1) >> 61) {
                    abort();
                  }
                  uint64_t v128 = v418 - (unsigned char *)v416;
                  if ((v418 - (unsigned char *)v416) >> 2 > v127) {
                    unint64_t v127 = v128 >> 2;
                  }
                  if ((unint64_t)v128 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v129 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v129 = v127;
                  }
                  if (v129)
                  {
                    CGAffineTransform v130 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>((uint64_t)&v418, v129);
                    uint64_t v125 = (char *)v416;
                    uint64_t v123 = v417;
                  }
                  else
                  {
                    CGAffineTransform v130 = 0;
                  }
                  uint64_t v131 = (uint64_t *)&v130[8 * v126];
                  *uint64_t v131 = v122;
                  double v124 = (char *)(v131 + 1);
                  while (v123 != v125)
                  {
                    uint64_t v132 = *((void *)v123 - 1);
                    v123 -= 8;
                    *--uint64_t v131 = v132;
                  }
                  v416 = v131;
                  v417 = v124;
                  v418 = &v130[8 * v129];
                  if (v125) {
                    operator delete(v125);
                  }
                }
                else
                {
                  *(void *)v417 = v121;
                  double v124 = v123 + 8;
                }
                v417 = v124;
                uint64_t v133 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(v19, "name"), "stringByAppendingString:", @".coerce"), "stringByAppendingFormat:", @"%i", v105);
                uint64_t v134 = v133;
                Rectangle v135 = v420;
                if (v420 >= (uint64_t *)v421)
                {
                  uint64_t v137 = ((char *)v420 - (unsigned char *)v419) >> 3;
                  if ((unint64_t)(v137 + 1) >> 61) {
                    abort();
                  }
                  unint64_t v138 = (v421 - (unsigned char *)v419) >> 2;
                  if (v138 <= v137 + 1) {
                    unint64_t v138 = v137 + 1;
                  }
                  if ((unint64_t)(v421 - (unsigned char *)v419) >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v139 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v139 = v138;
                  }
                  if (v139) {
                    unint64_t v140 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>((uint64_t)&v421, v139);
                  }
                  else {
                    unint64_t v140 = 0;
                  }
                  uint64_t v141 = (uint64_t *)&v140[8 * v137];
                  *uint64_t v141 = v134;
                  uint64_t v136 = v141 + 1;
                  unint64_t v143 = (char *)v419;
                  uint64_t v142 = (char *)v420;
                  if (v420 != v419)
                  {
                    do
                    {
                      uint64_t v144 = *((void *)v142 - 1);
                      v142 -= 8;
                      *--uint64_t v141 = v144;
                    }
                    while (v142 != v143);
                    uint64_t v142 = (char *)v419;
                  }
                  v419 = v141;
                  v420 = v136;
                  v421 = &v140[8 * v139];
                  if (v142) {
                    operator delete(v142);
                  }
                }
                else
                {
                  uint64_t *v420 = v133;
                  uint64_t v136 = v135 + 1;
                }
                uint64_t v105 = (v105 + 1);
                v420 = v136;
              }
              uint64_t v104 = [obj countByEnumeratingWithState:&v412 objects:v425 count:16];
              uint64_t v16 = v400;
              uint64_t v9 = v401;
              long long v18 = (void *)v404;
            }
            while (v104);
          }
          goto LABEL_170;
        }
        long long v22 = v423;
        if (v423 >= v424)
        {
          int v42 = (char *)__p;
          uint64_t v43 = (v423 - (unsigned char *)__p) >> 3;
          unint64_t v44 = v43 + 1;
          if ((unint64_t)(v43 + 1) >> 61) {
            abort();
          }
          uint64_t v45 = v424 - (unsigned char *)__p;
          if ((v424 - (unsigned char *)__p) >> 2 > v44) {
            unint64_t v44 = v45 >> 2;
          }
          if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v46 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v46 = v44;
          }
          if (v46)
          {
            int v47 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>((uint64_t)v18, v46);
            int v42 = (char *)__p;
            long long v22 = v423;
          }
          else
          {
            int v47 = 0;
          }
          int8x16_t v87 = &v47[8 * v43];
          *(void *)int8x16_t v87 = 1;
          long long v23 = v87 + 8;
          while (v22 != v42)
          {
            uint64_t v88 = *((void *)v22 - 1);
            v22 -= 8;
            *((void *)v87 - 1) = v88;
            v87 -= 8;
          }
          std::string __p = v87;
          v423 = v23;
          v424 = &v47[8 * v46];
          if (v42) {
            operator delete(v42);
          }
        }
        else
        {
          *(void *)v423 = 1;
          long long v23 = v22 + 8;
        }
        v423 = v23;
        unint64_t v89 = v417;
        if (v417 >= v418)
        {
          uint64_t v91 = (char *)v416;
          uint64_t v92 = (v417 - (unsigned char *)v416) >> 3;
          unint64_t v93 = v92 + 1;
          if ((unint64_t)(v92 + 1) >> 61) {
            abort();
          }
          uint64_t v94 = v418 - (unsigned char *)v416;
          if ((v418 - (unsigned char *)v416) >> 2 > v93) {
            unint64_t v93 = v94 >> 2;
          }
          if ((unint64_t)v94 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v95 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v95 = v93;
          }
          if (v95)
          {
            uint64_t v96 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>((uint64_t)&v418, v95);
            uint64_t v91 = (char *)v416;
            unint64_t v89 = v417;
          }
          else
          {
            uint64_t v96 = 0;
          }
          uint64_t v97 = (uint64_t *)&v96[8 * v92];
          *uint64_t v97 = v20;
          uint64_t v90 = (char *)(v97 + 1);
          while (v89 != v91)
          {
            uint64_t v98 = *((void *)v89 - 1);
            v89 -= 8;
            *--uint64_t v97 = v98;
          }
          v416 = v97;
          v417 = v90;
          v418 = &v96[8 * v95];
          if (v91) {
            operator delete(v91);
          }
        }
        else
        {
          *(void *)v417 = v20;
          uint64_t v90 = v89 + 8;
        }
        v417 = v90;
        uint64_t v60 = [v21 typeName];
        long long v61 = v420;
        if (v420 >= (uint64_t *)v421)
        {
          uint64_t v99 = ((char *)v420 - (unsigned char *)v419) >> 3;
          if ((unint64_t)(v99 + 1) >> 61) {
            abort();
          }
          unint64_t v100 = (v421 - (unsigned char *)v419) >> 2;
          if (v100 <= v99 + 1) {
            unint64_t v100 = v99 + 1;
          }
          if ((unint64_t)(v421 - (unsigned char *)v419) >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v64 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v64 = v100;
          }
          if (v64) {
            int v65 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>((uint64_t)&v421, v64);
          }
          else {
            int v65 = 0;
          }
          uint64_t v76 = (uint64_t *)&v65[8 * v99];
          *uint64_t v76 = v60;
          unint64_t v77 = v76 + 1;
          unint64_t v101 = (char *)v419;
          float v78 = (char *)v420;
          if (v420 != v419)
          {
            do
            {
              uint64_t v102 = *((void *)v78 - 1);
              v78 -= 8;
              *--uint64_t v76 = v102;
            }
            while (v78 != v101);
            goto LABEL_166;
          }
LABEL_167:
          v419 = v76;
          v420 = v77;
          v421 = &v65[8 * v64];
          if (v78) {
            operator delete(v78);
          }
          goto LABEL_169;
        }
      }
      else if (v20 == 2)
      {
        long long v24 = v423;
        if (v423 >= v424)
        {
          uint64_t v30 = (char *)__p;
          uint64_t v31 = (v423 - (unsigned char *)__p) >> 3;
          unint64_t v32 = v31 + 1;
          if ((unint64_t)(v31 + 1) >> 61) {
            goto LABEL_852;
          }
          uint64_t v33 = v424 - (unsigned char *)__p;
          if ((v424 - (unsigned char *)__p) >> 2 > v32) {
            unint64_t v32 = v33 >> 2;
          }
          if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v34 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v34 = v32;
          }
          if (v34)
          {
            long long v35 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>((uint64_t)v18, v34);
            uint64_t v30 = (char *)__p;
            long long v24 = v423;
          }
          else
          {
            long long v35 = 0;
          }
          float v48 = &v35[8 * v31];
          *(void *)float v48 = 65000;
          unint64_t v25 = v48 + 8;
          while (v24 != v30)
          {
            uint64_t v49 = *((void *)v24 - 1);
            v24 -= 8;
            *((void *)v48 - 1) = v49;
            v48 -= 8;
          }
          std::string __p = v48;
          v423 = v25;
          v424 = &v35[8 * v34];
          if (v30) {
            operator delete(v30);
          }
        }
        else
        {
          *(void *)v423 = 65000;
          unint64_t v25 = v24 + 8;
        }
        v423 = v25;
        float32x4_t v50 = v417;
        if (v417 >= v418)
        {
          CFDataRef v52 = (char *)v416;
          uint64_t v53 = (v417 - (unsigned char *)v416) >> 3;
          unint64_t v54 = v53 + 1;
          if ((unint64_t)(v53 + 1) >> 61) {
            goto LABEL_852;
          }
          uint64_t v55 = v418 - (unsigned char *)v416;
          if ((v418 - (unsigned char *)v416) >> 2 > v54) {
            unint64_t v54 = v55 >> 2;
          }
          if ((unint64_t)v55 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v56 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v56 = v54;
          }
          if (v56)
          {
            long long v57 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>((uint64_t)&v418, v56);
            CFDataRef v52 = (char *)v416;
            float32x4_t v50 = v417;
          }
          else
          {
            long long v57 = 0;
          }
          long long v58 = &v57[8 * v53];
          *(void *)long long v58 = 2;
          uint32_t v51 = v58 + 8;
          while (v50 != v52)
          {
            uint64_t v59 = *((void *)v50 - 1);
            v50 -= 8;
            *((void *)v58 - 1) = v59;
            v58 -= 8;
          }
          v416 = v58;
          v417 = v51;
          v418 = &v57[8 * v56];
          if (v52) {
            operator delete(v52);
          }
        }
        else
        {
          *(void *)v417 = 2;
          uint32_t v51 = v50 + 8;
        }
        v417 = v51;
        uint64_t v60 = [v19 name];
        long long v61 = v420;
        if (v420 >= (uint64_t *)v421)
        {
          uint64_t v62 = ((char *)v420 - (unsigned char *)v419) >> 3;
          if ((unint64_t)(v62 + 1) >> 61) {
            abort();
          }
          unint64_t v63 = (v421 - (unsigned char *)v419) >> 2;
          if (v63 <= v62 + 1) {
            unint64_t v63 = v62 + 1;
          }
          if ((unint64_t)(v421 - (unsigned char *)v419) >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v64 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v64 = v63;
          }
          if (v64) {
            int v65 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>((uint64_t)&v421, v64);
          }
          else {
            int v65 = 0;
          }
          uint64_t v76 = (uint64_t *)&v65[8 * v62];
          *uint64_t v76 = v60;
          unint64_t v77 = v76 + 1;
          uint64_t v79 = (char *)v419;
          float v78 = (char *)v420;
          if (v420 == v419) {
            goto LABEL_167;
          }
          do
          {
            uint64_t v80 = *((void *)v78 - 1);
            v78 -= 8;
            *--uint64_t v76 = v80;
          }
          while (v78 != v79);
          goto LABEL_166;
        }
      }
      else
      {
        uint64_t v26 = objc_msgSend((id)objc_msgSend(v19, "dataTypeDescription"), "dataType");
        uint64_t v27 = v26;
        unint64_t v28 = v423;
        if (v423 >= v424)
        {
          int64x2_t v36 = (char *)__p;
          uint64_t v37 = (v423 - (unsigned char *)__p) >> 3;
          unint64_t v38 = v37 + 1;
          if ((unint64_t)(v37 + 1) >> 61) {
            abort();
          }
          uint64_t v39 = v424 - (unsigned char *)__p;
          if ((v424 - (unsigned char *)__p) >> 2 > v38) {
            unint64_t v38 = v39 >> 2;
          }
          if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v40 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v40 = v38;
          }
          if (v40)
          {
            uint64_t v41 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>((uint64_t)v18, v40);
            int64x2_t v36 = (char *)__p;
            unint64_t v28 = v423;
          }
          else
          {
            uint64_t v41 = 0;
          }
          float32x4_t v66 = (uint64_t *)&v41[8 * v37];
          *float32x4_t v66 = v27;
          uint64_t v29 = (char *)(v66 + 1);
          while (v28 != v36)
          {
            uint64_t v67 = *((void *)v28 - 1);
            v28 -= 8;
            *--float32x4_t v66 = v67;
          }
          std::string __p = v66;
          v423 = v29;
          v424 = &v41[8 * v40];
          if (v36) {
            operator delete(v36);
          }
        }
        else
        {
          *(void *)v423 = v26;
          uint64_t v29 = v28 + 8;
        }
        v423 = v29;
        __int16 v68 = v417;
        if (v417 >= v418)
        {
          uint64_t v70 = (char *)v416;
          uint64_t v71 = (v417 - (unsigned char *)v416) >> 3;
          unint64_t v72 = v71 + 1;
          if ((unint64_t)(v71 + 1) >> 61) {
LABEL_852:
          }
            abort();
          uint64_t v73 = v418 - (unsigned char *)v416;
          if ((v418 - (unsigned char *)v416) >> 2 > v72) {
            unint64_t v72 = v73 >> 2;
          }
          if ((unint64_t)v73 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v74 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v74 = v72;
          }
          if (v74)
          {
            unint64_t v75 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>((uint64_t)&v418, v74);
            uint64_t v70 = (char *)v416;
            __int16 v68 = v417;
          }
          else
          {
            unint64_t v75 = 0;
          }
          uint64_t v81 = (uint64_t *)&v75[8 * v71];
          *uint64_t v81 = v20;
          float32x4_t v69 = (char *)(v81 + 1);
          while (v68 != v70)
          {
            uint64_t v82 = *((void *)v68 - 1);
            v68 -= 8;
            *--uint64_t v81 = v82;
          }
          v416 = v81;
          v417 = v69;
          v418 = &v75[8 * v74];
          if (v70) {
            operator delete(v70);
          }
        }
        else
        {
          *(void *)v417 = v20;
          float32x4_t v69 = v68 + 8;
        }
        v417 = v69;
        uint64_t v60 = [v19 name];
        long long v61 = v420;
        if (v420 >= (uint64_t *)v421)
        {
          uint64_t v83 = ((char *)v420 - (unsigned char *)v419) >> 3;
          if ((unint64_t)(v83 + 1) >> 61) {
            abort();
          }
          unint64_t v84 = (v421 - (unsigned char *)v419) >> 2;
          if (v84 <= v83 + 1) {
            unint64_t v84 = v83 + 1;
          }
          if ((unint64_t)(v421 - (unsigned char *)v419) >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v64 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v64 = v84;
          }
          if (v64) {
            int v65 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>((uint64_t)&v421, v64);
          }
          else {
            int v65 = 0;
          }
          uint64_t v76 = (uint64_t *)&v65[8 * v83];
          *uint64_t v76 = v60;
          unint64_t v77 = v76 + 1;
          uint64_t v85 = (char *)v419;
          float v78 = (char *)v420;
          if (v420 == v419) {
            goto LABEL_167;
          }
          do
          {
            uint64_t v86 = *((void *)v78 - 1);
            v78 -= 8;
            *--uint64_t v76 = v86;
          }
          while (v78 != v85);
LABEL_166:
          float v78 = (char *)v419;
          goto LABEL_167;
        }
      }
      *long long v61 = v60;
      unint64_t v77 = v61 + 1;
LABEL_169:
      v420 = v77;
LABEL_170:
      ++v17;
    }
    while (v17 != v16);
  }
  unint64_t v146 = (char *)__p;
  uint64_t v145 = v423;
  std::vector<std::string>::size_type v147 = (v423 - (unsigned char *)__p) >> 3;
  p_var6 = &this->var6;
  std::vector<std::string>::reserve((std::vector<std::string> *)&this->var6, v147);
  p_var5 = &this->var5;
  std::vector<CI::KernelArgumentType>::reserve((void **)&this->var5.var0, v147);
  if (v145 == v146)
  {
    char obja = 0;
    uint64_t v409 = 0;
LABEL_811:
    char v386 = 0;
    unsigned int var1 = this->var1;
    if (var1 > 3)
    {
      char v388 = obja;
      uint64_t v389 = v409;
    }
    else
    {
      char v388 = obja;
      uint64_t v389 = v409;
      if (var1 != 1) {
        char v386 = obja ^ 1;
      }
    }
    if (var1 == 1)
    {
      if (v388)
      {
        CIKernelError(v402, 5u, &cfstr_CiwarpkernelsC.isa);
        v390 = ci_logger_api();
        if (os_log_type_enabled(v390, OS_LOG_TYPE_ERROR)) {
          CIKernelReflection::reflect();
        }
        goto LABEL_830;
      }
      if (!v389)
      {
        CIKernelError(v402, 6u, &cfstr_CiwarpkernelsM.isa);
        v395 = ci_logger_api();
        if (os_log_type_enabled(v395, OS_LOG_TYPE_ERROR)) {
          CIKernelReflection::reflect();
        }
        goto LABEL_830;
      }
      this->var0 = 3;
    }
    else
    {
      if (v386) {
        int v391 = 2;
      }
      else {
        int v391 = 1;
      }
      this->var0 = v391;
      if (!v389)
      {
        this->var8 |= 1u;
LABEL_828:
        uint64_t v392 = 1;
        goto LABEL_831;
      }
    }
    if ((*(this->var5.var1 - 1) - 30) >= 0xA)
    {
      CIKernelError(v402, 4u, &cfstr_IfSpecifiedDes.isa);
      goto LABEL_830;
    }
    if (v389 == 5) {
      *(int64x2_t *)&this->var10 = vdupq_n_s64(2uLL);
    }
    goto LABEL_828;
  }
  uint64_t v150 = 0;
  uint64_t v408 = 0;
  uint64_t v409 = 0;
  char obja = 0;
  p_unsigned int var1 = &this->var5.var1;
  int v152 = &this->var5.var2;
  std::vector<std::string>::size_type v405 = v147 - 1;
  if (v147 <= 1) {
    uint64_t v153 = 1;
  }
  else {
    uint64_t v153 = v147;
  }
  while (1)
  {
    float32x4_t v154 = (std::string *)objc_msgSend(*((id *)v419 + v150), "stringByTrimmingCharactersInSet:", objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F28B88], "characterSetWithCharactersInString:", @"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz"), "invertedSet"));
    int v155 = v154;
    uint64_t v156 = *((void *)__p + v150);
    switch(v156)
    {
      case 1:
        goto LABEL_601;
      case 2:
      case 8:
      case 9:
      case 10:
      case 12:
      case 13:
      case 14:
      case 21:
      case 22:
      case 23:
      case 25:
      case 26:
      case 27:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        goto LABEL_844;
      case 3:
        int v157 = *p_var1;
        if (*p_var1 < v152->var0)
        {
          int v158 = 5;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        uint64_t v192 = v157 - p_var5->var0;
        unint64_t v193 = v192 + 1;
        if ((unint64_t)(v192 + 1) >> 62) {
          abort();
        }
        uint64_t v194 = (char *)v152->var0 - (char *)var0;
        if (v194 >> 1 > v193) {
          unint64_t v193 = v194 >> 1;
        }
        if ((unint64_t)v194 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v173 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v173 = v193;
        }
        if (v173)
        {
          int v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          int v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          int v174 = 0;
        }
        v280 = (int *)&v174[4 * v192];
        int *v280 = 5;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          int v286 = *--v157;
          *--v280 = v286;
        }
        goto LABEL_775;
      case 4:
        if (v408 == 3)
        {
          int v161 = *p_var1;
          if (*p_var1 >= v152->var0)
          {
            v247 = p_var5->var0;
            uint64_t v248 = v161 - p_var5->var0;
            unint64_t v249 = v248 + 1;
            if ((unint64_t)(v248 + 1) >> 62) {
              abort();
            }
            uint64_t v250 = (char *)v152->var0 - (char *)v247;
            if (v250 >> 1 > v249) {
              unint64_t v249 = v250 >> 1;
            }
            if ((unint64_t)v250 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v251 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v251 = v249;
            }
            if (v251)
            {
              v252 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v251);
              int v161 = *p_var1;
              v247 = p_var5->var0;
            }
            else
            {
              v252 = 0;
            }
            v337 = (int *)&v252[4 * v248];
            int *v337 = 2;
            int v162 = v337 + 1;
            while (v161 != v247)
            {
              int v338 = *--v161;
              *--v337 = v338;
            }
            p_var5->var0 = v337;
            *p_unsigned int var1 = v162;
            v152->var0 = (int *)&v252[4 * v251];
            if (v247) {
              operator delete(v247);
            }
          }
          else
          {
            *int v161 = 2;
            int v162 = v161 + 1;
          }
          *p_unsigned int var1 = v162;
          int v155 = (std::string *)unk_1EE4D5070(v155, "stringByReplacingOccurrencesOfString:withString:", @".coerce3", &stru_1EE465CC0);
          uint64_t v408 = 0;
          char obja = 1;
          goto LABEL_778;
        }
        if ((unk_1EE4D5080(v154, "containsString:", @".coerce") & 1) == 0)
        {
          uint64_t v181 = unk_1EE4D5078(v155, "length");
          if (v405 != v150 || v181)
          {
            int v157 = *p_var1;
            if (*p_var1 >= v152->var0)
            {
              var0 = p_var5->var0;
              uint64_t v352 = v157 - p_var5->var0;
              unint64_t v353 = v352 + 1;
              if ((unint64_t)(v352 + 1) >> 62) {
                abort();
              }
              uint64_t v354 = (char *)v152->var0 - (char *)var0;
              if (v354 >> 1 > v353) {
                unint64_t v353 = v354 >> 1;
              }
              if ((unint64_t)v354 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v173 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v173 = v353;
              }
              if (v173)
              {
                int v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
                int v157 = *p_var1;
                var0 = p_var5->var0;
              }
              else
              {
                int v174 = 0;
              }
              v280 = (int *)&v174[4 * v352];
              int *v280 = 6;
              v281 = v280 + 1;
              while (v157 != var0)
              {
                int v363 = *--v157;
                *--v280 = v363;
              }
LABEL_775:
              p_var5->var0 = v280;
              *p_unsigned int var1 = v281;
              v152->var0 = (int *)&v174[4 * v173];
              if (var0) {
                operator delete(var0);
              }
            }
            else
            {
              int v158 = 6;
LABEL_672:
              *int v157 = v158;
              v281 = v157 + 1;
            }
            *p_unsigned int var1 = v281;
            goto LABEL_778;
          }
        }
        if (!v409)
        {
          CGRect v182 = *p_var1;
          if (*p_var1 >= v152->var0)
          {
            v315 = p_var5->var0;
            uint64_t v316 = v182 - p_var5->var0;
            unint64_t v317 = v316 + 1;
            if ((unint64_t)(v316 + 1) >> 62) {
              abort();
            }
            uint64_t v318 = (char *)v152->var0 - (char *)v315;
            if (v318 >> 1 > v317) {
              unint64_t v317 = v318 >> 1;
            }
            if ((unint64_t)v318 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v319 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v319 = v317;
            }
            if (v319)
            {
              v320 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v319);
              CGRect v182 = *p_var1;
              v315 = p_var5->var0;
            }
            else
            {
              v320 = 0;
            }
            v350 = (int *)&v320[4 * v316];
            int *v350 = 30;
            CGRect v183 = v350 + 1;
            while (v182 != v315)
            {
              int v351 = *--v182;
              *--v350 = v351;
            }
            p_var5->var0 = v350;
            *p_unsigned int var1 = v183;
            v152->var0 = (int *)&v320[4 * v319];
            if (v315) {
              operator delete(v315);
            }
          }
          else
          {
            *CGRect v182 = 30;
            CGRect v183 = v182 + 1;
          }
          *p_unsigned int var1 = v183;
          uint64_t v341 = 1;
          goto LABEL_751;
        }
        CIKernelError(v402, 5u, &cfstr_FunctionHasToo.isa);
        v398 = ci_logger_api();
        if (os_log_type_enabled(v398, OS_LOG_TYPE_ERROR)) {
          CIKernelReflection::reflect();
        }
LABEL_830:
        uint64_t v392 = 0;
LABEL_831:
        if (v416)
        {
          v417 = (char *)v416;
          operator delete(v416);
        }
        if (v419)
        {
          v420 = (uint64_t *)v419;
          operator delete(v419);
        }
        if (__p)
        {
          v423 = (char *)__p;
          operator delete(__p);
        }
        return v392;
      case 5:
        int v157 = *p_var1;
        if (*p_var1 < v152->var0)
        {
          int v158 = 7;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        uint64_t v198 = v157 - p_var5->var0;
        unint64_t v199 = v198 + 1;
        if ((unint64_t)(v198 + 1) >> 62) {
          abort();
        }
        uint64_t v200 = (char *)v152->var0 - (char *)var0;
        if (v200 >> 1 > v199) {
          unint64_t v199 = v200 >> 1;
        }
        if ((unint64_t)v200 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v173 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v173 = v199;
        }
        if (v173)
        {
          int v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          int v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          int v174 = 0;
        }
        v280 = (int *)&v174[4 * v198];
        int *v280 = 7;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          int v288 = *--v157;
          *--v280 = v288;
        }
        goto LABEL_775;
      case 6:
        int v157 = *p_var1;
        int v175 = v152->var0;
        if (v409 == 2)
        {
          if (v157 >= v175)
          {
            v271 = p_var5->var0;
            uint64_t v272 = v157 - p_var5->var0;
            unint64_t v273 = v272 + 1;
            if ((unint64_t)(v272 + 1) >> 62) {
              abort();
            }
            uint64_t v274 = (char *)v175 - (char *)v271;
            if (v274 >> 1 > v273) {
              unint64_t v273 = v274 >> 1;
            }
            if ((unint64_t)v274 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v275 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v275 = v273;
            }
            if (v275)
            {
              v276 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v275);
              int v157 = *p_var1;
              v271 = p_var5->var0;
            }
            else
            {
              v276 = 0;
            }
            v346 = (int *)&v276[4 * v272];
            int *v346 = 36;
            int v176 = v346 + 1;
            while (v157 != v271)
            {
              int v347 = *--v157;
              *--v346 = v347;
            }
            p_var5->var0 = v346;
            *p_unsigned int var1 = v176;
            v152->var0 = (int *)&v276[4 * v275];
            if (v271) {
              operator delete(v271);
            }
          }
          else
          {
            *int v157 = 36;
            int v176 = v157 + 1;
          }
          *p_unsigned int var1 = v176;
          uint64_t v341 = 3;
          goto LABEL_751;
        }
        if (v157 < v175)
        {
          int v158 = 8;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        uint64_t v277 = v157 - p_var5->var0;
        unint64_t v278 = v277 + 1;
        if ((unint64_t)(v277 + 1) >> 62) {
          abort();
        }
        uint64_t v279 = (char *)v175 - (char *)var0;
        if (v279 >> 1 > v278) {
          unint64_t v278 = v279 >> 1;
        }
        if ((unint64_t)v279 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v173 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v173 = v278;
        }
        if (v173)
        {
          int v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          int v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          int v174 = 0;
        }
        v280 = (int *)&v174[4 * v277];
        int *v280 = 8;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          int v348 = *--v157;
          *--v280 = v348;
        }
        goto LABEL_775;
      case 7:
        int v163 = *p_var1;
        if (*p_var1 < v152->var0)
        {
          int v177 = 9;
          goto LABEL_324;
        }
        v201 = p_var5->var0;
        uint64_t v202 = v163 - p_var5->var0;
        unint64_t v203 = v202 + 1;
        if ((unint64_t)(v202 + 1) >> 62) {
          abort();
        }
        uint64_t v204 = (char *)v152->var0 - (char *)v201;
        if (v204 >> 1 > v203) {
          unint64_t v203 = v204 >> 1;
        }
        if ((unint64_t)v204 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v205 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v205 = v203;
        }
        if (v205)
        {
          v206 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v205);
          int v163 = *p_var1;
          v201 = p_var5->var0;
        }
        else
        {
          v206 = 0;
        }
        v289 = (int *)&v206[4 * v202];
        int *v289 = 9;
        uint64_t v187 = v289 + 1;
        while (v163 != v201)
        {
          int v290 = *--v163;
          *--v289 = v290;
        }
        goto LABEL_696;
      case 11:
        int v163 = *p_var1;
        if (*p_var1 < v152->var0)
        {
          int v177 = 10;
          goto LABEL_324;
        }
        v201 = p_var5->var0;
        uint64_t v210 = v163 - p_var5->var0;
        unint64_t v211 = v210 + 1;
        if ((unint64_t)(v210 + 1) >> 62) {
          abort();
        }
        uint64_t v212 = (char *)v152->var0 - (char *)v201;
        if (v212 >> 1 > v211) {
          unint64_t v211 = v212 >> 1;
        }
        if ((unint64_t)v212 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v205 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v205 = v211;
        }
        if (v205)
        {
          v206 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v205);
          int v163 = *p_var1;
          v201 = p_var5->var0;
        }
        else
        {
          v206 = 0;
        }
        v289 = (int *)&v206[4 * v210];
        int *v289 = 10;
        uint64_t v187 = v289 + 1;
        while (v163 != v201)
        {
          int v292 = *--v163;
          *--v289 = v292;
        }
        goto LABEL_696;
      case 15:
        int v163 = *p_var1;
        int v164 = v152->var0;
        if (v409 == 3)
        {
          if (v163 >= v164)
          {
            v253 = p_var5->var0;
            uint64_t v254 = v163 - p_var5->var0;
            unint64_t v255 = v254 + 1;
            if ((unint64_t)(v254 + 1) >> 62) {
              abort();
            }
            uint64_t v256 = (char *)v164 - (char *)v253;
            if (v256 >> 1 > v255) {
              unint64_t v255 = v256 >> 1;
            }
            if ((unint64_t)v256 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v257 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v257 = v255;
            }
            if (v257)
            {
              v258 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v257);
              int v163 = *p_var1;
              v253 = p_var5->var0;
            }
            else
            {
              v258 = 0;
            }
            v339 = (int *)&v258[4 * v254];
            int *v339 = 37;
            int v165 = v339 + 1;
            while (v163 != v253)
            {
              int v340 = *--v163;
              *--v339 = v340;
            }
            p_var5->var0 = v339;
            *p_unsigned int var1 = v165;
            v152->var0 = (int *)&v258[4 * v257];
            if (v253) {
              operator delete(v253);
            }
          }
          else
          {
            *int v163 = 37;
            int v165 = v163 + 1;
          }
          *p_unsigned int var1 = v165;
          uint64_t v341 = 4;
          goto LABEL_751;
        }
        if (v163 >= v164)
        {
          v201 = p_var5->var0;
          uint64_t v259 = v163 - p_var5->var0;
          unint64_t v260 = v259 + 1;
          if ((unint64_t)(v259 + 1) >> 62) {
            abort();
          }
          uint64_t v261 = (char *)v164 - (char *)v201;
          if (v261 >> 1 > v260) {
            unint64_t v260 = v261 >> 1;
          }
          if ((unint64_t)v261 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v205 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v205 = v260;
          }
          if (v205)
          {
            v206 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v205);
            int v163 = *p_var1;
            v201 = p_var5->var0;
          }
          else
          {
            v206 = 0;
          }
          v289 = (int *)&v206[4 * v259];
          int *v289 = 11;
          uint64_t v187 = v289 + 1;
          while (v163 != v201)
          {
            int v342 = *--v163;
            *--v289 = v342;
          }
LABEL_696:
          p_var5->var0 = v289;
          *p_unsigned int var1 = v187;
          v152->var0 = (int *)&v206[4 * v205];
          if (v201) {
            operator delete(v201);
          }
        }
        else
        {
          int v177 = 11;
LABEL_324:
          *int v163 = v177;
          uint64_t v187 = v163 + 1;
        }
        *p_unsigned int var1 = v187;
        int v155 = (std::string *)unk_1EE4D5088(v155, "stringByReplacingOccurrencesOfString:withString:", @".coerce", &stru_1EE465CC0);
        goto LABEL_778;
      case 16:
        int v157 = *p_var1;
        if (*p_var1 < v152->var0)
        {
          int v158 = 12;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        uint64_t v195 = v157 - p_var5->var0;
        unint64_t v196 = v195 + 1;
        if ((unint64_t)(v195 + 1) >> 62) {
          abort();
        }
        uint64_t v197 = (char *)v152->var0 - (char *)var0;
        if (v197 >> 1 > v196) {
          unint64_t v196 = v197 >> 1;
        }
        if ((unint64_t)v197 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v173 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v173 = v196;
        }
        if (v173)
        {
          int v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          int v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          int v174 = 0;
        }
        v280 = (int *)&v174[4 * v195];
        int *v280 = 12;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          int v287 = *--v157;
          *--v280 = v287;
        }
        goto LABEL_775;
      case 17:
        int v157 = *p_var1;
        if (*p_var1 < v152->var0)
        {
          int v158 = 13;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        uint64_t v184 = v157 - p_var5->var0;
        unint64_t v185 = v184 + 1;
        if ((unint64_t)(v184 + 1) >> 62) {
          abort();
        }
        uint64_t v186 = (char *)v152->var0 - (char *)var0;
        if (v186 >> 1 > v185) {
          unint64_t v185 = v186 >> 1;
        }
        if ((unint64_t)v186 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v173 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v173 = v185;
        }
        if (v173)
        {
          int v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          int v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          int v174 = 0;
        }
        v280 = (int *)&v174[4 * v184];
        int *v280 = 13;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          int v283 = *--v157;
          *--v280 = v283;
        }
        goto LABEL_775;
      case 18:
        int v157 = *p_var1;
        if (*p_var1 < v152->var0)
        {
          int v158 = 14;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        uint64_t v216 = v157 - p_var5->var0;
        unint64_t v217 = v216 + 1;
        if ((unint64_t)(v216 + 1) >> 62) {
          abort();
        }
        uint64_t v218 = (char *)v152->var0 - (char *)var0;
        if (v218 >> 1 > v217) {
          unint64_t v217 = v218 >> 1;
        }
        if ((unint64_t)v218 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v173 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v173 = v217;
        }
        if (v173)
        {
          int v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          int v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          int v174 = 0;
        }
        v280 = (int *)&v174[4 * v216];
        int *v280 = 14;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          int v294 = *--v157;
          *--v280 = v294;
        }
        goto LABEL_775;
      case 19:
        int v157 = *p_var1;
        if (*p_var1 < v152->var0)
        {
          int v158 = 15;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        uint64_t v222 = v157 - p_var5->var0;
        unint64_t v223 = v222 + 1;
        if ((unint64_t)(v222 + 1) >> 62) {
          abort();
        }
        uint64_t v224 = (char *)v152->var0 - (char *)var0;
        if (v224 >> 1 > v223) {
          unint64_t v223 = v224 >> 1;
        }
        if ((unint64_t)v224 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v173 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v173 = v223;
        }
        if (v173)
        {
          int v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          int v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          int v174 = 0;
        }
        v280 = (int *)&v174[4 * v222];
        int *v280 = 15;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          int v296 = *--v157;
          *--v280 = v296;
        }
        goto LABEL_775;
      case 20:
        int v157 = *p_var1;
        if (*p_var1 < v152->var0)
        {
          int v158 = 16;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        uint64_t v219 = v157 - p_var5->var0;
        unint64_t v220 = v219 + 1;
        if ((unint64_t)(v219 + 1) >> 62) {
          abort();
        }
        uint64_t v221 = (char *)v152->var0 - (char *)var0;
        if (v221 >> 1 > v220) {
          unint64_t v220 = v221 >> 1;
        }
        if ((unint64_t)v221 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v173 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v173 = v220;
        }
        if (v173)
        {
          int v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          int v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          int v174 = 0;
        }
        v280 = (int *)&v174[4 * v219];
        int *v280 = 16;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          int v295 = *--v157;
          *--v280 = v295;
        }
        goto LABEL_775;
      case 24:
        int v157 = *p_var1;
        if (*p_var1 < v152->var0)
        {
          int v158 = 17;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        uint64_t v231 = v157 - p_var5->var0;
        unint64_t v232 = v231 + 1;
        if ((unint64_t)(v231 + 1) >> 62) {
          abort();
        }
        uint64_t v233 = (char *)v152->var0 - (char *)var0;
        if (v233 >> 1 > v232) {
          unint64_t v232 = v233 >> 1;
        }
        if ((unint64_t)v233 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v173 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v173 = v232;
        }
        if (v173)
        {
          int v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          int v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          int v174 = 0;
        }
        v280 = (int *)&v174[4 * v231];
        int *v280 = 17;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          int v299 = *--v157;
          *--v280 = v299;
        }
        goto LABEL_775;
      case 28:
        int v157 = *p_var1;
        if (*p_var1 < v152->var0)
        {
          int v158 = 18;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        uint64_t v213 = v157 - p_var5->var0;
        unint64_t v214 = v213 + 1;
        if ((unint64_t)(v213 + 1) >> 62) {
          abort();
        }
        uint64_t v215 = (char *)v152->var0 - (char *)var0;
        if (v215 >> 1 > v214) {
          unint64_t v214 = v215 >> 1;
        }
        if ((unint64_t)v215 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v173 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v173 = v214;
        }
        if (v173)
        {
          int v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          int v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          int v174 = 0;
        }
        v280 = (int *)&v174[4 * v213];
        int *v280 = 18;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          int v293 = *--v157;
          *--v280 = v293;
        }
        goto LABEL_775;
      case 29:
        int v157 = *p_var1;
        if (*p_var1 < v152->var0)
        {
          int v158 = 19;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        uint64_t v225 = v157 - p_var5->var0;
        unint64_t v226 = v225 + 1;
        if ((unint64_t)(v225 + 1) >> 62) {
          abort();
        }
        uint64_t v227 = (char *)v152->var0 - (char *)var0;
        if (v227 >> 1 > v226) {
          unint64_t v226 = v227 >> 1;
        }
        if ((unint64_t)v227 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v173 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v173 = v226;
        }
        if (v173)
        {
          int v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          int v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          int v174 = 0;
        }
        v280 = (int *)&v174[4 * v225];
        int *v280 = 19;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          int v297 = *--v157;
          *--v280 = v297;
        }
        goto LABEL_775;
      case 30:
        int v157 = *p_var1;
        if (*p_var1 < v152->var0)
        {
          int v158 = 20;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        uint64_t v189 = v157 - p_var5->var0;
        unint64_t v190 = v189 + 1;
        if ((unint64_t)(v189 + 1) >> 62) {
          abort();
        }
        uint64_t v191 = (char *)v152->var0 - (char *)var0;
        if (v191 >> 1 > v190) {
          unint64_t v190 = v191 >> 1;
        }
        if ((unint64_t)v191 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v173 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v173 = v190;
        }
        if (v173)
        {
          int v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          int v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          int v174 = 0;
        }
        v280 = (int *)&v174[4 * v189];
        int *v280 = 20;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          int v284 = *--v157;
          *--v280 = v284;
        }
        goto LABEL_775;
      case 31:
        int v157 = *p_var1;
        if (*p_var1 < v152->var0)
        {
          int v158 = 21;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        uint64_t v178 = v157 - p_var5->var0;
        unint64_t v179 = v178 + 1;
        if ((unint64_t)(v178 + 1) >> 62) {
          abort();
        }
        uint64_t v180 = (char *)v152->var0 - (char *)var0;
        if (v180 >> 1 > v179) {
          unint64_t v179 = v180 >> 1;
        }
        if ((unint64_t)v180 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v173 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v173 = v179;
        }
        if (v173)
        {
          int v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          int v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          int v174 = 0;
        }
        v280 = (int *)&v174[4 * v178];
        int *v280 = 21;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          int v282 = *--v157;
          *--v280 = v282;
        }
        goto LABEL_775;
      case 32:
        int v157 = *p_var1;
        if (*p_var1 < v152->var0)
        {
          int v158 = 22;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        uint64_t v207 = v157 - p_var5->var0;
        unint64_t v208 = v207 + 1;
        if ((unint64_t)(v207 + 1) >> 62) {
          abort();
        }
        uint64_t v209 = (char *)v152->var0 - (char *)var0;
        if (v209 >> 1 > v208) {
          unint64_t v208 = v209 >> 1;
        }
        if ((unint64_t)v209 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v173 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v173 = v208;
        }
        if (v173)
        {
          int v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          int v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          int v174 = 0;
        }
        v280 = (int *)&v174[4 * v207];
        int *v280 = 22;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          int v291 = *--v157;
          *--v280 = v291;
        }
        goto LABEL_775;
      case 33:
        int v157 = *p_var1;
        if (*p_var1 < v152->var0)
        {
          int v158 = 23;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        uint64_t v228 = v157 - p_var5->var0;
        unint64_t v229 = v228 + 1;
        if ((unint64_t)(v228 + 1) >> 62) {
          abort();
        }
        uint64_t v230 = (char *)v152->var0 - (char *)var0;
        if (v230 >> 1 > v229) {
          unint64_t v229 = v230 >> 1;
        }
        if ((unint64_t)v230 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v173 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v173 = v229;
        }
        if (v173)
        {
          int v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          int v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          int v174 = 0;
        }
        v280 = (int *)&v174[4 * v228];
        int *v280 = 23;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          int v298 = *--v157;
          *--v280 = v298;
        }
        goto LABEL_775;
      case 34:
        int v157 = *p_var1;
        int v167 = v152->var0;
        if (v409 == 1)
        {
          if (v157 >= v167)
          {
            v262 = p_var5->var0;
            uint64_t v263 = v157 - p_var5->var0;
            unint64_t v264 = v263 + 1;
            if ((unint64_t)(v263 + 1) >> 62) {
              abort();
            }
            uint64_t v265 = (char *)v167 - (char *)v262;
            if (v265 >> 1 > v264) {
              unint64_t v264 = v265 >> 1;
            }
            if ((unint64_t)v265 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v266 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v266 = v264;
            }
            if (v266)
            {
              v267 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v266);
              int v157 = *p_var1;
              v262 = p_var5->var0;
            }
            else
            {
              v267 = 0;
            }
            v343 = (int *)&v267[4 * v263];
            int *v343 = 35;
            CGRect v168 = v343 + 1;
            while (v157 != v262)
            {
              int v344 = *--v157;
              *--v343 = v344;
            }
            p_var5->var0 = v343;
            *p_unsigned int var1 = v168;
            v152->var0 = (int *)&v267[4 * v266];
            if (v262) {
              operator delete(v262);
            }
          }
          else
          {
            *int v157 = 35;
            CGRect v168 = v157 + 1;
          }
          *p_unsigned int var1 = v168;
          uint64_t v341 = 2;
          goto LABEL_751;
        }
        if (v157 < v167)
        {
          int v158 = 24;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        uint64_t v268 = v157 - p_var5->var0;
        unint64_t v269 = v268 + 1;
        if ((unint64_t)(v268 + 1) >> 62) {
          abort();
        }
        uint64_t v270 = (char *)v167 - (char *)var0;
        if (v270 >> 1 > v269) {
          unint64_t v269 = v270 >> 1;
        }
        if ((unint64_t)v270 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v173 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v173 = v269;
        }
        if (v173)
        {
          int v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          int v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          int v174 = 0;
        }
        v280 = (int *)&v174[4 * v268];
        int *v280 = 24;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          int v345 = *--v157;
          *--v280 = v345;
        }
        goto LABEL_775;
      case 35:
        int v157 = *p_var1;
        if (*p_var1 < v152->var0) {
          goto LABEL_299;
        }
        var0 = p_var5->var0;
        uint64_t v234 = v157 - p_var5->var0;
        unint64_t v235 = v234 + 1;
        if ((unint64_t)(v234 + 1) >> 62) {
          abort();
        }
        uint64_t v236 = (char *)v152->var0 - (char *)var0;
        if (v236 >> 1 > v235) {
          unint64_t v235 = v236 >> 1;
        }
        if ((unint64_t)v236 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v173 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v173 = v235;
        }
        if (v173)
        {
          int v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          int v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          int v174 = 0;
        }
        v280 = (int *)&v174[4 * v234];
        int *v280 = 26;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          int v300 = *--v157;
          *--v280 = v300;
        }
        goto LABEL_775;
      case 36:
        int v157 = *p_var1;
        if (*p_var1 < v152->var0)
        {
LABEL_299:
          int v158 = 26;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        uint64_t v170 = v157 - p_var5->var0;
        unint64_t v171 = v170 + 1;
        if ((unint64_t)(v170 + 1) >> 62) {
          abort();
        }
        uint64_t v172 = (char *)v152->var0 - (char *)var0;
        if (v172 >> 1 > v171) {
          unint64_t v171 = v172 >> 1;
        }
        if ((unint64_t)v172 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v173 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v173 = v171;
        }
        if (v173)
        {
          int v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          int v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          int v174 = 0;
        }
        v280 = (int *)&v174[4 * v170];
        int *v280 = 26;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          int v285 = *--v157;
          *--v280 = v285;
        }
        goto LABEL_775;
      case 58:
        if (v409 == 5)
        {
          v245 = *p_var1;
          if (*p_var1 < v152->var0)
          {
            int v246 = 39;
            goto LABEL_605;
          }
          v304 = p_var5->var0;
          uint64_t v327 = v245 - p_var5->var0;
          unint64_t v328 = v327 + 1;
          if ((unint64_t)(v327 + 1) >> 62) {
            abort();
          }
          uint64_t v329 = (char *)v152->var0 - (char *)v304;
          if (v329 >> 1 > v328) {
            unint64_t v328 = v329 >> 1;
          }
          if ((unint64_t)v329 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v308 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v308 = v328;
          }
          if (v308)
          {
            v309 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v308);
            v245 = *p_var1;
            v304 = p_var5->var0;
          }
          else
          {
            v309 = 0;
          }
          v310 = (int *)&v309[4 * v327];
          int *v310 = 39;
          v303 = v310 + 1;
          while (v245 != v304)
          {
            int v357 = *--v245;
            *--v310 = v357;
          }
LABEL_748:
          p_var5->var0 = v310;
          *p_unsigned int var1 = v303;
          v152->var0 = (int *)&v309[4 * v308];
          if (v304) {
            operator delete(v304);
          }
LABEL_750:
          *p_unsigned int var1 = v303;
          uint64_t v341 = 6;
LABEL_751:
          uint64_t v409 = v341;
LABEL_778:
          v364 = (char *)unk_1EE4D5090(v155, "UTF8String");
          if (!v364) {
            v364 = CI::KernelArguments::name_for_type(*(*p_var1 - 1));
          }
          std::string::basic_string[abi:nn180100]<0>(v410, v364);
          v366 = (char *)this->var6.var1;
          v365 = (char *)this->var6.var2.var0;
          if (v366 >= v365)
          {
            unint64_t v368 = 0xAAAAAAAAAAAAAAABLL * ((v366 - (char *)p_var6->var0) >> 3);
            unint64_t v369 = v368 + 1;
            if (v368 + 1 > 0xAAAAAAAAAAAAAAALL) {
              abort();
            }
            unint64_t v370 = 0xAAAAAAAAAAAAAAABLL * ((v365 - (char *)p_var6->var0) >> 3);
            if (2 * v370 > v369) {
              unint64_t v369 = 2 * v370;
            }
            if (v370 >= 0x555555555555555) {
              unint64_t v371 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v371 = v369;
            }
            v426.__end_cap_.__value_ = (std::allocator<std::string> *)&this->var6.var2;
            if (v371) {
              v372 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SWRendererFunctionInputNode>>((uint64_t)&this->var6.var2, v371);
            }
            else {
              v372 = 0;
            }
            v373 = &v372[24 * v368];
            long long v374 = *(_OWORD *)v410;
            *((void *)v373 + 2) = v411;
            *(_OWORD *)v373 = v374;
            v410[1] = 0;
            uint64_t v411 = 0;
            v410[0] = 0;
            v376 = (char *)this->var6.var0;
            v375 = (char *)this->var6.var1;
            if (v375 == v376)
            {
              int64x2_t v379 = vdupq_n_s64((unint64_t)v375);
              v377 = &v372[24 * v368];
            }
            else
            {
              v377 = &v372[24 * v368];
              do
              {
                long long v378 = *(_OWORD *)(v375 - 24);
                *((void *)v377 - 1) = *((void *)v375 - 1);
                *(_OWORD *)(v377 - 24) = v378;
                v377 -= 24;
                *((void *)v375 - 2) = 0;
                *((void *)v375 - 1) = 0;
                *((void *)v375 - 3) = 0;
                v375 -= 24;
              }
              while (v375 != v376);
              int64x2_t v379 = *(int64x2_t *)&p_var6->var0;
            }
            v380 = v373 + 24;
            this->var6.var0 = v377;
            this->var6.unsigned int var1 = v373 + 24;
            *(int64x2_t *)&v426.__begin_ = v379;
            v381 = (std::string *)this->var6.var2.var0;
            this->var6.var2.var0 = &v372[24 * v371];
            v426.__end_cap_.__value_ = v381;
            v426.__first_ = (std::__split_buffer<std::string>::pointer)v379.i64[0];
            std::__split_buffer<std::string>::~__split_buffer(&v426);
            int v382 = SHIBYTE(v411);
            this->var6.unsigned int var1 = v380;
            if (v382 < 0) {
              operator delete(v410[0]);
            }
          }
          else
          {
            long long v367 = *(_OWORD *)v410;
            *((void *)v366 + 2) = v411;
            *(_OWORD *)v366 = v367;
            this->var6.unsigned int var1 = v366 + 24;
          }
          goto LABEL_798;
        }
        if (v409 == 4)
        {
          v243 = *p_var1;
          if (*p_var1 < v152->var0)
          {
            int v244 = 38;
            goto LABEL_677;
          }
          v321 = p_var5->var0;
          uint64_t v322 = v243 - p_var5->var0;
          unint64_t v323 = v322 + 1;
          if ((unint64_t)(v322 + 1) >> 62) {
            abort();
          }
          uint64_t v324 = (char *)v152->var0 - (char *)v321;
          if (v324 >> 1 > v323) {
            unint64_t v323 = v324 >> 1;
          }
          if ((unint64_t)v324 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v325 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v325 = v323;
          }
          if (v325)
          {
            v326 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v325);
            v243 = *p_var1;
            v321 = p_var5->var0;
          }
          else
          {
            v326 = 0;
          }
          v355 = (int *)&v326[4 * v322];
          int *v355 = 38;
          v336 = v355 + 1;
          while (v243 != v321)
          {
            int v356 = *--v243;
            *--v355 = v356;
          }
LABEL_804:
          p_var5->var0 = v355;
          *p_unsigned int var1 = v336;
          v152->var0 = (int *)&v326[4 * v325];
          if (v321) {
            operator delete(v321);
          }
          goto LABEL_806;
        }
        if (v409)
        {
          CIKernelError(v402, 3u, &cfstr_UnsupportedTyp.isa, v154);
          v399 = ci_logger_api();
          if (!os_log_type_enabled(v399, OS_LOG_TYPE_ERROR)) {
            goto LABEL_830;
          }
          goto LABEL_851;
        }
        ++v408;
        uint64_t v409 = 0;
LABEL_798:
        if (++v150 == v153) {
          goto LABEL_811;
        }
        break;
      case 59:
        if (v408 == 1)
        {
          uint64_t v166 = 2;
LABEL_293:
          uint64_t v408 = v166;
          goto LABEL_798;
        }
        CIKernelError(v402, 3u, &cfstr_UnsupportedTyp.isa, v154);
        v397 = ci_logger_api();
        if (!os_log_type_enabled(v397, OS_LOG_TYPE_ERROR)) {
          goto LABEL_830;
        }
        goto LABEL_851;
      case 60:
        if (v408 == 2)
        {
          uint64_t v166 = 3;
          goto LABEL_293;
        }
        int v157 = *p_var1;
        int v188 = v152->var0;
        if (*((void *)v416 + v150) == 28)
        {
          if (v157 < v188)
          {
            int v158 = 29;
            goto LABEL_672;
          }
          var0 = p_var5->var0;
          uint64_t v330 = v157 - p_var5->var0;
          unint64_t v331 = v330 + 1;
          if ((unint64_t)(v330 + 1) >> 62) {
            abort();
          }
          uint64_t v332 = (char *)v188 - (char *)var0;
          if (v332 >> 1 > v331) {
            unint64_t v331 = v332 >> 1;
          }
          if ((unint64_t)v332 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v173 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v173 = v331;
          }
          if (v173)
          {
            int v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
            int v157 = *p_var1;
            var0 = p_var5->var0;
          }
          else
          {
            int v174 = 0;
          }
          v280 = (int *)&v174[4 * v330];
          int *v280 = 29;
          v281 = v280 + 1;
          while (v157 != var0)
          {
            int v358 = *--v157;
            *--v280 = v358;
          }
        }
        else
        {
          if (v157 < v188)
          {
            int v158 = 28;
            goto LABEL_672;
          }
          var0 = p_var5->var0;
          uint64_t v333 = v157 - p_var5->var0;
          unint64_t v334 = v333 + 1;
          if ((unint64_t)(v333 + 1) >> 62) {
            abort();
          }
          uint64_t v335 = (char *)v188 - (char *)var0;
          if (v335 >> 1 > v334) {
            unint64_t v334 = v335 >> 1;
          }
          if ((unint64_t)v335 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v173 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v173 = v334;
          }
          if (v173)
          {
            int v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
            int v157 = *p_var1;
            var0 = p_var5->var0;
          }
          else
          {
            int v174 = 0;
          }
          v280 = (int *)&v174[4 * v333];
          int *v280 = 28;
          v281 = v280 + 1;
          while (v157 != var0)
          {
            int v359 = *--v157;
            *--v280 = v359;
          }
        }
        goto LABEL_775;
      default:
        if (v156 != 65000)
        {
LABEL_844:
          CIKernelError(v402, 3u, &cfstr_UnsupportedTyp.isa, v154);
          v396 = ci_logger_api();
          if (!os_log_type_enabled(v396, OS_LOG_TYPE_ERROR)) {
            goto LABEL_830;
          }
LABEL_851:
          CIKernelReflection::reflect();
          goto LABEL_830;
        }
        int v159 = *p_var1;
        if (*p_var1 >= v152->var0)
        {
          v237 = p_var5->var0;
          uint64_t v238 = v159 - p_var5->var0;
          unint64_t v239 = v238 + 1;
          if ((unint64_t)(v238 + 1) >> 62) {
            abort();
          }
          uint64_t v240 = (char *)v152->var0 - (char *)v237;
          if (v240 >> 1 > v239) {
            unint64_t v239 = v240 >> 1;
          }
          if ((unint64_t)v240 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v241 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v241 = v239;
          }
          if (v241)
          {
            v242 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v241);
            int v159 = *p_var1;
            v237 = p_var5->var0;
          }
          else
          {
            v242 = 0;
          }
          v301 = (int *)&v242[4 * v238];
          int *v301 = 4;
          int v160 = v301 + 1;
          while (v159 != v237)
          {
            int v302 = *--v159;
            *--v301 = v302;
          }
          p_var5->var0 = v301;
          *p_unsigned int var1 = v160;
          v152->var0 = (int *)&v242[4 * v241];
          if (v237) {
            operator delete(v237);
          }
        }
        else
        {
          *int v159 = 4;
          int v160 = v159 + 1;
        }
        *p_unsigned int var1 = v160;
LABEL_601:
        if ((unk_1EE4D50C8(v155, "isEqualToString:", @"coreimage::priv::destination") & 1) != 0
          || unk_1EE4D50D0(v155, "isEqualToString:", @"coreimage::priv::Destination"))
        {
          v245 = *p_var1;
          if (*p_var1 >= v152->var0)
          {
            v304 = p_var5->var0;
            uint64_t v305 = v245 - p_var5->var0;
            unint64_t v306 = v305 + 1;
            if ((unint64_t)(v305 + 1) >> 62) {
              abort();
            }
            uint64_t v307 = (char *)v152->var0 - (char *)v304;
            if (v307 >> 1 > v306) {
              unint64_t v306 = v307 >> 1;
            }
            if ((unint64_t)v307 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v308 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v308 = v306;
            }
            if (v308)
            {
              v309 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v308);
              v245 = *p_var1;
              v304 = p_var5->var0;
            }
            else
            {
              v309 = 0;
            }
            v310 = (int *)&v309[4 * v305];
            int *v310 = 31;
            v303 = v310 + 1;
            while (v245 != v304)
            {
              int v311 = *--v245;
              *--v310 = v311;
            }
            goto LABEL_748;
          }
          int v246 = 31;
        }
        else
        {
          if ((unk_1EE4D50B8(v155, "isEqualToString:", @"coreimage::priv::destination_h") & 1) == 0
            && !unk_1EE4D50C0(v155, "isEqualToString:", @"coreimage::priv::Destination_h"))
          {
            if ((unk_1EE4D50A8(v155, "isEqualToString:", @"coreimage::group::destination") & 1) != 0
              || unk_1EE4D50B0(v155, "isEqualToString:", @"coreimage::group::Destination"))
            {
              v243 = *p_var1;
              if (*p_var1 >= v152->var0)
              {
                v321 = p_var5->var0;
                uint64_t v360 = v243 - p_var5->var0;
                unint64_t v361 = v360 + 1;
                if ((unint64_t)(v360 + 1) >> 62) {
                  abort();
                }
                uint64_t v362 = (char *)v152->var0 - (char *)v321;
                if (v362 >> 1 > v361) {
                  unint64_t v361 = v362 >> 1;
                }
                if ((unint64_t)v362 >= 0x7FFFFFFFFFFFFFFCLL) {
                  unint64_t v325 = 0x3FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v325 = v361;
                }
                if (v325)
                {
                  v326 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v325);
                  v243 = *p_var1;
                  v321 = p_var5->var0;
                }
                else
                {
                  v326 = 0;
                }
                v355 = (int *)&v326[4 * v360];
                int *v355 = 33;
                v336 = v355 + 1;
                while (v243 != v321)
                {
                  int v383 = *--v243;
                  *--v355 = v383;
                }
                goto LABEL_804;
              }
              int v244 = 33;
LABEL_677:
              int *v243 = v244;
              v336 = v243 + 1;
LABEL_806:
              *p_unsigned int var1 = v336;
            }
            else
            {
              if ((unk_1EE4D5098(v155, "isEqualToString:", @"coreimage::group::destination_h") & 1) == 0
                && !unk_1EE4D50A0(v155, "isEqualToString:", @"coreimage::group::Destination_h"))
              {
                CIKernelError(v402, 3u, &cfstr_UnsupportedTyp.isa, v155);
                v384 = ci_logger_api();
                if (os_log_type_enabled(v384, OS_LOG_TYPE_ERROR))
                {
                  v385 = *v403;
                  LODWORD(v426.__first_) = 136446466;
                  *(std::__split_buffer<std::string>::pointer *)((char *)&v426.__first_ + 4) = v385;
                  WORD2(v426.__begin_) = 2114;
                  *(std::__split_buffer<std::string>::pointer *)((char *)&v426.__begin_ + 6) = v155;
                  _os_log_error_impl(&dword_193671000, v384, OS_LOG_TYPE_ERROR, "Function '%{public}s' has an unsupported type for the parameter '%{public}@'.", (uint8_t *)&v426, 0x16u);
                }
                goto LABEL_778;
              }
              LODWORD(v426.__first_) = 34;
              std::vector<CI::KernelArgumentType>::push_back[abi:nn180100]((uint64_t)&this->var5, &v426);
            }
            uint64_t v341 = 5;
            goto LABEL_751;
          }
          v245 = *p_var1;
          if (*p_var1 >= v152->var0)
          {
            v304 = p_var5->var0;
            uint64_t v312 = v245 - p_var5->var0;
            unint64_t v313 = v312 + 1;
            if ((unint64_t)(v312 + 1) >> 62) {
              abort();
            }
            uint64_t v314 = (char *)v152->var0 - (char *)v304;
            if (v314 >> 1 > v313) {
              unint64_t v313 = v314 >> 1;
            }
            if ((unint64_t)v314 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v308 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v308 = v313;
            }
            if (v308)
            {
              v309 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v308);
              v245 = *p_var1;
              v304 = p_var5->var0;
            }
            else
            {
              v309 = 0;
            }
            v310 = (int *)&v309[4 * v312];
            int *v310 = 32;
            v303 = v310 + 1;
            while (v245 != v304)
            {
              int v349 = *--v245;
              *--v310 = v349;
            }
            goto LABEL_748;
          }
          int v246 = 32;
        }
LABEL_605:
        int *v245 = v246;
        v303 = v245 + 1;
        goto LABEL_750;
    }
  }
}

void sub_1937D0F14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42)
{
  if (__p) {
    operator delete(__p);
  }
  if (a38) {
    operator delete(a38);
  }
  if (a41) {
    operator delete(a41);
  }
  _Unwind_Resume(exception_object);
}

void *CIKernelReflection::reflectConstants(CIKernelReflection *this)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  float v2 = objc_msgSend(this->var7, "functionWithName:", objc_msgSend(NSString, "stringWithUTF8String:", this->var2));
  if (!v2) {
    return 0;
  }
  uint64_t v3 = v2;
  uint64_t v4 = objc_msgSend((id)objc_msgSend(v2, "arguments"), "count");
  if (this->var12)
  {
    unint64_t v5 = (void *)[v3 functionConstantsDictionary];
    float v6 = (void *)[MEMORY[0x1E4F1CA60] dictionary];
    long long v35 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    uint64_t v7 = [v5 countByEnumeratingWithState:&v35 objects:v47 count:16];
    if (v7)
    {
      uint64_t v8 = v7;
      uint64_t v9 = *(void *)v36;
      do
      {
        for (uint64_t i = 0; i != v8; ++i)
        {
          if (*(void *)v36 != v9) {
            objc_enumerationMutation(v5);
          }
          uint64_t v11 = *(void *)(*((void *)&v35 + 1) + 8 * i);
          uint64_t v12 = (void *)[v5 objectForKeyedSubscript:v11];
          objc_msgSend(v6, "setValue:forKey:", objc_msgSend(NSNumber, "numberWithUnsignedInteger:", objc_msgSend(v12, "type")), v11);
        }
        uint64_t v8 = [v5 countByEnumeratingWithState:&v35 objects:v47 count:16];
      }
      while (v8);
    }
    return v6;
  }
  size_t v13 = v4;
  std::__split_buffer<std::string> v14 = (void *)[v3 device];
  obuint64_t j = 0;
  uint64_t v15 = malloc_type_calloc(v13, 0x18uLL, 0x1000040504FFAC1uLL);
  uint64_t v16 = v15;
  if (v13)
  {
    size_t v17 = v13;
    long long v18 = v15;
    do
    {
      *long long v18 = 3;
      v18 += 3;
      --v17;
    }
    while (v17);
  }
  v41[0] = 0;
  size_t v42 = v13;
  uint64_t v43 = v15;
  char v44 = 0;
  size_t v45 = v13;
  unint64_t v46 = v15;
  v40[0] = v3;
  v40[1] = v3;
  uint64_t v19 = objc_msgSend(v14, "newLibraryWithImageFilterFunctionsSPI:imageFilterFunctionInfo:error:", objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObjects:count:", v40, 2), v41, &obj);
  free(v16);
  if (!v19)
  {
    if (obj)
    {
      unint64_t v28 = ci_logger_api();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
        CIKernelReflection::reflectConstants();
      }
      CFShow(obj);
    }
    return 0;
  }
  uint64_t v20 = (void *)[v19 newFunctionWithName:@"ciKernelMain"];
  long long v21 = (void *)[v20 functionConstantsDictionary];
  float v6 = (void *)[MEMORY[0x1E4F1CA60] dictionary];
  long long v30 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  uint64_t v22 = [v21 countByEnumeratingWithState:&v30 objects:v39 count:16];
  if (v22)
  {
    uint64_t v23 = v22;
    uint64_t v24 = *(void *)v31;
    do
    {
      for (uint64_t j = 0; j != v23; ++j)
      {
        if (*(void *)v31 != v24) {
          objc_enumerationMutation(v21);
        }
        uint64_t v26 = *(void *)(*((void *)&v30 + 1) + 8 * j);
        uint64_t v27 = (void *)[v21 objectForKeyedSubscript:v26];
        objc_msgSend(v6, "setValue:forKey:", objc_msgSend(NSNumber, "numberWithUnsignedInteger:", objc_msgSend(v27, "type")), v26);
      }
      uint64_t v23 = [v21 countByEnumeratingWithState:&v30 objects:v39 count:16];
    }
    while (v23);
  }

  return v6;
}

std::string *CIKernelReflection::consolidate@<X0>(CIKernelReflection *this@<X0>, const CIKernelReflection *a2@<X1>, uint64_t a3@<X8>)
{
  long long v7 = *(_OWORD *)&a2->var3;
  *(_OWORD *)a3 = *(_OWORD *)&a2->var0;
  *(_OWORD *)(a3 + 16) = v7;
  uint64_t v8 = (_DWORD **)(a3 + 32);
  std::vector<CI::KernelArgumentType>::vector((void *)(a3 + 32), (uint64_t)&a2->var5);
  *(void *)(a3 + 56) = 0;
  *(void *)(a3 + 64) = 0;
  *(void *)(a3 + 72) = 0;
  BOOL result = std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>((std::string *)(a3 + 56), (long long *)a2->var6.var0, (long long *)a2->var6.var1, 0xAAAAAAAAAAAAAAABLL * (((char *)a2->var6.var1 - (char *)a2->var6.var0) >> 3));
  long long v10 = *(_OWORD *)&a2->var10;
  *(_OWORD *)(a3 + 80) = *(_OWORD *)&a2->var7;
  *(_OWORD *)(a3 + 96) = v10;
  *(_WORD *)(a3 + 112) = *(_WORD *)&a2->var12;
  *(void *)(a3 + 16) = this->var3;
  *(_DWORD *)(a3 + 92) = this->var9;
  var0 = this->var5.var0;
  uint64_t v12 = (char *)this->var5.var1 - (char *)var0;
  if (v12)
  {
    unint64_t v13 = v12 >> 2;
    std::__split_buffer<std::string> v14 = *v8;
    if (v13 <= 1) {
      unint64_t v13 = 1;
    }
    do
    {
      int v15 = *var0++;
      *v14++ = v15;
      --v13;
    }
    while (v13);
  }
  *(_DWORD *)(a3 + 88) |= this->var8;
  *(unsigned char *)(a3 + 113) = this->var13;
  return result;
}

void sub_1937D1628(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 40) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void CIKernelReflection::~CIKernelReflection(CIKernelReflection *this)
{
  p_var6 = &this->var6;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&p_var6);
  var0 = this->var5.var0;
  if (var0)
  {
    this->var5.unsigned int var1 = var0;
    operator delete(var0);
  }
}

void sub_1937D1758(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1937D1910(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
}

void sub_1937D1B88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
}

uint64_t CI::XXHashHelper::add(CI::XXHashHelper *this, CFNumberRef number)
{
  float v2 = this;
  if (number)
  {
    uint64_t v6 = 0;
    if (CFNumberIsFloatType(number)) {
      CFNumberGetValue(number, kCFNumberDoubleType, &v6);
    }
    else {
      CFNumberGetValue(number, kCFNumberSInt64Type, &v6);
    }
    __vImage_Buffer src = v6;
    this = v2;
    size_t v4 = 8;
  }
  else
  {
    LODWORD(__src) = 0;
    size_t v4 = 4;
  }
  return XXH64_update((uint64_t)this, (char *)&__src, v4);
}

CI::XXHashHelper *CI::XXHashHelper::add(CI::XXHashHelper *this, CFArrayRef theArray)
{
  if (theArray)
  {
    uint64_t v3 = this;
    this = (CI::XXHashHelper *)CFArrayGetCount(theArray);
    if ((int)this >= 1)
    {
      CFIndex v4 = 0;
      uint64_t v5 = this;
      do
      {
        ValueAtIndedouble x = (const __CFString *)CFArrayGetValueAtIndex(theArray, v4);
        CFTypeID v7 = CFGetTypeID(ValueAtIndex);
        if (v7 == CFNumberGetTypeID())
        {
          this = (CI::XXHashHelper *)CI::XXHashHelper::add(v3, (CFNumberRef)ValueAtIndex);
        }
        else if (v7 == CFDataGetTypeID())
        {
          this = (CI::XXHashHelper *)CI::XXHashHelper::add(v3, (CFDataRef)ValueAtIndex);
        }
        else
        {
          this = (CI::XXHashHelper *)CFStringGetTypeID();
          if ((CI::XXHashHelper *)v7 == this) {
            this = (CI::XXHashHelper *)CI::XXHashHelper::add(v3, ValueAtIndex);
          }
        }
        ++v4;
      }
      while (v5 != v4);
    }
  }
  return this;
}

void sub_1937D2268(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *))
{
  objc_sync_exit(v12);
  a12(&a10);
  _Unwind_Resume(a1);
}

void sub_1937D2B04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *__p, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__pa, uint64_t a14, uint64_t a15, uint64_t a16, CIKernelReflection *a17, uint64_t a18, CIKernelReflection *a19, CIKernelReflection *a20,CIKernelReflection *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  CIKernelReflection::~CIKernelReflection((CIKernelReflection *)&a41);
  CIKernelReflection::~CIKernelReflection((CIKernelReflection *)&a56);
  CIKernelReflection::~CIKernelReflection((CIKernelReflection *)&a71);
  _Unwind_Resume(a1);
}

uint64_t check_and_emit_compile_errors(NSString *a1, uint64_t a2, NSMutableArray *a3)
{
  v35[4] = *MEMORY[0x1E4F143B8];
  uint64_t result = fosl_filter_kernelpool_getNumDiagnostics(a2);
  if (result)
  {
    int v6 = result;
    uint64_t v7 = 0;
    uint64_t v26 = 0;
    uint64_t v8 = (void *)MEMORY[0x1E4FBA240];
    uint64_t v9 = (std::locale::id *)MEMORY[0x1E4FBA258];
    do
    {
      DiagnosticByIddouble x = (const char **)fosl_filter_kernelpool_getDiagnosticByIdx(a2, v7);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)"[CIKernelPool] ", 15);
      uint64_t v11 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v11, (uint64_t)":", 1);
      uint64_t v12 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v12, (uint64_t)": ", 2);
      switch(*(_DWORD *)DiagnosticByIdx)
      {
        case 0:
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)"note: ", 6);
          break;
        case 1:
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)"remark: ", 8);
          break;
        case 2:
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)"WARNING: ", 9);
          break;
        case 4:
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)"ERROR: ", 7);
          goto LABEL_9;
        case 8:
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)"FATAL ERROR: ", 13);
LABEL_9:
          ++v26;
          break;
        default:
          break;
      }
      size_t v13 = strlen(DiagnosticByIdx[2]);
      std::__split_buffer<std::string> v14 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)DiagnosticByIdx[2], v13);
      std::ios_base::getloc((const std::ios_base *)((char *)v14 + *(void *)(*v14 - 24)));
      int v15 = std::locale::use_facet(&v29, v9);
      ((void (*)(const std::locale::facet *, uint64_t))v15->__vftable[2].~facet_0)(v15, 10);
      std::locale::~locale(&v29);
      std::ostream::put();
      std::ostream::flush();
      v29.__locale_ = 0;
      long long v30 = &v29;
      uint64_t v31 = 0x2020000000;
      uint64_t v32 = 1;
      v28[0] = MEMORY[0x1E4F143A8];
      v28[1] = 3221225472;
      v28[2] = ___ZL29check_and_emit_compile_errorsP8NSStringPvP14NSMutableArray_block_invoke;
      v28[3] = &unk_1E57723F8;
      v28[4] = &v29;
      v28[5] = DiagnosticByIdx;
      [(NSString *)a1 enumerateLinesUsingBlock:v28];
      *(void *)((char *)v8 + *(void *)(*v8 - 24) + 24) = *((int *)DiagnosticByIdx + 2);
      uint64_t v16 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)"^", 1);
      std::ios_base::getloc((const std::ios_base *)((char *)v16 + *(void *)(*v16 - 24)));
      size_t v17 = std::locale::use_facet(&v33, v9);
      ((void (*)(const std::locale::facet *, uint64_t))v17->__vftable[2].~facet_0)(v17, 10);
      std::locale::~locale(&v33);
      std::ostream::put();
      std::ostream::flush();
      if (a3)
      {
        v34[0] = @"CIKernelMessageType";
        int v18 = *(_DWORD *)DiagnosticByIdx - 1;
        uint64_t v19 = @"CIKernelMessageTypeNote";
        if (v18 <= 7) {
          uint64_t v19 = (__CFString *)*((void *)&off_1E57724D0 + v18);
        }
        v35[0] = v19;
        v34[1] = @"CIKernelMessageLineNumber";
        v35[1] = [NSNumber numberWithUnsignedInt:*((unsigned int *)DiagnosticByIdx + 1)];
        v34[2] = @"kCIKernelMessageOffset";
        v35[2] = [NSNumber numberWithUnsignedInt:*((unsigned int *)DiagnosticByIdx + 3)];
        v34[3] = @"kCIKernelMessageDescription";
        v35[3] = [NSString stringWithUTF8String:DiagnosticByIdx[2]];
        -[NSMutableArray addObject:](a3, "addObject:", [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v35 forKeys:v34 count:4]);
      }
      free(DiagnosticByIdx);
      _Block_object_dispose(&v29, 8);
      uint64_t v7 = (v7 + 1);
    }
    while (v6 != v7);
    if (v26)
    {
      uint64_t v20 = (void *)std::ostream::operator<<();
      if (v26 == 1) {
        long long v21 = " error ";
      }
      else {
        long long v21 = " errors ";
      }
      if (v26 == 1) {
        uint64_t v22 = 7;
      }
      else {
        uint64_t v22 = 8;
      }
      uint64_t v23 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)v21, v22);
      uint64_t v24 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v23, (uint64_t)"generated.", 10);
      std::ios_base::getloc((const std::ios_base *)((char *)v24 + *(void *)(*v24 - 24)));
      unint64_t v25 = std::locale::use_facet(&v29, MEMORY[0x1E4FBA258]);
      ((void (*)(const std::locale::facet *, uint64_t))v25->__vftable[2].~facet_0)(v25, 10);
      std::locale::~locale(&v29);
      std::ostream::put();
      std::ostream::flush();
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void sub_1937D30C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::locale a18, uint64_t a19, uint64_t a20,uint64_t a21,std::locale a22)
{
}

uint64_t CIKernelReflection::operator=(uint64_t a1, uint64_t a2)
{
  long long v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  std::vector<CI::KernelArgumentType>::__move_assign(a1 + 32, (__n128 *)(a2 + 32));
  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(a1 + 56));
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  long long v5 = *(_OWORD *)(a2 + 80);
  long long v6 = *(_OWORD *)(a2 + 96);
  *(_WORD *)(a1 + 112) = *(_WORD *)(a2 + 112);
  *(_OWORD *)(a1 + 80) = v5;
  *(_OWORD *)(a1 + 96) = v6;
  return a1;
}

BOOL check_cikl_string(NSString *a1, const char *a2)
{
  NSUInteger v3 = [(NSString *)a1 length];
  if (!v3)
  {
    long long v4 = ci_logger_compile();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      check_cikl_string((uint64_t)a2, v4, v5, v6, v7, v8, v9, v10);
    }
  }
  return v3 != 0;
}

void sub_1937D34B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  MEMORY[0x1997023B0](v22, 0x10F1C409D028DB2);
  _Unwind_Resume(a1);
}

void sub_1937D35F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
}

void sub_1937D3D30(_Unwind_Exception *a1)
{
  NSUInteger v3 = (void *)STACK[0x260];
  if (STACK[0x260])
  {
    STACK[0x268] = (unint64_t)v3;
    operator delete(v3);
  }
  CIKernelReflection::~CIKernelReflection((CIKernelReflection *)&STACK[0x338]);
  CIKernelReflection::~CIKernelReflection((CIKernelReflection *)(v1 - 224));
  _Unwind_Resume(a1);
}

void CoreAnalytics(NSString *a1, NSString *a2, int a3)
{
  if (a1 && a2 && a3)
  {
    NSUInteger v3 = &unk_1E9330000;
    {
      uint64_t v9 = a1;
      int v8 = a3;
      uint64_t v7 = a2;
      NSUInteger v3 = &unk_1E9330000;
      a2 = v7;
      a3 = v8;
      int v6 = v5;
      a1 = v9;
      if (v6)
      {
        CoreAnalytics(NSString *,NSString *,int)::queue = (uint64_t)dispatch_queue_create("CoreImageAnalytics", 0);
        NSUInteger v3 = &unk_1E9330000;
        a1 = v9;
        a2 = v7;
        a3 = v8;
      }
    }
    long long v4 = *((void *)v3 + 438);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = ___ZL13CoreAnalyticsP8NSStringS0_i_block_invoke;
    block[3] = &unk_1E5772490;
    block[4] = a1;
    block[5] = a2;
    int v11 = a3;
    dispatch_async(v4, block);
  }
}

void sub_1937D4064(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
}

void sub_1937D431C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
}

void sub_1937D4704(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, void (*a20)(char *))
{
}

void sub_1937D49E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
}

void sub_1937D4C5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
}

void sub_1937D51B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, void (*a13)(char *))
{
}

void sub_1937D56C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, void (*a13)(char *))
{
}

void sub_1937D5BD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, void (*a13)(char *))
{
}

void sub_1937D64F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, CIKernelReflection *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,CIKernelReflection *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48)
{
}

void sub_1937D6710(_Unwind_Exception *a1)
{
}

void sub_1937D691C(_Unwind_Exception *a1)
{
}

void CI::Kernel::set_roi_selector(CI::Kernel *this, CFTypeRef cf)
{
  CFTypeRef v3 = (CFTypeRef)*((void *)this + 14);
  if (v3 != cf)
  {
    if (cf)
    {
      CFRetain(cf);
      CFTypeRef v3 = (CFTypeRef)*((void *)this + 14);
    }
    if (v3) {
      CFRelease(v3);
    }
    *((void *)this + 14) = cf;
  }
}

void sub_1937D757C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

const char *expected_argument_type(int a1)
{
  if ((a1 - 1) > 0x1C) {
    return "";
  }
  else {
    return off_1E5772510[a1 - 1];
  }
}

void sub_1937D827C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
}

void sub_1937D8624(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  MEMORY[0x1997023B0](v20, 0x10F1C40D6B4BB53);
  _Unwind_Resume(a1);
}

void sub_1937D8C4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
}

void sub_1937D8FD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  MEMORY[0x1997023B0](v18, 0x10F1C409D028DB2);
  _Unwind_Resume(a1);
}

void sub_1937D9664(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C4042639F6FLL);
  _Unwind_Resume(a1);
}

void sub_1937D9824(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
}

void sub_1937D9B2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
}

void sub_1937D9D60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
}

void std::__split_buffer<std::string>::~__split_buffer(std::__split_buffer<std::string> *this)
{
  if (this->__first_) {
    operator delete(this->__first_);
  }
}

void std::__split_buffer<std::string>::__destruct_at_end[abi:nn180100](uint64_t a1, void **a2)
{
  float v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      int v5 = v2 - 3;
      *(void *)(a1 + 16) = v2 - 3;
      if (*((char *)v2 - 1) < 0)
      {
        operator delete(*v5);
        int v5 = *(void ***)(a1 + 16);
      }
      float v2 = v5;
    }
    while (v5 != a2);
  }
}

void *std::vector<CI::KernelArgumentType>::vector(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  long long v4 = *(const void **)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  int64_t v5 = v3 - *(void *)a2;
  if (v3 != *(void *)a2)
  {
    std::vector<CI::KernelArgumentType>::__vallocate[abi:nn180100](a1, v5 >> 2);
    int v6 = (char *)a1[1];
    memmove(v6, v4, v5);
    a1[1] = &v6[v5];
  }
  return a1;
}

char *std::vector<CI::KernelArgumentType>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >> 62) {
    abort();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

std::string *std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>(std::string *result, long long *a2, long long *a3, unint64_t a4)
{
  if (a4)
  {
    int v6 = result;
    std::vector<CI::SWRendererFunctionInputNode>::__vallocate[abi:nn180100](result, a4);
    uint64_t result = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string*,std::string*,std::string*>((int)v6 + 16, a2, a3, (std::string *)v6->__r_.__value_.__l.__size_);
    v6->__r_.__value_.__l.__size_ = (std::string::size_type)result;
  }
  return result;
}

void sub_1937DA240(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

std::string *std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string*,std::string*,std::string*>(int a1, long long *a2, long long *a3, std::string *this)
{
  if (a2 != a3)
  {
    int v6 = a2;
    do
    {
      if (*((char *)v6 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)v6, *((void *)v6 + 1));
      }
      else
      {
        long long v7 = *v6;
        this->__r_.__value_.__r.__words[2] = *((void *)v6 + 2);
        *(_OWORD *)&this->__r_.__value_.__l.__data_ = v7;
      }
      int v6 = (long long *)((char *)v6 + 24);
      ++this;
    }
    while (v6 != a3);
  }
  return this;
}

void std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::string>::__clear[abi:nn180100]((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<std::string>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 24)
  {
    if (*(char *)(i - 1) < 0) {
      operator delete(*(void **)(i - 24));
    }
  }
  a1[1] = v2;
}

uint64_t ___ZL29check_and_emit_compile_errorsP8NSStringPvP14NSMutableArray_block_invoke(uint64_t result, void *a2, unsigned char *a3)
{
  uint64_t v3 = *(void *)(*(void *)(result + 32) + 8);
  uint64_t v4 = *(void *)(v3 + 24);
  if (v4 == *(_DWORD *)(*(void *)(result + 40) + 4))
  {
    uint64_t v6 = result;
    long long v7 = (const char *)[a2 UTF8String];
    size_t v8 = strlen(v7);
    uint64_t v9 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)v7, v8);
    std::ios_base::getloc((const std::ios_base *)((char *)v9 + *(void *)(*v9 - 24)));
    uint64_t v10 = std::locale::use_facet(&v11, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 10);
    std::locale::~locale(&v11);
    std::ostream::put();
    uint64_t result = std::ostream::flush();
    *a3 = 1;
    uint64_t v3 = *(void *)(*(void *)(v6 + 32) + 8);
    uint64_t v4 = *(void *)(v3 + 24);
  }
  *(void *)(v3 + 24) = v4 + 1;
  return result;
}

void sub_1937DA468(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
}

void *std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(void *a1, uint64_t a2, uint64_t a3)
{
  MEMORY[0x199702240](v13, a1);
  if (v13[0])
  {
    uint64_t v6 = (uint64_t)a1 + *(void *)(*a1 - 24);
    uint64_t v7 = *(void *)(v6 + 40);
    int v8 = *(_DWORD *)(v6 + 8);
    int v9 = *(_DWORD *)(v6 + 144);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
      uint64_t v10 = std::locale::use_facet(&v14, MEMORY[0x1E4FBA258]);
      int v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v9;
    }
    if ((v8 & 0xB0) == 0x20) {
      uint64_t v11 = a2 + a3;
    }
    else {
      uint64_t v11 = a2;
    }
    if (!std::__pad_and_output[abi:nn180100]<char,std::char_traits<char>>(v7, a2, v11, a2 + a3, v6, (char)v9)) {
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
    }
  }
  MEMORY[0x199702250](v13);
  return a1;
}

void sub_1937DA5B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::locale a12)
{
}

uint64_t std::__pad_and_output[abi:nn180100]<char,std::char_traits<char>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6 = a1;
  if (a1)
  {
    uint64_t v11 = *(void *)(a5 + 24);
    if (v11 <= a4 - a2) {
      int64_t v12 = 0;
    }
    else {
      int64_t v12 = v11 - (a4 - a2);
    }
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1) != a3 - a2) {
      return 0;
    }
    if (v12 >= 1)
    {
      std::string::basic_string[abi:nn180100](__p, v12, __c);
      size_t v13 = v18 >= 0 ? __p : (void **)__p[0];
      uint64_t v14 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v6 + 96))(v6, v13, v12);
      if (v18 < 0) {
        operator delete(__p[0]);
      }
      if (v14 != v12) {
        return 0;
      }
    }
    uint64_t v15 = a4 - a3;
    if (v15 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 96))(v6, a3, v15) == v15) {
      *(void *)(a5 + 24) = 0;
    }
    else {
      return 0;
    }
  }
  return v6;
}

void sub_1937DA74C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *std::string::basic_string[abi:nn180100](void *__b, size_t __len, int __c)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *__b = v6;
  }
  else
  {
    *((unsigned char *)__b + 23) = __len;
    uint64_t v6 = __b;
    if (!__len) {
      goto LABEL_9;
    }
  }
  memset(v6, __c, __len);
LABEL_9:
  *((unsigned char *)v6 + __len) = 0;
  return __b;
}

void CIKLLibraryMaker::CIKLLibraryMaker(CIKLLibraryMaker *this, uint64_t a2)
{
  *(void *)this = 0;
  *((void *)this + 1) = objc_opt_new();
  uint64_t v4 = objc_opt_new();
  *((void *)this + 5) = 0;
  *((void *)this + 4) = (char *)this + 40;
  *((void *)this + 2) = v4;
  *((void *)this + 3) = a2;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  std::vector<short>::reserve((void **)this + 7, 0x10uLL);
  CIKLLibraryMaker::createMetalLibraryFromFoslPool(this, a2);
}

void sub_1937DA8A0(_Unwind_Exception *a1)
{
  uint64_t v6 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 64) = v6;
    operator delete(v6);
  }
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy(v2, *v4);
  _Unwind_Resume(a1);
}

void std::vector<short>::reserve(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 1)
  {
    if ((a2 & 0x8000000000000000) != 0) {
      abort();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    uint64_t v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<short>>(v3, a2);
    size_t v7 = &v6[v5 & 0xFFFFFFFFFFFFFFFELL];
    int v9 = &v6[2 * v8];
    uint64_t v10 = (char *)*a1;
    uint64_t v11 = (char *)a1[1];
    int64_t v12 = v7;
    if (v11 != *a1)
    {
      int64_t v12 = v7;
      do
      {
        __int16 v13 = *((_WORD *)v11 - 1);
        v11 -= 2;
        *((_WORD *)v12 - 1) = v13;
        v12 -= 2;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void CIKLLibraryMaker::createMetalLibraryFromFoslPool(CIKLLibraryMaker *this, uint64_t a2)
{
  int NumKernels = fosl_filter_kernelpool_getNumKernels(a2);
  if (NumKernels << 16 >= 0x10000)
  {
    __int16 v5 = NumKernels;
    if (CIKLLibraryMaker::createMetalLibraryFromFoslPool(void *)::onceToken != -1) {
      dispatch_once(&CIKLLibraryMaker::createMetalLibraryFromFoslPool(void *)::onceToken, &__block_literal_global_461);
    }
    if (CIKLLibraryMaker::createMetalLibraryFromFoslPool(void *)::_cikl2metal_preamble)
    {
      v12[0] = MEMORY[0x1E4F143A8];
      v12[1] = 3221225472;
      void v12[2] = ___ZN16CIKLLibraryMaker30createMetalLibraryFromFoslPoolEPv_block_invoke_2;
      v12[3] = &__block_descriptor_50_e89_v16__0____sFILE__iiss___sbuf__i_i_v___________sbuf__i_____sFILEX_i_3C__1C____sbuf__i_iq_8l;
      __int16 v13 = v5;
      v12[4] = this;
      v12[5] = a2;
      uint64_t v6 = (__CFString *)stream_to_string((uint64_t)v12);
      size_t v7 = v6;
      uint64_t v11 = 0;
      if (v6 && [(__CFString *)v6 length])
      {
        uint64_t v8 = +[CIKernelLibrary libraryWithSource:v7 error:&v11];
        *(void *)this = v8;
        if (v8)
        {
LABEL_14:

          return;
        }
      }
      else
      {
        int v9 = ci_logger_compile();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
          CIKLLibraryMaker::createMetalLibraryFromFoslPool();
        }
        if (*(void *)this) {
          goto LABEL_14;
        }
      }
      uint64_t v10 = ci_logger_compile();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        CIKLLibraryMaker::createMetalLibraryFromFoslPool();
      }
      goto LABEL_14;
    }
  }
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<short>>(uint64_t a1, uint64_t a2)
{
  if (a2 < 0) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(2 * a2);
}

void ___ZN16CIKLLibraryMaker30createMetalLibraryFromFoslPoolEPv_block_invoke()
{
  unint64_t size = 0;
  unint64_t v0 = getsectdatafromFramework("CoreImage", "__TEXT", "__cikl2metal_pre", &size);
  if (v0)
  {
    uint64_t v1 = v0;
    id v2 = [NSString alloc];
    CIKLLibraryMaker::createMetalLibraryFromFoslPool(void *)::_cikl2metal_preamble = [v2 initWithBytesNoCopy:v1 length:size encoding:1 freeWhenDone:0];
    if (CIKLLibraryMaker::createMetalLibraryFromFoslPool(void *)::_cikl2metal_preamble) {
      return;
    }
    goto LABEL_3;
  }
  NSLog(&cfstr_CouldNotInitia.isa);
  if (!CIKLLibraryMaker::createMetalLibraryFromFoslPool(void *)::_cikl2metal_preamble) {
LABEL_3:
  }
    NSLog(&cfstr_CanTCreateTheC.isa);
}

void ___ZN16CIKLLibraryMaker30createMetalLibraryFromFoslPoolEPv_block_invoke_2(uint64_t a1, __sFILE *a2)
{
  uint64_t v4 = *(CIKLLibraryMaker **)(a1 + 32);
  fputs((const char *)[(id)CIKLLibraryMaker::createMetalLibraryFromFoslPool(void *)::_cikl2metal_preamble UTF8String], a2);
  if (*(__int16 *)(a1 + 48) >= 1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = (FILE **)MEMORY[0x1E4F143C8];
    do
    {
      KernelByIddouble x = fosl_filter_kernelpool_getKernelByIdx(*(void *)(a1 + 40), v5);
      if (KernelByIdx)
      {
        uint64_t v8 = KernelByIdx;
        KernelCFStringRef Name = (const char *)fosl_filter_kernelpool_getKernelName(KernelByIdx);
        PrintedKernel = (char *)fosl_filter_kernelpool_getPrintedKernel(v8);
        CIKLLibraryMaker::analyzeCIKLSource(v4, a2, PrintedKernel, KernelName);
        if (KernelName) {
          BOOL v11 = PrintedKernel == 0;
        }
        else {
          BOOL v11 = 1;
        }
        if (v11)
        {
          NSLog(&cfstr_NoValidKernels_0.isa);
          int64_t v12 = ci_logger_compile();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
            ___ZN16CIKLLibraryMaker30createMetalLibraryFromFoslPoolEPv_block_invoke_2_cold_1(&buf, v14, v12);
          }
        }
        else if (FOSL_PRINT_KERNEL_AST())
        {
          fprintf(*v6, "Printed AST of kernel %s:\n%s\n", KernelName, PrintedKernel);
        }
      }
      uint64_t v5 = (v5 + 1);
    }
    while ((int)v5 < *(__int16 *)(a1 + 48));
  }
}

void CIKLLibraryMaker::analyzeCIKLSource(CIKLLibraryMaker *this, __sFILE *a2, char *a3, const char *a4)
{
  uint64_t v8 = (char *)this + 32;
  int v9 = (void *)((char *)this + 40);
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)this + 32, *((void **)this + 5));
  *((void *)this + 4) = v9;
  *int v9 = 0;
  uint64_t v10 = *((void *)this + 7);
  *((void *)this + 6) = 0;
  *((void *)this + 8) = v10;
  v24[0] = 0;
  v24[1] = v24;
  void v24[2] = 0x4812000000;
  v24[3] = __Block_byref_object_copy__11;
  v24[4] = __Block_byref_object_dispose__11;
  v24[5] = "";
  std::set<char const*>::set[abi:nn180100](v25, (uint64_t)v8);
  v22[0] = 0;
  v22[1] = v22;
  void v22[2] = 0x4812000000;
  v22[3] = __Block_byref_object_copy__477;
  v22[4] = __Block_byref_object_dispose__478;
  v22[5] = "";
  std::vector<short>::vector(v23, (uint64_t)this + 56);
  v20[0] = 0;
  v20[1] = v20;
  v20[2] = 0x2020000000;
  __int16 v21 = 0;
  v18[0] = 0;
  v18[1] = v18;
  void v18[2] = 0x2020000000;
  __int16 v19 = 0;
  v16[0] = 0;
  v16[1] = v16;
  v16[2] = 0x2020000000;
  __int16 v17 = -1;
  v14[0] = 0;
  v14[1] = v14;
  void v14[2] = 0x2020000000;
  char v15 = 0;
  v12[0] = 0;
  v12[1] = v12;
  void v12[2] = 0x2020000000;
  char v13 = 0;
  v11[0] = MEMORY[0x1E4F143A8];
  v11[1] = 3221225472;
  v11[2] = ___ZN16CIKLLibraryMaker17analyzeCIKLSourceEP7__sFILEPKcS3__block_invoke;
  v11[3] = &unk_1E5772440;
  v11[4] = v16;
  v11[5] = v20;
  v11[6] = v18;
  v11[7] = v14;
  v11[8] = v12;
  v11[9] = v24;
  v11[10] = v22;
  v11[11] = this;
  v11[12] = a4;
  v11[13] = a2;
  CIKLLibraryMaker::tokenizer((uint64_t)this, a3, (uint64_t)a2, (uint64_t)v11);
  _Block_object_dispose(v12, 8);
  _Block_object_dispose(v14, 8);
  _Block_object_dispose(v16, 8);
  _Block_object_dispose(v18, 8);
  _Block_object_dispose(v20, 8);
  _Block_object_dispose(v22, 8);
  if (v23[0])
  {
    v23[1] = v23[0];
    operator delete(v23[0]);
  }
  _Block_object_dispose(v24, 8);
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)v25, (void *)v25[1]);
}

void sub_1937DAF28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  _Block_object_dispose(&a23, 8);
  _Block_object_dispose(&a27, 8);
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose(&a35, 8);
  _Block_object_dispose(&a39, 8);
  _Block_object_dispose((const void *)(v40 - 240), 8);
  size_t v42 = *(void **)(v40 - 192);
  if (v42)
  {
    *(void *)(v40 - 184) = v42;
    operator delete(v42);
  }
  _Block_object_dispose((const void *)(v40 - 168), 8);
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy(v39, *(void **)(v40 - 112));
  _Unwind_Resume(a1);
}

void *__Block_byref_object_copy__11(void *result, void *a2)
{
  result[6] = a2[6];
  id v2 = a2 + 7;
  uint64_t v3 = a2[7];
  result[7] = v3;
  uint64_t v4 = result + 7;
  uint64_t v5 = a2[8];
  result[8] = v5;
  if (v5)
  {
    *(void *)(v3 + 16) = v4;
    a2[6] = v2;
    *id v2 = 0;
    a2[8] = 0;
  }
  else
  {
    result[6] = v4;
  }
  return result;
}

void __Block_byref_object_dispose__11(uint64_t a1)
{
}

__n128 __Block_byref_object_copy__477(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__478(uint64_t a1)
{
  id v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void CIKLLibraryMaker::tokenizer(uint64_t a1, unsigned char *a2, uint64_t a3, uint64_t a4)
{
  unsigned __int16 v7 = 0;
  uint64_t v8 = MEMORY[0x1E4F14390];
  while (1)
  {
    int v9 = *a2;
    if (v9 == 10)
    {
      (*(void (**)(uint64_t, unsigned char *, uint64_t, void, uint64_t))(a4 + 16))(a4, a2, 1, v7++, a3);
      goto LABEL_13;
    }
    if (!*a2) {
      break;
    }
    if ((char)v9 < 0)
    {
      if (__maskrune((char)v9, 0x4000uLL)) {
        goto LABEL_6;
      }
LABEL_16:
      unsigned int v13 = (char)*a2;
      if ((v13 & 0x80000000) != 0)
      {
        if (__maskrune(v13, 0x500uLL)) {
          goto LABEL_21;
        }
      }
      else if ((*(_DWORD *)(v8 + 4 * v13 + 60) & 0x500) != 0)
      {
        goto LABEL_21;
      }
      if (*a2 == 95)
      {
LABEL_21:
        for (uint64_t i = 1; ; ++i)
        {
          unsigned int v14 = (char)a2[i];
          if ((v14 & 0x80000000) != 0)
          {
            if (__maskrune(v14, 0x500uLL)) {
              continue;
            }
          }
          else if ((*(_DWORD *)(v8 + 4 * v14 + 60) & 0x500) != 0)
          {
            continue;
          }
          if (a2[i] != 95) {
            goto LABEL_11;
          }
        }
      }
      (*(void (**)(uint64_t, unsigned char *, uint64_t, void, uint64_t))(a4 + 16))(a4, a2, 1, v7, a3);
LABEL_13:
      LODWORD(i) = 1;
      goto LABEL_14;
    }
    if ((*(_DWORD *)(v8 + 4 * (char)v9 + 60) & 0x4000) == 0) {
      goto LABEL_16;
    }
LABEL_6:
    uint64_t i = 0;
    do
    {
      unsigned int v11 = (char)a2[i + 1];
      if ((v11 & 0x80000000) != 0) {
        int v12 = __maskrune(v11, 0x4000uLL);
      }
      else {
        int v12 = *(_DWORD *)(v8 + 4 * v11 + 60) & 0x4000;
      }
      ++i;
    }
    while (v12);
LABEL_11:
    (*(void (**)(uint64_t, unsigned char *, uint64_t, void, uint64_t))(a4 + 16))(a4, a2, i, v7, a3);
LABEL_14:
    a2 += i;
  }
}

void ___ZN16CIKLLibraryMaker17analyzeCIKLSourceEP7__sFILEPKcS3__block_invoke(uint64_t a1, char *__s1, int a3, int a4)
{
  int v70 = a3;
  uint64_t v4 = __s1;
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a1 + 88);
  uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
  int v8 = *(__int16 *)(v7 + 24);
  *(_WORD *)(v7 + 24) = a4;
  int v9 = *__s1;
  if (v9 == 40)
  {
    ++*(_WORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    int v9 = *__s1;
  }
  if (v9 == 41)
  {
    --*(_WORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    int v9 = *__s1;
  }
  if (v9 == 123)
  {
    ++*(_WORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
    int v9 = *__s1;
  }
  int v10 = v8 + 1;
  if (v9 == 125) {
    --*(_WORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
  }
  if (v10 == a4) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 0;
  }
  if (*(_WORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) || *__s1 == 125)
  {
    uint64_t v11 = *(void *)(*(void *)(a1 + 80) + 8);
    uint64_t v12 = *(void *)(v11 + 56);
    if (*(void *)(v11 + 48) != v12 && *__s1 == 41)
    {
      int v14 = *(unsigned __int16 *)(v12 - 2);
      uint64_t v13 = v12 - 2;
      if (*(unsigned __int16 *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) == v14)
      {
        int v15 = *(__s1 - 1);
        if (v15 == 40) {
          uint64_t v4 = "_dst)";
        }
        else {
          uint64_t v4 = ", _dst)";
        }
        if (v15 == 40) {
          int v16 = 5;
        }
        else {
          int v16 = 7;
        }
        int v70 = v16;
        *(void *)(v11 + 56) = v13;
      }
    }
    uint64_t v17 = *(void *)(*(void *)(a1 + 72) + 8);
    uint64_t v20 = *(void **)(v17 + 56);
    char v18 = (void *)(v17 + 56);
    __int16 v19 = v20;
    if (v20)
    {
      __int16 v21 = v18;
      do
      {
        unint64_t v22 = v19[4];
        BOOL v23 = v22 >= (unint64_t)v4;
        if (v22 >= (unint64_t)v4) {
          uint64_t v24 = v19;
        }
        else {
          uint64_t v24 = v19 + 1;
        }
        if (v23) {
          __int16 v21 = v19;
        }
        __int16 v19 = (void *)*v24;
      }
      while (*v24);
      if (v21 != v18 && (unint64_t)v4 >= v21[4])
      {
        unint64_t v25 = *(void **)(*(void *)(a1 + 80) + 8);
        uint64_t v26 = *(void *)(*(void *)(a1 + 40) + 8);
        uint64_t v27 = (char *)v25[7];
        unint64_t v28 = v25[8];
        if ((unint64_t)v27 >= v28)
        {
          uint64_t v40 = (char *)v25[6];
          uint64_t v41 = v27 - v40;
          if (v27 - v40 <= -3) {
            abort();
          }
          uint64_t v42 = v41 >> 1;
          unint64_t v43 = v28 - (void)v40;
          if (v43 <= (v41 >> 1) + 1) {
            unint64_t v44 = v42 + 1;
          }
          else {
            unint64_t v44 = v43;
          }
          if (v43 >= 0x7FFFFFFFFFFFFFFELL) {
            uint64_t v45 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v45 = v44;
          }
          if (v45)
          {
            unint64_t v46 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<short>>((uint64_t)(v25 + 8), v45);
            uint64_t v40 = (char *)v25[6];
            uint64_t v27 = (char *)v25[7];
          }
          else
          {
            unint64_t v46 = 0;
          }
          unint64_t v56 = &v46[2 * v42];
          long long v57 = &v46[2 * v45];
          *(_WORD *)unint64_t v56 = *(_WORD *)(v26 + 24);
          std::locale v29 = v56 + 2;
          while (v27 != v40)
          {
            __int16 v58 = *((_WORD *)v27 - 1);
            v27 -= 2;
            *((_WORD *)v56 - 1) = v58;
            v56 -= 2;
          }
          v25[6] = v56;
          v25[7] = v29;
          v25[8] = v57;
          if (v40) {
            operator delete(v40);
          }
        }
        else
        {
          *(_WORD *)uint64_t v27 = *(_WORD *)(v26 + 24);
          std::locale v29 = v27 + 2;
        }
        v25[7] = v29;
      }
    }
    if (v70 == 3)
    {
      BOOL v69 = 0;
      if (!strncmp(v4, "_dc", 3uLL))
      {
        uint64_t v4 = "_dst.coord()";
        int v59 = 12;
      }
      else
      {
        int v59 = 3;
      }
      goto LABEL_94;
    }
    BOOL v69 = 0;
    goto LABEL_123;
  }
  if (v10 != a4)
  {
LABEL_111:
    BOOL v69 = 0;
    goto LABEL_112;
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = 0;
  uint64_t v30 = MEMORY[0x1E4F14390];
  if (a3 == 5 && !strncmp("const ", __s1, 6uLL))
  {
    for (uint64_t i = 0; ; ++i)
    {
      unsigned int v61 = v4[i];
      if ((v61 & 0x80000000) != 0)
      {
        if (__maskrune(v61, 0x500uLL)) {
          continue;
        }
      }
      else if ((*(_DWORD *)(v30 + 4 * v61 + 60) & 0x500) != 0)
      {
        continue;
      }
      int v62 = v4[i];
      if ((v62 - 40) >= 8)
      {
        unsigned int v63 = v62 - 32;
        BOOL v64 = v63 > 0x3F;
        unint64_t v65 = (1 << v63) & 0x8000000020000001;
        if (v64 || v65 == 0)
        {
          uint64_t v67 = (void *)[[NSString alloc] initWithBytes:v4 length:i encoding:1];
          if ([*(id *)(v6 + 16) containsObject:v67])
          {
            *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 1;
            int v70 = 5;
          }
          else
          {
            [*(id *)(v6 + 16) addObject:v67];
            int v70 = 8;
            uint64_t v4 = "constant";
          }

          goto LABEL_111;
        }
      }
    }
  }
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  std::locale v33 = 0;
  char v34 = 0;
  while (1)
  {
    unsigned int v35 = v4[v31];
    if ((v35 & 0x80000000) != 0)
    {
      int v36 = __maskrune(v35, 0x500uLL);
      LOBYTE(v35) = v4[v31];
      if (v36) {
        goto LABEL_48;
      }
    }
    else if ((*(_DWORD *)(v30 + 4 * v35 + 60) & 0x500) != 0)
    {
      goto LABEL_48;
    }
    if (v35 - 32 > 0x3F
      || ((1 << (v35 - 32)) & 0x8000000000001301) == 0)
    {
      break;
    }
LABEL_48:
    if (v34) {
      long long v38 = &v4[v31];
    }
    else {
      long long v38 = 0;
    }
    BOOL v39 = v32 != 0;
    if (!v32) {
      uint64_t v32 = v38;
    }
    if (v35 == 40) {
      std::locale v33 = &v4[v31];
    }
    if (v35 == 32) {
      char v34 = 1;
    }
    else {
      v34 &= v39;
    }
    ++v31;
  }
  int v47 = (void *)[[NSString alloc] initWithBytes:v4 length:v31 encoding:1];
  uint64_t v48 = (void *)[[NSString alloc] initWithBytes:v32 length:v33 - v32 encoding:1];
  int v49 = strncmp(*(const char **)(a1 + 96), v32, v33 - v32);
  BOOL v69 = v49 == 0;
  if ([*(id *)(v6 + 8) containsObject:v47])
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = 1;
    if (!v49) {
      goto LABEL_82;
    }
  }
  else
  {
    [*(id *)(v6 + 8) addObject:v47];
    if (!v49) {
      goto LABEL_82;
    }
  }
  long long v74 = 0u;
  long long v75 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  uint64_t v50 = [&unk_1EE4AB8B8 countByEnumeratingWithState:&v72 objects:v76 count:16];
  if (v50)
  {
    uint32_t v51 = (char *)&v4[v31];
    uint64_t v52 = *(void *)v73;
    do
    {
      for (uint64_t j = 0; j != v50; ++j)
      {
        if (*(void *)v73 != v52) {
          objc_enumerationMutation(&unk_1EE4AB8B8);
        }
        unint64_t v54 = (const char *)objc_msgSend((id)objc_msgSend(NSString, "stringWithFormat:", @"%@%@("), *(void *)(*((void *)&v72 + 1) + 8 * j), v48, "UTF8String");
        uint64_t v71 = 0;
        for (k = v51; ; k = v71 + 1)
        {
          uint64_t v71 = strstr(k, v54);
          if (!v71) {
            break;
          }
          std::__tree<char const*>::__emplace_unique_key_args<char const*,char const* const&>((uint64_t **)(*(void *)(*(void *)(a1 + 72) + 8) + 48), (unint64_t *)&v71, (uint64_t *)&v71);
        }
      }
      uint64_t v50 = [&unk_1EE4AB8B8 countByEnumeratingWithState:&v72 objects:v76 count:16];
    }
    while (v50);
  }
LABEL_82:

LABEL_112:
  if (!*(_WORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)
    && *v4 == 41
    && !*(_WORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24)
    && v4[1] == 32
    && v4[2] == 123)
  {
    int v68 = *((unsigned __int8 *)v4 - 1);
    if (v68 == 40) {
      uint64_t v4 = "coreimage::destination _dst)";
    }
    else {
      uint64_t v4 = ", coreimage::destination _dst)";
    }
    if (v68 == 40) {
      int v59 = 28;
    }
    else {
      int v59 = 30;
    }
LABEL_94:
    int v70 = v59;
  }
LABEL_123:
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24)
    && !*(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24))
  {
    if (v69) {
      fwrite("[[stitchable]] ", 0xFuLL, 1uLL, *(FILE **)(a1 + 104));
    }
    fprintf(*(FILE **)(a1 + 104), "%.*s", v70, v4);
  }
}

uint64_t *std::set<char const*>::set[abi:nn180100](uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  std::set<char const*>::insert[abi:nn180100]<std::__tree_const_iterator<char const*,std::__tree_node<char const*,void *> *,long>>(a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_1937DB93C(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *std::set<char const*>::insert[abi:nn180100]<std::__tree_const_iterator<char const*,std::__tree_node<char const*,void *> *,long>>(uint64_t *result, void *a2, void *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    uint64_t v5 = (uint64_t **)result;
    uint64_t v6 = result + 1;
    do
    {
      __n128 result = std::__tree<char const*>::__emplace_hint_unique_key_args<char const*,char const* const&>(v5, v6, v4 + 4, v4 + 4);
      uint64_t v7 = (void *)v4[1];
      if (v7)
      {
        do
        {
          int v8 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          int v8 = (void *)v4[2];
          BOOL v9 = *v8 == (void)v4;
          uint64_t v4 = v8;
        }
        while (!v9);
      }
      uint64_t v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *std::__tree<char const*>::__emplace_hint_unique_key_args<char const*,char const* const&>(uint64_t **a1, void *a2, unint64_t *a3, uint64_t *a4)
{
  uint64_t v6 = (uint64_t **)std::__tree<char const*>::__find_equal<char const*>(a1, a2, &v11, &v10, a3);
  uint64_t v7 = *v6;
  if (!*v6)
  {
    int v8 = v6;
    uint64_t v7 = (uint64_t *)operator new(0x28uLL);
    v7[4] = *a4;
    std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__insert_node_at(a1, v11, v8, v7);
  }
  return v7;
}

void *std::__tree<char const*>::__find_equal<char const*>(void *a1, void *a2, void *a3, void *a4, unint64_t *a5)
{
  uint64_t v5 = a1 + 1;
  if (a1 + 1 == a2 || (unint64_t v6 = *a5, v7 = a2[4], *a5 < v7))
  {
    uint64_t v8 = *a2;
    if ((void *)*a1 == a2)
    {
      uint64_t v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      BOOL v9 = (void *)*a2;
      do
      {
        uint64_t v10 = v9;
        BOOL v9 = (void *)v9[1];
      }
      while (v9);
    }
    else
    {
      uint64_t v13 = a2;
      do
      {
        uint64_t v10 = (void *)v13[2];
        BOOL v14 = *v10 == (void)v13;
        uint64_t v13 = v10;
      }
      while (v14);
    }
    unint64_t v15 = *a5;
    if (v10[4] < *a5) {
      goto LABEL_17;
    }
    int v16 = (void *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          uint64_t v17 = v16;
          unint64_t v18 = v16[4];
          if (v15 >= v18) {
            break;
          }
          int v16 = (void *)*v17;
          uint64_t v5 = v17;
          if (!*v17) {
            goto LABEL_29;
          }
        }
        if (v18 >= v15) {
          break;
        }
        uint64_t v5 = v17 + 1;
        int v16 = (void *)v17[1];
      }
      while (v16);
    }
    else
    {
      uint64_t v17 = a1 + 1;
    }
LABEL_29:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = a2;
    return a4;
  }
  uint64_t v11 = a2[1];
  if (v11)
  {
    uint64_t v12 = (void *)a2[1];
    do
    {
      a4 = v12;
      uint64_t v12 = (void *)*v12;
    }
    while (v12);
  }
  else
  {
    __int16 v19 = a2;
    do
    {
      a4 = (void *)v19[2];
      BOOL v14 = *a4 == (void)v19;
      __int16 v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= a4[4])
  {
    uint64_t v20 = (void *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          __int16 v21 = v20;
          unint64_t v22 = v20[4];
          if (v6 >= v22) {
            break;
          }
          uint64_t v20 = (void *)*v21;
          uint64_t v5 = v21;
          if (!*v21) {
            goto LABEL_48;
          }
        }
        if (v22 >= v6) {
          break;
        }
        uint64_t v5 = v21 + 1;
        uint64_t v20 = (void *)v21[1];
      }
      while (v20);
    }
    else
    {
      __int16 v21 = a1 + 1;
    }
LABEL_48:
    *a3 = v21;
    return v5;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

void *std::vector<short>::vector(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *(const void **)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  int64_t v5 = v3 - *(void *)a2;
  if (v3 != *(void *)a2)
  {
    std::vector<short>::__vallocate[abi:nn180100](a1, v5 >> 1);
    unint64_t v6 = (char *)a1[1];
    memmove(v6, v4, v5);
    a1[1] = &v6[v5];
  }
  return a1;
}

char *std::vector<short>::__vallocate[abi:nn180100](void *a1, uint64_t a2)
{
  if (a2 < 0) {
    abort();
  }
  __n128 result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<short>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[2 * v4];
  return result;
}

void CIKLLibraryMaker::~CIKLLibraryMaker(id *this)
{
  id v2 = this[7];
  if (v2)
  {
    this[8] = v2;
    operator delete(v2);
  }
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)(this + 4), this[5]);
}

void sub_1937DBD04(_Unwind_Exception *a1)
{
  uint64_t v3 = *(void **)(v1 + 56);
  if (v3)
  {
    *(void *)(v1 + 64) = v3;
    operator delete(v3);
  }
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy(v1 + 32, *(void **)(v1 + 40));
  _Unwind_Resume(a1);
}

__n128 std::vector<CI::KernelArgumentType>::__move_assign(uint64_t a1, __n128 *a2)
{
  uint64_t v4 = *(void **)a1;
  if (v4)
  {
    *(void *)(a1 + 8) = v4;
    operator delete(v4);
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
  }
  __n128 result = *a2;
  *(__n128 *)a1 = *a2;
  *(void *)(a1 + 16) = a2[1].n128_u64[0];
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  return result;
}

void std::vector<std::string>::__vdeallocate(std::vector<std::string> *this)
{
  if (this->__begin_)
  {
    std::vector<std::string>::__clear[abi:nn180100]((uint64_t *)this);
    operator delete(this->__begin_);
    this->__begin_ = 0;
    this->__end_ = 0;
    this->__end_cap_.__value_ = 0;
  }
}

char *std::vector<CI::KernelArgumentType>::__assign_with_size[abi:nn180100]<CI::KernelArgumentType*,CI::KernelArgumentType*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  unint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  BOOL v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 2)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *unint64_t v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 62) {
      abort();
    }
    uint64_t v10 = v8 >> 1;
    if (v8 >> 1 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v11 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    __n128 result = std::vector<CI::KernelArgumentType>::__vallocate[abi:nn180100](v7, v11);
    uint64_t v13 = (char *)v7[1];
    uint64_t v12 = (void **)(v7 + 1);
    BOOL v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      unint64_t v18 = v9;
      __int16 v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  uint64_t v12 = (void **)(result + 8);
  BOOL v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 2;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  int v16 = &__src[4 * v15];
  if (v14 != v9)
  {
    __n128 result = (char *)memmove(*(void **)result, __src, v14 - v9);
    BOOL v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    unint64_t v18 = v9;
    __int16 v19 = v16;
LABEL_18:
    __n128 result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *uint64_t v12 = &v9[v17];
  return result;
}

void std::vector<std::string>::__assign_with_size[abi:nn180100]<std::string*,std::string*>(std::vector<std::string> *this, std::string *__str, long long *a3, unint64_t a4)
{
  int v8 = this + 16;
  std::vector<std::string>::pointer begin = this->__begin_;
  if (0xAAAAAAAAAAAAAAABLL * (((char *)this->__end_cap_.__value_ - (char *)this->__begin_) >> 3) < a4)
  {
    std::vector<std::string>::__vdeallocate(this);
    if (a4 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v10 = 0x5555555555555556 * (((char *)this->__end_cap_.__value_ - (char *)this->__begin_) >> 3);
    if (v10 <= a4) {
      unint64_t v10 = a4;
    }
    if (0xAAAAAAAAAAAAAAABLL * (((char *)this->__end_cap_.__value_ - (char *)this->__begin_) >> 3) >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v10;
    }
    std::vector<CI::SWRendererFunctionInputNode>::__vallocate[abi:nn180100](this, v11);
    uint64_t v12 = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string*,std::string*,std::string*>(v8, (long long *)__str, a3, this->__end_);
    goto LABEL_11;
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)this->__end_ - (char *)begin) >> 3) < a4)
  {
    uint64_t v13 = (std::string *)((char *)__str + 8 * (((char *)this->__end_ - (char *)begin) >> 3));
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::string *,std::string *,std::string *,0>(__str, v13, begin);
    uint64_t v12 = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string*,std::string*,std::string*>(v8, (long long *)v13, a3, this->__end_);
LABEL_11:
    this->__end_ = v12;
    return;
  }
  std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::string *,std::string *,std::string *,0>(__str, (std::string *)a3, begin);
  unint64_t v15 = v14;
  std::vector<std::string>::pointer end = this->__end_;
  if (end != v14)
  {
    do
    {
      if (SHIBYTE(end[-1].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(end[-1].__r_.__value_.__l.__data_);
      }
      --end;
    }
    while (end != v15);
  }
  this->__end_ = v15;
}

void sub_1937DC028(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1937DC030(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

std::string *std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::string *,std::string *,std::string *,0>(std::string *__str, std::string *a2, std::string *this)
{
  uint64_t v4 = __str;
  if (__str != a2)
  {
    do
      std::string::operator=(this++, v4++);
    while (v4 != a2);
    return a2;
  }
  return (std::string *)v4;
}

CI::MetalKernel *CI::PrecompiledGeneralKernel::PrecompiledGeneralKernel(CI::MetalKernel *a1, const char *a2, CIKernelLibrary *a3, char *a4, char *a5, char a6, void **a7, uint64_t a8, unsigned int a9, int a10, int a11, NSDictionary *a12, NSDictionary *a13, uint64_t *a14, char a15)
{
  __int16 v21 = CI::MetalKernel::MetalKernel(a1, a2, a3, a12, a13, a15, ((unint64_t)a4 | (unint64_t)a5) != 0);
  CI::GeneralKernel::GeneralKernel((uint64_t)v21 + 80, a2, a4, a5, a6, a7, a8, a9, a10, a11, a14, 0);
  *(void *)a1 = &unk_1EE45D600;
  *((void *)a1 + 10) = &unk_1EE45D648;
  return a1;
}

void sub_1937DC188(_Unwind_Exception *a1)
{
  CI::MetalKernel::~MetalKernel(v1);
  _Unwind_Resume(a1);
}

uint64_t ___ZL13CoreAnalyticsP8NSStringS0_i_block_invoke()
{
  return AnalyticsSendEventLazy();
}

uint64_t ___ZL13CoreAnalyticsP8NSStringS0_i_block_invoke_2(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  CFStringRef v2 = (const __CFString *)objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F28B50], "mainBundle"), "bundleIdentifier");
  uint64_t v3 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F28B50], "mainBundle"), "bundlePath"), "pathExtension");
  CFStringRef v4 = CoreAnayticsAppIndentifier(v2);
  int64_t v5 = (__CFString *)[MEMORY[0x1E4F22448] extensionPointRecordForCurrentProcess];
  if (v5) {
    int64_t v5 = (__CFString *)[(__CFString *)v5 identifier];
  }
  v10[0] = @"identifier";
  v10[1] = @"extension";
  unint64_t v6 = &stru_1EE465CC0;
  if (v2) {
    unint64_t v7 = (__CFString *)v2;
  }
  else {
    unint64_t v7 = &stru_1EE465CC0;
  }
  if (v3) {
    int v8 = (__CFString *)v3;
  }
  else {
    int v8 = &stru_1EE465CC0;
  }
  if (v5) {
    int v8 = v5;
  }
  v11[0] = v7;
  v11[1] = v8;
  if (v4) {
    unint64_t v6 = (__CFString *)v4;
  }
  v11[2] = v6;
  v10[2] = @"client";
  v10[3] = @"kernelType";
  long long v12 = *(_OWORD *)(a1 + 32);
  v10[4] = @"kernelMethod";
  int64x2_t v10[5] = @"kernelCount";
  uint64_t v13 = [NSNumber numberWithInt:*(unsigned int *)(a1 + 48)];
  return [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v11 forKeys:v10 count:6];
}

CI::Buffer *CI::Buffer::Buffer(CI::Buffer *this, CFTypeRef cf)
{
  *(void *)this = &unk_1EE45DF30;
  *((_DWORD *)this + 2) = 1;
  *((void *)this + 2) = &unk_1EE45B0C0;
  atomic_fetch_add(&dword_1EB466E78[55], 1u);
  *(void *)this = &unk_1EE45DC58;
  *((void *)this + 2) = &unk_1EE45DC90;
  if (cf) {
    CFTypeRef v3 = CFRetain(cf);
  }
  else {
    CFTypeRef v3 = 0;
  }
  *((void *)this + 3) = v3;
  return this;
}

void sub_1937DC434(_Unwind_Exception *a1)
{
  *CFStringRef v2 = v1;
  atomic_fetch_add((atomic_uint *volatile)(v3 + 228), 0xFFFFFFFF);
  _Unwind_Resume(a1);
}

uint64_t CI::InstanceCounted<(CI::Type)57>::type()
{
  return 57;
}

void *CI::InstanceCounted<(CI::Type)57>::~InstanceCounted(void *result)
{
  *__n128 result = &unk_1EE45B0C0;
  atomic_fetch_add(&dword_1EB466E78[55], 0xFFFFFFFF);
  return result;
}

void CI::InstanceCounted<(CI::Type)57>::~InstanceCounted(void *a1)
{
  *a1 = &unk_1EE45B0C0;
  atomic_fetch_add(&dword_1EB466E78[55], 0xFFFFFFFF);
  JUMPOUT(0x1997023B0);
}

double cikernel::_ci_colormatrix_canonical(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  float32x4_t v4 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v4.i32[3] = a1.i32[3];
  float32x4_t v5 = vmulq_f32(a2, v4);
  *(float32x2_t *)v5.f32 = vadd_f32(*(float32x2_t *)v5.f32, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v5, (int8x16_t)v5, 8uLL));
  int8x16_t v6 = (int8x16_t)vmulq_f32(a3, v4);
  *(float32x2_t *)v6.i8 = vadd_f32(*(float32x2_t *)v6.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL));
  *(float32x2_t *)v5.f32 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v5.f32, *(int32x2_t *)v6.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v5.f32, *(int32x2_t *)v6.i8));
  int8x16_t v7 = (int8x16_t)vmulq_f32(a4, v4);
  *(float32x2_t *)v7.i8 = vadd_f32(*(float32x2_t *)v7.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL));
  *(float32x2_t *)&v5.u32[2] = vadd_f32(*(float32x2_t *)v7.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v7.i8, 1));
  *(void *)&double result = vmulq_laneq_f32(v5, a1, 3).u64[0];
  return result;
}

void CI::f4_s_f4_f4_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  unint64_t v10 = *(double (**)(__n128, __n128, __n128, __n128))(a1 + 24);
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  int v13 = *(_DWORD *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  int v15 = *(_DWORD *)(v9 + 64);
  uint64_t v16 = *(void *)(v9 + 56);
  int v17 = *(_DWORD *)(v9 + 88);
  uint64_t v18 = *(void *)(v9 + 80);
  if (*(unsigned char *)(a1 + 64))
  {
    uint64_t v24 = *(double (**)(__n128, __n128, __n128, __n128))(a1 + 24);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 104)), a2);
    unint64_t v10 = v24;
  }
  __int16 v19 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5) {
    __int16 v19 = (__n128 *)((char *)a2 + 64 * v18);
  }
  uint64_t v20 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5) {
    uint64_t v20 = (__n128 *)((char *)a2 + 64 * v16);
  }
  __int16 v21 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    __int16 v21 = (__n128 *)((char *)a2 + 64 * v14);
  }
  unint64_t v22 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    unint64_t v22 = (__n128 *)((char *)a2 + 64 * v12);
  }
  *(double *)&long long v23 = v10(*v22, *v21, *v20, *v19);
  *(_OWORD *)(a3 + 16 * a7) = v23;
}

CI::MetalKernel *CI::PrecompiledColorKernel::PrecompiledColorKernel(CI::MetalKernel *a1, const char *a2, CIKernelLibrary *a3, char *a4, char *a5, char a6, void **a7, uint64_t a8, unsigned int a9, int a10, int a11, NSDictionary *a12, NSDictionary *a13, uint64_t *a14, char a15)
{
  __int16 v21 = CI::MetalKernel::MetalKernel(a1, a2, a3, a12, a13, a15, ((unint64_t)a4 | (unint64_t)a5) != 0);
  CI::ColorKernel::ColorKernel((uint64_t)v21 + 80, a2, a4, a5, a6, a7, a8, a9, a10, a11, a14, 0, 0);
  *(void *)a1 = &unk_1EE45D548;
  *((void *)a1 + 10) = &unk_1EE45D590;
  return a1;
}

void sub_1937DC714(_Unwind_Exception *a1)
{
  CI::MetalKernel::~MetalKernel(v1);
  _Unwind_Resume(a1);
}

CI::MetalKernel *CI::PrecompiledWarpKernel::PrecompiledWarpKernel(CI::MetalKernel *a1, const char *a2, CIKernelLibrary *a3, char *a4, char *a5, char a6, void **a7, uint64_t a8, unsigned int a9, int a10, NSDictionary *a11, NSDictionary *a12, char a13)
{
  uint64_t v20 = CI::MetalKernel::MetalKernel(a1, a2, a3, a11, a12, a13, ((unint64_t)a4 | (unint64_t)a5) != 0);
  CI::WarpKernel::WarpKernel((uint64_t)v20 + 80, a2, a4, a5, a6, a7, a8, a9, a10, 0);
  *(void *)a1 = &unk_1EE45D4A0;
  *((void *)a1 + 10) = &unk_1EE45D4E8;
  return a1;
}

void sub_1937DC80C(_Unwind_Exception *a1)
{
  CI::MetalKernel::~MetalKernel(v1);
  _Unwind_Resume(a1);
}

uint64_t CI::SerialValArray<int>::SerialValArray(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 8) = 0;
  *(void *)a1 = 0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  if (a2 > 10)
  {
    *(_DWORD *)(a1 + 4) = a2;
    float32x4_t v4 = malloc_type_calloc((a2 - 10), 4uLL, 0x100004052888210uLL);
  }
  else
  {
    float32x4_t v4 = 0;
    *(_DWORD *)(a1 + 4) = 10;
  }
  *(void *)(a1 + 16) = v4;
  if (a2 <= 1) {
    int v5 = 1;
  }
  else {
    int v5 = a2;
  }
  *(_DWORD *)(a1 + 8) = v5;
  return a1;
}

void OUTLINED_FUNCTION_9_1(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x22u);
}

uint64_t OUTLINED_FUNCTION_10_0@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)(a2 + 4) = a3;
  *(_WORD *)(a2 + 12) = 2114;
  *(void *)(a2 + 14) = result;
  return result;
}

void OUTLINED_FUNCTION_11_1(uint64_t a1@<X8>)
{
  *(void *)(v1 - 8) = a1;
}

double cikernel::_LabDeltaE(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v58 = a2;
  a2.f32[0] = 1.0 - a1.f32[3];
  float32x4_t v2 = vaddq_f32(a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.f32, 0));
  float32x4_t v3 = vmulq_f32(v2, (float32x4_t)xmmword_193953B20);
  float32x4_t v4 = vmulq_f32(v2, (float32x4_t)xmmword_193953B30);
  v3.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))).u32[0];
  float32x4_t v5 = vmulq_f32(v2, (float32x4_t)xmmword_193953B40);
  v3.i32[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).u32[0];
  v3.i64[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))).u32[0];
  float32x4_t v61 = (float32x4_t)vdupq_n_s32(0xBC1118C2);
  float32x4_t v6 = vmaxnmq_f32(v3, (float32x4_t)0);
  float32x4_t v56 = vaddq_f32(v6, v61);
  float32x4_t v60 = (float32x4_t)vdupq_n_s32(0x40F92F1Bu);
  float32x4_t v59 = (float32x4_t)vdupq_n_s32(0x3E0D3DCBu);
  int8x16_t v49 = (int8x16_t)vaddq_f32(vmulq_f32(v6, v60), v59);
  v6.i32[3] = 0;
  simd_float4 v7 = _simd_pow_f4((simd_float4)v6, (simd_float4)xmmword_193953B50);
  int8x16_t v8 = (int8x16_t)vcltzq_f32(v56);
  int8x16_t v9 = vbslq_s8(v8, v49, (int8x16_t)v7);
  *(double *)v8.i64 = *(float *)&v9.i32[1] * 116.0 + -16.0;
  *(float *)v8.i32 = *(double *)v8.i64;
  *(float32x2_t *)v9.i8 = vmul_f32(vsub_f32(*(float32x2_t *)v9.i8, (float32x2_t)vext_s8(*(int8x8_t *)v9.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v9, v9, 8uLL), 4uLL)), (float32x2_t)0x4348000043FA0000);
  float32x4_t v57 = (float32x4_t)vextq_s8(vextq_s8(v8, v8, 4uLL), v9, 0xCuLL);
  float32x4_t v10 = vmulq_f32(a1, (float32x4_t)xmmword_193953B20);
  float32x4_t v11 = vmulq_f32(a1, (float32x4_t)xmmword_193953B30);
  v10.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2), vaddq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1))).u32[0];
  v8.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).u32[0];
  float32x4_t v12 = vmulq_f32(a1, (float32x4_t)xmmword_193953B40);
  v10.i32[1] = v8.i32[0];
  v10.i64[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))).u32[0];
  float32x4_t v13 = vmaxnmq_f32(v10, (float32x4_t)0);
  int8x16_t v50 = (int8x16_t)vaddq_f32(vmulq_f32(v13, v60), v59);
  float32x4_t v54 = vaddq_f32(v13, v61);
  v13.i32[3] = 0;
  simd_float4 v14 = _simd_pow_f4((simd_float4)v13, (simd_float4)xmmword_193953B50);
  int8x16_t v15 = (int8x16_t)vcltzq_f32(v54);
  int8x16_t v16 = vbslq_s8(v15, v50, (int8x16_t)v14);
  *(double *)v15.i64 = *(float *)&v16.i32[1] * 116.0 + -16.0;
  *(float *)v15.i32 = *(double *)v15.i64;
  *(float32x2_t *)v16.i8 = vmul_f32(vsub_f32(*(float32x2_t *)v16.i8, (float32x2_t)vext_s8(*(int8x8_t *)v16.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v16, v16, 8uLL), 4uLL)), (float32x2_t)0x4348000043FA0000);
  int8x16_t v17 = vextq_s8(vextq_s8(v15, v15, 4uLL), v16, 0xCuLL);
  float32x4_t v55 = (float32x4_t)v17;
  *(float *)v17.i32 = 1.0 - v58.f32[3];
  float32x4_t v18 = vaddq_f32(v58, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.i8, 0));
  float32x4_t v19 = vmulq_f32(v18, (float32x4_t)xmmword_193953B20);
  float32x4_t v20 = vmulq_f32(v18, (float32x4_t)xmmword_193953B30);
  v19.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 2), vaddq_f32(v19, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v19.f32, 1))).u32[0];
  float32x4_t v21 = vmulq_f32(v18, (float32x4_t)xmmword_193953B40);
  v19.i32[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 2), vaddq_f32(v20, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 1))).u32[0];
  v19.i64[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 2), vaddq_f32(v21, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 1))).u32[0];
  float32x4_t v22 = vmaxnmq_f32(v19, (float32x4_t)0);
  int8x16_t v48 = (int8x16_t)vaddq_f32(vmulq_f32(v22, v60), v59);
  float32x4_t v51 = vaddq_f32(v22, v61);
  v22.i32[3] = 0;
  simd_float4 v23 = _simd_pow_f4((simd_float4)v22, (simd_float4)xmmword_193953B50);
  int8x16_t v24 = (int8x16_t)vcltzq_f32(v51);
  int8x16_t v25 = vbslq_s8(v24, v48, (int8x16_t)v23);
  *(double *)v24.i64 = *(float *)&v25.i32[1] * 116.0 + -16.0;
  *(float *)v24.i32 = *(double *)v24.i64;
  *(float32x2_t *)v25.i8 = vmul_f32(vsub_f32(*(float32x2_t *)v25.i8, (float32x2_t)vext_s8(*(int8x8_t *)v25.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v25, v25, 8uLL), 4uLL)), (float32x2_t)0x4348000043FA0000);
  float32x4_t v52 = (float32x4_t)vextq_s8(vextq_s8(v24, v24, 4uLL), v25, 0xCuLL);
  float32x4_t v26 = vmulq_f32(v58, (float32x4_t)xmmword_193953B20);
  float32x4_t v27 = vmulq_f32(v58, (float32x4_t)xmmword_193953B30);
  v26.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 2), vaddq_f32(v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.f32, 1))).u32[0];
  v24.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 2), vaddq_f32(v27, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 1))).u32[0];
  float32x4_t v28 = vmulq_f32(v58, (float32x4_t)xmmword_193953B40);
  v26.i32[1] = v24.i32[0];
  v26.i64[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v28, 2), vaddq_f32(v28, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 1))).u32[0];
  float32x4_t v29 = vmaxnmq_f32(v26, (float32x4_t)0);
  float32x4_t v63 = vaddq_f32(v29, v61);
  int8x16_t v62 = (int8x16_t)vaddq_f32(vmulq_f32(v29, v60), v59);
  v29.i32[3] = 0;
  simd_float4 v30 = _simd_pow_f4((simd_float4)v29, (simd_float4)xmmword_193953B50);
  _Q1 = (int8x16_t)vcltzq_f32(v63);
  int8x16_t v32 = vbslq_s8(_Q1, v62, (int8x16_t)v30);
  *(double *)_Q1.i64 = *(float *)&v32.i32[1] * 116.0 + -16.0;
  *(float *)_Q1.i32 = *(double *)_Q1.i64;
  *(float32x2_t *)v32.i8 = vmul_f32(vsub_f32(*(float32x2_t *)v32.i8, (float32x2_t)vext_s8(*(int8x8_t *)v32.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL), 4uLL)), (float32x2_t)0x4348000043FA0000);
  float32x4_t v33 = (float32x4_t)vextq_s8(vextq_s8(_Q1, _Q1, 4uLL), v32, 0xCuLL);
  _Q1.i64[0] = vsubq_f32(v57, v52).u64[0];
  _S2 = _Q1.i32[1];
  _Q3 = vmulq_f32(v57, v57);
  _Q3.f32[0] = sqrtf(COERCE_FLOAT(vaddq_f32(_Q3, (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)&_Q3, 2)).i32[1]));
  _Q4 = vmulq_f32(v52, v52);
  _Q4.f32[0] = sqrtf(COERCE_FLOAT(vaddq_f32(_Q4, (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)&_Q4, 2)).i32[1]));
  float v37 = sqrtf(_Q3.f32[0] * _Q4.f32[0]);
  _Q3.f32[0] = _Q3.f32[0] - _Q4.f32[0];
  __asm { FMLA            S4, S2, V1.S[1] }
  *(float *)_Q1.i32 = sqrtf((float)(fmaxf(_Q4.f32[0] - (float)(_Q3.f32[0] * _Q3.f32[0]), 0.0)/ (float)((float)((float)(v37 * 0.015) + 1.0) * (float)((float)(v37 * 0.015) + 1.0)))+ vmlas_n_f32((float)(_Q3.f32[0] / (float)((float)(v37 * 0.045) + 1.0))* (float)(_Q3.f32[0] / (float)((float)(v37 * 0.045) + 1.0)), *(float *)_Q1.i32, *(float *)_Q1.i32));
  _D2 = vsubq_f32(v55, v33).u64[0];
  _Q3.i32[0] = HIDWORD(_D2);
  _Q5 = vmulq_f32(v55, v55);
  _Q5.f32[0] = sqrtf(COERCE_FLOAT(vaddq_f32(_Q5, (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)&_Q5, 2)).i32[1]));
  float32x4_t v44 = vmulq_f32(v33, v33);
  float32x4_t v45 = vaddq_f32(v44, (float32x4_t)vdupq_laneq_s32((int32x4_t)v44, 2));
  v45.f32[0] = sqrtf(v45.f32[1]);
  float v46 = sqrtf(_Q5.f32[0] * v45.f32[0]);
  v45.f32[0] = _Q5.f32[0] - v45.f32[0];
  __asm { FMLA            S5, S3, V2.S[1] }
  v45.f32[0] = fmaxf(*(float *)_Q1.i32, sqrtf((float)(fmaxf(_Q5.f32[0] - (float)(v45.f32[0] * v45.f32[0]), 0.0)/ (float)((float)((float)(v46 * 0.015) + 1.0) * (float)((float)(v46 * 0.015) + 1.0)))+ vmlas_n_f32((float)(v45.f32[0] / (float)((float)(v46 * 0.045) + 1.0))* (float)(v45.f32[0] / (float)((float)(v46 * 0.045) + 1.0)), *(float *)&_D2, *(float *)&_D2)));
  *(void *)&double result = vdupq_lane_s32(*(int32x2_t *)v45.f32, 0).u64[0];
  return result;
}

__n64 cikernel::_LAB_normalize(int8x16_t a1)
{
  float32x2_t v1 = (float32x2_t)vext_s8(*(int8x8_t *)a1.i8, (int8x8_t)*(_OWORD *)&vextq_s8(a1, a1, 8uLL), 4uLL);
  result.n64_f32[0] = *(float *)a1.i32 / 100.0;
  result.n64_u32[1] = vadd_f32(vmul_f32(v1, (float32x2_t)0x3C0000003C000000), (float32x2_t)0x3F0000003F000000).u32[0];
  return result;
}

__n64 cikernel::_LAB_denormalize(int8x16_t a1)
{
  float32x2_t v1 = (float32x2_t)vext_s8(*(int8x8_t *)a1.i8, (int8x8_t)*(_OWORD *)&vextq_s8(a1, a1, 8uLL), 4uLL);
  result.n64_f32[0] = 100.0 * *(float *)a1.i32;
  result.n64_u32[1] = vmul_f32(vadd_f32(v1, (float32x2_t)0xBF000000BF000000), (float32x2_t)0x4300000043000000).u32[0];
  return result;
}

CIImage *downBy2H(CIImage *a1)
{
  v25[2] = *MEMORY[0x1E4F143B8];
  float32x4_t v2 = +[CIVector vectorWithX:2.0 Y:1.0 Z:1.0 W:0.0];
  [(CIImage *)a1 extent];
  double x = v26.origin.x;
  double y = v26.origin.y;
  double width = v26.size.width;
  double height = v26.size.height;
  if (CGRectIsInfinite(v26))
  {
    double v7 = 1.79769313e308;
    double v8 = -8.98846567e307;
    double v9 = 1.79769313e308;
    double v10 = -8.98846567e307;
  }
  else
  {
    v27.origin.double x = x;
    v27.origin.double y = y;
    v27.size.double width = width;
    v27.size.double height = height;
    BOOL IsNull = CGRectIsNull(v27);
    double v10 = INFINITY;
    if (IsNull) {
      double v8 = INFINITY;
    }
    else {
      double v8 = y;
    }
    if (IsNull) {
      double v7 = 0.0;
    }
    else {
      double v7 = width;
    }
    if (IsNull) {
      double v9 = 0.0;
    }
    else {
      double v9 = height;
    }
    if (!IsNull) {
      double v10 = x;
    }
  }
  double v12 = fabs(v8);
  if (fabs(v10) == INFINITY || v12 == INFINITY)
  {
    *(int64x2_t *)&v22.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
    v22.var2 = 0.0;
    v22.var3 = 0.0;
  }
  else if (v10 == -8.98846567e307 && v8 == -8.98846567e307 && v7 == 1.79769313e308 && v9 == 1.79769313e308)
  {
    *(int64x2_t *)&v22.var0 = vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    *(int64x2_t *)&v22.var2 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  }
  else
  {
    v22.var0 = v10 * 0.5;
    v22.unsigned int var1 = v8;
    v22.var2 = v7 * 0.5;
    v22.var3 = v9;
  }
  Rectangle::inset(&v22, -3.0, -0.0, (uint64_t)&v23);
  *(void *)&double v14 = *(_OWORD *)&Rectangle::integralize(&v23, 0.0001, (uint64_t)v24);
  double v15 = *(double *)v24;
  double v16 = *(double *)&v24[1];
  double v18 = *(double *)&v24[2];
  double v17 = *(double *)&v24[3];
  float32x4_t v19 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_lanczosDown2, v14);
  if (v15 == -8.98846567e307 && v16 == -8.98846567e307 && v18 == 1.79769313e308 && v17 == 1.79769313e308)
  {
    double v15 = *MEMORY[0x1E4F1DB10];
    double v16 = *(double *)(MEMORY[0x1E4F1DB10] + 8);
    double v18 = *(double *)(MEMORY[0x1E4F1DB10] + 16);
    double v17 = *(double *)(MEMORY[0x1E4F1DB10] + 24);
  }
  v21[0] = MEMORY[0x1E4F143A8];
  v21[1] = 3221225472;
  v21[2] = ___ZL8downBy2HP7CIImage_block_invoke;
  v21[3] = &__block_descriptor_40_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
  v21[4] = 0x4012C985F06F6944;
  v25[0] = a1;
  v25[1] = v2;
  return -[CIKernel applyWithExtent:roiCallback:arguments:](v19, "applyWithExtent:roiCallback:arguments:", v21, [MEMORY[0x1E4F1C978] arrayWithObjects:v25 count:2], v15, v16, v18, v17);
}

CIImage *downBy2V(CIImage *a1)
{
  v25[2] = *MEMORY[0x1E4F143B8];
  float32x4_t v2 = +[CIVector vectorWithX:1.0 Y:2.0 Z:0.0 W:1.0];
  [(CIImage *)a1 extent];
  double x = v26.origin.x;
  double y = v26.origin.y;
  double width = v26.size.width;
  double height = v26.size.height;
  if (CGRectIsInfinite(v26))
  {
    double v7 = 1.79769313e308;
    double v8 = -8.98846567e307;
    double v9 = 1.79769313e308;
    double v10 = -8.98846567e307;
  }
  else
  {
    v27.origin.double x = x;
    v27.origin.double y = y;
    v27.size.double width = width;
    v27.size.double height = height;
    BOOL IsNull = CGRectIsNull(v27);
    double v10 = INFINITY;
    if (IsNull) {
      double v8 = INFINITY;
    }
    else {
      double v8 = y;
    }
    if (IsNull) {
      double v7 = 0.0;
    }
    else {
      double v7 = width;
    }
    if (IsNull) {
      double v9 = 0.0;
    }
    else {
      double v9 = height;
    }
    if (!IsNull) {
      double v10 = x;
    }
  }
  double v12 = fabs(v8);
  if (fabs(v10) == INFINITY || v12 == INFINITY)
  {
    *(int64x2_t *)&v22.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
    v22.var2 = 0.0;
    v22.var3 = 0.0;
  }
  else if (v10 == -8.98846567e307 && v8 == -8.98846567e307 && v7 == 1.79769313e308 && v9 == 1.79769313e308)
  {
    *(int64x2_t *)&v22.var0 = vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    *(int64x2_t *)&v22.var2 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  }
  else
  {
    v22.var0 = v10;
    v22.unsigned int var1 = v8 * 0.5;
    v22.var2 = v7;
    v22.var3 = v9 * 0.5;
  }
  Rectangle::inset(&v22, -0.0, -3.0, (uint64_t)&v23);
  *(void *)&double v14 = *(_OWORD *)&Rectangle::integralize(&v23, 0.0001, (uint64_t)v24);
  double v15 = *(double *)v24;
  double v16 = *(double *)&v24[1];
  double v18 = *(double *)&v24[2];
  double v17 = *(double *)&v24[3];
  float32x4_t v19 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_lanczosDown2, v14);
  if (v15 == -8.98846567e307 && v16 == -8.98846567e307 && v18 == 1.79769313e308 && v17 == 1.79769313e308)
  {
    double v15 = *MEMORY[0x1E4F1DB10];
    double v16 = *(double *)(MEMORY[0x1E4F1DB10] + 8);
    double v18 = *(double *)(MEMORY[0x1E4F1DB10] + 16);
    double v17 = *(double *)(MEMORY[0x1E4F1DB10] + 24);
  }
  v21[0] = MEMORY[0x1E4F143A8];
  v21[1] = 3221225472;
  v21[2] = ___ZL8downBy2VP7CIImage_block_invoke;
  v21[3] = &__block_descriptor_40_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
  v21[4] = 0x4012C985F06F6944;
  v25[0] = a1;
  v25[1] = v2;
  return -[CIKernel applyWithExtent:roiCallback:arguments:](v19, "applyWithExtent:roiCallback:arguments:", v21, [MEMORY[0x1E4F1C978] arrayWithObjects:v25 count:2], v15, v16, v18, v17);
}

void ___ZL8downBy2HP7CIImage_block_invoke(uint64_t a1, double a2, double a3, double a4, double a5)
{
  float v5 = *(double *)(a1 + 32);
  roiDown2(*(CGRect *)&a2, v5, 1);
}

void roiDown2(CGRect a1, float a2, int a3)
{
  CGFloat height = a1.size.height;
  CGFloat width = a1.size.width;
  CGFloat y = a1.origin.y;
  CGFloat x = a1.origin.x;
  double v7 = 1.0;
  if (a3) {
    double v8 = 2.0;
  }
  else {
    double v8 = 1.0;
  }
  if (a3)
  {
    double v9 = (float)-a2;
  }
  else
  {
    double v7 = 2.0;
    double v9 = 0.0;
  }
  if (a3) {
    double v10 = 0.0;
  }
  else {
    double v10 = (float)-a2;
  }
  CGAffineTransformMakeScale(&v11, v8, v7);
  v12.origin.CGFloat x = x;
  v12.origin.CGFloat y = y;
  v12.size.CGFloat width = width;
  v12.size.CGFloat height = height;
  CGRect v13 = CGRectApplyAffineTransform(v12, &v11);
  CGRectInset(v13, v9, v10);
}

double cikernel::_lanczosDown2(uint64_t a1, float64x2_t a2)
{
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  float64x2_t v4 = a2;
  float32x2_t v5 = vmul_f32(*(float32x2_t *)&a2.f64[0], *DC);
  float32x2_t v6 = (float32x2_t)vextq_s8((int8x16_t)v4, (int8x16_t)v4, 8uLL).u64[0];
  float32x2_t v7 = vmul_f32(v6, (float32x2_t)vdup_n_s32(0x40964C30u));
  *(float32x2_t *)&v4.f64[0] = vsub_f32(v5, v7);
  *(float *)&double v8 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v4.f64[0], 1), *(float *)(a1 + 16), *(float *)v4.f64);
  LODWORD(v9) = *(_DWORD *)(a1 + 24);
  v10.i32[0] = *(_DWORD *)(a1 + 28);
  v11.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v12.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v4.f64[0], 1), *(float *)v10.i32, *(float *)v4.f64);
  float32x2_t v13 = vmul_f32(v6, (float32x2_t)vdup_n_s32(0x3F3B9D6Fu));
  *(int32x2_t *)&v4.f64[0] = vdup_n_s32(0x40359F2Cu);
  float32x2_t v14 = vmul_f32(v6, *(float32x2_t *)&v4.f64[0]);
  v6.f32[0] = *(float *)&v9 + *(float *)&v8;
  *(float *)v4.f64 = *(float *)v11.i32 + *(float *)v12.i32;
  v6.f32[1] = *(float *)v11.i32 + *(float *)v12.i32;
  *(double *)v15.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v6, v4, v9, v8, v10, v12, v11);
  float32x4_t v57 = v15;
  *(float32x2_t *)v15.f32 = vsub_f32(v5, v14);
  *(float *)&double v16 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v15.f32, 1), *(float *)(a1 + 16), v15.f32[0]);
  LODWORD(v17) = *(_DWORD *)(a1 + 28);
  v18.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v15.f32, 1), *(float *)&v17, v15.f32[0]);
  v15.f32[0] = *(float *)(a1 + 24) + *(float *)&v16;
  *(float *)v20.f64 = *(float *)v18.i32 + *(float *)v19.i32;
  v15.f32[1] = *(float *)v18.i32 + *(float *)v19.i32;
  *(double *)v22.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v15.i64, v20, v16, v17, v19, v18, v21);
  float32x4_t v55 = v22;
  *(float32x2_t *)v22.f32 = vsub_f32(v5, v13);
  *(float *)&double v23 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v22.f32, 1), *(float *)(a1 + 16), v22.f32[0]);
  LODWORD(v24) = *(_DWORD *)(a1 + 28);
  v25.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v22.f32, 1), *(float *)&v24, v22.f32[0]);
  v22.f32[0] = *(float *)(a1 + 24) + *(float *)&v23;
  *(float *)v27.f64 = *(float *)v25.i32 + *(float *)v26.i32;
  v22.f32[1] = *(float *)v25.i32 + *(float *)v26.i32;
  *(double *)v29.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v22.i64, v27, v23, v24, v26, v25, v28);
  float32x4_t v54 = v29;
  *(float32x2_t *)v29.f32 = vadd_f32(v13, v5);
  *(float *)&double v30 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v29.f32, 1), *(float *)(a1 + 16), v29.f32[0]);
  LODWORD(v31) = *(_DWORD *)(a1 + 28);
  v32.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v29.f32, 1), *(float *)&v31, v29.f32[0]);
  v29.f32[0] = *(float *)(a1 + 24) + *(float *)&v30;
  *(float *)v34.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v29.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)v36.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v29.i64, v34, v30, v31, v33, v32, v35);
  float32x4_t v53 = v36;
  *(float32x2_t *)v36.f32 = vadd_f32(v14, v5);
  *(float *)&double v37 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v36.f32, 1), *(float *)(a1 + 16), v36.f32[0]);
  LODWORD(v38) = *(_DWORD *)(a1 + 28);
  v39.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v40.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v36.f32, 1), *(float *)&v38, v36.f32[0]);
  v36.f32[0] = *(float *)(a1 + 24) + *(float *)&v37;
  *(float *)v41.f64 = *(float *)v39.i32 + *(float *)v40.i32;
  v36.f32[1] = *(float *)v39.i32 + *(float *)v40.i32;
  *(double *)v43.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v36.i64, v41, v37, v38, v40, v39, v42);
  float32x4_t v52 = v43;
  *(float32x2_t *)v43.f32 = vadd_f32(v7, v5);
  *(float *)&double v44 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v43.f32, 1), *(float *)(a1 + 16), v43.f32[0]);
  LODWORD(v45) = *(_DWORD *)(a1 + 28);
  v46.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v47.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v43.f32, 1), *(float *)&v45, v43.f32[0]);
  v43.f32[0] = *(float *)(a1 + 24) + *(float *)&v44;
  *(float *)v48.f64 = *(float *)v46.i32 + *(float *)v47.i32;
  v43.f32[1] = *(float *)v46.i32 + *(float *)v47.i32;
  *(double *)v50.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v43.i64, v48, v44, v45, v47, v46, v49);
  *(void *)&double result = vaddq_f32(vaddq_f32(vmulq_f32(vaddq_f32(v54, v53), (float32x4_t)vdupq_n_s32(0x3F14F6CFu)), vmulq_f32(vaddq_f32(v55, v52), (float32x4_t)vdupq_n_s32(0xBDCE1A3F))), vmulq_f32(vaddq_f32(v57, v50), (float32x4_t)vdupq_n_s32(0x3C998FBEu))).u64[0];
  return result;
}

float ___ZL8downBy2VP7CIImage_block_invoke(uint64_t a1, double a2, double a3, double a4, double a5)
{
  float v5 = *(double *)(a1 + 32);
  roiDown2(*(CGRect *)&a2, v5, 0);
  return result;
}

float ___ZL5downHP7CIImaged_block_invoke(uint64_t a1, double a2, double a3, double a4, double a5)
{
  float v5 = *(double *)(a1 + 32);
  float v6 = *(double *)(a1 + 40);
  roiDownK(*(CGRect *)&a2, v5, v6, 1);
  return result;
}

double cikernel::_lanczosDownH(uint64_t a1, int8x16_t a2)
{
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  _Q2 = a2;
  *(float32x2_t *)_Q3.i8 = vmul_f32(*(float32x2_t *)a2.i8, *DC);
  int8x16_t v188 = _Q3;
  v6.i64[0] = 0.5;
  *(float *)v6.i32 = floor(*(float *)_Q3.i32 + -0.5) + 0.5;
  int8x16_t v174 = v6;
  int8x16_t v7 = _Q3;
  v7.i32[0] = v6.i32[0];
  float64x2_t v8 = (float64x2_t)vextq_s8(_Q2, _Q2, 8uLL);
  __asm { FMOV            V2.2S, #5.0 }
  *(float32x2_t *)_Q2.i8 = vmul_f32(*(float32x2_t *)&v8.f64[0], *(float32x2_t *)_Q2.i8);
  *(float32x2_t *)v13.i8 = vsub_f32(*(float32x2_t *)v7.i8, *(float32x2_t *)_Q2.i8);
  __asm { FMOV            V3.2S, #4.0 }
  *(float32x2_t *)_Q3.i8 = vmul_f32(*(float32x2_t *)&v8.f64[0], *(float32x2_t *)_Q3.i8);
  *(float32x2_t *)_Q4.i8 = vsub_f32(*(float32x2_t *)v7.i8, *(float32x2_t *)_Q3.i8);
  int8x16_t v166 = _Q4;
  __asm { FMOV            V4.2S, #3.0 }
  *(float32x2_t *)_Q4.i8 = vmul_f32(*(float32x2_t *)&v8.f64[0], *(float32x2_t *)_Q4.i8);
  *(float32x2_t *)v15.i8 = vsub_f32(*(float32x2_t *)v7.i8, *(float32x2_t *)_Q4.i8);
  int8x16_t v168 = v15;
  *(float32x2_t *)v15.i8 = vadd_f32(*(float32x2_t *)&v8.f64[0], *(float32x2_t *)&v8.f64[0]);
  *(float32x2_t *)v16.i8 = vsub_f32(*(float32x2_t *)v7.i8, *(float32x2_t *)v15.i8);
  int8x16_t v170 = v16;
  *(float32x2_t *)v16.i8 = vsub_f32(*(float32x2_t *)v7.i8, *(float32x2_t *)&v8.f64[0]);
  int8x16_t v172 = v16;
  *(float32x2_t *)v16.i8 = vadd_f32(*(float32x2_t *)&v8.f64[0], *(float32x2_t *)v7.i8);
  *(float32x2_t *)v15.i8 = vadd_f32(*(float32x2_t *)v15.i8, *(float32x2_t *)v7.i8);
  int8x16_t v175 = v16;
  int8x16_t v177 = v15;
  *(float32x2_t *)_Q4.i8 = vadd_f32(*(float32x2_t *)_Q4.i8, *(float32x2_t *)v7.i8);
  *(float32x2_t *)_Q3.i8 = vadd_f32(*(float32x2_t *)_Q3.i8, *(float32x2_t *)v7.i8);
  int8x16_t v179 = _Q4;
  int8x16_t v180 = _Q3;
  *(float32x2_t *)_Q2.i8 = vadd_f32(*(float32x2_t *)_Q2.i8, *(float32x2_t *)v7.i8);
  int8x16_t v184 = _Q2;
  __asm { FMOV            V2.2S, #6.0 }
  *(float32x2_t *)&v8.f64[0] = vmul_f32(*(float32x2_t *)&v8.f64[0], *(float32x2_t *)_Q2.i8);
  *(float32x2_t *)v7.i8 = vadd_f32(*(float32x2_t *)&v8.f64[0], *(float32x2_t *)v7.i8);
  int8x16_t v187 = v7;
  float32x2_t v164 = *(float32x2_t *)v13.i8;
  _Q2.i32[0] = *(_DWORD *)(a1 + 28);
  *(float *)v7.i32 = *(float *)(a1 + 24)
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v13.i8, 1), *(float *)(a1 + 16), *(float *)v13.i32);
  _Q3.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v8.f64 = *(float *)_Q3.i32
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v13.i8, 1), *(float *)_Q2.i32, *(float *)v13.i32);
  v7.i32[1] = LODWORD(v8.f64[0]);
  *(double *)v17.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v7.i64, v8, *(double *)_Q2.i64, *(double *)_Q3.i64, _Q4, v15, v13);
  float32x4_t v162 = v17;
  LODWORD(v18) = *(_DWORD *)(a1 + 28);
  v17.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v166.i8, 1), *(float *)(a1 + 16), *(float *)v166.i32);
  LODWORD(v19) = *(_DWORD *)(a1 + 36);
  *(float *)v20.f64 = *(float *)&v19
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v166.i8, 1), *(float *)&v18, *(float *)v166.i32);
  v17.i32[1] = LODWORD(v20.f64[0]);
  *(double *)v23.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v17.i64, v20, v18, v19, v166, v21, v22);
  float32x4_t v161 = v23;
  LODWORD(v24) = *(_DWORD *)(a1 + 28);
  v23.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v168.i8, 1), *(float *)(a1 + 16), *(float *)v168.i32);
  LODWORD(v25) = *(_DWORD *)(a1 + 36);
  *(float *)v26.f64 = *(float *)&v25
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v168.i8, 1), *(float *)&v24, *(float *)v168.i32);
  v23.i32[1] = LODWORD(v26.f64[0]);
  *(double *)v29.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v23.i64, v26, v24, v25, v168, v27, v28);
  float32x4_t v160 = v29;
  LODWORD(v30) = *(_DWORD *)(a1 + 28);
  v29.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v170.i8, 1), *(float *)(a1 + 16), *(float *)v170.i32);
  LODWORD(v31) = *(_DWORD *)(a1 + 36);
  *(float *)v32.f64 = *(float *)&v31
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v170.i8, 1), *(float *)&v30, *(float *)v170.i32);
  v29.i32[1] = LODWORD(v32.f64[0]);
  *(double *)v35.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v29.i64, v32, v30, v31, v170, v33, v34);
  float32x4_t v159 = v35;
  LODWORD(v36) = *(_DWORD *)(a1 + 28);
  v35.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v172.i8, 1), *(float *)(a1 + 16), *(float *)v172.i32);
  LODWORD(v37) = *(_DWORD *)(a1 + 36);
  *(float *)v38.f64 = *(float *)&v37
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v172.i8, 1), *(float *)&v36, *(float *)v172.i32);
  v35.i32[1] = LODWORD(v38.f64[0]);
  *(double *)v41.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v35.i64, v38, v36, v37, v172, v39, v40);
  float32x4_t v158 = v41;
  LODWORD(v42) = *(_DWORD *)(a1 + 28);
  v41.f32[0] = *(float *)(a1 + 24)
             + (float)(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v188.i8, 1)
                     + (float)(*(float *)v174.i32 * *(float *)(a1 + 16)));
  LODWORD(v43) = *(_DWORD *)(a1 + 36);
  *(float *)v44.f64 = *(float *)&v43
                    + (float)(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v188.i8, 1)
                            + (float)(*(float *)v174.i32 * *(float *)&v42));
  v41.i32[1] = LODWORD(v44.f64[0]);
  *(double *)v46.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v41.i64, v44, v42, v43, v188, v174, v45);
  float32x4_t v157 = v46;
  LODWORD(v47) = *(_DWORD *)(a1 + 28);
  v46.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v175.i8, 1), *(float *)(a1 + 16), *(float *)v175.i32);
  LODWORD(v48) = *(_DWORD *)(a1 + 36);
  *(float *)v49.f64 = *(float *)&v48
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v175.i8, 1), *(float *)&v47, *(float *)v175.i32);
  v46.i32[1] = LODWORD(v49.f64[0]);
  *(double *)v52.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v46.i64, v49, v47, v48, v175, v50, v51);
  float32x4_t v156 = v52;
  LODWORD(v53) = *(_DWORD *)(a1 + 28);
  v52.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v177.i8, 1), *(float *)(a1 + 16), *(float *)v177.i32);
  LODWORD(v54) = *(_DWORD *)(a1 + 36);
  *(float *)v55.f64 = *(float *)&v54
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v177.i8, 1), *(float *)&v53, *(float *)v177.i32);
  v52.i32[1] = LODWORD(v55.f64[0]);
  *(double *)v58.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v52.i64, v55, v53, v54, v177, v56, v57);
  float32x4_t v155 = v58;
  LODWORD(v59) = *(_DWORD *)(a1 + 28);
  v58.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v179.i8, 1), *(float *)(a1 + 16), *(float *)v179.i32);
  LODWORD(v60) = *(_DWORD *)(a1 + 36);
  *(float *)v61.f64 = *(float *)&v60
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v179.i8, 1), *(float *)&v59, *(float *)v179.i32);
  v58.i32[1] = LODWORD(v61.f64[0]);
  *(double *)v64.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v58.i64, v61, v59, v60, v179, v62, v63);
  float32x4_t v154 = v64;
  LODWORD(v65) = *(_DWORD *)(a1 + 28);
  v64.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v180.i8, 1), *(float *)(a1 + 16), *(float *)v180.i32);
  LODWORD(v66) = *(_DWORD *)(a1 + 36);
  *(float *)v67.f64 = *(float *)&v66
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v180.i8, 1), *(float *)&v65, *(float *)v180.i32);
  v64.i32[1] = LODWORD(v67.f64[0]);
  *(double *)v70.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v64.i64, v67, v65, v66, v180, v68, v69);
  float32x4_t v153 = v70;
  LODWORD(v71) = *(_DWORD *)(a1 + 28);
  v70.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v184.i8, 1), *(float *)(a1 + 16), *(float *)v184.i32);
  LODWORD(v72) = *(_DWORD *)(a1 + 36);
  *(float *)v73.f64 = *(float *)&v72
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v184.i8, 1), *(float *)&v71, *(float *)v184.i32);
  v70.i32[1] = LODWORD(v73.f64[0]);
  *(double *)v76.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v70.i64, v73, v71, v72, v184, v74, v75);
  float32x4_t v152 = v76;
  LODWORD(v77) = *(_DWORD *)(a1 + 28);
  v76.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v187.i8, 1), *(float *)(a1 + 16), *(float *)v187.i32);
  LODWORD(v78) = *(_DWORD *)(a1 + 36);
  *(float *)v79.f64 = *(float *)&v78
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v187.i8, 1), *(float *)&v77, *(float *)v187.i32);
  v76.i32[1] = LODWORD(v79.f64[0]);
  *(double *)v82.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v76.i64, v79, v77, v78, v187, v80, v81);
  float32x2_t v84 = *(float32x2_t *)v188.i8;
  float v83 = *(float *)a2.i32;
  float32x4_t v151 = v82;
  float v85 = fabsf(vsub_f32(v164, *(float32x2_t *)v188.i8).f32[0] / *(float *)a2.i32);
  float v165 = 0.0;
  float v163 = 0.0;
  if (v85 < 3.0)
  {
    double v86 = v85;
    float v163 = 1.0;
    if (v86 >= 0.001)
    {
      float v87 = v86 * 3.14159265;
      double v88 = sinf(v87) * 3.0;
      long double v89 = sin(v87 / 3.0);
      float32x2_t v84 = *(float32x2_t *)v188.i8;
      float v83 = *(float *)a2.i32;
      *(float *)&long double v89 = v88 * v89 / (float)(v87 * v87);
      float v163 = *(float *)&v89;
    }
  }
  float v90 = fabsf(vsub_f32(*(float32x2_t *)v166.i8, v84).f32[0] / v83);
  if (v90 < 3.0)
  {
    double v91 = v90;
    float v165 = 1.0;
    if (v91 >= 0.001)
    {
      float v92 = v91 * 3.14159265;
      double v93 = sinf(v92) * 3.0;
      long double v94 = sin(v92 / 3.0);
      float32x2_t v84 = *(float32x2_t *)v188.i8;
      float v83 = *(float *)a2.i32;
      *(float *)&long double v94 = v93 * v94 / (float)(v92 * v92);
      float v165 = *(float *)&v94;
    }
  }
  float v95 = fabsf(vsub_f32(*(float32x2_t *)v168.i8, v84).f32[0] / v83);
  float v169 = 0.0;
  float v167 = 0.0;
  if (v95 < 3.0)
  {
    double v96 = v95;
    float v167 = 1.0;
    if (v96 >= 0.001)
    {
      float v97 = v96 * 3.14159265;
      double v98 = sinf(v97) * 3.0;
      long double v99 = sin(v97 / 3.0);
      float32x2_t v84 = *(float32x2_t *)v188.i8;
      float v83 = *(float *)a2.i32;
      *(float *)&long double v99 = v98 * v99 / (float)(v97 * v97);
      float v167 = *(float *)&v99;
    }
  }
  float v100 = fabsf(vsub_f32(*(float32x2_t *)v170.i8, v84).f32[0] / v83);
  if (v100 < 3.0)
  {
    double v101 = v100;
    float v169 = 1.0;
    if (v101 >= 0.001)
    {
      float v102 = v101 * 3.14159265;
      double v103 = sinf(v102) * 3.0;
      long double v104 = sin(v102 / 3.0);
      float32x2_t v84 = *(float32x2_t *)v188.i8;
      float v83 = *(float *)a2.i32;
      *(float *)&long double v104 = v103 * v104 / (float)(v102 * v102);
      float v169 = *(float *)&v104;
    }
  }
  float v105 = fabsf(vsub_f32(*(float32x2_t *)v172.i8, v84).f32[0] / v83);
  float v173 = 0.0;
  float v171 = 0.0;
  if (v105 < 3.0)
  {
    double v106 = v105;
    float v171 = 1.0;
    if (v106 >= 0.001)
    {
      float v107 = v106 * 3.14159265;
      double v108 = sinf(v107) * 3.0;
      long double v109 = sin(v107 / 3.0);
      float32x2_t v84 = *(float32x2_t *)v188.i8;
      float v83 = *(float *)a2.i32;
      *(float *)&long double v109 = v108 * v109 / (float)(v107 * v107);
      float v171 = *(float *)&v109;
    }
  }
  float v110 = fabsf((float)(*(float *)v174.i32 - v84.f32[0]) / v83);
  if (v110 < 3.0)
  {
    double v111 = v110;
    float v173 = 1.0;
    if (v111 >= 0.001)
    {
      float v112 = v111 * 3.14159265;
      double v113 = sinf(v112) * 3.0;
      long double v114 = sin(v112 / 3.0);
      float32x2_t v84 = *(float32x2_t *)v188.i8;
      float v83 = *(float *)a2.i32;
      *(float *)&long double v114 = v113 * v114 / (float)(v112 * v112);
      float v173 = *(float *)&v114;
    }
  }
  float v115 = fabsf(vsub_f32(*(float32x2_t *)v175.i8, v84).f32[0] / v83);
  float v116 = 0.0;
  float v117 = 0.0;
  if (v115 < 3.0)
  {
    double v118 = v115;
    float v117 = 1.0;
    if (v118 >= 0.001)
    {
      float v119 = v118 * 3.14159265;
      double v120 = sinf(v119) * 3.0;
      long double v121 = sin(v119 / 3.0);
      float v116 = 0.0;
      float32x2_t v84 = *(float32x2_t *)v188.i8;
      float v83 = *(float *)a2.i32;
      float v117 = v120 * v121 / (float)(v119 * v119);
    }
  }
  float v122 = fabsf(vsub_f32(*(float32x2_t *)v177.i8, v84).f32[0] / v83);
  float v178 = v117;
  if (v122 < 3.0)
  {
    double v123 = v122;
    float v116 = 1.0;
    if (v123 >= 0.001)
    {
      float v124 = v123 * 3.14159265;
      double v125 = sinf(v124) * 3.0;
      long double v126 = sin(v124 / 3.0);
      float v117 = v178;
      float32x2_t v84 = *(float32x2_t *)v188.i8;
      float v83 = *(float *)a2.i32;
      float v116 = v125 * v126 / (float)(v124 * v124);
    }
  }
  float v127 = fabsf(vsub_f32(*(float32x2_t *)v179.i8, v84).f32[0] / v83);
  float v128 = 0.0;
  float v129 = 0.0;
  float v176 = v116;
  if (v127 < 3.0)
  {
    double v130 = v127;
    float v129 = 1.0;
    if (v130 >= 0.001)
    {
      float v131 = v130 * 3.14159265;
      double v132 = sinf(v131) * 3.0;
      long double v133 = sin(v131 / 3.0);
      float v128 = 0.0;
      float v116 = v176;
      float v117 = v178;
      float32x2_t v84 = *(float32x2_t *)v188.i8;
      float v83 = *(float *)a2.i32;
      float v129 = v132 * v133 / (float)(v131 * v131);
    }
  }
  float v134 = fabsf(vsub_f32(*(float32x2_t *)v180.i8, v84).f32[0] / v83);
  if (v134 < 3.0)
  {
    double v135 = v134;
    float v128 = 1.0;
    if (v135 >= 0.001)
    {
      float v136 = v135 * 3.14159265;
      float v181 = v129;
      double v137 = sinf(v136) * 3.0;
      long double v138 = sin(v136 / 3.0);
      float v129 = v181;
      float v116 = v176;
      float v117 = v178;
      float32x2_t v84 = *(float32x2_t *)v188.i8;
      float v83 = *(float *)a2.i32;
      float v128 = v137 * v138 / (float)(v136 * v136);
    }
  }
  float v139 = fabsf(vsub_f32(*(float32x2_t *)v184.i8, v84).f32[0] / v83);
  float v140 = 0.0;
  float v141 = 0.0;
  if (v139 < 3.0)
  {
    double v142 = v139;
    float v141 = 1.0;
    if (v142 >= 0.001)
    {
      float v143 = v142 * 3.14159265;
      float v182 = v129;
      float v185 = v128;
      double v144 = sinf(v143) * 3.0;
      long double v145 = sin(v143 / 3.0);
      float v140 = 0.0;
      float v129 = v182;
      float v128 = v185;
      float v116 = v176;
      float v117 = v178;
      float32x2_t v84 = *(float32x2_t *)v188.i8;
      float v83 = *(float *)a2.i32;
      float v141 = v144 * v145 / (float)(v143 * v143);
    }
  }
  double v146 = COERCE_DOUBLE(vsub_f32(*(float32x2_t *)v187.i8, v84));
  *(float *)&double v146 = fabsf(*(float *)&v146 / v83);
  if (*(float *)&v146 < 3.0)
  {
    double v146 = *(float *)&v146;
    float v140 = 1.0;
    if (v146 >= 0.001)
    {
      float v147 = v146 * 3.14159265;
      float v183 = v129;
      float v186 = v128;
      float v190 = v141;
      double v148 = sinf(v147) * 3.0;
      long double v149 = sin(v147 / 3.0);
      float v141 = v190;
      float v129 = v183;
      float v128 = v186;
      float v116 = v176;
      float v117 = v178;
      double v146 = v148 * v149 / (float)(v147 * v147);
      float v140 = v146;
    }
  }
  *(float *)&double v146 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v163 + v165) + v167)
                                                                                  + v169)
                                                                          + v171)
                                                                  + v173)
                                                          + v117)
                                                  + v116)
                                          + v129)
                                  + v128)
                          + v141)
                  + v140;
  *(void *)&double result = vdivq_f32(vaddq_f32(vmulq_n_f32(v156, v117), vaddq_f32(vmulq_n_f32(v155, v116), vaddq_f32(vmulq_n_f32(v154, v129), vaddq_f32(vmulq_n_f32(v153, v128), vaddq_f32(vmulq_n_f32(v152, v141), vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vmulq_n_f32(v162, v163), vmulq_n_f32(v161, v165)), vmulq_n_f32(v160, v167)), vmulq_n_f32(v159, v169)), vmulq_n_f32(v158, v171)),
                                       vmulq_n_f32(v157, v173)),
                                     vmulq_n_f32(v151, v140))))))),
                         (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v146, 0)).u64[0];
  return result;
}

float ___ZL5downVP7CIImaged_block_invoke(uint64_t a1, double a2, double a3, double a4, double a5)
{
  float v5 = *(double *)(a1 + 32);
  float v6 = *(double *)(a1 + 40);
  roiDownK(*(CGRect *)&a2, v5, v6, 0);
  return result;
}

double cikernel::_lanczosDownV(uint64_t a1, int8x16_t a2)
{
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  _Q2 = a2;
  *(float32x2_t *)v5.i8 = vmul_f32(*(float32x2_t *)a2.i8, *DC);
  int8x16_t v160 = v5;
  float v6 = *(float *)&v5.i32[1];
  v7.i64[0] = 0.5;
  *(float *)v7.i32 = floor(*(float *)&v5.i32[1] + -0.5) + 0.5;
  int8x16_t v176 = v7;
  int8x16_t v8 = v5;
  v8.i32[1] = v7.i32[0];
  float64x2_t v9 = (float64x2_t)vextq_s8(_Q2, _Q2, 8uLL);
  __asm { FMOV            V2.2S, #5.0 }
  *(float32x2_t *)_Q2.i8 = vmul_f32(*(float32x2_t *)&v9.f64[0], *(float32x2_t *)_Q2.i8);
  *(float32x2_t *)v5.i8 = vsub_f32(*(float32x2_t *)v8.i8, *(float32x2_t *)_Q2.i8);
  __asm { FMOV            V4.2S, #4.0 }
  float32x2_t v15 = vmul_f32(*(float32x2_t *)&v9.f64[0], _D4);
  *(float32x2_t *)_Q5.i8 = vsub_f32(*(float32x2_t *)v8.i8, v15);
  int8x16_t v165 = _Q5;
  __asm { FMOV            V5.2S, #3.0 }
  *(float32x2_t *)_Q5.i8 = vmul_f32(*(float32x2_t *)&v9.f64[0], *(float32x2_t *)_Q5.i8);
  *(float32x2_t *)v17.i8 = vsub_f32(*(float32x2_t *)v8.i8, *(float32x2_t *)_Q5.i8);
  int8x16_t v169 = v17;
  *(float32x2_t *)v17.i8 = vadd_f32(*(float32x2_t *)&v9.f64[0], *(float32x2_t *)&v9.f64[0]);
  *(float32x2_t *)v18.i8 = vsub_f32(*(float32x2_t *)v8.i8, *(float32x2_t *)v17.i8);
  int8x16_t v171 = v18;
  *(float32x2_t *)v18.i8 = vsub_f32(*(float32x2_t *)v8.i8, *(float32x2_t *)&v9.f64[0]);
  int8x16_t v173 = v18;
  *(float32x2_t *)v18.i8 = vadd_f32(*(float32x2_t *)&v9.f64[0], *(float32x2_t *)v8.i8);
  int8x16_t v175 = v18;
  *(float32x2_t *)v17.i8 = vadd_f32(*(float32x2_t *)v17.i8, *(float32x2_t *)v8.i8);
  *(float32x2_t *)_Q5.i8 = vadd_f32(*(float32x2_t *)_Q5.i8, *(float32x2_t *)v8.i8);
  int8x16_t v178 = v17;
  int8x16_t v179 = _Q5;
  *(float32x2_t *)v19.i8 = vadd_f32(v15, *(float32x2_t *)v8.i8);
  *(float32x2_t *)_Q2.i8 = vadd_f32(*(float32x2_t *)_Q2.i8, *(float32x2_t *)v8.i8);
  int8x16_t v181 = v19;
  int8x16_t v183 = _Q2;
  __asm { FMOV            V2.2S, #6.0 }
  *(float32x2_t *)&v9.f64[0] = vmul_f32(*(float32x2_t *)&v9.f64[0], *(float32x2_t *)_Q2.i8);
  *(float32x2_t *)v8.i8 = vadd_f32(*(float32x2_t *)&v9.f64[0], *(float32x2_t *)v8.i8);
  int8x16_t v187 = v8;
  _Q2.i32[0] = *(_DWORD *)(a1 + 28);
  _Q5.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v5.i8, 1), *(float *)_Q2.i32, *(float *)v5.i32);
  float v20 = *(float *)&v5.i32[1];
  *(float *)v8.i32 = *(float *)(a1 + 24)
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v5.i8, 1), *(float *)(a1 + 16), *(float *)v5.i32);
  *(float *)v9.f64 = *(float *)_Q5.i32 + *(float *)v19.i32;
  *(float *)&v8.i32[1] = *(float *)_Q5.i32 + *(float *)v19.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v8.i64, v9, *(double *)_Q2.i64, *(double *)v5.i64, v19, _Q5, v17);
  float32x4_t v167 = v21;
  LODWORD(v22) = *(_DWORD *)(a1 + 28);
  v23.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)&double v24 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v165.i8, 1), *(float *)&v22, *(float *)v165.i32);
  float v25 = *(float *)&v165.i32[1];
  v21.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v165.i8, 1), *(float *)(a1 + 16), *(float *)v165.i32);
  *(float *)v26.f64 = *(float *)v23.i32 + *(float *)&v24;
  v21.f32[1] = *(float *)v23.i32 + *(float *)&v24;
  *(double *)v28.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v21.i64, v26, v22, v24, v23, v165, v27);
  float32x4_t v166 = v28;
  LODWORD(v29) = *(_DWORD *)(a1 + 28);
  v28.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v169.i8, 1), *(float *)(a1 + 16), *(float *)v169.i32);
  LODWORD(v30) = *(_DWORD *)(a1 + 36);
  *(float *)v31.f64 = *(float *)&v30
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v169.i8, 1), *(float *)&v29, *(float *)v169.i32);
  v28.i32[1] = LODWORD(v31.f64[0]);
  *(double *)v34.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v28.i64, v31, v29, v30, v169, v32, v33);
  float32x4_t v164 = v34;
  LODWORD(v35) = *(_DWORD *)(a1 + 28);
  v34.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v171.i8, 1), *(float *)(a1 + 16), *(float *)v171.i32);
  LODWORD(v36) = *(_DWORD *)(a1 + 36);
  *(float *)v37.f64 = *(float *)&v36
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v171.i8, 1), *(float *)&v35, *(float *)v171.i32);
  v34.i32[1] = LODWORD(v37.f64[0]);
  *(double *)v40.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v34.i64, v37, v35, v36, v171, v38, v39);
  float32x4_t v163 = v40;
  LODWORD(v41) = *(_DWORD *)(a1 + 28);
  v40.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v173.i8, 1), *(float *)(a1 + 16), *(float *)v173.i32);
  LODWORD(v42) = *(_DWORD *)(a1 + 36);
  *(float *)v43.f64 = *(float *)&v42
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v173.i8, 1), *(float *)&v41, *(float *)v173.i32);
  v40.i32[1] = LODWORD(v43.f64[0]);
  *(double *)v46.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v40.i64, v43, v41, v42, v173, v44, v45);
  float32x4_t v162 = v46;
  LODWORD(v47) = *(_DWORD *)(a1 + 28);
  v48.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)&double v49 = vmlas_n_f32(*(float *)(a1 + 32) * *(float *)v176.i32, *(float *)&v47, *(float *)v160.i32);
  v46.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(*(float *)(a1 + 20) * *(float *)v176.i32, *(float *)(a1 + 16), *(float *)v160.i32);
  *(float *)v50.f64 = *(float *)v48.i32 + *(float *)&v49;
  v46.f32[1] = *(float *)v48.i32 + *(float *)&v49;
  *(double *)v51.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v46.i64, v50, v47, v49, v48, v176, v160);
  float32x4_t v161 = v51;
  LODWORD(v52) = *(_DWORD *)(a1 + 28);
  v51.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v175.i8, 1), *(float *)(a1 + 16), *(float *)v175.i32);
  LODWORD(v53) = *(_DWORD *)(a1 + 36);
  *(float *)v54.f64 = *(float *)&v53
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v175.i8, 1), *(float *)&v52, *(float *)v175.i32);
  v51.i32[1] = LODWORD(v54.f64[0]);
  *(double *)v57.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v51.i64, v54, v52, v53, v175, v55, v56);
  float32x4_t v159 = v57;
  LODWORD(v58) = *(_DWORD *)(a1 + 28);
  v57.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v178.i8, 1), *(float *)(a1 + 16), *(float *)v178.i32);
  LODWORD(v59) = *(_DWORD *)(a1 + 36);
  *(float *)v60.f64 = *(float *)&v59
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v178.i8, 1), *(float *)&v58, *(float *)v178.i32);
  v57.i32[1] = LODWORD(v60.f64[0]);
  *(double *)v63.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v57.i64, v60, v58, v59, v178, v61, v62);
  float32x4_t v158 = v63;
  LODWORD(v64) = *(_DWORD *)(a1 + 28);
  v63.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v179.i8, 1), *(float *)(a1 + 16), *(float *)v179.i32);
  LODWORD(v65) = *(_DWORD *)(a1 + 36);
  *(float *)v66.f64 = *(float *)&v65
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v179.i8, 1), *(float *)&v64, *(float *)v179.i32);
  v63.i32[1] = LODWORD(v66.f64[0]);
  *(double *)v69.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v63.i64, v66, v64, v65, v179, v67, v68);
  float32x4_t v157 = v69;
  LODWORD(v70) = *(_DWORD *)(a1 + 28);
  v69.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v181.i8, 1), *(float *)(a1 + 16), *(float *)v181.i32);
  LODWORD(v71) = *(_DWORD *)(a1 + 36);
  *(float *)v72.f64 = *(float *)&v71
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v181.i8, 1), *(float *)&v70, *(float *)v181.i32);
  v69.i32[1] = LODWORD(v72.f64[0]);
  *(double *)v75.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v69.i64, v72, v70, v71, v181, v73, v74);
  float32x4_t v156 = v75;
  LODWORD(v76) = *(_DWORD *)(a1 + 28);
  v75.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v183.i8, 1), *(float *)(a1 + 16), *(float *)v183.i32);
  LODWORD(v77) = *(_DWORD *)(a1 + 36);
  *(float *)v78.f64 = *(float *)&v77
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v183.i8, 1), *(float *)&v76, *(float *)v183.i32);
  v75.i32[1] = LODWORD(v78.f64[0]);
  *(double *)v81.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v75.i64, v78, v76, v77, v183, v79, v80);
  float32x4_t v155 = v81;
  LODWORD(v82) = *(_DWORD *)(a1 + 28);
  v81.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v187.i8, 1), *(float *)(a1 + 16), *(float *)v187.i32);
  LODWORD(v83) = *(_DWORD *)(a1 + 36);
  *(float *)v84.f64 = *(float *)&v83
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v187.i8, 1), *(float *)&v82, *(float *)v187.i32);
  v81.i32[1] = LODWORD(v84.f64[0]);
  *(double *)v87.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v81.i64, v84, v82, v83, v187, v85, v86);
  float32x4_t v154 = v87;
  float v88 = fabsf((float)(v20 - v6) / *(float *)&a2.i32[1]);
  a2.i32[0] = 0;
  float v89 = 0.0;
  if (v88 < 3.0)
  {
    double v90 = v88;
    float v89 = 1.0;
    if (v90 >= 0.001)
    {
      float v91 = v90 * 3.14159265;
      double v92 = sinf(v91) * 3.0;
      float v89 = v92 * sin(v91 / 3.0) / (float)(v91 * v91);
    }
  }
  float v153 = v89;
  float v93 = fabsf((float)(v25 - v6) / *(float *)&a2.i32[1]);
  if (v93 < 3.0)
  {
    double v94 = v93;
    a2.i32[0] = 1.0;
    if (v94 >= 0.001)
    {
      float v95 = v94 * 3.14159265;
      double v96 = sinf(v95) * 3.0;
      float v97 = v96 * sin(v95 / 3.0) / (float)(v95 * v95);
      *(float *)a2.i32 = v97;
    }
  }
  float v98 = fabsf((float)(*(float *)&v169.i32[1] - v6) / *(float *)&a2.i32[1]);
  float v172 = 0.0;
  float v99 = 0.0;
  if (v98 < 3.0)
  {
    double v100 = v98;
    float v99 = 1.0;
    if (v100 >= 0.001)
    {
      float v101 = v100 * 3.14159265;
      double v102 = sinf(v101) * 3.0;
      float v99 = v102 * sin(v101 / 3.0) / (float)(v101 * v101);
    }
  }
  float v170 = v99;
  float v103 = fabsf((float)(*(float *)&v171.i32[1] - v6) / *(float *)&a2.i32[1]);
  if (v103 < 3.0)
  {
    double v104 = v103;
    float v172 = 1.0;
    if (v104 >= 0.001)
    {
      float v105 = v104 * 3.14159265;
      double v106 = sinf(v105) * 3.0;
      float v107 = v106 * sin(v105 / 3.0) / (float)(v105 * v105);
      float v172 = v107;
    }
  }
  float v108 = fabsf((float)(*(float *)&v173.i32[1] - v6) / *(float *)&a2.i32[1]);
  float v109 = 0.0;
  float v110 = 0.0;
  if (v108 < 3.0)
  {
    double v111 = v108;
    float v110 = 1.0;
    if (v111 >= 0.001)
    {
      float v112 = v111 * 3.14159265;
      double v113 = sinf(v112) * 3.0;
      long double v114 = sin(v112 / 3.0);
      float v109 = 0.0;
      float v110 = v113 * v114 / (float)(v112 * v112);
    }
  }
  float v174 = v110;
  float v115 = fabsf((float)(*(float *)v176.i32 - v6) / *(float *)&a2.i32[1]);
  if (v115 < 3.0)
  {
    double v116 = v115;
    float v109 = 1.0;
    if (v116 >= 0.001)
    {
      float v117 = v116 * 3.14159265;
      double v118 = sinf(v117) * 3.0;
      float v109 = v118 * sin(v117 / 3.0) / (float)(v117 * v117);
    }
  }
  float v177 = v109;
  float v119 = fabsf((float)(*(float *)&v175.i32[1] - v6) / *(float *)&a2.i32[1]);
  float v120 = 0.0;
  float v121 = 0.0;
  if (v119 < 3.0)
  {
    double v122 = v119;
    float v121 = 1.0;
    if (v122 >= 0.001)
    {
      float v123 = v122 * 3.14159265;
      double v124 = sinf(v123) * 3.0;
      long double v125 = sin(v123 / 3.0);
      float v120 = 0.0;
      float v121 = v124 * v125 / (float)(v123 * v123);
    }
  }
  *(float *)v178.i32 = v121;
  float v126 = fabsf((float)(*(float *)&v178.i32[1] - v6) / *(float *)&a2.i32[1]);
  if (v126 < 3.0)
  {
    double v127 = v126;
    float v120 = 1.0;
    if (v127 >= 0.001)
    {
      float v128 = v127 * 3.14159265;
      double v129 = sinf(v128) * 3.0;
      float v120 = v129 * sin(v128 / 3.0) / (float)(v128 * v128);
    }
  }
  float v130 = fabsf((float)(*(float *)&v179.i32[1] - v6) / *(float *)&a2.i32[1]);
  float v131 = 0.0;
  float v132 = 0.0;
  float v180 = v120;
  if (v130 < 3.0)
  {
    double v133 = v130;
    float v132 = 1.0;
    if (v133 >= 0.001)
    {
      float v134 = v133 * 3.14159265;
      double v135 = sinf(v134) * 3.0;
      long double v136 = sin(v134 / 3.0);
      float v131 = 0.0;
      float v120 = v180;
      float v132 = v135 * v136 / (float)(v134 * v134);
    }
  }
  float v137 = fabsf((float)(*(float *)&v181.i32[1] - v6) / *(float *)&a2.i32[1]);
  if (v137 < 3.0)
  {
    double v138 = v137;
    float v131 = 1.0;
    if (v138 >= 0.001)
    {
      float v139 = v138 * 3.14159265;
      float v184 = v132;
      double v140 = sinf(v139) * 3.0;
      long double v141 = sin(v139 / 3.0);
      float v132 = v184;
      float v120 = v180;
      float v131 = v140 * v141 / (float)(v139 * v139);
    }
  }
  HIDWORD(v142) = v187.i32[1];
  *(float *)&double v142 = fabsf((float)(*(float *)&v183.i32[1] - v6) / *(float *)&a2.i32[1]);
  float v143 = 0.0;
  float v144 = 0.0;
  if (*(float *)&v142 < 3.0)
  {
    double v142 = *(float *)&v142;
    float v144 = 1.0;
    if (v142 >= 0.001)
    {
      float v145 = v142 * 3.14159265;
      float v185 = v132;
      float v188 = v131;
      double v146 = sinf(v145) * 3.0;
      long double v147 = sin(v145 / 3.0);
      float v143 = 0.0;
      float v132 = v185;
      float v131 = v188;
      float v120 = v180;
      double v142 = v146 * v147 / (float)(v145 * v145);
      float v144 = v142;
    }
  }
  float v148 = fabsf((float)(*(float *)&v187.i32[1] - v6) / *(float *)&a2.i32[1]);
  if (v148 < 3.0)
  {
    double v142 = v148;
    float v143 = 1.0;
    if (v142 >= 0.001)
    {
      float v149 = v142 * 3.14159265;
      float v186 = v132;
      float v189 = v131;
      float v182 = v144;
      double v150 = sinf(v149) * 3.0;
      long double v151 = sin(v149 / 3.0);
      float v144 = v182;
      float v132 = v186;
      float v131 = v189;
      float v120 = v180;
      double v142 = v150 * v151 / (float)(v149 * v149);
      float v143 = v142;
    }
  }
  *(float *)&double v142 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v153
                                                                                                  + *(float *)a2.i32)
                                                                                          + v170)
                                                                                  + v172)
                                                                          + v174)
                                                                  + v177)
                                                          + *(float *)v178.i32)
                                                  + v120)
                                          + v132)
                                  + v131)
                          + v144)
                  + v143;
  *(void *)&double result = vdivq_f32(vaddq_f32(vmulq_n_f32(v159, *(float *)v178.i32), vaddq_f32(vmulq_n_f32(v158, v120), vaddq_f32(vmulq_n_f32(v157, v132), vaddq_f32(vmulq_n_f32(v156, v131), vaddq_f32(vmulq_n_f32(v155, v144), vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vmulq_n_f32(v167, v153), vmulq_n_f32(v166, *(float *)a2.i32)), vmulq_n_f32(v164, v170)), vmulq_n_f32(v163, v172)), vmulq_n_f32(v162, v174)),
                                       vmulq_n_f32(v161, v177)),
                                     vmulq_n_f32(v154, v143))))))),
                         (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v142, 0)).u64[0];
  return result;
}

double cikernel::_lanczosUpH(cikernel *this, SamplerObj *a2, float a3)
{
  v5.f64[0] = *(float64_t *)CI::getDC(this);
  float v6 = (float)(a3 * *(float *)v5.f64) + -0.5;
  LODWORD(v5.f64[0]) = floorf(v6);
  float32x2_t v7 = *(float32x2_t *)&v5.f64[0];
  float64x2_t v48 = v5;
  float v8 = (float)(*(float *)v5.f64 - v6) + 1.0;
  v5.f64[0] = (float)(v8 * v8);
  v9.i32[1] = 1072237884;
  v10.i64[0] = 0xBFDA4BAB03FA3591;
  float v11 = v5.f64[0] * (v8 * (v8 * (v8 * -0.41086841 + 0.78286595) + 1.04059357) + -2.41189213) + 1.0;
  float v46 = v11;
  *(double *)v12.i64 = v8 * (v8 * -0.29216512 + 1.02524562) + -0.5242291;
  double v13 = v8 * *(double *)v12.i64 + -0.2088514;
  *(float *)&double v13 = v13 * v5.f64[0];
  float v14 = 1.0 - v8;
  double v15 = (float)(v14 * v14);
  double v16 = v14;
  v5.f64[0] = v16 * (v16 * -0.41086841 + 0.78286595) + 1.04059357;
  *(float *)&double v15 = v15 * (v16 * v5.f64[0] + -2.41189213) + 1.0;
  float v44 = *(float *)&v15;
  float v45 = *(float *)&v13;
  *(float *)&double v16 = 1.0 - *(float *)&v13 - *(float *)&v15 - v11;
  float v47 = *(float *)&v16;
  *(float32x2_t *)&v17.f64[0] = vadd_f32(v7, (float32x2_t)3204448256);
  LODWORD(v13) = *((_DWORD *)this + 7);
  *(float *)&double v16 = *((float *)this + 6)
                 + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)&v17.f64[0], 1), *((float *)this + 4), *(float *)v17.f64);
  v9.i32[0] = *((_DWORD *)this + 9);
  *(float *)v5.f64 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)&v17.f64[0], 1), *(float *)&v13, *(float *)v17.f64);
  *(float *)v17.f64 = *(float *)v9.i32 + *(float *)v5.f64;
  *((float *)&v16 + 1) = *(float *)v9.i32 + *(float *)v5.f64;
  *(double *)v18.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v16, v17, v5.f64[0], v13, v9, v10, v12);
  float32x4_t v43 = v18;
  float64x2_t v19 = v48;
  *(float32x2_t *)v18.f32 = vadd_f32(*(float32x2_t *)&v48.f64[0], (float32x2_t)1056964608);
  *(float *)&double v20 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v18.f32, 1), *((float *)this + 4), v18.f32[0]);
  LODWORD(v21) = *((_DWORD *)this + 7);
  v22.i32[0] = *((_DWORD *)this + 9);
  *(float *)v23.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v18.f32, 1), *(float *)&v21, v18.f32[0]);
  v18.f32[0] = *((float *)this + 6) + *(float *)&v20;
  *(float *)v19.f64 = *(float *)v22.i32 + *(float *)v23.i32;
  v18.f32[1] = *(float *)v22.i32 + *(float *)v23.i32;
  *(double *)v25.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v18.i64, v19, v20, v21, v23, v22, v24);
  float32x4_t v42 = v25;
  float64x2_t v26 = v48;
  *(float32x2_t *)v25.f32 = vadd_f32(*(float32x2_t *)&v48.f64[0], (float32x2_t)1069547520);
  *(float *)&double v27 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v25.f32, 1), *((float *)this + 4), v25.f32[0]);
  LODWORD(v28) = *((_DWORD *)this + 7);
  v29.i32[0] = *((_DWORD *)this + 9);
  *(float *)v30.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v25.f32, 1), *(float *)&v28, v25.f32[0]);
  v25.f32[0] = *((float *)this + 6) + *(float *)&v27;
  *(float *)v26.f64 = *(float *)v29.i32 + *(float *)v30.i32;
  v25.f32[1] = *(float *)v29.i32 + *(float *)v30.i32;
  *(double *)v32.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v25.i64, v26, v27, v28, v30, v29, v31);
  float32x4_t v41 = v32;
  float64x2_t v33 = v48;
  *(float32x2_t *)v32.f32 = vadd_f32(*(float32x2_t *)&v48.f64[0], (float32x2_t)1075838976);
  *(float *)&double v34 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v32.f32, 1), *((float *)this + 4), v32.f32[0]);
  LODWORD(v35) = *((_DWORD *)this + 7);
  v36.i32[0] = *((_DWORD *)this + 9);
  *(float *)v37.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v32.f32, 1), *(float *)&v35, v32.f32[0]);
  v32.f32[0] = *((float *)this + 6) + *(float *)&v34;
  *(float *)v33.f64 = *(float *)v36.i32 + *(float *)v37.i32;
  v32.f32[1] = *(float *)v36.i32 + *(float *)v37.i32;
  *(double *)v39.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v32.i64, v33, v34, v35, v37, v36, v38);
  *(void *)&double result = vaddq_f32(vaddq_f32(vaddq_f32(vmulq_n_f32(v43, v45), vmulq_n_f32(v42, v44)), vmulq_n_f32(v41, v46)), vmulq_n_f32(v39, v47)).u64[0];
  return result;
}

double upsampleHRect(double a1, float a2)
{
  float32x2_t v11 = (float32x2_t)__PAIR64__(HIDWORD(a1), COERCE_UNSIGNED_INT(floorf((float)(a2 * *(float *)&a1) + -0.5)));
  float32x2_t v2 = vadd_f32(v11, (float32x2_t)3204448256);
  v16.origin.CGFloat x = v2.f32[0];
  v16.origin.CGFloat y = v2.f32[1];
  v16.size.CGFloat width = 0.0;
  v16.size.CGFloat height = 0.0;
  CGRect v13 = CGRectUnion(*MEMORY[0x1E4F1DB20], v16);
  float32x2_t v3 = vadd_f32(v11, (float32x2_t)1056964608);
  v17.origin.CGFloat x = v3.f32[0];
  v17.origin.CGFloat y = v3.f32[1];
  v17.size.CGFloat width = 0.0;
  v17.size.CGFloat height = 0.0;
  CGRect v14 = CGRectUnion(v13, v17);
  float32x2_t v4 = vadd_f32(v11, (float32x2_t)1069547520);
  v18.origin.CGFloat x = v4.f32[0];
  v18.origin.CGFloat y = v4.f32[1];
  v18.size.CGFloat width = 0.0;
  v18.size.CGFloat height = 0.0;
  CGRect v15 = CGRectUnion(v14, v18);
  float32x2_t v5 = vadd_f32(v11, (float32x2_t)1075838976);
  double v6 = v5.f32[0];
  double v7 = v5.f32[1];
  uint64_t v8 = 0;
  uint64_t v9 = 0;

  *(void *)&double result = (unint64_t)CGRectUnion(v15, *(CGRect *)&v6);
  return result;
}

double cikernel::_lanczosUpV(cikernel *this, SamplerObj *a2, float a3)
{
  v5.f64[0] = *(float64_t *)CI::getDC(this);
  float v6 = vmuls_lane_f32(a3, *(float32x2_t *)&v5.f64[0], 1) + -0.5;
  HIDWORD(v5.f64[0]) = floorf(v6);
  float32x2_t v7 = *(float32x2_t *)&v5.f64[0];
  float64x2_t v48 = v5;
  float v8 = (float)(*((float *)v5.f64 + 1) - v6) + 1.0;
  v5.f64[0] = (float)(v8 * v8);
  v9.i32[1] = 1072237884;
  v10.i64[0] = 0xBFDA4BAB03FA3591;
  float v11 = v5.f64[0] * (v8 * (v8 * (v8 * -0.41086841 + 0.78286595) + 1.04059357) + -2.41189213) + 1.0;
  float v45 = v11;
  *(double *)v12.i64 = v8 * (v8 * -0.29216512 + 1.02524562) + -0.5242291;
  double v13 = v8 * *(double *)v12.i64 + -0.2088514;
  *(float *)&double v13 = v13 * v5.f64[0];
  float v47 = *(float *)&v13;
  float v14 = 1.0 - v8;
  double v15 = (float)(v14 * v14);
  double v16 = v14;
  v5.f64[0] = v16 * (v16 * -0.41086841 + 0.78286595) + 1.04059357;
  *(float *)&double v15 = v15 * (v16 * v5.f64[0] + -2.41189213) + 1.0;
  float v44 = *(float *)&v15;
  *(float *)&double v16 = 1.0 - *(float *)&v13 - *(float *)&v15 - v11;
  float v46 = *(float *)&v16;
  *(float32x2_t *)&v17.f64[0] = vadd_f32(v7, (float32x2_t)0xBF00000000000000);
  LODWORD(v13) = *((_DWORD *)this + 7);
  *(float *)&double v16 = *((float *)this + 6)
                 + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)&v17.f64[0], 1), *((float *)this + 4), *(float *)v17.f64);
  v9.i32[0] = *((_DWORD *)this + 9);
  *(float *)v5.f64 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)&v17.f64[0], 1), *(float *)&v13, *(float *)v17.f64);
  *(float *)v17.f64 = *(float *)v9.i32 + *(float *)v5.f64;
  *((float *)&v16 + 1) = *(float *)v9.i32 + *(float *)v5.f64;
  *(double *)v18.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v16, v17, v5.f64[0], v13, v9, v10, v12);
  float32x4_t v43 = v18;
  float64x2_t v19 = v48;
  *(float32x2_t *)v18.f32 = vadd_f32(*(float32x2_t *)&v48.f64[0], (float32x2_t)0x3F00000000000000);
  *(float *)&double v20 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v18.f32, 1), *((float *)this + 4), v18.f32[0]);
  LODWORD(v21) = *((_DWORD *)this + 7);
  v22.i32[0] = *((_DWORD *)this + 9);
  *(float *)v23.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v18.f32, 1), *(float *)&v21, v18.f32[0]);
  v18.f32[0] = *((float *)this + 6) + *(float *)&v20;
  *(float *)v19.f64 = *(float *)v22.i32 + *(float *)v23.i32;
  v18.f32[1] = *(float *)v22.i32 + *(float *)v23.i32;
  *(double *)v25.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v18.i64, v19, v20, v21, v23, v22, v24);
  float32x4_t v42 = v25;
  float64x2_t v26 = v48;
  *(float32x2_t *)v25.f32 = vadd_f32(*(float32x2_t *)&v48.f64[0], (float32x2_t)0x3FC0000000000000);
  *(float *)&double v27 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v25.f32, 1), *((float *)this + 4), v25.f32[0]);
  LODWORD(v28) = *((_DWORD *)this + 7);
  v29.i32[0] = *((_DWORD *)this + 9);
  *(float *)v30.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v25.f32, 1), *(float *)&v28, v25.f32[0]);
  v25.f32[0] = *((float *)this + 6) + *(float *)&v27;
  *(float *)v26.f64 = *(float *)v29.i32 + *(float *)v30.i32;
  v25.f32[1] = *(float *)v29.i32 + *(float *)v30.i32;
  *(double *)v32.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v25.i64, v26, v27, v28, v30, v29, v31);
  float32x4_t v41 = v32;
  float64x2_t v33 = v48;
  *(float32x2_t *)v32.f32 = vadd_f32(*(float32x2_t *)&v48.f64[0], (float32x2_t)0x4020000000000000);
  *(float *)&double v34 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v32.f32, 1), *((float *)this + 4), v32.f32[0]);
  LODWORD(v35) = *((_DWORD *)this + 7);
  v36.i32[0] = *((_DWORD *)this + 9);
  *(float *)v37.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v32.f32, 1), *(float *)&v35, v32.f32[0]);
  v32.f32[0] = *((float *)this + 6) + *(float *)&v34;
  *(float *)v33.f64 = *(float *)v36.i32 + *(float *)v37.i32;
  v32.f32[1] = *(float *)v36.i32 + *(float *)v37.i32;
  *(double *)v39.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v32.i64, v33, v34, v35, v37, v36, v38);
  *(void *)&double result = vaddq_f32(vaddq_f32(vmulq_n_f32(v43, v47), vaddq_f32(vmulq_n_f32(v42, v44), vmulq_n_f32(v41, v45))), vmulq_n_f32(v39, v46)).u64[0];
  return result;
}

double upsampleVRect(float32x2_t a1, float a2)
{
  float32x2_t v11 = (float32x2_t)__PAIR64__(COERCE_UNSIGNED_INT(floorf(vmuls_lane_f32(a2, a1, 1) + -0.5)), a1.u32[0]);
  float32x2_t v2 = vadd_f32(v11, (float32x2_t)0x3F00000000000000);
  v16.origin.CGFloat x = v2.f32[0];
  v16.origin.CGFloat y = v2.f32[1];
  v16.size.CGFloat width = 0.0;
  v16.size.CGFloat height = 0.0;
  CGRect v13 = CGRectUnion(*MEMORY[0x1E4F1DB20], v16);
  float32x2_t v3 = vadd_f32(v11, (float32x2_t)0xBF00000000000000);
  v17.origin.CGFloat x = v3.f32[0];
  v17.origin.CGFloat y = v3.f32[1];
  v17.size.CGFloat width = 0.0;
  v17.size.CGFloat height = 0.0;
  CGRect v14 = CGRectUnion(v13, v17);
  float32x2_t v4 = vadd_f32(v11, (float32x2_t)0x3FC0000000000000);
  v18.origin.CGFloat x = v4.f32[0];
  v18.origin.CGFloat y = v4.f32[1];
  v18.size.CGFloat width = 0.0;
  v18.size.CGFloat height = 0.0;
  CGRect v15 = CGRectUnion(v14, v18);
  float32x2_t v5 = vadd_f32(v11, (float32x2_t)0x4020000000000000);
  double v6 = v5.f32[0];
  double v7 = v5.f32[1];
  uint64_t v8 = 0;
  uint64_t v9 = 0;

  *(void *)&double result = (unint64_t)CGRectUnion(v15, *(CGRect *)&v6);
  return result;
}

double cikernel::_lozengeRefraction(uint64_t a1, float32x2_t a2, float32x2_t a3, float a4, double a5, int8x8_t a6, float a7, float a8)
{
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  float32x2_t v15 = vsub_f32(*DC, a2);
  v16.f32[0] = vmlas_n_f32(vmuls_lane_f32(-*(float *)&a5, v15, 1), *((float *)&a5 + 1), v15.f32[0]);
  int8x8_t v17 = vbsl_s8((int8x8_t)vdup_lane_s32(vcgt_f32(0, v16), 0), a6, (int8x8_t)vneg_f32((float32x2_t)a6));
  int32x2_t v18 = (int32x2_t)vmul_f32(v15, v15);
  float v19 = fabsf(v16.f32[0]);
  v16.i32[0] = vadd_f32((float32x2_t)v18, (float32x2_t)vdup_lane_s32(v18, 1)).u32[0];
  float v20 = sqrtf(vaddv_f32((float32x2_t)v18));
  float32x2_t v21 = vrsqrte_f32((float32x2_t)v16.u32[0]);
  int8x8_t v22 = (int8x8_t)vmul_n_f32(v15, vmul_f32(v21, vrsqrts_f32((float32x2_t)v16.u32[0], vmul_f32(v21, v21))).f32[0]);
  int32x2_t v23 = (int32x2_t)vmul_f32(*(float32x2_t *)&a5, v15);
  int8x16_t v24 = (float32x2_t *)CI::getDC((CI *)DC);
  *(float32x2_t *)v33.f32 = vsub_f32(*v24, a3);
  int32x2_t v26 = (int32x2_t)vmul_f32(*(float32x2_t *)v33.f32, *(float32x2_t *)v33.f32);
  unsigned __int32 v27 = vadd_f32((float32x2_t)v26, (float32x2_t)vdup_lane_s32(v26, 1)).u32[0];
  float v28 = sqrtf(vaddv_f32((float32x2_t)v26));
  float32x2_t v29 = vrsqrte_f32((float32x2_t)v27);
  LODWORD(v30) = vmul_f32(v29, vrsqrts_f32((float32x2_t)v27, vmul_f32(v29, v29))).u32[0];
  int32x2_t v31 = (int32x2_t)vmul_f32(*(float32x2_t *)&a5, *(float32x2_t *)v33.f32);
  int32x2_t v32 = vcltz_f32(vadd_f32((float32x2_t)vzip1_s32(v31, v23), (float32x2_t)vzip2_s32(v31, v23)));
  *(float32x2_t *)v33.f32 = vmul_n_f32(*(float32x2_t *)v33.f32, v30);
  if (v32.i8[4]) {
    float v34 = v19;
  }
  else {
    float v34 = v20;
  }
  if (v32.i8[4]) {
    unsigned int v35 = -1;
  }
  else {
    unsigned int v35 = 0;
  }
  *(int8x8_t *)v25.f32 = vbsl_s8((int8x8_t)vdup_n_s32(v35), v17, v22);
  BOOL v36 = (v32.i8[0] & 1) == 0;
  if (v32.i8[0]) {
    unsigned int v37 = -1;
  }
  else {
    unsigned int v37 = 0;
  }
  int8x8_t v38 = (int8x8_t)vdup_n_s32(v37);
  if (v36) {
    float v39 = v34;
  }
  else {
    float v39 = v28;
  }
  *(float32x2_t *)v33.f32 = vmul_n_f32((float32x2_t)vbsl_s8(v38, *(int8x8_t *)v33.f32, *(int8x8_t *)v25.f32), v39 / a4);
  double v40 = sqrt(1.0 - (float)((float)(v39 / a4) * (float)(v39 / a4)));
  *(float *)&double v40 = v40;
  v33.i32[2] = LODWORD(v40);
  *(double *)v25.i64 = (float)((float)(1.0 / a7) * (float)(1.0 / a7));
  v25.f32[0] = 1.0 - *(double *)v25.i64 * (1.0 - (float)(*(float *)&v40 * *(float *)&v40));
  float32x4_t v69 = v25;
  float32x4_t v41 = vaddq_f32(vmulq_n_f32((float32x4_t)xmmword_193954540, 1.0 / a7), vmulq_n_f32(v33, -(float)(sqrtf(fabsf(v25.f32[0])) - (float)((float)(1.0 / a7) * *(float *)&v40))));
  *(float32x2_t *)v41.f32 = vmul_n_f32(*(float32x2_t *)v41.f32, (float)-(float)(a8 + (float)(*(float *)&v40 * a4)) / v41.f32[2]);
  *(float *)&double v40 = a4 + a4;
  int32x2_t v42 = vdup_lane_s32(*(int32x2_t *)&v40, 0);
  *(float32x2_t *)v41.f32 = vminnm_f32(*(float32x2_t *)v41.f32, (float32x2_t)v42);
  *(float *)v42.i32 = a4 * -2.0;
  float32x2_t v43 = vadd_f32(vmaxnm_f32(*(float32x2_t *)v41.f32, (float32x2_t)vdup_lane_s32(v42, 0)), *(float32x2_t *)CI::getDC((CI *)v24));
  *(float *)&double v44 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v43, 1), *(float *)(a1 + 16), v43.f32[0]);
  LODWORD(v45) = *(_DWORD *)(a1 + 28);
  v46.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v47.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v43, 1), *(float *)&v45, v43.f32[0]);
  v43.f32[0] = *(float *)(a1 + 24) + *(float *)&v44;
  *(float *)v48.f64 = *(float *)v46.i32 + *(float *)v47.i32;
  v43.f32[1] = *(float *)v46.i32 + *(float *)v47.i32;
  *(double *)v51.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v43, v48, v44, v45, v47, v46, v49);
  v52.i64[0] = 0;
  int8x16_t v53 = vandq_s8(v51, (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vcgtq_f32(v52, v69)), 0));
  if ((float)(a4 - v39) <= 1.0) {
    float v54 = a4 - v39;
  }
  else {
    float v54 = 1.0;
  }
  if ((float)(a4 - v39) >= 0.0) {
    float v55 = v54;
  }
  else {
    float v55 = 0.0;
  }
  float v67 = v55;
  float32x4_t v70 = (float32x4_t)v53;
  int8x16_t v56 = (float32x2_t *)CI::getDC(v50);
  *(float *)&double v57 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *v56, 1), *(float *)(a1 + 16), COERCE_FLOAT(*v56));
  LODWORD(v58) = *(_DWORD *)(a1 + 28);
  v59.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v60.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *v56, 1), *(float *)&v58, COERCE_FLOAT(*v56));
  *(float *)&double v61 = *(float *)(a1 + 24) + *(float *)&v57;
  *(float *)v62.f64 = *(float *)v59.i32 + *(float *)v60.i32;
  *((float *)&v61 + 1) = *(float *)v59.i32 + *(float *)v60.i32;
  *(double *)v64.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v61, v62, v57, v58, v60, v59, v63);
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(v64, 1.0 - v67), v70, v67).u64[0];
  return result;
}

void CI::f4_sr_f2_f2_f_f2_f2_f_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = *(void *)(a1 + 48);
  float32x2_t v11 = *(double (**)(uint64_t, double, double, float, double, double, float, float))(a1 + 24);
  uint64_t v12 = *(void *)(v10 + 8);
  int v13 = *(_DWORD *)(v10 + 40);
  uint64_t v14 = *(void *)(v10 + 32);
  int v15 = *(_DWORD *)(v10 + 64);
  uint64_t v16 = *(void *)(v10 + 56);
  uint64_t v17 = *(void *)(v10 + 80);
  int v18 = *(_DWORD *)(v10 + 112);
  uint64_t v19 = *(void *)(v10 + 104);
  int v20 = *(_DWORD *)(v10 + 136);
  uint64_t v21 = *(void *)(v10 + 128);
  uint64_t v22 = *(void *)(v10 + 152);
  uint64_t v23 = *(void *)(v10 + 176);
  if (*(unsigned char *)(a1 + 64))
  {
    uint64_t v33 = *(void *)(v10 + 32);
    float v34 = *(double (**)(uint64_t, double, double, float, double, double, float, float))(a1 + 24);
    uint64_t v32 = *(void *)(v10 + 8);
    uint64_t v30 = *(void *)(v10 + 152);
    int v31 = *(_DWORD *)(v10 + 64);
    int v29 = *(_DWORD *)(v10 + 136);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 200)), a2);
    int v20 = v29;
    int v15 = v31;
    uint64_t v12 = v32;
    uint64_t v14 = v33;
    uint64_t v22 = v30;
    float32x2_t v11 = v34;
  }
  int8x16_t v24 = (double *)(a3 + 16 * v21);
  if (v20 != 5) {
    int8x16_t v24 = (double *)((char *)a2 + 64 * v21);
  }
  float32x4_t v25 = (double *)(a3 + 16 * v19);
  if (v18 != 5) {
    float32x4_t v25 = (double *)((char *)a2 + 64 * v19);
  }
  int32x2_t v26 = (double *)(a3 + 16 * v16);
  if (v15 != 5) {
    int32x2_t v26 = (double *)((char *)a2 + 64 * v16);
  }
  unsigned __int32 v27 = (double *)(a3 + 16 * v14);
  if (v13 != 5) {
    unsigned __int32 v27 = (double *)((char *)a2 + 64 * v14);
  }
  *(double *)&long long v28 = v11(a4 + 80 * v12, *v27, *v26, *((float *)a2 + 16 * v17), *v25, *v24, *((float *)a2 + 16 * v22), *((float *)a2 + 16 * v23));
  *(_OWORD *)(a3 + 16 * a7) = v28;
}

double cikernel::_torusRefraction(uint64_t a1, float32x2_t a2, float a3, float a4, float a5, float a6, float a7)
{
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)v17.i8 = vsub_f32(*DC, a2);
  int32x2_t v15 = (int32x2_t)vmul_f32(*(float32x2_t *)v17.i8, *(float32x2_t *)v17.i8);
  v19.i32[0] = vadd_f32((float32x2_t)v15, (float32x2_t)vdup_lane_s32(v15, 1)).u32[0];
  float32x2_t v16 = vrsqrte_f32((float32x2_t)v19.u32[0]);
  *(float32x2_t *)v17.i8 = vmul_n_f32(*(float32x2_t *)v17.i8, vmul_f32(v16, vrsqrts_f32((float32x2_t)v19.u32[0], vmul_f32(v16, v16))).f32[0]);
  float v18 = a4 + (float)(a3 * sqrtf(vaddv_f32((float32x2_t)v15)));
  v19.f32[0] = (1.0 - fabsf(v18)) * a5;
  if (v19.f32[0] <= 1.0) {
    float v20 = v19.f32[0];
  }
  else {
    float v20 = 1.0;
  }
  BOOL v21 = v19.f32[0] < 0.0;
  v19.i64[0] = 0;
  if (!v21) {
    v19.f32[0] = v20;
  }
  float32x4_t v50 = v19;
  *(float32x2_t *)v19.f32 = vmul_n_f32(*(float32x2_t *)v17.i8, v18);
  *(double *)v17.i64 = sqrt(1.0 - (float)(v18 * v18));
  *(float *)v17.i32 = *(double *)v17.i64;
  v19.i32[2] = v17.i32[0];
  int8x16_t v46 = v17;
  float32x4_t v47 = v19;
  v22.i64[0] = *(void *)CI::getDC((CI *)DC);
  int8x16_t v23 = v46;
  *(double *)v24.i64 = 1.0 - (float)(*(float *)v23.i32 * *(float *)v23.i32);
  v24.f32[0] = 1.0 - (float)((float)(1.0 / a6) * (float)(1.0 / a6)) * *(double *)v24.i64;
  float32x4_t v48 = v24;
  float32x4_t v25 = vmulq_n_f32((float32x4_t)xmmword_193954540, 1.0 / a6);
  v24.i32[1] = v47.i32[1];
  float32x4_t v26 = vaddq_f32(v25, vmulq_n_f32(v47, -(float)(sqrtf(fabsf(v24.f32[0])) - (float)((float)(1.0 / a6) * *(float *)v46.i32))));
  int8x16_t v27 = (int8x16_t)vaddq_f32(v22, vmulq_n_f32(v26, (float)-(float)(a7 + (float)(*(float *)v46.i32 * a5)) / v26.f32[2]));
  v26.i64[1] = v50.i64[1];
  *(double *)v26.i64 = v50.f32[0];
  v25.i64[0] = 0x3F50624DD2F1A9FCLL;
  int8x16_t v28 = (int8x16_t)vcgtq_f64((float64x2_t)v25, (float64x2_t)v26);
  int8x16_t v29 = (int8x16_t)vdupq_n_s32(0x42480000u);
  float64x2_t v30 = (float64x2_t)vbslq_s8(v28, v29, v27);
  v24.i32[0] = *(_DWORD *)(a1 + 28);
  *(float *)v27.i32 = *(float *)(a1 + 24)
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v30.f64[0], 1), *(float *)(a1 + 16), *(float *)v30.f64);
  v23.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v29.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v30.f64[0], 1), v24.f32[0], *(float *)v30.f64);
  *(float *)v30.f64 = *(float *)v23.i32 + *(float *)v29.i32;
  *(float *)&v27.i32[1] = *(float *)v23.i32 + *(float *)v29.i32;
  *(double *)v33.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v27.i64, v30, *(double *)v29.i64, *(double *)v24.i64, v23, v31, v32);
  v34.i64[0] = 0;
  float32x4_t v49 = (float32x4_t)vandq_s8(v33, (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vcgtq_f32(v34, v48)), 0));
  BOOL v36 = (float32x2_t *)CI::getDC(v35);
  *(float *)&double v37 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *v36, 1), *(float *)(a1 + 16), COERCE_FLOAT(*v36));
  LODWORD(v38) = *(_DWORD *)(a1 + 28);
  v39.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v40.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *v36, 1), *(float *)&v38, COERCE_FLOAT(*v36));
  *(float *)&double v41 = *(float *)(a1 + 24) + *(float *)&v37;
  *(float *)v42.f64 = *(float *)v39.i32 + *(float *)v40.i32;
  *((float *)&v41 + 1) = *(float *)v39.i32 + *(float *)v40.i32;
  *(double *)v44.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v41, v42, v37, v38, v40, v39, v43);
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(v44, 1.0 - v50.f32[0]), v49, v50.f32[0]).u64[0];
  return result;
}

void CI::f4_sr_f2_f_f_f_f_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v8 = a3;
  uint64_t v10 = *(void *)(a1 + 48);
  float32x2_t v11 = *(double (**)(uint64_t, double, float, float, float, float, float))(a1 + 24);
  uint64_t v12 = *(void *)(v10 + 8);
  int v13 = *(_DWORD *)(v10 + 40);
  uint64_t v14 = *(void *)(v10 + 32);
  uint64_t v15 = *(void *)(v10 + 56);
  uint64_t v16 = *(void *)(v10 + 80);
  uint64_t v17 = *(void *)(v10 + 104);
  uint64_t v18 = *(void *)(v10 + 128);
  uint64_t v19 = *(void *)(v10 + 152);
  if (*(unsigned char *)(a1 + 64))
  {
    uint64_t v23 = *(void *)(v10 + 128);
    uint64_t v20 = *(void *)(v10 + 104);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 176)), a2);
    uint64_t v17 = v20;
    uint64_t v18 = v23;
    uint64_t v8 = a3;
  }
  BOOL v21 = (double *)(v8 + 16 * v14);
  if (v13 != 5) {
    BOOL v21 = (double *)((char *)a2 + 64 * v14);
  }
  *(double *)&long long v22 = v11(a4 + 80 * v12, *v21, *((float *)a2 + 16 * v15), *((float *)a2 + 16 * v16), *((float *)a2 + 16 * v17), *((float *)a2 + 16 * v18), *((float *)a2 + 16 * v19));
  *(_OWORD *)(v8 + 16 * a7) = v22;
}

float sampleLinearWithOffset(void *a1, unsigned int a2, double a3, double a4)
{
  uint64_t v8 = [a1 baseAddress];
  float v9 = 0.0;
  if (a3 >= 0.0 && a4 >= 0.0)
  {
    uint64_t v10 = v8;
    [a1 region];
    if (a3 + 1.0 <= v11)
    {
      [a1 region];
      if (a4 + 1.0 <= v12)
      {
        int v13 = [a1 format];
        double v14 = 4.0;
        switch(v13)
        {
          case 2309:
            int v15 = 0;
            char v16 = 1;
LABEL_9:
            unsigned int v17 = 4;
            goto LABEL_10;
          case 2312:
            int v15 = 0;
            char v16 = 1;
            double v14 = 16.0;
            goto LABEL_9;
          case 261:
            int v15 = 1;
            double v14 = 1.0;
            char v16 = 1;
            break;
          case 2056:
            int v15 = 0;
            char v16 = 0;
            double v14 = 8.0;
            unsigned int v17 = 2;
            goto LABEL_10;
          case 264:
            char v16 = 1;
            int v15 = 1;
            break;
          default:
            abort();
        }
        unsigned int v17 = 1;
LABEL_10:
        double v18 = floor(a3) * v14
            + floor(a4) * (double)(unint64_t)[a1 bytesPerRow]
            + (double)(v17 * (unint64_t)a2);
        uint64_t v19 = (unsigned char *)(v10 + (unint64_t)v18);
        if (v15)
        {
          LOBYTE(v18) = *v19;
          double v20 = (double)*(unint64_t *)&v18;
        }
        else
        {
          if ((v16 & 1) == 0)
          {
            float v25 = 0.0;
            src.data = (void *)(v10 + (unint64_t)v18);
            *(int64x2_t *)&src.CGFloat height = vdupq_n_s64(1uLL);
            src.rowBytes = 2;
            dest.data = &v25;
            *(_OWORD *)&dest.CGFloat height = *(_OWORD *)&src.height;
            dest.rowBytes = 4;
            vImageConvert_Planar16FtoPlanarF(&src, &dest, 0x10u);
            double v21 = 0.0;
            if (v25 != 1.0) {
              return v25;
            }
            return v21;
          }
          double v20 = (double)(char)*v19;
        }
        return v20 / 255.0;
      }
    }
  }
  return v9;
}

double cikernel::_ciLensModelCalculator(uint64_t a1, uint64_t a2, int8x16_t a3, double a4)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  bzero(v42, 0x400uLL);
  LODWORD(v6) = *(_DWORD *)(a2 + 28);
  v7.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v8.i32 = *(float *)(a2 + 32) * 0.5;
  *(float *)&double v9 = *(float *)v8.i32 + (float)(*(float *)&v6 * 0.5);
  *(float *)&double v10 = *(float *)(a2 + 24)
                 + (float)((float)(*(float *)(a2 + 20) * 0.5) + (float)(*(float *)(a2 + 16) * 0.5));
  *(float *)v11.f64 = *(float *)v7.i32 + *(float *)&v9;
  *((float *)&v10 + 1) = *(float *)v7.i32 + *(float *)&v9;
  v19.f64[0] = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v10, v11, v9, v6, v8, v7, v12);
  int v16 = 0;
  float v17 = floor(*(float *)v19.f64 * 65536.0) * 0.0000152587891;
  v19.f64[0] = ceil(*((float *)v19.f64 + 1) * 65536.0) * 0.0000152587891;
  int8x16_t v18 = a3;
  *(float *)v19.f64 = v19.f64[0];
  float v20 = *(float *)v19.f64 - v17;
  float32x2_t v21 = (float32x2_t)vdup_n_s32(0x3C800000u);
  float32x2_t v22 = vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL), v21);
  float32x2_t v23 = vmul_f32(v22, (float32x2_t)0x3F0000003F000000);
  float v24 = (float)(1.0 / (float)(*(float *)v19.f64 - v17)) * 256.0;
  do
  {
    int v25 = 0;
    *(float *)v19.f64 = (float)v16;
    float64x2_t v41 = v19;
    do
    {
      v26.f32[0] = (float)v25;
      float64x2_t v27 = v41;
      v26.i32[1] = LODWORD(v41.f64[0]);
      float32x2_t v28 = vadd_f32(v23, vadd_f32(*(float32x2_t *)v18.i8, vmul_f32(v22, v26)));
      v21.f32[0] = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v28, 1), *(float *)(a1 + 16), v28.f32[0]);
      v18.i32[0] = *(_DWORD *)(a1 + 28);
      v14.i32[0] = *(_DWORD *)(a1 + 36);
      *(float *)v13.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v28, 1), *(float *)v18.i32, v28.f32[0]);
      v28.f32[0] = *(float *)(a1 + 24) + v21.f32[0];
      *(float *)v27.f64 = *(float *)v14.i32 + *(float *)v13.i32;
      v28.f32[1] = *(float *)v14.i32 + *(float *)v13.i32;
      v19.f64[0] = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v28, v27, *(double *)&v21, *(double *)v18.i64, v13, v14, v15);
      v18.i64[0] = a3.i64[0];
      int v29 = (int)fminf(v24 * (float)(*(float *)v19.f64 - v17), 255.0);
      if (v29 >= 255) {
        int v29 = 255;
      }
      ++v42[v29 & ~(v29 >> 31)];
      ++v25;
    }
    while (v25 != 64);
    ++v16;
  }
  while (v16 != 64);
  HIDWORD(v30) = HIDWORD(a4);
  int v31 = vcvtmd_s64_f64(*(float *)&a4 * 64.0 * 64.0);
  if (v31 < 1)
  {
    float v36 = -1.0;
    float v35 = 0.0;
  }
  else
  {
    unint64_t v32 = 0;
    int v33 = 0;
    do
    {
      unint64_t v34 = v32;
      v33 += v42[v32++];
    }
    while (v34 <= 0xFE && v33 < v31);
    float v35 = (float)v33;
    float v36 = (float)((int)v32 - 1);
  }
  float v37 = (float)(v20 * (float)((float)(fmaxf(v36, 0.0) + fminf(fmaxf((float)v31 / fmaxf(v35, 1.0), 0.0), 1.0)) + 0.5))
      * 0.00390625
      + v17;
  *(float *)&double v30 = v37;
  return v30;
}

void CI::f4_sr_f4_sr_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = *(void *)(a1 + 48);
  float64x2_t v11 = *(double (**)(uint64_t, uint64_t, __n128, __n128))(a1 + 24);
  uint64_t v12 = *(void *)(v10 + 8);
  int v13 = *(_DWORD *)(v10 + 40);
  uint64_t v14 = *(void *)(v10 + 32);
  uint64_t v15 = *(void *)(v10 + 56);
  int v16 = *(_DWORD *)(v10 + 88);
  uint64_t v17 = *(void *)(v10 + 80);
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 104)), a2);
  }
  int8x16_t v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5) {
    int8x16_t v18 = (__n128 *)((char *)a2 + 64 * v17);
  }
  float64x2_t v19 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    float64x2_t v19 = (__n128 *)((char *)a2 + 64 * v14);
  }
  *(double *)&long long v20 = v11(a4 + 80 * v12, a4 + 80 * v15, *v19, *v18);
  *(_OWORD *)(a3 + 16 * a7) = v20;
}

__n64 cikernel::_CILensModelApply(float32x4_t a1, float32x4_t a2)
{
  float v2 = fabsf(fminf(vsubq_f32(a1, a2).f32[0], a2.f32[2]));
  float v3 = vmuls_lane_f32(v2, a2, 3);
  if (v3 <= 1.0) {
    float v4 = v3;
  }
  else {
    float v4 = 1.0;
  }
  if (v3 < 0.0) {
    float v4 = 0.0;
  }
  float v5 = vmuls_lane_f32((float)(v2 * v4) + (float)((float)(1.0 - v4) * 0.0), *(float32x2_t *)a2.f32, 1);
  if (v5 <= 1.0) {
    float v6 = v5;
  }
  else {
    float v6 = 1.0;
  }
  if (v5 >= 0.0) {
    float v7 = v6;
  }
  else {
    float v7 = 0.0;
  }
  result.n64_f32[0] = sqrtf(v7);
  if (result.n64_f32[0] > 1.0) {
    result.n64_f32[0] = 1.0;
  }
  result.n64_u32[1] = 0;
  return result;
}

double cikernel::_lenticularHalo(uint64_t a1, float32x2_t a2, float32x2_t a3, float a4, float a5, float a6, float a7, float32x4_t a8, float32x4_t a9)
{
  float32x2_t v12 = vsub_f32(*(float32x2_t *)CI::getDC((CI *)a1), a2);
  int32x2_t v13 = (int32x2_t)vmul_f32(v12, v12);
  unsigned __int32 v14 = vadd_f32((float32x2_t)v13, (float32x2_t)vdup_lane_s32(v13, 1)).u32[0];
  *(float *)v13.i32 = sqrtf(vaddv_f32((float32x2_t)v13));
  float32x4_t v15 = vmulq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(v13, 0), a8), a5);
  v15.i32[3] = 0;
  float32x4_t v16 = vmaxnmq_f32(v15, (float32x4_t)0);
  v16.i32[3] = 0;
  float32x4_t v17 = vminnmq_f32(v16, (float32x4_t)xmmword_1939508C0);
  __asm { FMOV            V3.4S, #1.0 }
  float32x4_t v23 = vsubq_f32(_Q3, v17);
  v17.i32[3] = 0;
  v23.i32[3] = 0;
  float32x4_t v24 = vminnmq_f32(v17, v23);
  float32x4_t v25 = vaddq_f32(v24, v24);
  __asm { FMOV            V4.4S, #3.0 }
  float32x4_t v33 = vmulq_f32(v25, vmulq_f32(v25, vsubq_f32(_Q4, vaddq_f32(v25, v25))));
  *(float32x2_t *)v25.f32 = vrsqrte_f32((float32x2_t)v14);
  *(float32x2_t *)v23.f32 = vmul_f32(*(float32x2_t *)v25.f32, *(float32x2_t *)v25.f32);
  float32x2_t v27 = vrsqrts_f32((float32x2_t)v14, *(float32x2_t *)v23.f32);
  v25.i64[1] = v35;
  *(float32x2_t *)v25.f32 = vadd_f32(a3, vmul_n_f32(vmul_n_f32(v12, vmul_f32(*(float32x2_t *)v25.f32, v27).f32[0]), a4));
  v23.i32[0] = *(_DWORD *)(a1 + 28);
  v12.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v25.f32, 1), *(float *)(a1 + 16), v25.f32[0]);
  _Q4.i32[0] = *(_DWORD *)(a1 + 36);
  v27.f32[0] = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v25.f32, 1), v23.f32[0], v25.f32[0]);
  v25.f32[0] = _Q4.f32[0] + v27.f32[0];
  v12.f32[1] = _Q4.f32[0] + v27.f32[0];
  *(void *)&double result = vmulq_f32(a9, vmulq_n_f32(v33, vmlas_n_f32(a7, a6, COERCE_FLOAT(COERCE_UNSIGNED_INT64(CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v12, (float64x2_t)v25, *(double *)&v27, *(double *)v23.i64, (int8x16_t)_Q4, v28, v29)))))).u64[0];
  return result;
}

void CI::f4_sr_f2_f2_f_f_f_f_f3_clr(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = *(void *)(a1 + 48);
  float64x2_t v11 = *(double (**)(uint64_t, double, double, float, float, float, float, __n128, __n128))(a1 + 24);
  uint64_t v12 = *(void *)(v10 + 8);
  int v13 = *(_DWORD *)(v10 + 40);
  uint64_t v14 = *(void *)(v10 + 32);
  int v15 = *(_DWORD *)(v10 + 64);
  uint64_t v16 = *(void *)(v10 + 56);
  uint64_t v17 = *(void *)(v10 + 80);
  uint64_t v18 = *(void *)(v10 + 104);
  uint64_t v19 = *(void *)(v10 + 128);
  uint64_t v20 = *(void *)(v10 + 152);
  uint64_t v21 = *(void *)(v10 + 176);
  uint64_t v22 = *(void *)(v10 + 200);
  if (*(unsigned char *)(a1 + 64))
  {
    float32x4_t v23 = (CI *)(a3 + 16 * *(void *)(v10 + 224));
    uint64_t v28 = *(void *)(v10 + 200);
    uint64_t v29 = *(void *)(v10 + 8);
    uint64_t v31 = *(void *)(v10 + 128);
    uint64_t v32 = a3;
    uint64_t v24 = *(void *)(v10 + 152);
    int v30 = *(_DWORD *)(v10 + 64);
    CI::setDC(v23, a2);
    uint64_t v22 = v28;
    uint64_t v12 = v29;
    int v15 = v30;
    uint64_t v20 = v24;
    uint64_t v19 = v31;
    a3 = v32;
  }
  float32x4_t v25 = (double *)(a3 + 16 * v16);
  if (v15 != 5) {
    float32x4_t v25 = (double *)((char *)a2 + 64 * v16);
  }
  float32x2_t v26 = (double *)(a3 + 16 * v14);
  if (v13 != 5) {
    float32x2_t v26 = (double *)((char *)a2 + 64 * v14);
  }
  *(double *)&long long v27 = v11(a4 + 80 * v12, *v26, *v25, *((float *)a2 + 16 * v17), *((float *)a2 + 16 * v18), *((float *)a2 + 16 * v19), *((float *)a2 + 16 * v20), *((__n128 *)a2 + 4 * v21), *((__n128 *)a2 + 4 * v22));
  *(_OWORD *)(a3 + 16 * a7) = v27;
}

float32x2_t cikernel::_lighttunnel(CI *a1, float32x4_t a2)
{
  float32x2_t v2 = vsub_f32(*(float32x2_t *)CI::getDC(a1), *(float32x2_t *)a2.f32);
  int32x2_t v3 = (int32x2_t)vmul_f32(v2, v2);
  v3.i32[0] = vadd_f32((float32x2_t)v3, (float32x2_t)vdup_lane_s32(v3, 1)).u32[0];
  float32x2_t v4 = vrsqrte_f32((float32x2_t)v3.u32[0]);
  float v15 = vmuls_lane_f32(vmul_f32(v4, vrsqrts_f32((float32x2_t)v3.u32[0], vmul_f32(v4, v4))).f32[0], a2, 2);
  float v5 = logf(v15);
  __float2 v6 = __sincosf_stret(vmuls_lane_f32(v5, a2, 3));
  v7.f32[0] = -v6.__sinval;
  v7.i32[1] = LODWORD(v6.__cosval);
  int32x2_t v8 = (int32x2_t)vmul_f32(v2, (float32x2_t)__PAIR64__(LODWORD(v6.__sinval), LODWORD(v6.__cosval)));
  int32x2_t v9 = (int32x2_t)vmul_f32(v2, v7);
  float32x2_t v10 = vadd_f32(*(float32x2_t *)a2.f32, vmul_n_f32(vadd_f32((float32x2_t)vzip1_s32(v8, v9), (float32x2_t)vzip2_s32(v8, v9)), v15));
  DC = (float32x2_t *)CI::getDC(v11);
  float v13 = 0.0;
  if (v15 <= 1.0) {
    float v13 = 1.0;
  }
  return vmla_n_f32(vmul_n_f32(*DC, 1.0 - v13), v10, v13);
}

double cikernel::_localContrast(float32x4_t a1, double a2, double a3)
{
  a1.i32[3] = 0;
  float32x4_t v6 = vminnmq_f32(a1, (float32x4_t)0);
  __asm { FMOV            V16.4S, #-1.0 }
  float32x4_t v12 = vaddq_f32(vmaxnmq_f32(a1, (float32x4_t)xmmword_1939508C0), _Q16);
  float32x4_t v13 = vmaxnmq_f32(a1, (float32x4_t)0);
  v13.i32[3] = 0;
  float32x4_t v14 = vminnmq_f32(v13, (float32x4_t)xmmword_1939508C0);
  float32x4_t v15 = vmulq_f32(v14, (float32x4_t)vdupq_n_s32(0x3EAAA64Cu));
  v15.f32[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 2), vaddq_f32(v15, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.f32, 1))).f32[0]);
  v15.f32[0] = (1.0 - v15.f32[0]) * v15.f32[0];
  v14.i32[3] = 0;
  float32x4_t v16 = vsqrtq_f32(v14);
  float v17 = sqrtf(*((float *)&a2 + 1));
  *(float *)v3.i32 = -(float)(v17 * (float)(v15.f32[0] * *(float *)&a3));
  *(double *)_Q16.i64 = (float)(v15.f32[0] * *(float *)&a3);
  *(double *)v4.i64 = *(double *)_Q16.i64 * 0.299;
  v4.f32[0] = *(double *)_Q16.i64 * 0.299;
  double v18 = *(double *)_Q16.i64 * 0.587;
  *(float *)&double v18 = *(double *)_Q16.i64 * 0.587;
  *(double *)_Q16.i64 = *(double *)_Q16.i64 * 0.114;
  _Q16.f32[0] = *(double *)_Q16.i64;
  *(float *)&a3 = -(float)(v15.f32[0] * *(float *)&a3);
  float32x4_t v19 = vmlaq_f32(vmulq_f32(vmlaq_n_f32(vmulq_n_f32(v16, 1.0 - *(float *)&a3), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a3, 0), v17), (float32x4_t)vdupq_n_s32(0x3E4CCCCCu)), (float32x4_t)vdupq_n_s32(0x3F4CCCCDu), vaddq_f32((float32x4_t)vdupq_lane_s32(v3, 0), vaddq_f32(v16, vaddq_f32(vmulq_laneq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)_Q16.f32, 0), v16, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v18, 0), *(float32x2_t *)v16.f32, 1), (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmulq_f32(v16, v4), 0))))));
  v19.i32[3] = 0;
  float32x4_t v20 = vmaxnmq_f32(v19, (float32x4_t)0);
  *(void *)&double result = vaddq_f32(v12, vaddq_f32(v6, vmulq_f32(v20, v20))).u64[0];
  return result;
}

CIImage *_lightMapImageFromData(NSData *a1, NSNumber *a2, NSNumber *a3)
{
  v16[2] = *MEMORY[0x1E4F143B8];
  double result = [(NSData *)a1 length];
  if (result)
  {
    float32x2_t v7 = result;
    int v8 = [(NSNumber *)a2 intValue];
    int v9 = [(NSNumber *)a3 intValue];
    if (!v8 || (int v10 = v9) == 0)
    {
      int v8 = vcvtmd_s64_f64(sqrt((double)(unint64_t)v7 * 0.5));
      int v10 = v8;
    }
    if (v7 == (CIImage *)(2 * v8 * v10))
    {
      v15[0] = @"kCIImageProviderContentDigest";
      v15[1] = @"kCIImageProviderName";
      v16[0] = a1;
      v16[1] = @"CILocalLight";
      uint64_t v11 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v16 forKeys:v15 count:2];
      float32x4_t v12 = [CIImage alloc];
      v13[0] = MEMORY[0x1E4F143A8];
      v13[1] = 3221225472;
      v13[2] = ___ZL22_lightMapImageFromDataP6NSDataP8NSNumberS2__block_invoke;
      void v13[3] = &unk_1E5771F90;
      int v14 = v8;
      v13[4] = a1;
      v13[5] = v7;
      return [(CIImage *)v12 initWithImageProvider:v13 width:v8 height:v10 format:262 colorSpace:0 options:v11];
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CIImage *_scaledLightMapImage(CIImage *a1, CIImage *a2)
{
  double result = 0;
  void v19[3] = *MEMORY[0x1E4F143B8];
  if (a1 && a2)
  {
    [(CIImage *)a1 extent];
    CGFloat v6 = v5;
    CGFloat v8 = v7;
    CGFloat v10 = v9;
    CGFloat v12 = v11;
    [(CIImage *)a2 extent];
    v23.origin.CGFloat x = v13;
    v23.origin.CGFloat y = v14;
    v23.size.CGFloat width = v15;
    v23.size.CGFloat height = v16;
    v21.origin.CGFloat x = v6;
    v21.origin.CGFloat y = v8;
    v21.size.CGFloat width = v10;
    v21.size.CGFloat height = v12;
    if (CGRectEqualToRect(v21, v23))
    {
      return a1;
    }
    else
    {
      [(CIImage *)a1 extent];
      v24.origin.CGFloat x = 0.0;
      v24.origin.CGFloat y = 0.0;
      v24.size.CGFloat width = 1.0;
      v24.size.CGFloat height = 1.0;
      if (CGRectEqualToRect(v22, v24))
      {
        float v17 = [(CIImage *)a1 imageByClampingToExtent];
        [(CIImage *)a2 extent];
        return -[CIImage imageByCroppingToRect:](v17, "imageByCroppingToRect:");
      }
      else
      {
        v18[0] = @"inputSmallImage";
        v18[1] = @"inputSpatialSigma";
        v19[0] = a1;
        v19[1] = &unk_1EE4AB670;
        void v18[2] = @"inputLumaSigma";
        v19[2] = &unk_1EE4AB680;
        return -[CIImage imageByApplyingFilter:withInputParameters:](a2, "imageByApplyingFilter:withInputParameters:", @"CIEdgePreserveUpsampleRGFilter", [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v19 forKeys:v18 count:3]);
      }
    }
  }
  return result;
}

uint64_t anonymous namespace'::area_light_stats_from_histogram(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = 0;
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  long double v5 = 0.0;
  long double v6 = 0.0;
  do
  {
    double v7 = fmin((double)v4 / 255.0, 1.0);
    double v8 = *(double *)(a1 + 8 * v4);
    long double v5 = v5 + v8 * log(v7 + 0.00392156863);
    *(long double *)a2 = v5;
    long double v6 = v6 + v8 * log(1.0 - v7 + 0.00392156863);
    *(long double *)(a2 + 8) = v6;
    ++v4;
  }
  while (v4 != 256);
  *(long double *)a2 = exp(v5);
  *(long double *)(a2 + 8) = exp(v6);
  uint64_t result = MEMORY[0x1F4188790](v9, v10, v11, v12, v13, v14);
  uint64_t v17 = 0;
  double v18 = 1.0e-40;
  do
  {
    double v18 = v18 + *(double *)(a1 + v17);
    v17 += 8;
  }
  while (v17 != 2048);
  uint64_t v19 = 0;
  double v20 = 0.0;
  do
  {
    double v20 = v20 + *(double *)(a1 + v19);
    *(double *)&v34[v19] = v20 / v18;
    v19 += 8;
  }
  while (v19 != 2048);
  unint64_t v21 = 0;
  double v22 = 0.0;
  *(_OWORD *)(a2 + 16) = 0u;
  *(void *)(a2 + 48) = 0;
  *(_OWORD *)(a2 + 32) = 0u;
  double v23 = 0.0;
  double v24 = 0.0;
  double v25 = 0.0;
  double v26 = 0.0;
  double v27 = 0.0;
  do
  {
    double v28 = *(double *)&v34[8 * v21];
    if (v28 >= 0.001 && v27 == 0.0) {
      double v27 = (double)v21 / 255.0;
    }
    if (v28 >= 0.02 && v26 == 0.0)
    {
      double v26 = (double)v21 / 255.0;
      *(double *)(a2 + 16) = v26;
    }
    if (v28 >= 0.1 && v25 == 0.0)
    {
      double v25 = (double)v21 / 255.0;
      *(double *)(a2 + 24) = v25;
    }
    if (v28 >= 0.25 && v24 == 0.0)
    {
      double v24 = (double)v21 / 255.0;
      *(double *)(a2 + 32) = v24;
    }
    if (v28 >= 0.5 && v23 == 0.0)
    {
      double v23 = (double)v21 / 255.0;
      *(double *)(a2 + 40) = v23;
    }
    if (v28 >= 0.98 && v22 == 0.0)
    {
      double v22 = (double)v21 / 255.0;
      *(double *)(a2 + 48) = v22;
    }
    if (v28 >= 1.0 && *(double *)(a2 + 72) == 0.0) {
      *(double *)(a2 + 72) = (double)v21 / 255.0;
    }
    ++v21;
  }
  while (v21 != 256);
  *(double *)(a2 + 64) = v27 * ((sqrt(v27) * -0.65 + 1.0) * 0.85);
  double v29 = 0.6 - v23 - v24;
  if (v16 >= 0.8 || *(double *)(a2 + 72) >= 1.0) {
    double v30 = v29 * 0.9;
  }
  else {
    double v30 = v29 + fmin(0.8 - v16, 0.2);
  }
  double v31 = v23 + v24;
  if (v31 > 0.6)
  {
    if (v22 >= 1.0) {
      double v32 = -0.4;
    }
    else {
      double v32 = -0.7;
    }
    double v30 = v31 + v32;
  }
  double v33 = fmax(v30, 0.1);
  if (v26 <= 0.015 || v22 <= 0.95 || v23 <= 0.14)
  {
    if (v26 > 0.055) {
      double v33 = -v33;
    }
  }
  else
  {
    double v33 = -v33;
  }
  *(double *)(a2 + 56) = v33 * 0.68;
  return result;
}

char *___ZL22_lightMapImageFromDataP6NSDataP8NSNumberS2__block_invoke(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a3 == 2 * *(int *)(a1 + 48))
  {
    uint64_t v9 = (const void *)[*(id *)(a1 + 32) bytes];
    size_t v10 = *(void *)(a1 + 40);
    return (char *)memcpy(a2, v9, v10);
  }
  else
  {
    uint64_t result = (char *)[*(id *)(a1 + 32) bytes];
    if (a7)
    {
      CGFloat v15 = result;
      size_t v16 = 2 * a6;
      do
      {
        uint64_t result = (char *)memcpy(a2, v15, v16);
        v15 += v16;
        a2 += a3;
        --a7;
      }
      while (a7);
    }
  }
  return result;
}

double cikernel::_shadowKernel(float32x4_t a1, float a2, float a3)
{
  *(float *)v3.i32 = a2 * 3.4 + -1.2;
  v3.i32[1] = 0;
  float v4 = (float)(*(float *)v3.i32 * a3) + (float)((float)(1.0 - a3) * 0.0);
  double v5 = v4;
  if (v4 <= 0.0)
  {
    float64x2_t v7 = vmulq_n_f64(vmulq_n_f64((float64x2_t)xmmword_193954730, v5), v5);
    *(float32x2_t *)&v7.f64[0] = vcvt_f32_f64(v7);
    float32x4_t v6 = (float32x4_t)vzip1q_s32((int32x4_t)v7, (int32x4_t)v7);
  }
  else
  {
    *(float *)v3.i32 = v4 * 0.0;
    float32x4_t v6 = (float32x4_t)vdupq_lane_s32(v3, 0);
  }
  a1.i32[3] = 0;
  float32x4_t v9 = vmaxnmq_f32(a1, (float32x4_t)0);
  v9.i32[3] = 0;
  float32x4_t v10 = vminnmq_f32(v9, (float32x4_t)xmmword_1939508C0);
  float32x4_t v11 = vmulq_f32(v10, (float32x4_t)vdupq_n_s32(0x3EAAAA3Bu));
  float v12 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).f32[0]);
  __asm { FMOV            V18.4S, #-1.0 }
  float32x4_t v17 = vaddq_f32(vmaxnmq_f32(a1, (float32x4_t)xmmword_1939508C0), _Q18);
  __asm { FMOV            V19.4S, #1.0 }
  float32x4_t v19 = vaddq_f32(vmulq_f32(vsubq_f32(_Q19, v6), v10), vmulq_f32(v6, vmulq_f32(v10, v10)));
  double v20 = v12;
  float v21 = 0.1 - v12;
  _Q18.i32[1] = 0;
  float v23 = v5 * 1.85 * fmaxf(v21, 0.0) + 1.0;
  float32x4_t v24 = vmulq_n_f32(v19, v23);
  v24.i32[3] = 0;
  float32x4_t v25 = vminnmq_f32(a1, (float32x4_t)0);
  float32x4_t v26 = vmaxnmq_f32(v24, (float32x4_t)0);
  v26.i32[3] = 0;
  float32x4_t v27 = vminnmq_f32(v26, (float32x4_t)xmmword_1939508C0);
  float v28 = fminf(v4 * v4, 1.0);
  if (v4 >= 0.0) {
    float v29 = 0.0;
  }
  else {
    float v29 = v28;
  }
  float v30 = (1.0 - v20) * v20;
  v27.i32[3] = 0;
  float32x4_t v31 = vsqrtq_f32(v27);
  _Q18.f32[0] = (float)(v29 * v30) * -0.4;
  double v32 = (float)(v29 * v30);
  *(double *)_Q19.i64 = v32 * 0.299;
  _Q19.f32[0] = v32 * 0.299;
  double v33 = v32 * 0.587;
  *(float *)&double v33 = v32 * 0.587;
  double v34 = v32 * 0.114;
  *(float *)&double v34 = v34;
  float32x4_t v35 = vmlaq_f32(vmulq_f32(vmlaq_n_f32(vmulq_n_f32(v31, 1.0 - (float)-(float)(v30 * v29)), (float32x4_t)vdupq_n_s32(0x3ECCCCCDu), -(float)(v30 * v29)), (float32x4_t)vdupq_n_s32(0x3E4CCCCCu)), (float32x4_t)vdupq_n_s32(0x3F4CCCCDu), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)_Q18.f32, 0), vaddq_f32(v31, vaddq_f32(vmulq_laneq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v34, 0), v31, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v33, 0), *(float32x2_t *)v31.f32, 1), (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmulq_f32(v31, _Q19), 0))))));
  v35.i32[3] = 0;
  float32x4_t v36 = vmaxnmq_f32(v35, (float32x4_t)0);
  float32x4_t v37 = vmulq_f32(v36, v36);
  v37.i32[3] = 0;
  float32x4_t v38 = vmaxnmq_f32(v37, (float32x4_t)0);
  v38.i32[3] = 0;
  *(void *)&double result = vaddq_f32(v25, vaddq_f32(v17, vminnmq_f32(v38, (float32x4_t)xmmword_1939508C0))).u64[0];
  return result;
}

double cikernel::_polyKernel(float32x4_t a1, double a2, double a3, double a4, double a5, double a6, double a7, float32x4_t a8)
{
  double v8 = *(float *)&a2 * 3.4 + -1.2;
  *(float *)&double v8 = v8;
  *(float *)&double v8 = (float)(*(float *)&v8 * *(float *)&a3) + (float)((float)(1.0 - *(float *)&a3) * 0.0);
  if (*(float *)&v8 <= 0.0)
  {
    a8.f32[0] = *(float *)&v8 * 1.75;
    float32_t v9 = *(float *)&v8 * 1.55;
    a8.i32[1] = a8.i32[0];
    a8.f32[2] = v9;
  }
  else
  {
    *(float *)&double v8 = *(float *)&v8 * 1.5;
    a8 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v8, 0);
  }
  a1.i32[3] = 0;
  float32x4_t v11 = vmaxnmq_f32(a1, (float32x4_t)0);
  v11.i32[3] = 0;
  float32x4_t v12 = vminnmq_f32(v11, (float32x4_t)xmmword_1939508C0);
  float32x4_t v13 = vmulq_f32(v12, (float32x4_t)vdupq_n_s32(0x3EAAAA3Bu));
  float v14 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2), vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1))).f32[0]);
  __asm { FMOV            V18.4S, #-1.0 }
  float32x4_t v20 = vaddq_f32(vmaxnmq_f32(a1, (float32x4_t)xmmword_1939508C0), _Q18);
  __asm { FMOV            V19.4S, #1.0 }
  float32x4_t v22 = vaddq_f32(vmulq_f32(vsubq_f32(_Q19, a8), v12), vmulq_f32(a8, vmulq_f32(v12, v12)));
  v22.i32[3] = 0;
  float32x4_t v23 = vmaxnmq_f32(v22, (float32x4_t)0);
  v23.i32[3] = 0;
  float32x4_t v24 = vminnmq_f32(v23, (float32x4_t)xmmword_1939508C0);
  *(float *)&a3 = fminf(*(float *)&a3, 0.5);
  double v25 = v14;
  *(double *)_Q18.i64 = 1.0 - v25;
  *(float *)&double v25 = (1.0 - v25) * v25;
  v24.i32[3] = 0;
  float32x4_t v26 = vsqrtq_f32(v24);
  float v27 = fmaxf(*((float *)&a2 + 1), 0.5);
  _Q18.f32[0] = -(float)(v27 * (float)(*(float *)&a3 * *(float *)&v25));
  *(double *)v12.i64 = (float)(*(float *)&a3 * *(float *)&v25);
  *(double *)_Q19.i64 = *(double *)v12.i64 * 0.299;
  _Q19.f32[0] = *(double *)v12.i64 * 0.299;
  double v28 = *(double *)v12.i64 * 0.587;
  *(float *)&double v28 = *(double *)v12.i64 * 0.587;
  *(double *)v12.i64 = *(double *)v12.i64 * 0.114;
  v12.f32[0] = *(double *)v12.i64;
  *(float *)&a3 = -(float)(*(float *)&v25 * *(float *)&a3);
  float32x4_t v29 = vmlaq_f32(vmulq_f32(vmlaq_n_f32(vmulq_n_f32(v26, 1.0 - *(float *)&a3), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a3, 0), v27), (float32x4_t)vdupq_n_s32(0x3E4CCCCCu)), (float32x4_t)vdupq_n_s32(0x3F4CCCCDu), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)_Q18.f32, 0), vaddq_f32(v26, vaddq_f32(vmulq_laneq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 0), v26, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v28, 0), *(float32x2_t *)v26.f32, 1), (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmulq_f32(v26, _Q19), 0))))));
  v29.i32[3] = 0;
  float32x4_t v30 = vmaxnmq_f32(v29, (float32x4_t)0);
  float32x4_t v31 = vmulq_f32(v30, v30);
  v31.i32[3] = 0;
  float32x4_t v32 = vmaxnmq_f32(v31, (float32x4_t)0);
  v32.i32[3] = 0;
  *(void *)&double result = vaddq_f32(vminnmq_f32(a1, (float32x4_t)0), vaddq_f32(v20, vminnmq_f32(v32, (float32x4_t)xmmword_1939508C0))).u64[0];
  return result;
}

__n128 cikernel::_lumaMap(uint64x2_t *a1, float32x4_t a2, float64x2_t a3, double a4, double a5, int8x16_t a6, int8x16_t a7, int8x16_t a8)
{
  unsigned __int32 v11 = a2.u32[3];
  int8x16_t v8 = (int8x16_t)vmulq_f32(a2, (float32x4_t)xmmword_193950AB0);
  float32x2_t v9 = (float32x2_t)vextq_s8(v8, v8, 8uLL).u64[0];
  v9.f32[0] = vmlas_n_f32(*((float *)a3.f64 + 1), vaddv_f32(vadd_f32(*(float32x2_t *)v8.i8, v9)), *(float *)a3.f64);
  result.n128_f64[0] = CI::BitmapSampler::read(a1, COERCE_DOUBLE(v9.u32[0] | 0x3F00000000000000), a3, *(double *)&v9, *(double *)v8.i64, a6, a7, a8);
  result.n128_u32[3] = v11;
  return result;
}

void CI::f4_s_sr2d_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = *(void *)(a1 + 48);
  unsigned __int32 v11 = *(double (**)(uint64_t, __n128, double))(a1 + 24);
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  uint64_t v14 = *((void *)a2 + 8 * *(void *)(v10 + 32));
  int v15 = *(_DWORD *)(v10 + 64);
  uint64_t v16 = *(void *)(v10 + 56);
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 80)), a2);
  }
  float32x4_t v17 = (double *)(a3 + 16 * v16);
  if (v15 != 5) {
    float32x4_t v17 = (double *)((char *)a2 + 64 * v16);
  }
  double v18 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    double v18 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v19 = v11(v14, *v18, *v17);
  *(_OWORD *)(a3 + 16 * a7) = v19;
}

CIImage *scaleH(CIImage *a1, double a2)
{
  v27[2] = *MEMORY[0x1E4F143B8];
  if (a2 <= 1.0) {
    double v4 = 0.0;
  }
  else {
    double v4 = 1.0;
  }
  double v5 = +[CIVector vectorWithX:1.0 / a2 Y:1.0 Z:1.0 W:0.0];
  [(CIImage *)a1 extent];
  CGFloat x = v28.origin.x;
  CGFloat y = v28.origin.y;
  CGFloat width = v28.size.width;
  CGFloat height = v28.size.height;
  if (CGRectIsInfinite(v28))
  {
    *(int64x2_t *)&v19.var0 = vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    *(int64x2_t *)&v19.var2 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  }
  else
  {
    v29.origin.CGFloat x = x;
    v29.origin.CGFloat y = y;
    v29.size.CGFloat width = width;
    v29.size.CGFloat height = height;
    if (CGRectIsNull(v29))
    {
      *(int64x2_t *)&v19.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
      v19.var2 = 0.0;
      v19.var3 = 0.0;
    }
    else
    {
      v19.var0 = x;
      v19.unsigned int var1 = y;
      v19.var2 = width;
      v19.var3 = height;
    }
  }
  Rectangle::inset(&v19, -v4, -0.0, (uint64_t)&v20);
  if (fabs(v20.f64[0]) == INFINITY || fabs(v20.f64[1]) == INFINITY)
  {
    *(int64x2_t *)&v22.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
    v22.var2 = 0.0;
    v22.var3 = 0.0;
  }
  else
  {
    float64x2_t v16 = (float64x2_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    float64x2_t v17 = (float64x2_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    if (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_f64(v20, v17), (int32x4_t)vceqq_f64(v21, v16))))))
    {
      v22.var0 = v20.f64[0] * a2;
      v22.unsigned int var1 = v20.f64[1];
      v22.var2 = a2 * v21.f64[0];
      v22.var3 = v21.f64[1];
    }
    else
    {
      *(float64x2_t *)&v22.var0 = v17;
      *(float64x2_t *)&v22.var2 = v16;
    }
  }
  uint64_t v10 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_maxScale, Rectangle::integralize(&v22, 0.0001, (uint64_t)&v23).f64[0]);
  double v11 = v23;
  double v12 = v24;
  double v14 = v25;
  double v13 = v26;
  if (v23 == -8.98846567e307 && v24 == -8.98846567e307 && v25 == 1.79769313e308 && v26 == 1.79769313e308)
  {
    double v11 = *MEMORY[0x1E4F1DB10];
    double v12 = *(double *)(MEMORY[0x1E4F1DB10] + 8);
    double v14 = *(double *)(MEMORY[0x1E4F1DB10] + 16);
    double v13 = *(double *)(MEMORY[0x1E4F1DB10] + 24);
  }
  v18[0] = MEMORY[0x1E4F143A8];
  v18[1] = 3221225472;
  void v18[2] = ___ZL6scaleHP7CIImaged_block_invoke;
  void v18[3] = &__block_descriptor_40_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
  *(double *)&v18[4] = a2;
  v27[0] = a1;
  v27[1] = v5;
  return -[CIKernel applyWithExtent:roiCallback:arguments:](v10, "applyWithExtent:roiCallback:arguments:", v18, [MEMORY[0x1E4F1C978] arrayWithObjects:v27 count:2], v11, v12, v14, v13);
}

CIImage *scaleV(CIImage *a1, double a2)
{
  v27[2] = *MEMORY[0x1E4F143B8];
  if (a2 <= 1.0) {
    double v4 = 0.0;
  }
  else {
    double v4 = 1.0;
  }
  double v5 = +[CIVector vectorWithX:1.0 Y:1.0 / a2 Z:0.0 W:1.0];
  [(CIImage *)a1 extent];
  CGFloat x = v28.origin.x;
  CGFloat y = v28.origin.y;
  CGFloat width = v28.size.width;
  CGFloat height = v28.size.height;
  if (CGRectIsInfinite(v28))
  {
    *(int64x2_t *)&v19.var0 = vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    *(int64x2_t *)&v19.var2 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  }
  else
  {
    v29.origin.CGFloat x = x;
    v29.origin.CGFloat y = y;
    v29.size.CGFloat width = width;
    v29.size.CGFloat height = height;
    if (CGRectIsNull(v29))
    {
      *(int64x2_t *)&v19.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
      v19.var2 = 0.0;
      v19.var3 = 0.0;
    }
    else
    {
      v19.var0 = x;
      v19.unsigned int var1 = y;
      v19.var2 = width;
      v19.var3 = height;
    }
  }
  Rectangle::inset(&v19, -0.0, -v4, (uint64_t)&v20);
  if (fabs(v20.f64[0]) == INFINITY || fabs(v20.f64[1]) == INFINITY)
  {
    *(int64x2_t *)&v22.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
    v22.var2 = 0.0;
    v22.var3 = 0.0;
  }
  else
  {
    float64x2_t v16 = (float64x2_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    float64x2_t v17 = (float64x2_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    if (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_f64(v20, v17), (int32x4_t)vceqq_f64(v21, v16))))))
    {
      v22.var0 = v20.f64[0];
      v22.unsigned int var1 = v20.f64[1] * a2;
      v22.var2 = v21.f64[0];
      v22.var3 = vmuld_lane_f64(a2, v21, 1);
    }
    else
    {
      *(float64x2_t *)&v22.var0 = v17;
      *(float64x2_t *)&v22.var2 = v16;
    }
  }
  uint64_t v10 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_maxScale, Rectangle::integralize(&v22, 0.0001, (uint64_t)&v23).f64[0]);
  double v11 = v23;
  double v12 = v24;
  double v14 = v25;
  double v13 = v26;
  if (v23 == -8.98846567e307 && v24 == -8.98846567e307 && v25 == 1.79769313e308 && v26 == 1.79769313e308)
  {
    double v11 = *MEMORY[0x1E4F1DB10];
    double v12 = *(double *)(MEMORY[0x1E4F1DB10] + 8);
    double v14 = *(double *)(MEMORY[0x1E4F1DB10] + 16);
    double v13 = *(double *)(MEMORY[0x1E4F1DB10] + 24);
  }
  v18[0] = MEMORY[0x1E4F143A8];
  v18[1] = 3221225472;
  void v18[2] = ___ZL6scaleVP7CIImaged_block_invoke;
  void v18[3] = &__block_descriptor_40_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
  *(double *)&v18[4] = a2;
  v27[0] = a1;
  v27[1] = v5;
  return -[CIKernel applyWithExtent:roiCallback:arguments:](v10, "applyWithExtent:roiCallback:arguments:", v18, [MEMORY[0x1E4F1C978] arrayWithObjects:v27 count:2], v11, v12, v14, v13);
}

void ___ZL9downBy2x2P7CIImage_block_invoke(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4)
{
  if (CGRectIsInfinite(*(CGRect *)&a1))
  {
    double v8 = -8.98846567e307;
    double v9 = 1.79769313e308;
    double v10 = 1.79769313e308;
    double v11 = -8.98846567e307;
  }
  else
  {
    v20.origin.CGFloat x = a1;
    v20.origin.CGFloat y = a2;
    v20.size.CGFloat width = a3;
    v20.size.CGFloat height = a4;
    BOOL IsNull = CGRectIsNull(v20);
    double v11 = INFINITY;
    if (IsNull) {
      double v9 = 0.0;
    }
    else {
      double v9 = a3;
    }
    if (IsNull) {
      double v10 = 0.0;
    }
    else {
      double v10 = a4;
    }
    if (IsNull) {
      double v8 = INFINITY;
    }
    else {
      double v8 = a2;
    }
    if (!IsNull) {
      double v11 = a1;
    }
  }
  double v13 = fabs(v8);
  if (fabs(v11) == INFINITY || v13 == INFINITY)
  {
    *(int64x2_t *)&v18.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
    *(_OWORD *)&v18.var2 = 0uLL;
  }
  else if (v11 == -8.98846567e307 && v8 == -8.98846567e307 && v9 == 1.79769313e308 && v10 == 1.79769313e308)
  {
    *(int64x2_t *)&v18.var0 = vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    *(int64x2_t *)&v18.var2 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  }
  else
  {
    v18.var0 = v11 + v11;
    v18.unsigned int var1 = v8 + v8;
    v18.var2 = v9 + v9;
    v18.var3 = v10 + v10;
  }
  Rectangle::integralize(&v18, 0.0001, (uint64_t)&v19);
}

double cikernel::_maxScaleDown2x2(cikernel *this, SamplerObj *a2)
{
  DC = (float32x2_t *)CI::getDC(this);
  float32x2_t v4 = vadd_f32(*DC, *DC);
  float32x2_t v5 = vadd_f32(v4, (float32x2_t)0x3F0000003F000000);
  *(float *)&double v6 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v5, 1), *((float *)this + 4), v5.f32[0]);
  LODWORD(v7) = *((_DWORD *)this + 7);
  v8.i32[0] = *((_DWORD *)this + 9);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *((float *)this + 6) + *(float *)&v6;
  *(float *)v10.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v5, v10, v6, v7, v9, v8, v11);
  float32x4_t v37 = v12;
  *(float32x2_t *)v12.f32 = vadd_f32(v4, (float32x2_t)0xBF0000003F000000);
  *(float *)&double v13 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v12.f32, 1), *((float *)this + 4), v12.f32[0]);
  LODWORD(v14) = *((_DWORD *)this + 7);
  v15.i32[0] = *((_DWORD *)this + 9);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v12.f32, 1), *(float *)&v14, v12.f32[0]);
  v12.f32[0] = *((float *)this + 6) + *(float *)&v13;
  *(float *)v17.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v12.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v12.i64, v17, v13, v14, v16, v15, v18);
  float32x4_t v36 = v19;
  *(float32x2_t *)v19.f32 = vadd_f32(v4, (float32x2_t)0x3F000000BF000000);
  *(float *)&double v20 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v19.f32, 1), *((float *)this + 4), v19.f32[0]);
  LODWORD(v21) = *((_DWORD *)this + 7);
  v22.i32[0] = *((_DWORD *)this + 9);
  *(float *)v23.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v19.f32, 1), *(float *)&v21, v19.f32[0]);
  v19.f32[0] = *((float *)this + 6) + *(float *)&v20;
  *(float *)v24.f64 = *(float *)v22.i32 + *(float *)v23.i32;
  v19.f32[1] = *(float *)v22.i32 + *(float *)v23.i32;
  *(double *)v26.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v19.i64, v24, v20, v21, v23, v22, v25);
  float32x4_t v35 = v26;
  *(float32x2_t *)v26.f32 = vadd_f32(v4, (float32x2_t)0xBF000000BF000000);
  *(float *)&double v27 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v26.f32, 1), *((float *)this + 4), v26.f32[0]);
  LODWORD(v28) = *((_DWORD *)this + 7);
  v29.i32[0] = *((_DWORD *)this + 9);
  *(float *)v30.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v26.f32, 1), *(float *)&v28, v26.f32[0]);
  v26.f32[0] = *((float *)this + 6) + *(float *)&v27;
  *(float *)v31.f64 = *(float *)v29.i32 + *(float *)v30.i32;
  v26.f32[1] = *(float *)v29.i32 + *(float *)v30.i32;
  *(double *)v33.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v26.i64, v31, v27, v28, v30, v29, v32);
  *(void *)&double result = vmaxnmq_f32(vmaxnmq_f32(v37, v36), vmaxnmq_f32(v35, v33)).u64[0];
  return result;
}

void ___ZL8downBy2HP7CIImage_block_invoke_0(double a1, double a2, double a3, double a4)
{
}

void roiDown2(CGRect a1, int a2)
{
  double height = a1.size.height;
  double width = a1.size.width;
  double y = a1.origin.y;
  double x = a1.origin.x;
  if (CGRectIsInfinite(a1))
  {
    double v7 = -8.98846567e307;
    double v8 = 1.79769313e308;
    double v9 = 1.79769313e308;
    double v10 = -8.98846567e307;
  }
  else
  {
    v21.origin.double x = x;
    v21.origin.double y = y;
    v21.size.double width = width;
    v21.size.double height = height;
    BOOL IsNull = CGRectIsNull(v21);
    double v10 = INFINITY;
    if (IsNull) {
      double v8 = 0.0;
    }
    else {
      double v8 = width;
    }
    if (IsNull) {
      double v9 = 0.0;
    }
    else {
      double v9 = height;
    }
    if (IsNull) {
      double v7 = INFINITY;
    }
    else {
      double v7 = y;
    }
    if (!IsNull) {
      double v10 = x;
    }
  }
  double v12 = 1.0;
  if (a2) {
    double v13 = 2.0;
  }
  else {
    double v13 = 1.0;
  }
  if (!a2) {
    double v12 = 2.0;
  }
  double v14 = fabs(v7);
  if (fabs(v10) == INFINITY || v14 == INFINITY)
  {
    *(int64x2_t *)&v19.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
    *(_OWORD *)&v19.var2 = 0uLL;
  }
  else if (v10 == -8.98846567e307 && v7 == -8.98846567e307 && v8 == 1.79769313e308 && v9 == 1.79769313e308)
  {
    *(int64x2_t *)&v19.var0 = vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    *(int64x2_t *)&v19.var2 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  }
  else
  {
    v19.var0 = v13 * v10;
    v19.unsigned int var1 = v12 * v7;
    v19.var2 = v13 * v8;
    v19.var3 = v12 * v9;
  }
  Rectangle::integralize(&v19, 0.0001, (uint64_t)&v20);
}

double cikernel::_maxScaleDown2(uint64_t a1, float32x2_t a2)
{
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  __asm { FMOV            V1.2S, #1.0 }
  *(float32x2_t *)&v10.f64[0] = vadd_f32(a2, _D1);
  float32x2_t v11 = vmul_f32(*(float32x2_t *)&v10.f64[0], *DC);
  float32x2_t v12 = vmul_f32(a2, (float32x2_t)0x3F0000003F000000);
  float32x2_t v13 = vsub_f32(v11, v12);
  *(float *)&double v14 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v13, 1), *(float *)(a1 + 16), v13.f32[0]);
  LODWORD(v15) = *(_DWORD *)(a1 + 28);
  v16.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v13, 1), *(float *)&v15, v13.f32[0]);
  v13.f32[0] = *(float *)(a1 + 24) + *(float *)&v14;
  *(float *)v10.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v13.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v13, v10, v14, v15, v17, v16, v18);
  float32x4_t v28 = v19;
  *(float32x2_t *)v19.f32 = vadd_f32(v12, v11);
  *(float *)&double v20 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v19.f32, 1), *(float *)(a1 + 16), v19.f32[0]);
  LODWORD(v21) = *(_DWORD *)(a1 + 28);
  v22.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v23.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v19.f32, 1), *(float *)&v21, v19.f32[0]);
  v19.f32[0] = *(float *)(a1 + 24) + *(float *)&v20;
  *(float *)v24.f64 = *(float *)v22.i32 + *(float *)v23.i32;
  v19.f32[1] = *(float *)v22.i32 + *(float *)v23.i32;
  *(double *)v26.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v19.i64, v24, v20, v21, v23, v22, v25);
  *(void *)&double result = vmaxnmq_f32(v28, v26).u64[0];
  return result;
}

void ___ZL8downBy2VP7CIImage_block_invoke_0(double a1, double a2, double a3, double a4)
{
}

void ___ZL6scaleHP7CIImaged_block_invoke(uint64_t a1, double a2, double a3, double a4, double a5)
{
  float v5 = *(double *)(a1 + 32);
  roiDownK(*(CGRect *)&a2, v5, 1);
}

void roiDownK(CGRect a1, float a2, int a3)
{
  double height = a1.size.height;
  double width = a1.size.width;
  double y = a1.origin.y;
  double x = a1.origin.x;
  if (CGRectIsInfinite(a1))
  {
    double v9 = -8.98846567e307;
    double v10 = 1.79769313e308;
    double v11 = 1.79769313e308;
    double v12 = -8.98846567e307;
  }
  else
  {
    v18.origin.double x = x;
    v18.origin.double y = y;
    v18.size.double width = width;
    v18.size.double height = height;
    BOOL IsNull = CGRectIsNull(v18);
    double v12 = INFINITY;
    if (IsNull) {
      double v10 = 0.0;
    }
    else {
      double v10 = width;
    }
    if (IsNull) {
      double v11 = 0.0;
    }
    else {
      double v11 = height;
    }
    if (IsNull) {
      double v9 = INFINITY;
    }
    else {
      double v9 = y;
    }
    if (!IsNull) {
      double v12 = x;
    }
  }
  double v14 = 1.0 / a2;
  if (a3) {
    double v15 = 1.0 / a2;
  }
  else {
    double v15 = 1.0;
  }
  if (a3) {
    double v14 = 1.0;
  }
  if (fabs(v12) == INFINITY || fabs(v9) == INFINITY)
  {
    *(int64x2_t *)&v16.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
    *(_OWORD *)&v16.var2 = 0uLL;
  }
  else if (v12 == -8.98846567e307 && v9 == -8.98846567e307 && v10 == 1.79769313e308 && v11 == 1.79769313e308)
  {
    *(int64x2_t *)&v16.var0 = vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    *(int64x2_t *)&v16.var2 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  }
  else
  {
    v16.var0 = v12 * v15;
    v16.unsigned int var1 = v9 * v14;
    v16.var2 = v10 * v15;
    v16.var3 = v11 * v14;
  }
  Rectangle::integralize(&v16, 0.0001, (uint64_t)&v17);
}

double cikernel::_maxScale(uint64_t a1, int8x16_t a2)
{
  float32x2_t v3 = vmul_f32(*(float32x2_t *)a2.i8, *(float32x2_t *)CI::getDC((CI *)a1));
  *(float32x2_t *)&v4.f64[0] = vadd_f32(vrndm_f32(vadd_f32(v3, (float32x2_t)0xBF000000BF000000)), (float32x2_t)0x3F0000003F000000);
  float32x2_t v5 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  __asm { FMOV            V3.2S, #1.0 }
  float32x2_t v11 = vsub_f32(_D3, v5);
  float32x2_t v12 = vmla_f32(vmul_f32(v11, v3), v5, *(float32x2_t *)&v4.f64[0]);
  v11.f32[0] = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v12, 1), *(float *)(a1 + 16), v12.f32[0]);
  v13.i32[0] = *(_DWORD *)(a1 + 28);
  v14.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v12, 1), *(float *)v13.i32, v12.f32[0]);
  *(float32x2_t *)v16.i8 = vadd_f32(v5, v12);
  int8x16_t v25 = v16;
  *(float *)v16.i32 = *(float *)(a1 + 24) + v11.f32[0];
  *(float *)v4.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  *(float *)&v16.i32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)v17.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v16.i64, v4, *(double *)&v5, *(double *)&v11, v13, v15, v14);
  float32x4_t v27 = v17;
  HIDWORD(v18) = v25.i32[1];
  LODWORD(v18) = *(_DWORD *)(a1 + 28);
  v19.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)&double v20 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v25.i8, 1), *(float *)&v18, *(float *)v25.i32);
  v17.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v25.i8, 1), *(float *)(a1 + 16), *(float *)v25.i32);
  *(float *)v21.f64 = *(float *)v19.i32 + *(float *)&v20;
  v17.f32[1] = *(float *)v19.i32 + *(float *)&v20;
  *(double *)v23.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v17.i64, v21, v18, v20, v19, v25, v22);
  *(void *)&double result = vmaxnmq_f32(v27, v23).u64[0];
  return result;
}

float ___ZL6scaleVP7CIImaged_block_invoke(uint64_t a1, double a2, double a3, double a4, double a5)
{
  float v5 = *(double *)(a1 + 32);
  roiDownK(*(CGRect *)&a2, v5, 0);
  return result;
}

double cikernel::_maskToAlpha(int32x2_t a1)
{
  *(void *)&double result = vdupq_lane_s32(a1, 1).u64[0];
  return result;
}

double cikernel::_betterDown2(cikernel *this, SamplerObj *a2)
{
  DC = (float32x2_t *)CI::getDC(this);
  HIDWORD(v4.f64[0]) = 1065353216;
  float32x2_t v5 = vadd_f32(vadd_f32(*DC, *DC), (float32x2_t)0x3F80000000000000);
  *(float *)&double v6 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v5, 1), *((float *)this + 4), v5.f32[0]);
  LODWORD(v7) = *((_DWORD *)this + 7);
  v8.i32[0] = *((_DWORD *)this + 9);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *((float *)this + 6) + *(float *)&v6;
  *(float *)v4.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v11.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v5, v4, v6, v7, v9, v8, v10);
  float32x4_t v50 = v11;
  int8x16_t v13 = (float32x2_t *)CI::getDC(v12);
  HIDWORD(v14.f64[0]) = -1082130432;
  float32x2_t v15 = vadd_f32(vadd_f32(*v13, *v13), (float32x2_t)0xBF80000000000000);
  *(float *)&double v16 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v15, 1), *((float *)this + 4), v15.f32[0]);
  LODWORD(v17) = *((_DWORD *)this + 7);
  v18.i32[0] = *((_DWORD *)this + 9);
  *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v15, 1), *(float *)&v17, v15.f32[0]);
  v15.f32[0] = *((float *)this + 6) + *(float *)&v16;
  *(float *)v14.f64 = *(float *)v18.i32 + *(float *)v19.i32;
  v15.f32[1] = *(float *)v18.i32 + *(float *)v19.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v15, v14, v16, v17, v19, v18, v20);
  float32x4_t v49 = v21;
  float32x4_t v23 = (float32x2_t *)CI::getDC(v22);
  HIDWORD(v24.f64[0]) = 0;
  float32x2_t v25 = vadd_f32(vadd_f32(*v23, *v23), (float32x2_t)1065353216);
  *(float *)&double v26 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v25, 1), *((float *)this + 4), v25.f32[0]);
  LODWORD(v27) = *((_DWORD *)this + 7);
  v28.i32[0] = *((_DWORD *)this + 9);
  *(float *)v29.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v25, 1), *(float *)&v27, v25.f32[0]);
  v25.f32[0] = *((float *)this + 6) + *(float *)&v26;
  *(float *)v24.f64 = *(float *)v28.i32 + *(float *)v29.i32;
  v25.f32[1] = *(float *)v28.i32 + *(float *)v29.i32;
  *(double *)v31.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v25, v24, v26, v27, v29, v28, v30);
  float32x4_t v48 = v31;
  float32x4_t v33 = (float32x2_t *)CI::getDC(v32);
  HIDWORD(v34.f64[0]) = 0;
  float32x2_t v35 = vadd_f32(vadd_f32(*v33, *v33), (float32x2_t)3212836864);
  *(float *)&double v36 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v35, 1), *((float *)this + 4), v35.f32[0]);
  LODWORD(v37) = *((_DWORD *)this + 7);
  v38.i32[0] = *((_DWORD *)this + 9);
  *(float *)v39.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v35, 1), *(float *)&v37, v35.f32[0]);
  v35.f32[0] = *((float *)this + 6) + *(float *)&v36;
  *(float *)v34.f64 = *(float *)v38.i32 + *(float *)v39.i32;
  v35.f32[1] = *(float *)v38.i32 + *(float *)v39.i32;
  *(double *)v41.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v35, v34, v36, v37, v39, v38, v40);
  __asm { FMOV            V1.4S, #0.25 }
  *(void *)&double result = vmulq_f32(vaddq_f32(v48, vaddq_f32(vaddq_f32(v50, v49), v41)), _Q1).u64[0];
  return result;
}

double cikernel::_maskedVariableBlur(cikernel *this, SamplerObj *a2, SamplerObj *a3, SamplerObj *a4, SamplerObj *a5, SamplerObj *a6, SamplerObj *a7, SamplerObj *a8, float a9, SamplerObj *a10)
{
  DC = (float32x2_t *)CI::getDC(this);
  *(float32x2_t *)v20.i8 = *DC;
  int8x16_t v265 = v20;
  LODWORD(v21) = *((_DWORD *)this + 7);
  *(float *)&double v22 = *((float *)this + 6)
                 + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *DC, 1), *((float *)this + 4), COERCE_FLOAT(*DC));
  LODWORD(v23) = *((_DWORD *)this + 9);
  *(float *)v24.f64 = *(float *)&v23
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *DC, 1), *(float *)&v21, COERCE_FLOAT(*DC));
  HIDWORD(v22) = LODWORD(v24.f64[0]);
  double v27 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v22, v24, v21, v23, v20, v25, v26);
  float v28 = 1.0;
  if (*((float *)&v27 + 1) <= 1.0) {
    float v28 = *((float *)&v27 + 1);
  }
  if (*((float *)&v27 + 1) >= 0.0) {
    float v29 = v28;
  }
  else {
    float v29 = 0.0;
  }
  float v30 = log2((float)(v29 * a9) * 4.0 / 3.0);
  *(float *)v31.i32 = fmaxf(v30, 0.0);
  float v231 = *(float *)v31.i32;
  LODWORD(v32) = *((_DWORD *)a2 + 7);
  *(float *)&double v33 = *((float *)a2 + 6)
                 + vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 5), *(float32x2_t *)v265.i8, 1), *((float *)a2 + 4), *(float *)v265.i32);
  LODWORD(v34) = *((_DWORD *)a2 + 9);
  float v35 = floorf(*(float *)v31.i32);
  *(float *)v36.f64 = *(float *)&v34
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 8), *(float32x2_t *)v265.i8, 1), *(float *)&v32, *(float *)v265.i32);
  HIDWORD(v33) = LODWORD(v36.f64[0]);
  *(double *)v38.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a2 + 1), v33, v36, v32, v34, v31, v265, v37);
  float32x4_t v230 = v38;
  *(float32x2_t *)v38.f32 = vadd_f32(vmul_f32(*(float32x2_t *)v265.i8, (float32x2_t)0x3F0000003F000000), (float32x2_t)0xBF000000BF000000);
  *(float32x2_t *)&v39.f64[0] = vrndm_f32(*(float32x2_t *)v38.f32);
  __asm { FMOV            V13.2S, #1.0 }
  float32x2_t v45 = vadd_f32(vsub_f32(*(float32x2_t *)&v39.f64[0], *(float32x2_t *)v38.f32), _D13);
  *(float32x2_t *)v38.f32 = vsub_f32(*(float32x2_t *)v38.f32, *(float32x2_t *)&v39.f64[0]);
  float32x2_t v46 = (float32x2_t)vdup_n_s32(0x3EAAAAABu);
  float32x2_t v47 = vmul_f32(v45, (float32x2_t)0x3F0000003F000000);
  *(float32x2_t *)v48.i8 = vmul_f32(v45, v47);
  float32x2_t v49 = (float32x2_t)vdup_n_s32(0x3E2AAAABu);
  *(float32x2_t *)v50.i8 = vadd_f32(vadd_f32(v47, vsub_f32(*(float32x2_t *)v48.i8, vmul_f32(v45, vmul_f32(v45, vmul_f32(v45, v46))))), v49);
  float32x2_t v51 = vsub_f32(_D13, *(float32x2_t *)v50.i8);
  *(float32x2_t *)v52.i8 = vadd_f32(vadd_f32(*(float32x2_t *)&v39.f64[0], vdiv_f32(vadd_f32(vadd_f32(v47, vsub_f32(*(float32x2_t *)v48.i8, vmul_f32(v45, *(float32x2_t *)v48.i8))), v49), *(float32x2_t *)v50.i8)), (float32x2_t)0xBF000000BF000000);
  *(float32x2_t *)&v53.f64[0] = vmul_f32(*(float32x2_t *)v38.f32, *(float32x2_t *)v38.f32);
  __asm
  {
    FMOV            V9.2S, #6.0
    FMOV            V8.2S, #1.5
  }
  float32x2_t v251 = vadd_f32(vadd_f32(*(float32x2_t *)&v39.f64[0], vdiv_f32(vdiv_f32(vmul_f32(*(float32x2_t *)v38.f32, *(float32x2_t *)&v53.f64[0]), _D9), v51)), _D8);
  float32x2_t v258 = v51;
  int8x16_t v232 = v52;
  int8x16_t v244 = v50;
  v38.f32[0] = *((float *)a3 + 6)
             + vmlas_n_f32(vmuls_lane_f32(*((float *)a3 + 5), *(float32x2_t *)v52.i8, 1), *((float *)a3 + 4), *(float *)v52.i32);
  v51.i32[0] = *((_DWORD *)a3 + 9);
  *(float *)v53.f64 = vmuls_lane_f32(*(float *)v50.i32, *(float32x2_t *)v50.i8, 1);
  float64x2_t v220 = v53;
  *(float *)v39.f64 = v51.f32[0]
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)a3 + 8), *(float32x2_t *)v52.i8, 1), *((float *)a3 + 7), *(float *)v52.i32);
  v38.i32[1] = LODWORD(v39.f64[0]);
  *(double *)v56.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a3 + 1), *(double *)v38.i64, v39, v53.f64[0], *(double *)&v51, v52, v48, v50);
  float64x2_t v57 = v220;
  float32x4_t v58 = vmulq_n_f32(v56, *(float *)v220.f64);
  v56.f32[0] = *((float *)a3 + 6)
             + vmlas_n_f32(vmuls_lane_f32(*((float *)a3 + 5), *(float32x2_t *)v232.i8, 1), *((float *)a3 + 4), v251.f32[0]);
  LODWORD(v59) = *((_DWORD *)a3 + 9);
  HIDWORD(v60) = v258.i32[1];
  *(float *)&double v60 = vmuls_lane_f32(v258.f32[0], *(float32x2_t *)v244.i8, 1);
  float v215 = *(float *)&v60;
  float32x4_t v221 = v58;
  *(float *)v57.f64 = *(float *)&v59
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)a3 + 8), *(float32x2_t *)v232.i8, 1), *((float *)a3 + 7), v251.f32[0]);
  v56.i32[1] = LODWORD(v57.f64[0]);
  *(double *)v62.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a3 + 1), *(double *)v56.i64, v57, v60, v59, v244, v232, v61);
  *(float *)&double v63 = vmlas_n_f32(vmuls_lane_f32(*((float *)a3 + 5), v251, 1), *((float *)a3 + 4), *(float *)v232.i32);
  v64.i32[0] = *((_DWORD *)a3 + 9);
  *(float *)v65.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)a3 + 8), v251, 1), *((float *)a3 + 7), *(float *)v232.i32);
  float32x4_t v233 = vaddq_f32(v221, vmulq_n_f32(v62, v215));
  v62.f32[0] = *((float *)a3 + 6) + *(float *)&v63;
  *(float *)v66.f64 = *(float *)v64.i32 + *(float *)v65.i32;
  v62.f32[1] = *(float *)v64.i32 + *(float *)v65.i32;
  *(double *)v67.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a3 + 1), *(double *)v62.i64, v66, v63, *(double *)v244.i64, v65, v64, (int8x16_t)v233);
  *(float *)&double v68 = vmlas_n_f32(vmuls_lane_f32(*((float *)a3 + 5), v251, 1), *((float *)a3 + 4), v251.f32[0]);
  v69.i32[0] = *((_DWORD *)a3 + 9);
  *(float *)v70.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)a3 + 8), v251, 1), *((float *)a3 + 7), v251.f32[0]);
  float32x4_t v252 = vaddq_f32(v233, vmulq_n_f32(v67, vmuls_lane_f32(*(float *)v244.i32, v258, 1)));
  v67.f32[0] = *((float *)a3 + 6) + *(float *)&v68;
  *(float *)v71.f64 = *(float *)v69.i32 + *(float *)v70.i32;
  v67.f32[1] = *(float *)v69.i32 + *(float *)v70.i32;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a3 + 1), *(double *)v67.i64, v71, v68, *(double *)v233.i64, v70, v69, (int8x16_t)v252);
  float32x4_t v274 = vaddq_f32(v252, vmulq_n_f32(_Q0, vmuls_lane_f32(v258.f32[0], v258, 1)));
  __asm { FMOV            V0.2S, #0.25 }
  *(void *)&v73.f64[1] = v265.i64[1];
  *(float32x2_t *)_Q0.f32 = vadd_f32(vmul_f32(*(float32x2_t *)v265.i8, *(float32x2_t *)_Q0.f32), (float32x2_t)0xBF000000BF000000);
  *(float32x2_t *)&v73.f64[0] = vrndm_f32(*(float32x2_t *)_Q0.f32);
  float32x2_t v74 = vadd_f32(vsub_f32(*(float32x2_t *)&v73.f64[0], *(float32x2_t *)_Q0.f32), _D13);
  *(float32x2_t *)_Q0.f32 = vsub_f32(*(float32x2_t *)_Q0.f32, *(float32x2_t *)&v73.f64[0]);
  float32x2_t v75 = vmul_f32(v74, (float32x2_t)0x3F0000003F000000);
  *(float32x2_t *)v76.i8 = vmul_f32(v74, v75);
  *(float32x2_t *)v77.i8 = vadd_f32(vadd_f32(v75, vsub_f32(*(float32x2_t *)v76.i8, vmul_f32(v74, vmul_f32(v74, vmul_f32(v74, v46))))), v49);
  float32x2_t v78 = vsub_f32(_D13, *(float32x2_t *)v77.i8);
  *(float32x2_t *)v79.i8 = vadd_f32(vadd_f32(*(float32x2_t *)&v73.f64[0], vdiv_f32(vadd_f32(vadd_f32(v75, vsub_f32(*(float32x2_t *)v76.i8, vmul_f32(v74, *(float32x2_t *)v76.i8))), v49), *(float32x2_t *)v77.i8)), (float32x2_t)0xBF000000BF000000);
  *(float32x2_t *)&v80.f64[0] = vmul_f32(*(float32x2_t *)_Q0.f32, *(float32x2_t *)_Q0.f32);
  *(float32x2_t *)v252.f32 = vadd_f32(vadd_f32(*(float32x2_t *)&v73.f64[0], vdiv_f32(vdiv_f32(vmul_f32(*(float32x2_t *)_Q0.f32, *(float32x2_t *)&v80.f64[0]), _D9), v78)), _D8);
  float32x2_t v259 = v78;
  int8x16_t v234 = v79;
  int8x16_t v245 = v77;
  _Q0.f32[0] = *((float *)a4 + 6)
             + vmlas_n_f32(vmuls_lane_f32(*((float *)a4 + 5), *(float32x2_t *)v79.i8, 1), *((float *)a4 + 4), *(float *)v79.i32);
  v78.i32[0] = *((_DWORD *)a4 + 9);
  *(float *)v80.f64 = vmuls_lane_f32(*(float *)v77.i32, *(float32x2_t *)v77.i8, 1);
  float64x2_t v222 = v80;
  *(float *)v73.f64 = v78.f32[0]
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)a4 + 8), *(float32x2_t *)v79.i8, 1), *((float *)a4 + 7), *(float *)v79.i32);
  _Q0.i32[1] = LODWORD(v73.f64[0]);
  *(double *)v81.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a4 + 1), *(double *)_Q0.i64, v73, v80.f64[0], *(double *)&v78, v79, v76, v77);
  float64x2_t v82 = v222;
  float32x4_t v83 = vmulq_n_f32(v81, *(float *)v222.f64);
  v81.f32[0] = *((float *)a4 + 6)
             + vmlas_n_f32(vmuls_lane_f32(*((float *)a4 + 5), *(float32x2_t *)v234.i8, 1), *((float *)a4 + 4), v252.f32[0]);
  LODWORD(v84) = *((_DWORD *)a4 + 9);
  HIDWORD(v85) = v259.i32[1];
  *(float *)&double v85 = vmuls_lane_f32(v259.f32[0], *(float32x2_t *)v245.i8, 1);
  float v216 = *(float *)&v85;
  float32x4_t v223 = v83;
  *(float *)v82.f64 = *(float *)&v84
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)a4 + 8), *(float32x2_t *)v234.i8, 1), *((float *)a4 + 7), v252.f32[0]);
  v81.i32[1] = LODWORD(v82.f64[0]);
  *(double *)v87.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a4 + 1), *(double *)v81.i64, v82, v85, v84, v245, v234, v86);
  *(float *)&double v88 = vmlas_n_f32(vmuls_lane_f32(*((float *)a4 + 5), *(float32x2_t *)v252.f32, 1), *((float *)a4 + 4), *(float *)v234.i32);
  v89.i32[0] = *((_DWORD *)a4 + 9);
  *(float *)v90.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)a4 + 8), *(float32x2_t *)v252.f32, 1), *((float *)a4 + 7), *(float *)v234.i32);
  float32x4_t v235 = vaddq_f32(v223, vmulq_n_f32(v87, v216));
  v87.f32[0] = *((float *)a4 + 6) + *(float *)&v88;
  *(float *)v91.f64 = *(float *)v89.i32 + *(float *)v90.i32;
  v87.f32[1] = *(float *)v89.i32 + *(float *)v90.i32;
  *(double *)v92.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a4 + 1), *(double *)v87.i64, v91, v88, *(double *)v245.i64, v90, v89, (int8x16_t)v235);
  *(float *)&double v93 = vmlas_n_f32(vmuls_lane_f32(*((float *)a4 + 5), *(float32x2_t *)v252.f32, 1), *((float *)a4 + 4), v252.f32[0]);
  v94.i32[0] = *((_DWORD *)a4 + 9);
  *(float *)v95.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)a4 + 8), *(float32x2_t *)v252.f32, 1), *((float *)a4 + 7), v252.f32[0]);
  float32x4_t v253 = vaddq_f32(v235, vmulq_n_f32(v92, vmuls_lane_f32(*(float *)v245.i32, v259, 1)));
  v92.f32[0] = *((float *)a4 + 6) + *(float *)&v93;
  *(float *)v96.f64 = *(float *)v94.i32 + *(float *)v95.i32;
  v92.f32[1] = *(float *)v94.i32 + *(float *)v95.i32;
  *(double *)v97.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a4 + 1), *(double *)v92.i64, v96, v93, *(double *)v235.i64, v95, v94, (int8x16_t)v253);
  float32x4_t v273 = vaddq_f32(v253, vmulq_n_f32(v97, vmuls_lane_f32(v259.f32[0], v259, 1)));
  *(void *)&v98.f64[1] = v265.i64[1];
  *(float32x2_t *)v97.f32 = vadd_f32(vmul_f32(*(float32x2_t *)v265.i8, (float32x2_t)0x3E0000003E000000), (float32x2_t)0xBF000000BF000000);
  *(float32x2_t *)&v98.f64[0] = vrndm_f32(*(float32x2_t *)v97.f32);
  float32x2_t v99 = vadd_f32(vsub_f32(*(float32x2_t *)&v98.f64[0], *(float32x2_t *)v97.f32), _D13);
  *(float32x2_t *)v97.f32 = vsub_f32(*(float32x2_t *)v97.f32, *(float32x2_t *)&v98.f64[0]);
  float32x2_t v100 = vmul_f32(v99, (float32x2_t)0x3F0000003F000000);
  *(float32x2_t *)v101.i8 = vmul_f32(v99, v100);
  *(float32x2_t *)v102.i8 = vadd_f32(vadd_f32(v100, vsub_f32(*(float32x2_t *)v101.i8, vmul_f32(v99, vmul_f32(v99, vmul_f32(v99, v46))))), v49);
  float32x2_t v103 = vsub_f32(_D13, *(float32x2_t *)v102.i8);
  *(float32x2_t *)v104.i8 = vadd_f32(vadd_f32(*(float32x2_t *)&v98.f64[0], vdiv_f32(vadd_f32(vadd_f32(v100, vsub_f32(*(float32x2_t *)v101.i8, vmul_f32(v99, *(float32x2_t *)v101.i8))), v49), *(float32x2_t *)v102.i8)), (float32x2_t)0xBF000000BF000000);
  *(float32x2_t *)&v105.f64[0] = vmul_f32(*(float32x2_t *)v97.f32, *(float32x2_t *)v97.f32);
  *(float32x2_t *)v253.f32 = vadd_f32(vadd_f32(*(float32x2_t *)&v98.f64[0], vdiv_f32(vdiv_f32(vmul_f32(*(float32x2_t *)v97.f32, *(float32x2_t *)&v105.f64[0]), _D9), v103)), _D8);
  float32x2_t v260 = v103;
  int8x16_t v236 = v104;
  int8x16_t v246 = v102;
  v97.f32[0] = *((float *)a5 + 6)
             + vmlas_n_f32(vmuls_lane_f32(*((float *)a5 + 5), *(float32x2_t *)v104.i8, 1), *((float *)a5 + 4), *(float *)v104.i32);
  v103.i32[0] = *((_DWORD *)a5 + 9);
  *(float *)v105.f64 = vmuls_lane_f32(*(float *)v102.i32, *(float32x2_t *)v102.i8, 1);
  float64x2_t v224 = v105;
  *(float *)v98.f64 = v103.f32[0]
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)a5 + 8), *(float32x2_t *)v104.i8, 1), *((float *)a5 + 7), *(float *)v104.i32);
  v97.i32[1] = LODWORD(v98.f64[0]);
  *(double *)v106.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a5 + 1), *(double *)v97.i64, v98, v105.f64[0], *(double *)&v103, v104, v101, v102);
  float64x2_t v107 = v224;
  float32x4_t v108 = vmulq_n_f32(v106, *(float *)v224.f64);
  v106.f32[0] = *((float *)a5 + 6)
              + vmlas_n_f32(vmuls_lane_f32(*((float *)a5 + 5), *(float32x2_t *)v236.i8, 1), *((float *)a5 + 4), v253.f32[0]);
  LODWORD(v109) = *((_DWORD *)a5 + 9);
  HIDWORD(v110) = v260.i32[1];
  *(float *)&double v110 = vmuls_lane_f32(v260.f32[0], *(float32x2_t *)v246.i8, 1);
  float v217 = *(float *)&v110;
  float32x4_t v225 = v108;
  *(float *)v107.f64 = *(float *)&v109
                     + vmlas_n_f32(vmuls_lane_f32(*((float *)a5 + 8), *(float32x2_t *)v236.i8, 1), *((float *)a5 + 7), v253.f32[0]);
  v106.i32[1] = LODWORD(v107.f64[0]);
  *(double *)v112.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a5 + 1), *(double *)v106.i64, v107, v110, v109, v246, v236, v111);
  *(float *)&double v113 = vmlas_n_f32(vmuls_lane_f32(*((float *)a5 + 5), *(float32x2_t *)v253.f32, 1), *((float *)a5 + 4), *(float *)v236.i32);
  v114.i32[0] = *((_DWORD *)a5 + 9);
  *(float *)v115.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)a5 + 8), *(float32x2_t *)v253.f32, 1), *((float *)a5 + 7), *(float *)v236.i32);
  float32x4_t v237 = vaddq_f32(v225, vmulq_n_f32(v112, v217));
  v112.f32[0] = *((float *)a5 + 6) + *(float *)&v113;
  *(float *)v116.f64 = *(float *)v114.i32 + *(float *)v115.i32;
  v112.f32[1] = *(float *)v114.i32 + *(float *)v115.i32;
  *(double *)v117.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a5 + 1), *(double *)v112.i64, v116, v113, *(double *)v246.i64, v115, v114, (int8x16_t)v237);
  *(float *)&double v118 = vmlas_n_f32(vmuls_lane_f32(*((float *)a5 + 5), *(float32x2_t *)v253.f32, 1), *((float *)a5 + 4), v253.f32[0]);
  v119.i32[0] = *((_DWORD *)a5 + 9);
  *(float *)v120.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)a5 + 8), *(float32x2_t *)v253.f32, 1), *((float *)a5 + 7), v253.f32[0]);
  float32x4_t v254 = vaddq_f32(v237, vmulq_n_f32(v117, vmuls_lane_f32(*(float *)v246.i32, v260, 1)));
  v117.f32[0] = *((float *)a5 + 6) + *(float *)&v118;
  *(float *)v121.f64 = *(float *)v119.i32 + *(float *)v120.i32;
  v117.f32[1] = *(float *)v119.i32 + *(float *)v120.i32;
  *(double *)v122.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a5 + 1), *(double *)v117.i64, v121, v118, *(double *)v237.i64, v120, v119, (int8x16_t)v254);
  float32x4_t v272 = vaddq_f32(v254, vmulq_n_f32(v122, vmuls_lane_f32(v260.f32[0], v260, 1)));
  *(void *)&v123.f64[1] = v265.i64[1];
  *(float32x2_t *)v122.f32 = vadd_f32(vmul_f32(*(float32x2_t *)v265.i8, (float32x2_t)vdup_n_s32(0x3D800000u)), (float32x2_t)0xBF000000BF000000);
  *(float32x2_t *)&v123.f64[0] = vrndm_f32(*(float32x2_t *)v122.f32);
  float32x2_t v124 = vadd_f32(vsub_f32(*(float32x2_t *)&v123.f64[0], *(float32x2_t *)v122.f32), _D13);
  *(float32x2_t *)v122.f32 = vsub_f32(*(float32x2_t *)v122.f32, *(float32x2_t *)&v123.f64[0]);
  float32x2_t v125 = vmul_f32(v124, (float32x2_t)0x3F0000003F000000);
  *(float32x2_t *)v126.i8 = vmul_f32(v124, v125);
  *(float32x2_t *)v127.i8 = vadd_f32(vadd_f32(v125, vsub_f32(*(float32x2_t *)v126.i8, vmul_f32(v124, vmul_f32(v124, vmul_f32(v124, v46))))), v49);
  float32x2_t v128 = vsub_f32(_D13, *(float32x2_t *)v127.i8);
  *(float32x2_t *)v129.i8 = vadd_f32(vadd_f32(*(float32x2_t *)&v123.f64[0], vdiv_f32(vadd_f32(vadd_f32(v125, vsub_f32(*(float32x2_t *)v126.i8, vmul_f32(v124, *(float32x2_t *)v126.i8))), v49), *(float32x2_t *)v127.i8)), (float32x2_t)0xBF000000BF000000);
  *(float32x2_t *)&v130.f64[0] = vmul_f32(*(float32x2_t *)v122.f32, *(float32x2_t *)v122.f32);
  *(float32x2_t *)v254.f32 = vadd_f32(vadd_f32(*(float32x2_t *)&v123.f64[0], vdiv_f32(vdiv_f32(vmul_f32(*(float32x2_t *)v122.f32, *(float32x2_t *)&v130.f64[0]), _D9), v128)), _D8);
  float32x2_t v261 = v128;
  int8x16_t v238 = v129;
  int8x16_t v247 = v127;
  v122.f32[0] = *((float *)a6 + 6)
              + vmlas_n_f32(vmuls_lane_f32(*((float *)a6 + 5), *(float32x2_t *)v129.i8, 1), *((float *)a6 + 4), *(float *)v129.i32);
  v128.i32[0] = *((_DWORD *)a6 + 9);
  *(float *)v130.f64 = vmuls_lane_f32(*(float *)v127.i32, *(float32x2_t *)v127.i8, 1);
  float64x2_t v226 = v130;
  *(float *)v123.f64 = v128.f32[0]
                     + vmlas_n_f32(vmuls_lane_f32(*((float *)a6 + 8), *(float32x2_t *)v129.i8, 1), *((float *)a6 + 7), *(float *)v129.i32);
  v122.i32[1] = LODWORD(v123.f64[0]);
  *(double *)v131.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a6 + 1), *(double *)v122.i64, v123, v130.f64[0], *(double *)&v128, v129, v126, v127);
  float64x2_t v132 = v226;
  float32x4_t v133 = vmulq_n_f32(v131, *(float *)v226.f64);
  v131.f32[0] = *((float *)a6 + 6)
              + vmlas_n_f32(vmuls_lane_f32(*((float *)a6 + 5), *(float32x2_t *)v238.i8, 1), *((float *)a6 + 4), v254.f32[0]);
  LODWORD(v134) = *((_DWORD *)a6 + 9);
  HIDWORD(v135) = v261.i32[1];
  *(float *)&double v135 = vmuls_lane_f32(v261.f32[0], *(float32x2_t *)v247.i8, 1);
  float v218 = *(float *)&v135;
  float32x4_t v227 = v133;
  *(float *)v132.f64 = *(float *)&v134
                     + vmlas_n_f32(vmuls_lane_f32(*((float *)a6 + 8), *(float32x2_t *)v238.i8, 1), *((float *)a6 + 7), v254.f32[0]);
  v131.i32[1] = LODWORD(v132.f64[0]);
  *(double *)v137.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a6 + 1), *(double *)v131.i64, v132, v135, v134, v247, v238, v136);
  *(float *)&double v138 = vmlas_n_f32(vmuls_lane_f32(*((float *)a6 + 5), *(float32x2_t *)v254.f32, 1), *((float *)a6 + 4), *(float *)v238.i32);
  v139.i32[0] = *((_DWORD *)a6 + 9);
  *(float *)v140.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)a6 + 8), *(float32x2_t *)v254.f32, 1), *((float *)a6 + 7), *(float *)v238.i32);
  float32x4_t v239 = vaddq_f32(v227, vmulq_n_f32(v137, v218));
  v137.f32[0] = *((float *)a6 + 6) + *(float *)&v138;
  *(float *)v141.f64 = *(float *)v139.i32 + *(float *)v140.i32;
  v137.f32[1] = *(float *)v139.i32 + *(float *)v140.i32;
  *(double *)v142.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a6 + 1), *(double *)v137.i64, v141, v138, *(double *)v247.i64, v140, v139, (int8x16_t)v239);
  *(float *)&double v143 = vmlas_n_f32(vmuls_lane_f32(*((float *)a6 + 5), *(float32x2_t *)v254.f32, 1), *((float *)a6 + 4), v254.f32[0]);
  v144.i32[0] = *((_DWORD *)a6 + 9);
  *(float *)v145.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)a6 + 8), *(float32x2_t *)v254.f32, 1), *((float *)a6 + 7), v254.f32[0]);
  float32x4_t v255 = vaddq_f32(v239, vmulq_n_f32(v142, vmuls_lane_f32(*(float *)v247.i32, v261, 1)));
  v142.f32[0] = *((float *)a6 + 6) + *(float *)&v143;
  *(float *)v146.f64 = *(float *)v144.i32 + *(float *)v145.i32;
  v142.f32[1] = *(float *)v144.i32 + *(float *)v145.i32;
  *(double *)v147.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a6 + 1), *(double *)v142.i64, v146, v143, *(double *)v239.i64, v145, v144, (int8x16_t)v255);
  float32x4_t v271 = vaddq_f32(v255, vmulq_n_f32(v147, vmuls_lane_f32(v261.f32[0], v261, 1)));
  *(void *)&v148.f64[1] = v265.i64[1];
  *(float32x2_t *)v147.f32 = vadd_f32(vmul_f32(*(float32x2_t *)v265.i8, (float32x2_t)0x3D0000003D000000), (float32x2_t)0xBF000000BF000000);
  *(float32x2_t *)&v148.f64[0] = vrndm_f32(*(float32x2_t *)v147.f32);
  float32x2_t v149 = vadd_f32(vsub_f32(*(float32x2_t *)&v148.f64[0], *(float32x2_t *)v147.f32), _D13);
  *(float32x2_t *)v147.f32 = vsub_f32(*(float32x2_t *)v147.f32, *(float32x2_t *)&v148.f64[0]);
  float32x2_t v150 = vmul_f32(v149, (float32x2_t)0x3F0000003F000000);
  *(float32x2_t *)v151.i8 = vmul_f32(v149, v150);
  *(float32x2_t *)v152.i8 = vadd_f32(vadd_f32(v150, vsub_f32(*(float32x2_t *)v151.i8, vmul_f32(v149, vmul_f32(v149, vmul_f32(v149, v46))))), v49);
  float32x2_t v153 = vsub_f32(_D13, *(float32x2_t *)v152.i8);
  *(float32x2_t *)v154.i8 = vadd_f32(vadd_f32(*(float32x2_t *)&v148.f64[0], vdiv_f32(vadd_f32(vadd_f32(v150, vsub_f32(*(float32x2_t *)v151.i8, vmul_f32(v149, *(float32x2_t *)v151.i8))), v49), *(float32x2_t *)v152.i8)), (float32x2_t)0xBF000000BF000000);
  *(float32x2_t *)&v155.f64[0] = vmul_f32(*(float32x2_t *)v147.f32, *(float32x2_t *)v147.f32);
  *(float32x2_t *)v255.f32 = vadd_f32(vadd_f32(*(float32x2_t *)&v148.f64[0], vdiv_f32(vdiv_f32(vmul_f32(*(float32x2_t *)v147.f32, *(float32x2_t *)&v155.f64[0]), _D9), v153)), _D8);
  float32x2_t v262 = v153;
  int8x16_t v240 = v154;
  int8x16_t v248 = v152;
  v147.f32[0] = *((float *)a7 + 6)
              + vmlas_n_f32(vmuls_lane_f32(*((float *)a7 + 5), *(float32x2_t *)v154.i8, 1), *((float *)a7 + 4), *(float *)v154.i32);
  v153.i32[0] = *((_DWORD *)a7 + 9);
  *(float *)v155.f64 = vmuls_lane_f32(*(float *)v152.i32, *(float32x2_t *)v152.i8, 1);
  float64x2_t v228 = v155;
  *(float *)v148.f64 = v153.f32[0]
                     + vmlas_n_f32(vmuls_lane_f32(*((float *)a7 + 8), *(float32x2_t *)v154.i8, 1), *((float *)a7 + 7), *(float *)v154.i32);
  v147.i32[1] = LODWORD(v148.f64[0]);
  *(double *)v156.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a7 + 1), *(double *)v147.i64, v148, v155.f64[0], *(double *)&v153, v154, v151, v152);
  float64x2_t v157 = v228;
  float32x4_t v158 = vmulq_n_f32(v156, *(float *)v228.f64);
  v156.f32[0] = *((float *)a7 + 6)
              + vmlas_n_f32(vmuls_lane_f32(*((float *)a7 + 5), *(float32x2_t *)v240.i8, 1), *((float *)a7 + 4), v255.f32[0]);
  LODWORD(v159) = *((_DWORD *)a7 + 9);
  HIDWORD(v160) = v262.i32[1];
  *(float *)&double v160 = vmuls_lane_f32(v262.f32[0], *(float32x2_t *)v248.i8, 1);
  float v219 = *(float *)&v160;
  float32x4_t v229 = v158;
  *(float *)v157.f64 = *(float *)&v159
                     + vmlas_n_f32(vmuls_lane_f32(*((float *)a7 + 8), *(float32x2_t *)v240.i8, 1), *((float *)a7 + 7), v255.f32[0]);
  v156.i32[1] = LODWORD(v157.f64[0]);
  *(double *)v162.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a7 + 1), *(double *)v156.i64, v157, v160, v159, v248, v240, v161);
  *(float *)&double v163 = vmlas_n_f32(vmuls_lane_f32(*((float *)a7 + 5), *(float32x2_t *)v255.f32, 1), *((float *)a7 + 4), *(float *)v240.i32);
  v164.i32[0] = *((_DWORD *)a7 + 9);
  *(float *)v165.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)a7 + 8), *(float32x2_t *)v255.f32, 1), *((float *)a7 + 7), *(float *)v240.i32);
  float32x4_t v241 = vaddq_f32(v229, vmulq_n_f32(v162, v219));
  v162.f32[0] = *((float *)a7 + 6) + *(float *)&v163;
  *(float *)v166.f64 = *(float *)v164.i32 + *(float *)v165.i32;
  v162.f32[1] = *(float *)v164.i32 + *(float *)v165.i32;
  *(double *)v167.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a7 + 1), *(double *)v162.i64, v166, v163, *(double *)v248.i64, v165, v164, (int8x16_t)v241);
  *(float *)&double v168 = vmlas_n_f32(vmuls_lane_f32(*((float *)a7 + 5), *(float32x2_t *)v255.f32, 1), *((float *)a7 + 4), v255.f32[0]);
  v169.i32[0] = *((_DWORD *)a7 + 9);
  *(float *)v170.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)a7 + 8), *(float32x2_t *)v255.f32, 1), *((float *)a7 + 7), v255.f32[0]);
  float32x4_t v256 = vaddq_f32(v241, vmulq_n_f32(v167, vmuls_lane_f32(*(float *)v248.i32, v262, 1)));
  v167.f32[0] = *((float *)a7 + 6) + *(float *)&v168;
  *(float *)v171.f64 = *(float *)v169.i32 + *(float *)v170.i32;
  v167.f32[1] = *(float *)v169.i32 + *(float *)v170.i32;
  *(double *)v172.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a7 + 1), *(double *)v167.i64, v171, v168, *(double *)v241.i64, v170, v169, (int8x16_t)v256);
  float32x4_t v173 = vaddq_f32(v256, vmulq_n_f32(v172, vmuls_lane_f32(v262.f32[0], v262, 1)));
  float32x4_t v270 = v173;
  *(void *)&v174.f64[1] = v265.i64[1];
  *(float32x2_t *)v173.f32 = vadd_f32(vmul_f32(*(float32x2_t *)v265.i8, (float32x2_t)vdup_n_s32(0x3C800000u)), (float32x2_t)0xBF000000BF000000);
  *(float32x2_t *)&v174.f64[0] = vrndm_f32(*(float32x2_t *)v173.f32);
  float32x2_t v175 = vadd_f32(vsub_f32(*(float32x2_t *)&v174.f64[0], *(float32x2_t *)v173.f32), _D13);
  *(float32x2_t *)v173.f32 = vsub_f32(*(float32x2_t *)v173.f32, *(float32x2_t *)&v174.f64[0]);
  float32x2_t v176 = vmul_f32(v175, (float32x2_t)0x3F0000003F000000);
  *(float32x2_t *)v177.i8 = vmul_f32(v175, v176);
  *(float32x2_t *)v178.i8 = vadd_f32(vadd_f32(v176, vsub_f32(*(float32x2_t *)v177.i8, vmul_f32(v175, vmul_f32(v175, vmul_f32(v175, v46))))), v49);
  float32x2_t v179 = vsub_f32(_D13, *(float32x2_t *)v178.i8);
  *(float32x2_t *)v180.i8 = vadd_f32(vadd_f32(*(float32x2_t *)&v174.f64[0], vdiv_f32(vadd_f32(vadd_f32(v176, vsub_f32(*(float32x2_t *)v177.i8, vmul_f32(v175, *(float32x2_t *)v177.i8))), v49), *(float32x2_t *)v178.i8)), (float32x2_t)0xBF000000BF000000);
  float32x2_t v181 = vmul_f32(*(float32x2_t *)v173.f32, *(float32x2_t *)v173.f32);
  *(float32x2_t *)v173.f32 = vadd_f32(vadd_f32(*(float32x2_t *)&v174.f64[0], vdiv_f32(vdiv_f32(vmul_f32(*(float32x2_t *)v173.f32, v181), _D9), v179)), _D8);
  float32x2_t v263 = *(float32x2_t *)v173.f32;
  float32x2_t v266 = v179;
  v173.f32[0] = vmuls_lane_f32(*(float *)v178.i32, *(float32x2_t *)v178.i8, 1);
  float32x4_t v242 = v173;
  int8x16_t v249 = v180;
  int8x16_t v257 = v178;
  v181.i32[0] = *((_DWORD *)a8 + 7);
  v173.f32[0] = *((float *)a8 + 6)
              + vmlas_n_f32(vmuls_lane_f32(*((float *)a8 + 5), *(float32x2_t *)v180.i8, 1), *((float *)a8 + 4), *(float *)v180.i32);
  v179.i32[0] = *((_DWORD *)a8 + 9);
  *(float *)v174.f64 = v179.f32[0]
                     + vmlas_n_f32(vmuls_lane_f32(*((float *)a8 + 8), *(float32x2_t *)v180.i8, 1), v181.f32[0], *(float *)v180.i32);
  v173.i32[1] = LODWORD(v174.f64[0]);
  *(double *)v182.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a8 + 1), *(double *)v173.i64, v174, *(double *)&v181, *(double *)&v179, v180, v177, v178);
  float64x2_t v183 = (float64x2_t)v242;
  float32x4_t v243 = vmulq_n_f32(v182, v242.f32[0]);
  v182.f32[0] = *((float *)a8 + 6)
              + vmlas_n_f32(vmuls_lane_f32(*((float *)a8 + 5), *(float32x2_t *)v249.i8, 1), *((float *)a8 + 4), v263.f32[0]);
  LODWORD(v184) = *((_DWORD *)a8 + 9);
  HIDWORD(v185) = v266.i32[1];
  *(float *)&double v185 = vmuls_lane_f32(v266.f32[0], *(float32x2_t *)v257.i8, 1);
  v229.i32[0] = LODWORD(v185);
  *(float *)v183.f64 = *(float *)&v184
                     + vmlas_n_f32(vmuls_lane_f32(*((float *)a8 + 8), *(float32x2_t *)v249.i8, 1), *((float *)a8 + 7), v263.f32[0]);
  v182.i32[1] = LODWORD(v183.f64[0]);
  *(double *)v187.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a8 + 1), *(double *)v182.i64, v183, v185, v184, v257, v249, v186);
  *(float *)&double v188 = vmlas_n_f32(vmuls_lane_f32(*((float *)a8 + 5), v263, 1), *((float *)a8 + 4), *(float *)v249.i32);
  v189.i32[0] = *((_DWORD *)a8 + 9);
  *(float *)v190.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)a8 + 8), v263, 1), *((float *)a8 + 7), *(float *)v249.i32);
  float32x4_t v250 = vaddq_f32(v243, vmulq_n_f32(v187, v229.f32[0]));
  v187.f32[0] = *((float *)a8 + 6) + *(float *)&v188;
  *(float *)v191.f64 = *(float *)v189.i32 + *(float *)v190.i32;
  v187.f32[1] = *(float *)v189.i32 + *(float *)v190.i32;
  *(double *)v192.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a8 + 1), *(double *)v187.i64, v191, v188, *(double *)v257.i64, v190, v189, (int8x16_t)v250);
  *(float *)&double v193 = vmlas_n_f32(vmuls_lane_f32(*((float *)a8 + 5), v263, 1), *((float *)a8 + 4), v263.f32[0]);
  v194.i32[0] = *((_DWORD *)a8 + 9);
  *(float *)v195.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)a8 + 8), v263, 1), *((float *)a8 + 7), v263.f32[0]);
  float32x4_t v264 = vaddq_f32(v250, vmulq_n_f32(v192, vmuls_lane_f32(*(float *)v257.i32, v266, 1)));
  v192.f32[0] = *((float *)a8 + 6) + *(float *)&v193;
  *(float *)v196.f64 = *(float *)v194.i32 + *(float *)v195.i32;
  v192.f32[1] = *(float *)v194.i32 + *(float *)v195.i32;
  *(double *)v197.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a8 + 1), *(double *)v192.i64, v196, v193, *(double *)v250.i64, v195, v194, (int8x16_t)v264);
  float32x4_t v268 = v230;
  float32x4_t v269 = vaddq_f32(v264, vmulq_n_f32(v197, vmuls_lane_f32(v266.f32[0], v266, 1)));
  uint64_t v198 = &v268;
  unint64_t v199 = &v274;
  if (v35 <= 0.5) {
    unint64_t v199 = &v268;
  }
  float32x4_t v200 = *v199;
  float32x4_t v267 = v274;
  float32x4_t v268 = v200;
  v201 = &v267;
  uint64_t v202 = &v273;
  if (v35 <= 0.5) {
    unint64_t v203 = &v267;
  }
  else {
    unint64_t v203 = &v273;
  }
  if (v35 <= 1.5) {
    uint64_t v202 = &v268;
  }
  float32x4_t v204 = *v202;
  float32x4_t v267 = *v203;
  float32x4_t v268 = v204;
  unint64_t v205 = &v272;
  if (v35 <= 1.5) {
    v206 = &v267;
  }
  else {
    v206 = &v272;
  }
  if (v35 <= 2.5) {
    unint64_t v205 = &v268;
  }
  float32x4_t v207 = *v205;
  float32x4_t v267 = *v206;
  float32x4_t v268 = v207;
  unint64_t v208 = &v271;
  if (v35 <= 2.5) {
    uint64_t v209 = &v267;
  }
  else {
    uint64_t v209 = &v271;
  }
  if (v35 <= 3.5) {
    unint64_t v208 = &v268;
  }
  float32x4_t v210 = *v208;
  float32x4_t v267 = *v209;
  float32x4_t v268 = v210;
  unint64_t v211 = &v270;
  if (v35 <= 3.5) {
    uint64_t v212 = &v267;
  }
  else {
    uint64_t v212 = &v270;
  }
  if (v35 <= 4.5) {
    unint64_t v211 = &v268;
  }
  float32x4_t v213 = *v211;
  float32x4_t v267 = *v212;
  float32x4_t v268 = v213;
  if (v35 > 4.5) {
    v201 = &v269;
  }
  if (v35 > 5.5) {
    uint64_t v198 = &v269;
  }
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(*v198, 1.0 - (float)(v231 - v35)), *v201, v231 - v35).u64[0];
  return result;
}

void CI::f4_sr_sr_sr_sr_sr_sr_sr_sr_f(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v8 = a3;
  int8x16_t v10 = *(void **)(a1 + 48);
  float32x4_t v11 = *(double (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, float))(a1 + 24);
  uint64_t v12 = v10[1];
  uint64_t v13 = v10[4];
  uint64_t v14 = v10[7];
  uint64_t v15 = v10[10];
  uint64_t v16 = v10[13];
  uint64_t v17 = v10[16];
  uint64_t v18 = v10[19];
  int8x16_t v19 = (const vec2 *)v10[22];
  uint64_t v20 = v10[25];
  if (*(unsigned char *)(a1 + 64))
  {
    float64x2_t v24 = (const vec2 *)v10[22];
    double v21 = *(double (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, float))(a1 + 24);
    uint64_t v23 = v10[7];
    CI::setDC((CI *)(a3 + 16 * v10[28]), v19);
    uint64_t v14 = v23;
    int8x16_t v19 = v24;
    float32x4_t v11 = v21;
    uint64_t v8 = a3;
  }
  *(double *)&long long v22 = v11(a4 + 80 * v12, a4 + 80 * v13, a4 + 80 * v14, a4 + 80 * v15, a4 + 80 * v16, a4 + 80 * v17, a4 + 80 * v18, a4 + 80 * (void)v19, *(float *)(a2 + (v20 << 6)));
  *(_OWORD *)(v8 + 16 * a7) = v22;
}

double cikernel::_median3x3(cikernel *this, SamplerObj *a2)
{
  v3.f64[0] = *(float64_t *)CI::getDC(this);
  int8x16_t v98 = (int8x16_t)v3;
  float32x2_t v4 = vadd_f32(*(float32x2_t *)&v3.f64[0], (float32x2_t)1065353216);
  *(float *)&double v5 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v4, 1), *((float *)this + 4), v4.f32[0]);
  LODWORD(v6) = *((_DWORD *)this + 7);
  v7.i32[0] = *((_DWORD *)this + 9);
  *(float *)v8.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v4, 1), *(float *)&v6, v4.f32[0]);
  v4.f32[0] = *((float *)this + 6) + *(float *)&v5;
  *(float *)v3.f64 = *(float *)v7.i32 + *(float *)v8.i32;
  v4.f32[1] = *(float *)v7.i32 + *(float *)v8.i32;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v4, v3, v5, v6, v8, v7, v9);
  float32x4_t v97 = _Q0;
  __asm { FMOV            V0.2S, #1.0 }
  float64x2_t v15 = (float64x2_t)v98;
  *(float32x2_t *)_Q0.f32 = vadd_f32(*(float32x2_t *)v98.i8, *(float32x2_t *)_Q0.f32);
  *(float *)&double v16 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)_Q0.f32, 1), *((float *)this + 4), _Q0.f32[0]);
  LODWORD(v17) = *((_DWORD *)this + 7);
  v18.i32[0] = *((_DWORD *)this + 9);
  *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)_Q0.f32, 1), *(float *)&v17, _Q0.f32[0]);
  _Q0.f32[0] = *((float *)this + 6) + *(float *)&v16;
  *(float *)v15.f64 = *(float *)v18.i32 + *(float *)v19.i32;
  _Q0.f32[1] = *(float *)v18.i32 + *(float *)v19.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)_Q0.i64, v15, v16, v17, v19, v18, v20);
  float32x4_t v96 = v21;
  float64x2_t v22 = (float64x2_t)v98;
  *(float32x2_t *)v21.f32 = vadd_f32(*(float32x2_t *)v98.i8, (float32x2_t)0x3F80000000000000);
  *(float *)&double v23 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v21.f32, 1), *((float *)this + 4), v21.f32[0]);
  LODWORD(v24) = *((_DWORD *)this + 7);
  v25.i32[0] = *((_DWORD *)this + 9);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v21.f32, 1), *(float *)&v24, v21.f32[0]);
  v21.f32[0] = *((float *)this + 6) + *(float *)&v23;
  *(float *)v22.f64 = *(float *)v25.i32 + *(float *)v26.i32;
  v21.f32[1] = *(float *)v25.i32 + *(float *)v26.i32;
  *(double *)v28.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v21.i64, v22, v23, v24, v26, v25, v27);
  float32x4_t v95 = v28;
  float64x2_t v29 = (float64x2_t)v98;
  *(float32x2_t *)v28.f32 = vadd_f32(*(float32x2_t *)v98.i8, (float32x2_t)0x3F800000BF800000);
  *(float *)&double v30 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v28.f32, 1), *((float *)this + 4), v28.f32[0]);
  LODWORD(v31) = *((_DWORD *)this + 7);
  v32.i32[0] = *((_DWORD *)this + 9);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v28.f32, 1), *(float *)&v31, v28.f32[0]);
  v28.f32[0] = *((float *)this + 6) + *(float *)&v30;
  *(float *)v29.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v28.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)v35.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v28.i64, v29, v30, v31, v33, v32, v34);
  float32x4_t v94 = v35;
  float64x2_t v36 = (float64x2_t)v98;
  *(float32x2_t *)v35.f32 = vadd_f32(*(float32x2_t *)v98.i8, (float32x2_t)3212836864);
  *(float *)&double v37 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v35.f32, 1), *((float *)this + 4), v35.f32[0]);
  LODWORD(v38) = *((_DWORD *)this + 7);
  v39.i32[0] = *((_DWORD *)this + 9);
  *(float *)v40.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v35.f32, 1), *(float *)&v38, v35.f32[0]);
  v35.f32[0] = *((float *)this + 6) + *(float *)&v37;
  *(float *)v36.f64 = *(float *)v39.i32 + *(float *)v40.i32;
  v35.f32[1] = *(float *)v39.i32 + *(float *)v40.i32;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v35.i64, v36, v37, v38, v40, v39, v41);
  float32x4_t v93 = _Q0;
  __asm { FMOV            V0.2S, #-1.0 }
  float64x2_t v43 = (float64x2_t)v98;
  *(float32x2_t *)_Q0.f32 = vadd_f32(*(float32x2_t *)v98.i8, *(float32x2_t *)_Q0.f32);
  *(float *)&double v44 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)_Q0.f32, 1), *((float *)this + 4), _Q0.f32[0]);
  LODWORD(v45) = *((_DWORD *)this + 7);
  v46.i32[0] = *((_DWORD *)this + 9);
  *(float *)v47.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)_Q0.f32, 1), *(float *)&v45, _Q0.f32[0]);
  _Q0.f32[0] = *((float *)this + 6) + *(float *)&v44;
  *(float *)v43.f64 = *(float *)v46.i32 + *(float *)v47.i32;
  _Q0.f32[1] = *(float *)v46.i32 + *(float *)v47.i32;
  *(double *)v49.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)_Q0.i64, v43, v44, v45, v47, v46, v48);
  float32x4_t v92 = v49;
  float64x2_t v50 = (float64x2_t)v98;
  *(float32x2_t *)v49.f32 = vadd_f32(*(float32x2_t *)v98.i8, (float32x2_t)0xBF80000000000000);
  *(float *)&double v51 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v49.f32, 1), *((float *)this + 4), v49.f32[0]);
  LODWORD(v52) = *((_DWORD *)this + 7);
  v53.i32[0] = *((_DWORD *)this + 9);
  *(float *)v54.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v49.f32, 1), *(float *)&v52, v49.f32[0]);
  v49.f32[0] = *((float *)this + 6) + *(float *)&v51;
  *(float *)v50.f64 = *(float *)v53.i32 + *(float *)v54.i32;
  v49.f32[1] = *(float *)v53.i32 + *(float *)v54.i32;
  *(double *)v56.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v49.i64, v50, v51, v52, v54, v53, v55);
  float32x4_t v91 = v56;
  float64x2_t v57 = (float64x2_t)v98;
  *(float32x2_t *)v56.f32 = vadd_f32(*(float32x2_t *)v98.i8, (float32x2_t)0xBF8000003F800000);
  *(float *)&double v58 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v56.f32, 1), *((float *)this + 4), v56.f32[0]);
  LODWORD(v59) = *((_DWORD *)this + 7);
  v60.i32[0] = *((_DWORD *)this + 9);
  *(float *)v61.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v56.f32, 1), *(float *)&v59, v56.f32[0]);
  v56.f32[0] = *((float *)this + 6) + *(float *)&v58;
  *(float *)v57.f64 = *(float *)v60.i32 + *(float *)v61.i32;
  v56.f32[1] = *(float *)v60.i32 + *(float *)v61.i32;
  *(double *)v63.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v56.i64, v57, v58, v59, v61, v60, v62);
  float32x4_t v90 = v63;
  HIDWORD(v64) = v98.i32[1];
  LODWORD(v64) = *((_DWORD *)this + 7);
  v65.i32[0] = *((_DWORD *)this + 9);
  *(float *)&double v66 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v98.i8, 1), *(float *)&v64, *(float *)v98.i32);
  v63.f32[0] = *((float *)this + 6)
             + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v98.i8, 1), *((float *)this + 4), *(float *)v98.i32);
  *(float *)v67.f64 = *(float *)v65.i32 + *(float *)&v66;
  v63.f32[1] = *(float *)v65.i32 + *(float *)&v66;
  *(double *)v69.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v63.i64, v67, v64, v66, v65, v98, v68);
  float32x4_t v70 = vminnmq_f32(v96, v95);
  float32x4_t v71 = vmaxnmq_f32(v96, v95);
  float32x4_t v72 = vminnmq_f32(v93, v92);
  float32x4_t v73 = vmaxnmq_f32(v93, v92);
  float32x4_t v74 = vminnmq_f32(v90, v69);
  float32x4_t v75 = vmaxnmq_f32(v90, v69);
  float32x4_t v76 = vminnmq_f32(v97, v70);
  float32x4_t v77 = vmaxnmq_f32(v97, v70);
  float32x4_t v78 = vminnmq_f32(v94, v72);
  float32x4_t v79 = vmaxnmq_f32(v94, v72);
  float32x4_t v80 = vminnmq_f32(v91, v74);
  float32x4_t v81 = vmaxnmq_f32(v91, v74);
  float32x4_t v82 = vminnmq_f32(v77, v71);
  float32x4_t v83 = vmaxnmq_f32(v77, v71);
  float32x4_t v84 = vminnmq_f32(v79, v73);
  float32x4_t v85 = vmaxnmq_f32(v79, v73);
  float32x4_t v86 = vminnmq_f32(v81, v75);
  float32x4_t v87 = vminnmq_f32(v83, vminnmq_f32(v85, vmaxnmq_f32(v81, v75)));
  float32x4_t v88 = vminnmq_f32(vmaxnmq_f32(v84, v86), vmaxnmq_f32(v82, vminnmq_f32(v84, v86)));
  *(void *)&double result = vminnmq_f32(vmaxnmq_f32(vmaxnmq_f32(vmaxnmq_f32(v76, v78), v80), vminnmq_f32(v88, v87)), vmaxnmq_f32(v88, v87)).u64[0];
  return result;
}

void OUTLINED_FUNCTION_1_5(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x12u);
}

double cikernel::_mesh1(CI *a1, int8x16_t a2, float a3, int8x16_t a4, float a5)
{
  float v5 = a3 * 0.5;
  DC = (float32x2_t *)CI::getDC(a1);
  float32x2_t v7 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  float32x2_t v8 = vsub_f32(*DC, *(float32x2_t *)a2.i8);
  float32x2_t v9 = vsub_f32(v7, *(float32x2_t *)a2.i8);
  float v10 = fabsf(vmlas_n_f32((float)-v8.f32[1] * v9.f32[0], v9.f32[1], v8.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v9, v9))), 0.01));
  float v11 = vmlas_n_f32(vmuls_lane_f32(v9.f32[1], v8, 1), v9.f32[0], v8.f32[0]);
  float v12 = sqrtf(vaddv_f32(vmul_f32(v8, v8)));
  if (v11 >= 0.0) {
    float v12 = v10;
  }
  float32x2_t v13 = vsub_f32(*DC, v7);
  float v14 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v9, v13).i32[1]), v9.f32[0], v13.f32[0]);
  float v15 = sqrtf(vaddv_f32(vmul_f32(v13, v13)));
  if (v14 < 0.0) {
    float v15 = v12;
  }
  float v16 = 1.0;
  if ((float)(v5 - v15) <= 1.0) {
    float v16 = v5 - v15;
  }
  float v17 = 0.0;
  if ((float)(v5 - v15) >= 0.0) {
    float v17 = v16;
  }
  float v18 = (v17 * -2.0 + 3.0) * v17 * v17;
  float v19 = v15 - (v5 + -1.0);
  *(void *)&double result = vmulq_n_f32((float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v19 < 0.0)), 0x1FuLL)), a4, vandq_s8((int8x16_t)vmulq_n_f32((float32x4_t)a4, v18), (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16((float)(v15 - v5) < 0.0)), 0x1FuLL)))), a5).u64[0];
  return result;
}

void CI::f4_f4_f_clr_f(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  float v11 = (double (*)(void *, __n128, float, __n128, float))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  uint64_t v14 = *(void *)(v10 + 32);
  uint64_t v15 = *(void *)(v10 + 56);
  uint64_t v16 = *(void *)(v10 + 80);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 104)), a2);
  }
  float v17 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    float v17 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v18 = v11(a1, *v17, *((float *)a2 + 16 * v14), *((__n128 *)a2 + 4 * v15), *((float *)a2 + 16 * v16));
  *(_OWORD *)(a3 + 16 * a7) = v18;
}

double cikernel::_mesh2(CI *a1, int8x16_t a2, int8x16_t a3, float a4, int8x16_t a5, float a6)
{
  float v6 = a4 * 0.5;
  float32x2_t v7 = *(float32x2_t *)CI::getDC(a1);
  float32x2_t v8 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  float32x2_t v9 = vsub_f32(v7, *(float32x2_t *)a2.i8);
  float32x2_t v10 = vsub_f32(v8, *(float32x2_t *)a2.i8);
  float v11 = fabsf(vmlas_n_f32((float)-v9.f32[1] * v10.f32[0], v10.f32[1], v9.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v10, v10))), 0.01));
  float v12 = vmlas_n_f32(vmuls_lane_f32(v10.f32[1], v9, 1), v10.f32[0], v9.f32[0]);
  float v13 = sqrtf(vaddv_f32(vmul_f32(v9, v9)));
  if (v12 >= 0.0) {
    float v13 = v11;
  }
  float32x2_t v14 = vsub_f32(v7, v8);
  float v15 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v10, v14).i32[1]), v10.f32[0], v14.f32[0]);
  float v16 = sqrtf(vaddv_f32(vmul_f32(v14, v14)));
  if (v15 < 0.0) {
    float v16 = v13;
  }
  float32x2_t v17 = (float32x2_t)vextq_s8(a3, a3, 8uLL).u64[0];
  float32x2_t v18 = vsub_f32(v7, *(float32x2_t *)a3.i8);
  float32x2_t v19 = vsub_f32(v17, *(float32x2_t *)a3.i8);
  float v20 = fabsf(vmlas_n_f32((float)-v18.f32[1] * v19.f32[0], v19.f32[1], v18.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v19, v19))), 0.01));
  float v21 = vmlas_n_f32(vmuls_lane_f32(v19.f32[1], v18, 1), v19.f32[0], v18.f32[0]);
  float v22 = sqrtf(vaddv_f32(vmul_f32(v18, v18)));
  if (v21 >= 0.0) {
    float v22 = v20;
  }
  float32x2_t v23 = vsub_f32(v7, v17);
  float v24 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v19, v23).i32[1]), v19.f32[0], v23.f32[0]);
  float v25 = sqrtf(vaddv_f32(vmul_f32(v23, v23)));
  if (v24 < 0.0) {
    float v25 = v22;
  }
  float v26 = fminf(v16, v25);
  float v27 = 1.0;
  if ((float)(v6 - v26) <= 1.0) {
    float v27 = v6 - v26;
  }
  float v28 = 0.0;
  if ((float)(v6 - v26) >= 0.0) {
    float v28 = v27;
  }
  float v29 = (v28 * -2.0 + 3.0) * v28 * v28;
  float v30 = v26 - (v6 + -1.0);
  *(void *)&double result = vmulq_n_f32((float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v30 < 0.0)), 0x1FuLL)), a5, vandq_s8((int8x16_t)vmulq_n_f32((float32x4_t)a5, v29), (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16((float)(v26 - v6) < 0.0)), 0x1FuLL)))), a6).u64[0];
  return result;
}

void CI::f4_f4_f4_f_clr_f(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = a1[6];
  float32x2_t v10 = (double (*)(void *, __n128, __n128, float, __n128, float))a1[3];
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  int v13 = *(_DWORD *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  uint64_t v15 = *(void *)(v9 + 56);
  uint64_t v16 = *(void *)(v9 + 80);
  uint64_t v17 = *(void *)(v9 + 104);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 128)), a2);
  }
  float32x2_t v18 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    float32x2_t v18 = (__n128 *)((char *)a2 + 64 * v14);
  }
  float32x2_t v19 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    float32x2_t v19 = (__n128 *)((char *)a2 + 64 * v12);
  }
  *(double *)&long long v20 = v10(a1, *v19, *v18, *((float *)a2 + 16 * v15), *((__n128 *)a2 + 4 * v16), *((float *)a2 + 16 * v17));
  *(_OWORD *)(a3 + 16 * a7) = v20;
}

double cikernel::_mesh4(CI *a1, int8x16_t a2, int8x16_t a3, int8x16_t a4, int8x16_t a5, float a6, int8x16_t a7, float a8)
{
  float v8 = a6 * 0.5;
  float32x2_t v9 = *(float32x2_t *)CI::getDC(a1);
  float32x2_t v10 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  float32x2_t v11 = vsub_f32(v9, *(float32x2_t *)a2.i8);
  float32x2_t v12 = vsub_f32(v10, *(float32x2_t *)a2.i8);
  float v13 = fabsf(vmlas_n_f32((float)-v11.f32[1] * v12.f32[0], v12.f32[1], v11.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v12, v12))), 0.01));
  float v14 = vmlas_n_f32(vmuls_lane_f32(v12.f32[1], v11, 1), v12.f32[0], v11.f32[0]);
  float v15 = sqrtf(vaddv_f32(vmul_f32(v11, v11)));
  if (v14 >= 0.0) {
    float v15 = v13;
  }
  float32x2_t v16 = vsub_f32(v9, v10);
  float v17 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v12, v16).i32[1]), v12.f32[0], v16.f32[0]);
  float v18 = sqrtf(vaddv_f32(vmul_f32(v16, v16)));
  if (v17 < 0.0) {
    float v18 = v15;
  }
  float32x2_t v19 = (float32x2_t)vextq_s8(a3, a3, 8uLL).u64[0];
  float32x2_t v20 = vsub_f32(v9, *(float32x2_t *)a3.i8);
  float32x2_t v21 = vsub_f32(v19, *(float32x2_t *)a3.i8);
  float v22 = fabsf(vmlas_n_f32((float)-v20.f32[1] * v21.f32[0], v21.f32[1], v20.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v21, v21))), 0.01));
  float v23 = vmlas_n_f32(vmuls_lane_f32(v21.f32[1], v20, 1), v21.f32[0], v20.f32[0]);
  float v24 = sqrtf(vaddv_f32(vmul_f32(v20, v20)));
  if (v23 >= 0.0) {
    float v24 = v22;
  }
  float32x2_t v25 = vsub_f32(v9, v19);
  float v26 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v21, v25).i32[1]), v21.f32[0], v25.f32[0]);
  float v27 = sqrtf(vaddv_f32(vmul_f32(v25, v25)));
  if (v26 < 0.0) {
    float v27 = v24;
  }
  float v28 = fminf(v18, v27);
  float32x2_t v29 = (float32x2_t)vextq_s8(a4, a4, 8uLL).u64[0];
  float32x2_t v30 = vsub_f32(v9, *(float32x2_t *)a4.i8);
  float32x2_t v31 = vsub_f32(v29, *(float32x2_t *)a4.i8);
  float v32 = fabsf(vmlas_n_f32((float)-v30.f32[1] * v31.f32[0], v31.f32[1], v30.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v31, v31))), 0.01));
  float v33 = vmlas_n_f32(vmuls_lane_f32(v31.f32[1], v30, 1), v31.f32[0], v30.f32[0]);
  float v34 = sqrtf(vaddv_f32(vmul_f32(v30, v30)));
  if (v33 >= 0.0) {
    float v34 = v32;
  }
  float32x2_t v35 = vsub_f32(v9, v29);
  float v36 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v31, v35).i32[1]), v31.f32[0], v35.f32[0]);
  float v37 = sqrtf(vaddv_f32(vmul_f32(v35, v35)));
  if (v36 < 0.0) {
    float v37 = v34;
  }
  float v38 = fminf(v28, v37);
  float32x2_t v39 = (float32x2_t)vextq_s8(a5, a5, 8uLL).u64[0];
  float32x2_t v40 = vsub_f32(v9, *(float32x2_t *)a5.i8);
  float32x2_t v41 = vsub_f32(v39, *(float32x2_t *)a5.i8);
  float v42 = fabsf(vmlas_n_f32((float)-v40.f32[1] * v41.f32[0], v41.f32[1], v40.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v41, v41))), 0.01));
  float v43 = vmlas_n_f32(vmuls_lane_f32(v41.f32[1], v40, 1), v41.f32[0], v40.f32[0]);
  float v44 = sqrtf(vaddv_f32(vmul_f32(v40, v40)));
  if (v43 < 0.0) {
    float v42 = v44;
  }
  float32x2_t v45 = vsub_f32(v9, v39);
  float v46 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v41, v45).i32[1]), v41.f32[0], v45.f32[0]);
  float v47 = sqrtf(vaddv_f32(vmul_f32(v45, v45)));
  if (v46 < 0.0) {
    float v47 = v42;
  }
  float v48 = fminf(v38, v47);
  float v49 = 1.0;
  if ((float)(v8 - v48) <= 1.0) {
    float v49 = v8 - v48;
  }
  float v50 = 0.0;
  if ((float)(v8 - v48) >= 0.0) {
    float v50 = v49;
  }
  float v51 = (v50 * -2.0 + 3.0) * v50 * v50;
  float v52 = v48 - (v8 + -1.0);
  *(void *)&double result = vmulq_n_f32((float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v52 < 0.0)), 0x1FuLL)), a7, vandq_s8((int8x16_t)vmulq_n_f32((float32x4_t)a7, v51), (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16((float)(v48 - v8) < 0.0)), 0x1FuLL)))), a8).u64[0];
  return result;
}

void CI::f4_f4_f4_f4_f4_f_clr_f(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  float32x2_t v10 = *(double (**)(__n128, __n128, __n128, __n128, float, __n128, float))(a1 + 24);
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  float v13 = (const vec2 *)*(unsigned int *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  int v15 = *(_DWORD *)(v9 + 64);
  uint64_t v16 = *(void *)(v9 + 56);
  int v17 = *(_DWORD *)(v9 + 88);
  uint64_t v18 = *(void *)(v9 + 80);
  uint64_t v19 = *(void *)(v9 + 104);
  uint64_t v20 = *(void *)(v9 + 128);
  uint64_t v21 = *(void *)(v9 + 152);
  if (*(unsigned char *)(a1 + 64))
  {
    uint64_t v30 = *(void *)(v9 + 104);
    uint64_t v28 = *(void *)(v9 + 152);
    int v29 = *(_DWORD *)(v9 + 40);
    int v27 = *(_DWORD *)(v9 + 88);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 176)), v13);
    int v17 = v27;
    LODWORD(v13) = v29;
    uint64_t v21 = v28;
    uint64_t v19 = v30;
  }
  float v22 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5) {
    float v22 = (__n128 *)(a2 + (v18 << 6));
  }
  float v23 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5) {
    float v23 = (__n128 *)(a2 + (v16 << 6));
  }
  float v24 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    float v24 = (__n128 *)(a2 + (v14 << 6));
  }
  float32x2_t v25 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    float32x2_t v25 = (__n128 *)(a2 + (v12 << 6));
  }
  *(double *)&long long v26 = v10(*v25, *v24, *v23, *v22, *(float *)(a2 + (v19 << 6)), *(__n128 *)(a2 + (v20 << 6)), *(float *)(a2 + (v21 << 6)));
  *(_OWORD *)(a3 + 16 * a7) = v26;
}

double cikernel::_mesh8(CI *a1, int8x16_t a2, int8x16_t a3, int8x16_t a4, int8x16_t a5, int8x16_t a6, int8x16_t a7, int8x16_t a8, int8x16_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, float a17, uint64_t a18, float32x4_t a19, float a20)
{
  float v20 = a17 * 0.5;
  float32x2_t v21 = *(float32x2_t *)CI::getDC(a1);
  float32x2_t v22 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  float32x2_t v23 = vsub_f32(v21, *(float32x2_t *)a2.i8);
  float32x2_t v24 = vsub_f32(v22, *(float32x2_t *)a2.i8);
  float v25 = fabsf(vmlas_n_f32((float)-v23.f32[1] * v24.f32[0], v24.f32[1], v23.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v24, v24))), 0.01));
  float v26 = vmlas_n_f32(vmuls_lane_f32(v24.f32[1], v23, 1), v24.f32[0], v23.f32[0]);
  float v27 = sqrtf(vaddv_f32(vmul_f32(v23, v23)));
  if (v26 >= 0.0) {
    float v27 = v25;
  }
  float32x2_t v28 = vsub_f32(v21, v22);
  float v29 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v24, v28).i32[1]), v24.f32[0], v28.f32[0]);
  float v30 = sqrtf(vaddv_f32(vmul_f32(v28, v28)));
  if (v29 < 0.0) {
    float v30 = v27;
  }
  float32x2_t v31 = (float32x2_t)vextq_s8(a3, a3, 8uLL).u64[0];
  float32x2_t v32 = vsub_f32(v21, *(float32x2_t *)a3.i8);
  float32x2_t v33 = vsub_f32(v31, *(float32x2_t *)a3.i8);
  float v34 = fabsf(vmlas_n_f32((float)-v32.f32[1] * v33.f32[0], v33.f32[1], v32.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v33, v33))), 0.01));
  float v35 = vmlas_n_f32(vmuls_lane_f32(v33.f32[1], v32, 1), v33.f32[0], v32.f32[0]);
  float v36 = sqrtf(vaddv_f32(vmul_f32(v32, v32)));
  if (v35 >= 0.0) {
    float v36 = v34;
  }
  float32x2_t v37 = vsub_f32(v21, v31);
  float v38 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v33, v37).i32[1]), v33.f32[0], v37.f32[0]);
  float v39 = sqrtf(vaddv_f32(vmul_f32(v37, v37)));
  if (v38 < 0.0) {
    float v39 = v36;
  }
  float v40 = fminf(v30, v39);
  float32x2_t v41 = (float32x2_t)vextq_s8(a4, a4, 8uLL).u64[0];
  float32x2_t v42 = vsub_f32(v21, *(float32x2_t *)a4.i8);
  float32x2_t v43 = vsub_f32(v41, *(float32x2_t *)a4.i8);
  float v44 = fabsf(vmlas_n_f32((float)-v42.f32[1] * v43.f32[0], v43.f32[1], v42.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v43, v43))), 0.01));
  float v45 = vmlas_n_f32(vmuls_lane_f32(v43.f32[1], v42, 1), v43.f32[0], v42.f32[0]);
  float v46 = sqrtf(vaddv_f32(vmul_f32(v42, v42)));
  if (v45 >= 0.0) {
    float v46 = v44;
  }
  float32x2_t v47 = vsub_f32(v21, v41);
  float v48 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v43, v47).i32[1]), v43.f32[0], v47.f32[0]);
  float v49 = sqrtf(vaddv_f32(vmul_f32(v47, v47)));
  if (v48 < 0.0) {
    float v49 = v46;
  }
  float v50 = fminf(v40, v49);
  float32x2_t v51 = (float32x2_t)vextq_s8(a5, a5, 8uLL).u64[0];
  float32x2_t v52 = vsub_f32(v21, *(float32x2_t *)a5.i8);
  float32x2_t v53 = vsub_f32(v51, *(float32x2_t *)a5.i8);
  float v54 = fabsf(vmlas_n_f32((float)-v52.f32[1] * v53.f32[0], v53.f32[1], v52.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v53, v53))), 0.01));
  float v55 = vmlas_n_f32(vmuls_lane_f32(v53.f32[1], v52, 1), v53.f32[0], v52.f32[0]);
  float v56 = sqrtf(vaddv_f32(vmul_f32(v52, v52)));
  if (v55 >= 0.0) {
    float v56 = v54;
  }
  float32x2_t v57 = vsub_f32(v21, v51);
  float v58 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v53, v57).i32[1]), v53.f32[0], v57.f32[0]);
  float v59 = sqrtf(vaddv_f32(vmul_f32(v57, v57)));
  if (v58 < 0.0) {
    float v59 = v56;
  }
  float v60 = fminf(v50, v59);
  float32x2_t v61 = (float32x2_t)vextq_s8(a6, a6, 8uLL).u64[0];
  float32x2_t v62 = vsub_f32(v21, *(float32x2_t *)a6.i8);
  float32x2_t v63 = vsub_f32(v61, *(float32x2_t *)a6.i8);
  float v64 = fabsf(vmlas_n_f32((float)-v62.f32[1] * v63.f32[0], v63.f32[1], v62.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v63, v63))), 0.01));
  float v65 = vmlas_n_f32(vmuls_lane_f32(v63.f32[1], v62, 1), v63.f32[0], v62.f32[0]);
  float v66 = sqrtf(vaddv_f32(vmul_f32(v62, v62)));
  if (v65 >= 0.0) {
    float v66 = v64;
  }
  float32x2_t v67 = vsub_f32(v21, v61);
  float v68 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v63, v67).i32[1]), v63.f32[0], v67.f32[0]);
  float v69 = sqrtf(vaddv_f32(vmul_f32(v67, v67)));
  if (v68 < 0.0) {
    float v69 = v66;
  }
  float v70 = fminf(v60, v69);
  float32x2_t v71 = (float32x2_t)vextq_s8(a7, a7, 8uLL).u64[0];
  float32x2_t v72 = vsub_f32(v21, *(float32x2_t *)a7.i8);
  float32x2_t v73 = vsub_f32(v71, *(float32x2_t *)a7.i8);
  float v74 = fabsf(vmlas_n_f32((float)-v72.f32[1] * v73.f32[0], v73.f32[1], v72.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v73, v73))), 0.01));
  float v75 = vmlas_n_f32(vmuls_lane_f32(v73.f32[1], v72, 1), v73.f32[0], v72.f32[0]);
  float v76 = sqrtf(vaddv_f32(vmul_f32(v72, v72)));
  if (v75 >= 0.0) {
    float v76 = v74;
  }
  float32x2_t v77 = vsub_f32(v21, v71);
  float v78 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v73, v77).i32[1]), v73.f32[0], v77.f32[0]);
  float v79 = sqrtf(vaddv_f32(vmul_f32(v77, v77)));
  if (v78 < 0.0) {
    float v79 = v76;
  }
  float v80 = fminf(v70, v79);
  float32x2_t v81 = (float32x2_t)vextq_s8(a8, a8, 8uLL).u64[0];
  float32x2_t v82 = vsub_f32(v21, *(float32x2_t *)a8.i8);
  float32x2_t v83 = vsub_f32(v81, *(float32x2_t *)a8.i8);
  float v84 = fabsf(vmlas_n_f32((float)-v82.f32[1] * v83.f32[0], v83.f32[1], v82.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v83, v83))), 0.01));
  float v85 = vmlas_n_f32(vmuls_lane_f32(v83.f32[1], v82, 1), v83.f32[0], v82.f32[0]);
  float v86 = sqrtf(vaddv_f32(vmul_f32(v82, v82)));
  if (v85 >= 0.0) {
    float v86 = v84;
  }
  float32x2_t v87 = vsub_f32(v21, v81);
  float v88 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v83, v87).i32[1]), v83.f32[0], v87.f32[0]);
  float v89 = sqrtf(vaddv_f32(vmul_f32(v87, v87)));
  if (v88 < 0.0) {
    float v89 = v86;
  }
  float v90 = fminf(v80, v89);
  float32x2_t v91 = (float32x2_t)vextq_s8(a9, a9, 8uLL).u64[0];
  float32x2_t v92 = vsub_f32(v21, *(float32x2_t *)a9.i8);
  float32x2_t v93 = vsub_f32(v91, *(float32x2_t *)a9.i8);
  float v94 = fabsf(vmlas_n_f32((float)-v92.f32[1] * v93.f32[0], v93.f32[1], v92.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v93, v93))), 0.01));
  float v95 = vmlas_n_f32(vmuls_lane_f32(v93.f32[1], v92, 1), v93.f32[0], v92.f32[0]);
  float v96 = sqrtf(vaddv_f32(vmul_f32(v92, v92)));
  if (v95 < 0.0) {
    float v94 = v96;
  }
  float32x2_t v97 = vsub_f32(v21, v91);
  float v98 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v93, v97).i32[1]), v93.f32[0], v97.f32[0]);
  float v99 = sqrtf(vaddv_f32(vmul_f32(v97, v97)));
  if (v98 < 0.0) {
    float v99 = v94;
  }
  float v100 = fminf(v90, v99);
  float v101 = 1.0;
  if ((float)(v20 - v100) <= 1.0) {
    float v101 = v20 - v100;
  }
  float v102 = 0.0;
  if ((float)(v20 - v100) >= 0.0) {
    float v102 = v101;
  }
  float v103 = (v102 * -2.0 + 3.0) * v102 * v102;
  float v104 = v100 - (v20 + -1.0);
  *(void *)&double result = vmulq_n_f32((float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v104 < 0.0)), 0x1FuLL)), (int8x16_t)a19, vandq_s8((int8x16_t)vmulq_n_f32(a19, v103), (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16((float)(v100 - v20) < 0.0)), 0x1FuLL)))), a20).u64[0];
  return result;
}

void CI::f4_f4_f4_f4_f4_f4_f4_f4_f4_f_clr_f(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  float32x2_t v10 = *(const vec2 **)(a1 + 24);
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  int v13 = *(_DWORD *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  int v15 = *(_DWORD *)(v9 + 64);
  uint64_t v16 = *(void *)(v9 + 56);
  int v17 = *(_DWORD *)(v9 + 88);
  uint64_t v18 = *(void *)(v9 + 80);
  int v19 = *(_DWORD *)(v9 + 112);
  uint64_t v20 = *(void *)(v9 + 104);
  int v21 = *(_DWORD *)(v9 + 136);
  uint64_t v22 = *(void *)(v9 + 128);
  int v23 = *(_DWORD *)(v9 + 160);
  uint64_t v24 = *(void *)(v9 + 152);
  int v25 = *(_DWORD *)(v9 + 184);
  uint64_t v26 = *(void *)(v9 + 176);
  uint64_t v27 = *(void *)(v9 + 200);
  if (*(unsigned char *)(a1 + 64))
  {
    float v48 = *(const vec2 **)(a1 + 24);
    uint64_t v50 = *(void *)(v9 + 8);
    int v45 = *(_DWORD *)(v9 + 112);
    int v28 = *(_DWORD *)(v9 + 40);
    uint64_t v51 = *(void *)(v9 + 32);
    int v42 = *(_DWORD *)(v9 + 160);
    int v43 = *(_DWORD *)(v9 + 136);
    int v49 = *(_DWORD *)(v9 + 64);
    int v47 = *(_DWORD *)(v9 + 88);
    uint64_t v46 = *(void *)(v9 + 80);
    uint64_t v44 = *(void *)(v9 + 104);
    int v41 = *(_DWORD *)(v9 + 184);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 272)), v10);
    int v25 = v41;
    int v23 = v42;
    uint64_t v20 = v44;
    uint64_t v18 = v46;
    int v17 = v47;
    int v15 = v49;
    int v21 = v43;
    uint64_t v12 = v50;
    uint64_t v14 = v51;
    int v13 = v28;
    int v19 = v45;
    float32x2_t v10 = v48;
  }
  float v29 = (__n128 *)(a3 + 16 * v26);
  if (v25 != 5) {
    float v29 = (__n128 *)(a2 + (v26 << 6));
  }
  float v30 = (__n128 *)(a3 + 16 * v24);
  if (v23 != 5) {
    float v30 = (__n128 *)(a2 + (v24 << 6));
  }
  float32x2_t v31 = (__n128 *)(a3 + 16 * v22);
  if (v21 != 5) {
    float32x2_t v31 = (__n128 *)(a2 + (v22 << 6));
  }
  float32x2_t v32 = (__n128 *)(a3 + 16 * v20);
  float32x2_t v33 = (__n128 *)(a2 + (v20 << 6));
  if (v19 != 5) {
    float32x2_t v32 = v33;
  }
  float v34 = (__n128 *)(a3 + 16 * v18);
  float v35 = (__n128 *)(a2 + (v18 << 6));
  if (v17 != 5) {
    float v34 = v35;
  }
  float v36 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5) {
    float v36 = (__n128 *)(a2 + (v16 << 6));
  }
  float32x2_t v37 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    float32x2_t v37 = (__n128 *)(a2 + (v14 << 6));
  }
  float v38 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    float v38 = (__n128 *)(a2 + (v12 << 6));
  }
  LODWORD(v40) = *(_DWORD *)(a2 + (v27 << 6));
  *(double *)&long long v39 = ((double (*)(__n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128, double))v10)(*v38, *v37, *v36, *v34, *v32, *v31, *v30, *v29, v40);
  *(_OWORD *)(a3 + 16 * a7) = v39;
}

double cikernel::_mesh16(CI *a1, int8x16_t a2, int8x16_t a3, int8x16_t a4, int8x16_t a5, int8x16_t a6, int8x16_t a7, int8x16_t a8, int8x16_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int8x16_t a17, int8x16_t a18, int8x16_t a19, int8x16_t a20,int8x16_t a21,int8x16_t a22,int8x16_t a23,int8x16_t a24,float a25,uint64_t a26,float32x4_t a27,float a28)
{
  float v28 = a25 * 0.5;
  float32x2_t v29 = *(float32x2_t *)CI::getDC(a1);
  float32x2_t v30 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  float32x2_t v31 = vsub_f32(v29, *(float32x2_t *)a2.i8);
  float32x2_t v32 = vsub_f32(v30, *(float32x2_t *)a2.i8);
  float v33 = fabsf(vmlas_n_f32((float)-v31.f32[1] * v32.f32[0], v32.f32[1], v31.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v32, v32))), 0.01));
  float v34 = vmlas_n_f32(vmuls_lane_f32(v32.f32[1], v31, 1), v32.f32[0], v31.f32[0]);
  float v35 = sqrtf(vaddv_f32(vmul_f32(v31, v31)));
  if (v34 >= 0.0) {
    float v35 = v33;
  }
  float32x2_t v36 = vsub_f32(v29, v30);
  float v37 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v32, v36).i32[1]), v32.f32[0], v36.f32[0]);
  float v38 = sqrtf(vaddv_f32(vmul_f32(v36, v36)));
  if (v37 < 0.0) {
    float v38 = v35;
  }
  float32x2_t v39 = (float32x2_t)vextq_s8(a3, a3, 8uLL).u64[0];
  float32x2_t v40 = vsub_f32(v29, *(float32x2_t *)a3.i8);
  float32x2_t v41 = vsub_f32(v39, *(float32x2_t *)a3.i8);
  float v42 = fabsf(vmlas_n_f32((float)-v40.f32[1] * v41.f32[0], v41.f32[1], v40.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v41, v41))), 0.01));
  float v43 = vmlas_n_f32(vmuls_lane_f32(v41.f32[1], v40, 1), v41.f32[0], v40.f32[0]);
  float v44 = sqrtf(vaddv_f32(vmul_f32(v40, v40)));
  if (v43 >= 0.0) {
    float v44 = v42;
  }
  float32x2_t v45 = vsub_f32(v29, v39);
  float v46 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v41, v45).i32[1]), v41.f32[0], v45.f32[0]);
  float v47 = sqrtf(vaddv_f32(vmul_f32(v45, v45)));
  if (v46 < 0.0) {
    float v47 = v44;
  }
  float v48 = fminf(v38, v47);
  float32x2_t v49 = (float32x2_t)vextq_s8(a4, a4, 8uLL).u64[0];
  float32x2_t v50 = vsub_f32(v29, *(float32x2_t *)a4.i8);
  float32x2_t v51 = vsub_f32(v49, *(float32x2_t *)a4.i8);
  float v52 = fabsf(vmlas_n_f32((float)-v50.f32[1] * v51.f32[0], v51.f32[1], v50.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v51, v51))), 0.01));
  float v53 = vmlas_n_f32(vmuls_lane_f32(v51.f32[1], v50, 1), v51.f32[0], v50.f32[0]);
  float v54 = sqrtf(vaddv_f32(vmul_f32(v50, v50)));
  if (v53 >= 0.0) {
    float v54 = v52;
  }
  float32x2_t v55 = vsub_f32(v29, v49);
  float v56 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v51, v55).i32[1]), v51.f32[0], v55.f32[0]);
  float v57 = sqrtf(vaddv_f32(vmul_f32(v55, v55)));
  if (v56 < 0.0) {
    float v57 = v54;
  }
  float v58 = fminf(v48, v57);
  float32x2_t v59 = (float32x2_t)vextq_s8(a5, a5, 8uLL).u64[0];
  float32x2_t v60 = vsub_f32(v29, *(float32x2_t *)a5.i8);
  float32x2_t v61 = vsub_f32(v59, *(float32x2_t *)a5.i8);
  float v62 = fabsf(vmlas_n_f32((float)-v60.f32[1] * v61.f32[0], v61.f32[1], v60.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v61, v61))), 0.01));
  float v63 = vmlas_n_f32(vmuls_lane_f32(v61.f32[1], v60, 1), v61.f32[0], v60.f32[0]);
  float v64 = sqrtf(vaddv_f32(vmul_f32(v60, v60)));
  if (v63 >= 0.0) {
    float v64 = v62;
  }
  float32x2_t v65 = vsub_f32(v29, v59);
  float v66 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v61, v65).i32[1]), v61.f32[0], v65.f32[0]);
  float v67 = sqrtf(vaddv_f32(vmul_f32(v65, v65)));
  if (v66 < 0.0) {
    float v67 = v64;
  }
  float v68 = fminf(v58, v67);
  float32x2_t v69 = (float32x2_t)vextq_s8(a6, a6, 8uLL).u64[0];
  float32x2_t v70 = vsub_f32(v29, *(float32x2_t *)a6.i8);
  float32x2_t v71 = vsub_f32(v69, *(float32x2_t *)a6.i8);
  float v72 = fabsf(vmlas_n_f32((float)-v70.f32[1] * v71.f32[0], v71.f32[1], v70.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v71, v71))), 0.01));
  float v73 = vmlas_n_f32(vmuls_lane_f32(v71.f32[1], v70, 1), v71.f32[0], v70.f32[0]);
  float v74 = sqrtf(vaddv_f32(vmul_f32(v70, v70)));
  if (v73 >= 0.0) {
    float v74 = v72;
  }
  float32x2_t v75 = vsub_f32(v29, v69);
  float v76 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v71, v75).i32[1]), v71.f32[0], v75.f32[0]);
  float v77 = sqrtf(vaddv_f32(vmul_f32(v75, v75)));
  if (v76 < 0.0) {
    float v77 = v74;
  }
  float v78 = fminf(v68, v77);
  float32x2_t v79 = (float32x2_t)vextq_s8(a7, a7, 8uLL).u64[0];
  float32x2_t v80 = vsub_f32(v29, *(float32x2_t *)a7.i8);
  float32x2_t v81 = vsub_f32(v79, *(float32x2_t *)a7.i8);
  float v82 = fabsf(vmlas_n_f32((float)-v80.f32[1] * v81.f32[0], v81.f32[1], v80.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v81, v81))), 0.01));
  float v83 = vmlas_n_f32(vmuls_lane_f32(v81.f32[1], v80, 1), v81.f32[0], v80.f32[0]);
  float v84 = sqrtf(vaddv_f32(vmul_f32(v80, v80)));
  if (v83 >= 0.0) {
    float v84 = v82;
  }
  float32x2_t v85 = vsub_f32(v29, v79);
  float v86 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v81, v85).i32[1]), v81.f32[0], v85.f32[0]);
  float v87 = sqrtf(vaddv_f32(vmul_f32(v85, v85)));
  if (v86 < 0.0) {
    float v87 = v84;
  }
  float v88 = fminf(v78, v87);
  float32x2_t v89 = (float32x2_t)vextq_s8(a8, a8, 8uLL).u64[0];
  float32x2_t v90 = vsub_f32(v29, *(float32x2_t *)a8.i8);
  float32x2_t v91 = vsub_f32(v89, *(float32x2_t *)a8.i8);
  float v92 = fabsf(vmlas_n_f32((float)-v90.f32[1] * v91.f32[0], v91.f32[1], v90.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v91, v91))), 0.01));
  float v93 = vmlas_n_f32(vmuls_lane_f32(v91.f32[1], v90, 1), v91.f32[0], v90.f32[0]);
  float v94 = sqrtf(vaddv_f32(vmul_f32(v90, v90)));
  if (v93 >= 0.0) {
    float v94 = v92;
  }
  float32x2_t v95 = vsub_f32(v29, v89);
  float v96 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v91, v95).i32[1]), v91.f32[0], v95.f32[0]);
  float v97 = sqrtf(vaddv_f32(vmul_f32(v95, v95)));
  if (v96 < 0.0) {
    float v97 = v94;
  }
  float v98 = fminf(v88, v97);
  float32x2_t v99 = (float32x2_t)vextq_s8(a9, a9, 8uLL).u64[0];
  float32x2_t v100 = vsub_f32(v29, *(float32x2_t *)a9.i8);
  float32x2_t v101 = vsub_f32(v99, *(float32x2_t *)a9.i8);
  float v102 = fabsf(vmlas_n_f32((float)-v100.f32[1] * v101.f32[0], v101.f32[1], v100.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v101, v101))), 0.01));
  float v103 = vmlas_n_f32(vmuls_lane_f32(v101.f32[1], v100, 1), v101.f32[0], v100.f32[0]);
  float v104 = sqrtf(vaddv_f32(vmul_f32(v100, v100)));
  if (v103 >= 0.0) {
    float v104 = v102;
  }
  float32x2_t v105 = vsub_f32(v29, v99);
  float v106 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v101, v105).i32[1]), v101.f32[0], v105.f32[0]);
  float v107 = sqrtf(vaddv_f32(vmul_f32(v105, v105)));
  if (v106 < 0.0) {
    float v107 = v104;
  }
  float v108 = fminf(v98, v107);
  float32x2_t v109 = (float32x2_t)vextq_s8(a17, a17, 8uLL).u64[0];
  float32x2_t v110 = vsub_f32(v29, *(float32x2_t *)a17.i8);
  float32x2_t v111 = vsub_f32(v109, *(float32x2_t *)a17.i8);
  float v112 = fabsf(vmlas_n_f32((float)-v110.f32[1] * v111.f32[0], v111.f32[1], v110.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v111, v111))), 0.01));
  float v113 = vmlas_n_f32(vmuls_lane_f32(v111.f32[1], v110, 1), v111.f32[0], v110.f32[0]);
  float v114 = sqrtf(vaddv_f32(vmul_f32(v110, v110)));
  if (v113 >= 0.0) {
    float v114 = v112;
  }
  float32x2_t v115 = vsub_f32(v29, v109);
  float v116 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v111, v115).i32[1]), v111.f32[0], v115.f32[0]);
  float v117 = sqrtf(vaddv_f32(vmul_f32(v115, v115)));
  if (v116 < 0.0) {
    float v117 = v114;
  }
  float v118 = fminf(v108, v117);
  float32x2_t v119 = (float32x2_t)vextq_s8(a18, a18, 8uLL).u64[0];
  float32x2_t v120 = vsub_f32(v29, *(float32x2_t *)a18.i8);
  float32x2_t v121 = vsub_f32(v119, *(float32x2_t *)a18.i8);
  float v122 = fabsf(vmlas_n_f32((float)-v120.f32[1] * v121.f32[0], v121.f32[1], v120.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v121, v121))), 0.01));
  float v123 = vmlas_n_f32(vmuls_lane_f32(v121.f32[1], v120, 1), v121.f32[0], v120.f32[0]);
  float v124 = sqrtf(vaddv_f32(vmul_f32(v120, v120)));
  if (v123 >= 0.0) {
    float v124 = v122;
  }
  float32x2_t v125 = vsub_f32(v29, v119);
  float v126 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v121, v125).i32[1]), v121.f32[0], v125.f32[0]);
  float v127 = sqrtf(vaddv_f32(vmul_f32(v125, v125)));
  if (v126 < 0.0) {
    float v127 = v124;
  }
  float v128 = fminf(v118, v127);
  float32x2_t v129 = (float32x2_t)vextq_s8(a19, a19, 8uLL).u64[0];
  float32x2_t v130 = vsub_f32(v29, *(float32x2_t *)a19.i8);
  float32x2_t v131 = vsub_f32(v129, *(float32x2_t *)a19.i8);
  float v132 = fabsf(vmlas_n_f32((float)-v130.f32[1] * v131.f32[0], v131.f32[1], v130.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v131, v131))), 0.01));
  float v133 = vmlas_n_f32(vmuls_lane_f32(v131.f32[1], v130, 1), v131.f32[0], v130.f32[0]);
  float v134 = sqrtf(vaddv_f32(vmul_f32(v130, v130)));
  if (v133 >= 0.0) {
    float v134 = v132;
  }
  float32x2_t v135 = vsub_f32(v29, v129);
  float v136 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v131, v135).i32[1]), v131.f32[0], v135.f32[0]);
  float v137 = sqrtf(vaddv_f32(vmul_f32(v135, v135)));
  if (v136 < 0.0) {
    float v137 = v134;
  }
  float v138 = fminf(v128, v137);
  float32x2_t v139 = (float32x2_t)vextq_s8(a20, a20, 8uLL).u64[0];
  float32x2_t v140 = vsub_f32(v29, *(float32x2_t *)a20.i8);
  float32x2_t v141 = vsub_f32(v139, *(float32x2_t *)a20.i8);
  float v142 = fabsf(vmlas_n_f32((float)-v140.f32[1] * v141.f32[0], v141.f32[1], v140.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v141, v141))), 0.01));
  float v143 = vmlas_n_f32(vmuls_lane_f32(v141.f32[1], v140, 1), v141.f32[0], v140.f32[0]);
  float v144 = sqrtf(vaddv_f32(vmul_f32(v140, v140)));
  if (v143 >= 0.0) {
    float v144 = v142;
  }
  float32x2_t v145 = vsub_f32(v29, v139);
  float v146 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v141, v145).i32[1]), v141.f32[0], v145.f32[0]);
  float v147 = sqrtf(vaddv_f32(vmul_f32(v145, v145)));
  if (v146 < 0.0) {
    float v147 = v144;
  }
  float v148 = fminf(v138, v147);
  float32x2_t v149 = (float32x2_t)vextq_s8(a21, a21, 8uLL).u64[0];
  float32x2_t v150 = vsub_f32(v29, *(float32x2_t *)a21.i8);
  float32x2_t v151 = vsub_f32(v149, *(float32x2_t *)a21.i8);
  float v152 = fabsf(vmlas_n_f32((float)-v150.f32[1] * v151.f32[0], v151.f32[1], v150.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v151, v151))), 0.01));
  float v153 = vmlas_n_f32(vmuls_lane_f32(v151.f32[1], v150, 1), v151.f32[0], v150.f32[0]);
  float v154 = sqrtf(vaddv_f32(vmul_f32(v150, v150)));
  if (v153 >= 0.0) {
    float v154 = v152;
  }
  float32x2_t v155 = vsub_f32(v29, v149);
  float v156 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v151, v155).i32[1]), v151.f32[0], v155.f32[0]);
  float v157 = sqrtf(vaddv_f32(vmul_f32(v155, v155)));
  if (v156 < 0.0) {
    float v157 = v154;
  }
  float v158 = fminf(v148, v157);
  float32x2_t v159 = (float32x2_t)vextq_s8(a22, a22, 8uLL).u64[0];
  float32x2_t v160 = vsub_f32(v29, *(float32x2_t *)a22.i8);
  float32x2_t v161 = vsub_f32(v159, *(float32x2_t *)a22.i8);
  float v162 = fabsf(vmlas_n_f32((float)-v160.f32[1] * v161.f32[0], v161.f32[1], v160.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v161, v161))), 0.01));
  float v163 = vmlas_n_f32(vmuls_lane_f32(v161.f32[1], v160, 1), v161.f32[0], v160.f32[0]);
  float v164 = sqrtf(vaddv_f32(vmul_f32(v160, v160)));
  if (v163 >= 0.0) {
    float v164 = v162;
  }
  float32x2_t v165 = vsub_f32(v29, v159);
  float v166 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v161, v165).i32[1]), v161.f32[0], v165.f32[0]);
  float v167 = sqrtf(vaddv_f32(vmul_f32(v165, v165)));
  if (v166 < 0.0) {
    float v167 = v164;
  }
  float v168 = fminf(v158, v167);
  float32x2_t v169 = (float32x2_t)vextq_s8(a23, a23, 8uLL).u64[0];
  float32x2_t v170 = vsub_f32(v29, *(float32x2_t *)a23.i8);
  float32x2_t v171 = vsub_f32(v169, *(float32x2_t *)a23.i8);
  float v172 = fabsf(vmlas_n_f32((float)-v170.f32[1] * v171.f32[0], v171.f32[1], v170.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v171, v171))), 0.01));
  float v173 = vmlas_n_f32(vmuls_lane_f32(v171.f32[1], v170, 1), v171.f32[0], v170.f32[0]);
  float v174 = sqrtf(vaddv_f32(vmul_f32(v170, v170)));
  if (v173 >= 0.0) {
    float v174 = v172;
  }
  float32x2_t v175 = vsub_f32(v29, v169);
  float v176 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v171, v175).i32[1]), v171.f32[0], v175.f32[0]);
  float v177 = sqrtf(vaddv_f32(vmul_f32(v175, v175)));
  if (v176 < 0.0) {
    float v177 = v174;
  }
  float v178 = fminf(v168, v177);
  float32x2_t v179 = (float32x2_t)vextq_s8(a24, a24, 8uLL).u64[0];
  float32x2_t v180 = vsub_f32(v29, *(float32x2_t *)a24.i8);
  float32x2_t v181 = vsub_f32(v179, *(float32x2_t *)a24.i8);
  float v182 = fabsf(vmlas_n_f32((float)-v180.f32[1] * v181.f32[0], v181.f32[1], v180.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v181, v181))), 0.01));
  float v183 = vmlas_n_f32(vmuls_lane_f32(v181.f32[1], v180, 1), v181.f32[0], v180.f32[0]);
  float v184 = sqrtf(vaddv_f32(vmul_f32(v180, v180)));
  if (v183 < 0.0) {
    float v182 = v184;
  }
  float32x2_t v185 = vsub_f32(v29, v179);
  float v186 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v181, v185).i32[1]), v181.f32[0], v185.f32[0]);
  float v187 = sqrtf(vaddv_f32(vmul_f32(v185, v185)));
  if (v186 < 0.0) {
    float v187 = v182;
  }
  float v188 = fminf(v178, v187);
  float v189 = 1.0;
  if ((float)(v28 - v188) <= 1.0) {
    float v189 = v28 - v188;
  }
  float v190 = 0.0;
  if ((float)(v28 - v188) >= 0.0) {
    float v190 = v189;
  }
  float v191 = (v190 * -2.0 + 3.0) * v190 * v190;
  float v192 = v188 - (v28 + -1.0);
  *(void *)&double result = vmulq_n_f32((float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v192 < 0.0)), 0x1FuLL)), (int8x16_t)a27, vandq_s8((int8x16_t)vmulq_n_f32(a27, v191), (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16((float)(v188 - v28) < 0.0)), 0x1FuLL)))), a28).u64[0];
  return result;
}

void CI::f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f_clr_f(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  float32x2_t v10 = *(double (**)(__n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double))(a1 + 24);
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  int v13 = *(_DWORD *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  int v15 = *(_DWORD *)(v9 + 64);
  uint64_t v16 = *(void *)(v9 + 56);
  int v17 = *(_DWORD *)(v9 + 88);
  uint64_t v18 = *(void *)(v9 + 80);
  uint64_t v19 = *(void *)(v9 + 104);
  int v83 = *(_DWORD *)(v9 + 136);
  int v84 = *(_DWORD *)(v9 + 112);
  uint64_t v20 = *(const vec2 **)(v9 + 128);
  int v82 = *(_DWORD *)(v9 + 160);
  uint64_t v81 = *(void *)(v9 + 152);
  uint64_t v21 = *(void *)(v9 + 176);
  int v79 = *(_DWORD *)(v9 + 208);
  int v80 = *(_DWORD *)(v9 + 184);
  uint64_t v22 = *(void *)(v9 + 200);
  int v78 = *(_DWORD *)(v9 + 232);
  uint64_t v23 = *(void *)(v9 + 224);
  int v24 = *(_DWORD *)(v9 + 256);
  int v25 = *(_DWORD *)(v9 + 280);
  uint64_t v76 = *(void *)(v9 + 272);
  uint64_t v77 = *(void *)(v9 + 248);
  int v26 = *(_DWORD *)(v9 + 304);
  int v27 = *(unsigned __int8 *)(a1 + 64);
  uint64_t v28 = *(void *)(v9 + 296);
  int v29 = *(_DWORD *)(v9 + 328);
  uint64_t v30 = *(void *)(v9 + 320);
  int v31 = *(_DWORD *)(v9 + 352);
  uint64_t v32 = *(void *)(v9 + 344);
  int v33 = *(_DWORD *)(v9 + 376);
  uint64_t v34 = *(void *)(v9 + 368);
  uint64_t v85 = *(void *)(v9 + 392);
  if (v27)
  {
    int v61 = *(_DWORD *)(v9 + 352);
    float32x2_t v71 = v10;
    uint64_t v72 = *(void *)(v9 + 56);
    uint64_t v74 = *(void *)(v9 + 32);
    uint64_t v75 = *(void *)(v9 + 8);
    int v73 = *(_DWORD *)(v9 + 16);
    int v35 = *(_DWORD *)(v9 + 40);
    int v36 = *(_DWORD *)(v9 + 64);
    int v37 = *(_DWORD *)(v9 + 88);
    uint64_t v70 = *(void *)(v9 + 104);
    uint64_t v68 = *(void *)(v9 + 176);
    float32x2_t v69 = *(const vec2 **)(v9 + 128);
    uint64_t v66 = *(void *)(v9 + 224);
    uint64_t v67 = *(void *)(v9 + 200);
    int v64 = *(_DWORD *)(v9 + 280);
    int v65 = *(_DWORD *)(v9 + 256);
    int v62 = *(_DWORD *)(v9 + 328);
    int v63 = *(_DWORD *)(v9 + 304);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 464)), v20);
    int v31 = v61;
    int v29 = v62;
    int v26 = v63;
    int v25 = v64;
    int v24 = v65;
    uint64_t v23 = v66;
    uint64_t v22 = v67;
    uint64_t v21 = v68;
    uint64_t v20 = v69;
    uint64_t v19 = v70;
    int v17 = v37;
    int v15 = v36;
    int v13 = v35;
    uint64_t v14 = v74;
    uint64_t v12 = v75;
    int v11 = v73;
    float32x2_t v10 = v71;
    uint64_t v16 = v72;
  }
  float v38 = (double *)(a3 + 16 * v34);
  if (v33 != 5) {
    float v38 = (double *)(a2 + (v34 << 6));
  }
  float32x2_t v39 = (double *)(a3 + 16 * v32);
  if (v31 != 5) {
    float32x2_t v39 = (double *)(a2 + (v32 << 6));
  }
  float32x2_t v40 = (double *)(a3 + 16 * v30);
  if (v29 != 5) {
    float32x2_t v40 = (double *)(a2 + (v30 << 6));
  }
  float32x2_t v41 = (double *)(a3 + 16 * v28);
  if (v26 != 5) {
    float32x2_t v41 = (double *)(a2 + (v28 << 6));
  }
  float v42 = (double *)(a3 + 16 * v76);
  if (v25 != 5) {
    float v42 = (double *)(a2 + (v76 << 6));
  }
  float v43 = (double *)(a3 + 16 * v77);
  if (v24 != 5) {
    float v43 = (double *)(a2 + (v77 << 6));
  }
  float v44 = (double *)(a3 + 16 * v23);
  float32x2_t v45 = (double *)(a2 + (v23 << 6));
  if (v78 != 5) {
    float v44 = v45;
  }
  float v46 = (double *)(a3 + 16 * v22);
  float v47 = (double *)(a2 + (v22 << 6));
  if (v79 != 5) {
    float v46 = v47;
  }
  float v48 = (__n128 *)(a3 + 16 * v21);
  float32x2_t v49 = (__n128 *)(a2 + (v21 << 6));
  if (v80 != 5) {
    float v48 = v49;
  }
  float32x2_t v50 = (__n128 *)(a3 + 16 * v81);
  if (v82 != 5) {
    float32x2_t v50 = (__n128 *)(a2 + (v81 << 6));
  }
  float32x2_t v51 = (__n128 *)(a3 + 16 * (void)v20);
  float v52 = (__n128 *)(a2 + ((void)v20 << 6));
  if (v83 != 5) {
    float32x2_t v51 = v52;
  }
  float v53 = (__n128 *)(a3 + 16 * v19);
  float v54 = (__n128 *)(a2 + (v19 << 6));
  if (v84 != 5) {
    float v53 = v54;
  }
  float32x2_t v55 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5) {
    float32x2_t v55 = (__n128 *)(a2 + (v18 << 6));
  }
  float v56 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5) {
    float v56 = (__n128 *)(a2 + (v16 << 6));
  }
  float v57 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    float v57 = (__n128 *)(a2 + (v14 << 6));
  }
  float v58 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    float v58 = (__n128 *)(a2 + (v12 << 6));
  }
  LODWORD(v60) = *(_DWORD *)(a2 + (v85 << 6));
  *(double *)&long long v59 = v10(*v58, *v57, *v56, *v55, *v53, *v51, *v50, *v48, *v46, v46[1], *v44, v44[1], *v43, v43[1], *v42, v42[1], *v41, v41[1], *v40,
                      v40[1],
                      *v39,
                      v39[1],
                      *v38,
                      v38[1],
                      v60);
  *(_OWORD *)(a3 + 16 * a7) = v59;
}

double cikernel::_mesh32(CI *a1, int8x16_t a2, int8x16_t a3, int8x16_t a4, int8x16_t a5, int8x16_t a6, int8x16_t a7, int8x16_t a8, int8x16_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int8x16_t a17, int8x16_t a18, int8x16_t a19, int8x16_t a20,int8x16_t a21,int8x16_t a22,int8x16_t a23,int8x16_t a24,int8x16_t a25,int8x16_t a26,int8x16_t a27,int8x16_t a28,int8x16_t a29,int8x16_t a30,int8x16_t a31,int8x16_t a32,int8x16_t a33,int8x16_t a34,int8x16_t a35,int8x16_t a36,int8x16_t a37,int8x16_t a38,int8x16_t a39,int8x16_t a40,float a41,uint64_t a42,float32x4_t a43,float a44)
{
  float v44 = a41 * 0.5;
  float32x2_t v45 = *(float32x2_t *)CI::getDC(a1);
  float32x2_t v46 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  float32x2_t v47 = vsub_f32(v45, *(float32x2_t *)a2.i8);
  float32x2_t v48 = vsub_f32(v46, *(float32x2_t *)a2.i8);
  float v49 = vmlas_n_f32(vmuls_lane_f32(v48.f32[1], v47, 1), v48.f32[0], v47.f32[0]);
  float v50 = fabsf(vmlas_n_f32((float)-v47.f32[1] * v48.f32[0], v48.f32[1], v47.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v48, v48))), 0.01));
  float v51 = sqrtf(vaddv_f32(vmul_f32(v47, v47)));
  if (v49 >= 0.0) {
    float v51 = v50;
  }
  float32x2_t v52 = vsub_f32(v45, v46);
  float v53 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v48, v52).i32[1]), v48.f32[0], v52.f32[0]);
  float v54 = sqrtf(vaddv_f32(vmul_f32(v52, v52)));
  if (v53 < 0.0) {
    float v54 = v51;
  }
  float32x2_t v55 = (float32x2_t)vextq_s8(a3, a3, 8uLL).u64[0];
  float32x2_t v56 = vsub_f32(v45, *(float32x2_t *)a3.i8);
  float32x2_t v57 = vsub_f32(v55, *(float32x2_t *)a3.i8);
  float v58 = vmlas_n_f32(vmuls_lane_f32(v57.f32[1], v56, 1), v57.f32[0], v56.f32[0]);
  float v59 = fabsf(vmlas_n_f32((float)-v56.f32[1] * v57.f32[0], v57.f32[1], v56.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v57, v57))), 0.01));
  float v60 = sqrtf(vaddv_f32(vmul_f32(v56, v56)));
  if (v58 >= 0.0) {
    float v60 = v59;
  }
  float32x2_t v61 = vsub_f32(v45, v55);
  float v62 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v57, v61).i32[1]), v57.f32[0], v61.f32[0]);
  float v63 = sqrtf(vaddv_f32(vmul_f32(v61, v61)));
  if (v62 < 0.0) {
    float v63 = v60;
  }
  float v64 = fminf(v54, v63);
  float32x2_t v65 = (float32x2_t)vextq_s8(a4, a4, 8uLL).u64[0];
  float32x2_t v66 = vsub_f32(v45, *(float32x2_t *)a4.i8);
  float32x2_t v67 = vsub_f32(v65, *(float32x2_t *)a4.i8);
  float v68 = vmlas_n_f32(vmuls_lane_f32(v67.f32[1], v66, 1), v67.f32[0], v66.f32[0]);
  float v69 = fabsf(vmlas_n_f32((float)-v66.f32[1] * v67.f32[0], v67.f32[1], v66.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v67, v67))), 0.01));
  float v70 = sqrtf(vaddv_f32(vmul_f32(v66, v66)));
  if (v68 >= 0.0) {
    float v70 = v69;
  }
  float32x2_t v71 = vsub_f32(v45, v65);
  float v72 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v67, v71).i32[1]), v67.f32[0], v71.f32[0]);
  float v73 = sqrtf(vaddv_f32(vmul_f32(v71, v71)));
  if (v72 < 0.0) {
    float v73 = v70;
  }
  float v74 = fminf(v64, v73);
  float32x2_t v75 = (float32x2_t)vextq_s8(a5, a5, 8uLL).u64[0];
  float32x2_t v76 = vsub_f32(v45, *(float32x2_t *)a5.i8);
  float32x2_t v77 = vsub_f32(v75, *(float32x2_t *)a5.i8);
  float v78 = vmlas_n_f32(vmuls_lane_f32(v77.f32[1], v76, 1), v77.f32[0], v76.f32[0]);
  float v79 = fabsf(vmlas_n_f32((float)-v76.f32[1] * v77.f32[0], v77.f32[1], v76.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v77, v77))), 0.01));
  float v80 = sqrtf(vaddv_f32(vmul_f32(v76, v76)));
  if (v78 >= 0.0) {
    float v80 = v79;
  }
  float32x2_t v81 = vsub_f32(v45, v75);
  float v82 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v77, v81).i32[1]), v77.f32[0], v81.f32[0]);
  float v83 = sqrtf(vaddv_f32(vmul_f32(v81, v81)));
  if (v82 < 0.0) {
    float v83 = v80;
  }
  float v84 = fminf(v74, v83);
  float32x2_t v85 = (float32x2_t)vextq_s8(a6, a6, 8uLL).u64[0];
  float32x2_t v86 = vsub_f32(v45, *(float32x2_t *)a6.i8);
  float32x2_t v87 = vsub_f32(v85, *(float32x2_t *)a6.i8);
  float v88 = vmlas_n_f32(vmuls_lane_f32(v87.f32[1], v86, 1), v87.f32[0], v86.f32[0]);
  float v89 = fabsf(vmlas_n_f32((float)-v86.f32[1] * v87.f32[0], v87.f32[1], v86.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v87, v87))), 0.01));
  float v90 = sqrtf(vaddv_f32(vmul_f32(v86, v86)));
  if (v88 >= 0.0) {
    float v90 = v89;
  }
  float32x2_t v91 = vsub_f32(v45, v85);
  float v92 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v87, v91).i32[1]), v87.f32[0], v91.f32[0]);
  float v93 = sqrtf(vaddv_f32(vmul_f32(v91, v91)));
  if (v92 < 0.0) {
    float v93 = v90;
  }
  float v94 = fminf(v84, v93);
  float32x2_t v95 = (float32x2_t)vextq_s8(a7, a7, 8uLL).u64[0];
  float32x2_t v96 = vsub_f32(v45, *(float32x2_t *)a7.i8);
  float32x2_t v97 = vsub_f32(v95, *(float32x2_t *)a7.i8);
  float v98 = vmlas_n_f32(vmuls_lane_f32(v97.f32[1], v96, 1), v97.f32[0], v96.f32[0]);
  float v99 = fabsf(vmlas_n_f32((float)-v96.f32[1] * v97.f32[0], v97.f32[1], v96.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v97, v97))), 0.01));
  float v100 = sqrtf(vaddv_f32(vmul_f32(v96, v96)));
  if (v98 >= 0.0) {
    float v100 = v99;
  }
  float32x2_t v101 = vsub_f32(v45, v95);
  float v102 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v97, v101).i32[1]), v97.f32[0], v101.f32[0]);
  float v103 = sqrtf(vaddv_f32(vmul_f32(v101, v101)));
  if (v102 < 0.0) {
    float v103 = v100;
  }
  float v104 = fminf(v94, v103);
  float32x2_t v105 = (float32x2_t)vextq_s8(a8, a8, 8uLL).u64[0];
  float32x2_t v106 = vsub_f32(v45, *(float32x2_t *)a8.i8);
  float32x2_t v107 = vsub_f32(v105, *(float32x2_t *)a8.i8);
  float v108 = vmlas_n_f32(vmuls_lane_f32(v107.f32[1], v106, 1), v107.f32[0], v106.f32[0]);
  float v109 = fabsf(vmlas_n_f32((float)-v106.f32[1] * v107.f32[0], v107.f32[1], v106.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v107, v107))), 0.01));
  float v110 = sqrtf(vaddv_f32(vmul_f32(v106, v106)));
  if (v108 >= 0.0) {
    float v110 = v109;
  }
  float32x2_t v111 = vsub_f32(v45, v105);
  float v112 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v107, v111).i32[1]), v107.f32[0], v111.f32[0]);
  float v113 = sqrtf(vaddv_f32(vmul_f32(v111, v111)));
  if (v112 < 0.0) {
    float v113 = v110;
  }
  float v114 = fminf(v104, v113);
  float32x2_t v115 = (float32x2_t)vextq_s8(a9, a9, 8uLL).u64[0];
  float32x2_t v116 = vsub_f32(v45, *(float32x2_t *)a9.i8);
  float32x2_t v117 = vsub_f32(v115, *(float32x2_t *)a9.i8);
  float v118 = vmlas_n_f32(vmuls_lane_f32(v117.f32[1], v116, 1), v117.f32[0], v116.f32[0]);
  float v119 = fabsf(vmlas_n_f32((float)-v116.f32[1] * v117.f32[0], v117.f32[1], v116.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v117, v117))), 0.01));
  float v120 = sqrtf(vaddv_f32(vmul_f32(v116, v116)));
  if (v118 >= 0.0) {
    float v120 = v119;
  }
  float32x2_t v121 = vsub_f32(v45, v115);
  float v122 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v117, v121).i32[1]), v117.f32[0], v121.f32[0]);
  float v123 = sqrtf(vaddv_f32(vmul_f32(v121, v121)));
  if (v122 < 0.0) {
    float v123 = v120;
  }
  float v124 = fminf(v114, v123);
  float32x2_t v125 = (float32x2_t)vextq_s8(a17, a17, 8uLL).u64[0];
  float32x2_t v126 = vsub_f32(v45, *(float32x2_t *)a17.i8);
  float32x2_t v127 = vsub_f32(v125, *(float32x2_t *)a17.i8);
  float v128 = vmlas_n_f32(vmuls_lane_f32(v127.f32[1], v126, 1), v127.f32[0], v126.f32[0]);
  float v129 = fabsf(vmlas_n_f32((float)-v126.f32[1] * v127.f32[0], v127.f32[1], v126.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v127, v127))), 0.01));
  float v130 = sqrtf(vaddv_f32(vmul_f32(v126, v126)));
  if (v128 >= 0.0) {
    float v130 = v129;
  }
  float32x2_t v131 = vsub_f32(v45, v125);
  float v132 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v127, v131).i32[1]), v127.f32[0], v131.f32[0]);
  float v133 = sqrtf(vaddv_f32(vmul_f32(v131, v131)));
  if (v132 < 0.0) {
    float v133 = v130;
  }
  float v134 = fminf(v124, v133);
  float32x2_t v135 = (float32x2_t)vextq_s8(a18, a18, 8uLL).u64[0];
  float32x2_t v136 = vsub_f32(v45, *(float32x2_t *)a18.i8);
  float32x2_t v137 = vsub_f32(v135, *(float32x2_t *)a18.i8);
  float v138 = vmlas_n_f32(vmuls_lane_f32(v137.f32[1], v136, 1), v137.f32[0], v136.f32[0]);
  float v139 = fabsf(vmlas_n_f32((float)-v136.f32[1] * v137.f32[0], v137.f32[1], v136.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v137, v137))), 0.01));
  float v140 = sqrtf(vaddv_f32(vmul_f32(v136, v136)));
  if (v138 >= 0.0) {
    float v140 = v139;
  }
  float32x2_t v141 = vsub_f32(v45, v135);
  float v142 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v137, v141).i32[1]), v137.f32[0], v141.f32[0]);
  float v143 = sqrtf(vaddv_f32(vmul_f32(v141, v141)));
  if (v142 < 0.0) {
    float v143 = v140;
  }
  float v144 = fminf(v134, v143);
  float32x2_t v145 = (float32x2_t)vextq_s8(a19, a19, 8uLL).u64[0];
  float32x2_t v146 = vsub_f32(v45, *(float32x2_t *)a19.i8);
  float32x2_t v147 = vsub_f32(v145, *(float32x2_t *)a19.i8);
  float v148 = fabsf(vmlas_n_f32((float)-v146.f32[1] * v147.f32[0], v147.f32[1], v146.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v147, v147))), 0.01));
  float v149 = vmlas_n_f32(vmuls_lane_f32(v147.f32[1], v146, 1), v147.f32[0], v146.f32[0]);
  float v150 = sqrtf(vaddv_f32(vmul_f32(v146, v146)));
  if (v149 >= 0.0) {
    float v150 = v148;
  }
  float32x2_t v151 = vsub_f32(v45, v145);
  float v152 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v147, v151).i32[1]), v147.f32[0], v151.f32[0]);
  float v153 = sqrtf(vaddv_f32(vmul_f32(v151, v151)));
  if (v152 < 0.0) {
    float v153 = v150;
  }
  float v154 = fminf(v144, v153);
  float32x2_t v155 = (float32x2_t)vextq_s8(a20, a20, 8uLL).u64[0];
  float32x2_t v156 = vsub_f32(v45, *(float32x2_t *)a20.i8);
  float32x2_t v157 = vsub_f32(v155, *(float32x2_t *)a20.i8);
  float v158 = fabsf(vmlas_n_f32((float)-v156.f32[1] * v157.f32[0], v157.f32[1], v156.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v157, v157))), 0.01));
  float v159 = vmlas_n_f32(vmuls_lane_f32(v157.f32[1], v156, 1), v157.f32[0], v156.f32[0]);
  float v160 = sqrtf(vaddv_f32(vmul_f32(v156, v156)));
  if (v159 >= 0.0) {
    float v160 = v158;
  }
  float32x2_t v161 = vsub_f32(v45, v155);
  float v162 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v157, v161).i32[1]), v157.f32[0], v161.f32[0]);
  float v163 = sqrtf(vaddv_f32(vmul_f32(v161, v161)));
  if (v162 < 0.0) {
    float v163 = v160;
  }
  float v164 = fminf(v154, v163);
  float32x2_t v165 = (float32x2_t)vextq_s8(a21, a21, 8uLL).u64[0];
  float32x2_t v166 = vsub_f32(v45, *(float32x2_t *)a21.i8);
  float32x2_t v167 = vsub_f32(v165, *(float32x2_t *)a21.i8);
  float v168 = fabsf(vmlas_n_f32((float)-v166.f32[1] * v167.f32[0], v167.f32[1], v166.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v167, v167))), 0.01));
  float v169 = vmlas_n_f32(vmuls_lane_f32(v167.f32[1], v166, 1), v167.f32[0], v166.f32[0]);
  float v170 = sqrtf(vaddv_f32(vmul_f32(v166, v166)));
  if (v169 >= 0.0) {
    float v170 = v168;
  }
  float32x2_t v171 = vsub_f32(v45, v165);
  float v172 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v167, v171).i32[1]), v167.f32[0], v171.f32[0]);
  float v173 = sqrtf(vaddv_f32(vmul_f32(v171, v171)));
  if (v172 < 0.0) {
    float v173 = v170;
  }
  float v174 = fminf(v164, v173);
  float32x2_t v175 = (float32x2_t)vextq_s8(a22, a22, 8uLL).u64[0];
  float32x2_t v176 = vsub_f32(v45, *(float32x2_t *)a22.i8);
  float32x2_t v177 = vsub_f32(v175, *(float32x2_t *)a22.i8);
  float v178 = fabsf(vmlas_n_f32((float)-v176.f32[1] * v177.f32[0], v177.f32[1], v176.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v177, v177))), 0.01));
  float v179 = vmlas_n_f32(vmuls_lane_f32(v177.f32[1], v176, 1), v177.f32[0], v176.f32[0]);
  float v180 = sqrtf(vaddv_f32(vmul_f32(v176, v176)));
  if (v179 >= 0.0) {
    float v180 = v178;
  }
  float32x2_t v181 = vsub_f32(v45, v175);
  float v182 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v177, v181).i32[1]), v177.f32[0], v181.f32[0]);
  float v183 = sqrtf(vaddv_f32(vmul_f32(v181, v181)));
  if (v182 < 0.0) {
    float v183 = v180;
  }
  float v184 = fminf(v174, v183);
  float32x2_t v185 = (float32x2_t)vextq_s8(a23, a23, 8uLL).u64[0];
  float32x2_t v186 = vsub_f32(v45, *(float32x2_t *)a23.i8);
  float32x2_t v187 = vsub_f32(v185, *(float32x2_t *)a23.i8);
  float v188 = fabsf(vmlas_n_f32((float)-v186.f32[1] * v187.f32[0], v187.f32[1], v186.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v187, v187))), 0.01));
  float v189 = vmlas_n_f32(vmuls_lane_f32(v187.f32[1], v186, 1), v187.f32[0], v186.f32[0]);
  float v190 = sqrtf(vaddv_f32(vmul_f32(v186, v186)));
  if (v189 >= 0.0) {
    float v190 = v188;
  }
  float32x2_t v191 = vsub_f32(v45, v185);
  float v192 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v187, v191).i32[1]), v187.f32[0], v191.f32[0]);
  float v193 = sqrtf(vaddv_f32(vmul_f32(v191, v191)));
  if (v192 < 0.0) {
    float v193 = v190;
  }
  float v194 = fminf(v184, v193);
  float32x2_t v195 = (float32x2_t)vextq_s8(a24, a24, 8uLL).u64[0];
  float32x2_t v196 = vsub_f32(v45, *(float32x2_t *)a24.i8);
  float32x2_t v197 = vsub_f32(v195, *(float32x2_t *)a24.i8);
  float v198 = fabsf(vmlas_n_f32((float)-v196.f32[1] * v197.f32[0], v197.f32[1], v196.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v197, v197))), 0.01));
  float v199 = vmlas_n_f32(vmuls_lane_f32(v197.f32[1], v196, 1), v197.f32[0], v196.f32[0]);
  float v200 = sqrtf(vaddv_f32(vmul_f32(v196, v196)));
  if (v199 >= 0.0) {
    float v200 = v198;
  }
  float32x2_t v201 = vsub_f32(v45, v195);
  float v202 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v197, v201).i32[1]), v197.f32[0], v201.f32[0]);
  float v203 = sqrtf(vaddv_f32(vmul_f32(v201, v201)));
  if (v202 < 0.0) {
    float v203 = v200;
  }
  float v204 = fminf(v194, v203);
  float32x2_t v205 = (float32x2_t)vextq_s8(a25, a25, 8uLL).u64[0];
  float32x2_t v206 = vsub_f32(v45, *(float32x2_t *)a25.i8);
  float32x2_t v207 = vsub_f32(v205, *(float32x2_t *)a25.i8);
  float v208 = fabsf(vmlas_n_f32((float)-v206.f32[1] * v207.f32[0], v207.f32[1], v206.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v207, v207))), 0.01));
  float v209 = vmlas_n_f32(vmuls_lane_f32(v207.f32[1], v206, 1), v207.f32[0], v206.f32[0]);
  float v210 = sqrtf(vaddv_f32(vmul_f32(v206, v206)));
  if (v209 >= 0.0) {
    float v210 = v208;
  }
  float32x2_t v211 = vsub_f32(v45, v205);
  float v212 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v207, v211).i32[1]), v207.f32[0], v211.f32[0]);
  float v213 = sqrtf(vaddv_f32(vmul_f32(v211, v211)));
  if (v212 < 0.0) {
    float v213 = v210;
  }
  float v214 = fminf(v204, v213);
  float32x2_t v215 = (float32x2_t)vextq_s8(a26, a26, 8uLL).u64[0];
  float32x2_t v216 = vsub_f32(v45, *(float32x2_t *)a26.i8);
  float32x2_t v217 = vsub_f32(v215, *(float32x2_t *)a26.i8);
  float v218 = fabsf(vmlas_n_f32((float)-v216.f32[1] * v217.f32[0], v217.f32[1], v216.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v217, v217))), 0.01));
  float v219 = vmlas_n_f32(vmuls_lane_f32(v217.f32[1], v216, 1), v217.f32[0], v216.f32[0]);
  float v220 = sqrtf(vaddv_f32(vmul_f32(v216, v216)));
  if (v219 >= 0.0) {
    float v220 = v218;
  }
  float32x2_t v221 = vsub_f32(v45, v215);
  float v222 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v217, v221).i32[1]), v217.f32[0], v221.f32[0]);
  float v223 = sqrtf(vaddv_f32(vmul_f32(v221, v221)));
  if (v222 < 0.0) {
    float v223 = v220;
  }
  float v224 = fminf(v214, v223);
  float32x2_t v225 = (float32x2_t)vextq_s8(a27, a27, 8uLL).u64[0];
  float32x2_t v226 = vsub_f32(v45, *(float32x2_t *)a27.i8);
  float32x2_t v227 = vsub_f32(v225, *(float32x2_t *)a27.i8);
  float v228 = fabsf(vmlas_n_f32((float)-v226.f32[1] * v227.f32[0], v227.f32[1], v226.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v227, v227))), 0.01));
  float v229 = vmlas_n_f32(vmuls_lane_f32(v227.f32[1], v226, 1), v227.f32[0], v226.f32[0]);
  float v230 = sqrtf(vaddv_f32(vmul_f32(v226, v226)));
  if (v229 >= 0.0) {
    float v230 = v228;
  }
  float32x2_t v231 = vsub_f32(v45, v225);
  float v232 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v227, v231).i32[1]), v227.f32[0], v231.f32[0]);
  float v233 = sqrtf(vaddv_f32(vmul_f32(v231, v231)));
  if (v232 < 0.0) {
    float v233 = v230;
  }
  float v234 = fminf(v224, v233);
  float32x2_t v235 = (float32x2_t)vextq_s8(a28, a28, 8uLL).u64[0];
  float32x2_t v236 = vsub_f32(v45, *(float32x2_t *)a28.i8);
  float32x2_t v237 = vsub_f32(v235, *(float32x2_t *)a28.i8);
  float v238 = fabsf(vmlas_n_f32((float)-v236.f32[1] * v237.f32[0], v237.f32[1], v236.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v237, v237))), 0.01));
  float v239 = vmlas_n_f32(vmuls_lane_f32(v237.f32[1], v236, 1), v237.f32[0], v236.f32[0]);
  float v240 = sqrtf(vaddv_f32(vmul_f32(v236, v236)));
  if (v239 >= 0.0) {
    float v240 = v238;
  }
  float32x2_t v241 = vsub_f32(v45, v235);
  float v242 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v237, v241).i32[1]), v237.f32[0], v241.f32[0]);
  float v243 = sqrtf(vaddv_f32(vmul_f32(v241, v241)));
  if (v242 < 0.0) {
    float v243 = v240;
  }
  float v244 = fminf(v234, v243);
  float32x2_t v245 = (float32x2_t)vextq_s8(a29, a29, 8uLL).u64[0];
  float32x2_t v246 = vsub_f32(v45, *(float32x2_t *)a29.i8);
  float32x2_t v247 = vsub_f32(v245, *(float32x2_t *)a29.i8);
  float v248 = fabsf(vmlas_n_f32((float)-v246.f32[1] * v247.f32[0], v247.f32[1], v246.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v247, v247))), 0.01));
  float v249 = vmlas_n_f32(vmuls_lane_f32(v247.f32[1], v246, 1), v247.f32[0], v246.f32[0]);
  float v250 = sqrtf(vaddv_f32(vmul_f32(v246, v246)));
  if (v249 >= 0.0) {
    float v250 = v248;
  }
  float32x2_t v251 = vsub_f32(v45, v245);
  float v252 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v247, v251).i32[1]), v247.f32[0], v251.f32[0]);
  float v253 = sqrtf(vaddv_f32(vmul_f32(v251, v251)));
  if (v252 < 0.0) {
    float v253 = v250;
  }
  float v254 = fminf(v244, v253);
  float32x2_t v255 = (float32x2_t)vextq_s8(a30, a30, 8uLL).u64[0];
  float32x2_t v256 = vsub_f32(v45, *(float32x2_t *)a30.i8);
  float32x2_t v257 = vsub_f32(v255, *(float32x2_t *)a30.i8);
  float v258 = fabsf(vmlas_n_f32((float)-v256.f32[1] * v257.f32[0], v257.f32[1], v256.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v257, v257))), 0.01));
  float v259 = vmlas_n_f32(vmuls_lane_f32(v257.f32[1], v256, 1), v257.f32[0], v256.f32[0]);
  float v260 = sqrtf(vaddv_f32(vmul_f32(v256, v256)));
  if (v259 >= 0.0) {
    float v260 = v258;
  }
  float32x2_t v261 = vsub_f32(v45, v255);
  float v262 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v257, v261).i32[1]), v257.f32[0], v261.f32[0]);
  float v263 = sqrtf(vaddv_f32(vmul_f32(v261, v261)));
  if (v262 < 0.0) {
    float v263 = v260;
  }
  float v264 = fminf(v254, v263);
  float32x2_t v265 = (float32x2_t)vextq_s8(a31, a31, 8uLL).u64[0];
  float32x2_t v266 = vsub_f32(v45, *(float32x2_t *)a31.i8);
  float32x2_t v267 = vsub_f32(v265, *(float32x2_t *)a31.i8);
  float v268 = fabsf(vmlas_n_f32((float)-v266.f32[1] * v267.f32[0], v267.f32[1], v266.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v267, v267))), 0.01));
  float v269 = vmlas_n_f32(vmuls_lane_f32(v267.f32[1], v266, 1), v267.f32[0], v266.f32[0]);
  float v270 = sqrtf(vaddv_f32(vmul_f32(v266, v266)));
  if (v269 >= 0.0) {
    float v270 = v268;
  }
  float32x2_t v271 = vsub_f32(v45, v265);
  float v272 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v267, v271).i32[1]), v267.f32[0], v271.f32[0]);
  float v273 = sqrtf(vaddv_f32(vmul_f32(v271, v271)));
  if (v272 < 0.0) {
    float v273 = v270;
  }
  float v274 = fminf(v264, v273);
  float32x2_t v275 = (float32x2_t)vextq_s8(a32, a32, 8uLL).u64[0];
  float32x2_t v276 = vsub_f32(v45, *(float32x2_t *)a32.i8);
  float32x2_t v277 = vsub_f32(v275, *(float32x2_t *)a32.i8);
  float v278 = fabsf(vmlas_n_f32((float)-v276.f32[1] * v277.f32[0], v277.f32[1], v276.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v277, v277))), 0.01));
  float v279 = vmlas_n_f32(vmuls_lane_f32(v277.f32[1], v276, 1), v277.f32[0], v276.f32[0]);
  float v280 = sqrtf(vaddv_f32(vmul_f32(v276, v276)));
  if (v279 >= 0.0) {
    float v280 = v278;
  }
  float32x2_t v281 = vsub_f32(v45, v275);
  float v282 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v277, v281).i32[1]), v277.f32[0], v281.f32[0]);
  float v283 = sqrtf(vaddv_f32(vmul_f32(v281, v281)));
  if (v282 < 0.0) {
    float v283 = v280;
  }
  float v284 = fminf(v274, v283);
  float32x2_t v285 = (float32x2_t)vextq_s8(a33, a33, 8uLL).u64[0];
  float32x2_t v286 = vsub_f32(v45, *(float32x2_t *)a33.i8);
  float32x2_t v287 = vsub_f32(v285, *(float32x2_t *)a33.i8);
  float v288 = fabsf(vmlas_n_f32((float)-v286.f32[1] * v287.f32[0], v287.f32[1], v286.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v287, v287))), 0.01));
  float v289 = vmlas_n_f32(vmuls_lane_f32(v287.f32[1], v286, 1), v287.f32[0], v286.f32[0]);
  float v290 = sqrtf(vaddv_f32(vmul_f32(v286, v286)));
  if (v289 >= 0.0) {
    float v290 = v288;
  }
  float32x2_t v291 = vsub_f32(v45, v285);
  float v292 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v287, v291).i32[1]), v287.f32[0], v291.f32[0]);
  float v293 = sqrtf(vaddv_f32(vmul_f32(v291, v291)));
  if (v292 < 0.0) {
    float v293 = v290;
  }
  float v294 = fminf(v284, v293);
  float32x2_t v295 = (float32x2_t)vextq_s8(a34, a34, 8uLL).u64[0];
  float32x2_t v296 = vsub_f32(v45, *(float32x2_t *)a34.i8);
  float32x2_t v297 = vsub_f32(v295, *(float32x2_t *)a34.i8);
  float v298 = fabsf(vmlas_n_f32((float)-v296.f32[1] * v297.f32[0], v297.f32[1], v296.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v297, v297))), 0.01));
  float v299 = vmlas_n_f32(vmuls_lane_f32(v297.f32[1], v296, 1), v297.f32[0], v296.f32[0]);
  float v300 = sqrtf(vaddv_f32(vmul_f32(v296, v296)));
  if (v299 >= 0.0) {
    float v300 = v298;
  }
  float32x2_t v301 = vsub_f32(v45, v295);
  float v302 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v297, v301).i32[1]), v297.f32[0], v301.f32[0]);
  float v303 = sqrtf(vaddv_f32(vmul_f32(v301, v301)));
  if (v302 < 0.0) {
    float v303 = v300;
  }
  float v304 = fminf(v294, v303);
  float32x2_t v305 = (float32x2_t)vextq_s8(a35, a35, 8uLL).u64[0];
  float32x2_t v306 = vsub_f32(v45, *(float32x2_t *)a35.i8);
  float32x2_t v307 = vsub_f32(v305, *(float32x2_t *)a35.i8);
  float v308 = fabsf(vmlas_n_f32((float)-v306.f32[1] * v307.f32[0], v307.f32[1], v306.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v307, v307))), 0.01));
  float v309 = vmlas_n_f32(vmuls_lane_f32(v307.f32[1], v306, 1), v307.f32[0], v306.f32[0]);
  float v310 = sqrtf(vaddv_f32(vmul_f32(v306, v306)));
  if (v309 >= 0.0) {
    float v310 = v308;
  }
  float32x2_t v311 = vsub_f32(v45, v305);
  float v312 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v307, v311).i32[1]), v307.f32[0], v311.f32[0]);
  float v313 = sqrtf(vaddv_f32(vmul_f32(v311, v311)));
  if (v312 < 0.0) {
    float v313 = v310;
  }
  float v314 = fminf(v304, v313);
  float32x2_t v315 = (float32x2_t)vextq_s8(a36, a36, 8uLL).u64[0];
  float32x2_t v316 = vsub_f32(v45, *(float32x2_t *)a36.i8);
  float32x2_t v317 = vsub_f32(v315, *(float32x2_t *)a36.i8);
  float v318 = fabsf(vmlas_n_f32((float)-v316.f32[1] * v317.f32[0], v317.f32[1], v316.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v317, v317))), 0.01));
  float v319 = vmlas_n_f32(vmuls_lane_f32(v317.f32[1], v316, 1), v317.f32[0], v316.f32[0]);
  float v320 = sqrtf(vaddv_f32(vmul_f32(v316, v316)));
  if (v319 >= 0.0) {
    float v320 = v318;
  }
  float32x2_t v321 = vsub_f32(v45, v315);
  float v322 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v317, v321).i32[1]), v317.f32[0], v321.f32[0]);
  float v323 = sqrtf(vaddv_f32(vmul_f32(v321, v321)));
  if (v322 < 0.0) {
    float v323 = v320;
  }
  float v324 = fminf(v314, v323);
  float32x2_t v325 = (float32x2_t)vextq_s8(a37, a37, 8uLL).u64[0];
  float32x2_t v326 = vsub_f32(v45, *(float32x2_t *)a37.i8);
  float32x2_t v327 = vsub_f32(v325, *(float32x2_t *)a37.i8);
  float v328 = fabsf(vmlas_n_f32((float)-v326.f32[1] * v327.f32[0], v327.f32[1], v326.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v327, v327))), 0.01));
  float v329 = vmlas_n_f32(vmuls_lane_f32(v327.f32[1], v326, 1), v327.f32[0], v326.f32[0]);
  float v330 = sqrtf(vaddv_f32(vmul_f32(v326, v326)));
  if (v329 >= 0.0) {
    float v330 = v328;
  }
  float32x2_t v331 = vsub_f32(v45, v325);
  float v332 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v327, v331).i32[1]), v327.f32[0], v331.f32[0]);
  float v333 = sqrtf(vaddv_f32(vmul_f32(v331, v331)));
  if (v332 < 0.0) {
    float v333 = v330;
  }
  float v334 = fminf(v324, v333);
  float32x2_t v335 = (float32x2_t)vextq_s8(a38, a38, 8uLL).u64[0];
  float32x2_t v336 = vsub_f32(v45, *(float32x2_t *)a38.i8);
  float32x2_t v337 = vsub_f32(v335, *(float32x2_t *)a38.i8);
  float v338 = fabsf(vmlas_n_f32((float)-v336.f32[1] * v337.f32[0], v337.f32[1], v336.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v337, v337))), 0.01));
  float v339 = vmlas_n_f32(vmuls_lane_f32(v337.f32[1], v336, 1), v337.f32[0], v336.f32[0]);
  float v340 = sqrtf(vaddv_f32(vmul_f32(v336, v336)));
  if (v339 >= 0.0) {
    float v340 = v338;
  }
  float32x2_t v341 = vsub_f32(v45, v335);
  float v342 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v337, v341).i32[1]), v337.f32[0], v341.f32[0]);
  float v343 = sqrtf(vaddv_f32(vmul_f32(v341, v341)));
  if (v342 < 0.0) {
    float v343 = v340;
  }
  float v344 = fminf(v334, v343);
  float32x2_t v345 = (float32x2_t)vextq_s8(a39, a39, 8uLL).u64[0];
  float32x2_t v346 = vsub_f32(v45, *(float32x2_t *)a39.i8);
  float32x2_t v347 = vsub_f32(v345, *(float32x2_t *)a39.i8);
  BOOL v348 = vmlas_n_f32(vmuls_lane_f32(v347.f32[1], v346, 1), v347.f32[0], v346.f32[0]) < 0.0;
  float v349 = fabsf(vmlas_n_f32((float)-v346.f32[1] * v347.f32[0], v347.f32[1], v346.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v347, v347))), 0.01));
  float v350 = sqrtf(vaddv_f32(vmul_f32(v346, v346)));
  if (!v348) {
    float v350 = v349;
  }
  float32x2_t v351 = vsub_f32(v45, v345);
  float v352 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v347, v351).i32[1]), v347.f32[0], v351.f32[0]);
  float v353 = sqrtf(vaddv_f32(vmul_f32(v351, v351)));
  if (v352 < 0.0) {
    float v353 = v350;
  }
  float v354 = fminf(v344, v353);
  float32x2_t v355 = (float32x2_t)vextq_s8(a40, a40, 8uLL).u64[0];
  float32x2_t v356 = vsub_f32(v45, *(float32x2_t *)a40.i8);
  float32x2_t v357 = vsub_f32(v355, *(float32x2_t *)a40.i8);
  float v358 = vmlas_n_f32(vmuls_lane_f32(v357.f32[1], v356, 1), v357.f32[0], v356.f32[0]);
  float v359 = fabsf(vmlas_n_f32((float)-v356.f32[1] * v357.f32[0], v357.f32[1], v356.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v357, v357))), 0.01));
  float v360 = sqrtf(vaddv_f32(vmul_f32(v356, v356)));
  if (v358 < 0.0) {
    float v359 = v360;
  }
  float32x2_t v361 = vsub_f32(v45, v355);
  float v362 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v357, v361).i32[1]), v357.f32[0], v361.f32[0]);
  float v363 = sqrtf(vaddv_f32(vmul_f32(v361, v361)));
  if (v362 < 0.0) {
    float v363 = v359;
  }
  float v364 = fminf(v354, v363);
  float v365 = 1.0;
  if ((float)(v44 - v364) <= 1.0) {
    float v365 = v44 - v364;
  }
  float v366 = 0.0;
  if ((float)(v44 - v364) >= 0.0) {
    float v366 = v365;
  }
  double v367 = v364 - (v44 + -1.0);
  float v368 = (v366 * -2.0 + 3.0) * v366 * v366;
  int8x16_t v369 = vandq_s8((int8x16_t)vmulq_n_f32(a43, v368), (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16((float)(v364 - v44) < 0.0)), 0x1FuLL)));
  float v370 = v367;
  *(void *)&double result = vmulq_n_f32((float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v370 < 0.0)), 0x1FuLL)), (int8x16_t)a43, v369), a44).u64[0];
  return result;
}

void CI::f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f_clr_f(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  float v144 = *(double (**)(__n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double))(a1 + 24);
  int v143 = *(_DWORD *)(v9 + 16);
  uint64_t v142 = *(void *)(v9 + 8);
  int v141 = *(_DWORD *)(v9 + 40);
  uint64_t v140 = *(void *)(v9 + 32);
  int v139 = *(_DWORD *)(v9 + 64);
  uint64_t v138 = *(void *)(v9 + 56);
  int v137 = *(_DWORD *)(v9 + 88);
  uint64_t v136 = *(void *)(v9 + 80);
  int v135 = *(_DWORD *)(v9 + 112);
  uint64_t v134 = *(void *)(v9 + 104);
  int v133 = *(_DWORD *)(v9 + 136);
  uint64_t v132 = *(void *)(v9 + 128);
  int v10 = *(_DWORD *)(v9 + 160);
  uint64_t v131 = *(void *)(v9 + 152);
  int v130 = *(_DWORD *)(v9 + 184);
  uint64_t v129 = *(void *)(v9 + 176);
  int v128 = *(_DWORD *)(v9 + 208);
  uint64_t v127 = *(void *)(v9 + 200);
  int v125 = *(_DWORD *)(v9 + 232);
  uint64_t v124 = *(void *)(v9 + 224);
  int v120 = *(_DWORD *)(v9 + 256);
  uint64_t v119 = *(void *)(v9 + 248);
  int v116 = *(_DWORD *)(v9 + 280);
  uint64_t v115 = *(void *)(v9 + 272);
  int v112 = *(_DWORD *)(v9 + 304);
  int v11 = *(unsigned __int8 *)(a1 + 64);
  uint64_t v107 = *(void *)(v9 + 296);
  int v106 = *(_DWORD *)(v9 + 328);
  uint64_t v105 = *(void *)(v9 + 320);
  int v104 = *(_DWORD *)(v9 + 352);
  uint64_t v103 = *(void *)(v9 + 344);
  int v12 = *(_DWORD *)(v9 + 376);
  uint64_t v102 = *(void *)(v9 + 368);
  int v13 = *(_DWORD *)(v9 + 400);
  uint64_t v101 = *(void *)(v9 + 392);
  int v14 = *(_DWORD *)(v9 + 424);
  uint64_t v100 = *(void *)(v9 + 416);
  int v15 = *(_DWORD *)(v9 + 448);
  uint64_t v99 = *(void *)(v9 + 440);
  int v98 = *(_DWORD *)(v9 + 472);
  uint64_t v16 = *(void *)(v9 + 464);
  int v97 = *(_DWORD *)(v9 + 496);
  uint64_t v17 = *(void *)(v9 + 488);
  int v96 = *(_DWORD *)(v9 + 520);
  uint64_t v18 = *(const vec2 **)(v9 + 512);
  int v95 = *(_DWORD *)(v9 + 544);
  uint64_t v19 = *(void *)(v9 + 536);
  int v94 = *(_DWORD *)(v9 + 568);
  uint64_t v20 = *(void *)(v9 + 560);
  int v93 = *(_DWORD *)(v9 + 592);
  uint64_t v21 = *(void *)(v9 + 584);
  int v92 = *(_DWORD *)(v9 + 616);
  uint64_t v22 = *(void *)(v9 + 608);
  int v23 = *(_DWORD *)(v9 + 640);
  uint64_t v24 = *(void *)(v9 + 632);
  int v25 = *(_DWORD *)(v9 + 664);
  uint64_t v26 = *(void *)(v9 + 656);
  int v27 = *(_DWORD *)(v9 + 688);
  uint64_t v28 = *(void *)(v9 + 680);
  int v29 = *(_DWORD *)(v9 + 712);
  uint64_t v30 = *(void *)(v9 + 704);
  int v31 = *(_DWORD *)(v9 + 736);
  uint64_t v32 = *(void *)(v9 + 728);
  int v33 = *(_DWORD *)(v9 + 760);
  uint64_t v34 = *(void *)(v9 + 752);
  uint64_t v126 = *(void *)(v9 + 776);
  if (v11)
  {
    uint64_t v89 = *(void *)(v9 + 536);
    float v90 = *(const vec2 **)(v9 + 512);
    int v121 = *(_DWORD *)(v9 + 376);
    int v117 = *(_DWORD *)(v9 + 400);
    int v113 = *(_DWORD *)(v9 + 424);
    int v110 = *(_DWORD *)(v9 + 448);
    uint64_t v108 = *(void *)(v9 + 464);
    uint64_t v91 = *(void *)(v9 + 488);
    uint64_t v87 = *(void *)(v9 + 584);
    uint64_t v88 = *(void *)(v9 + 560);
    uint64_t v86 = *(void *)(v9 + 608);
    int v85 = *(_DWORD *)(v9 + 640);
    int v84 = *(_DWORD *)(v9 + 664);
    int v83 = *(_DWORD *)(v9 + 688);
    int v82 = *(_DWORD *)(v9 + 712);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 848)), v18);
    int v29 = v82;
    int v27 = v83;
    int v25 = v84;
    int v23 = v85;
    uint64_t v22 = v86;
    uint64_t v21 = v87;
    uint64_t v20 = v88;
    uint64_t v19 = v89;
    uint64_t v18 = v90;
    uint64_t v17 = v91;
    uint64_t v16 = v108;
    int v15 = v110;
    int v14 = v113;
    int v13 = v117;
    int v12 = v121;
  }
  int v35 = (long long *)(a3 + 16 * v34);
  if (v33 != 5) {
    int v35 = (long long *)(a2 + (v34 << 6));
  }
  float v123 = v35;
  if (v31 == 5) {
    int v36 = (long long *)(a3 + 16 * v32);
  }
  else {
    int v36 = (long long *)(a2 + (v32 << 6));
  }
  float v122 = v36;
  if (v29 == 5) {
    int v37 = (long long *)(a3 + 16 * v30);
  }
  else {
    int v37 = (long long *)(a2 + (v30 << 6));
  }
  float v118 = v37;
  if (v27 == 5) {
    float v38 = (long long *)(a3 + 16 * v28);
  }
  else {
    float v38 = (long long *)(a2 + (v28 << 6));
  }
  float v114 = v38;
  if (v25 == 5) {
    float32x2_t v39 = (long long *)(a3 + 16 * v26);
  }
  else {
    float32x2_t v39 = (long long *)(a2 + (v26 << 6));
  }
  float32x2_t v111 = v39;
  if (v23 == 5) {
    float32x2_t v40 = (long long *)(a3 + 16 * v24);
  }
  else {
    float32x2_t v40 = (long long *)(a2 + (v24 << 6));
  }
  float v109 = v40;
  float32x2_t v41 = (double *)(a3 + 16 * v22);
  float v42 = (double *)(a2 + (v22 << 6));
  if (v92 != 5) {
    float32x2_t v41 = v42;
  }
  float v43 = (double *)(a3 + 16 * v21);
  float v44 = (double *)(a2 + (v21 << 6));
  if (v93 != 5) {
    float v43 = v44;
  }
  float32x2_t v45 = (double *)(a3 + 16 * v20);
  float32x2_t v46 = (double *)(a2 + (v20 << 6));
  if (v94 != 5) {
    float32x2_t v45 = v46;
  }
  float32x2_t v47 = (double *)(a3 + 16 * v19);
  float32x2_t v48 = (double *)(a2 + (v19 << 6));
  if (v95 != 5) {
    float32x2_t v47 = v48;
  }
  float v49 = (double *)(a3 + 16 * (void)v18);
  float v50 = (double *)(a2 + ((void)v18 << 6));
  if (v96 != 5) {
    float v49 = v50;
  }
  float v51 = (double *)(a3 + 16 * v17);
  float32x2_t v52 = (double *)(a2 + (v17 << 6));
  if (v97 != 5) {
    float v51 = v52;
  }
  float v53 = (double *)(a3 + 16 * v16);
  float v54 = (double *)(a2 + (v16 << 6));
  if (v98 != 5) {
    float v53 = v54;
  }
  float32x2_t v55 = (double *)(a3 + 16 * v99);
  if (v15 != 5) {
    float32x2_t v55 = (double *)(a2 + (v99 << 6));
  }
  float32x2_t v56 = (double *)(a3 + 16 * v100);
  if (v14 != 5) {
    float32x2_t v56 = (double *)(a2 + (v100 << 6));
  }
  float32x2_t v57 = (double *)(a3 + 16 * v101);
  if (v13 != 5) {
    float32x2_t v57 = (double *)(a2 + (v101 << 6));
  }
  float v58 = (double *)(a3 + 16 * v102);
  if (v12 != 5) {
    float v58 = (double *)(a2 + (v102 << 6));
  }
  float v59 = (double *)(a3 + 16 * v103);
  if (v104 != 5) {
    float v59 = (double *)(a2 + (v103 << 6));
  }
  float v60 = (double *)(a3 + 16 * v105);
  if (v106 != 5) {
    float v60 = (double *)(a2 + (v105 << 6));
  }
  float32x2_t v61 = (double *)(a3 + 16 * v107);
  if (v112 != 5) {
    float32x2_t v61 = (double *)(a2 + (v107 << 6));
  }
  float v62 = (double *)(a3 + 16 * v115);
  if (v116 != 5) {
    float v62 = (double *)(a2 + (v115 << 6));
  }
  float v63 = (double *)(a3 + 16 * v119);
  if (v120 != 5) {
    float v63 = (double *)(a2 + (v119 << 6));
  }
  float v64 = (double *)(a3 + 16 * v124);
  if (v125 != 5) {
    float v64 = (double *)(a2 + (v124 << 6));
  }
  float32x2_t v65 = (double *)(a3 + 16 * v127);
  if (v128 != 5) {
    float32x2_t v65 = (double *)(a2 + (v127 << 6));
  }
  float32x2_t v66 = (__n128 *)(a3 + 16 * v129);
  if (v130 != 5) {
    float32x2_t v66 = (__n128 *)(a2 + (v129 << 6));
  }
  float32x2_t v67 = (__n128 *)(a3 + 16 * v131);
  if (v10 != 5) {
    float32x2_t v67 = (__n128 *)(a2 + (v131 << 6));
  }
  float v68 = (__n128 *)(a2 + (v132 << 6));
  if (v133 == 5) {
    float v68 = (__n128 *)(a3 + 16 * v132);
  }
  float v69 = (__n128 *)(a2 + (v134 << 6));
  if (v135 == 5) {
    float v69 = (__n128 *)(a3 + 16 * v134);
  }
  float v70 = (__n128 *)(a2 + (v136 << 6));
  if (v137 == 5) {
    float v70 = (__n128 *)(a3 + 16 * v136);
  }
  float32x2_t v71 = (__n128 *)(a2 + (v138 << 6));
  if (v139 == 5) {
    float32x2_t v71 = (__n128 *)(a3 + 16 * v138);
  }
  float v72 = (__n128 *)(a2 + (v140 << 6));
  if (v141 == 5) {
    float v72 = (__n128 *)(a3 + 16 * v140);
  }
  float v73 = (__n128 *)(a2 + (v142 << 6));
  if (v143 == 5) {
    float v73 = (__n128 *)(a3 + 16 * v142);
  }
  LODWORD(v81) = *(_DWORD *)(a2 + (v126 << 6));
  long long v79 = *v122;
  long long v80 = *v123;
  long long v77 = *v114;
  long long v78 = *v118;
  long long v75 = *v109;
  long long v76 = *v111;
  *(double *)&long long v74 = v144(*v73, *v72, *v71, *v70, *v69, *v68, *v67, *v66, *v65, v65[1], *v64, v64[1], *v63, v63[1], *v62, v62[1], *v61, v61[1], *v60,
                      v60[1],
                      *v59,
                      v59[1],
                      *v58,
                      v58[1],
                      *v57,
                      v57[1],
                      *v56,
                      v56[1],
                      *v55,
                      v55[1],
                      *v53,
                      v53[1],
                      *v51,
                      v51[1],
                      *v49,
                      v49[1],
                      *v47,
                      v47[1],
                      *v45,
                      v45[1],
                      *v43,
                      v43[1],
                      *v41,
                      v41[1],
                      *(double *)&v75,
                      *((double *)&v75 + 1),
                      *(double *)&v76,
                      *((double *)&v76 + 1),
                      *(double *)&v77,
                      *((double *)&v77 + 1),
                      *(double *)&v78,
                      *((double *)&v78 + 1),
                      *(double *)&v79,
                      *((double *)&v79 + 1),
                      *(double *)&v80,
                      *((double *)&v80 + 1),
                      v81);
  *(_OWORD *)(a3 + 16 * a7) = v74;
}

objc_object *metaFilterForFilter(uint64_t a1, objc_object *a2)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  if (metaFilterForFilter::onceToken != -1) {
    dispatch_once(&metaFilterForFilter::onceToken, &__block_literal_global_47);
  }
  superclass = (objc_class *)objc_opt_class();
  float64x2_t v3 = [NSStringFromClass(superclass) stringByAppendingString:@"_wrapper"];
  uint64_t v4 = (void *)wrappedClassDict;
  objc_sync_enter((id)wrappedClassDict);
  uint64_t v5 = [MEMORY[0x1E4F29238] valueWithPointer:objc_opt_class()];
  float v6 = (void *)[(id)wrappedClassDict objectForKeyedSubscript:v5];
  if (v6)
  {
    ClassPair = (objc_class *)[v6 pointerValue];
    if (ClassPair)
    {
      objc_sync_exit(v4);
      goto LABEL_63;
    }
  }
  ClassPair = objc_allocateClassPair(superclass, [(NSString *)v3 UTF8String], 0x100uLL);
  uint64_t v8 = [MEMORY[0x1E4F29238] valueWithPointer:ClassPair];
  [(id)wrappedClassDict setObject:v8 forKeyedSubscript:v5];
  objc_sync_exit(v4);
  long long v55 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  uint64_t v9 = (void *)[(objc_object *)a2 inputKeys];
  uint64_t v10 = [v9 countByEnumeratingWithState:&v55 objects:v64 count:16];
  if (v10)
  {
    uint64_t v11 = *(void *)v56;
    do
    {
      uint64_t v12 = 0;
      do
      {
        if (*(void *)v56 != v11) {
          objc_enumerationMutation(v9);
        }
        int v13 = *(void **)(*((void *)&v55 + 1) + 8 * v12);
        InstanceVariable = object_getInstanceVariable(a2, (const char *)[v13 UTF8String], 0);
        if (!InstanceVariable)
        {
          NSLog(&cfstr_IvarIsNilForKe.isa, v13);
          goto LABEL_30;
        }
        TypeEncoding = (char *)ivar_getTypeEncoding(InstanceVariable);
        uint64_t v16 = class_getInstanceVariable(ClassPair, (const char *)[v13 UTF8String]);
        if (v16)
        {
          uint64_t v17 = ivar_getTypeEncoding(v16);
          if (v17 && strcmp(TypeEncoding, v17)) {
            NSLog(&cfstr_NotAddingNewKe.isa, TypeEncoding, v17);
          }
          goto LABEL_30;
        }
        std::string::basic_string[abi:nn180100]<0>(&__p, TypeEncoding);
        Class = 0;
        *(_OWORD *)&name.__r_.__value_.__r.__words[1] = 0uLL;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_p = &__p;
        }
        else {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        unsigned int v20 = p_p->__r_.__value_.__s.__data_[0] - 64;
        if (v20 <= 0x33)
        {
          if (((1 << v20) & 0xA1258000A120CLL) != 0)
          {
            *((unsigned char *)&name.__r_.__value_.__s + 23) = 8;
            name.__r_.__value_.__r.__words[0] = 0x7265626D754E534ELL;
            p_std::string name = &name;
            goto LABEL_23;
          }
          if (p_p->__r_.__value_.__s.__data_[0] == 64)
          {
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              size_t size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            }
            else {
              size_t size = __p.__r_.__value_.__l.__size_;
            }
            if (size < 2)
            {
              uint64_t v26 = -1;
            }
            else
            {
              uint64_t v24 = &__p;
              if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                uint64_t v24 = (std::string *)__p.__r_.__value_.__r.__words[0];
              }
              int v25 = memchr((char *)&v24->__r_.__value_.__l.__data_ + 1, 34, size - 1);
              if (v25) {
                uint64_t v26 = v25 - (unsigned char *)p_p;
              }
              else {
                uint64_t v26 = -1;
              }
            }
            if (size <= v26 + 1)
            {
              uint64_t v28 = -1;
              if (size) {
                goto LABEL_48;
              }
              uint64_t v50 = -1;
LABEL_52:
              uint64_t v30 = v50;
            }
            else
            {
              int v27 = memchr((char *)&p_p->__r_.__value_.__l.__data_ + v26 + 1, 34, size - (v26 + 1));
              uint64_t v28 = v27 - (unsigned char *)p_p;
              if (!v27) {
                uint64_t v28 = -1;
              }
LABEL_48:
              uint64_t v50 = v28;
              int v29 = memchr(p_p, 60, size);
              if (!v29) {
                goto LABEL_52;
              }
              uint64_t v30 = v29 - (unsigned char *)p_p;
              if (v29 - (unsigned char *)p_p == -1) {
                goto LABEL_52;
              }
            }
            if (v26 == -1 || v30 == -1 || (unint64_t v31 = v30 - v26, v31 < 2)) {
              std::string::basic_string[abi:nn180100]<0>(&v60, "NSObject");
            }
            else {
              std::string::basic_string(&v60, &__p, v26 + 1, v31 - 1, (std::allocator<char> *)&v62);
            }
            std::string name = v60;
            if ((v60.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              p_std::string name = &name;
            }
            else {
              p_std::string name = (std::string *)v60.__r_.__value_.__r.__words[0];
            }
LABEL_23:
            Class = objc_getClass((const char *)p_name);
            if (SHIBYTE(name.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(name.__r_.__value_.__l.__data_);
            }
          }
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__p.__r_.__value_.__l.__data_);
          if (!Class) {
            goto LABEL_30;
          }
        }
        else if (!Class)
        {
          goto LABEL_30;
        }
        uint64_t v22 = [[NSStringFromClass(Class) stringByAppendingString:@" *"] UTF8String];
        if (!class_addIvar(ClassPair, (const char *)[v13 UTF8String], 8uLL, 3u, v22)) {
          metaFilterForFilter_cold_3();
        }
LABEL_30:
        ++v12;
      }
      while (v10 != v12);
      uint64_t v32 = [v9 countByEnumeratingWithState:&v55 objects:v64 count:16];
      uint64_t v10 = v32;
    }
    while (v32);
  }
  BOOL v33 = class_addIvar(ClassPair, "originalObject", 8uLL, 3u, "@\"CIFilter\"");
  BOOL v34 = class_addIvar(ClassPair, "inputOutputImage", 8uLL, 3u, "@\"CIImage\"");
  InstanceMethod = class_getInstanceMethod(superclass, sel_valueForUndefinedKey_);
  int v36 = method_getTypeEncoding(InstanceMethod);
  BOOL v37 = class_addMethod(ClassPair, sel_valueForUndefinedKey_, (IMP)valueForUndefinedKey, v36);
  float v38 = class_getInstanceMethod(superclass, sel_setValue_forUndefinedKey_);
  float32x2_t v39 = method_getTypeEncoding(v38);
  BOOL v40 = class_addMethod(ClassPair, sel_setValue_forUndefinedKey_, (IMP)setValueForUndefinedKey, v39);
  if (((v33 && v34 && v37) & v40 & class_addMethod(ClassPair, sel_valueForKey_, (IMP)valueForKey, v36) & 1) == 0) {
    metaFilterForFilter_cold_2();
  }
LABEL_63:
  float32x2_t v41 = (objc_object *)objc_alloc_init(ClassPair);
  setValueForObject(v41, &cfstr_Originalobject.isa, a2);
  long long v53 = 0u;
  long long v54 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  float v42 = (void *)[(objc_object *)a2 inputKeys];
  uint64_t v43 = [v42 countByEnumeratingWithState:&v51 objects:v63 count:16];
  if (v43)
  {
    uint64_t v44 = *(void *)v52;
    do
    {
      for (uint64_t i = 0; i != v43; ++i)
      {
        if (*(void *)v52 != v44) {
          objc_enumerationMutation(v42);
        }
        float32x2_t v46 = *(NSString **)(*((void *)&v51 + 1) + 8 * i);
        float32x2_t v47 = (objc_object *)[(objc_object *)a2 valueForKey:v46];
        setValueForObject(v41, v46, v47);
        if ((objc_object *)[(objc_object *)v41 valueForUndefinedKey:v46] != v47) {
          metaFilterForFilter_cold_1();
        }
      }
      uint64_t v43 = [v42 countByEnumeratingWithState:&v51 objects:v63 count:16];
    }
    while (v43);
  }
  return v41;
}

void sub_1937F0510(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  objc_sync_exit(v45);
  _Unwind_Resume(a1);
}

id __metaFilterForFilter_block_invoke()
{
  id result = (id)[MEMORY[0x1E4F1CA60] dictionary];
  wrappedClassDict = (uint64_t)result;
  return result;
}

objc_ivar *valueForUndefinedKey(objc_object *a1, objc_selector *a2, uint64_t a3, ...)
{
  va_start(va, a3);
  v5[0] = 0;
  va_copy((va_list)&v5[1], va);
  id result = object_getInstanceVariable(a1, "originalObject", v5);
  if (result) {
    return (objc_ivar *)objc_msgSend(object_getIvar(a1, result), "valueForKey:", a3);
  }
  return result;
}

objc_ivar *setValueForUndefinedKey(objc_object *a1, objc_selector *a2, objc_object *a3, NSString *a4, ...)
{
  id result = getValueForObject(a1, &cfstr_Originalobject.isa);
  if (result) {
    return setValueForObject((objc_object *)result, a4, a3);
  }
  return result;
}

Ivar valueForKey(objc_object *a1, objc_selector *a2, NSString *a3, ...)
{
  va_start(va, a3);
  if (object_getInstanceVariable(a1, [(NSString *)a3 UTF8String], &v5)) {
    return getValueForObject(a1, a3);
  }
  Ivar result = object_getInstanceVariable(a1, "originalObject", &v5);
  if (result) {
    return (Ivar)objc_msgSend(object_getIvar(a1, result), "valueForKey:", a3);
  }
  return result;
}

objc_ivar *setValueForObject(objc_object *a1, NSString *a2, objc_object *a3)
{
  Ivar result = object_getInstanceVariable(a1, [(NSString *)a2 UTF8String], 0);
  if (result)
  {
    float v6 = result;
    Ivar = (objc_object *)object_getIvar(a1, result);
    if (Ivar != a3)
    {
      if (Ivar) {

      }
      object_setIvar(a1, v6, a3);
      if (a3) {
        uint64_t v8 = a3;
      }
    }
    Ivar result = (objc_ivar *)object_getIvar(a1, v6);
    if (result != (objc_ivar *)a3) {
      setValueForObject();
    }
  }
  return result;
}

objc_ivar *getValueForObject(objc_object *a1, NSString *a2)
{
  Ivar result = object_getInstanceVariable(a1, [(NSString *)a2 UTF8String], 0);
  if (result)
  {
    return (objc_ivar *)object_getIvar(a1, result);
  }
  return result;
}

void *pixelFormatForMetalTexture(void *result)
{
  if (result) {
    return (void *)[result pixelFormat];
  }
  return result;
}

const char *stringForMetalTextureFormat()
{
  return "Unknown";
}

void setInternalError(void *a1, id value)
{
  if (value) {
    objc_setAssociatedObject(a1, setInternalError, value, (void *)0x301);
  }
}

uint64_t isImageConversionServiceProcess()
{
  if (isImageConversionServiceProcess_onceToken != -1) {
    dispatch_once(&isImageConversionServiceProcess_onceToken, &__block_literal_global_48);
  }
  return isImageConversionServiceProcess_isICS;
}

uint64_t isQuickLookSideCar()
{
  if (isQuickLookSideCar_onceToken != -1) {
    dispatch_once(&isQuickLookSideCar_onceToken, &__block_literal_global_3);
  }
  return isQuickLookSideCar_isQL;
}

uint64_t __isQuickLookSideCar_block_invoke()
{
  uint64_t result = [MEMORY[0x1E4F28F80] processInfo];
  if (result)
  {
    float32x2_t v1 = (void *)result;
    uint64_t result = [(id)result processName];
    if (result)
    {
      float32x2_t v2 = (void *)[v1 processName];
      if (([v2 containsString:@"com.apple.quicklook"] & 1) != 0
        || ([v2 containsString:@"com.apple.sidecar"] & 1) != 0)
      {
        uint64_t result = 1;
      }
      else
      {
        uint64_t result = [v2 containsString:@"ContinuityCamera"];
      }
      isQuickLookSideCar_isQL = result;
    }
  }
  return result;
}

uint64_t isMobileSlideShowOrCamera()
{
  if (isMobileSlideShowOrCamera_onceToken != -1) {
    dispatch_once(&isMobileSlideShowOrCamera_onceToken, &__block_literal_global_14);
  }
  return isMobileSlideShowOrCamera_isMobileSlideShowOrCamera;
}

uint64_t __isMobileSlideShowOrCamera_block_invoke()
{
  uint64_t result = [MEMORY[0x1E4F28F80] processInfo];
  if (result)
  {
    float32x2_t v1 = (void *)result;
    if (objc_msgSend((id)objc_msgSend((id)result, "processName"), "isEqualToString:", @"MobileSlideShow")) {
      uint64_t result = 1;
    }
    else {
      uint64_t result = objc_msgSend((id)objc_msgSend(v1, "processName"), "isEqualToString:", @"Camera");
    }
  }
  isMobileSlideShowOrCamera_isMobileSlideShowOrCamera = result;
  return result;
}

BOOL CIMetalDeviceSupportsMPS(void *a1)
{
  return MEMORY[0x1E4F353D0] && MPSSupportsMTLDevice(a1);
}

uint64_t CIMetalDeviceSupportsFamilyApple7(void *a1, const char *a2)
{
  return [a1 supportsFamily:1007];
}

uint64_t CIMetalDeviceSupportsFamilyApple8(void *a1, const char *a2)
{
  return [a1 supportsFamily:1008];
}

uint64_t CIFormatFromCIMetalTextureFormat(int a1, unsigned char *a2)
{
  if (a2) {
    *a2 = 0;
  }
  uint64_t result = 0;
  if (a1 > 79)
  {
    if (a1 > 114)
    {
      switch(a1)
      {
        case 552:
          uint64_t v4 = &kCIFormatARGB10WideLinear;
          return *v4;
        case 553:
          if (a2) {
            *a2 = 1;
          }
          uint64_t v4 = &kCIFormatARGB10WideGamut;
          return *v4;
        case 554:
          uint64_t v4 = &kCIFormatRGB10WideLinear;
          return *v4;
        case 555:
          if (a2) {
            *a2 = 1;
          }
          uint64_t v4 = &kCIFormatRGB10WideGamut;
          return *v4;
        default:
          if (a1 == 115)
          {
            uint64_t v4 = &kCIFormatRGBAh;
          }
          else
          {
            if (a1 != 125) {
              return result;
            }
            uint64_t v4 = &kCIFormatRGBAf;
          }
          break;
      }
    }
    else
    {
      if (a1 > 93)
      {
        switch(a1)
        {
          case '^':
            uint64_t v4 = &kCIFormatA2RGB10;
            break;
          case 'i':
            uint64_t v4 = &kCIFormatRGf;
            break;
          case 'n':
            uint64_t v4 = &kCIFormatRGBA16;
            break;
          default:
            return result;
        }
        return *v4;
      }
      if (a1 != 80)
      {
        if (a1 != 81)
        {
          if (a1 != 90) {
            return result;
          }
          uint64_t v4 = &kCIFormatA2BGR10;
          return *v4;
        }
        if (a2) {
          *a2 = 1;
        }
      }
      uint64_t v4 = &kCIFormatBGRA8;
    }
    return *v4;
  }
  if (a1 > 30)
  {
    if (a1 > 64)
    {
      if (a1 == 65)
      {
        uint64_t v4 = &kCIFormatRGh;
      }
      else
      {
        if (a1 != 70)
        {
          if (a1 != 71) {
            return result;
          }
          if (a2) {
            *a2 = 1;
          }
        }
        uint64_t v4 = &kCIFormatRGBA8;
      }
      return *v4;
    }
    if (a1 != 31)
    {
      if (a1 == 55)
      {
        uint64_t v4 = &kCIFormatRf;
      }
      else
      {
        if (a1 != 60) {
          return result;
        }
        uint64_t v4 = &kCIFormatRG16;
      }
      return *v4;
    }
    if (a2) {
      *a2 = 1;
    }
LABEL_48:
    uint64_t v4 = &kCIFormatRG8;
    return *v4;
  }
  if (a1 <= 19)
  {
    if (a1 == 1)
    {
      uint64_t v4 = &kCIFormatA8;
    }
    else
    {
      if (a1 != 10)
      {
        if (a1 != 11) {
          return result;
        }
        if (a2) {
          *a2 = 1;
        }
      }
      uint64_t v4 = &kCIFormatR8;
    }
    return *v4;
  }
  switch(a1)
  {
    case 20:
      uint64_t v4 = &kCIFormatR16;
      return *v4;
    case 25:
      uint64_t v4 = &kCIFormatRh;
      return *v4;
    case 30:
      goto LABEL_48;
  }
  return result;
}

uint64_t CIMetalTextureGetFormat(void *a1)
{
  return [a1 pixelFormat];
}

void *CIMetalTextureCreateFromBuffer(uint64_t a1, void *a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, __int16 a7)
{
  if (!a3) {
    return 0;
  }
  uint64_t v8 = objc_msgSend(a2, "newTextureWithDescriptor:offset:bytesPerRow:", CreateTextureDescriptor(a3, a4, a5, a7), 0, a6);
  if (CI_ENABLE_METAL_LABEL()) {
    objc_msgSend(v8, "setLabel:", objc_msgSend(NSString, "stringWithUTF8String:", a1));
  }
  return v8;
}

uint64_t CIMetalTextureSetBytes(void *a1, uint64_t a2, uint64_t a3)
{
  memset(v7, 0, 24);
  v7[3] = [a1 width];
  v7[4] = [a1 height];
  int64x2_t v7[5] = 1;
  return [a1 replaceRegion:v7 mipmapLevel:0 withBytes:a2 bytesPerRow:a3];
}

void *CIMetalBufferCreateAndWrapData(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (void *)[a2 newBufferWithBytesNoCopy:a3 length:a4 options:0 deallocator:0];
  if (CI_ENABLE_METAL_LABEL()) {
    objc_msgSend(v5, "setLabel:", objc_msgSend(NSString, "stringWithUTF8String:", a1));
  }
  return v5;
}

uint64_t CIGetHarvestingBinaryArchiveDict(uint64_t a1)
{
  v6[3] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = [MEMORY[0x1E4F28CB8] defaultManager];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __CIGetHarvestingBinaryArchiveDict_block_invoke;
  block[3] = &unk_1E57710E0;
  block[4] = v2;
  block[5] = a1;
  if (CIGetHarvestingBinaryArchiveDict_onceToken != -1) {
    dispatch_once(&CIGetHarvestingBinaryArchiveDict_onceToken, block);
  }
  v5[0] = @"bin";
  v5[1] = @"queue";
  v6[0] = CIGetHarvestingBinaryArchiveDict_bin;
  v6[1] = CIGetHarvestingBinaryArchiveDict_queue;
  _OWORD v5[2] = @"path";
  void v6[2] = CIGetHarvestingBinaryArchiveDict_binary_archive_file_path;
  return [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v6 forKeys:v5 count:3];
}

uint64_t __CIGetHarvestingBinaryArchiveDict_block_invoke(uint64_t a1)
{
  id v21 = 0;
  if (CI_HARVEST_BIN_ARCHIVE_ABSOLUTE_PATH())
  {
    uint64_t v2 = [NSString stringWithUTF8String:CI_HARVEST_BIN_ARCHIVE_ABSOLUTE_PATH()];
  }
  else
  {
    float64x2_t v3 = (void *)[*(id *)(a1 + 32) temporaryDirectory];
    uint64_t v2 = objc_msgSend((id)objc_msgSend(v3, "URLByAppendingPathComponent:", objc_msgSend(NSString, "stringWithUTF8String:", CI_HARVEST_BIN_ARCHIVE_FOLDER_NAME())), "path");
  }
  uint64_t v4 = v2;
  char v20 = 0;
  if ([*(id *)(a1 + 32) fileExistsAtPath:v2 isDirectory:&v20]) {
    BOOL v5 = v20 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5)
  {
    uint64_t v19 = 0;
    objc_msgSend(*(id *)(a1 + 32), "createDirectoryAtPath:withIntermediateDirectories:attributes:error:", v4, 1, objc_msgSend(MEMORY[0x1E4F1C9E8], "dictionaryWithObject:forKey:", *MEMORY[0x1E4F28340], *MEMORY[0x1E4F28370]), &v19);
    if (v19)
    {
      float v6 = ci_logger_render();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
        __CIGetHarvestingBinaryArchiveDict_block_invoke_cold_3(&v19, v6);
      }
    }
  }
  int v7 = CI_ADD_PROCESS_NAME_TO_BIN_ARCHIVE();
  uint64_t v8 = NSString;
  if (v7)
  {
    uint64_t v9 = objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F28F80], "processInfo"), "processName");
    uint64_t v10 = [v8 stringWithFormat:@"%@/ci_archive_%@_%d.bin", v4, v9, objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F28F80], "processInfo"), "processIdentifier")];
  }
  else
  {
    uint64_t v10 = [NSString stringWithFormat:@"%@/ci_archive.bin", v4, v17, v18];
  }
  uint64_t v11 = v10;
  CIGetHarvestingBinaryArchiveDict_binary_archive_file_path = [[NSString alloc] initWithFormat:@"file:%@", v10];
  uint64_t v12 = objc_opt_new();
  if ([*(id *)(a1 + 32) fileExistsAtPath:v11]) {
    objc_msgSend(v12, "setUrl:", objc_msgSend(MEMORY[0x1E4F1CB10], "URLWithString:", CIGetHarvestingBinaryArchiveDict_binary_archive_file_path));
  }
  int v13 = *(void **)(a1 + 40);
  if (v13)
  {
    CIGetHarvestingBinaryArchiveDict_bin = [v13 newBinaryArchiveWithDescriptor:v12 error:&v21];
    if (CIGetHarvestingBinaryArchiveDict_bin) {
      goto LABEL_23;
    }
  }
  else if (CIGetHarvestingBinaryArchiveDict_bin)
  {
    goto LABEL_23;
  }
  int v14 = ci_logger_render();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
    __CIGetHarvestingBinaryArchiveDict_block_invoke_cold_2(v12, &v21);
  }
LABEL_23:

  CIGetHarvestingBinaryArchiveDict_queue = (uint64_t)dispatch_queue_create("CoreImageBinaryArchive", 0);
  if (!CIGetHarvestingBinaryArchiveDict_queue)
  {
    int v15 = ci_logger_render();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      __CIGetHarvestingBinaryArchiveDict_block_invoke_cold_1();
    }
  }
  uint64_t result = CI_BIN_ARCHIVE_SERIALIZATION_METHOD();
  if (!result) {
    return atexit(serializeHarvestedBinaryArchiveExit);
  }
  return result;
}

void serializeHarvestedBinaryArchiveExit()
{
  unint64_t v0 = (void *)CIGetHarvestingBinaryArchiveDict(0);
  uint64_t v1 = [v0 objectForKeyedSubscript:@"bin"];
  uint64_t v2 = [v0 objectForKeyedSubscript:@"queue"];
  uint64_t v3 = [v0 objectForKeyedSubscript:@"path"];
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = __serializeHarvestedBinaryArchiveExit_block_invoke;
  _OWORD v4[3] = &unk_1E57710E0;
  v4[4] = v1;
  v4[5] = v3;
  dispatch_sync(v2, v4);
}

uint64_t CreateRenderPipelineState(void *a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  v15[1] = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 0;
  }
  uint64_t v14 = 0;
  uint64_t v10 = objc_opt_new();
  [v10 setTileFunction:a2];
  [v10 setThreadgroupSizeMatchesTileSize:1];
  if (a5)
  {
    v15[0] = a5;
    objc_msgSend(v10, "setPreloadedLibraries:", objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObjects:count:", v15, 1));
  }
  if (a3) {
    [v10 setBinaryArchives:a3];
  }
  if (CI_ENABLE_METAL_IMAGEBLOCKS() == 2) {
    objc_msgSend((id)objc_msgSend((id)objc_msgSend(v10, "colorAttachments"), "objectAtIndexedSubscript:", 0), "setPixelFormat:", a4);
  }
  uint64_t v11 = [a1 newRenderPipelineStateWithTileDescriptor:v10 options:0 reflection:0 error:&v14];

  if (!v11)
  {
    uint64_t v12 = ci_logger_compile();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      CreateRenderPipelineState_cold_1();
    }
  }
  return v11;
}

void *CIMetalComputePipelineStateCreateFromSource(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result = CreateFunctionFromSource(a1, a2, a3, a4, a5);
  if (result)
  {
    int v7 = result;
    uint64_t ComputePipelineState = CreateComputePipelineState(a2, result, 0, 0);

    return (void *)ComputePipelineState;
  }
  return result;
}

void *CreateFunctionFromSource(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v27 = 0;
  uint64_t v10 = objc_opt_new();
  [v10 setAdditionalCompilerArguments:@"-w"];
  uint64_t v11 = objc_msgSend(a2, "newLibraryWithSource:options:error:", objc_msgSend(NSString, "stringWithUTF8String:", a3), v10, &v27);

  ArchiveLibrary(v11, a5, a4);
  if (!v11)
  {
    id v21 = ci_logger_compile();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      CreateFunctionFromSource_cold_1();
    }
    return 0;
  }
  uint64_t v24 = a3;
  if (CI_ENABLE_METAL_LABEL()) {
    objc_msgSend(v11, "setLabel:", objc_msgSend(NSString, "stringWithUTF8String:", a1));
  }
  uint64_t v26 = a1;
  if (CI_ENABLE_METAL_DEBUG())
  {
    if (CreateFunctionFromDefaultLibrary_init != -1) {
      dispatch_once(&CreateFunctionFromDefaultLibrary_init, &__block_literal_global_115_0);
    }
    long long v30 = 0u;
    long long v31 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    uint64_t v12 = (void *)CreateFunctionFromDefaultLibrary_bundles;
    uint64_t v13 = objc_msgSend((id)CreateFunctionFromDefaultLibrary_bundles, "countByEnumeratingWithState:objects:count:", &v28, v32, 16, a3);
    if (v13)
    {
      uint64_t v14 = v13;
      uint64_t v15 = *(void *)v29;
      int v25 = v11;
      while (2)
      {
        for (uint64_t i = 0; i != v14; ++i)
        {
          if (*(void *)v29 != v15) {
            objc_enumerationMutation(v12);
          }
          uint64_t v17 = *(void **)(*((void *)&v28 + 1) + 8 * i);
          uint64_t v18 = (void *)[a2 newDefaultLibraryWithBundle:v17 error:0];
          uint64_t v19 = objc_msgSend(v18, "newFunctionWithName:", objc_msgSend(NSString, "stringWithUTF8String:", a4));

          if (v19)
          {
            uint64_t v22 = ci_logger_compile();
            if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
              CreateFunctionFromSource_cold_3(a4, v17);
            }

            goto LABEL_24;
          }
        }
        uint64_t v14 = [v12 countByEnumeratingWithState:&v28 objects:v32 count:16];
        uint64_t v11 = v25;
        if (v14) {
          continue;
        }
        break;
      }
    }
  }
  uint64_t v19 = objc_msgSend(v11, "newFunctionWithName:", objc_msgSend(NSString, "stringWithUTF8String:", a4, v24));

  if (!v19)
  {
    char v20 = ci_logger_compile();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      CreateFunctionFromSource_cold_2();
    }
    return 0;
  }
LABEL_24:
  if (CI_ENABLE_METAL_LABEL()) {
    objc_msgSend(v19, "setLabel:", objc_msgSend(NSString, "stringWithUTF8String:", v26));
  }
  return v19;
}

void *CIMetalRenderPipelineStateCreateFromSource(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6)
{
  uint64_t result = CreateFunctionFromSource(a1, a2, a3, a4, a5);
  if (result)
  {
    uint64_t v9 = result;
    uint64_t RenderPipelineState = CreateRenderPipelineState(a2, (uint64_t)result, 0, a6, 0);

    return (void *)RenderPipelineState;
  }
  return result;
}

uint64_t CILoadBinaryArchive(uint64_t a1, int a2)
{
  id v12 = 0;
  if (!a1) {
    return 0;
  }
  id v4 = MTLCreateSystemDefaultDevice();
  if (!v4)
  {
    uint64_t v9 = ci_logger_api();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      CILoadBinaryArchive_cold_1();
    }
    return 0;
  }
  BOOL v5 = v4;
  if (a2 && ([v4 supportsFamily:1006] & 1) == 0)
  {
LABEL_12:

    return 0;
  }
  float v6 = objc_opt_new();
  [v6 setUrl:a1];
  uint64_t v7 = [v5 newBinaryArchiveWithDescriptor:v6 error:&v12];
  if (!v7)
  {
    uint64_t v10 = ci_logger_api();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      CILoadBinaryArchive_cold_2(a1, &v12, v10);
    }

    goto LABEL_12;
  }
  uint64_t v8 = v7;

  return v8;
}

uint64_t CILoadAIRArchive(uint64_t a1, int a2)
{
  uint64_t v2 = a1;
  uint64_t v8 = 0;
  if (a1)
  {
    id v4 = MTLCreateSystemDefaultDevice();
    if (v4)
    {
      BOOL v5 = v4;
      if (!a2 || ([v4 supportsFamily:1006] & 1) != 0)
      {
        uint64_t v2 = [v5 newLibraryWithURL:v2 error:&v8];

        return v2;
      }
    }
    else
    {
      float v6 = ci_logger_api();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
        CILoadAIRArchive_cold_1();
      }
    }
    return 0;
  }
  return v2;
}

void testBinaryArchive(void *a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v19 = 0;
  id v4 = MTLCreateSystemDefaultDevice();
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  obuint64_t j = (id)[a1 functionNames];
  uint64_t v5 = [obj countByEnumeratingWithState:&v15 objects:v21 count:16];
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)v16;
    do
    {
      for (uint64_t i = 0; i != v6; ++i)
      {
        if (*(void *)v16 != v7) {
          objc_enumerationMutation(obj);
        }
        uint64_t v9 = *(void *)(*((void *)&v15 + 1) + 8 * i);
        uint64_t v10 = [a1 newFunctionWithName:v9];
        if (v10)
        {
          uint64_t v11 = (void *)v10;
          NSLog(&cfstr_Trying.isa, v9);
          id v12 = objc_opt_new();
          [v12 setComputeFunction:v11];
          uint64_t v20 = a2;
          objc_msgSend(v12, "setBinaryArchives:", objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObjects:count:", &v20, 1));
          uint64_t v13 = (void *)[v4 newComputePipelineStateWithDescriptor:v12 options:4 reflection:0 error:&v19];

          if (!v13) {
            testBinaryArchive_cold_1(&v19, v9);
          }
        }
        else
        {
          NSLog(&cfstr_FailedToCreate_2.isa, v9);
        }
      }
      uint64_t v6 = [obj countByEnumeratingWithState:&v15 objects:v21 count:16];
    }
    while (v6);
  }

  NSLog(&cfstr_DoneWithAllFun.isa);
}

uint64_t CIMetalRenderPipelineStateCreateFromDagDescriptor(uint64_t a1, uint64_t a2, void *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned int a8)
{
  uint64_t result = CreateStitchedFunctionFromDescriptor(a1, a2, a3, a4, a7);
  if (result)
  {
    uint64_t v13 = (void *)result;
    uint64_t RenderPipelineState = CreateRenderPipelineState(a3, result, a5, a8, a6);

    return RenderPipelineState;
  }
  return result;
}

void print_stitched_dag(void *a1, void *a2)
{
  uint64_t v2 = objc_msgSend(a1, "newDagStringWithGraphs:", objc_msgSend(a2, "functionGraphs"));
  uint64_t v3 = ci_logger_compile();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
    print_stitched_dag_cold_1();
  }
}

void *CIMetalComputePipelineStateCreateFromDAG(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t result = CreateFunctionFromDAG(a1, a2, a3, a4, a5, a6, a7);
  if (result)
  {
    uint64_t v9 = result;
    uint64_t ComputePipelineState = CreateComputePipelineState(a3, result, 0, 0);

    return (void *)ComputePipelineState;
  }
  return result;
}

void *CreateFunctionFromDAG(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v17 = 0;
  uint64_t v11 = [a3 newLibraryWithImageFilterFunctionsSPI:a4 imageFilterFunctionInfo:a5 error:&v17];
  if (!v11)
  {
    uint64_t v14 = ci_logger_compile();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      CreateFunctionFromSource_cold_1();
    }
    return 0;
  }
  id v12 = (void *)v11;
  if (CI_ENABLE_METAL_LABEL()) {
    objc_msgSend(v12, "setLabel:", objc_msgSend(NSString, "stringWithUTF8String:", a1));
  }
  ArchiveLibrary(v12, a7, a2);
  uint64_t v13 = (void *)[v12 newFunctionWithName:@"ciKernelMain" constantValues:a6 error:&v17];

  if (!v13)
  {
    long long v15 = ci_logger_compile();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      CreateStitchedFunctionFromDescriptor_cold_2();
    }
    return 0;
  }
  if (CI_ENABLE_METAL_LABEL()) {
    objc_msgSend(v13, "setLabel:", objc_msgSend(NSString, "stringWithUTF8String:", a1));
  }
  return v13;
}

void *CIMetalRenderPipelineStateCreateFromDAG(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned int a8)
{
  uint64_t result = CreateFunctionFromDAG(a1, a2, a3, a4, a5, a6, a7);
  if (result)
  {
    uint64_t v11 = result;
    uint64_t RenderPipelineState = CreateRenderPipelineState(a3, (uint64_t)result, 0, a8, 0);

    return (void *)RenderPipelineState;
  }
  return result;
}

uint64_t CIMetalCommandQueueSetPriority(void *a1, const char *a2)
{
  if ((int)a2 >= 0) {
    uint64_t v2 = a2 == 0;
  }
  else {
    uint64_t v2 = 2;
  }
  return [a1 setGPUPriority:v2];
}

uint64_t CIMetalRenderToImageblocks(uint64_t a1, int a2, void *a3, void *a4, uint64_t a5, double a6, double a7, uint64_t a8, void **a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  uint64_t v29 = a1;
  uint64_t v20 = objc_opt_new();
  id v21 = *a9;
  uint64_t v22 = (void *)[MEMORY[0x1E4F352E0] renderPassDescriptor];
  objc_msgSend(v22, "setImageblockSampleLength:", objc_msgSend(a4, "imageblockSampleLength"));
  if (CI_ENABLE_METAL_IMAGEBLOCKS() == 2)
  {
    int v23 = objc_msgSend((id)objc_msgSend(v22, "colorAttachments"), "objectAtIndexedSubscript:", 0);
    [v23 setTexture:v21];
    [v23 setStoreAction:1];
    if (a6 < (double)(unint64_t)[v21 width]
      || a7 < (double)(unint64_t)[v21 height])
    {
      objc_msgSend(v23, "setLoadAction:", 1, v29);
    }
  }
  else
  {
    [v22 setDefaultColorSampleCount:1];
    objc_msgSend(v22, "setRenderTargetWidth:", objc_msgSend(v21, "width"));
    objc_msgSend(v22, "setRenderTargetHeight:", objc_msgSend(v21, "height"));
  }
  uint64_t v24 = objc_msgSend(a3, "renderCommandEncoderWithDescriptor:", v22, v29);
  if (a13) {
    objc_msgSend(v24, "setLabel:", objc_msgSend(NSString, "stringWithUTF8String:", a13));
  }
  [v24 setRenderPipelineState:a4];
  [v20 addObject:a4];
  [v24 setTileTexture:v21 atIndex:0];
  [v20 addObject:v21];
  if (a10)
  {
    uint64_t v25 = 0;
    do
    {
      uint64_t v26 = *(void *)(a11 + 8 * v25);
      [v24 setTileTexture:v26 atIndex:v25 + 1];
      [v20 addObject:v26];
      uint64_t v27 = *(void *)(a12 + 8 * v25);
      [v24 setTileSamplerState:v27 atIndex:v25];
      [v20 addObject:v27];
      ++v25;
    }
    while (a10 != v25);
  }
  [v24 setTileBuffer:a5 offset:0 atIndex:0];
  [v20 addObject:a5];
  v36[0] = [v24 tileWidth];
  v36[1] = [v24 tileHeight];
  v36[2] = 1;
  [v24 dispatchThreadsPerTile:v36];
  [v24 endEncoding];
  v34[0] = MEMORY[0x1E4F143A8];
  v34[1] = 3221225472;
  v34[2] = __CIMetalRenderToImageblocks_block_invoke;
  v34[3] = &unk_1E57726B0;
  void v34[4] = a3;
  *(double *)&v34[5] = a6;
  *(double *)&v34[6] = a7;
  v34[7] = v30;
  int v35 = a2;
  [a3 addScheduledHandler:v34];
  v32[0] = MEMORY[0x1E4F143A8];
  v32[1] = 3221225472;
  v32[2] = __CIMetalRenderToImageblocks_block_invoke_92;
  v32[3] = &unk_1E57726B0;
  *(double *)&v32[5] = a6;
  *(double *)&v32[6] = a7;
  v32[7] = v30;
  int v33 = a2;
  v32[4] = v20;
  return [a3 addCompletedHandler:v32];
}

void __CIMetalRenderToImageblocks_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (CI_KDEBUG()) {
    kdebug_trace();
  }
  if (CI_VERBOSE_SIGNPOSTS())
  {
    id v4 = ci_signpost_log_render();
    os_signpost_id_t v5 = *(int *)(a1 + 64) | (*(void *)(a1 + 56) << 32);
    if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      uint64_t v6 = v4;
      if (os_signpost_enabled(v4))
      {
        double v7 = *(double *)(a1 + 48);
        unsigned int v8 = *(double *)(a1 + 40);
        int v9 = 134218496;
        uint64_t v10 = a2;
        __int16 v11 = 1024;
        unsigned int v12 = v8;
        __int16 v13 = 1024;
        unsigned int v14 = v7;
        _os_signpost_emit_with_name_impl(&dword_193671000, v6, OS_SIGNPOST_INTERVAL_BEGIN, v5, "gpu_compute", "cb:%p [%u, %u]", (uint8_t *)&v9, 0x18u);
      }
    }
  }
}

void __CIMetalRenderToImageblocks_block_invoke_92(uint64_t a1, void *a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (CI_KDEBUG()) {
    kdebug_trace();
  }
  if (CI_VERBOSE_SIGNPOSTS())
  {
    id v4 = ci_signpost_log_render();
    os_signpost_id_t v5 = *(int *)(a1 + 64) | (*(void *)(a1 + 56) << 32);
    if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      uint64_t v6 = v4;
      if (os_signpost_enabled(v4))
      {
        double v7 = *(double *)(a1 + 48);
        unsigned int v8 = *(double *)(a1 + 40);
        int v9 = 134218496;
        uint64_t v10 = a2;
        __int16 v11 = 1024;
        unsigned int v12 = v8;
        __int16 v13 = 1024;
        unsigned int v14 = v7;
        _os_signpost_emit_with_name_impl(&dword_193671000, v6, OS_SIGNPOST_INTERVAL_END, v5, "gpu_compute", "cb:%p [%u, %u]", (uint8_t *)&v9, 0x18u);
      }
    }
  }
  CIAbortIfICSAndUnsuccessfulCommandBufferExecution(a2);
}

void *CIMetalCommandBufferCopyTexture(void *result, uint64_t a2, uint64_t a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  if (a2 && result)
  {
    if (a3)
    {
      uint64_t v17 = (void *)[result blitCommandEncoder];
      v20[0] = (unint64_t)a6;
      v20[1] = (unint64_t)a7;
      v20[2] = 0;
      v19[0] = (unint64_t)a8;
      v19[1] = (unint64_t)a9;
      v19[2] = 1;
      v18[0] = (unint64_t)a4;
      v18[1] = (unint64_t)a5;
      void v18[2] = 0;
      [v17 copyFromTexture:a3 sourceSlice:0 sourceLevel:0 sourceOrigin:v20 sourceSize:v19 toTexture:a2 destinationSlice:0 destinationLevel:0 destinationOrigin:v18];
      return (void *)[v17 endEncoding];
    }
  }
  return result;
}

void CIMetalCommandBufferWaitUntilScheduled(void *a1)
{
  if ((unint64_t)[a1 status] < 2)
  {
    NSLog(&cfstr_MetalCommandBu.isa);
  }
  else
  {
    [a1 waitUntilScheduled];
  }
}

void __serializeHarvestedBinaryArchiveExit_block_invoke(uint64_t a1)
{
}

void serializeBinaryArchive(void *a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  id v6 = 0;
  char v3 = objc_msgSend(a1, "serializeToURL:error:", objc_msgSend(MEMORY[0x1E4F1CB10], "URLWithString:", a2), &v6);
  id v4 = ci_logger_render();
  os_signpost_id_t v5 = v4;
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)uint8_t buf = 138543362;
      uint64_t v8 = a2;
      _os_log_impl(&dword_193671000, v5, OS_LOG_TYPE_INFO, "Serialized binary archive to %{public}@\n", buf, 0xCu);
    }
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    serializeBinaryArchive_cold_1(a2, &v6);
  }
}

void __ArchiveLibrary_block_invoke(uint64_t a1)
{
  if (CI_HARVEST_BIN_ARCHIVE_ABSOLUTE_PATH())
  {
    uint64_t v2 = [NSString stringWithUTF8String:CI_HARVEST_BIN_ARCHIVE_ABSOLUTE_PATH()];
  }
  else
  {
    char v3 = (void *)[*(id *)(a1 + 32) temporaryDirectory];
    uint64_t v2 = objc_msgSend((id)objc_msgSend(v3, "URLByAppendingPathComponent:", objc_msgSend(NSString, "stringWithUTF8String:", CI_HARVEST_BIN_ARCHIVE_FOLDER_NAME())), "path");
  }
  uint64_t v4 = v2;
  char v8 = 0;
  if ([*(id *)(a1 + 32) fileExistsAtPath:v2 isDirectory:&v8]) {
    BOOL v5 = v8 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5)
  {
    double v7 = 0;
    objc_msgSend(*(id *)(a1 + 32), "createDirectoryAtPath:withIntermediateDirectories:attributes:error:", v4, 1, objc_msgSend(MEMORY[0x1E4F1C9E8], "dictionaryWithObject:forKey:", *MEMORY[0x1E4F28340], *MEMORY[0x1E4F28370]), &v7);
    if (v7)
    {
      id v6 = ci_logger_render();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
        __CIGetHarvestingBinaryArchiveDict_block_invoke_cold_3(&v7, v6);
      }
    }
  }
}

uint64_t __CreateFunctionFromDefaultLibrary_block_invoke()
{
  id v0 = (id)objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithArray:", objc_msgSend(MEMORY[0x1E4F28B50], "allBundles"));
  CreateFunctionFromDefaultLibrary_bundles = (uint64_t)v0;
  uint64_t v1 = [MEMORY[0x1E4F28B50] bundleWithIdentifier:@"com.apple.CoreImage"];

  return [v0 addObject:v1];
}

void *__isHarvestingForThisProcess_block_invoke(uint64_t a1)
{
  uint64_t v1 = (void *)[NSString stringWithCString:*(void *)(a1 + 32) encoding:1];
  uint64_t result = (void *)[MEMORY[0x1E4F28F80] processInfo];
  if (result) {
    uint64_t result = objc_msgSend(v1, "containsString:", objc_msgSend(result, "processName"));
  }
  isHarvestingForThisProcess_isListed = (char)result;
  return result;
}

void __ArchiveLibraryUsingStitchedDagDescriptor_block_invoke(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (CI_PREVENT_HARVEST_DUPLICATE_ENTRIES())
  {
    uint64_t v2 = (void *)[MEMORY[0x1E4F28CB8] defaultManager];
    char v3 = (void *)[v2 temporaryDirectory];
    uint64_t v4 = [(id)objc_msgSend(v3 URLByAppendingPathComponent:objc_msgSend(NSString, "stringWithFormat:", @"%s/ci_%016llX.txt", CI_HARVEST_BIN_ARCHIVE_FOLDER_NAME(), *(void *)(a1 + 72))), "path"];
    if ([v2 fileExistsAtPath:v4 isDirectory:0]) {
      return;
    }
    if (([v2 createFileAtPath:v4, objc_msgSend((id)objc_msgSend(NSString, "stringWithFormat:", @"0x%016llX %@\n", *(void *)(a1 + 72), *(void *)(a1 + 32)), "dataUsingEncoding:", 4), 0 contents attributes] & 1) == 0)
    {
      BOOL v5 = ci_logger_render();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        __ArchiveLibraryUsingStitchedDagDescriptor_block_invoke_cold_3();
      }
    }
  }
  uint64_t v20 = 0;
  if ([*(id *)(a1 + 40) addLibraryWithDescriptor:*(void *)(a1 + 48) error:&v20])
  {
    char v6 = [*(id *)(a1 + 40) addComputePipelineFunctionsWithDescriptor:*(void *)(a1 + 56) error:&v20];
    double v7 = ci_logger_render();
    char v8 = v7;
    if (v6)
    {
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        uint64_t v9 = *(void *)(a1 + 32);
        uint64_t v10 = [*(id *)(a1 + 64) lastPathComponent];
        *(_DWORD *)uint8_t buf = 138543618;
        *(void *)&uint8_t buf[4] = v9;
        *(_WORD *)&unsigned char buf[12] = 2114;
        *(void *)&buf[14] = v10;
        _os_log_impl(&dword_193671000, v8, OS_LOG_TYPE_INFO, "%{public}@ program added to %{public}@\n", buf, 0x16u);
      }
      if (CI_BIN_ARCHIVE_SERIALIZATION_METHOD() == 1)
      {
        serializeBinaryArchive(*(void **)(a1 + 40), *(void *)(a1 + 64));
      }
      else if (CI_BIN_ARCHIVE_SERIALIZATION_METHOD() == 2)
      {
        unsigned int v12 = (void *)CIGetHarvestingBinaryArchiveDict(0);
        uint64_t v13 = [v12 objectForKeyedSubscript:@"bin"];
        uint64_t v14 = [v12 objectForKeyedSubscript:@"queue"];
        uint64_t v15 = [v12 objectForKeyedSubscript:@"path"];
        double v16 = CI_BIN_ARCHIVE_SERIALIZATION_DELAY();
        dispatch_time_t v17 = dispatch_time(0, (uint64_t)(v16 / 1000.0 * 1000000000.0));
        if ((scheduleSerializingHarvestedBinaryArchive_serialization_pending & 1) == 0)
        {
          dispatch_time_t v18 = v17;
          scheduleSerializingHarvestedBinaryArchive_serialization_pending = 1;
          global_queue = dispatch_get_global_queue(0, 0);
          *(void *)uint8_t buf = MEMORY[0x1E4F143A8];
          *(void *)&buf[8] = 3221225472;
          *(void *)&buf[16] = __scheduleSerializingHarvestedBinaryArchive_block_invoke;
          uint64_t v22 = &unk_1E5772728;
          uint64_t v23 = v14;
          uint64_t v24 = v13;
          uint64_t v25 = v15;
          dispatch_after(v18, global_queue, buf);
        }
      }
    }
    else if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      __ArchiveLibraryUsingStitchedDagDescriptor_block_invoke_cold_1(&v20, v8);
    }
  }
  else
  {
    __int16 v11 = ci_logger_render();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      __ArchiveLibraryUsingStitchedDagDescriptor_block_invoke_cold_2(&v20, v11);
    }
  }
}

void __scheduleSerializingHarvestedBinaryArchive_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 32);
  v2[0] = MEMORY[0x1E4F143A8];
  v2[1] = 3221225472;
  v2[2] = __scheduleSerializingHarvestedBinaryArchive_block_invoke_2;
  v2[3] = &unk_1E57710E0;
  long long v3 = *(_OWORD *)(a1 + 40);
  dispatch_sync(v1, v2);
}

void __scheduleSerializingHarvestedBinaryArchive_block_invoke_2(uint64_t a1)
{
  scheduleSerializingHarvestedBinaryArchive_serialization_pending = 0;
}

uint64_t __configureQueue_block_invoke(uint64_t result, void *a2, void *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t v7 = [a3 bytes];
    unint64_t v8 = 0;
    uint64_t v9 = 0;
    uint64_t v10 = *(void *)(v6 + 32);
    uint64_t v11 = 2 * v10;
    uint64_t v12 = v7 + 8 * v10;
    double v13 = 0.0;
    do
    {
      uint64_t v14 = (void *)(v12 + 8 * v8);
      double v13 = v13 + (double)(unint64_t)(*v14 - *(void *)(v7 + 8 * v8));
      uint64_t v9 = v9 - *(void *)(v7 + ((8 * v8) | 8)) + v14[1];
      v8 += v11;
    }
    while (v8 < a4);
    uint64_t result = objc_msgSend((id)objc_msgSend(a2, "userDictionary"), "objectForKeyedSubscript:", @"RendererStatsPerfCallback");
    if (result)
    {
      uint64_t v15 = *(uint64_t (**)(void))(result + 16);
      return v15();
    }
  }
  return result;
}

uint64_t x_log(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  return vfprintf((FILE *)*MEMORY[0x1E4F143C8], "com.apple.coreimage.perDispatchCommandBuffer: %s\n", &a9);
}

void OUTLINED_FUNCTION_1_6(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0xCu);
}

uint64_t OUTLINED_FUNCTION_11_2(void **a1)
{
  uint64_t v2 = *a1;
  return [v2 localizedDescription];
}

void OUTLINED_FUNCTION_12_1(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x1Cu);
}

double cikernel::_minimumComponent(__n128 a1, double a2)
{
  *(float *)&a2 = fminf(fminf(a1.n128_f32[0], a1.n128_f32[1]), a1.n128_f32[2]);
  *(void *)&double result = vdupq_lane_s32(*(int32x2_t *)&a2, 0).u64[0];
  return result;
}

double cikernel::_maximumComponent(__n128 a1, double a2)
{
  *(float *)&a2 = fmaxf(fmaxf(a1.n128_f32[0], a1.n128_f32[1]), a1.n128_f32[2]);
  *(void *)&double result = vdupq_lane_s32(*(int32x2_t *)&a2, 0).u64[0];
  return result;
}

__n128 extendDOD@<Q0>(uint64_t a1@<X0>, _OWORD *a2@<X8>, float32x2_t a3@<D0>, float32x2_t a4@<D1>, __n128 a5@<Q2>, int8x16_t a6@<Q3>, int8x16_t a7@<Q4>)
{
  float32x2_t v23 = vsub_f32(a3, *(float32x2_t *)a6.i8);
  if ((float)(a5.n128_f32[2] + vaddv_f32(vmul_f32((float32x2_t)a5.n128_u64[0], v23))) < 0.001)
  {
    Rectangle::Union((Rectangle *)a1, (const vec2 *)&v23, (uint64_t)&v21);
    if (&v21 != (long long *)a1)
    {
      long long v11 = v22;
      *(_OWORD *)a1 = v21;
      *(_OWORD *)(a1 + 16) = v11;
    }
    float32x2_t v12 = vsub_f32(vsub_f32(a3, a4), (float32x2_t)*(_OWORD *)&vextq_s8(a6, a6, 8uLL));
    int32x2_t v13 = (int32x2_t)vmul_f32(v12, *(float32x2_t *)a7.i8);
    int32x2_t v14 = (int32x2_t)vmul_f32(v12, (float32x2_t)*(_OWORD *)&vextq_s8(a7, a7, 8uLL));
    float32x2_t v23 = vadd_f32((float32x2_t)vzip1_s32(v13, v14), (float32x2_t)vzip2_s32(v13, v14));
    float32x2_t v20 = vadd_f32(a4, v23);
    Rectangle::Union((Rectangle *)a1, (const vec2 *)&v20, (uint64_t)&v21);
    if (&v21 != (long long *)a1)
    {
      long long v15 = v22;
      *(_OWORD *)a1 = v21;
      *(_OWORD *)(a1 + 16) = v15;
    }
  }
  __n128 result = *(__n128 *)a1;
  long long v17 = *(_OWORD *)(a1 + 16);
  *a2 = *(_OWORD *)a1;
  a2[1] = v17;
  return result;
}

float32x2_t cikernel::_mirror(CI *a1, float32x2_t a2, __n128 a3, int8x16_t a4, int8x16_t a5)
{
  DC = (float32x2_t *)CI::getDC(a1);
  float v7 = a3.n128_f32[2] + vaddv_f32(vmul_f32((float32x2_t)a3.n128_u64[0], *DC));
  float32x2_t v8 = vsub_f32(*(float32x2_t *)CI::getDC((CI *)DC), a2);
  int32x2_t v9 = (int32x2_t)vmul_f32(*(float32x2_t *)a5.i8, v8);
  int32x2_t v10 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a5, a5, 8uLL), v8);
  double v11 = COERCE_DOUBLE(vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), vadd_f32((float32x2_t)vzip1_s32(v9, v10), (float32x2_t)vzip2_s32(v9, v10))));
  double v12 = COERCE_DOUBLE(vadd_f32(*(float32x2_t *)a4.i8, v8));
  if (v7 >= 0.0) {
    double v12 = v11;
  }
  return vadd_f32(a2, *(float32x2_t *)&v12);
}

void CI::f2_f2_f3_f4_f4(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = a1[6];
  int32x2_t v10 = (double (*)(void *, double, __n128, __n128, __n128))a1[3];
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  uint64_t v13 = *(void *)(v9 + 32);
  int v14 = *(_DWORD *)(v9 + 64);
  uint64_t v15 = *(void *)(v9 + 56);
  int v16 = *(_DWORD *)(v9 + 88);
  uint64_t v17 = *(void *)(v9 + 80);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 104)), a2);
  }
  dispatch_time_t v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5) {
    dispatch_time_t v18 = (__n128 *)((char *)a2 + 64 * v17);
  }
  uint64_t v19 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5) {
    uint64_t v19 = (__n128 *)((char *)a2 + 64 * v15);
  }
  float32x2_t v20 = (double *)(a3 + 16 * v12);
  if (v11 != 5) {
    float32x2_t v20 = (double *)((char *)a2 + 64 * v12);
  }
  *(double *)(a3 + 16 * a7) = v10(a1, *v20, *((__n128 *)a2 + 4 * v13), *v19, *v18);
}

float64_t Rectangle::Union@<D0>(Rectangle *this@<X0>, const vec2 *a2@<X1>, uint64_t a3@<X8>)
{
  double var0 = this->var0;
  if (fabs(this->var0) == INFINITY || (double var1 = this->var1, fabs(var1) == INFINITY))
  {
    float64x2_t v5 = vcvtq_f64_f32(*(float32x2_t *)a2);
    *(float64x2_t *)a3 = v5;
    *(void *)(a3 + 16) = 0;
    *(void *)(a3 + 24) = 0;
  }
  else
  {
    BOOL v6 = var0 == -8.98846567e307 && var1 == -8.98846567e307;
    if (v6 && this->var2 == 1.79769313e308 && this->var3 == 1.79769313e308)
    {
      float64x2_t v5 = (float64x2_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
      *(float64x2_t *)a3 = v5;
      *(int64x2_t *)(a3 + 16) = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    }
    else
    {
      double v7 = var0 + this->var2;
      double v8 = COERCE_FLOAT(*(void *)a2);
      double v9 = fmin(fmin(var0, v7), v8);
      double v10 = var1 + this->var3;
      double v11 = COERCE_FLOAT(HIDWORD(*(void *)a2));
      double v12 = fmin(fmin(var1, v10), v11);
      v5.f64[0] = fmax(fmax(var0, v7), v8) - v9;
      *(double *)a3 = v9;
      *(double *)(a3 + 8) = v12;
      *(float64_t *)(a3 + 16) = v5.f64[0];
      *(double *)(a3 + 24) = fmax(fmax(var1, v10), v11) - v12;
    }
  }
  return v5.f64[0];
}

__n128 extendROI@<Q0>(uint64_t a1@<X0>, _OWORD *a2@<X8>, float32x2_t a3@<D0>, float32x2_t a4@<D1>, __n128 a5@<Q2>, int8x16_t a6@<Q3>, int8x16_t a7@<Q4>)
{
  if ((float)(a5.n128_f32[2] + vaddv_f32(vmul_f32((float32x2_t)a5.n128_u64[0], vsub_f32(a3, *(float32x2_t *)a6.i8)))) < 0.001)
  {
    float v9 = a5.n128_f32[2] + vaddv_f32(vmul_f32(a3, (float32x2_t)a5.n128_u64[0]));
    float32x2_t v10 = vsub_f32(a3, a4);
    BOOL v11 = v9 < 0.0;
    int32x2_t v12 = (int32x2_t)vmul_f32(v10, *(float32x2_t *)a7.i8);
    int32x2_t v13 = (int32x2_t)vmul_f32(v10, (float32x2_t)*(_OWORD *)&vextq_s8(a7, a7, 8uLL));
    double v14 = COERCE_DOUBLE(vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a6, a6, 8uLL), vadd_f32((float32x2_t)vzip1_s32(v12, v13), (float32x2_t)vzip2_s32(v12, v13))));
    double v15 = COERCE_DOUBLE(vadd_f32(v10, *(float32x2_t *)a6.i8));
    if (!v11) {
      double v15 = v14;
    }
    float32x2_t v20 = vadd_f32(a4, *(float32x2_t *)&v15);
    Rectangle::Union((Rectangle *)a1, (const vec2 *)&v20, (uint64_t)v19);
    if (v19 != (_OWORD *)a1)
    {
      long long v16 = v19[1];
      *(_OWORD *)a1 = v19[0];
      *(_OWORD *)(a1 + 16) = v16;
    }
  }
  __n128 result = *(__n128 *)a1;
  long long v18 = *(_OWORD *)(a1 + 16);
  *a2 = *(_OWORD *)a1;
  a2[1] = v18;
  return result;
}

double cikernel::_modTransition(CI *a1, float32x4_t a2, float32x4_t a3, float32x2_t a4, float32x4_t a5, int8x16_t a6, __n128 a7, __n128 a8)
{
  float32x2_t v9 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a4);
  float v10 = vmuls_lane_f32(v9.f32[0], a5, 2);
  float v11 = a7.n128_f32[3] + (float)(a7.n128_f32[2] / vmlas_n_f32(a7.n128_f32[1], v10, a7.n128_f32[0]));
  float v12 = a8.n128_f32[3] + (float)(a8.n128_f32[2] / vmlas_n_f32(a8.n128_f32[1], v10, a8.n128_f32[0]));
  if (v10 >= 0.5) {
    float v13 = v12;
  }
  else {
    float v13 = v11;
  }
  v9.i32[0] = vmuls_lane_f32(v13, a5, 3);
  int32x2_t v14 = (int32x2_t)vmul_f32(*(float32x2_t *)a6.i8, v9);
  int32x2_t v15 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a6, a6, 8uLL), v9);
  float32x2_t v16 = vadd_f32(a4, vadd_f32((float32x2_t)vzip1_s32(v14, v15), (float32x2_t)vzip2_s32(v14, v15)));
  float32x2_t v17 = vminnm_f32(vsub_f32(v16, vrndm_f32(v16)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu));
  __asm { FMOV            V1.2S, #1.0 }
  float32x2_t v23 = vminnm_f32(v17, vsub_f32(_D1, v17));
  float32x2_t v24 = vadd_f32(v23, v23);
  float v25 = vmlas_n_f32(a5.f32[1], sqrtf(vaddv_f32(vmul_f32(v24, v24))), a5.f32[0]);
  if (v25 <= 1.0) {
    float v26 = v25;
  }
  else {
    float v26 = 1.0;
  }
  _NF = v25 < 0.0;
  float v27 = 0.0;
  if (!_NF) {
    float v27 = v26;
  }
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(a3, 1.0 - v27), a2, v27).u64[0];
  return result;
}

void CI::f4_s_s_f2_f4_f4_f4_f4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  float v10 = *(const vec2 **)(a1 + 24);
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  int v13 = *(_DWORD *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  int v15 = *(_DWORD *)(v9 + 64);
  uint64_t v16 = *(void *)(v9 + 56);
  int v17 = *(_DWORD *)(v9 + 88);
  uint64_t v18 = *(void *)(v9 + 80);
  int v19 = *(_DWORD *)(v9 + 112);
  uint64_t v20 = *(void *)(v9 + 104);
  int v21 = *(_DWORD *)(v9 + 136);
  uint64_t v22 = *(void *)(v9 + 128);
  int v23 = *(_DWORD *)(v9 + 160);
  uint64_t v24 = *(void *)(v9 + 152);
  if (*(unsigned char *)(a1 + 64))
  {
    float32x2_t v39 = *(const vec2 **)(a1 + 24);
    uint64_t v40 = *(void *)(v9 + 32);
    uint64_t v37 = *(void *)(v9 + 8);
    uint64_t v38 = *(void *)(v9 + 56);
    int v36 = *(_DWORD *)(v9 + 112);
    uint64_t v35 = *(void *)(v9 + 80);
    int v34 = *(_DWORD *)(v9 + 160);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 176)), v10);
    int v23 = v34;
    uint64_t v18 = v35;
    int v19 = v36;
    uint64_t v12 = v37;
    uint64_t v16 = v38;
    float v10 = v39;
    uint64_t v14 = v40;
  }
  float v25 = (__n128 *)(a3 + 16 * v24);
  if (v23 != 5) {
    float v25 = (__n128 *)(a2 + (v24 << 6));
  }
  float v26 = (__n128 *)(a3 + 16 * v22);
  if (v21 != 5) {
    float v26 = (__n128 *)(a2 + (v22 << 6));
  }
  float v27 = (__n128 *)(a3 + 16 * v20);
  if (v19 != 5) {
    float v27 = (__n128 *)(a2 + (v20 << 6));
  }
  long long v28 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5) {
    long long v28 = (__n128 *)(a2 + (v18 << 6));
  }
  uint64_t v29 = (double *)(a3 + 16 * v16);
  uint64_t v30 = (double *)(a2 + (v16 << 6));
  if (v15 != 5) {
    uint64_t v29 = v30;
  }
  long long v31 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    long long v31 = (__n128 *)(a2 + (v14 << 6));
  }
  uint64_t v32 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    uint64_t v32 = (__n128 *)(a2 + (v12 << 6));
  }
  *(double *)&long long v33 = ((double (*)(__n128, __n128, double, __n128, __n128, __n128, __n128))v10)(*v32, *v31, *v29, *v28, *v27, *v26, *v25);
  *(_OWORD *)(a3 + 16 * a7) = v33;
}

double cikernel::_maxDisk(cikernel *this, SamplerObj *a2, float a3)
{
  DC = (CI *)CI::getDC(this);
  float32x2_t v6 = *(float32x2_t *)DC;
  double v7 = (float32x2_t *)CI::getDC(DC);
  *(float *)&double v8 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *v7, 1), *((float *)this + 4), COERCE_FLOAT(*v7));
  LODWORD(v9) = *((_DWORD *)this + 7);
  v10.i32[0] = *((_DWORD *)this + 9);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *v7, 1), *(float *)&v9, COERCE_FLOAT(*v7));
  *(float *)&double v12 = *((float *)this + 6) + *(float *)&v8;
  *(float *)v13.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  *((float *)&v12 + 1) = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v15.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v12, v13, v8, v9, v11, v10, v14);
  float32x4_t v21 = v15;
  float v22 = ceilf(a3);
  if (v22 >= 0.0)
  {
    float v23 = a3 * a3;
    *(float *)&long long v17 = -v22;
    do
    {
      *(float *)v18.i32 = -v22;
      long long v27 = v17;
      do
      {
        *(float32x2_t *)&v16.f64[0] = vmul_f32((float32x2_t)__PAIR64__(v18.u32[0], v17), (float32x2_t)__PAIR64__(v18.u32[0], v17));
        if (vaddv_f32(*(float32x2_t *)&v16.f64[0]) <= v23)
        {
          float32x2_t v24 = vadd_f32(v6, (float32x2_t)__PAIR64__(v18.u32[0], v17));
          int8x16_t v28 = v18;
          float32x4_t v29 = v21;
          v21.f32[0] = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v24, 1), *((float *)this + 4), v24.f32[0]);
          LODWORD(v17) = *((_DWORD *)this + 7);
          v19.i32[0] = *((_DWORD *)this + 9);
          *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v24, 1), *(float *)&v17, v24.f32[0]);
          v24.f32[0] = *((float *)this + 6) + v21.f32[0];
          *(float *)v16.f64 = *(float *)v19.i32 + *(float *)v18.i32;
          v24.f32[1] = *(float *)v19.i32 + *(float *)v18.i32;
          *(double *)v25.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v24, v16, *(double *)v21.i64, *(double *)&v17, v18, v19, v20);
          long long v17 = v27;
          int8x16_t v18 = v28;
          float32x4_t v21 = vmaxnmq_f32(v29, v25);
        }
        *(float *)v18.i32 = *(float *)v18.i32 + 1.0;
      }
      while (*(float *)v18.i32 <= v22);
      *(float *)&long long v17 = *(float *)&v17 + 1.0;
    }
    while (*(float *)&v17 <= v22);
  }
  return *(double *)v21.i64;
}

double cikernel::_minDisk(cikernel *this, SamplerObj *a2, float a3)
{
  DC = (CI *)CI::getDC(this);
  float32x2_t v6 = *(float32x2_t *)DC;
  double v7 = (float32x2_t *)CI::getDC(DC);
  *(float *)&double v8 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *v7, 1), *((float *)this + 4), COERCE_FLOAT(*v7));
  LODWORD(v9) = *((_DWORD *)this + 7);
  v10.i32[0] = *((_DWORD *)this + 9);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *v7, 1), *(float *)&v9, COERCE_FLOAT(*v7));
  *(float *)&double v12 = *((float *)this + 6) + *(float *)&v8;
  *(float *)v13.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  *((float *)&v12 + 1) = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v15.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v12, v13, v8, v9, v11, v10, v14);
  float32x4_t v21 = v15;
  float v22 = ceilf(a3);
  if (v22 >= 0.0)
  {
    float v23 = a3 * a3;
    *(float *)&long long v17 = -v22;
    do
    {
      *(float *)v18.i32 = -v22;
      long long v27 = v17;
      do
      {
        *(float32x2_t *)&v16.f64[0] = vmul_f32((float32x2_t)__PAIR64__(v18.u32[0], v17), (float32x2_t)__PAIR64__(v18.u32[0], v17));
        if (vaddv_f32(*(float32x2_t *)&v16.f64[0]) <= v23)
        {
          float32x2_t v24 = vadd_f32(v6, (float32x2_t)__PAIR64__(v18.u32[0], v17));
          int8x16_t v28 = v18;
          float32x4_t v29 = v21;
          v21.f32[0] = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v24, 1), *((float *)this + 4), v24.f32[0]);
          LODWORD(v17) = *((_DWORD *)this + 7);
          v19.i32[0] = *((_DWORD *)this + 9);
          *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v24, 1), *(float *)&v17, v24.f32[0]);
          v24.f32[0] = *((float *)this + 6) + v21.f32[0];
          *(float *)v16.f64 = *(float *)v19.i32 + *(float *)v18.i32;
          v24.f32[1] = *(float *)v19.i32 + *(float *)v18.i32;
          *(double *)v25.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v24, v16, *(double *)v21.i64, *(double *)&v17, v18, v19, v20);
          long long v17 = v27;
          int8x16_t v18 = v28;
          float32x4_t v21 = vminnmq_f32(v29, v25);
        }
        *(float *)v18.i32 = *(float *)v18.i32 + 1.0;
      }
      while (*(float *)v18.i32 <= v22);
      *(float *)&long long v17 = *(float *)&v17 + 1.0;
    }
    while (*(float *)&v17 <= v22);
  }
  return *(double *)v21.i64;
}

double cikernel::_max3x3(uint64_t a1, int8x16_t a2)
{
  v3.i64[0] = *(void *)CI::getDC((CI *)a1);
  int8x16_t v85 = v3;
  float64x2_t v4 = (float64x2_t)a2;
  float32x2_t v5 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)a2.i8, 1);
  *(float32x2_t *)v3.i8 = vsub_f32(*(float32x2_t *)v3.i8, v5);
  *(float *)&double v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v3.i8, 1), *(float *)(a1 + 16), *(float *)v3.i32);
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v3.i8, 1), *(float *)&v7, *(float *)v3.i32);
  *(float *)v3.i32 = *(float *)(a1 + 24) + *(float *)&v6;
  *(float *)v4.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  *(float *)&v3.i32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v11.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v3.i64, v4, v6, v7, v9, v8, v10);
  float32x4_t v76 = v11;
  float64x2_t v12 = (float64x2_t)vextq_s8(a2, a2, 8uLL);
  int8x8_t v78 = *(int8x8_t *)&v12.f64[0];
  float32x2_t v13 = (float32x2_t)vext_s8(*(int8x8_t *)&v12.f64[0], *(int8x8_t *)a2.i8, 4uLL);
  *(float32x2_t *)v11.f32 = vsub_f32(*(float32x2_t *)v85.i8, v13);
  *(float *)&double v14 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v11.f32, 1), *(float *)(a1 + 16), v11.f32[0]);
  LODWORD(v15) = *(_DWORD *)(a1 + 28);
  v16.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v11.f32, 1), *(float *)&v15, v11.f32[0]);
  v11.f32[0] = *(float *)(a1 + 24) + *(float *)&v14;
  *(float *)v12.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v11.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v11.i64, v12, v14, v15, v17, v16, v18);
  HIDWORD(v20) = a2.i32[1];
  float32x2_t v21 = (float32x2_t)vext_s8(*(int8x8_t *)a2.i8, v78, 4uLL);
  float32x2_t v22 = vadd_f32(v21, *(float32x2_t *)v85.i8);
  *(float *)&double v23 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v22, 1), *(float *)(a1 + 16), v22.f32[0]);
  LODWORD(v20) = *(_DWORD *)(a1 + 24);
  v24.i32[0] = *(_DWORD *)(a1 + 28);
  v25.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v22, 1), *(float *)v24.i32, v22.f32[0]);
  float64x2_t v27 = (float64x2_t)v76;
  float32x4_t v77 = vmaxnmq_f32(v76, v19);
  v19.f32[0] = *(float *)&v20 + *(float *)&v23;
  *(float *)v27.f64 = *(float *)v25.i32 + *(float *)v26.i32;
  v19.f32[1] = *(float *)v25.i32 + *(float *)v26.i32;
  *(double *)v28.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v19.i64, v27, v20, v23, v24, v26, v25);
  a2.i64[0] = __PAIR64__(v78.u32[1], a2.u32[0]);
  double v29 = *(double *)a2.i64;
  float32x2_t v30 = vsub_f32(*(float32x2_t *)v85.i8, *(float32x2_t *)a2.i8);
  *(float *)&double v31 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v30, 1), *(float *)(a1 + 16), v30.f32[0]);
  LODWORD(v29) = *(_DWORD *)(a1 + 24);
  v32.i32[0] = *(_DWORD *)(a1 + 28);
  v33.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v34.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v30, 1), *(float *)v32.i32, v30.f32[0]);
  float64x2_t v35 = (float64x2_t)v77;
  float32x4_t v79 = vmaxnmq_f32(v77, v28);
  v28.f32[0] = *(float *)&v29 + *(float *)&v31;
  *(float *)v35.f64 = *(float *)v33.i32 + *(float *)v34.i32;
  v28.f32[1] = *(float *)v33.i32 + *(float *)v34.i32;
  *(double *)v36.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v28.i64, v35, v29, v31, v32, v34, v33);
  float64x2_t v37 = (float64x2_t)v79;
  float32x4_t v80 = vmaxnmq_f32(v79, v36);
  LODWORD(v38) = *(_DWORD *)(a1 + 28);
  v36.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v85.i8, 1), *(float *)(a1 + 16), *(float *)v85.i32);
  LODWORD(v39) = *(_DWORD *)(a1 + 36);
  *(float *)v37.f64 = *(float *)&v39
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v85.i8, 1), *(float *)&v38, *(float *)v85.i32);
  v36.i32[1] = LODWORD(v37.f64[0]);
  *(double *)v42.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v36.i64, v37, v38, v39, v85, v40, v41);
  HIDWORD(v43) = a2.i32[1];
  float32x2_t v44 = vadd_f32(*(float32x2_t *)a2.i8, *(float32x2_t *)v85.i8);
  *(float *)&double v45 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v44, 1), *(float *)(a1 + 16), v44.f32[0]);
  LODWORD(v43) = *(_DWORD *)(a1 + 24);
  v46.i32[0] = *(_DWORD *)(a1 + 28);
  v47.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v48.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v44, 1), *(float *)v46.i32, v44.f32[0]);
  float64x2_t v49 = (float64x2_t)v80;
  float32x4_t v82 = vmaxnmq_f32(v80, v42);
  v42.f32[0] = *(float *)&v43 + *(float *)&v45;
  *(float *)v49.f64 = *(float *)v47.i32 + *(float *)v48.i32;
  v42.f32[1] = *(float *)v47.i32 + *(float *)v48.i32;
  *(double *)v50.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v42.i64, v49, v43, v45, v46, v48, v47);
  float32x2_t v51 = vsub_f32(*(float32x2_t *)v85.i8, v21);
  *(float *)&double v52 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v51, 1), *(float *)(a1 + 16), v51.f32[0]);
  LODWORD(v53) = *(_DWORD *)(a1 + 24);
  v54.i32[0] = *(_DWORD *)(a1 + 28);
  v55.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v56.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v51, 1), *(float *)v54.i32, v51.f32[0]);
  float64x2_t v57 = (float64x2_t)v82;
  float32x4_t v83 = vmaxnmq_f32(v82, v50);
  v50.f32[0] = *(float *)&v53 + *(float *)&v52;
  *(float *)v57.f64 = *(float *)v55.i32 + *(float *)v56.i32;
  v50.f32[1] = *(float *)v55.i32 + *(float *)v56.i32;
  *(double *)v58.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v50.i64, v57, v53, v52, v54, v56, v55);
  float32x2_t v59 = vadd_f32(v13, *(float32x2_t *)v85.i8);
  *(float *)&double v60 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v59, 1), *(float *)(a1 + 16), v59.f32[0]);
  LODWORD(v61) = *(_DWORD *)(a1 + 24);
  v62.i32[0] = *(_DWORD *)(a1 + 28);
  v63.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v64.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v59, 1), *(float *)v62.i32, v59.f32[0]);
  float64x2_t v65 = (float64x2_t)v83;
  float32x4_t v84 = vmaxnmq_f32(v83, v58);
  v58.f32[0] = *(float *)&v61 + *(float *)&v60;
  *(float *)v65.f64 = *(float *)v63.i32 + *(float *)v64.i32;
  v58.f32[1] = *(float *)v63.i32 + *(float *)v64.i32;
  *(double *)v66.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v58.i64, v65, v61, v60, v62, v64, v63);
  float32x2_t v67 = vadd_f32(v5, *(float32x2_t *)v85.i8);
  *(float *)&double v68 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v67, 1), *(float *)(a1 + 16), v67.f32[0]);
  LODWORD(v69) = *(_DWORD *)(a1 + 24);
  v70.i32[0] = *(_DWORD *)(a1 + 28);
  v71.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v72.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v67, 1), *(float *)v70.i32, v67.f32[0]);
  float64x2_t v73 = (float64x2_t)v84;
  float32x4_t v86 = vmaxnmq_f32(v84, v66);
  v66.f32[0] = *(float *)&v69 + *(float *)&v68;
  *(float *)v73.f64 = *(float *)v71.i32 + *(float *)v72.i32;
  v66.f32[1] = *(float *)v71.i32 + *(float *)v72.i32;
  *(double *)v74.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v66.i64, v73, v69, v68, v70, v72, v71);
  *(void *)&double result = vmaxnmq_f32(v86, v74).u64[0];
  return result;
}

double cikernel::_min3x3(uint64_t a1, int8x16_t a2)
{
  v3.i64[0] = *(void *)CI::getDC((CI *)a1);
  int8x16_t v85 = v3;
  float64x2_t v4 = (float64x2_t)a2;
  float32x2_t v5 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)a2.i8, 1);
  *(float32x2_t *)v3.i8 = vsub_f32(*(float32x2_t *)v3.i8, v5);
  *(float *)&double v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v3.i8, 1), *(float *)(a1 + 16), *(float *)v3.i32);
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v3.i8, 1), *(float *)&v7, *(float *)v3.i32);
  *(float *)v3.i32 = *(float *)(a1 + 24) + *(float *)&v6;
  *(float *)v4.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  *(float *)&v3.i32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v11.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v3.i64, v4, v6, v7, v9, v8, v10);
  float32x4_t v76 = v11;
  float64x2_t v12 = (float64x2_t)vextq_s8(a2, a2, 8uLL);
  int8x8_t v78 = *(int8x8_t *)&v12.f64[0];
  float32x2_t v13 = (float32x2_t)vext_s8(*(int8x8_t *)&v12.f64[0], *(int8x8_t *)a2.i8, 4uLL);
  *(float32x2_t *)v11.f32 = vsub_f32(*(float32x2_t *)v85.i8, v13);
  *(float *)&double v14 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v11.f32, 1), *(float *)(a1 + 16), v11.f32[0]);
  LODWORD(v15) = *(_DWORD *)(a1 + 28);
  v16.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v11.f32, 1), *(float *)&v15, v11.f32[0]);
  v11.f32[0] = *(float *)(a1 + 24) + *(float *)&v14;
  *(float *)v12.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v11.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v11.i64, v12, v14, v15, v17, v16, v18);
  HIDWORD(v20) = a2.i32[1];
  float32x2_t v21 = (float32x2_t)vext_s8(*(int8x8_t *)a2.i8, v78, 4uLL);
  float32x2_t v22 = vadd_f32(v21, *(float32x2_t *)v85.i8);
  *(float *)&double v23 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v22, 1), *(float *)(a1 + 16), v22.f32[0]);
  LODWORD(v20) = *(_DWORD *)(a1 + 24);
  v24.i32[0] = *(_DWORD *)(a1 + 28);
  v25.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v22, 1), *(float *)v24.i32, v22.f32[0]);
  float64x2_t v27 = (float64x2_t)v76;
  float32x4_t v77 = vminnmq_f32(v76, v19);
  v19.f32[0] = *(float *)&v20 + *(float *)&v23;
  *(float *)v27.f64 = *(float *)v25.i32 + *(float *)v26.i32;
  v19.f32[1] = *(float *)v25.i32 + *(float *)v26.i32;
  *(double *)v28.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v19.i64, v27, v20, v23, v24, v26, v25);
  a2.i64[0] = __PAIR64__(v78.u32[1], a2.u32[0]);
  double v29 = *(double *)a2.i64;
  float32x2_t v30 = vsub_f32(*(float32x2_t *)v85.i8, *(float32x2_t *)a2.i8);
  *(float *)&double v31 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v30, 1), *(float *)(a1 + 16), v30.f32[0]);
  LODWORD(v29) = *(_DWORD *)(a1 + 24);
  v32.i32[0] = *(_DWORD *)(a1 + 28);
  v33.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v34.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v30, 1), *(float *)v32.i32, v30.f32[0]);
  float64x2_t v35 = (float64x2_t)v77;
  float32x4_t v79 = vminnmq_f32(v77, v28);
  v28.f32[0] = *(float *)&v29 + *(float *)&v31;
  *(float *)v35.f64 = *(float *)v33.i32 + *(float *)v34.i32;
  v28.f32[1] = *(float *)v33.i32 + *(float *)v34.i32;
  *(double *)v36.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v28.i64, v35, v29, v31, v32, v34, v33);
  float64x2_t v37 = (float64x2_t)v79;
  float32x4_t v80 = vminnmq_f32(v79, v36);
  LODWORD(v38) = *(_DWORD *)(a1 + 28);
  v36.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v85.i8, 1), *(float *)(a1 + 16), *(float *)v85.i32);
  LODWORD(v39) = *(_DWORD *)(a1 + 36);
  *(float *)v37.f64 = *(float *)&v39
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v85.i8, 1), *(float *)&v38, *(float *)v85.i32);
  v36.i32[1] = LODWORD(v37.f64[0]);
  *(double *)v42.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v36.i64, v37, v38, v39, v85, v40, v41);
  HIDWORD(v43) = a2.i32[1];
  float32x2_t v44 = vadd_f32(*(float32x2_t *)a2.i8, *(float32x2_t *)v85.i8);
  *(float *)&double v45 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v44, 1), *(float *)(a1 + 16), v44.f32[0]);
  LODWORD(v43) = *(_DWORD *)(a1 + 24);
  v46.i32[0] = *(_DWORD *)(a1 + 28);
  v47.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v48.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v44, 1), *(float *)v46.i32, v44.f32[0]);
  float64x2_t v49 = (float64x2_t)v80;
  float32x4_t v82 = vminnmq_f32(v80, v42);
  v42.f32[0] = *(float *)&v43 + *(float *)&v45;
  *(float *)v49.f64 = *(float *)v47.i32 + *(float *)v48.i32;
  v42.f32[1] = *(float *)v47.i32 + *(float *)v48.i32;
  *(double *)v50.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v42.i64, v49, v43, v45, v46, v48, v47);
  float32x2_t v51 = vsub_f32(*(float32x2_t *)v85.i8, v21);
  *(float *)&double v52 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v51, 1), *(float *)(a1 + 16), v51.f32[0]);
  LODWORD(v53) = *(_DWORD *)(a1 + 24);
  v54.i32[0] = *(_DWORD *)(a1 + 28);
  v55.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v56.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v51, 1), *(float *)v54.i32, v51.f32[0]);
  float64x2_t v57 = (float64x2_t)v82;
  float32x4_t v83 = vminnmq_f32(v82, v50);
  v50.f32[0] = *(float *)&v53 + *(float *)&v52;
  *(float *)v57.f64 = *(float *)v55.i32 + *(float *)v56.i32;
  v50.f32[1] = *(float *)v55.i32 + *(float *)v56.i32;
  *(double *)v58.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v50.i64, v57, v53, v52, v54, v56, v55);
  float32x2_t v59 = vadd_f32(v13, *(float32x2_t *)v85.i8);
  *(float *)&double v60 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v59, 1), *(float *)(a1 + 16), v59.f32[0]);
  LODWORD(v61) = *(_DWORD *)(a1 + 24);
  v62.i32[0] = *(_DWORD *)(a1 + 28);
  v63.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v64.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v59, 1), *(float *)v62.i32, v59.f32[0]);
  float64x2_t v65 = (float64x2_t)v83;
  float32x4_t v84 = vminnmq_f32(v83, v58);
  v58.f32[0] = *(float *)&v61 + *(float *)&v60;
  *(float *)v65.f64 = *(float *)v63.i32 + *(float *)v64.i32;
  v58.f32[1] = *(float *)v63.i32 + *(float *)v64.i32;
  *(double *)v66.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v58.i64, v65, v61, v60, v62, v64, v63);
  float32x2_t v67 = vadd_f32(v5, *(float32x2_t *)v85.i8);
  *(float *)&double v68 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v67, 1), *(float *)(a1 + 16), v67.f32[0]);
  LODWORD(v69) = *(_DWORD *)(a1 + 24);
  v70.i32[0] = *(_DWORD *)(a1 + 28);
  v71.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v72.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v67, 1), *(float *)v70.i32, v67.f32[0]);
  float64x2_t v73 = (float64x2_t)v84;
  float32x4_t v86 = vminnmq_f32(v84, v66);
  v66.f32[0] = *(float *)&v69 + *(float *)&v68;
  *(float *)v73.f64 = *(float *)v71.i32 + *(float *)v72.i32;
  v66.f32[1] = *(float *)v71.i32 + *(float *)v72.i32;
  *(double *)v74.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v66.i64, v73, v69, v68, v70, v72, v71);
  *(void *)&double result = vminnmq_f32(v86, v74).u64[0];
  return result;
}

double cikernel::_gradient(float32x4_t a1, float32x4_t a2)
{
  v2.i64[0] = 0x3F0000003F000000;
  v2.i64[1] = 0x3F0000003F000000;
  *(void *)&double result = vmulq_f32(vsubq_f32(a1, a2), v2).u64[0];
  return result;
}

double cikernel::_laplacian(float32x4_t a1, float32x4_t a2, float32x4_t a3)
{
  float32x4_t v3 = vsubq_f32(vaddq_f32(a2, a3), vaddq_f32(a1, a1));
  v4.i64[0] = 0x3F0000003F000000;
  v4.i64[1] = 0x3F0000003F000000;
  *(void *)&double result = vmulq_f32(v3, v4).u64[0];
  return result;
}

double cikernel::_average(float32x4_t a1, float32x4_t a2, float a3)
{
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - a3), a2, a3).u64[0];
  return result;
}

void cikernel::_morphmin(uint64_t a1, float a2, float32x2_t a3)
{
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)v7.i8 = *DC;
  LODWORD(v8) = *(_DWORD *)(a1 + 28);
  *(float *)&double v9 = *(float *)(a1 + 24)
                + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v10) = *(_DWORD *)(a1 + 36);
  float64x2_t v25 = (float64x2_t)v7;
  *(float *)v11.f64 = *(float *)&v10
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)&v8, COERCE_FLOAT(*DC));
  HIDWORD(v9) = LODWORD(v11.f64[0]);
  *(double *)v14.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v9, v11, v8, v10, v7, v12, v13);
  if (a2 >= 0.0)
  {
    *(float *)&long long v15 = -a2;
    do
    {
      long long v26 = v15;
      float32x4_t v27 = v14;
      float32x2_t v21 = vmul_n_f32(a3, *(float *)&v15);
      float64x2_t v22 = v25;
      float32x2_t v23 = vadd_f32(*(float32x2_t *)&v25.f64[0], v21);
      *(float *)&double v16 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v23, 1), *(float *)(a1 + 16), v23.f32[0]);
      LODWORD(v17) = *(_DWORD *)(a1 + 28);
      v19.i32[0] = *(_DWORD *)(a1 + 36);
      *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v23, 1), *(float *)&v17, v23.f32[0]);
      v23.f32[0] = *(float *)(a1 + 24) + *(float *)&v16;
      *(float *)v22.f64 = *(float *)v19.i32 + *(float *)v18.i32;
      v23.f32[1] = *(float *)v19.i32 + *(float *)v18.i32;
      *(double *)v24.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v23, v22, v16, v17, v18, v19, v20);
      long long v15 = v26;
      float32x4_t v14 = vminnmq_f32(v27, v24);
      *(float *)&long long v15 = *(float *)&v26 + 1.0;
    }
    while ((float)(*(float *)&v26 + 1.0) <= a2);
  }
}

void cikernel::_morphmax(uint64_t a1, float a2, float32x2_t a3)
{
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)v7.i8 = *DC;
  LODWORD(v8) = *(_DWORD *)(a1 + 28);
  *(float *)&double v9 = *(float *)(a1 + 24)
                + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v10) = *(_DWORD *)(a1 + 36);
  float64x2_t v25 = (float64x2_t)v7;
  *(float *)v11.f64 = *(float *)&v10
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)&v8, COERCE_FLOAT(*DC));
  HIDWORD(v9) = LODWORD(v11.f64[0]);
  *(double *)v14.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v9, v11, v8, v10, v7, v12, v13);
  if (a2 >= 0.0)
  {
    *(float *)&long long v15 = -a2;
    do
    {
      long long v26 = v15;
      float32x4_t v27 = v14;
      float32x2_t v21 = vmul_n_f32(a3, *(float *)&v15);
      float64x2_t v22 = v25;
      float32x2_t v23 = vadd_f32(*(float32x2_t *)&v25.f64[0], v21);
      *(float *)&double v16 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v23, 1), *(float *)(a1 + 16), v23.f32[0]);
      LODWORD(v17) = *(_DWORD *)(a1 + 28);
      v19.i32[0] = *(_DWORD *)(a1 + 36);
      *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v23, 1), *(float *)&v17, v23.f32[0]);
      v23.f32[0] = *(float *)(a1 + 24) + *(float *)&v16;
      *(float *)v22.f64 = *(float *)v19.i32 + *(float *)v18.i32;
      v23.f32[1] = *(float *)v19.i32 + *(float *)v18.i32;
      *(double *)v24.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v23, v22, v16, v17, v18, v19, v20);
      long long v15 = v26;
      float32x4_t v14 = vmaxnmq_f32(v27, v24);
      *(float *)&long long v15 = *(float *)&v26 + 1.0;
    }
    while ((float)(*(float *)&v26 + 1.0) <= a2);
  }
}

int64x2_t Rectangle::Union@<Q0>(Rectangle *this@<X0>, const Rectangle *a2@<X1>, uint64_t a3@<X8>, int64x2_t result@<Q0>)
{
  double var0 = this->var0;
  if (fabs(this->var0) == INFINITY || (double var1 = this->var1, fabs(var1) == INFINITY))
  {
    double result = *(int64x2_t *)&a2->var0;
    int64x2_t v6 = *(int64x2_t *)&a2->var2;
LABEL_4:
    *(int64x2_t *)a3 = result;
    *(int64x2_t *)(a3 + 16) = v6;
    return result;
  }
  double v7 = a2->var0;
  if (fabs(a2->var0) == INFINITY || (double v8 = a2->var1, fabs(v8) == INFINITY))
  {
    double result = *(int64x2_t *)&this->var0;
    int64x2_t v6 = *(int64x2_t *)&this->var2;
    goto LABEL_4;
  }
  BOOL v9 = var0 == -8.98846567e307 && var1 == -8.98846567e307;
  if (v9 && this->var2 == 1.79769313e308 && this->var3 == 1.79769313e308)
  {
    double result = vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    int64x2_t v6 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    goto LABEL_4;
  }
  float64x2_t v10 = *(float64x2_t *)&a2->var2;
  float64x2_t v11 = (float64x2_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  if (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_f64(*(float64x2_t *)&a2->var0, (float64x2_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL)), (int32x4_t)vceqq_f64(v10, v11))))))
  {
    double v12 = var0 + this->var2;
    double v13 = fmin(fmin(var0, v12), fmin(v7, v7 + v10.f64[0]));
    double v14 = var1 + this->var3;
    double v15 = fmin(fmin(var1, v14), fmin(v8, v8 + v10.f64[1]));
    *(double *)result.i64 = fmax(fmax(var0, v12), fmax(v7, v7 + v10.f64[0])) - v13;
    *(double *)a3 = v13;
    *(double *)(a3 + 8) = v15;
    *(void *)(a3 + 16) = result.i64[0];
    *(double *)(a3 + 24) = fmax(fmax(var1, v14), fmax(v8, v8 + v10.f64[1])) - v15;
  }
  else
  {
    double result = vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    *(int64x2_t *)a3 = result;
    *(float64x2_t *)(a3 + 16) = v11;
  }
  return result;
}

double cikernel::_motionBlur(uint64_t a1, float32x4_t a2)
{
  v3.f64[0] = *(float64_t *)CI::getDC((CI *)a1);
  int8x16_t v44 = (int8x16_t)v3;
  float32x2_t v4 = vadd_f32(*(float32x2_t *)a2.f32, *(float32x2_t *)a2.f32);
  float32x2_t v5 = vsub_f32(*(float32x2_t *)&v3.f64[0], v4);
  *(float *)&double v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v5, 1), *(float *)(a1 + 16), v5.f32[0]);
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *(float *)(a1 + 24) + *(float *)&v6;
  *(float *)v3.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v11.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v5, v3, v6, v7, v9, v8, v10);
  float32x4_t v43 = v11;
  float64x2_t v12 = (float64x2_t)v44;
  *(float32x2_t *)v11.f32 = vsub_f32(*(float32x2_t *)v44.i8, *(float32x2_t *)a2.f32);
  *(float *)&double v13 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v11.f32, 1), *(float *)(a1 + 16), v11.f32[0]);
  LODWORD(v14) = *(_DWORD *)(a1 + 28);
  v15.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v11.f32, 1), *(float *)&v14, v11.f32[0]);
  v11.f32[0] = *(float *)(a1 + 24) + *(float *)&v13;
  *(float *)v12.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v11.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  *(double *)v18.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v11.i64, v12, v13, v14, v16, v15, v17);
  float32x4_t v42 = v18;
  LODWORD(v19) = *(_DWORD *)(a1 + 28);
  v18.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v44.i8, 1), *(float *)(a1 + 16), *(float *)v44.i32);
  LODWORD(v20) = *(_DWORD *)(a1 + 36);
  *(float *)v21.f64 = *(float *)&v20
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v44.i8, 1), *(float *)&v19, *(float *)v44.i32);
  v18.i32[1] = LODWORD(v21.f64[0]);
  *(double *)v24.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v18.i64, v21, v19, v20, v44, v22, v23);
  float32x4_t v41 = v24;
  float64x2_t v25 = (float64x2_t)v44;
  *(float32x2_t *)v24.f32 = vadd_f32(*(float32x2_t *)a2.f32, *(float32x2_t *)v44.i8);
  *(float *)&double v26 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v24.f32, 1), *(float *)(a1 + 16), v24.f32[0]);
  LODWORD(v27) = *(_DWORD *)(a1 + 28);
  v28.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v29.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v24.f32, 1), *(float *)&v27, v24.f32[0]);
  v24.f32[0] = *(float *)(a1 + 24) + *(float *)&v26;
  *(float *)v25.f64 = *(float *)v28.i32 + *(float *)v29.i32;
  v24.f32[1] = *(float *)v28.i32 + *(float *)v29.i32;
  *(double *)v31.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v24.i64, v25, v26, v27, v29, v28, v30);
  float32x4_t v40 = v31;
  *(float32x2_t *)v31.f32 = vadd_f32(v4, *(float32x2_t *)v44.i8);
  *(float *)&double v32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v31.f32, 1), *(float *)(a1 + 16), v31.f32[0]);
  LODWORD(v33) = *(_DWORD *)(a1 + 28);
  v34.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v35.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v31.f32, 1), *(float *)&v33, v31.f32[0]);
  v31.f32[0] = *(float *)(a1 + 24) + *(float *)&v32;
  *(float *)v36.f64 = *(float *)v34.i32 + *(float *)v35.i32;
  v31.f32[1] = *(float *)v34.i32 + *(float *)v35.i32;
  *(double *)v38.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v31.i64, v36, v32, v33, v35, v34, v37);
  *(void *)&double result = vaddq_f32(vmulq_laneq_f32(v41, a2, 2), vmulq_laneq_f32(vaddq_f32(vaddq_f32(v42, v40), vmulq_laneq_f32(vaddq_f32(v43, v38), a2, 3)), a2, 3)).u64[0];
  return result;
}

double cikernel::_zoomBlur(uint64_t a1, float32x2_t a2, float32x4_t a3, float32x4_t a4, float a5)
{
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  float32x2_t v8 = vsub_f32(*DC, a2);
  int8x16_t v9 = (float32x2_t *)CI::getDC((CI *)DC);
  *(float *)&double v10 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *v9, 1), *(float *)(a1 + 16), COERCE_FLOAT(*v9));
  LODWORD(v11) = *(_DWORD *)(a1 + 28);
  v12.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v13.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *v9, 1), *(float *)&v11, COERCE_FLOAT(*v9));
  *(float *)&double v14 = *(float *)(a1 + 24) + *(float *)&v10;
  *(float *)v15.f64 = *(float *)v12.i32 + *(float *)v13.i32;
  *((float *)&v14 + 1) = *(float *)v12.i32 + *(float *)v13.i32;
  *(double *)v17.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v14, v15, v10, v11, v13, v12, v16);
  float32x4_t v50 = v17;
  *(float32x2_t *)v17.f32 = vadd_f32(a2, vmul_n_f32(v8, a3.f32[0]));
  *(float *)&double v18 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v17.f32, 1), *(float *)(a1 + 16), v17.f32[0]);
  LODWORD(v19) = *(_DWORD *)(a1 + 28);
  v20.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v21.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v17.f32, 1), *(float *)&v19, v17.f32[0]);
  v17.f32[0] = *(float *)(a1 + 24) + *(float *)&v18;
  *(float *)v22.f64 = *(float *)v20.i32 + *(float *)v21.i32;
  v17.f32[1] = *(float *)v20.i32 + *(float *)v21.i32;
  *(double *)v24.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v17.i64, v22, v18, v19, v21, v20, v23);
  float32x4_t v49 = v24;
  *(float32x2_t *)v24.f32 = vadd_f32(a2, vmul_lane_f32(v8, *(float32x2_t *)a3.f32, 1));
  *(float *)&double v25 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v24.f32, 1), *(float *)(a1 + 16), v24.f32[0]);
  LODWORD(v26) = *(_DWORD *)(a1 + 28);
  v27.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v28.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v24.f32, 1), *(float *)&v26, v24.f32[0]);
  v24.f32[0] = *(float *)(a1 + 24) + *(float *)&v25;
  *(float *)v29.f64 = *(float *)v27.i32 + *(float *)v28.i32;
  v24.f32[1] = *(float *)v27.i32 + *(float *)v28.i32;
  *(double *)v31.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v24.i64, v29, v25, v26, v28, v27, v30);
  float32x4_t v48 = v31;
  *(float32x2_t *)v31.f32 = vadd_f32(a2, vmul_laneq_f32(v8, a3, 2));
  *(float *)&double v32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v31.f32, 1), *(float *)(a1 + 16), v31.f32[0]);
  LODWORD(v33) = *(_DWORD *)(a1 + 28);
  v34.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v35.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v31.f32, 1), *(float *)&v33, v31.f32[0]);
  v31.f32[0] = *(float *)(a1 + 24) + *(float *)&v32;
  *(float *)v36.f64 = *(float *)v34.i32 + *(float *)v35.i32;
  v31.f32[1] = *(float *)v34.i32 + *(float *)v35.i32;
  *(double *)v38.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v31.i64, v36, v32, v33, v35, v34, v37);
  float32x4_t v47 = v38;
  *(float32x2_t *)v38.f32 = vadd_f32(a2, vmul_laneq_f32(v8, a3, 3));
  *(float *)&double v39 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v38.f32, 1), *(float *)(a1 + 16), v38.f32[0]);
  LODWORD(v40) = *(_DWORD *)(a1 + 28);
  v41.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v42.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v38.f32, 1), *(float *)&v40, v38.f32[0]);
  v38.f32[0] = *(float *)(a1 + 24) + *(float *)&v39;
  *(float *)v43.f64 = *(float *)v41.i32 + *(float *)v42.i32;
  v38.f32[1] = *(float *)v41.i32 + *(float *)v42.i32;
  *(double *)v45.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v38.i64, v43, v39, v40, v42, v41, v44);
  *(void *)&double result = vaddq_f32(vmulq_n_f32(v50, a5), vaddq_f32(vmulq_laneq_f32(v49, a4, 3), vaddq_f32(vmulq_laneq_f32(v48, a4, 2), vaddq_f32(vmulq_lane_f32(v47, *(float32x2_t *)a4.f32, 1), vmulq_n_f32(v45, a4.f32[0]))))).u64[0];
  return result;
}

void CI::f4_sr_f2_f4_f4_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = *(void *)(a1 + 48);
  double v11 = *(double (**)(uint64_t, double, __n128, __n128, float))(a1 + 24);
  uint64_t v12 = *(void *)(v10 + 8);
  int v13 = *(_DWORD *)(v10 + 40);
  uint64_t v14 = *(void *)(v10 + 32);
  int v15 = *(_DWORD *)(v10 + 64);
  uint64_t v16 = *(void *)(v10 + 56);
  int v17 = *(_DWORD *)(v10 + 88);
  uint64_t v18 = *(void *)(v10 + 80);
  uint64_t v19 = *(void *)(v10 + 104);
  if (*(unsigned char *)(a1 + 64))
  {
    int v24 = *(_DWORD *)(v10 + 88);
    int v25 = *(_DWORD *)(v10 + 40);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 128)), a2);
    int v17 = v24;
    int v13 = v25;
  }
  int8x16_t v20 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5) {
    int8x16_t v20 = (__n128 *)((char *)a2 + 64 * v18);
  }
  int8x16_t v21 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5) {
    int8x16_t v21 = (__n128 *)((char *)a2 + 64 * v16);
  }
  float64x2_t v22 = (double *)(a3 + 16 * v14);
  if (v13 != 5) {
    float64x2_t v22 = (double *)((char *)a2 + 64 * v14);
  }
  *(double *)&long long v23 = v11(a4 + 80 * v12, *v22, *v21, *v20, *((float *)a2 + 16 * v19));
  *(_OWORD *)(a3 + 16 * a7) = v23;
}

void cikernel::_zoom(uint64_t a1, float32x2_t a2, float a3)
{
  int v6 = 0;
  float32x2_t v12 = vsub_f32(*(float32x2_t *)CI::getDC((CI *)a1), a2);
  float32x4_t v13 = 0uLL;
  float64x2_t v14 = (float64x2_t)vdupq_n_s32(0x3C23D70Au);
  float32x4_t v18 = (float32x4_t)v14;
  do
  {
    float32x4_t v19 = v13;
    float v15 = (float)((float)((float)((float)v6 / 99.0) + -0.5)
                + (float)((float)((float)((float)((float)v6 / 99.0) + -0.5) * (float)((float)((float)v6 / 99.0) + -0.5))
                        * (float)((float)((float)v6 / 99.0) + -0.5)))
        * 0.8
        + 0.5;
    float32x2_t v16 = vadd_f32(a2, vmul_n_f32(v12, v15 + (float)(a3 * (float)(1.0 - v15))));
    *(float *)&double v7 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v16, 1), *(float *)(a1 + 16), v16.f32[0]);
    LODWORD(v8) = *(_DWORD *)(a1 + 28);
    v10.i32[0] = *(_DWORD *)(a1 + 36);
    *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v16, 1), *(float *)&v8, v16.f32[0]);
    v16.f32[0] = *(float *)(a1 + 24) + *(float *)&v7;
    *(float *)v14.f64 = *(float *)v10.i32 + *(float *)v9.i32;
    v16.f32[1] = *(float *)v10.i32 + *(float *)v9.i32;
    *(double *)v17.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v16, v14, v7, v8, v9, v10, v11);
    float64x2_t v14 = (float64x2_t)vaddq_f32(v19, vmulq_f32(v17, v18));
    float32x4_t v13 = (float32x4_t)v14;
    ++v6;
  }
  while (v6 != 100);
}

void CI::f4_sr_f2_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = *(void *)(a1 + 48);
  float32x2_t v12 = *(double (**)(uint64_t, double, float))(a1 + 24);
  uint64_t v13 = *(void *)(v11 + 8);
  int v14 = *(_DWORD *)(v11 + 40);
  uint64_t v15 = *(void *)(v11 + 32);
  uint64_t v16 = *(void *)(v11 + 56);
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC((CI *)(a3 + 16 * *(void *)(v11 + 80)), a2);
  }
  float32x4_t v17 = (double *)(a3 + 16 * v15);
  if (v14 != 5) {
    float32x4_t v17 = (double *)((char *)a2 + 64 * v15);
  }
  *(double *)&long long v18 = v12(a4 + 80 * v13, *v17, *((float *)a2 + 16 * v16));
  *(_OWORD *)(a3 + 16 * a7) = v18;
}

double cikernel::_opTile(uint64_t a1, float32x2_t a2, double a3, int8x16_t a4)
{
  float32x2_t v6 = vsub_f32(*(float32x2_t *)CI::getDC((CI *)a1), a2);
  *(float32x2_t *)&v9.f64[0] = vmul_lane_f32(vrndm_f32(vmul_n_f32(v6, *(float *)&a3)), *(float32x2_t *)&a3, 1);
  float32x2_t v11 = vsub_f32(v6, *(float32x2_t *)&v9.f64[0]);
  int32x2_t v13 = (int32x2_t)vmul_f32(*(float32x2_t *)a4.i8, *(float32x2_t *)&v9.f64[0]);
  *(float32x2_t *)&v9.f64[0] = vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), *(float32x2_t *)&v9.f64[0]);
  float32x2_t v10 = (float32x2_t)vzip1_s32(v13, *(int32x2_t *)&v9.f64[0]);
  *(float32x2_t *)&v9.f64[0] = vadd_f32(a2, vadd_f32(v11, vadd_f32(v10, (float32x2_t)vzip2_s32(v13, *(int32x2_t *)&v9.f64[0]))));
  v10.i32[0] = *(_DWORD *)(a1 + 28);
  v11.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v9.f64[0], 1), *(float *)(a1 + 16), *(float *)v9.f64);
  v12.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v13.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v9.f64[0], 1), v10.f32[0], *(float *)v9.f64);
  int v14 = *(uint64x2_t **)(a1 + 8);

  v11.f32[1] = *(float *)v12.i32 + *(float *)v13.i32;
  *(float *)v9.f64 = *(float *)v12.i32 + *(float *)v13.i32;
  return CI::BitmapSampler::read(v14, *(double *)&v11, v9, *(double *)&v13, *(double *)&v10, v12, v7, v8);
}

void CI::f4_sr_f2_f2_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = *(void *)(a1 + 48);
  float32x2_t v11 = *(double (**)(uint64_t, double, double, __n128))(a1 + 24);
  uint64_t v12 = *(void *)(v10 + 8);
  int v13 = *(_DWORD *)(v10 + 40);
  uint64_t v14 = *(void *)(v10 + 32);
  int v15 = *(_DWORD *)(v10 + 64);
  uint64_t v16 = *(void *)(v10 + 56);
  int v17 = *(_DWORD *)(v10 + 88);
  uint64_t v18 = *(void *)(v10 + 80);
  if (*(unsigned char *)(a1 + 64))
  {
    int v23 = *(_DWORD *)(v10 + 64);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 104)), a2);
    int v15 = v23;
  }
  float32x4_t v19 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5) {
    float32x4_t v19 = (__n128 *)((char *)a2 + 64 * v18);
  }
  int8x16_t v20 = (double *)(a3 + 16 * v16);
  if (v15 != 5) {
    int8x16_t v20 = (double *)((char *)a2 + 64 * v16);
  }
  int8x16_t v21 = (double *)(a3 + 16 * v14);
  if (v13 != 5) {
    int8x16_t v21 = (double *)((char *)a2 + 64 * v14);
  }
  *(double *)&long long v22 = v11(a4 + 80 * v12, *v21, *v20, *v19);
  *(_OWORD *)(a3 + 16 * a7) = v22;
}

void pageCurlMapInverse(CGPoint a1, CGAffineTransform *a2, CGAffineTransform *a3)
{
  CGFloat v3 = a2->tx + a1.y * a2->c + a2->a * a1.x;
  if (v3 > 0.0 && v3 < 3.14159265) {
    sin(v3);
  }
}

uint64_t CriticalPointsDOD(CGRect a1, CGAffineTransform *a2, CGPoint *a3)
{
  CGRect v22 = CGRectStandardize(a1);
  tdouble x = a2->tx + -1.57079633;
  a2->tdouble x = tx;
  double a = a2->a;
  double c = a2->c;
  double v8 = -(tx + v22.origin.x * a2->a) / c;
  double v9 = v22.origin.y + v22.size.height;
  if (v8 < v22.origin.y || v8 > v9)
  {
    uint64_t result = 0;
  }
  else
  {
    a3->double x = v22.origin.x;
    a3->double y = v8;
    double a = a2->a;
    tdouble x = a2->tx;
    uint64_t result = 1;
    double c = a2->c;
  }
  double v12 = v22.origin.x + v22.size.width;
  double v13 = -(tx + v12 * a) / c;
  if (v13 >= v22.origin.y && v13 <= v9)
  {
    int v15 = &a3[result];
    uint64_t result = (result + 1);
    v15->double x = v12;
    v15->double y = v13;
    double c = a2->c;
    tdouble x = a2->tx;
    double a = a2->a;
  }
  double v16 = -(tx + v22.origin.y * c) / a;
  if (v16 >= v22.origin.x && v16 <= v12)
  {
    uint64_t v18 = &a3[result];
    uint64_t result = (result + 1);
    v18->double x = v16;
    v18->double y = v22.origin.y;
    double c = a2->c;
    tdouble x = a2->tx;
    double a = a2->a;
  }
  double v19 = -(tx + v9 * c) / a;
  if (v19 >= v22.origin.x && v19 <= v12)
  {
    int8x16_t v21 = &a3[result];
    uint64_t result = (result + 1);
    v21->double x = v19;
    v21->double y = v9;
  }
  return result;
}

void pageCurlROI(int a1, float64x2_t *a2, double *a3, double *a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  v89[15] = *(double *)MEMORY[0x1E4F143B8];
  if (a1 == 2) {
    return;
  }
  *(double *)float32x2_t v67 = a9;
  *(double *)&v67[8] = a10;
  *(double *)&v67[16] = a11;
  *(double *)&v67[24] = a12;
  double v17 = *MEMORY[0x1E4F1DB20];
  double y = *(double *)(MEMORY[0x1E4F1DB20] + 8);
  double width = *(double *)(MEMORY[0x1E4F1DB20] + 16);
  double height = *(double *)(MEMORY[0x1E4F1DB20] + 24);
  double v20 = a2->f64[0];
  double v21 = a2[1].f64[0];
  double v22 = a2[2].f64[0];
  CGRect v90 = CGRectStandardize(*(CGRect *)&a5);
  double v23 = v22 + -0.999;
  double v24 = -(v22 + -0.999 + v90.origin.x * v20) / v21;
  double v25 = v90.origin.y + v90.size.height;
  if (v24 < v90.origin.y || v24 > v25)
  {
    unsigned int v27 = 0;
  }
  else
  {
    CGFloat x = v90.origin.x;
    v89[0] = -(v22 + -0.999 + v90.origin.x * v20) / v21;
    unsigned int v27 = 1;
  }
  double v28 = v90.origin.x + v90.size.width;
  double v29 = -(v23 + v28 * v20) / v21;
  if (v29 >= v90.origin.y && v29 <= v25)
  {
    float32x4_t v31 = &v89[2 * v27++ - 1];
    *float32x4_t v31 = v28;
    v31[1] = v29;
  }
  double v32 = -(v23 + v90.origin.y * v21) / v20;
  if (v32 >= v90.origin.x && v32 <= v28)
  {
    int8x16_t v34 = &v89[2 * v27++ - 1];
    *int8x16_t v34 = v32;
    v34[1] = v90.origin.y;
  }
  double v35 = -(v23 + v25 * v21) / v20;
  if (v35 >= v90.origin.x && v35 <= v28)
  {
    int8x16_t v37 = &v89[2 * v27++ - 1];
    *int8x16_t v37 = v35;
    v37[1] = v25;
  }
  if (v23 + v21 * v90.origin.y + v90.origin.x * v20 <= 0.0)
  {
    float32x4_t v38 = &v89[2 * v27++ - 1];
    *float32x4_t v38 = v90.origin.x;
    v38[1] = v90.origin.y;
  }
  if (v23 + v21 * v25 + v90.origin.x * v20 <= 0.0)
  {
    double v39 = &v89[2 * v27++ - 1];
    *double v39 = v90.origin.x;
    v39[1] = v25;
  }
  if (v23 + v21 * v25 + v28 * v20 <= 0.0)
  {
    double v40 = &v89[2 * v27++ - 1];
    *double v40 = v28;
    v40[1] = v25;
  }
  if (v23 + v21 * v90.origin.y + v28 * v20 <= 0.0)
  {
    float32x4_t v45 = &v89[2 * v27++ - 1];
    *float32x4_t v45 = v28;
    v45[1] = v90.origin.y;
LABEL_33:
    int8x16_t v46 = v89;
    double v44 = height;
    double v43 = width;
    double v42 = y;
    CGFloat v41 = v17;
    uint64_t v47 = v27;
    do
    {
      CGFloat r1 = v44;
      CGFloat v77 = height;
      CGFloat v78 = width;
      CGFloat v79 = v17;
      CGFloat v80 = y;
      CGFloat v81 = v43;
      CGFloat v82 = v42;
      CGFloat v83 = v41;
      double v70 = *v46;
      double v48 = *a3;
      double v49 = a3[1];
      double v50 = a3[2];
      double v51 = a3[3];
      double v52 = a3[4];
      double v53 = a3[5];
      double v54 = a4[2];
      double v74 = *a4;
      double v75 = a4[1];
      double v71 = a4[4];
      double v72 = a4[5];
      double v73 = a4[3];
      v87[0] = *(v46 - 1);
      double v69 = v87[0];
      v87[1] = v70;
      float64x2_t v68 = vaddq_f64(a2[2], vmlaq_n_f64(vmulq_n_f64(a2[1], v70), *a2, v87[0]));
      float64x2_t v84 = v68;
      float64x2_t v85 = v68;
      long double v55 = asin(v68.f64[0]);
      v85.f64[0] = v52 + v50 * v85.f64[1] + v48 * v55;
      v85.f64[1] = v53 + v51 * v85.f64[1] + v49 * v55;
      v84.f64[0] = v52 + vmuld_lane_f64(v50, v68, 1) + v48 * (3.14159265 - v55);
      v84.f64[1] = v53 + vmuld_lane_f64(v51, v68, 1) + v49 * (3.14159265 - v55);
      if (v68.f64[0] > 0.0) {
        int8x16_t v56 = (double *)&v85;
      }
      else {
        int8x16_t v56 = v87;
      }
      float64x2_t v57 = *(float64x2_t *)v56;
      v86[0] = v71 + v70 * v54 + v74 * v69;
      v86[1] = v72 + v70 * v73 + v75 * v69;
      if (v68.f64[0] > 0.0) {
        float32x4_t v58 = (double *)&v84;
      }
      else {
        float32x4_t v58 = v86;
      }
      float64x2_t v84 = *(float64x2_t *)v58;
      float64x2_t v85 = v57;
      if (v68.f64[0] > 0.0) {
        double v60 = v57.f64[1];
      }
      else {
        double v60 = v70;
      }
      CGFloat v61 = *v58;
      if (v68.f64[0] > 0.0) {
        double v62 = v84.f64[1];
      }
      else {
        double v62 = v72 + v70 * v73 + v75 * v69;
      }
      uint64_t v63 = 0;
      uint64_t v64 = 0;
      v91.origin.CGFloat x = v79;
      v91.origin.double y = v80;
      v91.size.double height = v77;
      v91.size.double width = v78;
      uint64_t v59 = *(void *)v56;
      CGRect v92 = CGRectUnion(v91, *(CGRect *)(&v60 - 1));
      double v17 = v92.origin.x;
      double y = v92.origin.y;
      double width = v92.size.width;
      double height = v92.size.height;
      v94.size.double width = 0.0;
      v94.size.double height = 0.0;
      v92.origin.double y = v82;
      v92.origin.CGFloat x = v83;
      v92.size.double width = v81;
      v92.size.double height = r1;
      v94.origin.CGFloat x = v61;
      v94.origin.double y = v62;
      *(CGRect *)&CGFloat v41 = CGRectUnion(v92, v94);
      v46 += 2;
      --v47;
    }
    while (v47);
    goto LABEL_47;
  }
  if (v27) {
    goto LABEL_33;
  }
  CGFloat v41 = v17;
  double v42 = y;
  double v43 = width;
  double v44 = height;
LABEL_47:
  if (a1) {
    CGFloat v65 = v44;
  }
  else {
    CGFloat v65 = height;
  }
  if (a1) {
    CGFloat v66 = v43;
  }
  else {
    CGFloat v66 = width;
  }
  if (a1)
  {
    double y = v42;
    double v17 = v41;
  }
  CGRect v95 = CGRectInset(*(CGRect *)v67, -1.0, -1.0);
  v93.origin.CGFloat x = v17;
  v93.origin.double y = y;
  v93.size.double width = v66;
  v93.size.double height = v65;
  CGRectIntersection(v93, v95);
}

double cikernel::_pageCurlTransition(uint64_t a1, uint64_t a2, uint64_t a3, int8x16_t a4, float32x2_t a5, int8x16_t a6, float32x2_t a7, int8x16_t a8, float32x2_t a9, float a10, int8x16_t a11)
{
  float32x2_t v18 = *(float32x2_t *)CI::getDC((CI *)a1);
  int32x2_t v19 = (int32x2_t)vmul_f32(*(float32x2_t *)a4.i8, v18);
  int32x2_t v20 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v18);
  *(float32x2_t *)&v21.f64[0] = vadd_f32(a5, vadd_f32((float32x2_t)vzip1_s32(v19, v20), (float32x2_t)vzip2_s32(v19, v20)));
  float64x2_t v71 = v21;
  double v22 = *(float *)v21.f64;
  float v23 = sqrt(1.0 - pow(*(float *)v21.f64, 1.5)) + -1.0;
  float v24 = v22 + (float)(v23 * v23) * 0.5625;
  float64x2_t v25 = v71;
  *(float *)v25.f64 = v24;
  *(float *)&unsigned int v26 = 3.14159265 - v24;
  v27.i64[1] = *(void *)&v71.f64[1];
  float32x2_t v28 = (float32x2_t)__PAIR64__(HIDWORD(v71.f64[0]), v26);
  int32x2_t v29 = (int32x2_t)vmul_f32(*(float32x2_t *)a6.i8, *(float32x2_t *)&v25.f64[0]);
  float32x2_t v30 = (float32x2_t)vextq_s8(a6, a6, 8uLL).u64[0];
  int8x16_t v31 = a6;
  *(float32x2_t *)&v25.f64[0] = vmul_f32(v30, *(float32x2_t *)&v25.f64[0]);
  int8x8_t v32 = (int8x8_t)vadd_f32(a7, vadd_f32((float32x2_t)vzip1_s32(v29, *(int32x2_t *)&v25.f64[0]), (float32x2_t)vzip2_s32(v29, *(int32x2_t *)&v25.f64[0])));
  *(float32x2_t *)&v25.f64[0] = vmul_f32(*(float32x2_t *)a6.i8, v28);
  int32x2_t v33 = (int32x2_t)vmul_f32(v30, v28);
  *(float32x2_t *)&v25.f64[0] = vadd_f32(a7, vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)&v25.f64[0], v33), (float32x2_t)vzip2_s32(*(int32x2_t *)&v25.f64[0], v33)));
  int8x8_t v34 = (int8x8_t)vdup_lane_s32(vcge_f32(0, *(float32x2_t *)&v71.f64[0]), 0);
  int32x2_t v35 = (int32x2_t)vmul_f32(*(float32x2_t *)a8.i8, v18);
  int8x16_t v36 = vextq_s8(a8, a8, 8uLL);
  *(float32x2_t *)v36.i8 = vmul_f32(*(float32x2_t *)v36.i8, v18);
  *(int32x2_t *)v27.i8 = vzip1_s32(v35, *(int32x2_t *)v36.i8);
  int8x8_t v37 = (int8x8_t)vadd_f32(a9, vadd_f32(*(float32x2_t *)v27.i8, (float32x2_t)vzip2_s32(v35, *(int32x2_t *)v36.i8)));
  *(int8x8_t *)&v25.f64[0] = vbsl_s8(v34, v37, *(int8x8_t *)&v25.f64[0]);
  int8x16_t v66 = (int8x16_t)v25;
  *(int8x8_t *)&v25.f64[0] = vbsl_s8(v34, (int8x8_t)v18, v32);
  v37.i32[0] = *(_DWORD *)(a1 + 28);
  *(float *)v32.i32 = *(float *)(a1 + 24)
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v25.f64[0], 1), *(float *)(a1 + 16), *(float *)v25.f64);
  v36.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v34.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v25.f64[0], 1), *(float *)v37.i32, *(float *)v25.f64);
  *(float *)v25.f64 = *(float *)v36.i32 + *(float *)v34.i32;
  *(float *)&v32.i32[1] = *(float *)v36.i32 + *(float *)v34.i32;
  *(double *)v38.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v32, v25, *(double *)&v34, *(double *)&v37, v36, v27, v31);
  float32x4_t v69 = v38;
  HIDWORD(v39) = v66.i32[1];
  LODWORD(v39) = *(_DWORD *)(a2 + 28);
  v40.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)&double v41 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *(float32x2_t *)v66.i8, 1), *(float *)&v39, *(float *)v66.i32);
  v38.f32[0] = *(float *)(a2 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *(float32x2_t *)v66.i8, 1), *(float *)(a2 + 16), *(float *)v66.i32);
  *(float *)v42.f64 = *(float *)v40.i32 + *(float *)&v41;
  v38.f32[1] = *(float *)v40.i32 + *(float *)&v41;
  *(double *)v44.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v38.i64, v42, v39, v41, v40, v66, v43);
  float32x4_t v67 = v44;
  __asm { FMOV            V1.2S, #-1.0 }
  *(float32x2_t *)v44.f32 = vmaxnm_f32(vmul_n_f32(*(float32x2_t *)a4.i8, a10 * *(float *)v71.f64), _D1);
  __asm { FMOV            V1.2S, #1.0 }
  *(int8x8_t *)v44.f32 = vbsl_s8((int8x8_t)vdup_lane_s32(vcgt_f32(0, *(float32x2_t *)&v71.f64[0]), 0), (int8x8_t)0x3F0000003F000000, (int8x8_t)vadd_f32(vmul_f32(vminnm_f32(*(float32x2_t *)v44.f32, _D1), (float32x2_t)0x3F0000003F000000), (float32x2_t)0x3F0000003F000000));
  int8x16_t v51 = a11;
  float64x2_t v52 = (float64x2_t)vextq_s8(v51, v51, 8uLL);
  *(float32x2_t *)v44.f32 = vadd_f32(*(float32x2_t *)a11.i8, vmul_f32(*(float32x2_t *)&v52.f64[0], *(float32x2_t *)v44.f32));
  *(float *)v51.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a3 + 20), *(float32x2_t *)v44.f32, 1), *(float *)(a3 + 16), v44.f32[0]);
  LODWORD(v53) = *(_DWORD *)(a3 + 28);
  v54.i32[0] = *(_DWORD *)(a3 + 36);
  *(float *)v55.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a3 + 32), *(float32x2_t *)v44.f32, 1), *(float *)&v53, v44.f32[0]);
  v44.f32[0] = *(float *)(a3 + 24) + *(float *)v51.i32;
  *(float *)v52.f64 = *(float *)v54.i32 + *(float *)v55.i32;
  v44.f32[1] = *(float *)v54.i32 + *(float *)v55.i32;
  *(double *)v57.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a3 + 8), *(double *)v44.i64, v52, *(double *)v51.i64, v53, v55, v54, v56);
  float32x4_t v58 = vmulq_laneq_f32(v57, v67, 3);
  float v59 = 1.0;
  float32x4_t v60 = vaddq_f32(v58, vmulq_n_f32(v67, 1.0 - v58.f32[3]));
  float32x4_t v61 = vaddq_f32(v60, vmulq_n_f32(v69, 1.0 - v60.f32[3]));
  float v62 = (1.0 - v22) * a10;
  if (v62 <= 1.0) {
    float v59 = (1.0 - v22) * a10;
  }
  if (v62 >= 0.0) {
    float v63 = v59;
  }
  else {
    float v63 = 0.0;
  }
  *(void *)&double result = vmulq_n_f32(v61, v63).u64[0];
  return result;
}

void CI::f4_sr_sr_sr_f4_f2_f4_f2_f4_f2_f_f4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  uint64_t v10 = *(double (**)(uint64_t, uint64_t, uint64_t, __n128, double, __n128, double, __n128, double, float, __n128))(a1 + 24);
  uint64_t v11 = *(void *)(v9 + 8);
  uint64_t v12 = *(void *)(v9 + 32);
  double v13 = *(const vec2 **)(v9 + 56);
  int v14 = *(_DWORD *)(v9 + 88);
  uint64_t v15 = *(void *)(v9 + 80);
  int v16 = *(_DWORD *)(v9 + 112);
  uint64_t v17 = *(void *)(v9 + 104);
  int v18 = *(_DWORD *)(v9 + 136);
  uint64_t v19 = *(void *)(v9 + 128);
  int v20 = *(_DWORD *)(v9 + 160);
  uint64_t v21 = *(void *)(v9 + 152);
  int v22 = *(_DWORD *)(v9 + 184);
  uint64_t v23 = *(void *)(v9 + 176);
  int v24 = *(_DWORD *)(v9 + 208);
  uint64_t v25 = *(void *)(v9 + 200);
  uint64_t v26 = *(void *)(v9 + 224);
  int v27 = *(_DWORD *)(v9 + 256);
  uint64_t v28 = *(void *)(v9 + 248);
  if (*(unsigned char *)(a1 + 64))
  {
    double v48 = *(double (**)(uint64_t, uint64_t, uint64_t, __n128, double, __n128, double, __n128, double, float, __n128))(a1 + 24);
    uint64_t v52 = a4;
    int v42 = *(_DWORD *)(v9 + 208);
    int v43 = *(_DWORD *)(v9 + 184);
    uint64_t v29 = *(void *)(v9 + 32);
    double v50 = *(const vec2 **)(v9 + 56);
    int v51 = *(_DWORD *)(v9 + 88);
    int v49 = *(_DWORD *)(v9 + 112);
    uint64_t v30 = *(void *)(v9 + 104);
    int v47 = *(_DWORD *)(v9 + 136);
    uint64_t v46 = *(void *)(v9 + 128);
    int v45 = *(_DWORD *)(v9 + 160);
    uint64_t v44 = *(void *)(v9 + 152);
    int v41 = *(_DWORD *)(v9 + 256);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 272)), v13);
    int v27 = v41;
    int v24 = v42;
    uint64_t v21 = v44;
    int v20 = v45;
    uint64_t v19 = v46;
    int v18 = v47;
    uint64_t v17 = v30;
    int v16 = v49;
    int v14 = v51;
    double v13 = v50;
    uint64_t v12 = v29;
    int v22 = v43;
    a4 = v52;
    uint64_t v10 = v48;
  }
  int8x16_t v31 = (__n128 *)(a3 + 16 * v28);
  if (v27 != 5) {
    int8x16_t v31 = (__n128 *)(a2 + (v28 << 6));
  }
  int8x8_t v32 = (double *)(a3 + 16 * v25);
  if (v24 != 5) {
    int8x8_t v32 = (double *)(a2 + (v25 << 6));
  }
  int32x2_t v33 = (__n128 *)(a3 + 16 * v23);
  if (v22 != 5) {
    int32x2_t v33 = (__n128 *)(a2 + (v23 << 6));
  }
  int8x8_t v34 = (double *)(a3 + 16 * v21);
  int32x2_t v35 = (double *)(a2 + (v21 << 6));
  if (v20 != 5) {
    int8x8_t v34 = v35;
  }
  int8x16_t v36 = (__n128 *)(a3 + 16 * v19);
  int8x8_t v37 = (__n128 *)(a2 + (v19 << 6));
  if (v18 != 5) {
    int8x16_t v36 = v37;
  }
  float32x4_t v38 = (double *)(a3 + 16 * v17);
  if (v16 != 5) {
    float32x4_t v38 = (double *)(a2 + (v17 << 6));
  }
  double v39 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5) {
    double v39 = (__n128 *)(a2 + (v15 << 6));
  }
  *(double *)&long long v40 = v10(a4 + 80 * v11, a4 + 80 * v12, a4 + 80 * (void)v13, *v39, *v38, *v36, *v34, *v33, *v32, *(float *)(a2 + (v26 << 6)), *v31);
  *(_OWORD *)(a3 + 16 * a7) = v40;
}

double cikernel::_pageCurlTransNoEmap(uint64_t a1, uint64_t a2, int8x16_t a3, float32x2_t a4, int8x16_t a5, float32x2_t a6, int8x16_t a7, float32x2_t a8, float a9)
{
  float32x2_t v15 = *(float32x2_t *)CI::getDC((CI *)a1);
  int32x2_t v16 = (int32x2_t)vmul_f32(*(float32x2_t *)a3.i8, v15);
  int32x2_t v17 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v15);
  *(float32x2_t *)v18.i8 = vadd_f32(a4, vadd_f32((float32x2_t)vzip1_s32(v16, v17), (float32x2_t)vzip2_s32(v16, v17)));
  int8x16_t v47 = v18;
  double v19 = *(float *)v18.i32;
  float v20 = sqrt(1.0 - pow(*(float *)v18.i32, 1.5)) + -1.0;
  float v21 = v19 + (float)(v20 * v20) * 0.5625;
  float64x2_t v22 = (float64x2_t)v47;
  *(float *)v22.f64 = v21;
  *(float *)&unsigned int v23 = 3.14159265 - v21;
  float32x2_t v24 = (float32x2_t)__PAIR64__(v47.u32[1], v23);
  int32x2_t v25 = (int32x2_t)vmul_f32(*(float32x2_t *)a5.i8, *(float32x2_t *)&v22.f64[0]);
  float32x2_t v26 = (float32x2_t)vextq_s8(a5, a5, 8uLL).u64[0];
  v27.i64[1] = a5.i64[1];
  *(float32x2_t *)&v22.f64[0] = vmul_f32(v26, *(float32x2_t *)&v22.f64[0]);
  int8x8_t v28 = (int8x8_t)vadd_f32(a6, vadd_f32((float32x2_t)vzip1_s32(v25, *(int32x2_t *)&v22.f64[0]), (float32x2_t)vzip2_s32(v25, *(int32x2_t *)&v22.f64[0])));
  *(float32x2_t *)&v22.f64[0] = vmul_f32(*(float32x2_t *)a5.i8, v24);
  int32x2_t v29 = (int32x2_t)vmul_f32(v26, v24);
  *(float32x2_t *)&v22.f64[0] = vadd_f32(a6, vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)&v22.f64[0], v29), (float32x2_t)vzip2_s32(*(int32x2_t *)&v22.f64[0], v29)));
  int8x8_t v30 = (int8x8_t)vdup_lane_s32(vcge_f32(0, *(float32x2_t *)v47.i8), 0);
  int32x2_t v31 = (int32x2_t)vmul_f32(*(float32x2_t *)a7.i8, v15);
  int8x16_t v32 = vextq_s8(a7, a7, 8uLL);
  *(float32x2_t *)v32.i8 = vmul_f32(*(float32x2_t *)v32.i8, v15);
  *(int32x2_t *)v27.i8 = vzip1_s32(v31, *(int32x2_t *)v32.i8);
  int8x8_t v33 = (int8x8_t)vadd_f32(a8, vadd_f32(*(float32x2_t *)v27.i8, (float32x2_t)vzip2_s32(v31, *(int32x2_t *)v32.i8)));
  *(int8x8_t *)&v22.f64[0] = vbsl_s8(v30, v33, *(int8x8_t *)&v22.f64[0]);
  int8x16_t v51 = (int8x16_t)v22;
  *(int8x8_t *)&v22.f64[0] = vbsl_s8(v30, (int8x8_t)v15, v28);
  v33.i32[0] = *(_DWORD *)(a1 + 28);
  *(float *)v28.i32 = *(float *)(a1 + 24)
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v22.f64[0], 1), *(float *)(a1 + 16), *(float *)v22.f64);
  v32.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v30.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v22.f64[0], 1), *(float *)v33.i32, *(float *)v22.f64);
  *(float *)v22.f64 = *(float *)v32.i32 + *(float *)v30.i32;
  *(float *)&v28.i32[1] = *(float *)v32.i32 + *(float *)v30.i32;
  *(double *)v34.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v28, v22, *(double *)&v30, *(double *)&v33, v32, v27, v47);
  float32x4_t v49 = v34;
  HIDWORD(v35) = v51.i32[1];
  LODWORD(v35) = *(_DWORD *)(a2 + 28);
  v36.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)&double v37 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *(float32x2_t *)v51.i8, 1), *(float *)&v35, *(float *)v51.i32);
  v34.f32[0] = *(float *)(a2 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *(float32x2_t *)v51.i8, 1), *(float *)(a2 + 16), *(float *)v51.i32);
  *(float *)v38.f64 = *(float *)v36.i32 + *(float *)&v37;
  v34.f32[1] = *(float *)v36.i32 + *(float *)&v37;
  *(double *)v40.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v34.i64, v38, v35, v37, v36, v51, v39);
  float v41 = 1.0;
  float32x4_t v42 = vaddq_f32(v40, vmulq_n_f32(v49, 1.0 - v40.f32[3]));
  float v43 = (1.0 - v19) * a9;
  if (v43 <= 1.0) {
    float v41 = (1.0 - v19) * a9;
  }
  if (v43 >= 0.0) {
    float v44 = v41;
  }
  else {
    float v44 = 0.0;
  }
  *(void *)&double result = vmulq_n_f32(v42, v44).u64[0];
  return result;
}

void CI::f4_sr_sr_f4_f2_f4_f2_f4_f2_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = *(void *)(a1 + 48);
  uint64_t v11 = *(double (**)(uint64_t, uint64_t, __n128, double, __n128, double, __n128, double, float))(a1 + 24);
  uint64_t v12 = *(void *)(v10 + 8);
  uint64_t v13 = *(void *)(v10 + 32);
  int v14 = *(_DWORD *)(v10 + 64);
  uint64_t v15 = *(void *)(v10 + 56);
  int v16 = *(_DWORD *)(v10 + 88);
  uint64_t v17 = *(void *)(v10 + 80);
  int v18 = *(_DWORD *)(v10 + 112);
  uint64_t v19 = *(void *)(v10 + 104);
  int v20 = *(_DWORD *)(v10 + 136);
  uint64_t v21 = *(void *)(v10 + 128);
  int v22 = *(_DWORD *)(v10 + 160);
  uint64_t v23 = *(void *)(v10 + 152);
  int v24 = *(_DWORD *)(v10 + 184);
  uint64_t v25 = *(void *)(v10 + 176);
  uint64_t v26 = *(void *)(v10 + 200);
  if (*(unsigned char *)(a1 + 64))
  {
    uint64_t v42 = *(void *)(v10 + 200);
    float v43 = *(double (**)(uint64_t, uint64_t, __n128, double, __n128, double, __n128, double, float))(a1 + 24);
    uint64_t v40 = *(void *)(v10 + 80);
    uint64_t v41 = *(void *)(v10 + 8);
    int v39 = *(_DWORD *)(v10 + 64);
    uint64_t v38 = *(void *)(v10 + 104);
    int v36 = *(_DWORD *)(v10 + 160);
    int v37 = *(_DWORD *)(v10 + 136);
    int v35 = *(_DWORD *)(v10 + 184);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 224)), a2);
    int v24 = v35;
    int v22 = v36;
    int v20 = v37;
    uint64_t v19 = v38;
    uint64_t v17 = v40;
    uint64_t v12 = v41;
    uint64_t v26 = v42;
    uint64_t v11 = v43;
    int v14 = v39;
  }
  int8x16_t v27 = (double *)(a3 + 16 * v25);
  if (v24 != 5) {
    int8x16_t v27 = (double *)((char *)a2 + 64 * v25);
  }
  int8x8_t v28 = (__n128 *)(a3 + 16 * v23);
  if (v22 != 5) {
    int8x8_t v28 = (__n128 *)((char *)a2 + 64 * v23);
  }
  int32x2_t v29 = (double *)(a3 + 16 * v21);
  if (v20 != 5) {
    int32x2_t v29 = (double *)((char *)a2 + 64 * v21);
  }
  int8x8_t v30 = (__n128 *)(a3 + 16 * v19);
  int32x2_t v31 = (__n128 *)((char *)a2 + 64 * v19);
  if (v18 != 5) {
    int8x8_t v30 = v31;
  }
  int8x16_t v32 = (double *)(a3 + 16 * v17);
  if (v16 != 5) {
    int8x16_t v32 = (double *)((char *)a2 + 64 * v17);
  }
  int8x8_t v33 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5) {
    int8x8_t v33 = (__n128 *)((char *)a2 + 64 * v15);
  }
  *(double *)&long long v34 = v11(a4 + 80 * v12, a4 + 80 * v13, *v33, *v32, *v30, *v29, *v28, *v27, *((float *)a2 + 16 * v26));
  *(_OWORD *)(a3 + 16 * a7) = v34;
}

double cikernel::_pageCurlWithShadowTransition(uint64_t a1, uint64_t a2, int8x16_t a3, float32x2_t a4, int8x16_t a5, float32x2_t a6, int8x16_t a7, float32x2_t a8, float a9, int8x16_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, float a17, float a18, uint64_t a19, float32x4_t a20,float32x4_t a21)
{
  float32x2_t v26 = *(float32x2_t *)CI::getDC((CI *)a1);
  int32x2_t v27 = (int32x2_t)vmul_f32(*(float32x2_t *)a3.i8, v26);
  float64x2_t v31 = (float64x2_t)vextq_s8(a3, a3, 8uLL);
  *(float32x2_t *)&v31.f64[0] = vmul_f32(*(float32x2_t *)&v31.f64[0], v26);
  *(float32x2_t *)v28.i8 = vadd_f32(a4, vadd_f32((float32x2_t)vzip1_s32(v27, *(int32x2_t *)&v31.f64[0]), (float32x2_t)vzip2_s32(v27, *(int32x2_t *)&v31.f64[0])));
  double v29 = *(float *)v28.i32;
  float32x2_t v30 = *(float32x2_t *)v28.i8;
  LODWORD(v31.f64[0]) = v28.i32[0];
  float v32 = 0.0;
  float v33 = *(float *)v28.i32;
  int8x16_t v123 = v28;
  if (*(float *)v28.i32 > 0.0)
  {
    long double v34 = pow(*(float *)v28.i32, 1.5);
    int8x16_t v28 = v123;
    *(float *)&long double v34 = sqrt(1.0 - v34) + -1.0;
    double v35 = v29 + (float)(*(float *)&v34 * *(float *)&v34) * 0.5625;
    double v36 = v29 * 9999.0;
    float v37 = 1.0;
    if (*(float *)v123.i32 < 1.0) {
      double v36 = v35;
    }
    *(float *)v31.f64 = v36;
    float32x2_t v30 = (float32x2_t)__PAIR64__(v123.u32[1], LODWORD(v31.f64[0]));
    float v38 = (float)(*(float *)v123.i32 + -0.607) / 0.693;
    if (v38 <= 1.0) {
      float v37 = (float)(*(float *)v123.i32 + -0.607) / 0.693;
    }
    if (v38 < 0.0) {
      float v37 = 0.0;
    }
    if (v29 >= 0.9) {
      double v35 = v29 + (float)((float)(v37 * v37) * (float)((float)(v37 * -2.0) + 3.0)) * 0.570796327;
    }
    float v33 = v35;
    float v32 = *(float *)v123.i32;
  }
  float v119 = v33;
  v39.i32[1] = v28.i32[1];
  v39.f32[0] = 3.1416 - *(float *)v31.f64;
  *(float32x2_t *)&v31.f64[0] = vmul_f32(*(float32x2_t *)a5.i8, v30);
  int8x16_t v40 = vextq_s8(a5, a5, 8uLL);
  int32x2_t v41 = (int32x2_t)vmul_f32(*(float32x2_t *)v40.i8, v30);
  int8x8_t v42 = (int8x8_t)vadd_f32(a6, vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)&v31.f64[0], v41), (float32x2_t)vzip2_s32(*(int32x2_t *)&v31.f64[0], v41)));
  *(float32x2_t *)&v31.f64[0] = vmul_f32(*(float32x2_t *)a5.i8, v39);
  float32x2_t v118 = *(float32x2_t *)v40.i8;
  int32x2_t v43 = (int32x2_t)vmul_f32(*(float32x2_t *)v40.i8, v39);
  *(float32x2_t *)&v31.f64[0] = vadd_f32(a6, vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)&v31.f64[0], v43), (float32x2_t)vzip2_s32(*(int32x2_t *)&v31.f64[0], v43)));
  int8x8_t v44 = (int8x8_t)vdup_lane_s32(vcgt_f32(0, *(float32x2_t *)v28.i8), 0);
  int32x2_t v45 = (int32x2_t)vmul_f32(*(float32x2_t *)a7.i8, v26);
  int8x16_t v46 = vextq_s8(a7, a7, 8uLL);
  *(float32x2_t *)v46.i8 = vmul_f32(*(float32x2_t *)v46.i8, v26);
  *(int32x2_t *)v40.i8 = vzip1_s32(v45, *(int32x2_t *)v46.i8);
  float32x2_t v47 = vadd_f32(*(float32x2_t *)v40.i8, (float32x2_t)vzip2_s32(v45, *(int32x2_t *)v46.i8));
  float32x2_t v48 = vadd_f32(a8, v47);
  *(int8x8_t *)&v31.f64[0] = vbsl_s8(v44, (int8x8_t)v48, *(int8x8_t *)&v31.f64[0]);
  int8x16_t v115 = (int8x16_t)v31;
  *(int8x8_t *)&v31.f64[0] = vbsl_s8(v44, (int8x8_t)v26, v42);
  v47.i32[0] = *(_DWORD *)(a1 + 28);
  *(float *)v42.i32 = *(float *)(a1 + 24)
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v31.f64[0], 1), *(float *)(a1 + 16), *(float *)v31.f64);
  v46.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v44.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v31.f64[0], 1), v47.f32[0], *(float *)v31.f64);
  *(float *)v31.f64 = *(float *)v46.i32 + *(float *)v44.i32;
  *(float *)&v42.i32[1] = *(float *)v46.i32 + *(float *)v44.i32;
  *(double *)v49.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v42, v31, *(double *)&v44, *(double *)&v47, v46, v40, v28);
  float32x4_t v117 = v49;
  HIDWORD(v50) = v115.i32[1];
  LODWORD(v50) = *(_DWORD *)(a2 + 28);
  v51.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)&double v52 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *(float32x2_t *)v115.i8, 1), *(float *)&v50, *(float *)v115.i32);
  v49.f32[0] = *(float *)(a2 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *(float32x2_t *)v115.i8, 1), *(float *)(a2 + 16), *(float *)v115.i32);
  *(float *)v53.f64 = *(float *)v51.i32 + *(float *)&v52;
  v49.f32[1] = *(float *)v51.i32 + *(float *)&v52;
  *(double *)v55.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v49.i64, v53, v50, v52, v51, v115, v54);
  float v56 = (v32 + -0.6) * 2.5;
  float v57 = 1.0;
  if (v56 <= 1.0) {
    float v57 = (v32 + -0.6) * 2.5;
  }
  if (v56 < 0.0) {
    float v57 = 0.0;
  }
  double v58 = v57;
  if (v57 <= 0.75) {
    double v59 = v58 * 0.375 * v58 + v58 * 0.35;
  }
  else {
    double v59 = (v58 + -0.82) * 15.0 * (v58 + -0.82) + 0.4;
  }
  double v60 = 1.0 - v29;
  float v61 = (1.0 - v29) * a9;
  if (v61 <= 1.0) {
    float v62 = (1.0 - v29) * a9;
  }
  else {
    float v62 = 1.0;
  }
  if (v61 < 0.0) {
    float v62 = 0.0;
  }
  float32x4_t v63 = vmulq_n_f32(v117, v62);
  v64.i32[1] = v123.i32[1];
  v64.f32[0] = 3.1416 - v119;
  int32x2_t v65 = (int32x2_t)vmul_f32(*(float32x2_t *)a5.i8, v64);
  int32x2_t v66 = (int32x2_t)vmul_f32(v118, v64);
  float32x2_t v67 = vadd_f32(a6, vadd_f32((float32x2_t)vzip1_s32(v65, v66), (float32x2_t)vzip2_s32(v65, v66)));
  *(float *)v66.i32 = 1.0 - (float)(a17 + a17);
  float32x2_t v68 = vmla_n_f32(vmul_n_f32(v67, *(float *)v66.i32), v48, a17 + a17);
  int32x2_t v69 = (int32x2_t)vmul_f32(*(float32x2_t *)a5.i8, (float32x2_t)__PAIR64__(v123.u32[1], LODWORD(v119)));
  int32x2_t v70 = (int32x2_t)vmul_f32(v118, (float32x2_t)__PAIR64__(v123.u32[1], LODWORD(v119)));
  float32x2_t v71 = vmla_n_f32(vmul_n_f32(vadd_f32(a6, vadd_f32((float32x2_t)vzip1_s32(v69, v70), (float32x2_t)vzip2_s32(v69, v70))), *(float *)v66.i32), v26, a17 + a17);
  float v72 = (float)(*(float *)v123.i32 + -0.5) + (float)(*(float *)v123.i32 + -0.5);
  if (v72 <= 1.0) {
    float v73 = (float)(*(float *)v123.i32 + -0.5) + (float)(*(float *)v123.i32 + -0.5);
  }
  else {
    float v73 = 1.0;
  }
  if (v72 >= 0.0) {
    float v74 = v73;
  }
  else {
    float v74 = 0.0;
  }
  float v75 = (float)(vmuls_lane_f32((float)((float)((float)(v74 * v74) * (float)((float)(v74 * -2.0) + 3.0)) * 1.25)+ (float)((float)(1.0 - (float)((float)(v74 * v74) * (float)((float)(v74 * -2.0) + 3.0))) * 2.0), v63, 3)+ (float)((float)(1.0 - v63.f32[3]) * 2.3))* a17;
  *(float *)v69.i32 = v75 * a9;
  *(float32x2_t *)v76.f32 = vsub_f32(v68, *(float32x2_t *)a10.i8);
  float32x2_t v77 = (float32x2_t)vextq_s8(a10, a10, 8uLL).u64[0];
  *(float32x2_t *)&v76.u32[2] = vsub_f32(v77, v68);
  float32x4_t v78 = vdivq_f32(v76, (float32x4_t)vdupq_lane_s32(v69, 0));
  float32x4_t v79 = (float32x4_t)vdupq_n_s32(0x3F23D70Au);
  v80.i64[0] = 0x3F0000003F000000;
  v80.i64[1] = 0x3F0000003F000000;
  float32x4_t v81 = (float32x4_t)vdupq_n_s32(0x3E0F5C29u);
  __asm
  {
    FMOV            V19.4S, #1.0
    FMOV            V24.4S, #-1.0
  }
  float32x4_t v87 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_f32(vaddq_f32(v78, _Q24)), vbicq_s8((int8x16_t)vsubq_f32(vaddq_f32(vmulq_f32(v78, v79), v80), vmulq_f32(v78, vmulq_f32(v78, vmulq_f32(v78, v81)))), (int8x16_t)vcltzq_f32(vaddq_f32(v78, _Q19))), (int8x16_t)_Q19);
  float v88 = v60 / v75;
  float v89 = v88 * 0.64 + 0.5 + v88 * -0.14 * v88 * v88;
  if (v88 <= -1.0) {
    float v89 = 0.0;
  }
  if (v88 < 1.0) {
    float v90 = v89;
  }
  else {
    float v90 = 1.0;
  }
  float v91 = v90 * vmulq_laneq_f32(vmulq_laneq_f32(vmulq_lane_f32(v87, *(float32x2_t *)v87.f32, 1), v87, 2), v87, 3).f32[0];
  if (v91 <= 1.0) {
    float v92 = v91;
  }
  else {
    float v92 = 1.0;
  }
  if (v91 >= 0.0) {
    float v93 = v92;
  }
  else {
    float v93 = 0.0;
  }
  float v94 = vmul_f32(*(float32x2_t *)v123.i8, *(float32x2_t *)v123.i8).f32[0];
  if (v94 > 1.5) {
    float v94 = 1.5;
  }
  double v95 = v94 * 0.65;
  *(float *)&double v95 = v95;
  float v96 = v60 / (float)(a17 * 2.5);
  float v97 = v96 * 0.64 + 0.5 + v96 * -0.14 * v96 * v96;
  if (v96 <= -1.0) {
    float v97 = 0.0;
  }
  if (v96 < 1.0) {
    float v98 = v97;
  }
  else {
    float v98 = 1.0;
  }
  if (*(float *)v123.i32 <= 1.0) {
    float v99 = *(float *)v123.i32;
  }
  else {
    float v99 = 1.0;
  }
  if (*(float *)v123.i32 < 0.0) {
    *(float *)&double v95 = 0.0;
  }
  *(float *)&double v95 = (float)((float)(*(float *)&v95 * a17) * 2.5) * a9;
  *(float32x2_t *)v100.f32 = vsub_f32(v71, *(float32x2_t *)a10.i8);
  *(float32x2_t *)&v100.u32[2] = vsub_f32(v77, v71);
  float32x4_t v101 = vdivq_f32(v100, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v95, 0));
  float32x4_t v102 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_f32(vaddq_f32(v101, _Q24)), vbicq_s8((int8x16_t)vsubq_f32(vaddq_f32(vmulq_f32(v101, v79), v80), vmulq_f32(v101, vmulq_f32(v101, vmulq_f32(v101, v81)))), (int8x16_t)vcltzq_f32(vaddq_f32(v101, _Q19))), (int8x16_t)_Q19);
  float v103 = (1.0 - v63.f32[3])
       * (float)(v98
               * vmulq_laneq_f32(vmulq_laneq_f32(vmulq_lane_f32(v102, *(float32x2_t *)v102.f32, 1), v102, 2), v102, 3).f32[0]);
  if (*(float *)v123.i32 >= 0.0) {
    float v104 = v99;
  }
  else {
    float v104 = 0.0;
  }
  float v105 = v104 * v103;
  if (v105 <= 1.0) {
    float v106 = v105;
  }
  else {
    float v106 = 1.0;
  }
  _NF = v105 < 0.0 || *(float *)v123.i32 < 0.0;
  float32x4_t v108 = vmulq_n_f32(v55, v62);
  float v109 = v59;
  float32x4_t v110 = vmulq_laneq_f32(vmlaq_n_f32(vmulq_n_f32(a20, 1.0 - v109), a21, v109), v108, 3);
  float32x4_t v111 = vaddq_f32(v110, vmulq_n_f32(v108, 1.0 - v110.f32[3]));
  if (_NF) {
    float v112 = 0.0;
  }
  else {
    float v112 = v106;
  }
  v113.i64[0] = 0;
  v113.i32[2] = 0;
  v113.f32[3] = fminf(fmaxf(v93, v112), 0.5) * a18;
  *(void *)&double result = vaddq_f32(v111, vmulq_n_f32(vaddq_f32(v113, vmulq_n_f32(v63, 1.0 - v113.f32[3])), 1.0 - v111.f32[3])).u64[0];
  return result;
}

void CI::f4_sr_sr_f4_f2_f4_f2_f4_f2_f_f4_f_f_f4_f4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  uint64_t v10 = *(double (**)(uint64_t, uint64_t, __n128, double, __n128, double, __n128, double, float, __n128, double))(a1 + 24);
  uint64_t v11 = *(void *)(v9 + 8);
  uint64_t v12 = *(const vec2 **)(v9 + 32);
  int v13 = *(_DWORD *)(v9 + 64);
  uint64_t v14 = *(void *)(v9 + 56);
  int v15 = *(_DWORD *)(v9 + 88);
  uint64_t v16 = *(void *)(v9 + 80);
  int v17 = *(_DWORD *)(v9 + 112);
  uint64_t v18 = *(void *)(v9 + 104);
  int v19 = *(_DWORD *)(v9 + 136);
  uint64_t v20 = *(void *)(v9 + 128);
  int v21 = *(_DWORD *)(v9 + 160);
  uint64_t v22 = *(void *)(v9 + 152);
  int v23 = *(_DWORD *)(v9 + 184);
  uint64_t v24 = *(void *)(v9 + 176);
  uint64_t v25 = *(void *)(v9 + 200);
  int v60 = *(_DWORD *)(v9 + 232);
  uint64_t v26 = *(void *)(v9 + 224);
  uint64_t v27 = *(void *)(v9 + 248);
  uint64_t v28 = *(void *)(v9 + 272);
  if (*(unsigned char *)(a1 + 64))
  {
    double v59 = *(double (**)(uint64_t, uint64_t, __n128, double, __n128, double, __n128, double, float, __n128, double))(a1 + 24);
    int v53 = *(_DWORD *)(v9 + 112);
    uint64_t v29 = a4;
    uint64_t v55 = *(void *)(v9 + 8);
    int v51 = *(_DWORD *)(v9 + 136);
    float32x2_t v30 = *(const vec2 **)(v9 + 32);
    uint64_t v57 = *(void *)(v9 + 248);
    uint64_t v56 = *(void *)(v9 + 56);
    uint64_t v31 = *(void *)(v9 + 200);
    uint64_t v58 = *(void *)(v9 + 272);
    uint64_t v54 = *(void *)(v9 + 80);
    int v32 = *(_DWORD *)(v9 + 64);
    int v49 = *(_DWORD *)(v9 + 160);
    int v33 = *(_DWORD *)(v9 + 88);
    uint64_t v52 = *(void *)(v9 + 104);
    uint64_t v50 = *(void *)(v9 + 128);
    uint64_t v48 = *(void *)(v9 + 152);
    uint64_t v47 = *(void *)(v9 + 176);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 344)), v12);
    uint64_t v24 = v47;
    uint64_t v22 = v48;
    uint64_t v20 = v50;
    uint64_t v18 = v52;
    int v15 = v33;
    int v21 = v49;
    int v13 = v32;
    uint64_t v16 = v54;
    uint64_t v11 = v55;
    uint64_t v27 = v57;
    uint64_t v28 = v58;
    uint64_t v25 = v31;
    uint64_t v14 = v56;
    uint64_t v12 = v30;
    int v19 = v51;
    a4 = v29;
    int v17 = v53;
    uint64_t v10 = v59;
  }
  long double v34 = (__n128 *)(a3 + 16 * v26);
  if (v60 != 5) {
    long double v34 = (__n128 *)(a2 + (v26 << 6));
  }
  double v35 = (double *)(a3 + 16 * v24);
  double v36 = (double *)(a2 + (v24 << 6));
  if (v23 != 5) {
    double v35 = v36;
  }
  float v37 = (__n128 *)(a3 + 16 * v22);
  float v38 = (__n128 *)(a2 + (v22 << 6));
  if (v21 != 5) {
    float v37 = v38;
  }
  float32x2_t v39 = (double *)(a3 + 16 * v20);
  int8x16_t v40 = (double *)(a2 + (v20 << 6));
  if (v19 != 5) {
    float32x2_t v39 = v40;
  }
  int32x2_t v41 = (__n128 *)(a3 + 16 * v18);
  int8x8_t v42 = (__n128 *)(a2 + (v18 << 6));
  if (v17 != 5) {
    int32x2_t v41 = v42;
  }
  int32x2_t v43 = (double *)(a3 + 16 * v16);
  if (v15 != 5) {
    int32x2_t v43 = (double *)(a2 + (v16 << 6));
  }
  int8x8_t v44 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    int8x8_t v44 = (__n128 *)(a2 + (v14 << 6));
  }
  LODWORD(v46) = *(_DWORD *)(a2 + (v27 << 6));
  HIDWORD(v46) = *(_DWORD *)(a2 + (v28 << 6));
  *(double *)&long long v45 = v10(a4 + 80 * v11, a4 + 80 * (void)v12, *v44, *v43, *v41, *v39, *v37, *v35, *(float *)(a2 + (v25 << 6)), *v34, v46);
  *(_OWORD *)(a3 + 16 * a7) = v45;
}

double cikernel::_pageCurlNoShadowTransition(uint64_t a1, uint64_t a2, int8x16_t a3, float32x2_t a4, int8x16_t a5, float32x2_t a6, int8x16_t a7, float32x2_t a8, float a9, float32x4_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, float32x4_t a17)
{
  float32x2_t v24 = *(float32x2_t *)CI::getDC((CI *)a1);
  int32x2_t v25 = (int32x2_t)vmul_f32(*(float32x2_t *)a3.i8, v24);
  int32x2_t v26 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v24);
  *(float32x2_t *)v27.i8 = vadd_f32(a4, vadd_f32((float32x2_t)vzip1_s32(v25, v26), (float32x2_t)vzip2_s32(v25, v26)));
  int8x16_t v70 = v27;
  v17.i32[0] = v27.i32[0];
  double v28 = *(float *)v27.i32;
  double v29 = pow(*(float *)v27.i32, 1.5);
  double v31 = v28;
  if (v17.f32[0] > 0.0)
  {
    if (v17.f32[0] >= 1.0)
    {
      double v31 = v28 * 9999.0;
    }
    else
    {
      float v32 = sqrt(1.0 - v29) + -1.0;
      double v31 = v28 + (float)(v32 * v32) * 0.5625;
    }
  }
  float v33 = v31;
  int8x16_t v34 = v70;
  float64x2_t v35 = (float64x2_t)v70;
  *(float *)v35.f64 = v33;
  *(float *)v34.i32 = 3.1416 - v33;
  int32x2_t v36 = (int32x2_t)vmul_f32(*(float32x2_t *)a5.i8, *(float32x2_t *)&v35.f64[0]);
  float32x2_t v37 = (float32x2_t)vextq_s8(a5, a5, 8uLL).u64[0];
  *(float32x2_t *)&v35.f64[0] = vmul_f32(v37, *(float32x2_t *)&v35.f64[0]);
  int8x8_t v38 = (int8x8_t)vadd_f32(a6, vadd_f32((float32x2_t)vzip1_s32(v36, *(int32x2_t *)&v35.f64[0]), (float32x2_t)vzip2_s32(v36, *(int32x2_t *)&v35.f64[0])));
  *(float32x2_t *)&v35.f64[0] = vmul_f32(*(float32x2_t *)a5.i8, *(float32x2_t *)v34.i8);
  int32x2_t v39 = (int32x2_t)vmul_f32(v37, *(float32x2_t *)v34.i8);
  *(float32x2_t *)&v35.f64[0] = vadd_f32(a6, vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)&v35.f64[0], v39), (float32x2_t)vzip2_s32(*(int32x2_t *)&v35.f64[0], v39)));
  int8x8_t v40 = (int8x8_t)vdup_lane_s32(vcgt_f32(0, v17), 0);
  int32x2_t v41 = (int32x2_t)vmul_f32(*(float32x2_t *)a7.i8, v24);
  int8x16_t v42 = vextq_s8(a7, a7, 8uLL);
  *(float32x2_t *)v42.i8 = vmul_f32(*(float32x2_t *)v42.i8, v24);
  *(int32x2_t *)v34.i8 = vzip1_s32(v41, *(int32x2_t *)v42.i8);
  int8x8_t v43 = (int8x8_t)vadd_f32(a8, vadd_f32(*(float32x2_t *)v34.i8, (float32x2_t)vzip2_s32(v41, *(int32x2_t *)v42.i8)));
  *(int8x8_t *)&v35.f64[0] = vbsl_s8(v40, v43, *(int8x8_t *)&v35.f64[0]);
  int8x16_t v66 = (int8x16_t)v35;
  *(int8x8_t *)&v35.f64[0] = vbsl_s8(v40, (int8x8_t)v24, v38);
  v43.i32[0] = *(_DWORD *)(a1 + 28);
  *(float *)v38.i32 = *(float *)(a1 + 24)
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v35.f64[0], 1), *(float *)(a1 + 16), *(float *)v35.f64);
  v42.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v40.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v35.f64[0], 1), *(float *)v43.i32, *(float *)v35.f64);
  *(float *)v35.f64 = *(float *)v42.i32 + *(float *)v40.i32;
  *(float *)&v38.i32[1] = *(float *)v42.i32 + *(float *)v40.i32;
  *(double *)v44.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v38, v35, *(double *)&v40, *(double *)&v43, v42, v34, v30);
  float32x4_t v68 = v44;
  HIDWORD(v45) = v66.i32[1];
  LODWORD(v45) = *(_DWORD *)(a2 + 28);
  v46.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)&double v47 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *(float32x2_t *)v66.i8, 1), *(float *)&v45, *(float *)v66.i32);
  v44.f32[0] = *(float *)(a2 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *(float32x2_t *)v66.i8, 1), *(float *)(a2 + 16), *(float *)v66.i32);
  *(float *)v48.f64 = *(float *)v46.i32 + *(float *)&v47;
  v44.f32[1] = *(float *)v46.i32 + *(float *)&v47;
  *(double *)v50.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v44.i64, v48, v45, v47, v46, v66, v49);
  if (v17.f32[0] > 0.0) {
    float v51 = v17.f32[0];
  }
  else {
    float v51 = 0.0;
  }
  float v52 = (v51 + -0.6) * 2.5;
  float v53 = 1.0;
  if (v52 <= 1.0) {
    float v53 = v52;
  }
  if (v52 < 0.0) {
    float v53 = 0.0;
  }
  double v54 = v53;
  if (v53 <= 0.75) {
    double v55 = v54 * 0.375 * v54 + v54 * 0.35;
  }
  else {
    double v55 = (v54 + -0.82) * 15.0 * (v54 + -0.82) + 0.4;
  }
  float v56 = (1.0 - v28) * a9;
  if (v56 <= 1.0) {
    float v57 = (1.0 - v28) * a9;
  }
  else {
    float v57 = 1.0;
  }
  BOOL v58 = v56 < 0.0;
  float v59 = 0.0;
  if (!v58) {
    float v59 = v57;
  }
  float32x4_t v60 = vmulq_n_f32(v50, v59);
  float v61 = v55;
  float32x4_t v62 = vmulq_laneq_f32(vmlaq_n_f32(vmulq_n_f32(a10, 1.0 - v61), a17, v61), v60, 3);
  float32x4_t v63 = vaddq_f32(v62, vmulq_n_f32(v60, 1.0 - v62.f32[3]));
  *(void *)&double result = vaddq_f32(v63, vmulq_n_f32(vmulq_n_f32(v68, v59), 1.0 - v63.f32[3])).u64[0];
  return result;
}

void CI::f4_sr_sr_f4_f2_f4_f2_f4_f2_f_f4_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  uint64_t v10 = *(double (**)(uint64_t, uint64_t, __n128, double, __n128, double, __n128, double, float, __n128, double, double))(a1 + 24);
  uint64_t v11 = *(void *)(v9 + 8);
  uint64_t v12 = *(void *)(v9 + 32);
  int v13 = *(_DWORD *)(v9 + 64);
  uint64_t v14 = *(void *)(v9 + 56);
  int v15 = *(_DWORD *)(v9 + 88);
  uint64_t v16 = *(void *)(v9 + 80);
  int v17 = *(_DWORD *)(v9 + 112);
  uint64_t v18 = *(void *)(v9 + 104);
  int v19 = *(_DWORD *)(v9 + 136);
  uint64_t v20 = *(void *)(v9 + 128);
  int v21 = *(_DWORD *)(v9 + 160);
  uint64_t v22 = *(void *)(v9 + 152);
  int v23 = *(_DWORD *)(v9 + 184);
  uint64_t v24 = *(void *)(v9 + 176);
  uint64_t v25 = *(void *)(v9 + 200);
  int v26 = *(_DWORD *)(v9 + 232);
  uint64_t v27 = *(void *)(v9 + 224);
  int v28 = *(_DWORD *)(v9 + 256);
  uint64_t v29 = *(void *)(v9 + 248);
  if (*(unsigned char *)(a1 + 64))
  {
    float v57 = *(double (**)(uint64_t, uint64_t, __n128, double, __n128, double, __n128, double, float, __n128, double, double))(a1 + 24);
    int v46 = *(_DWORD *)(v9 + 232);
    int v47 = *(_DWORD *)(v9 + 184);
    uint64_t v30 = a4;
    uint64_t v53 = *(void *)(v9 + 8);
    uint64_t v54 = *(void *)(v9 + 80);
    uint64_t v55 = *(void *)(v9 + 200);
    uint64_t v56 = *(void *)(v9 + 56);
    int v51 = *(_DWORD *)(v9 + 136);
    int v31 = *(_DWORD *)(v9 + 64);
    int v49 = *(_DWORD *)(v9 + 160);
    int v32 = *(_DWORD *)(v9 + 88);
    uint64_t v52 = *(void *)(v9 + 104);
    uint64_t v50 = *(void *)(v9 + 128);
    uint64_t v48 = *(void *)(v9 + 152);
    int v45 = *(_DWORD *)(v9 + 256);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 272)), a2);
    int v28 = v45;
    int v26 = v46;
    uint64_t v22 = v48;
    uint64_t v20 = v50;
    uint64_t v18 = v52;
    uint64_t v11 = v53;
    uint64_t v16 = v54;
    uint64_t v25 = v55;
    int v15 = v32;
    int v21 = v49;
    uint64_t v14 = v56;
    int v13 = v31;
    int v19 = v51;
    a4 = v30;
    int v23 = v47;
    uint64_t v10 = v57;
  }
  float v33 = (double *)(a3 + 16 * v29);
  if (v28 != 5) {
    float v33 = (double *)((char *)a2 + 64 * v29);
  }
  int8x16_t v34 = (__n128 *)(a3 + 16 * v27);
  if (v26 != 5) {
    int8x16_t v34 = (__n128 *)((char *)a2 + 64 * v27);
  }
  float64x2_t v35 = (double *)(a3 + 16 * v24);
  if (v23 != 5) {
    float64x2_t v35 = (double *)((char *)a2 + 64 * v24);
  }
  int32x2_t v36 = (__n128 *)(a3 + 16 * v22);
  float32x2_t v37 = (__n128 *)((char *)a2 + 64 * v22);
  if (v21 != 5) {
    int32x2_t v36 = v37;
  }
  int8x8_t v38 = (double *)(a3 + 16 * v20);
  int32x2_t v39 = (double *)((char *)a2 + 64 * v20);
  if (v19 != 5) {
    int8x8_t v38 = v39;
  }
  int8x8_t v40 = (__n128 *)(a3 + 16 * v18);
  int32x2_t v41 = (__n128 *)((char *)a2 + 64 * v18);
  if (v17 != 5) {
    int8x8_t v40 = v41;
  }
  int8x16_t v42 = (double *)(a3 + 16 * v16);
  if (v15 != 5) {
    int8x16_t v42 = (double *)((char *)a2 + 64 * v16);
  }
  int8x8_t v43 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    int8x8_t v43 = (__n128 *)((char *)a2 + 64 * v14);
  }
  *(double *)&long long v44 = v10(a4 + 80 * v11, a4 + 80 * v12, *v43, *v42, *v40, *v38, *v36, *v35, *((float *)a2 + 16 * v25), *v34, *v33, v33[1]);
  *(_OWORD *)(a3 + 16 * a7) = v44;
}

float32x2_t cikernel::_parallelogramTile(CI *a1, float32x2_t a2, int8x16_t a3, int8x16_t a4)
{
  float32x2_t v5 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  int32x2_t v6 = (int32x2_t)vmul_f32(*(float32x2_t *)a3.i8, v5);
  int32x2_t v7 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v5);
  float32x2_t v8 = vadd_f32((float32x2_t)vzip1_s32(v6, v7), (float32x2_t)vzip2_s32(v6, v7));
  float32x2_t v9 = vminnm_f32(vsub_f32(v8, vrndm_f32(v8)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu));
  __asm { FMOV            V1.2S, #1.0 }
  float32x2_t v15 = vminnm_f32(v9, vsub_f32(_D1, v9));
  float32x2_t v16 = vadd_f32(v15, v15);
  int32x2_t v17 = (int32x2_t)vmul_f32(*(float32x2_t *)a4.i8, v16);
  int32x2_t v18 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v16);
  return vadd_f32(a2, vadd_f32((float32x2_t)vzip1_s32(v17, v18), (float32x2_t)vzip2_s32(v17, v18)));
}

void CI::f2_f2_f4_f4(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  uint64_t v11 = (double (*)(void *, double, __n128, __n128))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  int v14 = *(_DWORD *)(v10 + 40);
  uint64_t v15 = *(void *)(v10 + 32);
  int v16 = *(_DWORD *)(v10 + 64);
  uint64_t v17 = *(void *)(v10 + 56);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 80)), a2);
  }
  int32x2_t v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5) {
    int32x2_t v18 = (__n128 *)((char *)a2 + 64 * v17);
  }
  int v19 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5) {
    int v19 = (__n128 *)((char *)a2 + 64 * v15);
  }
  uint64_t v20 = (double *)(a3 + 16 * v13);
  if (v12 != 5) {
    uint64_t v20 = (double *)((char *)a2 + 64 * v13);
  }
  *(double *)(a3 + 16 * a7) = v11(a1, *v20, *v19, *v18);
}

void sub_1937FFF08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__12(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__12(uint64_t a1)
{
}

Class __getVNGeneratePersonSegmentationRequestClass_block_invoke(uint64_t a1)
{
  VisionLibrary_0();
  Class result = objc_getClass("VNGeneratePersonSegmentationRequest");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    __getVNGeneratePersonSegmentationRequestClass_block_invoke_cold_1();
  }
  getVNGeneratePersonSegmentationRequestClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

void VisionLibrary_0()
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  v0[0] = 0;
  if (!VisionLibraryCore_frameworkLibrary_0)
  {
    v0[1] = (void *)MEMORY[0x1E4F143A8];
    v0[2] = (void *)3221225472;
    v0[3] = __VisionLibraryCore_block_invoke_0;
    v0[4] = &__block_descriptor_40_e5_v8__0l;
    v0[5] = v0;
    long long v1 = xmmword_1E57727C8;
    uint64_t v2 = 0;
    VisionLibraryCore_frameworkLibrary_0 = _sl_dlopen();
  }
  if (!VisionLibraryCore_frameworkLibrary_0) {
    VisionLibrary_cold_1(v0);
  }
  if (v0[0]) {
    free(v0[0]);
  }
}

uint64_t __VisionLibraryCore_block_invoke_0()
{
  uint64_t result = _sl_dlopen();
  VisionLibraryCore_frameworkLibrary_0 = result;
  return result;
}

Class __getVNImageRequestHandlerClass_block_invoke(uint64_t a1)
{
  VisionLibrary_0();
  Class result = objc_getClass("VNImageRequestHandler");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    __getVNImageRequestHandlerClass_block_invoke_cold_1();
  }
  getVNImageRequestHandlerClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

uint64_t ci_signpost_log_perspectiveAC(void)
{
  if (ci_signpost_log_perspectiveAC(void)::onceToken != -1) {
    dispatch_once(&ci_signpost_log_perspectiveAC(void)::onceToken, &__block_literal_global_49);
  }
  return ci_signpost_log_perspectiveAC(void)::log;
}

os_log_t ___Z29ci_signpost_log_perspectiveACv_block_invoke()
{
  os_log_t result = os_log_create("com.apple.coreimage", "signpost_perspectiveAC");
  ci_signpost_log_perspectiveAC(void)::log = (uint64_t)result;
  return result;
}

uint64_t CIPerspectiveAutoCalcDefaultImpl(void)
{
  id v0 = objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F1CB18], "standardUserDefaults"), "objectForKey:", @"com.apple.CoreImage.PerspectiveACVersion");
  if (v0)
  {
    unint64_t v1 = [v0 integerValue];
    uint64_t v2 = 2;
    if (v1 < 2) {
      uint64_t v2 = v1;
    }
    if (v2 != 1 && v2 != 2) {
      CIPerspectiveAutoCalcDefaultImpl();
    }
  }

  return objc_opt_class();
}

void sub_193801700(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t CI::Perspective::plotLines<CI::Perspective::Line>(void *a1, CGColor *a2, uint64_t **a3)
{
  [a1 extent];
  size_t v7 = (unint64_t)v6;
  [a1 extent];
  size_t v9 = (unint64_t)v8;
  if (v7 <= (unint64_t)v8) {
    unint64_t v10 = (unint64_t)v8;
  }
  else {
    unint64_t v10 = v7;
  }
  if (v10 < 0x1F4) {
    unint64_t v11 = 1;
  }
  else {
    unint64_t v11 = v10 / 0x1F4;
  }
  [a1 extent];
  float v13 = v12;
  [a1 extent];
  float v15 = v14;
  DeviceRGB = CGColorSpaceCreateDeviceRGB();
  uint64_t v17 = CGBitmapContextCreate(0, v7, v9, 8uLL, 4 * v7, DeviceRGB, 1u);
  CGContextSetStrokeColorWithColor(v17, a2);
  CGContextSetLineWidth(v17, (double)v11);
  int v19 = *a3;
  int32x2_t v18 = a3[1];
  if (v19 != v18)
  {
    double v20 = (double)(2 * v11);
    float v42 = v15;
    do
    {
      uint64_t v21 = *v19;
      uint64_t v22 = v19[1];
      v19 += 2;
      float v23 = *(float *)&v22 - v13;
      float v24 = *((float *)&v22 + 1) - v15;
      CGFloat v25 = (float)(*(float *)&v21 - v13);
      CGFloat v26 = (float)(*((float *)&v21 + 1) - v15);
      CGContextMoveToPoint(v17, v25, v26);
      CGFloat v27 = v23;
      CGFloat v28 = v24;
      CGContextAddLineToPoint(v17, v27, v28);
      CGFloat v29 = v25 - v20;
      CGFloat v30 = v20 + v26;
      CGContextMoveToPoint(v17, v25 - v20, v20 + v26);
      CGFloat v31 = v20 + v25;
      CGFloat v32 = v26 - v20;
      CGContextAddLineToPoint(v17, v31, v32);
      CGContextMoveToPoint(v17, v29, v32);
      CGContextAddLineToPoint(v17, v31, v30);
      CGFloat v33 = v27 - v20;
      CGFloat v34 = v20 + v28;
      CGContextMoveToPoint(v17, v27 - v20, v20 + v28);
      CGFloat v35 = v20 + v27;
      CGFloat v36 = v28 - v20;
      CGContextAddLineToPoint(v17, v35, v36);
      CGContextMoveToPoint(v17, v33, v36);
      CGFloat v37 = v34;
      float v15 = v42;
      CGContextAddLineToPoint(v17, v35, v37);
    }
    while (v19 != v18);
  }
  CGContextStrokePath(v17);
  Image = CGBitmapContextCreateImage(v17);
  int32x2_t v39 = +[CIImage imageWithCGImage:Image];
  CGAffineTransformMakeTranslation(&v43, v13, v15);
  uint64_t v40 = [[(CIImage *)v39 imageByApplyingTransform:&v43] imageByCompositingOverImage:a1];
  CGImageRelease(Image);
  CGContextRelease(v17);
  CGColorSpaceRelease(DeviceRGB);
  return v40;
}

void sub_193803398(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,uint64_t a30,void *a31,uint64_t a32)
{
  operator delete(v32);
  if (__p) {
    operator delete(__p);
  }
  if (a31) {
    operator delete(a31);
  }
  CGFloat v35 = *(void **)(v33 - 168);
  if (v35)
  {
    *(void *)(v33 - 160) = v35;
    operator delete(v35);
  }
  _Unwind_Resume(a1);
}

void std::vector<CI::Perspective::Line>::reserve(void **a1, unint64_t a2)
{
  float32x2_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 4)
  {
    if (a2 >> 60) {
      abort();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    double v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::Perspective::Line>>(v3, a2);
    size_t v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF0];
    size_t v9 = &v6[16 * v8];
    unint64_t v11 = (char *)*a1;
    unint64_t v10 = (char *)a1[1];
    double v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        *((_OWORD *)v12 - 1) = *((_OWORD *)v10 - 1);
        v12 -= 16;
        v10 -= 16;
      }
      while (v10 != v11);
      unint64_t v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void sub_193803C8C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_193804B00(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

char *std::vector<CI::Perspective::Line>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >> 60) {
    abort();
  }
  os_log_t result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::Perspective::Line>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

char *___ZN2CI11PerspectiveL24CI_AUTOPERSPECTIVE_DEBUGEv_block_invoke()
{
  os_log_t result = getenv("CI_AUTOPERSPECTIVE_DEBUG");
  CI::Perspective::CI_AUTOPERSPECTIVE_DEBUG(void)::dump = result != 0;
  return result;
}

double cikernel::_gradientNormalizeV1(float32x4_t a1, float a2)
{
  *(void *)&double result = vmulq_n_f32(a1, a2).u64[0];
  return result;
}

float32x2_t cikernel::_gradientThresholdV1(float32x4_t a1, float a2, float a3)
{
  float v3 = (float)(sqrtf(vaddv_f32((float32x2_t)*(_OWORD *)&vmulq_f32(a1, a1))) - a2) / (float)(a3 - a2);
  float v4 = 1.0;
  if (v3 <= 1.0) {
    float v4 = v3;
  }
  BOOL v5 = v3 < 0.0;
  float v6 = 0.0;
  if (!v5) {
    float v6 = v4;
  }
  return vmul_n_f32(*(float32x2_t *)a1.f32, (float)(v6 * v6) * (float)((float)(v6 * -2.0) + 3.0));
}

double cikernel::_gradientRangeLimit(float32x4_t a1, float a2, float a3, float a4, float a5)
{
  float v5 = fabsf(a1.f32[1]);
  float v6 = fabsf(a1.f32[0]);
  double v7 = 0.0;
  if ((float)(v5 + v6) >= 0.001)
  {
    if (v6 >= v5) {
      float v8 = (float)((float)(a1.f32[1] / a1.f32[0]) - a4) / (float)(a5 - a4);
    }
    else {
      float v8 = (float)((float)(a1.f32[0] / a1.f32[1]) - a2) / (float)(a3 - a2);
    }
    if (v8 <= 1.0) {
      float v9 = v8;
    }
    else {
      float v9 = 1.0;
    }
    BOOL v10 = v8 < 0.0;
    float v11 = 0.0;
    if (!v10) {
      float v11 = v9;
    }
    *(void *)&double v7 = vmulq_n_f32(a1, 1.0 - (float)((float)(v11 * v11) * (float)((float)(v11 * -2.0) + 3.0))).u64[0];
  }
  return v7;
}

void CI::f4_s_f_f_f_f(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  float v11 = (double (*)(void *, __n128, float, float, float, float))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  uint64_t v14 = *(void *)(v10 + 32);
  uint64_t v15 = *(void *)(v10 + 56);
  uint64_t v16 = *(void *)(v10 + 80);
  uint64_t v17 = *(void *)(v10 + 104);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 128)), a2);
  }
  int32x2_t v18 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    int32x2_t v18 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v19 = v11(a1, *v18, *((float *)a2 + 16 * v14), *((float *)a2 + 16 * v15), *((float *)a2 + 16 * v16), *((float *)a2 + 16 * v17));
  *(_OWORD *)(a3 + 16 * a7) = v19;
}

uint64_t std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,-[CIPerspectiveAutoCalcV1 clusterLineSegments]::$_0::operator() const(std::vector<CI::Perspective::Line> const&,unsigned long)::{lambda(-[CIPerspectiveAutoCalcV1 clusterLineSegments]::Hypothesis const&,-[CIPerspectiveAutoCalcV1 clusterLineSegments]::Hypothesis const&)#1} &,std::__wrap_iter<-[CIPerspectiveAutoCalcV1 clusterLineSegments]::Hypothesis*>>(uint64_t result, uint64_t a2, float *a3)
{
  if (a2 >= 2)
  {
    int64_t v3 = (unint64_t)(a2 - 2) >> 1;
    if (v3 >= (uint64_t)(0xCCCCCCCCCCCCCCCDLL * (((uint64_t)a3 - result) >> 3)))
    {
      int64_t v4 = (0x999999999999999ALL * (((uint64_t)a3 - result) >> 3)) | 1;
      float v5 = (long long *)(result + 40 * v4);
      if ((uint64_t)(0x999999999999999ALL * (((uint64_t)a3 - result) >> 3) + 2) < a2
        && *(float *)(result + 40 * v4 + 32) > *((float *)v5 + 18))
      {
        float v5 = (long long *)((char *)v5 + 40);
        int64_t v4 = 0x999999999999999ALL * (((uint64_t)a3 - result) >> 3) + 2;
      }
      float v6 = a3[8];
      if (*((float *)v5 + 8) <= v6)
      {
        long long v13 = *(_OWORD *)a3;
        long long v14 = *((_OWORD *)a3 + 1);
        int v7 = *((_DWORD *)a3 + 9);
        do
        {
          float v8 = a3;
          a3 = (float *)v5;
          long long v9 = *v5;
          long long v10 = v5[1];
          *((void *)v8 + 4) = *((void *)v5 + 4);
          *(_OWORD *)float v8 = v9;
          *((_OWORD *)v8 + 1) = v10;
          if (v3 < v4) {
            break;
          }
          uint64_t v11 = (2 * v4) | 1;
          float v5 = (long long *)(result + 40 * v11);
          uint64_t v12 = 2 * v4 + 2;
          if (v12 < a2 && *(float *)(result + 40 * v11 + 32) > *((float *)v5 + 18))
          {
            float v5 = (long long *)((char *)v5 + 40);
            uint64_t v11 = v12;
          }
          int64_t v4 = v11;
        }
        while (*((float *)v5 + 8) <= v6);
        *(_OWORD *)a3 = v13;
        *((_OWORD *)a3 + 1) = v14;
        a3[8] = v6;
        *((_DWORD *)a3 + 9) = v7;
      }
    }
  }
  return result;
}

char *std::vector<CI::Perspective::Line>::__assign_with_size[abi:nn180100]<CI::Perspective::Line*,CI::Perspective::Line*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  int v7 = result;
  uint64_t v8 = *((void *)result + 2);
  long long v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *int v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 60) {
      abort();
    }
    uint64_t v10 = v8 >> 3;
    if (v8 >> 3 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    double result = std::vector<CI::Perspective::Line>::__vallocate[abi:nn180100](v7, v11);
    long long v13 = (char *)v7[1];
    uint64_t v12 = (void **)(v7 + 1);
    long long v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      int32x2_t v18 = v9;
      long long v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  uint64_t v12 = (void **)(result + 8);
  long long v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 4;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  uint64_t v16 = &__src[16 * v15];
  if (v14 != v9)
  {
    double result = (char *)memmove(*(void **)result, __src, v14 - v9);
    long long v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    int32x2_t v18 = v9;
    long long v19 = v16;
LABEL_18:
    double result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *uint64_t v12 = &v9[v17];
  return result;
}

void sub_19380830C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,uint64_t a30,void *a31,uint64_t a32)
{
  operator delete(v32);
  if (__p) {
    operator delete(__p);
  }
  if (a31) {
    operator delete(a31);
  }
  CGFloat v35 = *(void **)(v33 - 168);
  if (v35)
  {
    *(void *)(v33 - 160) = v35;
    operator delete(v35);
  }
  _Unwind_Resume(a1);
}

void sub_193808B48(_Unwind_Exception *exception_object)
{
  int64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<LineCostProxy>::reserve(void **a1, unint64_t a2)
{
  int64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - (unsigned char *)*a1) >> 3) < a2)
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    uint64_t v5 = ((unsigned char *)a1[1] - (unsigned char *)*a1) / 24;
    float v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SWRendererFunctionInputNode>>(v3, a2);
    int v7 = &v6[24 * v5];
    long long v9 = &v6[24 * v8];
    unint64_t v11 = (char *)*a1;
    uint64_t v10 = (char *)a1[1];
    uint64_t v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        long long v13 = *(_OWORD *)(v10 - 24);
        *((void *)v12 - 1) = *((void *)v10 - 1);
        *(_OWORD *)(v12 - 24) = v13;
        v12 -= 24;
        v10 -= 24;
      }
      while (v10 != v11);
      uint64_t v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

char *___ZN2CI11PerspectiveL24CI_AUTOPERSPECTIVE_DEBUGEv_block_invoke_0()
{
  double result = getenv("CI_AUTOPERSPECTIVE_DEBUG");
  CI::Perspective::CI_AUTOPERSPECTIVE_DEBUG(void)::dump = result != 0;
  return result;
}

double cikernel::_lumaRange(float32x4_t a1, float a2, float a3)
{
  float32x4_t v3 = vmulq_f32(a1, (float32x4_t)xmmword_193954EE0);
  float v4 = (float)(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))).f32[0]- a2)/ (float)(a3 - a2);
  if (v4 <= 1.0) {
    float v5 = v4;
  }
  else {
    float v5 = 1.0;
  }
  BOOL v6 = v4 < 0.0;
  int32x2_t v7 = 0;
  if (!v6) {
    *(float *)v7.i32 = v5;
  }
  *(float *)v7.i32 = (float)(*(float *)v7.i32 * *(float *)v7.i32) * (float)((float)(*(float *)v7.i32 * -2.0) + 3.0);
  *(void *)&double result = vdupq_lane_s32(v7, 0).u64[0];
  return result;
}

double cikernel::_gradientNormalizeV2(float32x4_t a1, float32x4_t a2)
{
  *(void *)&double result = vmulq_n_f32(vsubq_f32(a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.f32, 0)), 1.0 / vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.f32, 1), a2).f32[0]).u64[0];
  return result;
}

float32x2_t cikernel::_gradientThresholdV2(float32x4_t a1, float a2, float a3)
{
  float v3 = (float)(sqrtf(vaddv_f32((float32x2_t)*(_OWORD *)&vmulq_f32(a1, a1))) - a2) / (float)(a3 - a2);
  float v4 = 1.0;
  if (v3 <= 1.0) {
    float v4 = v3;
  }
  BOOL v5 = v3 < 0.0;
  float v6 = 0.0;
  if (!v5) {
    float v6 = v4;
  }
  return vmul_n_f32(*(float32x2_t *)a1.f32, (float)(v6 * v6) * (float)((float)(v6 * -2.0) + 3.0));
}

uint64_t _ZN2CI11Perspective9NMSimplexIDv3_fEC2ENS0_8NMParamsEU13block_pointerFfRKS2_EPS5_m(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  long long v10 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v10;
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 40) = 0;
  unint64_t v11 = (char **)(a1 + 40);
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  _ZNSt3__16vectorIN2CI11Perspective9NMSimplexIDv3_fE8NMVertexENS_9allocatorIS6_EEE7reserveEm((void **)(a1 + 40), a5);
  if (a5)
  {
    uint64_t v12 = 0;
    do
    {
      long long v56 = *(_OWORD *)(a4 + 16 * v12);
      float v13 = (*(float (**)(uint64_t))(a3 + 16))(a3);
      unint64_t v15 = *(void *)(a1 + 48);
      unint64_t v14 = *(void *)(a1 + 56);
      if (v15 >= v14)
      {
        uint64_t v17 = (uint64_t)(v15 - (void)*v11) >> 5;
        unint64_t v18 = v17 + 1;
        if ((unint64_t)(v17 + 1) >> 59) {
          abort();
        }
        uint64_t v19 = v14 - (void)*v11;
        if (v19 >> 4 > v18) {
          unint64_t v18 = v19 >> 4;
        }
        if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v20 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v20 = v18;
        }
        if (v20) {
          uint64_t v21 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SoftwareDAGDescriptor::ArgumentInfo>>(a1 + 56, v20);
        }
        else {
          uint64_t v21 = 0;
        }
        uint64_t v22 = (float *)&v21[32 * v17];
        *(_OWORD *)uint64_t v22 = v56;
        v22[4] = v13;
        float v24 = *(char **)(a1 + 40);
        float v23 = *(char **)(a1 + 48);
        CGFloat v25 = v22;
        if (v23 != v24)
        {
          do
          {
            long long v26 = *((_OWORD *)v23 - 1);
            *((_OWORD *)v25 - 2) = *((_OWORD *)v23 - 2);
            *((_OWORD *)v25 - 1) = v26;
            v25 -= 8;
            v23 -= 32;
          }
          while (v23 != v24);
          float v23 = *v11;
        }
        uint64_t v16 = (char *)(v22 + 8);
        *(void *)(a1 + 40) = v25;
        *(void *)(a1 + 48) = v22 + 8;
        *(void *)(a1 + 56) = &v21[32 * v20];
        if (v23) {
          operator delete(v23);
        }
      }
      else
      {
        *(_OWORD *)unint64_t v15 = v56;
        *(float *)(v15 + 16) = v13;
        uint64_t v16 = (char *)(v15 + 32);
      }
      *(void *)(a1 + 48) = v16;
      ++v12;
    }
    while (v12 != a5);
  }
  for (*(void *)(a1 + 64) = 1;
        (_ZNK2CI11Perspective9NMSimplexIDv3_fE15shouldTerminateEv(a1) & 1) == 0;
        ++*(void *)(a1 + 64))
  {
    unint64_t v28 = *(void *)(a1 + 40);
    CGFloat v29 = *(float **)(a1 + 48);
    unint64_t v30 = 126 - 2 * __clz((uint64_t)((uint64_t)v29 - v28) >> 5);
    if (v29 == (float *)v28) {
      uint64_t v31 = 0;
    }
    else {
      uint64_t v31 = v30;
    }
    _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_Lb0EEEvT1_SD_T0_NS_15iterator_traitsISD_E15difference_typeEb(v28, v29, (uint64_t)&v63, v31, 1);
    CGFloat v34 = *(float32x4_t **)(a1 + 40);
    uint64_t v33 = *(void *)(a1 + 48);
    uint64_t v35 = (v33 - (uint64_t)v34) >> 5;
    float32x4_t v36 = 0uLL;
    unint64_t v37 = v35 - 1;
    if (v35 != 1)
    {
      int8x8_t v38 = *(float32x4_t **)(a1 + 40);
      uint64_t v39 = v35 - 1;
      do
      {
        float32x4_t v40 = *v38;
        v38 += 2;
        v32.i32[1] = v40.i32[1];
        float32x4_t v36 = vaddq_f32(v36, v40);
        --v39;
      }
      while (v39);
    }
    *(float *)v32.i32 = (float)v37;
    v63.i32[2] = 0;
    v63.i64[0] = 0;
    float32x4_t v57 = vdivq_f32(v36, (float32x4_t)vdupq_lane_s32(v32, 0));
    int8x16_t v54 = (int8x16_t)vmlaq_n_f32(v57, vsubq_f32(v57, *(float32x4_t *)(v33 - 32)), *(float *)a1);
    float32x4_t v63 = (float32x4_t)v54;
    v41.i32[0] = (*(float (**)(uint64_t, float32x4_t *))(a3 + 16))(a3, &v63);
    float v42 = &v34[2 * v37];
    float v43 = v34[1].f32[0];
    if (v43 <= v41.f32[0] && v41.f32[0] < v34[2 * v35 - 3].f32[0])
    {
      *float v42 = (float32x4_t)v54;
      v42[1].i32[0] = v41.i32[0];
    }
    else
    {
      if (v41.f32[0] < v43)
      {
        float32x4_t v53 = v41;
        int8x16_t v58 = (int8x16_t)vmlaq_n_f32(v57, vsubq_f32(v63, v57), *(float *)(a1 + 4));
        int8x16_t v62 = v58;
        *(double *)v45.i64 = (*(double (**)(uint64_t, int8x16_t *))(a3 + 16))(a3, &v62);
        int8x16_t v46 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(v53, v45), 0), v58, v54);
        v42[1].i32[3] = 0;
        *(uint64_t *)((char *)v42[1].i64 + 4) = 0;
        if (v45.f32[0] >= v53.f32[0]) {
          v45.f32[0] = v53.f32[0];
        }
        *float v42 = (float32x4_t)v46;
        v42[1].i32[0] = v45.i32[0];
        continue;
      }
      v62.i32[2] = 0;
      v62.i64[0] = 0;
      float32x4_t v59 = vmlaq_n_f32(v57, vsubq_f32(*(float32x4_t *)(*(void *)(a1 + 48) - 32), v57), *(float *)(a1 + 8));
      int8x16_t v62 = (int8x16_t)v59;
      float v47 = (*(float (**)(uint64_t, int8x16_t *))(a3 + 16))(a3, &v62);
      if (v47 >= v34[2 * v37 + 1].f32[0])
      {
        uint64_t v48 = *(void *)(a1 + 40);
        if ((unint64_t)(*(void *)(a1 + 48) - v48) >= 0x21)
        {
          uint64_t v49 = 0;
          float32x4_t v55 = *v34;
          unint64_t v50 = 1;
          do
          {
            v61.i32[2] = 0;
            v61.i64[0] = 0;
            float32x4_t v60 = vmlaq_n_f32(v55, vsubq_f32(*(float32x4_t *)(v48 + v49 + 32), v55), *(float *)(a2 + 12));
            float32x4_t v61 = v60;
            float v51 = (*(float (**)(uint64_t, float32x4_t *))(a3 + 16))(a3, &v61);
            uint64_t v52 = (float32x4_t *)(*(void *)(a1 + 40) + v49);
            v52[2] = v60;
            v52[3].f32[0] = v51;
            ++v50;
            uint64_t v48 = *(void *)(a1 + 40);
            v49 += 32;
          }
          while (v50 < (*(void *)(a1 + 48) - v48) >> 5);
        }
        continue;
      }
      *float v42 = v59;
      v42[1].f32[0] = v47;
    }
    *(uint64_t *)((char *)v42[1].i64 + 4) = 0;
    v42[1].i32[3] = 0;
  }
  return a1;
}

void sub_19380B564(_Unwind_Exception *exception_object)
{
  float v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 48) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void _ZNSt3__16vectorIN2CI11Perspective9NMSimplexIDv3_fE8NMVertexENS_9allocatorIS6_EEE7reserveEm(void **a1, unint64_t a2)
{
  float v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 5)
  {
    if (a2 >> 59) {
      abort();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    float v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SoftwareDAGDescriptor::ArgumentInfo>>(v3, a2);
    int32x2_t v7 = &v6[v5 & 0xFFFFFFFFFFFFFFE0];
    long long v9 = &v6[32 * v8];
    unint64_t v11 = (char *)*a1;
    long long v10 = (char *)a1[1];
    uint64_t v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        long long v13 = *((_OWORD *)v10 - 1);
        *((_OWORD *)v12 - 2) = *((_OWORD *)v10 - 2);
        *((_OWORD *)v12 - 1) = v13;
        v12 -= 32;
        v10 -= 32;
      }
      while (v10 != v11);
      long long v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

uint64_t _ZNK2CI11Perspective9NMSimplexIDv3_fE15shouldTerminateEv(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 24);
  if (v1 && *(void *)(a1 + 64) >= v1) {
    return 1;
  }
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = *(void *)(a1 + 48);
  if (v2 == v3)
  {
    float v6 = (float)(unint64_t)((v3 - v2) >> 5);
  }
  else
  {
    float v4 = 0.0;
    uint64_t v5 = *(void *)(a1 + 40);
    do
    {
      float v4 = v4 + *(float *)(v5 + 16);
      v5 += 32;
    }
    while (v5 != v3);
    float v6 = (float)(unint64_t)((v3 - v2) >> 5);
    if (v3 != v2)
    {
      float v7 = 0.0;
      float v8 = v4 / v6;
      do
      {
        float v7 = v7 + (float)((float)(*(float *)(v2 + 16) - v8) * (float)(*(float *)(v2 + 16) - v8));
        v2 += 32;
      }
      while (v2 != v3);
      return sqrtf(v7 / v6) < *(float *)(a1 + 16);
    }
  }
  float v7 = 0.0;
  return sqrtf(v7 / v6) < *(float *)(a1 + 16);
}

void _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_Lb0EEEvT1_SD_T0_NS_15iterator_traitsISD_E15difference_typeEb(unint64_t a1, float *a2, uint64_t a3, uint64_t a4, char a5)
{
LABEL_1:
  unint64_t v11 = a1;
LABEL_2:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    a1 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (uint64_t)a2 - v11;
    unint64_t v15 = (uint64_t)((uint64_t)a2 - v11) >> 5;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          if (*(a2 - 4) < *(float *)(v11 + 16))
          {
            __n128 v24 = *(__n128 *)v11;
            long long v26 = *(_OWORD *)(v11 + 16);
            long long v22 = *((_OWORD *)a2 - 1);
            *(_OWORD *)unint64_t v11 = *((_OWORD *)a2 - 2);
            *(_OWORD *)(v11 + 16) = v22;
            *((__n128 *)a2 - 2) = v24;
            *((_OWORD *)a2 - 1) = v26;
          }
          break;
        case 3uLL:
          _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_((float *)v11, (float *)(v11 + 32), a2 - 8);
          break;
        case 4uLL:
          _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_SD_SD_T0_((__n128 *)v11, (__n128 *)(v11 + 32), (__n128 *)(v11 + 64), (__n128 *)a2 - 2);
          break;
        case 5uLL:
          _ZNSt3__17__sort5B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_SD_SD_SD_T0_((__n128 *)v11, (__n128 *)(v11 + 32), (__n128 *)(v11 + 64), (__n128 *)(v11 + 96), (__n128 *)a2 - 2);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v14 <= 767) {
      break;
    }
    if (v13 == 1)
    {
      if ((float *)v11 != a2)
      {
        _ZNSt3__119__partial_sort_implB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_SC_EET1_SD_SD_T2_OT0_(v11, a2, a2, a3);
      }
      return;
    }
    unint64_t v16 = v15 >> 1;
    unint64_t v17 = v11 + 32 * (v15 >> 1);
    if ((unint64_t)v14 > 0x1000)
    {
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_((float *)v11, (float *)(v11 + 32 * (v15 >> 1)), a2 - 8);
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_((float *)(v11 + 32), (float *)(v17 - 32), a2 - 16);
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_((float *)(v11 + 64), (float *)(v11 + 32 + 32 * v16), a2 - 24);
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_((float *)(v17 - 32), (float *)v17, (float *)(v11 + 32 + 32 * v16));
      __n128 v23 = *(__n128 *)v11;
      long long v25 = *(_OWORD *)(v11 + 16);
      long long v18 = *(_OWORD *)(v17 + 16);
      *(_OWORD *)unint64_t v11 = *(_OWORD *)v17;
      *(_OWORD *)(v11 + 16) = v18;
      *(__n128 *)unint64_t v17 = v23;
      *(_OWORD *)(v17 + 16) = v25;
      if (a5) {
        goto LABEL_13;
      }
    }
    else
    {
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_((float *)(v11 + 32 * (v15 >> 1)), (float *)v11, a2 - 8);
      if (a5) {
        goto LABEL_13;
      }
    }
    if (*(float *)(v11 - 16) >= *(float *)(v11 + 16))
    {
      unint64_t v11 = _ZNSt3__131__partition_with_equals_on_leftB8nn180100INS_17_ClassicAlgPolicyEPN2CI11Perspective9NMSimplexIDv3_fE8NMVertexERZNS6_13orderVerticesEvEUlRKS7_SA_E_EET0_SD_SD_T1_((long long *)v11, a2);
      goto LABEL_18;
    }
LABEL_13:
    unint64_t v19 = _ZNSt3__132__partition_with_equals_on_rightB8nn180100INS_17_ClassicAlgPolicyEPN2CI11Perspective9NMSimplexIDv3_fE8NMVertexERZNS6_13orderVerticesEvEUlRKS7_SA_E_EENS_4pairIT0_bEESE_SE_T1_((long long *)v11, a2);
    if ((v20 & 1) == 0) {
      goto LABEL_16;
    }
    BOOL v21 = _ZNSt3__127__insertion_sort_incompleteB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEbT1_SD_T0_(v11, v19);
    unint64_t v11 = v19 + 32;
    if (_ZNSt3__127__insertion_sort_incompleteB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEbT1_SD_T0_(v19 + 32, (uint64_t)a2))
    {
      a4 = -v13;
      a2 = (float *)v19;
      if (v21) {
        return;
      }
      goto LABEL_1;
    }
    uint64_t v12 = v13 + 1;
    if (!v21)
    {
LABEL_16:
      _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_Lb0EEEvT1_SD_T0_NS_15iterator_traitsISD_E15difference_typeEb(a1, v19, a3, -v13, a5 & 1);
      unint64_t v11 = v19 + 32;
LABEL_18:
      a5 = 0;
      a4 = -v13;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    _ZNSt3__116__insertion_sortB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_T0_(v11, a2);
  }
  else
  {
    _ZNSt3__126__insertion_sort_unguardedB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_T0_((long long *)v11, (long long *)a2);
  }
}

  unint64_t v11 = a1;
LABEL_2:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    a1 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (char *)a2 - (char *)v11;
    unint64_t v15 = a2 - v11;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          if (a2[-1].n128_f32[2] < v11->n128_f32[2])
          {
            long long v22 = *v11;
            *unint64_t v11 = a2[-1];
            a2[-1] = v22;
          }
          break;
        case 3uLL:
          _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_((float *)v11, (float *)&v11[1], (float *)&a2[-1]);
          break;
        case 4uLL:
          _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_SD_SD_T0_((float *)v11, (uint64_t)&v11[1], (uint64_t)&v11[2], (uint64_t)&a2[-1]);
          break;
        case 5uLL:
          _ZNSt3__17__sort5B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_SD_SD_SD_T0_((float *)v11, v11 + 1, v11 + 2, v11 + 3, a2 - 1);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v14 <= 383) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        _ZNSt3__119__partial_sort_implB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_SC_EET1_SD_SD_T2_OT0_((float *)v11, (float *)a2, (float *)a2, a3);
      }
      return;
    }
    unint64_t v16 = v15 >> 1;
    unint64_t v17 = (float *)&v11[v15 >> 1];
    if ((unint64_t)v14 >= 0x801)
    {
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_((float *)v11, (float *)&v11[v15 >> 1], (float *)&a2[-1]);
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_((float *)&v11[1], v17 - 4, (float *)&a2[-2]);
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_((float *)&v11[2], (float *)&v11[v16 + 1], (float *)&a2[-3]);
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_(v17 - 4, v17, (float *)&v11[v16 + 1]);
      BOOL v21 = *v11;
      *unint64_t v11 = *(__n128 *)v17;
      *(__n128 *)unint64_t v17 = v21;
      if (a5) {
        goto LABEL_13;
      }
    }
    else
    {
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_((float *)&v11[v15 >> 1], (float *)v11, (float *)&a2[-1]);
      if (a5) {
        goto LABEL_13;
      }
    }
    if (v11[-1].n128_f32[2] >= v11->n128_f32[2])
    {
      unint64_t v11 = (__n128 *)_ZNSt3__131__partition_with_equals_on_leftB8nn180100INS_17_ClassicAlgPolicyEPN2CI11Perspective9NMSimplexIDv2_fE8NMVertexERZNS6_13orderVerticesEvEUlRKS7_SA_E_EET0_SD_SD_T1_((float *)v11, (float *)a2);
      goto LABEL_18;
    }
LABEL_13:
    long long v18 = (__n128 *)_ZNSt3__132__partition_with_equals_on_rightB8nn180100INS_17_ClassicAlgPolicyEPN2CI11Perspective9NMSimplexIDv2_fE8NMVertexERZNS6_13orderVerticesEvEUlRKS7_SA_E_EENS_4pairIT0_bEESE_SE_T1_((float *)v11, (float *)a2);
    if ((v19 & 1) == 0) {
      goto LABEL_16;
    }
    char v20 = _ZNSt3__127__insertion_sort_incompleteB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEbT1_SD_T0_(v11, v18);
    unint64_t v11 = v18 + 1;
    if (_ZNSt3__127__insertion_sort_incompleteB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEbT1_SD_T0_(v18 + 1, a2))
    {
      a4 = -v13;
      a2 = v18;
      if (v20) {
        return;
      }
      goto LABEL_1;
    }
    uint64_t v12 = v13 + 1;
    if (!v20)
    {
LABEL_16:
      _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_Lb0EEEvT1_SD_T0_NS_15iterator_traitsISD_E15difference_typeEb(a1, v18, a3, -v13, a5 & 1);
      unint64_t v11 = v18 + 1;
LABEL_18:
      a5 = 0;
      a4 = -v13;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    _ZNSt3__116__insertion_sortB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_T0_((uint64_t)v11, a2);
  }
  else
  {
    _ZNSt3__126__insertion_sort_unguardedB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_T0_(v11, a2);
  }
}

uint64_t _ZNSt3__116__insertion_sortB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_T0_(uint64_t result, _OWORD *a2)
{
  if ((_OWORD *)result != a2)
  {
    uint64_t v2 = (_OWORD *)(result + 32);
    if ((_OWORD *)(result + 32) != a2)
    {
      uint64_t v3 = 0;
      float v4 = (_OWORD *)result;
      do
      {
        char v5 = v2;
        float v6 = *((float *)v4 + 12);
        if (v6 < *((float *)v4 + 4))
        {
          long long v11 = *v2;
          uint64_t v12 = *(void *)((char *)v4 + 52);
          int v13 = *((_DWORD *)v4 + 15);
          uint64_t v7 = v3;
          while (1)
          {
            uint64_t v8 = result + v7;
            long long v9 = *(_OWORD *)(result + v7 + 16);
            *(_OWORD *)(v8 + 32) = *(_OWORD *)(result + v7);
            *(_OWORD *)(v8 + 48) = v9;
            if (!v7) {
              break;
            }
            v7 -= 32;
            if (v6 >= *(float *)(v8 - 16))
            {
              uint64_t v10 = result + v7 + 32;
              goto LABEL_10;
            }
          }
          uint64_t v10 = result;
LABEL_10:
          *(_OWORD *)uint64_t v10 = v11;
          *(float *)(v10 + 16) = v6;
          *(void *)(v10 + 20) = v12;
          *(_DWORD *)(v10 + 28) = v13;
        }
        uint64_t v2 = v5 + 2;
        v3 += 32;
        float v4 = v5;
      }
      while (v5 + 2 != a2);
    }
  }
  return result;
}

long long *_ZNSt3__126__insertion_sort_unguardedB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_T0_(long long *result, long long *a2)
{
  if (result != a2)
  {
    uint64_t v2 = result + 2;
    while (v2 != a2)
    {
      uint64_t v3 = v2;
      float v4 = *((float *)result + 12);
      if (v4 < *((float *)result + 4))
      {
        long long v7 = *v2;
        uint64_t v8 = *(void *)((char *)result + 52);
        int v9 = *((_DWORD *)result + 15);
        do
        {
          long long v5 = *(v2 - 1);
          *uint64_t v2 = *(v2 - 2);
          v2[1] = v5;
          float v6 = *((float *)v2 - 12);
          v2 -= 2;
        }
        while (v4 < v6);
        *uint64_t v2 = v7;
        *((float *)v2 + 4) = v4;
        *(void *)((char *)v2 + 20) = v8;
        *((_DWORD *)v2 + 7) = v9;
      }
      uint64_t v2 = v3 + 2;
      double result = v3;
    }
  }
  return result;
}

uint64_t _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_(float *a1, float *a2, float *a3)
{
  float v3 = a2[4];
  float v4 = a3[4];
  if (v3 < a1[4])
  {
    if (v4 < v3)
    {
      long long v6 = *(_OWORD *)a1;
      long long v5 = *((_OWORD *)a1 + 1);
      long long v7 = *((_OWORD *)a3 + 1);
      *(_OWORD *)a1 = *(_OWORD *)a3;
      *((_OWORD *)a1 + 1) = v7;
      *(_OWORD *)a3 = v6;
      *((_OWORD *)a3 + 1) = v5;
      return 1;
    }
    long long v15 = *(_OWORD *)a1;
    long long v14 = *((_OWORD *)a1 + 1);
    long long v16 = *((_OWORD *)a2 + 1);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *((_OWORD *)a1 + 1) = v16;
    *(_OWORD *)a2 = v15;
    *((_OWORD *)a2 + 1) = v14;
    if (a3[4] >= a2[4]) {
      return 1;
    }
    long long v18 = *(_OWORD *)a2;
    long long v17 = *((_OWORD *)a2 + 1);
    long long v19 = *((_OWORD *)a3 + 1);
    *(_OWORD *)a2 = *(_OWORD *)a3;
    *((_OWORD *)a2 + 1) = v19;
    *(_OWORD *)a3 = v18;
    *((_OWORD *)a3 + 1) = v17;
    return 2;
  }
  if (v4 < v3)
  {
    long long v9 = *(_OWORD *)a2;
    long long v8 = *((_OWORD *)a2 + 1);
    long long v10 = *((_OWORD *)a3 + 1);
    *(_OWORD *)a2 = *(_OWORD *)a3;
    *((_OWORD *)a2 + 1) = v10;
    *(_OWORD *)a3 = v9;
    *((_OWORD *)a3 + 1) = v8;
    if (a2[4] >= a1[4]) {
      return 1;
    }
    long long v12 = *(_OWORD *)a1;
    long long v11 = *((_OWORD *)a1 + 1);
    long long v13 = *((_OWORD *)a2 + 1);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *((_OWORD *)a1 + 1) = v13;
    *(_OWORD *)a2 = v12;
    *((_OWORD *)a2 + 1) = v11;
    return 2;
  }
  return 0;
}

unint64_t _ZNSt3__131__partition_with_equals_on_leftB8nn180100INS_17_ClassicAlgPolicyEPN2CI11Perspective9NMSimplexIDv3_fE8NMVertexERZNS6_13orderVerticesEvEUlRKS7_SA_E_EET0_SD_SD_T1_(long long *a1, float *a2)
{
  long long v16 = *a1;
  float v2 = *((float *)a1 + 4);
  uint64_t v19 = *(void *)((char *)a1 + 20);
  int v20 = *((_DWORD *)a1 + 7);
  if (v2 >= *(a2 - 4))
  {
    unint64_t v6 = (unint64_t)(a1 + 2);
    do
    {
      unint64_t v4 = v6;
      if (v6 >= (unint64_t)a2) {
        break;
      }
      float v7 = *(float *)(v6 + 16);
      v6 += 32;
    }
    while (v2 >= v7);
  }
  else
  {
    float v3 = (float *)a1;
    do
    {
      unint64_t v4 = (unint64_t)(v3 + 8);
      float v5 = v3[12];
      v3 += 8;
    }
    while (v2 >= v5);
  }
  if (v4 >= (unint64_t)a2)
  {
    long long v8 = a2;
  }
  else
  {
    do
    {
      long long v8 = a2 - 8;
      float v9 = *(a2 - 4);
      a2 -= 8;
    }
    while (v2 < v9);
  }
  while (v4 < (unint64_t)v8)
  {
    long long v17 = *(_OWORD *)v4;
    long long v18 = *(_OWORD *)(v4 + 16);
    long long v10 = *((_OWORD *)v8 + 1);
    *(_OWORD *)unint64_t v4 = *(_OWORD *)v8;
    *(_OWORD *)(v4 + 16) = v10;
    *(_OWORD *)long long v8 = v17;
    *((_OWORD *)v8 + 1) = v18;
    do
    {
      float v11 = *(float *)(v4 + 48);
      v4 += 32;
    }
    while (v2 >= v11);
    do
    {
      float v12 = *(v8 - 4);
      v8 -= 8;
    }
    while (v2 < v12);
  }
  long long v13 = (long long *)(v4 - 32);
  if ((long long *)(v4 - 32) != a1)
  {
    long long v14 = *(_OWORD *)(v4 - 16);
    *a1 = *v13;
    a1[1] = v14;
  }
  *long long v13 = v16;
  *(float *)(v4 - 16) = v2;
  *(_DWORD *)(v4 - 4) = v20;
  *(void *)(v4 - 12) = v19;
  return v4;
}

unint64_t _ZNSt3__132__partition_with_equals_on_rightB8nn180100INS_17_ClassicAlgPolicyEPN2CI11Perspective9NMSimplexIDv3_fE8NMVertexERZNS6_13orderVerticesEvEUlRKS7_SA_E_EENS_4pairIT0_bEESE_SE_T1_(long long *a1, float *a2)
{
  uint64_t v2 = 0;
  long long v18 = *a1;
  float v3 = *((float *)a1 + 4);
  uint64_t v20 = *(void *)((char *)a1 + 20);
  int v21 = *((_DWORD *)a1 + 7);
  do
  {
    float v4 = *(float *)&a1[v2 + 3];
    v2 += 2;
  }
  while (v4 < v3);
  unint64_t v5 = (unint64_t)&a1[v2];
  if (v2 == 2)
  {
    while (v5 < (unint64_t)a2)
    {
      unint64_t v6 = a2 - 8;
      float v8 = *(a2 - 4);
      a2 -= 8;
      if (v8 < v3) {
        goto LABEL_9;
      }
    }
    unint64_t v6 = a2;
  }
  else
  {
    do
    {
      unint64_t v6 = a2 - 8;
      float v7 = *(a2 - 4);
      a2 -= 8;
    }
    while (v7 >= v3);
  }
LABEL_9:
  unint64_t v9 = (unint64_t)&a1[v2];
  if (v5 < (unint64_t)v6)
  {
    long long v10 = v6;
    do
    {
      long long v11 = *(_OWORD *)v9;
      long long v19 = *(_OWORD *)(v9 + 16);
      long long v12 = *((_OWORD *)v10 + 1);
      *(_OWORD *)unint64_t v9 = *(_OWORD *)v10;
      *(_OWORD *)(v9 + 16) = v12;
      *(_OWORD *)long long v10 = v11;
      *((_OWORD *)v10 + 1) = v19;
      do
      {
        float v13 = *(float *)(v9 + 48);
        v9 += 32;
      }
      while (v13 < v3);
      do
      {
        float v14 = *(v10 - 4);
        v10 -= 8;
      }
      while (v14 >= v3);
    }
    while (v9 < (unint64_t)v10);
  }
  long long v15 = (long long *)(v9 - 32);
  if ((long long *)(v9 - 32) != a1)
  {
    long long v16 = *(_OWORD *)(v9 - 16);
    *a1 = *v15;
    a1[1] = v16;
  }
  *long long v15 = v18;
  *(float *)(v9 - 16) = v3;
  *(_DWORD *)(v9 - 4) = v21;
  *(void *)(v9 - 12) = v20;
  return v9 - 32;
}

BOOL _ZNSt3__127__insertion_sort_incompleteB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEbT1_SD_T0_(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 5;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (*(float *)(a2 - 16) < *(float *)(a1 + 16))
      {
        long long v7 = *(_OWORD *)a1;
        long long v6 = *(_OWORD *)(a1 + 16);
        long long v8 = *(_OWORD *)(a2 - 16);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 32);
        *(_OWORD *)(a1 + 16) = v8;
        *(_OWORD *)(a2 - 32) = v7;
        *(_OWORD *)(a2 - 16) = v6;
      }
      return result;
    case 3:
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_((float *)a1, (float *)(a1 + 32), (float *)(a2 - 32));
      return 1;
    case 4:
      _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_SD_SD_T0_((__n128 *)a1, (__n128 *)(a1 + 32), (__n128 *)(a1 + 64), (__n128 *)(a2 - 32));
      return 1;
    case 5:
      _ZNSt3__17__sort5B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_SD_SD_SD_T0_((__n128 *)a1, (__n128 *)(a1 + 32), (__n128 *)(a1 + 64), (__n128 *)(a1 + 96), (__n128 *)(a2 - 32));
      return 1;
    default:
      uint64_t v9 = a1 + 64;
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_((float *)a1, (float *)(a1 + 32), (float *)(a1 + 64));
      uint64_t v10 = a1 + 96;
      if (a1 + 96 == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    float v13 = *(float *)(v10 + 16);
    if (v13 < *(float *)(v9 + 16))
    {
      long long v18 = *(_OWORD *)v10;
      uint64_t v19 = *(void *)(v10 + 20);
      int v20 = *(_DWORD *)(v10 + 28);
      uint64_t v14 = v11;
      while (1)
      {
        uint64_t v15 = a1 + v14;
        long long v16 = *(_OWORD *)(a1 + v14 + 80);
        *(_OWORD *)(v15 + 96) = *(_OWORD *)(a1 + v14 + 64);
        *(_OWORD *)(v15 + 112) = v16;
        if (v14 == -64) {
          break;
        }
        v14 -= 32;
        if (v13 >= *(float *)(v15 + 48))
        {
          uint64_t v17 = a1 + v14 + 96;
          goto LABEL_12;
        }
      }
      uint64_t v17 = a1;
LABEL_12:
      *(_OWORD *)uint64_t v17 = v18;
      *(float *)(v17 + 16) = v13;
      *(void *)(v17 + 20) = v19;
      *(_DWORD *)(v17 + 28) = v20;
      if (++v12 == 8) {
        return v10 + 32 == a2;
      }
    }
    uint64_t v9 = v10;
    v11 += 32;
    v10 += 32;
    if (v10 == a2) {
      return 1;
    }
  }
}

__n128 _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_SD_SD_T0_(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4)
{
  _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_((float *)a1, (float *)a2, (float *)a3);
  result.n128_u32[0] = a4[1].n128_u32[0];
  if (result.n128_f32[0] < a3[1].n128_f32[0])
  {
    __n128 v9 = *a3;
    __n128 result = a3[1];
    __n128 v10 = a4[1];
    *a3 = *a4;
    a3[1] = v10;
    *a4 = v9;
    a4[1] = result;
    result.n128_u32[0] = a3[1].n128_u32[0];
    if (result.n128_f32[0] < a2[1].n128_f32[0])
    {
      __n128 v11 = *a2;
      __n128 result = a2[1];
      __n128 v12 = a3[1];
      *a2 = *a3;
      a2[1] = v12;
      *a3 = v11;
      a3[1] = result;
      result.n128_u32[0] = a2[1].n128_u32[0];
      if (result.n128_f32[0] < a1[1].n128_f32[0])
      {
        __n128 v13 = *a1;
        __n128 result = a1[1];
        __n128 v14 = a2[1];
        *a1 = *a2;
        a1[1] = v14;
        *a2 = v13;
        a2[1] = result;
      }
    }
  }
  return result;
}

__n128 _ZNSt3__17__sort5B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_SD_SD_SD_T0_(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4, __n128 *a5)
{
  __n128 result = _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_SD_SD_T0_(a1, a2, a3, a4);
  result.n128_u32[0] = a5[1].n128_u32[0];
  if (result.n128_f32[0] < a4[1].n128_f32[0])
  {
    __n128 v11 = *a4;
    __n128 result = a4[1];
    __n128 v12 = a5[1];
    *a4 = *a5;
    a4[1] = v12;
    *a5 = v11;
    a5[1] = result;
    result.n128_u32[0] = a4[1].n128_u32[0];
    if (result.n128_f32[0] < a3[1].n128_f32[0])
    {
      __n128 v13 = *a3;
      __n128 result = a3[1];
      __n128 v14 = a4[1];
      *a3 = *a4;
      a3[1] = v14;
      *a4 = v13;
      a4[1] = result;
      result.n128_u32[0] = a3[1].n128_u32[0];
      if (result.n128_f32[0] < a2[1].n128_f32[0])
      {
        __n128 v15 = *a2;
        __n128 result = a2[1];
        __n128 v16 = a3[1];
        *a2 = *a3;
        a2[1] = v16;
        *a3 = v15;
        a3[1] = result;
        result.n128_u32[0] = a2[1].n128_u32[0];
        if (result.n128_f32[0] < a1[1].n128_f32[0])
        {
          __n128 v17 = *a1;
          __n128 result = a1[1];
          __n128 v18 = a2[1];
          *a1 = *a2;
          a1[1] = v18;
          *a2 = v17;
          a2[1] = result;
        }
      }
    }
  }
  return result;
}

float *_ZNSt3__119__partial_sort_implB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_SC_EET1_SD_SD_T2_OT0_(uint64_t a1, float *a2, float *a3, uint64_t a4)
{
  if ((float *)a1 != a2)
  {
    long long v6 = a2;
    uint64_t v8 = (uint64_t)a2 - a1;
    uint64_t v9 = ((uint64_t)a2 - a1) >> 5;
    if ((uint64_t)a2 - a1 >= 33)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      __n128 v12 = (float *)(a1 + 32 * v10);
      do
      {
        _ZNSt3__111__sift_downB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_OT0_NS_15iterator_traitsISD_E15difference_typeESD_(a1, a4, v9, v12);
        v12 -= 8;
        --v11;
      }
      while (v11);
    }
    __n128 v13 = v6;
    if (v6 != a3)
    {
      __n128 v14 = v6;
      do
      {
        if (v14[4] < *(float *)(a1 + 16))
        {
          long long v16 = *(_OWORD *)v14;
          long long v15 = *((_OWORD *)v14 + 1);
          long long v17 = *(_OWORD *)(a1 + 16);
          *(_OWORD *)__n128 v14 = *(_OWORD *)a1;
          *((_OWORD *)v14 + 1) = v17;
          *(_OWORD *)a1 = v16;
          *(_OWORD *)(a1 + 16) = v15;
          _ZNSt3__111__sift_downB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_OT0_NS_15iterator_traitsISD_E15difference_typeESD_(a1, a4, v9, (float *)a1);
        }
        v14 += 8;
      }
      while (v14 != a3);
      __n128 v13 = a3;
    }
    if (v8 >= 33)
    {
      uint64_t v18 = (unint64_t)v8 >> 5;
      do
      {
        uint64_t v19 = 0;
        long long v28 = *(_OWORD *)a1;
        long long v29 = *(_OWORD *)(a1 + 16);
        uint64_t v20 = a1;
        do
        {
          int v21 = (_OWORD *)v20;
          v20 += 32 * (v19 + 1);
          uint64_t v22 = 2 * v19;
          uint64_t v19 = (2 * v19) | 1;
          uint64_t v23 = v22 + 2;
          if (v23 < v18 && *(float *)(v20 + 16) < *(float *)(v20 + 48))
          {
            v20 += 32;
            uint64_t v19 = v23;
          }
          long long v24 = *(_OWORD *)(v20 + 16);
          *int v21 = *(_OWORD *)v20;
          v21[1] = v24;
        }
        while (v19 <= (uint64_t)((unint64_t)(v18 - 2) >> 1));
        v6 -= 8;
        if ((float *)v20 == v6)
        {
          *(_OWORD *)uint64_t v20 = v28;
          *(_OWORD *)(v20 + 16) = v29;
        }
        else
        {
          long long v25 = *((_OWORD *)v6 + 1);
          *(_OWORD *)uint64_t v20 = *(_OWORD *)v6;
          *(_OWORD *)(v20 + 16) = v25;
          *(_OWORD *)long long v6 = v28;
          *((_OWORD *)v6 + 1) = v29;
          _ZNSt3__19__sift_upB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_OT0_NS_15iterator_traitsISD_E15difference_typeE(a1, v20 + 32, a4, (v20 + 32 - a1) >> 5);
        }
      }
      while (v18-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t _ZNSt3__111__sift_downB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_OT0_NS_15iterator_traitsISD_E15difference_typeESD_(uint64_t result, uint64_t a2, uint64_t a3, float *a4)
{
  if (a3 >= 2)
  {
    uint64_t v4 = (uint64_t)a4 - result;
    int64_t v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 5)
    {
      uint64_t v6 = v4 >> 4;
      uint64_t v7 = (v4 >> 4) + 1;
      uint64_t v8 = (float *)(result + 32 * v7);
      uint64_t v9 = v6 + 2;
      if (v9 < a3 && v8[4] < v8[12])
      {
        v8 += 8;
        uint64_t v7 = v9;
      }
      float v10 = a4[4];
      if (v8[4] >= v10)
      {
        long long v15 = *(_OWORD *)a4;
        uint64_t v16 = *(void *)(a4 + 5);
        int v17 = *((_DWORD *)a4 + 7);
        do
        {
          unint64_t v11 = a4;
          a4 = v8;
          long long v12 = *((_OWORD *)v8 + 1);
          *(_OWORD *)unint64_t v11 = *(_OWORD *)v8;
          *((_OWORD *)v11 + 1) = v12;
          if (v5 < v7) {
            break;
          }
          uint64_t v13 = 2 * v7;
          uint64_t v7 = (2 * v7) | 1;
          uint64_t v8 = (float *)(result + 32 * v7);
          uint64_t v14 = v13 + 2;
          if (v14 < a3 && v8[4] < v8[12])
          {
            v8 += 8;
            uint64_t v7 = v14;
          }
        }
        while (v8[4] >= v10);
        *(_OWORD *)a4 = v15;
        a4[4] = v10;
        *(void *)(a4 + 5) = v16;
        *((_DWORD *)a4 + 7) = v17;
      }
    }
  }
  return result;
}

uint64_t _ZNSt3__19__sift_upB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_OT0_NS_15iterator_traitsISD_E15difference_typeE(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4 >= 2)
  {
    unint64_t v4 = (unint64_t)(a4 - 2) >> 1;
    float v5 = *(float *)(a2 - 16);
    if (*(float *)(result + 32 * v4 + 16) < v5)
    {
      uint64_t v6 = a2 - 32;
      long long v9 = *(_OWORD *)(a2 - 32);
      uint64_t v10 = *(void *)(a2 - 12);
      int v11 = *(_DWORD *)(a2 - 4);
      do
      {
        uint64_t v7 = (_OWORD *)v6;
        uint64_t v6 = result + 32 * v4;
        long long v8 = *(_OWORD *)(v6 + 16);
        *uint64_t v7 = *(_OWORD *)v6;
        v7[1] = v8;
        if (!v4) {
          break;
        }
        unint64_t v4 = (v4 - 1) >> 1;
      }
      while (*(float *)(result + 32 * v4 + 16) < v5);
      *(_OWORD *)uint64_t v6 = v9;
      *(float *)(v6 + 16) = v5;
      *(void *)(v6 + 20) = v10;
      *(_DWORD *)(v6 + 28) = v11;
    }
  }
  return result;
}

uint64_t _ZN2CI11Perspective9NMSimplexIDv2_fEC2ENS0_8NMParamsEU13block_pointerFfRKS2_EPS5_m(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  long long v11 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v11;
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 40) = 0;
  long long v12 = (char **)(a1 + 40);
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  std::vector<CI::Perspective::Line>::reserve((void **)(a1 + 40), a5);
  if (a5)
  {
    uint64_t v13 = 0;
    do
    {
      uint64_t v14 = *(void *)(a4 + 8 * v13);
      float v15 = (*(float (**)(uint64_t))(a3 + 16))(a3);
      float v16 = v15;
      unint64_t v18 = *(void *)(a1 + 48);
      unint64_t v17 = *(void *)(a1 + 56);
      if (v18 >= v17)
      {
        uint64_t v20 = (uint64_t)(v18 - (void)*v12) >> 4;
        unint64_t v21 = v20 + 1;
        if ((unint64_t)(v20 + 1) >> 60) {
          abort();
        }
        uint64_t v22 = v17 - (void)*v12;
        if (v22 >> 3 > v21) {
          unint64_t v21 = v22 >> 3;
        }
        if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v23 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v23 = v21;
        }
        if (v23) {
          long long v24 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::Perspective::Line>>(a1 + 56, v23);
        }
        else {
          long long v24 = 0;
        }
        long long v25 = (float *)&v24[16 * v20];
        *(void *)long long v25 = v14;
        v25[2] = v16;
        CGFloat v27 = *(char **)(a1 + 40);
        long long v26 = *(char **)(a1 + 48);
        long long v28 = v25;
        if (v26 != v27)
        {
          do
          {
            *((_OWORD *)v28 - 1) = *((_OWORD *)v26 - 1);
            v28 -= 4;
            v26 -= 16;
          }
          while (v26 != v27);
          long long v26 = *v12;
        }
        uint64_t v19 = (char *)(v25 + 4);
        *(void *)(a1 + 40) = v28;
        *(void *)(a1 + 48) = v25 + 4;
        *(void *)(a1 + 56) = &v24[16 * v23];
        if (v26) {
          operator delete(v26);
        }
      }
      else
      {
        *(void *)unint64_t v18 = v14;
        *(float *)(v18 + 8) = v15;
        uint64_t v19 = (char *)(v18 + 16);
      }
      *(void *)(a1 + 48) = v19;
      ++v13;
    }
    while (v13 != a5);
  }
  for (*(void *)(a1 + 64) = 1;
        (_ZNK2CI11Perspective9NMSimplexIDv2_fE15shouldTerminateEv(a1) & 1) == 0;
        ++*(void *)(a1 + 64))
  {
    unint64_t v30 = *(__n128 **)(a1 + 40);
    uint64_t v31 = *(__n128 **)(a1 + 48);
    unint64_t v32 = 126 - 2 * __clz(v31 - v30);
    if (v31 == v30) {
      uint64_t v33 = 0;
    }
    else {
      uint64_t v33 = v32;
    }
    _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_Lb0EEEvT1_SD_T0_NS_15iterator_traitsISD_E15difference_typeEb(v30, v31, (uint64_t)&v59, v33, 1);
    float32x4_t v36 = *(float32x2_t **)(a1 + 40);
    uint64_t v35 = *(void *)(a1 + 48);
    uint64_t v37 = (v35 - (uint64_t)v36) >> 4;
    float32x2_t v38 = 0;
    unint64_t v39 = v37 - 1;
    if (v37 != 1)
    {
      float32x4_t v40 = *(float32x2_t **)(a1 + 40);
      uint64_t v41 = v37 - 1;
      do
      {
        float32x2_t v42 = *v40;
        v40 += 2;
        v34.i32[1] = v42.i32[1];
        float32x2_t v38 = vadd_f32(v38, v42);
        --v41;
      }
      while (v41);
    }
    *(float *)v34.i32 = (float)v39;
    float32x2_t v43 = vdiv_f32(v38, (float32x2_t)vdup_lane_s32(v34, 0));
    float32x2_t v59 = 0;
    int8x8_t v44 = (int8x8_t)vmla_n_f32(v43, vsub_f32(v43, *(float32x2_t *)(v35 - 16)), *(float *)a1);
    float32x2_t v59 = (float32x2_t)v44;
    v5.i32[0] = (*(float (**)(uint64_t, float32x2_t *))(a3 + 16))(a3, &v59);
    float32x4_t v45 = (int8x8_t *)&v36[2 * v39];
    float v46 = v36[1].f32[0];
    if (v46 <= v5.f32[0] && v5.f32[0] < v36[2 * v37 - 3].f32[0])
    {
      *float32x4_t v45 = v44;
      v45[1].i32[0] = v5.i32[0];
    }
    else
    {
      if (v5.f32[0] >= v46)
      {
        float32x2_t v58 = 0;
        float32x2_t v50 = vmla_n_f32(v43, vsub_f32(*(float32x2_t *)(*(void *)(a1 + 48) - 16), v43), *(float *)(a1 + 8));
        float32x2_t v58 = v50;
        *(float *)&double v49 = (*(float (**)(uint64_t, float32x2_t *))(a3 + 16))(a3, &v58);
        if (*(float *)&v49 >= v36[2 * v39 + 1].f32[0])
        {
          uint64_t v51 = *(void *)(a1 + 40);
          if ((unint64_t)(*(void *)(a1 + 48) - v51) >= 0x11)
          {
            uint64_t v52 = 0;
            float32x2_t v5 = *v36;
            unint64_t v53 = 1;
            do
            {
              float32x2_t v57 = 0;
              float32x2_t v54 = vmla_n_f32(v5, vsub_f32(*(float32x2_t *)(v51 + v52 + 16), v5), *(float *)(a2 + 12));
              float32x2_t v57 = v54;
              float v55 = (*(float (**)(uint64_t, float32x2_t *))(a3 + 16))(a3, &v57);
              long long v56 = (float32x2_t *)(*(void *)(a1 + 40) + v52);
              v56[2] = v54;
              v56[3].f32[0] = v55;
              ++v53;
              uint64_t v51 = *(void *)(a1 + 40);
              v52 += 16;
            }
            while (v53 < (*(void *)(a1 + 48) - v51) >> 4);
          }
          continue;
        }
        *float32x4_t v45 = (int8x8_t)v50;
      }
      else
      {
        int8x8_t v48 = (int8x8_t)vmla_n_f32(v43, vsub_f32(v59, v43), *(float *)(a1 + 4));
        float32x2_t v58 = (float32x2_t)v48;
        double v49 = (*(double (**)(uint64_t, float32x2_t *))(a3 + 16))(a3, &v58);
        *float32x4_t v45 = vbsl_s8((int8x8_t)vdup_lane_s32(vcgt_f32(v5, *(float32x2_t *)&v49), 0), v48, v44);
        if (*(float *)&v49 >= v5.f32[0]) {
          *(float *)&double v49 = v5.f32[0];
        }
      }
      v45[1].i32[0] = LODWORD(v49);
    }
    v45[1].i32[1] = 0;
  }
  return a1;
}

void sub_19380CA78(_Unwind_Exception *exception_object)
{
  unint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 48) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t _ZNK2CI11Perspective9NMSimplexIDv2_fE15shouldTerminateEv(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 24);
  if (v1 && *(void *)(a1 + 64) >= v1) {
    return 1;
  }
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = *(void *)(a1 + 48);
  if (v2 == v3)
  {
    float v6 = (float)(unint64_t)((v3 - v2) >> 4);
  }
  else
  {
    float v4 = 0.0;
    uint64_t v5 = *(void *)(a1 + 40);
    do
    {
      float v4 = v4 + *(float *)(v5 + 8);
      v5 += 16;
    }
    while (v5 != v3);
    float v6 = (float)(unint64_t)((v3 - v2) >> 4);
    if (v3 != v2)
    {
      float v7 = 0.0;
      float v8 = v4 / v6;
      do
      {
        float v7 = v7 + (float)((float)(*(float *)(v2 + 8) - v8) * (float)(*(float *)(v2 + 8) - v8));
        v2 += 16;
      }
      while (v2 != v3);
      return sqrtf(v7 / v6) < *(float *)(a1 + 16);
    }
  }
  float v7 = 0.0;
  return sqrtf(v7 / v6) < *(float *)(a1 + 16);
}

void _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_Lb0EEEvT1_SD_T0_NS_15iterator_traitsISD_E15difference_typeEb(__n128 *a1, __n128 *a2, uint64_t a3, uint64_t a4, char a5)
{
uint64_t _ZNSt3__116__insertion_sortB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_T0_(uint64_t result, void *a2)
{
  if ((void *)result != a2)
  {
    uint64_t v2 = (void *)(result + 16);
    if ((void *)(result + 16) != a2)
    {
      uint64_t v3 = 0;
      float v4 = (float *)result;
      do
      {
        char v5 = v2;
        float v6 = v4[6];
        if (v6 < v4[2])
        {
          uint64_t v7 = *v2;
          int v8 = *((_DWORD *)v4 + 7);
          uint64_t v9 = v3;
          while (1)
          {
            *(_OWORD *)(result + v9 + 16) = *(_OWORD *)(result + v9);
            if (!v9) {
              break;
            }
            float v10 = *(float *)(result + v9 - 8);
            v9 -= 16;
            if (v6 >= v10)
            {
              uint64_t v11 = result + v9 + 16;
              goto LABEL_10;
            }
          }
          uint64_t v11 = result;
LABEL_10:
          *(void *)uint64_t v11 = v7;
          *(float *)(v11 + 8) = v6;
          *(_DWORD *)(v11 + 12) = v8;
        }
        uint64_t v2 = v5 + 2;
        v3 += 16;
        float v4 = (float *)v5;
      }
      while (v5 + 2 != a2);
    }
  }
  return result;
}

void *_ZNSt3__126__insertion_sort_unguardedB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_T0_(void *result, void *a2)
{
  if (result != a2)
  {
    uint64_t v2 = result + 2;
    while (v2 != a2)
    {
      uint64_t v3 = v2;
      float v4 = *((float *)result + 6);
      if (v4 < *((float *)result + 2))
      {
        uint64_t v5 = *v2;
        int v6 = *((_DWORD *)result + 7);
        uint64_t v7 = v3;
        do
        {
          *(_OWORD *)uint64_t v7 = *((_OWORD *)v7 - 1);
          float v8 = *((float *)v7 - 6);
          v7 -= 2;
        }
        while (v4 < v8);
        *uint64_t v7 = v5;
        *((float *)v7 + 2) = v4;
        *((_DWORD *)v7 + 3) = v6;
      }
      uint64_t v2 = v3 + 2;
      __n128 result = v3;
    }
  }
  return result;
}

uint64_t _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_(float *a1, float *a2, float *a3)
{
  float v3 = a2[2];
  float v4 = a3[2];
  if (v3 < a1[2])
  {
    if (v4 < v3)
    {
      long long v5 = *(_OWORD *)a1;
      *(_OWORD *)a1 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v5;
      return 1;
    }
    long long v8 = *(_OWORD *)a1;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_OWORD *)a2 = v8;
    if (a3[2] >= a2[2]) {
      return 1;
    }
    long long v9 = *(_OWORD *)a2;
    *(_OWORD *)a2 = *(_OWORD *)a3;
    *(_OWORD *)a3 = v9;
    return 2;
  }
  if (v4 < v3)
  {
    long long v6 = *(_OWORD *)a2;
    *(_OWORD *)a2 = *(_OWORD *)a3;
    *(_OWORD *)a3 = v6;
    if (a2[2] >= a1[2]) {
      return 1;
    }
    long long v7 = *(_OWORD *)a1;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_OWORD *)a2 = v7;
    return 2;
  }
  return 0;
}

unint64_t _ZNSt3__131__partition_with_equals_on_leftB8nn180100INS_17_ClassicAlgPolicyEPN2CI11Perspective9NMSimplexIDv2_fE8NMVertexERZNS6_13orderVerticesEvEUlRKS7_SA_E_EET0_SD_SD_T1_(float *a1, float *a2)
{
  float v2 = a1[2];
  if (v2 >= *(a2 - 2))
  {
    unint64_t v6 = (unint64_t)(a1 + 4);
    do
    {
      unint64_t v4 = v6;
      if (v6 >= (unint64_t)a2) {
        break;
      }
      float v7 = *(float *)(v6 + 8);
      v6 += 16;
    }
    while (v2 >= v7);
  }
  else
  {
    float v3 = a1;
    do
    {
      unint64_t v4 = (unint64_t)(v3 + 4);
      float v5 = v3[6];
      v3 += 4;
    }
    while (v2 >= v5);
  }
  if (v4 >= (unint64_t)a2)
  {
    long long v8 = a2;
  }
  else
  {
    do
    {
      long long v8 = a2 - 4;
      float v9 = *(a2 - 2);
      a2 -= 4;
    }
    while (v2 < v9);
  }
  uint64_t v10 = *(void *)a1;
  int v11 = *((_DWORD *)a1 + 3);
  while (v4 < (unint64_t)v8)
  {
    long long v15 = *(_OWORD *)v4;
    *(_OWORD *)unint64_t v4 = *(_OWORD *)v8;
    *(_OWORD *)long long v8 = v15;
    do
    {
      float v12 = *(float *)(v4 + 24);
      v4 += 16;
    }
    while (v2 >= v12);
    do
    {
      float v13 = *(v8 - 2);
      v8 -= 4;
    }
    while (v2 < v13);
  }
  if ((float *)(v4 - 16) != a1) {
    *(_OWORD *)a1 = *(_OWORD *)(v4 - 16);
  }
  *(void *)(v4 - 16) = v10;
  *(float *)(v4 - 8) = v2;
  *(_DWORD *)(v4 - 4) = v11;
  return v4;
}

unint64_t _ZNSt3__132__partition_with_equals_on_rightB8nn180100INS_17_ClassicAlgPolicyEPN2CI11Perspective9NMSimplexIDv2_fE8NMVertexERZNS6_13orderVerticesEvEUlRKS7_SA_E_EENS_4pairIT0_bEESE_SE_T1_(float *a1, float *a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = *(void *)a1;
  float v4 = a1[2];
  int v5 = *((_DWORD *)a1 + 3);
  do
  {
    float v6 = a1[v2 + 6];
    v2 += 4;
  }
  while (v6 < v4);
  unint64_t v7 = (unint64_t)&a1[v2];
  if (v2 == 4)
  {
    while (v7 < (unint64_t)a2)
    {
      long long v8 = a2 - 4;
      float v10 = *(a2 - 2);
      a2 -= 4;
      if (v10 < v4) {
        goto LABEL_9;
      }
    }
    long long v8 = a2;
  }
  else
  {
    do
    {
      long long v8 = a2 - 4;
      float v9 = *(a2 - 2);
      a2 -= 4;
    }
    while (v9 >= v4);
  }
LABEL_9:
  unint64_t v11 = (unint64_t)&a1[v2];
  if (v7 < (unint64_t)v8)
  {
    float v12 = v8;
    do
    {
      long long v13 = *(_OWORD *)v11;
      *(_OWORD *)unint64_t v11 = *(_OWORD *)v12;
      *(_OWORD *)float v12 = v13;
      do
      {
        float v14 = *(float *)(v11 + 24);
        v11 += 16;
      }
      while (v14 < v4);
      do
      {
        float v15 = *(v12 - 2);
        v12 -= 4;
      }
      while (v15 >= v4);
    }
    while (v11 < (unint64_t)v12);
  }
  if ((float *)(v11 - 16) != a1) {
    *(_OWORD *)a1 = *(_OWORD *)(v11 - 16);
  }
  *(void *)(v11 - 16) = v3;
  *(float *)(v11 - 8) = v4;
  *(_DWORD *)(v11 - 4) = v5;
  return v11 - 16;
}

BOOL _ZNSt3__127__insertion_sort_incompleteB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEbT1_SD_T0_(__n128 *a1, __n128 *a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (a2[-1].n128_f32[2] < a1->n128_f32[2])
      {
        __n128 v6 = *a1;
        *a1 = a2[-1];
        a2[-1] = v6;
      }
      return result;
    case 3:
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_((float *)a1, (float *)&a1[1], (float *)&a2[-1]);
      return 1;
    case 4:
      _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_SD_SD_T0_((float *)a1, (uint64_t)&a1[1], (uint64_t)&a1[2], (uint64_t)&a2[-1]);
      return 1;
    case 5:
      _ZNSt3__17__sort5B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_SD_SD_SD_T0_((float *)a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      unint64_t v7 = a1 + 2;
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_((float *)a1, (float *)&a1[1], (float *)&a1[2]);
      long long v8 = a1 + 3;
      if (&a1[3] == a2) {
        return 1;
      }
      uint64_t v9 = 0;
      int v10 = 0;
      break;
  }
  while (1)
  {
    float v11 = v8->n128_f32[2];
    if (v11 < v7->n128_f32[2])
    {
      unint64_t v12 = v8->n128_u64[0];
      unsigned __int32 v13 = v8->n128_u32[3];
      uint64_t v14 = v9;
      while (1)
      {
        *(__n128 *)((char *)a1 + v14 + 48) = *(__n128 *)((char *)a1 + v14 + 32);
        if (v14 == -32) {
          break;
        }
        float v15 = *(float *)((char *)&a1[1].n128_f32[2] + v14);
        v14 -= 16;
        if (v11 >= v15)
        {
          uint64_t v16 = (uint64_t)&a1[3] + v14;
          goto LABEL_12;
        }
      }
      uint64_t v16 = (uint64_t)a1;
LABEL_12:
      *(void *)uint64_t v16 = v12;
      *(float *)(v16 + 8) = v11;
      *(_DWORD *)(v16 + 12) = v13;
      if (++v10 == 8) {
        return &v8[1] == a2;
      }
    }
    unint64_t v7 = v8;
    v9 += 16;
    if (++v8 == a2) {
      return 1;
    }
  }
}

__n128 _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_SD_SD_T0_(float *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_(a1, (float *)a2, (float *)a3);
  result.n128_u32[0] = *(_DWORD *)(a4 + 8);
  if (result.n128_f32[0] < *(float *)(a3 + 8))
  {
    __n128 result = *(__n128 *)a3;
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(__n128 *)a4 = result;
    result.n128_u32[0] = *(_DWORD *)(a3 + 8);
    if (result.n128_f32[0] < *(float *)(a2 + 8))
    {
      __n128 result = *(__n128 *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(__n128 *)a3 = result;
      result.n128_u32[0] = *(_DWORD *)(a2 + 8);
      if (result.n128_f32[0] < a1[2])
      {
        __n128 result = *(__n128 *)a1;
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

__n128 _ZNSt3__17__sort5B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_SD_SD_SD_T0_(float *a1, __n128 *a2, __n128 *a3, __n128 *a4, __n128 *a5)
{
  __n128 result = _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_SD_SD_T0_(a1, (uint64_t)a2, (uint64_t)a3, (uint64_t)a4);
  result.n128_u32[0] = a5->n128_u32[2];
  if (result.n128_f32[0] < a4->n128_f32[2])
  {
    __n128 result = *a4;
    *a4 = *a5;
    *a5 = result;
    result.n128_u32[0] = a4->n128_u32[2];
    if (result.n128_f32[0] < a3->n128_f32[2])
    {
      __n128 result = *a3;
      *a3 = *a4;
      *a4 = result;
      result.n128_u32[0] = a3->n128_u32[2];
      if (result.n128_f32[0] < a2->n128_f32[2])
      {
        __n128 result = *a2;
        *a2 = *a3;
        *a3 = result;
        result.n128_u32[0] = a2->n128_u32[2];
        if (result.n128_f32[0] < a1[2])
        {
          __n128 result = *(__n128 *)a1;
          *(__n128 *)a1 = *a2;
          *a2 = result;
        }
      }
    }
  }
  return result;
}

float *_ZNSt3__119__partial_sort_implB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_SC_EET1_SD_SD_T2_OT0_(float *a1, float *a2, float *a3, uint64_t a4)
{
  if (a1 != a2)
  {
    __n128 v6 = a2;
    uint64_t v8 = (char *)a2 - (char *)a1;
    uint64_t v9 = ((char *)a2 - (char *)a1) >> 4;
    if ((char *)a2 - (char *)a1 >= 17)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      unint64_t v12 = &a1[4 * v10];
      do
      {
        _ZNSt3__111__sift_downB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_OT0_NS_15iterator_traitsISD_E15difference_typeESD_((uint64_t)a1, a4, v9, v12);
        v12 -= 4;
        --v11;
      }
      while (v11);
    }
    unsigned __int32 v13 = v6;
    if (v6 != a3)
    {
      uint64_t v14 = v6;
      do
      {
        if (v14[2] < a1[2])
        {
          long long v15 = *(_OWORD *)v14;
          *(_OWORD *)uint64_t v14 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v15;
          _ZNSt3__111__sift_downB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_OT0_NS_15iterator_traitsISD_E15difference_typeESD_((uint64_t)a1, a4, v9, a1);
        }
        v14 += 4;
      }
      while (v14 != a3);
      unsigned __int32 v13 = a3;
    }
    if (v8 >= 17)
    {
      uint64_t v16 = (unint64_t)v8 >> 4;
      do
      {
        uint64_t v17 = 0;
        long long v24 = *(_OWORD *)a1;
        unint64_t v18 = a1;
        do
        {
          char v19 = v18;
          v18 += 4 * v17 + 4;
          uint64_t v20 = 2 * v17;
          uint64_t v17 = (2 * v17) | 1;
          uint64_t v21 = v20 + 2;
          if (v21 < v16 && v18[2] < v18[6])
          {
            v18 += 4;
            uint64_t v17 = v21;
          }
          *(_OWORD *)char v19 = *(_OWORD *)v18;
        }
        while (v17 <= (uint64_t)((unint64_t)(v16 - 2) >> 1));
        v6 -= 4;
        if (v18 == v6)
        {
          *(_OWORD *)unint64_t v18 = v24;
        }
        else
        {
          *(_OWORD *)unint64_t v18 = *(_OWORD *)v6;
          *(_OWORD *)__n128 v6 = v24;
          _ZNSt3__19__sift_upB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_OT0_NS_15iterator_traitsISD_E15difference_typeE((uint64_t)a1, (uint64_t)(v18 + 4), a4, ((char *)(v18 + 4) - (char *)a1) >> 4);
        }
      }
      while (v16-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t _ZNSt3__111__sift_downB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_OT0_NS_15iterator_traitsISD_E15difference_typeESD_(uint64_t result, uint64_t a2, uint64_t a3, float *a4)
{
  if (a3 >= 2)
  {
    uint64_t v4 = (uint64_t)a4 - result;
    int64_t v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 4)
    {
      uint64_t v6 = v4 >> 3;
      uint64_t v7 = (v4 >> 3) + 1;
      uint64_t v8 = (float *)(result + 16 * v7);
      uint64_t v9 = v6 + 2;
      if (v9 < a3 && v8[2] < v8[6])
      {
        v8 += 4;
        uint64_t v7 = v9;
      }
      float v10 = a4[2];
      if (v8[2] >= v10)
      {
        uint64_t v11 = *(void *)a4;
        int v12 = *((_DWORD *)a4 + 3);
        do
        {
          unsigned __int32 v13 = a4;
          a4 = v8;
          *(_OWORD *)unsigned __int32 v13 = *(_OWORD *)v8;
          if (v5 < v7) {
            break;
          }
          uint64_t v14 = 2 * v7;
          uint64_t v7 = (2 * v7) | 1;
          uint64_t v8 = (float *)(result + 16 * v7);
          uint64_t v15 = v14 + 2;
          if (v15 < a3 && v8[2] < v8[6])
          {
            v8 += 4;
            uint64_t v7 = v15;
          }
        }
        while (v8[2] >= v10);
        *(void *)a4 = v11;
        a4[2] = v10;
        *((_DWORD *)a4 + 3) = v12;
      }
    }
  }
  return result;
}

uint64_t _ZNSt3__19__sift_upB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_OT0_NS_15iterator_traitsISD_E15difference_typeE(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4 >= 2)
  {
    unint64_t v4 = (unint64_t)(a4 - 2) >> 1;
    float v5 = *(float *)(a2 - 8);
    if (*(float *)(result + 16 * v4 + 8) < v5)
    {
      uint64_t v7 = *(void *)(a2 - 16);
      uint64_t v6 = a2 - 16;
      uint64_t v8 = v7;
      int v9 = *(_DWORD *)(v6 + 12);
      do
      {
        float v10 = (_OWORD *)v6;
        uint64_t v6 = result + 16 * v4;
        *float v10 = *(_OWORD *)v6;
        if (!v4) {
          break;
        }
        unint64_t v4 = (v4 - 1) >> 1;
      }
      while (*(float *)(result + 16 * v4 + 8) < v5);
      *(void *)uint64_t v6 = v8;
      *(float *)(v6 + 8) = v5;
      *(_DWORD *)(v6 + 12) = v9;
    }
  }
  return result;
}

CIImage *perspectiveTransformImage(CIImage *a1, simd::float3x3 a2)
{
  v34[3] = *MEMORY[0x1E4F143B8];
  {
    simd::float3x3 v30 = a2;
    a2 = v30;
    if (v28)
    {
      perspectiveTransformImage(CIImage *,simd::float3x3)::I = xmmword_193954F70;
      *(_OWORD *)algn_1E9333510 = xmmword_193954F80;
      xmmword_1E9333520 = xmmword_193954F90;
      a2 = v30;
    }
  }
  float32x4_t v3 = (float32x4_t)vdupq_n_s32(0x358637BDu);
  uint32x4_t v4 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v3, vabdq_f32((float32x4_t)a2.columns[1], *(float32x4_t *)algn_1E9333510)), (int8x16_t)vcgeq_f32(v3, vabdq_f32((float32x4_t)a2.columns[0], (float32x4_t)perspectiveTransformImage(CIImage *,simd::float3x3)::I))), (int8x16_t)vcgeq_f32(v3, vabdq_f32((float32x4_t)a2.columns[2], (float32x4_t)xmmword_1E9333520)));
  v4.i32[3] = v4.i32[2];
  if ((vminvq_u32(v4) & 0x80000000) == 0)
  {
    simd::float3x3 v29 = a2;
    float v5 = +[CIKernel kernelWithInternalRepresentation:&CI::_perspectiveWarp];
    [(CIImage *)a1 extent];
    *(float *)&double v6 = v6;
    v8.f64[1] = v7;
    *(float *)&double v9 = v9;
    float32x4_t v10 = vmulq_n_f32((float32x4_t)v29.columns[0], *(float *)&v6);
    HIDWORD(v6) = LODWORD(v9);
    float32x2_t v11 = vadd_f32(*(float32x2_t *)&v6, vcvt_f32_f64(v8));
    int32x4_t v12 = (int32x4_t)vaddq_f32((float32x4_t)v29.columns[2], vmlaq_n_f32(v10, (float32x4_t)v29.columns[1], *(float *)&v9));
    float32x4_t v13 = vmulq_n_f32((float32x4_t)v29.columns[0], v11.f32[0]);
    int32x4_t v14 = (int32x4_t)vaddq_f32((float32x4_t)v29.columns[2], vmlaq_n_f32(v13, (float32x4_t)v29.columns[1], *(float *)&v9));
    *(float32x2_t *)v12.i8 = vdiv_f32(*(float32x2_t *)v12.i8, (float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v12, 2));
    int32x4_t v15 = (int32x4_t)vaddq_f32((float32x4_t)v29.columns[2], vmlaq_lane_f32(v13, (float32x4_t)v29.columns[1], v11, 1));
    *(float32x2_t *)v15.i8 = vdiv_f32(*(float32x2_t *)v15.i8, (float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v15, 2));
    int32x4_t v16 = (int32x4_t)vaddq_f32((float32x4_t)v29.columns[2], vmlaq_lane_f32(v10, (float32x4_t)v29.columns[1], v11, 1));
    v12.u64[1] = (unint64_t)vdiv_f32(*(float32x2_t *)v14.i8, (float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v14, 2));
    v15.u64[1] = (unint64_t)vdiv_f32(*(float32x2_t *)v16.i8, (float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v16, 2));
    v33[0] = v12;
    v33[1] = v15;
    float32x2_t v17 = CI::Perspective::bbox((float32x2_t *)v33);
    double v18 = v17.f32[0];
    double v19 = v17.f32[1];
    double v21 = v20;
    v31[0] = MEMORY[0x1E4F143A8];
    v31[1] = 3221225472;
    v31[2] = ___ZL25perspectiveTransformImageP7CIImageN4simd8float3x3E_block_invoke;
    v31[3] = &__block_descriptor_80_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
    double v23 = v22;
    simd::float3x3 v32 = v29;
    simd_float3x3 v35 = __invert_f3(v29.simd_float3x3);
    v29.columns[0].i32[2] = v35.columns[0].i32[2];
    v29.columns[1] = v35.columns[1];
    v29.columns[2] = v35.columns[2];
    long long v24 = +[CIVector vectorWithX:Y:Z:](CIVector, "vectorWithX:Y:Z:", v35.columns[0].f32[0], v35.columns[1].f32[0], v35.columns[2].f32[0], v35.columns[0].i64[0]);
    long long v25 = +[CIVector vectorWithX:v29.columns[0].f32[1] Y:v29.columns[1].f32[1] Z:v29.columns[2].f32[1]];
    long long v26 = +[CIVector vectorWithX:v29.columns[0].f32[2] Y:v29.columns[1].f32[2] Z:v29.columns[2].f32[2]];
    v34[0] = v24;
    v34[1] = v25;
    v34[2] = v26;
    return -[CIWarpKernel applyWithExtent:roiCallback:inputImage:arguments:](v5, "applyWithExtent:roiCallback:inputImage:arguments:", v31, a1, [MEMORY[0x1E4F1C978] arrayWithObjects:v34 count:3], v18, v19, v21, v23);
  }
  return a1;
}

double ___ZL25perspectiveTransformImageP7CIImageN4simd8float3x3E_block_invoke(uint64_t a1, double a2, double a3, float64x2_t a4, float64_t a5)
{
  *(float *)&unsigned int v5 = a2;
  *(float *)&unsigned int v6 = a3;
  float v11 = *(float *)&v5;
  float v12 = *(float *)&v6;
  a4.f64[1] = a5;
  float32x2_t v13 = vadd_f32((float32x2_t)__PAIR64__(v6, v5), vcvt_f32_f64(a4));
  simd_float3x3 v15 = __invert_f3(*(simd_float3x3 *)(a1 + 32));
  float32x4_t v7 = vmulq_n_f32((float32x4_t)v15.columns[0], v11);
  int32x4_t v8 = (int32x4_t)vaddq_f32((float32x4_t)v15.columns[2], vmlaq_n_f32(v7, (float32x4_t)v15.columns[1], v12));
  v15.columns[0] = (simd_float3)vmulq_n_f32((float32x4_t)v15.columns[0], v13.f32[0]);
  int32x4_t v9 = (int32x4_t)vaddq_f32((float32x4_t)v15.columns[2], vmlaq_n_f32((float32x4_t)v15.columns[0], (float32x4_t)v15.columns[1], v12));
  *(float32x2_t *)v8.i8 = vdiv_f32(*(float32x2_t *)v8.i8, (float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v8, 2));
  v15.columns[0] = (simd_float3)vaddq_f32((float32x4_t)v15.columns[2], vmlaq_lane_f32((float32x4_t)v15.columns[0], (float32x4_t)v15.columns[1], v13, 1));
  *(float32x2_t *)v15.columns[0].f32 = vdiv_f32(*(float32x2_t *)v15.columns[0].f32, (float32x2_t)*(_OWORD *)&vdupq_laneq_s32((int32x4_t)v15.columns[0], 2));
  v15.columns[1] = (simd_float3)vaddq_f32((float32x4_t)v15.columns[2], vmlaq_lane_f32(v7, (float32x4_t)v15.columns[1], v13, 1));
  v8.u64[1] = (unint64_t)vdiv_f32(*(float32x2_t *)v9.i8, (float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v9, 2));
  *(float32x2_t *)&v15.columns[0].u32[2] = vdiv_f32(*(float32x2_t *)v15.columns[1].f32, (float32x2_t)*(_OWORD *)&vdupq_laneq_s32((int32x4_t)v15.columns[1], 2));
  v14[0] = v8;
  v14[1] = v15.columns[0];
  return CI::Perspective::bbox((float32x2_t *)v14).f32[0];
}

float32x2_t cikernel::_perspectiveWarp(CI *a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  DC = (uint64_t *)CI::getDC(a1);
  __asm { FMOV            V1.4S, #1.0 }
  _Q1.i64[0] = *DC;
  int32x4_t v10 = (int32x4_t)vmulq_f32(a2, _Q1);
  int32x4_t v11 = (int32x4_t)vmulq_f32(a3, _Q1);
  int32x4_t v12 = (int32x4_t)vmulq_f32(a4, _Q1);
  return vdiv_f32((float32x2_t)vzip1_s32((int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v10, 2), vadd_f32(*(float32x2_t *)v10.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v10.i8, 1))), (int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v11, 2), vadd_f32(*(float32x2_t *)v11.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v11.i8, 1)))), (float32x2_t)vdup_lane_s32((int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v12, 2), vadd_f32(*(float32x2_t *)v12.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v12.i8, 1))), 0));
}

void CI::f2_f3_f3_f3(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int32x4_t v10 = (void *)a1[6];
  int32x4_t v11 = (double (*)(void *, __n128, __n128, __n128))a1[3];
  uint64_t v12 = v10[1];
  uint64_t v13 = v10[4];
  uint64_t v14 = v10[7];
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * v10[10]), a2);
  }
  *(double *)(a3 + 16 * a7) = v11(a1, *((__n128 *)a2 + 4 * v12), *((__n128 *)a2 + 4 * v13), *((__n128 *)a2 + 4 * v14));
}

double computeHomogeneousPerspectiveTransformAndInverse(double *a1, uint64_t a2, double a3, float32x2_t a4, float32x2_t a5, float32x2_t a6)
{
  float32x2_t v6 = vsub_f32(vadd_f32(vsub_f32(*(float32x2_t *)&a3, a4), a5), a6);
  int32x2_t v7 = vceqz_f32(v6);
  if (v7.i32[0] & v7.i32[1])
  {
    _Q4 = vcvtq_f64_f32(vsub_f32(a4, *(float32x2_t *)&a3));
    float64x2_t v9 = vcvtq_f64_f32(vsub_f32(a5, a4));
    double v10 = 0.0;
    _D5 = 0.0;
  }
  else
  {
    float32x2_t v12 = vsub_f32(a6, a5);
    float32x2_t v13 = vsub_f32(a4, a5);
    double v14 = vmlas_n_f32((float)-v13.f32[1] * v12.f32[0], v12.f32[1], v13.f32[0]);
    double v10 = vmlas_n_f32((float)-v6.f32[1] * v12.f32[0], v12.f32[1], v6.f32[0]) / v14;
    _D5 = vmlas_n_f32((float)-v13.f32[1] * v6.f32[0], v6.f32[1], v13.f32[0]) / v14;
    _Q4 = vmlaq_n_f64(vcvtq_f64_f32(vsub_f32(a4, *(float32x2_t *)&a3)), vcvtq_f64_f32(a4), v10);
    float64x2_t v9 = vmlaq_n_f64(vcvtq_f64_f32(vsub_f32(a6, *(float32x2_t *)&a3)), vcvtq_f64_f32(a6), _D5);
  }
  double v15 = *((float *)&a3 + 1);
  _D0 = *(float *)&a3;
  *(float64x2_t *)a2 = _Q4;
  *(double *)(a2 + 16) = v10;
  *(float64x2_t *)(a2 + 24) = v9;
  *(double *)(a2 + 40) = _D5;
  *(double *)(a2 + 48) = _D0;
  *(double *)(a2 + 56) = v15;
  *(void *)(a2 + 64) = 0x3FF0000000000000;
  double v17 = -_Q4.f64[1] * v9.f64[0];
  double v18 = -(_Q4.f64[0] * _D5);
  double v19 = v17
      + vmuld_lane_f64(_Q4.f64[0], v9, 1)
      + vmuld_lane_f64(_D5, _Q4, 1) * _D0
      + v10 * v9.f64[0] * v15
      + vmuld_lane_f64(-v10, v9, 1) * _D0
      + v18 * v15;
  *a1 = (v9.f64[1] - _D5 * v15) / v19;
  a1[1] = -(_Q4.f64[1] - v10 * v15) / v19;
  __asm { FMLA            D17, D5, V4.D[1] }
  a1[2] = _D17 / v19;
  a1[3] = -(v9.f64[0] - _D5 * _D0) / v19;
  a1[4] = (_Q4.f64[0] - v10 * _D0) / v19;
  a1[5] = vmlad_n_f64(v18, v10, v9.f64[0]) / v19;
  __asm { FMLA            D2, D0, V4.D[1] }
  a1[6] = vmlad_n_f64(-(v9.f64[1] * _D0), v15, v9.f64[0]) / v19;
  a1[7] = _D2 / v19;
  double result = vmlad_n_f64(v17, v9.f64[1], _Q4.f64[0]) / v19;
  a1[8] = result;
  return result;
}

float32x2_t cikernel::_perspectiveTransform(CI *a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x2_t a5)
{
  DC = (uint64_t *)CI::getDC(a1);
  __asm { FMOV            V1.4S, #1.0 }
  _Q1.i64[0] = *DC;
  int32x4_t v12 = (int32x4_t)vmulq_f32(a2, _Q1);
  int32x4_t v13 = (int32x4_t)vmulq_f32(a3, _Q1);
  float32x4_t v14 = vmulq_f32(a4, _Q1);
  return vadd_f32(a5, vmul_n_f32((float32x2_t)vzip1_s32((int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v12, 2), vadd_f32(*(float32x2_t *)v12.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v12.i8, 1))), (int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v13, 2), vadd_f32(*(float32x2_t *)v13.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v13.i8, 1)))), 1.0/ fmaxf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).f32[0], 0.000001)));
}

void CI::f2_f3_f3_f3_f2(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  int32x4_t v11 = (double (*)(void *, __n128, __n128, __n128, double))a1[3];
  uint64_t v12 = *(void *)(v10 + 8);
  uint64_t v13 = *(void *)(v10 + 32);
  uint64_t v14 = *(void *)(v10 + 56);
  int v15 = *(_DWORD *)(v10 + 88);
  uint64_t v16 = *(void *)(v10 + 80);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 104)), a2);
  }
  double v17 = (double *)(a3 + 16 * v16);
  if (v15 != 5) {
    double v17 = (double *)((char *)a2 + 64 * v16);
  }
  *(double *)(a3 + 16 * a7) = v11(a1, *((__n128 *)a2 + 4 * v12), *((__n128 *)a2 + 4 * v13), *((__n128 *)a2 + 4 * v14), *v17);
}

double cikernel::_perspectiveMask(CI *a1, float32x4_t a2, float32x4_t a3)
{
  DC = (uint64_t *)CI::getDC(a1);
  __asm { FMOV            V1.4S, #1.0 }
  _Q1.i64[0] = *DC;
  float32x4_t v9 = vmulq_f32(a3, _Q1);
  _NF = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2), vaddq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1))).f32[0] < 0.000001;
  double v10 = 1.0;
  if (_NF) {
    double v10 = 0.0;
  }
  float v11 = v10;
  *(void *)&double result = vmulq_n_f32(a2, v11).u64[0];
  return result;
}

void CI::f4_s_f3(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  float v11 = (double (*)(void *, __n128, __n128))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  uint64_t v14 = *(void *)(v10 + 32);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 56)), a2);
  }
  int v15 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    int v15 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v16 = v11(a1, *v15, *((__n128 *)a2 + 4 * v14));
  *(_OWORD *)(a3 + 16 * a7) = v16;
}

float32x2_t cikernel::_perspectiveCorrection(CI *a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  DC = (uint64_t *)CI::getDC(a1);
  __asm { FMOV            V1.4S, #1.0 }
  _Q1.i64[0] = *DC;
  int32x4_t v10 = (int32x4_t)vmulq_f32(a2, _Q1);
  int32x4_t v11 = (int32x4_t)vmulq_f32(a3, _Q1);
  float32x4_t v12 = vmulq_f32(a4, _Q1);
  v12.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))).u64[0];
  v12.f32[0] = fmaxf(v12.f32[0], 0.000001);
  return vdiv_f32((float32x2_t)vzip1_s32((int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v10, 2), vadd_f32(*(float32x2_t *)v10.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v10.i8, 1))), (int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v11, 2), vadd_f32(*(float32x2_t *)v11.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v11.i8, 1)))), (float32x2_t)vdup_lane_s32(*(int32x2_t *)v12.f32, 0));
}

void __Block_byref_object_copy__13(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__13(uint64_t a1)
{
}

void __Block_byref_object_copy__14(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__14(uint64_t a1)
{
}

double cikernel::_photoEffectDepthBlend(float32x4_t a1, float32x4_t a2, float a3, float a4)
{
  float v4 = fminf(a3 + a3, 1.0);
  float32x4_t v5 = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - v4), a2, v4);
  float v6 = a4 + 0.15;
  float v7 = (float)(v4 - a4) / (float)(v6 - a4);
  if (v7 <= 1.0) {
    float v8 = v7;
  }
  else {
    float v8 = 1.0;
  }
  BOOL v9 = v7 < 0.0;
  float v10 = 0.0;
  if (!v9) {
    float v10 = v8;
  }
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - (float)((float)(v10 * v10) * (float)((float)(v10 * -2.0) + 3.0))), v5, (float)(v10 * v10) * (float)((float)(v10 * -2.0) + 3.0)).u64[0];
  return result;
}

double cikernel::_blendGrains(__n128 _Q0, float a2)
{
  double v2 = a2;
  float v3 = v2 * 1.43067656 + -1.43067656;
  float v4 = vmlas_n_f32(vmuls_lane_f32(v3, (float32x2_t)_Q0.n128_u64[0], 1), 1.0 - v3, _Q0.n128_f32[0]);
  float v5 = v2 * 1.10730936 + -1.8812854;
  _S6 = 1.0 - v5;
  __asm { FMLA            S4, S6, V0.S[1] }
  float v12 = v2 * 1.10730936 + -2.8812854;
  _S6 = 1.0 - v12;
  __asm { FMLA            S5, S6, V0.S[2] }
  double v15 = v2 + -1.69897;
  *(float *)&double v15 = v2 + -1.69897;
  *(float *)&double v2 = v2 + -2.60205999;
  if (*(float *)&v2 >= 0.0) {
    float v16 = _S5;
  }
  else {
    float v16 = _S4;
  }
  if (*(float *)&v15 >= 0.0) {
    *(float *)&double v15 = v16;
  }
  else {
    *(float *)&double v15 = v4;
  }
  *(void *)&double result = vdupq_lane_s32(*(int32x2_t *)&v15, 0).u64[0];
  return result;
}

double cikernel::_grainBlendAndMix(float32x4_t a1, float a2, float a3, float a4, int32x2_t a5)
{
  float32x4_t v6 = vmulq_f32(a1, (float32x4_t)vdupq_n_s32(0x3EAAAA9Fu));
  float v7 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), vaddq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1))).f32[0];
  if (v7 <= 1.0) {
    float v8 = v7;
  }
  else {
    float v8 = 1.0;
  }
  if (v7 >= 0.0) {
    float v9 = v8;
  }
  else {
    float v9 = 0.0;
  }
  *(float *)a5.i32 = v9 * -2.0 + 4.01;
  v10.i64[0] = 0x8000000080000000;
  v10.i64[1] = 0x8000000080000000;
  __asm { FMOV            V2.4S, #1.0 }
  int8x16_t v29 = _Q2;
  int32x2_t v30 = a5;
  int8x16_t v16 = vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a1), (int8x16_t)vcgtzq_f32(a1)), vorrq_s8(vandq_s8((int8x16_t)a1, v10), _Q2), (int8x16_t)0);
  float32x4_t v28 = (float32x4_t)v16;
  simd_float4 v17 = (simd_float4)vabsq_f32(a1);
  *(float *)v16.i32 = 1.0 / *(float *)a5.i32;
  v17.i32[3] = 0;
  simd_float4 v18 = (simd_float4)vdupq_lane_s32(*(int32x2_t *)v16.i8, 0);
  v18.i32[3] = 0;
  float32x4_t v19 = (float32x4_t)_simd_pow_f4(v17, v18);
  double v20 = (1.0 - v9) * (float)((float)((float)(a2 + -0.5) * a3) * fmaxf(v9, 0.5));
  *(float *)&double v20 = v20;
  float32x4_t v21 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v20, 0), vmulq_f32(v28, v19));
  v22.i64[0] = 0x8000000080000000;
  v22.i64[1] = 0x8000000080000000;
  float32x4_t v32 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v21), (int8x16_t)vcgtzq_f32(v21)), vorrq_s8(vandq_s8((int8x16_t)v21, v22), v29), (int8x16_t)0);
  simd_float4 v23 = (simd_float4)vabsq_f32(v21);
  v23.i32[3] = 0;
  simd_float4 v24 = (simd_float4)vdupq_lane_s32(v30, 0);
  v24.i32[3] = 0;
  float32x4_t v25 = vmulq_f32((float32x4_t)_simd_pow_f4(v23, v24), v32);
  v25.i32[3] = 0;
  float32x4_t v26 = vminnmq_f32(v25, (float32x4_t)xmmword_1939508C0);
  v26.i32[3] = a1.i32[3];
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - a4), v26, a4).u64[0];
  return result;
}

float32x2_t cikernel::_paddedTile2(CI *a1, int8x16_t a2)
{
  float32x2_t v2 = vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a2, a2, 8uLL), *(float32x2_t *)CI::getDC(a1));
  __asm { FMOV            V1.2S, #1.0 }
  return vadd_f32(vmul_f32(*(float32x2_t *)a2.i8, vminnm_f32(vsub_f32(v2, vrndm_f32(v2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu))), _D1);
}

double map_point_inv(float32x2_t a1, float32x2_t a2, double a3, float a4, double a5, double a6, double a7, double a8)
{
  float32x2_t v9 = a1;
  float32x2_t v10 = vsub_f32(a1, a2);
  *(float *)&a8 = sqrtf(vaddv_f32(vmul_f32(v10, v10)));
  long double v11 = *(float *)&a8;
  if (*(float *)&a8 >= 0.001)
  {
    if (fabsf(a4 + -1.0) >= 0.001)
    {
      double v14 = a4;
      if (a4 >= 1.0 && *(float *)&a8 >= *(float *)&a3)
      {
        float v21 = *(float *)&a3;
        double v15 = pow(v11, v14 / (2.0 - v14));
        long double v16 = pow(v21, v14 / (v14 + -2.0));
        float v17 = v15;
        *(float *)&long double v16 = v16;
        float32x2_t v18 = vmul_n_f32(vmul_n_f32(v10, v17), *(float *)&v16);
LABEL_9:
        float32x2_t v9 = vadd_f32(a2, v18);
        return *(double *)&v9;
      }
      float v19 = ((float)((float)(*(float *)&a3 * a4) * a4)
           + v14 * -2.0 * v11
           + v11 * 2.0
           - sqrt((float)((float)(*(float *)&a3 * a4) * a4) + v14 * -4.0 * v11 + v11 * 4.0)
           * (float)(sqrtf(*(float *)&a3) * a4))
          / ((float)(a4 * a4) + v14 * -2.0 + 1.0 + (float)(a4 * a4) + v14 * -2.0 + 1.0);
      float32x2_t v12 = vmul_n_f32(v10, v19);
      float32x2_t v13 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a8, 0);
    }
    else
    {
      float32x2_t v12 = vmul_n_f32(v10, *(float *)&a8);
      float32x2_t v13 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a3, 0);
    }
    float32x2_t v18 = vdiv_f32(v12, v13);
    goto LABEL_9;
  }
  return *(double *)&v9;
}

double regionOf(CGRect a1, float32x2_t a2, float32_t a3, float a4, float a5)
{
  float v72 = a2.f32[0];
  double height = a1.size.height;
  double width = a1.size.width;
  double y = a1.origin.y;
  CGFloat v71 = a1.origin.y;
  double x = a1.origin.x;
  CGFloat v9 = *MEMORY[0x1E4F1DB20];
  CGFloat v10 = *(double *)(MEMORY[0x1E4F1DB20] + 8);
  a2.f32[1] = a3;
  float32x2_t v82 = a2;
  CGFloat v11 = *(double *)(MEMORY[0x1E4F1DB20] + 16);
  CGFloat v12 = *(double *)(MEMORY[0x1E4F1DB20] + 24);
  v13.f32[0] = a1.origin.x;
  __int32 v77 = v13.i32[0];
  float32_t v14 = a1.origin.y;
  __int32 v75 = LODWORD(v14);
  v13.f32[1] = v14;
  map_point(v13, a2, a5, a4);
  double v16 = unionPointWithRect(v15, v9, v10, v11, v12);
  CGFloat v18 = v17;
  CGFloat v20 = v19;
  CGFloat v22 = v21;
  CGFloat v70 = x;
  *(float *)&double v17 = y + height;
  unsigned int v74 = LODWORD(v17);
  map_point((float32x2_t)__PAIR64__(LODWORD(v17), v77), v82, a5, a4);
  double v24 = unionPointWithRect(v23, v16, v18, v20, v22);
  CGFloat v26 = v25;
  CGFloat v28 = v27;
  CGFloat v30 = v29;
  v31.f32[0] = x + width;
  __int32 v76 = v31.i32[0];
  v31.i32[1] = v75;
  map_point(v31, v82, a5, a4);
  double v33 = unionPointWithRect(v32, v24, v26, v28, v30);
  CGFloat v35 = v34;
  CGFloat v37 = v36;
  CGFloat v39 = v38;
  float v69 = a4;
  CGFloat v40 = width;
  map_point((float32x2_t)__PAIR64__(v74, v76), v82, a5, a4);
  double v42 = unionPointWithRect(v41, v33, v35, v37, v39);
  CGFloat v79 = v43;
  CGFloat v45 = v44;
  CGFloat v47 = v46;
  v83.origin.double x = v70;
  v83.origin.double y = v71;
  v83.size.double width = width;
  v83.size.double height = height;
  if (CGRectGetMinX(v83) < v72)
  {
    v84.origin.double x = v70;
    v84.origin.double y = v71;
    v84.size.double width = width;
    v84.size.double height = height;
    if (CGRectGetMaxX(v84) > v72)
    {
      map_point((float32x2_t)__PAIR64__(v75, v82.u32[0]), v82, a5, a4);
      double v80 = unionPointWithRect(v48, v42, v79, v45, v47);
      CGFloat v50 = v49;
      CGFloat v52 = v51;
      CGFloat v54 = v53;
      CGFloat v40 = width;
      map_point((float32x2_t)__PAIR64__(v74, v82.u32[0]), v82, a5, a4);
      double v42 = unionPointWithRect(v55, v80, v50, v52, v54);
      CGFloat v79 = v56;
      CGFloat v45 = v57;
      CGFloat v47 = v58;
    }
  }
  v85.origin.double x = v70;
  v85.origin.double y = v71;
  v85.size.double width = v40;
  v85.size.double height = height;
  if (CGRectGetMinY(v85) < a3)
  {
    v86.origin.double x = v70;
    v86.origin.double y = v71;
    v86.size.double width = v40;
    v86.size.double height = height;
    if (CGRectGetMaxY(v86) > a3)
    {
      map_point((float32x2_t)__PAIR64__(v82.u32[1], v77), v82, a5, a4);
      double v60 = unionPointWithRect(v59, v42, v79, v45, v47);
      CGFloat v62 = v61;
      CGFloat v64 = v63;
      CGFloat v66 = v65;
      map_point((float32x2_t)__PAIR64__(v82.u32[1], v76), v82, a5, v69);
      return unionPointWithRect(v67, v60, v62, v64, v66);
    }
  }
  return v42;
}

float32x2_t cikernel::_pinchDistortionScaleLT1(CI *a1, float32x2_t a2, float32x4_t a3)
{
  DC = (float32x2_t *)CI::getDC(a1);
  float32x2_t v5 = vsub_f32(*DC, a2);
  *(float *)&unsigned int v6 = vmuls_lane_f32(sqrtf(vaddv_f32(vmul_f32(v5, v5))), *(float32x2_t *)a3.f32, 1) + 0.000001;
  float v7 = *(float *)&v6;
  float32x2_t v8 = vrsqrte_f32((float32x2_t)v6);
  return vmla_laneq_f32(vmul_n_f32(*(float32x2_t *)CI::getDC((CI *)DC), 1.0 - a3.f32[2]), vadd_f32(a2, vmul_n_f32(v5, vmul_f32(v8, vrsqrts_f32((float32x2_t)LODWORD(v7), vmul_f32(v8, v8))).f32[0])), a3, 2);
}

int8x8_t cikernel::_pinchDistortionScaleGE1(CI *a1, float32x2_t a2, float32x4_t a3)
{
  float32x2_t v4 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  *(double *)&float32x2_t v5 = vmuls_lane_f32(sqrtf(vaddv_f32(vmul_f32(v4, v4))), *(float32x2_t *)a3.f32, 1) + 0.000001;
  v5.f32[0] = *(double *)&v5;
  float32x2_t v14 = v5;
  int8x8_t v6 = (int8x8_t)vadd_f32(a2, vmul_n_f32(v4, powf(v5.f32[0], a3.f32[3])));
  float32x2_t v7 = vrsqrte_f32((float32x2_t)v14.u32[0]);
  float32x2_t v8 = vadd_f32(a2, vmul_n_f32(v4, vmul_f32(v7, vrsqrts_f32((float32x2_t)v14.u32[0], vmul_f32(v7, v7))).f32[0]));
  DC = (float32x2_t *)CI::getDC(v9);
  v11.i32[0] = 1.0;
  return vbsl_s8((int8x8_t)vdup_lane_s32(vcge_f32(v11, v14), 0), (int8x8_t)vmla_laneq_f32(vmul_n_f32(*DC, 1.0 - a3.f32[2]), v8, a3, 2), v6);
}

void map_point(float32x2_t a1, float32x2_t a2, float a3, float a4)
{
  if (a4 >= 1.0)
  {
    float32x2_t v4 = vsub_f32(a1, a2);
    float v5 = (float)((float)(1.0 / a3) * sqrtf(vaddv_f32(vmul_f32(v4, v4)))) + 0.000001;
    powf(v5, a4 * -0.5);
  }
}

float32x2_t cikernel::_pixellate(CI *a1, float32x2_t a2, double a3)
{
  return vadd_f32(a2, vmul_lane_f32(vadd_f32(vrndm_f32(vmul_n_f32(vsub_f32(*(float32x2_t *)CI::getDC(a1), a2), *(float *)&a3)), (float32x2_t)0x3F0000003F000000), *(float32x2_t *)&a3, 1));
}

void CI::f2_f2_f2(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  float32x2_t v11 = (double (*)(void *, double, double))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  int v14 = *(_DWORD *)(v10 + 40);
  uint64_t v15 = *(void *)(v10 + 32);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 56)), a2);
  }
  double v16 = (double *)(a3 + 16 * v15);
  if (v14 != 5) {
    double v16 = (double *)((char *)a2 + 64 * v15);
  }
  double v17 = (double *)(a3 + 16 * v13);
  if (v12 != 5) {
    double v17 = (double *)((char *)a2 + 64 * v13);
  }
  *(double *)(a3 + 16 * a7) = v11(a1, *v17, *v16);
}

double cikernel::_hexagonalPixellate(uint64_t a1, float32x2_t a2, float32x2_t a3, float32x2_t a4, float a5)
{
  _S9 = a5;
  _D1 = vsub_f32(*(float32x2_t *)CI::getDC((CI *)a1), a2);
  __asm { FMLS            S0, S9, V1.S[1] }
  float32x2_t v16 = vmul_f32(a3, (float32x2_t)__PAIR64__(_D1.u32[1], _S0));
  float32x2_t v17 = vrndm_f32(v16);
  _D3 = vsub_f32(v16, v17);
  *(float32x2_t *)_Q0.i8 = vmul_f32(a4, v17);
  _D4 = vadd_f32(a4, *(float32x2_t *)_Q0.i8);
  *(float32x2_t *)_Q2.i8 = vadd_f32(*(float32x2_t *)_Q0.i8, (float32x2_t)vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32((float)(vaddv_f32(_D3) + -1.0) < 0.0), 0x1FuLL)), (int8x8_t)0x8000000080000000, (int8x8_t)a4));
  __asm { FMLA            S3, S9, V2.S[1] }
  _Q2.i32[0] = _D3.i32[0];
  __asm { FMLA            S5, S9, V4.S[1] }
  v23.i64[0] = __PAIR64__(_D4.u32[1], _S5);
  __asm { FMLA            S4, S9, V0.S[1] }
  _Q0.i32[0] = _D4.i32[0];
  float32x2_t v24 = vsub_f32(_D1, *(float32x2_t *)_Q2.i8);
  int32x2_t v25 = (int32x2_t)vmul_f32(v24, v24);
  float32x2_t v26 = vadd_f32((float32x2_t)v25, (float32x2_t)vdup_lane_s32(v25, 1));
  v28.i64[1] = v27;
  float32x2_t v29 = vrsqrte_f32((float32x2_t)v26.u32[0]);
  _Q2.u64[1] = (unint64_t)vmul_f32(vmul_f32(v29, vrsqrts_f32((float32x2_t)v26.u32[0], vmul_f32(v29, v29))), v26);
  float32x2_t v30 = vsub_f32(_D1, *(float32x2_t *)v23.i8);
  int32x2_t v31 = (int32x2_t)vmul_f32(v30, v30);
  float32x2_t v32 = vadd_f32((float32x2_t)v31, (float32x2_t)vdup_lane_s32(v31, 1));
  float32x2_t v33 = vrsqrte_f32((float32x2_t)v32.u32[0]);
  *(float32x2_t *)v28.i8 = vmul_f32(vmul_f32(v33, vrsqrts_f32((float32x2_t)v32.u32[0], vmul_f32(v33, v33))), v32);
  v23.i64[1] = v28.i64[0];
  float32x2_t v34 = vsub_f32(_D1, *(float32x2_t *)_Q0.i8);
  int32x2_t v35 = (int32x2_t)vmul_f32(v34, v34);
  float32x2_t v36 = vadd_f32((float32x2_t)v35, (float32x2_t)vdup_lane_s32(v35, 1));
  v38.i64[1] = v37;
  float32x2_t v39 = vrsqrte_f32((float32x2_t)v36.u32[0]);
  *(float32x2_t *)v38.i8 = vmul_f32(v39, vrsqrts_f32((float32x2_t)v36.u32[0], vmul_f32(v39, v39)));
  _Q0.u64[1] = (unint64_t)vmul_f32(*(float32x2_t *)v38.i8, v36);
  int8x16_t v40 = (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(vsub_f32((float32x2_t)_Q2.u64[1], *(float32x2_t *)v28.i8).f32[0] < 0.0)), 0x1FuLL));
  float32x4_t v41 = (float32x4_t)vbslq_s8(v40, _Q2, v23);
  float32x4_t v42 = (float32x4_t)vbslq_s8(v40, v23, _Q2);
  int8x16_t v43 = (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(COERCE_FLOAT(vsubq_f32(v41, v42).i32[2]) < 0.0)), 0x1FuLL));
  int8x16_t v44 = vbslq_s8(v43, (int8x16_t)v41, _Q0);
  float32x4_t v45 = (float32x4_t)vbslq_s8(v43, _Q0, (int8x16_t)v41);
  int8x16_t v46 = (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(COERCE_FLOAT(vsubq_f32(v42, v45).i32[2]) < 0.0)), 0x1FuLL));
  float32x4_t v59 = (float32x4_t)v44;
  float32x4_t v60 = (float32x4_t)vbslq_s8(v46, (int8x16_t)v42, (int8x16_t)v45);
  *(float32x2_t *)v42.f32 = vadd_f32(a2, *(float32x2_t *)v44.i8);
  v44.i32[0] = *(_DWORD *)(a1 + 28);
  v45.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v42.f32, 1), *(float *)(a1 + 16), v42.f32[0]);
  v41.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v46.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v42.f32, 1), *(float *)v44.i32, v42.f32[0]);
  v42.f32[0] = v41.f32[0] + *(float *)v46.i32;
  v45.f32[1] = v41.f32[0] + *(float *)v46.i32;
  *(double *)v47.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v45.i64, (float64x2_t)v42, *(double *)v46.i64, *(double *)v44.i64, (int8x16_t)v41, v28, v38);
  float32x4_t v58 = v47;
  *(float32x2_t *)v47.f32 = vadd_f32(a2, *(float32x2_t *)v60.f32);
  *(float *)&double v48 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v47.f32, 1), *(float *)(a1 + 16), v47.f32[0]);
  LODWORD(v49) = *(_DWORD *)(a1 + 28);
  v50.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v51.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v47.f32, 1), *(float *)&v49, v47.f32[0]);
  v47.f32[0] = *(float *)(a1 + 24) + *(float *)&v48;
  *(float *)v52.f64 = *(float *)v50.i32 + *(float *)v51.i32;
  v47.f32[1] = *(float *)v50.i32 + *(float *)v51.i32;
  *(double *)v54.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v47.i64, v52, v48, v49, v51, v50, v53);
  float v55 = COERCE_FLOAT(vsubq_f32(v59, v60).i32[2]) * 0.5 + 0.5;
  if (v55 <= 1.0) {
    float v56 = v55;
  }
  else {
    float v56 = 1.0;
  }
  if (v55 < 0.0) {
    float v56 = 0.0;
  }
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(v58, 1.0 - v56), v54, v56).u64[0];
  return result;
}

void CI::f4_sr_f2_f2_f2_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = *(void *)(a1 + 48);
  float32x2_t v11 = *(double (**)(uint64_t, double, double, double, float))(a1 + 24);
  uint64_t v12 = *(void *)(v10 + 8);
  int v13 = *(_DWORD *)(v10 + 40);
  uint64_t v14 = *(void *)(v10 + 32);
  int v15 = *(_DWORD *)(v10 + 64);
  uint64_t v16 = *(void *)(v10 + 56);
  int v17 = *(_DWORD *)(v10 + 88);
  uint64_t v18 = *(void *)(v10 + 80);
  uint64_t v19 = *(void *)(v10 + 104);
  if (*(unsigned char *)(a1 + 64))
  {
    int v24 = *(_DWORD *)(v10 + 88);
    int v25 = *(_DWORD *)(v10 + 40);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 128)), a2);
    int v17 = v24;
    int v13 = v25;
  }
  CGFloat v20 = (double *)(a3 + 16 * v18);
  if (v17 != 5) {
    CGFloat v20 = (double *)((char *)a2 + 64 * v18);
  }
  double v21 = (double *)(a3 + 16 * v16);
  if (v15 != 5) {
    double v21 = (double *)((char *)a2 + 64 * v16);
  }
  CGFloat v22 = (double *)(a3 + 16 * v14);
  if (v13 != 5) {
    CGFloat v22 = (double *)((char *)a2 + 64 * v14);
  }
  *(double *)&long long v23 = v11(a4 + 80 * v12, *v22, *v21, *v20, *((float *)a2 + 16 * v19));
  *(_OWORD *)(a3 + 16 * a7) = v23;
}

double cikernel::_interleavedToPlanar3(cikernel *this, SamplerObj *a2, float a3)
{
  v5.f64[0] = *(float64_t *)CI::getDC(this);
  float v9 = *((float *)v5.f64 + 1);
  double v10 = *((float *)v5.f64 + 1);
  double v11 = a3;
  double v12 = v11 + v11;
  double v13 = *((float *)v5.f64 + 1) + a3 * -2.0;
  if (v11 + v11 > *((float *)v5.f64 + 1)) {
    double v13 = *((float *)v5.f64 + 1) - a3;
  }
  HIDWORD(v14) = 0x80000000;
  double v15 = v10 + v11 * -0.0;
  if (*((float *)v5.f64 + 1) >= a3) {
    double v15 = v13;
  }
  *(float *)&double v13 = v15;
  v6.i32[0] = *((_DWORD *)this + 7);
  *(float *)&double v16 = *((float *)this + 6)
                 + vmlas_n_f32(*((float *)this + 5) * *(float *)&v13, *((float *)this + 4), *(float *)v5.f64);
  LODWORD(v14) = *((_DWORD *)this + 8);
  v7.i32[0] = *((_DWORD *)this + 9);
  *(float *)&double v13 = vmlas_n_f32(*(float *)&v14 * *(float *)&v13, *(float *)v6.i32, *(float *)v5.f64);
  *(float *)v5.f64 = *(float *)v7.i32 + *(float *)&v13;
  *((float *)&v16 + 1) = *(float *)v7.i32 + *(float *)&v13;
  double v17 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v16, v5, v13, v14, v6, v7, v8);
  HIDWORD(v19) = 0;
  if (v9 >= a3)
  {
    if (v12 <= v10) {
      LODWORD(v19) = LODWORD(v17);
    }
    else {
      LODWORD(v19) = HIDWORD(v17);
    }
  }
  else
  {
    LODWORD(v19) = v18;
  }
  return v19;
}

double cikernel::_planarToInterleaved3(cikernel *this, SamplerObj *a2, double a3)
{
  DC = (void *)CI::getDC(this);
  HIDWORD(v8) = HIDWORD(a3);
  v9.f64[0] = *(float64_t *)DC;
  double v10 = 0.0;
  if (COERCE_FLOAT(*DC) >= 0.0
    && *(float *)v9.f64 <= *(float *)&a3
    && *((float *)v9.f64 + 1) >= 0.0
    && *((float *)v9.f64 + 1) <= *(float *)&a3)
  {
    v13.i32[0] = 0;
    v13.i32[1] = LODWORD(a3);
    float64x2_t v32 = v9;
    float32x2_t v33 = v13;
    float32x2_t v14 = vadd_f32(vadd_f32(v13, v13), *(float32x2_t *)&v9.f64[0]);
    *(float *)&double v10 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v14, 1), *((float *)this + 4), v14.f32[0]);
    LODWORD(v8) = *((_DWORD *)this + 7);
    v6.i32[0] = *((_DWORD *)this + 9);
    *(float *)v5.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v14, 1), *(float *)&v8, v14.f32[0]);
    v14.f32[0] = *((float *)this + 6) + *(float *)&v10;
    *(float *)v9.f64 = *(float *)v6.i32 + *(float *)v5.i32;
    v14.f32[1] = *(float *)v6.i32 + *(float *)v5.i32;
    double v15 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v14, v9, v10, v8, v5, v6, v7);
    unsigned int v35 = LODWORD(v15);
    float64x2_t v16 = v32;
    float32x2_t v17 = vadd_f32(v33, *(float32x2_t *)&v32.f64[0]);
    *(float *)&double v18 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v17, 1), *((float *)this + 4), v17.f32[0]);
    LODWORD(v19) = *((_DWORD *)this + 7);
    v20.i32[0] = *((_DWORD *)this + 9);
    *(float *)v21.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v17, 1), *(float *)&v19, v17.f32[0]);
    v17.f32[0] = *((float *)this + 6) + *(float *)&v18;
    *(float *)v16.f64 = *(float *)v20.i32 + *(float *)v21.i32;
    v17.f32[1] = *(float *)v20.i32 + *(float *)v21.i32;
    double v23 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v17, v16, v18, v19, v21, v20, v22);
    unint64_t v36 = __PAIR64__(LODWORD(v23), v35);
    float64x2_t v24 = v32;
    float32x2_t v25 = vadd_f32(vmul_f32(v33, 0), *(float32x2_t *)&v32.f64[0]);
    *(float *)&double v26 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v25, 1), *((float *)this + 4), v25.f32[0]);
    LODWORD(v27) = *((_DWORD *)this + 7);
    v28.i32[0] = *((_DWORD *)this + 9);
    *(float *)v29.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v25, 1), *(float *)&v27, v25.f32[0]);
    v25.f32[0] = *((float *)this + 6) + *(float *)&v26;
    *(float *)v24.f64 = *(float *)v28.i32 + *(float *)v29.i32;
    v25.f32[1] = *(float *)v28.i32 + *(float *)v29.i32;
    CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v25, v24, v26, v27, v29, v28, v30);
    return *(double *)&v36;
  }
  return v10;
}

double cikernel::_interleavedToPlanar4(cikernel *this, SamplerObj *a2, float a3)
{
  v5.f64[0] = *(float64_t *)CI::getDC(this);
  float v10 = *((float *)v5.f64 + 1);
  double v11 = *((float *)v5.f64 + 1);
  double v12 = a3;
  double v13 = v12 + v12;
  double v14 = *((float *)v5.f64 + 1) + a3 * -3.0;
  if (a3 * 3.0 > *((float *)v5.f64 + 1)) {
    double v14 = *((float *)v5.f64 + 1) + a3 * -2.0;
  }
  if (v13 > v11) {
    double v14 = v11 - v12;
  }
  double v15 = v11 + v12 * -0.0;
  if (*((float *)v5.f64 + 1) < a3) {
    double v14 = v11 + v12 * -0.0;
  }
  *(float *)&double v15 = v14;
  v7.i32[0] = *((_DWORD *)this + 7);
  *(float *)&double v16 = *((float *)this + 6)
                 + vmlas_n_f32(*((float *)this + 5) * *(float *)&v15, *((float *)this + 4), *(float *)v5.f64);
  LODWORD(v6) = *((_DWORD *)this + 8);
  v8.i32[0] = *((_DWORD *)this + 9);
  *(float *)&double v15 = vmlas_n_f32(*(float *)&v6 * *(float *)&v15, *(float *)v7.i32, *(float *)v5.f64);
  *(float *)v5.f64 = *(float *)v8.i32 + *(float *)&v15;
  *((float *)&v16 + 1) = *(float *)v8.i32 + *(float *)&v15;
  double v17 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v16, v5, v15, v6, v7, v8, v9);
  if (v10 >= a3)
  {
    if (v13 <= v11)
    {
      HIDWORD(v20) = 0;
      if (v12 * 3.0 <= v11) {
        LODWORD(v20) = LODWORD(v17);
      }
      else {
        LODWORD(v20) = HIDWORD(v17);
      }
    }
    else
    {
      *(void *)&double v20 = v18;
    }
  }
  else
  {
    *(void *)&double v20 = v19;
  }
  return v20;
}

double cikernel::_planarToInterleaved4(cikernel *this, SamplerObj *a2, double a3)
{
  DC = (void *)CI::getDC(this);
  HIDWORD(v8) = HIDWORD(a3);
  v9.f64[0] = *(float64_t *)DC;
  double v10 = 0.0;
  if (COERCE_FLOAT(*DC) >= 0.0
    && *(float *)v9.f64 <= *(float *)&a3
    && *((float *)v9.f64 + 1) >= 0.0
    && *((float *)v9.f64 + 1) <= *(float *)&a3)
  {
    LODWORD(v13) = 0;
    HIDWORD(v13) = LODWORD(a3);
    float64x2_t v44 = v9;
    float32x2_t v46 = *(float32x2_t *)&v13;
    __asm { FMOV            V0.2S, #3.0 }
    float32x2_t v19 = vadd_f32(vmul_f32(*(float32x2_t *)&v13, _D0), *(float32x2_t *)&v9.f64[0]);
    *(float *)&double v13 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v19, 1), *((float *)this + 4), v19.f32[0]);
    LODWORD(v8) = *((_DWORD *)this + 7);
    v6.i32[0] = *((_DWORD *)this + 9);
    *(float *)v5.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v19, 1), *(float *)&v8, v19.f32[0]);
    v19.f32[0] = *((float *)this + 6) + *(float *)&v13;
    *(float *)v9.f64 = *(float *)v6.i32 + *(float *)v5.i32;
    v19.f32[1] = *(float *)v6.i32 + *(float *)v5.i32;
    *(double *)v20.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v19, v9, v13, v8, v5, v6, v7);
    int32x4_t v43 = v20;
    float64x2_t v21 = v44;
    *(float32x2_t *)v20.i8 = vadd_f32(vadd_f32(v46, v46), *(float32x2_t *)&v44.f64[0]);
    *(float *)&double v22 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v20.i8, 1), *((float *)this + 4), *(float *)v20.i32);
    LODWORD(v23) = *((_DWORD *)this + 7);
    v24.i32[0] = *((_DWORD *)this + 9);
    *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v20.i8, 1), *(float *)&v23, *(float *)v20.i32);
    *(float *)v20.i32 = *((float *)this + 6) + *(float *)&v22;
    *(float *)v21.f64 = *(float *)v24.i32 + *(float *)v25.i32;
    *(float *)&v20.i32[1] = *(float *)v24.i32 + *(float *)v25.i32;
    *(double *)v27.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v20.i64, v21, v22, v23, v25, v24, v26);
    HIDWORD(v28) = HIDWORD(v44.f64[0]);
    float32x2_t v29 = vadd_f32(v46, *(float32x2_t *)&v44.f64[0]);
    *(float *)&double v30 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v29, 1), *((float *)this + 4), v29.f32[0]);
    LODWORD(v28) = *((_DWORD *)this + 6);
    v31.i32[0] = *((_DWORD *)this + 7);
    v32.i32[0] = *((_DWORD *)this + 9);
    *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v29, 1), *(float *)v31.i32, v29.f32[0]);
    float64x2_t v34 = (float64x2_t)v43;
    v43.i64[0] = vzip1q_s32(v43, v27).u64[0];
    *(float *)v27.i32 = *(float *)&v28 + *(float *)&v30;
    *(float *)v34.f64 = *(float *)v32.i32 + *(float *)v33.i32;
    *(float *)&v27.i32[1] = *(float *)v32.i32 + *(float *)v33.i32;
    CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v27.i64, v34, v28, v30, v31, v33, v32);
    float64x2_t v35 = v44;
    float32x2_t v36 = vadd_f32(vmul_f32(v46, 0), *(float32x2_t *)&v44.f64[0]);
    *(float *)&double v37 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v36, 1), *((float *)this + 4), v36.f32[0]);
    LODWORD(v38) = *((_DWORD *)this + 7);
    v39.i32[0] = *((_DWORD *)this + 9);
    *(float *)v40.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v36, 1), *(float *)&v38, v36.f32[0]);
    v36.f32[0] = *((float *)this + 6) + *(float *)&v37;
    *(float *)v35.f64 = *(float *)v39.i32 + *(float *)v40.i32;
    v36.f32[1] = *(float *)v39.i32 + *(float *)v40.i32;
    CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v36, v35, v37, v38, v40, v39, v41);
    return *(double *)v43.i64;
  }
  return v10;
}

double cikernel::_pointillize(uint64_t a1, uint64_t a2, int8x16_t a3)
{
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)&double v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)&v7, COERCE_FLOAT(*DC));
  *(float *)&double v10 = *(float *)(a1 + 24) + *(float *)&v6;
  *(float *)v11.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  *((float *)&v10 + 1) = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v10, v11, v6, v7, v9, v8, v12);
  float32x4_t v143 = v13;
  v14.i32[0] = vextq_s8(a3, a3, 8uLL).u32[0];
  unsigned __int32 v144 = v14.i32[0];
  v14.i32[1] = a3.i32[2];
  float32x2_t v141 = v14;
  float32x2_t v16 = *(float32x2_t *)CI::getDC(v15);
  float32x2_t v17 = vmul_laneq_f32(v16, (float32x4_t)a3, 3);
  float32x2_t v18 = vadd_f32(vadd_f32(*(float32x2_t *)a3.i8, (float32x2_t)0x3F0000003F000000), vrndm_f32(vadd_f32(v17, (float32x2_t)0x3F0000003F000000)));
  float32x2_t v19 = (float32x2_t)vdup_n_s32(0x3B800000u);
  *(float32x2_t *)&v20.f64[0] = vrndm_f32(vmul_f32(v18, v19));
  float32x2_t v21 = (float32x2_t)vdup_n_s32(0xC3800000);
  float32x2_t v22 = vmla_f32(v18, v21, *(float32x2_t *)&v20.f64[0]);
  *(float *)&double v23 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v22, 1), *(float *)(a2 + 16), v22.f32[0]);
  LODWORD(v24) = *(_DWORD *)(a2 + 28);
  v25.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v22, 1), *(float *)&v24, v22.f32[0]);
  v22.f32[0] = *(float *)(a2 + 24) + *(float *)&v23;
  *(float *)v20.f64 = *(float *)v25.i32 + *(float *)v26.i32;
  v22.f32[1] = *(float *)v25.i32 + *(float *)v26.i32;
  *(double *)&long long v28 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)&v22, v20, v23, v24, v26, v25, v27);
  long long v138 = v28;
  HIDWORD(v29) = a3.i32[1];
  *(float32x2_t *)v30.i8 = vadd_f32(vmul_laneq_f32(vadd_f32(vrndm_f32(vadd_f32(v17, (float32x2_t)0xBF000000BF000000)), (float32x2_t)0x3F0000003F000000), (float32x4_t)a3, 2), (float32x2_t)0x3F0000003F000000);
  float32x2_t v31 = vadd_f32(v141, *(float32x2_t *)v30.i8);
  float32x2_t v32 = (float32x2_t)vdup_n_s32(0x3F266666u);
  *(float32x2_t *)&v33.f64[0] = vmul_f32(vmul_laneq_f32(vadd_f32(*(float32x2_t *)&v28, (float32x2_t)0xBF000000BF000000), (float32x4_t)a3, 2), v32);
  *(float32x2_t *)&long long v28 = vadd_f32(v31, *(float32x2_t *)&v33.f64[0]);
  *(float *)&double v29 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v28, 1), *(float *)(a1 + 16), *(float *)&v28);
  v31.i32[0] = *(_DWORD *)(a1 + 28);
  v34.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v30.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v28, 1), v31.f32[0], *(float *)&v28);
  *(float32x2_t *)&long long v28 = vsub_f32(*(float32x2_t *)&v28, v16);
  *(float32x2_t *)&long long v28 = vmul_f32(*(float32x2_t *)&v28, *(float32x2_t *)&v28);
  long long v140 = v28;
  *(float *)&long long v28 = *(float *)(a1 + 24) + *(float *)&v29;
  *(float *)v33.f64 = *(float *)v34.i32 + *(float *)v30.i32;
  *((float *)&v28 + 1) = *(float *)v34.i32 + *(float *)v30.i32;
  *(double *)v36.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v28, v33, v29, *(double *)&v31, v30, v34, v35);
  v37.i32[1] = DWORD1(v138);
  *(float *)v37.i32 = (float)(*((float *)&v138 + 2) + -0.5) * 0.1;
  float32x4_t v38 = vaddq_f32(v36, vmulq_laneq_f32((float32x4_t)vdupq_lane_s32(v37, 0), v36, 3));
  v38.i32[3] = v36.i32[3];
  float32x4_t v142 = v38;
  v38.i32[0] = 0;
  v38.i32[1] = v144;
  *(void *)&long long v138 = v38.i64[0];
  float32x2_t v40 = *(float32x2_t *)CI::getDC(v39);
  float32x2_t v41 = vmul_laneq_f32(v40, (float32x4_t)a3, 3);
  float32x2_t v42 = vadd_f32(vadd_f32(*(float32x2_t *)a3.i8, (float32x2_t)0x3F000000BF000000), vrndm_f32(vadd_f32(v41, (float32x2_t)0x3F0000003F000000)));
  *(float32x2_t *)&v43.f64[0] = vrndm_f32(vmul_f32(v42, v19));
  float32x2_t v44 = vmla_f32(v42, v21, *(float32x2_t *)&v43.f64[0]);
  *(float *)&double v45 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v44, 1), *(float *)(a2 + 16), v44.f32[0]);
  LODWORD(v46) = *(_DWORD *)(a2 + 28);
  v47.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v48.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v44, 1), *(float *)&v46, v44.f32[0]);
  v44.f32[0] = *(float *)(a2 + 24) + *(float *)&v45;
  *(float *)v43.f64 = *(float *)v47.i32 + *(float *)v48.i32;
  v44.f32[1] = *(float *)v47.i32 + *(float *)v48.i32;
  *(double *)&long long v50 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)&v44, v43, v45, v46, v48, v47, v49);
  long long v134 = v50;
  HIDWORD(v51) = a3.i32[1];
  *(float32x2_t *)v52.i8 = vadd_f32(vmul_laneq_f32(vadd_f32(vrndm_f32(vadd_f32(v41, (float32x2_t)0xBF000000BF000000)), (float32x2_t)0x3F0000003F000000), (float32x4_t)a3, 2), (float32x2_t)0x3F0000003F000000);
  float32x2_t v53 = vadd_f32(*(float32x2_t *)&v138, *(float32x2_t *)v52.i8);
  *(float32x2_t *)&v54.f64[0] = vmul_f32(vmul_laneq_f32(vadd_f32(*(float32x2_t *)&v50, (float32x2_t)0xBF000000BF000000), (float32x4_t)a3, 2), v32);
  *(float32x2_t *)&long long v50 = vadd_f32(v53, *(float32x2_t *)&v54.f64[0]);
  *(float *)&double v51 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v50, 1), *(float *)(a1 + 16), *(float *)&v50);
  v53.i32[0] = *(_DWORD *)(a1 + 28);
  v55.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v52.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v50, 1), v53.f32[0], *(float *)&v50);
  *(float32x2_t *)&long long v50 = vsub_f32(*(float32x2_t *)&v50, v40);
  int32x2_t v137 = (int32x2_t)vmul_f32(*(float32x2_t *)&v50, *(float32x2_t *)&v50);
  *(float *)&long long v50 = *(float *)(a1 + 24) + *(float *)&v51;
  *(float *)v54.f64 = *(float *)v55.i32 + *(float *)v52.i32;
  *((float *)&v50 + 1) = *(float *)v55.i32 + *(float *)v52.i32;
  *(double *)v57.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v50, v54, v51, *(double *)&v53, v52, v55, v56);
  v58.i32[1] = DWORD1(v134);
  *(float *)v58.i32 = (float)(*((float *)&v134 + 2) + -0.5) * 0.1;
  float32x4_t v59 = vaddq_f32(v57, vmulq_laneq_f32((float32x4_t)vdupq_lane_s32(v58, 0), v57, 3));
  v59.i32[3] = v57.i32[3];
  float32x4_t v139 = v59;
  float32x2_t v61 = *(float32x2_t *)CI::getDC(v60);
  float32x2_t v62 = vmul_laneq_f32(v61, (float32x4_t)a3, 3);
  float32x2_t v63 = vadd_f32(vadd_f32(*(float32x2_t *)a3.i8, (float32x2_t)0xBF0000003F000000), vrndm_f32(vadd_f32(v62, (float32x2_t)0x3F0000003F000000)));
  *(float32x2_t *)&v64.f64[0] = vrndm_f32(vmul_f32(v63, v19));
  float32x2_t v65 = vmla_f32(v63, v21, *(float32x2_t *)&v64.f64[0]);
  *(float *)&double v66 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v65, 1), *(float *)(a2 + 16), v65.f32[0]);
  LODWORD(v67) = *(_DWORD *)(a2 + 28);
  v68.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v69.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v65, 1), *(float *)&v67, v65.f32[0]);
  v65.f32[0] = *(float *)(a2 + 24) + *(float *)&v66;
  *(float *)v64.f64 = *(float *)v68.i32 + *(float *)v69.i32;
  v65.f32[1] = *(float *)v68.i32 + *(float *)v69.i32;
  *(double *)&long long v71 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)&v65, v64, v66, v67, v69, v68, v70);
  long long v135 = v71;
  HIDWORD(v72) = a3.i32[1];
  *(float32x2_t *)v73.i8 = vadd_f32(vmul_laneq_f32(vadd_f32(vrndm_f32(vadd_f32(v62, (float32x2_t)0xBF000000BF000000)), (float32x2_t)0x3F0000003F000000), (float32x4_t)a3, 2), (float32x2_t)0x3F0000003F000000);
  float32x2_t v74 = vadd_f32((float32x2_t)v144, *(float32x2_t *)v73.i8);
  *(float32x2_t *)&v75.f64[0] = vmul_f32(vmul_laneq_f32(vadd_f32(*(float32x2_t *)&v71, (float32x2_t)0xBF000000BF000000), (float32x4_t)a3, 2), v32);
  *(float32x2_t *)&long long v71 = vadd_f32(v74, *(float32x2_t *)&v75.f64[0]);
  *(float *)&double v72 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v71, 1), *(float *)(a1 + 16), *(float *)&v71);
  v74.i32[0] = *(_DWORD *)(a1 + 28);
  v76.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v73.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v71, 1), v74.f32[0], *(float *)&v71);
  *(float32x2_t *)&long long v71 = vsub_f32(*(float32x2_t *)&v71, v61);
  int32x2_t v77 = (int32x2_t)vmul_f32(*(float32x2_t *)&v71, *(float32x2_t *)&v71);
  *(float *)&long long v71 = *(float *)(a1 + 24) + *(float *)&v72;
  *(float *)v75.f64 = *(float *)v76.i32 + *(float *)v73.i32;
  *((float *)&v71 + 1) = *(float *)v76.i32 + *(float *)v73.i32;
  *(double *)v79.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v71, v75, v72, *(double *)&v74, v73, v76, v78);
  v80.i32[1] = DWORD1(v135);
  *(float *)v80.i32 = (float)(*((float *)&v135 + 2) + -0.5) * 0.1;
  float32x4_t v81 = vaddq_f32(v79, vmulq_laneq_f32((float32x4_t)vdupq_lane_s32(v80, 0), v79, 3));
  v81.i32[3] = v79.i32[3];
  float32x4_t v145 = v81;
  float32x2_t v83 = *(float32x2_t *)CI::getDC(v82);
  float32x2_t v84 = vmul_laneq_f32(v83, (float32x4_t)a3, 3);
  float32x2_t v85 = vadd_f32(vadd_f32(*(float32x2_t *)a3.i8, (float32x2_t)0xBF000000BF000000), vrndm_f32(vadd_f32(v84, (float32x2_t)0x3F0000003F000000)));
  *(float32x2_t *)&v86.f64[0] = vrndm_f32(vmul_f32(v85, v19));
  float32x2_t v87 = vmla_f32(v85, v21, *(float32x2_t *)&v86.f64[0]);
  *(float *)&double v88 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v87, 1), *(float *)(a2 + 16), v87.f32[0]);
  LODWORD(v89) = *(_DWORD *)(a2 + 28);
  v90.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v91.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v87, 1), *(float *)&v89, v87.f32[0]);
  v87.f32[0] = *(float *)(a2 + 24) + *(float *)&v88;
  *(float *)v86.f64 = *(float *)v90.i32 + *(float *)v91.i32;
  v87.f32[1] = *(float *)v90.i32 + *(float *)v91.i32;
  *(double *)v93.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)&v87, v86, v88, v89, v91, v90, v92);
  float32x4_t v136 = v93;
  *(float32x2_t *)&v95.f64[0] = vadd_f32(vadd_f32(vmul_laneq_f32(vadd_f32(vrndm_f32(vadd_f32(v84, (float32x2_t)0xBF000000BF000000)), (float32x2_t)0x3F0000003F000000), (float32x4_t)a3, 2), (float32x2_t)0x3F0000003F000000), vmul_f32(vmul_laneq_f32(vadd_f32(*(float32x2_t *)v93.f32, (float32x2_t)0xBF000000BF000000), (float32x4_t)a3, 2), v32));
  *(float32x2_t *)v93.f32 = vsub_f32(*(float32x2_t *)&v95.f64[0], v83);
  *(float32x2_t *)v93.f32 = vmul_f32(*(float32x2_t *)v93.f32, *(float32x2_t *)v93.f32);
  *(int32x2_t *)v96.f32 = vzip1_s32(*(int32x2_t *)v93.f32, v77);
  v96.i64[1] = __PAIR64__(v140, v137.u32[0]);
  v97.i64[1] = *((void *)&v140 + 1);
  *(int32x2_t *)v93.f32 = vzip2_s32(*(int32x2_t *)v93.f32, v77);
  v93.i64[1] = __PAIR64__(DWORD1(v140), vdup_lane_s32(v137, 1).u32[0]);
  float32x4_t v98 = vdivq_f32(vmulq_laneq_f32(vsqrtq_f32(vaddq_f32(v96, v93)), (float32x4_t)a3, 3), (float32x4_t)vdupq_n_s32(0xBF35C28F));
  float64x2_t v99 = vcvt_hight_f64_f32(v98);
  __asm { FMOV            V3.2D, #1.0 }
  float64x2_t v105 = vaddq_f64(vcvtq_f64_f32(*(float32x2_t *)v98.f32), _Q3);
  float64x2_t v106 = vaddq_f64(v99, _Q3);
  __asm { FMOV            V3.2D, #3.0 }
  float64x2_t v108 = vmulq_f64(v106, _Q3);
  int32x2_t v109 = (int32x2_t)vcvt_f32_f64(vmulq_f64(v105, _Q3));
  float32x4_t v110 = vcvt_hight_f32_f64(v109, v108);
  float32x2_t v111 = vcvt_f32_f64(v108);
  float v112 = v111.f32[1];
  if (v111.f32[1] > 1.0) {
    float v112 = 1.0;
  }
  double v113 = COERCE_DOUBLE(vmovn_s32(vcltzq_f32(v110)));
  double v114 = v112;
  v97.i64[0] = 0;
  if (BYTE6(v113)) {
    double v114 = 0.0;
  }
  v94.i64[0] = 3.0;
  double v115 = (v114 * -2.0 + 3.0) * v114;
  float v116 = v115 * v114;
  *(float *)&double v115 = 1.0 - v116;
  float32x4_t v117 = vmlaq_n_f32(vmulq_laneq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v115, 0), v143, 3), v142, v116);
  if (v111.f32[0] > 1.0) {
    v111.f32[0] = 1.0;
  }
  double v118 = v111.f32[0];
  if (BYTE4(v113)) {
    double v118 = 0.0;
  }
  float v119 = (v118 * -2.0 + 3.0) * v118 * v118;
  float32x4_t v120 = vmlaq_n_f32(vmulq_n_f32(v117, 1.0 - v119), v139, v119);
  float v121 = *(float *)&v109.i32[1];
  if (*(float *)&v109.i32[1] > 1.0) {
    float v121 = 1.0;
  }
  double v122 = v121;
  if (BYTE2(v113)) {
    double v122 = 0.0;
  }
  float v123 = (v122 * -2.0 + 3.0) * v122 * v122;
  float32x4_t v124 = vmulq_n_f32(v120, 1.0 - v123);
  int8x16_t v125 = (int8x16_t)v145;
  float32x4_t v148 = vmlaq_n_f32(v124, v145, v123);
  if (*(float *)v109.i32 > 1.0) {
    *(float *)v109.i32 = 1.0;
  }
  double v126 = *(float *)v109.i32;
  if (LOBYTE(v113)) {
    double v126 = 0.0;
  }
  double v127 = (v126 * -2.0 + 3.0) * v126;
  float v128 = v127 * v126;
  float v146 = v128;
  LODWORD(v113) = *(_DWORD *)(a1 + 28);
  *(float *)&double v129 = *(float *)(a1 + 24)
                  + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v95.f64[0], 1), *(float *)(a1 + 16), *(float *)v95.f64);
  v125.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)&double v127 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v95.f64[0], 1), *(float *)&v113, *(float *)v95.f64);
  *(float *)v95.f64 = *(float *)v125.i32 + *(float *)&v127;
  *((float *)&v129 + 1) = *(float *)v125.i32 + *(float *)&v127;
  *(double *)v130.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v129, v95, v127, v113, v125, v97, v94);
  v131.i32[1] = v136.i32[1];
  *(float *)v131.i32 = (float)(v136.f32[2] + -0.5) * 0.1;
  float32x4_t v132 = vaddq_f32(v130, vmulq_laneq_f32((float32x4_t)vdupq_lane_s32(v131, 0), v130, 3));
  v132.i32[3] = v130.i32[3];
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(v148, 1.0 - v146), v132, v146).u64[0];
  return result;
}

void sub_193817408(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_193818700(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
}

__n64 cikernel::_xSmooth(cikernel *this, SamplerObj *a2)
{
  float32x2_t v8 = *(float32x2_t *)CI::getDC(this);
  int v9 = -4;
  float v10 = 0.0;
  LODWORD(v11.f64[0]) = 1120403456;
  do
  {
    float64x2_t v15 = v11;
    HIDWORD(v11.f64[0]) = 0;
    float32x2_t v12 = vadd_f32(v8, (float32x2_t)COERCE_UNSIGNED_INT((float)v9));
    *(float *)&double v3 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v12, 1), *((float *)this + 4), v12.f32[0]);
    LODWORD(v4) = *((_DWORD *)this + 7);
    v6.i32[0] = *((_DWORD *)this + 9);
    *(float *)v5.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v12, 1), *(float *)&v4, v12.f32[0]);
    v12.f32[0] = *((float *)this + 6) + *(float *)&v3;
    *(float *)v11.f64 = *(float *)v6.i32 + *(float *)v5.i32;
    v12.f32[1] = *(float *)v6.i32 + *(float *)v5.i32;
    *(double *)v13.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v12, v11, v3, v4, v5, v6, v7);
    double v3 = v10;
    float v10 = v10 + vmulq_f32(v13, v13).f32[0] * 0.111111111;
    float64x2_t v11 = v15;
    *(float *)v11.f64 = fminf(*(float *)v15.f64, v13.f32[0]);
    ++v9;
  }
  while (v9 != 5);
  result.n64_f32[0] = sqrtf(v10);
  result.n64_u32[1] = LODWORD(v11.f64[0]);
  return result;
}

double cikernel::_ySmooth(uint64_t a1, uint64_t a2, int8x16_t a3)
{
  float32x2_t v11 = *(float32x2_t *)CI::getDC((CI *)a1);
  int v12 = -4;
  float v13 = 0.0;
  LODWORD(v14.f64[0]) = 1120403456;
  float64x2_t v40 = v14;
  do
  {
    LODWORD(v5.f64[0]) = 0;
    *((float *)v5.f64 + 1) = (float)v12;
    float32x2_t v15 = vadd_f32(v11, *(float32x2_t *)&v5.f64[0]);
    *(float *)&double v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v15, 1), *(float *)(a1 + 16), v15.f32[0]);
    LODWORD(v7) = *(_DWORD *)(a1 + 28);
    v9.i32[0] = *(_DWORD *)(a1 + 36);
    *(float *)v8.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v15, 1), *(float *)&v7, v15.f32[0]);
    v15.f32[0] = *(float *)(a1 + 24) + *(float *)&v6;
    *(float *)v5.f64 = *(float *)v9.i32 + *(float *)v8.i32;
    v15.f32[1] = *(float *)v9.i32 + *(float *)v8.i32;
    *(double *)v17.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v15, v5, v6, v7, v8, v9, v10);
    double v6 = v13;
    float v13 = v13 + vmulq_f32(v17, v17).f32[0] * 0.111111111;
    float64x2_t v5 = v40;
    *(float *)v5.f64 = fminf(*(float *)v40.f64, v17.f32[1]);
    float64x2_t v40 = v5;
    ++v12;
  }
  while (v12 != 5);
  DC = (float32x2_t *)CI::getDC(v16);
  *(float *)&double v19 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *DC, 1), *(float *)(a2 + 16), COERCE_FLOAT(*DC));
  LODWORD(v20) = *(_DWORD *)(a2 + 28);
  v21.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v22.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *DC, 1), *(float *)&v20, COERCE_FLOAT(*DC));
  *(float *)&double v23 = *(float *)(a2 + 24) + *(float *)&v19;
  *(float *)v24.f64 = *(float *)v21.i32 + *(float *)v22.i32;
  *((float *)&v23 + 1) = *(float *)v21.i32 + *(float *)v22.i32;
  double v26 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v23, v24, v19, v20, v22, v21, v25);
  float32x2_t v27 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v26, 0);
  _Q4 = a3;
  v27.i32[0] = LODWORD(v40.f64[0]);
  unint64_t v29 = vextq_s8(_Q4, _Q4, 8uLL).u64[0];
  _Q4.i32[0] = HIDWORD(v29);
  float32x2_t v30 = vdiv_f32(vsub_f32(v27, (float32x2_t)__PAIR64__(a3.u32[0], v29)), vsub_f32(*(float32x2_t *)_Q4.i8, (float32x2_t)__PAIR64__(a3.u32[0], v29)));
  __asm { FMOV            V3.2S, #1.0 }
  float32x2_t v36 = (float32x2_t)vbic_s8(vbsl_s8((int8x8_t)vcgt_f32(v30, _D3), (int8x8_t)_D3, (int8x8_t)v30), (int8x8_t)vcltz_f32(v30));
  __asm { FMOV            V4.2S, #3.0 }
  float32x2_t v37 = vmul_f32(vmul_f32(v36, v36), vmla_f32(*(float32x2_t *)_Q4.i8, (float32x2_t)0xC0000000C0000000, v36));
  v37.f32[0] = vmul_lane_f32(v37, v37, 1).f32[0];
  *(void *)&double result = COERCE_UNSIGNED_INT(vmlas_n_f32(sqrtf(v13) * v37.f32[0], 1.0 - v37.f32[0], *(float *)&v26));
  return result;
}

float32x4_t cikernel::_CIPortraitBlurDir(uint64_t a1, int8x16_t a2)
{
  float v80 = *(float *)a2.i32;
  float32x2_t v3 = (float32x2_t)vext_s8(*(int8x8_t *)a2.i8, (int8x8_t)*(_OWORD *)&vextq_s8(a2, a2, 8uLL), 4uLL);
  v4.f64[0] = *(float64_t *)CI::getDC((CI *)a1);
  int8x16_t v87 = (int8x16_t)v4;
  __asm { FMOV            V0.2S, #3.0 }
  float32x2_t v10 = vmul_f32(v3, _D0);
  float32x2_t v11 = vsub_f32(*(float32x2_t *)&v4.f64[0], v10);
  *(float *)&double v12 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v11, 1), *(float *)(a1 + 16), v11.f32[0]);
  LODWORD(v13) = *(_DWORD *)(a1 + 28);
  v14.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v11, 1), *(float *)&v13, v11.f32[0]);
  v11.f32[0] = *(float *)(a1 + 24) + *(float *)&v12;
  *(float *)v4.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v11.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)v17.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v11, v4, v12, v13, v15, v14, v16);
  float32x4_t v86 = v17;
  float32x2_t v18 = vadd_f32(v3, v3);
  *(float32x2_t *)v17.f32 = vsub_f32(*(float32x2_t *)v87.i8, v18);
  *(float *)&double v19 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v17.f32, 1), *(float *)(a1 + 16), v17.f32[0]);
  LODWORD(v20) = *(_DWORD *)(a1 + 28);
  v21.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v22.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v17.f32, 1), *(float *)&v20, v17.f32[0]);
  v17.f32[0] = *(float *)(a1 + 24) + *(float *)&v19;
  *(float *)v23.f64 = *(float *)v21.i32 + *(float *)v22.i32;
  v17.f32[1] = *(float *)v21.i32 + *(float *)v22.i32;
  *(double *)v25.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v17.i64, v23, v19, v20, v22, v21, v24);
  float32x4_t v85 = v25;
  *(float32x2_t *)v25.f32 = vsub_f32(*(float32x2_t *)v87.i8, v3);
  *(float *)&double v26 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v25.f32, 1), *(float *)(a1 + 16), v25.f32[0]);
  LODWORD(v27) = *(_DWORD *)(a1 + 28);
  v28.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v29.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v25.f32, 1), *(float *)&v27, v25.f32[0]);
  v25.f32[0] = *(float *)(a1 + 24) + *(float *)&v26;
  *(float *)v30.f64 = *(float *)v28.i32 + *(float *)v29.i32;
  v25.f32[1] = *(float *)v28.i32 + *(float *)v29.i32;
  *(double *)v32.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v25.i64, v30, v26, v27, v29, v28, v31);
  float32x4_t v84 = v32;
  LODWORD(v33) = *(_DWORD *)(a1 + 28);
  v32.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v87.i8, 1), *(float *)(a1 + 16), *(float *)v87.i32);
  LODWORD(v34) = *(_DWORD *)(a1 + 36);
  *(float *)v35.f64 = *(float *)&v34
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v87.i8, 1), *(float *)&v33, *(float *)v87.i32);
  v32.i32[1] = LODWORD(v35.f64[0]);
  *(double *)v38.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v32.i64, v35, v33, v34, v87, v36, v37);
  float32x4_t v83 = v38;
  *(float32x2_t *)v38.f32 = vadd_f32(v3, *(float32x2_t *)v87.i8);
  *(float *)&double v39 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v38.f32, 1), *(float *)(a1 + 16), v38.f32[0]);
  LODWORD(v40) = *(_DWORD *)(a1 + 28);
  v41.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v42.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v38.f32, 1), *(float *)&v40, v38.f32[0]);
  v38.f32[0] = *(float *)(a1 + 24) + *(float *)&v39;
  *(float *)v43.f64 = *(float *)v41.i32 + *(float *)v42.i32;
  v38.f32[1] = *(float *)v41.i32 + *(float *)v42.i32;
  *(double *)v45.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v38.i64, v43, v39, v40, v42, v41, v44);
  float32x4_t v82 = v45;
  *(float32x2_t *)v45.f32 = vadd_f32(v18, *(float32x2_t *)v87.i8);
  *(float *)&double v46 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v45.f32, 1), *(float *)(a1 + 16), v45.f32[0]);
  LODWORD(v47) = *(_DWORD *)(a1 + 28);
  v48.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v49.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v45.f32, 1), *(float *)&v47, v45.f32[0]);
  v45.f32[0] = *(float *)(a1 + 24) + *(float *)&v46;
  *(float *)v50.f64 = *(float *)v48.i32 + *(float *)v49.i32;
  v45.f32[1] = *(float *)v48.i32 + *(float *)v49.i32;
  *(double *)v52.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v45.i64, v50, v46, v47, v49, v48, v51);
  float32x4_t v81 = v52;
  *(float32x2_t *)v52.f32 = vadd_f32(v10, *(float32x2_t *)v87.i8);
  *(float *)&double v53 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v52.f32, 1), *(float *)(a1 + 16), v52.f32[0]);
  LODWORD(v54) = *(_DWORD *)(a1 + 28);
  v55.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v56.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v52.f32, 1), *(float *)&v54, v52.f32[0]);
  v52.f32[0] = *(float *)(a1 + 24) + *(float *)&v53;
  *(float *)v57.f64 = *(float *)v55.i32 + *(float *)v56.i32;
  v52.f32[1] = *(float *)v55.i32 + *(float *)v56.i32;
  *(double *)v59.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v52.i64, v57, v53, v54, v56, v55, v58);
  float32x4_t v88 = v59;
  float32x4_t v77 = vmulq_f32(v86, v86);
  float32x4_t v78 = vmulq_f32(v59, v59);
  float32x4_t v79 = vmulq_f32(v83, v83);
  v59.f32[0] = fmaxf(vmuls_lane_f32(v80, v79, 3), 0.01);
  v59.f32[0] = -1.0 / ((v59.f32[0] + v59.f32[0]) * v59.f32[0]);
  _S0 = exp(v59.f32[0]);
  _S1 = (float)((float)(_S0 * _S0) * _S0) * _S0;
  _S2 = (float)(_S1 * _S1) * _S0;
  _V5.S[3] = v77.i32[3];
  __asm { FMLA            S3, S2, V5.S[3] }
  _Q18 = vmulq_f32(v84, v84);
  _Q17 = vmulq_f32(v82, v82);
  __asm
  {
    FMLA            S3, S0, V18.S[3]
    FMLA            S3, S0, V17.S[3]
  }
  _Q16 = vmulq_f32(v81, v81);
  _V7.S[3] = v78.i32[3];
  __asm
  {
    FMLA            S3, S1, V16.S[3]
    FMLA            S3, S2, V7.S[3]
  }
  float v73 = 1.0 / _S3;
  float v74 = _S1 * v73;
  float v75 = _S2 * v73;
  float32x4_t result = vaddq_f32(vmulq_n_f32(v82, vmuls_lane_f32(v73 * _S0, _Q17, 3)), vaddq_f32(vmulq_n_f32(v83, vmuls_lane_f32(v73, v79, 3)), vaddq_f32(vmulq_n_f32(v84, vmuls_lane_f32(v73 * _S0, _Q18, 3)), vaddq_f32(vmulq_n_f32(v85, vmuls_lane_f32(v74, vmulq_f32(v85, v85), 3)), vmulq_n_f32(v86, vmuls_lane_f32(v75, v77, 3))))));
  result.i64[0] = vaddq_f32(vmulq_n_f32(v88, vmuls_lane_f32(v75, v78, 3)), vaddq_f32(vmulq_n_f32(v81, vmuls_lane_f32(v74, _Q16, 3)), result)).u64[0];
  result.i32[3] = v83.i32[3];
  return result;
}

double cikernel::_CIPortraitBlurBlendWithMaskFromAlpha(float32x4_t a1, float32x4_t a2, float32x4_t a3)
{
  float v3 = (float)(vmuls_lane_f32(vmuls_lane_f32(vmulq_laneq_f32(a3, a3, 3).f32[0], a2, 3), a2, 3) - a3.f32[1]) / a3.f32[2];
  if (v3 <= 1.0) {
    float v4 = v3;
  }
  else {
    float v4 = 1.0;
  }
  if (v3 < 0.0) {
    float v4 = 0.0;
  }
  a2.f32[3] = v4;
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - v4), a2, v4).u64[0];
  return result;
}

void sub_19381B3EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
}

void sub_19381BA00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t nRingsFromTuningParameters(NSDictionary *a1, float a2, uint64_t a3, NSNumber *a4)
{
  SDOFRenderingValue(&cfstr_Nrings.isa, a1);
  uint64_t v9 = (int)v8;
  SDOFRenderingValue(&cfstr_Minimumsimulat.isa, a1);
  float v11 = v10;
  SDOFSimpleLensModelValue(@"maximumSimulatedAperture", a1);
  float v13 = v12;
  SDOFSimpleLensModelValue(@"defaultSimulatedAperture", a1);
  float v15 = v14;
  [(NSNumber *)a4 floatValue];
  float v17 = v16;
  if (a2 <= 1.0) {
    float v18 = a2;
  }
  else {
    float v18 = 1.0;
  }
  double v19 = v18;
  if (v18 >= 1.0 || v11 <= 0.0 || v13 <= 0.0 || v15 <= 0.0)
  {
    if (v19 < 0.5) {
      double v19 = 0.5;
    }
    float v23 = v19 * (double)(int)v9;
    float v24 = ceilf(v23);
  }
  else
  {
    if (v17 >= v15)
    {
      float v25 = 0.699999988 / (float)(v13 - v15) * (float)(v17 - v15) + 1.0;
      float v21 = pow(v19, 0.2);
      float v22 = (float)(int)v9 * v25;
    }
    else
    {
      float v20 = (float)((float)((float)(v17 - v11) / (float)(v15 - v11)) * -0.5) + 1.0;
      float v21 = pow(v19, 0.0833333333);
      float v22 = v20 * (float)(int)v9;
    }
    float v24 = v22 * v21;
  }
  unsigned int v26 = (int)v24;
  if ((int)v24 <= 4) {
    unsigned int v26 = 4;
  }
  if (a3 != 2)
  {
    if (v9 == 4) {
      unsigned int v27 = 2;
    }
    else {
      unsigned int v27 = 4;
    }
    if (a3 == 1) {
      return v27;
    }
    else {
      return v26;
    }
  }
  return v9;
}

void sub_19381CF28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
}

double cikernel::_sparserendering_add_noise(float32x4_t a1, float a2, double a3)
{
  double v3 = a2 * 10.0 + -5.0;
  *(float *)&double v3 = v3;
  float32x4_t v4 = vmulq_f32(a1, (float32x4_t)xmmword_193950AB0);
  *(float *)&double v3 = vmuls_lane_f32((float)(1.0 - *(float *)&a3)+ vmuls_n_f32(*(float *)&a3, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).f32[0]), *(float32x2_t *)&a3, 1)* *(float *)&v3;
  float32x4_t v5 = vaddq_f32(a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v3, 0));
  v5.i32[3] = 0;
  float32x4_t v6 = vmaxnmq_f32(v5, (float32x4_t)0);
  v6.i32[3] = 0;
  float32x4_t v7 = vminnmq_f32(v6, (float32x4_t)xmmword_1939508C0);
  v7.i32[3] = a1.i32[3];
  float32x4_t v8 = vmaxnmq_f32(v7, (float32x4_t)0);
  __asm { FMOV            V1.4S, #1.0 }
  *(void *)&double result = vminnmq_f32(v8, _Q1).u64[0];
  return result;
}

void CI::f4_s_s_f2(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  float v11 = (double (*)(void *, __n128, __n128, double))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  int v14 = *(_DWORD *)(v10 + 40);
  uint64_t v15 = *(void *)(v10 + 32);
  int v16 = *(_DWORD *)(v10 + 64);
  uint64_t v17 = *(void *)(v10 + 56);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 80)), a2);
  }
  float v18 = (double *)(a3 + 16 * v17);
  if (v16 != 5) {
    float v18 = (double *)((char *)a2 + 64 * v17);
  }
  double v19 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5) {
    double v19 = (__n128 *)((char *)a2 + 64 * v15);
  }
  float v20 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    float v20 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v21 = v11(a1, *v20, *v19, *v18);
  *(_OWORD *)(a3 + 16 * a7) = v21;
}

double cikernel::_CIPortraitBlurBlendWithMaskMatteFromAlpha(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  float v4 = vmuls_lane_f32(vmuls_lane_f32(a4.f32[0], a2, 3), a2, 3);
  float v5 = (float)(v4 - a4.f32[1]) / a4.f32[2];
  if (v5 <= 1.0) {
    float v6 = (float)(v4 - a4.f32[1]) / a4.f32[2];
  }
  else {
    float v6 = 1.0;
  }
  if (v5 < 0.0) {
    float v6 = 0.0;
  }
  float v7 = vmulq_laneq_f32(a3, a4, 3).f32[0];
  float v8 = 1.0 - v7;
  if (v7 > 1.0) {
    float v8 = 0.0;
  }
  if (v7 >= 0.0) {
    float v9 = v8;
  }
  else {
    float v9 = 1.0;
  }
  a2.i32[3] = fminf(v6, v9);
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - a2.f32[3]), a2, a2.f32[3]).u64[0];
  return result;
}

double cikernel::_CIPortraitBlurBlendWithMaskMatteFromAlphaYCC(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float a5)
{
  float v6 = vmuls_lane_f32(vmuls_lane_f32(a4.f32[0], a2, 3), a2, 3);
  float v7 = (float)(v6 - a4.f32[1]) / a4.f32[2];
  if (v7 <= 1.0) {
    float v8 = (float)(v6 - a4.f32[1]) / a4.f32[2];
  }
  else {
    float v8 = 1.0;
  }
  if (v7 < 0.0) {
    float v8 = 0.0;
  }
  float v9 = a5 * a3.f32[0];
  float v10 = 1.0 - (float)(a5 * a3.f32[0]);
  if (v9 > 1.0) {
    float v10 = 0.0;
  }
  if (v9 >= 0.0) {
    float v11 = v10;
  }
  else {
    float v11 = 1.0;
  }
  float v12 = fminf(v8, v11);
  float32x4_t v13 = vmlaq_laneq_f32(vmulq_n_f32(a1, 1.0 - a2.f32[3]), a2, a2, 3);
  double result = *(double *)v13.i64;
  if (v12 < 1.0)
  {
    float32x4_t v15 = vmulq_laneq_f32(a3, a4, 3);
    float v16 = 1.0 - v15.f32[0];
    if (v15.f32[0] > 1.0) {
      float v16 = 0.0;
    }
    if (v15.f32[0] >= 0.0) {
      v15.f32[0] = v16;
    }
    else {
      v15.f32[0] = 1.0;
    }
    v15.f32[0] = fminf(v8, v15.f32[0]);
    v15.f32[1] = v12;
    v15.f32[2] = v12;
    *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(v15, 1.0 - v12), v13, v12).u64[0];
  }
  return result;
}

void CI::f4_s_s_s_f4_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  float v10 = *(double (**)(__n128, __n128, __n128, __n128, float))(a1 + 24);
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  int v13 = *(_DWORD *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  int v15 = *(_DWORD *)(v9 + 64);
  uint64_t v16 = *(void *)(v9 + 56);
  int v17 = *(_DWORD *)(v9 + 88);
  uint64_t v18 = *(void *)(v9 + 80);
  uint64_t v19 = *(void *)(v9 + 104);
  if (*(unsigned char *)(a1 + 64))
  {
    int v25 = *(_DWORD *)(v9 + 88);
    int v26 = *(_DWORD *)(v9 + 64);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 128)), a2);
    int v17 = v25;
    int v15 = v26;
  }
  float v20 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5) {
    float v20 = (__n128 *)((char *)a2 + 64 * v18);
  }
  long long v21 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5) {
    long long v21 = (__n128 *)((char *)a2 + 64 * v16);
  }
  float v22 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    float v22 = (__n128 *)((char *)a2 + 64 * v14);
  }
  float v23 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    float v23 = (__n128 *)((char *)a2 + 64 * v12);
  }
  *(double *)&long long v24 = v10(*v23, *v22, *v21, *v20, *((float *)a2 + 16 * v19));
  *(_OWORD *)(a3 + 16 * a7) = v24;
}

uint64_t dictionaryDeepCopy(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if ([a1 count])
  {
    float32x2_t v2 = (void *)[MEMORY[0x1E4F1CA48] array];
    long long v14 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    long long v17 = 0u;
    uint64_t v3 = [a1 countByEnumeratingWithState:&v14 objects:v18 count:16];
    if (!v3) {
      return objc_msgSend(MEMORY[0x1E4F1C9E8], "dictionaryWithObjects:forKeys:", v2, objc_msgSend(a1, "allKeys"));
    }
    uint64_t v4 = v3;
    uint64_t v5 = *(void *)v15;
    while (1)
    {
      uint64_t v6 = 0;
      do
      {
        if (*(void *)v15 != v5) {
          objc_enumerationMutation(a1);
        }
        float v7 = (void *)[a1 valueForKey:*(void *)(*((void *)&v14 + 1) + 8 * v6)];
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          uint64_t v8 = dictionaryDeepCopy(v7);
          goto LABEL_11;
        }
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          uint64_t v8 = arrayDeepCopy(v7);
LABEL_11:
          uint64_t v9 = (void *)v8;
          float v10 = v2;
LABEL_12:
          [v10 addObject:v9];
          goto LABEL_13;
        }
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0 || (objc_opt_respondsToSelector() & 1) == 0)
        {
          float v10 = v2;
          uint64_t v9 = v7;
          goto LABEL_12;
        }
        int v11 = (void *)[v7 copy];
        [v2 addObject:v11];

LABEL_13:
        ++v6;
      }
      while (v4 != v6);
      uint64_t v12 = [a1 countByEnumeratingWithState:&v14 objects:v18 count:16];
      uint64_t v4 = v12;
      if (!v12) {
        return objc_msgSend(MEMORY[0x1E4F1C9E8], "dictionaryWithObjects:forKeys:", v2, objc_msgSend(a1, "allKeys"));
      }
    }
  }
  return MEMORY[0x1E4F1CC08];
}

uint64_t scaleImageWithQuality(void *a1, _OWORD *a2)
{
  if (isMetalFamily3_onceToken != -1) {
    dispatch_once(&isMetalFamily3_onceToken, &__block_literal_global_57);
  }
  long long v4 = a2[1];
  v6[0] = *a2;
  v6[1] = v4;
  void v6[2] = a2[2];
  if (isMetalFamily3_supports) {
    return [a1 imageByApplyingTransform:v6 highQualityDownsample:1];
  }
  else {
    return [a1 imageByApplyingTransform:v6];
  }
}

uint64_t arrayDeepCopy(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if ([a1 count])
  {
    float32x2_t v2 = (void *)[MEMORY[0x1E4F1CA48] array];
    long long v14 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    long long v17 = 0u;
    uint64_t v3 = [a1 countByEnumeratingWithState:&v14 objects:v18 count:16];
    if (!v3) {
      return [MEMORY[0x1E4F1C978] arrayWithArray:v2];
    }
    uint64_t v4 = v3;
    uint64_t v5 = *(void *)v15;
    while (1)
    {
      uint64_t v6 = 0;
      do
      {
        if (*(void *)v15 != v5) {
          objc_enumerationMutation(a1);
        }
        float v7 = *(void **)(*((void *)&v14 + 1) + 8 * v6);
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          uint64_t v8 = dictionaryDeepCopy(v7);
          goto LABEL_11;
        }
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          uint64_t v8 = arrayDeepCopy(v7);
LABEL_11:
          uint64_t v9 = (void *)v8;
          float v10 = v2;
LABEL_12:
          [v10 addObject:v9];
          goto LABEL_13;
        }
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0 || (objc_opt_respondsToSelector() & 1) == 0)
        {
          float v10 = v2;
          uint64_t v9 = v7;
          goto LABEL_12;
        }
        int v11 = (void *)[v7 copy];
        [v2 addObject:v11];

LABEL_13:
        ++v6;
      }
      while (v4 != v6);
      uint64_t v12 = [a1 countByEnumeratingWithState:&v14 objects:v18 count:16];
      uint64_t v4 = v12;
      if (!v12) {
        return [MEMORY[0x1E4F1C978] arrayWithArray:v2];
      }
    }
  }
  return MEMORY[0x1E4F1CBF0];
}

void __isMetalFamily3_block_invoke()
{
  id v0 = MTLCreateSystemDefaultDevice();
  isMetalFamily3_supports = [v0 supportsFamily:1003];
}

double GetAdaptationMatrix(const double *a1, const double *a2, double *a3)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  double v4 = a1[1];
  double v5 = a1[2];
  double v6 = v4 * 0.2664 + *a1 * 0.8951 + v5 * -0.1614;
  double v7 = v4 * 1.7135 + *a1 * -0.7502 + v5 * 0.0367;
  double v8 = v4 * -0.0685 + *a1 * 0.0389 + v5 * 1.0296;
  double v9 = a2[1];
  double v10 = a2[2];
  double v11 = v9 * 0.2664 + *a2 * 0.8951 + v10 * -0.1614;
  double v12 = v9 * 1.7135 + *a2 * -0.7502 + v10 * 0.0367;
  double v13 = v9 * -0.0685 + *a2 * 0.0389 + v10 * 1.0296;
  uint64_t v17 = 0;
  uint64_t v20 = 0;
  long long v19 = 0u;
  long long v16 = 0u;
  double v15 = v11 / v6;
  double v18 = v12 / v7;
  double v21 = v13 / v8;
  MatrixMatrix(GetAdaptationMatrix(double const*,double const*,double *)::Bradford_mtx, &v15, a3);

  return MatrixMatrix(a3, GetAdaptationMatrix(double const*,double const*,double *)::invBradford_mtx, a3);
}

double MatrixMatrix(double *a1, double *a2, double *a3)
{
  double v3 = *a1;
  double v4 = a1[1];
  double v5 = a1[2];
  double v6 = a1[3];
  double v7 = a1[4];
  double v8 = a1[5];
  double v9 = a1[6];
  double v10 = a1[7];
  double v11 = a1[8];
  double v12 = *a2;
  double v13 = a2[1];
  double v14 = a2[2];
  double v15 = a2[3];
  double v16 = a2[4];
  double v17 = a2[5];
  double v18 = a2[6];
  double v19 = a2[7];
  double v20 = a2[8];
  double v21 = v7 * v13 + v4 * *a2 + v10 * v14;
  *a3 = v6 * v13 + *a1 * *a2 + v9 * v14;
  a3[1] = v21;
  a3[2] = v8 * v13 + v5 * v12 + v11 * v14;
  a3[3] = v6 * v16 + v3 * v15 + v9 * v17;
  a3[4] = v7 * v16 + v4 * v15 + v10 * v17;
  a3[5] = v8 * v16 + v5 * v15 + v11 * v17;
  a3[6] = v6 * v19 + v3 * v18 + v9 * v20;
  a3[7] = v7 * v19 + v4 * v18 + v10 * v20;
  double result = v8 * v19 + v5 * v18 + v11 * v20;
  a3[8] = result;
  return result;
}

void ___ZL17GetLinearAdobeRGBv_block_invoke()
{
  id v0 = CGDataProviderCreateWithData(0, &GetLinearAdobeRGB(void)::data, 0x210uLL, 0);
  GetLinearAdobeRGB(void)::space = (uint64_t)CGColorSpaceCreateICCBased(3uLL, 0, v0, 0);

  CFRelease(v0);
}

double cikernel::_convertUsingColorMatrix(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  *(void *)&double result = vaddq_f32(vmulq_laneq_f32(a4, a1, 2), vaddq_f32(vmulq_n_f32(a2, a1.f32[0]), vmulq_lane_f32(a3, *(float32x2_t *)a1.f32, 1))).u64[0];
  return result;
}

double cikernel::_localBoost(float32x4_t a1, int32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5, float32x4_t a6, float a7)
{
  float32x4_t v7 = vmulq_f32(a1, a1);
  float32x4_t v8 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 0);
  float32x4_t v9 = vmulq_f32(a1, v7);
  v8.i32[0] = v9.i32[0];
  v8.i64[1] = __PAIR64__(1.0, vdupq_lane_s32(*(int32x2_t *)&a1, 0).u32[2]);
  int8x16_t v10 = (int8x16_t)vmulq_f32(a3, v8);
  int32x2_t v11 = (int32x2_t)vadd_f32(*(float32x2_t *)v10.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v10, v10, 8uLL));
  int8x16_t v12 = (int8x16_t)vmulq_f32(a4, v8);
  int32x2_t v13 = (int32x2_t)vadd_f32(*(float32x2_t *)v12.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v12, v12, 8uLL));
  int8x16_t v14 = (int8x16_t)vmulq_f32(a5, v8);
  int32x2_t v15 = (int32x2_t)vadd_f32(*(float32x2_t *)v14.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v14, v14, 8uLL));
  int8x16_t v16 = (int8x16_t)vmulq_f32(v8, a6);
  int32x2_t v17 = (int32x2_t)vadd_f32(*(float32x2_t *)v16.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v16, v16, 8uLL));
  float32x4_t v18 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a1.f32, 1);
  v18.i64[0] = __PAIR64__(v7.u32[1], v9.u32[1]);
  *(double *)v16.i64 = a7;
  v18.i32[3] = v8.i32[3];
  int8x16_t v19 = (int8x16_t)vmulq_f32(a3, v18);
  *(float32x2_t *)v19.i8 = vadd_f32(*(float32x2_t *)v19.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v19, v19, 8uLL));
  *(float32x2_t *)v19.i8 = vadd_f32((float32x2_t)vzip1_s32(v11, *(int32x2_t *)v19.i8), (float32x2_t)vzip2_s32(v11, *(int32x2_t *)v19.i8));
  int8x16_t v20 = (int8x16_t)vmulq_f32(a4, v18);
  *(float32x2_t *)v20.i8 = vadd_f32(*(float32x2_t *)v20.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v20, v20, 8uLL));
  *(float32x2_t *)v20.i8 = vadd_f32((float32x2_t)vzip1_s32(v13, *(int32x2_t *)v20.i8), (float32x2_t)vzip2_s32(v13, *(int32x2_t *)v20.i8));
  int8x16_t v21 = (int8x16_t)vmulq_f32(v18, a5);
  *(float32x2_t *)v21.i8 = vadd_f32(*(float32x2_t *)v21.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v21, v21, 8uLL));
  *(float32x2_t *)v21.i8 = vadd_f32((float32x2_t)vzip1_s32(v15, *(int32x2_t *)v21.i8), (float32x2_t)vzip2_s32(v15, *(int32x2_t *)v21.i8));
  int8x16_t v22 = (int8x16_t)vmulq_f32(v18, a6);
  *(float32x2_t *)v22.i8 = vadd_f32(*(float32x2_t *)v22.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v22, v22, 8uLL));
  *(float32x2_t *)v22.i8 = vadd_f32((float32x2_t)vzip1_s32(v17, *(int32x2_t *)v22.i8), (float32x2_t)vzip2_s32(v17, *(int32x2_t *)v22.i8));
  __asm { FMOV            V23.2D, #-1.0 }
  float64x2_t v28 = vaddq_f64(vcvtq_f64_f32(*(float32x2_t *)a1.f32), _Q23);
  __asm { FMOV            V23.2D, #1.0 }
  float32x4_t v30 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2);
  v30.i32[0] = v9.i32[2];
  v30.i64[1] = __PAIR64__(1.0, a1.u32[2]);
  int8x16_t v31 = (int8x16_t)vmulq_f32(a3, v30);
  *(float32x2_t *)v31.i8 = vadd_f32(*(float32x2_t *)v31.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v31, v31, 8uLL));
  v19.u64[1] = (unint64_t)vadd_f32(*(float32x2_t *)v31.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v31.i8, 1));
  *(float32x2_t *)v31.i8 = vcvt_f32_f64(vmlaq_n_f64(_Q23, v28, *(double *)v16.i64));
  int8x16_t v32 = (int8x16_t)vmulq_f32(a4, v30);
  *(float32x2_t *)v32.i8 = vadd_f32(*(float32x2_t *)v32.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL));
  v20.u64[1] = (unint64_t)vadd_f32(*(float32x2_t *)v32.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v32.i8, 1));
  int8x16_t v33 = (int8x16_t)vmulq_f32(a5, v30);
  *(float32x2_t *)v33.i8 = vadd_f32(*(float32x2_t *)v33.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v33, v33, 8uLL));
  v21.u64[1] = (unint64_t)vadd_f32(*(float32x2_t *)v33.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v33.i8, 1));
  int8x16_t v34 = (int8x16_t)vmulq_f32(v30, a6);
  *(float32x2_t *)v34.i8 = vadd_f32(*(float32x2_t *)v34.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL));
  v22.u64[1] = (unint64_t)vadd_f32(*(float32x2_t *)v34.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v34.i8, 1));
  *(float *)v34.i32 = (a1.f32[2] + -1.0) * *(double *)v16.i64 + 1.0;
  v31.i32[2] = v34.i32[0];
  *(void *)&double result = vbicq_s8(vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.i8, 0))), v19, vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.i8, 1))), v20, vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(a1, (float32x4_t)vdupq_laneq_s32(a2, 2))), v21, vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(a1, (float32x4_t)vdupq_laneq_s32(a2, 3))), v22, v31)))), (int8x16_t)vcltzq_f32(a1)).u64[0];
  return result;
}

void CI::f4_s_f4_f4_f4_f4_f4_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  int8x16_t v10 = *(double (**)(__n128, __n128, __n128, __n128, __n128, __n128, float))(a1 + 24);
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  int v13 = *(_DWORD *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  int v15 = *(_DWORD *)(v9 + 64);
  uint64_t v16 = *(void *)(v9 + 56);
  int v17 = *(_DWORD *)(v9 + 88);
  uint64_t v18 = *(void *)(v9 + 80);
  int v19 = *(_DWORD *)(v9 + 112);
  uint64_t v20 = *(void *)(v9 + 104);
  int v21 = *(_DWORD *)(v9 + 136);
  uint64_t v22 = *(void *)(v9 + 128);
  uint64_t v23 = *(void *)(v9 + 152);
  if (*(unsigned char *)(a1 + 64))
  {
    int8x16_t v34 = *(double (**)(__n128, __n128, __n128, __n128, __n128, __n128, float))(a1 + 24);
    uint64_t v32 = *(void *)(v9 + 8);
    int v35 = *(_DWORD *)(v9 + 64);
    int v36 = *(_DWORD *)(v9 + 40);
    int v33 = *(_DWORD *)(v9 + 88);
    int v31 = *(_DWORD *)(v9 + 136);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 176)), a2);
    int v21 = v31;
    int v17 = v33;
    int v15 = v35;
    int v13 = v36;
    uint64_t v12 = v32;
    int8x16_t v10 = v34;
  }
  long long v24 = (__n128 *)(a3 + 16 * v22);
  if (v21 != 5) {
    long long v24 = (__n128 *)((char *)a2 + 64 * v22);
  }
  int v25 = (__n128 *)(a3 + 16 * v20);
  if (v19 != 5) {
    int v25 = (__n128 *)((char *)a2 + 64 * v20);
  }
  int v26 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5) {
    int v26 = (__n128 *)((char *)a2 + 64 * v18);
  }
  unsigned int v27 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5) {
    unsigned int v27 = (__n128 *)((char *)a2 + 64 * v16);
  }
  float64x2_t v28 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    float64x2_t v28 = (__n128 *)((char *)a2 + 64 * v14);
  }
  int8x16_t v29 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    int8x16_t v29 = (__n128 *)((char *)a2 + 64 * v12);
  }
  *(double *)&long long v30 = v10(*v29, *v28, *v27, *v26, *v25, *v24, *((float *)a2 + 16 * v23));
  *(_OWORD *)(a3 + 16 * a7) = v30;
}

double cikernel::_boostRGB(float32x4_t a1, int32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5, float32x4_t a6, float a7)
{
  float32x4_t v7 = vmulq_f32(a1, a1);
  float32x4_t v8 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 0);
  float32x4_t v9 = vmulq_f32(a1, v7);
  v8.i32[0] = v9.i32[0];
  v8.i64[1] = __PAIR64__(1.0, vdupq_lane_s32(*(int32x2_t *)&a1, 0).u32[2]);
  int8x16_t v10 = (int8x16_t)vmulq_f32(a3, v8);
  *(float32x2_t *)v10.i8 = vadd_f32(*(float32x2_t *)v10.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v10, v10, 8uLL));
  int8x16_t v11 = (int8x16_t)vmulq_f32(a4, v8);
  int32x2_t v12 = (int32x2_t)vadd_f32(*(float32x2_t *)v11.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v11, v11, 8uLL));
  int8x16_t v13 = (int8x16_t)vmulq_f32(a5, v8);
  int32x2_t v14 = (int32x2_t)vadd_f32(*(float32x2_t *)v13.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v13, v13, 8uLL));
  int8x16_t v15 = (int8x16_t)vmulq_f32(v8, a6);
  *(float32x2_t *)v15.i8 = vadd_f32(*(float32x2_t *)v15.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v15, v15, 8uLL));
  float32x4_t v16 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a1.f32, 1);
  v16.i64[0] = __PAIR64__(v7.u32[1], v9.u32[1]);
  v16.i32[3] = 1.0;
  int8x16_t v17 = (int8x16_t)vmulq_f32(a3, v16);
  *(float32x2_t *)v17.i8 = vadd_f32(*(float32x2_t *)v17.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v17, v17, 8uLL));
  *(float32x2_t *)v10.i8 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v10.i8, *(int32x2_t *)v17.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v10.i8, *(int32x2_t *)v17.i8));
  float32x4_t v18 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2);
  v18.i32[0] = v9.i32[2];
  v18.i64[1] = __PAIR64__(1.0, a1.u32[2]);
  int8x16_t v19 = (int8x16_t)vmulq_f32(a3, v18);
  *(float32x2_t *)v19.i8 = vadd_f32(*(float32x2_t *)v19.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v19, v19, 8uLL));
  v10.i64[1] = vadd_f32(*(float32x2_t *)v19.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v19.i8, 1)).u32[0];
  int8x16_t v20 = (int8x16_t)vmulq_f32(a4, v16);
  *(float32x2_t *)v20.i8 = vadd_f32(*(float32x2_t *)v20.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v20, v20, 8uLL));
  int8x16_t v21 = (int8x16_t)vmulq_f32(a4, v18);
  *(float32x2_t *)v21.i8 = vadd_f32(*(float32x2_t *)v21.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v21, v21, 8uLL));
  *(float32x2_t *)v20.i8 = vadd_f32((float32x2_t)vzip1_s32(v12, *(int32x2_t *)v20.i8), (float32x2_t)vzip2_s32(v12, *(int32x2_t *)v20.i8));
  v20.i64[1] = vadd_f32(*(float32x2_t *)v21.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v21.i8, 1)).u32[0];
  int8x16_t v22 = (int8x16_t)vmulq_f32(v16, a5);
  *(float32x2_t *)v22.i8 = vadd_f32(*(float32x2_t *)v22.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v22, v22, 8uLL));
  *(float32x2_t *)v22.i8 = vadd_f32((float32x2_t)vzip1_s32(v14, *(int32x2_t *)v22.i8), (float32x2_t)vzip2_s32(v14, *(int32x2_t *)v22.i8));
  int8x16_t v23 = (int8x16_t)vmulq_f32(a5, v18);
  *(float32x2_t *)v23.i8 = vadd_f32(*(float32x2_t *)v23.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v23, v23, 8uLL));
  v22.i64[1] = vadd_f32(*(float32x2_t *)v23.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v23.i8, 1)).u32[0];
  int8x16_t v24 = (int8x16_t)vmulq_f32(v16, a6);
  *(float32x2_t *)v24.i8 = vadd_f32(*(float32x2_t *)v24.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL));
  *(float32x2_t *)v24.i8 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v15.i8, *(int32x2_t *)v24.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v15.i8, *(int32x2_t *)v24.i8));
  int8x16_t v25 = (int8x16_t)vmulq_f32(v18, a6);
  *(float32x2_t *)v25.i8 = vadd_f32(*(float32x2_t *)v25.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v25, v25, 8uLL));
  v24.i64[1] = vadd_f32(*(float32x2_t *)v25.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v25.i8, 1)).u32[0];
  *(double *)v25.i64 = a7;
  __asm { FMOV            V16.2D, #-1.0 }
  float64x2_t v31 = vaddq_f64(vcvtq_f64_f32(*(float32x2_t *)a1.f32), _Q16);
  __asm { FMOV            V16.2D, #1.0 }
  *(float32x2_t *)&v31.f64[0] = vcvt_f32_f64(vmlaq_n_f64(_Q16, v31, *(double *)v25.i64));
  *(float *)v25.i32 = (a1.f32[2] + -1.0) * *(double *)v25.i64 + 1.0;
  *(void *)&v31.f64[1] = v25.u32[0];
  float32x4_t v33 = (float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.i8, 0))), v10, vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.i8, 1))), v20, vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(a1, (float32x4_t)vdupq_laneq_s32(a2, 2))), v22, vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(a1, (float32x4_t)vdupq_laneq_s32(a2, 3))), v24, (int8x16_t)v31)))), (int8x16_t)vcltzq_f32(a1));
  *(void *)&double result = vbicq_s8((int8x16_t)v33, (int8x16_t)vcltzq_f32(v33)).u64[0];
  return result;
}

double cikernel::_boostRGBLNoGamma(float32x4_t a1, int32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5, float32x4_t a6, float a7)
{
  float32x4_t v7 = vmulq_f32(a1, a1);
  float32x4_t v8 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 0);
  float32x4_t v9 = vmulq_f32(a1, v7);
  v8.i32[0] = v9.i32[0];
  v8.i64[1] = __PAIR64__(1.0, vdupq_lane_s32(*(int32x2_t *)&a1, 0).u32[2]);
  int8x16_t v10 = (int8x16_t)vmulq_f32(a3, v8);
  int32x2_t v11 = (int32x2_t)vadd_f32(*(float32x2_t *)v10.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v10, v10, 8uLL));
  int8x16_t v12 = (int8x16_t)vmulq_f32(a4, v8);
  int32x2_t v13 = (int32x2_t)vadd_f32(*(float32x2_t *)v12.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v12, v12, 8uLL));
  float32x4_t v14 = vmulq_f32(a5, v8);
  *(float32x2_t *)v14.f32 = vadd_f32(*(float32x2_t *)v14.f32, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v14, (int8x16_t)v14, 8uLL));
  float32x4_t v15 = vmulq_f32(v8, a6);
  float32x4_t v16 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a1.f32, 1);
  v16.i64[0] = __PAIR64__(v7.u32[1], v9.u32[1]);
  *(float32x2_t *)v15.f32 = vadd_f32(*(float32x2_t *)v15.f32, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v15, (int8x16_t)v15, 8uLL));
  v16.i32[3] = 1.0;
  int8x16_t v17 = (int8x16_t)vmulq_f32(a3, v16);
  int32x2_t v18 = (int32x2_t)vadd_f32(*(float32x2_t *)v17.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v17, v17, 8uLL));
  int8x16_t v19 = (int8x16_t)vmulq_f32(a4, v16);
  int32x2_t v20 = (int32x2_t)vadd_f32(*(float32x2_t *)v19.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v19, v19, 8uLL));
  int8x16_t v21 = (int8x16_t)vmulq_f32(v16, a5);
  *(float32x2_t *)v21.i8 = vadd_f32(*(float32x2_t *)v21.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v21, v21, 8uLL));
  int8x16_t v22 = (int8x16_t)vmulq_f32(v16, a6);
  float32x4_t v23 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2);
  v23.i32[0] = v9.i32[2];
  v23.i64[1] = __PAIR64__(1.0, a1.u32[2]);
  *(float32x2_t *)v7.f32 = vadd_f32(*(float32x2_t *)v22.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v22, v22, 8uLL));
  int8x16_t v24 = (int8x16_t)vmulq_f32(a3, v23);
  int32x2_t v25 = (int32x2_t)vadd_f32(*(float32x2_t *)v24.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL));
  int8x16_t v26 = (int8x16_t)vmulq_f32(a4, v23);
  int32x2_t v27 = (int32x2_t)vadd_f32(*(float32x2_t *)v26.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL));
  int8x16_t v28 = (int8x16_t)vmulq_f32(a5, v23);
  *(float32x2_t *)v22.i8 = vadd_f32(*(float32x2_t *)v28.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL));
  float32x4_t v29 = vmulq_f32(a1, (float32x4_t)xmmword_193950AB0);
  float32x4_t v30 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v29, 2), vaddq_f32(v29, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v29.f32, 1)));
  int32x2_t v31 = (int32x2_t)vmulq_f32(v30, v30).u64[0];
  float32x4_t v32 = (float32x4_t)vdupq_lane_s32(v31, 0);
  float32x4_t v33 = vmulq_f32(v23, a6);
  v32.i32[0] = vmuls_n_f32(v30.f32[0], *(float *)v31.i32);
  v32.i64[1] = __PAIR64__(1.0, vdupq_lane_s32(*(int32x2_t *)&v30, 0).u32[2]);
  int8x16_t v34 = (int8x16_t)vmulq_f32(a3, v32);
  *(float32x2_t *)v34.i8 = vadd_f32(*(float32x2_t *)v34.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL));
  *(int32x2_t *)v35.f32 = vzip1_s32(v11, v18);
  v35.i64[1] = __PAIR64__(v34.u32[0], v25.u32[0]);
  *(int32x2_t *)v36.f32 = vzip2_s32(v11, v18);
  v36.i32[2] = vdup_lane_s32(v25, 1).u32[0];
  v36.i32[3] = v34.i32[1];
  *(float32x2_t *)v34.i8 = vadd_f32(*(float32x2_t *)v33.f32, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v33, (int8x16_t)v33, 8uLL));
  int8x16_t v37 = (int8x16_t)vmulq_f32(a4, v32);
  *(int32x2_t *)v33.f32 = vzip1_s32(v13, v20);
  v33.i32[2] = v27.i32[0];
  *(float32x2_t *)v37.i8 = vadd_f32(*(float32x2_t *)v37.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v37, v37, 8uLL));
  v33.i32[3] = v37.i32[0];
  *(int32x2_t *)v38.f32 = vzip2_s32(v13, v20);
  v38.i32[2] = vdup_lane_s32(v27, 1).u32[0];
  v38.i32[3] = v37.i32[1];
  int8x16_t v39 = (int8x16_t)vmulq_f32(a5, v32);
  *(float32x2_t *)v39.i8 = vadd_f32(*(float32x2_t *)v39.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v39, v39, 8uLL));
  *(int32x2_t *)v40.f32 = vzip1_s32(*(int32x2_t *)v14.f32, *(int32x2_t *)v21.i8);
  v40.i64[1] = __PAIR64__(v39.u32[0], v22.u32[0]);
  *(int32x2_t *)v14.f32 = vzip2_s32(*(int32x2_t *)v14.f32, *(int32x2_t *)v21.i8);
  v14.i32[2] = vdup_lane_s32(*(int32x2_t *)v22.i8, 1).u32[0];
  v14.i32[3] = v39.i32[1];
  int8x16_t v41 = (int8x16_t)vmulq_f32(a6, v32);
  *(float32x2_t *)v41.i8 = vadd_f32(*(float32x2_t *)v41.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v41, v41, 8uLL));
  *(int32x2_t *)v42.f32 = vzip1_s32(*(int32x2_t *)v15.f32, *(int32x2_t *)v7.f32);
  v42.i64[1] = __PAIR64__(v41.u32[0], v34.u32[0]);
  *(int32x2_t *)v15.f32 = vzip2_s32(*(int32x2_t *)v15.f32, *(int32x2_t *)v7.f32);
  v15.i64[1] = __PAIR64__(v41.u32[1], vdup_lane_s32(*(int32x2_t *)v34.i8, 1).u32[0]);
  int8x16_t v43 = (int8x16_t)vaddq_f32(v42, v15);
  a1.i32[3] = v30.i32[0];
  v42.f32[0] = v32.f32[3] - a7;
  a1.i64[0] = vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.i8, 0))), (int8x16_t)vaddq_f32(v35, v36), vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.i8, 1))), (int8x16_t)vaddq_f32(v33, v38), vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(a1, (float32x4_t)vdupq_laneq_s32(a2, 2))), (int8x16_t)vaddq_f32(v40, v14), vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(a1, (float32x4_t)vdupq_laneq_s32(a2, 3))), v43, (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v42.f32, 0), vmulq_n_f32(a1, a7)))))).u64[0];
  return *(double *)a1.i64;
}

float32x4_t cikernel::_boostHybrid(uint64_t a1, float32x4_t a2, float a3, float a4, float a5)
{
  float32x4_t v9 = vmulq_f32(a2, (float32x4_t)xmmword_193950AB0);
  float v28 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2), vaddq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1))).f32[0];
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)&double v11 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v12) = *(_DWORD *)(a1 + 28);
  v13.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v14.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)&v12, COERCE_FLOAT(*DC));
  *(float *)&double v15 = *(float *)(a1 + 24) + *(float *)&v11;
  *(float *)v16.f64 = *(float *)v13.i32 + *(float *)v14.i32;
  *((float *)&v15 + 1) = *(float *)v13.i32 + *(float *)v14.i32;
  *(double *)v18.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v15, v16, v11, v12, v14, v13, v17);
  float32x4_t v19 = a2;
  v19.f32[3] = v28;
  float32x4_t result = vmaxnmq_f32((float32x4_t)vbicq_s8(v18, (int8x16_t)vcltzq_f32(v19)), (float32x4_t)0);
  float32x4_t v21 = vmulq_n_f32(a2, result.f32[3] / fmaxf(v28, 0.000001));
  v21.i32[3] = 0;
  float32x4_t v22 = vmaxnmq_f32(v21, (float32x4_t)0);
  float v23 = (v28 - (a3 + a4 * -0.5)) / a4;
  if (v23 <= 1.0) {
    float v24 = (v28 - (a3 + a4 * -0.5)) / a4;
  }
  else {
    float v24 = 1.0;
  }
  BOOL v25 = v23 < 0.0;
  float v26 = 0.0;
  if (!v25) {
    float v26 = v24;
  }
  float v27 = -((v26 * -2.0 + 3.0) * v26) * v26 + 1.0;
  result.i64[0] = vmlaq_n_f32(vmulq_n_f32(result, 1.0 - (float)(v27 * a5)), v22, v27 * a5).u64[0];
  result.i32[3] = a2.i32[3];
  return result;
}

void CI::f4_s_s_f_f_f(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = a1[6];
  int8x16_t v10 = (double (*)(void *, __n128, __n128, float, float, float))a1[3];
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  int v13 = *(_DWORD *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  uint64_t v15 = *(void *)(v9 + 56);
  uint64_t v16 = *(void *)(v9 + 80);
  uint64_t v17 = *(void *)(v9 + 104);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 128)), a2);
  }
  int8x16_t v18 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    int8x16_t v18 = (__n128 *)((char *)a2 + 64 * v14);
  }
  float32x4_t v19 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    float32x4_t v19 = (__n128 *)((char *)a2 + 64 * v12);
  }
  *(double *)&long long v20 = v10(a1, *v19, *v18, *((float *)a2 + 16 * v15), *((float *)a2 + 16 * v16), *((float *)a2 + 16 * v17));
  *(_OWORD *)(a3 + 16 * a7) = v20;
}

float32x2_t cikernel::_paddedTile(CI *a1, int8x16_t a2)
{
  float32x2_t v2 = vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a2, a2, 8uLL), *(float32x2_t *)CI::getDC(a1));
  __asm { FMOV            V1.2S, #1.0 }
  return vadd_f32(vmul_f32(*(float32x2_t *)a2.i8, vminnm_f32(vsub_f32(v2, vrndm_f32(v2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu))), _D1);
}

void sub_19382B920(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,void (*a43)(char *))
{
}

void __Block_byref_object_copy__15(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__15(uint64_t a1)
{
}

Class ___ZL33getVNDetectRectanglesRequestClassv_block_invoke(uint64_t a1)
{
  VisionLibrary();
  Class result = objc_getClass("VNDetectRectanglesRequest");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    ___ZL33getVNDetectRectanglesRequestClassv_block_invoke_cold_1();
  }
  getVNDetectRectanglesRequestClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

uint64_t ___ZL17VisionLibraryCorePPc_block_invoke_0()
{
  uint64_t result = _sl_dlopen();
  VisionLibraryCore(char **)::frameworkLibrardouble y = result;
  return result;
}

void *___ZL34getVNImageOptionCIContextSymbolLocv_block_invoke_0(uint64_t a1)
{
  float32x2_t v2 = (void *)VisionLibrary();
  uint64_t result = dlsym(v2, "VNImageOptionCIContext");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getVNImageOptionCIContextSymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

Class ___ZL29getVNImageRequestHandlerClassv_block_invoke_0(uint64_t a1)
{
  VisionLibrary();
  Class result = objc_getClass("VNImageRequestHandler");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    ___ZL29getVNImageRequestHandlerClassv_block_invoke_cold_1();
  }
  getVNImageRequestHandlerClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

double cikernel::_rectangle(CI *a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  uint64_t v20 = *(void *)CI::getDC(a1);
  v4.i64[0] = v20;
  *(double *)v5.i64 = vec2::get_xxy((vec2 *)&v20, v4);
  float32x4_t v6 = vaddq_f32(a3, vmulq_f32(a2, v5));
  __asm { FMOV            V2.4S, #1.0 }
  float32x4_t v12 = vminnmq_f32(vmaxnmq_f32(vminnmq_f32(vmaxnmq_f32(vmaxnmq_f32(v6, (float32x4_t)vrev64q_s32((int32x4_t)v6)), (float32x4_t)0), _Q2), (float32x4_t)0), _Q2);
  v13.i64[0] = 0xC0000000C0000000;
  v13.i64[1] = 0xC0000000C0000000;
  __asm { FMOV            V4.4S, #3.0 }
  float32x4_t v15 = vsubq_f32(_Q2, vmulq_f32(vmulq_f32(v12, v12), vmlaq_f32(_Q4, v13, v12)));
  *(void *)&double result = vmulq_n_f32(a4, vmulq_laneq_f32(v15, v15, 2).f32[0]).u64[0];
  return result;
}

void CI::f4_f4_f4_clr(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  int v11 = (double (*)(void *, __n128, __n128, __n128))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  int v14 = *(_DWORD *)(v10 + 40);
  uint64_t v15 = *(void *)(v10 + 32);
  uint64_t v16 = *(void *)(v10 + 56);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 80)), a2);
  }
  uint64_t v17 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5) {
    uint64_t v17 = (__n128 *)((char *)a2 + 64 * v15);
  }
  int8x16_t v18 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    int8x16_t v18 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v19 = v11(a1, *v18, *v17, *((__n128 *)a2 + 4 * v16));
  *(_OWORD *)(a3 + 16 * a7) = v19;
}

double cikernel::_roundedrect(CI *a1, int8x16_t a2, double a3, float32x4_t a4)
{
  DC = (float32x2_t *)CI::getDC(a1);
  float32x2_t v5 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a3, 0);
  float32x2_t v6 = vmaxnm_f32(vminnm_f32(vsub_f32(*DC, vadd_f32(*(float32x2_t *)a2.i8, v5)), 0), vsub_f32(*DC, vsub_f32((float32x2_t)*(_OWORD *)&vextq_s8(a2, a2, 8uLL), v5)));
  float v7 = (float)(*(float *)&a3 - sqrtf(vaddv_f32(vmul_f32(v6, v6)))) + 0.5;
  float v8 = 1.0;
  if (v7 <= 1.0) {
    float v8 = v7;
  }
  BOOL v9 = v7 < 0.0;
  float v10 = 0.0;
  if (!v9) {
    float v10 = v8;
  }
  *(void *)&double result = vmulq_n_f32(a4, v10).u64[0];
  return result;
}

void CI::f4_f4_f_clr(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  int v11 = (double (*)(void *, __n128, float, __n128))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  uint64_t v14 = *(void *)(v10 + 32);
  uint64_t v15 = *(void *)(v10 + 56);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 80)), a2);
  }
  uint64_t v16 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    uint64_t v16 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v17 = v11(a1, *v16, *((float *)a2 + 16 * v14), *((__n128 *)a2 + 4 * v15));
  *(_OWORD *)(a3 + 16 * a7) = v17;
}

double cikernel::_blurredrect(CI *a1, int8x16_t a2, float a3, float32x4_t a4)
{
  DC = (float32x2_t *)CI::getDC(a1);
  double v6 = a3 * 2.4;
  *(float *)&double v6 = v6;
  float32x2_t v7 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v6, 0);
  *(float *)&double v6 = *(float *)&v6 + *(float *)&v6;
  float32x2_t v8 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v6, 0);
  __asm { FMOV            V6.2S, #1.0 }
  float32x2_t v14 = vminnm_f32(vmaxnm_f32(vdiv_f32(vsub_f32(*DC, vsub_f32(*(float32x2_t *)a2.i8, v7)), v8), 0), _D6);
  __asm
  {
    FMOV            V16.2S, #6.0
    FMOV            V18.2S, #-15.0
    FMOV            V17.2S, #10.0
  }
  float32x2_t v18 = vmul_f32(vmul_f32(v14, vmul_f32(v14, v14)), vadd_f32(vmul_f32(v14, vadd_f32(vmul_f32(v14, _D16), _D18)), _D17));
  float32x2_t v19 = vminnm_f32(vmaxnm_f32(vdiv_f32(vsub_f32(vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a2, a2, 8uLL), v7), *DC), v8), 0), _D6);
  float32x2_t v20 = vmul_f32(vmul_f32(v19, vmul_f32(v19, v19)), vadd_f32(vmul_f32(v19, vadd_f32(vmul_f32(v19, _D16), _D18)), _D17));
  *(void *)&double result = vmulq_n_f32(a4, vmul_lane_f32(vmul_f32(vmul_lane_f32(v18, v18, 1), v20), v20, 1).f32[0]).u64[0];
  return result;
}

double cikernel::_roundedstroke(CI *a1, int8x16_t a2, double a3, double a4, float32x4_t a5)
{
  DC = (float32x2_t *)CI::getDC(a1);
  float32x2_t v6 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a3, 0);
  float32x2_t v7 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  float32x2_t v8 = vmaxnm_f32(vminnm_f32(vsub_f32(*DC, vadd_f32(*(float32x2_t *)a2.i8, v6)), 0), vsub_f32(*DC, vsub_f32(v7, v6)));
  v9.i32[1] = HIDWORD(a3);
  float v10 = (float)(*(float *)&a3 - sqrtf(vaddv_f32(vmul_f32(v8, v8)))) + 0.5;
  if (v10 <= 1.0) {
    float v11 = v10;
  }
  else {
    float v11 = 1.0;
  }
  BOOL v12 = v10 < 0.0;
  float v13 = 0.0;
  *(float *)v9.i32 = fmaxf(*(float *)&a3 - *(float *)&a4, 0.5);
  float32x2_t v14 = (float32x2_t)vdup_lane_s32(v9, 0);
  if (v12) {
    float v11 = 0.0;
  }
  float32x2_t v15 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a4, 0);
  float32x2_t v16 = vmaxnm_f32(vminnm_f32(vsub_f32(*DC, vadd_f32(v15, vadd_f32(*(float32x2_t *)a2.i8, v14))), 0), vsub_f32(*DC, vsub_f32(vsub_f32(v7, v14), v15)));
  float v17 = (float)(*(float *)v9.i32 - sqrtf(vaddv_f32(vmul_f32(v16, v16)))) + 0.5;
  if (v17 <= 1.0) {
    float v13 = 1.0 - v17;
  }
  float32x4_t v18 = vmulq_n_f32(a5, v11);
  if (v17 < 0.0) {
    float v13 = 1.0;
  }
  *(void *)&double result = vmulq_n_f32(v18, v13).u64[0];
  return result;
}

void CI::f4_f4_f_f_clr(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  float v11 = (double (*)(void *, __n128, float, float, __n128))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  uint64_t v14 = *(void *)(v10 + 32);
  uint64_t v15 = *(void *)(v10 + 56);
  uint64_t v16 = *(void *)(v10 + 80);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 104)), a2);
  }
  float v17 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    float v17 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v18 = v11(a1, *v17, *((float *)a2 + 16 * v14), *((float *)a2 + 16 * v15), *((__n128 *)a2 + 4 * v16));
  *(_OWORD *)(a3 + 16 * a7) = v18;
}

double cikernel::_rectstroke(CI *a1, int8x16_t a2, int32x2_t a3, float32x4_t a4)
{
  DC = (float32x2_t *)CI::getDC(a1);
  float32x2_t v5 = vadd_f32(*(float32x2_t *)a2.i8, (float32x2_t)0xBF000000BF000000);
  float32x2_t v6 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a2, a2, 8uLL), (float32x2_t)0x3F0000003F000000);
  float32x2_t v7 = vminnm_f32(vsub_f32(*DC, v5), vsub_f32(v6, *DC));
  __asm { FMOV            V5.2S, #1.0 }
  float32x2_t v13 = (float32x2_t)vbic_s8(vbsl_s8((int8x8_t)vcgt_f32(v7, _D5), (int8x8_t)_D5, (int8x8_t)v7), (int8x8_t)vcltz_f32(v7));
  float32x2_t v14 = (float32x2_t)vdup_lane_s32(a3, 0);
  float32x2_t v15 = vminnm_f32(vsub_f32(*DC, vadd_f32(v14, v5)), vsub_f32(vsub_f32(v6, v14), *DC));
  float32x2_t v16 = (float32x2_t)vbic_s8(vbsl_s8((int8x8_t)vcgt_f32(v15, _D5), (int8x8_t)_D5, (int8x8_t)v15), (int8x8_t)vcltz_f32(v15));
  *(void *)&double result = vmulq_n_f32(vmulq_n_f32(a4, vmul_lane_f32(v13, v13, 1).f32[0]), 1.0 - vmul_lane_f32(v16, v16, 1).f32[0]).u64[0];
  return result;
}

void sub_19382E814(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
}

void _ZZZ33__CIRedEyeCorrection_outputImage_EUb_EN13SignpostTimerD1Ev(TimerBase *a1)
{
  float32x2_t v2 = ci_signpost_log_render();
  os_signpost_id_t v3 = *((void *)a1 + 1);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    int32x4_t v4 = v2;
    if (os_signpost_enabled(v2))
    {
      *(_WORD *)float32x2_t v5 = 0;
      _os_signpost_emit_with_name_impl(&dword_193671000, v4, OS_SIGNPOST_INTERVAL_END, v3, "CIRedEyeCorrection_processor", "", v5, 2u);
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_19382E8C8(_Unwind_Exception *a1)
{
  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

void clearOutput(void *a1)
{
  int v2 = CI::format_bytes_per_pixel([a1 format]);
  [a1 region];
  uint64_t v4 = [a1 bytesPerRow] * ((int)v3 - 1);
  [a1 region];
  size_t v6 = v4 + (int)v5 * (uint64_t)v2;
  float32x2_t v7 = (void *)[a1 baseAddress];

  bzero(v7, v6);
}

uint64_t CIRedEyeUtilsSizeFromScale(float a1)
{
  uint64_t v1 = 90;
  if (a1 < 90.0) {
    uint64_t v1 = 35;
  }
  if (a1 >= 35.0) {
    return v1;
  }
  else {
    return 0;
  }
}

float stretch(float a1, float a2, float a3, float a4, float a5)
{
  float result = a4 + (float)((float)((float)(a1 - a2) / (float)(a3 - a2)) * (float)(a5 - a4));
  if (result >= a5) {
    float result = a5;
  }
  if (result <= a4) {
    return a4;
  }
  return result;
}

float interpolate(float result, float a2, float a3)
{
  float v3 = result + (float)(a3 * (float)(a2 - result));
  if (a2 >= result) {
    float v4 = result;
  }
  else {
    float v4 = a2;
  }
  if (a2 >= result) {
    float result = a2;
  }
  if (v3 <= v4) {
    float v5 = v4;
  }
  else {
    float v5 = v3;
  }
  if (v5 < result) {
    return v5;
  }
  return result;
}

__CFString *tagForEye(uint64_t a1)
{
  uint64_t v1 = @"L";
  if (a1 == 35) {
    uint64_t v1 = @"M";
  }
  if (a1) {
    return v1;
  }
  else {
    return @"S";
  }
}

CIImage *refilter(CIImage *a1, CIImage *a2, float a3, float a4)
{
  v10[3] = *MEMORY[0x1E4F143B8];
  if (a3 > 0.0 && a4 > 0.0)
  {
    v10[0] = a2;
    v9[0] = @"inputSource";
    v9[1] = @"inputSigmaSpace";
    v10[1] = objc_msgSend(NSNumber, "numberWithFloat:");
    v9[2] = @"inputSigmaRange";
    *(float *)&double v6 = a4;
    v10[2] = [NSNumber numberWithFloat:v6];
    float32x2_t v7 = -[CIImage imageByApplyingFilter:withInputParameters:](a1, "imageByApplyingFilter:withInputParameters:", @"CICheapBilateral", [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v10 forKeys:v9 count:3]);
    [(CIImage *)a1 extent];
    return -[CIImage imageByCroppingToRect:](v7, "imageByCroppingToRect:");
  }
  return a1;
}

unint64_t radialFillRGBA8(void *a1, void *a2, int a3, unsigned int a4, unint64_t a5, double a6, double a7)
{
  [a1 region];
  double v14 = v13;
  [a2 region];
  if (v14 >= v15) {
    float32x2_t v16 = a2;
  }
  else {
    float32x2_t v16 = a1;
  }
  [v16 region];
  int v71 = (int)v17;
  [a1 region];
  double v19 = v18;
  [a2 region];
  if (v19 >= v20) {
    float32x4_t v21 = a2;
  }
  else {
    float32x4_t v21 = a1;
  }
  [v21 region];
  int v70 = (int)v22;
  int v23 = [a1 bytesPerRow];
  int v24 = [a2 bytesPerRow];
  uint64_t v25 = [a1 baseAddress];
  uint64_t v26 = [a2 baseAddress];
  int v27 = (int)a6;
  int v28 = (int)a7;
  float v29 = sqrtf((float)a5);
  int v30 = (int)(v29 + v29);
  if ((int)a6 >= (int)a7) {
    int v31 = (int)a7;
  }
  else {
    int v31 = (int)a6;
  }
  if (v31 < v30) {
    int v30 = v31;
  }
  int v32 = v71 + ~v27;
  if (v32 >= v70 + ~v28) {
    int v32 = v70 + ~v28;
  }
  if (v32 < v30) {
    int v30 = v32;
  }
  int v72 = v30;
  [a1 region];
  double v34 = v33;
  [a2 region];
  double v36 = v35;
  [a1 region];
  double v38 = v37;
  [a2 region];
  if (v72 < 1) {
    return 0;
  }
  int v40 = 0;
  unint64_t result = 0;
  int v42 = a3 + (v28 + (int)(v38 - v39)) * v24 + 4 * (v27 + (int)(v34 - v36));
  int v43 = a3 + v28 * v23 + 4 * v27;
  int v44 = 1;
  int v45 = v43;
  int v46 = v42;
  int v47 = v43;
  int v48 = v42;
  do
  {
    int v49 = v44;
    int v50 = v47;
    int v51 = v48;
    do
    {
      unint64_t v52 = result;
      int v53 = *(unsigned __int8 *)(v25 + v50) > a4;
      if (*(unsigned __int8 *)(v25 + v50) > a4) {
        ++result;
      }
      if (v52 >= a5) {
        int v53 = 0;
      }
      *(unsigned char *)(v26 + v51) = v53 << 31 >> 31;
      v51 += v24;
      v50 += v23;
      --v49;
    }
    while (v49);
    int v54 = v44;
    int v55 = v45;
    int v56 = v46;
    if (result > a5) {
      break;
    }
    do
    {
      unint64_t v57 = result;
      int v58 = *(unsigned __int8 *)(v25 + v55) > a4;
      if (*(unsigned __int8 *)(v25 + v55) > a4) {
        ++result;
      }
      if (v57 >= a5) {
        int v58 = 0;
      }
      *(unsigned char *)(v26 + v56) = v58 << 31 >> 31;
      v56 += v24;
      v55 += v23;
      --v54;
    }
    while (v54);
    if (result > a5) {
      break;
    }
    int v59 = 0;
    int v60 = v44;
    do
    {
      unint64_t v61 = result;
      int v62 = *(unsigned __int8 *)(v25 + v47 + v59) > a4;
      if (*(unsigned __int8 *)(v25 + v47 + v59) > a4) {
        ++result;
      }
      if (v61 >= a5) {
        int v62 = 0;
      }
      *(unsigned char *)(v26 + v48 + v59) = v62 << 31 >> 31;
      v59 += 4;
      --v60;
    }
    while (v60);
    int v63 = v44;
    int v64 = v42;
    int v65 = v43;
    if (result > a5) {
      break;
    }
    do
    {
      unint64_t v66 = result;
      int v67 = *(unsigned __int8 *)(v25 + v65) > a4;
      if (*(unsigned __int8 *)(v25 + v65) > a4) {
        ++result;
      }
      if (v66 >= a5) {
        int v67 = 0;
      }
      *(unsigned char *)(v26 + v64) = v67 << 31 >> 31;
      v65 += 4;
      v64 += 4;
      --v63;
    }
    while (v63);
    ++v40;
    v48 += -4 - v24;
    v47 += -4 - v23;
    v44 += 2;
    v46 += 4 - v24;
    v45 += 4 - v23;
    v43 += v23 - 4;
    v42 += v24 - 4;
  }
  while (result <= a5 && v40 != v72);
  return result;
}

uint64_t radialFillRGBA8_circular(void *a1, void *a2, int a3, unsigned int a4, unint64_t a5, float a6, double a7, double a8)
{
  [a1 region];
  double v15 = v14;
  [a2 region];
  if (v15 >= v16) {
    double v17 = a2;
  }
  else {
    double v17 = a1;
  }
  [v17 region];
  int v19 = (int)v18;
  [a1 region];
  double v21 = v20;
  [a2 region];
  if (v21 >= v22) {
    int v23 = a2;
  }
  else {
    int v23 = a1;
  }
  [v23 region];
  int v25 = (int)v24;
  int v26 = [a1 bytesPerRow];
  int v27 = [a2 bytesPerRow];
  uint64_t v28 = [a1 baseAddress];
  uint64_t v29 = [a2 baseAddress];
  uint64_t v30 = (int)a7;
  float v31 = (float)a5;
  float v32 = sqrtf((float)a5);
  int v33 = (int)(v32 + v32);
  if ((int)v30 >= (int)a8) {
    int v34 = (int)a8;
  }
  else {
    int v34 = (int)a7;
  }
  if (v34 < v33) {
    int v33 = v34;
  }
  int v35 = v19 + ~v30;
  int v36 = (int)a8;
  if (v35 >= v25 + ~(int)a8) {
    int v35 = v25 + ~(int)a8;
  }
  if (v35 >= v33) {
    uint64_t v37 = v33;
  }
  else {
    uint64_t v37 = v35;
  }
  [a1 region];
  double v39 = v38;
  [a2 region];
  double v41 = v40;
  [a1 region];
  double v43 = v42;
  uint64_t result = [a2 region];
  uint64_t v132 = v37;
  if ((int)v37 >= 1)
  {
    uint64_t v46 = 0;
    int v47 = 0;
    int v48 = (int)(v39 - v41);
    int v49 = (int)(v43 - v45);
    uint64_t v50 = v27;
    int v51 = v26;
    uint64_t v52 = v26;
    uint64_t v53 = a3;
    uint64_t v131 = 4 * (int)v30 + (uint64_t)a3;
    uint64_t v130 = 4 * (v48 + (int)v30) + (uint64_t)a3;
    uint64_t v127 = a3 + v27 * (uint64_t)(v49 + v36);
    uint64_t v128 = a3 + (int)v52 * (uint64_t)v36;
    uint64_t v126 = v49;
    uint64_t v54 = v36 + (uint64_t)v49;
    uint64_t v129 = v36;
    uint64_t v124 = v28 + (v36 - 1) * v52;
    uint64_t v125 = v29 + (v54 - 1) * v27;
    uint64_t v123 = v29 + v27 * v54 + v27;
    uint64_t v122 = v28 + v52 + (int)v52 * (uint64_t)v36;
    int v121 = 4 * v30 - 4;
    int v120 = 4 * v30 + 4;
    int v139 = v36;
    int v138 = 4 * v48;
    uint64_t v136 = -(uint64_t)v27;
    int v143 = v48;
    int v135 = v49;
    uint64_t v141 = v28;
    uint64_t v140 = v29;
    do
    {
      BOOL v55 = *(unsigned __int8 *)(v28 + v131 + v52 * (v46 + v129)) > a4;
      if (*(unsigned __int8 *)(v28 + v131 + v52 * (v46 + v129)) <= a4) {
        char v56 = 0;
      }
      else {
        char v56 = -1;
      }
      *(unsigned char *)(v29 + v130 + v50 * (v46 + v129 + v126)) = v56;
      unsigned int v57 = *(unsigned __int8 *)(v28 + v131 + v52 * (v129 - v46));
      BOOL v58 = v57 > a4;
      if (v57 <= a4) {
        char v59 = 0;
      }
      else {
        char v59 = -1;
      }
      *(unsigned char *)(v29 + v130 + v50 * (v129 - v46 + v126)) = v59;
      if (v58) {
        int v60 = v55 + 1;
      }
      else {
        int v60 = v55;
      }
      unsigned int v61 = *(unsigned __int8 *)(v28 + v128 + 4 * ((int)v30 - (int)v46));
      BOOL v62 = v61 > a4;
      if (v61 <= a4) {
        char v63 = 0;
      }
      else {
        char v63 = -1;
      }
      *(unsigned char *)(v29 + v127 + 4 * ((int)v30 - (int)v46 + v48)) = v63;
      if (v62) {
        ++v60;
      }
      unsigned int v64 = *(unsigned __int8 *)(v28 + v128 + 4 * ((int)v46 + (int)v30));
      BOOL v65 = v64 > a4;
      if (v64 <= a4) {
        uint64_t result = 0;
      }
      else {
        uint64_t result = 0xFFFFFFFFLL;
      }
      *(unsigned char *)(v29 + v127 + 4 * ((int)v46 + (int)v30 + v48)) = result;
      if (v65) {
        int v66 = v60 + 1;
      }
      else {
        int v66 = v60;
      }
      uint64_t v134 = v46;
      int v133 = v47;
      if (v46)
      {
        uint64_t v67 = 0;
        LODWORD(result) = 1 - v46;
        int v68 = 3;
        int v70 = v120;
        int v69 = v121;
        uint64_t v72 = v122;
        uint64_t v71 = v123;
        uint64_t v74 = v124;
        uint64_t v73 = v125;
        int v75 = v46;
        int v76 = -2 * v46;
        do
        {
          int v77 = v76 + 2;
          if ((int)result >= 0) {
            v76 += 2;
          }
          v75 += ~result >> 31;
          int v78 = v75 + v139;
          uint64_t v79 = v53 + v70;
          unsigned int v80 = *(unsigned __int8 *)(v141 + v79 + (int)v52 * (uint64_t)(v75 + v139));
          BOOL v81 = v80 > a4;
          if (v80 <= a4) {
            char v82 = 0;
          }
          else {
            char v82 = -1;
          }
          int v83 = v78 + v135;
          uint64_t v84 = v53 + v138 + v70;
          uint64_t v85 = v30;
          *(unsigned char *)(v140 + v84 + (int)v50 * (uint64_t)(v78 + v135)) = v82;
          if (v81) {
            int v86 = v66 + 1;
          }
          else {
            int v86 = v66;
          }
          uint64_t v87 = v53 + v69;
          unsigned int v88 = *(unsigned __int8 *)(v141 + v87 + (int)v52 * (uint64_t)v78);
          BOOL v89 = v88 > a4;
          if (v88 <= a4) {
            char v90 = 0;
          }
          else {
            char v90 = -1;
          }
          uint64_t v91 = v53 + v138 + v69;
          *(unsigned char *)(v140 + v91 + (int)v50 * (uint64_t)v83) = v90;
          if (v89) {
            ++v86;
          }
          int v92 = v139 - v75;
          unsigned int v93 = *(unsigned __int8 *)(v141 + v79 + (int)v52 * (uint64_t)(v139 - v75));
          BOOL v94 = v93 > a4;
          if (v93 <= a4) {
            char v95 = 0;
          }
          else {
            char v95 = -1;
          }
          int v96 = v92 + v135;
          *(unsigned char *)(v140 + v84 + (int)v50 * (uint64_t)(v92 + v135)) = v95;
          int v97 = v77 & ~((int)result >> 31);
          ++v67;
          int v98 = v68 + result;
          if (v94) {
            ++v86;
          }
          unsigned int v99 = *(unsigned __int8 *)(v141 + v87 + (int)v52 * (uint64_t)v92);
          BOOL v100 = v99 > a4;
          if (v99 <= a4) {
            char v101 = 0;
          }
          else {
            char v101 = -1;
          }
          uint64_t v102 = v91 + (int)v50 * (uint64_t)v96;
          uint64_t v30 = v85;
          *(unsigned char *)(v140 + v102) = v101;
          if (v100) {
            ++v86;
          }
          uint64_t v103 = v53 + 4 * (v75 + (int)v85);
          unsigned int v104 = *(unsigned __int8 *)(v72 + v103);
          BOOL v105 = v104 > a4;
          if (v104 <= a4) {
            char v106 = 0;
          }
          else {
            char v106 = -1;
          }
          uint64_t v107 = v53 + 4 * (v75 + (int)v85 + v143);
          *(unsigned char *)(v71 + v107) = v106;
          if (v105) {
            ++v86;
          }
          uint64_t v108 = v53 + 4 * ((int)v85 - v75);
          unsigned int v109 = *(unsigned __int8 *)(v72 + v108);
          BOOL v110 = v109 > a4;
          if (v109 <= a4) {
            char v111 = 0;
          }
          else {
            char v111 = -1;
          }
          uint64_t v112 = v53 + 4 * ((int)v85 - v75 + v143);
          *(unsigned char *)(v71 + v112) = v111;
          uint64_t result = (v98 + v97);
          if (v110) {
            ++v86;
          }
          unsigned int v113 = *(unsigned __int8 *)(v74 + v103);
          BOOL v114 = v113 > a4;
          if (v113 <= a4) {
            char v115 = 0;
          }
          else {
            char v115 = -1;
          }
          *(unsigned char *)(v73 + v107) = v115;
          if (v114) {
            ++v86;
          }
          unsigned int v116 = *(unsigned __int8 *)(v74 + v108);
          BOOL v117 = v116 > a4;
          if (v116 <= a4) {
            char v118 = 0;
          }
          else {
            char v118 = -1;
          }
          *(unsigned char *)(v73 + v112) = v118;
          if (v117) {
            int v66 = v86 + 1;
          }
          else {
            int v66 = v86;
          }
          v73 += v136;
          v74 -= v51;
          v71 += v50;
          v72 += v52;
          v69 -= 4;
          v70 += 4;
          v68 += 2;
        }
        while (v67 < v75);
      }
      int v47 = v66 + v133;
      uint64_t v46 = v134 + 1;
      BOOL v119 = v66 + v133 > (int)(float)(v31 * a6) || v46 == v132;
      int v48 = (int)(v39 - v41);
      uint64_t v28 = v141;
      uint64_t v29 = v140;
    }
    while (!v119);
  }
  return result;
}

void radialSplatR8(unsigned __int8 *a1, unsigned __int8 *a2, int a3, int a4, unint64_t a5, uint64_t a6, unint64_t a7, CGPoint a8)
{
  int x = (int)a8.x;
  int y = (int)a8.y;
  LODWORD(v10) = (int)sqrt((double)a7 / 3.14159265);
  if ((int)a8.x >= (int)a8.y) {
    int v11 = (int)a8.y;
  }
  else {
    int v11 = (int)a8.x;
  }
  if (v11 >= (int)v10) {
    int v11 = v10;
  }
  LODWORD(v12) = ~x + a3;
  int v13 = ~y + a4;
  if ((int)v12 >= v13) {
    int v14 = ~y + a4;
  }
  else {
    int v14 = ~x + a3;
  }
  if (v14 >= v11) {
    int v15 = v11;
  }
  else {
    int v15 = v14;
  }
  if ((v15 & 0x80000000) == 0)
  {
    unsigned int v16 = v15 * v15;
    uint64_t v17 = x;
    uint64_t v18 = -v15;
    uint64_t v19 = y;
    int v20 = v15 + 1;
    if (v19 < x) {
      uint64_t v17 = v19;
    }
    if (v17 >= (int)v10) {
      uint64_t v10 = (int)v10;
    }
    else {
      uint64_t v10 = v17;
    }
    if (v10 >= v13) {
      uint64_t v10 = v13;
    }
    if (v10 >= (int)v12) {
      uint64_t v12 = (int)v12;
    }
    else {
      uint64_t v12 = v10;
    }
    double v21 = &a2[a6 * (v19 - v12) + x];
    int v22 = ~(v15 + v12);
    uint64_t v23 = v18;
    do
    {
      int v24 = v22;
      int v25 = v21;
      int v26 = v18;
      do
      {
        if (v16 >= (int)v23 * (int)v23 + v26 * v26) {
          v25[v23] = -1;
        }
        ++v26;
        v25 += a6;
      }
      while (!__CFADD__(v24++, 1));
      ++v23;
    }
    while (v20 != v23);
  }
}

float findPercentileNonZero(unint64_t *a1, float a2, unint64_t a3, unint64_t a4)
{
  float result = 0.0;
  if (a4)
  {
    if (a4 == 1)
    {
      uint64_t v6 = 0;
      unint64_t v7 = 0;
      unint64_t v8 = (unint64_t)(float)(a2 * 0.0);
      unint64_t v12 = 1;
    }
    else
    {
      unint64_t v9 = 0;
      for (uint64_t i = 1; i != a4; ++i)
        v9 += a1[i];
      unint64_t v8 = (unint64_t)(float)((float)v9 * a2);
      unint64_t v7 = 0;
      uint64_t v6 = 0;
      unint64_t v12 = 1;
      while (1)
      {
        unint64_t v11 = a1[v12];
        v7 += v11;
        if (v7 >= v8) {
          break;
        }
        v6 += v11;
        if (a4 == ++v12)
        {
          unint64_t v12 = a4;
          break;
        }
      }
    }
    if (v8)
    {
      float v13 = (float)(v7 - v6);
      if (v13 > 0.00001)
      {
        float result = (float)((float)((float)((float)(v8 - v6) / v13) + (float)v12) * (float)a3) / (float)a4;
        if (result > (float)a3) {
          float result = (float)a3;
        }
        if (result < 0.0) {
          return 0.0;
        }
      }
    }
  }
  return result;
}

BOOL computeDensity(unsigned __int8 *a1, unsigned int a2, int a3, int a4, uint64_t a5, unsigned int a6, CGPoint a7, int a8, float *a9)
{
  int x = (int)a7.x;
  int y = (int)a7.y;
  LODWORD(v11) = (int)a7.x - 1;
  int v12 = (int)a7.y - 1;
  if ((int)v11 >= v12) {
    int v13 = (int)a7.y - 1;
  }
  else {
    int v13 = (int)a7.x - 1;
  }
  if (v13 >= a8) {
    int v13 = a8;
  }
  int v14 = ~x + a3;
  int v15 = ~y + a4;
  if (v14 >= v15) {
    int v16 = ~y + a4;
  }
  else {
    int v16 = v14;
  }
  if (v16 < v13) {
    int v13 = v16;
  }
  float v17 = 0.0;
  if (v13 >= 2)
  {
    unint64_t v18 = 0;
    unint64_t v19 = 0;
    uint64_t v20 = a2;
    uint64_t v21 = v15;
    if (v15 >= (uint64_t)v14) {
      uint64_t v21 = v14;
    }
    int v22 = 4 * x;
    if (v21 >= v12) {
      uint64_t v21 = v12;
    }
    if (v21 >= (int)v11) {
      uint64_t v11 = (int)v11;
    }
    else {
      uint64_t v11 = v21;
    }
    int v23 = a8;
    if (v11 < a8) {
      int v23 = v11;
    }
    int v24 = v22 - 4 * v23;
    int v25 = ~(v13 + v23);
    uint64_t v26 = -v13;
    do
    {
      int v27 = v25;
      int v28 = v24;
      int v29 = -v13;
      do
      {
        if (v13 * v13 > (v26 * v26 + v29 * v29))
        {
          if (a1[v20 + (v26 + y) * a5 + v28] > a6) {
            ++v19;
          }
          ++v18;
        }
        ++v29;
        v28 += 4;
      }
      while (!__CFADD__(v27++, 1));
      ++v26;
    }
    while (v13 + 1 != v26);
    if (v18) {
      float v17 = (float)v19 / (float)v18;
    }
    else {
      float v17 = 1.0;
    }
  }
  BOOL result = v13 > 1;
  *a9 = v17;
  return result;
}

uint64_t clipRepair(void *a1, void *a2, int a3, unsigned int a4)
{
  [a1 region];
  double v9 = v8;
  [a1 region];
  int v11 = (int)v10;
  int v12 = [a1 bytesPerRow];
  int v13 = [a2 bytesPerRow];
  uint64_t v14 = [a1 baseAddress];
  uint64_t v15 = [a2 baseAddress];
  [a1 region];
  double v17 = v16;
  [a2 region];
  double v19 = v18;
  [a1 region];
  double v21 = v20;
  uint64_t result = [a2 region];
  if (v11 >= 1)
  {
    int v24 = 0;
    int v25 = (int)(v21 - v23) * v13 + 4 * (int)(v17 - v19) + a3;
    do
    {
      uint64_t v26 = (int)v9;
      int v27 = v25;
      int v28 = a3;
      if ((int)v9 >= 1)
      {
        do
        {
          unsigned int v29 = *(unsigned __int8 *)(v14 + v28);
          if (v29 <= a4) {
            LOBYTE(v29) = 0;
          }
          *(unsigned char *)(v15 + v27) = v29;
          v28 += 4;
          v27 += 4;
          --v26;
        }
        while (v26);
      }
      ++v24;
      a3 += v12;
      v25 += v13;
    }
    while (v24 != v11);
  }
  return result;
}

uint64_t sampleUnderCentroid(void *a1, double a2, double a3, float a4)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  [a1 region];
  int v9 = (int)v8;
  int v11 = (int)v10;
  uint64_t v12 = [a1 bytesPerRow];
  uint64_t v13 = [a1 baseAddress];
  if (v9 >= v11) {
    int v14 = v11;
  }
  else {
    int v14 = v9;
  }
  int v15 = (int)(float)((float)v14 * a4);
  bzero(v25, 0x400uLL);
  uint64_t v16 = ((int)a3 - v15) & ~(((int)a3 - v15) >> 31);
  LODWORD(v17) = v15 + (int)a3;
  if ((int)v17 >= v11) {
    uint64_t v17 = v11;
  }
  else {
    uint64_t v17 = v17;
  }
  if ((int)v16 < (int)v17)
  {
    LODWORD(v18) = v15 + (int)a2;
    if ((int)v18 >= v9) {
      uint64_t v18 = v9;
    }
    else {
      uint64_t v18 = v18;
    }
    uint64_t v19 = ((int)a2 - v15) & ~(((int)a2 - v15) >> 31);
    double v20 = (unsigned __int8 *)(v13 + v19 + v12 * v16);
    do
    {
      uint64_t v21 = v18 - v19;
      int v22 = v20;
      if ((int)v19 < (int)v18)
      {
        do
        {
          int v23 = *v22++;
          ++v25[v23];
          --v21;
        }
        while (v21);
      }
      ++v16;
      v20 += v12;
    }
    while (v16 != v17);
  }
  percentile(v25, 0.25);
  return percentile(v25, 0.75);
}

uint64_t percentile(int *a1, float a2)
{
  uint64_t v2 = 0;
  int v3 = 0;
  do
    v3 += a1[v2++];
  while (v2 != 255);
  uint64_t v4 = 0;
  double v5 = a2;
  if (v5 > 1.0) {
    double v5 = 1.0;
  }
  if (v5 < 0.0) {
    double v5 = 0.0;
  }
  int v6 = (int)(v5 * (double)v3);
  float v7 = (float)v6;
  float v8 = 0.0;
  float v9 = 0.0;
  while (1)
  {
    float v10 = (float)a1[v4];
    float v8 = v8 + v10;
    if (v8 >= v7) {
      break;
    }
    float v9 = v9 + v10;
    if (++v4 == 255)
    {
      float v11 = 255.0;
      goto LABEL_12;
    }
  }
  float v11 = (float)(int)v4;
LABEL_12:
  float v12 = 0.0;
  if (v6 >= 1)
  {
    float v13 = v8 - v9;
    if (v13 > 0.0) {
      float v12 = (float)(v7 - v9) / v13;
    }
  }
  float v14 = roundf(v12 + v11);
  if (v14 > 255.0) {
    return 255;
  }
  if (v14 >= 0.0) {
    return (int)v14;
  }
  return 0;
}

uint64_t calculateMeans(void *a1, void *a2, int a3, double a4, double a5)
{
  [a2 region];
  double v11 = v10;
  [a1 region];
  if (v11 >= v12) {
    float v13 = a1;
  }
  else {
    float v13 = a2;
  }
  [v13 region];
  int v15 = (int)v14;
  [a2 region];
  double v17 = v16;
  [a1 region];
  if (v17 >= v18) {
    uint64_t v19 = a1;
  }
  else {
    uint64_t v19 = a2;
  }
  [v19 region];
  int v21 = (int)v20;
  uint64_t v22 = [a1 bytesPerRow];
  uint64_t v23 = [a2 bytesPerRow];
  uint64_t v24 = [a1 baseAddress];
  uint64_t result = [a2 baseAddress];
  if (v15 >= v21) {
    int v26 = v21;
  }
  else {
    int v26 = v15;
  }
  int v27 = (int)((double)v26 * 0.3);
  uint64_t v28 = ((int)a5 - v27) & ~(((int)a5 - v27) >> 31);
  int v29 = v27 + (int)a5;
  if (v29 >= v21) {
    uint64_t v30 = v21;
  }
  else {
    uint64_t v30 = v29;
  }
  if ((int)v28 < (int)v30)
  {
    int v31 = 0;
    int v32 = 0;
    LODWORD(v33) = v27 + (int)a4;
    if ((int)v33 >= v15) {
      uint64_t v33 = v15;
    }
    else {
      uint64_t v33 = v33;
    }
    uint64_t v34 = ((int)a4 - v27) & ~(((int)a4 - v27) >> 31);
    int v35 = (unsigned __int8 *)(v24 + v34 + v22 * v28);
    float v36 = 0.0;
    float v37 = 0.0;
    do
    {
      if ((int)v33 > (int)v34)
      {
        uint64_t v38 = a3 + v23 * v28;
        uint64_t v39 = v33 - v34;
        double v40 = v35;
        int v41 = 4 * v34;
        do
        {
          unsigned int v42 = *v40++;
          float v43 = (float)v42;
          float v37 = v37 + (float)v42;
          if (!*(unsigned char *)(result + v38 + (v41 & 0xFFFFFFFC))) {
            float v43 = -0.0;
          }
          float v36 = v36 + v43;
          if (*(unsigned char *)(result + v38 + (v41 & 0xFFFFFFFC))) {
            ++v31;
          }
          v41 += 4;
          --v39;
        }
        while (v39);
        v32 += v33 - v34;
      }
      ++v28;
      v35 += v22;
    }
    while (v28 != v30);
  }
  return result;
}

CIImage *RRradialCentroidMask(CIImage *a1, CGRect a2, float a3, float a4, int a5)
{
  double height = a2.size.height;
  double width = a2.size.width;
  void v24[4] = *MEMORY[0x1E4F143B8];
  double v11 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_drr_puncturec2, a2.origin.x, a2.origin.y);
  double v12 = +[CIKernel kernelWithInternalRepresentation:&CI::_drr_puncturec2_hard];
  float v13 = +[CIVector vectorWithX:1.0 / (width * width) Y:1.0 / (height * height)];
  if (a5)
  {
    if (width >= height) {
      double v15 = height;
    }
    else {
      double v15 = width;
    }
    float v16 = v15;
    float v13 = +[CIVector vectorWithX:1.0 / (float)(v16 * v16) Y:1.0 / (float)(v16 * v16)];
  }
  double v17 = v13;
  *(float *)&double v14 = a3 * 0.5;
  if (a4 >= 1.0) {
    double v11 = v12;
  }
  double v18 = *MEMORY[0x1E4F1DB10];
  double v19 = *(double *)(MEMORY[0x1E4F1DB10] + 8);
  double v20 = *(double *)(MEMORY[0x1E4F1DB10] + 16);
  double v21 = *(double *)(MEMORY[0x1E4F1DB10] + 24);
  v24[0] = a1;
  v24[1] = [NSNumber numberWithFloat:v14];
  *(float *)&double v22 = a4;
  void v24[2] = [NSNumber numberWithFloat:v22];
  v24[3] = v17;
  return -[CIColorKernel applyWithExtent:arguments:](v11, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v24 count:4], v18, v19, v20, v21);
}

uint64_t RRmaximumRh(void *a1, void *a2)
{
  void v18[2] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = +[CIKernel kernelWithInternalRepresentation:&CI::_drr_maximumRh];
  [a1 extent];
  CGFloat v6 = v5;
  CGFloat v8 = v7;
  CGFloat v10 = v9;
  CGFloat v12 = v11;
  [a2 extent];
  v21.origin.int x = v13;
  v21.origin.int y = v14;
  v21.size.double width = v15;
  v21.size.double height = v16;
  v19.origin.int x = v6;
  v19.origin.int y = v8;
  v19.size.double width = v10;
  v19.size.double height = v12;
  CGRect v20 = CGRectUnion(v19, v21);
  v18[0] = a1;
  v18[1] = a2;
  return (uint64_t)-[CIColorKernel applyWithExtent:arguments:](v4, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v18 count:2], v20.origin.x, v20.origin.y, v20.size.width, v20.size.height);
}

uint64_t convexFill(unsigned __int8 *a1, unsigned __int8 *a2, unint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, int a7, CGPoint a8)
{
  double y = a8.y;
  CGFloat x = a8.x;
  uint64_t v17 = convexFillHorizontal(a1, a2, a3, a4, a5, a6, a7, a8, 1);
  v19.double y = y + -1.0;
  v19.CGFloat x = x;
  return convexFillHorizontal(a1, a2, a3, a4, a5, a6, a7, v19, -1) + v17;
}

uint64_t convexFillHorizontal(unsigned __int8 *a1, unsigned __int8 *a2, unint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, int a7, CGPoint a8, int a9)
{
  uint64_t v80 = *MEMORY[0x1E4F143B8];
  memset(v79, 0, 140);
  unint64_t y = (int)a8.y;
  if ((y & 0x80000000) != 0 || y >= a4 || (unint64_t x = (int)a8.x, (x & 0x80000000) != 0) || x >= a3)
  {
    if (CI_LOG_DUALRED())
    {
      uint64_t v72 = ci_logger_api();
      if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR)) {
        convexFillHorizontal(v72);
      }
    }
    return 0;
  }
  if (a9 == -1) {
    uint64_t v12 = -a5;
  }
  else {
    LODWORD(v12) = a5;
  }
  if (a9 == -1) {
    uint64_t v13 = 0;
  }
  else {
    uint64_t v13 = a5 * a4;
  }
  uint64_t v14 = y * a5;
  CGFloat v15 = &a1[x + y * a5];
  if (*v15 <= a7)
  {
    if (CI_LOG_DUALRED())
    {
      uint64_t v74 = ci_logger_api();
      if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR)) {
        convexFillHorizontal(v15, a7, v74);
      }
    }
    return 0;
  }
  BOOL v16 = v14 >= v13;
  if (a9 != -1) {
    BOOL v16 = v14 < v13;
  }
  if (!v16) {
    return 0;
  }
  int v17 = 0;
  int v18 = 0;
  uint64_t v19 = 0;
  CGRect v20 = &a1[v13];
  CGRect v21 = &a1[v14];
  int v22 = -1;
  int v23 = -1;
  do
  {
    if ((x & 0x80000000) != 0)
    {
      unint64_t v26 = 0;
      unint64_t v25 = 0;
      int v28 = x;
    }
    else
    {
      uint64_t v24 = 0;
      unint64_t v25 = 0;
      unint64_t v26 = 0;
      int v27 = &v21[x];
      do
      {
        if (v27[v24] <= a7) {
          break;
        }
        v26 += ((int)x + (int)v24) * (unint64_t)v27[v24];
        v25 += v27[v24];
        ++v19;
        --v24;
      }
      while (&v27[v24] >= v21);
      int v28 = x + v24;
    }
    int v29 = x + 1;
    if ((int)x + 1 < (uint64_t)a3)
    {
      uint64_t v30 = &v21[v29];
      do
      {
        if (*v30 <= a7) {
          break;
        }
        v26 += *v30 * (uint64_t)v29;
        v25 += *v30;
        ++v19;
        ++v29;
        ++v30;
      }
      while (v30 < &v21[a3]);
    }
    int v31 = v28 + 1;
    int v32 = v29 - v31;
    float v33 = (float)v25;
    if (v29 - v31 < 1) {
      int v34 = 0;
    }
    else {
      int v34 = (int)(float)(v33 / (float)v32);
    }
    if (v23 == -1)
    {
      int v35 = -1;
    }
    else
    {
      if (v31 > v23) {
        int v23 = v31;
      }
      if (v29 < v22) {
        int v22 = v29;
      }
      int v35 = v22 - v23;
    }
    if (v32 < 1) {
      break;
    }
    if (v18 == 5)
    {
      float v36 = (char *)v79 + 28 * v17;
      int v37 = *((_DWORD *)v36 + 2);
      uint64_t v38 = *((int *)v36 + 1);
      if (v37 > (int)v38)
      {
        uint64_t v39 = *((int *)v79 + 7 * v17);
        double v40 = &a2[v39 * a6 + v38];
        int v41 = &a1[v39 * a5 + v38];
        int v42 = v37 - v38;
        do
        {
          unsigned __int8 v43 = *v41++;
          *v40++ = v43;
          --v42;
        }
        while (v42);
      }
      int v18 = 4;
    }
    int v44 = (_DWORD *)v79 + 7 * v17;
    *int v44 = y;
    v44[1] = v31;
    v44[2] = v29;
    v44[3] = v35;
    v44[4] = v34;
    ++v18;
    if (v17 == 4) {
      int v17 = 0;
    }
    else {
      ++v17;
    }
    if (v18 == 5)
    {
      for (uint64_t i = 0; i != 5; ++i)
      {
        int v46 = v17 + i;
        if (v17 + (int)i > 4) {
          int v46 = v17 - 5 + i;
        }
        *(_DWORD *)&v75[4 * i] = v46;
      }
      int v47 = v76;
      int v48 = v76;
      int v49 = *((_DWORD *)v79 + 7 * v76 + 3);
      for (uint64_t j = 8; j != 20; j += 4)
      {
        int v51 = (_DWORD *)v79 + 7 * v47;
        int v52 = *(_DWORD *)&v75[j];
        int v53 = *((_DWORD *)v79 + 7 * v52 + 3);
        if (v49 >= v53) {
          int v49 = *((_DWORD *)v79 + 7 * v52 + 3);
        }
        v51[5] = v51[4] * v49 * (v51[2] - v51[1]);
        v51[6] = v49;
        int v49 = v53;
        int v47 = v52;
      }
      if (*((int *)&v79[1] + 7 * v77 + 2) <= 7)
      {
        int v54 = *((_DWORD *)&v79[1] + 7 * v77 + 1);
        int v55 = *((_DWORD *)&v79[1] + 7 * v48 + 1);
        if (v54 < v55)
        {
          int v56 = *((_DWORD *)&v79[1] + 7 * v78 + 1);
          if (v54 < v56 && (float)v54 * 2.8 < (float)(v56 + v55))
          {
            int v18 = 3;
            goto LABEL_64;
          }
        }
      }
      int v18 = 5;
    }
    if (v32 < 5) {
      break;
    }
    LODWORD(x) = (int)(float)((float)v26 / v33);
    LODWORD(y) = y + a9;
    v21 += (int)v12;
    BOOL v57 = v21 >= v20;
    if (a9 != -1) {
      BOOL v57 = v21 < v20;
    }
    int v22 = v29;
    int v23 = v31;
  }
  while (v57);
  if (v18 < 1) {
    return v19;
  }
LABEL_64:
  int v59 = v17 - v18;
  BOOL v58 = v17 < v18;
  int v60 = v17 - v18 + 5;
  if (v58) {
    int v61 = v60;
  }
  else {
    int v61 = v59;
  }
  do
  {
    int v62 = v61;
    char v63 = (char *)v79 + 28 * v61;
    int v64 = *((_DWORD *)v63 + 2);
    uint64_t v65 = *((int *)v63 + 1);
    if (v64 > (int)v65)
    {
      uint64_t v66 = *((int *)v79 + 7 * v62);
      uint64_t v67 = &a2[v66 * a6 + v65];
      int v68 = &a1[v66 * a5 + v65];
      int v69 = v64 - v65;
      do
      {
        unsigned __int8 v70 = *v68++;
        *v67++ = v70;
        --v69;
      }
      while (v69);
    }
    if (v62 == 4) {
      int v61 = 0;
    }
    else {
      int v61 = v62 + 1;
    }
    BOOL v71 = __OFSUB__(v18--, 1);
  }
  while (!((v18 < 0) ^ v71 | (v18 == 0)));
  return v19;
}

BOOL fillR8(void *a1, unsigned __int8 *a2, int a3, int a4)
{
  unsigned int v4 = a2[a1[1] * a4 + a3];
  unsigned int v5 = *(unsigned __int8 *)a1;
  ++*((_DWORD *)a1 + 8);
  return v4 > v5;
}

CIImage *RRcombineRGBA(CIImage *a1, CIImage *a2, CIImage *a3, CIImage *a4)
{
  v38[4] = *MEMORY[0x1E4F143B8];
  CGFloat v8 = +[CIKernel kernelWithInternalRepresentation:&CI::_drr_combine_rgba];
  [(CIImage *)a1 extent];
  CGFloat v10 = v9;
  CGFloat v12 = v11;
  CGFloat v14 = v13;
  CGFloat v16 = v15;
  [(CIImage *)a2 extent];
  v44.origin.CGFloat x = v17;
  v44.origin.CGFloat y = v18;
  v44.size.CGFloat width = v19;
  v44.size.CGFloat height = v20;
  v39.origin.CGFloat x = v10;
  v39.origin.CGFloat y = v12;
  v39.size.CGFloat width = v14;
  v39.size.CGFloat height = v16;
  CGRect v40 = CGRectUnion(v39, v44);
  CGFloat x = v40.origin.x;
  CGFloat y = v40.origin.y;
  CGFloat width = v40.size.width;
  CGFloat height = v40.size.height;
  [(CIImage *)a3 extent];
  CGFloat v26 = v25;
  CGFloat v28 = v27;
  CGFloat v30 = v29;
  CGFloat v32 = v31;
  [(CIImage *)a4 extent];
  v45.origin.CGFloat x = v33;
  v45.origin.CGFloat y = v34;
  v45.size.CGFloat width = v35;
  v45.size.CGFloat height = v36;
  v41.origin.CGFloat x = v26;
  v41.origin.CGFloat y = v28;
  v41.size.CGFloat width = v30;
  v41.size.CGFloat height = v32;
  CGRect v46 = CGRectUnion(v41, v45);
  v42.origin.CGFloat x = x;
  v42.origin.CGFloat y = y;
  v42.size.CGFloat width = width;
  v42.size.CGFloat height = height;
  CGRect v43 = CGRectUnion(v42, v46);
  v38[0] = a1;
  v38[1] = a2;
  v38[2] = a3;
  v38[3] = a4;
  return -[CIColorKernel applyWithExtent:arguments:](v8, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v38 count:4], v43.origin.x, v43.origin.y, v43.size.width, v43.size.height);
}

CIImage *RRextractR8(CIImage *a1)
{
  v8[1] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = +[CIKernel kernelWithInternalRepresentation:&CI::_drr_r];
  [(CIImage *)a1 extent];
  v8[0] = a1;
  return -[CIColorKernel applyWithExtent:arguments:](v2, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v8 count:1], v3, v4, v5, v6);
}

CIImage *RRextractG8(CIImage *a1)
{
  v8[1] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = +[CIKernel kernelWithInternalRepresentation:&CI::_drr_g];
  [(CIImage *)a1 extent];
  v8[0] = a1;
  return -[CIColorKernel applyWithExtent:arguments:](v2, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v8 count:1], v3, v4, v5, v6);
}

CIImage *RRextractB8(CIImage *a1)
{
  v8[1] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = +[CIKernel kernelWithInternalRepresentation:&CI::_drr_b];
  [(CIImage *)a1 extent];
  v8[0] = a1;
  return -[CIColorKernel applyWithExtent:arguments:](v2, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v8 count:1], v3, v4, v5, v6);
}

CIImage *RRextractA8(CIImage *a1)
{
  v8[1] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = +[CIKernel kernelWithInternalRepresentation:&CI::_drr_a];
  [(CIImage *)a1 extent];
  v8[0] = a1;
  return -[CIColorKernel applyWithExtent:arguments:](v2, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v8 count:1], v3, v4, v5, v6);
}

CIImage *RRsmoothstep(CIImage *a1, float a2)
{
  _OWORD v14[2] = *MEMORY[0x1E4F143B8];
  double v4 = +[CIKernel kernelWithInternalRepresentation:&CI::_drr_smoothstepRh];
  [(CIImage *)a1 extent];
  double v6 = v5;
  double v8 = v7;
  double v10 = v9;
  double v12 = v11;
  v14[0] = a1;
  *(float *)&double v5 = a2;
  v14[1] = [NSNumber numberWithFloat:v5];
  return -[CIColorKernel applyWithExtent:arguments:](v4, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v14 count:2], v6, v8, v10, v12);
}

CIImage *RRmaxIfGreaterThanZeroRh(CIImage *a1, CIImage *a2)
{
  void v18[2] = *MEMORY[0x1E4F143B8];
  double v4 = +[CIKernel kernelWithInternalRepresentation:&CI::_drr_maxmask];
  [(CIImage *)a1 extent];
  CGFloat v6 = v5;
  CGFloat v8 = v7;
  CGFloat v10 = v9;
  CGFloat v12 = v11;
  [(CIImage *)a2 extent];
  v21.origin.CGFloat x = v13;
  v21.origin.CGFloat y = v14;
  v21.size.CGFloat width = v15;
  v21.size.CGFloat height = v16;
  v19.origin.CGFloat x = v6;
  v19.origin.CGFloat y = v8;
  v19.size.CGFloat width = v10;
  v19.size.CGFloat height = v12;
  CGRect v20 = CGRectUnion(v19, v21);
  v18[0] = a1;
  v18[1] = a2;
  return -[CIColorKernel applyWithExtent:arguments:](v4, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v18 count:2], v20.origin.x, v20.origin.y, v20.size.width, v20.size.height);
}

CIImage *RRmaxRhScalar(CIImage *a1, float a2)
{
  _OWORD v14[2] = *MEMORY[0x1E4F143B8];
  double v4 = +[CIKernel kernelWithInternalRepresentation:&CI::_drr_maxScalarRh];
  [(CIImage *)a1 extent];
  double v6 = v5;
  double v8 = v7;
  double v10 = v9;
  double v12 = v11;
  v14[0] = a1;
  *(float *)&double v5 = a2;
  v14[1] = [NSNumber numberWithFloat:v5];
  return -[CIColorKernel applyWithExtent:arguments:](v4, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v14 count:2], v6, v8, v10, v12);
}

CIImage *RRminimumRh(CIImage *a1, CIImage *a2)
{
  void v18[2] = *MEMORY[0x1E4F143B8];
  double v4 = +[CIKernel kernelWithInternalRepresentation:&CI::_drr_minimumRh];
  [(CIImage *)a1 extent];
  CGFloat v6 = v5;
  CGFloat v8 = v7;
  CGFloat v10 = v9;
  CGFloat v12 = v11;
  [(CIImage *)a2 extent];
  v21.origin.CGFloat x = v13;
  v21.origin.CGFloat y = v14;
  v21.size.CGFloat width = v15;
  v21.size.CGFloat height = v16;
  v19.origin.CGFloat x = v6;
  v19.origin.CGFloat y = v8;
  v19.size.CGFloat width = v10;
  v19.size.CGFloat height = v12;
  CGRect v20 = CGRectUnion(v19, v21);
  v18[0] = a1;
  v18[1] = a2;
  return -[CIColorKernel applyWithExtent:arguments:](v4, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v18 count:2], v20.origin.x, v20.origin.y, v20.size.width, v20.size.height);
}

CIImage *RRmultiplyRh(CIImage *a1, CIImage *a2)
{
  _OWORD v19[2] = *MEMORY[0x1E4F143B8];
  double v4 = +[CIKernel kernelWithInternalRepresentation:&CI::_drr_multiply];
  if (a1 && a2)
  {
    double v5 = v4;
    [(CIImage *)a1 extent];
    CGFloat v7 = v6;
    CGFloat v9 = v8;
    CGFloat v11 = v10;
    CGFloat v13 = v12;
    [(CIImage *)a2 extent];
    v23.origin.CGFloat x = v14;
    v23.origin.CGFloat y = v15;
    v23.size.CGFloat width = v16;
    v23.size.CGFloat height = v17;
    v21.origin.CGFloat x = v7;
    v21.origin.CGFloat y = v9;
    v21.size.CGFloat width = v11;
    v21.size.CGFloat height = v13;
    CGRect v22 = CGRectUnion(v21, v23);
    v19[0] = a1;
    v19[1] = a2;
    return -[CIColorKernel applyWithExtent:arguments:](v5, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v19 count:2], v22.origin.x, v22.origin.y, v22.size.width, v22.size.height);
  }
  else
  {
    return +[CIImage emptyImage];
  }
}

CIImage *refilterChannel(CIImage *a1)
{
  v8[1] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = +[CIKernel kernelWithInternalRepresentation:&CI::_drr_refilter_chan];
  [(CIImage *)a1 extent];
  v8[0] = a1;
  return -[CIColorKernel applyWithExtent:arguments:](v2, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v8 count:1], v3, v4, v5, v6);
}

CIImage *RRbinarize(CIImage *a1)
{
  v8[1] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = +[CIKernel kernelWithInternalRepresentation:&CI::_drr_binarize];
  [(CIImage *)a1 extent];
  v8[0] = a1;
  return -[CIColorKernel applyWithExtent:arguments:](v2, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v8 count:1], v3, v4, v5, v6);
}

CIImage *RRbinarizeInverse(CIImage *a1)
{
  v8[1] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = +[CIKernel kernelWithInternalRepresentation:&CI::_drr_binarize_inv];
  [(CIImage *)a1 extent];
  v8[0] = a1;
  return -[CIColorKernel applyWithExtent:arguments:](v2, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v8 count:1], v3, v4, v5, v6);
}

CIImage *RRbinarizeAlpha(CIImage *a1, CIImage *a2, float a3)
{
  void v13[3] = *MEMORY[0x1E4F143B8];
  double v6 = +[CIKernel kernelWithInternalRepresentation:&CI::_drr_binarize_alpha];
  double v7 = *MEMORY[0x1E4F1DB10];
  double v8 = *(double *)(MEMORY[0x1E4F1DB10] + 8);
  double v9 = *(double *)(MEMORY[0x1E4F1DB10] + 16);
  double v10 = *(double *)(MEMORY[0x1E4F1DB10] + 24);
  *(float *)&double v11 = a3;
  v13[2] = objc_msgSend(NSNumber, "numberWithFloat:", v11, a1, a2);
  return -[CIColorKernel applyWithExtent:arguments:](v6, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v13 count:3], v7, v8, v9, v10);
}

CIImage *RRbinarizeAlphaInverse(CIImage *a1, CIImage *a2, float a3)
{
  void v13[3] = *MEMORY[0x1E4F143B8];
  double v6 = +[CIKernel kernelWithInternalRepresentation:&CI::_drr_binarize_alpha_inv];
  double v7 = *MEMORY[0x1E4F1DB10];
  double v8 = *(double *)(MEMORY[0x1E4F1DB10] + 8);
  double v9 = *(double *)(MEMORY[0x1E4F1DB10] + 16);
  double v10 = *(double *)(MEMORY[0x1E4F1DB10] + 24);
  *(float *)&double v11 = a3;
  v13[2] = objc_msgSend(NSNumber, "numberWithFloat:", v11, a1, a2);
  return -[CIColorKernel applyWithExtent:arguments:](v6, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v13 count:3], v7, v8, v9, v10);
}

CIImage *RRconditionalZero(CIImage *a1, CIImage *a2, float a3)
{
  v24[3] = *MEMORY[0x1E4F143B8];
  double v6 = +[CIKernel kernelWithInternalRepresentation:&CI::_drr_conditionalZeroRh];
  [(CIImage *)a1 extent];
  CGFloat v8 = v7;
  CGFloat v10 = v9;
  CGFloat v12 = v11;
  CGFloat v14 = v13;
  [(CIImage *)a2 extent];
  v27.origin.double x = v15;
  v27.origin.double y = v16;
  v27.size.double width = v17;
  v27.size.double height = v18;
  v25.origin.double x = v8;
  v25.origin.double y = v10;
  v25.size.double width = v12;
  v25.size.double height = v14;
  CGRect v26 = CGRectUnion(v25, v27);
  double x = v26.origin.x;
  double y = v26.origin.y;
  double width = v26.size.width;
  double height = v26.size.height;
  *(float *)&v26.origin.double x = a3;
  void v24[2] = objc_msgSend(NSNumber, "numberWithFloat:", v26.origin.x, a1, a2);
  return -[CIColorKernel applyWithExtent:arguments:](v6, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v24 count:3], x, y, width, height);
}

CIImage *feather(CIImage *a1, CGRect a2, float a3, float a4, float a5)
{
  double height = a2.size.height;
  double width = a2.size.width;
  double y = a2.origin.y;
  double x = a2.origin.x;
  v23[1] = *MEMORY[0x1E4F143B8];
  double v10 = round(a4 * 0.1 * a3);
  if (v10 <= 3.0) {
    double v10 = 3.0;
  }
  float v11 = v10;
  CGFloat v12 = -[CIImage imageByCroppingToRect:](a1, "imageByCroppingToRect:", x, a2.origin.y);
  *(float *)&double v13 = (float)(v11 + v11) * a5;
  CGRect v22 = @"inputRadius";
  v23[0] = [NSNumber numberWithFloat:v13];
  char v14 = 1;
  CGFloat v15 = -[CIImage imageByCroppingToRect:](-[CIImage imageByApplyingFilter:withInputParameters:](v12, "imageByApplyingFilter:withInputParameters:", @"CIMorphologyMaximum", [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v23 forKeys:&v22 count:1]), "imageByCroppingToRect:", x, y, width, height);
  do
  {
    char v17 = v14;
    CGRect v20 = @"inputRadius";
    *(float *)&double v16 = v11;
    uint64_t v21 = [NSNumber numberWithFloat:v16];
    CGFloat v18 = -[CIImage imageByCroppingToRect:](-[CIImage imageByApplyingFilter:withInputParameters:](v15, "imageByApplyingFilter:withInputParameters:", @"CIBoxBlur", [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v21 forKeys:&v20 count:1]), "imageByCroppingToRect:", x, y, width, height);
    CGFloat v15 = v18;
    char v14 = 0;
  }
  while ((v17 & 1) != 0);
  return -[CIImage imageByCroppingToRect:](v18, "imageByCroppingToRect:", x, y, width, height);
}

CIImage *chromaExclusion(CIImage *a1, CIImage *a2, CGRect a3, float a4, float a5, float a6, float a7)
{
  double height = a3.size.height;
  double width = a3.size.width;
  double y = a3.origin.y;
  double x = a3.origin.x;
  v39[1] = *MEMORY[0x1E4F143B8];
  double v16 = [(CIImage *)a1 imageByClampingToExtent];
  char v17 = [(CIImage *)a2 imageByClampingToExtent];
  CGFloat v18 = RRbinarizeAlphaInverse(v16, v17, a5);
  CGRect v19 = RRbinarizeAlpha(v16, v17, a5);
  uint64_t v38 = @"inputExtent";
  v39[0] = +[CIVector vectorWithCGRect:](CIVector, "vectorWithCGRect:", x, y, width, height);
  CGRect v20 = -[CIImage imageByApplyingFilter:withInputParameters:](v18, "imageByApplyingFilter:withInputParameters:", @"CIAreaAverage", [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v39 forKeys:&v38 count:1]);
  CGFloat v36 = @"inputExtent";
  int v37 = +[CIVector vectorWithCGRect:](CIVector, "vectorWithCGRect:", x, y, width, height);
  uint64_t v21 = -[CIImage imageByApplyingFilter:withInputParameters:](v19, "imageByApplyingFilter:withInputParameters:", @"CIAreaAverage", [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v37 forKeys:&v36 count:1]);
  CGRect v22 = [(CIImage *)v20 imageByUnpremultiplyingAlpha];
  [(CIImage *)v22 extent];
  uint64_t v23 = -[CIImage imageByClampingToExtent](-[CIImage imageBySettingAlphaOneInExtent:](v22, "imageBySettingAlphaOneInExtent:"), "imageByClampingToExtent");
  uint64_t v24 = [(CIImage *)v21 imageByUnpremultiplyingAlpha];
  [(CIImage *)v24 extent];
  uint64_t v25 = -[CIImage imageByClampingToExtent](-[CIImage imageBySettingAlphaOneInExtent:](v24, "imageBySettingAlphaOneInExtent:"), "imageByClampingToExtent");
  CGRect v26 = +[CIKernel kernelWithInternalRepresentation:&CI::_drr_chromaexc];
  *(float *)&double v27 = a4 * a4;
  double v28 = *MEMORY[0x1E4F1DB10];
  double v29 = *(double *)(MEMORY[0x1E4F1DB10] + 8);
  double v30 = *(double *)(MEMORY[0x1E4F1DB10] + 16);
  double v31 = *(double *)(MEMORY[0x1E4F1DB10] + 24);
  v35[2] = objc_msgSend(NSNumber, "numberWithFloat:", v27, v23, v25);
  *(float *)&double v32 = a6;
  v35[3] = [NSNumber numberWithFloat:v32];
  *(float *)&double v33 = a7;
  v35[4] = [NSNumber numberWithFloat:v33];
  return -[CIColorKernel applyWithExtent:arguments:](v26, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v35 count:5], v28, v29, v30, v31);
}

CIImage *RRspecularMask(CIImage *a1, CIImage *a2, float a3, float a4)
{
  v27[4] = *MEMORY[0x1E4F143B8];
  CGFloat v8 = +[CIKernel kernelWithInternalRepresentation:&CI::_drr_detect_specs];
  [(CIImage *)a1 extent];
  CGFloat v10 = v9;
  CGFloat v12 = v11;
  CGFloat v14 = v13;
  CGFloat v16 = v15;
  [(CIImage *)a2 extent];
  v30.origin.double x = v17;
  v30.origin.double y = v18;
  v30.size.double width = v19;
  v30.size.double height = v20;
  v28.origin.double x = v10;
  v28.origin.double y = v12;
  v28.size.double width = v14;
  v28.size.double height = v16;
  CGRect v29 = CGRectUnion(v28, v30);
  double x = v29.origin.x;
  double y = v29.origin.y;
  double width = v29.size.width;
  double height = v29.size.height;
  v27[0] = a1;
  v27[1] = a2;
  *(float *)&v29.origin.double x = a4;
  v27[2] = [NSNumber numberWithFloat:v29.origin.x];
  *(float *)&double v25 = a3;
  void v27[3] = [NSNumber numberWithFloat:v25];
  return -[CIColorKernel applyWithExtent:arguments:](v8, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v27 count:4], x, y, width, height);
}

CIImage *RRradialEllipticalMask(CGRect a1, CIVector *a2, objc_object *a3, float a4, float a5, float a6, float a7)
{
  double height = a1.size.height;
  double width = a1.size.width;
  v45[8] = *MEMORY[0x1E4F143B8];
  double v15 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_drr_mmv, a1.origin.x, a1.origin.y);
  CGFloat v16 = +[CIKernel kernelWithInternalRepresentation:&CI::_drr_mmi];
  objc_opt_class();
  float v44 = a6;
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      double v15 = v16;
    }
    else {
      double v15 = 0;
    }
  }
  [(CIVector *)a2 X];
  double v18 = v17;
  [(CIVector *)a2 X];
  double v20 = v19;
  [(CIVector *)a2 Y];
  double v22 = v21;
  [(CIVector *)a2 Y];
  *(float *)&double v23 = sqrt(v22 * v23 + v18 * v20);
  double v24 = *(float *)&v23;
  if (*(float *)&v23 >= 0.000001)
  {
    float v26 = 1.0 / sqrt(height * height + width * width);
    [(CIVector *)a2 X];
    double v28 = v27 / v24;
    [(CIVector *)a2 Y];
    CGRect v30 = +[CIVector vectorWithX:v28 Y:v29 / v24];
    [(CIVector *)v30 Y];
    double v32 = -v31;
    [(CIVector *)v30 X];
    CGFloat v34 = +[CIVector vectorWithX:v32 Y:v33];
    *(float *)&double v32 = v26 / a5;
    double v35 = *MEMORY[0x1E4F1DB10];
    double v36 = *(double *)(MEMORY[0x1E4F1DB10] + 8);
    float v37 = v26 / a4;
    double v38 = *(double *)(MEMORY[0x1E4F1DB10] + 16);
    double v39 = *(double *)(MEMORY[0x1E4F1DB10] + 24);
    v45[0] = a3;
    v45[1] = v30;
    v45[2] = v34;
    v45[3] = &unk_1EE4AB700;
    *(float *)&double v40 = v44;
    v45[4] = [NSNumber numberWithFloat:v40];
    LODWORD(v41) = LODWORD(v32);
    v45[5] = [NSNumber numberWithFloat:v41];
    *(float *)&double v42 = v37;
    v45[6] = [NSNumber numberWithFloat:v42];
    *(float *)&double v43 = a7;
    v45[7] = [NSNumber numberWithFloat:v43];
    return -[CIColorKernel applyWithExtent:arguments:](v15, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v45 count:8], v35, v36, v38, v39);
  }
  else
  {
    return +[CIImage emptyImage];
  }
}

CIImage *RRradialMask(CIVector *a1, CGRect a2, float a3, float a4, int a5)
{
  double height = a2.size.height;
  double width = a2.size.width;
  double y = a2.origin.y;
  double x = a2.origin.x;
  v28[4] = *MEMORY[0x1E4F143B8];
  double v13 = +[CIKernel kernelWithInternalRepresentation:&CI::_drr_puncture2];
  CGFloat v14 = +[CIKernel kernelWithInternalRepresentation:&CI::_drr_puncture2_hard];
  double v15 = +[CIVector vectorWithX:1.0 / (width * width) Y:1.0 / (height * height)];
  if (a5)
  {
    if (width >= height) {
      double v17 = height;
    }
    else {
      double v17 = width;
    }
    float v18 = v17;
    double v15 = +[CIVector vectorWithX:1.0 / (float)(v18 * v18) Y:1.0 / (float)(v18 * v18)];
  }
  double v19 = v15;
  if (!a1)
  {
    float v20 = x + width * 0.5;
    float v21 = y + height * 0.5;
    a1 = +[CIVector vectorWithX:roundf(v20) Y:roundf(v21)];
  }
  *(float *)&double v16 = a3 * 0.5;
  if (a4 >= 1.0) {
    double v13 = v14;
  }
  double v22 = *MEMORY[0x1E4F1DB10];
  double v23 = *(double *)(MEMORY[0x1E4F1DB10] + 8);
  double v24 = *(double *)(MEMORY[0x1E4F1DB10] + 16);
  double v25 = *(double *)(MEMORY[0x1E4F1DB10] + 24);
  v28[0] = a1;
  v28[1] = [NSNumber numberWithFloat:v16];
  *(float *)&double v26 = a4;
  v28[2] = [NSNumber numberWithFloat:v26];
  v28[3] = v19;
  return -[CIColorKernel applyWithExtent:arguments:](v13, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v28 count:4], v22, v23, v24, v25);
}

CIImage *RRradialCenterMask(CIImage *a1, CGRect a2, float a3, float a4, float a5)
{
  v20[4] = *MEMORY[0x1E4F143B8];
  double v9 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_drr_rcsoft, a2.origin.x, a2.origin.y, a2.size.width, a2.size.height);
  float v10 = a3 * a3;
  double v11 = *MEMORY[0x1E4F1DB10];
  double v12 = *(double *)(MEMORY[0x1E4F1DB10] + 8);
  double v13 = *(double *)(MEMORY[0x1E4F1DB10] + 16);
  double v14 = *(double *)(MEMORY[0x1E4F1DB10] + 24);
  v20[0] = a1;
  *(float *)&double v15 = a4 * a4;
  float v16 = 1.0 / v10;
  v20[1] = [NSNumber numberWithFloat:v15];
  *(float *)&double v17 = a5;
  v20[2] = [NSNumber numberWithFloat:v17];
  *(float *)&double v18 = v16;
  void v20[3] = [NSNumber numberWithFloat:v18];
  return -[CIColorKernel applyWithExtent:arguments:](v9, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v20 count:4], v11, v12, v13, v14);
}

CIImage *RRcloseByDilation(CIImage *a1, float a2)
{
  v19[1] = *MEMORY[0x1E4F143B8];
  [(CIImage *)a1 extent];
  double v5 = v4;
  double v7 = v6;
  double v9 = v8;
  double v11 = v10;
  double v18 = @"inputRadius";
  *(float *)&double v4 = a2;
  v19[0] = [NSNumber numberWithFloat:v4];
  double v12 = -[CIImage imageByApplyingFilter:withInputParameters:](a1, "imageByApplyingFilter:withInputParameters:", @"CIMorphologyMaximum", [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v19 forKeys:&v18 count:1]);
  float v16 = @"inputRadius";
  *(float *)&double v13 = a2;
  uint64_t v17 = [NSNumber numberWithFloat:v13];
  double v14 = -[CIImage imageByApplyingFilter:withInputParameters:](v12, "imageByApplyingFilter:withInputParameters:", @"CIMorphologyMinimum", [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v17 forKeys:&v16 count:1]);
  [(CIImage *)a1 extent];
  return -[CIImage imageByCroppingToRect:](-[CIImage imageByCroppingToRect:](v14, "imageByCroppingToRect:"), "imageByCroppingToRect:", v5, v7, v9, v11);
}

CIImage *RRcloseByErosion(CIImage *a1, float a2)
{
  v19[1] = *MEMORY[0x1E4F143B8];
  [(CIImage *)a1 extent];
  double v5 = v4;
  double v7 = v6;
  double v9 = v8;
  double v11 = v10;
  double v18 = @"inputRadius";
  *(float *)&double v4 = a2;
  v19[0] = [NSNumber numberWithFloat:v4];
  double v12 = -[CIImage imageByApplyingFilter:withInputParameters:](a1, "imageByApplyingFilter:withInputParameters:", @"CIMorphologyMinimum", [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v19 forKeys:&v18 count:1]);
  float v16 = @"inputRadius";
  *(float *)&double v13 = a2;
  uint64_t v17 = [NSNumber numberWithFloat:v13];
  double v14 = -[CIImage imageByApplyingFilter:withInputParameters:](v12, "imageByApplyingFilter:withInputParameters:", @"CIMorphologyMaximum", [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v17 forKeys:&v16 count:1]);
  [(CIImage *)a1 extent];
  return -[CIImage imageByCroppingToRect:](-[CIImage imageByCroppingToRect:](v14, "imageByCroppingToRect:"), "imageByCroppingToRect:", v5, v7, v9, v11);
}

CIImage *RRclip(CIImage *a1, float a2)
{
  _OWORD v14[2] = *MEMORY[0x1E4F143B8];
  double v4 = +[CIKernel kernelWithInternalRepresentation:&CI::_drr_pclip];
  [(CIImage *)a1 extent];
  double v6 = v5;
  double v8 = v7;
  double v10 = v9;
  double v12 = v11;
  v14[0] = a1;
  *(float *)&double v5 = a2;
  v14[1] = [NSNumber numberWithFloat:v5];
  return -[CIColorKernel applyWithExtent:arguments:](v4, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v14 count:2], v6, v8, v10, v12);
}

CIImage *RRspecularResponse(CIImage *a1)
{
  v8[1] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = +[CIKernel kernelWithInternalRepresentation:&CI::_drr_specular];
  [(CIImage *)a1 extent];
  v8[0] = a1;
  return -[CIColorKernel applyWithExtent:arguments:](v2, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v8 count:1], v3, v4, v5, v6);
}

CIImage *RRrawRedWhiteResponseSmallMedium(CIImage *a1, float a2, float a3)
{
  void v17[3] = *MEMORY[0x1E4F143B8];
  double v6 = +[CIKernel kernelWithInternalRepresentation:&CI::_drr_rawred_sm];
  [(CIImage *)a1 extent];
  double v8 = v7;
  double v10 = v9;
  double v12 = v11;
  double v14 = v13;
  *(float *)&double v7 = a2;
  v17[1] = objc_msgSend(NSNumber, "numberWithFloat:", v7, a1);
  *(float *)&double v15 = a3;
  v17[2] = [NSNumber numberWithFloat:v15];
  return -[CIColorKernel applyWithExtent:arguments:](v6, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v17 count:3], v8, v10, v12, v14);
}

CIImage *RRrawRedWhiteResponseLarge(CIImage *a1, float a2, float a3)
{
  void v17[3] = *MEMORY[0x1E4F143B8];
  double v6 = +[CIKernel kernelWithInternalRepresentation:&CI::_drr_rawred_large];
  [(CIImage *)a1 extent];
  double v8 = v7;
  double v10 = v9;
  double v12 = v11;
  double v14 = v13;
  *(float *)&double v7 = a2;
  v17[1] = objc_msgSend(NSNumber, "numberWithFloat:", v7, a1);
  *(float *)&double v15 = a3;
  v17[2] = [NSNumber numberWithFloat:v15];
  return -[CIColorKernel applyWithExtent:arguments:](v6, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v17 count:3], v8, v10, v12, v14);
}

__n64 cikernel::_drr_puncturec2(CI *a1, double a2, float a3, float a4, double a5)
{
  DC = (void *)CI::getDC(a1);
  float v8 = (float)(vmlas_n_f32(vmuls_lane_f32((float)(COERCE_FLOAT(HIDWORD(*DC)) - *((float *)&a2 + 1))* (float)(COERCE_FLOAT(HIDWORD(*DC)) - *((float *)&a2 + 1)), *(float32x2_t *)&a5, 1), (float)(COERCE_FLOAT(*DC) - *(float *)&a2) * (float)(COERCE_FLOAT(*DC) - *(float *)&a2), *(float *)&a5)- (float)((float)(a3 * a4) * a3))/ (float)((float)(a3 * a3) - (float)((float)(a3 * a4) * a3));
  if (v8 <= 1.0) {
    float v9 = v8;
  }
  else {
    float v9 = 1.0;
  }
  BOOL v10 = v8 < 0.0;
  float v11 = 0.0;
  if (!v10) {
    float v11 = v9;
  }
  result.n64_f32[0] = 1.0 - (float)((float)(v11 * v11) * (float)((float)(v11 * -2.0) + 3.0));
  result.n64_u32[1] = 0;
  return result;
}

void CI::f4_s_f_f_f2(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  float v11 = (double (*)(void *, __n128, float, float, double))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  uint64_t v14 = *(void *)(v10 + 32);
  uint64_t v15 = *(void *)(v10 + 56);
  int v16 = *(_DWORD *)(v10 + 88);
  uint64_t v17 = *(void *)(v10 + 80);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 104)), a2);
  }
  double v18 = (double *)(a3 + 16 * v17);
  if (v16 != 5) {
    double v18 = (double *)((char *)a2 + 64 * v17);
  }
  double v19 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    double v19 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v20 = v11(a1, *v19, *((float *)a2 + 16 * v14), *((float *)a2 + 16 * v15), *v18);
  *(_OWORD *)(a3 + 16 * a7) = v20;
}

double cikernel::_drr_puncturec2_hard(CI *a1, double a2, float a3, double a4, double a5)
{
  DC = (void *)CI::getDC(a1);
  int32x2_t v7 = 0;
  if (vmlas_n_f32(vmuls_lane_f32((float)(COERCE_FLOAT(HIDWORD(*DC)) - *((float *)&a2 + 1))* (float)(COERCE_FLOAT(HIDWORD(*DC)) - *((float *)&a2 + 1)), *(float32x2_t *)&a5, 1), (float)(COERCE_FLOAT(*DC) - *(float *)&a2) * (float)(COERCE_FLOAT(*DC) - *(float *)&a2), *(float *)&a5) <= (float)(a3 * a3))*(float *)v7.i32 = 1.0; {
  *(void *)&double result = vdupq_lane_s32(v7, 0).u64[0];
  }
  return result;
}

double cikernel::_drr_maximumRh(float32x4_t a1, float32x4_t a2)
{
  *(void *)&double result = vmaxnmq_f32(a1, a2).u64[0];
  return result;
}

double cikernel::_drr_combine_rgba(int32x4_t a1, int32x4_t a2)
{
  *(void *)&double result = vzip1q_s32(a1, a2).u64[0];
  return result;
}

void CI::f4_s_s_s_s(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  uint64_t v10 = *(double (**)(__n128, __n128, __n128, __n128))(a1 + 24);
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  int v13 = *(_DWORD *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  int v15 = *(_DWORD *)(v9 + 64);
  uint64_t v16 = *(void *)(v9 + 56);
  int v17 = *(_DWORD *)(v9 + 88);
  uint64_t v18 = *(void *)(v9 + 80);
  if (*(unsigned char *)(a1 + 64))
  {
    double v24 = *(double (**)(__n128, __n128, __n128, __n128))(a1 + 24);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 104)), a2);
    uint64_t v10 = v24;
  }
  double v19 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5) {
    double v19 = (__n128 *)((char *)a2 + 64 * v18);
  }
  long long v20 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5) {
    long long v20 = (__n128 *)((char *)a2 + 64 * v16);
  }
  float v21 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    float v21 = (__n128 *)((char *)a2 + 64 * v14);
  }
  double v22 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    double v22 = (__n128 *)((char *)a2 + 64 * v12);
  }
  *(double *)&long long v23 = v10(*v22, *v21, *v20, *v19);
  *(_OWORD *)(a3 + 16 * a7) = v23;
}

float cikernel::_drr_g(double a1)
{
  return *((float *)&a1 + 1);
}

float cikernel::_drr_b(__n128 a1)
{
  return a1.n128_f32[2];
}

float cikernel::_drr_a(__n128 a1)
{
  return a1.n128_f32[3];
}

__n64 cikernel::_drr_smoothstepRh(float a1, float a2)
{
  float v2 = a1 / a2;
  if (v2 <= 1.0) {
    float v3 = v2;
  }
  else {
    float v3 = 1.0;
  }
  BOOL v4 = v2 < 0.0;
  float v5 = 0.0;
  if (!v4) {
    float v5 = v3;
  }
  result.n64_f32[0] = (float)(v5 * v5) * (float)((float)(v5 * -2.0) + 3.0);
  result.n64_u32[1] = 0;
  return result;
}

double cikernel::_drr_maxmask(float32x4_t a1, float32x4_t a2)
{
  if (a1.f32[0] > 0.0) {
    a1.i64[0] = vmaxnmq_f32(a1, a2).u64[0];
  }
  return *(double *)a1.i64;
}

float cikernel::_drr_maxScalarRh(float a1, float a2)
{
  return fmaxf(a1, a2);
}

double cikernel::_drr_minimumRh(float32x4_t a1, float32x4_t a2)
{
  *(void *)&double result = vminnmq_f32(a1, a2).u64[0];
  return result;
}

double cikernel::_drr_multiply(float32x4_t a1, float32x4_t a2)
{
  *(void *)&double result = vmulq_f32(a1, a2).u64[0];
  return result;
}

double cikernel::_drr_refilter_chan(float a1)
{
  *(float *)&double v1 = a1;
  *((float *)&v1 + 1) = a1;
  return v1;
}

float cikernel::_drr_binarize(float a1)
{
  double v1 = 0.0;
  if (a1 > 0.00001) {
    return 1.0;
  }
  return v1;
}

float cikernel::_drr_binarize_inv(float a1)
{
  double v1 = 1.0;
  if (a1 > 0.00001) {
    return 0.0;
  }
  return v1;
}

double cikernel::_drr_binarize_alpha(float32x4_t a1, float a2, float a3)
{
  BOOL v3 = a2 <= 0.001;
  double v4 = 0.0;
  if (!v3) {
    double v4 = 1.0;
  }
  float v5 = v4;
  float32x4_t v6 = vmulq_n_f32(a1, v5);
  float v7 = 1.0;
  if (fminf(1.0 - v6.f32[0], v6.f32[0]) <= a3) {
    float v7 = 0.0;
  }
  *(void *)&double result = vmulq_n_f32(v6, v7).u64[0];
  return result;
}

double cikernel::_drr_binarize_alpha_inv(float32x4_t a1, float a2, float a3)
{
  BOOL v3 = a2 <= 0.001;
  double v4 = 1.0;
  if (!v3) {
    double v4 = 0.0;
  }
  float v5 = v4;
  float32x4_t v6 = vmulq_n_f32(a1, v5);
  float v7 = 1.0;
  if (fminf(1.0 - v6.f32[0], v6.f32[0]) <= a3) {
    float v7 = 0.0;
  }
  *(void *)&double result = vmulq_n_f32(v6, v7).u64[0];
  return result;
}

double cikernel::_drr_conditionalZeroRh(float32x4_t a1, float a2, float a3)
{
  BOOL v3 = a2 <= a3;
  float v4 = 0.0;
  if (!v3) {
    float v4 = 1.0;
  }
  *(void *)&double result = vmulq_n_f32(a1, v4).u64[0];
  return result;
}

__n64 cikernel::_drr_chromaexc(float32x4_t a1, float32x4_t a2, float a3, float a4, float32_t a5)
{
  float32x4_t v5 = vsubq_f32(a2, a1);
  float32x4_t v6 = vmulq_f32(v5, v5);
  LODWORD(v7) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), vaddq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1))).u32[0];
  float v8 = fminf(a2.f32[0], a1.f32[0]) * a3;
  if ((float)(fmaxf(a2.f32[0] - fminf(a2.f32[1], a2.f32[2]), 0.0) / fmaxf(a2.f32[0], 0.00001)) < a4 && a2.f32[0] > a5
    || v7 < v8)
  {
    result.n64_f32[0] = 0.0;
  }
  else
  {
    result.n64_f32[0] = 1.0;
  }
  result.n64_u32[1] = 0;
  return result;
}

__n64 cikernel::_drr_detect_specs(int8x16_t _Q0, int8x16_t _Q1, float _S2, int8x16_t a4)
{
  float v4 = fminf(*(float *)_Q1.i32, *(float *)&_Q1.i32[2]);
  __asm { FMLS            S0, S2, V1.S[1] }
  _Q1.i32[0] = 1.0;
  v9.i64[0] = 0x8000000080000000;
  v9.i64[1] = 0x8000000080000000;
  LODWORD(v10) = vbslq_s8(v9, _Q1, _Q0).u32[0];
  if (*(float *)_Q0.i32 == 0.0) {
    float v10 = 0.0;
  }
  float v11 = v4 * fmaxf(v10, 0.0);
  *(float *)a4.i32 = v11 - *(float *)a4.i32;
  LODWORD(v12) = vbslq_s8(v9, _Q1, a4).u32[0];
  if (*(float *)a4.i32 == 0.0) {
    float v12 = 0.0;
  }
  result.n64_f32[0] = 1.0 - (float)(v11 * fmaxf(v12, 0.0));
  result.n64_u32[1] = 0;
  return result;
}

__n64 cikernel::_drr_mmv(CI *a1, float32x2_t a2, float32x2_t a3, float32x2_t a4, float a5, float a6, float a7, float a8, float a9)
{
  float32x2_t v14 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  int32x2_t v15 = (int32x2_t)vmul_f32(a3, v14);
  float32x2_t v16 = vsub_f32(v14, vmul_n_f32(a3, vadd_f32((float32x2_t)v15, (float32x2_t)vdup_lane_s32(v15, 1)).f32[0]));
  int32x2_t v17 = (int32x2_t)vmul_f32(a4, v14);
  int32x2_t v18 = vdup_lane_s32(v17, 1);
  int32x2_t v19 = (int32x2_t)vmul_n_f32(a4, vadd_f32((float32x2_t)v17, (float32x2_t)v18).f32[0]);
  float32x2_t v20 = vsub_f32(v14, (float32x2_t)v19);
  int32x2_t v21 = (int32x2_t)vmul_f32(v16, v16);
  int32x2_t v22 = (int32x2_t)vmul_f32(v20, v20);
  *(float *)v19.i32 = a5 * a6;
  *(float *)v18.i32 = a5 - (float)(a5 * a6);
  float32x2_t v23 = vdiv_f32(vsub_f32(vmul_f32(vsqrt_f32(vadd_f32((float32x2_t)vzip1_s32(v21, v22), (float32x2_t)vzip2_s32(v21, v22))), (float32x2_t)__PAIR64__(LODWORD(a8), LODWORD(a7))), (float32x2_t)vdup_lane_s32(v19, 0)), (float32x2_t)vdup_lane_s32(v18, 0));
  __asm { FMOV            V2.2S, #1.0 }
  float32x2_t v29 = (float32x2_t)vbic_s8(vbsl_s8((int8x8_t)vcgt_f32(v23, _D2), (int8x8_t)_D2, (int8x8_t)v23), (int8x8_t)vcltz_f32(v23));
  __asm { FMOV            V4.2S, #3.0 }
  result.n64_u64[0] = (unint64_t)vsub_f32(_D2, vmul_f32(vmul_f32(v29, v29), vmla_f32(_D4, (float32x2_t)0xC0000000C0000000, v29)));
  result.n64_f32[0] = vmul_lane_f32((float32x2_t)result.n64_u64[0], (float32x2_t)result.n64_u64[0], 1).f32[0];
  if (result.n64_f32[0] > a9) {
    result.n64_f32[0] = 1.0;
  }
  result.n64_u32[1] = 0;
  return result;
}

void CI::f4_f2_f2_f2_f_f_f_f_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  float v10 = *(double (**)(double, double, double, float, float, float, float, float))(a1 + 24);
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  int v13 = *(_DWORD *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  int v15 = *(_DWORD *)(v9 + 64);
  uint64_t v16 = *(void *)(v9 + 56);
  uint64_t v17 = *(void *)(v9 + 80);
  uint64_t v18 = *(void *)(v9 + 104);
  uint64_t v19 = *(void *)(v9 + 128);
  uint64_t v20 = *(void *)(v9 + 152);
  uint64_t v21 = *(void *)(v9 + 176);
  if (*(unsigned char *)(a1 + 64))
  {
    double v27 = *(double (**)(double, double, double, float, float, float, float, float))(a1 + 24);
    uint64_t v28 = *(void *)(v9 + 152);
    uint64_t v29 = *(void *)(v9 + 128);
    int v26 = *(_DWORD *)(v9 + 64);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 200)), a2);
    int v15 = v26;
    uint64_t v20 = v28;
    uint64_t v19 = v29;
    float v10 = v27;
  }
  int32x2_t v22 = (double *)(a3 + 16 * v16);
  if (v15 != 5) {
    int32x2_t v22 = (double *)((char *)a2 + 64 * v16);
  }
  float32x2_t v23 = (double *)(a3 + 16 * v14);
  if (v13 != 5) {
    float32x2_t v23 = (double *)((char *)a2 + 64 * v14);
  }
  double v24 = (double *)(a3 + 16 * v12);
  if (v11 != 5) {
    double v24 = (double *)((char *)a2 + 64 * v12);
  }
  *(double *)&long long v25 = v10(*v24, *v23, *v22, *((float *)a2 + 16 * v17), *((float *)a2 + 16 * v18), *((float *)a2 + 16 * v19), *((float *)a2 + 16 * v20), *((float *)a2 + 16 * v21));
  *(_OWORD *)(a3 + 16 * a7) = v25;
}

__n64 cikernel::_drr_mmi(CI *a1, float32x2_t a2, float32x2_t a3, float32x2_t a4, float a5, float a6, float a7, float a8, float a9)
{
  float32x2_t v14 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  int32x2_t v15 = (int32x2_t)vmul_f32(a3, v14);
  float32x2_t v16 = vsub_f32(v14, vmul_n_f32(a3, vadd_f32((float32x2_t)v15, (float32x2_t)vdup_lane_s32(v15, 1)).f32[0]));
  int32x2_t v17 = (int32x2_t)vmul_f32(a4, v14);
  int32x2_t v18 = vdup_lane_s32(v17, 1);
  int32x2_t v19 = (int32x2_t)vmul_n_f32(a4, vadd_f32((float32x2_t)v17, (float32x2_t)v18).f32[0]);
  float32x2_t v20 = vsub_f32(v14, (float32x2_t)v19);
  int32x2_t v21 = (int32x2_t)vmul_f32(v16, v16);
  int32x2_t v22 = (int32x2_t)vmul_f32(v20, v20);
  *(float *)v19.i32 = a5 * a6;
  *(float *)v18.i32 = a5 - (float)(a5 * a6);
  float32x2_t v23 = vdiv_f32(vsub_f32(vmul_f32(vsqrt_f32(vadd_f32((float32x2_t)vzip1_s32(v21, v22), (float32x2_t)vzip2_s32(v21, v22))), (float32x2_t)__PAIR64__(LODWORD(a8), LODWORD(a7))), (float32x2_t)vdup_lane_s32(v19, 0)), (float32x2_t)vdup_lane_s32(v18, 0));
  __asm { FMOV            V2.2S, #1.0 }
  float32x2_t v29 = (float32x2_t)vbic_s8(vbsl_s8((int8x8_t)vcgt_f32(v23, _D2), (int8x8_t)_D2, (int8x8_t)v23), (int8x8_t)vcltz_f32(v23));
  __asm { FMOV            V4.2S, #3.0 }
  result.n64_u64[0] = (unint64_t)vsub_f32(_D2, vmul_f32(vmul_f32(v29, v29), vmla_f32(_D4, (float32x2_t)0xC0000000C0000000, v29)));
  result.n64_f32[0] = vmul_lane_f32((float32x2_t)result.n64_u64[0], (float32x2_t)result.n64_u64[0], 1).f32[0];
  if (result.n64_f32[0] > a9) {
    result.n64_f32[0] = 1.0;
  }
  result.n64_u32[1] = 0;
  return result;
}

void CI::f4_s_f2_f2_f_f_f_f_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  float v10 = *(double (**)(__n128, double, double, float, float, float, float, float))(a1 + 24);
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  int v13 = *(_DWORD *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  int v15 = *(_DWORD *)(v9 + 64);
  uint64_t v16 = *(void *)(v9 + 56);
  uint64_t v17 = *(void *)(v9 + 80);
  uint64_t v18 = *(void *)(v9 + 104);
  uint64_t v19 = *(void *)(v9 + 128);
  uint64_t v20 = *(void *)(v9 + 152);
  uint64_t v21 = *(void *)(v9 + 176);
  if (*(unsigned char *)(a1 + 64))
  {
    double v27 = *(double (**)(__n128, double, double, float, float, float, float, float))(a1 + 24);
    uint64_t v28 = *(void *)(v9 + 152);
    uint64_t v29 = *(void *)(v9 + 128);
    int v26 = *(_DWORD *)(v9 + 64);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 200)), a2);
    int v15 = v26;
    uint64_t v20 = v28;
    uint64_t v19 = v29;
    float v10 = v27;
  }
  int32x2_t v22 = (double *)(a3 + 16 * v16);
  if (v15 != 5) {
    int32x2_t v22 = (double *)((char *)a2 + 64 * v16);
  }
  float32x2_t v23 = (double *)(a3 + 16 * v14);
  if (v13 != 5) {
    float32x2_t v23 = (double *)((char *)a2 + 64 * v14);
  }
  double v24 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    double v24 = (__n128 *)((char *)a2 + 64 * v12);
  }
  *(double *)&long long v25 = v10(*v24, *v23, *v22, *((float *)a2 + 16 * v17), *((float *)a2 + 16 * v18), *((float *)a2 + 16 * v19), *((float *)a2 + 16 * v20), *((float *)a2 + 16 * v21));
  *(_OWORD *)(a3 + 16 * a7) = v25;
}

__n64 cikernel::_drr_puncture2(CI *a1, float32x2_t a2, float a3, float a4, double a5)
{
  float32x2_t v7 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  float32x2_t v8 = vmul_f32(v7, v7);
  float v9 = (float)(vmlas_n_f32(COERCE_FLOAT(vmul_f32(*(float32x2_t *)&a5, v8).i32[1]), *(float *)&a5, v8.f32[0])
             - (float)((float)(a3 * a4) * a3))
     / (float)((float)(a3 * a3) - (float)((float)(a3 * a4) * a3));
  if (v9 <= 1.0) {
    float v10 = v9;
  }
  else {
    float v10 = 1.0;
  }
  BOOL v11 = v9 < 0.0;
  float v12 = 0.0;
  if (!v11) {
    float v12 = v10;
  }
  result.n64_f32[0] = 1.0 - (float)((float)(v12 * v12) * (float)((float)(v12 * -2.0) + 3.0));
  result.n64_u32[1] = 0;
  return result;
}

void CI::f4_f2_f_f_f2(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  BOOL v11 = (double (*)(void *, double, float, float, double))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  uint64_t v14 = *(void *)(v10 + 32);
  uint64_t v15 = *(void *)(v10 + 56);
  int v16 = *(_DWORD *)(v10 + 88);
  uint64_t v17 = *(void *)(v10 + 80);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 104)), a2);
  }
  uint64_t v18 = (double *)(a3 + 16 * v17);
  if (v16 != 5) {
    uint64_t v18 = (double *)((char *)a2 + 64 * v17);
  }
  uint64_t v19 = (double *)(a3 + 16 * v13);
  if (v12 != 5) {
    uint64_t v19 = (double *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v20 = v11(a1, *v19, *((float *)a2 + 16 * v14), *((float *)a2 + 16 * v15), *v18);
  *(_OWORD *)(a3 + 16 * a7) = v20;
}

double cikernel::_drr_puncture2_hard(CI *a1, float32x2_t a2, float a3, double a4, double a5)
{
  float32x2_t v6 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  float32x2_t v7 = vmul_f32(v6, v6);
  float v8 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(*(float32x2_t *)&a5, v7).i32[1]), *(float *)&a5, v7.f32[0]);
  int32x2_t v9 = 0;
  if (v8 <= (float)(a3 * a3)) {
    *(float *)v9.i32 = 1.0;
  }
  *(void *)&double result = vdupq_lane_s32(v9, 0).u64[0];
  return result;
}

__n64 cikernel::_drr_rcsoft(CI *a1, double a2, float a3, float a4, float a5)
{
  DC = (void *)CI::getDC(a1);
  float v9 = (float)((float)((float)((float)((float)(COERCE_FLOAT(HIDWORD(*DC)) - *((float *)&a2 + 1))
                                     * (float)(COERCE_FLOAT(HIDWORD(*DC)) - *((float *)&a2 + 1)))
                             * a5)
                     + (float)((float)((float)(COERCE_FLOAT(*DC) - *(float *)&a2)
                                     * (float)(COERCE_FLOAT(*DC) - *(float *)&a2))
                             * a5))
             - (float)(a3 * a4))
     / (float)(a3 - (float)(a3 * a4));
  if (v9 <= 1.0) {
    float v10 = (float)((float)((float)((float)((float)(COERCE_FLOAT(HIDWORD(*DC)) - *((float *)&a2 + 1))
  }
                                        * (float)(COERCE_FLOAT(HIDWORD(*DC)) - *((float *)&a2 + 1)))
                                * a5)
                        + (float)((float)((float)(COERCE_FLOAT(*DC) - *(float *)&a2)
                                        * (float)(COERCE_FLOAT(*DC) - *(float *)&a2))
                                * a5))
                - (float)(a3 * a4))
        / (float)(a3 - (float)(a3 * a4));
  else {
    float v10 = 1.0;
  }
  BOOL v11 = v9 < 0.0;
  float v12 = 0.0;
  if (!v11) {
    float v12 = v10;
  }
  result.n64_f32[0] = 1.0 - (float)((float)(v12 * v12) * (float)((float)(v12 * -2.0) + 3.0));
  result.n64_u32[1] = 0;
  return result;
}

void CI::f4_sr_sr_f_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  BOOL v11 = *(void **)(a1 + 48);
  float v12 = *(double (**)(uint64_t, uint64_t, float, float))(a1 + 24);
  uint64_t v13 = v11[1];
  uint64_t v14 = v11[4];
  uint64_t v15 = v11[7];
  uint64_t v16 = v11[10];
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC((CI *)(a3 + 16 * v11[13]), a2);
  }
  *(double *)&long long v17 = v12(a4 + 80 * v13, a4 + 80 * v14, *((float *)a2 + 16 * v15), *((float *)a2 + 16 * v16));
  *(_OWORD *)(a3 + 16 * a7) = v17;
}

int8x8_t cikernel::_drr_pclip(int8x8_t a1, int32x2_t a2)
{
  return vbic_s8(a1, (int8x8_t)vcgt_f32((float32x2_t)vdup_lane_s32(a2, 0), (float32x2_t)a1));
}

double cikernel::_drr_specular(__n128 a1)
{
  a1.n128_f32[0] = (float)((float)(a1.n128_f32[2] + vaddv_f32((float32x2_t)a1.n128_u64[0]))
                         - fminf(fminf(a1.n128_f32[0], a1.n128_f32[1]), a1.n128_f32[2]))
                 * 0.5;
  a1.n128_u64[0] = vdupq_lane_s32((int32x2_t)a1.n128_u64[0], 0).u64[0];
  return a1.n128_f64[0];
}

__n64 cikernel::_drr_rawred_sm(float32x4_t a1, float a2, float a3)
{
  if (a1.f32[0] >= 0.005)
  {
    float32x4_t v4 = vmulq_f32(a1, (float32x4_t)vdupq_n_s32(0x3EAAAAABu));
    float32x4_t v5 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1)));
    LODWORD(v6) = vsubq_f32(a1, v5).u32[0];
    v5.f32[0] = fminf(fmaxf(a1.f32[0] - a1.f32[1], 0.0) / fmaxf(a1.f32[0] + a1.f32[1], 0.00001), fmaxf(a1.f32[0] - a1.f32[2], 0.0) / fmaxf(a1.f32[0] + a1.f32[2], 0.00001))* (float)((float)(vmlas_n_f32((float)(a1.f32[1] - v5.f32[0]) * (float)(a1.f32[1] - v5.f32[0]), v6, v6)+ (float)((float)(a1.f32[2] - v5.f32[0]) * (float)(a1.f32[2] - v5.f32[0])))/ fmaxf(v5.f32[0], 0.0001));
    result.n64_f32[0] = (float)(fmaxf(a1.f32[0] - (float)(a2 * fmaxf(a1.f32[1], a1.f32[2])), 0.0) * a3)
                      + (float)((float)((float)(v5.f32[0] * 10.0) * (float)(v5.f32[0] * 10.0)) * (float)(1.0 - a3));
    result.n64_u32[1] = 0;
  }
  else
  {
    return 0;
  }
  return result;
}

__n64 cikernel::_drr_rawred_large(float32x4_t a1, float a2, float a3)
{
  if (a1.f32[0] >= 0.005)
  {
    float32x4_t v4 = vmulq_f32(a1, (float32x4_t)vdupq_n_s32(0x3EAAAAABu));
    float32x4_t v5 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1)));
    LODWORD(v6) = vsubq_f32(a1, v5).u32[0];
    result.n64_f32[0] = (float)(a1.f32[0] * a2)
                      + (float)((float)(fminf(fmaxf(a1.f32[0] - a1.f32[1], 0.0) / fmaxf(a1.f32[0] + a1.f32[1], 0.00001), fmaxf(a1.f32[0] - a1.f32[2], 0.0) / fmaxf(a1.f32[0] + a1.f32[2], 0.00001))* (float)((float)(1.0 - a3)+ (float)((float)((float)(vmlas_n_f32((float)(a1.f32[1] - v5.f32[0])* (float)(a1.f32[1] - v5.f32[0]), v6, v6)+ (float)((float)(a1.f32[2] - v5.f32[0])* (float)(a1.f32[2] - v5.f32[0])))/ fmaxf(v5.f32[0], 0.0001))* a3)))* (float)(1.0 - a2));
    result.n64_u32[1] = 0;
  }
  else
  {
    return 0;
  }
  return result;
}

void ReductionROIwh(CGRect a1, float a2, float a3, float a4, float a5)
{
  ReductionROIw(a1, a2, a4);

  ReductionROIh(*(CGRect *)&v7, a3, a5);
}

void ReductionROIh(CGRect a1, float a2, float a3)
{
  double v3 = a2;
  CGFloat v4 = a1.origin.y * v3;
  CGFloat v5 = a1.size.height * v3;
  CGRectIntegral(a1);
}

void ReductionROIw(CGRect a1, float a2, float a3)
{
  double v3 = a2;
  CGFloat v4 = a1.origin.x * v3;
  CGFloat v5 = a1.size.width * v3;
  CGRectIntegral(a1);
}

void ReductionROI(CGRect a1, float a2, float a3)
{
  CGFloat height = a1.size.height;
  CGFloat width = a1.size.width;
  CGFloat y = a1.origin.y;
  CGFloat x = a1.origin.x;
  memset(&v8, 0, sizeof(v8));
  CGAffineTransformMakeScale(&v8, a2, a3);
  CGAffineTransform v7 = v8;
  v9.origin.CGFloat x = x;
  v9.origin.CGFloat y = y;
  v9.size.CGFloat width = width;
  v9.size.CGFloat height = height;
  CGRect v10 = CGRectApplyAffineTransform(v9, &v7);
  CGRectIntegral(v10);
}

double cikernel::_reduceCrop(cikernel *this, SamplerObj *a2, double a3, float64x2_t a4, double a5, double a6, int8x16_t a7, int8x16_t a8, int8x16_t a9)
{
  a7.i32[0] = 0.5;
  LODWORD(a5) = *((_DWORD *)this + 7);
  *(float *)&double v9 = *((float *)this + 6)
                + (float)((float)(*((float *)this + 5) * 0.5) + (float)(*((float *)this + 4) * 0.5));
  LODWORD(a6) = *((_DWORD *)this + 9);
  *(float *)a4.f64 = *(float *)&a6 + (float)((float)(*((float *)this + 8) * 0.5) + (float)(*(float *)&a5 * 0.5));
  *((float *)&v9 + 1) = *(float *)a4.f64;
  *(double *)v10.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v9, a4, a5, a6, a7, a8, a9);
  int8x16_t v15 = v10;
  *(float32x2_t *)v12.f32 = vabs_f32(vadd_f32(*(float32x2_t *)CI::getDC(v11), (float32x2_t)0xBF000000BF000000));
  v12.f32[0] = fmaxf(v12.f32[0], v12.f32[1]);
  v13.i64[0] = COERCE_UNSIGNED_INT(0.5) | 0xBF00000000000000;
  *(void *)&double result = vandq_s8(v15, (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(v13, v12), 0)).u64[0];
  return result;
}

double cikernel::_areaAvg8(cikernel *this, SamplerObj *a2)
{
  DC = (float32x2_t *)CI::getDC(this);
  HIDWORD(v4.f64[0]) = 1090519040;
  float32x2_t v5 = vmul_f32(*DC, (float32x2_t)0x4100000041000000);
  __asm { FMOV            V0.2S, #-3.0 }
  float32x2_t v11 = vadd_f32(v5, _D0);
  *(float *)&double v12 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v11, 1), *((float *)this + 4), v11.f32[0]);
  LODWORD(v13) = *((_DWORD *)this + 7);
  v14.i32[0] = *((_DWORD *)this + 9);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v11, 1), *(float *)&v13, v11.f32[0]);
  v11.f32[0] = *((float *)this + 6) + *(float *)&v12;
  *(float *)v4.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v11.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)v17.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v11, v4, v12, v13, v15, v14, v16);
  float32x4_t v141 = v17;
  *(float32x2_t *)v17.f32 = vadd_f32(v5, (float32x2_t)0xC0400000BF800000);
  *(float *)&double v18 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v17.f32, 1), *((float *)this + 4), v17.f32[0]);
  LODWORD(v19) = *((_DWORD *)this + 7);
  v20.i32[0] = *((_DWORD *)this + 9);
  *(float *)v21.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v17.f32, 1), *(float *)&v19, v17.f32[0]);
  v17.f32[0] = *((float *)this + 6) + *(float *)&v18;
  *(float *)v22.f64 = *(float *)v20.i32 + *(float *)v21.i32;
  v17.f32[1] = *(float *)v20.i32 + *(float *)v21.i32;
  *(double *)v24.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v17.i64, v22, v18, v19, v21, v20, v23);
  float32x2_t v25 = vadd_f32(v5, (float32x2_t)0xC04000003F800000);
  *(float *)&double v26 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v25, 1), *((float *)this + 4), v25.f32[0]);
  LODWORD(v27) = *((_DWORD *)this + 6);
  v28.i32[0] = *((_DWORD *)this + 7);
  v29.i32[0] = *((_DWORD *)this + 9);
  *(float *)v30.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v25, 1), *(float *)v28.i32, v25.f32[0]);
  float64x2_t v31 = (float64x2_t)v141;
  float32x4_t v142 = vaddq_f32(v141, v24);
  v24.f32[0] = *(float *)&v27 + *(float *)&v26;
  *(float *)v31.f64 = *(float *)v29.i32 + *(float *)v30.i32;
  v24.f32[1] = *(float *)v29.i32 + *(float *)v30.i32;
  *(double *)v32.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v24.i64, v31, v27, v26, v28, v30, v29);
  float32x2_t v33 = vadd_f32(v5, (float32x2_t)0xC040000040400000);
  *(float *)&double v34 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v33, 1), *((float *)this + 4), v33.f32[0]);
  LODWORD(v35) = *((_DWORD *)this + 6);
  v36.i32[0] = *((_DWORD *)this + 7);
  v37.i32[0] = *((_DWORD *)this + 9);
  *(float *)v38.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v33, 1), *(float *)v36.i32, v33.f32[0]);
  float64x2_t v39 = (float64x2_t)v142;
  float32x4_t v143 = vaddq_f32(v142, v32);
  v32.f32[0] = *(float *)&v35 + *(float *)&v34;
  *(float *)v39.f64 = *(float *)v37.i32 + *(float *)v38.i32;
  v32.f32[1] = *(float *)v37.i32 + *(float *)v38.i32;
  *(double *)v40.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v32.i64, v39, v35, v34, v36, v38, v37);
  float32x2_t v41 = vadd_f32(v5, (float32x2_t)0xBF800000C0400000);
  *(float *)&double v42 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v41, 1), *((float *)this + 4), v41.f32[0]);
  LODWORD(v43) = *((_DWORD *)this + 6);
  v44.i32[0] = *((_DWORD *)this + 7);
  v45.i32[0] = *((_DWORD *)this + 9);
  *(float *)v46.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v41, 1), *(float *)v44.i32, v41.f32[0]);
  float64x2_t v47 = (float64x2_t)v143;
  float32x4_t v144 = vaddq_f32(v143, v40);
  v40.f32[0] = *(float *)&v43 + *(float *)&v42;
  *(float *)v47.f64 = *(float *)v45.i32 + *(float *)v46.i32;
  v40.f32[1] = *(float *)v45.i32 + *(float *)v46.i32;
  *(double *)v48.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v40.i64, v47, v43, v42, v44, v46, v45);
  __asm { FMOV            V1.2S, #-1.0 }
  float32x2_t v50 = vadd_f32(v5, _D1);
  *(float *)&double v51 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v50, 1), *((float *)this + 4), v50.f32[0]);
  LODWORD(v52) = *((_DWORD *)this + 6);
  v53.i32[0] = *((_DWORD *)this + 7);
  v54.i32[0] = *((_DWORD *)this + 9);
  *(float *)v55.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v50, 1), *(float *)v53.i32, v50.f32[0]);
  float64x2_t v56 = (float64x2_t)v144;
  float32x4_t v145 = vaddq_f32(v144, v48);
  v48.f32[0] = *(float *)&v52 + *(float *)&v51;
  *(float *)v56.f64 = *(float *)v54.i32 + *(float *)v55.i32;
  v48.f32[1] = *(float *)v54.i32 + *(float *)v55.i32;
  *(double *)v57.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v48.i64, v56, v52, v51, v53, v55, v54);
  float32x2_t v58 = vadd_f32(v5, (float32x2_t)0xBF8000003F800000);
  *(float *)&double v59 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v58, 1), *((float *)this + 4), v58.f32[0]);
  LODWORD(v60) = *((_DWORD *)this + 6);
  v61.i32[0] = *((_DWORD *)this + 7);
  v62.i32[0] = *((_DWORD *)this + 9);
  *(float *)v63.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v58, 1), *(float *)v61.i32, v58.f32[0]);
  float64x2_t v64 = (float64x2_t)v145;
  float32x4_t v146 = vaddq_f32(v145, v57);
  v57.f32[0] = *(float *)&v60 + *(float *)&v59;
  *(float *)v64.f64 = *(float *)v62.i32 + *(float *)v63.i32;
  v57.f32[1] = *(float *)v62.i32 + *(float *)v63.i32;
  *(double *)v65.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v57.i64, v64, v60, v59, v61, v63, v62);
  float32x2_t v66 = vadd_f32(v5, (float32x2_t)0xBF80000040400000);
  *(float *)&double v67 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v66, 1), *((float *)this + 4), v66.f32[0]);
  LODWORD(v68) = *((_DWORD *)this + 6);
  v69.i32[0] = *((_DWORD *)this + 7);
  v70.i32[0] = *((_DWORD *)this + 9);
  *(float *)v71.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v66, 1), *(float *)v69.i32, v66.f32[0]);
  float64x2_t v72 = (float64x2_t)v146;
  float32x4_t v147 = vaddq_f32(v146, v65);
  v65.f32[0] = *(float *)&v68 + *(float *)&v67;
  *(float *)v72.f64 = *(float *)v70.i32 + *(float *)v71.i32;
  v65.f32[1] = *(float *)v70.i32 + *(float *)v71.i32;
  *(double *)v73.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v65.i64, v72, v68, v67, v69, v71, v70);
  float32x2_t v74 = vadd_f32(v5, (float32x2_t)0x3F800000C0400000);
  *(float *)&double v75 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v74, 1), *((float *)this + 4), v74.f32[0]);
  LODWORD(v76) = *((_DWORD *)this + 6);
  v77.i32[0] = *((_DWORD *)this + 7);
  v78.i32[0] = *((_DWORD *)this + 9);
  *(float *)v79.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v74, 1), *(float *)v77.i32, v74.f32[0]);
  float64x2_t v80 = (float64x2_t)v147;
  float32x4_t v148 = vaddq_f32(v147, v73);
  v73.f32[0] = *(float *)&v76 + *(float *)&v75;
  *(float *)v80.f64 = *(float *)v78.i32 + *(float *)v79.i32;
  v73.f32[1] = *(float *)v78.i32 + *(float *)v79.i32;
  *(double *)v81.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v73.i64, v80, v76, v75, v77, v79, v78);
  float32x2_t v82 = vadd_f32(v5, (float32x2_t)0x3F800000BF800000);
  *(float *)&double v83 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v82, 1), *((float *)this + 4), v82.f32[0]);
  LODWORD(v84) = *((_DWORD *)this + 6);
  v85.i32[0] = *((_DWORD *)this + 7);
  v86.i32[0] = *((_DWORD *)this + 9);
  *(float *)v87.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v82, 1), *(float *)v85.i32, v82.f32[0]);
  float64x2_t v88 = (float64x2_t)v148;
  float32x4_t v149 = vaddq_f32(v148, v81);
  v81.f32[0] = *(float *)&v84 + *(float *)&v83;
  *(float *)v88.f64 = *(float *)v86.i32 + *(float *)v87.i32;
  v81.f32[1] = *(float *)v86.i32 + *(float *)v87.i32;
  *(double *)v89.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v81.i64, v88, v84, v83, v85, v87, v86);
  __asm { FMOV            V1.2S, #1.0 }
  float32x2_t v91 = vadd_f32(v5, _D1);
  *(float *)&double v92 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v91, 1), *((float *)this + 4), v91.f32[0]);
  LODWORD(v93) = *((_DWORD *)this + 6);
  v94.i32[0] = *((_DWORD *)this + 7);
  v95.i32[0] = *((_DWORD *)this + 9);
  *(float *)v96.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v91, 1), *(float *)v94.i32, v91.f32[0]);
  float64x2_t v97 = (float64x2_t)v149;
  float32x4_t v150 = vaddq_f32(v149, v89);
  v89.f32[0] = *(float *)&v93 + *(float *)&v92;
  *(float *)v97.f64 = *(float *)v95.i32 + *(float *)v96.i32;
  v89.f32[1] = *(float *)v95.i32 + *(float *)v96.i32;
  *(double *)v98.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v89.i64, v97, v93, v92, v94, v96, v95);
  float32x2_t v99 = vadd_f32(v5, (float32x2_t)0x3F80000040400000);
  *(float *)&double v100 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v99, 1), *((float *)this + 4), v99.f32[0]);
  LODWORD(v101) = *((_DWORD *)this + 6);
  v102.i32[0] = *((_DWORD *)this + 7);
  v103.i32[0] = *((_DWORD *)this + 9);
  *(float *)v104.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v99, 1), *(float *)v102.i32, v99.f32[0]);
  float64x2_t v105 = (float64x2_t)v150;
  float32x4_t v151 = vaddq_f32(v150, v98);
  v98.f32[0] = *(float *)&v101 + *(float *)&v100;
  *(float *)v105.f64 = *(float *)v103.i32 + *(float *)v104.i32;
  v98.f32[1] = *(float *)v103.i32 + *(float *)v104.i32;
  *(double *)v106.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v98.i64, v105, v101, v100, v102, v104, v103);
  float32x2_t v107 = vadd_f32(v5, (float32x2_t)0x40400000C0400000);
  *(float *)&double v108 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v107, 1), *((float *)this + 4), v107.f32[0]);
  LODWORD(v109) = *((_DWORD *)this + 6);
  v110.i32[0] = *((_DWORD *)this + 7);
  v111.i32[0] = *((_DWORD *)this + 9);
  *(float *)v112.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v107, 1), *(float *)v110.i32, v107.f32[0]);
  float64x2_t v113 = (float64x2_t)v151;
  float32x4_t v152 = vaddq_f32(v151, v106);
  v106.f32[0] = *(float *)&v109 + *(float *)&v108;
  *(float *)v113.f64 = *(float *)v111.i32 + *(float *)v112.i32;
  v106.f32[1] = *(float *)v111.i32 + *(float *)v112.i32;
  *(double *)v114.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v106.i64, v113, v109, v108, v110, v112, v111);
  float32x2_t v115 = vadd_f32(v5, (float32x2_t)0x40400000BF800000);
  *(float *)&double v116 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v115, 1), *((float *)this + 4), v115.f32[0]);
  LODWORD(v117) = *((_DWORD *)this + 6);
  v118.i32[0] = *((_DWORD *)this + 7);
  v119.i32[0] = *((_DWORD *)this + 9);
  *(float *)v120.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v115, 1), *(float *)v118.i32, v115.f32[0]);
  float64x2_t v121 = (float64x2_t)v152;
  float32x4_t v153 = vaddq_f32(v152, v114);
  v114.f32[0] = *(float *)&v117 + *(float *)&v116;
  *(float *)v121.f64 = *(float *)v119.i32 + *(float *)v120.i32;
  v114.f32[1] = *(float *)v119.i32 + *(float *)v120.i32;
  *(double *)v122.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v114.i64, v121, v117, v116, v118, v120, v119);
  float32x2_t v123 = vadd_f32(v5, (float32x2_t)0x404000003F800000);
  *(float *)&double v124 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v123, 1), *((float *)this + 4), v123.f32[0]);
  LODWORD(v125) = *((_DWORD *)this + 6);
  v126.i32[0] = *((_DWORD *)this + 7);
  v127.i32[0] = *((_DWORD *)this + 9);
  *(float *)v128.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v123, 1), *(float *)v126.i32, v123.f32[0]);
  float64x2_t v129 = (float64x2_t)v153;
  float32x4_t v154 = vaddq_f32(v153, v122);
  v122.f32[0] = *(float *)&v125 + *(float *)&v124;
  *(float *)v129.f64 = *(float *)v127.i32 + *(float *)v128.i32;
  v122.f32[1] = *(float *)v127.i32 + *(float *)v128.i32;
  *(double *)v130.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v122.i64, v129, v125, v124, v126, v128, v127);
  __asm { FMOV            V1.2S, #3.0 }
  float32x2_t v132 = vadd_f32(v5, _D1);
  *(float *)&double v133 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v132, 1), *((float *)this + 4), v132.f32[0]);
  LODWORD(v134) = *((_DWORD *)this + 6);
  v135.i32[0] = *((_DWORD *)this + 7);
  v136.i32[0] = *((_DWORD *)this + 9);
  *(float *)v137.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v132, 1), *(float *)v135.i32, v132.f32[0]);
  float64x2_t v138 = (float64x2_t)v154;
  float32x4_t v155 = vaddq_f32(v154, v130);
  v130.f32[0] = *(float *)&v134 + *(float *)&v133;
  *(float *)v138.f64 = *(float *)v136.i32 + *(float *)v137.i32;
  v130.f32[1] = *(float *)v136.i32 + *(float *)v137.i32;
  *(double *)v139.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v130.i64, v138, v134, v133, v135, v137, v136);
  *(void *)&double result = vmulq_f32(vaddq_f32(v155, v139), (float32x4_t)vdupq_n_s32(0x3D800000u)).u64[0];
  return result;
}

double cikernel::_areaAvg4(cikernel *this, SamplerObj *a2)
{
  DC = (float32x2_t *)CI::getDC(this);
  __asm { FMOV            V1.2S, #4.0 }
  float32x2_t v9 = vmul_f32(*DC, *(float32x2_t *)&_Q1.f64[0]);
  __asm { FMOV            V0.2S, #-1.0 }
  float32x2_t v11 = vadd_f32(v9, _D0);
  *(float *)&double v12 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v11, 1), *((float *)this + 4), v11.f32[0]);
  LODWORD(v13) = *((_DWORD *)this + 7);
  v14.i32[0] = *((_DWORD *)this + 9);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v11, 1), *(float *)&v13, v11.f32[0]);
  v11.f32[0] = *((float *)this + 6) + *(float *)&v12;
  *(float *)_Q1.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v11.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)v17.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v11, _Q1, v12, v13, v15, v14, v16);
  float32x4_t v44 = v17;
  *(float32x2_t *)v17.f32 = vadd_f32(v9, (float32x2_t)0xBF8000003F800000);
  *(float *)&double v18 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v17.f32, 1), *((float *)this + 4), v17.f32[0]);
  LODWORD(v19) = *((_DWORD *)this + 7);
  v20.i32[0] = *((_DWORD *)this + 9);
  *(float *)v21.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v17.f32, 1), *(float *)&v19, v17.f32[0]);
  v17.f32[0] = *((float *)this + 6) + *(float *)&v18;
  *(float *)v22.f64 = *(float *)v20.i32 + *(float *)v21.i32;
  v17.f32[1] = *(float *)v20.i32 + *(float *)v21.i32;
  *(double *)v24.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v17.i64, v22, v18, v19, v21, v20, v23);
  float32x2_t v25 = vadd_f32(v9, (float32x2_t)0x3F800000BF800000);
  *(float *)&double v26 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v25, 1), *((float *)this + 4), v25.f32[0]);
  LODWORD(v27) = *((_DWORD *)this + 6);
  v28.i32[0] = *((_DWORD *)this + 7);
  v29.i32[0] = *((_DWORD *)this + 9);
  *(float *)v30.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v25, 1), *(float *)v28.i32, v25.f32[0]);
  float64x2_t v31 = (float64x2_t)v44;
  float32x4_t v45 = vaddq_f32(v44, v24);
  v24.f32[0] = *(float *)&v27 + *(float *)&v26;
  *(float *)v31.f64 = *(float *)v29.i32 + *(float *)v30.i32;
  v24.f32[1] = *(float *)v29.i32 + *(float *)v30.i32;
  *(double *)v32.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v24.i64, v31, v27, v26, v28, v30, v29);
  __asm { FMOV            V1.2S, #1.0 }
  float32x2_t v34 = vadd_f32(v9, _D1);
  *(float *)&double v35 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v34, 1), *((float *)this + 4), v34.f32[0]);
  LODWORD(v36) = *((_DWORD *)this + 6);
  v37.i32[0] = *((_DWORD *)this + 7);
  v38.i32[0] = *((_DWORD *)this + 9);
  *(float *)v39.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v34, 1), *(float *)v37.i32, v34.f32[0]);
  float64x2_t v40 = (float64x2_t)v45;
  float32x4_t v46 = vaddq_f32(v45, v32);
  v32.f32[0] = *(float *)&v36 + *(float *)&v35;
  *(float *)v40.f64 = *(float *)v38.i32 + *(float *)v39.i32;
  v32.f32[1] = *(float *)v38.i32 + *(float *)v39.i32;
  *(double *)v41.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v32.i64, v40, v36, v35, v37, v39, v38);
  __asm { FMOV            V1.4S, #0.25 }
  *(void *)&double result = vmulq_f32(vaddq_f32(v46, v41), _Q1).u64[0];
  return result;
}

double cikernel::_areaAvg2(cikernel *this, SamplerObj *a2)
{
  DC = (float32x2_t *)CI::getDC(this);
  float32x2_t v10 = vadd_f32(*DC, *DC);
  *(float *)&double v6 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v10, 1), *((float *)this + 4), v10.f32[0]);
  LODWORD(v7) = *((_DWORD *)this + 7);
  v8.i32[0] = *((_DWORD *)this + 9);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v10, 1), *(float *)&v7, v10.f32[0]);
  v10.f32[0] = *((float *)this + 6) + *(float *)&v6;
  float32x2_t v11 = (uint64x2_t *)*((void *)this + 1);

  v10.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(float *)v4.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  return CI::BitmapSampler::read(v11, *(double *)&v10, v4, v6, v7, v9, v8, v5);
}

double cikernel::_vertAvg16(cikernel *this, SamplerObj *a2)
{
  DC = (float32x2_t *)CI::getDC(this);
  HIDWORD(v4.f64[0]) = 1098907648;
  float32x2_t v5 = vmul_f32(*DC, (float32x2_t)0x418000003F800000);
  float32x2_t v6 = vadd_f32(v5, (float32x2_t)0xC0E0000000000000);
  *(float *)&double v7 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v6, 1), *((float *)this + 4), v6.f32[0]);
  LODWORD(v8) = *((_DWORD *)this + 7);
  v9.i32[0] = *((_DWORD *)this + 9);
  *(float *)v10.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v6, 1), *(float *)&v8, v6.f32[0]);
  v6.f32[0] = *((float *)this + 6) + *(float *)&v7;
  *(float *)v4.f64 = *(float *)v9.i32 + *(float *)v10.i32;
  v6.f32[1] = *(float *)v9.i32 + *(float *)v10.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v6, v4, v7, v8, v10, v9, v11);
  float32x4_t v70 = v12;
  *(float32x2_t *)v12.f32 = vadd_f32(v5, (float32x2_t)0xC0A0000000000000);
  *(float *)&double v13 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v12.f32, 1), *((float *)this + 4), v12.f32[0]);
  LODWORD(v14) = *((_DWORD *)this + 7);
  v15.i32[0] = *((_DWORD *)this + 9);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v12.f32, 1), *(float *)&v14, v12.f32[0]);
  v12.f32[0] = *((float *)this + 6) + *(float *)&v13;
  *(float *)v17.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v12.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v12.i64, v17, v13, v14, v16, v15, v18);
  float32x2_t v20 = vadd_f32(v5, (float32x2_t)0xC040000000000000);
  *(float *)&double v21 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v20, 1), *((float *)this + 4), v20.f32[0]);
  LODWORD(v22) = *((_DWORD *)this + 6);
  v23.i32[0] = *((_DWORD *)this + 7);
  v24.i32[0] = *((_DWORD *)this + 9);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v20, 1), *(float *)v23.i32, v20.f32[0]);
  float64x2_t v26 = (float64x2_t)v70;
  float32x4_t v71 = vaddq_f32(v70, v19);
  v19.f32[0] = *(float *)&v22 + *(float *)&v21;
  *(float *)v26.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  v19.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
  *(double *)v27.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v19.i64, v26, v22, v21, v23, v25, v24);
  float32x2_t v28 = vadd_f32(v5, (float32x2_t)0xBF80000000000000);
  *(float *)&double v29 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v28, 1), *((float *)this + 4), v28.f32[0]);
  LODWORD(v30) = *((_DWORD *)this + 6);
  v31.i32[0] = *((_DWORD *)this + 7);
  v32.i32[0] = *((_DWORD *)this + 9);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v28, 1), *(float *)v31.i32, v28.f32[0]);
  float64x2_t v34 = (float64x2_t)v71;
  float32x4_t v72 = vaddq_f32(v71, v27);
  v27.f32[0] = *(float *)&v30 + *(float *)&v29;
  *(float *)v34.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v27.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)v35.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v27.i64, v34, v30, v29, v31, v33, v32);
  float32x2_t v36 = vadd_f32(v5, (float32x2_t)0x3F80000000000000);
  *(float *)&double v37 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v36, 1), *((float *)this + 4), v36.f32[0]);
  LODWORD(v38) = *((_DWORD *)this + 6);
  v39.i32[0] = *((_DWORD *)this + 7);
  v40.i32[0] = *((_DWORD *)this + 9);
  *(float *)v41.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v36, 1), *(float *)v39.i32, v36.f32[0]);
  float64x2_t v42 = (float64x2_t)v72;
  float32x4_t v73 = vaddq_f32(v72, v35);
  v35.f32[0] = *(float *)&v38 + *(float *)&v37;
  *(float *)v42.f64 = *(float *)v40.i32 + *(float *)v41.i32;
  v35.f32[1] = *(float *)v40.i32 + *(float *)v41.i32;
  *(double *)v43.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v35.i64, v42, v38, v37, v39, v41, v40);
  float32x2_t v44 = vadd_f32(v5, (float32x2_t)0x4040000000000000);
  *(float *)&double v45 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v44, 1), *((float *)this + 4), v44.f32[0]);
  LODWORD(v46) = *((_DWORD *)this + 6);
  v47.i32[0] = *((_DWORD *)this + 7);
  v48.i32[0] = *((_DWORD *)this + 9);
  *(float *)v49.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v44, 1), *(float *)v47.i32, v44.f32[0]);
  float64x2_t v50 = (float64x2_t)v73;
  float32x4_t v74 = vaddq_f32(v73, v43);
  v43.f32[0] = *(float *)&v46 + *(float *)&v45;
  *(float *)v50.f64 = *(float *)v48.i32 + *(float *)v49.i32;
  v43.f32[1] = *(float *)v48.i32 + *(float *)v49.i32;
  *(double *)v51.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v43.i64, v50, v46, v45, v47, v49, v48);
  float32x2_t v52 = vadd_f32(v5, (float32x2_t)0x40A0000000000000);
  *(float *)&double v53 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v52, 1), *((float *)this + 4), v52.f32[0]);
  LODWORD(v54) = *((_DWORD *)this + 6);
  v55.i32[0] = *((_DWORD *)this + 7);
  v56.i32[0] = *((_DWORD *)this + 9);
  *(float *)v57.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v52, 1), *(float *)v55.i32, v52.f32[0]);
  float64x2_t v58 = (float64x2_t)v74;
  float32x4_t v75 = vaddq_f32(v74, v51);
  v51.f32[0] = *(float *)&v54 + *(float *)&v53;
  *(float *)v58.f64 = *(float *)v56.i32 + *(float *)v57.i32;
  v51.f32[1] = *(float *)v56.i32 + *(float *)v57.i32;
  *(double *)v59.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v51.i64, v58, v54, v53, v55, v57, v56);
  float32x2_t v60 = vadd_f32(v5, (float32x2_t)0x40E0000000000000);
  *(float *)&double v61 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v60, 1), *((float *)this + 4), v60.f32[0]);
  LODWORD(v62) = *((_DWORD *)this + 6);
  v63.i32[0] = *((_DWORD *)this + 7);
  v64.i32[0] = *((_DWORD *)this + 9);
  *(float *)v65.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v60, 1), *(float *)v63.i32, v60.f32[0]);
  float64x2_t v66 = (float64x2_t)v75;
  float32x4_t v76 = vaddq_f32(v75, v59);
  v59.f32[0] = *(float *)&v62 + *(float *)&v61;
  *(float *)v66.f64 = *(float *)v64.i32 + *(float *)v65.i32;
  v59.f32[1] = *(float *)v64.i32 + *(float *)v65.i32;
  *(double *)v67.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v59.i64, v66, v62, v61, v63, v65, v64);
  v68.i64[0] = 0x3E0000003E000000;
  v68.i64[1] = 0x3E0000003E000000;
  *(void *)&double result = vmulq_f32(vaddq_f32(v76, v67), v68).u64[0];
  return result;
}

double cikernel::_vertAvg8(cikernel *this, SamplerObj *a2)
{
  DC = (float32x2_t *)CI::getDC(this);
  HIDWORD(v4.f64[0]) = 1090519040;
  float32x2_t v5 = vmul_f32(*DC, (float32x2_t)0x410000003F800000);
  float32x2_t v6 = vadd_f32(v5, (float32x2_t)0xC040000000000000);
  *(float *)&double v7 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v6, 1), *((float *)this + 4), v6.f32[0]);
  LODWORD(v8) = *((_DWORD *)this + 7);
  v9.i32[0] = *((_DWORD *)this + 9);
  *(float *)v10.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v6, 1), *(float *)&v8, v6.f32[0]);
  v6.f32[0] = *((float *)this + 6) + *(float *)&v7;
  *(float *)v4.f64 = *(float *)v9.i32 + *(float *)v10.i32;
  v6.f32[1] = *(float *)v9.i32 + *(float *)v10.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v6, v4, v7, v8, v10, v9, v11);
  float32x4_t v42 = v12;
  *(float32x2_t *)v12.f32 = vadd_f32(v5, (float32x2_t)0xBF80000000000000);
  *(float *)&double v13 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v12.f32, 1), *((float *)this + 4), v12.f32[0]);
  LODWORD(v14) = *((_DWORD *)this + 7);
  v15.i32[0] = *((_DWORD *)this + 9);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v12.f32, 1), *(float *)&v14, v12.f32[0]);
  v12.f32[0] = *((float *)this + 6) + *(float *)&v13;
  *(float *)v17.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v12.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v12.i64, v17, v13, v14, v16, v15, v18);
  float32x2_t v20 = vadd_f32(v5, (float32x2_t)0x3F80000000000000);
  *(float *)&double v21 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v20, 1), *((float *)this + 4), v20.f32[0]);
  LODWORD(v22) = *((_DWORD *)this + 6);
  v23.i32[0] = *((_DWORD *)this + 7);
  v24.i32[0] = *((_DWORD *)this + 9);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v20, 1), *(float *)v23.i32, v20.f32[0]);
  float64x2_t v26 = (float64x2_t)v42;
  float32x4_t v43 = vaddq_f32(v42, v19);
  v19.f32[0] = *(float *)&v22 + *(float *)&v21;
  *(float *)v26.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  v19.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
  *(double *)v27.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v19.i64, v26, v22, v21, v23, v25, v24);
  float32x2_t v28 = vadd_f32(v5, (float32x2_t)0x4040000000000000);
  *(float *)&double v29 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v28, 1), *((float *)this + 4), v28.f32[0]);
  LODWORD(v30) = *((_DWORD *)this + 6);
  v31.i32[0] = *((_DWORD *)this + 7);
  v32.i32[0] = *((_DWORD *)this + 9);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v28, 1), *(float *)v31.i32, v28.f32[0]);
  float64x2_t v34 = (float64x2_t)v43;
  float32x4_t v44 = vaddq_f32(v43, v27);
  v27.f32[0] = *(float *)&v30 + *(float *)&v29;
  *(float *)v34.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v27.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)v35.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v27.i64, v34, v30, v29, v31, v33, v32);
  __asm { FMOV            V1.4S, #0.25 }
  *(void *)&double result = vmulq_f32(vaddq_f32(v44, v35), _Q1).u64[0];
  return result;
}

double cikernel::_vertAvg4(cikernel *this, SamplerObj *a2)
{
  DC = (float32x2_t *)CI::getDC(this);
  HIDWORD(v4.f64[0]) = 1082130432;
  float32x2_t v5 = vmul_f32(*DC, (float32x2_t)0x408000003F800000);
  float32x2_t v6 = vadd_f32(v5, (float32x2_t)0xBF80000000000000);
  *(float *)&double v7 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v6, 1), *((float *)this + 4), v6.f32[0]);
  LODWORD(v8) = *((_DWORD *)this + 7);
  v9.i32[0] = *((_DWORD *)this + 9);
  *(float *)v10.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v6, 1), *(float *)&v8, v6.f32[0]);
  v6.f32[0] = *((float *)this + 6) + *(float *)&v7;
  *(float *)v4.f64 = *(float *)v9.i32 + *(float *)v10.i32;
  v6.f32[1] = *(float *)v9.i32 + *(float *)v10.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v6, v4, v7, v8, v10, v9, v11);
  float32x4_t v22 = v12;
  *(float32x2_t *)v12.f32 = vadd_f32(v5, (float32x2_t)0x3F80000000000000);
  *(float *)&double v13 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v12.f32, 1), *((float *)this + 4), v12.f32[0]);
  LODWORD(v14) = *((_DWORD *)this + 7);
  v15.i32[0] = *((_DWORD *)this + 9);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v12.f32, 1), *(float *)&v14, v12.f32[0]);
  v12.f32[0] = *((float *)this + 6) + *(float *)&v13;
  *(float *)v17.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v12.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v12.i64, v17, v13, v14, v16, v15, v18);
  v20.i64[0] = 0x3F0000003F000000;
  v20.i64[1] = 0x3F0000003F000000;
  *(void *)&double result = vmulq_f32(vaddq_f32(v22, v19), v20).u64[0];
  return result;
}

double cikernel::_vertAvg2(cikernel *this, SamplerObj *a2)
{
  DC = (float32x2_t *)CI::getDC(this);
  HIDWORD(v5.f64[0]) = 0x40000000;
  float32x2_t v10 = vmul_f32(*DC, (float32x2_t)0x400000003F800000);
  *(float *)&double v6 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v10, 1), *((float *)this + 4), v10.f32[0]);
  LODWORD(v7) = *((_DWORD *)this + 7);
  v8.i32[0] = *((_DWORD *)this + 9);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v10, 1), *(float *)&v7, v10.f32[0]);
  v10.f32[0] = *((float *)this + 6) + *(float *)&v6;
  int8x16_t v11 = (uint64x2_t *)*((void *)this + 1);

  v10.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(float *)v5.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  return CI::BitmapSampler::read(v11, *(double *)&v10, v5, v6, v7, v9, v8, v4);
}

double cikernel::_horizAvg16(cikernel *this, SamplerObj *a2)
{
  DC = (float32x2_t *)CI::getDC(this);
  HIDWORD(v4.f64[0]) = 1065353216;
  float32x2_t v5 = vmul_f32(*DC, (float32x2_t)0x3F80000041800000);
  float32x2_t v6 = vadd_f32(v5, (float32x2_t)3235905536);
  *(float *)&double v7 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v6, 1), *((float *)this + 4), v6.f32[0]);
  LODWORD(v8) = *((_DWORD *)this + 7);
  v9.i32[0] = *((_DWORD *)this + 9);
  *(float *)v10.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v6, 1), *(float *)&v8, v6.f32[0]);
  v6.f32[0] = *((float *)this + 6) + *(float *)&v7;
  *(float *)v4.f64 = *(float *)v9.i32 + *(float *)v10.i32;
  v6.f32[1] = *(float *)v9.i32 + *(float *)v10.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v6, v4, v7, v8, v10, v9, v11);
  float32x4_t v70 = v12;
  *(float32x2_t *)v12.f32 = vadd_f32(v5, (float32x2_t)3231711232);
  *(float *)&double v13 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v12.f32, 1), *((float *)this + 4), v12.f32[0]);
  LODWORD(v14) = *((_DWORD *)this + 7);
  v15.i32[0] = *((_DWORD *)this + 9);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v12.f32, 1), *(float *)&v14, v12.f32[0]);
  v12.f32[0] = *((float *)this + 6) + *(float *)&v13;
  *(float *)v17.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v12.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v12.i64, v17, v13, v14, v16, v15, v18);
  float32x2_t v20 = vadd_f32(v5, (float32x2_t)3225419776);
  *(float *)&double v21 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v20, 1), *((float *)this + 4), v20.f32[0]);
  LODWORD(v22) = *((_DWORD *)this + 6);
  v23.i32[0] = *((_DWORD *)this + 7);
  v24.i32[0] = *((_DWORD *)this + 9);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v20, 1), *(float *)v23.i32, v20.f32[0]);
  float64x2_t v26 = (float64x2_t)v70;
  float32x4_t v71 = vaddq_f32(v70, v19);
  v19.f32[0] = *(float *)&v22 + *(float *)&v21;
  *(float *)v26.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  v19.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
  *(double *)v27.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v19.i64, v26, v22, v21, v23, v25, v24);
  float32x2_t v28 = vadd_f32(v5, (float32x2_t)3212836864);
  *(float *)&double v29 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v28, 1), *((float *)this + 4), v28.f32[0]);
  LODWORD(v30) = *((_DWORD *)this + 6);
  v31.i32[0] = *((_DWORD *)this + 7);
  v32.i32[0] = *((_DWORD *)this + 9);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v28, 1), *(float *)v31.i32, v28.f32[0]);
  float64x2_t v34 = (float64x2_t)v71;
  float32x4_t v72 = vaddq_f32(v71, v27);
  v27.f32[0] = *(float *)&v30 + *(float *)&v29;
  *(float *)v34.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v27.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)v35.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v27.i64, v34, v30, v29, v31, v33, v32);
  float32x2_t v36 = vadd_f32(v5, (float32x2_t)1065353216);
  *(float *)&double v37 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v36, 1), *((float *)this + 4), v36.f32[0]);
  LODWORD(v38) = *((_DWORD *)this + 6);
  v39.i32[0] = *((_DWORD *)this + 7);
  v40.i32[0] = *((_DWORD *)this + 9);
  *(float *)v41.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v36, 1), *(float *)v39.i32, v36.f32[0]);
  float64x2_t v42 = (float64x2_t)v72;
  float32x4_t v73 = vaddq_f32(v72, v35);
  v35.f32[0] = *(float *)&v38 + *(float *)&v37;
  *(float *)v42.f64 = *(float *)v40.i32 + *(float *)v41.i32;
  v35.f32[1] = *(float *)v40.i32 + *(float *)v41.i32;
  *(double *)v43.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v35.i64, v42, v38, v37, v39, v41, v40);
  float32x2_t v44 = vadd_f32(v5, (float32x2_t)1077936128);
  *(float *)&double v45 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v44, 1), *((float *)this + 4), v44.f32[0]);
  LODWORD(v46) = *((_DWORD *)this + 6);
  v47.i32[0] = *((_DWORD *)this + 7);
  v48.i32[0] = *((_DWORD *)this + 9);
  *(float *)v49.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v44, 1), *(float *)v47.i32, v44.f32[0]);
  float64x2_t v50 = (float64x2_t)v73;
  float32x4_t v74 = vaddq_f32(v73, v43);
  v43.f32[0] = *(float *)&v46 + *(float *)&v45;
  *(float *)v50.f64 = *(float *)v48.i32 + *(float *)v49.i32;
  v43.f32[1] = *(float *)v48.i32 + *(float *)v49.i32;
  *(double *)v51.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v43.i64, v50, v46, v45, v47, v49, v48);
  float32x2_t v52 = vadd_f32(v5, (float32x2_t)1084227584);
  *(float *)&double v53 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v52, 1), *((float *)this + 4), v52.f32[0]);
  LODWORD(v54) = *((_DWORD *)this + 6);
  v55.i32[0] = *((_DWORD *)this + 7);
  v56.i32[0] = *((_DWORD *)this + 9);
  *(float *)v57.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v52, 1), *(float *)v55.i32, v52.f32[0]);
  float64x2_t v58 = (float64x2_t)v74;
  float32x4_t v75 = vaddq_f32(v74, v51);
  v51.f32[0] = *(float *)&v54 + *(float *)&v53;
  *(float *)v58.f64 = *(float *)v56.i32 + *(float *)v57.i32;
  v51.f32[1] = *(float *)v56.i32 + *(float *)v57.i32;
  *(double *)v59.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v51.i64, v58, v54, v53, v55, v57, v56);
  float32x2_t v60 = vadd_f32(v5, (float32x2_t)1088421888);
  *(float *)&double v61 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v60, 1), *((float *)this + 4), v60.f32[0]);
  LODWORD(v62) = *((_DWORD *)this + 6);
  v63.i32[0] = *((_DWORD *)this + 7);
  v64.i32[0] = *((_DWORD *)this + 9);
  *(float *)v65.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v60, 1), *(float *)v63.i32, v60.f32[0]);
  float64x2_t v66 = (float64x2_t)v75;
  float32x4_t v76 = vaddq_f32(v75, v59);
  v59.f32[0] = *(float *)&v62 + *(float *)&v61;
  *(float *)v66.f64 = *(float *)v64.i32 + *(float *)v65.i32;
  v59.f32[1] = *(float *)v64.i32 + *(float *)v65.i32;
  *(double *)v67.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v59.i64, v66, v62, v61, v63, v65, v64);
  v68.i64[0] = 0x3E0000003E000000;
  v68.i64[1] = 0x3E0000003E000000;
  *(void *)&double result = vmulq_f32(vaddq_f32(v76, v67), v68).u64[0];
  return result;
}

double cikernel::_horizAvg8(cikernel *this, SamplerObj *a2)
{
  DC = (float32x2_t *)CI::getDC(this);
  HIDWORD(v4.f64[0]) = 1065353216;
  float32x2_t v5 = vmul_f32(*DC, (float32x2_t)0x3F80000041000000);
  float32x2_t v6 = vadd_f32(v5, (float32x2_t)3225419776);
  *(float *)&double v7 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v6, 1), *((float *)this + 4), v6.f32[0]);
  LODWORD(v8) = *((_DWORD *)this + 7);
  v9.i32[0] = *((_DWORD *)this + 9);
  *(float *)v10.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v6, 1), *(float *)&v8, v6.f32[0]);
  v6.f32[0] = *((float *)this + 6) + *(float *)&v7;
  *(float *)v4.f64 = *(float *)v9.i32 + *(float *)v10.i32;
  v6.f32[1] = *(float *)v9.i32 + *(float *)v10.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v6, v4, v7, v8, v10, v9, v11);
  float32x4_t v42 = v12;
  *(float32x2_t *)v12.f32 = vadd_f32(v5, (float32x2_t)3212836864);
  *(float *)&double v13 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v12.f32, 1), *((float *)this + 4), v12.f32[0]);
  LODWORD(v14) = *((_DWORD *)this + 7);
  v15.i32[0] = *((_DWORD *)this + 9);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v12.f32, 1), *(float *)&v14, v12.f32[0]);
  v12.f32[0] = *((float *)this + 6) + *(float *)&v13;
  *(float *)v17.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v12.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v12.i64, v17, v13, v14, v16, v15, v18);
  float32x2_t v20 = vadd_f32(v5, (float32x2_t)1065353216);
  *(float *)&double v21 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v20, 1), *((float *)this + 4), v20.f32[0]);
  LODWORD(v22) = *((_DWORD *)this + 6);
  v23.i32[0] = *((_DWORD *)this + 7);
  v24.i32[0] = *((_DWORD *)this + 9);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v20, 1), *(float *)v23.i32, v20.f32[0]);
  float64x2_t v26 = (float64x2_t)v42;
  float32x4_t v43 = vaddq_f32(v42, v19);
  v19.f32[0] = *(float *)&v22 + *(float *)&v21;
  *(float *)v26.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  v19.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
  *(double *)v27.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v19.i64, v26, v22, v21, v23, v25, v24);
  float32x2_t v28 = vadd_f32(v5, (float32x2_t)1077936128);
  *(float *)&double v29 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v28, 1), *((float *)this + 4), v28.f32[0]);
  LODWORD(v30) = *((_DWORD *)this + 6);
  v31.i32[0] = *((_DWORD *)this + 7);
  v32.i32[0] = *((_DWORD *)this + 9);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v28, 1), *(float *)v31.i32, v28.f32[0]);
  float64x2_t v34 = (float64x2_t)v43;
  float32x4_t v44 = vaddq_f32(v43, v27);
  v27.f32[0] = *(float *)&v30 + *(float *)&v29;
  *(float *)v34.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v27.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)v35.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v27.i64, v34, v30, v29, v31, v33, v32);
  __asm { FMOV            V1.4S, #0.25 }
  *(void *)&double result = vmulq_f32(vaddq_f32(v44, v35), _Q1).u64[0];
  return result;
}

double cikernel::_horizAvg4(cikernel *this, SamplerObj *a2)
{
  DC = (float32x2_t *)CI::getDC(this);
  HIDWORD(v4.f64[0]) = 1065353216;
  float32x2_t v5 = vmul_f32(*DC, (float32x2_t)0x3F80000040800000);
  float32x2_t v6 = vadd_f32(v5, (float32x2_t)3212836864);
  *(float *)&double v7 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v6, 1), *((float *)this + 4), v6.f32[0]);
  LODWORD(v8) = *((_DWORD *)this + 7);
  v9.i32[0] = *((_DWORD *)this + 9);
  *(float *)v10.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v6, 1), *(float *)&v8, v6.f32[0]);
  v6.f32[0] = *((float *)this + 6) + *(float *)&v7;
  *(float *)v4.f64 = *(float *)v9.i32 + *(float *)v10.i32;
  v6.f32[1] = *(float *)v9.i32 + *(float *)v10.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v6, v4, v7, v8, v10, v9, v11);
  float32x4_t v22 = v12;
  *(float32x2_t *)v12.f32 = vadd_f32(v5, (float32x2_t)1065353216);
  *(float *)&double v13 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v12.f32, 1), *((float *)this + 4), v12.f32[0]);
  LODWORD(v14) = *((_DWORD *)this + 7);
  v15.i32[0] = *((_DWORD *)this + 9);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v12.f32, 1), *(float *)&v14, v12.f32[0]);
  v12.f32[0] = *((float *)this + 6) + *(float *)&v13;
  *(float *)v17.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v12.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v12.i64, v17, v13, v14, v16, v15, v18);
  v20.i64[0] = 0x3F0000003F000000;
  v20.i64[1] = 0x3F0000003F000000;
  *(void *)&double result = vmulq_f32(vaddq_f32(v22, v19), v20).u64[0];
  return result;
}

double cikernel::_horizAvg2(cikernel *this, SamplerObj *a2)
{
  DC = (float32x2_t *)CI::getDC(this);
  HIDWORD(v5.f64[0]) = 1065353216;
  float32x2_t v10 = vmul_f32(*DC, (float32x2_t)0x3F80000040000000);
  *(float *)&double v6 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v10, 1), *((float *)this + 4), v10.f32[0]);
  LODWORD(v7) = *((_DWORD *)this + 7);
  v8.i32[0] = *((_DWORD *)this + 9);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v10, 1), *(float *)&v7, v10.f32[0]);
  v10.f32[0] = *((float *)this + 6) + *(float *)&v6;
  int8x16_t v11 = (uint64x2_t *)*((void *)this + 1);

  v10.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(float *)v5.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  return CI::BitmapSampler::read(v11, *(double *)&v10, v5, v6, v7, v9, v8, v4);
}

double cikernel::_areaMax4(uint64_t a1, double a2)
{
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)&v4.f64[0] = vadd_f32(*DC, *DC);
  float64x2_t v40 = v4;
  float32x2_t v5 = vadd_f32(*(float32x2_t *)&v4.f64[0], (float32x2_t)0xBF000000BF000000);
  *(float *)&double v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v5, 1), *(float *)(a1 + 16), v5.f32[0]);
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *(float *)(a1 + 24) + *(float *)&v6;
  *(float *)v4.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v11.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v5, v4, v6, v7, v9, v8, v10);
  float32x4_t v38 = v11;
  float64x2_t v12 = v40;
  *(float32x2_t *)v11.f32 = vadd_f32(*(float32x2_t *)&v40.f64[0], (float32x2_t)0xBF0000003F000000);
  *(float *)&double v13 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v11.f32, 1), *(float *)(a1 + 16), v11.f32[0]);
  LODWORD(v14) = *(_DWORD *)(a1 + 28);
  v15.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v11.f32, 1), *(float *)&v14, v11.f32[0]);
  v11.f32[0] = *(float *)(a1 + 24) + *(float *)&v13;
  *(float *)v12.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v11.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  *(double *)v18.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v11.i64, v12, v13, v14, v16, v15, v17);
  float32x4_t v36 = v18;
  float64x2_t v19 = v40;
  *(float32x2_t *)v18.f32 = vadd_f32(*(float32x2_t *)&v40.f64[0], (float32x2_t)0x3F000000BF000000);
  *(float *)&double v20 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v18.f32, 1), *(float *)(a1 + 16), v18.f32[0]);
  LODWORD(v21) = *(_DWORD *)(a1 + 28);
  v22.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v23.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v18.f32, 1), *(float *)&v21, v18.f32[0]);
  v18.f32[0] = *(float *)(a1 + 24) + *(float *)&v20;
  *(float *)v19.f64 = *(float *)v22.i32 + *(float *)v23.i32;
  v18.f32[1] = *(float *)v22.i32 + *(float *)v23.i32;
  *(double *)v25.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v18.i64, v19, v20, v21, v23, v22, v24);
  float32x4_t v37 = v25;
  float64x2_t v26 = v40;
  *(float32x2_t *)v25.f32 = vadd_f32(*(float32x2_t *)&v40.f64[0], (float32x2_t)0x3F0000003F000000);
  *(float *)&double v27 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v25.f32, 1), *(float *)(a1 + 16), v25.f32[0]);
  LODWORD(v28) = *(_DWORD *)(a1 + 28);
  v29.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v30.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v25.f32, 1), *(float *)&v28, v25.f32[0]);
  v25.f32[0] = *(float *)(a1 + 24) + *(float *)&v27;
  *(float *)v26.f64 = *(float *)v29.i32 + *(float *)v30.i32;
  v25.f32[1] = *(float *)v29.i32 + *(float *)v30.i32;
  *(double *)v32.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v25.i64, v26, v27, v28, v30, v29, v31);
  if (*(float *)v40.f64 + 0.5 >= *(float *)&a2)
  {
    float32x4_t v33 = v37;
    float32x4_t v34 = v38;
  }
  else
  {
    float32x4_t v33 = vmaxnmq_f32(v37, v32);
    float32x4_t v34 = vmaxnmq_f32(v38, v36);
  }
  if (*((float *)v40.f64 + 1) + 0.5 < *((float *)&a2 + 1)) {
    v34.i64[0] = vmaxnmq_f32(v34, v33).u64[0];
  }
  return *(double *)v34.i64;
}

double cikernel::_horizMax4(cikernel *this, SamplerObj *a2, float a3, float a4)
{
  *(float32x2_t *)&v6.f64[0] = vmul_f32(*(float32x2_t *)CI::getDC(this), (float32x2_t)0x3F80000040800000);
  float64x2_t v42 = v6;
  float32x2_t v7 = vadd_f32(*(float32x2_t *)&v6.f64[0], (float32x2_t)3217031168);
  *(float *)&double v8 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v7, 1), *((float *)this + 4), v7.f32[0]);
  LODWORD(v9) = *((_DWORD *)this + 7);
  v10.i32[0] = *((_DWORD *)this + 9);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v7, 1), *(float *)&v9, v7.f32[0]);
  v7.f32[0] = *((float *)this + 6) + *(float *)&v8;
  *(float *)v6.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  v7.f32[1] = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v7, v6, v8, v9, v11, v10, v12);
  float32x4_t v41 = v13;
  float64x2_t v14 = v42;
  *(float32x2_t *)v13.f32 = vadd_f32(*(float32x2_t *)&v42.f64[0], (float32x2_t)3204448256);
  *(float *)&double v15 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v13.f32, 1), *((float *)this + 4), v13.f32[0]);
  LODWORD(v16) = *((_DWORD *)this + 7);
  v17.i32[0] = *((_DWORD *)this + 9);
  *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v13.f32, 1), *(float *)&v16, v13.f32[0]);
  v13.f32[0] = *((float *)this + 6) + *(float *)&v15;
  *(float *)v14.f64 = *(float *)v17.i32 + *(float *)v18.i32;
  v13.f32[1] = *(float *)v17.i32 + *(float *)v18.i32;
  *(double *)v20.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v13.i64, v14, v15, v16, v18, v17, v19);
  float32x4_t v40 = v20;
  float64x2_t v21 = v42;
  *(float32x2_t *)v20.f32 = vadd_f32(*(float32x2_t *)&v42.f64[0], (float32x2_t)1056964608);
  *(float *)&double v22 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v20.f32, 1), *((float *)this + 4), v20.f32[0]);
  LODWORD(v23) = *((_DWORD *)this + 7);
  v24.i32[0] = *((_DWORD *)this + 9);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v20.f32, 1), *(float *)&v23, v20.f32[0]);
  v20.f32[0] = *((float *)this + 6) + *(float *)&v22;
  *(float *)v21.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  v20.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
  *(double *)v27.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v20.i64, v21, v22, v23, v25, v24, v26);
  float32x4_t v39 = v27;
  float64x2_t v28 = v42;
  *(float32x2_t *)v27.f32 = vadd_f32(*(float32x2_t *)&v42.f64[0], (float32x2_t)1069547520);
  *(float *)&double v29 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v27.f32, 1), *((float *)this + 4), v27.f32[0]);
  LODWORD(v30) = *((_DWORD *)this + 7);
  v31.i32[0] = *((_DWORD *)this + 9);
  *(float *)v32.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v27.f32, 1), *(float *)&v30, v27.f32[0]);
  v27.f32[0] = *((float *)this + 6) + *(float *)&v29;
  *(float *)v28.f64 = *(float *)v31.i32 + *(float *)v32.i32;
  v27.f32[1] = *(float *)v31.i32 + *(float *)v32.i32;
  *(double *)v34.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v27.i64, v28, v29, v30, v32, v31, v33);
  float32x4_t v35 = v41;
  double v36 = *(float *)v42.f64;
  double v37 = a3;
  if (*(float *)v42.f64 + -0.5 < a3) {
    float32x4_t v35 = vmaxnmq_f32(v41, v40);
  }
  if (v36 + 0.5 < v37) {
    float32x4_t v35 = vmaxnmq_f32(v35, v39);
  }
  if (v36 + 1.5 < v37) {
    v35.i64[0] = vmaxnmq_f32(v35, v34).u64[0];
  }
  return *(double *)v35.i64;
}

double cikernel::_vertMax4(cikernel *this, SamplerObj *a2, float a3, float a4)
{
  *(float32x2_t *)&v6.f64[0] = vmul_f32(*(float32x2_t *)CI::getDC(this), (float32x2_t)0x408000003F800000);
  float64x2_t v42 = v6;
  float32x2_t v7 = vadd_f32(*(float32x2_t *)&v6.f64[0], (float32x2_t)0xBFC0000000000000);
  *(float *)&double v8 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v7, 1), *((float *)this + 4), v7.f32[0]);
  LODWORD(v9) = *((_DWORD *)this + 7);
  v10.i32[0] = *((_DWORD *)this + 9);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v7, 1), *(float *)&v9, v7.f32[0]);
  v7.f32[0] = *((float *)this + 6) + *(float *)&v8;
  *(float *)v6.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  v7.f32[1] = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v7, v6, v8, v9, v11, v10, v12);
  float32x4_t v41 = v13;
  float64x2_t v14 = v42;
  *(float32x2_t *)v13.f32 = vadd_f32(*(float32x2_t *)&v42.f64[0], (float32x2_t)0xBF00000000000000);
  *(float *)&double v15 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v13.f32, 1), *((float *)this + 4), v13.f32[0]);
  LODWORD(v16) = *((_DWORD *)this + 7);
  v17.i32[0] = *((_DWORD *)this + 9);
  *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v13.f32, 1), *(float *)&v16, v13.f32[0]);
  v13.f32[0] = *((float *)this + 6) + *(float *)&v15;
  *(float *)v14.f64 = *(float *)v17.i32 + *(float *)v18.i32;
  v13.f32[1] = *(float *)v17.i32 + *(float *)v18.i32;
  *(double *)v20.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v13.i64, v14, v15, v16, v18, v17, v19);
  float32x4_t v40 = v20;
  float64x2_t v21 = v42;
  *(float32x2_t *)v20.f32 = vadd_f32(*(float32x2_t *)&v42.f64[0], (float32x2_t)0x3F00000000000000);
  *(float *)&double v22 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v20.f32, 1), *((float *)this + 4), v20.f32[0]);
  LODWORD(v23) = *((_DWORD *)this + 7);
  v24.i32[0] = *((_DWORD *)this + 9);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v20.f32, 1), *(float *)&v23, v20.f32[0]);
  v20.f32[0] = *((float *)this + 6) + *(float *)&v22;
  *(float *)v21.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  v20.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
  *(double *)v27.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v20.i64, v21, v22, v23, v25, v24, v26);
  float32x4_t v39 = v27;
  float64x2_t v28 = v42;
  *(float32x2_t *)v27.f32 = vadd_f32(*(float32x2_t *)&v42.f64[0], (float32x2_t)0x3FC0000000000000);
  *(float *)&double v29 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v27.f32, 1), *((float *)this + 4), v27.f32[0]);
  LODWORD(v30) = *((_DWORD *)this + 7);
  v31.i32[0] = *((_DWORD *)this + 9);
  *(float *)v32.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v27.f32, 1), *(float *)&v30, v27.f32[0]);
  v27.f32[0] = *((float *)this + 6) + *(float *)&v29;
  *(float *)v28.f64 = *(float *)v31.i32 + *(float *)v32.i32;
  v27.f32[1] = *(float *)v31.i32 + *(float *)v32.i32;
  *(double *)v34.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v27.i64, v28, v29, v30, v32, v31, v33);
  float32x4_t v35 = v41;
  double v36 = *((float *)v42.f64 + 1);
  double v37 = a3;
  if (*((float *)v42.f64 + 1) + -0.5 < a3) {
    float32x4_t v35 = vmaxnmq_f32(v41, v40);
  }
  if (v36 + 0.5 < v37) {
    float32x4_t v35 = vmaxnmq_f32(v35, v39);
  }
  if (v36 + 1.5 < v37) {
    v35.i64[0] = vmaxnmq_f32(v35, v34).u64[0];
  }
  return *(double *)v35.i64;
}

double cikernel::_areaMin4(uint64_t a1, double a2)
{
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)&v4.f64[0] = vadd_f32(*DC, *DC);
  float64x2_t v40 = v4;
  float32x2_t v5 = vadd_f32(*(float32x2_t *)&v4.f64[0], (float32x2_t)0xBF000000BF000000);
  *(float *)&double v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v5, 1), *(float *)(a1 + 16), v5.f32[0]);
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *(float *)(a1 + 24) + *(float *)&v6;
  *(float *)v4.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v11.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v5, v4, v6, v7, v9, v8, v10);
  float32x4_t v38 = v11;
  float64x2_t v12 = v40;
  *(float32x2_t *)v11.f32 = vadd_f32(*(float32x2_t *)&v40.f64[0], (float32x2_t)0xBF0000003F000000);
  *(float *)&double v13 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v11.f32, 1), *(float *)(a1 + 16), v11.f32[0]);
  LODWORD(v14) = *(_DWORD *)(a1 + 28);
  v15.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v11.f32, 1), *(float *)&v14, v11.f32[0]);
  v11.f32[0] = *(float *)(a1 + 24) + *(float *)&v13;
  *(float *)v12.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v11.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  *(double *)v18.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v11.i64, v12, v13, v14, v16, v15, v17);
  float32x4_t v36 = v18;
  float64x2_t v19 = v40;
  *(float32x2_t *)v18.f32 = vadd_f32(*(float32x2_t *)&v40.f64[0], (float32x2_t)0x3F000000BF000000);
  *(float *)&double v20 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v18.f32, 1), *(float *)(a1 + 16), v18.f32[0]);
  LODWORD(v21) = *(_DWORD *)(a1 + 28);
  v22.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v23.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v18.f32, 1), *(float *)&v21, v18.f32[0]);
  v18.f32[0] = *(float *)(a1 + 24) + *(float *)&v20;
  *(float *)v19.f64 = *(float *)v22.i32 + *(float *)v23.i32;
  v18.f32[1] = *(float *)v22.i32 + *(float *)v23.i32;
  *(double *)v25.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v18.i64, v19, v20, v21, v23, v22, v24);
  float32x4_t v37 = v25;
  float64x2_t v26 = v40;
  *(float32x2_t *)v25.f32 = vadd_f32(*(float32x2_t *)&v40.f64[0], (float32x2_t)0x3F0000003F000000);
  *(float *)&double v27 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v25.f32, 1), *(float *)(a1 + 16), v25.f32[0]);
  LODWORD(v28) = *(_DWORD *)(a1 + 28);
  v29.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v30.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v25.f32, 1), *(float *)&v28, v25.f32[0]);
  v25.f32[0] = *(float *)(a1 + 24) + *(float *)&v27;
  *(float *)v26.f64 = *(float *)v29.i32 + *(float *)v30.i32;
  v25.f32[1] = *(float *)v29.i32 + *(float *)v30.i32;
  *(double *)v32.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v25.i64, v26, v27, v28, v30, v29, v31);
  if (*(float *)v40.f64 + 0.5 >= *(float *)&a2)
  {
    float32x4_t v33 = v37;
    float32x4_t v34 = v38;
  }
  else
  {
    float32x4_t v33 = vminnmq_f32(v37, v32);
    float32x4_t v34 = vminnmq_f32(v38, v36);
  }
  if (*((float *)v40.f64 + 1) + 0.5 < *((float *)&a2 + 1)) {
    v34.i64[0] = vminnmq_f32(v34, v33).u64[0];
  }
  return *(double *)v34.i64;
}

double cikernel::_horizMin4(cikernel *this, SamplerObj *a2, float a3, float a4)
{
  *(float32x2_t *)&v6.f64[0] = vmul_f32(*(float32x2_t *)CI::getDC(this), (float32x2_t)0x3F80000040800000);
  float64x2_t v42 = v6;
  float32x2_t v7 = vadd_f32(*(float32x2_t *)&v6.f64[0], (float32x2_t)3217031168);
  *(float *)&double v8 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v7, 1), *((float *)this + 4), v7.f32[0]);
  LODWORD(v9) = *((_DWORD *)this + 7);
  v10.i32[0] = *((_DWORD *)this + 9);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v7, 1), *(float *)&v9, v7.f32[0]);
  v7.f32[0] = *((float *)this + 6) + *(float *)&v8;
  *(float *)v6.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  v7.f32[1] = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v7, v6, v8, v9, v11, v10, v12);
  float32x4_t v41 = v13;
  float64x2_t v14 = v42;
  *(float32x2_t *)v13.f32 = vadd_f32(*(float32x2_t *)&v42.f64[0], (float32x2_t)3204448256);
  *(float *)&double v15 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v13.f32, 1), *((float *)this + 4), v13.f32[0]);
  LODWORD(v16) = *((_DWORD *)this + 7);
  v17.i32[0] = *((_DWORD *)this + 9);
  *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v13.f32, 1), *(float *)&v16, v13.f32[0]);
  v13.f32[0] = *((float *)this + 6) + *(float *)&v15;
  *(float *)v14.f64 = *(float *)v17.i32 + *(float *)v18.i32;
  v13.f32[1] = *(float *)v17.i32 + *(float *)v18.i32;
  *(double *)v20.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v13.i64, v14, v15, v16, v18, v17, v19);
  float32x4_t v40 = v20;
  float64x2_t v21 = v42;
  *(float32x2_t *)v20.f32 = vadd_f32(*(float32x2_t *)&v42.f64[0], (float32x2_t)1056964608);
  *(float *)&double v22 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v20.f32, 1), *((float *)this + 4), v20.f32[0]);
  LODWORD(v23) = *((_DWORD *)this + 7);
  v24.i32[0] = *((_DWORD *)this + 9);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v20.f32, 1), *(float *)&v23, v20.f32[0]);
  v20.f32[0] = *((float *)this + 6) + *(float *)&v22;
  *(float *)v21.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  v20.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
  *(double *)v27.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v20.i64, v21, v22, v23, v25, v24, v26);
  float32x4_t v39 = v27;
  float64x2_t v28 = v42;
  *(float32x2_t *)v27.f32 = vadd_f32(*(float32x2_t *)&v42.f64[0], (float32x2_t)1069547520);
  *(float *)&double v29 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v27.f32, 1), *((float *)this + 4), v27.f32[0]);
  LODWORD(v30) = *((_DWORD *)this + 7);
  v31.i32[0] = *((_DWORD *)this + 9);
  *(float *)v32.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v27.f32, 1), *(float *)&v30, v27.f32[0]);
  v27.f32[0] = *((float *)this + 6) + *(float *)&v29;
  *(float *)v28.f64 = *(float *)v31.i32 + *(float *)v32.i32;
  v27.f32[1] = *(float *)v31.i32 + *(float *)v32.i32;
  *(double *)v34.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v27.i64, v28, v29, v30, v32, v31, v33);
  float32x4_t v35 = v41;
  double v36 = *(float *)v42.f64;
  double v37 = a3;
  if (*(float *)v42.f64 + -0.5 < a3) {
    float32x4_t v35 = vminnmq_f32(v41, v40);
  }
  if (v36 + 0.5 < v37) {
    float32x4_t v35 = vminnmq_f32(v35, v39);
  }
  if (v36 + 1.5 < v37) {
    v35.i64[0] = vminnmq_f32(v35, v34).u64[0];
  }
  return *(double *)v35.i64;
}

double cikernel::_vertMin4(cikernel *this, SamplerObj *a2, float a3, float a4)
{
  *(float32x2_t *)&v6.f64[0] = vmul_f32(*(float32x2_t *)CI::getDC(this), (float32x2_t)0x408000003F800000);
  float64x2_t v42 = v6;
  float32x2_t v7 = vadd_f32(*(float32x2_t *)&v6.f64[0], (float32x2_t)0xBFC0000000000000);
  *(float *)&double v8 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v7, 1), *((float *)this + 4), v7.f32[0]);
  LODWORD(v9) = *((_DWORD *)this + 7);
  v10.i32[0] = *((_DWORD *)this + 9);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v7, 1), *(float *)&v9, v7.f32[0]);
  v7.f32[0] = *((float *)this + 6) + *(float *)&v8;
  *(float *)v6.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  v7.f32[1] = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v7, v6, v8, v9, v11, v10, v12);
  float32x4_t v41 = v13;
  float64x2_t v14 = v42;
  *(float32x2_t *)v13.f32 = vadd_f32(*(float32x2_t *)&v42.f64[0], (float32x2_t)0xBF00000000000000);
  *(float *)&double v15 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v13.f32, 1), *((float *)this + 4), v13.f32[0]);
  LODWORD(v16) = *((_DWORD *)this + 7);
  v17.i32[0] = *((_DWORD *)this + 9);
  *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v13.f32, 1), *(float *)&v16, v13.f32[0]);
  v13.f32[0] = *((float *)this + 6) + *(float *)&v15;
  *(float *)v14.f64 = *(float *)v17.i32 + *(float *)v18.i32;
  v13.f32[1] = *(float *)v17.i32 + *(float *)v18.i32;
  *(double *)v20.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v13.i64, v14, v15, v16, v18, v17, v19);
  float32x4_t v40 = v20;
  float64x2_t v21 = v42;
  *(float32x2_t *)v20.f32 = vadd_f32(*(float32x2_t *)&v42.f64[0], (float32x2_t)0x3F00000000000000);
  *(float *)&double v22 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v20.f32, 1), *((float *)this + 4), v20.f32[0]);
  LODWORD(v23) = *((_DWORD *)this + 7);
  v24.i32[0] = *((_DWORD *)this + 9);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v20.f32, 1), *(float *)&v23, v20.f32[0]);
  v20.f32[0] = *((float *)this + 6) + *(float *)&v22;
  *(float *)v21.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  v20.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
  *(double *)v27.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v20.i64, v21, v22, v23, v25, v24, v26);
  float32x4_t v39 = v27;
  float64x2_t v28 = v42;
  *(float32x2_t *)v27.f32 = vadd_f32(*(float32x2_t *)&v42.f64[0], (float32x2_t)0x3FC0000000000000);
  *(float *)&double v29 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v27.f32, 1), *((float *)this + 4), v27.f32[0]);
  LODWORD(v30) = *((_DWORD *)this + 7);
  v31.i32[0] = *((_DWORD *)this + 9);
  *(float *)v32.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v27.f32, 1), *(float *)&v30, v27.f32[0]);
  v27.f32[0] = *((float *)this + 6) + *(float *)&v29;
  *(float *)v28.f64 = *(float *)v31.i32 + *(float *)v32.i32;
  v27.f32[1] = *(float *)v31.i32 + *(float *)v32.i32;
  *(double *)v34.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v27.i64, v28, v29, v30, v32, v31, v33);
  float32x4_t v35 = v41;
  double v36 = *((float *)v42.f64 + 1);
  double v37 = a3;
  if (*((float *)v42.f64 + 1) + -0.5 < a3) {
    float32x4_t v35 = vminnmq_f32(v41, v40);
  }
  if (v36 + 0.5 < v37) {
    float32x4_t v35 = vminnmq_f32(v35, v39);
  }
  if (v36 + 1.5 < v37) {
    v35.i64[0] = vminnmq_f32(v35, v34).u64[0];
  }
  return *(double *)v35.i64;
}

double cikernel::_areaMaxAlphaS4(uint64_t a1, double a2)
{
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)&v4.f64[0] = vadd_f32(*DC, *DC);
  float64x2_t v42 = v4;
  float32x2_t v5 = vadd_f32(*(float32x2_t *)&v4.f64[0], (float32x2_t)0xBF000000BF000000);
  *(float *)&double v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v5, 1), *(float *)(a1 + 16), v5.f32[0]);
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *(float *)(a1 + 24) + *(float *)&v6;
  *(float *)v4.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v11.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v5, v4, v6, v7, v9, v8, v10);
  HIDWORD(v12) = -1090519040;
  float64x2_t v13 = v42;
  *(float32x2_t *)v14.i8 = vadd_f32(*(float32x2_t *)&v42.f64[0], (float32x2_t)0xBF0000003F000000);
  *(float *)&double v12 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v14.i8, 1), *(float *)(a1 + 16), *(float *)v14.i32);
  LODWORD(v13.f64[0]) = *(_DWORD *)(a1 + 24);
  LODWORD(v15) = *(_DWORD *)(a1 + 28);
  v16.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v14.i8, 1), *(float *)&v15, *(float *)v14.i32);
  float32x4_t v40 = v11;
  float32x4_t v46 = v11;
  v11.f32[0] = *(float *)v13.f64 + *(float *)&v12;
  *(float *)v13.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v11.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v18.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v11.i64, v13, v12, v15, v17, v16, v14);
  HIDWORD(v19) = 1056964608;
  float64x2_t v20 = v42;
  *(float32x2_t *)v21.i8 = vadd_f32(*(float32x2_t *)&v42.f64[0], (float32x2_t)0x3F000000BF000000);
  *(float *)&double v19 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v21.i8, 1), *(float *)(a1 + 16), *(float *)v21.i32);
  LODWORD(v20.f64[0]) = *(_DWORD *)(a1 + 24);
  LODWORD(v22) = *(_DWORD *)(a1 + 28);
  v23.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v24.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v21.i8, 1), *(float *)&v22, *(float *)v21.i32);
  float32x4_t v39 = v18;
  float32x4_t v45 = v18;
  v18.f32[0] = *(float *)v20.f64 + *(float *)&v19;
  *(float *)v20.f64 = *(float *)v23.i32 + *(float *)v24.i32;
  v18.f32[1] = *(float *)v23.i32 + *(float *)v24.i32;
  *(double *)v25.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v18.i64, v20, v19, v22, v24, v23, v21);
  HIDWORD(v26) = 1056964608;
  float64x2_t v27 = v42;
  *(float32x2_t *)v28.i8 = vadd_f32(*(float32x2_t *)&v42.f64[0], (float32x2_t)0x3F0000003F000000);
  *(float *)&double v26 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v28.i8, 1), *(float *)(a1 + 16), *(float *)v28.i32);
  LODWORD(v27.f64[0]) = *(_DWORD *)(a1 + 24);
  LODWORD(v29) = *(_DWORD *)(a1 + 28);
  v30.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v31.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v28.i8, 1), *(float *)&v29, *(float *)v28.i32);
  float32x4_t v38 = v25;
  float32x4_t v44 = v25;
  v25.f32[0] = *(float *)v27.f64 + *(float *)&v26;
  *(float *)v27.f64 = *(float *)v30.i32 + *(float *)v31.i32;
  v25.f32[1] = *(float *)v30.i32 + *(float *)v31.i32;
  *(double *)v32.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v25.i64, v27, v26, v29, v31, v30, v28);
  float32x4_t v43 = v32;
  int8x16_t v33 = &v44;
  if (*(float *)v42.f64 + 0.5 >= *(float *)&a2)
  {
    float v36 = v40.f32[3];
    float32x4_t v35 = &v44;
  }
  else
  {
    float32x4_t v34 = &v45;
    if (vmovn_s32(vcgeq_f32(v40, v39)).i8[6]) {
      float32x4_t v34 = &v46;
    }
    float32x4_t v46 = *v34;
    float32x4_t v35 = &v43;
    if (vmovn_s32(vcgeq_f32(v38, v32)).i8[6]) {
      float32x4_t v35 = &v44;
    }
    float v36 = v46.f32[3];
  }
  float32x4_t v44 = *v35;
  if (v36 >= v44.f32[3]) {
    int8x16_t v33 = &v46;
  }
  if (*((float *)v42.f64 + 1) + 0.5 >= *((float *)&a2 + 1)) {
    int8x16_t v33 = &v46;
  }
  return *(double *)v33->i64;
}

double cikernel::_areaMaxAlphaH4(cikernel *this, SamplerObj *a2, float a3, float a4)
{
  *(float32x2_t *)&v6.f64[0] = vmul_f32(*(float32x2_t *)CI::getDC(this), (float32x2_t)0x3F80000040800000);
  float64x2_t v45 = v6;
  float32x2_t v7 = vadd_f32(*(float32x2_t *)&v6.f64[0], (float32x2_t)3217031168);
  *(float *)&double v8 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v7, 1), *((float *)this + 4), v7.f32[0]);
  LODWORD(v9) = *((_DWORD *)this + 7);
  v10.i32[0] = *((_DWORD *)this + 9);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v7, 1), *(float *)&v9, v7.f32[0]);
  v7.f32[0] = *((float *)this + 6) + *(float *)&v8;
  *(float *)v6.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  v7.f32[1] = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v7, v6, v8, v9, v11, v10, v12);
  float32x4_t v44 = v13;
  float64x2_t v14 = v45;
  *(float32x2_t *)v15.i8 = vadd_f32(*(float32x2_t *)&v45.f64[0], (float32x2_t)3204448256);
  *(float *)&unsigned int v16 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v15.i8, 1), *((float *)this + 4), *(float *)v15.i32);
  LODWORD(v14.f64[0]) = *((_DWORD *)this + 6);
  LODWORD(v17) = *((_DWORD *)this + 7);
  v18.i32[0] = *((_DWORD *)this + 9);
  *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v15.i8, 1), *(float *)&v17, *(float *)v15.i32);
  float32x4_t v49 = v13;
  v13.f32[0] = *(float *)v14.f64 + *(float *)&v16;
  *(float *)v14.f64 = *(float *)v18.i32 + *(float *)v19.i32;
  v13.f32[1] = *(float *)v18.i32 + *(float *)v19.i32;
  *(double *)v20.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v13.i64, v14, COERCE_DOUBLE((unint64_t)v16), v17, v19, v18, v15);
  float32x4_t v43 = v20;
  float64x2_t v21 = v45;
  *(float32x2_t *)v22.i8 = vadd_f32(*(float32x2_t *)&v45.f64[0], (float32x2_t)1056964608);
  *(float *)&unsigned int v23 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v22.i8, 1), *((float *)this + 4), *(float *)v22.i32);
  LODWORD(v21.f64[0]) = *((_DWORD *)this + 6);
  LODWORD(v24) = *((_DWORD *)this + 7);
  v25.i32[0] = *((_DWORD *)this + 9);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v22.i8, 1), *(float *)&v24, *(float *)v22.i32);
  float32x4_t v48 = v20;
  v20.f32[0] = *(float *)v21.f64 + *(float *)&v23;
  *(float *)v21.f64 = *(float *)v25.i32 + *(float *)v26.i32;
  v20.f32[1] = *(float *)v25.i32 + *(float *)v26.i32;
  *(double *)&long long v27 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v20.i64, v21, COERCE_DOUBLE((unint64_t)v23), v24, v26, v25, v22);
  float v42 = *((float *)&v27 + 3);
  float64x2_t v28 = v45;
  *(float32x2_t *)v29.i8 = vadd_f32(*(float32x2_t *)&v45.f64[0], (float32x2_t)1069547520);
  *(float *)&unsigned int v30 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v29.i8, 1), *((float *)this + 4), *(float *)v29.i32);
  LODWORD(v28.f64[0]) = *((_DWORD *)this + 6);
  LODWORD(v31) = *((_DWORD *)this + 7);
  v32.i32[0] = *((_DWORD *)this + 9);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v29.i8, 1), *(float *)&v31, *(float *)v29.i32);
  long long v47 = v27;
  *(float *)&long long v27 = *(float *)v28.f64 + *(float *)&v30;
  *(float *)v28.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  *((float *)&v27 + 1) = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)&long long v34 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v27, v28, COERCE_DOUBLE((unint64_t)v30), v31, v33, v32, v29);
  long long v46 = v34;
  double v35 = *(float *)v45.f64;
  double v36 = a3;
  double v37 = &v48;
  if (vmovn_s32(vcgeq_f32(v44, v43)).i8[6]) {
    double v37 = &v49;
  }
  if (*(float *)v45.f64 + -0.5 >= v36) {
    double v37 = &v49;
  }
  float32x4_t v49 = *v37;
  float32x4_t v38 = (float32x4_t *)&v47;
  if (v49.f32[3] >= v42) {
    float32x4_t v38 = &v49;
  }
  if (v35 + 0.5 >= v36) {
    float32x4_t v38 = &v49;
  }
  float32x4_t v49 = *v38;
  double v39 = v35 + 1.5;
  float32x4_t v40 = (float32x4_t *)&v46;
  if (v49.f32[3] >= *((float *)&v34 + 3)) {
    float32x4_t v40 = &v49;
  }
  if (v39 >= v36) {
    float32x4_t v40 = &v49;
  }
  return *(double *)v40->i64;
}

double cikernel::_areaMaxAlphaV4(cikernel *this, SamplerObj *a2, float a3, float a4)
{
  *(float32x2_t *)&v6.f64[0] = vmul_f32(*(float32x2_t *)CI::getDC(this), (float32x2_t)0x408000003F800000);
  float64x2_t v45 = v6;
  float32x2_t v7 = vadd_f32(*(float32x2_t *)&v6.f64[0], (float32x2_t)0xBFC0000000000000);
  *(float *)&double v8 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v7, 1), *((float *)this + 4), v7.f32[0]);
  LODWORD(v9) = *((_DWORD *)this + 7);
  v10.i32[0] = *((_DWORD *)this + 9);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v7, 1), *(float *)&v9, v7.f32[0]);
  v7.f32[0] = *((float *)this + 6) + *(float *)&v8;
  *(float *)v6.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  v7.f32[1] = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v7, v6, v8, v9, v11, v10, v12);
  float32x4_t v44 = v13;
  HIDWORD(v14) = -1090519040;
  float64x2_t v15 = v45;
  *(float32x2_t *)v16.i8 = vadd_f32(*(float32x2_t *)&v45.f64[0], (float32x2_t)0xBF00000000000000);
  *(float *)&double v14 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v16.i8, 1), *((float *)this + 4), *(float *)v16.i32);
  LODWORD(v15.f64[0]) = *((_DWORD *)this + 6);
  LODWORD(v17) = *((_DWORD *)this + 7);
  v18.i32[0] = *((_DWORD *)this + 9);
  *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v16.i8, 1), *(float *)&v17, *(float *)v16.i32);
  float32x4_t v49 = v13;
  v13.f32[0] = *(float *)v15.f64 + *(float *)&v14;
  *(float *)v15.f64 = *(float *)v18.i32 + *(float *)v19.i32;
  v13.f32[1] = *(float *)v18.i32 + *(float *)v19.i32;
  *(double *)v20.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v13.i64, v15, v14, v17, v19, v18, v16);
  float32x4_t v43 = v20;
  HIDWORD(v21) = 1056964608;
  float64x2_t v22 = v45;
  *(float32x2_t *)v23.i8 = vadd_f32(*(float32x2_t *)&v45.f64[0], (float32x2_t)0x3F00000000000000);
  *(float *)&double v21 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v23.i8, 1), *((float *)this + 4), *(float *)v23.i32);
  LODWORD(v22.f64[0]) = *((_DWORD *)this + 6);
  LODWORD(v24) = *((_DWORD *)this + 7);
  v25.i32[0] = *((_DWORD *)this + 9);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v23.i8, 1), *(float *)&v24, *(float *)v23.i32);
  float32x4_t v48 = v20;
  v20.f32[0] = *(float *)v22.f64 + *(float *)&v21;
  *(float *)v22.f64 = *(float *)v25.i32 + *(float *)v26.i32;
  v20.f32[1] = *(float *)v25.i32 + *(float *)v26.i32;
  *(double *)&long long v27 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v20.i64, v22, v21, v24, v26, v25, v23);
  float v42 = *((float *)&v27 + 3);
  HIDWORD(v28) = 1069547520;
  float64x2_t v29 = v45;
  *(float32x2_t *)v30.i8 = vadd_f32(*(float32x2_t *)&v45.f64[0], (float32x2_t)0x3FC0000000000000);
  *(float *)&double v28 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v30.i8, 1), *((float *)this + 4), *(float *)v30.i32);
  LODWORD(v29.f64[0]) = *((_DWORD *)this + 6);
  LODWORD(v31) = *((_DWORD *)this + 7);
  v32.i32[0] = *((_DWORD *)this + 9);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v30.i8, 1), *(float *)&v31, *(float *)v30.i32);
  long long v47 = v27;
  *(float *)&long long v27 = *(float *)v29.f64 + *(float *)&v28;
  *(float *)v29.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  *((float *)&v27 + 1) = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)&long long v34 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v27, v29, v28, v31, v33, v32, v30);
  long long v46 = v34;
  double v35 = *((float *)v45.f64 + 1);
  double v36 = a3;
  double v37 = &v48;
  if (vmovn_s32(vcgeq_f32(v44, v43)).i8[6]) {
    double v37 = &v49;
  }
  if (*((float *)v45.f64 + 1) + -0.5 >= v36) {
    double v37 = &v49;
  }
  float32x4_t v49 = *v37;
  float32x4_t v38 = (float32x4_t *)&v47;
  if (v49.f32[3] >= v42) {
    float32x4_t v38 = &v49;
  }
  if (v35 + 0.5 >= v36) {
    float32x4_t v38 = &v49;
  }
  float32x4_t v49 = *v38;
  double v39 = v35 + 1.5;
  float32x4_t v40 = (float32x4_t *)&v46;
  if (v49.f32[3] >= *((float *)&v34 + 3)) {
    float32x4_t v40 = &v49;
  }
  if (v39 >= v36) {
    float32x4_t v40 = &v49;
  }
  return *(double *)v40->i64;
}

double cikernel::_areaMinAlphaS4(uint64_t a1, double a2)
{
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)&v4.f64[0] = vadd_f32(*DC, *DC);
  float64x2_t v42 = v4;
  float32x2_t v5 = vadd_f32(*(float32x2_t *)&v4.f64[0], (float32x2_t)0xBF000000BF000000);
  *(float *)&double v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v5, 1), *(float *)(a1 + 16), v5.f32[0]);
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *(float *)(a1 + 24) + *(float *)&v6;
  *(float *)v4.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v11.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v5, v4, v6, v7, v9, v8, v10);
  HIDWORD(v12) = -1090519040;
  float64x2_t v13 = v42;
  *(float32x2_t *)v14.i8 = vadd_f32(*(float32x2_t *)&v42.f64[0], (float32x2_t)0xBF0000003F000000);
  *(float *)&double v12 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v14.i8, 1), *(float *)(a1 + 16), *(float *)v14.i32);
  LODWORD(v13.f64[0]) = *(_DWORD *)(a1 + 24);
  LODWORD(v15) = *(_DWORD *)(a1 + 28);
  v16.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v14.i8, 1), *(float *)&v15, *(float *)v14.i32);
  float32x4_t v40 = v11;
  float32x4_t v46 = v11;
  v11.f32[0] = *(float *)v13.f64 + *(float *)&v12;
  *(float *)v13.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v11.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v18.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v11.i64, v13, v12, v15, v17, v16, v14);
  HIDWORD(v19) = 1056964608;
  float64x2_t v20 = v42;
  *(float32x2_t *)v21.i8 = vadd_f32(*(float32x2_t *)&v42.f64[0], (float32x2_t)0x3F000000BF000000);
  *(float *)&double v19 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v21.i8, 1), *(float *)(a1 + 16), *(float *)v21.i32);
  LODWORD(v20.f64[0]) = *(_DWORD *)(a1 + 24);
  LODWORD(v22) = *(_DWORD *)(a1 + 28);
  v23.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v24.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v21.i8, 1), *(float *)&v22, *(float *)v21.i32);
  float32x4_t v39 = v18;
  float32x4_t v45 = v18;
  v18.f32[0] = *(float *)v20.f64 + *(float *)&v19;
  *(float *)v20.f64 = *(float *)v23.i32 + *(float *)v24.i32;
  v18.f32[1] = *(float *)v23.i32 + *(float *)v24.i32;
  *(double *)v25.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v18.i64, v20, v19, v22, v24, v23, v21);
  HIDWORD(v26) = 1056964608;
  float64x2_t v27 = v42;
  *(float32x2_t *)v28.i8 = vadd_f32(*(float32x2_t *)&v42.f64[0], (float32x2_t)0x3F0000003F000000);
  *(float *)&double v26 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v28.i8, 1), *(float *)(a1 + 16), *(float *)v28.i32);
  LODWORD(v27.f64[0]) = *(_DWORD *)(a1 + 24);
  LODWORD(v29) = *(_DWORD *)(a1 + 28);
  v30.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v31.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v28.i8, 1), *(float *)&v29, *(float *)v28.i32);
  float32x4_t v38 = v25;
  float32x4_t v44 = v25;
  v25.f32[0] = *(float *)v27.f64 + *(float *)&v26;
  *(float *)v27.f64 = *(float *)v30.i32 + *(float *)v31.i32;
  v25.f32[1] = *(float *)v30.i32 + *(float *)v31.i32;
  *(double *)v32.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v25.i64, v27, v26, v29, v31, v30, v28);
  float32x4_t v43 = v32;
  int8x16_t v33 = &v44;
  if (*(float *)v42.f64 + 0.5 >= *(float *)&a2)
  {
    float v36 = v40.f32[3];
    double v35 = &v44;
  }
  else
  {
    long long v34 = &v45;
    if (vmovn_s32(vcgeq_f32(v39, v40)).i8[6]) {
      long long v34 = &v46;
    }
    float32x4_t v46 = *v34;
    double v35 = &v43;
    if (vmovn_s32(vcgeq_f32(v32, v38)).i8[6]) {
      double v35 = &v44;
    }
    float v36 = v46.f32[3];
  }
  float32x4_t v44 = *v35;
  if (v36 <= v44.f32[3]) {
    int8x16_t v33 = &v46;
  }
  if (*((float *)v42.f64 + 1) + 0.5 >= *((float *)&a2 + 1)) {
    int8x16_t v33 = &v46;
  }
  return *(double *)v33->i64;
}

double cikernel::_areaMinAlphaH4(cikernel *this, SamplerObj *a2, float a3, float a4)
{
  *(float32x2_t *)&v6.f64[0] = vmul_f32(*(float32x2_t *)CI::getDC(this), (float32x2_t)0x3F80000040800000);
  float64x2_t v45 = v6;
  float32x2_t v7 = vadd_f32(*(float32x2_t *)&v6.f64[0], (float32x2_t)3217031168);
  *(float *)&double v8 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v7, 1), *((float *)this + 4), v7.f32[0]);
  LODWORD(v9) = *((_DWORD *)this + 7);
  v10.i32[0] = *((_DWORD *)this + 9);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v7, 1), *(float *)&v9, v7.f32[0]);
  v7.f32[0] = *((float *)this + 6) + *(float *)&v8;
  *(float *)v6.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  v7.f32[1] = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v7, v6, v8, v9, v11, v10, v12);
  float32x4_t v44 = v13;
  float64x2_t v14 = v45;
  *(float32x2_t *)v15.i8 = vadd_f32(*(float32x2_t *)&v45.f64[0], (float32x2_t)3204448256);
  *(float *)&unsigned int v16 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v15.i8, 1), *((float *)this + 4), *(float *)v15.i32);
  LODWORD(v14.f64[0]) = *((_DWORD *)this + 6);
  LODWORD(v17) = *((_DWORD *)this + 7);
  v18.i32[0] = *((_DWORD *)this + 9);
  *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v15.i8, 1), *(float *)&v17, *(float *)v15.i32);
  float32x4_t v49 = v13;
  v13.f32[0] = *(float *)v14.f64 + *(float *)&v16;
  *(float *)v14.f64 = *(float *)v18.i32 + *(float *)v19.i32;
  v13.f32[1] = *(float *)v18.i32 + *(float *)v19.i32;
  *(double *)v20.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v13.i64, v14, COERCE_DOUBLE((unint64_t)v16), v17, v19, v18, v15);
  float32x4_t v43 = v20;
  float64x2_t v21 = v45;
  *(float32x2_t *)v22.i8 = vadd_f32(*(float32x2_t *)&v45.f64[0], (float32x2_t)1056964608);
  *(float *)&unsigned int v23 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v22.i8, 1), *((float *)this + 4), *(float *)v22.i32);
  LODWORD(v21.f64[0]) = *((_DWORD *)this + 6);
  LODWORD(v24) = *((_DWORD *)this + 7);
  v25.i32[0] = *((_DWORD *)this + 9);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v22.i8, 1), *(float *)&v24, *(float *)v22.i32);
  float32x4_t v48 = v20;
  v20.f32[0] = *(float *)v21.f64 + *(float *)&v23;
  *(float *)v21.f64 = *(float *)v25.i32 + *(float *)v26.i32;
  v20.f32[1] = *(float *)v25.i32 + *(float *)v26.i32;
  *(double *)&long long v27 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v20.i64, v21, COERCE_DOUBLE((unint64_t)v23), v24, v26, v25, v22);
  float v42 = *((float *)&v27 + 3);
  float64x2_t v28 = v45;
  *(float32x2_t *)v29.i8 = vadd_f32(*(float32x2_t *)&v45.f64[0], (float32x2_t)1069547520);
  *(float *)&unsigned int v30 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v29.i8, 1), *((float *)this + 4), *(float *)v29.i32);
  LODWORD(v28.f64[0]) = *((_DWORD *)this + 6);
  LODWORD(v31) = *((_DWORD *)this + 7);
  v32.i32[0] = *((_DWORD *)this + 9);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v29.i8, 1), *(float *)&v31, *(float *)v29.i32);
  long long v47 = v27;
  *(float *)&long long v27 = *(float *)v28.f64 + *(float *)&v30;
  *(float *)v28.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  *((float *)&v27 + 1) = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)&long long v34 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v27, v28, COERCE_DOUBLE((unint64_t)v30), v31, v33, v32, v29);
  long long v46 = v34;
  double v35 = *(float *)v45.f64;
  double v36 = a3;
  double v37 = &v48;
  if (vmovn_s32(vcgeq_f32(v43, v44)).i8[6]) {
    double v37 = &v49;
  }
  if (*(float *)v45.f64 + -0.5 >= v36) {
    double v37 = &v49;
  }
  float32x4_t v49 = *v37;
  float32x4_t v38 = (float32x4_t *)&v47;
  if (v49.f32[3] <= v42) {
    float32x4_t v38 = &v49;
  }
  if (v35 + 0.5 >= v36) {
    float32x4_t v38 = &v49;
  }
  float32x4_t v49 = *v38;
  double v39 = v35 + 1.5;
  float32x4_t v40 = (float32x4_t *)&v46;
  if (v49.f32[3] <= *((float *)&v34 + 3)) {
    float32x4_t v40 = &v49;
  }
  if (v39 >= v36) {
    float32x4_t v40 = &v49;
  }
  return *(double *)v40->i64;
}

double cikernel::_areaMinAlphaV4(cikernel *this, SamplerObj *a2, float a3, float a4)
{
  *(float32x2_t *)&v6.f64[0] = vmul_f32(*(float32x2_t *)CI::getDC(this), (float32x2_t)0x408000003F800000);
  float64x2_t v45 = v6;
  float32x2_t v7 = vadd_f32(*(float32x2_t *)&v6.f64[0], (float32x2_t)0xBFC0000000000000);
  *(float *)&double v8 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v7, 1), *((float *)this + 4), v7.f32[0]);
  LODWORD(v9) = *((_DWORD *)this + 7);
  v10.i32[0] = *((_DWORD *)this + 9);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v7, 1), *(float *)&v9, v7.f32[0]);
  v7.f32[0] = *((float *)this + 6) + *(float *)&v8;
  *(float *)v6.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  v7.f32[1] = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v7, v6, v8, v9, v11, v10, v12);
  float32x4_t v44 = v13;
  HIDWORD(v14) = -1090519040;
  float64x2_t v15 = v45;
  *(float32x2_t *)v16.i8 = vadd_f32(*(float32x2_t *)&v45.f64[0], (float32x2_t)0xBF00000000000000);
  *(float *)&double v14 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v16.i8, 1), *((float *)this + 4), *(float *)v16.i32);
  LODWORD(v15.f64[0]) = *((_DWORD *)this + 6);
  LODWORD(v17) = *((_DWORD *)this + 7);
  v18.i32[0] = *((_DWORD *)this + 9);
  *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v16.i8, 1), *(float *)&v17, *(float *)v16.i32);
  float32x4_t v49 = v13;
  v13.f32[0] = *(float *)v15.f64 + *(float *)&v14;
  *(float *)v15.f64 = *(float *)v18.i32 + *(float *)v19.i32;
  v13.f32[1] = *(float *)v18.i32 + *(float *)v19.i32;
  *(double *)v20.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v13.i64, v15, v14, v17, v19, v18, v16);
  float32x4_t v43 = v20;
  HIDWORD(v21) = 1056964608;
  float64x2_t v22 = v45;
  *(float32x2_t *)v23.i8 = vadd_f32(*(float32x2_t *)&v45.f64[0], (float32x2_t)0x3F00000000000000);
  *(float *)&double v21 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v23.i8, 1), *((float *)this + 4), *(float *)v23.i32);
  LODWORD(v22.f64[0]) = *((_DWORD *)this + 6);
  LODWORD(v24) = *((_DWORD *)this + 7);
  v25.i32[0] = *((_DWORD *)this + 9);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v23.i8, 1), *(float *)&v24, *(float *)v23.i32);
  float32x4_t v48 = v20;
  v20.f32[0] = *(float *)v22.f64 + *(float *)&v21;
  *(float *)v22.f64 = *(float *)v25.i32 + *(float *)v26.i32;
  v20.f32[1] = *(float *)v25.i32 + *(float *)v26.i32;
  *(double *)&long long v27 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v20.i64, v22, v21, v24, v26, v25, v23);
  float v42 = *((float *)&v27 + 3);
  HIDWORD(v28) = 1069547520;
  float64x2_t v29 = v45;
  *(float32x2_t *)v30.i8 = vadd_f32(*(float32x2_t *)&v45.f64[0], (float32x2_t)0x3FC0000000000000);
  *(float *)&double v28 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v30.i8, 1), *((float *)this + 4), *(float *)v30.i32);
  LODWORD(v29.f64[0]) = *((_DWORD *)this + 6);
  LODWORD(v31) = *((_DWORD *)this + 7);
  v32.i32[0] = *((_DWORD *)this + 9);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v30.i8, 1), *(float *)&v31, *(float *)v30.i32);
  long long v47 = v27;
  *(float *)&long long v27 = *(float *)v29.f64 + *(float *)&v28;
  *(float *)v29.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  *((float *)&v27 + 1) = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)&long long v34 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v27, v29, v28, v31, v33, v32, v30);
  long long v46 = v34;
  double v35 = *((float *)v45.f64 + 1);
  double v36 = a3;
  double v37 = &v48;
  if (vmovn_s32(vcgeq_f32(v43, v44)).i8[6]) {
    double v37 = &v49;
  }
  if (*((float *)v45.f64 + 1) + -0.5 >= v36) {
    double v37 = &v49;
  }
  float32x4_t v49 = *v37;
  float32x4_t v38 = (float32x4_t *)&v47;
  if (v49.f32[3] <= v42) {
    float32x4_t v38 = &v49;
  }
  if (v35 + 0.5 >= v36) {
    float32x4_t v38 = &v49;
  }
  float32x4_t v49 = *v38;
  double v39 = v35 + 1.5;
  float32x4_t v40 = (float32x4_t *)&v46;
  if (v49.f32[3] <= *((float *)&v34 + 3)) {
    float32x4_t v40 = &v49;
  }
  if (v39 >= v36) {
    float32x4_t v40 = &v49;
  }
  return *(double *)v40->i64;
}

double cikernel::_reduceCropMinMaxRed(cikernel *this, SamplerObj *a2, double a3, float64x2_t a4, double a5, double a6, int8x16_t a7, int8x16_t a8, int8x16_t a9)
{
  a7.i32[0] = 0.5;
  LODWORD(a5) = *((_DWORD *)this + 7);
  *(float *)&double v9 = *((float *)this + 6)
                + (float)((float)(*((float *)this + 5) * 0.5) + (float)(*((float *)this + 4) * 0.5));
  LODWORD(a6) = *((_DWORD *)this + 9);
  *(float *)a4.f64 = *(float *)&a6 + (float)((float)(*((float *)this + 8) * 0.5) + (float)(*(float *)&a5 * 0.5));
  *((float *)&v9 + 1) = *(float *)a4.f64;
  *(double *)v10.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v9, a4, a5, a6, a7, a8, a9);
  int8x16_t v15 = v10;
  *(float32x2_t *)v12.f32 = vabs_f32(vadd_f32(*(float32x2_t *)CI::getDC(v11), (float32x2_t)0xBF000000BF000000));
  v12.f32[0] = fmaxf(v12.f32[0], v12.f32[1]);
  v13.i64[0] = COERCE_UNSIGNED_INT(0.5) | 0xBF00000000000000;
  *(void *)&double result = vandq_s8(v15, (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(v13, v12), 0)).u64[0];
  return result;
}

float64_t cikernel::_areaMinMaxRed16(uint64_t a1, float32x2_t a2, float a3)
{
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  __asm { FMOV            V1.2S, #4.0 }
  float32x2_t v17 = vmul_f32(*DC, _D1);
  v19.f64[0] = -5.05804416e157;
  float64x2_t v25 = v19;
  double v18 = a3;
  LODWORD(v19.f64[0]) = -1.5;
  float64x2_t v26 = v19;
  do
  {
    LODWORD(v19.f64[0]) = -1.5;
    do
    {
      float64x2_t v28 = v19;
      float64x2_t v20 = v26;
      HIDWORD(v19.f64[0]) = LODWORD(v26.f64[0]);
      *(float32x2_t *)v9.i8 = vadd_f32(v17, *(float32x2_t *)&v19.f64[0]);
      LODWORD(v7.f64[0]) = *(_DWORD *)(a1 + 28);
      *(float *)&double v21 = *(float *)(a1 + 24)
                     + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v9.i8, 1), *(float *)(a1 + 16), *(float *)v9.i32);
      LODWORD(v8) = *(_DWORD *)(a1 + 36);
      float32x2_t v27 = *(float32x2_t *)v9.i8;
      *(float *)v20.f64 = *(float *)&v8
                        + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v9.i8, 1), *(float *)v7.f64, *(float *)v9.i32);
      HIDWORD(v21) = LODWORD(v20.f64[0]);
      double v22 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v21, v20, v7.f64[0], v8, v9, v10, v11);
      if (v18 < 0.9) {
        double v22 = COERCE_DOUBLE(vdup_lane_s32(*(int32x2_t *)&v22, 0));
      }
      int32x2_t v23 = vcgt_f32(a2, v27);
      if (v23.i8[0] & 1) != 0 && (v23.i8[4])
      {
        v7.f64[1] = v25.f64[1];
        *(float *)v7.f64 = fminf(*(float *)&v22, *(float *)v25.f64);
        HIDWORD(v7.f64[0]) = fmaxf(*((float *)&v22 + 1), *((float *)v25.f64 + 1));
        float64x2_t v25 = v7;
      }
      float64x2_t v19 = v28;
      *(float *)v19.f64 = *(float *)v28.f64 + 1.0;
    }
    while ((float)(*(float *)v28.f64 + 1.0) < 2.0);
    float64x2_t v19 = v26;
    *(float *)v19.f64 = *(float *)v26.f64 + 1.0;
    float64x2_t v26 = v19;
  }
  while (*(float *)v19.f64 < 2.0);
  return v25.f64[0];
}

__n64 cikernel::_areaMinMaxRed4(uint64_t a1, double a2, float a3)
{
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)&v6.f64[0] = vadd_f32(*DC, *DC);
  float64x2_t v51 = v6;
  float32x2_t v7 = vadd_f32(*(float32x2_t *)&v6.f64[0], (float32x2_t)0xBF000000BF000000);
  *(float *)&double v8 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v7, 1), *(float *)(a1 + 16), v7.f32[0]);
  LODWORD(v9) = *(_DWORD *)(a1 + 28);
  v10.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v7, 1), *(float *)&v9, v7.f32[0]);
  v7.f32[0] = *(float *)(a1 + 24) + *(float *)&v8;
  *(float *)v6.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  v7.f32[1] = *(float *)v10.i32 + *(float *)v11.i32;
  double v49 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v7, v6, v8, v9, v11, v10, v12);
  float64x2_t v13 = v51;
  float32x2_t v14 = vadd_f32(*(float32x2_t *)&v51.f64[0], (float32x2_t)0xBF0000003F000000);
  *(float *)&double v15 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v14, 1), *(float *)(a1 + 16), v14.f32[0]);
  LODWORD(v16) = *(_DWORD *)(a1 + 28);
  v17.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v14, 1), *(float *)&v16, v14.f32[0]);
  v14.f32[0] = *(float *)(a1 + 24) + *(float *)&v15;
  *(float *)v13.f64 = *(float *)v17.i32 + *(float *)v18.i32;
  v14.f32[1] = *(float *)v17.i32 + *(float *)v18.i32;
  double v48 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v14, v13, v15, v16, v18, v17, v19);
  float64x2_t v20 = v51;
  float32x2_t v21 = vadd_f32(*(float32x2_t *)&v51.f64[0], (float32x2_t)0x3F000000BF000000);
  *(float *)&double v22 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v21, 1), *(float *)(a1 + 16), v21.f32[0]);
  LODWORD(v23) = *(_DWORD *)(a1 + 28);
  v24.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v21, 1), *(float *)&v23, v21.f32[0]);
  v21.f32[0] = *(float *)(a1 + 24) + *(float *)&v22;
  *(float *)v20.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  v21.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
  double v47 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v21, v20, v22, v23, v25, v24, v26);
  float64x2_t v27 = v51;
  float32x2_t v28 = vadd_f32(*(float32x2_t *)&v51.f64[0], (float32x2_t)0x3F0000003F000000);
  *(float *)&double v29 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v28, 1), *(float *)(a1 + 16), v28.f32[0]);
  LODWORD(v30) = *(_DWORD *)(a1 + 28);
  v31.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v32.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v28, 1), *(float *)&v30, v28.f32[0]);
  v28.f32[0] = *(float *)(a1 + 24) + *(float *)&v29;
  *(float *)v27.f64 = *(float *)v31.i32 + *(float *)v32.i32;
  v28.f32[1] = *(float *)v31.i32 + *(float *)v32.i32;
  double v34 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v28, v27, v29, v30, v32, v31, v33);
  if (a3 >= 0.9)
  {
    int32x2_t v36 = *(int32x2_t *)&v48;
    int32x2_t v35 = *(int32x2_t *)&v49;
    int32x2_t v37 = *(int32x2_t *)&v47;
  }
  else
  {
    int32x2_t v35 = vdup_lane_s32(*(int32x2_t *)&v49, 0);
    int32x2_t v36 = vdup_lane_s32(*(int32x2_t *)&v48, 0);
    int32x2_t v37 = vdup_lane_s32(*(int32x2_t *)&v47, 0);
    double v34 = COERCE_DOUBLE(vdup_lane_s32(*(int32x2_t *)&v34, 0));
  }
  double v38 = COERCE_DOUBLE(vzip2_s32(v35, v37));
  float v39 = fminf(*(float *)v37.i32, *(float *)&v34);
  float v40 = fminf(*(float *)v35.i32, *(float *)v36.i32);
  double v41 = COERCE_DOUBLE(vmaxnm_f32(*(float32x2_t *)&v38, (float32x2_t)vzip2_s32(v36, *(int32x2_t *)&v34)));
  if (*(float *)v51.f64 + 0.5 < *(float *)&a2)
  {
    double v38 = v41;
  }
  else
  {
    float v39 = *(float *)v37.i32;
    float v40 = *(float *)v35.i32;
  }
  double v42 = *((float *)v51.f64 + 1) + 0.5;
  float v43 = fminf(v40, v39);
  BOOL v44 = v42 < *((float *)&a2 + 1);
  if (v42 >= *((float *)&a2 + 1)) {
    result.n64_f32[0] = v40;
  }
  else {
    result.n64_f32[0] = v43;
  }
  float v46 = fmaxf(*(float *)&v38, *((float *)&v38 + 1));
  if (v44) {
    *(float *)&double v38 = v46;
  }
  result.n64_u32[1] = LODWORD(v38);
  return result;
}

double cikernel::_horizMinMaxRed4(cikernel *this, SamplerObj *a2, float a3, float a4)
{
  *(float32x2_t *)&v7.f64[0] = vmul_f32(*(float32x2_t *)CI::getDC(this), (float32x2_t)0x3F80000040800000);
  float64x2_t v56 = v7;
  float32x2_t v8 = vadd_f32(*(float32x2_t *)&v7.f64[0], (float32x2_t)3217031168);
  *(float *)&double v9 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v8, 1), *((float *)this + 4), v8.f32[0]);
  LODWORD(v10) = *((_DWORD *)this + 7);
  v11.i32[0] = *((_DWORD *)this + 9);
  *(float *)v12.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v8, 1), *(float *)&v10, v8.f32[0]);
  v8.f32[0] = *((float *)this + 6) + *(float *)&v9;
  *(float *)v7.f64 = *(float *)v11.i32 + *(float *)v12.i32;
  v8.f32[1] = *(float *)v11.i32 + *(float *)v12.i32;
  double v55 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v8, v7, v9, v10, v12, v11, v13);
  float64x2_t v14 = v56;
  float32x2_t v15 = vadd_f32(*(float32x2_t *)&v56.f64[0], (float32x2_t)3204448256);
  *(float *)&double v16 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v15, 1), *((float *)this + 4), v15.f32[0]);
  LODWORD(v17) = *((_DWORD *)this + 7);
  v18.i32[0] = *((_DWORD *)this + 9);
  *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v15, 1), *(float *)&v17, v15.f32[0]);
  v15.f32[0] = *((float *)this + 6) + *(float *)&v16;
  *(float *)v14.f64 = *(float *)v18.i32 + *(float *)v19.i32;
  v15.f32[1] = *(float *)v18.i32 + *(float *)v19.i32;
  double v54 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v15, v14, v16, v17, v19, v18, v20);
  float64x2_t v21 = v56;
  float32x2_t v22 = vadd_f32(*(float32x2_t *)&v56.f64[0], (float32x2_t)1056964608);
  *(float *)&double v23 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v22, 1), *((float *)this + 4), v22.f32[0]);
  LODWORD(v24) = *((_DWORD *)this + 7);
  v25.i32[0] = *((_DWORD *)this + 9);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v22, 1), *(float *)&v24, v22.f32[0]);
  v22.f32[0] = *((float *)this + 6) + *(float *)&v23;
  *(float *)v21.f64 = *(float *)v25.i32 + *(float *)v26.i32;
  v22.f32[1] = *(float *)v25.i32 + *(float *)v26.i32;
  double v53 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v22, v21, v23, v24, v26, v25, v27);
  float64x2_t v28 = v56;
  float32x2_t v29 = vadd_f32(*(float32x2_t *)&v56.f64[0], (float32x2_t)1069547520);
  *(float *)&double v30 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v29, 1), *((float *)this + 4), v29.f32[0]);
  LODWORD(v31) = *((_DWORD *)this + 7);
  v32.i32[0] = *((_DWORD *)this + 9);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v29, 1), *(float *)&v31, v29.f32[0]);
  v29.f32[0] = *((float *)this + 6) + *(float *)&v30;
  *(float *)v28.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v29.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  double v35 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v29, v28, v30, v31, v33, v32, v34);
  if (a4 >= 0.9)
  {
    int32x2_t v37 = *(int32x2_t *)&v54;
    int32x2_t v36 = *(int32x2_t *)&v55;
    int32x2_t v38 = *(int32x2_t *)&v53;
  }
  else
  {
    int32x2_t v36 = vdup_lane_s32(*(int32x2_t *)&v55, 0);
    int32x2_t v37 = vdup_lane_s32(*(int32x2_t *)&v54, 0);
    int32x2_t v38 = vdup_lane_s32(*(int32x2_t *)&v53, 0);
    double v35 = COERCE_DOUBLE(vdup_lane_s32(*(int32x2_t *)&v35, 0));
  }
  double v39 = *(float *)v56.f64;
  double v40 = a3;
  float v41 = *(float *)&v36.i32[1];
  float v42 = fminf(*(float *)v36.i32, *(float *)v37.i32);
  float v43 = fmaxf(*(float *)&v36.i32[1], *(float *)&v37.i32[1]);
  if (*(float *)v56.f64 + -0.5 < a3) {
    float v41 = v43;
  }
  else {
    float v42 = *(float *)v36.i32;
  }
  double v44 = v39 + 1.5;
  double v45 = v39 + 0.5;
  float v46 = fminf(v42, *(float *)v38.i32);
  BOOL v47 = v45 < v40;
  if (v45 >= v40) {
    *(float *)&double v48 = v42;
  }
  else {
    *(float *)&double v48 = v46;
  }
  float v49 = fminf(*(float *)&v48, *(float *)&v35);
  float v50 = fmaxf(v41, *(float *)&v38.i32[1]);
  if (v47) {
    float v41 = v50;
  }
  if (v44 < v40) {
    *(float *)&double v48 = v49;
  }
  float v51 = fmaxf(v41, *((float *)&v35 + 1));
  if (v44 >= v40) {
    float v51 = v41;
  }
  *((float *)&v48 + 1) = v51;
  return v48;
}

double cikernel::_vertMinMaxRed4(cikernel *this, SamplerObj *a2, float a3, float a4)
{
  *(float32x2_t *)&v7.f64[0] = vmul_f32(*(float32x2_t *)CI::getDC(this), (float32x2_t)0x408000003F800000);
  float64x2_t v56 = v7;
  float32x2_t v8 = vadd_f32(*(float32x2_t *)&v7.f64[0], (float32x2_t)0xBFC0000000000000);
  *(float *)&double v9 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v8, 1), *((float *)this + 4), v8.f32[0]);
  LODWORD(v10) = *((_DWORD *)this + 7);
  v11.i32[0] = *((_DWORD *)this + 9);
  *(float *)v12.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v8, 1), *(float *)&v10, v8.f32[0]);
  v8.f32[0] = *((float *)this + 6) + *(float *)&v9;
  *(float *)v7.f64 = *(float *)v11.i32 + *(float *)v12.i32;
  v8.f32[1] = *(float *)v11.i32 + *(float *)v12.i32;
  double v55 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v8, v7, v9, v10, v12, v11, v13);
  float64x2_t v14 = v56;
  float32x2_t v15 = vadd_f32(*(float32x2_t *)&v56.f64[0], (float32x2_t)0xBF00000000000000);
  *(float *)&double v16 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v15, 1), *((float *)this + 4), v15.f32[0]);
  LODWORD(v17) = *((_DWORD *)this + 7);
  v18.i32[0] = *((_DWORD *)this + 9);
  *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v15, 1), *(float *)&v17, v15.f32[0]);
  v15.f32[0] = *((float *)this + 6) + *(float *)&v16;
  *(float *)v14.f64 = *(float *)v18.i32 + *(float *)v19.i32;
  v15.f32[1] = *(float *)v18.i32 + *(float *)v19.i32;
  double v54 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v15, v14, v16, v17, v19, v18, v20);
  float64x2_t v21 = v56;
  float32x2_t v22 = vadd_f32(*(float32x2_t *)&v56.f64[0], (float32x2_t)0x3F00000000000000);
  *(float *)&double v23 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v22, 1), *((float *)this + 4), v22.f32[0]);
  LODWORD(v24) = *((_DWORD *)this + 7);
  v25.i32[0] = *((_DWORD *)this + 9);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v22, 1), *(float *)&v24, v22.f32[0]);
  v22.f32[0] = *((float *)this + 6) + *(float *)&v23;
  *(float *)v21.f64 = *(float *)v25.i32 + *(float *)v26.i32;
  v22.f32[1] = *(float *)v25.i32 + *(float *)v26.i32;
  double v53 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v22, v21, v23, v24, v26, v25, v27);
  float64x2_t v28 = v56;
  float32x2_t v29 = vadd_f32(*(float32x2_t *)&v56.f64[0], (float32x2_t)0x3FC0000000000000);
  *(float *)&double v30 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v29, 1), *((float *)this + 4), v29.f32[0]);
  LODWORD(v31) = *((_DWORD *)this + 7);
  v32.i32[0] = *((_DWORD *)this + 9);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v29, 1), *(float *)&v31, v29.f32[0]);
  v29.f32[0] = *((float *)this + 6) + *(float *)&v30;
  *(float *)v28.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v29.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  double v35 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v29, v28, v30, v31, v33, v32, v34);
  if (a4 >= 0.9)
  {
    int32x2_t v37 = *(int32x2_t *)&v54;
    int32x2_t v36 = *(int32x2_t *)&v55;
    int32x2_t v38 = *(int32x2_t *)&v53;
  }
  else
  {
    int32x2_t v36 = vdup_lane_s32(*(int32x2_t *)&v55, 0);
    int32x2_t v37 = vdup_lane_s32(*(int32x2_t *)&v54, 0);
    int32x2_t v38 = vdup_lane_s32(*(int32x2_t *)&v53, 0);
    double v35 = COERCE_DOUBLE(vdup_lane_s32(*(int32x2_t *)&v35, 0));
  }
  double v39 = *((float *)v56.f64 + 1);
  double v40 = a3;
  float v41 = *(float *)&v36.i32[1];
  float v42 = fminf(*(float *)v36.i32, *(float *)v37.i32);
  float v43 = fmaxf(*(float *)&v36.i32[1], *(float *)&v37.i32[1]);
  if (*((float *)v56.f64 + 1) + -0.5 < a3) {
    float v41 = v43;
  }
  else {
    float v42 = *(float *)v36.i32;
  }
  double v44 = v39 + 1.5;
  double v45 = v39 + 0.5;
  float v46 = fminf(v42, *(float *)v38.i32);
  BOOL v47 = v45 < v40;
  if (v45 >= v40) {
    *(float *)&double v48 = v42;
  }
  else {
    *(float *)&double v48 = v46;
  }
  float v49 = fminf(*(float *)&v48, *(float *)&v35);
  float v50 = fmaxf(v41, *(float *)&v38.i32[1]);
  if (v47) {
    float v41 = v50;
  }
  if (v44 < v40) {
    *(float *)&double v48 = v49;
  }
  float v51 = fmaxf(v41, *((float *)&v35 + 1));
  if (v44 >= v40) {
    float v51 = v41;
  }
  *((float *)&v48 + 1) = v51;
  return v48;
}

float64_t cikernel::_redThreshold(float64x2_t a1, float64x2_t a2)
{
  a1.f64[0] = *(float *)a1.f64;
  a2.f64[0] = 0.00001;
  *(void *)&a1.f64[0] = vbslq_s8((int8x16_t)vdupq_lane_s64(vcgtq_f64(a1, a2).i64[0], 0), (int8x16_t)xmmword_19394C820, (int8x16_t)xmmword_19394C7E0).u64[0];
  return a1.f64[0];
}

uint64_t cikernel::_maskBoundsInit(CI *a1, float a2)
{
  uint64_t result = CI::getDC(a1);
  if (a2 > 0.00001)
  {
    __asm
    {
      FMOV            V1.2S, #1.0
      FMOV            V2.2S, #0.25
    }
  }
  return result;
}

void cikernel::_maskBoundsReduce(cikernel *this, SamplerObj *a2)
{
  DC = (float32x2_t *)CI::getDC(this);
  float32x2_t v4 = vadd_f32(*DC, *DC);
  float32x2_t v5 = vadd_f32(v4, (float32x2_t)0x3F0000003F000000);
  *(float *)&double v6 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v5, 1), *((float *)this + 4), v5.f32[0]);
  LODWORD(v7) = *((_DWORD *)this + 7);
  v8.i32[0] = *((_DWORD *)this + 9);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *((float *)this + 6) + *(float *)&v6;
  *(float *)v10.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v5, v10, v6, v7, v9, v8, v11);
  int8x16_t v36 = v12;
  *(float32x2_t *)v12.i8 = vadd_f32(v4, (float32x2_t)0xBF0000003F000000);
  *(float *)&double v13 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v12.i8, 1), *((float *)this + 4), *(float *)v12.i32);
  LODWORD(v14) = *((_DWORD *)this + 7);
  v15.i32[0] = *((_DWORD *)this + 9);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v12.i8, 1), *(float *)&v14, *(float *)v12.i32);
  *(float *)v12.i32 = *((float *)this + 6) + *(float *)&v13;
  *(float *)v17.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  *(float *)&v12.i32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v12.i64, v17, v13, v14, v16, v15, v18);
  if (*(float *)&v19.i32[2] > 0.0)
  {
    v21.i32[1] = v36.i32[1];
    if (*(float *)&v36.i32[2] <= 0.0)
    {
      int8x16_t v36 = v19;
    }
    else
    {
      float64x2_t v20 = (float64x2_t)vextq_s8(v36, v36, 8uLL);
      *(float32x2_t *)v21.i8 = vminnm_f32(*(float32x2_t *)v19.i8, *(float32x2_t *)v36.i8);
      v21.u64[1] = (unint64_t)vmaxnm_f32((float32x2_t)*(_OWORD *)&vextq_s8(v19, v19, 8uLL), *(float32x2_t *)&v20.f64[0]);
      int8x16_t v36 = v21;
    }
  }
  float32x2_t v26 = vadd_f32(v4, (float32x2_t)0x3F000000BF000000);
  *(float *)v21.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v26, 1), *((float *)this + 4), v26.f32[0]);
  LODWORD(v22) = *((_DWORD *)this + 7);
  v24.i32[0] = *((_DWORD *)this + 9);
  *(float *)v23.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v26, 1), *(float *)&v22, v26.f32[0]);
  v26.f32[0] = *((float *)this + 6) + *(float *)v21.i32;
  *(float *)v20.f64 = *(float *)v24.i32 + *(float *)v23.i32;
  v26.f32[1] = *(float *)v24.i32 + *(float *)v23.i32;
  double v27 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v26, v20, *(double *)v21.i64, v22, v23, v24, v25);
  if (v34 > 0.0)
  {
    HIDWORD(v29) = v36.i32[1];
    if (*(float *)&v36.i32[2] > 0.0)
    {
      float64x2_t v28 = (float64x2_t)vextq_s8(v36, v36, 8uLL);
      double v29 = COERCE_DOUBLE(vminnm_f32(*(float32x2_t *)&v27, *(float32x2_t *)v36.i8));
    }
  }
  float32x2_t v35 = vadd_f32(v4, (float32x2_t)0xBF000000BF000000);
  *(float *)&double v29 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v35, 1), *((float *)this + 4), v35.f32[0]);
  LODWORD(v30) = *((_DWORD *)this + 7);
  v32.i32[0] = *((_DWORD *)this + 9);
  *(float *)v31.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v35, 1), *(float *)&v30, v35.f32[0]);
  v35.f32[0] = *((float *)this + 6) + *(float *)&v29;
  *(float *)v28.f64 = *(float *)v32.i32 + *(float *)v31.i32;
  v35.f32[1] = *(float *)v32.i32 + *(float *)v31.i32;
  CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v35, v28, v29, v30, v31, v32, v33);
}

double cikernel::_minMaxNormalize(float32x4_t a1, float32x4_t a2, float32x4_t a3)
{
  float32x4_t v3 = vsubq_f32(a1, a2);
  float32x4_t v4 = vsubq_f32(a3, a2);
  v4.i32[3] = 0;
  *(void *)&double result = vdivq_f32(v3, vmaxnmq_f32(v4, (float32x4_t)xmmword_1939508B0)).u64[0];
  return result;
}

float cikernel::_minMaxRedNormalize(float32x4_t a1, float32x4_t a2)
{
  return vsubq_f32(a1, a2).f32[0]
       / fmaxf(vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.f32, 1), a2).f32[0], 0.00001);
}

double cikernel::_KM_select(cikernel *this, SamplerObj *a2, SamplerObj *a3, float a4, float a5)
{
  DC = (float32x2_t *)CI::getDC(this);
  *(float *)&double v10 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *DC, 1), *((float *)this + 4), COERCE_FLOAT(*DC));
  LODWORD(v11) = *((_DWORD *)this + 7);
  v12.i32[0] = *((_DWORD *)this + 9);
  *(float *)v13.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *DC, 1), *(float *)&v11, COERCE_FLOAT(*DC));
  *(float *)&double v14 = *((float *)this + 6) + *(float *)&v10;
  *(float *)v15.f64 = *(float *)v12.i32 + *(float *)v13.i32;
  *((float *)&v14 + 1) = *(float *)v12.i32 + *(float *)v13.i32;
  *(double *)v17.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v14, v15, v10, v11, v13, v12, v16);
  float32x4_t v41 = v17;
  LODWORD(v18) = *((_DWORD *)a2 + 6);
  v19.i32[0] = *((_DWORD *)a2 + 9);
  *(float *)v20.i32 = *((float *)a2 + 8) * 0.5;
  *(float *)&double v21 = *(float *)v20.i32 + (float)((float)(a5 + 0.5) * *((float *)a2 + 7));
  v17.f32[0] = *(float *)&v18
             + (float)((float)(*((float *)a2 + 5) * 0.5) + (float)((float)(a5 + 0.5) * *((float *)a2 + 4)));
  *(float *)v22.f64 = *(float *)v19.i32 + *(float *)&v21;
  v17.f32[1] = *(float *)v19.i32 + *(float *)&v21;
  *(double *)v24.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a2 + 1), *(double *)v17.i64, v22, v18, v21, v20, v19, v23);
  if ((int)a4 < 1) {
    return *(double *)v41.i64;
  }
  int v29 = 0;
  double v30 = *(double *)v41.i64;
  float32x4_t v31 = vsubq_f32(v41, v24);
  float32x4_t v32 = vmulq_f32(v31, v31);
  float32x4_t v33 = vaddq_f32(v32, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v32.f32, 1));
  float32x4_t v40 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v32, 2), v33);
  while (1)
  {
    if ((int)a5 != v29)
    {
      float v34 = (float)v29 + 0.5;
      LODWORD(v30) = *((_DWORD *)a2 + 6);
      v27.i32[0] = *((_DWORD *)a2 + 9);
      *(float *)v26.i32 = *((float *)a2 + 8) * 0.5;
      *(float *)&double v25 = *(float *)v26.i32 + (float)(v34 * *((float *)a2 + 7));
      *(float *)&double v35 = *(float *)&v30 + (float)((float)(*((float *)a2 + 5) * 0.5) + (float)(v34 * *((float *)a2 + 4)));
      v33.f32[0] = *(float *)v27.i32 + *(float *)&v25;
      *((float *)&v35 + 1) = *(float *)v27.i32 + *(float *)&v25;
      *(double *)v36.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a2 + 1), v35, (float64x2_t)v33, v30, v25, v26, v27, v28);
      double v30 = *(double *)v41.i64;
      float32x4_t v37 = vsubq_f32(v41, v36);
      float32x4_t v38 = vmulq_f32(v37, v37);
      float32x4_t v33 = v40;
      if ((vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vcgtq_f32(v40, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v38, 2), vaddq_f32(v38, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v38.f32, 1)))))).u8[0] & 1) == 0)break; {
    }
      }
    if ((int)a4 == ++v29) {
      return v30;
    }
  }
  return 0.0;
}

void cikernel::_KM_defuse(cikernel *this, SamplerObj *a2, SamplerObj *a3, float a4, float a5)
{
  DC = (float32x2_t *)CI::getDC(this);
  *(float32x2_t *)v10.i8 = *DC;
  int8x16_t v38 = v10;
  LODWORD(v11) = *((_DWORD *)this + 7);
  *(float *)&double v12 = *((float *)this + 6)
                 + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *DC, 1), *((float *)this + 4), COERCE_FLOAT(*DC));
  LODWORD(v13) = *((_DWORD *)this + 9);
  *(float *)v14.f64 = *(float *)&v13
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *DC, 1), *(float *)&v11, COERCE_FLOAT(*DC));
  HIDWORD(v12) = LODWORD(v14.f64[0]);
  *(double *)v17.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v12, v14, v11, v13, v10, v15, v16);
  float32x4_t v34 = v17;
  LODWORD(v18) = *((_DWORD *)a2 + 7);
  v17.f32[0] = *((float *)a2 + 6)
             + vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 5), *(float32x2_t *)v38.i8, 1), *((float *)a2 + 4), *(float *)v38.i32);
  LODWORD(v19) = *((_DWORD *)a2 + 9);
  *(float *)v20.f64 = *(float *)&v19
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 8), *(float32x2_t *)v38.i8, 1), *(float *)&v18, *(float *)v38.i32);
  v17.i32[1] = LODWORD(v20.f64[0]);
  CI::BitmapSampler::read(*((uint64x2_t **)a2 + 1), *(double *)v17.i64, v20, v18, v19, v38, v21, v22);
  v28.f64[0] = -0.5;
  int v29 = (int)(*(float *)v38.i32 + -0.5) + 1;
  do
  {
    if (v29 >= (int)a4) {
      break;
    }
    float v30 = (float)v29 + 0.5;
    LODWORD(v23) = *((_DWORD *)this + 6);
    v26.i32[0] = *((_DWORD *)this + 9);
    v25.f32[0] = *((float *)this + 8) * 0.5;
    v24.f32[0] = v25.f32[0] + (float)(v30 * *((float *)this + 7));
    *(float *)&double v31 = *(float *)&v23 + (float)((float)(*((float *)this + 5) * 0.5) + (float)(v30 * *((float *)this + 4)));
    *(float *)v28.f64 = *(float *)v26.i32 + v24.f32[0];
    *((float *)&v31 + 1) = *(float *)v26.i32 + v24.f32[0];
    *(double *)v32.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v31, v28, v23, *(double *)v24.i64, (int8x16_t)v25, v26, v27);
    int8x16_t v26 = (int8x16_t)v34;
    float64x2_t v28 = (float64x2_t)v34;
    HIDWORD(v28.f64[1]) = v35;
    HIDWORD(v23) = v32.i32[1];
    float32x4_t v24 = vsubq_f32(v34, v32);
    float32x4_t v25 = v24;
    v25.i32[3] = v36;
    v26.i32[3] = v38.i32[3];
    v24.i32[3] = v37;
    float32x4_t v33 = vmulq_f32(v25, v24);
    int8x16_t v27 = (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v33, 2), vaddq_f32(v33, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v33.f32, 1)));
    ++v29;
  }
  while (*(float *)v27.i32 >= a5);
}

double cikernel::_ACWeightedCoordinatesR(CI *a1, float a2, int8x16_t a3)
{
  *(float32x2_t *)v3.f32 = vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), vsub_f32(*(float32x2_t *)CI::getDC(a1), *(float32x2_t *)a3.i8));
  __asm { FMOV            V1.2S, #1.0 }
  v3.i64[1] = _D1;
  *(void *)&double result = vmulq_n_f32(v3, a2).u64[0];
  return result;
}

float32x2_t cikernel::_ACCentroid(__n128 a1, int8x16_t a2, double a3)
{
  *(float *)&a3 = fmaxf(a1.n128_f32[2], 0.0001);
  return vadd_f32(*(float32x2_t *)a2.i8, vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a2, a2, 8uLL), vdiv_f32((float32x2_t)a1.n128_u64[0], (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a3, 0))));
}

double cikernel::_RCFalloffGaussian(CI *a1, float32x4_t a2, float32x2_t a3, float a4)
{
  float32x2_t v5 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a3);
  *(void *)&double result = vmulq_n_f32(a2, expf(-(float)(vaddv_f32(vmul_f32(v5, v5)) * a4))).u64[0];
  return result;
}

double cikernel::_RCFalloffDisk(CI *a1, float32x4_t a2, float32x2_t a3, float a4)
{
  float32x2_t v5 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a3);
  BOOL v6 = vaddv_f32(vmul_f32(v5, v5)) < a4;
  float v7 = 0.0;
  if (v6) {
    float v7 = 1.0;
  }
  *(void *)&double result = vmulq_n_f32(a2, v7).u64[0];
  return result;
}

void CI::f4_f2(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  double v11 = (double (*)(void *, double))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 32)), a2);
  }
  float64x2_t v14 = (double *)(a3 + 16 * v13);
  if (v12 != 5) {
    float64x2_t v14 = (double *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v15 = v11(a1, *v14);
  *(_OWORD *)(a3 + 16 * a7) = v15;
}

double cikernel::_RCSelectGreaterThan(int8x16_t a1, int8x16_t a2, int32x2_t a3, float32x4_t a4)
{
  *(void *)&double result = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32((float32x4_t)vdupq_lane_s32(a3, 1), a4), 0), a1, a2).u64[0];
  return result;
}

double cikernel::_PSDrawSpread(CI *a1, float32x2_t a2, double a3)
{
  *(double *)v11.i64 = a3;
  float32x2_t v3 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  *(float32x2_t *)v4.f32 = vmul_f32(v3, v3);
  v4.f32[0] = vaddv_f32(*(float32x2_t *)v4.f32);
  __asm { FMOV            V1.4S, #1.0 }
  *(void *)&double result = vandq_s8(_Q1, (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgeq_f32(v11, v4), 0)).u64[0];
  return result;
}

double cikernel::_PC_coord(cikernel *this, SamplerObj *a2, SamplerObj *a3, float a4, float a5)
{
  DC = (float32x2_t *)CI::getDC(this);
  *(float *)&double v10 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *DC, 1), *((float *)this + 4), COERCE_FLOAT(*DC));
  LODWORD(v11) = *((_DWORD *)this + 7);
  v12.i32[0] = *((_DWORD *)this + 9);
  *(float *)v13.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *DC, 1), *(float *)&v11, COERCE_FLOAT(*DC));
  *(float *)&double v14 = *((float *)this + 6) + *(float *)&v10;
  *(float *)v15.f64 = *(float *)v12.i32 + *(float *)v13.i32;
  *((float *)&v14 + 1) = *(float *)v12.i32 + *(float *)v13.i32;
  *(double *)v17.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v14, v15, v10, v11, v13, v12, v16);
  float32x4_t v42 = v17;
  LODWORD(v18) = *((_DWORD *)a2 + 6);
  v19.i32[0] = *((_DWORD *)a2 + 9);
  *(float *)v20.i32 = *((float *)a2 + 8) * 0.5;
  *(float *)&double v21 = *(float *)v20.i32 + (float)((float)(a5 + 0.5) * *((float *)a2 + 7));
  v17.f32[0] = *(float *)&v18
             + (float)((float)(*((float *)a2 + 5) * 0.5) + (float)((float)(a5 + 0.5) * *((float *)a2 + 4)));
  *(float *)v22.f64 = *(float *)v19.i32 + *(float *)&v21;
  v17.f32[1] = *(float *)v19.i32 + *(float *)&v21;
  *(double *)v24.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a2 + 1), *(double *)v17.i64, v22, v18, v21, v20, v19, v23);
  uint64_t v28 = 1065353216;
  if ((int)a4 >= 1)
  {
    int v29 = 0;
    HIDWORD(v30) = v42.i32[1];
    float32x4_t v31 = vsubq_f32(v42, v24);
    float32x4_t v32 = vmulq_f32(v31, v31);
    float32x4_t v33 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v32.f32, 1);
    float32x4_t v34 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v32, 2);
    float32x4_t v41 = vaddq_f32(v34, vaddq_f32(v32, v33));
    while (1)
    {
      if ((int)a5 != v29)
      {
        float v35 = (float)v29 + 0.5;
        v34.i32[0] = *((_DWORD *)a2 + 6);
        v26.i32[0] = *((_DWORD *)a2 + 9);
        *(float *)v25.i32 = *((float *)a2 + 8) * 0.5;
        *(float *)&double v30 = *(float *)v25.i32 + (float)(v35 * *((float *)a2 + 7));
        *(float *)&double v36 = v34.f32[0] + (float)((float)(*((float *)a2 + 5) * 0.5) + (float)(v35 * *((float *)a2 + 4)));
        v33.f32[0] = *(float *)v26.i32 + *(float *)&v30;
        *((float *)&v36 + 1) = *(float *)v26.i32 + *(float *)&v30;
        *(double *)v37.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a2 + 1), v36, (float64x2_t)v33, *(double *)v34.i64, v30, v25, v26, v27);
        HIDWORD(v30) = v42.i32[1];
        float32x4_t v38 = vsubq_f32(v42, v37);
        float32x4_t v39 = vmulq_f32(v38, v38);
        float32x4_t v33 = v41;
        if ((vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vcgtq_f32(v41, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v39, 2), vaddq_f32(v39, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.f32, 1)))))).u8[0] & 1) == 0)break; {
      }
        }
      if ((int)a4 == ++v29)
      {
        uint64_t v28 = 1065353216;
        return *(double *)&v28;
      }
    }
    *(double *)&uint64_t v28 = 0.0;
  }
  return *(double *)&v28;
}

void sub_1938468C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__16(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 48);
  long long v3 = *(_OWORD *)(a2 + 64);
  *(__n128 *)(a1 + 48) = result;
  *(_OWORD *)(a1 + 64) = v3;
  return result;
}

double affine::inverse@<D0>(affine *this@<X0>, double *a2@<X8>)
{
  double v3 = *(double *)this;
  double v4 = *((double *)this + 1);
  double v5 = *((double *)this + 2);
  double v6 = *((double *)this + 3);
  double v7 = *(double *)this * v6 - v4 * v5;
  if (fabs(v7) >= 1.0e-10)
  {
    double v9 = 1.0 / v7;
    *a2 = v6 * v9;
    a2[1] = v9 * -v4;
    double result = v3 * v9;
    a2[2] = -(v5 * v9);
    a2[3] = result;
  }
  else
  {
    printf("singular matrix cannot be inverted");
    double result = 0.0;
    *(_OWORD *)a2 = 0u;
    *((_OWORD *)a2 + 1) = 0u;
  }
  return result;
}

void roiForPoints(double a1, double a2, double a3, double a4)
{
  CGFloat v4 = fminf(fminf(fminf(*(float *)&a1, *(float *)&a2), *(float *)&a3), *(float *)&a4);
  float v5 = fmaxf(fmaxf(fmaxf(*(float *)&a1, *(float *)&a2), *(float *)&a3), *(float *)&a4);
  float v6 = *((float *)&a2 + 1);
  v8.origin.CGFloat y = fminf(fminf(fminf(*((float *)&a1 + 1), *((float *)&a2 + 1)), *((float *)&a3 + 1)), *((float *)&a4 + 1));
  float v7 = fmaxf(fmaxf(fmaxf(*((float *)&a1 + 1), v6), *((float *)&a3 + 1)), *((float *)&a4 + 1));
  v8.size.CGFloat width = v5 - v4;
  v8.size.CGFloat height = v7 - v8.origin.y;
  v8.origin.CGFloat x = v4;
  CGRect v9 = CGRectInset(v8, -0.0001, -0.0001);
  CGRect v10 = CGRectIntegral(v9);
  if (v10.size.height < 1.5) {
    CGRect v10 = CGRectInset(v10, 0.0, -1.0);
  }
  if (v10.size.width < 1.5) {
    CGRectInset(v10, 0.0, -1.0);
  }
}

void roiForPoints(double a1, double a2, double a3)
{
  CGFloat v3 = fminf(fminf(*(float *)&a1, *(float *)&a2), *(float *)&a3);
  float v4 = fmaxf(fmaxf(*(float *)&a1, *(float *)&a2), *(float *)&a3);
  float v5 = *((float *)&a2 + 1);
  v7.origin.CGFloat y = fminf(fminf(*((float *)&a1 + 1), *((float *)&a2 + 1)), *((float *)&a3 + 1));
  float v6 = fmaxf(fmaxf(*((float *)&a1 + 1), v5), *((float *)&a3 + 1));
  v7.size.CGFloat width = v4 - v3;
  v7.size.CGFloat height = v6 - v7.origin.y;
  v7.origin.CGFloat x = v3;
  CGRect v8 = CGRectInset(v7, -0.0001, -0.0001);
  CGRect v9 = CGRectIntegral(v8);
  if (v9.size.height < 1.5) {
    CGRect v9 = CGRectInset(v9, 0.0, -1.0);
  }
  if (v9.size.width < 1.5) {
    CGRectInset(v9, 0.0, -1.0);
  }
}

float32x2_t cikernel::_fourfoldRotatedTile(CI *a1, float32x2_t a2, int8x16_t a3, int8x16_t a4)
{
  float32x2_t v5 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  int32x2_t v6 = (int32x2_t)vmul_f32(*(float32x2_t *)a3.i8, v5);
  int32x2_t v7 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v5);
  float32x2_t v8 = vadd_f32((float32x2_t)vzip1_s32(v6, v7), (float32x2_t)vzip2_s32(v6, v7));
  float32x2_t v9 = vrndm_f32(v8);
  float32x2_t v10 = vmul_f32(v9, (float32x2_t)0x3F0000003F000000);
  float32x2_t v11 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
  float32x2_t v12 = vminnm_f32(vsub_f32(v10, vrndm_f32(v10)), v11);
  float32x2_t v13 = vadd_f32(v12, v12);
  float32x2_t v14 = vminnm_f32(vsub_f32(v8, v9), v11);
  __asm { FMOV            V1.2S, #1.0 }
  float32x2_t v20 = vsub_f32(_D1, v14);
  float32x2_t v21 = vmla_lane_f32(vmul_n_f32(vmla_n_f32(vmul_n_f32(v14, 1.0 - v13.f32[0]), (float32x2_t)vext_s8((int8x8_t)v14, (int8x8_t)v20, 4uLL), v13.f32[0]), 1.0 - v13.f32[1]), vmla_n_f32(vmul_n_f32((float32x2_t)vext_s8((int8x8_t)v20, (int8x8_t)v14, 4uLL), 1.0 - v13.f32[0]), v20, v13.f32[0]), v13, 1);
  int32x2_t v22 = (int32x2_t)vmul_f32(*(float32x2_t *)a4.i8, v21);
  int32x2_t v23 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v21);
  return vadd_f32(a2, vadd_f32((float32x2_t)vzip1_s32(v22, v23), (float32x2_t)vzip2_s32(v22, v23)));
}

float32x2_t cikernel::_sixfoldRotatedTile(CI *a1, float32x2_t a2, int8x16_t a3, int8x16_t a4)
{
  float32x2_t v5 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  int32x2_t v6 = (int32x2_t)vmul_f32(*(float32x2_t *)a3.i8, v5);
  int32x2_t v7 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v5);
  float32x2_t v8 = (float32x2_t)vzip1_s32(v6, v7);
  float32x2_t v9 = vadd_f32(v8, (float32x2_t)vzip2_s32(v6, v7));
  float32x2_t v10 = vminnm_f32(vsub_f32(v9, vrndm_f32(v9)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu));
  *(float *)v6.i32 = 1.0 - v10.f32[1];
  v8.f32[0] = vaddv_f32(v10) + -1.0;
  v6.i32[1] = v8.i32[0];
  int32x2_t v11 = (int32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32(vcgt_f32(0, v8), 0), (int8x8_t)v10, (int8x8_t)v6);
  v12.i32[0] = vdup_lane_s32(v11, 1).u32[0];
  *(float *)&__int32 v13 = 1.0 - *(float *)v11.i32 - *(float *)&v11.i32[1];
  v12.i32[1] = v13;
  int32x2_t v14 = (int32x2_t)vbsl_s8((int8x8_t)vcgtd_f64(0.0, *(float *)v11.i32 * -2.0 + 1.0 - *(float *)&v11.i32[1]), v12, (int8x8_t)v11);
  double v15 = 1.0 - *(float *)v14.i32 - *(float *)&v14.i32[1];
  *(float *)&double v15 = v15;
  int32x2_t v16 = (int32x2_t)vbsl_s8((int8x8_t)vcgtd_f64(0.0, *(float *)&v14.i32[1] * -2.0 + 1.0 - *(float *)v14.i32), (int8x8_t)vzip1_s32(*(int32x2_t *)&v15, v14), (int8x8_t)v14);
  *(float *)&__int32 v17 = 1.0 - *(float *)v16.i32 - *(float *)&v16.i32[1];
  v18.i32[0] = vdup_lane_s32(v16, 1).u32[0];
  v18.i32[1] = v17;
  float32x2_t v19 = (float32x2_t)vbsl_s8((int8x8_t)vcgtd_f64(0.0, *(float *)v16.i32 * -2.0 + 1.0 - *(float *)&v16.i32[1]), v18, (int8x8_t)v16);
  int32x2_t v20 = (int32x2_t)vmul_f32(*(float32x2_t *)a4.i8, v19);
  int32x2_t v21 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v19);
  return vadd_f32(a2, vadd_f32((float32x2_t)vzip1_s32(v20, v21), (float32x2_t)vzip2_s32(v20, v21)));
}

float32x2_t cikernel::_twelvefoldReflectedTile(CI *a1, float32x2_t a2, int8x16_t a3, int8x16_t a4)
{
  float32x2_t v5 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  int32x2_t v7 = (int32x2_t)vmul_f32(*(float32x2_t *)a3.i8, v5);
  int32x2_t v8 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v5);
  float32x2_t v9 = vadd_f32((float32x2_t)vzip1_s32(v7, v8), (float32x2_t)vzip2_s32(v7, v8));
  int32x2_t v10 = (int32x2_t)vminnm_f32(vsub_f32(v9, vrndm_f32(v9)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu));
  if (vsub_f32((float32x2_t)v10, (float32x2_t)vdup_lane_s32(v10, 1)).f32[0] >= 0.0) {
    *(float *)v6.i32 = 0.0;
  }
  else {
    *(float *)v6.i32 = 1.0;
  }
  __asm { FMOV            V6.2S, #1.0 }
  float32x2_t v16 = vmla_n_f32(vmul_f32((float32x2_t)vrev64_s32(v10), vsub_f32(_D6, (float32x2_t)vdup_lane_s32(v6, 0))), (float32x2_t)v10, *(float *)v6.i32);
  double v17 = 1.0 - v16.f32[0] - v16.f32[1];
  *(float *)&double v17 = v17;
  float32x2_t v18 = (float32x2_t)vrev64_s32((int32x2_t)vsub_f32(_D6, v16));
  if (*(float *)&v17 >= 0.0) {
    *(float *)&double v17 = 0.0;
  }
  else {
    *(float *)&double v17 = 1.0;
  }
  float32x2_t v19 = vmla_n_f32(vmul_f32(v16, vsub_f32(_D6, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v17, 0))), v18, *(float *)&v17);
  double v20 = v19.f32[1];
  float v21 = v19.f32[0] * -2.0 + 1.0 - v19.f32[1];
  *(float *)&double v17 = 1.0 - v19.f32[0] - v19.f32[1];
  if (v21 >= 0.0) {
    *(float *)&double v17 = v19.f32[0];
  }
  float v22 = *(float *)&v17 * -0.5 + 0.5 - v20;
  float v23 = 1.0 - *(float *)&v17 - v20;
  if (v22 >= 0.0) {
    float v23 = v19.f32[1];
  }
  *((float *)&v17 + 1) = v23;
  int32x2_t v24 = (int32x2_t)vmul_f32(*(float32x2_t *)a4.i8, *(float32x2_t *)&v17);
  int32x2_t v25 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), *(float32x2_t *)&v17);
  return vadd_f32(a2, vadd_f32((float32x2_t)vzip1_s32(v24, v25), (float32x2_t)vzip2_s32(v24, v25)));
}

float32x2_t cikernel::_fourfoldTranslatedTile(CI *a1, float32x2_t a2, int8x16_t a3, int8x16_t a4)
{
  float32x2_t v5 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  int32x2_t v6 = (int32x2_t)vmul_f32(*(float32x2_t *)a3.i8, v5);
  int32x2_t v7 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v5);
  float32x2_t v8 = vadd_f32((float32x2_t)vzip1_s32(v6, v7), (float32x2_t)vzip2_s32(v6, v7));
  float32x2_t v9 = vminnm_f32(vsub_f32(v8, vrndm_f32(v8)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu));
  int32x2_t v10 = (int32x2_t)vmul_f32(*(float32x2_t *)a4.i8, v9);
  int32x2_t v11 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v9);
  return vadd_f32(a2, vadd_f32((float32x2_t)vzip1_s32(v10, v11), (float32x2_t)vzip2_s32(v10, v11)));
}

float32x2_t cikernel::_glideReflectedTile(CI *a1, float32x2_t a2, int8x16_t a3, int8x16_t a4)
{
  float32x2_t v5 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  int32x2_t v6 = (int32x2_t)vmul_f32(*(float32x2_t *)a3.i8, v5);
  int32x2_t v7 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v5);
  float32x2_t v8 = vadd_f32((float32x2_t)vzip1_s32(v6, v7), (float32x2_t)vzip2_s32(v6, v7));
  float32x2_t v9 = vrndm_f32(v8);
  float32x2_t v10 = vmul_f32(v9, (float32x2_t)0x3F0000003F000000);
  float32x2_t v11 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
  float32x2_t v12 = vminnm_f32(vsub_f32(v10, vrndm_f32(v10)), v11);
  float32x2_t v13 = vadd_f32(v12, v12);
  float32x2_t v14 = vminnm_f32(vsub_f32(v8, v9), v11);
  __asm { FMOV            V1.2S, #1.0 }
  v11.i32[0] = vsub_f32(_D1, v14).u32[0];
  v11.i32[1] = vadd_f32(v14, _D1).i32[1];
  float32x2_t v20 = (float32x2_t)__PAIR64__(v14.u32[1], v11.u32[0]);
  float32x2_t v21 = vmul_n_f32(v14, 1.0 - v13.f32[0]);
  v14.i32[1] = v11.i32[1];
  float32x2_t v22 = vmla_lane_f32(vmul_n_f32(vmla_n_f32(v21, v11, v13.f32[0]), 1.0 - v13.f32[1]), vmla_n_f32(vmul_n_f32(v14, 1.0 - v13.f32[0]), v20, v13.f32[0]), v13, 1);
  int32x2_t v23 = (int32x2_t)vmul_f32(*(float32x2_t *)a4.i8, v22);
  int32x2_t v24 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v22);
  return vadd_f32(a2, vadd_f32((float32x2_t)vzip1_s32(v23, v24), (float32x2_t)vzip2_s32(v23, v24)));
}

float32x2_t cikernel::_eightfoldReflectedTile(CI *a1, float32x2_t a2, int8x16_t a3, int8x16_t a4)
{
  float32x2_t v5 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  int32x2_t v6 = (int32x2_t)vmul_f32(*(float32x2_t *)a3.i8, v5);
  int32x2_t v7 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v5);
  float32x2_t v8 = vadd_f32((float32x2_t)vzip1_s32(v6, v7), (float32x2_t)vzip2_s32(v6, v7));
  float32x2_t v9 = vminnm_f32(vsub_f32(v8, vrndm_f32(v8)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu));
  __asm { FMOV            V1.2S, #1.0 }
  int32x2_t v15 = (int32x2_t)vminnm_f32(v9, vsub_f32(_D1, v9));
  int32x2_t v16 = 0;
  if (vsub_f32((float32x2_t)vdup_lane_s32(v15, 1), (float32x2_t)v15).f32[0] < 0.0) {
    *(float *)v16.i32 = 1.0;
  }
  float32x2_t v17 = vmla_n_f32(vmul_f32((float32x2_t)vrev64_s32(v15), vsub_f32(_D1, (float32x2_t)vdup_lane_s32(v16, 0))), (float32x2_t)v15, *(float *)v16.i32);
  int32x2_t v18 = (int32x2_t)vmul_f32(*(float32x2_t *)a4.i8, v17);
  int32x2_t v19 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v17);
  return vadd_f32(a2, vadd_f32((float32x2_t)vzip1_s32(v18, v19), (float32x2_t)vzip2_s32(v18, v19)));
}

float32x2_t cikernel::_fourfoldReflectedTile(CI *a1, float32x2_t a2, int8x16_t a3, int8x16_t a4)
{
  float32x2_t v5 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  int32x2_t v6 = (int32x2_t)vmul_f32(*(float32x2_t *)a3.i8, v5);
  int32x2_t v7 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v5);
  float32x2_t v8 = vadd_f32((float32x2_t)vzip1_s32(v6, v7), (float32x2_t)vzip2_s32(v6, v7));
  float32x2_t v9 = vminnm_f32(vsub_f32(v8, vrndm_f32(v8)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu));
  __asm { FMOV            V1.2S, #1.0 }
  float32x2_t v15 = vminnm_f32(v9, vsub_f32(_D1, v9));
  float32x2_t v16 = vadd_f32(v15, v15);
  int32x2_t v17 = (int32x2_t)vmul_f32(*(float32x2_t *)a4.i8, v16);
  int32x2_t v18 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v16);
  return vadd_f32(a2, vadd_f32((float32x2_t)vzip1_s32(v17, v18), (float32x2_t)vzip2_s32(v17, v18)));
}

float32x2_t cikernel::_sixfoldReflectedTile(CI *a1, float32x2_t a2, int8x16_t a3, int8x16_t a4)
{
  float32x2_t v5 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  int32x2_t v7 = (int32x2_t)vmul_f32(*(float32x2_t *)a3.i8, v5);
  int32x2_t v8 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v5);
  float32x2_t v9 = vadd_f32((float32x2_t)vzip1_s32(v7, v8), (float32x2_t)vzip2_s32(v7, v8));
  int32x2_t v10 = (int32x2_t)vminnm_f32(vsub_f32(v9, vrndm_f32(v9)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu));
  if (vsub_f32((float32x2_t)v10, (float32x2_t)vdup_lane_s32(v10, 1)).f32[0] >= 0.0) {
    *(float *)v6.i32 = 0.0;
  }
  else {
    *(float *)v6.i32 = 1.0;
  }
  __asm { FMOV            V6.2S, #1.0 }
  float32x2_t v16 = vmla_n_f32(vmul_f32((float32x2_t)vrev64_s32(v10), vsub_f32(_D6, (float32x2_t)vdup_lane_s32(v6, 0))), (float32x2_t)v10, *(float *)v6.i32);
  float v17 = v16.f32[1];
  float v18 = vaddv_f32(v16);
  if ((float)((float)(2.0 - v18) - v16.f32[1]) < 0.0) {
    float v17 = 2.0 - v18;
  }
  *(float *)v19.i32 = 1.0 - v18;
  float v20 = v16.f32[0] - *(float *)v19.i32;
  if (v20 >= 0.0) {
    *(float *)v19.i32 = v16.f32[0];
  }
  *(float *)&v19.i32[1] = v17;
  if ((float)(*(float *)v19.i32 - v17) >= 0.0) {
    *(float *)v10.i32 = 0.0;
  }
  else {
    *(float *)v10.i32 = 1.0;
  }
  float32x2_t v21 = vmla_n_f32(vmul_f32((float32x2_t)vrev64_s32(v19), vsub_f32(_D6, (float32x2_t)vdup_lane_s32(v10, 0))), (float32x2_t)v19, *(float *)v10.i32);
  int32x2_t v22 = (int32x2_t)vmul_f32(*(float32x2_t *)a4.i8, v21);
  int32x2_t v23 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v21);
  return vadd_f32(a2, vadd_f32((float32x2_t)vzip1_s32(v22, v23), (float32x2_t)vzip2_s32(v22, v23)));
}

void sub_193848F1C(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C40E019140BLL);
  _Unwind_Resume(a1);
}

void sub_1938492CC(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E3C408FEBF924);
  _Unwind_Resume(a1);
}

void sub_19384946C(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C4067939989);
  _Unwind_Resume(a1);
}

void sub_1938495D8(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E3C400736B9BCLL);
  _Unwind_Resume(a1);
}

CFTypeRef CI::RenderDestination::setLabel(CI::RenderDestination *this, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  CFTypeRef result = (CFTypeRef)*((void *)this + 2);
  if (result) {
    CFTypeRef result = CFAutorelease(result);
  }
  *((void *)this + 2) = cf;
  return result;
}

const void *CI::RenderToMTLTextureProvider::texture(CI::RenderToMTLTextureProvider *this)
{
  CFTypeRef result = (const void *)*((void *)this + 10);
  if (!result)
  {
    CFTypeRef result = (const void *)(*(uint64_t (**)(void))(*((void *)this + 9) + 16))();
    *((void *)this + 10) = result;
    if (result)
    {
      CFRetain(result);
      return (const void *)*((void *)this + 10);
    }
  }
  return result;
}

double cikernel::_destDither(float32x4_t a1, int32x4_t a2, float a3)
{
  double v3 = vaddq_f32((float32x4_t)vdupq_laneq_s32(a2, 3), vaddq_f32((float32x4_t)vdupq_laneq_s32(a2, 2), vaddq_f32((float32x4_t)a2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.i8, 1)))).f32[0]* 0.25+ -0.5;
  *(float *)&double v3 = v3;
  *(float *)&double v3 = *(float *)&v3 * a3;
  float32x4_t v4 = vaddq_f32(a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v3, 0));
  v4.i32[3] = 0;
  float32x4_t v5 = vmaxnmq_f32(v4, (float32x4_t)0);
  v5.i32[3] = 0;
  *(void *)&double result = vminnmq_f32(v5, (float32x4_t)xmmword_1939508C0).u64[0];
  return result;
}

double cikernel::_rippleTransition(uint64_t a1, uint64_t a2, uint64_t a3, float32x2_t a4, float32x4_t a5, float32x2_t a6)
{
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  float32x2_t v12 = vsub_f32(*DC, a4);
  int32x2_t v13 = (int32x2_t)vmul_f32(v12, v12);
  *(float *)v13.i32 = sqrtf(vaddv_f32((float32x2_t)v13));
  float32x2_t v14 = (float32x2_t)vdup_lane_s32(v13, 0);
  *(float *)v13.i32 = vmuls_lane_f32(vmuls_lane_f32(*(float *)v13.i32 - a5.f32[0], *(float32x2_t *)a5.f32, 1), a5, 2);
  float32x2_t v15 = vdiv_f32(v12, v14);
  float32x4_t v16 = vaddq_f32((float32x4_t)vdupq_lane_s32(v13, 0), (float32x4_t)xmmword_193956200);
  int32x4_t v17 = vcltzq_f32(v16);
  v16.i32[3] = v16.i32[1];
  __asm { FMOV            V5.4S, #1.0 }
  float32x4_t v23 = vminnmq_f32(vmaxnmq_f32(vminnmq_f32(vmaxnmq_f32(v16, (float32x4_t)0), _Q5), (float32x4_t)0), _Q5);
  _Q5.i64[0] = 0xC0000000C0000000;
  _Q5.i64[1] = 0xC0000000C0000000;
  __asm { FMOV            V6.4S, #3.0 }
  float32x4_t v52 = vaddq_f32(vmulq_f32(vmulq_f32(vmulq_f32(v23, v23), vmlaq_f32(_Q6, _Q5, v23)), (float32x4_t)xmmword_193956210), (float32x4_t)xmmword_193956220);
  *(int16x4_t *)v23.f32 = vmovn_s32(v17);
  int8x16_t v25 = (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(*(int16x4_t *)v23.f32, 1)), 0x1FuLL));
  int8x16_t v26 = (int8x16_t)vdupq_laneq_s32((int32x4_t)v52, 2);
  int8x16_t v27 = (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(*(int16x4_t *)v23.f32, 2)), 0x1FuLL));
  *(int8x8_t *)v17.i8 = vbsl_s8(*(int8x8_t *)v27.i8, vbsl_s8(*(int8x8_t *)v25.i8, vand_s8((int8x8_t)vdup_lane_s32(*(int32x2_t *)v52.f32, 0), (int8x8_t)*(_OWORD *)&vcgezq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(*(int16x4_t *)v23.f32, 0)), 0x1FuLL))), (int8x8_t)vdup_lane_s32(*(int32x2_t *)v52.f32, 1)), *(int8x8_t *)v26.i8);
  float32x2_t v28 = vmul_f32(v15, (float32x2_t)vand_s8(*(int8x8_t *)v17.i8, (int8x8_t)*(_OWORD *)&vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(*(int16x4_t *)v23.f32, 3)), 0x1FuLL))));
  *(float32x2_t *)v23.f32 = vmul_laneq_f32(v28, a5, 3);
  *(float32x2_t *)v25.i8 = vadd_f32(*DC, *(float32x2_t *)v23.f32);
  *(float32x2_t *)&v29.f64[0] = vmul_f32(v28, (float32x2_t)0x3F0000003F000000);
  *(float32x2_t *)v30.i8 = vmul_f32(a6, vadd_f32(*(float32x2_t *)&v29.f64[0], (float32x2_t)0x3F0000003F000000));
  int8x16_t v47 = v25;
  int8x16_t v49 = v30;
  v23.i32[0] = *(_DWORD *)(a1 + 28);
  *(float *)v30.i32 = *(float *)(a1 + 24)
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v25.i8, 1), *(float *)(a1 + 16), *(float *)v25.i32);
  v17.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v29.f64 = *(float *)v17.i32
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v25.i8, 1), v23.f32[0], *(float *)v25.i32);
  v30.i32[1] = LODWORD(v29.f64[0]);
  *(double *)v31.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v30.i64, v29, *(double *)v23.i64, *(double *)v17.i64, v25, v26, v27);
  float32x4_t v51 = v31;
  HIDWORD(v32) = v47.i32[1];
  LODWORD(v32) = *(_DWORD *)(a2 + 28);
  v33.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)&double v34 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *(float32x2_t *)v47.i8, 1), *(float *)&v32, *(float *)v47.i32);
  v31.f32[0] = *(float *)(a2 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *(float32x2_t *)v47.i8, 1), *(float *)(a2 + 16), *(float *)v47.i32);
  *(float *)v35.f64 = *(float *)v33.i32 + *(float *)&v34;
  v31.f32[1] = *(float *)v33.i32 + *(float *)&v34;
  *(double *)v37.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v31.i64, v35, v32, v34, v33, v47, v36);
  float32x4_t v48 = v37;
  HIDWORD(v38) = v49.i32[1];
  LODWORD(v38) = *(_DWORD *)(a3 + 28);
  v39.i32[0] = *(_DWORD *)(a3 + 36);
  *(float *)&double v40 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a3 + 32), *(float32x2_t *)v49.i8, 1), *(float *)&v38, *(float *)v49.i32);
  v37.f32[0] = *(float *)(a3 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a3 + 20), *(float32x2_t *)v49.i8, 1), *(float *)(a3 + 16), *(float *)v49.i32);
  *(float *)v41.f64 = *(float *)v39.i32 + *(float *)&v40;
  v37.f32[1] = *(float *)v39.i32 + *(float *)&v40;
  *(double *)v43.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a3 + 8), *(double *)v37.i64, v41, v38, v40, v39, v49, v42);
  float32x4_t v44 = vmlaq_laneq_f32(vmulq_n_f32(v48, 1.0 - v52.f32[3]), v51, v52, 3);
  float32x4_t v45 = vmulq_laneq_f32(v43, v44, 3);
  *(void *)&double result = vaddq_f32(v45, vmulq_n_f32(v44, 1.0 - v45.f32[3])).u64[0];
  return result;
}

void CI::f4_sr_sr_sr_f2_f4_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = *(void *)(a1 + 48);
  float32x2_t v11 = *(double (**)(uint64_t, uint64_t, uint64_t, double, __n128, double))(a1 + 24);
  uint64_t v12 = *(void *)(v10 + 8);
  uint64_t v13 = *(void *)(v10 + 32);
  uint64_t v14 = *(void *)(v10 + 56);
  int v15 = *(_DWORD *)(v10 + 88);
  uint64_t v16 = *(void *)(v10 + 80);
  int v17 = *(_DWORD *)(v10 + 112);
  uint64_t v18 = *(void *)(v10 + 104);
  int v19 = *(_DWORD *)(v10 + 136);
  uint64_t v20 = *(void *)(v10 + 128);
  if (*(unsigned char *)(a1 + 64))
  {
    uint64_t v26 = *(void *)(v10 + 32);
    int v27 = *(_DWORD *)(v10 + 88);
    int v25 = *(_DWORD *)(v10 + 136);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 152)), a2);
    int v19 = v25;
    int v15 = v27;
    uint64_t v13 = v26;
  }
  float32x2_t v21 = (double *)(a3 + 16 * v20);
  if (v19 != 5) {
    float32x2_t v21 = (double *)((char *)a2 + 64 * v20);
  }
  int32x2_t v22 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5) {
    int32x2_t v22 = (__n128 *)((char *)a2 + 64 * v18);
  }
  float32x4_t v23 = (double *)(a3 + 16 * v16);
  if (v15 != 5) {
    float32x4_t v23 = (double *)((char *)a2 + 64 * v16);
  }
  *(double *)&long long v24 = v11(a4 + 80 * v12, a4 + 80 * v13, a4 + 80 * v14, *v23, *v22, *v21);
  *(_OWORD *)(a3 + 16 * a7) = v24;
}

void sub_19384B0D8(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C40191B4CE2);
  _Unwind_Resume(a1);
}

void sub_19384B2B0(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C40191B4CE2);
  _Unwind_Resume(a1);
}

CI::SRGBImage *CI::SRGBImage::SRGBImage(CI::SRGBImage *this, CI::Image *a2, int a3)
{
  int32x2_t v6 = CI::ImageWithChild::ImageWithChild(this, a2);
  *((void *)v6 + 14) = &unk_1EE45AA80;
  atomic_fetch_add(&dword_1EB466E78[12], 1u);
  *(void *)int32x2_t v6 = &unk_1EE45F8E8;
  *((void *)v6 + 14) = &unk_1EE45FA40;
  *((_DWORD *)v6 + 30) = a3;
  *((void *)this + 10) = CI::SRGBImage::makeDigest(*((void *)a2 + 10), a3);
  *((void *)this + 11) = CI::SRGBImage::makeDigest(*((void *)a2 + 11), a3);
  *((unsigned char *)this + 97) = 0;
  return this;
}

void sub_19384B3C8(_Unwind_Exception *a1)
{
  *((void *)v1 + 14) = v2;
  atomic_fetch_add(v3, 0xFFFFFFFF);
  CI::ImageWithChild::~ImageWithChild(v1);
  _Unwind_Resume(a1);
}

unint64_t CI::SRGBImage::makeDigest(uint64_t a1, int a2)
{
  XXH64_reset(v5, 0);
  LODWORD(__src) = 14;
  XXH64_update((uint64_t)v5, (char *)&__src, 4uLL);
  __vImage_Buffer src = a1;
  XXH64_update((uint64_t)v5, (char *)&__src, 8uLL);
  LODWORD(__src) = a2;
  XXH64_update((uint64_t)v5, (char *)&__src, 4uLL);
  return XXH64_digest((uint64_t)v5);
}

uint64_t CI::InstanceCounted<(CI::Type)14>::type()
{
  return 14;
}

void *CI::InstanceCounted<(CI::Type)14>::~InstanceCounted(void *result)
{
  *double result = &unk_1EE45AA80;
  atomic_fetch_add(&dword_1EB466E78[12], 0xFFFFFFFF);
  return result;
}

void CI::InstanceCounted<(CI::Type)14>::~InstanceCounted(void *a1)
{
  *a1 = &unk_1EE45AA80;
  atomic_fetch_add(&dword_1EB466E78[12], 0xFFFFFFFF);
  JUMPOUT(0x1997023B0);
}

void sub_19384B838(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__17(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__17(uint64_t a1)
{
}

Class ___ZL52getVNGenerateAttentionBasedSaliencyImageRequestClassv_block_invoke(uint64_t a1)
{
  VisionLibrary();
  Class result = objc_getClass("VNGenerateAttentionBasedSaliencyImageRequest");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    ___ZL52getVNGenerateAttentionBasedSaliencyImageRequestClassv_block_invoke_cold_1();
  }
  getVNGenerateAttentionBasedSaliencyImageRequestClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32)
                                                                                                + 8)
                                                                                    + 40);
  return result;
}

void VisionLibrary(void)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  v0[0] = 0;
  if (!VisionLibraryCore(char **)::frameworkLibrary)
  {
    v0[1] = (void *)MEMORY[0x1E4F143A8];
    v0[2] = (void *)3221225472;
    v0[3] = ___ZL17VisionLibraryCorePPc_block_invoke_1;
    v0[4] = &__block_descriptor_40_e5_v8__0l;
    v0[5] = v0;
    long long v1 = xmmword_1E5772DB8;
    uint64_t v2 = 0;
    VisionLibraryCore(char **)::frameworkLibrarCGFloat y = _sl_dlopen();
  }
  if (!VisionLibraryCore(char **)::frameworkLibrary) {
    VisionLibrary(v0);
  }
  if (v0[0]) {
    free(v0[0]);
  }
}

uint64_t ___ZL17VisionLibraryCorePPc_block_invoke_1()
{
  uint64_t result = _sl_dlopen();
  VisionLibraryCore(char **)::frameworkLibrarCGFloat y = result;
  return result;
}

Class ___ZL29getVNImageRequestHandlerClassv_block_invoke_1(uint64_t a1)
{
  VisionLibrary();
  Class result = objc_getClass("VNImageRequestHandler");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    ___ZL29getVNImageRequestHandlerClassv_block_invoke_cold_1();
  }
  getVNImageRequestHandlerClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

double cikernel::_sepia(float32x4_t a1, float a2)
{
  float32x4_t v2 = vmulq_f32(a1, (float32x4_t)xmmword_193950A90);
  int32x2_t v3 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v2, 2), vaddq_f32(v2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v2.f32, 1))).u64[0];
  if (vmlas_n_f32(-*(float *)v3.i32, *(float *)v3.i32, *(float *)v3.i32) >= 0.0)
  {
    float32x4_t v5 = (float32x4_t)vdupq_lane_s32(v3, 0);
  }
  else
  {
    float v4 = *(float *)v3.i32 / fmaxf(a1.f32[3], 0.0001);
    float32x4_t v5 = vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_1939562B0, a1, 3), vmulq_n_f32(vaddq_f32(vmulq_n_f32(vaddq_f32(vmulq_n_f32(vaddq_f32(vmulq_n_f32((float32x4_t)xmmword_193956270, v4), (float32x4_t)xmmword_193956280), v4), (float32x4_t)xmmword_193956290), v4), (float32x4_t)xmmword_1939562A0), *(float *)v3.i32));
    if (a1.f32[3] * 0.085 <= *(float *)v3.i32) {
      float v6 = v5.f32[3];
    }
    else {
      float v6 = v5.f32[0];
    }
    v5.f32[0] = v6;
  }
  v5.i32[3] = a1.i32[3];
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - a2), vmulq_f32(v5, (float32x4_t)xmmword_1939562C0), a2).u64[0];
  return result;
}

uint64_t encodePointForKey(void *a1, uint64_t a2, double a3)
{
  [a1 encodeDouble:objc_msgSend(NSString, "stringWithFormat:", @"%@.%@", a2, @"suffix", a3 forKey];
  uint64_t v6 = [NSString stringWithFormat:@"%@.%@", a2, @"suffix"];

  return [a1 encodeDouble:v6 forKey:a3];
}

uint64_t encodeRectForKey(void *a1, uint64_t a2, double a3, double a4, double a5, double a6)
{
  [a1 encodeDouble:objc_msgSend(NSString, "stringWithFormat:", @"%@.%@", a2, @"suffix", a3 forKey];
  [a1 encodeDouble:objc_msgSend(NSString, "stringWithFormat:", @"%@.%@", a2, @"suffix", a4 forKey];
  [a1 encodeDouble:objc_msgSend(NSString, "stringWithFormat:", @"%@.%@", a2, @"suffix", a5 forKey];
  uint64_t v11 = [NSString stringWithFormat:@"%@.%@", a2, @"suffix"];

  return [a1 encodeDouble:v11 forKey:a6];
}

double decodePointForKey(void *a1, uint64_t a2)
{
  [a1 decodeDoubleForKey:objc_msgSend(NSString, "stringWithFormat:", @"%@.%@", a2, @"suffix"];
  double v5 = v4;
  [a1 decodeDoubleForKey:objc_msgSend(NSString, "stringWithFormat:", @"%@.%@", a2, @"suffix"];
  return v5;
}

double decodeRectForKey(void *a1, uint64_t a2)
{
  [a1 decodeDoubleForKey:objc_msgSend(NSString, "stringWithFormat:", @"%@.%@", a2, @"suffix"];
  double v5 = v4;
  [a1 decodeDoubleForKey:objc_msgSend(NSString, "stringWithFormat:", @"%@.%@", a2, @"suffix"];
  [a1 decodeDoubleForKey:objc_msgSend(NSString, "stringWithFormat:", @"%@.%@", a2, @"suffix"];
  [a1 decodeDoubleForKey:objc_msgSend(NSString, "stringWithFormat:", @"%@.%@", a2, @"suffix"];
  return v5;
}

uint64_t valueWithPoint(double a1, double a2)
{
  *(double *)int32x2_t v3 = a1;
  *(double *)&v3[1] = a2;
  return [MEMORY[0x1E4F29238] valueWithBytes:v3 objCType:"{CGPoint=dd}"];
}

uint64_t valueWithRect(double a1, double a2, double a3, double a4)
{
  *(double *)double v5 = a1;
  *(double *)&v5[1] = a2;
  *(double *)&_OWORD v5[2] = a3;
  *(double *)&void v5[3] = a4;
  return [MEMORY[0x1E4F29238] valueWithBytes:v5 objCType:"{CGRect={CGPoint=dd}{CGSize=dd}}"];
}

double pointFromValue(void *a1)
{
  v2[0] = 0;
  v2[1] = 0;
  [a1 getValue:v2];
  return *(double *)v2;
}

double rectFromValue(void *a1)
{
  memset(v2, 0, sizeof(v2));
  [a1 getValue:v2];
  return *(double *)v2;
}

uint64_t unarchiveObjectOfClass(uint64_t a1, uint64_t a2)
{
  return [MEMORY[0x1E4F28DC0] unarchivedObjectOfClass:a1 fromData:a2 error:0];
}

uint64_t unarchiveObjectOfClassAllowCommon(uint64_t a1, uint64_t a2)
{
  int v17 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v16 = self;
  uint64_t v2 = self;
  uint64_t v3 = self;
  uint64_t v4 = self;
  uint64_t v5 = self;
  uint64_t v6 = self;
  uint64_t v7 = self;
  uint64_t v8 = self;
  uint64_t v9 = self;
  uint64_t v10 = self;
  uint64_t v11 = self;
  uint64_t v12 = objc_msgSend(v17, "setWithObjects:", v16, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, self, a1, 0);
  uint64_t v13 = (void *)MEMORY[0x1E4F28DC0];

  return [v13 unarchivedObjectOfClasses:v12 fromData:a2 error:0];
}

uint64_t archivedDataWithRootObject(uint64_t a1)
{
  return [MEMORY[0x1E4F28DB0] archivedDataWithRootObject:a1 requiringSecureCoding:1 error:0];
}

double cikernel::_shadedmaterial(uint64_t a1, uint64_t a2, float32_t a3, float32x2_t a4)
{
  float32x2_t v7 = *(float32x2_t *)CI::getDC((CI *)a1);
  float32x2_t v8 = vadd_f32(v7, (float32x2_t)0x3F80000000000000);
  *(float *)&double v9 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v8, 1), *(float *)(a1 + 16), v8.f32[0]);
  LODWORD(v10) = *(_DWORD *)(a1 + 28);
  v11.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v12.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v8, 1), *(float *)&v10, v8.f32[0]);
  v8.f32[0] = *(float *)(a1 + 24) + *(float *)&v9;
  *(float *)v13.f64 = *(float *)v11.i32 + *(float *)v12.i32;
  v8.f32[1] = *(float *)v11.i32 + *(float *)v12.i32;
  *(double *)v15.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v8, v13, v9, v10, v12, v11, v14);
  float32x4_t v61 = v15;
  *(float32x2_t *)v15.f32 = vadd_f32(v7, (float32x2_t)0xBF80000000000000);
  *(float *)&double v16 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v15.f32, 1), *(float *)(a1 + 16), v15.f32[0]);
  LODWORD(v17) = *(_DWORD *)(a1 + 28);
  v18.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v15.f32, 1), *(float *)&v17, v15.f32[0]);
  v15.f32[0] = *(float *)(a1 + 24) + *(float *)&v16;
  *(float *)v20.f64 = *(float *)v18.i32 + *(float *)v19.i32;
  v15.f32[1] = *(float *)v18.i32 + *(float *)v19.i32;
  *(double *)v22.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v15.i64, v20, v16, v17, v19, v18, v21);
  float32x4_t v60 = v22;
  *(float32x2_t *)v22.f32 = vadd_f32(v7, (float32x2_t)3212836864);
  *(float *)&double v23 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v22.f32, 1), *(float *)(a1 + 16), v22.f32[0]);
  LODWORD(v24) = *(_DWORD *)(a1 + 28);
  v25.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v22.f32, 1), *(float *)&v24, v22.f32[0]);
  v22.f32[0] = *(float *)(a1 + 24) + *(float *)&v23;
  *(float *)v27.f64 = *(float *)v25.i32 + *(float *)v26.i32;
  v22.f32[1] = *(float *)v25.i32 + *(float *)v26.i32;
  *(double *)v29.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v22.i64, v27, v23, v24, v26, v25, v28);
  float32x4_t v59 = v29;
  *(float32x2_t *)v29.f32 = vadd_f32(v7, (float32x2_t)1065353216);
  *(float *)&double v30 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v29.f32, 1), *(float *)(a1 + 16), v29.f32[0]);
  LODWORD(v31) = *(_DWORD *)(a1 + 28);
  v32.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v29.f32, 1), *(float *)&v31, v29.f32[0]);
  v29.f32[0] = *(float *)(a1 + 24) + *(float *)&v30;
  *(float *)v34.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v29.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)v36.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v29.i64, v34, v30, v31, v33, v32, v35);
  float32x4_t v57 = v36;
  DC = (float32x2_t *)CI::getDC(v37);
  *(float *)&double v39 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v40) = *(_DWORD *)(a1 + 28);
  v41.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v42.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)&v40, COERCE_FLOAT(*DC));
  *(float *)&double v43 = *(float *)(a1 + 24) + *(float *)&v39;
  *(float *)v44.f64 = *(float *)v41.i32 + *(float *)v42.i32;
  *((float *)&v43 + 1) = *(float *)v41.i32 + *(float *)v42.i32;
  *(double *)v46.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v43, v44, v39, v40, v42, v41, v45);
  float32x4_t v58 = v46;
  int32x4_t v47 = vzip1q_s32((int32x4_t)vsubq_f32(v59, v57), (int32x4_t)vsubq_f32(v60, v61));
  float32x4_t v48 = (float32x4_t)v47;
  v48.f32[2] = a3;
  float64x2_t v49 = (float64x2_t)vmulq_f32(v48, v48);
  LODWORD(v49.f64[0]) = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32((int32x4_t)v49, 2), vadd_f32(*(float32x2_t *)&v49.f64[0], (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v49.f64[0], 1))).u32[0];
  float32x2_t v50 = vrsqrte_f32((float32x2_t)LODWORD(v49.f64[0]));
  float32x2_t v51 = vmul_f32(v50, v50);
  *(float32x2_t *)&v49.f64[0] = vmul_f32(a4, vadd_f32(vmul_f32(vmul_n_f32(*(float32x2_t *)v47.i8, vmul_f32(v50, vrsqrts_f32((float32x2_t)LODWORD(v49.f64[0]), v51)).f32[0]), (float32x2_t)vdup_n_s32(0x3EFD70A4u)), (float32x2_t)0x3F0000003F000000));
  v51.i32[0] = *(_DWORD *)(a2 + 28);
  *(float *)v47.i32 = *(float *)(a2 + 24)
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *(float32x2_t *)&v49.f64[0], 1), *(float *)(a2 + 16), *(float *)v49.f64);
  v52.i32[0] = *(_DWORD *)(a2 + 36);
  v50.f32[0] = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *(float32x2_t *)&v49.f64[0], 1), v51.f32[0], *(float *)v49.f64);
  *(float *)v49.f64 = *(float *)v52.i32 + v50.f32[0];
  *(float *)&v47.i32[1] = *(float *)v52.i32 + v50.f32[0];
  *(double *)v55.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v47.i64, v49, *(double *)&v50, *(double *)&v51, v52, v53, v54);
  *(void *)&double result = vmulq_laneq_f32(v55, v58, 3).u64[0];
  return result;
}

void CI::f4_sr_sr_f_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = *(void *)(a1 + 48);
  int8x16_t v12 = *(double (**)(uint64_t, uint64_t, float, double))(a1 + 24);
  uint64_t v13 = *(void *)(v11 + 8);
  uint64_t v14 = *(void *)(v11 + 32);
  uint64_t v15 = *(void *)(v11 + 56);
  int v16 = *(_DWORD *)(v11 + 88);
  uint64_t v17 = *(void *)(v11 + 80);
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC((CI *)(a3 + 16 * *(void *)(v11 + 104)), a2);
  }
  int8x16_t v18 = (double *)(a3 + 16 * v17);
  if (v16 != 5) {
    int8x16_t v18 = (double *)((char *)a2 + 64 * v17);
  }
  *(double *)&long long v19 = v12(a4 + 80 * v13, a4 + 80 * v14, *((float *)a2 + 16 * v15), *v18);
  *(_OWORD *)(a3 + 16 * a7) = v19;
}

double cikernel::_shadedmaterial_0(uint64_t a1, uint64_t a2, float32x2_t a3)
{
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)&double v7 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v8) = *(_DWORD *)(a1 + 28);
  v9.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v10.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)&v8, COERCE_FLOAT(*DC));
  *(float *)&double v11 = *(float *)(a1 + 24) + *(float *)&v7;
  *(float *)v12.f64 = *(float *)v9.i32 + *(float *)v10.i32;
  *((float *)&v11 + 1) = *(float *)v9.i32 + *(float *)v10.i32;
  *(double *)v14.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v11, v12, v7, v8, v10, v9, v13);
  float32x4_t v23 = v14;
  *(float32x2_t *)v14.f32 = vmul_f32(a3, (float32x2_t)0x3F0000003F000000);
  *(float *)&double v15 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *(float32x2_t *)v14.f32, 1), *(float *)(a2 + 16), v14.f32[0]);
  LODWORD(v16) = *(_DWORD *)(a2 + 28);
  v17.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *(float32x2_t *)v14.f32, 1), *(float *)&v16, v14.f32[0]);
  v14.f32[0] = *(float *)(a2 + 24) + *(float *)&v15;
  *(float *)v19.f64 = *(float *)v17.i32 + *(float *)v18.i32;
  v14.f32[1] = *(float *)v17.i32 + *(float *)v18.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v14.i64, v19, v15, v16, v18, v17, v20);
  *(void *)&double result = vmulq_laneq_f32(v21, v23, 3).u64[0];
  return result;
}

void CI::f4_sr_sr_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = *(void *)(a1 + 48);
  float64x2_t v12 = *(double (**)(uint64_t, uint64_t, double))(a1 + 24);
  uint64_t v13 = *(void *)(v11 + 8);
  uint64_t v14 = *(void *)(v11 + 32);
  int v15 = *(_DWORD *)(v11 + 64);
  uint64_t v16 = *(void *)(v11 + 56);
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC((CI *)(a3 + 16 * *(void *)(v11 + 80)), a2);
  }
  int8x16_t v17 = (double *)(a3 + 16 * v16);
  if (v15 != 5) {
    int8x16_t v17 = (double *)((char *)a2 + 64 * v16);
  }
  *(double *)&long long v18 = v12(a4 + 80 * v13, a4 + 80 * v14, *v17);
  *(_OWORD *)(a3 + 16 * a7) = v18;
}

double cikernel::_noiseReduction(uint64_t a1, int8x16_t a2, float32x4_t a3, __n128 a4)
{
  v5.i64[0] = *(void *)CI::getDC((CI *)a1);
  float64x2_t v92 = (float64x2_t)v5;
  LODWORD(v6) = *(_DWORD *)(a1 + 28);
  *(float *)&double v7 = *(float *)(a1 + 24)
                + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v5.i8, 1), *(float *)(a1 + 16), *(float *)v5.i32);
  LODWORD(v8) = *(_DWORD *)(a1 + 36);
  *(float *)v9.f64 = *(float *)&v8
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v5.i8, 1), *(float *)&v6, *(float *)v5.i32);
  HIDWORD(v7) = LODWORD(v9.f64[0]);
  *(double *)v12.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v7, v9, v6, v8, v5, v10, v11);
  float32x4_t v87 = v12;
  v12.i32[0] = 0;
  v12.f32[1] = -*(float *)a2.i32;
  float64x2_t v13 = v92;
  *(float32x2_t *)v12.f32 = vadd_f32(*(float32x2_t *)v12.f32, *(float32x2_t *)&v92.f64[0]);
  *(float *)&double v14 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v12.f32, 1), *(float *)(a1 + 16), v12.f32[0]);
  LODWORD(v15) = *(_DWORD *)(a1 + 28);
  v16.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v12.f32, 1), *(float *)&v15, v12.f32[0]);
  v12.f32[0] = *(float *)(a1 + 24) + *(float *)&v14;
  *(float *)v13.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v12.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v12.i64, v13, v14, v15, v17, v16, v18);
  float32x4_t v86 = v19;
  float64x2_t v20 = v92;
  *(float32x2_t *)v19.f32 = vadd_f32((float32x2_t)vzip1_s32(0, *(int32x2_t *)a2.i8), *(float32x2_t *)&v92.f64[0]);
  *(float *)&double v21 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v19.f32, 1), *(float *)(a1 + 16), v19.f32[0]);
  LODWORD(v22) = *(_DWORD *)(a1 + 28);
  v23.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v24.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v19.f32, 1), *(float *)&v22, v19.f32[0]);
  v19.f32[0] = *(float *)(a1 + 24) + *(float *)&v21;
  *(float *)v20.f64 = *(float *)v23.i32 + *(float *)v24.i32;
  v19.f32[1] = *(float *)v23.i32 + *(float *)v24.i32;
  *(double *)v26.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v19.i64, v20, v21, v22, v24, v23, v25);
  float32x4_t v85 = v26;
  *(void *)&v27.f64[0] = COERCE_UNSIGNED_INT(-*(float *)a2.i32);
  *(float32x2_t *)v26.f32 = vadd_f32(*(float32x2_t *)&v27.f64[0], *(float32x2_t *)&v92.f64[0]);
  *(float *)&double v28 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v26.f32, 1), *(float *)(a1 + 16), v26.f32[0]);
  LODWORD(v29) = *(_DWORD *)(a1 + 28);
  v30.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v31.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v26.f32, 1), *(float *)&v29, v26.f32[0]);
  v26.f32[0] = *(float *)(a1 + 24) + *(float *)&v28;
  *(float *)v27.f64 = *(float *)v30.i32 + *(float *)v31.i32;
  v26.f32[1] = *(float *)v30.i32 + *(float *)v31.i32;
  *(double *)v33.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v26.i64, v27, v28, v29, v31, v30, v32);
  float32x4_t v84 = v33;
  float64x2_t v34 = v92;
  *(float32x2_t *)v33.f32 = vadd_f32((float32x2_t)a2.u32[0], *(float32x2_t *)&v92.f64[0]);
  *(float *)&double v35 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v33.f32, 1), *(float *)(a1 + 16), v33.f32[0]);
  LODWORD(v36) = *(_DWORD *)(a1 + 28);
  v37.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v38.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v33.f32, 1), *(float *)&v36, v33.f32[0]);
  v33.f32[0] = *(float *)(a1 + 24) + *(float *)&v35;
  *(float *)v34.f64 = *(float *)v37.i32 + *(float *)v38.i32;
  v33.f32[1] = *(float *)v37.i32 + *(float *)v38.i32;
  *(double *)v40.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v33.i64, v34, v35, v36, v38, v37, v39);
  float32x4_t v83 = v40;
  *(int32x2_t *)&v41.f64[0] = vdup_lane_s32(*(int32x2_t *)a2.i8, 1);
  float64x2_t v80 = v41;
  *(float32x2_t *)v40.f32 = vadd_f32(*(float32x2_t *)&v41.f64[0], *(float32x2_t *)&v92.f64[0]);
  *(float *)&double v42 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v40.f32, 1), *(float *)(a1 + 16), v40.f32[0]);
  LODWORD(v43) = *(_DWORD *)(a1 + 28);
  v44.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v45.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v40.f32, 1), *(float *)&v43, v40.f32[0]);
  v40.f32[0] = *(float *)(a1 + 24) + *(float *)&v42;
  *(float *)v41.f64 = *(float *)v44.i32 + *(float *)v45.i32;
  v40.f32[1] = *(float *)v44.i32 + *(float *)v45.i32;
  *(double *)v46.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v40.i64, v41, v42, v43, v45, v44, a2);
  float32x4_t v82 = v46;
  v46.f32[0] = -*(float *)&a2.i32[1];
  int32x2_t v90 = *(int32x2_t *)v46.f32;
  float64x2_t v47 = v80;
  *((float *)v47.f64 + 1) = -*(float *)&a2.i32[1];
  *(float32x2_t *)v46.f32 = vadd_f32(*(float32x2_t *)&v47.f64[0], *(float32x2_t *)&v92.f64[0]);
  *(float *)&double v48 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v46.f32, 1), *(float *)(a1 + 16), v46.f32[0]);
  LODWORD(v49) = *(_DWORD *)(a1 + 28);
  v50.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v51.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v46.f32, 1), *(float *)&v49, v46.f32[0]);
  v46.f32[0] = *(float *)(a1 + 24) + *(float *)&v48;
  *(float *)v47.f64 = *(float *)v50.i32 + *(float *)v51.i32;
  v46.f32[1] = *(float *)v50.i32 + *(float *)v51.i32;
  *(double *)v53.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v46.i64, v47, v48, v49, v51, v50, v52);
  float32x4_t v81 = v53;
  float64x2_t v54 = v92;
  *(float32x2_t *)v53.f32 = vadd_f32((float32x2_t)vdup_lane_s32(v90, 0), *(float32x2_t *)&v92.f64[0]);
  *(float *)&double v55 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v53.f32, 1), *(float *)(a1 + 16), v53.f32[0]);
  LODWORD(v56) = *(_DWORD *)(a1 + 28);
  v57.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v58.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v53.f32, 1), *(float *)&v56, v53.f32[0]);
  v53.f32[0] = *(float *)(a1 + 24) + *(float *)&v55;
  *(float *)v54.f64 = *(float *)v57.i32 + *(float *)v58.i32;
  v53.f32[1] = *(float *)v57.i32 + *(float *)v58.i32;
  *(double *)v60.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v53.i64, v54, v55, v56, v58, v57, v59);
  float32x4_t v79 = v60;
  float64x2_t v61 = v92;
  *(float32x2_t *)v60.f32 = vadd_f32((float32x2_t)__PAIR64__(a2.u32[1], v90.u32[0]), *(float32x2_t *)&v92.f64[0]);
  *(float *)&double v62 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v60.f32, 1), *(float *)(a1 + 16), v60.f32[0]);
  LODWORD(v63) = *(_DWORD *)(a1 + 28);
  v64.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v65.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v60.f32, 1), *(float *)&v63, v60.f32[0]);
  v60.f32[0] = *(float *)(a1 + 24) + *(float *)&v62;
  *(float *)v61.f64 = *(float *)v64.i32 + *(float *)v65.i32;
  v60.f32[1] = *(float *)v64.i32 + *(float *)v65.i32;
  *(double *)v67.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v60.i64, v61, v62, v63, v65, v64, v66);
  float32x4_t v68 = vaddq_f32(vmulq_laneq_f32(v87, a3, 2), vaddq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vaddq_f32(v86, v85), v84), v83), a3.f32[0]), vmulq_lane_f32(vaddq_f32(vaddq_f32(vaddq_f32(v82, v81), v79), v67), *(float32x2_t *)a3.f32, 1)));
  _Q0 = vabdq_f32(v68, v87);
  _Q0.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)_Q0, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)_Q0.f32, 1), _Q0)).u32[0];
  _V3.S[1] = a4.n128_u32[1];
  __asm { FMLA            S2, S0, V3.S[1] }
  if (_S2 <= 1.0) {
    float v76 = _S2;
  }
  else {
    float v76 = 1.0;
  }
  if (_S2 >= a4.n128_f32[2]) {
    float v77 = v76;
  }
  else {
    float v77 = a4.n128_f32[2];
  }
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(v87, 1.0 - v77), v68, v77).u64[0];
  return result;
}

double cikernel::_convertRGBtoY(float32x4_t a1, double a2)
{
  *(float *)&a2 = fmaxf(a1.f32[3], 0.00001);
  float32x4_t v2 = vmulq_f32(vdivq_f32(a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a2, 0)), (float32x4_t)xmmword_193950AB0);
  v2.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v2, 2), vaddq_f32(v2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v2.f32, 1))).u64[0];
  v2.f32[0] = sqrtf(fmaxf(v2.f32[0], 0.0));
  *(void *)&double result = vdupq_lane_s32(*(int32x2_t *)v2.f32, 0).u64[0];
  return result;
}

double cikernel::_blur1(cikernel *this, SamplerObj *a2)
{
  v3.f64[0] = *(float64_t *)CI::getDC(this);
  int8x16_t v84 = (int8x16_t)v3;
  float32x2_t v4 = vadd_f32(*(float32x2_t *)&v3.f64[0], (float32x2_t)0x3F800000BF800000);
  *(float *)&double v5 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v4, 1), *((float *)this + 4), v4.f32[0]);
  LODWORD(v6) = *((_DWORD *)this + 7);
  v7.i32[0] = *((_DWORD *)this + 9);
  *(float *)v8.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v4, 1), *(float *)&v6, v4.f32[0]);
  v4.f32[0] = *((float *)this + 6) + *(float *)&v5;
  *(float *)v3.f64 = *(float *)v7.i32 + *(float *)v8.i32;
  v4.f32[1] = *(float *)v7.i32 + *(float *)v8.i32;
  *(double *)v10.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v4, v3, v5, v6, v8, v7, v9);
  float32x4_t v83 = v10;
  float64x2_t v11 = (float64x2_t)v84;
  *(float32x2_t *)v10.f32 = vadd_f32(*(float32x2_t *)v84.i8, (float32x2_t)0x3F80000000000000);
  *(float *)&double v12 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v10.f32, 1), *((float *)this + 4), v10.f32[0]);
  LODWORD(v13) = *((_DWORD *)this + 7);
  v14.i32[0] = *((_DWORD *)this + 9);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v10.f32, 1), *(float *)&v13, v10.f32[0]);
  v10.f32[0] = *((float *)this + 6) + *(float *)&v12;
  *(float *)v11.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v10.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v10.i64, v11, v12, v13, v15, v14, v16);
  float32x4_t v78 = _Q0;
  __asm { FMOV            V0.2S, #1.0 }
  float64x2_t v22 = (float64x2_t)v84;
  *(float32x2_t *)_Q0.f32 = vadd_f32(*(float32x2_t *)v84.i8, *(float32x2_t *)_Q0.f32);
  *(float *)&double v23 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)_Q0.f32, 1), *((float *)this + 4), _Q0.f32[0]);
  LODWORD(v24) = *((_DWORD *)this + 7);
  v25.i32[0] = *((_DWORD *)this + 9);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)_Q0.f32, 1), *(float *)&v24, _Q0.f32[0]);
  _Q0.f32[0] = *((float *)this + 6) + *(float *)&v23;
  *(float *)v22.f64 = *(float *)v25.i32 + *(float *)v26.i32;
  _Q0.f32[1] = *(float *)v25.i32 + *(float *)v26.i32;
  *(double *)v28.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)_Q0.i64, v22, v23, v24, v26, v25, v27);
  HIDWORD(v29) = v84.i32[1];
  float32x2_t v30 = vadd_f32(*(float32x2_t *)v84.i8, (float32x2_t)3212836864);
  *(float *)&double v31 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v30, 1), *((float *)this + 4), v30.f32[0]);
  LODWORD(v29) = *((_DWORD *)this + 6);
  v32.i32[0] = *((_DWORD *)this + 7);
  v33.i32[0] = *((_DWORD *)this + 9);
  *(float *)v34.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v30, 1), *(float *)v32.i32, v30.f32[0]);
  float64x2_t v35 = (float64x2_t)v83;
  float32x4_t v81 = vaddq_f32(v83, v28);
  v28.f32[0] = *(float *)&v29 + *(float *)&v31;
  *(float *)v35.f64 = *(float *)v33.i32 + *(float *)v34.i32;
  v28.f32[1] = *(float *)v33.i32 + *(float *)v34.i32;
  *(double *)v36.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v28.i64, v35, v29, v31, v32, v34, v33);
  float64x2_t v37 = (float64x2_t)v78;
  float32x4_t v79 = vaddq_f32(v78, v36);
  LODWORD(v38) = *((_DWORD *)this + 7);
  v36.f32[0] = *((float *)this + 6)
             + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v84.i8, 1), *((float *)this + 4), *(float *)v84.i32);
  LODWORD(v39) = *((_DWORD *)this + 9);
  *(float *)v37.f64 = *(float *)&v39
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v84.i8, 1), *(float *)&v38, *(float *)v84.i32);
  v36.i32[1] = LODWORD(v37.f64[0]);
  double v42 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v36.i64, v37, v38, v39, v84, v40, v41);
  v83.i32[0] = LODWORD(v42);
  float64x2_t v43 = (float64x2_t)v84;
  float32x2_t v44 = vadd_f32(*(float32x2_t *)v84.i8, (float32x2_t)1065353216);
  *(float *)&double v45 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v44, 1), *((float *)this + 4), v44.f32[0]);
  LODWORD(v46) = *((_DWORD *)this + 7);
  v47.i32[0] = *((_DWORD *)this + 9);
  *(float *)v48.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v44, 1), *(float *)&v46, v44.f32[0]);
  v44.f32[0] = *((float *)this + 6) + *(float *)&v45;
  *(float *)v43.f64 = *(float *)v47.i32 + *(float *)v48.i32;
  v44.f32[1] = *(float *)v47.i32 + *(float *)v48.i32;
  *(double *)v50.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v44, v43, v45, v46, v48, v47, v49);
  __asm { FMOV            V1.2S, #-1.0 }
  HIDWORD(v52) = v84.i32[1];
  float32x2_t v53 = vadd_f32(*(float32x2_t *)v84.i8, _D1);
  *(float *)&double v54 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v53, 1), *((float *)this + 4), v53.f32[0]);
  LODWORD(v52) = *((_DWORD *)this + 6);
  v55.i32[0] = *((_DWORD *)this + 7);
  v56.i32[0] = *((_DWORD *)this + 9);
  *(float *)v57.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v53, 1), *(float *)v55.i32, v53.f32[0]);
  float64x2_t v58 = (float64x2_t)v79;
  float32x4_t v80 = vaddq_f32(v79, v50);
  v50.f32[0] = *(float *)&v52 + *(float *)&v54;
  *(float *)v58.f64 = *(float *)v56.i32 + *(float *)v57.i32;
  v50.f32[1] = *(float *)v56.i32 + *(float *)v57.i32;
  *(double *)v59.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v50.i64, v58, v52, v54, v55, v57, v56);
  HIDWORD(v60) = v84.i32[1];
  float32x2_t v61 = vadd_f32(*(float32x2_t *)v84.i8, (float32x2_t)0xBF80000000000000);
  *(float *)&double v62 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v61, 1), *((float *)this + 4), v61.f32[0]);
  LODWORD(v60) = *((_DWORD *)this + 6);
  v63.i32[0] = *((_DWORD *)this + 7);
  v64.i32[0] = *((_DWORD *)this + 9);
  *(float *)v65.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v61, 1), *(float *)v63.i32, v61.f32[0]);
  float64x2_t v66 = (float64x2_t)v81;
  float32x4_t v82 = vaddq_f32(v81, v59);
  v59.f32[0] = *(float *)&v60 + *(float *)&v62;
  *(float *)v66.f64 = *(float *)v64.i32 + *(float *)v65.i32;
  v59.f32[1] = *(float *)v64.i32 + *(float *)v65.i32;
  *(double *)v67.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v59.i64, v66, v60, v62, v63, v65, v64);
  HIDWORD(v68) = v84.i32[1];
  float32x2_t v69 = vadd_f32(*(float32x2_t *)v84.i8, (float32x2_t)0xBF8000003F800000);
  *(float *)&double v70 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v69, 1), *((float *)this + 4), v69.f32[0]);
  LODWORD(v68) = *((_DWORD *)this + 6);
  v71.i32[0] = *((_DWORD *)this + 7);
  v72.i32[0] = *((_DWORD *)this + 9);
  *(float *)v73.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v69, 1), *(float *)v71.i32, v69.f32[0]);
  float64x2_t v74 = (float64x2_t)v80;
  *(float *)v84.i32 = vaddq_f32(v80, v67).f32[0];
  v67.f32[0] = *(float *)&v68 + *(float *)&v70;
  *(float *)v74.f64 = *(float *)v72.i32 + *(float *)v73.i32;
  v67.f32[1] = *(float *)v72.i32 + *(float *)v73.i32;
  *(double *)v75.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v67.i64, v74, v68, v70, v71, v73, v72);
  *(float *)&unsigned int v76 = *(float *)v84.i32 * 0.125 + v83.f32[0] * 0.25 + vaddq_f32(v82, v75).f32[0] * 0.0625;
  return COERCE_DOUBLE(__PAIR64__(v76, v83.u32[0]));
}

__n128 cikernel::_blur2(cikernel *this, SamplerObj *a2)
{
  v3.f64[0] = *(float64_t *)CI::getDC(this);
  int8x16_t v76 = (int8x16_t)v3;
  float32x2_t v4 = vadd_f32(*(float32x2_t *)&v3.f64[0], (float32x2_t)0x40000000C0000000);
  *(float *)&double v5 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v4, 1), *((float *)this + 4), v4.f32[0]);
  LODWORD(v6) = *((_DWORD *)this + 7);
  v7.i32[0] = *((_DWORD *)this + 9);
  *(float *)v8.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v4, 1), *(float *)&v6, v4.f32[0]);
  v4.f32[0] = *((float *)this + 6) + *(float *)&v5;
  *(float *)v3.f64 = *(float *)v7.i32 + *(float *)v8.i32;
  v4.f32[1] = *(float *)v7.i32 + *(float *)v8.i32;
  *(double *)v10.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v4, v3, v5, v6, v8, v7, v9);
  float32x4_t v74 = v10;
  float64x2_t v11 = (float64x2_t)v76;
  *(float32x2_t *)v10.f32 = vadd_f32(*(float32x2_t *)v76.i8, (float32x2_t)0x4000000000000000);
  *(float *)&double v12 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v10.f32, 1), *((float *)this + 4), v10.f32[0]);
  LODWORD(v13) = *((_DWORD *)this + 7);
  v14.i32[0] = *((_DWORD *)this + 9);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v10.f32, 1), *(float *)&v13, v10.f32[0]);
  v10.f32[0] = *((float *)this + 6) + *(float *)&v12;
  *(float *)v11.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v10.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)v17.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v10.i64, v11, v12, v13, v15, v14, v16);
  float32x4_t v70 = v17;
  float64x2_t v18 = (float64x2_t)v76;
  *(float32x2_t *)v17.f32 = vadd_f32(*(float32x2_t *)v76.i8, (float32x2_t)0x4000000040000000);
  *(float *)&double v19 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v17.f32, 1), *((float *)this + 4), v17.f32[0]);
  LODWORD(v20) = *((_DWORD *)this + 7);
  v21.i32[0] = *((_DWORD *)this + 9);
  *(float *)v22.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v17.f32, 1), *(float *)&v20, v17.f32[0]);
  v17.f32[0] = *((float *)this + 6) + *(float *)&v19;
  *(float *)v18.f64 = *(float *)v21.i32 + *(float *)v22.i32;
  v17.f32[1] = *(float *)v21.i32 + *(float *)v22.i32;
  *(double *)v24.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v17.i64, v18, v19, v20, v22, v21, v23);
  HIDWORD(v25) = v76.i32[1];
  float32x2_t v26 = vadd_f32(*(float32x2_t *)v76.i8, (float32x2_t)3221225472);
  *(float *)&double v27 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v26, 1), *((float *)this + 4), v26.f32[0]);
  LODWORD(v25) = *((_DWORD *)this + 6);
  v28.i32[0] = *((_DWORD *)this + 7);
  v29.i32[0] = *((_DWORD *)this + 9);
  *(float *)v30.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v26, 1), *(float *)v28.i32, v26.f32[0]);
  float64x2_t v31 = (float64x2_t)v74;
  float32x4_t v73 = vaddq_f32(v74, v24);
  v24.f32[0] = *(float *)&v25 + *(float *)&v27;
  *(float *)v31.f64 = *(float *)v29.i32 + *(float *)v30.i32;
  v24.f32[1] = *(float *)v29.i32 + *(float *)v30.i32;
  *(double *)v32.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v24.i64, v31, v25, v27, v28, v30, v29);
  float64x2_t v33 = (float64x2_t)v70;
  float32x4_t v71 = vaddq_f32(v70, v32);
  LODWORD(v34) = *((_DWORD *)this + 7);
  v32.f32[0] = *((float *)this + 6)
             + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v76.i8, 1), *((float *)this + 4), *(float *)v76.i32);
  LODWORD(v35) = *((_DWORD *)this + 9);
  *(float *)v33.f64 = *(float *)&v35
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v76.i8, 1), *(float *)&v34, *(float *)v76.i32);
  v32.i32[1] = LODWORD(v33.f64[0]);
  *(double *)&long long v38 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v32.i64, v33, v34, v35, v76, v36, v37);
  long long v75 = v38;
  float64x2_t v39 = (float64x2_t)v76;
  *(float32x2_t *)&long long v38 = vadd_f32(*(float32x2_t *)v76.i8, (float32x2_t)0x40000000);
  *(float *)&double v40 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)&v38, 1), *((float *)this + 4), *(float *)&v38);
  LODWORD(v41) = *((_DWORD *)this + 7);
  v42.i32[0] = *((_DWORD *)this + 9);
  *(float *)v43.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)&v38, 1), *(float *)&v41, *(float *)&v38);
  *(float *)&long long v38 = *((float *)this + 6) + *(float *)&v40;
  *(float *)v39.f64 = *(float *)v42.i32 + *(float *)v43.i32;
  *((float *)&v38 + 1) = *(float *)v42.i32 + *(float *)v43.i32;
  *(double *)v45.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v38, v39, v40, v41, v43, v42, v44);
  HIDWORD(v46) = v76.i32[1];
  float32x2_t v47 = vadd_f32(*(float32x2_t *)v76.i8, (float32x2_t)0xC0000000C0000000);
  *(float *)&double v48 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v47, 1), *((float *)this + 4), v47.f32[0]);
  LODWORD(v46) = *((_DWORD *)this + 6);
  v49.i32[0] = *((_DWORD *)this + 7);
  v50.i32[0] = *((_DWORD *)this + 9);
  *(float *)v51.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v47, 1), *(float *)v49.i32, v47.f32[0]);
  float64x2_t v52 = (float64x2_t)v71;
  float32x4_t v72 = vaddq_f32(v71, v45);
  v45.f32[0] = *(float *)&v46 + *(float *)&v48;
  *(float *)v52.f64 = *(float *)v50.i32 + *(float *)v51.i32;
  v45.f32[1] = *(float *)v50.i32 + *(float *)v51.i32;
  CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v45.i64, v52, v46, v48, v49, v51, v50);
  HIDWORD(v53) = v76.i32[1];
  float32x2_t v54 = vadd_f32(*(float32x2_t *)v76.i8, (float32x2_t)0xC000000000000000);
  *(float *)&double v55 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v54, 1), *((float *)this + 4), v54.f32[0]);
  LODWORD(v53) = *((_DWORD *)this + 6);
  v56.i32[0] = *((_DWORD *)this + 7);
  v57.i32[0] = *((_DWORD *)this + 9);
  *(float *)v58.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v54, 1), *(float *)v56.i32, v54.f32[0]);
  float64x2_t v59 = (float64x2_t)v73;
  *(float *)&double v60 = *(float *)&v53 + *(float *)&v55;
  *(float *)v59.f64 = *(float *)v57.i32 + *(float *)v58.i32;
  *((float *)&v60 + 1) = *(float *)v57.i32 + *(float *)v58.i32;
  CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v60, v59, v53, v55, v56, v58, v57);
  HIDWORD(v61) = v76.i32[1];
  float32x2_t v62 = vadd_f32(*(float32x2_t *)v76.i8, (float32x2_t)0xC000000040000000);
  *(float *)&double v63 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v62, 1), *((float *)this + 4), v62.f32[0]);
  LODWORD(v61) = *((_DWORD *)this + 6);
  v64.i32[0] = *((_DWORD *)this + 7);
  v65.i32[0] = *((_DWORD *)this + 9);
  *(float *)v66.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v62, 1), *(float *)v64.i32, v62.f32[0]);
  float64x2_t v67 = (float64x2_t)v72;
  *(float *)&double v68 = *(float *)&v61 + *(float *)&v63;
  *(float *)v67.f64 = *(float *)v65.i32 + *(float *)v66.i32;
  *((float *)&v68 + 1) = *(float *)v65.i32 + *(float *)v66.i32;
  CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v68, v67, v61, v63, v64, v66, v65);
  return (__n128)v75;
}

__n128 cikernel::_blur4(cikernel *this, SamplerObj *a2)
{
  v3.f64[0] = *(float64_t *)CI::getDC(this);
  int8x16_t v81 = (int8x16_t)v3;
  float32x2_t v4 = vadd_f32(*(float32x2_t *)&v3.f64[0], (float32x2_t)0x40800000C0800000);
  *(float *)&double v5 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v4, 1), *((float *)this + 4), v4.f32[0]);
  LODWORD(v6) = *((_DWORD *)this + 7);
  v7.i32[0] = *((_DWORD *)this + 9);
  *(float *)v8.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v4, 1), *(float *)&v6, v4.f32[0]);
  v4.f32[0] = *((float *)this + 6) + *(float *)&v5;
  *(float *)v3.f64 = *(float *)v7.i32 + *(float *)v8.i32;
  v4.f32[1] = *(float *)v7.i32 + *(float *)v8.i32;
  *(double *)v10.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v4, v3, v5, v6, v8, v7, v9);
  float32x4_t v79 = v10;
  float64x2_t v11 = (float64x2_t)v81;
  *(float32x2_t *)v10.f32 = vadd_f32(*(float32x2_t *)v81.i8, (float32x2_t)0x4080000000000000);
  *(float *)&double v12 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v10.f32, 1), *((float *)this + 4), v10.f32[0]);
  LODWORD(v13) = *((_DWORD *)this + 7);
  v14.i32[0] = *((_DWORD *)this + 9);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v10.f32, 1), *(float *)&v13, v10.f32[0]);
  v10.f32[0] = *((float *)this + 6) + *(float *)&v12;
  *(float *)v11.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v10.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v10.i64, v11, v12, v13, v15, v14, v16);
  float32x4_t v75 = _Q0;
  __asm { FMOV            V0.2S, #4.0 }
  float64x2_t v22 = (float64x2_t)v81;
  *(float32x2_t *)_Q0.f32 = vadd_f32(*(float32x2_t *)v81.i8, *(float32x2_t *)_Q0.f32);
  *(float *)&double v23 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)_Q0.f32, 1), *((float *)this + 4), _Q0.f32[0]);
  LODWORD(v24) = *((_DWORD *)this + 7);
  v25.i32[0] = *((_DWORD *)this + 9);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)_Q0.f32, 1), *(float *)&v24, _Q0.f32[0]);
  _Q0.f32[0] = *((float *)this + 6) + *(float *)&v23;
  *(float *)v22.f64 = *(float *)v25.i32 + *(float *)v26.i32;
  _Q0.f32[1] = *(float *)v25.i32 + *(float *)v26.i32;
  *(double *)v28.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)_Q0.i64, v22, v23, v24, v26, v25, v27);
  HIDWORD(v29) = v81.i32[1];
  float32x2_t v30 = vadd_f32(*(float32x2_t *)v81.i8, (float32x2_t)3229614080);
  *(float *)&double v31 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v30, 1), *((float *)this + 4), v30.f32[0]);
  LODWORD(v29) = *((_DWORD *)this + 6);
  v32.i32[0] = *((_DWORD *)this + 7);
  v33.i32[0] = *((_DWORD *)this + 9);
  *(float *)v34.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v30, 1), *(float *)v32.i32, v30.f32[0]);
  float64x2_t v35 = (float64x2_t)v79;
  float32x4_t v78 = vaddq_f32(v79, v28);
  v28.f32[0] = *(float *)&v29 + *(float *)&v31;
  *(float *)v35.f64 = *(float *)v33.i32 + *(float *)v34.i32;
  v28.f32[1] = *(float *)v33.i32 + *(float *)v34.i32;
  *(double *)v36.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v28.i64, v35, v29, v31, v32, v34, v33);
  float64x2_t v37 = (float64x2_t)v75;
  float32x4_t v76 = vaddq_f32(v75, v36);
  LODWORD(v38) = *((_DWORD *)this + 7);
  v36.f32[0] = *((float *)this + 6)
             + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v81.i8, 1), *((float *)this + 4), *(float *)v81.i32);
  LODWORD(v39) = *((_DWORD *)this + 9);
  *(float *)v37.f64 = *(float *)&v39
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v81.i8, 1), *(float *)&v38, *(float *)v81.i32);
  v36.i32[1] = LODWORD(v37.f64[0]);
  *(double *)&long long v42 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v36.i64, v37, v38, v39, v81, v40, v41);
  long long v80 = v42;
  float64x2_t v43 = (float64x2_t)v81;
  *(float32x2_t *)&long long v42 = vadd_f32(*(float32x2_t *)v81.i8, (float32x2_t)1082130432);
  *(float *)&double v44 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)&v42, 1), *((float *)this + 4), *(float *)&v42);
  LODWORD(v45) = *((_DWORD *)this + 7);
  v46.i32[0] = *((_DWORD *)this + 9);
  *(float *)v47.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)&v42, 1), *(float *)&v45, *(float *)&v42);
  *(float *)&long long v42 = *((float *)this + 6) + *(float *)&v44;
  *(float *)v43.f64 = *(float *)v46.i32 + *(float *)v47.i32;
  *((float *)&v42 + 1) = *(float *)v46.i32 + *(float *)v47.i32;
  *(double *)v49.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v42, v43, v44, v45, v47, v46, v48);
  __asm { FMOV            V1.2S, #-4.0 }
  HIDWORD(v51) = v81.i32[1];
  float32x2_t v52 = vadd_f32(*(float32x2_t *)v81.i8, _D1);
  *(float *)&double v53 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v52, 1), *((float *)this + 4), v52.f32[0]);
  LODWORD(v51) = *((_DWORD *)this + 6);
  v54.i32[0] = *((_DWORD *)this + 7);
  v55.i32[0] = *((_DWORD *)this + 9);
  *(float *)v56.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v52, 1), *(float *)v54.i32, v52.f32[0]);
  float64x2_t v57 = (float64x2_t)v76;
  float32x4_t v77 = vaddq_f32(v76, v49);
  v49.f32[0] = *(float *)&v51 + *(float *)&v53;
  *(float *)v57.f64 = *(float *)v55.i32 + *(float *)v56.i32;
  v49.f32[1] = *(float *)v55.i32 + *(float *)v56.i32;
  CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v49.i64, v57, v51, v53, v54, v56, v55);
  HIDWORD(v58) = v81.i32[1];
  float32x2_t v59 = vadd_f32(*(float32x2_t *)v81.i8, (float32x2_t)0xC080000000000000);
  *(float *)&double v60 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v59, 1), *((float *)this + 4), v59.f32[0]);
  LODWORD(v58) = *((_DWORD *)this + 6);
  v61.i32[0] = *((_DWORD *)this + 7);
  v62.i32[0] = *((_DWORD *)this + 9);
  *(float *)v63.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v59, 1), *(float *)v61.i32, v59.f32[0]);
  float64x2_t v64 = (float64x2_t)v78;
  *(float *)&double v65 = *(float *)&v58 + *(float *)&v60;
  *(float *)v64.f64 = *(float *)v62.i32 + *(float *)v63.i32;
  *((float *)&v65 + 1) = *(float *)v62.i32 + *(float *)v63.i32;
  CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v65, v64, v58, v60, v61, v63, v62);
  HIDWORD(v66) = v81.i32[1];
  float32x2_t v67 = vadd_f32(*(float32x2_t *)v81.i8, (float32x2_t)0xC080000040800000);
  *(float *)&double v68 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v67, 1), *((float *)this + 4), v67.f32[0]);
  LODWORD(v66) = *((_DWORD *)this + 6);
  v69.i32[0] = *((_DWORD *)this + 7);
  v70.i32[0] = *((_DWORD *)this + 9);
  *(float *)v71.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v67, 1), *(float *)v69.i32, v67.f32[0]);
  float64x2_t v72 = (float64x2_t)v77;
  *(float *)&double v73 = *(float *)&v66 + *(float *)&v68;
  *(float *)v72.f64 = *(float *)v70.i32 + *(float *)v71.i32;
  *((float *)&v73 + 1) = *(float *)v70.i32 + *(float *)v71.i32;
  CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v73, v72, v66, v68, v69, v71, v70);
  return (__n128)v80;
}

double cikernel::_edgesPrep(float32x4_t a1, double a2)
{
  *(float *)&a2 = fmaxf(a1.f32[3], 0.00001);
  float32x4_t v2 = vdivq_f32(a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a2, 0));
  v2.i32[3] = 0;
  float32x4_t v3 = vmaxnmq_f32(v2, (float32x4_t)0);
  v3.i32[3] = 0;
  *(void *)&double result = vsqrtq_f32(v3).u64[0];
  return result;
}

double cikernel::_findEdges(cikernel *this, SamplerObj *a2, float a3)
{
  DC = (float32x2_t *)CI::getDC(this);
  *(float32x2_t *)v5.i8 = *DC;
  float64x2_t v46 = (float64x2_t)v5;
  LODWORD(v6) = *((_DWORD *)this + 7);
  *(float *)&double v7 = *((float *)this + 6)
                + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *DC, 1), *((float *)this + 4), COERCE_FLOAT(*DC));
  LODWORD(v8) = *((_DWORD *)this + 9);
  *(float *)v9.f64 = *(float *)&v8
                   + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *DC, 1), *(float *)&v6, COERCE_FLOAT(*DC));
  HIDWORD(v7) = LODWORD(v9.f64[0]);
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v7, v9, v6, v8, v5, v10, v11);
  float32x4_t v43 = _Q0;
  __asm { FMOV            V0.2S, #1.0 }
  float64x2_t v17 = v46;
  *(float32x2_t *)_Q0.f32 = vadd_f32(*(float32x2_t *)&v46.f64[0], *(float32x2_t *)_Q0.f32);
  *(float *)&double v18 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)_Q0.f32, 1), *((float *)this + 4), _Q0.f32[0]);
  LODWORD(v19) = *((_DWORD *)this + 7);
  v20.i32[0] = *((_DWORD *)this + 9);
  *(float *)v21.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)_Q0.f32, 1), *(float *)&v19, _Q0.f32[0]);
  _Q0.f32[0] = *((float *)this + 6) + *(float *)&v18;
  *(float *)v17.f64 = *(float *)v20.i32 + *(float *)v21.i32;
  _Q0.f32[1] = *(float *)v20.i32 + *(float *)v21.i32;
  *(double *)v23.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)_Q0.i64, v17, v18, v19, v21, v20, v22);
  HIDWORD(v24) = HIDWORD(v46.f64[0]);
  float32x2_t v25 = vadd_f32(*(float32x2_t *)&v46.f64[0], (float32x2_t)0x3F80000000000000);
  *(float *)&double v26 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v25, 1), *((float *)this + 4), v25.f32[0]);
  LODWORD(v24) = *((_DWORD *)this + 6);
  v27.i32[0] = *((_DWORD *)this + 7);
  v28.i32[0] = *((_DWORD *)this + 9);
  *(float *)v29.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v25, 1), *(float *)v27.i32, v25.f32[0]);
  float64x2_t v30 = (float64x2_t)v43;
  float32x4_t v44 = vsubq_f32(v43, v23);
  v23.f32[0] = *(float *)&v24 + *(float *)&v26;
  *(float *)v30.f64 = *(float *)v28.i32 + *(float *)v29.i32;
  v23.f32[1] = *(float *)v28.i32 + *(float *)v29.i32;
  *(double *)v31.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v23.i64, v30, v24, v26, v27, v29, v28);
  float32x4_t v42 = v31;
  float64x2_t v32 = v46;
  *(float32x2_t *)v31.f32 = vadd_f32(*(float32x2_t *)&v46.f64[0], (float32x2_t)1065353216);
  *(float *)&double v33 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v31.f32, 1), *((float *)this + 4), v31.f32[0]);
  LODWORD(v34) = *((_DWORD *)this + 7);
  v35.i32[0] = *((_DWORD *)this + 9);
  *(float *)v36.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v31.f32, 1), *(float *)&v34, v31.f32[0]);
  v31.f32[0] = *((float *)this + 6) + *(float *)&v33;
  *(float *)v32.f64 = *(float *)v35.i32 + *(float *)v36.i32;
  v31.f32[1] = *(float *)v35.i32 + *(float *)v36.i32;
  *(double *)v38.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v31.i64, v32, v33, v34, v36, v35, v37);
  float32x4_t v39 = vsubq_f32(v42, v38);
  float32x4_t v40 = vmulq_n_f32(vaddq_f32(vmulq_f32(v44, v44), vmulq_f32(v39, v39)), a3);
  v40.f32[0] = fminf(fmaxf(fmaxf(v40.f32[0], v40.f32[1]), v40.f32[2]), 1.0);
  *(void *)&double result = vdupq_lane_s32(*(int32x2_t *)v40.f32, 0).u64[0];
  return result;
}

double cikernel::_sharpenCombineEdges(int8x16_t a1, int8x16_t a2, float32x4_t a3, float a4, double a5)
{
  *(float *)&a5 = fmaxf(*(float *)&a1.i32[3], 0.00001);
  float32x4_t v5 = vmulq_f32(a3, vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.i8, 0), (float32x4_t)vextq_s8(a2, a1, 4uLL)));
  float32x4_t v6 = vdivq_f32((float32x4_t)a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a5, 0));
  float32x4_t v7 = vaddq_f32((float32x4_t)a2, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))));
  float32x4_t v8 = vmulq_laneq_f32(vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_193956380, v6, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_193956370, *(float32x2_t *)v6.f32, 1), vaddq_f32(vmulq_n_f32((float32x4_t)xmmword_193956360, v6.f32[0]), (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmulq_f32(v7, v7), 0)))), (float32x4_t)a1, 3);
  v8.i32[3] = a1.i32[3];
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32((float32x4_t)a1, 1.0 - a4), v8, a4).u64[0];
  return result;
}

void CI::f4_s_s_f3_s(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = a1[6];
  int8x16_t v10 = (double (*)(void *, __n128, __n128, __n128, __n128))a1[3];
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  int v13 = *(_DWORD *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  uint64_t v15 = *(void *)(v9 + 56);
  int v16 = *(_DWORD *)(v9 + 88);
  uint64_t v17 = *(void *)(v9 + 80);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 104)), a2);
  }
  double v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5) {
    double v18 = (__n128 *)((char *)a2 + 64 * v17);
  }
  double v19 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    double v19 = (__n128 *)((char *)a2 + 64 * v14);
  }
  int8x16_t v20 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    int8x16_t v20 = (__n128 *)((char *)a2 + 64 * v12);
  }
  *(double *)&long long v21 = v10(a1, *v20, *v19, *((__n128 *)a2 + 4 * v15), *v18);
  *(_OWORD *)(a3 + 16 * a7) = v21;
}

double cikernel::_sharpenLuminance(float32x4_t a1, float32x4_t a2, float a3)
{
  float32x4_t v3 = vmulq_f32(a2, (float32x4_t)xmmword_193950AB0);
  int8x16_t v4 = (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1)));
  *(float32x2_t *)a2.f32 = vsub_f32((float32x2_t)vzip1_s32(*(int32x2_t *)a2.f32, (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a2, (int8x16_t)a2, 8uLL)), (float32x2_t)vdup_lane_s32(*(int32x2_t *)v4.i8, 0));
  float32x4_t v5 = (float32x4_t)vextq_s8(vextq_s8(v4, v4, 4uLL), (int8x16_t)a2, 0xCuLL);
  float32x4_t v6 = vmulq_f32(a1, (float32x4_t)xmmword_193950AB0);
  int8x16_t v7 = (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), vaddq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1)));
  int8x16_t v8 = vextq_s8((int8x16_t)a1, (int8x16_t)a1, 8uLL);
  *(float32x2_t *)v8.i8 = vsub_f32((float32x2_t)vzip1_s32(*(int32x2_t *)a1.f32, *(int32x2_t *)v8.i8), (float32x2_t)vdup_lane_s32(*(int32x2_t *)v7.i8, 0));
  float32x4_t v9 = vmlaq_n_f32(vmulq_n_f32(v5, 1.0 - (float)(a3 + 1.0)), (float32x4_t)vextq_s8(vextq_s8(v7, v7, 4uLL), v8, 0xCuLL), a3 + 1.0);
  float32x4_t v10 = vmulq_f32(v9, (float32x4_t)xmmword_193956440);
  a1.i32[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2), vaddq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1))).u32[0];
  *(float32x2_t *)v9.f32 = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v9.f32, 0), (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v9, (int8x16_t)v9, 4uLL));
  a1.i64[0] = vtrn2q_s32(vzip1q_s32((int32x4_t)a1, (int32x4_t)v9), (int32x4_t)a1).u64[0];
  return *(double *)a1.i64;
}

simd_float4 cikernel::_grassAndSkyAdjust(float32x4_t a1, double a2)
{
  float v54 = *(float *)&a2;
  unsigned __int32 v58 = a1.u32[3];
  float v2 = *((float *)&a2 + 1);
  float32x4_t v3 = vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_1939564D0, a1, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_1939564C0, *(float32x2_t *)a1.f32, 1), vmulq_n_f32((float32x4_t)xmmword_1939564B0, a1.f32[0])));
  v4.i64[0] = 0x8000000080000000;
  v4.i64[1] = 0x8000000080000000;
  __asm { FMOV            V2.4S, #1.0 }
  int8x16_t v49 = _Q2;
  float32x4_t v51 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v3), (int8x16_t)vcgtzq_f32(v3)), vorrq_s8(vandq_s8((int8x16_t)v3, v4), _Q2), (int8x16_t)0);
  simd_float4 v10 = (simd_float4)vabsq_f32(v3);
  v10.i32[3] = 0;
  _Q0 = vmulq_f32(v51, (float32x4_t)_simd_pow_f4(v10, (simd_float4)xmmword_1939564E0));
  float32x4_t v52 = vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_193956510, _Q0, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_193956500, *(float32x2_t *)_Q0.f32, 1), vmulq_n_f32((float32x4_t)xmmword_1939564F0, _Q0.f32[0])));
  _S8 = v52.i32[2];
  _S14 = v52.i32[1];
  __asm { FMLA            S0, S8, V1.S[2] }
  float v14 = atan2f(sqrtf(_Q0.f32[0]) - v52.f32[1], v52.f32[2]) / 3.1416 + 0.5;
  float v15 = v14 + -0.88;
  float v16 = exp(v15 * v15 / -0.015488);
  _V3.S[1] = v52.i32[1];
  float v18 = (float)(v52.f32[0] + -0.4) / 0.1;
  if (v18 <= 1.0) {
    float v19 = (float)(v52.f32[0] + -0.4) / 0.1;
  }
  else {
    float v19 = 1.0;
  }
  if (v18 >= 0.0) {
    float v20 = v19;
  }
  else {
    float v20 = 0.0;
  }
  float32x2_t v47 = (float32x2_t)vextq_s8((int8x16_t)v52, (int8x16_t)v52, 4uLL).u64[0];
  float v48 = (float)(1.0 - (float)((float)(v20 * v20) * (float)((float)(v20 * -2.0) + 3.0))) * v16;
  float32x2_t v46 = vsub_f32((float32x2_t)0x3DCCCCCDBCF5C28FLL, v47);
  __asm { FMLA            S0, S14, V3.S[1] }
  float v22 = _S0 * 4.0;
  float v23 = pow((float)(_S0 * 4.0), 0.2) * v54;
  float v24 = 0.1 / (sqrtf(vmlas_n_f32(COERCE_FLOAT(vmul_f32(v46, v46).i32[1]), v46.f32[0], v46.f32[0])) + 0.05);
  *(float32x2_t *)v25.i8 = vmul_n_f32(vadd_f32(v47, vmul_n_f32(vmul_n_f32(v46, fminf(fminf(1.0 - (float)(v22 * v22), 1.0) * v23, 1.5)), fminf(v24, 1.0))), v54);
  float32x4_t v26 = (float32x4_t)vextq_s8(v25, v25, 0xCuLL);
  v26.i32[0] = v52.i32[0];
  float32x4_t v27 = vmlaq_n_f32(vmulq_n_f32(v52, 1.0 - v48), v26, v48);
  float32x4_t v55 = v27;
  float v28 = (float)(v27.f32[0] + -0.2) / 0.3;
  if (v28 <= 1.0) {
    float v29 = (float)(v27.f32[0] + -0.2) / 0.3;
  }
  else {
    float v29 = 1.0;
  }
  if (v28 >= 0.0) {
    float v30 = v29;
  }
  else {
    float v30 = 0.0;
  }
  float v31 = (float)(v30 * v30) * (float)((float)(v30 * -2.0) + 3.0);
  float v32 = v27.f32[1] + 0.04;
  float v33 = exp(v32 * v32 / -0.045) * v31;
  float v34 = v55.f32[2] + 0.1;
  float v35 = exp(v34 * v34 / -0.08) * v33;
  float v53 = v35;
  float32x4_t v36 = vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_193956530, v55, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v55.f32, 0), vmulq_lane_f32((float32x4_t)xmmword_193956520, *(float32x2_t *)v55.f32, 1)));
  v37.i64[0] = 0x8000000080000000;
  v37.i64[1] = 0x8000000080000000;
  float32x4_t v56 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v36), (int8x16_t)vcgtzq_f32(v36)), vorrq_s8(vandq_s8((int8x16_t)v36, v37), v49), (int8x16_t)0);
  simd_float4 v38 = (simd_float4)vabsq_f32(v36);
  v38.i32[3] = 0;
  float32x4_t v39 = vmulq_f32((float32x4_t)_simd_pow_f4(v38, (simd_float4)xmmword_193956540), v56);
  float32x4_t v40 = vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_193956570, v39, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_193956560, *(float32x2_t *)v39.f32, 1), vmulq_n_f32((float32x4_t)xmmword_193956550, v39.f32[0])));
  v40.i32[3] = 0;
  float32x4_t v41 = vmaxnmq_f32(v40, (float32x4_t)0);
  v41.i32[3] = v58;
  float32x4_t v57 = v41;
  float v50 = fabsf(v2);
  simd_float4 result = _simd_pow_f4((simd_float4)vmulq_n_f32(v41, fmaxf(v2 + 1.0, 1.0)), (simd_float4)vdupq_lane_s32((int32x2_t)COERCE_UNSIGNED_INT(v50 + 1.0), 0));
  int32x2_t v42 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)result.f32, 1), vaddq_f32((float32x4_t)result, (float32x4_t)vdupq_laneq_s32((int32x4_t)result, 2))).u64[0];
  *(float *)v42.i32 = *(float *)v42.i32 / 3.0;
  v43.i64[0] = 0x3F0000003F000000;
  v43.i64[1] = 0x3F0000003F000000;
  float32x4_t v44 = vaddq_f32((float32x4_t)result, vmulq_f32(vmulq_n_f32(vsubq_f32((float32x4_t)result, (float32x4_t)vdupq_lane_s32(v42, 0)), v50), v43));
  v44.i32[3] = result.i32[3];
  result.i64[0] = vmlaq_n_f32(vmulq_n_f32(v57, 1.0 - v53), v44, v53).u64[0];
  result.i32[3] = v58;
  return result;
}

__n128 cikernel::_smartBlackAndWhite(uint64x2_t *a1, float32x4_t a2, float32x4_t a3, __n128 a4)
{
  double v46 = a4.n128_f64[0];
  float v48 = a4.n128_f32[2];
  float v5 = a4.n128_f32[3];
  __asm { FMOV            V1.4S, #1.0 }
  float32x4_t v49 = vminnmq_f32(vmaxnmq_f32(a2, (float32x4_t)0), _Q1);
  float32x4_t v11 = vmulq_f32(v49, (float32x4_t)xmmword_193956600);
  v11.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).u32[0];
  float32x4_t v12 = vmulq_f32(v49, (float32x4_t)xmmword_193956610);
  float32x4_t v13 = vmulq_f32(v49, (float32x4_t)xmmword_193956620);
  v11.i32[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))).u32[0];
  v11.i64[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2), vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1))).u32[0];
  float32x4_t v14 = (float32x4_t)_simd_pow_f4((simd_float4)v11, (simd_float4)xmmword_1939564E0);
  float32x4_t v15 = vmulq_f32(v14, (float32x4_t)xmmword_193956630);
  float v45 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 2), vaddq_f32(v15, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.f32, 1))).f32[0];
  float32x4_t v16 = vmulq_f32(v14, (float32x4_t)xmmword_193956640);
  v16.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 2), vaddq_f32(v16, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v16.f32, 1))).u32[0];
  float32x4_t v17 = vmulq_f32(v14, (float32x4_t)xmmword_193956650);
  float32x4_t v18 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 2), vaddq_f32(v17, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1)));
  float v19 = sqrtf(vmlas_n_f32(vmulq_f32(v18, v18).f32[0], v16.f32[0], v16.f32[0]));
  float v20 = atan2f(v18.f32[0], v16.f32[0]);
  v21.f64[0] = 0.5;
  float v22 = v20 / 6.28318531 + 0.5;
  *(float *)v21.f64 = vmlas_n_f32(*((float *)&v46 + 1), v22, *(float *)&v46);
  *(double *)v27.i64 = CI::BitmapSampler::read(a1, COERCE_DOUBLE(LODWORD(v21.f64[0]) | 0x3F00000000000000), v21, v46, v23, v24, v25, v26);
  float32x4_t v28 = vmulq_f32(a3, v27);
  float v29 = fabs(v45 + -0.5) * 0.53 + 0.06;
  if ((float)(25.0 * v45) <= 1.0) {
    float v30 = 25.0 * v45;
  }
  else {
    float v30 = 1.0;
  }
  if ((float)(25.0 * v45) >= 0.0) {
    float v31 = v30;
  }
  else {
    float v31 = 0.0;
  }
  float v32 = (float)(v31 * v31) * (float)((float)(v31 * -2.0) + 3.0);
  float v33 = v19 / v29;
  if (v33 <= 1.0) {
    float v34 = v33;
  }
  else {
    float v34 = 1.0;
  }
  if (v33 >= 0.0) {
    float v35 = v34;
  }
  else {
    float v35 = 0.0;
  }
  float v36 = (1.0 - v45) * (float)((float)(v35 * v35) * (float)((float)(v35 * -2.0) + 3.0)) * v32 * (v28.f32[3] + -1.0) + 1.0;
  float32x4_t v37 = vmulq_f32(a3, v49);
  float v38 = powf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v37, 2), vaddq_f32(v37, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.f32, 1))).f32[0], v36);
  if ((float)(v19 * 10.0) <= 1.0) {
    float v39 = v19 * 10.0;
  }
  else {
    float v39 = 1.0;
  }
  if ((float)(v19 * 10.0) >= 0.0) {
    float v40 = v39;
  }
  else {
    float v40 = 0.0;
  }
  float v41 = (1.0 - v38)
      * v38
      * (float)(1.0 - (float)((float)(v40 * v40) * (float)((float)(v40 * -2.0) + 3.0)))
      * (v48 + -1.0)
      + 1.0;
  float v42 = v41 * -4.0 + 5.0;
  result.n128_f32[0] = powf(v38, v42);
  float v43 = result.n128_f32[0] * -2.1972 * result.n128_f32[0]
      + result.n128_f32[0] * 1.8031 * result.n128_f32[0] * result.n128_f32[0]
      + result.n128_f32[0] * 1.3823;
  result.n128_f32[0] = (float)(result.n128_f32[0] * (float)(v5 + 1.0)) - (float)(v5 * v43);
  result.n128_u64[0] = vdupq_lane_s32((int32x2_t)result.n128_u64[0], 0).u64[0];
  result.n128_u32[3] = v49.u32[3];
  return result;
}

void CI::f4_s_sr2d_f4_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  simd_float4 v10 = *(double (**)(uint64_t, __n128, __n128, __n128))(a1 + 24);
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *((void *)a2 + 8 * *(void *)(v9 + 32));
  uint64_t v13 = *(void *)(v9 + 8);
  int v14 = *(_DWORD *)(v9 + 64);
  uint64_t v15 = *(void *)(v9 + 56);
  int v16 = *(_DWORD *)(v9 + 88);
  uint64_t v17 = *(void *)(v9 + 80);
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 104)), a2);
  }
  float32x4_t v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5) {
    float32x4_t v18 = (__n128 *)((char *)a2 + 64 * v17);
  }
  float v19 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5) {
    float v19 = (__n128 *)((char *)a2 + 64 * v15);
  }
  float v20 = (__n128 *)(a3 + 16 * v13);
  if (v11 != 5) {
    float v20 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v21 = v10(v12, *v20, *v19, *v18);
  *(_OWORD *)(a3 + 16 * a7) = v21;
}

uint64_t anonymous namespace'::smart_tone_stats_from_histogram(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = 0;
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  *(void *)(a2 + 72) = 0;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  long double v5 = 0.0;
  long double v6 = 0.0;
  do
  {
    double v7 = fmin((double)v4 / 255.0, 1.0);
    double v8 = *(double *)(a1 + 8 * v4);
    long double v5 = v5 + v8 * log(v7 + 0.00392156863);
    *(long double *)a2 = v5;
    long double v6 = v6 + v8 * log(1.0 - v7 + 0.00392156863);
    *(long double *)(a2 + 8) = v6;
    ++v4;
  }
  while (v4 != 512);
  *(long double *)a2 = exp(v5);
  *(long double *)(a2 + 8) = exp(v6);
  uint64_t result = MEMORY[0x1F4188790](v9, v10, v11, v12, v13, v14);
  uint64_t v17 = 0;
  double v18 = 1.0e-40;
  do
  {
    double v18 = v18 + *(double *)(a1 + v17);
    v17 += 8;
  }
  while (v17 != 4096);
  uint64_t v19 = 0;
  double v20 = 0.0;
  do
  {
    double v20 = v20 + *(double *)(a1 + v19);
    *(double *)&v37[v19] = v20 / v18;
    v19 += 8;
  }
  while (v19 != 4096);
  unint64_t v21 = 0;
  double v22 = 0.0;
  *(_OWORD *)(a2 + 16) = 0u;
  *(void *)(a2 + 48) = 0;
  *(_OWORD *)(a2 + 32) = 0u;
  double v23 = 0.0;
  double v24 = 0.0;
  double v25 = 0.0;
  double v26 = 0.0;
  double v27 = 0.0;
  double v28 = 0.0;
  do
  {
    double v29 = *(double *)&v37[8 * v21];
    if (v29 >= 0.001 && v22 == 0.0) {
      double v22 = (double)v21 / 255.0;
    }
    if (v29 >= 0.02 && v23 == 0.0)
    {
      double v23 = (double)v21 / 255.0;
      *(double *)(a2 + 16) = v23;
    }
    if (v29 >= 0.1 && v24 == 0.0)
    {
      double v24 = (double)v21 / 255.0;
      *(double *)(a2 + 24) = v24;
    }
    if (v29 >= 0.25 && v25 == 0.0)
    {
      double v25 = (double)v21 / 255.0;
      *(double *)(a2 + 32) = v25;
    }
    if (v29 >= 0.5 && v26 == 0.0)
    {
      double v26 = (double)v21 / 255.0;
      *(double *)(a2 + 40) = v26;
    }
    if (v29 >= 0.98 && v27 == 0.0)
    {
      double v27 = (double)v21 / 255.0;
      *(double *)(a2 + 48) = v27;
    }
    if (v29 >= 1.0 && v28 == 0.0)
    {
      double v28 = (double)v21 / 255.0;
      *(double *)(a2 + 72) = v28;
    }
    ++v21;
  }
  while (v21 != 512);
  *(double *)(a2 + 64) = v22 * ((sqrt(v22) * -0.65 + 1.0) * 0.85);
  double v30 = 0.6 - v26 - v25;
  BOOL v31 = v28 < 1.0 && v16 < 0.8;
  double v32 = v30 + fmin(0.8 - v16, 0.2);
  double v33 = v30 * 0.9;
  if (v31) {
    double v33 = v32;
  }
  double v34 = v26 + v25;
  if (v26 + v25 > 0.6)
  {
    if (v27 >= 1.0) {
      double v35 = -0.4;
    }
    else {
      double v35 = -0.7;
    }
    double v33 = v34 + v35;
  }
  double v36 = fmax(v33, 0.1);
  if (v26 <= 0.14 || v23 <= 0.015 || v27 <= 0.95)
  {
    if (v23 > 0.055) {
      double v36 = -v36;
    }
  }
  else
  {
    double v36 = -v36;
  }
  *(double *)(a2 + 56) = v36 * 0.68;
  return result;
}

uint64_t anonymous namespace'::assemble_smart_tone_stats(void *a1, uint64_t a2, double a3)
{
  objc_msgSend((id)objc_msgSend(a1, "objectForKey:", @"tonalRange"), "doubleValue");
  *(void *)a2 = v6;
  objc_msgSend((id)objc_msgSend(a1, "objectForKey:", @"highKey"), "doubleValue");
  *(void *)(a2 + 8) = v7;
  objc_msgSend((id)objc_msgSend(a1, "objectForKey:", @"p02"), "doubleValue");
  *(void *)(a2 + 16) = v8;
  objc_msgSend((id)objc_msgSend(a1, "objectForKey:", @"p10"), "doubleValue");
  *(void *)(a2 + 24) = v9;
  objc_msgSend((id)objc_msgSend(a1, "objectForKey:", @"p25"), "doubleValue");
  *(void *)(a2 + 32) = v10;
  objc_msgSend((id)objc_msgSend(a1, "objectForKey:", @"p50"), "doubleValue");
  *(void *)(a2 + 40) = v11;
  objc_msgSend((id)objc_msgSend(a1, "objectForKey:", @"p98"), "doubleValue");
  *(void *)(a2 + 48) = v12;
  objc_msgSend((id)objc_msgSend(a1, "objectForKey:", @"autoValue"), "doubleValue");
  *(void *)(a2 + 56) = v13;
  objc_msgSend((id)objc_msgSend(a1, "objectForKey:", @"blackPoint"), "doubleValue");
  *(void *)(a2 + 64) = v14;
  uint64_t result = objc_msgSend((id)objc_msgSend(a1, "objectForKey:", @"whitePoint"), "doubleValue");
  *(void *)(a2 + 72) = v16;
  *(double *)(a2 + 80) = a3;
  return result;
}

void anonymous namespace'::smart_tone_adjustments_from_stats(uint64_t a1, double *a2, double a3)
{
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  double v5 = a2[6];
  if (a3 == 0.0 || v5 >= 0.01)
  {
    double v6 = a2[10];
    double v7 = fabs(v6);
    double v8 = a3 * 0.75;
    BOOL v9 = v7 < 1.0e-10;
    if (v7 >= 1.0e-10) {
      double v10 = a3 * 0.75;
    }
    else {
      double v10 = a3;
    }
    double v11 = 0.0;
    if (!v9)
    {
      double v12 = fabs(a3) * 0.75 * v6;
      double v13 = a2[7];
      double v11 = v12 / fabs(v13);
      if (v11 > v6) {
        double v11 = v6 - fabs(v13 * 0.75) + fabs(v8) * 0.5;
      }
    }
    *(double *)(a1 + 48) = v11;
    double v14 = a2[2];
    double v15 = pow(fabs(v10 / 1.5), 1.3) * 1.5;
    double v16 = a2[4];
    double v17 = *a2;
    double v18 = a2[1];
    double v19 = fmin(v5, v18);
    double v20 = 0.5;
    long double v21 = a2[9];
    double v46 = v21;
    if (v21 <= 1.0)
    {
      double v27 = 1.0 - v5 - v15;
    }
    else
    {
      double v22 = v14;
      double v23 = a2[4];
      double v24 = v10;
      double v25 = *a2;
      long double v26 = log2(v21);
      double v20 = 0.5;
      double v17 = v25;
      double v10 = v24;
      double v16 = v23;
      double v14 = v22;
      double v27 = -0.25 - v26;
    }
    double v28 = v5 - v14;
    double v29 = fmax(v19, v20);
    double v30 = fmax(v27, -0.25);
    if (v10 >= 0.0)
    {
      double v32 = v16 + -0.14;
      double v33 = fmax(-v15, -0.25);
      if (v46 == 1.0) {
        double v30 = v33;
      }
      if (v32 >= 0.0)
      {
        if (v5 < 0.82)
        {
          if (v32 < 0.06) {
            double v32 = sqrt(v32);
          }
          double v32 = v32 * -2.0;
        }
      }
      else
      {
        BOOL v36 = v32 <= -0.05;
        double v34 = v32 * 3.5;
        double v32 = sqrt(-v32) * -3.0;
        if (v36) {
          double v32 = v34;
        }
      }
      double v35 = a2[5];
      if (v28 < 0.68 && v35 < 0.35 && v14 > 0.04) {
        double v32 = v32 / (v28 * (v18 - v17));
      }
      if (v35 - v16 > 0.35) {
        double v32 = v32 * 2.5;
      }
      BOOL v36 = v16 <= 0.7 && a2[3] <= 0.45;
      if (!v36) {
        double v32 = -v32;
      }
      if (v32 > 0.0) {
        double v32 = -v32;
      }
      double v37 = fmax(fmin(v32, 0.8), -0.8);
      double v38 = fmin(fmin(v15 * 1.75 / v28, v15 + v15) / 3.4, 1.0);
      double v39 = fmin(0.35 / v28 * (1.0 - v35) / v29, 0.85);
      if (v39 < 0.5 && v16 < 0.08) {
        double v41 = v39 * 1.5;
      }
      else {
        double v41 = v39;
      }
      double v42 = v38 * 0.65;
      if (v18 < 0.4) {
        double v37 = v37 * 1.2;
      }
      else {
        double v42 = v38;
      }
      if (v18 >= 0.4) {
        double v43 = v41;
      }
      else {
        double v43 = v41 * 1.25;
      }
      *(double *)a1 = v10 * v30 * 0.5;
      *(double *)(a1 + 8) = v42;
      *(double *)(a1 + 16) = -(v10 * v37);
      *(double *)(a1 + 24) = fmin(v15 * 0.95 * v43, 1.0);
      double v44 = v15 * 0.8;
      if (v5 <= 0.85) {
        double v44 = v5 * (v10 * 0.8);
      }
      *(double *)(a1 + 32) = -fmin(v44, 0.75);
      if (v46 > 1.0)
      {
        *(double *)(a1 + 56) = 1.0 / (v46 * 1.25);
        *(double *)(a1 + 32) = -fmin(v5 * (v15 * 0.65), 0.75);
      }
      double v45 = fmin(v10 * 20.0 * a2[8] / fabs(a2[7]), a2[8] * 20.0);
      double v31 = fmax(v45 + v42 * -2.0 * v45, 0.0);
    }
    else
    {
      *(double *)(a1 + 8) = fmin(1.0 / v28, 1.25) * v10 / -3.0;
      *(double *)(a1 + 16) = v10 * 0.6666667;
      *(double *)(a1 + 24) = -(v10 * fmin(v29 * 0.75, 0.5));
      *(double *)(a1 + 32) = fmin(v5 * (v10 * 0.8), 0.75);
      if (v46 > 1.0)
      {
        *(double *)a1 = v10 * (fabs(v30) * 0.625);
        *(double *)(a1 + 56) = 1.0 / (v46 * 1.25);
        *(double *)(a1 + 32) = fmax(v15 * -0.75 * v46, -1.0);
      }
      double v31 = fmin(v10 * -20.0 * a2[8] / fabs(a2[7]), a2[8] * 20.0);
    }
    *(double *)(a1 + 40) = v31;
  }
}

float32x4_t cikernel::_smarttone_brightness_neg(float32x4_t a1, int32x2_t a2)
{
  unsigned __int32 v13 = a1.u32[3];
  a1.i32[3] = 0;
  float32x4_t v12 = a1;
  simd_float4 v2 = (simd_float4)vmaxnmq_f32(a1, (float32x4_t)0);
  float32x4_t v14 = (float32x4_t)v2;
  v2.i32[3] = 0;
  float v10 = *(float *)a2.i32;
  simd_float4 v3 = (simd_float4)vdupq_lane_s32(a2, 0);
  v3.i32[3] = 0;
  float32x4_t v4 = (float32x4_t)_simd_pow_f4(v2, v3);
  float32x4_t v5 = vmulq_f32(v14, (float32x4_t)xmmword_193956720);
  float32x4_t result = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1)));
  float32x4_t v7 = 0uLL;
  if (result.f32[0] > 0.0)
  {
    float v8 = v10;
    int32x2_t v9 = *(int32x2_t *)result.f32;
    float32x4_t v11 = v4;
    result.f32[0] = powf(result.f32[0], v8);
    float32x4_t v4 = v11;
    float32x4_t v7 = vdivq_f32(vmulq_n_f32(v14, result.f32[0]), (float32x4_t)vdupq_lane_s32(v9, 0));
  }
  result.i64[0] = vaddq_f32(vminnmq_f32(v12, (float32x4_t)0), vmlaq_f32(vmulq_f32(v4, (float32x4_t)vdupq_n_s32(0x3E4CCCCCu)), (float32x4_t)vdupq_n_s32(0x3F4CCCCDu), v7)).u64[0];
  result.i32[3] = v13;
  return result;
}

float32x4_t cikernel::_smarttone_brightness_pos(float32x4_t a1, double a2)
{
  float v18 = *(float *)&a2;
  unsigned __int32 v25 = a1.u32[3];
  float32x4_t v2 = a1;
  v2.i32[3] = 0;
  float32x4_t v24 = vminnmq_f32(v2, (float32x4_t)0);
  __asm { FMOV            V4.4S, #-1.0 }
  float32x4_t v23 = vaddq_f32(vmaxnmq_f32(v2, (float32x4_t)xmmword_1939508C0), _Q4);
  float32x4_t v8 = vmaxnmq_f32(v2, (float32x4_t)0);
  v8.i32[3] = 0;
  __asm { FMOV            V2.4S, #1.0 }
  float32x4_t v20 = _Q2;
  float32x4_t v22 = vminnmq_f32(v8, (float32x4_t)xmmword_1939508C0);
  simd_float4 v10 = (simd_float4)vsubq_f32(_Q2, v22);
  float32x4_t v19 = (float32x4_t)v10;
  v10.i32[3] = 0;
  simd_float4 v11 = (simd_float4)vdupq_lane_s32(*(int32x2_t *)&a2, 0);
  v11.i32[3] = 0;
  float32x4_t v12 = (float32x4_t)_simd_pow_f4(v10, v11);
  float32x4_t v13 = vsubq_f32(v20, vmulq_f32(v19, v19));
  float32x4_t v14 = vmulq_f32(vmulq_n_f32(v19, v18 + -1.0), v13);
  v13.f32[0] = v18 * v18;
  float32x4_t v21 = vsubq_f32(v20, vaddq_f32(v12, vmulq_f32(vdivq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 0)), (float32x4_t)vdupq_n_s32(0x3F19999Au))));
  v14.i64[0] = 1.0;
  v14.f32[0] = (fminf(v18, 2.95) + -1.0) / -2.6 + 1.0;
  simd_float4 v15 = (simd_float4)v22;
  v15.i32[3] = 0;
  simd_float4 v16 = (simd_float4)vdupq_lane_s32(*(int32x2_t *)v14.f32, 0);
  v16.i32[3] = 0;
  float32x4_t result = (float32x4_t)_simd_pow_f4(v15, v16);
  result.i64[0] = vaddq_f32(v23, vaddq_f32(v24, vmlaq_f32(vmulq_f32(result, (float32x4_t)vdupq_n_s32(0x3E199998u)), (float32x4_t)vdupq_n_s32(0x3F59999Au), v21))).u64[0];
  result.i32[3] = v25;
  return result;
}

double cikernel::_smarttone_contrast(float32x4_t a1, float a2)
{
  a1.i32[3] = 0;
  __asm { FMOV            V6.4S, #-1.0 }
  float32x4_t v9 = vmaxnmq_f32(a1, (float32x4_t)0);
  v9.i32[3] = 0;
  float32x4_t v10 = vaddq_f32(vmaxnmq_f32(a1, (float32x4_t)xmmword_1939508C0), _Q6);
  float32x4_t v11 = vminnmq_f32(v9, (float32x4_t)xmmword_1939508C0);
  float32x4_t v12 = vmulq_f32(v11, (float32x4_t)vdupq_n_s32(0x3EAAA64Cu));
  v12.f32[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))).f32[0]);
  v9.f32[0] = (float)((float)((float)(v11.f32[1] - v12.f32[0]) * (float)(v11.f32[1] - v12.f32[0]))
                    + (float)((float)(v11.f32[0] - v12.f32[0]) * (float)(v11.f32[0] - v12.f32[0])))
            + (float)((float)(v11.f32[2] - v12.f32[0]) * (float)(v11.f32[2] - v12.f32[0]));
  *(double *)v12.i64 = v12.f32[0];
  double v13 = 1.0 - *(double *)v12.i64;
  v12.f32[0] = (1.0 - *(double *)v12.i64) * *(double *)v12.i64;
  double v14 = (float)(v12.f32[0] * a2);
  *(float *)&double v13 = (float)(v12.f32[0] * a2) * -0.5;
  *(double *)v2.i64 = v14 * 0.299;
  double v15 = v14 * 0.587;
  double v16 = v14 * 0.114;
  v11.i32[3] = 0;
  float32x4_t v17 = vsqrtq_f32(v11);
  v2.f32[0] = *(double *)v2.i64;
  *(float *)&double v15 = v15;
  *(float *)&double v16 = v16;
  float32x4_t v18 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v13, 0), vaddq_f32(v17, vaddq_f32(vmulq_laneq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v16, 0), v17, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v15, 0), *(float32x2_t *)v17.f32, 1), (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmulq_f32(v17, v2), 0)))));
  v19.i64[0] = 0x3F0000003F000000;
  v19.i64[1] = 0x3F0000003F000000;
  float32x4_t v20 = vmlaq_n_f32(vmulq_n_f32(v17, 1.0 - (float)-(float)(v12.f32[0] * a2)), v19, -(float)(v12.f32[0] * a2));
  float v21 = v9.f32[0] + 0.8;
  float32x4_t v22 = vmlaq_n_f32(vmulq_n_f32(v20, 1.0 - v21), v18, v21);
  v22.i32[3] = 0;
  float32x4_t v23 = vmaxnmq_f32(v22, (float32x4_t)0);
  *(void *)&double result = vaddq_f32(v10, vaddq_f32(vminnmq_f32(a1, (float32x4_t)0), vmulq_f32(v23, v23))).u64[0];
  return result;
}

float32x4_t cikernel::_smarttone_highlightcontrast(float32x4_t a1, float a2, float a3)
{
  float32x4_t v4 = vmulq_f32(a1, (float32x4_t)vdupq_n_s32(0x3EAAA64Cu));
  float32x4_t v5 = a1;
  float v6 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).f32[0];
  if (v6 <= 1.0) {
    float v7 = v6;
  }
  else {
    float v7 = 1.0;
  }
  BOOL v8 = v6 < 0.0;
  int32x2_t v9 = 0;
  if (!v8) {
    *(float *)v9.i32 = v7;
  }
  v5.i32[3] = 0;
  int32x2_t v16 = v9;
  simd_float4 v10 = (simd_float4)vmaxnmq_f32(v5, (float32x4_t)0);
  double v11 = a2 * -2.0 + 3.0;
  *(float *)&double v11 = v11;
  v10.i32[3] = 0;
  simd_float4 v12 = (simd_float4)vdupq_lane_s32(*(int32x2_t *)&v11, 0);
  v12.i32[3] = 0;
  float32x4_t result = vaddq_f32((float32x4_t)_simd_pow_f4(v10, v12), vminnmq_f32(v5, (float32x4_t)0));
  float v13 = a2 * -3.0 + 4.0;
  double v14 = (float)((float)((float)(a2 * a2) * a2) * a2) * -3.0 + 4.0;
  *(float *)&double v14 = v14;
  *(float *)&double v14 = (float)((float)(*(float *)v16.i32 + -0.8) * *(float *)&v14) + 0.8;
  result.i64[0] = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - (float)(*(float *)v16.i32 * *(float *)v16.i32)), vmlaq_n_f32(vmulq_n_f32(vsubq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v14, 0), result), (float32x4_t)vdupq_lane_s32(v16, 0)), 1.0 - a3), vaddq_f32(vmulq_n_f32(vaddq_f32(result, (float32x4_t)vdupq_n_s32(0xBF4CCCCD)), v13), (float32x4_t)vdupq_n_s32(0x3F4CCCCDu)), a3), *(float *)v16.i32 * *(float *)v16.i32).u64[0];
  result.i32[3] = a1.i32[3];
  return result;
}

double cikernel::_rawHighlights(float32x4_t a1, float a2)
{
  float32x4_t v2 = vmulq_n_f32(a1, a2);
  float32x4_t v3 = vmulq_f32(a1, (float32x4_t)vdupq_n_s32(0x3EAAA64Cu));
  float v4 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))).f32[0];
  if (v4 <= 1.0) {
    float v5 = v4;
  }
  else {
    float v5 = 1.0;
  }
  BOOL v6 = v4 < 0.0;
  float v7 = 0.0;
  if (!v6) {
    float v7 = v5;
  }
  float32x4_t v8 = v2;
  v8.i32[3] = 0;
  float32x4_t v9 = a1;
  v9.i32[3] = 0;
  *(void *)&double result = vaddq_f32(vminnmq_f32(v8, (float32x4_t)0), vmlaq_n_f32(vmulq_n_f32(vmaxnmq_f32(v9, (float32x4_t)0), 1.0 - (float)(v7 * v7)), v2, v7 * v7)).u64[0];
  return result;
}

uint64_t ___ZL22CI_SMART_TONE_USE_CUBEv_block_invoke()
{
  id v0 = getenv("CI_SMART_TONE_USE_CUBE");
  if (v0) {
    uint64_t result = atoi(v0);
  }
  else {
    uint64_t result = CI_SMART_TONE_USE_CUBE(void)::v;
  }
  CI_SMART_TONE_USE_CUBE(void)::v = result;
  return result;
}

double cikernel::_smartcolor_contrast(float32x4_t a1, float a2)
{
  float32x4_t v2 = vmulq_f32(a1, (float32x4_t)xmmword_193956730);
  float32x4_t v3 = vaddq_f32(vsubq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v2, 2), vaddq_f32(v2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v2.f32, 1))), 0), a1), (float32x4_t)0);
  float32x4_t v4 = vmulq_f32(v3, v3);
  float v5 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).f32[0]);
  if (v5 > 1.0) {
    float v5 = 1.0;
  }
  float v6 = (float)((float)(v5 * v5) * (float)((float)(v5 * -2.0) + 3.0)) * 5.0 * a2;
  float32x4_t v7 = a1;
  v7.i32[3] = 0;
  __asm { FMOV            V7.4S, #-1.0 }
  float32x4_t v13 = vaddq_f32(vminnmq_f32(v7, (float32x4_t)0), vaddq_f32(vmaxnmq_f32(v7, (float32x4_t)xmmword_1939508C0), _Q7));
  float32x4_t v14 = vmaxnmq_f32(v7, (float32x4_t)0);
  v14.i32[3] = 0;
  float32x4_t v15 = vminnmq_f32(v14, (float32x4_t)xmmword_1939508C0);
  float32x2_t v16 = (float32x2_t)vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 2), v15).u64[0];
  float v17 = fmaxf(vmuls_lane_f32(v6, v16, 1), -0.35);
  v16.f32[0] = v17 + 1.0;
  *(void *)&double result = vaddq_f32(v13, vdivq_f32(v15, vsubq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)v16, 0), vmulq_n_f32(v15, v17)))).u64[0];
  return result;
}

double cikernel::_smartcolor_contrast_darken(float32x4_t a1, float a2)
{
  float32x4_t v3 = vmulq_f32(a1, (float32x4_t)xmmword_193956730);
  float32x4_t v4 = vaddq_f32(vsubq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))), 0), a1), (float32x4_t)0);
  float32x4_t v5 = vmulq_f32(v4, v4);
  float32x4_t v6 = vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1));
  float v7 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), v6).f32[0]);
  if (v7 > 1.0) {
    float v7 = 1.0;
  }
  double v12 = a2;
  float32x4_t v8 = a1;
  v8.i32[3] = 0;
  *(float *)&double v12 = (float)((float)(v7 * v7) * (float)((float)(v7 * -2.0) + 3.0)) * 5.0 * v12;
  float32x4_t v9 = vmaxnmq_f32(v8, (float32x4_t)0);
  v9.i32[3] = 0;
  float32x4_t v10 = (float32x4_t)xmmword_1939508C0;
  float32x4_t v11 = vminnmq_f32(v9, (float32x4_t)xmmword_1939508C0);
  *(float *)&double v12 = vmuls_lane_f32(*(float *)&v12, (float32x2_t)*(_OWORD *)&vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), v11), 1);
  if (*(float *)&v12 >= 0.0)
  {
    v6.f32[0] = *(float *)&v12 + 1.0;
    float32x4_t v15 = vdivq_f32(v11, vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 0), vmulq_n_f32(v11, *(float *)&v12)));
  }
  else
  {
    float32x4_t v13 = vmulq_f32(v11, (float32x4_t)xmmword_193956740);
    float32x4_t v22 = v8;
    *(float *)&double v12 = 1.0
                   - (float)(*(float *)&v12
                           * (float)(1.0
                                   - fminf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2), vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1))).f32[0], 1.0)));
    v11.i32[3] = 0;
    simd_float4 v14 = (simd_float4)vdupq_lane_s32(*(int32x2_t *)&v12, 0);
    v14.i32[3] = 0;
    float32x4_t v15 = (float32x4_t)_simd_pow_f4((simd_float4)v11, v14);
    float32x4_t v10 = (float32x4_t)xmmword_1939508C0;
    float32x4_t v8 = v22;
  }
  __asm { FMOV            V3.4S, #-1.0 }
  *(void *)&double result = vaddq_f32(v15, vaddq_f32(vminnmq_f32(v8, (float32x4_t)0), vaddq_f32(vmaxnmq_f32(v8, v10), _Q3))).u64[0];
  return result;
}

double cikernel::_smartcolor_vibrancy_gt1(float32x4_t a1, float a2)
{
  float32x4_t v2 = a1;
  v2.i32[3] = 0;
  float32x4_t v3 = vmaxnmq_f32(v2, (float32x4_t)0);
  v3.i32[3] = 0;
  float32x4_t v4 = vminnmq_f32(v3, (float32x4_t)xmmword_1939508C0);
  float32x4_t v5 = vmulq_f32(v4, (float32x4_t)xmmword_193956750);
  double v6 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))).f32[0];
  float v8 = 1.0 / (float)(a1.f32[2] + vaddv_f32(*(float32x2_t *)a1.f32));
  float v9 = (float)((float)((float)(v8 * a1.f32[0]) - vmuls_lane_f32(v8, a1, 2)) + -0.2) / 0.2;
  if (v9 <= 1.0) {
    float v10 = v9;
  }
  else {
    float v10 = 1.0;
  }
  if (v9 < 0.0) {
    float v10 = 0.0;
  }
  float v11 = (float)((float)(v10 * v10) * (float)((float)(v10 * -2.0) + 3.0)) * -0.8 + 1.0;
  float v7 = v6 * -4.0 * (1.0 - v6) + 1.0;
  float v12 = v11 * v7;
  if (a2 > 2.5)
  {
    float v13 = (a2 + -2.5) / 5.0 + v12;
    float v12 = fminf(v13, 1.0);
  }
  float32x4_t v14 = vmulq_f32(v4, (float32x4_t)xmmword_193956760);
  float32x4_t v15 = (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))), 0);
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - v12), vaddq_f32(v15, vmulq_n_f32(vsubq_f32(a1, v15), fminf(a2, 3.0))), v12).u64[0];
  return result;
}

double cikernel::_smartcolor_vibrancy_lt1(float32x4_t a1, float a2)
{
  float32x4_t v2 = vmulq_f32(a1, (float32x4_t)vdupq_n_s32(0x3EAAAA9Fu));
  v2.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v2, 2), vaddq_f32(v2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v2.f32, 1))).u64[0];
  v2.f32[0] = (float)(1.0 - a2) * v2.f32[0];
  *(void *)&double result = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v2.f32, 0), a1, a2).u64[0];
  return result;
}

float32x4_t cikernel::_smartcolor_cast(float32x4_t a1, float a2, float a3, float a4, float a5)
{
  __asm { FMOV            V1.4S, #1.0 }
  simd_float4 v12 = (simd_float4)vminnmq_f32(vmaxnmq_f32(a1, (float32x4_t)0), _Q1);
  unsigned __int32 v30 = v12.u32[3];
  v12.i32[3] = 0;
  float32x4_t v13 = (float32x4_t)_simd_pow_f4(v12, (simd_float4)xmmword_1939507B0);
  float32x4_t v14 = vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_1939507A0, v13, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_193950790, *(float32x2_t *)v13.f32, 1), vmulq_n_f32((float32x4_t)xmmword_193950780, v13.f32[0])));
  v15.i64[1] = v28;
  float v16 = (a5 + -1.0) * (1.0 - v14.f32[0]) + 1.0;
  int8x16_t v17 = vextq_s8((int8x16_t)v14, (int8x16_t)v14, 4uLL);
  *(float32x2_t *)v15.i8 = vadd_f32(*(float32x2_t *)v17.i8, vmul_n_f32((float32x2_t)__PAIR64__(LODWORD(a4), LODWORD(a3)), v16));
  float v18 = v14.f32[0] / (a2 + 0.00001);
  float v19 = fmaxf(fminf(v18, 1.0), 0.0);
  float32x4_t v20 = vmlaq_n_f32(vmulq_n_f32(v14, 1.0 - v19), (float32x4_t)vextq_s8(v17, v15, 0xCuLL), v19);
  float32x4_t v21 = vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_193950800, v20, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 0), vmulq_lane_f32((float32x4_t)xmmword_1939507F0, *(float32x2_t *)v20.f32, 1)));
  v21.i32[3] = 0;
  float32x4_t v22 = vmaxnmq_f32(v21, (float32x4_t)0);
  v22.i32[3] = 0;
  float32x4_t result = vminnmq_f32(v22, (float32x4_t)xmmword_1939508C0);
  float32x4_t v23 = a1;
  v23.i32[3] = 0;
  __asm { FMOV            V2.4S, #-1.0 }
  result.i64[0] = vaddq_f32(vmulq_f32(result, vmulq_f32(result, vmulq_f32(result, result))), vaddq_f32(vaddq_f32(vminnmq_f32(v23, (float32x4_t)0), vmaxnmq_f32(v23, (float32x4_t)xmmword_1939508C0)), _Q2)).u64[0];
  result.i32[3] = v30;
  return result;
}

uint64_t ___ZL23CI_SMART_COLOR_USE_CUBEv_block_invoke()
{
  id v0 = getenv("CI_SMART_COLOR_USE_CUBE");
  if (v0) {
    uint64_t result = atoi(v0);
  }
  else {
    uint64_t result = CI_SMART_COLOR_USE_CUBE(void)::v;
  }
  CI_SMART_COLOR_USE_CUBE(void)::v = result;
  return result;
}

void downsampleRoiH(CGRect a1, float a2)
{
  CGFloat height = a1.size.height;
  CGFloat width = a1.size.width;
  CGFloat y = a1.origin.y;
  CGFloat x = a1.origin.x;
  if (CGRectIsInfinite(a1))
  {
    *(int64x2_t *)&v9.double var0 = vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    *(int64x2_t *)&v9.var2 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  }
  else
  {
    v14.origin.CGFloat x = x;
    v14.origin.CGFloat y = y;
    v14.size.CGFloat width = width;
    v14.size.CGFloat height = height;
    if (CGRectIsNull(v14))
    {
      *(int64x2_t *)&v9.double var0 = vdupq_n_s64(0x7FF0000000000000uLL);
      *(_OWORD *)&v9.var2 = 0uLL;
    }
    else
    {
      v9.double var0 = x;
      v9.double var1 = y;
      v9.var2 = width;
      v9.var3 = height;
    }
  }
  Rectangle::inset(&v9, -2.0, -0.0, (uint64_t)&v10);
  if (fabs(v10.f64[0]) == INFINITY || fabs(v10.f64[1]) == INFINITY)
  {
    *(int64x2_t *)&v12.double var0 = vdupq_n_s64(0x7FF0000000000000uLL);
    v12.var2 = 0.0;
    v12.var3 = 0.0;
  }
  else
  {
    float64x2_t v7 = (float64x2_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    float64x2_t v8 = (float64x2_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    if (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_f64(v10, v8), (int32x4_t)vceqq_f64(v11, v7))))))
    {
      v12.double var0 = v10.f64[0] * a2;
      v12.double var1 = v10.f64[1];
      v12.var2 = a2 * v11.f64[0];
      v12.var3 = v11.f64[1];
    }
    else
    {
      *(float64x2_t *)&v12.double var0 = v8;
      *(float64x2_t *)&v12.var2 = v7;
    }
  }
  Rectangle::integralize(&v12, 0.0001, (uint64_t)&v13);
}

void downsampleRoiV(CGRect a1, float a2)
{
  CGFloat height = a1.size.height;
  CGFloat width = a1.size.width;
  CGFloat y = a1.origin.y;
  CGFloat x = a1.origin.x;
  if (CGRectIsInfinite(a1))
  {
    *(int64x2_t *)&v9.double var0 = vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    *(int64x2_t *)&v9.var2 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  }
  else
  {
    v14.origin.CGFloat x = x;
    v14.origin.CGFloat y = y;
    v14.size.CGFloat width = width;
    v14.size.CGFloat height = height;
    if (CGRectIsNull(v14))
    {
      *(int64x2_t *)&v9.double var0 = vdupq_n_s64(0x7FF0000000000000uLL);
      *(_OWORD *)&v9.var2 = 0uLL;
    }
    else
    {
      v9.double var0 = x;
      v9.double var1 = y;
      v9.var2 = width;
      v9.var3 = height;
    }
  }
  Rectangle::inset(&v9, -0.0, -2.0, (uint64_t)&v10);
  if (fabs(v10.f64[0]) == INFINITY || fabs(v10.f64[1]) == INFINITY)
  {
    *(int64x2_t *)&v12.double var0 = vdupq_n_s64(0x7FF0000000000000uLL);
    v12.var2 = 0.0;
    v12.var3 = 0.0;
  }
  else
  {
    float64x2_t v7 = (float64x2_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    float64x2_t v8 = (float64x2_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    if (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_f64(v10, v8), (int32x4_t)vceqq_f64(v11, v7))))))
    {
      v12.double var0 = v10.f64[0];
      v12.double var1 = v10.f64[1] * a2;
      v12.var2 = v11.f64[0];
      v12.var3 = vmuld_lane_f64(a2, v11, 1);
    }
    else
    {
      *(float64x2_t *)&v12.double var0 = v8;
      *(float64x2_t *)&v12.var2 = v7;
    }
  }
  Rectangle::integralize(&v12, 0.0001, (uint64_t)&v13);
}

double upsampleRoi(float64_t a1, float64_t a2, double a3, double a4, float32x2_t a5)
{
  v8.f64[0] = a1;
  v8.f64[1] = a2;
  *(float32x2_t *)&v8.f64[0] = vadd_f32(vmul_f32(a5, vcvt_f32_f64(v8)), (float32x2_t)0xBF000000BF000000);
  float32x2_t v9 = vrndm_f32(*(float32x2_t *)&v8.f64[0]);
  __asm { FMOV            V13.2S, #1.0 }
  float32x2_t v15 = vadd_f32(vsub_f32(v9, *(float32x2_t *)&v8.f64[0]), _D13);
  *(float32x2_t *)&v8.f64[0] = vsub_f32(*(float32x2_t *)&v8.f64[0], v9);
  float32x2_t v16 = (float32x2_t)vdup_n_s32(0x3E4CCCCDu);
  float32x2_t v17 = vadd_f32(vsub_f32(v9, vmul_f32(v15, vmul_f32(v15, v16))), (float32x2_t)0x3F0000003F000000);
  __asm { FMOV            V15.2S, #1.5 }
  float32x2_t v30 = vadd_f32(vadd_f32(v9, vmul_f32(*(float32x2_t *)&v8.f64[0], vmul_f32(*(float32x2_t *)&v8.f64[0], v16))), _D15);
  v8.f64[0] = v17.f32[0];
  double v19 = v17.f32[1];
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  CGRect v34 = CGRectUnion(*MEMORY[0x1E4F1DB20], *(CGRect *)v8.f64);
  v39.origin.CGFloat x = v30.f32[0];
  v39.origin.CGFloat y = v30.f32[1];
  v39.size.CGFloat width = 0.0;
  v39.size.CGFloat height = 0.0;
  CGRect v35 = CGRectUnion(v34, v39);
  v22.f32[0] = a1 + a3;
  float32_t v23 = a2 + a4;
  v22.f32[1] = v23;
  float32x2_t v24 = vadd_f32(vmul_f32(a5, v22), (float32x2_t)0xBF000000BF000000);
  float32x2_t v25 = vrndm_f32(v24);
  float32x2_t v26 = vadd_f32(vsub_f32(v25, v24), _D13);
  float32x2_t v27 = vsub_f32(v24, v25);
  float32x2_t v28 = vadd_f32(vsub_f32(v25, vmul_f32(v26, vmul_f32(v26, v16))), (float32x2_t)0x3F0000003F000000);
  float32x2_t v33 = vadd_f32(vadd_f32(v25, vmul_f32(v27, vmul_f32(v27, v16))), _D15);
  v40.origin.CGFloat x = v28.f32[0];
  v40.origin.CGFloat y = v28.f32[1];
  v40.size.CGFloat width = 0.0;
  v40.size.CGFloat height = 0.0;
  CGRect v36 = CGRectUnion(v35, v40);
  v41.origin.CGFloat x = v33.f32[0];
  v41.origin.CGFloat y = v33.f32[1];
  v41.size.CGFloat width = 0.0;
  v41.size.CGFloat height = 0.0;
  CGRect v37 = CGRectUnion(v36, v41);
  CGRect v38 = CGRectInset(v37, 0.0001, 0.0001);
  return COERCE_DOUBLE(CGRectIntegral(v38)) + -1.0;
}

double cikernel::_cubicDownsample2(uint64_t a1, int8x16_t a2)
{
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  float32x2_t v4 = vadd_f32(*DC, *DC);
  int32x2_t v146 = (int32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  float32x2_t v5 = (float32x2_t)vrev64_s32(v146);
  int32x2_t v147 = (int32x2_t)vneg_f32(v5);
  float32x2_t v6 = vadd_f32((float32x2_t)vdup_lane_s32(v147, 0), v4);
  *(float *)&double v7 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v6, 1), *(float *)(a1 + 16), v6.f32[0]);
  LODWORD(v8) = *(_DWORD *)(a1 + 28);
  v9.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v10.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v6, 1), *(float *)&v8, v6.f32[0]);
  v6.f32[0] = *(float *)(a1 + 24) + *(float *)&v7;
  *(float *)v11.f64 = *(float *)v9.i32 + *(float *)v10.i32;
  v6.f32[1] = *(float *)v9.i32 + *(float *)v10.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v6, v11, v7, v8, v10, v9, v12);
  float32x2_t v14 = vadd_f32((float32x2_t)vrev64_s32(v147), v4);
  *(float *)&double v15 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v14, 1), *(float *)(a1 + 16), v14.f32[0]);
  LODWORD(v16) = *(_DWORD *)(a1 + 24);
  v17.i32[0] = *(_DWORD *)(a1 + 28);
  v18.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v14, 1), *(float *)v17.i32, v14.f32[0]);
  float32x4_t v134 = vaddq_f32(vmulq_lane_f32(vmulq_lane_f32(v13, *(float32x2_t *)a2.i8, 1), *(float32x2_t *)a2.i8, 1), (float32x4_t)0);
  v13.f32[0] = *(float *)&v16 + *(float *)&v15;
  v13.f32[1] = *(float *)v18.i32 + *(float *)v19.i32;
  *(double *)v20.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v13.i64, (float64x2_t)COERCE_UNSIGNED_INT(*(float *)v18.i32 + *(float *)v19.i32), v16, v15, v17, v19, v18);
  HIDWORD(v21) = v147.i32[1];
  float32x2_t v22 = vadd_f32((float32x2_t)__PAIR64__(v147.u32[0], v146.u32[0]), v4);
  *(float *)&double v23 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v22, 1), *(float *)(a1 + 16), v22.f32[0]);
  LODWORD(v21) = *(_DWORD *)(a1 + 24);
  v24.i32[0] = *(_DWORD *)(a1 + 28);
  v25.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v22, 1), *(float *)v24.i32, v22.f32[0]);
  float64x2_t v27 = (float64x2_t)v134;
  float32x4_t v135 = vaddq_f32(v134, vmulq_lane_f32(vmulq_n_f32(v20, *(float *)a2.i32), *(float32x2_t *)a2.i8, 1));
  v20.f32[0] = *(float *)&v21 + *(float *)&v23;
  *(float *)v27.f64 = *(float *)v25.i32 + *(float *)v26.i32;
  v20.f32[1] = *(float *)v25.i32 + *(float *)v26.i32;
  *(double *)v28.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v20.i64, v27, v21, v23, v24, v26, v25);
  HIDWORD(v29) = v147.i32[1];
  float32x2_t v30 = vadd_f32((float32x2_t)vext_s8((int8x8_t)v146, (int8x8_t)v147, 4uLL), v4);
  *(float *)&double v31 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v30, 1), *(float *)(a1 + 16), v30.f32[0]);
  LODWORD(v29) = *(_DWORD *)(a1 + 24);
  v32.i32[0] = *(_DWORD *)(a1 + 28);
  v33.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v34.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v30, 1), *(float *)v32.i32, v30.f32[0]);
  float64x2_t v35 = (float64x2_t)v135;
  float32x4_t v136 = vaddq_f32(v135, vmulq_lane_f32(vmulq_n_f32(v28, *(float *)a2.i32), *(float32x2_t *)a2.i8, 1));
  v28.f32[0] = *(float *)&v29 + *(float *)&v31;
  *(float *)v35.f64 = *(float *)v33.i32 + *(float *)v34.i32;
  v28.f32[1] = *(float *)v33.i32 + *(float *)v34.i32;
  *(double *)v36.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v28.i64, v35, v29, v31, v32, v34, v33);
  float32x2_t v37 = vsub_f32(v4, v5);
  *(float *)&double v38 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v37, 1), *(float *)(a1 + 16), v37.f32[0]);
  LODWORD(v39) = *(_DWORD *)(a1 + 24);
  v40.i32[0] = *(_DWORD *)(a1 + 28);
  v41.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v42.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v37, 1), *(float *)v40.i32, v37.f32[0]);
  float64x2_t v43 = (float64x2_t)v136;
  float32x4_t v137 = vaddq_f32(v136, vmulq_lane_f32(vmulq_lane_f32(v36, *(float32x2_t *)a2.i8, 1), *(float32x2_t *)a2.i8, 1));
  v36.f32[0] = *(float *)&v39 + *(float *)&v38;
  *(float *)v43.f64 = *(float *)v41.i32 + *(float *)v42.i32;
  v36.f32[1] = *(float *)v41.i32 + *(float *)v42.i32;
  *(double *)v44.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v36.i64, v43, v39, v38, v40, v42, v41);
  float32x2_t v45 = vadd_f32((float32x2_t)vdup_lane_s32(v147, 1), v4);
  *(float *)&double v46 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v45, 1), *(float *)(a1 + 16), v45.f32[0]);
  LODWORD(v47) = *(_DWORD *)(a1 + 24);
  v48.i32[0] = *(_DWORD *)(a1 + 28);
  v49.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v50.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v45, 1), *(float *)v48.i32, v45.f32[0]);
  float64x2_t v51 = (float64x2_t)v137;
  float32x4_t v138 = vaddq_f32(v137, vmulq_n_f32(vmulq_lane_f32(v44, *(float32x2_t *)a2.i8, 1), *(float *)a2.i32));
  v44.f32[0] = *(float *)&v47 + *(float *)&v46;
  *(float *)v51.f64 = *(float *)v49.i32 + *(float *)v50.i32;
  v44.f32[1] = *(float *)v49.i32 + *(float *)v50.i32;
  *(double *)v52.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v44.i64, v51, v47, v46, v48, v50, v49);
  HIDWORD(v53) = v147.i32[1];
  float32x2_t v54 = vadd_f32((float32x2_t)__PAIR64__(v147.u32[1], v146.u32[0]), v4);
  *(float *)&double v55 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v54, 1), *(float *)(a1 + 16), v54.f32[0]);
  LODWORD(v53) = *(_DWORD *)(a1 + 24);
  v56.i32[0] = *(_DWORD *)(a1 + 28);
  v57.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v58.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v54, 1), *(float *)v56.i32, v54.f32[0]);
  float64x2_t v59 = (float64x2_t)v138;
  float32x4_t v139 = vaddq_f32(v138, vmulq_n_f32(vmulq_n_f32(v52, *(float *)a2.i32), *(float *)a2.i32));
  v52.f32[0] = *(float *)&v53 + *(float *)&v55;
  *(float *)v59.f64 = *(float *)v57.i32 + *(float *)v58.i32;
  v52.f32[1] = *(float *)v57.i32 + *(float *)v58.i32;
  *(double *)v60.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v52.i64, v59, v53, v55, v56, v58, v57);
  HIDWORD(v61) = v146.i32[1];
  float32x2_t v62 = vadd_f32((float32x2_t)__PAIR64__(v147.u32[1], v146.u32[1]), v4);
  *(float *)&double v63 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v62, 1), *(float *)(a1 + 16), v62.f32[0]);
  LODWORD(v61) = *(_DWORD *)(a1 + 24);
  v64.i32[0] = *(_DWORD *)(a1 + 28);
  v65.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v66.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v62, 1), *(float *)v64.i32, v62.f32[0]);
  float64x2_t v67 = (float64x2_t)v139;
  float32x4_t v140 = vaddq_f32(v139, vmulq_n_f32(vmulq_n_f32(v60, *(float *)a2.i32), *(float *)a2.i32));
  v60.f32[0] = *(float *)&v61 + *(float *)&v63;
  *(float *)v67.f64 = *(float *)v65.i32 + *(float *)v66.i32;
  v60.f32[1] = *(float *)v65.i32 + *(float *)v66.i32;
  *(double *)v68.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v60.i64, v67, v61, v63, v64, v66, v65);
  HIDWORD(v69) = v147.i32[1];
  float32x2_t v70 = vadd_f32((float32x2_t)vzip1_s32(v147, v146), v4);
  *(float *)&double v71 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v70, 1), *(float *)(a1 + 16), v70.f32[0]);
  LODWORD(v69) = *(_DWORD *)(a1 + 24);
  v72.i32[0] = *(_DWORD *)(a1 + 28);
  v73.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v74.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v70, 1), *(float *)v72.i32, v70.f32[0]);
  float64x2_t v75 = (float64x2_t)v140;
  float32x4_t v141 = vaddq_f32(v140, vmulq_n_f32(vmulq_lane_f32(v68, *(float32x2_t *)a2.i8, 1), *(float *)a2.i32));
  v68.f32[0] = *(float *)&v69 + *(float *)&v71;
  *(float *)v75.f64 = *(float *)v73.i32 + *(float *)v74.i32;
  v68.f32[1] = *(float *)v73.i32 + *(float *)v74.i32;
  *(double *)v76.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v68.i64, v75, v69, v71, v72, v74, v73);
  HIDWORD(v77) = v147.i32[1];
  float32x2_t v78 = vadd_f32((float32x2_t)vext_s8((int8x8_t)v147, (int8x8_t)v146, 4uLL), v4);
  *(float *)&double v79 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v78, 1), *(float *)(a1 + 16), v78.f32[0]);
  LODWORD(v77) = *(_DWORD *)(a1 + 24);
  v80.i32[0] = *(_DWORD *)(a1 + 28);
  v81.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v82.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v78, 1), *(float *)v80.i32, v78.f32[0]);
  float64x2_t v83 = (float64x2_t)v141;
  float32x4_t v142 = vaddq_f32(v141, vmulq_n_f32(vmulq_lane_f32(v76, *(float32x2_t *)a2.i8, 1), *(float *)a2.i32));
  v76.f32[0] = *(float *)&v77 + *(float *)&v79;
  *(float *)v83.f64 = *(float *)v81.i32 + *(float *)v82.i32;
  v76.f32[1] = *(float *)v81.i32 + *(float *)v82.i32;
  *(double *)v84.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v76.i64, v83, v77, v79, v80, v82, v81);
  float32x2_t v85 = vadd_f32((float32x2_t)vdup_laneq_s32((int32x4_t)a2, 2), v4);
  *(float *)&double v86 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v85, 1), *(float *)(a1 + 16), v85.f32[0]);
  LODWORD(v87) = *(_DWORD *)(a1 + 24);
  v88.i32[0] = *(_DWORD *)(a1 + 28);
  v89.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v90.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v85, 1), *(float *)v88.i32, v85.f32[0]);
  float64x2_t v91 = (float64x2_t)v142;
  float32x4_t v143 = vaddq_f32(v142, vmulq_n_f32(vmulq_n_f32(v84, *(float *)a2.i32), *(float *)a2.i32));
  v84.f32[0] = *(float *)&v87 + *(float *)&v86;
  *(float *)v91.f64 = *(float *)v89.i32 + *(float *)v90.i32;
  v84.f32[1] = *(float *)v89.i32 + *(float *)v90.i32;
  *(double *)v92.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v84.i64, v91, v87, v86, v88, v90, v89);
  float32x2_t v93 = vadd_f32(v5, v4);
  *(float *)&double v94 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v93, 1), *(float *)(a1 + 16), v93.f32[0]);
  LODWORD(v95) = *(_DWORD *)(a1 + 24);
  v96.i32[0] = *(_DWORD *)(a1 + 28);
  v97.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v98.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v93, 1), *(float *)v96.i32, v93.f32[0]);
  float64x2_t v99 = (float64x2_t)v143;
  float32x4_t v144 = vaddq_f32(v143, vmulq_n_f32(vmulq_n_f32(v92, *(float *)a2.i32), *(float *)a2.i32));
  v92.f32[0] = *(float *)&v95 + *(float *)&v94;
  *(float *)v99.f64 = *(float *)v97.i32 + *(float *)v98.i32;
  v92.f32[1] = *(float *)v97.i32 + *(float *)v98.i32;
  *(double *)v100.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v92.i64, v99, v95, v94, v96, v98, v97);
  HIDWORD(v101) = v146.i32[1];
  float32x2_t v102 = vadd_f32((float32x2_t)__PAIR64__(v146.u32[1], v147.u32[0]), v4);
  *(float *)&double v103 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v102, 1), *(float *)(a1 + 16), v102.f32[0]);
  LODWORD(v101) = *(_DWORD *)(a1 + 24);
  v104.i32[0] = *(_DWORD *)(a1 + 28);
  v105.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v106.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v102, 1), *(float *)v104.i32, v102.f32[0]);
  float64x2_t v107 = (float64x2_t)v144;
  float32x4_t v145 = vaddq_f32(v144, vmulq_n_f32(vmulq_lane_f32(v100, *(float32x2_t *)a2.i8, 1), *(float *)a2.i32));
  v100.f32[0] = *(float *)&v101 + *(float *)&v103;
  *(float *)v107.f64 = *(float *)v105.i32 + *(float *)v106.i32;
  v100.f32[1] = *(float *)v105.i32 + *(float *)v106.i32;
  *(double *)v108.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v100.i64, v107, v101, v103, v104, v106, v105);
  HIDWORD(v109) = v147.i32[1];
  float32x2_t v110 = vadd_f32((float32x2_t)vzip2_s32(v147, v146), v4);
  *(float *)&double v111 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v110, 1), *(float *)(a1 + 16), v110.f32[0]);
  LODWORD(v109) = *(_DWORD *)(a1 + 24);
  v112.i32[0] = *(_DWORD *)(a1 + 28);
  v113.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v114.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v110, 1), *(float *)v112.i32, v110.f32[0]);
  float64x2_t v115 = (float64x2_t)v145;
  float32x4_t v148 = vaddq_f32(v145, vmulq_lane_f32(vmulq_lane_f32(v108, *(float32x2_t *)a2.i8, 1), *(float32x2_t *)a2.i8, 1));
  v108.f32[0] = *(float *)&v109 + *(float *)&v111;
  *(float *)v115.f64 = *(float *)v113.i32 + *(float *)v114.i32;
  v108.f32[1] = *(float *)v113.i32 + *(float *)v114.i32;
  *(double *)v116.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v108.i64, v115, v109, v111, v112, v114, v113);
  float32x2_t v117 = vadd_f32((float32x2_t)v146, v4);
  *(float *)&double v118 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v117, 1), *(float *)(a1 + 16), v117.f32[0]);
  LODWORD(v119) = *(_DWORD *)(a1 + 24);
  v120.i32[0] = *(_DWORD *)(a1 + 28);
  v121.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v122.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v117, 1), *(float *)v120.i32, v117.f32[0]);
  float64x2_t v123 = (float64x2_t)v148;
  float32x4_t v149 = vaddq_f32(v148, vmulq_lane_f32(vmulq_n_f32(v116, *(float *)a2.i32), *(float32x2_t *)a2.i8, 1));
  v116.f32[0] = *(float *)&v119 + *(float *)&v118;
  *(float *)v123.f64 = *(float *)v121.i32 + *(float *)v122.i32;
  v116.f32[1] = *(float *)v121.i32 + *(float *)v122.i32;
  *(double *)v124.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v116.i64, v123, v119, v118, v120, v122, v121);
  float32x2_t v125 = vadd_f32((float32x2_t)vdup_laneq_s32((int32x4_t)a2, 3), v4);
  *(float *)&double v126 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v125, 1), *(float *)(a1 + 16), v125.f32[0]);
  LODWORD(v127) = *(_DWORD *)(a1 + 24);
  v128.i32[0] = *(_DWORD *)(a1 + 28);
  v129.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v130.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v125, 1), *(float *)v128.i32, v125.f32[0]);
  float64x2_t v131 = (float64x2_t)v149;
  float32x4_t v150 = vaddq_f32(v149, vmulq_lane_f32(vmulq_n_f32(v124, *(float *)a2.i32), *(float32x2_t *)a2.i8, 1));
  v124.f32[0] = *(float *)&v127 + *(float *)&v126;
  *(float *)v131.f64 = *(float *)v129.i32 + *(float *)v130.i32;
  v124.f32[1] = *(float *)v129.i32 + *(float *)v130.i32;
  *(double *)v132.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v124.i64, v131, v127, v126, v128, v130, v129);
  *(void *)&double result = vaddq_f32(v150, vmulq_lane_f32(vmulq_lane_f32(v132, *(float32x2_t *)a2.i8, 1), *(float32x2_t *)a2.i8, 1)).u64[0];
  return result;
}

double cikernel::_cubicDownsample2h(uint64_t a1, int8x16_t a2)
{
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  HIDWORD(v4.f64[0]) = 1065353216;
  float32x2_t v5 = vmul_f32(*DC, (float32x2_t)0x3F80000040000000);
  float32x2_t v37 = vneg_f32((float32x2_t)vrev64_s32((int32x2_t)*(_OWORD *)&vextq_s8(a2, a2, 8uLL)));
  float32x2_t v6 = vadd_f32(vmul_n_f32((float32x2_t)1065353216, v37.f32[0]), v5);
  *(float *)&double v7 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v6, 1), *(float *)(a1 + 16), v6.f32[0]);
  LODWORD(v8) = *(_DWORD *)(a1 + 28);
  v9.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v10.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v6, 1), *(float *)&v8, v6.f32[0]);
  v6.f32[0] = *(float *)(a1 + 24) + *(float *)&v7;
  *(float *)v4.f64 = *(float *)v9.i32 + *(float *)v10.i32;
  v6.f32[1] = *(float *)v9.i32 + *(float *)v10.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v6, v4, v7, v8, v10, v9, v11);
  float32x2_t v13 = vadd_f32(vmul_lane_f32((float32x2_t)1065353216, v37, 1), v5);
  *(float *)&double v14 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v13, 1), *(float *)(a1 + 16), v13.f32[0]);
  LODWORD(v15) = *(_DWORD *)(a1 + 24);
  v16.i32[0] = *(_DWORD *)(a1 + 28);
  v17.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v13, 1), *(float *)v16.i32, v13.f32[0]);
  float32x4_t v38 = vaddq_f32(vmulq_lane_f32(v12, *(float32x2_t *)a2.i8, 1), (float32x4_t)0);
  v12.f32[0] = *(float *)&v15 + *(float *)&v14;
  v12.f32[1] = *(float *)v17.i32 + *(float *)v18.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v12.i64, (float64x2_t)COERCE_UNSIGNED_INT(*(float *)v17.i32 + *(float *)v18.i32), v15, v14, v16, v18, v17);
  float32x2_t v20 = vadd_f32(vmul_laneq_f32((float32x2_t)1065353216, (float32x4_t)a2, 2), v5);
  *(float *)&double v21 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v20, 1), *(float *)(a1 + 16), v20.f32[0]);
  LODWORD(v22) = *(_DWORD *)(a1 + 24);
  v23.i32[0] = *(_DWORD *)(a1 + 28);
  v24.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v20, 1), *(float *)v23.i32, v20.f32[0]);
  float64x2_t v26 = (float64x2_t)v38;
  float32x4_t v39 = vaddq_f32(v38, vmulq_n_f32(v19, *(float *)a2.i32));
  v19.f32[0] = *(float *)&v22 + *(float *)&v21;
  *(float *)v26.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  v19.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
  *(double *)v27.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v19.i64, v26, v22, v21, v23, v25, v24);
  float32x2_t v28 = vadd_f32(vmul_laneq_f32((float32x2_t)1065353216, (float32x4_t)a2, 3), v5);
  *(float *)&double v29 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v28, 1), *(float *)(a1 + 16), v28.f32[0]);
  LODWORD(v30) = *(_DWORD *)(a1 + 24);
  v31.i32[0] = *(_DWORD *)(a1 + 28);
  v32.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v28, 1), *(float *)v31.i32, v28.f32[0]);
  float64x2_t v34 = (float64x2_t)v39;
  float32x4_t v40 = vaddq_f32(v39, vmulq_n_f32(v27, *(float *)a2.i32));
  v27.f32[0] = *(float *)&v30 + *(float *)&v29;
  *(float *)v34.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v27.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)v35.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v27.i64, v34, v30, v29, v31, v33, v32);
  *(void *)&double result = vaddq_f32(v40, vmulq_lane_f32(v35, *(float32x2_t *)a2.i8, 1)).u64[0];
  return result;
}

double cikernel::_cubicDownsample2v(uint64_t a1, int8x16_t a2)
{
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  HIDWORD(v4.f64[0]) = 0x40000000;
  float32x2_t v5 = vmul_f32(*DC, (float32x2_t)0x400000003F800000);
  float32x2_t v37 = vneg_f32((float32x2_t)vrev64_s32((int32x2_t)*(_OWORD *)&vextq_s8(a2, a2, 8uLL)));
  float32x2_t v6 = vadd_f32(vmul_n_f32((float32x2_t)0x3F80000000000000, v37.f32[0]), v5);
  *(float *)&double v7 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v6, 1), *(float *)(a1 + 16), v6.f32[0]);
  LODWORD(v8) = *(_DWORD *)(a1 + 28);
  v9.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v10.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v6, 1), *(float *)&v8, v6.f32[0]);
  v6.f32[0] = *(float *)(a1 + 24) + *(float *)&v7;
  *(float *)v4.f64 = *(float *)v9.i32 + *(float *)v10.i32;
  v6.f32[1] = *(float *)v9.i32 + *(float *)v10.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v6, v4, v7, v8, v10, v9, v11);
  float32x2_t v13 = vadd_f32(vmul_lane_f32((float32x2_t)0x3F80000000000000, v37, 1), v5);
  *(float *)&double v14 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v13, 1), *(float *)(a1 + 16), v13.f32[0]);
  LODWORD(v15) = *(_DWORD *)(a1 + 24);
  v16.i32[0] = *(_DWORD *)(a1 + 28);
  v17.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v13, 1), *(float *)v16.i32, v13.f32[0]);
  float32x4_t v38 = vaddq_f32(vmulq_lane_f32(v12, *(float32x2_t *)a2.i8, 1), (float32x4_t)0);
  v12.f32[0] = *(float *)&v15 + *(float *)&v14;
  v12.f32[1] = *(float *)v17.i32 + *(float *)v18.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v12.i64, (float64x2_t)COERCE_UNSIGNED_INT(*(float *)v17.i32 + *(float *)v18.i32), v15, v14, v16, v18, v17);
  float32x2_t v20 = vadd_f32(vmul_laneq_f32((float32x2_t)0x3F80000000000000, (float32x4_t)a2, 2), v5);
  *(float *)&double v21 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v20, 1), *(float *)(a1 + 16), v20.f32[0]);
  LODWORD(v22) = *(_DWORD *)(a1 + 24);
  v23.i32[0] = *(_DWORD *)(a1 + 28);
  v24.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v20, 1), *(float *)v23.i32, v20.f32[0]);
  float64x2_t v26 = (float64x2_t)v38;
  float32x4_t v39 = vaddq_f32(v38, vmulq_n_f32(v19, *(float *)a2.i32));
  v19.f32[0] = *(float *)&v22 + *(float *)&v21;
  *(float *)v26.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  v19.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
  *(double *)v27.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v19.i64, v26, v22, v21, v23, v25, v24);
  float32x2_t v28 = vadd_f32(vmul_laneq_f32((float32x2_t)0x3F80000000000000, (float32x4_t)a2, 3), v5);
  *(float *)&double v29 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v28, 1), *(float *)(a1 + 16), v28.f32[0]);
  LODWORD(v30) = *(_DWORD *)(a1 + 24);
  v31.i32[0] = *(_DWORD *)(a1 + 28);
  v32.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v28, 1), *(float *)v31.i32, v28.f32[0]);
  float64x2_t v34 = (float64x2_t)v39;
  float32x4_t v40 = vaddq_f32(v39, vmulq_n_f32(v27, *(float *)a2.i32));
  v27.f32[0] = *(float *)&v30 + *(float *)&v29;
  *(float *)v34.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v27.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)v35.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v27.i64, v34, v30, v29, v31, v33, v32);
  *(void *)&double result = vaddq_f32(v40, vmulq_lane_f32(v35, *(float32x2_t *)a2.i8, 1)).u64[0];
  return result;
}

double cikernel::_cubicDownsampleH(uint64_t a1, __n128 a2, int8x16_t a3, int8x16_t a4)
{
  DC = (int32x2_t *)CI::getDC((CI *)a1);
  __asm { FMOV            V2.2D, #0.5 }
  *(float32x2_t *)v13.i8 = vcvt_f32_f64(vaddq_f64(vrndmq_f64(vaddq_f64(vcvtq_f64_f32(vmul_n_f32(vadd_f32((float32x2_t)vdup_lane_s32(*DC, 0), (float32x2_t)0x40000000C0000000), a2.n128_f32[0])), (float64x2_t)xmmword_193956920)), _Q2));
  float v14 = *(float *)&v13.i32[1];
  if (*(float *)v13.i32 <= *(float *)&v13.i32[1])
  {
    float v16 = a2.n128_f32[2];
    float32x2_t v17 = vmul_f32((float32x2_t)a2.n128_u64[0], (float32x2_t)*DC);
    int8x16_t v18 = v13;
    v18.i32[1] = v17.i32[1];
    float v19 = a2.n128_f32[2] * vsub_f32(*(float32x2_t *)v13.i8, v17).f32[0];
    float32x4_t v15 = 0uLL;
    v6.i64[0] = 0;
    __asm { FMOV            V2.4S, #1.0 }
    unsigned int v28 = HIDWORD(_Q2);
    do
    {
      int8x16_t v32 = v18;
      float32x4_t v33 = v6;
      float32x4_t v34 = v15;
      int8x16_t v36 = v13;
      v6.f32[0] = fabsf(v19);
      v21.f32[0] = (float)(v19 * v19) * v6.f32[0];
      v21.f32[1] = v19 * v19;
      v21.i64[1] = __PAIR64__(v28, v6.u32[0]);
      v15.i32[0] = 1.0;
      HIDWORD(v22) = a3.i32[1];
      int8x16_t v23 = (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(v15, v6), 0), a3, a4), v21);
      float64x2_t v24 = (float64x2_t)vextq_s8(v23, v23, 8uLL);
      *(float32x2_t *)&v24.f64[0] = vadd_f32(*(float32x2_t *)v23.i8, *(float32x2_t *)&v24.f64[0]);
      *(float *)v23.i32 = *(float *)(a1 + 24)
                        + (float)(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v18.i8, 1)
                                + (float)(*(float *)v13.i32 * *(float *)(a1 + 16)));
      v13.i32[0] = *(_DWORD *)(a1 + 36);
      *(float *)&double v22 = vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v18.i8, 1)
                     + (float)(*(float *)v36.i32 * *(float *)(a1 + 28));
      *(float32x2_t *)v21.f32 = vadd_f32(*(float32x2_t *)&v24.f64[0], (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v24.f64[0], 1));
      float v31 = v21.f32[0];
      float v25 = vaddv_f32(*(float32x2_t *)&v24.f64[0]);
      *(float *)v24.f64 = *(float *)v13.i32 + *(float *)&v22;
      *(float *)&v23.i32[1] = *(float *)v13.i32 + *(float *)&v22;
      *(double *)v26.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v23.i64, v24, v22, *(double *)v21.i64, v13, v36, v7);
      int8x16_t v18 = v32;
      int8x16_t v13 = v36;
      float32x4_t v15 = vaddq_f32(v34, vmulq_n_f32(v26, v31));
      float32x4_t v6 = v33;
      v6.f32[0] = v33.f32[0] + v25;
      float v19 = v16 + v19;
      *(float *)v13.i32 = *(float *)v36.i32 + 1.0;
      *(float *)v18.i32 = *(float *)v36.i32 + 1.0;
    }
    while ((float)(*(float *)v36.i32 + 1.0) <= v14);
  }
  else
  {
    v6.i64[0] = 0;
    float32x4_t v15 = 0uLL;
  }
  *(void *)&double result = vdivq_f32(v15, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 0)).u64[0];
  return result;
}

double cikernel::_cubicDownsampleV(uint64_t a1, __n128 a2, int8x16_t a3, int8x16_t a4)
{
  DC = (int32x2_t *)CI::getDC((CI *)a1);
  __asm { FMOV            V2.2D, #0.5 }
  float32x4_t v14 = (float32x4_t)vaddq_f64(vrndmq_f64(vaddq_f64(vcvtq_f64_f32(vmul_lane_f32(vadd_f32((float32x2_t)vdup_lane_s32(*DC, 1), (float32x2_t)0x40000000C0000000), (float32x2_t)a2.n128_u64[0], 1)), (float64x2_t)xmmword_193956920)), _Q2);
  *(float32x2_t *)v14.f32 = vcvt_f32_f64((float64x2_t)v14);
  float v15 = v14.f32[1];
  if (v14.f32[0] <= v14.f32[1])
  {
    float v17 = a2.n128_f32[3];
    int32x2_t v18 = (int32x2_t)vmul_f32((float32x2_t)a2.n128_u64[0], (float32x2_t)*DC);
    *(int32x2_t *)v7.i8 = vzip1_s32(v18, *(int32x2_t *)v14.f32);
    float v19 = a2.n128_f32[3] * vsub_f32(*(float32x2_t *)v14.f32, (float32x2_t)vdup_lane_s32(v18, 1)).f32[0];
    float32x4_t v16 = 0uLL;
    v6.i64[0] = 0;
    __asm { FMOV            V3.4S, #1.0 }
    unsigned int v28 = HIDWORD(_Q3);
    do
    {
      int8x16_t v36 = v7;
      float32x4_t v32 = v6;
      float32x4_t v33 = v16;
      float32x4_t v34 = v14;
      v6.f32[0] = fabsf(v19);
      v21.f32[0] = (float)(v19 * v19) * v6.f32[0];
      v21.f32[1] = v19 * v19;
      v21.i64[1] = __PAIR64__(v28, v6.u32[0]);
      v14.i32[0] = 1.0;
      HIDWORD(v22) = a3.i32[1];
      int8x16_t v23 = (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(v14, v6), 0), a3, a4), v21);
      float64x2_t v24 = (float64x2_t)vextq_s8(v23, v23, 8uLL);
      *(float32x2_t *)&v24.f64[0] = vadd_f32(*(float32x2_t *)v23.i8, *(float32x2_t *)&v24.f64[0]);
      *(float *)v23.i32 = *(float *)(a1 + 24)
                        + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v7.i8, 1), *(float *)(a1 + 16), *(float *)v7.i32);
      v7.i32[0] = *(_DWORD *)(a1 + 36);
      *(float *)&double v22 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v36.i8, 1), *(float *)(a1 + 28), *(float *)v36.i32);
      *(float32x2_t *)v21.f32 = vadd_f32(*(float32x2_t *)&v24.f64[0], (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v24.f64[0], 1));
      float v31 = v21.f32[0];
      float v25 = vaddv_f32(*(float32x2_t *)&v24.f64[0]);
      *(float *)v24.f64 = *(float *)v7.i32 + *(float *)&v22;
      *(float *)&v23.i32[1] = *(float *)v7.i32 + *(float *)&v22;
      *(double *)v26.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v23.i64, v24, v22, *(double *)v21.i64, v7, v36, v8);
      float32x4_t v14 = v34;
      int8x16_t v7 = v36;
      float32x4_t v16 = vaddq_f32(v33, vmulq_n_f32(v26, v31));
      float32x4_t v6 = v32;
      v6.f32[0] = v32.f32[0] + v25;
      float v19 = v17 + v19;
      v14.f32[0] = v34.f32[0] + 1.0;
      *(float *)&v7.i32[1] = v34.f32[0] + 1.0;
    }
    while ((float)(v34.f32[0] + 1.0) <= v15);
  }
  else
  {
    v6.i64[0] = 0;
    float32x4_t v16 = 0uLL;
  }
  *(void *)&double result = vdivq_f32(v16, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 0)).u64[0];
  return result;
}

double cikernel::_cubicUpsample10(uint64_t a1, float32x2_t a2)
{
  float32x2_t v3 = vadd_f32(vmul_f32(a2, *(float32x2_t *)CI::getDC((CI *)a1)), (float32x2_t)0xBF000000BF000000);
  float32x2_t v4 = vrndm_f32(v3);
  __asm { FMOV            V4.2S, #1.0 }
  float32x2_t v10 = vadd_f32(vsub_f32(v4, v3), _D4);
  float32x2_t v11 = vsub_f32(v3, v4);
  *(float32x2_t *)v12.i8 = vmul_f32(v10, (float32x2_t)0x3F0000003F000000);
  float32x2_t v13 = vmul_f32(v10, *(float32x2_t *)v12.i8);
  float32x2_t v14 = (float32x2_t)vdup_n_s32(0x3E2AAAABu);
  *(float32x2_t *)v15.i8 = vadd_f32(vadd_f32(*(float32x2_t *)v12.i8, vadd_f32(v13, vmul_f32(v10, vmul_f32(v10, vmul_f32(v10, (float32x2_t)vdup_n_s32(0xBEAAAAAB)))))), v14);
  float32x2_t v48 = vsub_f32(_D4, *(float32x2_t *)v15.i8);
  *(float32x2_t *)v16.i8 = vadd_f32(vadd_f32(v4, vdiv_f32(vadd_f32(vadd_f32(*(float32x2_t *)v12.i8, vsub_f32(v13, vmul_f32(v10, v13))), v14), *(float32x2_t *)v15.i8)), (float32x2_t)0xBF000000BF000000);
  __asm { FMOV            V1.2S, #6.0 }
  float32x2_t v18 = vadd_f32(v4, vdiv_f32(vdiv_f32(vmul_f32(v11, vmul_f32(v11, v11)), _D1), v48));
  __asm { FMOV            V1.2S, #1.5 }
  *(float32x2_t *)v20.i8 = vadd_f32(v18, *(float32x2_t *)&_Q1.f64[0]);
  int8x16_t v45 = v15;
  int8x16_t v46 = v20;
  *(float *)v20.i32 = vmuls_lane_f32(*(float *)v15.i32, *(float32x2_t *)v15.i8, 1);
  float64x2_t v41 = (float64x2_t)v20;
  int8x16_t v43 = v16;
  int8x16_t v21 = v16;
  v4.i32[0] = *(_DWORD *)(a1 + 28);
  *(float *)v20.i32 = *(float *)(a1 + 24)
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v16.i8, 1), *(float *)(a1 + 16), *(float *)v16.i32);
  v16.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)_Q1.f64 = *(float *)v16.i32
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v21.i8, 1), v4.f32[0], *(float *)v21.i32);
  v20.i32[1] = LODWORD(_Q1.f64[0]);
  *(double *)v22.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v20.i64, _Q1, *(double *)&v4, *(double *)v16.i64, v21, v15, v12);
  float64x2_t v23 = v41;
  float32x4_t v42 = vmulq_n_f32(v22, *(float *)v41.f64);
  v22.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v43.i8, 1), *(float *)(a1 + 16), *(float *)v46.i32);
  LODWORD(v24) = *(_DWORD *)(a1 + 36);
  HIDWORD(v25) = v48.i32[1];
  *(float *)&double v25 = vmuls_lane_f32(v48.f32[0], *(float32x2_t *)v45.i8, 1);
  float v40 = *(float *)&v25;
  *(float *)v23.f64 = *(float *)&v24
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v43.i8, 1), *(float *)(a1 + 28), *(float *)v46.i32);
  v22.i32[1] = LODWORD(v23.f64[0]);
  *(double *)v27.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v22.i64, v23, v25, v24, v45, v43, v26);
  *(float *)&double v28 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v46.i8, 1), *(float *)(a1 + 16), *(float *)v43.i32);
  v29.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v30.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v46.i8, 1), *(float *)(a1 + 28), *(float *)v43.i32);
  float32x4_t v44 = vaddq_f32(v42, vmulq_n_f32(v27, v40));
  v27.f32[0] = *(float *)(a1 + 24) + *(float *)&v28;
  *(float *)v31.f64 = *(float *)v29.i32 + *(float *)v30.i32;
  v27.f32[1] = *(float *)v29.i32 + *(float *)v30.i32;
  *(double *)v32.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v27.i64, v31, v28, *(double *)v45.i64, v30, v29, v46);
  int8x16_t v33 = v46;
  *(float *)&double v34 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v46.i8, 1), *(float *)(a1 + 16), *(float *)v46.i32);
  v35.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v36.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v46.i8, 1), *(float *)(a1 + 28), *(float *)v46.i32);
  float32x4_t v47 = vaddq_f32(v44, vmulq_n_f32(v32, vmuls_lane_f32(*(float *)v45.i32, v48, 1)));
  v32.f32[0] = *(float *)(a1 + 24) + *(float *)&v34;
  *(float *)v37.f64 = *(float *)v35.i32 + *(float *)v36.i32;
  v32.f32[1] = *(float *)v35.i32 + *(float *)v36.i32;
  *(double *)v38.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v32.i64, v37, v34, *(double *)v44.i64, v36, v35, v33);
  *(void *)&double result = vaddq_f32(v47, vmulq_n_f32(v38, vmuls_lane_f32(v48.f32[0], v48, 1))).u64[0];
  return result;
}

double cikernel::_cubicUpsampleX0(uint64_t a1, float32x2_t a2, int32x4_t a3, int32x4_t a4)
{
  float32x2_t v5 = vmul_f32(a2, *(float32x2_t *)CI::getDC((CI *)a1));
  float32x2_t v6 = vadd_f32(vrndm_f32(vadd_f32(v5, (float32x2_t)0xBF000000BF000000)), (float32x2_t)0x3F0000003F000000);
  float32x2_t v7 = vsub_f32(v6, v5);
  __asm { FMOV            V3.2S, #-1.0 }
  float32x2_t v13 = vabs_f32(vadd_f32(v7, _D3));
  float32x2_t v14 = (float32x2_t)vdup_laneq_s32(a4, 3);
  v15.i64[1] = a4.i64[1];
  float32x2_t v16 = vabd_f32(v6, v5);
  float32x2_t v17 = vadd_f32((float32x2_t)vdup_laneq_s32(a3, 3), vadd_f32(vmul_laneq_f32(v16, (float32x4_t)a3, 2), vadd_f32(vmul_f32(vmul_lane_f32(v16, *(float32x2_t *)a3.i8, 1), v16), vmul_f32(vmul_f32(vmul_n_f32(v16, *(float *)a3.i32), v16), v16))));
  float32x2_t v18 = vabs_f32(vadd_f32(v7, (float32x2_t)0x4000000040000000));
  float32x2_t v19 = vadd_f32(v14, vadd_f32(vmul_laneq_f32(v18, (float32x4_t)a4, 2), vadd_f32(vmul_f32(vmul_lane_f32(v18, *(float32x2_t *)a4.i8, 1), v18), vmul_f32(vmul_f32(vmul_n_f32(v18, *(float *)a4.i32), v18), v18))));
  *(float32x2_t *)v15.i8 = vadd_f32(v17, vadd_f32(v14, vadd_f32(vmul_laneq_f32(v13, (float32x4_t)a4, 2), vadd_f32(vmul_f32(vmul_lane_f32(v13, *(float32x2_t *)a4.i8, 1), v13), vmul_f32(vmul_f32(vmul_n_f32(v13, *(float *)a4.i32), v13), v13)))));
  __asm { FMOV            V4.2S, #1.0 }
  *(int32x2_t *)v21.i8 = vdup_n_s32(0xB8D1B717);
  int8x16_t v51 = v15;
  *(int32x2_t *)v22.i8 = vcltz_f32(vadd_f32(*(float32x2_t *)v15.i8, *(float32x2_t *)v21.i8));
  *(float32x2_t *)v23.i8 = vadd_f32(vadd_f32(v6, _D3), (float32x2_t)vbic_s8((int8x8_t)vdiv_f32(v17, *(float32x2_t *)v15.i8), *(int8x8_t *)v22.i8));
  *(float32x2_t *)a3.i8 = vsub_f32(_D4, *(float32x2_t *)v15.i8);
  int8x8_t v24 = (int8x8_t)vdiv_f32(v19, *(float32x2_t *)a3.i8);
  *(float32x2_t *)&v25.f64[0] = vadd_f32(v6, _D4);
  *(float32x2_t *)v26.i8 = vadd_f32(*(float32x2_t *)&v25.f64[0], (float32x2_t)vbic_s8(v24, (int8x8_t)vcltz_f32(vadd_f32(*(float32x2_t *)a3.i8, *(float32x2_t *)v21.i8))));
  int8x16_t v53 = v26;
  *(float *)v26.i32 = vmuls_lane_f32(*(float *)v15.i32, *(float32x2_t *)v15.i8, 1);
  float64x2_t v47 = (float64x2_t)v26;
  int8x16_t v49 = v23;
  int8x16_t v27 = v23;
  v24.i32[0] = *(_DWORD *)(a1 + 28);
  *(float *)v26.i32 = *(float *)(a1 + 24)
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v23.i8, 1), *(float *)(a1 + 16), *(float *)v23.i32);
  v23.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v25.f64 = *(float *)v23.i32
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v27.i8, 1), *(float *)v24.i32, *(float *)v27.i32);
  v26.i32[1] = LODWORD(v25.f64[0]);
  *(double *)v28.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v26.i64, v25, *(double *)&v24, *(double *)v23.i64, v27, v21, v22);
  float64x2_t v29 = v47;
  float32x4_t v48 = vmulq_n_f32(v28, *(float *)v47.f64);
  v28.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v49.i8, 1), *(float *)(a1 + 16), *(float *)v53.i32);
  LODWORD(v30) = *(_DWORD *)(a1 + 36);
  HIDWORD(v31) = a3.i32[1];
  *(float *)&double v31 = vmuls_lane_f32(*(float *)a3.i32, *(float32x2_t *)v51.i8, 1);
  float v46 = *(float *)&v31;
  *(float *)v29.f64 = *(float *)&v30
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v49.i8, 1), *(float *)(a1 + 28), *(float *)v53.i32);
  v28.i32[1] = LODWORD(v29.f64[0]);
  *(double *)v33.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v28.i64, v29, v31, v30, v51, v49, v32);
  *(float *)&double v34 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v53.i8, 1), *(float *)(a1 + 16), *(float *)v49.i32);
  v35.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v36.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v53.i8, 1), *(float *)(a1 + 28), *(float *)v49.i32);
  float32x4_t v50 = vaddq_f32(v48, vmulq_n_f32(v33, v46));
  v33.f32[0] = *(float *)(a1 + 24) + *(float *)&v34;
  *(float *)v37.f64 = *(float *)v35.i32 + *(float *)v36.i32;
  v33.f32[1] = *(float *)v35.i32 + *(float *)v36.i32;
  *(double *)v38.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v33.i64, v37, v34, *(double *)v51.i64, v36, v35, v53);
  int8x16_t v39 = v53;
  *(float *)&double v40 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v53.i8, 1), *(float *)(a1 + 16), *(float *)v53.i32);
  v41.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v42.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v53.i8, 1), *(float *)(a1 + 28), *(float *)v53.i32);
  float32x4_t v54 = vaddq_f32(v50, vmulq_n_f32(v38, vmuls_lane_f32(*(float *)v51.i32, *(float32x2_t *)a3.i8, 1)));
  v38.f32[0] = *(float *)(a1 + 24) + *(float *)&v40;
  *(float *)v43.f64 = *(float *)v41.i32 + *(float *)v42.i32;
  v38.f32[1] = *(float *)v41.i32 + *(float *)v42.i32;
  *(double *)v44.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v38.i64, v43, v40, *(double *)v50.i64, v42, v41, v39);
  *(void *)&double result = vaddq_f32(v54, vmulq_n_f32(v44, vmuls_lane_f32(*(float *)a3.i32, *(float32x2_t *)a3.i8, 1))).u64[0];
  return result;
}

double cikernel::_cubicUpsample(uint64_t a1, float32x2_t a2, float32x4_t a3, int32x4_t a4)
{
  float32x2_t v5 = vmul_f32(a2, *(float32x2_t *)CI::getDC((CI *)a1));
  *(float32x2_t *)_Q2.i8 = vadd_f32(vrndm_f32(vadd_f32(v5, (float32x2_t)0xBF000000BF000000)), (float32x2_t)0x3F0000003F000000);
  float32x2_t v7 = vsub_f32(*(float32x2_t *)_Q2.i8, v5);
  int8x16_t v8 = _Q2;
  __asm { FMOV            V2.2S, #-1.0 }
  float32x2_t v13 = vabs_f32(vadd_f32(v7, *(float32x2_t *)_Q2.i8));
  *(float32x2_t *)a4.i8 = vadd_f32((float32x2_t)vdup_laneq_s32(a4, 3), vadd_f32(vmul_laneq_f32(v13, (float32x4_t)a4, 2), vadd_f32(vmul_f32(vmul_lane_f32(v13, *(float32x2_t *)a4.i8, 1), v13), vmul_f32(vmul_f32(vmul_n_f32(v13, *(float *)a4.i32), v13), v13))));
  float32x2_t v14 = vabd_f32(*(float32x2_t *)v8.i8, v5);
  int8x16_t v159 = v8;
  v15.i64[1] = a3.i64[1];
  *(float32x2_t *)v16.i8 = vmul_f32(vmul_lane_f32(v14, *(float32x2_t *)a3.f32, 1), v14);
  float32x2_t v17 = vadd_f32(*(float32x2_t *)v16.i8, vmul_f32(vmul_f32(vmul_n_f32(v14, a3.f32[0]), v14), v14));
  float32x2_t v18 = vadd_f32(vmul_laneq_f32(v14, a3, 2), v17);
  __asm { FMOV            V8.2S, #1.0 }
  float32x2_t v20 = vabs_f32(vadd_f32(v7, _D8));
  *(float32x2_t *)_Q2.i8 = vadd_f32(*(float32x2_t *)v8.i8, *(float32x2_t *)_Q2.i8);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)_Q2.i8, 1), *(float *)(a1 + 16), *(float *)_Q2.i32);
  v17.i32[0] = *(_DWORD *)(a1 + 24);
  *(float *)v8.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)_Q2.i8, 1), *(float *)(a1 + 28), *(float *)_Q2.i32);
  *(float32x2_t *)v15.i8 = vmul_f32(vmul_lane_f32(v20, *(float32x2_t *)a3.f32, 1), v20);
  *(int32x2_t *)_Q2.i8 = vdup_laneq_s32((int32x4_t)a3, 3);
  *(float32x2_t *)&v21.f64[0] = vadd_f32(*(float32x2_t *)_Q2.i8, vadd_f32(vmul_laneq_f32(v20, a3, 2), vadd_f32(*(float32x2_t *)v15.i8, vmul_f32(vmul_f32(vmul_n_f32(v20, a3.f32[0]), v20), v20))));
  float32x2_t v153 = vadd_f32(*(float32x2_t *)_Q2.i8, v18);
  float32x2_t v154 = *(float32x2_t *)&v21.f64[0];
  *(float32x2_t *)a3.f32 = vsub_f32(_D8, vadd_f32(*(float32x2_t *)&v21.f64[0], vadd_f32(v153, *(float32x2_t *)a4.i8)));
  v18.f32[0] = v17.f32[0] + *(float *)v16.i32;
  *(float *)v21.f64 = *(float *)(a1 + 36) + *(float *)v8.i32;
  v18.f32[1] = *(float *)v21.f64;
  *(double *)v22.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v18, v21, *(double *)_Q2.i64, *(double *)&v17, v16, v15, v8);
  HIDWORD(v23) = v159.i32[1];
  float32x2_t v24 = vadd_f32(*(float32x2_t *)v159.i8, (float32x2_t)0xBF80000000000000);
  *(float *)&double v25 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v24, 1), *(float *)(a1 + 16), v24.f32[0]);
  LODWORD(v23) = *(_DWORD *)(a1 + 24);
  v26.i32[0] = *(_DWORD *)(a1 + 28);
  v27.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v28.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v24, 1), *(float *)v26.i32, v24.f32[0]);
  float32x4_t v141 = vaddq_f32(vmulq_lane_f32(vmulq_n_f32(v22, *(float *)a4.i32), *(float32x2_t *)a4.i8, 1), (float32x4_t)0);
  v22.f32[0] = *(float *)&v23 + *(float *)&v25;
  v22.f32[1] = *(float *)v27.i32 + *(float *)v28.i32;
  *(double *)v29.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v22.i64, (float64x2_t)COERCE_UNSIGNED_INT(*(float *)v27.i32 + *(float *)v28.i32), v23, v25, v26, v28, v27);
  HIDWORD(v30) = v159.i32[1];
  float32x2_t v31 = vadd_f32(*(float32x2_t *)v159.i8, (float32x2_t)0xBF8000003F800000);
  *(float *)&double v32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v31, 1), *(float *)(a1 + 16), v31.f32[0]);
  LODWORD(v30) = *(_DWORD *)(a1 + 24);
  v33.i32[0] = *(_DWORD *)(a1 + 28);
  v34.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v35.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v31, 1), *(float *)v33.i32, v31.f32[0]);
  float64x2_t v36 = (float64x2_t)v141;
  float32x4_t v142 = vaddq_f32(vmulq_lane_f32(vmulq_n_f32(v29, v153.f32[0]), *(float32x2_t *)a4.i8, 1), v141);
  v29.f32[0] = *(float *)&v30 + *(float *)&v32;
  *(float *)v36.f64 = *(float *)v34.i32 + *(float *)v35.i32;
  v29.f32[1] = *(float *)v34.i32 + *(float *)v35.i32;
  *(double *)v37.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v29.i64, v36, v30, v32, v33, v35, v34);
  HIDWORD(v38) = v159.i32[1];
  float32x2_t v39 = vadd_f32(*(float32x2_t *)v159.i8, (float32x2_t)0xBF80000040000000);
  *(float *)&double v40 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v39, 1), *(float *)(a1 + 16), v39.f32[0]);
  LODWORD(v38) = *(_DWORD *)(a1 + 24);
  v41.i32[0] = *(_DWORD *)(a1 + 28);
  v42.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v43.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v39, 1), *(float *)v41.i32, v39.f32[0]);
  float64x2_t v44 = (float64x2_t)v142;
  float32x4_t v143 = vaddq_f32(v142, vmulq_lane_f32(vmulq_n_f32(v37, v154.f32[0]), *(float32x2_t *)a4.i8, 1));
  v37.f32[0] = *(float *)&v38 + *(float *)&v40;
  *(float *)v44.f64 = *(float *)v42.i32 + *(float *)v43.i32;
  v37.f32[1] = *(float *)v42.i32 + *(float *)v43.i32;
  *(double *)v45.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v37.i64, v44, v38, v40, v41, v43, v42);
  HIDWORD(v46) = v159.i32[1];
  float32x2_t v47 = vadd_f32(*(float32x2_t *)v159.i8, (float32x2_t)3212836864);
  *(float *)&double v48 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v47, 1), *(float *)(a1 + 16), v47.f32[0]);
  LODWORD(v46) = *(_DWORD *)(a1 + 24);
  v49.i32[0] = *(_DWORD *)(a1 + 28);
  v50.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v51.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v47, 1), *(float *)v49.i32, v47.f32[0]);
  float64x2_t v52 = (float64x2_t)v143;
  float32x4_t v144 = vaddq_f32(v143, vmulq_lane_f32(vmulq_n_f32(v45, a3.f32[0]), *(float32x2_t *)a4.i8, 1));
  v45.f32[0] = *(float *)&v46 + *(float *)&v48;
  *(float *)v52.f64 = *(float *)v50.i32 + *(float *)v51.i32;
  v45.f32[1] = *(float *)v50.i32 + *(float *)v51.i32;
  *(double *)v53.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v45.i64, v52, v46, v48, v49, v51, v50);
  float64x2_t v54 = (float64x2_t)v144;
  float32x4_t v145 = vaddq_f32(v144, vmulq_lane_f32(vmulq_n_f32(v53, *(float *)a4.i32), v153, 1));
  LODWORD(v55) = *(_DWORD *)(a1 + 28);
  v53.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v159.i8, 1), *(float *)(a1 + 16), *(float *)v159.i32);
  LODWORD(v56) = *(_DWORD *)(a1 + 36);
  *(float *)v54.f64 = *(float *)&v56
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v159.i8, 1), *(float *)&v55, *(float *)v159.i32);
  v53.i32[1] = LODWORD(v54.f64[0]);
  *(double *)v59.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v53.i64, v54, v55, v56, v159, v57, v58);
  HIDWORD(v60) = v159.i32[1];
  float32x2_t v61 = vadd_f32(*(float32x2_t *)v159.i8, (float32x2_t)1065353216);
  *(float *)&double v62 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v61, 1), *(float *)(a1 + 16), v61.f32[0]);
  LODWORD(v60) = *(_DWORD *)(a1 + 24);
  v63.i32[0] = *(_DWORD *)(a1 + 28);
  v64.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v65.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v61, 1), *(float *)v63.i32, v61.f32[0]);
  float64x2_t v66 = (float64x2_t)v145;
  float32x4_t v146 = vaddq_f32(v145, vmulq_lane_f32(vmulq_n_f32(v59, v153.f32[0]), v153, 1));
  v59.f32[0] = *(float *)&v60 + *(float *)&v62;
  *(float *)v66.f64 = *(float *)v64.i32 + *(float *)v65.i32;
  v59.f32[1] = *(float *)v64.i32 + *(float *)v65.i32;
  *(double *)v67.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v59.i64, v66, v60, v62, v63, v65, v64);
  HIDWORD(v68) = v159.i32[1];
  float32x2_t v69 = vadd_f32(*(float32x2_t *)v159.i8, (float32x2_t)0x40000000);
  *(float *)&double v70 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v69, 1), *(float *)(a1 + 16), v69.f32[0]);
  LODWORD(v68) = *(_DWORD *)(a1 + 24);
  v71.i32[0] = *(_DWORD *)(a1 + 28);
  v72.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v73.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v69, 1), *(float *)v71.i32, v69.f32[0]);
  float64x2_t v74 = (float64x2_t)v146;
  float32x4_t v147 = vaddq_f32(v146, vmulq_lane_f32(vmulq_n_f32(v67, v154.f32[0]), v153, 1));
  v67.f32[0] = *(float *)&v68 + *(float *)&v70;
  *(float *)v74.f64 = *(float *)v72.i32 + *(float *)v73.i32;
  v67.f32[1] = *(float *)v72.i32 + *(float *)v73.i32;
  *(double *)v75.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v67.i64, v74, v68, v70, v71, v73, v72);
  HIDWORD(v76) = v159.i32[1];
  float32x2_t v77 = vadd_f32(*(float32x2_t *)v159.i8, (float32x2_t)0x3F800000BF800000);
  *(float *)&double v78 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v77, 1), *(float *)(a1 + 16), v77.f32[0]);
  LODWORD(v76) = *(_DWORD *)(a1 + 24);
  v79.i32[0] = *(_DWORD *)(a1 + 28);
  v80.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v81.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v77, 1), *(float *)v79.i32, v77.f32[0]);
  float64x2_t v82 = (float64x2_t)v147;
  float32x4_t v148 = vaddq_f32(v147, vmulq_lane_f32(vmulq_n_f32(v75, a3.f32[0]), v153, 1));
  v75.f32[0] = *(float *)&v76 + *(float *)&v78;
  *(float *)v82.f64 = *(float *)v80.i32 + *(float *)v81.i32;
  v75.f32[1] = *(float *)v80.i32 + *(float *)v81.i32;
  *(double *)v83.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v75.i64, v82, v76, v78, v79, v81, v80);
  HIDWORD(v84) = v159.i32[1];
  float32x2_t v85 = vadd_f32(*(float32x2_t *)v159.i8, (float32x2_t)0x3F80000000000000);
  *(float *)&double v86 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v85, 1), *(float *)(a1 + 16), v85.f32[0]);
  LODWORD(v84) = *(_DWORD *)(a1 + 24);
  v87.i32[0] = *(_DWORD *)(a1 + 28);
  v88.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v89.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v85, 1), *(float *)v87.i32, v85.f32[0]);
  float64x2_t v90 = (float64x2_t)v148;
  float32x4_t v149 = vaddq_f32(v148, vmulq_lane_f32(vmulq_n_f32(v83, *(float *)a4.i32), v154, 1));
  v83.f32[0] = *(float *)&v84 + *(float *)&v86;
  *(float *)v90.f64 = *(float *)v88.i32 + *(float *)v89.i32;
  v83.f32[1] = *(float *)v88.i32 + *(float *)v89.i32;
  *(double *)v91.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v83.i64, v90, v84, v86, v87, v89, v88);
  float32x2_t v92 = vadd_f32(*(float32x2_t *)v159.i8, _D8);
  *(float *)&double v93 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v92, 1), *(float *)(a1 + 16), v92.f32[0]);
  LODWORD(v94) = *(_DWORD *)(a1 + 24);
  v95.i32[0] = *(_DWORD *)(a1 + 28);
  v96.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v97.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v92, 1), *(float *)v95.i32, v92.f32[0]);
  float64x2_t v98 = (float64x2_t)v149;
  float32x4_t v150 = vaddq_f32(v149, vmulq_lane_f32(vmulq_n_f32(v91, v153.f32[0]), v154, 1));
  v91.f32[0] = *(float *)&v94 + *(float *)&v93;
  *(float *)v98.f64 = *(float *)v96.i32 + *(float *)v97.i32;
  v91.f32[1] = *(float *)v96.i32 + *(float *)v97.i32;
  *(double *)v99.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v91.i64, v98, v94, v93, v95, v97, v96);
  HIDWORD(v100) = v159.i32[1];
  float32x2_t v101 = vadd_f32(*(float32x2_t *)v159.i8, (float32x2_t)0x3F80000040000000);
  *(float *)&double v102 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v101, 1), *(float *)(a1 + 16), v101.f32[0]);
  LODWORD(v100) = *(_DWORD *)(a1 + 24);
  v103.i32[0] = *(_DWORD *)(a1 + 28);
  v104.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v105.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v101, 1), *(float *)v103.i32, v101.f32[0]);
  float64x2_t v106 = (float64x2_t)v150;
  float32x4_t v151 = vaddq_f32(v150, vmulq_lane_f32(vmulq_n_f32(v99, v154.f32[0]), v154, 1));
  v99.f32[0] = *(float *)&v100 + *(float *)&v102;
  *(float *)v106.f64 = *(float *)v104.i32 + *(float *)v105.i32;
  v99.f32[1] = *(float *)v104.i32 + *(float *)v105.i32;
  *(double *)v107.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v99.i64, v106, v100, v102, v103, v105, v104);
  HIDWORD(v108) = v159.i32[1];
  float32x2_t v109 = vadd_f32(*(float32x2_t *)v159.i8, (float32x2_t)0x40000000BF800000);
  *(float *)&double v110 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v109, 1), *(float *)(a1 + 16), v109.f32[0]);
  LODWORD(v108) = *(_DWORD *)(a1 + 24);
  v111.i32[0] = *(_DWORD *)(a1 + 28);
  v112.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v113.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v109, 1), *(float *)v111.i32, v109.f32[0]);
  float64x2_t v114 = (float64x2_t)v151;
  float32x4_t v152 = vaddq_f32(v151, vmulq_lane_f32(vmulq_n_f32(v107, a3.f32[0]), v154, 1));
  v107.f32[0] = *(float *)&v108 + *(float *)&v110;
  *(float *)v114.f64 = *(float *)v112.i32 + *(float *)v113.i32;
  v107.f32[1] = *(float *)v112.i32 + *(float *)v113.i32;
  *(double *)v115.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v107.i64, v114, v108, v110, v111, v113, v112);
  HIDWORD(v116) = v159.i32[1];
  float32x2_t v117 = vadd_f32(*(float32x2_t *)v159.i8, (float32x2_t)0x4000000000000000);
  *(float *)&double v118 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v117, 1), *(float *)(a1 + 16), v117.f32[0]);
  LODWORD(v116) = *(_DWORD *)(a1 + 24);
  v119.i32[0] = *(_DWORD *)(a1 + 28);
  v120.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v121.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v117, 1), *(float *)v119.i32, v117.f32[0]);
  float64x2_t v122 = (float64x2_t)v152;
  float32x4_t v156 = vaddq_f32(v152, vmulq_lane_f32(vmulq_n_f32(v115, *(float *)a4.i32), *(float32x2_t *)a3.f32, 1));
  v115.f32[0] = *(float *)&v116 + *(float *)&v118;
  *(float *)v122.f64 = *(float *)v120.i32 + *(float *)v121.i32;
  v115.f32[1] = *(float *)v120.i32 + *(float *)v121.i32;
  *(double *)v123.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v115.i64, v122, v116, v118, v119, v121, v120);
  HIDWORD(v124) = v159.i32[1];
  float32x2_t v125 = vadd_f32(*(float32x2_t *)v159.i8, (float32x2_t)0x400000003F800000);
  *(float *)&double v126 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v125, 1), *(float *)(a1 + 16), v125.f32[0]);
  LODWORD(v124) = *(_DWORD *)(a1 + 24);
  v127.i32[0] = *(_DWORD *)(a1 + 28);
  v128.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v129.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v125, 1), *(float *)v127.i32, v125.f32[0]);
  float64x2_t v130 = (float64x2_t)v156;
  float32x4_t v157 = vaddq_f32(v156, vmulq_lane_f32(vmulq_n_f32(v123, v153.f32[0]), *(float32x2_t *)a3.f32, 1));
  v123.f32[0] = *(float *)&v124 + *(float *)&v126;
  *(float *)v130.f64 = *(float *)v128.i32 + *(float *)v129.i32;
  v123.f32[1] = *(float *)v128.i32 + *(float *)v129.i32;
  *(double *)v131.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v123.i64, v130, v124, v126, v127, v129, v128);
  HIDWORD(v132) = v159.i32[1];
  float32x2_t v133 = vadd_f32(*(float32x2_t *)v159.i8, (float32x2_t)0x4000000040000000);
  *(float *)&double v134 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v133, 1), *(float *)(a1 + 16), v133.f32[0]);
  LODWORD(v132) = *(_DWORD *)(a1 + 24);
  v135.i32[0] = *(_DWORD *)(a1 + 28);
  v136.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v137.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v133, 1), *(float *)v135.i32, v133.f32[0]);
  float64x2_t v138 = (float64x2_t)v157;
  float32x4_t v160 = vaddq_f32(v157, vmulq_lane_f32(vmulq_n_f32(v131, v154.f32[0]), *(float32x2_t *)a3.f32, 1));
  v131.f32[0] = *(float *)&v132 + *(float *)&v134;
  *(float *)v138.f64 = *(float *)v136.i32 + *(float *)v137.i32;
  v131.f32[1] = *(float *)v136.i32 + *(float *)v137.i32;
  *(double *)v139.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v131.i64, v138, v132, v134, v135, v137, v136);
  *(void *)&double result = vaddq_f32(v160, vmulq_lane_f32(vmulq_n_f32(v139, a3.f32[0]), *(float32x2_t *)a3.f32, 1)).u64[0];
  return result;
}

double cikernel::_cubicUpsample10v(cikernel *this, SamplerObj *a2, float a3)
{
  DC = (float32x2_t *)CI::getDC(this);
  *(float32x2_t *)v6.i8 = *DC;
  float v7 = vmuls_lane_f32(a3, *DC, 1) + -0.5;
  float v8 = floorf(v7);
  float v9 = (float)(v8 - v7) + 1.0;
  float v10 = v7 - v8;
  double v11 = v9;
  v12.i64[0] = 0.5;
  double v13 = v11 * 0.5 * v11;
  *(float *)v14.f64 = v13 + v11 * -0.333333333 * v11 * v11 + v11 * 0.5 + 0.166666667;
  *(double *)v15.i64 = *(float *)v14.f64;
  float64x2_t v32 = v14;
  float v34 = 1.0 - *(float *)v14.f64;
  *(double *)v16.i64 = v13 + v11 * -0.5 * v11 * v11;
  double v17 = v8;
  double v18 = (*(double *)v16.i64 + v11 * 0.5 + 0.166666667) / *(float *)v14.f64 + v17 + -0.5;
  *(float *)&double v18 = v18;
  double v19 = (float)(1.0 - *(float *)v14.f64);
  double v20 = (float)(v10 * (float)(v10 * v10)) / 6.0 / v19 + v17;
  v21.f64[0] = 1.5;
  float v22 = v20 + 1.5;
  int8x16_t v31 = v6;
  LODWORD(v19) = *((_DWORD *)this + 7);
  *(float *)&double v20 = *((float *)this + 6)
                 + vmlas_n_f32(*((float *)this + 5) * *(float *)&v18, *((float *)this + 4), COERCE_FLOAT(*DC));
  v15.i32[0] = *((_DWORD *)this + 9);
  *(float *)v21.f64 = *(float *)v15.i32
                    + vmlas_n_f32(*((float *)this + 8) * *(float *)&v18, *(float *)&v19, COERCE_FLOAT(*DC));
  HIDWORD(v20) = LODWORD(v21.f64[0]);
  *(double *)v23.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v20, v21, v18, v19, v15, v12, v16);
  float64x2_t v24 = v32;
  float32x4_t v33 = vmulq_n_f32(v23, *(float *)v32.f64);
  LODWORD(v25) = *((_DWORD *)this + 7);
  v23.f32[0] = *((float *)this + 6) + vmlas_n_f32(*((float *)this + 5) * v22, *((float *)this + 4), *(float *)v31.i32);
  LODWORD(v26) = *((_DWORD *)this + 9);
  *(float *)v24.f64 = *(float *)&v26 + vmlas_n_f32(*((float *)this + 8) * v22, *(float *)&v25, *(float *)v31.i32);
  v23.i32[1] = LODWORD(v24.f64[0]);
  *(double *)v29.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v23.i64, v24, v25, v26, v31, v27, v28);
  *(void *)&double result = vaddq_f32(v33, vmulq_n_f32(v29, v34)).u64[0];
  return result;
}

double cikernel::_cubicUpsample10h(cikernel *this, SamplerObj *a2, float a3)
{
  DC = (float32x2_t *)CI::getDC(this);
  *(float32x2_t *)v6.i8 = *DC;
  float v7 = (float)(a3 * COERCE_FLOAT(*DC)) + -0.5;
  float v8 = floorf(v7);
  float v9 = (float)(v8 - v7) + 1.0;
  float v10 = v7 - v8;
  double v11 = v9;
  v12.i64[0] = 0.5;
  double v13 = v11 * 0.5 * v11;
  *(float *)v14.f64 = v13 + v11 * -0.333333333 * v11 * v11 + v11 * 0.5 + 0.166666667;
  *(double *)v15.i64 = *(float *)v14.f64;
  float64x2_t v32 = v14;
  float v34 = 1.0 - *(float *)v14.f64;
  *(double *)v16.i64 = v13 + v11 * -0.5 * v11 * v11;
  double v17 = v8;
  double v18 = (*(double *)v16.i64 + v11 * 0.5 + 0.166666667) / *(float *)v14.f64 + v17 + -0.5;
  *(float *)&double v18 = v18;
  double v19 = (float)(1.0 - *(float *)v14.f64);
  double v20 = (float)(v10 * (float)(v10 * v10)) / 6.0 / v19 + v17;
  v21.f64[0] = 1.5;
  float v22 = v20 + 1.5;
  int8x16_t v31 = v6;
  LODWORD(v19) = *((_DWORD *)this + 7);
  *(float *)&double v20 = *((float *)this + 6)
                 + (float)(vmuls_lane_f32(*((float *)this + 5), *DC, 1) + (float)(*(float *)&v18 * *((float *)this + 4)));
  v15.i32[0] = *((_DWORD *)this + 9);
  *(float *)v21.f64 = *(float *)v15.i32
                    + (float)(vmuls_lane_f32(*((float *)this + 8), *DC, 1) + (float)(*(float *)&v18 * *(float *)&v19));
  HIDWORD(v20) = LODWORD(v21.f64[0]);
  *(double *)v23.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v20, v21, v18, v19, v15, v12, v16);
  float64x2_t v24 = v32;
  float32x4_t v33 = vmulq_n_f32(v23, *(float *)v32.f64);
  LODWORD(v25) = *((_DWORD *)this + 7);
  v23.f32[0] = *((float *)this + 6)
             + (float)(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v31.i8, 1)
                     + (float)(v22 * *((float *)this + 4)));
  LODWORD(v26) = *((_DWORD *)this + 9);
  *(float *)v24.f64 = *(float *)&v26
                    + (float)(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v31.i8, 1)
                            + (float)(v22 * *(float *)&v25));
  v23.i32[1] = LODWORD(v24.f64[0]);
  *(double *)v29.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v23.i64, v24, v25, v26, v31, v27, v28);
  *(void *)&double result = vaddq_f32(v33, vmulq_n_f32(v29, v34)).u64[0];
  return result;
}

double cikernel::_spotLight(CI *a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5, float a6)
{
  v6.i64[0] = *(void *)CI::getDC(a1);
  v6.i32[2] = 0;
  float32x4_t v7 = vsubq_f32(a3, v6);
  v7.i32[3] = 0;
  int8x16_t v8 = (int8x16_t)vmulq_f32(v7, v7);
  *(float32x2_t *)v8.i8 = vadd_f32(*(float32x2_t *)v8.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v8, v8, 8uLL));
  v8.i32[0] = vadd_f32(*(float32x2_t *)v8.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v8.i8, 1)).u32[0];
  float32x2_t v9 = vrsqrte_f32((float32x2_t)v8.u32[0]);
  float32x4_t v17 = vmulq_n_f32(v7, vmul_f32(v9, vrsqrts_f32((float32x2_t)v8.u32[0], vmul_f32(v9, v9))).f32[0]);
  float32x4_t v10 = vmulq_f32(a4, v17);
  float v11 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2), vaddq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1))).f32[0];
  float v12 = 1.0;
  if (v11 <= 1.0) {
    float v12 = v11;
  }
  BOOL v13 = v11 < 0.0;
  float v14 = 0.0;
  if (!v13) {
    float v14 = v12;
  }
  *(void *)&double result = vmulq_f32(a2, vmulq_laneq_f32(vmulq_n_f32(a5, powf(v14, a6)), v17, 2)).u64[0];
  return result;
}

void CI::f4_s_f3_f3_f4_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  float32x4_t v10 = *(double (**)(__n128, __n128, __n128, __n128, double))(a1 + 24);
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  uint64_t v13 = *(void *)(v9 + 32);
  uint64_t v14 = *(void *)(v9 + 56);
  int v15 = *(_DWORD *)(v9 + 88);
  uint64_t v16 = *(void *)(v9 + 80);
  int v17 = *(_DWORD *)(v9 + 112);
  uint64_t v18 = *(void *)(v9 + 104);
  if (*(unsigned char *)(a1 + 64))
  {
    int v23 = *(_DWORD *)(v9 + 88);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 128)), a2);
    int v15 = v23;
  }
  double v19 = (double *)(a3 + 16 * v18);
  if (v17 != 5) {
    double v19 = (double *)((char *)a2 + 64 * v18);
  }
  double v20 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5) {
    double v20 = (__n128 *)((char *)a2 + 64 * v16);
  }
  float64x2_t v21 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    float64x2_t v21 = (__n128 *)((char *)a2 + 64 * v12);
  }
  *(double *)&long long v22 = v10(*v21, *((__n128 *)a2 + 4 * v13), *((__n128 *)a2 + 4 * v14), *v20, *v19);
  *(_OWORD *)(a3 + 16 * a7) = v22;
}

double cikernel::_starshine(CI *a1, float32x2_t a2, int8x16_t a3, int32x4_t a4, float a5, float32x4_t a6)
{
  float32x2_t v6 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  int32x2_t v7 = (int32x2_t)vmul_f32(*(float32x2_t *)a3.i8, v6);
  int32x2_t v8 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v6);
  float32x2_t v9 = vadd_f32((float32x2_t)vzip1_s32(v7, v8), (float32x2_t)vzip2_s32(v7, v8));
  v6.f32[0] = sqrtf(vaddv_f32(vmul_f32(v6, v6)));
  float v10 = *(float *)a4.i32 / v6.f32[0];
  float32x2_t v11 = vabs_f32(vdiv_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)a4.i8, 0), vmaxnm_f32(vadd_f32((float32x2_t)vdup_laneq_s32(a4, 3), vmul_n_f32(vabs_f32(v9), a5)), (float32x2_t)vdup_n_s32(0x33D6BF95u))));
  float32x2_t v12 = vmul_f32(vmul_f32(v11, v11), v11);
  float v13 = vmuls_lane_f32(vmul_lane_f32(v12, v12, 1).f32[0], (float32x4_t)a4, 2);
  float v14 = 1.0 - vmuls_lane_f32(v6.f32[0], *(float32x2_t *)a4.i8, 1);
  if (v14 <= 1.0) {
    float v15 = v14;
  }
  else {
    float v15 = 1.0;
  }
  BOOL v16 = v14 < 0.0;
  int32x2_t v17 = 0;
  if (!v16) {
    *(float *)v17.i32 = v15;
  }
  *(float *)v17.i32 = v13 * (float)(*(float *)v17.i32 * *(float *)v17.i32);
  *(void *)&double result = vaddq_f32(vmulq_n_f32(a6, v10 * v10), (float32x4_t)vdupq_lane_s32(v17, 0)).u64[0];
  return result;
}

void CI::f4_f2_f4_f4_f_clr(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  float v10 = *(double (**)(double, __n128, __n128, float, __n128))(a1 + 24);
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  int v13 = *(_DWORD *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  int v15 = *(_DWORD *)(v9 + 64);
  uint64_t v16 = *(void *)(v9 + 56);
  uint64_t v17 = *(void *)(v9 + 80);
  uint64_t v18 = *(void *)(v9 + 104);
  if (*(unsigned char *)(a1 + 64))
  {
    int v23 = *(_DWORD *)(v9 + 40);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 128)), a2);
    int v13 = v23;
  }
  double v19 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5) {
    double v19 = (__n128 *)((char *)a2 + 64 * v16);
  }
  double v20 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    double v20 = (__n128 *)((char *)a2 + 64 * v14);
  }
  float64x2_t v21 = (double *)(a3 + 16 * v12);
  if (v11 != 5) {
    float64x2_t v21 = (double *)((char *)a2 + 64 * v12);
  }
  *(double *)&long long v22 = v10(*v21, *v20, *v19, *((float *)a2 + 16 * v17), *((__n128 *)a2 + 4 * v18));
  *(_OWORD *)(a3 + 16 * a7) = v22;
}

float32x2_t cikernel::_stretch(CI *a1, float32x2_t a2, float32x4_t a3)
{
  DC = (float32x2_t *)CI::getDC(a1);
  __asm { FMOV            V1.2S, #1.0 }
  float32x2_t v9 = vsub_f32(_D1, vminnm_f32(vmaxnm_f32(vmul_n_f32(vabd_f32(*DC, a2), a3.f32[0]), 0), _D1));
  __asm { FMOV            V2.2S, #3.0 }
  float32x2_t v11 = vmul_f32(v9, vmul_f32(v9, vsub_f32(_D2, vadd_f32(v9, v9))));
  *(float32x2_t *)v12.f32 = vmul_laneq_f32(vsub_f32(*(float32x2_t *)CI::getDC((CI *)DC), (float32x2_t)vdup_lane_s32((int32x2_t)a2, 1)), a3, 2);
  float32x2_t v13 = vmul_f32(vmul_lane_f32((float32x2_t)*(_OWORD *)&_simd_sin_f4(v12), *(float32x2_t *)a3.f32, 1), v11);
  return vsub_f32(*(float32x2_t *)CI::getDC(v14), v13);
}

void CI::f2_f2_f3(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  float32x2_t v11 = (double (*)(void *, double, __n128))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  uint64_t v14 = *(void *)(v10 + 32);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 56)), a2);
  }
  int v15 = (double *)(a3 + 16 * v13);
  if (v12 != 5) {
    int v15 = (double *)((char *)a2 + 64 * v13);
  }
  *(double *)(a3 + 16 * a7) = v11(a1, *v15, *((__n128 *)a2 + 4 * v14));
}

void minMax(double a1, double a2, double a3, double a4, double a5, int a6, double *a7, double *a8)
{
  double v14 = a2;
  if (a1 >= a3)
  {
    double v16 = a4 + a5;
    if (a4 + a5 >= a1)
    {
      if (v16 >= v14)
      {
        *a7 = minForMiddleRange(a1, v14, a3, a4, a5, a6);
        double v18 = a1;
        goto LABEL_13;
      }
      double v17 = minForMiddleRange(a1, v16, a3, a4, a5, a6);
    }
    else
    {
      double v17 = a1 - a5;
    }
    *a7 = v17;
LABEL_11:
    double v14 = v14 - a5;
    goto LABEL_14;
  }
  if (a2 >= a3)
  {
    *a7 = a1;
    if (a4 + a5 >= a2)
    {
      double v18 = a3;
LABEL_13:
      double v14 = maxForMiddleRange(v18, v14, a3, a4, a5, a6);
      goto LABEL_14;
    }
    goto LABEL_11;
  }
  *a7 = a1;
LABEL_14:
  *a8 = v14;
}

float32x2_t cikernel::_stretchcrop(CI *a1, float32x2_t a2, float32x2_t a3, int8x16_t a4)
{
  float32x2_t v7 = (float32x2_t)vextq_s8(a4, a4, 8uLL).u64[0];
  float32x2_t v8 = *(float32x2_t *)a4.i8;
  float32x2_t v5 = vdiv_f32(vsub_f32(*(float32x2_t *)CI::getDC(a1), a3), a2);
  return vmul_f32(a2, vadd_f32(vdiv_f32(v5, vadd_f32(v8, vmul_f32(v7, vabs_f32(v5)))), (float32x2_t)0x3F0000003F000000));
}

void CI::f2_f2_f2_f4(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  float32x2_t v11 = (double (*)(void *, double, double, __n128))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  int v14 = *(_DWORD *)(v10 + 40);
  uint64_t v15 = *(void *)(v10 + 32);
  int v16 = *(_DWORD *)(v10 + 64);
  uint64_t v17 = *(void *)(v10 + 56);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 80)), a2);
  }
  double v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5) {
    double v18 = (__n128 *)((char *)a2 + 64 * v17);
  }
  double v19 = (double *)(a3 + 16 * v15);
  if (v14 != 5) {
    double v19 = (double *)((char *)a2 + 64 * v15);
  }
  double v20 = (double *)(a3 + 16 * v13);
  if (v12 != 5) {
    double v20 = (double *)((char *)a2 + 64 * v13);
  }
  *(double *)(a3 + 16 * a7) = v11(a1, *v20, *v19, *v18);
}

float32x2_t cikernel::_ninePartStretched(CI *a1, float32x2_t a2, float32x2_t a3, float32x2_t a4)
{
  DC = (float32x2_t *)CI::getDC(a1);
  return vmaxnm_f32(vminnm_f32(*DC, vadd_f32(a2, vmul_f32(a4, vsub_f32(*DC, a2)))), vsub_f32(*DC, a3));
}

int8x8_t cikernel::_ninePartTiledAlt(CI *a1, int8x16_t a2, float32x2_t a3, float32x2_t a4)
{
  DC = (float32x2_t *)CI::getDC(a1);
  float32x2_t v7 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  float32x2_t v8 = vsub_f32(*DC, a4);
  float32x2_t v9 = vsub_f32(v7, *(float32x2_t *)a2.i8);
  return vbsl_s8((int8x8_t)vcltz_f32(vsub_f32(*DC, vadd_f32(a3, v7))), vbsl_s8((int8x8_t)vcltz_f32(vsub_f32(*DC, *(float32x2_t *)a2.i8)), (int8x8_t)*DC, (int8x8_t)vadd_f32(*(float32x2_t *)a2.i8, vsub_f32(v8, vmul_f32(v9, vrndm_f32(vdiv_f32(v8, v9)))))), (int8x8_t)vsub_f32(*DC, a3));
}

void CI::f2_f4_f2_f2(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  float32x2_t v11 = (double (*)(void *, __n128, double, double))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  int v14 = *(_DWORD *)(v10 + 40);
  uint64_t v15 = *(void *)(v10 + 32);
  int v16 = *(_DWORD *)(v10 + 64);
  uint64_t v17 = *(void *)(v10 + 56);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 80)), a2);
  }
  double v18 = (double *)(a3 + 16 * v17);
  if (v16 != 5) {
    double v18 = (double *)((char *)a2 + 64 * v17);
  }
  double v19 = (double *)(a3 + 16 * v15);
  if (v14 != 5) {
    double v19 = (double *)((char *)a2 + 64 * v15);
  }
  double v20 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    double v20 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)(a3 + 16 * a7) = v11(a1, *v20, *v19, *v18);
}

double maxForMiddleRange(double a1, double a2, double a3, double a4, double a5, int a6)
{
  double v6 = a4;
  double v10 = a1 - a3;
  double v11 = a4 - a3;
  double v12 = v10 / (a4 - a3);
  double v13 = a4 + a5;
  double v14 = a1 - (a4 + a5);
  if (a6)
  {
    double v12 = v14 / v11;
    double v15 = a4 + a5;
  }
  else
  {
    double v15 = a3;
  }
  if (vcvtmd_s64_f64(v12) == vcvtmd_s64_f64((a2 - v15) / v11))
  {
    if (a6)
    {
      double v11 = v6 - a3;
      double v16 = fmod(v14, v6 - a3) + v6;
    }
    else
    {
      double v16 = fmod(v10, v11) + a3;
      double v13 = a3;
      double v6 = a3;
    }
    double v17 = fmod(a2 - v13, v11) + v6;
    if (v16 <= v17) {
      return v17;
    }
    else {
      return v16;
    }
  }
  return v6;
}

double minForMiddleRange(double a1, double a2, double a3, double a4, double a5, int a6)
{
  double v6 = a4;
  double v7 = a3;
  double v10 = a1 - a3;
  double v11 = a4 - a3;
  double v12 = v10 / (a4 - a3);
  double v13 = a4 + a5;
  double v14 = a1 - (a4 + a5);
  if (a6)
  {
    double v12 = v14 / v11;
    double v15 = a4 + a5;
  }
  else
  {
    double v15 = v7;
  }
  if (vcvtmd_s64_f64(v12) == vcvtmd_s64_f64((a2 - v15) / v11))
  {
    if (a6)
    {
      double v11 = v6 - v7;
      double v16 = fmod(v14, v6 - v7) + v6;
    }
    else
    {
      double v16 = fmod(v10, v11) + v7;
      double v13 = v7;
      double v6 = v7;
    }
    double v17 = fmod(a2 - v13, v11) + v6;
    if (v16 >= v17) {
      return v17;
    }
    else {
      return v16;
    }
  }
  return v7;
}

double cikernel::_stripes(CI *a1, float a2, float32x4_t a3, float32x4_t a4, double a5)
{
  DC = (void *)CI::getDC(a1);
  _V3.S[1] = HIDWORD(a5);
  float v7 = (float)((float)(COERCE_FLOAT(*DC) - a2) * *(float *)&a5) + -0.25;
  float v8 = v7 - floorf(v7);
  _S0 = fminf(1.0 - v8, v8);
  __asm { FMLA            S2, S0, V3.S[1] }
  if (_S2 <= 1.0) {
    float v15 = _S2;
  }
  else {
    float v15 = 1.0;
  }
  if (_S2 < 0.0) {
    float v15 = 0.0;
  }
  float v16 = (v15 * -2.0 + 3.0) * v15 * v15;
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(a4, 1.0 - v16), a3, v16).u64[0];
  return result;
}

void cikernel::_sunbeams(uint64_t a1, int8x16_t a2)
{
  float32x2_t v3 = vsub_f32(*(float32x2_t *)CI::getDC((CI *)a1), *(float32x2_t *)a2.i8);
  int32x2_t v4 = (int32x2_t)vmul_f32(v3, v3);
  unsigned __int32 v5 = vadd_f32((float32x2_t)v4, (float32x2_t)vdup_lane_s32(v4, 1)).u32[0];
  float64x2_t v6 = (float64x2_t)vextq_s8(a2, a2, 8uLL);
  float32x2_t v7 = vrsqrte_f32((float32x2_t)v5);
  *(float32x2_t *)v8.i8 = vmul_f32(v7, v7);
  double v9 = COERCE_DOUBLE(vmul_f32(v7, vrsqrts_f32((float32x2_t)v5, *(float32x2_t *)v8.i8)));
  float32x2_t v10 = (float32x2_t)vdup_n_s32(0x42480000u);
  *(float32x2_t *)&v6.f64[0] = vadd_f32(*(float32x2_t *)&v6.f64[0], vmul_f32(vmul_n_f32(v3, *(float *)&v9), v10));
  v10.i32[0] = *(_DWORD *)(a1 + 28);
  v3.f32[0] = *(float *)(a1 + 24)
            + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v6.f64[0], 1), *(float *)(a1 + 16), *(float *)v6.f64);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)&double v9 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v6.f64[0], 1), v10.f32[0], *(float *)v6.f64);
  *(float *)v6.f64 = *(float *)v8.i32 + *(float *)&v9;
  v3.f32[1] = *(float *)v8.i32 + *(float *)&v9;
  CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v3, v6, v9, *(double *)&v10, v8, v11, v12);
}

void CI::f4_sr_f4_f4_clr(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = *(void *)(a1 + 48);
  int8x16_t v11 = *(double (**)(uint64_t, __n128, __n128, __n128))(a1 + 24);
  uint64_t v12 = *(void *)(v10 + 8);
  int v13 = *(_DWORD *)(v10 + 40);
  uint64_t v14 = *(void *)(v10 + 32);
  int v15 = *(_DWORD *)(v10 + 64);
  uint64_t v16 = *(void *)(v10 + 56);
  uint64_t v17 = *(void *)(v10 + 80);
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 104)), a2);
  }
  double v18 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5) {
    double v18 = (__n128 *)((char *)a2 + 64 * v16);
  }
  double v19 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    double v19 = (__n128 *)((char *)a2 + 64 * v14);
  }
  *(double *)&long long v20 = v11(a4 + 80 * v12, *v19, *v18, *((__n128 *)a2 + 4 * v17));
  *(_OWORD *)(a3 + 16 * a7) = v20;
}

double cikernel::_swipeTransition(CI *a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5)
{
  v5.i64[0] = *(void *)CI::getDC(a1);
  v5.i64[1] = 1065353216;
  int8x16_t v6 = (int8x16_t)vmulq_f32(a5, v5);
  float v7 = vaddv_f32(vadd_f32(*(float32x2_t *)v6.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL)));
  if (v7 <= 1.0) {
    float v8 = v7;
  }
  else {
    float v8 = 1.0;
  }
  BOOL v9 = v7 < 0.0;
  float v10 = 0.0;
  if (!v9) {
    float v10 = v8;
  }
  float v11 = fminf(1.0 - v10, v10);
  float v12 = (v11 + v11) * a5.f32[3];
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(vmlaq_n_f32(vmulq_n_f32(a3, 1.0 - v10), a2, v10), 1.0 - v12), a4, v12).u64[0];
  return result;
}

void CI::f4_s_s_clr_f4(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = a1[6];
  float v10 = (double (*)(void *, __n128, __n128, __n128, __n128))a1[3];
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  int v13 = *(_DWORD *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  uint64_t v15 = *(void *)(v9 + 56);
  int v16 = *(_DWORD *)(v9 + 88);
  uint64_t v17 = *(void *)(v9 + 80);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 104)), a2);
  }
  double v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5) {
    double v18 = (__n128 *)((char *)a2 + 64 * v17);
  }
  double v19 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    double v19 = (__n128 *)((char *)a2 + 64 * v14);
  }
  long long v20 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    long long v20 = (__n128 *)((char *)a2 + 64 * v12);
  }
  *(double *)&long long v21 = v10(a1, *v20, *v19, *((__n128 *)a2 + 4 * v15), *v18);
  *(_OWORD *)(a3 + 16 * a7) = v21;
}

double get_input_xy(CIVector *a1, double *a2, double *a3)
{
  [(CIVector *)a1 X];
  double v7 = v6;
  [(CIVector *)a1 Y];
  double v9 = v8;
  double result = 1.0;
  if (v7 < 1.0 && (v7 > 0.0 ? (BOOL v11 = v9 < 1.0) : (BOOL v11 = 0), v11 && v9 > 0.0))
  {
    *a2 = v7;
    *a3 = v9;
  }
  else
  {
    if (v7 < 2000.0 || v7 > 500000.0)
    {
      double v12 = 6500.0;
      double v9 = 0.0;
    }
    else
    {
      double v12 = v7;
    }
    return tempTint_to_xy(v12, v9, a2, a3);
  }
  return result;
}

double tempTint_to_xy(double a1, double a2, double *a3, double *a4)
{
  uint64_t v4 = 0x20u;
  double v5 = 1000000.0 / a1;
  do
  {
    double v6 = *(double *)((char *)&kTempTable + v4);
    uint64_t v7 = v4 + 32;
    if (v4 == 960) {
      break;
    }
    v4 += 32;
  }
  while (v5 >= v6);
  double v8 = a2 * -0.000333333333;
  double v9 = (double *)((char *)&kTempTable + v7);
  double v10 = (v6 - v5) / (v6 - *(double *)((char *)&kTempTable + v7 - 64));
  double v11 = *(v9 - 3) * (1.0 - v10) + *(v9 - 7) * v10;
  double v12 = *(double *)((char *)&kTempTable + v7 - 40);
  double v13 = (1.0 - v10) * *(v9 - 2) + *(v9 - 6) * v10;
  double v14 = *(double *)((char *)&kTempTable + v7 - 8);
  double v15 = sqrt(v12 * v12 + 1.0);
  double v16 = sqrt(v14 * v14 + 1.0);
  double v17 = (1.0 - v10) * (1.0 / v16) + 1.0 / v15 * v10;
  double v18 = (1.0 - v10) * (v14 / v16) + v12 / v15 * v10;
  double v19 = sqrt(v18 * v18 + v17 * v17);
  double v20 = v11 + v17 / v19 * v8;
  double v21 = v13 + v18 / v19 * v8;
  double v22 = v20 * 1.5;
  double v23 = v20 + v21 * -4.0 + 2.0;
  *a3 = v22 / v23;
  double result = v21 / v23;
  *a4 = result;
  return result;
}

double cikernel::_whitepointadjust(float32x4_t a1, float32x4_t a2)
{
  *(void *)&double result = vmulq_f32(a1, a2).u64[0];
  return result;
}

void CI::f4_s_clr(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  double v11 = (double (*)(void *, __n128, __n128))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  uint64_t v14 = *(void *)(v10 + 32);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 56)), a2);
  }
  double v15 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    double v15 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v16 = v11(a1, *v15, *((__n128 *)a2 + 4 * v14));
  *(_OWORD *)(a3 + 16 * a7) = v16;
}

double cikernel::_falseColor(float32x4_t a1, float32x4_t a2, float32x4_t a3)
{
  float32x4_t v3 = vmulq_f32(a1, (float32x4_t)xmmword_193950A90);
  v3.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))).f32[0];
  *(void *)&double result = vmulq_laneq_f32(vmlaq_n_f32(vmulq_n_f32(a2, 1.0 - v3.f32[0]), a3, v3.f32[0]), a1, 3).u64[0];
  return result;
}

void CI::f4_s_clr_clr(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  double v11 = (double (*)(void *, __n128, __n128, __n128))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  uint64_t v14 = *(void *)(v10 + 32);
  uint64_t v15 = *(void *)(v10 + 56);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 80)), a2);
  }
  long long v16 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    long long v16 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v17 = v11(a1, *v16, *((__n128 *)a2 + 4 * v14), *((__n128 *)a2 + 4 * v15));
  *(_OWORD *)(a3 + 16 * a7) = v17;
}

void sub_193861BC8(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(v1 - 200))(v1 - 216);
  _Unwind_Resume(a1);
}

double makeBoundingBox(void *a1, float a2)
{
  [a1 boundingBox];
  double v5 = v4 * a2;
  [a1 boundingBox];
  [a1 boundingBox];
  [a1 boundingBox];
  [a1 boundingBox];
  return v5;
}

CGFloat makeCorners(void *a1, CGPoint *a2, CGPoint *a3, CGPoint *a4, CGPoint *a5, float a6, float a7)
{
  CGPointMakeWithDictionaryRepresentation((CFDictionaryRef)objc_msgSend((id)objc_msgSend(a1, "corners"), "objectAtIndex:", 0), a2);
  CGPointMakeWithDictionaryRepresentation((CFDictionaryRef)objc_msgSend((id)objc_msgSend(a1, "corners"), "objectAtIndex:", 1), a3);
  CGPointMakeWithDictionaryRepresentation((CFDictionaryRef)objc_msgSend((id)objc_msgSend(a1, "corners"), "objectAtIndex:", 2), a5);
  CGPointMakeWithDictionaryRepresentation((CFDictionaryRef)objc_msgSend((id)objc_msgSend(a1, "corners"), "objectAtIndex:", 3), a4);
  double v14 = a7;
  CGFloat v15 = v14 - a2->y * v14;
  a2->CGFloat x = a2->x * a6;
  a2->CGFloat y = v15;
  CGFloat v16 = v14 - a3->y * v14;
  a3->CGFloat x = a3->x * a6;
  a3->CGFloat y = v16;
  CGFloat v17 = v14 - a4->y * v14;
  a4->CGFloat x = a4->x * a6;
  a4->CGFloat y = v17;
  CGFloat result = a5->x * a6;
  CGFloat v19 = v14 - a5->y * v14;
  a5->CGFloat x = result;
  a5->CGFloat y = v19;
  return result;
}

double cikernel::_toneCurve(float32x4_t a1, float a2, int8x16_t a3, float32x4_t a4, int8x16_t a5, float32x4_t a6, int8x16_t a7, float32x4_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int8x16_t a17, float a18, uint64_t a19, int8x16_t a20,float a21)
{
  v21.f32[0] = a18;
  _V17.S[1] = a20.i32[1];
  int8x16_t v23 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(v21, a1), 0), a17, a20);
  if (a1.f32[0] >= a18) {
    float v24 = a18;
  }
  else {
    float v24 = a8.f32[0];
  }
  int8x16_t v25 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(a8, a1), 0), a7, v23);
  if (a1.f32[0] < a8.f32[0]) {
    float v24 = a6.f32[0];
  }
  int8x16_t v26 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(a6, a1), 0), a5, v25);
  if (a1.f32[0] < a6.f32[0]) {
    float v24 = a4.f32[0];
  }
  _Q19 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(a4, a1), 0), a3, v26);
  if (a1.f32[0] < a4.f32[0]) {
    float v24 = a2;
  }
  _S21 = a1.f32[0] - v24;
  __asm { FMLA            S22, S21, V19.S[1] }
  float v34 = (float)(_S22 + (float)(vmuls_lane_f32(_S21, _Q19, 2) * _S21))
      + (float)((float)(_S21 * vmuls_lane_f32(_S21, _Q19, 3)) * _S21);
  if (a1.f32[0] >= a2) {
    float v35 = v34;
  }
  else {
    float v35 = *(float *)a3.i32;
  }
  __asm { FMLA            S23, S21, V17.S[1] }
  if (a1.f32[0] <= a18) {
    _S23 = v35;
  }
  float v37 = fmaxf(_S23, 0.0);
  if (a1.f32[0] > a18) {
    float v35 = *(float *)a20.i32;
  }
  if (v35 <= 1.0) {
    float v38 = v35;
  }
  else {
    float v38 = 1.0;
  }
  if (v35 >= 0.0) {
    float v39 = v38;
  }
  else {
    float v39 = 0.0;
  }
  if (a21 >= 0.5) {
    float v39 = v37;
  }
  float32x4_t v40 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a1.f32, 1);
  int8x16_t v41 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(v21, v40), 0), a17, a20);
  if (a1.f32[1] >= a18) {
    float v42 = a18;
  }
  else {
    float v42 = a8.f32[0];
  }
  int8x16_t v43 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(a8, v40), 0), a7, v41);
  if (a1.f32[1] < a8.f32[0]) {
    float v42 = a6.f32[0];
  }
  int8x16_t v44 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(a6, v40), 0), a5, v43);
  if (a1.f32[1] < a6.f32[0]) {
    float v42 = a4.f32[0];
  }
  _Q25 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(a4, v40), 0), a3, v44);
  if (a1.f32[1] >= a4.f32[0]) {
    float v46 = v42;
  }
  else {
    float v46 = a2;
  }
  _S26 = a1.f32[1] - v46;
  __asm { FMLA            S27, S26, V25.S[1] }
  float v49 = (float)(_S27 + (float)(vmuls_lane_f32(_S26, _Q25, 2) * _S26))
      + (float)((float)(_S26 * vmuls_lane_f32(_S26, _Q25, 3)) * _S26);
  if (a1.f32[1] < a2) {
    float v49 = *(float *)a3.i32;
  }
  __asm { FMLA            S27, S26, V17.S[1] }
  if (a1.f32[1] <= a18) {
    float v51 = v49;
  }
  else {
    float v51 = _S27;
  }
  float v52 = fmaxf(v51, 0.0);
  if (a1.f32[1] > a18) {
    float v49 = *(float *)a20.i32;
  }
  if (v49 <= 1.0) {
    float v53 = v49;
  }
  else {
    float v53 = 1.0;
  }
  if (v49 >= 0.0) {
    float v54 = v53;
  }
  else {
    float v54 = 0.0;
  }
  if (a21 < 0.5) {
    float v52 = v54;
  }
  float32x4_t v55 = (float32x4_t)vdupq_laneq_s32((int32x4_t)a1, 2);
  int8x16_t v56 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(v21, v55), 0), a17, a20);
  if (a1.f32[2] >= a18) {
    float v57 = a18;
  }
  else {
    float v57 = a8.f32[0];
  }
  int8x16_t v58 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(a8, v55), 0), a7, v56);
  if (a1.f32[2] >= a8.f32[0]) {
    float v59 = v57;
  }
  else {
    float v59 = a6.f32[0];
  }
  int8x16_t v60 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(a6, v55), 0), a5, v58);
  if (a1.f32[2] >= a6.f32[0]) {
    float v61 = v59;
  }
  else {
    float v61 = a4.f32[0];
  }
  _Q4 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(a4, v55), 0), a3, v60);
  if (a1.f32[2] >= a4.f32[0]) {
    float v63 = v61;
  }
  else {
    float v63 = a2;
  }
  _S3 = a1.f32[2] - v63;
  __asm
  {
    FMLA            S5, S3, V4.S[1]
    FMLA            S2, S3, V17.S[1]
  }
  return COERCE_DOUBLE(__PAIR64__(LODWORD(v52), LODWORD(v39)));
}

void CI::f4_s_f_f4_f_f4_f_f4_f_f4_f_f4_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  uint64_t v10 = *(double (**)(__n128, float, __n128, float, __n128, float, __n128, float, double, double, double))(a1 + 24);
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  uint64_t v13 = *(void *)(v9 + 32);
  int v14 = *(_DWORD *)(v9 + 64);
  uint64_t v15 = *(void *)(v9 + 56);
  uint64_t v16 = *(void *)(v9 + 80);
  int v17 = *(_DWORD *)(v9 + 112);
  uint64_t v18 = *(void *)(v9 + 104);
  uint64_t v19 = *(void *)(v9 + 128);
  int v20 = *(_DWORD *)(v9 + 160);
  uint64_t v21 = *(void *)(v9 + 152);
  uint64_t v22 = *(void *)(v9 + 176);
  int v23 = *(_DWORD *)(v9 + 208);
  uint64_t v24 = *(void *)(v9 + 200);
  uint64_t v25 = *(void *)(v9 + 224);
  if (*(unsigned char *)(a1 + 64))
  {
    float v42 = *(double (**)(__n128, float, __n128, float, __n128, float, __n128, float, double, double, double))(a1 + 24);
    int v38 = *(_DWORD *)(v9 + 160);
    uint64_t v26 = *(void *)(v9 + 32);
    uint64_t v46 = *(void *)(v9 + 80);
    uint64_t v44 = *(void *)(v9 + 224);
    uint64_t v45 = *(void *)(v9 + 8);
    int v43 = *(_DWORD *)(v9 + 64);
    uint64_t v41 = *(void *)(v9 + 56);
    int v40 = *(_DWORD *)(v9 + 112);
    uint64_t v39 = *(void *)(v9 + 104);
    int v37 = *(_DWORD *)(v9 + 208);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 296)), a2);
    int v23 = v37;
    uint64_t v18 = v39;
    int v17 = v40;
    uint64_t v15 = v41;
    uint64_t v10 = v42;
    int v14 = v43;
    uint64_t v12 = v45;
    uint64_t v16 = v46;
    uint64_t v25 = v44;
    uint64_t v13 = v26;
    int v20 = v38;
  }
  int8x16_t v27 = (double *)(a3 + 16 * v24);
  if (v23 != 5) {
    int8x16_t v27 = (double *)((char *)a2 + 64 * v24);
  }
  int8x16_t v28 = (__n128 *)(a3 + 16 * v21);
  if (v20 != 5) {
    int8x16_t v28 = (__n128 *)((char *)a2 + 64 * v21);
  }
  float32x4_t v29 = (__n128 *)(a3 + 16 * v18);
  double v30 = (__n128 *)((char *)a2 + 64 * v18);
  if (v17 != 5) {
    float32x4_t v29 = v30;
  }
  int8x16_t v31 = (__n128 *)(a3 + 16 * v15);
  float64x2_t v32 = (__n128 *)((char *)a2 + 64 * v15);
  if (v14 != 5) {
    int8x16_t v31 = v32;
  }
  float32x4_t v33 = (__n128 *)(a3 + 16 * v12);
  float v34 = (__n128 *)((char *)a2 + 64 * v12);
  if (v11 != 5) {
    float32x4_t v33 = v34;
  }
  LODWORD(v36) = *((_DWORD *)a2 + 16 * v25);
  *(double *)&long long v35 = v10(*v33, *((float *)a2 + 16 * v13), *v31, *((float *)a2 + 16 * v16), *v29, *((float *)a2 + 16 * v19), *v28, *((float *)a2 + 16 * v22), *v27, v27[1], v36);
  *(_OWORD *)(a3 + 16 * a7) = v35;
}

__n128 cikernel::_triangleKaleidoscopeColor(CI *a1, float32x4_t a2, float32x2_t a3, int8x16_t a4, float a5)
{
  float32x2_t v6 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a3);
  double v7 = vaddv_f32(vmul_f32(*(float32x2_t *)a4.i8, v6));
  double v8 = vaddv_f32(vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v6));
  *(float *)&unsigned int v9 = v7 + 1.0 - v8;
  *(float *)&unsigned int v10 = 2.0 - v7 + v8 * -2.0;
  *(float *)&double v8 = v7 * -2.0 + 2.0 - v8;
  v11.i64[0] = __PAIR64__(v10, v9);
  v11.i64[1] = LODWORD(v8);
  float32x4_t v12 = vabsq_f32(vrndmq_f32(v11));
  result.n128_u64[0] = vmulq_n_f32(a2, powf(a5, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1), v12)).f32[0])).u64[0];
  result.n128_u32[3] = a2.u32[3];
  return result;
}

void CI::f4_s_f2_f4_f(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = a1[6];
  unsigned int v10 = (double (*)(void *, __n128, double, __n128, float))a1[3];
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  int v13 = *(_DWORD *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  int v15 = *(_DWORD *)(v9 + 64);
  uint64_t v16 = *(void *)(v9 + 56);
  uint64_t v17 = *(void *)(v9 + 80);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 104)), a2);
  }
  uint64_t v18 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5) {
    uint64_t v18 = (__n128 *)((char *)a2 + 64 * v16);
  }
  uint64_t v19 = (double *)(a3 + 16 * v14);
  if (v13 != 5) {
    uint64_t v19 = (double *)((char *)a2 + 64 * v14);
  }
  int v20 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    int v20 = (__n128 *)((char *)a2 + 64 * v12);
  }
  *(double *)&long long v21 = v10(a1, *v20, *v19, *v18, *((float *)a2 + 16 * v17));
  *(_OWORD *)(a3 + 16 * a7) = v21;
}

float32x2_t cikernel::_triangleKaleidoscopeGeom(CI *a1, float32x2_t a2, int8x16_t a3, int8x16_t a4)
{
  float32x2_t v5 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  int32x2_t v6 = (int32x2_t)vmul_f32(*(float32x2_t *)a3.i8, v5);
  int32x2_t v7 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v5);
  float32x2_t v8 = vadd_f32((float32x2_t)vzip1_s32(v6, v7), (float32x2_t)vzip2_s32(v6, v7));
  int32x2_t v9 = (int32x2_t)vminnm_f32(vsub_f32(v8, vrndm_f32(v8)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu));
  float32x2_t v11 = (float32x2_t)vdup_lane_s32(vcgt_f32((float32x2_t)v9, (float32x2_t)vdup_lane_s32(v9, 1)), 0);
  int32x2_t v10 = (int32x2_t)vbsl_s8((int8x8_t)v11, (int8x8_t)vrev64_s32(v9), (int8x8_t)v9);
  v11.i32[0] = v10.i32[1];
  double v12 = *(float *)v10.i32;
  double v13 = 2.0 - *(float *)v10.i32 - *(float *)&v10.i32[1];
  if (v13 < *(float *)&v10.i32[1])
  {
    float32_t v14 = v13;
    v11.f32[0] = v14;
  }
  double v15 = 1.0 - v12 - v11.f32[0];
  if (v15 > v12)
  {
    float v16 = v15;
    *(float *)v10.i32 = v16;
  }
  int32x2_t v17 = vcgt_f32((float32x2_t)v10, v11);
  v10.i32[1] = v11.i32[0];
  float32x2_t v18 = (float32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32(v17, 0), (int8x8_t)vrev64_s32(v10), (int8x8_t)v10);
  int32x2_t v19 = (int32x2_t)vmul_f32(*(float32x2_t *)a4.i8, v18);
  int32x2_t v20 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v18);
  return vadd_f32(a2, vadd_f32((float32x2_t)vzip1_s32(v19, v20), (float32x2_t)vzip2_s32(v19, v20)));
}

double triangleBounds(float a1, float a2, float32x2_t a3)
{
  __double2 v4 = __sincos_stret(a2);
  v5.f32[0] = v4.__sinval * 0.288675129 + v4.__cosval * -0.5;
  float32_t v6 = v4.__cosval * -0.288675129 + v4.__sinval * -0.5;
  v5.f32[1] = v6;
  float32x2_t v7 = vadd_f32(a3, vmul_n_f32(v5, a1));
  v8.f32[0] = v4.__sinval * 0.288675129 + v4.__cosval * 0.5;
  v5.f32[0] = v4.__cosval * -0.288675129 + v4.__sinval * 0.5;
  v8.i32[1] = v5.i32[0];
  float32x2_t v9 = vadd_f32(a3, vmul_n_f32(v8, a1));
  float32x2_t v19 = vadd_f32(a3, vmul_n_f32(vcvt_f32_f64(vmlaq_f64(vmulq_f64((float64x2_t)v4, (float64x2_t)xmmword_193957060), (float64x2_t)0, (float64x2_t)vextq_s8((int8x16_t)v4, (int8x16_t)v4, 8uLL))), a1));
  v4.__sinval = v7.f32[0];
  double v10 = v7.f32[1];
  v22.origin.CGFloat x = v9.f32[0];
  v22.origin.CGFloat y = v9.f32[1];
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  v22.size.CGFloat width = 0.0;
  v22.size.CGFloat height = 0.0;
  CGRect v21 = CGRectUnion(*(CGRect *)&v4.__sinval, v22);
  uint64_t v15 = 0;
  uint64_t v16 = 0;

  double v13 = v19.f32[0];
  double v14 = v19.f32[1];
  *(void *)&double result = (unint64_t)CGRectUnion(v21, *(CGRect *)(&v15 - 2));
  return result;
}

double cikernel::_triangleTile(uint64_t a1, float32x2_t a2, int8x16_t a3, int8x16_t a4)
{
  float32x2_t v6 = vsub_f32(*(float32x2_t *)CI::getDC((CI *)a1), a2);
  *(float32x2_t *)&v12.f64[0] = vmul_f32(*(float32x2_t *)a3.i8, v6);
  int32x2_t v8 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v6);
  float32x2_t v9 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)&v12.f64[0], v8), (float32x2_t)vzip2_s32(*(int32x2_t *)&v12.f64[0], v8));
  int32x2_t v10 = (int32x2_t)vminnm_f32(vsub_f32(v9, vrndm_f32(v9)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu));
  *(int32x2_t *)&v12.f64[0] = vdup_lane_s32(vcgt_f32((float32x2_t)v10, (float32x2_t)vdup_lane_s32(v10, 1)), 0);
  int32x2_t v11 = (int32x2_t)vbsl_s8(*(int8x8_t *)&v12.f64[0], (int8x8_t)vrev64_s32(v10), (int8x8_t)v10);
  LODWORD(v12.f64[0]) = v11.i32[1];
  double v13 = *(float *)v11.i32;
  *(double *)v14.i64 = 2.0 - *(float *)v11.i32 - *(float *)&v11.i32[1];
  *(float *)v15.i32 = *(double *)v14.i64;
  if (*(double *)v14.i64 < *(float *)&v11.i32[1]) {
    *(float *)v12.f64 = *(double *)v14.i64;
  }
  *(double *)v14.i64 = *(float *)v12.f64;
  double v16 = 1.0 - v13 - *(float *)v12.f64;
  if (v16 > v13)
  {
    float v17 = v16;
    *(float *)v11.i32 = v17;
  }
  int32x2_t v18 = vcgt_f32((float32x2_t)v11, *(float32x2_t *)&v12.f64[0]);
  v11.i32[1] = LODWORD(v12.f64[0]);
  float32x2_t v19 = (float32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32(v18, 0), (int8x8_t)vrev64_s32(v11), (int8x8_t)v11);
  int32x2_t v20 = (int32x2_t)vmul_f32(*(float32x2_t *)a4.i8, v19);
  int32x2_t v21 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v19);
  float32x2_t v22 = (float32x2_t)vzip1_s32(v20, v21);
  *(float32x2_t *)&v12.f64[0] = vadd_f32(a2, vadd_f32(v22, (float32x2_t)vzip2_s32(v20, v21)));
  LODWORD(v13) = *(_DWORD *)(a1 + 28);
  *(float *)v21.i32 = *(float *)(a1 + 24)
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v12.f64[0], 1), *(float *)(a1 + 16), *(float *)v12.f64);
  v14.i32[0] = *(_DWORD *)(a1 + 36);
  v22.f32[0] = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v12.f64[0], 1), *(float *)&v13, *(float *)v12.f64);
  int v23 = *(uint64x2_t **)(a1 + 8);

  *(float *)&v21.i32[1] = *(float *)v14.i32 + v22.f32[0];
  *(float *)v12.f64 = *(float *)v14.i32 + v22.f32[0];
  return CI::BitmapSampler::read(v23, *(double *)&v21, v12, *(double *)&v22, v13, v14, v15, v7);
}

void cikernel::_twirl(CI *a1, float32x4_t a2)
{
  DC = (float32x2_t *)CI::getDC(a1);
  float32x2_t v3 = vsub_f32(*DC, *(float32x2_t *)a2.f32);
  float v4 = fminf(vmuls_lane_f32(sqrtf(vaddv_f32(vmul_f32(v3, v3))), a2, 2), 1.0);
  if (v4 >= 1.0)
  {
    CI::getDC((CI *)DC);
  }
  else
  {
    float v5 = ((float)(1.0 - v4) * -2.0 + 3.0) * (float)(1.0 - v4) * (float)(1.0 - v4);
    __sincosf_stret(vmuls_lane_f32(v5, a2, 3));
  }
}

void twirlTracePoint(double a1, double a2, CGPoint a3, float a4, float a5, CGRect *a6)
{
  double v7 = a2;
  double v8 = a1;
  double v9 = a1 - a3.x;
  double v10 = a2 - a3.y;
  float v11 = v10 * v10 + v9 * v9;
  float v12 = fminf(sqrtf(v11) * a4, 1.0);
  if (v12 < 1.0)
  {
    double y = a3.y;
    double x = a3.x;
    float v15 = ((float)(1.0 - v12) * -2.0 + 3.0) * (float)(1.0 - v12) * (float)(1.0 - v12);
    __float2 v16 = __sincosf_stret(v15 * a5);
    float v17 = v10 * v16.__sinval + v9 * v16.__cosval;
    float v18 = v10 * v16.__cosval - v9 * v16.__sinval;
    double v8 = x + v17;
    double v7 = y + v18;
  }
  v19.double x = v8;
  v19.double y = v7;
  if (!CGRectContainsPoint(*a6, v19))
  {
    v20.size.CGFloat width = 0.0;
    v20.size.CGFloat height = 0.0;
    v20.origin.double x = v8;
    v20.origin.double y = v7;
    *a6 = CGRectUnion(*a6, v20);
  }
}

double cikernel::_unsharpmask(float32x4_t a1, float32x4_t a2, float a3)
{
  *(void *)&double result = vaddq_f32(a1, vmulq_n_f32(vsubq_f32(a1, vmulq_n_f32(a2, a1.f32[3] / fmaxf(a2.f32[3], 0.0001))), a3)).u64[0];
  return result;
}

void sub_1938669B4(_Unwind_Exception *a1)
{
}

void __Block_byref_object_copy__18(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__18(uint64_t a1)
{
}

Class __getVNFaceObservationClass_block_invoke(uint64_t a1)
{
  VisionLibrary_1();
  Class result = objc_getClass("VNFaceObservation");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    __getVNFaceObservationClass_block_invoke_cold_1();
  }
  getVNFaceObservationClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

uint64_t VisionLibrary_1()
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  v2[0] = 0;
  if (!VisionLibraryCore_frameworkLibrary_1)
  {
    v2[1] = (void *)MEMORY[0x1E4F143A8];
    _OWORD v2[2] = (void *)3221225472;
    v2[3] = __VisionLibraryCore_block_invoke_1;
    void v2[4] = &__block_descriptor_40_e5_v8__0l;
    v2[5] = v2;
    long long v3 = xmmword_1E5772E70;
    uint64_t v4 = 0;
    VisionLibraryCore_frameworkLibrary_1 = _sl_dlopen();
  }
  uint64_t v0 = VisionLibraryCore_frameworkLibrary_1;
  if (!VisionLibraryCore_frameworkLibrary_1) {
    VisionLibrary_cold_1(v2);
  }
  if (v2[0]) {
    free(v2[0]);
  }
  return v0;
}

uint64_t __VisionLibraryCore_block_invoke_1()
{
  uint64_t result = _sl_dlopen();
  VisionLibraryCore_frameworkLibrary_1 = result;
  return result;
}

void *__getVNFaceAttributeSmilingSymbolLoc_block_invoke(uint64_t a1)
{
  float32x4_t v2 = (void *)VisionLibrary_1();
  uint64_t result = dlsym(v2, "VNFaceAttributeSmiling");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getVNFaceAttributeSmilingSymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *__getVNFaceAttributeEyesClosedSymbolLoc_block_invoke(uint64_t a1)
{
  float32x4_t v2 = (void *)VisionLibrary_1();
  uint64_t result = dlsym(v2, "VNFaceAttributeEyesClosed");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getVNFaceAttributeEyesClosedSymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

double cikernel::_variableBoxBlur(uint64_t a1, uint64_t a2, float a3, int8x16_t a4)
{
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)&double v8 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *DC, 1), *(float *)(a2 + 16), COERCE_FLOAT(*DC));
  LODWORD(v9) = *(_DWORD *)(a2 + 28);
  v10.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *DC, 1), *(float *)&v9, COERCE_FLOAT(*DC));
  *(float *)&double v12 = *(float *)(a2 + 24) + *(float *)&v8;
  *(float *)v13.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  *((float *)&v12 + 1) = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v15.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v12, v13, v8, v9, v11, v10, v14);
  float32x4_t v16 = vmulq_f32(vmulq_n_f32(v15, 1.0 / fmaxf(v15.f32[3], 0.00001)), (float32x4_t)xmmword_193954EE0);
  float32x4_t v17 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 2), vaddq_f32(v16, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v16.f32, 1)));
  v17.f32[0] = fmaxf(a3 * v17.f32[0], 0.5);
  float32x4_t v164 = v17;
  CGPoint v19 = (float32x2_t *)CI::getDC(v18);
  v20.f32[0] = -1.0 - v164.f32[0];
  int8x16_t v21 = (int8x16_t)v164;
  v20.f32[1] = -v164.f32[0];
  float32x2_t v22 = vadd_f32(*v19, v20);
  int8x16_t v23 = a4;
  float32x2_t v24 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(v23, v23, 8uLL), *(float32x2_t *)a4.i8);
  int8x16_t v25 = a4;
  *(float32x2_t *)v23.i8 = vminnm_f32(vmaxnm_f32(v22, *(float32x2_t *)a4.i8), v24);
  int8x16_t v170 = v23;
  *(float *)&v21.i32[1] = v164.f32[0] + 1.0;
  *(float32x2_t *)&v26.f64[0] = vminnm_f32(vmaxnm_f32(vadd_f32(*v19, *(float32x2_t *)v21.i8), *(float32x2_t *)a4.i8), v24);
  float64x2_t v168 = v26;
  int8x16_t v27 = v23;
  v27.i32[1] = HIDWORD(v26.f64[0]);
  *(float32x2_t *)v27.i8 = vadd_f32(*(float32x2_t *)v27.i8, (float32x2_t)0xBF000000BF000000);
  float32x2_t v28 = vrndm_f32(*(float32x2_t *)v27.i8);
  *(float32x2_t *)&v26.f64[0] = vadd_f32(v28, (float32x2_t)0x3F0000003F000000);
  *(float *)v23.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v26.f64[0], 1), *(float *)(a1 + 16), *(float *)v26.f64);
  v24.i32[0] = *(_DWORD *)(a1 + 24);
  v25.i32[0] = *(_DWORD *)(a1 + 28);
  v29.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v21.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v26.f64[0], 1), *(float *)v25.i32, *(float *)v26.f64);
  __asm { FMOV            V12.2S, #1.0 }
  float32x2_t v35 = vadd_f32(v28, _D12);
  *(float32x2_t *)v27.i8 = vsub_f32(v35, *(float32x2_t *)v27.i8);
  int8x16_t v165 = v27;
  *(float *)v27.i32 = v24.f32[0] + *(float *)v23.i32;
  *(float *)v26.f64 = *(float *)v29.i32 + *(float *)v21.i32;
  *(float *)&v27.i32[1] = *(float *)v29.i32 + *(float *)v21.i32;
  *(double *)v36.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v27.i64, v26, *(double *)&v24, *(double *)v23.i64, v25, v21, v29);
  float32x4_t v161 = v36;
  *(float32x2_t *)v36.f32 = vadd_f32(v35, (float32x2_t)0x3F0000003F000000);
  *(float *)&double v37 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v36.f32, 1), *(float *)(a1 + 16), v36.f32[0]);
  LODWORD(v3_Block_object_dispose(&STACK[0x238], 8) = *(_DWORD *)(a1 + 28);
  v39.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v40.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v36.f32, 1), *(float *)&v38, v36.f32[0]);
  v36.f32[0] = *(float *)(a1 + 24) + *(float *)&v37;
  *(float *)v41.f64 = *(float *)v39.i32 + *(float *)v40.i32;
  v36.f32[1] = *(float *)v39.i32 + *(float *)v40.i32;
  *(double *)v43.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v36.i64, v41, v37, v38, v40, v39, v42);
  float32x4_t v157 = v43;
  *(float32x2_t *)v43.f32 = vadd_f32(vadd_f32(v28, (float32x2_t)0x800000003F800000), (float32x2_t)0x3F0000003F000000);
  *(float *)&double v44 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v43.f32, 1), *(float *)(a1 + 16), v43.f32[0]);
  LODWORD(v45) = *(_DWORD *)(a1 + 28);
  v46.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v47.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v43.f32, 1), *(float *)&v45, v43.f32[0]);
  v43.f32[0] = *(float *)(a1 + 24) + *(float *)&v44;
  *(float *)v48.f64 = *(float *)v46.i32 + *(float *)v47.i32;
  v43.f32[1] = *(float *)v46.i32 + *(float *)v47.i32;
  *(double *)v50.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v43.i64, v48, v44, v45, v47, v46, v49);
  float32x4_t v153 = v50;
  *(float32x2_t *)v50.f32 = vadd_f32(vadd_f32(v28, (float32x2_t)0x3F80000080000000), (float32x2_t)0x3F0000003F000000);
  *(float *)&double v51 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v50.f32, 1), *(float *)(a1 + 16), v50.f32[0]);
  LODWORD(v52) = *(_DWORD *)(a1 + 28);
  v53.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v54.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v50.f32, 1), *(float *)&v52, v50.f32[0]);
  v50.f32[0] = *(float *)(a1 + 24) + *(float *)&v51;
  *(float *)v55.f64 = *(float *)v53.i32 + *(float *)v54.i32;
  v50.f32[1] = *(float *)v53.i32 + *(float *)v54.i32;
  *(double *)v57.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v50.i64, v55, v51, v52, v54, v53, v56);
  int8x16_t v58 = v165;
  float32x4_t v59 = vmlaq_n_f32(vmulq_n_f32(v153, 1.0 - *(float *)v165.i32), v161, *(float *)v165.i32);
  int8x16_t v60 = (int8x16_t)v157;
  float32x4_t v61 = vmlaq_n_f32(vmulq_n_f32(v157, 1.0 - *(float *)v165.i32), v57, *(float *)v165.i32);
  float32x4_t v166 = vmlaq_lane_f32(vmulq_n_f32(v61, 1.0 - *(float *)&v165.i32[1]), v59, *(float32x2_t *)v165.i8, 1);
  v57.i64[1] = *(void *)&v168.f64[1];
  *(float32x2_t *)v57.f32 = vadd_f32(*(float32x2_t *)&v168.f64[0], (float32x2_t)0xBF000000BF000000);
  float32x2_t v62 = vrndm_f32(*(float32x2_t *)v57.f32);
  *(float32x2_t *)v61.f32 = vadd_f32(v62, (float32x2_t)0x3F0000003F000000);
  *(float *)&double v63 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v61.f32, 1), *(float *)(a1 + 16), v61.f32[0]);
  v59.i32[0] = *(_DWORD *)(a1 + 24);
  v58.i32[0] = *(_DWORD *)(a1 + 28);
  v64.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v60.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v61.f32, 1), *(float *)v58.i32, v61.f32[0]);
  float32x2_t v65 = vadd_f32(v62, _D12);
  *(float32x2_t *)v57.f32 = vsub_f32(v65, *(float32x2_t *)v57.f32);
  float32x4_t v162 = v57;
  v57.f32[0] = v59.f32[0] + *(float *)&v63;
  v61.f32[0] = *(float *)v64.i32 + *(float *)v60.i32;
  v57.f32[1] = *(float *)v64.i32 + *(float *)v60.i32;
  *(double *)v66.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v57.i64, (float64x2_t)v61, *(double *)v59.i64, v63, v58, v60, v64);
  float32x4_t v158 = v66;
  *(float32x2_t *)v66.f32 = vadd_f32(v65, (float32x2_t)0x3F0000003F000000);
  *(float *)&double v67 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v66.f32, 1), *(float *)(a1 + 16), v66.f32[0]);
  LODWORD(v6_Block_object_dispose(&STACK[0x238], 8) = *(_DWORD *)(a1 + 28);
  v69.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v70.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v66.f32, 1), *(float *)&v68, v66.f32[0]);
  v66.f32[0] = *(float *)(a1 + 24) + *(float *)&v67;
  *(float *)v71.f64 = *(float *)v69.i32 + *(float *)v70.i32;
  v66.f32[1] = *(float *)v69.i32 + *(float *)v70.i32;
  *(double *)v73.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v66.i64, v71, v67, v68, v70, v69, v72);
  float32x4_t v154 = v73;
  *(float32x2_t *)v73.f32 = vadd_f32(vadd_f32(v62, (float32x2_t)0x800000003F800000), (float32x2_t)0x3F0000003F000000);
  *(float *)&double v74 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v73.f32, 1), *(float *)(a1 + 16), v73.f32[0]);
  LODWORD(v75) = *(_DWORD *)(a1 + 28);
  v76.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v77.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v73.f32, 1), *(float *)&v75, v73.f32[0]);
  v73.f32[0] = *(float *)(a1 + 24) + *(float *)&v74;
  *(float *)v78.f64 = *(float *)v76.i32 + *(float *)v77.i32;
  v73.f32[1] = *(float *)v76.i32 + *(float *)v77.i32;
  *(double *)v80.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v73.i64, v78, v74, v75, v77, v76, v79);
  float32x4_t v150 = v80;
  *(float32x2_t *)v80.f32 = vadd_f32(vadd_f32(v62, (float32x2_t)0x3F80000080000000), (float32x2_t)0x3F0000003F000000);
  *(float *)&double v81 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v80.f32, 1), *(float *)(a1 + 16), v80.f32[0]);
  LODWORD(v82) = *(_DWORD *)(a1 + 28);
  v83.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v84.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v80.f32, 1), *(float *)&v82, v80.f32[0]);
  v80.f32[0] = *(float *)(a1 + 24) + *(float *)&v81;
  *(float *)v85.f64 = *(float *)v83.i32 + *(float *)v84.i32;
  v80.f32[1] = *(float *)v83.i32 + *(float *)v84.i32;
  *(double *)v87.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v80.i64, v85, v81, v82, v84, v83, v86);
  int8x16_t v88 = (int8x16_t)v162;
  float32x4_t v89 = vmlaq_n_f32(vmulq_n_f32(v150, 1.0 - v162.f32[0]), v158, v162.f32[0]);
  int8x16_t v90 = (int8x16_t)v154;
  float32x4_t v91 = vmlaq_n_f32(vmulq_n_f32(v154, 1.0 - v162.f32[0]), v87, v162.f32[0]);
  float32x4_t v163 = vmlaq_lane_f32(vmulq_n_f32(v91, 1.0 - v162.f32[1]), v89, *(float32x2_t *)v162.f32, 1);
  v87.i64[1] = v170.i64[1];
  *(float32x2_t *)v87.f32 = vadd_f32(*(float32x2_t *)v170.i8, (float32x2_t)0xBF000000BF000000);
  float32x2_t v92 = vrndm_f32(*(float32x2_t *)v87.f32);
  *(float32x2_t *)v91.f32 = vadd_f32(v92, (float32x2_t)0x3F0000003F000000);
  *(float *)&double v93 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v91.f32, 1), *(float *)(a1 + 16), v91.f32[0]);
  v89.i32[0] = *(_DWORD *)(a1 + 24);
  v88.i32[0] = *(_DWORD *)(a1 + 28);
  v94.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v90.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v91.f32, 1), *(float *)v88.i32, v91.f32[0]);
  float32x2_t v95 = vadd_f32(v92, _D12);
  *(float32x2_t *)v87.f32 = vsub_f32(v95, *(float32x2_t *)v87.f32);
  float32x4_t v159 = v87;
  v87.f32[0] = v89.f32[0] + *(float *)&v93;
  v91.f32[0] = *(float *)v94.i32 + *(float *)v90.i32;
  v87.f32[1] = *(float *)v94.i32 + *(float *)v90.i32;
  *(double *)v96.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v87.i64, (float64x2_t)v91, *(double *)v89.i64, v93, v88, v90, v94);
  float32x4_t v155 = v96;
  *(float32x2_t *)v96.f32 = vadd_f32(v95, (float32x2_t)0x3F0000003F000000);
  *(float *)&double v97 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v96.f32, 1), *(float *)(a1 + 16), v96.f32[0]);
  LODWORD(v9_Block_object_dispose(&STACK[0x238], 8) = *(_DWORD *)(a1 + 28);
  v99.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v100.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v96.f32, 1), *(float *)&v98, v96.f32[0]);
  v96.f32[0] = *(float *)(a1 + 24) + *(float *)&v97;
  *(float *)v101.f64 = *(float *)v99.i32 + *(float *)v100.i32;
  v96.f32[1] = *(float *)v99.i32 + *(float *)v100.i32;
  *(double *)v103.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v96.i64, v101, v97, v98, v100, v99, v102);
  float32x4_t v151 = v103;
  *(float32x2_t *)v103.f32 = vadd_f32(vadd_f32(v92, (float32x2_t)0x800000003F800000), (float32x2_t)0x3F0000003F000000);
  *(float *)&double v104 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v103.f32, 1), *(float *)(a1 + 16), v103.f32[0]);
  LODWORD(v105) = *(_DWORD *)(a1 + 28);
  v106.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v107.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v103.f32, 1), *(float *)&v105, v103.f32[0]);
  v103.f32[0] = *(float *)(a1 + 24) + *(float *)&v104;
  *(float *)v108.f64 = *(float *)v106.i32 + *(float *)v107.i32;
  v103.f32[1] = *(float *)v106.i32 + *(float *)v107.i32;
  *(double *)v110.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v103.i64, v108, v104, v105, v107, v106, v109);
  float32x4_t v149 = v110;
  *(float32x2_t *)v110.f32 = vadd_f32(vadd_f32(v92, (float32x2_t)0x3F80000080000000), (float32x2_t)0x3F0000003F000000);
  *(float *)&double v111 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v110.f32, 1), *(float *)(a1 + 16), v110.f32[0]);
  LODWORD(v112) = *(_DWORD *)(a1 + 28);
  v113.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v114.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v110.f32, 1), *(float *)&v112, v110.f32[0]);
  v110.f32[0] = *(float *)(a1 + 24) + *(float *)&v111;
  *(float *)v115.f64 = *(float *)v113.i32 + *(float *)v114.i32;
  v110.f32[1] = *(float *)v113.i32 + *(float *)v114.i32;
  *(double *)v117.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v110.i64, v115, v111, v112, v114, v113, v116);
  int8x16_t v118 = (int8x16_t)v159;
  float32x4_t v119 = vmlaq_n_f32(vmulq_n_f32(v149, 1.0 - v159.f32[0]), v155, v159.f32[0]);
  float32x4_t v160 = vmlaq_lane_f32(vmulq_n_f32(vmlaq_n_f32(vmulq_n_f32(v151, 1.0 - v159.f32[0]), v117, v159.f32[0]), 1.0 - v159.f32[1]), v119, *(float32x2_t *)v159.f32, 1);
  *(void *)&v120.f64[1] = v170.i64[1];
  *(float32x2_t *)v117.f32 = vadd_f32((float32x2_t)__PAIR64__(v170.u32[1], LODWORD(v168.f64[0])), (float32x2_t)0xBF000000BF000000);
  float32x2_t v121 = vrndm_f32(*(float32x2_t *)v117.f32);
  float32x2_t v122 = vadd_f32(v121, _D12);
  *(float32x2_t *)v170.i8 = vsub_f32(v122, *(float32x2_t *)v117.f32);
  *(float32x2_t *)&v120.f64[0] = vadd_f32(v121, (float32x2_t)0x3F0000003F000000);
  LODWORD(v123) = *(_DWORD *)(a1 + 28);
  v117.f32[0] = *(float *)(a1 + 24)
              + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v120.f64[0], 1), *(float *)(a1 + 16), *(float *)v120.f64);
  v118.i32[0] = *(_DWORD *)(a1 + 36);
  v119.f32[0] = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v120.f64[0], 1), *(float *)&v123, *(float *)v120.f64);
  *(float *)v120.f64 = *(float *)v118.i32 + v119.f32[0];
  v117.f32[1] = *(float *)v118.i32 + v119.f32[0];
  *(double *)v125.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v117.i64, v120, *(double *)v119.i64, v123, v118, (int8x16_t)v151, v124);
  float32x4_t v169 = v125;
  *(float32x2_t *)v125.f32 = vadd_f32(v122, (float32x2_t)0x3F0000003F000000);
  *(float *)&double v126 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v125.f32, 1), *(float *)(a1 + 16), v125.f32[0]);
  LODWORD(v127) = *(_DWORD *)(a1 + 28);
  v128.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v129.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v125.f32, 1), *(float *)&v127, v125.f32[0]);
  v125.f32[0] = *(float *)(a1 + 24) + *(float *)&v126;
  *(float *)v130.f64 = *(float *)v128.i32 + *(float *)v129.i32;
  v125.f32[1] = *(float *)v128.i32 + *(float *)v129.i32;
  *(double *)v132.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v125.i64, v130, v126, v127, v129, v128, v131);
  float32x4_t v156 = v132;
  *(float32x2_t *)v132.f32 = vadd_f32(vadd_f32(v121, (float32x2_t)0x800000003F800000), (float32x2_t)0x3F0000003F000000);
  *(float *)&double v133 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v132.f32, 1), *(float *)(a1 + 16), v132.f32[0]);
  LODWORD(v134) = *(_DWORD *)(a1 + 28);
  v135.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v136.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v132.f32, 1), *(float *)&v134, v132.f32[0]);
  v132.f32[0] = *(float *)(a1 + 24) + *(float *)&v133;
  *(float *)v137.f64 = *(float *)v135.i32 + *(float *)v136.i32;
  v132.f32[1] = *(float *)v135.i32 + *(float *)v136.i32;
  *(double *)v139.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v132.i64, v137, v133, v134, v136, v135, v138);
  float32x4_t v152 = v139;
  *(float32x2_t *)v139.f32 = vadd_f32(vadd_f32(v121, (float32x2_t)0x3F80000080000000), (float32x2_t)0x3F0000003F000000);
  *(float *)&double v140 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v139.f32, 1), *(float *)(a1 + 16), v139.f32[0]);
  LODWORD(v141) = *(_DWORD *)(a1 + 28);
  v142.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v143.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v139.f32, 1), *(float *)&v141, v139.f32[0]);
  v139.f32[0] = *(float *)(a1 + 24) + *(float *)&v140;
  *(float *)v144.f64 = *(float *)v142.i32 + *(float *)v143.i32;
  v139.f32[1] = *(float *)v142.i32 + *(float *)v143.i32;
  *(double *)v146.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v139.i64, v144, v140, v141, v143, v142, v145);
  float32x4_t v147 = vsubq_f32(vsubq_f32(vaddq_f32(v166, vmlaq_lane_f32(vmulq_n_f32(vmlaq_n_f32(vmulq_n_f32(v156, 1.0 - *(float *)v170.i32), v146, *(float *)v170.i32), 1.0 - *(float *)&v170.i32[1]), vmlaq_n_f32(vmulq_n_f32(v152, 1.0 - *(float *)v170.i32), v169, *(float *)v170.i32), *(float32x2_t *)v170.i8, 1)), v163), v160);
  *(void *)&double result = vdivq_f32(v147, (float32x4_t)vdupq_laneq_s32((int32x4_t)v147, 3)).u64[0];
  return result;
}

void CI::f4_sr_sr_f_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = *(void *)(a1 + 48);
  double v12 = *(double (**)(uint64_t, uint64_t, float, __n128))(a1 + 24);
  uint64_t v13 = *(void *)(v11 + 8);
  uint64_t v14 = *(void *)(v11 + 32);
  uint64_t v15 = *(void *)(v11 + 56);
  int v16 = *(_DWORD *)(v11 + 88);
  uint64_t v17 = *(void *)(v11 + 80);
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC((CI *)(a3 + 16 * *(void *)(v11 + 104)), a2);
  }
  float v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5) {
    float v18 = (__n128 *)((char *)a2 + 64 * v17);
  }
  *(double *)&long long v19 = v12(a4 + 80 * v13, a4 + 80 * v14, *((float *)a2 + 16 * v15), *v18);
  *(_OWORD *)(a3 + 16 * a7) = v19;
}

double cikernel::_vibrance_neg(float32x4_t a1, float a2)
{
  float32x4_t v2 = vminnmq_f32(vmaxnmq_f32(a1, (float32x4_t)vdupq_n_s32(0x38D1B717u)), (float32x4_t)vdupq_n_s32(0x3F7FF972u));
  float32x4_t v3 = vsubq_f32(a1, v2);
  double v4 = (float)(v2.f32[2] + vaddv_f32(*(float32x2_t *)v2.f32)) * 0.33333;
  *(float *)&double v4 = v4;
  float v5 = 1.0 / *(float *)&v4;
  float v6 = 1.0 / (1.0 - *(float *)&v4);
  float32x4_t v7 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v4, 0);
  float32x4_t v8 = vsubq_f32(v2, v7);
  float32x4_t v9 = vmulq_n_f32(v8, v6);
  float32x4_t v10 = vmulq_n_f32(vsubq_f32(v7, v2), v5);
  v9.i32[3] = 0;
  v10.i32[3] = 0;
  float32x4_t v11 = vmaxnmq_f32(v9, v10);
  float v12 = fmaxf(fmaxf(v11.f32[0], v11.f32[1]), v11.f32[2]);
  float v13 = -(v2.f32[2] - v2.f32[1] * 2.0);
  float v14 = (1.0 - v11.f32[0]) * (fminf(v2.f32[0] - v2.f32[1], v13) * 4.0) * v5;
  if (v14 <= 1.0) {
    float v15 = v14;
  }
  else {
    float v15 = 1.0;
  }
  _NF = v14 < 0.0;
  float v17 = 0.0;
  if (!_NF) {
    float v17 = v15;
  }
  float v18 = v17 * 0.7 + 0.15;
  float v19 = (v12 * (v12 + -1.0) + 1.0) * a2 * (1.0 - v18);
  float32x4_t v20 = vmaxnmq_f32(vaddq_f32(v2, vmulq_n_f32(v8, v19)), (float32x4_t)0);
  __asm { FMOV            V3.4S, #1.0 }
  *(void *)&double result = vaddq_f32(v3, vminnmq_f32(v20, _Q3)).u64[0];
  return result;
}

double cikernel::_vibrance_pos(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2 = vminnmq_f32(vmaxnmq_f32(a1, (float32x4_t)vdupq_n_s32(0x38D1B717u)), (float32x4_t)vdupq_n_s32(0x3F7FF972u));
  float32x4_t v3 = vsubq_f32(a1, v2);
  v4.i32[1] = 1070945607;
  *(float *)v4.i32 = (float)(v2.f32[2] + vaddv_f32(*(float32x2_t *)v2.f32)) * 0.33333;
  float v5 = 1.0 / *(float *)v4.i32;
  float v6 = 1.0 / (1.0 - *(float *)v4.i32);
  float32x4_t v7 = (float32x4_t)vdupq_lane_s32(v4, 0);
  float32x4_t v8 = vsubq_f32(v2, v7);
  float32x4_t v9 = vmulq_n_f32(v8, v6);
  float32x4_t v10 = vmulq_n_f32(vsubq_f32(v7, v2), v5);
  v9.i32[3] = 0;
  v10.i32[3] = 0;
  float32x4_t v11 = vmaxnmq_f32(v9, v10);
  float v12 = fmaxf(fmaxf(v11.f32[0], v11.f32[1]), v11.f32[2]);
  float v13 = -(v2.f32[2] - v2.f32[1] * 2.0);
  float v14 = (1.0 - v11.f32[0]) * (fminf(v2.f32[0] - v2.f32[1], v13) * 4.0) * v5;
  if (v14 <= 1.0) {
    float v15 = v14;
  }
  else {
    float v15 = 1.0;
  }
  _NF = v14 < 0.0;
  float v17 = 0.0;
  if (!_NF) {
    float v17 = v15;
  }
  float v18 = v17 * 0.7 + 0.15;
  __asm { FMOV            V17.4S, #1.0 }
  v23.i64[0] = __PAIR64__(LODWORD(v12), _Q17.u32[0]);
  v23.f32[2] = v12 * v12;
  v23.f32[3] = v12 * (float)(v12 * v12);
  int8x16_t v24 = (int8x16_t)vmulq_f32(a2, v23);
  *(float *)v24.i32 = (1.0 - v18)
                    * vaddv_f32(vadd_f32(*(float32x2_t *)v24.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL)));
  *(void *)&double result = vaddq_f32(v3, vminnmq_f32(vmaxnmq_f32(vaddq_f32(v2, vmulq_n_f32(v8, *(float *)v24.i32)), (float32x4_t)0), _Q17)).u64[0];
  return result;
}

__n128 cikernel::_vignette(CI *a1, float32x4_t a2, float32x4_t a3)
{
  float32x2_t v3 = vsub_f32(*(float32x2_t *)CI::getDC(a1), *(float32x2_t *)a3.f32);
  result.n128_u64[0] = vmulq_n_f32(a2, powf(fmaxf(1.0 - vmuls_lane_f32(vaddv_f32(vmul_f32(v3, v3)), a3, 3), 0.0), a3.f32[2])).u64[0];
  result.n128_u32[3] = a2.u32[3];
  return result;
}

__n128 cikernel::_vignetteeffect(CI *a1, float32x4_t a2, float32x2_t a3, float32x4_t a4)
{
  result.n128_u64[0] = (unint64_t)vmul_n_f32(vsub_f32(*(float32x2_t *)CI::getDC(a1), a3), a4.f32[0]);
  result.n128_f32[0] = vmuls_lane_f32(sqrtf(vaddv_f32(vmul_f32((float32x2_t)result.n128_u64[0], (float32x2_t)result.n128_u64[0])))- a4.f32[1], a4, 2);
  if (result.n128_f32[0] <= 1.0) {
    float v5 = result.n128_f32[0];
  }
  else {
    float v5 = 1.0;
  }
  BOOL v6 = result.n128_f32[0] < 0.0;
  float v7 = 0.0;
  if (!v6) {
    float v7 = v5;
  }
  float v8 = ((v7 * 6.0 + -15.0) * v7 + 10.0) * (float)(v7 * (float)(v7 * v7));
  float v9 = vmuls_lane_f32(v8, a4, 3);
  float v10 = ((((float)(1.0 - v9) * -0.120638501 + 0.543878646) * (float)(1.0 - v9) + 0.538772615) * (float)(1.0 - v9)
       + 0.0376009997)
      * (float)(1.0 - v9);
  result.n128_u64[0] = vmulq_n_f32(a2, v10).u64[0];
  result.n128_u32[3] = a2.u32[3];
  return result;
}

void CI::f4_s_f2_f4(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  float32x4_t v11 = (double (*)(void *, __n128, double, __n128))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  int v14 = *(_DWORD *)(v10 + 40);
  uint64_t v15 = *(void *)(v10 + 32);
  int v16 = *(_DWORD *)(v10 + 64);
  uint64_t v17 = *(void *)(v10 + 56);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 80)), a2);
  }
  float v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5) {
    float v18 = (__n128 *)((char *)a2 + 64 * v17);
  }
  float v19 = (double *)(a3 + 16 * v15);
  if (v14 != 5) {
    float v19 = (double *)((char *)a2 + 64 * v15);
  }
  float32x4_t v20 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    float32x4_t v20 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v21 = v11(a1, *v20, *v19, *v18);
  *(_OWORD *)(a3 + 16 * a7) = v21;
}

__n128 cikernel::_vignetteeffectneg(CI *a1, float32x4_t a2, float32x2_t a3, float32x4_t a4)
{
  result.n128_u64[0] = (unint64_t)vmul_n_f32(vsub_f32(*(float32x2_t *)CI::getDC(a1), a3), a4.f32[0]);
  result.n128_f32[0] = vmuls_lane_f32(sqrtf(vaddv_f32(vmul_f32((float32x2_t)result.n128_u64[0], (float32x2_t)result.n128_u64[0])))- a4.f32[1], a4, 2);
  float v5 = 1.0;
  if (result.n128_f32[0] <= 1.0) {
    float v5 = result.n128_f32[0];
  }
  BOOL v6 = result.n128_f32[0] < 0.0;
  float v7 = 0.0;
  if (!v6) {
    float v7 = v5;
  }
  float v8 = ((v7 * 6.0 + -15.0) * v7 + 10.0) * (float)(v7 * (float)(v7 * v7));
  float v9 = v8 * 16.0 * a4.f32[3] + 1.0;
  result.n128_u64[0] = vmulq_n_f32(a2, v9).u64[0];
  result.n128_u32[3] = a2.u32[3];
  return result;
}

uint64_t CIVNgetOrientation(void *a1)
{
  if ([a1 properties]
    && objc_msgSend((id)objc_msgSend(a1, "properties"), "objectForKey:", @"Orientation"))
  {
    float32x4_t v2 = objc_msgSend((id)objc_msgSend(a1, "properties"), "objectForKey:", @"Orientation");
  }
  else
  {
    float32x4_t v2 = &unk_1EE4AAFB8;
  }

  return [v2 intValue];
}

uint64_t CIVNDetectFaces(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  v51[1] = *MEMORY[0x1E4F143B8];
  float v8 = (void *)[MEMORY[0x1E4F1CA60] dictionary];
  if (a3)
  {
    uint64_t v36 = 0;
    uint64_t v37 = (uint64_t)&v36;
    uint64_t v38 = 0x2020000000;
    float v9 = (void *)getVNImageOptionCIContextSymbolLoc_ptr;
    int8x16_t v39 = (void *)getVNImageOptionCIContextSymbolLoc_ptr;
    if (!getVNImageOptionCIContextSymbolLoc_ptr)
    {
      uint64_t v41 = MEMORY[0x1E4F143A8];
      uint64_t v42 = 3221225472;
      uint64_t v43 = (uint64_t)__getVNImageOptionCIContextSymbolLoc_block_invoke;
      double v44 = (void (*)(uint64_t, uint64_t))&unk_1E57710B8;
      double v45 = (void (*)(uint64_t))&v36;
      uint64_t v10 = (void *)VisionLibrary_2();
      float32x4_t v11 = dlsym(v10, "VNImageOptionCIContext");
      *(void *)(*((void *)v45 + 1) + 24) = v11;
      getVNImageOptionCIContextSymbolLoc_ptr = *(void *)(*((void *)v45 + 1) + 24);
      float v9 = *(void **)(v37 + 24);
    }
    _Block_object_dispose(&v36, 8);
    if (!v9) {
      CIVNDetectFaces_cold_6();
    }
    [v8 setObject:a3 forKey:*v9];
  }
  if (a4)
  {
    if ([a4 objectForKey:@"kCIVNDetectOptionRequestLandmarks"]) {
      int v12 = objc_msgSend((id)objc_msgSend(a4, "objectForKey:", @"kCIVNDetectOptionRequestLandmarks"), "BOOLValue");
    }
    else {
      int v12 = 0;
    }
    if ([a4 objectForKey:@"kCIVNDetectOptionRequestAttributes"]) {
      int v14 = objc_msgSend((id)objc_msgSend(a4, "objectForKey:", @"kCIVNDetectOptionRequestAttributes"), "BOOLValue");
    }
    else {
      int v14 = 0;
    }
    if ([a4 objectForKey:@"kCIVNDetectOptionRequestPose"]) {
      int v15 = objc_msgSend((id)objc_msgSend(a4, "objectForKey:", @"kCIVNDetectOptionRequestPose"), "BOOLValue");
    }
    else {
      int v15 = 0;
    }
    if ([a4 objectForKey:@"kCIVNDetectOptionRequestFast"]) {
      int v13 = objc_msgSend((id)objc_msgSend(a4, "objectForKey:", @"kCIVNDetectOptionRequestFast"), "BOOLValue");
    }
    else {
      int v13 = 0;
    }
    if ([a4 objectForKey:@"kCIVNDetectOptionRequestSegments"]) {
      LODWORD(a4) = objc_msgSend((id)objc_msgSend(a4, "objectForKey:", @"kCIVNDetectOptionRequestSegments"), "BOOLValue");
    }
    else {
      LODWORD(a4) = 0;
    }
  }
  else
  {
    int v13 = 0;
    int v14 = 0;
    int v12 = 0;
    int v15 = 0;
  }
  uint64_t v41 = 0;
  uint64_t v42 = (uint64_t)&v41;
  uint64_t v43 = 0x3052000000;
  double v44 = __Block_byref_object_copy__19;
  double v45 = __Block_byref_object_dispose__19;
  int v16 = (objc_class *)getVNImageRequestHandlerClass_softClass_0;
  uint64_t v46 = getVNImageRequestHandlerClass_softClass_0;
  if (!getVNImageRequestHandlerClass_softClass_0)
  {
    uint64_t v36 = MEMORY[0x1E4F143A8];
    uint64_t v37 = 3221225472;
    uint64_t v38 = (uint64_t)__getVNImageRequestHandlerClass_block_invoke_0;
    int8x16_t v39 = &unk_1E57710B8;
    int8x16_t v40 = &v41;
    __getVNImageRequestHandlerClass_block_invoke_0((uint64_t)&v36);
    int v16 = *(objc_class **)(v42 + 40);
  }
  _Block_object_dispose(&v41, 8);
  uint64_t v17 = (void *)[[v16 alloc] initWithCIImage:a1 orientation:a2 options:v8];
  uint64_t v35 = 0;
  uint64_t v41 = 0;
  uint64_t v42 = (uint64_t)&v41;
  uint64_t v43 = 0x3052000000;
  double v44 = __Block_byref_object_copy__19;
  double v45 = __Block_byref_object_dispose__19;
  float v18 = (objc_class *)getVNDetectFaceRectanglesRequestClass_softClass;
  uint64_t v46 = getVNDetectFaceRectanglesRequestClass_softClass;
  if (!getVNDetectFaceRectanglesRequestClass_softClass)
  {
    uint64_t v36 = MEMORY[0x1E4F143A8];
    uint64_t v37 = 3221225472;
    uint64_t v38 = (uint64_t)__getVNDetectFaceRectanglesRequestClass_block_invoke;
    int8x16_t v39 = &unk_1E57710B8;
    int8x16_t v40 = &v41;
    __getVNDetectFaceRectanglesRequestClass_block_invoke((uint64_t)&v36);
    float v18 = *(objc_class **)(v42 + 40);
  }
  _Block_object_dispose(&v41, 8);
  id v19 = objc_alloc_init(v18);
  [v19 setRevision:3];
  if (v13) {
    [v19 setDetectionLevel:2];
  }
  v51[0] = v19;
  objc_msgSend(v17, "performRequests:error:", objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObjects:count:", v51, 1, v35, v36), &v35);
  if (v35)
  {
    float32x4_t v20 = ci_logger_api();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG)) {
      CIVNDetectFaces_cold_5((uint64_t)&v35);
    }
    uint64_t v21 = 0;
  }
  else
  {
    uint64_t v21 = [v19 results];
  }

  if (v14)
  {
    uint64_t v41 = 0;
    uint64_t v42 = (uint64_t)&v41;
    uint64_t v43 = 0x3052000000;
    double v44 = __Block_byref_object_copy__19;
    double v45 = __Block_byref_object_dispose__19;
    float32x2_t v22 = (objc_class *)getVNClassifyFaceAttributesRequestClass_softClass;
    uint64_t v46 = getVNClassifyFaceAttributesRequestClass_softClass;
    if (!getVNClassifyFaceAttributesRequestClass_softClass)
    {
      uint64_t v36 = MEMORY[0x1E4F143A8];
      uint64_t v37 = 3221225472;
      uint64_t v38 = (uint64_t)__getVNClassifyFaceAttributesRequestClass_block_invoke;
      int8x16_t v39 = &unk_1E57710B8;
      int8x16_t v40 = &v41;
      __getVNClassifyFaceAttributesRequestClass_block_invoke((uint64_t)&v36);
      float32x2_t v22 = *(objc_class **)(v42 + 40);
    }
    _Block_object_dispose(&v41, 8);
    id v23 = objc_alloc_init(v22);
    [v23 setRevision:3737841666 error:0];
    [v23 setInputFaceObservations:v21];
    id v50 = v23;
    objc_msgSend(v17, "performRequests:error:", objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObjects:count:", &v50, 1), &v35);
    if (v35)
    {
      int8x16_t v24 = ci_logger_api();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG)) {
        CIVNDetectFaces_cold_4((uint64_t)&v35);
      }
    }
    else
    {
      uint64_t v21 = [v23 results];
    }
  }
  if (v12)
  {
    uint64_t v41 = 0;
    uint64_t v42 = (uint64_t)&v41;
    uint64_t v43 = 0x3052000000;
    double v44 = __Block_byref_object_copy__19;
    double v45 = __Block_byref_object_dispose__19;
    int8x16_t v25 = (objc_class *)getVNDetectFaceLandmarksRequestClass_softClass;
    uint64_t v46 = getVNDetectFaceLandmarksRequestClass_softClass;
    if (!getVNDetectFaceLandmarksRequestClass_softClass)
    {
      uint64_t v36 = MEMORY[0x1E4F143A8];
      uint64_t v37 = 3221225472;
      uint64_t v38 = (uint64_t)__getVNDetectFaceLandmarksRequestClass_block_invoke;
      int8x16_t v39 = &unk_1E57710B8;
      int8x16_t v40 = &v41;
      __getVNDetectFaceLandmarksRequestClass_block_invoke((uint64_t)&v36);
      int8x16_t v25 = *(objc_class **)(v42 + 40);
    }
    _Block_object_dispose(&v41, 8);
    id v26 = objc_alloc_init(v25);
    [v26 setRevision:2];
    [v26 setInputFaceObservations:v21];
    id v49 = v26;
    objc_msgSend(v17, "performRequests:error:", objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObjects:count:", &v49, 1), &v35);
    if (v35)
    {
      int8x16_t v27 = ci_logger_api();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG)) {
        CIVNDetectFaces_cold_3((uint64_t)&v35);
      }
    }
    else
    {
      uint64_t v21 = [v26 results];
    }
  }
  if (v15)
  {
    uint64_t v41 = 0;
    uint64_t v42 = (uint64_t)&v41;
    uint64_t v43 = 0x3052000000;
    double v44 = __Block_byref_object_copy__19;
    double v45 = __Block_byref_object_dispose__19;
    float32x2_t v28 = (objc_class *)getVNDetectFacePoseRequestClass_softClass;
    uint64_t v46 = getVNDetectFacePoseRequestClass_softClass;
    if (!getVNDetectFacePoseRequestClass_softClass)
    {
      uint64_t v36 = MEMORY[0x1E4F143A8];
      uint64_t v37 = 3221225472;
      uint64_t v38 = (uint64_t)__getVNDetectFacePoseRequestClass_block_invoke;
      int8x16_t v39 = &unk_1E57710B8;
      int8x16_t v40 = &v41;
      __getVNDetectFacePoseRequestClass_block_invoke((uint64_t)&v36);
      float32x2_t v28 = *(objc_class **)(v42 + 40);
    }
    _Block_object_dispose(&v41, 8);
    id v29 = objc_alloc_init(v28);
    [v29 setRevision:1];
    [v29 setInputFaceObservations:v21];
    id v48 = v29;
    objc_msgSend(v17, "performRequests:error:", objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObjects:count:", &v48, 1), &v35);
    if (v35)
    {
      double v30 = ci_logger_api();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG)) {
        CIVNDetectFaces_cold_2((uint64_t)&v35);
      }
    }
    else
    {
      uint64_t v21 = [v29 results];
    }
  }
  if (a4)
  {
    uint64_t v41 = 0;
    uint64_t v42 = (uint64_t)&v41;
    uint64_t v43 = 0x3052000000;
    double v44 = __Block_byref_object_copy__19;
    double v45 = __Block_byref_object_dispose__19;
    int8x16_t v31 = (objc_class *)getVNGenerateFaceSegmentsRequestClass_softClass;
    uint64_t v46 = getVNGenerateFaceSegmentsRequestClass_softClass;
    if (!getVNGenerateFaceSegmentsRequestClass_softClass)
    {
      uint64_t v36 = MEMORY[0x1E4F143A8];
      uint64_t v37 = 3221225472;
      uint64_t v38 = (uint64_t)__getVNGenerateFaceSegmentsRequestClass_block_invoke;
      int8x16_t v39 = &unk_1E57710B8;
      int8x16_t v40 = &v41;
      __getVNGenerateFaceSegmentsRequestClass_block_invoke((uint64_t)&v36);
      int8x16_t v31 = *(objc_class **)(v42 + 40);
    }
    _Block_object_dispose(&v41, 8);
    id v32 = objc_alloc_init(v31);
    [v32 setInputFaceObservations:v21];
    id v47 = v32;
    objc_msgSend(v17, "performRequests:error:", objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObjects:count:", &v47, 1), &v35);
    if (v35)
    {
      float32x4_t v33 = ci_logger_api();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG)) {
        CIVNDetectFaces_cold_1((uint64_t)&v35);
      }
    }
    else
    {
      uint64_t v21 = [v32 results];
    }
  }
  return v21;
}

void sub_19386A35C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__n64 CIVNBoundsOfLandmarkRegion(void *a1)
{
  uint64_t v2 = objc_msgSend(a1, "pointsInImageOfSize:");
  uint64_t v3 = [a1 pointCount];
  if (v3 && v2)
  {
    uint64_t v4 = v3;
    uint64_t v5 = *(void *)(MEMORY[0x1E4F1DB20] + 16);
    uint64_t v6 = *(void *)(MEMORY[0x1E4F1DB20] + 24);
    result.n64_u64[0] = *MEMORY[0x1E4F1DB20];
    uint64_t v8 = *(void *)(MEMORY[0x1E4F1DB20] + 8);
    float v9 = (CGFloat *)(v2 + 8);
    do
    {
      v10.origin.double x = *(v9 - 1);
      v10.origin.double y = *v9;
      v10.size.CGFloat width = 0.0;
      v10.size.CGFloat height = 0.0;
      *(CGRect *)result.n64_u64 = CGRectUnion(*(CGRect *)result.n64_u64, v10);
      v9 += 2;
      --v4;
    }
    while (v4);
  }
  else
  {
    return *(__n64 *)MEMORY[0x1E4F1DB20];
  }
  return result;
}

double CIVNAreaOfBoundsOfLandmarkRegion(void *a1)
{
  CIVNBoundsOfLandmarkRegion(a1);
  return v1 * v2;
}

double CIVNAverage(void *a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  uint64_t v2 = [a1 countByEnumeratingWithState:&v13 objects:v17 count:16];
  if (v2)
  {
    uint64_t v3 = v2;
    uint64_t v4 = *(void *)v14;
    double v5 = 0.0;
    double v6 = 0.0;
    do
    {
      for (uint64_t i = 0; i != v3; ++i)
      {
        if (*(void *)v14 != v4) {
          objc_enumerationMutation(a1);
        }
        uint64_t v8 = *(void **)(*((void *)&v13 + 1) + 8 * i);
        [v8 X];
        double v6 = v6 + v9;
        [v8 Y];
        double v5 = v5 + v10;
      }
      uint64_t v3 = [a1 countByEnumeratingWithState:&v13 objects:v17 count:16];
    }
    while (v3);
  }
  else
  {
    double v6 = 0.0;
  }
  unint64_t v11 = [a1 count];
  [a1 count];
  return v6 / (double)v11;
}

double CIVNBoundingRect(void *a1)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  uint64_t v2 = [a1 countByEnumeratingWithState:&v20 objects:v24 count:16];
  if (!v2) {
    return 1.79769313e308;
  }
  uint64_t v3 = v2;
  uint64_t v4 = *(void *)v21;
  double v5 = -1.79769313e308;
  double v6 = 1.79769313e308;
  double v7 = 1.79769313e308;
  double v8 = -1.79769313e308;
  do
  {
    for (uint64_t i = 0; i != v3; ++i)
    {
      if (*(void *)v21 != v4) {
        objc_enumerationMutation(a1);
      }
      double v10 = *(void **)(*((void *)&v20 + 1) + 8 * i);
      [v10 X];
      if (v6 >= v11)
      {
        [v10 X];
        double v6 = v12;
      }
      [v10 Y];
      if (v7 >= v13)
      {
        [v10 Y];
        double v7 = v14;
      }
      [v10 X];
      if (v5 <= v15)
      {
        [v10 X];
        double v5 = v16;
      }
      [v10 Y];
      if (v8 <= v17)
      {
        [v10 Y];
        double v8 = v18;
      }
    }
    uint64_t v3 = [a1 countByEnumeratingWithState:&v20 objects:v24 count:16];
  }
  while (v3);
  return v6;
}

id CIVNLandmarkInOrientedImage(void *a1, void *a2)
{
  uint64_t v4 = CIVNgetOrientation(a2);

  return denormalizedOrientatedLandmarkPoints(a1, a2, v4);
}

id denormalizedOrientatedLandmarkPoints(void *a1, void *a2, uint64_t a3)
{
  uint64_t v6 = [a1 pointCount];
  [a2 extent];
  if ((a3 - 5) >= 4) {
    double v9 = v7;
  }
  else {
    double v9 = v8;
  }
  if ((a3 - 5) >= 4) {
    double v10 = v8;
  }
  else {
    double v10 = v7;
  }
  uint64_t v11 = objc_msgSend(a1, "pointsInImageOfSize:", v9, v10);
  long long v12 = 0uLL;
  memset(&v18, 0, sizeof(v18));
  if (a2)
  {
    [a2 imageTransformForOrientation:a3];
    long long v12 = 0uLL;
  }
  *(_OWORD *)&v17.double c = v12;
  *(_OWORD *)&v17.tdouble x = v12;
  *(_OWORD *)&v17.double a = v12;
  CGAffineTransform v16 = v18;
  CGAffineTransformInvert(&v17, &v16);
  double v13 = (void *)[objc_alloc(MEMORY[0x1E4F1CA48]) initWithCapacity:v6];
  if (v6)
  {
    double v14 = (double *)(v11 + 8);
    do
    {
      objc_msgSend(v13, "addObject:", +[CIVector vectorWithCGPoint:](CIVector, "vectorWithCGPoint:", vaddq_f64(*(float64x2_t *)&v17.tx, vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)&v17.c, *v14), *(float64x2_t *)&v17.a, *(v14 - 1)))));
      v14 += 2;
      --v6;
    }
    while (v6);
  }
  return v13;
}

void CIVNRectInOrientedImage(void *a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5)
{
  memset(&v16, 0, sizeof(v16));
  denormalizationTransform(a1, (uint64_t)&v16);
  CGAffineTransform v15 = v16;
  v17.origin.CGFloat x = a2;
  v17.origin.CGFloat y = a3;
  v17.size.CGFloat width = a4;
  v17.size.CGFloat height = a5;
  CGRect v18 = CGRectApplyAffineTransform(v17, &v15);
  CGFloat x = v18.origin.x;
  CGFloat y = v18.origin.y;
  CGFloat width = v18.size.width;
  CGFloat height = v18.size.height;
  memset(&v15, 0, sizeof(v15));
  orientationTransform(a1, (uint64_t)&v15);
  CGAffineTransform v14 = v15;
  v19.origin.CGFloat x = x;
  v19.origin.CGFloat y = y;
  v19.size.CGFloat width = width;
  v19.size.CGFloat height = height;
  CGRectApplyAffineTransform(v19, &v14);
}

CGAffineTransform *denormalizationTransform@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  [a1 extent];
  double v5 = v4;
  double v7 = v6;
  unsigned int v8 = CIVNgetOrientation(a1) - 5;
  if (v8 >= 4) {
    CGFloat v9 = v5;
  }
  else {
    CGFloat v9 = v7;
  }
  if (v8 >= 4) {
    CGFloat v10 = v7;
  }
  else {
    CGFloat v10 = v5;
  }
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;

  return CGAffineTransformMakeScale((CGAffineTransform *)a2, v9, v10);
}

CGAffineTransform *orientationTransform@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = CIVNgetOrientation(a1);
  long long v5 = 0uLL;
  memset(&v7[1], 0, sizeof(CGAffineTransform));
  if (a1)
  {
    [a1 imageTransformForOrientation:v4];
    long long v5 = 0uLL;
  }
  *(_OWORD *)(a2 + 16) = v5;
  *(_OWORD *)(a2 + 32) = v5;
  *(_OWORD *)a2 = v5;
  v7[0] = v7[1];
  return CGAffineTransformInvert((CGAffineTransform *)a2, v7);
}

double CIVNPointInOrientedImage(void *a1, double a2, double a3)
{
  long long v13 = 0u;
  long long v14 = 0u;
  long long v12 = 0u;
  denormalizationTransform(a1, (uint64_t)&v12);
  double v8 = *(double *)&v14 + a3 * *(double *)&v13 + *(double *)&v12 * a2;
  double v7 = *((double *)&v14 + 1) + a3 * *((double *)&v13 + 1) + *((double *)&v12 + 1) * a2;
  float64x2_t v10 = 0u;
  float64x2_t v11 = 0u;
  float64x2_t v9 = 0u;
  orientationTransform(a1, (uint64_t)&v9);
  *(void *)&double result = *(_OWORD *)&vaddq_f64(v11, vmlaq_n_f64(vmulq_n_f64(v10, v7), v9, v8));
  return result;
}

void *CIVNOrientedImageLandmarkEyeRegions(void *a1, void *a2, CIContext *a3)
{
  uint64_t v3 = a3;
  v37[3] = *MEMORY[0x1E4F143B8];
  if (!a3) {
    uint64_t v3 = +[CIContext context];
  }
  v36[0] = @"kCIVNDetectOptionRequestLandmarks";
  v36[1] = @"kCIVNDetectOptionRequestAttributes";
  v37[0] = MEMORY[0x1E4F1CC38];
  v37[1] = MEMORY[0x1E4F1CC28];
  v36[2] = @"kCIVNDetectOptionRequestPose";
  v37[2] = MEMORY[0x1E4F1CC28];
  double v6 = (void *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v37 forKeys:v36 count:3];
  if (!a2)
  {
    a2 = (void *)CIVNDetectFaces((uint64_t)a1, 1, (uint64_t)v3, v6);
    if (!a2) {
      return 0;
    }
  }
  if (![a2 count]) {
    return 0;
  }
  uint64_t v7 = [a2 count];
  double v8 = (void *)[MEMORY[0x1E4F1CA48] arrayWithCapacity:v7];
  if (v7)
  {
    for (uint64_t i = 0; i != v7; ++i)
    {
      objc_msgSend((id)objc_msgSend(a2, "objectAtIndexedSubscript:", i), "boundingBox");
      CIVNRectInOrientedImage(a1, v10, v11, v12, v13);
      CGRect v39 = CGRectIntegral(v38);
      double y = v39.origin.y;
      double x = v39.origin.x;
      double height = v39.size.height;
      double width = v39.size.width;
      long long v14 = (void *)[a2 objectAtIndex:i];
      CGAffineTransform v15 = objc_msgSend((id)objc_msgSend(v14, "landmarks"), "leftEye");
      uint64_t v16 = CIVNgetOrientation(a1);
      id v17 = denormalizedOrientatedLandmarkPoints(v15, a1, v16);
      CGRect v18 = objc_msgSend((id)objc_msgSend(v14, "landmarks"), "rightEye");
      uint64_t v19 = CIVNgetOrientation(a1);
      id v20 = denormalizedOrientatedLandmarkPoints(v18, a1, v19);
      v40.origin.double x = CIVNBoundingRect(v17);
      CGRect v41 = CGRectIntegral(v40);
      double v21 = v41.origin.x;
      double v22 = v41.origin.y;
      double v23 = v41.size.width;
      double v24 = v41.size.height;
      v42.origin.double x = CIVNBoundingRect(v20);
      CGRect v43 = CGRectIntegral(v42);
      double v25 = v43.origin.x;
      double v26 = v43.origin.y;
      double v27 = v43.size.width;
      double v28 = v43.size.height;
      v34[0] = @"face";
      v35[0] = +[CIVector vectorWithCGRect:](CIVector, "vectorWithCGRect:", x, y, width, height);
      v34[1] = @"leftEye";
      v35[1] = +[CIVector vectorWithCGRect:](CIVector, "vectorWithCGRect:", v21, v22, v23, v24);
      v34[2] = @"rightEye";
      v35[2] = +[CIVector vectorWithCGRect:](CIVector, "vectorWithCGRect:", v25, v26, v27, v28);
      objc_msgSend(v8, "setObject:atIndexedSubscript:", objc_msgSend(MEMORY[0x1E4F1C9E8], "dictionaryWithObjects:forKeys:count:", v35, v34, 3), i);
    }
  }
  return v8;
}

uint64_t CIVNDenormalizedLandmarks(void *a1, uint64_t a2, void *a3)
{
  v8[13] = *MEMORY[0x1E4F143B8];
  long long v5 = (void *)[a3 landmarks];
  v7[0] = @"allPoints";
  v8[0] = denormalizedOrientatedLandmarkPoints((void *)[v5 allPoints], a1, a2);
  v7[1] = @"faceContour";
  v8[1] = denormalizedOrientatedLandmarkPoints((void *)[v5 faceContour], a1, a2);
  CGAffineTransform v7[2] = @"innerLips";
  void v8[2] = denormalizedOrientatedLandmarkPoints((void *)[v5 innerLips], a1, a2);
  v7[3] = @"leftEye";
  v8[3] = denormalizedOrientatedLandmarkPoints((void *)[v5 leftEye], a1, a2);
  v7[4] = @"leftEyebrow";
  v8[4] = denormalizedOrientatedLandmarkPoints((void *)[v5 leftEyebrow], a1, a2);
  int64x2_t v7[5] = @"leftPupil";
  int64x2_t v8[5] = denormalizedOrientatedLandmarkPoints((void *)[v5 leftPupil], a1, a2);
  void v7[6] = @"medianLine";
  v8[6] = denormalizedOrientatedLandmarkPoints((void *)[v5 medianLine], a1, a2);
  v7[7] = @"nose";
  v8[7] = denormalizedOrientatedLandmarkPoints((void *)[v5 nose], a1, a2);
  v7[8] = @"noseCrest";
  v8[8] = denormalizedOrientatedLandmarkPoints((void *)[v5 noseCrest], a1, a2);
  void v7[9] = @"outerLips";
  v8[9] = denormalizedOrientatedLandmarkPoints((void *)[v5 outerLips], a1, a2);
  v7[10] = @"rightEye";
  v8[10] = denormalizedOrientatedLandmarkPoints((void *)[v5 rightEye], a1, a2);
  v7[11] = @"rightEyebrow";
  v8[11] = denormalizedOrientatedLandmarkPoints((void *)[v5 rightEyebrow], a1, a2);
  v7[12] = @"rightPupil";
  v8[12] = denormalizedOrientatedLandmarkPoints((void *)[v5 rightPupil], a1, a2);
  return [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v8 forKeys:v7 count:13];
}

void *__getVNImageOptionCIContextSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)VisionLibrary_2();
  double result = dlsym(v2, "VNImageOptionCIContext");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getVNImageOptionCIContextSymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t VisionLibrary_2()
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  v2[0] = 0;
  if (!VisionLibraryCore_frameworkLibrary_2)
  {
    v2[1] = (void *)MEMORY[0x1E4F143A8];
    _OWORD v2[2] = (void *)3221225472;
    v2[3] = __VisionLibraryCore_block_invoke_2;
    void v2[4] = &__block_descriptor_40_e5_v8__0l;
    v2[5] = v2;
    long long v3 = xmmword_1E5772F30;
    uint64_t v4 = 0;
    VisionLibraryCore_frameworkLibrary_2 = _sl_dlopen();
  }
  uint64_t v0 = VisionLibraryCore_frameworkLibrary_2;
  if (!VisionLibraryCore_frameworkLibrary_2) {
    VisionLibrary_cold_1(v2);
  }
  if (v2[0]) {
    free(v2[0]);
  }
  return v0;
}

uint64_t __VisionLibraryCore_block_invoke_2()
{
  uint64_t result = _sl_dlopen();
  VisionLibraryCore_frameworkLibrary_2 = result;
  return result;
}

void __Block_byref_object_copy__19(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__19(uint64_t a1)
{
}

Class __getVNImageRequestHandlerClass_block_invoke_0(uint64_t a1)
{
  VisionLibrary_2();
  Class result = objc_getClass("VNImageRequestHandler");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    __getVNImageRequestHandlerClass_block_invoke_cold_1();
  }
  getVNImageRequestHandlerClass_softClass_0 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

Class __getVNDetectFaceRectanglesRequestClass_block_invoke(uint64_t a1)
{
  VisionLibrary_2();
  Class result = objc_getClass("VNDetectFaceRectanglesRequest");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    __getVNDetectFaceRectanglesRequestClass_block_invoke_cold_1();
  }
  getVNDetectFaceRectanglesRequestClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

Class __getVNClassifyFaceAttributesRequestClass_block_invoke(uint64_t a1)
{
  VisionLibrary_2();
  Class result = objc_getClass("VNClassifyFaceAttributesRequest");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    __getVNClassifyFaceAttributesRequestClass_block_invoke_cold_1();
  }
  getVNClassifyFaceAttributesRequestClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

Class __getVNDetectFaceLandmarksRequestClass_block_invoke(uint64_t a1)
{
  VisionLibrary_2();
  Class result = objc_getClass("VNDetectFaceLandmarksRequest");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    __getVNDetectFaceLandmarksRequestClass_block_invoke_cold_1();
  }
  getVNDetectFaceLandmarksRequestClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

Class __getVNDetectFacePoseRequestClass_block_invoke(uint64_t a1)
{
  VisionLibrary_2();
  Class result = objc_getClass("VNDetectFacePoseRequest");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    __getVNDetectFacePoseRequestClass_block_invoke_cold_1();
  }
  getVNDetectFacePoseRequestClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

Class __getVNGenerateFaceSegmentsRequestClass_block_invoke(uint64_t a1)
{
  VisionLibrary_2();
  Class result = objc_getClass("VNGenerateFaceSegmentsRequest");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    __getVNGenerateFaceSegmentsRequestClass_block_invoke_cold_1();
  }
  getVNGenerateFaceSegmentsRequestClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

uint64_t OUTLINED_FUNCTION_2_5(uint64_t a1)
{
  return *(void *)a1;
}

void cikernel::_vortexDistortion(CI *a1, float32x2_t a2, double a3)
{
  DC = (float32x2_t *)CI::getDC(a1);
  float32x2_t v5 = vsub_f32(*DC, a2);
  float v6 = sqrtf(vaddv_f32(vmul_f32(v5, v5)));
  float v7 = (float)(v6 * *(float *)&a3) + -1.0;
  if (v7 >= 0.0) {
    CI::getDC((CI *)DC);
  }
  else {
    __sincosf_stret(vmuls_lane_f32(v7 * v7, *(float32x2_t *)&a3, 1) / v6);
  }
}

void vortexTracePoint(CGRect *a1, double a2, float32x2_t a3, float a4, float a5)
{
  float32x2_t v7 = vsub_f32(*(float32x2_t *)&a2, a3);
  double v8 = sqrtf(vaddv_f32(vmul_f32(v7, v7)));
  double v9 = a4 * v8;
  if (v9 < 1.0)
  {
    float v10 = a5 / v8 * ((1.0 - v9) * (1.0 - v9));
    float32x2_t v20 = v7;
    __float2 v12 = __sincosf_stret(v10);
    _S0 = v12.__sinval;
    _S4 = v20.i32[0];
    int32x2_t v14 = (int32x2_t)vmul_f32(v20, (float32x2_t)__PAIR64__(LODWORD(v12.__sinval), LODWORD(v12.__cosval)));
    v14.i32[0] = vadd_f32((float32x2_t)v14, (float32x2_t)vdup_lane_s32(v14, 1)).u32[0];
    __asm { FMLS            S1, S0, V4.S[0] }
    v14.i32[1] = _S1;
    a2 = COERCE_DOUBLE(vadd_f32(a3, (float32x2_t)v14));
  }
  v21.origin.double x = *(float *)&a2;
  v21.origin.double y = *((float *)&a2 + 1);
  v21.size.double width = 0.0;
  v21.size.double height = 0.0;
  *a1 = CGRectUnion(*a1, v21);
}

float32x2_t cikernel::_wrapMirror(CI *a1, int8x16_t a2)
{
  DC = (float32x2_t *)CI::getDC(a1);
  float32x2_t v3 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  return vminnm_f32(vsub_f32(vadd_f32(v3, v3), vsub_f32(*DC, *(float32x2_t *)a2.i8)), vabd_f32(*DC, *(float32x2_t *)a2.i8));
}

uint64_t ci_logger_general()
{
  if (ci_logger_general_onceToken != -1) {
    dispatch_once(&ci_logger_general_onceToken, &__block_literal_global_68);
  }
  return ci_logger_general_logger;
}

os_log_t __ci_logger_general_block_invoke()
{
  os_log_t result = os_log_create("com.apple.coreimage", "general");
  ci_logger_general_logger = (uint64_t)result;
  return result;
}

uint64_t ci_logger_api()
{
  if (ci_logger_api_onceToken != -1) {
    dispatch_once(&ci_logger_api_onceToken, &__block_literal_global_5_0);
  }
  return ci_logger_api_logger;
}

os_log_t __ci_logger_api_block_invoke()
{
  os_log_t result = os_log_create("com.apple.coreimage", "api");
  ci_logger_api_logger = (uint64_t)result;
  return result;
}

uint64_t ci_logger_render()
{
  if (ci_logger_render_onceToken != -1) {
    dispatch_once(&ci_logger_render_onceToken, &__block_literal_global_9);
  }
  return ci_logger_render_logger;
}

os_log_t __ci_logger_render_block_invoke()
{
  os_log_t result = os_log_create("com.apple.coreimage", "render");
  ci_logger_render_logger = (uint64_t)result;
  return result;
}

uint64_t ci_logger_performance()
{
  if (ci_logger_performance_onceToken != -1) {
    dispatch_once(&ci_logger_performance_onceToken, &__block_literal_global_13_0);
  }
  return ci_logger_performance_logger;
}

os_log_t __ci_logger_performance_block_invoke()
{
  os_log_t result = os_log_create("com.apple.coreimage", "performance");
  ci_logger_performance_logger = (uint64_t)result;
  return result;
}

uint64_t ci_logger_compile()
{
  if (ci_logger_compile_onceToken != -1) {
    dispatch_once(&ci_logger_compile_onceToken, &__block_literal_global_17);
  }
  return ci_logger_compile_logger;
}

os_log_t __ci_logger_compile_block_invoke()
{
  os_log_t result = os_log_create("com.apple.coreimage", "compile");
  ci_logger_compile_logger = (uint64_t)result;
  return result;
}

uint64_t ci_logger_cache()
{
  if (ci_logger_cache_onceToken != -1) {
    dispatch_once(&ci_logger_cache_onceToken, &__block_literal_global_21);
  }
  return ci_logger_cache_logger;
}

os_log_t __ci_logger_cache_block_invoke()
{
  os_log_t result = os_log_create("com.apple.coreimage", "cache");
  ci_logger_cache_logger = (uint64_t)result;
  return result;
}

uint64_t ci_logger_filter()
{
  if (ci_logger_filter_onceToken != -1) {
    dispatch_once(&ci_logger_filter_onceToken, &__block_literal_global_25_0);
  }
  return ci_logger_filter_logger;
}

os_log_t __ci_logger_filter_block_invoke()
{
  os_log_t result = os_log_create("com.apple.coreimage", "filter");
  ci_logger_filter_logger = (uint64_t)result;
  return result;
}

uint64_t ci_signpost_log_compile()
{
  if (ci_signpost_log_compile_onceToken != -1) {
    dispatch_once(&ci_signpost_log_compile_onceToken, &__block_literal_global_5_1);
  }
  return ci_signpost_log_compile_log;
}

os_log_t __ci_signpost_log_compile_block_invoke()
{
  os_log_t result = os_log_create("com.apple.coreimage", "signpost_compile");
  ci_signpost_log_compile_log = (uint64_t)result;
  return result;
}

uint64_t ci_signpost_log_cache()
{
  if (ci_signpost_log_cache_onceToken != -1) {
    dispatch_once(&ci_signpost_log_cache_onceToken, &__block_literal_global_9_0);
  }
  return ci_signpost_log_cache_log;
}

os_log_t __ci_signpost_log_cache_block_invoke()
{
  os_log_t result = os_log_create("com.apple.coreimage", "signpost_cache");
  ci_signpost_log_cache_log = (uint64_t)result;
  return result;
}

uint64_t ci_signpost_log_detector()
{
  if (ci_signpost_log_detector_onceToken != -1) {
    dispatch_once(&ci_signpost_log_detector_onceToken, &__block_literal_global_13_1);
  }
  return ci_signpost_log_detector_log;
}

os_log_t __ci_signpost_log_detector_block_invoke()
{
  os_log_t result = os_log_create("com.apple.coreimage", "signpost_detector");
  ci_signpost_log_detector_log = (uint64_t)result;
  return result;
}

uint64_t ci_signpost_log_kernel()
{
  if (ci_signpost_log_kernel_onceToken != -1) {
    dispatch_once(&ci_signpost_log_kernel_onceToken, &__block_literal_global_21_0);
  }
  return ci_signpost_log_kernel_log;
}

os_log_t __ci_signpost_log_kernel_block_invoke()
{
  os_log_t result = os_log_create("com.apple.coreimage", "signpost_kernel");
  ci_signpost_log_kernel_log = (uint64_t)result;
  return result;
}

uint64_t ci_signpost_log_dualredeye()
{
  if (ci_signpost_log_dualredeye_onceToken != -1) {
    dispatch_once(&ci_signpost_log_dualredeye_onceToken, &__block_literal_global_25_1);
  }
  return ci_signpost_log_dualredeye_log;
}

os_log_t __ci_signpost_log_dualredeye_block_invoke()
{
  os_log_t result = os_log_create("com.apple.coreimage", "signpost_dualredeye");
  ci_signpost_log_dualredeye_log = (uint64_t)result;
  return result;
}

const char *_indent_str()
{
  return " . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . "
         ". . . . . . . . . . . . . . . . . .";
}

CFTypeRef linearP3ColorSpace()
{
  if (linearP3ColorSpace::onceToken != -1) {
    dispatch_once(&linearP3ColorSpace::onceToken, &__block_literal_global_70);
  }
  CGColorSpaceRetain((CGColorSpaceRef)linearP3ColorSpace::cachedCS);
  uint64_t v0 = (const void *)linearP3ColorSpace::cachedCS;

  return CFAutorelease(v0);
}

void __linearP3ColorSpace_block_invoke()
{
  CFDataRef v0 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], linearP3ColorSpace::data, 572, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  linearP3ColorSpace::cachedCS = MEMORY[0x199700DD0]();

  CFRelease(v0);
}

uint64_t SDOFV2MetalLibURL()
{
  if (SDOFV2MetalLibURL::onceToken != -1) {
    dispatch_once(&SDOFV2MetalLibURL::onceToken, &__block_literal_global_17_1);
  }
  return SDOFV2MetalLibURL::url;
}

uint64_t __SDOFV2MetalLibURL_block_invoke()
{
  uint64_t result = [MEMORY[0x1E4F28B50] bundleWithIdentifier:@"com.apple.CoreImage"];
  if (result)
  {
    double v1 = (void *)result;
    if (CI_ENABLE_FUNCTION_STITCHING()) {
      uint64_t v2 = @"CIPortraitBlurStitchableV2";
    }
    else {
      uint64_t v2 = @"CIPortraitBlurV2";
    }
    uint64_t result = [v1 URLForResource:v2 withExtension:@"metallib"];
    SDOFV2MetalLibURL::url = result;
  }
  return result;
}

uint64_t __SDOFV3MetalLibURL_block_invoke()
{
  uint64_t result = [MEMORY[0x1E4F28B50] bundleWithIdentifier:@"com.apple.CoreImage"];
  if (result)
  {
    double v1 = (void *)result;
    if (CI_ENABLE_FUNCTION_STITCHING()) {
      uint64_t v2 = @"CIPortraitBlurStitchableV3";
    }
    else {
      uint64_t v2 = @"CIPortraitBlurV3";
    }
    uint64_t result = [v1 URLForResource:v2 withExtension:@"metallib"];
    SDOFV3MetalLibURL::url = result;
  }
  return result;
}

double shiftmapSize(double a1, double a2, double a3, double a4, double a5, double a6)
{
  double v6 = a2 * 0.5;
  if (a2 * 0.5 <= a4 * (a6 * 0.5 / a4)) {
    double v6 = a4 * (a6 * 0.5 / a4);
  }
  if (v6 >= a2) {
    double v6 = a2;
  }
  if (v6 <= a4) {
    double v6 = a4;
  }
  return v6 / (a2 / a1);
}

uint64_t useMetalImage(void *a1)
{
  if (useMetalImage::onceToken != -1) {
    dispatch_once(&useMetalImage::onceToken, &__block_literal_global_45);
  }
  if (useMetalImage::useNativeImageAlways != 1) {
    return 0;
  }
  uint64_t v2 = (void *)[a1 objectForKey:@"kContextInfoIsMetal"];

  return [v2 BOOLValue];
}

const char *__useMetalImage_block_invoke()
{
  uint64_t result = getenv("CI_METAL_SDOF");
  if (result)
  {
    uint64_t result = (const char *)atoi(result);
    if (result) {
      useMetalImage::useNativeImageAlways = 1;
    }
  }
  return result;
}

void *SDOFBlurmapSmoothingParameterValue(NSString *a1, void *a2)
{
  if (a2
    && (float32x2_t v3 = (void *)[a2 objectForKey:@"BlurMapSmoothing"]) != 0
    && (uint64_t v4 = (void *)[v3 objectForKey:a1]) != 0)
  {
    return (void *)[v4 floatValue];
  }
  else
  {
    return SDOFParameterValue(&cfstr_Blurmapsmoothi.isa, a1);
  }
}

void *SDOFParameterValue(NSString *a1, NSString *a2)
{
  if (SDOFParameterValue(NSString *,NSString *)::onceToken != -1) {
    dispatch_once(&SDOFParameterValue(NSString *,NSString *)::onceToken, &__block_literal_global_1151);
  }
  if (SDOFParameterValue(NSString *,NSString *)::onceToken2 != -1) {
    dispatch_once(&SDOFParameterValue(NSString *,NSString *)::onceToken2, &__block_literal_global_1156);
  }
  uint64_t result = (void *)[(id)SDOFParameterValue(NSString *,NSString *)::sdofParameters objectForKeyedSubscript:a1];
  if (result)
  {
    uint64_t v5 = [result objectForKey:a2];
    if (!v5)
    {
      if ([(NSString *)a1 isEqualToString:@"RenderingV3"]
        && (double v6 = (void *)[(id)SDOFParameterValue(NSString *,NSString *)::sdofParameters objectForKeyedSubscript:@"Rendering"]) != 0)
      {
        uint64_t v5 = [v6 objectForKey:a2];
      }
      else
      {
        uint64_t v5 = 0;
      }
    }
    if (SDOFParameterValue(NSString *,NSString *)::sdofParametersOnDevice)
    {
      float32x2_t v7 = (void *)[(id)SDOFParameterValue(NSString *,NSString *)::sdofParametersOnDevice objectForKey:a1];
      if (!v7
        || (uint64_t v8 = [v7 objectForKey:a2]) == 0
        || (double v9 = (void *)v8, objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
      {
        double v9 = (void *)v5;
        if (!v5)
        {
          if ([(NSString *)a1 isEqualToString:@"RenderingV3"]
            && (float v10 = (void *)[(id)SDOFParameterValue(NSString *,NSString *)::sdofParametersOnDevice objectForKey:@"Rendering"]) != 0&& (v11 = objc_msgSend(v10, "objectForKey:", a2)) != 0)
          {
            __float2 v12 = (void *)v11;
            objc_opt_class();
            if (objc_opt_isKindOfClass()) {
              double v9 = v12;
            }
            else {
              double v9 = 0;
            }
          }
          else
          {
            double v9 = 0;
          }
        }
      }
    }
    else
    {
      double v9 = (void *)v5;
    }
    return (void *)[v9 floatValue];
  }
  return result;
}

void *SDOFDisparitySmoothingParameterValue(NSString *a1, void *a2)
{
  if (a2
    && (float32x2_t v3 = (void *)[a2 objectForKey:@"DisparitySmoothing"]) != 0
    && (uint64_t v4 = (void *)[v3 objectForKey:a1]) != 0)
  {
    return (void *)[v4 floatValue];
  }
  else
  {
    return SDOFParameterValue(&cfstr_Disparitysmoot.isa, a1);
  }
}

void *SDOFDisparityRefinementParameterValue(NSString *a1, void *a2)
{
  if (a2
    && (float32x2_t v3 = (void *)[a2 objectForKey:@"DisparityRefinement"]) != 0
    && (uint64_t v4 = (void *)[v3 objectForKey:a1]) != 0)
  {
    return (void *)[v4 floatValue];
  }
  else
  {
    return SDOFParameterValue(&cfstr_Disparityrefin.isa, a1);
  }
}

void *SDOFRenderingValue(NSString *a1, void *a2)
{
  if (a2
    && (uint64_t v4 = (void *)[a2 objectForKey:@"Rendering"]) != 0
    && (uint64_t v5 = (void *)[v4 objectForKey:a1]) != 0)
  {
    return (void *)[v5 floatValue];
  }
  else
  {
    if (objc_msgSend((id)objc_msgSend(a2, "objectForKeyedSubscript:", @"Version"), "intValue") == 2) {
      float32x2_t v7 = @"RenderingV3";
    }
    else {
      float32x2_t v7 = @"Rendering";
    }
    return SDOFParameterValue(&v7->isa, a1);
  }
}

uint64_t SDOFSimpleLensModelValue(void *a1, void *a2)
{
  if (a2
    && (float32x2_t v3 = (void *)[a2 objectForKey:@"SLM"]) != 0
    && (uint64_t v4 = (void *)[v3 objectForKey:a1]) != 0)
  {
    return [v4 floatValue];
  }
  else
  {
    uint64_t result = [a1 isEqualToString:@"defaultSimulatedAperture"];
    if ((result & 1) == 0)
    {
      uint64_t result = [a1 isEqualToString:@"disparityScalingFactor"];
      if ((result & 1) == 0)
      {
        return (uint64_t)SDOFParameterValue(&cfstr_Slm.isa, (NSString *)a1);
      }
    }
  }
  return result;
}

void *SDOFFaceMaskValue(uint64_t a1, void *a2)
{
  float32x2_t v3 = (NSString *)[NSString stringWithFormat:@"faces.%@", a1];
  if (a2
    && [a2 objectForKey:@"Rendering"]
    && (uint64_t v4 = objc_msgSend((id)objc_msgSend(a2, "objectForKeyedSubscript:", @"Rendering"), "objectForKey:", v3)) != 0)
  {
    return (void *)[v4 floatValue];
  }
  else
  {
    return SDOFParameterValue(&cfstr_Rendering.isa, v3);
  }
}

void *SDOFHighlightRecoveryValue(NSString *a1, void *a2)
{
  if (a2
    && (float32x2_t v3 = (void *)[a2 objectForKey:@"HighlightRecovery"]) != 0
    && (uint64_t v4 = (void *)[v3 objectForKey:a1]) != 0)
  {
    return (void *)[v4 floatValue];
  }
  else
  {
    return SDOFParameterValue(&cfstr_Xhlrb.isa, a1);
  }
}

uint64_t SDOFFusionValue(NSString *a1, NSDictionary *a2)
{
  if (!a2
    || (id v3 = [(NSDictionary *)a2 objectForKey:@"Fusion"]) == 0
    || (uint64_t v4 = (void *)[v3 objectForKey:a1]) == 0)
  {
    uint64_t v4 = (void *)[&unk_1EE4AB388 objectForKeyedSubscript:a1];
  }

  return [v4 floatValue];
}

CIVector *transformNormalizedMetalToCI(void *a1, unsigned int a2, double a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if ((unint64_t)[a1 count] >= 8)
  {
    long long v13 = xmmword_1939574A0;
    long long v14 = unk_1939574B0;
    unint64_t v7 = 4;
  }
  else
  {
    unint64_t v6 = [a1 count];
    long long v13 = xmmword_1939574A0;
    long long v14 = unk_1939574B0;
    if (v6 < 2) {
      return +[CIVector vectorWithValues:&v13 count:4];
    }
    unint64_t v7 = v6 >> 1;
  }
  uint64_t v8 = 0;
  unsigned int v9 = 1;
  do
  {
    objc_msgSend(a1, "valueAtIndex:", a2, v13, v14);
    *((double *)&v13 + v_Block_object_dispose(&STACK[0x238], 8) = v10 * a3;
    uint64_t v8 = v9;
    a2 += 2;
  }
  while (v7 > v9++);
  return +[CIVector vectorWithValues:&v13 count:4];
}

uint64_t SDOFBlurMapRefinementValue(NSString *a1, NSDictionary *a2)
{
  if (!a2
    || (id v3 = [(NSDictionary *)a2 objectForKey:@"BlurMapRefinement"]) == 0
    || (uint64_t v4 = (void *)[v3 objectForKey:a1]) == 0)
  {
    uint64_t v4 = (void *)[&unk_1EE4AB3B0 objectForKeyedSubscript:a1];
  }

  return [v4 floatValue];
}

void sub_193873948(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id getRenderingParametersFromCGImageMetadata(const CGImageMetadata *a1)
{
  CFTypeID TypeID = CGImageMetadataGetTypeID();
  if (TypeID != CFGetTypeID(a1)) {
    return 0;
  }
  id v3 = CGImageMetadataCopyTagWithPath(a1, 0, @"depthBlurEffect:RenderingParameters");
  if (!v3) {
    return 0;
  }
  uint64_t v4 = v3;
  if (CGImageMetadataTagGetType(v3) == kCGImageMetadataTypeString)
  {
    CFTypeRef v5 = CGImageMetadataTagCopyValue(v4);
    id v7 = (id)[objc_alloc(MEMORY[0x1E4F1C9B8]) initWithBase64EncodedString:(id)CFMakeCollectable(v5) options:0];
  }
  else
  {
    id v7 = 0;
  }
  CFRelease(v4);

  return v7;
}

CFTypeRef metadataFromValue(CFTypeRef cf)
{
  double v1 = (void *)cf;
  if (!cf) {
    return v1;
  }
  CFTypeID v2 = CFGetTypeID(cf);
  if (CGImageMetadataGetTypeID() == v2) {
    return v1;
  }
  if (CFStringGetTypeID() != v2)
  {
    if (CFDataGetTypeID() == v2) {
      goto LABEL_8;
    }
    return 0;
  }
  if ((unint64_t)[v1 length] <= 1) {
    return 0;
  }
  double v1 = objc_msgSend(MEMORY[0x1E4F1C9B8], "dataWithBytes:length:", objc_msgSend(v1, "UTF8String"), objc_msgSend(v1, "length"));
  if (!v1) {
    return v1;
  }
LABEL_8:
  CGImageMetadataRef v3 = CGImageMetadataCreateFromXMPData((CFDataRef)v1);
  if (!v3) {
    return 0;
  }

  return CFAutorelease(v3);
}

const CGImageMetadata *tuningParametersFromMetaData(const CGImageMetadata *a1)
{
  uint64_t v547 = *MEMORY[0x1E4F143B8];
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (TypeID == CFGetTypeID(a1)) {
    return a1;
  }
  CGImageMetadataRef v3 = CGImageMetadataCopyTagWithPath(a1, 0, @"depthBlurEffect:RenderingParameters");
  if (!v3) {
    return (const CGImageMetadata *)&unk_1EE4AB3D8;
  }
  uint64_t v4 = v3;
  if (CGImageMetadataTagGetType(v3) != kCGImageMetadataTypeString
    || (CFTypeRef v5 = CGImageMetadataTagCopyValue(v4),
        id v6 = (id)[objc_alloc(MEMORY[0x1E4F1C9B8]) initWithBase64EncodedString:(id)CFMakeCollectable(v5) options:0], (unint64_t)objc_msgSend(v6, "length") <= 0xB))
  {
    CFRelease(v4);
    return (const CGImageMetadata *)&unk_1EE4AB3D8;
  }
  [v6 getBytes:&v355 length:12];
  uint64_t v8 = HIDWORD(v355);
  char v206 = 1;
  int v9 = +[CIFilter maxSDOFRenderingVersionSupported];
  if (v9 < 4) {
    goto LABEL_15;
  }
  if ((int)v8 <= v9)
  {
    int v17 = 0;
  }
  else
  {
    double v10 = ci_logger_api();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      tuningParametersFromMetaData(v8, v10, v11, v12, v13, v14, v15, v16);
    }
    int v17 = 1;
  }
  if ((int)v8 <= 3)
  {
LABEL_15:
    switch(v8)
    {
      case 3:
        int v18 = FigDepthBlurEffectRenderingParametersV3FromCFData(v6, &v207);
        break;
      case 2:
        int v18 = FigDepthBlurEffectRenderingParametersV2FromCFData(v6, (char *)&v207, (BOOL *)&v206);
        break;
      case 1:
        int v18 = FigDepthBlurEffectRenderingParametersV1FromCFData(v6, &v207);
        break;
      default:
        id v32 = ci_logger_api();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
          tuningParametersFromMetaData(v8, v32, v33, v34, v35, v36, v37, v38);
        }
        CFRelease(v4);
        if ((int)v8 < 1) {
          return (const CGImageMetadata *)&unk_1EE4AB3D8;
        }
        int v17 = 1;
        goto LABEL_23;
    }
    int v17 = v18;
  }
  CFRelease(v4);
LABEL_23:
  int v19 = +[CIFilter maxSDOFRenderingVersionSupported];
  a1 = (const CGImageMetadata *)&unk_1EE4AB3D8;
  if (!v17 && (int)v8 <= v19)
  {
    switch(v8)
    {
      case 3:
        int v104 = v206;
        v531 = @"BlurMapSmoothing";
        v529[0] = @"nIterations";
        v530[0] = [NSNumber numberWithInt:v243];
        v529[1] = @"originalBlurValueT0";
        LODWORD(v105) = v267;
        v530[1] = [NSNumber numberWithFloat:v105];
        v529[2] = @"originalBlurValueT1";
        LODWORD(v106) = v268;
        v530[2] = [NSNumber numberWithFloat:v106];
        v529[3] = @"localMinimumBlurValueT0";
        LODWORD(v107) = v269;
        v530[3] = [NSNumber numberWithFloat:v107];
        v529[4] = @"localMinimumBlurValueT1";
        LODWORD(v10_Block_object_dispose(&STACK[0x238], 8) = v270;
        v530[4] = [NSNumber numberWithFloat:v108];
        uint64_t v539 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v530 forKeys:v529 count:5];
        v532 = @"DisparityRefinement";
        v495 = @"radius";
        uint64_t v512 = [NSNumber numberWithInt:HIDWORD(v207)];
        v496 = @"weightScaling";
        double v109 = v232;
        if (!v104) {
          double v109 = 0.2;
        }
        v513 = (void *)[NSNumber numberWithDouble:v109];
        v497 = @"maxReconstructionWeight";
        double v110 = v233;
        if (!v104) {
          double v110 = 0.1;
        }
        v514 = (void *)[NSNumber numberWithDouble:v110];
        v498 = @"innerSamplingRadius";
        double v111 = v234;
        if (!v104) {
          double v111 = 0.5;
        }
        uint64_t v515 = [NSNumber numberWithDouble:v111];
        v499 = @"outerSamplingRadius";
        double v112 = v235;
        if (!v104) {
          double v112 = 2.5;
        }
        v516 = (void *)[NSNumber numberWithDouble:v112];
        v500 = @"nSamples";
        if (v104) {
          uint64_t v113 = v236;
        }
        else {
          uint64_t v113 = 20;
        }
        uint64_t v517 = [NSNumber numberWithInt:v113];
        v501 = @"lumaSigma";
        double v114 = v237;
        if (!v104) {
          double v114 = 0.05;
        }
        uint64_t v518 = [NSNumber numberWithDouble:v114];
        v502 = @"chromaSigma";
        double v115 = v238;
        if (!v104) {
          double v115 = 0.02;
        }
        uint64_t v519 = [NSNumber numberWithDouble:v115];
        v503 = @"disparitySigma";
        double v116 = v208;
        if (!v104) {
          double v116 = 0.03;
        }
        uint64_t v520 = [NSNumber numberWithDouble:v116];
        v504 = @"accumulatedWeightT0";
        double v117 = v239;
        if (!v104) {
          double v117 = 0.01;
        }
        uint64_t v521 = [NSNumber numberWithDouble:v117];
        v505 = @"accumulatedWeightT1";
        double v118 = v240;
        if (!v104) {
          double v118 = 0.1;
        }
        uint64_t v522 = [NSNumber numberWithDouble:v118];
        v506 = @"aaLumaSigma";
        LODWORD(v119) = v209;
        uint64_t v523 = [NSNumber numberWithFloat:v119];
        v507 = @"aaChromaSigma";
        LODWORD(v120) = v210;
        uint64_t v524 = [NSNumber numberWithFloat:v120];
        v508 = @"aaSpatialSigma";
        LODWORD(v121) = v211;
        uint64_t v525 = [NSNumber numberWithFloat:v121];
        v509 = @"segmentationSigma";
        LODWORD(v122) = v272;
        if (!v104) {
          *(float *)&double v122 = 1000.0;
        }
        uint64_t v526 = [NSNumber numberWithFloat:v122];
        v510 = @"aaSegmentationSigma";
        double v123 = v273;
        if (!v104) {
          double v123 = 1.4;
        }
        uint64_t v527 = [NSNumber numberWithDouble:v123];
        v511 = @"Version";
        if (v104) {
          uint64_t v124 = v274;
        }
        else {
          uint64_t v124 = 0;
        }
        uint64_t v528 = [NSNumber numberWithInt:v124];
        uint64_t v540 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v512 forKeys:&v495 count:17];
        v533 = @"SLM";
        v483 = @"shiftDeadZone";
        LODWORD(v125) = v212;
        uint64_t v489 = [NSNumber numberWithFloat:v125];
        v484 = @"zeroShiftPercentile";
        double v126 = v241;
        if (!v104) {
          double v126 = 0.75;
        }
        uint64_t v490 = [NSNumber numberWithDouble:v126];
        v485 = @"maxFGBlur";
        double v127 = v242;
        if (!v104) {
          double v127 = 0.0002;
        }
        uint64_t v491 = [NSNumber numberWithDouble:v127];
        v486 = @"maximumSimulatedAperture";
        double v128 = v271;
        if (!v104) {
          double v128 = 0.0;
        }
        uint64_t v492 = [NSNumber numberWithDouble:v128];
        v487 = @"defaultSimulatedAperture";
        double v129 = v275;
        if (!v104) {
          double v129 = 0.0;
        }
        uint64_t v493 = [NSNumber numberWithDouble:v129];
        v488 = @"disparityScalingFactor";
        double v130 = v276;
        if (!v104) {
          double v130 = 0.0;
        }
        uint64_t v494 = [NSNumber numberWithDouble:v130];
        uint64_t v541 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v489 forKeys:&v483 count:6];
        v534 = @"HighlightRecovery";
        v461 = @"iterations";
        uint64_t v472 = [NSNumber numberWithInt:v217];
        v462 = @"preFilterGain";
        LODWORD(v131) = v218;
        uint64_t v473 = [NSNumber numberWithFloat:v131];
        v463 = @"weightGain";
        LODWORD(v132) = v219;
        uint64_t v474 = [NSNumber numberWithFloat:v132];
        v464 = @"intensityGain";
        LODWORD(v133) = v220;
        uint64_t v475 = [NSNumber numberWithFloat:v133];
        v465 = @"mode";
        v476 = &unk_1EE4AAFD0;
        v466 = @"blurRadiusT0";
        double v134 = v251;
        if (!v104) {
          double v134 = 0.0025;
        }
        uint64_t v477 = [NSNumber numberWithDouble:v134];
        v467 = @"blurRadiusT1";
        double v135 = v252;
        if (!v104) {
          double v135 = 0.0075;
        }
        v478 = (void *)[NSNumber numberWithDouble:v135];
        v468 = @"maxIntensityT0";
        double v136 = v253;
        if (!v104) {
          double v136 = 0.9;
        }
        uint64_t v479 = [NSNumber numberWithDouble:v136];
        v469 = @"maxIntensityT1";
        double v137 = v254;
        if (!v104) {
          double v137 = 1.0;
        }
        uint64_t v480 = [NSNumber numberWithDouble:v137];
        v470 = @"minIntensityT0";
        double v138 = v255;
        if (!v104) {
          double v138 = 0.0;
        }
        uint64_t v481 = [NSNumber numberWithDouble:v138];
        v471 = @"minIntensityT1";
        double v139 = v256;
        if (!v104) {
          double v139 = 0.2;
        }
        uint64_t v482 = [NSNumber numberWithDouble:v139];
        uint64_t v542 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v472 forKeys:&v461 count:11];
        v535 = @"Rendering";
        std::vector<std::string>::size_type v405 = @"faces.linearBlurGrowthC";
        LODWORD(v140) = v214;
        uint64_t v433 = [NSNumber numberWithFloat:v140];
        v406 = @"faces.linearBlurGrowthM";
        LODWORD(v141) = v213;
        uint64_t v434 = [NSNumber numberWithFloat:v141];
        v407 = @"faces.distToBlurScaling";
        LODWORD(v142) = v215;
        uint64_t v435 = [NSNumber numberWithFloat:v142];
        uint64_t v408 = @"faces.eyeToEyebrowRatio";
        LODWORD(v143) = v216;
        v436 = (void *)[NSNumber numberWithFloat:v143];
        uint64_t v409 = @"faces.maxBlurOnEyes";
        LODWORD(v144) = v257;
        uint64_t v437 = [NSNumber numberWithFloat:v144];
        v410 = @"faces.maxBlurDistFromFocus";
        LODWORD(v145) = v258;
        uint64_t v438 = [NSNumber numberWithFloat:v145];
        uint64_t v411 = @"faces.capMultip";
        LODWORD(v146) = v259;
        uint64_t v439 = [NSNumber numberWithFloat:v146];
        long long v412 = @"faces.gainMultip";
        LODWORD(v147) = v260;
        uint64_t v440 = [NSNumber numberWithFloat:v147];
        long long v413 = @"lumaNoiseModelCoeff";
        LODWORD(v14_Block_object_dispose(&STACK[0x238], 8) = v247;
        uint64_t v441 = [NSNumber numberWithFloat:v148];
        long long v414 = @"relativeWeightThreshold";
        LODWORD(v149) = v222;
        uint64_t v442 = [NSNumber numberWithFloat:v149];
        long long v415 = @"highlightBoostGain";
        LODWORD(v150) = v223;
        uint64_t v443 = [NSNumber numberWithFloat:v150];
        v416 = @"shapeObstructionCoeff";
        LODWORD(v151) = v224;
        uint64_t v444 = [NSNumber numberWithFloat:v151];
        v417 = @"ringAmplitude";
        LODWORD(v152) = v225;
        uint64_t v445 = [NSNumber numberWithFloat:v152];
        v418 = @"ringSharpness";
        LODWORD(v153) = v226;
        uint64_t v446 = [NSNumber numberWithFloat:v153];
        v419 = @"antiAliasBlurStrength";
        LODWORD(v154) = v228;
        uint64_t v447 = [NSNumber numberWithFloat:v154];
        v420 = @"minimumSimulatedAperture";
        LODWORD(v155) = v229;
        uint64_t v448 = [NSNumber numberWithFloat:v155];
        v421 = @"antiAliasRadius";
        uint64_t v449 = [NSNumber numberWithInt:v248];
        v422 = @"alphaEpsilon";
        LODWORD(v156) = v249;
        uint64_t v450 = [NSNumber numberWithFloat:v156];
        v423 = @"alphaGain";
        LODWORD(v157) = v250;
        uint64_t v451 = [NSNumber numberWithFloat:v157];
        v424 = @"maxBlur";
        v452 = &unk_1EE4AA2D0;
        v425 = @"nRings";
        uint64_t v453 = [NSNumber numberWithInt:v221];
        std::__split_buffer<std::string> v426 = @"preFilterBlurStrength";
        LODWORD(v15_Block_object_dispose(&STACK[0x238], 8) = v227;
        uint64_t v454 = [NSNumber numberWithFloat:v158];
        uint64_t v427 = @"preFilterRadius";
        uint64_t v455 = [NSNumber numberWithInt:v244];
        v428 = @"sharpRadius";
        LODWORD(v159) = v245;
        uint64_t v456 = [NSNumber numberWithFloat:v159];
        v429 = @"softRadius";
        double v160 = v246;
        if (!v104) {
          double v160 = 1.0;
        }
        uint64_t v457 = [NSNumber numberWithDouble:v160];
        v430 = @"basePixelWeight";
        v458 = &unk_1EE4AA2E0;
        v431 = @"blendingQuarterResAlphaGain";
        double v161 = v230;
        if (!v104) {
          double v161 = 1.0;
        }
        uint64_t v459 = [NSNumber numberWithDouble:v161];
        v432 = @"blendingFullResAlphaGain";
        double v162 = v231;
        if (!v104) {
          double v162 = 1.0;
        }
        uint64_t v460 = [NSNumber numberWithDouble:v162];
        uint64_t v543 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v433 forKeys:&v405 count:28];
        v536 = @"Fusion";
        v393 = @"subtractiveLowerAlpha";
        LODWORD(v163) = v261;
        if (!v104) {
          *(float *)&double v163 = 0.8;
        }
        uint64_t v399 = [NSNumber numberWithFloat:v163];
        v394 = @"subtractiveUpperAlpha";
        LODWORD(v164) = v262;
        if (!v104) {
          *(float *)&double v164 = 1.0;
        }
        uint64_t v400 = [NSNumber numberWithFloat:v164];
        v395 = @"subtractiveMaxBlur";
        double v165 = v263;
        if (!v104) {
          double v165 = 0.0;
        }
        uint64_t v401 = [NSNumber numberWithDouble:v165];
        v396 = @"additiveLowerAlpha";
        LODWORD(v166) = v264;
        if (!v104) {
          *(float *)&double v166 = 0.0;
        }
        uint64_t v402 = [NSNumber numberWithFloat:v166];
        v397 = @"additiveUpperAlpha";
        LODWORD(v167) = v265;
        if (!v104) {
          *(float *)&double v167 = 0.2;
        }
        uint64_t v403 = [NSNumber numberWithFloat:v167];
        v398 = @"additiveMaxBlur";
        double v168 = v266;
        if (!v104) {
          double v168 = 0.0;
        }
        uint64_t v404 = [NSNumber numberWithDouble:v168];
        uint64_t v544 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v399 forKeys:&v393 count:6];
        v537 = @"BlurMapRefinement";
        float32x2_t v317 = @"minimumFocusDistance";
        LODWORD(v169) = v277;
        uint64_t v355 = [NSNumber numberWithFloat:v169];
        float v318 = @"maximumFocusDistance";
        LODWORD(v170) = v278;
        uint64_t v356 = [NSNumber numberWithFloat:v170];
        float v319 = @"subjectDistanceScalingFactor";
        LODWORD(v171) = v279;
        uint64_t v357 = [NSNumber numberWithFloat:v171];
        float v320 = @"subjectDistanceOffset";
        LODWORD(v172) = v280;
        uint64_t v358 = [NSNumber numberWithFloat:v172];
        float32x2_t v321 = @"relativeApertureScalingStrength";
        LODWORD(v173) = v300;
        uint64_t v359 = [NSNumber numberWithFloat:v173];
        float v322 = @"protectBodyStrength";
        LODWORD(v174) = v281;
        uint64_t v360 = [NSNumber numberWithFloat:v174];
        float v323 = @"distanceAdd";
        LODWORD(v175) = v285;
        uint64_t v361 = [NSNumber numberWithFloat:v175];
        float v324 = @"hairAdditiveLowerAlpha";
        LODWORD(v176) = v296;
        uint64_t v362 = [NSNumber numberWithFloat:v176];
        float32x2_t v325 = @"hairAdditiveUpperAlpha";
        LODWORD(v177) = v297;
        uint64_t v363 = [NSNumber numberWithFloat:v177];
        float32x2_t v326 = @"hairAdditiveMaxBlur";
        LODWORD(v17_Block_object_dispose(&STACK[0x238], 8) = v298;
        uint64_t v364 = [NSNumber numberWithFloat:v178];
        float32x2_t v327 = @"hairSubtractiveLowerAlpha";
        LODWORD(v179) = v294;
        uint64_t v365 = [NSNumber numberWithFloat:v179];
        float v328 = @"hairSubtractiveUpperAlpha";
        LODWORD(v180) = v295;
        uint64_t v366 = [NSNumber numberWithFloat:v180];
        float v329 = @"hairSubtractiveMaxBlur";
        LODWORD(v181) = v299;
        uint64_t v367 = [NSNumber numberWithFloat:v181];
        float v330 = @"faceMaskAdditiveMaxBlur";
        LODWORD(v182) = v286;
        uint64_t v368 = [NSNumber numberWithFloat:v182];
        float32x2_t v331 = @"faceMaskSubtractiveMaxBlur";
        LODWORD(v183) = v287;
        uint64_t v369 = [NSNumber numberWithFloat:v183];
        float v332 = @"smoothstepMin";
        LODWORD(v184) = v283;
        uint64_t v370 = [NSNumber numberWithFloat:v184];
        float v333 = @"smoothstepMax";
        LODWORD(v185) = v284;
        uint64_t v371 = [NSNumber numberWithFloat:v185];
        float v334 = @"maxBlur";
        LODWORD(v186) = v282;
        uint64_t v372 = [NSNumber numberWithFloat:v186];
        float32x2_t v335 = @"personDistance";
        LODWORD(v187) = v288;
        uint64_t v373 = [NSNumber numberWithFloat:v187];
        float32x2_t v336 = @"personThreshold";
        LODWORD(v18_Block_object_dispose(&STACK[0x238], 8) = v289;
        long long v374 = (void *)[NSNumber numberWithFloat:v188];
        float32x2_t v337 = @"personMaxBlur";
        LODWORD(v189) = v290;
        uint64_t v375 = [NSNumber numberWithFloat:v189];
        float v338 = @"hairDistance";
        LODWORD(v190) = v291;
        uint64_t v376 = [NSNumber numberWithFloat:v190];
        float v339 = @"hairThreshold";
        LODWORD(v191) = v292;
        uint64_t v377 = [NSNumber numberWithFloat:v191];
        float v340 = @"hairMaxBlur";
        LODWORD(v192) = v293;
        uint64_t v378 = [NSNumber numberWithFloat:v192];
        float32x2_t v341 = @"eyeProtectionMaxFaces";
        uint64_t v379 = [NSNumber numberWithInt:v301];
        float v342 = @"eyeProtectionFaceWeightsSmoothStepMin";
        LODWORD(v193) = v302;
        v380 = (void *)[NSNumber numberWithFloat:v193];
        float v343 = @"eyeProtectionFaceWeightsSmoothStepMax";
        LODWORD(v194) = v303;
        uint64_t v381 = [NSNumber numberWithFloat:v194];
        float v344 = @"eyeProtectionOvalDimsDistanceScale";
        LODWORD(v195) = v304;
        uint64_t v382 = [NSNumber numberWithFloat:v195];
        float32x2_t v345 = @"eyeProtectionOvalDimsDistanceOffset";
        LODWORD(v196) = v305;
        uint64_t v383 = [NSNumber numberWithFloat:v196];
        float32x2_t v346 = @"eyeProtectionOvalDimsRadiusHorizontal";
        LODWORD(v197) = v306;
        uint64_t v384 = [NSNumber numberWithFloat:v197];
        float32x2_t v347 = @"eyeProtectionOvalDimsRadiusVertical";
        LODWORD(v19_Block_object_dispose(&STACK[0x238], 8) = v307;
        uint64_t v385 = [NSNumber numberWithFloat:v198];
        BOOL v348 = @"eyeProtectionOvalFallOffSmoothStepMin";
        LODWORD(v199) = v308;
        uint64_t v386 = [NSNumber numberWithFloat:v199];
        float v349 = @"eyeProtectionOvalFallOffSmoothStepMax";
        LODWORD(v200) = v309;
        uint64_t v387 = [NSNumber numberWithFloat:v200];
        float v350 = @"eyeProtectionPersonMaskSmoothStepMin";
        LODWORD(v201) = v310;
        uint64_t v388 = [NSNumber numberWithFloat:v201];
        float32x2_t v351 = @"eyeProtectionPersonMaskSmoothStepMax";
        LODWORD(v202) = v311;
        uint64_t v389 = [NSNumber numberWithFloat:v202];
        float v352 = @"eyeProtectionPreventStrength";
        LODWORD(v203) = v312;
        uint64_t v390 = [NSNumber numberWithFloat:v203];
        float v353 = @"eyeProtectionSubtractiveMaxBlur";
        LODWORD(v204) = v313;
        uint64_t v391 = [NSNumber numberWithFloat:v204];
        float v354 = @"eyeProtectionSubtractiveApertureScaling";
        LODWORD(v205) = v314;
        uint64_t v392 = [NSNumber numberWithFloat:v205];
        uint64_t v545 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v355 forKeys:&v317 count:38];
        v538 = @"Version";
        v546 = &unk_1EE4AB060;
        double v28 = (void *)MEMORY[0x1E4F1C9E8];
        id v29 = &v539;
        double v30 = &v531;
        uint64_t v31 = 8;
        break;
      case 2:
        int v39 = v206;
        v461 = @"BlurMapSmoothing";
        v393 = @"nIterations";
        uint64_t v399 = [NSNumber numberWithInt:v243];
        v394 = @"originalBlurValueT0";
        LODWORD(v40) = v267;
        uint64_t v400 = [NSNumber numberWithFloat:v40];
        v395 = @"originalBlurValueT1";
        LODWORD(v41) = v268;
        uint64_t v401 = [NSNumber numberWithFloat:v41];
        v396 = @"localMinimumBlurValueT0";
        LODWORD(v42) = v269;
        uint64_t v402 = [NSNumber numberWithFloat:v42];
        v397 = @"localMinimumBlurValueT1";
        LODWORD(v43) = v270;
        uint64_t v403 = [NSNumber numberWithFloat:v43];
        uint64_t v472 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v399 forKeys:&v393 count:5];
        v462 = @"DisparityRefinement";
        std::vector<std::string>::size_type v405 = @"radius";
        uint64_t v433 = [NSNumber numberWithInt:HIDWORD(v207)];
        v406 = @"weightScaling";
        double v44 = v232;
        if (!v39) {
          double v44 = 0.2;
        }
        uint64_t v434 = [NSNumber numberWithDouble:v44];
        v407 = @"maxReconstructionWeight";
        double v45 = v233;
        if (!v39) {
          double v45 = 0.1;
        }
        uint64_t v435 = [NSNumber numberWithDouble:v45];
        uint64_t v408 = @"innerSamplingRadius";
        double v46 = v234;
        if (!v39) {
          double v46 = 0.5;
        }
        v436 = (void *)[NSNumber numberWithDouble:v46];
        uint64_t v409 = @"outerSamplingRadius";
        double v47 = v235;
        if (!v39) {
          double v47 = 2.5;
        }
        uint64_t v437 = [NSNumber numberWithDouble:v47];
        v410 = @"nSamples";
        if (v39) {
          uint64_t v48 = v236;
        }
        else {
          uint64_t v48 = 20;
        }
        uint64_t v438 = [NSNumber numberWithInt:v48];
        uint64_t v411 = @"lumaSigma";
        double v49 = v237;
        if (!v39) {
          double v49 = 0.05;
        }
        uint64_t v439 = [NSNumber numberWithDouble:v49];
        long long v412 = @"chromaSigma";
        double v50 = v238;
        if (!v39) {
          double v50 = 0.02;
        }
        uint64_t v440 = [NSNumber numberWithDouble:v50];
        long long v413 = @"disparitySigma";
        double v51 = v208;
        if (!v39) {
          double v51 = 0.03;
        }
        uint64_t v441 = [NSNumber numberWithDouble:v51];
        long long v414 = @"accumulatedWeightT0";
        double v52 = v239;
        if (!v39) {
          double v52 = 0.01;
        }
        uint64_t v442 = [NSNumber numberWithDouble:v52];
        long long v415 = @"accumulatedWeightT1";
        double v53 = v240;
        if (!v39) {
          double v53 = 0.1;
        }
        uint64_t v443 = [NSNumber numberWithDouble:v53];
        v416 = @"aaLumaSigma";
        LODWORD(v54) = v209;
        uint64_t v444 = [NSNumber numberWithFloat:v54];
        v417 = @"aaChromaSigma";
        LODWORD(v55) = v210;
        uint64_t v445 = [NSNumber numberWithFloat:v55];
        v418 = @"aaSpatialSigma";
        LODWORD(v56) = v211;
        uint64_t v446 = [NSNumber numberWithFloat:v56];
        v419 = @"segmentationSigma";
        LODWORD(v57) = v272;
        if (!v39) {
          *(float *)&double v57 = 1000.0;
        }
        uint64_t v447 = [NSNumber numberWithFloat:v57];
        v420 = @"aaSegmentationSigma";
        double v58 = v273;
        if (!v39) {
          double v58 = 1.4;
        }
        uint64_t v448 = [NSNumber numberWithDouble:v58];
        v421 = @"Version";
        if (v39) {
          uint64_t v59 = v274;
        }
        else {
          uint64_t v59 = 0;
        }
        uint64_t v449 = [NSNumber numberWithInt:v59];
        uint64_t v473 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v433 forKeys:&v405 count:17];
        v463 = @"SLM";
        v531 = @"shiftDeadZone";
        LODWORD(v60) = v212;
        uint64_t v539 = [NSNumber numberWithFloat:v60];
        v532 = @"zeroShiftPercentile";
        double v61 = v241;
        if (!v39) {
          double v61 = 0.75;
        }
        uint64_t v540 = [NSNumber numberWithDouble:v61];
        v533 = @"maxFGBlur";
        double v62 = v242;
        if (!v39) {
          double v62 = 0.0002;
        }
        uint64_t v541 = [NSNumber numberWithDouble:v62];
        v534 = @"maximumSimulatedAperture";
        double v63 = v271;
        if (!v39) {
          double v63 = 0.0;
        }
        uint64_t v542 = [NSNumber numberWithDouble:v63];
        v535 = @"defaultSimulatedAperture";
        double v64 = v275;
        if (!v39) {
          double v64 = 0.0;
        }
        uint64_t v543 = [NSNumber numberWithDouble:v64];
        v536 = @"disparityScalingFactor";
        double v65 = v276;
        if (!v39) {
          double v65 = 0.0;
        }
        uint64_t v544 = [NSNumber numberWithDouble:v65];
        uint64_t v474 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v539 forKeys:&v531 count:6];
        v464 = @"HighlightRecovery";
        v495 = @"iterations";
        uint64_t v512 = [NSNumber numberWithInt:v217];
        v496 = @"preFilterGain";
        LODWORD(v66) = v218;
        v513 = (void *)[NSNumber numberWithFloat:v66];
        v497 = @"weightGain";
        LODWORD(v67) = v219;
        v514 = (void *)[NSNumber numberWithFloat:v67];
        v498 = @"intensityGain";
        LODWORD(v6_Block_object_dispose(&STACK[0x238], 8) = v220;
        uint64_t v515 = [NSNumber numberWithFloat:v68];
        v499 = @"mode";
        v516 = &unk_1EE4AAFD0;
        v500 = @"blurRadiusT0";
        double v69 = v251;
        if (!v39) {
          double v69 = 0.0025;
        }
        uint64_t v517 = [NSNumber numberWithDouble:v69];
        v501 = @"blurRadiusT1";
        double v70 = v252;
        if (!v39) {
          double v70 = 0.0075;
        }
        uint64_t v518 = [NSNumber numberWithDouble:v70];
        v502 = @"maxIntensityT0";
        double v71 = v253;
        if (!v39) {
          double v71 = 0.9;
        }
        uint64_t v519 = [NSNumber numberWithDouble:v71];
        v503 = @"maxIntensityT1";
        double v72 = v254;
        if (!v39) {
          double v72 = 1.0;
        }
        uint64_t v520 = [NSNumber numberWithDouble:v72];
        v504 = @"minIntensityT0";
        double v73 = v255;
        if (!v39) {
          double v73 = 0.0;
        }
        uint64_t v521 = [NSNumber numberWithDouble:v73];
        v505 = @"minIntensityT1";
        double v74 = v256;
        if (!v39) {
          double v74 = 0.2;
        }
        uint64_t v522 = [NSNumber numberWithDouble:v74];
        uint64_t v475 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v512 forKeys:&v495 count:11];
        v465 = @"Rendering";
        float32x2_t v317 = @"faces.linearBlurGrowthC";
        LODWORD(v75) = v214;
        uint64_t v355 = [NSNumber numberWithFloat:v75];
        float v318 = @"faces.linearBlurGrowthM";
        LODWORD(v76) = v213;
        uint64_t v356 = [NSNumber numberWithFloat:v76];
        float v319 = @"faces.distToBlurScaling";
        LODWORD(v77) = v215;
        uint64_t v357 = [NSNumber numberWithFloat:v77];
        float v320 = @"faces.eyeToEyebrowRatio";
        LODWORD(v7_Block_object_dispose(&STACK[0x238], 8) = v216;
        uint64_t v358 = [NSNumber numberWithFloat:v78];
        float32x2_t v321 = @"faces.maxBlurOnEyes";
        LODWORD(v79) = v257;
        uint64_t v359 = [NSNumber numberWithFloat:v79];
        float v322 = @"faces.maxBlurDistFromFocus";
        LODWORD(v80) = v258;
        uint64_t v360 = [NSNumber numberWithFloat:v80];
        float v323 = @"faces.capMultip";
        LODWORD(v81) = v259;
        uint64_t v361 = [NSNumber numberWithFloat:v81];
        float v324 = @"faces.gainMultip";
        LODWORD(v82) = v260;
        uint64_t v362 = [NSNumber numberWithFloat:v82];
        float32x2_t v325 = @"lumaNoiseModelCoeff";
        LODWORD(v83) = v247;
        uint64_t v363 = [NSNumber numberWithFloat:v83];
        float32x2_t v326 = @"relativeWeightThreshold";
        LODWORD(v84) = v222;
        uint64_t v364 = [NSNumber numberWithFloat:v84];
        float32x2_t v327 = @"highlightBoostGain";
        LODWORD(v85) = v223;
        uint64_t v365 = [NSNumber numberWithFloat:v85];
        float v328 = @"shapeObstructionCoeff";
        LODWORD(v86) = v224;
        uint64_t v366 = [NSNumber numberWithFloat:v86];
        float v329 = @"ringAmplitude";
        LODWORD(v87) = v225;
        uint64_t v367 = [NSNumber numberWithFloat:v87];
        float v330 = @"ringSharpness";
        LODWORD(v8_Block_object_dispose(&STACK[0x238], 8) = v226;
        uint64_t v368 = [NSNumber numberWithFloat:v88];
        float32x2_t v331 = @"antiAliasBlurStrength";
        LODWORD(v89) = v228;
        uint64_t v369 = [NSNumber numberWithFloat:v89];
        float v332 = @"minimumSimulatedAperture";
        LODWORD(v90) = v229;
        uint64_t v370 = [NSNumber numberWithFloat:v90];
        float v333 = @"antiAliasRadius";
        uint64_t v371 = [NSNumber numberWithInt:v248];
        float v334 = @"alphaEpsilon";
        LODWORD(v91) = v249;
        uint64_t v372 = [NSNumber numberWithFloat:v91];
        float32x2_t v335 = @"alphaGain";
        LODWORD(v92) = v250;
        uint64_t v373 = [NSNumber numberWithFloat:v92];
        float32x2_t v336 = @"maxBlur";
        long long v374 = &unk_1EE4AA2D0;
        float32x2_t v337 = @"nRings";
        uint64_t v375 = [NSNumber numberWithInt:v221];
        float v338 = @"preFilterBlurStrength";
        LODWORD(v93) = v227;
        uint64_t v376 = [NSNumber numberWithFloat:v93];
        float v339 = @"preFilterRadius";
        uint64_t v377 = [NSNumber numberWithInt:v244];
        float v340 = @"sharpRadius";
        LODWORD(v94) = v245;
        uint64_t v378 = [NSNumber numberWithFloat:v94];
        float32x2_t v341 = @"softRadius";
        double v95 = v246;
        if (!v39) {
          double v95 = 1.0;
        }
        uint64_t v379 = [NSNumber numberWithDouble:v95];
        float v342 = @"basePixelWeight";
        v380 = &unk_1EE4AA2E0;
        float v343 = @"blendingQuarterResAlphaGain";
        double v96 = v230;
        if (!v39) {
          double v96 = 1.0;
        }
        uint64_t v381 = [NSNumber numberWithDouble:v96];
        float v344 = @"blendingFullResAlphaGain";
        double v97 = v231;
        if (!v39) {
          double v97 = 1.0;
        }
        uint64_t v382 = [NSNumber numberWithDouble:v97];
        v476 = (void *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v355 forKeys:&v317 count:28];
        v466 = @"Fusion";
        v483 = @"subtractiveLowerAlpha";
        LODWORD(v9_Block_object_dispose(&STACK[0x238], 8) = v261;
        if (!v39) {
          *(float *)&double v98 = 0.8;
        }
        uint64_t v489 = [NSNumber numberWithFloat:v98];
        v484 = @"subtractiveUpperAlpha";
        LODWORD(v99) = v262;
        if (!v39) {
          *(float *)&double v99 = 1.0;
        }
        uint64_t v490 = [NSNumber numberWithFloat:v99];
        v485 = @"subtractiveMaxBlur";
        double v100 = v263;
        if (!v39) {
          double v100 = 0.0;
        }
        uint64_t v491 = [NSNumber numberWithDouble:v100];
        v486 = @"additiveLowerAlpha";
        LODWORD(v101) = v264;
        if (!v39) {
          *(float *)&double v101 = 0.0;
        }
        uint64_t v492 = [NSNumber numberWithFloat:v101];
        v487 = @"additiveUpperAlpha";
        LODWORD(v102) = v265;
        if (!v39) {
          *(float *)&double v102 = 0.2;
        }
        uint64_t v493 = [NSNumber numberWithFloat:v102];
        v488 = @"additiveMaxBlur";
        double v103 = v266;
        if (!v39) {
          double v103 = 0.0;
        }
        uint64_t v494 = [NSNumber numberWithDouble:v103];
        uint64_t v477 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v489 forKeys:&v483 count:6];
        v467 = @"Version";
        v478 = &unk_1EE4AAFE8;
        double v28 = (void *)MEMORY[0x1E4F1C9E8];
        id v29 = &v472;
        double v30 = &v461;
        uint64_t v31 = 7;
        break;
      case 1:
        std::vector<std::string>::size_type v405 = @"DisparitySmoothing";
        v461 = @"nIterations";
        uint64_t v472 = [NSNumber numberWithUnsignedInt:HIDWORD(v207)];
        uint64_t v433 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v472 forKeys:&v461 count:1];
        v406 = @"SLM";
        v495 = @"shiftDeadZone";
        *(float *)&double v20 = v208;
        uint64_t v512 = [NSNumber numberWithFloat:v20];
        v496 = @"maximumSimulatedAperture";
        v513 = &unk_1EE4AA270;
        v497 = @"defaultSimulatedAperture";
        v514 = &unk_1EE4AA270;
        uint64_t v434 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v512 forKeys:&v495 count:3];
        v407 = @"Rendering";
        float32x2_t v317 = @"faces.linearBlurGrowthC";
        LODWORD(v21) = v210;
        uint64_t v355 = [NSNumber numberWithFloat:v21];
        float v318 = @"faces.linearBlurGrowthM";
        LODWORD(v22) = v209;
        uint64_t v356 = [NSNumber numberWithFloat:v22];
        float v319 = @"faces.distToBlurScaling";
        LODWORD(v23) = v211;
        uint64_t v357 = [NSNumber numberWithFloat:v23];
        float v320 = @"faces.eyeToEyebrowRatio";
        LODWORD(v24) = v212;
        uint64_t v358 = [NSNumber numberWithFloat:v24];
        float32x2_t v321 = @"relativeWeightThreshold";
        LODWORD(v25) = v213;
        uint64_t v359 = [NSNumber numberWithFloat:v25];
        float v322 = @"highlightBoostGain";
        LODWORD(v26) = v214;
        uint64_t v360 = [NSNumber numberWithFloat:v26];
        float v323 = @"antiAliasBlurStrength";
        LODWORD(v27) = v215;
        uint64_t v361 = [NSNumber numberWithFloat:v27];
        uint64_t v435 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v355 forKeys:&v317 count:7];
        uint64_t v408 = @"Version";
        v436 = &unk_1EE4AB018;
        double v28 = (void *)MEMORY[0x1E4F1C9E8];
        id v29 = &v433;
        double v30 = &v405;
        uint64_t v31 = 4;
        break;
      default:
        float32x2_t v315 = @"Version";
        uint64_t v316 = [NSNumber numberWithInt:v8];
        double v28 = (void *)MEMORY[0x1E4F1C9E8];
        id v29 = &v316;
        double v30 = &v315;
        uint64_t v31 = 1;
        break;
    }
    return (const CGImageMetadata *)[v28 dictionaryWithObjects:v29 forKeys:v30 count:v31];
  }
  return a1;
}

const CGImageMetadata *tuningParametersFromImage(CIImage *a1)
{
  if (!a1) {
    return (const CGImageMetadata *)MEMORY[0x1E4F1CC08];
  }
  if (![(CIImage *)a1 properties]) {
    return (const CGImageMetadata *)MEMORY[0x1E4F1CC08];
  }
  CFTypeID v2 = [(CIImage *)a1 properties];
  CGImageMetadataRef v3 = [(NSDictionary *)v2 objectForKeyedSubscript:*MEMORY[0x1E4F2F380]];
  if (!v3) {
    return (const CGImageMetadata *)MEMORY[0x1E4F1CC08];
  }

  return tuningParametersFromMetaData(v3);
}

void getSimulatedAperture(CIImage *a1, const CGImageMetadata *a2, NSNumber *a3, NSDictionary *a4)
{
  [(NSNumber *)a3 floatValue];
  if (*(float *)&v7 != 0.0) {
    goto LABEL_10;
  }
  if (a2)
  {
    getSimulatedApertureFromAuxMetadata(a2);
    float v8 = *(float *)&v7;
    if (!a1) {
      goto LABEL_11;
    }
  }
  else
  {
    float v8 = 0.0;
    if (!a1) {
      goto LABEL_11;
    }
  }
  if (v8 == 0.0)
  {
    if ([(CIImage *)a1 properties])
    {
      int v9 = [(CIImage *)a1 properties];
      double v10 = [(NSDictionary *)v9 objectForKeyedSubscript:*MEMORY[0x1E4F2F380]];
      a2 = v10;
      if (v10)
      {
        getSimulatedApertureFromAuxMetadata(v10);
LABEL_10:
        float v8 = *(float *)&v7;
      }
    }
  }
LABEL_11:
  if (v8 == 0.0)
  {
    SDOFSimpleLensModelValue(@"simulatedAperture", 0);
    float v8 = *(float *)&v7;
  }
  LODWORD(v7) = 4.5;
  if (v8 != 0.0)
  {
    if (a4)
    {
      int v11 = objc_msgSend(-[NSDictionary objectForKeyedSubscript:](a4, "objectForKeyedSubscript:", @"Version", v7), "intValue");
      if (v11 >= 2)
      {
        int v17 = 1083179008;
        int v18 = 1083179008;
        if (v11 > 3)
        {
          if (a2)
          {
            uint64_t v12 = CGImageMetadataCopyTagWithPath(a2, 0, @"depthBlurEffect:RenderingParameters");
            if (v12)
            {
              uint64_t v13 = v12;
              if (CGImageMetadataTagGetType(v12) == kCGImageMetadataTypeString)
              {
                CFTypeRef v14 = CGImageMetadataTagCopyValue(v13);
                uint64_t v15 = (void *)[objc_alloc(MEMORY[0x1E4F1C9B8]) initWithBase64EncodedString:(id)CFMakeCollectable(v14) options:0];
                CFRelease(v13);
                if (v15)
                {
                  int v16 = 0;
                  +[CIFilter getMinMaxSimulatedApertureFrom:v15 minValue:&v18 maxValue:&v17 version:&v16];
                }
              }
              else
              {
                CFRelease(v13);
              }
            }
          }
        }
        else
        {
          SDOFRenderingValue(&cfstr_Minimumsimulat.isa, a4);
          SDOFSimpleLensModelValue(@"maximumSimulatedAperture", a4);
        }
      }
    }
  }
}

uint64_t envCCSDOFMetadataClass(void)
{
  if (CCPBundleEnvar(void)::onceToken != -1) {
    dispatch_once(&CCPBundleEnvar(void)::onceToken, &__block_literal_global_1246);
  }
  uint64_t v0 = [(id)CCPBundleEnvar(void)::b classNamed:@"CCSDOFMetadata"];
  if (!v0)
  {
    uint64_t v3 = 0;
    uint64_t v4 = &v3;
    uint64_t v5 = 0x3052000000;
    id v6 = __Block_byref_object_copy__20;
    double v7 = __Block_byref_object_dispose__20;
    uint64_t v0 = getCCSDOFMetadataClass(void)::softClass;
    uint64_t v8 = getCCSDOFMetadataClass(void)::softClass;
    if (!getCCSDOFMetadataClass(void)::softClass)
    {
      v2[0] = MEMORY[0x1E4F143A8];
      v2[1] = 3221225472;
      _OWORD v2[2] = ___ZL22getCCSDOFMetadataClassv_block_invoke;
      v2[3] = &unk_1E57710B8;
      void v2[4] = &v3;
      ___ZL22getCCSDOFMetadataClassv_block_invoke((uint64_t)v2);
      uint64_t v0 = v4[5];
    }
    _Block_object_dispose(&v3, 8);
  }
  return v0;
}

void sub_193877A98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t FigDepthBlurEffectRenderingParametersV1FromCFData(void *a1, _OWORD *a2)
{
  if ((unint64_t)[a1 length] > 0x2F)
  {
    [a1 getBytes:v10 length:48];
    if (LODWORD(v10[0]) == 1145980242)
    {
      if (DWORD1(v10[0]) == 1)
      {
        if (DWORD2(v10[0]) == 48)
        {
          uint64_t result = 0;
          long long v6 = v10[1];
          *a2 = v10[0];
          a2[1] = v6;
          a2[2] = v10[2];
        }
        else
        {
          int v9 = ci_logger_api();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
            FigDepthBlurEffectRenderingParametersV1FromCFData();
          }
          return 4;
        }
      }
      else
      {
        uint64_t v8 = ci_logger_api();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
          FigDepthBlurEffectRenderingParametersV1FromCFData();
        }
        return 3;
      }
    }
    else
    {
      double v7 = ci_logger_api();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
        FigDepthBlurEffectRenderingParametersV1FromCFData();
      }
      return 2;
    }
  }
  else
  {
    uint64_t v4 = ci_logger_api();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      FigDepthBlurEffectRenderingParametersV1FromCFData();
    }
    return 1;
  }
  return result;
}

uint64_t FigDepthBlurEffectRenderingParametersV2FromCFData(void *a1, char *a2, BOOL *a3)
{
  if ([a1 length] == 112 || (unint64_t)objc_msgSend(a1, "length") > 0x13F)
  {
    objc_msgSend(a1, "getBytes:length:", v12, objc_msgSend(a1, "length"));
    if (v12[0] == 1145980242)
    {
      if (v12[1] == 2)
      {
        size_t v8 = __n;
        if (__n == 112 || __n == 320)
        {
          *a3 = __n == 320;
          memcpy(a2, v12, v8);
          if (v8 != 320) {
            bzero(&a2[v8], 320 - v8);
          }
          return 0;
        }
        else
        {
          int v11 = ci_logger_api();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
            FigDepthBlurEffectRenderingParametersV1FromCFData();
          }
          return 4;
        }
      }
      else
      {
        double v10 = ci_logger_api();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
          FigDepthBlurEffectRenderingParametersV1FromCFData();
        }
        return 3;
      }
    }
    else
    {
      int v9 = ci_logger_api();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        FigDepthBlurEffectRenderingParametersV1FromCFData();
      }
      return 2;
    }
  }
  else
  {
    long long v6 = ci_logger_api();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      FigDepthBlurEffectRenderingParametersV1FromCFData();
    }
    return 1;
  }
}

uint64_t FigDepthBlurEffectRenderingParametersV3FromCFData(void *a1, void *a2)
{
  if ((unint64_t)[a1 length] > 0x1D7)
  {
    [a1 getBytes:__src length:472];
    if (__src[0] == 1145980242)
    {
      if (__src[1] == 3)
      {
        if (__src[2] == 472)
        {
          memcpy(a2, __src, 0x1D8uLL);
          return 0;
        }
        else
        {
          size_t v8 = ci_logger_api();
          if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
            FigDepthBlurEffectRenderingParametersV1FromCFData();
          }
          return 4;
        }
      }
      else
      {
        double v7 = ci_logger_api();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
          FigDepthBlurEffectRenderingParametersV1FromCFData();
        }
        return 3;
      }
    }
    else
    {
      long long v6 = ci_logger_api();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
        FigDepthBlurEffectRenderingParametersV1FromCFData();
      }
      return 2;
    }
  }
  else
  {
    uint64_t v4 = ci_logger_api();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      FigDepthBlurEffectRenderingParametersV1FromCFData();
    }
    return 1;
  }
}

id ___ZL18SDOFParameterValueP8NSStringS0__block_invoke()
{
  uint64_t v2 = 0;
  uint64_t v0 = [MEMORY[0x1E4F1C9B8] dataWithBytes:aXmlVersion10En length:6332];
  SDOFParameterValue(NSString *,NSString *)::sdofParameters = [MEMORY[0x1E4F28F98] propertyListWithData:v0 options:0 format:0 error:&v2];
  return (id)SDOFParameterValue(NSString *,NSString *)::sdofParameters;
}

id ___ZL18SDOFParameterValueP8NSStringS0__block_invoke_2()
{
  id result = (id)objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F28CB8], "defaultManager"), "contentsAtPath:", @"/System/Library/Frameworks/MediaToolbox.framework/D11/CameraSetup.plist");
  if (result)
  {
    uint64_t v4 = 0;
    id result = (id)[MEMORY[0x1E4F28F98] propertyListWithData:result options:0 format:0 error:&v4];
    if (result) {
      BOOL v1 = v4 == 0;
    }
    else {
      BOOL v1 = 0;
    }
    if (v1)
    {
      id result = (id)[result valueForKey:@"TuningParameters"];
      if (result)
      {
        uint64_t v2 = result;
        id result = (id)[result valueForKey:@"DefaultSensorIDs"];
        if (result)
        {
          id result = (id)[result valueForKey:@"PortTypeBackTelephoto"];
          if (result)
          {
            id v3 = result;
            id result = (id)[v2 valueForKey:@"PortTypeBackTelephoto"];
            if (result)
            {
              id result = (id)[result objectForKey:v3];
              if (result)
              {
                id result = (id)[result valueForKey:@"SDOFRenderingParameters"];
                if (result)
                {
                  SDOFParameterValue(NSString *,NSString *)::sdofParametersOnDevice = (uint64_t)result;
                  return result;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

float cikernel::_convertDepthOrDisparity(float a1)
{
  return 1.0 / fmaxf(a1, 0.000001);
}

double cikernel::_segmentationFusion(double a1, float a2, __n128 a3, __n128 a4)
{
  float v4 = vmlas_n_f32(a3.n128_f32[1], a2, a3.n128_f32[0]);
  a3.n128_u32[0] = a3.n128_u32[2];
  if (v4 <= a3.n128_f32[2]) {
    a3.n128_f32[0] = v4;
  }
  if (v4 < 0.0) {
    a3.n128_f32[0] = 0.0;
  }
  float v5 = vmlas_n_f32(a4.n128_f32[1], a2, a4.n128_f32[0]);
  float v6 = a4.n128_f32[2];
  if (v5 <= a4.n128_f32[2]) {
    float v6 = v5;
  }
  if (v5 < 0.0) {
    float v6 = 0.0;
  }
  float v7 = vmlas_n_f32(a3.n128_f32[0], *(float *)&a1, *(float *)&a1) - v6;
  if (v7 <= 1.0) {
    float v8 = v7;
  }
  else {
    float v8 = 1.0;
  }
  if (v7 >= 0.0) {
    *(float *)&a1 = v8;
  }
  else {
    *(float *)&a1 = 0.0;
  }
  *(float *)&a1 = sqrtf(*(float *)&a1);
  *(void *)&double result = vdupq_lane_s32(*(int32x2_t *)&a1, 0).u64[0];
  return result;
}

void CI::f4_s_s_f3_f3(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  int v11 = (double (*)(void *, __n128, __n128, __n128, __n128))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  int v14 = *(_DWORD *)(v10 + 40);
  uint64_t v15 = *(void *)(v10 + 32);
  uint64_t v16 = *(void *)(v10 + 56);
  uint64_t v17 = *(void *)(v10 + 80);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 104)), a2);
  }
  int v18 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5) {
    int v18 = (__n128 *)((char *)a2 + 64 * v15);
  }
  int v19 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    int v19 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v20 = v11(a1, *v19, *v18, *((__n128 *)a2 + 4 * v16), *((__n128 *)a2 + 4 * v17));
  *(_OWORD *)(a3 + 16 * a7) = v20;
}

char *___ZL14CCPBundleEnvarv_block_invoke()
{
  double result = getenv("CI_CCPORTRAIT_PATH");
  if (result)
  {
    BOOL v1 = objc_msgSend(MEMORY[0x1E4F28B50], "bundleWithPath:", objc_msgSend(NSString, "stringWithUTF8String:", result));
    CCPBundleEnvar(void)::b = (uint64_t)v1;
    return (char *)[v1 load];
  }
  return result;
}

void __Block_byref_object_copy__20(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__20(uint64_t a1)
{
}

Class ___ZL20getCCFacePointsClassv_block_invoke(uint64_t a1)
{
  CCPortraitLibrary();
  Class result = objc_getClass("CCFacePoints");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    ___ZL20getCCFacePointsClassv_block_invoke_cold_1();
  }
  getCCFacePointsClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

void CCPortraitLibrary(void)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  v0[0] = 0;
  if (!CCPortraitLibraryCore(char **)::frameworkLibrary)
  {
    v0[1] = (void *)MEMORY[0x1E4F143A8];
    v0[2] = (void *)3221225472;
    v0[3] = ___ZL21CCPortraitLibraryCorePPc_block_invoke;
    v0[4] = &__block_descriptor_40_e5_v8__0l;
    v0[5] = v0;
    long long v1 = xmmword_1E5773128;
    uint64_t v2 = 0;
    CCPortraitLibraryCore(char **)::frameworkLibrardouble y = _sl_dlopen();
  }
  if (!CCPortraitLibraryCore(char **)::frameworkLibrary) {
    CCPortraitLibrary(v0);
  }
  if (v0[0]) {
    free(v0[0]);
  }
}

uint64_t ___ZL21CCPortraitLibraryCorePPc_block_invoke()
{
  uint64_t result = _sl_dlopen();
  CCPortraitLibraryCore(char **)::frameworkLibrardouble y = result;
  return result;
}

Class ___ZL25getCCMakeBlurMapArgsClassv_block_invoke(uint64_t a1)
{
  CCPortraitLibrary();
  Class result = objc_getClass("CCMakeBlurMapArgs");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    ___ZL25getCCMakeBlurMapArgsClassv_block_invoke_cold_1();
  }
  getCCMakeBlurMapArgsClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

Class ___ZL21getCCMakeBlurMapClassv_block_invoke(uint64_t a1)
{
  CCPortraitLibrary();
  Class result = objc_getClass("CCMakeBlurMap");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    ___ZL21getCCMakeBlurMapClassv_block_invoke_cold_1();
  }
  getCCMakeBlurMapClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

void getSimulatedApertureFromAuxMetadata(const CGImageMetadata *a1)
{
  long long v1 = CGImageMetadataCopyTagWithPath(a1, 0, @"depthBlurEffect:SimulatedAperture");
  if (v1)
  {
    uint64_t v2 = v1;
    CFTypeRef v3 = CGImageMetadataTagCopyValue(v1);
    [(id)(id)CFMakeCollectable(v3) floatValue];
    CFRelease(v2);
  }
}

uint64_t envCCApplyBlurMapArgsClass(void)
{
  if (CCPBundleEnvar(void)::onceToken != -1) {
    dispatch_once(&CCPBundleEnvar(void)::onceToken, &__block_literal_global_1246);
  }
  uint64_t v0 = [(id)CCPBundleEnvar(void)::b classNamed:@"CCApplyBlurMapArgs"];
  if (!v0)
  {
    uint64_t v3 = 0;
    float v4 = &v3;
    uint64_t v5 = 0x3052000000;
    float v6 = __Block_byref_object_copy__20;
    float v7 = __Block_byref_object_dispose__20;
    uint64_t v0 = getCCApplyBlurMapArgsClass(void)::softClass;
    uint64_t v8 = getCCApplyBlurMapArgsClass(void)::softClass;
    if (!getCCApplyBlurMapArgsClass(void)::softClass)
    {
      v2[0] = MEMORY[0x1E4F143A8];
      v2[1] = 3221225472;
      _OWORD v2[2] = ___ZL26getCCApplyBlurMapArgsClassv_block_invoke;
      v2[3] = &unk_1E57710B8;
      void v2[4] = &v3;
      ___ZL26getCCApplyBlurMapArgsClassv_block_invoke((uint64_t)v2);
      uint64_t v0 = v4[5];
    }
    _Block_object_dispose(&v3, 8);
  }
  return v0;
}

void sub_19387BA58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t envCCApplyBlurMapClass(void)
{
  if (CCPBundleEnvar(void)::onceToken != -1) {
    dispatch_once(&CCPBundleEnvar(void)::onceToken, &__block_literal_global_1246);
  }
  uint64_t v0 = [(id)CCPBundleEnvar(void)::b classNamed:@"CCApplyBlurMap"];
  if (!v0)
  {
    uint64_t v3 = 0;
    float v4 = &v3;
    uint64_t v5 = 0x3052000000;
    float v6 = __Block_byref_object_copy__20;
    float v7 = __Block_byref_object_dispose__20;
    uint64_t v0 = getCCApplyBlurMapClass(void)::softClass;
    uint64_t v8 = getCCApplyBlurMapClass(void)::softClass;
    if (!getCCApplyBlurMapClass(void)::softClass)
    {
      v2[0] = MEMORY[0x1E4F143A8];
      v2[1] = 3221225472;
      _OWORD v2[2] = ___ZL22getCCApplyBlurMapClassv_block_invoke;
      v2[3] = &unk_1E57710B8;
      void v2[4] = &v3;
      ___ZL22getCCApplyBlurMapClassv_block_invoke((uint64_t)v2);
      uint64_t v0 = v4[5];
    }
    _Block_object_dispose(&v3, 8);
  }
  return v0;
}

void sub_19387BB8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class ___ZL26getCCApplyBlurMapArgsClassv_block_invoke(uint64_t a1)
{
  CCPortraitLibrary();
  Class result = objc_getClass("CCApplyBlurMapArgs");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    ___ZL26getCCApplyBlurMapArgsClassv_block_invoke_cold_1();
  }
  getCCApplyBlurMapArgsClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

Class ___ZL22getCCApplyBlurMapClassv_block_invoke(uint64_t a1)
{
  CCPortraitLibrary();
  Class result = objc_getClass("CCApplyBlurMap");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    ___ZL22getCCApplyBlurMapClassv_block_invoke_cold_1();
  }
  getCCApplyBlurMapClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

Class ___ZL22getCCSDOFMetadataClassv_block_invoke(uint64_t a1)
{
  CCPortraitLibrary();
  Class result = objc_getClass("CCSDOFMetadata");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    ___ZL22getCCSDOFMetadataClassv_block_invoke_cold_1();
  }
  getCCSDOFMetadataClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

uint64_t ___ZL23prewarmSDOFFilterGraphsP9CIContext_block_invoke(uint64_t a1)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  uint64_t result = [*(id *)(a1 + 32) count];
  if (result)
  {
    double v21 = *(CIContext **)(a1 + 40);
    if (!v21)
    {
      v36[0] = @"working_format";
      v37[0] = [NSNumber numberWithInt:2056];
      v37[1] = &unk_1EE4AB078;
      v36[1] = @"kCIContextIntermediateMemoryTarget";
      v36[2] = @"kCIContextCacheIntermediates";
      void v36[3] = @"kCIContextUseMetalRenderer";
      v37[2] = MEMORY[0x1E4F1CC28];
      v37[3] = MEMORY[0x1E4F1CC38];
      double v21 = +[CIContext contextWithOptions:](CIContext, "contextWithOptions:", [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v37 forKeys:v36 count:4]);
    }
    long long v26 = 0u;
    long long v27 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    uint64_t v3 = *(void **)(a1 + 32);
    uint64_t result = [v3 countByEnumeratingWithState:&v24 objects:v35 count:16];
    uint64_t v5 = result;
    if (result)
    {
      uint64_t v6 = *(void *)v25;
      *(void *)&long long v4 = 138543362;
      long long v20 = v4;
      do
      {
        uint64_t v7 = 0;
        do
        {
          if (*(void *)v25 != v6) {
            objc_enumerationMutation(v3);
          }
          id v8 = +[CIFilter prewarmedFilterFromString:](CIFilter, "prewarmedFilterFromString:", *(void *)(*((void *)&v24 + 1) + 8 * v7), v20);
          if (v8)
          {
            int v9 = (void *)MEMORY[0x199702DB0]();
            uint64_t v10 = (void *)[v8 outputImage];
            if (v10)
            {
              v32[0] = 0;
              v32[1] = v32;
              v32[2] = 0x3052000000;
              v32[3] = __Block_byref_object_copy__20;
              v32[4] = __Block_byref_object_dispose__20;
              v32[5] = 0;
              int v11 = [CIRenderDestination alloc];
              [v10 extent];
              double v13 = v12;
              [v10 extent];
              v31[0] = MEMORY[0x1E4F143A8];
              v31[1] = 3221225472;
              v31[2] = ___ZL20renderPrewarmedImageP9CIContextP8CIFilter_block_invoke;
              v31[3] = &unk_1E5773148;
              void v31[4] = v32;
              uint64_t v15 = [(CIRenderDestination *)v11 initWithWidth:(unint64_t)v13 height:(unint64_t)v14 pixelFormat:70 commandBuffer:0 mtlTextureProvider:v31];
              if (v15)
              {
                uint64_t v28 = 0;
                [v10 extent];
                -[CIContext prepareRender:fromRect:toDestination:atPoint:error:](v21, "prepareRender:fromRect:toDestination:atPoint:error:", v10, v15, &v28);
                if (v28)
                {
                  uint64_t v16 = ci_logger_api();
                  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)uint8_t buf = v20;
                    uint64_t v39 = v28;
                    _os_log_error_impl(&dword_193671000, v16, OS_LOG_TYPE_ERROR, "Error asking CI to prepare render = %{public}@", buf, 0xCu);
                  }
                }
              }
              else
              {
                int v19 = ci_logger_api();
                if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
                  ___ZL23prewarmSDOFFilterGraphsP9CIContext_block_invoke_cold_3(&v29, v30);
                }
              }
              _Block_object_dispose(v32, 8);
            }
            else
            {
              int v18 = ci_logger_api();
              if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
                ___ZL23prewarmSDOFFilterGraphsP9CIContext_block_invoke_cold_2(&v33, v34);
              }
            }
          }
          else
          {
            uint64_t v17 = ci_logger_api();
            if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
              ___ZL23prewarmSDOFFilterGraphsP9CIContext_block_invoke_cold_1(&v22, v23);
            }
          }
          ++v7;
        }
        while (v5 != v7);
        uint64_t result = [v3 countByEnumeratingWithState:&v24 objects:v35 count:16];
        uint64_t v5 = result;
      }
      while (result);
    }
  }
  return result;
}

void sub_19387C0B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
}

uint64_t ___ZL20renderPrewarmedImageP9CIContextP8CIFilter_block_invoke(uint64_t a1)
{
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
}

void OUTLINED_FUNCTION_2_6(void *a1, int a2, os_log_t log, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, a5, 2u);
}

unsigned char *OUTLINED_FUNCTION_3_2(unsigned char *result, unsigned char *a2)
{
  *uint64_t result = 0;
  *a2 = 0;
  return result;
}

void OUTLINED_FUNCTION_4_2(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 8u);
}

CIImage *_CUIMappedBlurImageWithSize(CIImage *a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3 = a2;
  long long v4 = a1;
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  unsigned int v5 = vcvtad_u64_f64((double)a3 * 0.01 * (double)a2);
  if (v5)
  {
    v3 -= v5;
    long long v4 = -[CIImage filteredImage:keysAndValues:](a1, "filteredImage:keysAndValues:", @"CUIScaleClampFilter", @"inputImage", _CUIMappedBlurImageWithSize(a1, v5, 0), @"inputScale", [NSNumber numberWithDouble:(float)((float)v5 * 5.0)], 0);
  }
  void v15[2] = xmmword_193957670;
  v15[3] = unk_193957680;
  uint64_t v16 = 0x3FB0000000000000;
  v15[0] = xmmword_193957650;
  v15[1] = unk_193957660;
  long long v12 = xmmword_1939576B8;
  long long v13 = unk_1939576C8;
  uint64_t v14 = 0x3FBC71C71C71C71CLL;
  HIDWORD(v6) = unk_1939576AC;
  long long v10 = xmmword_193957698;
  long long v11 = unk_1939576A8;
  if (!v3) {
    return v4;
  }
  if (v3 == 1)
  {
    uint64_t v7 = v15;
LABEL_8:
    id v8 = +[CIVector vectorWithValues:v7 count:9];
    return (CIImage *)[(CIImage *)v4 filteredImage:@"CIConvolution3X3", @"inputWeights", v8, @"inputBias", &unk_1EE4AA2F0, 0, v10, v11, v12, v13, v14 keysAndValues];
  }
  if (v3 <= 2)
  {
    uint64_t v7 = &v10;
    goto LABEL_8;
  }
  *(float *)&double v6 = (float)v3 / 2.853;
  return (CIImage *)-[CIImage filteredImage:keysAndValues:](v4, "filteredImage:keysAndValues:", @"CIGaussianBlur", @"inputRadius", [NSNumber numberWithFloat:v6], 0);
}

__n128 convolve(double *a1, const double *a2)
{
  uint64_t v2 = 0;
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = 0;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v7 = 0u;
  __n128 v8 = 0u;
  int v3 = -1;
  do
  {
    for (uint64_t i = 0; i != 3; ++i)
    {
      if ((v3 + i) <= 8) {
        *((double *)&v7 + (v3 + i)) = *((double *)&v7 + (v3 + i)) + a1[v2] * a2[i];
      }
    }
    ++v2;
    ++v3;
  }
  while (v2 != 9);
  long long v5 = v10;
  *((_OWORD *)a1 + 2) = v9;
  *((_OWORD *)a1 + 3) = v5;
  *((void *)a1 + _Block_object_dispose(&STACK[0x238], 8) = v11;
  __n128 result = v8;
  *(_OWORD *)a1 = v7;
  *((__n128 *)a1 + 1) = result;
  return result;
}

double cikernel::_cui_hueSaturation(int32x4_t a1, float a2, double a3, float a4, float32x2_t a5, double a6)
{
  if (*(float *)&a3 > 0.0)
  {
    double v6 = *(float *)&a3;
    *(float *)&a3 = fminf(*(float *)a1.i32, fminf(*(float *)&a1.i32[1], *(float *)&a1.i32[2]));
    float v7 = fmaxf(*(float *)a1.i32, fmaxf(*(float *)&a1.i32[1], *(float *)&a1.i32[2]));
    float v8 = v7 - *(float *)&a3;
    float v9 = (float)(v7 - *(float *)&a3) / v7;
    float v10 = 0.0;
    if (v7 == 0.0) {
      float v9 = 0.0;
    }
    if (v9 != 0.0)
    {
      float v11 = (float)((float)(*(float *)a1.i32 - *(float *)&a1.i32[1]) / v8) + 4.0;
      if (*(float *)&a1.i32[1] == v7) {
        float v11 = (float)((float)(*(float *)&a1.i32[2] - *(float *)a1.i32) / v8) + 2.0;
      }
      float v12 = (float)(*(float *)&a1.i32[1] - *(float *)&a1.i32[2]) / v8;
      if (*(float *)a1.i32 != v7) {
        float v12 = v11;
      }
      float v10 = v12 / 6.0;
      if ((float)(v12 / 6.0) < 0.0) {
        float v10 = v10 + 1.0;
      }
    }
    float v13 = (float)((float)(v10 * 360.0) - a2) / 6.0;
    if (v13 < 0.0) {
      float v13 = v13 + 360.0;
    }
    if (v6 * 0.5 > v13)
    {
      if (v9 == 0.0)
      {
        v14.i64[0] = 0;
        v14.i32[2] = 0;
      }
      else
      {
        float v15 = v13 + a4;
        if (v15 < 0.0) {
          float v15 = v15 + 360.0;
        }
        if (v15 > 360.0) {
          float v15 = v15 + -360.0;
        }
        float v16 = v15 / 60.0;
        int v17 = (int)v16;
        float v18 = v16 - floorf(v16);
        v19.f64[0] = v9;
        v19.f64[1] = (float)(v9 * v18);
        __asm { FMOV            V1.2D, #1.0 }
        float64x2_t v25 = vmulq_n_f64(vsubq_f64(_Q1, v19), v7);
        *(float32x2_t *)&v25.f64[0] = vcvt_f32_f64(v25);
        float v26 = (1.0 - v9 * (1.0 - v18)) * v7;
        switch(v17)
        {
          case 0:
            a1.i64[0] = __PAIR64__(LODWORD(v26), LODWORD(v7));
            a1.i32[2] = LODWORD(v25.f64[0]);
            goto LABEL_28;
          case 1:
            v14.i32[0] = vtrn2q_s32((int32x4_t)v25, a1).u32[0];
            *(float *)&v14.i32[1] = v7;
            v14.i32[2] = LODWORD(v25.f64[0]);
            break;
          case 2:
            HIDWORD(v25.f64[1]) = vextq_s8(*(int8x16_t *)&a1, *(int8x16_t *)&a1, 8uLL).i32[1];
            *((float *)v25.f64 + 1) = v7;
            *(float *)&v25.f64[1] = v26;
            goto LABEL_26;
          case 3:
            HIDWORD(v25.f64[1]) = vextq_s8(*(int8x16_t *)&a1, *(int8x16_t *)&a1, 8uLL).i32[1];
            *(float *)&v25.f64[1] = v7;
LABEL_26:
            int32x4_t v14 = (int32x4_t)v25;
            break;
          case 4:
            a1.i64[0] = __PAIR64__(LODWORD(v25.f64[0]), LODWORD(v26));
            *(float *)&a1.i32[2] = v7;
            goto LABEL_28;
          default:
            a1.i64[0] = __PAIR64__(LODWORD(v25.f64[0]), LODWORD(v7));
            a1.i32[2] = HIDWORD(v25.f64[0]);
LABEL_28:
            int32x4_t v14 = a1;
            break;
        }
      }
      float32x2_t v27 = vmls_lane_f32(*(float32x2_t *)v14.i8, vsub_f32(*(float32x2_t *)v14.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a3, 0)), *(float32x2_t *)&a6, 0);
      *(float *)&a3 = (float)((float)(*(float *)&v14.i32[2]
                                    - (float)((float)(*(float *)&v14.i32[2] - *(float *)&a3) * *(float *)&a6))
                            + vaddv_f32(v27))
                    / 3.0;
      *(float32x2_t *)a1.i8 = vmls_lane_f32(v27, vsub_f32(v27, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a3, 0)), a5, 0);
    }
  }
  return *(double *)a1.i64;
}

double cikernel::_scaleClamp(float32x4_t a1, float a2)
{
  float32x4_t v2 = vmaxnmq_f32(vmulq_n_f32(a1, a2), (float32x4_t)0);
  __asm { FMOV            V1.4S, #1.0 }
  *(void *)&double result = vminnmq_f32(v2, _Q1).u64[0];
  return result;
}

double cikernel::_innerGorS(__n128 a1, float32x4_t a2, float a3)
{
  float v3 = (1.0 - a1.n128_f32[3]) / a3;
  float v4 = 1.0;
  if (v3 <= 1.0) {
    float v4 = v3;
  }
  BOOL v5 = v3 < 0.0;
  float v6 = 0.0;
  if (!v5) {
    float v6 = v4;
  }
  *(void *)&double result = vmulq_n_f32(a2, v6).u64[0];
  return result;
}

double cikernel::_outerGorS(__n128 a1, float32x4_t a2, float a3)
{
  float v3 = a1.n128_f32[3] / a3;
  float v4 = 1.0;
  if (v3 <= 1.0) {
    float v4 = v3;
  }
  BOOL v5 = v3 < 0.0;
  float v6 = 0.0;
  if (!v5) {
    float v6 = v4;
  }
  *(void *)&double result = vmulq_n_f32(a2, v6).u64[0];
  return result;
}

double cikernel::_shapeEffectBlur_1(float32x4_t a1, __n128 _Q1, __n128 a3, __n128 a4, float32x4_t a5, float32x4_t a6, float32x4_t a7, float32x4_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, float32x4_t a17, float a18, float a19)
{
  float v19 = 1.0 - a3.n128_f32[3] + 1.0 - a3.n128_f32[3];
  if (v19 <= 1.0) {
    float v20 = 1.0 - a3.n128_f32[3] + 1.0 - a3.n128_f32[3];
  }
  else {
    float v20 = 1.0;
  }
  if (v19 < 0.0) {
    float v20 = 0.0;
  }
  float32x4_t v21 = vmulq_n_f32(a6, v20);
  if ((float)(a3.n128_f32[3] + a3.n128_f32[3]) <= 1.0) {
    float v22 = a3.n128_f32[3] + a3.n128_f32[3];
  }
  else {
    float v22 = 1.0;
  }
  if ((float)(a3.n128_f32[3] + a3.n128_f32[3]) >= 0.0) {
    float v23 = v22;
  }
  else {
    float v23 = 0.0;
  }
  float32x4_t v24 = vmulq_n_f32(a7, v23);
  float32x4_t v25 = vmulq_n_f32(a8, (float)((float)(1.0 - a4.n128_f32[3]) * a18) + (float)((float)(1.0 - _Q1.n128_f32[3]) * (float)(1.0 - a18)));
  _S7 = 1.0 - a19;
  __asm { FMLA            S3, S7, V1.S[3] }
  float32x4_t v32 = vmulq_n_f32(a17, _S3);
  float32x4_t v33 = vaddq_f32(v25, vmulq_n_f32(vaddq_f32(v21, vmulq_n_f32(a5, 1.0 - v21.f32[3])), 1.0 - v25.f32[3]));
  float v34 = a1.f32[3];
  float32x4_t v35 = vmulq_laneq_f32(v33, a1, 3);
  *(void *)&double result = vaddq_f32(v35, vmulq_n_f32(vmulq_n_f32(vaddq_f32(v24, vmulq_n_f32(v32, 1.0 - v24.f32[3])), 1.0 - v34), 1.0 - v35.f32[3])).u64[0];
  return result;
}

void CI::f4_s_s_s_s_s_clr_clr_clr_clr_f2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  float v10 = *(double (**)(__n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128, double, double, double))(a1 + 24);
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  int v13 = *(_DWORD *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  int v15 = *(_DWORD *)(v9 + 64);
  uint64_t v16 = *(void *)(v9 + 56);
  int v17 = *(_DWORD *)(v9 + 88);
  uint64_t v18 = *(void *)(v9 + 80);
  int v19 = *(_DWORD *)(v9 + 112);
  uint64_t v20 = *(void *)(v9 + 104);
  float32x4_t v21 = *(const vec2 **)(v9 + 128);
  uint64_t v22 = *(void *)(v9 + 152);
  uint64_t v23 = *(void *)(v9 + 176);
  uint64_t v24 = *(void *)(v9 + 200);
  int v25 = *(_DWORD *)(v9 + 232);
  uint64_t v26 = *(void *)(v9 + 224);
  if (*(unsigned char *)(a1 + 64))
  {
    uint64_t v40 = *(double (**)(__n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128, double, double, double))(a1 + 24);
    uint64_t v41 = *(void *)(v9 + 32);
    int v44 = *(_DWORD *)(v9 + 16);
    double v42 = *(const vec2 **)(v9 + 128);
    uint64_t v43 = *(void *)(v9 + 200);
    uint64_t v39 = *(void *)(v9 + 56);
    int v37 = *(_DWORD *)(v9 + 112);
    int v38 = *(_DWORD *)(v9 + 88);
    int v36 = *(_DWORD *)(v9 + 232);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 248)), v21);
    int v25 = v36;
    int v19 = v37;
    int v17 = v38;
    uint64_t v16 = v39;
    float v10 = v40;
    uint64_t v14 = v41;
    float32x4_t v21 = v42;
    uint64_t v24 = v43;
    int v11 = v44;
  }
  float32x2_t v27 = (double *)(a3 + 16 * v26);
  if (v25 != 5) {
    float32x2_t v27 = (double *)(a2 + (v26 << 6));
  }
  uint64_t v28 = (__n128 *)(a3 + 16 * v20);
  if (v19 != 5) {
    uint64_t v28 = (__n128 *)(a2 + (v20 << 6));
  }
  char v29 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5) {
    char v29 = (__n128 *)(a2 + (v18 << 6));
  }
  double v30 = (__n128 *)(a3 + 16 * v16);
  uint64_t v31 = (__n128 *)(a2 + (v16 << 6));
  if (v15 != 5) {
    double v30 = v31;
  }
  float32x4_t v32 = (__n128 *)(a3 + 16 * v14);
  float32x4_t v33 = (__n128 *)(a2 + (v14 << 6));
  if (v13 != 5) {
    float32x4_t v32 = v33;
  }
  float v34 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    float v34 = (__n128 *)(a2 + (v12 << 6));
  }
  *(double *)&long long v35 = v10(*v34, *v32, *v30, *v29, *v28, *(__n128 *)(a2 + ((void)v21 << 6)), *(__n128 *)(a2 + (v22 << 6)), *(__n128 *)(a2 + (v23 << 6)), *(double *)(a2 + (v24 << 6)), *(double *)(a2 + (v24 << 6) + 8), *v27);
  *(_OWORD *)(a3 + 16 * a7) = v35;
}

double cikernel::_outerBevelEmboss(uint64_t a1, int32x2_t a2)
{
  float32x2_t v3 = *(float32x2_t *)CI::getDC((CI *)a1);
  float32x2_t v4 = vadd_f32((float32x2_t)vdup_lane_s32(a2, 1), v3);
  *(float *)&double v5 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v4, 1), *(float *)(a1 + 16), v4.f32[0]);
  LODWORD(v6) = *(_DWORD *)(a1 + 28);
  v7.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v8.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v4, 1), *(float *)&v6, v4.f32[0]);
  v4.f32[0] = *(float *)(a1 + 24) + *(float *)&v5;
  *(float *)v9.f64 = *(float *)v7.i32 + *(float *)v8.i32;
  v4.f32[1] = *(float *)v7.i32 + *(float *)v8.i32;
  *(double *)v11.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v4, v9, v5, v6, v8, v7, v10);
  float32x4_t v40 = v11;
  *(float32x2_t *)v11.f32 = vadd_f32((float32x2_t)a2, v3);
  *(float *)&double v12 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v11.f32, 1), *(float *)(a1 + 16), v11.f32[0]);
  LODWORD(v13) = *(_DWORD *)(a1 + 28);
  v14.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v11.f32, 1), *(float *)&v13, v11.f32[0]);
  v11.f32[0] = *(float *)(a1 + 24) + *(float *)&v12;
  *(float *)v16.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v11.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)v18.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v11.i64, v16, v12, v13, v15, v14, v17);
  float32x4_t v39 = v18;
  *(float32x2_t *)v18.f32 = vadd_f32((float32x2_t)vrev64_s32(a2), v3);
  *(float *)&double v19 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v18.f32, 1), *(float *)(a1 + 16), v18.f32[0]);
  LODWORD(v20) = *(_DWORD *)(a1 + 28);
  v21.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v22.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v18.f32, 1), *(float *)&v20, v18.f32[0]);
  v18.f32[0] = *(float *)(a1 + 24) + *(float *)&v19;
  *(float *)v23.f64 = *(float *)v21.i32 + *(float *)v22.i32;
  v18.f32[1] = *(float *)v21.i32 + *(float *)v22.i32;
  *(double *)v25.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v18.i64, v23, v19, v20, v22, v21, v24);
  float32x4_t v38 = v25;
  *(float32x2_t *)v25.f32 = vadd_f32((float32x2_t)vdup_lane_s32(a2, 0), v3);
  *(float *)&double v26 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v25.f32, 1), *(float *)(a1 + 16), v25.f32[0]);
  LODWORD(v27) = *(_DWORD *)(a1 + 28);
  v28.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v29.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v25.f32, 1), *(float *)&v27, v25.f32[0]);
  v25.f32[0] = *(float *)(a1 + 24) + *(float *)&v26;
  *(float *)v30.f64 = *(float *)v28.i32 + *(float *)v29.i32;
  v25.f32[1] = *(float *)v28.i32 + *(float *)v29.i32;
  *(double *)v32.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v25.i64, v30, v26, v27, v29, v28, v31);
  v32.f32[0] = COERCE_FLOAT(vaddq_f32(v40, v39).i32[3]) + COERCE_FLOAT(vaddq_f32(v38, v32).i32[3]) * -1.3;
  float v33 = v32.f32[0] * 0.5 + 0.5;
  float v34 = 1.0;
  if (v33 <= 1.0) {
    float v34 = v33;
  }
  BOOL v35 = v33 < 0.0;
  int32x2_t v36 = 0;
  if (!v35) {
    *(float *)v36.i32 = v34;
  }
  *(void *)&double result = vdupq_lane_s32(v36, 0).u64[0];
  return result;
}

double cikernel::_outerBevelEmbossC(__n128 a1, float32x4_t a2, float32x4_t a3)
{
  float v3 = a1.n128_f32[3] * 2.0 + -1.0;
  float v4 = 1.0;
  if (v3 <= 1.0) {
    float v5 = a1.n128_f32[3] * 2.0 + -1.0;
  }
  else {
    float v5 = 1.0;
  }
  if (v3 >= -1.0) {
    float v4 = -v3;
  }
  BOOL v6 = v3 < 0.0;
  BOOL v7 = v3 <= 0.0;
  float v8 = 0.0;
  if (v6) {
    float v5 = 0.0;
  }
  float32x4_t v9 = vmulq_n_f32(a2, v5);
  if (v7) {
    float v8 = v4;
  }
  *(void *)&double result = vaddq_f32(vmulq_n_f32(a3, v8), v9).u64[0];
  return result;
}

double cikernel::_invertedMask()
{
  return 0.0;
}

double cikernel::_multiplyByMask(float32x4_t a1, float32x4_t a2)
{
  *(void *)&double result = vmulq_laneq_f32(a1, a2, 3).u64[0];
  return result;
}

void CI::f4_s_f_f_f_f_f(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = a1[6];
  int8x16_t v10 = (double (*)(void *, __n128, float, float, float, float, float))a1[3];
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  uint64_t v13 = *(void *)(v9 + 32);
  uint64_t v14 = *(void *)(v9 + 56);
  uint64_t v15 = *(void *)(v9 + 80);
  uint64_t v16 = *(void *)(v9 + 104);
  uint64_t v17 = *(void *)(v9 + 128);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 152)), a2);
  }
  float32x4_t v18 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    float32x4_t v18 = (__n128 *)((char *)a2 + 64 * v12);
  }
  *(double *)&long long v19 = v10(a1, *v18, *((float *)a2 + 16 * v13), *((float *)a2 + 16 * v14), *((float *)a2 + 16 * v15), *((float *)a2 + 16 * v16), *((float *)a2 + 16 * v17));
  *(_OWORD *)(a3 + 16 * a7) = v19;
}

void CI::snprintf_cs(CI *this, char *a2, CGColorSpace *a3, CGColorSpace *a4)
{
  int v4 = (int)a4;
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  int Type = CGColorSpaceGetType();
  if (a3)
  {
    switch(Type)
    {
      case 0:
        uint64_t v9 = "devicegray";
        goto LABEL_5;
      case 1:
      case 2:
        uint64_t v9 = "devicergb";
        goto LABEL_5;
      case 3:
        *(void *)&long long v33 = 0;
        long long v31 = 0u;
        long long v32 = 0u;
        *(_OWORD *)buffer = 0u;
        CGColorSpaceGetCalibratedGrayData();
        snprintf((char *)this, (size_t)a2, "calGray(");
        BOOL v11 = 0.96420002 == 0.0 && *(double *)&buffer[8] == 1.0;
        if (v11 && *(double *)&v31 == 0.824899971)
        {
          uint64_t v12 = "wp=d50 ";
        }
        else
        {
          *(void *)&long long v26 = v31;
          long long v24 = *(_OWORD *)buffer;
          uint64_t v12 = "wp=%.3f,%.3f,%.3f ";
        }
        CI::snprintfcat(this, a2, v12, v10, 0.0, 0.0, 0.0, v24, (void)v26);
        if (*((double *)&v31 + 1) != 0.0 || *(double *)&v32 != 0.0 || *((double *)&v32 + 1) != 0.0) {
          CI::snprintfcat(this, a2, "bp=%.3f,%.3f,%.3f ", v18, *((void *)&v31 + 1), v32);
        }
        double v19 = *(double *)&v33;
        if (*(double *)&v33 == 1.0)
        {
          double v20 = "gamma=1)";
          goto LABEL_58;
        }
        CI::snprintfcat(this, a2, "gamma=%.3f)", v18, *(double *)&v33, (void)v33, *((void *)&v25 + 1), (void)v26);
        return;
      case 4:
        long long v33 = 0u;
        memset(v34, 0, sizeof(v34));
        long long v31 = 0u;
        long long v32 = 0u;
        *(_OWORD *)buffer = 0u;
        CGColorSpaceGetCalibratedRGBData();
        snprintf((char *)this, (size_t)a2, "calRGB(");
        BOOL v14 = 0.96420002 == 0.0 && *(double *)&buffer[8] == 1.0;
        if (v14 && *(double *)&v31 == 0.824899971) {
          snprintf((char *)this, (size_t)a2, "wp=d50 ", 0.0, 0.0, 0.0);
        }
        else {
          CI::snprintfcat(this, a2, "wp=%.3f,%.3f,%.3f ", v13, *(void *)buffer, *(void *)&buffer[8], (void)v31);
        }
        if (*((double *)&v31 + 1) != 0.0 || *(double *)&v32 != 0.0 || *((double *)&v32 + 1) != 0.0) {
          CI::snprintfcat(this, a2, "bp=%.3f,%.3f,%.3f ", v15, *((void *)&v31 + 1), v32);
        }
        if (*(double *)&v33 == 1.0 && *((double *)&v33 + 1) == 1.0 && *(double *)v34 == 1.0)
        {
          int8x16_t v21 = "gamma=1 ";
        }
        else
        {
          if (*(double *)&v33 == *((double *)&v33 + 1) && *((double *)&v33 + 1) == *(double *)v34)
          {
            CI::snprintfcat(this, a2, "gamma=%.3f ", v15, *((double *)&v33 + 1), *(double *)&v33, *(double *)v34, *((void *)&v33 + 1), *((void *)&v24 + 1), (void)v26);
            goto LABEL_57;
          }
          *(void *)&long long v26 = *(void *)&v34[0];
          long long v24 = v33;
          int8x16_t v21 = "gamma=%.3f,%.3f,%.3f ";
        }
        CI::snprintfcat(this, a2, v21, v15, *((double *)&v33 + 1), *(double *)&v33, *(double *)v34, v24, (void)v26);
LABEL_57:
        double v19 = *((double *)v34 + 1);
        uint64_t v29 = *((void *)&v34[4] + 1);
        long long v27 = *(_OWORD *)((char *)&v34[2] + 8);
        long long v28 = *(_OWORD *)((char *)&v34[3] + 8);
        long long v25 = *(_OWORD *)((char *)v34 + 8);
        long long v26 = *(_OWORD *)((char *)&v34[1] + 8);
        double v20 = "mtx=%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f)";
LABEL_58:
        CI::snprintfcat(this, a2, v20, v18, v19, v25, v26, v27, v28, v29);
        return;
      case 5:
        snprintf((char *)this, (size_t)a2, "Lab Colorspace %p");
        return;
      case 6:
        {
          CI::snprintf_cs(char *,unsigned long,CGColorSpace *,BOOL)::sRGB_cs = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
        }
        if ((CGColorSpace *)CI::snprintf_cs(char *,unsigned long,CGColorSpace *,BOOL)::sRGB_cs == a3)
        {
          uint64_t v9 = "sRGB";
          goto LABEL_5;
        }
        memset(v34, 0, 64);
        long long v32 = 0u;
        long long v33 = 0u;
        *(_OWORD *)buffer = 0u;
        long long v31 = 0u;
        CFStringRef Name = CGColorSpaceGetName(a3);
        if (Name)
        {
          CFStringRef v17 = Name;
          CFRetain(Name);
LABEL_61:
          CFStringGetCString(v17, buffer, 128, 0x8000100u);
          char v22 = 0;
          goto LABEL_62;
        }
        CFStringRef v17 = (const __CFString *)CGColorSpaceCopyICCProfileDescription();
        if (v17) {
          goto LABEL_61;
        }
        char v22 = 1;
LABEL_62:
        BOOL v23 = *(void *)buffer == 0x726F6C6F4347436BLL && *(void *)&buffer[5] == 0x6563617053726F6CLL;
        if (v23 || !v4) {
          snprintf((char *)this, (size_t)a2, "%s");
        }
        else {
          snprintf((char *)this, (size_t)a2, "\"%s\"");
        }
        if ((v22 & 1) == 0) {
          CFRelease(v17);
        }
        break;
      case 7:
        snprintf((char *)this, (size_t)a2, "Indexed Colorspace %p");
        return;
      case 8:
        snprintf((char *)this, (size_t)a2, "DeviceN Colorspace %p");
        return;
      case 9:
        snprintf((char *)this, (size_t)a2, "Pattern Colorspace %p");
        return;
      case 10:
        snprintf((char *)this, (size_t)a2, "PlatformSets Colorspace %p");
        return;
      default:
        snprintf((char *)this, (size_t)a2, "%p");
        return;
    }
  }
  else
  {
    uint64_t v9 = "nil";
LABEL_5:
    snprintf((char *)this, (size_t)a2, v9);
  }
}

size_t CI::snprintfcat(CI *this, char *a2, const char *a3, const char *a4, ...)
{
  va_start(va, a4);
  size_t result = strlen((const char *)this);
  if ((unint64_t)a2 > result) {
    return vsnprintf((char *)this + result, (size_t)&a2[-result], a3, va);
  }
  return result;
}

uint64_t CI::fprintf_cs(FILE *this, __sFILE *a2, CGColorSpace *a3)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  CI::snprintf_cs((CI *)v5, (char *)0x100, (CGColorSpace *)a2, a3);
  return fputs(v5, this);
}

CGColorSpace *CI::ColorSpace_is_RGB(CGColorSpace *this, CGColorSpace *a2)
{
  if (this)
  {
    float32x4_t v2 = this;
    CFTypeID v3 = CFGetTypeID(this);
    if (v3 == CGColorSpaceGetTypeID()) {
      return (CGColorSpace *)(CGColorSpaceGetModel(v2) == kCGColorSpaceModelRGB);
    }
    else {
      return 0;
    }
  }
  return this;
}

CGColorSpace *CI::ColorSpace_is_RGB_or_Gray(CGColorSpace *this, CGColorSpace *a2)
{
  if (this)
  {
    float32x4_t v2 = this;
    CFTypeID v3 = CFGetTypeID(this);
    if (v3 == CGColorSpaceGetTypeID()) {
      return (CGColorSpace *)(CGColorSpaceGetModel(v2) < kCGColorSpaceModelCMYK);
    }
    else {
      return 0;
    }
  }
  return this;
}

BOOL CI::ColorSpace_is_RGB_and_supports_output(BOOL this, CGColorSpace *a2)
{
  if (this)
  {
    float32x4_t v2 = (CGColorSpace *)this;
    CFTypeID v3 = CFGetTypeID((CFTypeRef)this);
    if (v3 == CGColorSpaceGetTypeID())
    {
      this = CGColorSpaceSupportsOutput(v2);
      if (this) {
        return CGColorSpaceGetModel(v2) == kCGColorSpaceModelRGB;
      }
    }
    else
    {
      return 0;
    }
  }
  return this;
}

CGColorSpace *CI::ColorSpaceCreateSDRCopy(CGColorSpace *this, CGColorSpace *a2)
{
  if (this)
  {
    float32x4_t v2 = this;
    if (CGColorSpaceIsHDR(this))
    {
      CFTypeID v3 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DBA0]);
      int v4 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DBA8]);
      float v5 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DB98]);
      uint64_t v6 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC68]);
      BOOL v7 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC60]);
      char v8 = CGColorSpaceEqualToColorSpace();
      char v9 = CGColorSpaceEqualToColorSpace();
      int v10 = CGColorSpaceEqualToColorSpace();
      int v11 = CGColorSpaceEqualToColorSpace();
      int v12 = CGColorSpaceEqualToColorSpace();
      CGColorSpaceRelease(v3);
      CGColorSpaceRelease(v4);
      CGColorSpaceRelease(v5);
      CGColorSpaceRelease(v6);
      CGColorSpaceRelease(v7);
      if ((v8 & 1) != 0 || (v9 & 1) != 0 || v10 || (v11 | v12) != 1) {
        uint64_t v13 = (const __CFString **)MEMORY[0x1E4F1DB90];
      }
      else {
        uint64_t v13 = (const __CFString **)MEMORY[0x1E4F1DC98];
      }
      CFStringRef v14 = *v13;
      return CGColorSpaceCreateWithName(v14);
    }
    else
    {
      return CGColorSpaceRetain(v2);
    }
  }
  return this;
}

CGColorSpace *CI::ColorSpaceCreatePQBasedCopy(CGColorSpace *this, CGColorSpace *a2)
{
  if (this)
  {
    float32x4_t v2 = this;
    if (CGColorSpaceIsPQBased(this))
    {
      return CGColorSpaceRetain(v2);
    }
    else
    {
      CFTypeID v3 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DB90]);
      int v4 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
      float v5 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC58]);
      int v6 = CGColorSpaceEqualToColorSpace();
      int v7 = CGColorSpaceEqualToColorSpace();
      int v8 = CGColorSpaceEqualToColorSpace();
      CGColorSpaceRelease(v3);
      CGColorSpaceRelease(v4);
      CGColorSpaceRelease(v5);
      if (v6)
      {
        char v9 = (const __CFString **)MEMORY[0x1E4F1DBA0];
      }
      else if ((v7 | v8) == 1)
      {
        char v9 = (const __CFString **)MEMORY[0x1E4F1DC68];
      }
      else
      {
        char v9 = (const __CFString **)MEMORY[0x1E4F1DC50];
      }
      CFStringRef v10 = *v9;
      return CGColorSpaceCreateWithName(v10);
    }
  }
  return this;
}

unsigned __int8 **ConvertYCbCrtoREDEYEFORMAT(unsigned __int8 **result, unsigned __int8 **a2, uint64_t a3, int a4)
{
  int v4 = *((_DWORD *)result + 2);
  int v5 = *((_DWORD *)a2 + 2);
  if (v4 != 2 * v5)
  {
    int v6 = "ConvertYCbCrtoREDEYEFORMAT: widths do not match";
    goto LABEL_7;
  }
  if (*((_DWORD *)result + 3) != 2 * *((_DWORD *)a2 + 3))
  {
    int v6 = "ConvertYCbCrtoREDEYEFORMAT: heights do not match";
    goto LABEL_7;
  }
  if (*((_DWORD *)result + 4) >= *((_DWORD *)result + 7) * v4)
  {
    int v7 = *((_DWORD *)a2 + 4);
    if (v7 < *((_DWORD *)a2 + 7) * v5)
    {
      int v6 = "ConvertYCbCrtoREDEYEFORMAT: rowSamples is too small for CbCr bitmap";
      goto LABEL_7;
    }
    if (*(int *)(a3 + 12) < 1) {
      return result;
    }
    int v8 = 0;
    char v9 = *a2;
    CFStringRef v10 = *(char **)a3;
    double v87 = *result;
    while (1)
    {
      if (v8)
      {
        int v11 = *((_DWORD *)result + 3) - 1;
      }
      else
      {
        int v11 = 0;
        int v7 = -v7;
      }
      if (v8 == v11) {
        int v7 = 0;
      }
      int v12 = &v9[v7];
      int v13 = *v9;
      int v14 = v9[1];
      int v15 = *v12;
      int v16 = v12[1];
      double v86 = v10;
      if (*((int *)result + 2) >= 3) {
        break;
      }
      int v23 = *v9;
      int v22 = v9[1];
      int v21 = *v12;
      int v20 = v12[1];
      double v53 = v87;
      double v19 = v10;
      float32x4_t v18 = v9;
LABEL_63:
      int v54 = *v53;
      unsigned int v55 = ((9 * v13 + v21 + 3 * (v15 + v23) + 8) >> 4) - 128;
      unsigned int v56 = ((9 * v14 + v20 + 3 * (v16 + v22) + 8) >> 4) - 128;
      int v57 = v54 + ((int)(22970 * v56 + 0x2000) >> 14);
      int v58 = v54 + ((int)(-11700 * v56 - 5638 * v55 + 0x2000) >> 14);
      int v59 = v54 + ((int)(29032 * v55 + 0x2000) >> 14);
      if (v57 >= 255) {
        int v60 = 255;
      }
      else {
        int v60 = v57;
      }
      int v61 = v60 & ~(v60 >> 31);
      if (v58 >= 255) {
        int v58 = 255;
      }
      int v62 = v58 & ~(v58 >> 31);
      if (v59 >= 255) {
        int v59 = 255;
      }
      int v63 = v59 & ~(v59 >> 31);
      if (a4) {
        char v64 = v61;
      }
      else {
        char v64 = -1;
      }
      if (a4) {
        char v65 = v62;
      }
      else {
        char v65 = v61;
      }
      if (a4) {
        char v66 = v63;
      }
      else {
        char v66 = v62;
      }
      if (a4) {
        char v67 = -1;
      }
      else {
        char v67 = v63;
      }
      if (a4 == 2)
      {
        char v64 = v63;
        char v65 = v62;
        char v66 = v61;
        char v67 = -1;
      }
      if (a4 == 3)
      {
        char v64 = -1;
      }
      else
      {
        LOBYTE(v63) = v65;
        LOBYTE(v62) = v66;
        LOBYTE(v61) = v67;
      }
      *double v19 = v64;
      v19[1] = v63;
      void v19[2] = v62;
      void v19[3] = v61;
      if (*(_DWORD *)(a3 + 8) == *((_DWORD *)result + 2))
      {
        int v68 = v53[1];
        double v69 = &v19[*(int *)(a3 + 28)];
        unsigned int v70 = ((9 * *v18 + *v12 + 3 * (*v12 + *v18) + 8) >> 4) - 128;
        unsigned int v71 = ((9 * v18[1] + v12[1] + 3 * (v12[1] + v18[1]) + 8) >> 4) - 128;
        int v72 = v68 + ((int)(22970 * v71 + 0x2000) >> 14);
        int v73 = v68 + ((int)(-5638 * v70 - 11700 * v71 + 0x2000) >> 14);
        int v74 = v68 + ((int)(29032 * v70 + 0x2000) >> 14);
        if (v72 >= 255) {
          int v75 = 255;
        }
        else {
          int v75 = v72;
        }
        int v76 = v75 & ~(v75 >> 31);
        if (v73 >= 255) {
          int v73 = 255;
        }
        int v77 = v73 & ~(v73 >> 31);
        if (v74 >= 255) {
          int v74 = 255;
        }
        int v78 = v74 & ~(v74 >> 31);
        if (a4) {
          char v79 = v76;
        }
        else {
          char v79 = -1;
        }
        if (a4) {
          char v80 = v77;
        }
        else {
          char v80 = v76;
        }
        if (a4) {
          char v81 = v78;
        }
        else {
          char v81 = v77;
        }
        if (a4) {
          char v82 = -1;
        }
        else {
          char v82 = v78;
        }
        if (a4 == 2)
        {
          char v79 = v78;
          char v80 = v77;
          char v81 = v76;
          char v82 = -1;
        }
        if (a4 == 3)
        {
          char v79 = -1;
        }
        else
        {
          LOBYTE(v7_Block_object_dispose(&STACK[0x238], 8) = v80;
          LOBYTE(v77) = v81;
        }
        *double v69 = v79;
        v69[1] = v78;
        if (a4 == 3) {
          char v83 = v76;
        }
        else {
          char v83 = v82;
        }
        v69[2] = v77;
        v69[3] = v83;
      }
      int v7 = *((_DWORD *)a2 + 4);
      v9 += v7 * (v8++ & 1);
      v87 += *((int *)result + 4);
      CFStringRef v10 = &v86[*(int *)(a3 + 16)];
      if (v8 >= *(_DWORD *)(a3 + 12)) {
        return result;
      }
    }
    int v85 = v8;
    uint64_t v17 = 0;
    double v84 = v9;
    float32x4_t v18 = v9;
    double v19 = v10;
    int v20 = v12[1];
    int v21 = *v12;
    int v22 = v9[1];
    int v23 = *v9;
    while (1)
    {
      int v24 = v87[v17];
      unsigned int v25 = (9 * v14 + v20 + 3 * (v16 + v22) + 8) >> 4;
      unsigned int v26 = ((9 * v13 + v21 + 3 * (v15 + v23) + 8) >> 4) - 128;
      unsigned int v27 = v25 - 128;
      int v28 = v24 + ((int)(-11700 * v27 - 5638 * v26 + 0x2000) >> 14);
      int v29 = v24 + ((int)(29032 * v26 + 0x2000) >> 14);
      char v30 = -1;
      if (v24 + ((int)(22970 * v27 + 0x2000) >> 14) >= 255) {
        int v31 = 255;
      }
      else {
        int v31 = v24 + ((int)(22970 * v27 + 0x2000) >> 14);
      }
      int v32 = v31 & ~(v31 >> 31);
      if (v28 >= 255) {
        int v33 = 255;
      }
      else {
        int v33 = v28;
      }
      int v34 = v33 & ~(v33 >> 31);
      if (v29 >= 255) {
        int v35 = 255;
      }
      else {
        int v35 = v29;
      }
      int v36 = v35 & ~(v35 >> 31);
      if (a4 == 3)
      {
        char v37 = v34;
        char v30 = v32;
        LOBYTE(v32) = -1;
        LOBYTE(v34) = v36;
      }
      else
      {
        if (a4 != 2)
        {
          if (!a4)
          {
            char v30 = v36;
            LOBYTE(v36) = v34;
            LOBYTE(v34) = v32;
            LOBYTE(v32) = -1;
          }
          goto LABEL_37;
        }
        char v37 = v32;
        LOBYTE(v32) = v36;
      }
      LOBYTE(v36) = v37;
LABEL_37:
      *double v19 = v32;
      v19[1] = v34;
      void v19[2] = v36;
      void v19[3] = v30;
      int v38 = v87[v17 + 1];
      int v23 = *v18;
      int v22 = v18[1];
      int v13 = v18[2];
      int v14 = v18[3];
      int v21 = *v12;
      int v20 = v12[1];
      int v15 = v12[2];
      int v16 = v12[3];
      float32x4_t v39 = &v19[*(int *)(a3 + 28)];
      unsigned int v40 = ((9 * v23 + v15 + 3 * (v21 + v13) + 8) >> 4) - 128;
      unsigned int v41 = ((9 * v22 + v16 + 3 * (v20 + v14) + 8) >> 4) - 128;
      int v42 = v38 + ((int)(22970 * v41 + 0x2000) >> 14);
      int v43 = v38 + ((int)(-11700 * v41 - 5638 * v40 + 0x2000) >> 14);
      int v44 = v38 + ((int)(29032 * v40 + 0x2000) >> 14);
      if (v42 >= 255) {
        int v42 = 255;
      }
      int v45 = v42 & ~(v42 >> 31);
      if (v43 >= 255) {
        int v43 = 255;
      }
      int v46 = v43 & ~(v43 >> 31);
      if (v44 >= 255) {
        int v44 = 255;
      }
      int v47 = v44 & ~(v44 >> 31);
      if (a4) {
        char v48 = v45;
      }
      else {
        char v48 = -1;
      }
      if (a4) {
        char v49 = v46;
      }
      else {
        char v49 = v45;
      }
      if (a4) {
        char v50 = v47;
      }
      else {
        char v50 = v46;
      }
      if (a4) {
        char v51 = -1;
      }
      else {
        char v51 = v47;
      }
      if (a4 == 2)
      {
        char v48 = v47;
        char v49 = v46;
        char v50 = v45;
        char v51 = -1;
      }
      if (a4 == 3)
      {
        char v48 = -1;
        char v49 = v47;
      }
      else
      {
        LOBYTE(v46) = v50;
        LOBYTE(v45) = v51;
      }
      *float32x4_t v39 = v48;
      v39[1] = v49;
      void v39[2] = v46;
      v39[3] = v45;
      uint64_t v52 = *((int *)a2 + 7);
      v18 += v52;
      v12 += v52;
      v19 += 2 * *(int *)(a3 + 28);
      v17 += 2;
      if ((int)v17 >= *((_DWORD *)result + 2) - 2)
      {
        double v53 = &v87[v17];
        int v8 = v85;
        char v9 = v84;
        goto LABEL_63;
      }
    }
  }
  int v6 = "ConvertYCbCrtoREDEYEFORMAT: rowSamples is too small for Y bitmap";
LABEL_7:
  return (unsigned __int8 **)puts(v6);
}

uint64_t ConvertREDEYEFORMATtoYCbCr(uint64_t result, uint64_t *a2, uint64_t *a3, int a4)
{
  uint64_t v73 = result;
  int v4 = *(_DWORD *)(result + 12);
  if (v4 >= 1)
  {
    int v5 = 0;
    int v6 = 0;
    int v7 = 0;
    int v8 = 0;
    int v9 = 0;
    int v10 = 0;
    int v11 = 0;
    int v12 = 0;
    int v13 = 0;
    int v14 = 0;
    int v15 = 0;
    int v16 = 0;
    uint64_t v17 = *a3;
    uint64_t v18 = *a2;
    double v19 = *(unsigned __int8 **)result;
    uint64_t v72 = *((int *)a3 + 7);
    uint64_t v55 = *((int *)a3 + 4);
    uint64_t v20 = *(int *)(result + 28);
    uint64_t v63 = v20 + 3;
    uint64_t v21 = *(int *)(result + 16);
    uint64_t v70 = v20 + 2;
    uint64_t v22 = *((int *)a2 + 7);
    uint64_t v61 = v20 + v21 + 3;
    uint64_t v23 = *((int *)a2 + 4);
    uint64_t v69 = (int)v20 + (int)v21 + 2;
    uint64_t v68 = (int)v20 + (int)v21 + 1;
    uint64_t v60 = (int)v20 + (int)v21;
    uint64_t v74 = v18 + v22;
    uint64_t v24 = v18 + v23;
    uint64_t v25 = v18;
    uint64_t v26 = v18 + v22 + v23;
    uint64_t v67 = v20 + 1;
    uint64_t v59 = v21 + 3;
    uint64_t v66 = v21 + 2;
    uint64_t v64 = v20;
    uint64_t v65 = v21 + 1;
    uint64_t v71 = 2 * v20;
    uint64_t v62 = v21;
    uint64_t v53 = 2 * v21;
    uint64_t v54 = 2 * v23;
    int v27 = *(_DWORD *)(result + 8);
    int v28 = (unsigned char *)(v17 + 1);
    do
    {
      if (v27 >= 1)
      {
        int v58 = v16;
        uint64_t v29 = 0;
        int v30 = 0;
        unsigned int v56 = v28;
        int v57 = v19;
        int v31 = v28;
        do
        {
          int v32 = a4;
          switch(a4)
          {
            case 0:
              int v33 = v19 + 1;
              int v34 = v19 + 2;
              int v35 = v19 + 3;
              uint64_t v36 = v66;
              uint64_t v37 = v67;
              uint64_t v39 = v69;
              uint64_t v38 = v70;
              uint64_t v40 = v63;
              uint64_t v41 = v65;
              uint64_t v42 = v59;
              uint64_t v43 = v68;
              uint64_t v44 = v61;
              goto LABEL_10;
            case 1:
              int v34 = v19 + 1;
              int v35 = v19 + 2;
              uint64_t v37 = v64;
              uint64_t v36 = v65;
              uint64_t v42 = v66;
              uint64_t v38 = v67;
              uint64_t v44 = v69;
              uint64_t v40 = v70;
              uint64_t v41 = v62;
              uint64_t v43 = v60;
              uint64_t v39 = v68;
              int v33 = v19;
              goto LABEL_10;
            case 2:
              int v33 = v19 + 2;
              int v34 = v19 + 1;
              int v35 = v19;
              uint64_t v43 = v69;
              uint64_t v37 = v70;
              uint64_t v41 = v66;
              uint64_t v38 = v67;
              uint64_t v40 = v64;
              uint64_t v36 = v65;
              uint64_t v42 = v62;
              uint64_t v39 = v68;
              uint64_t v44 = v60;
              goto LABEL_10;
            case 3:
              int v33 = v19 + 3;
              int v34 = v19 + 2;
              int v35 = v19 + 1;
              uint64_t v37 = v63;
              uint64_t v39 = v69;
              uint64_t v38 = v70;
              uint64_t v36 = v66;
              uint64_t v40 = v67;
              uint64_t v41 = v59;
              uint64_t v42 = v65;
              uint64_t v43 = v61;
              uint64_t v44 = v68;
LABEL_10:
              int v32 = *v34;
              int v15 = *v33;
              int v14 = *v35;
              int v13 = v19[v37];
              int v12 = v19[v38];
              int v11 = v19[v40];
              int v10 = v19[v41];
              int v9 = v19[v36];
              int v8 = v19[v42];
              int v7 = v19[v43];
              int v6 = v19[v39];
              int v5 = v19[v44];
              break;
            default:
              break;
          }
          unsigned int v45 = (v15 + v13 + v10 + v7 + 2) >> 2;
          unsigned int v46 = (v32 + v12 + v9 + v6 + 2) >> 2;
          int v47 = -5427 * v46 - 2765 * v45;
          int v48 = -6860 * v46 + (v45 << 13);
          unsigned int v49 = (v14 + v11 + v8 + v5 + 2) >> 2;
          unsigned int v50 = v48 - 1332 * v49;
          *(unsigned char *)(v25 + v29) = (9617 * v32 + 4899 * v15 + 1868 * v14 + 0x2000) >> 14;
          *(unsigned char *)(v74 + v29) = (9617 * v12 + 4899 * v13 + 1868 * v11 + 0x2000) >> 14;
          *(unsigned char *)(v24 + v29) = (9617 * v9 + 4899 * v10 + 1868 * v8 + 0x2000) >> 14;
          *(unsigned char *)(v26 + v29) = (9617 * v6 + 4899 * v7 + 1868 * v5 + 0x2000) >> 14;
          int v51 = (int)(v47 + (v49 << 13) + 0x2000) >> 14;
          if (v51 >= 127) {
            LOBYTE(v51) = 127;
          }
          *(v31 - 1) = v51 ^ 0x80;
          int v52 = (int)(v50 + 0x2000) >> 14;
          if (v52 >= 127) {
            LOBYTE(v52) = 127;
          }
          *int v31 = v52 ^ 0x80;
          v30 += 2;
          v19 += v71;
          int v27 = *(_DWORD *)(v73 + 8);
          v31 += v72;
          v29 += 2 * v22;
        }
        while (v30 < v27);
        int v4 = *(_DWORD *)(v73 + 12);
        int v16 = v58;
        int v28 = v56;
        double v19 = v57;
      }
      v16 += 2;
      size_t result = v54;
      v19 += v53;
      v25 += v54;
      v28 += v55;
      v74 += v54;
      v24 += v54;
      v26 += v54;
    }
    while (v16 < v4);
  }
  return result;
}

unsigned __int8 **ConvertRedChannel2toY(unsigned __int8 **result, unsigned __int8 **a2, uint64_t a3)
{
  int v3 = *((_DWORD *)result + 2);
  int v4 = *((_DWORD *)a2 + 2);
  if (v3 != 2 * v4)
  {
    int v6 = "ConvertRedChannel2toY: widths do not match";
    goto LABEL_7;
  }
  int v5 = *((_DWORD *)result + 3);
  if (v5 != 2 * *((_DWORD *)a2 + 3))
  {
    int v6 = "ConvertRedChannel2toY: heights do not match";
    goto LABEL_7;
  }
  if (*((_DWORD *)result + 4) < *((_DWORD *)result + 7) * v3)
  {
    int v6 = "ConvertRedChannel2toY: rowSamples is too small for Y bitmap";
LABEL_7:
    return (unsigned __int8 **)puts(v6);
  }
  int v7 = *((_DWORD *)a2 + 4);
  if (v7 < *((_DWORD *)a2 + 7) * v4)
  {
    int v6 = "ConvertRedChannel2toY: rowSamples is too small for CbCr bitmap";
    goto LABEL_7;
  }
  if (*(_DWORD *)(a3 + 16) < *(_DWORD *)(a3 + 28) * *(_DWORD *)(a3 + 8))
  {
    int v6 = "ConvertRedChannel2toY: rowSamples is too small for ARGB bitmap";
    goto LABEL_7;
  }
  if (v5 >= 1)
  {
    int v8 = 0;
    int v9 = *a2;
    int v10 = *(unsigned char **)a3;
    int v11 = *result;
    do
    {
      int v12 = v8 & 1;
      if ((v8 & 1) == 0) {
        int v7 = -v7;
      }
      if (v8 == ((v8 << 31 >> 31) & (v5 - 1))) {
        int v7 = 0;
      }
      int v13 = &v9[v7];
      int v14 = *v9;
      int v15 = v9[1];
      int v16 = *v13;
      int v17 = v13[1];
      if (*((int *)result + 2) < 3)
      {
        int v24 = *v9;
        int v23 = v9[1];
        int v22 = *v13;
        int v21 = v13[1];
        uint64_t v44 = v11;
        uint64_t v20 = v10;
        double v19 = v9;
      }
      else
      {
        uint64_t v18 = 0;
        double v19 = v9;
        uint64_t v20 = v10;
        int v21 = v13[1];
        int v22 = *v13;
        int v23 = v9[1];
        int v24 = *v9;
        do
        {
          int v25 = v11[v18];
          unsigned int v26 = (9 * v15 + v21 + 3 * (v17 + v23) + 8) >> 4;
          unsigned int v27 = ((9 * v14 + v22 + 3 * (v16 + v24) + 8) >> 4) - 128;
          v26 -= 128;
          int v28 = v25 + ((int)(22970 * v26 + 0x2000) >> 14);
          int v29 = v25 + ((int)(-11700 * v26 - 5638 * v27 + 0x2000) >> 14);
          int v30 = v25 + ((int)(29032 * v27 + 0x2000) >> 14);
          if (v28 >= 255) {
            int v28 = 255;
          }
          int v31 = v28 & ~(v28 >> 31);
          if (v29 >= 255) {
            int v29 = 255;
          }
          int v32 = v29 & ~(v29 >> 31);
          if (v30 >= 255) {
            int v30 = 255;
          }
          int v33 = v31 - (((v30 & ~(v30 >> 31)) + v32 + 1) >> 1);
          *uint64_t v20 = v33 & ~(v33 >> 31);
          int v34 = v11[v18 + 1];
          int v24 = *v19;
          int v23 = v19[1];
          int v14 = v19[2];
          int v15 = v19[3];
          int v22 = *v13;
          int v21 = v13[1];
          int v16 = v13[2];
          int v17 = v13[3];
          unsigned int v35 = ((9 * v24 + v16 + 3 * (v22 + v14) + 8) >> 4) - 128;
          unsigned int v36 = ((9 * v23 + v17 + 3 * (v21 + v15) + 8) >> 4) - 128;
          int v37 = v34 + ((int)(22970 * v36 + 0x2000) >> 14);
          int v38 = v34 + ((int)(-11700 * v36 - 5638 * v35 + 0x2000) >> 14);
          int v39 = v34 + ((int)(29032 * v35 + 0x2000) >> 14);
          if (v37 >= 255) {
            int v40 = 255;
          }
          else {
            int v40 = v37;
          }
          int v41 = v40 & ~(v40 >> 31);
          if (v38 >= 255) {
            int v38 = 255;
          }
          int v42 = v38 & ~(v38 >> 31);
          if (v39 >= 255) {
            int v39 = 255;
          }
          v20[1] = (v41 - (((v39 & ~(v39 >> 31)) + v42 + 1) >> 1)) & ~((int)(v41 - (((v39 & ~(v39 >> 31)) + v42 + 1) >> 1)) >> 31);
          uint64_t v43 = *((int *)a2 + 7);
          v19 += v43;
          v13 += v43;
          v20 += 2 * *(int *)(a3 + 28);
          v18 += 2;
        }
        while ((int)v18 < *((_DWORD *)result + 2) - 2);
        uint64_t v44 = &v11[v18];
        int v12 = v8 & 1;
      }
      int v45 = *v44;
      unsigned int v46 = (9 * v15 + v21 + 3 * (v17 + v23) + 8) >> 4;
      unsigned int v47 = ((9 * v14 + v22 + 3 * (v16 + v24) + 8) >> 4) - 128;
      v46 -= 128;
      int v48 = v45 + ((int)(22970 * v46 + 0x2000) >> 14);
      int v49 = v45 + ((int)(-11700 * v46 - 5638 * v47 + 0x2000) >> 14);
      int v50 = v45 + ((int)(29032 * v47 + 0x2000) >> 14);
      if (v48 >= 255) {
        int v51 = 255;
      }
      else {
        int v51 = v48;
      }
      int v52 = v51 & ~(v51 >> 31);
      if (v49 >= 255) {
        int v49 = 255;
      }
      int v53 = v49 & ~(v49 >> 31);
      if (v50 >= 255) {
        int v50 = 255;
      }
      int v54 = v52 - (((v50 & ~(v50 >> 31)) + v53 + 1) >> 1);
      *uint64_t v20 = v54 & ~(v54 >> 31);
      int v55 = v44[1];
      unsigned int v56 = (9 * *v19 + *v13 + 3 * (*v13 + *v19) + 8) >> 4;
      unsigned int v57 = (9 * v19[1] + v13[1] + 3 * (v13[1] + v19[1]) + 8) >> 4;
      unsigned int v58 = v56 - 128;
      v57 -= 128;
      int v59 = v55 + ((int)(22970 * v57 + 0x2000) >> 14);
      int v60 = v55 + ((int)(-11700 * v57 - 5638 * v58 + 0x2000) >> 14);
      int v61 = v55 + ((int)(29032 * v58 + 0x2000) >> 14);
      if (v59 >= 255) {
        int v62 = 255;
      }
      else {
        int v62 = v59;
      }
      int v63 = v62 & ~(v62 >> 31);
      if (v60 >= 255) {
        int v60 = 255;
      }
      int v64 = v60 & ~(v60 >> 31);
      if (v61 >= 255) {
        int v61 = 255;
      }
      int v65 = v63 - (((v61 & ~(v61 >> 31)) + v64 + 1) >> 1);
      v20[1] = v65 & ~(v65 >> 31);
      int v7 = *((_DWORD *)a2 + 4);
      v9 += v7 * v12;
      ++v8;
      int v5 = *((_DWORD *)result + 3);
      v11 += *((int *)result + 4);
      v10 += *(int *)(a3 + 16);
    }
    while (v8 < v5);
  }
  return result;
}

unsigned __int8 **ConvertRedChannel5toY(unsigned __int8 **result, unsigned __int8 **a2, uint64_t a3)
{
  int v3 = *((_DWORD *)result + 2);
  int v4 = *((_DWORD *)a2 + 2);
  if (v3 != 2 * v4)
  {
    int v6 = "ConvertRedChannel5toY: widths do not match";
    goto LABEL_7;
  }
  int v5 = *((_DWORD *)result + 3);
  if (v5 != 2 * *((_DWORD *)a2 + 3))
  {
    int v6 = "ConvertRedChannel5toY: heights do not match";
    goto LABEL_7;
  }
  if (*((_DWORD *)result + 4) < *((_DWORD *)result + 7) * v3)
  {
    int v6 = "ConvertRedChannel5toY: rowSamples is too small for Y bitmap";
LABEL_7:
    return (unsigned __int8 **)puts(v6);
  }
  int v7 = *((_DWORD *)a2 + 4);
  if (v7 < *((_DWORD *)a2 + 7) * v4)
  {
    int v6 = "ConvertRedChannel5toY: rowSamples is too small for CbCr bitmap";
    goto LABEL_7;
  }
  if (*(_DWORD *)(a3 + 16) < *(_DWORD *)(a3 + 28) * *(_DWORD *)(a3 + 8))
  {
    int v6 = "ConvertRedChannel5toY: rowSamples is too small for ARGB bitmap";
    goto LABEL_7;
  }
  if (v5 >= 1)
  {
    int v8 = 0;
    int v9 = *a2;
    int v10 = *(unsigned char **)a3;
    int v11 = *result;
    do
    {
      int v12 = v8 & 1;
      if ((v8 & 1) == 0) {
        int v7 = -v7;
      }
      if (v8 == ((v8 << 31 >> 31) & (v5 - 1))) {
        int v7 = 0;
      }
      int v13 = &v9[v7];
      int v14 = *v9;
      int v15 = v9[1];
      int v16 = *v13;
      int v17 = v13[1];
      if (*((int *)result + 2) < 3)
      {
        int v24 = *v9;
        int v23 = v9[1];
        int v22 = *v13;
        int v21 = v13[1];
        int v38 = v11;
        uint64_t v20 = v10;
        double v19 = v9;
      }
      else
      {
        uint64_t v18 = 0;
        double v19 = v9;
        int v53 = v10;
        uint64_t v20 = v10;
        int v21 = v13[1];
        int v22 = *v13;
        int v23 = v9[1];
        int v24 = *v9;
        do
        {
          int v25 = v11[v18];
          unsigned int v26 = ((9 * v15 + v21 + 3 * (v17 + v23) + 8) >> 4) - 128;
          int v27 = v25 + ((int)(22970 * v26 + 0x2000) >> 14);
          int v28 = v25
              + ((int)(-5638 * ((9 * v14 + v22 + 3 * (v16 + v24) + 8) >> 4) + 729856 - 11700 * v26) >> 14);
          if (v27 >= 255) {
            int v27 = 255;
          }
          int v29 = v27 & ~(v27 >> 31);
          if (v28 >= 255) {
            int v28 = 255;
          }
          int v30 = v29 - ((v28 & ~(v28 >> 31)) + ((v29 * (v28 & ~(v28 >> 31)) + 128) >> 8));
          *uint64_t v20 = v30 & ~(v30 >> 31);
          int v31 = v11[v18 + 1];
          int v24 = *v19;
          int v23 = v19[1];
          int v14 = v19[2];
          int v15 = v19[3];
          int v22 = *v13;
          int v21 = v13[1];
          int v16 = v13[2];
          int v17 = v13[3];
          unsigned int v32 = ((9 * v23 + v17 + 3 * (v21 + v15) + 8) >> 4) - 128;
          int v33 = v31 + ((int)(22970 * v32 + 0x2000) >> 14);
          int v34 = v31
              + ((int)(-5638 * ((9 * v24 + v16 + 3 * (v22 + v14) + 8) >> 4) + 729856 - 11700 * v32) >> 14);
          if (v33 >= 255) {
            int v35 = 255;
          }
          else {
            int v35 = v33;
          }
          int v36 = v35 & ~(v35 >> 31);
          if (v34 >= 255) {
            int v34 = 255;
          }
          v20[1] = (v36
                  - ((v34 & ~(v34 >> 31))
                   + ((unsigned __int16)(v36 * (v34 & ~(unsigned __int16)(v34 >> 31)) + 128) >> 8))) & ~((int)(v36 - ((v34 & ~(v34 >> 31)) + ((v36 * (v34 & ~(v34 >> 31)) + 128) >> 8))) >> 31);
          uint64_t v37 = *((int *)a2 + 7);
          v19 += v37;
          v13 += v37;
          v20 += 2 * *(int *)(a3 + 28);
          v18 += 2;
        }
        while ((int)v18 < *((_DWORD *)result + 2) - 2);
        int v38 = &v11[v18];
        int v10 = v53;
        int v12 = v8 & 1;
      }
      int v39 = *v38;
      unsigned int v40 = ((9 * v15 + v21 + 3 * (v17 + v23) + 8) >> 4) - 128;
      int v41 = v39 + ((int)(22970 * v40 + 0x2000) >> 14);
      int v42 = v39
          + ((int)(-5638 * ((9 * v14 + v22 + 3 * (v16 + v24) + 8) >> 4) + 729856 - 11700 * v40) >> 14);
      if (v41 >= 255) {
        int v43 = 255;
      }
      else {
        int v43 = v41;
      }
      int v44 = v43 & ~(v43 >> 31);
      if (v42 >= 255) {
        int v42 = 255;
      }
      int v45 = v44 - ((v42 & ~(v42 >> 31)) + ((v44 * (v42 & ~(v42 >> 31)) + 128) >> 8));
      *uint64_t v20 = v45 & ~(v45 >> 31);
      int v46 = v38[1];
      unsigned int v47 = (9 * *v19 + *v13 + 3 * (*v13 + *v19) + 8) >> 4;
      unsigned int v48 = ((9 * v19[1] + v13[1] + 3 * (v13[1] + v19[1]) + 8) >> 4) - 128;
      int v49 = v46 + ((int)(22970 * v48 + 0x2000) >> 14);
      int v50 = v46 + ((int)(-5638 * v47 + 729856 - 11700 * v48) >> 14);
      if (v49 >= 255) {
        int v51 = 255;
      }
      else {
        int v51 = v49;
      }
      int v52 = v51 & ~(v51 >> 31);
      if (v50 >= 255) {
        int v50 = 255;
      }
      v20[1] = (v52
              - ((v50 & ~(v50 >> 31))
               + ((unsigned __int16)(v52 * (v50 & ~(unsigned __int16)(v50 >> 31)) + 128) >> 8))) & ~((int)(v52 - ((v50 & ~(v50 >> 31)) + ((v52 * (v50 & ~(v50 >> 31)) + 128) >> 8))) >> 31);
      int v7 = *((_DWORD *)a2 + 4);
      v9 += v7 * v12;
      ++v8;
      int v5 = *((_DWORD *)result + 3);
      v11 += *((int *)result + 4);
      v10 += *(int *)(a3 + 16);
    }
    while (v8 < v5);
  }
  return result;
}

void CI::Perspective::EDLinesCPU::EDLinesCPU(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(_OWORD *)(a1 + 8_Block_object_dispose(&STACK[0x238], 8) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  int v6 = &CI::Perspective::EDLinesParamsDefault;
  *(_OWORD *)(a1 + 136) = 0u;
  *(void *)(a1 + 152) = 0;
  if (a6) {
    int v6 = a6;
  }
  *(void *)a1 = &unk_1EE457CB0;
  *(void *)(a1 + _Block_object_dispose(&STACK[0x238], 8) = v6;
  *(void *)(a1 + 16) = a2;
  *(void *)(a1 + 24) = a3;
  *(void *)(a1 + 32) = a4;
  *(void *)(a1 + 40) = a5;
  CI::Perspective::EDLinesCPU::createGradMap((CI::Perspective::EDLinesCPU *)a1);
}

void sub_19388151C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  int v6 = (void *)v2[17];
  if (v6)
  {
    v2[18] = v6;
    operator delete(v6);
  }
  std::vector<std::vector<IRect>>::__destroy_vector::operator()[abi:nn180100]((void ***)va);
  int v7 = *v4;
  if (*v4)
  {
    v2[12] = v7;
    operator delete(v7);
  }
  int v8 = *v3;
  if (*v3)
  {
    v2[8] = v8;
    operator delete(v8);
  }
  _Unwind_Resume(a1);
}

void CI::Perspective::EDLinesCPU::createGradMap(CI::Perspective::EDLinesCPU *this)
{
}

void sub_1938816FC(_Unwind_Exception *a1)
{
}

void CI::Perspective::EDLinesCPU::sparseAnchors(CI::Perspective::EDLinesCPU *this)
{
  float32x4_t v2 = (float *)*((void *)this + 1);
  float v3 = v2[1];
  unint64_t v61 = *(unsigned __int16 *)v2;
  int v4 = (char **)((char *)this + 56);
  std::vector<EDAnchor>::reserve((void **)this + 7, (*(void *)(*((void *)this + 6) + 8) / v61 * (**((void **)this + 6) / v61)) >> 1);
  int v5 = (uint64_t *)*((void *)this + 6);
  if ((unint64_t)(v5[1] - 3) < 0xFFFFFFFFFFFFFFFELL)
  {
    uint64_t v6 = *v5;
    uint64_t v7 = 1;
    int v8 = 1;
    while ((unint64_t)(v6 - 3) > 0xFFFFFFFFFFFFFFFDLL)
    {
LABEL_38:
      v8 += v61;
      uint64_t v7 = v8;
      if (v5[1] - 1 <= (unint64_t)v8) {
        goto LABEL_41;
      }
    }
    uint64_t v9 = 1;
    while (1)
    {
      uint64_t v11 = v5[2];
      uint64_t v10 = v5[3];
      uint64_t v12 = v10 + v11 * v7;
      float v13 = *(float *)(v12 + 4 * v9);
      float v14 = -v13;
      if (v13 >= 0.0) {
        float v14 = *(float *)(v12 + 4 * v9);
      }
      if (v14 >= 0.001)
      {
        if (v13 <= 0.0)
        {
          float v17 = *(float *)(v12 + 4 * v9 - 4);
          if (v17 < 0.0) {
            float v17 = -v17;
          }
          if ((float)(v14 - v17) >= v3)
          {
            float v16 = *(float *)(v12 + 4 * (v9 + 1));
LABEL_17:
            if (v16 < 0.0) {
              float v16 = -v16;
            }
            if ((float)(v14 - v16) >= v3)
            {
              int v18 = (unsigned __int16)v9 | (v8 << 16);
              uint64_t v20 = (int *)*((void *)this + 8);
              unint64_t v19 = *((void *)this + 9);
              if ((unint64_t)v20 >= v19)
              {
                uint64_t v22 = ((char *)v20 - *v4) >> 2;
                if ((unint64_t)(v22 + 1) >> 62) {
LABEL_87:
                }
                  abort();
                uint64_t v23 = v19 - (void)*v4;
                uint64_t v24 = v23 >> 1;
                if (v23 >> 1 <= (unint64_t)(v22 + 1)) {
                  uint64_t v24 = v22 + 1;
                }
                if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFFCLL) {
                  unint64_t v25 = 0x3FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v25 = v24;
                }
                if (v25) {
                  unsigned int v26 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)this + 72, v25);
                }
                else {
                  unsigned int v26 = 0;
                }
                int v27 = (int *)&v26[4 * v22];
                *int v27 = v18;
                int v21 = v27 + 1;
                int v29 = (char *)*((void *)this + 7);
                int v28 = (char *)*((void *)this + 8);
                if (v28 != v29)
                {
                  do
                  {
                    int v30 = *((_DWORD *)v28 - 1);
                    v28 -= 4;
                    *--int v27 = v30;
                  }
                  while (v28 != v29);
                  int v28 = *v4;
                }
                *((void *)this + 7) = v27;
                *((void *)this + _Block_object_dispose(&STACK[0x238], 8) = v21;
                *((void *)this + 9) = &v26[4 * v25];
                if (v28) {
                  operator delete(v28);
                }
              }
              else
              {
                *uint64_t v20 = v18;
                int v21 = v20 + 1;
              }
              *((void *)this + _Block_object_dispose(&STACK[0x238], 8) = v21;
              int v5 = (uint64_t *)*((void *)this + 6);
              uint64_t v6 = *v5;
            }
          }
        }
        else
        {
          float v15 = *(float *)(v10 + v11 * (v8 - 1) + 4 * v9);
          if (v15 < 0.0) {
            float v15 = -v15;
          }
          if ((float)(v14 - v15) >= v3)
          {
            float v16 = *(float *)(v10 + v11 * (v8 + 1) + 4 * v9);
            goto LABEL_17;
          }
        }
      }
      if (v6 - 1 <= (unint64_t)++v9) {
        goto LABEL_38;
      }
    }
  }
  uint64_t v6 = *v5;
LABEL_41:
  if ((unint64_t)(v6 - 3) > 0xFFFFFFFFFFFFFFFDLL) {
    goto LABEL_80;
  }
  uint64_t v31 = 1;
  int v32 = 1;
  do
  {
    if ((unint64_t)(v5[1] - 3) > 0xFFFFFFFFFFFFFFFDLL) {
      goto LABEL_79;
    }
    uint64_t v33 = 1;
    do
    {
      uint64_t v35 = v5[2];
      uint64_t v34 = v5[3];
      uint64_t v36 = v34 + v35 * v33;
      float v37 = *(float *)(v36 + 4 * v31);
      float v38 = -v37;
      if (v37 >= 0.0) {
        float v38 = *(float *)(v36 + 4 * v31);
      }
      if (v38 >= 0.001)
      {
        if (v37 <= 0.0)
        {
          float v41 = *(float *)(v36 + 4 * (v32 - 1));
          if (v41 < 0.0) {
            float v41 = -v41;
          }
          if ((float)(v38 - v41) < v3) {
            goto LABEL_48;
          }
          float v40 = *(float *)(v36 + 4 * (v32 + 1));
        }
        else
        {
          float v39 = *(float *)(v34 + v35 * (v33 - 1) + 4 * v31);
          if (v39 < 0.0) {
            float v39 = -v39;
          }
          if ((float)(v38 - v39) < v3) {
            goto LABEL_48;
          }
          float v40 = *(float *)(v34 + v35 * (v33 + 1) + 4 * v31);
        }
        if (v40 < 0.0) {
          float v40 = -v40;
        }
        if ((float)(v38 - v40) >= v3)
        {
          int v42 = (unsigned __int16)v32 | (v33 << 16);
          int v44 = (int *)*((void *)this + 8);
          unint64_t v43 = *((void *)this + 9);
          if ((unint64_t)v44 >= v43)
          {
            uint64_t v46 = ((char *)v44 - *v4) >> 2;
            if ((unint64_t)(v46 + 1) >> 62) {
              goto LABEL_87;
            }
            uint64_t v47 = v43 - (void)*v4;
            uint64_t v48 = v47 >> 1;
            if (v47 >> 1 <= (unint64_t)(v46 + 1)) {
              uint64_t v48 = v46 + 1;
            }
            if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v49 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v49 = v48;
            }
            if (v49) {
              int v50 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)this + 72, v49);
            }
            else {
              int v50 = 0;
            }
            int v51 = (int *)&v50[4 * v46];
            *int v51 = v42;
            int v45 = v51 + 1;
            int v53 = (char *)*((void *)this + 7);
            int v52 = (char *)*((void *)this + 8);
            if (v52 != v53)
            {
              do
              {
                int v54 = *((_DWORD *)v52 - 1);
                v52 -= 4;
                *--int v51 = v54;
              }
              while (v52 != v53);
              int v52 = *v4;
            }
            *((void *)this + 7) = v51;
            *((void *)this + _Block_object_dispose(&STACK[0x238], 8) = v45;
            *((void *)this + 9) = &v50[4 * v49];
            if (v52) {
              operator delete(v52);
            }
          }
          else
          {
            *int v44 = v42;
            int v45 = v44 + 1;
          }
          *((void *)this + _Block_object_dispose(&STACK[0x238], 8) = v45;
          int v5 = (uint64_t *)*((void *)this + 6);
        }
      }
LABEL_48:
      ++v33;
    }
    while (v5[1] - 1 > (unint64_t)v33);
    uint64_t v6 = *v5;
LABEL_79:
    v32 += v61;
    uint64_t v31 = v32;
  }
  while (v6 - 1 > (unint64_t)v32);
LABEL_80:
  if (EDLines_Debug(void)::token != -1) {
    dispatch_once(&EDLines_Debug(void)::token, &__block_literal_global_71);
  }
  if (EDLines_Debug(void)::v)
  {
    int v55 = (CI::Perspective *)(*(uint64_t (**)(CI::Perspective::EDLinesCPU *))(*(void *)this + 24))(this);
    uint64_t v57 = *MEMORY[0x1E4F1DB20];
    uint64_t v58 = *(void *)(MEMORY[0x1E4F1DB20] + 8);
    uint64_t v59 = *(void *)(MEMORY[0x1E4F1DB20] + 16);
    uint64_t v60 = *(void *)(MEMORY[0x1E4F1DB20] + 24);
    CI::Perspective::CIImageToFile(v55, (CIImage *)@"/tmp/ED_anchors.png", v56, *(CGRect *)&v57);
  }
}

void CI::Perspective::EDLinesCPU::edgeDrawing(CI::Perspective::EDLinesCPU *this)
{
}

void sub_1938822DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  if (a16) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void CI::Perspective::EDLinesCPU::extractLines(CI::Perspective::EDLinesCPU *this)
{
  uint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *(void *)(v2 + 16);
  float v4 = *(float *)(v2 + 24);
  uint64_t v67 = (void *)((char *)this + 112);
  std::vector<std::vector<CI::Perspective::LSR<EDAnchor>>>::reserve((void *)this + 14, (uint64_t)(*((void *)this + 12) - *((void *)this + 11)) >> 4);
  uint64_t v5 = *((void *)this + 11);
  for (uint64_t i = *((void *)this + 12); v5 != i; v5 += 16)
  {
    __p[0] = 0;
    __p[1] = 0;
    *(void *)&long long v70 = 0;
    std::vector<std::vector<CI::Perspective::LSR<EDAnchor>>>::emplace_back<std::vector<CI::Perspective::LSR<EDAnchor>>>(v67, (uint64_t)__p);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (v3 < *(unsigned __int16 *)(v5 + 8))
    {
      unint64_t v6 = 0;
      uint64_t v7 = *((void *)this + 15);
      do
      {
        CI::Perspective::LSRInit<EDAnchor>(*(void *)v5 + 4 * v6, v3, (uint64_t)__p);
        v6 += v3;
        unint64_t v10 = *(unsigned __int16 *)(v5 + 8);
        float v11 = *((float *)&v74 + 1);
        if (v6 < v10 && *((float *)&v74 + 1) <= v4)
        {
          float v13 = (char *)__p[1];
          float v14 = *((float *)&v70 + 1);
          LODWORD(v15) = v70;
          float v16 = *((float *)&v70 + 3);
          float v17 = *((float *)&v70 + 2);
          float v18 = *((float *)&v71 + 1);
          LODWORD(v19) = v71;
          float v20 = *((float *)&v71 + 3);
          float v21 = *((float *)&v71 + 2);
          float v22 = *(float *)&v72;
          uint64_t v23 = (char *)__p[0] + 4 * (uint64_t)__p[1] + 2;
          do
          {
            LOWORD(v_Block_object_dispose(&STACK[0x238], 8) = *(v23 - 1);
            float v24 = (float)LODWORD(v8);
            LOWORD(v9) = *v23;
            float v9 = (float)LODWORD(v9);
            float v15 = v15 + v24;
            float v14 = v14 + v9;
            float v17 = v17 + (float)(v24 * v24);
            float v16 = v16 + (float)(v9 * v9);
            float v19 = v19 + (float)(v24 * v9);
            if (v18 >= v24) {
              float v18 = v24;
            }
            if (v21 <= v24) {
              float v21 = v24;
            }
            if (v20 >= v9) {
              float v20 = v9;
            }
            if (v22 <= v9) {
              float v22 = v9;
            }
            float v25 = v11 * (float)(unint64_t)v13;
            float v26 = v25
                + (float)((float)((float)((float)(*(float *)&v74 + (float)(*((float *)&v73 + 3) * v9))
                                        / *((float *)&v73 + 2))
                                + v24)
                        * (float)((float)((float)(*(float *)&v74 + (float)(*((float *)&v73 + 3) * v9))
                                        / *((float *)&v73 + 2))
                                + v24));
            float v27 = v25
                + (float)((float)((float)((float)(*(float *)&v74 + (float)(*((float *)&v73 + 2) * v24))
                                        / *((float *)&v73 + 3))
                                + v9)
                        * (float)((float)((float)(*(float *)&v74 + (float)(*((float *)&v73 + 2) * v24))
                                        / *((float *)&v73 + 3))
                                + v9));
            if ((float)(v21 - v18) <= (float)(v22 - v20)) {
              float v27 = v26;
            }
            float v8 = (float)(unint64_t)++v13;
            float v11 = v27 / (float)(unint64_t)v13;
            if (++v6 >= v10) {
              break;
            }
            v23 += 2;
          }
          while (v11 <= v4);
          __p[1] = v13;
          *(void *)&long long v70 = __PAIR64__(LODWORD(v14), LODWORD(v15));
          *((void *)&v70 + 1) = __PAIR64__(LODWORD(v16), LODWORD(v17));
          *(void *)&long long v71 = __PAIR64__(LODWORD(v18), LODWORD(v19));
          *((void *)&v71 + 1) = __PAIR64__(LODWORD(v20), LODWORD(v21));
          *(float *)&long long v72 = v22;
        }
        *((float *)&v74 + 1) = v11;
        CI::Perspective::LSRUpdateFit<EDAnchor>((uint64_t)__p);
        unint64_t v28 = *(void *)(v7 - 16);
        unint64_t v29 = *(void *)(v7 - 8);
        if (v28 >= v29)
        {
          uint64_t v31 = *(void *)(v7 - 24);
          uint64_t v32 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v28 - v31) >> 3);
          unint64_t v33 = v32 + 1;
          if ((unint64_t)(v32 + 1) > 0x2E8BA2E8BA2E8BALL) {
            abort();
          }
          unint64_t v34 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v29 - v31) >> 3);
          if (2 * v34 > v33) {
            unint64_t v33 = 2 * v34;
          }
          if (v34 >= 0x1745D1745D1745DLL) {
            unint64_t v35 = 0x2E8BA2E8BA2E8BALL;
          }
          else {
            unint64_t v35 = v33;
          }
          if (v35) {
            uint64_t v36 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::Perspective::LSR<EDAnchor>>>(v7 - 8, v35);
          }
          else {
            uint64_t v36 = 0;
          }
          float v37 = &v36[88 * v32];
          *(_OWORD *)float v37 = *(_OWORD *)__p;
          *((_OWORD *)v37 + 1) = v70;
          *((void *)v37 + 10) = v74;
          *((_OWORD *)v37 + 4) = v73;
          *((_OWORD *)v37 + 3) = v72;
          *((_OWORD *)v37 + 2) = v71;
          float v39 = *(char **)(v7 - 24);
          float v38 = *(char **)(v7 - 16);
          float v40 = v37;
          if (v38 != v39)
          {
            do
            {
              long long v41 = *(_OWORD *)(v38 - 88);
              *(_OWORD *)(v40 - 72) = *(_OWORD *)(v38 - 72);
              *(_OWORD *)(v40 - 8_Block_object_dispose(&STACK[0x238], 8) = v41;
              long long v42 = *(_OWORD *)(v38 - 56);
              long long v43 = *(_OWORD *)(v38 - 40);
              long long v44 = *(_OWORD *)(v38 - 24);
              *((void *)v40 - 1) = *((void *)v38 - 1);
              *(_OWORD *)(v40 - 24) = v44;
              *(_OWORD *)(v40 - 40) = v43;
              *(_OWORD *)(v40 - 56) = v42;
              v40 -= 88;
              v38 -= 88;
            }
            while (v38 != v39);
            float v38 = *(char **)(v7 - 24);
          }
          int v30 = v37 + 88;
          *(void *)(v7 - 24) = v40;
          *(void *)(v7 - 16) = v37 + 88;
          *(void *)(v7 - _Block_object_dispose(&STACK[0x238], 8) = &v36[88 * v35];
          if (v38) {
            operator delete(v38);
          }
        }
        else
        {
          *(_OWORD *)(v28 + 32) = v71;
          *(_OWORD *)(v28 + 4_Block_object_dispose(&STACK[0x238], 8) = v72;
          *(_OWORD *)(v28 + 64) = v73;
          *(void *)(v28 + 80) = v74;
          *(_OWORD *)unint64_t v28 = *(_OWORD *)__p;
          *(_OWORD *)(v28 + 16) = v70;
          int v30 = (char *)(v28 + 88);
        }
        *(void *)(v7 - 16) = v30;
      }
      while (*(unsigned __int16 *)(v5 + 8) - v6 > v3);
    }
  }
  if (EDLines_Debug(void)::token != -1) {
    dispatch_once(&EDLines_Debug(void)::token, &__block_literal_global_71);
  }
  if (EDLines_Debug(void)::v)
  {
    __p[0] = 0;
    __p[1] = 0;
    *(void *)&long long v70 = 0;
    int v45 = (uint64_t *)*((void *)this + 14);
    uint64_t v46 = (uint64_t *)*((void *)this + 15);
    if (v45 != v46)
    {
      uint64_t v47 = 0;
      do
      {
        uint64_t v48 = *v45;
        uint64_t v49 = v45[1];
        while (v48 != v49)
        {
          float v50 = (float)*(unint64_t *)(*((void *)this + 6) + 8);
          uint64_t v51 = *(void *)(v48 + 56);
          uint64_t v52 = *(void *)(v48 + 64);
          *((float *)&v51 + 1) = v50 - *((float *)&v51 + 1);
          *((float *)&v52 + 1) = v50 - *((float *)&v52 + 1);
          if ((unint64_t)v47 >= (unint64_t)v70)
          {
            uint64_t v66 = v52;
            uint64_t v68 = v51;
            uint64_t v53 = (v47 - (char *)__p[0]) >> 4;
            if ((unint64_t)(v53 + 1) >> 60) {
              abort();
            }
            unint64_t v54 = (uint64_t)(v70 - (unint64_t)__p[0]) >> 3;
            if (v54 <= v53 + 1) {
              unint64_t v54 = v53 + 1;
            }
            if ((unint64_t)v70 - (unint64_t)__p[0] >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v55 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v55 = v54;
            }
            if (v55) {
              unsigned int v56 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::Perspective::Line>>((uint64_t)&v70, v55);
            }
            else {
              unsigned int v56 = 0;
            }
            uint64_t v57 = &v56[16 * v53];
            *(void *)uint64_t v57 = v68;
            *((void *)v57 + 1) = v66;
            uint64_t v59 = (char *)__p[0];
            uint64_t v58 = (char *)__p[1];
            uint64_t v60 = v57;
            if (__p[1] != __p[0])
            {
              do
              {
                *((_OWORD *)v60 - 1) = *((_OWORD *)v58 - 1);
                v60 -= 16;
                v58 -= 16;
              }
              while (v58 != v59);
              uint64_t v58 = (char *)__p[0];
            }
            uint64_t v47 = v57 + 16;
            __p[0] = v60;
            __p[1] = v57 + 16;
            *(void *)&long long v70 = &v56[16 * v55];
            if (v58) {
              operator delete(v58);
            }
          }
          else
          {
            *(void *)uint64_t v47 = v51;
            *((void *)v47 + 1) = v52;
            v47 += 16;
          }
          __p[1] = v47;
          v48 += 88;
        }
        v45 += 3;
      }
      while (v45 != v46);
    }
    unint64_t v61 = (void *)(*(uint64_t (**)(CI::Perspective::EDLinesCPU *))(*(void *)this + 32))(this);
    int v62 = CGColorCreateSRGB(0.0, 1.0, 0.0, 1.0);
    int v63 = (CI::Perspective *)CI::Perspective::plotLines<CI::Perspective::Line>(v61, v62, (uint64_t **)__p);
    CI::Perspective::CIImageToFile(v63, (CIImage *)@"/tmp/ED_linesExtracted.png", v64, *MEMORY[0x1E4F1DB20]);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
}

void sub_1938828A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void CI::Perspective::EDLinesCPU::mergeLines(CI::Perspective::EDLinesCPU *this)
{
  uint64_t v2 = (unint64_t *)*((void *)this + 6);
  unint64_t v4 = *v2;
  unint64_t v3 = v2[1];
  if (v4 > v3) {
    unint64_t v3 = v4;
  }
  uint64_t v5 = (float32x2_t **)*((void *)this + 14);
  uint64_t v88 = (float32x2_t **)*((void *)this + 15);
  if (v5 != v88)
  {
    unint64_t v6 = (float *)*((void *)this + 1);
    float v7 = v6[7];
    float v8 = v6[8];
    float v9 = v6[9] * (float)v3;
    do
    {
      float v11 = *v5;
      unint64_t v10 = v5[1];
      unint64_t v12 = 0x2E8BA2E8BA2E8BA3 * (v10 - *v5);
      if (v12 >= 2)
      {
        if (v10 != v11)
        {
          unint64_t v20 = 0;
          do
          {
            unint64_t v21 = v20 + 1;
            if (v20 + 1 >= v12) {
              goto LABEL_21;
            }
            float v22 = (uint64_t *)&v11[11 * v20];
            uint64_t v23 = *v22;
            unint64_t v24 = v22[1];
            float v25 = &v11[11 * v20 + 19];
            unint64_t v26 = v24;
            while (1)
            {
              float32x2_t v27 = v25[-11];
              float32x2_t v28 = v25[-1];
              float32x2_t v29 = vsub_f32(v27, v28);
              if (sqrtf(vaddv_f32(vmul_f32(v29, v29))) > v8) {
                break;
              }
              float32x2_t v30 = vsub_f32(v27, v25[-12]);
              int32x2_t v31 = (int32x2_t)vmul_f32(v30, v30);
              v31.i32[0] = vadd_f32((float32x2_t)v31, (float32x2_t)vdup_lane_s32(v31, 1)).u32[0];
              float32x2_t v32 = vrsqrte_f32((float32x2_t)v31.u32[0]);
              float32x2_t v33 = vmul_f32(v32, vrsqrts_f32((float32x2_t)v31.u32[0], vmul_f32(v32, v32)));
              float32x2_t v34 = vmul_n_f32(v30, vmul_f32(v33, vrsqrts_f32((float32x2_t)v31.u32[0], vmul_f32(v33, v33))).f32[0]);
              float32x2_t v35 = vsub_f32(*v25, v28);
              int32x2_t v36 = (int32x2_t)vmul_f32(v35, v35);
              v36.i32[0] = vadd_f32((float32x2_t)v36, (float32x2_t)vdup_lane_s32(v36, 1)).u32[0];
              float32x2_t v37 = vrsqrte_f32((float32x2_t)v36.u32[0]);
              float32x2_t v38 = vmul_f32(v37, vrsqrts_f32((float32x2_t)v36.u32[0], vmul_f32(v37, v37)));
              float32x2_t v39 = vmul_n_f32(v35, vmul_f32(v38, vrsqrts_f32((float32x2_t)v36.u32[0], vmul_f32(v38, v38))).f32[0]);
              v39.f32[0] = (float)-v34.f32[1] * v39.f32[0];
              float v40 = -(float)(v39.f32[0] + (float)(v34.f32[0] * v39.f32[1]));
              float v41 = vmlas_n_f32(v39.f32[0], v39.f32[1], v34.f32[0]);
              if (v41 < 0.0) {
                float v41 = v40;
              }
              if (v41 > v7) {
                break;
              }
              v26 += *(void *)&v25[-7];
              ++v21;
              v25 += 11;
              if (v12 == v21)
              {
                unint64_t v21 = v12;
                break;
              }
            }
            if (v26 <= v24)
            {
LABEL_21:
              long long v44 = &v11[11 * v20];
              float32x2_t v42 = v44[7];
              float32x2_t v43 = v44[8];
            }
            else
            {
              CI::Perspective::LSRInit<EDAnchor>(v23, v26, (uint64_t)&__p);
              float32x2_t v42 = (float32x2_t)v92[5];
              float32x2_t v43 = (float32x2_t)v92[6];
            }
            unint64_t v20 = v21;
            float32x2_t v45 = vsub_f32(v42, v43);
            if (sqrtf(vaddv_f32(vmul_f32(v45, v45))) > v9)
            {
              uint64_t v47 = (float32x2_t *)*((void *)this + 18);
              unint64_t v46 = *((void *)this + 19);
              if ((unint64_t)v47 >= v46)
              {
                uint64_t v49 = *((void *)this + 17);
                uint64_t v50 = ((uint64_t)v47 - v49) >> 4;
                unint64_t v51 = v50 + 1;
                if ((unint64_t)(v50 + 1) >> 60) {
                  goto LABEL_83;
                }
                uint64_t v52 = v46 - v49;
                if (v52 >> 3 > v51) {
                  unint64_t v51 = v52 >> 3;
                }
                if ((unint64_t)v52 >= 0x7FFFFFFFFFFFFFF0) {
                  unint64_t v53 = 0xFFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v53 = v51;
                }
                if (v53) {
                  unint64_t v54 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::Perspective::Line>>((uint64_t)this + 152, v53);
                }
                else {
                  unint64_t v54 = 0;
                }
                unint64_t v55 = (float32x2_t *)&v54[16 * v50];
                *unint64_t v55 = v42;
                v55[1] = v43;
                uint64_t v57 = (char *)*((void *)this + 17);
                unsigned int v56 = (char *)*((void *)this + 18);
                uint64_t v58 = v55;
                if (v56 != v57)
                {
                  do
                  {
                    *(_OWORD *)v58[-2].f32 = *((_OWORD *)v56 - 1);
                    v58 -= 2;
                    v56 -= 16;
                  }
                  while (v56 != v57);
                  unsigned int v56 = (char *)*((void *)this + 17);
                }
                uint64_t v48 = v55 + 2;
                *((void *)this + 17) = v58;
                *((void *)this + 1_Block_object_dispose(&STACK[0x238], 8) = v55 + 2;
                *((void *)this + 19) = &v54[16 * v53];
                if (v56) {
                  operator delete(v56);
                }
              }
              else
              {
                *uint64_t v47 = v42;
                v47[1] = v43;
                uint64_t v48 = v47 + 2;
              }
              *((void *)this + 1_Block_object_dispose(&STACK[0x238], 8) = v48;
            }
            float v11 = *v5;
            unint64_t v12 = 0x2E8BA2E8BA2E8BA3 * (v5[1] - *v5);
          }
          while (v20 < v12);
        }
      }
      else
      {
        float32x2_t v14 = v11[7];
        float32x2_t v15 = v11[8];
        float v13 = v11 + 7;
        float32x2_t v16 = vsub_f32(v14, v15);
        if (sqrtf(vaddv_f32(vmul_f32(v16, v16))) > v9)
        {
          float v18 = (_OWORD *)*((void *)this + 18);
          unint64_t v17 = *((void *)this + 19);
          if ((unint64_t)v18 >= v17)
          {
            uint64_t v59 = *((void *)this + 17);
            uint64_t v60 = ((uint64_t)v18 - v59) >> 4;
            unint64_t v61 = v60 + 1;
            if ((unint64_t)(v60 + 1) >> 60) {
LABEL_83:
            }
              abort();
            uint64_t v62 = v17 - v59;
            if (v62 >> 3 > v61) {
              unint64_t v61 = v62 >> 3;
            }
            if ((unint64_t)v62 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v63 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v63 = v61;
            }
            if (v63) {
              int v64 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::Perspective::Line>>((uint64_t)this + 152, v63);
            }
            else {
              int v64 = 0;
            }
            int v65 = &v64[16 * v60];
            *(_OWORD *)int v65 = *(_OWORD *)v13->f32;
            uint64_t v67 = (char *)*((void *)this + 17);
            uint64_t v66 = (char *)*((void *)this + 18);
            uint64_t v68 = v65;
            if (v66 != v67)
            {
              do
              {
                *((_OWORD *)v68 - 1) = *((_OWORD *)v66 - 1);
                v68 -= 16;
                v66 -= 16;
              }
              while (v66 != v67);
              uint64_t v66 = (char *)*((void *)this + 17);
            }
            float v19 = v65 + 16;
            *((void *)this + 17) = v68;
            *((void *)this + 1_Block_object_dispose(&STACK[0x238], 8) = v65 + 16;
            *((void *)this + 19) = &v64[16 * v63];
            if (v66) {
              operator delete(v66);
            }
          }
          else
          {
            *float v18 = *(_OWORD *)v13->f32;
            float v19 = v18 + 1;
          }
          *((void *)this + 1_Block_object_dispose(&STACK[0x238], 8) = v19;
        }
      }
      v5 += 3;
    }
    while (v5 != v88);
  }
  if (EDLines_Debug(void)::token != -1) {
    dispatch_once(&EDLines_Debug(void)::token, &__block_literal_global_71);
  }
  if (EDLines_Debug(void)::v)
  {
    std::string __p = 0;
    double v91 = 0;
    v92[0] = 0;
    uint64_t v69 = (uint64_t *)*((void *)this + 17);
    long long v70 = (uint64_t *)*((void *)this + 18);
    if (v69 != v70)
    {
      long long v71 = 0;
      do
      {
        float v72 = (float)*(unint64_t *)(*((void *)this + 6) + 8);
        uint64_t v73 = *v69;
        uint64_t v74 = v69[1];
        *((float *)&v73 + 1) = v72 - COERCE_FLOAT(HIDWORD(*v69));
        *((float *)&v74 + 1) = v72 - *((float *)&v74 + 1);
        if ((unint64_t)v71 >= v92[0])
        {
          uint64_t v87 = v74;
          uint64_t v89 = v73;
          uint64_t v75 = (v71 - (unsigned char *)__p) >> 4;
          if ((unint64_t)(v75 + 1) >> 60) {
            abort();
          }
          unint64_t v76 = (uint64_t)(v92[0] - (void)__p) >> 3;
          if (v76 <= v75 + 1) {
            unint64_t v76 = v75 + 1;
          }
          if (v92[0] - (void)__p >= 0x7FFFFFFFFFFFFFF0uLL) {
            unint64_t v77 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v77 = v76;
          }
          if (v77) {
            int v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::Perspective::Line>>((uint64_t)v92, v77);
          }
          else {
            int v78 = 0;
          }
          char v79 = &v78[16 * v75];
          *(void *)char v79 = v89;
          *((void *)v79 + 1) = v87;
          char v81 = (char *)__p;
          char v80 = v91;
          char v82 = v79;
          if (v91 != __p)
          {
            do
            {
              *((_OWORD *)v82 - 1) = *((_OWORD *)v80 - 1);
              v82 -= 16;
              v80 -= 16;
            }
            while (v80 != v81);
            char v80 = (char *)__p;
          }
          long long v71 = v79 + 16;
          std::string __p = v82;
          double v91 = v79 + 16;
          v92[0] = &v78[16 * v77];
          if (v80) {
            operator delete(v80);
          }
        }
        else
        {
          *(void *)long long v71 = v73;
          *((void *)v71 + 1) = v74;
          v71 += 16;
        }
        double v91 = v71;
        v69 += 2;
      }
      while (v69 != v70);
    }
    char v83 = (void *)(*(uint64_t (**)(CI::Perspective::EDLinesCPU *))(*(void *)this + 32))(this);
    double v84 = CGColorCreateSRGB(0.0, 1.0, 0.0, 1.0);
    int v85 = (CI::Perspective *)CI::Perspective::plotLines<CI::Perspective::Line>(v83, v84, (uint64_t **)&__p);
    CI::Perspective::CIImageToFile(v85, (CIImage *)@"/tmp/ED_linesMerged.png", v86, *MEMORY[0x1E4F1DB20]);
    if (__p)
    {
      double v91 = (char *)__p;
      operator delete(__p);
    }
  }
}

void sub_193882E68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void CI::Perspective::EDLinesCPU::~EDLinesCPU(CI::Perspective::EDLinesCPU *this)
{
  *(void *)this = &unk_1EE457CB0;
  uint64_t v2 = (void **)*((void *)this + 11);
  unint64_t v3 = (void **)*((void *)this + 12);
  while (v2 != v3)
  {
    unint64_t v4 = *v2;
    v2 += 2;
    free(v4);
  }
  uint64_t v5 = *((void *)this + 6);
  if (v5)
  {
    free(*(void **)(v5 + 24));
    MEMORY[0x1997023B0](v5, 0x1080C4019856BD9);
  }
  uint64_t v6 = *((void *)this + 10);
  if (v6)
  {
    free(*(void **)(v6 + 24));
    MEMORY[0x1997023B0](v6, 0x1010C40313BCFEBLL);
  }
  float v7 = (void *)*((void *)this + 17);
  if (v7)
  {
    *((void *)this + 1_Block_object_dispose(&STACK[0x238], 8) = v7;
    operator delete(v7);
  }
  unint64_t v10 = (void **)((char *)this + 112);
  std::vector<std::vector<IRect>>::__destroy_vector::operator()[abi:nn180100](&v10);
  float v8 = (void *)*((void *)this + 11);
  if (v8)
  {
    *((void *)this + 12) = v8;
    operator delete(v8);
  }
  float v9 = (void *)*((void *)this + 7);
  if (v9)
  {
    *((void *)this + _Block_object_dispose(&STACK[0x238], 8) = v9;
    operator delete(v9);
  }
}

{
  uint64_t vars8;

  CI::Perspective::EDLinesCPU::~EDLinesCPU(this);

  JUMPOUT(0x1997023B0);
}

uint64_t CI::Perspective::EDLinesCPU::getLines(CI::Perspective::EDLinesCPU *this)
{
  return (uint64_t)this + 136;
}

CIImage *CI::Perspective::EDLinesCPU::getAnchorsImage(CI::Perspective::EDLinesCPU *this)
{
  uint64_t v2 = (unint64_t *)*((void *)this + 6);
  unint64_t v4 = *v2;
  unint64_t v3 = v2[1];
  v14[0] = v4;
  v14[1] = v3;
  if ((v4 & 7) != 0) {
    uint64_t v5 = (v4 >> 3) + 1;
  }
  else {
    uint64_t v5 = v4 >> 3;
  }
  _OWORD v14[2] = v5;
  size_t v6 = v5 * v3;
  float v7 = malloc_type_malloc(v5 * v3, 0xAD3CE366uLL);
  float32x2_t v15 = v7;
  bzero(v7, v6);
  float v8 = (unsigned __int16 *)*((void *)this + 7);
  for (uint64_t i = (unsigned __int16 *)*((void *)this + 8); v8 != i; v8 += 2)
  {
    unint64_t v10 = *v8;
    uint64_t v11 = v5 * v8[1] + (v10 >> 3);
    *((unsigned char *)v7 + v11) |= 1 << (~(_BYTE)v10 & 7);
  }
  unint64_t v12 = CI::Perspective::Bitmask::imageRepresentation((CI::Perspective::Bitmask *)v14);
  free(v15);
  return v12;
}

void sub_193883094(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
}

CIImage *CI::Perspective::Bitmask::imageRepresentation(CI::Perspective::Bitmask *this)
{
  void v15[2] = *MEMORY[0x1E4F143B8];
  unint64_t v2 = (*(void *)this + 15) ^ 0xFFFFFFFFFFFFFFEFLL;
  unint64_t v3 = (void *)[MEMORY[0x1E4F1CA58] dataWithLength:*((void *)this + 1) * v2];
  uint64_t v4 = [v3 mutableBytes];
  unint64_t v5 = *((void *)this + 1);
  if (v5)
  {
    unint64_t v6 = 0;
    uint64_t v7 = *(void *)this;
    do
    {
      if (v7)
      {
        unint64_t v8 = 0;
        do
        {
          if ((*(unsigned __int8 *)(*((void *)this + 3) + *((void *)this + 2) * v6 + (v8 >> 3)) >> (~(_BYTE)v8 & 7))) {
            char v9 = -1;
          }
          else {
            char v9 = 0;
          }
          *(unsigned char *)(v4 + v8++) = v9;
          uint64_t v7 = *(void *)this;
        }
        while (v8 < *(void *)this);
        unint64_t v5 = *((void *)this + 1);
      }
      ++v6;
      v4 += v2;
    }
    while (v6 < v5);
  }
  unint64_t v10 = CI::CIPerspectiveAutoCalcV1Kernels::arg_name_grad_e0_e1;
  {
    unint64_t v10 = CI::CIPerspectiveAutoCalcV1Kernels::arg_name_grad_e0_e1;
    if (v13)
    {
      CI::Perspective::Bitmask::imageRepresentation(void)const::linearGradouble y = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC78]);
      unint64_t v10 = CI::CIPerspectiveAutoCalcV1Kernels::arg_name_grad_e0_e1;
    }
  }
  uint64_t v11 = v10[379];
  v14[0] = @"CIImageColorSpace";
  v14[1] = @"CIImageFlipped";
  v15[0] = v11;
  v15[1] = MEMORY[0x1E4F1CC38];
  return +[CIImage imageWithBitmapData:bytesPerRow:size:format:options:](CIImage, "imageWithBitmapData:bytesPerRow:size:format:options:", v3, v2, 259, [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v15 forKeys:v14 count:2], (double)*(unint64_t *)this, (double)*((unint64_t *)this + 1));
}

void sub_193883254(_Unwind_Exception *a1)
{
}

CIImage *CI::Perspective::EDLinesCPU::getEdgeDrawingImage(CI::Perspective::EDLinesCPU *this)
{
  v26[2] = *MEMORY[0x1E4F143B8];
  unint64_t v2 = *((void *)this + 3);
  unint64_t v3 = *((void *)this + 4);
  unint64_t v4 = (4 * v2 + 15) & 0xFFFFFFFFFFFFFFF0;
  unint64_t v5 = (char *)malloc_type_malloc(v4 * v3, 0x6457AB2BuLL);
  unint64_t v6 = v5;
  if (v3)
  {
    if (v2 <= 1) {
      uint64_t v7 = 1;
    }
    else {
      uint64_t v7 = v2;
    }
    size_t v8 = 4 * v7;
    unint64_t v9 = v3;
    unint64_t v10 = v5;
    unint64_t v11 = v2;
    do
    {
      if (v11)
      {
        memset_pattern16(v10, &unk_1939577F0, v8);
        unint64_t v11 = v2;
      }
      v10 += v4;
      --v9;
    }
    while (v9);
  }
  uint64_t v13 = *((void *)this + 11);
  for (uint64_t i = *((void *)this + 12); v13 != i; v13 += 16)
  {
    uint32_t v14 = arc4random();
    if ((v14 & 0xF80000) <= 0x770000) {
      unsigned int v15 = -8978432;
    }
    else {
      unsigned int v15 = v14 & 0xFF0000 | 0xFF000000;
    }
    if ((v14 & 0xF800) <= 0x7700) {
      int v16 = 30464;
    }
    else {
      int v16 = v14 & 0xFF00;
    }
    if ((v14 & 0xF8) <= 0x77) {
      int v17 = 119;
    }
    else {
      int v17 = v14;
    }
    if (*(_WORD *)(v13 + 8))
    {
      uint64_t v18 = 0;
      unint64_t v19 = 0;
      int v20 = v15 | v16 | v17;
      do
      {
        *(_DWORD *)&v6[4 * *(unsigned __int16 *)(*(void *)v13 + v18)
                     + v4 * *(unsigned __int16 *)(*(void *)v13 + v18 + 2)] = v20;
        ++v19;
        v18 += 4;
      }
      while (v19 < *(unsigned __int16 *)(v13 + 8));
    }
  }
  {
    CI::Perspective::EDLinesCPU::getEdgeDrawingImage(void)const::sRGB = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
  }
  uint64_t v21 = CI::Perspective::EDLinesCPU::getEdgeDrawingImage(void)const::sRGB;
  uint64_t v22 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v6 length:v4 * v3];
  v25[0] = @"CIImageColorSpace";
  v25[1] = @"CIImageFlipped";
  v26[0] = v21;
  v26[1] = MEMORY[0x1E4F1CC38];
  uint64_t v23 = +[CIImage imageWithBitmapData:bytesPerRow:size:format:options:](CIImage, "imageWithBitmapData:bytesPerRow:size:format:options:", v22, v4, 264, [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v26 forKeys:v25 count:2], (double)v2, (double)v3);
  free(v6);
  return v23;
}

void sub_1938834D8(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

CIImage *CI::Perspective::Bitmap<float>::imageRepresentation(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  v9[2] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = [MEMORY[0x1E4F1C9B8] dataWithBytes:a1[3] length:a1[2] * a1[1]];
  v8[0] = @"CIImageColorSpace";
  v8[1] = @"CIImageFlipped";
  v9[0] = a3;
  v9[1] = MEMORY[0x1E4F1CC38];
  return +[CIImage imageWithBitmapData:bytesPerRow:size:format:options:](CIImage, "imageWithBitmapData:bytesPerRow:size:format:options:", v6, a1[2], a2, [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v9 forKeys:v8 count:2], (double)*a1, (double)a1[1]);
}

void std::vector<EDAnchor>::reserve(void **a1, unint64_t a2)
{
  unint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 2)
  {
    if (a2 >> 62) {
      abort();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    uint64_t v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>(v3, a2);
    uint64_t v7 = &v6[v5 & 0xFFFFFFFFFFFFFFFCLL];
    unint64_t v9 = &v6[4 * v8];
    unint64_t v11 = (char *)*a1;
    unint64_t v10 = (char *)a1[1];
    unint64_t v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        int v13 = *((_DWORD *)v10 - 1);
        v10 -= 4;
        *((_DWORD *)v12 - 1) = v13;
        v12 -= 4;
      }
      while (v10 != v11);
      unint64_t v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

uint64_t CI::Perspective::EDLinesCPU::traceForeward(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v2 = *a2;
  if (!*a2) {
    return 0;
  }
  uint64_t v3 = a2[1];
  unint64_t v4 = *(void **)(a1 + 48);
  BOOL v5 = *v4 - 2 < (unint64_t)*a2 || v3 == 0;
  if (v5 || v4[1] - 2 < (unint64_t)a2[1]) {
    return 0;
  }
  uint64_t v8 = v4 + 2;
  uint64_t v7 = v4[2];
  uint64_t v6 = v8[1];
  uint64_t v9 = v6 + v7 * v3;
  float v10 = *(float *)(v9 + 4 * v2);
  float v11 = -v10;
  if (v10 >= 0.0) {
    float v11 = *(float *)(v9 + 4 * v2);
  }
  if (v11 < *(float *)(*(void *)(a1 + 8) + 8)) {
    return 0;
  }
  if (v10 <= 0.0)
  {
    unsigned __int16 v17 = v3 + 1;
    uint64_t v21 = v6 + v7 * v17;
    float v22 = *(float *)(v21 + 4 * v2);
    if (v22 >= 0.0) {
      float v23 = *(float *)(v21 + 4 * v2);
    }
    else {
      float v23 = -v22;
    }
    unsigned __int16 v24 = v2 - 1;
    float v25 = *(float *)(v21 + 4 * (unsigned __int16)(v2 - 1));
    if (v25 < 0.0) {
      float v25 = -v25;
    }
    unsigned __int16 v12 = v2 + 1;
    float v18 = *(float *)(v21 + 4 * v12);
    if (v18 < 0.0) {
      float v18 = -v18;
    }
    if (v25 <= v18) {
      float v19 = v18;
    }
    else {
      float v19 = v25;
    }
    if (v23 > v19) {
      float v19 = v23;
    }
    if (v19 == v23) {
      goto LABEL_45;
    }
    if (v19 == v25)
    {
      *a2 = v24;
      goto LABEL_45;
    }
LABEL_43:
    if (v19 != v18) {
      return 1;
    }
    *a2 = v12;
LABEL_45:
    a2[1] = v17;
    return 1;
  }
  unsigned __int16 v12 = v2 + 1;
  float v13 = *(float *)(v9 + 4 * v12);
  if (v13 >= 0.0) {
    float v14 = *(float *)(v9 + 4 * v12);
  }
  else {
    float v14 = -v13;
  }
  unsigned __int16 v15 = v3 - 1;
  float v16 = *(float *)(v6 + v7 * (unsigned __int16)(v3 - 1) + 4 * v12);
  if (v16 < 0.0) {
    float v16 = -v16;
  }
  unsigned __int16 v17 = v3 + 1;
  float v18 = *(float *)(v6 + v7 * v17 + 4 * v12);
  if (v18 < 0.0) {
    float v18 = -v18;
  }
  if (v16 <= v18) {
    float v19 = v18;
  }
  else {
    float v19 = v16;
  }
  if (v14 > v19) {
    float v19 = v14;
  }
  if (v19 != v14)
  {
    if (v19 == v16)
    {
      *a2 = v12;
      a2[1] = v15;
      return 1;
    }
    goto LABEL_43;
  }
  *a2 = v12;
  return 1;
}

uint64_t CI::Perspective::EDLinesCPU::traceBackward(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v2 = *a2;
  if (!*a2) {
    return 0;
  }
  uint64_t v3 = a2[1];
  unint64_t v4 = *(void **)(a1 + 48);
  BOOL v5 = *v4 - 2 < (unint64_t)*a2 || v3 == 0;
  if (v5 || v4[1] - 2 < (unint64_t)a2[1]) {
    return 0;
  }
  uint64_t v8 = v4 + 2;
  uint64_t v7 = v4[2];
  uint64_t v6 = v8[1];
  uint64_t v9 = v6 + v7 * v3;
  float v10 = *(float *)(v9 + 4 * v2);
  float v11 = -v10;
  if (v10 >= 0.0) {
    float v11 = *(float *)(v9 + 4 * v2);
  }
  if (v11 < *(float *)(*(void *)(a1 + 8) + 8)) {
    return 0;
  }
  if (v10 <= 0.0)
  {
    unsigned __int16 v17 = v3 - 1;
    uint64_t v21 = v6 + v7 * v17;
    float v22 = *(float *)(v21 + 4 * v2);
    if (v22 >= 0.0) {
      float v23 = *(float *)(v21 + 4 * v2);
    }
    else {
      float v23 = -v22;
    }
    unsigned __int16 v24 = v2 - 1;
    float v25 = *(float *)(v21 + 4 * (unsigned __int16)(v2 - 1));
    if (v25 < 0.0) {
      float v25 = -v25;
    }
    unsigned __int16 v12 = v2 + 1;
    float v18 = *(float *)(v21 + 4 * v12);
    if (v18 < 0.0) {
      float v18 = -v18;
    }
    if (v25 <= v18) {
      float v19 = v18;
    }
    else {
      float v19 = v25;
    }
    if (v23 > v19) {
      float v19 = v23;
    }
    if (v19 == v23) {
      goto LABEL_45;
    }
    if (v19 == v25)
    {
      *a2 = v24;
      goto LABEL_45;
    }
LABEL_43:
    if (v19 != v18) {
      return 1;
    }
    *a2 = v12;
LABEL_45:
    a2[1] = v17;
    return 1;
  }
  unsigned __int16 v12 = v2 - 1;
  float v13 = *(float *)(v9 + 4 * v12);
  if (v13 >= 0.0) {
    float v14 = *(float *)(v9 + 4 * v12);
  }
  else {
    float v14 = -v13;
  }
  unsigned __int16 v15 = v3 - 1;
  float v16 = *(float *)(v6 + v7 * (unsigned __int16)(v3 - 1) + 4 * v12);
  if (v16 < 0.0) {
    float v16 = -v16;
  }
  unsigned __int16 v17 = v3 + 1;
  float v18 = *(float *)(v6 + v7 * v17 + 4 * v12);
  if (v18 < 0.0) {
    float v18 = -v18;
  }
  if (v16 <= v18) {
    float v19 = v18;
  }
  else {
    float v19 = v16;
  }
  if (v14 > v19) {
    float v19 = v14;
  }
  if (v19 != v14)
  {
    if (v19 == v16)
    {
      *a2 = v12;
      a2[1] = v15;
      return 1;
    }
    goto LABEL_43;
  }
  *a2 = v12;
  return 1;
}

uint64_t std::vector<std::vector<CI::Perspective::LSR<EDAnchor>>>::reserve(void *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3) < a2)
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    uint64_t v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SWRendererFunctionInputNode>>(result, a2);
    v7[1] = v7[0] + v5;
    CGAffineTransform v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 24 * v6;
    std::vector<std::vector<CI::Perspective::LSR<EDAnchor>>>::__swap_out_circular_buffer(a1, v7);
    return std::__split_buffer<std::vector<CI::Perspective::LSR<EDAnchor>>>::~__split_buffer((uint64_t)v7);
  }
  return result;
}

void sub_193883A34(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<CI::Perspective::LSR<EDAnchor>>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void *std::vector<std::vector<CI::Perspective::LSR<EDAnchor>>>::emplace_back<std::vector<CI::Perspective::LSR<EDAnchor>>>(void *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  uint64_t v7 = *(void **)(v4 - 8);
  if ((unint64_t)v7 >= v6)
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - *a1) >> 3);
    unint64_t v10 = v9 + 1;
    if (v9 + 1 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v11 > v10) {
      unint64_t v10 = 2 * v11;
    }
    if (v11 >= 0x555555555555555) {
      unint64_t v12 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v12 = v10;
    }
    void v17[4] = v4;
    float v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SWRendererFunctionInputNode>>(v4, v12);
    float v14 = &v13[24 * v9];
    v17[0] = v13;
    v17[1] = v14;
    void v17[3] = &v13[24 * v15];
    *((void *)v14 + 1) = 0;
    *((void *)v14 + 2) = 0;
    *(void *)float v14 = 0;
    *(_OWORD *)float v14 = *(_OWORD *)a2;
    *((void *)v14 + 2) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + _Block_object_dispose(&STACK[0x238], 8) = 0;
    *(void *)(a2 + 16) = 0;
    v17[2] = v14 + 24;
    std::vector<std::vector<CI::Perspective::LSR<EDAnchor>>>::__swap_out_circular_buffer(a1, v17);
    uint64_t v8 = (void *)a1[1];
    std::__split_buffer<std::vector<CI::Perspective::LSR<EDAnchor>>>::~__split_buffer((uint64_t)v17);
  }
  else
  {
    *uint64_t v7 = 0;
    v7[1] = 0;
    CGAffineTransform v7[2] = 0;
    *(_OWORD *)uint64_t v7 = *(_OWORD *)a2;
    CGAffineTransform v7[2] = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + _Block_object_dispose(&STACK[0x238], 8) = 0;
    *(void *)(a2 + 16) = 0;
    uint64_t v8 = v7 + 3;
    a1[1] = v7 + 3;
  }
  a1[1] = v8;
  return v8 - 3;
}

void sub_193883B74(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<CI::Perspective::LSR<EDAnchor>>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

float CI::Perspective::LSRInit<EDAnchor>@<S0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)(a3 + 16) = 0;
  *(void *)(a3 + 24) = 0;
  *(_DWORD *)(a3 + 32) = 0;
  *(_OWORD *)(a3 + 36) = xmmword_1939577E0;
  *(void *)a3 = a1;
  *(void *)(a3 + _Block_object_dispose(&STACK[0x238], 8) = a2;
  if (a2)
  {
    unint64_t v6 = (_WORD *)(a1 + 2);
    float v7 = 0.0;
    float v8 = -INFINITY;
    float v9 = INFINITY;
    float v10 = 0.0;
    float v11 = 0.0;
    float v12 = 0.0;
    float v13 = 0.0;
    float v14 = INFINITY;
    float v15 = -INFINITY;
    do
    {
      LOWORD(v3) = *(v6 - 1);
      float v3 = (float)LODWORD(v3);
      LOWORD(v4) = *v6;
      float v4 = (float)LODWORD(v4);
      float v13 = v13 + v3;
      float v12 = v12 + v4;
      float v11 = v11 + (float)(v3 * v3);
      float v10 = v10 + (float)(v4 * v4);
      float v7 = v7 + (float)(v3 * v4);
      if (v9 >= v3) {
        float v9 = v3;
      }
      if (v8 <= v3) {
        float v8 = v3;
      }
      if (v14 >= v4) {
        float v14 = v4;
      }
      if (v15 <= v4) {
        float v15 = v4;
      }
      v6 += 2;
      --a2;
    }
    while (a2);
    *(float *)(a3 + 16) = v13;
    *(float *)(a3 + 20) = v12;
    *(float *)(a3 + 24) = v11;
    *(float *)(a3 + 2_Block_object_dispose(&STACK[0x238], 8) = v10;
    *(float *)(a3 + 32) = v7;
    *(float *)(a3 + 36) = v9;
    *(float *)(a3 + 40) = v8;
    *(float *)(a3 + 44) = v14;
    *(float *)(a3 + 4_Block_object_dispose(&STACK[0x238], 8) = v15;
  }
  CI::Perspective::LSRUpdateFit<EDAnchor>(a3);
  unint64_t v17 = *(void *)(a3 + 8);
  if (v17)
  {
    float v18 = *(float *)(a3 + 72);
    float v19 = *(float *)(a3 + 76);
    float v20 = *(float *)(a3 + 80);
    float v21 = *(float *)(a3 + 44);
    float v22 = *(float *)(a3 + 48) - v21;
    float v23 = (_WORD *)(*(void *)a3 + 2);
    if ((float)(*(float *)(a3 + 40) - *(float *)(a3 + 36)) <= v22)
    {
      float v24 = 0.0;
      uint64_t v26 = *(void *)(a3 + 8);
      do
      {
        LOWORD(v22) = *(v23 - 1);
        LOWORD(v21) = *v23;
        float v21 = (float)(v20 + (float)(v19 * (float)LODWORD(v21))) / v18;
        float v22 = v21 + (float)LODWORD(v22);
        float v24 = v24 + (float)(v22 * v22);
        v23 += 2;
        --v26;
      }
      while (v26);
    }
    else
    {
      float v24 = 0.0;
      uint64_t v25 = *(void *)(a3 + 8);
      do
      {
        LOWORD(v22) = *(v23 - 1);
        LOWORD(v21) = *v23;
        float v21 = (float)LODWORD(v21);
        float v22 = (float)((float)(v20 + (float)(v18 * (float)LODWORD(v22))) / v19) + v21;
        float v24 = v24 + (float)(v22 * v22);
        v23 += 2;
        --v25;
      }
      while (v25);
    }
    float result = v24 / (float)v17;
    *(float *)(a3 + 84) = result;
  }
  return result;
}

uint64_t CI::Perspective::LSRUpdateFit<EDAnchor>(uint64_t result)
{
  unint64_t v1 = *(void *)(result + 8);
  if (v1)
  {
    float v2 = *(float *)(result + 16);
    float v3 = *(float *)(result + 20);
    float v4 = (float)v1;
    float v5 = v2 / (float)v1;
    unint64_t v6 = *(_WORD **)result;
    uint64_t v7 = *(void *)result + 4 * v1;
    float v8 = *(float *)(result + 32);
    float v9 = *(float *)(result + 44);
    float v10 = *(float *)(result + 48) - v9;
    float v11 = v3 / v4;
    if ((float)(*(float *)(result + 40) - *(float *)(result + 36)) <= v10)
    {
      LOWORD(v10) = v6[1];
      float v16 = (float)LODWORD(v10);
      LOWORD(v9) = *(_WORD *)(v7 - 2);
      float v17 = (float)LODWORD(v9);
      float v18 = *(float *)(result + 28) - (float)((float)(v3 * v3) / v4);
      if (v18 == 0.0) {
        float v19 = 0.0;
      }
      else {
        float v19 = (float)(v8 - (float)((float)(v2 * v3) / v4)) / v18;
      }
      float v21 = v5 - (float)(v19 * v11);
      if (v19 != 0.0) {
        float v5 = v21;
      }
      *(_DWORD *)(result + 72) = -1082130432;
      *(float *)(result + 76) = v19;
      *(float *)(result + 80) = v5;
      *(float *)&uint64_t v22 = v5 + (float)(v19 * v16);
      *((float *)&v22 + 1) = v16;
      *(void *)(result + 56) = v22;
      *(float *)&uint64_t v13 = v5 + (float)(v19 * v17);
      *((float *)&v13 + 1) = v17;
    }
    else
    {
      LOWORD(v10) = *v6;
      *(float *)&uint64_t v12 = (float)LODWORD(v10);
      LOWORD(v10) = *(_WORD *)(v7 - 4);
      *(float *)&uint64_t v13 = (float)LODWORD(v10);
      float v14 = *(float *)(result + 24) - (float)((float)(v2 * v2) / v4);
      if (v14 == 0.0) {
        float v15 = 0.0;
      }
      else {
        float v15 = (float)(v8 - (float)((float)(v2 * v3) / v4)) / v14;
      }
      float v20 = v11 - (float)(v15 * v5);
      if (v15 == 0.0) {
        float v20 = v3 / v4;
      }
      *(float *)(result + 72) = v15;
      *(_DWORD *)(result + 76) = -1082130432;
      *(float *)(result + 80) = v20;
      *((float *)&v12 + 1) = v20 + (float)(v15 * *(float *)&v12);
      *(void *)(result + 56) = v12;
      *((float *)&v13 + 1) = v20 + (float)(v15 * *(float *)&v13);
    }
    *(void *)(result + 64) = v13;
  }
  return result;
}

void CI::Perspective::EDLines::Create()
{
}

void sub_193883EA4(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C40EBE27C8DLL);
  _Unwind_Resume(a1);
}

uint64_t ___ZL13EDLines_Debugv_block_invoke()
{
  uint64_t v0 = getenv("EDLINES_DEBUG");
  if (v0) {
    uint64_t result = atoi(v0);
  }
  else {
    uint64_t result = EDLines_Debug(void)::v;
  }
  EDLines_Debug(void)::v = result != 0;
  return result;
}

void *std::vector<std::vector<CI::Perspective::LSR<EDAnchor>>>::__swap_out_circular_buffer(void *result, void *a2)
{
  float v3 = (void *)*result;
  float v2 = (void *)result[1];
  uint64_t v4 = a2[1];
  while (v2 != v3)
  {
    *(void *)(v4 - 24) = 0;
    *(void *)(v4 - 16) = 0;
    v4 -= 24;
    *(void *)(v4 + 16) = 0;
    long long v5 = *(_OWORD *)(v2 - 3);
    v2 -= 3;
    *(_OWORD *)uint64_t v4 = v5;
    *(void *)(v4 + 16) = v2[2];
    *float v2 = 0;
    v2[1] = 0;
    _OWORD v2[2] = 0;
  }
  a2[1] = v4;
  unint64_t v6 = (void *)*result;
  *uint64_t result = v4;
  a2[1] = v6;
  uint64_t v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<std::vector<CI::Perspective::LSR<EDAnchor>>>::~__split_buffer(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__split_buffer<std::vector<CI::Perspective::LSR<EDAnchor>>>::__destruct_at_end[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != a2)
  {
    long long v5 = *(void **)(v2 - 24);
    *(void *)(a1 + 16) = v2 - 24;
    if (v5)
    {
      *(void *)(v2 - 16) = v5;
      operator delete(v5);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 24;
    }
  }
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<CI::Perspective::LSR<EDAnchor>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x2E8BA2E8BA2E8BBLL) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(88 * a2);
}

uint64_t FastRegistration_computeSignatures(uint64_t a1, int a2, NSObject *a3, uint64_t a4)
{
  int v8 = Projections_projectionRowsCols_planar8UtoF();
  int v9 = v8;
  if (v8 < 0)
  {
    StatusDescription = Projections_getStatusDescription(v8);
    int v19 = 45;
    goto LABEL_24;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a4 + 40) = v10;
  *(void *)(a4 + _Block_object_dispose(&STACK[0x238], 8) = *(void *)(a1 + 8);
  if (*(void *)(a4 + 24) && *(void *)(a4 + 16) && *(void *)(a4 + 56))
  {
    BOOL v11 = *(void *)(a4 + 48) != 0;
    if (!a3) {
      goto LABEL_6;
    }
LABEL_14:
    uint64_t v41 = 0;
    float32x2_t v42 = &v41;
    uint64_t v43 = 0x2000000000;
    int v44 = 0;
    uint64_t v37 = 0;
    float32x2_t v38 = &v37;
    uint64_t v39 = 0x2000000000;
    int v40 = 0;
    uint64_t v33 = 0;
    float32x2_t v34 = &v33;
    uint64_t v35 = 0x2000000000;
    int v36 = 0;
    uint64_t v29 = 0;
    float32x2_t v30 = &v29;
    uint64_t v31 = 0x2000000000;
    int v32 = 0;
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __FastRegistration_computeSignatures_block_invoke;
    block[3] = &unk_1E5770618;
    char v28 = a2;
    block[5] = &v33;
    void block[6] = a4;
    BOOL v27 = v11;
    block[4] = &v41;
    v23[0] = MEMORY[0x1E4F143A8];
    v23[1] = 0x40000000;
    void v23[2] = __FastRegistration_computeSignatures_block_invoke_2;
    v23[3] = &unk_1E5773170;
    char v25 = a2;
    v23[5] = &v29;
    v23[6] = a4;
    BOOL v24 = v11;
    v23[4] = &v37;
    dispatch_async(a3, block);
    dispatch_async(a3, v23);
    dispatch_barrier_sync(a3, &__block_literal_global_72);
    unsigned int v16 = *((_DWORD *)v42 + 6);
    if (!v16)
    {
      unsigned int v16 = *((_DWORD *)v38 + 6);
      if (!v16)
      {
        if (*((_DWORD *)v30 + 6) | *((_DWORD *)v34 + 6)) {
          unsigned int v16 = -7;
        }
        else {
          unsigned int v16 = 0;
        }
      }
    }
    _Block_object_dispose(&v29, 8);
    _Block_object_dispose(&v33, 8);
    _Block_object_dispose(&v37, 8);
    _Block_object_dispose(&v41, 8);
    goto LABEL_20;
  }
  BOOL v11 = 0;
  if (a3) {
    goto LABEL_14;
  }
LABEL_6:
  if (!a2)
  {
LABEL_9:
    if (!v11)
    {
LABEL_12:
      unsigned int v16 = 0;
      goto LABEL_20;
    }
    int v14 = Projections_computeMeanStdTable(*(float **)(a4 + 32), *(_DWORD *)(a4 + 40), (void *)(a4 + 48));
    if ((v14 & 0x80000000) == 0)
    {
      int v15 = Projections_computeMeanStdTable(*(float **)a4, *(_DWORD *)(a4 + 8), (void *)(a4 + 16));
      int v9 = v15;
      if ((v15 & 0x80000000) == 0) {
        goto LABEL_12;
      }
      uint64_t v22 = Projections_getStatusDescription(v15);
      syslog(3, "Projections error %d:%s in %s @ %s:%d\n", v9, v22, "FastRegistration_status FastRegistration_computeSignatures(const vImage_Buffer *, _Bool, dispatch_queue_t, FastRegistration_Signatures *)", "/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage/Framework/api/Burst/Projections/FastRegistration_Core.c", 110);
      return 4294967289;
    }
    int v9 = v14;
    StatusDescription = Projections_getStatusDescription(v14);
    int v19 = 109;
LABEL_24:
    syslog(3, "Projections error %d:%s in %s @ %s:%d\n", v9, StatusDescription, "FastRegistration_status FastRegistration_computeSignatures(const vImage_Buffer *, _Bool, dispatch_queue_t, FastRegistration_Signatures *)", "/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage/Framework/api/Burst/Projections/FastRegistration_Core.c", v19);
    return 4294967289;
  }
  int v12 = FastRegistration_processProjections(*(void *)(a4 + 32), v10);
  if (v12 < 0)
  {
    unsigned int v16 = v12;
    float v20 = FastRegistration_getStatusDescription(v12);
    syslog(3, "FastRegistration error %d:%s in %s @ %s:%d\n", v16, v20, "FastRegistration_status FastRegistration_computeSignatures(const vImage_Buffer *, _Bool, dispatch_queue_t, FastRegistration_Signatures *)", "/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage/Framework/api/Burst/Projections/FastRegistration_Core.c", 105);
  }
  else
  {
    int v13 = FastRegistration_processProjections(*(void *)a4, *(void *)(a4 + 8));
    if ((v13 & 0x80000000) == 0) {
      goto LABEL_9;
    }
    unsigned int v16 = v13;
    float v21 = FastRegistration_getStatusDescription(v13);
    syslog(3, "FastRegistration error %d:%s in %s @ %s:%d\n", v16, v21, "FastRegistration_status FastRegistration_computeSignatures(const vImage_Buffer *, _Bool, dispatch_queue_t, FastRegistration_Signatures *)", "/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage/Framework/api/Burst/Projections/FastRegistration_Core.c", 106);
  }
LABEL_20:
  if (v9) {
    return 4294967289;
  }
  else {
    return v16;
  }
}

uint64_t FastRegistration_processProjections(uint64_t a1, uint64_t a2, ...)
{
  va_start(__B, a2);
  uint64_t v2 = MEMORY[0x1F4188790]();
  int v4 = v3;
  long long v5 = (float *)v2;
  STACK[0x3348] = *MEMORY[0x1E4F143B8];
  if ((int)(float)((float)v3 * 0.03) <= 3) {
    int v6 = 3;
  }
  else {
    int v6 = (int)(float)((float)v3 * 0.03);
  }
  int v7 = Projections_smoothProjection(v2, v3, v6, (uint64_t)__B);
  if (v7 < 0)
  {
    int v11 = v7;
    StatusDescription = Projections_getStatusDescription(v7);
    syslog(3, "Projections error %d:%s in %s @ %s:%d\n", v11, StatusDescription, "FastRegistration_status FastRegistration_processProjections(float *, vImagePixelCount)", "/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage/Framework/api/Burst/Projections/FastRegistration_Core.c", 25);
    return 4294967289;
  }
  int v8 = Projections_computeProjectionDerivative((const float *)__B, v4, v5);
  int v9 = v8;
  if (v8 < 0)
  {
    int v13 = Projections_getStatusDescription(v8);
    syslog(3, "Projections error %d:%s in %s @ %s:%d\n", v9, v13, "FastRegistration_status FastRegistration_processProjections(float *, vImagePixelCount)", "/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage/Framework/api/Burst/Projections/FastRegistration_Core.c", 26);
    return 4294967289;
  }
  if (v8) {
    return 4294967289;
  }
  else {
    return 0;
  }
}

uint64_t FastRegistration_register(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,int a22,uint64_t block,uint64_t a24,uint64_t (*a25)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9),void *a26,uint64_t *a27,void *a28,uint64_t a29,float *a30,float *a31,int a32,uint64_t a33,uint64_t *a34,uint64_t a35,int a36,uint64_t a37,uint64_t *a38,uint64_t a39,int a40,int a41,float a42)
{
  float32x2_t v42 = (void *)MEMORY[0x1F4188790]();
  uint64_t v48 = v47;
  uint64_t v50 = v49;
  unint64_t v51 = v44;
  uint64_t v53 = v52;
  unint64_t v54 = v42;
  STACK[0xCD38] = *MEMORY[0x1E4F143B8];
  unint64_t v55 = v42[5];
  unint64_t v56 = *(void *)(v53 + 40);
  if (v55 >= v56) {
    unint64_t v57 = *(void *)(v53 + 40);
  }
  else {
    unint64_t v57 = v42[5];
  }
  int v58 = (int)(float)((float)v57 * v46);
  unint64_t v59 = v42[1];
  if (v59 >= *(void *)(v53 + 8)) {
    unint64_t v59 = *(void *)(v53 + 8);
  }
  int v60 = (int)(float)((float)v59 * v46);
  a37 = 0;
  a38 = &a37;
  a39 = 0x2000000000;
  a40 = 0;
  a33 = 0;
  a34 = &a33;
  a35 = 0x2000000000;
  a36 = 0;
  if (v43)
  {
    unint64_t v61 = v43;
    block = MEMORY[0x1E4F143A8];
    a24 = 0x40000000;
    a25 = __FastRegistration_register_block_invoke;
    a26 = &unk_1E57731B8;
    a27 = &a37;
    a28 = v42;
    a32 = v58;
    a29 = v53;
    a30 = v44;
    a31 = v45;
    var10[0] = MEMORY[0x1E4F143A8];
    var10[1] = 0x40000000;
    var10[2] = __FastRegistration_register_block_invoke_2;
    var10[3] = &unk_1E57731E0;
    dispatch_async(v43, &block);
    dispatch_async(v61, var10);
    dispatch_barrier_sync(v61, &__block_literal_global_10);
  }
  else
  {
    int v62 = Projections_computeShiftBruteForce(v42[4], v55, v42 + 6, *(void *)(v53 + 32), v56, (void *)(v53 + 48), v58, (float *)&STACK[0x6720], 0.0, &a42, v44, v45);
    *((_DWORD *)a38 + 6) = v62;
    if (v62 < 0)
    {
      int v65 = v62;
      StatusDescription = Projections_getStatusDescription(v62);
      syslog(3, "Projections error %d:%s in %s @ %s:%d\n", v65, StatusDescription, "FastRegistration_status FastRegistration_register(const FastRegistration_Signatures *, const FastRegistration_Signatures *, float, dispatch_queue_t, float *, float *, float *, float *)", "/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage/Framework/api/Burst/Projections/FastRegistration_Core.c", 185);
      goto LABEL_13;
    }
    int v63 = Projections_computeShiftBruteForce(*v54, *((_DWORD *)v54 + 2), v54 + 2, *(void *)v53, *(_DWORD *)(v53 + 8), (void *)(v53 + 16), v60, (float *)&STACK[0x6720], 0.0, &a42, v50, v48);
    *((_DWORD *)a34 + 6) = v63;
    if (v63 < 0)
    {
      int v64 = v63;
      uint64_t v68 = Projections_getStatusDescription(v63);
      syslog(3, "Projections error %d:%s in %s @ %s:%d\n", v64, v68, "FastRegistration_status FastRegistration_register(const FastRegistration_Signatures *, const FastRegistration_Signatures *, float, dispatch_queue_t, float *, float *, float *, float *)", "/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage/Framework/api/Burst/Projections/FastRegistration_Core.c", 195);
      goto LABEL_13;
    }
  }
  *unint64_t v51 = -*v51;
  *uint64_t v50 = -*v50;
LABEL_13:
  if (*((_DWORD *)a38 + 6) || *((_DWORD *)a34 + 6)) {
    uint64_t v66 = 4294967289;
  }
  else {
    uint64_t v66 = 0;
  }
  _Block_object_dispose(&a33, 8);
  _Block_object_dispose(&a37, 8);
  return v66;
}

uint64_t FastRegistration_compareSignatures@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, float *a3@<X2>, vDSP_Length *a4@<X3>, float *a5@<X4>, vDSP_Length *a6@<X5>, uint64_t a7@<X8>, float a8@<S0>, float a9@<S1>)
{
  FastRegistration_compareSignature(a1[4], a1[5], a2[4], a2[5], a3, a4, a7, a8);
  FastRegistration_compareSignature(*a1, a1[1], *a2, a2[1], a5, a6, v14, a9);
  return 0;
}

void FastRegistration_compareSignature(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, int a4@<W3>, float *a5@<X4>, vDSP_Length *a6@<X5>, uint64_t a7@<X8>, float a8@<S0>)
{
  LODWORD(a7) = vcvtms_s32_f32(a8 + 0.5);
  uint64_t v10 = -(int)a7;
  int v11 = ~a7 + a2;
  if (v11 >= a4) {
    int v11 = a4 - 1;
  }
  int v12 = v11 + a7;
  int v13 = a7 + a4;
  if ((int)a7 + a4 >= a2) {
    int v13 = a2;
  }
  int v14 = v13 + ~a7;
  BOOL v15 = (int)a7 >= 0;
  if ((int)a7 >= 0) {
    uint64_t v10 = 0;
  }
  else {
    a7 = 0;
  }
  if (!v15) {
    int v14 = v12;
  }
  vDSP_Length v16 = v14 + 1;
  vDSP_vsub((const float *)(a1 + 4 * a7), 1, (const float *)(a3 + 4 * v10), 1, a5, 1, v16);
  vDSP_vabs(a5, 1, a5, 1, v16);
  *a6 = v16;
}

char *allocateSignatureBuffers(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result = 0;
  if (a1 && a2)
  {
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 4_Block_object_dispose(&STACK[0x238], 8) = 0u;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    uint64_t v7 = *(void *)(a2 + 8);
    uint64_t v6 = *(void *)(a2 + 16);
    *(void *)(a1 + 40) = v6;
    *(void *)(a1 + _Block_object_dispose(&STACK[0x238], 8) = v7;
    LODWORD(v6) = 4 * v6;
    int v8 = (v6 + 31) & 0xFFFFFFE0;
    LODWORD(v7) = 4 * v7;
    int v9 = (v7 + 31) & 0xFFFFFFE0;
    int v10 = (v6 + 35) & 0xFFFFFFE0;
    int v11 = (v7 + 35) & 0xFFFFFFE0;
    int v12 = 2 * (v11 + v10);
    if (!a3) {
      int v12 = 0;
    }
    uint64_t result = (char *)malloc_type_calloc(1uLL, v9 + v8 + v12, 0xD30F4451uLL);
    if (result)
    {
      *(void *)(a1 + 32) = result;
      int v13 = &result[v8];
      *(void *)a1 = v13;
      if (a3)
      {
        int v14 = &v13[v9];
        BOOL v15 = &v14[v11];
        *(void *)(a1 + 16) = v14;
        *(void *)(a1 + 24) = v15;
        vDSP_Length v16 = &v15[v11];
        *(void *)(a1 + 4_Block_object_dispose(&STACK[0x238], 8) = v16;
        *(void *)(a1 + 56) = &v16[v10];
      }
    }
  }
  return result;
}

void CI::SWContext::SWContext(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a4)
  {
    int v13 = a4;
    if ((int)CI::format_bits_per_component(a4) > 8) {
      goto LABEL_6;
    }
    int v14 = ci_logger_api();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint8_t buf = 0;
      _os_log_impl(&dword_193671000, v14, OS_LOG_TYPE_INFO, "Software context does not yet support 8bit working format", buf, 2u);
    }
  }
  int v13 = 2056;
LABEL_6:
  CI::Context::Context(a1, a2, a3, v13, a5, a6, a7, 0);
}

void CI::SWContext::~SWContext(CI::SWContext *this)
{
  *(void *)this = &unk_1EE456E80;
  *((void *)this + 4_Block_object_dispose(&STACK[0x238], 8) = &unk_1EE457100;
  uint64_t v2 = (CI::Object *)*((void *)this + 49);
  if (v2) {
    CI::Object::unref(v2);
  }
  uint64_t v3 = *((void *)this + 51);
  *((void *)this + 51) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 32))(v3);
  }
  *((void *)this + 4_Block_object_dispose(&STACK[0x238], 8) = &unk_1EE45B1B0;
  atomic_fetch_add(&dword_1EB466F58[17], 0xFFFFFFFF);

  CI::Context::~Context((CGColorSpaceRef *)this);
}

{
  uint64_t vars8;

  CI::SWContext::~SWContext(this);

  JUMPOUT(0x1997023B0);
}

void non-virtual thunk to'CI::SWContext::~SWContext(CI::SWContext *this)
{
}

{
  uint64_t vars8;

  CI::SWContext::~SWContext((CI::SWContext *)((char *)this - 384));

  JUMPOUT(0x1997023B0);
}

void *CI::SWContext::deviceName(CI::SWContext *this)
{
  if (CI::SWContext::deviceName(void)const::onceToken != -1) {
    dispatch_once(&CI::SWContext::deviceName(void)const::onceToken, &__block_literal_global_73);
  }
  return &CI::SWContext::deviceName(void)const::name;
}

uint64_t ___ZNK2CI9SWContext10deviceNameEv_block_invoke()
{
  size_t v1 = 64;
  return sysctlbyname("machdep.cpu.brand_string", &CI::SWContext::deviceName(void)const::name, &v1, 0, 0);
}

uint64_t CI::SWContext::max_texture_size(CI::SWContext *this)
{
  iosurface_limits((uint64_t)v2);
  return v2[0];
}

uint64_t CI::SWContext::max_input_image_size(CI::SWContext *this)
{
  iosurface_limits((uint64_t)v2);
  return v2[0];
}

uint64_t CI::SWContext::max_output_image_size(CI::SWContext *this)
{
  iosurface_limits((uint64_t)v2);
  return v2[0];
}

uint64_t CI::SWContext::max_texture_image_units(CI::SWContext *this)
{
  return 0xFFFFFFFFLL;
}

uint64_t CI::SWContext::max_fragment_uniform_vectors(CI::SWContext *this)
{
  return 0xFFFFFFFFLL;
}

uint64_t CI::SWContext::max_fragment_uniform_size(CI::SWContext *this)
{
  return 0xFFFFFFFFLL;
}

uint64_t CI::SWContext::max_render_load_bytes(CI::SWContext *this)
{
  return 0x20000000;
}

uint64_t CI::SWContext::max_device_memory(CI::SWContext *this)
{
  return 0xFFFFFFFFLL;
}

uint64_t CI::SWContext::createMainProgram()
{
  return 0;
}

double CI::SWContext::sampler_transform_for_extent@<D0>(const CGRect *a1@<X1>, double *a2@<X8>)
{
  double y = a1->origin.y;
  double v4 = 1.0 / a1->size.height;
  CGFloat v5 = a1->origin.x * -0.0 - y * v4 + 0.0;
  double v6 = 1.0 / a1->size.width;
  double v7 = y * -0.0 - a1->origin.x * v6;
  *a2 = v6 + 0.0;
  a2[1] = v4 * 0.0 + 0.0;
  a2[2] = v6 * 0.0 + 0.0;
  a2[3] = v4 + 0.0;
  double result = v7 + 0.0;
  a2[4] = result;
  a2[5] = v5;
  return result;
}

uint64_t CI::SWContext::format_is_directly_supported_for_input(uint64_t a1, int a2)
{
  if (CI::format_is_ycc_biplanar(a2))
  {
    uint64_t v4 = CI::format_of_plane(a2, 0);
    uint64_t v5 = CI::format_of_plane(a2, 1);
    LODWORD(v4) = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 424))(a1, v4);
    return v4 & (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a1 + 424))(a1, v5);
  }
  uint64_t result = 1;
  if (a2 > 1796)
  {
    if ((a2 - 1797) >= 4 && (a2 - 2053) >= 4 && (a2 - 2309) >= 4) {
      return 0;
    }
  }
  else if (((a2 - 257) > 0xA || ((1 << (a2 - 1)) & 0x7F1) == 0) {
         && ((a2 - 773) > 0xC || ((1 << (a2 - 5)) & 0x1003) == 0)
  }
         && (a2 - 1285) >= 2)
  {
    return 0;
  }
  return result;
}

uint64_t CI::SWContext::format_is_directly_supported_for_output(uint64_t a1, int a2)
{
  uint64_t result = 1;
  if (a2 > 1796)
  {
    if ((a2 - 1797) < 4 || (a2 - 2053) < 4 || (a2 - 2309) < 4) {
      return result;
    }
    return 0;
  }
  if (((a2 - 261) > 5 || a2 == 265)
    && ((a2 - 773) > 0xC || ((1 << (a2 - 5)) & 0x1803) == 0))
  {
    return 0;
  }
  return result;
}

uint64_t CI::SWContext::bind_cgimage()
{
  return 0;
}

uint64_t CI::SWContext::bind_surface()
{
  return 0;
}

uint64_t CI::SWContext::bind_texture()
{
  return 0;
}

{
  return 0;
}

uint64_t CI::SWContext::bind_intermediate()
{
  return 0;
}

uint64_t CI::SWContext::set_bitmap_destination(uint64_t result, CI::Object *this)
{
  if (this)
  {
    *(void *)(result + 392) = this;
    return CI::Object::ref((uint64_t)this);
  }
  return result;
}

uint64_t CI::SWContext::set_surface_destination(uint64_t result, IOSurfaceRef buffer)
{
  if (buffer)
  {
    *(void *)(result + 400) = buffer;
    IOSurfaceLock(buffer, 0, 0);
    operator new();
  }
  return result;
}

uint64_t CI::SWContext::set_texture_destination(CI::SWContext *this, Texture a2, const CGSize *a3)
{
  return 0;
}

uint64_t CI::SWContext::set_user_destination(CI::SWContext *this)
{
  return 0;
}

uint64_t CI::SWContext::unset_destination(CI::SWContext *this)
{
  uint64_t v2 = (CI::Object *)*((void *)this + 49);
  if (v2) {
    CI::Object::unref(v2);
  }
  *((void *)this + 49) = 0;
  uint64_t result = IOSurfaceUnlock(*((IOSurfaceRef *)this + 50), 0, 0);
  *((void *)this + 50) = 0;
  return result;
}

void CI::SWContext::render_node(CI::SWContext *this, dispatch_queue_t *a2, const CGRect *a3, const CGRect *a4, const CI::Bitmap *a5)
{
  v131[19] = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    uint64_t v67 = ci_logger_render();
    if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR)) {
      CI::SWContext::render_node(v67, v68, v69, v70, v71, v72, v73, v74);
    }
LABEL_76:
    abort();
  }
  if (!a5)
  {
    uint64_t v75 = ci_logger_render();
    if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
    {
      CI::SWContext::render_node(v75, v76, v77, v78, v79, v80, v81, v82);
      abort();
    }
    goto LABEL_76;
  }
  if (!(*((void *)a5 + 11) * *((void *)a5 + 10)))
  {
    char v83 = ci_logger_render();
    if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
    {
      CI::SWContext::render_node((uint64_t *)a5 + 10, (uint64_t *)a5 + 11, v83);
      abort();
    }
    goto LABEL_76;
  }
  int v8 = (CI::ProgramNode *)a2;
  dispatch_queue_t v9 = CI::ProgramNode::mainProgram(a2);
  if (v9)
  {
    int v10 = (CI::MainProgram *)v9;
    CGRectIntersection(*a3, *a4);
    if (*((unsigned char *)v8 + 148))
    {
      CGFloat MidY = CGRectGetMidY(*a4);
      CGFloat v12 = MidY + MidY;
      CGRect v132 = *a3;
      v127.b = 0.0;
      v127.double c = 0.0;
      v127.double a = 1.0;
      *(_OWORD *)&v127.d = xmmword_193951E50;
      v127.tdouble y = v12;
      CGRect v133 = CGRectApplyAffineTransform(v132, &v127);
      CGRectIntersection(v133, *a4);
    }
    int v13 = CI::MainProgram::num_arguments(v10);
    dispatch_sync(*((dispatch_queue_t *)v8 + 13), &__block_literal_global_33);
    uint64_t v14 = *((void *)v8 + 16);
    int v15 = *(_DWORD *)v14;
    int v120 = 0;
    uint64_t v119 = 0;
    long long v121 = 0u;
    long long v122 = 0u;
    long long v123 = 0u;
    long long v124 = 0u;
    long long v125 = 0u;
    uint64_t v126 = 0;
    if (v15 > 10)
    {
      HIDWORD(v119) = v15;
      vDSP_Length v16 = malloc_type_calloc((v15 - 10), 8uLL, 0x80040B8603338uLL);
    }
    else
    {
      vDSP_Length v16 = 0;
      HIDWORD(v119) = 10;
    }
    *(void *)&long long v121 = v16;
    if (v15 <= 1) {
      int v17 = 1;
    }
    else {
      int v17 = v15;
    }
    int v120 = v17;
    if (*(_DWORD *)v14 == v13)
    {
      if (v13 > 0)
      {
        unint64_t v18 = 0;
        *(void *)double v112 = v13;
        int v19 = (CI::Vector **)(v14 + 24);
        uint64_t v109 = v14;
        double v110 = v8;
        while (1)
        {
          int v20 = (*(uint64_t (**)(CI::MainProgram *, unint64_t))(*(void *)v10 + 40))(v10, v18);
          float v21 = v19;
          if (v18 >= 0xA) {
            float v21 = (CI::Vector **)(*(void *)(v14 + 16) + 8 * (v18 - 10));
          }
          uint64_t v22 = *v21;
          if (v20 > 39) {
            break;
          }
          if ((v20 - 1) >= 4) {
            goto LABEL_41;
          }
          if ((*(unsigned int (**)(CI::Vector *))(*(void *)v22 + 16))(v22) != 60) {
            goto LABEL_68;
          }
          CI::ProgramNode::child_can_sample_nearest(v8, *((_DWORD *)v22 + 8));
          CI::ProgramNode::roiKeys_of_child(v8, *a3, *((unsigned int *)v22 + 8), __p);
          if (*(void *)&__p[0].origin.y == *(void *)&__p[0].origin.x)
          {
            unint64_t v51 = ci_logger_render();
            if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
            {
              CI::SWContext::render_node(v51, v52, v53, v54, v55, v56, v57, v58);
              abort();
            }
            goto LABEL_76;
          }
          *(_OWORD *)double v114 = **(_OWORD **)&__p[0].origin.x;
          float v23 = (CGImageRef *)*((void *)v22 + 3);
          if (!v23)
          {
            unint64_t v59 = ci_logger_render();
            if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
            {
              CI::SWContext::render_node(v59, v60, v61, v62, v63, v64, v65, v66);
              abort();
            }
            goto LABEL_76;
          }
          v118[0] = 0;
          v118[1] = 0;
          int v24 = (*((uint64_t (**)(CGImageRef *))*v23 + 2))(v23);
          if (v24 > 45)
          {
            if (v24 == 52)
            {
              v137.origin.double x = CI::Node::roi(v114[0], (int)v114[1]);
              if (CGRectIsEmpty(v137)) {
                operator new();
              }
              uint64_t v37 = (*(uint64_t (**)(CI::SWContext *))(*(void *)this + 112))(this);
              uint64_t intermediate_for_node = CI::TextureManager::get_intermediate_for_node(v37, (uint64_t)v114);
              if (((_BYTE)v23[18] & 4) != 0)
              {
                uint64_t v39 = (*(uint64_t (**)(CI::SWContext *))(*(void *)this + 112))(this);
                (*(void (**)(uint64_t, uint64_t))(*(void *)v39 + 56))(v39, intermediate_for_node);
              }
              operator new();
            }
            if (v24 == 46)
            {
              v135.origin.double x = CI::Node::roi(v114[0], (int)v114[1]);
              if (!CGRectIsEmpty(v135)) {
                operator new();
              }
              double v92 = ci_logger_render();
              if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
              {
                CI::SWContext::render_node(v92, v93, v94, v95, v96, v97, v98, v99);
                abort();
              }
              goto LABEL_76;
            }
          }
          else
          {
            if (v24 == 29)
            {
              v136.origin.double x = CI::Node::roi(v114[0], (int)v114[1]);
              if (!CGRectIsEmpty(v136))
              {
                buf.origin.double x = CI::Node::roi(v114[0], (int)v114[1]);
                buf.origin.double y = v34;
                buf.size.double width = v35;
                buf.size.double height = v36;
                CI::CGNode::cgImageForROI(v23, &buf, (CGImageRef *)&cf);
                operator new();
              }
              double v100 = ci_logger_render();
              if (os_log_type_enabled(v100, OS_LOG_TYPE_ERROR))
              {
                CI::SWContext::render_node(v100, v101, v102, v103, v104, v105, v106, v107);
                abort();
              }
              goto LABEL_76;
            }
            if (v24 == 44)
            {
              v134.origin.double x = CI::Node::roi(v114[0], (int)v114[1]);
              if (!CGRectIsEmpty(v134))
              {
                buf.origin.double x = CI::Node::roi(v114[0], (int)v114[1]);
                buf.origin.double y = v25;
                buf.size.double width = v26;
                buf.size.double height = v27;
                CI::ProviderNode::surfaceForROI((uint64_t)v23, this, &buf.origin.x, (uint64_t)v118);
                operator new();
              }
              double v84 = ci_logger_render();
              if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR))
              {
                CI::SWContext::render_node(v84, v85, v86, v87, v88, v89, v90, v91);
                abort();
              }
              goto LABEL_76;
            }
          }
          if (!MEMORY[0x48])
          {
            v138.origin.double x = CI::Node::roi(v114[0], (int)v114[1]);
            if (!CGRectIsEmpty(v138))
            {
              int v40 = ci_logger_render();
              if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
              {
                uint64_t v41 = (*((uint64_t (**)(CGImageRef *))*v23 + 13))(v23);
                int v42 = *((_DWORD *)v23 + 9);
                LODWORD(buf.origin.x) = 136446722;
                *(void *)((char *)&buf.origin.x + 4) = "void CI::SWContext::render_node(ProgramNode *, const CGRect &, "
                                                         "const CGRect &, const Bitmap *)";
                WORD2(buf.origin.y) = 2080;
                *(void *)((char *)&buf.origin.y + 6) = v41;
                HIWORD(buf.size.width) = 1024;
                LODWORD(buf.size.height) = v42;
                _os_log_error_impl(&dword_193671000, v40, OS_LOG_TYPE_ERROR, "%{public}s: Bad bitmap argument for %s:%d leaf", (uint8_t *)&buf, 0x1Cu);
              }
            }
          }
          CI::SerialObjectPtrArray::append((uint64_t)&v119, 0);
          CI::Object::unref(0);
          uint64_t v14 = v109;
          if (*(void *)&__p[0].origin.x)
          {
            __p[0].origin.double y = __p[0].origin.x;
            operator delete(*(void **)&__p[0].origin.x);
          }
          int v8 = v110;
LABEL_56:
          ++v18;
          ++v19;
          if (*(void *)v112 == v18) {
            goto LABEL_57;
          }
        }
        if ((v20 - 44) < 2)
        {
          if ((*(unsigned int (**)(CI::Vector *))(*(void *)v22 + 16))(v22) == 58)
          {
            CI::Vector::affine(v22, &buf.origin.x);
            operator new();
          }
          goto LABEL_68;
        }
        if (v20 == 40)
        {
          if ((*(unsigned int (**)(CI::Vector *))(*(void *)v22 + 16))(v22) == 60)
          {
            memset(&buf, 0, sizeof(buf));
            buf.origin.double x = CI::Node::region_of_child(v8, *a3);
            buf.origin.double y = v31;
            buf.size.double width = v32;
            buf.size.double height = v33;
            operator new();
          }
          goto LABEL_68;
        }
        if (v20 == 41)
        {
          if ((*(unsigned int (**)(CI::Vector *))(*(void *)v22 + 16))(v22) == 60)
          {
            memset(__p, 0, 32);
            __p[0].origin.double x = CI::Node::region_of_child(v8, *a3);
            __p[0].origin.double y = v28;
            __p[0].size.double width = v29;
            __p[0].size.double height = v30;
            CI::TextureSampler::transform(v22, this, __p, (float64x2_t *)&buf);
            operator new();
          }
          goto LABEL_68;
        }
LABEL_41:
        CI::SerialObjectPtrArray::append((uint64_t)&v119, v22);
        goto LABEL_56;
      }
LABEL_57:
      std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn180100]((uint64_t)&buf);
      uint64_t v43 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&buf.size.width, (uint64_t)"CI::SWContextRenderQ", 20);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v43, (uint64_t)"-", 1);
      (*(void (**)(CI::SWContext *))(*(void *)this + 272))(this);
      int v44 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v44, (uint64_t)"-", 1);
      std::ostream::operator<<();
      std::stringbuf::str[abi:nn180100]<std::allocator<char>>((uint64_t)&buf.size.height, v114);
      if (v115 >= 0) {
        float32x2_t v45 = (char *)v114;
      }
      else {
        float32x2_t v45 = (char *)v114[0];
      }
      QueuePool<4>::QueuePool((uint64_t)__p, v45);
      if (SHIBYTE(v115) < 0) {
        operator delete(v114[0]);
      }
      v114[0] = 0;
      v114[1] = 0;
      uint64_t v115 = 0;
      unint64_t v46 = vcvtd_n_u64_f64(ceil(a3->size.height * 0.125), 3uLL);
      unsigned int v47 = atomic_load((unsigned int *)a5 + 2);
      int v113 = v47;
      if (v46)
      {
        dispatch_queue_attr_t v48 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
        QueuePool<4>::get_new((uint64_t)__p, (uint64_t)v48);
      }
      int v49 = atomic_load((unsigned int *)a5 + 2);
      if (v47 != v49)
      {
        double v108 = ci_logger_render();
        if (os_log_type_enabled(v108, OS_LOG_TYPE_ERROR))
        {
          CI::SWContext::render_node(v113, v49, v108);
          abort();
        }
        goto LABEL_76;
      }
      QueuePool<4>::~QueuePool((uint64_t)__p);
      buf.origin.double x = *(CGFloat *)MEMORY[0x1E4FBA408];
      CGFloat v50 = *(double *)(MEMORY[0x1E4FBA408] + 72);
      *(CGFloat *)((char *)&buf.origin.x + *(void *)(*(void *)&buf.origin.x - 24)) = *(CGFloat *)(MEMORY[0x1E4FBA408] + 64);
      buf.size.double width = v50;
      *(void *)&buf.size.double height = MEMORY[0x1E4FBA470] + 16;
      if (v130 < 0) {
        operator delete(v129);
      }
      std::streambuf::~streambuf();
      std::iostream::~basic_iostream();
      MEMORY[0x199702340](v131);
    }
LABEL_68:
    CI::SerialObjectPtrArray::~SerialObjectPtrArray((CI::SerialObjectPtrArray *)&v119);
  }
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA488] + 24;
  uint64_t v3 = MEMORY[0x1E4FBA488] + 104;
  *(void *)(a1 + 12_Block_object_dispose(&STACK[0x238], 8) = MEMORY[0x1E4FBA488] + 104;
  uint64_t v4 = a1 + 16;
  uint64_t v5 = MEMORY[0x1E4FBA488] + 64;
  *(void *)(a1 + 16) = MEMORY[0x1E4FBA488] + 64;
  double v6 = (void *)MEMORY[0x1E4FBA408];
  uint64_t v7 = *(void *)(MEMORY[0x1E4FBA408] + 24);
  uint64_t v8 = *(void *)(MEMORY[0x1E4FBA408] + 16);
  *(void *)a1 = v8;
  *(void *)(a1 + *(void *)(v8 - 24)) = v7;
  *(void *)(a1 + _Block_object_dispose(&STACK[0x238], 8) = 0;
  dispatch_queue_t v9 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v9, (void *)(a1 + 24));
  v9[1].__vftable = 0;
  v9[1].__fmtflags_ = -1;
  uint64_t v10 = v6[5];
  uint64_t v11 = v6[4];
  *(void *)(a1 + 16) = v11;
  *(void *)(v4 + *(void *)(v11 - 24)) = v10;
  uint64_t v12 = v6[1];
  *(void *)a1 = v12;
  *(void *)(a1 + *(void *)(v12 - 24)) = v6[6];
  *(void *)a1 = v2;
  *(void *)(a1 + 12_Block_object_dispose(&STACK[0x238], 8) = v3;
  *(void *)(a1 + 16) = v5;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 24) = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)(a1 + 8_Block_object_dispose(&STACK[0x238], 8) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 120) = 24;
  return a1;
}

void QueuePool<4>::get_new(uint64_t a1, uint64_t a2)
{
  v4[0] = 0;
  v4[1] = v4;
  v4[2] = 0x2000000000;
  _OWORD v4[3] = 0;
  uint64_t v2 = *(NSObject **)(a1 + 8);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZN9QueuePoolILi4EE7get_newEP21dispatch_queue_attr_s_block_invoke;
  block[3] = &unk_1E5770518;
  block[4] = v4;
  block[5] = a1;
  void block[6] = a2;
  dispatch_sync(v2, block);
  operator new();
}

uint64_t CI::SWContext::render_root_node(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn180100]((uint64_t)v19);
  uint64_t v10 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v20, (uint64_t)"CI::SWContext-root", 18);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v10, (uint64_t)"-", 1);
  (*(void (**)(uint64_t))(*(void *)a1 + 272))(a1);
  uint64_t v11 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v11, (uint64_t)"-", 1);
  std::ostream::operator<<();
  std::stringbuf::str[abi:nn180100]<std::allocator<char>>((uint64_t)v21, __p);
  if (v18 >= 0) {
    uint64_t v12 = __p;
  }
  else {
    uint64_t v12 = (void **)__p[0];
  }
  int v13 = dispatch_queue_create((const char *)v12, 0);
  if (v18 < 0) {
    operator delete(__p[0]);
  }
  v16[0] = MEMORY[0x1E4F143A8];
  v16[1] = 0x40000000;
  v16[2] = ___ZN2CI9SWContext16render_root_nodeEPNS_8TileTaskERKNS_9parentROIEU13block_pointerFvvES7__block_invoke;
  void v16[3] = &unk_1E5773228;
  v16[6] = a1;
  v16[7] = a3;
  v16[8] = a2;
  v16[4] = a4;
  void v16[5] = a5;
  dispatch_sync(v13, v16);
  dispatch_release(v13);
  v19[0] = *MEMORY[0x1E4FBA408];
  uint64_t v14 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)v19 + *(void *)(v19[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  uint64_t v20 = v14;
  v21[0] = MEMORY[0x1E4FBA470] + 16;
  if (v22 < 0) {
    operator delete((void *)v21[8]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x199702340](&v23);
}

void ___ZN2CI9SWContext16render_root_nodeEPNS_8TileTaskERKNS_9parentROIEU13block_pointerFvvES7__block_invoke(uint64_t a1)
{
  void v24[6] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(CI::SWContext **)(a1 + 48);
  uint64_t v2 = *(CI::parentROI **)(a1 + 56);
  uint64_t v4 = *(void *)v2;
  v21.origin.double x = CI::parentROI::roi(v2);
  v21.origin.double y = v5;
  v21.size.double width = v6;
  v21.size.double height = v7;
  if (CI_VERBOSE_SIGNPOSTS())
  {
    uint64_t v8 = ci_signpost_log_render();
    os_signpost_id_t v9 = *(int *)(v4 + 36) | (unint64_t)((*(uint64_t (**)(CI::SWContext *))(*(void *)v3 + 272))(v3) << 32);
    if (v9 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v8))
    {
      *(_DWORD *)CGRect buf = 68289026;
      int v23 = 256;
      LOWORD(v24[0]) = 2082;
      *(void *)((char *)v24 + 2) = CI::Context::programName((dispatch_queue_t *)v4, v10);
      _os_signpost_emit_with_name_impl(&dword_193671000, v8, OS_SIGNPOST_INTERVAL_BEGIN, v9, "render_node", "%{public}.256s", buf, 0x12u);
    }
  }
  uint64_t v11 = (*(uint64_t (**)(CI::SWContext *))(*(void *)v3 + 272))(v3);
  TimerBase::TimerBase((uint64_t)buf, v11, *(_DWORD *)(v4 + 36), (uint64_t)"render_node", 0);
  double Current = CFAbsoluteTimeGetCurrent();
  CI::TileTask::addROIForNode(*(CI::TileTask **)(a1 + 64), (CI::ProgramNode *)v4, &v21);
  int v13 = (uint64x2_t *)*((void *)v3 + 49);
  v20.origin.double x = 0.0;
  v20.origin.double y = 0.0;
  v20.size_t size = (CGSize)vcvtq_f64_u64(v13[5]);
  CI::SWContext::render_node(v3, (dispatch_queue_t *)v4, &v21, &v20, (const CI::Bitmap *)v13);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  uint64_t v14 = *(CI::TileTask **)(a1 + 64);
  CFAbsoluteTime v15 = CFAbsoluteTimeGetCurrent();
  CI::TileTask::incrementTimeForNode(v14, (const CI::ProgramNode *)v4, v15 - Current);
  uint64_t v16 = *(void *)(a1 + 64);
  *(CFAbsoluteTime *)(v16 + 40) = CFAbsoluteTimeGetCurrent();
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  if (CI_VERBOSE_SIGNPOSTS())
  {
    int v17 = ci_signpost_log_render();
    os_signpost_id_t v18 = v24[0];
    if ((unint64_t)(v24[0] - 1) <= 0xFFFFFFFFFFFFFFFDLL)
    {
      int v19 = v17;
      if (os_signpost_enabled(v17))
      {
        LOWORD(v20.origin.x) = 0;
        _os_signpost_emit_with_name_impl(&dword_193671000, v19, OS_SIGNPOST_INTERVAL_END, v18, "render_node", "", (uint8_t *)&v20, 2u);
      }
    }
  }
  TimerBase::~TimerBase((TimerBase *)buf);
}

const char *CI::Context::programName(dispatch_queue_t *this, const CI::ProgramNode *a2)
{
  if (!this) {
    return "";
  }
  if (CI::ProgramNode::mainProgram(this) && CI::ProgramNode::mainProgram(this)[6].isa) {
    return (const char *)CI::ProgramNode::mainProgram(this)[6].isa;
  }
  return "";
}

void CI::SWContext::render_intermediate_node(uint64_t a1, CFAbsoluteTime *a2, CI::parentROI *this, uint64_t (***a4)(void), uint64_t a5, uint64_t a6)
{
  v40[19] = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *(void *)this;
  v34.origin.double x = CI::parentROI::roi(this);
  v34.origin.double y = v11;
  v34.size.double width = v12;
  v34.size.double height = v13;
  if (CI_VERBOSE_SIGNPOSTS())
  {
    uint64_t v14 = ci_signpost_log_render();
    os_signpost_id_t v15 = *(int *)(v10 + 36) | (unint64_t)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 272))(a1) << 32);
    if (v15 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v14))
    {
      *(_DWORD *)CGRect buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 256;
      __int16 v36 = 2082;
      *(void *)uint64_t v37 = CI::Context::programName((dispatch_queue_t *)v10, v16);
      _os_signpost_emit_with_name_impl(&dword_193671000, v14, OS_SIGNPOST_INTERVAL_BEGIN, v15, "render_node", "%{public}.256s", buf, 0x12u);
    }
  }
  uint64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 272))(a1);
  TimerBase::TimerBase((uint64_t)v32, v17, *(_DWORD *)(v10 + 36), (uint64_t)"render_node", 0);
  double Current = CFAbsoluteTimeGetCurrent();
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn180100]((uint64_t)buf);
  int v19 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v37[6], (uint64_t)"CI::SWContext-intermediate", 26);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)"-", 1);
  (*(void (**)(uint64_t))(*(void *)a1 + 272))(a1);
  CGRect v20 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)"-", 1);
  std::ostream::operator<<();
  std::stringbuf::str[abi:nn180100]<std::allocator<char>>((uint64_t)v38, __p);
  if (v31 >= 0) {
    CGRect v21 = __p;
  }
  else {
    CGRect v21 = (void **)__p[0];
  }
  char v22 = dispatch_queue_create((const char *)v21, 0);
  if (v31 < 0) {
    operator delete(__p[0]);
  }
  CI::TileTask::addROIForNode((CI::TileTask *)a2, (CI::ProgramNode *)v10, &v34);
  if ((**a4)(a4))
  {
    v28[0] = MEMORY[0x1E4F143A8];
    v28[1] = 0x40000000;
    CGRect v29 = v34;
    v28[2] = ___ZN2CI9SWContext24render_intermediate_nodeEPNS_8TileTaskERKNS_9parentROIEPNS_14intermediate_tEbU13block_pointerFvvE_block_invoke;
    v28[3] = &__block_descriptor_tmp_7_2;
    v28[4] = a1;
    void v28[5] = a4;
    void v28[6] = v10;
    dispatch_sync(v22, v28);
    dispatch_release(v22);
    CFAbsoluteTime v23 = CFAbsoluteTimeGetCurrent();
    CI::TileTask::incrementTimeForNode((CI::TileTask *)a2, (const CI::ProgramNode *)v10, v23 - Current);
    a2[5] = CFAbsoluteTimeGetCurrent();
    (*(void (**)(uint64_t))(a6 + 16))(a6);
  }
  *(void *)CGRect buf = *MEMORY[0x1E4FBA408];
  uint64_t v24 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)&buf[*(void *)(*(void *)buf - 24)] = *(void *)(MEMORY[0x1E4FBA408] + 64);
  *(void *)&v37[6] = v24;
  v38[0] = MEMORY[0x1E4FBA470] + 16;
  if (v39 < 0) {
    operator delete((void *)v38[8]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x199702340](v40);
  if (CI_VERBOSE_SIGNPOSTS())
  {
    CGFloat v25 = ci_signpost_log_render();
    os_signpost_id_t v26 = v33;
    if (v33 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      CGFloat v27 = v25;
      if (os_signpost_enabled(v25))
      {
        *(_WORD *)CGRect buf = 0;
        _os_signpost_emit_with_name_impl(&dword_193671000, v27, OS_SIGNPOST_INTERVAL_END, v26, "render_node", "", buf, 2u);
      }
    }
  }
  TimerBase::~TimerBase((TimerBase *)v32);
}

void ___ZN2CI9SWContext24render_intermediate_nodeEPNS_8TileTaskERKNS_9parentROIEPNS_14intermediate_tEbU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(CI::SWContext **)(a1 + 32);
  uint64_t v3 = (__IOSurface *)(***(uint64_t (****)(void))(a1 + 40))(*(void *)(a1 + 40));
  CI::Bitmap::Bitmap((CI::Bitmap *)v9, v3, 0);
  v9[0] = &unk_1EE4569D0;
  int32x4_t v4 = vdupq_n_s32(0x3B808081u);
  uint64_t v11 = v4.i64[0];
  int32x4_t v12 = v4;
  int32x4_t v13 = v4;
  int32x4_t v17 = v4;
  int32x4_t v18 = v4;
  int32x4_t v15 = v4;
  int32x4_t v16 = v4;
  int32x4_t v14 = v4;
  int32x4_t v5 = vdupq_n_s32(0x37800080u);
  v9[2] = &unk_1EE456A08;
  uint64_t v19 = v5.i64[0];
  int32x4_t v20 = v5;
  int32x4_t v21 = v5;
  int32x4_t v25 = v5;
  int32x4_t v26 = v5;
  int32x4_t v23 = v5;
  int32x4_t v24 = v5;
  int32x4_t v22 = v5;
  int32x4_t v6 = vdupq_n_s32(0x3A802008u);
  __int16 v10 = 0;
  uint64_t v27 = v6.i64[0];
  int32x4_t v29 = v6;
  int32x4_t v30 = v6;
  int32x4_t v28 = v6;
  CGFloat v7 = *(dispatch_queue_t **)(a1 + 48);
  uint64_t v8 = (const CGRect *)(*(uint64_t (**)(void))(**(void **)(a1 + 40) + 32))(*(void *)(a1 + 40));
  CI::SWContext::render_node(v2, v7, (const CGRect *)(a1 + 56), v8, (const CI::Bitmap *)v9);
  CI::Bitmap::~Bitmap((CI::Bitmap *)v9);
}

void CI::SWContext::after_render(IOSurfaceRef *this)
{
  uint64_t v2 = ci_signpost_log_render();
  os_signpost_id_t v3 = (*((uint64_t (**)(IOSurfaceRef *))*this + 34))(this) << 32;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)os_signpost_id_t v9 = 0;
    _os_signpost_emit_with_name_impl(&dword_193671000, v2, OS_SIGNPOST_INTERVAL_BEGIN, v3, "after_render", "", v9, 2u);
  }
  uint64_t v4 = (*((uint64_t (**)(IOSurfaceRef *))*this + 34))(this);
  TimerBase::TimerBase((uint64_t)v9, v4, 0, (uint64_t)"after_render", 8);
  IOSurfaceUnlock(this[50], 0, 0);
  this[50] = 0;
  int32x4_t v5 = this[49];
  if (v5) {
    CI::Object::unref(v5);
  }
  this[49] = 0;
  int32x4_t v6 = ci_signpost_log_render();
  os_signpost_id_t v7 = v10;
  if (v10 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v8 = v6;
    if (os_signpost_enabled(v6))
    {
      *(_WORD *)CGRect buf = 0;
      _os_signpost_emit_with_name_impl(&dword_193671000, v8, OS_SIGNPOST_INTERVAL_END, v7, "after_render", "", buf, 2u);
    }
  }
  TimerBase::~TimerBase((TimerBase *)v9);
}

void CI::SWTextureManager::~SWTextureManager(dispatch_queue_t *this)
{
  *this = (dispatch_queue_t)&unk_1EE456DA8;
  CI::TextureManager::purge_intermediates((CI::TextureManager *)this);
  dispatch_sync(this[12], &__block_literal_global_10_0);
  CI::TextureManager::remove_all((CI::TextureManager *)this);

  CI::TextureManager::~TextureManager(this);
}

{
  uint64_t vars8;

  CI::SWTextureManager::~SWTextureManager(this);

  JUMPOUT(0x1997023B0);
}

__CFDictionary *CI::SWContext::switch_dictionary(CI::SWContext *this)
{
  uint64_t result = (__CFDictionary *)*((void *)this + 52);
  if (!result)
  {
    Mutable = CFDictionaryCreateMutable(0, 3, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    *((void *)this + 52) = Mutable;
    __CFDictionary::setValue(Mutable, (__CFDictionary *)@"kContextInfoSupportsMPS", 0, v4);
    __CFDictionary::setValue(*((__CFDictionary **)this + 52), (__CFDictionary *)@"kContextInfoIsMetal", 0, v5);
    __CFDictionary::setValue(*((__CFDictionary **)this + 52), (__CFDictionary *)@"kContextInfoIsSoftware", (const __CFString *)1, v6);
    __CFDictionary::setValue(*((__CFDictionary **)this + 52), (__CFDictionary *)@"kContextInfoWorkingFormat", (const __CFString *)*((unsigned int *)this + 8));
    uint64_t v8 = (const void *)*((void *)this + 3);
    uint64_t result = (__CFDictionary *)*((void *)this + 52);
    if (v8)
    {
      __CFDictionary::setValue(result, @"kContextInfoWorkingSpace", v8, v7);
      return (__CFDictionary *)*((void *)this + 52);
    }
  }
  return result;
}

void __CFDictionary::setValue(__CFDictionary *this, __CFDictionary *a2, const __CFString *a3)
{
  int valuePtr = (int)a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  __CFDictionary::setValue(this, a2, v5, v6);
  if (v5) {
    CFRelease(v5);
  }
}

{
  CFNumberRef v5;
  const void *v6;
  CFStringRef valuePtr;

  int valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
  __CFDictionary::setValue(this, a2, v5, v6);
  if (v5) {
    CFRelease(v5);
  }
}

uint64_t CI::SWTextureManager::create_intermediate(uint64_t a1, uint64_t a2, uint64_t a3, CGFloat *a4, uint64_t a5, uint64_t a6, char a7)
{
  if ((a7 & 1) == 0)
  {
    CGFloat v7 = *a4;
    CGFloat v8 = a4[1];
    CGFloat v9 = a4[2];
    CGFloat v10 = a4[3];
    v13.origin.double x = *a4;
    v13.origin.double y = v8;
    v13.size.double width = v9;
    v13.size.double height = v10;
    if (!CGRectIsNull(v13))
    {
      v14.origin.double x = v7;
      v14.origin.double y = v8;
      v14.size.double width = v9;
      v14.size.double height = v10;
      if (CGRectIsInfinite(v14)
        || ((v15.origin.double x = v7,
             v15.origin.double y = v8,
             v15.size.double width = v9,
             v15.size.double height = v10,
             CGRect v16 = CGRectInset(v15, 0.000001, 0.000001),
             CGRect v17 = CGRectIntegral(v16),
             (unint64_t)v17.size.width)
          ? (BOOL v11 = (unint64_t)v17.size.height == 0)
          : (BOOL v11 = 1),
            !v11))
      {
        operator new();
      }
    }
  }
  return 0;
}

void ___ZN2CI16SWTextureManager19create_intermediateERKNS_22IntermediateDescriptorENS_17NodeContentDigestERK6CGRectmmb_block_invoke(void *a1)
{
  uint64_t v2 = *(uint64_t **)(a1[4] + 136);
  os_signpost_id_t v3 = operator new(0x18uLL);
  void v3[2] = a1[5];
  uint64_t v4 = *v2;
  *os_signpost_id_t v3 = *v2;
  v3[1] = v2;
  *(void *)(v4 + _Block_object_dispose(&STACK[0x238], 8) = v3;
  *uint64_t v2 = (uint64_t)v3;
  ++v2[2];
  CFNumberRef v5 = (uint64_t (***)(void))a1[5];
  if (v5 && (**v5)(v5) && a1[6] >= 2uLL)
  {
    unint64_t v6 = 1;
    do
    {
      CGFloat v7 = (const void *)(**(uint64_t (***)(void))a1[5])(a1[5]);
      RetainSurfaceFromCache(v7);
      ++v6;
    }
    while (v6 < a1[6]);
  }
}

uint64_t CI::TextureManager::create_intermediate()
{
  return 0;
}

void CI::TextureManager::convert_to_sRGB()
{
  uint64_t v0 = ci_logger_render();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR)) {
    CI::TextureManager::convert_to_sRGB(v0, v1, v2, v3, v4, v5, v6, v7);
  }
}

uint64_t CI::TextureManager::wiredBytes(CI::TextureManager *this)
{
  return 0;
}

uint64_t CI::SWContext::type(CI::SWContext *this)
{
  return 75;
}

uint64_t CI::Context::blitSurface()
{
  return 0;
}

uint64_t CI::SWContext::texture_manager(CI::SWContext *this)
{
  return *((void *)this + 51);
}

__n128 CI::Context::setCTM(CI::Context *this, CGAffineTransform *a2)
{
  __n128 result = *(__n128 *)&a2->a;
  long long v3 = *(_OWORD *)&a2->tx;
  *((_OWORD *)this + 7) = *(_OWORD *)&a2->c;
  *((_OWORD *)this + _Block_object_dispose(&STACK[0x238], 8) = v3;
  *((__n128 *)this + 6) = result;
  return result;
}

__n128 CI::Context::CTM@<Q0>(CI::Context *this@<X0>, uint64_t a2@<X8>)
{
  long long v2 = *((_OWORD *)this + 7);
  *(_OWORD *)a2 = *((_OWORD *)this + 6);
  *(_OWORD *)(a2 + 16) = v2;
  __n128 result = *((__n128 *)this + 8);
  *(__n128 *)(a2 + 32) = result;
  return result;
}

uint64_t CI::Context::setHLGOpticalScale(uint64_t this, float a2)
{
  *(float *)(this + 36) = a2;
  return this;
}

float CI::Context::HLGOpticalScale(CI::Context *this)
{
  return *((float *)this + 9);
}

uint64_t CI::Context::lossyIntermediates(CI::Context *this)
{
  return 0;
}

CGRect *CI::Context::setBounds(CGRect *this, CGRect a2)
{
  this[2] = a2;
  return this;
}

double CI::Context::bounds(CI::Context *this)
{
  return *((double *)this + 8);
}

float CI::Context::setQuality(CI::Context *this, float a2)
{
  float result = fmaxf(fminf(a2, 1.0), -1.0);
  *((float *)this + 14) = result;
  return result;
}

float CI::Context::quality(CI::Context *this)
{
  return *((float *)this + 14);
}

uint64_t CI::Context::setDownsampleQuality(uint64_t this, char a2)
{
  *(unsigned char *)(this + 60) = a2;
  return this;
}

uint64_t CI::Context::setCacheVolatility(uint64_t this, int a2)
{
  if (a2 < 0) {
    int v2 = -1;
  }
  else {
    int v2 = a2;
  }
  if (v2 >= 8) {
    int v2 = 8;
  }
  *(_DWORD *)(this + 232) = v2;
  return this;
}

uint64_t CI::Context::priority(CI::Context *this)
{
  return 0;
}

uint64_t CI::Context::setDefaultBlendingEnabled(uint64_t this, char a2)
{
  *(unsigned char *)(this + 300) = a2;
  return this;
}

uint64_t CI::Context::defaultBlendingEnabled(CI::Context *this)
{
  return *((unsigned __int8 *)this + 300);
}

uint64_t CI::SWContext::is_cpu(CI::SWContext *this)
{
  return 1;
}

const char *CI::SWContext::name(CI::SWContext *this)
{
  return "sw";
}

void CI::Context::destination_descriptor(uint64_t a1@<X8>)
{
  *(_DWORD *)a1 = 0;
  *(unsigned char *)(a1 + 4) = 0;
}

uint64_t CI::Context::set_texture_destination()
{
  return 0;
}

uint64_t CI::Context::set_texture_destination(CI::Context *this, Texture a2, const CGRect *a3)
{
  long long v4 = *(_OWORD *)a2.var0.var0;
  return (*(uint64_t (**)(CI::Context *, long long *, char *, const CGRect *))(*(void *)this + 368))(this, &v4, (char *)a2.var0.var2.var1 + 16, a3);
}

uint64_t CI::Context::max_kernel_arguments_size(CI::Context *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 480))();
}

uint64_t CI::Context::resticted_kernel_arguments_size(CI::Context *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 480))();
}

uint64_t CI::Context::bitmap_destination_rowbytes_alignment(uint64_t a1, int a2)
{
  if (CI::format_is_half_float(a2)) {
    return 8;
  }
  else {
    return 4;
  }
}

uint64_t CI::SWContext::surface_rowbytes_alignment_for_input()
{
  return 16;
}

uint64_t CI::SWContext::surface_rowbytes_alignment_for_output()
{
  return 16;
}

uint64_t CI::SWContext::supportsDeferredCGImage(CI::SWContext *this)
{
  return 1;
}

BOOL CI::SWContext::supports_edge_mode(uint64_t a1, int a2)
{
  return a2 == 1;
}

uint64_t CI::SWContext::supports_sample_mode()
{
  return 1;
}

uint64_t CI::SWContext::supported_compute_features(CI::SWContext *this)
{
  return 0;
}

uint64_t CI::Context::supports_sRGB_texture_for_format()
{
  return 0;
}

uint64_t CI::Context::protectionOptions(CI::Context *this)
{
  return 0;
}

uint64_t non-virtual thunk to'CI::SWContext::type(CI::SWContext *this)
{
  return 75;
}

void CI::BitmapSampler::~BitmapSampler(CI::BitmapSampler *this)
{
  CI::Bitmap::~Bitmap(this);

  JUMPOUT(0x1997023B0);
}

uint64_t CI::BitmapSampler::type(CI::BitmapSampler *this)
{
  return 56;
}

uint64_t non-virtual thunk to'CI::BitmapSampler::type(CI::BitmapSampler *this)
{
  return 56;
}

void non-virtual thunk to'CI::BitmapSampler::~BitmapSampler(CI::BitmapSampler *this)
{
}

{
  uint64_t vars8;

  CI::Bitmap::~Bitmap((CI::BitmapSampler *)((char *)this - 16));

  JUMPOUT(0x1997023B0);
}

int32x4_t CI::BitmapSampler::BitmapSampler(CI::BitmapSampler *this, __IOSurface *a2, int a3, char a4, char a5)
{
  uint64_t v7 = CI::Bitmap::Bitmap(this, a2, a3);
  *(void *)uint64_t v7 = &unk_1EE4569D0;
  int32x4_t v8 = vdupq_n_s32(0x3B808081u);
  *((void *)v7 + 2) = &unk_1EE456A08;
  *((void *)v7 + 1_Block_object_dispose(&STACK[0x238], 8) = v8.i64[0];
  *((int32x4_t *)v7 + 10) = v8;
  *((int32x4_t *)v7 + 11) = v8;
  *((int32x4_t *)v7 + 15) = v8;
  *((int32x4_t *)v7 + 16) = v8;
  *((int32x4_t *)v7 + 13) = v8;
  *((int32x4_t *)v7 + 14) = v8;
  *((int32x4_t *)v7 + 12) = v8;
  int32x4_t v9 = vdupq_n_s32(0x37800080u);
  *((unsigned char *)v7 + 13_Block_object_dispose(&STACK[0x238], 8) = a4;
  *((void *)v7 + 34) = v9.i64[0];
  *((int32x4_t *)v7 + 1_Block_object_dispose(&STACK[0x238], 8) = v9;
  *((int32x4_t *)v7 + 19) = v9;
  *((int32x4_t *)v7 + 23) = v9;
  *((int32x4_t *)v7 + 24) = v9;
  *((int32x4_t *)v7 + 21) = v9;
  *((int32x4_t *)v7 + 22) = v9;
  *((int32x4_t *)v7 + 20) = v9;
  int32x4_t result = vdupq_n_s32(0x3A802008u);
  *((unsigned char *)v7 + 139) = a5;
  *((void *)v7 + 50) = result.i64[0];
  *((int32x4_t *)v7 + 27) = result;
  *((int32x4_t *)v7 + 2_Block_object_dispose(&STACK[0x238], 8) = result;
  *((int32x4_t *)v7 + 26) = result;
  return result;
}

int32x4_t CI::BitmapSampler::BitmapSampler(CI::BitmapSampler *this, CGImage *a2, char a3, char a4)
{
  uint64_t v6 = CI::Bitmap::Bitmap(this, a2);
  *(void *)uint64_t v6 = &unk_1EE4569D0;
  int32x4_t v7 = vdupq_n_s32(0x3B808081u);
  *((void *)v6 + 2) = &unk_1EE456A08;
  *((void *)v6 + 1_Block_object_dispose(&STACK[0x238], 8) = v7.i64[0];
  *((int32x4_t *)v6 + 10) = v7;
  *((int32x4_t *)v6 + 11) = v7;
  *((int32x4_t *)v6 + 15) = v7;
  *((int32x4_t *)v6 + 16) = v7;
  *((int32x4_t *)v6 + 13) = v7;
  *((int32x4_t *)v6 + 14) = v7;
  *((int32x4_t *)v6 + 12) = v7;
  int32x4_t v8 = vdupq_n_s32(0x37800080u);
  *((unsigned char *)v6 + 13_Block_object_dispose(&STACK[0x238], 8) = a3;
  *((void *)v6 + 34) = v8.i64[0];
  *((int32x4_t *)v6 + 1_Block_object_dispose(&STACK[0x238], 8) = v8;
  *((int32x4_t *)v6 + 19) = v8;
  *((int32x4_t *)v6 + 23) = v8;
  *((int32x4_t *)v6 + 24) = v8;
  *((int32x4_t *)v6 + 21) = v8;
  *((int32x4_t *)v6 + 22) = v8;
  *((int32x4_t *)v6 + 20) = v8;
  int32x4_t result = vdupq_n_s32(0x3A802008u);
  *((unsigned char *)v6 + 139) = a4;
  *((void *)v6 + 50) = result.i64[0];
  *((int32x4_t *)v6 + 27) = result;
  *((int32x4_t *)v6 + 2_Block_object_dispose(&STACK[0x238], 8) = result;
  *((int32x4_t *)v6 + 26) = result;
  return result;
}

int32x4_t CI::BitmapSampler::BitmapSampler(CI::BitmapSampler *this, __int8 a2, __int8 a3)
{
  CI::Bitmap::Bitmap(this);
  v5->i64[0] = (uint64_t)&unk_1EE4569D0;
  int32x4_t v6 = vdupq_n_s32(0x3B808081u);
  v5[1].i64[0] = (uint64_t)&unk_1EE456A08;
  v5[9].i64[0] = v6.i64[0];
  v5[10] = v6;
  v5[11] = v6;
  v5[15] = v6;
  uint8_t v5[16] = v6;
  v5[13] = v6;
  v5[14] = v6;
  v5[12] = v6;
  int32x4_t v7 = vdupq_n_s32(0x37800080u);
  v5[8].i8[10] = a2;
  v5[17].i64[0] = v7.i64[0];
  v5[18] = v7;
  v5[19] = v7;
  v5[23] = v7;
  v5[24] = v7;
  v5[21] = v7;
  v5[22] = v7;
  v5[20] = v7;
  int32x4_t result = vdupq_n_s32(0x3A802008u);
  v5[8].i8[11] = a3;
  v5[25].i64[0] = result.i64[0];
  v5[27] = result;
  v5[28] = result;
  v5[26] = result;
  return result;
}

uint64_t CI::TextureManager::tmIntermediate_t::needs_rendering(CI::TextureManager::tmIntermediate_t *this)
{
  return *((unsigned __int8 *)this + 72);
}

uint64_t CI::TextureManager::tmIntermediate_t::roi(CI::TextureManager::tmIntermediate_t *this)
{
  return (uint64_t)this + 32;
}

void *CI::TextureManager::tmIntermediate_t::updateSurface(void *this, CFTypeRef cf, int a3)
{
  this[3] = cf;
  if (a3) {
    return CFRetain(cf);
  }
  return this;
}

uint64_t CI::InstanceCounted<(CI::Type)75>::type()
{
  return 75;
}

void *CI::InstanceCounted<(CI::Type)75>::~InstanceCounted(void *result)
{
  *int32x4_t result = &unk_1EE45B1B0;
  atomic_fetch_add(&dword_1EB466F58[17], 0xFFFFFFFF);
  return result;
}

void CI::InstanceCounted<(CI::Type)75>::~InstanceCounted(void *a1)
{
  *a1 = &unk_1EE45B1B0;
  atomic_fetch_add(&dword_1EB466F58[17], 0xFFFFFFFF);
  JUMPOUT(0x1997023B0);
}

uint64_t std::stringbuf::str[abi:nn180100]<std::allocator<char>>@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = std::stringbuf::view[abi:nn180100](a1);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  uint64_t v5 = (const void *)result;
  size_t v6 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    int32x4_t v9 = operator new(v7 + 1);
    a2[1] = v6;
    a2[2] = v8 | 0x8000000000000000;
    *a2 = v9;
    a2 = v9;
  }
  else
  {
    *((unsigned char *)a2 + 23) = v4;
    if (!v4) {
      goto LABEL_9;
    }
  }
  uint64_t result = (uint64_t)memmove(a2, v5, v6);
LABEL_9:
  *((unsigned char *)a2 + v6) = 0;
  return result;
}

uint64_t std::stringbuf::view[abi:nn180100](uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 96);
  if ((v1 & 0x10) != 0)
  {
    unint64_t v3 = *(void *)(a1 + 48);
    if (*(void *)(a1 + 88) < v3) {
      *(void *)(a1 + 8_Block_object_dispose(&STACK[0x238], 8) = v3;
    }
    return *(void *)(a1 + 40);
  }
  else if ((v1 & 8) != 0)
  {
    return *(void *)(a1 + 16);
  }
  else
  {
    return 0;
  }
}

uint64_t QueuePool<4>::~QueuePool(uint64_t a1)
{
  for (uint64_t i = 40; i != 72; i += 8)
  {
    unint64_t v3 = *(NSObject **)(a1 + i);
    if (v3) {
      dispatch_release(v3);
    }
  }
  dispatch_release(*(dispatch_object_t *)(a1 + 8));
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void ___ZN9QueuePoolILi4EE7get_newEP21dispatch_queue_attr_s_block_invoke(uint64_t a1)
{
  int v2 = *(int **)(a1 + 40);
  if (!*(void *)&v2[2 * *v2 + 10])
  {
    std::string::basic_string[abi:nn180100]<0>(&v29, "-Pool-");
    int v3 = *((char *)v2 + 39);
    if (v3 >= 0) {
      unint64_t v4 = (const std::string::value_type *)(v2 + 4);
    }
    else {
      unint64_t v4 = (const std::string::value_type *)*((void *)v2 + 2);
    }
    if (v3 >= 0) {
      std::string::size_type v5 = *((unsigned __int8 *)v2 + 39);
    }
    else {
      std::string::size_type v5 = *((void *)v2 + 3);
    }
    size_t v6 = std::string::insert(&v29, 0, v4, v5);
    std::string::size_type v7 = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v30.__r_.__value_.__l.__data_ = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v30.__r_.__value_.__r.__words[2] = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&__p, *v2);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    CGFloat v10 = std::string::append(&v30, (const std::string::value_type *)p_p, size);
    std::string::size_type v11 = v10->__r_.__value_.__r.__words[2];
    long long v31 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    uint64_t v32 = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v30.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v29.__r_.__value_.__l.__data_);
    }
    if (v32 >= 0) {
      int32x4_t v12 = (const char *)&v31;
    }
    else {
      int32x4_t v12 = (const char *)v31;
    }
    CGRect v13 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    *(void *)&v2[2 * *v2 + 10] = dispatch_queue_create(v12, v13);
    if (SHIBYTE(v32) < 0) {
      operator delete((void *)v31);
    }
  }
  std::string::basic_string[abi:nn180100]<0>(&v29, "-");
  int v14 = *((char *)v2 + 39);
  if (v14 >= 0) {
    CGRect v15 = (const std::string::value_type *)(v2 + 4);
  }
  else {
    CGRect v15 = (const std::string::value_type *)*((void *)v2 + 2);
  }
  if (v14 >= 0) {
    std::string::size_type v16 = *((unsigned __int8 *)v2 + 39);
  }
  else {
    std::string::size_type v16 = *((void *)v2 + 3);
  }
  CGRect v17 = std::string::insert(&v29, 0, v15, v16);
  std::string::size_type v18 = v17->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v30.__r_.__value_.__l.__data_ = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  v30.__r_.__value_.__r.__words[2] = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&__p, *v2);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v19 = &__p;
  }
  else {
    uint64_t v19 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v20 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v20 = __p.__r_.__value_.__l.__size_;
  }
  int32x4_t v21 = std::string::append(&v30, (const std::string::value_type *)v19, v20);
  std::string::size_type v22 = v21->__r_.__value_.__r.__words[2];
  long long v31 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
  uint64_t v32 = v22;
  v21->__r_.__value_.__l.__size_ = 0;
  v21->__r_.__value_.__r.__words[2] = 0;
  v21->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v30.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v29.__r_.__value_.__l.__data_);
  }
  if (v32 >= 0) {
    int32x4_t v23 = (const char *)&v31;
  }
  else {
    int32x4_t v23 = (const char *)v31;
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = dispatch_queue_create_with_target_V2(v23, *(dispatch_queue_attr_t *)(a1 + 48), *(dispatch_queue_t *)&v2[2 * *v2 + 10]);
  int v24 = *v2 + 1;
  BOOL v25 = -v24 < 0;
  int v26 = -v24 & 3;
  int v27 = v24 & 3;
  if (!v25) {
    int v27 = -v26;
  }
  *int v2 = v27;
  if (SHIBYTE(v32) < 0) {
    operator delete((void *)v31);
  }
}

char *FastRegistration_getStatusDescription(int a1)
{
  return (&FastRegistration_statusDescription)[a1 + 8];
}

void CMatrix::CMatrix(CMatrix *this, const CMatrix *a2)
{
  unsigned int v2 = *(_DWORD *)a2;
  unsigned int v3 = *((_DWORD *)a2 + 1);
  *(_DWORD *)this = *(_DWORD *)a2;
  *((_DWORD *)this + 1) = v3;
  memcpy((char *)this + 8, (char *)a2 + 8, 8 * v2 * (unint64_t)v3);
}

void CMatrix::CMatrix(CMatrix *this, unsigned int a2, unsigned int a3)
{
  *(_DWORD *)this = a2;
  *((_DWORD *)this + 1) = a3;
  if (a2 > 5 || a3 >= 6) {
    *(void *)this = 0;
  }
  bzero((char *)this + 8, 0xC8uLL);
}

void CMatrix::diagonalMatrix(CMatrix *this@<X0>, double a2@<D0>, _DWORD *a3@<X8>, uint64_t a4, ...)
{
  unsigned int v5 = this;
  *a3 = this;
  a3[1] = this;
  if (this >= 6) {
    *(void *)a3 = 0;
  }
  bzero(a3 + 2, 0xC8uLL);
  LODWORD(v_Block_object_dispose(&STACK[0x238], 8) = *a3;
  unsigned int v7 = a3[1];
  if (v7) {
    BOOL v9 = v8 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (v9) {
    CGFloat v10 = (double *)&CMatrixRow::operator[]const::zero;
  }
  else {
    CGFloat v10 = (double *)(a3 + 2);
  }
  *CGFloat v10 = a2;
  std::string::size_type v16 = &a4;
  if (v5 >= 2)
  {
    if (v8 >= v7) {
      unint64_t v8 = v7;
    }
    else {
      unint64_t v8 = v8;
    }
    std::string::size_type v11 = a3 + 4;
    unint64_t v12 = 1;
    unsigned int v13 = v7;
    do
    {
      int v14 = (uint64_t *)&v11[2 * v13];
      CGRect v15 = v16++;
      if (v12 >= v8) {
        int v14 = (uint64_t *)&CMatrixRow::operator[]const::zero;
      }
      *int v14 = *v15;
      ++v12;
      v13 += v7;
      v11 += 2;
    }
    while (v5 != v12);
  }
}

void CMatrix::transpose(CMatrix *this@<X0>, unsigned int *a2@<X8>)
{
  uint64_t v5 = *(unsigned int *)this;
  uint64_t v4 = *((unsigned int *)this + 1);
  *a2 = v4;
  a2[1] = v5;
  if (v4 > 5 || v5 >= 6) {
    *(void *)a2 = 0;
  }
  bzero(a2 + 2, 0xC8uLL);
  if (v5)
  {
    unsigned int v7 = 0;
    unint64_t v8 = 0;
    unint64_t v9 = *a2;
    unint64_t v10 = a2[1];
    do
    {
      if (v4)
      {
        unsigned int v11 = 0;
        for (unint64_t i = 0; i != v4; ++i)
        {
          BOOL v13 = v8 >= v10 || i >= v9;
          int v14 = &a2[2 * v8 + 2 + 2 * v11];
          if (v13) {
            int v14 = (unsigned int *)&CMatrixRow::operator[]const::zero;
          }
          *(void *)int v14 = *((void *)this + v7 + i + 1);
          v11 += v10;
        }
      }
      ++v8;
      v7 += v4;
    }
    while (v8 != v5);
  }
}

uint64_t mtlutl_ComputeThreadGroupParameters(uint64_t result, unsigned int a2, _DWORD *a3, _DWORD *a4, unsigned int a5, unsigned int a6)
{
  if ((a5 | result | a2))
  {
    int v6 = 1;
  }
  else
  {
    int v6 = 1;
    unsigned int v7 = result;
    do
    {
      char v8 = a5;
      a5 >>= 1;
      uint64_t result = v7 >> 1;
      char v9 = a2;
      a2 >>= 1;
      v6 *= 2;
      if ((v8 & 2) != 0) {
        break;
      }
      if ((v7 & 2) != 0) {
        break;
      }
      v7 >>= 1;
    }
    while ((v9 & 2) == 0);
  }
  if ((a6 | result))
  {
    int v10 = 1;
  }
  else
  {
    int v10 = 1;
    unsigned int v11 = a6;
    unsigned int v12 = result;
    do
    {
      a6 = v11 >> 1;
      uint64_t result = v12 >> 1;
      v10 *= 2;
      char v13 = v11 | v12;
      v11 >>= 1;
      v12 >>= 1;
    }
    while ((v13 & 2) == 0);
  }
  if (a2 >= result) {
    unsigned int v14 = result;
  }
  else {
    unsigned int v14 = a2;
  }
  if (v14)
  {
    if (v14 + 1 > 2) {
      int v15 = v14 + 1;
    }
    else {
      int v15 = 2;
    }
    unsigned int v16 = 1;
    int v17 = 1;
    int v18 = 1;
    do
    {
      if (!(a5 % v16))
      {
        int v19 = 1;
        for (unsigned int i = a6; ; i /= 7u)
        {
          while (1)
          {
            while (1)
            {
              while ((i & 1) == 0 && 2 * v16 * v19 <= result)
              {
                i >>= 1;
                v19 *= 2;
              }
              if (i != 3 * (i / 3) || 3 * v16 * v19 > result) {
                break;
              }
              v19 *= 3;
              i /= 3u;
            }
            if (i != 5 * (i / 5) || 5 * v16 * v19 > result) {
              break;
            }
            v19 *= 5;
            i /= 5u;
          }
          if (i % 7 || 7 * v16 * v19 > result) {
            break;
          }
          v19 *= 7;
        }
        unsigned int v24 = v17 * v18;
        if (v19 * v16 >= v17 * v18) {
          int v18 = v16;
        }
        if (v19 * v16 >= v24) {
          int v17 = v19;
        }
      }
      ++v16;
    }
    while (v16 != v15);
  }
  else
  {
    int v18 = 1;
    int v17 = 1;
  }
  *a3 = v18 * v6;
  *a4 = v17 * v10;
  return result;
}

CIImage *CI::Perspective::gradDirImage(CI::Perspective *this, CIImage *a2)
{
  v9[1] = *MEMORY[0x1E4F143B8];
  unsigned int v3 = +[CIKernel kernelWithInternalRepresentation:&CI::_gradientDirection];
  [(CI::Perspective *)this extent];
  v9[0] = this;
  return -[CIColorKernel applyWithExtent:arguments:](v3, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v9 count:1], v4, v5, v6, v7);
}

CIImage *CI::Perspective::gradMagImage(CI::Perspective *this, CIImage *a2)
{
  v9[1] = *MEMORY[0x1E4F143B8];
  unsigned int v3 = +[CIKernel kernelWithInternalRepresentation:&CI::_gradientMagnitude];
  [(CI::Perspective *)this extent];
  v9[0] = this;
  return -[CIColorKernel applyWithExtent:arguments:](v3, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v9 count:1], v4, v5, v6, v7);
}

BOOL CI::Perspective::CIImageToFile(CI::Perspective *this, CIImage *a2, NSString *a3, CGRect a4)
{
  double height = a4.size.height;
  double width = a4.size.width;
  double y = a4.origin.y;
  double x = a4.origin.x;
  {
    CI::Perspective::CIImageToFile(CIImage *,NSString *,CGRect)::colorspace = (uint64_t)CGColorSpaceCreateDeviceRGB();
  }
  v14.origin.double x = x;
  v14.origin.double y = y;
  v14.size.double width = width;
  v14.size.double height = height;
  if (!CGRectIsNull(v14)) {
    this = (CI::Perspective *)-[CI::Perspective imageByCroppingToRect:](this, "imageByCroppingToRect:", x, y, width, height);
  }
  int v10 = +[CIContext context];
  unsigned int v11 = [(CIContext *)v10 PNGRepresentationOfImage:this format:2056 colorSpace:CI::Perspective::CIImageToFile(CIImage *,NSString *,CGRect)::colorspace options:MEMORY[0x1E4F1CC08]];

  return [(NSData *)v11 writeToFile:a2 atomically:1];
}

void sub_193890E54(_Unwind_Exception *a1)
{
}

double cikernel::_gradientMagnitude(float32x4_t a1)
{
  float32x2_t v1 = (float32x2_t)vmulq_f32(a1, a1).u64[0];
  v1.f32[0] = sqrtf(vaddv_f32(v1));
  *(void *)&double result = vdupq_lane_s32((int32x2_t)v1, 0).u64[0];
  return result;
}

__n64 CI::Perspective::getRotation(CI::Perspective *this, float a2, float a3, float a4)
{
  __float2 v6 = __sincosf_stret(a2 * 0.5);
  float32x4_t v37 = vmulq_n_f32((float32x4_t)xmmword_193954F70, v6.__sinval);
  __float2 v7 = __sincosf_stret(a3 * 0.5);
  float32x4_t v8 = vmulq_n_f32((float32x4_t)xmmword_193954F80, v7.__sinval);
  v8.i32[3] = LODWORD(v7.__cosval);
  float32x4_t v36 = v8;
  __float2 v9 = __sincosf_stret(a4 * 0.5);
  _Q0 = vmulq_n_f32((float32x4_t)xmmword_193954F90, v9.__sinval);
  _Q0.i32[3] = LODWORD(v9.__cosval);
  int32x4_t v11 = (int32x4_t)vnegq_f32(v36);
  int8x16_t v12 = (int8x16_t)vtrn2q_s32((int32x4_t)v36, vtrn1q_s32((int32x4_t)v36, v11));
  float32x4_t v13 = vmlaq_n_f32(vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)v36, (int8x16_t)v11, 8uLL), *(float32x2_t *)v37.f32, 1), (float32x4_t)vextq_s8(v12, v12, 8uLL), v37.f32[0]);
  float32x4_t v14 = (float32x4_t)vrev64q_s32((int32x4_t)v36);
  v14.i32[0] = v11.i32[1];
  v14.i32[3] = v11.i32[2];
  float32x4_t v15 = vaddq_f32(vmlaq_laneq_f32(vmulq_n_f32(v36, v6.__cosval), v14, v37, 2), v13);
  int32x4_t v16 = (int32x4_t)vnegq_f32(_Q0);
  int8x16_t v17 = (int8x16_t)vtrn2q_s32((int32x4_t)_Q0, vtrn1q_s32((int32x4_t)_Q0, v16));
  _Q4 = vmlaq_n_f32(vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)_Q0, (int8x16_t)v16, 8uLL), *(float32x2_t *)v15.f32, 1), (float32x4_t)vextq_s8(v17, v17, 8uLL), v15.f32[0]);
  float32x4_t v19 = (float32x4_t)vrev64q_s32((int32x4_t)_Q0);
  v19.i32[0] = v16.i32[1];
  v19.i32[3] = v16.i32[2];
  _Q3 = vaddq_f32(_Q4, vmlaq_laneq_f32(vmulq_laneq_f32(_Q0, v15, 3), v19, v15, 2));
  _Q4.i32[0] = _Q3.i32[1];
  _S5 = _Q3.i32[2];
  __asm { FMLS            S0, S5, V3.S[2] }
  _S7 = _Q3.i32[3];
  __asm { FMLA            S0, S7, V3.S[3] }
  float v27 = vmlas_n_f32(-(float)(_Q3.f32[2] * _Q3.f32[3]), _Q3.f32[1], _Q3.f32[0]);
  __asm
  {
    FMLA            S6, S4, V3.S[1]
    FMLA            S6, S7, V3.S[3]
    FMLS            S6, S3, V3.S[0]
    FMLA            S18, S5, V3.S[1]
    FMLA            S7, S5, V3.S[2]
    FMLS            S7, S3, V3.S[0]
  }
  result.n64_f32[1] = v27 + v27;
  __asm { FMLS            S7, S4, V3.S[1] }
  return result;
}

uint64_t CI::Perspective::pointInBounds(float32x2_t *a1, float32x2_t *a2)
{
  uint32x2_t v2 = (uint32x2_t)vand_s8((int8x8_t)vcgt_f32(vadd_f32(*a2, (float32x2_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)a2->f32, *(int8x16_t *)a2->f32, 8uLL)), *a1), (int8x8_t)vcgt_f32(*a1, *a2));
  return vpmin_u32(v2, v2).u32[0] >> 31;
}

float32x2_t CI::Perspective::bbox(float32x2_t *a1)
{
  return vminnm_f32(vminnm_f32(vminnm_f32(*a1, a1[1]), a1[2]), a1[3]);
}

BOOL CI::Perspective::intersect(int32x2_t *a1, int32x2_t *a2, float32x2_t *a3)
{
  v3.i32[0] = (__int32)*a1;
  v3.i32[1] = HIDWORD(*(void *)&a2[1]);
  v4.i32[0] = (__int32)a1[1];
  v4.i32[1] = HIDWORD(*(unint64_t *)a2);
  int v5 = (int)*a2;
  _D6.i32[1] = HIDWORD(*(void *)&a1[1]);
  float32x2_t v6 = vsub_f32(v3, v4);
  v4.i32[0] = (__int32)a2[1];
  v4.i32[1] = HIDWORD(*(unint64_t *)a1);
  _D16 = vsub_f32(_D6, v4);
  __asm { FMLA            S6, S16, V16.S[1] }
  if (_D6.f32[0] >= 0.0) {
    float v13 = _D6.f32[0];
  }
  else {
    float v13 = -(float)((float)((float)-v6.f32[1] * v6.f32[0]) + (float)(_D16.f32[1] * _D16.f32[0]));
  }
  double v14 = v13;
  if (v14 >= 0.01)
  {
    float32x2_t v15 = vmla_f32(vmul_f32((float32x2_t)vzip2_s32(a2[1], a1[1]), vneg_f32((float32x2_t)vzip1_s32(*a2, *a1))), (float32x2_t)vzip2_s32(*a2, *a1), (float32x2_t)vzip1_s32(a2[1], a1[1]));
    *a3 = vdiv_f32(vmla_f32(vmul_f32((float32x2_t)vrev64_s32((int32x2_t)v15), vneg_f32(_D16)), v15, v6), (float32x2_t)vdup_lane_s32((int32x2_t)_D6, 0));
  }
  return v14 >= 0.01;
}

BOOL CI::Perspective::intersect(float *a1, _DWORD *a2, double a3, double a4, __n128 a5)
{
  __asm { FMOV            V3.2S, #1.0 }
  float32x2_t v10 = vdiv_f32(_D3, *(float32x2_t *)&a4);
  if (*(float *)&a4 == 0.0)
  {
    float v14 = INFINITY;
    float v13 = -INFINITY;
  }
  else
  {
    float v11 = a5.n128_f32[2];
    if (*(float *)&a4 <= 0.0) {
      float v12 = a5.n128_f32[2];
    }
    else {
      float v12 = a5.n128_f32[0];
    }
    float v13 = (float)(v12 - *(float *)&a3) * v10.f32[0];
    if (*(float *)&a4 <= 0.0) {
      float v11 = a5.n128_f32[0];
    }
    float v14 = (float)(v11 - *(float *)&a3) * v10.f32[0];
  }
  if (*((float *)&a4 + 1) == 0.0)
  {
    float32x2_t v19 = (float32x2_t)0x7F800000FF800000;
  }
  else
  {
    uint64_t v15 = 3;
    if (*((float *)&a4 + 1) > 0.0) {
      uint64_t v16 = 1;
    }
    else {
      uint64_t v16 = 3;
    }
    int8x16_t v17 = (__int32 *)((unint64_t)&v22 | (4 * v16));
    if (*((float *)&a4 + 1) <= 0.0) {
      uint64_t v15 = 1;
    }
    __n128 v22 = a5;
    v18.i32[0] = *v17;
    v18.i32[1] = *(_DWORD *)((unint64_t)&v22 | (4 * v15));
    float32x2_t v19 = vmul_lane_f32(vsub_f32(v18, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a3, 1)), v10, 1);
  }
  if (v13 <= v19.f32[0]) {
    float v20 = v19.f32[0];
  }
  else {
    float v20 = v13;
  }
  *a1 = v20;
  v19.i32[0] = v19.i32[1];
  if (v14 < v19.f32[1]) {
    v19.f32[0] = v14;
  }
  *a2 = v19.i32[0];
  return v19.f32[0] >= *a1 && v19.f32[0] >= 0.0;
}

float CI::Perspective::keystoneV(double a1, double a2, double a3, double a4)
{
  float result = -atan2f(vmlas_n_f32((float)-(float)(*((float *)&a2 + 1) - *((float *)&a1 + 1))* vsub_f32(*(float32x2_t *)&a4, *(float32x2_t *)&a3).f32[0], *((float *)&a4 + 1) - *((float *)&a3 + 1), vsub_f32(*(float32x2_t *)&a2, *(float32x2_t *)&a1).f32[0]), (float)((float)(*((float *)&a2 + 1) - *((float *)&a1 + 1))* vmlas_n_f32((float)-*((float *)&a4 + 1) * *(float *)&a3, *((float *)&a3 + 1), *(float *)&a4))- (float)((float)(*((float *)&a4 + 1) - *((float *)&a3 + 1))* vmlas_n_f32((float)-*((float *)&a2 + 1) * *(float *)&a1, *((float *)&a1 + 1), *(float *)&a2)));
  if (result < -1.57079633)
  {
    float v5 = result + 3.14159265;
    float result = v5;
  }
  if (result > 1.57079633) {
    return result + -3.14159265;
  }
  return result;
}

float CI::Perspective::keystoneH(double a1, double a2, double a3, double a4)
{
  float v4 = vsub_f32(*(float32x2_t *)&a4, *(float32x2_t *)&a3).f32[0];
  float v5 = vsub_f32(*(float32x2_t *)&a2, *(float32x2_t *)&a1).f32[0];
  float result = -atan2f(vmlas_n_f32(-(float)(v5 * (float)(*((float *)&a4 + 1) - *((float *)&a3 + 1))), *((float *)&a2 + 1) - *((float *)&a1 + 1), v4), vmlas_n_f32(-(float)(v4* vmlas_n_f32(vmuls_lane_f32(-*(float *)&a1, *(float32x2_t *)&a2, 1), *((float *)&a1 + 1), *(float *)&a2)), vmlas_n_f32(vmuls_lane_f32(-*(float *)&a3, *(float32x2_t *)&a4, 1), *((float *)&a3 + 1), *(float *)&a4), v5));
  if (result < -1.57079633)
  {
    float v7 = result + 3.14159265;
    float result = v7;
  }
  if (result > 1.57079633) {
    return result + -3.14159265;
  }
  return result;
}

float CI::Perspective::horizonV(CI::Perspective *a1, double a2, double a3, double a4, double a5, float a6, float a7)
{
  *(__n64 *)v7.f32 = CI::Perspective::getRotation(a1, a6, a7, 0.0);
  int32x4_t v10 = (int32x4_t)vaddq_f32(v9, vmlaq_lane_f32(vmulq_n_f32(v7, *(float *)&a2), v8, *(float32x2_t *)&a2, 1));
  int32x4_t v11 = (int32x4_t)vaddq_f32(v9, vmlaq_lane_f32(vmulq_n_f32(v7, *(float *)&a4), v8, *(float32x2_t *)&a4, 1));
  *(float32x2_t *)v10.i8 = vadd_f32(vdiv_f32(*(float32x2_t *)v10.i8, (float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v10, 2)), vdiv_f32(*(float32x2_t *)v11.i8, (float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v11, 2)));
  int32x4_t v12 = (int32x4_t)vaddq_f32(v9, vmlaq_lane_f32(vmulq_n_f32(v7, *(float *)&a3), v8, *(float32x2_t *)&a3, 1));
  int32x4_t v13 = (int32x4_t)vaddq_f32(v9, vmlaq_lane_f32(vmulq_n_f32(v7, *(float *)&a5), v8, *(float32x2_t *)&a5, 1));
  *(float32x2_t *)v8.f32 = vsub_f32(vmul_f32(*(float32x2_t *)v10.i8, (float32x2_t)0x3F0000003F000000), vmul_f32(vadd_f32(vdiv_f32(*(float32x2_t *)v12.i8, (float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v12, 2)), vdiv_f32(*(float32x2_t *)v13.i8, (float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v13, 2))), (float32x2_t)0x3F0000003F000000));
  float result = atan2f(v8.f32[1], v8.f32[0]) + -1.57079633;
  if (result < -1.57079633)
  {
    float v15 = result + 3.14159265;
    float result = v15;
  }
  if (result > 1.57079633) {
    return result + -3.14159265;
  }
  return result;
}

float CI::Perspective::horizonH(CI::Perspective *a1, double a2, double a3, double a4, double a5, float a6, float a7)
{
  *(__n64 *)v7.f32 = CI::Perspective::getRotation(a1, a6, a7, 0.0);
  int32x4_t v10 = (int32x4_t)vaddq_f32(v9, vmlaq_lane_f32(vmulq_n_f32(v7, *(float *)&a2), v8, *(float32x2_t *)&a2, 1));
  int32x4_t v11 = (int32x4_t)vaddq_f32(v9, vmlaq_lane_f32(vmulq_n_f32(v7, *(float *)&a4), v8, *(float32x2_t *)&a4, 1));
  *(float32x2_t *)v10.i8 = vadd_f32(vdiv_f32(*(float32x2_t *)v10.i8, (float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v10, 2)), vdiv_f32(*(float32x2_t *)v11.i8, (float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v11, 2)));
  int32x4_t v12 = (int32x4_t)vaddq_f32(v9, vmlaq_lane_f32(vmulq_n_f32(v7, *(float *)&a3), v8, *(float32x2_t *)&a3, 1));
  int32x4_t v13 = (int32x4_t)vaddq_f32(v9, vmlaq_lane_f32(vmulq_n_f32(v7, *(float *)&a5), v8, *(float32x2_t *)&a5, 1));
  *(float32x2_t *)v8.f32 = vsub_f32(vmul_f32(*(float32x2_t *)v10.i8, (float32x2_t)0x3F0000003F000000), vmul_f32(vadd_f32(vdiv_f32(*(float32x2_t *)v12.i8, (float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v12, 2)), vdiv_f32(*(float32x2_t *)v13.i8, (float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v13, 2))), (float32x2_t)0x3F0000003F000000));
  float result = atan2f(v8.f32[1], v8.f32[0]);
  if (result < -1.57079633)
  {
    float v15 = result + 3.14159265;
    float result = v15;
  }
  if (result > 1.57079633) {
    return result + -3.14159265;
  }
  return result;
}

uint64_t PixelBufferApplyPlaneBlock(CVPixelBufferRef pixelBuffer, uint64_t a2)
{
  uint64_t result = 4294960635;
  if (pixelBuffer)
  {
    if (a2)
    {
      size_t PlaneCount = CVPixelBufferGetPlaneCount(pixelBuffer);
      uint64_t result = CVPixelBufferLockBaseAddress(pixelBuffer, 0);
      if (!result)
      {
        if (PlaneCount)
        {
          if ((PlaneCount & 0xFFFFFFFFFFFFFFFELL) == 2)
          {
            for (size_t i = 0; i != PlaneCount; ++i)
            {
              BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, i);
              size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, i);
              size_t WidthOfPlane = CVPixelBufferGetWidthOfPlane(pixelBuffer, i);
              size_t HeightOfPlane = CVPixelBufferGetHeightOfPlane(pixelBuffer, i);
              if (BaseAddressOfPlane && BytesPerRowOfPlane && WidthOfPlane)
              {
                if (HeightOfPlane) {
                  (*(void (**)(uint64_t, void *, size_t, size_t, size_t, size_t))(a2 + 16))(a2, BaseAddressOfPlane, i, WidthOfPlane, HeightOfPlane, BytesPerRowOfPlane);
                }
              }
            }
          }
        }
        else
        {
          BaseAddress = CVPixelBufferGetBaseAddress(pixelBuffer);
          size_t BytesPerRow = CVPixelBufferGetBytesPerRow(pixelBuffer);
          size_t Width = CVPixelBufferGetWidth(pixelBuffer);
          size_t Height = CVPixelBufferGetHeight(pixelBuffer);
          if (BaseAddress && BytesPerRow && Width && Height) {
            (*(void (**)(uint64_t, void *, void, size_t, size_t, size_t))(a2 + 16))(a2, BaseAddress, 0, Width, Height, BytesPerRow);
          }
        }
        CVPixelBufferUnlockBaseAddress(pixelBuffer, 0);
        return 0;
      }
    }
  }
  return result;
}

uint64_t PixelBufferApplyOnePlaneBlock(CVPixelBufferRef pixelBuffer, size_t a2, uint64_t a3)
{
  uint64_t result = 4294960635;
  if (pixelBuffer && a3)
  {
    size_t PlaneCount = CVPixelBufferGetPlaneCount(pixelBuffer);
    size_t v8 = PlaneCount;
    BOOL v9 = a2 && PlaneCount == 0;
    BOOL v10 = v9;
    size_t v11 = PlaneCount - 1;
    uint64_t result = 4294960635;
    if (v11 >= a2 && !v10)
    {
      uint64_t result = CVPixelBufferLockBaseAddress(pixelBuffer, 0);
      if (!result)
      {
        if (v8)
        {
          if ((v8 & 0xFFFFFFFFFFFFFFFELL) == 2)
          {
            BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, a2);
            size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, a2);
            size_t WidthOfPlane = CVPixelBufferGetWidthOfPlane(pixelBuffer, a2);
            size_t HeightOfPlane = CVPixelBufferGetHeightOfPlane(pixelBuffer, a2);
            if (BaseAddressOfPlane)
            {
              if (BytesPerRowOfPlane && WidthOfPlane)
              {
                if (HeightOfPlane) {
                  (*(void (**)(uint64_t, void *, size_t, size_t, size_t, size_t))(a3 + 16))(a3, BaseAddressOfPlane, a2, WidthOfPlane, HeightOfPlane, BytesPerRowOfPlane);
                }
              }
            }
          }
        }
        else
        {
          BaseAddress = CVPixelBufferGetBaseAddress(pixelBuffer);
          size_t BytesPerRow = CVPixelBufferGetBytesPerRow(pixelBuffer);
          size_t Width = CVPixelBufferGetWidth(pixelBuffer);
          size_t Height = CVPixelBufferGetHeight(pixelBuffer);
          if (BaseAddress && BytesPerRow && Width && Height) {
            (*(void (**)(uint64_t, void *, void, size_t, size_t, size_t))(a3 + 16))(a3, BaseAddress, 0, Width, Height, BytesPerRow);
          }
        }
        CVPixelBufferUnlockBaseAddress(pixelBuffer, 0);
        return 0;
      }
    }
  }
  return result;
}

uint64_t PixelBufferApplyPlaneReadOnlyBlock(__CVBuffer *a1, uint64_t a2)
{
  size_t PlaneCount = CVPixelBufferGetPlaneCount(a1);
  uint64_t v5 = CVPixelBufferLockBaseAddress(a1, 1uLL);
  if (!v5)
  {
    if (PlaneCount)
    {
      if ((PlaneCount & 0xFFFFFFFFFFFFFFFELL) == 2)
      {
        for (size_t i = 0; i != PlaneCount; ++i)
        {
          BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(a1, i);
          size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(a1, i);
          size_t WidthOfPlane = CVPixelBufferGetWidthOfPlane(a1, i);
          size_t HeightOfPlane = CVPixelBufferGetHeightOfPlane(a1, i);
          if (BaseAddressOfPlane && BytesPerRowOfPlane && WidthOfPlane && HeightOfPlane) {
            (*(void (**)(uint64_t, void *, size_t, size_t, size_t, size_t))(a2 + 16))(a2, BaseAddressOfPlane, i, WidthOfPlane, HeightOfPlane, BytesPerRowOfPlane);
          }
        }
      }
    }
    else
    {
      BaseAddress = CVPixelBufferGetBaseAddress(a1);
      size_t BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
      size_t Width = CVPixelBufferGetWidth(a1);
      size_t Height = CVPixelBufferGetHeight(a1);
      if (BaseAddress && BytesPerRow && Width && Height) {
        (*(void (**)(uint64_t, void *, void, size_t, size_t, size_t))(a2 + 16))(a2, BaseAddress, 0, Width, Height, BytesPerRow);
      }
    }
    CVPixelBufferUnlockBaseAddress(a1, 1uLL);
  }
  return v5;
}

uint64_t PixelBufferApplyOnePlaneReadOnlyBlock(__CVBuffer *a1, size_t a2, uint64_t a3)
{
  size_t PlaneCount = CVPixelBufferGetPlaneCount(a1);
  size_t v7 = PlaneCount;
  if (a2) {
    BOOL v8 = PlaneCount == 0;
  }
  else {
    BOOL v8 = 0;
  }
  char v9 = v8;
  size_t v10 = PlaneCount - 1;
  uint64_t result = 4294960635;
  if (v10 >= a2 && (v9 & 1) == 0)
  {
    uint64_t result = CVPixelBufferLockBaseAddress(a1, 1uLL);
    if (!result)
    {
      if (v7)
      {
        if ((v7 & 0xFFFFFFFFFFFFFFFELL) == 2)
        {
          BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(a1, a2);
          size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(a1, a2);
          size_t WidthOfPlane = CVPixelBufferGetWidthOfPlane(a1, a2);
          size_t HeightOfPlane = CVPixelBufferGetHeightOfPlane(a1, a2);
          if (BaseAddressOfPlane)
          {
            if (BytesPerRowOfPlane && WidthOfPlane)
            {
              if (HeightOfPlane) {
                (*(void (**)(uint64_t, void *, size_t, size_t, size_t, size_t))(a3 + 16))(a3, BaseAddressOfPlane, a2, WidthOfPlane, HeightOfPlane, BytesPerRowOfPlane);
              }
            }
          }
        }
      }
      else
      {
        BaseAddress = CVPixelBufferGetBaseAddress(a1);
        size_t BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
        size_t Width = CVPixelBufferGetWidth(a1);
        size_t Height = CVPixelBufferGetHeight(a1);
        if (BaseAddress && BytesPerRow && Width && Height) {
          (*(void (**)(uint64_t, void *, void, size_t, size_t, size_t))(a3 + 16))(a3, BaseAddress, 0, Width, Height, BytesPerRow);
        }
      }
      CVPixelBufferUnlockBaseAddress(a1, 1uLL);
      return 0;
    }
  }
  return result;
}

CFDictionaryRef CreateColorAttributesForColorSpace()
{
  keys[3] = *(void **)MEMORY[0x1E4F143B8];
  uint64_t v18 = 0;
  float32x2_t v19 = &v18;
  uint64_t v20 = 0x2000000000;
  uint64_t v21 = 0;
  uint64_t v14 = 0;
  float v15 = &v14;
  uint64_t v16 = 0x2000000000;
  uint64_t v17 = 0;
  uint64_t v10 = 0;
  size_t v11 = (float *)&v10;
  uint64_t v12 = 0x2000000000;
  int v13 = 0;
  uint64_t v0 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC20]);
  int v1 = CGColorConversionInfoIterateColorSpaceFunctionsWithCallbacks();
  CGColorSpaceRelease(v0);
  CFDictionaryRef v2 = 0;
  if (v1)
  {
    memset(keys, 0, 24);
    memset(values, 0, sizeof(values));
    float32x2_t v3 = (void *)v19[3];
    if (v3)
    {
      keys[0] = *(void **)MEMORY[0x1E4F24A90];
      values[0] = v3;
      unsigned int v4 = 1;
    }
    else
    {
      unsigned int v4 = 0;
    }
    uint64_t v5 = (void *)v15[3];
    if (v5)
    {
      keys[v4] = (void *)*MEMORY[0x1E4F24BC8];
      values[v4++] = v5;
    }
    float32x2_t v6 = v11 + 6;
    float v7 = v11[6];
    if (v7 == 0.0)
    {
      CFDictionaryRef v2 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, v4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    }
    else
    {
      *float32x2_t v6 = roundf(v7 * 10000.0) / 10000.0;
      CFNumberRef v8 = CFNumberCreate(0, kCFNumberFloatType, v6);
      keys[v4] = (void *)*MEMORY[0x1E4F24B28];
      values[v4] = v8;
      CFDictionaryRef v2 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, v4 + 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (v8) {
        CFRelease(v8);
      }
    }
  }
  _Block_object_dispose(&v10, 8);
  _Block_object_dispose(&v14, 8);
  _Block_object_dispose(&v18, 8);
  return v2;
}

uint64_t __CreateColorAttributesForColorSpace_block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 36) != 1) {
    return 0;
  }
  if (*(uint64_t *)(a2 + 44) > 0) {
    return 0;
  }
  uint64_t v3 = *(void *)(a2 + 28);
  if (v3 > 1) {
    return 0;
  }
  if (!v3) {
    goto LABEL_8;
  }
  CGColorTRCGetFunction();
  if (v6 == 5) {
    return 0;
  }
  if (!*(void *)(a2 + 28)) {
LABEL_8:
  }
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *MEMORY[0x1E4F24BE8];
  return 1;
}

BOOL __CreateColorAttributesForColorSpace_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v6 = *a5;
  if (a4 >= 2)
  {
    if (a5[1] != v6) {
      return 0;
    }
    uint64_t v7 = 2;
    while (a4 != v7)
    {
      uint64_t v8 = a5[v7++];
      if (v8 != v6) {
        return v7 - 1 >= a4;
      }
    }
  }
  CGColorTRCGetFunction();
  switch(CGColorTRCGetGammaID())
  {
    case 0u:
      if (!CGColorTRCPureGammaOriginal()) {
        goto LABEL_11;
      }
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *MEMORY[0x1E4F24C08];
      *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
      return 1;
    case 1u:
      uint64_t v10 = (void *)MEMORY[0x1E4F24C10];
      goto LABEL_20;
    case 2u:
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *MEMORY[0x1E4F24C08];
      uint64_t v11 = *(void *)(*(void *)(a1 + 40) + 8);
      int v12 = 1074580685;
      goto LABEL_18;
    case 3u:
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *MEMORY[0x1E4F24C08];
      uint64_t v11 = *(void *)(*(void *)(a1 + 40) + 8);
      int v12 = 1072064102;
LABEL_18:
      *(_DWORD *)(v11 + 24) = v12;
      return 1;
    case 7u:
      uint64_t v10 = (void *)MEMORY[0x1E4F24BE8];
      goto LABEL_20;
    case 8u:
      uint64_t v10 = (void *)MEMORY[0x1E4F24BF8];
      goto LABEL_20;
    case 0xAu:
      uint64_t v10 = (void *)MEMORY[0x1E4F24BD8];
      goto LABEL_20;
    case 0xEu:
      uint64_t v10 = (void *)MEMORY[0x1E4F24BE0];
LABEL_20:
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *v10;
      break;
    default:
LABEL_11:
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
      break;
  }
  return 1;
}

uint64_t __CreateColorAttributesForColorSpace_block_invoke_3(uint64_t a1)
{
  long long v10 = 0u;
  long long v11 = 0u;
  long long v9 = 0u;
  CGColorMatrixGetMatrix();
  long long v6 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  if (near_matrix((float *)&v6, flt_193958154))
  {
    CFDictionaryRef v2 = (uint64_t *)MEMORY[0x1E4F24AB0];
LABEL_7:
    uint64_t v3 = *v2;
    goto LABEL_8;
  }
  long long v6 = v9;
  long long v7 = v10;
  long long v8 = v11;
  if (near_matrix((float *)&v6, flt_193958184))
  {
    CFDictionaryRef v2 = (uint64_t *)MEMORY[0x1E4F24AC0];
    goto LABEL_7;
  }
  long long v6 = v9;
  long long v7 = v10;
  long long v8 = v11;
  if (near_matrix((float *)&v6, flt_1939581B4))
  {
    CFDictionaryRef v2 = (uint64_t *)MEMORY[0x1E4F24AA8];
    goto LABEL_7;
  }
  long long v6 = v9;
  long long v7 = v10;
  long long v8 = v11;
  BOOL v5 = near_matrix((float *)&v6, flt_1939581E4);
  uint64_t v3 = *MEMORY[0x1E4F24A98];
  if (!v5) {
    uint64_t v3 = 0;
  }
LABEL_8:
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v3;
  return 1;
}

uint64_t __CreateColorAttributesForColorSpace_block_invoke_4()
{
  return 0;
}

BOOL near_matrix(float *a1, float *a2)
{
  return vabdd_f64(*a1, *a2) < 0.0001
      && vabdd_f64(a1[1], a2[1]) < 0.0001
      && vabdd_f64(a1[2], a2[2]) < 0.0001
      && vabdd_f64(a1[3], a2[3]) < 0.0001
      && vabdd_f64(a1[4], a2[4]) < 0.0001
      && vabdd_f64(a1[5], a2[5]) < 0.0001
      && vabdd_f64(a1[6], a2[6]) < 0.0001
      && vabdd_f64(a1[7], a2[7]) < 0.0001
      && vabdd_f64(a1[8], a2[8]) < 0.0001
      && vabdd_f64(a1[9], a2[9]) < 0.0001
      && vabdd_f64(a1[10], a2[10]) < 0.0001
      && vabdd_f64(a1[11], a2[11]) < 0.0001;
}

uint64_t Projections_projectionRows_planar8UtoF(uint64_t a1, int a2, int a3, uint64_t a4, int a5, uint64_t a6)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v19 = a1;
  int v20 = a2 >> 1;
  int v21 = a3;
  uint64_t v22 = a4;
  int v23 = a5;
  uint64_t v24 = a6;
  uint64_t v26 = a1 + (a2 >> 1);
  int v27 = a2 >> 1;
  int v28 = a3;
  uint64_t v29 = a4;
  int v30 = a5;
  uint64_t v31 = a6 + 4 * (a2 >> 1);
  char v6 = 1;
  long long v7 = dispatch_queue_attr_make_with_autorelease_frequency(MEMORY[0x1E4F14430], DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  long long v8 = dispatch_queue_create("projectionRows_planar8UtoF", v7);
  uint64_t v9 = MEMORY[0x1E4F143A8];
  uint64_t v14 = MEMORY[0x1E4F143A8];
  uint64_t v15 = 0x40000000;
  uint64_t v16 = __Projections_projectionRows_planar8UtoF_block_invoke;
  uint64_t v17 = &__block_descriptor_tmp_3;
  uint64_t v18 = &v19;
  dispatch_async(v8, &v14);
  uint64_t v14 = v9;
  uint64_t v15 = 0x40000000;
  uint64_t v16 = __Projections_projectionRows_planar8UtoF_block_invoke;
  uint64_t v17 = &__block_descriptor_tmp_3;
  uint64_t v18 = &v26;
  dispatch_async(v8, &v14);
  dispatch_barrier_sync(v8, &__block_literal_global_77);
  uint64_t v10 = 0;
  do
  {
    uint64_t v11 = *((unsigned int *)&v25 + 12 * v10);
    if (v11) {
      break;
    }
    char v12 = v6;
    char v6 = 0;
    uint64_t v10 = 1;
  }
  while ((v12 & 1) != 0);
  dispatch_release(v8);
  return v11;
}

uint64_t Projections_projectionCols_planar8UtoF(uint64_t a1, int a2, int a3, uint64_t a4, int a5, uint64_t a6)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v19 = a1;
  int v20 = a2;
  int v21 = a3 >> 1;
  uint64_t v22 = a4;
  int v23 = a5;
  uint64_t v24 = a6;
  uint64_t v26 = a1 + ((uint64_t)a3 >> 1) * a4;
  int v27 = a2;
  int v28 = a3 >> 1;
  uint64_t v29 = a4;
  int v30 = a5;
  uint64_t v31 = a6 + 4 * (a3 >> 1);
  char v6 = 1;
  long long v7 = dispatch_queue_attr_make_with_autorelease_frequency(MEMORY[0x1E4F14430], DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  long long v8 = dispatch_queue_create("projectionCols_planar8UtoF", v7);
  uint64_t v9 = MEMORY[0x1E4F143A8];
  uint64_t v14 = MEMORY[0x1E4F143A8];
  uint64_t v15 = 0x40000000;
  uint64_t v16 = __Projections_projectionCols_planar8UtoF_block_invoke;
  uint64_t v17 = &__block_descriptor_tmp_4_0;
  uint64_t v18 = &v19;
  dispatch_async(v8, &v14);
  uint64_t v14 = v9;
  uint64_t v15 = 0x40000000;
  uint64_t v16 = __Projections_projectionCols_planar8UtoF_block_invoke;
  uint64_t v17 = &__block_descriptor_tmp_4_0;
  uint64_t v18 = &v26;
  dispatch_async(v8, &v14);
  dispatch_barrier_sync(v8, &__block_literal_global_7_0);
  uint64_t v10 = 0;
  do
  {
    uint64_t v11 = *((unsigned int *)&v25 + 12 * v10);
    if (v11) {
      break;
    }
    char v12 = v6;
    char v6 = 0;
    uint64_t v10 = 1;
  }
  while ((v12 & 1) != 0);
  dispatch_release(v8);
  return v11;
}

uint64_t Projections_projectionRowsCols_planar8UtoF()
{
  uint64_t v0 = MEMORY[0x1F4188790]();
  long long v8 = v7;
  uint64_t v9 = (float *)v4;
  uint64_t v10 = v3;
  int v11 = v2;
  int v12 = v1;
  uint64_t v13 = v0;
  STACK[0x6648] = *MEMORY[0x1E4F143B8];
  if (v2 & 1 | v1 & 0x1F || v3 & 0x1F | v0 & 0xF)
  {
    uint64_t v15 = Projections_projectionCols_planar8UtoF(v0, v1, v2, v3, 1, v4);
    if ((v15 & 0x80000000) != 0)
    {
      uint64_t v17 = v15;
      StatusDescription = Projections_getStatusDescription(v15);
      syslog(3, "Projections error %d:%s in %s @ %s:%d\n", v17, StatusDescription, "Projections_status Projections_projectionRowsCols_planar8UtoF(const uint8_t *, int, int, size_t, float *, float *)", "/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage/Framework/api/Burst/Projections/Projections_Core.c", 471);
      return v17;
    }
    else
    {
      uint64_t v16 = Projections_projectionRows_planar8UtoF(v13, v12, v11, v10, 1, (uint64_t)v8);
      uint64_t v14 = v16;
      if ((v16 & 0x80000000) != 0)
      {
        uint64_t v22 = Projections_getStatusDescription(v16);
        syslog(3, "Projections error %d:%s in %s @ %s:%d\n", v14, v22, "Projections_status Projections_projectionRowsCols_planar8UtoF(const uint8_t *, int, int, size_t, float *, float *)", "/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage/Framework/api/Burst/Projections/Projections_Core.c", 472);
      }
    }
  }
  else if (PixelSumASM((uint8x16_t *)v0, v1, v2, v3, &STACK[0x3340], &__A, v5, v6, v20))
  {
    uint64_t v14 = 0xFFFFFFFFLL;
    int v21 = Projections_getStatusDescription(-1);
    syslog(3, "Projections error %d:%s in %s @ %s:%d\n", -1, v21, "Projections_status Projections_projectionRowsCols_planar8UtoF(const uint8_t *, int, int, size_t, float *, float *)", "/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage/Framework/api/Burst/Projections/Projections_Core.c", 463);
  }
  else
  {
    vDSP_vflt32((const int *)&STACK[0x3340], 1, v9, 1, v11);
    vDSP_vflt32(__A.i32, 1, v8, 1, v12);
    return 0;
  }
  return v14;
}

uint64_t Projections_smoothProjection(uint64_t a1, int a2, int a3, uint64_t a4)
{
  int v4 = -a3;
  if (-a3 < a2)
  {
    uint64_t v5 = 0;
    int v6 = 0;
    int v7 = 0;
    int v8 = v4 - a3;
    do
    {
      unsigned int v9 = v8 + v5;
      if (v8 + v5 < 0 || v5 >= a2)
      {
        if (v5 < a2)
        {
          int v7 = (int)(float)(*(float *)(a1 + 4 * v5) + (float)v7);
          ++v6;
        }
        float v11 = (float)v7;
        if (((v4 + v5) & 0x8000000000000000) == 0) {
          *(float *)(a4 + 4 * (v5 - a3)) = v11 / (float)v6;
        }
        if ((v9 & 0x80000000) == 0)
        {
          int v7 = (int)(float)(v11 - *(float *)(a1 + 4 * v9));
          --v6;
        }
      }
      else
      {
        float v10 = (float)(int)(float)(*(float *)(a1 + 4 * v5) + (float)v7);
        *(float *)(a4 - 4 * a3 + 4 * v5) = v10 / (float)(v6 + 1);
        int v7 = (int)(float)(v10 - *(float *)(a1 + 4 * v9));
      }
      ++v5;
    }
    while (a3 + a2 != v5);
  }
  return 0;
}

uint64_t Projections_computeProjectionDerivative(const float *__B, int a2, float *a3)
{
  if (a2 > 1)
  {
    if (a2 == 3)
    {
      uint64_t v3 = 0;
      *a3 = __B[1] - *__B;
      a3[1] = -(float)(*__B - (float)(__B[2] * 0.5));
      a3[2] = __B[2] - __B[1];
    }
    else
    {
      vDSP_Length v5 = (a2 - 2);
      if (a2 == 2)
      {
        uint64_t v3 = 0;
        float v6 = __B[1] - *__B;
        *a3 = v6;
        a3[1] = v6;
      }
      else
      {
        *a3 = __B[1] - *__B;
        a3[a2 - 1] = __B[a2 - 1] - __B[v5];
        float __C = 0.5;
        vDSP_vsbsm(__B + 2, 1, __B, 1, &__C, a3 + 1, 1, v5);
        return 0;
      }
    }
  }
  else
  {
    uint64_t v3 = 0xFFFFFFFFLL;
    StatusDescription = Projections_getStatusDescription(-1);
    syslog(3, "Projections error %d:%s in %s @ %s:%d\n", -1, StatusDescription, "Projections_status Projections_computeProjectionDerivative(const float *, int, float *)", "/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage/Framework/api/Burst/Projections/Projections_Core.c", 528);
  }
  return v3;
}

char *Projections_getStatusDescription(int a1)
{
  return Projections_statusDescription[a1 + 4];
}

float32x2_t Projections_fastSqrtf(double a1)
{
  *(float *)&a1 = *(float *)&a1 + 0.0;
  float32x2_t v1 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a1, 0);
  int8x8_t v2 = (int8x8_t)vceqz_f32(v1);
  int8x8_t v3 = (int8x8_t)vcgt_s32((int32x2_t)v1, vdup_n_s32(0x7F7FFFFFu));
  float32x2_t v4 = vrsqrte_f32(v1);
  int8x8_t v5 = vorr_s8(v3, v2);
  __asm { FMOV            V3.2S, #1.0 }
  return vmul_f32(*(float32x2_t *)&a1, (float32x2_t)vbsl_s8(v5, _D3, (int8x8_t)vmul_f32(v4, vrsqrts_f32(v4, vmul_n_f32(v4, *(float *)&a1)))));
}

BOOL Projections_isZero(float a1)
{
  return (LODWORD(a1) & 0x7FFFFFFF) == 0;
}

uint64_t Projections_normalizeMeanStdUsingTable(uint64_t a1, int a2, int a3, void *a4, uint64_t a5, float *a6, float *a7, double a8)
{
  float v13 = (float)(a3 - a2 + 1);
  float v14 = (float)(*(float *)(a4[1] + 4 * (a3 + 1)) - *(float *)(a4[1] + 4 * a2)) / v13;
  *(float *)&a8 = (float)(*(float *)(*a4 + 4 * (a3 + 1)) - *(float *)(*a4 + 4 * a2)) / v13;
  *a6 = *(float *)&a8;
  *(float *)&a8 = v14 - (float)(*(float *)&a8 * *(float *)&a8);
  LODWORD(v15) = Projections_fastSqrtf(a8).u32[0];
  *a7 = v15;
  if (a5)
  {
    if (Projections_isZero(v15))
    {
      memcpy((void *)(a5 + 4 * a2), (const void *)(a1 + 4 * a2), vcvts_n_u32_f32(v13, 2uLL));
    }
    else
    {
      float __B = 1.0 / *a7;
      float __C = -(float)(*a6 * __B);
      vDSP_vsmsa((const float *)(a1 + 4 * a2), 1, &__B, &__C, (float *)(a5 + 4 * a2), 1, (unint64_t)v13);
    }
  }
  return 0;
}

uint64_t Projections_computeMeanStdTable(float *a1, int a2, void *a3)
{
  int8x8_t v3 = (_DWORD *)*a3;
  float32x2_t v4 = (_DWORD *)a3[1];
  *(_DWORD *)*a3 = 0;
  *float32x2_t v4 = 0;
  if (a2 >= 1)
  {
    int8x8_t v5 = (float *)(v3 + 1);
    float v6 = (float *)(v4 + 1);
    uint64_t v7 = (a2 + 1) - 1;
    do
    {
      float *v5 = *(v5 - 1) + *a1;
      ++v5;
      float v8 = *a1++;
      *float v6 = *(v6 - 1) + (float)(v8 * v8);
      ++v6;
      --v7;
    }
    while (v7);
  }
  return 0;
}

uint64_t Projections_computeShiftBruteForce(uint64_t a1, int a2, void *a3, uint64_t a4, int a5, void *a6, int a7, float *a8, float a9, float *a10, float *a11, float *a12)
{
  int v12 = a8;
  uint64_t v17 = a10;
  if (a2 <= a5) {
    int v18 = a5;
  }
  else {
    int v18 = a2;
  }
  int v19 = 2 * v18;
  CGFloat v50 = a8;
  if (!a8) {
    CGFloat v50 = (float *)malloc_type_malloc(4 * v19, 0x100004052888210uLL);
  }
  uint64_t v20 = a10;
  if (!a10) {
    uint64_t v20 = (float *)malloc_type_malloc(4 * v19, 0x100004052888210uLL);
  }
  int v21 = a12;
  *uint64_t v20 = 3.4028e38;
  int v22 = 1 - a2;
  float v23 = *a11;
  float v24 = 0.0;
  if (*a11 >= (float)(1 - a2))
  {
    float v25 = (float)(a5 - 1);
    if (v23 <= v25)
    {
      float v26 = v23 - (float)v22;
      float v27 = v25 - v23;
      if (v26 > v27) {
        float v27 = v26;
      }
      float v24 = a9 / v27;
    }
  }
  if (v22 >= a5)
  {
    int v36 = 0;
    uint64_t v31 = 0;
    float v32 = 3.4028e38;
  }
  else
  {
    float32x2_t v45 = v12;
    uint64_t v28 = 0;
    uint64_t v29 = (a5 + a2 - 1);
    do
    {
      v51[0] = 3.4028e38;
      uint64_t v30 = Projections_computeCost(v22 + (int)v28, a1, a2, a3, a4, a5, a6, a7, *a11, v24, v51);
      uint64_t v31 = v30;
      if ((v30 & 0x80000000) != 0)
      {
        StatusDescription = Projections_getStatusDescription(v30);
        syslog(3, "Projections error %d:%s in %s @ %s:%d\n", v31, StatusDescription, "Projections_status Projections_computeShiftBruteForce(const float *, int, const Projections_meanStdTable *, const float *, int, const Projections_meanStdTable *, int, float, float *, float *, float *, float *)", "/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage/Framework/api/Burst/Projections/Projections_Optimizer.c", 122);
        int v12 = v45;
        uint64_t v17 = a10;
        goto LABEL_36;
      }
      v50[v28] = (float)(v22 + v28);
      v20[v28++] = v51[0];
    }
    while (v29 != v28);
    float v32 = *v20;
    if (v29 < 2)
    {
      int v36 = 0;
      int v12 = v45;
      uint64_t v17 = a10;
    }
    else
    {
      uint64_t v33 = 0;
      char v34 = 0;
      int v35 = 0;
      int v36 = 0;
      uint64_t v37 = v29 - 1;
      float32x2_t v38 = (char *)(v50 + 1);
      float v39 = 3.4028e38;
      int v12 = v45;
      uint64_t v17 = a10;
      do
      {
        float v40 = v20[v33 + 1];
        if (v32 > v40)
        {
          int v36 = (int)*(float *)&v38[4 * v33];
          float v32 = v20[v33 + 1];
        }
        if (v33 + 1 < a5 + a2 - 2 && v39 > v40)
        {
          uint64_t v41 = &v20[v33];
          if (*v41 > v40 && v41[2] > v40)
          {
            int v35 = (int)*(float *)&v38[4 * v33];
            char v34 = 1;
            float v39 = v20[v33 + 1];
          }
        }
        ++v33;
      }
      while (v37 != v33);
      if (v34)
      {
        *a11 = (float)v35;
        *a12 = v39;
        goto LABEL_36;
      }
    }
    int v21 = a12;
  }
  *a11 = (float)v36;
  *int v21 = v32;
LABEL_36:
  if (!v12 && v50) {
    free(v50);
  }
  if (!v17) {
    free(v20);
  }
  return v31;
}

uint64_t Projections_computeCost(int a1, uint64_t a2, int a3, void *a4, uint64_t a5, int a6, void *a7, int a8, float a9, float a10, float *a11)
{
  uint64_t v11 = 0;
  unsigned int v12 = -a1 & (a1 >> 31);
  if (a3 - 1 >= a6 - 1 - a1) {
    int v13 = a6 - 1 - a1;
  }
  else {
    int v13 = a3 - 1;
  }
  if (a6 - 1 >= a3 - 1 + a1) {
    int v14 = a3 - 1 + a1;
  }
  else {
    int v14 = a6 - 1;
  }
  int v15 = v13 - v12 + 1;
  if (v15 >= a8)
  {
    unsigned int v22 = a1 & ~(a1 >> 31);
    float __C = 0.0;
    vDSP_dotpr((const float *)(a2 + 4 * v12), 1, (const float *)(a5 + 4 * v22), 1, &__C, v15);
    float __C = __C / (float)v15;
    *(float *)&double v23 = __C;
    float v33 = 0.0;
    uint64_t v32 = 0;
    float v31 = 0.0;
    uint64_t v24 = Projections_normalizeMeanStdUsingTable(a2, v12, v13, a4, 0, &v33, (float *)&v32 + 1, v23);
    if ((v24 & 0x80000000) != 0)
    {
      uint64_t v11 = v24;
      StatusDescription = Projections_getStatusDescription(v24);
      syslog(3, "Projections error %d:%s in %s @ %s:%d\n", v11, StatusDescription, "Projections_status Projections_computeCost(int, float, float, const float *, int, const Projections_meanStdTable *, const float *, int, const Projections_meanStdTable *, int, float *)", "/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage/Framework/api/Burst/Projections/Projections_Optimizer.c", 58);
    }
    else
    {
      uint64_t v26 = Projections_normalizeMeanStdUsingTable(a5, v22, v14, a7, 0, (float *)&v32, &v31, v25);
      uint64_t v11 = v26;
      if ((v26 & 0x80000000) != 0)
      {
        uint64_t v29 = Projections_getStatusDescription(v26);
        syslog(3, "Projections error %d:%s in %s @ %s:%d\n", v11, v29, "Projections_status Projections_computeCost(int, float, float, const float *, int, const Projections_meanStdTable *, const float *, int, const Projections_meanStdTable *, int, float *)", "/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage/Framework/api/Burst/Projections/Projections_Optimizer.c", 59);
      }
      else
      {
        *a11 = (float)((float)((float)((float)(*((float *)&v32 + 1) * v31) - __C) + (float)(v33 * *(float *)&v32))
                     / (float)((float)(*((float *)&v32 + 1) * v31) + (float)(*((float *)&v32 + 1) * v31)))
             + (float)(a10 * vabds_f32(a9, (float)a1));
      }
    }
  }
  return v11;
}

uint64_t nextPointAction(uint64_t result, int a2, uint64_t a3)
{
  double v3 = *(double *)(a3 + 8);
  double v4 = *(double *)(result + 8);
  float v5 = *(double *)a3 - *(double *)result;
  float v6 = v3 - v4;
  if (*(double *)(result + 24) * v6 + v5 * *(double *)(result + 16) > 0.0
    && *(double *)(a3 + 24) * v6 + v5 * *(double *)(a3 + 16) > 0.0)
  {
    float v7 = v4 * *(float *)(a3 + 88) + *(float *)(a3 + 84) * *(double *)result + *(float *)(a3 + 92);
    float v8 = v3 * *(float *)(result + 36) + *(float *)(result + 32) * *(double *)a3 + *(float *)(result + 40);
    if ((float)(fabsf(v7) + fabsf(v8)) < *(float *)(result + 44))
    {
      float v9 = (float)(v6 * v6) + (float)(v5 * v5);
      if (v9 < *(float *)(result + 48))
      {
        *(float *)(result + 4_Block_object_dispose(&STACK[0x238], 8) = v9;
        *(_DWORD *)(result + 52) = a2;
      }
    }
  }
  return result;
}

float32x2_t regressionMeanAction(float32x2_t *a1, uint64_t a2, float64x2_t *a3)
{
  float32x2_t v3 = vcvt_f32_f64(*a3);
  double v4 = a1;
  if (a1->f32[0] > v3.f32[0] || (double v4 = a1 + 1, a1[1].f32[0] < v3.f32[0])) {
    v4->i32[0] = v3.i32[0];
  }
  float v5 = (_DWORD *)a1 + 1;
  if (a1->f32[1] > v3.f32[1] || (float v5 = (_DWORD *)&a1[1] + 1, a1[1].f32[1] < v3.f32[1])) {
    _DWORD *v5 = v3.i32[1];
  }
  float32x2_t result = vadd_f32(a1[2], v3);
  a1[2] = result;
  ++a1[3].i32[0];
  return result;
}

float32x2_t regressionHorizontalAction(float32x2_t *a1, uint64_t a2, float64x2_t *a3)
{
  float32x2_t result = vsub_f32(vcvt_f32_f64(*a3), *a1);
  a1[1] = vmla_n_f32(a1[1], result, result.f32[0]);
  return result;
}

float32x2_t regressionVerticalAction(float32x2_t *a1, uint64_t a2, float64x2_t *a3)
{
  float32x2_t result = vsub_f32(vcvt_f32_f64(*a3), *a1);
  a1[1] = vmla_lane_f32(a1[1], (float32x2_t)vrev64_s32((int32x2_t)result), result, 1);
  return result;
}

uint64_t lineEquationThroughTwoPoints(float *a1, double a2, double a3, double a4, double a5)
{
  float v5 = a4 - a2;
  float v6 = a5 - a3;
  float v7 = sqrtf((float)(v6 * v6) + (float)(v5 * v5));
  if (v7 == 0.0) {
    return 43;
  }
  uint64_t v8 = 0;
  float v9 = 1.0 / v7;
  float v10 = v9 * v5;
  float v11 = -(float)(v9 * v6);
  *a1 = v11;
  a1[1] = v10;
  float v12 = a3 * v10 + v11 * a2;
  a1[2] = -v12;
  return v8;
}

void threadSearchAction(int *a1, uint64_t a2, int *a3)
{
  if (*((unsigned char *)a3 + 24) && !*((unsigned char *)a3 + 25))
  {
    int v5 = 0;
    unsigned int v20 = *a1;
    uint64_t v6 = *((void *)a1 + 1);
    uint64_t v7 = *((void *)a1 + 3);
    uint64_t v19 = *((void *)a1 + 4);
    uint64_t v21 = *((void *)a1 + 2);
    uint64_t v22 = *(void *)(v7 + 32) + 96 * *a3;
    int v8 = 1;
    do
    {
      uint64_t v9 = 0;
      do
      {
        int v10 = *(_DWORD *)(v6 + 8);
        if (v10 >= 2 * (int)v9)
        {
          int v11 = v5 - v9;
          if (a3[2] >= 2 * (v5 - (int)v9))
          {
            if (*a1 == a2 && v10 < v5 + 3) {
              return;
            }
            uint64_t v13 = v21;
            int v14 = v9;
            if (v9)
            {
              while (1)
              {
                int v15 = *(_DWORD *)(v13 + 72);
                if (v15 == -1) {
                  break;
                }
                uint64_t v13 = *(void *)(v7 + 32) + 96 * v15;
                if (!--v14) {
                  goto LABEL_17;
                }
              }
            }
            else
            {
LABEL_17:
              uint64_t v16 = v22;
              if (v11 < 1)
              {
LABEL_21:
                if (pointToPointScore(v13, v16) > 0.0) {
                  +[CIRedEyeRepair3 insertIntoConnectionHopper:index1:drop1:index2:drop2:score:](CIRedEyeRepair3, "insertIntoConnectionHopper:index1:drop1:index2:drop2:score:", v19, v20, v9, a2, (v5 - v9));
                }
              }
              else
              {
                int v17 = 0;
                uint64_t v16 = v22;
                while (1)
                {
                  int v18 = *(_DWORD *)(v16 + 68);
                  if (v18 == -1) {
                    break;
                  }
                  uint64_t v16 = *(void *)(v7 + 32) + 96 * v18;
                  if (++v17 >= v11) {
                    goto LABEL_21;
                  }
                }
              }
            }
          }
        }
        uint64_t v9 = (v9 + 1);
      }
      while (v9 != v8);
      ++v5;
      ++v8;
    }
    while (v5 != 11);
  }
}

float pointToPointScore(uint64_t a1, uint64_t a2)
{
  double v2 = *(double *)(a1 + 8);
  double v3 = *(double *)(a2 + 8);
  float v4 = *(double *)a2 - *(double *)a1;
  float v5 = v3 - v2;
  float result = -1.0;
  if (*(double *)(a1 + 24) * v5 + v4 * *(double *)(a1 + 16) > 0.0)
  {
    float result = -2.0;
    if (*(double *)(a2 + 24) * v5 + v4 * *(double *)(a2 + 16) > 0.0)
    {
      float v7 = v2 * *(float *)(a2 + 88) + *(float *)(a2 + 84) * *(double *)a1 + *(float *)(a2 + 92);
      float v8 = v3 * *(float *)(a1 + 88) + *(float *)(a1 + 84) * *(double *)a2 + *(float *)(a1 + 92);
      return sqrtf((float)(v5 * v5) + (float)(v4 * v4)) + (float)(fabsf(v8) + fabsf(v7)) * 0.333;
    }
  }
  return result;
}

void computeLengthAndAngle(uint64_t a1, double *a2)
{
  float v3 = *a2 - *(double *)a1;
  float v4 = a2[1] - *(double *)(a1 + 8);
  *(float *)(a1 + 16) = sqrtf((float)(v4 * v4) + (float)(v3 * v3));
  float v5 = atan2(v4, v3);
  double v6 = v5;
  if (v5 < 0.0)
  {
    double v7 = 6.28318531;
LABEL_5:
    float v5 = v6 + v7;
    goto LABEL_6;
  }
  if (v6 >= 6.28318531)
  {
    double v7 = -6.28318531;
    goto LABEL_5;
  }
LABEL_6:
  *(float *)(a1 + 20) = v5;
}

float bilinearFloat4LookupComponents(uint64_t a1, float *a2, float a3, float a4)
{
  float v4 = 0.0;
  float v5 = 0.0;
  if (a3 >= 0.0)
  {
    float v5 = a3;
    if ((float)(*(_DWORD *)(a1 + 8) - 1) < a3) {
      float v5 = (float)(*(_DWORD *)(a1 + 8) - 1);
    }
  }
  int v6 = *(_DWORD *)(a1 + 12);
  if (a4 >= 0.0)
  {
    float v4 = a4;
    if ((float)(v6 - 1) < a4) {
      float v4 = (float)(v6 - 1);
    }
  }
  int v7 = vcvtms_s32_f32(v5);
  signed int v8 = vcvtms_s32_f32(v4);
  if (*(_DWORD *)(a1 + 8) - 2 < v7) {
    int v7 = *(_DWORD *)(a1 + 8) - 2;
  }
  int v9 = v6 - 2;
  if (v9 >= v8) {
    int v9 = v8;
  }
  float v10 = v5 - (float)v7;
  float v11 = v4 - (float)v9;
  uint64_t v12 = *(int *)(a1 + 16);
  uint64_t v13 = *(int *)(a1 + 28);
  int v14 = (float *)(*(void *)a1 + 4 * v9 * (int)v12 + 4 * (int)v13 * v7);
  float v16 = v14[2];
  float v15 = v14[3];
  float v17 = v14[(int)v13 + 2];
  float v18 = v14[(int)v13 + 3];
  float v19 = v14[v12];
  float v20 = v14[(int)v12 + 1];
  float v21 = v14[(int)v12 + 2];
  int v22 = v12 + 3;
  double v23 = &v14[(int)v13 + (int)v12];
  float v24 = v23[2];
  float v25 = *v14 + (float)((float)(v14[v13] - *v14) * v10);
  float v26 = v25 + (float)((float)((float)(v19 + (float)((float)(*v23 - v19) * v10)) - v25) * v11);
  float v27 = v14[1] + (float)((float)(v14[(int)v13 + 1] - v14[1]) * v10);
  float v28 = v27 + (float)((float)((float)(v20 + (float)((float)(v23[1] - v20) * v10)) - v27) * v11);
  float v29 = (float)(v28 * v28) + (float)(v26 * v26);
  float v30 = 0.0;
  if (v29 != 0.0) {
    float v30 = 1.0 / sqrt(v29);
  }
  float v31 = v14[v22];
  float v32 = v23[3];
  *a2 = v26 * v30;
  a2[1] = v28 * v30;
  a2[2] = (float)(v16 + (float)((float)(v17 - v16) * v10))
        + (float)((float)((float)(v21 + (float)((float)(v24 - v21) * v10))
                        - (float)(v16 + (float)((float)(v17 - v16) * v10)))
                * v11);
  double v33 = (float)(v18 - v15);
  if (v33 >= -3.14159265)
  {
    if (v33 <= 3.14159265) {
      goto LABEL_18;
    }
    double v34 = v18;
    double v35 = -6.28318531;
  }
  else
  {
    double v34 = v18;
    double v35 = 6.28318531;
  }
  float v18 = v34 + v35;
LABEL_18:
  double v36 = (float)(v31 - v15);
  if (v36 >= -3.14159265)
  {
    if (v36 <= 3.14159265) {
      goto LABEL_23;
    }
    double v37 = v31;
    double v38 = -6.28318531;
  }
  else
  {
    double v37 = v31;
    double v38 = 6.28318531;
  }
  float v31 = v37 + v38;
LABEL_23:
  double v39 = (float)(v32 - v15);
  if (v39 < -3.14159265)
  {
    double v40 = v32;
    double v41 = 6.28318531;
LABEL_27:
    float v32 = v40 + v41;
    goto LABEL_28;
  }
  if (v39 > 3.14159265)
  {
    double v40 = v32;
    double v41 = -6.28318531;
    goto LABEL_27;
  }
LABEL_28:
  float result = (float)(v15 + (float)((float)(v18 - v15) * v10))
         + (float)((float)((float)(v31 + (float)((float)(v32 - v31) * v10))
                         - (float)(v15 + (float)((float)(v18 - v15) * v10)))
                 * v11);
  a2[3] = result;
  return result;
}

float checkpointScore(int a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + 8);
  float v5 = (double *)(v4 + 48 * *(int *)(a2 + 24 * a1 + 16));
  double v6 = *v5;
  double v7 = v5[1];
  if (a1 >= 1) {
    int v8 = a1;
  }
  else {
    int v8 = a3;
  }
  int v9 = (double *)(v4 + 48 * *(int *)(a2 + 24 * v8 - 8));
  double v10 = *v9;
  double v11 = v9[1];
  if (a1 + 1 < a3) {
    int v12 = a1 + 1;
  }
  else {
    int v12 = 0;
  }
  uint64_t v13 = (double *)(v4 + 48 * *(int *)(a2 + 24 * v12 + 16));
  float v14 = v6 - v10;
  float v15 = v7 - v11;
  float v16 = *v13 - v6;
  float v17 = v13[1] - v7;
  return sqrtf(sqrtf((float)(v15 * v15) + (float)(v14 * v14)) * sqrtf((float)(v17 * v17) + (float)(v16 * v16)));
}

void histogramBitmap(unsigned __int8 **a1, uint64_t a2, _DWORD *a3, _DWORD *a4, int *a5)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  bzero(v24, 0x400uLL);
  int v9 = *((_DWORD *)a1 + 3);
  if (v9 >= 1)
  {
    int v10 = 0;
    double v11 = *a1;
    int v12 = *((_DWORD *)a1 + 2);
    uint64_t v13 = *((int *)a1 + 4);
    do
    {
      if (v12 >= 1)
      {
        uint64_t v14 = *((int *)a1 + 7);
        int v15 = v12;
        float v16 = v11;
        do
        {
          ++v24[*v16];
          v16 += v14;
          --v15;
        }
        while (v15);
      }
      ++v10;
      v11 += v13;
    }
    while (v10 != v9);
  }
  uint64_t v17 = 0;
  int v18 = 0;
  do
  {
    v18 += v24[v17];
    if (v18 > 4) {
      break;
    }
    ++v17;
  }
  while (v17 != 256);
  int v19 = 0;
  for (int i = 255; i != -1; --i)
  {
    v19 += v24[i];
    if (v19 > 4) {
      break;
    }
  }
  uint64_t v21 = 0;
  int v22 = 0;
  int v23 = (*((_DWORD *)a1 + 2) * v9 + 1) >> 1;
  do
  {
    v22 += v24[v21];
    if (v22 > v23) {
      break;
    }
    ++v21;
  }
  while (v21 != 256);
  *a3 = v17;
  *a4 = v21;
  *a5 = i;
}

void **computeBitmask(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, float a7, double a8, float a9)
{
  v278[12] = *MEMORY[0x1E4F143B8];
  long long v262 = 0u;
  long long v263 = 0u;
  long long v260 = 0u;
  long long v261 = 0u;
  long long v258 = 0u;
  long long v259 = 0u;
  int v15 = *(_DWORD *)(a1 + 12);
  int v254 = *(_DWORD *)(a1 + 8);
  float v16 = -1.0;
  if (a7 >= 0.0) {
    float v16 = (float)(a7 * a7) * 0.25 * 3.14159265;
  }
  inited = (void **)initBitmask(v254, v15);
  if (!inited)
  {
    puts("computeBitmask: can not allocate bitmask bm");
    return 0;
  }
  int v18 = inited;
  uint64_t v241 = a4;
  int v243 = a6;
  int v244 = v15;
  int v19 = initBitmask(v254, v15);
  if (!v19)
  {
    puts("computeBitmask: can not allocate bitmask bm2");
    uint64_t v87 = v18;
    goto LABEL_147;
  }
  uint64_t v21 = (uint64_t)v19;
  uint64_t v274 = 0;
  uint64_t v275 = 0;
  uint64_t v273 = 0;
  *(_OWORD *)__dst = 0u;
  long long v271 = 0u;
  uint64_t v272 = 0;
  long long v264 = 0u;
  long long v265 = 0u;
  long long v266 = 0u;
  long long v267 = 0u;
  long long v268 = 0u;
  long long v269 = 0u;
  uint64_t v22 = a1;
  histogramBitmap((unsigned __int8 **)a1, v20, (_DWORD *)&v274 + 1, (_DWORD *)&v273 + 1, (int *)&v274);
  initBitmap((uint64_t)__dst, *(_DWORD *)(v22 + 8), *(_DWORD *)(v22 + 12), *(_DWORD *)(v22 + 28), 1, *(float *)(v22 + 36));
  memmove(__dst[0], *(const void **)v22, *(int *)(v22 + 24));
  applyMaxFilter8((uint64_t)__dst, 11);
  uint64_t v23 = *(int *)(a1 + 16);
  uint64_t v24 = *(int *)(a1 + 28);
  uint64_t v25 = (uint64_t *)v18;
  int v249 = v18;
  uint64_t v253 = v21;
  uint64_t v240 = a5;
  if (v243 != 2)
  {
    int v88 = *(_DWORD *)(a1 + 12);
    if (v88 < 1)
    {
      int v83 = 0;
      int v86 = 0;
      unsigned int v85 = 0;
      unsigned int v84 = 0;
    }
    else
    {
      unsigned int v89 = 0;
      unsigned int v84 = 0;
      unsigned int v85 = 0;
      int v83 = 0;
      int v90 = *(_DWORD *)(a1 + 8);
      uint64_t v91 = (unsigned __int8 *)__dst[0];
      double v92 = *(unsigned __int8 **)a1;
      int v93 = v88 * v90;
      do
      {
        if (v90 >= 1)
        {
          uint64_t v94 = 0;
          unsigned int v95 = 0;
          int v96 = (v89 - a3) * (v89 - a3);
          do
          {
            if (v92[v94]) {
              BOOL v97 = v91[v94] == v92[v94];
            }
            else {
              BOOL v97 = 0;
            }
            BOOL v98 = v97 && (int)(v96 + (v95 - a2) * (v95 - a2)) < v93;
            if (v98) {
              int v93 = v96 + (v95 - a2) * (v95 - a2);
            }
            if (v98) {
              int v83 = v92[v94];
            }
            if (v98) {
              unsigned int v85 = v89;
            }
            if (v98) {
              unsigned int v84 = v95;
            }
            ++v95;
            v94 += v24;
          }
          while (v90 != v95);
        }
        ++v89;
        v92 += v23;
        v91 += v23;
      }
      while (v89 != v88);
      int v86 = 0;
    }
    goto LABEL_111;
  }
  memset(v278, 0, 96);
  v277[0] = 0;
  uint64_t v26 = *(int *)(a1 + 12);
  if ((int)v26 < 1) {
    goto LABEL_145;
  }
  int v27 = 0;
  float v28 = *(unsigned __int8 **)a1;
  float v29 = (unsigned __int8 *)__dst[0];
  int v30 = *(_DWORD *)(a1 + 8);
  float v31 = *(unsigned __int8 **)a1;
  do
  {
    if (v30 >= 1)
    {
      int v32 = 0;
      double v33 = v29;
      double v34 = v31;
      do
      {
        if (v27)
        {
          unsigned int v35 = *v34;
          BOOL v36 = *v33 == v35 && v27 < (int)v26 - 1;
          BOOL v37 = !v36 || v32 == 0;
          if (!v37 && v32 < v30 - 1)
          {
            float v39 = sqrtf((float)((v27 - a3) * (v27 - a3) + (v32 - a2) * (v32 - a2)));
            float v40 = (float)v35 / fmaxf(v39, 1.0);
            int v41 = v277[0];
            if (v277[0] < 1)
            {
              LODWORD(v42) = 0;
            }
            else
            {
              unint64_t v42 = 0;
              uint64_t v43 = v277[0];
              uint64_t v44 = 3;
              while (*(float *)&v277[v44] >= v40)
              {
                ++v42;
                v44 += 6;
                if (v277[0] == v42)
                {
                  unint64_t v42 = v277[0];
                  goto LABEL_34;
                }
              }
              if (v277[0] > (int)v42)
              {
                float32x2_t v45 = &v278[3 * v277[0]];
                do
                {
                  if (v43 <= 3)
                  {
                    *(_OWORD *)float32x2_t v45 = *(_OWORD *)(v45 - 3);
                    v45[2] = *(v45 - 1);
                  }
                  --v43;
                  v45 -= 3;
                }
                while (v43 > (uint64_t)v42);
              }
              unint64_t v42 = v42;
LABEL_34:
              if (v42 > 3) {
                goto LABEL_40;
              }
              int v41 = v277[0];
            }
            unint64_t v46 = (float *)&v277[6 * v42];
            *((_DWORD *)v46 + 1) = v35;
            v46[2] = v39;
            v46[3] = v40;
            *((_DWORD *)v46 + 4) = v27;
            *((_DWORD *)v46 + 5) = v32;
            if (v41 < 4) {
              int v47 = v41 + 1;
            }
            else {
              int v47 = 4;
            }
            v277[0] = v47;
          }
        }
LABEL_40:
        ++v32;
        v34 += v24;
        v33 += v24;
      }
      while (v32 != v30);
    }
    ++v27;
    v31 += v23;
    v29 += v23;
  }
  while (v27 != v26);
  int v48 = v277[0];
  if (v277[0] < 1) {
    goto LABEL_145;
  }
  uint64_t v49 = 0;
  int v50 = 0;
  int v51 = 0;
  uint64_t v52 = v278;
  signed int v53 = *(_DWORD *)(a1 + 8);
  float v54 = -10000.0;
  int v55 = -1;
  do
  {
    uint64_t v56 = 0;
    int v57 = *((_DWORD *)v52 + 4);
    uint64_t v58 = *((int *)v52 + 3);
    int v59 = v57;
    do
    {
      signed int v60 = v57 + v56;
      int v61 = (v58 - v56) & ~(((int)v58 - (int)v56) >> 31);
      if (v56 + v58 < v26) {
        int v62 = v56 + v58 + 1;
      }
      else {
        int v62 = v26;
      }
      if (v60 < v53) {
        signed int v63 = v60 + 1;
      }
      else {
        signed int v63 = v53;
      }
      if (v61 >= v62)
      {
        int v65 = 255;
      }
      else
      {
        uint64_t v64 = &v28[(int)v23 * (uint64_t)v61];
        int v65 = 255;
        do
        {
          if (((v57 - v56) & ~((v57 - (int)v56) >> 31)) < v63)
          {
            uint64_t v66 = (int)(v24 * (v59 & ~(v59 >> 31)));
            signed int v67 = (v57 - v56) & ~((v57 - (int)v56) >> 31);
            do
            {
              if (v65 >= v64[v66]) {
                int v65 = v64[v66];
              }
              ++v67;
              v66 += v24;
            }
            while (v67 < v63);
          }
          ++v61;
          v64 += v23;
        }
        while (v61 < v62);
      }
      v276[v56++] = v65;
      --v59;
    }
    while (v56 != 11);
    int v68 = -1;
    int v69 = v276[0];
    for (uint64_t i = 1; i != 11; ++i)
    {
      int v71 = v276[i];
      int v72 = v69 - v71;
      if (v72 > v68)
      {
        int v68 = v72;
        int v50 = i;
      }
      int v69 = v71;
    }
    uint64_t v73 = v50;
    if (v50 <= 10) {
      uint64_t v74 = 10;
    }
    else {
      uint64_t v74 = v50;
    }
    uint64_t v75 = &v276[v50 + 1];
    uint64_t v25 = (uint64_t *)v249;
    uint64_t v21 = v253;
    while (v74 != v73)
    {
      uint64_t v76 = *(v75 - 1);
      if (v73 != 9)
      {
        ++v73;
        int v77 = *v75++;
        if (20 * ((int)v76 - v77) >= (int)v76) {
          continue;
        }
      }
      goto LABEL_75;
    }
    uint64_t v76 = v49;
LABEL_75:
    float v78 = *((float *)v52 + 1);
    float v79 = (float)*(int *)v52 / fmaxf((float)(int)v76, 1.0);
    *((_DWORD *)v52 + 5) = v76;
    float v80 = v79 + v78 * -0.05;
    if (v54 < v80)
    {
      int v55 = v51;
      float v54 = v80;
    }
    ++v51;
    v52 += 3;
    uint64_t v49 = v76;
  }
  while (v51 != v48);
  if (v54 == -10000.0 || v55 == -1)
  {
LABEL_145:
    double v128 = (void **)v25;
LABEL_146:
    termBitmask(v128);
    uint64_t v87 = (void **)v21;
    goto LABEL_147;
  }
  uint64_t v82 = &v277[6 * v55];
  int v83 = v82[1];
  LODWORD(v274) = v83;
  unsigned int v85 = v82[4];
  unsigned int v84 = v82[5];
  int v86 = v82[6];
LABEL_111:
  termBitmap(__dst);
  int v99 = v274;
  int v100 = HIDWORD(v273);
  if ((int)v274 > v83)
  {
    LODWORD(v274) = v83;
    int v99 = v83;
    if (SHIDWORD(v273) >= v83)
    {
      int v100 = v83 - 1;
      HIDWORD(v273) = v83 - 1;
      int v99 = v83;
    }
  }
  int v101 = (v100 + 2 * v99) / 3;
  if (v101 == v99) {
    int v102 = v99 - 1;
  }
  else {
    int v102 = v101;
  }
  computeThresholdedBitmask((unsigned __int8 *)a1, v25, v102);
  if (v244 < 1) {
    goto LABEL_143;
  }
  int v239 = v99;
  LODWORD(v23_Block_object_dispose(&STACK[0x238], 8) = v86;
  uint64_t v103 = 0;
  int v104 = v254;
  float v105 = (float)(v244 * v244 + v104 * v104);
  unsigned int v246 = -1;
  unsigned int v247 = -1;
  do
  {
    if (v104 >= 1)
    {
      unsigned int v106 = 0;
      unsigned int v250 = v103;
      do
      {
        if (bitValueFromBitmask((uint64_t)v25, v106, v103))
        {
          if (!seedFill((uint64_t)v25, v21, v106, v103, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))bitIsSet))
          {
            CGAffineTransform v127 = "computeBitmask: seedFill failed";
            goto LABEL_144;
          }
          uint64_t v107 = a2;
          double v108 = v25;
          uint64_t v109 = a3;
          unint64_t v110 = bitmaskBoundingBitmapRect(v21);
          uint64_t v112 = v111;
          bitmaskCentroidUsingBoundingRect(v21, v110, v111);
          unint64_t v113 = v110;
          a3 = v109;
          uint64_t v25 = v108;
          a2 = v107;
          uint64_t v114 = v112;
          int v104 = v254;
          closestSetBitInBitmaskUsingBoundingRect(v21, v113, v114, (int *)&v275 + 1, (int *)&v275, v115, v116);
          float v117 = (float)(v275 - a3) * (float)(v275 - a3);
          if ((float)(v117 + (float)((float)(HIDWORD(v275) - v107) * (float)(HIDWORD(v275) - v107))) < v105)
          {
            if (HIDWORD(v275) == -1)
            {
              puts("computeBitmask: centroid closest bit search failed");
              double v131 = (void **)v25;
              goto LABEL_151;
            }
            unsigned int v246 = HIDWORD(v275);
            unsigned int v247 = v275;
            float v105 = v117 + (float)((float)(HIDWORD(v275) - v107) * (float)(HIDWORD(v275) - v107));
            uint64_t v21 = v253;
          }
          bitmaskMinus((uint64_t)v25, v21);
          uint64_t v103 = v250;
        }
        ++v106;
      }
      while (v104 != v106);
    }
    uint64_t v103 = (v103 + 1);
  }
  while (v103 != v244);
  unsigned int v118 = v239;
  if (v247 == -1)
  {
LABEL_143:
    CGAffineTransform v127 = "computeBitmask: connected pieces search failed";
LABEL_144:
    puts(v127);
    goto LABEL_145;
  }
  int v119 = *(unsigned __int8 *)(v241 + 24);
  *(_DWORD *)uint64_t v240 = -1;
  if (v16 > 0.0 && v243 != -1 && !v119)
  {
    uint64_t v120 = a1;
    if ((v239 & 0x80000000) == 0)
    {
      float v121 = a9 * 0.055;
      uint64_t v122 = (uint64_t)rintf(v121 * v121);
      float v123 = a9 * 0.23;
      uint64_t v124 = (uint64_t)rintf(v123 * v123);
      int v125 = -1;
      while (1)
      {
        LODWORD(v273) = v118;
        if (!(v125 == -1
             ? seedFill(v120, (uint64_t)v249, v246, v247, (uint64_t)&v273, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))aboveThreshold): incrementalSeedFill(v120, (uint64_t)v249, v246, v247, (uint64_t)&v273, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))aboveThreshold)))break;
        if ((int)bitmaskArea((uint64_t)v249) >= (int)v122)
        {
          unsigned int v155 = v118;
          signed int v156 = v118 + 9;
          int v256 = v155 + 8;
          int v157 = -1;
          uint64_t v158 = a1;
          while (1)
          {
            unsigned int v159 = v155;
            LODWORD(v273) = v155;
            if (!(v157 == -1
                 ? seedFill(v158, (uint64_t)v249, v246, v247, (uint64_t)&v273, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))aboveThreshold): incrementalSeedFill(v158, (uint64_t)v249, v246, v247, (uint64_t)&v273, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))aboveThreshold)))goto LABEL_197;
            if ((int)bitmaskArea((uint64_t)v249) > (int)v124)
            {
              int v161 = v159;
              uint64_t v158 = a1;
LABEL_279:
              int v202 = v161 & ~(v161 >> 31);
              if (v256 >= v202)
              {
                int v203 = 0;
                int v204 = 256;
                int v205 = -1;
                float v206 = -1000000.0;
                do
                {
                  LODWORD(v273) = --v156;
                  if (v205 == -1) {
                    int v207 = seedFill(v158, (uint64_t)v249, v246, v247, (uint64_t)&v273, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))aboveThreshold);
                  }
                  else {
                    int v207 = incrementalSeedFill(v158, (uint64_t)v249, v246, v247, (uint64_t)&v273, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))aboveThreshold);
                  }
                  if (!v207) {
                    goto LABEL_314;
                  }
                  getBitmaskInfoWithSeedPoint((uint64_t)v249, (uint64_t *)a1, (uint64_t)&v264, v246, v247);
                  if ((int)v265 <= (int)v124 && (int)v265 >= (int)v122)
                  {
                    float v209 = (float)(*((float *)&v265 + 2) + *((float *)&v265 + 3)) / 255.0;
                    if ((float)(*((float *)&v265 + 1) + v209) > v206)
                    {
                      int v204 = v156;
                      float v206 = *((float *)&v265 + 1) + v209;
                      int v203 = v265;
                    }
                    int v205 = v156;
                  }
                  uint64_t v158 = a1;
                }
                while (v156 > v202);
                if (v205 != -1 && v203 <= (int)v124 && v203 >= (int)v122)
                {
                  LODWORD(v273) = v204;
                  if (!seedFill(a1, (uint64_t)v249, v246, v247, (uint64_t)&v273, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))aboveThreshold))
                  {
LABEL_314:
                    puts("computeBitmask: seedFill failed");
                    goto LABEL_315;
                  }
                  getBitmaskInfoWithSeedPoint((uint64_t)v249, (uint64_t *)a1, (uint64_t)&v264, v246, v247);
                  HIDWORD(v267) = v83;
                  *(void *)&long long v268 = __PAIR64__(v84, v85);
                  if (v243 != 2)
                  {
                    uint64_t v210 = 0;
                    double v211 = sqrt((float)(int)v265 / 3.14159265);
                    double v212 = v211 + v211;
                    float v213 = 0.0;
                    do
                    {
                      __double2 v214 = __sincos_stret(v213);
                      float cosval = v214.__cosval;
                      *(float *)&v277[v210] = cosval;
                      float sinval = v214.__sinval;
                      *(float *)&v276[v210] = sinval;
                      float v213 = v213 + 0.62832;
                      ++v210;
                    }
                    while (v210 != 10);
                    uint64_t v217 = 0;
                    int v218 = 0;
                    int v219 = 0;
                    float v220 = v212;
                    double v221 = v220 * 0.5;
                    do
                    {
                      float v222 = v221 * *(float *)&v277[v217];
                      int v223 = v84 + (uint64_t)rintf(v222);
                      if (v223 >= 0)
                      {
                        float v224 = v221 * *(float *)&v276[v217];
                        int v225 = v85 + (uint64_t)rintf(v224);
                        if ((v225 & 0x80000000) == 0 && v223 < *(_DWORD *)(a1 + 8) && v225 < *(_DWORD *)(a1 + 12))
                        {
                          ++v219;
                          v218 += *(unsigned __int8 *)(*(void *)a1
                                                     + *(_DWORD *)(a1 + 16) * v225
                                                     + *(_DWORD *)(a1 + 28) * v223);
                        }
                      }
                      ++v217;
                    }
                    while (v217 != 10);
                    uint64_t v238 = (uint64_t)rintf((float)v218 / (float)v219);
                  }
                  DWORD2(v26_Block_object_dispose(&STACK[0x238], 8) = v238;
                  if (!BYTE8(v267))
                  {
                    long long v226 = v267;
                    *(_OWORD *)(v240 + 40) = v266;
                    *(_OWORD *)(v240 + 56) = v226;
                    long long v227 = v269;
                    *(_OWORD *)(v240 + 72) = v268;
                    *(_OWORD *)(v240 + 8_Block_object_dispose(&STACK[0x238], 8) = v227;
                    long long v228 = v265;
                    *(_OWORD *)(v240 + _Block_object_dispose(&STACK[0x238], 8) = v264;
                    *(_DWORD *)uint64_t v240 = v204;
                    *(_OWORD *)(v240 + 24) = v228;
                    *(_DWORD *)(v240 + 104) = v246;
                    *(_DWORD *)(v240 + 10_Block_object_dispose(&STACK[0x238], 8) = v247;
                    double v129 = v249;
                    spreadBitmask((uint64_t)v249, v253, 0);
                    chokeBitmask(v253, (uint64_t)v249, 0);
                    double v201 = (void **)v253;
                    goto LABEL_275;
                  }
                }
              }
              goto LABEL_315;
            }
            int v161 = v159 - 8;
            int v157 = v159;
            unsigned int v155 = v159 - 8;
            uint64_t v158 = a1;
            if (v159 <= 7) {
              goto LABEL_279;
            }
          }
        }
        int v125 = v118;
        BOOL v36 = v118 > 7;
        v118 -= 8;
        uint64_t v120 = a1;
        if (!v36) {
          goto LABEL_198;
        }
      }
LABEL_197:
      puts("computeBitmask: seedFill failed");
    }
LABEL_198:
    double v128 = v249;
    goto LABEL_146;
  }
  float v132 = 0.0;
  float v133 = 0.0;
  int v134 = v243;
  CGRect v135 = (uint64_t *)a1;
  uint64_t v136 = v246;
  if (v243 == -1) {
    float v133 = 2.0 / (float)*(int *)(v241 + 28);
  }
  int v137 = HIDWORD(v274);
  if (v239 < SHIDWORD(v274))
  {
    int v138 = 0;
    int v139 = 256;
    goto LABEL_205;
  }
  int v140 = 0;
  int v141 = 0;
  int v142 = 0;
  unsigned int v236 = (_OWORD *)(v240 + 8);
  int v237 = 256;
  int v143 = -1;
  float v144 = 0.0;
  int v145 = v239;
  int v242 = HIDWORD(v274);
  while (2)
  {
    int v245 = v145;
    int v251 = v142;
    int v146 = v118 + v140;
    LODWORD(v273) = v118 + v140;
    int v255 = v143;
    if (v143 == -1)
    {
      double v147 = v249;
      if (!seedFill((uint64_t)v135, (uint64_t)v249, v246, v247, (uint64_t)&v273, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))aboveThreshold))
      {
LABEL_199:
        puts("computeBitmask: seedFill failed");
        double v131 = v147;
        goto LABEL_151;
      }
      getBitmaskInfoWithSeedPoint((uint64_t)v249, v135, (uint64_t)&v264, v246, v247);
      float v148 = 0.0;
    }
    else
    {
      double v147 = v249;
      if (!incrementalSeedFill((uint64_t)v135, (uint64_t)v249, v246, v247, (uint64_t)&v273, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))aboveThreshold))goto LABEL_199; {
      getBitmaskInfoWithSeedPoint((uint64_t)v249, v135, (uint64_t)&v264, v246, v247);
      }
      float v148 = breakoutScore((uint64_t)&v258, (uint64_t)&v264);
    }
    int v149 = v141 | ((int)v265 < 1);
    int v142 = v251;
    if (!(v141 & 1 | ((int)v265 < 1))) {
      int v142 = v146;
    }
    int v139 = v255;
    unsigned int v118 = v239;
    if (v243 == 2)
    {
      CGRect v135 = (uint64_t *)a1;
      if (v265 == 1 || BYTE8(v267)) {
        float v150 = 0.0;
      }
      else {
        float v150 = *((float *)&v265 + 1) * (float)(fminf(*((float *)&v265 + 2), 100.0) + *((float *)&v265 + 3));
      }
      int v137 = v242;
      if (v255 == -1) {
        goto LABEL_181;
      }
LABEL_180:
      if (v150 > v132) {
        goto LABEL_181;
      }
    }
    else
    {
      CGRect v135 = (uint64_t *)a1;
      if (v243 == -1)
      {
        float v151 = 1.0 - (float)(v133 * (float)(int)v265);
        if (v151 < 0.0) {
          float v151 = 0.0;
        }
        if (v151 > 1.0) {
          float v151 = 1.0;
        }
        float v150 = (float)((float)(v151 * v151) * *((float *)&v265 + 1))
             * (float)(*((float *)&v265 + 2) + *((float *)&v265 + 3));
        int v137 = v242;
        if (v255 != -1) {
          goto LABEL_180;
        }
LABEL_181:
        *(_DWORD *)uint64_t v240 = v146;
        long long v152 = v267;
        *(_OWORD *)(v240 + 40) = v266;
        *(_OWORD *)(v240 + 56) = v152;
        long long v153 = v269;
        *(_OWORD *)(v240 + 72) = v268;
        *(_OWORD *)(v240 + 8_Block_object_dispose(&STACK[0x238], 8) = v153;
        long long v154 = v265;
        int v237 = v146;
        float v132 = v150;
        *unsigned int v236 = v264;
        *(_OWORD *)(v240 + 24) = v154;
      }
      else
      {
        int v137 = v242;
        if (v255 != -1 && (v148 > 1.0 || v148 > 0.44 && v144 * 30.0 < v148) && (float)v142 * 0.68 >= (float)v146)
        {
          *(_DWORD *)uint64_t v240 = v255;
          long long v232 = v261;
          *(_OWORD *)(v240 + 40) = v260;
          *(_OWORD *)(v240 + 56) = v232;
          long long v233 = v263;
          *(_OWORD *)(v240 + 72) = v262;
          *(_OWORD *)(v240 + 8_Block_object_dispose(&STACK[0x238], 8) = v233;
          long long v234 = v259;
          int v235 = v255;
          *unsigned int v236 = v258;
          *(_OWORD *)(v240 + 24) = v234;
          uint64_t v136 = v246;
          goto LABEL_217;
        }
      }
    }
    if (!BYTE8(v267))
    {
      v141 |= v149 ^ 1;
      long long v260 = v266;
      long long v261 = v267;
      long long v262 = v268;
      long long v263 = v269;
      long long v258 = v264;
      long long v259 = v265;
      float v144 = v144 * 0.2 + v148 * 0.8;
      int v143 = v245;
      int v145 = v245 - 8;
      v140 -= 8;
      if (v239 + v140 < v137)
      {
        int v138 = 0;
        int v134 = v243;
        goto LABEL_203;
      }
      continue;
    }
    break;
  }
  int v138 = 0;
  int v134 = v243;
  if (v243 != -1)
  {
    uint64_t v136 = v246;
    if (v243 == 2)
    {
      int v134 = 2;
      goto LABEL_204;
    }
    if (v140)
    {
      if (v255 == -1) {
        int v139 = v239 + v140;
      }
      *(_DWORD *)uint64_t v240 = v139;
      long long v229 = v261;
      *(_OWORD *)(v240 + 40) = v260;
      *(_OWORD *)(v240 + 56) = v229;
      long long v230 = v263;
      *(_OWORD *)(v240 + 72) = v262;
      *(_OWORD *)(v240 + 8_Block_object_dispose(&STACK[0x238], 8) = v230;
      long long v231 = v259;
      int v138 = 1;
      *unsigned int v236 = v258;
      *(_OWORD *)(v240 + 24) = v231;
      int v134 = v243;
      goto LABEL_205;
    }
LABEL_315:
    double v131 = v249;
LABEL_151:
    termBitmask(v131);
    uint64_t v87 = (void **)v253;
LABEL_147:
    termBitmask(v87);
    return 0;
  }
LABEL_203:
  uint64_t v136 = v246;
LABEL_204:
  int v139 = v237;
LABEL_205:
  if (v134 == 2 || v134 == -1)
  {
    if (v139 <= 247) {
      int v235 = v139 + 8;
    }
    else {
      int v235 = 255;
    }
    if (v139 <= 8) {
      int v162 = 8;
    }
    else {
      int v162 = v139;
    }
    int v137 = v162 - 8;
  }
  else if (v138)
  {
    int v235 = v139;
  }
  else
  {
    int v235 = v137 + 8;
  }
LABEL_217:
  int v257 = v139;
  if (v235 < v137)
  {
    char v163 = 0;
    int v164 = -1;
    goto LABEL_256;
  }
  float v252 = (_OWORD *)(v240 + 8);
  int v164 = -1;
  float v165 = 0.0;
  while (2)
  {
    uint64_t v166 = v136;
    LODWORD(v273) = v235;
    if (v164 == -1)
    {
      double v167 = v249;
      if (!seedFill((uint64_t)v135, (uint64_t)v249, v166, v247, (uint64_t)&v273, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))aboveThreshold))
      {
LABEL_252:
        puts("computeBitmask: seedFill failed");
        double v131 = v167;
        goto LABEL_151;
      }
      getBitmaskInfoWithSeedPoint((uint64_t)v249, v135, (uint64_t)&v264, v166, v247);
      float v168 = 0.0;
    }
    else
    {
      double v167 = v249;
      if (!incrementalSeedFill((uint64_t)v135, (uint64_t)v249, v166, v247, (uint64_t)&v273, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))aboveThreshold))goto LABEL_252; {
      getBitmaskInfoWithSeedPoint((uint64_t)v249, v135, (uint64_t)&v264, v166, v247);
      }
      float v168 = breakoutScore((uint64_t)&v258, (uint64_t)&v264);
    }
    uint64_t v136 = v166;
    if (v243 == 2)
    {
      CGRect v135 = (uint64_t *)a1;
      if (v265 == 1 || BYTE8(v267)) {
        float v169 = 0.0;
      }
      else {
        float v169 = *((float *)&v265 + 1) * (float)(fminf(*((float *)&v265 + 2), 100.0) + *((float *)&v265 + 3));
      }
      goto LABEL_246;
    }
    CGRect v135 = (uint64_t *)a1;
    if (v243 == -1)
    {
      float v171 = 1.0 - (float)(v133 * (float)(int)v265);
      if (v171 < 0.0) {
        float v171 = 0.0;
      }
      if (v171 > 1.0) {
        float v171 = 1.0;
      }
      float v169 = (float)(*((float *)&v265 + 2) + *((float *)&v265 + 3))
           * (float)(*((float *)&v265 + 1) * (float)(v171 * v171));
      if (v164 != -1)
      {
LABEL_246:
        if (v169 <= v132) {
          goto LABEL_248;
        }
      }
      *(_DWORD *)uint64_t v240 = v235;
      long long v172 = v267;
      *(_OWORD *)(v240 + 40) = v266;
      *(_OWORD *)(v240 + 56) = v172;
      long long v173 = v269;
      *(_OWORD *)(v240 + 72) = v268;
      *(_OWORD *)(v240 + 8_Block_object_dispose(&STACK[0x238], 8) = v173;
      long long v174 = v265;
      int v257 = v235;
      float v132 = v169;
      _OWORD *v252 = v264;
      *(_OWORD *)(v240 + 24) = v174;
    }
    else if (v164 != -1)
    {
      BOOL v170 = *((float *)&v259 + 3) * 0.6 <= *((float *)&v265 + 3) && v168 <= 1.0;
      if (!v170 || v168 > 0.55 && v165 * 30.0 < v168) {
        goto LABEL_255;
      }
    }
LABEL_248:
    if (!BYTE8(v267))
    {
      long long v260 = v266;
      long long v261 = v267;
      long long v262 = v268;
      long long v263 = v269;
      long long v258 = v264;
      long long v259 = v265;
      float v165 = v165 * 0.2 + v168 * 0.8;
      int v164 = v235;
      BOOL v36 = v235-- <= v137;
      if (v36)
      {
        char v163 = 0;
        int v164 = v137;
        goto LABEL_256;
      }
      continue;
    }
    break;
  }
  char v163 = 0;
  int v175 = v243;
  if (v243 == -1) {
    goto LABEL_257;
  }
  if (v243 != 2)
  {
LABEL_255:
    long long v176 = v261;
    *(_OWORD *)(v240 + 40) = v260;
    *(_OWORD *)(v240 + 56) = v176;
    long long v177 = v263;
    *(_OWORD *)(v240 + 72) = v262;
    *(_OWORD *)(v240 + 8_Block_object_dispose(&STACK[0x238], 8) = v177;
    long long v178 = v259;
    _OWORD *v252 = v258;
    *(_OWORD *)(v240 + 24) = v178;
    char v163 = 1;
    int v257 = v164;
    *(_DWORD *)uint64_t v240 = v164;
  }
LABEL_256:
  int v175 = v243;
LABEL_257:
  if (v175 != -1 && v175 != 2 && (v163 & 1) == 0)
  {
    *(_DWORD *)uint64_t v240 = v164;
    long long v179 = v261;
    *(_OWORD *)(v240 + 40) = v260;
    *(_OWORD *)(v240 + 56) = v179;
    long long v180 = v263;
    *(_OWORD *)(v240 + 72) = v262;
    *(_OWORD *)(v240 + 8_Block_object_dispose(&STACK[0x238], 8) = v180;
    long long v181 = v259;
    *(_OWORD *)(v240 + _Block_object_dispose(&STACK[0x238], 8) = v258;
    int v257 = v164;
    *(_OWORD *)(v240 + 24) = v181;
  }
  LODWORD(v273) = v257;
  if (!seedFill((uint64_t)v135, (uint64_t)v249, v136, v247, (uint64_t)&v273, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))aboveThreshold))
  {
    puts("computeBitmask: seedFill failed");
    goto LABEL_277;
  }
  getBitmaskInfoWithSeedPoint((uint64_t)v249, v135, (uint64_t)&v264, v136, v247);
  HIDWORD(v267) = v83;
  *(void *)&long long v268 = __PAIR64__(v84, v85);
  if (BYTE8(v267))
  {
LABEL_277:
    termBitmask(v249);
    uint64_t v87 = (void **)v253;
    goto LABEL_147;
  }
  if (v175 != 2)
  {
    uint64_t v182 = 0;
    double v183 = sqrt((float)(int)v265 / 3.14159265);
    double v184 = v183 + v183;
    float v185 = 0.0;
    do
    {
      __double2 v186 = __sincos_stret(v185);
      float v187 = v186.__cosval;
      *(float *)&v277[v182] = v187;
      float v188 = v186.__sinval;
      *(float *)&v276[v182] = v188;
      float v185 = v185 + 0.62832;
      ++v182;
    }
    while (v182 != 10);
    uint64_t v189 = 0;
    int v190 = 0;
    int v191 = 0;
    float v192 = v184;
    double v193 = v192 * 0.5;
    do
    {
      float v194 = v193 * *(float *)&v277[v189];
      int v195 = v84 + (uint64_t)rintf(v194);
      if (v195 >= 0)
      {
        float v196 = v193 * *(float *)&v276[v189];
        int v197 = v85 + (uint64_t)rintf(v196);
        if ((v197 & 0x80000000) == 0 && v195 < *(_DWORD *)(a1 + 8) && v197 < *(_DWORD *)(a1 + 12))
        {
          ++v191;
          v190 += *(unsigned __int8 *)(*(void *)a1 + *(_DWORD *)(a1 + 16) * v197 + *(_DWORD *)(a1 + 28) * v195);
        }
      }
      ++v189;
    }
    while (v189 != 10);
    uint64_t v238 = (uint64_t)rintf((float)v190 / (float)v191);
  }
  DWORD2(v26_Block_object_dispose(&STACK[0x238], 8) = v238;
  long long v198 = v267;
  *(_OWORD *)(v240 + 40) = v266;
  *(_OWORD *)(v240 + 56) = v198;
  long long v199 = v268;
  *(_OWORD *)(v240 + 8_Block_object_dispose(&STACK[0x238], 8) = v269;
  long long v200 = v265;
  *(_OWORD *)(v240 + _Block_object_dispose(&STACK[0x238], 8) = v264;
  *(_OWORD *)(v240 + 24) = v200;
  *(_DWORD *)uint64_t v240 = v257;
  *(_OWORD *)(v240 + 72) = v199;
  *(_DWORD *)(v240 + 104) = v136;
  *(_DWORD *)(v240 + 10_Block_object_dispose(&STACK[0x238], 8) = v247;
  double v129 = v249;
  spreadBitmask((uint64_t)v249, v253, 0);
  chokeBitmask(v253, (uint64_t)v249, 0);
  double v201 = (void **)v253;
LABEL_275:
  termBitmask(v201);
  return v129;
}

uint64_t bitIsSet(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  return bitValueFromBitmask(a2, a3, a4);
}

BOOL aboveThreshold(_DWORD *a1, uint64_t a2, int a3, int a4)
{
  return *a1 < (int)*(unsigned __int8 *)(*(void *)a2 + *(_DWORD *)(a2 + 16) * a4 + *(_DWORD *)(a2 + 28) * a3);
}

float breakoutScore(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 16);
  float result = 0.0;
  if (v2 < 6) {
    return result;
  }
  float v4 = (float)*(int *)(a2 + 16) / (float)v2;
  float v5 = *(float *)(a1 + 20);
  float v6 = 0.01;
  if (v5 <= 0.0) {
    float v7 = 0.01;
  }
  else {
    float v7 = *(float *)(a1 + 20);
  }
  if ((float)(*(float *)(a1 + 24) + *(float *)(a1 + 28)) != 0.0) {
    float v6 = *(float *)(a1 + 24) + *(float *)(a1 + 28);
  }
  float v8 = 1.0;
  if (v4 <= 5.0)
  {
    double v9 = v4;
    if (v4 > 3.0)
    {
      double v10 = (v9 + -3.0) * 0.125 + 0.75;
LABEL_14:
      float v8 = v10;
      goto LABEL_15;
    }
    if (v4 > 1.5)
    {
      double v10 = (v9 + -1.5) * 0.3333333 + 0.25;
      goto LABEL_14;
    }
    float v8 = 0.0;
    if (v9 > 1.1)
    {
      double v10 = (v9 + -1.1) * 0.625;
      goto LABEL_14;
    }
  }
LABEL_15:
  float v11 = *(float *)(a2 + 20);
  double v12 = v5;
  float v13 = 0.0;
  float v14 = (float)(*(float *)(a2 + 24) + *(float *)(a2 + 28)) / v6;
  if (v12 >= 0.3 || v11 >= 0.3)
  {
    float v15 = v11 / v7;
    float v13 = 1.0;
    if (v15 >= 0.25)
    {
      float v13 = 0.0;
      if (v15 < 0.5) {
        float v13 = (0.5 - v15) * 4.0;
      }
    }
  }
  double v16 = v14;
  float v17 = 1.0;
  if (v14 >= 0.61)
  {
    if (v16 >= 0.8)
    {
      float v17 = 0.0;
      if (v14 < 2.0) {
        float v17 = v14 * -0.5;
      }
    }
    else
    {
      float v17 = (0.8 - v16) * 5.26316;
    }
  }
  float result = (float)(v8 + v13) + v17;
  if (result < 0.0) {
    return 0.0;
  }
  return result;
}

void **recomputeBitmask(uint64_t a1, int a2, uint64_t a3, int a4, uint64_t a5)
{
  int v11 = *(_DWORD *)(a1 + 8);
  int v10 = *(_DWORD *)(a1 + 12);
  inited = (void **)initBitmask(v11, v10);
  if (!inited)
  {
    puts("recomputeBitmask: can not allocate bitmask bm");
    return inited;
  }
  float v13 = (void **)initBitmask(v11, v10);
  if (!v13)
  {
    puts("recomputeBitmask: can not allocate bitmask bm2");
    float v15 = inited;
LABEL_11:
    termBitmask(v15);
    return 0;
  }
  float v14 = v13;
  int v17 = a4;
  if (!seedFill(a1, (uint64_t)inited, a2, a3, (uint64_t)&v17, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))aboveThreshold))
  {
    puts("recomputeBitmask: seedFill failed");
LABEL_10:
    termBitmask(inited);
    float v15 = v14;
    goto LABEL_11;
  }
  if (a5)
  {
    getBitmaskInfo((uint64_t)inited, (uint64_t *)a1, a5);
    if (*(unsigned char *)(a5 + 56)) {
      goto LABEL_10;
    }
  }
  spreadBitmask((uint64_t)inited, (uint64_t)v14, 0);
  chokeBitmask((uint64_t)v14, (uint64_t)inited, 0);
  termBitmask(v14);
  return inited;
}

void **extractAlpha(uint64_t a1, uint64_t a2, unsigned char *a3, int *a4)
{
  if (!a2) {
    return 0;
  }
  int v8 = *(_DWORD *)(a1 + 8);
  int v7 = *(_DWORD *)(a1 + 12);
  size_t v9 = *(int *)(a1 + 16);
  uint64_t v10 = *(int *)(a1 + 28);
  float result = (void **)zmalloc(0x28uLL);
  if (result)
  {
    double v12 = result;
    initBitmap((uint64_t)result, v8, v7, 1, 1, 100.0);
    bzero(*v12, *((int *)v12 + 6));
    inited = (void **)initBitmask(v8, v7);
    int v140 = v8;
    int v141 = v7 - 1;
    int v119 = a4;
    uint64_t v120 = (const void **)v12;
    size_t v155 = v9;
    uint64_t v139 = 2 * v10;
    int v118 = v7;
    if (v7 >= 3)
    {
      int v142 = a3;
      uint64_t v13 = 0;
      int v14 = 0;
      float v15 = (char *)*v12;
      uint64_t v150 = -(int)v9;
      float v151 = (void *)a1;
      uint64_t v149 = v150 - v10;
      uint64_t v148 = (int)v10 - (int)v9;
      uint64_t v147 = -v10;
      uint64_t v146 = (int)v9 - (int)v10;
      uint64_t v145 = (int)v10 + (int)v9;
      int v143 = v7 - 2;
      int v144 = v8 - 2;
      size_t v137 = (size_t)*v12 + v10 + v9;
      uint64_t v136 = (uint64_t)*v12 + 2 * v10;
      uint64_t v134 = (uint64_t)*v12 + 2 * v10 + 2 * v9;
      uint64_t v135 = (uint64_t)*v12 + v10;
      size_t v16 = v10 + 2 * v9;
      uint64_t v133 = (uint64_t)*v12 + v16;
      size_t v132 = (size_t)*v12 + v9;
      size_t v17 = v9 + 2 * v10;
      size_t v130 = *(void *)a1 + v9 + v150;
      size_t v131 = (size_t)*v12 + v17;
      uint64_t v129 = *(void *)a1 + v10;
      size_t v128 = *(void *)a1 + v10 + v9 + v148;
      size_t v127 = *(void *)a1 + v9;
      size_t v126 = *(void *)a1 + v17;
      uint64_t v125 = *(void *)a1 + v16;
      size_t v124 = *(void *)a1 + v10 + v9 + v145;
      size_t v123 = *(void *)a1 + v10 + v9;
      int v161 = 2 - v8;
      int v18 = 1;
      int v138 = v15;
      float v121 = &v15[2 * v9];
      uint64_t v122 = *(void *)a1 + 2 * v9;
      uint64_t v164 = v10;
      while (v8 <= 2)
      {
        int v97 = v18 + 1;
LABEL_108:
        v13 += v9;
        int v18 = v97;
        if (v97 == v141) {
          goto LABEL_112;
        }
      }
      int v156 = v14;
      int v19 = v18 - 1;
      int v163 = v18 + 1;
      unsigned int v20 = 1;
      size_t v190 = v123;
      size_t v22 = v124;
      uint64_t v21 = v125;
      uint64_t v23 = v122;
      size_t v24 = v126;
      size_t v25 = v127;
      size_t v27 = v128;
      uint64_t v26 = v129;
      size_t v28 = v130;
      size_t v29 = v131;
      size_t v30 = v132;
      float v187 = v121;
      uint64_t v186 = v133;
      uint64_t v31 = v134;
      float v185 = v138;
      uint64_t v184 = v135;
      uint64_t v183 = v136;
      size_t v189 = v137;
      int v169 = v18;
      int v162 = v18 - 1;
      while (1)
      {
        size_t v179 = v30;
        size_t v180 = v29;
        size_t v173 = v28;
        int v168 = *(unsigned __int8 *)(v28 + v13);
        uint64_t v174 = v26;
        int v165 = *(unsigned __int8 *)(v26 + v13);
        unsigned int v32 = v20;
        int v33 = v19;
        uint64_t v34 = v21;
        uint64_t v35 = v23;
        size_t v36 = v24;
        int v170 = bitValueFromBitmask(a2, v20, v33);
        size_t v175 = v27;
        int v166 = *(unsigned __int8 *)(v27 + v13);
        size_t v181 = v25;
        int v167 = *(unsigned __int8 *)(v25 + v13);
        int v37 = bitValueFromBitmask(a2, v32 - 1, v18);
        int v38 = bitValueFromBitmask(a2, v32, v18);
        size_t v176 = v36;
        int v39 = *(unsigned __int8 *)(v36 + v13);
        unsigned int v192 = v32 + 1;
        int v40 = bitValueFromBitmask(a2, v32 + 1, v18);
        uint64_t v177 = v35;
        uint64_t v178 = v34;
        int v41 = *(unsigned __int8 *)(v35 + v13);
        int v42 = *(unsigned __int8 *)(v34 + v13);
        int v43 = bitValueFromBitmask(a2, v32, v163);
        if (v38 != 1) {
          break;
        }
        int v160 = v39;
        unsigned int v158 = v32 - 1;
        unsigned int v159 = v32;
        if (v37 + v170 + v40 + v43 == 4) {
          break;
        }
        int v53 = *(unsigned __int8 *)(v22 + v13);
        int v54 = v166 - (v168 + v41) + 2 * (v39 - v167) + v53;
        int v55 = v41 - (v166 + v168) + v53 + 2 * (v42 - v165);
        int v56 = v54 * v54 + v55 * v55;
        if (!v56)
        {
          int v18 = v169;
          int v19 = v162;
          goto LABEL_10;
        }
        int v171 = *(unsigned __int8 *)(v22 + v13);
        float v57 = 1.0 / sqrtf((float)v56);
        float v58 = v57 * (float)v54;
        float v59 = v57 * (float)v55;
        int v60 = v32 + (uint64_t)rintf(v58 + v58);
        int v61 = v169 + (uint64_t)rintf(v59 + v59);
        int v62 = v32 - (uint64_t)rintf(v58 * 3.0);
        int v63 = v169 - (uint64_t)rintf(v59 * 3.0);
        if (v60 <= 1) {
          int v60 = 1;
        }
        if (v60 >= v144) {
          int v60 = v144;
        }
        if (v61 <= 1) {
          int v61 = 1;
        }
        if (v61 >= v143) {
          int v61 = v143;
        }
        if (v62 <= 1) {
          int v62 = 1;
        }
        if (v62 >= v144) {
          int v62 = v144;
        }
        if (v63 <= 1) {
          int v63 = 1;
        }
        if (v63 >= v143) {
          int v65 = v143;
        }
        else {
          int v65 = v63;
        }
        uint64_t v64 = (unsigned __int8 *)(*v151 + v61 * (int)v155 + v60 * (int)v164);
        unsigned int v66 = (v64[v149]
             + v64[v148]
             + 4 * *v64
             + v64[v146]
             + v64[v145]
             + 2 * (v64[v147] + v64[v150] + v64[v164] + v64[v155])
             + 8) >> 4;
        signed int v67 = (unsigned __int8 *)(*v151 + v65 * (int)v155 + v62 * (int)v164);
        unsigned int v68 = (v67[v149]
             + v67[v148]
             + 4 * *v67
             + v67[v146]
             + v67[v145]
             + 2 * (v67[v147] + v67[v150] + v67[v164] + v67[v155])
             + 8) >> 4;
        int v154 = v42;
        int v153 = v41;
        if (v156 <= 399)
        {
          *int v142 = v159;
          v142[1] = v169;
          v142[2] = v60;
          void v142[3] = v61;
          v142[4] = v62;
          v142[5] = v65;
          v142[6] = v66;
          v142[7] = v68;
          v142 += 8;
          ++v156;
        }
        int v19 = v162;
        size_t v49 = v180;
        size_t v48 = v181;
        size_t v52 = v179;
        if (v66 != v68)
        {
          int v69 = (__int16)(16320 / (__int16)(v66 - v68));
          int v70 = (*(unsigned __int8 *)(v190 + v13) - v68) * v69;
          int v71 = (v70 + 32) >> 6;
          if (v71 >= 255) {
            LOBYTE(v71) = -1;
          }
          if (v70 >= -32) {
            char v72 = v71;
          }
          else {
            char v72 = 0;
          }
          *(unsigned char *)(v189 + v13) = v72;
          setBitInBitmask((uint64_t)inited, v159, v169, 1);
          unsigned int v152 = v68;
          int v73 = (v168 - v68) * v69;
          int v74 = (v73 + 32) >> 6;
          if (v74 >= 255) {
            int v74 = 255;
          }
          if (v73 >= -32) {
            int v75 = v74;
          }
          else {
            int v75 = 0;
          }
          if (bitValueFromBitmask((uint64_t)inited, v158, v162))
          {
            v185[v13] = (v75 + v185[v13] + 1) >> 1;
          }
          else
          {
            v185[v13] = v75;
            setBitInBitmask((uint64_t)inited, v158, v162, 1);
          }
          int v76 = (v165 - v68) * v69;
          int v77 = (v76 + 32) >> 6;
          if (v77 >= 255) {
            int v77 = 255;
          }
          if (v76 >= -32) {
            int v78 = v77;
          }
          else {
            int v78 = 0;
          }
          if (bitValueFromBitmask((uint64_t)inited, v159, v162))
          {
            *(unsigned char *)(v184 + v13) = (v78 + *(unsigned __int8 *)(v184 + v13) + 1) >> 1;
          }
          else
          {
            *(unsigned char *)(v184 + v13) = v78;
            setBitInBitmask((uint64_t)inited, v159, v162, 1);
          }
          int v79 = (v166 - v68) * v69;
          int v80 = (v79 + 32) >> 6;
          if (v80 >= 255) {
            int v80 = 255;
          }
          if (v79 >= -32) {
            int v81 = v80;
          }
          else {
            int v81 = 0;
          }
          if (bitValueFromBitmask((uint64_t)inited, v192, v162))
          {
            *(unsigned char *)(v183 + v13) = (v81 + *(unsigned __int8 *)(v183 + v13) + 1) >> 1;
          }
          else
          {
            *(unsigned char *)(v183 + v13) = v81;
            setBitInBitmask((uint64_t)inited, v192, v162, 1);
          }
          int v82 = (v167 - v68) * v69;
          int v83 = (v82 + 32) >> 6;
          if (v83 >= 255) {
            int v83 = 255;
          }
          if (v82 >= -32) {
            int v84 = v83;
          }
          else {
            int v84 = 0;
          }
          if (bitValueFromBitmask((uint64_t)inited, v158, v169))
          {
            *(unsigned char *)(v179 + v13) = (v84 + *(unsigned __int8 *)(v179 + v13) + 1) >> 1;
          }
          else
          {
            *(unsigned char *)(v179 + v13) = v84;
            setBitInBitmask((uint64_t)inited, v158, v169, 1);
          }
          int v85 = (v160 - v68) * v69;
          int v86 = (v85 + 32) >> 6;
          if (v86 >= 255) {
            int v86 = 255;
          }
          if (v85 >= -32) {
            int v87 = v86;
          }
          else {
            int v87 = 0;
          }
          if (bitValueFromBitmask((uint64_t)inited, v192, v169))
          {
            *(unsigned char *)(v180 + v13) = (v87 + *(unsigned __int8 *)(v180 + v13) + 1) >> 1;
          }
          else
          {
            *(unsigned char *)(v180 + v13) = v87;
            setBitInBitmask((uint64_t)inited, v192, v169, 1);
          }
          int v88 = (v153 - v68) * v69;
          int v89 = (v88 + 32) >> 6;
          if (v89 >= 255) {
            int v89 = 255;
          }
          if (v88 >= -32) {
            int v90 = v89;
          }
          else {
            int v90 = 0;
          }
          if (bitValueFromBitmask((uint64_t)inited, v158, v163))
          {
            v187[v13] = (v90 + v187[v13] + 1) >> 1;
          }
          else
          {
            v187[v13] = v90;
            setBitInBitmask((uint64_t)inited, v158, v163, 1);
          }
          int v91 = (v154 - v68) * v69;
          int v92 = (v91 + 32) >> 6;
          if (v92 >= 255) {
            int v92 = 255;
          }
          if (v91 >= -32) {
            int v93 = v92;
          }
          else {
            int v93 = 0;
          }
          if (bitValueFromBitmask((uint64_t)inited, v159, v163))
          {
            *(unsigned char *)(v186 + v13) = (v93 + *(unsigned __int8 *)(v186 + v13) + 1) >> 1;
          }
          else
          {
            *(unsigned char *)(v186 + v13) = v93;
            setBitInBitmask((uint64_t)inited, v159, v163, 1);
          }
          uint64_t v10 = v164;
          int v94 = (v171 - v152) * v69;
          int v95 = (v94 + 32) >> 6;
          if (v95 >= 255) {
            int v95 = 255;
          }
          if (v94 >= -32) {
            int v96 = v95;
          }
          else {
            int v96 = 0;
          }
          if (bitValueFromBitmask((uint64_t)inited, v192, v163))
          {
            *(unsigned char *)(v31 + v13) = (v96 + *(unsigned __int8 *)(v31 + v13) + 1) >> 1;
          }
          else
          {
            *(unsigned char *)(v31 + v13) = v96;
            setBitInBitmask((uint64_t)inited, v192, v163, 1);
          }
          int v18 = v169;
          int v19 = v162;
          size_t v48 = v181;
          uint64_t v45 = v177;
          uint64_t v44 = v178;
          size_t v47 = v175;
          size_t v46 = v176;
          size_t v51 = v173;
          uint64_t v50 = v174;
          goto LABEL_12;
        }
        int v18 = v169;
        uint64_t v45 = v177;
        uint64_t v44 = v178;
        size_t v47 = v175;
        size_t v46 = v176;
        size_t v51 = v173;
        uint64_t v50 = v174;
LABEL_11:
        uint64_t v10 = v164;
LABEL_12:
        size_t v28 = v51 + v10;
        uint64_t v26 = v50 + v10;
        size_t v27 = v47 + v10;
        size_t v25 = v48 + v10;
        size_t v24 = v46 + v10;
        uint64_t v23 = v45 + v10;
        uint64_t v21 = v44 + v10;
        v22 += v10;
        v189 += v10;
        v183 += v10;
        v184 += v10;
        v185 += v10;
        v31 += v10;
        v186 += v10;
        v187 += v10;
        size_t v30 = v52 + v10;
        size_t v29 = v49 + v10;
        v190 += v10;
        unsigned int v20 = v192;
        if (v161 + v192 == 1)
        {
          int v8 = v140;
          size_t v9 = v155;
          int v14 = v156;
          int v97 = v163;
          goto LABEL_108;
        }
      }
      int v18 = v169;
      int v19 = v162;
LABEL_10:
      uint64_t v45 = v177;
      uint64_t v44 = v178;
      size_t v47 = v175;
      size_t v46 = v176;
      size_t v49 = v180;
      size_t v48 = v181;
      size_t v51 = v173;
      uint64_t v50 = v174;
      size_t v52 = v179;
      goto LABEL_11;
    }
    int v14 = 0;
LABEL_112:
    int v157 = v14;
    if (v118 >= 1)
    {
      int v98 = 0;
      int v99 = *v120;
      do
      {
        if (v8 >= 1)
        {
          unsigned int v100 = 0;
          int v101 = v99;
          do
          {
            if (!bitValueFromBitmask((uint64_t)inited, v100, v98))
            {
              if (bitValueFromBitmask(a2, v100, v98))
              {
                *int v101 = -1;
                setBitInBitmask((uint64_t)inited, v100, v98, 1);
              }
              else
              {
                *int v101 = 0;
              }
            }
            ++v100;
            v101 += v10;
          }
          while (v8 != v100);
        }
        ++v98;
        v99 += v9;
      }
      while (v98 != v118);
    }
    termBitmask(inited);
    float v188 = (char *)zmalloc(2 * v9);
    memmove(v188, *v120, v9);
    if (v118 >= 3)
    {
      size_t v102 = v9;
      uint64_t v103 = &v188[v9];
      int v104 = (char *)*v120;
      uint64_t v105 = (uint64_t)*v120 + 2 * v102;
      uint64_t v106 = (uint64_t)*v120 + 2 * v102 + v10;
      uint64_t v107 = (char *)*v120 + v10 + v102 + (int)v10 + (int)v102;
      double v108 = (char *)*v120 + v10 + v102;
      int v109 = 1;
      unint64_t v110 = v188;
      do
      {
        int v191 = v109;
        uint64_t v111 = v110;
        double v193 = &v104[v102];
        memmove(v103, &v104[v102], v102);
        if (v140 >= 3)
        {
          uint64_t v112 = 0;
          int v113 = v140 - 2;
          do
          {
            unsigned int v114 = v111[v139 + v112]
                 + v111[v112]
                 + 4 * v103[v10 + v112]
                 + *(unsigned __int8 *)(v105 + v112)
                 + v107[v112]
                 + 2
                 * (v103[v112]
                  + v111[v10 + v112]
                  + v103[v139 + v112]
                  + *(unsigned __int8 *)(v106 + v112));
            int v115 = (int)(5100 * ((v114 + 8) >> 4) - 650752) >> 12;
            if (v115 >= 127) {
              LOBYTE(v115) = 127;
            }
            char v116 = v115 ^ 0x80;
            if (v114 >= 0x188) {
              char v117 = v116;
            }
            else {
              char v117 = 0;
            }
            v108[v112] = v117;
            v112 += v10;
            --v113;
          }
          while (v113);
        }
        int v109 = v191 + 1;
        size_t v102 = v155;
        v105 += v155;
        v106 += v155;
        v107 += v155;
        v108 += v155;
        unint64_t v110 = v103;
        uint64_t v103 = v111;
        int v104 = v193;
      }
      while (v191 + 1 != v141);
    }
    zfree(v188);
    float result = (void **)v120;
    *int v119 = v157;
  }
  return result;
}

void featheredOutsize(uint64_t a1, _DWORD *a2, _DWORD *a3, float a4, float a5, float a6)
{
  uint64_t v102 = *MEMORY[0x1E4F143B8];
  uint64_t v98 = 0;
  *(_OWORD *)__dst = 0u;
  long long v97 = 0u;
  int v7 = *(_DWORD *)(a1 + 12);
  if (v7 < 1)
  {
    int v12 = 0;
    float v21 = 0.0;
  }
  else
  {
    int v8 = 0;
    int v9 = 0;
    int v10 = 0;
    int v11 = 0;
    int v12 = 0;
    int v13 = 0;
    int v14 = *(_DWORD *)(a1 + 8);
    float v15 = *(unsigned char **)a1;
    char v16 = 1;
    do
    {
      int v17 = v13 + 1;
      if (v14 >= 1)
      {
        int v18 = 0;
        int v19 = v15;
        do
        {
          if (*v19)
          {
            v12 += *v19 | (*v19 << 8);
            if (v13 < v11) {
              int v11 = v13;
            }
            if (v13 >= v9) {
              int v9 = v13 + 1;
            }
            if (v18 < v10) {
              int v10 = v18;
            }
            int v20 = v18 + 1;
            if (v18 >= v8) {
              int v8 = v18 + 1;
            }
            if (v16) {
              int v11 = v13;
            }
            else {
              int v20 = v18 + 1;
            }
            if (v16)
            {
              int v10 = v18;
              int v9 = v13 + 1;
              int v8 = v18 + 1;
            }
            int v18 = v20;
            char v16 = 0;
          }
          else
          {
            ++v18;
          }
          v19 += *(int *)(a1 + 28);
        }
        while (v18 != v14);
      }
      v15 += *(int *)(a1 + 16);
      ++v13;
    }
    while (v17 != v7);
    float v21 = (float)((v8 - v10) * (v9 - v11)) * 0.785398163;
  }
  uint64_t v22 = (uint64_t)rintf((float)v12 / 65535.0);
  *a3 = (uint64_t)rintf(v21);
  *a2 = v22;
  if (v22)
  {
    double v23 = sqrt((float)(int)v22 / 3.14159265);
    *(float *)&double v23 = v23 + v23;
    uint64_t v95 = *(int *)(a1 + 16);
    uint64_t v24 = (uint64_t)rintf(a5 * 255.0);
    uint64_t v25 = (uint64_t)rintf(a6 * 4096.0);
    uint64_t v100 = 0;
    double v26 = *(float *)&v23 * 0.125;
    memset(&v99[10], 0, 32);
    if (v26 >= a4) {
      float v27 = a4;
    }
    else {
      float v27 = v26;
    }
    memset(v99, 0, 160);
    int v28 = 1;
    int v29 = 4;
    do
    {
      float v30 = (float)(v29 + 1) * -0.5;
      float v31 = (float)(v30 / v27) * 0.7071067;
      float v32 = (erff(v31) + 1.0) * 0.5;
      float v33 = (float)((float)(v30 + 1.0) / v27) * 0.7071067;
      float v34 = (erff(v33) + 1.0) * 0.5;
      float v35 = (float)((float)(v30 + 2.0) / v27) * 0.7071067;
      float v36 = (erff(v35) + 1.0) * 0.5;
      ++v28;
      v29 += 2;
    }
    while ((float)((float)(v34 - v32) + v32) >= (float)((float)(v36 - v34) * 0.75));
    uint64_t v37 = 0;
    int v38 = &v101[4 * v28];
    unint64_t v39 = (v28 + 1);
    int v40 = v39;
    do
    {
      float v41 = (float)((float)(v30 + 1.0) / v27) * 0.7071067;
      float v42 = (erff(v41) + 1.0) * 0.5;
      float v43 = (float)(v30 / v27) * 0.7071067;
      float v44 = (erff(v43) + 1.0) * 0.5;
      float v45 = v42 - v44;
      float v46 = -0.0;
      if (!v37) {
        float v46 = v32;
      }
      *(float *)&v38[v37] = v46 + v45;
      --v40;
      v37 -= 4;
      float v30 = v30 + 1.0;
    }
    while (v40 > 0);
    uint64_t v47 = 0;
    if (v39 <= 1) {
      uint64_t v48 = 1;
    }
    else {
      uint64_t v48 = v39;
    }
    uint64_t v49 = 4 * v48;
    do
    {
      *(_DWORD *)((char *)v99 + v47) = llround(*(float *)&v101[v47] * 65536.0);
      v47 += 4;
    }
    while (v49 != v47);
    unsigned int v50 = v29 & 0x7FFFFFFE;
    int v51 = (v29 & 0x7FFFFFFE) - 1;
    initBitmap((uint64_t)__dst, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 28), *(_DWORD *)(a1 + 32), *(float *)(a1 + 36));
    memcpy(__dst[0], *(const void **)a1, *(int *)(a1 + 16) * (uint64_t)*(int *)(a1 + 12));
    size_t v52 = zmalloc(SLODWORD(__dst[1]));
    if (v51 >= 0) {
      int v53 = v51;
    }
    else {
      int v53 = v50;
    }
    unsigned int v54 = v53 >> 1;
    if (SHIDWORD(__dst[1]) >= 1)
    {
      int v55 = 0;
      int v56 = (unsigned __int8 *)__dst[0];
      do
      {
        int v57 = (int)__dst[1];
        if (SLODWORD(__dst[1]) >= 1)
        {
          int v58 = 0;
          unsigned int v59 = v54 + 1;
          int v60 = v52;
          do
          {
            int v61 = v58 - v54;
            if (v50 < 3)
            {
              int v62 = 0;
            }
            else
            {
              int v62 = 0;
              int v63 = (int *)v99 + v54;
              do
              {
                int v64 = *v63--;
                v62 += v64 * v56[v61 & ~(v61 >> 31)];
                ++v61;
              }
              while (v61 < v58);
            }
            if (v61 <= (int)(v58 + v54))
            {
              uint64_t v65 = v59 - v61;
              unsigned int v66 = (int *)v99;
              do
              {
                if (v61 >= v57) {
                  int v67 = v57 - 1;
                }
                else {
                  int v67 = v61;
                }
                int v68 = *v66++;
                v62 += v68 * v56[v67];
                ++v61;
                --v65;
              }
              while (v65);
            }
            *v60++ = (v62 + 0x8000) >> 16;
            ++v58;
            int v57 = (int)__dst[1];
            ++v59;
          }
          while (v58 < SLODWORD(__dst[1]));
        }
        memcpy(v56, v52, v57);
        ++v55;
        v56 += (int)v97;
      }
      while (v55 < SHIDWORD(__dst[1]));
    }
    zfree(v52);
    int v69 = zmalloc(SHIDWORD(__dst[1]));
    if (SLODWORD(__dst[1]) >= 1)
    {
      int v70 = 0;
      int v71 = (char *)__dst[0];
      int v72 = HIDWORD(__dst[1]);
      do
      {
        if (v72 >= 1)
        {
          uint64_t v73 = 0;
          int v74 = v71;
          do
          {
            v69[v73] = *v74;
            int v72 = HIDWORD(__dst[1]);
            v74 += (int)v97;
            ++v73;
          }
          while ((int)v73 < SHIDWORD(__dst[1]));
          if (SHIDWORD(__dst[1]) >= 1)
          {
            int v75 = 0;
            unsigned int v76 = v54 + 1;
            int v77 = v71;
            do
            {
              int v78 = v75 - v54;
              if (v50 < 3)
              {
                int v79 = 0;
              }
              else
              {
                int v79 = 0;
                int v80 = (int *)v99 + v54;
                do
                {
                  int v81 = *v80--;
                  v79 += v81 * v69[v78 & ~(v78 >> 31)];
                  ++v78;
                }
                while (v78 < v75);
              }
              if (v78 <= (int)(v75 + v54))
              {
                uint64_t v82 = v76 - v78;
                int v83 = (int *)v99;
                do
                {
                  if (v78 >= v72) {
                    int v84 = v72 - 1;
                  }
                  else {
                    int v84 = v78;
                  }
                  int v85 = *v83++;
                  v79 += v85 * v69[v84];
                  ++v78;
                  --v82;
                }
                while (v82);
              }
              *int v77 = (v79 + 0x8000) >> 16;
              ++v75;
              int v72 = HIDWORD(__dst[1]);
              v77 += (int)v97;
              ++v76;
            }
            while (v75 < SHIDWORD(__dst[1]));
          }
        }
        ++v70;
        ++v71;
      }
      while (v70 < SLODWORD(__dst[1]));
    }
    zfree(v69);
    int v86 = *(_DWORD *)(a1 + 12);
    if (v86 >= 1)
    {
      int v87 = 0;
      int v88 = *(unsigned char **)a1;
      int v89 = (unsigned __int8 *)__dst[0];
      int v90 = *(_DWORD *)(a1 + 8);
      do
      {
        if (v90 >= 1)
        {
          uint64_t v91 = 0;
          do
          {
            int v92 = (v89[v91] - v24) * v25;
            if (v92 >= -526336)
            {
              int v94 = (v92 + 2048) >> 12;
              if (v94 >= 127) {
                LOBYTE(v94) = 127;
              }
              char v93 = v94 + 0x80;
            }
            else
            {
              char v93 = 0;
            }
            v88[v91] = v93;
            int v90 = *(_DWORD *)(a1 + 8);
            ++v91;
          }
          while ((int)v91 < v90);
          int v86 = *(_DWORD *)(a1 + 12);
        }
        ++v87;
        v89 += v95;
        v88 += v95;
      }
      while (v87 < v86);
    }
    termBitmap(__dst);
  }
}

void computeRedChannel(unsigned __int8 **a1, unsigned __int8 **a2, uint64_t a3, int a4)
{
  int v7 = *((_DWORD *)a1 + 3);
  uint64_t v97 = *((int *)a1 + 4);
  uint64_t v8 = *((int *)a1 + 7);
  int v9 = *((_DWORD *)a2 + 4);
  uint64_t v106 = *((int *)a2 + 7);
  int v98 = *((_DWORD *)a1 + 2);
  initBitmap(a3, v98, v7, 1, 1, 100.0);
  bzero(*(void **)a3, *(int *)(a3 + 24));
  int v95 = v7 - 1;
  int v96 = v7;
  if (v7 >= 1)
  {
    uint64_t v10 = 0;
    int v11 = 0;
    int v12 = *a2;
    int v13 = *(unsigned char **)a3;
    int v92 = -v9;
    uint64_t v105 = 2 * (int)v8;
    uint64_t v14 = (uint64_t)*a1;
    uint64_t v15 = *(void *)a3 + v8;
    char v16 = &(*a1)[v8];
    int v17 = *(unsigned char **)a3;
    int v18 = *a1;
    uint64_t v94 = v8;
    int v93 = v9;
    while (2)
    {
      if (v11 == v95) {
        int v19 = 0;
      }
      else {
        int v19 = v9;
      }
      int v20 = v92;
      if (!v11) {
        int v20 = 0;
      }
      if ((v11 & 1) == 0) {
        int v19 = v20;
      }
      float v21 = &v12[v19];
      int v22 = *v12;
      int v23 = v12[1];
      int v24 = *v21;
      int v25 = v21[1];
      uint64_t v104 = v10;
      int v103 = v11;
      int v101 = v17;
      uint64_t v102 = v12;
      uint64_t v100 = v18;
      int v99 = v11 & 1;
      if (v98 < 3)
      {
        int v33 = *v12;
        int v32 = v12[1];
        int v31 = *v21;
        int v30 = v21[1];
        int v62 = v18;
        int v29 = v12;
      }
      else
      {
        int v26 = 0;
        uint64_t v27 = v19;
        uint64_t v28 = v10;
        int v29 = v12;
        int v30 = v25;
        int v31 = v24;
        int v32 = v12[1];
        int v33 = *v12;
        do
        {
          int v34 = *(unsigned __int8 *)(v14 + v28);
          unsigned int v35 = ((9 * v22 + v31 + 3 * (v24 + v33) + 8) >> 4) - 128;
          unsigned int v36 = ((9 * v23 + v30 + 3 * (v25 + v32) + 8) >> 4) - 128;
          int v37 = v34 + ((int)(22970 * v36 + 0x2000) >> 14);
          int v38 = v34 + ((int)(-11700 * v36 - 5638 * v35 + 0x2000) >> 14);
          int v39 = v34 + ((int)(29032 * v35 + 0x2000) >> 14);
          if (v37 >= 255) {
            int v40 = 255;
          }
          else {
            int v40 = v37;
          }
          unsigned int v41 = v40 & ~(v40 >> 31);
          if (v38 >= 255) {
            int v42 = 255;
          }
          else {
            int v42 = v38;
          }
          int v43 = v42 & ~(v42 >> 31);
          if (v39 >= 255) {
            int v39 = 255;
          }
          int v44 = v39 & ~(v39 >> 31);
          switch(a4)
          {
            case 1:
              if (v43 <= v44) {
                int v43 = v39 & ~(v39 >> 31);
              }
              goto LABEL_29;
            case 2:
              if (v40 < 1)
              {
                LOBYTE(v41) = 0;
              }
              else
              {
                if (v43 <= v44) {
                  int v43 = v39 & ~(v39 >> 31);
                }
                __int16 v46 = (v41 - v43) & ~(unsigned __int16)((int)(v41 - v43) >> 31);
                unsigned int v41 = (unsigned __int16)(v46 * v46)
                    / (unsigned __int16)(v40 & ~(unsigned __int16)(v40 >> 31));
LABEL_32:
                if (v41 >= 0xFF) {
                  LOBYTE(v41) = -1;
                }
              }
              break;
            case 3:
              v43 += (v41 * v43 + 128) >> 8;
LABEL_29:
              int v45 = v41 - v43;
              goto LABEL_30;
            case 4:
              unsigned int v41 = ((unsigned __int16)(v41 & 0x3FF) << 6) / (unsigned __int16)(v43 + v44 + 1);
              goto LABEL_32;
            case 5:
              break;
            default:
              int v45 = v41 - ((v43 + v44 + 1) >> 1);
LABEL_30:
              unsigned int v41 = v45 & ~(v45 >> 31);
              break;
          }
          v13[v28] = v41;
          int v47 = v16[v28];
          int v33 = *v29;
          int v32 = v29[1];
          int v22 = v29[2];
          int v23 = v29[3];
          int v31 = v29[v27];
          int v30 = v29[v27 + 1];
          int v24 = v29[v27 + 2];
          int v25 = v29[v27 + 3];
          unsigned int v48 = ((9 * v33 + v24 + 3 * (v31 + v22) + 8) >> 4) - 128;
          unsigned int v49 = ((9 * v32 + v25 + 3 * (v30 + v23) + 8) >> 4) - 128;
          int v50 = v47 + ((int)(22970 * v49 + 0x2000) >> 14);
          int v51 = v47 + ((int)(-11700 * v49 - 5638 * v48 + 0x2000) >> 14);
          int v52 = v47 + ((int)(29032 * v48 + 0x2000) >> 14);
          if (v50 >= 255) {
            int v50 = 255;
          }
          int v53 = v50 & ~(v50 >> 31);
          if (v51 >= 255) {
            int v54 = 255;
          }
          else {
            int v54 = v51;
          }
          int v55 = v54 & ~(v54 >> 31);
          if (v52 >= 255) {
            int v52 = 255;
          }
          int v56 = v52 & ~(v52 >> 31);
          switch(a4)
          {
            case 1:
              if (v55 <= v56) {
                int v57 = v52 & ~(v52 >> 31);
              }
              else {
                int v57 = v55;
              }
              goto LABEL_52;
            case 2:
              if (v50 < 1)
              {
                LOBYTE(v53) = 0;
              }
              else
              {
                if (v55 <= v56) {
                  int v59 = v52 & ~(v52 >> 31);
                }
                else {
                  int v59 = v55;
                }
                __int16 v60 = (v53 - v59) & ~(unsigned __int16)((v53 - v59) >> 31);
                unsigned int v61 = (unsigned __int16)(v60 * v60)
                    / (unsigned __int16)(v50 & ~(unsigned __int16)(v50 >> 31));
LABEL_55:
                if (v61 >= 0xFF) {
                  LOBYTE(v53) = -1;
                }
                else {
                  LOBYTE(v53) = v61;
                }
              }
              break;
            case 3:
              int v57 = v55 + ((v53 * v55 + 128) >> 8);
LABEL_52:
              int v58 = v53 - v57;
              goto LABEL_53;
            case 4:
              unsigned int v61 = ((unsigned __int16)(v53 & 0x3FF) << 6) / (unsigned __int16)(v55 + v56 + 1);
              goto LABEL_55;
            case 5:
              break;
            default:
              int v58 = v53 - ((v55 + v56 + 1) >> 1);
LABEL_53:
              int v53 = v58 & ~(v58 >> 31);
              break;
          }
          *(unsigned char *)(v15 + v2_Block_object_dispose(&STACK[0x238], 8) = v53;
          v29 += v106;
          v26 += 2;
          v28 += v105;
        }
        while (v26 < v98 - 2);
        int v17 = &v13[v28];
        float v21 = &v29[v27];
        int v62 = (unsigned __int8 *)(v14 + v28);
      }
      int v63 = *v62;
      unsigned int v64 = ((9 * v22 + v31 + 3 * (v24 + v33) + 8) >> 4) - 128;
      unsigned int v65 = ((9 * v23 + v30 + 3 * (v25 + v32) + 8) >> 4) - 128;
      int v66 = v63 + ((int)(22970 * v65 + 0x2000) >> 14);
      int v67 = v63 + ((int)(-11700 * v65 - 5638 * v64 + 0x2000) >> 14);
      int v68 = v63 + ((int)(29032 * v64 + 0x2000) >> 14);
      if (v66 >= 255) {
        int v69 = 255;
      }
      else {
        int v69 = v66;
      }
      unsigned int v70 = v69 & ~(v69 >> 31);
      if (v67 >= 255) {
        int v71 = 255;
      }
      else {
        int v71 = v67;
      }
      int v72 = v71 & ~(v71 >> 31);
      if (v68 >= 255) {
        int v68 = 255;
      }
      int v73 = v68 & ~(v68 >> 31);
      int v9 = v93;
      switch(a4)
      {
        case 1:
          if (v72 <= v73) {
            int v72 = v68 & ~(v68 >> 31);
          }
          goto LABEL_80;
        case 2:
          if (v69 < 1)
          {
            LOBYTE(v70) = 0;
          }
          else
          {
            if (v72 <= v73) {
              int v72 = v68 & ~(v68 >> 31);
            }
            __int16 v74 = (v70 - v72) & ~(unsigned __int16)((int)(v70 - v72) >> 31);
            unsigned int v70 = (unsigned __int16)(v74 * v74) / (unsigned __int16)(v69 & ~(unsigned __int16)(v69 >> 31));
LABEL_82:
            if (v70 >= 0xFF) {
              LOBYTE(v70) = -1;
            }
          }
LABEL_84:
          *int v17 = v70;
          int v75 = v62[v94];
          unsigned int v76 = ((9 * *v29 + *v21 + 3 * (*v21 + *v29) + 8) >> 4) - 128;
          unsigned int v77 = ((9 * v29[1] + v21[1] + 3 * (v21[1] + v29[1]) + 8) >> 4) - 128;
          int v78 = v75 + ((int)(22970 * v77 + 0x2000) >> 14);
          int v79 = v75 + ((int)(-11700 * v77 - 5638 * v76 + 0x2000) >> 14);
          int v80 = v75 + ((int)(29032 * v76 + 0x2000) >> 14);
          if (v78 >= 255) {
            int v78 = 255;
          }
          unsigned int v81 = v78 & ~(v78 >> 31);
          if (v79 >= 255) {
            int v82 = 255;
          }
          else {
            int v82 = v79;
          }
          int v83 = v82 & ~(v82 >> 31);
          if (v80 >= 255) {
            int v84 = 255;
          }
          else {
            int v84 = v80;
          }
          int v85 = v84 & ~(v84 >> 31);
          int v86 = v103;
          int v87 = v99;
          switch(a4)
          {
            case 1:
              if (v83 <= v85) {
                int v88 = v85;
              }
              else {
                int v88 = v83;
              }
              goto LABEL_103;
            case 2:
              if (v78 < 1)
              {
                LOBYTE(v81) = 0;
              }
              else
              {
                if (v83 <= v85) {
                  int v89 = v85;
                }
                else {
                  int v89 = v83;
                }
                __int16 v90 = (v81 - v89) & ~(unsigned __int16)((int)(v81 - v89) >> 31);
                unsigned int v91 = (unsigned __int16)(v90 * v90)
                    / (unsigned __int16)(v78 & ~(unsigned __int16)(v78 >> 31));
LABEL_105:
                if (v91 >= 0xFF) {
                  LOBYTE(v81) = -1;
                }
                else {
                  LOBYTE(v81) = v91;
                }
              }
LABEL_108:
              v17[v94] = v81;
              int v12 = &v102[v87 * v9];
              int v11 = v86 + 1;
              int v18 = &v100[v97];
              int v17 = &v101[v97];
              uint64_t v10 = v104 + v97;
              if (v11 == v96) {
                return;
              }
              continue;
            case 3:
              int v88 = v83 + ((v81 * v83 + 128) >> 8);
LABEL_103:
              unsigned int v81 = (v81 - v88) & ~((int)(v81 - v88) >> 31);
              goto LABEL_108;
            case 4:
              unsigned int v91 = ((unsigned __int16)(v81 & 0x3FF) << 6) / (unsigned __int16)(v83 + v85 + 1);
              goto LABEL_105;
            case 5:
              goto LABEL_108;
            default:
              unsigned int v81 = (v81 - ((v83 + v85 + 1) >> 1)) & ~((int)(v81 - ((v83 + v85 + 1) >> 1)) >> 31);
              int v86 = v103;
              int v87 = v99;
              goto LABEL_108;
          }
        case 3:
          v72 += (v70 * v72 + 128) >> 8;
LABEL_80:
          unsigned int v70 = (v70 - v72) & ~((int)(v70 - v72) >> 31);
          goto LABEL_84;
        case 4:
          unsigned int v70 = ((unsigned __int16)(v70 & 0x3FF) << 6) / (unsigned __int16)(v72 + v73 + 1);
          goto LABEL_82;
        case 5:
          goto LABEL_84;
        default:
          unsigned int v70 = (v70 - ((v72 + v73 + 1) >> 1)) & ~((int)(v70 - ((v72 + v73 + 1) >> 1)) >> 31);
          int v9 = v93;
          goto LABEL_84;
      }
    }
  }
}

float redEyeCancellation(_DWORD *a1, unsigned __int8 **a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t a6, _DWORD *a7)
{
  int v7 = a1[3];
  if (v7 < 1)
  {
    float v73 = 0.0;
  }
  else
  {
    int v75 = a7;
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    int v11 = 0;
    int v12 = 0;
    int v13 = 0;
    uint64_t v14 = 0;
    int v92 = 0;
    uint64_t v15 = *((int *)a2 + 4);
    int v16 = a1[2];
    uint64_t v89 = *a5;
    int v17 = *a2;
    uint64_t v18 = (int)a1[7];
    int v77 = -(int)v15;
    uint64_t v19 = (int)a1[4];
    int v76 = v7 - 2;
    uint64_t v97 = 2 * v18;
    uint64_t v98 = *a3;
    uint64_t v80 = 2 * v19;
    uint64_t v96 = *a3 + v18;
    uint64_t v94 = *a3 + v18 + v19;
    uint64_t v95 = *a3 + v19;
    int v20 = 0;
    uint64_t v85 = *a4 + v18 + v19;
    uint64_t v86 = *a4;
    uint64_t v93 = *((int *)a2 + 7);
    uint64_t v83 = *a4 + v18;
    uint64_t v84 = *a4 + v19;
    char v110 = 1;
    float v21 = *a2;
    int v87 = *a2;
    uint64_t v88 = a6;
    int v79 = a1[3];
    uint64_t v78 = v15;
    do
    {
      if (v16 <= 0)
      {
        int v72 = v92 + 2;
      }
      else
      {
        int v109 = v12;
        if (v92 == v76) {
          int v22 = 0;
        }
        else {
          int v22 = v15;
        }
        int v23 = &v21[v22];
        int v24 = v23[1];
        int v25 = *v23;
        if (v92) {
          int v26 = v77;
        }
        else {
          int v26 = 0;
        }
        uint64_t v27 = &v21[v26];
        int v28 = v27[1];
        int v29 = *v27;
        int v30 = v21[1];
        int v107 = v24;
        int v108 = v92 | 1;
        __int16 v90 = &v17[v26];
        unsigned int v91 = &v17[v22];
        int v31 = 1;
        unsigned int v81 = v21;
        int v32 = *v21;
        uint64_t v82 = v9;
        uint64_t v33 = v10;
        int v105 = v24;
        int v106 = v25;
        int v103 = v25;
        int v104 = v28;
        int v102 = v29;
        int v34 = v30;
        int v35 = v32;
        do
        {
          int v36 = *(unsigned __int8 *)(v98 + v33) | (*(unsigned __int8 *)(v98 + v33) << 8);
          int v37 = *(unsigned __int8 *)(v96 + v33);
          int v38 = v37 | (v37 << 8);
          int v39 = *(unsigned __int8 *)(v95 + v33);
          int v40 = v39 | (v39 << 8);
          int v41 = *(unsigned __int8 *)(v94 + v33);
          int v42 = v41 | (v41 << 8);
          if (v38 | v36 | v40 | v42)
          {
            int v43 = v31 - 1;
            unsigned int v44 = (v102 + 9 * v32 + 3 * (v29 + v35) + 8) >> 4;
            unsigned int v45 = (v104 + 9 * v30 + 3 * (v28 + v34) + 8) >> 4;
            if (*(unsigned char *)(v98 + v33))
            {
              int v46 = (int)(1505792 - 11700 * v45 - 5638 * (v44 - 128)) >> 14;
              if (v46 >= (int)(29032 * (v44 - 128) + 0x2000) >> 14) {
                int v46 = (int)(29032 * (v44 - 128) + 0x2000) >> 14;
              }
              int v47 = *(unsigned __int8 *)(v86 + v33)
                  + (((*(unsigned __int8 *)(a6
                                          + ((v46 + *(unsigned __int8 *)(v86 + v33)) & ~((v46 + *(unsigned __int8 *)(v86 + v33)) >> 31)))
                     - *(unsigned __int8 *)(v86 + v33))
                    * v36
                    + 0x8000) >> 16);
              *(unsigned char *)(v86 + v33) = v47 & ~(v47 >> 31);
              v45 += (int)(v36 * (128 - v45) + 0x8000) >> 16;
              unsigned int v100 = v44 + ((int)(v36 * (128 - v44) + 0x8000) >> 16);
              uint64_t v48 = (v36 + v14);
              if (v110)
              {
                int v13 = v92;
                int v20 = v31 - 1;
                int v109 = v92 | 1;
                char v110 = 0;
                int v11 = v31;
              }
              else
              {
                if (v92 < v13) {
                  int v13 = v92;
                }
                int v49 = v109;
                if (v92 >= v109) {
                  int v49 = v92 | 1;
                }
                int v109 = v49;
                char v110 = 0;
                if (v43 < v20) {
                  int v20 = v31 - 1;
                }
                if (v43 >= v11) {
                  int v11 = v31;
                }
              }
            }
            else
            {
              unsigned int v100 = v44;
              uint64_t v48 = v14;
            }
            int v50 = &v17[v9];
            int v51 = v17[v9];
            int v52 = v50[1];
            int v53 = v50[2];
            int v54 = v50[3];
            int v101 = v90[v9 + 2];
            int v102 = v90[v9];
            unsigned int v55 = (9 * v51 + v101 + 3 * (v102 + v53) + 8) >> 4;
            int v99 = v90[v9 + 3];
            unsigned int v56 = (9 * v52 + v99 + 3 * (v90[v9 + 1] + v54) + 8) >> 4;
            int v104 = v90[v9 + 1];
            if (v37)
            {
              int v57 = (int)(1505792 - 11700 * v56 - 5638 * (v55 - 128)) >> 14;
              if (v57 >= (int)(29032 * (v55 - 128) + 0x2000) >> 14) {
                int v57 = (int)(29032 * (v55 - 128) + 0x2000) >> 14;
              }
              a6 = v88;
              int v58 = *(unsigned __int8 *)(v83 + v33)
                  + (((*(unsigned __int8 *)(v88
                                          + ((v57 + *(unsigned __int8 *)(v83 + v33)) & ~((v57 + *(unsigned __int8 *)(v83 + v33)) >> 31)))
                     - *(unsigned __int8 *)(v83 + v33))
                    * v38
                    + 0x8000) >> 16);
              *(unsigned char *)(v83 + v33) = v58 & ~(v58 >> 31);
              v55 += (int)((128 - v55) * v38 + 0x8000) >> 16;
              v56 += (int)((128 - v56) * v38 + 0x8000) >> 16;
              uint64_t v14 = (v48 + v38);
              if (v110)
              {
                char v110 = 0;
                int v11 = v31 + 1;
                int v13 = v92;
                int v20 = v31;
                int v59 = v92 | 1;
              }
              else
              {
                char v110 = 0;
                if (v92 < v13) {
                  int v13 = v92;
                }
                int v59 = v109;
                if (v92 >= v109) {
                  int v59 = v92 | 1;
                }
                if (v31 < v20) {
                  int v20 = v31;
                }
                if (v31 >= v11) {
                  int v11 = v31 + 1;
                }
              }
            }
            else
            {
              uint64_t v14 = v48;
              a6 = v88;
              int v59 = v109;
            }
            unsigned int v60 = (v103 + 9 * v53 + 3 * (v106 + v51) + 8) >> 4;
            unsigned int v61 = (v105 + 9 * v54 + 3 * (v107 + v52) + 8) >> 4;
            if (v39)
            {
              int v62 = (int)(1505792 - 11700 * v61 - 5638 * (v60 - 128)) >> 14;
              if (v62 >= (int)(29032 * (v60 - 128) + 0x2000) >> 14) {
                int v62 = (int)(29032 * (v60 - 128) + 0x2000) >> 14;
              }
              int v63 = *(unsigned __int8 *)(v84 + v33)
                  + (((*(unsigned __int8 *)(a6
                                          + ((v62 + *(unsigned __int8 *)(v84 + v33)) & ~((v62 + *(unsigned __int8 *)(v84 + v33)) >> 31)))
                     - *(unsigned __int8 *)(v84 + v33))
                    * v40
                    + 0x8000) >> 16);
              *(unsigned char *)(v84 + v33) = v63 & ~(v63 >> 31);
              v60 += (int)((128 - v60) * v40 + 0x8000) >> 16;
              v61 += (int)((128 - v61) * v40 + 0x8000) >> 16;
              uint64_t v14 = (v14 + v40);
              if (v110)
              {
                int v13 = v92 | 1;
                int v20 = v31 - 1;
                int v109 = v92 + 2;
                char v110 = 0;
                int v11 = v31;
              }
              else
              {
                if (v108 < v13) {
                  int v13 = v92 | 1;
                }
                if (v108 >= v59) {
                  int v59 = v92 + 2;
                }
                int v109 = v59;
                char v110 = 0;
                if (v43 < v20) {
                  int v20 = v31 - 1;
                }
                if (v43 >= v11) {
                  int v11 = v31;
                }
              }
            }
            else
            {
              int v109 = v59;
            }
            int v17 = v87;
            int v35 = v87[v9];
            int v34 = v50[1];
            int v32 = v50[2];
            int v30 = v50[3];
            int v103 = v91[v9];
            int v105 = v91[v9 + 1];
            int v106 = v91[v9 + 2];
            unsigned int v64 = (9 * v35 + v106 + 3 * (v103 + v32) + 8) >> 4;
            int v107 = v91[v9 + 3];
            unsigned int v65 = (9 * v34 + v107 + 3 * (v105 + v30) + 8) >> 4;
            if (v41)
            {
              int v66 = (int)(1505792 - 11700 * v65 - 5638 * (v64 - 128)) >> 14;
              if (v66 >= (int)(29032 * (v64 - 128) + 0x2000) >> 14) {
                int v66 = (int)(29032 * (v64 - 128) + 0x2000) >> 14;
              }
              int v67 = *(unsigned __int8 *)(v85 + v33)
                  + (((*(unsigned __int8 *)(a6
                                          + ((v66 + *(unsigned __int8 *)(v85 + v33)) & ~((v66 + *(unsigned __int8 *)(v85 + v33)) >> 31)))
                     - *(unsigned __int8 *)(v85 + v33))
                    * v42
                    + 0x8000) >> 16);
              *(unsigned char *)(v85 + v33) = v67 & ~(v67 >> 31);
              v64 += (int)((128 - v64) * v42 + 0x8000) >> 16;
              v65 += (int)((128 - v65) * v42 + 0x8000) >> 16;
              uint64_t v14 = (v14 + v42);
              if (v110)
              {
                int v11 = v31 + 1;
                int v13 = v92 | 1;
                int v20 = v31;
                int v109 = v92 + 2;
                char v110 = 0;
              }
              else
              {
                int v68 = v109;
                if (v108 < v13) {
                  int v13 = v92 | 1;
                }
                if (v108 >= v109) {
                  int v68 = v92 + 2;
                }
                int v109 = v68;
                char v110 = 0;
                if (v31 < v20) {
                  int v20 = v31;
                }
                if (v31 >= v11) {
                  int v11 = v31 + 1;
                }
              }
            }
            int v28 = v99;
            unsigned int v69 = (v100 + v55 + v60 + v64 + 2) >> 2;
            unsigned int v70 = (unsigned char *)(v89 + v9);
            *unsigned int v70 = v69;
            v70[1] = (v45 + v56 + v61 + v65 + 2) >> 2;
            int v29 = v101;
          }
          v33 += v97;
          int v71 = v31 + 1;
          v31 += 2;
          v9 += v93;
        }
        while (v71 < v16);
        int v7 = v79;
        uint64_t v9 = v82;
        uint64_t v15 = v78;
        int v12 = v109;
        float v21 = v81;
        int v72 = v92 + 2;
      }
      v21 += v15;
      v10 += v80;
      v9 += v15;
      int v92 = v72;
    }
    while (v72 < v7);
    float v73 = (float)((v11 - v20) * (v12 - v13)) * 0.785398163;
    a7 = v75;
  }
  float result = rintf(v73);
  *a7 = (uint64_t)result;
  return result;
}

uint64_t whiteEyeCancellation(int *a1, uint64_t a2, float a3, uint64_t a4, uint64_t a5, unsigned __int8 **a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t *a11, uint64_t a12, uint64_t a13, int *a14, _DWORD *a15)
{
  int v17 = a1[3];
  if (v17 < 1)
  {
    int v18 = 0;
    if (!a9) {
      return 0;
    }
  }
  else
  {
    int v18 = 0;
    int v19 = 0;
    int v20 = *a6;
    do
    {
      if (a1[2] >= 1)
      {
        int v21 = a1[2];
        int v22 = v20;
        do
        {
          v18 += *v22;
          v22 += a1[7];
          --v21;
        }
        while (v21);
      }
      ++v19;
      v20 += a1[4];
    }
    while (v19 != v17);
    if (!a9) {
      return 0;
    }
  }
  int v198 = a1[2];
  int v192 = a1[3];
  uint64_t v199 = a1[7];
  uint64_t v191 = a1[4];
  uint64_t v186 = *(int *)(a12 + 28);
  uint64_t v187 = *(int *)(a12 + 16);
  uint64_t v203 = (uint64_t)rintf((float)v18 / 255.0);
  unint64_t v23 = bitmaskBoundingBitmapRect(a9);
  int v24 = v23;
  uint64_t v26 = v25;
  unint64_t v27 = HIDWORD(v23);
  bitmaskCentroid(a9);
  float v29 = v28;
  float v31 = v30;
  if (v24 >= (int)v27)
  {
    int v32 = 0;
  }
  else
  {
    int v32 = 0;
    uint64_t v209 = (uint64_t)rintf(v29);
    int v33 = -(uint64_t)rintf(v31);
    do
    {
      if ((int)v26 < SHIDWORD(v26))
      {
        unsigned int v34 = v26;
        do
        {
          int v35 = bitValueFromBitmask(a9, v34, v24);
          int v36 = (v24 - v209) * (v24 - v209) + (v33 + v34) * (v33 + v34);
          if (v36 <= v32) {
            int v36 = v32;
          }
          if (v35) {
            int v32 = v36;
          }
          ++v34;
        }
        while (HIDWORD(v26) != v34);
      }
      ++v24;
    }
    while (v24 != v27);
  }
  double v37 = sqrt((float)v32);
  inited = initBitmask(a1[2], a1[3]);
  int v39 = 0;
  float v40 = v37 * 12.5663706;
  uint64_t v41 = (uint64_t)rintf(v40);
  if ((int)v41 <= 6) {
    LODWORD(v41) = 6;
  }
  int v210 = v41;
  double v42 = 6.28318531 / (double)(int)v41;
  float v43 = v37 * 2.5;
  int v44 = -1;
  double v45 = 0.0;
  uint64_t v206 = (uint64_t)rintf(v43);
  int v46 = v206;
  do
  {
    __double2 v47 = __sincos_stret(v42 * v45);
    if (v44 != -1)
    {
      uint64_t v48 = (uint64_t)rintf((float)v44 * 1.5);
      if (v44 + 2 > (int)v48) {
        LODWORD(v4_Block_object_dispose(&STACK[0x238], 8) = v44 + 2;
      }
      if ((int)v48 >= (int)v206) {
        int v46 = v206;
      }
      else {
        int v46 = v48;
      }
    }
    float cosval = v47.__cosval;
    float sinval = v47.__sinval;
    int v51 = bilinearLookup((uint64_t)a1, v31, v29);
    if (v46 < 1)
    {
      int v53 = -1;
      int v52 = 0x10000;
    }
    else
    {
      int v52 = 0x10000;
      int v53 = -1;
      int v54 = v46;
      float v55 = v29;
      float v56 = v31;
      do
      {
        if (!bilinearLookupTest((uint64_t)a1, v56, v55)) {
          break;
        }
        int v57 = bilinearLookup((uint64_t)a1, v56, v55);
        if (v57 < v52) {
          int v52 = v57;
        }
        if (v57 > v53) {
          int v53 = v57;
        }
        float v56 = v56 + cosval;
        float v55 = v55 + sinval;
        --v54;
      }
      while (v54);
    }
    if (v52 < v51)
    {
      uint64_t v58 = 1717986919 * (v53 + 19 * v52 + 10);
      int v59 = (v58 >> 35) + ((unint64_t)v58 >> 63);
      if (v59 == v52) {
        int v60 = v59 + 1;
      }
      else {
        int v60 = v59;
      }
      if (v46 < 1)
      {
        int v44 = 0;
      }
      else
      {
        int v44 = 0;
        float v61 = v29;
        float v62 = v31;
        while (bilinearLookupTest((uint64_t)a1, v62, v61))
        {
          int v63 = bilinearLookup((uint64_t)a1, v62, v61);
          setBitInBitmask((uint64_t)inited, (uint64_t)rintf(v62), (uint64_t)rintf(v61), 1);
          if (v63 < v60) {
            break;
          }
          ++v44;
          float v62 = v62 + cosval;
          float v61 = v61 + sinval;
          if (v46 == v44)
          {
            int v44 = v46;
            break;
          }
        }
      }
    }
    double v45 = v45 + 1.0;
    ++v39;
  }
  while (v39 != v210);
  int v64 = *((_DWORD *)inited + 3);
  if (v64 < 1)
  {
    int v65 = 0;
    int v68 = v203;
  }
  else
  {
    int v65 = 0;
    int v66 = 0;
    int v67 = *((_DWORD *)inited + 2);
    int v68 = v203;
    do
    {
      if (v67 >= 1)
      {
        for (signed int i = 0; i < v67; ++i)
        {
          if (bitValueFromBitmask((uint64_t)inited, i, v66)) {
            ++v65;
          }
          int v67 = *((_DWORD *)inited + 2);
        }
        int v64 = *((_DWORD *)inited + 3);
      }
      ++v66;
    }
    while (v66 < v64);
  }
  termBitmask((void **)inited);
  if (v65 - v68 > 2 * v68) {
    return 0;
  }
  unint64_t v71 = bitmaskBoundingBitmapRect(a9);
  int v72 = v71;
  uint64_t v74 = v73;
  unint64_t v75 = HIDWORD(v71);
  bitmaskCentroid(a9);
  float v77 = v76;
  float v79 = v78;
  if (v72 >= (int)v75)
  {
    int v80 = 0;
  }
  else
  {
    int v80 = 0;
    uint64_t v211 = (uint64_t)rintf(v77);
    int v81 = -(uint64_t)rintf(v79);
    do
    {
      if ((int)v74 < SHIDWORD(v74))
      {
        unsigned int v82 = v74;
        do
        {
          int v83 = bitValueFromBitmask(a9, v82, v72);
          int v84 = (v72 - v211) * (v72 - v211) + (v81 + v82) * (v81 + v82);
          if (v84 <= v80) {
            int v84 = v80;
          }
          if (v83) {
            int v80 = v84;
          }
          ++v82;
        }
        while (HIDWORD(v74) != v82);
      }
      ++v72;
    }
    while (v72 != v75);
  }
  int v85 = 0;
  int v86 = 0;
  double v87 = sqrt((float)v80);
  float v88 = v87 * 12.5663706;
  uint64_t v89 = (uint64_t)rintf(v88);
  if ((int)v89 <= 6) {
    LODWORD(v89) = 6;
  }
  int v200 = v89;
  double v193 = 6.28318531 / (double)(int)v89;
  float v90 = v87 * 2.5;
  int v212 = *((_DWORD *)a11 + 4);
  int v204 = *(_DWORD *)(a12 + 16);
  int v207 = *((_DWORD *)a11 + 7);
  int v202 = *(_DWORD *)(a12 + 28);
  int v91 = -1;
  double v92 = 0.0;
  uint64_t v190 = (uint64_t)rintf(v90);
  int v93 = v190;
  float v196 = v77;
  float v194 = v79;
  do
  {
    __double2 v94 = __sincos_stret(v193 * v92);
    if (v91 != -1)
    {
      uint64_t v95 = (uint64_t)rintf((float)v91 * 1.5);
      if (v91 + 2 > (int)v95) {
        LODWORD(v95) = v91 + 2;
      }
      if ((int)v95 >= (int)v190) {
        int v93 = v190;
      }
      else {
        int v93 = v95;
      }
    }
    float v96 = v94.__cosval;
    float v97 = v94.__sinval;
    int v98 = bilinearLookup((uint64_t)a1, v79, v77);
    if (v93 < 1)
    {
      int v101 = 0x10000;
      double v103 = 0.0;
      int v99 = -1;
      double v100 = 0.0;
    }
    else
    {
      int v99 = -1;
      double v100 = 0.0;
      int v101 = 0x10000;
      int v102 = v93;
      double v103 = 0.0;
      do
      {
        if (!bilinearLookupTest((uint64_t)a1, v79, v77)) {
          break;
        }
        int v104 = bilinearLookup((uint64_t)a1, v79, v77);
        if (v104 < v101)
        {
          double v103 = bilinearCbCrLookup(a2, v79 * 0.5, v77 * 0.5);
          double v100 = v105;
          int v101 = v104;
        }
        if (v104 > v99) {
          int v99 = v104;
        }
        float v79 = v79 + v96;
        float v77 = v77 + v97;
        --v102;
      }
      while (v102);
    }
    int v106 = a11;
    float v77 = v196;
    float v79 = v194;
    if (v101 < v98)
    {
      uint64_t v107 = 1717986919 * (v99 + 19 * v101 + 10);
      int v108 = (v107 >> 35) + ((unint64_t)v107 >> 63);
      if (v108 == v101) {
        int v109 = v108 + 1;
      }
      else {
        int v109 = v108;
      }
      if (v93 < 1)
      {
        int v91 = 0;
      }
      else
      {
        int v91 = 0;
        int v110 = (int)v103;
        int v111 = (int)v100;
        float v112 = v196;
        float v113 = v194;
        while (bilinearLookupTest((uint64_t)a1, v113, v112))
        {
          int v114 = bilinearLookup((uint64_t)a1, v113, v112);
          *(unsigned char *)(*a11 + v212 * (uint64_t)(int)(uint64_t)rintf(v112) + v207 * (uint64_t)(int)(uint64_t)rintf(v113)) = v101;
          int v115 = (unsigned char *)(*(void *)a12
                         + v204 * (uint64_t)(int)(uint64_t)rintf(v112 * 0.5)
                         + v202 * (uint64_t)(int)(uint64_t)rintf(v113 * 0.5));
          *int v115 = v110;
          v115[1] = v111;
          if (v114 < v109) {
            break;
          }
          ++v91;
          float v113 = v113 + v96;
          float v112 = v112 + v97;
          if (v93 == v91)
          {
            int v91 = v93;
            break;
          }
        }
      }
    }
    v86 += v101;
    double v92 = v92 + 1.0;
    ++v85;
  }
  while (v85 != v200);
  if (a14) {
    int v116 = *a14;
  }
  else {
    int v116 = (v86 / v200 + 1) >> 1;
  }
  int v197 = v116;
  uint64_t v117 = v199;
  int v118 = v192;
  uint64_t v119 = a13;
  float v120 = *(float *)(a13 + 20);
  srandom(0x4853467u);
  if (v192 < 1)
  {
    float v139 = 0.0;
    float v142 = NAN;
    float v141 = NAN;
    float v157 = 0.0;
    uint64_t v144 = v191;
    int v128 = v198;
    float v150 = a3;
  }
  else
  {
    int v215 = 0;
    int v208 = 0;
    int v205 = 0;
    int v213 = 0;
    int v121 = 0;
    int v122 = 0;
    uint64_t v195 = (uint64_t)rintf((float)(2.0 / v120) * 4096.0);
    size_t v123 = *a6;
    uint64_t v124 = *a11;
    char v125 = 1;
    float v126 = 0.0;
    float v127 = 0.0;
    int v128 = v198;
    do
    {
      int v201 = v122 + 1;
      if (v128 >= 1)
      {
        uint64_t v129 = 0;
        for (int j = 0; j != v128; ++j)
        {
          int v131 = v123[v129];
          if (v123[v129])
          {
            int v132 = *(unsigned __int8 *)(v124 + v129);
            int v133 = v132
                 + (((v197 - v132 + ((((random() >> 7) - 128) * (int)v195 + 2048) >> 12))
                   * v131
                   + 128) >> 8);
            *(unsigned char *)(v124 + v129) = v133 & ~(v133 >> 31);
            if (v125)
            {
              int v215 = j + 1;
              int v213 = v122;
              int v205 = j;
              int v208 = v122 + 1;
            }
            else
            {
              int v134 = v213;
              if (v122 < v213) {
                int v134 = v122;
              }
              int v213 = v134;
              int v135 = v208;
              if (v122 >= v208) {
                int v135 = v122 + 1;
              }
              int v208 = v135;
              int v136 = v205;
              if (j < v205) {
                int v136 = j;
              }
              int v205 = v136;
              int v137 = v215;
              if (j >= v215) {
                int v137 = j + 1;
              }
              int v215 = v137;
            }
            uint64_t v117 = v199;
            int v128 = v198;
            char v125 = 0;
            v121 += v131;
            float v127 = v127 + (float)(v122 * v131);
            float v126 = v126 + (float)(j * v131);
          }
          v129 += v117;
        }
      }
      v124 += v191;
      v123 += v191;
      ++v122;
    }
    while (v201 != v192);
    int v138 = 0;
    float v139 = (float)v121;
    float v140 = 1.0 / (float)v121;
    float v141 = v140 * v126;
    float v142 = v140 * v127;
    uint64_t v119 = a13;
    int v143 = *a6;
    uint64_t v144 = v191;
    int v106 = a11;
    uint64_t v145 = 2 * (int)v191;
    uint64_t v146 = &(*a6)[v117];
    uint64_t v147 = &(*a6)[v191];
    uint64_t v148 = &(*a6)[(int)v117 + (int)v191];
    uint64_t v149 = *(void *)a12 + 1;
    int v118 = v192;
    float v150 = a3;
    do
    {
      if (v128 >= 1)
      {
        uint64_t v151 = 0;
        int v152 = 0;
        int v153 = (unsigned char *)v149;
        do
        {
          unsigned int v154 = v146[v151] + v143[v151] + v147[v151] + v148[v151];
          if (v154 >= 2)
          {
            unsigned int v155 = (v154 + 2) >> 2;
            __int16 v156 = *v153;
            *(v153 - 1) += (unsigned __int16)((128 - *(v153 - 1)) * v155 + 128) >> 8;
            *int v153 = v156 + ((unsigned __int16)((128 - v156) * v155 + 128) >> 8);
          }
          v151 += 2 * (int)v117;
          v152 += 2;
          v153 += v186;
        }
        while (v152 < v128);
      }
      v138 += 2;
      v143 += v145;
      v146 += v145;
      v147 += v145;
      v148 += v145;
      v149 += v187;
    }
    while (v138 < v192);
    float v157 = (float)((v215 - v205) * (v208 - v213)) * 0.785398163;
  }
  uint64_t result = (uint64_t)rintf(v139 / 255.0);
  *a15 = (uint64_t)rintf(v157);
  double v158 = sqrt((float)(int)result / 3.14159265);
  *(float *)&double v158 = v158 + v158;
  double v159 = *(float *)&v158;
  if (v150 == 0.0)
  {
    if (*(unsigned char *)(v119 + 24)) {
      double v160 = v159 * 10.4;
    }
    else {
      double v160 = (v159 + -4.1) * 10.75;
    }
    float v150 = v160;
  }
  if (*(float *)(a10 + 20) <= 0.7
    || *(_DWORD *)(a10 + 40) - *(_DWORD *)(a10 + 36) <= 2 * (*(_DWORD *)(a10 + 48) - *(_DWORD *)(a10 + 44)))
  {
    if (*(unsigned char *)(v119 + 24))
    {
      float v161 = 0.5;
      if (v159 >= 4.7) {
        float v161 = 1.6 / (v159 + -1.5);
      }
    }
    else
    {
      float v161 = 0.1;
    }
    float v162 = v150 * 0.0266667;
    float v163 = v162 * 0.5;
    float v164 = (float)(v162 * 0.5) * 4.0;
    unsigned int v165 = vcvtps_s32_f32(v164);
    uint64_t v166 = (uint64_t)rintf(v141);
    uint64_t v167 = (uint64_t)rintf(v142);
    int v168 = v165 + v167;
    int v169 = (int)(v165 + v166) < v128 ? v165 + v166 + 1 : v128;
    int v170 = (v167 - v165) & ~((int)(v167 - v165) >> 31);
    int v171 = v168 < v118 ? v168 + 1 : v118;
    if (v170 < v171)
    {
      double v172 = 1.0 - v161;
      float v173 = v172 * v163;
      float v174 = (float)v197 + (float)(250 - v197) * (v172 * 0.67 + 0.33);
      uint64_t v175 = (uint64_t)rintf(v174);
      int v176 = (v166 - v165) & ~((int)(v166 - v165) >> 31);
      float v177 = v173 * v173;
      float v178 = 1.0 / (float)(v164 - v173);
      uint64_t v179 = *v106 + v170 * (int)v144;
      while (v176 >= v169)
      {
LABEL_167:
        ++v170;
        v179 += v144;
        if (v170 == v171) {
          return result;
        }
      }
      size_t v180 = (unsigned char *)(v179 + v176 * (int)v117);
      int v181 = v176;
      while (1)
      {
        float v182 = (float)((float)((float)v170 - v142) * (float)((float)v170 - v142))
             + (float)((float)((float)v181 - v141) * (float)((float)v181 - v141));
        LOBYTE(v183) = v175;
        if (v182 < v177) {
          goto LABEL_165;
        }
        if (v182 < (float)(v164 * v164)) {
          break;
        }
LABEL_166:
        ++v181;
        v180 += v117;
        if (v169 == v181) {
          goto LABEL_167;
        }
      }
      float v184 = v178 * (float)(v164 - sqrtf(v182));
      float v185 = (v184 * -2.0 + 3.0) * v184 * v184;
      unsigned int v183 = *v180
           + (((v175 - *v180)
             * (uint64_t)rintf((float)((float)(v184* (float)(v184* (float)(v184 * (float)(v184 * (float)(v184 * v184)))))+ (float)(v161* (float)(v185- (float)(v184* (float)(v184* (float)(v184* (float)(v184* (float)(v184 * v184))))))))* 4096.0)+ 2048) >> 12);
LABEL_165:
      *size_t v180 = v183;
      goto LABEL_166;
    }
  }
  return result;
}

void **closestConnectedComponent(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int *a5, int *a6)
{
  int v10 = *(_DWORD *)(a1 + 8);
  int v11 = *(_DWORD *)(a1 + 12);
  inited = initBitmask(v10, v11);
  if (!inited)
  {
    puts("closestConnectedComponent: can not allocate bitmask bm");
    return 0;
  }
  uint64_t v13 = (uint64_t)inited;
  uint64_t v14 = (void **)initBitmask(v10, v11);
  if (!v14)
  {
    puts("closestConnectedComponent: can not allocate bitmask bm2");
LABEL_24:
    termBitmask((void **)v13);
    return v14;
  }
  uint64_t v15 = (void **)initBitmask(v10, v11);
  if (!v15)
  {
    puts("closestConnectedComponent: can not allocate bitmask bm3");
    termBitmask((void **)v13);
    int v35 = v14;
    goto LABEL_30;
  }
  int v16 = v15;
  int v38 = a5;
  int v39 = a6;
  uint64_t v41 = 0;
  computeThresholdedBitmask((unsigned __int8 *)a1, (uint64_t *)v13, a2);
  memmove(*v16, *(const void **)v13, *(int *)(v13 + 12) * (uint64_t)*(int *)(v13 + 16));
  if (v11 < 1)
  {
LABEL_27:
    termBitmask((void **)v13);
    termBitmask(v14);
    int v35 = v16;
    goto LABEL_30;
  }
  float v40 = v16;
  uint64_t v17 = 0;
  float v18 = (float)(v10 * v10 + v11 * v11);
  uint64_t v19 = 0xFFFFFFFFLL;
  int v20 = -1;
  while (v10 < 1)
  {
LABEL_15:
    uint64_t v17 = (v17 + 1);
    if (v17 == v11)
    {
      int v16 = v40;
      if (v19 != -1)
      {
        seedFill((uint64_t)v40, (uint64_t)v14, v20, v19, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))bitIsSet);
        unint64_t v30 = bitmaskBoundingBitmapRect((uint64_t)v14);
        int v32 = HIDWORD(v30) + v30;
        if (HIDWORD(v30) + (int)v30 < 0 != __OFADD__(HIDWORD(v30), v30)) {
          ++v32;
        }
        int v33 = v32 >> 1;
        int v34 = HIDWORD(v31) + v31;
        if (HIDWORD(v31) + (int)v31 < 0 != __OFADD__(HIDWORD(v31), v31)) {
          ++v34;
        }
        *int v38 = v34 >> 1;
        *int v39 = v33;
        termBitmask(v40);
        goto LABEL_24;
      }
      goto LABEL_27;
    }
  }
  unsigned int v21 = 0;
  while (!bitValueFromBitmask(v13, v21, v17))
  {
LABEL_14:
    if (v10 == ++v21) {
      goto LABEL_15;
    }
  }
  if (!seedFill(v13, (uint64_t)v14, v21, v17, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))bitIsSet))
  {
    int v36 = "closestConnectedComponent: seedFill failed";
    goto LABEL_29;
  }
  unint64_t v22 = bitmaskBoundingBitmapRect((uint64_t)v14);
  uint64_t v24 = v23;
  bitmaskCentroidUsingBoundingRect((uint64_t)v14, v22, v23);
  float v27 = v25 + -(float)v10 * 0.5;
  float v28 = v26 + -(float)v11 * 0.5;
  float v29 = (float)(v28 * v28) + (float)(v27 * v27);
  if (v29 >= v18)
  {
LABEL_13:
    bitmaskMinus(v13, (uint64_t)v14);
    goto LABEL_14;
  }
  closestSetBitInBitmaskUsingBoundingRect((uint64_t)v14, v22, v24, (int *)&v41 + 1, (int *)&v41, v25, v26);
  int v20 = HIDWORD(v41);
  if (HIDWORD(v41) != -1)
  {
    uint64_t v19 = v41;
    float v18 = v29;
    goto LABEL_13;
  }
  int v36 = "closestConnectedComponent: centroid closest bit search failed";
LABEL_29:
  puts(v36);
  termBitmask((void **)v13);
  termBitmask(v14);
  int v35 = v40;
LABEL_30:
  termBitmask(v35);
  return 0;
}

void *cornealReflectionBitmask(uint64_t a1, uint64_t a2, int a3)
{
  if (!a1 || a3 >= 1 && (float)a3 * 0.6 < (float)(int)bitmaskArea(a1)) {
    return 0;
  }
  inited = initBitmask(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12));
  if (!inited)
  {
    puts("cornealReflectionBitmask: can not allocate bitmask bm2 intended for spread");
    return inited;
  }
  if (!a2)
  {
    spreadBitmask3(a1, (uint64_t)inited, 0);
    return inited;
  }
  unint64_t v6 = bitmaskBoundingBitmapRect(a1);
  unint64_t v8 = v7;
  uint64_t v9 = *(int *)(a2 + 16);
  uint64_t v10 = *(int *)(a2 + 28);
  bitmaskCentroid(a1);
  unint64_t v66 = HIDWORD(v6);
  uint64_t v67 = (uint64_t)inited;
  if ((int)v6 < SHIDWORD(v6))
  {
    double v13 = v11;
    double v14 = v12;
    unint64_t v68 = 0;
    uint64_t v15 = *(void *)a2 + (int)v9 * (uint64_t)(int)v6;
    uint64_t v63 = (int)v10 * (uint64_t)(int)v8;
    uint64_t v64 = v9;
    unint64_t v16 = HIDWORD(v8);
    float v17 = 0.0;
    int v18 = 256;
    int v19 = v6;
    int v65 = v8;
    while ((int)v8 >= (int)v16)
    {
      float v25 = v17;
LABEL_21:
      ++v19;
      LODWORD(v_Block_object_dispose(&STACK[0x238], 8) = v65;
      v15 += v64;
      float v17 = v25;
      if (v19 == HIDWORD(v6))
      {
        int v27 = 0;
        int v29 = v68;
        int v28 = HIDWORD(v68);
        do
        {
          if ((int)v8 < (int)v16)
          {
            unsigned int v30 = v8;
            do
            {
              int v31 = bitValueFromBitmask(a1, v30, v6);
              int v32 = (v6 - HIDWORD(v68)) * (v6 - HIDWORD(v68)) + (v30 - v68) * (v30 - v68);
              if (v32 <= v27) {
                int v32 = v27;
              }
              if (v31) {
                int v27 = v32;
              }
              ++v30;
            }
            while (v16 != v30);
          }
          LODWORD(v6) = v6 + 1;
          LODWORD(v_Block_object_dispose(&STACK[0x238], 8) = v65;
        }
        while (v6 != v66);
        goto LABEL_35;
      }
    }
    float v20 = (float)v19 - v14;
    float v21 = v20 * v20;
    uint64_t v22 = v63;
    while (bitValueFromBitmask(a1, v8, v19))
    {
      int v23 = *(unsigned __int8 *)(v15 + v22);
      if (v18 <= v23)
      {
        if (v18 != v23) {
          break;
        }
        float v26 = (float)(int)v8 - v13;
        float v25 = v21 + (float)(v26 * v26);
        if (v25 >= v17) {
          break;
        }
        unint64_t v68 = __PAIR64__(v19, v8);
      }
      else
      {
        float v24 = (float)(int)v8 - v13;
        float v25 = v21 + (float)(v24 * v24);
        unint64_t v68 = __PAIR64__(v19, v8);
        int v18 = *(unsigned __int8 *)(v15 + v22);
      }
LABEL_18:
      LODWORD(v_Block_object_dispose(&STACK[0x238], 8) = v8 + 1;
      v22 += v10;
      float v17 = v25;
      if (v16 == v8) {
        goto LABEL_21;
      }
    }
    float v25 = v17;
    goto LABEL_18;
  }
  int v29 = 0;
  int v28 = 0;
  int v27 = 0;
LABEL_35:
  int v33 = 0;
  double v34 = sqrt((float)v27);
  float v35 = v34 * 12.5663706;
  uint64_t v36 = (uint64_t)rintf(v35);
  if ((int)v36 <= 6) {
    LODWORD(v36) = 6;
  }
  int v69 = v36;
  float v37 = v34 * 2.5;
  uint64_t v38 = (uint64_t)rintf(v37);
  double v39 = 6.28318531 / (double)(int)v36;
  float v40 = (float)v29;
  float v41 = (float)v28;
  int v42 = -1;
  double v43 = 0.0;
  int v44 = v38;
  do
  {
    __double2 v45 = __sincos_stret(v39 * v43);
    if (v42 != -1)
    {
      uint64_t v46 = (uint64_t)rintf((float)v42 * 1.5);
      if (v42 + 2 > (int)v46) {
        LODWORD(v46) = v42 + 2;
      }
      if ((int)v46 >= (int)v38) {
        int v44 = v38;
      }
      else {
        int v44 = v46;
      }
    }
    float cosval = v45.__cosval;
    float sinval = v45.__sinval;
    int v49 = bilinearLookup(a2, v40, v41);
    if (v44 < 1)
    {
      int v51 = 256;
      int v50 = -1;
    }
    else
    {
      int v50 = -1;
      int v51 = 256;
      int v52 = v44;
      float v53 = v41;
      float v54 = v40;
      do
      {
        if (!bilinearLookupTest(a2, v54, v53)) {
          break;
        }
        int v55 = bilinearLookup(a2, v54, v53);
        if (v55 < v51) {
          int v51 = v55;
        }
        if (v55 > v50) {
          int v50 = v55;
        }
        float v54 = v54 + cosval;
        float v53 = v53 + sinval;
        --v52;
      }
      while (v52);
    }
    if (v50 > v49)
    {
      uint64_t v56 = 1717986919 * (v51 + 19 * v50 + 10);
      int v57 = (v56 >> 35) + ((unint64_t)v56 >> 63);
      if (v44 < 1)
      {
        int v42 = 0;
      }
      else
      {
        int v42 = 0;
        int v58 = v57 - (v57 == v50);
        float v59 = v41;
        float v60 = v40;
        while (bilinearLookupTest(a2, v60, v59))
        {
          int v61 = bilinearLookup(a2, v60, v59);
          setBitInBitmask(v67, (uint64_t)rintf(v60), (uint64_t)rintf(v59), 1);
          if (v61 > v58) {
            break;
          }
          ++v42;
          float v60 = v60 + cosval;
          float v59 = v59 + sinval;
          if (v44 == v42)
          {
            int v42 = v44;
            break;
          }
        }
      }
    }
    double v43 = v43 + 1.0;
    ++v33;
    inited = (void *)v67;
  }
  while (v33 != v69);
  spreadBitmask3(v67, a1, 0);
  chokeBitmask(a1, v67, 0);
  return inited;
}

void infillChannelWithBitmask(uint64_t *a1, uint64_t a2, int a3, int a4)
{
  uint64_t v5 = a2;
  *(void *)&v230[468] = *MEMORY[0x1E4F143B8];
  unint64_t v7 = bitmaskBoundingBitmapRect(a2);
  unint64_t v9 = insetBitmapRect(v7, v8, 0xFFFFFFFFLL, -1);
  unint64_t v11 = v10;
  double v12 = zmalloc(0x10uLL);
  if (!v12)
  {
    puts("determineOutsidePath: unable to allocate path");
    return;
  }
  double v13 = v12;
  int v210 = a1;
  int v211 = a4;
  unint64_t v14 = HIDWORD(v9);
  *double v12 = 0;
  v12[1] = 0;
  inited = (void **)initBitmask(*(_DWORD *)(v5 + 8), *(_DWORD *)(v5 + 12));
  *((_DWORD *)v13 + 2) = 0;
  if ((int)v9 >= SHIDWORD(v9)) {
    goto LABEL_33;
  }
  unint64_t v214 = v11;
  int v215 = v13;
  int v15 = 0;
  unint64_t v16 = HIDWORD(v11);
  uint64_t v209 = v9;
  int v17 = v9;
  unint64_t v213 = HIDWORD(v9);
  uint64_t v217 = v5;
  unint64_t v218 = HIDWORD(v11);
  do
  {
    if ((int)v11 < (int)v16)
    {
      int v220 = v17 - 1;
      int v222 = v17 + 1;
      unsigned int v18 = v11;
      int v219 = v17;
      while (1)
      {
        if (bitValueFromBitmask(v5, v18, v17))
        {
          unsigned int v19 = v18 + 1;
        }
        else
        {
          LODWORD(v225) = bitValueFromBitmask(v5, v18 - 1, v220);
          int v15 = bitValueFromBitmask(v5, v18, v220);
          unsigned int v19 = v18 + 1;
          int v20 = bitValueFromBitmask(v5, v18 + 1, v220);
          int v21 = bitValueFromBitmask(v5, v18 - 1, v17);
          int v22 = bitValueFromBitmask(v5, v18 + 1, v17);
          int v23 = bitValueFromBitmask(v5, v18 - 1, v222);
          int v24 = bitValueFromBitmask(v5, v18, v222);
          if (v15 + v225 + v20 + v21 + v22 + v23 + v24 + bitValueFromBitmask(v5, v18 + 1, v222))
          {
            ++*((_DWORD *)v215 + 2);
            int v17 = v219;
            setBitInBitmask((uint64_t)inited, v18, v219, 1);
            if (v15 && v24)
            {
              ++*((_DWORD *)v215 + 2);
            }
            else if (v21)
            {
              LODWORD(v16) = v218;
              if (v22) {
                ++*((_DWORD *)v215 + 2);
              }
              uint64_t v5 = v217;
              goto LABEL_18;
            }
            uint64_t v5 = v217;
            LODWORD(v16) = v218;
          }
          else
          {
            uint64_t v5 = v217;
            LODWORD(v16) = v218;
            int v17 = v219;
          }
        }
LABEL_18:
        unsigned int v18 = v19;
        if (v19 == v16)
        {
          LODWORD(v14) = v213;
          unint64_t v11 = v214;
          int v25 = v222;
          goto LABEL_21;
        }
      }
    }
    int v25 = v17 + 1;
LABEL_21:
    int v17 = v25;
  }
  while (v25 != v14);
  double v13 = v215;
  if (!*((_DWORD *)v215 + 2))
  {
LABEL_33:
    puts("determineOutsidePath: no bits set");
    termBitmask(inited);
    zfree((void *)*v13);
    float v35 = (void **)v13;
LABEL_34:
    zfree(v35);
    return;
  }
  unint64_t v27 = insetBitmapRect(v209, v11, 0xFFFFFFFFLL, -1);
  unint64_t v28 = HIDWORD(v27);
  if ((int)v27 >= SHIDWORD(v27))
  {
    int v15 = 0;
    unsigned int v31 = 0;
    goto LABEL_42;
  }
  int v29 = v26;
  unint64_t v30 = HIDWORD(v26);
  do
  {
    if (v29 >= (int)v30) {
      goto LABEL_30;
    }
    unsigned int v31 = v29;
    do
    {
      int v32 = bitValueFromBitmask((uint64_t)inited, v31, v27);
      unsigned int v33 = v31 + 1;
      if (v32)
      {
        int v15 = v27;
        if (bitValueFromBitmask((uint64_t)inited, v33, v27)) {
          goto LABEL_42;
        }
        puts("determineOutsidePath: isolated point");
        termBitmask(inited);
        uint64_t v36 = (void **)v215;
        goto LABEL_94;
      }
      ++v31;
    }
    while (v30 != v33);
    int v15 = 0;
LABEL_30:
    int v34 = v15;
    int v15 = 0;
    if (v34)
    {
      unsigned int v31 = 0;
      break;
    }
    LODWORD(v27) = v27 + 1;
    unsigned int v31 = 0;
  }
  while ((int)v27 < (int)v28);
LABEL_42:
  uint64_t v36 = (void **)v215;
  float v37 = (char *)zmalloc(8 * *((int *)v215 + 2));
  *int v215 = v37;
  if (!v37)
  {
    puts("determineOutsidePath: unable to allocate path body");
    termBitmask(inited);
LABEL_94:
    zfree(*v36);
    float v35 = v36;
    goto LABEL_34;
  }
  uint64_t v38 = v37;
  LODWORD(v39) = 0;
  unsigned int v40 = v31;
  int v41 = v15;
  while (2)
  {
    LODWORD(v225) = v39;
    uint64_t v39 = ((_BYTE)v39 + 1) & 3;
    int v42 = v38 + 8;
    double v43 = v38;
LABEL_45:
    uint64_t v38 = v42;
    if (*((int *)v215 + 2) <= (uint64_t)&v43[-*v215] >> 3)
    {
      float v53 = "determineOutsidePath: overflow";
      break;
    }
    *((_DWORD *)v42 - 2) = v40;
    *((_DWORD *)v42 - 1) = v41;
    switch((int)v225)
    {
      case 1:
        ++v41;
        break;
      case 2:
        --v40;
        break;
      case 3:
        --v41;
        break;
      default:
        ++v40;
        break;
    }
    if (!bitValueFromBitmask((uint64_t)inited, v40, v41))
    {
      float v53 = "determineOutsidePath: border pixel expected";
      break;
    }
    if (v40 == v31 && v41 == v15)
    {
      uint64_t v54 = v5;
      termBitmask(inited);
      int v55 = 0;
      uint64_t v56 = 0;
      float v57 = 0.0;
      float v58 = *(float *)"(knN";
      double v59 = 3.14159265;
      float v60 = "infill arcs surround arcs";
      double v61 = 18.0;
      double v62 = -1.57079633;
      double v63 = 0.0001;
      uint64_t v64 = (double *)&unk_193951000;
      int v65 = "  [%2d] f2 %.2f pix %.2f ";
      unint64_t v66 = (float *)&unk_193958000;
      float v221 = 0.0;
      int v67 = a3;
      while (1)
      {
        unint64_t v68 = v65;
        int v225 = v56;
        int v69 = v60;
        unsigned int v70 = (void **)zmalloc(0x20uLL);
        if (!v70)
        {
          puts("determineArcsAtAngleForOutsidePath: unable to allocate arcs");
          return;
        }
        unint64_t v71 = v70;
        int v223 = v55;
        float v72 = (float)v55 * v59 / v61;
        *(_OWORD *)unsigned int v70 = 0u;
        *((_OWORD *)v70 + 1) = 0u;
        __double2 v73 = __sincos_stret(v72);
        if (fabs(v72 + v62) < v63)
        {
          float v76 = 1.0;
        }
        else
        {
          float cosval = v73.__cosval;
          float v57 = cosval;
          float sinval = v73.__sinval;
          float v76 = sinval;
        }
        *((_DWORD *)v71 + 6) = 0;
        *((_DWORD *)v71 + 2) = 0;
        unint64_t v77 = *((unsigned int *)v215 + 2);
        if ((int)v77 >= 1)
        {
          int v78 = 0;
          int v79 = 0;
          unint64_t v80 = 0;
          int v81 = (int *)*v215;
          unsigned int v82 = (int *)(*v215 + 4);
          int v83 = v211;
          while (1)
          {
            unint64_t v84 = v80;
            if (v80) {
              int v85 = v80;
            }
            else {
              int v85 = v77;
            }
            ++v80;
            int v86 = &v81[2 * v85];
            if (v80 < v77) {
              unint64_t v87 = v84 + 1;
            }
            else {
              unint64_t v87 = 0;
            }
            float v88 = (float)(v57 * (float)*v82) - (float)((float)*(v82 - 1) * v76);
            float v89 = v88 - (float)((float)(v57 * (float)*(v86 - 1)) - (float)((float)*(v86 - 2) * v76));
            float v90 = (float)((float)(v57 * (float)v81[2 * v87 + 1]) - (float)((float)v81[2 * v87] * v76)) - v88;
            if (v89 >= 0.0)
            {
              if (v89 <= 0.0)
              {
                if (v90 >= 0.0 && v90 <= 0.0) {
                  goto LABEL_118;
                }
                ++v79;
                goto LABEL_117;
              }
              if (v90 < 0.0)
              {
LABEL_110:
                v79 += 2;
LABEL_117:
                *((_DWORD *)v71 + 6) = v79;
                *((_DWORD *)v71 + 2) = ++v78;
                goto LABEL_118;
              }
            }
            else if (v90 > 0.0)
            {
              goto LABEL_110;
            }
            *((_DWORD *)v71 + 6) = ++v79;
LABEL_118:
            v82 += 2;
            if (v77 == v80) {
              goto LABEL_121;
            }
          }
        }
        int v79 = 0;
        int v83 = v211;
LABEL_121:
        int v91 = zmalloc(12 * v79);
        v71[2] = v91;
        if (!v91)
        {
          int v200 = "determineArcsAtAngleForOutsidePath: unable to allocate arc bodies";
          goto LABEL_260;
        }
        double v92 = (int *)zmalloc(12 * *((int *)v71 + 2));
        *unint64_t v71 = v92;
        if (!v92)
        {
          int v200 = "determineArcsAtAngleForOutsidePath: unable to allocate arcs";
          goto LABEL_260;
        }
        unint64_t v93 = *((unsigned int *)v215 + 2);
        if ((int)v93 >= 1)
        {
          unint64_t v94 = 0;
          int v95 = *((_DWORD *)v210 + 4);
          int v96 = *((_DWORD *)v210 + 7);
          uint64_t v97 = *v210;
          int v98 = v71[2];
          int v99 = (int *)*v215;
          double v100 = v92;
          int v101 = v98;
          while (1)
          {
            unint64_t v102 = v94;
            double v103 = &v99[2 * v94];
            int v105 = *v103;
            int v104 = v103[1];
            int v106 = v102 ? v102 : v93;
            unint64_t v94 = v102 + 1;
            uint64_t v107 = &v99[2 * v106];
            uint64_t v108 = v102 + 1 < v93 ? v102 + 1 : 0;
            float v109 = (float)(v57 * (float)v104) - (float)((float)v105 * v76);
            float v110 = v109 - (float)((float)(v57 * (float)*(v107 - 1)) - (float)((float)*(v107 - 2) * v76));
            float v111 = (float)((float)(v57 * (float)v99[2 * v108 + 1]) - (float)((float)v99[2 * v108] * v76)) - v109;
            if (v110 <= 0.0 && v111 > 0.0) {
              break;
            }
            if (v110 >= 0.0 && v111 < 0.0)
            {
              if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * (v100 - v92)) >= *((int *)v71 + 2)) {
                goto LABEL_263;
              }
              *double v100 = -1431655765 * ((unint64_t)(v101 - v98) >> 2);
              v100[1] = 0;
              *((unsigned char *)v100 + _Block_object_dispose(&STACK[0x238], 8) = 0;
              int64_t v112 = *((int *)v71 + 6);
              float v113 = v101 - 12;
              uint64_t v114 = v101 - v98;
              int v115 = -1;
              do
              {
                if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * (v114 >> 2)) >= v112) {
                  goto LABEL_259;
                }
                *((float *)v113 + 3) = (float)(v57 * (float)v104) - (float)((float)v105 * v76);
                *((float *)v113 + 4) = (float)(v76 * (float)v104) + (float)((float)v105 * v57);
                v113 += 12;
                *((_DWORD *)v113 + 2) = *(unsigned __int8 *)(v97 + (v104 + v83) * v95 + (v105 + v67) * v96);
                v100[1] = v115 + 2;
                if (v102 + 1 == v93) {
                  LODWORD(v102) = 0;
                }
                else {
                  LODWORD(v102) = v102 + 1;
                }
                int v121 = &v99[2 * (int)v102];
                int v105 = *v121;
                int v104 = v121[1];
                if ((int)v102 + 1 < (int)v93) {
                  int v122 = v102 + 1;
                }
                else {
                  int v122 = 0;
                }
                float v118 = (float)v105;
                float v119 = (float)v104;
                float v120 = (float)(v57 * (float)v104) - (float)((float)v105 * v76);
                ++v115;
                v114 += 12;
              }
              while ((float)((float)((float)(v57 * (float)v99[2 * v122 + 1]) - (float)((float)v99[2 * v122] * v76))
                            - v120) < 0.0);
LABEL_156:
              if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * (v114 >> 2)) >= v112) {
                goto LABEL_259;
              }
              *((float *)v113 + 3) = v120;
              *((float *)v113 + 4) = (float)(v76 * v119) + (float)(v118 * v57);
              *((_DWORD *)v113 + 5) = *(unsigned __int8 *)(v97 + (v104 + v83) * v95 + (v105 + v67) * v96);
              int v101 = v113 + 24;
              v100[1] = v115 + 2;
              v100 += 3;
            }
            if (v94 == v93) {
              goto LABEL_159;
            }
          }
          if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * (v100 - v92)) >= *((int *)v71 + 2))
          {
LABEL_263:
            int v200 = "determineArcsAtAngleForOutsidePath: too many arcs";
          }
          else
          {
            *double v100 = -1431655765 * ((unint64_t)(v101 - v98) >> 2);
            v100[1] = 0;
            *((unsigned char *)v100 + _Block_object_dispose(&STACK[0x238], 8) = 1;
            int64_t v112 = *((int *)v71 + 6);
            float v113 = v101 - 12;
            uint64_t v114 = v101 - v98;
            int v115 = -1;
            while ((uint64_t)(0xAAAAAAAAAAAAAAABLL * (v114 >> 2)) < v112)
            {
              *((float *)v113 + 3) = (float)(v57 * (float)v104) - (float)((float)v105 * v76);
              *((float *)v113 + 4) = (float)(v76 * (float)v104) + (float)((float)v105 * v57);
              v113 += 12;
              *((_DWORD *)v113 + 2) = *(unsigned __int8 *)(v97 + (v104 + v83) * v95 + (v105 + v67) * v96);
              v100[1] = v115 + 2;
              if (v102 + 1 == v93) {
                LODWORD(v102) = 0;
              }
              else {
                LODWORD(v102) = v102 + 1;
              }
              int v116 = &v99[2 * (int)v102];
              int v105 = *v116;
              int v104 = v116[1];
              if ((int)v102 + 1 < (int)v93) {
                int v117 = v102 + 1;
              }
              else {
                int v117 = 0;
              }
              float v118 = (float)v105;
              float v119 = (float)v104;
              float v120 = (float)(v57 * (float)v104) - (float)((float)v105 * v76);
              ++v115;
              v114 += 12;
              if ((float)((float)((float)(v57 * (float)v99[2 * v117 + 1]) - (float)((float)v99[2 * v117] * v76)) - v120) <= 0.0) {
                goto LABEL_156;
              }
            }
LABEL_259:
            int v200 = "determineArcsAtAngleForOutsidePath: too many arc bodies";
          }
LABEL_260:
          puts(v200);
          goto LABEL_261;
        }
LABEL_159:
        int v123 = *((_DWORD *)v71 + 2);
        double v205 = v62;
        double v206 = v63;
        double v204 = v59;
        if (v123 < 1)
        {
          int v125 = v209;
          int v126 = v214;
        }
        else
        {
          int v124 = 0;
          int v125 = v209;
          int v126 = v214;
          do
          {
            if (!*((unsigned char *)v92 + 8))
            {
              float v127 = v71[2];
              unint64_t v128 = (unint64_t)v127 + 12 * *v92;
              unint64_t v129 = v128 + 12 * v92[1] - 12;
              if (v129 > v128)
              {
                unint64_t v130 = (unint64_t)v127 + 12 * *v92 + 12;
                do
                {
                  uint64_t __base = *(void *)(v130 - 12);
                  uint64_t v131 = __base;
                  int v229 = *(_DWORD *)(v130 - 4);
                  int v132 = v229;
                  int v133 = *(_DWORD *)(v129 + 8);
                  *(void *)(v130 - 12) = *(void *)v129;
                  *(_DWORD *)(v130 - 4) = v133;
                  *(void *)unint64_t v129 = v131;
                  *(_DWORD *)(v129 + _Block_object_dispose(&STACK[0x238], 8) = v132;
                  v129 -= 12;
                  BOOL v134 = v129 > v130;
                  v130 += 12;
                }
                while (v134);
                int v123 = *((_DWORD *)v71 + 2);
              }
            }
            ++v124;
            v92 += 3;
          }
          while (v124 < v123);
        }
        float v135 = -1000000.0;
        float v136 = 1000000.0;
        int v137 = v125;
        float v60 = v69;
        do
        {
          if (v126 < (int)v16)
          {
            float v139 = v135;
            signed int v140 = v126;
            do
            {
              if (!bitValueFromBitmask(v54, v140, v137)) {
                goto LABEL_176;
              }
              float v138 = v57 * (float)v137;
              float v135 = v138 - (float)((float)v140 * v76);
              if (v135 < v136) {
                float v136 = v138 - (float)((float)v140 * v76);
              }
              if (v135 <= v139) {
LABEL_176:
              }
                float v135 = v139;
              float v60 = v69;
              int v65 = v68;
              ++v140;
              float v139 = v135;
            }
            while (v16 != v140);
          }
          ++v137;
          int v126 = v214;
        }
        while (v137 != v213);
        uint64_t v226 = 0;
        uint64_t v227 = 0;
        int v141 = 0;
        float v142 = 0.0;
        if (v136 > v135)
        {
LABEL_180:
          float v143 = v142 / (float)v141;
          double v62 = v205;
          double v63 = v206;
          float v57 = 0.0;
          double v59 = v204;
          goto LABEL_214;
        }
        while (1)
        {
          int v144 = *((_DWORD *)v71 + 2);
          if (v144 < 1)
          {
LABEL_210:
            puts("arcCorrelation: no crossings at f1");
            int v65 = v68;
LABEL_212:
            float v143 = v66[245];
            LODWORD(v16) = v218;
            goto LABEL_213;
          }
          int v145 = 0;
          uint64_t v146 = (char *)v71[2];
          double v147 = v136;
          uint64_t v148 = (char *)*v71 + 8;
          do
          {
            uint64_t v149 = (float *)&v146[12 * *((int *)v148 - 2)];
            double v150 = v64[461];
            if (*v149 + v150 <= v147)
            {
              int v151 = *((_DWORD *)v148 - 1);
              if (v149[3 * v151 - 3] + v150 >= v147)
              {
                float v152 = f2AndPixelValueFromBorderPixelsAt((uint64_t)v149, v151, (float *)&v227 + 1, v136);
                if (v145 >= 40)
                {
                  puts("arcCorrelation: too many crossings");
                  unint64_t v66 = (float *)&unk_193958000;
                  float v143 = 100000000.0;
                  LODWORD(v16) = v218;
                  double v62 = v205;
                  double v63 = v206;
                  float v57 = 0.0;
                  double v59 = v204;
                  float v60 = v69;
                  double v61 = 18.0;
                  int v65 = v68;
                  goto LABEL_215;
                }
                int v153 = (float *)&__base + 3 * v145;
                *int v153 = *((float *)&v227 + 1);
                v153[1] = v152;
                *((unsigned char *)v153 + _Block_object_dispose(&STACK[0x238], 8) = *v148;
                ++v145;
              }
            }
            v148 += 12;
            --v144;
          }
          while (v144);
          if (v145)
          {
            puts("arcCorrelation: odd number of crossings");
            int v65 = v68;
            unint64_t v66 = (float *)&unk_193958000;
            goto LABEL_212;
          }
          unint64_t v66 = (float *)&unk_193958000;
          if (!v145) {
            goto LABEL_210;
          }
          qsort(&__base, v145, 0xCuLL, (int (__cdecl *)(const void *, const void *))crossingCompare);
          if (v145 >= 1) {
            break;
          }
          LODWORD(v16) = v218;
LABEL_201:
          float v136 = v136 + 0.5;
          float v60 = v69;
          int v65 = v68;
          if (v136 > v135) {
            goto LABEL_180;
          }
        }
        int v154 = 0;
        p_base = (float *)&__base;
        __int16 v156 = v230;
        LODWORD(v16) = v218;
        while (1)
        {
          int v157 = *((unsigned __int8 *)p_base + 8);
          if (v157 != v156[8])
          {
            float v161 = p_base[1] - *((float *)v156 + 1);
            float v142 = v142 + (float)(v161 * v161);
            ++v141;
            goto LABEL_198;
          }
          if (v154 > v145 - 4) {
            break;
          }
          double v158 = v156 + 12;
          if (vabds_f32(*(float *)v156, *((float *)v156 + 3)) >= 0.01 || v157 == v156[20]) {
            break;
          }
          uint64_t v226 = *(void *)v156;
          uint64_t v159 = v226;
          LODWORD(v227) = *((_DWORD *)v156 + 2);
          int v160 = v227;
          *(void *)__int16 v156 = *v158;
          *((_DWORD *)v156 + 2) = *((_DWORD *)v156 + 5);
          *double v158 = v159;
          *((_DWORD *)v156 + 5) = v160;
          v154 -= 2;
          p_base -= 6;
          v156 -= 24;
LABEL_198:
          v154 += 2;
          p_base += 6;
          v156 += 24;
          if (v154 >= v145) {
            goto LABEL_201;
          }
        }
        printf("arcCorrelation: improper crossing pairing at f1 %.2f\n", v136);
        printf("%d crossings:\n", v145);
        uint64_t v162 = 0;
        float v163 = &__base;
        int v65 = v68;
        do
        {
          printf(v68, v162, *(float *)v163, *((float *)v163 + 1));
          if (*((unsigned char *)v163 + 8)) {
            float v164 = "+";
          }
          else {
            float v164 = "-";
          }
          puts(v164);
          uint64_t v162 = (v162 + 1);
          float v163 = (uint64_t *)((char *)v163 + 12);
        }
        while (v145 != v162);
        unint64_t v66 = (float *)&unk_193958000;
        float v143 = 100000000.0;
        LODWORD(v16) = v218;
        uint64_t v64 = (double *)&unk_193951000;
LABEL_213:
        double v62 = v205;
        double v63 = v206;
        float v57 = 0.0;
        double v59 = v204;
        float v60 = v69;
LABEL_214:
        double v61 = 18.0;
LABEL_215:
        int v67 = a3;
        if (v143 >= v58)
        {
          unsigned int v165 = v71;
          float v72 = v221;
          unint64_t v71 = v225;
          float v143 = v58;
        }
        else
        {
          unsigned int v165 = v225;
          float v166 = v72;
          if (!v225) {
            goto LABEL_220;
          }
        }
        freeArcs(v165);
        int v65 = v68;
        float v60 = v69;
        float v166 = v72;
LABEL_220:
        float v221 = v166;
        int v55 = v223 + 1;
        float v58 = v143;
        uint64_t v56 = v71;
        if (v223 == 17)
        {
          zfree((void *)*v215);
          zfree(v215);
          uint64_t v226 = 0;
          uint64_t v227 = 0;
          __double2 v167 = __sincos_stret(v221);
          BOOL v170 = fabs(v221 + v62) < v63;
          if (v170)
          {
            float v171 = 0.0;
          }
          else
          {
            float v168 = v167.__cosval;
            float v171 = v168;
          }
          if (v170)
          {
            float v172 = 1.0;
          }
          else
          {
            float v169 = v167.__sinval;
            float v172 = v169;
          }
          uint64_t v207 = *((int *)v210 + 7);
          uint64_t v208 = *v210;
          int v173 = v214;
          uint64_t v224 = *((int *)v210 + 4);
          float v174 = v64;
          uint64_t v175 = (int)v209;
          double v176 = v174[461];
          while (1)
          {
            if (v173 >= (int)v16) {
              goto LABEL_257;
            }
            *(float *)&int v225 = v171 * (float)(int)v175;
            uint64_t v177 = (int)v214;
            do
            {
              if (!bitValueFromBitmask(v54, v177, v175)) {
                goto LABEL_256;
              }
              int v178 = *((_DWORD *)v71 + 2);
              if (v178 < 1)
              {
LABEL_274:
                int v200 = "arcInfill: no crossings at f1";
                goto LABEL_260;
              }
              int v179 = 0;
              float v180 = *(float *)&v225 - (float)((float)(int)v177 * v172);
              float v181 = (float)(v172 * (float)(int)v175) + (float)((float)(int)v177 * v171);
              float v182 = (char *)v71[2];
              double v183 = v180;
              float v184 = (char *)*v71 + 8;
              do
              {
                float v185 = (float *)&v182[12 * *((int *)v184 - 2)];
                if (*v185 + v176 <= v183)
                {
                  int v186 = *((_DWORD *)v184 - 1);
                  if (v185[3 * v186 - 3] + v176 >= v183)
                  {
                    float v187 = f2AndPixelValueFromBorderPixelsAt((uint64_t)v185, v186, (float *)&v227 + 1, v180);
                    if (v179 > 39)
                    {
                      int v200 = "arcInfill: too many crossings";
                      goto LABEL_260;
                    }
                    float v188 = (float *)&__base + 3 * v179;
                    *float v188 = *((float *)&v227 + 1);
                    v188[1] = (float)(int)v187;
                    *((unsigned char *)v188 + _Block_object_dispose(&STACK[0x238], 8) = *v184;
                    ++v179;
                  }
                }
                v184 += 12;
                --v178;
              }
              while (v178);
              if (v179)
              {
                int v200 = "arcInfill: odd number of crossings";
                goto LABEL_260;
              }
              LODWORD(v16) = v218;
              if (!v179) {
                goto LABEL_274;
              }
              qsort(&__base, v179, 0xCuLL, (int (__cdecl *)(const void *, const void *))crossingCompare);
              if (v179 < 1) {
                goto LABEL_256;
              }
              int v189 = 0;
              uint64_t v190 = (float *)&__base;
              uint64_t v191 = v230;
              while (2)
              {
                int v192 = *((unsigned __int8 *)v190 + 8);
                if (v192 == v191[8])
                {
                  if (v189 > v179 - 4
                    || (double v193 = v191 + 12, vabds_f32(*(float *)v191, *((float *)v191 + 3)) >= 0.01)
                    || v192 == v191[20])
                  {
                    printf("arcInfill: improper crossing pairing at f1 %.2f\n", v180);
                    printf("%d crossings:\n", v179);
                    int v201 = 0;
                    int v202 = &__base;
                    do
                    {
                      printf("  [%2d] f2 %.2f pix %.2f ", v201, *(float *)v202, *((float *)v202 + 1));
                      if (*((unsigned char *)v202 + 8)) {
                        uint64_t v203 = "+";
                      }
                      else {
                        uint64_t v203 = "-";
                      }
                      puts(v203);
                      ++v201;
                      int v202 = (uint64_t *)((char *)v202 + 12);
                    }
                    while (v179 != v201);
                    goto LABEL_261;
                  }
                  uint64_t v226 = *(void *)v191;
                  uint64_t v194 = v226;
                  LODWORD(v227) = *((_DWORD *)v191 + 2);
                  int v195 = v227;
                  *(void *)uint64_t v191 = *v193;
                  *((_DWORD *)v191 + 2) = *((_DWORD *)v191 + 5);
                  *double v193 = v194;
                  *((_DWORD *)v191 + 5) = v195;
                  v189 -= 2;
                  v190 -= 6;
                  v191 -= 24;
                  goto LABEL_249;
                }
                float v196 = *v190;
                if (*v190 > v181 || (float v197 = *(float *)v191, v181 > *(float *)v191))
                {
LABEL_249:
                  v189 += 2;
                  v190 += 6;
                  v191 += 24;
                  if (v189 >= v179) {
                    goto LABEL_256;
                  }
                  continue;
                }
                break;
              }
              float v198 = 0.0;
              if (v197 > v196)
              {
                float v199 = (float)(v181 - v196) / (float)(v197 - v196);
                if (v199 >= 0.0)
                {
                  float v198 = v199;
                  if (v199 > 1.0) {
                    float v198 = 1.0;
                  }
                }
              }
              *(unsigned char *)(v208 + (v175 + v211) * v224 + (v177 + a3) * v207) = (uint64_t)rintf(v190[1]+ (float)((float)(*((float *)v191 + 1) - v190[1])* v198));
              LODWORD(v16) = v218;
LABEL_256:
              ++v177;
            }
            while (v177 != v16);
LABEL_257:
            ++v175;
            int v173 = v214;
            if (v175 == v213)
            {
LABEL_261:
              freeArcs(v71);
              return;
            }
          }
        }
      }
    }
    switch(v39)
    {
      case 1:
        int v45 = v41 + 1;
        goto LABEL_60;
      case 2:
        unsigned int v44 = v40 - 1;
        goto LABEL_58;
      case 3:
        int v45 = v41 - 1;
LABEL_60:
        unsigned int v44 = v40;
        goto LABEL_61;
      default:
        unsigned int v44 = v40 + 1;
LABEL_58:
        int v45 = v41;
LABEL_61:
        if (bitValueFromBitmask((uint64_t)inited, v44, v45)) {
          continue;
        }
        switch((int)v225)
        {
          case 1:
            int v47 = v41 + 1;
            goto LABEL_68;
          case 2:
            unsigned int v46 = v40 - 1;
            goto LABEL_66;
          case 3:
            int v47 = v41 - 1;
LABEL_68:
            unsigned int v46 = v40;
            goto LABEL_69;
          default:
            unsigned int v46 = v40 + 1;
LABEL_66:
            int v47 = v41;
LABEL_69:
            int v48 = bitValueFromBitmask((uint64_t)inited, v46, v47);
            int v42 = v38 + 8;
            v43 += 8;
            if (v48) {
              goto LABEL_45;
            }
            LODWORD(v39) = ((_BYTE)v225 - 1) & 3;
            switch(((_BYTE)v225 - 1) & 3)
            {
              case 1:
                int v50 = v41 + 1;
                goto LABEL_76;
              case 2:
                unsigned int v49 = v40 - 1;
                goto LABEL_74;
              case 3:
                int v50 = v41 - 1;
LABEL_76:
                unsigned int v49 = v40;
                goto LABEL_77;
              default:
                unsigned int v49 = v40 + 1;
LABEL_74:
                int v50 = v41;
LABEL_77:
                if (bitValueFromBitmask((uint64_t)inited, v49, v50)) {
                  continue;
                }
                LODWORD(v39) = ((_BYTE)v225 + 2) & 3;
                switch(((_BYTE)v225 + 2) & 3)
                {
                  case 1:
                    int v52 = v41 + 1;
                    goto LABEL_84;
                  case 2:
                    unsigned int v51 = v40 - 1;
                    goto LABEL_82;
                  case 3:
                    int v52 = v41 - 1;
LABEL_84:
                    unsigned int v51 = v40;
                    goto LABEL_85;
                  default:
                    unsigned int v51 = v40 + 1;
LABEL_82:
                    int v52 = v41;
LABEL_85:
                    if (bitValueFromBitmask((uint64_t)inited, v51, v52)) {
                      continue;
                    }
                    float v53 = "determineOutsidePath: nowhere to go";
                    break;
                }
                break;
            }
            break;
        }
        break;
    }
    break;
  }
  puts(v53);
  zfree((void *)*v215);
  zfree(v215);

  termBitmask(inited);
}

void freeArcs(void **a1)
{
  zfree(*a1);
  zfree(a1[2]);

  zfree(a1);
}

int *computePupilAlphaMap(uint64_t a1, uint64_t a2, int a3, uint64_t a4, _DWORD *a5, _DWORD *a6)
{
  uint64_t v267 = *MEMORY[0x1E4F143B8];
  int v263 = 0;
  long long v262 = 0;
  uint64_t v261 = 0;
  long long v259 = 0u;
  long long v260 = 0u;
  uint64_t v258 = 0;
  memset(v257, 0, sizeof(v257));
  uint64_t v264 = 0;
  uint64_t v265 = 0;
  histogramBitmap((unsigned __int8 **)a1, a2, v266, (_DWORD *)&v265 + 1, (int *)&v265);
  int v10 = v265;
  int v11 = HIDWORD(v265);
  unint64_t v14 = closestConnectedComponent(a1, ((int)v265 + 2 * HIDWORD(v265)) / 3, v12, v13, (int *)&v264, (int *)&v264 + 1);
  if (!v14) {
    return 0;
  }
  unint64_t v214 = a5;
  int v215 = a6;
  termBitmask(v14);
  unint64_t v15 = 0;
  LODWORD(v16) = 0;
  int v239 = 0;
  int v17 = (v11 + v10) >> 1;
  uint64_t v216 = v264;
  float v237 = (float)(int)v264;
  float v18 = sqrt((float)a3 / 3.14159265);
  float v235 = (float)SHIDWORD(v264);
  if (v17 >= 20) {
    int v17 = 20;
  }
  float v19 = (float)(v17 << 6);
  double v20 = v18 * 0.5;
  float v227 = 0.0;
  double v21 = 1.0;
  float v223 = 0.0;
  do
  {
    int v243 = v16;
    if (v15 <= 4)
    {
      float v223 = flt_1939583DC[v15];
      float v227 = flt_1939583F0[v15];
    }
    unint64_t v231 = v15;
    double v22 = (float)(v227 + v237);
    double v23 = (float)(v223 + v235);
    float v24 = (float)(v227 + v237) - (float)(*(_DWORD *)(a1 + 8) - 1);
    float v25 = v23 * v23 + v22 * v22;
    float v26 = (float)(v24 * v24) + v23 * v23;
    if (v26 > v25) {
      float v25 = (float)(v24 * v24) + v23 * v23;
    }
    float v27 = (float)((float)(v223 + v235) - (float)(*(_DWORD *)(a1 + 12) - 1))
        * (float)((float)(v223 + v235) - (float)(*(_DWORD *)(a1 + 12) - 1));
    float v28 = v27 + v22 * v22;
    if (v25 < v28) {
      float v25 = v27 + v22 * v22;
    }
    float v29 = v27 + (float)(v24 * v24);
    if (v29 <= v25) {
      float v29 = v25;
    }
    if (*(void *)a1)
    {
      int v239 = 0;
      int v30 = 0;
      uint64_t v217 = &v266[4 * (int)v16];
      int v31 = vcvtpd_s64_f64(sqrt(v29));
      double v32 = 0.0;
      do
      {
        unsigned int v33 = (unsigned __int16 *)zmalloc(4 * v31);
        if (v33)
        {
          int v34 = v33;
          float v35 = v32 * 0.03125 * 6.28318531;
          uint64_t v36 = &v33[v31];
          __double2 v37 = __sincos_stret(v35);
          if (v31 < 1)
          {
            *uint64_t v36 = (*v34 - v34[1]) & ~(unsigned __int16)((*v34 - v34[1]) >> 31);
            unsigned int v44 = v36 + 1;
            goto LABEL_40;
          }
          uint64_t v38 = 0;
          float cosval = v37.__cosval;
          float sinval = v37.__sinval;
          float v41 = v223 + v235;
          float v42 = v227 + v237;
          do
          {
            v34[v38] = bilinearLookupAccurate(a1, v42, v41);
            float v42 = v42 + cosval;
            float v41 = v41 + sinval;
            ++v38;
          }
          while (v31 != v38);
          double v43 = v34 + 1;
          *uint64_t v36 = (*v34 - v34[1]) & ~(unsigned __int16)((*v34 - v34[1]) >> 31);
          unsigned int v44 = v36 + 1;
          if (v31 <= 2)
          {
            double v21 = 1.0;
LABEL_40:
            *unsigned int v44 = (*v34 - v34[1]) & ~(unsigned __int16)((*v34 - v34[1]) >> 31);
LABEL_41:
            zfree(v34);
            goto LABEL_42;
          }
          uint64_t v265 = 0;
          int v45 = v31 - 2;
          double v21 = 1.0;
          do
          {
            unsigned int v46 = v43;
            int v47 = v43[1];
            ++v43;
            v46[v31] = (*(v46 - 1) - v47) & ~(unsigned __int16)((*(v46 - 1) - v47) >> 31);
            --v45;
          }
          while (v45);
          uint64_t v48 = 0;
          v43[v31] = (*(v43 - 1) - *v43) & ~(unsigned __int16)((*(v43 - 1) - *v43) >> 31);
          unsigned __int16 v49 = v34[v31];
          LOWORD(v44) = *v44;
          while (1)
          {
            float v50 = (float)v49;
            unsigned __int16 v49 = (unsigned __int16)v44;
            float v51 = (float)(unsigned __int16)v44;
            LODWORD(v44) = v34[v31 + 2 + v48];
            float v52 = (float)v44;
            BOOL v53 = v51 < v50 || v51 < v52;
            if (!v53 && v51 > v19 && (v50 != v51 || v51 != v52))
            {
              if (maximumPointWithSamples((float *)&v265 + 1, (float *)&v265, v50, v51, v52))
              {
                float v56 = *((float *)&v265 + 1) + (float)(int)v48;
                if (v20 < v56) {
                  break;
                }
              }
            }
            if ((v31 - 1) - 1 == ++v48) {
              goto LABEL_41;
            }
          }
          zfree(v34);
          float v57 = (double *)&v217[4 * v239];
          *float v57 = (float)(v227 + v237) + (float)(v56 * cosval);
          v57[1] = (float)(v223 + v235) + (float)(v56 * sinval);
          ++v239;
        }
LABEL_42:
        double v32 = v32 + v21;
        ++v30;
      }
      while (v30 != 32);
    }
    uint64_t v16 = (v239 + v243);
    unint64_t v15 = v231 + 1;
  }
  while (v231 != 4);
  if (!v16) {
    return 0;
  }
  if ((int)v16 <= 0)
  {
    float v65 = 0.0 / (float)(int)v16;
    float v70 = sqrtf(0.0 / (float)(v16 - 1));
  }
  else
  {
    uint64_t v58 = 0;
    double v59 = v237;
    double v60 = v235;
    float v61 = 0.0;
    do
    {
      float v62 = *(double *)&v266[v58] - v59;
      float v63 = *(double *)&v266[v58 + 2] - v60;
      float v61 = v61 + sqrtf((float)(v63 * v63) + (float)(v62 * v62));
      v58 += 4;
    }
    while (4 * (v239 + v243) != v58);
    uint64_t v64 = 0;
    float v65 = v61 / (float)(int)v16;
    float v66 = 0.0;
    do
    {
      float v67 = *(double *)&v266[v64] - v59;
      float v68 = *(double *)&v266[v64 + 2] - v60;
      float v69 = sqrtf((float)(v68 * v68) + (float)(v67 * v67)) - v65;
      float v66 = v66 + (float)(v69 * v69);
      v64 += 4;
    }
    while (4 * v16 != v64);
    float v70 = sqrtf(v66 / (float)(v16 - 1));
    if (v16 == 1) {
      float v70 = 0.0;
    }
  }
  double v71 = v65;
  float v72 = v65 * 6.28318531;
  uint64_t v73 = (uint64_t)rintf(v72);
  float v74 = v71 + v70 * 2.5;
  uint64_t v75 = (uint64_t)rintf(v74);
  initBitmap((uint64_t)v257, v73, v75 + 1, 1, 2, 100.0);
  int v228 = v75 + 1;
  initBitmap((uint64_t)&v259, v73, v75 + 1, 1, 2, 100.0);
  uint64_t v251 = v73;
  if ((int)v73 >= 1)
  {
    uint64_t v76 = 0;
    uint64_t v77 = 0;
    uint64_t v244 = (int)v260;
    uint64_t v78 = v259;
    int v220 = v75 - 1;
    uint64_t v248 = SHIDWORD(v260);
    uint64_t v232 = 2 * SHIDWORD(v260);
    uint64_t v79 = 2 * (int)v260;
    uint64_t v80 = 4 * (int)v260;
    uint64_t v81 = v79;
    int v224 = v75;
    do
    {
      float v82 = (double)(int)v77 / (double)(int)v251 * 6.28318531;
      __double2 v83 = __sincos_stret(v82);
      if ((v75 & 0x80000000) != 0)
      {
        int v99 = (_WORD *)(v78 + 2 * v77 * v248);
        int v93 = (unsigned __int16)*v99;
        unint64_t v94 = &v99[v244];
        *int v99 = (v93 - *v94) & ~(unsigned __int16)((v93 - (unsigned __int16)*v94) >> 31);
      }
      else
      {
        uint64_t v86 = *(void *)&v257[0];
        uint64_t v87 = v76;
        int v88 = v228;
        uint64_t v254 = v87;
        float v89 = v235;
        float v90 = v237;
        do
        {
          __int16 v91 = bilinearLookupAccurate(a1, v90, v89);
          *(_WORD *)(v78 + v87) = v91;
          *(_WORD *)(v86 + v87) = v91;
          float v84 = v83.__cosval;
          float v90 = v90 + v84;
          float v85 = v83.__sinval;
          float v89 = v89 + v85;
          v87 += v79;
          --v88;
        }
        while (v88);
        uint64_t v78 = v259;
        double v92 = (_WORD *)(v259 + 2 * v77 * v248);
        int v93 = (unsigned __int16)*v92;
        unint64_t v94 = &v92[v244];
        *double v92 = (v93 - *v94) & ~(unsigned __int16)((v93 - (unsigned __int16)*v94) >> 31);
        LODWORD(v75) = v224;
        if (v224 < 2)
        {
          uint64_t v76 = v254;
        }
        else
        {
          int v95 = v220;
          uint64_t v96 = v78;
          uint64_t v76 = v254;
          do
          {
            int v97 = v93 - *(unsigned __int16 *)(v96 + v80);
            int v93 = *(unsigned __int16 *)(v96 + v81);
            unsigned int v98 = (2 * v97) & ~((2 * v97) >> 31);
            if (v98 >= 0xFFFF) {
              LOWORD(v9_Block_object_dispose(&STACK[0x238], 8) = -1;
            }
            *(_WORD *)(v96 + v81) = v98;
            v96 += v79;
            --v95;
          }
          while (v95);
          unint64_t v94 = (_WORD *)(v96 + v81);
        }
      }
      *unint64_t v94 = (v93 - *v94) & ~(unsigned __int16)((v93 - (unsigned __int16)*v94) >> 31);
      ++v77;
      v76 += v232;
      v81 += v232;
      v80 += v232;
    }
    while (v77 != v251);
  }
  double v100 = (int *)zmalloc(168 * (int)v251);
  if (!v100)
  {
    termBitmap((void **)v257);
    termBitmap((void **)&v259);
    return v100;
  }
  v266[0] = 0.0;
  HIDWORD(v265) = 0;
  uint64_t v101 = DWORD2(v259);
  if (SDWORD2(v259) < 1)
  {
    uint64_t v145 = 0;
  }
  else
  {
    uint64_t v102 = 0;
    uint64_t v103 = 0;
    int v255 = 0;
    int v104 = HIDWORD(v259);
    double v105 = (double)SDWORD2(v259);
    uint64_t v229 = 4 * (int)v260;
    uint64_t v233 = (int)v260;
    uint64_t v106 = 2 * SHIDWORD(v260);
    uint64_t v107 = v100;
    int v108 = 2 - HIDWORD(v259);
    float v109 = v100 + 12;
    __asm { FMOV            V3.2D, #0.5 }
    unint64_t v213 = v107;
    uint64_t v221 = DWORD2(v259);
    uint64_t v225 = v106;
    int v219 = HIDWORD(v259);
    uint64_t v252 = 2 * (int)v260;
    float64x2_t v218 = _Q3;
    do
    {
      *uint64_t v107 = 0;
      float v114 = (double)(int)v103 / v105 * 6.28318531;
      __double2 v115 = __sincos_stret(v114);
      if (v104 >= 3)
      {
        uint64_t v240 = v109;
        uint64_t v245 = v103;
        LOBYTE(v116) = 0;
        float v117 = v115.__cosval;
        float v118 = v115.__sinval;
        uint64_t v119 = v259;
        uint64_t v120 = v259 + 2 * v233;
        uint64_t v121 = *(void *)&v257[0] + v229;
        uint64_t v122 = v259 + v229;
        int v123 = 1;
        uint64_t v249 = v102;
        uint64_t v124 = v252;
        do
        {
          unsigned int v125 = *(unsigned __int16 *)(v120 + v102);
          unsigned int v126 = *(unsigned __int16 *)(v122 + v102);
          unsigned int v127 = *(unsigned __int16 *)(v121 + v102);
          if (v116)
          {
            if (v125 == v126)
            {
              LOBYTE(v116) = 1;
            }
            else
            {
              if (v125 > v126)
              {
                v266[0] = (float)(v255 + v123) * 0.5;
                hopperInsert(v107, (float)v125, v266[0], (float)(v237 + (float)(v117 * v266[0])), (float)(v235 + (float)(v118 * v266[0])), (float)v127 * 0.000061275);
                uint64_t v124 = v252;
              }
              LOBYTE(v116) = 0;
            }
          }
          else
          {
            unsigned int v128 = *(unsigned __int16 *)(v119 + v102);
            if (v125 > v128 && v125 > v126)
            {
              if (maximumPointWithSamples(v266, (float *)&v265 + 1, (float)v128, (float)v125, (float)v126))
              {
                v266[0] = v266[0] + (float)(v123 - 1);
                hopperInsert(v107, *((float *)&v265 + 1), v266[0], (float)(v237 + (float)(v117 * v266[0])), (float)(v235 + (float)(v118 * v266[0])), (float)v127 * 0.000061275);
              }
              LOBYTE(v116) = 0;
              uint64_t v124 = v252;
            }
            else
            {
              BOOL v116 = v125 > v128 && v125 == v126;
              int v130 = v255;
              if (v116) {
                int v130 = v123;
              }
              int v255 = v130;
            }
          }
          v102 += v124;
          ++v123;
        }
        while (v108 + v123 != 1);
        int v131 = *v107;
        uint64_t v106 = v225;
        float v109 = v240;
        if (*v107 < 1)
        {
          uint64_t v101 = v221;
          uint64_t v103 = v245;
          uint64_t v102 = v249;
          int v104 = v219;
        }
        else
        {
          unsigned int v132 = 0;
          int v133 = v107 + 2;
          uint64_t v101 = v221;
          uint64_t v103 = v245;
          uint64_t v102 = v249;
          int v104 = v219;
          do
          {
            if (v131 >= 1)
            {
              uint64_t v134 = 0;
              float v135 = v240;
              float v136 = v107 + 2;
              int v137 = v131;
              do
              {
                if (v132 < v134)
                {
                  float v138 = *((float *)v133 + 1);
                  float v139 = *((float *)v136 + 1);
                  if (vabds_f32(v138, v139) < 2.6)
                  {
                    float v140 = (float)(v138 + v139) * 0.5;
                    *((float *)v133 + 1) = v140;
                    *(float *)int v133 = (float)(*(float *)v133 + *(float *)v136) * 0.5;
                    if (v140 <= *((float *)v136 + 1)) {
                      int v141 = v136;
                    }
                    else {
                      int v141 = v133;
                    }
                    v133[2] = v141[2];
                    *((float64x2_t *)v133 + 1) = vmulq_f64(vaddq_f64(*((float64x2_t *)v133 + 1), *((float64x2_t *)v136 + 1)), v218);
                    int v131 = v137 - 1;
                    if ((int)v134 + 1 < v137)
                    {
                      uint64_t v142 = (v137 - 1);
                      float v143 = v135;
                      do
                      {
                        long long v144 = *((_OWORD *)v143 + 1);
                        *(_OWORD *)(v143 - 10) = *(_OWORD *)v143;
                        *(_OWORD *)(v143 - 6) = v144;
                        *((void *)v143 - 1) = *((void *)v143 + 4);
                        v143 += 10;
                        --v142;
                      }
                      while (v134 != v142);
                    }
                    *uint64_t v107 = v131;
                    int v137 = v131;
                  }
                }
                ++v134;
                v136 += 10;
                v135 += 10;
              }
              while (v137 > (int)v134);
            }
            ++v132;
            v133 += 10;
          }
          while ((int)v132 < v131);
        }
      }
      ++v103;
      v107 += 42;
      v102 += v106;
      v109 += 42;
    }
    while (v103 != v101);
    LODWORD(v145) = 0;
    double v100 = v213;
    uint64_t v146 = v213;
    do
    {
      int v147 = *v146;
      v146 += 42;
      uint64_t v145 = (v147 + v145);
      LODWORD(v101) = v101 - 1;
    }
    while (v101);
  }
  termBitmap((void **)v257);
  termBitmap((void **)&v259);
  int v149 = computeOutlineByTracingSnake((uint64_t)v100, v251, v145, (uint64_t)&v262, (uint64_t)&v263, v148);
  zfree(v100);
  if (!v149) {
    return 0;
  }
  int v150 = v263;
  int v151 = v262;
  if (v263 < 1)
  {
    float v158 = 0.0;
    float v157 = 0.0;
    float v156 = 0.0;
    float v155 = 0.0;
    float v154 = 0.0;
  }
  else
  {
    int v152 = 0;
    int v153 = (double *)(v262 + 8);
    float v154 = 0.0;
    float v155 = 0.0;
    float v156 = 0.0;
    float v157 = 0.0;
    float v158 = 0.0;
    do
    {
      double v159 = *(v153 - 1);
      if (v152)
      {
        if (v159 > v155) {
          float v160 = v159;
        }
        else {
          float v160 = v155;
        }
        if (v159 >= v157) {
          float v155 = v160;
        }
        else {
          float v157 = v159;
        }
        if (*v153 > v154) {
          float v161 = *v153;
        }
        else {
          float v161 = v154;
        }
        if (*v153 >= v156) {
          float v154 = v161;
        }
        else {
          float v156 = *v153;
        }
      }
      else
      {
        float v157 = v159;
        float v156 = *v153;
        float v155 = v157;
        float v154 = v156;
      }
      float v158 = v158 + *((float *)v153 + 2);
      ++v152;
      v153 += 6;
    }
    while (v263 != v152);
  }
  float v246 = v156;
  float v241 = v157;
  float v162 = (float)(1.0 / (float)v263) * v158;
  double v163 = v162;
  if (v162 <= 4.0) {
    float v164 = v162;
  }
  else {
    float v164 = 4.0;
  }
  if (v162 > 3.0) {
    float v162 = 3.0;
  }
  double v165 = v163 * 0.5;
  if (v165 < v162) {
    float v162 = v165;
  }
  float v226 = v162;
  if (v263 >= 1)
  {
    float v166 = -v162;
    __double2 v167 = (double *)v262;
    do
    {
      float v168 = *v167;
      float v169 = v167[1];
      float v170 = v168 - v237;
      float v171 = v169 - v235;
      float v172 = (float)(v171 * v171) + (float)(v170 * v170);
      if (v172 > 0.0)
      {
        float v173 = 1.0 / sqrt(v172);
        float v170 = v170 * v173;
        float v171 = v171 * v173;
      }
      float v174 = *v167;
      *((float *)v167 + 6) = (float)(int)bilinearLookup(a1, v174, v169);
      *((float *)v167 + 9) = (float)(int)bilinearLookup(a1, v168 + (float)(v164 * v170), v169 + (float)(v164 * v171));
      *((float *)v167 + _Block_object_dispose(&STACK[0x238], 8) = (float)(int)bilinearLookup(a1, v168 + (float)(v166 * v170), v169 + (float)(v166 * v171));
      v167 += 6;
      --v150;
    }
    while (v150);
  }
  unsigned int v175 = vcvtms_s32_f32(v164 + v154);
  unsigned int v176 = vcvtms_s32_f32(v164 + v155);
  signed int v178 = *(_DWORD *)(a1 + 8);
  signed int v177 = *(_DWORD *)(a1 + 12);
  if ((int)(v175 + 1) < v177) {
    unsigned int v179 = v175 + 1;
  }
  else {
    unsigned int v179 = v177 - 1;
  }
  int v256 = v179;
  unsigned int v180 = v178 - 1;
  if ((int)(v176 + 1) < v178) {
    unsigned int v180 = v176 + 1;
  }
  signed int v253 = v180;
  uint64_t v250 = *(int *)(a1 + 16);
  uint64_t v181 = *(int *)(a1 + 28);
  float v182 = (int *)zmalloc(0x28uLL);
  double v100 = v182;
  if (!v182)
  {
    zfree(v151);
    return v100;
  }
  initBitmap((uint64_t)v182, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), 1, 1, 100.0);
  if (!*(void *)v100)
  {
    zfree(v151);
    zfree(v100);
    return 0;
  }
  int v183 = vcvtms_s32_f32(v246 - v164);
  int v184 = v183 & ~(v183 >> 31);
  bzero(*(void **)v100, v100[6]);
  if (v184 < v256)
  {
    int v185 = vcvtms_s32_f32(v241 - v164);
    int v186 = v185 & ~(v185 >> 31);
    uint64_t v242 = v100[4];
    uint64_t v187 = *(void *)v100 + (int)v242 * (uint64_t)v184;
    uint64_t v188 = *(void *)a1 + (int)v250 * (uint64_t)v184;
    int v222 = v100;
    uint64_t v189 = v100[7];
    uint64_t v236 = (int)v189 * (uint64_t)v186;
    uint64_t v238 = (int)v181 * (uint64_t)v186;
    int v234 = v253 - v186;
    int v247 = v186;
    int v230 = v186 - v216;
    do
    {
      if (v253 > v247)
      {
        float v190 = (float)(v184 - HIDWORD(v216));
        float v191 = v190 * v190;
        long double v192 = v190;
        int v193 = v230;
        int v194 = v234;
        uint64_t v196 = v236;
        uint64_t v195 = v238;
        do
        {
          float v197 = sqrtf(v191 + (float)((float)v193 * (float)v193));
          long double v198 = atan2(v192, (float)v193);
          LOBYTE(v199) = 0;
          float v200 = v198 * (float)(int)v251 / 6.28318531;
          int v201 = vcvtms_s32_f32(v200);
          int v202 = (v251 & (v201 >> 31)) + v201;
          if (v202 + 1 == v251) {
            int v203 = 0;
          }
          else {
            int v203 = v202 + 1;
          }
          double v204 = (float *)&v262[48 * v202];
          double v205 = (float *)&v262[48 * v203];
          float v206 = v200 - (float)(int)floorf(v200);
          float v207 = v204[4] + (float)((float)(v205[4] - v204[4]) * v206);
          if (v197 <= (float)(v164 + v207))
          {
            if (v197 >= (float)(v207 - v226))
            {
              float v208 = v204[8];
              float v209 = v204[9] + (float)((float)(v205[9] - v204[9]) * v206);
              float v210 = v208 + (float)((float)(v205[8] - v208) * v206);
              if (v209 >= v210)
              {
                LOBYTE(v199) = 0x80;
              }
              else
              {
                LOBYTE(v20_Block_object_dispose(&STACK[0x238], 8) = *(unsigned char *)(v188 + v195);
                int v211 = 2 * (uint64_t)rintf((float)((float)((float)LODWORD(v208) - v209) * 255.0) / (float)(v210 - v209));
                if (v211 >= 255) {
                  int v211 = 255;
                }
                int v199 = v211 & ~(v211 >> 31);
              }
            }
            else
            {
              LOBYTE(v199) = -1;
            }
          }
          *(unsigned char *)(v187 + v196) = v199;
          v196 += v189;
          v195 += v181;
          ++v193;
          --v194;
        }
        while (v194);
      }
      ++v184;
      v188 += v250;
      v187 += v242;
    }
    while (v184 != v256);
    int v151 = v262;
    double v100 = v222;
  }
  zfree(v151);
  *unint64_t v214 = v216;
  *int v215 = HIDWORD(v216);
  return v100;
}

uint64_t computeOutlineByTracingSnake(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6 = MEMORY[0x1F4188790](a1, a2, a3, a4, a5, a6);
  float v154 = v7;
  unint64_t v9 = v8;
  int v11 = v10;
  int v13 = v12;
  uint64_t v14 = v6;
  *(void *)&v191[4788] = *MEMORY[0x1E4F143B8];
  long long v185 = 0u;
  memset(v186, 0, 496);
  int v184 = 0;
  memset(v183, 0, sizeof(v183));
  uint64_t result = (uint64_t)zmalloc(48 * v10);
  if (!result) {
    return result;
  }
  uint64_t v16 = (char *)result;
  int v153 = v9;
  uint64_t v17 = 0;
  uint64_t v18 = v11;
  LODWORD(v19) = 0;
  uint64_t v179 = v18;
  unsigned int v180 = (char *)result;
  float v164 = (unsigned char *)(v14 + 40);
  uint64_t v161 = v14 + 24;
  uint64_t v162 = v14;
  uint64_t v20 = v13;
  int v163 = v13;
  uint64_t v155 = v13;
  while (1)
  {
    int v173 = v13 - 1;
    if (v13 < 1) {
      break;
    }
    uint64_t v21 = 0;
    double v22 = v164;
    while (1)
    {
      uint64_t v23 = *(unsigned int *)(v14 + 168 * v21);
      float v24 = v22;
      if ((int)v23 >= 1) {
        break;
      }
LABEL_8:
      ++v21;
      v22 += 168;
      if (v21 == v20) {
        goto LABEL_43;
      }
    }
    while ((*v24 & 1) != 0)
    {
      v24 += 40;
      if (!--v23) {
        goto LABEL_8;
      }
    }
    int v25 = 0;
    uint64_t v26 = (uint64_t)(v24 - 32);
    float v27 = &v189[16 * v17];
    *(_DWORD *)float v27 = v19;
    double v159 = (float *)(v27 + 12);
    uint64_t v160 = v17 + 1;
    v27[8] = 0;
    float v157 = v27 + 8;
    float v158 = v27 + 4;
    float v28 = (float32x2_t *)&v16[48 * (int)v19];
    uint64_t v19 = (int)v19;
    float v29 = -1.0;
    float v30 = 0.0;
    int v156 = v19;
    int v31 = v21;
    while (1)
    {
      double v32 = (int32x2_t *)&v16[48 * v19];
      *(_OWORD *)v32->i8 = *(_OWORD *)(v26 + 16);
      int32x2_t v33 = *(int32x2_t *)v26;
      v32[2] = vrev64_s32(*(int32x2_t *)v26);
      v32[3].i32[0] = *(_DWORD *)(v26 + 8);
      *(float *)&v32[3].i32[1] = v29;
      v32[5].i32[0] = v31;
      ++v19;
      *(_DWORD *)(v26 + 32) |= 1u;
      ++v25;
      float v30 = *(float *)v33.i32 + v30;
      int v34 = v31 + 1 == v13 ? 0 : v31 + 1;
      if (v34 == v21) {
        break;
      }
      if (v34 + 1 == v13) {
        int v35 = 0;
      }
      else {
        int v35 = v34 + 1;
      }
      LODWORD(v183[0]) = 0;
      int v36 = *(_DWORD *)(v14 + 168 * v34);
      if (v36 < 1) {
        goto LABEL_39;
      }
      int v169 = v25;
      uint64_t v171 = v19;
      int v37 = 0;
      int v38 = v35;
      uint64_t v181 = (int *)(v14 + 168 * v35);
      int v165 = v34;
      int v167 = v34;
      uint64_t v39 = (float32x2_t *)(v14 + 168 * v34 + 8);
      float v174 = (double *)(v161 + 168 * v35);
      unsigned int v176 = (float32x2_t *)&v164[168 * v35];
      do
      {
        if ((v39[4].i8[0] & 1) == 0)
        {
          float v40 = energyFunction1((float32x2_t *)v26, v39);
          int v41 = *v181;
          if (v38 == v21)
          {
            if (v41 >= 1)
            {
              float v42 = v174;
              float v43 = v28[2].f32[0];
              do
              {
                if (*((float *)v42 - 3) == v43
                  && *v42 == *(double *)v28
                  && v42[1] == *(double *)&v28[1]
                  && *((float *)v42 - 4) == v28[2].f32[1])
                {
                  float v44 = energyFunction1(v39, (float32x2_t *)v42 - 2);
                  float v45 = energyFunction1((float32x2_t *)v26, (float32x2_t *)v42 - 2);
                  minEnergyHopperInsert((int *)v183, v37, (float)(v40 + v44) + v45);
                }
                v42 += 5;
                --v41;
              }
              while (v41);
            }
          }
          else if (v41 >= 1)
          {
            unsigned int v46 = v176;
            int v47 = v176;
            do
            {
              char v48 = v47->i8[0];
              v47 += 5;
              if ((v48 & 1) == 0)
              {
                unsigned __int16 v49 = v46 - 4;
                float v50 = energyFunction1(v39, v46 - 4);
                float v51 = energyFunction1((float32x2_t *)v26, v49);
                minEnergyHopperInsert((int *)v183, v37, (float)(v40 + v50) + v51);
              }
              unsigned int v46 = v47;
              --v41;
            }
            while (v41);
          }
        }
        ++v37;
        v39 += 5;
      }
      while (v37 != v36);
      int v13 = v163;
      uint64_t v16 = v180;
      uint64_t v14 = v162;
      uint64_t v19 = v171;
      int v25 = v169;
      int v31 = v167;
      if (!LODWORD(v183[0]))
      {
LABEL_39:
        *float v158 = v25;
        *double v159 = v30;
        goto LABEL_41;
      }
      uint64_t v26 = v162 + 168 * v165 + 40 * SDWORD2(v183[0]) + 8;
      float v29 = *((float *)v183 + 1);
    }
    *float v158 = v25;
    *double v159 = v30;
    *float v157 = 1;
    float v52 = (float32x2_t *)&v16[48 * v156];
    float v53 = energyFunction2((float32x2_t *)v32, v28);
    float v54 = energyFunction2(v28, v52 + 6);
    v52[3].f32[1] = (float)(v53 + v54) + energyFunction2((float32x2_t *)v32, v52 + 6);
LABEL_41:
    uint64_t v17 = v160;
    uint64_t v20 = v155;
    if (v160 == 300) {
      goto LABEL_44;
    }
  }
LABEL_43:
  if (!v17) {
    goto LABEL_131;
  }
LABEL_44:
  int v55 = 0;
  float v56 = (float *)v191;
  int v57 = -1;
  float v58 = 0.0;
  do
  {
    if (*((unsigned char *)v56 - 4) && *v56 > v58)
    {
      int v57 = v55;
      float v58 = *v56;
    }
    v56 += 4;
    ++v55;
  }
  while (v17 != v55);
  if (v57 != -1)
  {
    uint64_t v59 = *(int *)&v189[16 * v57];
    if (v13 >= 1)
    {
      uint64_t v60 = 48 * (int)v59 + 28;
      float v61 = 0.0;
      uint64_t v62 = *(int *)&v189[16 * v57];
      do
      {
        if (*(float *)&v16[v60] > v61) {
          float v61 = *(float *)&v16[v60];
        }
        ++v62;
        v60 += 48;
      }
      while (v62 < v59 + v13);
      if (v61 > 1.5) {
        goto LABEL_131;
      }
    }
    if (*(_DWORD *)&v189[16 * v57 + 4] != v13) {
      puts("incorrect number of points");
    }
    float v63 = zmalloc(48 * v13);
    memmove(v63, &v16[48 * (int)v59], 48 * v13);
    zfree(v16);
    *int v153 = v63;
    *float v154 = v13;
    return 1;
  }
  int v64 = 0;
  int v188 = 0;
  memset(v187, 0, sizeof(v187));
  LODWORD(v187[0]) = 0;
  float v65 = (int *)v189;
  int v178 = v17;
  do
  {
    int v166 = v64 + 1;
    if (v64 + 1 < v17)
    {
      float v66 = &v16[48 * *v65];
      float v168 = v66 + 40;
      float v170 = v66;
      float v67 = v65;
      int v68 = v64 + 1;
      float v69 = v65;
      float v172 = v65;
      do
      {
        int v70 = v69[4];
        v69 += 4;
        double v71 = &v66[48 * v65[1]];
        float v72 = (float32x2_t *)&v16[48 * v70];
        int v73 = v72[5].i32[0];
        uint64_t v74 = *((int *)v71 - 2);
        if (v73 <= (int)v74 + 1)
        {
          int v75 = v67[5];
          if (v72[6 * v75 - 1].i32[0] >= (int)v74)
          {
            __int32 v175 = v72[6 * v75 - 1].i32[0];
            signed int v177 = v69;
            int v182 = v72[5].i32[0];
            if (v75 < 1)
            {
              float v80 = *(float *)"(knN";
            }
            else
            {
              uint64_t v76 = v71 - 48;
              uint64_t v77 = v73;
              int v78 = ~v74;
              uint64_t v79 = v75 + v73;
              float v80 = *(float *)"(knN";
              do
              {
                if (checkPointAddress((unint64_t)&v76[48 * v78 + 48 * (int)v77], (unint64_t)v180, v179)
                  && checkPointAddress((unint64_t)v72, (unint64_t)v180, v179))
                {
                  float v81 = energyFunction2((float32x2_t *)&v76[48 * v78 + 48 * (int)v77], v72);
                  if (v81 < v80)
                  {
                    int v182 = v77;
                    float v80 = v81;
                  }
                }
                if (v77 > v74) {
                  break;
                }
                ++v77;
                v72 += 6;
              }
              while (v77 < v79);
            }
            snakeHopperInsert((int *)v187, v64, v68, v182, v175 - *v168 + 1, v80);
            uint64_t v16 = v180;
            float v69 = v177;
            LODWORD(v17) = v178;
            float v66 = v170;
            float v65 = v172;
          }
        }
        ++v68;
        float v67 = v69;
      }
      while (v68 != v17);
    }
    v65 += 4;
    ++v64;
  }
  while (v166 != v17);
  int v82 = 0;
  __double2 v83 = (int *)v189;
  do
  {
    int v84 = 0;
    float v85 = &v16[48 * *v83];
    uint64_t v86 = &v190;
    do
    {
      int v87 = v83[1];
      int v88 = &v85[48 * v87];
      if (*((_DWORD *)v88 - 2) == v173)
      {
        int v89 = *(v86 - 1);
        if (!*(_DWORD *)&v180[48 * v89 + 40])
        {
          float v90 = (float32x2_t *)&v180[48 * v89];
          float v91 = energyFunction2((float32x2_t *)v88 - 6, v90);
          __int32 v92 = v90[6 * *v86 - 1].i32[0];
          __int32 v93 = *((_DWORD *)v85 + 10);
          if (v92 >= v93) {
            __int32 v94 = v93 + ~v92;
          }
          else {
            __int32 v94 = 0;
          }
          snakeHopperInsert((int *)v187, v82, v84, 0, *v86 + v87 + v94, v91);
          LODWORD(v17) = v178;
        }
      }
      ++v84;
      v86 += 4;
    }
    while (v17 != v84);
    ++v82;
    v83 += 4;
    uint64_t v16 = v180;
  }
  while (v82 != v17);
  int v95 = v187[0];
  if (SLODWORD(v187[0]) < 1) {
    goto LABEL_131;
  }
  uint64_t v96 = (int *)((unint64_t)v187 | 0xC);
  int v97 = v187[0];
  do
  {
    if (v96[2] == v163)
    {
      uint64_t v124 = *(v96 - 1);
      uint64_t v125 = *v96;
      printf("winning snake = connection of snakes %d and %d\n", *(v96 - 1), *v96);
      unsigned int v126 = (int *)&v189[16 * v124];
      int v127 = *(_DWORD *)&v189[16 * v125];
      if (*(_DWORD *)&v180[48 * v127 + 40])
      {
        int v127 = *v126;
        if (*(_DWORD *)&v180[48 * *v126 + 40]) {
          goto LABEL_130;
        }
        unsigned int v128 = v126;
        unsigned int v126 = (int *)&v189[16 * v125];
      }
      else
      {
        unsigned int v128 = (int *)&v189[16 * v125];
      }
      uint64_t v129 = (uint64_t)&v180[48 * v127 + 48 * v128[1]];
      int v130 = &v180[48 * *v126];
      int v131 = *(_DWORD *)(v129 - 8);
      int v132 = *((_DWORD *)v130 + 10);
      if (v131 <= v132 + 1)
      {
        uint64_t v134 = (float32x2_t *)(v129 - 48);
        int v135 = v131 - 1;
        int v136 = -v132;
        int v133 = -1000;
        float v137 = *(float *)"(knN";
        do
        {
          int v138 = v135 + 1;
          float v139 = energyFunction2((float32x2_t *)&v130[48 * v136 + 48 * v135], v134);
          if (v139 < v137)
          {
            int v133 = v135 + 1;
            float v137 = v139;
          }
          v134 += 6;
          ++v135;
        }
        while (v136 + v138 != 1);
      }
      else
      {
        int v133 = -1000;
      }
      int v140 = v163;
      int v141 = (char *)zmalloc(48 * v163);
      memmove(v141, &v180[48 * *v128], 48 * v133);
      uint64_t v142 = &v141[48 * v133];
      float v143 = &v180[48 * *v126];
      size_t v144 = 48 * (v163 - v133);
LABEL_142:
      memmove(v142, v143, v144);
      zfree(v180);
      *int v153 = v141;
      *float v154 = v140;
      return 1;
    }
    v96 += 5;
    --v97;
  }
  while (v97);
  LODWORD(v185) = 0;
  int v98 = 0;
  int v99 = (char *)v187 + 4;
  do
  {
    int v100 = 0;
    uint64_t v101 = (char *)v187 + 4;
    do
    {
      if (v100 == v98) {
        goto LABEL_121;
      }
      int v103 = *((_DWORD *)v99 + 1);
      int v102 = *((_DWORD *)v99 + 2);
      int v104 = *((_DWORD *)v101 + 1);
      if (v102 == v104)
      {
        double v105 = v99;
        int v104 = *((_DWORD *)v99 + 1);
        int v103 = *((_DWORD *)v99 + 2);
        int v102 = *((_DWORD *)v101 + 2);
      }
      else
      {
        double v105 = v101;
        if (v103 != *((_DWORD *)v101 + 2)) {
          goto LABEL_121;
        }
      }
      int v106 = *((_DWORD *)v105 + 4);
      uint64_t v107 = (int *)&v189[16 * v102];
      int v108 = *(_DWORD *)&v180[48 * *(int *)&v189[16 * v103] - 8 + 48 * *(int *)&v189[16 * v103 + 4]];
      int v109 = v107[1];
      int v110 = *(_DWORD *)&v180[48 * *v107 + 40];
      if (v110) {
        BOOL v111 = 0;
      }
      else {
        BOOL v111 = v108 == v173;
      }
      int v112 = v110 + ~v108;
      if (v111) {
        int v112 = 0;
      }
      float v113 = *(float *)v99 + *(float *)v101;
      int v114 = v185;
      if ((int)v185 < 1)
      {
        LODWORD(v115) = 0;
LABEL_117:
        int v119 = v112 + v106 + v109;
        uint64_t v120 = (float *)&v186[-1] + 7 * v115;
        v120[1] = v113;
        *((_DWORD *)v120 + 2) = v104;
        *((_DWORD *)v120 + 3) = v103;
        *((_DWORD *)v120 + 4) = v102;
        *((_DWORD *)v120 + 7) = v119;
        if (v114 < 20) {
          int v121 = v114 + 1;
        }
        else {
          int v121 = 20;
        }
        LODWORD(v185) = v121;
        goto LABEL_121;
      }
      unint64_t v115 = 0;
      uint64_t v116 = (int)v185;
      uint64_t v117 = 4;
      while (*(float *)((char *)&v186[-1] + v117) <= v113)
      {
        ++v115;
        v117 += 28;
        if (v185 == v115)
        {
          unint64_t v115 = v185;
          goto LABEL_115;
        }
      }
      if ((int)v185 > (int)v115)
      {
        float v118 = (long long *)((char *)&v185 + 28 * (int)v185 + 4);
        do
        {
          if (v116 <= 19)
          {
            *float v118 = *(_OWORD *)((char *)v118 - 28);
            *(_OWORD *)((char *)v118 + 12) = *(v118 - 1);
          }
          --v116;
          float v118 = (_OWORD *)((char *)v118 - 28);
        }
        while (v116 > (uint64_t)v115);
      }
      unint64_t v115 = v115;
LABEL_115:
      if (v115 <= 0x13)
      {
        int v114 = v185;
        goto LABEL_117;
      }
LABEL_121:
      ++v100;
      v101 += 20;
    }
    while (v100 != v95);
    ++v98;
    v99 += 20;
  }
  while (v98 != v95);
  int v122 = v185;
  if ((int)v185 >= 1)
  {
    int v123 = (int *)v186;
    while (v123[3] < v163)
    {
      v123 += 7;
      if (!--v122) {
        goto LABEL_131;
      }
    }
    uint64_t v145 = *v123;
    uint64_t v146 = (int *)&v189[16 * *(v123 - 2)];
    int v147 = (int *)&v189[16 * *(v123 - 1)];
    uint64_t v148 = (int *)&v189[16 * v145];
    if (!*(_DWORD *)&v180[48 * *v148 + 40])
    {
      int v149 = (int *)&v189[16 * v145];
      int v150 = v146;
      uint64_t v148 = v147;
      goto LABEL_149;
    }
    if (!*(_DWORD *)&v180[48 * *v147 + 40])
    {
      int v149 = v147;
      int v150 = (int *)&v189[16 * v145];
      uint64_t v148 = v146;
      goto LABEL_149;
    }
    int v149 = v146;
    int v150 = v147;
    if (!*(_DWORD *)&v180[48 * *v146 + 40])
    {
LABEL_149:
      uint64_t v151 = *(int *)&v180[48 * *v150 + 40];
      uint64_t v152 = *(int *)&v180[48 * *v148 + 40];
      int v140 = v163;
      int v141 = (char *)zmalloc(48 * v163);
      memmove(v141, &v180[48 * *v149], 48 * v151);
      memmove(&v141[48 * v151], &v180[48 * *v150], 48 * (v152 - v151));
      uint64_t v142 = &v141[48 * (int)v152];
      float v143 = &v180[48 * *v148];
      size_t v144 = 48 * v148[1];
      goto LABEL_142;
    }
LABEL_130:
    puts("error - impossible connect arrangement");
  }
LABEL_131:
  zfree(v16);
  return 0;
}

uint64_t computeBorderForAlpha(uint64_t result, uint64_t a2, unsigned char *a3, int *a4)
{
  int v4 = *(_DWORD *)(a2 + 12);
  if (v4 < 3)
  {
    int v5 = 0;
  }
  else
  {
    int v5 = 0;
    uint64_t v6 = *(int *)(a2 + 16);
    uint64_t v7 = *(int *)(result + 16);
    uint64_t v8 = *(int *)(result + 28);
    unint64_t v9 = *(unsigned char **)a2;
    uint64_t v65 = (int)v8 - (int)v7;
    uint64_t v66 = -(int)v7 - (int)v8;
    uint64_t v62 = (int)v8 + (int)v7;
    uint64_t v63 = v8;
    uint64_t v10 = *(int *)(a2 + 28);
    int v11 = *(_DWORD *)(a2 + 8);
    uint64_t v12 = v6 + v10;
    uint64_t v13 = v6 + v10 + (int)v10 - (int)v6;
    int v67 = v4 - 2;
    int v61 = v11 - 2;
    uint64_t v14 = v6 + 2 * v10;
    uint64_t v15 = 2 * v6;
    uint64_t v64 = v7;
    uint64_t v59 = v7 - v8;
    uint64_t v60 = -v8;
    uint64_t v16 = v10 + 2 * v6;
    int v54 = v11;
    int v17 = 2 - v11;
    int v68 = 1;
    uint64_t v69 = v6 + v10 + (int)v10 + (int)v6;
    uint64_t v57 = v10;
    uint64_t v58 = v6 + v10;
    int v56 = 2 - v11;
    uint64_t v18 = -v7;
    do
    {
      int v55 = v9;
      if (v54 >= 3)
      {
        int v19 = 1;
        uint64_t v20 = v9;
        do
        {
          uint64_t v21 = &v20[v10];
          if (v20[v12])
          {
            int v22 = v20[v6];
            int v23 = v20[v14];
            int v24 = v20[v16];
            BOOL v25 = !*v21 || v22 == 0;
            BOOL v26 = v25 || v23 == 0;
            if (v26 || v24 == 0)
            {
              int v28 = v20[v6 - (int)v6];
              int v29 = v20[v13];
              int v30 = v20[v15];
              int v31 = v20[v69];
              int v32 = v29 - (v28 + v30) + 2 * (v23 - v22) + v31;
              int v33 = v30 - (v29 + v28) + v31 + 2 * (v24 - *v21);
              int v34 = v32 * v32 + v33 * v33;
              if (v34)
              {
                if (v5 <= 399)
                {
                  float v35 = 1.0 / sqrtf((float)v34);
                  float v36 = v35 * (float)v33;
                  int v37 = v67;
                  int v38 = v68 - (uint64_t)rintf(v36 * 3.0);
                  if (v38 <= 1) {
                    int v38 = 1;
                  }
                  if (v38 >= v67) {
                    int v39 = v67;
                  }
                  else {
                    int v39 = v38;
                  }
                  float v40 = v35 * (float)v32;
                  int v41 = v19 - (uint64_t)rintf(v40 * 3.0);
                  if (v41 <= 1) {
                    int v41 = 1;
                  }
                  if (v41 >= v61) {
                    int v42 = v61;
                  }
                  else {
                    int v42 = v41;
                  }
                  int v43 = v68 + (uint64_t)rintf(v36 + v36);
                  if (v43 <= 1) {
                    int v43 = 1;
                  }
                  if (v43 < v67) {
                    int v37 = v43;
                  }
                  int v44 = v19 + (uint64_t)rintf(v40 + v40);
                  if (v44 <= 1) {
                    int v44 = 1;
                  }
                  if (v44 >= v61) {
                    int v45 = v61;
                  }
                  else {
                    int v45 = v44;
                  }
                  unsigned int v46 = (unsigned __int8 *)(*(void *)result + v39 * (int)v64 + v42 * (int)v63);
                  uint64_t v47 = v15;
                  char v48 = (unsigned __int8 *)(*(void *)result + v37 * (int)v64 + v45 * (int)v63);
                  LODWORD(v46) = (v46[v66]
                                + 4 * *v46
                                + 2 * (v46[v60] + v46[v18] + v46[v63] + v46[v64])
                                + v46[v65]
                                + v46[v59]
                                + v46[v62]
                                + 8) >> 4;
                  int v17 = v56;
                  int v49 = v48[v65];
                  int v50 = v48[v59];
                  int v51 = v48[v62];
                  LODWORD(v4_Block_object_dispose(&STACK[0x238], 8) = v48[v66] + 4 * *v48 + 2 * (v48[v60] + v48[v18] + v48[v63] + v48[v64]);
                  int v52 = v49 + v50 + v51;
                  uint64_t v15 = v47;
                  uint64_t v10 = v57;
                  uint64_t v12 = v58;
                  *a3 = v19;
                  a3[1] = v68;
                  a3[2] = v45;
                  a3[3] = v37;
                  a3[4] = v42;
                  a3[5] = v39;
                  a3[6] = (v48 + v52 + 8) >> 4;
                  a3[7] = (_BYTE)v46;
                  a3 += 8;
                  ++v5;
                }
              }
            }
          }
          ++v19;
          uint64_t v20 = v21;
        }
        while (v17 + v19 != 1);
      }
      unint64_t v9 = &v55[v6];
      BOOL v25 = v68++ == v67;
    }
    while (!v25);
  }
  *a4 = v5;
  return result;
}

uint64_t buildTransferTable(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = 0;
  int v6 = -((HIDWORD(a3) - a3) * result);
  int v7 = -((240 - HIDWORD(a3)) * HIDWORD(result));
  do
  {
    char v8 = a3;
    if (v5 >= (int)result)
    {
      if (v5 >= result >> 32)
      {
        if ((unint64_t)v5 >= 0xF0) {
          char v8 = v5;
        }
        else {
          char v8 = (uint64_t)rintf((float)v7 / (float)(240 - HIDWORD(result))) + BYTE4(a3);
        }
      }
      else
      {
        char v8 = (uint64_t)rintf((float)v6 / (float)(HIDWORD(result) - result)) + a3;
      }
    }
    *(unsigned char *)(a5 + v5++) = v8;
    v6 += HIDWORD(a3) - a3;
    v7 += 240 - HIDWORD(a3);
  }
  while (v5 != 256);
  return result;
}

void examineAlpha(unsigned __int8 **a1, unsigned __int8 **a2, char **a3, _DWORD *a4, float *a5, float *a6, _DWORD *a7, float *a8)
{
  uint64_t v138 = *MEMORY[0x1E4F143B8];
  if (*((_DWORD *)a1 + 7) != 1 || (*((_DWORD *)a3 + 7) == 1 ? (BOOL v10 = *((_DWORD *)a2 + 7) == 2) : (BOOL v10 = 0), !v10))
  {
    int v11 = "examineAlpha: bitmaps are the wrong number of samples per pixel";
LABEL_129:
    puts(v11);
    return;
  }
  int v13 = *((_DWORD *)a1 + 2);
  if (v13 != *((_DWORD *)a3 + 2)
    || (int v131 = *((_DWORD *)a1 + 3), v131 != *((_DWORD *)a3 + 3))
    || (uint64_t v130 = *((int *)a1 + 4), v130 != *((_DWORD *)a3 + 4))
    || v13 != 2 * *((_DWORD *)a2 + 2)
    || v131 != 2 * *((_DWORD *)a2 + 3))
  {
    int v11 = "examineAlpha: bitmaps don't match";
    goto LABEL_129;
  }
  int v14 = *((_DWORD *)a2 + 4);
  bzero(v137, 0x400uLL);
  int v135 = 0;
  int32x4_t v15 = 0uLL;
  memset(v134, 0, sizeof(v134));
  memset(v136, 0, sizeof(v136));
  int v16 = 0;
  if (v131 >= 1)
  {
    int v17 = 0;
    uint64_t v18 = *a2;
    int v19 = *a3;
    int v128 = v13;
    int v129 = -v14;
    int v20 = v13 - 2;
    uint64_t v21 = *a1;
    int v127 = v14;
    do
    {
      if (v17 == v131 - 1) {
        int v22 = 0;
      }
      else {
        int v22 = v14;
      }
      if (v17) {
        int v23 = v129;
      }
      else {
        int v23 = 0;
      }
      if ((v17 & 1) == 0) {
        int v22 = v23;
      }
      int v24 = &v18[v22];
      int v25 = *v18;
      int v26 = v18[1];
      int v27 = *v24;
      int v28 = v24[1];
      int v132 = v17;
      int v133 = v17 & 1;
      if (v13 < 3)
      {
        int v33 = *v18;
        int v32 = v18[1];
        int v31 = *v24;
        int v30 = v24[1];
        uint64_t v59 = v21;
        int v61 = v19;
        uint64_t v60 = v18;
      }
      else
      {
        uint64_t v29 = 0;
        int v30 = v24[1];
        int v31 = *v24;
        int v32 = v18[1];
        int v33 = *v18;
        do
        {
          int v34 = v27 + v33;
          int v33 = v25;
          int v35 = v21[v29];
          unsigned int v36 = (9 * v26 + v30 + 3 * (v28 + v32) + 8) >> 4;
          unsigned int v37 = ((9 * v25 + v31 + 3 * v34 + 8) >> 4) - 128;
          v36 -= 128;
          int v38 = v35 + ((int)(22970 * v36 + 0x2000) >> 14);
          int v39 = v35 + ((int)(-11700 * v36 - 5638 * v37 + 0x2000) >> 14);
          int v40 = v35 + ((int)(29032 * v37 + 0x2000) >> 14);
          if (v38 >= 255) {
            int v38 = 255;
          }
          if (v39 >= 255) {
            int v39 = 255;
          }
          if (v40 >= 255) {
            int v40 = 255;
          }
          if (v19[v29] < 0)
          {
            unsigned int v41 = v39 & ~(v39 >> 31);
            int v42 = v40 & ~(v40 >> 31);
            if (v41 >= v42)
            {
              int v43 = (v38 & ~(v38 >> 31)) - v42;
              if (v43 >= 1)
              {
                int v44 = ((int)((v41 - v42) << 6) / (int)(v43 + v41 - v42) + 2) >> 2;
                if (v44 >= 8) {
                  int v44 = 8;
                }
                ++*((_DWORD *)v134 + v44);
              }
            }
            else
            {
              ++LODWORD(v134[0]);
            }
            if (v42 < (int)v41) {
              unsigned int v41 = v42;
            }
            ++v137[v41];
            ++*((_DWORD *)v136 + (v41 >> 5));
            ++v16;
          }
          int v45 = v21[v29 + 1];
          int v32 = v18[v29 + 1];
          int v25 = v18[v29 + 2];
          int v26 = v18[v29 + 3];
          int v31 = v24[v29];
          int v30 = v24[v29 + 1];
          int v27 = v24[v29 + 2];
          int v28 = v24[v29 + 3];
          unsigned int v46 = ((9 * v33 + v27 + 3 * (v31 + v25) + 8) >> 4) - 128;
          unsigned int v47 = ((9 * v32 + v28 + 3 * (v30 + v26) + 8) >> 4) - 128;
          int v48 = v45 + ((int)(22970 * v47 + 0x2000) >> 14);
          int v49 = v45 + ((int)(-11700 * v47 - 5638 * v46 + 0x2000) >> 14);
          int v50 = v45 + ((int)(29032 * v46 + 0x2000) >> 14);
          if (v48 >= 255) {
            int v51 = 255;
          }
          else {
            int v51 = v48;
          }
          if (v49 >= 255) {
            int v52 = 255;
          }
          else {
            int v52 = v49;
          }
          if (v50 >= 255) {
            int v53 = 255;
          }
          else {
            int v53 = v50;
          }
          if (v19[v29 + 1] < 0)
          {
            int v54 = v52 & ~(v52 >> 31);
            int v55 = v53 & ~(v53 >> 31);
            if (v54 >= v55)
            {
              int v56 = (v51 & ~(v51 >> 31)) - v55;
              if (v56 >= 1)
              {
                int v57 = (((v54 - v55) << 6) / (v56 + v54 - v55) + 2) >> 2;
                if (v57 >= 8) {
                  int v57 = 8;
                }
                ++*((_DWORD *)v134 + v57);
              }
            }
            else
            {
              ++LODWORD(v134[0]);
            }
            if (v55 >= v54) {
              unsigned int v58 = v54;
            }
            else {
              unsigned int v58 = v53 & ~(v53 >> 31);
            }
            ++v137[v58];
            ++*((_DWORD *)v136 + (v58 >> 5));
            ++v16;
          }
          v29 += 2;
        }
        while ((int)v29 < v20);
        v24 += v29;
        uint64_t v59 = &v21[v29];
        uint64_t v60 = &v18[v29];
        int v61 = &v19[v29];
      }
      int v62 = *v59;
      unsigned int v63 = (9 * v26 + v30 + 3 * (v28 + v32) + 8) >> 4;
      unsigned int v64 = ((9 * v25 + v31 + 3 * (v27 + v33) + 8) >> 4) - 128;
      v63 -= 128;
      int v65 = v62 + ((int)(22970 * v63 + 0x2000) >> 14);
      int v66 = v62 + ((int)(-11700 * v63 - 5638 * v64 + 0x2000) >> 14);
      int v67 = v62 + ((int)(29032 * v64 + 0x2000) >> 14);
      if (v65 >= 255) {
        int v65 = 255;
      }
      if (v66 >= 255) {
        int v66 = 255;
      }
      if (v67 >= 255) {
        int v68 = 255;
      }
      else {
        int v68 = v67;
      }
      if (*v61 < 0)
      {
        unsigned int v70 = v66 & ~(v66 >> 31);
        int v71 = v68 & ~(v68 >> 31);
        if (v70 >= v71)
        {
          int v72 = (v65 & ~(v65 >> 31)) - v71;
          int v14 = v127;
          int v13 = v128;
          int v69 = v132;
          if (v72 >= 1)
          {
            int v73 = ((int)((v70 - v71) << 6) / (int)(v72 + v70 - v71) + 2) >> 2;
            if (v73 >= 8) {
              int v73 = 8;
            }
            ++*((_DWORD *)v134 + v73);
          }
        }
        else
        {
          ++LODWORD(v134[0]);
          int v14 = v127;
          int v13 = v128;
          int v69 = v132;
        }
        if (v71 < (int)v70) {
          unsigned int v70 = v71;
        }
        ++v137[v70];
        ++*((_DWORD *)v136 + (v70 >> 5));
        ++v16;
        int v25 = *v60;
      }
      else
      {
        int v14 = v127;
        int v13 = v128;
        int v69 = v132;
      }
      int v74 = v59[1];
      unsigned int v75 = ((9 * v25 + *v24 + 3 * (*v24 + v25) + 8) >> 4) - 128;
      unsigned int v76 = ((9 * v60[1] + v24[1] + 3 * (v24[1] + v60[1]) + 8) >> 4) - 128;
      int v77 = v74 + ((int)(22970 * v76 + 0x2000) >> 14);
      int v78 = v74 + ((int)(-11700 * v76 - 5638 * v75 + 0x2000) >> 14);
      int v79 = v74 + ((int)(29032 * v75 + 0x2000) >> 14);
      if (v77 >= 255) {
        int v80 = 255;
      }
      else {
        int v80 = v77;
      }
      if (v78 >= 255) {
        int v81 = 255;
      }
      else {
        int v81 = v78;
      }
      if (v79 >= 255) {
        int v82 = 255;
      }
      else {
        int v82 = v79;
      }
      if (v61[1] < 0)
      {
        unsigned int v84 = v81 & ~(v81 >> 31);
        int v85 = v82 & ~(v82 >> 31);
        int v83 = v133;
        if (v84 >= v85)
        {
          int v86 = (v80 & ~(v80 >> 31)) - v85;
          if (v86 >= 1)
          {
            int v87 = ((int)((v84 - v85) << 6) / (int)(v86 + v84 - v85) + 2) >> 2;
            if (v87 >= 8) {
              int v87 = 8;
            }
            ++*((_DWORD *)v134 + v87);
          }
        }
        else
        {
          ++LODWORD(v134[0]);
        }
        if (v85 < (int)v84) {
          unsigned int v84 = v85;
        }
        ++v137[v84];
        ++*((_DWORD *)v136 + (v84 >> 5));
        ++v16;
      }
      else
      {
        int v83 = v133;
      }
      v18 += v83 * v14;
      int v17 = v69 + 1;
      v21 += v130;
      v19 += v130;
    }
    while (v17 != v131);
  }
  uint64_t v88 = 0;
  int32x4_t v89 = (int32x4_t)xmmword_19394C9F0;
  float v90 = 0.0;
  v91.i64[0] = 0x400000004;
  v91.i64[1] = 0x400000004;
  do
  {
    int32x4_t v92 = (int32x4_t)v136[v88];
    float32x4_t v93 = vmulq_f32(vcvtq_f32_s32(v92), vcvtq_f32_s32(v89));
    int32x4_t v15 = vaddq_s32(v92, v15);
    float v90 = (float)((float)((float)(v90 + v93.f32[0]) + v93.f32[1]) + v93.f32[2]) + v93.f32[3];
    int32x4_t v89 = vaddq_s32(v89, v91);
    ++v88;
  }
  while (v88 != 2);
  uint64_t v94 = 0;
  int v95 = vaddvq_s32(v15);
  *(float *)v15.i32 = v90 / (float)v95;
  float32x4_t v96 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.i8, 0);
  int32x4_t v97 = (int32x4_t)xmmword_19394C9F0;
  float v98 = 0.0;
  v99.i64[0] = 0x400000004;
  v99.i64[1] = 0x400000004;
  do
  {
    float32x4_t v100 = vsubq_f32(vcvtq_f32_s32(v97), v96);
    float32x4_t v101 = vmulq_f32(vmulq_f32(v100, v100), vcvtq_f32_s32((int32x4_t)v136[v94]));
    float v98 = (float)((float)((float)(v98 + v101.f32[0]) + v101.f32[1]) + v101.f32[2]) + v101.f32[3];
    int32x4_t v97 = vaddq_s32(v97, v99);
    ++v94;
  }
  while (v94 != 2);
  float v102 = 0.0;
  if (v95 != 1) {
    float v102 = sqrtf(v98 / (float)(v95 - 1));
  }
  uint64_t v103 = 0;
  *a7 = v15.i32[0];
  *a8 = v102;
  do
  {
    if (v137[v103]) {
      break;
    }
    ++v103;
  }
  while (v103 != 256);
  int v104 = 0;
  for (int i = 255; i != -1; --i)
  {
    v104 += v137[i];
    if (v104 > (5 * v16 + 50) / 100) {
      break;
    }
  }
  uint64_t v106 = 0;
  int v107 = 0;
  int v108 = (v16 + 1) >> 1;
  do
  {
    v107 += v137[v106];
    if (v107 > v108) {
      break;
    }
    ++v106;
  }
  while (v106 != 256);
  unint64_t v109 = 0;
  int v110 = 0;
  int v111 = 0;
  *a4 = v103;
  a4[1] = v106;
  a4[2] = i;
  do
  {
    if (v109 <= 0xC7)
    {
      int v112 = v137[v109];
      v111 += v112 * v109;
      v110 += v112;
    }
    ++v109;
  }
  while (v109 != 256);
  uint64_t v113 = 0;
  int v114 = 0;
  a4[3] = (int)(float)((float)v111 / (float)v110);
  float v115 = 0.0;
  do
  {
    int v116 = *((_DWORD *)v134 + v113);
    float v115 = v115 + (float)((float)v116 * (float)(int)v113);
    v114 += v116;
    ++v113;
  }
  while (v113 != 9);
  uint64_t v117 = 0;
  float v118 = v115 / (float)v114;
  float v119 = 0.0;
  do
  {
    float v119 = v119
         + (float)((float)((float)((float)(int)v117 - v118) * (float)((float)(int)v117 - v118))
                 * (float)*((int *)v134 + v117));
    ++v117;
  }
  while (v117 != 9);
  float v120 = 0.0;
  int v121 = v114 - 1;
  if (v121) {
    float v120 = sqrtf(v119 / (float)v121);
  }
  *a5 = v118;
  *a6 = v120;
}

uint64_t redEyeDiscernment(uint64_t *a1, uint64_t a2, int *a3, uint64_t a4, float a5, float a6)
{
  memset(v166, 0, 48);
  uint64_t v12 = *a1;
  if (*a1)
  {
    unsigned int v13 = a3[2];
    int v14 = *a3;
    *(_OWORD *)((char *)&v166[1] + _Block_object_dispose(&STACK[0x238], 8) = *(_OWORD *)(a2 + 36);
    int v15 = *(_DWORD *)(a2 + 16);
    char v16 = 1;
  }
  else
  {
    unint64_t BitmapRect = makeBitmapRect(0, 0, 0, 0);
    char v16 = 0;
    unsigned int v13 = 0;
    int v14 = 0;
    int v15 = 0;
    *((void *)&v166[1] + 1) = BitmapRect;
    *(void *)&v166[2] = v18;
  }
  memset(v165, 0, sizeof(v165));
  LOBYTE(v166[0]) = v16;
  *((void *)&v166[0] + 1) = v12;
  *(void *)&v166[1] = __PAIR64__(v14, v13);
  DWORD2(v166[2]) = v15;
  uint64_t v19 = a1[1];
  uint64_t v140 = a2;
  if (v19)
  {
    uint64_t v20 = a3[6];
    int v21 = a3[4];
    *(_OWORD *)((char *)&v165[1] + _Block_object_dispose(&STACK[0x238], 8) = *(_OWORD *)(a2 + 132);
    int v22 = *(_DWORD *)(a2 + 112);
    char v23 = 1;
  }
  else
  {
    unint64_t v24 = makeBitmapRect(0, 0, 0, 0);
    char v23 = 0;
    uint64_t v20 = 0;
    int v21 = 0;
    int v22 = 0;
    *((void *)&v165[1] + 1) = v24;
    *(void *)&v165[2] = v25;
  }
  memset(v164, 0, sizeof(v164));
  LOBYTE(v165[0]) = v23;
  *((void *)&v165[0] + 1) = v19;
  *(void *)&v165[1] = __PAIR64__(v21, v20);
  DWORD2(v165[2]) = v22;
  uint64_t v26 = a1[2];
  uint64_t v138 = a3;
  if (v26)
  {
    uint64_t v27 = a3[10];
    int v28 = a3[8];
    *(_OWORD *)((char *)&v164[1] + _Block_object_dispose(&STACK[0x238], 8) = *(_OWORD *)(v140 + 228);
    int v29 = *(_DWORD *)(v140 + 208);
    char v30 = 1;
  }
  else
  {
    uint64_t v31 = v20;
    unint64_t v32 = makeBitmapRect(0, 0, 0, 0);
    uint64_t v20 = v31;
    char v30 = 0;
    uint64_t v27 = 0;
    int v28 = 0;
    int v29 = 0;
    *((void *)&v164[1] + 1) = v32;
    *(void *)&v164[2] = v33;
  }
  LOBYTE(v164[0]) = v30;
  *((void *)&v164[0] + 1) = v26;
  *(void *)&v164[1] = __PAIR64__(v28, v27);
  DWORD2(v164[2]) = v29;
  if (a4 == -1)
  {
    if (v12 && v19 && v26)
    {
      uint64_t v155 = 0;
      uint64_t v156 = 0;
      uint64_t v154 = 0;
      int v151 = 0;
      int v148 = 0;
      uint64_t v34 = v20;
      unint64_t v35 = offsetBitmapRect(*((uint64_t *)&v164[1] + 1), *(uint64_t *)&v164[2], v27, v28);
      uint64_t v37 = v36;
      int v141 = v34;
      unint64_t v38 = offsetBitmapRect(*((uint64_t *)&v165[1] + 1), *(uint64_t *)&v165[2], v34, v21);
      uint64_t v39 = unionBitmapRects(v35, v37, v38);
      uint64_t v41 = v40;
      int v42 = HIDWORD(v40) - v40;
      inited = initBitmask(HIDWORD(v40) - (int)v40, HIDWORD(v39) - (int)v39);
      int v134 = v41;
      int v136 = v39;
      unint64_t v44 = offsetBitmapRect(v39, v41, -(int)v41, -(int)v39);
      uint64_t v132 = v45;
      unint64_t v133 = v44;
      int v145 = HIDWORD(v39) - v39;
      int v147 = inited;
      if (HIDWORD(v39) - (int)v39 >= 1)
      {
        int v46 = 0;
        int v47 = v41 - v27;
        int v48 = v41 - v141;
        int v142 = v136 - v21;
        do
        {
          if (v42 >= 1)
          {
            for (unsigned int i = 0; i != v42; ++i)
            {
              int v50 = bitValueFromBitmask(v26, v47 + i, v136 - v28 + v46);
              int v51 = bitValueFromBitmask(v19, v48 + i, v142 + v46) | v50;
              inited = v147;
              setBitInBitmask((uint64_t)v147, i, v46, v51);
            }
          }
          ++v46;
        }
        while (v46 != v145);
      }
      float v130 = a5;
      float v131 = a6;
      v157[0] = 1;
      memset(&v157[1], 0, 7);
      float v158 = inited;
      int v159 = v134;
      int v160 = v136;
      unint64_t v161 = v133;
      uint64_t v162 = v132;
      uint64_t v163 = bitmaskArea((uint64_t)inited);
      comparePlacedBitmasks((uint64_t)v164, (uint64_t)v165, (_DWORD *)&v156 + 1, &v156, (_DWORD *)&v155 + 1);
      int v146 = HIDWORD(v155);
      int v52 = v156 + HIDWORD(v156) + HIDWORD(v155);
      comparePlacedBitmasks((uint64_t)v164, (uint64_t)v166, &v155, (_DWORD *)&v154 + 1, &v154);
      int v143 = HIDWORD(v154);
      int v144 = v155;
      int v137 = v154;
      comparePlacedBitmasks((uint64_t)v165, (uint64_t)v166, &v153, &v152, &v151);
      comparePlacedBitmasks((uint64_t)v166, (uint64_t)v157, &v150, &v149, &v148);
      int v53 = *(_DWORD *)(v140 + 16);
      int v54 = *(_DWORD *)(v140 + 112);
      int v55 = *(_DWORD *)(v140 + 208);
      float v56 = *(float *)(v140 + 20);
      float v57 = *(float *)(v140 + 24);
      float v58 = *(float *)(v140 + 116);
      float v59 = *(float *)(v140 + 212);
      int v60 = v138[2];
      int v61 = *v138;
      uint64_t v62 = v138[6];
      int v63 = v138[4];
      int v64 = v138[10];
      int v65 = v138[8];
      double v139 = *(double *)v140;
      double v135 = *(double *)(v140 + 8);
      double v67 = *(double *)(v140 + 96);
      double v66 = *(double *)(v140 + 104);
      double v69 = *(double *)(v140 + 192);
      double v68 = *(double *)(v140 + 200);
      unint64_t v70 = offsetBitmapRect(*(void *)(v140 + 132), *(void *)(v140 + 140), v62, v63);
      if (v56 <= v58) {
        float v72 = v58;
      }
      else {
        float v72 = v56;
      }
      if (v72 <= v59) {
        float v72 = v59;
      }
      double v73 = v72 * 0.5;
      if (v57 > 30.0 && v73 <= v56 || v57 > 90.0)
      {
        if (v52 >= 1)
        {
          double v76 = (float)v146;
          double v77 = (float)v52;
          double v78 = v77 * 0.8;
          double v79 = v77 * 1.25;
          BOOL v80 = v78 >= v76 || v79 <= v76;
          int v81 = (void **)v147;
          if (!v80)
          {
            double v82 = (float)SDWORD2(v166[2]);
            if (v82 * 0.6 < v76 && (v57 <= 100.0 || v82 * 10.0 >= v76))
            {
              a4 = v82 * 0.5 <= (float)v151;
LABEL_118:
              termBitmask(v81);
              return a4;
            }
          }
LABEL_114:
          a4 = 0;
          goto LABEL_118;
        }
        a4 = 0;
LABEL_89:
        int v81 = (void **)v147;
        goto LABEL_118;
      }
      int v83 = v64;
      int v84 = v65;
      if (v52 < 1
        || ((double v85 = (float)v146, v86 = (float)v52, v87 = v86 * 1.25, v86 * 0.8 < v85) ? (v88 = v87 <= v85) : (v88 = 1),
            v88))
      {
        if (SDWORD2(v165[2]) >= 1)
        {
          double v89 = (float)(v143 + v144 + v137);
          double v90 = (float)SDWORD2(v165[2]);
          double v91 = v90 * 0.8;
          double v92 = v90 * 1.25;
          if (v91 < v89 && v92 > v89) {
            goto LABEL_88;
          }
        }
        if (SDWORD2(v164[2]) >= 1 && SDWORD2(v165[2]) >= 1)
        {
          double v94 = (float)v146;
          double v95 = (float)SDWORD2(v164[2]);
          if (v95 * 0.8 < v94 && v95 * 1.25 > v94)
          {
            double v96 = (float)v151;
            double v97 = (float)SDWORD2(v165[2]);
            if (v97 * 0.8 < v96 && v97 * 1.25 > v96)
            {
              int v98 = DWORD2(v166[2]);
              if (SDWORD2(v166[2]) >= SDWORD2(v164[2])) {
                int v98 = DWORD2(v164[2]);
              }
              a4 = (float)v98 * 0.2 <= (float)v137;
              goto LABEL_89;
            }
          }
        }
        int v102 = DWORD2(v166[2]);
        int v81 = (void **)v147;
        if (SDWORD2(v166[2]) >= 1)
        {
          double v103 = (float)v151;
          double v104 = (float)SDWORD2(v166[2]);
          if (v104 * 0.8 < v103)
          {
            double v105 = v68;
            if (DWORD2(v166[2]) >= 2 && v104 * 1.25 > v103)
            {
              double v106 = v67;
              if (3 * DWORD2(v166[2]) > SDWORD2(v165[2])) {
                goto LABEL_114;
              }
              goto LABEL_104;
            }
LABEL_103:
            double v106 = v67;
LABEL_104:
            double v110 = v139 + (double)v60;
            double v111 = v135 + (double)v61;
            float v112 = sqrt((float)v55 / 3.14159265);
            float v113 = sqrt((float)v54 / 3.14159265);
            float v114 = v106 + (double)(int)v62 - v110;
            float v115 = v66 + (double)v63 - v111;
            float v116 = sqrtf((float)(v115 * v115) + (float)(v114 * v114));
            if (v116 <= v113 || v116 <= v112)
            {
              float v118 = v58;
              double v119 = v69 + (double)v83;
              double v120 = v105 + (double)v84;
              double v121 = v139 + (double)v60;
              double v122 = v135 + (double)v61;
              uint64_t v123 = v70;
              uint64_t v124 = v71;
              if (!pointInsideBitmapRect(v70, v71, v121, v122)
                || !pointInsideBitmapRect(v123, v124, v119, v120)
                || SDWORD2(v165[2]) >= 4 * v102)
              {
                if (v53 > 3 * v55 && v53 > 2 * v54) {
                  goto LABEL_114;
                }
                if (v118 <= v59 || v54 <= v55)
                {
                  if (v57 <= 10.0
                    || (float v126 = v110 - v130,
                        float v127 = v111 - v131,
                        float v128 = v119 - v130,
                        float v129 = v120 - v131,
                        sqrtf((float)(v127 * v127) + (float)(v126 * v126)) * 3.0 >= sqrtf((float)(v129 * v129)+ (float)(v128 * v128))))
                  {
                    if (*(unsigned char *)(v140 + 248)) {
                      a4 = 1;
                    }
                    else {
                      a4 = 2;
                    }
                    goto LABEL_118;
                  }
                  goto LABEL_114;
                }
              }
            }
            goto LABEL_117;
          }
        }
      }
      else
      {
        int v102 = DWORD2(v166[2]);
        double v107 = (float)SDWORD2(v166[2]);
        if (v86 * 0.1 > v107)
        {
LABEL_88:
          a4 = 1;
          goto LABEL_89;
        }
        double v108 = (float)v148;
        int v81 = (void **)v147;
        if (SDWORD2(v166[2]) >= 1 && v107 * 0.8 < v108 && v107 * 1.25 > v108)
        {
LABEL_117:
          a4 = 1;
          goto LABEL_118;
        }
        if (v107 * 0.6 < v86)
        {
          BOOL v109 = v86 * 0.8 >= v108 || v87 <= v108;
          double v105 = v68;
          double v106 = v67;
          if (!v109) {
            goto LABEL_117;
          }
          goto LABEL_104;
        }
      }
      double v105 = v68;
      goto LABEL_103;
    }
    if (v12)
    {
      if (v19)
      {
        return *(_DWORD *)(v140 + 16) <= 2 * *(_DWORD *)(v140 + 112);
      }
      else if (v26)
      {
        return 2 * (*(_DWORD *)(v140 + 16) <= 3 * *(_DWORD *)(v140 + 208));
      }
      else
      {
        return 0;
      }
    }
    else
    {
      BOOL v99 = v26 == 0;
      if (!v19) {
        BOOL v99 = 0;
      }
      if (v99)
      {
        return 1;
      }
      else
      {
        BOOL v100 = v19 == 0;
        if (!v26) {
          BOOL v100 = 0;
        }
        if (v100)
        {
          return 2;
        }
        else if (v22 <= v29 || *(float *)(v140 + 116) <= *(float *)(v140 + 212))
        {
          return 2;
        }
        else
        {
          return 1;
        }
      }
    }
  }
  return a4;
}

uint64_t comparePlacedBitmasks(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  uint64_t v6 = a1;
  unint64_t v7 = offsetBitmapRect(*(void *)(a1 + 24), *(void *)(a1 + 32), *(unsigned int *)(a1 + 16), *(_DWORD *)(a1 + 20));
  uint64_t v9 = v8;
  unint64_t v10 = offsetBitmapRect(*(void *)(a2 + 24), *(void *)(a2 + 32), *(unsigned int *)(a2 + 16), *(_DWORD *)(a2 + 20));
  uint64_t result = unionBitmapRects(v7, v9, v10);
  int v38 = HIDWORD(result) - result;
  if (HIDWORD(result) - (int)result < 1)
  {
    int v16 = 0;
    int v40 = 0;
    int v15 = 0;
  }
  else
  {
    int v13 = 0;
    uint64_t v14 = a2;
    int v15 = 0;
    int v40 = 0;
    int v16 = 0;
    int v17 = HIDWORD(v12) - v12;
    unsigned int v36 = v12 - *(_DWORD *)(v6 + 16);
    int v37 = HIDWORD(v12) - v12;
    int v35 = result - *(_DWORD *)(v6 + 20);
    uint64_t v18 = v14;
    unsigned int v34 = v12 - *(_DWORD *)(v14 + 16);
    int v33 = result - *(_DWORD *)(v14 + 20);
    do
    {
      int v39 = v13;
      if (v17 >= 1)
      {
        unsigned int v19 = v36;
        int v20 = v35 + v13;
        unsigned int v21 = v34;
        int v22 = v33 + v13;
        do
        {
          uint64_t v23 = v6;
          int v24 = bitValueFromBitmask(*(void *)(v6 + 8), v19, v20);
          uint64_t result = bitValueFromBitmask(*(void *)(v18 + 8), v21, v22);
          if (v24 == 1 && result == 0)
          {
            ++v16;
          }
          else
          {
            if (v24 == 1 && result == 1) {
              int v27 = v15 + 1;
            }
            else {
              int v27 = v15;
            }
            if (v24) {
              BOOL v28 = 0;
            }
            else {
              BOOL v28 = result == 1;
            }
            int v29 = v40;
            if (v28) {
              int v29 = v40 + 1;
            }
            int v40 = v29;
            if (!v28) {
              int v15 = v27;
            }
          }
          uint64_t v6 = v23;
          ++v21;
          ++v19;
          --v17;
        }
        while (v17);
      }
      int v13 = v39 + 1;
      int v17 = v37;
    }
    while (v39 + 1 != v38);
  }
  *a3 = v16;
  *a4 = v40;
  *a5 = v15;
  return result;
}

BOOL pointInsideBitmapRect(uint64_t a1, uint64_t a2, double a3, double a4)
{
  return a3 >= (float)(int)a2 && a3 <= (float)SHIDWORD(a2) && a4 >= (float)(int)a1 && a4 <= (float)SHIDWORD(a1);
}

unsigned __int8 **snapToPupil(unsigned __int8 **result, int a2, int a3, _DWORD *a4, _DWORD *a5, _DWORD *a6)
{
  int v7 = 0;
  int v8 = 0;
  int v9 = 0;
  uint64_t v10 = *((int *)result + 7);
  int v11 = *((_DWORD *)result + 3);
  uint64_t v12 = *((int *)result + 4);
  int v13 = (*result)[(int)v12 * a3 + (int)v10 * a2];
  int v14 = -a2;
  int v15 = -2;
  do
  {
    int v16 = a2;
    int v17 = a3;
    int v18 = v13;
    if (v11 >= 1)
    {
      int v19 = 0;
      int v20 = *((_DWORD *)result + 2);
      unsigned int v21 = *result;
      int v23 = -a3;
      int v22 = -v13;
      int v18 = v13;
      int v17 = a3;
      int v16 = a2;
      do
      {
        if (v20 >= 1)
        {
          int v24 = 0;
          uint64_t v25 = v21;
          do
          {
            int v26 = v23 * v23 + (v14 + v24) * (v14 + v24);
            int v27 = *v25;
            unsigned int v28 = (v26 + (1 << (v15 - 1))) >> v15;
            unsigned int v29 = v26 << -(char)v15;
            if (v15 <= 0) {
              unsigned int v28 = v29;
            }
            if ((int)(v28 - v27) < v22)
            {
              int v16 = v24;
              int v17 = v19;
              int v18 = *v25;
              int v22 = v28 - v27;
            }
            ++v24;
            v25 += v10;
          }
          while (v20 != v24);
        }
        ++v19;
        v21 += v12;
        ++v23;
      }
      while (v19 != v11);
    }
    if (v15 >= -1
      && sqrtf((float)((a3 - v9) * (a3 - v9) + (a2 - v8) * (a2 - v8))) * 4.0 < sqrtf((float)((a2 - v16) * (a2 - v16)
                                                                                           + (a3 - v17) * (a3 - v17))))
    {
      break;
    }
    ++v15;
    int v7 = v18;
    int v8 = v16;
    int v9 = v17;
  }
  while (v15 != 7);
  *a4 = v8;
  *a5 = v9;
  *a6 = v7;
  return result;
}

_DWORD *computeSkinMask(_DWORD *result, unsigned __int8 **a2, uint64_t a3, uint64_t a4)
{
  int v4 = result[3];
  BOOL v5 = __OFSUB__(v4, 1);
  int v6 = v4 - 1;
  if (v6 < 0 == v5)
  {
    int v7 = 0;
    int v8 = *((_DWORD *)a2 + 4);
    int v9 = *(unsigned char **)a3;
    uint64_t v10 = *a2;
    uint64_t v11 = *((int *)a2 + 7);
    uint64_t v12 = (int)result[4];
    uint64_t v13 = 2 * *(int *)(a3 + 28);
    do
    {
      if (v7 == v6) {
        int v14 = 0;
      }
      else {
        int v14 = v8;
      }
      if (v7) {
        int v15 = -v8;
      }
      else {
        int v15 = 0;
      }
      if ((v7 & 1) == 0) {
        int v14 = v15;
      }
      int v16 = &v10[v14];
      int v17 = *v10;
      int v18 = v10[1];
      int v19 = *v16;
      int v20 = v16[1];
      if ((int)result[2] < 3)
      {
        int v28 = *v10;
        int v27 = v10[1];
        int v26 = *v16;
        int v25 = v16[1];
        int v24 = v10;
        int v23 = v9;
      }
      else
      {
        int v21 = 0;
        uint64_t v22 = v14;
        int v23 = v9;
        int v24 = v10;
        int v25 = v20;
        int v26 = v19;
        int v27 = v10[1];
        int v28 = *v10;
        do
        {
          *int v23 = *(unsigned char *)(a4
                          + ((16 * (v26 + 9 * v17 + 3 * (v19 + v28)) + 128) & 0x7FFFFF00)
                          + (unint64_t)((9 * v18 + v25 + 3 * (v20 + v27) + 8) >> 4));
          int v28 = *v24;
          int v27 = v24[1];
          int v17 = v24[2];
          int v18 = v24[3];
          int v26 = v24[v22];
          int v25 = v24[v22 + 1];
          int v19 = v24[v22 + 2];
          int v20 = v24[v22 + 3];
          v23[1] = *(unsigned char *)(a4
                            + ((16 * (3 * (v26 + v17) + 9 * v28 + v19) + 128) & 0x7FFFFF00)
                            + (unint64_t)((9 * v27 + v20 + 3 * (v25 + v18) + 8) >> 4));
          v24 += v11;
          v21 += 2;
          v23 += v13;
        }
        while (v21 < result[2] - 2);
        int v16 = &v24[v22];
      }
      *int v23 = *(unsigned char *)(a4
                      + ((16 * (v26 + 9 * v17 + 3 * (v19 + v28)) + 128) & 0x7FF00)
                      + (unint64_t)((9 * v18 + v25 + 3 * (v20 + v27) + 8) >> 4));
      v23[1] = *(unsigned char *)(a4
                        + ((16 * (9 * *v24 + *v16 + 3 * (*v16 + *v24)) + 128) & 0x7FF00)
                        + (unint64_t)((9 * v24[1] + v16[1] + 3 * (v16[1] + v24[1]) + 8) >> 4));
      v10 += (v7++ & 1) * v8;
      v9 += v12;
    }
    while (v7 < result[3]);
  }
  return result;
}

uint64_t examineBitmask(unsigned __int8 **a1, unsigned __int8 **a2, uint64_t a3, int *a4)
{
  uint64_t v134 = *MEMORY[0x1E4F143B8];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *((_DWORD *)a1 + 3);
  uint64_t v6 = *((int *)a1 + 4);
  int v7 = *((_DWORD *)a1 + 7);
  int v8 = *((_DWORD *)a2 + 7);
  int v9 = *((_DWORD *)a2 + 4);
  *a4 = 0;
  if (v7 != 1 || v8 != 2)
  {
    uint64_t v11 = "examineBitmask: bitmaps are the wrong number of samples per pixel";
LABEL_135:
    puts(v11);
    return 0xFFFFFFFFLL;
  }
  uint64_t v12 = a3;
  if (v4 != *(_DWORD *)(a3 + 8)
    || v5 != *(_DWORD *)(a3 + 12)
    || v4 != 2 * *((_DWORD *)a2 + 2)
    || v5 != 2 * *((_DWORD *)a2 + 3))
  {
    uint64_t v11 = "examineBitmask: bitmaps don't match";
    goto LABEL_135;
  }
  uint32x4_t v13 = 0uLL;
  memset(v133, 0, sizeof(v133));
  if (v5 > 0)
  {
    int v14 = 0;
    int v15 = *a2;
    int v117 = -v9;
    int v118 = v5 - 1;
    int v123 = v4 - 2;
    float v126 = *a1;
    int v116 = v5;
    int v121 = v4;
    uint64_t v120 = v6;
    int v119 = v9;
    do
    {
      int v16 = v117;
      if (v14 == v118) {
        int v17 = 0;
      }
      else {
        int v17 = v9;
      }
      if (!v14) {
        int v16 = 0;
      }
      int v131 = v14;
      int v122 = v14 & 1;
      if ((v14 & 1) == 0) {
        int v17 = v16;
      }
      int v18 = &v15[v17];
      int v19 = *v15;
      int v20 = v15[1];
      int v21 = *v18;
      uint64_t v124 = v15;
      uint64_t v125 = v18;
      int v22 = v18[1];
      if (v4 < 3)
      {
        LODWORD(v5_Block_object_dispose(&STACK[0x238], 8) = 0;
        int v27 = *v15;
        int v26 = v15[1];
        int v25 = *v18;
        int v24 = v18[1];
        float v59 = v126;
      }
      else
      {
        uint64_t v23 = 0;
        int v24 = v22;
        int v25 = v21;
        int v26 = v15[1];
        int v27 = *v15;
        do
        {
          uint64_t v28 = v23;
          unsigned int v29 = &v126[v23];
          int v30 = v126[v23];
          unsigned int v31 = ((9 * v27 + v21 + 3 * (v25 + v19) + 8) >> 4) - 128;
          unsigned int v32 = ((9 * v26 + v22 + 3 * (v24 + v20) + 8) >> 4) - 128;
          int v33 = v30 + ((int)(22970 * v32 + 0x2000) >> 14);
          int v34 = v30 + ((int)(-11700 * v32 - 5638 * v31 + 0x2000) >> 14);
          int v35 = v30 + ((int)(29032 * v31 + 0x2000) >> 14);
          if (v33 >= 255) {
            int v36 = 255;
          }
          else {
            int v36 = v33;
          }
          if (v34 >= 255) {
            int v37 = 255;
          }
          else {
            int v37 = v34;
          }
          if (v35 >= 255) {
            int v38 = 255;
          }
          else {
            int v38 = v35;
          }
          if (bitValueFromBitmask(v12, v28, v131))
          {
            unsigned int v39 = v37 & ~(v37 >> 31);
            int v40 = v38 & ~(v38 >> 31);
            if (v39 < v40 || (int v41 = (v36 & ~(v36 >> 31)) - v40, v41 < 1))
            {
              int v42 = 0;
            }
            else
            {
              int v42 = ((int)((v39 - v40) << 6) / (int)(v41 + v39 - v40) + 2) >> 2;
              if (v42 >= 8) {
                int v42 = 8;
              }
            }
            if (v40 < (int)v39) {
              unsigned int v39 = v38 & ~(v38 >> 31);
            }
            ++*((_DWORD *)v133 + (int)(8 * v42 + (v39 >> 5)));
          }
          int v43 = v29[1];
          int v25 = v125[v28 + 2];
          int v128 = v125[v28];
          int v129 = v124[v28];
          int v127 = v124[v28 + 2];
          int v20 = v124[v28 + 1];
          int v44 = v125[v28 + 1];
          int v26 = v124[v28 + 3];
          int v45 = v125[v28 + 3];
          unsigned int v46 = ((9 * v129 + v25 + 3 * (v128 + v127) + 8) >> 4) - 128;
          unsigned int v47 = ((9 * v20 + v45 + 3 * (v44 + v26) + 8) >> 4) - 128;
          int v48 = v43 + ((int)(22970 * v47 + 0x2000) >> 14);
          int v49 = v43 + ((int)(-11700 * v47 - 5638 * v46 + 0x2000) >> 14);
          int v50 = v43 + ((int)(29032 * v46 + 0x2000) >> 14);
          if (v48 >= 255) {
            int v51 = 255;
          }
          else {
            int v51 = v48;
          }
          if (v49 >= 255) {
            int v52 = 255;
          }
          else {
            int v52 = v49;
          }
          if (v50 >= 255) {
            int v53 = 255;
          }
          else {
            int v53 = v50;
          }
          if (bitValueFromBitmask(a3, (int)v28 + 1, v131))
          {
            unsigned int v54 = v52 & ~(v52 >> 31);
            int v55 = v53 & ~(v53 >> 31);
            if (v54 < v55 || (int v56 = (v51 & ~(v51 >> 31)) - v55, v56 < 1))
            {
              int v57 = 0;
            }
            else
            {
              int v57 = ((int)((v54 - v55) << 6) / (int)(v56 + v54 - v55) + 2) >> 2;
              if (v57 >= 8) {
                int v57 = 8;
              }
            }
            if (v55 < (int)v54) {
              unsigned int v54 = v53 & ~(v53 >> 31);
            }
            ++*((_DWORD *)v133 + (int)(8 * v57 + (v54 >> 5)));
          }
          uint64_t v23 = v28 + 2;
          uint64_t v12 = a3;
          int v22 = v44;
          int v21 = v128;
          int v19 = v129;
          int v24 = v45;
          int v27 = v127;
        }
        while ((int)v28 + 2 < v123);
        uint64_t v58 = v28 + 2;
        v125 += v58;
        float v59 = &v126[v58];
        int v15 = &v124[v58];
        int v5 = v116;
      }
      int v60 = *v59;
      unsigned int v61 = ((9 * v27 + v21 + 3 * (v25 + v19) + 8) >> 4) - 128;
      unsigned int v62 = ((9 * v26 + v22 + 3 * (v24 + v20) + 8) >> 4) - 128;
      int v63 = v60 + ((int)(22970 * v62 + 0x2000) >> 14);
      int v64 = v60 + ((int)(-11700 * v62 - 5638 * v61 + 0x2000) >> 14);
      int v65 = v60 + ((int)(29032 * v61 + 0x2000) >> 14);
      if (v63 >= 255) {
        int v66 = 255;
      }
      else {
        int v66 = v63;
      }
      if (v64 >= 255) {
        int v67 = 255;
      }
      else {
        int v67 = v64;
      }
      if (v65 >= 255) {
        int v68 = 255;
      }
      else {
        int v68 = v65;
      }
      if (bitValueFromBitmask(v12, v58, v131))
      {
        unsigned int v69 = v67 & ~(v67 >> 31);
        int v70 = v68 & ~(v68 >> 31);
        if (v69 < v70 || (int v71 = (v66 & ~(v66 >> 31)) - v70, v71 < 1))
        {
          int v72 = 0;
        }
        else
        {
          int v72 = ((int)((v69 - v70) << 6) / (int)(v71 + v69 - v70) + 2) >> 2;
          if (v72 >= 8) {
            int v72 = 8;
          }
        }
        if (v70 < (int)v69) {
          unsigned int v69 = v68 & ~(v68 >> 31);
        }
        ++*((_DWORD *)v133 + (int)(8 * v72 + (v69 >> 5)));
      }
      int v73 = v59[1];
      unsigned int v74 = ((9 * *v15 + *v125 + 3 * (*v125 + *v15) + 8) >> 4) - 128;
      unsigned int v75 = ((9 * v15[1] + v125[1] + 3 * (v125[1] + v15[1]) + 8) >> 4) - 128;
      int v76 = v73 + ((int)(22970 * v75 + 0x2000) >> 14);
      int v77 = v73 + ((int)(-11700 * v75 - 5638 * v74 + 0x2000) >> 14);
      int v78 = v73 + ((int)(29032 * v74 + 0x2000) >> 14);
      if (v76 >= 255) {
        int v79 = 255;
      }
      else {
        int v79 = v76;
      }
      if (v77 >= 255) {
        int v80 = 255;
      }
      else {
        int v80 = v77;
      }
      if (v78 >= 255) {
        int v81 = 255;
      }
      else {
        int v81 = v78;
      }
      int v82 = bitValueFromBitmask(v12, v58 | 1, v131);
      int v9 = v119;
      uint32x4_t v13 = 0uLL;
      if (v82)
      {
        unsigned int v83 = v80 & ~(v80 >> 31);
        int v84 = v81 & ~(v81 >> 31);
        if (v83 < v84 || (int v85 = (v79 & ~(v79 >> 31)) - v84, v85 < 1))
        {
          int v86 = 0;
        }
        else
        {
          int v86 = ((int)((v83 - v84) << 6) / (int)(v85 + v83 - v84) + 2) >> 2;
          if (v86 >= 8) {
            int v86 = 8;
          }
        }
        if (v84 < (int)v83) {
          unsigned int v83 = v81 & ~(v81 >> 31);
        }
        ++*((_DWORD *)v133 + (int)(8 * v86 + (v83 >> 5)));
      }
      int v4 = v121;
      int v15 = &v124[v122 * v119];
      int v14 = v131 + 1;
      v126 += v120;
    }
    while (v131 + 1 != v5);
  }
  for (uint64_t i = 0; i != 18; ++i)
    uint32x4_t v13 = vmaxq_u32((uint32x4_t)v133[i], v13);
  int v88 = vmaxvq_u32(v13);
  unsigned int v89 = v88 - 1;
  if (v88 <= 1) {
    return 0xFFFFFFFFLL;
  }
  int v90 = 0;
  unsigned int v91 = v88 / 3u;
  double v92 = v133;
  do
  {
    uint64_t v93 = 0;
    do
    {
      unsigned int v94 = *(_DWORD *)((char *)v92 + v93);
      if (v94 <= v91) {
        unsigned int v95 = 0;
      }
      else {
        unsigned int v95 = (8 * v94 - 8) / v89 + 1;
      }
      *(_DWORD *)((char *)v92 + v93) = v95;
      v93 += 4;
    }
    while (v93 != 32);
    ++v90;
    v92 += 2;
  }
  while (v90 != 9);
  int v96 = 0;
  int v97 = 0;
  do
  {
    uint64_t v98 = 0;
    int v99 = v97;
    BOOL v100 = &v132[v97];
    float32x4_t v101 = (char *)v133 + 4 * v97;
    do
    {
      if (v98) {
        int v102 = *(_DWORD *)&v101[4 * v98];
      }
      else {
        int v102 = 0;
      }
      v100[v98++] = v102;
    }
    while (v98 != 8);
    ++v96;
    int v97 = v99 + 8;
  }
  while (v96 != 9);
  int v103 = 0;
  int v104 = 0;
  int v105 = 10;
  int v106 = -1;
  double v107 = v132;
  int v108 = -1;
  do
  {
    uint64_t v109 = 0;
    do
    {
      if (v104 >= v105) {
        int v110 = v105;
      }
      else {
        int v110 = v104;
      }
      if (v104 <= v108) {
        int v111 = v108;
      }
      else {
        int v111 = v104;
      }
      if ((int)v109 <= v106) {
        int v112 = v106;
      }
      else {
        int v112 = v109;
      }
      int v113 = v109 + 1;
      if (v107[v109])
      {
        int v105 = v110;
        int v108 = v111;
        int v106 = v112;
        ++v103;
      }
      ++v109;
    }
    while (v113 != 8);
    ++v104;
    v107 += 8;
  }
  while (v104 != 9);
  if (v103 && (v106 > 1 || v108 >= 2))
  {
    if (v108)
    {
      if (v106 == 1)
      {
        uint64_t result = 1;
      }
      else if ((v105 - 1) > 1 || v108 <= 2)
      {
        if (v105 == 3 && v108 == 3)
        {
          uint64_t result = 4;
        }
        else if (v108 >= 5)
        {
          uint64_t result = 5;
        }
        else
        {
          uint64_t result = 6;
        }
      }
      else
      {
        uint64_t result = 2;
      }
    }
    else
    {
      uint64_t result = 3;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  *a4 = v106;
  return result;
}

float f2AndPixelValueFromBorderPixelsAt(uint64_t a1, int a2, float *a3, float a4)
{
  if (a2 < 1)
  {
LABEL_6:
    *a3 = *(float *)(a1 - 8);
    return (float)*(int *)(a1 - 4);
  }
  int v4 = 0;
  int v5 = (float *)(a1 + 8);
  while (1)
  {
    float v6 = *(v5 - 2);
    if (v6 >= a4) {
      break;
    }
    ++v4;
    v5 += 3;
    if (a2 == v4)
    {
      a1 += 12 * (a2 - 1) + 12;
      goto LABEL_6;
    }
  }
  if (!v4)
  {
    *a3 = *(v5 - 1);
    return (float)*(int *)v5;
  }
  float v9 = (float)(a4 - *(v5 - 5)) / (float)(v6 - *(v5 - 5));
  float v10 = 0.0;
  if (v9 >= 0.0)
  {
    float v10 = v9;
    if (v9 > 1.0) {
      float v10 = 1.0;
    }
  }
  float v11 = *(v5 - 1);
  float v12 = *(v5 - 4);
  if (v11 != v12) {
    float v11 = v12 + (float)((float)(v11 - v12) * v10);
  }
  *a3 = v11;
  return (float)*((int *)v5 - 3) + (float)((float)(*(_DWORD *)v5 - *((_DWORD *)v5 - 3)) * v10);
}

uint64_t crossingCompare(float *a1, float *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a1 > *a2;
  }
}

uint64_t maximumPointWithSamples(float *a1, float *a2, float a3, float a4, float a5)
{
  double v5 = a4;
  double v6 = a5;
  float v7 = (a3 + a4 * -2.0 + v6) * 0.5;
  if (v7 == 0.0) {
    return 0;
  }
  float v8 = v5 + v5 + a3 * -1.5 + v6 * -0.5;
  float v9 = (float)-v8 / (v7 + v7);
  if (v9 <= 0.0 || v9 >= 2.0) {
    return 0;
  }
  *a1 = v9;
  *a2 = (float)(a3 + (float)(v8 * v9)) + (float)((float)(v7 * v9) * v9);
  return 1;
}

int *hopperInsert(int *result, float a2, float a3, double a4, double a5, float a6)
{
  uint64_t v6 = *result;
  if ((int)v6 < 1)
  {
    LODWORD(v7) = 0;
LABEL_13:
    float v12 = (float *)&result[10 * v7];
    _DWORD v12[2] = a2;
    void v12[3] = a3;
    v12[4] = a6;
    *((double *)v12 + 3) = a4;
    *((double *)v12 + 4) = a5;
    v12[10] = 0.0;
    if (*result < 4) {
      int v13 = *result + 1;
    }
    else {
      int v13 = 4;
    }
    *uint64_t result = v13;
    return result;
  }
  uint64_t v7 = 0;
  float v8 = (float *)(result + 2);
  while (*v8 >= a2)
  {
    ++v7;
    v8 += 10;
    if (v6 == v7)
    {
      LODWORD(v7) = *result;
      goto LABEL_12;
    }
  }
  if ((int)v6 > (int)v7)
  {
    uint64_t v9 = (int)v6;
    uint64_t v10 = (uint64_t)&result[10 * (int)v6 + 2];
    do
    {
      if (v9 <= 3)
      {
        long long v11 = *(_OWORD *)(v10 - 24);
        *(_OWORD *)uint64_t v10 = *(_OWORD *)(v10 - 40);
        *(_OWORD *)(v10 + 16) = v11;
        *(void *)(v10 + 32) = *(void *)(v10 - 8);
      }
      --v9;
      v10 -= 40;
    }
    while (v9 > v7);
  }
LABEL_12:
  if (v7 <= 3) {
    goto LABEL_13;
  }
  return result;
}

float energyFunction2(float32x2_t *a1, float32x2_t *a2)
{
  float32x2_t v2 = a1[2];
  float32x2_t v3 = a2[2];
  float64x2_t v4 = vcvtq_f64_f32(vabd_f32(v2, v3));
  float64x2_t v5 = vcvtq_f64_f32(vadd_f32(v2, v3));
  __asm { FMOV            V3.2D, #0.5 }
  return vabds_f32(a1[3].f32[0], a2[3].f32[0]) + vaddv_f32(vcvt_f32_f64(vdivq_f64(v4, vmulq_f64(v5, _Q3))));
}

float energyFunction1(float32x2_t *a1, float32x2_t *a2)
{
  __asm { FMOV            V3.2D, #0.5 }
  return vabds_f32(a1[1].f32[0], a2[1].f32[0])
       + vaddv_f32(vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(vabd_f32(*a1, *a2)), vmulq_f64(vcvtq_f64_f32(vadd_f32(*a1, *a2)), _Q3))));
}

int *minEnergyHopperInsert(int *result, int a2, float a3)
{
  uint64_t v3 = *result;
  if ((int)v3 < 1)
  {
    LODWORD(v4) = 0;
LABEL_13:
    uint64_t v6 = (float *)&result[2 * v4];
    v6[1] = a3;
    *((_DWORD *)v6 + 2) = a2;
    if (*result < 4) {
      int v7 = *result + 1;
    }
    else {
      int v7 = 4;
    }
    *uint64_t result = v7;
    return result;
  }
  uint64_t v4 = 0;
  float64x2_t v5 = (float *)(result + 1);
  while (*v5 <= a3)
  {
    ++v4;
    v5 += 2;
    if (v3 == v4)
    {
      LODWORD(v4) = *result;
      goto LABEL_12;
    }
  }
  if ((int)v3 > (int)v4)
  {
    uint64_t v3 = (int)v3;
    do
    {
      if (v3 <= 3) {
        *(void *)&result[2 * v3 + 1] = *(void *)&result[2 * v3 - 1];
      }
      --v3;
    }
    while (v3 > v4);
  }
LABEL_12:
  if (v4 <= 3) {
    goto LABEL_13;
  }
  return result;
}

BOOL checkPointAddress(unint64_t a1, unint64_t a2, uint64_t a3)
{
  return a1 >= a2 && a2 + 48 * a3 > a1;
}

int *snakeHopperInsert(int *result, int a2, int a3, int a4, int a5, float a6)
{
  uint64_t v6 = *result;
  if ((int)v6 < 1)
  {
    LODWORD(v7) = 0;
LABEL_13:
    long long v11 = (float *)&result[5 * v7];
    v11[1] = a6;
    *((_DWORD *)v11 + 2) = a2;
    *((_DWORD *)v11 + 3) = a3;
    *((_DWORD *)v11 + 4) = a4;
    *((_DWORD *)v11 + 5) = a5;
    if (*result < 20) {
      int v12 = *result + 1;
    }
    else {
      int v12 = 20;
    }
    *uint64_t result = v12;
    return result;
  }
  uint64_t v7 = 0;
  float v8 = (float *)(result + 1);
  while (*v8 <= a6)
  {
    ++v7;
    v8 += 5;
    if (v6 == v7)
    {
      LODWORD(v7) = *result;
      goto LABEL_12;
    }
  }
  if ((int)v6 > (int)v7)
  {
    uint64_t v9 = (int)v6;
    uint64_t v10 = (uint64_t)&result[5 * (int)v6 + 1];
    do
    {
      if (v9 <= 19)
      {
        *(_OWORD *)uint64_t v10 = *(_OWORD *)(v10 - 20);
        *(_DWORD *)(v10 + 16) = *(_DWORD *)(v10 - 4);
      }
      --v9;
      v10 -= 20;
    }
    while (v9 > v7);
  }
LABEL_12:
  if (v7 <= 0x13) {
    goto LABEL_13;
  }
  return result;
}

uint64_t bitIsSet_0(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  return bitValueFromBitmask(a2, a3, a4);
}

BOOL seedFill(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t, uint64_t, uint64_t))
{
  unsigned __int16 v39 = 0;
  int v38 = 0;
  if ((a3 & 0x80000000) == 0 && (a4 & 0x80000000) == 0 && *(_DWORD *)(a2 + 8) > a3)
  {
    int v9 = *(_DWORD *)(a2 + 12);
    if (v9 > (int)a4)
    {
      bzero(*(void **)a2, *(int *)(a2 + 16) * (uint64_t)v9);
      int v13 = allocSpanStack();
      if (v13)
      {
        uint64_t v14 = (uint64_t)v13;
        unsigned __int16 v41 = 0;
        int v40 = 0;
        spanSearch(a1, a2, a3, a4, &v40, a5, a6);
        unsigned int v15 = HIWORD(v40);
        if (HIWORD(v40) <= v41)
        {
          int v16 = (unsigned __int16)v40;
          int v17 = v41 + 1;
          do
            setBitInBitmask(a2, v15++, v16, 1);
          while (v17 != v15);
        }
        pushSpan(v14, &v40);
        uint64_t v37 = v14;
        while (1)
        {
LABEL_10:
          uint64_t v19 = *(void *)(v14 + 8);
          uint64_t v18 = *(void *)(v14 + 16);
          if (v18 == v19 + 16)
          {
            uint64_t v20 = *(void *)(v19 + 8);
            if (!v20)
            {
              freeSpanStack((void **)v14);
              return 1;
            }
            *(void *)(v14 + _Block_object_dispose(&STACK[0x238], 8) = v20;
            uint64_t v18 = v20 + 316;
          }
          *(void *)(v14 + 16) = v18 - 6;
          int v40 = *(_DWORD *)(v18 - 6);
          unsigned __int16 v41 = *(_WORD *)(v18 - 2);
          int v36 = (unsigned __int16)v40;
          if ((_WORD)v40)
          {
            uint64_t v21 = HIWORD(v40);
            int v22 = v41;
            if (HIWORD(v40) <= v41)
            {
              uint64_t v23 = (unsigned __int16)v40 - 1;
              do
              {
                if (!bitValueFromBitmask(a2, v21, v23) && a6(a5, a1, v21, v23))
                {
                  spanSearch(a1, a2, v21, v23, &v38, a5, a6);
                  unsigned int v24 = HIWORD(v38);
                  int v25 = v39;
                  if (HIWORD(v38) <= v39)
                  {
                    int v26 = (unsigned __int16)v38;
                    do
                      setBitInBitmask(a2, v24++, v26, 1);
                    while (v25 + 1 != v24);
                  }
                  uint64_t v14 = v37;
                  if (!pushSpan(v37, &v38))
                  {
LABEL_38:
                    puts("seedFill: can not push span onto stack");
                    freeSpanStack((void **)v14);
                    return 0;
                  }
                  LODWORD(v21) = v25 + 2;
                }
                BOOL v27 = (int)v21 < v22;
                uint64_t v21 = (v21 + 1);
              }
              while (v27);
            }
          }
          if (*(_DWORD *)(a2 + 12) - 1 > v36)
          {
            uint64_t v28 = HIWORD(v40);
            int v29 = v41;
            if (HIWORD(v40) <= v41)
            {
              uint64_t v30 = (v36 + 1);
              while (1)
              {
                if (!bitValueFromBitmask(a2, v28, v30) && a6(a5, a1, v28, v30))
                {
                  spanSearch(a1, a2, v28, v30, &v38, a5, a6);
                  unsigned int v31 = HIWORD(v38);
                  int v32 = v39;
                  if (HIWORD(v38) <= v39)
                  {
                    int v33 = (unsigned __int16)v38;
                    do
                      setBitInBitmask(a2, v31++, v33, 1);
                    while (v32 + 1 != v31);
                  }
                  uint64_t v14 = v37;
                  if (!pushSpan(v37, &v38)) {
                    goto LABEL_38;
                  }
                  LODWORD(v2_Block_object_dispose(&STACK[0x238], 8) = v32 + 2;
                }
                BOOL v27 = (int)v28 < v29;
                uint64_t v28 = (v28 + 1);
                if (!v27) {
                  goto LABEL_10;
                }
              }
            }
          }
        }
      }
      puts("seedFill: can not allocate span stack");
      return 0;
    }
  }
  int v34 = ci_logger_render();
  BOOL result = os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG);
  if (result)
  {
    seedFill_cold_1(v34);
    return 0;
  }
  return result;
}

void *allocSpanStack()
{
  uint64_t v0 = zmalloc(0x18uLL);
  if (v0)
  {
    float32x2_t v1 = zmalloc(0x140uLL);
    *uint64_t v0 = v1;
    v0[1] = v1;
    if (v1)
    {
      *float32x2_t v1 = 0;
      v1[1] = 0;
      v0[2] = v1 + 2;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    puts("allocSpanStack: span stack could not be allocated");
  }
  return v0;
}

uint64_t spanSearch(uint64_t result, uint64_t a2, int a3, uint64_t a4, _WORD *a5, uint64_t a6, uint64_t (*a7)(uint64_t, uint64_t, uint64_t, uint64_t))
{
  int v11 = a3;
  uint64_t v13 = result;
  *a5 = a4;
  LODWORD(v14) = a3;
  do
  {
    __int16 v15 = v14;
    BOOL v16 = __OFSUB__(v14, 1);
    uint64_t v14 = (v14 - 1);
    if ((int)v14 < 0 != v16) {
      break;
    }
    BOOL result = bitValueFromBitmask(a2, v14, a4);
    if (result == 1) {
      break;
    }
    BOOL result = a7(a6, v13, v14, a4);
  }
  while (result);
  a5[1] = v15;
  do
  {
    int v17 = v11;
    uint64_t v18 = (v11 + 1);
    if ((int)v18 >= *(_DWORD *)(a2 + 8)) {
      break;
    }
    BOOL result = bitValueFromBitmask(a2, v18, a4);
    if (result == 1) {
      break;
    }
    BOOL result = a7(a6, v13, v18, a4);
    int v11 = v17 + 1;
  }
  while (result);
  a5[2] = v17;
  if ((unsigned __int16)a5[1] > (unsigned __int16)v17)
  {
    return puts("spanSearch: empty span");
  }
  return result;
}

uint64_t pushSpan(uint64_t a1, int *a2)
{
  float64x2_t v5 = *(uint64_t **)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  if (v4 - (uint64_t)v5 - 16 >= 295)
  {
    uint64_t v6 = *v5;
    if (!v6)
    {
      uint64_t result = (uint64_t)zmalloc(0x140uLL);
      float v8 = *(uint64_t **)(a1 + 8);
      *float v8 = result;
      if (!result) {
        return result;
      }
      *(void *)uint64_t result = 0;
      uint64_t v6 = *v8;
      *(void *)(*v8 + _Block_object_dispose(&STACK[0x238], 8) = v8;
    }
    uint64_t v4 = v6 + 16;
    *(void *)(a1 + _Block_object_dispose(&STACK[0x238], 8) = v6;
    *(void *)(a1 + 16) = v6 + 16;
  }
  int v9 = *a2;
  *(_WORD *)(v4 + 4) = *((_WORD *)a2 + 2);
  *(_DWORD *)uint64_t v4 = v9;
  *(void *)(a1 + 16) += 6;
  return 1;
}

void freeSpanStack(void **a1)
{
  float32x2_t v2 = *a1;
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      zfree(v2);
      float32x2_t v2 = v3;
    }
    while (v3);
  }

  zfree(a1);
}

uint64_t incrementalSeedFill(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t, uint64_t, uint64_t))
{
  unsigned __int16 v59 = 0;
  int v58 = 0;
  int v12 = allocSpanStack();
  if (!v12)
  {
    puts("seedFill: can not allocate span stack");
    return 0;
  }
  int v56 = v12;
  unsigned __int16 v61 = 0;
  int v60 = 0;
  unint64_t v13 = bitmaskBoundingBitmapRectWithSeedPoint((uint64_t *)a2, a3, a4);
  unint64_t v15 = insetBitmapRect(v13, v14, 0xFFFFFFFFLL, -1);
  uint64_t v17 = v15 & ~((int)v15 >> 31);
  if (*(_DWORD *)(a2 + 12) >= SHIDWORD(v15)) {
    int v18 = HIDWORD(v15);
  }
  else {
    int v18 = *(_DWORD *)(a2 + 12);
  }
  int v55 = a6;
  uint64_t v57 = a5;
  if ((int)v17 < v18)
  {
    int v19 = *(_DWORD *)(a2 + 8);
    unint64_t v20 = v16 & 0xFFFFFFFF00000000;
    if ((v16 & 0x80000000) == 0) {
      unint64_t v20 = v16;
    }
    if (v19 >= SHIDWORD(v20)) {
      unint64_t v21 = v20;
    }
    else {
      unint64_t v21 = v20 | ((unint64_t)v19 << 32);
    }
    unint64_t v22 = HIDWORD(v21);
    int v53 = v18;
    unint64_t v52 = v21;
    do
    {
      if ((int)v21 >= (int)v22)
      {
        uint64_t v34 = (v17 + 1);
      }
      else
      {
        unsigned int v54 = v17 + 1;
        unint64_t v23 = v21;
        do
        {
          uint64_t v24 = *(void *)a2;
          uint64_t v25 = *(int *)(a2 + 16);
          uint64_t v26 = *(void *)a2 + (int)v25 * (uint64_t)(int)v17;
          if ((v23 & 0x80000000) == 0) {
            int v27 = v23;
          }
          else {
            int v27 = v23 + 7;
          }
          int v28 = 1 << (v23 & 7);
          if ((v28 & *(unsigned char *)(v26 + (v27 >> 3))) == 0)
          {
            if ((int)v23 >= 1
              && ((*(unsigned __int8 *)(v26 + ((unint64_t)(v23 - 1) >> 3)) >> ((v23 - 1) & 7)) & 1) != 0)
            {
              goto LABEL_68;
            }
            if ((int)v23 < *(_DWORD *)(a2 + 8) - 1)
            {
              int v29 = v23 + 8;
              if ((int)v23 >= -1) {
                int v29 = v23 + 1;
              }
              if ((*(unsigned __int8 *)(v26 + (v29 >> 3)) >> ((v23 + 1) & 7))) {
                goto LABEL_68;
              }
            }
            if ((uint64_t v30 = (uint64_t)v27 >> 3, v17)
              && (v28 & *(unsigned char *)(v24 + v25 * ((int)v17 - 1) + v30)) != 0
              || (int)v17 < *(_DWORD *)(a2 + 12) - 1
              && (v28 & *(unsigned char *)(v24 + (int)v25 * (uint64_t)(int)v54 + v30)) != 0)
            {
LABEL_68:
              if (a6(a5, a1, v23, v17))
              {
                spanSearch(a1, a2, v23, v17, &v60, a5, a6);
                unsigned int v31 = HIWORD(v60);
                if (HIWORD(v60) <= v61)
                {
                  int v32 = (unsigned __int16)v60;
                  int v33 = v61 + 1;
                  do
                    setBitInBitmask(a2, v31++, v32, 1);
                  while (v33 != v31);
                }
                pushSpan((uint64_t)v56, &v60);
                a6 = v55;
                a5 = v57;
              }
            }
          }
          unint64_t v23 = (v23 + 1);
        }
        while (v23 != v22);
        int v18 = v53;
        uint64_t v34 = v54;
        unint64_t v21 = v52;
      }
      uint64_t v17 = v34;
    }
    while (v34 != v18);
  }
  while (1)
  {
LABEL_37:
    uint64_t v36 = v56[1];
    uint64_t v35 = v56[2];
    if (v35 == v36 + 16)
    {
      uint64_t v37 = *(void *)(v36 + 8);
      if (!v37)
      {
        freeSpanStack((void **)v56);
        return 1;
      }
      v56[1] = v37;
      uint64_t v35 = v37 + 316;
    }
    v56[2] = v35 - 6;
    int v60 = *(_DWORD *)(v35 - 6);
    unsigned __int16 v61 = *(_WORD *)(v35 - 2);
    int v38 = (unsigned __int16)v60;
    if ((_WORD)v60)
    {
      uint64_t v39 = HIWORD(v60);
      int v40 = v61;
      if (HIWORD(v60) <= v61) {
        break;
      }
    }
LABEL_50:
    if (*(_DWORD *)(a2 + 12) - 1 > v38)
    {
      uint64_t v45 = HIWORD(v60);
      int v46 = v61;
      if (HIWORD(v60) <= v61)
      {
        uint64_t v47 = (v38 + 1);
        while (1)
        {
          if (!bitValueFromBitmask(a2, v45, v47) && a6(a5, a1, v45, v47))
          {
            spanSearch(a1, a2, v45, v47, &v58, a5, a6);
            unsigned int v48 = HIWORD(v58);
            int v49 = v59;
            if (HIWORD(v58) <= v59)
            {
              int v50 = (unsigned __int16)v58;
              do
                setBitInBitmask(a2, v48++, v50, 1);
              while (v49 + 1 != v48);
            }
            if (!pushSpan((uint64_t)v56, &v58)) {
              goto LABEL_63;
            }
            LODWORD(v45) = v49 + 2;
            a5 = v57;
          }
          BOOL v44 = (int)v45 < v46;
          uint64_t v45 = (v45 + 1);
          if (!v44) {
            goto LABEL_37;
          }
        }
      }
    }
  }
  while (1)
  {
    if (bitValueFromBitmask(a2, v39, v38 - 1) || !a6(a5, a1, v39, (v38 - 1))) {
      goto LABEL_49;
    }
    spanSearch(a1, a2, v39, (v38 - 1), &v58, a5, a6);
    unsigned int v41 = HIWORD(v58);
    int v42 = v59;
    if (HIWORD(v58) <= v59)
    {
      int v43 = (unsigned __int16)v58;
      do
        setBitInBitmask(a2, v41++, v43, 1);
      while (v42 + 1 != v41);
    }
    if (!pushSpan((uint64_t)v56, &v58)) {
      break;
    }
    LODWORD(v39) = v42 + 2;
    a6 = v55;
    a5 = v57;
LABEL_49:
    BOOL v44 = (int)v39 < v40;
    uint64_t v39 = (v39 + 1);
    if (!v44) {
      goto LABEL_50;
    }
  }
LABEL_63:
  puts("seedFill: can not push span onto stack");
  freeSpanStack((void **)v56);
  return 0;
}

uint64_t SurfaceApplyPlaneBlock(__IOSurface *a1, uint64_t a2)
{
  uint64_t result = 3758097090;
  if (a1 && a2)
  {
    if (IOSurfaceGetCompressionTypeOfPlane())
    {
      x_log("Error: a compressed surface cannot be accessed via its base address.\n");
      return 3758097084;
    }
    size_t PlaneCount = IOSurfaceGetPlaneCount(a1);
    if (PlaneCount <= 1)
    {
      uint64_t result = IOSurfaceLock(a1, 0, 0);
      if (result) {
        return result;
      }
      BaseAddress = IOSurfaceGetBaseAddress(a1);
      size_t BytesPerRow = IOSurfaceGetBytesPerRow(a1);
      size_t Width = IOSurfaceGetWidth(a1);
      size_t Height = IOSurfaceGetHeight(a1);
      if (BaseAddress && BytesPerRow && Width)
      {
        if (Height) {
          (*(void (**)(uint64_t, void *, void, size_t, size_t, size_t))(a2 + 16))(a2, BaseAddress, 0, Width, Height, BytesPerRow);
        }
      }
      IOSurfaceUnlock(a1, 0, 0);
      return 0;
    }
    size_t v10 = PlaneCount;
    if ((PlaneCount & 0xFFFFFFFFFFFFFFFELL) != 2) {
      return 0;
    }
    for (size_t i = 0; i != v10; ++i)
    {
      uint64_t result = IOSurfaceLockPlane();
      if (result) {
        break;
      }
      BaseAddressOfPlane = IOSurfaceGetBaseAddressOfPlane(a1, i);
      size_t BytesPerRowOfPlane = IOSurfaceGetBytesPerRowOfPlane(a1, i);
      size_t WidthOfPlane = IOSurfaceGetWidthOfPlane(a1, i);
      size_t HeightOfPlane = IOSurfaceGetHeightOfPlane(a1, i);
      if (BaseAddressOfPlane && BytesPerRowOfPlane && WidthOfPlane && HeightOfPlane) {
        (*(void (**)(uint64_t, void *, size_t, size_t, size_t, size_t))(a2 + 16))(a2, BaseAddressOfPlane, i, WidthOfPlane, HeightOfPlane, BytesPerRowOfPlane);
      }
      IOSurfaceUnlockPlane();
      uint64_t result = 0;
    }
  }
  return result;
}

uint64_t SurfaceApplyPlaneReadOnlyBlock(__IOSurface *a1, uint64_t a2)
{
  size_t PlaneCount = IOSurfaceGetPlaneCount(a1);
  if (IOSurfaceGetCompressionTypeOfPlane())
  {
    x_log("Error: a compressed surface cannot be accessed via its base address.\n");
    return 3758097084;
  }
  if (PlaneCount <= 1)
  {
    uint64_t result = IOSurfaceLock(a1, 1u, 0);
    if (result) {
      return result;
    }
    BaseAddress = IOSurfaceGetBaseAddress(a1);
    size_t BytesPerRow = IOSurfaceGetBytesPerRow(a1);
    size_t Width = IOSurfaceGetWidth(a1);
    size_t Height = IOSurfaceGetHeight(a1);
    if (BaseAddress && BytesPerRow && Width)
    {
      if (Height) {
        (*(void (**)(uint64_t, void *, void, size_t, size_t, size_t))(a2 + 16))(a2, BaseAddress, 0, Width, Height, BytesPerRow);
      }
    }
    IOSurfaceUnlock(a1, 1u, 0);
    return 0;
  }
  if ((PlaneCount & 0xFFFFFFFFFFFFFFFELL) != 2) {
    return 0;
  }
  size_t v10 = 0;
  while (1)
  {
    uint64_t result = IOSurfaceLockPlane();
    if (result) {
      break;
    }
    BaseAddressOfPlane = IOSurfaceGetBaseAddressOfPlane(a1, v10);
    size_t BytesPerRowOfPlane = IOSurfaceGetBytesPerRowOfPlane(a1, v10);
    size_t WidthOfPlane = IOSurfaceGetWidthOfPlane(a1, v10);
    size_t HeightOfPlane = IOSurfaceGetHeightOfPlane(a1, v10);
    if (BaseAddressOfPlane && BytesPerRowOfPlane && WidthOfPlane && HeightOfPlane) {
      (*(void (**)(uint64_t, void *, size_t, size_t, size_t, size_t))(a2 + 16))(a2, BaseAddressOfPlane, v10, WidthOfPlane, HeightOfPlane, BytesPerRowOfPlane);
    }
    IOSurfaceUnlockPlane();
    if (PlaneCount == ++v10) {
      return 0;
    }
  }
  return result;
}

uint64_t SurfaceGetMemorySize(__IOSurface *a1)
{
  size_t PlaneCount = IOSurfaceGetPlaneCount(a1);
  if (PlaneCount >= 2)
  {
    size_t v3 = PlaneCount;
    uint64_t v4 = 0;
    do
    {
      v4 += IOSurfaceGetSizeOfPlane();
      --v3;
    }
    while (v3);
    return v4;
  }
  else
  {
    return IOSurfaceGetSizeOfPlane();
  }
}

uint64_t CopyYCC444_to_Y_8(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3)
  {
    for (uint64_t i = 0; i != a3; ++i)
    {
      if (a2)
      {
        int v9 = (unsigned char *)(a5 + a6 + (i + a7) * a8);
        size_t v10 = (char *)(result + i * a4);
        uint64_t v11 = a2;
        do
        {
          char v12 = *v10;
          v10 += 4;
          *v9++ = v12;
          --v11;
        }
        while (v11);
      }
    }
  }
  return result;
}

uint64_t CopyYCC444_to_CbCr_8(uint64_t result, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 >= 2)
  {
    uint64_t v8 = 0;
    unint64_t v9 = a3 >> 1;
    unint64_t v10 = a3 - 1;
    uint64_t v11 = a5 + 2 * a6;
    uint64_t v12 = a2 >> 1;
    if (a2 >> 1 <= 1) {
      uint64_t v12 = 1;
    }
    unint64_t v13 = (unsigned __int8 *)(result + 6);
    do
    {
      if (a2 >= 2)
      {
        uint64_t v14 = (unsigned char *)(v11 + (v8 + a7) * a8);
        if (v10 <= 2 * v8) {
          uint64_t v15 = 0;
        }
        else {
          uint64_t v15 = a4;
        }
        unint64_t v16 = v13;
        uint64_t result = v12;
        do
        {
          uint64_t v17 = &v16[v15];
          *uint64_t v14 = (*(v16 - 5) + *(v16 - 1) + v16[v15 - 5] + v16[v15 - 1] + 2) >> 2;
          int v18 = *(v16 - 4);
          int v19 = *v16;
          v16 += 8;
          v14[1] = (v18 + v19 + *(v17 - 4) + *v17 + 2) >> 2;
          v14 += 2;
          --result;
        }
        while (result);
      }
      ++v8;
      v13 += 2 * a4;
    }
    while (v8 != v9);
  }
  return result;
}

uint64_t CopyYCC444_to_CbCr422_8(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3)
  {
    uint64_t v8 = 0;
    uint64_t v9 = a2 >> 1;
    if (a2 >> 1 <= 1) {
      uint64_t v9 = 1;
    }
    unint64_t v10 = (unsigned __int8 *)(result + 5);
    uint64_t v11 = a8 * a7 + 2 * a6 + a5 + 1;
    do
    {
      uint64_t v12 = v9;
      unint64_t v13 = (unsigned char *)v11;
      uint64_t v14 = v10;
      if (a2 >= 2)
      {
        do
        {
          *(v13 - 1) = (*(v14 - 4) + *v14 + 1) >> 1;
          *unint64_t v13 = (*(v14 - 3) + v14[1] + 1) >> 1;
          v13 += 2;
          v14 += 8;
          --v12;
        }
        while (v12);
      }
      ++v8;
      v10 += a4;
      v11 += a8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t CopyYCC444_to_CbCr444_8(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3)
  {
    uint64_t v8 = 0;
    uint64_t v9 = a8 * a7 + 2 * a6 + a5 + 1;
    unint64_t v10 = (char *)(result + 2);
    do
    {
      uint64_t v11 = v10;
      uint64_t v12 = (unsigned char *)v9;
      for (uint64_t i = a2; i; --i)
      {
        *(v12 - 1) = *(v11 - 1);
        char v14 = *v11;
        v11 += 4;
        *uint64_t v12 = v14;
        v12 += 2;
      }
      ++v8;
      v9 += a8;
      v10 += a4;
    }
    while (v8 != a3);
  }
  return result;
}

__int16 *CopyYCC444_to_Y_16(__int16 *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3)
  {
    for (uint64_t i = 0; i != a3; ++i)
    {
      if (a2)
      {
        uint64_t v9 = (_WORD *)(a5 + 2 * a6 + (((i + a7) * a8) & 0xFFFFFFFFFFFFFFFELL));
        uint64_t v10 = a2;
        uint64_t v11 = result;
        do
        {
          __int16 v12 = *v11;
          v11 += 4;
          *v9++ = v12;
          --v10;
        }
        while (v10);
      }
      uint64_t result = (__int16 *)((char *)result + a4);
    }
  }
  return result;
}

uint64_t CopyYCC444_to_CbCr_16(uint64_t result, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 >= 2)
  {
    uint64_t v8 = 0;
    unint64_t v9 = a3 >> 1;
    uint64_t v10 = result + a4;
    unint64_t v11 = a3 - 1;
    uint64_t v12 = a2 >> 1;
    uint64_t v13 = 2 * a4;
    if (a2 >> 1 <= 1) {
      uint64_t v12 = 1;
    }
    do
    {
      if (a2 >= 2)
      {
        char v14 = (_WORD *)(a5 + 4 * a6 + (((v8 + a7) * a8) & 0xFFFFFFFFFFFFFFFELL));
        if (v11 <= 2 * v8) {
          uint64_t v15 = result;
        }
        else {
          uint64_t v15 = v10;
        }
        uint64_t v16 = 10;
        uint64_t v17 = v12;
        do
        {
          *char v14 = (*(unsigned __int16 *)(result + v16 - 8)
                + *(unsigned __int16 *)(result + v16)
                + *(unsigned __int16 *)(v15 + v16 - 8)
                + *(unsigned __int16 *)(v15 + v16)
                + 2) >> 2;
          v14[1] = (*(unsigned __int16 *)(result + v16 - 6)
                  + *(unsigned __int16 *)(result + v16 + 2)
                  + *(unsigned __int16 *)(v15 + v16 - 6)
                  + *(unsigned __int16 *)(v15 + v16 + 2)
                  + 2) >> 2;
          v16 += 16;
          v14 += 2;
          --v17;
        }
        while (v17);
      }
      ++v8;
      result += v13;
      v10 += v13;
    }
    while (v8 != v9);
  }
  return result;
}

uint64_t CopyYCC444_to_CbCr422_16(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3)
  {
    uint64_t v8 = 0;
    uint64_t v9 = a5 + a8 * a7;
    uint64_t v10 = a2 >> 1;
    if (a2 >> 1 <= 1) {
      uint64_t v10 = 1;
    }
    unint64_t v11 = (unsigned __int16 *)(result + 10);
    do
    {
      uint64_t v12 = v11;
      uint64_t v13 = 4 * a6;
      uint64_t v14 = v10;
      if (a2 >= 2)
      {
        do
        {
          uint64_t v15 = (_WORD *)(v9 + v13);
          *uint64_t v15 = (*(v12 - 4) + *v12 + 1) >> 1;
          uint64_t result = v12[1];
          v15[1] = (*(v12 - 3) + result + 1) >> 1;
          v13 += 4;
          v12 += 8;
          --v14;
        }
        while (v14);
      }
      ++v8;
      v9 += a8;
      unint64_t v11 = (unsigned __int16 *)((char *)v11 + a4);
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t CopyYCC444_to_CbCr444_16(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3)
  {
    uint64_t v8 = 0;
    uint64_t v9 = a8 * a7 + 4 * a6 + a5 + 2;
    uint64_t v10 = (__int16 *)(result + 4);
    do
    {
      unint64_t v11 = v10;
      uint64_t v12 = (_WORD *)v9;
      for (uint64_t i = a2; i; --i)
      {
        *(v12 - 1) = *(v11 - 1);
        __int16 v14 = *v11;
        v11 += 4;
        *uint64_t v12 = v14;
        v12 += 2;
      }
      ++v8;
      v9 += a8;
      uint64_t v10 = (__int16 *)((char *)v10 + a4);
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t CopyYCC_A2BGR10_to_Y_10(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3)
  {
    uint64_t v8 = 0;
    uint64_t v9 = a8 * a7;
    do
    {
      if (a2)
      {
        for (uint64_t i = 0; i != a2; ++i)
          *(_WORD *)(a5 + 2 * a6 + (v9 & 0xFFFFFFFFFFFFFFFELL) + 2 * i) = *(_WORD *)(result + 4 * i) << 6;
      }
      ++v8;
      result += a4;
      v9 += a8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t CopyYCC_A2BGR10_to_CbCr_10(uint64_t result, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 >= 2)
  {
    uint64_t v8 = 0;
    unint64_t v9 = a3 >> 1;
    uint64_t v10 = result + a4;
    unint64_t v11 = a3 - 1;
    uint64_t v12 = a2 >> 1;
    uint64_t v13 = 2 * a4;
    uint64_t v14 = a5 + 4 * a6;
    if (a2 >> 1 <= 1) {
      uint64_t v12 = 1;
    }
    int8x8_t v15 = (int8x8_t)vdup_n_s32(0xFFC0u);
    do
    {
      if (a2 >= 2)
      {
        uint64_t v16 = 0;
        uint64_t v17 = (_WORD *)(v14 + (((v8 + a7) * a8) & 0xFFFFFFFFFFFFFFFELL));
        if (v11 <= 2 * v8) {
          uint64_t v18 = result;
        }
        else {
          uint64_t v18 = v10;
        }
        uint64_t v19 = v12;
        do
        {
          unint64_t v20 = (const float *)(result + v16);
          unint64_t v21 = (const float *)(v18 + v16);
          uint32x2_t v22 = (uint32x2_t)vld1_dup_f32(v20++);
          uint32x2_t v23 = (uint32x2_t)vld1_dup_f32(v20);
          uint32x2_t v24 = (uint32x2_t)vld1_dup_f32(v21++);
          uint32x2_t v25 = (uint32x2_t)vld1_dup_f32(v21);
          uint32x2_t v26 = vshr_n_u32((uint32x2_t)vadd_s32(vadd_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32(v23, (uint32x2_t)0xFFFFFFF2FFFFFFFCLL), v15), vadd_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32(v22, (uint32x2_t)0xFFFFFFF2FFFFFFFCLL), v15), (int32x2_t)vand_s8((int8x8_t)vshl_u32(v24, (uint32x2_t)0xFFFFFFF2FFFFFFFCLL), v15))), (int32x2_t)vand_s8((int8x8_t)vshl_u32(v25, (uint32x2_t)0xFFFFFFF2FFFFFFFCLL), v15)), 2uLL);
          v17[1] = v26.i16[2];
          *uint64_t v17 = v26.i16[0];
          v17 += 2;
          v16 += 8;
          --v19;
        }
        while (v19);
      }
      ++v8;
      result += v13;
      v10 += v13;
    }
    while (v8 != v9);
  }
  return result;
}

const float *CopyYCC_A2BGR10_to_CbCr422_10(const float *result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3)
  {
    uint64_t v8 = 0;
    uint64_t v9 = a5 + a8 * a7;
    uint64_t v10 = a2 >> 1;
    if (a2 >> 1 <= 1) {
      uint64_t v10 = 1;
    }
    int8x8_t v11 = (int8x8_t)vdup_n_s32(0xFFC0u);
    do
    {
      uint64_t v12 = 4 * a6;
      uint64_t v13 = v10;
      uint64_t v14 = result;
      if (a2 >= 2)
      {
        do
        {
          int8x8_t v15 = (_WORD *)(v9 + v12);
          uint64_t v16 = v14;
          uint32x2_t v17 = (uint32x2_t)vld1_dup_f32(v16++);
          uint32x2_t v18 = (uint32x2_t)vld1_dup_f32(v16);
          uint32x2_t v19 = vhadd_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32(v18, (uint32x2_t)0xFFFFFFF2FFFFFFFCLL), v11), (uint32x2_t)vand_s8((int8x8_t)vshl_u32(v17, (uint32x2_t)0xFFFFFFF2FFFFFFFCLL), v11));
          v15[1] = v19.i16[2];
          *int8x8_t v15 = v19.i16[0];
          v12 += 4;
          v14 += 2;
          --v13;
        }
        while (v13);
      }
      ++v8;
      uint64_t result = (const float *)((char *)result + a4);
      v9 += a8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t CopyYCC_A2BGR10_to_CbCr444_10(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3)
  {
    uint64_t v8 = 0;
    uint64_t v9 = a8 * a7 + 4 * a6 + a5 + 2;
    do
    {
      if (a2)
      {
        uint64_t v10 = 0;
        int8x8_t v11 = (_WORD *)v9;
        do
        {
          unsigned int v12 = *(_DWORD *)(result + 4 * v10);
          *(v11 - 1) = (v12 >> 4) & 0xFFC0;
          *int8x8_t v11 = (v12 >> 14) & 0xFFC0;
          v11 += 2;
          ++v10;
        }
        while (a2 != v10);
      }
      ++v8;
      result += a4;
      v9 += a8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t CopyYCC_A2RGB10_to_Y_10(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3)
  {
    uint64_t v8 = 0;
    uint64_t v9 = a8 * a7;
    do
    {
      if (a2)
      {
        for (uint64_t i = 0; i != a2; ++i)
          *(_WORD *)(a5 + 2 * a6 + (v9 & 0xFFFFFFFFFFFFFFFELL) + 2 * i) = (*(_DWORD *)(result + 4 * i) >> 14) & 0xFFC0;
      }
      ++v8;
      result += a4;
      v9 += a8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t CopyYCC_A2RGB10_to_CbCr_10(uint64_t result, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 >= 2)
  {
    uint64_t v8 = 0;
    unint64_t v9 = a3 >> 1;
    uint64_t v10 = result + a4;
    unint64_t v11 = a3 - 1;
    uint64_t v12 = a2 >> 1;
    uint64_t v13 = 2 * a4;
    if (a2 >> 1 <= 1) {
      uint64_t v12 = 1;
    }
    uint64_t v14 = a5 + 4 * a6;
    uint64_t v15 = a8 * a7;
    do
    {
      if (a2 >= 2)
      {
        uint64_t v16 = 0;
        if (v11 <= 2 * v8) {
          uint64_t v17 = result;
        }
        else {
          uint64_t v17 = v10;
        }
        uint64_t v18 = v12;
        do
        {
          uint32x2_t v19 = (unsigned int *)(result + 4 * v16);
          unint64_t v20 = (unsigned int *)(v17 + 4 * v16);
          unint64_t v21 = (_WORD *)(v14 + (v15 & 0xFFFFFFFFFFFFFFFELL) + 2 * v16);
          unsigned int v22 = *v19;
          LODWORD(v19) = v19[1];
          unsigned int v23 = *v20;
          LODWORD(v20) = v20[1];
          *unint64_t v21 = (((v19 >> 4) & 0xFFC0)
                + ((v22 >> 4) & 0xFFC0)
                + ((v23 >> 4) & 0xFFC0)
                + ((v20 >> 4) & 0xFFC0)) >> 2;
          v21[1] = ((((unsigned __int16)v19 & 0x3FF) << 6)
                  + ((v22 & 0x3FF) << 6)
                  + ((v23 & 0x3FF) << 6)
                  + (((unsigned __int16)v20 & 0x3FF) << 6)) >> 2;
          v16 += 2;
          --v18;
        }
        while (v18);
      }
      ++v8;
      result += v13;
      v10 += v13;
      v15 += a8;
    }
    while (v8 != v9);
  }
  return result;
}

uint64_t CopyYCC_A2RGB10_to_CbCr422_10(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3)
  {
    uint64_t v8 = 0;
    uint64_t v9 = a2 >> 1;
    if (a2 >> 1 <= 1) {
      uint64_t v9 = 1;
    }
    uint64_t v10 = a5 + a8 * a7 + 4 * a6;
    do
    {
      if (a2 >= 2)
      {
        uint64_t v11 = 0;
        uint64_t v12 = v9;
        do
        {
          uint64_t v13 = (_WORD *)(v10 + 2 * v11);
          uint64_t v14 = (unsigned int *)(result + 4 * v11);
          unsigned int v15 = *v14;
          LODWORD(v14) = v14[1];
          *uint64_t v13 = (((v14 >> 4) & 0xFFC0) + ((v15 >> 4) & 0xFFC0)) >> 1;
          v13[1] = ((((unsigned __int16)v14 & 0x3FF) << 6) + ((v15 & 0x3FF) << 6)) >> 1;
          v11 += 2;
          --v12;
        }
        while (v12);
      }
      ++v8;
      result += a4;
      v10 += a8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t CopyYCC_A2RGB10_to_CbCr444_10(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3)
  {
    uint64_t v8 = 0;
    uint64_t v9 = a8 * a7 + 4 * a6 + a5 + 2;
    do
    {
      if (a2)
      {
        uint64_t v10 = 0;
        uint64_t v11 = (_WORD *)v9;
        do
        {
          unsigned int v12 = *(_DWORD *)(result + 4 * v10);
          *(v11 - 1) = (v12 >> 4) & 0xFFC0;
          *uint64_t v11 = (_WORD)v12 << 6;
          v11 += 2;
          ++v10;
        }
        while (a2 != v10);
      }
      ++v8;
      result += a4;
      v9 += a8;
    }
    while (v8 != a3);
  }
  return result;
}

unsigned __int16 *CopyYCC444_to_Y_10packed(unsigned __int16 *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3)
  {
    for (uint64_t i = 0; i != a3; ++i)
    {
      if (a2)
      {
        uint64_t v9 = a2;
        uint64_t v10 = a6;
        uint64_t v11 = result;
        do
        {
          unsigned int v12 = *v11;
          v11 += 4;
          uint64_t v13 = llroundf((float)((float)v12 * 1023.0) / 65535.0);
          if (v13 >= 1023) {
            uint64_t v13 = 1023;
          }
          *(_DWORD *)(a5 + (((i + a7) * a8) & 0xFFFFFFFFFFFFFFFCLL) + 4 * (v10 / 3)) = ((v13 & ~(v13 >> 63)) << (10 * (v10 % 3))) | dword_193958500[v10 % 3] & *(_DWORD *)(a5 + (((i + a7) * a8) & 0xFFFFFFFFFFFFFFFCLL) + 4 * (v10 / 3));
          ++v10;
          --v9;
        }
        while (v9);
      }
      uint64_t result = (unsigned __int16 *)((char *)result + a4);
    }
  }
  return result;
}

uint64_t CopyYCC444_to_CbCr_10packed(uint64_t result, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 >= 2)
  {
    uint64_t v8 = 0;
    unint64_t v9 = a3 >> 1;
    uint64_t v10 = result + a4;
    unint64_t v11 = a3 - 1;
    uint64_t v12 = a2 >> 1;
    uint64_t v13 = 2 * a4;
    if (a2 >> 1 <= 1) {
      uint64_t v12 = 1;
    }
    uint64_t v14 = 2 * a6;
    do
    {
      if (a2 >= 2)
      {
        uint64_t v15 = a5 + (((v8 + a7) * a8) & 0xFFFFFFFFFFFFFFFCLL);
        if (v11 <= 2 * v8) {
          uint64_t v16 = result;
        }
        else {
          uint64_t v16 = v10;
        }
        uint64_t v17 = 10;
        uint64_t v18 = v12;
        uint64_t v19 = v14;
        do
        {
          uint64_t v20 = llroundf((float)((float)(unsigned __int16)((*(unsigned __int16 *)(result + v17 - 8)+ *(unsigned __int16 *)(result + v17)+ *(unsigned __int16 *)(v16 + v17 - 8)+ *(unsigned __int16 *)(v16 + v17)+ 2) >> 2)* 1023.0)/ 65535.0);
          if (v20 >= 1023) {
            uint64_t v20 = 1023;
          }
          int v21 = *(unsigned __int16 *)(result + v17 - 6)
              + *(unsigned __int16 *)(result + v17 + 2)
              + *(unsigned __int16 *)(v16 + v17 - 6)
              + *(unsigned __int16 *)(v16 + v17 + 2);
          *(_DWORD *)(v15 + 4 * (v19 / 3)) = ((v20 & ~(v20 >> 63)) << (10 * (v19 % 3))) | dword_193958500[v19 % 3] & *(_DWORD *)(v15 + 4 * (v19 / 3));
          uint64_t v22 = llroundf((float)((float)(unsigned __int16)((v21 + 2) >> 2) * 1023.0) / 65535.0);
          if (v22 >= 1023) {
            uint64_t v22 = 1023;
          }
          *(_DWORD *)(v15 + 4 * ((v19 + 1) / 3)) = ((v22 & ~(v22 >> 63)) << (10 * ((v19 + 1) % 3))) | dword_193958500[(v19 + 1) % 3] & *(_DWORD *)(v15 + 4 * ((v19 + 1) / 3));
          v19 += 2;
          v17 += 16;
          --v18;
        }
        while (v18);
      }
      ++v8;
      result += v13;
      v10 += v13;
    }
    while (v8 != v9);
  }
  return result;
}

uint64_t CopyYCC444_to_CbCr422_10packed(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3)
  {
    uint64_t v8 = 0;
    uint64_t v9 = a5 + a8 * a7;
    uint64_t v10 = a2 >> 1;
    if (a2 >> 1 <= 1) {
      uint64_t v10 = 1;
    }
    unint64_t v11 = (unsigned __int16 *)(result + 10);
    do
    {
      uint64_t v12 = v11;
      uint64_t v13 = v10;
      uint64_t result = 2 * a6;
      if (a2 >= 2)
      {
        do
        {
          uint64_t v14 = llroundf((float)((float)(unsigned __int16)((*(v12 - 4) + *v12 + 1) >> 1) * 1023.0) / 65535.0);
          if (v14 >= 1023) {
            uint64_t v14 = 1023;
          }
          unsigned int v15 = ((v14 & ~(v14 >> 63)) << (10 * (result % 3))) | dword_193958500[result % 3] & *(_DWORD *)(v9 + 4 * (result / 3));
          uint64_t v16 = llroundf((float)((float)(unsigned __int16)((*(v12 - 3) + v12[1] + 1) >> 1) * 1023.0) / 65535.0);
          *(_DWORD *)(v9 + 4 * (result / 3)) = v15;
          if (v16 >= 1023) {
            uint64_t v17 = 1023;
          }
          else {
            uint64_t v17 = v16;
          }
          *(_DWORD *)(v9 + 4 * ((result + 1) / 3)) = ((v17 & ~(v17 >> 63)) << (10 * ((result + 1) % 3))) | dword_193958500[(result + 1) % 3] & *(_DWORD *)(v9 + 4 * ((result + 1) / 3));
          result += 2;
          v12 += 8;
          --v13;
        }
        while (v13);
      }
      ++v8;
      v9 += a8;
      unint64_t v11 = (unsigned __int16 *)((char *)v11 + a4);
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t CopyYCC444_to_CbCr444_10packed(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, float a11)
{
  if (a3)
  {
    uint64_t v11 = 0;
    uint64_t v12 = a5 + a8 * a7;
    uint64_t v13 = 2 * a6;
    uint64_t v14 = (_WORD *)(result + 4);
    do
    {
      uint64_t v15 = a2;
      uint64_t v16 = v14;
      for (uint64_t i = v13; v15; --v15)
      {
        LOWORD(a11) = *(v16 - 1);
        float v18 = (float)((float)LODWORD(a11) * 1023.0) / 65535.0;
        uint64_t v19 = llroundf(v18);
        if (v19 >= 1023) {
          uint64_t v19 = 1023;
        }
        LOWORD(v1_Block_object_dispose(&STACK[0x238], 8) = *v16;
        a11 = (float)((float)LODWORD(v18) * 1023.0) / 65535.0;
        uint64_t v20 = llroundf(a11);
        *(_DWORD *)(v12 + 4 * (i / 3)) = ((v19 & ~(v19 >> 63)) << (10 * (i % 3))) | dword_193958500[i % 3] & *(_DWORD *)(v12 + 4 * (i / 3));
        if (v20 >= 1023) {
          uint64_t v21 = 1023;
        }
        else {
          uint64_t v21 = v20;
        }
        uint64_t result = ((v21 & ~(v21 >> 63)) << (10 * ((i + 1) % 3))) | dword_193958500[(i + 1) % 3] & *(_DWORD *)(v12 + 4 * ((i + 1) / 3));
        *(_DWORD *)(v12 + 4 * ((i + 1) / 3)) = result;
        i += 2;
        v16 += 4;
      }
      ++v11;
      v12 += a8;
      uint64_t v14 = (_WORD *)((char *)v14 + a4);
    }
    while (v11 != a3);
  }
  return result;
}

uint64_t CopyYCC_A2BGR10_to_Y_10p(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3)
  {
    for (uint64_t i = 0; i != a3; ++i)
    {
      if (a2)
      {
        for (uint64_t j = 0; j != a2; ++j)
          *(_DWORD *)(a5 + (((i + a7) * a8) & 0xFFFFFFFFFFFFFFFCLL) + 4 * ((a6 + j) / 3)) = dword_193958500[(a6 + j) % 3] & *(_DWORD *)(a5 + (((i + a7) * a8) & 0xFFFFFFFFFFFFFFFCLL) + 4 * ((a6 + j) / 3)) | ((*(_DWORD *)(result + 4 * j) & 0x3FF) << (10 * ((char)(a6 + j) % 3)));
      }
      result += a4;
    }
  }
  return result;
}

uint64_t CopyYCC_A2BGR10_to_CbCr_10p(uint64_t result, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 >= 2)
  {
    uint64_t v8 = 0;
    uint64_t v9 = result + a4;
    uint64_t v10 = a2 >> 1;
    uint64_t v11 = 2 * a4;
    if (a2 >> 1 <= 1) {
      uint64_t v10 = 1;
    }
    uint64_t v12 = 2 * a6;
    do
    {
      if (a2 >= 2)
      {
        uint64_t v13 = 0;
        if (a3 - 1 <= 2 * v8) {
          uint64_t v14 = result;
        }
        else {
          uint64_t v14 = v9;
        }
        uint64_t v15 = v10;
        do
        {
          uint64_t v16 = (unsigned int *)(result + 4 * v13);
          uint64_t v17 = (unsigned int *)(v14 + 4 * v13);
          unsigned int v18 = *v16;
          LODWORD(v16) = v16[1];
          unsigned int v19 = *v17;
          LODWORD(v17) = v17[1];
          *(_DWORD *)(a5 + (((v8 + a7) * a8) & 0xFFFFFFFFFFFFFFFCLL) + 4 * ((v12 + v13) / 3)) = ((((v18 >> 10) & 0x3FF)
                                                                                                + ((v16 >> 10) & 0x3FF)
                                                                                                + ((v19 >> 10) & 0x3FF)
                                                                                                + ((v17 >> 10) & 0x3FF)
                                                                                                + 2) >> 2 << (10 * ((char)(v12 + v13) % 3))) | dword_193958500[(v12 + v13) % 3] & *(_DWORD *)(a5 + (((v8 + a7) * a8) & 0xFFFFFFFFFFFFFFFCLL) + 4 * ((v12 + v13) / 3));
          uint64_t v20 = v12 + v13 + 1;
          *(_DWORD *)(a5 + (((v8 + a7) * a8) & 0xFFFFFFFFFFFFFFFCLL) + 4 * (v20 / 3)) = dword_193958500[v20 % 3] & *(_DWORD *)(a5 + (((v8 + a7) * a8) & 0xFFFFFFFFFFFFFFFCLL) + 4 * (v20 / 3)) | ((((v18 >> 20) & 0x3FF) + ((v16 >> 20) & 0x3FF) + ((v19 >> 20) & 0x3FF) + ((v17 >> 20) & 0x3FF) + 2) >> 2 << (10 * (v20 % 3)));
          v13 += 2;
          --v15;
        }
        while (v15);
      }
      ++v8;
      result += v11;
      v9 += v11;
    }
    while (v8 != a3 >> 1);
  }
  return result;
}

uint64_t CopyYCC_A2BGR10_to_CbCr422_10p(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3)
  {
    uint64_t v8 = 0;
    uint64_t v9 = a5 + a8 * a7;
    uint64_t v10 = a2 >> 1;
    if (a2 >> 1 <= 1) {
      uint64_t v10 = 1;
    }
    uint64_t v11 = 2 * a6;
    do
    {
      if (a2 >= 2)
      {
        uint64_t v12 = 0;
        uint64_t v13 = v10;
        do
        {
          uint64_t v14 = (unsigned int *)(result + 4 * v12);
          unsigned int v15 = *v14;
          LODWORD(v14) = v14[1];
          uint64_t v16 = (v11 + v12) / 3;
          *(_DWORD *)(v9 + 4 * v16) = ((((v15 >> 10) & 0x3FF) + ((v14 >> 10) & 0x3FF) + 1) >> 1 << (10 * (v11 + v12 - 3 * v16))) | dword_193958500[v11 + v12 - 3 * v16] & *(_DWORD *)(v9 + 4 * v16);
          uint64_t v17 = v11 + v12 + 1;
          *(_DWORD *)(v9 + 4 * (v17 / 3)) = dword_193958500[v17 % 3] & *(_DWORD *)(v9 + 4 * (v17 / 3)) | ((((v15 >> 20) & 0x3FF) + ((v14 >> 20) & 0x3FF) + 1) >> 1 << (10 * (v17 % 3)));
          v12 += 2;
          --v13;
        }
        while (v13);
      }
      ++v8;
      result += a4;
      v9 += a8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t CopyYCC_A2BGR10_to_CbCr444_10p(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3)
  {
    uint64_t v8 = 0;
    uint64_t v9 = a5 + a8 * a7;
    do
    {
      if (a2)
      {
        uint64_t v10 = 0;
        uint64_t v11 = 2 * a6;
        do
        {
          unsigned int v12 = *(_DWORD *)(result + 4 * v10);
          *(_DWORD *)(v9 + 4 * (v11 / 3)) = dword_193958500[v11 % 3] & *(_DWORD *)(v9 + 4 * (v11 / 3)) | (((v12 >> 10) & 0x3FF) << (10 * (v11 % 3)));
          *(_DWORD *)(v9 + 4 * ((v11 + 1) / 3)) = dword_193958500[(v11 + 1) % 3] & *(_DWORD *)(v9 + 4 * ((v11 + 1) / 3)) | (((v12 >> 20) & 0x3FF) << (10 * ((char)(v11 + 1) % 3)));
          ++v10;
          v11 += 2;
        }
        while (a2 != v10);
      }
      ++v8;
      result += a4;
      v9 += a8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t CopyYCC_A2RGB10_to_Y_10p(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3)
  {
    for (uint64_t i = 0; i != a3; ++i)
    {
      if (a2)
      {
        for (uint64_t j = 0; j != a2; ++j)
          *(_DWORD *)(a5 + (((i + a7) * a8) & 0xFFFFFFFFFFFFFFFCLL) + 4 * ((a6 + j) / 3)) = dword_193958500[(a6 + j) % 3] & *(_DWORD *)(a5 + (((i + a7) * a8) & 0xFFFFFFFFFFFFFFFCLL) + 4 * ((a6 + j) / 3)) | (((*(_DWORD *)(result + 4 * j) >> 20) & 0x3FF) << (10 * ((char)(a6 + j) % 3)));
      }
      result += a4;
    }
  }
  return result;
}

uint64_t CopyYCC_A2RGB10_to_CbCr_10p(uint64_t result, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 >= 2)
  {
    uint64_t v8 = 0;
    uint64_t v9 = result + a4;
    uint64_t v10 = a2 >> 1;
    uint64_t v11 = 2 * a4;
    if (a2 >> 1 <= 1) {
      uint64_t v10 = 1;
    }
    uint64_t v12 = 2 * a6;
    do
    {
      if (a2 >= 2)
      {
        uint64_t v13 = 0;
        if (a3 - 1 <= 2 * v8) {
          uint64_t v14 = result;
        }
        else {
          uint64_t v14 = v9;
        }
        uint64_t v15 = v10;
        do
        {
          uint64_t v16 = (unsigned int *)(result + 4 * v13);
          uint64_t v17 = (unsigned int *)(v14 + 4 * v13);
          unsigned int v18 = *v16;
          LODWORD(v16) = v16[1];
          unsigned int v19 = *v17;
          LODWORD(v17) = v17[1];
          *(_DWORD *)(a5 + (((v8 + a7) * a8) & 0xFFFFFFFFFFFFFFFCLL) + 4 * ((v12 + v13) / 3)) = ((((v18 >> 10) & 0x3FF)
                                                                                                + ((v16 >> 10) & 0x3FF)
                                                                                                + ((v19 >> 10) & 0x3FF)
                                                                                                + ((v17 >> 10) & 0x3FF)
                                                                                                + 2) >> 2 << (10 * ((char)(v12 + v13) % 3))) | dword_193958500[(v12 + v13) % 3] & *(_DWORD *)(a5 + (((v8 + a7) * a8) & 0xFFFFFFFFFFFFFFFCLL) + 4 * ((v12 + v13) / 3));
          uint64_t v20 = v12 + v13 + 1;
          *(_DWORD *)(a5 + (((v8 + a7) * a8) & 0xFFFFFFFFFFFFFFFCLL) + 4 * (v20 / 3)) = dword_193958500[v20 % 3] & *(_DWORD *)(a5 + (((v8 + a7) * a8) & 0xFFFFFFFFFFFFFFFCLL) + 4 * (v20 / 3)) | (((v18 & 0x3FF) + ((unsigned __int16)v16 & 0x3FF) + (v19 & 0x3FF) + ((unsigned __int16)v17 & 0x3FF) + 2) >> 2 << (10 * (v20 % 3)));
          v13 += 2;
          --v15;
        }
        while (v15);
      }
      ++v8;
      result += v11;
      v9 += v11;
    }
    while (v8 != a3 >> 1);
  }
  return result;
}

uint64_t CopyYCC_A2RGB10_to_CbCr422_10p(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3)
  {
    uint64_t v8 = 0;
    uint64_t v9 = a5 + a8 * a7;
    uint64_t v10 = a2 >> 1;
    if (a2 >> 1 <= 1) {
      uint64_t v10 = 1;
    }
    uint64_t v11 = 2 * a6;
    do
    {
      if (a2 >= 2)
      {
        uint64_t v12 = 0;
        uint64_t v13 = v10;
        do
        {
          uint64_t v14 = (unsigned int *)(result + 4 * v12);
          unsigned int v15 = *v14;
          LODWORD(v14) = v14[1];
          uint64_t v16 = (v11 + v12) / 3;
          *(_DWORD *)(v9 + 4 * v16) = ((((v15 >> 10) & 0x3FF) + ((v14 >> 10) & 0x3FF) + 1) >> 1 << (10 * (v11 + v12 - 3 * v16))) | dword_193958500[v11 + v12 - 3 * v16] & *(_DWORD *)(v9 + 4 * v16);
          *(_DWORD *)(v9 + 4 * ((v11 + v12 + 1) / 3)) = dword_193958500[(v11 + v12 + 1) % 3] & *(_DWORD *)(v9 + 4 * ((v11 + v12 + 1) / 3)) | (((v15 & 0x3FF) + ((unsigned __int16)v14 & 0x3FF) + 1) >> 1 << (10 * ((v11 + v12 + 1) % 3)));
          v12 += 2;
          --v13;
        }
        while (v13);
      }
      ++v8;
      result += a4;
      v9 += a8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t CopyYCC_A2RGB10_to_CbCr444_10p(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3)
  {
    uint64_t v8 = 0;
    uint64_t v9 = a5 + a8 * a7;
    do
    {
      if (a2)
      {
        uint64_t v10 = 0;
        uint64_t v11 = 2 * a6;
        do
        {
          unsigned int v12 = *(_DWORD *)(result + 4 * v10);
          *(_DWORD *)(v9 + 4 * (v11 / 3)) = dword_193958500[v11 % 3] & *(_DWORD *)(v9 + 4 * (v11 / 3)) | (((v12 >> 10) & 0x3FF) << (10 * (v11 % 3)));
          *(_DWORD *)(v9 + 4 * ((v11 + 1) / 3)) = dword_193958500[(v11 + 1) % 3] & *(_DWORD *)(v9 + 4 * ((v11 + 1) / 3)) | ((v12 & 0x3FF) << (10 * ((char)(v11 + 1) % 3)));
          ++v10;
          v11 += 2;
        }
        while (a2 != v10);
      }
      ++v8;
      result += a4;
      v9 += a8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t CopyYCC444_to_Y_half(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3)
  {
    for (uint64_t i = 0; i != a3; ++i)
    {
      if (a2)
      {
        uint64_t v9 = (_WORD *)(a5 + 2 * a6 + (((i + a7) * a8) & 0xFFFFFFFFFFFFFFFELL));
        uint64_t v10 = (__int16 *)(result + ((i * a4) & 0xFFFFFFFFFFFFFFFELL));
        uint64_t v11 = a2;
        do
        {
          __int16 v12 = *v10;
          v10 += 4;
          *v9++ = v12;
          --v11;
        }
        while (v11);
      }
    }
  }
  return result;
}

short float *CopyYCC444_to_CbCr_half(short float *result, unint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 >= 2)
  {
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    unint64_t v10 = a3 >> 1;
    unint64_t v11 = a3 - 1;
    uint64_t v12 = a4 >> 1;
    uint64_t v13 = a2 >> 1;
    if (a2 >> 1 <= 1) {
      uint64_t v13 = 1;
    }
    uint64_t v14 = result + 6;
    uint64_t v15 = 2 * a4;
    LOWORD(v16) = COERCE_UNSIGNED_INT(0.25);
    do
    {
      if (a2 >= 2)
      {
        uint64_t v17 = (short float *)((char *)v14 + (v8 & 0xFFFFFFFFFFFFFFFELL));
        uint64_t result = (short float *)(a5 + 4 * a6 + (((v9 + a7) * a8) & 0xFFFFFFFFFFFFFFFELL));
        if (v11 <= 2 * v9) {
          uint64_t v18 = 0;
        }
        else {
          uint64_t v18 = v12;
        }
        uint64_t v19 = v18;
        uint64_t v20 = v13;
        do
        {
          *uint64_t result = (short float)((short float)((short float)(*(v17 - 5) + *(v17 - 1)) + v17[v19 - 5]) + v17[v19 - 1])
                  * v16;
          result[1] = (short float)((short float)((short float)(*(v17 - 4) + *v17) + v17[v19 - 4]) + v17[v19]) * v16;
          v17 += 8;
          result += 2;
          --v20;
        }
        while (v20);
      }
      ++v9;
      v8 += v15;
    }
    while (v9 != v10);
  }
  return result;
}

uint64_t CopyYCC444_to_CbCr422_half(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3)
  {
    uint64_t v8 = 0;
    uint64_t v9 = a2 >> 1;
    if (a2 >> 1 <= 1) {
      uint64_t v9 = 1;
    }
    unint64_t v10 = (short float *)(result + 10);
    uint64_t v11 = a8 * a7 + 4 * a6 + a5 + 2;
    LOWORD(v12) = COERCE_UNSIGNED_INT(0.5);
    do
    {
      uint64_t v13 = v9;
      uint64_t v14 = (short float *)v11;
      uint64_t v15 = v10;
      if (a2 >= 2)
      {
        do
        {
          *(v14 - 1) = (short float)(*(v15 - 4) + *v15) * v12;
          *uint64_t v14 = (short float)(*(v15 - 3) + v15[1]) * v12;
          v15 += 8;
          v14 += 2;
          --v13;
        }
        while (v13);
      }
      ++v8;
      unint64_t v10 = (short float *)((char *)v10 + a4);
      v11 += a8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t CopyYCC444_to_CbCr444_half(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3)
  {
    uint64_t v8 = 0;
    uint64_t v9 = a8 * a7 + 4 * a6 + a5 + 2;
    unint64_t v10 = (_WORD *)(result + 4);
    do
    {
      uint64_t v11 = v10;
      short float v12 = (_WORD *)v9;
      for (uint64_t i = a2; i; --i)
      {
        *(v12 - 1) = *(v11 - 1);
        *short float v12 = *v11;
        v12 += 2;
        v11 += 4;
      }
      ++v8;
      v9 += a8;
      unint64_t v10 = (_WORD *)((char *)v10 + a4);
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t ClearSurface(__IOSurface *a1)
{
  signed int PixelFormat = IOSurfaceGetPixelFormat(a1);
  int v3 = 0;
  if (PixelFormat <= 1937125935)
  {
    if (PixelFormat > 1882468911)
    {
      if (PixelFormat > 1885745713)
      {
        if (PixelFormat > 1936077359)
        {
          if (PixelFormat == 1936077360 || PixelFormat == 1936077362) {
            goto LABEL_65;
          }
          int v5 = 1936077876;
          goto LABEL_34;
        }
        if (PixelFormat != 1885745714)
        {
          int v10 = 1885746228;
LABEL_52:
          if (PixelFormat != v10) {
            goto LABEL_86;
          }
          goto LABEL_69;
        }
LABEL_70:
        v16[0] = MEMORY[0x1E4F143A8];
        v16[1] = 0x40000000;
        v16[2] = __ClearSurface_block_invoke_7;
        void v16[3] = &__block_descriptor_tmp_11_2;
        int v17 = v3;
        uint64_t v9 = v16;
        return SurfaceApplyPlaneBlock(a1, (uint64_t)v9);
      }
      if (PixelFormat > 1882469427)
      {
        if (PixelFormat != 1882469428)
        {
          if (PixelFormat != 1885745712) {
            goto LABEL_86;
          }
          goto LABEL_70;
        }
      }
      else if (PixelFormat != 1882468912)
      {
        int v10 = 1882468914;
        goto LABEL_52;
      }
LABEL_69:
      int v3 = (PixelFormat != 1885746228) << 6;
      goto LABEL_70;
    }
    if (PixelFormat > 875704933)
    {
      if (PixelFormat > 875836517)
      {
        if (PixelFormat == 875836518)
        {
LABEL_79:
          int v3 = 16 * (PixelFormat != 875836518);
          goto LABEL_80;
        }
        int v13 = 875836534;
LABEL_78:
        if (PixelFormat != v13) {
          goto LABEL_86;
        }
        goto LABEL_79;
      }
      if (PixelFormat != 875704934)
      {
        unsigned __int16 v12 = 12918;
LABEL_60:
        int v13 = v12 | 0x34320000;
        goto LABEL_78;
      }
    }
    else
    {
      if (PixelFormat <= 875704421)
      {
        if (PixelFormat != 846624102)
        {
          int v6 = 846624121;
LABEL_23:
          if (PixelFormat == v6) {
            goto LABEL_24;
          }
LABEL_86:
          uint64_t v15 = &__block_literal_global_14_0;
          goto LABEL_83;
        }
LABEL_24:
        BOOL v7 = PixelFormat == 2037741171 || PixelFormat == 846624121;
        v24[0] = MEMORY[0x1E4F143A8];
        v24[1] = 0x40000000;
        void v24[2] = __ClearSurface_block_invoke_2;
        v24[3] = &__block_descriptor_tmp_4_1;
        if (v7) {
          int v8 = 16;
        }
        else {
          int v8 = 0;
        }
        int v25 = v8;
        signed int v26 = PixelFormat;
        uint64_t v9 = v24;
        return SurfaceApplyPlaneBlock(a1, (uint64_t)v9);
      }
      if (PixelFormat != 875704422)
      {
        unsigned __int16 v12 = 12406;
        goto LABEL_60;
      }
    }
LABEL_80:
    v27[0] = MEMORY[0x1E4F143A8];
    v27[1] = 0x40000000;
    v27[2] = __ClearSurface_block_invoke;
    void v27[3] = &__block_descriptor_tmp_3_2;
    int v28 = v3;
    uint64_t v9 = v27;
    return SurfaceApplyPlaneBlock(a1, (uint64_t)v9);
  }
  if (PixelFormat <= 2016686639)
  {
    if (PixelFormat > 1952854577)
    {
      if (PixelFormat <= 1953903151)
      {
        if (PixelFormat == 1952854578)
        {
LABEL_49:
          v20[0] = MEMORY[0x1E4F143A8];
          v20[1] = 0x40000000;
          v20[2] = __ClearSurface_block_invoke_5;
          void v20[3] = &__block_descriptor_tmp_9;
          int v21 = v3;
          uint64_t v9 = v20;
          return SurfaceApplyPlaneBlock(a1, (uint64_t)v9);
        }
        int v4 = 1952855092;
      }
      else
      {
        if (PixelFormat == 1953903152 || PixelFormat == 1953903154) {
          goto LABEL_48;
        }
        int v4 = 1953903668;
      }
      if (PixelFormat == v4)
      {
LABEL_48:
        int v3 = (PixelFormat != 1952855092) << 8;
        goto LABEL_49;
      }
      goto LABEL_86;
    }
    if (PixelFormat > 1937126451)
    {
      if (PixelFormat != 1937126452)
      {
        if (PixelFormat == 1952854576) {
          goto LABEL_49;
        }
        goto LABEL_86;
      }
    }
    else if (PixelFormat != 1937125936)
    {
      int v5 = 1937125938;
LABEL_34:
      if (PixelFormat != v5) {
        goto LABEL_86;
      }
    }
    int v3 = (PixelFormat != 1936077876) << 12;
LABEL_65:
    v18[0] = MEMORY[0x1E4F143A8];
    v18[1] = 0x40000000;
    void v18[2] = __ClearSurface_block_invoke_6;
    void v18[3] = &__block_descriptor_tmp_10;
    int v19 = v3;
    uint64_t v9 = v18;
    return SurfaceApplyPlaneBlock(a1, (uint64_t)v9);
  }
  if (PixelFormat <= 2019963441)
  {
    if (PixelFormat > 2016687155)
    {
      if (PixelFormat != 2016687156)
      {
        if (PixelFormat != 2019963440) {
          goto LABEL_86;
        }
        goto LABEL_75;
      }
    }
    else if (PixelFormat != 2016686640)
    {
      int v11 = 2016686642;
      goto LABEL_56;
    }
LABEL_74:
    int v3 = (PixelFormat != 2019963956) << 6;
    goto LABEL_75;
  }
  if (PixelFormat <= 2033463351)
  {
    if (PixelFormat != 2019963442)
    {
      int v11 = 2019963956;
LABEL_56:
      if (PixelFormat != v11) {
        goto LABEL_86;
      }
      goto LABEL_74;
    }
LABEL_75:
    v22[0] = MEMORY[0x1E4F143A8];
    v22[1] = 0x40000000;
    void v22[2] = __ClearSurface_block_invoke_4;
    v22[3] = &__block_descriptor_tmp_8_1;
    int v23 = v3;
    uint64_t v9 = v22;
    return SurfaceApplyPlaneBlock(a1, (uint64_t)v9);
  }
  if (PixelFormat != 2033463352)
  {
    if (PixelFormat != 2037741158)
    {
      int v6 = 2037741171;
      goto LABEL_23;
    }
    goto LABEL_24;
  }
  uint64_t v15 = &__block_literal_global_7_1;
LABEL_83:

  return SurfaceApplyPlaneBlock(a1, (uint64_t)v15);
}

void *__ClearSurface_block_invoke(uint64_t a1, void *__b, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a3) {
    int v7 = 128;
  }
  else {
    int v7 = *(_DWORD *)(a1 + 32);
  }
  return memset(__b, v7, a6 * a5);
}

void __ClearSurface_block_invoke_2(uint64_t a1, void *__b, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  char __pattern4 = 0x80;
  char v12 = *(unsigned char *)(a1 + 32);
  char v13 = 0x80;
  char v14 = v12;
  v10[0] = v12;
  v10[1] = 0x80;
  v10[2] = v12;
  _OWORD v10[3] = 0x80;
  int v6 = *(_DWORD *)(a1 + 36);
  if (v6 <= 2037741157)
  {
    if (v6 != 846624102 && v6 != 846624121) {
      return;
    }
    p_pattern4 = &__pattern4;
LABEL_14:
    memset_pattern4(__b, p_pattern4, a6 * a5);
    return;
  }
  if (v6 == 2037741171 || v6 == 2037741158)
  {
    p_pattern4 = v10;
    goto LABEL_14;
  }
}

void __ClearSurface_block_invoke_3(int a1, void *__b, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
}

void __ClearSurface_block_invoke_4(uint64_t a1, void *__b, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a3) {
    int v6 = -2147450880;
  }
  else {
    int v6 = ((*(_DWORD *)(a1 + 32) & 0x3FF) << 6) | (*(_DWORD *)(a1 + 32) << 22);
  }
  int __pattern4 = v6;
  memset_pattern4(__b, &__pattern4, a6 * a5);
}

void __ClearSurface_block_invoke_5(uint64_t a1, void *__b, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a3) {
    int v6 = -2147450880;
  }
  else {
    int v6 = (16 * (*(_DWORD *)(a1 + 32) & 0xFFF)) | (*(_DWORD *)(a1 + 32) << 20);
  }
  int __pattern4 = v6;
  memset_pattern4(__b, &__pattern4, a6 * a5);
}

void __ClearSurface_block_invoke_6(uint64_t a1, void *__b, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a3) {
    int v6 = -2147450880;
  }
  else {
    int v6 = *(unsigned __int16 *)(a1 + 32) | (*(unsigned __int16 *)(a1 + 32) << 16);
  }
  int __pattern4 = v6;
  memset_pattern4(__b, &__pattern4, a6 * a5);
}

void __ClearSurface_block_invoke_7(uint64_t a1, void *__b, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a3) {
    int v6 = 537395712;
  }
  else {
    int v6 = (*(_DWORD *)(a1 + 32) << 10) | (*(_DWORD *)(a1 + 32) << 20) | *(_DWORD *)(a1 + 32);
  }
  int __pattern4 = v6;
  memset_pattern4(__b, &__pattern4, a6 * a5);
}

void __ClearSurface_block_invoke_8(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
}

unint64_t CreateSurfaceMemorySize(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v7 = equivalent_uncompressed_format(a4);
  unint64_t result = 0;
  if (!a1 || !a2 || !v7) {
    return result;
  }
  if (is_biplanar(v7))
  {
    int v9 = equivalent_uncompressed_format(v7);
    if (v9 <= 1936077875)
    {
      if (v9 <= 1751528499)
      {
        unint64_t v10 = a1;
        if (v9 == 875836518) {
          goto LABEL_24;
        }
        int v11 = 875836534;
      }
      else
      {
        unint64_t v10 = a1;
        if (v9 == 1751528500) {
          goto LABEL_24;
        }
        unint64_t v10 = a1;
        if (v9 == 1882469428) {
          goto LABEL_24;
        }
        int v11 = 1885746228;
      }
    }
    else if (v9 > 1953903667)
    {
      unint64_t v10 = a1;
      if (v9 == 1953903668) {
        goto LABEL_24;
      }
      unint64_t v10 = a1;
      if (v9 == 2016687156) {
        goto LABEL_24;
      }
      int v11 = 2019963956;
    }
    else
    {
      unint64_t v10 = a1;
      if (v9 == 1936077876) {
        goto LABEL_24;
      }
      unint64_t v10 = a1;
      if (v9 == 1937126452) {
        goto LABEL_24;
      }
      int v11 = 1952855092;
    }
    unint64_t v10 = a1;
    if (v9 != v11) {
      unint64_t v10 = (unint64_t)(a1 + 1) >> 1;
    }
LABEL_24:
    if (v9 <= 1936077359)
    {
      if (v9 <= 1751527983)
      {
        if (v9 == 875704422) {
          goto LABEL_39;
        }
        int v14 = 875704438;
      }
      else
      {
        if (v9 == 1751527984 || v9 == 1882468912) {
          goto LABEL_39;
        }
        int v14 = 1885745712;
      }
    }
    else if (v9 > 1953903151)
    {
      if (v9 == 1953903152 || v9 == 2019963440) {
        goto LABEL_39;
      }
      int v14 = 2016686640;
    }
    else
    {
      if (v9 == 1936077360 || v9 == 1937125936) {
        goto LABEL_39;
      }
      int v14 = 1952854576;
    }
    unint64_t v15 = a2;
    if (v9 != v14)
    {
LABEL_40:
      uint64_t v16 = format_for_plane(v7, 0);
      uint64_t v17 = format_for_plane(v7, 1);
      uint64_t v18 = min_bytes_per_row(v16, a1);
      uint64_t v19 = min_bytes_per_row(v17, v10);
      unint64_t v20 = 32;
      if (a3) {
        unint64_t v20 = a3;
      }
      return (v20 - 1 + v18) / v20 * v20 * a2 + (v20 - 1 + v19) / v20 * v20 * v15;
    }
LABEL_39:
    unint64_t v15 = (a2 + 1) >> 1;
    goto LABEL_40;
  }
  uint64_t v12 = min_bytes_per_row(v7, a1);
  unint64_t v13 = 32;
  if (a3) {
    unint64_t v13 = a3;
  }
  return (v13 + v12 - 1) / v13 * v13 * a2;
}

uint64_t is_biplanar(uint64_t a1)
{
  uint64_t v1 = equivalent_uncompressed_format(a1);
  int v2 = equivalent_uncompressed_format(v1);
  uint64_t result = 1;
  if (v2 <= 1936077361)
  {
    if (v2 <= 1751528499)
    {
      if (v2 > 875836517)
      {
        if (v2 > 1751527983)
        {
          if (v2 == 1751527984) {
            return result;
          }
          int v4 = 1751527986;
        }
        else
        {
          if (v2 == 875836518) {
            return result;
          }
          int v4 = 875836534;
        }
      }
      else
      {
        if (v2 > 875704933)
        {
          if (v2 == 875704934) {
            return result;
          }
          unsigned __int16 v5 = 12918;
        }
        else
        {
          if (v2 == 875704422) {
            return result;
          }
          unsigned __int16 v5 = 12406;
        }
        int v4 = v5 | 0x34320000;
      }
      goto LABEL_54;
    }
    if (v2 <= 1885745711)
    {
      if (v2 > 1882468913)
      {
        if (v2 == 1882468914) {
          return result;
        }
        unsigned __int16 v6 = 13364;
      }
      else
      {
        if (v2 == 1751528500) {
          return result;
        }
        unsigned __int16 v6 = 12848;
      }
      int v4 = v6 | 0x70340000;
      goto LABEL_54;
    }
    if (v2 <= 1885746227)
    {
      if (v2 == 1885745712) {
        return result;
      }
      int v4 = 1885745714;
      goto LABEL_54;
    }
    if (v2 == 1885746228) {
      return result;
    }
    unsigned __int16 v7 = 12848;
    goto LABEL_50;
  }
  if (v2 <= 1953903151)
  {
    if (v2 > 1937126451)
    {
      if (v2 > 1952854577)
      {
        if (v2 == 1952854578) {
          return result;
        }
        unsigned __int16 v8 = 13364;
      }
      else
      {
        if (v2 == 1937126452) {
          return result;
        }
        unsigned __int16 v8 = 12848;
      }
      int v4 = v8 | 0x74660000;
      goto LABEL_54;
    }
    if (v2 > 1937125935)
    {
      if (v2 == 1937125936) {
        return result;
      }
      int v4 = 1937125938;
      goto LABEL_54;
    }
    if (v2 == 1936077362) {
      return result;
    }
    unsigned __int16 v7 = 13364;
LABEL_50:
    int v4 = v7 | 0x73660000;
LABEL_54:
    if (v2 != v4) {
      return 0;
    }
    return result;
  }
  if (v2 <= 2016686641)
  {
    if (v2 <= 1953903667)
    {
      if (v2 == 1953903152) {
        return result;
      }
      int v4 = 1953903154;
      goto LABEL_54;
    }
    if (v2 == 1953903668) {
      return result;
    }
    unsigned __int16 v9 = 12848;
    goto LABEL_37;
  }
  if (v2 <= 2019963439)
  {
    if (v2 == 2016686642) {
      return result;
    }
    unsigned __int16 v9 = 13364;
LABEL_37:
    int v4 = v9 | 0x78340000;
    goto LABEL_54;
  }
  if (v2 != 2019963440 && v2 != 2019963442)
  {
    int v4 = 2019963956;
    goto LABEL_54;
  }
  return result;
}

uint64_t format_for_plane(uint64_t a1, int a2)
{
  if ((a1 & 0xFD000000) == 0x2D000000) {
    return 0;
  }
  uint64_t result = 0;
  if ((int)a1 >> 24 == 38 || (int)a1 >> 24 == 124) {
    return result;
  }
  uint64_t result = 826486888;
  if ((int)a1 > 1936077359)
  {
    if ((int)a1 <= 1953903151)
    {
      if ((int)a1 > 1937125937)
      {
        if ((int)a1 > 1952854575)
        {
          if (a1 != 1952854576 && a1 != 1952854578)
          {
            int v4 = 1952855092;
            goto LABEL_38;
          }
          goto LABEL_71;
        }
        if (a1 == 1937125938) {
          goto LABEL_58;
        }
        unsigned __int16 v10 = 13364;
        goto LABEL_56;
      }
      if ((int)a1 > 1936077875)
      {
        if (a1 != 1936077876)
        {
          unsigned __int16 v10 = 12848;
LABEL_56:
          int v7 = v10 | 0x73760000;
LABEL_57:
          if (a1 == v7) {
            goto LABEL_58;
          }
          return a1;
        }
      }
      else if (a1 != 1936077360)
      {
        int v7 = 1936077362;
        goto LABEL_57;
      }
LABEL_58:
      unsigned int v13 = 826487094;
      unsigned int v15 = 843264310;
LABEL_72:
      BOOL v14 = a2 == 0;
LABEL_73:
      if (v14) {
        return v13;
      }
      else {
        return v15;
      }
    }
    if ((int)a1 <= 2016686641)
    {
      if ((int)a1 <= 1953903667)
      {
        if (a1 != 1953903152)
        {
          int v4 = 1953903154;
LABEL_38:
          if (a1 != v4) {
            return a1;
          }
        }
LABEL_71:
        unsigned int v13 = 826487090;
        unsigned int v15 = 843264306;
        goto LABEL_72;
      }
      if (a1 == 1953903668) {
        goto LABEL_71;
      }
      unsigned __int16 v12 = 12848;
    }
    else
    {
      if ((int)a1 > 2019963439)
      {
        if (a1 == 2019963440 || a1 == 2019963442) {
          goto LABEL_70;
        }
        int v5 = 2019963956;
        goto LABEL_69;
      }
      if (a1 == 2016686642) {
        goto LABEL_70;
      }
      unsigned __int16 v12 = 13364;
    }
    int v5 = v12 | 0x78340000;
LABEL_69:
    if (a1 != v5) {
      return a1;
    }
LABEL_70:
    unsigned int v13 = 826487088;
    unsigned int v15 = 843264304;
    goto LABEL_72;
  }
  if ((int)a1 <= 1751528499)
  {
    if ((int)a1 > 875836517)
    {
      if ((int)a1 > 1751527983)
      {
        if (a1 != 1751527984 && a1 != 1751527986) {
          return a1;
        }
        goto LABEL_78;
      }
      if (a1 == 875836518)
      {
LABEL_53:
        unsigned int v13 = 826486840;
        BOOL v14 = a2 == 0;
        unsigned int v15 = 843264056;
        goto LABEL_73;
      }
      int v9 = 875836534;
    }
    else
    {
      if ((int)a1 > 875704933)
      {
        if (a1 == 875704934) {
          goto LABEL_53;
        }
        unsigned __int16 v6 = 12918;
      }
      else
      {
        if (a1 == 875704422) {
          goto LABEL_53;
        }
        unsigned __int16 v6 = 12406;
      }
      int v9 = v6 | 0x34320000;
    }
    if (a1 != v9) {
      return a1;
    }
    goto LABEL_53;
  }
  if ((int)a1 <= 1885745711)
  {
    if ((int)a1 > 1882468913)
    {
      if (a1 == 1882468914) {
        goto LABEL_63;
      }
      unsigned __int16 v8 = 13364;
      goto LABEL_61;
    }
    if (a1 != 1751528500)
    {
      unsigned __int16 v8 = 12848;
LABEL_61:
      int v11 = v8 | 0x70340000;
LABEL_62:
      if (a1 != v11) {
        return a1;
      }
LABEL_63:
      if (a2) {
        return 845361456;
      }
      else {
        return 828584240;
      }
    }
LABEL_78:
    if (a2) {
      return 843264104;
    }
    else {
      return 826486888;
    }
  }
  if ((int)a1 <= 1885746227)
  {
    if (a1 == 1885745712) {
      goto LABEL_63;
    }
    int v11 = 1885745714;
    goto LABEL_62;
  }
  if (a1 == 1885746228) {
    goto LABEL_63;
  }
  if (a1 == 1919365990) {
    return 826486886;
  }
  if (a1 != 1919365992) {
    return a1;
  }
  return result;
}

uint64_t min_bytes_per_row(uint64_t a1, uint64_t a2)
{
  if ((equivalent_uncompressed_format(a1) - 1919365990) & 0xFFFFFFFD) == 0 || (is_biplanar(a1)) {
    return 0;
  }
  uint64_t v5 = 0;
  uint64_t v6 = 1;
  if ((int)a1 > 1279340599)
  {
    if ((int)a1 > 1667844407)
    {
      if ((int)a1 > 1815162993)
      {
        if ((int)a1 > 1999908960)
        {
          if ((int)a1 > 2037741157)
          {
            if (a1 == 2037741158) {
              goto LABEL_92;
            }
            int v10 = 2037741171;
            goto LABEL_91;
          }
          if (a1 != 1999908961)
          {
            int v9 = 2033463352;
            goto LABEL_75;
          }
        }
        else
        {
          if ((int)a1 <= 1815491697)
          {
            if (a1 == 1815162994) {
              goto LABEL_76;
            }
            int v8 = 1815361650;
            goto LABEL_45;
          }
          if (a1 != 1815491698)
          {
            int v9 = 1999843442;
LABEL_75:
            if (a1 != v9) {
              return v5 * a2;
            }
            goto LABEL_76;
          }
        }
        goto LABEL_88;
      }
      if ((int)a1 > 1717855599)
      {
        if ((int)a1 <= 1751410031)
        {
          if (a1 == 1717855600) {
            goto LABEL_76;
          }
          int v9 = 1717856627;
          goto LABEL_75;
        }
        if (a1 == 1751410032) {
          goto LABEL_92;
        }
        int v10 = 1751411059;
        goto LABEL_91;
      }
      if (a1 == 1667844408) {
        goto LABEL_93;
      }
      if (a1 == 1667844454) {
        goto LABEL_76;
      }
      unsigned __int16 v12 = 18792;
LABEL_87:
      int v10 = v12 | 0x63690000;
      goto LABEL_91;
    }
    if ((int)a1 > 1664496753)
    {
      if ((int)a1 <= 1667838821)
      {
        if (a1 != 1664496754)
        {
          if (a1 == 1667838256) {
            goto LABEL_76;
          }
          int v9 = 1667838768;
          goto LABEL_75;
        }
        goto LABEL_88;
      }
      if ((int)a1 <= 1667839023)
      {
        if (a1 == 1667838822)
        {
          uint64_t v6 = 12;
          goto LABEL_93;
        }
        int v8 = 1667838824;
LABEL_45:
        if (a1 != v8) {
          return v5 * a2;
        }
        uint64_t v6 = 6;
        goto LABEL_93;
      }
      if (a1 != 1667839024)
      {
        unsigned __int16 v12 = 18742;
        goto LABEL_87;
      }
    }
    else
    {
      if ((int)a1 > 1279340853)
      {
        if ((int)a1 <= 1380410944)
        {
          if (a1 == 1279340854) {
            goto LABEL_76;
          }
          int v9 = 1380401729;
          goto LABEL_75;
        }
        if (a1 == 1380410945)
        {
          uint64_t v6 = 16;
          goto LABEL_93;
        }
        int v11 = 1380411457;
        goto LABEL_79;
      }
      if (a1 == 1279340600) {
        goto LABEL_92;
      }
      if (a1 != 1279340646)
      {
        int v9 = 1279340648;
        goto LABEL_75;
      }
    }
LABEL_88:
    uint64_t v6 = 8;
    goto LABEL_93;
  }
  if ((int)a1 > 845361455)
  {
    if ((int)a1 > 1094862673)
    {
      if ((int)a1 <= 1278226533)
      {
        if (a1 != 1094862674 && a1 != 1111970369)
        {
          int v7 = 1278226488;
LABEL_22:
          if (a1 != v7) {
            return v5 * a2;
          }
          goto LABEL_93;
        }
        goto LABEL_76;
      }
      if ((a1 - 1278226736) <= 6 && ((1 << (a1 - 48)) & 0x45) != 0) {
        goto LABEL_92;
      }
      if (a1 == 1278226534)
      {
LABEL_76:
        uint64_t v6 = 4;
        goto LABEL_93;
      }
      int v10 = 1278226536;
      goto LABEL_91;
    }
    if ((int)a1 <= 1093677111)
    {
      if (a1 == 845361456)
      {
        a2 *= 2;
        return (2 * (((unint64_t)(a2 + 2) * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64)) & 0xFFFFFFFFFFFFFFFCLL;
      }
      if (a1 == 846624102) {
        goto LABEL_92;
      }
      int v10 = 846624121;
    }
    else
    {
      if ((int)a1 <= 1093677159)
      {
        if (a1 != 1093677112)
        {
          int v9 = 1093677158;
          goto LABEL_75;
        }
LABEL_93:
        uint64_t v5 = v6;
        return v5 * a2;
      }
      if (a1 == 1093677160) {
        goto LABEL_92;
      }
      int v10 = 1093677366;
    }
LABEL_91:
    if (a1 == v10) {
      goto LABEL_92;
    }
    return v5 * a2;
  }
  if ((int)a1 <= 828584239)
  {
    if ((int)a1 <= 826486885)
    {
      if (a1 == 24)
      {
        uint64_t v6 = 3;
        goto LABEL_93;
      }
      if (a1 != 32)
      {
        int v7 = 826486840;
        goto LABEL_22;
      }
      goto LABEL_76;
    }
    if ((a1 - 826487088) > 6 || ((1 << (a1 - 48)) & 0x45) == 0)
    {
      if (a1 != 826486886)
      {
        int v10 = 826486888;
        goto LABEL_91;
      }
      goto LABEL_76;
    }
LABEL_92:
    uint64_t v6 = 2;
    goto LABEL_93;
  }
  if ((int)a1 > 843264103)
  {
    if ((a1 - 843264304) <= 6 && ((1 << (a1 - 48)) & 0x45) != 0) {
      goto LABEL_76;
    }
    int v9 = 843264104;
    goto LABEL_75;
  }
  if (a1 != 828584240)
  {
    if (a1 == 843264056) {
      goto LABEL_92;
    }
    int v11 = 843264102;
LABEL_79:
    if (a1 != v11) {
      return v5 * a2;
    }
    goto LABEL_88;
  }
  return (2 * (((unint64_t)(a2 + 2) * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64)) & 0xFFFFFFFFFFFFFFFCLL;
}

void SurfaceSetYCCMatrix(__IOSurface *a1, int a2)
{
  if (a1)
  {
    OSType PixelFormat = IOSurfaceGetPixelFormat(a1);
    if ((IOSurfaceGetPlaneCount(a1) == 2 || PixelFormat == 2033463352) && (a2 == 709 || a2 == 601))
    {
      if (a2 == 601) {
        uint64_t v5 = (CFTypeRef *)MEMORY[0x1E4F2F2D8];
      }
      else {
        uint64_t v5 = (CFTypeRef *)MEMORY[0x1E4F2F2E0];
      }
      IOSurfaceSetBulkAttachments2();
      IOSurfaceSetValue(a1, (CFStringRef)*MEMORY[0x1E4F2F2C8], *v5);
    }
  }
}

__IOSurface *CreateSurface(__CVBuffer *a1, __CVBuffer *a2, void *a3, uint64_t a4, int a5)
{
  memset(v6, 0, sizeof(v6));
  return CreateCachedSurface(a1, a2, a3, a4, (uint64_t)v6, a5);
}

__IOSurface *CreateCachedSurface(__CVBuffer *a1, __CVBuffer *a2, void *a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v200 = *MEMORY[0x1E4F143B8];
  uint64_t v12 = equivalent_uncompressed_format(a4);
  IOSurface = 0;
  if (a1 && a2 && a4)
  {
    uint64_t v14 = v12;
    uint64_t v15 = min_bytes_per_row(v12, (uint64_t)a1);
    if (((v14 - 1919365990) & 0xFFFFFFFD) == 0 || (int v16 = is_biplanar(a4), v15) || v16)
    {
      int v186 = a3;
      double height = a2;
      uint64_t v17 = v14;
      int v189 = a6;
      if ((a4 & 0xFD000000) != 0x2D000000 && (int)a4 >> 24 != 38 && (int)a4 >> 24 != 124)
      {
        uint64_t v25 = a5;
        uint64_t v22 = (const void *)*MEMORY[0x1E4F2F280];
        uint64_t v28 = a4;
        uint32x2_t v24 = (const void *)*MEMORY[0x1E4F2EFC0];
LABEL_18:
        Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        uint64_t v30 = (const void *)*MEMORY[0x1E4F2F2C0];
        *(void *)&long long valuePtr = a1;
        CFNumberRef v31 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
        CFDictionarySetValue(Mutable, v30, v31);
        CFRelease(v31);
        int v32 = (const void *)*MEMORY[0x1E4F2F0E8];
        *(void *)&long long valuePtr = height;
        CFNumberRef v33 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
        CFDictionarySetValue(Mutable, v32, v33);
        CFRelease(v33);
        uint64_t v34 = (const void *)*MEMORY[0x1E4F2F150];
        LODWORD(valuePtr) = v28;
        CFNumberRef v35 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
        CFDictionarySetValue(Mutable, v34, v35);
        CFRelease(v35);
        uint64_t v36 = (const void *)*MEMORY[0x1E4F2EFE8];
        LODWORD(valuePtr) = *(_DWORD *)v25;
        CFNumberRef v37 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
        CFDictionarySetValue(Mutable, v36, v37);
        CFRelease(v37);
        *(void *)&long long valuePtr = *(void *)(v25 + 8);
        CFNumberRef v38 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
        CFDictionarySetValue(Mutable, v22, v38);
        CFRelease(v38);
        uint64_t v184 = v25;
        *(void *)&long long valuePtr = *(void *)(v25 + 16);
        CFNumberRef v39 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
        theDict = Mutable;
        CFDictionarySetValue(Mutable, v24, v39);
        CFRelease(v39);
        uint64_t v40 = v17;
        if (is_biplanar(v17))
        {
          int v183 = v28;
          int v41 = equivalent_uncompressed_format(v17);
          if (v41 <= 1936077875)
          {
            unint64_t v42 = (unint64_t)height;
            if (v41 <= 1751528499)
            {
              unint64_t v43 = (unint64_t)a1;
              if (v41 == 875836518) {
                goto LABEL_51;
              }
              int v44 = 875836534;
            }
            else
            {
              unint64_t v43 = (unint64_t)a1;
              if (v41 == 1751528500) {
                goto LABEL_51;
              }
              unint64_t v43 = (unint64_t)a1;
              if (v41 == 1882469428) {
                goto LABEL_51;
              }
              int v44 = 1885746228;
            }
          }
          else
          {
            unint64_t v42 = (unint64_t)height;
            if (v41 > 1953903667)
            {
              unint64_t v43 = (unint64_t)a1;
              if (v41 == 1953903668) {
                goto LABEL_51;
              }
              unint64_t v43 = (unint64_t)a1;
              if (v41 == 2016687156) {
                goto LABEL_51;
              }
              int v44 = 2019963956;
            }
            else
            {
              unint64_t v43 = (unint64_t)a1;
              if (v41 == 1936077876) {
                goto LABEL_51;
              }
              unint64_t v43 = (unint64_t)a1;
              if (v41 == 1937126452) {
                goto LABEL_51;
              }
              int v44 = 1952855092;
            }
          }
          unint64_t v43 = (unint64_t)a1;
          if (v41 != v44) {
            unint64_t v43 = ((unint64_t)a1 + 1) >> 1;
          }
LABEL_51:
          if (v41 <= 1936077359)
          {
            if (v41 <= 1751527983)
            {
              if (v41 == 875704422) {
                goto LABEL_66;
              }
              int v57 = 875704438;
            }
            else
            {
              if (v41 == 1751527984 || v41 == 1882468912) {
                goto LABEL_66;
              }
              int v57 = 1885745712;
            }
          }
          else if (v41 > 1953903151)
          {
            if (v41 == 1953903152 || v41 == 2019963440) {
              goto LABEL_66;
            }
            int v57 = 2016686640;
          }
          else
          {
            if (v41 == 1936077360 || v41 == 1937125936) {
              goto LABEL_66;
            }
            int v57 = 1952854576;
          }
          unint64_t v58 = v42;
          if (v41 != v57)
          {
LABEL_67:
            uint64_t v59 = format_for_plane(v40, 0);
            uint64_t v60 = format_for_plane(v40, 1);
            if (((equivalent_uncompressed_format(v59) - 1919365990) & 0xFFFFFFFD) == 0
              || (is_biplanar(v59) & 1) != 0)
            {
              int v61 = 0;
              goto LABEL_70;
            }
            int v61 = 2;
            if ((int)v59 > 846624120)
            {
              if (v59 == 846624121 || v59 == 2037741158) {
                goto LABEL_70;
              }
              int v96 = 2037741171;
            }
            else
            {
              if (v59 == 828584240 || v59 == 845361456)
              {
                int v61 = 3;
                goto LABEL_70;
              }
              int v96 = 846624102;
            }
            if (v59 != v96) {
              int v61 = 1;
            }
LABEL_70:
            int v179 = v61;
            unsigned int v176 = v40;
            if (((equivalent_uncompressed_format(v60) - 1919365990) & 0xFFFFFFFD) == 0
              || (is_biplanar(v60) & 1) != 0)
            {
              int v62 = 0;
LABEL_73:
              int v181 = v62;
              int v177 = bytes_per_element(v60);
              int v169 = bytes_per_element(v59);
              uint64_t v63 = min_bytes_per_row(v59, (uint64_t)a1);
              uint64_t v64 = min_bytes_per_row(v60, v43);
              unint64_t v65 = 32;
              if (v186) {
                unint64_t v65 = (unint64_t)v186;
              }
              uint64_t v171 = (__CVBuffer *)v43;
              float v172 = (__CVBuffer *)v58;
              int v66 = (__CVBuffer *)((v63 + v65 - 1) / v65 * v65);
              uint64_t v187 = (__CVBuffer *)((v64 + v65 - 1) / v65 * v65);
              int v67 = (__CVBuffer *)((void)v66 * v42);
              float v174 = (__CVBuffer *)((void)v187 * v58);
              int v68 = (const void *)*MEMORY[0x1E4F2EFE0];
              *(void *)&long long valuePtr = ((void)v187 * v58 + (void)v66 * v42) / v42;
              CFNumberRef v69 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
              CFDictionarySetValue(theDict, v68, v69);
              CFRelease(v69);
              int v70 = (const void *)*MEMORY[0x1E4F2EFB8];
              *(void *)&long long valuePtr = (void)v187 * v58 + (void)v66 * v42;
              CFNumberRef v71 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
              CFDictionarySetValue(theDict, v70, v71);
              CFRelease(v71);
              int v72 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
              *(void *)&long long valuePtr = v72;
              int v73 = (const void *)*MEMORY[0x1E4F2F258];
              CVPixelBufferRef pixelBufferOut = a1;
              CFNumberRef v74 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
              CFDictionarySetValue(v72, v73, v74);
              CFRelease(v74);
              unsigned int v75 = (const void *)*MEMORY[0x1E4F2F220];
              CVPixelBufferRef pixelBufferOut = (CVPixelBufferRef)v42;
              CFNumberRef v76 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
              CFDictionarySetValue(v72, v75, v76);
              CFRelease(v76);
              int v77 = (const void *)*MEMORY[0x1E4F2F240];
              CVPixelBufferRef pixelBufferOut = 0;
              CFNumberRef v78 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
              CFDictionarySetValue(v72, v77, v78);
              CFRelease(v78);
              int v79 = (const void *)*MEMORY[0x1E4F2F248];
              CVPixelBufferRef pixelBufferOut = v67;
              CFNumberRef v80 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
              CFDictionarySetValue(v72, v79, v80);
              CFRelease(v80);
              int v81 = (const void *)*MEMORY[0x1E4F2F178];
              CVPixelBufferRef pixelBufferOut = v66;
              CFNumberRef v82 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
              CFDictionarySetValue(v72, v81, v82);
              CFRelease(v82);
              unsigned int v83 = (const void *)*MEMORY[0x1E4F2F170];
              LODWORD(pixelBufferOut) = v169;
              CFNumberRef v84 = CFNumberCreate(0, kCFNumberIntType, &pixelBufferOut);
              CFDictionarySetValue(v72, v83, v84);
              CFRelease(v84);
              int v85 = (const void *)*MEMORY[0x1E4F2F1F0];
              LODWORD(pixelBufferOut) = v179;
              CFNumberRef v86 = CFNumberCreate(0, kCFNumberIntType, &pixelBufferOut);
              CFDictionarySetValue(v72, v85, v86);
              CFRelease(v86);
              double v87 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
              *((void *)&valuePtr + 1) = v87;
              CVPixelBufferRef pixelBufferOut = v171;
              CFNumberRef v88 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
              CFDictionarySetValue(v87, v73, v88);
              CFRelease(v88);
              CVPixelBufferRef pixelBufferOut = v172;
              CFNumberRef v89 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
              CFDictionarySetValue(v87, v75, v89);
              CFRelease(v89);
              CVPixelBufferRef pixelBufferOut = v67;
              CFNumberRef v90 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
              CFDictionarySetValue(v87, v77, v90);
              CFRelease(v90);
              CVPixelBufferRef pixelBufferOut = v174;
              CFNumberRef v91 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
              CFDictionarySetValue(v87, v79, v91);
              CFRelease(v91);
              CVPixelBufferRef pixelBufferOut = v187;
              CFNumberRef v92 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
              CFDictionarySetValue(v87, v81, v92);
              CFRelease(v92);
              LODWORD(pixelBufferOut) = v177;
              CFNumberRef v93 = CFNumberCreate(0, kCFNumberIntType, &pixelBufferOut);
              CFDictionarySetValue(v87, v83, v93);
              CFRelease(v93);
              LODWORD(pixelBufferOut) = v181;
              CFNumberRef v94 = CFNumberCreate(0, kCFNumberIntType, &pixelBufferOut);
              CFDictionaryRef v49 = theDict;
              CFDictionarySetValue(v87, v85, v94);
              CFRelease(v94);
              CFArrayRef v95 = CFArrayCreate(0, (const void **)&valuePtr, 2, MEMORY[0x1E4F1D510]);
              CFDictionarySetValue(theDict, (const void *)*MEMORY[0x1E4F2F238], v95);
              CFRelease(v95);
              CFRelease((CFTypeRef)valuePtr);
              CFRelease(*((CFTypeRef *)&valuePtr + 1));
              int v45 = v183;
              uint64_t v40 = v176;
              goto LABEL_119;
            }
            int v62 = 2;
            if ((int)v60 > 846624120)
            {
              if (v60 == 846624121 || v60 == 2037741158) {
                goto LABEL_73;
              }
              int v97 = 2037741171;
            }
            else
            {
              if (v60 == 828584240 || v60 == 845361456)
              {
                int v62 = 3;
                goto LABEL_73;
              }
              int v97 = 846624102;
            }
            if (v60 != v97) {
              int v62 = 1;
            }
            goto LABEL_73;
          }
LABEL_66:
          unint64_t v58 = (v42 + 1) >> 1;
          goto LABEL_67;
        }
        int v45 = v28;
        if (((equivalent_uncompressed_format(v28) - 1919365990) & 0xFFFFFFFD) != 0)
        {
          unint64_t v46 = 32;
          if (v186) {
            unint64_t v46 = (unint64_t)v186;
          }
          uint64_t v47 = (const void *)*MEMORY[0x1E4F2EFE0];
          *(void *)&long long valuePtr = (v46 + v15 - 1) / v46 * v46;
          CFNumberRef v48 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
          CFDictionaryRef v49 = theDict;
          CFDictionarySetValue(theDict, v47, v48);
          CFRelease(v48);
          if (((equivalent_uncompressed_format(v17) - 1919365990) & 0xFFFFFFFD) == 0) {
            goto LABEL_118;
          }
          int v50 = 2;
          if ((int)v17 > 846624120)
          {
            if (v17 != 846624121 && v17 != 2037741158)
            {
              int v51 = 2037741171;
LABEL_45:
              if (v17 != v51) {
                goto LABEL_118;
              }
            }
          }
          else
          {
            if (v17 != 828584240 && v17 != 845361456)
            {
              int v51 = 846624102;
              goto LABEL_45;
            }
            int v50 = 3;
          }
          setIntValue(theDict, (const void *)*MEMORY[0x1E4F2F0A0], v50);
LABEL_118:
          int v147 = bytes_per_element(v17);
          int v148 = (const void *)*MEMORY[0x1E4F2EFD8];
          LODWORD(valuePtr) = v147;
          CFNumberRef v149 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
          CFDictionarySetValue(theDict, v148, v149);
          CFRelease(v149);
          goto LABEL_119;
        }
        uint64_t v52 = format_for_plane(v17, 0);
        uint64_t v53 = format_for_plane(v17, 1);
        uint64_t v54 = format_for_plane(v17, 2);
        if (((equivalent_uncompressed_format(v52) - 1919365990) & 0xFFFFFFFD) == 0)
        {
          int v56 = 0;
          int v55 = height;
          goto LABEL_95;
        }
        int v55 = height;
        if (is_biplanar(v52))
        {
          int v56 = 0;
          goto LABEL_95;
        }
        int v56 = 2;
        if ((int)v52 > 846624120)
        {
          if (v52 == 846624121 || v52 == 2037741158) {
            goto LABEL_95;
          }
          int v144 = 2037741171;
        }
        else
        {
          if (v52 == 828584240 || v52 == 845361456)
          {
            int v56 = 3;
            goto LABEL_95;
          }
          int v144 = 846624102;
        }
        if (v52 != v144) {
          int v56 = 1;
        }
LABEL_95:
        if (((equivalent_uncompressed_format(v53) - 1919365990) & 0xFFFFFFFD) == 0
          || (is_biplanar(v53) & 1) != 0)
        {
          int v98 = 0;
          goto LABEL_98;
        }
        int v98 = 2;
        if ((int)v53 > 846624120)
        {
          if (v53 == 846624121 || v53 == 2037741158) {
            goto LABEL_98;
          }
          int v145 = 2037741171;
        }
        else
        {
          if (v53 == 828584240 || v53 == 845361456)
          {
            int v98 = 3;
            goto LABEL_98;
          }
          int v145 = 846624102;
        }
        if (v53 != v145) {
          int v98 = 1;
        }
LABEL_98:
        int v182 = v98;
        int v175 = v56;
        if (((equivalent_uncompressed_format(v54) - 1919365990) & 0xFFFFFFFD) == 0
          || (is_biplanar(v54) & 1) != 0)
        {
          int v99 = theDict;
          int v100 = 0;
          goto LABEL_101;
        }
        int v100 = 2;
        if ((int)v54 > 846624120)
        {
          if (v54 == 846624121)
          {
            int v99 = theDict;
            goto LABEL_101;
          }
          int v99 = theDict;
          if (v54 == 2037741158)
          {
LABEL_101:
            int v178 = v100;
            int v180 = bytes_per_element(v54);
            int v170 = bytes_per_element(v53);
            int v165 = bytes_per_element(v52);
            uint64_t v101 = min_bytes_per_row(v52, (uint64_t)a1);
            uint64_t v102 = min_bytes_per_row(v53, (uint64_t)a1);
            uint64_t v103 = min_bytes_per_row(v54, (uint64_t)a1);
            unint64_t v104 = 32;
            if (v186) {
              unint64_t v104 = (unint64_t)v186;
            }
            int v105 = (__CVBuffer *)((v101 + v104 - 1) / v104 * v104);
            unint64_t v106 = (v102 + v104 - 1) / v104 * v104;
            int v173 = (__CVBuffer *)((v103 + v104 - 1) / v104 * v104);
            int v167 = (__CVBuffer *)(v106 * (void)v55);
            float v168 = (__CVBuffer *)v106;
            unint64_t v107 = (void)v173 * (void)v55 + 2 * v106 * (void)v55;
            int v108 = (const void *)*MEMORY[0x1E4F2EFE0];
            *(void *)&long long valuePtr = v107 / (unint64_t)v55;
            CFNumberRef v109 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
            CFDictionarySetValue(v99, v108, v109);
            CFRelease(v109);
            int v110 = (const void *)*MEMORY[0x1E4F2EFB8];
            *(void *)&long long valuePtr = v107;
            CFNumberRef v111 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
            CFDictionarySetValue(v99, v110, v111);
            CFRelease(v111);
            cf[0] = 0;
            int v112 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            *(void *)&long long valuePtr = v112;
            int v113 = (const void *)*MEMORY[0x1E4F2F258];
            CVPixelBufferRef pixelBufferOut = a1;
            CFNumberRef v114 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
            CFDictionarySetValue(v112, v113, v114);
            CFRelease(v114);
            float v115 = (const void *)*MEMORY[0x1E4F2F220];
            kedouble y = (void *)*MEMORY[0x1E4F2F220];
            CVPixelBufferRef pixelBufferOut = v55;
            CFNumberRef v116 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
            CFDictionarySetValue(v112, v115, v116);
            CFRelease(v116);
            int v117 = (const void *)*MEMORY[0x1E4F2F240];
            uint64_t v163 = (void *)*MEMORY[0x1E4F2F240];
            CVPixelBufferRef pixelBufferOut = 0;
            CFNumberRef v118 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
            CFDictionarySetValue(v112, v117, v118);
            CFRelease(v118);
            int v119 = (const void *)*MEMORY[0x1E4F2F248];
            int v188 = (void *)*MEMORY[0x1E4F2F248];
            CVPixelBufferRef pixelBufferOut = (CVPixelBufferRef)((void)v105 * (void)v55);
            CFNumberRef v120 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
            CFDictionarySetValue(v112, v119, v120);
            CFRelease(v120);
            int v121 = (const void *)*MEMORY[0x1E4F2F178];
            uint64_t v162 = (void *)*MEMORY[0x1E4F2F178];
            CVPixelBufferRef pixelBufferOut = v105;
            CFNumberRef v122 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
            CFDictionarySetValue(v112, v121, v122);
            CFRelease(v122);
            int v123 = (const void *)*MEMORY[0x1E4F2F170];
            LODWORD(pixelBufferOut) = v165;
            CFNumberRef v124 = CFNumberCreate(0, kCFNumberIntType, &pixelBufferOut);
            CFDictionarySetValue(v112, v123, v124);
            CFRelease(v124);
            uint64_t v125 = (const void *)*MEMORY[0x1E4F2F1F0];
            int v166 = (void *)*MEMORY[0x1E4F2F1F0];
            LODWORD(pixelBufferOut) = v175;
            CFNumberRef v126 = CFNumberCreate(0, kCFNumberIntType, &pixelBufferOut);
            CFDictionarySetValue(v112, v125, v126);
            CFRelease(v126);
            int v127 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            *((void *)&valuePtr + 1) = v127;
            CVPixelBufferRef pixelBufferOut = a1;
            CFNumberRef v128 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
            CFDictionarySetValue(v127, v113, v128);
            CFRelease(v128);
            CVPixelBufferRef pixelBufferOut = v55;
            CFNumberRef v129 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
            CFDictionarySetValue(v127, key, v129);
            CFRelease(v129);
            CVPixelBufferRef pixelBufferOut = (CVPixelBufferRef)((void)v105 * (void)v55);
            CFNumberRef v130 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
            CFDictionarySetValue(v127, v163, v130);
            CFRelease(v130);
            CVPixelBufferRef pixelBufferOut = v167;
            CFNumberRef v131 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
            CFDictionarySetValue(v127, v188, v131);
            CFRelease(v131);
            CVPixelBufferRef pixelBufferOut = v168;
            CFNumberRef v132 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
            CFDictionarySetValue(v127, v162, v132);
            CFRelease(v132);
            LODWORD(pixelBufferOut) = v170;
            CFNumberRef v133 = CFNumberCreate(0, kCFNumberIntType, &pixelBufferOut);
            CFDictionarySetValue(v127, v123, v133);
            CFRelease(v133);
            LODWORD(pixelBufferOut) = v182;
            CFNumberRef v134 = CFNumberCreate(0, kCFNumberIntType, &pixelBufferOut);
            CFDictionarySetValue(v127, v166, v134);
            CFRelease(v134);
            CFMutableDictionaryRef v135 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            cf[0] = v135;
            CVPixelBufferRef pixelBufferOut = a1;
            CFNumberRef v136 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
            CFDictionarySetValue(v135, v113, v136);
            CFRelease(v136);
            CVPixelBufferRef pixelBufferOut = height;
            CFNumberRef v137 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
            CFDictionarySetValue(v135, key, v137);
            CFRelease(v137);
            CVPixelBufferRef pixelBufferOut = (__CVBuffer *)((char *)v167 + (void)v105 * (void)v55);
            CFNumberRef v138 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
            CFDictionarySetValue(v135, v163, v138);
            CFRelease(v138);
            CVPixelBufferRef pixelBufferOut = (CVPixelBufferRef)((void)v173 * (void)v55);
            CFNumberRef v139 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
            CFDictionarySetValue(v135, v188, v139);
            CFRelease(v139);
            CVPixelBufferRef pixelBufferOut = v173;
            CFNumberRef v140 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
            CFDictionarySetValue(v135, v162, v140);
            CFRelease(v140);
            LODWORD(pixelBufferOut) = v180;
            CFNumberRef v141 = CFNumberCreate(0, kCFNumberIntType, &pixelBufferOut);
            CFDictionarySetValue(v135, v123, v141);
            CFRelease(v141);
            LODWORD(pixelBufferOut) = v178;
            CFNumberRef v142 = CFNumberCreate(0, kCFNumberIntType, &pixelBufferOut);
            CFDictionaryRef v49 = theDict;
            CFDictionarySetValue(v135, v166, v142);
            CFRelease(v142);
            CFArrayRef v143 = CFArrayCreate(0, (const void **)&valuePtr, 3, MEMORY[0x1E4F1D510]);
            CFDictionarySetValue(theDict, (const void *)*MEMORY[0x1E4F2F238], v143);
            CFRelease(v143);
            CFRelease((CFTypeRef)valuePtr);
            CFRelease(*((CFTypeRef *)&valuePtr + 1));
            CFRelease(cf[0]);
LABEL_119:
            IOSurface = IOSurfaceCreate(v49);
            nameSurface(*(void *)(v184 + 16), IOSurface);
            if (v189)
            {
              if ((v45 & 0xFD000000) == 0x2D000000 || v45 >> 24 == 124 || v45 >> 24 == 38) {
                x_log("Error: a compressed surface cannot be cleared using ClearSurface().\n");
              }
              else {
                ClearSurface(IOSurface);
              }
            }
            if ((int)v40 > 2037741157)
            {
              if (v40 != 2037741158)
              {
                int v150 = 2037741171;
LABEL_129:
                if (v40 == v150) {
                  goto LABEL_130;
                }
                int v157 = equivalent_uncompressed_format(v40);
                if (v157 > 1937126451)
                {
                  if (v157 <= 2016686639)
                  {
                    if (v157 > 1953903153)
                    {
                      if (v157 == 1953903154) {
                        goto LABEL_184;
                      }
                      unsigned __int16 v159 = 13364;
                    }
                    else
                    {
                      if (v157 == 1937126452) {
                        goto LABEL_184;
                      }
                      unsigned __int16 v159 = 12848;
                    }
                    int v158 = v159 | 0x74760000;
                  }
                  else if (v157 <= 2016687155)
                  {
                    if (v157 == 2016686640) {
                      goto LABEL_184;
                    }
                    int v158 = 2016686642;
                  }
                  else
                  {
                    if (v157 == 2016687156 || v157 == 2037741171) {
                      goto LABEL_184;
                    }
                    int v158 = 2033463352;
                  }
                }
                else if (v157 <= 1882468911)
                {
                  if (v157 > 875704949)
                  {
                    if (v157 == 875704950) {
                      goto LABEL_184;
                    }
                    int v158 = 875836534;
                  }
                  else
                  {
                    if (v157 == 846624121) {
                      goto LABEL_184;
                    }
                    int v158 = 875704438;
                  }
                }
                else if (v157 <= 1882469427)
                {
                  if (v157 == 1882468912) {
                    goto LABEL_184;
                  }
                  int v158 = 1882468914;
                }
                else
                {
                  if (v157 == 1882469428 || v157 == 1937125936) {
                    goto LABEL_184;
                  }
                  int v158 = 1937125938;
                }
                if (v157 != v158) {
                  goto LABEL_130;
                }
LABEL_184:
                if (v157 > 1937126451)
                {
                  if (v157 <= 2016686639)
                  {
                    if (v157 > 1953903153)
                    {
                      if (v157 == 1953903154) {
                        goto LABEL_211;
                      }
                      unsigned __int16 v161 = 13364;
                    }
                    else
                    {
                      if (v157 == 1937126452) {
                        goto LABEL_211;
                      }
                      unsigned __int16 v161 = 12848;
                    }
                    int v160 = v161 | 0x74760000;
                  }
                  else if (v157 <= 2016687155)
                  {
                    if (v157 == 2016686640) {
                      goto LABEL_211;
                    }
                    int v160 = 2016686642;
                  }
                  else
                  {
                    if (v157 == 2016687156 || v157 == 2037741171) {
                      goto LABEL_211;
                    }
                    int v160 = 2033463352;
                  }
                }
                else if (v157 <= 1882468911)
                {
                  if (v157 > 875704949)
                  {
                    if (v157 == 875704950) {
                      goto LABEL_211;
                    }
                    int v160 = 875836534;
                  }
                  else
                  {
                    if (v157 == 846624121) {
                      goto LABEL_211;
                    }
                    int v160 = 875704438;
                  }
                }
                else
                {
                  if (v157 > 1882469427)
                  {
                    if (v157 != 1882469428 && v157 != 1937125936)
                    {
                      int v160 = 1937125938;
                      goto LABEL_210;
                    }
LABEL_211:
                    int v153 = 0;
                    int v151 = 1;
                    char v152 = 1;
                    goto LABEL_131;
                  }
                  if (v157 == 1882468912) {
                    goto LABEL_211;
                  }
                  int v160 = 1882468914;
                }
LABEL_210:
                if (v157 != v160)
                {
LABEL_136:
                  CVPixelBufferRef v27 = v49;
LABEL_137:
                  CFRelease(v27);
                  return IOSurface;
                }
                goto LABEL_211;
              }
            }
            else if (v40 != 846624102)
            {
              int v150 = 846624121;
              goto LABEL_129;
            }
LABEL_130:
            int v151 = 0;
            char v152 = 6;
            int v153 = 1;
LABEL_131:
            int v199 = 0;
            long long v197 = 0u;
            long long v198 = 0u;
            long long v195 = 0u;
            long long v196 = 0u;
            *(_OWORD *)CFTypeRef cf = 0u;
            long long v194 = 0u;
            long long valuePtr = 0u;
            BYTE10(v195) = v152;
            IOSurfaceSetBulkAttachments2();
            uint64_t v154 = (CFTypeRef *)MEMORY[0x1E4F2F2D8];
            uint64_t v155 = (CFTypeRef *)MEMORY[0x1E4F2F2E0];
            if (!v151) {
              uint64_t v155 = (CFTypeRef *)MEMORY[0x1E4F2F2D0];
            }
            if (!v153) {
              uint64_t v154 = v155;
            }
            IOSurfaceSetValue(IOSurface, (CFStringRef)*MEMORY[0x1E4F2F2C8], *v154);
            goto LABEL_136;
          }
          int v146 = 2037741171;
        }
        else
        {
          int v99 = theDict;
          if (v54 == 828584240 || v54 == 845361456)
          {
            int v100 = 3;
            goto LABEL_101;
          }
          int v146 = 846624102;
        }
        if (v54 != v146) {
          int v100 = 1;
        }
        goto LABEL_101;
      }
      CVPixelBufferRef pixelBufferOut = 0;
      uint64_t v18 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
      uint64_t v19 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
      unint64_t v20 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      int v21 = CFDictionaryCreateMutable(0, 0, v18, v19);
      uint64_t v22 = (const void *)*MEMORY[0x1E4F2F280];
      *(void *)&long long valuePtr = *(void *)(a5 + 8);
      CFNumberRef v23 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
      CFDictionarySetValue(v21, v22, v23);
      CFRelease(v23);
      uint32x2_t v24 = (const void *)*MEMORY[0x1E4F2EFC0];
      uint64_t v25 = a5;
      *(void *)&long long valuePtr = *(void *)(a5 + 16);
      CFNumberRef v26 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
      CFDictionarySetValue(v21, v24, v26);
      CFRelease(v26);
      CFDictionarySetValue(v20, (const void *)*MEMORY[0x1E4F24D20], v21);
      CFDictionarySetValue(v20, @"IOSurfacePurgeable", (const void *)*MEMORY[0x1E4F1CFD0]);
      CVPixelBufferCreate(0, (size_t)a1, (size_t)height, a4, v20, &pixelBufferOut);
      CFRelease(v21);
      CFRelease(v20);
      if (pixelBufferOut)
      {
        IOSurface = CVPixelBufferGetIOSurface(pixelBufferOut);
        if (IOSurface)
        {
          nameSurface(*(void *)(v25 + 16), IOSurface);
          CFRetain(IOSurface);
        }
        CVPixelBufferRef v27 = pixelBufferOut;
        goto LABEL_137;
      }
      if (v17)
      {
        uint64_t v28 = v17;
        goto LABEL_18;
      }
    }
    return 0;
  }
  return IOSurface;
}

__IOSurface *nameSurface(uint64_t a1, __IOSurface *a2)
{
  if (CI_NAME_SURFACES())
  {
    if (a1) {
      int v4 = @"CoreImagePool";
    }
    else {
      int v4 = @"CoreImage";
    }
    IOSurfaceSetValue(a2, (CFStringRef)*MEMORY[0x1E4F2F128], v4);
  }
  return a2;
}

void setIntValue(__CFDictionary *a1, const void *a2, int a3)
{
  int valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(a1, a2, v5);
  CFRelease(v5);
}

uint64_t bytes_per_element(uint64_t a1)
{
  if ((equivalent_uncompressed_format(a1) - 1919365990) & 0xFFFFFFFD) == 0 || (is_biplanar(a1)) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v3 = 1;
  if ((int)a1 > 1279340599)
  {
    if ((int)a1 > 1667844407)
    {
      if ((int)a1 > 1815162993)
      {
        if ((int)a1 > 1999908960)
        {
          if ((int)a1 > 2037741157)
          {
            if (a1 == 2037741158) {
              return 4;
            }
            int v7 = 2037741171;
            goto LABEL_94;
          }
          if (a1 != 1999908961)
          {
            int v7 = 2033463352;
            goto LABEL_94;
          }
          return 8;
        }
        if ((int)a1 > 1815491697)
        {
          if (a1 != 1815491698)
          {
            int v7 = 1999843442;
            goto LABEL_94;
          }
          return 8;
        }
        if (a1 == 1815162994) {
          return 4;
        }
        int v6 = 1815361650;
LABEL_52:
        if (a1 != v6) {
          return result;
        }
        return 6;
      }
      if ((int)a1 > 1717855599)
      {
        if ((int)a1 > 1751410031)
        {
          if (a1 == 1751410032) {
            return 2;
          }
          int v8 = 1751411059;
          goto LABEL_89;
        }
        if (a1 == 1717855600) {
          return 4;
        }
        int v7 = 1717856627;
LABEL_94:
        if (a1 != v7) {
          return result;
        }
        return 4;
      }
      if (a1 == 1667844408) {
        return v3;
      }
      if (a1 == 1667844454) {
        return 4;
      }
      unsigned __int16 v9 = 18792;
    }
    else
    {
      if ((int)a1 <= 1380411456)
      {
        if ((int)a1 > 1279340853)
        {
          if ((int)a1 > 1380401728)
          {
            if (a1 != 1380401729)
            {
              if (a1 != 1380410945) {
                return result;
              }
              return 16;
            }
          }
          else if (a1 != 1279340854)
          {
            int v8 = 1279342648;
            goto LABEL_89;
          }
          return 4;
        }
        if (a1 == 1279340600) {
          return 2;
        }
        if (a1 != 1279340646)
        {
          int v7 = 1279340648;
          goto LABEL_94;
        }
        return 8;
      }
      if ((int)a1 <= 1667838821)
      {
        if ((int)a1 > 1667838255)
        {
          if (a1 == 1667838256) {
            return 4;
          }
          int v7 = 1667838768;
          goto LABEL_94;
        }
        if (a1 != 1380411457)
        {
          int v5 = 1664496754;
          goto LABEL_64;
        }
        return 8;
      }
      if ((int)a1 <= 1667839023)
      {
        if (a1 == 1667838822) {
          return 12;
        }
        int v6 = 1667838824;
        goto LABEL_52;
      }
      if (a1 == 1667839024) {
        return 8;
      }
      unsigned __int16 v9 = 18742;
    }
    int v8 = v9 | 0x63690000;
    goto LABEL_89;
  }
  if ((int)a1 <= 845361455)
  {
    if ((int)a1 <= 828584239)
    {
      if ((int)a1 <= 826486885)
      {
        if (a1 == 24) {
          return 3;
        }
        if (a1 != 32)
        {
          int v4 = 826486840;
          goto LABEL_22;
        }
        return 4;
      }
      if ((a1 - 826487088) <= 6 && ((1 << (a1 - 48)) & 0x45) != 0) {
        return 2;
      }
      if (a1 != 826486886)
      {
        int v8 = 826486888;
        goto LABEL_89;
      }
      return 4;
    }
    if ((int)a1 > 843264103)
    {
      if ((a1 - 843264304) <= 6 && ((1 << (a1 - 48)) & 0x45) != 0) {
        return 4;
      }
      int v7 = 843264104;
      goto LABEL_94;
    }
    if (a1 == 828584240) {
      return 4;
    }
    if (a1 != 843264056)
    {
      int v5 = 843264102;
LABEL_64:
      if (a1 != v5) {
        return result;
      }
      return 8;
    }
    return 2;
  }
  if ((int)a1 > 1094862673)
  {
    if ((int)a1 <= 1278226533)
    {
      if (a1 != 1094862674 && a1 != 1111970369)
      {
        int v4 = 1278226488;
LABEL_22:
        if (a1 != v4) {
          return result;
        }
        return v3;
      }
      return 4;
    }
    if ((a1 - 1278226736) <= 6 && ((1 << (a1 - 48)) & 0x45) != 0) {
      return 2;
    }
    if (a1 == 1278226534) {
      return 4;
    }
    int v8 = 1278226536;
LABEL_89:
    if (a1 != v8) {
      return result;
    }
    return 2;
  }
  if ((int)a1 <= 1093677111)
  {
    if (a1 != 845361456)
    {
      if (a1 == 846624102) {
        return 4;
      }
      int v7 = 846624121;
      goto LABEL_94;
    }
    return 8;
  }
  if ((int)a1 > 1093677159)
  {
    if (a1 == 1093677160) {
      return 2;
    }
    int v8 = 1093677366;
    goto LABEL_89;
  }
  if (a1 != 1093677112)
  {
    int v7 = 1093677158;
    goto LABEL_94;
  }
  return v3;
}

__IOSurface *CreateWrappedSurface(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  return CreateSurfaceWrapped(a1, a2, a3, a4, a6);
}

__IOSurface *CreateSurfaceWrapped(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  int v5 = 0;
  if (a1 && a2 && a3)
  {
    if (is_biplanar(a3)) {
      return 0;
    }
    int v11 = bytes_per_element(a3);
    unint64_t v12 = min_bytes_per_row(a3, a1);
    int v5 = 0;
    if (v11)
    {
      unint64_t v13 = v12;
      if (v12)
      {
        if (v12 <= a4)
        {
          CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          if (!Mutable) {
            return 0;
          }
          uint64_t v15 = Mutable;
          int v16 = (const void *)*MEMORY[0x1E4F2F040];
          uint64_t valuePtr = a5;
          CFNumberRef v17 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
          CFDictionarySetValue(v15, v16, v17);
          CFRelease(v17);
          uint64_t v18 = (const void *)*MEMORY[0x1E4F2EFB8];
          uint64_t valuePtr = v13 + (a2 - 1) * a4;
          CFNumberRef v19 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
          CFDictionarySetValue(v15, v18, v19);
          CFRelease(v19);
          unint64_t v20 = (const void *)*MEMORY[0x1E4F2EFE0];
          uint64_t valuePtr = (int)a4;
          CFNumberRef v21 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
          CFDictionarySetValue(v15, v20, v21);
          CFRelease(v21);
          uint64_t v22 = (const void *)*MEMORY[0x1E4F2F2C0];
          uint64_t valuePtr = a1;
          CFNumberRef v23 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
          CFDictionarySetValue(v15, v22, v23);
          CFRelease(v23);
          uint32x2_t v24 = (const void *)*MEMORY[0x1E4F2F0E8];
          uint64_t valuePtr = a2;
          CFNumberRef v25 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
          CFDictionarySetValue(v15, v24, v25);
          CFRelease(v25);
          CFNumberRef v26 = (const void *)*MEMORY[0x1E4F2F150];
          LODWORD(valuePtr) = a3;
          CFNumberRef v27 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
          CFDictionarySetValue(v15, v26, v27);
          CFRelease(v27);
          uint64_t v28 = (const void *)*MEMORY[0x1E4F2EFD8];
          LODWORD(valuePtr) = v11;
          CFNumberRef v29 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
          CFDictionarySetValue(v15, v28, v29);
          CFRelease(v29);
          if (((equivalent_uncompressed_format(a3) - 1919365990) & 0xFFFFFFFD) == 0) {
            goto LABEL_22;
          }
          int v30 = 2;
          if ((int)a3 > 846624120)
          {
            if (a3 != 846624121 && a3 != 2037741158)
            {
              int v31 = 2037741171;
LABEL_18:
              if (a3 != v31) {
                goto LABEL_22;
              }
            }
          }
          else
          {
            if (a3 != 828584240 && a3 != 845361456)
            {
              int v31 = 846624102;
              goto LABEL_18;
            }
            int v30 = 3;
          }
          int v32 = (const void *)*MEMORY[0x1E4F2F0A0];
          LODWORD(valuePtr) = v30;
          CFNumberRef v33 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
          CFDictionarySetValue(v15, v32, v33);
          CFRelease(v33);
LABEL_22:
          int v5 = IOSurfaceCreate(v15);
          if (CI_NAME_SURFACES()) {
            IOSurfaceSetValue(v5, (CFStringRef)*MEMORY[0x1E4F2F128], @"CoreImage");
          }
          CFRelease(v15);
        }
      }
    }
  }
  return v5;
}

uint64_t SurfaceSetVolatileEmpty(IOSurfaceRef buffer)
{
  if (CI_TRASH_SURFACES_ON_SETVOLATILE_didCheck != -1) {
    dispatch_once(&CI_TRASH_SURFACES_ON_SETVOLATILE_didCheck, &__block_literal_global_28);
  }
  if (CI_TRASH_SURFACES_ON_SETVOLATILE_v) {
    SurfaceApplyPlaneBlock(buffer, (uint64_t)&__block_literal_global_32_1);
  }
  uint32_t oldState = 0;
  return IOSurfaceSetPurgeable(buffer, 2u, &oldState);
}

BOOL SurfaceIsVolatileNonEmpty(__IOSurface *a1)
{
  uint32_t oldState = 0;
  return !IOSurfaceSetPurgeable(a1, 3u, &oldState) && oldState == 1;
}

BOOL SurfaceIsVolatileEmpty(__IOSurface *a1)
{
  uint32_t oldState = 0;
  return !IOSurfaceSetPurgeable(a1, 3u, &oldState) && oldState == 2;
}

CGColorSpaceRef CreateColorSpaceFromInfo(const void *a1, const void *a2, const void *a3, const __CFNumber *a4)
{
  CFDataRef v4 = 0;
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  if (a1 && a2)
  {
    if (CFEqual(a1, (CFTypeRef)*MEMORY[0x1E4F24AB0]))
    {
      uint64_t v9 = 1;
    }
    else if (CFEqual(a1, (CFTypeRef)*MEMORY[0x1E4F24AA0]))
    {
      uint64_t v9 = 5;
    }
    else if (CFEqual(a1, (CFTypeRef)*MEMORY[0x1E4F24AC8]))
    {
      uint64_t v9 = 6;
    }
    else if (CFEqual(a1, (CFTypeRef)*MEMORY[0x1E4F24AB8]))
    {
      uint64_t v9 = 22;
    }
    else if (CFEqual(a1, (CFTypeRef)*MEMORY[0x1E4F24AA8]))
    {
      uint64_t v9 = 9;
    }
    else if (CFEqual(a1, (CFTypeRef)*MEMORY[0x1E4F24A98]))
    {
      uint64_t v9 = 11;
    }
    else if (CFEqual(a1, (CFTypeRef)*MEMORY[0x1E4F24AC0]))
    {
      uint64_t v9 = 12;
    }
    else
    {
      uint64_t v9 = 2;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F24BE0]))
    {
      uint64_t v10 = 1;
    }
    else if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F24BF0]))
    {
      uint64_t v10 = 7;
    }
    else if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F24BD0]))
    {
      uint64_t v10 = 14;
    }
    else if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F24C08]))
    {
      uint64_t v10 = 0;
    }
    else if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F24C00]))
    {
      uint64_t v10 = 17;
    }
    else if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F24BE8]))
    {
      uint64_t v10 = 20;
    }
    else if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F24C10]))
    {
      uint64_t v10 = 19;
    }
    else
    {
      uint64_t v10 = 2;
    }
    if (a3)
    {
      if (CFEqual(a3, (CFTypeRef)*MEMORY[0x1E4F24C48]))
      {
        uint64_t v11 = 1;
      }
      else if (CFEqual(a3, (CFTypeRef)*MEMORY[0x1E4F24C40]))
      {
        uint64_t v11 = 6;
      }
      else if (CFEqual(a3, (CFTypeRef)*MEMORY[0x1E4F24C60]))
      {
        uint64_t v11 = 7;
      }
      else if (CFEqual(a3, (CFTypeRef)*MEMORY[0x1E4F24C20]))
      {
        uint64_t v11 = 11;
      }
      else if (CFEqual(a3, (CFTypeRef)*MEMORY[0x1E4F24C58]))
      {
        uint64_t v11 = 12;
      }
      else if (CFEqual(a3, (CFTypeRef)*MEMORY[0x1E4F24C30]))
      {
        uint64_t v11 = 9;
      }
      else
      {
        uint64_t v11 = 2;
      }
    }
    else
    {
      uint64_t v11 = 2;
    }
    uint64_t valuePtr = 0x3FF0000000000000;
    if (a4)
    {
      CFNumberGetValue(a4, kCFNumberDoubleType, &valuePtr);
      double v12 = *(double *)&valuePtr;
    }
    else
    {
      double v12 = 1.0;
    }
    if (v9 == 12 && v10 == 1)
    {
      unint64_t v13 = (CFStringRef *)MEMORY[0x1E4F1DB90];
      return CGColorSpaceCreateWithName(*v13);
    }
    if (v9 == 1 && v10 == 19)
    {
      unint64_t v13 = (CFStringRef *)MEMORY[0x1E4F1DC98];
      return CGColorSpaceCreateWithName(*v13);
    }
    if (v9 == 1 && v10 == 20)
    {
      unint64_t v13 = (CFStringRef *)MEMORY[0x1E4F1DC88];
      return CGColorSpaceCreateWithName(*v13);
    }
    v51[0] = 0;
    *(double *)&v51[1] = v12;
    long long v52 = xmmword_193953170;
    uint64_t v53 = 0;
    if (v9 == 1)
    {
      uint64_t v15 = &CreateColorSpaceFromInfoValues_primaries_ITU_R709_2_Info;
    }
    else
    {
      uint64_t v15 = &CreateColorSpaceFromInfoValues_primaries_EBU_3213_Info;
      switch((int)v9)
      {
        case 5:
          break;
        case 6:
          uint64_t v15 = &CreateColorSpaceFromInfoValues_primaries_SMPTE_C_Info;
          break;
        case 7:
        case 8:
        case 10:
          goto LABEL_102;
        case 9:
          uint64_t v15 = &CreateColorSpaceFromInfoValues_primaries_ITU_R_2020_Info;
          break;
        case 11:
          uint64_t v15 = &CreateColorSpaceFromInfoValues_primaries_DCI_P3_Info;
          break;
        default:
          if (v9 == 22)
          {
            uint64_t v15 = &CreateColorSpaceFromInfoValues_primaries_GenericRGB_Info;
          }
          else
          {
LABEL_102:
            if (v9 == 12) {
              uint64_t v15 = (uint64_t *)&CreateColorSpaceFromInfoValues_primaries_P3_D65_Info;
            }
            else {
              uint64_t v15 = &CreateColorSpaceFromInfoValues_primaries_GenericRGB_Info;
            }
          }
          break;
      }
    }
    if (v10 == 1)
    {
      int v16 = &CreateColorSpaceFromInfoValues_transferFunction_ITU_R2020_Info;
      uint64_t v10 = 1;
    }
    else if (v10 <= 0xF && ((1 << v10) & 0xC080) != 0)
    {
      int v16 = &CreateColorSpaceFromInfoValues_transferFunction_ITU_R2020_Info;
    }
    else
    {
      if (v10 == 20) {
        int v16 = (__int16 *)&CreateColorSpaceFromInfoValues_transferFunction_Linear_Info;
      }
      else {
        int v16 = (__int16 *)&CreateColorSpaceFromInfoValues_transferFunction_sRGB_Info;
      }
      if ((v10 - 19) >= 2)
      {
        _ZF = v10 == 0;
        if (v10) {
          uint64_t v10 = v10;
        }
        else {
          uint64_t v10 = 2;
        }
        if (_ZF) {
          int v16 = (__int16 *)v51;
        }
        else {
          int v16 = (__int16 *)&CreateColorSpaceFromInfoValues_transferFunction_GenericRGB_Info;
        }
      }
    }
    double v17 = *((double *)v16 + 1);
    _ZF = *v16 == 0;
    long long v59 = xmmword_1E5773650;
    long long v60 = *(_OWORD *)&off_1E5773660;
    if (_ZF) {
      double v18 = v17;
    }
    else {
      double v18 = 1.0 / v17;
    }
    long long v61 = xmmword_1E5773670;
    *(_OWORD *)keys = xmmword_1E5773610;
    long long v56 = *(_OWORD *)&off_1E5773620;
    long long v57 = xmmword_1E5773630;
    long long v58 = *(_OWORD *)&off_1E5773640;
    values[0] = (void *)CFRetain(@"displayRGB");
    if (v9 == 1 && v11 == 1 && v10 == 1)
    {
      CFNumberRef v19 = @"HDTV";
    }
    else if (v11 == 6 && v9 == 6 && v10 == 1)
    {
      CFNumberRef v19 = @"Composite NTSC";
    }
    else if (v11 == 6 && v9 == 5 && v10 == 1)
    {
      CFNumberRef v19 = @"Composite PAL";
    }
    else if (v9 == 6 && v11 == 7 && v10 == 7)
    {
      CFNumberRef v19 = @"HDTV Interim Color Implementation";
    }
    else if (v9 == 11 && v11 == 11 && v10 == 14)
    {
      CFNumberRef v19 = @"Digital Cinema P3";
    }
    else
    {
      if (v9 != 12 || v11 != 12 || v10 != 14)
      {
        CFNumberRef v21 = (void *)CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"QuickTime 'nclc' Video (%d,%d,%d)", v9, v10, v11);
        goto LABEL_116;
      }
      CFNumberRef v19 = @"D65 P3";
    }
    CFNumberRef v21 = (void *)CFRetain(v19);
LABEL_116:
    values[1] = v21;
    *(double *)bytes = v18;
    uint64_t v22 = 13;
    values[2] = CFNumberCreate(0, kCFNumberDoubleType, bytes);
    *(double *)bytes = v18;
    values[3] = CFNumberCreate(0, kCFNumberDoubleType, bytes);
    *(double *)bytes = v18;
    values[4] = CFNumberCreate(0, kCFNumberDoubleType, bytes);
    *(void *)bytes = v15[4];
    values[5] = CFNumberCreate(0, kCFNumberDoubleType, bytes);
    *(void *)bytes = v15[5];
    values[6] = CFNumberCreate(0, kCFNumberDoubleType, bytes);
    *(void *)bytes = *v15;
    values[7] = CFNumberCreate(0, kCFNumberDoubleType, bytes);
    *(void *)bytes = v15[1];
    values[8] = CFNumberCreate(0, kCFNumberDoubleType, bytes);
    *(void *)bytes = v15[2];
    values[9] = CFNumberCreate(0, kCFNumberDoubleType, bytes);
    *(void *)bytes = v15[3];
    values[10] = CFNumberCreate(0, kCFNumberDoubleType, bytes);
    *(void *)bytes = v15[6];
    values[11] = CFNumberCreate(0, kCFNumberDoubleType, bytes);
    *(void *)bytes = v15[7];
    values[12] = CFNumberCreate(0, kCFNumberDoubleType, bytes);
    values[13] = (void *)CFStringCreateWithCString(0, "Copyright 2007 Apple Inc.", 0);
    CFDictionaryRef v23 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 14, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    do
    {
      CFRelease(values[v22]);
      unint64_t v24 = v22-- + 1;
    }
    while (v24 > 1);
    if (!v23) {
      return 0;
    }
    Profile = (const ColorSyncProfile *)ColorSyncMakeProfile();
    if (Profile)
    {
      CFNumberRef v26 = Profile;
      MutableCopdouble y = ColorSyncProfileCreateMutableCopy(Profile);
      CFRelease(v26);
      if (MutableCopy)
      {
        CFDataRef v28 = ColorSyncProfileCopyHeader(MutableCopy);
        if (v28)
        {
          CFDataRef v29 = v28;
          int v30 = CFDataCreateMutableCopy(0, 128, v28);
          CFRelease(v29);
          if (v30)
          {
            CFDataSetLength(v30, 128);
            MutableBytePtr = CFDataGetMutableBytePtr(v30);
            if (!MutableBytePtr)
            {
              CFDataRef v4 = 0;
              goto LABEL_133;
            }
            int v32 = MutableBytePtr;
            if (*v16 == 3)
            {
              double v33 = *((double *)v16 + 3);
              v34.f64[0] = *((double *)v16 + 4) + 1.0;
              __asm { FMOV            V3.2D, #1.0 }
              v39.f64[1] = _Q3.f64[1];
              v39.f64[0] = *((float64_t *)v16 + 4);
              v40.f64[0] = *((float64_t *)v16 + 1);
              double v41 = *((double *)v16 + 2);
              v40.f64[1] = v34.f64[0];
              v34.f64[1] = v33;
              float64x2_t v42 = vdivq_f64(_Q3, v40);
              float64x2_t v43 = vdivq_f64(v39, v34);
              float64x2_t v44 = (float64x2_t)vdupq_n_s64(0x40DFFFC000000000uLL);
              __asm { FMOV            V4.2D, #0.5 }
              bytes[5] = 0;
              *(_WORD *)&bytes[6] = 0;
              int v48 = 768;
              strcpy((char *)bytes, "para");
              int8x16_t v49 = vrev32q_s8((int8x16_t)vuzp1q_s32((int32x4_t)vcvtq_u64_f64(vmlaq_f64(_Q4, v44, v42)), (int32x4_t)vcvtq_u64_f64(vmlaq_f64(_Q4, v44, v43))));
              unsigned int v50 = bswap32((v33 * v41 * 32767.0 + 0.5));
              CFDataRef v4 = CFDataCreateWithBytesNoCopy(0, bytes, 32, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
              if (!v4)
              {
LABEL_133:
                CFRelease(MutableCopy);
                CFRelease(v30);
                goto LABEL_131;
              }
              ColorSyncProfileSetTag(MutableCopy, @"rTRC", v4);
              ColorSyncProfileSetTag(MutableCopy, @"gTRC", v4);
              ColorSyncProfileSetTag(MutableCopy, @"bTRC", v4);
              CFRelease(v4);
              *((_DWORD *)v32 + 2) = 0x4000000;
            }
            *((void *)v32 + 3) = 0x10001000407D5;
            *((_DWORD *)v32 + _Block_object_dispose(&STACK[0x238], 8) = 65537;
            ColorSyncProfileSetHeader(MutableCopy, v30);
            CFDataRef v4 = CGColorSpaceCreateWithPlatformColorSpace(MutableCopy);
            goto LABEL_133;
          }
        }
        CFRelease(MutableCopy);
      }
    }
    CFDataRef v4 = 0;
LABEL_131:
    CFRelease(v23);
  }
  return v4;
}

CGColorSpaceRef CopySurfaceColorSpace(__IOSurface *a1)
{
  uint64_t PixelFormat = IOSurfaceGetPixelFormat(a1);
  int v3 = PixelFormat;
  int v4 = equivalent_uncompressed_format(PixelFormat);
  char v5 = 0;
  if (v4 <= 1279340599)
  {
    if (((v4 - 1278226488) > 0x30 || ((1 << (v4 - 56)) & 0x1400000000001) == 0)
      && ((v4 - 1278226736) > 6 || ((1 << (v4 - 48)) & 0x45) == 0))
    {
LABEL_19:
      char v5 = 1;
      goto LABEL_20;
    }
    goto LABEL_20;
  }
  if (v4 <= 1279342647)
  {
    if ((v4 - 1279340600) <= 0x30 && ((1 << (v4 - 56)) & 0x1400000000001) != 0) {
      goto LABEL_20;
    }
    int v6 = 1279340854;
LABEL_18:
    if (v4 == v6) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  if (v4 <= 1717856626)
  {
    if (v4 == 1279342648) {
      goto LABEL_20;
    }
    int v6 = 1717855600;
    goto LABEL_18;
  }
  if (v4 != 1717856627 && v4 != 1751410032)
  {
    int v6 = 1751411059;
    goto LABEL_18;
  }
LABEL_20:
  if (v3 > 1751410031)
  {
    if (v3 == 1751411059) {
      goto LABEL_26;
    }
    int v7 = 1751410032;
  }
  else
  {
    if (v3 == 1717855600) {
      goto LABEL_26;
    }
    int v7 = 1717856627;
  }
  if (v3 != v7)
  {
    CFTypeRef v10 = IOSurfaceCopyValue(a1, (CFStringRef)*MEMORY[0x1E4F2F068]);
    if (v10)
    {
      uint64_t v11 = v10;
      CGColorSpaceRef v12 = CGColorSpaceCreateWithPropertyList(v10);
      CFRelease(v11);
      return v12;
    }
    if (v5)
    {
      if (!IOSurfaceGetBulkAttachments())
      {
        CGColorSpaceRef result = (CGColorSpaceRef)CVCreateColorSpaceFromIOSurfaceBulkAttachments();
        if (result) {
          return result;
        }
      }
      unint64_t v13 = (CFStringRef *)MEMORY[0x1E4F1DC98];
    }
    else
    {
      IOSurfaceGetBulkAttachments();
      unint64_t v13 = (CFStringRef *)MEMORY[0x1E4F1DC00];
    }
    return CGColorSpaceCreateWithName(*v13);
  }
LABEL_26:
  CFStringRef v8 = (const __CFString *)*MEMORY[0x1E4F1DBD0];

  return CGColorSpaceCreateWithName(v8);
}

CGImage *SurfaceWriteToFile(__IOSurface *a1, CGColorSpace *a2, char *a3)
{
  CGColorSpaceRef result = SurfaceCreateCGImage(a1, a2, 1);
  if (result)
  {
    char v5 = result;
    BOOL v6 = _writeCGImageToFile(result, a3);
    CGImageRelease(v5);
    return (CGImage *)v6;
  }
  return result;
}

BOOL _writeCGImageToFile(CGImage *a1, char *__s)
{
  size_t v4 = strlen(__s);
  CFURLRef v5 = CFURLCreateFromFileSystemRepresentation(0, (const UInt8 *)__s, v4, 0);
  if (!v5) {
    return 0;
  }
  CFURLRef v6 = v5;
  int v7 = strstr(__s, ".jpg");
  CFStringRef v8 = strstr(__s, ".png");
  uint64_t v9 = @"public.png";
  if (!v8) {
    uint64_t v9 = @"public.tiff";
  }
  if (v7) {
    CFStringRef v10 = @"public.jpeg";
  }
  else {
    CFStringRef v10 = v9;
  }
  uint64_t v11 = CGImageDestinationCreateWithURL(v6, v10, 1uLL, 0);
  if (v11)
  {
    CGColorSpaceRef v12 = v11;
    CGImageDestinationAddImage(v11, a1, 0);
    BOOL v13 = CGImageDestinationFinalize(v12);
    CFRelease(v12);
  }
  else
  {
    BOOL v13 = 0;
  }
  CFRelease(v6);
  return v13;
}

CGImage *SurfaceRegionWriteToFile(__IOSurface *a1, CGColorSpace *a2, char *a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7)
{
  CGColorSpaceRef result = SurfaceCreateCGImage(a1, a2, 1);
  if (result)
  {
    BOOL v13 = result;
    v16.origin.double x = a4;
    v16.origin.double y = a5;
    v16.size.double width = a6;
    v16.size.double height = a7;
    uint64_t v14 = CGImageCreateWithImageInRect(result, v16);
    BOOL v15 = _writeCGImageToFile(v14, a3);
    CGImageRelease(v14);
    CGImageRelease(v13);
    return (CGImage *)v15;
  }
  return result;
}

CGImage *SurfaceCroppedWriteToFile(__IOSurface *a1, CGColorSpace *a2, char *a3, CGFloat a4, CGFloat a5)
{
  return SurfaceRegionWriteToFile(a1, a2, a3, 0.0, 0.0, a4, a5);
}

BOOL SurfaceCroppedWriteRawToFile(__IOSurface *a1, char *__filename, double a3, double a4)
{
  int v7 = fopen(__filename, "wb");
  if (v7)
  {
    CFStringRef v8 = v7;
    size_t PlaneCount = IOSurfaceGetPlaneCount(a1);
    if (PlaneCount)
    {
      size_t v9 = 0;
      unint64_t v10 = (unint64_t)a3;
      unint64_t v11 = (unint64_t)a4;
      while (1)
      {
        size_t WidthOfPlane = IOSurfaceGetWidthOfPlane(a1, v9);
        size_t HeightOfPlane = IOSurfaceGetHeightOfPlane(a1, v9);
        size_t BytesPerRowOfPlane = IOSurfaceGetBytesPerRowOfPlane(a1, v9);
        size_t BytesPerElementOfPlane = IOSurfaceGetBytesPerElementOfPlane(a1, v9);
        unint64_t v16 = WidthOfPlane >= v10 ? v10 : WidthOfPlane;
        unint64_t v17 = HeightOfPlane >= v11 ? v11 : HeightOfPlane;
        int v18 = IOSurfaceLockPlane();
        BOOL v19 = v18 == 0;
        if (v18) {
          goto LABEL_26;
        }
        BaseAddressOfPlane = (char *)IOSurfaceGetBaseAddressOfPlane(a1, v9);
        if (v17)
        {
          CFNumberRef v21 = BaseAddressOfPlane;
          size_t v22 = BytesPerElementOfPlane * v16;
          while (fwrite(v21, 1uLL, v22, v8) == v22)
          {
            v21 += BytesPerRowOfPlane;
            if (!--v17) {
              goto LABEL_15;
            }
          }
          IOSurfaceUnlockPlane();
          goto LABEL_25;
        }
LABEL_15:
        IOSurfaceUnlockPlane();
        ++v9;
        unint64_t v11 = (unint64_t)a4;
        unint64_t v10 = (unint64_t)a3;
        if (v9 == PlaneCount) {
          goto LABEL_26;
        }
      }
    }
    size_t Width = IOSurfaceGetWidth(a1);
    size_t Height = IOSurfaceGetHeight(a1);
    size_t BytesPerRow = IOSurfaceGetBytesPerRow(a1);
    size_t BytesPerElement = IOSurfaceGetBytesPerElement(a1);
    if (Width >= (unint64_t)a3) {
      unint64_t v27 = (unint64_t)a3;
    }
    else {
      unint64_t v27 = Width;
    }
    if (Height >= (unint64_t)a4) {
      size_t Height = (unint64_t)a4;
    }
    if (!IOSurfaceLock(a1, 1u, 0))
    {
      BaseAddress = (char *)IOSurfaceGetBaseAddress(a1);
      if (!Height)
      {
LABEL_32:
        BOOL v19 = 1;
        IOSurfaceUnlock(a1, 1u, 0);
        goto LABEL_26;
      }
      int v30 = BaseAddress;
      size_t v31 = BytesPerElement * v27;
      while (fwrite(v30, 1uLL, v31, v8) == v31)
      {
        v30 += BytesPerRow;
        if (!--Height) {
          goto LABEL_32;
        }
      }
      IOSurfaceUnlock(a1, 1u, 0);
    }
LABEL_25:
    BOOL v19 = 0;
LABEL_26:
    fclose(v8);
    return v19;
  }
  return 0;
}